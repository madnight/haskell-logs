00:13:08 <i12321> id is O(1)?
00:13:56 <Solonarv> i12321: it doesn't do anything, so, yes
00:14:00 <i12321> n! is O(n!)?
00:14:21 <i12321> [1..10] is O(?)
00:14:58 <koz_> i12321: [1..10] is O(1), because it has a fixed number of elements, and therefore can be produced in a fixed amount of time.
00:15:05 <Solonarv> f(n) is always O(f(n)), that's not a very useful statement
00:15:48 <koz_> It is also Omega(f(n)), while we're at it. :P
00:16:04 <Solonarv> unless you meant to ask whether n! takes O(n!) resources to calculate, in which case the answer is again yes - but this isn't a very instructive result, because O(n!) also includes anything that grows *slower* than n!
00:16:23 * hackage fromhtml 1.0.3 - Simple adapter for transformation of HTML to other formats  https://hackage.haskell.org/package/fromhtml-1.0.3 (MarekSuchanek)
00:16:41 <koz_> Solonarv just stated the reason why I give Theta bounds whenever possible.
00:16:51 <jpcooper> Morning. Let's say I have defined a `value = x` inside a where clause, and `value` is of type `D a b c`. GHC could do with some help to figure out what `a` is. `c` is a bit of a mouthful to write down, but GHC knows what it is anyway. Is it possible to communicate the type of `a` without communicating the rest of `D a b c`?
00:17:16 <Solonarv> jpcooper: you can write a _ in the type and let the typechecker fill it in
00:17:33 <jpcooper> Solonarv: Fantastic. I had no idea about this. What is this called?
00:17:37 <Solonarv> but I think you need a language extension for that and/or a flag to make this merely a warning instead of an error
00:17:44 <i12321> f(n) is always O(f(n)) means n^2 is O(n^2)?
00:17:48 <Solonarv> PartialTypeSignatures is the extension
00:17:51 <jpcooper> Thank you
00:18:44 <koz_> i12321: Are you referring to the literal function n^2, or the operation of computing the square of a number?
00:19:02 <Solonarv> i12321: do you actually know what the "big O" means, or are you just relying on vagueness and guesswork?
00:19:17 <Solonarv> also, (again!) what koz_ said is an important distinction
00:19:37 <i12321> the second
00:19:51 <Solonarv> okay
00:19:55 <koz_> Then still yes, although much as Solonarv said earlier, this isn't terribly accurate.
00:20:01 <i12321> I don't know big O notation
00:20:08 <Solonarv> look it up, then!
00:20:15 <koz_> i12321: Then I would advise learning it properly instead of randomly guessing.
00:21:34 <i12321> Data.List.permutations is O(n!)?
00:22:35 <koz_> i12321: There are n! possible permutations of a list of length n, yes. Assuming that all elements are unique of course.
00:22:42 <koz_> (if they're not, some will be identical)
00:28:10 <Solonarv> generally speaking, a function's runtime will be Omega(size of output)
00:30:46 * koz_ looked at the implementation of Data.List.permutations, expecting Jonson-Stenhaus-Trotter.
00:30:50 * koz_ was disappoint.
00:31:05 <koz_> (there may also have been a spelling error in that name collection up there)
00:32:12 <i12321> > foldl1 (*) [1..10]
00:32:15 <lambdabot>  3628800
00:33:16 <i12321> permutation a list that has 10 elements, it take so much time?
00:33:42 <koz_> i12321: It takes time _proportional_ to that.
00:34:01 <koz_> Because there are 10! possible permutations of a list of 10 (unique) elements.
00:34:21 <koz_> (it's a fairly easy induction proof)
00:37:24 <Bandu> this channel is about Cristiano Ronaldo?
01:07:18 <dminuoso_> Are there some notions of "distance" between types?
01:57:47 <[exa]> dminuoso_: types are syntactically differentiable (which may serve for constructing one kind of distances). Alternatively, HoTT has a pretty nice distance-like relation between types
01:59:19 <[exa]> dminuoso_: and for practical reasons, "size of the most general unifier" might be a pretty good metric
02:53:53 * hackage call-alloy 0.2.0.3 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.0.3 (marcellus)
02:54:58 <polygonXz> I would like to share with you a great website: https://moneyfree.co/?ref=3lDiIzIxcSimole et easy to use!
03:38:23 * hackage fromhtml 1.0.4 - Simple adapter for transformation of HTML to other formats  https://hackage.haskell.org/package/fromhtml-1.0.4 (MarekSuchanek)
03:50:37 <[itchyjunk]> What is ":" called? I forgot.
03:50:59 <tdammers> cons?
03:51:13 <[itchyjunk]> I was using to create list somehow i think? [a]:[b] gave me [a,b] ?
03:51:15 * [itchyjunk] googles
03:51:31 <Clint> a:[b] gave you [a,b]
03:52:07 <[itchyjunk]> ah i see thanks
03:52:50 <[itchyjunk]> if list = [a,b], does (x:list) give me "a" ?
03:53:13 <[itchyjunk]> Trying to make my way to recursion, but failing at this (x:xs) stuff.
03:53:54 <__monty__> > let (x:list) = ['a', 'b'] in x
03:53:57 <lambdabot>  'a'
03:55:02 <[itchyjunk]> hmmm
03:55:39 <[itchyjunk]> hmmmmmmmmmmmmm
03:56:05 <boxscape> [itchyjunk] do you know what a list looks like without syntax sugar?
03:56:27 <[itchyjunk]> i think [1,2,3] looks like 1:2:3 i think
03:56:31 <[itchyjunk]> unless : is a sugar too
03:56:48 <boxscape> not quite. It's 1:2:3:[], Or 1:(2:(3:[]))
03:56:55 <[itchyjunk]> ah
03:57:47 <boxscape> ':' is just a constructor, similar to "Just" for example, and we could give it a name, which might make it more understandable in terms of how it's actually built: Cons 1 (Cons 2 (Cons 3 []))
03:58:14 <boxscape> % data List a = Cons a (List a) | Nil
03:58:14 <yahb> boxscape: 
03:58:28 <boxscape> and then you can pattern match on a list just like on anything else, for example
03:58:38 <maerwald> Is there a library that helps me write exception-free code, e.g. by automatically catching IO exceptions in some interface or something?
03:58:43 <boxscape> % (Cons x rest) = Cons 1 (Cons 2 Nil)
03:58:43 <yahb> boxscape: 
03:58:46 <boxscape> % x
03:58:46 <yahb> boxscape: 1
03:58:47 <boxscape> % rest
03:58:47 <yahb> boxscape: ; <interactive>:4:1: error:; * No instance for (Show (List Integer)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
03:59:04 <boxscape> % data List a = Cons a (List a) | Nil deriving Show
03:59:04 <yahb> boxscape: 
03:59:09 <boxscape> % (Cons x rest) = Cons 1 (Cons 2 Nil)
03:59:09 <yahb> boxscape: 
03:59:11 <boxscape> % rest
03:59:12 <yahb> boxscape: Cons 2 Nil
03:59:13 <boxscape> there
03:59:38 <[itchyjunk]> hmm, why do you put ( ) around Cons x rest ?
03:59:46 <boxscape> no good reason actually
04:00:03 <boxscape> but if you had it as function argument like `f (Cons x rest) = ...` you would need them
04:00:23 <[itchyjunk]> ah
04:06:18 <[itchyjunk]> i am trying to say, given a list, give me the first element and create a new list with the first element missing.
04:06:49 <[itchyjunk]> so x:newlist = x:oldlist? hmm that doesnt make sense
04:08:04 <boxscape> the oldlist already contains its first element
04:08:16 <[itchyjunk]> right thats what i was thinking
04:08:37 <boxscape> so do you know what it should be then? :)
04:08:40 <[itchyjunk]> x:newlist = oldlist ? so it breaks the old into 2 things, first element and rest of the list?
04:08:45 <boxscape> that's right
04:08:48 <polyphem> [itchyjunk]: f (x:xs) = (x,xs) 
04:09:14 <[itchyjunk]> hmm whats the (x,xs) part doing?
04:09:14 <polyphem> [itchyjunk]: gives you a pair (firstelem,restoflist)
04:09:34 <polyphem> (,) is a pair in haskell
04:10:15 <polyphem> that funktion f will however explode if you pass it an empty list ...
04:12:17 <[itchyjunk]> shouldn't f x:xs = x create a function that takes a list and returns the first element?
04:12:41 <boxscape> yes, though since this is a function parameter you need to put parentheses around (x:xs)
04:13:23 <boxscape> @src head
04:13:24 <lambdabot> head (x:_) = x
04:13:24 <lambdabot> head []    = error "Prelude.head: empty list"
04:13:47 <[itchyjunk]> ah right parenthesis around function parameter
04:13:49 <[itchyjunk]> but why?
04:14:26 <polyphem> [itchyjunk]: its a complex pattern match so it needs parens
04:14:38 <[itchyjunk]> so recursive if if i don't new a new list but if i keep refrencing the same list while at the same time stripping it of it's elments?
04:15:02 <[itchyjunk]> is if*
04:15:06 <boxscape> in something like `f Just x` it wouldn't be clear if you're trying to define a function of 2 arguments or a function of one argument and pattern matching on the Maybe, without parens
04:15:22 <boxscape> s/without parens/if parens weren't necessary
04:15:28 <[itchyjunk]> ah right
04:16:26 <boxscape> [itchyjunk] if you write `f (x:xs) = ...` you are creating a new list on a function call, namely xs
04:17:00 <boxscape> well, I guess whether or not that's a "new list" depends on what exactly one means by that
04:17:29 <[itchyjunk]> if i write f (x:xs) = (x,xs) , the cardinality of list before i pass it for the function is 1 more than after i pass it?
04:17:57 <[itchyjunk]> once the functions runs, i have a xs but with one less element
04:17:59 <[itchyjunk]> ?
04:18:03 <boxscape> yes
04:18:17 <boxscape> though that function isn't recursive, since it doesn't call itself
04:18:18 <[itchyjunk]> wait, do i need it to be a tuple like that?
04:18:32 <boxscape> no, you can just return x or xs on their own if you want to
04:18:44 <[itchyjunk]> f (x:xs) = (x:xs) ?
04:18:52 <boxscape> that works but that's just f = id
04:19:08 <[itchyjunk]> ah
04:21:49 <[itchyjunk]> How would i say, this function should take a list and spit out (x,xs) then take xs and ... till the list looks like [] ?
04:22:41 <boxscape> so, if given a list [1,2,3,4], you would want this function to return (1,(2,(3,4)))?
04:23:45 <boxscape> or (1,(2,(3,(4,()))))
04:23:53 <[itchyjunk]> the second
04:23:56 <maerwald> hexagoxel: wondering why hangingTypeSignature is not the default. I think it should, because without it you cannot easily grep for type signatures anymore
04:24:03 <Bad_K4rMa> is there a good haskell book?
04:24:11 <boxscape> [itchyjunk] that's kind of impossible, since the type of the tuple would depend on the length of the list
04:24:22 <maerwald> when '::' is on the next line, then how do you grep for 'functionName ::'?
04:24:26 <[itchyjunk]> ah
04:24:45 <boxscape> [itchyjunk] you can probably kind of do it if you simulate dependent types but that's not something haskell is good at at the moment and also fairly advanced :)
04:24:59 <Taneb> Bad_K4rMa: yes. I'm fond of Programming in Haskell by Graham Hutton but there are other options too
04:25:23 <boxscape> @where haskellbook
04:25:23 <lambdabot> http://haskellbook.com
04:25:27 <boxscape> is recommended by some
04:25:35 <Bad_K4rMa> ahh nice thanks Taneb
04:25:36 <maerwald> boxscape: did you read it? :P
04:25:48 <boxscape> I read some of it
04:25:55 <maerwald> I've heard mixed reviews
04:26:03 <maerwald> some like the detail, others find it overly verbose
04:26:25 <boxscape> Still not sure how I feel about starting the book with lambda calculus
04:26:47 <[itchyjunk]> so id have to pad by list somehow to make it work?
04:27:08 <[itchyjunk]> [1,2,3,4,0] and recurse till 0?
04:27:10 <boxscape> [itchyjunk] by "pad" you mean bring the list to a fixed length?
04:30:09 <[itchyjunk]> hmm
04:30:43 <[itchyjunk]> in your first option i get a tuple as the last result?
04:31:07 <boxscape> the first option is just as impossible as the second option I'm afraid
04:31:36 <[itchyjunk]> so how does list recursion work?
04:33:13 <polyphem> > let f (a:[]) = [([a],[])] ; f (x:xs) = ([x],xs) : f xs in f "h123456"
04:33:15 <lambdabot>  [("h","123456"),("1","23456"),("2","3456"),("3","456"),("4","56"),("5","6"),...
04:33:32 <boxscape> [itchyjunk] if we use making a sum of a list of integers for example...
04:33:59 <boxscape> [itchyjunk] you would first think about what you want to do if the list is empty. In this case, an empty sum should be 0, so you can write `f [] = 0`.
04:34:28 <[itchyjunk]> okay
04:34:38 <boxscape> [itchyjunk] then you would think about what to do with the rest of the list, which of course depends greatly on what function you're actually implementing. In the case of sum, we want to take the first element and add it to the sum of the rest of the list
04:34:48 <boxscape> any idea how you might express that in code?
04:35:29 <boxscape> oh and I suppose I should have written `mySum [] = 0` rather than `f [] = 0`
04:35:55 <[itchyjunk]> f (number:list) = (sum+number,list)
04:36:01 <[itchyjunk]> i defined sum = 0 somewhere before 
04:36:34 <[itchyjunk]> oops
04:36:37 <[itchyjunk]> not quite
04:37:17 <[itchyjunk]> i want to store the stuff i add somewhere/somehow
04:37:32 <boxscape> you don't actually need to store it
04:38:06 <boxscape> remember, we're making a function that calculates the sum of a list, so we can reuse the function we're currently defining to get the sum of the rest of the list
04:38:49 <boxscape> so if you have `mySum []  = 0`, and in the next like we have `mySum (number : list) = ...`, then on the right side we can use `mySum list` to refer to the sum of the rest of the list
04:38:59 <[itchyjunk]> f (number:list) = (ineedanotherfunctionthatadds?,list)
04:39:13 <boxscape> so, this actually doesn't have anything to do with tuples
04:39:31 <boxscape> you only need tuples here if you want to return a tuple
04:39:33 <[itchyjunk]> hmm
04:39:35 <boxscape> but we want to return a number
04:40:14 <__monty__> Maybe sum with an accumulator is easier to grok?
04:40:29 <boxscape> Perhaps, I'm not sure
04:40:50 <boxscape> Seems like introducing an accumulator might make it more complex though
04:41:17 <__monty__> I know it's not simpler but from an imperative angle it does make it look like you "store" the running sum.
04:41:41 <[itchyjunk]> dont i need to return the sum and a shorter list?
04:41:52 <[itchyjunk]> or i dont need the list to get smaller either?
04:42:11 <boxscape> [itchyjunk] no, you don't need to return any list - you want to return a number. Instead, you call the function itself with a shorter list to calculate the result
04:42:27 <boxscape> i.e. the `mySum list` I wrote above
04:43:39 <[itchyjunk]> oh mySum (number:list) = number + mySum(number:list) ?
04:43:41 <[itchyjunk]> hmm
04:43:45 <boxscape> almost
04:44:16 <boxscape> except that now you're adding the first element back to the list, but you actually want to get the sum of the shorter list on the right-hand side
04:44:26 <boxscape> s/adding/prepending
04:46:04 <boxscape> right now what you would get if you called `mySum [1,2,3]` is `1 + mySum [1,2,3]`, but you want to get `1 + mySum [2,3]`
04:47:51 <[itchyjunk]> oh mySum (number:list) = number + mySum(number:(list !! 0)) ?
04:48:13 <boxscape> hm, you're getting further away ;)
04:48:19 <boxscape> you want `mySum list`
04:48:42 <boxscape> literally
04:49:12 <boxscape> so mySum (number:list) = number + mySum list
04:49:14 <[itchyjunk]> oh list on the rhs is the list on lhs minus number
04:49:23 * hackage amqp 0.19.1 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.19.1 (HolgerReinhardt)
04:49:23 <boxscape> that's right
04:49:51 <boxscape> % mySum [] = 0; mySum (number:list) = number + mySum list
04:49:51 <yahb> boxscape: 
04:49:57 <boxscape> % mySum [1..5]
04:49:57 <yahb> boxscape: 15
04:50:12 <[itchyjunk]> oh i was thinking about it but i didn't make the connection that mySum would automatically break this new list into number:list pattern
04:50:45 <[itchyjunk]> is this the elusive recursion? /0\
04:50:51 <boxscape> indeed!
04:51:15 <[itchyjunk]> wow, this is great. thanks!
04:51:48 <boxscape> so now what happens is if you have something like `mySum [1,2,3]` it gets evaluated to `1 + mySum [2,3]`, then `1 + (2 + mySum [3])`, then `1 + (2 + (3 + mySum []))`, and then `1 + (2 + (3 + 0)))`
04:51:53 <boxscape> you're welcome :)
04:52:40 <[itchyjunk]> ah thats where the defining the [] case comes in
04:52:57 <boxscape> exactly
04:54:35 <boxscape> [itchyjunk] so to be clear, when people say "recursion" they usually just mean that a function calls itself, like in this case mySum appears inside its own definition
04:54:55 <[itchyjunk]> right
04:55:13 <[itchyjunk]> self refrence and what not
04:55:16 <boxscape> yeah
05:55:53 <michael66> Can anyone come up with a function (Functor f, Functor g) => f a -> g b -> f ( g (a, b))?
05:57:15 <petersen> Does `cabal new-install` ignore --datadir?
05:57:35 <MarcelineVQ> It is possible
05:57:39 <Taneb> michael66: such a function does exist, and it's not too hard to write.
05:57:42 <MarcelineVQ> michael66: It is possible
05:57:43 <Taneb> Why do you need it?
05:57:58 <michael66> Taneb, apparently it does exist and it is an exam question
05:58:03 <petersen> Maybe I try opening a bug..
06:00:58 <Putonlalla> It's may be easier to start with `Monad m => m a -> m b -> m (m (a, b))` and generalize that, michael66.
06:01:36 <MarcelineVQ> michael66: The answer to most homework questions that have constraints in the type (like Functor) are to make use of the things the constraint provides you, in this case fmap. we need an f in the end so we probably want to start there. there's not much more to say without giving things away.
06:03:20 <MarcelineVQ> a typed hole can be used like this to ask the compiler what can fit    beb :: (Functor f) => f a -> f (a, a); beb x = fmap _thehole x
06:03:54 <munksgaard> I'm having problems compiling ghc 8.8.1. When running `./configure` I get `checking alignment of char... configure: error: cannot compute alignment (char)`. My config.log is here https://pastebin.com/Tf3K7kmR. Does anyone know what could be wrong?
06:07:03 <maerwald> gcc: error: unrecognized command line option '-V'
06:08:58 <maerwald> hard to figure out which errors are fatal in verbose mode
06:09:46 <fendor> @djinn (Functor f, Functor g) => f a -> g b -> f ( g (a, b))
06:09:46 <lambdabot> Error: Class not found: Functor
06:09:58 <fendor> @djinn (Monad f, Monad g) => f a -> g b -> f ( g (a, b))
06:09:59 <lambdabot> -- f cannot be realized.
06:10:18 <maerwald> is there a nice way to structure multiple 'm (Bool)' in something similar to MultiWayIf without executing all of them before the check?
06:10:21 <MarcelineVQ> fendor: if that had worked it would have gave away the answer which probably isn't in the spirit of exam questions :>
06:10:45 <fendor> MarcelineVQ, Right, sorry
06:10:50 <maerwald> basically, a monadic if elif
06:11:42 <munksgaard> maerwald: Hm, so perhaps I should get a newer version of gcc?
06:12:00 <maerwald> not sure, might be worth a shot, why are you compiling from source?
06:12:23 <jusss> how to express something like [1,2,3]:[0::-1] in haskell?
06:12:28 <munksgaard> I'm working on a server that I don't have root access to.
06:12:29 <jusss> slice in python
06:12:42 <maerwald> munksgaard: ?
06:13:01 <maerwald> that's not really an answer :>
06:13:11 <munksgaard> maerwald: I'm actually using `stack setup` to install something else, but that gave me an error that I think I've traced back to the fact that I'm not able to compile gcc.
06:13:18 <maerwald> you could try ghcup
06:13:24 <maerwald> the CentOS tarball might work
06:14:46 <maerwald> munksgaard: https://www.haskell.org/ghcup/
06:15:16 <maerwald> but if your gcc doesn't work, the installation method doesn't matter
06:17:47 <munksgaard> maerwald: That's a good point, but I don't think that'll make my `stack setup` work. For reference, I'm trying to install Futhark using their installation instructions, which essentially boil down to `stack setup && stack build && stack install`. However when running `stack setup` I get the following error https://pastebin.com/JPzTehgj
06:18:39 <munksgaard> Because that looks like there's an error happening when compiling ghc, I then tried to see if I could compile ghc myself, which led to the error above.
06:19:50 <munksgaard> Link to the futhark installation page, which also has a link to their github: https://futhark.readthedocs.io/en/latest/installation.html
06:20:56 <maerwald> You can tell stack to use an existing ghc. I would try to install a pre-compiled tarball first
06:21:46 <maerwald> Also, futhark seems to support cabal as well: https://github.com/diku-dk/futhark/blob/master/cabal.project
06:23:40 <yushyin> jusss: http://hackage.haskell.org/package/sliceofpy :P
06:28:05 <polyphem> let f fa gb = fmap (flip fmap gb . (,)) fa in f [1,2,3] (Just "b") -- fendor 
06:28:30 <polyphem> > let f fa gb = fmap (flip fmap gb . (,)) fa in f [1,2,3] (Just "b") -- fendor 
06:28:33 <lambdabot>  [Just (1,"b"),Just (2,"b"),Just (3,"b")]
06:31:23 * hackage mmsyn7h 0.5.0.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.5.0.0 (OleksandrZhabenko)
06:32:23 * hackage haskoin-store 0.19.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.19.4 (jprupp)
07:10:49 <hseg> Hi. I'm trying to do some computations with formal trigonometric polynomials, and can't figure out how to glue `linear` and `algebra` together to get what I want.
07:11:44 <hseg> Basically, I want polynomials in x1,...,xn,x1^{-1},...,xn^{-1}
07:12:00 <hseg> (with the intention of extracting the constant term once I'm done)
07:13:30 <hseg> n is fixed per-computation, but needs to be parametrized over
07:14:36 <hseg> Thought I could basically enocde this as a free algebra over Exp (Vector n Int)
07:16:26 <hseg> But I don't see how to construct a group algebra
07:17:29 <hseg> Seems I want a (Multiplicative m, Semiring r) => Algebra r m instance...
07:19:10 <hseg> It's unfortunate that the haddocks don't give you usages of a class (i.e. given a class C, the list of all functions C => t)
07:20:13 <Cale> Well, they kind of do... eventually. It's just not necessarily organised like that.
07:30:03 <boxscape> % f [] = unsafeCoerce (); f (x:xs) = unsafeCoerce (x, f xs)
07:30:04 <yahb> boxscape: 
07:30:12 <boxscape> % f [True, False] :: (Bool, (Bool, ()))
07:30:12 <yahb> boxscape: (True,(False,()))
07:30:24 <boxscape> it's somewhat surprising to me that this works so flawlessly
07:30:32 <boxscape> I suppose it makes sense though
07:32:49 <Taneb> boxscape: please never use that in code I have to run
07:32:51 <dminuoso_> boxscape: There's no guarantee it will work though.
07:33:01 <maerwald> is there a library for evaluating bash scripts?
07:33:02 <dminuoso_> boxscape: Depending on optimization flags and GHC versions it can suddenly stop working.
07:33:06 <boxscape> I see
07:34:31 <geekosaur> wouldn't that require reimplementing bash in haskell?
07:34:47 <Taneb> boxscape: if you're feeling brave you can use "unsafeCoerce" as a lens
07:34:53 <boxscape> interesting
07:35:15 <boxscape> (I have a version of this code with singletons by the way, that's why I got curious to try this in the first place)
07:35:29 <maerwald> geekosaur: yeah. But would be particularly interesting if you could evaluate *some* expressions without IO
07:35:48 <maerwald> basically, whnf vs nf
07:36:14 <maerwald> https://github.com/knrafto/language-bash is already quite a good parser
07:36:46 <maerwald> E.g. I'm thinking a bash config file with lots of assignments. Get those assignments with variable substitution applied
07:37:13 <Taneb> boxscape: using unsafeCoerce as a lens is (in some cases, if you're careful) safe, like Sum (3 :: Int) & unsafeCoerce +~ (4 :: Int) :: Sum Int, because "Sum Int -> Identity (Sum Int)" and "Int -> Identity Int" have the same runtime representaton (I think)
07:37:41 <geekosaur> internal variables and environment variables being conflated complicates that a bit
07:38:20 <geekosaur> not to say variables with special handling, but I'm not sure how many of those bash has (zsh has quite a few due to csh emulation)
07:38:34 <maerwald> yeah, in shell, the devil is in the details
07:38:37 <boxscape> Taneb hm, could you use coerce for that instead of unsafeCoerce?
07:39:00 <Taneb> I don't know
07:39:30 <geekosaur> and how they affect things, e.g. $CDPATH is fine for expansion but changes the behavior of cd and pushd
07:40:07 <Taneb> boxscape: yes
07:40:28 <boxscape> ah, nice
07:43:58 <boxscape> % _
07:43:58 <yahb> boxscape: ; <interactive>:1:1: error:; GHC internal error: `Ghci21.f' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
07:44:01 <boxscape> hmm
07:44:24 <geekosaur> still has that bug?
07:44:54 <boxscape> probably not I suppose but I'll check, if I can figure what caused it
07:45:11 <geekosaur> it's supposed to be an error. that it's that error is the bug
07:46:08 <boxscape> It's supposed to say that it found a hole, right?
07:46:16 <geekosaur> well, I suppose it would be a tyed hole with type 'a' these days. but it shouldn't produce that error, and I thought they'd fixed it at some point. it's ghci-specific iirc
07:46:58 <MarcelineVQ> % :! ghc --version
07:46:59 <yahb> MarcelineVQ: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
07:47:14 <Cheery> [1,2] >>= f where f x = [x,x+10]
07:47:25 <MarcelineVQ> huh, thought the bug was for older versions of 8 than that, 8.2 or 8.4 or something
07:47:27 <boxscape> how does one restart yahb again?
07:47:27 <Cheery> now, if 'f' could fail, what'd be similarly easy way to do this?
07:47:33 <MarcelineVQ> % :q
07:47:33 <yahb> MarcelineVQ: 
07:47:38 <boxscape> % _
07:47:42 <yahb> boxscape: ; <interactive>:1:1: error:; GHC internal error: `Ghci1.it' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
07:47:46 <boxscape> hm, okay
07:47:48 <Taneb> Cheery: fail in what sense?
07:47:56 <geekosaur> right, it works herein 8.8.1
07:48:10 <geekosaur> so yahb is running an 8.6 prerelease without the bug fix
07:48:13 <Taneb> geekosaur: works here in GHC 8.6.5
07:48:16 <boxscape> Yeah I thought it might have had something to do with my definition of f but apparently not
07:48:23 <Cheery> Taneb: m [a] -> (a -> m [b]) -> m [b]
07:48:29 <MarcelineVQ> Taneb: ditto
07:49:59 <geekosaur> boxscape, no, it's just a bug with typed holes and ghci in older ghc versions. don't recall when it was fixed but apparently somewhere between that 8.6.1 prerelease and 8.6.5
07:50:06 <boxscape> okay
07:50:22 <Cheery> hm. m [a] -> ([a] -> m [b]) -> m [b], so.. got to do [a] -> (a -> m [b]) -> m [b]
07:51:22 <kuribas> this looks interesting, anyone have some experience with it?  http://hackage.haskell.org/package/front
07:51:24 * hackage haskoin-store 0.19.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.19.5 (jprupp)
07:51:33 <kuribas> "front: A reactive frontend web framework"
07:52:00 <kuribas> "bring the power of GHC on client side with as less JavaScript as possible by the Fay." <= sounds interesting
07:53:38 <MarcelineVQ> kuribas: interesting, wonder if it's competative with miso
07:53:53 <kuribas> looks a bit preliminary though...
07:54:28 <MarcelineVQ> fay has been around for awhile a least
07:55:23 <hseg> Can someone explain how https://hackage.haskell.org/package/algebra-4.3.1/docs/Numeric-Algebra-Class.html#t:Algebra relates to the mathematical concept? Not clear how to use the class
07:56:39 <Cheery> solved, it's concatMapM from Control.Monad.Extra
07:58:17 <kuribas> MarcelineVQ: how does fay compare with purescript?
08:00:25 <MarcelineVQ> dunno
08:01:16 <cupofchino> To join `Num`, a type must already be friends with `Show` and `Eq`.
08:01:49 <MarcelineVQ> Num doesn't require Eq or Show
08:01:50 <cupofchino> really? how does `*` works using `Eq` and `Show` only?
08:02:01 <cupofchino> oh
08:02:26 <MarcelineVQ> perhaps your use of something that required Num happened to also require Eq and Show
08:02:26 <cupofchino> what does "friends" mean then
08:02:46 <MarcelineVQ> no idea, I don't know where you heard that
08:02:58 <cupofchino> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
08:03:03 <geekosaur> that changed some time back, but Eq and Show have nothing to do with * as such. what you do afterward may care, especially if the code assumes Haskell '98 where those were prerequisites ("superclasses" but I hate that name)
08:03:22 <geekosaur> in particular Show will matter if you want to see the result
08:03:46 <kuribas> MarcelineVQ: the model seems more similar to threepenny-gui
08:04:45 <MarcelineVQ> looks like that book's showing its age
08:05:24 <cupofchino> lol'ed "For instance, the length function has a type declaration of length :: [a] -> Int instead of having a more general type of (Num b) => length :: [a] -> b."
08:05:35 <cupofchino> "I think that's there for historical reasons or something, although in my opinion, it's pretty stupid"
08:05:41 <cupofchino> any suggestion then?
08:05:56 <Ferdirand> :t length
08:05:58 <lambdabot> Foldable t => t a -> Int
08:06:28 <geekosaur> you'd be horrified
08:06:29 <maerwald> is there a foldrM that can short-circuit (and not run all effects)?
08:06:31 <geekosaur> :t length
08:06:32 <lambdabot> Foldable t => t a -> Int
08:06:40 <geekosaur> that book is quite old at this point
08:06:44 <maerwald> Maybe I need Selective
08:07:02 <cupofchino> still an Int, why isnt it an Integral or Num for that matter
08:07:08 <MarcelineVQ> The usual retort is that if you're computing the length of a list longer than Int can hold there's something bad about the approach
08:07:15 <geekosaur> :t genericLength
08:07:17 <lambdabot> Num i => [a] -> i
08:07:17 <cupofchino> lol that makes sense
08:07:18 <Taneb> MarcelineVQ: why not a Word?
08:07:36 <Ferdirand> :t fromIntegral . length
08:07:38 <lambdabot> (Num c, Foldable t) => t a -> c
08:07:38 <geekosaur> hm, now why isn't that one using Foldable?
08:08:37 <Taneb> Also, genericLength tends to be slower than length even when using Int
08:08:54 <boxscape> cupofchino > any suggestion then? -- Programming in Haskell by Graham Hutton, or haskellbook.com , or https://github.com/bitemyapp/learnhaskell , in particular https://www.seas.upenn.edu/~cis194/spring13/lectures.html from that page if you want something that's free
08:09:04 <geekosaur> they left
08:09:08 <boxscape> oh
08:09:50 <Putonlalla> @let mostGenericLength = foldr (const succ) minBound
08:09:52 <lambdabot>  Defined.
08:09:59 <boxscape> :t mostGenericLength
08:10:00 <lambdabot> (Foldable t, Enum b1, Bounded b1) => t b2 -> b1
08:10:03 <Putonlalla> > mostGenericLength "yeah" :: Word
08:10:05 <lambdabot>  4
08:10:49 <boxscape> > mostGenericLength "yeah" :: Bool
08:10:51 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
08:12:03 <Taneb> > mostGenericLength "hello" :: Int
08:12:05 <lambdabot>  -9223372036854775803
08:12:14 <Taneb> Putonlalla: I think this definition isn't quite right
08:12:28 <MarcelineVQ> typechecks, ship it
08:13:07 <boxscape> > mostGenericLength "hello" :: Integer
08:13:09 <lambdabot>  error:
08:13:09 <lambdabot>      • No instance for (Bounded Integer)
08:13:09 <lambdabot>          arising from a use of ‘mostGenericLength’
08:13:15 <boxscape> it isn't more generic than genericLength, either
08:13:34 <Putonlalla> It's both generic and calculates length. Perhaps you just need to adjust your expectations.
08:14:25 <geekosaur> -9223372036854775803 didn't look quite right as a length
08:14:58 <Ferdirand> @let mostGenericLength = foldr (const succ) (toEnum 0)
08:14:59 <lambdabot>  .L.hs:161:1: error:
08:14:59 <lambdabot>      Multiple declarations of ‘mostGenericLength’
08:14:59 <lambdabot>      Declared at: .L.hs:160:1
08:15:27 <boxscape> % mostGenericLength = foldr (const succ) (toEnum 0)
08:15:27 <yahb> boxscape: 
08:15:32 <boxscape> % :t mostGenericLength
08:15:32 <yahb> boxscape: (Foldable t, Enum b1) => t b2 -> b1
08:16:09 <Putonlalla> Not that I would ever advocate using any of these...
08:17:43 <boxscape> % genericLength (genericReplicate ((maxBound :: Int) + 2) 'a') :: Int
08:17:43 <yahb> boxscape: 0
08:18:16 <boxscape> wait
08:18:23 <boxscape> % genericLength (genericReplicate (fromIntegral (maxBound :: Int) + 2) 'a') :: Int
08:18:24 <yahb> boxscape: *** Exception: heap overflow
08:18:30 <boxscape> ah, that's better
08:22:06 <xeno> which ghc options should I use to get as much debug info as possible? preferably both stack trace and variable values 
08:23:06 <asdsadsad> sorry boxscape, i exited too early
08:23:10 <solonarv> to enable "stack traces", you need to compile with profiling enabled and tell ghc what sort of profiling info it should generate
08:23:15 <asdsadsad> i saw your recommendation in the logs tho, thanks!
08:23:23 <boxscape> sure, no problem
08:23:42 <solonarv> there isn't anything that will automagically print variable values, but you can use ghci's debugger or just insert 'print's in the relevant places
08:27:34 <xeno> solonarv: -prof -fprof-auto ?
08:28:57 <solonarv> xeno: yeah, that'll work
08:29:19 <solonarv> note that if you're using libraries, those won't have profiling info, which might not be what you want
08:30:02 <xeno> getting "Perhaps you haven't installed the profiling libraries for package" <my application>
08:31:16 <solonarv> with cabal, this is very simple: you just pass '--enable-profiling' to whichever cabal command you are using
08:31:35 <solonarv> if you are using something else then I don't know if there is a simple way to take care of that
08:31:43 <asdsadsad> haskell have no way of proving that my implementation of `Ord` on some type 'A` satisfy transivity, etc etc is there?
08:32:28 <solonarv> asdsadsad: *proving*, no; but property tests are possible
08:32:51 <maerwald> shouldn't foldlM short-circuit?
08:33:38 <Cale> asdsadsad: That's generally correct. For certain types, you might be able to encode a proof for the DataKinds-lifted values, but that's often not going to be very useful, and since Haskell has general recursion anyway, proofs of that sort aren't all that solid.
08:34:19 <Cale> maerwald: In what way? It's got to carry out all the effects at least.
08:34:35 <maerwald> Cale: I want to short-circuit the effects
08:34:44 <maerwald> cannot figure out how to do that without manual recursion
08:35:20 <Cale> You could probably use ContT to do it ;)
08:35:23 <maerwald> Maybe I want Selective lol
08:35:30 <solonarv> maerwald: this looks like the sort of thing you'd find in monad-loops, maybe
08:35:31 <maerwald> nah, ContT is too heavy
08:35:34 <solonarv> have you looked there?
08:35:35 <Cale> callCC $ \shortcircuit -> ...
08:35:51 <maerwald> it's a trivial loop
08:36:02 <solonarv> aye, monad-loops is full of those!
08:36:08 <geekosaur> wouldn't short circuiting be more of an unfold?
08:36:19 <geekosaur> in some sense
08:36:24 <Cale> Just writing a loop by hand in a let-block immediately preceding its use is what I usually do though, yeah
08:37:12 <Cale> You can define custom loop combinators, but you also have to be able to remember what they all mean.
08:37:15 <geekosaur> meh, probably not. manual loop is probably easier than trying to find which loopy construct would work
08:37:30 <solonarv> well, consider for example: allM [] = True; allM (mx:mxs) = do x <- mx; fmap (x &&) (allM mxs)
08:37:36 <maerwald> Cale: https://git.io/JvJFd
08:37:45 <maerwald> don't think that justifies ContT :P
08:37:58 <solonarv> you can imagine a short-circuiting version that doesn't run (allM mxs) when 'x' is False
08:39:10 <Cale> maerwald: It might be more readable to move the catMaybes and fmap parseAbs to the argument in the following line
08:39:35 <solonarv> maerwald: this looks like it could be done using the Alternative (MaybeT m) instance
08:40:31 <Cale> MaybeT is an option, indeed
08:40:40 <solonarv> go paths = asum [(s </> ex) <$ (guard =<< eExists s) | s <- paths]
08:41:48 <solonarv> h, sprinkle a liftIO and a runMaybeT in there somewhere
08:42:10 <maerwald> we are clearly golfing :P
08:42:31 <solonarv> I wouldn't even consider MaybeT golfing, tbh
08:42:59 <solonarv> in my mind, usage of its Alternative instance very clearly encapsulates "first thing that works/succeeds"
08:43:30 <maerwald> wait, shouldn't that just work with plain IO?
08:43:36 <Cale> This case might be a little too simple to warrant using it, but in a slightly more complicated situation, I'd start to find it more attractive
08:43:58 <Cale> IO's Alternative instance handles exceptions
08:44:20 <Cale> You could possibly do it that way
08:45:21 <solonarv> you could use 'doesFileExist >=> guard' and then use IO's Alternative instance, yes
08:45:33 <solonarv> but I don't like that at all! :P
08:45:58 <solonarv> you could of course juggle some work between eExists and (what you called) 'go'
08:46:49 <maerwald> yes it does
08:46:50 <maerwald> handleIOError (\_ -> pure Nothing) $ fmap Just $ asum [(s </> ex) <$ (guard =<< eExists s) | s <- sPaths]
08:46:58 <maerwald> no transformers
08:47:35 <maerwald> but it doesn't seem to short-circuit :P
08:47:49 <maerwald> oh wait it does
08:47:51 <maerwald> good
08:51:52 <solonarv> I left a slightly-more-golfed approach as a comment
08:52:40 <solonarv> oh, your 'sPaths <-' line I think can just be 'sPaths <- mapMaybe parseAbs <$> getSearchPath'
08:59:02 <jusss> how to optimize this code? https://paste.ubuntu.com/p/NtScPPQ3hb/
08:59:35 <maerwald> solonarv: never used the <$ thing
09:00:12 <jusss> this cause codewars run timeout, but I don't know where it can be optimized
09:00:20 <maerwald> but it's a nice operator, clearer than fmap . const
09:02:05 <zebrag> import Data.Functor.Identity (Identity) -- How do I really import Identity?
09:02:29 <zebrag> obviously the above doesn't work
09:03:17 <zebrag> streange, there is this very code there: https://taylor.fausak.me/2015/05/14/monad-transformers/
09:04:09 <zebrag> I might have found what's wrong
09:04:28 <jusss> how to check a list is only one element?
09:04:34 <jusss> has
09:05:03 <zebrag> pattern matching?
09:05:07 <solonarv> zebrag: that import you wrote only imports the *type* 'Identity'
09:05:10 <asdsadsad> there's a constant time solution to this
09:05:11 <asdsadsad> https://www.youtube.com/watch?v=uCsD3ZGzMgE
09:05:11 <solonarv> not the constructor
09:05:17 <asdsadsad> jusss
09:05:35 <zebrag> solonarv: okay, nice
09:06:09 <zebrag> how do I import the constructor?
09:06:16 <solonarv> to import the constructor as well, write 'import Data.Functor.Identity (Identity(Identity))'
09:06:26 <zebrag> ok, tx
09:06:29 <solonarv> or Identity(..) to import all the constructors and fields
09:07:01 <hololeap> probably want Identity(..) or Identity(Identity, runIdentity)
09:07:28 <zebrag> I only want to provide WriterT with Identity
09:07:40 <zebrag> do I need runIdentity?
09:08:09 <hololeap> zebrag: you can just use the Writer type synonym and its functions if that's all you need it for
09:08:41 <hololeap> type Writer w = Writer t Identity
09:08:48 <hololeap> oops, type Writer w = WriterT t Identity
09:08:50 <zebrag> hololeap: ok, wasn't in the first returned lines w. hoogle
09:09:00 <hololeap> it's in Control.Monad.Writer
09:09:29 <fresheyeball> is there a way to perform this operation?
09:09:38 <hololeap> grr, type Writer w = WriterT w Identity
09:09:50 <fresheyeball> Monad m => (a -> m a) -> m (a -> a)?
09:09:59 <fresheyeball> I suspect no
09:10:23 <hololeap> fresheyeball: no, (a -> m a) is more "powerful" than m (a -> a)
09:11:04 <hololeap> in the first one, the context "m" is determined by the argument "a"; in the second one, the context "m" is given outright
09:11:08 <solonarv> \_ -> pure id -- ;)
09:11:32 <dminuoso_> % :t const (pure id)
09:11:32 <yahb> dminuoso_: Applicative f => b -> f (a -> a)
09:11:37 <dminuoso_> Not quite!
09:12:02 <dminuoso_> (And no, monomorphizing arbitrarily is not allowed under the rules of code golfing)
09:12:04 <solonarv> it's more general than what fresheyeball asked for, but it is a valid implementation of that type!
09:12:17 <dminuoso_> It violates the sacred code golf rules.
09:12:21 <solonarv> surely providing a more general answer is, indeed, allowed
09:12:31 <dminuoso_> Mmm
09:12:53 <dminuoso_> solonarv: By that logic, wouldn't undefined be the ultimate answer to everything?
09:12:55 <hololeap> :t \a -> pure (const a)
09:12:57 <lambdabot> Applicative f => a -> f (b -> a)
09:13:10 <solonarv> well, 'undefined' is bottom which is boring
09:14:06 <zebrag> hololeap: What's wrong with: :t \w -> W.WriterT w Identity, says "couldn't match expected types..."
09:15:14 <MarcelineVQ> :t WriterT
09:15:16 <lambdabot> m (a, w) -> WriterT w m a
09:15:31 <solonarv> fresheyeball: anyway, I suspect you wanted a function that interchanges nicely with all the other Functor/Applicative/Monad operations
09:15:52 <fresheyeball> nah, I was just avoiding updating my nice pure api with an `m`
09:15:57 <solonarv> in that case the answer is no; a concrete counterexample is choosing m ~ Maybe
09:15:59 <hololeap> zebrag: i'm not sure you're using it correctly. that isn't typical usage
09:16:07 <fresheyeball> since it's not possible, then I just need to add the `m` and that's all there is to it
09:16:12 <solonarv> then you can easily see that this can't be done
09:16:17 <solonarv> fresheyeball: looks like it!
09:16:37 <solonarv> of course for *some* choices of m it can be done
09:17:02 <solonarv> with m ~ ((->) r) it's just 'flip', for example
09:17:48 <hololeap> zebrag: if you just wanted to create a Writer
09:18:02 <hololeap> use `writer :: (a, w) -> Writer w a`
09:20:17 <zebrag> hololeap: I should take it a little bit more slowly; I'll come back later with more questions; because obviously there is something I'm doing wrong
09:22:54 * hackage taskell 1.9.1.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.9.1.0 (smallhadroncollider)
09:22:55 <hololeap> zebrag: typically, using Writer would look like "runWriter $ do ..."
09:23:33 <solonarv> zebrag: when you say ':t \w -> Writer w Identity', you are mixing the type and value levels
09:23:39 <hololeap> and you would use `tell` to write to it
09:27:20 <hololeap> Writer by itself isn't that useful imo. you can get the same functionality with mconcat or foldMap
09:30:35 <zebrag> solonarv: yes, I know, I'm all mixed up there; I usually know my type constructor from my data constructor... I'm working on it and come back later
09:42:02 * hackage xrefcheck 0.1.0.0 -   https://hackage.haskell.org/package/xrefcheck-0.1.0.0 (gromak)
10:06:11 <hololeap> @unmtl State Int Bool
10:06:11 <lambdabot> Int -> (Bool, Int)
10:06:47 <hololeap> why is State = (s -> (a,s)) instead of (s -> (s,a)) ?
10:07:40 <hololeap> it would make more sense to me for it to be the second, since (s,a) is a proper Functor in a
10:08:23 * hackage log4hs 0.6.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.6.0.0 (gqk007)
10:13:01 <MarcelineVQ> it would
10:20:43 <koz_> My guess? Hysterical raisins.
10:27:24 <dminuoso_> hackage: An even better reason would be to emphasize the adjunction.
10:28:03 <dminuoso_> hololeap:
10:28:05 <dminuoso_> As in: (s (->)) :.: ((,) s)
10:28:40 <MarcelineVQ> dminuoso_: that was obvious to everyone
10:32:25 <Cheery> hyping about adjunction feels a bit like hyping about equivalences
10:33:39 <hololeap> would this break any of the applicative/monad laws? https://gist.github.com/78cbf828fd0b1d76e508f0880b851d6f
10:33:43 <Cheery> though.. maybe it'd be worth hyping if it new stuff.
10:34:41 <koz_> hololeap: Isn't that just WriterT Int?
10:35:03 <koz_> Oh wait, never mind, didn't read far enough. :P
10:35:26 <Cheery> they should not be hard to check.
10:35:47 <koz_> hololeap: pure id <*> v = v
10:35:49 <Cheery> just not remembering in detail.. It had associativity and identities right?
10:35:51 <koz_> I think you fail that one.
10:39:06 <Cheery> so that's a counter in a context.
10:39:36 <Cheery> pure x starts a new counter from zero, the 'bind' sums counters
10:40:05 <Cheery> oh the 'bind' includes addition.. it's counting binds
10:40:35 <koz_> Cheery: <*> doesn't just sum counters - it sums, _then_ also increments. This is what fails the law I pasted.
10:40:42 <solonarv> indeed
10:40:58 <koz_> pure id <*> v doesn't equal v then, because the former will have a counter value of n + 1, but the latter would only be n.
10:41:05 <solonarv> a quick way to think about this is: your type is WriterT with an unlawful 'Monoid' instance
10:41:58 <amalloy> i'm not sure i would call it WriterT if there's no way to indicate what you want to write
10:42:21 <koz_> amalloy: IWillWriteForYouT is a bit of a mouthful. :P
10:42:25 <koz_> GhostWriterT?
10:42:39 <solonarv> oh, I can even tell you exactly what the problem is!
10:43:02 <solonarv> the semigroup operation x <> y = x+y+1 does have an identity element, namely (-1)
10:43:25 <koz_> solonarv: So pure needs to staple on -1?
10:43:27 <solonarv> but your 'pure' adjoins something other than the identity element! so this is wrong
10:43:35 <koz_> That's... mind-bending.
10:43:51 <solonarv> 'pure' needs to staple on 'mempty', yes
10:44:10 <solonarv> if x <> y = x+y+1, then mempty = -1
10:44:19 <hseg> Can someone explain https://hackage.haskell.org/package/algebra-4.3.1/docs/Numeric-Algebra-Class.html#t:Algebra ? The instances are unclear, and I'm having a hard time finding functions making use of the class
10:44:25 <koz_> I guess in general, if x <> y = x + y + k, then mempty is -k?
10:44:51 <koz_> hseg: How's your algebra?
10:44:52 <solonarv> again, this is just WriterT specialized to a particular choice of monoid - or it would be, if it were lawful
10:44:58 <solonarv> koz_: looks like it to me
10:45:04 <koz_> solonarv: TIL.
10:45:23 <koz_> hseg: This is all stuff that's very 'mathy'. If you're not up with the maths, it will be super-unclear.
10:45:28 <hseg> koz_: I know what an algebra over a ring is: just a ring extension
10:45:46 <hseg> I know the maths, am having trouble seeing the relation between the haskell and the maths
10:45:47 <solonarv> koz_: I actually just figured this out in my head as I typed it
10:46:17 <solonarv> I went from "this doesn't have an identity element" to "wait, (-1) <> (-1) = (-1)" to "oh"
10:46:42 <koz_> It's like the integer line, but the 'middle' got 'moved' to the 'left'.
10:46:48 <solonarv> exactly!
10:46:49 <koz_> (it could also be 'moved' to the 'right' I guess)
10:46:52 <hseg> solonarv: It is basically your original monoid under the isomophism (-k)
10:46:53 <koz_> Something something infinity.
10:47:17 <hseg> solonarv: The salient point here is that you actually have a group, so -k is inverted by +k
10:50:38 <hseg> koz_: Basically, what I'm trying to construct is the ring of polynomials in x1...xn and their inverses
10:52:36 <hseg> The main roadblock is that I'm trying to do this by constructing the group algebra on Exp (Vect n Int), but the lack of clarity in the Algebra class makes this difficult
10:53:04 <hseg> I mean, even the tensor algebra example there isn't clearly related to the tensor algebra of a ring
10:53:54 <hseg> (Side question: Given a class C, how do I search for functions of type C => t ?)
10:55:37 <solonarv> hseg: enter that type into hoogle, perhaps?
10:55:44 <solonarv> I don't have anything better, sadly :(
10:56:11 <MarcelineVQ> I think hoogle used to be better with classes
10:56:36 <hseg> Not too helpful -- online hoogle doesn't index kmett's algebra, and local hoogle doesn't allow me to disambiguate
10:56:37 <MarcelineVQ> e.g. Applicative => a -> f a is result 4 on a search
10:58:42 <hseg> koz_: I mean, an algebra *is* given by the multiplication coefficients of its basis...
10:59:59 <hseg> ah... the `a` paremeter in Algebra r a is the *basis* of the algebra...
11:00:04 <fog> ok, i managed to figure how to write HFoldable2; https://gist.github.com/fog-hs/a0bbf93f579999f4d86e9124168c50fb
11:00:10 <solonarv> oooh, *that*'s what that means!
11:00:43 <fog> im going to extend it so the "actions" can take 3 params
11:01:35 <fog> at the moment its just (a->b->b) between a pair of subsequent hetrogenous values of types a,b
11:01:37 <hseg> OK, so the hoogle xrefs in algebra are messed up
11:02:12 <fog> and then to extend it to be over a tree or HFree
11:02:35 <hseg> e.g. (Commutative k, Rng k) => Algebra k TrigBasis has source linked to https://hackage.haskell.org/package/algebra-4.3.1/docs/src/Numeric-Algebra-Class.html#line-140, when it should be https://hackage.haskell.org/package/algebra-4.3.1/docs/src/Numeric-Coalgebra-Trigonometric.html#line-140
11:02:55 <solonarv> oh, I noticed that too
11:08:50 <fog> ok, i made some ctrl-h changes, it should be better now; https://gist.github.com/fog-hs/a0bbf93f579999f4d86e9124168c50fb
11:09:32 <hseg> Still doesn't make sense. Besides the fact that the structure coefficients should be constant across the class, the type is wrong -- with Vec r a ~ (a -> r), you should have mult :: (a -> a -> Vec r a) -> (Vec r a -> Vec r a -> Vec r a)
11:09:41 <hseg> unless mult is something else...
11:10:24 * hackage hledger-lib 1.16.2 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.16.2 (SimonMichael)
11:10:36 <hseg> which would make sense, given that the instance (TriviallyInvolutive r, Rng r) => Algebra r QuaternionBasis doesn't seem to be doing that
11:11:24 * hackage hledger-web 1.16.2, hledger-ui 1.16.2, hledger 1.16.2 (SimonMichael)
11:11:29 <hseg> Ah! mult is just encoding the structure coefficients...
11:13:03 <hseg> Still odd that (a -> a -> r) is appearing in negative position here, however...
11:15:04 <TheCommieDuck> Is there a nice way to have transitive typeclasses? like HasX Foo, HasY Foo, HasFoo Foo where foo = id, HasFoo B where foo = somethingOnB...then automagically getting HasX B and HasY B?
11:15:28 <TheCommieDuck> I'm under the impression instance HasFoo y => HasX y doesn't do what I want.
11:15:42 <hseg> So it's basically taking any axa matrix over r and mashing it into the structure coefficients of the algebra? (e.g. the quaternion algebra example symmetrizes the multiplication with the real part)
11:16:13 <fog> it doesnt need to uncurry the basecase, since the list is hetrogenous it can store it directly
11:17:37 <fog> TheCommieDuck, are you trying to write Has a c => (Has a b,Has b c) ?
11:18:00 <fog> class Has a b where to :: a -> b
11:18:14 <TheCommieDuck> I think so?
11:18:49 <TheCommieDuck> like I have x foo already, but I'd like to do x (foo, blah) or x (bar {_foo = foo})
11:19:11 <fog> instance (Has a b,Has b c) => Has a c where to a = to @b @c ((to @a @b) a)
11:20:24 * hackage tree-sitter 0.8.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.8.0.0 (tclem)
11:21:07 <fog> ah, no because b is ambiguous or Undecidable 
11:21:44 <fog> you would have to make something like "via" that could take @a @b @c type applications
11:22:19 <TheCommieDuck> I mean I could just jump a step up and instead of HasX a constraints, just use HasFoo constraints
11:22:21 <fog> i wonder how you would be able to make a list of these...
11:23:17 <fog> there is no problem with expanding Has a b instead of using a synonym of it for HasA b instances?
11:23:47 <fog> like, why name them all since they should basically be defined by the extra parameter?
11:23:56 <TheCommieDuck> very true
11:24:01 <fog> you can even then have it be polykinded
11:24:15 <MarcelineVQ> TheCommieDuck: you can explore https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#functional-dependencies and see if any of that can be applied to what you're doing
11:24:37 <fog> with Has taking four arguments instead of 2, with the first 2 being the kinds of the types a,b
11:25:41 <fog> which basically then allows you to do something like a class at type level, making instances for different kinds instead of different types - but instead of having an explicit kind signature, we just use the levity collapse to write all the levels in one type family instance
11:26:33 <TheCommieDuck> yeah I was using HasX a rather than Has a x because...dunno
11:26:38 <TheCommieDuck> nicer looking?
11:26:41 <TheCommieDuck> but that's wrong
11:26:42 <fog> but the trouble you have remains as to how to direct the compiler to which sequence of available instances to use
11:27:29 <fog> so you need the intermidiate type applications somehow
11:27:30 <TheCommieDuck> seems like makeFields with lenses automatically adds in functional dependencies
11:28:24 * hackage tree-sitter-java 0.6.1.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.6.1.0 (tclem)
11:30:23 * hackage tree-sitter-go 0.4.1.0 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.4.1.0 (tclem)
11:31:53 * hackage tree-sitter-json 0.6.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.6.0.0 (tclem)
11:34:24 * hackage tree-sitter-python 0.8.1.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.8.1.0 (tclem)
11:37:24 * hackage tree-sitter-ruby 0.4.1.0 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.4.1.0 (tclem)
11:38:01 <hseg> Ah... Now I get it -- writing Vec r a = a -> r, with a the basis for Vec r a, mult :: Vec r (a,a) -> Vec r a. Vec r (a,a) is the tensor square of Vec r a. Therefore, mult encodes the structure coefficients.
11:40:53 * hackage tree-sitter-tsx 0.4.1.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.4.1.0 (tclem)
11:44:01 <moet> > (+1) 5
11:44:03 <lambdabot>  6
11:44:05 <moet> > (-1) 5
11:44:07 <lambdabot>  error:
11:44:07 <lambdabot>      • Could not deduce (Num t0)
11:44:07 <lambdabot>        from the context: (Num t, Num (t -> t1))
11:44:14 <moet> > :t (-1)
11:44:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:44:48 <moet> uh, anyway, i'm trying to make a section using (-) where the 1 is the second argument.. a sub1 function, and finding that it doesn't behave the same way as (+)
11:44:54 <moet> any suggestions?
11:45:49 <glguy> > (subtract 10) 100
11:45:51 <lambdabot>  90
11:45:51 <MarcelineVQ> moet: subtract exists for this reason
11:45:58 <moet> til, thank you
11:46:06 <glguy> > (- 10)
11:46:08 <lambdabot>  -10
11:47:07 <moet> it's interesting that the grammar special cases (- 1) to be the same as (-1) .. i'd expect the space to be consistently treated as application
11:47:22 <glguy> number literals are all non-negative
11:47:37 <glguy> -1 is the same as - 1; a negated one
11:47:57 <glguy> > (-(1), -1) -- same thing
11:48:00 <lambdabot>  (-1,-1)
11:48:18 <glguy> it's not a special case
11:49:01 <moet> does that mean that in `(- 1)` the `-` is treated as the `negate` function instead of the normal `-` (subtraction) function?
11:49:27 <glguy> right: (-1) is (negate 1)
11:49:54 * hackage tree-sitter-typescript 0.4.1.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.4.1.0 (tclem)
11:50:24 <moet> so there is a special case there.. `- 1` is `negate 1` whereas `2 - 1` is `subtract 1 2`
11:50:45 <moet> the special case being the choice of what function the `-` corresponds to..
11:52:00 <moet> or something
11:52:16 <moet> i dunno, anyhow, Prelude.subtract solves my problem; thanks!
11:52:29 <jle`> the - token is the special case
11:52:38 <jle`> not a function
11:55:01 <moet> yes, i meant the treatment of the token :)
12:10:40 <hseg> Why is such an instance head forbidden without FlexibleInstances? instance (Factorable a, Semiring r) => Algebra r (MonoidBasis a)
12:11:40 <hseg> (using the monoid algebra as a toy scenario to try and understand the Algebra class)
12:14:31 <kw> Is there any particular reason that Strict.Map doesn't isn't newtype wrapped to have strict instances?
12:15:46 <geekosaur> only the functions are different; the Map itself is the same
12:16:20 <geekosaur> and it's considered useful to be able to mix strict and lazy operations on the same Map
12:17:22 <kw> Yep. But it could use, e.g. `newtype Map k v = Lazy{ getMap :: Lazy.Map k v } to have strict fmap, etc.
12:17:34 <kw> Anybody know why it doesn't?
12:17:57 <cdunklau> so i import Data.Tree, and i can use it, but i don't see it in base... how can i tell where it came from using ghci
12:19:03 <cdunklau> nm, ghc-pkg list
12:19:09 <solonarv> moet: space does not denote application, it acts only as a separator
12:20:15 <fendor> @src (<)
12:20:15 <lambdabot> x < y = case compare x y of
12:20:15 <lambdabot>           LT -> True
12:20:15 <lambdabot>           _  -> False
12:22:18 <hseg> Hrm. Is there some way of saying "derive all possible classes via the newtype isomorphism, except for this one class I want to define myself"?
12:22:28 <geekosaur> nope
12:23:38 <hseg> OK, then how about "derive all classes with instances of form instance C a => C (N a) where {f = f; ...}" ?
12:24:38 <hseg> Was under the impression the GND would give me that, but it isn't smart enough to insert the obvious constraint.
12:26:10 <geekosaur> I think any "derive all known classes {where <condition>}" runs into the question of classes defined after the code was written. meaning recompiling later might unexpectedly change the derived classes
12:26:18 <geekosaur> an explicit list is always going to do the same thing
12:26:36 <solonarv> yes, I was trying to figure out how to say that
12:26:43 <solonarv> geekosaur: beat me to the punch :D
12:28:26 <hseg> Hm. In a usecase where there are finite differences between the type and its newtype, I'd want typeclass resolution to look at the base type if checking for the newtype failed. Other libraries can't be expected to know about my newtype
12:28:38 <hseg> ... It's basically the orphan instance problem all over again
12:28:46 <hseg> (though with narrower scope)
12:29:46 <fendor> @src (<) :: Ord a => [a] -> [a] -> Bool
12:29:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:29:48 <geekosaur> coerce? which you have to request explicitly; this is generally a good thing in Haskell
12:30:21 <hseg> OK, that makes sense
12:30:57 <bitmapper> i don't know why i did it but i did do it
12:31:00 <bitmapper> Yale Haskell Y2.0.5   ECL version 16.1.3 on x86_64
12:32:20 <geekosaur> there was at one point a postprocessor from yhc core to jvm, iirc…
12:33:15 <bitmapper> no, there was not
12:33:33 <bitmapper> there was yhc core -> erlang, and yhc core -> grin
12:35:03 <geekosaur> whoops, apparently it was to java_script_ not jvm. sigh
12:35:29 <hseg> Hrm. Is there a way to get the derived code of an instance?
12:35:32 <bitmapper> yeah, although if you want to compile to jvm frege/eta are there
12:36:10 <hseg> Specifically, I'm trying to figure out how instance Algebra r a => Semiring (a -> r)  works
12:36:21 <maerwald> when I enable -XStrict, then whenM_ never terminates: https://git.io/JvUv9
12:36:33 <maerwald> err, whileM_1
12:37:21 <maerwald> it's because of t in whenM, right?
12:37:31 <maerwald> but those are IO actions
12:37:46 <hseg> I see -ddump-deriv will do the trick, but how do I run it on package code?
12:37:47 <solonarv> hseg: yes, -ddump-deriv
12:37:55 <solonarv> (flag to pass to ghc)
12:38:11 <solonarv> this will dump *all* derived instances
12:39:45 <hseg> OK, is there a way to pass that to ghci?
12:40:54 <geekosaur> huuuuh. "NET and JVM stuff from Yhc already in this new compiler" from http://neilmitchell.blogspot.com/2006/12/bhc-basic-haskell-compiler.html . I didn't remember incorrectly, just can't find it
12:41:18 <geekosaur> hseg, should work as an option, otherwise :set -ddump-deriv
12:41:28 <bitmapper> geekosaur: i think he means UHC
12:41:32 <bitmapper> as they had both jvm and .net
12:42:24 <geekosaur> this said, "on package code" once the package is installed, it's too late; you'd need to recompile the package with -ddump-deriv
12:42:34 <hseg> Just found that out
12:42:53 <hseg> cabal new-repl --ghc-options=-ddump-deriv kicked off an entire rebuild
12:43:48 <geekosaur> build hash includes compiler options, although -ddump-deriv shouldn't in theory change any code
12:44:15 <hseg> Too bad
12:46:40 <hseg> Ugh... Now I need to search for my instance in a package filled with such
12:48:49 <hseg> Odd. -ddump-deriv only lists two instances: Semiring (BasisCoblade m) and Semiring Euclidean
12:59:47 <dmwit> hseg: Why do you believe the instance is derived and not hand-written?
12:59:57 <dmwit> I'd be sort of shocked if it were possible to derive that instance.
13:00:30 <hseg> dmwit: See for yourself: https://hackage.haskell.org/package/algebra-4.3.1/docs/src/Numeric-Algebra-Class.html
13:00:48 <dmwit> That's not a derived instance.
13:00:51 <hseg> Search for instance Algebra r a => Semiring (a -> r) 
13:01:01 <dmwit> The entire contents of the instance is right there in plain sight.
13:01:34 <dmwit> (The class just has no methods!)
13:02:03 <p0a> Hello does the order of definitions matter in a haskell file?
13:02:08 <p0a> For example f = g; g = 3
13:02:14 <dmwit> It is a trick that was commonly used in the past, before ConstraintKinds were a thing, for making type-synonym-alikes but for classes.
13:02:15 <hseg> ... ah
13:02:31 <dmwit> p0a: Generally no, although TemplateHaskell can affect that answer.
13:02:50 <p0a> dmwit: I see because of scope and stuff right?
13:03:02 <dmwit> mmm
13:03:17 <dmwit> Sort of, yes.
13:03:43 <p0a> Okay, thank you
13:04:24 <hseg> OK, so the entirety of the class is in the Multiplicative and Additive instances, with Abelian and Semiring just there to declare laws
13:11:24 <hseg> Is there a nice way of asking ghci if a term specializes to a given type?
13:11:40 <hseg> Have a type synonym, want to check that my term is actually of that type
13:14:02 <dmwit> :t term :: type
13:14:04 <lambdabot> error: parse error on input ‘type’
13:14:09 <dmwit> hseg: :t term :: type
13:14:24 * hackage refurb 0.2.3.0 - Tools for maintaining a database  https://hackage.haskell.org/package/refurb-0.2.3.0 (dridus)
13:14:42 <dmwit> Throw some type holes in there if you want.
13:14:52 <hseg> Echoes nothing
13:15:31 <dmwit> That's odd. It should either respond with `term :: type :: type` or a type error.
13:15:38 <dmwit> Responding with nothing at all is very surprising.
13:15:45 <dmwit> Can you show a copy-and-paste of your session?
13:15:54 <hseg> Right. When I insert a hole, it suddenly starts complaining
13:16:21 <dmwit> (With `term :: type :: type` meaning that the term does specialize to that type, and the type error meaning it doesn't, obviously.)
13:16:36 <hseg> A moment, will need to gather the relevant lines from modules
13:19:43 <hseg> OK, so with http://ix.io/27pV, run :set -XDataKinds, :t (map (delta . M . Exp) $ basis @(V 3)) :: [TrigPoly 3]
13:20:18 <hseg> (should type error -- wrong kinds)
13:21:08 <hseg> (Should transpose the parameters to TrigPoly anyway)
13:22:23 <dmwit> um
13:22:27 <dmwit> what packages
13:24:00 <hseg> algebra and linear
13:24:24 <dmwit> WFM. Prints a nice long kind error.
13:24:53 <hseg> Am on The Glorious Glasgow Haskell Compilation System, version 8.8.1
13:28:20 <hseg> Nope, tried copying the .hs file I posted to a new cabal project, adding only algebra and linear to the deps, and running the :set and :t commands I stated above, still no errors
13:28:24 * hackage hledger-iadd 1.3.10 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.10 (hpdeifel)
13:29:27 <hseg> Hrm. If I remove the :: type, get "• Cannot apply expression of type ‘t1’ 
13:29:29 <hseg>       to a visible type argument ‘(V 3)’
13:30:04 <hseg> Seems I need to import Linear.Vector
13:30:21 <hseg> But beyond that, behaviour is the same
13:32:57 <hseg> (Of course, the answer is to enable PolyKinds at the definition of TrigPoly so that the parameter to V is inferred to be general enough)
13:36:26 <dmwit> IDK. I tried briefly to install 8.8.1 but it would involve upgrading cabal-install and I super don't want to do that right now. Perhaps worth a bug report, especially if you can cause it to happen with a more basic (read: no dependencies) file.
13:37:45 <hseg> There's a chance I can reduce to just a linear dependency
13:37:48 <solonarv> I have 8.8.1 installed, but I don't feel like waiting for the entire kmettiverse to build
13:40:18 <hseg> Does the kmettiverse have such a bad rep?
13:40:49 <MarcelineVQ> no :> there's just a lot of it
13:41:05 <solonarv> indeed, and I don't have it cached yet
13:43:09 <hseg> OK, managed to reduce it to :t (map (const 0) $ basis @(V 3)) :: [Covector 3 Integer] with :set -XDataKinds and http://ix.io/27qc loaded
13:46:07 <hseg> And managed to excise the kmettiverse! With just http://ix.io/27qd and :set -XDataKinds, :t (map (const 0) $ basis @(V 3)) :: [Covector 3 Integer] is still silent
13:46:50 <hseg> Even worse, it doesn't complain for different values of 3 in the type
13:47:13 <dmwit> WFM. Says "Hey, did you mean to turn on TypeApplications?".
13:47:17 <dmwit> (on 8.8.1)
13:47:36 <dmwit> ...although after turning that on it is silent.
13:47:37 <dmwit> Whoa!
13:47:42 <dmwit> That's a bug for sure.
13:48:33 <hseg> OK, converging on MFE: :t basis @(V 0) is also silent
13:49:16 <dmwit> :t id :: [Covector 3 Integer] also silent
13:49:18 <lambdabot> error:
13:49:18 <lambdabot>     Not in scope: type constructor or class ‘Covector’
13:50:27 <hseg> Doesn't even need DataKinds to trigger -- :t base @(V Int) is also silent
13:51:01 <hseg> (BTW, just noticed I have TypeApplications in my ghci.conf, so that needs to be added to the repro instructions)
13:51:37 <dmwit> this requires no file even: :t id :: [Maybe] 
13:51:49 <hseg> Hm. If I directly ghci Canary.hs I do get a complaint
13:52:04 <dmwit> No file, no extensions. That's a pretty minimal example, if you ask me.
13:52:35 <hseg> OK, further tomfoolery shows this only happens in cabal new-repl, not in ghci
13:52:52 <dmwit> Happens in ghci here.
13:53:13 <hseg> solonarv: Can you repro in vanilla ghci?
13:53:25 <hseg> dmwit: You're on which version?
13:53:29 <dmwit> 8.8.1
13:53:43 <dmwit> ghci-8.8.1 -ignore-dot-ghci, then :t id :: [Maybe]
13:53:46 <dmwit> no response
13:53:53 <hseg> Huh
13:54:00 <iqubic> Has 8.8.1 been released publicly?
13:54:11 <dmwit> If only there were some way to find that out.
13:54:19 <hseg> Just noticed my vanilla ghci is 8.6.5, so this seems to be a regression
13:54:40 <hseg> (forgot to update that symlink)
13:54:52 <solonarv> hseg: can reproduce ':t id :: [Maybe]' is silent for me on 8.8.1
13:55:16 <dmwit> :t id :: [[]] is even cuter ;-)
13:55:18 <lambdabot> error: parse error on input ‘;’
13:55:38 <solonarv> this is just raw 'ghci', nothing else, no extra packages or flags
13:56:14 <hseg> OK, so we have a regression here in ghci between 8.6.5 and 8.8.1
13:56:17 <hseg> Reporting...
13:57:36 <solonarv> finding ghc bugs, fun!
14:00:17 <dmj`> visible type applications at the type level, neat
14:01:05 <solonarv> yeah!
14:01:24 <solonarv> I haven't played with them yet, but they should be useful for some type-level wizardry
14:02:37 <hseg> And done https://gitlab.haskell.org/ghc/ghc/issues/17681
14:08:14 <dmj`> solonarv: usually I use VTA at the term level when dealing with typeclasses (i.e. read :: Read a => String  -> a), so not having typeclasses at the type level makes me think this won't be too useful, but maybe I'm being myopic
14:10:20 <solonarv> dmj`: agreed, hence only *some* type level wizardry
14:11:07 <dmj`> solonarv: more excited for dot syntax to land
14:11:22 <dmj`> then Haskell will finally be the OOP language its always tried so hard to be
14:12:37 <Cheery> they need to make it much worse before it gets there
14:12:54 * hackage apns-http2 0.1.1.0 - Apple Push Notification service HTTP/2 integration.  https://hackage.haskell.org/package/apns-http2-0.1.1.0 (dridus)
14:19:15 <lpil> Hello everyone! Does anyone know how bidirectional type checking compares to HM type inference?
14:19:50 <lpil> Trying to determine the advantages and disadvantages of each compared to each other
14:20:33 <Cheery> um...
14:20:38 <Cheery> you can use them together
14:21:05 <zeta_0> hello guys, i placed some language pragmas in default-extensions: section of my .cabal file, but runhaskell Main.hs is throwing an error and pointing at this piece of code that uses one of the dsls?
14:21:06 <zeta_0> Main.hs:9:36: error: parse error on input ‘/’
14:21:06 <zeta_0>   |
14:21:06 <zeta_0> 9 | mkYesod "HelloWorld" [parseRoutes| / HomeR GET|]
14:21:06 <zeta_0>   |                                    ^
14:21:06 <zeta_0> [
14:21:20 <lpil> Oh Cheery? :)
14:21:35 <zeta_0> here is my .cabal file that i am using for the project: https://hastebin.com/umefukadak.diff
14:21:47 <Cheery> lpil: people talk about it as if they were "either or", but they're different ideas that are both called "typing"
14:22:46 <lpil> Interesting! Could you expand a little on that, or point me in the direction of some more info? I've been working with HM for the last year but I'm certainly no expert on type systems
14:23:00 <hseg> ... heh. I was hoping kmett kept his packages compatible, guess he's as mortal as the rest of us. linear and algebra don't mesh well -- for example algebra doesn't know vectors form abelian groups
14:23:04 <zeta_0> i placed the language pragmas my .cabal file so that i would not have to keep writing them over and over again, but it seems like that syntax is not being recognized?
14:23:31 <hseg> In which case, might as well just use sized
14:23:45 <hseg> s/sized/vector-sized/
14:24:26 <Cheery> lpil: http://boxbase.org/entries/2019/jul/29/bidirectional-typechecking-dependent/
14:24:54 <lpil> Thanks for the link
14:25:29 <Cheery> it's my blog. but there's a link to Pfenning's lecture that helped me out with understanding this stuff.
14:26:12 <Cheery> there are some things related to type inference though.. one thing is that you odn't necessarily need it with bid
14:26:36 <Cheery> I can explain it in few words now probably.
14:27:44 <solonarv> zeta_0: the explanation is very simple: 'runhaskell' doesn't read .cabal files
14:28:22 <wild_buffalo> Hi, how should I install stack with Nix?
14:28:38 <wild_buffalo> Is there a Stack package or should I use the instructions on the website?
14:29:26 <Cheery> lpil: there are some kind of expressions where you can start with a type, and just kind of decompose the type as you go toward leaves, the type describes the whole expression.
14:31:31 <lpil> Am I right in reading this blog as saying that bidirectional typing may be more straightforward to implement than HM?
14:32:17 <Cheery> lpil: it's very straightforward to implement. Basically the thing is that you got expressions that cannot reduce further.. called normal forms, and expressions that don't have enough context to reduce, called neutral forms.
14:33:46 <Cheery> if there's normal forms inside neutral forms, you got to type those, but otherwise type information can reside in the top of the expression.
14:33:48 <wild_buffalo> nvm found the instructions! :)
14:34:41 <lpil> Would you say there are benefits beyond ease of implementation? I'd trying to decide if I should have a go at rewriting my typer using it. Learning is great, but some other benefit would be a nice extra :)
14:36:23 <Cheery> lpil: it depends what kind of language you have.
14:36:38 <lpil> oh?
14:36:47 <Cheery> if it's a theorem prover, I think it probably should use bidirectional typing.
14:37:10 <lpil> It's a simple general purpose lang, like a baby Caml
14:37:26 <lpil> Nothing exciting type wise
14:37:38 <Squarism> I've not followed the duplicate records fields problem that close. Is possible, in recent versions of ghc, possible to use the same field selector in the same file if the arguments dont lead to ambiguities? 
14:37:53 <Squarism> Is it*
14:39:00 <Cheery> lpil: maybe the idea can be conveyed such that bidirectional typing is an observation: even if you didn't have type inference, the only place where you ever need to type-annotate anything is at a boundary where expression can reduce.
14:40:35 <Cheery> eg. ((\x -> y) z) only in this kind of boundary you got to type-annotate anything.
14:41:05 <Cheery> and the type annotation goes in between there.. (((\x -> y) : (a -> b)) z)
14:41:48 <Cheery> basically, every normal form is annotated before it's "used".
14:42:41 <Cheery> but if you got normal form inside normal form, eg. (\x -> (\z -> w) : (a -> b)) : (a -> b -> c)
14:43:03 <Cheery> there the annotation is redundant and you don't ever need to put it there.
14:43:26 <Cheery> you can just write (\x -> \z -> w) : (a -> b -> c)
14:44:12 <lpil> thanks :)
14:44:41 <dmj`> wild_buffalo: why use stack at all if you're using nix?
14:45:27 <Cheery> lpil: you're working on the "miniocaml" or .. what was that one thing shown in r/programminglanguages short while ago?
14:46:04 <lpil> Nah, I've been making an Erlang clone with some simple type checking https://github.com/lpil/gleam
14:53:13 <dmj`> lpil: very cool
14:53:50 <lpil> thanks, it's a lot of fun
14:54:16 <dmwit> hseg++ good bug report!
15:02:54 * hackage json 0.10 - Support for serialising Haskell to and from JSON  https://hackage.haskell.org/package/json-0.10 (IavorDiatchki)
15:09:28 <hexagoxel> maerwald: by "grepping for type signatures" do you mean "grepping for the binding definition? For the latter, I am using r"^myFunc". For the former, I don't think hanging type signatures help.
15:10:03 <maerwald> hexagoxel: "^myfunc" is less correct than "^myfunc ::" and will introduce false-positives
15:11:21 <dmwit> Because of TH?
15:11:40 <maerwald> because of that, of comments and similarly named functions
15:11:49 <zeta_0> so how do i place language pragmas in a cabal project so that haskell recognizes them? i don't want to have to write them over and over again in every haskell file?
15:12:00 <glguy> maerwald: So like this? https://github.com/glguy/intcode/blob/master/src/Intcode.hs#L137-L140
15:12:07 <maerwald> yep
15:12:12 <maerwald> that is reliable for grepping functions
15:12:17 <hexagoxel> "^myfunc " ? but you are right, there are sometimes false positives.
15:12:34 <glguy> s/functions/top-level definitions/ ?
15:12:44 <maerwald> hexagoxel: also, where clauses
15:12:49 <maerwald> breaks "^myfunc"
15:12:57 <maerwald> or functions definitions via let
15:13:00 <glguy> you have to indent your where clauses
15:13:04 <maerwald> yeah
15:13:06 <glguy> so they couldn't match the ^, right?
15:13:27 <maerwald> I like to have r"funcname ::" match functions anywhere they are
15:14:21 <zeta_0> i placed the language pragmas in the default-extensions section of the .cabal of the project, but haskell keeps throwing the error that it does not recognize the language pragmas?
15:14:46 <maerwald> but it's configurable, so I don't have a strong opinion. But anywhere I install brittany I have to turn that off first :P
15:14:53 <glguy> You're probably not running a program called "haskell" , what are you actually doing?
15:18:42 <jle`> speaking of source formatters, is there some comparison as to which extensions/syntax stuff different formatters support
15:18:58 <jle`> since every time i try to start using a formatter, my actual codebases never work because of one or another extension
15:22:18 <fog> why does this overflow? https://gist.github.com/fog-hs/72ef3997a68e8fd012f87a9ca8775850
15:23:12 <hexagoxel> maerwald: The alternatives all have other downsides, but I agree that easy grepping might outweigh them. I might have to switch to some "hanging" (or other always-put-::-after-binding) style for a bit to see how much I like that. Or I need to call for a vote on the defaults at some point, before brittany-1.0 ?
15:23:38 <hexagoxel> Anyway, thanks for the input.
15:24:13 <maerwald> If our IDE tools would work better, there would be no reason to use grep :P
15:24:39 <maerwald> hasktags works ok-ish, but in the end I still use 'ag' and grep a lot
15:25:30 <hexagoxel> true, and same.
15:27:00 <fog> i blame the solver
15:27:47 <fog> it should be able to find a solution in less than infinite trys
15:30:44 <hexagoxel> jle`: the "error-handling" branch on brittany will make extensions a good bit smoother; Falling back on ghc-exactprint on a per-top-level-binding basis turns a lot of previous errors into warnings. Will be in next release, can only be a matter of weeks :p
15:31:28 <jle`> ah thanks, looking forward to it :)
15:31:47 <jle`> yeah, that's something that would allow me to use it as it is
15:32:14 <jle`> i'd like to be able to not have to worry about formatting
15:32:46 <MarcelineVQ> fog: meanwhile I can't even figure out why   from (_,xs) =  is a tuple for the argument.   It's pretty suspicious instance though, HCons is building a list, what ensures it's gonna shrink?
15:34:51 <MarcelineVQ> That is to say I can't read this stuff very well but it's giving the impression of  "lemme remove that head, now lemme add a different head, somehow I'm not getting to the end of my list"
15:38:14 <zeta_0> when i place the language pragmas inside my .hs files, when i exectute runhaskell file-name.hs it works fine, but when i place the language pragmas inside of the .cabal of my cabal project in the default-extensions section, the runhaskell command stops working i am not sure how to troubleshoot this problem? https://hastebin.com/uziyesohuq.diff
15:39:47 <p0a> zeta_0: runhaskell doesnt look at your files
15:39:48 <glguy> zeta_0: That's why you should avoid using default-extensions; it makes it harder to use your source files without cabal
15:40:08 <glguy> also because it makes your readers work harder to know what extensions are in play in any particular file
15:40:59 <jle`> zeta_0: 'runhaskell' is a "ghc" thing, it doesn't know about projects or cabal or stack or package.yaml or anything
15:41:15 <jle`> zeta_0: remember that haskell itself doesn't know anything about projects or stuff like that
15:41:28 <jle`> all of that is added on top of haskell by Cabal
15:41:46 <Axman6> zeta_0: Didn't I tell you the other day that doing that is considered bad practise?
15:42:06 <zeta_0> well, i am only going to do this for my personal projects, just to save me some time and hassle not having to write the language pragramas over and over again
15:42:33 <p0a> zeta_0: to avoid writing the pragmas over and over look into your text editors capabilities
15:42:44 <Axman6> decent tools make adding new pragmas easy, and having them in each file lets any other reader know what to expect in the file, and gives them a handle to find documentation if they don't understand some piece of code which uses an unfamilliar extension
15:42:58 <sm[m]> thats totally fine, but runhaskell wont work then
15:43:00 <glguy> zeta_0: Now instead of writing language pragmas once per file you'll write them once per runhaskell invocation
15:43:05 <jle`> if you're using stack (and probably cabal too, i'm not sure the command) you might be able to fake it using `stack exec -- runghc file-name.hs' maybe, i'm not sure
15:43:14 <sm[m]> but why use runhaskell ? nobody does
15:43:16 <glguy> You've just chosen to write: runhaskell -XOverloadedStrings -XAndSoOn main.hs
15:43:46 <jle`> or ah, i think it's `stack runhaskell file-name.hs'
15:44:10 <zeta_0> i am using nix integrated with cabal, not stack
15:44:17 <sm[m]> right (runghc)
15:44:35 <jle`> ah, then i'm not familiar with how that works
15:44:43 <jle`> there might be a way
15:45:55 <jle`> but, i do not
15:45:57 <jle`> know
15:46:08 <dmj`> I just use runghc these days, no cabal nor stack
15:46:57 <dmj`> nix-shell --run 'runghc Setup.hs build' 
15:47:28 <glguy> You don't "just use runghc", you use an even more complicated solution :) 
15:48:29 <iqubic> Yeah.
15:49:17 <zeta_0> i just started using ghcide(which is phenomenal), but it seems to be missing auto-completion for language pragmas, oh well'
15:49:28 <zeta_0> you guys should give ghcide a try
15:51:19 <jle`> i don't mind recommendations, but this is a funny context to give one ;)
15:51:26 <iqubic> Meh. I'm fine with just dante
15:51:30 <zeta_0> haskell-ide-engine was giving me to many problems(everything kept breaking), i'm glad i found ghcide, it is bare bones with only a couple of features but is very stable and fast
15:51:47 <iqubic> jle`: I loved your adjunctions post.
15:51:56 <zeta_0> iqubic: that's cool, it's good that we have options to choose from
15:52:00 <Cheery> iqubic: link?
15:52:12 <iqubic> link to what?
15:52:24 <iqubic> Dante is an emacs plugin. It only works with Emacs.
15:52:28 <Cheery> you mentioned a post
15:52:31 <shachaf> Legend of adjunctions: A link to the post.
15:52:50 <iqubic> https://blog.jle.im/entry/foldl-adjunction.html
15:53:20 <glguy> shachaf: I played the remake of Link's Awakening on the Switch and loved it :)
15:53:22 <iqubic> jle`: What would you say, in your opinion, is the point of adjunctions.
15:54:10 <jle`> like in general, or in haskell?
15:54:20 <iqubic> In haskell.
15:54:47 <jle`> i sort of went over this in the post heh
15:54:55 <shachaf> Adjunctions in Haskell are really boring, anyway.
15:54:57 <shachaf> There's only one.
15:55:36 <iqubic> Which one? Adjunction ((,) e) ((->) a) where ...?
15:55:48 <jle`> iqubic: but it's a little different than other abstractions in haskell like monad or monoid, where the utility is in the vast amount of useful polymorphic functions we have with them
15:55:55 <iqubic> Yeah. I know.
15:56:09 <jle`> if you've read the article then everything i will say now is something you already know
15:56:26 <iqubic> Right. I have read the article.
15:56:41 <iqubic> No need to repeat yourself.
15:57:05 <jle`> Adjunction ((,) (Rep u)) ((->) (Rep u))
15:57:19 <jle`> er, Adjunction ((,) (Rep u)) u
15:57:37 <jle`> is the only adjunction in haskell, mathematically
15:57:43 <iqubic> Yes. I'm aware of that.
15:57:55 <jle`> but, sometimes you have interesting/surprising manifestations of ((,) (Rep u))
15:57:59 <iqubic> Are all other adjunctions in Haskell isomorphic to this one?
15:58:09 <jle`> so the Adjunction typeclass can maybe be useful for identifying these interesting manifestations
15:58:20 <jle`> when they aren't very obvious normally
15:58:50 <jle`> this is the main use for me, i think.  not anything practical, but just maybe some interesting connections you might not have noticed otherwise
16:00:54 <jle`> for example we have Adjunction (Free f) (Cofree u), which is not necessarily an obvious conclusion if you are working only from the knowledge of (,) [Rep u] -| Cofree u
16:01:06 <iqubic> Yeah.
16:08:19 <iqubic> Also, for the first half of the blog post, I thought the adjucntion to a list consumer/fold/catamorphism was going to be some sort of list creator/unfold/anamorphism.
16:10:37 <iqubic> Which would also make sense.
16:11:46 <iqubic> Now, is there a guide I can look at to see how ApplicativeDo desugars?
16:12:10 <iqubic> I'm on this train of thought because of jle`'s newest blog post.
16:38:03 <dmj`> glguy: it's not more complicated I swear :) I just wrap all the calls in bash functions so it ends up becoming `nix-shell --run build`
16:38:08 <dmj`> with just the settings I want
17:09:06 <fog> I managed to get this "via" idea to work using a constraint list
17:09:07 <fog> https://gist.github.com/fog-hs/72ef3997a68e8fd012f87a9ca8775850
17:11:54 <dmj`> SwiftUI is fun
17:20:43 <fog> Now the path can be unfolded; https://gist.github.com/fog-hs/72ef3997a68e8fd012f87a9ca8775850
17:23:14 <fog> eg; unfoldHasList :: ToHasList (String :| Bool :| (End Int)) 
17:24:24 * hackage yaml2owl 0.0.2 - Generate OWL schema from YAML syntax, and an RDFa template.  https://hackage.haskell.org/package/yaml2owl-0.0.2 (LeifWarner)
17:25:29 <fog> if i can reify insances during cons that would be good
17:26:18 <fog> maybe labling the Has instance by position to remove ambiguity
17:26:56 <fog> a phantom index on the type at each position 
17:27:17 <fog> then it can be used on a list of lists or a tree
17:28:19 <fog> then instead of evaluating the result and trying to update the tail as with HFoldable2
17:28:36 <fog> it is just the scope that is updated, with extra Has instances
17:29:32 <fog> during the Folding, as when a value is reached all the arguments it needs should have been calculated and added to scope with reified Has () a instances
17:30:23 <fog> instead of having to navigate to that node and return a new function that was the partial application of the newly generated value of the head matched during folding
17:30:50 <fog> and having to update the types of these functions stored at each node during folding
17:31:50 <fog> now instead we can fold up the net by just adding the recently calculated values to be used by the function represented as a HasList which is unchanging at each node
17:32:19 <fog> by the time "from" is called on this HasList, constraints sufficient to satisfy it should have been reified into scope
17:33:06 <fog> namely, all the `Has () a' instances of values calculated in this way, from evaluating these HasLists at the nodes
17:34:01 <fog> effectively forming edges along wich arguments of various types are passed to provide to the function at the nodes represented by its type as a HasList
17:34:53 <fog> where the Has instances express partial function application (yet to do)
17:36:26 <alc`> splitAt is O(n)?
17:37:52 <Cale> alc`: For lists? Yes, it must be.
17:39:14 <Cale> The entire left list is new (it doesn't share any tail with the original list), so you're at least allocating O(n) cons cells by the time you've finished evaluating that list.
17:39:16 <Axman6> it's pretty hard to do anything with lists which isn't at least O(n)
17:40:12 <alc`> "Notes and tips: using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1."
17:40:14 <Cale> and then to get the first element of the right list, you need to get to walk down n elements of the original -- though at least, having done that, you have a tail of the original list, so you don't need to allocate anything there
17:41:14 <alc`> https://paste.ubuntu.com/p/vft7Wv5ngf/
17:41:17 <Cale> alc`: Sounds like maybe a problem for which there is a solution which involves doing some arithmetic instead of simulating something directly.
17:41:37 <Cale> Ah yes, that's definitely such a problem
17:41:54 <alc`> yeah, I used splitAt at a very larger list
17:42:12 <alc`> josephusSurvivor 2000223 1320
17:43:07 <alc`> Cale: what's that Notes meaning?
17:43:26 <alc`> assume both n and k will always be >=1
17:45:06 <Cale> Well, if n is 0 or less, the thing doesn't make much sense, and if k is zero, that's also quite unhelpful
17:47:32 <alc`> Cale: but this is not help to large numbers
17:54:31 <Axman6> there's a really good Numberphile video on the josephus problem btw - it'll help you a lot with worting out the necessary maths
17:59:04 <Axman6> I think this problem is probably doable with lists, but calling lengs everywhere is not going to help, since it's O(n). In general, calling length on lists is a code smell, you almost certainly don't want to do it
18:05:19 <p0a> what does type X = X !A !B mean?
18:06:42 <Axman6> it means that X contains two fields, of type A and B, and both of them are strict fields - when X is evaluated, the A and the B will be evaluated first
18:08:05 <shachaf> I think it's a syntax error?
18:09:04 <Axman6> uh, yes it would be if it were type, but if it were data X = X !A !B then it's what I said - p0a did you mean data instead of type?
18:09:39 <glguy> Not helping:
18:09:40 <glguy> Prelude> type a ! b = (a,b)
18:09:40 <glguy> Prelude> type X = Int ! Bool ! Char
18:10:01 * Axman6 glares
18:10:02 <glguy> Thanks -XTypeOperators, Thopertors
18:11:59 <p0a> Axman6: I meant data, thank you 
18:17:54 <shachaf> glguy: Doesn't happen in my ghci: "Malformed head of type or class declaration: a (!b)"
18:17:57 <pacak> Greetings fellow humans. Any ideas why callCC  (https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html#v:callCC) is allowed to look at type of b? This makes it impossible to call on k from places with different types. In purescript it looks like "callCC :: forall a. ((forall b. a -> m b) -> m a) -> m a" for example. Am I doing something wrong?
18:18:39 <shachaf> pacak: You can always let b be Void and then use absurd on it in multiple places.
18:19:41 <shachaf> Presumably avoiding a rank-2 type is worth the small hassle there.
18:20:08 <pacak> or I can define by own callCC' with forall...
18:21:08 <pacak> Not sure which approach is the best if we want to follow the principle of least astonishment...
18:22:37 <pacak> But "in order not to use rank-2 types" is a plausible explanation. Thanks!
18:23:58 <shachaf> I think "((a -> m Void) -> m a) -> m a" would be a nicer type for callcc anyway.
18:24:08 <shachaf> Maybe less convenient but at least clearer to read.
18:25:11 <iqubic> Why are we specializing b ~ Void?
18:28:38 <pacak> When you call the continuation it won't return.
18:29:25 <pacak> Void makes it clear(er) (also lol) that it won't return
18:40:53 <iqubic> Void in traditional imperative signifies no return value.
18:59:39 <pacak> Sure. Return also means somethnig different.
18:59:45 <nshepperd> it's just a name
18:59:55 <pacak> Void in Haskell is not void in c++.
19:00:29 <glguy> s/traditional/historical
19:14:57 <remexre> dumb question
19:15:06 <remexre> how do I import a pattern synonym with a symboly name
19:15:15 <remexre> import Foo (pattern (:==:)) gives me a syntax error
19:15:38 <remexre> wait nvm, double dumb, I don't have -XPatternSynonyms
19:32:45 <p0a> I was kind of messing around with Yesod with the book
19:32:59 <p0a> I think now I need to re-read the chapters I've read and read the hackage docs to learn the types
19:33:03 <p0a> because so far it was plug n play
19:38:08 <pacak> Yesod uses enough TH and changes enough of the std library to the point it becames a language on it's own and not just Haskell.
19:38:24 <pacak> for example
19:38:25 <pacak> :t head
19:38:27 <lambdabot> [a] -> a
19:38:33 <pacak> ^ it's not that in yesod.
19:46:46 <p0a> pacak: sure but I'm just trying to learn it 
19:46:52 <p0a> pacak: and reading the book has me confused 
20:57:21 <Ailrun[m]> you mean the one from blaze?
20:57:52 <Ailrun[m]> :t Text.Blaze.Html5.head
20:57:53 <lambdabot> Text.Blaze.Html.Html -> Text.Blaze.Html.Html
21:10:08 <fog> managed to get to the point where you can capture reified functions (as global instances for now) if thier arguments are available
21:10:21 <fog> via Has () constraints in scope
21:10:25 <fog> https://gist.github.com/fog-hs/5696684088996e558f7c1692d5d699a0
21:11:54 <fog> so that all the neurons have functions of some type specified as a proxy list of types and an output type
21:12:36 <fog> and should reify the value returned for it to be available for this process downstream in a deep net
21:13:18 <fog> where the partial application and matching up of edges has been differed to the Constraint solver
21:13:37 <fog> deferred*
21:16:36 <fog> where the plan is to extend from HasList to a tree for parralel threads and a bipartite graph with multiple edges corresponding to function application 
21:17:29 <fog> between each layer of a deep net (list-of-lists-like structure)
21:17:48 <d34df00d> Hi!
21:18:04 <d34df00d> What'd be the right way to pass the analog of `-march=native` to the llvm codegen when compiling with llvm?
21:18:37 <Axman6> there's -optSOMETHING flags which can be used for that, cgeck the ghc docs
21:19:13 <d34df00d> I tried -optlo "-march=native" but it made my code much slower.
21:19:23 <d34df00d> Maybe I'm passing an incorrect argument, dunno.
21:24:17 <pounce> is there some kind of parser-like reader in haskell
21:24:40 <fog> what for?
21:24:46 <Axman6> I'm not sure what that means
21:24:56 <fog> what are you trying to parse?
21:25:17 <pounce> like, i give it "2 3" and say result = start "2 3" > do n<-read; m<-read; return (n,m);
21:25:21 <pounce> bc that'd be fun
21:25:33 <pounce> >>*
21:25:40 <Axman6> sounds exacrly like a parser to me
21:25:45 <pounce> hmm
21:25:56 <pounce> u right
21:27:00 <pounce> better just read it another way
21:27:26 <fog> wouldnt you need a list of the types that you expect to peel of in a sequence?
21:28:06 <fog> maybe many different sequences could be permitted, like as long as it is valid haskell for example
21:29:31 <fog> where the syntax read in would change what kind of sequence could follow, like, close that bracket
21:30:39 <fog> so you would have to be able to read in these control chars or substrings
21:30:58 <pounce> fog: no, here `read` should be polymorphic still and read what type you expect
21:31:04 <pounce> so here `result :: (Int, Int)`
21:32:02 <fog> but if it was a compiler there would only be a certain combinations allowed, if they corresponded to eg values or type signatures being read in
21:32:20 <fog> otherwise being a syntax error
21:32:31 <fog> then i guess even a typechecker could be inserted
21:33:53 <fog> is there a parser used by GHC to create some intermediate representation of the program?
21:33:58 <pounce> hmm
21:36:20 <fog> the thing i like about this representing function implementations on a scafold is that the functions at the nodes which act on the previously returned values upstream, 
21:36:54 <fog> is that the functions at the nodes can be represented on such an implementation scaffold recursively into a tree
21:38:23 <iqubic> pounce: I'm sure one coul write this easily with a parser combinator library.
21:39:15 <iqubic> Actually, maybe not.
21:39:56 <fog> so when the Has () instance for this function is being reified, it can do so inside a Has instance evaluating a function scaffold into a constraint continuation 
21:40:52 <iqubic> fog: I think you're going to really really like dependent haskell when it arrives.
21:42:27 <fog> it looks like either something to compile into or maybe for some generative process
21:42:37 <fog> like enumerating programs 
21:43:32 <fog> its daunting that recursive computations seem to unroll infinitly deep function nets, i hope lazy evaluation can save the day
21:45:32 <fog> oh no, how do i fold them lazily!?
21:46:08 <fog> damn infinite computations
21:46:23 * hackage wai-app-static 3.1.7 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.7 (MichaelSnoyman)
21:47:53 <haskelllisp[m]> https://hackage.haskell.org/package/redis-io
21:47:53 <haskelllisp[m]> Has anyone used this library? How to set Redis connection password？
21:50:53 * hackage wai-app-static 3.1.7.1 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.7.1 (MichaelSnoyman)
21:52:12 <iqubic> haskelllisp[m]: I'm not seeing a simple way of doing that.
21:53:19 <haskelllisp[m]> sad
21:54:05 <iqubic> I mean, there must be a way of doing it. But I'm not seeing it.
21:56:15 <haskelllisp[m]> I see what you mean, there should really be an easy way to set a password, but now there isn't
21:57:59 <iqubic> I don't know enough about Redis to help you. Sorry.
21:58:28 <haskelllisp[m]> This library is used in an open source project, and now there are mining Trojans that use redis weak passwords and should be fixed as soon as possible
21:58:48 <no-n> I want to pick up Haskell again but it's been a while. I originally read LYAH, but what is the recommended way to learn it now?
22:00:25 * haskelllisp[m] uploaded an image: image.png (387KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/ITpmixEqFxGQKsYeuBOMNWjf >
22:02:56 <iqubic> Look, I don't know redis, or any Asian langauge. That image isn't helpful for me.
22:04:17 <haskelllisp[m]> ok
22:04:42 <Axman6> haskelllisp[m]: any reason why you're using thst specific redis library?
22:06:06 <Axman6> https://hackage.haskell.org/package/hedis-0.12.11/docs/Database-Redis.html foe xeample supports using a password
22:06:09 <haskelllisp[m]> https://github.com/wireapp/wire-server
22:06:09 <haskelllisp[m]> This project uses the redis-io library, which I did not decide. If I change to another library, the workload is also large. .
22:11:24 <Axman6> Based on the docs in hedis, it looks you can use the `auth` command to authanticate: When the server is protected by a password, set connectAuth to Just the password. Each connection will then authenticate by the auth command.
22:13:03 <Axman6> I can't see how that library actually uses the redis-resp library though, I would have expected it to expose all the commands somehow and let you send them
22:15:18 <haskelllisp[m]> Axman6: 
22:15:18 <haskelllisp[m]> thanks, I saw the documentation of hedis, but this open source project uses redis-io, it is not easy to switch, I have to continue to study the source code to see if I can set a password
22:16:24 <Axman6> My point is that I don't think you "set a password", you send an auth message to the server, and I assume that connection is then authenticated from that point on. but I can't see how you actually do that with redit-io
22:18:44 <Axman6> oh you need to use the Redirt monad from https://hackage.haskell.org/package/redis-resp-1.0.0/docs/Data-Redis-Command.html#t:Redis
22:18:59 <Axman6> which provides https://hackage.haskell.org/package/redis-resp-1.0.0/docs/Data-Redis-Command.html#v:auth
22:19:30 <Axman6> basically all the important redits-y thing are in the redit-resp package, redis-io is just an implementation
22:21:12 <Axman6> you can then use `commands` from redis-io to execute the messages you've made using the Redit monad
22:21:15 <Axman6> Redis*
22:22:16 <haskelllisp[m]> https://bpaste.net/Z3DQ
22:22:16 <haskelllisp[m]> my code
22:22:20 <haskelllisp[m]> Axman6: 
22:23:17 <Axman6> and that's not working at the moment?
22:26:09 <haskelllisp[m]> Axman6: 
22:26:09 <haskelllisp[m]>  I simplified this code, I use `Redis Connection Pool`. When do I need to execute the` Auth` command? ? Do you execute `Auth` every time you use it?
22:27:18 <Axman6> you could do something like: liftClient m = view rstate >>= \p -> Redis.runRedis (auth (getPassword rstate) >> p) m perhaps, but I'm not sure if that's a great idea. I have no idea how auth is supposed to work in redis though, I'm just going off the docs/types in this library
22:27:51 <pounce> is there a hashmap that ships with haskell?
22:28:14 <Axman6> no, but Data.HashMap from unordered-containers is the canonical choice
22:28:57 <Axman6> haskelllisp[m]:  this is also worth keeping in mind, from the redis security documentation: Redis is designed to be accessed by trusted clients inside trusted environments. This means that usually it is not a good idea to expose the Redis instance directly to the internet or, in general, to an environment where untrusted clients can directly access the Redis TCP port or UNIX socket.
22:30:08 <Axman6> haskelllisp[m]: https://redis.io/topics/security
22:31:09 <p0a> Hello can someone show an example haddock usage? I tried `haddock file.hs' but I don't see any files generated 
22:31:28 <p0a> my file is essentially -- | Comment \n module MyModule where
22:31:34 <Axman6> have you looked at the haddock documentation?
22:31:51 <p0a> yeah it says I have to use a flag to use a directory other than the current
22:31:57 <p0a> which I dind't
22:32:32 <p0a> What bothers me about some man pages is that they do not describe what the tool does
22:32:45 <p0a> Just how the tool is invoked
22:33:31 <p0a> okay I guess I had to use the -h flag
22:33:37 <haskelllisp[m]> Axman6: 
22:33:37 <haskelllisp[m]> Yes, we accidentally exposed it to the Internet for a few hours, and then it was hacked, so we need to add a password to redis to further improve security
22:34:21 <Axman6> haskelllisp[m]: right, well do you have any other problems at this point? 
22:35:06 <Axman6> also, like the docs say, you should only be exposing it over TLS, so that no one can see the password in the clear - otherwise you're wasting your time setting a password
22:36:53 <haskelllisp[m]> ok, thanks,  l will try that `Auth` command
22:47:47 <dminuoso_> 19:28:18  MarcelineVQ | dminuoso_: that was obvious to everyone
22:47:49 <dminuoso_> I know, right?
22:47:54 * hackage maquinitas-tidal 0.2.0 - library for MIDI control of hardware  https://hackage.haskell.org/package/maquinitas-tidal-0.2.0 (montoyamoraga)
22:50:20 <dminuoso_> I mean it's a well known fact that all monads arise from adjunctions. ;)
22:53:54 * hackage maquinitas-tidal 0.2.1 - library for MIDI control of hardware  https://hackage.haskell.org/package/maquinitas-tidal-0.2.1 (montoyamoraga)
23:01:36 <iqubic> dminuoso_: I understand that, but I don't see how it is useful.
23:03:29 <dminuoso_> iqubic: Are you familiar with tongue in cheek? :)
23:04:50 <nshepperd> i don't really understand what an adjunction is
23:05:19 <dminuoso_> The thing monads are composed of, literally!
23:08:25 <nshepperd2> oh okay
23:08:43 <iqubic> I know what an adjunction is, but I don't know why it is.
23:09:39 <iqubic> I don't understand why they are important tools to have in my tool belt.
23:11:20 <dminuoso_> iqubic: What makes you think they are?
23:11:49 <dminuoso_> Much of the category theory isn't immediately useful or obvious. It's only within certain programming domains where its useful.
23:11:58 <dminuoso_> Or if you employ a high degree of code discipline
23:12:32 <dminuoso_> Overall, if you expect any category theory knowledge to directly translate into improved code quality or reasoning, you will likely become very disappointed.
23:13:20 <dibblego> I do not agree.
23:35:05 <xrisk> Hey guys, could someone tell me what `type` declaration inside a type class means?
23:35:12 <xrisk> What should I Google to learn more?
23:37:08 <dminuoso_> xrisk: associated type families
23:37:29 <dminuoso_> xrisk: They are, for the most part, the same thing as functional dependencies on multi param type classes.
23:38:03 <dminuoso_> Or at least they give you the same power.
23:38:36 <xrisk> I'm referring to something like this, if it isn't clear: https://paste.ubuntu.com/p/xmBHvy6Ww8/
23:38:43 <dminuoso_> Yup.
23:38:49 <dminuoso_> That's an associated type family
23:39:00 <xrisk> Thank you, I'll look it up.
23:39:41 <dminuoso_> xrisk: It might be easier to start with plain type families, and then move towards associated type families.
23:40:27 <xrisk> Gotcha
23:41:20 <jackdk> xrisk: an associated type is where your `class`-definition demands that any `instance` of that class supply a type alias as part of the instance
23:41:51 <dminuoso_> jackdk: But it's not a type alias.
23:46:38 <jackdk> dminuoso_: true, but I find that gives the feel of associated types pretty well. shoulda been clearer
23:47:21 <jackdk> I also find the classes in mono-traversable a good motivating example, even though traversals are a better general solution
23:50:08 <madnight> Representable Functor is also an motivating example with type Rep f :: *
