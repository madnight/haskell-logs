02:03:10 <bunnyocto> how do I investigate where a program gets stuck exactly?
02:03:25 <bunnyocto> I tried with Debug.Trace but I ain't seing nothing.
02:07:54 * hackage mmsyn7ukr 0.4.1.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.4.1.0 (OleksandrZhabenko)
02:14:48 <bunnyocto> It gets stuck in 'optional spaces'
02:14:50 <bunnyocto> how the ..
02:35:51 <Axman6> bunnyocto: can you share the code? at this point we know less than you about why something is going wrong
02:37:53 <bunnyocto> I think parsec just blows up because the grammar is too complicated
02:38:01 <bunnyocto> but anyway.. has anybode ever run into Not in scope: `GHC.withCleanupSession'
02:38:09 <bunnyocto> i'm trying to install a package with cabal
02:51:54 * hackage json-rpc 1.0.1 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-1.0.1 (xenog)
02:53:46 <adfhawidua> Hi, what is the difference between Text.ParserCombinators.ReadPrec and Text.ParserCombinators.ReadP?
03:07:20 <Guest_34> Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
03:07:32 <Guest_34> what's the problem
03:29:19 <Athas> Just got bitten by the 'length' instance for tuples today!  I don't know if it's the first time I've had that happen to me.
03:30:27 <Rembane> > length (1,2,3,4,5)
03:30:34 <lambdabot>  mueval-core: Time limit exceeded
03:30:36 <Rembane> :D
03:30:42 <Rembane> What?! 
03:30:49 <Rembane> Athas: How did it bite you?
03:31:22 <Athas> Rembane: I was refactoring and ended up writing 'length . f' where I really needed 'length . fst . f'.
03:34:05 <Rembane> Athas: That's painful. 
03:35:47 <Athas> While this example is not so bad, I think it's interesting to speculate about whether high degrees of overloading, inference, and abstraction can undermine the type system.
03:36:19 <Athas> You end up with a language where many things are type correct, but they don't really do what you intended.  That's not a problem if you have a much stronger (dependent) type system, of course.  But then you have (S n) problems.
03:36:54 * hackage haskoin-core 0.9.8 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.8 (xenog)
03:39:05 <Rembane> Indeed. I wonder if it's the Foldable instance for tuples that is the culprit here.
04:03:24 * hackage taskell 1.8.2.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.8.2.0 (smallhadroncollider)
04:57:34 <maerwald> functional just means "based on lambda calculus", nothing more
06:01:46 <mroman> is there a json library for dynamic structures?
06:01:57 <mroman> i.e. one that I don't need to do fromJSON data :: ConcreteType
06:04:54 <mroman> Text.JSON doesn't seem to be willing to accept valid json.
06:05:13 <mroman> probably because it also needs a :: of some sort
06:06:35 <mroman> ah. nvm. figured it out
06:06:40 <mroman> :: Result JSValue is what it needs
06:51:35 <zincy> Should I encode times using LocalTime in my HTTP request bodies and Use UTC interally in my server
06:51:52 <zincy> Or should I just use UTC internally and when
06:52:09 <zincy> encoding/decoding my JSON requests and responses
06:54:15 * geekosaur prefers UTC
06:56:05 <stteevveen> Hi! I have come back at cabal after reading that there was much improvement, and even a v2 workflow. I tried to follow https://cabal.readthedocs.io/en/latest/developing-packages.html but its not clear what I'm missing.  What I want: have a strating point project using QuickCheck and Polysemy. What I have done: cabal init. MOdified proglet.cabal
06:56:05 <stteevveen> entry "buildepends", so as to add QuickCheck and polysemy to the already existing base ^>=4.12.0.0 dependency. When I build it fails with unknown package polysemy. But it also complains about QuickCheck. When I run icabal update, it warns me that it is a legacy v1 operation, but that doesn make polysemy and QuickCheck seeable by cabal. Any idea
06:56:06 <stteevveen> what I'm missing ?
06:56:46 <maerwald> stteevveen: what version of cabal
06:56:59 <stteevveen> cabal version 2.4
06:57:03 <maerwald> update to 3.0
06:58:28 <[exa]> regarding cabal versions, who's the debian maintainer? it would be really cool to finally push v3 there
06:59:25 <maerwald> [exa]: the metadata says who the maintainer is
06:59:27 <geekosaur> as it turns out, v1-update and v2-update are the same thing; it's just reacting to not seeing a v2- prefix
07:14:33 <stteevveen> ls
07:19:28 <fenedor> Desktop Documents Downloads Music Pictures Public Videos
07:20:12 <solonarv> whoa, that's all that's in your ~ ?
07:20:48 <sm[m]> stteevveen: you could also try cabal new-update
07:20:53 <fenedor> it only shows directories without a . prefix, so yeah
07:21:27 <fenedor> Actually I have an additional entry 'VirtualBox VMs' but that didnt look as nice
07:21:34 <solonarv> mine has 41 entries according to `ls | wc -l`
07:21:59 <solonarv> actually not as many as I expected
07:22:54 <fenedor> `ls -Al | wc -l` has like 86 entries for me, but `ls` is small
07:23:19 <solonarv> oh, TIL about ls -A
07:24:06 <solonarv> interesting, for me it's 126; seems we have about the same number of hidden entries
07:28:01 <fenedor> 40 is still a solid difference.  .config also has a bunch of stuff. nowdays, most stuff should be in .config or XDG_Spec directories, right?
07:28:52 <stteevveen> maerwald thanks. with v3 it works like a charm. just got to get it from nixos unstable channel. 
07:30:06 <stteevveen> what do you advise when using cabal v3: cabal udpate , cabal v2-update, cabal new-update ? are they equivalent ? is there a v3-update ?
07:30:23 <geekosaur> they're all the same thing
07:30:25 <merijn> stteevveen: "cabal update" and v2-update are the same in 3.0
07:31:12 <merijn> stteevveen: the v1/v2 prefixes exist so you can write script compatible across multiple cabal-install versions, but from 3.0 and up the v2 workflow is the default
07:33:33 <statusfailed> stupid question... TypeNats has a 'type family' called *, but that's the same symbol as the kind, so how do I write a type like "n * m", where n and m are both KnownNats ?
07:33:59 <statusfailed> I'm getting an error that seems to indicate GHC thinks that (n * m) means n has kind * -> Nat -> Nat
07:34:13 <stteevveen> other question, in a few words, as I use cabal v3 on nixos, should I directly look at using cabal2nix, or is it ok to start focussing on cabal only for the moment ?
07:34:17 <geekosaur> {-# LANGUAGE NoStarIsKind #-}
07:34:25 <geekosaur> iirc
07:34:33 <geekosaur> or upgrade to a ghc which does that by default
07:35:00 <geekosaur> sorry, NoStarIsType
07:35:07 <geekosaur> "Type" being its replacement
07:35:49 <statusfailed> geekosaur: hooray!! thank you :)
07:36:28 <merijn> stteevveen: afaik cabal2nix and things still use v1 stuff. I can't say what you should use, though
07:37:44 <stteevveen> merijn that's sufficient to keep on going with cabal v3 alone for the moment for me :-)
07:38:29 <fenedor> stteevveen, personally, I use cabal and a simple nix-shell to have system-libraries on the path, such aus zlib
07:41:50 <solonarv> fenedor: my 126 is the hidden *and* non-hidden entries together; #hidden = #total - #nonhidden = 85
07:42:10 <solonarv> yours is 79 if I'm counting right
07:42:57 <fenedor> solonarv, ls -Al shows all entries, right? I have 84 in total, with hidden and non-hidden entries
07:43:12 <solonarv> shows all, yes
07:43:17 <solonarv> so you have 77 hidden entries
07:44:09 <maerwald> stteevveen: you might find https://github.com/kowainik/summoner interesting, but I usually just write my .cabal files manually
07:44:15 <fenedor> yeah
07:44:21 <fenedor> oh
07:44:25 <fenedor> ok, I am dumb
07:46:10 <stteevveen> maerwald maybe a bit premature for the state of my project, but I definitely put it in my notes about cabal for future use. 
08:00:24 * hackage filepath-bytestring 1.4.2.1.4 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.4 (JoeyHess)
08:13:53 * hackage exp-extended 0.2 - floating point with extended exponent range  https://hackage.haskell.org/package/exp-extended-0.2 (ClaudeHeilandAllen)
09:14:40 <d34df00d> What would be the best way to make an image with criterion benchmark results bar graph? It seems to render it as a canvas element on the HTML page that's produced and includes some JS.
09:26:48 <dsal> benchmark' gives you a Report. You can do whatever you need with that.
09:38:04 <arsdragonfly> how do I most concisely write f :: (a -> b -> m c) -> (c -> m d) -> (a -> b -> m d)?
09:38:52 <arsdragonfly> the kleisli arrow doesn't work because of the reader monad
09:40:30 <solonarv> :t \f -> (>=>) . f
09:40:32 <lambdabot> Monad m => (a1 -> a2 -> m b) -> a1 -> (b -> m c) -> a2 -> m c
09:40:47 <fendor> :t foo f g = \x y -> f x y >>= g 
09:40:49 <lambdabot> error:
09:40:49 <lambdabot>     parse error on input â€˜=â€™
09:40:49 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
09:40:55 <solonarv> almost!
09:41:01 <solonarv> :t \f -> flip ((>=>) . f)
09:41:02 <lambdabot> Monad m => (a1 -> a2 -> m b) -> (b -> m c) -> a1 -> a2 -> m c
09:41:25 <arsdragonfly> ðŸ˜€ thanks!
09:41:45 <solonarv> :t flip . (.) (>=>) -- unnecessary pointfree verison
09:41:47 <lambdabot> Monad m => (a1 -> a2 -> m b) -> (b -> m c) -> a1 -> a2 -> m c
09:42:01 <solonarv> really though, I would just write it pointfully
10:02:07 <fendor> When using data-files, you can influence the directory cabal uses to look data-files up with a magic env variable that looks like pkg_name_var. Can I use that in a nested way? E.g. I depend on a package with data-files, is the env variable for that package the same as beofer, or has it some prefix?
10:02:59 <monochrom> No.
10:03:28 <fendor> no, in the sense of, I shouldnt want that, or no, it does not have some prefix?
10:03:33 <d34df00d> dsal: I really don't want to do the plot myself.
10:08:49 <d34df00d> Self-answering: HTML canvas element has toDataURL() method, so I can save the criterion report from the web page it generates somewhat easily.
10:12:21 <maerwald> is there a way to convert a streamly Array into a bytestring cost-free?
10:18:04 <geekosaur> fendor, you depend on a package, that package is installed and uses its final install location
10:19:12 <fendor> geekosaur, so I can usually not overwrite this location?
10:19:17 <fendor> e.g. the data-dir
10:19:59 <geekosaur> if you meant "override" then correct.
10:21:08 <fendor> yeah, I meant that
10:21:10 <fendor> Ok, thanks
10:31:12 <d34df00d> So there are `cc-options` to pass options to the C compiler. What's the right way to pass options to the C++ compiler? (I'm using inline-c-cpp)
10:31:23 * hackage filepath-bytestring 1.4.2.1.5 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.5 (JoeyHess)
10:36:54 * hackage pomaps 0.1.0.0 - Maps and sets of partial orders  https://hackage.haskell.org/package/pomaps-0.1.0.0 (sgraf812)
10:48:00 <zincy> What is the correct way of returning a composite primary key with postgres-simple?
10:48:04 <zincy>      RETURNING (class_type_id, start_timestamp)
10:49:03 <zincy> And then I guess you have a row and you then define a FromRow instance for the ClassId type which represents the composite key
10:49:34 <Ailrun[m]> @pl \f flip ((>=>) . f)
10:49:34 <lambdabot> (line 1, column 11):
10:49:34 <lambdabot> unexpected ">"
10:49:34 <lambdabot> expecting pattern
10:49:44 <Ailrun[m]> @pl \f -> flip ((>=>) . f)
10:49:44 <lambdabot> flip . ((>=>) .)
11:01:30 <d34df00d> Alright. What's the easiest while efficient way to call C++ code from Haskell?
11:01:57 <hpc> via C, probably
11:02:00 <d34df00d> I'm using inline-c-cpp right now, and it results in almost twice as much time spent in C++ than the corresponding C++ version.
11:02:06 <d34df00d> The code is here: https://github.com/0xd34df00d/edit-distance-linear-bench/blob/master/src/Text/EditDistance/Cpp.hs
11:02:25 <d34df00d> A test program in C++ runs in about 1.3 secs, while the corresponding Haskell version calling this function runs in 2.4 secs.
11:03:06 <wildtrees> how do I stack install a package off of hackage that generates a binary? it only builds for a specific ghc as well 8.4.4 iirc 
11:03:10 <d34df00d> hpc: uh, that's my fallback option, since that'd imply lots of glue code.
11:06:43 <electricityZZZZ> what are the algorithms which a compiler spends most of its time executing? (and are those algorithms mostly the same across languages?)
11:07:50 <wildtrees> electricityZZZZ, ghc can spend alot of time type checking if you do really complicated things, I am not expert in this matter, but optimizations tend to be pretty heavy on time 
11:08:38 <electricityZZZZ> ok, but then what are those algorithmically? tree traversal? graph matching? etc
11:12:01 <sm[m]> wildtrees: stack install PKG-VERSION, as a start
11:13:00 <wildtrees> will that resolve to a working ghc? I specified ghc via --resolver and it seems to be chugging along now, sm[m] 
11:14:12 <sm[m]> If PKG has the right base bounds, Iâ€™d think it would, but Iâ€™m not sure
11:14:49 <sm[m]> â€”resolver is a good way to be sure
11:15:01 <wildtrees> oh ok, I just don't use stack that much, but I know quite a few packages won't install on anything other than like/or latter than ghc 8.4.4 
11:15:22 <wildtrees> hugs, do you implement the full haskell98 report? ;) 
11:16:00 <hugs> wildtrees: I consulted a magic 8 ball, it says "doubtfully so"
11:18:17 <geekosaur> hugs did the whole report iirc, plus some extensions (such as trex)
11:18:53 <wildtrees> hugs, https://www.haskell.org/hugs/ <-- see this for what I was referring to 
11:18:59 <wildtrees> what was/is trex? 
11:19:12 <hugs> huh, alternate haskell compiler
11:19:13 <geekosaur> an old proposal for extensible records
11:20:20 <geekosaur> it also supported mptc and a few other ghc extensions, but not any of the more recent ones like type families
11:20:21 <wildtrees> hugs, I think Hugs was just an interpreter written in like C, it's is/was quite portable 
11:20:24 * hackage morpheus-graphql 0.9.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.9.0 (nalchevanidze)
11:20:26 <geekosaur> yes
11:20:32 <wildtrees> geekosaur, did it have fun deps? 
11:20:46 <geekosaur> yes
11:21:08 <ski> and existentials
11:21:20 <geekosaur> mtl 1.x worked in hugs; I don't think 2.x was ever tested though
11:21:46 <wildtrees> hugs was just an interpreter though, right? 
11:21:51 <geekosaur> yes
11:22:21 <wildtrees> I remember I tried hugs, didn't like it , came here a few months latter, and people recommended ghc, and haskell began growing on me 
11:22:32 <geekosaur> whole-program, so I think didn't have some shortcomings ghc does (notably recursive module imports)
11:33:35 <monochrom> hugs has simpler error messages
11:34:01 <hugs> error: daily hug quota not met
11:34:13 <monochrom> haha
11:34:32 * monochrom hugs hugs
11:34:38 <hugs> <3
11:35:03 <Uniaika> o/
11:35:17 <MarcelineVQ> â€‹@hugssnack
11:35:49 <monochrom> Part of simpler error messages comes from, unlikely GHC, not trying to be the most general System F-omega internally.
11:36:24 * hackage schemas 0.4.0.1 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.4.0.1 (PepeIborra)
11:53:56 <moet> > read "-1" :: Word
11:53:58 <lambdabot>  18446744073709551615
11:54:01 <moet> :(
11:54:25 <moet> i understand where this comes from but it still feels very nonintuitive from a "haskell" perspective
11:54:49 <hugs> moet: it's unsigned, what do you expect :P
11:55:43 <sm[m]> It could reject negative numbers
11:56:51 <moet> yeah, i'd expect a "no parse"
11:57:06 <moet> this overflow behavior feels too much like C :)
11:57:17 <moet> > -1 :: Word
11:57:20 <lambdabot>  18446744073709551615
11:57:22 <moet> same same
11:57:39 <[exa]> that at least throws a warning about overflowed-literals
11:59:21 <[exa]> btw the implementation in (Read Word) is basically fromInteger.read
11:59:50 <moet> yes, that's the problem :)
11:59:57 <moet> (in my opinion)
12:00:44 <MarcelineVQ> I have a haskell program that will occasionally eat 600% cpu, without warning, seemingly impossibly <_< idk how long it'll do this since I don't let it continue to do so. It doesn't use forkIO or async, all it does is check a file for the last writetime, do an action if it has changed, threadDelay for 15 seconds, and try again in a loop. It will do this crazy cpu use regardless of whether the file modification time has changed or not.  I don't 
12:00:44 <MarcelineVQ> understand how it can go nuts on cpu use when it has a 15 second wait between loops.
12:01:10 <MarcelineVQ> anything obvious to cause that https://github.com/MarcelineVQ/vid_dl/blob/master/src/Lib.hs#L54 ?
12:01:13 <[exa]> moet: the ase function is here https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Read.html#readNumber
12:01:18 <[exa]> *base
12:01:56 <MarcelineVQ> The sudden huge cpu use happens at entirely random times, afaict so far, and rarely.
12:03:06 <MarcelineVQ> Which makes it reeeal hard to try to narrow down with rts or profiling options
12:03:12 <[exa]> moet: anyway Reading is not parsing (just as Show is not prettyprinting) and I guess that the behavior should closely reflect the actual code `-1::Word`
12:04:42 <[exa]> MarcelineVQ: can you strace the program to see what it does during the spike?
12:05:48 <MarcelineVQ> [exa]: never used that before, will look into it though thank you
12:05:49 <wildtrees> MarcelineVQ, shot in the dark here, massive garbage collection? 
12:07:42 <MarcelineVQ> idk what there is to collect, could try forcing the times I pass along I guess. I wish the problem was more consistent
12:08:28 <[exa]> MarcelineVQ: `doEvent` is not triggered, right?
12:08:50 <MarcelineVQ> the program doesn't use crazy amounts of memory, and there is a large delay between the loops that are creating things
12:08:58 <[exa]> MarcelineVQ: otherwise it doesn't look like there would be a thunk buildup or anything like that
12:10:36 <MarcelineVQ> doEvent only runs if the file modification time changes but this issue happens regardless of whether the file has changed recently
12:10:53 <vroomvroom> Is it possible to optimize something like length [1..9999] > 2 ? 
12:11:49 <[exa]> vroomvroom: what property would you want to optimize?
12:13:21 <vroomvroom> It seems to actually compute the length before comparing to 2, when we know the length is greater than 2 we don't need to continue to compute the length
12:13:52 <glguy> If you want a different algorithm you'll need to use one. For example: not . null . drop 2
12:14:04 <vroomvroom> this kind of optimization could allow us write length [1..] > 2
12:14:46 <vroomvroom> glguy: oh that's clever
12:14:46 <iqubic> vroomvroom: glguy's suggestion is pretty useful here.
12:14:50 <[exa]> vroomvroom: you must not touch the end of the list, which basically translates to "not use length".
12:16:33 <geekosaur> a compiler plugin might notice comparison with a constant and rewrite it. (standard rewrite rules only consider types, not literal-ness)
12:16:57 <geekosaur> it's not clear how generally useful this would be especially with large constants
12:17:03 <iqubic> Yeah.
12:18:31 <vroomvroom> ok so even if compilers are smarter than ever, I still need some brain cells to code :)
12:19:00 <iqubic> Yes. Hasn't that alway been the case?
12:19:32 <hugs> lol
12:20:16 <geekosaur> the day it's smart enough to code for you, it applies for your positionâ€¦
12:20:36 <hugs> I think there's a relevant SMBC
12:21:04 <geekosaur> this would not surprise me
12:21:41 <hugs> eh, not strictly related, but this reminded me of it :P http://www.smbc-comics.com/?id=2362
12:21:49 <iqubic> Might be some relevent XKCD too.
12:23:39 <MarcelineVQ> [exa]: strace should be helpful, thanks for the tip, it's clearly showing activity only once every 15 seconds, so it should also be clear when it's doing otherwise and hopefully tell me what it's doing
12:23:58 <solonarv> geekosaur: actually, a rewrite rule could rewrite 'length xs > n' to '(nut . null . drop n) xs' just fine
12:25:20 <geekosaur> sure, but it's most useful when n is known to be a constant
12:25:26 <[exa]> MarcelineVQ: you might need `strace -f` which follows the spawned processes/threads
12:25:38 <geekosaur> or more precisely, that computing n is faster than computing length xs
12:25:46 <MarcelineVQ> oh? thank you
12:26:28 <MarcelineVQ> that does result in more output
12:27:03 <geekosaur> you also want +RTS -V0 or you get a *lot* of noise from the rts
12:28:52 <MarcelineVQ> I'll give that a try if I can't make sense of the strace, I don't want to change rts options in case they dissappear my already rare error :>
14:01:29 <olle> I'm writing a cli tool, and I want to store configuration options somewhere. Where would be a good place for that?
14:02:58 <olle> Also, how do I use writeFile for another directory? `writeFile "~/.abc" string" always gives me "no such file or dir" exceptions
14:04:07 <srid> `getXdgDirectory XdgConfig "myconfig.yaml"` https://hackage.haskell.org/package/directory-1.3.5.0/docs/System-Directory.html#v:getXdgDirectory
14:05:42 <ChaiTRex> olle: I think maybe ~ is a shell thing rather than a Haskell thing.
14:05:49 <maerwald> correct
14:05:57 <ChaiTRex> olle: https://stackoverflow.com/questions/43023445/haskell-does-not-interpret-users-home-directory-correctly
14:05:57 <maerwald> ~ is a valid filename
14:06:10 <maerwald> some path libraries incorrectly treat it special
14:06:17 <hpc> expanding ~ is a shell thing
14:06:29 <olle> Aha!
14:07:07 <olle> ./ didn't work either, so maybe that should have clued me in
14:07:27 <olle> srid: was that in response to me?
14:07:37 <MarcelineVQ> olle: yes
14:08:22 <olle> that gives me a filepath, I can writeFile on?
14:08:36 <ChaiTRex> olle: System.Directory has getHomeDirectory :: IO FilePath
14:09:51 <maerwald> directory is an unreliable package, use unix if you are on unix
14:10:20 <olle> getXdgDirectory gave me ~/.config/ which might be even better
14:10:45 <olle> but with an absolute path, not ~
14:10:49 <olle> so that's great, thanks a lot
14:12:02 <maerwald> the way it looks up home directory is also not really correct
14:12:17 <maerwald> and only works in login environments
14:13:05 <olle> what do you mean use unix? using the "turtle" package or something instead?
14:13:12 <maerwald> 'unix' package
14:13:16 <olle> aha
14:13:56 <maerwald> homeDirectory <$> (getEffectiveUserID >>= getUserEntryForID)
14:14:14 <maerwald> correctly gets the home directory of the user running the current process
14:14:28 <maerwald> https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-User.html#v:homeDirectory
14:15:04 <maerwald> directory package just looks home $HOME env, which may be unset or whatnot
14:16:04 <tydeu> Will GHC always iinline functions of the form `funName = otherFunName`?
14:16:24 <tydeu> Or do they need inline pragmas to guarentee that?
14:17:12 <olle> that's great, maerwald! thanks! so it probably works on macos too? 
14:17:29 <maerwald> as long as that's POSIX =)
14:20:48 <olle> maerwald sounds great
14:22:38 <olle> and when concating file paths, should I use intercalate?
14:23:03 <maerwald> don't use the filepath library xD
14:23:37 <maerwald> well, it's not that bad
14:23:45 <olle> nevermind I just use ++ to join homedir with filename :D
14:24:07 <maerwald> but </> is terrible: e.g. "foo" </> "/bar" -- yields "/bar"
14:24:20 <olle> I got it working with the unix package so thank you very much!
14:24:43 <maerwald> so if you have user controlled unsanitized input, </> may produce undefined results
14:26:00 <olle> I see! For now the input is controlled by me
14:26:39 <maerwald> well, then it's fine: https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath-Posix.html#v:joinPath
14:28:16 <olle>   home <- homeDirectory <$> (getEffectiveUserID >>= getUserEntryForID)
14:28:16 <olle>   writeFile (home ++ "/.cndb") "hello"
14:28:56 <olle> joinPath might be advantagus somehow tho?
14:29:23 <maerwald> "normalises" the filepath (removing extraneous slashes etc), but your code should work too
14:29:35 <olle> Aha
14:30:10 <olle> well thanks for the help! and happy new year
15:03:52 <olle> what is usually the prefered data structures when storing data in haskell? yaml, json or something else?
15:06:39 <Uniaika> olle: is it for configuration or just storing? do you need to send it over the wire or on disk? do you need memory access?
15:06:58 <Uniaika> olle: also: are dhall and sqlite proper solutions for what you're asking?
15:07:19 <Uniaika> (note that sqlite3 can open in-memory databases)
15:08:51 <olle> It's just for storing, and only for the program to use. I think using a file as db is fine, as it wont contain any sensitive data
15:09:07 <olle> will look into dhall
15:13:36 <EvanR> if your "data" has JSON instances from aeson, then a json file would be dead simple if unimaginative!
15:14:04 <olle> my data will probably look like this
15:14:04 <EvanR> but an sqlite database file would be safer in the long term
15:14:07 <olle> { "user": [[a, b], [c, d]], "global": [[a, b], [c, d]] }
15:14:55 <EvanR> looks like a straight forward record type amenable to JSON instances
15:15:01 <olle> is sqlite a good option if I want to distribute the application as well?
15:15:17 <EvanR> sure
15:15:50 <olle> It wouldnt be any extra setup for the user I mean?
15:15:51 <EvanR> if there are only 8 parameters total... a file with 8 lines might also work
15:16:05 <maerwald> db for configuration file? :> wat
15:16:06 <olle> Yea, it feels easier with just a file
15:16:20 <EvanR> "ini file"
15:16:29 <olle> but then I think json is what I'll go with
15:17:09 <maerwald> toml is also nice
15:17:31 <maerwald> and more readable imo
15:17:39 <olle> it does look nice
15:17:59 <maerwald> XML is also an option, hehe, but uagh
15:18:22 <maerwald> (I remember openbox used a huge XML file for configuration)
15:19:51 <olle> but if I want to store other data than config stuff, sqlite would be the prefered method?
15:20:34 <olle> it would't contain anything sensitive anyway, so maybe a json file for that too
15:20:47 <maerwald> not sure about that, hard to judge without knowing the exact use case and how you expect your application to evolve
15:21:12 <maerwald> even many package managers don't use databases, but plain files 
15:21:21 <solonarv> whether the data is sensitive or not is orthogonal to choice of format: all of them can be encrypted/decrypted as an unstructured blob
15:22:04 <Uniaika> olle: if your file is a configuration file, go dhall. I personally distribute nix files with my applications so I don't have to care about writing installation instructions for debian/fedora/rhel/centos/ubuntu/void/arch/gentoo/slackware/
15:22:13 <solonarv> anyway, I've never used it but have heard only good things about sqlite; its main drawbacks are that you need to write SQL, and that you can't just open the files in a text editor whenever you want
15:22:38 <Uniaika> olle: however, know that you can store unstructured data in sqlite, it speaks json as well
15:23:18 <maerwald> last time I used sqlite somewhere, I regretted it (but it wasn't a user application)
15:23:37 <EvanR> sqlite has extra protection against hard drive issues
15:23:59 <EvanR> but for config files this probably isn't relevant
15:24:37 <olle> for config I'm probably going to store in as a toml/json file in the homedir 
15:25:03 <olle> ill have a think about the actual application data that has to be stored :)
15:29:40 <Uniaika> olle: please no json :( it doesn't have comments
15:29:54 * hackage bitwise-enum 0.1.0.0 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-0.1.0.0 (jnbooth)
15:29:59 <Uniaika> (in the end do what you feel is right, don't take my comment as an order)
15:30:47 <solonarv> well, you can use "json but with comments"
15:30:54 <solonarv> I can't remember, does aeson allow comments?
15:30:57 <olle> both toml and json seems to have packages that does everything I want
15:31:20 <olle> so I might go for toml simply because I havent used it before
15:34:24 * hackage bitwise-enum 0.1.0.1 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-0.1.0.1 (jnbooth)
15:35:54 * hackage bitwise-enum 0.1.0.2 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-0.1.0.2 (jnbooth)
15:35:55 <Uniaika> olle: godspeed!
15:36:11 <Uniaika> solonarv: you "can" if the library you're using deviates from the standard
15:37:01 <Uniaika> but at this point you could very well be using YAML, as every library under the sun implements a very specific subset of YAML that slightly deviates from the others' implementation
15:37:14 <solonarv> or you could adhere to json5, I suppose
15:37:16 <solonarv> it has comments
15:37:37 <solonarv> but IDK if there is a Haskell library for that
15:37:42 <Uniaika> it's a superset, so you'd have to make sure your tooling works for it
15:38:48 <Uniaika> I'm not going to throw arguments like "auditing libraries" and stuff because only security experts & co. do such a thing, but yeah, I actually like Aeson, not sure I'd want to switch to another libaray :P
15:43:04 <fendor> Uniaika, https://hackage.haskell.org/package/waargonaut looks cool, too.
15:45:24 * hackage bitwise-enum 0.1.0.3 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-0.1.0.3 (jnbooth)
15:49:35 <wikiemol> Hello! Is there a way to :force an expression in GHCI without having to put the expression into a variable first?
15:55:02 <Uniaika> wikiemol: not sure about that :/ The behaviour is the same for :sprint
15:55:57 <wikiemol> :(
16:00:23 <kj_> hi!
16:03:37 <pounce> >using bind syntax to create lists
16:03:42 <pounce> wew getting to big brain haskell now
16:04:36 <maerwald> bind syntax?
16:04:50 <pounce> w >>=
16:05:03 <pounce> err, the bind operator
16:05:10 <maerwald> yeah, that is not syntax
16:05:45 <dmwit> who cares whether it's syntax
16:05:52 <dmwit> just be happy for the achievement lmao
16:06:01 * dmwit high fives pounce
16:06:39 <pounce> ty dmwit lol
16:07:23 * pounce after just having written a parser; sees a token
16:07:29 <pounce> . o O is this syntax
16:09:12 <Uniaika> > [4] >>= (\x -> x : [32])
16:09:14 <lambdabot>  [4,32]
16:10:16 <Uniaika> pounce: I see 2020's geting off to a great start!
16:11:08 <maerwald> > [4,6] >>= (:[32])
16:11:12 <lambdabot>  [4,32,6,32]
16:11:38 <pounce> i was working on https://projecteuler.net/problem=65 and i wanted a quick way to represent the list for `e`
16:12:02 <pounce> > [2,1] ++ ([1..] >>= k -> [2*k,1,1])
16:12:03 <lambdabot>  error:
16:12:04 <lambdabot>      Pattern syntax in expression context:
16:12:04 <lambdabot>          [1 .. ] >>= k -> [2 * k, 1, 1]
16:12:13 <pounce> > [2,1] ++ ([1..] >>= \k -> [2*k,1,1])
16:12:16 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,14,1,1,16,1,1,18,1,1,20,1,1,22,1,...
16:12:20 <pounce> yee
16:12:30 <pounce> seems better than what i could do with list comprehensions
16:12:45 <maerwald> yeah, I wish we didn't have list comprehensions :P
16:14:36 <pounce> do they always have a restriction on the "pure" return value?
16:15:16 <amalloy> i only use list comprehensions instead of do-notation when i want a filter. importing guard is a bummer. move that to Prelude please
16:15:29 <amalloy> also join
16:15:32 <pounce> ah makes sense
16:15:44 <pounce> is "guard" only for monadfail?
16:15:53 <amalloy> :t guard
16:15:54 <lambdabot> Alternative f => Bool -> f ()
16:15:57 <pounce> oh ok
16:16:59 <amalloy> it used to be MonadPlus, or MonadZero or something. i always forget the difference between those two
16:17:46 <pounce> i feel like i get alternative so i like it better
16:18:54 <dmwit> > "ea" >>= \c -> [(11,635),(4,0),(19,1443)] >>= \(m,b) -> [toEnum ((m*fromEnum c-b)`div`4)] :: String
16:18:56 <lambdabot>  "wewlad"
16:21:15 <dmwit> Oh, it's prettier with ord and chr. Missed my chance.
16:22:24 <maerwald> 50cent into the code golfing jar!
16:22:53 <maerwald> oh wait, this is the code obfuscation jar
16:23:08 <pounce> ye
16:23:27 <pounce> i think the first one was too long to be golfing lmao
16:23:53 <Uniaika> "nothing is obfuscated when you have access to the disassembly code." -- An old Reverse Engineering proverb
16:26:41 <iqubic> It is now 2020. Will this be the year of Dependent Haskell?
16:27:06 <pounce> ohno
16:28:35 <maerwald> yeah, because our code is not complicated enough yet!
16:29:40 <pounce> whats a good way to print out a `Rational` in decimal form?
16:30:58 <amalloy> convert it to a type that prints as a decimal, e.g. Double
16:31:44 <pounce> so `show . (fromRational :: a -> Double)`
16:32:29 <pounce> humm ty
16:34:00 <pounce> ok im bad at project euler but understand num types better thanks
16:36:24 <Uniaika> iqubic: first let it be the year of GHC 8.10 and then we'll think about that :P
16:36:58 <Uniaika> I need my type-level trickfuckery to compile fast enough before being able to determine at compile-time that my regexps are bound to fail
16:40:47 <iqubic> Well, this is pissing me off.
16:51:23 <iqubic> Why is GHC claiming that _Number from Data.Aeson.Lens is a type hole?
16:51:40 <p0a> Hello is haskell used for webdev?
16:51:49 <iqubic> It can be.
16:52:05 <p0a> Is it a good idea?
16:52:50 <p0a> I want to design a basic marketplace, I have no experience in web dev and little in haskell but the whole thing should be relatively simple and I've done programming for the past 15 years on and off as a hobby in C++/lisp mostly
16:53:54 <iqubic> Learning Haskell will be rather hard.
16:54:18 <p0a> I know some Haskell and lots of math
16:54:39 <p0a> so I'm not without hope
16:56:41 <p0a> I am wondering if doing webdev in Haskell is a good idea though. I have not kept up with web dev at all and the last thing I remember is ruby on rails and all that
16:57:12 <cvlad-> p0a: If you've done lisp, you might have an easier time than most, but the strong typing and lack of an "escape hatch" to just "do this one small impure thing in this one place" can be rough for beginners.
16:57:12 <cvlad-> Also, not having experience in web dev makes things even harder, because there is usually very little (if any) documentation to Haskell libraries. If you know the problem domain, and understand Haskell, it's fairly easy to figure out how to use them, but if you're trying to learn both at the same time, you might have a rough time.
17:00:39 <p0a> cvlad-: thanks, I think lack of documentation will do it for me 
17:00:47 <cvlad-> p0a: It also depends a lot on how you define a good idea. What do you want to accomplish? If you just want to get a website done, learning Haskell and webdev at the same time is most likely not going to be the easiest/fastest path. It might be the most rewarding path, where you get to learn a ton of things.
17:01:08 <p0a> cvlad-: how can I counter lack of documentation?
17:01:44 <dsal> iqubic: You're probably importing the wrong package.
17:01:51 <iqubic> dsal: Are you sure?
17:02:15 <dsal> What are you importing?
17:02:40 <iqubic> aeson-lens.
17:02:47 <dsal> That doesn't have _Number
17:03:02 <dsal> http://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html  <- no _Number there.
17:03:08 <dsal> vs. https://hackage.haskell.org/package/lens-aeson-1.1/docs/Data-Aeson-Lens.html
17:03:36 <iqubic> Why do both of those exist, and have Data.Lens.Aeson?
17:03:48 <dsal> Because people can make whatever they want and call them whatever they want.
17:05:30 <cvlad-> p0a: I can only share my personal story: I started with Haskell because I was frustrated at the number of bugs me and my team were producing. It felt this was one way to reduce their number, and I convinced myself it is (after spending a lot of time learning). The project I was working on wasn't going to change, so I changed jobs and I now work with Haskell full-time, and I love it.
17:05:30 <cvlad-> What I can say is, two years later, I can look at a library and I don't usually need any documentation. The types in Haskell are so expressive, you can usually guess what a function does by just its signature. This also means that functions can't really lie: if you see a function like `Int -> Int`, you can be sure that it takes an int and calculates something to return some other int; it can't possibly do a database 
17:05:30 <cvlad-> call or log something or read a file.
17:06:53 <dsal> Every time I've learned a new thing, there's been a phase of "the documentation for this thing is bad and stupid" and then I learn it and it's mostly OK.
17:07:51 <dsal> There's a lot of bad and stupid haskell documentation, but you can get really far changing your goals from "I want a function named xxx" to "I want a function that makes a T out of a J"
17:08:03 <p0a> dsal: The documentation for XCB wasn't that good, which is the recommended library for X programming in C
17:08:47 <p0a> Of course that's somewhat arcane so I'm hoping Haskell will not be as difficult in that aspect
17:09:11 <dsal> I'd never heard of XCB, but it looks like a replacement for xlib.  I once wrote something against xlib decades ago, but I don't think anyone even back then would recommend using xlib for programming X.
17:09:40 <p0a> Yeah it's an xlib replacement and perhaps I've been misguided in that aspect dsal (in wanting to use XCB/xlib)
17:09:54 <p0a> in any case, I'm a hobbyist so it's all up to me
17:10:03 <dsal> If you understand X11 pretty well, it seems to make enough sense, depending on what you're trying to do.
17:10:38 <p0a> I just wanted to code a low level hack for something I had in mind, it never materialized and I barely know X11 
17:11:50 <dsal> Oh.  Well, yeah.  If you wanted to make an HTTP request and you started with gnu radio, you'd be very sad.
17:13:08 <p0a> lol
17:14:14 <dsal> Yeah, the last thing I wrote against X11 directly was in 2000.  It was a tool I used to remotely record keystrokes across the network.
17:14:59 <p0a> Sounds like 2000. I wanted to black out portion of the display when a button is pressed
17:15:26 <dmwit> FWIW you can be sad wanting to make an HTTP request and starting with wget, too, if you really don't know HTTP at all.
17:15:57 <evelyn> My friend's scope ran HP-UX with FVWM. It was hateful. My experience of X since then has not been much better.
17:15:57 <dmwit> I can say this with great confidence, having just helped my very smart but not completely modernized father write a script to reboot his router every night last weekend.
17:16:19 <dsal> heh
17:16:20 <p0a> maybe netcat will do it though :P I am going to attempt to set up a coding environment for Haskell now. There's "Things I wished I knew about Haskell" that I'm going to read a bit. Then try to move on to web libraries
17:18:39 <dsal> Point is that most things you're going to try to do will have documentation that assumes a certain thing about the reader.  Most haskell documentation assumes you can navigate types well, and you know some common classes.  If you know these things, you can get a lot of information from a single word ("Oh!  This is a Functor!").  If you don't know them, it'll be frustrating.
17:19:54 <p0a> I know some things; I know what a functor is but I don't know much about classes because I keep forgetting about how Haskell works exactly
17:20:46 <p0a> and honestly what J -> T conveys to me remains to be seen in practice
17:21:43 <dsal> haskell itself is pretty simple.  It's the easiest language I program in regularly.
17:22:20 <dsal> The parts that get tedious are often just the areas I'd write bugs in other languages.  There are a couple areas that are a little harder to reason about.
17:24:09 <p0a> part of what seems unappealing to me about Haskell is how fast it is; I wrote some basic vector computations that were quite slow (and I believe I had issues with accuracy too; at least in common lisp the implementation was actually broken and I resorted to C++ with gnump)
17:24:47 <dsal> Did you profile it and/or discuss performance with someone who knew how to make improvements?
17:24:47 <p0a> however to Haskells credit I did absolutely nothing to make the code faster. I didn't look into how to optimize it
17:25:08 <p0a> no I didn't but it was hard to do that in part because it was some research that I didn't want to share
17:25:53 <p0a> it was actually just a personal project, but I still didn't want to share it
17:26:20 <dsal> So it's unappealing when you make something slow and don't make it faster?  :)
17:26:42 <p0a> heh reading `stack templates' gives me `hakyll-template' which seems nice :)
17:26:54 <dsal> Often my first attempt to do something isn't necessarily the fastest way to do it, but it's  generally fast enough.
17:27:17 <dsal> I use my own stack template.  Other people's templates don't seem as useful.
17:27:24 <p0a> sure; when you do millions of repeats of a simple thing and the difference is 30 seconds it's annoying
17:27:39 <p0a> but yeah I didn't know how to fix it and that's what frustrated me
17:31:27 <a1c> (\out -> let fn = out fn in fn) :: (t -> t) -> t
17:31:43 <a1c> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
17:32:34 <dsal> p0a: There are lots of ways to make a slow piece of code faster, but you've gotta figure out what's making it slow.
17:33:02 <a1c> callCC ((ContT r m b -> ContT r m b) -> ContT r m (ContT r m b)) -> ContT r m (ContT r m b)
17:33:15 <a1c> a ~ ContT r m b
17:33:21 <p0a> dsal: I agree. I don't know how to do that. In C++ I just reason by thinking in terms of big-O ; I never wrote (or was involved in) large enough projects where this was not feasible
17:33:39 <p0a> also hakyll is static websites so I don't need that :P
17:34:42 <dsal> Sometimes it's frustrating, though.  I had a particular integer encoding being the bulk of my CPU consumption in a project using proto-lens.  I spent a long time optimizing that one function.  I went as far as to just replace the haskell version with a highly optimized C version.  It was... slightly faster.  I learned GHC actually spat out some pretty good code.
17:37:53 <zeta_0> can i add the language pragmas to a nix file? i have a default.nix file with the installation and configuration for yesod, so how would i add the language pragmas to default.nix as well, it would save me the hassle of having to manually place them over and over again?
17:39:39 <dsal> I assume so.  It's pretty straightforward in stack.
17:39:45 <iqubic> I have no idea what's going on here.
17:40:54 <a1c> I have no idea what's going on with fixed-point in recursive call
17:42:19 <solonarv> zeta_0: that should be possible
17:43:04 <solonarv> in the end you just need to pass -XFlexibleContexts -XFlexibleInstances ... to ghc
17:43:39 <solonarv> maybe look at what cabal2nix outputs when it is run on a cabal file with nonempty default-extensions field
17:51:57 <zeta_0> if not, instead in the cabal file, add a default-extensions block like the yesod book recommends, then do cabal2nix, it should save me from having to manually write those language pragmas over and over again, which would be very painful
17:59:43 <p0a> a1c: what do you mean by fixed point in recursive call?
18:00:59 <a1c> p0a: gotoC = C.callCC $ \out -> let fn num = out (fn, num) in return (fn, 0)
18:01:34 <a1c> gotoEx2 = flip C.runContT return $ do (marker1,num) <- gotoC; marker1 (num +1)
18:05:26 <dsal> @src fix
18:05:26 <lambdabot> fix f = let x = f x in x
18:05:27 <iqubic> Well, I'm getting pissed off by lens here.
18:05:53 <iqubic> deep isn't doing what I want it too.
18:07:06 <p0a> so by fix you mean something that when applied to itself is just itself right? The basic idea is 1:[1,1..] is itself
18:07:19 <ChaiTRex> iqubic: this is good. something to learn.
18:07:53 <a1c> that marker1 is fn, 
18:08:24 <iqubic> ChaiTRex: I'm trying to use deep to do AoC 2015, Day 12, Part 1
18:08:29 <iqubic> https://adventofcode.com/2015/day/12
18:08:52 <ChaiTRex> iqubic: soory, I don't know lenses personally.
18:08:55 <dsal> What is the issue?
18:08:59 <iqubic> Totally fine.
18:09:22 <amalloy> p0a: in general nothing applied to itself is itself. rather, fix is, for some function f, finding a value x such that applying f to x yields x again
18:09:44 <iqubic> dsal: The issue is that "input ^.. deep _Number" is only returning the first number found in the JSON input.
18:09:49 <p0a> amalloy: in my example f=: and x =[1,1..]
18:09:57 <p0a> amalloy: I meant, f=1:
18:10:18 <p0a> I think a1c's example is similar but in lambda calculus instead
18:10:36 <a1c> `fix f` will return f's fixed-point?
18:10:46 <amalloy> p0a: i know that is the canonical example of fix, but there is nothing there that fits "something applied to itself"
18:11:06 <p0a> amalloy: right, misspoke!
18:11:42 <p0a> so the web frameworks in the haskell wiki use apache or are they servers by themselves?
18:11:56 <a1c> fn = out fn, does that fn equal to `fix out`?
18:12:57 <iqubic> I don't think so.
18:13:05 <dsal> iqubic: that seems incorrect.  What is input?
18:13:29 <iqubic> dsal: Input is a String.
18:13:50 <dsal> Oh. You'll want to parse it as json first, I'd think.
18:14:15 <iqubic> How do I do that? I've literally never used aeson before today..
18:18:58 <p0a> I'm going to give Happstack-lite a go
18:20:54 * hackage simplest-sqlite 0.1.0.2 - Simplest SQLite3 binding  https://hackage.haskell.org/package/simplest-sqlite-0.1.0.2 (YoshikuniJujo)
18:22:15 <dsal> @hackage aeson
18:22:15 <lambdabot> http://hackage.haskell.org/package/aeson
18:23:23 <p0a> I get this error after running `stack new hakyll-template; stack init'
18:23:24 <p0a> https://pastebin.com/aPcDKWzP
18:24:27 <dsal> pounce: What version of stack?  Did you mean to name a project 'hakyll-template'?  Did you go into that directory?
18:24:50 <dsal> er, p0a 
18:25:10 <p0a> dsal: I thought `stack new hakyll-template' uses the template. I ran that command under project-0/
18:25:41 <dsal> 'stack new x' creates a new project called 'x'
18:25:49 <dsal> in a new directory called 'x'
18:25:55 <p0a> dsal: my stack --version has a warning "unsupported build that may use different versions of dependencies etc..."
18:26:23 <p0a> I downloaded it with `apt install haskell-stack'
18:26:32 <p0a> says to run `stack upgrade --force-download'
18:26:35 <dsal> It's probably prehistoric.
18:28:26 <p0a> ah yeah upgrading worked! thank you
18:28:33 <p0a> also thanks for the tip I thought I had a template going lol
18:36:40 <iqubic> Alright.. This thing is pissing me off so much.
19:12:44 <a1c> lines split String with 
19:12:49 <a1c> "\n"
19:13:00 <a1c> is there a version split with "\r\n"?
19:13:38 <ChaiTRex> You can filter out \r.
19:14:00 <Axman6> yeah . lines . filter (/='\r')
19:14:00 <ChaiTRex> > lines . filter (/= '\r') $ "test\r\n123"
19:14:03 <lambdabot>  ["test","123"]
19:14:20 <monochrom> Do you actually know your string contains \r\n?
19:15:24 <monochrom> Because for example if you use getContents you won't get the \r, even on Windows, it is already eliminated before reaching you.
19:16:26 <monochrom> (Conversely also true: you do putStrLn or putStr "\n", there will be \r inserted for you.)
19:18:05 <p0a> just as Bill intended.
19:18:50 <monochrom> I have a feeling that it was a CP/M convention that Bill simply adopted.
19:22:08 <dsal> I guess it makes sense to not conflate the two concepts.
19:22:28 <a1c> monochrom: but what if the ByteString is from socket?
19:22:29 <p0a> ah nice I didn't know
19:22:58 <dsal> String and ByteString are significantly less related than their names would suggest.
19:23:23 <monochrom> Yeah, then you simply don't have a "String".
19:24:31 <a1c> Axman6: is there a function called yeah?
19:27:30 <a1c> /= "\r" means not equal to "\r"?
19:27:35 <dsal> @hoogle yeah
19:27:35 <lambdabot> No results found
19:27:47 <a1c> @hoogle /=
19:27:47 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
19:27:47 <lambdabot> Data.Eq (/=) :: Eq a => a -> a -> Bool
19:27:47 <lambdabot> Test.Hspec.Discover (/=) :: Eq a => a -> a -> Bool
19:29:15 <ChaiTRex> :t (/= 'r')
19:29:17 <lambdabot> Char -> Bool
19:31:36 <a1c> > filter (/= '\r') "1\r2"
19:31:39 <lambdabot>  "12"
19:32:12 <ChaiTRex> > filter (== '/r') "1\r2"
19:32:14 <lambdabot>  <hint>:1:13: error: parse error on input â€˜/â€™
19:32:20 <ChaiTRex> > filter (== '\r') "1\r2"
19:32:22 <lambdabot>  "\r"
19:35:29 <phanimahesh[m]> That was gold. Is there a function named yeah.
19:35:47 <monochrom> heh
19:35:58 <phanimahesh[m]> With all the esoteric names I've encountered I won't be surprised if there was one
19:36:21 <phanimahesh[m]> Still digesting These.
19:36:22 <monochrom> There is a unix program named yes.
19:36:34 <dsal> > let yeah = cycle ["sure"] in    yeah
19:36:36 <lambdabot>  ["sure","sure","sure","sure","sure","sure","sure","sure","sure","sure","sure...
19:36:43 <ChaiTRex> > repeat 'y'
19:36:45 <lambdabot>  "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy...
19:36:57 <dsal> why did I cycle instead of repeat?
19:37:47 <monochrom> So I can apply unlines to get "sure\nsure\nsure\n..."
19:37:54 <phanimahesh[m]> > let yeah = cycle ["yeah", "sure", "will do", "OK"] in    yeah
19:37:56 <lambdabot>  ["yeah","sure","will do","OK","yeah","sure","will do","OK","yeah","sure","wi...
19:38:02 <dsal> that's it!
19:38:39 <phanimahesh[m]> Elementary, dear dsal!
19:41:24 * hackage intcode 0.2.0.0 - Advent of Code 2019 intcode interpreter  https://hackage.haskell.org/package/intcode-0.2.0.0 (EricMertens)
19:44:00 <dsal> Heh.  He rev'd that.
22:05:54 <Axman6> Just a reminder, python 2 is now EOL https://i.redd.it/ese4phhmh7841.jpg
22:11:21 <dsal> Worse:  Python 3 is LOL
22:27:20 <mycroftiv> â†— (â†— (â†— x)) dot â†— (â†— y) = ((x dot y) dsum ((â†— (â†— zerd)) dot x)) dsum (((â†— (â†— (â†— zerd))) dot y) dsum â†— (â†— (â†— (â†— (â†— (â†— zerd))))))
22:27:25 <iqubic> What is this?
22:27:31 <iqubic> I have no idea whay that mean.
22:27:43 <mycroftiv> oops misclick paste, sorry
22:58:54 * hackage morpheus-graphql 0.9.1 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.9.1 (nalchevanidze)
