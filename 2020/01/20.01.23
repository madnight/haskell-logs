00:38:12 <jle`> hi all
00:38:19 <jle`> there is no way to add cases to a closed type family?
00:38:23 <jle`> that another library defines
00:38:26 <jle`> :(
00:39:11 <mniip> no
00:39:17 <mniip> not safely
00:40:56 <jle`> i crave
00:40:57 <jle`> unsafety D:
00:43:40 <jle`> i guess it's just time to copy and paste an entire external library's module
00:43:57 <jle`> er, an external library's entire module
00:45:43 <lortabac> jle`: out of curiosity, which library?
00:46:57 <jle`> generic-lens
00:47:24 <jle`> hm maybe i can get away with not copying an entire module
00:47:29 <dmj`> isn't that what open type families are for
00:48:16 <jle`> it's from an external library so i can't change it :'(
00:49:07 <lortabac> can you wrap the existing type family into a larger one?
00:49:22 <lortabac> maybe by defining an auxiliary data type
00:49:23 * hackage mmsyn7ukr 0.7.5.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.5.0 (OleksandrZhabenko)
00:50:00 <dmj`> jle`: you can call one closed type family inside another
00:50:04 <jle`> i'm probably just going to have to replace all the code that uses that type family, but i can somewhat isolate it and maximize reuse due to some typeclass trickery i think ...
00:50:07 <dmj`> jle`: so maybe you can wrap it
00:50:13 <dmj`> inside another closed type family
00:50:28 <jle`> i want to call a function that is written using a closed type family
00:50:34 <jle`> so i can't get around rewriting the entire function
00:50:39 <lortabac> oh ok
00:50:47 <dmj`> ah :/
00:51:04 <dmj`> lortabac: sorry I didn't read that you had just recommended that :)
00:51:21 <jle`> :'(
00:52:54 <__monty__> I guess if you add to the family you have to change the function anyway? So a wrapped family and a function that simply dispatches for the wrapped family is the least work you can get away with?
00:53:34 <jle`> the function simply check if MyFam x ~ 'True
00:53:45 <jle`> i just wanted to add another case where MyFam MyType = 'True
00:53:54 <jle`> it doesn't actually use the type family, it's just a part of the constraint
00:54:03 <jle`> heh
00:54:03 <__monty__> Ah.
00:57:05 <dmj`> anyone used frag before?
00:57:09 <dmj`> @package frag
00:57:09 <lambdabot> http://hackage.haskell.org/package/frag
01:11:39 <dmj`> I got it to build
01:11:48 <dmj`> but it segfaults pretty hard
01:22:19 <comerijn> Is there a soft way to segfault?
01:23:15 <dminuoso> A what?
01:23:25 <dminuoso> Oh.
01:23:36 <dminuoso> merijn: I didnt catch the message before, you had me *really* confused
01:24:25 <pavonia> `error "segfault"` seems like one to me
01:25:51 <dminuoso> Fun fact, you used to be able to *recover* from a segmentation fault in Ruby... using *plain* Ruby with no funky things!
01:26:57 <merijn> dminuoso: You can do that in any language
01:27:01 <merijn> For some value of recover
01:27:23 <dminuoso> merijn: Without a signal handler!
01:29:50 <merijn> They need a signal handler somewhere
01:30:01 <dminuoso> Well, without an explicit one.
01:30:04 <merijn> The default handler for SIGSEGV is abort
01:30:11 <merijn> So the Ruby interpreter has to install one
01:59:04 <Maxdamantus> Another fun fact: the HotSpot JVM allows segfaults to occur in cold paths of code, where the signal is caught and the VM just figures out where the code is up to. It's basically used to test if a pointer is null without emitting an actual branch instruction.
01:59:50 <Maxdamantus> can often attach `strace` to a Java process and see the occasional segfault signals.
02:00:46 <fweht> whats the haskell way to count the number of tuples which satisfy something, id write `length[Nothing|i<-I,j<-J,...,P(i,j,...)]` or should i write `length[(i,j,...)|i<-I,j<-J,...,P(i,j,...)]`
02:01:05 <Maxdamantus> er, not quite "cold paths of code", but rather when the conditional branch is unlikely.
02:03:21 <iqubic> fweht: It seems weird to be writing P(i,j,...)
02:03:34 <iqubic> Most likely you don't want parensthesis there.
02:03:37 <fweht> iqubic: that dots are not literally
02:03:39 <Solonarv_> it doesn't really matter what you use as the "filler" element if you're just going to call 'length' anway
02:03:41 <iqubic> I know.
02:03:50 <Solonarv_> I'd just go for ()
02:04:01 <iqubic> Same.
02:04:06 <fweht> Solonarv_:  thats what i wanted i thing, something like Null, thanks!
02:04:08 <Solonarv_> i.e.: length [ () | ... stuff here ... ]
02:04:20 <Solonarv_> () is not really "something like Null"
02:04:24 <fweht> *i think
02:04:29 <Solonarv_> it's an empty tuple (with no elements)
02:05:00 <fweht> yes
02:05:21 <iqubic> Haskell doesn't have a concept of null.
02:05:44 <iqubic> I mean the closest thing you'll get is undefined. But no one likes using that in production code.
02:05:59 <fweht> no i know, but its some kind of default value just in the usecase way not in a mathematical way
02:06:27 <fweht> just like `IO ()`
02:06:57 <iqubic> Yes. That's a good use for ()
02:07:01 <Solonarv_> yes, exactly
02:07:31 <Solonarv_> there is only one value of type '()' (this value is also written '()'), so that value can't possibly contain any information
02:08:18 <iqubic> :t ()
02:08:20 <lambdabot> ()
02:08:30 <iqubic> So it's both a value and a type?
02:08:50 <fweht> i think it just has the same denotation
02:09:06 <Solonarv_> correct
02:09:19 <Solonarv_> the value and the type are separate, they're just written the same way
02:09:33 <Solonarv_> this is usually not a problem because values and types live in different "worlds" anyway
02:09:55 <olligobber> :k ()
02:09:57 <lambdabot> *
02:10:01 <iqubic> Yeah.
02:10:16 <Solonarv_> similarly, in 'data AnInt = AnInt Int' you have a type 'AnInt' and a value 'AnInt' which are totally different things
02:11:37 <iqubic> % :set -XConstraintKinds
02:11:37 <yahb> iqubic: 
02:11:48 <iqubic> % :k ()
02:11:48 <yahb> iqubic: () :: *
02:12:15 <iqubic> Damn. I was hoping to be able to show that () is also a valid constraint.
02:12:28 <Solonarv_> no, that's extra weird magic
02:12:37 <iqubic> What is?
02:12:44 <iqubic> () as a constraint?
02:13:37 <olligobber> `f :: () => Int; f = 1'
02:14:01 <olligobber> empty constraint
02:15:32 <kuribas> is there an easy to use IDE for linux which isn't emacs or vim?
02:15:44 <olligobber> atom?
02:15:46 <olligobber> nano?
02:15:55 <kuribas> IDE, not text editor
02:16:04 <kuribas> maybe atom...
02:17:01 <kuribas> I was just thinking something that could be set up globally, then everyone could use it over X windows, without installing anything.
02:18:14 <kuribas> maybe atom + hie?
02:34:46 <maerwald> kuribas: vscode
02:36:33 <maerwald> but then your input lag will be terrible
02:45:57 <kuribas> maerwald: it's ok with emacs
02:46:09 <plakband> Anybody else here notice that in vim, "i)", "a)", and surround breaks a lot in lambdas because it thinks the ( in e.g. \(Just _) -> ... is escaped?
02:46:24 * hackage ormolu 0.0.3.1 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.0.3.1 (mrkkrp)
02:46:30 <dminuoso> plakband: Using what plugin?
02:47:11 <plakband> Stock vim, I think? afaict vim-surround has the issue because it uses normal vim text objects
02:47:30 <Franciman> kakoune
02:48:01 <plakband> Try it, type \(Just _) and then vi) and see what it selects
02:48:27 <maerwald> I also think vscode is the only IDE that supports "type of expression" currently with hie
02:48:41 <maerwald> all others just look up identifier
03:11:02 <kuribas> Is there a reason servant-foreign doesn't use the Description and Summary types?
03:11:06 <kuribas> It just ignores them
03:11:21 <kuribas> I think having a description and summary is very useful
03:19:07 <phadej> for what it would use them, to generate comments?
03:22:53 <kuribas> phadej: yeah
03:22:53 <kuribas> phadej: or doc-strings in some languages
03:23:00 <kuribas> phadej: or doing whatever you want to do with servant-foreign
03:23:15 <kuribas> it's useful for a lot of stuff that's not external APIs.
03:23:25 <kuribas> as it monomorphises an API
03:30:40 <__monty__> plakband: o.O Yes, could never put my finger on it but yeah, `ab` and `ib` *do* misbehave a lot with lambdas. Thanks for pointing this out : )
03:33:25 <phadej> kuribas: but to answer your question directly, "is there a reason ...": no, there is no other reason than "nobody cared to write a patch"
03:33:37 <kuribas> phadej: can I write a patch?
03:33:45 <kuribas> phadej: I'll have to extend the type though
03:34:06 <phadej> that shouldn't be a problem
03:34:38 <kuribas> alright, expect a patch soon :-)
03:50:37 <Wasby> r
03:51:24 <Wasby> hi
03:53:41 <dminuoso> Is there a way to check unused identifiers across an entire library?
03:53:54 <dminuoso> (I suppose package-level is the correct term here)
04:03:52 <jle`> dminuoso: maybe you're looking for 'weeder' ?
04:07:57 <dminuoso> jle`: Ah mmm. Looks like I might have to patch it for cabal usage. :)
04:07:58 <dminuoso> Thanks!
04:17:54 * hackage servant 0.17 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.17 (phadej)
04:18:54 * hackage servant-foreign 0.15.1, servant-docs 0.11.5, servant-http-streams 0.17, servant-client-core 0.17, servant-client 0.17, servant-server 0.17 (phadej)
04:30:15 <aplainzetakind> warning: unrecognised warning flag: -Werror=all
04:30:27 <aplainzetakind> Am I wrong to expect this to work?
04:31:35 <piyush-kurur> hackage does not support cabal version 3.0.0 ?
04:32:09 <phadej> piyush-kurur: it doesn't, yet.
04:33:19 <piyush-kurur> phadej: thanks
04:41:19 <piyush-kurur> when using haddock (with cabal) I am unsure of how to give Markup to a module in a different component in multi-component library. The "ModuleName" does not seem to work neither does "component:ModuleName". even when component has visibility:public
04:42:32 <piyush-kurur> without that documenting a backpack based library seems to be a pain.
04:49:24 * hackage core-text 0.2.3.3 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.2.3.3 (AndrewCowie)
04:50:10 <phadej> piyush-kurur: i won't be surprised if haddock isn't really aware of multi-libs
04:50:15 <phadej> well-aware
04:50:24 * hackage unbeliever 0.10.0.5, core-program 0.2.4.1, core-data 0.2.1.5 (AndrewCowie)
04:51:23 <piyush-kurur> phadej: the document is being created nonetheless in the appropriate subdirectory of dist-newstyle
04:53:29 <piyush-kurur> so may be there might be "an easy way" to make haddock/cabal work with this. How does hackage link across packages ?
04:53:29 <phadej> piyush-kurur: yes, but from haddock perspective multilib is probably just an ordinary lib; but the intralinks have to do how the non-flat-namespace of parentlib:sublib is mapped into flat "(munged)-package-ids"
04:53:43 <phadej> as GHC isn't aware of multilib packages
04:53:51 <phadej> in fact, GHC isn't aware of "packages", but only units
04:54:01 <phadej> yet the terminology uses words package-id (which are really unit-ids)
04:54:18 <phadej> so, it's _not_ surprise if something related doesn't work
04:54:54 * hackage mmsyn7ukr 0.7.6.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.6.0 (OleksandrZhabenko)
05:17:33 <amy_monnet> Hey everyone, a friend and I are currently building a web app and we are using docker to containerize our application. We used the official Docker image from Docker hub but then when we built our container it was 3 GB! Has anyone else had a similar experience?
05:17:46 <amy_monnet> built our image *
05:18:11 <amy_monnet> also our image build took a really long time.. and all our app is doing at the moment is serving a static webpage
05:18:43 <__monty__> amy_monnet: Maybe you're including GHC in your container?
05:19:02 <amy_monnet> Yes we are. Don't we have to?
05:19:09 <__monty__> If the official container has GHC it's probably meant for *development* not deployment.
05:19:32 <__monty__> Most web apps shouldn't need a compiler at run-time.
05:19:48 <__monty__> GHC is huge so don't expect a small container if you're gonna include it.
05:20:46 <amy_monnet> https://github.com/haskell/docker-haskell/blob/master/8.6/Dockerfile here is the container
05:20:55 <amy_monnet> *docker file, sorry
05:21:22 <amy_monnet> I see so how should our work flow be?
05:22:15 <amy_monnet> For context. Here is our docker file 
05:25:23 * hackage pandoc-plot 0.2.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.2.0.0 (LaurentRDC)
05:27:04 <dmj`> amy_monnet: I use nix to build docker images that are lightweight, and then use `upx` on the haskell binary to compress it while preserving program semantics
05:29:16 <merijn> Compressing binaries is a waste of time, unless you're worried about paying bandwidth costs when transferring them
05:29:53 <maerwald> ricing
05:30:09 <merijn> maerwald: Actually has very real odds of it negatively affecting performance
05:30:51 <merijn> amy_monnet: I realise I'm a backwards luddite, but personally (assuming CI and production run the same environment) just build a static binary and copy it and call it a day
05:31:05 <amy_monnet> Interesting
05:32:01 <amy_monnet> Seems like a lot of you use Nix. Someone at our FP meetup presented on Nix and talked about how it essentially makes docker redundant. Would you recommend learning Nix/ replacing Docker with Nix?
05:32:36 <maerwald> amy_monnet: usually, you have an image that builds your application, then tars it up and sends the tar is output to your host. Then you create a busybox derived image that unpacks that tar and adds missing dynamic libraries, if any
05:32:59 <maerwald> static binary is a little more involved
05:33:17 <merijn> amy_monnet: In terms of deploying Haskell binaries are "just binaries" in the same sense as C/C++ applications. So there's 0 reason to ship the compiler with them. GHC (by default) links all Haskell libraries statically (so those are already in there), so the only thing to worry about is the C libraries (which are dynamically linked), but you can just statically link most (non-glibc libraries) in which 
05:33:23 <merijn> case your executable only depends on having the same glibc on the CI and production machines, which seems easy enough to arrange
05:33:23 <maerwald> and I advise against nix, if you don't have someone who knows it VERY well
05:33:39 <merijn> I know lots of people are super into Nix, but tbh it doesn't seem worth the hassle to me
05:34:15 <maerwald> merijn: the problem with nix is the bus factor
05:34:27 <maerwald> if you have one guy who knows it and he leaves, good luck
05:34:35 <maerwald> no one will be able to pick that up in a reasonable timeframe
05:35:01 <olligobber> yeah, I found nix too hard to learn and gave up
05:35:17 <merijn> maerwald: Well also, there's a lot of custom Nix-y stuff to learn and it just doesn't seem worth the investment to me
05:35:23 <amy_monnet> Yeh I here the documentation is atrocious 
05:35:37 <maerwald> there is a lot of documentation, but usually not about the things you need
05:35:49 <dmj`> merijn: well docker has to transfer its layers, so compression would help
05:35:58 <dmj`> merijn: less bandwidth you have to pay for
05:36:04 <dmj`> maerwald: but yes ricing :P
05:36:14 <merijn> dmj`: I mean, I would just not recommend using docker >.>
05:36:18 <maerwald> amy_monnet: really, you should deploy the binary in a busybox image
05:36:31 <merijn> dmj`: Also, you can achieve the same by just xzipping your binary/docker stuff before transfer
05:36:58 <merijn> dmj`: Leaving it compressed on the host has a very real chance of harming performance and 0 chance of improving anything other than "disk storage used"
05:37:03 <maerwald> if you want static linking, you're going into the musl direction, then you get all sorts of other problems
05:37:35 <merijn> maerwald: You can just static link most things (i.e. like everything except glibc), that gets rid of most issues
05:37:48 <merijn> maerwald: And keeping glibc in sync seems like it should be a manageable problem, tbh
05:37:51 <maerwald> even ncurses statically already makes problems afair
05:38:19 <maerwald> but yeah, static binaries are the best (if they work)
05:38:54 <maerwald> and then you also need a build image that properly supports static libraries everywhere
05:41:30 <sm[m]> morning..  deploying a haskell app is rocket science, not for mortals, it sounds like
05:42:32 <maerwald> yeah, my deployment runs as a pure side effect in the type system, while GHC compiles the application
05:43:38 <sm[m]> a complete guide comparing all these techniques would be a cool doc
05:43:40 <merijn> sm[m]: I don't see how it's more complicated than any other language? I'd say it's far simpler than most, even. It's just that many of those others have tools that automate the process (usually badly and in wrong ways, but hey!) and therefore it's "just one command!"
05:45:23 * hackage tintin 1.10.1 - A softer alternative to Haddock  https://hackage.haskell.org/package/tintin-1.10.1 (NickSeagull)
05:46:17 <sm[m]> amy_monnet I seem to remember fpcomplete providing a lean docker image for haskell deployments
05:46:33 <maerwald> it's called busybox lol
05:46:47 <ezzieyguywuf> the implementation of Control.Applicative starts off `class (Functor f) => Applicative f where`. The next line is `pure :: a -> f a`. The author of Learn You a Haskell describes the `pure` function that takes a value a returns a functor with the Applicative value "inside it". While the author does admit that the "box" analogy is imperfect, I do understand why it is used as it helps to explain other 
05:46:54 <ezzieyguywuf> more complex topics. However, I would like to understand the `f` as it is used in this class implementation a bit more. is `f` a concrete type?
05:47:10 <ezzieyguywuf> I don't think it can be, since each use in the Applicative type class definition uses it as `f a`
05:47:17 <merijn> ezzieyguywuf: Yes, no, maybe
05:47:36 <merijn> ezzieyguywuf: The term "concrete type" is rather ill-defined: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
05:47:57 <sm[m]> maerwald: for my future reference.. busybox is not a docket image, I assume
05:48:10 <maerwald> docker pull busybox
05:48:24 <sm[m]> oh, ok
05:50:49 <ezzieyguywuf> merijn: very well then. is the kind of `f` here `* -> *`?
05:50:54 <merijn> ezzieyguywuf: Yes
05:51:42 <ezzieyguywuf> ah, I did not realize that a type class definition could include a type of kind other than `*`
05:51:58 <ezzieyguywuf> but that is likely just my unfamiliarity with the haskell syntax and language in general
05:53:11 <merijn> ezzieyguywuf: The Applicative (and Functor, and Monad) classes are defined for types of kind "* -> *", so trying to define, say, "instance Functor Int" is a kind error (since 'Int :: *')
05:53:16 <ezzieyguywuf> follow-up question: in the line `class (Functor f) => Applicative f where`, is it possible to already know that the kind of `f` is `* -> *`, or is it necessary to see how `f` is used in the function definitions in order to infer this?
05:53:57 <merijn> ezzieyguywuf: With some extensions you can explicitly define a kind signature to specify this, but in general you need to see how it's used, yes
05:54:22 <merijn> ezzieyguywuf: In this case (Applicative) you can also infer it from "Functor f", since Functor also requires it's argument to be "* -> *"
06:03:34 <ezzieyguywuf> merijn: hrm, but without extensions (not sure what you mean by that) I could simply propogate my question down to the definition of Functor, i.e. `class Functor f where`, is there a way to know at this point that the kind of `f` is `* -> *`?
06:04:25 <merijn> ezzieyguywuf: What I mean is that there is a GHC specific (i.e. not standard Haskell2010) extension called -XKindSignatures which lets you write "class Functor (f :: * -> *) where..."
06:04:39 <merijn> ezzieyguywuf: Which lets you explicitly state that 'f' has kind '* -> *'
06:04:59 <olligobber> ezzieyguywuf, in the definition of Functor f, every use of f has some other type applied to it, so f must have kind * -> *
06:05:23 <merijn> ezzieyguywuf: Inside Functor fmap is defined as 'fmap :: (a -> b) -> f a -> f b', so 'f :: * -> *' can be inferred from that
06:05:49 <ezzieyguywuf> got it - so without non-standard extensions, the only way to know is to examine the use of `f` and infer its kind
06:05:50 <merijn> ezzieyguywuf: And we can know that 'a' has kind * because all types that have values have type *
06:05:58 <ezzieyguywuf> I imagine that this is precicely what the compiler does?
06:06:05 <merijn> ezzieyguywuf: (And we can only apply functions to values)
06:06:07 <merijn> ezzieyguywuf: Yes
06:06:11 * ezzieyguywuf nods
06:06:16 <ezzieyguywuf> alright then thank you, back to reading :)
06:09:15 <ezzieyguywuf> hah ok I already have another question. in the definition of `Maybe` as an instance of `Applicator` (at least as shown here: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors), it seems that the definition is incomplete for `<*>`. It handles the case where the first argument is `Nothing` as well as when the first argument is `Just f` (here `f` is kind `* -> 
06:09:21 <ezzieyguywuf> *`). But what happens if a `Just a` (where `a` is kind `*`) is the first argument? does this crash?
06:09:51 <merijn> ezzieyguywuf: Just is not a type
06:09:55 <ezzieyguywuf> and if so, would this be considered an ill definition of an Applicator instance?
06:11:02 <merijn> ezzieyguywuf: Things are slightly less confusing if we rewrite "data Maybe a = Nothing | Just a" to use the GADTSyntax extension
06:11:11 <merijn> ezzieyguywuf: Using that extension we would write:
06:11:13 <merijn> data Maybe a where
06:11:21 <merijn>     Nothing :: Maybe a
06:11:27 <merijn>     Just :: a -> Maybe a
06:11:28 <Taneb> ezzieyguywuf: It handles the case when the first argument is Nothing, no matter what the second argument is. It also handels the case when the first argument is "Just f", no matter what the second argument is. There's no more cases to handle here.
06:12:19 <merijn> ezzieyguywuf: Note that the argument to 'Just' is a *value* of type 'a' (where type 'a' must have kind *, since 1) all values have types with kind *, and 2) that's what the type of Maybe specifies)
06:12:24 <ezzieyguywuf> Taneb: but in the case where it is `Just f`, the rhs is `fmap f something`. So if `f` is not a function then it blows up, right?
06:12:46 <Taneb> ezzieyguywuf: yes, that would be a type error.
06:13:07 <Taneb> The type of (<*>) for Maybe is "Maybe (a -> b) -> Maybe a -> Maybe b"
06:13:08 <ezzieyguywuf> so you mean the compiler would catch this
06:13:11 <Taneb> Yes
06:13:14 <ezzieyguywuf> ah hah
06:13:17 <merijn> > fmap True Nothing
06:13:20 <lambdabot>  error:
06:13:20 <lambdabot>      • Couldn't match expected type ‘a0 -> b’ with actual type ‘Bool’
06:13:20 <lambdabot>      • In the first argument of ‘fmap’, namely ‘True’
06:13:38 <ezzieyguywuf> forcing me as a programming to go in and figure out where my logic failed
06:13:44 <ezzieyguywuf> ok, this is helpful thanks
06:13:52 <ezzieyguywuf> s/programming/programmer/
07:04:50 <herad> I don't know how this forum works but I would need some help with installation please
07:05:54 <solonarv> sure, we can help you with that
07:06:05 <solonarv> first, what exactly are you trying to install?
07:06:43 <herad> Perfect, thanks! I'm trying to get started with haskell, and I followed the instructions on haskell.org
07:06:52 <herad> so I guess the ghc 
07:07:04 <herad> and all tools (the stack?) and stuff
07:07:26 <solonarv> okay, second: which platform/OS are you on?
07:07:32 <herad> OS X
07:07:35 <herad> mac
07:08:01 <solonarv> okay, then I would recommend installing GHC and cabal using ghcup
07:08:04 <solonarv> @where ghcup
07:08:04 <lambdabot> https://www.haskell.org/ghcup/
07:08:43 <herad> I did! I ran this command in the command line as per the websites instructions:
07:08:43 <herad> curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org
07:08:59 <herad> and it downloaded and installed and everything
07:09:22 <herad> When I tried ghci in the command line it gave me this response:
07:09:28 <herad> -bash: ghci: command not found
07:09:39 <solonarv> what happens if you run 'ghcup' ?
07:09:51 <herad> -bash: ghcup: command not found
07:11:05 <solonarv> alright, so it looks like it isn't installed properly
07:11:10 <herad> hmm . okay
07:11:16 <solonarv> let's see... where did you put that ghcup script you downloaded?
07:11:24 <herad> uh
07:11:29 <herad> good question
07:11:33 <solonarv> heh
07:11:40 <solonarv> other question: what's in ~/.ghcup ?
07:11:40 <herad> i was in the root directory 
07:11:47 <herad> let me check
07:12:18 <herad> bin   cache   env  ghc  share
07:12:51 <solonarv> okay, that's encouraging
07:12:59 <herad> haha good
07:13:09 <solonarv> that ~/.ghcup/bin directory should be in your PATH
07:13:17 <herad> alright
07:13:19 <herad> whats PATH
07:13:40 <evanjs> alright, noob question time -- still just fumbling around and don't understand much yet, but is there an easy way to get this into one line? `t <- getCurrentTime <&> formatTime defaultTimeLocale "%c"; putStrLn $ "Date: " ++ t`
07:13:52 <Uniaika> herad: it's an environment variable in your shell that lists all the directories where you may find executables
07:14:06 <solonarv> you can check its contents by running: echo $PATH
07:14:11 <Uniaika> herad: you may inspect it by typing "echo $PATH" if you are on linux/macOS
07:14:20 <herad> okk 1 sec then
07:14:27 <solonarv> I don't know if there is some special way you are supposed to edit it on OS X
07:14:43 <Uniaika> solonarv: .bashrc like everyone else
07:14:54 <Uniaika> (from the UNIX world)
07:14:56 <herad> can I edit it with vim or something?
07:15:01 <Uniaika> herad: sure you can!
07:15:01 <solonarv> evanjs: that *can* be put on one line, but it won't be very readable. keep it like it is.
07:15:27 <herad> So this is my current PATH:
07:15:31 <herad> nvm
07:15:38 <herad> too long to paste
07:15:44 <Uniaika> yeah it's pretty damn long
07:15:48 <solonarv> we don't need to see it all, just need to know whether ~/.ghcup/bin is in there
07:15:51 <merijn> Technically you should modify your .profile/.bash_profile for your path, not .bashrc
07:15:52 <evanjs> solonarv: don't worry I know haha.  I was going to leave it alone, was just curious how I'd do so
07:16:16 <solonarv> evanjs: okay good, if you're just indulging in idle curiosity that's fine
07:16:17 <Cale> evanjs: also, while you're at it, maybe consider using <$> instead of <&> there which is just kinda easier to figure out because the "getCurrentTime" ends up roughly where the time argument to formatTime would be
07:16:21 <merijn> Since bashrc gets resourced for every interactive shell, so any PATH="...:$PATH" stuff will repeatedly lengthen your path if you nest shells
07:16:41 <herad> the ghcup is not in there
07:17:20 <herad> I'm not sure exactly how to disinguish between the different things in the path, it just printed it as one long line
07:17:34 <evanjs> Cale: yup I initially was using that, I just found <&> and it fit my current lazy use case of demoing time format strings.  Waaay easier to test them out if the format string is at the end
07:17:40 <solonarv> alright, go ahead and add a line as follows: source ~/.ghcup/env
07:17:54 <Cale> evanjs: You could write something like  putStrLn . ("Date: " ++) =<< (formatTime defaultTimeLocale "%c" <$> getCurrentTime)
07:17:55 <herad> just append at the end? solonarv
07:17:56 <solonarv> the directories in PATH are separated by colons ( : )
07:18:02 <herad> ah
07:18:11 <herad> so I add colon and then what you wrote?
07:18:14 <solonarv> at the end of ~/.profile, I think
07:18:26 <solonarv> nono, 'source FILENAME' says "run this other file"
07:18:43 <Cale> (those parens may not be necessary, but I try not to rely on the precedence between =<< and <$> because I don't want to have to remember that stuff
07:18:46 <Cale> )
07:18:46 <maerwald> source ~/.ghcup/env
07:19:10 <solonarv> ~/.ghcup/env is a file which sets up all the necessary environment for ghcup (currently it just modifies your PATH appropriately)
07:19:50 <herad> I'm not sure how to edit the path actually, what is the file called? If I wanted to edit in vim
07:20:02 <herad> just vim PATH?
07:20:13 <solonarv> no, PATH isn't a file
07:20:20 <herad> uh okay
07:20:20 <solonarv> you want to edit ~/.profile, I think
07:20:23 <evanjs> Cale: wow that's great.  So basically >>= is to =<< as <&> is to <$>. 
07:20:26 <solonarv> (someone else might correct me)
07:20:26 <herad> ah
07:20:52 <herad> ~/.profile was an empty file
07:20:56 <herad> this correct?
07:21:21 <yushyin> merijn: at least zsh (i don't know for bash) has a need trick, with typeset -U path the entries in path are gonna be unique
07:21:41 <solonarv> yeah, it might not have existed yet
07:22:02 <herad> really? How come there were things in my path then? I am so cofused lol
07:22:32 <evanjs> path is modified by many different things
07:22:55 <maerwald> herad: did you read the instructions after ghcup was installed?
07:22:56 <herad> either way I added source ~/.ghcup/env   to ~/.profile, but it still didn't show up in my path
07:23:10 <herad> Maybe not maerwald
07:23:13 <maerwald> what were the instructions? Did you answer the last question with YES or NO?
07:23:17 <merijn> herad: You need to restart your shell
07:23:18 <herad> YES
07:23:26 <solonarv> you also need to restart the shell, that file is only read once
07:23:36 <herad> what's shell? the command line?
07:23:50 <maerwald> ghcup even tells you what shell you have
07:23:51 <herad> i did restart the cmnd line after installation
07:24:16 <yushyin> if they edited .profile a shell restart will not be sufficient
07:24:23 <herad> I feel like I'm not very suited for this degree ;-;
07:24:32 <solonarv> hey, nobody's born knowing this
07:24:36 <herad> haha true
07:25:20 <maerwald> echo $SHELL
07:25:40 <herad>  /bin/bash
07:26:05 <Cale> evanjs: Yeah, and often if you're going to use it explicitly =<< is a little easier to deal with, since it keeps the data flowing in the same direction as function application -- also kind of nice along with the <- that occurs in do-notation. But usually if I'm going to use a bind operator, I'd rather just use do. Sometimes >>= can be nice along with \case though.
07:26:17 <maerwald> then either ~/.bashrc or ~/.bash_profile was modified
07:26:25 <solonarv> oh yes, >>= \case is great
07:26:30 <herad> okay, what do I do now?
07:26:51 <maerwald> check both files
07:27:11 <herad> what am i lookig for?
07:27:36 <herad> ~/.bashrc has something about ghcup
07:27:45 <yushyin> the bootstrap script is not very bulletproof anyway, like making the assumption that shell rc files are to by found in ~/
07:27:49 <herad> last line is:
07:27:50 <herad> [ -f "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env" ] && source "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env"
07:27:50 <ezzieyguywuf> herad: you can do it!
07:28:01 <herad> haha thanks
07:28:17 <maerwald> yushyin: yes, that is why it's interactive and users expected to read the output
07:28:43 <solonarv> oh good, looks like editing ~/.profile was totally unnecessary ^^
07:28:44 <maerwald> herad: is .bashrc sourced in .bash_profile?
07:28:52 <ezzieyguywuf> fyi, PATH is just a variable that the operating system manages. the user can modify/add to it in many different ways, some automatically upon login, e.g. by modifying ~/.bashrc (or more correctly ~/.profile/whatever-merijn-said-earlier)
07:29:18 <herad> doesn't look like it is maerwald
07:29:32 <herad> the first line is: source ~/.profile
07:29:41 <herad> but that's the only source: something
07:29:59 <herad> then there's an export PATH= ......
07:30:04 <herad> followed by a bunch  of stuff
07:30:04 <ezzieyguywuf> herad: as a one-off, you can try `PATH=~/.ghcup/bin:$PATH ghci` to see if everything works. This temporarily prepends the path that contains teh ghci executable to the sytsem's PATH
07:30:06 <maerwald> [[ -f ~/.bashrc ]] && source ~/.bashrc
07:30:13 <maerwald> add that to ~/.bash_profile
07:30:18 <yushyin> why would you do that ^
07:30:34 <ezzieyguywuf> herad: if that works, you can do this bash_profile or w/e stuff in order to have it added to your path automatically whenever you login or start a shell
07:30:36 <maerwald> because that is what bash upstream recommends
07:30:44 <merijn> yushyin: Because .bashrc doesn't get loaded by interactive login shells
07:30:52 <yushyin> it does
07:30:54 * hackage hhwloc 0.1.0 - Bindings to https://www.open-mpi.org/projects/hwloc  https://hackage.haskell.org/package/hhwloc-0.1.0 (dtaskoff)
07:31:33 <herad> okay I added [[ -f ~/.bashrc ]] && source ~/.bashrc to .bash_profile
07:31:40 <maerwald> yushyin: I don't think so
07:31:43 <yushyin> 'When  an  interactive  shell  that  is  not  a login shell is started, bash reads and executes commands from ~/.bashrc, if that file exists.' -- man bash /INVOCATION
07:31:51 <herad> should I post my entire .bash_profile? it's not that long
07:32:02 <maerwald> herad: just start a new shell now
07:32:03 <merijn> yushyin: Right, and .profile only gets sourced for login shells
07:32:08 <evanjs> not language related (are hoogle questions off-topic here?) if not... what prevents a library from showing up on hoogle if it's on hackage? In this case, taffybar
07:32:15 <merijn> yushyin: Therefore, interactive login shells don't source .bashrc
07:32:28 <herad> just to be clear, when you say start a new shell you mean restart the command line, right?
07:32:30 <merijn> yushyin: So if you want a login shell to source .bashrc you need to do so in .profile
07:32:35 <yushyin> but interactive shells do
07:32:49 <merijn> yushyin: only interactive nonlogin shells
07:32:59 <merijn> yushyin: It says so right in the text you quoted
07:33:18 <herad> maerwald: I restarted the command line but ghci still doesn't work
07:33:22 <merijn> yushyin: And guess what most (all?) terminal emulators start login shells
07:33:33 <yushyin> they do not
07:33:39 <maerwald> herad: echo $PATH
07:33:58 <herad> still nothing about ghcup
07:34:57 <merijn> yushyin: All the ones I've used so far and Terminal.app (the one on macOS, which herad is using) *definitely* does start a login shell
07:35:22 <herad> am I supposed to add anything to ~/.bashrc?
07:38:04 <herad> wow why are things so complicated all the time
07:38:15 <herad> everyone out of ideas?
07:39:44 <merijn> herad: Can you put the output of "echo $PATH" and the contents of .bashrc and .profile on a paste site like https://paste.debian.net/ ?
07:40:13 <herad> sure but I could just post it straight here, they're all very short
07:40:35 <solonarv> didn't you say PATH was too long for pasting just a few minutes ago?
07:40:51 <herad> i did but i realised my  keyboard  is strugglingthat's why
07:40:54 <solonarv> also, we prefer if anything code-like longer than one or two lines isn't dumped straight into IRC
07:41:00 <herad> okk
07:41:29 <herad> how do i use debian?
07:41:37 <herad> do i write herad as the name ?
07:42:00 <solonarv> oh, the name doesn't matter
07:42:48 <herad> okay I "pasted" my ~/.bashrc
07:43:29 <herad> pasted path aswell
07:44:26 <herad> okay ~/.profile is pasted too
07:44:47 <yushyin> merijn: ok must be different for different operating systems or terminal, I just checked my freshly started terminal emulator and it does not start a login shell. But yes, tmux does it, but tmux is known for this default behavior.
07:45:29 <solonarv> okay, now you need to post the resulting links here
07:45:36 <solonarv> we can't magically find them!
07:45:46 <maerwald> solonarv: you can :D
07:45:57 <solonarv> maerwald: shhh I'm trying to build good habits here
07:46:03 <herad> haha okay will dop
07:46:14 <herad> https://paste.debian.net/1127293
07:46:20 <herad> https://paste.debian.net/1127294
07:46:24 <Finianb1> If they're public I think you can browse the most recent pastes on gist, but that's not fun to look through.
07:46:26 <herad> https://paste.debian.net/1127295
07:46:30 <maerwald> herad: file "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env"
07:46:42 <herad> maerwald: ?
07:46:50 <maerwald> run that
07:47:04 <herad> result:
07:47:07 <herad>  /Users/harald/.ghcup/env: ASCII text
07:47:27 <maerwald> type: bash
07:47:36 <herad> just bash?
07:47:40 <maerwald> yes
07:47:43 <herad> or "type:  bash"
07:48:02 <herad> it seems to be running
07:48:09 <maerwald> then: ghci
07:48:16 <herad> ghci
07:48:20 <herad> ah sry
07:48:22 <maerwald> good
07:48:23 <herad> wrong place
07:48:30 <herad> ay itt worked
07:48:37 <herad> GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
07:48:47 <herad> and now I'm in the haskell interactive mode
07:48:53 <herad> it'sthe prelude> thing
07:48:58 <solonarv> a-ha!
07:49:03 <herad> Nice!
07:49:22 <herad> Now is there a way to be able  to just directly type ghci from a newly opened terminal window?
07:49:47 <solonarv> there should be, I am not sure why you had to start a nested 'bash'
07:49:52 <herad> hmm
07:50:13 <herad> well this way isn't too much of a hassle either way
07:50:27 <herad> thank you so much for all the help to everybody! This is a great forum :D
07:51:11 <ezzieyguywuf> herad: I'm not all too familiar with mac os, though I do believe it is unix-based. I know on linux, for example, if I change the groups that my user is in, I have to log out and log back in in order for that change to take effect. I usually don't have to do the same with changes to ~/.bashrc, but maybe mac os is different? In other words, try restarting :-P
07:51:31 <herad> yeah mac is the unix terminal
07:51:40 <herad> so, log out and in from my user?
07:51:49 <herad> like restart the computer, or?
07:51:51 <ezzieyguywuf> herad: yea. or just go nucleur and restart teh whole comp
07:51:58 <herad> haha opkay
07:51:59 <ezzieyguywuf> I doubt it'll fix your issue, but *shrug*
07:52:10 <herad> yeah lol
07:52:24 <herad> thanks all!
07:53:57 * ezzieyguywuf waves farewell and wipes a tear off his cheek. "Fare thee well, herad. Fare the well..."
07:54:31 <solonarv> restarting, presumably :>
07:54:36 <ezzieyguywuf> lol I know
07:54:53 <ezzieyguywuf> always a shame to reset the uptime though. hence the tear...
07:55:53 <geekosaur> bleh. I'd had to reboot my mac at least once a week since leopard came out. and it only ever got worse. eventually I gave up
07:55:53 * hackage brok 0.1.7.0 - Finds broken links in text files  https://hackage.haskell.org/package/brok-0.1.7.0 (smallhadroncollider)
07:56:07 <herad> okay I still can't type ghci straight from the terminal, but I'll just do the nested bash thing
07:56:14 <herad> thanks so much!
07:57:23 <solonarv> aw man, they just left again
07:58:52 <maerwald> it's possible that $SHELL is not set to the login shell
07:59:32 <merijn> geekosaur: heh?
07:59:33 <maerwald> POSIX says "This variable shall represent a pathname of the user's preferred command language interpreter.", which in theory, doesn't have to be the login shell
08:00:08 <merijn> geekosaur: I think I basically only reboot when new kernel security patches come out or I update to a new version...
08:01:54 <Finianb1> Wait, couldn't you then remap $SHELL to something like rlwwrap perl 
08:06:46 <geekosaur> you can set the shell Terminal runs in its properties menu. don't recall if it can set $SHELL
08:08:10 <geekosaur> usually $SHELL comes from user properties on Macs (editing that db is annoying though and I've forgotten details)
08:09:38 <geekosaur> also if its running latest OS X then the default shell is likely to be zsh. but why this should require bash is a question, granting I missed the start of the whole thing
08:10:14 <ddellacosta> I'm trying to understand ekmett's point here criticizing this usage of OverloadedLabels but having trouble. What does " discharging on the result type Html" mean? In particular I guess I don't know the technical meaning of "discharge:" https://www.reddit.com/r/haskell/comments/4x8tk8/overloadedlabels_considered_awesome/d6du4xr/
08:11:19 <hyperisco> ddellacosta, I haven't read but probably means removing a constraint by finding a matching instance
08:11:31 <hyperisco> :t 3
08:11:33 <lambdabot> Num p => p
08:11:37 <hyperisco> :t 3 :: Int
08:11:38 <lambdabot> Int
08:11:42 <hyperisco> That sort of thing
08:11:43 <ddellacosta> hyperisco: I see, thanks, that clears that up
08:11:54 <solonarv> % :t +v 3
08:11:54 <yahb> solonarv: Num p => p
08:12:01 <solonarv> % :t +v 3 :: Int
08:12:01 <yahb> solonarv: Int
08:12:13 <solonarv> aw, I thought that'd leave the Num Int constraint in
08:12:17 <solonarv> I must have misremembered
08:13:30 <ddellacosta> I'm also confused as to where he's getting that [x] -> Html from, it's not clear what he's referring to there
08:13:59 <hyperisco> I am not sure what the "linear" part means in "linear implicit parameters"
08:14:00 <John_Ivan> hi. is there a package for supporting Windows 10 Toast Notifications in the UWP/UI system?
08:14:39 <ddellacosta> hyperisco: yeah I can't help you there either, was also wondering that myself but I figured I'd focus on one thing at a time lol
08:14:47 <geekosaur> linear implicit parameters are a former ghc extension. one-use, iirc
08:14:59 <ddellacosta> ah
08:15:06 <hyperisco> Well then I wonder what the significance of the linearity was
08:15:08 <geekosaur> they used % prefix, like standard implicit params use ? prefix
08:15:31 <ddellacosta> oh, like, linear types-ish linear?
08:15:47 <geekosaur> > let %foo = 1 in %foo -- I think this still elicits a diagnostic
08:15:49 <lambdabot>  <hint>:1:5: error: parse error on input ‘%’
08:15:55 <geekosaur> nope, they finally removed it
08:16:02 <geekosaur> yeh
08:16:10 <ddellacosta> gotcha
08:16:22 <geekosaur> was supposed to add linear types without the typechecker overhead iirc
08:16:50 <hyperisco> The overhead is significant? I wouldn't have guessed that.
08:17:48 <hyperisco> So say I like Haskell but I also want to like linear types. Where do I go? And Idris 2 isn't ready yet.
08:18:20 <geekosaur> well, it's more work in the typechecker. linear implicit parmeters only invoked the extra work when used, I think. but didn't work well
08:19:16 <geekosaur> isn't -o on the way or maybe already in 8.8? (linear arrow instead of linear type)
08:19:37 <boxscape> https://github.com/ghc-proposals/ghc-proposals/pull/111
08:19:39 <boxscape> still open
08:20:34 <daydaynatation> what's the difference between: Control.Monad.Trans.RWS
08:20:58 <daydaynatation> and Control.Monad.RWS
08:21:25 <daydaynatation> They both define newtype RWST r w s m a
08:21:28 <geekosaur> sadly if I try to compose the operator here I get ō instead of ⊸
08:22:00 <daydaynatation> so transformer and mtl both define this RWST type
08:22:13 <geekosaur> one is from the transformers package, the other is mtl re-exporting it with an implementation based on fundeps?
08:22:30 <geekosaur> iirc
08:22:41 <solonarv> transformers defines *just* the transformers
08:22:51 <solonarv> i.e. 'newtype RWST r w s m a = ...'
08:22:56 <boxscape> the suggested syntax currently is ->. instead of -o I think
08:22:58 <solonarv> and a handful of accompanying functions
08:23:21 <solonarv> mtl defines typeclasses that generalize the transformers, and re-exports the transformers
08:23:52 <solonarv> and mtl's typeclasses are fundep-based
08:24:03 <geekosaur> yeh, I know they were having parser issues with -o
08:28:38 <aplainzetakind> Should I not expect SetPaletteColor of ansi-terminal to have an effect with $TERM=rxvt-unicode-256color ?
08:36:10 <Phyx-> win 1
08:36:37 <daydaynatation> How to intuitively understand the tell function in MonadWriter?
08:37:01 <hyperisco> :t tell
08:37:03 <lambdabot> MonadWriter w m => w -> m ()
08:37:56 <hyperisco> iirc  MonadWriter w m  implies  w  has a Semigroup instance (or maybe Monoid), and so this would just append onto the end
08:39:01 <daydaynatation> so for example: tell [0] will append to some existing [Int]
08:39:02 <hyperisco> So for example  tell "Hello " *> tell "Sailor!"  will append  "Hello Sailor!"  to the state
08:39:04 <daydaynatation> ?
08:39:15 <hyperisco> yes
08:40:43 <hyperisco> homomorphism  tell x *> tell y = tell (x <> y)
08:44:54 * hackage pprecord 0.2.0.0 - A library for pretty printing Records  https://hackage.haskell.org/package/pprecord-0.2.0.0 (tdct)
08:53:46 <ezzieyguywuf> dang, it's going to bother me that herad is doing this nested bash nonsense for all of eternity
08:56:07 <yushyin> only as long as they continue doing haskell
08:56:22 <ezzieyguywuf> hah, seems pretty addictive
08:56:45 <Nolrai> Herad?
08:57:38 <ezzieyguywuf> Nolrai: this user that was in here troubleshooting recently
09:01:00 <smatting> Hi, how would you write a function Monad m => (b -> a -> m b) -> b -> m a -> m b ? Are there some well-known functions from which this could be build?
09:02:30 <solonarv> is it particularly significant that it's b -> a -> m b instead of a -> b -> m c ?
09:02:50 <tabaqui1> https://www.stackage.org/haddock/lts-12.8/monad-extras-0.6.0/Control-Monad-Extra.html#v:nom
09:02:53 <smatting> solonarv: no, more general like this would be fine
09:02:59 <tabaqui1> nom :: Monad m => (a -> b -> m c) -> a -> m b -> m c 
09:03:07 <tabaqui1> this one is more general
09:03:52 <solonarv> f abmc a mb = abmc a =<< mb -- very simple
09:04:29 <tabaqui1> nom f x m = m >>= f x
09:04:37 <tabaqui1> same thing:)
09:04:54 <tabaqui1> solonarv: why did you use reverse bind instead of direct?
09:06:05 <smatting> ah, maybe it's not what i need? I'd like to the action (m b) to be called indefinitely to yield a stream of b
09:06:30 <smatting> .. which get folded by the function in the first argument
09:07:17 <solonarv> if you want the result to be a *stream* of b, then 'm b' isn't the right return type
09:07:42 <smatting> no the result should be an action m () i think
09:07:56 <tabaqui1> % take 10 $ (\f x m -> f >>= f x) (*) 2 [1..]
09:07:56 <yahb> tabaqui1: ; <interactive>:55:28: error:; * Couldn't match expected type `Integer -> a0 -> [a]' with actual type `[a0]'; * The function `f' is applied to one argument,; but its type `[a0]' has none; In the second argument of `(>>=)', namely `f x'; In the expression: f >>= f x; * Relevant bindings include; f :: [a0] (bound at <interactive>:55:13); it :: [a] (bound at <inte
09:08:15 <solonarv> it should properly be 'm Void', because what you're describing never returns
09:08:19 <tabaqui1> % take 10 $ (\f x m -> f >>= f x) (\a b -> replicate a b) 2 [1..]
09:08:19 <yahb> tabaqui1: ; <interactive>:56:28: error:; * Couldn't match expected type `Integer -> a1 -> [a]' with actual type `[a1]'; * The function `f' is applied to one argument,; but its type `[a1]' has none; In the second argument of `(>>=)', namely `f x'; In the expression: f >>= f x; * Relevant bindings include; f :: [a1] (bound at <interactive>:56:13); it :: [a] (bound at <inte
09:08:22 <smatting> solonarv: make sense
09:08:25 <tabaqui1> ah, nevermind
09:08:26 <smatting> solonarv: makes
09:08:36 <ezzieyguywuf> aside from being strict vs lazy, how is ocaml distinct from haskell?
09:08:50 <solonarv> purity is also a big difference
09:08:56 <solonarv> (haskell is pure, ocalm isn't)
09:09:10 <smatting> basically what i'm looking for is a monadic fold, but not over a foldable, but over a monadic value which yields the elements to be folded over
09:09:18 <Taneb> Haskell has typeclasses, OCaml has modules, functors, objects
09:09:40 <solonarv> you said "producing a stream of b", do you actually want to get this stream of b out at the end to do something else with it?
09:09:44 <ezzieyguywuf> hrm, I see. my current goal is to become familiar/comfortable with the functional programming paradigm, so it seems that sticking with haskell would make more sense
09:09:51 <smatting> solonarv: no, just fire some actions
09:10:06 <solonarv> okay, that's perfectly doable
09:10:48 <smatting> i could write a custom recursive function of course, but i thought there's maybe a nice function that already does the job
09:11:11 <Taneb> A more subtle difference between Haskell and OCaml is that Haskell allows for a more general form of recursive type
09:11:29 <solonarv> @let loopy step x source = do y <- source; x' <- step x y; loopy step x' source
09:11:30 <Taneb> like "data Foo a = Bar a | Baz (Foo (a, a))"
09:11:31 <lambdabot>  Defined.
09:11:34 <solonarv> :t loopy
09:11:36 <lambdabot> Monad m => (t1 -> t2 -> m t1) -> t1 -> m t2 -> m b
09:12:37 <solonarv> monad-loops might have something
09:13:54 <solonarv> oh, actually
09:14:03 <Taneb> :t unfoldrM
09:14:05 <lambdabot> error:
09:14:05 <lambdabot>     • Variable not in scope: unfoldrM
09:14:05 <lambdabot>     • Perhaps you meant one of these:
09:15:24 <solonarv> :t \f x0 src -> evalStateT (forever $ do x <- get; y <- lift src; put =<< lift (f x y)) x0
09:15:27 <lambdabot> Monad m => (s -> t -> m s) -> s -> m t -> m a
09:17:00 <solonarv> I'm not sure if that's much better, tbh
09:17:27 <solonarv> it does have the advantage that you can see at a glance "there is something stateful" and "there is an infinite loop"
09:24:53 * hackage log4hs 0.7.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.7.0.0 (gqk007)
09:33:58 <ezzieyguywuf> I'm reading about the `State` monad in "Learn You a Haskell". in `instance Monad (State s) where`, the `(>>=)` operator is defined as `(State h) >>= f =...`. I'm confused about `(State h)`. The `Monad` typeclass defines `>>=` as `(>>=) :: m a -> (a -> m b) -> m b`. so if i substitute in `(State s)` for `m`, I get `(>>=) :: State s a -> (a -> State s b) -> State s b`. How then, does the `>>=` 
09:34:04 <ezzieyguywuf> implementation for `State` only have `(State s)` on the left hand side rather than `(State s a)`?
09:34:45 <dmj`> ezzieyguywuf: the kind of Monad is (* -> *) -> Constraint
09:35:02 <dmj`> ezzieyguywuf: the kind of State is (* -> * -> *)
09:35:34 <dmj`> ezzieyguywuf: the kind of State s is (* -> *), which when applied to Monad will produce a Constraint
09:35:46 <ezzieyguywuf> dmj`: what do you mean by `-> Constraint`
09:36:09 <dmj`> ezzieyguywuf:  all typeclass kinds return Constraint
09:36:14 <dmj`> :kind Monad
09:36:21 <solonarv> you are mixing up the type constructor and the data constructor
09:36:21 <dmj`> > :kind Monad
09:36:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:36:34 <dmj`> ezzieyguywuf: what solonarv said
09:36:49 <solonarv> in: newtype State s a = State (s -> (s, a)), the first State defines a type constructor and the second one defines a data constructor
09:36:53 <dmj`> State s means you cannot change the type of 's' from within the instance
09:37:22 <solonarv> they happen to be named the same, but that is merely convention and does not mean anything special
09:37:27 <ezzieyguywuf> ahhh
09:37:38 <ezzieyguywuf> ok, that helps a ton
09:37:41 <solonarv> the definition could also have been: newtype State s a = MkState (s -> (s, a))
09:38:07 <solonarv> then the instance decl would be: instance Monad (State s) where (MkState h) >>= f = ...
09:38:09 <ezzieyguywuf> in which case `(State h) >>= f` would be `(MkState h) >>= f`
09:38:18 <ezzieyguywuf> right!
09:39:16 <ezzieyguywuf> and of course, this makes sense, because functions (such as `>>=`) take _values_ not _types_
09:40:24 * hackage Fin 0.2.8.0 - Finite totally-ordered sets  https://hackage.haskell.org/package/Fin-0.2.8.0 (MatthewFarkasDyck)
09:47:58 <maerwald> yushyin: any suggestion on how to improve the bootstrap-haskell shell detection?
09:48:41 <AWizzArd> I have a  let f = flip runReaderT env in liftIO $ pure $ OnliftIO (onliftIO x . f)    and it does not compile. However, when I replace the f with the flip it does work? Whyy?
09:48:44 <AWizzArd> https://pastecode.xyz/view/de82e214
09:51:13 <yushyin> maerwald: maybe, but I have to think about it thoroughly first. I will approach you when I have something meaningful to contribute.
09:51:40 <maerwald> sure
09:56:07 <patrl>   /script install buffers.pl buffer_autoclose.py iset.pl go.py colorize_nicks.py
09:56:18 <patrl> ach wrong buffer, sorry
10:07:18 <ezzieyguywuf> when I try to `import Control.Monad.Writer` I get an error about a hidden package mtl. am I not supposed to use `Control.Monad.Writer` directly?
10:07:57 <AWizzArd> ezzieyguywuf: have you added mtl to your dependencies already?
10:08:19 <ezzieyguywuf> AWizzArd: I'm only working in ghci right now
10:09:13 <AWizzArd> ezzieyguywuf: do you use Stack? Cabal?
10:09:39 <ezzieyguywuf> AWizzArd: I don't "use" anything quite yet, as I'm still learning the language and tools. I've installed ghc with ghcup, which I think comes with cabal
10:10:06 <AWizzArd> This module that you try to use... Control.Monad.Writer – it does not directly ship with GHCi.
10:10:19 <ezzieyguywuf> ah. is it non-standard?
10:10:20 <AWizzArd> Instead you need to download the corresponding lib first and use that.
10:10:34 <AWizzArd> Well, it is very standard, but simply not directly included.
10:11:51 <geekosaur> that shouldn't report it as hidden though
10:12:16 <ezzieyguywuf> it gives me a solution
10:12:25 <ezzieyguywuf> `:set -package mtl`
10:12:27 <AWizzArd> geekosaur: I think I saw this message when I use some dependency A which itself needs B and then suddenly I try to use something from B without having listed it explicitly as a dep.
10:12:31 <ezzieyguywuf> I'm just unsure what this does or why I need to do it
10:12:42 <ezzieyguywuf> (it does solve the problem)
10:12:43 <AWizzArd> ezzieyguywuf: just try this out. This sounds good.
10:13:29 <geekosaur> because the module isn't part of base, it's part of mtl. but ghci by itself should search packages unless they're hidden, and by default only ghc pckage (the ghc-api, compiler as a library) should be hidden
10:13:29 <AWizzArd> ezzieyguywuf: I think that ghci tries to tell you that "yes, I have access to this module, but you did not explicitly tell me that you know this is your dependency"
10:13:43 <sm[m]> might there be a decent alternative to http://hackage.haskell.org/package/here that doesn't depend on the very heavy haskell-src-meta/haskell-src-exts ?
10:14:13 <sm[m]> I've forgotten their names
10:14:17 <AWizzArd> It is a transitive dependency, and by explicitly adding this package you communicate that you really want to use it, and that you will add it later to your explicit deps.
10:14:42 <AWizzArd> geekosaur: any idea why https://pastecode.xyz/view/de82e214 will not work with that first version?
10:14:53 <sm[m]> "interpol" seems to find a bunch
10:15:26 <yushyin> neat-interpolation maybe?
10:15:38 <geekosaur> http://hackage.haskell.org/package/heredocs ? depends on what you want from it
10:16:38 <sm[m]> thanks, I'll check both of those
10:17:27 <sm[m]> shakespeare seems to do this too
10:18:12 <sm[m]> holy mackerel why are there so many of these
10:18:15 <geekosaur> AWizzArd, I'd check the type of f (you should include the error message)
10:18:16 <ezzieyguywuf> is there a haskell module (library?) that provides similar functionality to the c++ GCAL library?
10:22:33 <dmwit> Could you describe what GCAL does for those of us that don't live and breathe C++?
10:38:06 <sm[m]> FWIW: I found ~10+ packages all aimed at basic multiline string literals and/or interpolation. The ones with light dependencies (no haskell-src-meta) were string-qq, neat-interpolation, rawstring-qm, and heredocs. The first three of those are popular enough to be in current stackage nightly. string-qq is the simplest. Replacing here with string-qq shaved of several minutes of build time.
10:38:23 * hackage tree-sitter-go 0.4.1.1 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.4.1.1 (robrix)
10:42:54 * hackage pandoc-plot 0.2.1.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.2.1.0 (LaurentRDC)
10:46:54 * hackage tree-sitter 0.8.0.2 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.8.0.2 (robrix)
11:08:17 <ezzieyguywuf> GCAL is the Geometric Computational Algorithm Library. It provides things such a a Point2D, Point3D class, as well as geometric objects such as Circle, Polygon, and algorithms that operate on them, such as Area, Interects, etc..
11:08:59 <ezzieyguywuf> it has a reputation for being rigourously "correct" in its implementation of its various algorithms
11:09:11 <solonarv> ah, I see
11:09:38 <solonarv> Haskell libraries tend to be less monolithic, we have a bunch of libraries that cover this sort of thing rather than a single one
11:09:54 <ezzieyguywuf> it also abstract enough that it allows the user (programmer) to specify which c++ primitives to use to describe, say, a Point2D, such that a Point2D could be (int, int), (float, float), (double, double), etc...
11:09:58 <hyperisco> I worry about other libraries if getting the geometry right is a feature
11:10:45 <ezzieyguywuf> solonarv: so you mean, I would specifically find a library that finds the intersection of two.....what? how would the one library know about data types described in the other unless the one had a dependency on the other?
11:10:49 <ezzieyguywuf> hyperisco: what do you mean?
11:11:08 <ddellacosta> ezzieyguywuf: you might start by checking out linear, but it sounds like it's going to depend on what parts of GCAL you are specifically interested in replicating in a Haskell environment
11:11:34 <hyperisco> ezzieyguywuf, I just don't understand how being rigorously correct is different than what other geometry libraries aim to do
11:11:57 <hyperisco> Are there some out there that say pi = 3 and roll with that?
11:11:58 <ezzieyguywuf> i'm interested in constructing arbitrary polynomial curves, as well as bezier and NURBs curves, and using these as the foundation of a CAD kernel that will build up 3D solids
11:12:36 <ezzieyguywuf> hyperisco: I see what you mean. perhaps my description of CGAL is falling short then. maybe I can find out how they describe themselves on their website...
11:13:05 <ezzieyguywuf> "provides easy access to efficient and reliable geometric algorithms in the form of a C++ library"
11:13:12 <ezzieyguywuf> I was trying to get across the "reliable" I suppose
11:14:22 <hyperisco> There is the "linear" package for, unsurprisingly, linear algebra
11:14:38 <ezzieyguywuf> perhaps that should be my starting point then
11:14:50 <ddellacosta> https://hackage.haskell.org/package/linear
11:14:53 <ezzieyguywuf> i'm simply trying to make sure I don't end up "reinventing the wheel"
11:15:17 <hyperisco> Circles and polygons and stuff I don't know. I haven't done such a thing in Haskell. There are many ways to talk about such things, so you're likely to find a variety of libraries
11:15:44 <hyperisco> For CAD I imagine you will want a constructive solid geometry library
11:16:01 <ddellacosta> I suspect diagrams is probably a bit different than what you want for your goals but may be worth taking a glance at it as well: https://hackage.haskell.org/package/diagrams
11:16:03 <ezzieyguywuf> hyperisco: rather, I'm trying to develop a BREP library
11:16:58 <ezzieyguywuf> ddellacosta: that is interesting. However I was considering writing the frontend using something like QT
11:17:17 <hyperisco> Hm. Well I have to imagine there is at least a half-baked library on Hackage for it.
11:17:22 <ddellacosta> ezzieyguywuf: yeah I think diagrams has a different target audience than you for what you're trying to build
11:17:24 <ezzieyguywuf> but then again, I have not even begun to delve into the world of gui with haskell
11:17:27 <ezzieyguywuf> I'm still pretty new
11:22:08 <hyperisco> First of me hearing of brep, but how does it differ from… meshes?
11:23:00 <hyperisco> Which, from my outsider knowledge, are more like a necessary evil than a desirable format
11:24:57 <sm[m]> nice.. 16G runaway ghc killing my machine
11:25:13 <sm[m]> usually it's just a ~4G ghcide
11:25:15 <ezzieyguywuf> brep is short for "Boundary Representation". It is distinct from Constructive Solid Geometry in that it models solids based on their surfaces, or boundaries. Any point is either inside or outside the solid
11:25:24 * hackage vectortiles 1.5.0 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.5.0 (fosskers)
11:25:50 <ezzieyguywuf> mesh, on the other hand (per my understanding) is a simplified solid built up using triangles
11:25:50 <hyperisco> "Boundary representation is essentially a local representation connecting faces, edges and vertices." from Wikipedia. Sounds like a mesh!
11:26:03 <ezzieyguywuf> it's like the difference between vector graphics (brep) and pixel graphics (mesh)
11:26:43 <ezzieyguywuf> you can increase the "resolution" of a mesh by adding more triangles, but ultimately you are still left with a "non perfect" solid
11:27:02 <hyperisco> Okay, so you're saying a face can be more than just a triangle, in brep
11:27:35 <ezzieyguywuf> hyperisco: yes. brep aims to represent perfectly the solid. It can be used as the basis to generit a mesh - it often is - for example in order to render or 3d print
11:27:56 <ezzieyguywuf> but for the purposes of engineering and...other reasons (lol), you need to have a way to represent the solid in "full res"
11:28:32 <ezzieyguywuf> CSG accomplishes this by forcing the designer to build up each solid as some boolean combination of a handful of primitive solids
11:28:42 <ezzieyguywuf> that's not so say that CSG is "bad", it is merely different from brep.
11:28:47 <maerwald> sm[m]: parallel builds?
11:33:45 <sm[m]> maerwald: no.. I couldn't really investigate, but I think it was a background ghc started by global-flycheck-mode for a (ordinary) source file
11:34:26 * sm[m] disables all flycheck and ghcide shenanigans in haskell-mode
11:34:33 <sm[m]> back to ghcid...
11:35:45 <maerwald> sm[m]: yesterday a coc.nvim plugin for rust kept spawning processes until memory exhaustion. Even 'killall' didn't work...
11:35:55 <sm[m]> which has its own issues with losing track of child ghcs, but better the devil you know
11:36:02 <maerwald> I guess programmers these days are not aware that they get access to my machines resources...
11:37:00 <sm[m]> well.. just no real incentive to make things reliable
11:37:03 <hyperisco> I have been wondering if my eventual workstation upgrade will be to 32GB or 64GB RAM
11:37:12 <maerwald> hyperisco: 64
11:37:19 <hyperisco> Currently I have 8
11:38:07 <MarcelineVQ> I have just barely enough to build idris2 or agda with nothing else open
11:38:27 <maerwald> browsers these day need *minimum* 4gb, easily up to 10, then your IDE needs double the same amount, then another haskell build needs up to 16gig if it's parallel, then...
11:38:35 <hyperisco> Also was debating say a Xeon for high core count, but I don't think GHC and other compilers are really that parallel, are they?
11:38:54 <sm[m]> but honestly, weren't operating systems supposed to protect us from crappy software ? I mean what is the point, otherwise
11:39:23 <maerwald> sm[m]: even the kernel oom killer is crap, here is your only protection https://github.com/rfjakob/earlyoom ;)
11:39:49 <hyperisco> maerwald, I dunno but FireFox hasn't been that RAM-hungry. Then again I don't go to many JavaScript-laden web services.
11:40:03 <maerwald> I install that even on servers (because it just so happened that memory exhaustion lead to not being able to ssh into a machine for minutes)
11:40:31 <hyperisco> MarcelineVQ, or machine having how much RAM?
11:40:35 <hyperisco> your*
11:40:39 <sm[m]> maerwald, I would open that link, but the popup says: Close Firefox. A copy of Firefox is already open. Only one copy of Firefox can be open at a time.
11:40:42 <maerwald> swap off, earlyoom on, glasses on.
11:40:48 <maerwald> sm[m]: xxxD
11:41:06 <MarcelineVQ> hyperisco: 8 as well
11:41:57 <sm[m]> the machines sense my unrest and are shutting me down. Well I'll shut THEM down. brb
11:43:08 <evanjs> found the answer to my question from earlier.  Hackage itself does not determine what is searchable on hoogle, but a package's presence on stackage does
11:43:47 <evanjs> so I can't search for modules in taffybar, but when searching it, I get "Not on Stackage, so not searched. "
11:44:42 <evanjs> I did solve the problem by enabling services.hoogle on NixOS and adding it there, though :D Now I can simply search for it on any of my NixOS machines with their local hoogle instance
12:03:57 <nshepperd2> soon you'll be able to get 1TB ram sticks, and firefox will eat it all
12:06:37 <merijn> nshepperd2: And debugging will be hell ;)
12:07:56 <merijn> nshepperd2: During my internship I had a colleague who was working on one of these HUGE Sparc boxes with 5TB of RAM in them. If his program segfaulted it would take *ages* too write a core dump and opening them in gdb was an entirely separate challenge :p
12:08:40 <Finianb1> Does anyone know what happened to the online version of the Free Theorem generator?
12:09:08 <Finianb1> It used to be on the University of Bonn 
12:09:16 <Finianb1> http://www-ps.iai.uni-bonn.de/ft/
12:09:19 <Finianb1> Was here 
12:09:23 <Finianb1> Now the link is dead
12:10:25 <Finianb1> @free
12:10:25 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
12:10:35 <Finianb1> @free mapp
12:10:36 <lambdabot> Extra stuff at end of line in retrieved type "error:\n    \226\128\162 Variable not in scope: mapp\n    \226\128\162 Perhaps you meant one of these:\n"
12:10:42 <Finianb1> @free map 
12:10:43 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
12:10:54 <Finianb1> Oh nice 
12:13:54 * hackage servant-lucid 0.9.0.1 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.9.0.1 (phadej)
12:19:24 * hackage servant-swagger 1.1.8 - Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.8 (phadej)
12:38:39 <Nolrai> Is there a standard way I should check for and strip off the BOM at the begining of some unicode files?
12:40:07 <monochrom> I coded my own.
12:42:25 <hyperisco> if you want it done wrong, at least give yourself to blame
12:42:29 <Nolrai> > isSpace (read '\65279')
12:42:31 <lambdabot>  error:
12:42:31 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
12:42:31 <lambdabot>        Expected type: String
12:42:50 <Nolrai> > isSpace (read "\'\65279\'")
12:42:53 <lambdabot>  False
12:43:46 <Nolrai> Its called a non-breaking space..but I guess it doesn't count as a space.
12:44:02 <merijn> Nolrai: How does unicode classify it?
12:44:20 <Nolrai> That is a good question.
12:44:23 <hyperisco> > isSpace '\65279'
12:44:26 <lambdabot>  False
12:44:35 <merijn> Nolrai: If unicode classifies it as a space and isSpace returns false, that's a bug
12:44:45 <mceier> > read "\'\65279\'"
12:44:47 <lambdabot>  *Exception: Prelude.read: no parse
12:45:42 <solonarv> ah, ExtendedDefaultRules strikes again!
12:46:20 <phadej> > isPrint '\65279'
12:46:22 <lambdabot>  False
12:46:26 <phadej> isPrint '\n'
12:46:34 <phadej> > isPrint '\n'
12:46:36 <lambdabot>  False
12:46:42 <phadej> > isSpace '\n'
12:46:44 <lambdabot>  True
12:46:57 <phadej> > isPrint ' '
12:46:59 <lambdabot>  True
12:47:05 <phadej> hmm
12:47:58 <hyperisco> it isn't considered White_Space
12:48:09 <Nolrai> Its category is "Other, format".
12:49:03 <geekosaur> > isGraph ' '
12:49:06 <lambdabot>  error:
12:49:06 <lambdabot>      Variable not in scope: isGraph :: Char -> t
12:49:09 <geekosaur> bah
12:49:26 <hyperisco> also quite the evil character, as are all zero-width characters
12:51:25 <Nolrai> My files are actually limited to characters [0-9][A-Z][a-z][/+=] so I could filter out all non-ascii or something.
12:51:54 * hackage servant-multipart 0.11.5 - multipart/form-data (e.g file upload) support for servant  https://hackage.haskell.org/package/servant-multipart-0.11.5 (phadej)
13:09:24 <Finianb1> Does anyone know a good method to generate rooted trees in Haskell?
13:11:26 <monochrom> All of them?  A random one?
13:14:24 * hackage servant-mock 0.8.6 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.8.6 (phadej)
13:21:24 * hackage primitive-unlifted 0.1.3.0 - Primitive GHC types with unlifted types inside  https://hackage.haskell.org/package/primitive-unlifted-0.1.3.0 (andrewthad)
13:23:58 <Finianb1> Monochrom, specifically I'm looking to generate all rooted trees nodes <= n for some argument n
13:26:11 <monochrom> You can use recursion on n.  If you have a list of n-node trees, you can build upon it for a list of (n+1)-node trees.
13:27:59 <monochrom> Actually from list of at-most-n-node trees to list of at-most-n+1-node trees.
13:34:04 <ezzieyguywuf> So, here is a small example where I define a `Point` data type and a `Vector` data type: https://repl.it/@WolfgangSanyer/UntrueDefinitiveFiles. I'm also defining an `offset` function that will take a `Point` and offset it by the amount indicated by the `Vector`. However, the approach I'm taking here feels wrong - it seems that my `offset` function is rather fragile, as I can see various combinations 
13:34:10 <ezzieyguywuf> of `Point`/`Vector` pairs that would not make sense
13:34:27 <ezzieyguywuf> being new to haskell and the functional style of programming, can anyone provide any commentary on how this approach may be improved upon?
13:37:51 <amx> well, you might want to have separate types for 2d/3d points
13:38:52 <amx> as you point out in the comment some operations make no sense, hence it might be a good idea to use types to prevent them
13:39:27 <ezzieyguywuf> hm, maybe `Coordinate` and `Coordinate2`, each with a `Cartesian` and `Polar` value constructor?
13:40:48 <amx> I know embarrassingly little about geometry, but that sounds good
13:40:48 <solonarv> I would do something like: data V2 a = V2 a a; data V3 a = V3 a a a
13:41:03 <solonarv> newtype Point v a = P (v a)
13:41:55 <solonarv> now you can write things like: instance Num a => Num V2 a where V2 x1 y1 + V2 x2 y2 = V2 (x1 + x2) (y1 + y2); -- and so on
13:42:32 <ezzieyguywuf> hm, that makes good sense
13:42:39 <ezzieyguywuf> you lost me with `P (v a)`
13:42:42 <solonarv> and then you can also write: offset :: Num (v a) => Point v a -> v a -> Point v a; offset (Point pos) v = Point (pos + v)
13:43:03 <solonarv> which part of it is confusing you?
13:43:35 <solonarv> er, that last bit should be: offset (P pos) v = P (pos + v)
13:43:54 <ezzieyguywuf> well, when I read `newtype Point v a = P (v a)` I see "define a new type Point that can be constructed with two values `v` and `a` and describe it as a P of (v a)`
13:44:04 <ezzieyguywuf> but I don't know what "a P of (v a)" is
13:44:36 <solonarv> well, 'P' is just what I called the constructor
13:44:49 <solonarv> I could just as well have called it 'Point' or 'MkPoint' or 'Frobnizzle'
13:44:57 <ezzieyguywuf> ah yes ok that makes sense
13:45:02 <ezzieyguywuf> I'm still lost on the `(v a)`
13:45:53 <solonarv> example usage: oneoneone = P (V3 1 1 1) :: Point V3 Int
13:46:01 <solonarv> here v = V3, and a = Int
13:46:32 <solonarv> "concrete types" aren't the only thing we can abstract over!
13:47:55 <ezzieyguywuf> hmmm, so if I was writing a module, I might expose a function `point3 :: a -> a -> a -> Point` and define it as `point3 x y z = P(V3 x y z)`
13:48:18 <solonarv> the type would be 'point3 :: a -> a -> a -> Point V3 a'
13:48:35 <solonarv> you can't just leave out the parameters!
13:48:39 <ezzieyguywuf> ah, because a `Point` is not fully defined unless you provide it with two `*`s
13:49:05 <solonarv> yes - to draw an analogy to C++: you can't just leave out the parameters to a template!
13:49:27 <ezzieyguywuf> could this not become cumbersome for the user if they need to "qualify" any Point they use with a Vector type?
13:49:42 <amalloy> ezzieyguywuf: "two values `v` and `a`" isn't quite right. it's two *types* to construct the type; to construct a value you need a single value, of type (v a)
13:49:49 <solonarv> well, it's either that or you end up defining redundant Point2, Point3, etc types
13:49:51 <ezzieyguywuf> I could see `Point V2 a` making sense, as one could assume a 0 for the z-value of the vector
13:50:06 <ezzieyguywuf> solonarv: ah hah, i see
13:50:06 <solonarv> nono, 'Point V2 a' is just a point in 2D space
13:50:13 <solonarv> it doesn't have a z component at all
13:50:36 <ezzieyguywuf> ohhh
13:50:46 <ezzieyguywuf> you know what, I'm going to play around with these concepts a bit
13:50:54 <ezzieyguywuf> perhaps it won't be so cumbersome after all
13:50:59 <ezzieyguywuf> thank you :)
13:51:09 <solonarv> btw, I did not invent this from scratch
13:51:23 <ezzieyguywuf> please elaborate
13:51:25 <solonarv> those V2 V3 etc... types are from the 'linear' package
13:51:29 <solonarv> which was already mentioned earlier
13:51:33 <ezzieyguywuf> lol, which was discussed earlier
13:51:55 <ezzieyguywuf> I do think it could be helpful for me to stumble about like this for a bit before diving in and relying on linear too much
13:51:57 <solonarv> and 'Point' is there as well
13:52:03 <ezzieyguywuf> though it could be helpful for me to go in there and sort of see how they do things
13:52:23 <solonarv> oh, it's definitely a good idea to experiment with this on your own, that's how I got comfortable with a lot of things
13:52:37 * ezzieyguywuf nods
13:52:44 <ezzieyguywuf> I can use linear as a reference though
14:06:24 <pounce> could i make a haskell wiki edit request? or should i just email the list to make an account
14:12:24 <solonarv> pounce: I think you are supposed to just ask for an account
14:19:58 <Koala-Gentil> Hello there, Im currently learning Haskell with lyah. In the part about Writer, the tutorial show how to implement a gcd with logs. I tried to add the date of the log with getCurrentTime but now my code is very ugly. Can someone look at my code and explain what I should have done ?
14:24:50 <ammar2> sure, paste your code
14:26:27 <solonarv> actually I can already tell you why your code is a mess
14:26:39 <solonarv> Writer is a pure computation
14:26:57 <Koala-Gentil> https://gist.github.com/Koala-gentil/672442f5682651800bad0094cfdd2a22
14:26:58 <solonarv> "pure" means, among other things, that you get the same result no matter when the computation actually happens
14:27:18 <solonarv> clearly this is no longer the case if you want the output to include the current time!
14:28:58 <Koala-Gentil> So is there a good way to do what I have try ?
14:30:55 <solonarv> hm, well
14:31:04 <solonarv> you did have the right idea with mixing in IO
14:31:44 <solonarv> there is a less messy way to mix IO (or any other monad) with Writer, namely WriterT - which is a monad *transformer* rather than a monad
14:31:52 <solonarv> but that is a more advanced topic which you will get to later
14:32:56 <solonarv> you could also have used unsafePerformIO, but the spooky name should already warn you to stay away from that unles syou know what you're doing
14:33:31 <solonarv> the main problem with that is: the IO action does not get performed immediately, but at some unknown time, possibly not at all or possibly multiple times
14:33:45 <solonarv> if you want to read the clock, that's no good at all!
14:40:52 <Koala-Gentil> Ok, thank you for yours answers solonarv, I will take a look at WriterT
14:43:23 * hackage servant-js 0.9.4.1 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.9.4.1 (phadej)
14:44:10 <daydaynatation> In Monad type class, the kind of m should be * -> *, is this inferred? Becuase it's not mentioned in the type class definition
14:44:26 <phadej> yes.
14:51:17 <aplainzetakind> `cabal v2-haddock someexecutable --haddock-internal` still skips non-exported names. Isn't that the purpose of -internal?
15:07:35 <pounce> solonarv: ah makes sense. ill do that
15:28:08 <daydaynatation> in multi parameter type class, such as MonadState s m | m -> s, is the m -> s always necessary?
15:28:47 <daydaynatation> I noticed that it's used in all mtl multi parameter type classes, such as monadstate, monadwriter, reader etc..
15:29:45 <daydaynatation> if it's a must for all cases, why not make it a default? are there exceptions?
15:31:15 <amalloy> @hoogle Data.Coerce.Coercible
15:31:15 <lambdabot> Data.Coerce class a ~ R# b => Coercible (a :: k0) (b :: k0)
15:31:46 <amalloy> the fundep is definitely incorrect in many cases
15:32:11 <CoffeeCoder[m]> Learning about applicative functors. My head hurts.
15:59:23 <Axman6> CoffeeCoder[m]: you might find that using some, and then learning how they work is a bit easier. Many parsing problems can be solved with Applicative 
16:03:14 <daydaynatation> in type class definition, a function is declared and also defined. Does it mean it's the default defintion? Can it be changed?
16:04:18 <shachaf> Yes and yes.
16:04:53 <shachaf> -> is called a functional dependency and it's neither required nor a default that makes sense. You can look that name up to see what it does.
16:05:24 <daydaynatation> thx
16:07:12 <daydaynatation> shachaf: do you know a multi parameter type class without functional dependency?
16:09:03 <dminuoso> Im looking for an efficient function `Int -> Text` that encodes using plain decimals.
16:09:41 <dminuoso> Beyond the obvious `pack . show`, is there something more efficient?
16:10:23 <infinisil> dminuoso: I'm thinking some binary serialization library to encode it to a bytestring, then from that to text with e.g. utf8
16:10:31 <infinisil> Wait
16:11:01 <infinisil> Nah not serialization, that would just make a bunch of bytes, not render it as a decimal
16:11:49 <infinisil> dminuoso: https://hackage.haskell.org/package/text-show
16:12:23 <davve_> im kind of surprised haskell doesn't have that built in
16:12:36 <dminuoso> davve_: Text is not part of standard haskell.
16:12:57 <dminuoso> infinisil: Ah interesting, I think I can copy and paste that implementation for Int!
16:13:40 <dminuoso> infinisil: Ohhh!
16:13:42 <dminuoso> infinisil: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Lazy-Builder-Int.html#v:decimal
16:13:52 <infinisil> Yup just found that too!
16:13:56 <infinisil> Neat
16:14:38 <davve_> theres no printf simillar thing?
16:15:14 <davve_> sorry for my noobness :)
16:16:12 <dminuoso> davve_: Well there is a printf, but that gives me a ShowS, so it still takes me through String.
16:17:13 <davve_> ok... i need to check what Text is :p
16:17:35 <davve_> oh cool
16:21:15 <dminuoso> infinisil: Ah what a shame! It buys me only 5ms on average. :<
16:21:23 <dminuoso> But, 5ms is 5ms!
16:21:44 <infinisil> dminuoso: How many %?
16:21:50 <MarcelineVQ> that's a lot of ms tho
16:21:54 * hackage mutable 0.1.0.0 - Automatic piecewise-mutable references for your types  https://hackage.haskell.org/package/mutable-0.1.0.0 (jle)
16:22:05 <dminuoso> infinisil: Well Im averaging 258ms now.
16:22:30 <davve_> i don't like microoptimzations :P
16:22:53 <MarcelineVQ> I like them if they're easy :>
16:23:03 <infinisil> Using Text.pack . show does feel a bit nasty though
16:23:16 <dminuoso> infinisil: It's surprisingly efficient though.
16:23:30 <dminuoso> I suppose the Show instance for Int is fairly good already
16:23:41 <davve_> can't you cache a range of int and refer to them
16:23:49 <davve_> to their utf counterpart
16:23:51 <dminuoso> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Show.html#itos
16:23:54 <dminuoso> Lot's of hashes.
16:23:56 <davve_> trade memory for speed
16:24:06 <davve_> computation*
16:24:15 <dminuoso> davve_: We call that technique memoization. :)
16:24:20 <davve_> ah right :)
16:24:30 <dminuoso> Though for this computation I dont think it's worth it.
16:25:51 <dminuoso> But... its worth a try!
16:33:29 <infinisil> dminuoso: Did you profile the code?
16:41:22 <nshepperd> i learned something interesting recently: you can have a functional dependency with nothing to the left of the ->
16:41:39 <nshepperd> which means the variables on the right have only one value
16:42:01 <Axman6> singleton classes?
16:42:59 <nshepperd> a type level singleton, yeah
16:44:28 <nshepperd> it seems pretty useless. but that 'typing the technical interview' post used it to force evaluation of constraints for the repl
16:48:23 <Axman6> class TheOneTrueType a | -> a where; instance TheOneTrueType Any where
16:50:14 <nshepperd> heh
16:50:23 <hseg> Huh
16:56:13 <wildtrees> one ring to rule them all , and in the darkness >>= them
16:57:43 <Axman6> as long as it is also a Group
16:58:11 <wildtrees> Fellowship of the (.) perhaps? 
17:11:50 <jackdk> https://www.irregularwebcomic.net/470.html ; What's an abelian group with an associative, distributive secondary operator and the power to corrupt mortals?
17:28:09 <fog> i need a representation of a parametrised surface of arbitrary genus that can be provided with continuous variables to sample the space of possible surfaces as a way to represent solid objects for ray tracing with occlusion
17:28:34 <suzu> are you still solving problems that exist in this universe and not a different one
17:29:01 <CoffeeCoder[m]> @axman
17:29:01 <CoffeeCoder[m]>  * 
17:29:01 <lambdabot> Not enough privileges
17:29:10 <fog> i think it requires something like the Poincare conjecture
17:29:13 <CoffeeCoder[m]> Axman6: alright :)
17:29:33 <fog> suzu, someone was asking about 3d modeling 
17:30:19 <fog> if there is eg an embeded surface, this can be the interpolation over some sparse points on the surface, or with arbitrary representation to the input
17:30:35 <fog> ie, a function over some variables that outputs the interpolant surface
17:30:43 <fog> so just a parametric model
17:30:55 <fog> then the problem is defining a coordinates system on the surface
17:31:20 <fog> so that lover dimensional surfaces arrear as sections resulting from partial function application
17:32:37 <fog> ie selecting some curvilinear orthogonal coordinate system that the surface is a level set of
17:33:45 <fog> and parametrising over the space of these being a coordinate system for the set of shapes, which can be chosen to represent some underlying manifold
17:34:21 <fog> such as the set of shapes of a 2d surface in 3d space undergoing deformation in time
17:34:49 <fog> which is a connected curve in this space
17:34:53 <suzu> 🤔🤔🤔
17:37:22 <fog> then we can ask that the parameters of the shape changing continuously results in nearby surfaces in the limit 
17:38:42 <fog> basically this parametric model can then be factored into a neural network component, and some system it drives which is a fairly expressive way to represent arbitrary closed surface of abritrary genus
17:39:27 <fog> ie i can use the net to restrict from this parametric model of surfaces to those which are dog surfaces
17:40:19 <fog> where the original model was a parametrisation over all surfaces, and the model with a net component can convert this into a coordinate system over a learned shape
17:41:13 <fog> the net part seems easy, but whats then needed is the parametric model over the space of curvinilear orthogonal coordinate systems, the level sets of which are surfaces
17:41:27 <fog> probably only of genus 2...
17:42:10 <fog> which is easy because we have a coordinate system on continuous deformations from the spere by poincare conjecture
17:42:51 <fog> so can parametrise over a curve taking one shape to the other by time evolving curvature at each point
17:43:20 <fog> which is only possible since we have a coordinate system on the surface, which i cant do in higher genus easily 
17:44:08 <fog> then we have a parametrisation over the space of surfaces of genus 2 by specifying this evolving surface curvature
17:45:11 <fog> which are then the inputs that must be generated by the neural net from some other parametrisation coordinates supplied to this net as inputs
17:45:52 <fog> and then these need to be ray traced with occlusion for viewing
17:46:32 <fog> where there are probably constraints to do with shape surfaces intersecting each other and themselves 
17:56:17 <ezzieyguywuf> fog: I was the person asking about 3d modeling
17:56:54 <ezzieyguywuf> fog: I won't pretend to have followed all of what you said. I'll say I caught maybe 10% of it. But in general (very very general to to my low comprehension) I believe you have captured the problem and a potential solution
17:57:42 <ezzieyguywuf> if you are up to it I'd like to have a deeper conversation regarding your approach (here or elsewhere)
18:01:07 <nshepperd> i don't understand why you would just leave after saying all that
18:01:24 * hackage rank2classes 1.3.2.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.3.2.1 (MarioBlazevic)
18:02:12 <ezzieyguywuf> nshepperd: lol me neither
18:05:08 <MarcelineVQ> "we can generate shapes with a neural net" cool, didn't need 35 lines to say
18:06:01 <MarcelineVQ> also what you generate with a NN, the problem is generating what you want to generate
18:06:03 <ezzieyguywuf> 😂😂😂
18:06:05 <MarcelineVQ> *what can't you
18:17:57 <ezzieyguywuf> how do I generate the haddock documentation locally?
18:49:14 <mmaruseacph2> stack haddock or some equivalent in cabal-land (I don't remember it)
18:50:42 <davean> cabal haddock
18:50:47 <davean> stack just passes commands through
18:52:09 <MarcelineVQ> through to what?
18:52:18 <davean> cabal
18:52:21 <glguy> the past
18:52:29 <MarcelineVQ> are you sure?
18:52:32 <davean> absolutely
18:52:53 <MarcelineVQ> so if I don't have cabal-install stack haddock won't work?
18:52:56 <ddellacosta> is there a way to write an "instance IsLabel a Text where" ? I found something similar but it would appear that fromLabel used to have an argument and does not now
18:53:20 <davean> MarcelineVQ: if you don't have cabal, stack can basicly only install cabal. stack only gets some stuff onto the system and runs cabal.
18:53:57 <ezzieyguywuf> hrm, `cabal haddock` tries to generate documentation for a package I'm writing. what about documentation for Prelude and other Base stuff
18:54:29 <davean> ezzieyguywuf: you can ask cabal to build the documentation whenever it installs a package for example
18:54:33 <MarcelineVQ> That's not correct davean, if by runs cabal you mean uses cabal-installc
18:54:52 <MarcelineVQ> *uses cabal-install
18:54:53 <glguy> ezzieyguywuf: Documentation for Prelude is linked in to the stuff generated by "cabal haddock"
18:55:22 <ezzieyguywuf> hm. I'm confused. someone in here told me that hoogle is nice, but sometimes out of date, and that it'd be better to build my documentation locally
18:55:24 <MarcelineVQ> If you mean makes use of the Cabal library, then so does cabal-install (aka cabal)
18:55:41 <glguy> ezzieyguywuf: and documentation is installed, for example, at ~/.ghcup/ghc/8.8.2/share/doc/ghc-8.8.2/html/index.html
18:55:47 <MarcelineVQ> and by that logic it's as-correct to say 'cabal just passes commands through'
18:56:38 <ddellacosta> ezzieyguywuf: fwiw I find the !h bang command in duckduckgo super handy for looking up Haskell docs quickly, just redirects to hoogle which doesn't seem to be out-of-date as far as I can tell
18:58:20 <ddellacosta> or at least, if it is, it hasn't prevented me from ever finding what I needed
19:00:56 <MarcelineVQ> davean: I don't think therse any command a recent stack can do that requires cabal-install. stack used to have a solve command and init option that used cabal-install to solve hackage-related package requirements but they dropped that at some point
19:03:17 <davean> looking at stacks code now its a lot more Cabal absed than it was at least
19:10:30 <dportin> is there a better (purely functional) data structure for mapping non-disjoint subsets of a finite set to values than some kind of trie? suppose insertions occur an order of magnitude less than queries.
20:34:32 <gendarme> can someone explain how a is handled here?
20:39:37 <iqubic> gendarme: Handled where?
20:43:34 <gendarme> on the rhs
20:43:37 <gendarme> a:takewhile
20:44:30 <ChaiTRex> gendarme: Can you give the whole expression please?
20:44:35 <iqubic> Do you have the full code?
20:46:22 <gendarme> oooh woops
20:46:25 <gendarme> sorry
20:46:51 <gendarme> https://bpaste.net/6ZXA
20:47:19 <jle`> what language is this?
20:47:32 <gendarme> miranda
20:47:33 <ChaiTRex> gendarme: That's not valid Haskell code.
20:47:38 <gendarme> ah got me
20:47:56 <gendarme> ok, thanks for looking
20:47:59 <jle`> gendarme: are you familiar with how lists are constructred?
20:48:05 <ChaiTRex> gendarme: It looks like a is an element of the list.
20:48:14 <jle`> how 1:2:3:[] is [1,2,3], for instance
20:48:38 <gendarme> yeah : means to append to the head
20:48:55 <jle`> gendarme: yeah, so a is being appended to the head of takewhile f x
20:49:30 <gendarme> right
20:49:32 <gendarme> ok
21:43:32 <fog> ezzieyguywuf: yeah, i think thats the idea, to get a representation of the occluding surface when ray tracing from a 3d scene
21:43:42 <fog> you want a low dimensional representation of a surface
21:44:14 <fog> that was the idea with having it output from a net, which can take comparatively few inputs compared to a spline for example
21:45:53 * hackage conferer 0.2.0.0 - Configuration management library  https://hackage.haskell.org/package/conferer-0.2.0.0 (ludat)
21:46:54 * hackage conferer-hspec 0.2.0.0, conferer-warp 0.2.0.0 (ludat): https://qbin.io/cure-dive-nuvr
21:47:54 * hackage conferer-provider-json 0.2.0.0, conferer-provider-yaml 0.2.0.0, conferer-provider-dhall 0.2.0.0, conferer-snap 0.2.0.0 (ludat)
21:59:54 * hackage fedora-dists 1.1.2 - Library for Fedora distribution versions  https://hackage.haskell.org/package/fedora-dists-1.1.2 (JensPetersen)
22:19:24 <fog> the other way of paramatrising the surfaces is instead of have a time evolving curvature of the surface to deform it continuously from a sphere
22:19:30 <fog> is to have conformal transformations
22:19:45 <fog> which are local infintesimal generators
22:19:51 <fog> like deep covnets
22:20:43 <fog> then some continuous integrated conformal transformation over regular cartesian coordinates can carry the unit ball into some surface
22:21:09 <fog> as a choice of level set on the resulting curvilinear orthogonal coordinate system
22:21:27 <fog> again, the main task is the intersection with rays and occlusion
22:22:03 <fog> basically the task is to select a "frame"
22:22:19 <fog> when even we could use a mixture of wavelets and curvelets
22:22:35 <fog> but this is more of a volumetric approach than just representing the surface
22:23:20 <fog> infact, the dictionary learning approach, particularly curvelets, as bandpassed ridgelets (small radial brushstrokes of a charicteristic width and length)
22:23:42 <fog> are specifically used to *avoid* a parametric representation of a surface
22:24:03 <fog> the resolution of which is normally difficult because of pixilation and noise
22:24:40 <fog> ie, you dont need to do edge detection, or rather it is no more helpful to do so, when using an adequate frame
22:25:51 <fog> but this is a consideration just to do with continuous data, such as a 2d image. in 3d where we have open space which we ray trace through as transparent, im not sure how the curvelets could be helpful
22:26:57 <fog> as it really is a representation of the surface which is used to ray trace against. unless it was some kind of translucency like for medical imaging with partial refraction, but thats not how we normally do ray tracing
22:27:41 <fog> it seems much lower cost to consider one reflective surface compared to the integral through a less than totally opaque region
22:28:17 <fog> perhaps the curvelets then can just act as edge detectors
22:28:48 <fog> where then the wavelets and curvelets in a mixed frame is important so that the curvelets are only used at the edges and the wavelets through the volume
22:29:52 <fog> then it is always tempting to make an elastic sheet subject to forces which have it fit the region weighted by directional ridgelets at various scales
22:30:27 <fog> but that seems of a similar complexity to an interpolating spline
22:31:01 <fog> but possibly with the advantage as not requering intergration over the surface to ensure it does not intersect itself
22:31:29 <fog> since it was basically wrapped around the detected edges
22:31:41 <fog> surfaces*
22:32:50 <fog> then, regulating the smoothness ammounts similarly to truncating to low order polynomial interpolants, as acheived by a high elastic force to promote smoothness across some order of derivative
22:34:06 <fog> a very simple way also is to make a point cloud and blur it and place the surface at a threshold intensity, which is kind of how smoothed particle hydrodynamics would represent a fluid surface
22:34:36 <fog> the idea there is that these same particles are used to embed the equations of motion of the material aswell
22:35:11 <fog> allowing for eg simulations of splatting Plasticine teapots etc
22:36:19 <fog> where then the representation of the surface is again of similar complexity in terms of control points covering the surface, except they are smooted via gausian blur instead of a surface with tension
22:37:32 <fog> there is then probably some optimal with giving each point a different rate of diffusion to have the fewest number of well placed points as possible
22:38:20 <fog> maybe even something like locally linear embedding could work well
22:39:15 <fog> a technique in manifold learning that preserves local angles and distances to kind of flatten out a low dimensional manifold thats all curled up in higher demensions as a sectioning hypersurface
22:40:34 <fog> and then maybe something to do with self orgamising maps, but they are more like swarm optimisors and it would have to be phrased as a gradient descent over which several paths of sctochasitc exploration could be combined
22:42:53 <fog> where i guess simple mote carlo would just be evolong the surface until it has a small integrated distance to some target, or where this is the maximum a priori estimate, as the lowest moment in a probabilistic expansion
22:43:24 <fog> ie its a coordinate descent of an approximating surface
22:44:00 <fog> the interesting thing with each of these is the API the user gets to specify shapes via
22:45:22 <fog> in each case its actually probably quite hard to describe a shape in terms of eg, conformally distroting a sphere, or recording the history of curvature on its surface, like a solution to einstines equations or something
22:45:59 <fog> but that has a nice interface of kind of dragging a magnet over a sphere to deform it
22:46:40 <fog> another cool idea is to have small machines rolling and positioning plasticine like particle fluid simulatied 3d blobs
22:47:10 <fog> where eg, robotic arms and conveya belts can be used to move the plasitcine around and construct the overall 3d shape
22:47:26 <fog> basically then, you are recording the history of steps in processing the shape
22:48:41 <fog> where then it would be really cool to get physical tollerances over eg metal components made on a lathe 
22:49:21 <fog> to build physically accurate robotic arms with bearings and everything
22:50:21 <fog> so then the users ability to make a particular 3d shape is limited by their access to accurate and versatile virtual manufacturing lines
22:51:04 <fog> which would probably require some 3d modeling specification to be input to them...
23:04:11 <dmj`> the fog of war
23:30:40 <zeta_0> hello guys, i installed the threepenny-gui package but these modules are not being recognized?
23:30:43 <zeta_0> import qualified Graphics.UI.Threepenny as UI
23:30:43 <zeta_0> import           Graphics.UI.Threepenny.Core
23:31:02 <zeta_0> am i missing another package that i need to install?
23:31:43 <MarcelineVQ> are those imports in a module that is part of a project?
23:34:13 <MarcelineVQ> Or, to ask another way, how did you install threepenny-gui and how are you using the source file that has those imports in order to get that error
23:36:52 <zeta_0> MarcelineVQ: hello again, yes i am using a cloned project from github to follow a tutorial blog, a while back i was having a problem with ghcide not recognizing the Yesod modules, so one of the contributors instructed me to set the NIX_GHC_LIBDIR env var and it worked, so i am not sure if i am having the same issue here?
23:37:10 <MarcelineVQ> how did you install threepenny-gui and how are you using the source file that has those imports in order to get that error
23:37:36 <zeta_0> MarcelineVQ: i have everything installed in home.nix(home-manager)
23:38:08 <zeta_0> MarcelineVQ: and here is the tutorial that i am following: https://binarin.ru/post/auto-reload-threepenny-gui/
23:39:20 <zeta_0> he has a link to a github repo, which i then cloned to follow along with his tutorial
23:41:50 <zeta_0> MarcelineVQ: i could show you my home.nix file if you want?
23:42:12 <MarcelineVQ> sure, and the error, and what you are typing into the cli to see the error
23:43:56 <MarcelineVQ> especially the last part since it's "how are you using the source file that has those imports in order to get that error"
23:44:33 <zeta_0> here is my home.nix file, and i'll paste the error in a second: https://hastebin.com/oyadopisux.bash
23:47:45 <zeta_0> so after cloning the project from github, i opened the Main.hs file and ghcide is throwing the error: could not find the module Graphics.UI.Threepenny, it is not a module in the current program or any known package
23:48:48 <MarcelineVQ> you're using nix to provide threepenny-gui, are you running ghcide via nix?
23:50:18 <MarcelineVQ> I don't use nix so that's all I can think of when it comes to things to diagnose
23:51:24 <zeta_0> MarcelineVQ: i installed ghcide with nix, and i have it setup in emacs, after setting that nix env var in home.nix that i showed you earlier, ghcide was then able to recognize Yesod modules, so i don't know if i am having the same problem with this module
23:54:44 <MarcelineVQ> hmm that is pretty perplexing if it finds yesod just fine, did you add threepenny-ui very recently, do you maybe need to reload nix or something? idk how it works or if that's neccesary. have you restarted your pc since you added threepenny-gui just to see if it has an effect?
23:57:49 <zeta_0> MarcelineVQ: yes, i installed threepenny-gui afterwards, i set the env var, but i have already done a bunch of rebuild switches'
23:58:46 <zeta_0> MarcelineVQ: maybe after i installed the package the nix store path changed, maybe that's why the module is not being recognized
23:59:24 <MarcelineVQ> dunno sorry, nix is a mystery to me
