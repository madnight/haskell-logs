00:09:11 <smollcato> [irc/freenode] <Guest91870> w
00:21:44 <a1c> @hoogle it
00:21:45 <lambdabot> Test.Hspec it :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)
00:21:45 <lambdabot> Test.Hspec.Core.Spec it :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)
00:21:45 <lambdabot> Hledger.Utils.Test it :: Text -> Test a -> Test a
00:22:29 <a1c> :t it
00:22:31 <lambdabot> error:
00:22:31 <lambdabot>     • Variable not in scope: it
00:22:31 <lambdabot>     • Perhaps you meant one of these:
00:22:52 <MarcelineVQ> 'it' is just the result of the last thing you typed into ghci, it's specifically a ghci thing
00:23:19 <a1c> it :: [Char]  what this function is?
00:24:14 <a1c> oh
00:50:10 <a1c> if there's a list [1,2,9,22,8,7,21,8,2,77], how to get the greatest number and this number must be unique?
00:51:26 <lortabac> > maximum [1,2,9,22,8,7,21,8,2,77]
00:51:28 <lambdabot>  77
00:52:30 <a1c> lortabac: how to remove the same element?
00:53:25 <a1c> duplicate number
00:53:43 <a1c> lortabac: remove the duplicate number from a list
00:54:20 <lortabac> Data.List.nub
00:54:30 <lortabac> > nub [1,2,9,22,8,7,21,8,2,77]
00:54:32 <lambdabot>  [1,2,9,22,8,7,21,77]
00:56:50 <MarcelineVQ> do you want to remove it or do you want to check if it's unique?
00:57:25 <a1c> are they not the same?
00:58:10 <a1c> if I know if it's unique then I know how to remove it
00:58:58 <a1c> oh, my fault
00:59:13 <a1c> MarcelineVQ: if it's unique is what I want
00:59:41 <lortabac> also, if this is homework, are you allowed to use library functions?
00:59:51 <a1c> lortabac: nub just remove the duplicate elements, but I want remove the duplicate element itself
01:00:32 <lortabac> a1c: do you want to remove all the instances of that value?
01:00:54 <a1c> lortabac: yeah
01:01:12 <lortabac> ok
01:01:20 <lortabac> then nub is probably not the right choice
01:15:41 <MarcelineVQ> a1c: sort and group from Data.List are good options. this will tell you what items are unique based on the length of the groups.
01:19:42 <a1c> > group [1,2,3,2,3]
01:19:44 <lambdabot>  [[1],[2],[3],[2],[3]]
01:20:10 <MarcelineVQ> > group (sort [1,2,3,2,3])
01:20:12 <lambdabot>  [[1],[2,2],[3,3]]
01:23:07 <a1c> > filter (\l -> length l == 1) (group . sort $ [1,2,3,2,1])
01:23:10 <lambdabot>  [[3]]
01:25:35 <MarcelineVQ> that's the idea, good job
01:27:23 <a1c> > (maximum . concat) $ filter (\l -> length l == 1) (group . sort $ [1,2,3,77,22,77,21,5])
01:27:25 <lambdabot>  22
01:28:03 <a1c> MarcelineVQ: can the code be more less?
01:28:14 <amalloy> @hoogle nubOrd
01:28:14 <lambdabot> Data.Containers.ListUtils nubOrd :: Ord a => [a] -> [a]
01:28:14 <lambdabot> Data.List.Extra nubOrd :: Ord a => [a] -> [a]
01:28:15 <lambdabot> Extra nubOrd :: Ord a => [a] -> [a]
01:29:38 <MarcelineVQ> a1c: That's pretty good as far as length goes. It can be made slightly safer by letting it work on the empty list, and slightly faster by avoiding using length, but I think yours looks good.
01:30:13 <MarcelineVQ> it can be cleaned up slightly with some use of .   maximum . concat . filter (\l -> length l == 1) . group . sort $ [1,2,3,77,22,77,21,5]
01:30:54 <amalloy> i'm a fan of functions like ((== 1) . length) as well
01:33:01 <a1c> > maximum . concat . filter ((== 1) . length) . group . sort $ [1,2,3,77,22,77,21,5]
01:33:03 <lambdabot>  22
01:35:37 <a1c> more less?
01:36:13 <MarcelineVQ> That looks great
01:37:49 <MarcelineVQ> If we wanted to improve it further we could write  listToMaybe . concat . filter (null . drop 1) . group . sortOn Down   which filters with (null . drop 1) to check that a list is empty if we remove one element, in other words that its length is at most 1, this can be an improvement because length needs to could the whole list but (null . drop 1) just checks if it's empty after dropping one item.
01:38:26 <MarcelineVQ> This version also sorts by largest to smallest using sortOn Down  so that the first item in the resulting list is the largest one. We can use head at that point to get the largest element quickly but I chose to use listToMaybe which takes the first item in the list and wraps it with Just if the list isn't empty, and Nothing if it is empty
01:38:41 <MarcelineVQ> Down is from Data.Ord and listToMaybe is from Data.Maybe
01:39:18 <MarcelineVQ> *because length needs to count the whole list
01:39:54 <dminuoso_> discrimination?
01:43:24 <MarcelineVQ> dminuoso_: https://hackage.haskell.org/package/discrimination-0.4/docs/Data-Discrimination.html ?   neat mention. That's a tidier group. Can it obviate the filtering too?
01:45:04 <kubrat> p
01:52:28 <dminuoso_> MarcelineVQ: I dont think so, but I'd just write a simple `f [] = Nothing; f ([x]):_ = Just x; f _:xs = f xs` helper function maybe?
01:52:45 <dminuoso_> Seems easier than trying to be clever and only reusing existing functions
01:53:37 <dminuoso_> Or maybe just safeHead, seems to fit better with the sorting.
01:53:57 <MarcelineVQ> listToMaybe is safeHead isn't it?
01:54:10 <dminuoso_> MarcelineVQ: Ah wait, I meant something else.
01:54:15 <f-a> I would rather install hakyll from my repos (Debian) than compile it myself. Do I just specify the version in my .cabal file and be done with it?
01:54:35 <MarcelineVQ> we're down to   listToMaybe . maximum . filter (null . drop 1) . group $ [1,2,3,77,22,77,21,5]  with that version of group anyway, which is pretty short
01:54:42 <dminuoso_> Something like `safeSingleHead (x:[]) = Just x; safeSingleHead _ = Nothing`
01:54:51 <dminuoso_> Then you can drop the filter
01:55:19 <MarcelineVQ> ah I see
01:55:36 <dminuoso_> I think its a bit more expressive than filter
01:55:40 <MarcelineVQ> exactlyOne :: [a] -> Maybe a   :>
01:55:48 <dminuoso_> Oh sure, thats a better name :)
01:57:12 <Ailrun[m]> you can use fmap fst . uncons
01:57:30 <MarcelineVQ> I really like uncons
01:57:32 <Ailrun[m]> Oh no, it's not
01:57:59 <Ailrun[m]> It's bit more complex than fmap fst . uncons
01:58:13 <dminuoso_> MarcelineVQ: Mmm, I recall a useful library that provided Traversable (or was it Functor?) in a modified form that allowed it to drop an element.
01:58:20 <MarcelineVQ> withering
01:58:22 <MarcelineVQ> witherable
01:58:25 <dminuoso_> That one, right.
01:58:43 <dminuoso_> oh, we could just use mapMaybe then
01:58:54 <dminuoso_> maximum . mapMaybe exactlyOne . group
01:58:59 <dminuoso_> That seems fairly expressive :)
01:59:10 <Ailrun[m]> sort too
01:59:20 <Ailrun[m]> maximum . ... . group . sort
01:59:28 <dminuoso_> Ailrun[m]: why the extra sort?
01:59:38 <MarcelineVQ> Ailrun[m]:  dminuoso_ is using  a version of group that doesn't need sorting
01:59:41 <dminuoso_> Ailrun[m]: Im assuming we're using edwards discrimination, so we're already in O(n) :)
01:59:51 <dminuoso_> with the correct behavior
02:00:09 <Ailrun[m]> Oh, maybe I missed some context.
02:00:16 <dminuoso_> Ailrun[m]: https://hackage.haskell.org/package/discrimination
02:03:41 <Ailrun[m]> Thx
02:10:53 * hackage sws 0.5.0.0 - A simple web server for serving directories.  https://hackage.haskell.org/package/sws-0.5.0.0 (DerekElkins)
02:21:34 <dibblego> @type (^? _head)
02:21:36 <lambdabot> Cons s s a a => s -> Maybe a
02:28:29 <MarcelineVQ> you fancy people and your fancy symbology :>
02:33:29 <kuribas> @type (view _head)
02:33:30 <lambdabot> (MonadReader s m, Cons s s a a, Monoid a) => m a
02:33:42 <phadej> @type (preview  _head)
02:33:43 <lambdabot> (MonadReader s m, Cons s s a a) => m (Maybe a)
02:33:55 <kuribas> > view _head []
02:33:58 <lambdabot>  ()
02:34:13 <kuribas> that's mempty?
02:34:19 <phadej> yes
02:34:32 <phadej> > view _head [] :: String
02:34:34 <lambdabot>  ""
02:34:46 <phadej> > view _head "foobar" :: String
02:34:48 <lambdabot>  error:
02:34:48 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
02:34:48 <lambdabot>          arising from a functional dependency between:
02:35:04 <phadej> > view _head [1,2,3] :: Sum Int
02:35:06 <lambdabot>  Sum {getSum = 1}
02:35:33 <phadej> > view _head [] :: Sum Int
02:35:36 <lambdabot>  Sum {getSum = 0}
02:35:58 <phadej> in other words, it doesn't really make sense ;)
02:36:28 <phadej> > preview _head "foobar"
02:36:30 <lambdabot>  Just 'f'
02:36:44 <phadej> but preview does
03:08:28 <merijn> > view _head [1,2,3] :: Last Int -- I wonder...
03:08:29 <lambdabot>  error:
03:08:29 <lambdabot>      • No instance for (Num (Last Int)) arising from the literal ‘1’
03:08:30 <lambdabot>      • In the expression: 1
03:08:36 <merijn> ah, lame
03:08:49 <merijn> > view _head (map Last [1,2,3]) :: Last Int -- I wonder...
03:08:52 <lambdabot>  error:
03:08:52 <lambdabot>      • No instance for (Num (Maybe Int)) arising from the literal ‘1’
03:08:52 <lambdabot>      • In the expression: 1
03:09:08 <merijn> > view _head (map (Last . Just) [1,2,3]) :: Last Int
03:09:10 <lambdabot>  Last {getLast = Just 1}
03:36:14 <dminuoso_> merijn: Do you know of a quick hacky way to explicitly parse for '-Wfoo'?
03:36:32 <dminuoso_> (optparse-applicative I mean)
03:57:36 <merijn> Not sure what "explicitly parse for" means?
04:14:23 * hackage staversion 0.2.3.3 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.3.3 (debugito)
04:22:21 <dminuoso_> merijn: So something like https://gist.github.com/dminuoso/b9ede31c65231f9071cd4957e5fefdb6 except with short 
04:23:43 <merijn> dminuoso_: Eh, you can preprocess the args list before calling optparse? :p
04:24:11 <dminuoso_> Ah, that's an idea I haven't thought of. :)
04:24:32 <merijn> <- big brain
04:24:34 <dminuoso_> Heh
04:24:51 <dminuoso_> Not sure whether its worth it though.. I mean what Im doing now is very little effort and I have free tab completion as well
04:32:07 <cocreature> dminuoso_: fwiw, what you call "try" already exists in base as "optional"
04:32:38 <dminuoso_> cocreature: Ah cheers
04:44:40 <miguelnegrao> hi all. I'm stuck trying to solve a space leak. I want to walk over all the permutations of two lists, calculate something, and then find the smallest element. 
04:44:57 <miguelnegrao> simple example: minimum $ do { x <- permutations [1..7]; y <- permutations [1..7]; return $ head x + head y }
04:45:17 <miguelnegrao> As the lists get bigger the memory usage goes through the roof...
04:45:42 <miguelnegrao> Isn't it possible to walk though all the permutations and not keeping them around in memory ?
04:46:27 <miguelnegrao> tried using a version of minimum with foldl1' but didn't help...
04:48:32 <hseg> Hi. I need to write some code using rational functions (fractions of polynomials) in n variables (n a parameter). Other than trying to get HaskellForMaths to fit or reimplementing my own, are there any alternatives?
04:56:32 <hseg> hrm. Since I'm only interested in trigonometric polynomials, could instead consider the Q-algebra generated by Exp R^n (from algebra)
05:00:33 <madnight> "Considering a preorder as a category is right adjoint to turning a category into a preorder by preorder reflection" What does that mean? (I know the definition of preorders and categories)
05:06:00 <smollcato> [telegram/haskell] <SchmollCatto> test
05:06:33 <hseg> madnight: IIUC, you have the functor viewing a preorder as a category (by having a unique arrow iff dom<cod) and a functor from categories to preorders collapsing all homsets to contain at most one element
05:07:03 <phadej> madnight: adjunctions (i.e. what right adjoint means) is involved topic, cannot be explained easily
05:08:55 <phadej> Awodey goes explains adjunctions in 9th chapter
05:10:39 <phadej> yet, preorder reflection seems to be simple: make x =< y whenever there's an arrow between x and y
05:10:48 <merijn> Every time I try to figure out what people are on about when they talk about adjoints I just get hopelessly lost >.>
05:11:09 <phadej> s/adjoints/monads/
05:11:26 <madnight> okay, "dom<cod" stands for domain < codomain?
05:12:39 <merijn> phadej: I'm not convinced I understnad monads outside Haskell either, tbh :p
05:12:42 <hseg> madnight: sorry, computer rebooted. Basically, writing i::PreOrder->Category, F::Category->Preorder, we have (F x -> y) ~ (x -> i y)
05:13:02 <phadej> merijn: :)
05:14:35 <madnight> okay and collapsing homsets, means collapsing multiple morphisms between object to just one morphism?
05:14:52 <madnight> *objects
05:14:53 <hseg> Yes
05:15:17 <hseg> So there is a unique morphism iff there was any morphism
05:15:49 <madnight> okay, so unique up to isomorphism i guess
05:17:52 <hseg> no, as in Hom(Fx,Fy) is a singleton set if Hom(x,y) is nonempty, Hom(Fx,Fy) is empty iff Hom(x,y) is empty
05:18:17 <hseg> unless you meant something else
05:27:24 <madnight> ah okay and preorder reflection is x =< y iff x -> y (as phadej points out) hmm so its possible to construct a "Free Preorder" for a given category?
05:30:04 <hakell> hi guys
05:30:11 <hakell> anyone from Sweden?
05:34:21 <hseg> madnight: Yeah, except since you're losing a _lot_ of information we don't really call it "free"
05:34:41 <phadej> yes, that direction is rather forgetting
05:34:53 <phadej> (more rich category structure0
05:35:05 <phadej> the preorder -> category direction is  "free"
05:35:23 <dminuoso_> merijn: Gah I decided to go for `--warn-...` and `--no-warn...` just so I get a nice help page and tab completion.
05:35:46 <hseg> BTW - this adjoint pair gives you a monad on categories, though not really a useful one: T:Category->Category forgets whether there was more than one arrow between objects
05:36:04 <hseg> Showing this is a monad is left as an exercise
05:37:18 <madnight> So a construction is "non-free" when it involves some sort of collapsing and "free" if no information is lost.
05:37:46 <hseg> (similarly, you have a comonad U:PreOrder->PreOrder given by composing the insertion and forgetting functors. However, this is again unuseful, since it's just the identity)
05:38:17 <hseg> madnight: Yeah, ish
05:40:45 <hseg> "free" isn't really well-defined -- it's used more qualitatively than as an actual definition
05:41:00 <dminuoso_> Well freeness is well defined in terms of adjunctions..
05:41:30 <hseg> Yes, free functors are left adjoint to forgetful functors, but that's just kicking the can
05:41:44 <dminuoso_> In general you could say, the left functor in an adunction is free and the right functor is forgetful.
05:42:02 <hseg> I mean, no one would say that abelization is a "free abelian group" construction, would they?
05:42:04 <dminuoso_> (Though you would only call them free or forgetful if there was some obvious structure that was being forgotten)
05:42:22 <madnight> Hmm okay, so maybe one could also say that a free construction goes generally from lower level of abstraction to higher level of abstraction?
05:42:41 <hseg> Not necessarily - see my abelization example
05:43:46 <hseg> Which basically forces everything in the group to commute
05:44:44 <hseg> This means that the "free abelian group" generated by certain groups (perfect groups) are just the trivial 1-element group
05:45:39 <hseg> Concrete examples are the alternating groups of degree >=5
05:48:11 <madnight> thanks, your answers helped to further deploy my intuition for free constructions and the similarities between preorders and categories. I guess I continue to read the book now
05:51:54 <dminuoso_> madnight: freeness/forgetfulness is a characterization of adjunctions.
05:52:36 <dminuoso_> madnight: Losely, the idea is as follows: Just like isomorphism can be thought of as a weaker form of equality, adjunction is an even weaker form that admits some form of "forgetting" in one direction and "freeing" in the other direction
05:52:59 <dminuoso_> (though adjunctions specifically make sense in terms of functors)
05:53:28 <dminuoso_> So the freeness/forgetfulness is only with respect to an adjunction. 
05:54:14 <hseg> ... not really. You have *many* kinds of adjunctions, and not all of them fit this mold
05:55:03 <dminuoso_> hseg: For example?
05:55:58 <hseg> Take adjunctions between endofunctors of PreOrder, e.g. inclusion_{Z->R}-|floor
05:56:18 <hseg> or direct_image-|preimage
05:56:56 <madnight> just out of curiosity, what is the weakest from of equality you are aware of?
05:57:01 <dminuoso_> hseg: I suppose the terms free/forgetful are useful for when we can clearly associate an adjunction with something that can be forgotten
05:57:14 <hseg> Right
05:57:21 <dminuoso_> That is not always the case, or it requires some serious contortion of your head
05:57:36 <dminuoso_> madnight: Weakest in what sense?
05:58:22 <dminuoso_> madnight: Weakest would imply some kind of ordering. What ordering did you have in mind? When I said "weaker" it was meant in a really handwaving fashion
06:00:12 <madnight> Then I mean weaker in terms of "really handwaving fashion" : )
06:01:04 <dminuoso_> hseg: I think edward once mentioned an interesting example of C -> C*C which can be thought of as forgetful in the sense as forgetting the index if we think of C*C as C^2 and yielding constant functors
06:01:29 <dminuoso_> Perhaps you can always associate an adjunction with forgetfulness if you contort your mind long enough?
06:01:38 <mniip> much like any Functor is a container
06:01:59 <hseg> mniip: exactly
06:02:19 <hseg> dminuoso_: Well, yeah, limits/colimits are adjoint to the appropriate diagonal functors
06:02:30 <mniip> forgetful is usually reserved for faithful functors between concrete categories that commute with the functors to Set
06:04:34 <hseg> dminuoso_: I like the motivation wikipedia gives "The notion that F is the most efficient solution to the problem posed by G is, in a certain rigorous sense, equivalent to the notion that G poses the most difficult problem that F solves."
06:19:37 <hseg> This is just another reformulation of Lawvere's comment that syntax is adjoint to semantics - you have a functor interp:Languages->Models and a functor describe:Models->Languages. Then (m -> interp p) ~ (describe m -> p) (in a handwaving sense)
06:23:10 <hseg> But really, an adjunction is a free-forgetful pair or an optimization solution in much the same way a monad is a burrito
06:29:09 <hseg> You have several families of adjunctions: is-|generates (reflection), (x,)-|^x (tensor-hom), (contravariant) \x->R(x,.)-|\y->R(.,y) (Galois connection), ... see https://www.math3ma.com/blog/what-is-an-adjunction-part-3
06:44:35 <hseg> btw, madnight, re your question about superweak equality, you can always weak an equality C=D by an isomorphism f:C~D:g (and then weaken the isomorphism to an equivalence, i.e. fg=1 becomes fg~1, etc etc)
06:44:40 <hseg> cf https://ncatlab.org/nlab/show/equivalence
06:44:44 <maerwald> does GHC clean up file handles after some time?
06:45:26 <merijn> maerwald: You mean while compiling?
06:45:51 <maerwald> nah, for example when you lazily read from a file handle and then just stop and never look at the bytestring again
06:46:29 <merijn> maerwald: So you're not really asking about GHC, but about the RTS/base?
06:46:33 <maerwald> I'm trying to figure out how streamly will behave in a similar scenario and can't come up with an opaque API that cleans up file handles
06:46:37 <maerwald> yeah
06:46:58 <merijn> maerwald: No, it doesn't you leak them indefinitely unless you force the entire lazy String/BS/Text
06:47:11 <merijn> That's why conduit, etc. were invented in the first place
06:47:53 <maerwald> streamly doesn't have a notion of "closing" a stream, so when creating the Unfold from a Handle, you have to pass the Handle with the stream to every caller
06:47:56 <maerwald> which is unfortunate
06:48:05 <maerwald> (or you consume the entire stream)
06:49:44 <maerwald> for example, my idea was to give the Stream to the caller and then the caller might decide to not use it at all. Instead of knowing how to clean up the resources, that should be internal and the caller would just say "trigger cleanup"
06:50:02 <maerwald> seems harder than I thought
06:50:54 <maerwald> S.drain $ S.take 1 $ S.finally (putStrLn "cleanup") $ (S.fromList [1,2,3] :: SerialT IO Int) -- for example never triggers the cleanup, because S.take doesn't evaluate the whole input stream
06:51:11 <merijn> maerwald: Implementing proper bracketing is the entire reason for the internal complexity in conduit/pipe/iteratees/etc.
06:51:31 <merijn> maerwald: Wait, don't you just want ResourceT?
06:51:50 <maerwald> I've never used that
06:52:04 <maerwald> might be worth a shot
06:52:05 <merijn> maerwald: Your problem is essentially that S.finally only runs when the stream is exhausted, yes?
06:52:15 <maerwald> yeah, or if an exception is raised
06:53:08 <merijn> maerwald: Right, so the design of ResourceT is that you register cleanups and when you exit the ResourceT (by hitting the end or exception) then all remaining cleanups run
06:53:38 <merijn> maerwald: conduit has the same problem, which is why ResourceT was invented
06:54:08 <maerwald> gonna try that then
06:54:12 <merijn> maerwald: So in conduit you'd do "res <- alloc; yieldStuff res; release res"
06:54:56 <merijn> maerwald: Release will finalise the resource whenever the stream is exhausted. If release is never reached the finalizer will still be inside ResourceT and run upon exiting the ResourceT block
06:55:24 * hackage ghc-lib-parser 0.20200102 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200102 (shayne_fletcher)
06:56:23 * hackage ghc-lib 0.20200102 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200102 (shayne_fletcher)
06:57:24 <merijn> maerwald: Essentially it's just an IORef containing a "Map Key Finalizer" (well, there's also some reference counting for multi-threading) and you just insert new finalizer upon allocation and releasing them will remove them from the map
06:58:22 <merijn> maerwald: But since you have this "global" (it's not really global since it's basically ReaderT, but you get the idea) you can always tell which finalizers you'd be "leaking" and run them before exiting the final block)
07:07:34 <madnight> hseg, so is there something like infinitely weak equality?
07:11:02 <hseg> Yep, cf infinity-categories. In practice, IIRC you want to weaken equality differently, but I don't remember how
07:11:34 <hseg> IIRC one of the thing HoTT set out to do was figure that out, but don't take my word for it
07:15:32 <madnight> hmm interesting I'll add infinity-categories to my notes. I heard that HoTT is a hot topic : )
07:16:06 <dminuoso_> Why am I getting this seemingly strange error about "No instance for (Semigroup e)"? https://gist.github.com/dminuoso/4c73c5b018083a12465a8066b7ce989c
07:16:27 <dminuoso_> What is "a superclass of an instance declaration" exactly?
07:17:28 <merijn> dminuoso_: I think one of your instance has a "Semigroup e" constraint
07:17:39 <merijn> Presumably Monad
07:17:46 <merijn> Since Monad is a superclass of MonadReader
07:18:32 <merijn> dminuoso_: This is based on ChronicleT, right?
07:18:34 <maralorn[m]> I don‘t think Monad has the Semigroup constraint.
07:18:58 <merijn> maralorn[m]: Monad doesn't, but the Monad instance of ChronicleT does
07:19:13 <dminuoso_> merijn: Yeah
07:19:17 <merijn> maralorn[m]: And since he's standalone deriving based on that instance, that's missing
07:19:34 <merijn> dminuoso_: "(Semigroup c, MonadReader r m) => MonadReader r (ChronicleT c m)"
07:19:42 <maralorn[m]>  * I don‘t think Monad has aSemigroup constraint.
07:19:57 <dminuoso_> merijn: Okay the diagnostic is pretty confusing here I think. :/
07:20:05 <dminuoso_> Especially the choice of the word "superclass"
07:20:16 <merijn> dminuoso_: Agreed, but also not sure how easy it's to fix
07:21:45 * geekosaur dislikes ghc's use of "superclass" anyway. 
07:21:53 <geekosaur> "prerequisite" seems to make more sense
07:22:54 <dminuoso_> geekosaur: The word superclass seems to make sense when you think of class as a synonym for set.
07:24:02 <dminuoso_> I think I might open an issue on ghc gitlab about this, see if this can be improved somehow
07:24:08 <geekosaur> I'm tempted to say "then call it a typeset". "class" just adds confusion to something already often confusing
07:24:20 <dminuoso_> Fair enough.
07:24:21 <geekosaur> as for this error, it'd be nice if it showed *which* one at least
07:24:35 <dminuoso_> geekosaur: In this case, its not even a superclass! It's an instance constraint.
07:25:05 <geekosaur> I mean, it showed Semigroup, but not the (here, instance) that brought it into scope
07:25:05 <dminuoso_> While they are written using the same lexical elements, their meaning differs wildly
07:25:10 <dminuoso_> Ah right
07:25:28 <dminuoso_> geekosaur: Heh perhaps I should finish my GHC pull request then.
07:25:51 <dminuoso_> I have implemented the machinery for displaying instance instance provenance, it might fit there as well
07:26:02 <dminuoso_> s/instance//
07:28:26 <kuribas> can you have classes without methods?
07:28:53 <dminuoso_> kuribas: Yes.
07:28:57 <kuribas> for example, to represent a subtype relationship using symbols
07:29:06 <dminuoso_> % class Has t
07:29:06 <yahb> dminuoso_: 
07:29:09 <dminuoso_> % instance Has Integer
07:29:09 <yahb> dminuoso_: 
07:29:34 <kuribas> like:  instance IsSubTypeOf "int" "number"
07:30:48 <kuribas> I wonder if you can have a static type model that changes over time, and is stored in a database
07:31:01 <kuribas> so you can see the whole history of the model
07:32:16 <kuribas> obviously you cannot do that in the haskell typesystem, because it's static
07:32:40 <dminuoso_> "static type model that changes over time"
07:32:42 <kuribas> but perhaps make a meta-model in the haskell typesystem
07:32:44 <dminuoso_> Not sure what that is supposed to mean
07:33:02 <kuribas> dminuoso_: it's static, but parameterized by time
07:34:00 <kuribas> dminuoso_: like in, it's fixed for anytime in the past, but can change in the future
07:34:25 <merijn> Isn't that just "versioning"? >.>
07:34:33 <kuribas> merijn: yeah, but live
07:37:08 <kuribas> and the metamodel is stored in a database, not in code
07:37:27 <kuribas> but the code can be checked against compatibility with the metamodel
07:40:01 <p0lyph3m> kuribas: have you had a look at unison language ?
07:40:44 <dminuoso_> kuribas: Types are still a compile-time thing. 
07:40:57 <kuribas> p0lyph3m: is it staticly typed?
07:41:02 <dminuoso_> The moment you talk about runtime, it's something different.
07:41:06 <p0lyph3m> yep 
07:41:21 <kuribas> dminuoso_: the metamodel is not implemented in the haskell type system
07:41:27 <p0lyph3m> the have really good ideas
07:41:35 <kuribas> p0lyph3m: cool, I'll have a look
07:42:24 * hackage IPv6Addr 1.1.3 - Library to deal with IPv6 address text representations.  https://hackage.haskell.org/package/IPv6Addr-1.1.3 (MichelBoucey)
07:42:32 <kuribas> "Needless complexity and difficulties should be stripped away, leaving only that exhilarating creative essence of programming that made many of us want to learn this subject in the first place."
07:42:45 <kuribas> that true, but allow many interpretations
07:43:14 <p0lyph3m> kuribas: https://www.youtube.com/watch?v=gCWtkvDQ2ZI , its a intro talk about unison
07:43:25 <c_wraith> its also highly dependent on the definition of "needless"
07:44:34 <kuribas> we have an object database written in lisp, which also stores the metamodel in lisp.  It's quite nice, but I miss static garantuees in the code.
07:45:09 <dminuoso_> Gah what I wouldn't give for monad access in guards!
07:45:40 <kuribas> dminuoso_: use multiWay if?
07:47:05 <dminuoso_> kuribas: Not applicable.
07:47:16 <dminuoso_> kuribas: https://gist.github.com/dminuoso/434e08118f8ec53ded51c5acefcd8547 <- Id just love that whenWarn stuffed inside a guard.
07:52:28 <maerwald> merijn: https://gist.github.com/hasufell/337ce3f09221cc9905d2eb26f17ad396 ...so basically the stream has to be wrapped inside ResourceT. I don't see a way to make that more opaque
07:52:50 <maerwald> the inner monad of SerialT is the effects that are run during the step function
07:52:58 <maerwald> so that cannot hold the allocation
07:55:17 <unyu> Does anyone know what happened to the lens tutorial that was hosted on Skills Matter?
07:55:27 <dminuoso_> unyu: skillsmatter has gone into administration
07:55:29 <unyu> Errr, s/the lens tutorial/SPJ's lens talk/
07:55:30 <dminuoso_> unyu: try archive.org
07:55:39 <unyu> Ah, thanks.
07:55:52 <dminuoso_> unyu: Otherwise, try writing simon a mail
07:56:58 <unyu> He's probably busy. Besides, I could find the talk on a Chinese website called Bilibili. It is just... amusing that I could not find it on a website hosted in the West.
07:57:23 <dminuoso_> Well until 4 months ago, there was little reason to rehost it..
07:57:32 <maerwald> more opaque would probably just mean to newtype it I guess...
08:12:59 <zincy_> Is there a FromRow instance (postgres-simple) for a map data structure?
08:15:02 <dminuoso_> zincy_: What would that even do?
08:16:34 <zincy_> two columns one for the keys and the other would be a pg_array of things
08:16:59 <dminuoso_> zincy_: Just use the `FromField a, FromField b => FromRow (a, b)` instance and use Map.fromList
08:17:00 <zincy_> The instance would marshal this into a map of the keys in the first column and values which are lists of things
08:17:18 <zincy_> Ah thanks!
08:17:36 <zincy_> I also need to figure out what :. is fo
08:17:37 <zincy_> r
08:17:50 <dminuoso_> zincy_: `fromList <$> fromRow :: RowParser (Map K V)`
08:18:25 <zincy_> :)
08:18:30 <zincy_> Cheers
08:19:47 <dminuoso_> zincy_: You can also use queryWith
08:23:09 <dminuoso_> zincy_: (:.) is, internally, the same as (,)
08:23:50 <dminuoso_> zincy_: The difference is that FromRow (a,b) is for two *fields* a and b, whereas (:.) lets you combine two entire typeclass-based row parsers
08:25:55 <zincy_> ah gotcha
08:26:30 <dminuoso_> zincy_: Consider something like: traverse (\(User name age :. Group size) -> ...) $ query_ conn "SELECT user.*, group.* FROM ..." 
08:26:42 <dminuoso_> zincy_: In general I'd rather use queryWith with hand crafted parsers.
08:27:04 <dminuoso_> So you can do something like `(,) <$> parserUser <*> parserGroup`
08:35:01 <zincy_> nice I hadn't seen queryWith yet
08:40:36 <dminuoso_> Assume that this tuple has the type ([If], [If], [If], [If], [If]) in let (brs, ons, lags, virts, phys) = foldr (selectIf ifType) ([], [], [], [], []) interfaces
08:40:45 <dminuoso_> Is there some elegant way to ensure I dont mix things up?
08:41:23 <dminuoso_> (This is a 5 way/bucket partition that partitions a list of interfaces into an appropriate bucket, according to its type)
08:42:07 <dminuoso_> But the way this is done, it poses the risk of mixing up the names (that is, if I accidentally pass `ons` instead of `brs` - things will still typecheck)
08:43:04 <glguy> That could be improved with a record instead of a tuple to give each field a name that doesn't get mixed up with a bad pattern
08:43:20 <glguy> But it's not really a good candidate for types
08:45:54 * hackage git-repair 1.20200102 - repairs a damanged git repisitory  https://hackage.haskell.org/package/git-repair-1.20200102 (JoeyHess)
08:47:57 <dminuoso_> glguy: Mm For a while I was pondering about Tagged perhaps
08:48:07 <dminuoso_> With DataKinds and string literals
08:53:10 <kuribas> dminuoso_: use a record?
08:54:08 <kuribas> tuple blindness is similar to boolean blindness, or either blindness
08:54:48 <dminuoso_> kuribas: A record will not fix that, other than actually using Tagged (or separate newtypes) its impossible to keep track of the provenance
08:55:39 <kuribas> dminuoso_: not in the typesystem, but it makes it easier for the programmer
08:56:43 <kuribas> it's the same with having many similarly typed arguments for a function, you can then better define a datatype
08:56:48 <kuribas> a record
08:57:02 <kuribas> so you don't accidentally swap arguments
09:06:43 <olle> is there no easy way to convert a string to FilePath?
09:06:54 * hackage taskell 1.9.0.0 - A command-line kanban board/task manager  https://hackage.haskell.org/package/taskell-1.9.0.0 (smallhadroncollider)
09:07:02 <kuribas> :t FilePath
09:07:04 <dminuoso_> olle: String is a type alias for filePath
09:07:04 <lambdabot> error: Data constructor not in scope: FilePath
09:07:09 <dminuoso_> olle: So they are the same type
09:07:12 <kuribas> :i FilePath
09:07:23 <olle> Oh, that's neat!
09:07:55 <kuribas> they could have made it a newtype
09:08:03 <kuribas> that makes more sense
09:08:07 <dminuoso_> The GHC team is quite fond of type aliases. :o)
09:09:16 <kuribas> you mean in place of newtypes?
09:15:36 <zincy_> dminuoso: Having a bit of trouble with this FromRow for the map
09:15:39 <zincy_> https://pastebin.com/tgZQXUmX
09:16:08 <zincy_> Why am I expected to five a FromField instance?
09:16:30 <zincy_> Day and [ClassSummary] should be two separate fields in a row
09:20:56 <zincy_> Oh a list would have to be parsed from a single row not multiple rows
09:21:36 <zincy_> hence why fromList requires a field of a tuple of key value pair
09:21:44 <zincy_> This feels overly complexed
09:22:37 <zincy_> I simply would like to query my db for classes and group them by day
09:23:10 <zincy_> maybe I need to do more in haskell and less in SQL 
09:33:42 <erisco> What new lambdas have you been cooking up?
09:35:39 <kuribas> zincy_: I would keep it in SQL if it is more performant
09:38:35 <zincy_> kuribas: yeah i trust the sql query optimiser more than my haskell
09:39:02 <kuribas> zincy_: and you can save on bandwidth
09:39:16 <zincy_> juribas: how come?
09:39:33 <zincy_> sorry kuribas
09:39:41 <kuribas> by not having to send extra data
09:40:10 <zincy_> I would have thought it to be the same amount of data over the wire
09:40:57 <zincy_> but I am sure you generally save on bandwidth be erring towards doing stuff in the db
09:41:03 <kuribas> maybe I missed what you are doing in the DB...
09:41:30 <zincy_> Is there a way of parsing multiple rows with postgres-simple into a single value
09:42:41 <zincy_> This would be a solution to the problem of how do you encode a set of result rows which are the output of a GROUP BY  query
09:43:17 <zincy_> Say you have an aggregation in SQL sum a column and then group by day of the week
09:43:18 <kuribas> SQL is flat, but you can group using groupBy
09:43:28 <kuribas> :t groupBy
09:43:29 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
09:44:01 <zincy_> it is flat but I am thinking of cheating with json
09:44:22 <zincy_> so the first field would be day of the week 
09:44:48 <zincy_> the second field could represent denormalised data using json
09:45:24 * hackage ipfs 1.0.1 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.0.1 (expede)
09:45:40 <kuribas> you group the SQL by day, then use groupBy (comparing day)
09:45:50 <kuribas> (if day is your record field)
09:46:53 <zincy_> thanks
09:47:03 <zincy_> ill give that a shot!
09:50:15 <zincy_> Although what does the group by with day in sql do here? I am not sure what value it adds
09:51:18 <kuribas> zincy_: groupBy only groups adjacent elements
09:52:03 <kuribas> > groupBy (comparing (`mod` 3)) [1, 4, 7, 2, 5, 8, 3, 6, 9]
09:52:05 <lambdabot>  error:
09:52:05 <lambdabot>      • Couldn't match type ‘Ordering’ with ‘Bool’
09:52:05 <lambdabot>        Expected type: a -> a -> Bool
09:53:28 <iqubic> :t groupBy
09:53:30 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
09:53:53 <kuribas> > groupBy ((==) `on` (`mod` 3)) [1, 4, 7, 2, 5, 8, 3, 6, 9]
09:53:55 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
09:54:02 <kuribas> > groupBy ((==) `on` (`mod` 3)) [1..9]
09:54:04 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9]]
09:54:33 <kuribas> right, groupBy doesn't use Ordering, but Bool.
09:58:48 <zincy_> kuribas: ah right so it more performant when ordering is used as opposed to bool
09:59:00 <kuribas> zincy_: no
09:59:47 <kuribas> sortBy uses order, groupBy bool
09:59:48 <kuribas> :t sortBy
09:59:50 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
09:59:54 <kuribas> :t groupBy
09:59:55 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
10:00:20 <kuribas> zincy_: you need to do groupBy ((==) `on` day) for groupBy
10:09:19 <zincy_> cheers
10:12:54 * hackage mmsyn7ukr 0.4.2.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.4.2.0 (OleksandrZhabenko)
10:19:43 <siers> was there a way to do case with unit as the argument and then a list of boolean statements for each case? So not really like a case, but more like the "|" guard.
10:21:33 <pavonia> > case () of { _ | 1 > 2 -> "foo"; _ | 1 < 2 -> "bar" }
10:21:34 <lambdabot>  "bar"
10:21:48 <siers> nice
10:21:49 <dsal> > case () of _ | True -> "yes" | otherwise -> "no"
10:21:50 <lambdabot>  "yes"
10:22:57 <p0lyph3m> isnt multiwayif syntactic suger for just that case () - pattern
10:23:24 * hackage ats-pkg 3.4.0.8 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.4.0.8 (vmchale)
10:24:52 <dsal> % if | True -> "yes" | otherwise -> "no"
10:24:52 <yahb> dsal: "yes"
11:26:24 * hackage minio-hs 1.5.2 - A MinIO Haskell Library for Amazon S3 compatible cloudstorage.  https://hackage.haskell.org/package/minio-hs-1.5.2 (MinioDevTeam)
11:30:20 <siers> How do I get the id of a field from groundhog?
11:32:24 * hackage rdf4h 4.0.0 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-4.0.0 (RobStewart)
11:59:24 * hackage gothic 0.1.3 - A Haskell Vault KVv2 secret engine client  https://hackage.haskell.org/package/gothic-0.1.3 (MichelBoucey)
12:03:46 <oats> could I get some criticism of my solution for AoC day 12 solution? https://paste.xinu.at/tVsRFaO/hs
12:04:43 <oats> I may have overdone it with arbitrary-dimensional moons
12:04:50 <oats> but it made my code for part 1 reusable :P
12:13:01 <glguy> I also generalized to n dimensions
12:14:13 <glguy> https://github.com/glguy/advent2019/blob/master/execs/Day12.hs
12:26:19 <fendor> can I get at compile-time the version of a package that I depend on?
12:26:56 <merijn> Yes
12:27:06 <cocreature> fendor: yes, via CPP, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#standard-cpp-macros
12:27:07 <merijn> Via CPP at leas
12:27:15 <fendor> merijn, cocreature thank you! 
12:28:24 * hackage filepath-bytestring 1.4.2.1.6 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.6 (JoeyHess)
12:39:54 * hackage google-oauth2-jwt 0.3.2 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.3.2 (MichelBoucey)
12:51:54 * hackage ip6addr 1.0.1 - Commandline tool to deal with IPv6 address text representations  https://hackage.haskell.org/package/ip6addr-1.0.1 (MichelBoucey)
12:58:54 * hackage esqueleto 3.3.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.1 (parsonsmatt)
13:03:54 * hackage IPv6DB 0.3.2 - A RESTful microService for IPv6-related data  https://hackage.haskell.org/package/IPv6DB-0.3.2 (MichelBoucey)
13:10:41 <dsal> fo/me is writing rank-n haskell code to interface with rank-n c++ code to do something that should've been designed better
13:10:54 * hackage glabrous 2.0.1 - A template DSL library  https://hackage.haskell.org/package/glabrous-2.0.1 (MichelBoucey)
13:11:28 * dsal apparently has an irc client that doesn't understand fo/me
13:13:17 <geekosaur> fo/me stuff possibly doesn't belong on irc in general…
13:20:24 * hackage cayley-client 0.4.10 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.4.10 (MichelBoucey)
13:30:01 <siers> do you filter your irc join/quits?
13:30:27 <geekosaur> many do. I don't
13:31:04 <siers> I wonder whether questions are worth repeating on the count that joins pushed them outside the visible part of the buffera
13:31:07 <siers> *-s
13:31:31 <siers> although personally I still see my question :D
13:42:42 <dsal> It's more of a factor of time, I think.  I don't tend to join or leave and I don't always read all of the messages I missed if things have been busy.
13:43:46 <Guest10409> Hi dsal. Forget OOP
13:44:50 <dsal> OK
13:45:04 <amalloy> i'm aware of /me, but i've never heard of fo/me. what is that about?
13:45:55 <Guest10409> Hi amalloy. Forget OOP
13:46:11 <dsal> I was deep in some code.  Came back to irc and typed that.  Apparently  something stuck a 'fo' in my buffer first.
13:46:37 <amalloy> Guest10409: knock it off, please
13:53:41 * olle
13:54:58 <glguy> Is that greeting automatic?
13:59:49 <Guest10409> Hi glguy Forget OOP
14:00:46 --- mode: ChanServ set +o monochrom
14:00:51 --- mode: monochrom set +b *!*@lstlambert-656-1-44-4.w92-154.abo.wanadoo.fr
14:00:51 --- kick: Guest10409 was kicked by monochrom (Guest10409)
14:01:05 <evelyn> it's obvioulsy not a bot because it forgot a full-stop the third time
14:01:09 --- mode: monochrom set -o monochrom
14:01:58 <monochrom> And I receive that in PM
14:02:32 <monochrom> (after the kickban)
14:02:53 <solonarv> sometimes I wonder what goes through people's heads.
14:03:05 <johnw> well, OOP for one
14:03:12 <johnw> else the request would not be made
14:03:35 <monochrom> Chinese Room is what happens to people's heads.
14:03:49 <zeta_0> zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
14:03:49 <zeta_0> zipWith' _ [] _ = []
14:03:49 <zeta_0> zipWith' _ _ [] = []
14:03:49 <zeta_0> zipWith' f (a:as) (b:bs) = f a b : zipWith' f as bs
14:04:16 <zeta_0> what does this mean implementation mean?
14:04:18 <zeta_0> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
14:04:40 <monochrom> What does "mean" mean? What kind of answer are you looking for?
14:04:59 <dmwit> Which bit(s) of it are especially hard for you to understand?
14:05:10 <amalloy> zeta_0: try working through the types, and when you get to a specific part that's confusing that'd be a better question
14:05:54 * hackage lightstep-haskell 0.5.0 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.5.0 (DmitryIvanov)
14:06:54 <zeta_0> i understand the function definition fine, i already worked through some example implementations, its just this one that is confusing me? zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
14:08:57 <monochrom> Then you should have probably noticed that zipWith' g [t,u,v] [x,y,z] = [g t x, g u y, g v z].  If not, go back to square one.
14:09:39 <monochrom> But if yes, then you're merely looking at g = zipWith' (*), t = [1,2,3], x = [3,2,2], etc.  So plug and chug, and keep doing it.
14:10:56 <zeta_0> the inner (zipWith' (*)) is tripping me out, is it just a partial application?
14:11:05 <monochrom> Yes.
14:12:53 <zeta_0> [[3,4,6],[9,20,30],[10,12,12]]
14:13:48 <dsal> zeta_0: What's the type of the first argument to zipWith' ?
14:14:04 <zeta_0> ok, so it multiplies the 2 parameters according to their corresponding order, guess i am a little confused of how to function traverses through list of lists
14:14:36 <monochrom> Yes, wordy mental models are always confusing.
14:14:57 <zeta_0> dsal: the type of the 1st parameter is a function right
14:15:10 <dsal> Your definition above says (a -> b -> c)
14:15:15 <monochrom> I don't care about wordy "explanations" such as "function taking a function parameter" or "list of list" etc.  Just plug and chug.
14:15:35 <dsal> Yes, try plugging and/or chugging.
14:15:53 <dsal> Step 1:  Accept that the mechanism is quite simple.  Once you accept it, you can try it and you'll realize the answer is:  "Oh."
14:17:43 <zeta_0> so the second zipWith is to get into the `inner` lists right?
14:18:38 <zeta_0> the other examples that i worked through were easy to understand, but for some reasion this example is tripping me out
14:18:48 <dsal> You can use ghci to help you take apart/name the types sometimes.
14:20:02 <zeta_0> zipWith' (*) :: forall c. Num c => [c] -> [c] -> [c]
14:20:08 <dsal> You could also just manually evaluate the first term before you recurse.
14:20:17 <dsal> :t zipWith (zipWith (*))
14:20:18 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
14:20:55 <zeta_0> dsal: oh, so the function is recursively calling itself?
14:21:06 <dsal> Your definition of zipWith does.
14:21:20 <dmwit> zipWithA (zipWithB (*)) [[a,b,c],[d,e,f]] [[g,h,i],[j,k,l]] = [zipWithB (*) [a,b,c] [g,h,i], zipWithB (*) [d,e,f] [j,k,l]]
14:21:24 * hackage musicw 0.3.2 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.2 (dktr0)
14:21:47 <dmwit> = [[a*g, b*h, c*i], [d*j, e*k, f*l]]
14:22:29 <zeta_0> ok, it is starting to make some more sense, thanks guys
14:26:24 * hackage lightstep-haskell 0.5.1 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.5.1 (DmitryIvanov)
14:39:09 <dmwit> > zipWith g [[a,b,c],[d,e]] [[u,v,w],[x,y]] :: [Expr]
14:39:12 <lambdabot>  [g [a,b,c] [u,v,w],g [d,e] [x,y]]
14:39:36 <dmwit> > let g = zipWith f in zipWith g [[a,b,c],[d,e]] [[u,v,w],[x,y]] :: [[Expr]]
14:39:39 <lambdabot>  [[f a u,f b v,f c w],[f d x,f e y]]
14:40:10 <dmwit> (Is this useful? I don't know. But it would have saved me some typing in my explanation. =P)
14:44:54 <zeta_0> oh it takes the heads of the list of lists, which are the 2 inner lists, then recursively takes the head of the list then multiplies them together, then recursively applies the functions to the tails, doing the process again until the base conditions are reached?
14:48:15 <zeta_0> dmwit: i am understanding bits and pieces here and there
14:49:29 <dsal> I don't think I'd use "recursively" so much.  dmwit's example named the two zips differently which may reduce confusion.
14:49:53 <dsal> You happen to be giving it the same function for an inner invocation, but it doesn't know that.
14:50:00 <nil> zipWith :: (a -> b -> c) -> ([a] -> [b] -> [c]) ; zipWith . zipWith :: (a -> b -> c) -> ([[a]] -> [[b]] -> [[c]])
14:51:02 <nil> much like  map :: (a -> b) -> ([a] -> [b]) ; map . map :: (a -> b) -> ([[a]] -> [[b]])
14:51:37 <dsal> I've been using fmap.fmap and fmap.fmap.fmap a bit lately.
14:51:49 <nil> (replace map with fmap and zipWith with liftA2 for a more general setting)
15:00:23 <zeta_0> ok, i understand it well enough, thanks guys, time to go to the next piece of code
15:24:24 <oats> :t liftM2
15:24:26 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:26:14 <oats> > liftA2 (+) [1..5] [5..10]
15:26:17 <lambdabot>  [6,7,8,9,10,11,7,8,9,10,11,12,8,9,10,11,12,13,9,10,11,12,13,14,10,11,12,13,1...
15:26:26 <oats> not quite the same :P
15:26:47 <oats> > zipWith (+) [1..5] [5..10]
15:26:50 <lambdabot>  [6,8,10,12,14]
15:27:21 <solonarv> oats: practically speaking, liftM2 is just liftA2 with a silly overly-specific constraint
15:27:26 <solonarv> most of the time anyway
15:28:29 <solonarv> and zipWith actually would be a valid implementation of liftA2!
15:29:03 <solonarv> however, the actual implementation of liftA2 for [] is a different one, because it has to be compatible with the Monad [] instance and zipWith wouldn't be
15:31:33 <oats> ah
15:31:41 <oats> I don't like the idea of zipWith as liftA2
15:31:45 <oats> that makes me uncomfy :P
15:32:38 <solonarv> why is that?
15:33:18 <solonarv> it's a perfectly reasonable implementation (note that if liftA2 = zipWith, pure has to be 'repeat')
15:33:55 <solonarv> it's available via the ZipList newtype, btw
15:34:01 <oats> I guess it doesn't break any applicative laws
15:36:15 <solonarv> indeed, that's why it is a valid implementation
15:38:03 <dmwit> (And other implementations are possible, too.)
16:08:12 <iqubic> > replicate (4^100) 1
16:08:14 <lambdabot>  []
16:08:26 <iqubic> Why is that giving me an answer of []?
16:08:46 <hpc> > 4^100
16:08:48 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
16:08:54 <hpc> :t replicate
16:08:55 <lambdabot> Int -> a -> [a]
16:08:58 <Axman6> > maxBound :: Int
16:09:00 <lambdabot>  9223372036854775807
16:09:04 <hpc> > 4^100 :: Int
16:09:06 <lambdabot>  0
16:09:11 <iqubic> I see.
16:09:19 <hpc> the funny thing is, if you didn't use 4
16:09:24 <hpc> if you used 3 or 5 or something
16:09:26 <hpc> it'd work
16:09:53 <hpc> 4^100 at some point gains a factor of 2^64
16:09:53 <Axman6> "work"
16:09:57 <hpc> > 2^64 :: Int
16:10:00 <lambdabot>  0
16:10:12 <hpc> heh yeah, it still wouldn't be as long as you hope
16:10:21 <iqubic> Will "replicateM 100 [1..4]" work in the way I want it too? Or will the resulting list still be way way too long?
16:10:26 <hpc> but maybe it lands somewhere on the "really big" side of the 64-bit space
16:10:41 <hpc> what output do you want?
16:10:45 <Axman6> > length $ replicateM 100 [1..4]
16:10:51 <lambdabot>  mueval-core: Time limit exceeded
16:11:12 <amalloy> iqubic: you will have a difficult time using the result of that replicateM call, even if it is technically a totally fine value
16:11:29 <iqubic> amalloy: Yeah, that's what I'm starting to think.
16:12:04 <iqubic> Looks like I need to be a bit more clever on Advent of Code 2015, Day 15, Part 1.
16:12:05 <amalloy> like, 10^60 is a lot of elements to process. you will never get to the last one before the sun burns out
16:12:22 <iqubic> https://adventofcode.com/2015/day/15
16:12:34 <iqubic> Right... So that's not going to work at all.
16:13:48 <amalloy> 100^4 looks like a better naive model of this than 4^100 anyway?
16:14:14 <iqubic> Why do you say that?
16:14:29 <amalloy> what 100 things are you making 4 choices each about?
16:14:37 <iqubic> I have been given 4 ingredients in my input.
16:14:52 <iqubic> amalloy: You are absolutely right.
16:15:38 <amalloy> there is obviously still room for a lot of improvement beyond 100^4, but that number is small enough you could brute force it
16:16:09 <iqubic> But even if I do replicateM 3 [1..4], I'll still get things like "[1,2,1]", "[1,1,2]" and "[2,1,1]" which are equivalent, as far as the puzzle goes.
16:16:37 <iqubic> So there's probably a better way to do this.
16:17:15 <amalloy> why are those equivalent?
16:17:36 <amalloy> XXYZ is not the same as XYYZ
16:18:24 <iqubic> Right. But XXY, XYX, and YXX are all equivalent though. And the naive replicateM solution would get me all three of those.
16:19:26 <amalloy> oh, you're planning to, 100 times, choose one of the 4 ingredients? well yes, then you would have 4^100 choices, and not enough time
16:19:30 <amalloy> i advise you don't do it that way
16:19:37 <iqubic> Yes. I was planning on doing that.
16:19:58 <amalloy> try 4 times choosing a number between 1 and 100
16:20:03 <amalloy> well, 0 and 100
16:20:04 <MarcelineVQ> now to learn the simplex algorithm
16:21:42 <amalloy> yes, you could start with a course on linear algebra
16:22:38 <iqubic> Me? But this Advent of Code. It should be simple.
16:23:09 <amalloy> that's why i suggested a simple approach. MarcelineVQ's suggestion is a different one
16:23:40 <iqubic> What does MarcelineVQ think I should do?
16:23:50 <hpc> AoC can be a simple passtime, or it can give you direction to learn interesting things
16:24:16 <iqubic> I'd like to learn things today.
16:24:57 <amalloy> iqubic: did you read the message? MarcelineVQ suggested learning the simplex algorithm, which afaict is an algorithm that applies nicely to this but requires more linear algebra than i know to be sure
16:29:39 <iqubic> I'm not sure how linear programming helps me here.
16:29:56 <hpc> it's an optimization problem
16:30:06 <iqubic> I don't really know what linear programming is. I guess it's time for me to learn.
16:30:14 <hpc> you have an equation (sum of ingredients = 100)
16:30:59 <hpc> and you have a variety of equations that end up defining the score
16:31:05 <iqubic> And I have a fromula that gives me the 'score' for that chosen set of ingredients.
16:31:14 <hpc> the whole thing is a system of linear equations, and the variables are the ingredients
16:31:23 <iqubic> Right. I'll look into this.
16:34:01 <hpc> this is probably something i should work into my own brain's muscle memory as well, i know it at a high level but haven't ever implemented any of the algorithms
16:34:29 <hpc> except maybe if you count neural networks as approximating it?
16:34:39 <hpc> iirc they solve linear systems if you only have one layer
16:36:24 <MarcelineVQ> this is a little harder too since it's an integer programming problem instead of linear programming problem
16:37:19 <hpc> oh ugh, right
16:37:33 <iqubic> Right. All the inputs here are integers.
16:38:00 <anonymous8> hell oiqubic 
16:38:05 <iqubic> I need an integer amount of each ingredient. Could be 0 for some ingredients.
16:39:12 <hpc> i don't think it changes much for simplex
16:40:33 <MarcelineVQ> if you're lucky you can use linear techniques and the inputs they have for the exercise will work out anyway
16:41:00 <MarcelineVQ> and there's LP libs for haskell you can use instead of writing your own
16:42:02 <iqubic> Nice.
16:42:12 <iqubic> What libraries do you recommend?
16:42:27 <MarcelineVQ> dunno never used any, my adivce is to find one with examples
16:44:29 <hpc> https://hoogle.haskell.org/?hoogle=linear%20is%3Apackage is a good place to start
16:45:40 <hpc> linearEqSolver might make it too easy?
16:46:57 <MarcelineVQ> careful, you'll summon shapr at this rate
16:47:03 <shapr> WHAT?
16:47:08 <MarcelineVQ> using SMT to bodangle linear things
16:47:11 <shapr> oh yeah!
16:47:28 <shapr> I learned a bunch from digging into SMT solvers
16:47:42 <shapr> but mostly I learned I don't know enough other solvers.
16:47:48 <hpc> what are linear things for, if not bodangling
16:47:49 <shajra> What's a common reason that cabal.project.local would be not just an empty file?
16:48:06 <shapr> My problem was easily solved with integer linear programming, but I didn't know about ILP before I tried the problem.
16:48:54 <iqubic> shapr: My current problem is this: https://adventofcode.com/2015/day/15
16:49:00 <iqubic> If you care to look at it.
16:49:13 <iqubic> My particular input has 4 ingredients.
16:50:14 <hpc> if it's that few, you could definitely just get an exact solution, then try the hypercube of integer coordinates around it
16:50:35 <iqubic> What?!? How would that work?
16:50:45 <adamCS> shajra: You could put local config--compiler choice, number of concurrent jobs--there.  Also, when you tell cabal configure to enable profiling, I think it puts those flags there.
16:51:23 <hpc> so say your exact optimum is something like (25.3, 18.7, 5.6, 4.2) or whatever
16:51:38 <shajra> adamCS: I'm never to touch cabal.project.local, right?  I was under the impression Cabal-install managed it directly, right?
16:51:56 <hpc> you can sample [(x, y, z, w) | x <- [25, 26], y <- [18, 19], z <- [5, 6], w <- [4, 5]]
16:52:12 <iqubic> Oh, yeah. That makes sense.
16:52:23 <hpc> oh wait, that doesn't quite work
16:52:26 <hpc> always, anyway
16:52:39 <adamCS> shajra: I guess.  But I don't think things will go very wrong if you do. Why?
16:52:48 <iqubic> Why doesn't that always work?
16:53:09 <shajra> adamCS: actually, I see that now... it's just a file that saves flags passed to `cabal configure`.
16:53:11 <hpc> imagine solving it in two dimensions, and you get a triangle sort of shape
16:53:22 <iqubic> Right.
16:53:41 <hpc> it's super narrow, such that near the tip where the optimum is, there aren't any integer coordinates that are even inside the shape
16:53:42 <adamCS> shajra: yep.  But they can be overwritten by "cabal configure" and they are usually not pushed to git or whatever.
16:53:48 <hpc> that kind of thing can happen
16:53:52 <iqubic> Ah. I see.
16:54:09 <iqubic> So I really do need to restrict this to an integer domain.
16:54:24 <shajra> adamCS: it was just always a blank file for me because I'm not often messing around with profiling... just normal building.
16:54:37 <iqubic> This really seems like the kind of thing that prolog would be good for.
16:55:28 <hpc> i think it's gotta be something more like SMT than simplex
16:55:49 <iqubic> Yeah. That sounds right.
16:56:02 <solonarv> shajra: it's fine to modify it by hand, IIRC the docs even say something like "after running cabal configure, you might want to edit cabal.project.local some more"
16:56:20 <solonarv> just remember that running cabal configure will overwrite it again
16:56:30 <hpc> wikipedia describes the scenarios where simplex still works, but it's blue text word salad
16:56:31 <solonarv> (my solution is to just hand-write it in the first place :>(
16:57:32 <shajra> solonarv: not the best UX... best to have yet another file for user-managed configuration... or at least a comment marker to put the auto-generated stuff at the bottom.
16:57:36 <iqubic> solonarv: Is that a comment directed to me?
16:58:19 <solonarv> iqubic: no, nothing I said was directed at you
16:58:56 <iqubic> I see.
17:32:00 <iqubic> Are there any native haskell SMT solvers, or do all of the good SMT libraries use FFI?
17:34:13 <AfricanMan> Ching Chong Ping Pong, It is not meant to be racist I just like the sound.
17:34:38 <mikail> wtf
17:44:31 <oats> is this channel +r?
17:46:55 <oats> m, it is not
17:47:06 <oats> +r might help with that kind of spam
17:49:31 <AfricanMan> I am sorry but the ping pong has another meaning in my language.
17:49:47 <oats> ._.
17:50:50 <amalloy> oats: the amount of spam is relatively low, and +r often deflects inexperienced IRC users who genuinely want to participate
17:50:59 <oats> fair enough
17:53:55 <MarcelineVQ> That and it's funny
17:57:58 <phanimahesh[m]> Do you mean channel mode +R?
17:58:25 <adamCS> MarcelineVQ: The spam that is racist, etc. is offensive and may discourage some people from participating.  So, regardless of whether anyone finds it funny, it'd be good if the community supported the people being disparaged and discouraged the spam...
17:58:54 <MarcelineVQ> Something was racist?
17:59:24 * hackage core-program 0.2.3.0 - Opinionated Haskell Interoperability  https://hackage.haskell.org/package/core-program-0.2.3.0 (AndrewCowie)
17:59:31 <phanimahesh[m]> The +r mode can only be set by services itself and indicates that the channel in question is registered with ChanServ. This mode has been removed.
17:59:31 <phanimahesh[m]> +R stands for registered nicknames only. As its name implies, only those who are using and have identified to their current nickname (in other words, those who are set to umode +r) are allowed to enter the channel.
18:00:24 * hackage core-text 0.2.2.6 - A rope type based on a finger tree over UTF-8 fragments  https://hackage.haskell.org/package/core-text-0.2.2.6 (AndrewCowie)
18:00:51 <adamCS> MarcellineVQ: I think the odds are that any statement which precedes "It is not meant to be racist but..." has a pretty good chance of being somehow offensive or racist.
18:01:01 <adamCS> MarcelineVQ: ^
18:01:33 <nshepperd2> it's +r on freenode https://freenode.net/kb/answer/channelmodes
18:02:07 <MarcelineVQ> idk man, that sounds like a scary position to hold. like, I'm not a nazi but I do like The Sound of Music. does the I'm not a nazi part mean I'm a nazi?
18:02:07 <phanimahesh[m]> Great. I thought irc modes are standardized and common?
18:02:35 <nshepperd2> nothing is standardized on irc it seems
18:02:56 <phanimahesh[m]> It does get ridiculous when taken to the extreme but without being targeted it's hard to understand what is and isn't racist
18:03:39 <phanimahesh[m]> Some people prefer to censor everything potentially racist. I see the logic but I don't like it either.
18:05:11 <phanimahesh[m]> Sometimes the rules are complex. What we think of as racist may not be and vice versa. Some people may laugh it off or pretend to while feeling bad privately.
18:05:17 <phanimahesh[m]> It's a complex topic.
18:05:22 <nshepperd2> it's obviously trolling which is off topic in any case
18:05:45 <phanimahesh[m]> Let's stick to simpler stuff like mind bending Type Tetris.
18:05:58 <phanimahesh[m]> Agreed. That person was trolling.
18:06:27 <WeeOooWee> Tao Tao take notes from my Kung Pao
18:06:48 <MarcelineVQ> I wish trolling didn't lose its meaning as a word. Now it's just like 'literally', which literally means figuratively now.
18:06:48 <phanimahesh[m]> What the
18:08:39 <phanimahesh[m]> We have some socially maladjusted person trying to feel important by getting a rise out of people.
18:09:15 <phanimahesh[m]> What do you mean the pile of candy wasn't literally taller than everest?
18:09:26 <phanimahesh[m]> I've been bamboozled
18:10:15 <phanimahesh[m]> How do you people do docker builds for Haskell stuff?
18:10:48 <phanimahesh[m]> The build times are horrendous when I start from scratch
18:11:32 <phanimahesh[m]> I thought fpco/stack-build had hackage stuff precompiled and available but apparently nope. Stack builds all deps.
18:12:06 <phanimahesh[m]> Did I misunderstand?
18:12:53 <solonarv> I don't know docker very well, but you should be able to set up a docker image with all the dependencies already installed and then just use that as a starting point, rather than a blank slate?
18:13:26 <solonarv> all the stuff you need to cache should live in ~/.stack (by default)
18:13:53 <iqubic> So, are there any native Haskell SMT/SAT solvers or not? Will I have to grab on that does FFI, and make sure to get the right external dependency too?
18:15:28 <mniip> hmm
18:15:37 <mniip> what's a free cartesian category look like
18:16:37 <iqubic> This might help: https://ncatlab.org/nlab/show/free+cartesian+category
18:18:08 <mniip> hmm so objects are like multisets of Ob(C)
18:18:20 <mniip> implemented by functions X -> Ob(C) for varying X
18:26:48 <a1c`> > partition (`elem` "AB") "BOBsidneyMORGANeddy"
18:26:50 <lambdabot>  ("BBA","OsidneyMORGNeddy")
18:27:13 <a1c`> :t elem
18:27:15 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
18:27:29 <a1c`> why this `elem` "AB" work?
18:28:18 <oats> :t partition
18:28:19 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:29:03 <oats> :t `elem` ['A', 'B']
18:29:05 <lambdabot> error: parse error on input ‘`’
18:29:19 <oats> :t (`elem` ['A', 'B'])
18:29:20 <phanimahesh[m]> Turns out the build server has caching disabled.
18:29:21 <lambdabot> Char -> Bool
18:29:59 <oats> a1c`: (`elem` "AB") is the partitioning function here, it checks if its argument is in the list ['A', 'B']
18:30:21 <oats> > partition even [1..10]
18:30:24 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
18:30:52 <a1c`> oats: what this `elem` means? I know ` ` can use for infix expression
18:31:00 <oats> :t elem
18:31:01 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
18:31:12 <oats> elem will tell you if an element is in a foldable :)
18:31:23 <oats> > elem 5 [1,5,9]
18:31:26 <lambdabot>  True
18:31:42 <a1c`> > `elem` 5 [1,5,9]
18:31:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘`’
18:31:57 <a1c`> oats: why ` ` in that expression
18:32:01 <oats> ahhh
18:32:11 <oats> you're using elem as infix
18:32:19 <oats> so you're partially applying the second argument
18:32:29 <oats> full infix:
18:32:36 <oats> > 5 `elem` [1,5,9]
18:32:38 <lambdabot>  True
18:32:58 <a1c`> but in partition (`elem` "AB") "BOBsidneyMORGANeddy"  
18:33:03 <a1c`> what's the infix?
18:33:09 <solonarv> (`elem` abc) is the same thing as (\x -> x `elem` abc), which is the same thing as (\x -> elem x abc)
18:33:13 <a1c`> `elem` star in the first
18:33:28 <oats> a1c`: are you familiar with partial function application?
18:34:05 <a1c`> oats: what kind you mean?
18:34:11 <a1c`> oats: currying?
18:34:14 <oats> yeah
18:34:27 <a1c`> oats: I know that
18:34:40 <oats> (a `f` b) == (f a b)
18:34:44 <oats> so if you omit argument a
18:34:58 <oats> (`f` b) == (\a -> f a b)
18:35:29 <oats> and the types reflect this
18:35:30 <a1c`> but f a = \b -> f a b
18:35:37 <oats> :t `elem` [1..5]
18:35:39 <lambdabot> error: parse error on input ‘`’
18:35:52 <oats> a1c`: correct
18:36:02 <solonarv> but there is no (f a) here
18:36:03 <a1c`> oats: the position changed, f a = \b -> f a b, not  f a = \b -> f b a
18:36:07 <solonarv> there is onle (`f` a)
18:36:22 <solonarv> the `` are not decoration!
18:36:47 <oats> a1c`: in infix notation, the argument on the right side is the second argument of the function, not the first.
18:36:47 <a1c`> wait a sec, is that a `f` b = b `f` a?
18:36:54 <oats> a1c`: nope
18:37:42 <oats> well, if the function is commutitive, it is
18:37:43 <oats> but not all are
18:38:02 <a1c`> oats: `f` a, so a is the second parameter?
18:38:08 <oats> yes
18:38:15 <oats> :t elem
18:38:17 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
18:38:21 <a1c`> `f` a = \b -> b `f` a
18:38:23 <oats> :t (`elem` [1..5])
18:38:25 <lambdabot> (Eq a, Num a, Enum a) => a -> Bool
18:38:31 <oats> a1c`: correct
18:38:51 <a1c`> oats: oh, I see, 
18:39:11 <a1c`> eta-convertion 
18:40:16 <oats> > (`elem` 5) [1..5]
18:40:18 <lambdabot>  error:
18:40:18 <lambdabot>      • No instance for (Num [[Integer]]) arising from the literal ‘5’
18:40:18 <lambdabot>      • In the second argument of ‘elem’, namely ‘5’
18:40:28 <oats> oops, got that backwards
18:40:33 <oats> > (`elem` [1..5]) 5
18:40:36 <lambdabot>  True
18:40:49 <oats> > elem 5 [1..5]
18:40:51 <lambdabot>  True
18:41:42 <oats> a1c`: does it make sense now?
18:41:56 <a1c`> oats: but wait, partition (`elem` "AB") "BOBsidney.."  this ['A','B'] is the second parameter, the first parameter need to be 'a' 
18:42:08 <a1c`> not [Char]
18:42:23 <a1c`> :t partition
18:42:26 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:42:37 <a1c`> oh, I see
18:42:43 <oats> :t partition (`elem` "AB")
18:42:44 <lambdabot> [Char] -> ([Char], [Char])
18:42:59 <oats> (`elem` "AB") :: (Char -> Bool)
18:43:35 <a1c`> oats: but this should split "AB"
18:43:42 <a1c`> oats: not "BOBsid..."
18:44:02 <a1c`> > partition (>3) [1,2,5,6]
18:44:04 <lambdabot>  ([5,6],[1,2])
18:44:21 <divVerent> flip f x = (`f` x)
18:44:28 <divVerent> an obscure mandatory parenthesis :)
18:45:02 <oats> a1c`: sorry, I'm confused. What is the behavior you're expecting from the function?
18:46:10 <a1c`> oats: partition (`elem` "AB") "BOBsidneyMORGANeddy", I see, now
18:46:30 <a1c`> oats: it filters A and B character from this string
18:47:27 <oats> do you want to just filter out the A and B characters, or separate the A and B characters from the non-A-and-B characters?
18:47:29 <a1c`> partition put 'B' from "BOB..." to `elem` "AB" to check if it's true, if it's true then put in the left, then 'O', then 'B'...
18:47:51 <a1c`> true, put into the left, false, put into the right
18:48:19 <oats> partition (`elem` "AB") "ABCABCD"
18:48:25 <oats> > partition (`elem` "AB") "ABCABCD"
18:48:29 <lambdabot>  ("ABAB","CCD")
18:49:04 <a1c`> > partition (`elem` "AB") "CD"
18:49:06 <lambdabot>  ("","CD")
18:49:20 <oats> is that not the behavior you were wanting?
18:49:32 <a1c`> oats: it is, now
18:49:36 <oats> ok then :)
18:49:50 <a1c`> oats: thanks
18:50:02 <oats> hope I didn't just make things foggier :P
18:51:31 <a1c`> oats: is there another way to do this?
18:51:53 <oats> well, you could probably do it with a fold
18:52:31 <a1c`> oats: what about filter?
18:52:35 <a1c`> or takeWhile
18:52:47 <a1c`> fold is reduce, right?
18:52:50 <iqubic> a1c`: Those two functions do different things.
18:52:54 <iqubic> And yes, fold is reduce.
18:52:54 <oats> well, they would behave differently
18:53:14 <oats> > filter (`elem` "AB") "ABCABCD"
18:53:16 <lambdabot>  "ABAB"
18:53:34 <oats> > takeWhile (`elem` "AB") "ABCABCD"
18:53:37 <lambdabot>  "AB"
18:54:26 <a1c`> oats: no elem, filter with others
18:54:53 <oats> I'm not sure I understand what your goal is
18:54:58 <oats> could you elaborate?
18:55:34 <oats> > foldl (\(l,r) c -> if elem c "AB" then (c:l,r) else (l,c:r)) ("","") "ABCABCD"
18:55:36 <lambdabot>  ("BABA","DCC")
18:55:46 <a1c`> filter 'A' and 'B' character from a string to ("ABAB", non-"AB"-string)
18:56:57 <oats> @pl \c -> c == 'A' || c == 'B'
18:56:58 <lambdabot> liftM2 (||) ('A' ==) ('B' ==)
18:57:05 <oats> eh
18:57:08 <MarcelineVQ> you've already done that with partition, there's other ways to do it but you'll just be re-writing partition
18:57:29 <a1c`> ok
18:57:31 <oats> a1c`: do you have a constraint keeping you from using 'elem'?
18:57:43 <a1c`> oats: no, I just wonder
18:57:49 <oats> fair enough :)
18:58:35 <oats> I cannot think of a simpler way to express it than 'partition (`elem` "AB")'
19:02:08 <a1c`> oats: what's the simple way to split a string like "ABCDEF" to ("AB", "CD","EF") with "CD"?
19:02:26 <a1c`> split a string with a string
19:02:30 <oats> probably the "split" library
19:02:50 <a1c`> :t split
19:02:52 <lambdabot> Splitter a -> [a] -> [[a]]
19:02:58 <oats> :t splitOn
19:02:59 <lambdabot> Eq a => [a] -> [a] -> [[a]]
19:03:20 <oats> splitOn "CD" "ABCDEFGHIJCDKL"
19:03:28 <oats> > splitOn "CD" "ABCDEFGHIJCDKL"
19:03:31 <lambdabot>  ["AB","EFGHIJ","KL"]
19:03:42 <a1c`> ok
19:03:54 <oats> hmm, you want the "CD"s
19:03:55 <a1c`> > splitOn "CD" "AB"
19:03:57 <lambdabot>  ["AB"]
19:09:03 <Tao> You see Tao Yau the Topologists have some beautiful techniques. You can prove that some theories are wrong. I am figuring this out right now. They are monitoring me...the Uber German Jews are good...
19:09:38 <monochrom> haha
19:09:39 <oats> sounds like some markov shit
19:10:25 <monochrom> Santa Claus is monitoring me too.  I'm on his good list. :)
19:10:41 <monochrom> Err, nice list!
19:12:03 <Tao> They are really good.
19:12:23 <oats> lolwat
19:13:03 <MarcelineVQ> fwiw if you don't like that it is the same ip each time. I think it's funny though.
19:13:05 <dmwit> Perhaps we can just let this episode pass without further comment. Wouldn't that be nice?
19:13:15 --- mode: ChanServ set +o monochrom
19:13:45 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.70.124.161.118
19:13:53 --- mode: monochrom set -o monochrom
19:15:27 <oats> gets (partition (== "monochrome") . view nices) >>= (\(m, ns) -> modify (set nices ns) >> modify (over naughtys (++ m)))
19:16:53 <solonarv> don't you know lens has MonadState operators? :>
19:17:17 <oats> shit, really?
19:17:22 <solonarv> yup!
19:17:26 <oats> I could've used that for my intcode vm :P
19:17:34 <solonarv> I did, it was very convenient
19:17:34 <oats> where do I find these
19:17:39 <oats> I am a lens fledgling
19:17:54 <solonarv> same place as the other operators
19:18:00 <iqubic> It's really helpful to use those operators.
19:18:22 <iqubic> oats: The stateful operators usually end in =.
19:18:30 <solonarv> but the quick answer is: for every xx~ operator that works as a plain old function, there is a xx= that works in MonadState
19:18:57 <iqubic> Yes. That's the right way of putting it.
19:19:42 <oats> :t assign
19:19:44 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
19:20:00 <oats> mmmmm
19:20:03 <iqubic> And then you have "use l = gets (view l)"
19:20:05 <iqubic> :t use
19:20:07 <lambdabot> MonadState s m => Getting a s a -> m a
19:20:17 <oats> hot damn
19:20:27 <oats> this simplifies a lot of stuff
19:20:44 <iqubic> So you can do "ip <- use instrpoint"
19:21:02 <solonarv> so: partition (== "monochrom") <$> use nices >>= \(m, ns) -> do nices .= ns; naughtys %= (++ m)
19:21:11 <iqubic> Where instrpoint is a lens into the position of the instruction pointer.
19:21:13 <digifox03> hello, can someone help me with pattern matching?
19:21:16 <oats> we are not worthy of `lens`
19:21:27 <oats> digifox03: no need to ask to ask, fire away :)
19:21:30 <solonarv> digifox03: probably, what sort of help are you looking for?
19:21:30 <iqubic> solonarv: Why is monochrom naughty?
19:22:04 <digifox03> i'm trying to use pattern matching with Linear.V2
19:22:04 <iqubic> also: `naughtys %= (++ m)` should really be `naughtys <>= m`
19:22:26 <oats> haskell is the best imperative language
19:22:31 <digifox03> i tried something like `f (a b) = ...` but it gives me an error
19:22:37 <iqubic> Lists are monoids, so you can just mappend the element to the end of the list.
19:22:46 <solonarv> iqubic: oh right, somehow I got it in my head that 'm' was a single element rather than a list
19:22:50 <solonarv> brain fart I geuss
19:23:05 <oats> digifox03: the constructor for V2 is... V2 :P
19:23:18 <oats> digifox03: so it'd be something like "f (V2 x y) = ..."
19:23:28 <iqubic> solonarv: If m was a single element you'd need "naughtys %= (++ [m])"
19:23:29 <monochrom> He who puts other people on the ban list is put on the naughty list. :)
19:23:50 <iqubic> So clearly you knew 'm' wasn't a single element.
19:24:02 <digifox03> thanks!
19:24:05 <oats> he's on the naughty list multiple times
19:24:20 <solonarv> iqubic: yeah, I'm clearly tired :P
19:24:38 <iqubic> :t assigns
19:24:40 <lambdabot> error:
19:24:40 <lambdabot>     • Variable not in scope: assigns
19:24:40 <lambdabot>     • Perhaps you meant one of these:
19:24:44 <iqubic> :t assign
19:24:45 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
19:25:01 <iqubic> Oh. I see. .= is just infix assign.
19:25:35 <iqubic> :t (.=)
19:25:37 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
19:25:51 <iqubic> Yeah quite literally the same function.
19:26:26 <solonarv> indeed
19:27:28 <oats> naughtify person = do
19:27:29 <oats>   (targets, others) <- partition (== persosn) <$> use nices
19:27:31 <oats>   nices .= others
19:27:33 <oats>   naughtys <>= targets
19:27:41 <iqubic> That works.
19:28:05 <oats> that's really nice
19:28:21 <solonarv> although this is kind of a weird way to do it
19:29:05 <solonarv> naughtify person = do nices %= filter (/= person); naughtys %= (person :)
19:29:34 <oats> ooh
19:29:42 <oats> oh but
19:29:50 <oats> we already established a person can be extra naughty
19:30:01 <solonarv> I suppose
19:30:02 <solonarv> hm
19:31:55 <oats> I feel like I need a complete tour of the lens library
19:32:01 <solonarv> partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:32:02 <oats> there's so much interesting stuff here
19:32:08 <solonarv> arrows!
19:32:25 <oats> evaluate it or shove it :P
19:32:44 <solonarv> I evaluated it in my head
19:32:49 <solonarv> surely that is sufficient! :P
19:33:13 <oats> your head is not a verified haskell interpreter
19:33:52 <solonarv> :t let nices = _1; nices = _2 in \person -> partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:33:54 <lambdabot> error:
19:33:54 <lambdabot>     Conflicting definitions for ‘nices’
19:33:54 <lambdabot>     Bound at: <interactive>:1:5-9
19:34:06 <solonarv> oops
19:34:12 <solonarv> :t let nices = _1; naughtys = _2 in \person -> partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:34:13 <lambdabot> (Field1 s s [a] [a], Field2 s s [a] [a], Eq a, MonadState s m) => a -> m ()
19:35:35 <solonarv> @let naughtify nices naughtys person = partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:35:37 <lambdabot>  .L.hs:189:62: error:
19:35:37 <lambdabot>      • Couldn't match type ‘Identity [a]’ with ‘Const [a] [a]’
19:35:37 <lambdabot>        Expected type: ASetter s s [a] [a]
19:35:48 <solonarv> bah
19:36:16 <solonarv> @let naughtify = let nices = _1; nices = _2 in \person -> partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:36:17 <lambdabot>  .L.hs:177:9: error:
19:36:17 <lambdabot>      Conflicting definitions for ‘nices’
19:36:17 <lambdabot>      Bound at: .L.hs:177:9-13
19:36:48 <solonarv> @let naughtify = let nices = _1; naughtys = _2 in \person -> partition (== person) <$> use nices >>= void . runKleisli (Kleisli (naughtys <>=) *** Kleisli (nices .=))
19:36:50 <lambdabot>  Defined.
19:36:54 <solonarv> there we go!
19:37:42 <solonarv> > runState (naughtify "monochrome") ([], ["monochrome", "someone else", "a sentient chair", "monochrome"])
19:37:45 <lambdabot>  ((),([],["monochrome","someone else","a sentient chair","monochrome"]))
19:38:10 <solonarv> hmm, okay, I'm clearly too tired for this
19:38:12 <solonarv> no more!
19:38:25 <iqubic> @undefine
19:38:26 <lambdabot> Undefined.
19:39:35 <oats> lol
19:47:27 <mniip> does anyone else have this problem with ghci in WSL where it spits text out at like 300 baud
19:54:45 <oats> there a way to simplify this kind of thing with fancy state lens?
19:54:46 <oats> readInput dest = use input >>= \case
19:54:48 <oats>   (v : vs) -> writeMem dest v >> modify (set input vs)
19:54:50 <oats>   []       -> machineError EmptyInput Nothing
19:55:13 <oats> s/modify (set input vs)/input .= vs
19:58:06 <solonarv> yes, using _Cons should help
19:58:35 <a1c`> how to get the index of a string in another string, like "ab" is 3 on "casabwefabwe"?
19:59:37 <solonarv> hm, actually not sure how much _Cons helps
20:00:21 <solonarv> I'd probably just keep it the way you have it right now
20:01:47 <oats> solonarv: sounds good
20:01:59 <oats> it is pretty clear in its workings
20:03:19 <MarcelineVQ> the [] case uses Nothing? jam uncons in there :>>>
20:03:29 <dmwit> > findIndices ("ab"`isPrefixOf) (tails "casabwefabwe")
20:03:30 <lambdabot>  <hint>:1:29: error: parse error on input ‘)’
20:03:33 <dmwit> > findIndices ("ab"`isPrefixOf`) (tails "casabwefabwe")
20:03:36 <lambdabot>  [3,8]
20:03:40 <dmwit> a1c`: ^
20:04:34 <a1c`> dmwit: wow!
20:04:39 <dmwit> > findIndices ("aa" `isPrefixOf`) (tails "casaawefaawe") -- an interesting edge case to consider
20:04:41 <lambdabot>  [3,8]
20:04:42 <dmwit> whoops
20:04:47 <dmwit> > findIndices ("aa" `isPrefixOf`) (tails "casaaawefaaawe") -- an interesting edge case to consider
20:04:49 <lambdabot>  [3,4,9,10]
20:04:56 <a1c`> > tails "casaawefaawe"
20:04:57 <lambdabot>  ["casaawefaawe","asaawefaawe","saawefaawe","aawefaawe","awefaawe","wefaawe",...
20:05:09 <MarcelineVQ> > tails [1,2,3]
20:05:11 <lambdabot>  [[1,2,3],[2,3],[3],[]]
20:05:39 <a1c`> tails is very powerful
20:05:47 <a1c`> so I wonder is there heads?
20:05:52 <dmwit> inits
20:05:57 <a1c`> aha
20:06:10 <dmwit> or... maybe id, depending on what you wanted heads to do
20:06:24 * hackage persistent-sqlite 2.10.5.1 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.5.1 (parsonsmatt)
20:06:59 <a1c`> heads [1,2,3] = [[],[1],[1,2],[1,2,3]]
20:07:09 <dmwit> Okay, inits.
20:07:45 <dmwit> (But inits is much more expensive than tails.)
20:07:59 <a1c`> thanks, those functions are so powerful, if let me to do that, I may to write a twist recursive function to check the index 
20:08:12 <iqubic> > heads [1,2,3]
20:08:13 <lambdabot>  error:
20:08:14 <lambdabot>      • Variable not in scope: heads :: [Integer] -> t
20:08:14 <lambdabot>      • Perhaps you meant one of these:
20:08:26 <iqubic> > inits [1,2,3]
20:08:28 <lambdabot>  [[],[1],[1,2],[1,2,3]]
20:08:35 <iqubic> > tails [1,2,3]
20:08:38 <lambdabot>  [[1,2,3],[2,3],[3],[]]
20:08:47 <MarcelineVQ> dmwit: is it? it would be if it was [1,2,3],[1,2],[1],[]]
20:09:19 <a1c`> > concat . inits $ [1,2,3]
20:09:21 <lambdabot>  [1,1,2,1,2,3]
20:09:24 * hackage persistent-mysql 2.10.2.1 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.10.2.1 (parsonsmatt)
20:10:37 <iqubic> > lasts
20:10:40 <lambdabot>  error:
20:10:40 <lambdabot>      • Variable not in scope: lasts
20:10:40 <lambdabot>      • Perhaps you meant one of these:
20:10:43 <MarcelineVQ> dmwit: oh right I see
20:10:46 <iqubic> Why is lasts not a thing?
20:11:24 * hackage persistent-template 2.8.0 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.0 (parsonsmatt)
20:11:42 <Axman6> do you mean tails?
20:11:56 <Axman6> no
20:12:01 <dmwit> iqubic: What do you want lasts to do?
20:12:37 <a1c`> all those powerful functions are from Data.List and Prelude? any other modules?
20:13:03 <dmwit> a1c`: Given the questions I've seen so far, you might want to check out a parser combinator library.
20:13:39 <dmwit> megaparsec or regex-applicative are fairly non-controversial ones, if you don't know where to start.
20:13:41 <a1c`> dmwit: like?
20:13:51 * dmwit predicts the future
20:22:11 <mniip> lexi-lambda, speaking of, I've been looking at all of this effect business
20:22:35 <mniip> are there reasons we use monads (and free monads in particular) other than because their kleisli categories are closed cartesian
20:22:48 <mniip> can we generate a free closed cartesian category instead?
20:22:53 <mniip> from a semigroupoid?
20:23:03 <lexi-lambda> I don’t know enough category theory to answer your question
20:23:22 <mniip> :(
20:25:25 <lexi-lambda> Maybe I can quickly read up on enough of those terms to muddle through an answer, but I’m not sure the result would be very helpful
20:32:33 <mniip> sounds like you should be able to define a semigroupoid like
20:32:58 <mniip> data S s a b where Get :: S s () s; Put :: S s s ()
20:33:11 <mniip> and then you'd only have to define how the effects interact with eachother (semigroupoid composition)
20:33:30 <mniip> and then generate a free cartesian closed category which should resemble Kleisli (State s)
20:33:55 <mniip> the latter seems to be the tricky bit though
20:34:46 <mniip> ok hmm that is not a semigroupoid
20:34:53 <mniip> but the idea is somewhere near
20:37:00 * solonarv h i s s e s like a snek
20:37:13 <mniip> s t a b
20:39:38 <mniip> data S s a b where Get :: S s () s; Put :: S s s (); Id :: S s a a
20:39:53 <mniip> Id . f = f; f . Id = f; Get . Put = Id; Put . Get = Id
20:42:09 <solonarv> surely you could get away with a slightly different free construction that adjoins Id for you
20:42:16 <solonarv> oh, hm
20:42:23 <mniip> you can't express Get . Put = Id
20:42:34 <solonarv> yeah
20:42:45 <mniip> you could try a free category on a quiver
20:42:53 <mniip> but then you have to manually quotient out Get . Put
20:43:01 * solonarv looks up what a quiver is
20:43:05 <mniip> graph
20:43:35 <iqubic> Why are we calling it a quiver?
20:43:41 <mniip> because category theory context
20:43:47 <solonarv> clarity
20:43:52 <solonarv> it's a specific kind of graph
20:44:09 <mniip> a quiver is specifically a directed graph that can have multiedges and loops
20:44:14 <iqubic> I've heard the term in here before, but I don't recall what it means.
20:44:17 <mniip> a pre-category
20:44:19 <mniip> if you will
20:44:35 <iqubic> A what?!?!
20:44:47 <mniip> imagine a category without any operations
20:44:50 <mniip> or axioms
20:44:56 <mniip> just objects and arrows
20:44:56 <solonarv> a not-quite-a-category-yet, where f . g and id don't always have to exist
20:45:01 <solonarv> yeah
20:45:03 <mniip> that's a quiver
20:45:16 <iqubic> Ah. I see.
20:45:23 <mniip> data Free q a b where Id :: Free q a a; Circ :: q b c -> Free q a b -> Free q a c
20:46:20 <iqubic> I see. How does that differ from a regular category?
20:46:50 <solonarv> pattern Lift :: q a b -> Free q a c; pattern Lift f = Circ f Id -- for convenience
20:46:50 <mniip> what does
20:47:11 <mniip> well ya that's the unit of the adjunction
20:47:12 <mniip> :)
20:47:24 <iqubic> how does Free differ from Catagory?
20:47:33 <mniip> it is a particular category
20:47:35 <iqubic> I have no idea what an adjuction is.
20:47:36 <mniip> not all categories are free
20:48:02 <iqubic> Right... But that one is?
20:48:16 <mniip> well that's like asking how does Maybe differ from a type
20:48:28 <mniip> it's a particular example thereof
20:48:32 <mniip> or a class of examples
20:49:35 <mniip> free constructions are interesting however because they are universal: you can in a specific sense make any other thing using a free thing
20:50:25 <mniip> the simplest example would be that of a free monoid I guess
20:51:08 <solonarv> free abelian group is pretty simple too
20:51:10 <mniip> for any type X, [X] is a monoid and there is an injection X -> [X], such that for any monoid M any function X -> M yields a monoid homomorphism [X] -> M
20:51:24 <mniip> we call this homomorphism foldMap
20:51:45 <mniip> % :t foldMap @[_]
20:51:45 <yahb> mniip: ; <interactive>:1:10: error:; * Expected kind `* -> *', but `[_]' has kind `*'; * In the type `[_]'; In the expression: foldMap @[_]
20:52:17 <mniip> % :t foldMap @[]
20:52:17 <yahb> mniip: Monoid m => (a -> m) -> [a] -> m
20:52:17 <solonarv> % :t foldMap @[]
20:52:18 <yahb> solonarv: Monoid m => (a -> m) -> [a] -> m
20:53:31 <iqubic> foldmap is cool.
20:53:44 <iqubic> :t foldMap `asAppliedTo` []
20:53:46 <lambdabot> error:
20:53:46 <lambdabot>     • Couldn't match expected type ‘a -> m’ with actual type ‘[a0]’
20:53:46 <lambdabot>     • In the second argument of ‘asAppliedTo’, namely ‘[]’
20:53:51 <iqubic> Damn.
20:54:08 <solonarv> got the argument order wrong
20:54:20 <mniip> so in a sense any monoid M can be constructed as [X] for some X, with some elements considered "same"
20:54:23 <mniip> (quotient)
20:54:51 <iqubic> Sure. Makes sense.
20:54:56 * mniip . o O ( the free category is just the horizontal oidification of this process )
20:55:19 <iqubic> I don't know that phrase.
20:56:38 * mniip . o O ( are indexed monads an oidification of monads? )
20:56:51 <iqubic> mniip: Any more nuggets of wisdom to import unto us?
20:57:49 <mniip> well ok, consider the definitions of a category and a monoid
20:57:51 <iqubic> I really need to take an advanced math course and learn all of this.
20:58:04 <iqubic> I know what a category is, and what a monoid is.
20:58:14 <mniip> a category is like a monoid but every element has markers on the left and right that tell it what it can be "concatenated" (composed) with
20:58:26 <iqubic> How so?
20:58:29 <mniip> id is like mempty where both ends are the same marker
20:58:38 <iqubic> Sure.
20:58:39 <mniip> compose is like mappend and the markers in the middle must match
20:58:46 <oats> tacos are just tacoids in the category of endoburritos
20:58:51 <iqubic> Oh. Right I see.
20:58:57 <iqubic> :t (.)
20:58:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:59:02 <mniip> well
20:59:06 <mniip> :t (>>>)
20:59:08 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
20:59:13 <mniip> there they're in the middle
20:59:24 <iqubic> Right.. The Bs need to match.
20:59:28 <mniip> in particular, every monoid is a category with one object
20:59:38 <mniip> if there is only one marker ever, anything can compose with anything
20:59:50 <iqubic> Right. That makes sense.
21:00:07 <mniip> so going back to
21:00:19 <iqubic> I feel like this is creeping closer to the definition of adjunction.
21:00:46 <mniip> if you have some quiver Q, in haskell you could represent this as a datatype Q :: k -> k -> *
21:01:01 <mniip> that corresponds to each pair of vertices the set of edges between them
21:01:02 <iqubic> Sure.
21:01:32 <mniip> similarly you consider all finite lists of edges of Q
21:01:37 <mniip> but you want the ends to match
21:01:50 <mniip> like in a list in the middle the edges should all connect
21:02:16 <iqubic> Alright. Sounds good.
21:02:23 <mniip> data Free a b where Id :: Free a a {- empty list -}; Circ :: Q a b -> Free b c -> Free a c {- cons an edge to the list -}
21:03:13 <iqubic> Right. You can't just cons any random element onto the list. You need it to have the correct markers.
21:03:17 <mniip> yup
21:03:32 <mniip> Free is a category: id is Id, composition is list concatenation
21:03:49 <mniip> and it has a similar universal property
21:04:02 <iqubic> I understand.
21:04:13 <iqubic> id . f = f . id = f
21:04:16 <mniip> given any category C, a graph homomorphism Q => C (haskellese: forall a b. Q a b -> C a b)
21:04:29 <mniip> induces a functor Free Q => C
21:04:39 <iqubic> It does? How?
21:04:50 <iqubic> How did you just magic up a Functor?
21:05:56 <mniip> phi :: (forall a b. Q a b -> C a b) -> Free x y -> C x y; phi h Id = id; phi h (Circ f g) = f . phi h g
21:06:17 <mniip> whoops
21:06:19 <mniip> make that
21:06:25 <mniip> phi h (Circ f g) = h f . phi h g
21:06:31 <solonarv> also, s/Free x y/Free Q x y/
21:06:43 <iqubic> Sure. That makes sense.
21:06:45 <mniip> yea whatever I've fixed a Q her
21:07:08 <mniip> this is really the same thing as in the monoid case
21:07:11 <iqubic> And actually, that mirrors the definition of map/fmap for [a]  too.
21:07:19 <mniip> phi h [] = mempty; phi h (x : xs) = h x : phi h xs
21:07:33 <mniip> phi h [] = mempty; phi h (x : xs) = h x `mappend` phi h xs
21:07:34 <mniip> sorry
21:08:02 <PhaseLock> Hi all, I have a question about do notation and indentation of operators. I put the details on pastebin, here: https://pastebin.com/n0q2QTcd
21:08:06 <iqubic> Right. I just said that, but didn't express it so rigorously.
21:08:18 <mniip> not fmap, but rather foldMap
21:09:11 <iqubic> Why is that distinction important?
21:09:30 <mniip> they're different functions?
21:09:40 <iqubic> Mmm.
21:09:41 <mniip> lists's fmap is completely mundane
21:09:46 <iqubic> Right.
21:09:47 <mniip> foldMap is the proof of list's universality
21:09:50 <iqubic> Yeah.
21:09:51 <mniip> the exciting bit
21:10:07 <PhaseLock> If you read the paste, I've pretty much figured out how it works in this case, I just wanted to see if anyone had additional explanation or documentation about it.
21:10:27 <mniip> there's an extra bit of connection though
21:10:32 <iqubic> Oh?
21:10:35 <iqubic> Do tell.
21:10:51 <mniip> if you have a free object FX for every X, then F can be made into a functor
21:11:03 <mniip> so, since [X] is the free monoid over X for every X
21:11:07 <mniip> you can make map out of foldMap
21:11:31 <iqubic> And then you can just piggyback on the Functor instance for [X]
21:12:05 <iqubic> Is the concept of markers you mentioned earlier anything like the concept of adjuctions that I've seen in here a few times?
21:12:13 <mniip> no
21:12:38 <iqubic> Oh. I see.
21:12:51 <iqubic> Well, in that case I have literally no idea what an adjuction is.
21:12:55 <mniip> it's really just the connection between monoids <-> categories, groups <-> groupoids, semigroups <-> semigroupoids
21:13:00 <mniip> (the markers)
21:13:32 <iqubic> Ah. I see.
21:13:32 <mniip> an adjunction is when a universal property is satisfied for every choice of object
21:13:59 <iqubic> Ah. I see.
21:14:25 <mniip> for every X we have [X] a free monoid satisfying its universal property
21:14:35 <iqubic> Yes. Correct.
21:14:43 <mniip> if you look closer at the universal property, there we talk about a function X -> [X]
21:14:52 <iqubic> Sure.
21:14:57 <mniip> there's actually a functor that we've omitted to write
21:15:06 <mniip> [X] is strictly speaking a monoid and we're looking at a morphism in Set
21:15:12 <iqubic> Oh. Of course.
21:15:14 <mniip> there's a functor U : Mon -> Set
21:15:20 <iqubic> Sure.
21:15:22 <mniip> X -> U[X]
21:15:53 <mniip> [X] is a universal object and X -> U[X] is a universal morphism
21:16:02 <iqubic> I'd agree with that.
21:16:48 <mniip> in general if there's some F such that for every X, FX is a universal object (with the corresponding X -> UFX universal morphism)
21:16:52 <mniip> we say that F is left adjoint to U
21:17:18 <iqubic> I get it.
21:17:27 <mniip> the universal property states that for every other morphism X -> UY, there is a unique morphism FX -> Y
21:17:38 <iqubic> Sure.
21:17:42 <mniip> hence we have an isomorphism of hom-sets: Hom(FX, Y) isomorphic to Hom(X, UY)
21:17:52 <iqubic> Correct.
21:18:12 <mniip> this shows us that the notion of adjunction is somewhat symmetric
21:18:29 <iqubic> Correct.
21:18:36 <mniip> we could also have been looking at U as providing universal objects for F, with universal morphisms of the shape FUX -> X
21:19:09 <iqubic> Right. And we'd get the same results either way.
21:19:49 <mniip> an adjunction has many faces
21:19:57 <iqubic> How does one learn all of this stuff? And does it help when writing Haskell code?
21:20:30 <mniip> you could talk about Hom(FX, Y) ~ Hom(X, GY), or about natural transformations X -> GFX and FGX -> X, or about F providing universal objects for G or vice versa
21:20:37 <mniip> and that's the gist of it I guess
21:20:58 <mniip> you know how a product satisfies a universal property?
21:21:01 <iqubic> Right. All of this makes sense.
21:21:07 <mniip> and how in, say, Set, a product exists for any pair of objects
21:21:14 <iqubic> I understand how Products work.
21:21:20 <mniip> of course, there's an adjunction
21:21:31 <iqubic> There is?
21:21:34 <mniip> yup
21:21:49 <mniip> if you consider the categories C and CxC
21:22:08 <mniip> you can make a functor C -> CxC that sends X into (X, X) and f into (f, f)
21:22:17 <mniip> that's called the diagonal functor
21:22:27 <mniip> it's similar to `const` in a sense
21:22:39 <mniip> this functor has a left adjoint
21:22:45 <mniip> the functor that sends (X, Y) to XxY
21:22:50 <mniip> the product functor
21:22:55 <iqubic> Ah I see.
21:23:00 <mniip> did I get this right
21:23:09 <iqubic> I'm not sure.
21:23:13 <mniip> nope
21:23:17 <mniip> it's the *right* adjoint
21:24:01 <iqubic> Oh???
21:24:02 <mniip> CxC( (Z, Z), (X, Y) ) ~ C(Z, XxY)
21:24:29 <iqubic> Yes. Makes sense.
21:24:44 <mniip> so the product is the right adjoint of the diagonal functor (on CxC)
21:24:52 <mniip> the diagonal functor has a left adjoint too
21:24:56 <mniip> it's the coproduct functor
21:25:32 <mniip> in general since limits satisfy universal properties, there's adjunctions lurking nearby
21:25:50 <iqubic> How does all of this help when writing actual haskell code?
21:25:56 <mniip> limits are universal cones/cocones, so you have all morphisms going out of/going into a single object
21:26:05 <mniip> that suggests that one of the functors in the adjunction is going to be the diagonal
21:26:19 <mniip> well uh
21:26:26 <mniip> it helps you think about stuff I guess
21:27:04 <mniip> helps you recognize more abstractions in more places
21:27:11 <mniip> write more general/robust code
21:27:32 <iqubic> Ah. I see.
21:28:23 <mniip> 1/3/2020 [08:17:49] <iqubic> How does one learn all of this stuff?
21:28:28 <mniip> I don't have a simple answer
21:28:31 <mniip> took me years
21:28:45 <mniip> of continually approaching the subject from varying angles
21:28:57 <mniip> initially from the CS side, then from the math side as well
21:31:22 <dsal> Can you please have me understand all the things tonight?  Thanks.
21:31:24 * dsal puts on a movie
21:33:46 <iqubic> dsal: I too want to understand this stuff.
21:33:58 <dsal> I just take the slow path.
21:34:00 <iqubic> I'm going to read Bartosz's blog.
21:34:26 <dsal> I read stuff, watch videos, etc... and see a lot of things that I don't get the point of.  Then I occasionally go "man, I wish I had a way to..." and it clicks.
21:43:24 * hackage yesod-persistent 1.6.0.4 - Some helpers for using Persistent from Yesod.  https://hackage.haskell.org/package/yesod-persistent-1.6.0.4 (MichaelSnoyman)
21:56:00 <nevere> Can somebody please help me figure why this wouldn't typecheck, https://codeshare.io/5OqRw7
22:01:01 <mniip> you have cast :: Char -> Maybe a0
22:01:17 <mniip> where both fn and cast want Typeable a0
22:01:22 <mniip> but you haven't specified what a0 is
22:01:49 <mniip> as it stands your fn will take *any* typeable
22:01:56 <mniip> did you mean to make it take *some* typeable?
22:08:35 <p0a> Hello
22:08:47 <nevere> mniip: \e
22:09:20 <nevere> mniip: Sorry. Yes, I want it to be some typeable.
22:09:55 <mniip> data Test where Test :: forall a. (Typeable a) => (a -> ()) -> Test
22:11:43 <amalloy> you don't actually need the forall there, right?
22:12:28 <a1c`> > concat $ splitOn "he" "hey there" "y tre"
22:12:30 <lambdabot>  error:
22:12:30 <lambdabot>      • Couldn't match expected type ‘[Char] -> [[a]]’
22:12:30 <lambdabot>                    with actual type ‘[[Char]]’
22:12:37 <a1c`> concat $ splitOn "he" "hey there"
22:12:48 <nevere> mniip: It works. Amazing! But I have no idea how it was changed by your suggestion.
22:13:03 <a1c`> > concat $ splitOn "he" "hey there"
22:13:03 <mniip> amalloy, correct
22:13:05 <lambdabot>  "y tre"
22:13:22 <a1c`> but I just want remove the first he, to get "y there"
22:13:25 <a1c`> how I shoud do?
22:13:49 <mniip> :t stripPrefix
22:13:50 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
22:14:09 <oats> a1c`: are you trying to do some parsing of some kind?
22:14:18 <a1c`> > stripPrefix "he" "hey there"
22:14:20 <lambdabot>  Just "y there"
22:14:42 <mniip> nevere, when you write 'f :: forall a...' you're saying that the user of f can chose any a they want, and the implementor of f has to be able to accomodate
22:14:44 <a1c`> oats: no, I'm just learning that basic functions
22:14:53 <oats> gotcha
22:15:08 <mniip> when you write 'f :: (forall a...) -> ...' you're saying that the implementor of f can choose any a they want, and the user of f has to accomodate
22:16:13 <mniip> Test :: (forall a. (Typeable a) => a -> ()) -> Test
22:16:43 <mniip> when constructing Test you pass in an 'forall a. (Typeable a) => a -> ()' meaning you have to pass in a function that can accomodate for any a
22:17:00 <mniip> when destructing you get back an 'forall a. (Typeable a) => a -> ()' meaning you as now the user can choose any a you want
22:17:20 <mniip> Test :: forall a. (Typeable a) => (a -> ()) -> Test
22:17:44 <mniip> this is now saying that Test can accomodate for any a, and when constructing you as the user of Test can choose any a you want
22:18:14 <p0a> What is a good way to write a website using haskell? Will "Haskell and Yesod" do?
22:18:19 <mniip> when destructing on the other hand you will get back an 'a -> ()' but you don't know what a is, so you have to be able to accomodate for any
22:19:04 <a1c`> oats: there're so many basic functions, about list, it has already take me a day, and I still can't finish it
22:19:11 <mniip> nevere, does that make sense?
22:19:59 <a1c`> p0a: scotty is more easy to use
22:20:00 <dsal> a1c`: "available" and "basic" aren't the same, really.  You don't need to know everything available.  :)
22:20:19 <oats> a1c`: may I suggest, there are more productive ways to get familiar with haskell then forcing yourself to read through module documentation :)
22:20:38 * dsal learned English by reading the dictionary
22:21:14 <mniip> to learn haskell first learn to write the functions
22:21:29 <mniip> then once you have a solid understanding of how to do that you can move onto using functions written by others
22:22:01 <p0a> I think I have a bit of understanding 
22:22:05 <p0a> I've done some haskell before 
22:22:15 <nevere> mniip: Yes. The frustrating thing about this is that I kinda know this alreay, but it still trips me up from time to time..
22:22:58 <oats> mniip, a1c`: and, just write code! do the best you can with what you know, then look around, see how others approached the same problem. maybe share your solution! maybe someone else will suggest an alternative
22:23:28 <mniip> someone probably will suggest an alternative and make sure not to take criticism too close to heart
22:23:37 <p0a> a1c`: any advice on a good tutorial/book on scotty? I see this https://github.com/scotty-web/scotty/wiki/Scotty-Tutorials-&-Examples but the first tutorial was outdated as it said itself
22:23:39 <a1c`> oats: my codes is ugle... totally scheme style, lots of lambda and twisted recursive
22:23:40 <dsal> I really like the kind of stupid I feel when I see how someone else wrote a program I worked hard on.
22:23:47 <oats> I don't think learning is "Take everything in and then starting doing stuff", there's definitely a feedback loop that needs to take place
22:23:59 <oats> a1c`: perfect, you're on track to success. write those ugly lambdas :P
22:24:59 <a1c`> p0a: yes, the tutorial link on github I think it's good
22:25:03 <dsal> Sharing that code with someone might get you pointers to things outside of where you're looking, but very interesting.  e.g., instead of Data.List, maybe what you'd find most useful for a particular thing is in Data.Foldable.
22:25:27 * mniip . o O ( semigroupoids )
22:25:31 <p0a> What about happstack?
22:26:05 <oats> a1c`: once you've written a bunch of "ugly" code, you'll eventually come across some code someone else wrote that's a little nicer and uses a trick you weren't aware of, and then you can pull that into your brain bank and write some slightly nicer code :D
22:26:31 <a1c`> oats: this my ugly split list function, https://github.com/jusss/code/blob/bla2/Haskell/SplitList.hs
22:26:48 <mniip> to understand why common practices are such, you have to see what happens when you don't follow them
22:27:18 <a1c`> oats: it's the same function with splitOn
22:28:10 <oats> I can see the scheme influence ;)
22:28:15 <mniip> wait how does that function work
22:28:24 <mniip> what are you expecting from it
22:28:25 <a1c`> oats: yeah! scheme!
22:28:28 <mniip> I don't understand the testcases
22:28:48 <a1c`> mniip: split string with another string
22:29:00 <a1c`> same as splitOn
22:29:03 <a1c`> very twisted
22:29:11 <a1c`> totally scheme style
22:29:15 <dsal> a1c`: Note ~everything in haskell is immutable.  `copyB = listB` doesn't do much but give you another name.
22:29:49 <mniip> then shouldn't split [1,2,3,2,4,5] [3,4] = [[1,2,3,2,4,5]]
22:29:54 <nevere> mniip: Is there any resource that describe the whole constraint/context stuff in good detail? I ll be thankful forever!
22:30:20 <a1c`> mniip: I don't use Maybe, so just return itself
22:30:31 <mniip> nevere, I don't know, I just think about them in terms of system F (system FC)
22:30:42 <mniip> a1c`, no like
22:30:51 <mniip> surely split "hello" "," = ["hello"]
22:30:53 <mniip> and not []
22:31:16 <mniip> that's what splitOn would do
22:31:32 <a1c`> yeah, a bit different with splitOn
22:31:52 <a1c`> return a [] is good to `if ... else`
22:31:56 <oats> > splitOn "," "hello"
22:31:59 <lambdabot>  ["hello"]
22:32:11 <dsal> I find I don't use if very much in haskell code.
22:32:19 <mniip> you should try to use as little if-else as possible
22:32:33 <mniip> that will in turn make your functions simpler
22:32:41 <mniip> and probably uncover base cases you didn't think about
22:32:59 <dsal> e.g., your `removeN` is basically   removeN xs 0 = xs; removeN (_:xs) n = removeN xs (n-1)
22:33:12 <dsal> (or just `drop` if you flip the args around)
22:33:44 <dsal> Though that's still uncomfortably partial.
22:34:02 <a1c`> dsal: use patter matching is not easy to convert it to other languaes, so I used if-else
22:34:39 <dsal> That's why I don't use other languages when I can avoid it.  :)
22:34:52 <mniip> what I'm saying is
22:34:57 <a1c`> dsal: but you're right, pattern matching is more easy to read
22:35:08 <mniip> maybe your understanding of what the function should do in edge cases is making the function more complicated than it should be
22:35:26 <a1c`> mniip: yeah, this function is very twisted
22:35:46 <a1c`> so I want to learn the library functions
22:35:48 <mniip> I would try to decouple that functionality then
22:35:58 <p0a> auxiliary functions may help
22:36:01 <mniip> splitting into words the simple way first
22:36:07 <mniip> and then building the "odd" edge cases around it
22:36:12 <mniip> if that is indeed what you need
22:36:40 <dsal> e.g., you have   `f [] listB before counter =`  (pattern matching on null listA) and then  you start it with `if (null listB) `   -- Just pattern match on [] []
22:38:10 <dsal> Oh, I see, you have `copyB` because you're shadowing the parameter.  IMO, it's easier to just not do that.  -Wall is helpful here.
22:39:28 <p0a> What is <*> ?
22:39:35 <dsal> :t (<*>)
22:39:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:39:40 <a1c`> p0a: apply
22:39:41 <dsal> It's like <$>, but for applicatives.
22:39:57 <oats> p0a: it lets you apply functions that are in a functor to values that are in a functor, kinda
22:40:00 <p0a> How can I inspect it? I can't use :t on it 
22:40:07 <dsal> :t (<*>)
22:40:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:40:10 <p0a> aaah thank you 
22:40:11 <a1c`> mniip: dsal see the twisted scheme version, https://paste.ubuntu.com/p/FB8KkmXxwx/
22:40:25 <oats> > Just (+1) <*> Just 4
22:40:28 <lambdabot>  Just 5
22:40:33 <oats> > Nothing <*> Just 4
22:40:36 <lambdabot>  Nothing
22:41:00 <oats> (+) <$> Just 4 <*> Just 1
22:41:09 <oats> > (+) <$> Just 4 <*> Just 1
22:41:11 <lambdabot>  Just 5
22:42:27 <a1c`> > (,) <$> "abc" <*> "123"
22:42:29 <lambdabot>  [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...
22:42:43 <oats> uffda
22:43:21 <mniip> @let splt xs ys | Just zs <- stripPrefix ys xs = []:splt zs ys; splt (x:xs) ys = case splt xs ys of (rs:rss) -> (x:rs):rss; split [] ys = [[]]
22:43:21 <lambdabot>  Parse failed: Parse error in pattern: split
22:43:31 <mniip> @let splt xs ys | Just zs <- stripPrefix ys xs = []:splt zs ys; splt (x:xs) ys = case splt xs ys of { (rs:rss) -> (x:rs):rss }; splt [] ys = [[]]
22:43:33 <lambdabot>  Defined.
22:43:48 <mniip> > splt "hey there" "he"
22:43:51 <lambdabot>  ["","y t","re"]
22:45:22 <a1c`> > splitOn "he" "hey there"
22:45:24 <lambdabot>  ["","y t","re"]
22:45:33 <oats> hey, that's pretty neat
22:47:02 <mniip> > splitOn "....." ".."
22:47:04 <lambdabot>  [".."]
22:47:11 <oats> mniip: did you forget another guard there?
22:47:13 <mniip> oops
22:47:18 <mniip> > splitOn ".." "....."
22:47:20 <lambdabot>  ["","","."]
22:47:28 <mniip> my fn does the same
22:47:31 <mniip> oats, no?
22:48:07 <oats> oh, forgive me
22:48:14 <oats> I was trying to parse it out all on one line :<
22:49:26 <p0a> when I type `return "foo"' I'm getting :: Monad m => m [Char] instead of `Just "foo"'
22:49:31 <p0a> Why is that?
22:49:44 <p0a> It's unclear to me because I'm reading that chapter on monads on learn you a haskell
22:50:02 <p0a> I meant instead of :: Maybe String
22:50:37 <oats> p0a: it's because there's lots of things that `return "foo"` could be
22:50:56 <oats> > return "foo" :: Maybe String
22:50:58 <lambdabot>  Just "foo"
22:51:04 <oats> > return "foo" :: [String]
22:51:06 <lambdabot>  ["foo"]
22:51:23 <p0a> oats: sure, but why would the tutorial say Maybe String?
22:51:38 <oats> p0a: could you link us what you're looking at?
22:51:58 <p0a> Aaah nevermind. I just realized they're using :: Maybe String to `tell' the interpreter what it is 
22:52:15 <p0a> I didn't realize :: Maybe String was part of the code I had to evaluate
22:52:25 <i12321> mniip: @let splt xs ys | Just zs <- stripPrefix ys xs = []:splt zs ys; splt (x:xs) ys = case splt xs ys of { (rs:rss) -> (x:rs):rss }; splt [] ys = [[]]
22:52:58 <mniip> hm?
22:53:01 <mniip> that's a copy
22:53:15 <i12321> wonderful
22:53:51 <p0a> is () more special than [] ?
22:54:35 <oats> :t ()
22:54:36 <lambdabot> ()
22:54:48 <oats> it is not a list :)
22:55:09 <p0a> good point
22:55:59 <oats> it's called a unit datatype
22:56:04 <oats> it has only one constructor, ()
22:56:27 <oats> it's often used to represent the absence of data
22:56:34 <oats> or an action that returns no value
22:56:55 <oats> (a :: IO ()) is a value that might do something with IO, but will yield no value
22:58:28 <a1c`> :t Void
22:58:29 <lambdabot> error:
22:58:29 <lambdabot>     • Data constructor not in scope: Void
22:58:29 <lambdabot>     • Perhaps you meant one of these:
22:58:46 <dsal> :t absurd
22:58:48 <lambdabot> Void -> a
22:59:09 <dsal> You can't make nothing.
22:59:26 <a1c`> is there (1,2,3) ?
22:59:47 <a1c`> is that tuple in other languages same ?
23:00:00 <dsal> There are many (1,2,3)s.  Are you looking for one in particular?
23:00:15 <dsal> Yeah, that's a tuple.
23:00:48 <a1c`> dsal: (1,2,3) is a tuple?
23:00:54 <dsal> Yes
23:01:07 <a1c`> dsal: then what we call (1,2)?
23:01:16 <dsal> :t (1,2,3)
23:01:18 <lambdabot> (Num a, Num b, Num c) => (a, b, c)
23:01:23 <oats> a1c`: a two-tuple :)
23:01:30 <a1c`> oats: aha
23:01:32 <oats> ghci is a very wise teacher
23:01:32 <dsal> Twople
23:01:47 <a1c`> oats: but ghci won't tell you its name
23:01:52 <a1c`> only its type
23:02:02 <oats> well, it's colloquial
23:02:25 <dsal> :t (,,)
23:02:26 <lambdabot> a -> b -> c -> (a, b, c)
23:02:29 <p0a> so if I were to do a getline and a concatenation and a printStrLn all in one line what would it look like?
23:02:39 <p0a> Do I need a lambda around the concatenation?
23:02:42 <a1c`> p0a: >>=
23:02:42 <p0a> I mean (++)
23:02:58 <p0a> right but (++) is pure right
23:02:58 <oats> p0a: so you want to get some lines and cat them together?
23:03:07 <p0a> no something like "Hello " ++ name 
23:03:22 <oats> ah
23:03:33 <p0a> I know it has to start with getLine >>= right?
23:03:39 <oats> yeah, you'll need >>= since you want to do an action based on the result of a previous action
23:03:46 <amalloy> that is the most obvious way to start it, yes
23:03:53 <oats> but it'll be prettier with do-notation
23:04:13 <dsal> % putStrLn =<< ("hello " <$> pure "world")
23:04:13 <a1c`> p0a: 'cause the string you want to operate, is in an IO
23:04:13 <yahb> dsal: ; <interactive>:33:15: error:; * Couldn't match expected type `[Char] -> String' with actual type `[Char]'; * In the first argument of `(<$>)', namely `"hello "'; In the second argument of `(=<<)', namely `("hello " <$> pure "world")'; In the expression: putStrLn =<< ("hello " <$> pure "world")
23:04:18 <amalloy> putStrLn =<< (("Hello " ++) <$> getLine)
23:04:23 <dsal> Phone Haskell fail
23:04:24 <amalloy> is how i would write it
23:04:25 <p0a> getLine >>= \x -> putStrLn ("Hello " ++ x) ?
23:04:35 <iqubic> Yes
23:04:38 <oats> p0a: yep :)
23:04:40 <oats> or
23:04:42 <oats> do
23:04:45 <oats>   name <- getLine
23:04:47 <oats>   putStrLn ("Hello", ++ name)
23:04:48 <oats> they are equivalent
23:05:09 <p0a> I don't want the `do' equivalence I want to desugarify it 
23:05:17 <oats> fair enough
23:05:20 <p0a> hence the one liner, btw,  my code doesnt' work
23:05:28 <amalloy> you need parens
23:05:47 <dsal> % putStrLn =<< (("hello " <>) <$> pure "world")
23:05:47 <yahb> dsal: hello world
23:06:14 <p0a> amalloy: thank you, it works
23:07:07 <p0a> okay I think I sort of get monads now 
23:07:19 <dsal> p0a: you'll probably think that many times
23:07:24 <oats> hehe
23:07:29 <p0a> superficially dsal :P
23:07:41 <p0a> This was my first time so I can celebrate
23:08:03 * oats throws confetti on p0a
23:09:23 <p0a> lol
23:09:40 <oats> oversimplified, monads let you compose functions where the return type is more "complicated" than a simple, single value
23:09:54 <a1c`> dsal: +1
23:10:11 <dsal> > let l = "abcde" in do { a <- l; b <- l; guard $ a /= b; pure [a,b] } -- p0a 
23:10:13 <lambdabot>  ["ab","ac","ad","ae","ba","bc","bd","be","ca","cb","cd","ce","da","db","dc",...
23:10:25 <mniip> I unironically reason about monads as if they were monoids
23:10:28 <p0a> oats: I agree, that's how I think of it in a way. That a monad is a type just "tainted"
23:10:40 <p0a> I am not sure what monads are mathematically
23:10:42 <a1c`> p0a: there're lots of twisted monads waiting for you :)
23:10:43 <mniip> occasionally as kleisli categories or as monadic adjunctions
23:10:55 <oats> mniip: please elaborate on the first :)
23:11:10 <p0a> I'd like to hear too
23:11:11 <dsal> mniip: sounds like song lyrics
23:11:14 <mniip> a monad is a monoid in the category of endofunctors
23:11:20 <oats> of course
23:11:23 <mniip> shockingly
23:11:47 <p0a> so the category of endofunctors is what
23:11:53 <a1c`> mniip: is that lambda-man said that?
23:11:56 <p0a> an endofunctor is F : C -> C. What is the category?
23:12:08 <oats> volvos are volvoids in the caregory of endotrucks
23:12:20 <mniip> a monoidal category is a triple (C, (x), I) of a category C, a bifunctor (x) : C x C -> C, and an object I in ob(C)
23:13:02 <mniip> together with natural isomorphisms: unitors: X (x) I ~~ X ~~ I (x) X and associator (X (x) Y) (x) Z ~~ X (x) (Y (x) Z)
23:13:12 <oats> mniip: is `x` the associative binary operator?
23:13:15 <mniip> that satisfy appropriate commutative diagrams (triangles and pentagon)
23:13:28 <p0a> mniip: What is the category of endofunctors?
23:13:40 <mniip> it's usually denoted ⊗ but I'm using a vulgar ascii representation
23:13:54 <oats> and `I` the identity element?
23:13:55 <mniip> yes ⊗ is the associative bifunctor
23:14:00 <mniip> and I is the identity object
23:14:20 <mniip> for example, if you set ⊗ to be the product and I to be the terminal object
23:14:35 <mniip> if your category has products then the result will be a monoidal category
23:14:46 <mniip> that's called a cartesian monoidal category
23:14:56 <p0a> the problem I have with thinking of Haskell in categorical terms is that Category theory is axiomatized on something much bigger than what computers do
23:15:12 <mniip> it can be lowered to computers' level
23:15:18 <mniip> by constructing everything on top of the effective topos
23:15:25 <mniip> but that is a story for another day
23:15:30 <p0a> So by effective topos you mean whatever is computable right
23:15:34 <mniip> yes
23:15:37 <oats> ok, this went over my head 10 lines ago
23:15:43 <oats> it's 2am, I'm going to sleep :P
23:16:21 <p0a> mniip: by doing what you said, we guarantee that when we talk of "the category of all ..." it's a computable thing
23:16:34 <p0a> the notion is restricted
23:16:48 <p0a> goodnight oats 
23:17:16 <mniip> we don't talk about "the category of all"
23:17:44 <mniip> but if we do happen to talk about e.g. a particular monad, by construction its unit/counit will be computable (componentwise)
23:17:58 <mniip> because they're morphisms in Eff
23:18:33 <p0a> so teh category of all is `Eff' that's what I meant
23:18:37 <p0a> and yeah the things inside it are computable
23:18:38 <mniip> we don't need "all monads" to be a computable set
23:18:45 <mniip> we just want each monad to be a computable entity
23:18:46 <p0a> yes
23:19:05 <mniip> Eff achieves that
23:19:23 <a1c`> mniip: what's isomorphism?
23:19:23 <mniip> though I can't really talk about Eff as I'm still on the way to comprehending it completely
23:19:44 <p0a> I'm reading this https://stackoverflow.com/a/3870310
23:19:52 <mniip> an isomorphism f : X -> Y is a morphism that has an inverse: some morphism g : Y -> X such that g.f = id and f.g = id
23:20:15 <a1c`> mniip: what's Curry-Howard isomorphism?
23:20:29 <mniip> it's called Curry-Howard correspondence
23:20:38 <mniip> calling it an isomorphism is a bit of a terminology abuse
23:20:40 <p0a> So the endofunctor T : X → X is how we start; What is the meaning of T?
23:20:51 <a1c`> mniip: ok, so that's it?
23:21:29 <mniip> a1c`, you could probably talk about some sort of homotopy equivalence between some logic category and some set/type category
23:21:54 <mniip> but in general no concrete meaning is put in that "isomorphism"
23:22:14 <mniip> at least not that I know
23:22:19 <mniip> p0a, what are you asking
23:22:21 <a1c`> ok
23:23:17 <p0a> mniip: I am reading the stackoverflow post https://stackoverflow.com/a/3870310 which I think explains your sentence "monoid in category of endofunctors"
23:24:01 <p0a> mniip: I am trying to understand the meaning of T in that post
23:24:13 <p0a> or X even
23:25:14 <mniip> well T is a functor
23:25:44 <p0a> So X is the set of types?
23:25:46 <mniip> no
23:25:57 <p0a> Should I stop trying to understand this? :P
23:25:58 <mniip> ah in that notation
23:26:01 <mniip> X is the category of types
23:26:13 <mniip> I mean I could try continuing with my explanation
23:26:18 <p0a> so T takes pure/impure types to impure types right?
23:26:19 <mniip> about monoidal categories
23:26:36 <p0a> Well sure but before we go on let's agree on which explanation we're going about
23:26:43 <p0a> Do you want to talk about monoidal cats?
23:26:45 <mniip> sure
23:26:55 <p0a> okay you said something before let me read it 
23:27:02 <a1c`> data Reader r a = Reader { runReader :: r -> a }
23:27:39 <mniip> (C, ⊗, I) is a monoidal category if ⊗ is an associative bifunctor on C and I is its left and right unit object
23:27:43 <a1c`> mniip: runReader is isomorphic with Reader?
23:27:58 <mniip> a1c`, runReader is the inverse of Reader
23:28:10 <mniip> 'Reader r a' is isomorphic with 'r -> a'
23:28:36 <Ailrun[m]> by `Reader` and `runReader`
23:28:45 <a1c`> runReader :: Reader -> (r->a)
23:28:48 <p0a> mniip: okay, following. then?
23:29:01 <a1c`> Reader :: (r->a) -> Reader
23:29:34 <a1c`> runReader :: Reader r a-> (r->a)
23:29:41 <a1c`> Reader :: (r->a) -> Reader r a
23:29:46 <p0a> for example ⊗ = +, C = ℕ, I = 0 could do it I believe
23:29:55 <p0a> I mean (ℕ, +, 0)
23:30:00 <mniip> is ℕ a category?
23:30:35 <p0a> Well I suppose so in some sense we could have it be. Maybe by order x -> y iff x <= y
23:30:54 <a1c`> mniip: runReader . Reader = id?
23:31:05 <p0a> ah you're worried about ⊗ being a bifunctor. Okay, I retract my statement, I realize that now
23:31:17 <mniip> it is a bifunctor in this case
23:31:22 <mniip> it just so happens
23:31:34 <p0a> right it just happened that I was able to bullshit my way out of this one
23:31:36 <p0a> lol
23:31:38 <mniip> thin categories are't very interesting though
23:31:54 <mniip> the cartesian monoidal category is the easiest to think of
23:32:03 <mniip> consider (Set, direct product, singleton set)
23:32:08 <Ailrun[m]> a1c`: it is `id`
23:32:27 <p0a> mniip: okay, got it. Anyway, why talk about the concept of monoidal category?
23:32:37 <mniip> this lets us generalize the definition of a monoid
23:32:44 <a1c`> Ailrun[m]:  runReader and Reader are isomorphic?
23:33:09 <mniip> a monoid in (C, ⊗, I) is an object M with morphisms M⊗M -> M and I -> M that make appropriate diagrams commute
23:33:11 <Ailrun[m]> a1c`: no, as mniip said, they are the inverse of each other.
23:33:21 <mniip> (the unital triangles and the associativity pentagon)
23:33:58 <Ailrun[m]> "by" those two, `Reader r a` and `r -> a` are isomorphic.
23:33:59 <mniip> for example in the cartesian monoidal example on Set, this definition of a monoid coincides with the usual definition of a monoid
23:34:17 <p0a> I think I can see that
23:34:55 <p0a> A monoidal category is a strictly more general concept to a monoid due to the unit/assoc natural functors
23:35:06 <mniip> they are uncomparable
23:35:26 <p0a> not entirely as demonstrated with the (ℕ, +, 0) example
23:35:38 <mniip> a discrete monoidal category is a monoid yes
23:35:44 <mniip> but that's not the comparison we're going for
23:35:54 <p0a> right you actually picked an object M to get a monoid from
23:36:04 <mniip> anyway you could for example consider the cocartesian monoidal structure
23:36:08 <mniip> coproduct and empty set
23:36:24 <p0a> the coproduct being disjoint union? 
23:36:31 <mniip> yes
23:36:47 <p0a> but what is all this to do with monads?
23:36:52 <mniip> every set is a monoid in this monoidal category in exactly one way
23:37:03 <mniip> you have a unique way to define M+M -> M and 0 -> M
23:37:14 <mniip> well I'm just trying to provide some intuition
23:37:49 <mniip> consider now for some category C its category of endofunctors End(C)
23:38:03 <mniip> with objects functors C -> C, and morphisms natural transformations between those functors
23:38:34 <p0a> okay
23:38:38 <mniip> endofunctor composition is a bifunctor on this category
23:38:43 <mniip> it is associative
23:38:55 <mniip> and has as left and right units the identity bifunctor Id : C -> C
23:39:00 <mniip> functor*
23:39:23 <mniip> hence there is a monoidal category
23:39:32 <mniip> (End(C), composition, Id)
23:39:58 <p0a> okay
23:40:11 <mniip> a monoid in this is an object M of End(C) with morphisms Id -> M and M.M -> M
23:40:16 <mniip> morphisms in End(C) of course
23:40:22 <mniip> i.e. natural transformations
23:40:44 <mniip> written componentwise they are, forall X, Id X -> M X; and  forall X, M (M X) -> M X
23:41:18 <mniip> the commutative diagrams in the definition of a monoid are precisely the monad laws
23:41:28 <p0a> When you say Id → M which Id do you mean? the Id functor of C?
23:41:32 <mniip> yes
23:42:29 <p0a> So Functor → Object?
23:42:39 <p0a> What kind of arrow is that?
23:42:45 <p0a> oh M is in End(C)
23:43:31 <mniip> no
23:43:35 <mniip> yeah
23:43:43 <mniip> M is an endofunctor
23:44:09 <p0a> can you clarify when you say "the commutative diagrams in the def. of a monoid are precisely of the monad laws?"
23:44:13 <p0a> With one example? no need to do all laws
23:46:15 <p0a> am i to think of C as all types, pure and impure?
23:47:04 <p0a> let me reread what you said above for monoids
23:48:40 <p0a> so assume we have: ı : Id→M and μ : M⊗M→M
23:48:56 <mniip> a monoid satisfies these commutative diagrams https://cdn.discordapp.com/attachments/488104216678760469/662562831882780693/207092805644845057.png
23:49:28 <mniip> there is no such thing as "impure types"
23:50:32 <p0a> so the first is the associativity law. What is η?
23:51:11 <p0a> is it the inverse? monoids wouldn't have it 
23:51:39 <mniip> eta is the I -> M
23:51:44 <mniip> the identity
23:51:52 <mniip> (of the monoid)
23:51:57 <p0a> aah okay
23:52:06 <p0a> give me some time lol
23:52:13 <mniip> in Set that corresponds to a function from the singleton set
23:52:16 <mniip> i.e. a choice of an element
23:52:51 <p0a> the unnamed arrow is what though?
23:52:59 <mniip> which one
23:53:01 <mniip> the diagonal?
23:53:01 <p0a> What is M⊗I→M ?
23:53:03 <p0a> yeah
23:53:08 <mniip> that's the unitor of the monoidal category
23:53:16 <p0a> ah okay
23:53:47 <p0a> and the associator was used in the first law where you wrote M⊗M⊗M unambiguously
23:53:56 <mniip> yes
23:54:21 <p0a> thats' some weird stuff
23:54:50 <p0a> ok so I see the laws, what part of return/>>=/>>/fail corresponds to this?
23:54:57 <mniip> End(C) happens to be strict monoidal so the unitor and the associator are exactly identoty
23:55:04 <mniip> and the objects are exactly equal
23:55:16 <mniip> return is eta
23:55:18 <mniip> join is mu
23:55:34 <mniip> :t return
23:55:36 <lambdabot> Monad m => a -> m a
23:55:36 <mniip> :t join
23:55:38 <lambdabot> Monad m => m (m a) -> m a
23:55:46 <p0a> Sure so there is a leeway with the natural transformations but End(C) is what we're looking at
23:56:09 <mniip> ?
23:56:32 <p0a> so C is the types?
23:56:46 <mniip> C can be Hask yes
23:57:00 <mniip> haskell monads are monads on Hask - monoids in End(Hask)
23:57:31 <p0a> Monad m => m a is a type right?
23:57:38 <mniip> uhh
23:57:44 <mniip> not sure what you're asking here
23:58:02 <mniip> it's not an object of Hask no
23:58:19 <p0a> I'm still thinking of return as eta 
23:58:24 <p0a> trying to undertsand it
23:58:24 <mniip> Int is an object on Hask
23:58:29 <mniip> Maybe is a monad on Hask
23:58:53 <p0a> so the M we are talking about?
23:58:56 <mniip> it has associated natural transformations  forall a. a -> Maybe a   and   forall a. Maybe (Maybe a) -> Maybe a
23:58:59 <mniip> for example
