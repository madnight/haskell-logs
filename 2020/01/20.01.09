00:01:50 <alc`> can we combine two Monad Transformer?
00:04:11 <jle`> combine, like put in a tuple?
00:07:27 <alc`> jle`: can we use Maybe in ContT () IO a?
00:07:39 <jle`> what do you mean 'use Maybe' ?
00:07:48 <jle`> you can have ContT () IO (Maybe Int) or something
00:07:56 <jle`> it depends on what you want to do with it and what behavior you want to have
00:08:21 <alc`> flip C.runContT return $ do   this context is IO, can we use Maybe in this context
00:09:28 <dminuoso_> alc`: Why do you think it is IO?
00:09:31 <jle`> do you mean, you want to write `ContT () Maybe a` instead ?
00:10:04 <iqubic> Grrr.... I don't like slow code.
00:10:55 <dminuoso_> alc`: Generally, a monad transformer takes the effect of one monad (this is sometimes called the precursor monad), and takes another (base) monad, and imbues it with the effect of the precursor monad, such that you get a new monad in return.
00:11:57 <dminuoso_> So mixing two monad effects is precisely the point of monad transformers.
00:15:30 <jle`> can you tell us what you are trying to do with cont and io and maybe ?
00:15:46 <jle`> without knowing what you want to use (the interface you are trying to get), it's not really possible to give any advice
00:33:19 <jonathan_> Is there any way to pass a custom error text to hspec's shouldBe? https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#v:shouldBe
00:33:57 <jonathan_> ==is there a similar function that takes a custom error message, or is there any other recommended approach?
00:34:57 <dminuoso_> jonathan_: You can throwIO a HUnitFailure yourself
00:35:38 <dminuoso_> jonathan_: shouldBe is just a non-operator for (@?=) which merely tests two things for equality, and throws an appropriate HUnitFailure
00:36:42 <dminuoso_> jonathan_: If you merely want to include some bits, you can use assertEqual, which takes a message prefix 
00:36:49 <dminuoso_> jonathan_: https://hackage.haskell.org/package/HUnit-1.6.0.0/docs/src/Test.HUnit.Lang.html#assertEqual
00:37:39 <dminuoso_> Don't get sidetracked by the deepseq, it might as well just read: when (actual /= expected) $ E.throwIO (HUnitFailure location $ ExpectedButGot prefaceMsg expectedMsg actualMsg))
00:39:21 <jonathan_> okay, I'll look into it. ty! :)
00:53:53 * hackage command-qq 0.3.1.0 - Quasiquoters for external commands  https://hackage.haskell.org/package/command-qq-0.3.1.0 (MatveyAksenov)
01:21:22 <Taneb> :t foldr ((<|>) . pure) empty
01:21:25 <lambdabot> (Foldable t, Alternative f) => t a -> f a
01:21:30 <Taneb> Does this exist anywhere?
01:21:40 <merijn> Taneb: "asum . map pure"?
01:21:51 <Taneb> merijn: that's what I'm currently using
01:22:26 <merijn> I don't think there's anything shorter
01:22:51 <merijn> Doesn't seem very common as for most Alternative instances that's utterly silly
01:23:49 <Solonarv> yeah, [] and its ilk are the only ones I can think of where that isn't silly
01:24:19 <iqubic> Wouldn't that be the same as "head . toList" in most cases?
01:24:20 <boxscape> > [1,2] <|> [3,4]
01:24:23 <lambdabot>  [1,2,3,4]
01:24:56 <Taneb> I think it's useful for anything that backtracks
01:25:13 <iqubic> > (asum $ map pure [1..10]) :: [Int]
01:25:15 <merijn> Taneb: Pure always succeeds
01:25:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:25:23 <iqubic> Well, that's kinda silly.
01:25:23 <Taneb> merijn: yes but things later on might not
01:25:52 <merijn> Taneb: I don't think any Alternative backtracks like that?
01:26:08 <iqubic> Taneb: Yes, but you are mapping pure over all the elements, so it's kinda silly.
01:26:25 <alc`> jle`: dminuoso_ https://paste.ubuntu.com/p/jnRsSsrF48/
01:26:42 <alc`> main :: IO ()
01:26:42 <Taneb> :t foldr ((<|>).pure) empty [1..10] >>= \x -> guard (x >= 3)
01:26:44 <lambdabot> (Monad m, Alternative m) => m ()
01:27:08 <Taneb> > foldr ((<|>).pure) empty [1..10] >>= \x -> guard (x >= 3) >> pure x :: [Int]
01:27:10 <lambdabot>  [3,4,5,6,7,8,9,10]
01:27:15 <iqubic> > [1..10] >>= \x -> guar (x >= 3)
01:27:18 <lambdabot>  error:
01:27:18 <lambdabot>      â€¢ Variable not in scope: guar :: Bool -> [b]
01:27:18 <lambdabot>      â€¢ Perhaps you meant â€˜guardâ€™ (imported from Control.Monad.Writer)
01:27:33 <iqubic> > [1..10] >>= \x -> guard (x >= 3)
01:27:36 <lambdabot>  [(),(),(),(),(),(),(),()]
01:27:42 <Taneb> merijn: I'd be using this with a MonadPlus ultimately
01:28:15 <alc`> jle`: I'd like print that Just x in ContT () IO a
01:28:28 <Solonarv> Taneb: in fact I was under the impression Alternative is explicitly supposed to *not* backtrack
01:28:34 <Solonarv> as in, x <|> empty = x
01:28:50 <Solonarv> oh wait I see what you mean, I think
01:29:21 <Taneb> Solonarv: this to use as somewhere to backtrack *to*
01:32:51 <alc`> jle`: flip C.runContT return $ do { lift $ liftIO $ print (Just n >>= return . (+1)) }
01:34:48 <iqubic> alc`: What is the purpose of this code? What are you using this code to compute?
01:35:23 <alc`> iqubic: know how to use multiple monads
01:35:50 <iqubic> So your only goal here is to learn how to use multiple monads at the same time?
01:37:28 <tdammers> I think "learn to use multiple monads" isn't a very useful approach
01:37:34 <iqubic> I feel like Cont and Conduit here are just obfuscating the code and making it harder to learn the underlying cocepts.
01:38:03 <tdammers> or is this about understanding monad transformers?
01:38:27 <iqubic> Well, also that. I didn't learn about monad tranformers until I had a concrete use for them.
01:38:37 <tdammers> in which case I would suggest looking at more "vanilla" transformers, implementing a few of them yourself, and develop an intuition for the general concept of a monad transformer through that route
01:38:44 <tdammers> e.g. StateT, ExceptT, that kind of stuff
01:39:16 <tdammers> maybe even just start with ReaderT
01:39:26 <alc`> ok
01:39:40 <iqubic> Well, you could start with MaybeT. That would be the easiest. Newtype MaybeT m a = MaybeT {unMaybeT :: m (Maybe a)}
01:40:01 <tdammers> yeah. MaybeT or ReaderT should be the easiest.
01:40:24 <iqubic> And then you'd have "instance Functor (MaybeT a) where"
01:40:56 <merijn> Man, I'm...what, 12 years into my haskell career and I *still* need to do a triple take when I see ContT
01:41:19 <merijn> Talk about unnecessarily complicated starting points for your exercises :p
01:41:37 <iqubic> I'm at 3 years, and ConnT confuses the hell out of me.
01:42:05 <merijn> @quote and.it.works
01:42:05 <lambdabot> danharaj says: All I have to do is remove me from the program and it works.
01:42:11 <merijn> ah, wrong quote...
01:42:32 <merijn> @quote autrijus and.it.works
01:42:32 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
01:42:32 <lambdabot> just don't know what it means.
01:42:53 <merijn> Story of my life, any time I use ContT :p
01:43:07 <tdammers> "so don't" :D
01:43:54 <iqubic> To be fair, I cont handle it.
01:43:59 <Rembane> That's almost all of my AoC solutions 
01:44:10 <merijn> tdammers: It's so useful sometimes, though!
01:56:45 <dminuoso_> Taneb: `getAlt . foldMap Alt`
01:57:27 <dminuoso_> Or possibly `foldMap (Alt . pure)` I guess
01:57:33 <dminuoso_> Im just a big fan of foldMap :(
01:57:40 <merijn> dminuoso_: Would have to be "getAlt . foldMap (Alt . pure)", but that's hardly cleaner or shorter
01:57:48 <dminuoso_> Right
02:00:53 * hackage hasbolt-extras 0.0.1.1 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.1.1 (ozzzzz)
02:04:29 <iqubic> This is very similar to something I wrote today.
02:04:47 <iqubic> foldIf :: (m -> Bool) -> t m -> m
02:05:06 <iqubic> (Monoid m, Foldable t)
02:05:56 <merijn> oh, that looks related to one of my favourite functions, which I will campaign to add to base as soon as I figure out a good name
02:06:07 <merijn> i.e. "Monoid m => Bool -> m -> m"
02:06:12 <iqubic> Basically every single element failing the predicate is replaced with mepmty, and the you foldMap. But I wrote this to be a single pass through the list.
02:06:46 <merijn> iqubic: I use that approach heavily in cabal's GHC flag normalisation code. It's very nice :)
02:07:14 <iqubic> So that either gives you the same input you passed in, or mempty? Nice.
02:07:20 <merijn> iqubic: Yeah
02:07:32 <merijn> iqubic: I just can't figure out a good name
02:07:36 <iqubic> f True = const mempty
02:07:42 <iqubic> f False = id
02:07:54 <iqubic> Or the other way around, depending on what you want.
02:08:02 <merijn> I've been using mif or something for now
02:08:11 <iqubic> What is mif?
02:08:25 <iqubic> monoidal if?
02:08:26 <merijn> iqubic: The name I used for that function, but it's not great :p
02:08:30 <iqubic> Ah. I see.
02:08:57 <iqubic> And my implementation would work, except it might not be the best one.
02:09:12 <iqubic> mif False _ = mempty
02:09:17 <iqubic> mif True m = m
02:09:21 <iqubic> Or something.
02:09:54 <iqubic> That's the same as the other version, just with True now being the case that gives you id.
02:14:26 <iqubic> I would love to have "select :: [a] -> [(a, [a])]" in base
02:14:47 <boxscape> what would that do?
02:15:28 <iqubic> give you all the possible ways to select a single item from the list.
02:16:16 <iqubic> each pair (a, [a]) is a different single item, coupled with the input list minus that element.
02:16:35 <boxscape> I see
02:18:00 <iqubic> This is an example of a problem where select is useful: https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html
02:56:41 <Guest_73> hello
03:02:45 <kuribas> hello
03:04:07 <dmj`> hello
03:24:05 <nil> in the writer monad, is there a better way to write `censor (const mempty) (listen foo)` ? i want to run foo and catch its output while preventing it to be output
03:25:58 <shachaf> runWriter?
03:26:55 <nil> indeed
03:28:58 <nil> that doesn't really work in my case though, because i have a WriterT layer in the middle of a monad stack
03:31:03 <shachaf> lift and runWriterT?
03:31:13 <shachaf> Oh, in the middle.
03:32:01 <nil> i'd need to also runStateT, which is cumbersome
03:32:30 <shachaf> Yes, good point.
03:34:54 <nil> alright, `conceal = censor (const mempty) . listen` then.
05:46:31 <tabaqui1> do you know a parser that can deal with file handles?
05:46:48 <dminuoso_> file handles?
05:46:50 <tabaqui1> using seek call or so
05:46:58 <dminuoso_> In linux a file handle is just a number.
05:47:34 <tabaqui1> yes, but it makes sense to call seek and read on it, so it is not just a number
05:47:57 <tabaqui1> I mean, some applicative parser for files
05:48:49 <mniip> you mean something that would handle buffering for you?
05:49:08 <mniip> are you parsing something that would not fit in memory?
05:49:32 <mniip> and that you would also need to backtrack over, enough that the backtracked portion would, again, not fit in memory?
05:49:48 <mniip> if not, you can probably get away with some conduit parsers
05:49:52 <tabaqui1> sort of; not really; sort of
05:50:24 <tabaqui1> I want to parse a file with a lot of sections distributed across it
05:50:34 <tabaqui1> addresses of these sections are distributed too
05:50:47 <mniip> are you parsing something like ELF
05:50:49 <MarcelineVQ> protobufs?
05:51:03 <tabaqui1> PE to be precise
05:51:09 <mniip> yeah that makes more sense
05:51:17 <mniip> and I think applicative parsers are a poor choice here then
05:51:48 <mniip> applicative parsers are for context free grammars, which PE is not
05:51:54 <mniip> at least not in spirit
05:52:02 <dminuoso_> tabaqui1: Is conduit-parser possibly an option?
05:52:11 <dminuoso_> err, conduit-parse
05:52:53 <tabaqui1> dunno, I didn't work with conduit before
05:53:06 <tabaqui1> I don't see a rich api in conduit-parse library now
05:53:27 <dminuoso_> tabaqui1: Well its just an adapter for `parsers`
05:53:49 <merijn> dminuoso_: He seems to want to be able to skip back and forth on demand, conduit-parse does nothing like that
05:53:58 <dminuoso_> Mmm
05:54:00 <merijn> That's just for parsing a stream of invidual things
05:54:11 <tabaqui1> yes, and debugging utilities like lookAhead and getCurrentPosition
05:58:26 * tabaqui1 is afk
05:58:54 <dminuoso_> zincy: https://gist.github.com/dminuoso/73d943f533f65c0898b6acfc5f61e8e0
07:00:53 * hackage primitive-unaligned 0.1.1.1 - Unaligned access to primitive arrays  https://hackage.haskell.org/package/primitive-unaligned-0.1.1.1 (andrewthad)
07:08:40 <pta2002> I have a function that's in the form of a -> IO a
07:08:48 <pta2002> and I have another one that takes in an a -> a
07:08:58 <pta2002> is there any way I can pass the first one into the second?
07:09:20 <Rembane> :t (>>=)
07:09:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:09:30 <merijn> pta2002: is 'a' a type variable?
07:09:36 <merijn> Or some unnamed type
07:09:39 <merijn> Rembane: Not really
07:09:57 <pta2002> merijn: the second one is a -> a
07:10:00 <pta2002> so yeah
07:10:08 <dminuoso_> Juicy! I think I can use ContT! :)
07:10:22 <dminuoso_> A few nested `withR $ \r -> ...` things getting out of hands.
07:10:23 <Rembane> merijn: I saw that when I saw the types. 
07:10:43 <merijn> pta2002: You could try and turn "a -> IO a" into "IO a -> IO a", which would fit into "a -> a", although it might not do what you want :p
07:11:18 <merijn> pta2002: Have some more context? What's the function that takes "a -> a"?
07:11:25 <Taneb> pta2002: there are lots of different ways those two pieces can fit together
07:12:46 <Taneb> Oh! Rereading it, I think the answer is "no"
07:13:41 <cdunklau> pta2002: so you want to call the `a -> IO a` function, and pass its result into the `a -> a` function?
07:13:55 <pta2002> merijn: it's a function from gloss, the graphics thing
07:14:02 <pta2002> frankly i hate it but i have to use it for school
07:14:11 <pta2002> merijn: i want the update function to use io
07:14:19 <pta2002> for saving a file
07:14:35 <pta2002> so the 'a' in this case would be the game state
07:14:40 <pta2002> Could I put the IO inside the 'a'?
07:15:02 <pta2002> so like data GameState = State { ..., io = IO () } or something
07:15:10 <pta2002> that sounds like it's extremely hacky though
07:15:18 <pta2002> http://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss-Interface-IO-Game.html#t:Event basically, the play function
07:15:59 <merijn> pta2002: I mean, you certainly can simply put an IO action in a record if you want
07:16:08 <merijn> pta2002: They're just like any other value
07:16:18 <pta2002> yeah but would it work
07:16:43 <merijn> pta2002: Well, putting it in doesn't do anything. You'd need to have some code that gets it out and runs it at some point
07:17:05 <merijn> Which, if you don't have access to an API that runs IO isn't possible
07:17:13 <pta2002> so
07:17:17 <pta2002> i can't do this
07:17:32 <merijn> I'm not sure what gloss' API looks like, so I can't say
07:17:46 <pta2002> wait
07:17:47 <pta2002> hold on
07:17:51 <pta2002> i just noticed there's a playIO
07:17:54 <pta2002> i think this will do
07:18:01 <pta2002> which takes in an a -> IO a
07:18:04 <pta2002> instead of a -> a
07:18:17 <merijn> :)
07:21:02 <pta2002> well thanks for helping my ruber duck debugging
07:23:57 <dminuoso_> Mmm, Generic + Aeson is quite hefty in terms of compilation. I'm at nearly 40 seconds for this module already.
07:24:36 <geekosaur> Generic's kinda begging for it, no?
07:26:21 <dminuoso_> I suppose so.
07:26:32 <sm[m]> hey all.. what's the best way to reliably clean up a socket file ? We were thinking create it with socket, convert to a handle with socketToHandle, and then use bracket to close the handle (or simply let it be closed automatically on exit). Is there a more direct way ?
07:26:58 <sm[m]> cf https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#v:socketToHandle , https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:bracket
07:28:58 <geekosaur> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#v:close ?
07:29:18 <geekosaur> but doing useful things with a stream socket probably wants you to make a Handle from it
07:29:19 <maerwald> sm[m]: what do you mean with more direct?
07:29:28 <geekosaur> that's more or less my question too
07:30:22 <maerwald> if you mean *reliably*, then don't use Control.Exception.bracket, because the handlers accept async exceptions afaik
07:30:29 <maerwald> so you want safe-exceptions
07:30:35 <sm[m]> I thought maybe there'd be a withSocket ... type of thing that would close it 
07:30:58 <sm[m]> I see withFdSocket but I'm not sure it does that
07:31:21 <geekosaur> it does
07:32:13 <sm[m]> hmm.. reliably of course, yes.. we just want to do the normal cleanup that you would expect so that if the program terminates abnormally no socket file is left
07:32:43 <geekosaur> sockets aren't files
07:33:08 <geekosaur> if the program terminates abnormally the socket is cleaned up by the kernel.
07:33:11 <merijn> geekosaur: Well, technically unix sockets are
07:33:15 <geekosaur> also true on windows since at least winnt
07:33:17 <maerwald> sockets are files
07:33:21 <geekosaur> but nothing cleans up unix sockets
07:33:26 <merijn> No, sockets *can* be files
07:33:45 <merijn> sockets (on unix) are file descriptors, but *file descriptors are not files*
07:33:53 <geekosaur> ^
07:33:57 <sm[m]> you know what I mean I think.. certainly on unix, a socket usually/often means there's something visible on the filesystem
07:34:01 <geekosaur> nope
07:34:04 <merijn> sm[m]: eh, no
07:34:10 <sm[m]> and we want to ensure that's cleaned up
07:34:12 <geekosaur> not for AF_INET
07:34:32 <merijn> sm[m]: UNIX sockets are the only thing that show up on the filesystem
07:34:34 <geekosaur> some OSes may expose a filesystem interface to sockets but the kernel maintains that illusion and cleans it up automatically on close
07:34:59 <merijn>  /proc might show sockets, but /proc is all lies
07:35:01 <geekosaur> liek you don't have to remove /proc/$$/0 before exiting
07:35:02 <sm[m]> ok thanks. I'm talking about UNIX sockets obviously
07:35:09 <sm[m]> geekosaur: I couldn't see how withFdSocket would clean up, from the source 
07:35:39 <geekosaur> sm[m], I looked too, it seems like it relies on garbage collection or someoen manually calling close
07:36:46 <geekosaur> not even shutdown on it. so you may have a socket descriptor hanging around a little longer than needed, but this will be cleaned up on exit
07:37:02 <dminuoso_> geekosaur: Ah I have an idea. I could use TH and splice it in manually.
07:37:15 <dminuoso_> GHC doesn't have some mode to splice in-place in the source file, does it?
07:37:23 <merijn> dminuoso_: Or handwrite things?
07:37:33 <geekosaur> on unix you might hit a file descriptor limit, although there are other limits you'd usually hit forst (number of sockets systemwide, or TIME_WAIT, etc.)
07:37:39 <merijn> dminuoso_: -ddump-splices + copy&paste :p
07:37:53 <dminuoso_> merijn: Sure. It just feels like GHC should have a mode to do that!
07:38:05 <dminuoso_> Some `-fsplice-inplace` of sorts
07:38:13 <merijn> I feel that "modifying source files in place" is something compilers should *never* do
07:38:28 <dminuoso_> Well we could start a discussion whether TH is something compilers should ever do.
07:38:36 <geekosaur> there used to be a zeroth package but internals changes kept breaking it
07:38:40 <Guanin> The problem sm[m] is asking about is for a pull request I sent him. Using an AF_UNIX socket obviously creates some file in the file system, but on termination of the program the file is not removed: https://gist.github.com/Amarandus/09a657976a357a509ec3d0cf3f7e581d
07:39:14 <geekosaur> right, removing such has never been automatic and this is a cross-language problem.
07:39:29 <geekosaur> basically you try to bind it and if it fails, remove the file and repeat
07:39:42 <geekosaur> unix api here is kinda annoying
07:39:58 <Guanin> Okay, but this might be a problem as it can overwrite/destroy files
07:40:06 <merijn> I don't think you should automatically remove on fail, that's racy and dangerous
07:40:12 <[exa]> dminuoso_: if you remove the (relatively well restricted) templating from compilers, someone will inevitably replicate m4 on that to add the missing feature
07:40:34 <merijn> The right solution is to fix resource management to remove the file upon exit (ctrl-c here)
07:40:42 <Guanin> merijn, and to add to this, deleting _after_ closing can still introduce a race condition: https://github.com/simonmichael/hledger/pull/1074#issuecomment-572476870
07:41:10 <Guanin> (This is the PR that caused the question in the first place)
07:41:18 <merijn> This problem sounds like one that requires referencing the bible for these things
07:41:32 <geekosaur> this is why I dislike the api for AF_UNIX
07:41:51 <merijn> "Advanced Programming in the UNIX Environment", 3rd edition. One of the world's most underutilised programming books >.>
07:42:43 <merijn> (Danger, reading this book may make examining source code for *nix programs traumatic on account of everyone doing everything willfully wrong)
07:42:44 <infandum> If I just want to use a single function from a library, is there something like you can do in R (Library::function(x))? Or do I still have to do the normal (import Library (x)) at the top?
07:42:59 <merijn> infandum: You still have to import
07:43:08 * sm[m] realises this simple sunlit pond extends into a vast ocean of darkness
07:43:14 <geekosaur> ghci has a hack, there used to be a language pragma for it
07:43:25 <infandum> err, import Library (function)
07:43:25 <merijn> sm[m]: Correct :)
07:43:37 <sm[m]> I wonder what is the simple practical thing to do that doesn't require hours of study and testing
07:43:53 <merijn> sm[m]: Give up? :)
07:44:04 <maerwald> use a high-level abstraction that works in 90% of the cases :P
07:44:05 <geekosaur> sadly they changed it so it was specific to ghci instead of a pragma :(
07:44:19 <sm[m]> I would certainly, but Guanin will never!
07:44:29 <geekosaur> not sure you can compile with -fimplicit-import-qualified to get it in a compiled program
07:44:43 <sm[m]> Guanin: catch exception when you try to create the socket, and delete it then ?
07:45:01 <merijn> sm[m]: That said, given the amount of terminal code in hledger I cannot recommend that book highly enough. It's a great reference book for that sorta thing
07:45:02 <geekosaur> this wants filesystems with transactions. or namespaces. neither of which I expect to happen :(
07:45:02 <infandum> merijn: Okay. Any changes to import syntax over the past year through extensions?
07:45:13 <maerwald> merijn: so whether a socket ends up being a file or something else is implementation-defined by the kernel?
07:45:28 <merijn> sm[m]: ctrl-c's signal handler normally raises an exception in the main thread, so if there's a proper exception-safe resource handling it Should Work (TM)
07:45:32 <Guanin> sm[m], I guess deleting after usage is more sane - that way, we clean up afterwards, but won't destroy anything (at least if the user does not do that type of file switching)
07:46:08 <Guanin> And given that renaming/moving files require write access in that directory, which also gives the user the ability to delete the file in the first place, maybe it's not that bad?
07:46:09 <geekosaur> infandum, PackageImports plus some keywords (http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export)
07:46:12 <sm[m]> yes. Plus, leaving junk on the filesystem would be crap
07:46:17 <merijn> maerwald: Well, more like "only unix sockets and named pipes ever appear on the filesystem and that sorta thing is defined by POSIX"
07:46:23 <geekosaur> maerwald, yes
07:47:01 <merijn> maerwald: See also, the book I mentioned ;)
07:47:45 <sm[m]> merijn: thanks for the book recommendation. Actually I've had very little hassle with terminals in hledger, ansi-terminal/vty/brick are marvellous. Except on windows of course
07:48:49 <merijn> It's very practical "Signal handling. This is what we want to do. This is the original UNIX API. Here's how it breaks in all sorts of subtle ways in the real world. Here is the modern/latest POSIX API. Here's how to do those things we wanted, but without the subtle failures from before. Here's a list of how various unices (BSD, macOS, linux, HP/UX, etc.) differ in their interpretation/support"
07:49:13 <merijn> Same for stuff like terminals, filesystem API, sockets, etc.
07:50:06 <sm[m]> ok thank you all, I guess we'll try some more stuff
07:50:10 <geekosaur> Guanin, many programs make a virtue of it: they use it as a lockfile. which has the same potentila failure modes because there isn't a way to limit others' ability to delete it beyond permissions, but at some point you will run into this anway
07:51:09 <maerwald> POSIX is marvellous. You can't do anything without breaking ~10 platforms.
07:51:35 <merijn> sm[m]: Oh! Also, so I have a unix socket domain process which has the same problem when the daemon crashes (well, really it's never crashed in the current version, but sometimes my machine reboots :p)
07:51:46 <merijn> sm[m]: So I asked the tmux guys how they manage this in tmux
07:52:00 * geekosaur kinda misses when mode 0 directories worked as firewalls, before someone came up with bind mounts
07:52:06 <merijn> sm[m]: I didn't get around to investigating this yet, but they pointed me to "there is a lock, look at client.c:client_get_lock also the loop in client_connect" in the tmux code
07:52:41 <merijn> maerwald: Actually, posix works surprisingly well and portable. Unfortunately, no one ever follows posix because the system's manpages never make clear which bits are posix and which bits are extensions to posix
07:53:02 <maerwald> I just broke ghcup, because mac doesn't have '-T' for 'ln'
07:53:04 <merijn> maerwald: Which the book does very clearly, which is invaluable
07:53:05 <maerwald> ...
07:53:27 <merijn> maerwald: Most likely bsd won't have -T either, then
07:53:32 <geekosaur> actually I find increasingly that I can't trust POSIX because they'll randomly remove stuff to make manufacturers happy
07:53:34 <maerwald> yeah, but '-F'
07:53:46 <geekosaur> it's not a technical standard at its heart, it's a marketing standard
07:53:47 <merijn> maerwald: People also like to confuse "posix" and "GNU coreutils"
07:53:53 <maerwald> and there's really no useful shell checking tool that checks for posix compliance
07:54:24 <geekosaur> so after nearly a decade they ripped most of the ksh-related stuff out of POSIX sh to make some unix vendor happy
07:54:41 <sm[m]> maerwald: I have those mac/linux/bsd command flag issues continually, increasingly moving to pure haskell shake files to avoid them
07:54:43 <geekosaur> [[ ]] was useful while it lasted, it fixed a number of annoyances with [ ]
07:55:11 <maerwald> sm[m]: I'll do that once I can build fully static binaries with haskell :P
07:56:13 <geekosaur> runghc :Ã¾
07:57:06 <maerwald> that requires ghc...
07:58:56 <geekosaur> tbh in this situation I use perl or python, rather than fight with command line flags or other issues (e.g. how do you do a safe and portable lockfile solely in the shell?)
07:59:07 <solonarv> geekosaur: I think that's the first time I've seen someone use thorn that way
08:01:09 <maerwald> geekosaur: docker run -ti --rm alpine python
08:01:17 <maerwald> will error ;P
08:03:47 <maerwald> and then you probably have to support python2 and python3 to be "portable"
08:03:57 <maerwald> then figure out whether the distro installed python2 and python3 symlinks
08:04:07 <maerwald> and whether 'python' pointy to python2 or python3
08:04:31 <maerwald> and then get struck by subtle differences between python3.5 and python3.8?
08:05:28 <maerwald> I think perl is more reliable here, but who wants to code in perl...
08:05:59 <mycroftiv> blog about how I ended up thinking that haskell was creating infinite mathematical minds inside my computer to teach humans about love: https://doc.9gridchan.org/blog/200108.infinite.searches
08:15:36 <tomjaguarpaw> Cabal inconsistency: On one machine I can "cabal v2-install" and it works fine.  On the other it says "there are no executables in targets: ." even though there is *only* an executable in my cabal file.  Does anyone know why this is happening?
08:15:55 <tomjaguarpaw> The two machines have identical setups AFAICT
08:15:58 <sm[m]> maerwald: my shake files are stack scripts, so in general all that's needed is download stack binary, run ./Shake.hs. I know this is completely impossible for you though :)
08:16:09 <tomjaguarpaw> (cabal-3.0, ghc-8.6.5 from hvr's ppr)
08:16:09 <MarcelineVQ> targets: .   is kind of suspicious looking
08:16:23 <merijn> tomjaguarpaw: Are they the same version of cabal-install?
08:16:43 <merijn> tomjaguarpaw: Pretty sure v2-install was basically unimplemented in several versions before 3.0
08:17:04 <merijn> I think 2.4 was the first version where it worked and I'm not even sure of that
08:17:11 <maerwald> sm[m]: yes, it is nicely portable if ghc toolchain is already installed. But I still have the feeling that shake is overkill for most tasks and I would rather have portable Makefiles.
08:17:32 <tomjaguarpaw> merijn: They are both cabal-3.0 from hvr's ppr (although strangely they have different md5sums ...)
08:17:48 <maerwald> sm[m]: e.g. if all or most of your targets are phony, then why use shake...
08:17:57 <merijn> maerwald: Depends, if your project already has haskell in there then that barrier is much lower :)
08:18:03 <sm[m]> stack installs the ghc toolchain, that's why I mention it
08:18:23 <maerwald> and stack bootstraps itself via a shell script :P
08:18:48 <sm[m]> or a windows binary
08:18:48 <merijn> tomjaguarpaw: Same cabal.project file and no cabal.project.local?
08:18:56 <maerwald> merijn: there are so many problems with signal handling in shake...
08:19:00 <maerwald> make doesn't have those problems
08:19:08 <sm[m]> there's really no simpler install method that can be relied on on all the major platforms.
08:19:18 <merijn> maerwald: There are so many problems with signal handling in literally every application that attempts to handle signals
08:19:30 <maerwald> well, but make works correctly
08:19:46 <maerwald> shake just leaves processes around most of the time, whatever you do
08:19:51 <merijn> maerwald: I mean, the python MPI bindings will just hard hang everything indefinitely because of stupid choices in the python interpreter
08:19:58 <tomjaguarpaw> merijn: Ohhh, I have a cabal.project.local in the one that works.  Where did that come from?  I was just assumuing I would build from projectname.cabal.
08:20:11 <merijn> tomjaguarpaw: Did you run v2-configure at any point?
08:20:21 <inkbottle> I've verified the types, they are perfect, perfect types... I can't understand why ghc doesn't want to agree: http://paste.debian.net/1125338/
08:20:21 <merijn> Or configure, I suppose with 3.0
08:20:34 <maerwald> https://github.com/ndmitchell/shake/issues/169
08:20:36 <sm[m]> maerwald: I love make, but my experience is (a) the unix tools you call with it are incompatible and (b) make itself is too squirrelly and arcane once you start doing complex things
08:20:45 <merijn> inkbottle: It would help to include GHC's error :)
08:20:50 <maerwald> sm[m]: make has functions!
08:20:58 <maerwald> except, most ppl maybe don't know :P
08:21:01 <merijn> maerwald: Correction *g*make has functions
08:21:07 <inkbottle> merijn: I do that
08:21:07 <tomjaguarpaw> merijn: I don't recall if I ran `v2-configure`.  I assumed it was no longer necessary ... things seem to work without it.
08:21:09 <sm[m]> right
08:21:16 <merijn> If you standardise on gmake, fine. But not all make is gmake
08:21:31 <MarcelineVQ> some of them are cmake
08:21:40 <MarcelineVQ> or scons, cmake for cool people
08:21:49 <merijn> tomjaguarpaw: v2-configure is optional, yes. You can use it to create a persistent configuration different from the default (like --enable-profiling)
08:21:55 <merijn> maerwald: cmake is not a make
08:21:59 <maerwald> lol
08:22:01 <MarcelineVQ> :D
08:22:11 <merijn> eh, s/maerwald/MarcelineVQ
08:22:11 <maerwald> hey, but cmake works well on windows
08:22:17 <merijn> EH
08:22:22 <maerwald> it even has a GUI there
08:22:25 <merijn> I think you mean "CMake works equally bad on windows"
08:22:43 <merijn> Literally every CMake setup I've encountered is full of junk
08:22:47 <maerwald> you can click through random stuff (like usually on windows)
08:22:56 <sm[m]> nothing is as portable as a (portable) pure haskell script. It requires annoying costly bootstrapping, but at least stack makes that simple and mechanical. It's a trade off. That's why I have both a makefile and a shakefile :)
08:23:30 <maerwald> depends what you mean with portable 
08:23:44 <maerwald> "runs on all platforms" or "works correctly on all platforms" may be a huge gap :P
08:23:53 <inkbottle> merijn: With first error http://paste.debian.net/1125340/
08:24:05 <tomjaguarpaw> merijn: Hmm, well, getting rid of cabal.project.local doesn't make the behaviour the same 
08:24:15 <merijn> tomjaguarpaw: Then I'm confused :)
08:25:05 <tomjaguarpaw> merijn: I'll have to see what happens with a completely fresh checkout.
08:25:16 <merijn> inkbottle: tbh, I'd add a where block and split notDelim into several bindings in that where block (with type signatures), because as it is, it's rather unreadable
08:25:42 <inkbottle> I agree
08:26:33 <merijn> In general if you and GHC disagree on the types splitting it into as many tiny (named and type annotated) definitions as possible is the way to go
08:26:48 <AWizzArd> In my webserver I have a data type D with multiple fields. One of which is a (Map Int Foo). Now a client expects exactly such a type D as JSON, with the exception of that map. The client wants a (Set Foo) instead.
08:26:52 <AWizzArd> What is more ideomatic here? Create a copy of this type but use a Set instead? Or wrap it in a newtype and not inherit ToJSON but instead write my own implementation, which renders that Map into a Set? Or something else?
08:27:56 <solonarv> you can just write a standalone function to convert it to the JSON you want
08:28:17 <glguy> You don't need a ToJSON instance to generate a JSON Value
08:29:01 <AWizzArd> glguy: sounds good, in principle, though what return type should I then use in Servant?
08:29:16 <solonarv> Value would work
08:29:24 <solonarv> (that's the type of a JSON value)
08:29:58 <AWizzArd> The generic Value would totally work, but it might give the reader the impression that any JSON could be returned.
08:31:43 <sm[m]> btw, thanks for the https://github.com/ndmitchell/shake/issues/169 link maerwald, that's useful to me
08:35:54 <tomjaguarpaw> Aha, hvr's ppr updates its contents from git, it seems: I had two different versions of cabal-install-3.0 (3.0+git20191223.2.9169832-6~18.04 and 3.0+git20190421.1.38969a0-6~18.04
08:36:35 <tomjaguarpaw> merijn: ^^ I assumed they were from a fixed release.
08:37:46 <tomjaguarpaw> Maybe I should switch to ghcup
08:37:53 * hackage ghcid 0.8.1 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.8.1 (NeilMitchell)
08:45:23 * hackage optparse-generic 1.3.1 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.3.1 (GabrielGonzalez)
08:57:53 * hackage map-reduce-folds 0.1.0.4 - foldl wrappers for map-reduce  https://hackage.haskell.org/package/map-reduce-folds-0.1.0.4 (adamCS)
09:11:16 <AWizzArd> I have duplicate field names. I want to implement an instance of a typeclass. In that one method that I want to implement I now have to explicitly tell what type my value has repeatedly:     foo u = [name (u :: User), city (u :: User), ...]
09:11:36 <AWizzArd> Can I somehow allow for an improved type inference?
09:12:09 <AWizzArd> It is clear that u is a User. I tried ScopedTypeVariables   foo (u :: User) = [name u, city u, ...]
09:12:12 <AWizzArd> But this also did not work.
09:12:44 <AWizzArd> instance Foo User where    foo u = [name u, city u, ...]     <- this is what I would ideally have expected.
09:13:51 <Phyx-> maerwald: has nothing to do with shake, it's mintty
09:14:11 <Phyx-> people shouldn't use *windows* programs under a cygwin process and expect windows signal handling to work
09:14:19 <Phyx-> it's even called out explicitly in the documentation of mintty
09:15:45 <Phyx-> so you want your signal handlers to work, use either brand new version of cygwin which has support for conpty, or use an actual windows shell as your host
09:17:23 <berndl> AWizzArd: how about foo u = let (u' :: User) = u in [name u', ...
09:17:28 <maerwald> Phyx-: I wasn't talking about windows
09:17:37 <maerwald> the unix signal handling is borked as well
09:19:23 <maerwald> in fact, it doesn't do any real signal handling, it just catches exceptions: https://github.com/ndmitchell/shake/blob/c3f08f906f41ec62e813a0898897f7f58d804e17/src/General/Process.hs#L159-L160
09:20:18 <AWizzArd> berndl: unfortunately this doesnâ€™t prevent the "ambigious occurrence" error.
09:21:15 <Phyx-> maerwald: well that ticket *was*
09:21:34 <maerwald> the discussion entails unix as well
09:21:36 <merijn> AWizzArd: Are the different datatypes in different modules?
09:22:17 <AWizzArd> merijn: no, in the same Module
09:22:46 <tomjaguarpaw> Do people here use hvr's Ubuntu ppr?  I've just noticed that the version of cabal-3.0 is a git-latest.  Is that what most people prefer?
09:24:12 <solonarv> AWizzArd: pattern matching instead of accessor functions?
09:24:23 <solonarv> foo User{name,city} = [name, city]
09:24:33 <solonarv> (with NamedFieldPuns)
09:24:53 * hackage Frames-map-reduce 0.3.0.0 - Frames wrapper for map-reduce-folds and some extra folds helpers.  https://hackage.haskell.org/package/Frames-map-reduce-0.3.0.0 (adamCS)
09:24:57 <dminuoso_> Or use RecordWildCards together with:
09:25:04 <maerwald> tomjaguarpaw: are you sure you installed cabal-install-3.0 and not cabal-install-head?
09:25:32 <dminuoso_> Or mmm, perhaps TypeApplications is an option.
09:26:06 <solonarv> I don't like RecordWildCards because I prefer knowing exactly what is being brought into scope, but sure, it also works
09:26:34 <dminuoso_> solonarv: RecordWildCards not for `f Foo{..} = ..` but `f = Foo{..}` instead
09:26:42 <tomjaguarpaw> maerwald: Yes, see the cabal-install-3.0 entry on https://launchpad.net/~hvr/+archive/ubuntu/ghc, it's a version from 2019-12-23
09:26:48 <AWizzArd> solonarv: I don't want positional matching over 12 fields.
09:27:15 <solonarv> dminuoso_: oh, I'm fine with it for construction
09:27:28 <solonarv> AWizzArd: this is not positional matching
09:27:34 <dminuoso_> Mmm
09:27:47 <solonarv> User{name,city} is sugar for User{name=name, city=city}
09:27:53 <maerwald> tomjaguarpaw: hm, then you might want to use https://downloads.haskell.org/~cabal/cabal-install-3.0.0.0/
09:28:45 <tomjaguarpaw> maerwald: Yes, this may be the best idea
09:29:02 <tomjaguarpaw> maerwald: Thanks!
09:29:18 * solonarv is very happy with ghcup
09:41:02 * dminuoso_ prefers nixos
09:44:37 <maerwald> ghcup is not a distro :P
09:45:31 <glguy> maerwald: Could you create an issue ticket about that? :-p
09:45:44 <maerwald> (there's a hidden --emacs-mode option...)
09:46:11 <glguy> ghcup is missing a lot of my favorite packages
09:46:26 <dminuoso_> Indeed, ghcup should at the very least install m4
09:46:49 <glguy> If I run: 'ghcup install bad', will it install ghc-8.6.1?
09:47:00 <maerwald> the first tag that matches
09:47:18 <glguy> that's handy
09:47:30 <maerwald> it's a little weird
09:48:04 * tomjaguarpaw does not like implicit behaviour
09:48:25 <glguy> Now you've made that explicit
09:48:37 <xeno> hi, when creating a new project with the haskell plugin in intellij, it asks me to select SDK...  I've installed haskell through homebrew, so what would be the right thing to select here? 
09:48:40 <dminuoso_> Tag in what sense?
09:48:53 <xeno> I have /usr/local/bin/ghc -> ../Cellar/ghc/8.8.1/bin/ghc
09:48:57 <dminuoso_> xeno: The right thing would be to uninstall haskell from homebrew and install it properly.
09:49:00 <glguy> ghcup has some versions tagged like: bad, recommended, latest
09:49:18 <glguy> and also tags for the current minor revision: 8.0, 8.2, 8.4, 8.6, 8.8
09:49:25 <xeno> dminuoso_: sounds good to me, doing that now 
09:49:28 <dminuoso_> xeno: Use ghcup :)
09:49:37 <glguy> so you can run: ghcup install latest; and you'll get the latest ghc
09:49:53 <dminuoso_> glguy: I see, what's with that `bad` tag?
09:50:10 <glguy> dminuoso_: 8.6.1 is labeled "bad" because you shouldn't use it
09:50:12 <dminuoso_> glguy: And I take it these tags are stored in the ghcup mirror? Or are they tags from some git repository?
09:50:40 <maerwald> dminuoso_: https://gitlab.haskell.org/haskell/ghcup/raw/master/.available-versions
09:50:46 <dminuoso_> Holy, I missed tha tbug!
09:51:45 <glguy> maerwald: ghcup seems to change much faster than its version number
09:52:03 <maerwald> agile
09:53:39 <dminuoso_> I have a Text and want to base64 encode all non-ascii characters, is there a different way than `decodeUtf8 . Data.ByteString.Base64.encode . encodeUtf8`?
09:53:58 <dminuoso_> (I honestly dont care which encoding is used internally)
09:55:03 <solonarv> you want to base64 encode *only* the non-ascii characters?
09:56:03 <dminuoso_> Thanks for the question, I phrased it inaccurate.
09:56:19 <dminuoso_> I want to escape all characters that are not alphanumeric from ASCII
09:56:23 <dminuoso_> At the least.
09:56:31 <dminuoso_> Gah
09:56:39 <dminuoso_> Okay fine. Ill just generate a freaking GUID for this.
09:56:54 <dminuoso_> LDAP and all its implementations are an abomination.
10:07:03 <djanatyn_> data BrowerSession { browserSession :: WDSession, runBrowser :: forall a. WD a -> IO a }
10:07:09 <djanatyn_> why does this datatype require RankNTypes?
10:07:24 <dminuoso_> Because it's a Rank2 type
10:07:34 <djanatyn_> why isn't this valid: data BrowserSession { browserSession :: WDSession, runBrowser ::: WD a -> IO a }
10:07:52 <dminuoso_> djanatyn_: Well first, that is not a syntactically valid data definition.
10:08:09 <glguy> djanatyn_: If you want to use a quantified type in a record you need to enable that extension
10:08:37 <dminuoso_> djanatyn_: assuming `data BrowserSession = BrowserSession { ... }` then `BrowserSession :: WDSession -> (forall a. WD a -> IO a) -> BrowserSession`
10:08:37 <glguy> djanatyn_: and type variables have to be introduced somewhere. You can't just use 'a' out of the blue
10:08:55 <glguy> (when declaring a new data type)
10:08:59 <solonarv> djanatyn_: the type of that constructor is 'WDSession -> (forall a. WD a -> IO a) -> BrowserSesssion'
10:09:05 <solonarv> this is a rank-2 type
10:09:06 <djanatyn_> glguy: but you can with function definitions, yes?
10:09:12 <dminuoso_> djanatyn_: Well yes
10:09:25 <dminuoso_> djanatyn_: Mostly because Haskell inventors chose *not* to make forall an explicit requirement.
10:09:46 <dminuoso_> djanatyn_: If you wrote `f :: a -> a` that implicitly means `f :: forall a. a -> a`
10:09:47 <djanatyn_> the forall is implicit for function definitions, but with record syntax you need to explicitly use (existential?) quantification
10:09:54 <djanatyn_> dminuoso_: got it
10:09:56 <glguy> djanatyn_: With type signatures all type variables are implicitly introduced at the type signature; but that doesn't work out for data declarations
10:10:15 <dminuoso_> I suppose with data declarations there's ambiguity whether it should be existentially quantified or universally.
10:10:20 <djanatyn_> i was looking at RankNTypes, but looking at Rank2Types is a little clearer for me
10:10:25 <glguy> You can introduce them like: data T a = ... or data T = forall a. C ... or data T = C (forall a. ...
10:10:36 <glguy> Rank2Types is an alias for RankNTypes now
10:10:50 <dminuoso_> That is, does `data Thing = Thing { unThing :: a }` mean `data Thing = forall a. Thing { unThing :: a }` or does it mean `data Thing = Thing { unThing :: forall a. a }`
10:10:58 <dminuoso_> djanatyn_: ^- these two have different meanings.
10:11:29 <dminuoso_> (The syntax is annoying and confusing, it's a bit clearer to see when looking at GADT-style equivalents)
10:13:00 * solonarv was about to mention GADT-style syntax as well
10:13:00 <djanatyn_> dminuoso_: thanks for the example, that clears up the ambiguity. let me try to convert my explicit forall data type to GADT-style
10:13:36 <dminuoso_> djanatyn_: Note you can use the extension GADTSyntax to merely enable the syntax without the other baggage.
10:13:49 <dminuoso_> It's a neat extension I often recommend to beginners. :)
10:14:17 <djanatyn_> data BrowserSession where browserSession :: WDSession; runBrowser :: forall a. WD a -> IO a
10:15:06 <solonarv> no, that is not correct
10:15:14 <inkbottle> empty :: Parser String == return "" ? (where type Parser = P.Parsec Void String, empty :: GHC.Base.Alternative f => f a)
10:15:42 <dminuoso_> djanatyn_: data BrowserSession where BrowserSession :: WDSession -> (forall a. WD a -> IO a) -> BrowserSession
10:15:49 <solonarv> inkbottle: no
10:15:51 <dminuoso_> Or, if you want field accessors
10:16:03 <solonarv> generally speaking, empty /= return x
10:16:16 <solonarv> (the only exception, I believe, is Proxy)
10:16:25 <djanatyn_> ah, sorry, mixed that up
10:16:30 <inkbottle> solonarv: but in that special case of parsers?
10:16:35 <dminuoso_> Gah I cant recall the syntax for field accessors in GADT syntax
10:16:45 <solonarv> inkbottle: nope
10:16:57 <solonarv> 'empty' is a parse that fails without consuming any imput
10:17:11 <inkbottle> right my bad
10:17:18 <inkbottle> thanks what I wanted to know
10:17:51 <dminuoso_> Ah shame
10:17:57 <solonarv> data BrowserSession where BrowserSession :: { session :: WDSession, runBrowser :: forall a. WD a -> IO a } -> BrowserSession
10:17:59 <dminuoso_> with field accessors you lose the benefit of GADTSynta.
10:18:04 <dminuoso_> That's a bummer
10:18:10 <dminuoso_> Wish it could have been
10:18:13 <dminuoso_> data Foo where Foo :: {someInt :: Int} -> {someChar :: Char} -> Foo
10:18:31 <inkbottle> so what is the null element then?
10:20:01 <solonarv> inkbottle: what do you mean by "null element"?
10:22:43 <dmwit> This question sounds like you are still thinking that `empty = return X` for some `X`, and wondering what the "null element" X is. But for parsers, `empty` and `return X` are always different, no matter what X is.
10:22:56 <dmwit> `empty` fails without consuming any input. `return X` succeeds without consuming any input.
10:23:12 <zebrag> yes, I'm confused
10:23:33 <zebrag> I'm looking for the seminal paper on parsers
10:23:44 <zebrag> got it
10:25:39 <zebrag> I'll see to that a little bit later
10:27:19 <zebrag> merijn: I did what you suggested, and after like an hour, I've replace a 'l' by a 'r', and that worked
10:33:35 <zebrag> When you do (someParser <|> return ""), the rhs doesn't have some "name" in Control.Applicative? Or Control.Monad?
10:34:01 <zebrag> maybe not
10:34:40 <solonarv> zebrag: why do you believe String should be treated specially?
10:36:21 <zebrag> I don't really know, some reminiscence of something I misunderstood the first time
10:39:46 <zebrag> many p = many1 p +++ return [] -- yes, nothing really specific (http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf)
10:41:19 <zebrag> Doesn't have a specific name
10:42:56 <solonarv> zebrag: ah, but this is still polymorphic!
10:43:11 <solonarv> many :: Alternative f => f a -> f [a]
10:47:06 <zebrag> solonarv: yes, but the (return []) has no specific mathematical signification
10:47:53 * hackage haskellish 0.2.0 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.2.0 (dktr0)
11:01:06 <solonarv> zebrag: it actually does, it's the identity element of a monoid
11:02:04 <solonarv> namely: mempty = pure @f (mempty @a); (<>) = liftA2 @f ((<>) @a)
11:29:53 * hackage hlint 2.2.6 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.6 (NeilMitchell)
11:40:24 * hackage BiobaseEnsembl 0.2.0.1 - Ensembl related datastructures and functions  https://hackage.haskell.org/package/BiobaseEnsembl-0.2.0.1 (FlorianEggenhofer)
11:46:23 * hackage cantor-pairing 0.2.0.0 - Convert data to and from a natural number representation  https://hackage.haskell.org/package/cantor-pairing-0.2.0.0 (identicalsnowflake)
11:47:05 <TheCommieDuck> Hey. Is there a nice way to shorten do { x <- get; someFunc (x ^. someField) (x ^. someOtherField) (x . some . nested. lenses ^. too) }?
11:47:45 <merijn> view + gets?
11:48:11 <solonarv> actually, 'view' already works on its own
11:48:45 <solonarv> its type is 'view :: MonadReader s m => Getting a s a -> m a'
11:49:32 <solonarv> shortened: liftA3 someFunc (view someField) (view someOtherField) (view (some . nested . lenses . too))
11:49:44 <solonarv> or use <$> <*> <*> instead of liftA3
11:49:49 <TheCommieDuck> ooh, neat. thanks
11:50:25 <TheCommieDuck> I wish I could one day understand the whole lifting thing rather than just blindly changing operators and whatnot until it compiles
11:52:23 * hackage linenoise 0.3.0 - A lightweight readline-replacement library for Haskell  https://hackage.haskell.org/package/linenoise-0.3.0 (ejconlon)
11:53:11 <TheCommieDuck> liftAx works, but applicative style doesn't. huh.
11:53:30 <solonarv> eh? what did you write, exactly?
11:53:51 <TheCommieDuck> oh no, neither work. hm.
11:54:49 <TheCommieDuck> so my actual example is do { w <- get; move (w ^. player) (w ^. firstRoom) }. I tried { liftA2 move (view player) (view firstRoom) }.
11:55:02 <solonarv> ooh, right
11:55:39 <oats> I think 'use' is what you want
11:55:46 <oats> lens has some nice functions for state stuff
11:55:48 <solonarv> no, 'use' is not relevant
11:55:50 <oats> no?
11:56:07 <TheCommieDuck> ...use doesn't flag up errors at the very least
11:56:20 <TheCommieDuck> (subbing 'view' for 'use')
11:56:22 <oats> move <$> (use player) <*> (use firstroom)
11:56:23 <solonarv> oh actually yes, you do want 'use' not 'view' 
11:56:24 <oats> like that?
11:56:40 <TheCommieDuck> thank you :)
11:57:04 <solonarv> I mixed up 'get' and 'ask', and mistakenly concluded that you were in a MonadReader rather than a MonadState
11:57:16 <solonarv> anyway, with 'use' this typechecks but doesn't actually *do* anything
11:57:25 <oats> ah :)
11:57:37 <TheCommieDuck> ..oh.
11:58:05 <solonarv> presumably the type of 'move' is something like 'MonadState Foo m => Player -> Room -> m ()', right?
11:58:07 <oats> oh, is move kleisli arrow?
11:58:59 <solonarv> in that case, the type of 'liftA2 move' is 'MonadState Foo m => m Player -> m Room -> m (m ())'
11:59:57 <oats> oh yeah, you're just gonna have to use bind then
12:00:10 <oats> I've done this too lol
12:00:18 <solonarv> no, you can still use this and just slap a 'join $' in front
12:00:23 <TheCommieDuck> move is something like that, yeah
12:00:53 <solonarv> so this would look like: join $ liftA2 move (use player) (use firstRoom)
12:01:06 <TheCommieDuck> (though I'm going round and round in circles with getting various State Foo, State (Foo, Bar), State (Foo, Baz) to all work together
12:01:29 <solonarv> Control.Lens.Zoom can help with that
12:01:56 <TheCommieDuck> I did just find zoom, yes - I still haven't quite grokked how to...integrate it into my helper functions and whatnot
12:02:21 <solonarv> slightly specialized type signatures follow:
12:02:49 <solonarv> zoom :: Lens' outer inner -> State inner a -> State outer a
12:03:03 <solonarv> zoom _1 :: State Foo a -> State (Foo, x) a
12:04:16 <TheCommieDuck> ...I've just realised I spent /hours/ writing helper methods to redo Zoom lmao
12:04:24 <oats> haha
12:04:31 <oats> this is the way
12:04:39 <TheCommieDuck> okay, time to shelve this move thing and go back and rewrite this stuff with zoom.
12:06:23 * hackage linenoise 0.3.1 - A lightweight readline-replacement library for Haskell  https://hackage.haskell.org/package/linenoise-0.3.1 (ejconlon)
12:10:54 <TheCommieDuck> ...am I right in thinking that the do block of a State a b isn't necessarily a sequence (b, a) -> (b, a) -> (b, a) ... -> (b, a) but instead (b, a) -> (c, d) -> (e, f) ... -> (b, a)? as in, I don't need to keep the same state or result type throughout?
12:11:29 <merijn> TheCommieDuck: You need to keep the same *type* of state with StateT
12:12:06 <TheCommieDuck> but...I don't need to keep the same result type?
12:12:19 <TheCommieDuck> (which is why get works at all?)
12:12:21 <merijn> :t (>>=)
12:12:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:12:51 <merijn> TheCommieDuck: Keep in mind that "m" there is 'StateT s Something" and 'a' is the result
12:13:13 <merijn> TheCommieDuck: (Which is the long-winded way of saying "no, you don't need to keep the same result type")
12:13:36 <TheCommieDuck> gotcha, thanks
12:14:23 <merijn> TheCommieDuck: And do notation and <- are just sugar for >>=
12:15:34 <TheCommieDuck> yep; I can understand >>= and >> but I can't quite ever think of it in terms of <-
12:16:02 <merijn> TheCommieDuck: The translation is fairly straightforward: https://en.wikibooks.org/wiki/Haskell/do_notation
12:16:46 <TheCommieDuck> straightforward, sure. can make my dumb brain understand it intrinsically, less so
12:16:48 <geekosaur> something <-     is the same as     >>= \something ->
12:17:08 <dmwit> :t mapStateT
12:17:10 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:17:23 * hackage climb 0.3.1 - Building blocks for a GHCi-like REPL with colon-commands  https://hackage.haskell.org/package/climb-0.3.1 (ejconlon)
12:17:25 <fog> so magnify is to change part of a monad transformer stack?
12:17:50 <solonarv> in short: do { foo; stmts } = foo >> do { stmts }, and do { x <- foo; stmts } = foo >>= \x -> do { stmts }
12:18:12 <geekosaur> point, I wrote that poorly
12:18:14 <solonarv> dmwit: that allows one to change the 'm', not the 's' as Zoom does
12:18:28 <fog> solonarv: right, its sugar not just for (>>=) and (>>) but also for lambda binding of variables
12:21:36 <fog> if you have a list of functions that can be composed together it needs to be a hetrogenous list of adjacently used types.... like, storing the intermediate types in a type list parameter to the hetrogenous "function list" and having the 2 of the stored function values refer to one of the values in the type list param
12:21:44 <fog> how does that fit with zoom?
12:23:47 <fog> just from the comment before about (s1,a) -> (s2,b) etc in a chain of changing states
12:24:40 <fog> seems like [(a->b),(b->c)...]
12:30:38 <dminuoso_> fog: What is `[(a->b),(b->c)...]` supposed to denote? A type? A value?
12:30:46 <fog> a list of functions
12:30:54 <dminuoso_> Lists are by definitions homogenous.
12:30:54 <fog> that can be composed together 
12:31:07 <fog> yeah sorry i shouldnt have used square brackets
12:31:41 <fog> wait, I can try and write it as a datatype, hang on
12:32:40 <fog> i was writing something where the hetrogenously typed values values could depend on the tail of the type param list
12:33:41 <fog> and then also to apply a defunctionalised type family, in this case HeadSym, so two adjacent values in the type list param can be used by the type function used to give the type of each of the stored values
12:34:35 <fog> ie, the value consed onto this type param list, and the head of the previously grown type list param
12:39:53 * hackage heart-core 0.1.0 - An opinionated library prelude in the UnliftIO style  https://hackage.haskell.org/package/heart-core-0.1.0 (ejconlon)
12:44:15 <jpcooper> Evening. What's the easiest way of having an Alternative instance provided as the Monoid instance to Data.Foldable ( fold )?
12:44:45 <solonarv> jpcooper: use 'asum'
12:45:07 <solonarv> no need to faff about with instances or anything
12:45:11 <solonarv> :t asum
12:45:13 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
12:45:22 <dminuoso_> jpcooper: Also checkout Alt
12:45:52 <dminuoso_> % :t getAlt . foldMap Alt
12:45:52 <yahb> dminuoso_: (Foldable t, Alternative f) => t (f a) -> f a
12:46:16 <jpcooper> Thanks both
12:46:53 <merijn> dminuoso_: That's strictly more work than asum :p
12:47:01 <solonarv> note: please don't use the 'getXXX . foldMap XXX' thing when there is a perfectly good function that already does the thing ;)
12:47:12 <dminuoso_> merijn: Shhh.
12:47:23 * hackage mmsyn7s 0.1.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.1.0.0 (OleksandrZhabenko)
12:47:31 <dminuoso_> merijn: foldMap and traverse are elegant weapons from a more civilized age.
12:49:07 <merijn> The future?
12:49:37 <dminuoso_> If they were from the future I would have quoted Back to the Future.
12:50:12 <jpcooper> This is relatively possible
12:50:29 <dminuoso_> "Wait a minute, Doc. Are you telling me you built a time machine...out of foldMap"
12:51:23 * hackage heart-app 0.1.0 - An opinionated app prelude and framework in the UnliftIO style  https://hackage.haskell.org/package/heart-app-0.1.0 (ejconlon)
12:52:45 <TheCommieDuck> okay, I'm probably missing something. I'm zooming into the first element of a state tuple, then looking something up in a Data.map record field with ix, accessing some field of the thing I look up, and setting it to a value. Yet after the zoom, the record field hasn't updated. am I missing something?
12:53:31 <jpcooper> Has someone written a nice type class defining a function (.) which allows one to write ((x . y) :: (a -> b -> c -> z)) for all (x :: d -> z) and (y :: a -> b -> c -> d), where no (d, z, a, b, c, d) are function types themselves, and y really is a function with an arbitrary number of arguments?
12:53:54 <TheCommieDuck> https://pastebin.com/RQvJZ7wt hopefully it's straightforward enough
12:54:01 <dminuoso_> jpcooper: should be easily possible
12:54:37 <jpcooper> dminuoso_: Yes. I was just wondering whether someone had done this already, given that it is a reasonable thing to want
12:54:41 <TheCommieDuck> (namely, it prints '1 2 1 2 2' instead of '1 1 1 1 1')
12:55:09 <dminuoso_> jpcooper: It would not be a reasonable API to present
12:55:37 <jpcooper> dminuoso_: Is it not as reasonable as the type of Text.Printf ( printf )?
12:55:53 * hackage blanks 0.3.0 - Fill-in-the-blanks - A library factoring out substitution from ASTs  https://hackage.haskell.org/package/blanks-0.3.0 (ejconlon)
12:56:01 <dminuoso_> jpcooper: Probably not
12:56:13 <dminuoso_> jpcooper: It require a similar implementation to that of a generic lift function, probably
12:56:33 <jpcooper> I am going to give it a go
12:57:09 <dminuoso_> jpcooper: If you want a hint, I can show you how lift could be implemented.
12:57:16 <fog> oh no, i have another type error....
12:58:34 <dminuoso_> jpcooper: In fact it doesn't even whether d, z, a, b, c or d are functions.
12:59:28 <fog> https://gist.github.com/fog-hs/df3498c205433723ca022c552c3849a4
13:00:38 <nickednamed> Hello all. I have a noob question regarding test-suites, cabal and executables/libraries. I'm trying to set a a mini-project with multiple executables, but I can't seem to get `cabal new-test` to work (builds fine though). Error message says "none of theIs it the case that I *must* only 
13:00:59 <nickednamed> damn, finger slipped..
13:01:51 <nickednamed> Error message says "no components available to build" Is it the case that I must use libraries instead of executables and expose library modules to the test-suite?
13:02:18 <fog> does it need to be the function of a class to recuse over the function list as it evaluated?
13:02:28 <nickednamed> Or can this be achieved with executables only?
13:02:42 <dminuoso_> nickednamed: Can you please gist the full output, including the command you invoked?
13:02:58 <fnurglewitz> hi, got some issues with some never-ending code, https://pastebin.com/Gs9RXYJL , anyone got any suggestion on why this happens? If the output from the command is shorter there's no issue
13:03:46 <jpcooper> dminuoso_: Yes please do give me a hint
13:04:21 <dminuoso_> jpcooper: https://gist.github.com/dminuoso/f55bcd0516849397df536657be529e1c
13:04:27 <fog> i guess so since the function basically matches on the type, since its basecase is when the type list param is length 2
13:04:41 <jpcooper> dminuoso_: Thank you
13:04:50 <nickednamed> none of the
13:04:51 <dminuoso_> jpcooper: It'd be the same implementation, essentially. There's a couple other tricks to implement it though, this is not the only one.
13:05:48 <jpcooper> Okay
13:06:11 <geekosaur> fnurglewitz, other languages call this the open3 problem
13:06:24 <nickednamed> https://github.com/haskell/cabal/issues/4869#issuecomment-493726320
13:06:29 <nickednamed> not mine, but identical
13:07:13 <geekosaur> if output is larger than an OS pipe buffer then the process will block waiting for your program to read, but your program is blocked waiting for it to exit
13:07:14 <fnurglewitz> geekosaur: open3 problem? Initially i thought it was a buffering issue so I tried to disable the buffering but it doesn't help
13:07:30 <geekosaur> you can't diable the kernel's pipe buffers
13:08:10 <fog> ah ok, this works; https://gist.github.com/fog-hs/df3498c205433723ca022c552c3849a4
13:08:17 <dminuoso_> nickednamed: No I wwant yours.
13:08:18 <geekosaur> pipes expect multitasking, i.e. both ends' programs are running at the same time, not blocked waiting for each other.
13:08:33 <dminuoso_> nickednamed: If its not exactly like your point, it's may not even be relevant, may it? :)
13:08:36 <dminuoso_> *like your output
13:09:30 <geekosaur> in Haskell, you would normally have another thread reading the output from the program and perhaps writing it to a Chan for the main thread to read after the process exits. but it depends on what else you'll be doing with the data or whether you intend to interact with it
13:10:17 <geekosaur> (waiting for it is a form of interaction, which is the relationship to classic open3 which is two programs trying to write and read from each other)
13:10:57 <fnurglewitz> cool, a deadlock =/
13:11:03 <geekosaur> in any case you get much the same problem in any other language
13:13:25 <fog> it works! https://gist.github.com/fog-hs/df3498c205433723ca022c552c3849a4
13:16:53 * hackage mmsyn7h 0.4.0.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.4.0.0 (OleksandrZhabenko)
13:17:16 <fog> i guess the class is basically folding the hlist...
13:17:29 <nickednamed> But it is identical but for the package name listed. I don't have my github credentials right now (never really use it) so I can't give you my own, but I assure you, it is virtually identical.
13:18:47 <fnurglewitz> geekosaur: ty
13:21:37 <nickednamed> Essentially, I want to know: is the guy in the issue I linked correct? Is it only possible to make test-suites for exposed library modules, as opposed to executables?
13:21:40 <`Guest00000> learn epidemiology in order to not contaminate https://en.wikipedia.org/wiki/Epidemiology
13:23:03 <solonarv> nickednamed: this matches my understanding
13:23:15 <solonarv> the problem is that executables don't export anything
13:23:37 <`Guest00000> maybe in response to probes from Earth
13:24:27 <merijn> nickednamed: Just move the bits to test into the library?
13:26:57 <nickednamed> What if I have an executable in it's own directory, with some functionalities in a sub directory, listed uner "other-modules"? I couldn't get this to work either. So "other-modules" are not exposed either, right? Sorry if these are dumb questions.
13:27:21 <geekosaur> a program is a program, not a library with some magic
13:27:48 <geekosaur> the same is true of C or C++ programs, if you have other source files somewhere else youd need to compile them separately as a library of some kind
13:28:06 <dminuoso_> nickednamed: You can use any other paste site if you like :)
13:28:23 * hackage simplelru 0.1.0.1 -   https://hackage.haskell.org/package/simplelru-0.1.0.1 (Murakami)
13:29:27 <geekosaur> there are .o files but it's looking for a .a or .so file made from them; there aren't any, for a program
13:30:52 <fog> omg, how are you supposed to fold a hetrogenous list!?
13:31:03 <fog> whats the type of hfoldr!?
13:31:28 <fog> class HFoldable (hcontainer :: [*] -> *) where
13:31:33 <fog> class HFoldable (hcontainer :: [*] -> Type) where
13:32:02 <nickednamed> Well cabal docs say not exposed, so I will restructre as a libraries.
13:32:05 <nickednamed> Thank you,
13:32:30 <fog> so from the paste  evalFunctionList = hfold (.)
13:32:35 <fog> hfolrd*
13:32:40 <fog> hfoldr*
13:32:46 <geekosaur> right this isn't because cabal is opinionated but because OS executables are opinionated
13:33:10 <fog> :t (.)
13:33:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:33:32 <fog> which is supposed to be like (a -> b -> b) of;
13:33:35 <fog> :t foldr
13:33:36 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:33:37 <geekosaur> (they are in fact libraries in some sense, on most unixlikes at least, but not usefully so)
13:39:23 * hackage simplelru 0.1.0.2 -   https://hackage.haskell.org/package/simplelru-0.1.0.2 (Murakami)
13:41:18 <solonarv> well, I suppose cabal could just *also* build a library
13:41:28 <solonarv> but it is a bit late for such a change
13:42:39 <merijn> solonarv: cabal supports multiple (internal) libraries right now, so you can just define a library per executable if you wanna test things
13:42:47 <solonarv> yes, I know
13:42:56 <merijn> solonarv: (Actually, it also supports multiple libraries in general now, but Hackage does not yet)
13:43:27 <fog> argh, its totally complicated by the fact the values have their types distributed over adjacent values of the type list param
13:43:32 <solonarv> the hypothetical I was referring to is that each 'executable foo' would *also* make a library available, in addition to an executable
13:43:41 <solonarv> but I am not suggesting that this should be done
13:49:53 * hackage simplelru 0.1.0.3 -   https://hackage.haskell.org/package/simplelru-0.1.0.3 (Murakami)
14:05:53 * hackage mmsyn7h 0.4.0.1 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.4.0.1 (OleksandrZhabenko)
14:06:51 <TheCommieDuck> ...just to check I'm not being dumb, zooming from (a, b) to a and then modifying a should persist when I zoom back out, right?
14:07:30 <dminuoso_> TheCommieDuck: What exactly do you mean by "zoom back out"
14:08:02 <dminuoso_> TheCommieDuck: zoom is a combinator. `zoom _2` acts as sort of `lift`
14:08:40 <dminuoso_> TheCommieDuck: Instead of asking a meta question, share your code instead, and its result you deem errenous perhaps so we can look at what you actually did?
14:09:23 * hackage mmsyn7h 0.4.0.2 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.4.0.2 (OleksandrZhabenko)
14:10:32 <[exa]> TheCommieDuck: if you ask whether the change "inside of zoom" propagate out, then yes
14:11:31 <dminuoso_> % flip execState ('a','b') $ zoom _2 $ id .= 'c'
14:11:31 <yahb> dminuoso_: ('a','c')
14:12:22 <dminuoso_> % flip execState (('a', 'b'), 'd') $ zoom _2 $ _1 .= 'c'
14:12:22 <yahb> dminuoso_: ; <interactive>:230:46: error:; * No instance for (Field1 Char Char a0 Char) arising from a use of `_1'; * In the first argument of `(.=)', namely `_1'; In the second argument of `($)', namely _1 .= 'c'; In the second argument of `($)', namely zoom _2 $ _1 .= 'c'
14:12:26 <dminuoso_> % flip execState (('a', 'b'), 'd') $ zoom _1 $ _2 .= 'c'
14:12:26 <yahb> dminuoso_: (('a','c'),'d')
14:13:01 <iqubic> Weird use for zoom.
14:13:15 <iqubic> % flip execState (('a', 'b'), 'd') $ _1 . _2 .= 'c'
14:13:15 <yahb> iqubic: (('a','c'),'d')
14:13:50 <iqubic> zoom is more useful if you want to do a long computation with a certain subsection of the data.
14:14:01 <TheCommieDuck> I did post code and got no reply earlier, so I figured asking a more generic version of the question might help. https://pastebin.com/i4h0QSxB
14:14:35 <iqubic> What exactly is your question here?
14:14:43 <dminuoso_> TheCommieDuck: Can you share the definition of sayModifyLn?
14:15:21 <iqubic> And can you show use what data structure firstRoom is a lens into?
14:15:44 <iqubic> This is a very incomplete code snippet.
14:16:10 <dminuoso_> The indentation is weird. Is there something missing around the zoom?
14:16:23 <TheCommieDuck> the indentation is weird because pastebin
14:16:34 <iqubic> I'll also need to see the definition of getLocationId too, in order to answer this
14:16:51 <dminuoso_> TheCommieDuck: Please use a different website or adjust your pastie.
14:18:06 <iqubic> This is only a small section of the code. I have no idea what w, sayModifyLn, firstRoom, or getlocationID are.
14:19:48 <iqubic> And yes, I know w comes from get, but without knowing what the state is, w could be anything.
14:21:03 <TheCommieDuck> https://pastebin.com/MN8edSjv I think this is everything you asked for. Apologies.
14:22:04 <iqubic> This is much better.
14:22:05 <dminuoso_> TheCommieDuck: And your actual code without broken indentation?
14:22:52 <iqubic> Yes. Can we please have the first paste, again, this time with correct indetation?
14:24:15 <iqubic> Ummm... Sorry to keep asking for more code, but what is sayLn?
14:25:48 <TheCommieDuck> full code, unless you want me to attempt to extract a MWE: https://github.com/TheCommieDuck/Catnip/tree/master/src ; I give up on pastebin, I'll tryu another pastie.
14:26:32 <TheCommieDuck> (sayLn is in SayCommon.hs)
14:26:58 <iqubic> Which part of that isn't working in the way you want it too?
14:27:52 <dminuoso_> TheCommieDuck: So, if the expected output is `1 2 1 2` from that region, and you have gotten `1 1 1 1`, then clearly something went wrong already before the zoom.
14:27:55 <dminuoso_>                 sayModifyLn $ getLocationID w (w ^. player)
14:27:57 <TheCommieDuck> in the repo I linked, Actions.hs lines 163-173. I figured all the extra stuff around it wasn't necessary since it was all just convoluted lookups :P
14:27:59 <dminuoso_> Does not give you what you think it does.
14:28:10 <TheCommieDuck> oh, I see
14:29:23 <dminuoso_> TheCommieDuck: But yeah, the second zoom is a bit silly.
14:29:38 <TheCommieDuck> the second zoom was just me trying to debug fairly blindly
14:30:04 <dminuoso_> TheCommieDuck: In your case its probably simpler to use IO for debugging.
14:30:07 <TheCommieDuck> (if that zoom worked, then I knew the issue was in the composition of lenses)
14:30:37 <TheCommieDuck> but then I would have to be chaining up IO monads through the entire call stack?
14:30:59 <dminuoso_> Ah there's no IO here?
14:31:11 <[exa]> with parsecs (attoparsec in particular), what's the best way to do something like many1, but limited to maximum N items?
14:31:48 <iqubic> dminuoso_: No there isn't.
14:31:53 <dminuoso_> [exa]: asum (replicate n t) ?
14:31:53 <TheCommieDuck> Yeah - the whole idea of sayLn is rather than print to the screen, I can just append it to an internal buffer (as part of the World state) and then print it in a much further out layer.
14:32:02 <dminuoso_> Oh.. not asum...
14:32:09 <dminuoso_> but.. I think you could go down this road.
14:32:44 <[exa]> asum will fail the whole thing if the later things in sequence fail
14:32:51 <dminuoso_> TheCommieDuck: Fair enough. I would probably include more context, ensure you are not looking at the *wrong* output
14:32:57 <[exa]> oh no, sorry
14:33:13 <dminuoso_> [exa]: Well, its not spot on quite yet.
14:33:37 <[exa]> I guess it will unnecessarily try the later items?
14:33:44 <TheCommieDuck> I know with certainty I'm looking at the right bit - the advantage of this sayLn mess is it allows me to separate debug printing and not debug printing 
14:34:10 <dminuoso_> [exa]: No, its not exactly what you are asking for
14:35:48 <[exa]> anyway the purpose is to just stop scanning e.g. a number if it's too long to make sense
14:37:50 <dminuoso_> [exa]: https://gist.github.com/dminuoso/d55e18de07bec1843d761cdf71b193e9
14:38:24 <[exa]> I kindof wanted to avoid handcoding that but thanks a lot :]
14:39:07 <dminuoso_> [exa]: Well I recently came up with the idea of `witherAlt f = getAlt . wither (optional . f)`
14:39:27 <[exa]> assuming this situation should be pretty common in lowlevel or network-facing parsers, right? "Let's scan a number but don't allow the other end to kill our buffers"
14:39:39 <dminuoso_> You could...
14:40:07 <dminuoso_> err, not getAlt there
14:40:24 <dminuoso_> % witherAlt f = wither (optional . f)
14:40:24 <yahb> dminuoso_: ; <interactive>:233:15: error:; * Variable not in scope: wither :: (a -> f (Maybe a1)) -> t; * Perhaps you meant one of these: `either' (imported from Prelude), `writer' (imported from Control.Monad.RWS), `Q.within' (imported from Test.QuickCheck)
14:40:33 <dminuoso_> % import Data.Witherable
14:40:33 <yahb> dminuoso_: ; <no location info>: error:; Could not find module `Data.Witherable'; It is not a module in the current program, or in any known package.
14:40:38 * dminuoso_ sighs
14:41:33 <Solonarv_> dminuoso_: asum (replicate n t) is rarely sensible, for most Alternative instances (certainly including parsers) it's just the same thing as t
14:41:52 <[exa]> ok anyway witherable looks interesting, thanks for the pointer :D
14:42:10 <Solonarv_> [exa]: asum [replicateA i t | i <- [1..n]]
14:42:29 <dminuoso_> Solonarv_: That doesn't look quite right, either.
14:42:50 <dminuoso_> I think what we are looking for is a missing newtype for Witherable
14:43:18 <Solonarv_> I was still operating on the "many1 but with a maximum number of items" query
14:43:45 <dminuoso_> mmm
14:43:53 * hackage patch 0.0.1.0 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.1.0 (JohnEricson)
14:44:07 <dminuoso_> Solonarv_: Well, then yours will unnecessarily repeat work
14:44:18 <Solonarv_> indeed it will
14:44:31 <dminuoso_> And unless you have automatic back tracking, this will misbehav
14:44:44 <Solonarv_> oh,dang
14:44:59 <Solonarv_> I must be very tired, neither of those occured to me until you pointed them out
14:45:10 <Solonarv_> of course now they are blindingly obvious
14:45:31 <dminuoso_> I liked the idea of using a list comprehension right to an asum though.
14:45:40 <dminuoso_> The idea was certainly neat
14:53:27 <orionx> hi
14:56:23 * hackage mmsyn7h 0.4.0.3 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.4.0.3 (OleksandrZhabenko)
15:04:53 * hackage mmsyn7s 0.1.1.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.1.1.0 (OleksandrZhabenko)
15:06:56 <hololeap> yo
15:08:21 <electricityZZZZ> yo
15:09:41 <jackdk> yo
15:10:53 * hackage mmsyn7ukr 0.6.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.0.0 (OleksandrZhabenko)
15:11:22 <electricityZZZZ> ok i've got a general computer science question,... if we pick a particular data structure or algorithm, we can find apparent absolutely superior algorithms... such as find/insert/delete in O(1) rather than O(log(N)) etc. so why would someone want to talk about an inferior data structure, except for historic, pedagogic, or occasional scholarly purposes?
15:11:57 <[exa]> dminuoso_: anyway I found it in hsemail as manyN
15:12:27 <Axman6> it's rarew that you will be able to get O(1) for all operations, you pick the structure with the best asymtotics for the operations you'll do the most. 
15:13:05 <merijn> electricityZZZZ: Whole bunch of reasons: For one: are those O(1) things actually O(1) (usually not) are they average, best, or worst case complexity? Does the data structure require some property of the input data that doesn't exist?
15:13:48 <merijn> I don't know any data structure that supports O(1) find, insert and delete (unless we're counting extremely niche ones)
15:13:52 <Axman6> if you need the history of a strucutre, then you need something without mutation - so places where an array may have made sense might no longer because updates become O(n) instead of O(1). These sorts of trade offs often happen when concurrency is involved
15:15:20 <electricityZZZZ> sorry i didn't mean O(1) for everything, but you can find algorithms like slow sorting algorithms as an easy example,... are there real applications of O(N^2) sorting algorithms?
15:15:22 <[exa]> dminuoso_: highlight: foldr ((<|>) . (\x -> try (replicateM x p))) (return []) (reverse [1 .. m])
15:15:58 <dminuoso_> [exa]: That will cause quite a bit of unnecessary work as well
15:16:03 <Axman6> Insert sort, which is O(n^2) is aften used when sorting small n because it tends to be very fast and cache friendly - have a look at timsort
15:16:08 <Axman6> often*
15:16:44 <dminuoso_> [exa]: Im trying to remmeber whether there was a way to get from `[Maybe a] -> [a]` taking the first consecutive Just values
15:16:57 <dminuoso_> My mind says there was a trick
15:17:00 <electricityZZZZ> and furthermore can i abstract myself even from algorithm choice?
15:17:12 <[exa]> electricityZZZZ: people use insertsort e.g. on GPUs because it behaves less chaotically i.e. faster in total
15:17:29 <electricityZZZZ> can i just let my program run on some test data and let a compiler determine what algorithms and optimizations to apply?
15:17:31 <dminuoso_> electricityZZZZ: Another relevant part is that the constants are often quite bad, or that there's more than one asymptotic to consider.
15:17:40 <electricityZZZZ> i dont think i can keep up with all of the knowledge required to program a computer
15:17:56 <dminuoso_> electricityZZZZ: For example sorting can usually be done in O(n) - contrary to what comp sci students religiously learn across the world.
15:18:22 <electricityZZZZ> i'm aware of approximate solutions to traveling salesman
15:18:39 <dminuoso_> But that's O(n) time, not memory
15:19:14 <[exa]> electricityZZZZ: overall aiming at optimality is rarely necessary (and very hard), just do something that isn't wasting a noticeable amount of resources
15:19:22 <dminuoso_> Then there's many other characteristics like cache efficiency
15:19:25 <electricityZZZZ> ok well thanks for giving me an idea here. interesting re: sort+gpu
15:19:59 <electricityZZZZ> [exa]: i sorta agree regarding "premature optimization is the root of all evil",... except that i don't
15:20:12 <electricityZZZZ> writing a program so that it performs well can require re-architecting it in substantial ways
15:20:13 <fog_> https://gist.github.com/fog-hs/e7a2447448f0b478ebdeeac85ad50330
15:20:18 <dminuoso_> For example a sort algorithm that runs O(n*log n), is cache efficient and has cheap constants might in most cases perform much faster than one that runs in O(n) time
15:20:30 <fog_> help^
15:20:39 <electricityZZZZ> and i believe that in the real world it makes much more sense to get things right from the outset rather than to assume that you can sink time into something which can theoretically be optimized later
15:21:12 <[exa]> electricityZZZZ: the advice is "write a short program" so that you don't suffer so much when the future understanding hits :]
15:21:17 <dminuoso_> electricityZZZZ: Asymptoptics are just that, asymptotics. They dont tell you how good something performs. They tell you something about the asymptotic behavior.
15:21:48 <electricityZZZZ> i'm not saying that i worship big O notation, i know about empirical performance
15:22:12 <dminuoso_> [exa]: Gah that `[Maybe a] -> [a]` is totally bugging me
15:22:23 <electricityZZZZ> one might say that it's meaningless to describe the performance of an algorithm except by testing it on specific distributions of data
15:22:41 <[exa]> dminuoso_: I was searching for something similar as well. Maybe we should spawn it as a new maybe-related tool?
15:22:48 <[exa]> ("series" ?)
15:22:51 * electricityZZZZ will brb
15:22:58 <dminuoso_> [exa]: Im not even sure where it would fit into
15:23:04 <dminuoso_> It's something that only really makes sense in witherable
15:24:05 <[exa]> electricityZZZZ: also, compare programmer vs. actual algorithm time
15:24:15 <dminuoso_> If we had that, we could do: manyN n = take n . thatThing . witherAlt id . replicate n
15:24:46 <dminuoso_> Or.. can we? Im a bit tired
15:26:32 <[exa]> IMO the foldr describes the whole problem well, shortcutting is exactly as with other foldrs
15:26:45 <[exa]> except for the monad there
15:49:23 * hackage avro-piper 1.0.2 - Tool for decoding avro  https://hackage.haskell.org/package/avro-piper-1.0.2 (haskellworks)
15:53:03 <TheCommieDuck> well, I solved my problem from earlier. Turns out I was stupid and it was somewhere else entirely. Thanks everyone, and apologies.
16:11:23 <hohohohoskell> Enum members are sequentially ordered types â€” they can be enumerated. The main advantage of the Enum typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.
16:11:34 <hohohohoskell> but `succ ()` returns an exception?
16:12:27 <hohohohoskell> or is it "theoretically" an Enum but like how `succ (2^32)-1` will also fail?
16:17:44 <oats> hohohohoskell: enums can have bounds
16:18:31 <hohohohoskell> yea, its intereseting (to me) that `succ maxBound :: Int` and succ somehow knows that I am attempting to take succ of maxBound
16:18:42 <hohohohoskell> instead of, say, returning an exception
16:19:05 <fog> cant fathom this at all.... https://gist.github.com/fog-hs/e7a2447448f0b478ebdeeac85ad50330
16:21:18 <oats> > [() .. ()]
16:21:21 <lambdabot>  [()]
16:21:26 <oats> 100% Enum :P
16:22:37 <hohohohoskell> yea but how the heck does this work? succ (succ (pred maxBound :: Int)) how does it know i am taking succ of maxBound?
16:22:48 <oats> ahh
16:23:12 <oats> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#line-464
16:23:23 <oats> it's the definition of succ on Ints
16:23:41 <oats> when x == maxBound, it throws an exception
16:24:07 <oats> and maxBound is defined on Ints since Int is Bounded
16:28:49 <hohohohoskell> oh, that makes sense, i thought its some types magic
16:29:23 <hohohohoskell> i.e. it infers that succ pred forms an identity or something lol
16:30:52 <oats> gotcha :)
16:40:26 <fog> ok, I think the problem is because of the fact that the HList takes a type parameter of a list that is gradually consumed, so it needs a class for this, to match over the different intermidiate types in a recursion, like in evalFunctionList; https://gist.github.com/fog-hs/df3498c205433723ca022c552c3849a4
16:40:55 <fog> but the HFoldable class is supposed to abstract over a container that takes a type list as a parameter
16:41:31 <fog> as in, if it were list, this would just be one type, and there would be no kind of matching on this being a different type for different lengthed lists
16:41:52 <fog> so it seems to need 2 classes, which seems really difficult to understand how to do
16:58:09 <oats> that's an interesting way to use IRC
17:10:51 <electricityZZZZ> so rust is 'bad at handling graph-structured references.' is haskell 'good at handling graph structured references'?
17:15:37 <alc`> how to use pattern matching to match negative number?
17:15:56 <alc`> if (x < 0) then True else False
17:16:13 <alc`> f x = if (x < 0) then True else False
17:16:28 <oats> alc`: well, that whole expression can just be replaced with (x < 0)
17:17:00 <alc`> oats: f x = if (x < 0) then 1 else 2
17:17:21 <oats> if you wanted to write it "piecewise" style
17:17:41 <oats> f x | x < 0 = 1 | otherwise = 2
17:17:48 <oats> using guards
17:18:03 <alc`> oats: but pattern matching can't do this?
17:18:29 <alc`> we can't have f (x<0) = 1; f x = 2
17:18:30 <oats> I don't think so, at least not in the way you want it to
17:20:14 <alc`> oats: guards is `case` in other languages, right?
17:20:43 <oats> I think it'd be closer to 'cond' in scheme
17:20:58 <alc`> yeah, scheme call it 'cond'
17:22:39 <oats> pattern matching is for when you want to have multiple paths to go down, based on the structure of some value
17:25:32 <alc`> oats: guards, case..of, if-then-else, who defined whom?
17:25:55 <oats> sorry, I don't understand
17:26:28 <alc`> oats: `cond` is defined by if-else in scheme
17:26:49 <alc`> or the reverse, I don't remember correctly
17:27:07 <oats> no idea
17:27:25 <oats> I defer to ghc
17:28:13 <alc`> we can use if-then-else to replace guards or case..of, it's more generic
17:30:18 <oats> I believe guards can be replaced by chaining if-then-else
17:30:20 <oats> but it's ugly
17:30:26 <oats> and guards are pretty :<
17:32:58 <alc`> I wonder if there're other ways to replace if-then-else
17:33:36 <oats> I don't believe if-then-else can be replaced by anything more basic
17:33:56 <oats> it's technically just a really simple function
17:34:04 <oats> if' True a _ = a
17:34:08 <oats> if' False _ b = b
17:34:20 <oats> just selecting an argument based on a boolean
17:34:47 <oats> constructing the if function is a basic exercise when learning about lambda calculus
17:35:10 <oats> so I guess you could say it's made of lambda calculus :P
17:36:56 <alc`> ok
17:37:25 <alc`> and you're using pattern matching to define if-else
17:37:51 <alc`> I wonder if that's ok, like using if-else to define if-else
17:38:04 <oats> that is a valid definition of if-else
17:38:12 <oats> you could use that in your haskell code just fine
17:38:28 <oats> but notice, I didn't use haskell's built-in if-else
17:38:53 <oats> @let if' True a _ = a; if' False _ b = b
17:38:54 <lambdabot>  Defined.
17:38:55 <alc`> but you use pattern matching, it's techilly equal to if-else
17:39:05 <oats> that's an implementation detail :P
17:39:19 <oats> > if' (1 < 2) "yeh" "nah"
17:39:20 <lambdabot>  "yeh"
17:39:30 <oats> > if' ("foo" == "bar") "yeh" "nah"
17:39:32 <lambdabot>  "nah"
17:40:04 <alc`> oats: wait, you if' is more easy to read, why we need 'then' and 'else'?
17:40:20 <oats> I actually don't think it's easier to read :P
17:40:21 <alc`> this if' suppose to replace if-then-else
17:40:33 <oats> I'm perfectly happy using the built-in keywords
17:40:48 <jackdk> oats: if you like pretty guards, have you seen -XMultiWayIf?
17:40:53 <alc`> oats: your if' is the way of scheme
17:41:06 <oats> alc`: and? :>
17:41:53 <iqubic> I have no idea how MultiWayIf works.
17:42:37 <oats> alc`: if you want to see building stuff from "nothing", I highly recommend checking out lambda calculus :P
17:43:22 <jackdk> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#multi-way-if-expressions
17:43:59 <oats> doesn't lambdabot have a lc interpreter?
17:44:15 <iqubic> If it does, I've never heard of it.
17:44:50 <iqubic> Why would you ever use MultiWayIf over guards?
17:44:58 <alc`> oats: I just heard of them, typed lambda calculus, and untyped lambda calculas
17:45:17 <Axman6> when you're not defining a new function
17:45:46 <alc`> I just know that three convertions, alpha, beta, and eta
17:46:09 <alc`> if x = c x, can we get x y = c x y through eta-convertion?
17:46:21 <alc`> I forget that free variable stuff 
17:46:41 <alc`> f = f; f x = f x; f = \x -> f x
17:48:05 <amalloy> iqubic: can you think of a context in which an if-expression is legal and a guard is illegal?
17:48:26 <amalloy> if one such existed, that would be a good answer to "Why would you ever use MultiWayIf over guards?"
17:48:34 <oats> the "if" function in lambda calculus, represented with haskell syntax: \b -> \t -> \f -> b t f
17:49:12 <oats> true = \a -> \b -> a
17:49:15 <oats> true = \a -> \b -> b
17:49:24 <oats> er, *false
17:49:29 <oats> https://learnxinyminutes.com/docs/lambda-calculus/
17:50:33 <alc`> oats: can we get `x y = c x y` if `x = c x`?
17:50:57 <oats> if c takes at least 2 arguments
17:52:11 <alc`> oats: do that annonymous recursive use this way?
17:53:17 <iqubic> What is annonymous recursion?
17:53:45 <alc`> https://en.wikipedia.org/wiki/Anonymous_recursion
17:57:04 <alc`> https://en.wikipedia.org/wiki/Fixed-point_combinator
17:58:09 <alc`> is that?
17:58:58 <dmwit> If x = c x, then it is certainly true that x y = c x y. Additionally, both x y and c x y may be type errors.
17:59:21 <dmwit> You may take any one-hole context and put in equal things to get out equal things.
18:01:26 <alc`> dmwit: Y f x = f (Y f) x is related to anonymous recursion?
18:02:44 <dmwit> Sure, why not.
18:03:08 <iqubic> @import Data.Fix
18:03:08 <lambdabot> Unknown command, try @list
18:03:17 <iqubic> @let import Data.Fix
18:03:18 <lambdabot>  .L.hs:89:1: error:
18:03:18 <lambdabot>      Could not find module â€˜Data.Fixâ€™
18:03:18 <lambdabot>      Perhaps you meant
18:03:24 <iqubic> damn
18:03:30 <iqubic> % import Data.Fix
18:03:31 <yahb> iqubic: ; <no location info>: error:; Could not find module `Data.Fix'; Perhaps you meant; Data.Fixed (from base-4.12.0.0); Data.Ix (from base-4.12.0.0)
18:03:50 <shachaf> iqubic: Please consider whether you really need a bunch of lambdabot lines to make whatever point you're trying to make.
18:03:59 <alc`> @import Control.Monad.Fix
18:03:59 <lambdabot> Unknown command, try @list
18:04:06 <iqubic> shachaf: I don't.
18:04:29 <iqubic> newtype Fix f = f (Fix f)
18:04:44 <iqubic> That's what I wanted to show.
18:05:01 <alc`> Fix f is the fixed-point of f
18:05:13 <iqubic> Sure. That's how you'd describe it.
18:06:04 <iqubic> @src fix
18:06:04 <lambdabot> fix f = let x = f x in x
18:06:06 <alc`> in that x = c x, x is the fixed-point of c, so x y = c x y, we call x y in c x y, it's equal to call c x y in c x y, that's recursion
18:06:28 <iqubic> We can rewrite fix as: "fix f x = f (fix f x)"
18:06:42 <alc`> so we can use that to implement anonymous recursion with fixed-point
18:06:52 <dmwit> You don't need to call anything for it to be recursion.
18:07:10 <iqubic> let fix' f x = f (fix' f x) in fix' (1:)
18:07:19 <iqubic> > let fix' f x = f (fix' f x) in fix' (1:)
18:07:20 <lambdabot>  error:
18:07:20 <lambdabot>      â€¢ No instance for (Typeable t0)
18:07:20 <lambdabot>          arising from a use of â€˜show_M63245099320462317554458â€™
18:07:25 <dmwit> alc`: If x = c x, then we use x in c, that's recursion.
18:07:46 <iqubic> Right.
18:08:00 <alc`> dmwit: but x need a parameter, every function is unary function in haskell, we don't have a function without parameter
18:08:12 <dmwit> alc`: x does not need a parameter if it is not a function.
18:08:23 <dmwit> Every function is a unary function. But not every term is a function.
18:09:05 <alc`> dmwit: to implement anonymous recursion, that x has to be a function
18:09:29 <dmwit> I don't know what that means. It doesn't sound right.
18:10:14 <alc`> dmwit: "<dmwit> alc`: If x = c x, then we use x in c, that's recursion." if x is not a function, we can call that recursion to use x in c?
18:10:24 <dmwit> Yes, certainly.
18:10:27 <alc`> like?
18:10:58 <shachaf> "anonymous recursion" is a fake idea.
18:11:04 <dmwit> Two examples: repeat 1 = 1 : repeat 1 (here x = repeat 1, c = (1:)); 3 = const 3 3 (here x = 3, c = const 3).
18:11:17 <shachaf> That whole Wikipedia page looks like nonsense to me.
18:11:47 <maerwald> what, fake news about recursion?
18:12:08 <shachaf> Real ideas: Recursion; fixed points; the Y combinator.
18:13:06 <dmwit> Actually, I gues what I said was backwards. If x = c x, then we use c in x (not "we use x in c").
18:13:09 <shachaf> "anonymous" doesn't mean much. What's the actual question?
18:13:33 <dmwit> I was simplifying your statement about x y = c x y, but your statement was wrong to begin with (in the analogous way) and I didn't check it carefully enough.
18:13:52 <alc`> aha
18:14:56 <alc`> dmwit: more details?
18:16:04 <dmwit> I don't know how to give more details. I don't know what is confusing. Recursion always felt very natural to me.
18:16:47 <dmwit> (First I learned about fractals and self-similarity. Then I learned programming, and recursion is just, like, fractals, man.)
18:17:05 <dmwit> (I learned programming so that I could draw fractals.)
18:17:23 <dmwit> But if you ask a question that says more about what *you* find hard, perhaps I can help more.
18:17:53 <glguy> Got any sweet fractal pictures to share?
18:18:00 <dmwit> ^_^
18:18:43 <dmwit> I love the Mandlebrot set and aaaalll the Julia sets. I don't have anything from when I was a kid but there are so many videos on YouTube now that look better than what I did as a kid anyway... =P
18:19:31 <shachaf> *All* the Julia sets?
18:19:57 <glguy> No, aaaalll
18:20:08 <dmwit> glguy gets me
18:20:15 <glguy> It's a term of art
18:21:37 <dmwit> oh wait!
18:21:41 <dmwit> I do have a sweet fractal pic
18:21:55 <dmwit> http://dmwit.com/menger/
18:22:07 <dmwit> And this one is actually on-topic because I did it with Haskell! yay
18:23:43 <glguy> Those are some build instructions
18:24:21 <dmwit> no warrantee, no claim that this is suitable for any use, etc. etc.
18:26:23 * hackage bioinformatics-toolkit 0.9.1 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.9.1 (kaizhang)
18:27:20 <monochrom> 6.10 eh
18:27:42 <monochrom> You know what, if it breaks stack, I support it. :)
18:29:36 <nshepperd> the mandelbrot set is the fractal with the best theme song that i know of
19:00:23 * hackage describe 0.3.0.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.3.0.0 (riuga)
19:15:24 <zeta_0> how do i add language pragmas to my .cabal file, i don't want to have to write them over and over again for each new haskell file?
19:16:33 <maerwald> zeta_0: https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-default-extensions
19:17:23 * hackage describe 0.3.0.1 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.3.0.1 (riuga)
19:18:03 <Axman6> zeta_0: it's generally not considered good practice to do that though
19:18:36 <maerwald> Axman6: why?
19:18:42 <zeta_0> thanks guys, and why is it considered bad practice?
19:18:51 <Axman6> some are ubiquious, like OverloadedStrings
19:19:16 <maerwald> well, that's true even on module level
19:19:42 <maerwald> but I wouldn't go so far to say it's bad practice, it depends on the extension
19:19:49 <maerwald> LambdaCase is safe to enable project wide
19:20:37 <zeta_0> so extensions: are deprecated in favor of default-extensions: ?
19:20:55 <maerwald> cabal config can be confusing
19:21:36 <zeta_0> so i can enable modules as well so i don't need to write the imports in my haskell files?
19:26:43 <glguy> No, you write import statements as usual
19:27:11 <maerwald> that sounds like a dream
19:27:23 <maerwald> vscode -> add missing imports -- hahaha
19:27:30 <maerwald> oh wait, that was typescript :(
19:28:25 <maerwald> when ghc-mod was still working, this actually worked with hs-import
19:32:57 <alc`> f (a,b) = [a,b] does this f have a common name?
19:33:13 <monochrom> No.
19:33:13 <glguy> no
19:33:31 <monochrom> Also I've never needed it.  Nor "f a b = [a,b]".
19:33:53 <koz_> @pl \(a, b) -> [a, b]
19:33:53 <lambdabot> uncurry ((. return) . (:))
19:33:56 <koz_> ^
19:34:08 <alc`> splitAt return a tuple (a,b), but transpose work on [a,b]
19:34:25 <monochrom> Goes a long way to show that everyone thinks the function they need is universally needed, and they're wrong.
19:34:42 <alc`> I don't understand why splitAt or SplitOn work on list and return tuple?
19:34:49 <alc`> shouldn't it return list?
19:34:56 <glguy> Because it takes N things and returns 2
19:35:08 <monochrom> Well yeah I just happened to have only used tranpose on arbitrary-length lists, not two things.
19:35:13 <koz_> And the tuples are of lists, I believe.
19:35:16 <koz_> :t splitAt
19:35:17 <lambdabot> Int -> [a] -> ([a], [a])
19:35:24 <zeta_0> haskell-ide-engine is evolving pretty good, and they are getting rid of ghc-mod and replacing it with something else, i have always had problems with ghc-mod so that is good
19:35:32 <koz_> So yeah, you have 'everything up to split point' and 'everything after split-point'.
19:36:31 <alc`> it reminder me that improper list
19:37:01 <monochrom> Like improper integral?
19:37:03 <koz_> alc`: That sentence no verb.
19:37:14 <koz_> What even _is_ an 'improper list'?
19:37:25 <monochrom> Bah English grammar is overrated.
19:37:40 <glguy> It's when you don't have types and have a "cons" that is just a tuple and sometimes you don't put a list in the second part of the tuple
19:37:55 <koz_> glguy: Oh, the Lisp thing.
19:38:00 <koz_> Almost forgot about those.
19:38:08 <monochrom> So like how catfish is not a fish?
19:38:10 <alc`> koz_: not mind, it's about scheme, (a . b) == (cons a b)
19:38:15 <monochrom> And not a cat?
19:38:38 <glguy> monochrom: Right, it's just nothing
19:39:35 <monochrom> Do you realize that you can say "cons list" and it's a perfectly good name?
19:40:30 <ChaiTRex> :t Right (Just Nothing)
19:40:31 <lambdabot> Either a1 (Maybe (Maybe a2))
19:41:12 <alc`> and another function f [a,b] = [b,a], does it have a name?
19:41:24 <monochrom> Just use reverse.
19:41:30 <alc`> ok
19:41:55 <monochrom> You need to study Prelude from cover to cover.
19:50:24 * hackage describe 0.3.1.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.3.1.0 (riuga)
19:51:54 * hackage heart-core 0.1.1 - An opinionated library prelude in the UnliftIO style  https://hackage.haskell.org/package/heart-core-0.1.1 (ejconlon)
19:54:54 * hackage cron 0.6.2 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.6.2 (MichaelXavier)
19:59:43 <fragamus> hi i have this line:   import qualified Data.Map.Strict as M     and I want in GHCI to say M.fromList
19:59:58 <fragamus> can I export that or what
20:02:19 <fragamus> argh   https://wiki.haskell.org/GHC/QualifiedModuleExport
20:04:06 <ChaiTRex> fragamus: Does M.fromList work? if not, do import qualified ... in GHCi
20:04:54 <fragamus> yeah it doesn't work but I can just enter the import in GHCI
20:05:01 <fragamus> which is nice
20:05:10 <fragamus> because I LOVE to type stuff
20:05:32 <dsal> Haskell is all about typed stuff.
20:06:09 <fragamus> bahaha
20:09:53 * hackage heart-app 0.1.1 - An opinionated app prelude and framework in the UnliftIO style  https://hackage.haskell.org/package/heart-app-0.1.1 (ejconlon)
20:10:14 <alc`> why haskell doesn't have dependent type?
20:12:53 <koz_> alc`: It's complicated. You can use singletons (the library) in the meantime.
20:14:57 <alc`> koz_: about type systems, there are huge difference between them?
20:15:09 <koz_> alc`: I don't understand what you mean.
20:15:26 <koz_> Are you referring to type systems in the theory sense (as in, STLC vs System F vs COC etc)?
20:15:28 <alc`> koz_: haskell, scala, rust they have different type systems
20:15:49 <koz_> That's too broad a question to have a sensible answer.
20:16:38 <alc`> koz_: there's no dependent type in system F?
20:19:05 <koz_> alc`: System F does not have dependent types, no.
20:20:20 <koz_> If we're talking lambda cube, there's Lambda-P, Lambda-P2, Lambda-P-Omega-Bar, and COC, which do.
20:20:25 <koz_> (along with possibly other things)
20:20:41 <koz_> Lambda-P is the least expressive of these (it's basically STLC + dependent types only).
20:20:51 <koz_> COC is the most expressive (it basically has everything).
20:21:21 <alc`> P is short for what?
20:22:12 <heatsink> I think it stands for Î 
20:22:19 <koz_> alc`: I think P refers to capital-pi (the Greek letter).
20:22:28 <koz_> I'm not precisely sure what _that_ refers to though.
20:22:39 <koz_> heatsink: Something something I owe you a soda?
20:22:39 <heatsink> dependent product
20:23:23 <alc`> and System F is Lambda?
20:23:30 <alc`> Lambda-P2?
20:24:11 <koz_> alc`: System F is designated Lambda-2.
20:24:24 <koz_> Lambda-P2 is System F + dependent types.
20:24:28 <heatsink> koz_: Î  is the dependent type equivalent of âˆƒ
20:24:51 <koz_> heatsink: Yeah, I recall.
20:25:02 <alc`> I wonder how you guys input that greek letters...
20:25:37 <wikiemol> When using the ST monad, is `do s <- newSTRef str; modifySTRef s (++"appended")` O(len str)?
20:26:00 <wikiemol> Or is it O(1)
20:26:11 <koz_> wikiemol: String concatenation (as in, Haskell String type) is O(n), because Strings are just [Char].
20:26:18 <koz_> Doing it in a mutable context makes no difference I don't think.
20:26:58 <heatsink> wikiemol: STRef doesn't force evaluation of its contents, if that's what you're asking
20:27:46 <koz_> heatsink: I don't think it matters here.
20:27:59 <koz_> [a] is a singly-linked list, which means you gotta chase to its end to append.
20:28:10 <koz_> Whether you do so mutably or immutably changes nothing of this fact.
20:28:37 <wikiemol> koz_ Hm, thanks. I heard that there was a way to use ST to get better performance in cases where zippers don't work. So, like, if you have a tree for example, and you want to continuously append to the end of the tree without traversing the tree every time, you could theoretically use a stref to get O(1) on the append, like you would do in an
20:28:37 <wikiemol> imperative language, is this true?
20:29:01 <koz_> wikiemol: This is true, _provided_ the structure is designed for this.
20:29:16 <koz_> However, I don't think that your standard Haskell tree implementation will work with this.
20:29:36 <wikiemol> koz_ How would you design the structure for this? Would you have to use STRef's in the structure itself?
20:29:42 <koz_> You can write one which will, but it involves a bit more effort than just jamming stuff in ST.
20:29:48 <koz_> wikiemol: Yeah, I think so.
20:29:59 <koz_> I've never tried though.
20:32:36 <wikiemol> I can't shake the feeling its bad practice, but Zippers don't seem to work to solve this specific problem.. since the place to insert in the tree changes every time you append
20:32:53 <wikiemol> I mean it seems possible
20:33:00 <wikiemol> but just very ugly and annoying
20:41:41 <koz_> wikiemol: It might help if you explain what you're trying to achieve.
20:41:54 <koz_> There might be a way that's not zippers _or_ mutability that does what you need.
20:43:51 <wikiemol> koz_ I have a data structure like this https://pastebin.com/b07S5Ea0. I am parsing a string of tokens, and as I am going through the string of tokens, I need to append new things to the parse tree. I am always appending at the very end of the tree. 
20:43:53 * hackage describe 0.3.1.1 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.3.1.1 (riuga)
20:44:58 <koz_> So wait, it's _either_ a blob of Text _or_ a rose tree full of as?
20:45:09 <koz_> s/Text/text/
20:46:03 <wikiemol> koz_ Essentially yes, although, in this case the "a"s are being used more like a tag, as in an html tag
20:46:49 <koz_> wikiemol: I'm not quite sure how that makes sense. You have a sum type - you don't have both a String _and_ a rose tree at any point.
20:47:15 <koz_> And I'm also not sure what you mean by 'in this case the "a"s are being used more like a tag'.
20:47:18 <koz_> What do you mean by that?
20:47:34 <wikiemol> koz_ This is how the dom behaves. There are nodes, and the leaves of the DOM tree are text objects, which are completely different types 
20:47:53 <wikiemol> So like, DIV is a tag
20:48:16 <koz_> wikiemol: If you're dealing with parsing HTML, there's _definitely_ already a solution out there.
20:48:26 <koz_> Since you're talking about the DOM.
20:48:38 <koz_> And to be honest, the DOM is so damn complex, I wouldn't wanna roll it myself anyway.
20:48:57 <wikiemol> Well, this is transpiling one set of tags to another, that is my own language I am making up
20:49:02 <wikiemol> I am not parsing HTML
20:49:16 <koz_> So... what's the DOM got to do with it? Was that just an example?
20:49:38 <wikiemol> no, I am transpiling to HTML 
20:49:41 <koz_> Ah.
20:50:26 <koz_> How come then you always need to 'append to the very end of the tree'. What is the 'end' of a tree? Why specifically are you always sure this is the case?
20:50:55 <monochrom> wikiemol: I suggest reading some papers or articles on monadic parsing and/or top-down recursive descent parsing.  You will find that you will not append at the end/tip of a tree.
20:51:23 <monochrom> BTW bottom-up dynamic-programming parsing doesn't either.
20:51:28 <koz_> monochrom: Whatever 'end/tip of a tree' even means.
20:51:38 <koz_> Since I frankly don't understand what that means for a rose tree.
20:51:49 <monochrom> Well, "end" is their wording, "tip" is mine.
20:51:50 <koz_> (with no explicit ordering of its nodes either)
20:51:59 <wikiemol> Bottom right 
20:52:30 <koz_> OK, so why do you think your tree only grows at its rightmost leaf?
20:52:41 <koz_> It seems rather unlikely.
20:53:12 <monochrom> But from past conversations it means I have "Branch (Branch Tip Tip) Tip" and now I want to "modify" it to "Branch (Branch Tip Tip) (Branch Tip Tip)"
20:54:01 <monochrom> But now we see that if the purpose is parsing, you just never do that.
20:54:41 <glguy> That tree is like 57% tip; I tend to default to 18% personally
20:54:50 <monochrom> Both top-down and bottom-up will build the two (Branch Tip Tip)s in two recursive calls or iterations, then later combine them with the upper Branch.
20:56:19 <monochrom> You just never modify some lower part or right side of an existing tree.  All you do is finish subtrees first then you tack on the parent node.
20:56:20 <glguy> challenge, make a tree that is less than or equal to 50% tip o.O
20:56:55 <glguy> 1) sometimes you want to modify the tips of a tree 2) zippers work on trees
20:56:58 <wikiemol> monochrom I think I see what you are saying
20:57:02 <glguy> (regarding the earlier zipper comment)
21:00:03 <zeta_0> Main.hs:10:1: error:
21:00:03 <zeta_0>     parse error (possibly incorrect indentation or mismatched brackets)
21:00:03 <zeta_0>    |
21:00:03 <zeta_0> 10 | / HomeR GET]
21:00:03 <zeta_0>    | ^
21:00:49 <zeta_0> i don't know why i always get that error, i already setup up the QuasiQuotes extension, how strange, i must be missing something
21:01:30 <zeta_0> mkYesod "HelloWorld" [parseRoutes|
21:01:30 <zeta_0> / HomeR GET]
21:03:12 <zeta_0> nevermind i will try to figure this out later
21:03:13 <heatsink> glguy: fix (\t -> Branch t t)
21:03:16 <wikiemol> monochrom I am still learning about parsers. I am reading a book about formal languages. This is an arbitrary CFG, that can define a non deterministic pushdown automata. The push down automata generated by the CFG has a transition function that takes the current description of the push down automata and produces the next possible states in a list. 
21:04:33 <monochrom> A pushdown automaton only produces a "yes" or "no".  This teaches you nothing about building an abstract syntax tree.
21:06:13 <wikiemol> The pushdown automata is constructed in such a way that it behaves as you would expect it to. So that a change in the stack corresponds directly to closing and opening a "tag", and that each NonTerminal of the CFG that defines it corresponds exactly to one of these tags
21:06:31 <koz_> Automata are recognizers - they merely state whether some string belongs to some set of strings.
21:06:55 <koz_> If you wanna actually have it read input _and build something_, then that's a transducer, and those are much trickier.
21:07:23 <wikiemol> That I am aware of. The algorithm I have transitions the pushdown automata, and checks what was added to the stack, or removed
21:07:28 <wikiemol> and generates the parse tree that way
21:07:31 <wikiemol> and it works
21:07:40 <wikiemol> I have it working
21:08:04 <wikiemol> Its just, whenever I insert into the tree, I have to traverse all the way to the bottom
21:08:44 <wikiemol> I wouldn't have to do that in an imperative language. In an imperative language, the algorithm I have would be relatively performant
21:09:41 <monochrom> Why don't you put subtrees on the stack.
21:10:19 <wikiemol> monochrom !! I think thats probably what I have been looking for
21:10:22 <monochrom> And when you pop a non-terminal from the stack, that means you also pop some subtrees and push a bigger tree.
21:10:56 <monochrom> which is what a top-down parser does, when recursive calls are implemented by stack.
21:11:30 <monochrom> If you had studied top-down parsers, you would have made this connection, because that's how I made it.
21:11:45 <monochrom> Knowing both top-down parsing and pushdown automaton.
21:12:16 <monochrom> Generalized Sapir-Worf: Your thinking is limiting by your reading. (Duh)
21:12:29 <wikiemol> Well, you are probably right, but I might not have appreciated it as much :) 
21:13:37 <monochrom> Also experience with RPN calculators.
21:13:40 <wikiemol> Although, still, in an imperative language, the other solution would have worked just fine
21:14:31 <monochrom> I wouldn't do it in an imperative language either.
21:14:46 <wikiemol> Why not?
21:15:15 <monochrom> Because it entails polluting your tree data structure like so: data Tree = Branch Tree Tree | FinishedLeaf | Unfinished
21:15:24 * hackage foldl 1.4.6 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.4.6 (GabrielGonzalez)
21:15:38 <monochrom> The pollution is the "Unfinished" case.  In C you use the null pointer.
21:16:04 <monochrom> This means the data type admits more illegal possibilities than necessary.
21:16:21 <wikiemol> Hm... I suppose you have a point
21:16:31 <monochrom> And in C, null is simply evil.  Look at Rust.
21:18:51 <wikiemol> How does Rust deal with partial functions? Isn't some value that inhabits all types necessary in an imperative language? 
21:19:06 <monochrom> Like Haskell. Use an ADT like Maybe.
21:19:56 <wikiemol> I thought the equivalent in Haskell is _|_, but because it is a pure language, it doesn't have to add it explicitly to the type system
21:20:08 <monochrom> Rust learned types from Haskell, Haskell learned ghup from rustup.
21:20:42 <jle`> wikiemol: _|_ doesn't have to do anything with purity or functional languages
21:20:50 <jle`> or imperative
21:20:57 <jle`> you can have bottom in imperative languages too
21:21:00 <wikiemol> It is a value that inherits all types
21:21:04 <wikiemol> yes
21:21:21 <jle`> i'm saying it doesn't have anything to do with purity or functional or imperative
21:21:31 <wikiemol> jle` In fact you have to, thats why I am asking
21:21:39 <monochrom> I doubt you know what it really entails.
21:21:52 <jle`> i have to what?
21:22:07 <wikiemol> monochrom I am no expert, but I have studied type theory pretty extensively 
21:22:36 <wikiemol> Every language has to have bottom
21:22:41 <wikiemol> otherwise it is not turing complete
21:23:04 <jle`> bottom doesn't exist as the inhabitant of values in strict languages
21:23:09 <jle`> and also many languages are not turing complete ...
21:24:28 <monochrom> 5 is a value, and a language allows you to test a value against "is it 5?".  bottom is a value, but no language allows you to test a value against "is it bottom?".  This is what's wrong with keep harping "it's a value".
21:26:26 <jle`> wikiemol: also remember adding null pointers (which are not bottom) was a conscious choice in the design of java; it doesn't have to support them
21:26:45 <monochrom> If I model my partial function as f::Int->Int you cannot test whether f 5 bottoms out or not.  If I make it f::Int -> Maybe Int you can test against Nothing.
21:27:16 <monochrom> Oh yeah null pointer is not bottom.  So much for type theory.
21:27:27 <zeta_0> do any of you guys use haskell-ide-engine, i have a question?
21:28:40 <wikiemol> monochrom _|_ is a value in type theory
21:28:48 <wikiemol> it is defined as a value that inhabits every type
21:28:55 <wikiemol> this has to exist in every type system
21:29:11 <monochrom> Talk to the computer.
21:29:22 <monochrom> Convince it to test for bottom for you.
21:29:32 <zeta_0> whin i open a single haskell program hie works fine but when i run cabal init, then open a file from the project, the lsp loads but all of hie's features are deactivated?
21:29:34 <monochrom> No use convincing me.  I am not running your programs.
21:29:36 <wikiemol> Thats the halting problem
21:29:47 <wikiemol> I didn't say you could always test for it
21:30:57 <wikiemol> null is, by definition, a bottom, because it inhabits every type in most imperative languages 
21:31:34 <dsal> Most languages I've used with null don't have it as an inhabitant of most types.
21:31:53 <monochrom> In C I can test against null, I can't test again bottom.  Again, good luck convincing your gcc.
21:32:37 <monochrom> You ever heard of Leibniz's principle?
21:33:03 <shachaf> I define _|_ as a value that inhabits only types whose name has an even number of characters.
21:33:28 <monochrom> Is it because _|_ consists of an even number of _'s?
21:33:43 <shachaf> Let's go with that.
21:33:49 <monochrom> :)
21:34:34 <monochrom> This is also what's wrong with unsupervised learning.
21:36:01 <shachaf> I'd better have monochrom supervise all my learning.
21:36:16 <koz_> I believe supervising learning is part of monochrom's job.
21:37:26 <zeta_0> if you guys don't use hie then what do you use then?
21:37:38 <monochrom> emacs haskell-mode
21:38:50 <zeta_0> hie works fine i just need to figure out how to enable it in a cabal project, do you guys have any idea?
21:39:00 <monochrom> Aww no one else is answering you so you're just getting my outlier data point.
21:39:33 <monochrom> emacs haskell-mode has a few wrinkles that I work around by intervening manually.  You don't want to go there.
21:39:35 <koz_> Vim + ALE.
21:39:44 <koz_> That setup also has a few wrinkles.
21:39:50 <koz_> Which I also work around by manual intervention.
21:39:54 <koz_> You also don't want to go there.
21:40:01 <monochrom> For most people vim or vscode or sublime with suitable plugins is great.
21:40:46 <shachaf> I use lambdabot and ghci.
21:41:53 <zeta_0> i also have the nix-haskell-mode pkg setup, it works great out of the box but interferes with hie sometimes
21:41:57 <koz_> shachaf: And ed, lol?
21:42:11 <jle`> i use the little interactive repl on https://www.haskell.org
21:42:43 <monochrom> I wonder which one is a better editor, ghci vs ed.
21:43:13 <koz_> monochrom: That's a tough one.
21:43:13 <monochrom> (Sarcastic)
21:44:23 <monochrom> I have in mind those misguised beginners who type in entire pages of definitions into ghci and then ask this channel "where is the save command I demand it".
21:44:41 <monochrom> We need to recommend ed to those people.  They will enjoy it thoroughly.
21:44:49 <koz_> monochrom: Bonus round - multi-line definitions.
21:45:05 <zeta_0> i think i found somewhere in the hie documentation, a section on how to add hie to the cabal configuration of a project
21:45:39 <zeta_0> it was buried deep in the documentation, i almost couldn't find it
21:45:51 <jackdk> monochrom: there is nothing to wonder about, ed is the standard editor so clearly it's the most widely-used and useful
21:46:04 <koz_> jackdk: Lols.
21:49:04 <monochrom> And for those on DOS without ed, GW-BASIC.
21:50:24 * hackage hasql-th 0.4.0.3 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.3 (NikitaVolkov)
21:50:49 <Axman6> koz_: he's not even joking, ask him
21:51:13 <koz_> Axman6: I'm sure.
21:51:30 <zeta_0> haskell's infrastructure is pretty especially when using nix to install, but there still is some strange quirks, and buggy features, after fixing the flycheck problem it does not lag anymore which is good
21:51:34 <monochrom> Oh God is it one of those angle-or-demon sentinel and either way of course they say "I am not joking".
21:51:58 <Axman6> he shared the release notes for the latest release of ed with me the other day, he's a madman
21:52:02 <monochrom> Therefore...  jackdk: Suppose I asked you whether you were joking or not, what would be your answer?  >:)
21:52:41 <monochrom> Haha, angle-or-demon, joker-or-madman.  Oh wait...
21:52:44 <koz_> monochrom: Yeah, it's a Smullen puzzle.
21:53:06 <koz_> s/Smullen/Smullyan/
21:54:19 <monochrom> Oh zeta_0 is already using emacs for IRC.  Maybe haskell-mode is not so far-fetched afterall...
21:54:46 <monochrom> Maybe dante.  At least still a live project.
21:56:07 <jackdk> monochrom: those on DOS should have EDLIN surely?
21:56:14 <monochrom> Oh!
21:56:47 <jackdk> apparently it went away in MS-DOS 6, so perhaps not.
21:57:34 <monochrom> DOS 6 killed the edlin.  WSL brought back ed.  :)
21:59:13 <monochrom> Did you know: A while ago someone used withCreateProcess to run cat, found it terminated prematurely, then I said you misunderstood withCreateProcess, so they tried to fix it with adding waitForProcess, and now cat hangs.
21:59:38 <monochrom> So I said: withCreateProcess killed the cat, waitForProcess brought it back.
21:59:54 <koz_> monochrom: Meow.
22:00:51 <jackdk> so for 23 years windows users had to make do without a line-oriented editor
22:01:17 <jackdk> actually one of my backburner projects is to implement ed, and test the implementation using state machine tests against real ed, but I keep getting bogged down in subprocess shenanigans
22:02:03 <jackdk> monochrom: also, to answer your earlier question:
22:02:04 <jackdk> ?
22:02:34 <monochrom> Aww I hate three-value logic.
22:04:18 <jackdk> monochrom: I'm making the ed-prompt-joke, not the 3-value-logic joke. I have used ed a bit when I've had weird machines that didn't play nice with the term I was connecting from, and it's a fun party trick
22:04:52 <monochrom> Ah
22:05:14 <Axman6> He does it, at parties, Iâ€™ve seen it
22:05:20 <Axman6> madman
22:06:14 <monochrom> Damn my lectures are not on April 1.  Would love live-code in ed in from of students on that day.
22:08:10 <jackdk> oh that would be a good trick
22:10:01 <Axman6> Reminds me a litttle of the competitions have writing python blindfolded, where they have to speak what is to be written
22:12:21 <monochrom> Pair programming the-blind-leading-the-blind edition.
22:12:45 <Axman6> More like the blind leading the mute but yes
22:12:53 <wikiemol> monochrom I am salty, and I still disagree. I think in many ways it is still technically true that you can't always check for null (especially in C where segfaults are possible). But thank you for your help regarding the tree thing regardless.
22:13:38 <monochrom> God, segfault is because you forgot to check for null, not because you can't.
22:14:01 <wikiemol> monochrom Segfaults can happen because you allocate memory you don't have access to 
22:18:27 <suzu> you ask for memory - the system says no - and you try to use that memory anyway
22:20:31 <monochrom> This is actually how some of my millenial students work.
22:20:50 <suzu> ^ what?
22:22:07 <monochrom> ask for memory or to open a file, the system says no, and they try to proceed anyway, and later instead of admitting negligence they blame it on "I can't".
22:22:21 <monochrom> "I can't check" to clarify
22:30:01 <nshepperd2> regarding 'save' in ghci, is there such a thing as a ghci-mode for emacs?
22:30:15 <nshepperd2> a colab-style live notebook thing
22:30:34 <tpham1> Hi all.
22:30:51 <wikiemol> Look, you are interfacing with the outside world. You can't guarantee anything that is going on out there from the language itself. The operating system can say no, but this isn't part of the language from a theoretical perspective. The operating system doesn't have to say no. 
22:36:15 <wikiemol> People complain about null because people use null incorrectly. The way people use null in imperetive languages is roughly equivalent to blatantly ignoring haskell's warnings about incomplete pattern matches. It's just not the right thing to do in almost every case. 
22:44:44 <tpham1> I'm not a haskeller but I'm looking for help to think in functional way. In this video: https://youtu.be/bmKYiUOEo2A?t=2999, Conal Elliott modeled  an image as `u :: Image->(Loc->Color)` and `u::Region->(Loc->Bool)`. I'm doing a data conversion framework, it's more less like the image editor project he mentioned in the video. My project doing some thing like get data from file then convert between some data structure like string -> A -> B -> C - > network pa
22:45:48 <nshepperd2> imperative language NULL is usually a conflation of a 'recoverable error' value which just marks the absence of something with a nonrecoverable pure exception (bottom)
22:55:32 <wikiemol> nshepperd2 Thats a good way of putting it in a way. I think the way I would look at is this. When you have a "referential" language, in which everything is basically a reference to "the outside world" you have to have a way of "parsing" the outside data into your type system, and letting the programmer know if it failed. The problem is that when
22:55:33 <wikiemol> you let the programmer know that you failed, if you don't have null, you again have to use memory to create the inhabitant of the failure type. Which could again fail. So you have to have null, which doesn't require falling back to something else that could fail. In reality, there are very few languages that are truly completely referential in
22:55:33 <wikiemol> nature (there are almost always primitive types). But in practice, this is how  OOP languages behave.
23:07:58 <fvr> Is there a cabal command to list all available components in the library?
