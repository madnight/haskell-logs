00:00:06 <amalloy> it does
00:00:20 <amalloy> let a = [b], and observe that they are the same
00:00:39 <iqubic> Oh. Oh right...
00:00:41 <amalloy> obviously not the function you wanted
00:00:51 <iqubic> No. The function I wanted was partitions.
00:01:43 <iqubic> That definition is from the combinatorial package.
00:09:19 <Poscat[m]> Hi all. Is using ReaderT with a modifiable environment (e.g. TVar) a good practice or should I use a StateT instead ?
00:12:01 <iqubic> StateT is much much much better.
00:13:35 <jle`> Poscat[m]: it's a good practice
00:13:43 <jle`> it's a common thing actually
00:13:48 <jle`> ReaderT (IORef a) IO
00:14:03 <jle`> well, it's a nice way to write functions paramterized on an IORef
00:14:15 <jle`> if you are doing things like multi-threading and concurrency
00:14:23 <jle`> you can't really do that kind of stuff with StateT
00:14:38 <MarcelineVQ> iqubic: why?
00:14:41 <iqubic> jle`: Are you saying that my answer is wrong?
00:14:50 <jle`> you can think of it as, StateT is for dealing with (s -> (a, s)) functions in a nice way, and ReaderT is for dealing with r -> a functions in a nice way
00:15:01 <iqubic> MarcelineVQ: I don't actually have a good reason.
00:15:06 <jle`> and if your thing is TVar X -> ... then it makes sense
00:15:17 <MarcelineVQ> Then that's probably not the advice to give someone
00:15:26 <jle`> using StateT with a TVar doesn't quite make sense unless the pointer is being swapped out or something
00:16:16 <jle`> seeing as you are using 'TVar' it suggests you're dealing with things like concurrency and parallelism and nondeterminancy with IO, so it's not something that StateT can really handle
00:41:23 <amalloy> i feel like it's hard to answer this question without asking, or assuming answers to, questions like "what is this function going to do"
00:44:09 <wagle> how do i figure out whats non-exhaustive about [] and (a : as)
00:47:10 <cocreature> wagle: can you show us the code and the full error you get?
00:49:01 <wagle> https://gist.github.com/wagle/e56e1a0cf7e83290a452192bf71eec14
00:49:42 <wagle> cocreature: ^^^
00:52:16 <cocreature> wagle: that’s because you are working in ghci. the second line will define a new function called "greedy" and shadow the one defined in the first line
00:53:02 <wagle> <nelson> HAha! </nelson>
00:53:11 <cocreature> you can enter multiline definitions by starting with ":{" and ending with ":}" but I would recommend to just define things in a file and load them via ":l"
00:53:20 <jle`> yeah ghci can be kind of surprising here
00:55:24 <Poscat[m]> jle` thanks
00:56:05 <jle`> Poscat[m]: but yeah, as amalloy said, it depends on what you want to do with the thing
00:56:32 <wagle> I knew there was a reason to fire up emacs, but repl'ing seemed faster
00:57:03 <jle`> wagle: you can also enable multiline mode with `:set +m`, but it's not as usable still as writing a file
00:58:37 <wagle> Prelude> :| load-balancing.hs 
00:58:37 <wagle> unknown command ':|'
01:00:36 <jle`> wagle: ah, that should be :l, as in the letter "l"
01:00:42 <jle`> > succ 'k'
01:00:45 <lambdabot>  'l'
01:00:57 <wagle> haha
01:01:00 <jle`> > toLower 'L'
01:01:02 <lambdabot>  'l'
01:01:46 <MarcelineVQ> short for :load
01:02:58 <wagle> yeah
01:03:18 <wagle> got it, thanks..  rusty
01:32:11 <absentia> anyone awake?
01:32:44 <kaol> That's a nice domain.
01:32:51 <absentia> thx
01:33:20 <Orbstheorem> Heh
01:36:03 * absentia is not here.
01:42:06 <absentia> heh
01:43:12 <absentia> if I'm even asking this correctly:  is 'Control' not in LTS ?  or, alternatively, is resolver supposed to find it without me specifying it explicitly?
01:44:15 <absentia> I can not figure out how to get that library to work when using stack (I can figure out it with cabal)
01:44:28 <absentia> this is 'stupidly difficult'
01:45:19 <amalloy> Control is a namespace not associated with any single library
01:45:24 <amalloy> what are you trying to use?
01:45:35 <absentia> sorry. bashing my head against my keyboard.
01:45:50 <absentia> parallel1.hs:2:1: error: Could not find module ‘Control.Parallel’
01:46:03 <absentia> just trying to figure out how to get that to work with stack.
01:46:27 <absentia> cabel = 30 seconds.  stack = 90 minutes of frustration
01:47:15 <absentia> either I'm completely missing it -- or this is a huge gap in the documentation for first time users (of stack)
01:49:20 <amalloy> Control.Parallel is in package `parallel`, so you need to add parallel to your dependencies in package.yaml
01:49:27 <absentia> ok, "stack new blah blah"  got it.
01:49:29 <absentia> jeeze.
01:49:36 <absentia> yes!
01:49:42 <absentia> "dependencies:"
01:49:47 <absentia> stack says that's not valid :-)
01:50:40 <amalloy> oh, or put it in the cabal file that got generated? i always forget where stuff goes
01:50:42 <MarcelineVQ> sure it says more than that
01:50:45 <MarcelineVQ> *surely
01:51:12 <jle`> without the error message it's hard to know how to help
01:51:29 <absentia> I did a stack init ...   so I was trying to fifure out what goes into the stack.yaml -- and the documentation didn't match.
01:51:40 <jle`> or well maybe more importantly what files you changed and stuff
01:51:50 <MarcelineVQ> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
01:52:18 <jle`> ah. my guess is that you changed the stack.yaml and not the package.yaml
01:52:28 <absentia> I pasted the error message.  The response here is what I figured -- it needs to be added to "dependencies" -- but there is no clear information on how to do that.  the docs seem to say put something after "dependencies:" in stack.yaml -- but that section doesn't exist -- and adding it causes stack to give  a parsing error on stack.yaml
01:53:08 <MarcelineVQ> Which docs day that?
01:53:09 <absentia> argh!  ok.   so dependencies is in package.yaml not stack.yaml
01:53:52 <absentia> I'm going to read this from top to bottom:  https://docs.haskellstack.org/en/latest/GUIDE/
01:54:28 <absentia> it's in the section "Adding dependencies" -- it clearly says add it to "package.yaml" :-)
02:00:03 <absentia> just trying to get this to run via stack:  https://www.spy.org/tmp/parallel1.hs
02:00:46 <absentia> again, cabal:  easy.  install Parallel -- ghc parallel1.hs, then run it.   stack?   first I seem to need to create the universe.
02:11:01 <thblt> package.yaml describes the package in a build-system-indedendant way, stack.yaml configures stack to build it.
02:11:15 <thblt> And yeah, stack has some sharp edges :)
02:20:08 <jackdk> This is one of the reasons I don't consider package.yaml an improvement
02:35:44 <MarcelineVQ> In this case parallel was already in scope so it looked like a difference between build systems as well. Even though the solution, adding the dependency to your cabal file, would have been the same if parallel hadn't been in scope already for cabal-install.
02:43:24 <MarcelineVQ> thanks to ghcup though I can finally use cabal instead of stack again, so that's fun
02:51:03 <thblt> cabal v2- sounds really cool
02:51:57 <MarcelineVQ> the v2 stuff is default as well on recent cabal-install versions afaik
02:52:54 * thblt pops a nix shell to give it a try
02:57:17 <__monty__> Versio*n*, afaik.
02:58:30 <MarcelineVQ> I guess yeah, 3.0.0.0
03:00:24 <thblt> Yeah, v2-build==build, and so on
03:03:28 <thblt> It's nice how cabal-v2 “just works”. Not exactly my previous experience with cabal-install.
03:08:37 <thblt> While it's all nice and quiet in here: I wrote this https://paste.thb.lt/1578827126.hs.html and have two questions: 1) does it make sense and 2) is there a way to get the default implementation of same to compile?  It's a simple typeclass for stuff which can be associated with an Eq identifier, and I feel unsure about needing two language extensions for something so simple. Thanks!
03:11:36 <MarcelineVQ> rather than AmbiguousTypes you might try  FunctionalDependencies   and   class (Eq i) => Identifiable i t | t -> i where
03:13:29 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#functional-dependencies though it's surpsiringly underdocumented
03:13:31 <MarcelineVQ> https://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf
03:14:17 <MarcelineVQ> oh, no it's not, I was looking at the wrong thing, they do explain a fair bit in the ghc manual link
03:15:00 <thblt> MarcelineVQ: thanks, looking into this!
03:20:21 <jpcooper> Morning. I am trying to do an ST monad like trick, where I have `data Parameters p = Parameters (Map String (Set String))` and `data SubParameter p = SubParameter String String`, which is an assignment obtained from a `Parameters p` instance. I have another `data Cube p a = X (SubParameter p) a | Y (SubParameter p) a | ...`, which for a unique `p`, I want to ensure is constructed from a unique `Parameters p` instance. I am missing how
03:20:21 <jpcooper> to do this. Can anyone help?
03:21:16 <jpcooper> In essence: How to ensure that `SubParameter p` instances are obtained from a unique `Parameters p` instance?
03:34:05 <__monty__> jpcooper: Class instances are unique unless you allow OverlappingInstances and maybe other extensions.
03:34:29 <jpcooper> __monty__: Sorry. By instance I mean a value of that type
03:34:59 <__monty__> Oh, right, they're types, not classes, whoops.
03:35:40 <jpcooper> I have a value of type `Parameters p` from which I construct values of type `SubParameter p`. I construct values of type `Cube p a` using those values of type `SubParameter p`. I want to ensure that a `Cube p a` is constructed from `SubParameter p` values constructed from a unique `Parameters p` value. I was hoping to do this with an ST monad-like trick
03:35:54 <xeno> hi, what's the right type for a data definition containing a HashMap?  trying 'data memory = (HashMap Int Int), but apparently not... 
03:35:59 <xeno> or (Map Int Int) 
03:36:38 <jpcooper> xeno: Are we talking about HashMap from unordered-containers?
03:36:59 <__monty__> xeno: You can't define a type starting with a lowercase letter.
03:37:18 <xeno> __monty__: that was a typo, it was actually Memory 
03:37:25 <__monty__> And you need to provide a constructor name if you use data.
03:37:33 <xeno> jpcooper: I've imported Data.HashMap
03:37:42 <__monty__> Maybe you're looking for a type synonym? `type Memory = Map Int Int`
03:37:52 <jpcooper> xeno: Do you know which package you expect this to come from?
03:38:32 <xeno> jpcooper: Data.HashMap
03:38:42 <xeno> but yeah, the constructor name ofc explains it...
03:39:28 <jpcooper> xeno: Data.HashMap is actually a module
03:40:08 <xeno> jpcooper: you mean what package that module is in? standard library? 
03:40:28 <xeno> I'm btw n00bing around here, but I guess that's more than obvious...
03:41:06 <matheus23> xeno: you might want to consider simply using Data.Map, it should be more beginner-friendly to use
03:41:23 <matheus23> I could create a simple example file that illustrates a Data.Map usage
03:41:29 <matheus23> that you could load up in ghci
03:43:22 <xeno> matheus23: no need, I think I got it now... but thanks for the offer
03:43:34 <matheus23> alright :)
03:51:54 * hackage regex-do 3.2.1 - PCRE wrapper  https://hackage.haskell.org/package/regex-do-3.2.1 (procione)
04:34:02 <yushyin> has anyone ever tried ghcide in combination with cabal's mixins? I just tried it and ghcide seems to ignore the mixins.
04:43:29 <jusss> > groupBy (\x y -> if (x-y) == -1 then True else False) [0,1,2,3,5,6]
04:43:31 <lambdabot>  [[0,1],[2,3],[5,6]]
04:43:48 <jusss> why it's not [[0,1,2,3],[5,6]]?
04:44:03 <jusss> > groupBy (==) [0,0,1,1,1,5,6]
04:44:06 <lambdabot>  [[0,0],[1,1,1],[5],[6]]
04:50:30 <madnight> :t groupBy
04:50:32 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
04:50:38 <MarcelineVQ> You'll want to look at groupBy's source which doesn't compare each element with the next one but actually uses span. So as I understand it we don't check 0 and 1, then 1 and 2, then 2 and 3. We check 0 and 1 and 2 and 3, and on...  0 - 1 is -1  but 0 - 2 is not -1, and 0 - 3 is not -1
04:52:59 <madnight> > groupBy (const . const True) [0,0,1,1,1,5,6]
04:53:01 <lambdabot>  [[0,0,1,1,1,5,6]]
04:54:07 <jusss> MarcelineVQ: is there other library function can do this?
04:54:21 <MarcelineVQ> I don't know
04:54:25 <jusss> check one and the next one
05:00:48 <maerwald> how do you do type synonyms in dhall?
05:08:59 <jusss> I don't want to write a very twisted recursive function to do this, I wonder if there's a elegant way?
05:10:45 <kuribas> jusss: there is a library that does that
05:11:05 <jusss> kuribas: what's it?
05:11:11 <juri_> jusss: folds are fun. :)
05:11:43 <kuribas> jusss: I don't remember.  Something by byorgey I think
05:16:38 <kuribas> jusss: maybe this one: https://hackage.haskell.org/package/groupBy-0.1.0.0/docs/Data-List-GroupBy.html
05:17:28 <maerwald> seems dhall doesn't have first class Maps
05:22:15 <jusss> kuribas: yeah, it did what I want
05:22:44 <jusss> kuribas: but the definition is twisted too...
05:24:39 <jusss> juri_: is there a function call `folds`?
05:24:47 <jusss> or you mean foldl or foldr
05:26:48 <xeno> hi, when I do stack run, it bugs me to add - queue-0.1.2@sha256:4efac395db09637ec7b667dc09b74ff80e0b83452088540e1d1b2ec262f4defa,1312
05:26:49 <xeno>  to stack.yaml (I got queue >= 0.1.2 in package.yaml) - is that a good idea? 
05:28:33 <MarcelineVQ> when it says that it's because the version of the package that fits your requirement isn't in the resolver you've chosen
05:29:17 <MarcelineVQ> you can either relax the version bounds, if queue exists in your resolver, or add it to extra deps as it suggests.  - queue-0.1.2  is enough, you don't need all that extra sha stuff
05:32:22 <xeno> tried relaxing... it says queue must match ==0.1.2, but the stack configuration has no specified version  (latest matching version is 0.1.2) - so not sure any relaxing would help... am I even using the right package? 
05:32:25 <MarcelineVQ> queue doesn't seem to exist in any resolver so you'll definitely need to add it to extra-deps so stack knows to get it from hackage
05:33:09 <maerwald> what's the point of dhall when I can just create my more complex config in haskell, convert it to json and validate it with the parser before I push it somewhere
05:33:25 <MarcelineVQ> "the stack configuration has no specified version" means that nothing in stack.yaml (the stack configuration) has provided a way to get the package, meaning the resolver doesn't have it and it's not in your extra-deps
05:36:58 <MarcelineVQ> xeno: https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/ is a good read
05:39:06 <maerwald> I am sure that is not biased... lol
05:39:30 <MarcelineVQ> biased in that it.. ?
05:39:41 <maerwald> ah, I thought it compares project files
05:39:42 <maerwald> nvm
05:40:09 <MarcelineVQ> I link it mostly to explain what a stack.yaml is for rather than package.yaml and such
05:40:45 <maerwald> newtype Foo = Foo (NonEmpty Bar) deriving IsList -- doesn't work, even with GeneralisedNewtypeDeriving :/
05:41:14 <maerwald> it wants undecidable instances
05:41:53 <xeno> maerwald: iI'kk read that one... but when I just want a simple queue, and the package I try to use is not available, my first thought is that I'm doing something wrong... since a queue should not be something uncommon...
05:51:55 <xeno> turns out I was right, I need to use Data.Sequence
06:09:35 <maerwald> https://git.io/Jvfii I wish I could do that in dhall :/
06:16:22 <MarcelineVQ> What part is missing, and why would you prefer dhall?
06:16:39 <maerwald> Maps are missing
06:17:02 <maerwald> I would most certainly write two different representations, one in dhall, one in haskell
06:17:20 <maerwald> also, enums in dhall can't be record types
06:19:52 <maerwald> it seems like it'll be easier to just create an executable that lints/checks the config file that would be in json format
06:20:11 <maerwald> which would initially just be "does it parse?"
06:20:41 <MarcelineVQ> What's the advantage of dhall in this task, compiling to a shell script or some such?
06:21:10 <MarcelineVQ> mentioning that since iiuc ghcup is a shell script
06:21:11 <maerwald> I can convert to many formats
06:21:31 <maerwald> and the linting might be more powerful than just checking whether something parses
06:22:17 <maerwald> e.g. not sure json parsing cares about uniqueness of maps (according to the standard, it doesn't, so a haskell parser would have to allow it)
06:22:36 <maerwald> and then behavior is unpredictable if there are duplicate keys
06:22:57 <maerwald> I would suspect you don't have these problems in dhall
06:32:14 <MarcelineVQ> maerwald: does dhall have a Maybe type?
06:36:26 <Clint> MarcelineVQ: Optional
06:36:52 <MarcelineVQ> I wonder why dhall wouldn't have a Map then, if there's a type to handle failure.
06:43:44 <Clint> https://docs.dhall-lang.org/discussions/Design-choices.html
06:48:55 <MarcelineVQ> hmm iow "If we added these people would shove values in them just to do comparison on them"
07:00:53 * hackage barbies 2.0.0.0 - Classes for working with types that can change clothes.  https://hackage.haskell.org/package/barbies-2.0.0.0 (DanielGorin)
07:03:52 <maerwald> lol
07:06:47 <MarcelineVQ> cute names are great but easy to find packages are greater ^^;
07:09:39 <MarcelineVQ> Not that I have a better one there, searchable isn't a well defined term in the first place unless you're google
07:10:32 <MarcelineVQ> and if you were you'd type in "hkd" in hackage and it would say: showing results for "hkt"
07:10:35 <yushyin> i know this by the name higher kinded data from a blogpost I once read.
07:10:44 <thblt> I wonder what's an actual use case for such types.  
07:10:55 <MarcelineVQ> yushyin: yeah the packages docs link to that :>
07:11:04 <yushyin> good!
07:11:40 <MarcelineVQ> thblt: supposedly it's pretty common in libraries, though I don't see enough libs to know one way or the other,   writeup here:  https://hackage.haskell.org/package/barbies-2.0.0.0/src/src/Barbies.hs
07:12:43 * thblt reads.
07:13:05 <thblt> I just found harg, which use those types for command line argument parsing, which indeed makes sense.
07:15:53 * hackage hanabi-dealer 0.3.0.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.3.0.0 (SusumuKatayama)
07:18:07 <rhinoceratops> q: Is there something I can derive to make my custom data type work with arithmetic?
07:20:29 <rhinoceratops> for example I can define a custom instance of Eq and Ord as in this SO answer https://stackoverflow.com/questions/3065954/defining-own-ord-for-a-data-type/3065984#3065984
07:23:04 <rhinoceratops> is there a data type that can be derived from like Eq or Ord that would allow use of the `+` operator, for example?
07:24:04 <rhinoceratops> this is mostly a curiosity question, there isn't a use case atm
07:24:10 <__monty__> rhinoceratops: You can implement an instance for Num. Doubt you can derive one though, even with generic deriving.
07:24:37 <rhinoceratops> oh that's what I meant thanks
07:24:53 <MarcelineVQ> What does your datatype look like?
07:24:56 <rhinoceratops> i'm relatively new to writing haskell so i didn't use the right words - thanks
07:25:30 <MarcelineVQ> if your type is straightforward like   data Foo = MkFoo Int   you could derive instances by using the instances for Int for example since your type is really just a wrapper
07:26:13 <__monty__> Does that work for non newtypes?
07:26:51 <MarcelineVQ> on step at a time :>
07:28:01 <MarcelineVQ> 'cause if it's not a datype like that it's not relevant. but yes that requires newtype with GeneralizedNewtypeDeriving or DerivingVia
07:34:26 <rhinoceratops> i want to share a gist but i'm getting a mysterious parse error so obviously i'm getting something else wrong but anyway
07:34:30 <rhinoceratops> https://gist.github.com/cruxicheiros/80e7f9a04310a1fdc39dc9f7e6541739
07:35:11 <rhinoceratops> i am trying to write implementations of election systems as a revision exercise
07:35:40 <__monty__> rhinoceratops: You're pattern matching with the constructor "Candidate", but there is no constructor by that name.
07:35:41 <MarcelineVQ> it's because you don't have a data constructor for your type, you've only given fields.   data Candidate = MkCandidate Name Votes
07:35:41 <rhinoceratops> and i was thinking it would be handy in different systems (for example IRV) to be able to add one candidate's votes to another
07:37:26 <__monty__> I'm not sure a Num instance makes sense tbh. That implies not only `+` but also negate, abs, multiplication, division...
07:37:54 <__monty__> Operator overloading often *looks* like a good idea.
07:38:09 <rhinoceratops> true I should probably just write a function instead of being clever about it
07:54:38 <solonarv> it is an infelicity that 'Num' bundles so many of the arithmetic operations
07:55:22 <merijn> Num is like democracy
07:55:32 <merijn> It's terrible, but not as bad as the alternatives
07:56:26 <solonarv> eh, at least a split into 2-3 typeclasses would be reasonable IMO
07:56:33 <nshepperd2> if the only thing you can implement is (+) maybe Semigroup would be more appropriate
07:56:34 <solonarv> of course it's hard to make such a big change *now*
07:58:11 <solonarv> a sensible split might be:
07:58:36 <solonarv> class Semiring a where (+), (*) :: a -> a -> a; fromNatural :: Natural -> a
07:58:58 <solonarv> class Semiring a => Ring a where (-) :: a -> a -> a; negate :: a -> a; fromInteger :: Integer -> a
07:59:25 <solonarv> class Ring a => Euclidean a where abs, signum :: a -> a
08:16:58 <ibrahims> hello people
08:17:47 <solonarv> ibrahims: hello person!
08:18:07 <ibrahims> i have been trying to pass a (Ptr Float) to a foreign function for the last couple of hours but it goes wrong somehow
08:18:23 <ibrahims> whereas it works for Ptr CInt
08:18:32 <ibrahims> Ptr CFloat did not work either
08:18:45 <ibrahims> i am starting to pull hairs
08:18:58 <ibrahims> do you know of anything i should read?
08:20:15 <solonarv> "goes wrong somehow" is not very informative! I would suggest sharing your code as well as the error message you're getting
08:20:16 <thblt> What language is the foreign function is?
08:21:34 <ibrahims> the function is generated on the llvm jit
08:22:15 <ibrahims> and passing int array works fine but float array does not
08:22:32 <ibrahims> the data is all zeros
08:23:32 <ibrahims> i could not figure out what to share or how to inform and code is a mess 
08:23:51 <ibrahims> sorry to bother you with such a vague problem
08:29:42 <ibrahims> traverse (peekElemOff verticesPtr >=> putStrLn . show) [0..10]
08:30:09 <ibrahims> prints the first 10 elements of the array just fine
08:30:39 <ibrahims> but when i pass the verticesPtr to a foreign function the data is all clear
08:30:55 <ibrahims> nothing in it
08:37:01 <maerwald> https://hackage.haskell.org/package/waargonaut-0.8.0.1/docs/Waargonaut-Decode-Traversal.html says deprecated, but the module it points to has none of its functions
08:39:43 <thblt> ibrahims: wrong type size maybe? couldn't your fereign function be expecting doubles, or something like that?
08:42:52 <ibrahims> thblt: that does not seem to be it.
08:43:51 <ibrahims> it does not change when i explicitly expect doubles either
08:45:30 <MarcelineVQ> maerwald: looks like it should be pointing to https://hackage.haskell.org/package/waargonaut-0.8.0.1/docs/Waargonaut-Decode.html
08:46:31 <ibrahims> although it is funny to be getting all zeros
08:46:33 <MarcelineVQ> to my untrained eye anyway
08:47:08 <thblt> ibrahims: have those floats actually been evaluated, or may it be a laziness issue?
08:48:01 <ibrahims> oh boy that might actually be it.
08:48:04 <MarcelineVQ> maerwald: oh interesting, some haddock fail? src shows correct thing for that deprecated message https://hackage.haskell.org/package/waargonaut-0.8.0.1/docs/src/Waargonaut.Decode.Traversal.html
08:48:57 <maerwald> maybe I am just unable to do basic things like navigating websites
08:48:58 <thblt> ibrahims: see seq, IIRC
08:50:05 <MarcelineVQ> maerwald: it's linking incorrectly
08:50:11 <thblt> or ! maybe
08:50:25 <MarcelineVQ> Waargonaut.Decode is being treated as and identifier called Decode within Waargonaut module
08:50:30 <maerwald> is there an efficient way to convert between ByteString and ByteString.Char8 without turning it into a list of Word8?
08:50:46 <solonarv> maerwald: IIRC they are the same type
08:51:01 <monochrom> poke causes evaluation.  peek doesn't care, C has already evaluated before you peek.
08:51:10 <solonarv> Data.ByteString.Char8 just has a bunch of questionably-safe functions
08:51:30 <ibrahims> thblt: https://hackage.haskell.org/package/wavefront-0.7.1.3/docs/Codec-Wavefront.html#t:Location this location type is strict in its fields right? 
08:52:08 <maerwald> solonarv: but the types are in different modules. Are you proposing to use coerce?
08:52:32 <maerwald> I'm not convinced the in-memory representation will even be the same
08:52:47 <solonarv> I am saying that they both reexport Data.Bytestring.Internal.ByteString
08:52:54 <solonarv> I may be misremembering, though - let me ehcek
08:52:56 <cocreature> there is only one type
08:52:56 <solonarv> *check
08:53:10 <MarcelineVQ> solonarv: afaict it is doing that
08:53:21 <maerwald> and is the in-memory representation the same?
08:53:33 <cocreature> maerwald: it is literally the same type so yes
08:53:41 <solonarv> of course it's the same! it is the same type!
08:53:48 <maerwald> err
08:53:49 <cocreature> you don’t need "coerce" because it’s the same type
08:53:58 <solonarv> https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Char8.html#t:ByteString ; https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString.html#t:ByteString
08:54:12 <solonarv> the 'Source' links there point to the same definition: https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/src/Data.ByteString.Internal.html#ByteString
08:54:18 <maerwald> (ForeignPtr Word8)
08:54:28 <maerwald> don't tell me that enforces results
08:54:50 <cocreature> what do you mean by "enforces results"?
08:55:11 <thblt> ibrahims: I don't know, sorry. From what I read, the fields are strict, but I don't know if that makes the type itself strict, ie if that means thunks of type Location cannot exist.
08:55:32 <solonarv> Data.ByteString.ByteString and Data.ByteString.Char8.ByteString are the *same type*, much like Prelude.Maybe and Data.Maybe.Maybe are the same type
08:55:45 <maerwald> cocreature: it is a pointer somewhere into memory, that's all I know. I don't know what that memory looks like, even if the types are the same
08:56:10 <solonarv> it doesn't matter anyway, why are you mucking about with the internal representation of ByteString?
08:56:32 <maerwald> I don't want my code to misbehave? :)
08:57:04 <cocreature> as long as you stick to the public interface the invariants on the internal representation are uphold
08:57:33 <solonarv> you are worried about misbehavior when "converting" between Data.ByteString.ByteString and Data.ByteString.Char8.ByteString, yes?
09:00:03 <ibrahims> thblt: Thanks.
09:00:17 <ibrahims> I think i'll call it a day. Good luck to you all.
09:00:42 <maerwald> solonarv: I guess I can trust the API if they unify it over the same type
09:01:10 <maerwald> Just pointing out that, in practice, the types don't mean anything ;)
09:01:30 <maerwald> (yes, that's how much I trust libraries in general)
09:03:34 <solonarv> maerwald: the types are the same, however you are right to be wary - because the Char8 stuff is dubious and will go wrong as soon as you have non-ASCII data
09:03:50 <merijn> Don't use Char8, don't use Char8, don't use Char8...
09:03:51 <maerwald> Well, I know I have ASCII data
09:03:59 <maerwald> Because I control the input
09:04:09 <maerwald> In fact, I would want a proper ascii type
09:04:11 <maerwald> Char8 isnt
09:04:38 <monochrom> {-# LANGUAGE OverloadedChar #-}  >:)
09:04:51 <merijn> maerwald: What are you trying to do? (I missed the setup)
09:06:11 <maerwald> merijn: URLs
09:06:15 <maerwald> which are ascii
09:06:37 <merijn> That's not really something you're trying to do, but some data
09:07:03 <maerwald> yeah, creating a waargonaut encode/decoder for ByteString.Char8, but I guess that's pointless if the types are the same
09:07:15 <maerwald> however, I get compile errors, so apparently there is something wrong
09:07:26 <merijn> Char8 exists just to expert questionable functions
09:07:30 <merijn> maerwald: strict vs lazy?
09:08:19 <maerwald> Could not deduce (JsonEncode GWaarg C.ByteString)
09:09:05 <maerwald> I'm probably using it wrong ;)
09:15:34 <maerwald> yeah, have to provide the instance manually it seems
09:15:45 <maerwald> waargonaut seems like slightly more boilerplate
09:19:21 <dminuoso_> monochrom: Oh yes, that should be a thing.
09:29:26 <maerwald> so there's a bytestring decoder, but not a bytestring encoder :)
09:34:39 <merijn> hmm, anyone know a tool that diffs two files in a way that lets me verify there are only deletions (or only insertions)?
09:35:08 <[exa]> merijn: diff x y |grep ^+ ?
09:35:57 <merijn> [exa]: Not quite, I think as diff may generate spurious entries when it thinks something is more shortly described as an insert + delete, instead of just deletes
09:36:44 <[exa]> merijn: AFAIK it should not do that (the algorithm is workalike of maximum common subsequence)
09:36:58 <[exa]> merijn: but if you have a counterexample I'm very interested
09:37:19 <merijn> I can try, at least it should never have false positives
09:37:49 <maerwald> --minimal may have an impact on it
09:38:13 <[exa]> merijn: the point is that if the files are convertible using deletions only (or the other way), diff should be able to find it.
09:38:53 <geekosaur> diff has multiple algorithms and may use heuristics such as file size to pick different ones
09:38:59 <xeno> hi, in a module, I have defined a type data MyValues = FOO | BAR | BAZ | ZOT | XYZZY...  -  how can I export them without listing them all again in the module declaration? 
09:39:32 <[exa]> merijn: otherwise if only one type of edits are allowed I believe that a greedy algorithm should be sufficient for the decision
09:39:36 <geekosaur> MyValues(..)
09:40:13 <geekosaur> that's exactly two periods
09:40:20 <[exa]> xeno: T(..) is a shortcut for "every constructor that belongs to T"
09:41:15 <dmwit> It may also be worth mentioning that you can export the current module. (This is relevant, for example, if you want to re-export another module, and there's nothing in the current module that you want to avoid exporting.)
09:41:33 <dmwit> module Foo (module Foo) where ...
09:42:39 <maerwald> merijn: https://hackage.haskell.org/package/darcs-2.14.1/docs/Darcs-Patch-SummaryData.html#t:SummOp with darcs you could :P
09:42:53 <maerwald> match on SummAdd and SummRm ;)
09:45:12 <xeno> geekosaur: [exa]: thanks :)
09:47:53 * hackage hanabi-dealer 0.3.0.1 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.3.0.1 (SusumuKatayama)
09:50:03 <[exa]> hm, is there any regex to finite-state-machine compiler in a package? I'd like to have a tokenizer that users may customize using e.g. commandline parameters, and I can't think about anything better
09:51:23 <zeta_0> hello guys, i was having to much problems with haskell-ide-engine so i decided to give ghcide a try and it works great, the only issue that i am having is with imports, for some reason ghcide is not recognizing the modules that i have installed?
09:52:30 <[exa]> zeta_0: does it know what environment you're using?
09:55:13 <[exa]> more specific question to the above: What happens if I attoparse an expression that describes a parser and use it to construct another attoparser?
09:55:37 <merijn> [exa]: That's fine
09:55:42 <[exa]> Performance penalty?
09:56:18 <merijn> [exa]: Depends, do you use the parser directly on the same input or on separate input? (Although I wouldn't think it'd have much if any impact in the former case)
09:56:23 <solonarv> [exa]: I think one of the regex packages (possibly many/all of them) have "parse this string to a dfa"
09:56:31 <[exa]> like, performance is not critical but I wouldn't like it to be super-slow
09:56:43 <glguy> [exa]: attoparsec parsers that generate parsers to be used is most often just "using the Monad instance"
09:56:46 <[exa]> merijn: a separate input
09:56:48 <merijn> [exa]: Why would it be super slow? Unless you do it like a billion times
09:56:57 <merijn> [exa]: In separate input it should have no result at all
09:57:43 <zeta_0> [exa]: i don't know, how do i troubleshoot this?
10:00:05 <[exa]> zeta_0: I don't have much experience in that direction but likely something from here https://github.com/mpickering/hie-bios
10:00:48 <[exa]> merijn: I didn't look very much at attoparsec implementation and how much it relies on compile-time optimizations
10:00:48 <solonarv> [exa]: does this correctly describe your use case: your user enters some text. you turn this text into a regex/parser/finite automaton. you match this thing against some other text
10:01:28 <[exa]> solonarv: yes, the input is basically regex, but slightly extended with some special marks
10:01:31 <zeta_0> i installed ghcide with nix and all of it's features seem to be working fine, the only problem that i am having is when i try to import, i get the error: could find module, it is not a module in the current program, or any known package
10:02:09 <solonarv> [exa]: ah, I was going to suggest using one of the existing regex packages
10:02:25 <solonarv> and just letting it handle everything
10:02:46 <solonarv> if you have custom extra bits obviously that won't work, but perhaps you can still reuse its DFA handling or whatever
10:03:02 <[exa]> I guess some of these will have the custom bits
10:03:18 <zeta_0> [exa]: thanks i'll take a look now]
10:03:34 <[exa]> basically the only thing I want to do is to separate the input into tokens vs. whitespace and the tokenization should be customizable to allow a decent subset of current programming languages
10:03:35 <solonarv> there is a regex-pcre package, if that will do the job
10:03:57 <[exa]> tokenization only, no actual parsing or ASTs at all
10:04:19 <solonarv> I see, that makes sense
10:04:41 <solonarv> certainly looks like something a standard regex dialect could do
10:06:35 <[exa]> yeah, technically it must be doable by DFA
10:21:18 <TheCommieDuck> So trying to get my head around prisms. I have a Data.Map String Foo, where Foo = Foo1 Int | Foo2 Bool (let's say). I want to lookup some entry in the map, and if it's a Foo1 then increment it, else do nothing. is there a nicer way than ```over (theMap . ix key ) (\y -> case y of Foo1 r -> r+1; otherwise -> id)```? 
10:23:29 <TheCommieDuck> as in, it strikes me as something that there would be a nice simple prism operator for; "over if the right branch, else nothing"
10:23:35 <sQVe> Is possibly anyone here comfortable with Hindley Milner signatures in JavaScript? I'm a bit confused about one aspect of it.
10:24:22 <fog> these type errors just keep getting less readable
10:25:32 <fog> https://pastebin.com/raw/CmZfffCt
10:26:25 <fog> trying hfoldl now which is easier because the return type constrains pairs of adjacent values, instead of foldr where the return type is at the far right
10:29:03 <fog> the C2Cons' with the type application is putting the return type (of the first two values of the list) back onto the head of the list for recursion, which is why it has the constraint with the types x z, as x -> y -> x was done on the first two values of (x ': y ': z ': xs
10:29:34 <fog> the typechecker is returning very strange messages in response
10:31:56 <lyxia> I have a hard time imagining defunctionalized type classes have a legitimate purpose...
10:32:17 <TheCommieDuck> well, seems I can do over (theMap . ix key . _Foo1) f and have f be Int -> Int rather than Foo -> Foo which is neat
10:32:45 <fog> lyxia: why? they seem to work just fine
10:36:10 <zeta_0> does ghcide come built-in with hie-bios or do i need to install it separately? also do i need to place this code in ~/.cabal/config or does it need to be placed in the .cabal file of a specific project?
10:36:14 <zeta_0> cradle: {cabal: {component: "lib:haskell-ide-engine"}}
10:36:16 <fog> i guess its nesacary too since otherwise it would be complain that it needs arguments applied
10:37:06 <[exa]> sQVe: which aspect btw?
10:37:08 <lyxia> fog: maybe it works, but this looks like unnecessary, overengineered complexity
10:37:50 <fog> no way i would have done that if there was no need...
10:38:25 <monochrom> lyxia: Generally most of type-level wishes.
10:38:52 <sQVe> [exa]: I'm confused on how specific I should be. I have a Container that has a specific design but should I still write the signature like: combineContainers :: {k: v} -> {k: v} -> {k: v} or maybe: combineContainers: :: {a} -> {b} -> {c}.
10:38:54 <monochrom> if the language is not a real dependently typed language, that is.
10:39:14 <fog> cant quite remember why though, maybe it was something to do with matching on it, or having a class in terms of it
10:39:15 <monochrom> Hell, even a real one like ATS can still be like this.
10:39:19 <sQVe> Or furthermore... combineContainers :: Container a -> Container b -> Container c.
10:39:26 * sQVe is confused...
10:40:31 <monochrom> I bet you mean Container a -> Container a -> Container a
10:41:07 <sQVe> monochrom: You are probably right... I'm most likely misunderstanding the concept.
10:41:42 <[exa]> sQVe: how does "k: v" translate to normal HindleyMilner?
10:42:03 <monochrom> Perhaps {k:v} is like Map k v.
10:42:08 <[exa]> oh so.
10:42:11 <sQVe> [exa]: It's just a concept taken from the Ramda.js lib.
10:42:27 <sQVe> A object that is simply a key/value Record.
10:43:05 <[exa]> sQVe: anyway the questions of "how specific" are best resolved by writing the explicit "forall"s in the type, reading it aloud and seeing whether it still makes sense
10:43:30 <fog_> ah, ok, its defunctionalised because it needed to combine 2 constraints that both took 2 args together, and its that type family thats defunctionalised, not actually a class
10:43:39 <fog_> its just confusing that it returns a Constraint
10:44:03 <zeta_0> i don't understand the instructions how to setup hie-bios, could you guys help me out: https://github.com/mpickering/hie-bios
10:44:13 <[exa]> sQVe: in your case, I guess the a/b/c case is not going to pass that check
10:44:54 <zeta_0> yaml files are for the stack build tool right, i use nix integrated with cabal, so i don't think i need a hie.yaml file right?
10:45:59 <sQVe> [exa]: Hm, I'm a but unsure on what you mean by forall's. 
10:46:20 <Solonarv_> zeta_0: yaml is just a generic data/config format like json, toml, xml, ...
10:46:29 <monochrom> The user choose which type to use for "a".
10:47:01 <Solonarv_> zeta_0: hie.yaml is a config file that is read by HIE
10:47:17 <[exa]> in HM, all type variables need to by introduced by explicit ∀, e.g. `id :: ∀a . a -> a` (haskell is removing the forall part by default)
10:47:40 <[exa]> sQVe: ^^, and it reads "for any type 'a', id can create 'a' out of 'a'"
10:48:35 <sQVe> Ah... okay. 
10:49:13 <sQVe> So what I have as a signature here https://github.com/sQVe/righttp/blob/develop/src/helpers.ts#L65 is somewhat correct then?
10:49:53 <[exa]> sQVe: in your case with a/b/c, you'd say that "for any types a,b,c, the function can create a container of type 'c' (for whatever choice of c) just out of containers with 'a' and 'b'"
10:51:18 <sQVe> I think I'm making the classic shortcut mistake instead of taking my time and diving deeper... 
10:52:18 <[exa]> sQVe: what do the {braces} mean in the type signature?
10:52:33 <sQVe> [exa]: That is is a "object".
10:52:57 <[exa]> oh so. So then it should work. Combines 2 containers of some type into a new one of the same type.
10:53:54 <zeta_0> Solonarv_: ok, thanks for explanation
10:57:25 <sQVe> [exa]: But how does that differ from say combineContainers :: {a} -> {b} -> {c}? Because a, b and c is allowed to have the same type in HM, correct?
10:58:20 <sQVe> Oh... but the function does not allow them to differ in types... and therefor {a} everyhere is prefer and more correct.
10:58:24 <sQVe> True?
10:58:46 <pablo[m]3> Guys, I've got a simple question. What is the significance of `!` in type declarations? Such as in `!Int`...
10:58:57 <pablo[m]3>  * Peeps, I've got a simple question. What is the significance of `!` in type declarations? Such as in `!Int`...
10:59:12 <merijn> pablo[m]3: Strictness
10:59:24 <geekosaur> it mens the value is strict (will be bevaluated while constructing the new value, instead of when that value is used)
10:59:44 <pablo[m]3> ohh, I see
10:59:48 <pablo[m]3> nice to know
10:59:51 <merijn> geekosaur: Evaluated when the constructed value is evaluated, not when constructed :p
11:19:53 * hackage tropical-geometry 0.0.0 - A Tropical Geometry package for Haskell  https://hackage.haskell.org/package/tropical-geometry-0.0.0 (ferynando7)
11:37:34 <zeta_0> i placed hie.yaml in the root of the workspace and when i ran: `hie-bios flags exe/Main.hs` it threw the error: `hie-bios: AesonException "Error in $: Expected a cradle: key containing the preferences"`
11:38:11 <cocreature> zeta_0: what is in your hie.yaml?
11:38:13 <zeta_0> i already placed the some code in hie.yaml so i don't know why this error is being thrown?
11:38:28 <zeta_0> cocreature: let me pastebin, one second
11:40:11 <zeta_0> cocreature: https://gist.github.com/zeta-00/e0dedee9199e4bfe84662f3563c3f726
11:42:26 <zeta_0> [nix-shell:/yesod-render-html]$ ls
11:42:26 <zeta_0> CHANGELOG.md  dist-newstyle  Main.hs   yesod-render-html.cabal
11:42:26 <zeta_0> default.nix   hie.yaml       Setup.hs  yesod-render-html.nix
11:42:36 <cocreature> zeta_0: which version of hie-bios are you using?
11:45:01 <zeta_0> cocreature: it throws the same error when i run: `hie-bios --version` in terminal, i installed it using nix, in a nix-shell, i guess i could also install it in my home packages(home.nix) to make sure that is not why it is not working
11:45:52 <zeta_0> cocreature: i am going to do a quick rebuild switch i'll be back to this channel in a bit
11:48:03 <cocreature> @tell zeta_0 judging from the error you are on an outdated version of hie-bios which has a different format for the hie.yaml file
11:48:03 <lambdabot> Consider it noted.
12:06:54 <zeta_0> cocreature: ok, i'm back, the nix's rebuild took a while
12:06:59 <zeta_0> [zeta@nixos:/test-nix]$ hie-bios --version
12:06:59 <zeta_0> "--version" not supported
12:06:59 <zeta_0> [zeta@nixos:/test-nix]$ hie-bios flags exe/Main.hs
12:06:59 <zeta_0> "flags" not supported
12:07:25 <zeta_0> [zeta@nixos:/test-nix]$ ls
12:07:25 <zeta_0> CHANGELOG.md  hie.yaml  Main.hs  Setup.hs  test-nix.cabal
12:07:42 <mpickering> The version of `hie-bios` you have on path is not related at all to the version `ghcide` uses
12:08:00 <mpickering> If you want to debug a ghcide problem then you run `ghcide` on the command line and it will give you some debugging info
12:10:38 <zeta_0> mpickering: so does ghcide come built-in with hie-bios, or does hie-bios need to be installed separately?
12:13:48 <zeta_0> mpickering: ok, it looks like the the syntax of the code in hie.yaml is off: https://gist.github.com/zeta-00/a4b6edff23711387c258b0044bd52e10
12:16:15 <quiet_laika[m]> can someone help me figure out my recursive megaparsec parser? seems like it should be straightforward but im messing up somewhere. https://gist.github.com/matthewess/55cde10d7df32aca2711e867a37fa9bf i cant successfully parse a recursive term in the first position, for some reason
12:16:31 <quiet_laika[m]> err, maybe better said as my megaparsec parser for a recursive datatype
12:18:31 <merijn> quiet_laika[m]: Not directly an answer, but related to your code: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/  :)
12:18:49 <merijn> quiet_laika[m]: Also, your probably want "chainl"
12:19:01 <zeta_0> mpickering: i just installed ghcide and read the documentation last night, so there are things that confuse me
12:27:55 <pavonia> quiet_laika[m]: How is symbol defined exactly?
12:34:31 <alx741_> hello all. What would be a good approach to turn a really complicated and intricate business logic (involving many data types and complicated operations upon that data) into something I can easily (purely) test? Right now I have operations as REST endpoints in IO that write to a DB, so untestable, global mutable state mess. Should I approach it as ADTs? build a DSL for the business logic (how)?,
12:34:33 <alx741_> free monads, something else?
12:34:52 <yushyin> has anyone ever tried ghcide in combination with cabal's mixins? I just tried it and ghcide seems to ignore the mixins. CC: cocreature
12:36:18 <cocreature> yushyin: I definitely haven’t tried it. does "cabal repl" work with them?
12:39:00 <zeta_0> could you guys help me setup a hie.yaml file, i am trying to set it up in a cabal project and all the code that i place in hie.yaml is throwing errors: https://github.com/mpickering/hie-bios
12:40:15 <cocreature> zeta_0: your previous hie.yaml looked fine it was just for a newer version of hie-bios than you seem to be using. ghcide 0.0.6 should use one that supports this
12:41:28 <cocreature> yushyin: if "cabal repl" works and your "hie.yaml" has a cabal cradle and ghcide doesn’t work then that’s a bug so feel free to open an issue (just don’t expect it to be fixed soon ;))
12:42:39 <merijn> cocreature: I think breaking that is trivial? Any cabal.project with more than 1 cabal file seems to break it? :p
12:43:06 <quiet_laika[m]> merijn ill take a peek at that 
12:43:07 <zeta_0> cocreature: i install ghcide using nix so i don't know why the version of hie-bios is incorrect? https://github.com/hercules-ci/ghcide-nix
12:43:22 <iqubic> Hello folks
12:43:41 <zeta_0> i already did a rebuilding switch as well so everything should be updated
12:44:13 <quiet_laika[m]> pavonia symbol is just `L.symbol (L.space space1 (skipLineComment "#") (skipNestedBlockComment "#{" "}#"))`
12:48:03 <zeta_0> ghcide version: 0.0.5, oh so the version of ghcide is off, i need to figure out how to upgrade it with nix
12:51:43 <cocreature> merijn: well if you set your cabal cradle correctly it should work. What doesn't work is working on multiple components at the same time
12:52:15 <merijn> cocreature: Components is confusing, do you mean "multiple cabal files", "multiple components in a single package", or "both"?
12:52:25 <cocreature> Both
12:53:01 <cocreature> Which is the same limitation that cabal repl puts on you
12:53:24 <merijn> cocreature: Except cabal repl makes it clear and unambigouos what to specify to control it ;)
12:53:47 <cocreature> Sure I'm not saying the ux for this is great
12:53:54 <merijn> cocreature: Anyway, I tried setting it to a single component before via hie.yaml, but got stuck on some TH stuff that's still broken, so carefully monitoring those tickets
12:54:12 <cocreature> Just stop using TH :P
12:54:29 <merijn> cocreature: Sure, I'll just quickly rewrite all 10k LOC to avoid it!
12:54:41 <merijn> How hard could that be?
12:54:44 <cocreature> Sounds like a solid plan!
12:59:01 <glguy> Start with -ddump-splices from a working version ;-)
13:03:11 <merijn> Is there a cheap method for converting a UTF-16 byte chunk into Text?
13:05:21 <c_wraith> What form is the byte chunk?
13:05:34 <c_wraith> because you've at least got https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Foreign.html#v:fromPtr
13:05:37 <merijn> c_wraith: Pointer I have in the FFI
13:05:50 <c_wraith> that's O(n) for safety, though
13:05:50 <merijn> Ah, that looks good :)
13:05:54 <merijn> aww
13:06:02 <merijn> At least the text isn't long
13:06:07 <merijn> Safety's overrated :p
13:17:38 <zeta_0> cocreature: ghcide works fine, but for some reason i am not able to import modules, i tried to setup hie-bios, but it kept throwing errors when i with the code i placed in hie.yaml, are there some other things that i can do to troubleshoot this issue?
13:21:12 <yushyin> cocreature: thanks for the hint with the cabal repl. I was using stack and indeed the mixins do not work in stack repl (and I found the open issue on github about that). I tried ghcide with cabal (with stack exec --no-ghc-package-path -- ghcide and a hie.yaml which uses cabal) and can confirm that this works! Also works in cabal repl. So not a bug with ghcide but with stack.
13:30:50 <zeta_0> yushyin: are you able to import modules with ghcide? i still can't figure out how to get that to work, hie.yaml keeps throwing errors, i am using cabal
13:36:55 <yushyin> zeta_0: 'be able to import module with ghicde' if you mean, if ghcide is able to check/run on files with 'import ModuleXYZ' lines, yes, worked ootb.
13:40:08 <zeta_0> yushyin: i just installed ghcide using the nix instructions, what steps do i need to do for ghcide to auto-complete/recognize imports?
13:42:04 <mpickering> zeta_0: You just said "ghcide" works fine
13:42:10 <mpickering> but then you claim it doesn't in the next sentence
13:42:26 <mpickering> Perhaps you are using a version of ghcide which uses an older version of hie-bios
13:42:30 <yushyin> I did nothing special. I installed ghcide with stack, run ghcide, opened a random file, autocompleted *all* the things.
13:42:43 <mpickering> or perhaps trying to use a multi-cradle anyway you have given no info which can actually help anyone solve the problem
13:46:53 * hackage hsinstall 2.6 - Install Haskell software  https://hackage.haskell.org/package/hsinstall-2.6 (DinoMorelli)
13:48:28 <zeta_0> mpickering: sorry i worded that incorrectly, ghcide seems to work fine except it is not able to auto-complete/recognize imports, https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
13:49:21 <zeta_0> mpickering: someone else recommended that i setup hie-bios but the code that i placed in the hie.yaml kept throwing errors
13:50:00 <zeta_0> mpickering: ghcide version: 0.0.5  , is it because this is the incorrect version?
13:50:58 <zeta_0> mpickering: i already ran: `nixos-rebuild switch --upgrade` so everything should be up to date, at this point, i have no idea what is wrong
13:56:33 <mpickering> zeta_0: What hie.yaml did you try?
13:56:48 <mpickering> It is not recognising your project is a cabal or stack project
14:07:33 <zeta_0> mpickering: here is the code i have in the hie.yaml file: https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
14:10:03 <mpickering> where is that hie.yaml file?
14:10:14 <mpickering> Is it `/home/zeta/test-nix/hie.yaml`?
14:12:01 <quiet_laika[m]> i refactored my parser to use `makeExprParser` which is supposed to supercede the `chain*` functions. still can't successfully parse a parenthesized arrow kind in the first position :/ https://gist.github.com/matthewess/55cde10d7df32aca2711e867a37fa9bf
14:14:06 <zeta_0> mpickering: ignore the 1st comment, and at the bottom is the cabal project that i am working on: https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
14:14:59 <zeta_0> mpickering: the code for hie.yaml is in the 2nd comment
14:15:27 <zeta_0> mpickering: sorry that i am little disorganized with my pastebin
14:15:47 <mpickering> right so did you read the error?
14:15:52 <mpickering> It's because your component name is wrong..
14:16:13 <mpickering> You need to write down the name of the component which actually works when you try "cabal repl lib:foo"
14:16:26 <mpickering> `"lib:hie-bios"` is not a component for your project
14:24:59 <pounce> can i statically link haskell programs so they can run wherever?
14:25:42 <solonarv> pounce: yes - and in fact that's what our build tools do by default, with a few exceptions that I don't know very well myself
14:25:43 <merijn> pounce: If you're slightly masochistic and willing to put some effort into it, yes
14:25:50 <merijn> solonarv: Not quite
14:25:59 <merijn> solonarv: You still depend on a dynamic libc/gmp
14:26:22 <pounce> oh, hm maybe that's o
14:26:25 <pounce> ok*
14:26:33 <merijn> pounce: Haskell libraries themselves are linked statically by default, but C libraries are not. It's possible to also link C libraries statically, but that's a bit more work
14:26:57 <pounce> i see
14:26:58 <merijn> (Unless you're on arch, because arch maintainers are either incompetent or malicious, tbh)
14:27:23 <solonarv> on arch the default is "broken dynamic linking" :(
14:28:09 <maerwald> merijn: theres static musl and static gmp 
14:28:18 <merijn> solonarv: The dynamic linking works, but GHC still defaults to static, but they don't install the static ones
14:28:26 <merijn> maerwald: Sure, hence why I said it's *possible*
14:28:42 <maerwald> https://github.com/utdemir/ghc-musl
14:28:47 <maerwald> use that
14:28:48 <merijn> maerwald: But linking with static musl and GMP is still a bunch of effort
14:29:00 <maerwald> not that much, unless you have system libs
14:29:04 <merijn> maerwald: Not undoable, but more than just linking Haskell statically
14:29:20 <zeta_0> mpickering: so how do i find the correct compent/name to be placed in hie.yaml, cabal repl has a bunch of completions?
14:29:45 <zeta_0> typo: component(not compent)
14:30:08 <solonarv> just look at your cabal file: each 'library foo' stanza defines a 'mypackage:lib:foo' component
14:30:28 <solonarv> 'executable bar' -> mypackage:exe:bar, and so on
14:31:17 <zeta_0> solonarv: do i need to look in the .cabal file of my project or in ~/.cabal/config ?
14:31:47 <solonarv> components are part of a package
14:32:02 <solonarv> ~/.cabal/config does not define a package, it's a bunch of global configuration
14:32:20 <solonarv> so, look at the mypackage.cabal file(s) in your project
14:32:33 <pounce> merijn: oh im on arch
14:32:38 <pounce> can i still compile statically?
14:32:53 <solonarv> yes, you can - it's only the system packages that are weird
14:32:55 <merijn> pounce: Yeah, just don't use any of the Arch packages
14:33:11 <pounce> hmm
14:33:11 <solonarv> @where ghcup
14:33:12 <lambdabot> https://www.haskell.org/ghcup/
14:33:27 <solonarv> I recommend ghcup (see above) for installing ghc + cabal
14:34:11 <zeta_0> solonarv: here is my .cabal file(scroll all the way to the bottom), i am not sure what it the component name that i need to place in the hie.yaml? https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
14:35:02 <solonarv> zeta_0: it looks like you have just one component, namely that executable
14:35:11 <solonarv> its full name is 'ghcide-test:exe:ghcide-test'
14:35:49 <solonarv> oh btw, instead of adding extra files in comments you can just add extra files to the gist :)
14:38:08 <bitmapper> so when is -XPleaseCompileThisGHCIveBeenStaringAtThisCodeForEightHours getting added
14:38:28 <solonarv> -fdefer-type-errors has existed for quite some time :P
14:38:39 <bitmapper> what if it's not a type error
14:38:53 <solonarv> well, then I don't know
14:38:53 <bitmapper> what if the code is wrong huh
14:38:56 <koz_> bitmapper: This channel has also existed for quite some time. :P
14:39:10 <pounce> how do i get a bytestring from a string
14:39:12 <solonarv> ah, but if the code is wrong and it's *not* a type error then surely it was already compiling?
14:39:29 <maerwald> bitmapper: man, you're running probably a few million SLOC of wrong c code right now. It's gonna be fiiine
14:39:34 <bitmapper> could be a syntax error
14:40:05 <merijn> solonarv, bitmapper: Don't use defer-type-errors, just add typed holes until it compiles!
14:40:42 <bitmapper> theres almost 100 source files i have to add semigroup and monadfail to here
14:40:45 <merijn> Then you just sprinkle typed-holes until it compiles and figure out what they should be later
14:40:59 <solonarv> bitmapper: ah, that sort of thing can be tedious indeed
14:41:02 <bitmapper> oh and Applicative
14:41:04 <MarcelineVQ>  merijn don't you need to deter-type-errors to do that
14:41:11 <bitmapper> love old code
14:41:12 <merijn> MarcelineVQ: No
14:41:18 <solonarv> whoa, Applicative as well? must be truly ancient code!
14:41:39 <MarcelineVQ> merijn: are you suuure
14:41:41 <bitmapper> ghc 7.6 is the suggested compiler
14:41:47 <merijn> MarcelineVQ: Typed holes "Just Work", if you wanna run it you'd have to add -fdefer-typed-holes, but that only hides holes, not other type errors
14:41:48 <solonarv> typed holes are compile errors, but there is a flag that defers them
14:42:08 <merijn> MarcelineVQ: Yes, because I wrote the patch for GHC that allows you to toggle typed holes off without turning -fdefer-type-errors on :p
14:42:21 <maerwald> pounce: what kind of byte string
14:42:25 <bitmapper> honestly on one hand i feel like these fixes are great, and on the other hand i feel like things are getting too complex
14:42:32 <merijn> s/toggle typed holes/toggle typed hole *errors*
14:42:53 <merijn> So typed holes are like undefined, but better :p
14:43:05 <merijn> Because it's trivial to check if you forgot any
14:43:15 <bitmapper> (in regards to AMP and monadfail in GHC)
14:44:17 <dmj`> but undefined doesn't yell at you like typed holes will :) 
14:44:31 <merijn> dmj`: You can silence those while developing
14:44:38 <MarcelineVQ> merijn: what do you mean by just work? compiling a program with holes fails with errors :X
14:44:54 <dmj`> merijn: -fdefer-typed-holes, never knew about this, nice
14:44:56 <merijn> MarcelineVQ: Compiling a program with holes and -fdefer-typed-holes works fine
14:44:59 <bitmapper> replace the program with a hole
14:45:12 <zeta_0> solonarv: looks like it worked but it threw another error: Could not load module ‘Distribution.Simple’ https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
14:45:13 <merijn> MarcelineVQ: It converts typed holes (and *only* typed holes) into a runtime error
14:45:21 <MarcelineVQ> okay so you do need a flag, just not the defer everything flag
14:45:42 <dmj`> merijn: so typed holes will act like undefined then ?
14:46:17 <dmj`> let _ = a
14:46:25 <merijn> dmj`: They turn into a warning (that behaves like undefined, i.e. bottom when you evaluate them)
14:46:35 <merijn> dmj`: There's also a flag for turning the warning off
14:46:44 <merijn> Because it annoys me too when developing ;)
14:47:02 <solonarv> zeta_0: okay, the module 'Distribution.Simple' is part of Cabal
14:47:07 <dmj`> seems like there's a flag for everything these days
14:47:08 <solonarv> which is a dependency of Setup.hs
14:47:32 <solonarv> I do not know how to make this available, it will probably involve poking nix in the right manner
14:47:45 <merijn> dmj`: -fdefer-typed-holes and -Wno-typed-holes (which silences the warning) have been around for ages :p
14:48:24 <merijn> dmj`: According to gitlab I added them in 7.10 5 years ago :p
14:49:37 <fenedor> zeta_0, I think ghcide does not support loading Setup.hs files. But any other file should work
14:50:50 <pounce> maerwald: lazy bytestring?
14:51:01 <maerwald> pounce: what encoding? String has none
14:51:53 <maerwald> check out https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-Lazy-UTF8.html
14:57:26 <zeta_0> mpickering: should i report this as an issue(scroll all the way to the bottom): https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
14:57:43 <pounce> i just want to convert between [Char] to bytestream 
14:57:47 <pounce> with word8 characters
15:00:13 <iqubic> pounce: Import Data.ByteString.Char8 and then use pack and unpack.
15:00:39 <maerwald> if you don't control the input, that might give incorrect results
15:00:47 <iqubic> Yeah.
15:05:25 <fenedor> zeta_0, in the last message, it just shows that can not load Setup.hs which, afaik, is normal and not a problem
15:05:48 <merijn> Never use Char8 >.<
15:06:12 <merijn> If you have ascii data and want a ByteString just save yourself the drame and use encodeUtf8
15:07:53 <maerwald> or give up and use Text. It's efficient enough for most things
15:08:30 <pounce> the library im using uses bytestring
15:08:47 <maerwald> do you control the input?
15:09:03 <pounce> yee
15:37:30 <zeta_0> fenedor: i put yesod as package dependency in in my .cabal file of the project and ghcide threw this error? ghcide: <command line>: cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
15:37:58 <fenedor> zeta_0, but stack build and cabal build succeeds?
15:38:00 <fenedor> *or
15:41:11 <zeta_0> fenedor: yes cabal build works, here is my .cabal file(scroll all the way to the bottom): https://gist.github.com/zeta-00/d4580ff9ef786adff863c56816344d83
15:42:19 <fenedor> zeta_0, and what was your "hie.yaml"?
15:42:54 <fenedor> did you change it like it was suggested?
15:47:01 <fenedor> zeta_0, I suggest a hie.yaml with `cradle: { cabal: { component: "exe:ghcide-test"} }`
16:00:32 <zeta_0> ghcide: <command line>: cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
16:03:04 <zeta_0> i am not sure how to fix this? https://gist.github.com/zeta-00/43e78f2434f7242f032c073bd814bcac
16:04:35 <zeta_0> mpickering: it seems like i got ghcide working now, but when i try to add yesod as a dependency in the .cabal file of my project it throws this error? https://gist.github.com/zeta-00/43e78f2434f7242f032c073bd814bcac
16:56:04 <zeta_0> ghcide: <command line>: cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
16:56:22 <zeta_0> build-depends:       base >=4.12 && <4.13, yesod
16:57:38 <zeta_0> i added yesod as a build dependency in the .cabal file of my project and when i run ghcide it throws that error, what is wrong and how do i fix it?
17:20:11 <alc> about that Data.List.GroupBy.groupBy, it can be compose through those functions in Data.List?
17:21:56 <ChaiTRex> alc: Look at the types. If the output of one function has the same type as the input of another, you can compose them.
17:22:43 <alc> ChaiTRex: sorry, I mean implemented
17:25:16 <ChaiTRex> alc: Yes, you can write groupBy with the functions in Data.List.
17:25:45 <alc> [0,1,2,3,5] -> [[0,1],[1,2],[2,3],[3,5]] -> [(True,[0,1]),(True,[1,2]),(True,[2,3]),(False,[3,5])] -> [[0,1,2,3],[5]]
17:26:57 <ChaiTRex> alc: Right, that's doable with iterate, takeWhile, dropWhile, zip, and tail.
17:27:12 <ChaiTRex> alc: I'm sure there are other implementatitons as well.
17:44:40 <alc> ChaiTRex: do you know how to let [0,1,2,3,5] to [[0,1],[1,2],[2,3],[3,5]]?
17:44:55 <alc> and the reverse
17:45:23 <ChaiTRex> alc: Sure: zip xs (tail xs)
17:45:45 <ChaiTRex> alc: And concat, then take the even indexes.
17:46:05 <ChaiTRex> alc: Hmm, maybe not since that skips the last element.
17:46:23 <ChaiTRex> alc: The first element of the first list plus the last element of all the lists.
17:46:23 * hackage threaded 0.0.0 - Manage concurrently operating threads without having to spark them  https://hackage.haskell.org/package/threaded-0.0.0 (athanclark)
17:46:25 <kaychaks> I want to use promoted types in a type synonym. I've these 2 ADTs - `data T i t a b = T t (i -> Either a b)` and `data O a = A a | B a`. This works - `type T'' = T Double String (O Double) (O Double)`. This is failing - `type T'' = T Double String ('A Double) ('B Double)` 
17:47:11 <kaychaks> I understand the error that when its expected a type, promoted types have kind. 
17:47:37 <alc> ChaiTRex: zip xs (tail xs) is wonderful
17:47:47 <ChaiTRex> alc: Yes, it's very handy at times.
17:48:46 <alc> ChaiTRex: what about [0,1,2,3,5,7] to [(0,1,2),(1,2,3),(2,3,5),(3,5,7)]?
17:49:07 <alc> zip2 or zip3?
17:49:10 <zeta_0> hello guys, could you help me figure out an issue that i am having with cabal?
17:49:12 <kaychaks> how should I restructure my ADTs to make use promoted types in type synonyms or in places where the actual type would have been used
17:49:19 <ChaiTRex> alc: Probably zip3 xs (drop 1 xs) (drop 2 xs)
17:49:28 <alc> ChaiTRex: ok
17:49:33 <ChaiTRex> alc: It's zip3 since you have 3-tuples.
17:50:13 <ChaiTRex> > let xs = [0, 1, 2, 3, 5, 7] in zip3 xs (drop 1 xs) (drop 2 xs)
17:50:15 <lambdabot>  [(0,1,2),(1,2,3),(2,3,5),(3,5,7)]
17:51:51 <zeta_0> i placed yesod in the build-dependencies of my .cabal file but when i try to import Yesod, ghcide tells me that it does not recognize the module Yesod?
17:55:19 <alc> ChaiTRex: f l1 l2 = [(x,y) | x <- l1, y <- l2];  f [1,2,3] [4,5] == liftA2 (,) [1,2,3] [4,5]; but I want the zip's definition with list comprehension
17:55:55 <alc> how to change it
17:56:09 <alc> zip = [(x,y) | ?]
17:57:56 <ChaiTRex> alc: zip xs ys = [(xs !! i, ys !! i), i <- [0 .. min (length xs) (length ys)]]
17:58:04 <ChaiTRex> alc: It's not the best way of implementing it.
17:58:14 <ChaiTRex> alc: Better to do it without a list comprehension.
17:58:49 <alc> ChaiTRex: oh, I thought that there's a simple list comprehension for zip...
18:00:34 <Axman6> There is an extension for list comprehensions which lets you do it, but they're not really the right tool for the job when zip* exist already
18:01:00 <alc> ok
18:01:13 <zeta_0> ghcide: <command line>: cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
18:01:16 <zeta_0> ?
18:01:23 <ChaiTRex> alc: No, normal list comprehensions (don't know about extensions like Axman6 mentioned) will give you a Cartesian product of lists by default rather than a zip.
18:01:51 <zeta_0> ghcide does not want to recognize yesod
18:16:18 <zeta_0> what does this mean in haskell? cannot satisfy -package-id
18:19:04 <ChaiTRex> zeta_0: That's more a Cabal thing, I think. Not sure exactly, but perhaps it means that the package can't be used with other packages or package versions you chose.
18:20:52 <ChaiTRex> zeta_0: There's a #yesod you might also ask on.
18:26:48 <zeta_0> ChaiTRex: ok, thanks for the explanation, i'll go checkout the #yesod channel to see if anyone is on
18:41:06 <zeta_0> ok, i asked the question on #yesod, there is not that many people on the channel, so who knows if anyone will respond
18:41:55 <ChaiTRex> zeta_0: Yeah, it'll probably be a while.
18:54:40 <alc> ChaiTRex: Axman6 why zip would use tuple but not list?
18:54:53 <alc> > zip [0,1] [2,3]
18:54:56 <lambdabot>  [(0,2),(1,3)]
18:55:10 <alc> why it wouldn't be [[0,2],[1,3]]?
18:55:39 <koz_> :t zip
18:55:41 <lambdabot> [a] -> [b] -> [(a, b)]
18:56:01 <koz_> This means that you get back tuples in your list. This isn't Lisp.
18:56:10 <koz_> (that is, lists aren't stuffed in every possible hole)
18:56:13 <alc> why it shouldn't by [a] -> [b] -> [[a,b]]
18:56:23 <koz_> Because Haskell isn't Lisp.
18:56:35 <koz_> (assuming [a, b] even made sense)
18:57:18 <alc> but can we use that a bunch of functions of Data.List on tuple?
18:57:38 <alc> like foldl, <>, ...
18:57:45 <koz_> No, because Haskell isn't Python.
18:57:48 <koz_> (or Lisp)
18:58:00 <koz_> Tuples are a separate entity to lists, and mashing them together isn't helpful.
18:58:38 <koz_> Tuples have (statically) known length, and can have various types in each position. Lists have (statically) unknown (or possibly infinite, in Haskell) length, and must have the _same_ type of thing in each position.
18:58:56 <koz_> Those are fundamentally not the same thing, behave differently, and mashing them together creates nothing but confusion.
19:00:11 <alc> but normally we handle lots of lists, and when we use that zip, we have to convert tuple to list, that's more step
19:00:22 <iqubic> tuples and lists are as different as night and day.
19:00:42 <koz_> alc: What do you mean by 'normally'?
19:00:55 <iqubic> alc: You don't have to convert that tuple to a list. You could just work with it as a tuple.
19:01:06 <koz_> If you're having to do a tuple-to-list conversion, something has gone wildly wrong in your design, chances are.
19:01:11 <alc> iqubic: but tuple can't have that <>
19:01:17 <koz_> How do you convert (4, "foo") into a list?
19:01:26 <iqubic> alc: No. You are right.
19:01:35 <alc> f (x,y) = [x,y]
19:01:49 <iqubic> @let f (x,y) = [x,y]
19:01:51 <lambdabot>  Defined.
19:01:55 <koz_> alc: That doesn't make sense unless the type of x and y match.
19:02:02 <iqubic> > f (4, "foo")
19:02:04 <lambdabot>  error:
19:02:04 <lambdabot>      Ambiguous occurrence ‘f’
19:02:04 <koz_> Which in my case, they don't, unless this is JavaScript.
19:02:04 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
19:02:12 <iqubic> @undefine
19:02:12 <lambdabot> Undefined.
19:02:29 <iqubic> @let mkList (x,y) = [x,y]
19:02:31 <lambdabot>  Defined.
19:02:38 <alc> :t (4,"foo")
19:02:40 <lambdabot> Num a => (a, [Char])
19:02:44 <iqubic> mkList (4,"foo")
19:02:50 <iqubic> > mkList (4,"foo")
19:02:53 <lambdabot>  error:
19:02:53 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘4’
19:02:53 <lambdabot>      • In the expression: 4
19:03:02 <iqubic> Yeah. That just doesn't work.
19:03:17 <alc> > mkList (4,3)
19:03:20 <lambdabot>  [4,3]
19:03:29 <alc> > mkList ("4","foo")
19:03:31 <lambdabot>  ["4","foo"]
19:03:31 <koz_> alc: That works only because 4 and 3 happen to share a type.
19:03:37 <koz_> Same with that.
19:03:44 <koz_> But tuples don't _have_ to behave that way.
19:03:53 <koz_> (Int, String) is a perfectly fine tuple type.
19:03:58 <alc> but you're missing another point, list has the same type! so after zip, it has the same type!!!
19:04:05 <rotaerk> alc, zip produces a list of tuples because tuples have a fixed length, while lists have arbitrary length... and zip must produce *pairs* of values... exactly two
19:04:06 <koz_> alc: Read the type agian.
19:04:07 <koz_> :t zip
19:04:09 <lambdabot> [a] -> [b] -> [(a, b)]
19:04:17 <koz_> Nobody in any universe said that a ~ b must hold.
19:04:26 <alc> fine
19:04:28 <iqubic> If you are using a tuple as a container for 2 elements with the same type, and wanting to do list operations on it, then you are using tuples incorrectly.
19:04:34 <koz_> If it holds _in your particular case_, my argument stands: you're not solving the problem in the best way.
19:04:38 <rotaerk> yeah that too... difference in types is possible
19:04:59 <alc> @let l5 = [(True,(0,1)),(True,(1,2)),(True,(2,3)),(False,(3,5)),(False,(5,7))]
19:04:59 <iqubic> > zip [1,2,3,4,5] ['h','e','l','l','o']
19:05:00 <lambdabot>  Defined.
19:05:01 <lambdabot>  [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
19:05:16 <koz_> > zip [1 ..] ["Oops"]
19:05:18 <lambdabot>  [(1,"Oops")]
19:05:22 <alc> how I can get [[0,1,2,3],[5,7]] throught l5?
19:05:40 <iqubic> That's not the question you should be asking.
19:06:39 <iqubic> alc: You wrote earlier: "[0,1,2,3,5] -> [[0,1],[1,2],[2,3],[3,5]] -> [(True,[0,1]),(True,[1,2]),(True,[2,3]),(False,[3,5])] -> [[0,1,2,3],[5]]"
19:06:54 <iqubic> Why do you think that you need to add additional steps here?
19:07:27 <alc> then I don't know how to do it, Data.List.groupBy don't do what I expect
19:07:48 <koz_> :t groupBy
19:07:49 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
19:07:54 <alc> and Data.List.GroupBy , I can't find the pacakge on archlinux
19:07:58 <alc> groupBy
19:08:04 <rotaerk> :t partition
19:08:04 <koz_> alc: I'm not sure groupBy is what you want here.
19:08:05 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:08:14 <koz_> I think rotaerk beat me to the thing you want.
19:08:36 <rotaerk> I'm not sure if it's what they want or not, though it gives the result in that specific case
19:08:41 <koz_> Also, Data.List.GroupBy isn't a package name on Arch. And you don't wanna be using Arch's Haskell packages, since they are super-baroke.
19:09:08 <rotaerk> broke? baroque?
19:09:17 <koz_> rotaerk: Pick whichever you prefer. :P
19:09:26 <rotaerk> heh
19:09:28 <koz_> Also, takeWhile might be an option here.
19:09:31 <koz_> :t takeWhile
19:09:32 <lambdabot> (a -> Bool) -> [a] -> [a]
19:09:43 <koz_> Wait, no.
19:09:45 <koz_> Argh.
19:09:46 <ChaiTRex> alc: Because the types then tell us exactly how many elements, which can be useful.
19:09:57 <alc> this is the question https://www.codewars.com/kata/51ba717bb08c1cd60f00002f
19:10:42 <alc> my anwser https://www.codewars.com/kata/reviews/58ea65914a9cca2100000ccd/groups/5e1b3c58691e67000106e62e
19:11:50 <iqubic> alc: Only you can see that page. You'll have to post that code on a different site.
19:11:51 <alc> [0,1,2,3,5,7] need to be [[0,1,2,3],[5],[7]]
19:11:57 <iqubic> @where paste
19:11:57 <lambdabot> https://gist.github.com
19:12:04 <iqubic> Something like that.
19:12:11 <iqubic> Or you can use pastebin.
19:12:30 <rotaerk> alc, why does it need to be? why does 5 get putt into a separate list? because it skipped 4?
19:12:42 <alc> https://paste.ubuntu.com/p/HrVS9x4Xsv/
19:13:42 <iqubic> rotaerk: Yes. He's trying to split the list into sublists where each list contains only consecutive numbers.
19:14:05 <rotaerk> ok
19:14:31 <alc> rotaerk: 0 - 1 = -1,  1 - 2 = -1, 3 - 5 = -2
19:14:36 <iqubic> And in this case the input is guarunteed to be in ascending order already.
19:14:54 <rotaerk> :t split
19:14:56 <lambdabot> Splitter a -> [a] -> [[a]]
19:15:07 <rotaerk> hmm not the one I was looking for
19:15:20 <rotaerk> https://hoogle.haskell.org/?hoogle=%28a+-%3E+Bool%29+-%3E+%5Ba%5D+-%3E+%5B%5Ba%5D%5D&scope=set%3Astackage
19:24:45 <alc> I'm trying to replace the groupBy' function there
19:24:59 <alc> now I have [(True,(0,1)),(True,(1,2)),(True,(2,3)),(False,(3,5)),(False,(5,7))]
19:25:22 <alc> so I'd like to convert it to [[0,1,2,3],[5],[7]]
19:37:01 <alc> > filter fst l5
19:37:04 <lambdabot>  [(True,(0,1)),(True,(1,2)),(True,(2,3))]
19:37:11 <alc> > filter (not . fst) l5
19:37:13 <lambdabot>  [(False,(3,5)),(False,(5,7))]
19:38:45 <pounce> does anybody know how to do literate haskell with vim?
19:44:57 <pounce> or in general im confused ;_;
19:45:53 * hackage avro-piper 1.0.3 - Tool for decoding avro  https://hackage.haskell.org/package/avro-piper-1.0.3 (haskellworks)
19:48:23 * hackage dhall-lsp-server 1.0.4 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.4 (GabrielGonzalez)
19:50:23 * hackage dhall-json 1.6.1 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.6.1 (GabrielGonzalez)
19:51:24 * hackage dhall-bash 1.0.27, dhall-yaml 1.0.1 (GabrielGonzalez): https://qbin.io/pst-saddam-4j6r
19:54:56 <electricityZZZZ> you guys should probably switch over to this better runtime https://github.com/lechimp-p/php-stg
19:56:23 * hackage dhall-nix 1.1.11 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.11 (GabrielGonzalez)
19:57:23 * hackage dhall 1.29.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.29.0 (GabrielGonzalez)
20:07:04 <zeta_0> i placed yesod in build-depends, but for some reason ghcide is not recognizing import Yesod module, and ghcide also throws this error? ghcide: <command line>: cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
20:08:36 <glguy> zeta_0: Do you also have a package.yaml file?
20:12:47 <pounce> say i have [[a]] and i want to work with it as a monad
20:12:56 <pounce> is it considered m [a] or [m a]
20:13:12 <glguy> [[a]] is : [] ([] a)
20:13:18 <glguy> so: m [a]
20:13:25 <heatsink> also [m a]
20:13:25 <pounce> nevermind im dumb, didn't do `pure`
20:13:38 <heatsink> either [] can be m
20:14:20 <pounce> also im in contexts where i want to work with both but i dont know how to do that in a pretty way (either nested arr notation or nested do notation)
20:14:33 <pounce> did it with an fmap but that's just as ugly
20:15:18 <heatsink> It depends what you want to do.  sequence is useful for monadic values in a container
20:15:45 <heatsink> > sequence [return 2, return 3, return 4] :: Maybe [Int]
20:15:48 <lambdabot>  Just [2,3,4]
20:15:48 <zeta_0> glguy: no i don't have a package.yaml file but i do have a hie.yaml file(for ghcide)?
20:16:28 <pounce> im working with boolean problems in disjunctive notation (so [[variable]] kinda where the outer list is an `and` of the inner list of ors of variables)
20:16:42 <pounce> and im trying to translate my shorthand of lots of indexed ands and ors into haskell
20:17:06 <pounce> btw can you guard in a `do` block like the guards in arrays?
20:17:21 <heatsink> You can call 'guard'
20:17:40 <heatsink> It does the same thing as a guard in list comprehension
20:19:26 <pounce> ok found it
20:19:28 <pounce> tyy
20:19:36 <iqubic> I feel a bit wrong import GHC.Integer.GMP.Internals and using powModInteger
20:21:03 <koz_> iqubic: What are you trying to do?
20:21:41 <iqubic> a^n mod m where a, n, and m are all large integers.
20:22:25 <Clint> would you feel less wrong using powModSecInteger
20:22:29 <iqubic> these integers are on the order of 10^7
20:22:32 <iqubic> Clint: No.
20:22:55 <zeta_0> glguy: my hie.yaml file and the error: https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
20:23:07 <iqubic> I feel wrong using an import that says: Internal.
20:23:14 <iqubic> But it's fine.
20:23:20 <Clint> i'd feel the same
20:23:30 <iqubic> This is just Advent of Code stuff, not real world production code.
20:23:43 <zeta_0> do i need a package.yaml file as well in order for the module Yesod to be detected by ghcide?
20:25:25 <nshepperd2> i think the appropriate emotion for importing Internal modules is "mad with power"
20:26:08 <iqubic> Yes.
20:26:30 <iqubic> nshepperd2: If you must know, this was used for Advent of Code 2015, Day 25.
20:26:41 <Ailrun[m]> zeta_0: Do you have .cabal file?
20:34:42 <zeta_0> Ailrun[m]: scroll to the bottom to see the code of the .cabal file: https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
20:35:20 <zeta_0> build-depends: base >=4.12 && <4.13, yesod
20:35:42 <iqubic> So, powModInteger works really well.
20:36:11 <Ailrun[m]> It looks fine, did you install your deps, i.e., yesod?
20:36:56 <Ailrun[m]> I mean, did you actually install them?
20:38:49 <zeta_0> Ailrun[m]: yes i installed them, here is installation/configuration in my home.nix file: https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
20:54:26 <pounce> so i want a `Show a => [[a]] -> String` where i space separate the inner list and newline separate the outer lists
20:54:49 <pounce> would that be `unlines . fmap unwords . fmap fmap show`?? seems unwieldy
20:56:24 <ChaiTRex> :t interpolate
20:56:25 <lambdabot> error:
20:56:25 <lambdabot>     • Variable not in scope: interpolate
20:56:25 <lambdabot>     • Perhaps you meant one of these:
20:56:34 <ChaiTRex> :t intercalate
20:56:36 <amalloy> you can collapse two of those maps, anyway
20:56:36 <lambdabot> [a] -> [[a]] -> [a]
20:56:45 <amalloy> :t unlines . map (unwords . map show)
20:56:47 <lambdabot> Show a => [[a]] -> String
20:57:42 <pounce> oh that's better thank you
20:58:33 <ChaiTRex> :t intercalate "\n" . map (intercalate " " . map show)
20:58:34 <lambdabot> Show a => [[a]] -> [Char]
21:00:38 <pounce> ooh oki
21:05:13 <amalloy> yeah, unwords and unlines are specializations of intercalate. i'd rather use the specialized versions, since they exist
21:06:19 <electricityZZZZ> why is it called "graph reduction"... these expressions look like trees?
21:07:44 <ChaiTRex> electricityZZZZ: trees are a kind of graph
21:07:48 <iqubic> electricityZZZZ: In Computer Science a tree is just another name for a directed acyclic graph.
21:08:00 <Ailrun[m]> electricityZZZZ: if there are any kinds of sharing, it is not a tree.
21:08:04 <electricityZZZZ> well, yeah, but,... so it's tree reduction then?
21:08:19 <electricityZZZZ> or, tree-plus-a-little-extra reduction
21:08:30 <electricityZZZZ> i mean actual graphs are quite complicated beasts
21:08:38 <iqubic> tree-plus-a-little-extra is a graph.
21:08:40 <Ailrun[m]> for ex) let a = 1+1 in a + a
21:09:18 <Ailrun[m]> it will not evaluate a twice.
21:09:25 <iqubic> Nope.
21:10:32 <Ailrun[m]> so, it's usually not a tree
21:32:41 <hololeap> hexagoxel: did you ever figure out what is needed to keep brick-reflex from needing a forked brick?
21:34:18 <hololeap> i'm interested in using reflex for various projects and so far the only other non-DOM example i've found is reflex-gloss
21:35:34 <iqubic> hololeap: reflex-gloss exists? hy???
21:35:37 <iqubic> Why??
21:36:15 <hololeap> why not?
21:36:32 <hololeap> it was originally for frp-zoo
21:36:57 <jackdk> hololeap: there's also reflex-basic-host and reflex-vty
21:38:48 <hololeap> jackdk: those look cool! i don't know how i missed them
22:26:05 <hololeap> anyone know if weaving between IO and a MonadIO like this has any drawbacks?
22:26:08 <hololeap> https://hackage.haskell.org/package/reflex-gloss-0.2/docs/src/Reflex-Gloss.html
22:31:00 <jle`> hololeap: what do you mean by weavking?
22:31:02 <jle`> *weaving
22:31:12 <hololeap> playReflex ... = runSpiderHost $ ... liftIO $ playIO ... (\_ -> runSpiderHost ...)
22:31:59 <hololeap> runSpiderHost :: SpiderHost a -> IO a
22:32:07 <jle`> that's basically how things like the monad instance for StateT works 
22:32:17 <hololeap> it's a MonadIO
22:32:37 <jle`> but there isn't really much you can say about 'a MonadIO', they are all very different
22:32:46 <jle`> they pretty much have no semantics in common other than being able to write liftIO
22:33:11 <hololeap> so there's no rules
22:33:12 <jle`> so it depends on SpiderHost or w/e the instance is
22:33:18 <jle`> there are rules for SpiderHost
22:33:28 <jle`> but MonadIO in general, it's basically just nothing more than the type signature of liftIO
22:33:34 <iqubic> What other MonadIO instances are there besides IO?
22:33:37 <jle`> and some rules about monad homomorphism and stuff
22:33:52 <iqubic> :t liftIO
22:33:53 <lambdabot> MonadIO m => IO a -> m a
22:33:58 <jle`> data StringIO a = StringIO { runStringIO :: String -> IO a }
22:33:58 <hololeap> liftIO . toIO . liftIO == toIO . liftIO . toIO
22:34:11 <jle`> hololeap: runSpiderHost is not a 'toIO'
22:34:23 <hololeap> sorry, fromIO
22:34:36 <jle`> where is fromIO here?
22:34:41 <jle`> liftIO is arguably the closest thing to fromIO
22:35:14 <jle`> my point basically is that the semantics of SpiderHost are likely to be well defined, so what drawbacks or anything would come from the semantics of SpiderHost, not from the fact that it is a MonadIO
22:35:39 <hololeap> fair enough
22:35:45 <jle`> it's sort of like asking if weaving back and forth into a Monad has any drawbacks
22:35:55 <jle`> you can only say if a given Maybe usage has drawbacks
22:35:59 <jle`> or a given tuple usage has drawbacks
22:36:25 <jle`> iqubic: if you've used Conduit, the ConduitT i o m is a MonadIO if m is
22:37:12 <jle`> hololeap: using Maybe, it just depends on how Maybe works
22:37:14 <jle`> not how monads work
22:37:20 <jle`> or using Either, or tuple
22:37:30 <jle`> so it's like asking if f (x, y) = x + y is a good usage of monads
22:38:12 <jle`> hololeap: to understand that code and whether or not it has any drawbacks, you just need to understand what the semantics of runSpiderHost are
22:38:28 <jle`> not the semantics of MonadIO
22:39:59 <hololeap> the relationship between liftIO and runConduit is another example
22:40:25 <hololeap> assuming it's a ConduitT i o IO a
22:42:10 <hololeap> so there is no rule to be expected here due to it being a MonadIO
22:44:08 <iqubic> It's actually "instance MonadIO m => MonadIO (ConduitT i o m a) where" I should think. Note, I haven't looked at the docs to verify this.
22:45:04 <iqubic> I was close.
22:45:07 <hololeap> liftIO :: IO a -> ConduitT () Void IO a ; runConduit :: ConduitT () Void IO a -> IO a
22:45:24 <iqubic> It's actually "instance MonadIO m => MonadIO (ConduitT i o m)"
22:45:39 <iqubic> My previous attempt at getting that right didn't kind check at all.
22:45:59 <jle`> right, MonadIO instances are monads
22:46:31 <jle`> like MonadPlus and MonadFail
22:46:39 <jle`> and MonadState s, MonadReader r, etc.
22:46:46 <hololeap> it forms what looks like a natural isomorphism, but should i expect the laws to hold?
22:47:34 <jle`> do you mean, are liftIO and runConduit inverses of each other?
22:47:52 <hololeap> right. i've seen this with a few libraries... liftIO and runBlah
22:48:08 <hololeap> i'm wondering if it's safe to expect that they would act as inverses
22:48:09 <jle`> in the case of most MonadIO instances, liftIO is not a part of an isomorphism
22:48:11 <iqubic> I just realized that `ConduitT () Void m r` is interesting categorically. In Hask () is the inital object and Void is the terminal object. So what you are saying is that there is literally no input aawaited and literally no output yeiled from that Conduit.
22:48:13 <jle`> it's an embedding
22:48:43 <jle`> so it means that ConduitT i o IO is 'bigger' an IO
22:49:10 <jle`> and liftIO directs an IO into some subset of all ConduitT i o IO
22:49:34 <hololeap> gotcha
22:49:43 <jle`> it's sort of like how Integer is smaller than Double
22:49:56 <jle`> and you have fromInteger :: Integer -> Double, to embed an Integer into Double
22:50:37 <hololeap> because ConduitT holds logic that determines what the IO will be?
22:51:04 <hololeap> is that what makes it "larger"?
22:51:04 <jle`> `ConduitT i o` is a monad transformer
22:51:12 <jle`> it takes a monad and adds extra 'effects' to it
22:51:15 <jle`> extra semantics
22:51:24 <jle`> like how 'MaybeT' takes a monad and adds short circuiting failure semantics
22:51:52 <hololeap> true, but it ends up back as just an IO at some point. what makes it "bigger" than IO?
22:52:40 <jle`> you can say that MaybeT has a few primitive operations in its API
22:52:48 <jle`> it has pure :: a -> MaybeT m a
22:52:51 <jle`> empty :: MaybeT m a
22:52:57 <jle`> liftIO :: IO a -> MaybeT m a
22:53:11 <jle`> so it sort of adds 'empty' as an extra structure you can use
22:53:36 <jle`> it adds extra explicit failure-or-not structure
22:53:45 <jle`> er, implicit, maybe
22:54:12 <jle`> thinking of MaybeT here as an abstract data type
22:55:42 <hololeap> there's a sum type coming out of runMaybeT, so it makes it less straightforward
22:56:25 <hololeap> there's no simple way to do MaybeT IO a -> IO a
22:56:26 <jle`> i'm only talking about the semantics of the type
22:56:41 <jle`> hololeap: right, that's what makes an embedding 
22:56:46 <jle`> just like there is no Double -> Integer
22:56:57 <dminuoso_> By simple do you mean invertible?
22:57:31 <jle`> you can't have `forall m. MaybeT m a -> m a`, because there might be some value in your MaybeT m a that is 'outside' of m a
22:57:32 <hololeap> if it's Nothing inside the IO, there's no way to get to IO a
22:57:41 <jle`> just like how you can't go from Double to Integer without sacrificing or losing information
22:58:04 <hololeap> but there is no problem like this for (runConduit :: Conduit i o IO a -> IO a)
22:58:18 <jle`> that type is in general not possible
22:58:18 <hololeap> what information gets lost?
22:58:40 <jle`> only Monad m => ConduitT () Void m a -> m a is possible
22:58:49 <dminuoso_> hololeap: Consider the floor function. If the result is 6, what was its input?
22:59:01 <jle`> and in that case `ConduitT () Void m` is actually literally isomorphic to `m`
22:59:30 <jle`> so liftIO :: IO a -> ConduitT String Double IO a, that is a better analogy to MaybeT IO
22:59:31 <hololeap> ah, true...
23:01:08 <jle`> `ConduitT i o m a` adds `yield :: o -> ConduitT i o m ()` and `await :: ConduitT i o m (Maybe i)` to the structure of m
23:01:19 <jle`> just like how MaybeT  adds 'empty :: MaybeT m a'
23:01:28 <jle`> and how ReaderT adds ask :: ReaderT r m r
23:01:47 <jle`> so a ConduitT i o m a, it has 'm' actions, and more
23:03:20 <hololeap> so, the only time a natural isomorphism forms with liftIO as one half is Identity (or things isomorphic to Identity)
23:03:26 <jle`> so it's bigger than m, in that it has more structure and possible 'values' than just normal m actions
23:03:46 <hololeap> or IO...
23:03:53 <jle`> well, one half is isomorphic to IO, yeah
23:04:06 <jle`> liftIO is only an isomorphism if the MonadIO instance is isomorphic to IO
23:04:18 <jle`> just like how fromInteger is only an isomorphism if the Num instance is isomorphic to Integer
23:04:23 <jle`> but this is sort of a tautology
23:04:51 <jle`> liftIO is only an isomorphism ... if it's an isomorphism
23:05:13 <jle`> or well, liftIO only forms one half of an isomorphism if it forms one half of an isomorphism
23:05:15 <hololeap> (ConduitT () Void m) is isomorphic to m?
23:05:21 <jle`> that's really all you can say
23:05:23 <jle`> yeah, it is
23:05:32 <hololeap> that makes sense
23:05:53 <jle`> well from an external perspective it is
23:06:03 <jle`> internally you can inspect some extra structure i believe potentially
23:06:19 <jle`> but the abstract data type of COnduitT () Void m, is isomorphic to m, yeah
23:06:38 <jle`> it's called an 'Effect', in pipe lingo
23:07:07 <jle`> if i is () it's a source, if o is Void it's a sink, if it's both a source and a sink it's an effect
23:07:39 <hololeap> and open is a pipe?
23:08:44 <jle`> in the general case it can just be called a Conduit
23:08:52 <jle`> or a Pipe or whatever data type
23:09:07 <jle`> if it's specifically open on both ends then i've seen it called a transformer maybe
23:09:55 <jle`> but it gets muddy because you can technically use a source as a transformer/pipe and stuff. just all the typical shenanigans that come from subtyping
23:11:06 <hololeap> what is subtyping?
23:11:45 <jle`> it's an "is-a" relationship
23:11:54 <jle`> an effect is a source and an effect is a sink
23:12:30 <jle`> triangles are polygons, and so are rectangles
23:14:32 <hololeap> i'm not sure i follow how this relates to what you said earlier
23:14:52 <hololeap> "you can technically use a source as a transformer/pipe"
23:15:13 <hololeap> this doesn't make sense to me
23:15:13 <jle`> yeah, since nothing is stopping you from something like C.map (const ()) .| mySource
23:15:51 <jle`> where source is now used as if it were just a normal transformer or pipe that takes () as input
23:16:16 <jle`> so you can treat a `ConduitT () Int m` as both "a source of Int" and also "a transformer of () into Int"
23:16:57 <hololeap> oh, because it can yield ()'s? 
23:17:04 <jle`> it can await for ()'s
23:17:26 <hololeap> right
23:17:30 <jle`> intuitively you wouldn't really use a conduit that way
23:17:44 <jle`> er, semantically, i mean
23:17:48 <jle`> but the type system doesn't stop you
23:17:53 * hackage doclayout 0.3 - A prettyprinting library for laying out text documents.  https://hackage.haskell.org/package/doclayout-0.3 (JohnMacFarlane)
23:18:04 <hololeap> now how is this subtyping?
23:18:25 <jle`> (.|) expects a transformer on both sides
23:18:33 <jle`> but you can still give it a source
23:18:37 <jle`> or a sink
23:18:46 <jle`> since they legally 'count' w.r.t. how (.|) treats things
23:19:10 <jle`> so you can use a source or sink in a situation where transformers are expected
23:19:18 <jle`> this is subtyping
23:19:38 <jle`> 'X is a subtype of Y' means that anywhere a Y is expected, you can provide an X
23:19:54 <jle`> (in this case, provided the types match up for .|)
23:20:53 <hololeap> it's just undocumented by the type system
23:21:20 <hololeap> or the semantics
23:22:01 <jle`> eh, you can really argue either way. my original point is just that what you choose to consider a sink or pipe or source is up to some degree of interpretation
23:22:20 <jle`> because of how the terms relate to each other
23:22:42 <hololeap> cool. it's helping me think about Conduit on a deeper level
23:23:45 <jle`> Conduit/Pipe is actually an interesting example of how to encode subtyping in Haskell actually, since they have a couple of interesting approaches if you want to look at it formally
23:24:27 <jle`> aside from `type Source o = ConduitT () o`, you'll also find `type Producer i o m a = forall i. ConduitT i o m a`
23:24:59 <jle`> er, that's `type Producer o m a = forall i. ConduitT i o m a`. same kind as Source
23:25:48 <jle`> if you work it out on paper the chain of 'can be used as ... in place of ...' gets intricate
23:26:08 <hololeap> so it yields `o` every time it awaits `i`, no matter what i is
23:26:36 <jle`> not quite
23:26:46 <dminuoso_> I find myself writing runtime assertions/validations in the style of: `assertT ... = do { r <- someAction ...; case c of Just _ -> throwIO SomeErr; Nothing -> pure ()`
23:26:53 <jle`> something of type `Producer o m a` literally canot ever use 'await', or use any result of 'await'
23:27:13 <jle`> er, the second one is true. it can never use anything it receives from await
23:27:15 <hololeap> what about awaitForever (\_ -> ...)
23:27:17 <dminuoso_> Short of writing this with some `whenMJust` instead, is there another more idiomatic way to write this?
23:27:27 <jle`> yeah, it can await, but it can't use anything it gets from awaiting
23:27:38 <hololeap> ok that's what i meant
23:28:07 <jle`> dminuoso_: i do something like forM_ c $ \_ -> throwIO SomeErr in the middle of an action often
23:29:33 <jle`> hololeap: and type Consumer i m a => forall o. ConduitT i o m a, can never use 'yield'
23:29:41 <dminuoso_> jle`: In my case that would require wrapping with a MaybeT though, wouldn't it?
23:29:54 <jle`> dminuoso_: hm, how do you mean?
23:30:00 <jle`> throwIO aborts the rest of the IO actions
23:30:07 <hololeap> jle`: is that any different from Sink?
23:30:09 <dminuoso_> jle`: Oh!
23:30:42 <dminuoso_> jle`: I like it. It doesn't cover the "throw when Nothing" case, but it would address half of my validations nicely
23:30:53 <jle`> hololeap: it's actually isomorphic to sink
23:30:58 <jle`> but you have to convert it to make the types match up
23:31:38 <hololeap> right, because the only thing that would fit into "forall o." is Void
23:32:17 <jle`> we have toConsumer :: Monad m => Sink i m b -> Consumer i m b, in Conduit
23:32:56 <jle`> but actually you can use a Consumer directly as a Sink
23:33:01 <jle`> without needing any conversion functionality
23:33:36 <jle`> so you can say that Consumer is a subtype of Sink
23:33:46 <hololeap> so then why have both? is it beneficial to have o freed up like that?
23:34:55 <jle`> Sink is nicer to ask for in a type signature, but Consumer is nicer to provide as a result in a type signature
23:35:15 <hololeap> ok
23:35:29 <jle`> you can directly use a Consumer as any conduit
23:35:34 <jle`> as if it provided any output
23:35:45 <dminuoso_> (Why is Data.Traversable not re-exporting for_/traverse_ by the way?)
23:35:57 <jle`> myConsumer .| nextPipe is fine, no matter what input nextPipe expects
23:36:10 <jle`> but you can't directly do mySink .| nextPipe if nextPipe expects Int, without converting mySink
23:36:47 <jle`> dminuoso_: hm, at this point i've gotten used to it.  the reason is probably beucase for_ and traverse_ don't have anything to do with Traversable
23:36:51 <jle`> at least not technically
23:37:14 <jle`> but it can be useful to re-export them because people always import Data.Traversable for them, it feels natural-er
23:40:06 <hololeap> now what would the point in doing myConsumer .| nextPipe ?
23:41:41 <jle`> the user is always right :)
23:42:10 <hololeap> lol
23:42:34 <jle`> but really it's the same thing as why we have mapM_ :: (a -> m b) -> [a] -> m (), instead of mapM_ :: (a -> m ()) -> [a] -> m ()
23:42:40 <jle`> it just is a little more flexible
23:44:32 <jle`> there might be some other reasons ... that are escaping my mind right now
23:44:53 <jle`> ah. here's one thing
23:45:02 <dminuoso_> jle`: Though looking a bit through base, it seems like Haskell has a tendency to be really conservative about exports other than Prelude
23:45:23 <jle`> hololeap: you might want to have a pipe that acts like a normal pipe/transformer at first, and then transitions to be a producer
23:45:25 <dminuoso_> For instance, Data.Monoid doesn't re-export anything from Data.Semigroup (even though that might be perfectly reasonable)
23:45:58 <jle`> dminuoso_: i suppose there are benefits to that
23:46:52 <jle`> hololeap: for example `C.take 10 *> repeat 'a'`
23:47:07 <jle`> or do C.take 10; repeat 'a' :: ConduitT Char Char m ()
23:47:28 <jle`> C.repeat, which is repeat x = forever (yield x)
23:47:55 <jle`> hololeap: now if `repeat :: a -> ConduitT () a m ()`, we couldn't directly use it there
23:48:13 <jle`> hololeap: but if repeat :: a -> (forall i. ConduitT i a m ()`, it can be used directly there without requiring extra conversions
23:49:24 <jle`> hololeap: `C.take 10` is a pipe that allows 10 items through and then terminates.  sequencing `C.take 10 >> repeat 'a'` will be a pipe that lets 10 items pass through, and then just repeatedly yields 'a' after the ten items are done
