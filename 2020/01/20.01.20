00:59:53 * hackage elm-syntax 0.2.0.0 - Elm syntax and pretty-printing  https://hackage.haskell.org/package/elm-syntax-0.2.0.0 (OlleFredriksson)
01:10:54 * hackage haskell-to-elm 0.2.1.0 - Generate Elm types and JSON encoders and decoders from Haskell types  https://hackage.haskell.org/package/haskell-to-elm-0.2.1.0 (OlleFredriksson)
01:21:54 * hackage servant-to-elm 0.3.1.0 - Automatically generate Elm clients for Servant APIs  https://hackage.haskell.org/package/servant-to-elm-0.3.1.0 (OlleFredriksson)
01:22:24 <ptek> Hi, is there anyone using dhall in the chat? I am trying to find out how does one deal with a specific environment configuration [development, staging, production]. Do you have several files for that or do you use environment variables to specify which env are you in and somehow use the right record?
01:28:21 <jle`> ptek: your configuration can be a function from < Devel | Staging | Production > to your configuration
01:28:59 <jle`> ptek: but practically that might be manifested as three different files, and a main file to dispatch which one you want to use
01:29:15 <jle`> the nice thing is that your different files only need to specify what is different between the three
01:29:19 <jle`> since they can share most of the components
01:29:45 <jle`> you can have a separate file that has all of the 'common' configuration elements and modify it according to the environment, maybe
01:32:53 <ptek> jle: pardon me if I am just not getting it, but how do you tell the main.dhall to use the right choice?
01:34:18 <ptek> jle: I am thinking of something like "let env = < D | S | P > in env:ENV" but this does not compile with `ENV=P dhall --file main.dhall`
01:36:14 <jle`> ptek: your environment variable would itself be a dhall value
01:36:17 <ptek> jle: the error I am getting is `Error: Unbound variable: P` and I think it just doesn't know how to use that value
01:36:20 <jle`> the contents, that is
01:36:54 <jle`> so you would do `env:ENV`, and ENV="<D|S|P>.P" dhall --file main.dhall
01:37:50 <jle`> and now `env:ENV`, in any dhall file you evaluate locally, will be 'P', and have type <D|S|P>
01:38:07 <ptek> oh
01:38:09 <jle`> so your main function might be a `\(x : <D|S|P>) -> ...`
01:38:19 <jle`> and you would call it with mainFunc env:ENV
01:39:04 <jle`> you can also import an environment variable and treat it as a string/text, `env:ENV as Text`
01:39:29 <jle`> however currently in dhall text values are opaque, and you can't really do anything with them except display them. you can't match and branch on them or check for equality and stuff
01:39:32 <ptek> jle`: but with the Text I'd need to filter some lists, right
01:39:39 <ptek> ah
01:39:56 <ptek> thanks a lot!
01:40:03 <jle`> np :)
01:40:22 <jle`> note that if the contents of the environment variable feels verbose, you can have the type be in a separate file or environment variable
01:40:37 <jle`> so you would just have ENV="(./env).P"
01:41:21 <jle`> or "(env:TYPES).P"
02:03:22 <ferru97> Hi guys. I have a question about haskell that has been troubling me for days. Can someone help me?
02:03:58 <yushyin> try asking
02:04:00 <merijn> ferru97: Possibly, but no one knows unless you say what the question is
02:07:47 <ferru97> I created custom multiset ShoppingBag a = Bag[(a, Int)] deriving (Show, Eq)
02:07:53 <ferru97> I managed to create a mupping function : mapShopping : (a -> b) -> ShoppingBag a -> ShoppingBag b
02:08:00 <ferru97> A question on my tesstbook explicity say that I can't create an instance of Functor using mapShopping as implementation of fmap, but if I try everithing work fine.I was thinking that maybe there is some semantical property of a Functor that a Multiset cannot satissfy.
02:08:42 <iqubic> No. Actually, you can do that.
02:08:58 <iqubic> And it's a law abiding functor.
02:09:07 <merijn> ferru97: The issue is that sets generally provide efficiently log N lookup, generally by using an ordered tree implementation
02:09:30 <merijn> ferru97: Which requires and Ord constraint on 'a' and means you can't make sets like that instance of functor
02:09:47 <merijn> ferru97: Your datatype can be a functor, but it also doesn't implement a multiset correctly
02:10:00 <merijn> ferru97: Consider what happens if I insert the same element into the set twice
02:10:08 <merijn> What does that do?
02:10:28 <iqubic> Isn't that the same as just inserting it once?
02:10:36 <merijn> iqubic: Not for a multiset
02:10:52 <merijn> iqubic: multisets track how many copies are inside the set
02:11:01 <iqubic> Ah. I see.
02:11:01 <merijn> iqubic: i.e. a multiset is more like "Map Value Int"
02:11:05 <iqubic> Right.
02:11:25 <merijn> iqubic: And also, you can't correctly implement the set behaviour of "multiple insert = single insert" either :)
02:11:55 <iqubic> I actually wrote a function that takes a list, and inserts all the elements into a multiset.
02:12:08 <ferru97> there are other function that manage the creation avoiding the duplications 
02:12:16 <ferru97> for example from a list of pair
02:12:28 <iqubic> freqs :: (Ord a) => [a] -> M.Map a Int
02:12:33 <iqubic> freqs xs = M.fromListWith (+) [(x, 1) | x <- xs]
02:12:42 <iqubic> That is the function I wrote.
02:13:00 <merijn> ferru97: And how do those functions work? Using Eq? :)
02:13:11 <Solonarv> okay, what is the result of: mapShopping (\_ -> 'c') (Bag [('a', 2), ('b', 3)] )
02:13:16 <ferru97> yes using Eq on a
02:13:31 <merijn> Solonarv: Oh, that's a good example too
02:13:49 <iqubic> merijn: That freqs function is something I wrote myself. It basically creates a multiset for me.
02:14:05 <ferru97> yes maybe with that map will result an sematical incorrect multiset
02:14:21 <Solonarv> "maybe"? you have the code! test it!
02:14:36 <ferru97> give me a sec :)
02:15:03 <merijn> ferru97: You can fix it by changing "mapShopping :: Eq b => (a -> b) -> ShoppingBag a -> ShoppingBag b", but then mapShopping is no longer the correct type for fmap :)
02:17:32 <ferru97> yes it gives me a Bag [('c',2),('c',3)]
02:20:01 <Solonarv> ah, then you have a semantically incorrect multiset implementation
02:20:14 <Solonarv> surely you agree that the result should be: [('c', 5)] ?
02:20:39 <ferru97> yea sure
02:21:20 <Solonarv> so, you need to combine the (b, Int) tuples where the 'b' is the same
02:21:30 <Solonarv> to check whether they are the same, you need 'Eq b'
02:22:09 <Solonarv> this means (as merijn said already) that the fixed mapShopping can't be a 'fmap' implementation
02:22:44 <ferru97> Oh ok I see it now!
02:23:29 <ferru97> So the main issue is that a correctt mapShopping require Eq b while an instance of fmap dowsn't
02:24:15 <Solonarv> yup
02:24:50 <Solonarv> generally speaking, to be a Functor your "container" must work equally well for *all* choices of element you might put into it
02:25:13 <Solonarv> but mapShopping wants an 'Eq' constraint on the elements, so it *doesn't* work for all choices
02:25:49 <ferru97> Now it's very clear
02:26:03 <ferru97> I've been struggling for days on this question
02:26:06 <ferru97> Thank you so much Solonarv: and merijn:
02:54:08 <fendor> is there some good way to "remember" issues? I've got a bunch of issues that I want to come back, too, but I forget all the time which issues and have to find them again.
02:55:06 <Solonarv> ...browser bookmarks?
02:55:15 * Solonarv has nothing better
02:56:24 <Rembane> fendor: I usually put such things in a Markdown file in a relevant place. Then I can write comments and thoughts on every issue without sharing them with the rest of the world.
02:57:24 <fendor> Solonarv, never used bookmarks before and then I have to sync them between my devices. Which is alright, I guess
02:57:50 <Solonarv> most (all?) of the modern browsers handle that syncing automagically in the background
02:57:54 <Solonarv> at least firefox does
02:58:00 <fendor> Rembane, I was also thinking about that. I dont like that it is so much manual work, I would like some button in github ui
02:58:26 <fendor> Solonarv, yeah, I know, synced tabs or something like that, right?
02:58:44 <Solonarv> tabs are one of the things it can sync, bookmarks and history as well
02:59:28 <Rembane> fendor: That's true. You can add even more manual work by making a browser extension... 
03:00:00 <Solonarv> I think there is some sort of "subscribe" or "follow" feature
03:00:02 <fendor> Rembane, hehe, but after that it is less manual work
03:00:06 <Solonarv> but idk the details
03:00:48 <fendor> Solonarv, I dont think that works when I am watching the whole project?
03:01:08 <Rembane> fendor: Indeed, cue relevant xkcd. :)
03:01:33 <fendor> Rembane, https://xkcd.com/1205/ 
03:02:17 <Rembane> fendor: Exactly! 
03:06:37 <maerwald> fendor: never used it, I think it's overkill, but https://github.com/kowainik/hit-on
03:17:07 <fendor> maerwald, while cool, does not really help with remembering issues I wanted to look at later, right?
03:24:09 <maerwald> fendor: that is basically bookmarks.
03:24:37 <maerwald> you could write a simple tool that saves user/repo/issueId instead, but that's still basically a bookmark
03:25:17 <fendor> maerwald, yeah, I see. makes sense
03:25:47 <maerwald> https://hackage.haskell.org/package/github
03:25:51 <maerwald> off you go! :)
03:28:53 <fendor> not sure if this will make me happier 
03:29:39 <maerwald> give you a week of work with something you could have done with browser bookmarks instead
03:29:40 <maerwald> :D
03:30:05 <maerwald> but this is how we learn best, no? Doing unnecessary things
03:31:11 <juri_> i prefer to do necessary things badly. :D
03:31:28 <fendor> maybe it is not unnecessary and I develop a great app and I get rich! 
03:31:41 <maerwald> yes, opensource has made so many people rich...
03:32:44 <fendor> and I have developed so *many* *great* apps  
03:32:47 <juri_> maerwald: define rich. i've worked in Free Software 24/7 for 25 years.. and now have a middle class life that i would have called rich, back when i lived in a trailer house in the country. :)
03:33:27 <maerwald> rich = money, everything else are excuses *chuckle*
03:33:38 <maerwald> speaking of rich: https://git.io/JvIco am I stuck here with type level programming in haskell?
03:55:34 <merijn> maerwald: Yes, unless you implement an existential wrapper
03:55:50 <merijn> And then you get KnownPath like shenanigans like singletons and Nat
04:19:39 <dminuoso> Given Tagged, how does one implement `(forall (s :: K). Tagged s a -> b) -> b`, such that I can pattern match on K to provide different implementations?
04:19:53 * hackage hlibcpuid 0.1.0.0 - Bindings to https://github.com/anrieff/libcpuid  https://hackage.haskell.org/package/hlibcpuid-0.1.0.0 (dtaskoff)
04:19:54 <dminuoso> (Err, pattern match on `s`)
04:20:13 <dminuoso> Or rather.. how do I implement a function to pass to that./
04:20:31 <hexagoxel> @tell hseg you need tell brittany that you are using -XTypeApplications. Either by putting a module pragma, or via brittany config. The cabal file is not (yet) considered by brittany.
04:20:31 <lambdabot> Consider it noted.
04:20:49 <dminuoso> Do I have to go through singletons?
05:03:58 <idnar> @hoogle (b -> f c) -> (f a -> f b) -> a -> f c
05:03:58 <lambdabot> No results found
05:04:27 <nshepperd2> dminuoso: you need some kind of gadt of s, or typeable.
05:05:49 <nshepperd2> huh, why is Sing from singletons package not a data family
05:08:43 <lortabac> nshepperd2: https://github.com/goldfirere/singletons/issues/421
05:11:28 <nshepperd2> ah, it was a recent change
05:14:39 <nshepperd2> alright, makes sense
05:26:43 <kuribas> :t \f g x -> g (pure x) >>= f
05:26:44 <lambdabot> (Monad m, Applicative f) => (a1 -> m b) -> (f a2 -> m a1) -> a2 -> m b
05:27:13 <kuribas> idnar: ^^
05:28:55 <rsoeldner> Someone has experience with `zlib` and `nixos` ? I'm failling to install ghcide with `cabal v2-install ghcide` due to missing zlib dep which I have added like this https://pastebin.com/AaH1wexj
05:30:23 <__monty__> rsoeldner: I recommend against installing ghc globally. Check out the haskell infrastructure section of the nixpkgs manual: https://nixos.org/nixpkgs/manual/#haskell
05:32:46 <rsoeldner> __monty__, Ok, but still, is still do not get why this shouldn't work. 
05:34:47 <__monty__> System-wide dependencies on NixOS aren't worth the bother.
05:35:17 <rsoeldner> __monty__, :P
05:40:47 <__monty__> rsoeldner: I'm not just saying this. If you persist in doing this you'll only bring a world of hurt upon yourself.
05:45:52 <rsoeldner> __monty__, I see, but still strange with zlib. Thanks for the link
05:53:31 <[exa]> Hm guys, is there any good explanatory-level article about compiling the multifield pattern matches in ghc?
05:53:49 <[exa]> I remember there was something but forgot the name
06:11:17 <dminuoso> nshepperd2: Oh you mean like a type indexed gadt?
06:11:54 * hackage system-info 0.5.0.0 - Get the name of the operating system  https://hackage.haskell.org/package/system-info-0.5.0.0 (dtaskoff)
06:14:12 <p0a> Hello, is parsec a good library?
06:15:59 <dminuoso> p0a: For the most part, parsec has been superseeded by megaparsec.
06:17:05 <dminuoso> (It was a fork originally and has better performance, better error reporting and more combinators)
06:17:32 <sshine> p0a, it's not a bad library.
06:18:31 <sshine> p0a, it's been the standard for a long time, but megaparsec has certain advantages.
06:18:48 <sshine> p0a, you can certainly still use parsec without a problem.
06:18:53 <idnar> kuribas: I went with g . pure >=> f :)
06:19:14 <sshine> p0a, it's kind of like what's happening with QuickCheck and Hedgehog, except Megaparsec seems more well-documented at this point.
06:19:51 <p0a> sshine: not aware of that situation 
06:20:03 <p0a> dminuoso: thanks, I will check megaparsec
06:20:21 <dminuoso> p0a: See https://github.com/mrkkrp/megaparsec#megaparsec-vs-parsec
06:22:22 <p0a> great, thank you
06:22:33 <dminuoso> jackdk: There's a really cool thing I came up with wither, which is basically: `witherAlt :: Alternative f => (a -> f (Maybe b)) -> [a] -> f [b]; witherAlt f = wither (optional . f)`
06:22:56 <dminuoso> I have about 6 uses of this already :)
06:23:56 <dmwit> :t optional
06:23:58 <lambdabot> Alternative f => f a -> f (Maybe a)
06:24:21 <dminuoso> Strictly, it could be polymorphic over any Witherable - but I dont have witherable in my build-depends right now, so its handcrafted and specialized to []
06:24:25 <dmwit> How does that typecheck?
06:24:38 <dminuoso> Ohh huh
06:24:40 <dmwit> Did you mean `witherAlt :: Alternative f => (a -> f b) -> ...`?
06:24:41 <dminuoso> My bad!
06:24:44 <dminuoso> witherAlt :: Alternative f => (a -> f b) -> [a] -> f [b]
06:24:46 <dminuoso> wither :: Applicative f => (a -> f (Maybe b)) -> [a] -> f [b]
06:24:49 <dminuoso> Copy paste mistake. :)
06:25:51 <dmwit> Seems occasionally handy.
06:26:46 <dminuoso> I found it when writing some optparse-applicative code, when I had a list of parser for warning flags, and I wanted to collect any specified warning flag.
06:30:06 <aveltras> having some type like the following, how could i get my type signatures to say that a function taking RequestG1 should return Bool and Int when used with RequestG2 Int, only by using a type variable "request" representing all possible inputs ?
06:30:10 <aveltras> https://www.irccloud.com/pastebin/1LD5SEFq/
06:33:22 <solonarv> aveltras: 'func :: RequestG req -> req' ?
06:34:54 <aveltras> right now, im trying to setup a newtype wrapper for a function which should handle requests of type RequestG like req x -> x
06:35:01 <aveltras> x being Bool or Int in my example
06:35:12 <aveltras> but i don't want to have two type variables
06:35:18 <aveltras> x shouldn't be there i think
06:35:38 <solonarv> oh, you want to abstract over 'RequestG' as well instead of fixing it in place?
06:35:54 <aveltras> yes
06:36:00 <aveltras> it's for use in a library
06:36:07 <aveltras> where client should only define the gadts
06:36:14 <aveltras> and library functions should work over it
06:36:47 <solonarv> ah, then I think you want something like: newtype Perform req = Perform { runPerform :: forall x. req x -> x }
06:38:37 <aveltras> let me see if i get this to compile :)
06:39:12 <solonarv> you might need one or two extra GHC extensions, but seeing as you're already using GADTs I doubt that will scare you
07:00:12 <aveltras> solonarv: i don't really see how to make this work since i can't refer to the response type variable (or at least i think i cant)
07:00:16 <aveltras> https://www.irccloud.com/pastebin/zbhqbVAB/
07:00:47 <aveltras> there's an ambiguity at the decodeXhrResponse
07:06:44 <aveltras> ok i get this to compile without the newtype wrapper, guess it's good enough
07:06:48 <aveltras> thanks for the hints
07:06:50 <AWizzArd> I have a newtype `AppT m a` and an alias `type App a = AppT IO a`.   Now I wanted to make an `instance MonadDBTransaction App where ...`  <- can I use an alias here?
07:07:59 <solonarv> yes, with a language extension
07:08:12 <solonarv> and you may need to change the alias to 'type App = AppT'
07:09:39 <solonarv> however I would suggest simply writing `instance MonadIO m => MonadDBTransaction (AppT m) where ...` if you can, since it's a bit more general
07:10:08 <Philonous> type aliases always have to be fully saturated, so »instance <..> App where« won't work, but you can just define your type alias like solanarv said
07:10:26 <AWizzArd> okies
07:10:30 <AWizzArd> thx
07:11:05 <solonarv> I said "may" because I wasn't sure that GHC wouldn't eta-reduce that type alias for you
07:12:00 <Philonous> Actually, it's »type App = AppT IO« 
07:12:11 <Philonous> But it's the same idea
07:12:20 <solonarv> oh, oops
07:13:57 <Philonous> I'm kind of glad GHC doesn't do eta-reduction here, because you might end up in a situaion where you change the type definition and suddenly something else down the line breaks seemingly for no reason 
09:07:24 * hackage type-of-html 1.5.1.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.5.1.0 (knupfer)
09:20:23 <infinisil> Neat package ^
09:23:49 <jusss> foldl = fix f, how to get f?
09:26:35 <Taneb> jusss: what's the explicitly recursive definition of foldr?
09:26:44 <solonarv> (foldl, not foldr)
09:26:44 <Taneb> (as in, defined in terms of itself)
09:26:48 <solonarv> @src foldl
09:26:48 <lambdabot> foldl f z []     = z
09:26:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:28:07 <jusss> but this need to convert to lambda ?
09:28:30 <solonarv> yes, which you can do very mechanically
09:31:39 <jusss> foldl = \f l1 l2 -> if (l2 == []) then l1 else f (f l1 (head l2)) (tail l2)
09:32:01 <jusss> right?
09:36:03 <jusss> foldl = \f result list -> if (null list) then result else foldl (f result (head list)) (tail list)
09:38:02 <jusss> foldl = \f result list -> if (null list) then result else foldl f (f result (head list)) (tail list)
09:38:38 <jusss> Taneb: solonarv , then what?
09:44:24 * hackage json-syntax 0.1.0.0 - High-performance JSON parser  https://hackage.haskell.org/package/json-syntax-0.1.0.0 (andrewthad)
09:45:54 * hackage vformat 0.11.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.11.0.0 (gqk007)
09:49:13 <tom__> Is there a nice way of using an offset and limit in a postgres-simple query based on whether a Just or a Nothing is supplied to the query generating function for either parameter?
09:51:44 <jusss> gg = \foldl f result list -> if (null list) then result else foldl f (f result (head list)) (tail list)
09:52:24 <jusss> @let gg = \foldl f result list -> if (null list) then result else foldl f (f result (head list)) (tail list)
09:52:26 <lambdabot>  Defined.
09:52:36 <jusss> > gg foldl (+) 0 [1,2,3]
09:52:39 <lambdabot>  6
09:52:48 <jusss> that's it?
09:54:24 * hackage turtle 1.5.16 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.16 (GabrielGonzalez)
09:55:24 * hackage lawz 0.1 - Common mathematical laws.  https://hackage.haskell.org/package/lawz-0.1 (cmk)
09:59:24 * hackage mmsyn7ukr 0.7.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.0.0 (OleksandrZhabenko)
10:07:23 * hackage bookkeeping-jp 0.1.1.4 - Helper functions for Japanese bookkeeping.  https://hackage.haskell.org/package/bookkeeping-jp-0.1.1.4 (arowM)
10:17:15 <dmwit> jusss: That's it.
10:17:40 <dmwit> jusss: You can make it even more mechanical: instead of null, head, tail, you can use the same pattern matching.
10:18:06 <dmwit> \foldl f z fresh -> case fresh of [] -> z; x:xs -> foldl f (f z x) xs
10:18:11 <dmwit> :t fix (\foldl f z fresh -> case fresh of [] -> z; x:xs -> foldl f (f z x) xs)
10:18:12 <lambdabot> (t1 -> t2 -> t1) -> t1 -> [t2] -> t1
10:18:30 <jusss> dmwit: f = fix gg, but f is not foldl
10:18:46 <dmwit> Convince me.
10:19:01 <jusss> @let fff = fix gg
10:19:03 <lambdabot>  Defined.
10:19:16 <jusss> fff (+) 0 [1,2,3]
10:19:30 <jusss> > fff (+) 0 [1,2,3]
10:19:32 <lambdabot>  6
10:19:37 <dmwit> > fff (+) 0 [1,2,3] === foldl (+) 0 [1,2,3]
10:19:40 <lambdabot>  error:
10:19:40 <lambdabot>      • No instance for (Show Test.QuickCheck.Safe.SProperty)
10:19:40 <lambdabot>          arising from a use of ‘show_M52234029220551649422208’
10:19:43 <dmwit> > fff (+) 0 [1,2,3] == foldl (+) 0 [1,2,3]
10:19:46 <lambdabot>  True
10:19:50 <dmwit> Looks fine to me.
10:19:54 * hackage selda-sqlite 0.1.7.1 - SQLite backend for the Selda database EDSL.  https://hackage.haskell.org/package/selda-sqlite-0.1.7.1 (AntonEkblad)
10:20:12 <solonarv> although (+) is not a very good test function, tbh
10:20:20 <solonarv> since it is both associative and commutative
10:20:46 <dmwit> Since I believe they are equal, I believe there is no good test function. ^_^
10:20:54 * hackage selda-postgresql 0.1.8.1 - PostgreSQL backend for the Selda database EDSL.  https://hackage.haskell.org/package/selda-postgresql-0.1.8.1 (AntonEkblad)
10:21:31 <jusss> @let reverse = (\result -> list -> if (null list) then result else reverse (tail list) ((head list):result)) []
10:21:32 <lambdabot>  Parse failed: Parse error in pattern: if (null list) then result else
10:21:32 <lambdabot>    reverse (tail list) ((head list) : result)
10:22:19 <jusss> dmwit: how to handle this case? this reverse need a init value [], but it doesn't show in the parameter
10:22:27 <jusss> that result is []
10:22:34 <jusss> :t reverse
10:22:36 <lambdabot> [a] -> [a]
10:22:41 <solonarv> stop it with the 'if (null list) then ... else ... head ... tail ...' already! use pattern matching!
10:22:46 <jusss> but reverse only have one parameter
10:23:02 <dmwit> jusss: First show how to define reverse without fix.
10:23:05 <jusss> solonarv: very sorry, old scheme habbit
10:23:08 <dmwit> Then I will show you the mechanical translation into using fix.
10:23:31 <dmwit> (The solution to "how do I have a helper function" is *exactly* the same in both situations.)
10:24:09 <jusss> reverse = \result -> list -> if (null list) then result else reverse (tail list) ((head list):result)
10:24:32 <dmwit> No. Show me the explicit recursion version.
10:24:43 <dmwit> (Or I can show you, if you prefer.)
10:25:00 <jusss> dmwit: sorry I don't understand what you mean
10:25:07 <jusss> 'explict' version
10:25:28 <jusss> r l = reverse [] l
10:25:47 <jusss> this r is reverse, I think 
10:26:23 <jusss> my reverse need a empty list [] as a init value to store the result
10:26:23 <dmwit> You want to implement reverse as a call to fix. I am asking if you know how to implement reverse at all, even without the extra constraint of "make it a call to fix".
10:26:39 <dmwit> You say "my reverse needs ...". Show me your reverse.
10:27:45 <int-e> > let reverse' acc [] = acc; reverse' acc (x:xs) = reverse' (x:acc) xs; reverse = reverse' [] in reverse [1,2,3] -- this?
10:27:48 <lambdabot>  [3,2,1]
10:29:25 <dmwit> If you like. Then the mechanical translation is `reverse' = fix (\fresh1 acc fresh2 -> case fresh2 of [] -> acc; x:xs -> fresh1 (x:acc) xs); reverse = reverse' []`.
10:30:14 <jusss> dmwit: reverse = (\result -> \list -> if (null list) then result else reverse (tail list) ((head list):result)) []
10:30:24 * hackage mmsyn7ukr 0.7.1.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.1.0 (OleksandrZhabenko)
10:30:44 <dmwit> jusss: That doesn't typecheck.
10:30:57 <jusss> yeah, I don't know where's wrong
10:31:00 <int-e> jusss: That doesn't type-check, since the "reverse" you're defining has a single argument but you're calling it with 2.
10:31:22 <dmwit> jusss: So. This is my point. =)
10:31:26 <dmwit> Your confusion is not about fix.
10:31:26 <int-e> jusss: The final [] is wrong, I think.
10:31:33 <dmwit> It's about how to have a helper function available.
10:31:48 <dmwit> And the answer to that is to use let or where for a local binding, or have a global binding that you don't export, or similar.
10:31:50 <jusss> wait a sec
10:31:58 <jusss> this is similar
10:32:34 <int-e> . o O ( "similar" and "wrong" have a huge overlap )
10:32:51 <dmwit> jusss: Here is one example of how to fix it:
10:33:04 <jusss> dmwit: don't tell me yet
10:33:10 <jusss> I think I can get it
10:33:16 <dmwit> reverse = go [] where go result list = if null list then result else go (head list:result) (tail list)
10:33:21 <jusss> it's very like that case in scheme
10:33:23 <dmwit> oh, sorry
10:36:03 <jusss> dmwit: it's just let sugar in scheme, 
10:36:30 <dmwit> It is just let syntax in Haskell.
10:36:56 <jusss> (define f (let ((result [])) (lambda ...)))
10:37:20 <jusss> but I forget a lot of scheme
10:37:37 <jusss> that lambda is really f
10:37:50 <jusss> that is a closure, right?
10:38:53 * hackage selda 0.5.1.0 - Multi-backend, high-level EDSL for interacting with SQL databases.  https://hackage.haskell.org/package/selda-0.5.1.0 (AntonEkblad)
10:38:55 <dmwit> hm
10:39:10 <dmwit> I think no. But I am not sure because I don't know what "that" refers to in your question.
10:41:37 <dmwit> I also don't think anything important depends on the answer to that question.
10:41:44 <jusss> (define count ((lambda (n) (lambda () (set! n (+ n 1)) n)) 0))
10:41:44 <jusss> (define count (let ((n 0)) (lambda () (set! n (+ n 1)) n)))
10:42:29 <jusss> maybe I'm wrong...
10:42:54 <jusss> dmwit: can you use lambda to express that reverse without 'where'
10:43:01 <jusss> just lambda bindings
10:43:17 <DigitalKiwi> how to avoid nested case of Eithers?
10:43:19 <dmwit> Yes.
10:43:19 <jusss> no let or where sugar
10:43:46 <DigitalKiwi> do i want Validation
10:43:58 <dmwit> The difference between lambda and let/where is how polymorphic the binding is. It is okay for this binding to be monomorphic. Therefore there is no important difference.
10:44:13 <DigitalKiwi> of course TonyMorris, qfpl :D
10:44:32 <cocreature> what is the difference between the "id" and the "key" field in GHC package conf files?
10:44:33 <dmwit> DigitalKiwi: Maybe. Or maybe Either is fine. It depends on why you have nested Eithers.
10:44:54 * hackage natural-arithmetic 0.1.2.0 - Arithmetic of natural numbers  https://hackage.haskell.org/package/natural-arithmetic-0.1.2.0 (andrewthad)
10:45:14 <DigitalKiwi> dmwit: https://myfriendshate.me/files/Main.hs
10:45:28 <dmwit> Validation is good when Applicative is enough and you want to know all the errors. Either is good when you need Monad or want to stop at the first error.
10:45:40 <DigitalKiwi> plz don't look at my commented code
10:46:15 <solonarv> it looks like you are stopping at the first error anyway, here
10:46:34 <DigitalKiwi> all 1 line of it *wink*
10:46:34 <solonarv> which means the Applicative/Monad instances for (Either e) should do just fine
10:46:50 <dmwit> fourC2value b1 b2 b3 b4 = do b <- value; mb <- lift multiplier; ta <- lift tolerance; pure (b*mb, ta)
10:47:08 <dmwit> lift (Left e) = Left [e]; lift (Right v) = Right v
10:47:09 <solonarv> what's the 'lift' for?
10:47:23 <dmwit> solonarv: to turn one kind of error into the other
10:47:29 <dmwit> lift is a bad name.
10:47:31 <dmwit> pick a better one
10:47:34 <solonarv> ah yes, I sent my message just before you sent yours
10:47:48 <solonarv> I thought you were referring to Control.Monad.Trans.Lift
10:47:56 <dmwit> Yeah, lift is a bad name. Sorry.
10:48:19 <jusss> dmwit: sorry, I'm waiting for your lambda :)
10:48:27 <dmwit> (I guess you can inline the lets, too, so `b <- twocolors2value b1 b2` etc.)
10:48:49 <dmwit> jusss: It's the same translation as in scheme: let x = y in z -> (\x -> z) y
10:48:54 <solonarv> FWIW, your 'lift' is simply: Data.Bifunctor.first (:[])
10:49:06 <dmwit> solonarv: nice!
10:49:37 <DigitalKiwi> inb4 use lens
10:49:52 <jusss> dmwit: just show it without 'let' 'where' pls
10:50:16 <DigitalKiwi> lens is always the answer for my problems just the question is not always clear
10:50:34 <dmwit> old: reverse = go [] where go result [] = result; go result (x:xs) = go (x:result) xs
10:51:20 <dmwit> with fix: reverse = go [] where go = fix (\g result fresh -> case fresh of [] -> result; x:xs -> g (x:result) xs)
10:51:42 <dmwit> without where: reverse = fix (\g result fresh -> case fresh of [] -> result; x:xs -> g (x:result) xs) []
10:53:32 <dmwit> (without where, but mechanically: reverse = (\go -> go []) (fix (\g result fresh -> case fresh of [] -> result; x:xs -> g (x:result) xs))
10:54:00 <jusss> dmwit: I remember how I do that in scheme, I used set! to change the variable, but that's not ok in haskell
10:55:08 <cocreature> okay, if I read this correctly "key" is just dead
10:55:17 <cocreature> i.e. old and deprecated in favor of "id"
10:59:03 <DigitalKiwi> dmwit: thanks i like that one you gave
10:59:54 * hackage dual 0.1.1.0 - Dual category  https://hackage.haskell.org/package/dual-0.1.1.0 (MatthewFarkasDyck)
11:00:23 <hololeap> so is leksah an abandoned project?
11:02:44 <hololeap> nvm, it looks like it's just not updated on hackage anymore
11:05:23 * hackage dual 0.1.1.1 - Dual category  https://hackage.haskell.org/package/dual-0.1.1.1 (MatthewFarkasDyck)
11:25:24 * hackage hpath-filepath 0.10.3 - ByteString based filepath manipulation  https://hackage.haskell.org/package/hpath-filepath-0.10.3 (maerwald)
11:26:25 * hackage hpath-io 0.12.0, hpath 0.11.0 (maerwald): https://qbin.io/honda-pages-9nwc
11:28:54 * hackage tar-bytestring 0.6.1.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.1.0 (maerwald)
11:29:54 * hackage byteslice 0.2.0.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.2.0.0 (andrewthad)
11:41:54 * hackage smith 0.1.1.0 - Parse arrays of tokens  https://hackage.haskell.org/package/smith-0.1.1.0 (andrewthad)
11:43:52 <monochrom> Yikes, 8.8.2 already?!
11:44:59 <amx> it's already been three days
11:45:15 <c_wraith> It's several important-looking bug fixes.
11:45:23 <c_wraith> Doesn't look like it has any new features.
11:45:37 <monochrom> Right, I'm procrastining reading haskell-cafe messages.
11:47:49 <maerwald> monochrom: something scaring you? :>
11:48:12 <monochrom> that time flies like an arrow
11:48:27 <monochrom> @quote monochrom macro
11:48:27 <lambdabot> monochrom says: Time leaks like an arrow. Syntax rules like a macro.
11:58:23 * hackage hs-functors 0.1.6.0 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.6.0 (MatthewFarkasDyck)
12:01:53 * hackage reflex-process 0.2.0.0 - reflex-frp interface for running shell commands  https://hackage.haskell.org/package/reflex-process-0.2.0.0 (abrar)
12:03:53 * hackage lens-core 0.0.0.0 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-core-0.0.0.0 (MatthewFarkasDyck)
12:11:53 * hackage binary 0.8.8.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.8.0 (LennartKolmodin)
12:22:54 * hackage reflex-ghci 0.1.3.1 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.3.1 (abrar)
12:50:10 <jackdk> dminuoso: that witherAlt looks pretty neat
12:52:06 <zeta_0> could you guys help me with this issue? https://github.com/xmonad/xmonad/issues/210
12:52:56 <zeta_0> i think i found the link that explains how to do this but i want to make sure that i am doing this correct: https://hackage.haskell.org/package/xmonad-contrib-0.13/docs/XMonad-Hooks-EwmhDesktops.html
12:56:22 <hseg> Hi. How do I get brittany to stop removing the space preceding a type application?
12:56:44 <hseg> nm, just saw the message
12:58:24 * hackage lens-core 0.1.0.0 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-core-0.1.0.0 (MatthewFarkasDyck)
12:59:26 <zeta_0> is there people in #xmonad, i don't want to be stuck waiting for hours?
13:15:24 * hackage lens-core 0.1.0.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-core-0.1.0.1 (MatthewFarkasDyck)
13:27:04 <jackdk> zeta_0: Try things yourself and see what happens. You received an answer in that GH issue; have you actually tried it? If it doesn't work, show people what you actually tried, etc. The world is not your personal support team. https://www.mikeash.com/getting_answers.html
13:28:50 <zeta_0> jackdk: hello there, yes i tried geekausaurs's instructions, xmonad recompiled without any errors, but it still did not solve my issue, maybe i am missing something
13:29:40 <zeta_0> jackdk: i asked for help in #xmonad as well, i'm just waiting for someone to respond
13:37:48 <jackdk> I don't know xmonad, but posting a "here's what I tried", including code snippets, to the GH issue seems possibly useful. Surround code in ``` to get a code block so it renders nicely
13:56:12 <roconnor> Is it the case that C structures cannot be marshalled, even when the type on the Haskell side is Storable?
13:59:55 <HiRE> Has anyone encounter the `recompile with -fPIC` error on arch linux?
14:00:14 <HiRE> im running stack with GHC 8.6.5
14:00:24 <HiRE> stack 2.1.3
14:01:06 <HiRE> nothing compiles, even a simple hello world. I get thousands of `requires dynamic R_X86_64_PC32 reloc against '<XZ>' which may overflow at runtime; recompile with -fPIC`
14:01:24 <HiRE> where <XZ> is a library - strlen, free, reloc, etc.
14:01:24 <jackdk> roconnor: I have written storable instances for structs before
14:01:37 <c_wraith> HiRE: did you install ghc from pacman?
14:01:55 <HiRE> c wraith: I uninstalled it to use the stack-given ghc via `stack ghc`
14:01:59 <MarcelineVQ> I have before but not for a long time, it's supposed to detect what libs you have an set up ghc appripriately, hmm
14:02:28 <HiRE> fwiw I installed stack via the websites's curl script.
14:02:30 <c_wraith> HiRE: just checking, because pacman likes to install a broken build of ghc. 
14:03:08 <HiRE> yeah thats what brought me to use stack :)
14:03:14 <MarcelineVQ> pacman's (dynamic related) ghc's errors tend to be about missing package files fwiw
14:03:32 <roconnor> jackdk: Okay.  I mean I'm still getting the ‘FrameItem’ cannot be marshalled in a foreign call error.  Which leaves me confused.
14:04:43 <MarcelineVQ> -fPIC I haven't seen for quite awhile, it might be work making an issue about
14:04:51 <MarcelineVQ> worth
14:05:08 <jackdk> roconnor: I have no idea what you're doing, what your code looks like or how exactly it's going wrong. I've got to head to work so I'm just going to have to drop a link to some Storable instances I wrote and then run; I hope it helps: https://git.sr.ht/~jack/libtelnet-haskell/tree/master/src/Network/Telnet/LibTelnet/Types.hsc
14:08:28 <roconnor> https://wiki.haskell.org/Foreign_Function_Interface#Foreign_types says "Warning: GHC does not support passing structures as values yet. "
14:10:10 <jackdk> ah, the api I wrapped passes pointers-to-structs everywhere. suggestion: write a thin C shim that takes/returns pointers and passes to the underlying lib as values?
14:11:09 <roconnor> yep.  And since it is my C code I might just redo the interface to take pointers to const rather than structures.
14:15:39 <jackdk> iirc that's more conventional, especially if your structs are large
14:31:23 * hackage lens-core 0.1.0.2 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-core-0.1.0.2 (MatthewFarkasDyck)
15:46:43 <maerwald> how do you pass cabals '-f' to stack to build a package with certain flags?
15:51:58 <Axman6> I think there's a --flag flag, which you use as --flag <package>:<flag-name> (it might not be called --flag though, I don't remember)
15:52:26 <Axman6> yeah it's --flag: --flag bits-extra:bmi2
15:56:54 * hackage small-bytearray-builder 0.3.2.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/small-bytearray-builder-0.3.2.0 (andrewthad)
15:59:02 <habbah> what does persistent give me that I can't get with postgres-simple?
15:59:12 <Axman6> pain
16:00:43 <c_wraith> in theory, writing queries based on a DSL instead of combining text.
16:00:44 <maerwald> :D
16:01:07 <maerwald> sql is already a DSL :>
16:02:54 <WinchellsM> Is there an equivalent of `pgrep` in Haskell, or something that allows users to get a Linux process id (pid) by name/String?
16:07:48 <habbah> Axman6: that isn't what I was expecting. is there a blog article I could read about the pain, or do you care to elaborate? thank you for responding, btw
16:09:37 <jackdk> habbah: https://williamyaoh.com/posts/2019-12-14-typesafe-db-libraries.html possibly. I've heard Axman6 rant a lot about persistent but haven't used it myself
16:11:59 <Axman6> I used it once, never again, it was a massive pain to move off and didn't really buy us much. we moved that app to hasql and it became much simpler, much faster, but less type safe
16:12:51 <sm[m]> habbah: persistent aims to make it quick to throw together simple crud apps with a minimum boilerplate
16:13:16 <monochrom> haha database for professional hitmen
16:31:36 <jle`> is there a list of all data types in base
16:31:42 <jle`> i need to generate instances for all o' dem
16:39:37 <iqubic> jle`: What are you doing?
16:40:19 <jle`> making instances for all the data types
16:40:25 <jle`> in base
16:40:31 <jle`> D:
16:40:51 <iqubic> Yes, but why?!?
16:41:53 <iqubic> jle`: Why are you doing this?
16:45:36 <jle`> i ran out of things to do
16:48:14 <iqubic> Really? I can't tell if you are joking or not.
16:49:32 <MarcelineVQ> I hear that's genetic
16:58:24 <habbah> Axman6: have you tried hasql-th and would that help with the type safety?
17:10:02 <haskode> consider this problem https://leetcode.com/problems/two-sum/, whats the most natural way of solving it?
17:10:18 <haskode> in imperative languages, its basically a 2 for loops
17:17:35 <evanjs> haskode: seems like codewars has an option for haskell so I'd assume so -- https://www.codewars.com/kata/52c31f8e6605bcc646000082 -- hrm
17:17:46 <dmwit> haskode: [(i,j) | (i,v) <- zip [0..] xs, (j,w) <- zip [0..] ys, v+w == target, i /= j]
17:18:09 <dmwit> It's basically 2 for loops in Haskell, too.
17:18:22 <dmwit> There may be more efficient ways. But this way is very natural.
17:18:32 <haskode> kekw thats ... quite unreadable
17:18:44 <dmwit> Looks quite readable to me. Maybe you need glasses.
17:18:56 <haskode> how to create [(element, index)] from list
17:19:05 <MarcelineVQ> just means you should learn about list comprehensions at this point
17:19:07 <dmwit> zip [0..] list
17:19:21 <dmwit> (Which you can see twice in the code above.)
17:19:54 <dmwit> Oh, I guess the ys should be xs.
17:20:30 <sm[m]> Haskell glasses!
17:20:43 <sm[m]> I would buy those
17:21:24 <hpc> they're like regular glasses, but with lenses
17:21:43 <evanjs> rosetta code is a nice resource for this kind of thing IMO -- http://www.rosettacode.org/wiki/List_comprehensions
17:21:54 <evanjs> e.g. I know how to do x in language a but not language b
17:22:07 <sm[m]> the view is spectacular
17:22:37 <jle`> haskode: hm, maybe it is a little more readable if you put it over different lines
17:22:52 <jle`>     [ (i, j)
17:23:01 <jle`>     | (i, v) <- zip [0..] xs
17:23:13 <jle`>     , (j, w) <- zip [0..] ys
17:23:23 <jle`>     , v + w == target && i /= j
17:23:25 <jle`>     ]
17:23:34 <jle`> the you can clearly see the logic that is going on
17:23:44 <haskode> a solution to problem 1295 is something like this, and i really like this kind of algorithms
17:23:47 <haskode> findNumbers :: [Int] -> IntfindNumbers = length . filter even . map (length . show)
17:23:48 <jle`> "i want (i, j), where i and v are from xs, j and w are from ys, etc.
17:23:53 <hpc> it might be easier to read as do-notation
17:24:27 <jle`> and also it's a pretty direct translation of the problem statement i think
17:56:51 <HiRE> Stupid question but im new to haskell. I'm trying to think of a good thing to return from a function that represents a divide by zero intelligently
17:56:52 <HiRE> Infinity doesnt really work because 0/0 is undefined...not infinity.
17:56:52 <HiRE> is there a nice existing error type for this?
17:56:52 <HiRE> (I wanted to use undefined but that seems more like a placeholder than a useful error thing)
18:01:29 <ChaiTRex> HiRE: There are Maybe and Either.
18:02:47 <ChaiTRex> > let divide _ 0 = Nothing; divide a b = Just (a/b) in divide 5 0
18:02:50 <lambdabot>  Nothing
18:03:12 <ChaiTRex> > let divide _ 0 = Left "divide by zero"; divide a b = Right (a/b) in divide 5 0
18:03:15 <lambdabot>  Left "divide by zero"
18:04:11 <ChaiTRex> HiRE: There's also using the error function.
18:04:34 <ChaiTRex> > let divide _ 0 = error "divide by zero"; divide a b = a/b in divide 5 0
18:04:36 <lambdabot>  *Exception: divide by zero
18:16:02 <dmwit> HiRE: It would probably be good to explain why the current divide-by-zero situation doesn't meet your needs.
18:16:38 <HiRE> just felt weird tbh. I guess letting it exception out is probably fine
18:16:44 <HiRE> being new to haskell im probably overthinking things
18:21:42 <MarcelineVQ> infinity as a result isn't specifically a haskell thing it's a ieee floating number thing
18:22:43 <MarcelineVQ> that being said 0/0 is NaN not infinity
18:22:56 <HiRE> yeah NaN makes sense
18:23:07 <HiRE> I was certainly overthinking it
18:24:09 <MarcelineVQ> just in case you're intending integral division it's   div  rather than   /
18:30:54 * hackage warp 3.3.8 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.8 (KazuYamamoto)
18:31:54 * hackage warp-tls 3.2.11 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.11 (KazuYamamoto)
18:43:24 * hackage massiv 0.4.5.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.4.5.0 (lehins)
19:18:22 <fog> any thoughts on Scope and reifying instances?
19:20:08 <fog_> i want to check if it has lazy evaluation
19:21:28 <MarcelineVQ> You need to include what Scope is with such a question
19:23:05 <fog__> its a value that exists via a constraint which records the other values reified so appearing via constraints
19:23:50 <fog__> ie, on reifying a value to appear as existing via a constraint, the Scope should by updated accordingly
19:24:03 <fog__> so we can ask to see which constraints are in Scope
19:24:39 <fog__> what is being reified is just Symbol adorned values of some type, corresponding to let binding 
19:25:05 <fog__> the constraints are just that there is a value and type corresponding to that name
19:25:58 <fog__> the Scope then just stores these names types and values, by having a class Create a where create :: a instance 
19:26:29 <fog__> and having a Create instance appearing as the constraint, that a value of some named type can be returned
19:26:38 <fog__> the name is like the name of the let bound variable
19:26:43 <MarcelineVQ> I ​just meant like, a link to a definition, otherwise no one would have a clue what you're asking for thoughts 'on'
19:27:27 <fog__> yeah, its just a list updated on reification to store which values have been placed in "Scope"
19:27:34 <MarcelineVQ> It's just a better way to ask a question, including context along with it, Scope-ing the question as it were :>
19:29:20 <fog__> i want to set up enough of an implementation of this to test to see if i can lazily consume an infinite list, as a tail recursive value level function/type level implementation  
19:30:37 <fog__> i think it should be lazy, since it is only when an instance is demanded by a value level computation that the constraint is unpacked and the value it stores is evaluated, calling further consuming of variables from Scope
19:30:47 <fog__> ie, it is only evaluated if it is demanded
19:31:18 <fog__> i think if i can show an infinite list being lazily consumed then it will show everything is implemented correctly
19:32:40 <fog__> this has abstracted over a previous model where a graph of edges were supplied, where now the referencing is all donw by name
19:32:43 <fog__> done*
19:33:03 <fog__> the function implementation in lambda calculus basically defines the graph then
19:33:28 <fog__> i guess it would be nice to be able to actually construct this graph at type level from dereferencing the let bound names
19:34:10 <fog__> but it gets around trying to work with an explicit implementation of a graph at type level
19:35:00 <fog__> there is no need to evaluate columns from left to right like the deep neural net approach of maiking a function net, instead, there are lazily demanded named references 
19:35:34 <fog__> which consume the graph greedily as opposed to proceeding one layer of evaluations at a time
19:36:19 <fog__> greedily and lazily... depth first
19:37:06 <fog__> Is what i describe clear enough so that anyone can imagine how to implement it?
19:37:43 <fog__> how to write this constraint continuation updated Scope reification of named values of some type?
19:38:16 <MarcelineVQ> Is there a notion of lazyness at the type level?
19:40:21 <Axman6> I feel like Csongor Kiss wrong something about that
19:41:11 <fog__> the point is just that if demand call a Create constraint is satisfied, and it goes to this reification point and needs to evaluate more create functions to call values from Scope
19:41:22 <fog__> then it should only call the Constraints on demand
19:42:06 <fog__> so it should be possible to have an infinite chain of such, and if not evaluating the whole infinite sequence of tail calls, avoid an infinite computation
19:50:02 <fog__> would anybody be able to help implement it?
19:55:23 <fog__> if i get this thing working with lists then i get a neural network for free 
19:55:40 <Axman6> neural network for free sounds fun
19:56:20 <fog__> yeah, i wrote all that before,the last part i need is this reification scope thing
20:04:25 <HiRE> hm so an efficiency question. I am writing a little mathematical software that will be processing around 64,000 samples per second (radio DSP). 
20:04:45 <HiRE> I want to calculate a running sample standard deviation and storing the running totals in a record seems to be a clean way to do it
20:05:08 <HiRE> however, if I just have a function that updates the record and returns a new one I'm going to smash the crud out of my heap - probably causing the GC to stop the world alot.
20:05:25 <HiRE> Is there a good efficient way to write and return the _same_ object?
20:06:49 <HiRE> pre-mature optimization is the root of all evil but this seems like an obvious place for easy improvement in my code.
20:06:57 <infinisil> HiRE: Fyi there's a way to implement a streaming standard deviation, constant memory
20:07:10 <Axman6> look at my foldl-statistics package
20:07:24 <Axman6> it implements it (and other stuff, I forget what)
20:07:47 <HiRE> Axman6, could you link it? 
20:07:48 <Axman6> it should be very low on allocation too, everything's unpacked
20:07:54 <Axman6> @hackage foldl-statistics
20:07:54 <lambdabot> http://hackage.haskell.org/package/foldl-statistics
20:07:56 <HiRE> infinisil, could you link the way to do that?
20:08:19 <Axman6> it's implemented in my package
20:08:36 <infinisil> HiRE: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm
20:08:56 <HiRE> oh cool Axman6 I didn't realize foldl had a way to be made in constant memory
20:09:14 <HiRE> Thank you infinisil!
20:09:30 <edwardk> the dangers of naive online std-dev is they usually have pretty terrible accuracy, because accumulating moments around zero is awful, so I hope you at  least use Kahan
20:09:42 <edwardk> ah, looks like Axman got it right.
20:09:45 <edwardk> Axman6++
20:10:18 <Axman6> <3
20:10:24 <Axman6> stolen code ftw
20:10:27 <edwardk> hah
20:10:39 <infinisil> Ah didn't know about Kahan
20:10:41 <infinisil> Neat
20:10:41 <edwardk> i have some that computes a similar batch of the first few moments
20:11:07 <edwardk> and then uses my compensated library instead of directly doing Kahan in a left fold
20:11:13 <edwardk> that way it can work in a monoidal setting better
20:12:29 <HiRE> to be honest despite having taken enough math to probably know about these things this is the first time I've stepped outside the matlab playground
20:12:30 * Axman6 was just reading http://www.johngustafson.net/pdfs/DebateTranscription.pdf
20:12:39 <HiRE> haskell seemed perfectly suited for a DSP task
20:12:46 <HiRE> and ive been wanting to learn it for a while
20:13:28 <Axman6> edwardk: I always wanted to generalise the compensated stuff, but couldn't figure out how to decide how many iterations needed to be run for each size of compensated 
20:13:52 <edwardk> infinisil: my code was an extension of Terriberry's IIRC
20:14:26 <edwardk> Axman6: the thing that killed compensated for me was that you need to tweak all the newton  raphson  stuff to do just that, and it was kinda messy
20:14:27 <edwardk> yeah
20:15:00 <edwardk> for basic ops its fine, its the Floating combinators that kill you
20:15:16 <infinisil> HiRE: I'm not sure it's suited for that very well, it's easy to have leaks and can be hard to make it performant
20:15:32 <infinisil> I recently used Haskell for something that needed to rust as fast as possible, and I kind of struggled because of this
20:15:48 <infinisil> If I knew Rust better I probably should've chosen that instead
20:15:52 <edwardk> i use haskell for all sorts of things that need to run as fast as possible. that is what LLVM is for
20:16:07 <Axman6> it feels like there should be a formula based on the size, which it should be able to unrol everything at compile time, as long as the size is available at compile time
20:16:12 <HiRE> It seems to do well on many performance benchmarks. What I like about it is the conciseness. It is easy to express operations on streams of data (such as radio signals) in a way that is very clean and easy.
20:16:30 <infinisil> Maybe I just need to up my performance game :)
20:16:34 <infinisil> "just"
20:16:37 <HiRE> its hard to quickly discern what a for loop is doing (I am a C programmer by trade)
20:17:29 <edwardk> HiRE: when i found haskell i had to suppress that side of my brain for a while, til my high level understanding of what the haskell _meant_ caught up with my low level understanding of what the C did.
20:17:48 <Axman6> HiRE: there's some cool signals processing stuff you can do with copilot, whic generates guaranteed constant time and memory C code
20:18:24 <HiRE> for sure. I am not expecting to write anything production quality. I am a ham operator and I got tired of using other people's software to look at satellites when I could use what I learned in school to do it myself :)
20:18:30 <infinisil> ?package copilot
20:18:30 <lambdabot> http://hackage.haskell.org/package/copilot
20:18:42 <HiRE> Axman6, I've heard a lot about copilot. I will have to take a look
20:18:54 <edwardk> HiRE: if it helps you do eventually get to become a whole human being once you emerge from the other side, its just useful to that fledgling haskell understanding to not bludgeon it with too much prior expertise until it is robust enough to have answers
20:19:02 <Axman6> not sure how active it is, but it's avery cool project nonetheless
20:19:14 <fog5> here; https://gist.github.com/fog-hs/c5ce3555142cac6e1d3b7e7c63c47e8e
20:19:52 <HiRE> edwardk, that's good advice. I only asked my question because knowing GC'd languages its easy to accidentally smash your heap on something simple like storing the running tallys for a standard deviation
20:21:22 <HiRE> since the sample size is fixed I probably wouldn't have been in too much trouble
20:21:32 <HiRE> since decoding in real time still would only be a 2-3 minute transmission
20:22:04 <HiRE> its good to know the haskell community is generous with their help though :)
20:22:17 <edwardk> HiRE: yeah. in the end i usually wind up doing everything directly in fairly haskell as a first pass. all lists and slow ass data structures. then i may go back through and do a pass using vectors and stream fusion, that'll usually  get me close  to maybe 2-5x slower than hand tuned c/c++ for most problems, failing that i'll go and write an edsl for describing my problem domain, write a hand compiler, leverage SIMD, GPU, other craziness 
20:22:17 <edwardk> and see how far the other side of naive c/c++ I can get for my particular problem domain. but  we're in  <1% of  my problems territory by that point.
20:22:22 <oats> edwardk: hey, this is the first time I've noticed you active in here. just want to take a second and thank you for your contributions to the haskell community. It's always fun to stumble across something you've helped out with (since I know the code will probably be high-quality (: ) and I thoroughly enjoy your recorded talks
20:22:56 <edwardk> oats: thanks! i've been a bit busy of late, so not as active on channel
20:39:37 <Bad_K4rMa> how do i get extra decimal precision? 
20:45:43 <oats> Bad_K4rMa: beyond a Double?
20:45:50 <iqubic> edwardk: Your libraries are awesome.
20:46:07 <oats> iqubic++
20:46:11 <oats> er, excuse me
20:46:15 <oats> succ iqubic
20:47:12 <iqubic> edwardk: I'm thinking I might use the Pointer type from Comonad-Extras to make a Game of Life thing.
20:47:14 <edwardk> i need to spend some time pushing out updates some time soon
20:47:25 <iqubic> https://hackage.haskell.org/package/comonad-extras-4.0/docs/Control-Comonad-Store-Pointer.html
20:47:40 <iqubic> https://hackage.haskell.org/package/comonad-extras-4.0
20:47:52 <edwardk> iqubic: did you see the automata articles i wrote a few years back?
20:47:59 <iqubic> And I have no idea what the Zipper module is supposed to be.
20:48:07 <iqubic> edwardk: I haven't seen those.
20:48:22 <iqubic> And that's the comonadic Zipper thing that I don't understand.
20:48:32 <iqubic> I know what a zipper is in general
20:48:35 <edwardk> https://www.schoolofhaskell.com/user/edwardk/cellular-automata  <- were more impressive when the site would live run the haskell code
20:49:09 <edwardk> so  that webserver contained in the first page could be run and you could just see the resulting svg inline
20:49:34 <iqubic> Ah. I see.
20:50:00 <iqubic> edwardk: Do you even remember what the Zipper thing does from comonad-extra?
20:50:03 <iqubic> https://hackage.haskell.org/package/comonad-extras-4.0/docs/Control-Comonad-Store-Zipper.html
20:50:29 <edwardk> part 1: 1d cellular automata -> SVG, part 2: is basically how to generate PNGs using a fancy choice of comonad for monoidal summaries, and part 3 was about  folding space in on itself
20:50:31 <edwardk> iqubic: sure
20:50:46 <edwardk> the idea is take a traversal, you  can get out a list  of its contents, right?
20:51:00 <iqubic> Sure. I understand that.
20:51:07 <iqubic> :t toList
20:51:09 <lambdabot> error:
20:51:09 <lambdabot>     Ambiguous occurrence ‘toList’
20:51:09 <lambdabot>     It could refer to either ‘F.toList’,
20:51:16 <iqubic> @undefine
20:51:16 <lambdabot> Undefined.
20:51:20 <iqubic> :t toList
20:51:22 <lambdabot> error:
20:51:22 <lambdabot>     Ambiguous occurrence ‘toList’
20:51:22 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
20:51:28 <edwardk> now walk the contents left, right, etc. basically turn the  container  you were given into an array of some length, such that you could package them back up in the  original container to get a new structure
20:51:39 <iqubic> toList :: Foldable t => t a -> [a]
20:51:53 <iqubic> I see.
20:52:08 <iqubic> How would one use that Zipper in actual code?
20:52:20 <edwardk> basically this is a version of the Pointer comonad  you like, paired up with a container of the right size to take those elements and package it back up
20:52:54 * hackage vformat 0.12.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.12.0.0 (gqk007)
20:53:03 <iqubic> Pointer only really works on Arrays.
20:53:26 <edwardk> http://hackage.haskell.org/package/zippers-0.3/docs/Control-Zipper.html is basically the same idea as this, generalized to let you walk up/down multiple  levels
20:53:29 <edwardk> and has a  bunch  of examples
20:53:50 <edwardk> fmap rezip $ zipper "hello" & within traverse <&> tug rightward <&> focus .~ 'u'    ===> "hullo"
20:54:20 <iqubic> What does tug do?
20:54:38 <edwardk> tries a possibly failing movement, staying still if it can't move the cursor
20:55:25 <iqubic> I see. How do you define what it means to move rightward for a particular type?
20:55:39 <edwardk> write any traversal
20:55:49 <edwardk> and left or right in the traversal's results is left or right
20:56:46 <iqubic> What are left and right in the context of a traversal?
20:57:15 <iqubic> Are you refering to this: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html#v:left
20:57:16 <edwardk> [a,b,c,d] -- if you traversed that, a is left of b
20:57:47 <iqubic> I see.
20:58:46 <edwardk> the zipper code 'zipper' gives you a structure that describes a 'path' of types down into some container, moving 'up' is closing a layer up behind you, going down, using 'within someTraversal' puts  the focus on the first element that would be returned by the traversal.
20:59:01 <edwardk> rezip seals the zipper back up and gives you the whole top level result
20:59:28 <edwardk> in the Zipper code in comonad-extras, you only have one 'layer'
20:59:48 <iqubic> Ah. I see.
20:59:53 <iqubic> Makes sense.
21:00:13 <edwardk> but with the code in zippers, you might have a pair that looks like (String,Word32) , then go down into _2, then go down into the bits of the Word32, walk right a few times and set a given bit, then seal it up behind you, etc.
21:00:30 <iqubic> Sure. I can so how that would work.
21:00:48 <iqubic> I still think this might be easier to do with just vanilla lenses.
21:01:32 <edwardk> these use lenses/traversals. consider what happens if you need to do lots of stuff down  5 layers deep in a structure and don't want to keep unsealing/resealing the thing behind  you
21:01:54 <edwardk> or you want to map over the contents at one level a bunch of times, but  only want to pass in one traversal, and will only 'rezip' at the end
21:02:06 <edwardk> that is the sort of thing this is good at
21:02:39 <iqubic> Well, you could use something like magnify or zoom
21:02:42 <edwardk> yes
21:03:07 <edwardk> that zippers code was originally packaged as part of the lens api, at the same time as zoom/magnify
21:03:40 <edwardk> i pulled it out because it was  iterating faster than the rest of the lens code, so it was an often-broken part of the API, but then pulling it out  cost everyone interest in coding with them this way at all.
21:04:17 <iqubic> Because you should be able to use magnify with ((->) a) as the MonadReader in the same way we do with view.
21:05:04 <glguy> The zippers package also wasn't great at being a zipper for recursive data strutures as the depth you'd traveled would show up in the type
21:05:24 <glguy> and so you could only do simple things without going into type astronautics
21:05:41 <edwardk> also, the zippers  code moves the focus left/right one entry at a time in O(1) for each step as opposed to say, rebuilding the list and keeping track of a position and going all the way back into it when you want to look at the next entry.
21:06:02 <edwardk> and yeah, the power of type changing zippers played poorly with recursive data types
21:06:21 <iqubic> Yeah, you can use magnify with ((->) a). That's the same as just using views.
21:08:00 <iqubic> Also, I recently found out about indexed traversals and used it to write this function: "createGridWith :: (a -> b) -> [[a]] -> Map (V2 Int) b"
21:08:10 <edwardk> iqubic: the issue is more like walking down  into some treelike structure, then doing a  bunch of local rewrites while you have  the surrounding context flayed open. zippers are kinda useful for that sort of thing. zooming is similar in flavor, but doen't give you the ability to move 'left' 3 characters in a string as a sequence of instructions. if your control flow doesn't follow the recursive nature of the data type, zoom is a bad fit
21:09:06 <iqubic> Yes. That is a very good argument in favor of zippers.
21:09:27 <iqubic> Thanks for opening my eyes to this power.
21:10:31 <iqubic> I've looked at this module before, but never really understood it until you shared that example code with me. Even though I knew what a Zipper was before, I never understood that module until today.
21:12:26 <edwardk> :t \f -> Data.Map.Lens.toMapOf (itraversed<.>itraversed.to f)
21:12:28 <lambdabot> (Ord j, Ord i, TraversableWithIndex i t1, TraversableWithIndex j t2) => (b -> a) -> t1 (t2 b) -> M.Map (i, j) a
21:12:34 <edwardk> iqubic: like that?
21:12:48 <edwardk> oh you want V2, easy enough to change i guess
21:13:02 <iqubic> (itraversed <.> itraversed . to f & reindexed (uncurry V2 . swap))
21:13:05 <iqubic> I did that.
21:13:22 <iqubic> -- First traversal adds y coord. Second traversal adds x coord
21:13:26 <iqubic> -- Hence we need a swap before creating the V2
21:13:55 <edwardk> sure, all of that is up to user interpretation
21:14:01 <Axman6> needs more flip
21:14:11 <iqubic> Axman6: Where would I use flip?
21:14:30 <edwardk> rather than swap, just uncurry (flip V2) i presume
21:14:36 <iqubic> Ah. I see.
21:15:39 <iqubic> Is that more efficient, or just more stylish?
21:16:03 <edwardk> mildly more efficient unless the optimizer goes to town?
21:16:27 <edwardk> because naively the swap is going to make a temp tuple and then uncurry will immediately destroy it
21:16:39 <Axman6> hopefully they compile to the same code
21:16:44 <edwardk> so you'd be relying on code transformation eliminating the temporary
21:17:05 <edwardk> so at -O2 (probably -O1) they should be the same
21:17:17 <edwardk> but unoptimized, slight edge to axman
21:30:31 <iqubic> I'm so glad that the Linear package provides lenses into the fields of a V1-V4.
21:30:43 <iqubic> And I'm also glad that those are repersentable.
21:31:15 <iqubic> I have used that Repersentable instance on a number of instances.
21:33:17 <Axman6> linear is literally the reason lens exists iqubic
21:34:04 <iqubic> Wait? What? Why?
21:34:49 <Axman6> edwardk will  correct me if I;m wrong, but he wanted to be able to access the x coordinate of arbitrary vectore generically
21:35:08 <iqubic> edwardk: Why does Lens use the Van Larhoven repersentation instead of the Profunctor repersentation for Optics?
21:35:42 <iqubic> *Van Laarhoven
21:39:31 <jackdk> to unify with `traverse`, I think?
21:39:37 <edwardk> iqubic: because it enables you to write lenses and traversals without incurring a third party library dependency, which means people can and will supply lenses and traversals in libraries that would never consider picking up an extra dependency
21:39:43 <edwardk> and yeah, traverse already exists
21:40:36 <edwardk> also, it is more convenient and less verbose to write traversals with code like `both f (a,b) = (,) <$> f a <*> f b`  -- than to construct the equivalent in profunctor optics
21:40:51 <edwardk> (well, that case may be the only case that it isn't smaller) =)
21:43:21 <iqubic> edwardk: Also, in your cellular automaton article on School of Haskell, you wrote the following: "An interesting exercise for the advanced Haskeller is to flip the definition of experiment and take that as the definition for Store." I actually have an implementation of that laying around. http://dpaste.com/2803H0Y
21:43:50 <iqubic> This also has a little bit of some lens-y stuff too.
21:44:06 <iqubic> But I wrote that code about 2 months ago as a learning experience.
21:45:32 <edwardk> iqubic: yeah i wrote that article around the time i'd shipped the lensy Context type
21:46:00 <iqubic> And that code actually works.
21:46:49 <iqubic> Down near the bottom you can see the results of using over, set, and view on the V3 type.
21:47:01 <iqubic> lens :: (s -> a) -> (s -> a -> s) -> Lens' s a
21:47:05 <iqubic> lens getter setter s = Pretext (\f -> setter s <$> f (getter s))
21:47:19 <iqubic> That was a large pain to write.
21:48:20 <iqubic> Also, I have this statement written in the comments: "Lenses are the coalgebra of the costate comonad" Which I actually fully understand now.
21:50:06 <iqubic> lensToTraversal :: Lens' s a -> Traversal' s a
21:50:21 <iqubic> lensToTraversal l s = case l s of Pretext g -> Bazaar g
21:51:18 <iqubic> I know the lens library doesn't have a function like that, but I know how the lens library lets you use a Lens anywhere a Traversal is expected.
21:51:30 <iqubic> That coercion function is weird and odd.
21:51:34 <edwardk> it does have such a function,  we call it 'id' =)
21:52:03 <iqubic> Oh?
21:52:15 <edwardk> :t _2
21:52:17 <lambdabot> (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
21:52:18 <edwardk> :t id _2
21:52:19 <lambdabot> (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
21:52:21 <edwardk> see =)
21:52:46 <iqubic> Well, no. Not exactly.
21:57:32 <jackdk> % :i Lens
21:57:33 <yahb> jackdk: type role ReifiedLens representational nominal representational nominal; newtype ReifiedLens s t a b = Lens {...}; -- Defined in `Control.Lens.Reified'; type Lens s t a b = forall (f :: * -> *). Functor f => (a -> f b) -> s -> f t -- Defined in `Control.Lens.Type'
21:57:43 <iqubic> Well, I'm trying to recreate a small part of the lens library to see what makes it work. Using newtypes here doesn't actually work. See this paste for the reasons. http://dpaste.com/1VWT44S
21:57:44 <iqubic> Now I know why Lenses and Traversals use type synonyms
21:58:09 <iqubic> with type synonyms, using id would just work there.
21:59:40 <iqubic> But the internal modules of Lens do actually use pretext and bazaar. Clearly not in this way.
22:00:10 <habbah> I want to ask a few wrong questions (because I haven't yet thought of the appropriate questions) in hopes of gathering the appropriate information. Are refinement types necessary if you have property based testing? What do refinement types get you that you can't get in property based testing?
22:00:42 <iqubic> But I'm not planning on recreating all of Lens. I just want to have some basic intuition for how the library works.
22:00:50 <iqubic> :t view
22:00:52 <lambdabot> MonadReader s m => Getting a s a -> m a
22:00:56 <suzu> artyom has a great discourse on it
22:01:01 <iqubic> :t over
22:01:02 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
22:01:11 <suzu> https://artyom.me/lens-over-tea-1
22:01:30 <mud> habbah: Without being an expert really, what you usually get from "type" anything that you don't get from testing is it's statically enforced for you
22:03:41 <iqubic> :t toListOf
22:03:42 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
22:03:51 <iqubic> What the heck is the point of Endo there?
22:04:08 <iqubic> :t (^?)
22:04:09 <lambdabot> s -> Getting (First a) s a -> Maybe a
22:04:15 <iqubic> And why do you need first there?
22:04:37 <habbah> for some reason, I've been thinking the predicates for liquid haskell were lifted at runtime
22:05:01 <habbah> if that's the case, then why not simply write property tests which fail
22:05:21 <habbah> ..if your predicates don't hold
22:05:32 <habbah> s/predicates/properties
22:07:37 <jle`> iqubic: try implementing it
22:07:41 <jle`> and you will find your answer :)
22:07:51 <iqubic> try implementing what? toListOf?
22:08:32 <iqubic> Well, I looked at the source.
22:08:33 <iqubic> toListOf l = foldrOf l (:) []
22:09:07 <iqubic> foldrOf l f z = flip appEndo z . foldMapOf l (Endo #. f)
22:09:09 <jle`> implementing the thing you are trying to figure out
22:09:16 <iqubic> Not sure why Endo is needed there.
22:09:20 <jle`> so if you want to know why (^?) uses First, look at how (^?) is implemented
22:09:31 <jle`> or, i mean, try implementing (^?)
22:09:40 <jle`> if you want to know why toListOf needs Endo, try implementing Endo
22:09:44 <jle`> don't look at the implementation
22:09:47 <jle`> try to implement it yourself :)
22:10:03 <iqubic> Oh. I see why (^?) needs First, just from looking at the implementation.
22:10:05 <jle`> we could give you an answer but it definitely wouldn't stick as much as if you figured it out yourself by implementing it
22:13:39 <koz_> Ah, I see iqubic is busy discovering something I went ga-ga over in a (not so) recent blog post.
22:17:03 <iqubic> koz_: do you have a link to that blog post?
22:17:37 <iqubic> foldMapOf :: Getting r s a -> (a -> r) -> s -> r
22:17:40 <iqubic> foldMapOf l f = getConst #. l (Const #. f)
22:17:57 <iqubic> How? Just how does that work?
22:18:14 <koz_> iqubic: That would be cheating.
22:18:25 <koz_> :P
22:18:34 <koz_> Don't wanna undercut jle`'s teaching moment.
22:20:17 <Axman6> iqubic: hint: look at the Applicative instance for Const
22:20:21 <iqubic> I just finished looking figuring out how foldr can be written with foldmap. The trick is that if you partially apply (a -> b -> b) then you get (b -> b)
22:21:37 <iqubic> Axman6: Where is the applicative instance for Const being used?
22:22:10 <Axman6> what's the definition of Getting? 
22:22:34 <iqubic> type Getting r s a = (a -> Const r a) -> s -> Const r s
22:22:48 <iqubic> No applicative there.
22:23:30 <jle`> Const is there
22:24:04 <jle`> and the Applicative instance is used in the fold
22:24:16 <iqubic> In which fold?
22:24:19 <jle`> at least, for toListOf and foldrOf
22:24:21 <jle`> that's the 'l'
22:25:00 <jle`> note that foldMapOf doesn't use the Applicative instance, and so it just needs a Getting
22:25:15 <iqubic> Right.
22:25:15 <jle`> Axman6 was probably referring to your earlier stuff with toListOf/foldrOf/(^?)/etc.
22:25:15 <Axman6> remember that _the getter_ can choose how it uses the Const, so if it actually happens to be a Traversal, then it might use the Applicative instance for Const
22:25:26 <iqubic> Ah. I see.
22:26:14 <iqubic> https://blog.jle.im/entry/const-applicative-and-monoids.html
22:26:33 <iqubic> Time to read this, and see how the Const Applicative works.
22:27:46 <iqubic> In fact, sometimes I like to refer to `Const w a` as “an `Either w a` with only `Left`, no `Right`”.
22:27:53 <iqubic> Good writting there jle`
22:28:18 <jle`> thanks :)
22:31:37 <iqubic> Wait... The Const Applicative is very very similar to a Monoid.
22:31:46 <iqubic> Why not just use a Monoid instead?
22:33:04 <Axman6> think about what the first type parameter to Const is doing, and what the second one is doing
22:36:32 <iqubic> Well, I'm not sure what the first type parameter is doing, but I know the second one is a phantom type and literally doing nothing at all.
22:44:22 <jle`> iqubic: you use Const m used as an Applicative is like a Monoid
22:44:33 <jle`> iqubic: you use Const m when you are using an Applicative-polymorphic function
22:44:43 <jle`> like something written Applicative f => ...
22:44:53 <jle`> the whole point is to deal with polymorphism and abstractions
22:45:05 <jle`> think of it as a newtype wrapper to give the right functionality
22:45:29 <jle`> you would of course never write Const [1,2,3] <*> Const [4,5,6] directly, to get [1,2,3,4,6,7]
22:45:32 <jle`> * [1,2,3,4,5,6]
22:45:39 <jle`> you would just write [1,2,3] ++ [4,5,6]
22:45:50 <jle`> the only reason you would use Const is if you're leveraging a pre-written function using Applicative
22:46:05 <jle`> same for Sum/Product --- you would never directly write Sum 4 <> Sum 5 to get Sum 9
22:46:07 <jle`> you would just write 4 + 5
22:46:21 <jle`> the only reason you would use Sum ever is to leverage a pre-written function that uses Monoid
22:46:31 <jle`> like, say, foldMap or Writer functions
22:58:14 <hololeap> i have some code that uses Chan, but i'm curious about STM. my questions are: 1) would switching to TChan improve anything with this particular code 2) how would i do it
22:58:16 <hololeap> https://gist.github.com/0fc5faeae487102cabfac9b5973ca4d8
22:59:46 <erikd> hololeap: i have always chosen TChan over Chan due to "The channels are implemented with MVars and therefore inherit all the caveats that apply to MVars (possibility of races, deadlocks etc)."
22:59:59 <erikd> i take that kind of warning seriously :)
23:00:22 <hololeap> sure, but in this case, each Chan has only one producer and one consumer
23:02:24 * hackage vformat-time 0.1.0.0 - Extend vformat to time datatypes  https://hackage.haskell.org/package/vformat-time-0.1.0.0 (gqk007)
23:07:54 <erikd> hololeap: sure, for now there is only one of each, but if this is a work project, what happens in 3 years, after you have left the company and someone else is maintaining that code?
23:09:13 <iqubic> koz_: This was written by you, right? https://retro-freedom.nz/haskell-magic-from-semigroup-to-foldable.html
23:10:13 <iqubic> My search term to find that was "koz foldmap" and it was the first result.
23:14:04 <hololeap> i get the philosophy behind "always use STM", but right now i'm trying to learn if it would benefit this particular code
23:14:37 <koz_> iqubic: Yep.
23:15:38 <hololeap> also i'm really unfamiliar with it and i don't understand how i could plug it in to this code
23:16:40 <dmwit> I don't think that code would benefit much.
23:16:44 <dmwit> But it would be easy to slot in.
23:17:08 <dmwit> Just toss an `atomically` around each call to a `Chan` function.
23:17:28 <dmwit> TChan will shine more when you want to have complicated transactions that handle multiple channels.
23:18:02 <dmwit> For example, if you wanted to create a thread that would either read from two channels or none, that would be easy with TChan and basically impossible with Chan.
23:19:27 <hololeap> the default newTChan creates it in the STM monad, but in this code would i want to use newTChanIO?
23:20:18 <hololeap> i'm not really sure i understand what atomically means and if you can take a TChan out of STM, pass it around in IO, pass it back into atomically, and expect it to still work
23:21:16 <hololeap> atomically just means that the inner STM can only be accessed by one thread at a time?
23:22:06 <dmwit> no
23:22:42 <dmwit> atomically means that from the perspective of every other thread, all of the things in the given STM action happen at once, or none of them happen at all.
23:23:19 <dmwit> Yes, you can take a TChan out of STM, pass it around in IO, pass it back into atomically, and expect that to work.
23:24:06 <dmwit> For your case, the choice between newTChan+atomically or newTChanIO is immaterial.
23:25:12 <dmwit> newTChanIO exists to support a workflow that I do not endorse and which involves unsafePerformIO. You can pretend it doesn't exist and you won't miss out on any important aspect of the library.
23:26:22 <hololeap> i'm having a hard time seeing when you would want to go with newTChan+atomically over newTChanIO. it seems like the only useful thing to do with a TChan is create it and then pass it to your threads, which are run in IO
23:28:49 <dmwit> I dunno. I can't invent a crisp example off the top of my head. But I could imagine that somebody wanted to, say, only create a new TChan if some TVar had a special value in it or something.
23:29:20 <hololeap> that's actually a pretty good example
23:29:22 <dmwit> And, say, to swap the TVar to some other special value at the same time to notify somebody else that it had happened. Or something.
23:31:25 <hololeap> well, i can't say i understand the inner workings of STM yet, but i do feel more confident using it. so thanks!
23:31:30 <iqubic> jle`: Have you finished recording all of your thoughts from the 2019 Advent Of Code?
23:33:54 <hololeap> dmwit: oh... one last question; would i benefit from using newBroadcastTChanIO here instead of newTChanIO?
23:34:48 <jle`> iqubic: i have not
23:37:17 <dmwit> hololeap: Almost certainly not.
23:37:29 <mniip> is it possible to tell ghci to execute a command before dropping to a prompt?
23:37:31 <mniip> from the commandline
23:37:55 <MarcelineVQ> mniip: .ghci files execute befire the prompt I think
23:38:12 <mniip> yeah but -ghci-init replaces the init file
23:39:06 <dmwit> hololeap: But, like... you can just read the source and see the difference and decide for yourself.
23:39:16 <dmwit> The whole module can be digested in one sitting.
23:39:57 <MarcelineVQ> mniip: init?
23:40:19 <MarcelineVQ> *init what is that?
23:40:24 <mniip> sorry
23:40:28 <mniip> -ghci-script
23:40:52 <MarcelineVQ> you can give more than one script fwiw, appearantly
23:41:49 <hololeap> alrighty. thanks again!
23:42:00 <MarcelineVQ> not that creating a dummy file just to pass a command is much fun
23:42:44 <hololeap> how do i get cabal to look for dependencies from local source trees?
23:43:10 <dmwit> hololeap: Make a cabal.project file.
23:43:24 <hololeap> right
23:44:02 <mniip> alright that works tbh
23:44:18 <mniip> I only need to create the file once
23:45:36 <MarcelineVQ> .ghci files can also include a  :script foo  line to call up other .ghci
23:54:30 <iqubic> jle`: I just realized that you could very easily use edwardk's machines library for 2017 Day 25.
23:54:48 <iqubic> From AoC
23:55:59 <rsoeldner> Does ghcide work with `cabal v2-*`, looks like it cant find deps ?
23:57:21 <hololeap> do i use extra-lib-dirs?
23:59:08 <yushyin> rsoeldner: I've the same issue and not yet solved it, https://paste.xinu.at/m-Reav/#n-XH4rGR-46
