00:00:04 <nshepperd2> yeah, you can make them at runtime hololeap
00:00:12 <dminuoso_> alc: `1 : []` is the same as [1]
00:00:19 <dminuoso_> alc: Or more generally, `a : []` is the same as [a]`
00:00:27 <alc> > [1,2] ! 0
00:00:29 <lambdabot>  error:
00:00:29 <lambdabot>      • Couldn't match expected type ‘Array Integer e’
00:00:30 <lambdabot>                    with actual type ‘[Integer]’
00:00:58 <hololeap> nshepperd2: can you make a KnownNat at runtime?
00:01:02 <alc> dminuoso_: then why 0 not start with []...
00:01:23 <dminuoso_> % [[]] ! 0
00:01:23 <yahb> dminuoso_: ; <interactive>:162:1: error:; * Couldn't match expected type `Array Integer e' with actual type `[[a0]]'; * In the first argument of `(!)', namely `[[]]'; In the expression: [[]] ! 0; In an equation for `it': it = [[]] ! 0; * Relevant bindings include it :: e (bound at <interactive>:162:1)
00:01:25 <dminuoso_> Uh
00:01:25 <day> how do i properly handle if situations where i only need a 'then' but not a 'else? e.g. if fileExists x then renameFile x x++".bak"
00:01:37 <nshepperd2> hololeap: yeah
00:01:57 <iqubic> % [[]] !! 0
00:01:57 <yahb> iqubic: []
00:02:04 <nshepperd2> withSized is the relevant function for vectors
00:02:06 <hololeap> huh, i guess i don't understand what KnownNat is supposed to mean semantically then
00:02:11 <dminuoso_> Oh heh. :)
00:02:11 <merijn> day: You probably want "when"
00:02:13 <merijn> :t when
00:02:15 <lambdabot> Applicative f => Bool -> f () -> f ()
00:02:21 <iqubic> dminuoso_: Base uses !! for indexing lists, as opposed to container's !
00:02:24 <alc> oh, heh. :)
00:02:26 <nshepperd2> for KnownNat in general you use someNatVal
00:02:45 <dminuoso_> iqubic: Heh, I dont think I've used (!!) at all beyond some beginner excercises when I started with haskell.
00:02:53 <hololeap> also i thought all the type info was lost after compile time
00:03:04 <hololeap> so are Nats special?
00:03:05 <dminuoso_> hololeap: Not necessarily
00:03:26 <iqubic> dminuoso_: I've used it quite a bit in Advent Of Code.
00:03:51 <nshepperd2> KnownNat n means "the value of n is known in this context (at runtime)"
00:03:54 <merijn> hololeap: Type info is lost, but typeclasses can reify compile time info at runtime
00:03:55 <alc> 6 kyu excercises on codewars is difficult to me now, I think I can't do 5 kyu
00:04:37 <hololeap> oh snap
00:04:39 <nshepperd2> a KnownNat dictionary is just an Integer inside
00:04:46 <hololeap> that's really good to know
00:05:07 <dminuoso_> hololeap: `KnownNat n` is a constraint where, if you have evidence at runtime, you can discover what n is
00:05:22 <dminuoso_> hololeap: You can either produce that value for n at compile time or at runtime.
00:05:30 <merijn> hololeap: I mean, consider "foo x y = x == y" you need to somehow (at runtime!) access the relevant implementation of (==)
00:05:49 <dminuoso_> hololeap: c.f. `SomeNat : exists n. KnownNat n *> Proxy n`
00:05:52 <hololeap> so is this also what singletons does?
00:06:18 <dminuoso_> (I deliberately used : to signal that this is a pseudo type signature since we dont have exists or *>)
00:07:05 <hololeap> merijn: i figured it baked that logic into the binary
00:07:34 <merijn> hololeap: Well yes, the logic is, but it still requires "runtime access to something"
00:08:00 <hololeap> i mean, i figured the whole concept of typeclasses was gone once the binary was compiled
00:08:04 <merijn> hololeap: If foo is monomorphic (i.e. Int -> Int -> Bool) then you can just inline the Int instance, but if it's polymorphic you can't
00:08:10 <merijn> hololeap: Not really
00:08:25 <dminuoso_> hololeap: Consider libraries exposing polymorphic functions.
00:08:38 <jle`> hololeap: are you familiar with the Typeable class?
00:08:39 <day> merijn: thanks
00:08:43 <merijn> hololeap: For monomorphic usage you can effectively inline everything and do it statically, yes
00:08:57 <dminuoso_> hololeap: If my library exposes `Functor f => (a -> b) -> f a -> f b`, then GHC will compile it in such a way, that it is parametrized at runtime over a dictionary
00:09:03 <merijn> hololeap: Which is why they're often more efficient than vtables in C++, but not all cases are like that
00:09:04 <jle`> KnownNat is esentially just Typeable for Nat
00:09:11 <day> :t if
00:09:13 <lambdabot> error:
00:09:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
00:09:15 <dminuoso_> hololeap: That dictionary has to be provided at *runtime*
00:09:33 <dminuoso_> (Unless GHC has enough information via interface files to inline and specialize)
00:09:37 <dminuoso_> (But lets ignore that)
00:09:38 <merijn> day: if/then/else is not a function, it's an expression
00:09:45 <jle`> in fact we don't even need KnownNat technically if Typeable was made a little beefier
00:10:14 <merijn> day: (You can think of if/then/else as the the ternary operator in C and friends "foo ? bar : baz" -> "if foo then bar else baz"
00:10:27 <jle`> hm actually checking the docs, it looks like typeable is already sufficiently beefy
00:10:28 <merijn> day: With the ternary operator you also can't skip the else
00:10:32 <jle`> KnownNat is useless! D:
00:10:48 <jle`> well, it's convenient, at least, heh
00:11:10 <day> merijn: yes that is how i memorized it :)
00:11:31 <jle`> but yeah if you understand Typeable then you should be able to understand KnownNat
00:11:41 <jle`> s/understand/grok
00:11:57 <hololeap> this is still confusing to me, because it seems like if none of the types are ambiguous it would be able to pretend that everything is monomorphic
00:12:09 <merijn> day: If you consider the type of if/then/else it makes sense too "if foo then 3 else 4" has type Int, but what type would "if foo then 3" have?
00:12:27 <merijn> hololeap: Ambiguity isn't relevant
00:12:54 <merijn> hololeap: Those functions can be used with many different argument types at runtime and you can statically determine which
00:12:56 <hololeap> sorry i meant if every type is concrete
00:13:09 <merijn> "concrete" is ill defined :p
00:13:11 <jle`> what does concrete mean?
00:13:16 <merijn> jle`: Jinx!
00:13:21 <jle`> or, what are you trying to say when you say 'concrete'
00:13:26 <dminuoso_> hololeap: https://theconstructor.org/wp-content/uploads/2014/05/self-compacting-concrete.jpg ?
00:13:31 <merijn> Also: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
00:13:44 <jle`> if you are trying to say 'monomorphic', then 'if types are all monomorphic then we can pretend everything is monomorphic' is vacuously true
00:14:03 <hololeap> when main is compiled, it has to know what every type is. it can't have any hanging type variables
00:14:12 <dminuoso_> hololeap: Consider this:
00:14:16 <merijn> hololeap: One function may be called on many different types
00:14:22 <dminuoso_> hololeap: My library exposes `f :: Functor f => (a -> b) -> f a -> f b`
00:14:28 <dminuoso_> hololeap: I compile it, and hand you the library in binary form.
00:15:08 <jle`> hololeap: also, remember that separate compilation is useful. it's useful to compile a library first and then compile the executable later
00:15:09 <merijn> hololeap: Consider: "do { line <- getLine; if line == "foo" then bar 'a' else bar True }" <- you cannot statically know which instance of bar will be used
00:15:17 <dminuoso_> hololeap: Now my library must be able to handle you calling `f` with any choice of f where `Functor f` holds. The instance might not even be known to me while I compiled my library
00:15:35 <dminuoso_> hololeap: For example, you might have defined it in *your* program. My library cant know this.
00:15:55 <hololeap> ok i can see the point for libraries
00:16:09 <merijn> The library argument is a red herring
00:16:22 <merijn> The real reason is that my case can be generalised to 20 different types, for example
00:16:30 <merijn> Or 100, or whatever
00:16:53 <nshepperd2> you can't just specialise every polymorphic function for each choice of type variables because 1. separate compilation 2. irregular recursion 3. it's bad for code size
00:16:59 <hololeap> ok i see your point
00:17:07 <dminuoso_> The library argument shows that it's completely unknowable, whereas your example is just a matter of "maybe it specializes for each invocation"
00:17:13 <merijn> IFF you do whole program optimisation you can monomorphise everything always, but we don't because 1) it's super slow to compile, 2) it bloats your code to insane levels
00:17:36 <merijn> dminuoso_: It's "completely unknownable assuming our current compilation approach which is not at all required"
00:17:53 <dminuoso_> hololeap: Another relevant part where type knowledge remains alive is GADTs.
00:18:07 <merijn> dminuoso_: The library argument is a red herring because you weasel the *real* reason behind (coincidental) artifacts of how we currently handle compiling libraries
00:18:23 <nshepperd2> merijn you can't even then because of irregular recursion i think
00:18:34 <merijn> nshepperd2: Yeah, I wasn't quite sure of that case
00:19:37 <Lears> % if_ True then_ 'a' else_ 'b'
00:19:37 <yahb> Lears: 'a'
00:19:41 <Lears> % :t if_ True then_ 'a'
00:19:41 <yahb> Lears: Else -> Char -> Char
00:19:43 <hololeap> dminuoso_: that also makes sense
00:19:48 <Lears> Totally works.
00:19:53 <hololeap> and your points too, merijn 
00:20:36 <dminuoso_> % :t if_
00:20:36 <yahb> dminuoso_: Bool -> Then -> p -> Else -> p -> p
00:21:00 <jle`> 'cute'
00:21:09 <alc> to check a number if it's prime or not, use mod or div? or other math functions?
00:21:37 <hololeap> so what are the riciest bloatiest options i can pass to GHC? ;)
00:21:55 <dminuoso_> alc: You will have to do it yourself using whatever primality test you like.
00:22:07 <dminuoso_> hololeap: INLINE everything.
00:22:24 <merijn> hololeap: See the GHC user guide on "Sooner, faster, smaller, thriftier"
00:22:26 <dminuoso_> hololeap: megaparsec does it, it can blow up compilation times to hilarious amounts
00:22:54 <hololeap> i want -O3 -funroll-all-loops
00:23:01 <nshepperd2> silly :: Show a => Int -> a -> String; silly 0 x = show x; silly n x = silly (n-1) [x]
00:23:24 <nshepperd2> ^^ constructs arbitrarily deep Show instances
00:23:31 <iqubic> What the hell?
00:23:35 <dminuoso_> jle`: re Typeable and KnownNat, Do you have an example of using Typeable instead?
00:24:32 <hololeap> nshepperd2: good example
00:25:31 <merijn> hololeap: The way GHC (currently) compiles this is by turning the typeclass constraint into an extra argument which gets a record containing each function in the typeclass, so they can be passed in it runtime
00:25:37 <nshepperd2> what the hell is right
00:25:45 <jle`> dminuoso_: i'm saying we could have hijacked Typeable to implement all the reflection/reification in GHC.TypeLits instead of making a new typeclass
00:25:57 <merijn> hololeap: Of course, in the trivial monomorphic case you can trivially optimise this extra dictionary argument away and directly call the relevant code
00:26:39 <jle`> although! looking deeper, SomeTypeRep is kind of silly
00:26:45 <jle`> it should be parameterized by the kind ...
00:26:47 <merijn> hololeap: And GHC almost certainly will, which is why monomorphic usage of typeclass functions is effectively no overhead
00:26:53 * hackage git-mediate 1.0.6 - Tool to help resolving git conflicts  https://hackage.haskell.org/package/git-mediate-1.0.6 (EyalLotem)
00:26:53 <jle`> why is it not ...
00:27:01 <dminuoso_> hololeap: And in case of libraries, if you mark a function as INLINABLE its definition will be exported in the interface files, such that you can still specialize at call sites.
00:27:17 <dminuoso_> (or rather GHC can)
00:27:34 <hololeap> this is some interesting stuff
00:27:52 <jle`> dminuoso_: okay, looking deeper into it, Typeable as it is in Type.Reflection is not really good enough yet
00:28:25 <jle`> but it didn't have to be this way ...
00:28:49 <jle`> it makes me sad
00:29:05 <nshepperd2> natVal = read . show . typeRep :p
00:29:29 <jle`> hah
00:30:10 <jle`> yeah the reflection part i think isn't too bad to implement on top of Typeable/typeRep
00:30:47 <jle`> it's the reflection part that you probably can't do without some unsafe stuff
00:31:04 <jle`> unsafe as in magic unsafeCoerce dictionary stuff
00:31:45 <merijn> s/unsafe/fun
00:31:56 <merijn> We shoulda called unsafeCoerce funCoerce :p
00:32:08 <jle`> unsafeCoerce? more like funSafeCoerce
00:32:34 <jle`> on hindsight, who named it 'coerce' and not 'funsafeCoerce'
00:37:44 <jle`> yeah it's kind of a shame that Type.Reflection doesn't offer enough for... actual reflection
00:37:53 <jle`> er
00:38:00 <jle`> no, it offers enough for reflection, but not reification
00:38:11 <jle`> i guess they must have thought it would have belonged in Type.Reification
00:38:21 <jle`> so i guess we can't replace KnownNat with Typeable just yet.
00:40:53 * hackage git-mediate 1.0.7 - Tool to help resolving git conflicts  https://hackage.haskell.org/package/git-mediate-1.0.7 (EyalLotem)
01:12:52 <iqubic> Well, I feel much more versed in representable functors and adjoints than I was 4 hours ago.
01:15:14 <iqubic> https://bartoszmilewski.com/2015/07/29/representable-functors/
01:15:19 <iqubic> https://bartoszmilewski.com/2016/04/18/adjunctions/
01:15:31 <iqubic> I just finished reading those posts. Super super cool
01:16:24 <LarryTheCow> Bartosz is super super cool
01:17:03 <iqubic> Actually, I'll correct myself. I spent 5 hours reading those two sources.
01:18:29 <iqubic> I'm not sure I see how adjoints are useful in Haskell programming, but I totally understand how representable functors are.
01:29:23 * hackage conduino 0.2.1.0 - Lightweight composable continuation-based stream processors  https://hackage.haskell.org/package/conduino-0.2.1.0 (jle)
01:29:47 <iqubic> jle`: Nice.
01:36:00 <dminuoso_> iqubic: I think adjunctions are more easily approachable if you start with a motivation example like an optimization problem.
01:37:43 <iqubic> What sort of optimization problem are we talking about here?
01:40:16 <dminuoso_> iqubic: So in some sense we can think of universal constructions as the most efficient solution to a given problem.
01:40:27 <iqubic> Ah. I see. Makes sense.
01:40:27 <dminuoso_> adjoint functors are special cases of that
01:40:44 <iqubic> I suppose so.
01:42:39 <cdunklau> map (uncurry step) (zip (repeat controller) moves)  --i think i need more coffee
01:43:07 <iqubic> I thought you were talking about a sort of mathematical optimization as in "Here's some constraints on these 4 variables. Find the largest product those 4 variables can have".
01:43:07 <dminuoso_> cdunklau: Maybe cofree helps?
01:43:09 <cdunklau> like, a lot more :(
01:43:13 <dminuoso_> cdunklau: *chuckles*
01:43:30 <dminuoso_> iqubic: Like anything in category theory, it's with a bit more handwaving.
01:43:39 <cdunklau> dminuoso_: this was entirely reasonable 10 minutes ago, then i looked at it again and was like... wat
01:43:43 <iqubic> Yeah. I  know.
01:44:17 <dminuoso_> iqubic: https://www.youtube.com/watch?v=TNtntlVo4LY
01:44:21 <cdunklau> dminuoso_: i think i'm still thinking too much in python :/
01:44:23 <iqubic> dminuoso_: I love how Bartosz manages to show how Representable Functors can be highly useful in Haskel
01:44:24 <dminuoso_> iqubic: This might be instructive, it contains many examples.
01:44:50 <iqubic> do I really want to watch that at 2AM?
01:45:06 <iqubic> I think I'll bookmark it and watch it later. But thanks for the link.
01:45:12 <dminuoso_> cdunklau: `step <$> pure controller <*> ZipList moves` ?
01:45:28 <dminuoso_> Or haha
01:45:31 <dminuoso_> I see what you mean
01:45:35 <dminuoso_> Not bad! :)
01:45:42 <dminuoso_> Caught me by surprise, even.
01:46:05 <cdunklau> yeah... map (step controller) moves  is just not obvious at all right :/
01:46:21 * cdunklau sighs
01:46:32 <iqubic> dminuoso_: You'd probably want to unwrap the new type at the end of that computation, but that seems to work.
01:49:12 <jle`> cdunklau: map uncurry and zip is zipWith
01:49:35 <cdunklau> dminuoso_: the best part is i wrote `step :: RemoteControl -> MovementCommand -> ...` in that order _specifically_ so i would be able to do `map (step controller) ...`
01:49:40 <cdunklau> and entirely forgot about it :D
01:49:41 <jle`> zipWith step (repeat controller) moves. but also since you're using repeat that's just
01:49:46 <jle`> map (step controller) moves
01:49:48 <cdunklau> yes
01:50:02 <cdunklau> there are several levels of stupidity here :D
01:50:03 <jle`> heh, i do that all the time
01:50:04 <iqubic> Also, I finally learned what HomC(a,b) mean.
01:50:10 <jle`> honestly
01:50:11 <cdunklau> well, inexperience mostly
01:50:21 <iqubic> That C is supposed to be subscript there.
01:50:47 <cdunklau> jle`: oh, zipWith is neat, thanks
01:50:48 <dminuoso_> iqubic: And what does HomC(a,b) mean?
01:50:55 <jle`> cdunklau: don't worry, i've programmed haskell for a while and i still do stuff like this heh
01:50:56 <jonathan_> Does anyone know of a data type like tree, but with enforced unique elements? Like the unique constraint of the keys in a map
01:51:00 <jle`> it doesn't matter as long as it's readable :)
01:51:16 <cdunklau> jle`: because the original is soooo readable :D
01:51:16 <Rembane> jonathan_: HAve you taken a look at Data.Set?
01:51:18 <jle`> jonathan_: unique leaves? or unique nodes?
01:51:52 <iqubic> dminuoso_: It's the set of all morphisms from object a to object b that exist in category C.
01:51:57 <jonathan_> I want all the elements in the tree to be unique, not just the leaves
01:52:03 <jle`> what are 'elements' here?
01:52:05 <dminuoso_> iqubic: It's even better.
01:52:16 <jle`> all the nodes, maybe?
01:52:32 <jle`> i suppose the issue is that there is more than one type of tree structure we can be talking about here
01:52:46 <iqubic> dminuoso_: Even better you say?
01:52:55 <dminuoso_> iqubic: Hom_C is a bifunctor from `C^op, C` to set
01:53:03 <jonathan_> Just a simple rose tree :)
01:53:19 <iqubic> Oh. I see. That makes sense.
01:53:23 <dminuoso_> iqubic: The key observation is that it doesn't just map objects, but it can map morphisms as well - it is after all a functor
01:53:38 <iqubic> Sure. Correct.
01:53:38 <jle`> jonathan_: like the Data.Tree sort of rose tree?
01:53:57 <jonathan_> jle`: yep, exactly
01:55:03 <jonathan_> jle`: but with enforced unique elements :)
02:01:15 <dminuoso_> iqubic: Understanding Hom as a functor and not as some "magical term" is an important insight. :)
02:01:48 <dminuoso_> (Or rather a bifunctor/profunctor, as it is)
02:02:09 <iqubic> I see. It's really cool.
02:02:13 <phanimahesh[m]> I wrote way worse stuff than  uncurry + zip
02:03:06 <dminuoso_> iqubic: I think a big problem of Bartosz approach is that the audience is programmers, so many examples are kept close to Hask
02:03:46 <iqubic> I prefer the Hask examples.
02:04:32 <iqubic> But then again I'm a programmer, and not a recreational mathematition.
02:04:57 <iqubic> *mathematician
02:05:23 <iqubic> As you can see, I'm 2AM, and its tired.
02:05:34 <iqubic> I mean not that, but the other way around.
02:09:53 * hackage git-mediate 1.0.8 - Tool to help resolving git conflicts  https://hackage.haskell.org/package/git-mediate-1.0.8 (EyalLotem)
02:12:35 <zebrag> https://wiki.haskell.org/Parsec > "parsing css with parsec" redirects to a "deceptive" site; maybe the link should be removed?
02:13:45 <zebrag> This seems to be the correct url: https://blog.jakuba.net/2014/08/10/Parsing-CSS-with-Parsec/
02:14:24 <phadej> zebrag: it's wiki :)
02:15:42 <phadej> i.e. if external link died, please fix it
02:15:49 <zebrag> phadej: yes; I should create an account, or something
02:15:58 <zebrag> ;)
02:16:10 <phadej> (I think I don't have wiki account myself either)
02:16:50 <zebrag> (todo list: create a wiki account...)
02:32:23 * hackage tls 1.5.3 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.5.3 (KazuYamamoto)
02:33:23 * hackage tls-session-manager 0.0.4 - In-memory TLS session manager  https://hackage.haskell.org/package/tls-session-manager-0.0.4 (KazuYamamoto)
03:08:55 <jpcooper> Morning. I have an error along the lines of "Couldn't match type X with Y." Is there any flag I can enable which will tell me more relevant information?
03:09:13 <opqdonut> not really
03:09:22 <opqdonut> what usually helps is adding more type annotations into the code
03:09:30 <opqdonut> that'll usually narrow down where the actual error is
03:09:52 <merijn> Yeah, splitting up with lots of where definitions and explicit type signatures is the best way to go
03:10:10 <opqdonut> the other method is just staring at the code really hard ;)
03:10:19 <merijn> I recommend a healthy mix of both
03:11:07 <jpcooper> I have been doing this. I guess I will continue
03:11:20 <merijn> jpcooper: pastebin a minimal example + error?
03:11:27 <jpcooper> It would be lovely to be able to see the minimum set of constraints which leads to this error
03:11:58 <jpcooper> merijn: That would take quite a while. I am going to work on this a bit more by myself, and will come back if I get nowhere
03:48:40 <maralorn[m]> Is there a way to use a unicode lambda instead of the backslash for writting lambda expressions?
03:48:57 <merijn> maralorn[m]: Yes, but you shouldn't >.>
03:49:06 <merijn> Actually, not even 100% sure, tbh
03:49:23 <phadej> lambda character is a valid variable name
03:49:31 <maralorn[m]> I can‘t find it.
03:49:35 <boxscape> there's a proposal for haskell2020 here https://github.com/blamario/rfcs/blob/lambda-reserved-word/0000-lambda-reserved-word.rst
03:49:45 <merijn> Ah, not it's not part of UnicodeSyntax
03:50:08 <phadej> > let λ = 42 in λ 
03:50:10 <lambdabot>  42
03:50:39 <phadej> maybe some physist do have variable named λ
03:50:41 <ent> that's a nice way to confuse people who have a haskell mode that shows \ as λ
03:50:43 <merijn> I will downvote that proposal with extreme prejudice, tbh
03:51:05 <merijn> In fact, I will downvote most of these "trivial superficial syntax tweaks" with extreme prejudice
03:51:33 <dibblego> same
03:51:47 <merijn> They do absolutely nothing to make Haskell easier, simpler, nicer, better. Although they is make things "slightly different for 0 functional pay off and gratuitously breaking the ecosystem"
03:52:06 <merijn> s/Although they/All they do
03:52:12 <boxscape> Actually the pull request is closed anyway https://github.com/haskell/rfcs/pull/19
03:52:42 <merijn> LambdaCase is already iffy IMO and that one at least doesn't break anything and has a lot of common usecases
03:53:34 <Rembane> maralorn[m]: There are plugins for some editors that do it for you without messing with the actual source code. 
03:54:09 <boxscape> or just use a font that makes \ look like λ ;P
03:54:17 <maralorn[m]> merijn: So then you don‘t like https://github.com/ghc-proposals/ghc-proposals/pull/302 I suppose?^^
03:54:34 <boxscape> oh hey it's my proposal
03:54:38 <Rembane> boxscape: That's a really nice solution until you want to escape some characters. :D
03:54:43 <boxscape> true
03:55:16 <merijn> maralorn[m]: I don't. In fact, I dislike DoArguments or what it's called too (despite like the resulting syntax)
03:55:31 <merijn> I don't consider the syntax improvement worth the breakage and incompatibilities
03:55:50 <maralorn[m]> I understand that one shouldn‘t bikeshed over those issues. otoh hand every time I write Haskell I get annoyed about some syntax tweaks …
03:56:20 <phadej> merijn: BlockArguments ?
03:56:47 <merijn> maralorn[m]: Annoyed enough to break all the tooling *again*? Annoyed enough to make the syntax even more complex for beginners?
04:01:31 <phadej> well, all tooling is broken by e.g. KindSignatures
04:01:39 <phadej> but those at least allow you to write something you couldn't before
04:02:22 <merijn> phadej: Right, I didn't say I was against *all* breaking extensions. I was complaining about breaking *syntax* extensions that don't provide adequate improvement in expressivity
04:02:27 <phadej> changing single one-letter character to another is... really picking a color of the bikeshed
04:03:20 <phadej> ah, now I remember the argument for BlockArguments
04:03:31 <merijn> LambdaCase/BlockArguments are right on the edge of "usefulness-to-breakage" ratio
04:03:40 <phadej> with it, one can remove special typing rule for runST
04:03:54 <merijn> In the defense of those two, they don't require changes that break existing code, they merely "allow more"
04:03:55 <phadej> `runST $ do ...` works by magic
04:04:20 <phadej> but if one writes `runST do ...` then the magic of `$` isn't required
04:04:26 <merijn> phadej: Except that so much code relies on that that it can't be removed anytime soon (if ever) anyway
04:04:46 <merijn> And considering ImpredicativeTypes was finally getting some love, that might be a better solution
04:05:24 <phadej> well, you'd need to enable ImpredicativeTypes for it to work
04:05:33 <phadej> vs. BlockArguments is syntax extension
04:05:47 <phadej> but it's really a nuance
04:06:33 <phadej> runST (do ...) is not _that_ bad; so $ rule is already "making syntax nicer"
04:06:54 <maralorn[m]> Of course even a change breaks no code it breaks syntax highlighting and similar.
04:08:07 <p0a> so what kind of files does haskell have? I know it has .hs. Any others? with regards to source code
04:10:50 <tdammers> source code only? .hs, .hs-boot, .lhs
04:12:19 <Taneb> Does .hsc count?
04:12:52 <Taneb> And is there an lhs-boot?
04:14:16 <geo2a> Hey, does anyone know if lambdabot is active? Do I pm it to use it? 
04:14:38 <p0a> yeah
04:15:10 <merijn> @botsnack
04:15:10 <lambdabot> :)
04:15:13 <merijn> Seems to work
04:25:42 <geo2a> Thanks!
04:32:32 <Putonlalla> Is there a package for calculating font metrics, such as extents of a glyph, number of curves needed to rasterize it or estimated amount of ink needed to print it?
04:37:23 * hackage sensu-run 0.7.0.4 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.7.0.4 (MitsutoshiAoe)
04:49:03 <phadej> Putonlalla: ekmett has, yet not on hackage afaik
04:51:13 <phadej> github.com/ekmett/codex there's harfbuzz
04:51:32 <Putonlalla> Oh, let's see.
06:00:59 <p0a> Hello is hoogle already in stack or do I have to install it?
06:02:09 <Axman6> @where hoogle
06:02:09 <lambdabot> http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
06:03:00 <p0a> Axman6: do you use `stack hoogle' out of the box?
06:03:10 <MarcelineVQ> p0a: recent enough stack will install it for you when you type stack hoogle
06:03:33 <p0a> MarcelineVQ: I think I ran into https://github.com/commercialhaskell/stack/issues/4905
06:03:37 <MarcelineVQ> though it failed when I tried just now :>
06:03:48 <p0a> hehe shucks
06:07:43 <MarcelineVQ> stack install hoogle  worked just fine though
06:08:55 <p0a> MarcelineVQ: it complains about stuff for me
06:09:09 <p0a> oh no it doesn't nevermind. Thank you 
06:09:32 <p0a> god I'm doing progress at the speed of a snail, hope it picks up soon
06:11:59 <maerwald> p0a: I told you to use cabal :P
06:16:28 <[exa]> p0a: are you forced into using stack by some dependency or so?
06:17:02 <p0a> [exa]: I'm using yesod and it recommends stack
06:17:10 <p0a> not about to get into those details it honestly does not matter to me lol
06:17:52 <p0a> what tied me down to stack is the fact I spent a bit of time to learn it so I'm not about to do a 180
06:18:15 <p0a> every day counts im on a break and once shit hits the fan itll be even slower
06:22:04 <inkbottle> https://github.com/chrisdone/intero: "The intero project has reached the end of its life cycle"; which raises the question, what shall I be using next. I'm used to emacs, and w. debian, vscode is not really an option
06:22:28 <MarcelineVQ> try dante
06:22:46 <inkbottle> okay
06:24:46 <maerwald> how is emacs support for hie?
06:25:15 <maerwald> I'm between switching to vscode or emacs from vim, because the MS language server for vim isn't that good
06:25:40 <maerwald> s/server/client/
06:26:30 <inkbottle> 2 month ago, I haven't been able just to have it working; are you using windows, how come you use vscode?
06:29:03 <inkbottle> MarcelineVQ: (https://github.com/jyp/dante) "aims exclusively at providing a convenient frontend to GHCi"; doesn't seem to really be for editing code
06:30:11 <inkbottle> I'll go for plain haskell-mode
06:31:58 <MarcelineVQ> ..
06:35:53 <MarcelineVQ> "Dante is a fork of Intero mode which aims exclusively at providing a convenient frontend to GHCi. It steals good ideas from Intero" and from that point on tells you which
06:39:30 <inkbottle> I'll try it asap
06:41:23 * hackage niv 0.2.11 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.11 (nmattia)
06:53:39 <inkbottle> Is there something like "stack --resolver latest"?
06:53:58 <hc> stack --resolver nightly   iirc
06:54:11 <merijn> I don't think so, because that'd kinda contradict stack's entire design philosophy, wouldn't it?
06:55:11 <hc> why? it could be used to check if your package is still compatible with the latest "world"
06:55:30 <MarcelineVQ> merijn: it's allowed on cli, just not in stack.yaml
06:55:47 <inkbottle> merijn: yes it would defeat the purpose (would be convenient though)
06:55:48 <MarcelineVQ> keeping your project conformant
06:55:57 <merijn> You're developing against a fixed set of packages and compiler, that are supposed to play nicely. Arbitrarily using the latest whatever kinda does the opposite
06:58:14 <hc> not if you want early warning that your code will not be compatible with the latest versions of libraries
06:58:27 <hc> which might be important to you if you wish to upgrade in case of security bugs in dependencies
06:59:02 <merijn> At that point you're basically using cabal-install's workflow, but with lots of extra hoops and steps
06:59:35 <hc> not really.. i'm using a stable lts release for development but use the nightly thingy in the CI pipleline for the warnings
06:59:54 <hc> how to get security patches of dependencies if you cannot upgrade to the latest lts?
07:00:10 <hc> or are you saying that the type system saves from 'em all? :-)
07:00:27 <maerwald> I never got why people use stable lts for development. Deployment sure, but during development I want to be exposed to new APIs and build failures.
07:00:51 <merijn> hc: No, I think stack's lts notion itself is fundamentally flawed and doesn't really support "security patches"
07:00:59 <hc> okay, fair point
07:01:22 <maerwald> merijn: even if it would, the definition of "security patch" itself is flawed
07:01:29 <hc> i wish 'security patches' weren't a thing, but sadly they have become some kind of industry standard
07:01:31 <merijn> Personally I just cabal-install and freeze
07:01:39 <merijn> maerwald: Word.
07:01:55 <tdammers> .oO("add security")
07:02:10 <hc> like qmail... one patch once every ten years
07:03:16 <hc> i think what stack tried to solve with lts cabal/rust solved by allowing multiple versions of the same library to exist in parallel in a project
07:03:22 <merijn> The problem is that in most modern software you can't get "just" security patches, you get all the feature stuff too (which is what maerwald was hinting at, I think)
07:03:41 <hc> hints and security don't match ;p
07:04:39 <maerwald> merijn: well, to quote gregkh: you can actually never know when a patch or bugfix is just that or a security patch
07:05:05 <tdammers> the problem is also that any patch is potentially security-relevant, though not necessarily in a good way
07:05:13 <maerwald> exactly
07:05:53 <maerwald> thus, backporting is flawed
07:06:04 <maerwald> and the only true way is to keep rolling
07:07:08 <tdammers> no, that doesn't work either
07:07:30 <tdammers> and it's particularly terrible when you don't know what those updates do
07:07:39 <tdammers> then you're essentially at the mercy of whoever publishes the updates
07:07:56 <maerwald> we are anyway!
07:08:17 <tdammers> the promise of open source was that we wouldn't
07:08:57 <maerwald> they lied to us!
07:09:12 <MarcelineVQ> they played us like a damn fiddle
07:09:20 * maerwald stirs up the mob
07:11:20 <tdammers> angry beard stroking intensifies
07:11:36 * tdammers plays Angry Beards on his freephone
07:18:30 <inkbottle> blah :: IO (Either ParseError [[Char]]); if I do `show <$> blah` in ghci it shows 'Right ["..."]'; but (putStrLn . show) <$> blah, prints nothing
07:19:43 <maralorn[m]> If you develop on nightly how do you know that you can even deploy for lts?
07:19:43 <MarcelineVQ> what's the type of (putStrLn . show) <$> blah
07:20:30 <hc> maralorn[m]: by using a CI pipeline and lots of unit tests?
07:20:45 <merijn> inkbottle: Because you end up with IO (IO ())
07:20:47 <inkbottle> MarcelineVQ: (putStrLn . show) <$> blah :: IO (IO ())
07:20:49 <geekosaur> nothing runs that action that I see, betting it's ... that
07:20:58 <merijn> inkbottle: i.e. an IO action that will produce the IO action which prints
07:21:20 <merijn> inkbottle: But you never use that resulting IO action
07:21:22 <inkbottle> i see
07:21:29 <merijn> inkbottle: So it never runs and thus never prints
07:22:03 <merijn> Possible solutions: 1) replace fmap (i.e. <$>) with bind (i.e. >>=), 2) use join
07:22:07 <geekosaur> you could use join, or rephrase it using >>=
07:22:09 <geekosaur> heh
07:22:22 <merijn> inkbottle: Related note "putStrLn . show" is just "print" :)
07:22:29 <merijn> :t print
07:22:32 <lambdabot> Show a => a -> IO ()
07:22:40 <inkbottle> hum
07:22:46 <inkbottle> good point
07:27:06 <lavalike> @src print
07:27:06 <lambdabot> print x = putStrLn (show x)
07:27:06 <inkbottle> >>= worked nicely, thanks
07:27:38 <merijn> :t join
07:27:40 <lambdabot> Monad m => m (m a) -> m a
07:30:53 * hackage morph 0.1.1.3 - A simple database migrator for PostgreSQL  https://hackage.haskell.org/package/morph-0.1.1.3 (thoferon)
07:46:36 <daydaynatation> Is the rio library gaining tractions nowdays? I find it definitly not for beginners because of the lack of easy printing functions
07:47:31 <pie_[bnc]> is there a list of languages embeddable in haskell somewhere?
07:47:47 <pie_[bnc]> i want something I can interpret at runtime 
07:48:01 <pie_[bnc]> would probably be beneficial if it was possible to run it purely
07:48:10 <ziman> hello, my OS libraries got upgraded and now one of the (shared) libraries in ~/.stack fails to link. Is there a way to recompile only that one library?
07:48:43 <ziman> i find it hard to come up with good search terms
07:51:48 <merijn> pie_[bnc]: Whether a language is embeddable is mostly a question of "how much effort are you willing to invest?"
07:52:14 <merijn> pie_[bnc]: What sorta languages are you looking to embed? For what purpose? How much effort are you willing to invest?
07:53:34 <ziman> for the record, i found it: https://stackoverflow.com/a/37237777
07:55:12 <pie_[bnc]> merijn: I want extensibility of my program for users without having to recompile it, theres two main components im thinking about right now, one is a throttling scheduler, the other is something for specifying web scrapes
07:55:27 <pie_[bnc]> merijn: maybe i should just use lisp instead of haskell :P
07:55:41 <pie_[bnc]> this is all very hypothetical at the moment
07:56:45 <merijn> pie_[bnc]: There's nothing really easily prebuilt, but otoh it doesn't strike me as considerably more effort than it'd take to, say, embed something in C or Java
07:56:54 <merijn> Potentially much less effort than those
07:57:03 <pie_[bnc]> hm :/
07:57:39 <daydaynatation> Seems guile is particularly good for that  
07:58:00 <merijn> pie_[bnc]: Would something like a userspecified dynamic library they can plug into your system work/match what you want?
07:59:08 <pie_[bnc]> merijn: I'm not sure?
07:59:18 <solonarv> hc: cabal in fact does not allow multiple versions of the same library, and when I found out that this is common in other build tools I was frankly baffled
07:59:29 <pie_[bnc]> merijn: oh you mean like loading a shared object from the used (yeah i know thats the same thing you just said)
07:59:42 <pie_[bnc]> *from the user
07:59:47 <merijn> pie_[bnc]: Because that seems like it'd be pretty straightforward
07:59:56 <pie_[bnc]> I guessssss that could work, but I really want it to feel like scripting
08:00:06 <pie_[bnc]> so Id have to deal with a compiler
08:00:13 <dminuoso_> pie_[bnc]: "scripting" is not a thing. its all in your head. :)
08:00:24 <solonarv> one important question is how worried you are about the extension code being safe / able to do evil things
08:00:25 <pie_[bnc]> dminuoso_: so are side effects :P
08:00:36 <hc> solonarv: indeed. that's what makes building rust projects so much more painless compared to haskell projects
08:00:39 <pie_[bnc]> solonarv: mildly. which is why it would be nice to run pure
08:00:43 <dminuoso_> pie_[bnc]: shared objects is a battle-tested method of distributing program parts without having to recompile things.
08:00:49 <merijn> pie_[bnc]: I mean, that's fine, it certainly doable, defining a scriptable API is a lot of work, but then you'd have to do that in any language
08:00:53 <hc> (haskell and rust being the only two languages i ever used a dependency manager for)
08:01:01 <dminuoso_> pie_[bnc]: Literally *decades* of tens of thousands of robust software projects are proof that it cant be bad. :)
08:01:25 <merijn> dminuoso_: Embedding scripting engines in large applications also has decades of software projects as proof, so...
08:01:27 <pie_[bnc]> dminuoso_: just like writing software in C :P
08:01:31 <solonarv> there are some lua bindings; AFAIK they all need to run in IO for the actual execution, but you can easily control what the lua code is allowed to do
08:01:35 <merijn> dminuoso_: Like, every singe game in recent history
08:01:48 <solonarv> lua is a fairly common choice for this sort of thing especially among games, btw
08:01:59 <dminuoso_> merijn: And Im not convinced that it's a good idea.
08:02:09 <merijn> Embedding Lua or something seems perfectly reasonable, like I said a substantial amount of work, but not more than it'd be in C
08:02:09 <pie_[bnc]> dminuoso_: I thnk youre wrong :P
08:02:18 <merijn> dminuoso_: I think it depends on the application
08:02:24 <pie_[bnc]> having a short feedback cycle is important
08:02:24 <dminuoso_> merijn: I think languages have been doing it because you are usually at odds with being forced to use C++ to gain high performance but lacking expressivity for high level task.
08:02:27 <dminuoso_> merijn: Which is why games do it so frequently
08:02:50 <merijn> Queue, my usual example of the WoW ui
08:03:03 <solonarv> I was thinking of that as well
08:03:30 <dminuoso_> merijn: Well it's rather an artifact of wanting expressive high level languages while writing high performance code for the engine and networking things.
08:03:35 <solonarv> the WoW ui is also a good example of how it's useful to have the extensibility locked into a VM instead of just loading a dynamic library
08:03:37 <dminuoso_> So you glue lua into your code
08:03:45 <merijn>  dminuoso_: No
08:04:01 <dminuoso_> Ah you mean the extensible portion of that WoW UI?
08:04:03 <merijn> dminuoso_: The Lua in WoW was providing users a complete scriptable Lua VM to program custom UI
08:04:26 <dminuoso_> Ah
08:04:45 <merijn> Where the game is essentially a high-level API exposed to a Lua VM and then you can go crazy and write whatever you want
08:05:04 <pie_[bnc]> i keep getting studd on EDSLs
08:05:08 <pie_[bnc]> kind of hard to google for thi
08:05:10 <merijn> Sure, that's not suitable for ALL applications, likely not even for very many, but it's a perfectly reasonable thing to want
08:05:17 <solonarv> and doing things this way made it feasible to disallow things like a script that just plays your character for you
08:05:17 <dminuoso_> Gah, I hate prettyprinter.
08:05:20 <pie_[bnc]> looks like haskell isnt big on it (tfw you arent the JVM)
08:05:20 <merijn> pie_[bnc]: EDSLs are something else entirely, though :)
08:05:25 <pie_[bnc]> merijn: i know
08:05:36 <merijn> Haskell is very big on EDSLs :p
08:05:41 <merijn> dminuoso_: How come?
08:05:50 <solonarv> oh! you could also use dhall
08:05:56 <dminuoso_> merijn: Prettyprinter is so fast, I dont have a single bottleneck left - most of my time is spend in prettyprinter because of the sheer volume of text to pump through!
08:06:11 <dminuoso_> Now I dont know how to make my program any faster anymore. :(
08:06:25 <merijn> :p
08:06:37 <solonarv> which is rather more esoteric, being a non-turing-complete pure language without any escape hatches
08:07:26 <dminuoso_> solonarv: Speaking of escape hatches. Erlang got me enraged properly because they religiously live this "No mutability", that seemingly simple tasks require complex workarounds.
08:08:04 <dminuoso_> I wish I had escape hatches there.
08:10:25 <solonarv> do they at least have something like StateT so you can disguise your pure FP as mutable imperative programming?
08:14:57 <solonarv> oh, of course you can write some sort of free monad thing in dhall and interpret it from the haskell side
08:15:57 <pie_[bnc]> I really dont want to write my own s expression language but it seems almost inevitable :(
08:16:08 <pie_[bnc]> and then its going to be crippled and not have a ton of stuff
08:16:22 <solonarv> what's giving you the impression that you have to do that?
08:16:35 <pie_[bnc]> well I dont see anything particularly more enticing yet
08:18:27 <pie_[bnc]> is it time to learn lua....
08:18:51 <solonarv> it does seem well-suited to the task
08:20:42 <fdem> i was told learning haskell would broaden my horizons. i am going to do just that.
08:21:32 <fdem> and pop my functional programming cherry
08:24:11 <pie_[bnc]> husk-scheme hasnt been changed in 4 years so it probably doesnt even compile anymore
08:26:35 <solonarv> fdem: welcome! if you have any questions about haskell, just ask them
08:37:23 * hackage morpheus-graphql 0.10.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.10.0 (nalchevanidze)
09:00:06 <fog> yeasterday i wrote a type where it had type-lengthed-lists at every value in a HList with the list of lengths of the internal lists as a type parameter
09:01:00 <fog> then i had to change it so these inner lengthed lists contained lists that were the same length as the previous layer
09:01:25 <fog> it was an absolute nightmare, and then it needed fold and unfold instances and these were pretty much impossible to understand how to write
09:02:37 <fog> how are we supposed to be able to work with such difficult types?
09:03:53 <fog> im trying to think how to phrase a helpful abstraction that would simplify the whole process, but its very difficult to understand how that particular container fits into a wider collection
09:04:38 <fog> basically its the constraint between the values in the hlist thats the problem
09:05:09 <fog> a gadt managed to express it, by matching on the head value of the list being consed to with its constructor
09:05:28 <fog> but that yields a type thats very difficult to work with for eg, folding and unfolding
09:05:37 <fog> maybe i just need help writing these instances...
09:06:39 <fog> i was working on fold/unfold for HFree and thought this was a fairly all encompassing abstraction, but this is a whole other thing...
09:30:30 <statusfailed> Is it not allowed to partially apply a type synonym?
09:30:56 <statusfailed> e.g., instance MyClass (MySynonym []) where ...
09:31:05 <statusfailed> where "MySynonym" has kind Type -> Type -> Type for example
09:31:22 <Taneb> statusfailed: no, it is not
09:31:35 <statusfailed> What's the correct thing to do?
09:31:36 <statusfailed> use a newtype?
09:31:40 <Taneb> Although see the extension TypeSynonymInstances, which lets you do this in some circumstances
09:31:48 <statusfailed> Ah, I have that switched on, it seems still not allowed
09:32:28 <Taneb> If it doesn't make sense if you expand the type synonym then it won't work
09:32:49 <voyons_osti> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/data-type-extensions.html#type-synonyms
09:32:50 <statusfailed> Sorry, could you explain what you mean by "expand the type synonym" ?
09:33:01 <voyons_osti> is this what you're trying to do?
09:33:22 <voyons_osti> With the -XLiberalTypeSynonyms extension, GHC does validity checking on types only after expanding type synonyms.
09:34:59 <statusfailed> Hmm, not sure
09:35:00 <statusfailed> I will have a read
09:35:12 <statusfailed> I have to run to catch a train, but thanks for the link!
09:35:34 <voyons_osti> in ghci, is there a quieter version of :type ? 
09:35:52 <voyons_osti> i.e. , `:type x :: Int` outputs `x :: Int`
09:36:07 <voyons_osti> but with long, complex types, this is a bit hard to read
09:36:13 <voyons_osti> i would prefer just  `Int` 
09:51:23 * hackage simple-get-opt 0.4 - A simple library for processing command-line options.  https://hackage.haskell.org/package/simple-get-opt-0.4 (IavorDiatchki)
09:52:23 * hackage base64 0.3.0.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.3.0.0 (topos)
09:52:42 <topos> ^ addresses lexilambda's comments
09:52:50 <topos> + adds lenient decoding
09:59:31 <phadej> topos: fwiw, don't upload docs, let the doc-builder do them
09:59:48 <phadej> see e.g. https://hackage.haskell.org/package/base64-lens-0.1.0.0/docs/Data-ByteString-Base64-Lens.html
09:59:55 <topos> oh?
10:00:01 <phadej> I removed your uploaded docs, doc-builder built dhem and links work
10:00:04 <geekosaur> uploading docs is for when you have external deps that prevent the builder from building them
10:00:19 <topos> oh thank youy
10:00:25 <topos> The instructions were unclear about that. That's great news. Less work and better results
10:00:30 <geekosaur> since the builder doesn't have every conceivable external C lib installed, for example
10:01:31 <phadej> yes, you only need to make sure that package builds with GHC doc-builder uses (IIRC 8.6 atm)
10:01:58 <phadej> there is some good amount of common C-libs
10:02:22 <oats> I still for some reason feel a little burst of joy when I realize I can use applicative for something
10:12:57 * jojoz[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/fsSWoJOyDxSbEQnLYDrUNMWC >
10:12:59 <maerwald> phadej: do you know the exact difference between using a freeze file and pinning the hackage state? If the build plan only depends on 1. the .cabal file and 2. the hackage state, then that should be enough for reproducible output, right?
10:12:59 <maerwald> But my gut feeling tells me that might not be the case
10:13:58 <maerwald> (e.g. already installed packages might change the build plan?)
10:13:59 <jojoz[m]> oof it broke
10:14:19 <phadej> pinning index-state and cabal-install version should produce same install plan yes, except if there's some pkg-config etc. global change which may flip some automatic flags
10:14:41 <phadej> already installed packages don't affect v2-build solver at all
10:14:53 <phadej> (that's _the_ point)
10:15:41 <maerwald> cabal options like max-backjumps and whatnot don't affect the build plan?
10:16:39 <phadej> max-backjumps don't, some other might (like reorder-goals)
10:17:19 <phadej> but not in the case when the resulting plan is "all the latest (up to index-state)"
10:17:52 <maerwald> pinning index state seems easier when you want to support both windows and unix
10:18:06 <phadej> it depends how much freedom in movement there is (for apps I'd recommend to support only one major version of dependencies anyway, so most likely solver will find always the same plan)
10:19:27 <phadej> problematic cases are "should I pick newer vector or newer hashable, because of the dependencies I can pick only either, but not both"
10:20:02 <phadej> and those build-plans aren't "comparable" (you cannot say which one is better, objectively)
10:22:22 <phadej> if you really want truly reproducible builds, you could ditch hackage index all together and download all the dependencies into https://cabal.readthedocs.io/en/latest/installing-packages.html#local-no-index-repositories (which is cabal-install-3.2 feature though)
10:22:38 <phadej> if you are a "bank", I'd do that
10:58:48 <maerwald> how do you get the timestamp of the current index state? ~/.cabal/packages/hackage.haskell.org/timestamp.json doesn't have it
10:59:31 <phadej> cabal v2-update prints it
10:59:38 <maerwald> only the previous one
10:59:39 <phadej> (with side-effect of updating it though)
10:59:47 <phadej> update again :)
10:59:49 <maerwald> ...
10:59:59 <maerwald> not great for writing a script doing that
11:00:25 <maerwald> there should be a way to get it programmatically (or tell cabal configure/freeze to pin and write it out)
11:01:18 <phadej> there's an issue of freeze putting it but no-one implemented that yet
11:01:36 <phadej> (there are some nuances though)
11:01:50 <phadej> technically the index-state is "most recent file in 01-index.tar"
11:02:01 <zeta_0> i installed the haskell pkg `network` and i still get an error when i try to do this import, am i supposed the install another pkg instead?
11:02:03 <zeta_0> import Network.HTTP.Conduit
11:02:53 * hackage base64-lens 0.1.0.3 - Optics for the Base64 library  https://hackage.haskell.org/package/base64-lens-0.1.0.3 (topos)
11:04:31 <pounce> how do you do a multiline string
11:04:47 <phadej> > unlines ["foo", "bar"]
11:04:49 <solonarv> jojoz[m]: you can actually use CPP (C PreProcessor) in Haskell as well, it's built in to GHC
11:04:49 <lambdabot>  "foo\nbar\n"
11:05:00 <solonarv> so you can do it exactly the same way
11:06:00 <zeta_0> so do i need both `network` and `http-coduit` pkgs for `import Network.HTTP.Conduit` to work?
11:06:35 <solonarv> probably not, no
11:06:47 <solonarv> a module is only ever exposed from *one* package
11:07:12 <solonarv> if multiple packages expose a module of the same name, you get some sort of ambiguity warning/error; never happened to me though
11:07:37 <solonarv> based on the name, this module probably comes from http-conduit
11:07:39 <geekosaur> the real question is whether one is a dependency of the other, and my guess is yes network is a dependency of http-conduit
11:08:13 <solonarv> however it's entirely possible that you can't do anything useful with Network.HTTP.Conduit without also import some module(s) from network
11:08:38 <geekosaur> indirectly via http-client
11:08:49 <jojoz[m]> solonarv: I'll check that out, thanks
11:08:49 <sm[m]> An interesting article about compromising package repositories (python's): https://news.ycombinator.com/item?id=21910406 . I found the final image alarming - at least 10 hostile packages uploaded in 2017. I wonder how we're doing on this issue.
11:10:21 <zeta_0> so i guess i will just install both pkgs to make to make sure that it works
11:10:25 <wildtrees> so I got a working algorithm I came up with for some graphics, it's kinda bad at I *think* big O(n^4) , how long is that with n = 1000?? n=100 it runs fine 
11:10:41 <wildtrees> oh just got a result , took like 3 minutes with n = 1000 
11:11:23 <Uniaika> wildtrees: I guess you can make such a plot on Excel based on a constant time for each n
11:12:16 <solonarv> zeta_0: why are you "installing" packages?
11:12:53 <phadej> sm[m]: not well; yet you have to pass "human check" before you get rights to upload packages, and one of the checks is to show package you plan to upload
11:13:22 <phadej> so at least malicious user has to something good before the bad thing
11:13:22 <wildtrees> Uniaika, not sure how to benchmark Graphics.Gloss app from time of runnning to time that it has drawn a picture 
11:14:07 <sm[m]> phadej: good to know. We need more tools
11:14:25 <phadej> having human check for each new package would be best, but it will anger to many vocal people
11:14:39 <phadej> (new package, not version)
11:14:56 <zeta_0> solonarv: i am using nix, so whenever i need a some new packages, i place them in home.nix and do a rebuild switch, then reboot
11:15:16 <phadej> human is better, because "some algorithmic tools" will be always played
11:16:04 <solonarv> zeta_0: that seems like a somewhat janky workflow, but I am not a nix user - you do you I geuss
11:16:32 <sm[m]> I'd like eg a good tool for listing/browsing all transitive dependencies, their version diffs, their commits etc.
11:18:29 <zeta_0> solonarv: i almost gave up on haskell because of so many problems with package management, nix is a breathe of fresh air
11:19:31 <merijn> phadej: on the other hand, it would help the problem of some packages that have no business on hackage bloating the package index >.>
11:21:22 <sm[m]> zeta_0: ha! For some value of "air" :)
11:22:57 <zeta_0> ya
11:29:59 <inkbottle> Text and ByteString are 2 alternative ways to implement String?
11:30:29 <jojoz[m]> zeta_0: Sounds like you could use [nix-shell](https://nixos.org/nixos/nix-pills/developing-with-nix-shell.html)
11:30:40 <merijn> inkbottle: No
11:30:40 <cocreature> inkbottle: no, ByteString is a sequence of bytes. Text is a sequence of unicode characters
11:30:41 <fizbin> Okay, I have a question that people might not be able to answer because of my necessary vagueness, but I've got a Haskell process that runs as a web service. Over time, the amount of CPU used by this process seems to grow slowly but I have no idea why. The requests it gets are pure "spend some time computing this result" requests - no db access. Any idea how I could try to track this down?
11:30:53 <inkbottle> thanks
11:30:56 <merijn> inkbottle: The name ByteString is a historical accident, pretend it's name is "Bytes"
11:31:32 <merijn> fizbin: profiling and the eventlog would be starting points
11:31:40 <merijn> fizbin: the GHC user guide has info on using those
11:32:47 <sm[m]> CPU used during each request ? Or background CPU when idle ?
11:33:11 <sm[m]> I'd check its memory use
11:33:13 <fizbin> merijn: So I can't see anything in the profile, because of the time scale I need to watch this at. The amount of CPU used per request grows slowly over time - requests at the beginning of the week and end of the week are clearly different, but within any given hour the CPU graph just looks like noise.
11:33:19 <iqubic> So, I'vee been thinking. Is it true that Const is the closest thing Haskell has to a forgetful functor?
11:33:35 <merijn> fizbin: I recall that you can toggle profiling on at runtime
11:33:49 <jojoz[m]> zeta_0: With nix-shell you only have to restar the specific shell-instance rather than the whole system, and you can have different development environments for different projects. E.g. different versions of a library or GHC.
11:33:49 <sm[m]> ekg ?
11:33:56 <dsal> iqubic: what do you mean "forgetful"?
11:34:06 <fizbin> sm[m]: I believe that it's amount used within the request, but I'm not really sure.
11:34:13 <merijn> fizbin: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Profiling.html
11:34:37 <merijn> fizbin: You can implement a signal handler that, say, uses SIGUSR1 to toggle profiling on/off or add some other API call for that
11:34:56 <iqubic> dsal: It's a category theory thing. https://en.wikipedia.org/wiki/Forgetful_functor
11:34:56 <dsal> iqubic: It seems that Const is always forgetful, but I guess I don't have a good category theory background to know how to consider things like Maybe.
11:34:56 <merijn> fizbin: Then you can toggle the profiling on when you start noticing slowdowns, instead of the entire run
11:35:05 <fizbin> merijn: But a profile won't dump stuff out until I stop the process.
11:35:23 <merijn> fizbin: Ah, yeah. There's also the eventlog stuff, but I haven't used it
11:35:38 <sm[m]> if there's no state preserved between requests (like a global IORef or something).. maybe the server is leaking memory and spending more time garbage collecting
11:35:48 <fizbin> One thing I do know is that the CPU use resets if I restart the process. There is now a weekly restart.
11:36:49 <merijn> fizbin: I recall mpickering's work to get speedscope working uses the eventlog for profiling, I dunno if that can help get profiling data before the program shuts down
11:36:56 <merijn> fizbin: Also, have you seen ekg?
11:36:58 <merijn> @hackage ekg
11:36:58 <lambdabot> http://hackage.haskell.org/package/ekg
11:39:22 <fizbin> Huh. I may try adding in ekg.
11:40:27 <fizbin> I wish I could reproduce this behavior on timescales smaller than multiple days. This slow debugging is really annoying, because I lose so much state day to day.
11:40:58 <sm[m]> fizbin: doesn't it happen faster if you hammer it with traffic ?
11:41:11 <merijn> fizbin: You could ask in #ghc too, because they know the details of the eventlog and profiling stuff better
11:41:49 * sm[m] restarts darcsden nightly for a similar reason
11:43:17 <fizbin> sm[m]: I do have some evidence that extra traffic will make this happen more, in that the climb in CPU use was slower over the past two weeks. (It's a server mostly hammered by our internal build processes, so developers on vacation => less traffic)
11:44:18 <sm[m]> hammer it with synthetic traffic. I'd be surprised if it doesn't fall over quicker
11:44:55 <sm[m]> and did you respond re memory use ? You'll be able to see if that's going up
11:47:35 <fizbin> Hrm. Memory use isn't on this dashboard; let me see how to add it...
11:48:43 <haskell_noooob> hi
11:49:15 <haskell_noooob> have anyone set up a haskell project to solvle leetcode/codewars problems
11:49:40 <haskell_noooob> i want to be able to set up such that i can execute tests of all functions with a single command
11:49:45 <haskell_noooob> similar to rust, if you are familiar with that
11:49:47 <root____1> hey
11:49:50 <root____1> anyone there
11:50:07 <haskell_noooob> sup
11:50:15 <root____1> its ok
11:50:21 <root____1> and you?
11:50:29 <haskell_noooob> all cool
11:50:35 <root____1> where are you from
11:50:40 <haskell_noooob> are you familiar with haskell? i have newbie questions
11:50:47 <root____1> nope
11:50:54 <root____1> this is my first irc chat actually
11:51:15 <haskell_noooob> oo, welcome to the 2000s! 
11:51:23 <root____1> :)
11:51:33 <root____1> I have an literature exam tomorrow
11:51:36 <solonarv> haskell_noooob: yes, that can be done
11:51:37 <fizbin> sm[m]: Well that's bizarre. If I've chosen the variables correctly, it seems that memory use is: 1) not growing over time, and 2) totally uncorrelated to CPU use.
11:51:39 <root____1> I don't know anything
11:51:51 <solonarv> do you have any tests already?
11:52:48 <sm[m]> fizbin: you have the memory stats for a full cycle already ? Well, that may not be the issue then
11:52:49 <fizbin> haskell_noooob: The traditional thing to do these days is to do all your work within a project, add your test programs to its cabal file, and run with either "stack test" or "cabal test"
11:53:13 <sm[m]> not growing = great
11:53:20 <solonarv> haskell_noooob: you will note that this is similar to the rust/cargo workflow you were referring to ;)
11:53:36 <root____1> yesterday I made a perfect encryption algorithm
11:53:38 <root____1> I mean
11:53:43 <root____1> I guess it is perfect
11:53:59 <fizbin> sm[m]: Datadog is nice that way, collecting more stats on all your servers all the time and just not displaying them until you ask for them. Of course, there's _so_ many options that I might not actually be looking at what I think I am looking at.
11:53:59 <solonarv> root____1: please note that this channel is for discussion of the Haskell programming language
11:54:03 <solonarv> it is not a general chat channel
11:54:12 <haskell_noooob> ahh i see, im still going through this haskell tutorial, but i think i learn better from actual code
11:54:16 <haskell_noooob> will look into it
11:54:23 <root____1> thanks for the warning
11:54:26 <root____1> leaving
11:55:40 <sm[m]> see ya. Or you're welcome to hang out and learn about haskell
11:55:56 <solonarv> hm, perhaps the topic line should say something to that effect near the start...
11:56:46 <solonarv> right now it is just a pile of links, and gives no clue what this "Haskell" thing might be
11:58:21 <sm[m]> haskell_noooob: I've done things like that. "stack scripts" are a way to write a reliable single file haskell script, without needing a project. "ghcid" and "entr" are very useful tools for getting rapid feedback.
11:58:38 <ben> is this really worth optimizing the limited topic real estate for
11:58:42 <fizbin> sm[m]: E.g., here's what I see for cpu and memory use on those servers over the course of a month. Remember that I set something up to restart services every Sunday: https://imgur.com/a/lDNxOjT
11:59:39 <sm[m]> ben: it does happen a lot, and seems to be increasing. But yes, topic space is valuable
11:59:48 <sm[m]> and nobody reads the topic.
11:59:59 <solonarv> "Haskell Programming Language" at the start doesn't seem like it would take up too much space
12:00:13 <solonarv> and it's not like the entire topic fits on screen currently
12:00:24 <solonarv> or, wait, is there a max length that we have already hit?
12:00:36 <oats> are there any conduit functions for "lifting" functions into a conduit? something like liftC2 :: (a -> a -> b) -> ConduitT a b m () ?
12:00:39 <oats> hoogle wasn't able to help me here
12:00:53 <sm[m]> fizbin: that's memory use by all processes I guess. I was thinking "watch the haskell process with [h]top while hammering it"
12:01:27 <haskell_noooob> how do i see the implementation of built in functions like `succ`
12:01:51 <sm[m]> solonarv: I think it gets truncated differently by every client
12:01:51 <oats> @src succ
12:01:51 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:02:39 <oats> haskell_noooob: search for it on hoogle, there's often a "source" link with the function documentation
12:02:43 <oats> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:succ
12:02:47 <sm[m]> if you view channel with Riot (matrix client), there's a very clear "Haskell | an advanced, purely functional programming language" title
12:02:48 <solonarv> haskell_noooob: look them up in the documentation (can be found on hackage, usually) and click the "source" link
12:03:06 <haskell_noooob> ah, i didnt see that source thing
12:03:10 <solonarv> note that "succ" in particular doesn't have a single implementation, it has a different implementation for every type
12:03:44 <oats> succ = toEnum . (+ 1)  . fromEnum
12:03:51 <topos> <s u c c>
12:03:52 <int-e> oats: Right, it has a default implementation.
12:03:52 <solonarv> sm[m]: that topic appears to be entirely Matrix-side
12:04:08 <haskell_noooob> ah so its not like c++? that just do ++ and if the type implement operator++ it werks
12:04:13 <haskell_noooob> i believe this is called subtyping?
12:04:30 <sm[m]> it's the room name on the matrix side, yes. The IRC topic is displayed separately
12:04:31 <solonarv> on my client (irssi) I see however much fits on one line (and /topic shows all of it)
12:04:41 <solonarv> haskell_noooob: it is sort of similar, actually
12:04:50 <sm[m]> I wish the matrix name was short actually
12:04:59 <solonarv> what happens if you do ++ on a type that doesn't implement operator++ ? surely you get some sort of compile error
12:05:01 <oats> haskell_noooob: here, succ is defined for any type that has an 'Enum' instance
12:05:41 <sm[m]> you do
12:06:12 <sm[m]> oh, sorry. I was answering for haskell.
12:06:56 <koz_> Operator overloading is a kind of ad-hoc polymorphism.
12:07:02 <koz_> We do that using type classes.
12:07:21 <solonarv> and we can do it for any operator, not just a handful of built-in ones ;)
12:07:26 <koz_> (easy example: Eq)
12:07:26 <geekosaur> which are slightly less ad hoc
12:07:26 <koz_> geekosaur: Yeah, indeed.
12:07:43 <geekosaur> also note that haskell lets you define new operators
12:07:45 <koz_> Yeah, if you want to 'overload' the :+-*/ operator, go for it. :P
12:08:05 <solonarv> haskell_noooob: it's not quite subtyping, no: Haskell does not have subtyping in the same sense that e.g. C++ or Java do
12:08:13 <geekosaur> a name consrtucted from symbol characters can be defined as an operator
12:08:34 <koz_> More precisely, we do some of the things they do without resorting to subtyping as such.
12:08:50 <koz_> Because subtyping brings with it a whole slew of additional concerns.
12:08:54 <koz_> (thanks TAPL!)
12:09:57 <solonarv> you can sort of try to build your own subtyping in Haskell using advanced type hackery, but it is kind of inconvenient and annoying and the type inference gets really bad
12:10:33 <koz_> I think someone (may have even been solonarv?) hacked together something like that using Vinyl a while back.
12:10:33 <sm[m]> haskell_noooob: one more thing (two more things) on solving puzzles with haskell. https://github.com/simonmichael/aoc2018 has examples of the stack scripts approach. byorgey has some related posts at https://byorgey.wordpress.com/tag/competitive . https://www.codingame.com/multiplayer/clashofcode is really fun. Counting is hard.
12:11:08 <solonarv> koz_: that does sound like something I would do, yes :>
12:14:32 <koz_> Also, TIL that apparently the 'linear arrow' is named 'lollipop'?
12:15:59 <monochrom> Because it's made to look like a lollipop.
12:16:08 <koz_> monochrom: Yeah, I get _why_, it's just hilarious.
12:16:19 <oats> —@
12:16:29 <koz_> (of course, the first time I saw that designation, it was in a McBride paper)
12:16:31 <[exa]> koz_: lollipops can be consumed.
12:16:33 <koz_> (because Conor will Conor :P)
12:16:58 <koz_> [exa]: Not merely _can_: _must_. :P
12:17:05 <solonarv> @_@
12:17:14 <oats> @-@
12:17:20 <oats> double lollipop
12:17:23 <oats> for... reasons
12:17:23 <[exa]> ◔.◔
12:17:42 <solonarv> bidirectional lollipop
12:17:57 <solonarv> ...a linear... isomorphism? adjunction?
12:18:00 * solonarv isn't sure
12:18:19 <monochrom> St. Valentine's lollipop
12:18:46 <koz_> solonarv: A linear adjunction means 'these have to be consumed together, exactly once'?
12:22:52 <solonarv> I was thinking of it as an iso where each direction is linear
12:23:06 <solonarv> which does not sound very useful, tbh
12:23:17 <solonarv> since that's most (all?) isos anyway
12:24:07 <[exa]> rewording: what a guarantee!
12:54:03 <hahahahaskell> >concatenating 2 lists requires walking through the entire lhs list
12:54:14 <hahahahaskell> is the underlying implementation of list like cons in lisp?
12:54:19 <hahahahaskell> basically a linked list
12:54:24 <geekosaur> yes
12:54:46 <geekosaur> there are other data types for more compact kinds of representations (Array, Vector, etc.)
12:56:06 <geekosaur> we keep lists because they're loops encoded as data, when thinking functionally
12:56:48 <jojoz[m]> Don't forget about Seq (Sequence). Probably the most versatile/convenient list alternative in my experience.
12:59:58 <tdammers> the difference between Haskell lists and lisp cons lists is mainly that Haskell lists are non-strict, which means that large lists can be processed in a streaming fashion in constant memory (though at the mercy of the garbage collector)
13:01:47 * geekosaur wonders if it's still true that some programs that process strings compile via list fusion to better code than an optimizing C compiler can produce
13:02:06 <hahahahaskell> hmm how does haskell deal with floating points? they are surely not associative, even in haskell?
13:02:31 <p0a> tdammers: what do you mean by that?
13:03:23 * hackage haskoin-store 0.19.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.19.3 (jprupp)
13:03:39 <geekosaur> haskell doesn't deal with associativity as such, there is no way to tell it that some operation is associative or commutative, etc., nor does it assume the built-in ones are
13:04:15 <p0a> in language pragmas, must LANGUAGE be all caps?
13:04:20 <dmj`> p0a: no
13:04:27 <geekosaur> nor can it, since it might not be true of user defined Num instances
13:04:47 <mniip> hmm
13:04:55 <mniip> does GHC haskell have any sort of well defined operational semantics
13:05:00 <p0a> dmj`: thank you, but I suppose it's popular style ?
13:05:21 <dsal> p0a: I like hlint/stylish-haskell  as at least offering some guidance.
13:05:22 <geekosaur> p0a, it helps them stand out, which is a good thing for those reading the code
13:05:38 <dmj`> p0a: yea, but not required. You can also put all pragmas on the same line too. Also not popular, but allowed.
13:06:06 <inkbottle> :t Data.Attoparsec.Text.parse Data.Attoparsec.Text.hexadecimal "10" -- the output is `Partial _`. How do I use it; I've tried `>>= \f -> f "0"` but without success
13:06:08 <lambdabot> error:
13:06:08 <lambdabot>     • Couldn't match expected type ‘Data.Text.Internal.Text’
13:06:08 <lambdabot>                   with actual type ‘[Char]’
13:06:36 <dsal> inkbottle: You don't generally just use a bit of a parser on its own.
13:06:40 <geekosaur> mniip, (in)famously no
13:06:49 <dmj`> p0a: Haskell really lacks any kind of deeply-held conventions, nothing is really enforced in this regard. You have to be flexible, but some people are more anal than others. 
13:06:53 <mniip> right...
13:06:59 <mniip> maybe that should be a thing?
13:07:14 <mniip> not for the purposes of the average user,
13:07:26 <mniip> but for the purpose of formal verification of low level libraries written against ghc
13:07:26 <tdammers> p0a: haskell lists are "lazy": when you say 1 : 2 : 3 : 4 : 5 : [], and then only get the first element, the rest of it won't be evaluated at all.
13:07:34 <p0a> dmj`: thank you
13:07:41 <tdammers> > take 2 [1,2,3,undefined] -- doesn't crash
13:07:44 <lambdabot>  [1,2]
13:07:59 <tdammers> and this allows us to do things like recursively defined infinite lists
13:08:20 <p0a> tdammers: okay, thank you. undefined :: a can't be evaluated if I remember
13:08:20 <tdammers> > let xs = 1 : xs in take 10 xs
13:08:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:08:38 <tdammers> or infinite lists using plain old list syntax sugar:
13:08:43 <tdammers> > take 5 [1..]
13:08:44 <geekosaur> it can be "evaluated", it just throws
13:08:45 <lambdabot>  [1,2,3,4,5]
13:08:56 <__monty__> mniip: Sure, would be awesome if most or even many languages had a formal description of semantics.
13:09:03 <inkbottle> dsal: I was just experimenting from the Data-Attoparsec-Text page; and I was wondering how to use the so called returned continuation they speak about
13:09:07 <geekosaur> > take 2 [1,undefined] -- boom
13:09:12 <lambdabot>  [1,*Exception: Prelude.undefined
13:10:04 <tdammers> and you can also do something like mapM_ putStrLn (repeat "hello") (though not in lambdabot), and it'll just run forever, in constant space
13:10:21 <hololeap> @src cata
13:10:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:10:32 <tdammers> lisp's cons lists can't do that, because lisp evaluates the entire list before passing it to anything
13:10:34 <mniip> maybe there could be like several formal machines gradually getting more and more hardware level that could be formally proven to be models of each other in sequence
13:10:45 <mniip> and then you could pick the level of abstraction wrt which you're trying to verify
13:10:57 <mniip> with like, haskell's denotational semantics at the top
13:11:15 <inkbottle> "To resume the parse, pass more data to the given continuation." But I can't find how to really do it
13:12:35 <dsal> inkbottle: That's not generally how you'd do it.  You'd normally use   A.parseOnly (your parser here) (your input here) 
13:13:41 <dsal> If you're wanting to stream data, you might consider something like conduit, which has some good attoparsec integration.  I use it for a streaming binary protocol.
13:13:48 <inkbottle> Of course, but since they speak about the continuation in the doc page I wanted to try it (I stumbled upon the case using parse instead of parseonly, by mistake)
13:14:20 <mniip> inkbottle, you just invoke the continuation with more text
13:14:33 <inkbottle> OK, I try that
13:14:46 <hahahahaskell> > let xs = 1 : xs in take 10 xs
13:14:48 <dsal> Ah, well, the result type might give you Partial (i -> IResult i r)	which wants more inputs.
13:14:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:14:50 <hahahahaskell> how does this even work?
13:15:03 <dsal> hahahahaskell: It's a list of 1 followed by itself.
13:15:27 <hahahahaskell> how does it not terminate? this is like set of all set
13:15:41 <dsal> What do you mean?  It's an infinitely long list.
13:15:48 <dsal> It contains every 1 ever conceived.
13:16:01 <mniip> xs is an infinite list
13:16:08 <mniip> take 10 xs -- is a list of 10 elements
13:16:24 <inkbottle> mniip: I've tried: parse hexadecimal "10" >>= \f -> (f "0"); which doesn't work, I've tried many other things too, unsuccessfully
13:16:29 <p0a> and that is a reason to have these kinds of lists instead of the ones you spoke of hahahahaskell 
13:16:51 <p0a> because if list concatenation was O(1) you'd need to store the length of the list (and therefore not be able to speak of infinite lists)
13:16:53 <dsal> > let fibs = 1: 1 : zipWith (+) fibs (tail fibs)  in   take 7 fibs
13:16:56 <lambdabot>  [1,1,2,3,5,8,13]
13:17:02 <fizbin> > let xs2 = 1 : map (+1) xs2 in take 10 xs2
13:17:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:17:17 <fizbin> dsal: I was going to build up to that, slowly.
13:17:27 <dsal> sorry.  forget I said that.
13:17:37 <fizbin> I mean, that's the next step.
13:18:19 <hahahahaskell> so instead of thinking of list as arrays, i should think of list as some function f that defines how a list is constructed
13:18:30 <mniip> inkbottle, seems to work for me
13:18:48 <inkbottle> mniip: okay, thanks
13:18:50 <mniip>  >  case parse hexadecimal "10" of Partial f -> case f "0" of Partial g -> g ""
13:18:51 <mniip> Done "" 256
13:19:16 <dsal> hahahahaskell: Very much not like arrays, but you don't even need to think function per se.  That example of all 1s is just a simple definition.
13:19:24 <fizbin> hahahahaskell: Well, the thing is that every value in haskell is sort of like that (that is, a function that constructs the value) until you look at it because of laziness.
13:19:57 <fizbin> hahahahaskell: Lists it's best to think of as singly linked lists.
13:20:04 <mniip> hahahahaskell, it is useful to think about haskell values symbolically, as actual strings of code
13:20:10 <mniip> because that is how the semantics is defined
13:20:20 <fizbin> Except that what's on the other end of the link isn't known until you go follow that.
13:21:01 <hahahahaskell> i've heard that its possibly to "inline" or do text replacement when doing haskell afaik, this is why haskell uses = to define a function? because lhs is equivalent to doing rhs, but taking this interpretation means that i am recursively calling take 10 on some infinite list
13:21:08 <mniip> head (let xs = 1 : xs in xs) = head (let xs = 1 : xs in 1 : xs) = head (1 : let xs = 1 : xs in xs) = 1
13:21:27 <mniip> what you're saying is called referential transparency
13:21:34 <solonarv> hahahahaskell: no, you are not *recursively* calling 'take 10' on an infinite list
13:21:41 <solonarv> you are calling 'take 10' *once*
13:21:50 <mniip> when you say 'f = ...' that means you can substitute '...' anywhere you use 'f'
13:22:24 <hahahahaskell> yea that what confused about that example, if i replaced take 10 xs with xs ,,,, then it kinda explodes
13:22:42 <merijn> fizbin: Describing laziness as a "function" is needlessly confusing because it's an operational detail and now you've given it a name the clashes with *actual* functions
13:22:44 <solonarv> what makes you think that's a valid replacement to perform, though?
13:23:36 <p0a> I've read of something similar before
13:23:41 <fog> :t (!!)
13:23:43 <lambdabot> [a] -> Int -> a
13:23:58 <p0a> I think what they're trying to say is that since haskell is pure, its data structures are algorithmically determined (and are thus like functions f(n) = n+1 etc)
13:24:17 <p0a> I'm talking about instances of data, not data structures themselves
13:24:42 <merijn> p0a: Functions are functions, though and everything else is...not a function
13:24:52 <p0a> merijn: note `algorithmically determined'
13:25:07 <fog> as in, not effects
13:25:11 <mniip> hot take: the only reason data aren't functions is because we care about normal forms
13:25:21 <fizbin> merijn: I suppose that's fair. I guess a better way to describe it is that laziness means that haskell surprises newcomers with the order in which it does things.
13:26:04 <p0a> merijn: the only reason I Tried to explain hahahahaskell's point of view is because I vaguely recall reading that (the thing they said) before in a haskell tutorial
13:26:20 <dsal> There are a lot of bad haskell tutorials.
13:26:21 <p0a> so I think it's some sort of misconception/aphorism
13:26:24 <fog> what, not completely evaluating an infinite lists first?
13:26:27 <dsal> I kept trying to eat monads for months...
13:26:48 <mniip> dsal, bruh I had an epiphany about monads last week and I've been doing haskell for 6 years
13:26:53 <mniip> :)
13:26:57 <fog> ooh, what was it?
13:27:03 <solonarv> mniip: now I'm curious
13:27:04 <dsal> I expect many more over the next several years.
13:27:06 <fizbin> E.g. in the (let xs = 1 : xs in take 10 xs) case, haskell doesn't finish making all of what xs is before doing the "take" bit, whereas people coming from non-lazy languages are very surprised by that behavior.
13:27:22 <mniip> monads are just points in the lax subcategory of the cbiategory of categories
13:27:26 <mniip> bicategory
13:27:39 <fog> oh, that....
13:27:42 <dsal> > let xs = undefined : xs in take 0 xs
13:27:44 <lambdabot>  []
13:27:46 <dmj`> dsal: all about monads is good
13:27:55 <dmj`> @google all about monads
13:27:57 <lambdabot> http://www.google.com/url?q=https://wiki.haskell.org/All_About_Monads
13:27:57 <lambdabot> Title: Уведомление о переадресации
13:28:05 <solonarv> hm, that revelation is apparently beyond me
13:28:05 <mniip> >.>
13:28:09 <dmj`> russian hacker lambdabot strikes again
13:28:13 <solonarv> I'm sure I'll figure it out eventually
13:28:31 <mniip> solonarv, you can generalize monads to arbitrary bicategories
13:28:41 <fog> lax subcategory returns no google results
13:28:44 <mniip> in particular the good old monads that you know are monads in Cat
13:29:13 <oats> is lambdabot hosted in russia?
13:29:30 <p0a> yeah in petropavlovsk
13:29:34 <dsal> lambdabot sold out to Russia.
13:29:45 <fog> this is totally unintelligible https://ncatlab.org/nlab/show/bicategory
13:29:54 <inkbottle> mniip: that looks similar: (parse hexadecimal "10") >>= \f -> f ""; but I get: http://paste.debian.net/1125051/
13:29:54 <mniip> odd
13:30:11 <mniip> I also have a vps with ramnode and google picks its IP as being in turkey
13:30:14 <mniip> even though it's in NL
13:31:10 <mniip> inkbottle, why are you using >>= here
13:31:32 <fog> any ideas about lists generalized by having constraints over the input and the tail? 
13:32:36 <fog> (which basically by virtue of construction being tail first actually leads to a relation in both directions, ie constraining yet-to-be added values)
13:32:43 <p0a> so in QuasiQuotes, something like [foo|bar|] means that foo evaluates to the string containing bar?
13:33:20 <geekosaur> p0a, it means use the quasiquoter foo to parse bar
13:33:23 <inkbottle> mniip: because it is the first thing that came to my mind; and it looks similar to using 'case' as you did; and 3rd reason because IResult is like recursive, ans so I guess it even should work without a 'return'; however it doesn't, but I can't understand why
13:33:39 <geekosaur> which can be used by, for example, inline-c to embed C code in a Haskell program
13:33:58 <fog> HLists rather
13:35:35 <dsal> inkbottle: when you say "return" and ">>=", what monad are you referring to?  The parser returns a IResult.  IResult is a functor, but there's no monad outside of the parser.
13:35:36 <p0a> geekosaur: I'm not exactly sure of what's going on to be honest
13:35:40 <mniip> inkbottle, Result is not a Monad
13:36:07 <mniip> you're trying to bind the integral type that 'hexadecimal' parses and apply it to a string
13:36:12 <inkbottle> dsal: mniip: my mistake, thanks for the correction
13:36:19 <mniip> hence the error message
13:36:32 <geekosaur> p0a, inline-c package defines a quasiquoter which parses a subset of C code and arranges for it to be compiled and called in place of the quote.
13:36:54 <p0a> geekosaur: ghci complains when I enter [foo|bar|] even after the pragma. In any case I don't know what [foo|bar|] evaluates to
13:37:28 <geekosaur> p0a, do you have a quasiquoter named foo anywhere?
13:37:42 <geekosaur> (note that it must be imported from another module)
13:37:47 <mniip> p0a, you need foo :: String -> Q Expr
13:37:53 <fog> this; https://pastebin.com/raw/JZKA64jb
13:38:18 <fog> so that relations between the types of the values can be expressed as a constraint
13:38:28 <geekosaur> if you don't, perhaps you should learn more before playing with it. this is not a normal expression, it's asking the compiler to compute something at compile time and substitute it into your program
13:38:50 <geekosaur> what it computes is determined by your choice of quasiquoter (foo), which is passed bar as a parameter
13:38:56 <fog> i think it captures some interesting types depending on the constraint
13:39:00 <p0a> geekosaur: oh, okay. I get it now
13:39:23 <p0a> geekosaur: I didn't realize parseRoutes and whamlet were more than just names
13:39:57 <geekosaur> they're just names, but they're imported and have specific uses. this is all part of template haskell, which is extensible like various other aspects of haskell are
13:40:16 <p0a> geekosaur: I'm not exactly familiar but I can imagine a bit of what's going on
13:42:21 <dsal> Heh.  I've almost never used QQ.  I didn't realize that's what was happening.  Seems more useful now.
13:43:48 <p0a> hehe it's used in yesod which is what I'm hoping to learn
13:43:53 <pounce> what's the priority of infix functions?
13:44:00 <pounce> i.e. ones created by backticks
13:44:46 <geekosaur> the default is 9 for any infix function, changeable with an infix{,l,r} declaration. this also works for `names`
13:44:52 <maralorn[m]> This tutorial recommends Megaparsec.String for the Parser typesynonym. But it‘s to old and that submodule does not exist anymore. Any types where I can find a specialised Parser or do I have to define myself? https://akashagrawal.me/beginners-guide-to-megaparsec/
13:45:11 <fizbin> > take 10 $ fix $ (1:) . (1:) . (zipWith (+) <$> id <*> tail)
13:45:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:45:23 * hackage mmsyn7ukr 0.5.0.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.5.0.1 (OleksandrZhabenko)
13:45:48 <pounce> hmm? how do i do the infix{,l,r} thing
13:46:01 <geekosaur> infixl 0 `foo` -- example
13:46:27 <geekosaur> go look up infix, infixl, infixr
13:46:33 <dsal> % :i mod
13:46:33 <yahb> dsal: class (Real a, Enum a) => Integral a where; ...; mod :: a -> a -> a; ...; -- Defined in `GHC.Real'; infixl 7 `mod`
13:46:40 * geekosaur also sees he misspoke earlier, whoops
13:46:47 <pounce> thank you this solves my problem!
13:47:10 <fog> actually, this is better; https://pastebin.com/raw/agpUrFRL
13:47:54 <fog> F2List :: (a -> k -> *) -> ([a] -> k) -> [a] -> *
13:48:02 <fog> F2List :: (a -> k -> Type) -> ([a] -> k) -> [a] -> Type
13:48:23 <pounce> probably should not throw `infix 0 ..` everywhere but this seems warrented
13:49:46 <b_jonas> Hello. https://wiki.haskell.org/Lambdabot says that the lambdabot source is maintained in the darcs repo "http://code.haskell.org/lambdabot";
13:49:49 <b_jonas> but 
13:49:51 <b_jonas> @version
13:49:51 <lambdabot> lambdabot 5.2
13:49:51 <lambdabot> git clone https://github.com/lambdabot/lambdabot
13:50:23 <b_jonas> points to a different git repository. so which one of those two is the actual repository used for development, which one has the currently used source code?
13:50:49 <fog> that is, the hetrogenous values are of a type calculated according to both a new argument `x' stored in the params xs, but also information determined from the tail of these params (previously added xs) 
13:50:54 <b_jonas> int-e: ^
13:51:24 * hackage mmsyn7l 0.1.0.0 - A program and a library to modify the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.1.0.0 (OleksandrZhabenko)
13:51:36 <fog> as a way to effectively constrain the yet to be added values types
13:53:39 <fog> i guess then the instances it implements depend on each of these params f g xs. maybe there is a way to implement collections of these depending on some constraint over the params
13:53:59 <fog> i dont have an example though
13:54:55 <fog> hmm, i guess it could be simplified;
13:54:57 <fog>  F2Cons  :: f x (g xs) -> F2List f g xs -> F2List f g (x ': xs)
13:55:00 <fog> could be;
13:55:12 <fog> F2Cons  :: f x xs -> F2List f xs -> F2List f (x ': xs)
13:56:13 <fog> before i was using g = Head, to make f combine consecutive elements types
13:56:48 <fog> but i guess that could be deferred into the definition of f to make it more general
13:56:51 <solonarv> fizbin: that '<$> id' is unnecessary, btw
13:57:37 <solonarv> for functions, (<$>) is just (.), so f <$> id = f . id = f
13:58:10 <fizbin> solonarv: Right. That is cleaner, sort of.
13:59:18 <fizbin> > ((++) <*> show) "> ((++) <*> show) "
13:59:20 <lambdabot>  "> ((++) <*> show) \"> ((++) <*> show) \""
13:59:59 <solonarv> yeah, neat :>
13:59:59 <fizbin> If only there were a way to get lambdabot to just print a string plain, without quoting...
14:00:16 <solonarv> actually I think there is, but you can just use yahb instead
14:00:53 <fog> its really no good that those 2 different datatypes cant be generated automatically
14:01:01 <fog> or one from the other...
14:01:07 <solonarv> % liftA2 (*>) putStr print"% liftA2 (*>) putStr print"
14:01:07 <yahb> solonarv: % liftA2 (*>) putStr print"% liftA2 (*>) putStr print"
14:01:35 <fog> like, if f in the version with f x xs has g being used on xs, then it could be written as f x (g xs)
14:02:00 <fog> so the definition of f could be commuted into the datatype to generate the new datatype
14:02:36 <fog> but the only way to express this is to have a plethora of datatype definitions, and conversion functions witnessing the isomorphisms
14:03:06 <fog> i want to know how to write a metalanguage which solves this
14:03:48 <fog> its difficult to keep track of all these different datatypes otherwise
14:04:44 <fog> the f x (g xs) version is less general but more informative, ie that f' x xs has an f' that has a part that can be factored out into g
14:05:23 <fog> and i guess something like this can happen again and again, making ever less abstract datatypes
14:05:57 <fog> i wouldnt want to have to be confronted with having to learn this hierarchy if the first few layers were common
14:07:11 <b_jonas> Is there a table of fixity declarations in the ghc standard library? I was looking at the docs at https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/base-4.6.0.1/Control-Applicative.html#v:-60--42--62- and that one doesn't mention what the fixity of (<*>) is
14:07:31 <b_jonas> alternately, is there a lambdabot command that looks up fixities?
14:07:53 <b_jonas> I don't want to know just (<*>) in particular, I want to be able to look this up for other operators
14:10:23 * hackage mmsyn7l 0.1.0.1 - A program and a library to modify the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.1.0.1 (OleksandrZhabenko)
14:10:53 <fog> and anyway, i cant even write instances over these with a concrete function implemented as a type family
14:11:17 <fog> so then the each actual concrete instance of this needs to be written as a new datatype
14:11:54 <ephemient> :i <*>
14:11:55 <fog> eg with a constructor of type  :: f x (Head xs) -> F2List f xs -> F2List f (x ': xs)
14:12:19 <solonarv> lambdabot is not ghci
14:12:20 <fog> there is going to end up being a datatype for every function!
14:12:21 <ephemient> hmm, the equivalent in GHCi will tell you the fixity
14:12:52 <solonarv> :browse might do it
14:12:57 <solonarv> (again, in ghci)
14:13:08 <solonarv> this will show you *everything* though
14:13:22 <fog> i guess this would be solved if we solved defunctionalisation
14:14:03 <solonarv> huh, nope - it doesn't show fixities
14:14:04 <fog> so we could write instances for partially applied type family arguments to datatypes
14:14:06 <solonarv> that's annoying
14:14:10 <maerwald> lol, hack to get the cabal cache timestamp: https://git.io/JvecB
14:14:29 <maerwald> parsing binary formats with bash, yay
14:14:32 <ephemient> parenthesize everything and then let hlint warn you about unnecessary parentheses?
14:18:17 <fog> eg; https://pastebin.com/raw/FDyZt87H
14:19:17 <fog> i guess i *could* match on the defunctionalisation symbol 
14:22:47 <steevveen> Hi! I was reading my notes about Foldable and Traversable, and there one line from me that is not clear. I wonder if it is something I quoted by mistake or erroneously, or if it is legitimate. Does that rings a bell for you : "Optic Hierarchy: Iso => Lens and Prism => Traversal => Fold". I cannot wrap my head about what I meant with this line. Do
14:22:47 <steevveen> you think it makes sense ?
14:23:29 <flatmap> I try to understand the internals of an library call (https://gist.github.com/pertl/51f65bce8718056faf757e738ba2c773)
14:23:44 <flatmap> I don’t get where parameter CryptHandle comes from
14:23:52 <flatmap> it seems to come from nowhere :-P
14:24:11 <p0a> from the crypt
14:24:49 <lyxia> steevveen: look at the diagram here https://hackage.haskell.org/package/lens and https://oleg.fi/gists/posts/2017-04-18-glassery.html
14:25:12 <glguy> flatmap: it comes from openHandle
14:25:59 <glguy> bracket applies (hGetEntropy n) to the the result of openHandle where n is the unnamed Int paramter of getEntropy
14:26:05 <flatmap> ah ok
14:26:17 <flatmap> did not spot it … thanks :-)
14:26:18 <glguy> getEntropy n = bracket openHandle closeHandle (\h -> getEntropy n h)
14:26:37 <glguy> getEntropy n = bracket openHandle closeHandle (\h -> getEntropy h n)
14:26:48 <flatmap> I am also confused by the combine operator ‚.‘
14:26:55 <flatmap> the dot
14:26:57 <glguy> the author got cute in that case
14:28:12 <flatmap> thanks glguy 
15:37:01 <daydaynatation> I can't understand how the MonadIO instance is defined for ReaderT :: liftIO = lift . liftIO
15:37:14 <daydaynatation> How can it be defined by itself?
15:38:07 <Axman6> the inner liftIO  has type IO a -> m a, where as the one being defined has type IO a -> ReaderT r m a
15:38:32 <Axman6> so the inner liftIO is being used at the type of the monad the ReaderT is wrapping
15:39:05 <daydaynatation> wow ok
15:39:06 <Axman6> then lift :: m a -> ReaderT r m a
15:39:30 <Axman6> that's why the instance has the context MonadIO m => MonadIO (ReaderT r m)
15:40:37 <daydaynatation> Thanks!
15:40:40 <jle`> daydaynatation: typeclasses can be weird huh
15:40:49 <jle`> it's a similar situation for the Eq instance for Maybe a
15:40:54 <jle`> instance Eq a => Eq (Maybe a) where
15:40:59 <jle`>   Just x == Just y == x == y
15:41:04 <jle`> er
15:41:10 <jle`>   Just x == Just y = x == y
15:41:21 <jle`> 'how can it be defined by itself?' :)
15:41:35 <daydaynatation> Indeed. It definitely takes some getting used to. In a strange way this is beautiful
15:42:03 <jle`> it can be helpful to explicitly use type annotations sometimes, to know which instance is being dispatched
15:42:12 <jle`> liftIO = lift @ReaderT . liftIO @m
15:42:38 <jle`> to show that we are defining liftIO for `ReaderT r m`, by using liftIO for `m`
15:42:45 <jle`> * lift @(ReaderT r)
15:42:48 <daydaynatation> wow, type annotations! that's something new for me. I don't see it used much though
15:42:59 <jle`> ah, they're called Type Applications, sorry
15:43:13 <jle`> yeah, they're somewhat new (a couple of years?) but they can really help with readability
15:44:24 <daydaynatation> cool. is there a way to turn on and off this feature for all types?
15:44:27 <Axman6> Eq for [] is also somewhat fun to think about, it is definied in terms of itself and the instance of Eq for the values in the list: instance Eq a => Eq [a] where (x:xs) == (y:ys) = x == y && xs == ys
15:45:09 <jle`> daydaynatation: it's a tool for you to use when you write code
15:45:16 <jle`> it's not something that gets added for you :)
15:45:21 <daydaynatation> I understand that there's often recursive calls in functional programming..but that liftIO just blow my mind
15:45:27 <jle`> you can choose to write the instance as liftIO = lift @(ReaderT r) . liftIO @m
15:45:34 <jle`> yeah, in this case it's not a recursive call
15:45:40 <jle`> it's a call to a completely different function
15:45:48 <jle`> that just happens to have the same name, textually
15:46:30 <jle`> it just looks like recursion because liftIO for `ReaderT r m` has the same 'name' (series of characters you type into your text editor) as liftIO for m
15:46:38 <jle`> but they are completely different functions
15:46:45 <jle`> their similarity is only (literally) superficial
15:48:12 <daydaynatation> Maybe I can use the so called hole driven programming next time
15:48:27 <daydaynatation> I try liftIO = lift . _
15:48:39 <Axman6> what did it tell you?
15:49:06 <daydaynatation> Haven't tried it yet. It should tell me the type it expects in that hole right?
15:49:13 <Axman6> yep
15:49:58 <daydaynatation> I've seen people use it, just I never realize it's related to types. My mind was fixed on recursion
15:49:59 <Axman6> better question is though, what type do you expect it to have?
15:52:08 <maralorn[m]> This megaparsec Parser supposed to parse "100%" or "34%" or something like that to Int feels clumsy. Does anyone have a tip to make it nicer? https://termbin.com/rem5
15:52:59 <maralorn[m]> I mean isn‘t there something like "parseInt ::  Parser Int"?
15:53:22 <dsal> L.decimal
15:53:43 <dsal> https://hackage.haskell.org/package/megaparsec-4.4.0/docs/Text-Megaparsec-Lexer.html
15:53:52 <maralorn[m]> dsal: What is the "L"?
15:54:05 <dsal> percentParser = L.decimal <* "%"
15:54:28 <maralorn[m]> uh …
15:54:30 <jojoz[m]> maralorn: qualified import. `import qualified Text.Megaparsec.Lexer as L`
15:54:42 <maralorn[m]> I ignored the Lexer Module. m(
15:54:50 <maralorn[m]> thx.
15:55:00 <jle`> it can be useful when you're doing lexing :)
15:55:55 <koala_man> maralorn[m]: you're not planning backtrack and parse a regular number of this fails, right?
15:56:06 <koala_man> *to, *if
15:57:13 <maralorn[m]> koala_man: No, their is either a percentage or something very wrong.^^
15:57:17 <maralorn[m]> *there
15:58:03 <maralorn[m]> Also any hints on what is the easiest way of give me the first substring this parser parses succesfully?
15:58:46 <maralorn[m]> I have a solution with Replace.Megaparsec.sepCap but it feels like overkill.
15:58:57 <jle`> like, searching for it in a string?
15:59:22 <jle`> you can use tails maybe, and mapMaybe
16:00:31 <maralorn[m]> Hm, okay.
16:03:50 <maralorn[m]> Then my solution actually is fine.
16:16:07 <daydaynatation> Can we set verbosity level in ghci? I :info MonadTrans, it only gives me limited instances
16:17:02 <Axman6> it'll only give you instances which are visible from the modules you have in scope
16:18:09 <daydaynatation> I see
16:19:54 <iqubic> For those that know category theory, is Const the closest thing haskell has to a forgetful functor?
16:20:15 <dolio> No.
16:21:28 <iqubic> Why do you say that?
16:22:16 <dolio> Forgetful functors occur when you have something like a category built by equipping types with extra structure.
16:22:23 * hackage accelerate-kullback-liebler 0.1.1.0 - Kullback-Liebler divergence  https://hackage.haskell.org/package/accelerate-kullback-liebler-0.1.1.0 (vmchale)
16:22:48 <iqubic> Ah. And what is Const then?
16:23:07 <dolio> So, you can have a category of monoids, where the objects are types equipped with monoid structure, and arrows are monoid-structure preserving functions between them.
16:23:14 <iqubic> Sure.
16:23:28 <dolio> Then a forgetful functor maps those back to the ordinary category of types, forgetting the monoid structure.
16:24:04 <iqubic> Right. And the left adjunt of that forgetful functor is the free monoid.
16:24:10 <dolio> Yeah.
16:24:15 <iqubic> Cool
16:25:01 <dolio> I don't know that there's a particular designation that best describes Const.
16:25:40 <iqubic> I see. I thought that the phantom type allowed it to be forgetful.
16:25:51 <dolio> It's the right adjoint of the colimit functor, but it's a pretty big stretch to describe it as 'forgetful'.
16:26:20 <mniip> diagonal functors can be described as forgetful in a sense
16:26:42 <iqubic> I've not yet learned about (co)limits or (co)cones
16:26:53 <mniip> you can identify C with a subcategory of C^J of functors that map everything to identity
16:27:30 <mniip> then forgetting the mapping property gives C -> C^J
16:29:15 <dolio> I guess.
16:29:47 <dolio> That seems a lot like going out of your way to come up with a way of describing something as 'forgetful', which you can probably always do. :)
16:30:28 <iqubic> Sometimes I forget what that term means.
16:30:55 <iqubic> I am forgetful
16:56:19 <jle`> hololeap: not sure if you hav already moved past this, but i thought a bit more about the adjunction between Free ((,) r) and Cofree ((->) r), and i realize that leftAdjunct is essentially tabulate, and rightAdjunct is essentially index
16:57:08 <jle`> hololeap: in the context of treeting Cofree ((->) r) a as `Moore r a`, rightAdjunct is essentially feeding in a list of r's to the moore machine and observing the final result
16:57:27 <jle`> hololeap: and leeftAdjunct is generating a moore machine based on what should be observed on each branch
17:01:45 <sim590> Why does (+1) $ const 5 4 works, but ((+1) . const) 5 4 doesn'T ?
17:02:06 <Axman6> expand the definition of (.)
17:02:14 <Axman6> @src (.)
17:02:14 <lambdabot> (f . g) x = f (g x)
17:02:37 <p0a> sim590: because of currying, a 2-argument function is really a 1-argument function
17:02:41 <Axman6> (I prefer f . g = \x -> f (g x))
17:02:45 <p0a> sim590: so composition doesn't work as you'd think 
17:03:40 <jle`> ((+1) . const) 4
17:03:53 <jle`> ((+1) . const) 5 4    -- sorry
17:03:55 <jle`> let's expand this
17:04:02 <sim590> Because, now I can't write `scanl (f . const) 0 [1..] for some `f :: Integer -> Integer`.
17:04:10 <jle`> ((+1) . const) 5 = (+1) (const 5)
17:04:24 <jle`> which is const 5 + 1
17:04:38 <jle`> so (((+1) . const) 5) 4 is (const 5 + 1) 4
17:04:55 <sim590> OKi, I get it, but what I just really want is to ignore the second argument of my scanl function parameter without making a lambda explicitely.
17:05:11 <sim590> I thought that const would do it
17:05:20 <Axman6> I would do it with a lambda personally :\
17:06:02 <Axman6> there's nothing special about const, it has type a -> (b -> a), so if you use f . const, then that f better expect something of type b -> a
17:06:17 <jle`> sim590: so you want to write scanl (\x _ -> f x) ?
17:06:18 <Axman6> :t \f -> const . f
17:06:19 <lambdabot> (a1 -> a2) -> a1 -> b -> a2
17:06:31 <sim590> jle`: yeah
17:06:40 <jle`> sim590: that looks like (\x -> const (f x)), if you really wanted to avoid the point
17:06:40 <ChaiTRex> @pl \ x _ -> f x
17:06:40 <lambdabot> const . f
17:06:52 <sim590> Oh
17:06:56 <jle`> or const . f i suppose, but that's arguably less readable
17:08:08 <sim590> I wanted to avoid tha lambda, so just using (const . f) is what I meant to do.
17:08:14 <p0a> you can do ((+1) . (const 5)) 4
17:08:18 <sim590> I just didn't do it in the good order.
17:08:32 <jle`> ah, is this a code obfuscation challenge maybe/
17:08:48 <sim590> hah. I just thought to safe space on the line ;)
17:09:22 <jle`> > length "\x _ -> f x"
17:09:24 <p0a> generally . is quick to get confusing so unless it's trivial try to avoid it
17:09:25 <Axman6> code is for people, not for storage on disks
17:09:26 <lambdabot>  <hint>:1:11: error:
17:09:26 <lambdabot>      lexical error in string/character literal at character ' '
17:09:33 <jle`> > length "const . f"
17:09:35 <lambdabot>  9
17:09:45 <jle`> > length "\\x _ -> f x"
17:09:47 <lambdabot>  11
17:09:54 <maerwald> any haskeller tried Nim? :>
17:10:15 <jle`> can't argue with that
17:10:19 <Axman6> > length "\\x _->f x"
17:10:22 <lambdabot>  9
17:10:44 <jle`> i guess you can
17:11:52 <sim590> I think that const . f is pretty explanatory once you know what const does. It ignores the second argument.
17:12:20 <jle`> hm. i've been reading and writing haskell fo ralmost 10 years
17:12:27 <jle`> and const . f still takes me a few seconds to think through
17:12:33 <jle`> whereas \x _ -> f x, i understand immediately
17:13:02 <jle`> if i saw `const . f`, i could figure out what it means, but it would take me a while. i'd have to think about the type of const, the type of f, etc.
17:13:06 <Axman6> I'd echo what jle`said
17:13:08 <jle`> and figure out how all the pieces fit together
17:13:26 <jle`> if i saw `\x _ -> f x`, there is pretty much no thinking i'd have to do to immediately understand it
17:14:28 <jle`> `const . f` is not a mystery to me, but it's still takes conscious effort/struggle
17:15:41 <p0a> I think you can also do \_ -> f right?
17:15:50 <dsal> Can profiling be enabled at runtime?
17:16:08 <ChaiTRex> p0a: That's const f
17:16:08 <dsal> (like, late at runtime)
17:16:15 <p0a> ChaiTRex: right, that's the other way around
17:22:10 <sim590> p0a: I want to ignore the second argument, not the first, so I don't hink we can do (\_ -> f).
17:24:18 <sim590> jle`: The only difference I see between both ways is that one doesn't "shadow" the effect of getting rid of the second argument, while the other relies on the reader to know that const does it. You say you'd have to think about types, but that's the same with an explanatory lambda, no? The lambda doesn't tell you the types. When you see (\x _ -> f x), you don't know what is the type of x just by
17:24:20 <sim590> looking at it just like in the form of (const . f).
17:25:09 <jle`> for `const . f` i'd have to think about how const can be a function
17:25:13 <jle`> that it can be used with (.)
17:25:45 <alc> 513005777 is a prime number?
17:26:25 <jle`> sim590: requiring the reader to know things isn't necessarily a bad thing. i'm not talking about the knowledge burden, but the burden of thinking it through once you see it in code you are newly reading
17:27:17 <jle`> even someone with perfect knowledge of all haskell will see `\x _ -> f x` as more readable than `const . f`
17:28:03 <jle`> just like knowing how multiplication works, it's easier to read `15` than `3 * 5`
17:28:12 <jle`> yes, 3 * 5 requires knowledge about multiplication, which most people have
17:28:21 <jle`> but i'm not talking about the knowledge burden
17:28:44 <phanimahesh[m]> Const is a function that ignores second argument. It is known.
17:29:10 <phanimahesh[m]> I admit it takes a second or two to read const.f
17:29:26 <phanimahesh[m]> But I don't think it is hard to read at all
17:29:28 <jle`> to understand what `const . f` does, you have to understand how const works and also how . works
17:29:32 <jle`> it's definitely not hard to read
17:29:40 <jle`> but it's harder to read than \x _ -> f x
17:29:53 <jle`> it's like 15 vs. 3 * 5
17:29:54 <Logio> const . f is clearer to me in intent, \x _ -> f x looks like a hack thrown together
17:30:17 <jle`> yeah sure, you can write (3 * 5) instead of 15, and it might take a second to read 3*5.  but 3*5 is not objectively hard to read
17:30:44 <Logio> but then I'm a mathy person, so const and . make sense to me generally 
17:30:48 <jle`> or maybe 1 * 5 is a better analogy
17:31:30 <phanimahesh[m]> Barely, but yes. Depends on your experience with reading Haskell too. I have very little of it, so the lambda is slightly easier to see.
17:31:48 <phanimahesh[m]> But anyone reading Haskell must know how composition operates
17:31:53 <jle`> i don't think there is any amount of haskell reading experience that will make `const . f` easier to read than `\x _ -> f x`
17:31:59 <phanimahesh[m]> And const is a basic function too
17:32:18 <jle`> if anything, having reading experience will allow you read both of these easier
17:32:40 <jle`> it won't magically make const . f  easier to read, and \x _ -> f x harder to read
17:33:01 <phanimahesh[m]> If it's in a chain of compositions I would strongly prefer const.f
17:33:03 <p0a> but tie_laces . put_on_shoes is fine
17:33:14 <p0a> I guess I meant to say tieLaces . putOnShoes
17:34:12 <phanimahesh[m]> Plugging in an anonymous lambda into a composition chain is ugly.
17:37:24 <jle`> ugly maybe, but I'm talking about readability 
17:38:11 <phanimahesh[m]> Ugliness doesn't matter outside readability
17:38:43 <phanimahesh[m]> Ugly code is ugly because it is harder to read.
17:39:28 <p0a> empty statements phanimahesh[m] 
17:39:37 <Axman6> data Void
17:40:08 <phanimahesh[m]> Personal opinions.
17:40:50 <jle`> so are you saying that const . f is more readable? 
17:41:26 <phanimahesh[m]> In a composition chain, yes. Isolated, I will prefer the lambda form.
17:42:39 <phanimahesh[m]> Because const and . are simple functions. I don't have universal preference against lambdas.
17:43:40 <phanimahesh[m]> If it was const <$> f or some other variant I would have definitively called it ugly in isolation, and likely to be ugly in chains too
17:44:01 <Axman6> :t \f g -> f . const . g
17:44:03 <lambdabot> ((b -> a1) -> c) -> (a2 -> a1) -> a2 -> c
17:44:09 <phanimahesh[m]> Because I need to parse fmap. Carefully see which version of fmap takes effect
17:44:32 <phanimahesh[m]> With const and . the definitions are simple and clear
17:45:05 <Axman6> const <$> f <*> g is a pretty common idiom (a.k.a f <* g) and arguably much more understandable than const . f
17:45:24 <phanimahesh[m]> Const ignores second argument. Returns first. From there there are not many things const.f can do.
17:45:30 <jle`> ah. in this case we are talking about scanl (\x _ -> f x), which isn't a part of a chain 
17:48:13 <phanimahesh[m]> Environment matters. Now I need to remember what scanl does. At my current level of experience I strongly prefer lambdas as arguments to filter, scanl etc. Unless the lambda just writes out a composition by hand.
17:49:33 <phanimahesh[m]> Rather the argument order for scanl
17:50:00 <phanimahesh[m]> If I was writing a lambda I would use an underscored variable name to help me read it easier
17:50:22 <phanimahesh[m]> That advantage is lost when it's just plain _ or const.f
17:51:27 <phanimahesh[m]> Between those it's a matter of preference. Replace _ with _xs or similar and the lambda form becomes better for readability. It carries more information.
17:51:50 <jle`> yeah, it's purely a case by case basis and you can't really make generalizations
17:51:51 <phanimahesh[m]> If I don't have to look up docs every time I read that's a win.
17:53:09 <Axman6> you can _always_ make generalisations
18:19:20 <srid> Is this an instance of abusing free monads? https://www.srid.ca/tidbits/dhall-toml-free-monad.html
18:19:54 <srid> free monads to incrementally construct a barbie record
18:20:55 <alc`> to detect prime number, https://paste.ubuntu.com/p/VRBJdzx2HQ/
18:21:02 <alc`> where it's wrong?
18:32:53 <dolio> If it weren't wrong, then primality testing would be possible in log time?
18:33:06 <dolio> Or linear depending on how you measure number size.
18:36:57 <dolio> Also `isPrime 7 == False`
18:41:02 <alc`> dolio: the haskell wiki about prime number definition is written by math, I don't understand
18:41:08 <alc`> that math symbols...
18:41:45 <alc`> I google it, there're two ways, one is mod it with 6, if it's 0 2 3 4, then it's not prime
18:41:57 <alc`> another way is about sqrt 
18:43:24 <alc`> the silly way is div all the number from 2 to n, that is impossible
18:44:04 <alc`> should this be a common knowlege? 'cause it's famous on math
18:50:04 <evelyn> learn the 'math symbols' if you don't understand them
18:50:21 <Ailrun[m]> alc`: It's famous since for a big number, determining whether that number is prime or not takes long time.
18:55:39 <Axman6> alc`:  you might also want to try using quotRem:
18:55:51 <Axman6> > let  digits 0 acc = acc; digits n acc = case quotRem x 10 of (y,r) -> digits y (r:acc) in digits 1234567 []
18:55:57 <lambdabot>  mueval-core: Time limit exceeded
18:56:36 <Axman6> > let  digits 0 acc = acc; digits n acc = case quotRem n 10 of (y,r) -> digits y (r:acc) in digits 1234567 []
18:56:38 <lambdabot>  [1,2,3,4,5,6,7]
18:59:12 <alc`> > let f x = 0 `elem` (x `mod` <$> [2..(x-1)])
18:59:14 <lambdabot>  <hint>:1:29: error: parse error on input ‘<$>’
18:59:46 <alc`> > let f x = 0 `elem` (fmap (mod x) [2..(x-1)])
18:59:48 <lambdabot>  <no location info>: error:
18:59:48 <lambdabot>      not an expression: ‘let f x = 0 `elem` (fmap (mod x) [2..(x-1)])’
19:04:56 <alc`> f x = 0 `notElem` (fmap (mod x) [2..(x-1)])
19:07:19 <dsal> alc`: you shouldn't need a single if statement to write that code.  It makes it a lot harder to follow.
19:08:18 <dsal> Last time I needed primes, I just made a list of all prime numbers (defined by numbers not divisible by numbers in my list)
19:10:41 <alc`> Axman6: your way is better, 123 to [1,2,3]
19:11:28 <alc`> dsal: it's a train in codewars https://www.codewars.com/kata/5262119038c0985a5b00029f/train/haskell
19:14:10 <Axman6> phadej had a pretty nice, lazy generator of prime numbers
19:14:30 <MarcelineVQ> you'll want to look up how to write the sieve of erasothenes in haskell
19:14:41 <dsal> alc`: n `elem` primes -- *almost* works, but you should need to stop looking when you get a value larger than your number.
19:15:50 <MarcelineVQ> It's very efficient and not especially complicated once explained
19:15:53 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000
19:15:57 <lambdabot>  104743
19:40:30 <Axman6> > let primes = (2 :: Int):3:5:7:filter isPrime (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in drop 10000 primes
19:40:34 <lambdabot>  [104743,104759,104761,104773,104779,104789,104801,104803,104827,104831,10484...
19:41:06 <ephemient> > unfoldr (fmap (swap . (`quotRem` 10)) . mfilter (/= 0) . Just) 1234567  -- pointless
19:41:09 <lambdabot>  [7,6,5,4,3,2,1]
19:41:22 <topos> do complete pragmas work with pattern synonyms yet?
19:41:33 <hololeap> Axman6: care to explain that one?
19:42:00 <Axman6> ask phadej =)
19:42:19 <hololeap> scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4] <- this part in particular
19:42:20 <Axman6> > scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]
19:42:22 <lambdabot>  [11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,101...
19:42:51 <Axman6> I believe that filters out a bunch of known non-primes
19:43:22 <hololeap> hm strange
19:43:23 <ephemient> drops multiples of 2, 3, 5
19:44:04 <ephemient> could extend the wheel to exclude multiples of 7 or whatever, but that would make it larger
19:44:52 <hololeap> how does (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]) filter out multiples of 2, 3, 5 ?
19:47:16 <ephemient> liftM2 (+) [0, 30..] [11, 13, 17, 19, 23, 29, 31, 37, 41]
19:47:20 <ephemient> > liftM2 (+) [0, 30..] [11, 13, 17, 19, 23, 29, 31, 37, 41]
19:47:22 <lambdabot>  [11,13,17,19,23,29,31,37,41,41,43,47,49,53,59,61,67,71,71,73,77,79,83,89,91,...
19:47:23 <day> why are functions like these https://pastebin.com/RJgG8jE8 with 'non exhaustive patterns' allowed? 
19:48:01 <MarcelineVQ> sometimes you know better than the compiler, in knowing what input you'll reall put into a function, so writing more is just noise. Though I don't agree with that pov.
19:48:12 <ephemient> the scanl just makes use of the sequential differences in that cycle of 30
19:48:27 <hololeap> ok i see that
19:48:53 <day> MarcelineVQ: I thought a major point of 'pure' functions was to remove the 'the programmer knows better' part from the equation :|
19:49:01 <hololeap> but cycling the list won't miss any primes?
19:49:06 <MarcelineVQ> No but that is a major point of total functions
19:49:30 <day> well either way that function presents itself as pure, but isn't
19:49:32 <ephemient> hololeap: it's only skipping multiples of 2,3,5 starting from 11. it can't possibly miss any primes
19:50:02 <ephemient> if you accept bottom as a value, they're still pure functions
19:50:25 <MarcelineVQ> You can make it a compiler error to miss any cases if you feel strongly about it
19:50:43 <hololeap> i guess i
19:51:00 <hololeap> *i'd have to work it out on paper, but i belive you ;)
19:51:43 <Axman6> > scanl (+) 0 $ cycle [2,4,2,4,6,2,6,4]
19:51:46 <lambdabot>  [0,2,6,8,12,18,20,26,30,32,36,38,42,48,50,56,60,62,66,68,72,78,80,86,90,92,9...
19:51:57 <day> i didnt know abut the difference between total and pure
19:52:37 <ephemient> that's how the sieve of eratothenes works: list all numbers [2..], cross out all multiples of 2 after 2, all multiples of 3 after 3, all multiples of 5 after 5, etc.
19:52:56 <day> so a function not being defined for certain inputs means it can still be pure?
19:53:52 <ephemient> it's "defined" as being ⊥ in all other cases
19:54:28 <day> ⊥ means undefined?
19:54:37 <MarcelineVQ> in that you always get the same result for the same inputs
19:54:39 <hololeap> day: in general partial functions ("pure" functions that can throw an error) are the exception rather than the norm, and you should (hopefully) know exactly which functions are partial and use them sparingly
19:54:49 <ephemient> https://wiki.haskell.org/Bottom
19:55:19 <MarcelineVQ> -Werror=incomplete-patterns  -Werror=incomplete-uni-patterns  turns missing cases into compiler errors
19:55:48 <day> ah
19:56:33 <ephemient> in practice it's equivalent to let f x | x == 'a' = 1 | otherwise = error "Non-exhaustive patterns in function f" in f 'a'
19:56:53 <hololeap> there are also some total function replacements for partial functions out there. for instance, listToMaybe from Data.Maybe can be used instead of head
19:57:27 <hololeap> so, instead of throwing an error like `head` does on an empty list, it returns a Nothing instead
19:58:02 <ephemient> or Data.List.NonEmpty.head which (type-checked) cannot take an empty list argument
20:06:48 <hololeap> > sum [2,4,2,4,6,2,6,4]
20:06:50 <lambdabot>  30
20:12:41 <fog> ok, this compiles; https://pastebin.com/raw/JWiYRD1i
20:12:58 <fog> thats the instance matching the defunctionalisation symbol from before
20:15:17 <fog> really it was for use with HeadSym
20:16:01 <fog> so nets could have as many function weights at the neurons as edges to the neurons of the previous layer 
20:18:37 <fog> where the same Nat parameter at some position in the type list parameter to a FList is used in as the parameter of two different (adjacent) values datatype constructors
20:20:01 <fog> in one case to specify the length of the list of neurons, and the other to specify the length of the list of weights at each of the next layers neurons
20:20:42 <fog> neurons per layer and edges per neuron
20:48:29 <koz_> :t (^)
20:48:30 <lambdabot> (Integral b, Num a) => a -> b -> a
21:00:24 * hackage conduino 0.2.2.0 - Lightweight composable continuation-based stream processors  https://hackage.haskell.org/package/conduino-0.2.2.0 (jle)
21:20:27 <alc`> how to match negative number in patter matching?
21:21:47 <glguy> > case 3-9 of -6 -> "yay"
21:21:49 <lambdabot>  "yay"
21:31:31 <pie_[bnc]> trying and failing to search my logs for some floating point related papers people recommended me
21:31:35 <pie_[bnc]> but i found this gem
21:31:37 <pie_[bnc]> #haskell.log:Oct 02 17:21:07 <Athas>    Just use floats.  Do not tempt the wrath of Kahan.
21:35:54 <jle`> floats. not even once
21:40:19 <koz_> Is there a more concise way to say "(n == n' && k == k') || (n > n' && k > k')
21:40:21 <koz_> "?
21:40:46 <MarcelineVQ> >= ?
21:40:48 <sarahzrf> that looks wrong
21:40:51 <sarahzrf> are you sure that's what you mean?
21:41:26 <koz_> sarahzrf: Yes, I am _very_ sure that's what I mean.
21:41:46 <koz_> It's a comparison of two two-component data types.
21:42:04 <sarahzrf> you don't want the lex ordering?
21:42:06 <jle`> hm. compare n n' == compare k k' ?  except also not the gt case
21:42:26 <koz_> MarcelineVQ: n >= n' && k >= k' could give me, for example n == n && k > k', which wouldn't be right.
21:42:39 <jle`> are n and k numbers here?
21:42:43 <koz_> jle`: Correct.
21:42:48 <koz_> Non-negative ones to boot.
21:43:23 <koz_> sarahzrf: It's not an ordering function for Ord, if that's what you're wondering.
21:43:43 <sarahzrf> 👍
21:43:53 <ephemient> (n, k) == (n', k') || not (inRange ((0, 0), (n', k')) (n, k))
21:43:57 <ephemient> maybe
21:44:05 <koz_> ephemient: Lol, I said _more_ concise. :P
21:44:29 <sarahzrf> just thinking that if it *was* a mistake, it could be a nasty thing to track down :)
21:44:56 <koz_> sarahzrf: Yeah, that's why I wrote it out in this form first.
21:45:13 <chambln> (n, k) == (n', k') || n > n' && k > k'
21:45:31 <koz_> chambln: Yeah, that is a bit better.
21:45:40 <chambln> Arguably less readable though
21:46:37 <ephemient> `inRange` might be more readable if it were a data type with an Ix instance, e.g.
21:46:54 <ephemient> p == q || not (inRange (minBound, q) p)
21:47:23 <ephemient> but of course that depends on what your data type is
22:06:06 <chambln> Will ‘(n, k) == (n', k')’ short circuit in the same way ‘n == n' && k == k'’ does?
22:06:52 <chambln> So if n /= n', will k and k' be evaluated?
22:07:39 <jle`> yea
22:07:48 <jle`> > (1, undefined) == (3, undefined)
22:07:51 <lambdabot>  False
22:08:31 <Axman6> pie_[bnc]: that's fantastic
22:08:42 <chambln> Cool
22:08:47 <jle`> chambln: since (a, b) == (c, d) = a == b && c == d i think
22:09:17 <jle`> evaluation by substitution and all that jazz
22:10:32 <chambln> So when tuples are compared for equality, they are first expanded into a series of comparisons of corresponding elements?
22:10:55 <pie_[bnc]> for those who dont know who kahan is, i dont really know either but aparently hes very good at numerics, also https://people.eecs.berkeley.edu/~wkahan/
22:11:13 <pie_[bnc]> a commonly linked paper, which i dont remember the content of, but is quite good https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf
22:11:27 <pie_[bnc]> "How Futile are Mindless Assessments of Roundoffin Floating-Point Computation?"
22:12:07 <pie_[bnc]> on which note, there's some relatively known tool that does some analysis of floating point algorithms or tranformations or something but I cant remember the name of it...
22:13:09 <ephemient> this guy's been pushing for a floating-point replacement for ages... http://www.johngustafson.net/unums.html
22:14:31 <pie_[bnc]> hm i might be thinking of https://herbie.uwplse.org/ but im not sure
22:14:45 <Axman6> yeah unums are pretty cool
22:15:05 <Axman6> pie_[bnc]: he wrote IEEE-754
22:15:15 <pie_[bnc]> Axman6: oh shit son
22:15:19 <pie_[bnc]> Axman6: kahan did?
22:15:19 <Axman6> yah
22:15:24 <Axman6> yes
22:15:45 <Axman6> "Kahan was the primary architect behind the IEEE 754-1985 standard for floating-point computation (and its radix-independent follow-on, IEEE 854)."
22:17:36 <Axman6> also "... who received the Turing Award in 1989 for "his fundamental contributions to numerical analysis""
22:17:37 <koz_> ephemient: Yep, I'm a big fan of the unum efforts.
22:20:13 <pie_[bnc]> `So, for example, one section of Gustafson’s book is entitled “The Wrath of Kahan” [laughter] `
22:20:19 <pie_[bnc]> ah looks like athas did his reading
22:20:29 <pie_[bnc]> http://www.johngustafson.net/pdfs/DebateTranscription.pdf
22:20:33 <pie_[bnc]> reading / watching
22:23:16 <koz_> pie_[bnc]: That particular section is quite amazing.
22:23:25 <koz_> I recommend reading The End of Error - it's very approachable.
22:24:04 <pie_[bnc]> that sounds good because im pretty afraid of touching floats anywhere that actually matters
22:24:16 <pie_[bnc]> which is how i ended up peeking at this to begin with
22:32:27 <jle`> chambln: it's "evaluation by substitution"
22:33:05 <jle`> chambln: basically whenever haskell sees 'f x', it looks up the definition of f, like f x = blahblah
22:33:13 <jle`> chambln: and it 'literally' replaces f 1 with blahlbah
22:33:27 <jle`> so for example if `f x y = x + y`, and haskell sees `f 1 2`, it literally just replaces it with 1 + 2
22:33:32 <jle`> it's almost a lexical replacement
22:33:52 <jle`> chambln: so if it sees (1,2) == (3,4), it looks up the definition of (==) for tuples and literally just replaces it with the body
22:34:29 <koz_> pie_[bnc]: I can't say that book will assuage you much. :P
22:35:16 <jle`> chambln: so "when ... is given to this function, they are ...", it's pretty much true for every haskell function
22:35:18 <jle`> not just (==) :)
22:35:32 <jle`> there is no special-case situation here, it's the same rules as for all other haskell functions
22:35:57 <dsal> I think part of what makes haskell seem hard to people coming from other languages is expecting things to be weird.
22:36:02 <dsal> Not being weird is the new weird.
22:40:58 <koz_> dsal: Can't say I blame them. The list of gotchas in most languages is extremely long.
22:41:03 <koz_> And for extremely bizarre reasons.
22:41:14 <dsal> Lots of battle scars.
22:41:32 <koz_> Also, how do I document arguments to GADT constructors using Haddock?
22:42:12 <dsal> I do a lot of work in databases.  People coming from mysql are permanently broken...  It's all about "how do I deal with [thing that should never happen in decent software]?"
22:42:57 <dsal> Yeah, docs aren't the best thing in haskell.  I really want to generate docs with TH, but that's... an old bug.
22:59:35 <happycoder_> is it possible to generate elm types for Persistent Entity-s?
23:00:30 <pie_[bnc]> koz_: seems like it heh, going by the debate transcript
23:00:35 <happycoder_> I tried using elm-bridge and haskell-to-elm, which are giving difficult errors. Is it possible?
23:29:47 <koz_> When I'm reading type judgments, what's the difference between 'Gamma, t : T |- whatever' and 'Gamma |- t : T'? Basically, how does having t : T to the left of the turnstile differ in meaning to having it to the right of the turnstile?
23:32:06 <Solonarv> the part on the left is the environment of things we have already assinged types to
23:32:23 <Solonarv> on the right is a new conclusion that we (probably) didn't know yet
23:33:03 <Solonarv> so the first is "know all the things in Gamma as well as knowing t : T, we can conclude whatever"
23:33:14 <Solonarv> the second is "knowing all the things in Gamma, we can conclude t : T"
23:33:24 <koz_> Solonarv: OK, thanks.
23:54:23 * hackage mmsyn7l 0.1.1.0 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.1.1.0 (OleksandrZhabenko)
23:55:51 <alc`> does leetcode support Haskell?
23:57:55 <Solonarv> it appears that it doesn't
23:58:00 <Solonarv> at least not on the website
23:58:24 <Solonarv> (you can check this yourself by going to https://leetcode.com/playground/new/empty and opening the language dropdown)
23:58:48 <alc`> aha, then I stay on codewars
