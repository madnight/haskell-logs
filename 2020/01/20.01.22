00:22:23 * hackage hasbolt-extras 0.0.1.2 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.1.2 (ozzzzz)
00:27:23 * hackage fastcgi 3001.0.2.5 - A Haskell library for writing FastCGI programs  https://hackage.haskell.org/package/fastcgi-3001.0.2.5 (krasimir)
01:34:38 <purelazy> Hi nav2002
01:38:48 <purelazy> Hi  MoarSpaceFi 
01:39:03 <MoarSpaceFi> h-hello
01:39:23 <purelazy>  MoarSpaceFi: how are you
01:40:44 <purelazy> Hi  kuribas
01:40:59 <kuribas> purelazy: hey
01:41:34 <gentauro> anybody know how to access binaries created by the `stack build --profile`?
01:42:20 <MoarSpaceFi> purelazy, just living life - you?
01:42:26 <gentauro> without `--profile` the path can be found with `$(stack path --local-install-root)/bin
01:43:46 <purelazy> What are you trying to do gentauro?
01:44:48 <gentauro> purelazy: I just want to be able to have profiling output with `stack`
01:45:19 <purelazy> MoarSpaceFi: living & learning
01:46:09 <gentauro> purelazy: with GHC i would do: `ghc -prof -fprof-auto -rtsopts -Wall -Werror -O2 --make Main.hs -o foobar`
01:46:10 <MoarSpaceFi> purelazy, whatcha learning?
01:46:40 <chloekek> I am using stack test with hspec and quickcheck (through hspec’s prop function). One of the tests enters an infinite loop or overly expensive computation and does not appear to finish. But the output only contains the names of tests that passed or failed, not of the running test. All I see is “19/1000”. Is there a way to get this combination of tools to print the name of each test prior to
01:46:42 <chloekek> executing that test?
01:48:11 <purelazy> MoarSpaceFi: Learning how to help people.
01:48:19 <chloekek> I tried all possible --format options but none do this.
01:48:34 <MoarSpaceFi> purelazy, help people with what?
01:49:52 <purelazy> MoarSpaceFi: Whatever they need help with.
01:51:24 <sshine> chloekek, sounds like a divergent generator?
01:51:28 <purelazy> MoarSpaceFi: I do my best
01:51:39 <chloekek> sshine: I cannot diagnose the issue until I know which test is causing it.
01:52:15 <chloekek> I’ll just pass --test-arguments --dry-run to stack test and hope that it lists them in the same order as stack test does.
01:53:19 <sshine> chloekek, I'd just comment out the tests until the stalling one ceases to stall, binary-search style.
01:54:00 <sshine> chloekek, (so my non-answer is that I also don't know a smart way to get debug data on infinite regress in tests.)
01:54:22 <chloekek> It appears that --test-arguments --dry-run does list them in the same order, so I can take the name of the test after the one that succeeded before the stalling one.
01:54:32 <sshine> chloekek, ok.
01:54:41 <chloekek> Then commenting out that test makes the run complete.
01:57:40 <sshine> oh hi kuribas
01:58:28 <sshine> kuribas, I just recalled you're the author of aeson-diff-generic. I like that package. :)
02:00:42 <kuribas> sshine: ah, someone uses it :)
02:00:44 <kuribas> sshine: thanks
02:01:02 <kuribas> sshine: I should find some time to complete it.  Expecially the lenses are still broken.
02:04:26 <maerwald> how do you compare to filepaths on darwin?
02:04:35 <maerwald> *two
02:08:24 <sshine> kuribas, probably only if you need it.
02:09:12 <sshine> kuribas, I've decided to try and push to all the libraries I use that are missing things I need this year.
02:14:23 * hackage morley 0.6.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.6.0 (gromak)
02:33:48 <dftxbs3e> JSharp, hey, I think I'll have a go at this! hah
02:34:02 <dftxbs3e> is there a way to do without the garbage collector in Haskell?
02:34:44 <Solonarv> technically, yes, but practically you're not going to have a particularly easy time
02:36:26 <dminuoso> dftxbs3e: Do you have a particular problem with it?
02:36:55 <dftxbs3e> dminuoso, I feel uneasy at having code running in the background that I don't have control on, how does Haskell's GC work?
02:37:04 <dftxbs3e> Solonarv, I can imagine the abstractions don't do well without it :/
02:37:08 <__monty__> dftxbs3e: There's compact regions.
02:37:23 <__monty__> But if you don't want a GC, haskell's probably not for you.
02:37:24 <dminuoso> dftxbs3e: It's a 2-space, moving, stop-the-world, garbage collector.
02:38:04 <dftxbs3e> __monty__, though it seems like I'd love the functional programming features so much! :-/
02:38:19 <dftxbs3e> dminuoso, stop-the-world ahh..
02:38:38 <dminuoso> dftxbs3e: Realistically it's not a problem for most applications.
02:38:43 <dftxbs3e> Does Structured Concurrency ring any bells in Haskell?
02:38:54 <dminuoso> The category of problems that require real-time/low latency is really small :)
02:39:23 <Arahael> Last time I did that, we did it in low-level assembly...  And liked it.
02:39:28 <Solonarv> the problem is simply that Haskell is designed as a garbage-collected language, so if you want to avoid the GC your options are:
02:39:28 <Solonarv> 1) just turn off the GC and never reclaim any memory, or
02:39:28 <Solonarv> 2) write code that never allocates anything that would have to be cleaned up later
02:39:45 <Solonarv> well, really you'd have to do *both* of those
02:39:48 <Arahael> Nothing's quite like having a certain fixed amount of time for a particular function, and knowing exactly how long every byte takes.
02:40:00 <Solonarv> obviously 1) is dangerous because you will run out of memory, and 2) is very hard
02:40:23 <Arahael> And then hooking up an oscilloscope to confirm that the bytes your program are executing are taking exactly as long as the documentation says they are. ;)
02:40:32 <dminuoso> dftxbs3e: I've come to the realization that much negativity around garbage collection is mis-placed.
02:40:44 <dftxbs3e> Is there any functional programming language in general that can do well with manual memory handling?
02:41:04 <dminuoso> As programmers we concern ourselves with writing programs that solve our problems well, and not worrying about memory makes that job *much* easier.
02:41:09 <Arahael> dftxbs3e: Depends on what you mean by "manual" memory handling.
02:41:20 <Solonarv> hm, I've heard of one or two mostly experimental ones
02:41:22 <dftxbs3e> Arahael, no GC
02:41:22 <Arahael> dftxbs3e: There are techniques other than GC that can be used, but they are sometimes even slower.
02:41:23 <Solonarv> Clean comes to mind
02:41:24 <dminuoso> dftxbs3e: Decades of millions of CVEs surrounding memory management provably demonstrate that manual memory management is dangerous and highly error prone.
02:41:36 <opqdonut> dftxbs3e: rust maybe, depending on your definition of functional. also check out carp (which isn't production-ready but is interesting)
02:41:48 <dftxbs3e> dminuoso, I mean, it can be in the Rust sense :P -- I already do Rust. But it isnt functional enough! hah
02:41:49 <Arahael> Swift is another, I think.
02:42:04 <dminuoso> dftxbs3e: My personal recommendation? don'
02:42:16 <dminuoso> dftxbs3e: My personal recommendation? Don't let the garbage collector impact your decision whether or not to learn a language. :)
02:42:16 <Arahael> (Swift uses ARC, which is basically compiler-inferred reference counting)
02:42:27 <Solonarv> ah, carp is what I was thinking of, not clean
02:43:05 <dminuoso> Solonarv: Well it's essentially uniqueness types, no? :)
02:43:17 <Solonarv> yeah, those do the heavy lifting
02:43:39 <Solonarv> but I definitely had carp in mind, I simply misremembered the name
02:45:52 <dftxbs3e> Just in general, I like a language that lets me express what I want my computer to do without forcing on me some runtime. For example, I write frontend web in Rust, I also write header-less small position-independent shellcodes for infosec (with quite small size actually, too), and CLI programs. Haskell couldnt be used to make a small shellcode, because of GC. It must link that code, and it must be quite big.
02:47:13 <dminuoso> Well the goal of GHC Haskell is not to be used for shellcode, but it's designed to write performant, scalable, maintainable and robust software with it. :)
02:47:46 <Solonarv> but indeed, if you want to write close-to-the-metal code Haskell is simply not the right language
02:48:16 <Solonarv> it can certainly be done, but would require significant effort
02:48:17 <MarcelineVQ> but I can be used to create a, or generator code for a, right language :>
02:48:25 <MarcelineVQ> *generate
02:48:55 <MarcelineVQ> *it can       :(
02:48:55 <dminuoso> For what its worth, there were multiple successful attempts to write low level OS kernels with Haskell. 
02:49:18 <dminuoso> But those require heavy modification to the toolchain. :)
02:49:31 <Solonarv> indeed
02:49:39 <Solonarv> significant effort!
02:49:54 <dftxbs3e> dminuoso, Well. It this fundamentally stuck with Haskell or is it possible to write a replacement GC for Haskell that is non-intrusive? As in, like Rust "GC" that basically compiles with the code, by forcing Drop traits etc.
02:50:00 <dftxbs3e> Is this *
02:50:04 <dminuoso> dftxbs3e: It absolutely is possbile.
02:50:24 <Solonarv> simply, nobody has done it (and released the result publicly)
02:50:34 <dminuoso> dftxbs3e: Well-Typed is currently involved in writing a new garbage-collector for GHC.
02:51:07 <dminuoso> (I think Ben is mostly involved with that)
02:51:29 <dftxbs3e> dminuoso, I see, interesting! And it does not run in the background? Because I don't think we can call that a GC if it doesnt run separate to the main program's control flow.
02:52:09 <dminuoso> dftxbs3e: It's a concurrent mark&sweep garbage collector
02:52:22 <dminuoso> dftxbs3e: You can check out the design in B. Gamari. "A Concurrent Garbage Collector For the Glasgow Haskell Compiler" (2018)
02:53:54 * hackage data-r-tree 0.6.0 - R-Tree is a spatial data structure similar to Quadtrees or B-Trees.  https://hackage.haskell.org/package/data-r-tree-0.6.0 (SebastianPhilipp)
02:54:44 <dminuoso> dftxbs3e: If you want to learn more, https://www.youtube.com/watch?v=7_ig6r2C-d4 is a good presentation by the same Ben Gamari.
02:56:02 <MarcelineVQ> dminuoso: that's not related to a desire/interest for minimal gc tho afaik ye?
02:56:31 <dftxbs3e> dminuoso, thanks!! :-)
02:56:58 <Arahael> Even C technically has a runtime.
02:57:21 <dminuoso> Arahael: That runtime consists of a shim setting up the stack and static storage... :P 
02:57:29 <Arahael> Even so. :)
02:57:58 <dftxbs3e> Arahael, it is not needed and programming without it is really just as easy as with it :P
02:58:06 <dminuoso> Strictly speaking, it doesnt need a runtime though. So some particular implementations of it have what one might call a runtime system
02:58:27 <Arahael> Which is - arguably - sometimes the same thing
03:00:08 <dftxbs3e> also can Haskell do needless copies at times?
03:00:18 <dminuoso> dftxbs3e: Yes.
03:00:18 <jle`> i mean, it can if you tell it to
03:00:26 <dminuoso> dftxbs3e: It's one of the reasons that Clean is faster than GHC Haskell. ;)
03:00:37 <jle`> it can also not do needless copies, as well :)
03:00:50 <dminuoso> Because Clean uses uniqueness types to figure out whether it can safely mutate things, GHC Haskell cannot.
03:00:58 <dminuoso> But what jle` has pointed out is just as relevant. :)
03:01:46 <dminuoso> dftxbs3e: We have access to mutable data types, so if we need/want, we can still get it.
03:01:54 <jle`> any sufficiently powerful language can do needless copies
03:02:17 <dminuoso> https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Mutable.html for instance gives you mutable vectors (which is basically another synonym for list/array)
03:02:21 <jle`> if the programmer asks it to
03:02:43 <dftxbs3e> jle`, I would say the compiler can figure out what is useful and useless and optimize, no? Like move semantics?
03:02:55 <dminuoso> dftxbs3e: That's what Clean does, exactly.
03:02:58 <dminuoso> GHC Haskell cannot.
03:03:10 <dftxbs3e> Ah okay. Well Clean is very interesting to me now!
03:03:18 <jle`> dftxbs3e: it can in a lot of situations, but a clever programmer can confuse GHC enough to force it to do needless operations
03:03:20 <dminuoso> dftxbs3e: GHC Haskell can do sharing though, which gets you half the way. :)
03:03:41 <jle`> dftxbs3e: i'm assuming you are talking about someone who is trying to force the compiler to do needless operations
03:03:42 <dminuoso> dftxbs3e: Say if GHC Haskell recognizes that the same expression appears twice, then it can *share* the result in both places.
03:03:52 <jle`> dftxbs3e: someone who uses the compiler normally will probably be able to avoid lots of them :)
03:04:21 <Solonarv> dminuoso: I seem to recall that GHC is actually fairly reluctant to perform CSE ?
03:04:33 <dftxbs3e> CSE?
03:04:38 <dminuoso> Common subexpression elimination
03:05:00 <dminuoso> Solonarv: Indeed, I mean at the end inlining and CSE are on opposite ends
03:05:07 <Solonarv> turning 'f (x+1) (x+1)' into 'let y = x+1 in f y y', for example
03:05:15 <dminuoso> GHC is rather keen on inlining instead.
03:05:46 <dftxbs3e> jle`, I meant to ask if Haskell had needless operations inherent to the syntax or paradigm, akin to when C++ lacked move semantics and people kept on copying big objects in memory because it was troublesome not to.
03:06:01 <Solonarv> ah, no, that's not really problem
03:06:25 <dminuoso> dftxbs3e: The way GHC Haskell works, most of our "copy semantics" are implemented efficiently.
03:06:35 <Solonarv> (GHC) Haskell is quite pervasively pass-by-"reference" (not exactly, because of non-strict semantics, but close enough)
03:06:52 <dminuoso> dftxbs3e: In most cases we dont need to actually duplicate entire data structures when we "modify" it.
03:06:52 <Solonarv> so you are actually passing pointers to heap objects, not copying them
03:07:43 <dminuoso> dftxbs3e: Take lists for instance. Because a list is, semantically, a linked list in Haskell, "appending" to a list does not require duplicating the list. We can just create a new element and have it point to the other list.
03:07:52 <dminuoso> (Or, prepending, as it is rather)
03:08:08 <dftxbs3e> I see
03:08:33 <Solonarv> for another example, consider the following code:
03:08:33 <Solonarv> data Person = Person { name :: String, age :: Int }
03:08:33 <Solonarv> youngJoe = Person { name = "Joe", age = 15 }
03:08:33 <Solonarv> oldJoe = youngJoe { age = 50 }
03:08:37 <dminuoso> dftxbs3e: The general performance of Haskell sits right somewhere around Java, with some cases getting closer to what Rust or C++ can do.
03:08:43 <dminuoso> That is, GHC Haskell.
03:09:06 <dminuoso> dftxbs3e: That should give you an indication how good our implementation works, despite lack of mutability in the langauge itself and having garbage collection. :)
03:09:09 <Solonarv> youngJoe and oldJoe's `name` fields will point to the same 'String'
03:09:23 <Solonarv> so, no unnecessary copying there either
03:10:05 <dftxbs3e> dminuoso, hmm, I see. How large is the binary for a size-optimized and stripped Haskell Hello World?
03:10:13 <dftxbs3e> (static-linked)
03:10:18 <dminuoso> dftxbs3e: Im going to argue that this metric is a useless one
03:10:20 * dminuoso pokes merijn
03:10:25 <dminuoso> It's your show!
03:10:35 <dftxbs3e> It matters to me! :P
03:11:01 <dminuoso> dftxbs3e: Haskell promotes static linking, and we have the runtime.
03:11:33 <dminuoso> dftxbs3e: If we were to compare the binary sizes of two compilers of comparable complexity and size, implemented in different languages.
03:11:37 <dminuoso> That'd be a much more useful metric.
03:12:00 <dminuoso> Because it tells you something about code size
03:12:36 <dminuoso> dftxbs3e: Take for instance, GHC RTS comes with its own scheduler because we have green threads.
03:13:34 <dminuoso> Should we take the Linux scheduler into account as well, when looking at the size of a simple C hello world problem?
03:14:23 <dftxbs3e> We could, but I'm myself comparing with only other Linux things so, it does not matter for me
03:15:16 <dftxbs3e> For example, with Rust, a no_std static-linked musl Hello World program can be as big as the system's page size, not less
03:15:50 <dminuoso> dftxbs3e: Well a naively written hello world program without any stripping is 3.1MiB already.
03:15:58 <dminuoso> But like I said, that includes the entirety of the RTS
03:16:11 <dftxbs3e> Okay. Stripping probably accounts for much of it
03:16:30 <dminuoso> If we strip it, we get down to 678KiB
03:16:33 <dftxbs3e> Rust's tokio asynchronous runtime can produce executables as small as 200kb static linked and stripped
03:16:39 <dftxbs3e> with std and all
03:16:54 <dftxbs3e> That's pretty good! Is it static linked even to a libc?
03:17:21 <dftxbs3e> Does Haskell have LTO?
03:18:04 <dminuoso> dftxbs3e: GHC eventually uses llvm and whatever linker you have.
03:19:21 <dminuoso> dftxbs3e: No its not statically linked to a libc
03:19:54 <dminuoso> dftxbs3e: Most systems ship with glibc, like mine, and Ulrich Drepper does not want you to statically link the glibc. :)
03:20:18 <dftxbs3e> When static linking, I use musl because glibc doesnt support it heh
03:20:42 <dminuoso> There is a musl-gcc wrapper, but I havent tried it
03:21:57 <dftxbs3e> OK! Well thanks for all the answers. I'll have a closer look at that GC video, and Clean. I have to write a portable, maintainable, high performance Secure Scuttlebutt server, so it may be in Haskell! Or Clean :D
03:22:23 <dminuoso> dftxbs3e: Be aware that Clean is a research language that is mostly only used in a few dutch universities. :)
03:22:47 <dftxbs3e> Aha, noted. It exists for 30 years though!
03:23:50 <Arahael> I feel that there is so little we know about programming and software design.
03:23:51 <dftxbs3e> Ohh and last question, I work exclusively on a system that runs PowerISA 3.0 (IBM POWER9, in my case). Does Haskell support that?
03:24:49 <Arahael> dftxbs3e: Honestly, if you're working on a fairly exclusive system, you're going to end up having to be *intimately* aware of the whole toolchain, whatever that may be.
03:25:08 <Arahael> I doubt haskell would be much different there, even if it supports it.
03:25:54 <dftxbs3e> Arahael, I feel like there's so much room for improvement :-) -- Seeing the way some IDEs autocomplete code and all (C# with Visual Studio), I think that there must be a more concise and simple way to write code. I tend to think that the offered abstractions are often redundant, and lots of it could be inferred.
03:26:04 <dftxbs3e> Arahael, well, Rust supports it out of the box with minimal modifications :P
03:26:28 <dminuoso> dftxbs3e: Well you definitely have to compile it yourself, we dont ship distributions for that.
03:26:30 <dftxbs3e> JSharp also has such a system, and they write Haskell. So I'm guessing they have already hacked Haskell to work there :D
03:26:43 <dftxbs3e> I use Fedora, Fedora must package GHC, correct?
03:26:53 <dminuoso> dftxbs3e: However, I see some GHC issues with people suggesting they run on Power9
03:27:03 <dminuoso> dftxbs3e: You shouldn't use your distribution provided GHC.
03:27:11 <dminuoso> It's likely out of date
03:27:23 <dftxbs3e> Fedora has recent software, that's why I use it!
03:27:30 <Arahael> dftxbs3e: I would suspect that even Rust won't support all crates on Power9.
03:28:21 <dftxbs3e> Arahael, a big majority are supported, honestly. Rare are the crates that use Assembly code underneath. Rust code is very portable, you can't go wrong by assuming things because Rust protects you against undefined behavior in safe code.
03:29:30 <Arahael> dftxbs3e: What would happen if you run into a bug involving the linker, or it uses an newer LLVM that doesn't quite suport some idiosyncracy of Power9, etc?  I'm not providing specific examples - just saying that if you are using a fairly obscure system, you're going to have to be able to support it yourself.
03:29:58 <dftxbs3e> Arahael, POWER9 is far from obscure. It has industry support, and LLVM supports it well.
03:30:15 <dftxbs3e> A lot of the US government, research and financial industry uses it worldwide
03:30:19 <dftxbs3e> Also, AI
03:30:30 <Arahael> dftxbs3e: You're not getting my point.
03:30:38 <dftxbs3e> RHEL has top-tier support for it
03:30:45 <dftxbs3e> So they go and fix things in FOSS along the way :-)
03:31:11 <dftxbs3e> version 8.6.5, is that good enough?
03:31:17 <Arahael> dftxbs3e: IT comes down to expectations.  Your employer is presumeably hiring you for working on it.  And then there's something that doesn't work right.   You're going to have to fix it.
03:31:57 <Arahael> dftxbs3e: If you struggle with it because you don't fully understand the entire toolchain, then your employer is going to think about hiring someone else.
03:32:46 <Arahael> dftxbs3e: Why do you think developers on such systems are so conservative with their language setups?
03:33:07 <dftxbs3e> I'm not the kind of guy that gets employers or gets fired or hired. So I'm not concerned with that
03:33:31 <Arahael> Well, then, go for it.
03:38:22 <dftxbs3e> Seems 8.6.5 is latest LTS. Good! Thanks everyone for guidance on Haskell and functional programming in general!
03:49:24 * hackage aeson-match-qq 1.0.0 - Matching Aeson values with a quasiquoter  https://hackage.haskell.org/package/aeson-match-qq-1.0.0 (MatveyAksenov)
04:00:22 <lukelau> is there a way to view the preprocessor output when building a module via cabal?
04:00:40 <lukelau> copying and pasting the ghc command and slapping on -E doesn’t work because it build it in make mode
04:02:54 * hackage construct 0.1 - Haskell version of the Construct library for easy specification of file formats  https://hackage.haskell.org/package/construct-0.1 (MarioBlazevic)
04:03:54 * hackage http-streams 0.8.7.1 - An HTTP client using io-streams  https://hackage.haskell.org/package/http-streams-0.8.7.1 (AndrewCowie)
04:17:25 <dminuoso> 12:29:35         dftxbs3e | Arahael, POWER9 is far from obscure. It has industry support, and LLVM supports it well.
04:17:53 <dminuoso> It depends on what you define as obscurity.
04:18:46 <dminuoso> dftxbs3e: Is it SO or SU?
04:42:08 <Clint> hvr: are you aware of an issue with the pgp key used to sign http://downloads.haskell.org/debian's stretch InRelease file?
04:42:46 <AWizzArd> I’m in the process of refactoring some code, and now I replaced IO with an abstract monad m. I am calling   forkIO (foo 10 20). But now foo returns   m ()
04:44:21 <phadej> Clint: he is
04:44:40 <phadej> https://github.com/haskell-CI/haskell-ci/issues/349
04:44:50 <phadej> (and I discussed the issue with him on the weekend)
04:44:58 <Clint> phadej: thanks
04:45:22 <phadej> fwiw, If you have any feature requests or encounter any issues, please report them here. where here points https://github.com/haskell-CI/haskell-ci/issues
04:46:04 <dminuoso> AWizzArd: Implement MonadIO for your monad.
04:46:09 <dminuoso> AWizzArd: Oh
04:46:10 * Clint nods.
04:46:19 <dminuoso> AWizzArd: Check out unliftio
04:46:22 <dminuoso> AWizzArd: https://hackage.haskell.org/package/unliftio-0.2.12/docs/UnliftIO-Concurrent.html#v:forkIO
04:47:14 <phadej> as far as we figured on the weekend, for some reason the subkey the packages are signed with are not on the keyserver
04:47:28 <AWizzArd> dminuoso: yeah, I can’t have a meaningful MonadIO implementation, because I need data from some Reader, for which I do have an impl. But yeah, I essentially want to do the opposit of liftIO.
04:47:37 <dminuoso> AWizzArd: That's MonadUnliftIO 
04:47:48 <phadej> (maybe the keyserver runs too old software and just drops ed25519 keys, or something like that; herbert run out of time on the weekend checking that)
04:47:49 <Clint> phadej: were they before the keyserver switched software?
04:47:52 <dminuoso> AWizzArd: You can still have a MonadIO implementation even if you have ReaderT
04:48:04 <dminuoso> AWizzArd: But for forkIO you need MonadUnliftIO, not MonadIO
04:48:08 <phadej> Clint: before the packages were signed with the root key
04:48:09 <Clint> phadej: i believe it used to use sks and now it uses hockeypuck
04:48:14 <Clint> phadej: ah, okay
04:48:23 <phadej> or maybe they weren't
04:48:27 <phadej> I actually not sure
04:48:41 <phadej> when the software echange happend, any pointer to it?
04:49:05 <dminuoso> AWizzArd: Either use unliftio or unliftio-core, and then depending on which one you picked you'd use UnliftIO.Concurrent.forkIO or just withRunInIO
04:49:30 <Clint> phadej: not sure, i only noticed when i was looking into this problem
04:50:02 <AWizzArd> dminuoso: okies, will try that!
04:50:34 <phadej> Clint: k, thanks for the insight however
04:51:32 <phadej> ... might find this other keyserver implementation, Hockeypuck, of interest—looks like it's supposed to be protocol-compatible with SKS, but written in Go instead of OCaml: https://hockeypuck.github.io/
04:51:45 <phadej> :(
04:53:48 <phadej> if one would migrate from OCaml, why to Go :/
04:56:40 <phadej> at least https://github.com/hockeypuck/hockeypuck/pull/52  is relatively recent change, not idea what version keyserver.ubuntu.com is running
04:56:57 <phadej> https://keyserver.ubuntu.com/pks/lookup?op=stats says "version: -unreleased"
05:31:36 <maerwald> phadej: why not?
05:45:17 <[exa]> I'm parsing a large bytestring into a relatively huge amount of smaller ones, that are just picked out from the big one. Q: with lazy bytestrings, does it make any sense to try to be super-efficient and "save space" by representing the tiny bytestrings as offsets, or is the lazy BS representation is already good enough to avoid problems?
05:45:32 <[exa]> (actual parsing is done with attoparsec)
05:49:38 <Solonarv> strict bytestrings are *already* represented as an offset + length
05:49:38 <Solonarv> and a lazy bytestring is basically just [Strict.ByteString]
05:51:51 <[exa]> hm, reading the implementation... so if there is nothing that would cause spawning of separate Chunks (B.copy?), chances are that the actual data in the bytestring won't be ever reallocated?
05:51:57 <[exa]> s/reallocated/copied
05:53:14 <Solonarv> as long as the small bytestrings are just slices of the big one, no copying should be happening
05:55:03 <[exa]> cool
05:55:08 <[exa]> thanks :]
06:04:40 <phadej> maerwald: this is #haskell channel, if you haven't noticed
06:29:55 <maerwald> phadej: doesn't answer my question ;)
06:33:41 <nshepperd2> go is a perfectly cromulent choice, if you don't want features or data structures or reusability
06:33:59 <dminuoso> Or if you dont like abstractions.
06:40:28 <hseg> Hi. Still stuck with my "simulating dependent types in Haskell" problem. Thought I might be able to hide type-level hackery through a CPS, not succeeding
06:41:15 <hseg> GHC rejects (k $ case someNatVal n of (SomeNat (_ :: Proxy n')) -> Data.Vector.Sized.replicate @n') :: (Natural -> (forall n. KnownNat n => Vector n Int -> r) -> r) 
06:41:51 <hseg> sorry, meant \n k -> (k $ case someNatVal n of (SomeNat (_ :: Proxy n')) -> Data.Vector.Sized.replicate @n') :: (Natural -> (forall n. KnownNat n => Vector n Int -> r) -> r) 
06:42:25 <hseg> (BTW, is there a cleaner way of destructoring a SomeNat than what I'm doing?)
06:43:03 <Solonarv> I dimly recall seeing a 'withSomeNat' or the like around
06:43:27 <nshepperd2> you need to apply the k inside the case statement
06:43:40 <dminuoso> Solonarv: withSomeNat :: Natural -> (forall n. SNat n -> r) -> r  ?
06:43:41 <hseg> typelits-witnesses
06:44:04 <Solonarv> I think there is a variant in base as well, but that one would probably work
06:44:34 <dminuoso> withSomeNat (someNatVal->SomeNat (Proxy :: Proxy n)) x = x (SNat :: SNat n)
06:44:37 <dminuoso> Heh. 
06:45:01 <dminuoso> What is that arrow doing there in the pattern..
06:45:25 <nshepperd2> note that the case statement currently has a type something like exists n. a -> Vector n a
06:45:42 <hseg> Ah, that's what's going on
06:45:46 <nshepperd2> which is illegal, since haskell doesn't have exists
06:46:16 <nshepperd2> error messages will say that n' has escaped its scope
06:46:41 <nshepperd2> also, i assume you mean to apply replicate to a number
06:46:42 <Kanimal_pelao> Hello folks
06:46:44 <hseg> Right
06:47:05 <hseg> ... yes, typo
06:50:27 <hseg> dminuoso: It's a ViewPattern
06:50:48 <dminuoso> Ahh
06:51:13 <hseg> So it already passes the Natural through someNatVal and extracts the proxy
06:57:32 <hseg> Probably easier to work with singletons anyway. Will at least make it clear to me what's what.
06:59:19 <AWizzArd> If I would not want to use unliftIO (for whatever reason): how could I manually do what unliftio would have done? I am in a monad m and in main I chose it to be my   newtype AppT m a = AppT { runApp :: ReaderT Context (ExceptT ServantErr m) a }
06:59:27 <dminuoso> AWizzArd: absolutely, sure.
06:59:44 <dminuoso> AWizzArd: unliftio-core has a low dependency overhead though, I'd just use it.
06:59:46 <AWizzArd> Would I need, as a first step, a new type class which can work on m, with an instance for (AppT IO)
07:00:02 <AWizzArd> dminuoso: I am totally not against using it but would like to understand the „magic” a bit better.
07:00:17 <AWizzArd> So, this is more an academic question than a professional one.
07:00:17 <dminuoso> AWizzArd: There's nothing to it.
07:00:33 <merijn> AWizzArd: The magic is that you can basically only make ReaderT (or things isomorphic to it) instances of MonadUnliftIO
07:00:46 <dminuoso> AWizzArd: UnliftIO is, essentially, just providing `unliftIO :: MonadUnliftIO m => m a -> IO a` ... but that function cant exist for reasons.
07:00:50 <boxscape> hseg you might find singletons-nats useful, which has unary naturals for the singletons "ecosystem". Imo a bit easier to understand than TypeLit nats but they don't both share all the same use cases
07:00:55 <merijn> AWizzArd: Which means you can just "query" the ReaderT parameter and unwrap in another action by passing the argument through
07:01:03 <AWizzArd> I am in `m`. This can concretly be AppT or some TestM type.
07:01:27 <dminuoso> AWizzArd: Sure! You can unlift anything out of things isomorphic to ReaderT or IdentityT.
07:01:30 <AWizzArd> Inside my function, which returns the m, I don’t know the concrete type. So I would guess that my first step needs to be to write a type class and add a constraint.
07:01:53 <AWizzArd> dminuoso: I would like to do that but am not too certain how to write the exact code+sigs.
07:01:57 <hseg> boxscape: Hrm. Will give it a look. Thanks!
07:02:27 <dminuoso> AWizzArd: withRunInIO $ \io -> ....
07:02:34 <dminuoso> AWizzArd: Then `io` is that unlifting function.
07:02:38 <dminuoso> AWizzArd: So for instance:
07:02:54 <dminuoso> withRunInIO $ \io -> forkIO (io yourAction)
07:02:58 <AWizzArd> So, my task is to implement my own  withRunInIO
07:03:02 <dminuoso> Sure!
07:03:42 <dminuoso> AWizzArd: Note that withRunInIO will, liftIO everything back. This is not necessary, it's just how 90% of the users would use it. :)
07:03:44 <AWizzArd> Okay, so this is the type class I was thinking about. For this one I will have to write an instance for (AppT IO) and some TestM type later on.
07:06:14 <dminuoso> AWizzArd: You could, alternatively, implement `askRunInIO :: MonadUnliftIO m => m (m a -> IO a)`
07:08:17 <AWizzArd> dminuoso: that would require me to use the unliftio package. But as a learning excercise I must not use it at all.
07:08:29 <hseg> Not sure of the interaction with higher-rank types -- would liftA2 @(Cont r) (,) (withSomeNat n) (withSomeNat k) give me a pair of singletons, for n and k respectively?
07:08:29 <dminuoso> AWizzArd: No, I meant you could reimplement that yourself.
07:08:46 <dminuoso> AWizzArd: As in, askRunInIO :: App (App a -> IO a)
07:08:49 <AWizzArd> dminuoso: yes okay, this is what I need to try to do. Will teach some good lessons.
07:33:54 * hackage byteslice 0.2.1.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.2.1.0 (andrewthad)
07:56:43 <sim590> How can I ignore cabal's "environment" data when starting ghci?
07:57:19 <sim590> Because, I don't want to have to include names of packages in my cabal file when I simply just want to test something.
07:57:24 <merijn> sim590: Remove the .ghc.environment file (or pass the flag that disables that)
07:57:37 <Solonarv> sim590: you can pass a flag to ghc(i) to make it not load those files
07:57:52 <Solonarv> or delete the file and pass a flag / set a config option to make cabal not generate them
07:59:50 <sim590> Yeah, I thought so, but I just can't find find the flag. 
08:00:12 <merijn> Should be in the GHC user's guide flag reference?
08:00:30 <sim590> I'm looking at manpage right now. 
08:01:03 <Solonarv> it's -package-env for GHC
08:01:21 <sim590> I tried that -global-package-db, but it didn't work.
08:01:41 <Solonarv> nono, the package-db is where all the package *are*
08:01:56 <sim590> -package-env needs an argument.
08:02:05 <Solonarv> the environment says which of those packages are meant to be visible
08:02:15 <Solonarv> yes, IIRC passing - as the argument says "none"
08:02:31 <sim590> Well... They coudl have documented it...
08:02:35 <Solonarv> but now that you know the flag name, you can efficiently search the manual and don't have to rely on my guesses
08:03:08 <sim590> The only doc about the flag is "Use the specified package environment." There's nothing about the magic "-"...
08:03:44 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9
08:04:12 <sim590> Man page doesn't say taht :/
08:04:27 <Solonarv> hmm :/
08:04:34 <sim590> I guess that's new...
08:08:47 <sm[m]> sim590: you're not wrong, docs could be better
08:10:39 <sm[m]> good morning all. I'm trying to remember and uplevel to use a certain construct: a way of using a guard (in a list ?) to replace something like if foo then [bar] else []. Would you know the name of it ?
08:12:47 <sm[m]> ah, probably it was a list comprehension: [bar | foo]
08:12:48 <heatsink> It is a guard in a list comprehension
08:17:05 <dminuoso> sm[m]: do-notation would work too :)
08:18:37 <phadej> or enable MonadComprehensions!
08:18:44 <phadej> to guard generically
08:19:23 <dminuoso> phadej: Is there any popular codebase out there that uses MonadComprehensions?
08:19:29 <dminuoso> I can't recall ever seeing it on hackage
08:19:41 <Solonarv> frankly, I don't see the point
08:19:45 <Solonarv> it's just wacky do notation
08:20:19 <dminuoso> Solonarv: By that logic why have list comprehensions at all?
08:20:35 <Solonarv> oh, I find that they're fine for lists
08:20:36 <Taneb> There's been a handful of times I've really wanted to use MonadComprehensions
08:20:45 <Taneb> Mostly with Maybe
08:20:46 <Solonarv> and perhaps for some similar monads that look a lot like []
08:21:21 <dminuoso> Taneb: I found that pattern guards can fit that niche as well.
08:24:39 <maerwald> dminuoso: exactly, I'm pro removing list comprehension
08:25:17 <dminuoso> Well list comprehensions have that nice benefit of catering to set-builder notation in mathematics.
08:28:57 <phadej> Taneb: fwiw, do notation probably feels weird to many when used with Maybe; so MonadComprehensions shouldn't be too "surprising" in that surprise
08:29:19 <phadej> (where surprise is Maybe is a Monad instance)
08:30:55 <maerwald> Selective is even weirder :P
08:31:41 <dminuoso> maerwald: Selective is sort of a dual to Applicative, it's more natural than you might think.
08:31:59 <maerwald> I don't think using it is intuitive at all
08:32:22 <maerwald> Takes a while to get used to
08:35:01 <phadej> it's really not dual, there are no arrows reversed
08:35:24 <phadej> different-ish monoidal structure, but still very unclear
08:35:55 <phadej> the ArrowChoice is (IMHO) way more natural and intuitive
08:36:06 <phadej> but people don't like arrows :(
08:36:58 <maerwald> it's just that you are never really forced to use them. The only non-trivial lib that uses them is hxt, no?
08:37:59 <Solonarv> there are one or two arrow-based FRP libs, too
08:39:27 <dminuoso> phadej: Maybe dual is the wrong word
08:39:47 <dminuoso> phadej: Im thinking about `(<+>) :: Monoidal f => f a -> f b -> f (a, b)` vs `select :: Selective f => f a -> f b -> f (Either a b)`
08:40:17 <dminuoso> (im aware the actual select type signature is different, but this version is sort of the same (except you have less parametricity from this)
08:41:31 <dminuoso> Though.. maybe it is differemt.
08:41:38 <phadej> that's not the type of symmetric-select
08:41:47 <phadej> it's branch :: Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c
08:41:53 <dminuoso> Ah
08:42:00 <hseg> Well, that's just a change of monoidal structures that the applicative functor preserves
08:42:35 <hseg> phadej: Yeah, but that's just church-encoding the Either
08:43:38 <phadej> hseg: it's **not** the same as `f a -> f b -> f (Either a b)` type
08:44:31 <hseg> No, but the church encoding is Either a b ~ (a->c) -> (b->c) -> c
08:44:54 <dminuoso> hseg: The interesting part however is the combining of the f.
08:45:17 <dminuoso> hseg: It's just like how Applicative is really just `(<+>) :: Monoidal f => f a -> f b -> f (a, b)`
08:45:23 <phadej> so with product you have to "lift" `(,)` (constructor); with sum you have to "lift" eliminator `either`
08:45:27 <dminuoso> (It's not exactly for unrelated reasons)
08:45:31 <phadej> as fmap lifts everything else
08:45:38 <phadej> fmap fst, fmap snd; fmap Left and fmap Right
08:45:54 <hseg> Hrm.
08:46:27 <dminuoso> phadej: Perhaps what I wrote is actually rather Alternative!
08:46:46 <phadej> dminuoso: yes, Left <$> x <|> Right <$> y
08:46:52 <phadej> indeed
08:47:26 <phadej> it's all very not-obvious, so I'd recommend not to use "fancy" CT words, unitl you are 99.9% sure it's the right word
08:47:41 <dminuoso> phadej: By the way http://oleg.fi/gists/posts/2018-02-21-single-free.html is a real blast. :)
08:47:58 <phadej> rather, be handwavy "it's like Applicative but for Either, in different way than Alternative"
08:48:14 <phadej> I should adher to this advice myself more too
08:48:46 <hseg> Hm. Applicative can be explained as saying f sends (,) to itself (uncurry <+> :: (f a, f b) -> f (a,b)) ). Is there such a formulation for Selective?
08:49:50 <hseg> Unrelated question: Doing some type tetris. Is there some way to tell GHCi to expand type synonyms?
08:50:17 <hseg> (e.g. :t liftA2 @(Cont Int) just gives me a mess of Cont's)
08:50:25 <dminuoso> hseg: use :kind!
08:50:33 <phadej> hseg: note that for Applicative, `fmap fst (liftA2 (,) x y) /= x`; in general; nor is `branch (fmap Left x) (pure id) y /= x`; but they could
08:51:13 <hseg> dminuoso: That gives me an error that liftA2 isn't a type variable
08:51:17 <hseg> phadej: Wait, what?
08:51:26 <dminuoso> hseg: Use it on the resulting type signature.
08:51:37 <hseg> phadej: Ah, because you might pick up the effects of y?
08:51:43 <phadej> hseg: yes
08:54:02 <hseg> :kind! doesn't expand the aliases
08:54:13 <hseg> It just spits them back
08:54:24 * hackage taskwarrior 0.1.2.1 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.2.1 (maralorn)
08:55:16 <sm[m]> sorry, got called away. Thanks for the answers. dminuoso, phadej, would those also be one-liners ? examples welcome
08:55:23 <sm[m]> taskwarrior! \o/
08:56:17 <dminuoso> sm[m]: list-comprehension is essentially just the list monad with MonadFail and MonadPlus
08:57:24 * hackage bytesmith 0.3.3.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.3.0 (andrewthad)
09:04:44 <hseg> Dammit. https://gitlab.haskell.org/ghc/ghc/issues/13795
09:07:31 <hseg> OK, working around that.
09:08:44 <hseg> Why can't I use Cont's Applicative instance to write (%+) <$> withSomeNat 3 <*> withSomeNat 2 ?
09:08:54 * hackage prettyprinter 1.6.0 - A modern, easy to use, well-documented, extensible pretty-printer.  https://hackage.haskell.org/package/prettyprinter-1.6.0 (sjakobi)
09:09:27 <hseg> (in actual code have function needing two singletons
09:09:29 <hseg> )
09:14:33 <nshepperd> there's a thing like Alternative but not, which goes 'guardA :: f (Maybe a) -> f a'
09:15:16 <nshepperd> i don't know what it's good for, but it has the interesting property that it lets you do choice at 'runtime' without having all the power of >>=
09:18:24 * hackage ip 1.7.1 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.7.1 (andrewthad)
09:19:54 * hackage tree-sitter 0.8.0.1 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.8.0.1 (robrix)
09:22:24 <dftxbs3e> dminuoso, SU
09:48:36 <hseg> Hm. Is there some variant of liftA2 that would have signature ((forall s t. f s -> f t -> c)) -> ((forall s. f s -> r) -> r) -> ((forall s. f s -> r) -> r) -> ((c -> r) -> r) ?
09:51:25 <hseg> (the idea would be to take some function f :: SNat n -> SNat m -> c and write liftA2' f (withSomeNat n) (withSomeNat m) :: (c -> r) -> r)
10:00:24 * hackage reflex 0.6.4 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6.4 (JohnEricson)
10:21:30 <maralorn[m]> I am very confused: https://hackage.haskell.org/package/feed says NixOS:1.3.0.0 but on nixpkgs master feed is still on 1.2.0.1. How can that be? How does hackage determine the distribution version?
10:26:04 <geekosaur> it's part of the cabal file, so (possibly mis)reported
10:26:53 <geekosaur> or the nix update is pending (it was tested and submitted but hasn't landed yet?)
10:27:53 <maralorn[m]> geekosaur: Is it? My lib is reported to be in nixos and I have definitely not changed my cabal file.
10:27:54 <maerwald> part of the cabal file?
10:28:43 <geekosaur> hm, thought I saw it in various cabal files. I don't know what it's using for data here then
10:29:44 <maralorn[m]> The cabal file displayed in hackage does also not contain the distribution information.
10:30:45 <sclv> distro versions are updated by distro maintainers
10:30:59 <sclv> its not cabal metadata
10:31:01 <hseg> ... OK, managed to construct what I wanted manually, but I'm betting there's a better way.
10:31:02 <geekosaur> yes, I just looked at it. nor does the upstream, which sometimes does have such information
10:32:47 <hseg> Is there a better way of writing
10:32:50 <hseg> type NatCont  r = (forall n. SNat n -> r) -> r
10:32:52 <hseg> type NatCont2 r = (forall n m. SNat n -> SNat m -> r) -> r
10:32:54 <hseg> liftSN2 :: NatCont2 r -> NatCont r -> NatCont r -> r
10:32:56 <hseg> liftSN2 f kx ky = kx (\x -> ky (\y -> f x y))
10:32:58 <hseg> ?
10:34:01 <hseg> I mean, the code is _exactly_ the same as that of Cont's Applicative instance, the only difference is that I want the "encapsulated value" of Cont to be existential.
10:35:08 <hseg> That actually gives me an idea -- how about type Cont1 r f = (forall x. f x -> r) r with the relevant instances?
10:35:19 <maralorn[m]> Yeah, apparently it‘s uploaded by peti. https://github.com/haskell/hackage-server/issues/287
10:35:52 <maralorn[m]> That probably means, that it is already bumped in a PR but not merged into master yet.
10:36:57 <hseg> But I'd need a parallel hierarchy (e.g. class Functor1 t where fmap1 :: (forall x. f x -> g x) -> t f -> t g) 
10:37:24 <phadej> @package hkd
10:37:24 <lambdabot> http://hackage.haskell.org/package/hkd
10:38:11 <maralorn[m]> What do you think about my statement: „I am not a fan of the "keep your dependencies small" philosophy. I feel it is the result of a false trade off which I don‘t want my language/eco system to drive me into.
10:38:11 <maralorn[m]> I feel like it leads to code duplication. And to the opposite of abstraction and modularization.”
10:38:20 <maralorn[m]> Where is the sweetspot for how much dependencies to use?
10:38:43 <hseg> phadej: Yeah, that looks like what I'm looking for.
10:38:55 <hseg> phadej: So now I need hk-transformers...
10:39:02 <phadej> :)
10:40:24 <phadej> maralorn[m]: if only there were way to avoid say, having utf8 decoding N times in the dependency footprint
10:42:02 <phadej> but if we'd go to very granular dependencies, human people heads will explode managing that complexity
10:42:55 <phadej> so as real world fact, you always depend on more code than you strictly need. And then people debate whether adding a depdendency just for a single function is tolerable or not
10:44:26 <phadej> that's distilled versions of e.g. lens vs. microlens
10:44:36 <phadej> ... discussions
10:45:27 <phadej> would you pull in whole lens, if you only need
10:45:29 <phadej> :t over
10:45:31 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
10:45:38 <phadej> which is implementable as
10:46:15 <maerwald> maralorn[m]: do you know the behavior of all your dependencies? Do you trust the maintainers to know what pvp is and make semantic incompatibilities visible? How will they do that?
10:46:38 <phadej> :t coerce (fmap :: (a -> b) -> f a -> f b) ::  ASetter s t a b -> (a -> b) -> s -> t
10:46:40 <lambdabot> error:
10:46:40 <lambdabot>     • Variable not in scope:
10:46:40 <lambdabot>         coerce
10:46:46 <phadej> :t unsafeCoerce (fmap :: (a -> b) -> f a -> f b) ::  ASetter s t a b -> (a -> b) -> s -> t
10:46:47 <lambdabot> error:
10:46:47 <lambdabot>     Variable not in scope:
10:46:47 <lambdabot>       unsafeCoerce
10:46:50 <phadej> :(
10:46:56 <phadej> %:t coerce (fmap :: (a -> b) -> f a -> f b) ::  ASetter s t a b -> (a -> b) -> s -> t
10:47:06 <phadej> % 1
10:47:06 <yahb> phadej: 1
10:47:09 <phadej> % :t coerce (fmap :: (a -> b) -> f a -> f b) ::  ASetter s t a b -> (a -> b) -> s -> t
10:47:09 <yahb> phadej: ; <interactive>:1:1: error:; * Couldn't match representation of type `f0 b0' with that of `s1 -> t1' arising from a use of `coerce'; * In the expression: coerce (fmap :: (a -> b) -> f a -> f b) :: ASetter s t a b -> (a -> b) -> s -> t
10:47:27 <phadej> ah, sorry; not that
10:47:38 <phadej> but anyway, as a oneliner
10:47:56 <mniip> you can :t unsafe functions in lambdabot btw
10:48:02 <mniip> :t Unsafe.Coerce.unsafeCoerce
10:48:17 <lambdabot> a -> b
10:48:21 <maralorn[m]> maerwald: Well that would at least be an argument against just some libraries not against having a lot of dependencies in general, doesn‘t it?
10:48:31 <maralorn[m]> I mean I can agree with "only have good dependencies". ;-)
10:48:43 <maerwald> maralorn[m]: well, the more libraries you have, the harder it becomes to guess what your program does
10:49:59 <maerwald> If you wrote it yourself, you defined the behavior as you wanted.
10:50:10 <maralorn[m]> maerwald: I thought the problem is mostly about install and compilation resources.
10:54:07 <maerwald> the problem is you don't really know all the behaviors of foreign code
10:54:13 <maralorn[m]> maerwald: Well I sympathize with the "I can only be sure if I do it myself" point of view. But that’s not my idea of programing. I am so glad that I don‘t have to solve everything by myself. I want to share as much code as possible. Life is short but a big community can make it very efficient.
10:54:36 <maerwald> well, sometimes things are solved badly
10:55:23 <maralorn[m]> Okay, still sounds to me like "use only good dependencies".^^
10:55:29 <maerwald> to some degree yes
10:55:38 <maerwald> But you can only know that many dependencies well
10:55:50 <maerwald> Like, most haskell backend devs probably know aeson inside out and a few other common things
10:55:53 <maerwald> but it probably stops there
10:55:54 <phadej> % :t coerce (id @((Int -> Int) -> Char -> Char)) :: ASetter' Char Int -> (Int -> Int) -> Char -> Char
10:55:54 <yahb> phadej: ASetter' Char Int -> (Int -> Int) -> Char -> Char
10:56:17 <maralorn[m]> Well I don‘t know the linux kernel code. I still run it.
10:56:20 <phadej> ^ so over is coerce id; would you depend on _any_ library for that? :)
10:56:41 <phadej> % :i ASetter
10:56:42 <yahb> phadej: type ASetter s t a b = (a -> Identity b) -> s -> Identity t -- Defined in `Control.Lens.Setter'
10:56:56 <phadej> given that type-alias is just... type-alias
10:58:18 <phadej> (it's not implemented like there anywhere AFAIK, as it's tricky if you want to support pre Coercible GHCs, like microlens and lens do)
11:01:05 <maerwald> maralorn[m]: and yeah, I pick libraries based on maintainers sometimes
11:01:30 <maerwald> because they can change the behavior of my code :P
11:04:04 <maerwald> for example, I don't trust haskell-tls, so I have to track down transitive dependencies and whether something is using it implicitly
11:04:20 <maerwald> which is actually a lot
11:04:38 <maralorn[m]> maerwald: It‘s interesting. That‘s a good point. And kinda orthogonal to the arguments I was expecting.
11:04:59 <maralorn[m]> I always here people complaining about "heavy" dependencies.
11:05:33 <maerwald> it would be cool if hackage had a rating for dependency footprint
11:05:45 <maerwald> could be something like 0-5
11:06:35 <maerwald> then it's easier to evaluate if using that one function from package X warrantes that dependency footprint
11:06:50 <MarcelineVQ> there's a list of some things at least, though not sortable live
11:06:55 <MarcelineVQ> https://packdeps.haskellers.com/reverse
11:07:03 <maerwald> since v2-build you really don't even notice the difference in build-times anymore lol
11:07:37 <maerwald> could be achieved with diffing freeze files too
11:07:47 <MarcelineVQ> oops that list wasn't the one I thought it was
11:08:14 <MarcelineVQ> still a neat link tho
11:08:37 <MarcelineVQ> people sure seem to like aeson
11:09:12 <maralorn[m]> I like aeson.
11:10:41 <hseg> maerwald: For curiosity's sake, what do you have against haskell-tls?
11:12:21 <maerwald> hseg: https://github.com/vincenthz/hs-tls/issues/117 is one reason, another is that doing security relevant things in a GCed language is questionable anyway. There was a thread on haskell-cafe about all the intricacies of doing that
11:12:27 <maerwald> I don't see any of them addressed
11:13:38 <maerwald> Nor am I confident that any of this was audited
11:15:18 <day> maerwald: what does GCed mean?
11:15:26 <hseg> garbage collected
11:15:29 <day> ah
11:15:51 <ystael> does cabal have a way to ban specific transitive dependencies? (like haskell-tls in this case)
11:17:33 <maerwald> https://leonmergen.com/on-the-state-of-cryptography-in-haskell-c272fb0b6478
11:18:05 <maerwald> and here's an old thread about the topic https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118059.html
11:18:12 <hseg> maerwald: Point. Would be nice if there were a tls implementation in a sufficiently strongly typed language with good memory control
11:19:58 <day> maerwald: out of curiosity, are modern implementations resistant to this? the comments make it sound like it is technically impossible, due to the 'constant time' requirement tomato42 names
11:21:04 <hseg> maerwald: something a la https://www.microsoft.com/en-us/research/project/project-everest-verified-secure-implementations-https-ecosystem/ for example
11:21:38 <maerwald> hseg: exactly
11:22:46 <hseg> The idea of doing crypto in a language with a stronger type system than C is sound and great. The choice of haskell, while correct re the "stronger type system" part, loses out on the requisite memory control
11:23:12 <maerwald> day: I wasn't so much struck by the CVE details (and don't understand them well enough), but by some of the comments there
11:24:20 <hseg> maerwald: I suppose Cryptonite has the same problems?
11:24:22 <day> maerwald: idk. there was a lot of whining from multiple involved parties. and i don't know how fast he replied/ prepared before replying
11:24:23 <wildtrees> I heard something about a rust tls a while back 
11:25:13 <day> i try not to judge. especially not people on topics they clearly understand vastly better than i do :D
11:25:26 <maerwald> day: I would expect people who work on crypto and security relevant stuff to be paranoid and not tell users "hey, can you prove that our implementation does not run in constant time?"
11:25:47 <maerwald> which it clearly doesn't
11:25:55 <day> yeah that one was a bit odd. but common, it is impossible he doesnt understand that this statement makes no sense
11:26:03 <day> probably something written in the heat of the moment
11:26:37 <maerwald> day: yes, but this is no joke library
11:28:52 <day> i dont know the background of the project, but is he getting paid for this or is that just a hobby project that got big because people started to use it?
11:28:59 <maerwald> not many non-haskell-tls http clients out there, I only found https://hackage.haskell.org/package/http-io-streams
11:29:53 <Solonarv> ystael: yes, in a roundabout way: you can specify an impossible constraint, like 'bad-package < 0 && > 0'
11:29:55 <nshepperd2> should i write a drop in replacement for tls that uses openssl
11:29:59 <day> im not saying thats ideal, but thats simply a risk of opensource. people like to use free stuff without asking questions
11:32:27 <dmwit> Solonarv: That seems like it would just make it impossible to create a build plan, not prevent bad-package from being in a successful build plan.
11:32:47 <maerwald> day: sure, but as long as there are alternatives...
11:34:15 <maerwald> day: that's also why I use LibreSSL. Not because I understand the code and can say its higher quality, but because of the maintainers attitude (e.g. aggressively removing questionable stuff, instead of keeping it years for backwards compat)
11:34:39 <nshepperd2> (the checkPassword function in snap lets you compare two unencrypted passwords, instead of throwing an error, and uses == on ByteStrings for the comparison. with obvious consequences)
11:35:52 <Solonarv> dmwit: correct
11:35:58 <Solonarv> it's a start, though!
11:36:50 <maerwald> hseg: I don't know, but it has the same maintainer ;)
11:36:53 <Solonarv> and cabal will happily tell you which transitive chain of dependencies is adding bad-package, so you can set about replacing them
11:37:52 <hseg> maerwald: :facepalm: OK, thanks for reminding me not to do crypto in haskell 
11:38:52 <maerwald> I guess calling into a C library should be fine... or is it?
11:39:53 <cocreature> if I want to block until a handle (stdin) is closed, do I just call `hIsEof` until it returns True or is there a nicer option?
11:40:35 <hseg> maerwald: do we have guarantees on ffi memory semantics?
11:40:42 <maerwald> from reading about the everest project, my impression was: use high-level languages to prove the *logic* of the code, never the behavior. For that you want to emit low-level code and run further proofs on that
11:41:43 <maerwald> like, it's fine to describe protocols in haskell, but don't actually run them in haskell :P
11:42:14 <maerwald> hseg: good question, I also have no idea
11:43:40 <hseg> Well, assuming you have guarantees on the memory semantics (e.g. if haskell could compile to a no-gc variant), you might be able to code stuff in high-level
11:43:51 <hseg> But so far, that's not what these languages are optimized for
11:43:54 * hackage ghc-events-analyze 0.2.7 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.7 (EdskoDeVries)
11:44:22 <wildtrees> is there a name for using something like tagless-final in object oriented languages? 
11:44:42 <nshepperd2> what guarantees would you want from the ffi?
11:46:09 <hseg> Basically, constraints on the time to marshall/unmarshall & in-memory representation.
11:46:26 <hseg> Also, interaction b/w marshalled data and RTS's GC
11:54:56 <cocreature> wildtrees: object algebras, https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/ provides a very nice comparison
11:56:16 <wildtrees> thank you cocreature 
11:59:23 * hackage mmsyn7ukr 0.7.3.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.3.0 (OleksandrZhabenko)
12:03:04 <wildtrees> cocreature, what about something like this https://0paste.com/50520 is program1() there still an object algebra? 
12:03:57 <cocreature> wildtrees: it’s been too long since I’ve looked at this and I don’t have time to reread that post atm, sorry
12:04:43 <wildtrees> oh ok thank you anyways 
12:07:53 * hackage hal 0.4.0 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.4.0 (nikeoss)
12:19:59 <det0x[m]> hi everyone, does anyone use spacemacs for haskell development here?
12:20:54 * hackage mmsyn7ukr 0.7.3.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.3.1 (OleksandrZhabenko)
12:21:37 <Solonarv> det0x[m]: some people around here do, stick around for a while if you don't get an answer right away - also maybe go ahead and state your question rather than waiting for someone to jump into the unknown :)
12:22:52 <det0x[m]> Im using hoogle lookup SPC m h h to do a hoogle lookup but the results are only showing 20. Where would I increase the count?
12:24:00 <det0x[m]> Also, does anyone have a favorite utils library they wanna share? Looking at https://github.com/haskell-hvr/missingh now
12:28:38 <maralorn[m]> Is there a nice tagless-final introduction I can read?
12:30:49 <Nolrai> is there a better way to write the middle paragraph of https://pastebin.com/G0B7zd7e
12:31:00 <Nolrai> ?
12:31:54 * hackage too-many-cells 0.2.2.1 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.2.2.1 (GregorySchwartz)
12:32:58 <Solonarv> Nolrai: that doesn't look like it typechecks? specifically, the 'putStrLn (putStrLn ...' bit
12:34:43 <Nolrai> You would be correct. Weird copy paste error there..
12:34:50 <Solonarv> to answer your question more directly, this can be greatly shortened to: compressed <- either die pure (decodeBase64 blueprintString)
12:35:11 <Solonarv> 'die' is from System.Exit, btw
12:35:42 <Nolrai> :t die
12:35:43 <lambdabot> error:
12:35:43 <lambdabot>     • Variable not in scope: die
12:35:43 <lambdabot>     • Perhaps you meant ‘div’ (imported from Prelude)
12:36:09 <Solonarv> % :t System.Exit.die
12:36:09 <yahb> Solonarv: String -> IO a
12:36:32 <Solonarv> roughly: die msg = hPutStrLn stderr msg >> exitFailure
12:36:52 <Solonarv> see, it even correctly prints the error message to stderr like you're supposed to! :D
12:37:48 <Nolrai> Nice!
12:38:36 <Solonarv> alright, gotta go now
12:38:42 <Nolrai> Thanks!
12:38:47 <wildtrees> maralorn[m], mostly this http://okmij.org/ftp/tagless-final/index.html is what I used to get into it, one more link following...
12:40:08 <wildtrees> maralorn[m], I have read like the first 20 pages of this paper, http://okmij.org/ftp/tagless-final/index.html#course-oxford most of it so far isn't too complicated if you know how to use typeclasses, has some interesting tricks for more polymorphism for your typeclasses as well 
12:42:41 <maralorn[m]> wildtrees: Thank you!
12:42:58 <wildtrees> maralorn[m], you are welcome :D 
12:43:32 <maralorn[m]> Will bookmark that.
12:50:23 <wildtrees> maralorn[m], I made a simple embedded domain specific (mini) language in haskell using like half that paper I linked, has an interpreter for a language with some input output and a while loop iirc and can also spit out ruby code that does the same thing, from the same edsl , also had a version of the language that could run on given inputs and produce outputs, all pure, no IO to it , same edsl as well 
12:53:24 * hackage warp-grpc 0.3.0.0 - A minimal gRPC server on top of Warp.  https://hackage.haskell.org/package/warp-grpc-0.3.0.0 (LucasDiCioccio)
12:54:24 * hackage mmsyn7ukr 0.7.4.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.4.0 (OleksandrZhabenko)
12:54:52 <ezzieyguywuf>  is it possible in ghci to list all the type classes that a particular data type is an instance of?
12:55:15 <solonarv> :info lists all the visible instances
12:57:10 <ezzieyguywuf> solonarv: nice! thanks
13:16:20 <[itchyjunk]> hi, do you see something obviously wrong with f p = 2^((p-1)/2) `mod` p ?
13:19:49 <[itchyjunk]> i am getting zillions of errors :s
13:20:09 <[itchyjunk]> maybe i need to tell it that p is an integer but idk how to do it in ghci
13:20:24 <Nolrai> mod takes intergral values "/" takes floating values.
13:20:44 <Nolrai> `div` is integer division.
13:20:47 <[itchyjunk]> ah
13:24:06 <[itchyjunk]> ah it works now /o\
13:24:56 <[itchyjunk]> too bad haskell can't do the second part of this problem for me :D
13:26:00 <ChaiTRex> [itchyjunk]: What is the second part of the problem?
13:33:33 <[itchyjunk]> ChaiTRex, https://imgur.com/a/tEAafSu
13:37:34 <ChaiTRex> > let f p = 2^(p `div` 2) `mod` p in map f [3, 5, 7, 11, 13, 17, 19]
13:37:36 <lambdabot>  [2,4,1,10,12,1,18]
13:39:19 <[itchyjunk]> p -1 but yes thats similar to what i did
13:39:49 <ChaiTRex> [itchyjunk]: The `div` does flooring, removing the - 1 anyway for odd numbers.
13:40:10 <ChaiTRex> > let f p = 2^((p - 1) `div` 2) `mod` p in map f [3, 5, 7, 11, 13, 17, 19]
13:40:12 <lambdabot>  [2,4,1,10,12,1,18]
13:40:20 <[itchyjunk]> oh
13:42:14 <ChaiTRex> > let balMod a b = let m = mod a b in if m > div b 2 then m - b else m; f p = 2^(p `div` 2) `mod` p in map f [3, 5, 7, 11, 13, 17, 19]
13:42:16 <lambdabot>  [2,4,1,10,12,1,18]
13:42:23 <ChaiTRex> > let balMod a b = let m = mod a b in if m > div b 2 then m - b else m; f p = 2^(p `div` 2) `balMod` p in map f [3, 5, 7, 11, 13, 17, 19]
13:42:25 <lambdabot>  [2,4,8,32,64,256,512]
13:42:31 <ChaiTRex> No, that's not it.
13:46:48 <ChaiTRex> > let balMod a b = let m = mod a b in if m > div b 2 then m - b else m; f p = 2^(p `div` 2) `balMod` p in map (`balMod` 10) [0 .. 30]
13:46:51 <lambdabot>  [0,1,2,3,4,5,-4,-3,-2,-1,0,1,2,3,4,5,-4,-3,-2,-1,0,1,2,3,4,5,-4,-3,-2,-1,0]
13:47:26 <ChaiTRex> > let balMod a b = let m = mod a b in if m > div b 2 then m - b else m; f p = (2^(p `div` 2)) `balMod` p in map f [3, 5, 7, 11, 13, 17, 19]
13:47:28 <lambdabot>  [-1,-1,1,-1,-1,1,-1]
13:47:34 <ChaiTRex> Ahh, precedence.
14:00:25 <ezzieyguywuf> I'm reading about monads here http://learnyouahaskell.com/a-fistful-of-monads. There is a line where the instance definition of `Maybe` for the `Monad` typeclass is given. In that definition, there is `Just x >>= f  = f x`. I do not understand how Haskell can be sure that `f` is of type `a -> Maybe a`
14:00:45 <ezzieyguywuf> which it must be, in order to be a `Monad` instance, right?
14:01:09 <ezzieyguywuf> hah, ah wait, nvm just answered my own question
14:01:17 <ezzieyguywuf> it's built into the type definition of `>>=`
14:01:21 <ezzieyguywuf> wow what a neat language~
14:01:29 <merijn> ezzieyguywuf: :)
14:02:04 <ezzieyguywuf> in this line `ghci> Just 9 >>= \x -> return (x*10)` is ghci infering the proper type for the lambda?
14:02:16 <iqubic> Yes.
14:02:21 * ezzieyguywuf nods
14:02:22 <iqubic> It always does.
14:02:29 <merijn> ezzieyguywuf: Inferring the proper type for the lambda and (transitively) for return
14:02:40 <merijn> > return True :: Maybe Bool
14:02:43 <lambdabot>  Just True
14:02:45 <merijn> > return True :: [Bool]
14:02:47 <lambdabot>  [True]
14:02:48 <ezzieyguywuf> "it always does", that's deep
14:03:26 <merijn> ezzieyguywuf: In Haskell2010 (i.e. no extensions) all types are inferrable (there are some extensions that make that impossible, though)
14:06:21 <Heffalump> Is there any clever type trickery I can use to get hold of some runtime reflection of a polymorphic type? I think I can write getType :: MyClass a => a -> MyStructure and have things like getType "foo" and getType (\a -> a ++ "foo") work (like with Data.Typeable), but I don't know how to handle something like getType id and getType show.
14:06:46 <merijn> Heffalump: That way lies sadness and madness
14:06:53 <Heffalump> :-)
14:07:34 <merijn> Heffalump: Why do you want/need that?
14:09:11 <Heffalump> runtime optimisation, basically. I'm writing some arbitrary functions that may or may not use values from an input environment. I'd like to write that code, use type inference to figure out the minimum set of dependencies on that environment, and then (at runtime) look at the inferred type to optimise the way I call that code.
14:09:37 <Heffalump> I'm using Data.Type.Map from type-level-sets to define the environments, so I can already track dependencies in the type system.
14:10:17 <Heffalump> I'm guessing it's not possible because the type-checker will want to instantiate my type before it lets me use it. But it's easy to miss some clever tricks with latest GHC Haskell.
14:10:29 <merijn> This sounds like a whole lot of Hasochism, tbh :)
14:11:14 <merijn> Heffalump: Can't you just explicitly specify which version to use? Rather than trying to do all this at the type level
14:11:33 <Heffalump> what do you mean by version?
14:12:21 <Heffalump> I mean, yes, I could declare the dependencies explicitly at the value level (or in a monomorphic type signature), and at least they'd be checked. But I'd like to be able to infer them.
14:12:31 <merijn> Heffalump: Well, you seem to imply there's multiple possible code paths, depending on what you pass in, so why not make that explicit?
14:13:34 <Heffalump> right, that's what I'll have to do if I can't do what I want (which seems quite likely :-)
14:14:13 <merijn> Heffalump: It might be possible, I'm just almost certain that if it is, it's not worth the hassle/pain
14:32:29 <wildtrees> Heffalump, maybe you want something like tagless final? mtl is kinda like tagless final iirc 
14:32:54 * hackage hal 0.4.1 - A runtime environment for Haskell applications running on AWS Lambda.  https://hackage.haskell.org/package/hal-0.4.1 (nikeoss)
14:35:03 <Heffalump> wildtrees: hmm, not sure how that'd work
14:35:53 <wildtrees> like you want polymorphism but with different functions for different types 
14:36:15 <wildtrees> you can kind of use typeclasses and wrap the different types in newtypes if you say need different features for String 
14:36:42 <Heffalump> I don't think that helps me with finding out which of those wrappers my code actually sued.
14:36:46 <Heffalump> *used
14:39:18 <wildtrees> if you dispatch by types using different typeclasses something like class (Reify a) where reify :: a -> SomeSumTypeRepresentingEachType 
14:39:57 <wildtrees> data SomeSumTypeRepresentingEachType = WasAnInteger | WasAString | etc... 
14:41:05 <Heffalump> I know how that would work if the thing I pass to reify has a monomorphic type
14:41:56 <wildtrees> there is a trick with newtypes and internal foralls's using Rank2/NTypes that can allow your polymorphic code to be more polymorphic 
14:42:13 <wildtrees> let me see if I can dig it up 
14:42:21 <Heffalump> thanks
14:48:07 <wildtrees> Heffalump, http://okmij.org/ftp/tagless-final/course/lecture.pdf page 10 about way half down has a newtype with a forall symbol, you can use that trick to wrap typeclass polymorphic code and run it on differerent instances
14:48:32 <wildtrees> you need either Rank2Types or RankNTypes enabled as a language extension to get the forall though 
14:48:40 <Heffalump> that's ok :-)
14:48:44 <wildtrees> :)
14:48:45 <Heffalump> I'm not short of language extensions.
14:49:46 <Heffalump> I'm not sure I'll be able to use that to capture unpredictable polymorphism, but it might help. I'll have a play.
14:49:54 <Heffalump> Thanks!
14:51:04 <wildtrees> your polymorphism will need a constraint on it , or wait I think I have seen it work without constraints, not sure 
14:51:56 <Heffalump> part of the problem is I have an unknown number of polymorphic variables
14:52:03 <Heffalump> with unknown constraints :-)
14:53:40 <wildtrees> maybe you could do something like the typeclass for printf trick, I don't know where that one is located though and I have never used it myself, just heard of it, gives you like var args that can be different types 
14:54:08 <hseg> Hm - you guys' discussion might be relevant for my problem: am trying to define an "Applicative" instance for Cont r so that the following is a valid instantiation of liftA2: (forall n m. SNat n -> SNat m -> SNat (n+m)) -> ((forall n. SNat n -> r) -> r) -> ((forall m. SNat m -> r) -> r) -> ((forall nm. SNat nm -> r) -> r)
14:54:10 <hseg> ?
14:54:35 <Heffalump> wildtrees: yeah, I was wondering if I can somehow peel off each polymorphic variable one at a time
14:54:56 <wildtrees> you are still gonna need instances defined for them somewhere I think 
14:55:13 <hseg> Thought Rank2.Apply from rank2types was a good fit, but seem to need the internal (* -> *) to be applied at the same types
14:56:25 <hseg> (i.e. the type signature they give for liftA2 specializes here to (forall a. f a -> g a -> h a) -> ((forall a. f a -> r) -> r) -> ((forall a. g a -> r) -> r) -> ((forall a. h a -> r) -> r) )
14:57:29 <hseg> which *looks* like it should be implementable -- after all, the foralls in the Cont arguments are in positive position, so I should be able to enforce they're equal
14:57:30 <Heffalump> hseg: so you need h a to unify with SNat (n+m) somehow?
14:57:40 <Heffalump> (maybe I'm missing the crux of your problem)
14:57:42 <JSharp> dftxbs3e: 
14:57:43 <hseg> Yeah, but that's step 2
14:57:54 <hseg> Firstly, I even need to get liftA2 working
14:58:15 <hseg> bc GHC complains the a's in the two Cont parameters differ
14:58:18 <JSharp> dftxbs3e: yes, I do have ghc and stack working on ppc64le - less the GHC RTS dynamic linker
14:59:02 <hseg> Step 2 would be to figure out how to make (forall a. f a -> g a -> h a) unify with (forall n m. SNat n -> SNat m -> SNat (n+m))
14:59:22 <Heffalump> hseg: that seems hopeless even if you get past the first bit :-)
14:59:40 <hseg> (for that I'll probably need to extend rank2types' classes to BiApplicative)
14:59:47 <hseg> Right
15:01:26 <hseg> (though looking at https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor-Apply.html, think they're using a different definition of BiApplicative than I'm thinking of)
15:02:03 <hseg> (specifically, I'd want liftA2 :: (forall a b. f a b -> g a b -> h a b) -> ...)
15:02:28 <hseg> (well, then again that's the wrong package to take inspiration from)
15:03:13 <hseg> Hrm. Might it be possible to define the liftA2 I'm after given instances for Const and Cont?
15:03:38 <hseg> ... though that's probably a bit of a big ask
15:04:34 <wildtrees> hseg, this is a bit beyond me, though do you have a working Functor at least first? if you can't get it to fit into a standard typeclass maybe make your own? 
15:04:48 <hseg> Yes, I have a working Functor
15:05:21 <hseg> instance Rank2.Functor (MCont r) where { f <$> MCont mk = MCont $ \k -> mk (k . f) }
15:05:35 <hseg> where newtype MCont r f = MCont { runMCont :: (forall a. f a -> r) -> r }
15:05:59 <hseg> (That *should* behave correctly)
15:06:27 <hseg> Am trying to write instance Rank2.Apply (MCont r) where { liftA2 f (MCont mx) (MCont my) = MCont $ \k -> mx $ \x -> my $ \y -> _ }, but GHC complains x and y are applied at different indeces
15:08:13 <hseg> (i.e. recall liftA2 :: (forall a. f a -> g a -> h a) -> t f -> t g -> t h, where in this case t = (forall a. _ a -> r) -> r. Then x here is :: f a, y :: g b)
15:09:15 <hseg> So I cannot just fill the hole with k (f x y), since x and y are applied at different indeces)
15:13:03 <hseg> ... Wait! Unification is possible, albeit with some wrapping/unwrapping
15:13:53 <hseg> Let newtype Fst (a,b) = F a; newtype Snd (a,b) = S b; newtype Id (a,b) = I (a,b) 
15:14:44 <hseg> And let newtype Uncurry f (a,b) = U (f a b)
15:15:31 <hseg> Then the first parameter to liftA2 that I want is essentially of type (forall a. SNat (Fst a) -> SNat (Snd a) -> SNat (Uncurry (+) a))
15:15:47 <hseg> Right?
15:16:30 <wildtrees> whats SNat? 
15:16:34 <hseg> (You still have the problem that type families cannot be partially applied, but that can be avoided by defining Up (a,b) = Up (a + b))
15:17:06 <hseg> https://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/docs/GHC-TypeLits-Witnesses.html#t:SNat
15:17:24 <hseg> A singleton representing a type-level Nat
15:18:13 <hseg> (I'm going down this rabbit hole because I want to write an expression of form use <$> withRes1 <*> withRes2 ... <*> withResN)
15:18:29 <hseg> where the withResi are of type (forall k. f k -> r) -> r
15:18:47 <hseg> This should obviously be possible, since Cont r is Applicative
15:19:13 <hseg> But the usual Applicative instance cannot be used here, since I want the Rank 2 version of Cont
15:19:39 <hseg> viz my MCont defined above (recall: MCont r f = (forall k. f k -> r) -> r
15:19:40 <hseg> viz my MCont defined above (recall: MCont r f = (forall k. f k -> r) -> r)
15:20:21 <hseg> OK, so in my three-step plan to take over the rank-2 world, steps 2 and 3 are complete.
15:20:30 <hseg> Now I just need to get this ball rolling...
15:20:45 <wildtrees> what's it gonna do if you get it working, hseg ? 
15:21:36 <hseg> You'll be able to get multiple resources in one expression
15:22:07 <wildtrees> resources? 
15:22:19 <hseg> (i.e. instead of withRes1 $ \r1 -> withRes2 $ \r2 -> ... use r1 r2, you'll be able to write use <$> withRes1 <*> withRes2 <*> ...)
15:22:47 <hseg> That's my terminology for stuff that exposes a CPS API
15:23:57 <hseg> This is overengineered for my specific use case, but it's bugging me.
15:24:36 <hseg> (in my case, I have a function SNat n -> SNat m -> r that I want to apply two several calls of https://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/docs/GHC-TypeLits-Witnesses.html#v:withSomeNat)
15:25:08 <hseg> (obviously I could do the with $ \_ -> train, but why avoid a sensible abstraction?) 
15:26:00 <jle`> hseg: the way i usually do it is with do blocks
15:26:26 <jle`> SomeNat n <- pure 3
15:26:32 <jle`> er
15:26:38 <jle`> FromSNat n <- pure 3
15:26:42 <jle`> FromSNat m <- pure 5
15:26:47 <jle`> and now we have 'n' and 'm' in copse
15:27:00 <jle`> with the proper rank-n typing preserved
15:27:08 <hseg> ... wait, what?
15:27:18 <hseg> :headdesk:
15:27:25 <jle`> and run it over Identity or something
15:27:31 <jle`> it's admittedly kind of hacky
15:27:36 <hseg> OK, how does that work?
15:27:51 <jle`> remember that do notation is just sugar for >>=
15:27:55 <jle`> and it's "dumbly typed"
15:28:00 <hseg> Right...
15:28:03 <jle`> it does no type checking or anything as it translates to application of >>=
15:28:08 <hseg> wat
15:28:11 <jle`> so it can handle rank-n types just fine because it doesn't ahve to go through the type checker
15:28:22 <jle`> yeah it's a purely synactic transformation
15:28:28 <jle`> it translates to applications of >>= first, and then it typechecks
15:29:14 <jle`> so let's say we have runIdentity $ do FromSNat n <- pure 3; FromSNat m <- pure 5; pure (fromSing (n %+ n))
15:29:41 <jle`> (that should return 8 :: Natural, by through through addition of SNat 3 and SNat 5)
15:29:58 <jle`> that gets block gets syntactically translated to:
15:30:29 <jle`> Identity 3 >>= \(FromSNat n) -> Identity 5 >>= \(FromSNat m) -> pure (fromSing (n %+ m))
15:30:45 <jle`> basically exactly the CPS stype you would normally be writing
15:30:55 <jle`> *style
15:31:01 <hseg> ... :headdesk:
15:31:18 <jle`> it's not exactly an obvious trick though
15:31:27 <hseg> So runIdentity $ do can give me all the CPSing I want, _for free_?!
15:31:37 <hseg> fml
15:31:59 <jle`> yeah, because it doesn't need to be smart with types since the do notation is dumbly typed
15:32:20 <hseg> ... wait, how does this avoid the rank-2 problem?
15:32:21 <jle`> it's actually even more useful when you have things like IO Int because you can bind in IO
15:32:29 <hseg> How does this typecheck?
15:32:37 <jle`> hseg: well, you see how the desugared version typechekcs, right?
15:32:56 <jle`> hm maybe it might be better written as ...
15:33:06 <hseg> i'd need to see how the FromSNat desugars before I'd be convinced
15:33:14 <jle`> Identity 3 >>= \case FromSNat n -> Identity 5 >>= \case FromSNat m -> pure (fromSing (n %+ m))
15:33:30 <jle`> hseg: it's a 'dependent pattern match'
15:33:37 <jle`> hm, let me add parentheses
15:33:55 <jle`> Identity 3 >>= \case FromSNat n -> (Identity 5 >>= \case FromSNat m -> (pure (fromSing (n %+ m))))
15:34:05 <jle`> hseg: or rather, are you familiar with how dependent pattern matching works?
15:34:09 <wildtrees> are those pattern matching in the cases' refining the types? 
15:34:18 <hseg> Not really
15:34:18 <jle`> yeah, it's dependent pattern matching
15:34:36 <jle`> hseg: basically the case statement is the main way you bring proofs into scope
15:34:41 <jle`> in dependently typed programming
15:34:57 <jle`> when you write case myNat of FromSNat n -> {...}
15:34:57 <hseg> Ah. Yeah, am familiar with that from GADTs
15:35:12 <jle`> you're allowed to do anything you want in the {..}, as long as you don't let the introduced type variable escape
15:35:36 <jle`> so here we have Identity 3 >>= \nn -> case nn of FromSNat n -> {...}
15:35:41 <hseg> because the FromSNat ultimately desugars into a \case SomeNat (Proxy :: Proxy n), you have n in scope
15:36:05 <jle`> you have n in scope but you're not allowed to let it escape the body of the case statement
15:36:42 <hseg> Right
15:37:20 <jle`> so yeah, the desugard version typechecks fine, just along those rules
15:38:17 <jle`> this wouldn't really work if every 'suffix' of a do block were required to have a type-inferred type
15:38:40 <jle`> but it just works because the desugared version is just normal CPS style so it typechecks after it does the syntactical transformation
15:39:23 <hseg> Can this hack be used to define the liftA2 I wanted?
15:40:03 <hseg> (specifically, :: (forall a b. f a b -> g a b -> h a b) -> ((forall a. f a -> r) -> r) -> ...) 
15:40:08 <jle`> i don't know
15:40:20 <jle`> this hack doesn't add anything to the type system
15:40:25 <jle`> or give you any extra type capabilities
15:40:31 <jle`> it just aids in making your code cleaner syntactically
15:40:39 <hseg> Right
15:40:44 <jle`> it doesn't let you do anything you couldn't normally already do with case statmenets and cps and lambdas
15:40:50 <jle`> just makes it syntactically easier to write it :)
15:41:06 <jle`> so if you can't write it with lambdas and case statements then this doesn't help
15:43:20 <hseg> ah...
15:43:35 <hseg> so I'd still not be able to extract this pattern in its own function
15:43:43 <nshepperd2> i don't see the advantage of doing anything fancy with cps here
15:44:29 <hseg> Admittedly, it's a bit of golfing
15:44:52 <hseg> I could very well just write with $ \r1 -> with $ \r2 -> use r1 r2
15:45:08 <hseg> but "see pattern, extract" is a bit of an instinct
15:45:23 <hseg> especially when it resembles a known-good pattern
15:47:19 <nshepperd2> do [SomeNat a, SomeNat b, SomeNat c] <- pure [sa, sb, sc]
15:48:56 <hseg> :facepalm: Right. Why didn't I look at the pattern synonyms before?
15:49:03 <hseg> It's even listed in the examples
15:51:37 <iqubic> How does that work?
15:52:27 <nshepperd2> it's just regular old pattern matching
15:53:04 <hseg> Well, in fact found out I can rewrite my usecase using the FromSNat synonym
15:53:40 <hseg> Would still be a cute exercise to see if I can write the rank-2 Cont Applicative instance, but that's for another time
15:57:29 <nshepperd2> i think it's technically rank-3 if you'd be expecting it to accept a rank-2 argument
15:58:58 <nshepperd2> but there's no need to do that. it'd always make more sense for a function to take a SomeNat than the rank2 church encoding of it
15:59:23 <hseg> right, I meant the rank3 Applicative instance of rank2 conts
15:59:34 <hseg> and as you say, that's navel-gazing
16:00:25 <hseg> Hm. Interesting that GHC doesn't complain about me writing toSomeNat 1 %+ 1 within a file, but does within GHCi
16:01:07 <hseg> ... that should be SNat @1 %+ 1
16:01:39 <iqubic> What does %+ do?
16:01:41 <wildtrees> monomorphism restriction being on and off? 
16:02:55 <hseg> iqubic: SNat summation
16:03:13 <hseg> wildtrees: Nope, FlexibleContexts and a Num (SNat n) instance
16:03:24 <hseg> ofc, the latter makes no sense
16:03:28 <holaskell> i think learning haskell is very useful in helping me solve algorithm problems by composing stuff together, the fact  its something executable and not just something i write on paper is quite useful, do you have specfic resources that helps me get used to the various constructs like foldl, reduce and stuff
16:04:05 <ChaiTRex> hseg: Did you turn on FlexibleContexts in GHCi?
16:04:55 <wildtrees> holaskell, I played around with functions at a ghci prompt alot and still do there is also > for lambdabot here and % for yahb here as well 
16:05:42 <hseg> Yep
16:06:05 <hseg> btw, what's the difference between lambdabot and yahb?
16:06:28 <holaskell> i have a stack setup that i can run tests easily
16:06:48 <holaskell> but i dont have any particular "project" to utilize them
16:06:59 <holaskell> so far i just have random Libs that does random stuff
16:07:00 <hseg> Oh well, GHC will probably complain once I have fixed the other errors
16:08:41 <wildtrees> hseg, to my knowledge lambdabot is a custom repl and yahb offers an actual ghci repl 
16:08:54 <nshepperd2> lambdabot is magic, while yahb is more magic
16:09:53 <hseg> :D
16:10:22 <maerwald> their entire source code has been put on type level
16:10:59 <hseg> Dammit, so annoying that ~ binds so tightly
16:11:15 <hseg> (d ~ r+1) should parse as (d ~ (r+1)), not the other way round
16:12:03 <hseg> Excellent, more errors, but sensible ones this time
16:12:37 <nshepperd2> hseg: i think your rank 3 "Applicative" actually needs impredicative types to work how you want it to
16:13:17 <nshepperd2> cause you need the type variables of <*> to range over arbitrary rank2 types
16:13:40 <hseg> Oh?
16:14:04 <nshepperd2> only problem is impredicative types are broken in ghc and type inference is impossible so you'd have to annotate the types of everything
16:14:25 <nshepperd2> which would be worse than a tower of withNats
16:14:53 <hseg> I want liftA2 :: (forall a. f a -> g a -> h a) -> t f -> t g -> t h, where t f ~ ((forall a. f a -> r) -> r). How does this require impredicative types?
16:15:17 <nshepperd2> what about liftA3?
16:15:41 <hseg> (forall a. f a -> g a -> h a -> k a) -> t f -> t g -> t h -> t k
16:15:47 <hseg> with t as above
16:16:38 <nshepperd2> would you define each level of liftA separately then?
16:16:45 <hseg> (this is assuming (forall a. f a -> g a -> h a) can be specialized to (forall (a,b). f (a,b) -> g (a,b) -> h (a,b)), otherwise I need to reingineer)
16:17:12 <hseg> No, I'm trying to write an instance of https://hackage.haskell.org/package/rank2classes-1.3.1.2/docs/Rank2.html#t:Apply
16:17:29 <hseg> Of course, liftN is much deeper magic to implement
16:17:43 <hseg> but individual lifti are just compositions of lift2
16:18:21 <nshepperd2> not when you need things to be higher rank...
16:20:17 <hseg> Why? What's wrong with liftA3 f g h i = liftA2 (\p q-> f p q) g h <*> i ?
16:20:50 <hseg> Unless you're referring to the fact that you need to apply everything in sight at the same type index, which was my problem earlier
16:24:41 <nshepperd2> what's wrong is when you write that a bunch of type variables suddenly need to be instantiated with polymorphic types
16:24:52 <hseg> ?
16:25:05 <nshepperd2> like that <*> there
16:25:20 <hseg> explain please
16:26:08 <hseg> only instantiations in what i've said so far which i can see are wanting (forall a. ...) to instantiate to (forall (a,b). ...)
16:26:57 <hseg> and having a problem writing liftA2 for Cont r because the continuations of the two Cont r parameters might be given at different type indeces
16:27:55 <nshepperd2> well, what's the type of liftA2 there
16:28:52 <hseg> fully expanded, my desired liftA2 :: (forall a. f a -> g a -> h a) -> ((forall a. f a -> r) -> r) -> ((forall a. g a -> r) -> r) -> ((forall a. h a -> r) -> r)
16:29:39 <hseg> Or are you talking about the general type?
16:30:51 <hseg> That would be g (/\a. p a -> q a) -> g p -> g q (we're actually going through a newtype here)
16:34:20 <hseg> Actually, rewriting my Cont with that newtype, I can write the Cont instance. Let MCont r f = MCont ((/\a. f a -> r) -> r). Then liftA2@(MCont r) f (MCont kx) (MCont ky) = MCont $ \k -> kx $ \x -> ky $ \y -> k (/\a. f a (x a) (y a)) 
16:35:04 <nshepperd2> here's the problem: you can't specialise a type into a type with more foralls
16:35:33 <hseg> ... was suspecting that'd be the case
16:36:43 <hseg> So this is unlike the term level, where e.g. length :: forall a. [a] -> Int specializes to length :: forall a b. [(a,b)] -> Int ?
16:38:53 <nshepperd2> you can't unify  ((forall a. h a -> r) -> r) with anything that would typecheck when you apply (<*> rank2thing) to it
16:40:42 <nshepperd2> hseg: hm, not quite what i meant
16:42:06 <nshepperd2> hseg: the thing you can't do is 'specialise' forall a. [a] -> Int into [forall b. b] -> Int
16:43:51 <nshepperd2> or, in this case 'g (/\a. p a -> q a) -> g p -> g q' into something with q replaced with some rank 2 expression
16:45:00 <wildtrees> whats /\ mean? 
16:50:29 <Axman6> forall I assume
16:52:42 <hseg> wildtrees: dependent product. Basically, idea is that you can capture and pass type variables in much the same way as you can terms
16:53:17 <wildtrees> like (n ** Vec n Int) from idris? 
16:54:20 <hseg> ... a moment, trying to find a reference
16:57:31 <hseg> Idrisly, I'd want MCont r f = MCont ((a:Type) -> f a -> r) -> r
16:58:15 <hseg> which would make the k (\a -> f a (x a) (y a)) part of my definition correct
16:59:38 <hseg> nshepperd2: well, you obviously can't specialise forall a. [a] -> Int into [forall b. b] -> Int. The latter is a heterogeneous list, the former homogeneous
17:00:55 <hseg> nshepperd2: your quibble is that we can't specialize the f in ((forall a. f a -> r) -> r) to (/\a. p a -> q a) ?
17:01:05 <hseg> nshepperd2: because the latter is of rank 2?
17:01:09 <nshepperd2> actually it's a list of undefineds
17:01:38 <nshepperd2> (cos of course undefined is the only thing that inhabits forall b. b)
17:01:59 <nshepperd2> hseg: yes
17:02:24 <hseg> Yeah but still. Wouldn't call that a homogeneous list.
17:02:29 <hseg> ... ahh
17:02:38 <nshepperd2> you can't specialise the f, or the a, or the r, to *anything* with a forall it in 
17:03:20 <hseg> because specialization in ghc inherently wants the specialized term to be rank-1
17:03:30 <hseg> s/specialized/specializing/
17:05:39 <hseg> otoh, if we had dependent types, i could write the type of liftA2 as g (forall a -> p a -> q a) -> g p -> g q (i think)
17:06:04 <hseg> (where forall a -> here means the type a must be passed explicitly)
17:06:38 <hseg> :/ all depends on what is allowed to specialize.
17:07:01 <hseg> don't have good enough intuitions re dependent types to know whether this is sensible
17:08:21 <nshepperd2> well, the proper way of talking about this is to talk about instantiating type variables
17:08:24 <MarcelineVQ> isn't that ill-kinded?
17:08:29 <hseg> ... well - at least your pathological example rewrites to "given forall a -> [a] -> Int, get [forall a -> a] -> Int", which looks sensible to me
17:09:11 <hseg> nshepperd2: Right. As I showed above, once you can capture the type variable the continuation is applied at, you can instantiate all the other continuations at the same type
17:09:17 <hseg> MarcelineVQ: why?
17:10:21 <hseg> (note that forall a -> a can typecase on a, which means [forall a -> a] contains more terms than just replicate n undefined)
17:11:17 <nshepperd2> the algorithm for type checking something like '1 + 2' is something like "instantiate the types of 1, 2 and (+) with new type variables replacing the top level foralls, unify them according to the typing rules for function application, then generalise the result"
17:11:31 <hseg> right
17:11:55 <hseg> i'm definitely arguing that you need dependent types to write this instance, btw
17:12:26 <nshepperd2> and in the unification it's just not allowed to have type_variable ~ something_with_foralls
17:13:30 <hseg> right in non-dependent language. afaict, in dependent types you should be able to unify that as long as the type is visible
17:13:40 <hseg> would need to read eisenberg's thesis to be sure
17:13:51 <hseg> but it intuitively makes sense to me
17:14:22 <nshepperd2> type variables are permitted to be things like Int, Char, (), Maybe, f c
17:14:36 <nshepperd2> foralled things are in a whole separate universe
17:14:50 <hseg> nshepperd2: yes. does this continue to hold with deptypes?
17:15:04 <nshepperd2> no idea
17:15:24 <nshepperd2> i don't see why dependent types would help though, isn't that just letting types refer to terms
17:15:33 <hseg> bc at least from the liftA2 example, that's what i seem to need
17:16:15 <hseg> it helps bc then i can write k (\(a :: Type) -> f @a (x @a) (y @a))
17:16:49 <hseg> i.e. unify the type indeces manually
17:17:22 <nshepperd2> well i think the conceptual problem is what (a :: Type) even means
17:17:33 <nshepperd2> like what values a is allowed to assume
17:17:49 <hseg> Int, Bool, Char, Maybe Foo, etc
17:18:02 <hseg> anything of kind *
17:18:17 <nshepperd2> yeah, but how about (forall a. Maybe a)
17:18:24 <nshepperd2> in haskell, that wouldn't be allowed
17:18:44 <hseg> hm. again, this bumps up eisenberg's thesis on my reading list
17:20:29 <nshepperd2> this feature is called impredicativity in ghc
17:20:48 <nshepperd2> https://en.wikipedia.org/wiki/Lambda_cube doesn't seem to associate it with dependent typing
17:21:51 <hseg> right. which is why i was saying that what you'd probably want is predicative polymorphism, ie forall->
17:22:04 <hseg> that is, where you explicitly need to pass a type
17:22:54 * hackage hOpenPGP 2.9.1 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.9.1 (ClintAdams)
17:24:00 <MarcelineVQ> that's it's quantitative/linear, something like QTT can allow you typecase because you can explicity say what type (variables) are relevant in terms, or not
17:24:50 <MarcelineVQ> e.g. idris2 allows this because "There is an important consequence of being able to distinguish between relevant and irrelevant type arguments, which is that a function is only parametric in a if a has multiplicity 0." https://www.type-driven.org.uk/edwinb/linearity-and-erasure-in-idris-2.html
17:26:36 <MarcelineVQ> though if I'm wrong to extend \(a :: Type) -> ...   to the notion of typecasing then I apologize for misleasing
17:27:17 <hseg> hey, it's ok, i'm also talking about stuff i only e-understand
17:27:27 <hseg> s/e-/epsilon-/
17:44:05 <hseg> nshepperd2: eisenberg's section 4.4.4 seems to concur with you, with an open research question to permitting my intuition
17:44:45 <hseg> (This is in "Dependent Types in Haskell: Theory and Practice")
17:46:05 <hseg> specifically, he points out that impredicativity is essentially challenging since it is impossible to know where to infer invisible arguments (i.e. arguments that need are passed by unification instead of by application)
17:47:52 <hseg> (e.g. in trying to unify forall a. [a] with [forall a. a], ghc would need to infer all the a's in the internal forall a. a)
17:50:54 * hackage hOpenPGP 2.9.2 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.9.2 (ClintAdams)
17:52:07 <hseg> but this is seemingly only relevant for invisible binders -- if we have to instantiate all the type variables there shouldn't be a problem
17:53:34 <hseg> which means that if this conjencture holds true, my type g (forall a -> p a -> q a) -> g p -> g q should be instantiable at g ~ forall f -> forall r. ((forall a -> f a -> r) -> r)
17:53:50 <hseg> ... that should be forall r. forall f -> 
18:45:54 * hackage lens-core 0.1.0.3 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-core-0.1.0.3 (MatthewFarkasDyck)
18:47:59 <fragamus> hello I am having trouble getting stack to find the HPDF library
19:32:23 <ezzieyguywuf> on this page, http://learnyouahaskell.com/for-a-few-monads-more#writer, under the "Using do notation with writer", I'm confused about `return (a*b)`. Both `a` and `b` are instances (is this the correct term?) of the Writer data type. How does haskell know how to `(*)` two `Writer`?
19:33:28 <ezzieyguywuf> uhp, wait, actually I guess `a` and `b` are each `([String], Int)`, e?
19:33:59 <ezzieyguywuf> the question still stands though
19:38:08 <Axman6> ezzieyguywuf: without looking at that URL, I would guess that a and b are both Ints
19:39:19 <ezzieyguywuf> Axman6: they can't be, as the `return` is the last line of a function with the signature `multWithLog :: Writer [String] Int`
19:39:44 <ezzieyguywuf> oh wait...
19:39:51 <Axman6> ezzieyguywuf: remember that a) a <- ma; ... is syntax sugar for ma >>= \a -> ..., and the types of thw values are ma :: Writer [String] a and a :: a
19:40:04 <ezzieyguywuf> `return` will "wrap" the result of `(a*b)` in a `Writer`, right?
19:41:18 <Axman6> well yes, that is what return does: return :: Monad m => a -> m a, here m ~ Writer [String]
19:41:46 <monochrom> logNumber 3 :: Writer [String] Int  therefore a :: Int
19:43:18 <ezzieyguywuf> hm...so I guess what I need to understand is how the `return (a*b)` provides the "logging" functions that are being discussed in this section
19:43:36 <ezzieyguywuf> I can probably re-read the section though to get that, I have a cursory understandnig of what's going on
19:43:58 <ezzieyguywuf> monochrom: the fact that `a :: Int` definitely helps here, so thanks
19:44:02 <ezzieyguywuf> Axman6: thanks to you too.
19:44:04 <monochrom> Re-read first, now that you have new information.
19:44:05 <Axman6> return does (and must not) do any logging, the only thing it can do is pass along the current [String] and provide the given a 
19:44:18 <jackdk> what is up with all those MatthewFarkasDyck packages? lens-core appears to be a straight copy of lens including the giant UML diagram and Edward A. Kmett copyright
19:54:06 <fireflower> hello!
19:55:28 <fireflower> ?
19:55:48 <Axman6> Hello
19:58:59 <fireflower> Hi! This is my first time here. Are there any hackage admins here? I'm trying to get package uploaders permission. I'm not sure how long it usually takes; I sent the email requesting permissions earlier today. 
20:03:00 <jackdk> fireflower: I have pinged someone outside this channel who may be able to help.
20:03:08 <jackdk> (I'm not a hackage admin)
20:04:04 <fireflower> Tyvm!
20:24:07 <fireflower> Thanks, it is resolved c:
20:37:54 * hackage pprecord 0.1.0.0 - A library for pretty printing Records  https://hackage.haskell.org/package/pprecord-0.1.0.0 (tdct)
20:58:26 <iqubic> Spending 10 minutes in #Python has really shown me why static type systems, like the one Haskell has, is so much more plesent to work with.
20:59:44 <iqubic> s/is/are/
22:22:54 * hackage network-byte-order 0.1.3.0 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.3.0 (KazuYamamoto)
22:50:58 <fog> Ok I have managed to get this done on the idea of a reified Scope; 
22:50:58 <fog> https://gist.github.com/fog-hs/2af156168d1c71f4545373f1dd048692
22:59:48 <fog> how do i get it to throw an error if the types are not in "Scope" ?
23:06:58 <olligobber> fog, why doesn't your gist have syntax highlighting?
23:08:39 * det0x[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/FZBaYSkkLOvEyuIBhsDZlzFh >
23:08:47 <det0x[m]> can anyone help me with this one not compiling?
23:09:06 <det0x[m]> getting variosu `Ambiguous type variable ‘a0’ arising from a use of ‘fromIntegral’`
23:10:15 * det0x[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/iXNvyevQFEYvxxMHeNgkFvHD >
23:10:18 <det0x[m]> doesn't work either
23:11:01 <olligobber> det0x[m], attaching type signatures to your functions would help
23:11:30 <olligobber> so like add `isSquare :: Double -> Bool'
23:11:52 <olligobber> because right now the compiler can't figure out what type you want to use, Float, Double, Rational, Real, etc.
23:13:03 <det0x[m]> that helped with tons of errors
23:13:12 <det0x[m]> ` No instance for (Integral Double) arising from a use of ‘round’` remains
23:13:45 * det0x[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/nFAhwGHbNTkctjDvvXtXREZw >
23:13:49 <det0x[m]> with this being the whole code
23:14:19 <det0x[m]> im still having difficulties with interpreting the errors and applying fixes
23:15:31 <det0x[m]>  * im still having difficulties with interpreting the errors and applying fixes, replacing Double with Integer doesn't help either :(
23:15:42 <olligobber> might be a good idea to check the types of these things in the interpreter
23:15:46 <olligobber> :t round
23:15:47 <lambdabot> (RealFrac a, Integral b) => a -> b
23:15:51 <olligobber> :t fromIntegral
23:15:53 <lambdabot> (Integral a, Num b) => a -> b
23:16:13 <det0x[m]> so round takes a RealFrac input
23:16:17 <olligobber> so round takes a fractional thing (like Double) and turns it into an integral thing (like Integer)
23:16:23 <det0x[m]> and fromIntegral outputs Num
23:16:41 <det0x[m]> so to solve this i would need to convert Num to RealFrac
23:16:44 <olligobber> yeah, and Num includes Double, Integer, etc
23:17:11 <olligobber> Num and RealFrac are classes of types, both of which include Double
23:17:42 <det0x[m]> so i'd be okay if I casted fromIntegral to a Double right?
23:17:56 <olligobber> :t fromIntegral :: Integer -> Double
23:17:58 <lambdabot> Integer -> Double
23:18:04 <olligobber> interpreter says that works
23:18:42 <olligobber> however, right now the input to your functions is already a Double
23:19:43 <det0x[m]> why doesn't round accept fromIntegral's output?
23:19:59 <det0x[m]> i still have a weak understanding of typeclasses
23:21:32 <olligobber> ah, the problem is, you are doing round (...) == x
23:21:48 <olligobber> the type on the left is Integral, since it's the output of round
23:21:59 <det0x[m]> and x is Double
23:22:03 <olligobber> yes
23:22:12 <olligobber> so the compiler is complaining about DOuble not being Integral
23:23:43 <det0x[m]> so I can probably do fromIntegral x on rhs?
23:24:07 <olligobber> that would fix that problem
23:24:18 <olligobber> I imagine another will come up once it's fixed though
23:24:45 <olligobber> wait
23:24:52 <det0x[m]> basic arithmetics are so hard 
23:25:05 <olligobber> no, it won't, the rhs is a Double, so fromInteger won't fix it
23:26:12 <olligobber> so what you're trying to do is raise to (1/n), then round, then raise to n, and see if the result is the same as the input...
23:26:35 <olligobber> it would probably be best if things stay the same type everywhere, probably Double
23:27:13 <det0x[m]> I'm trying to see if a number's Nth root is a whole number for square, cubic and quintic roots
23:27:41 <olligobber> maybe you could write a function to check if some Double is a whole number then?
23:30:59 * det0x[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/eYOsygtAlUInFrPzOOLkMRwk >
23:31:54 <olligobber> I guess that works, but it wouldn't be particularly fast
23:32:23 <olligobber> maybe you could find a better one if you had a round function that went Double -> Double
23:33:03 <det0x[m]> ghci is taking forever, ill try compiling and if thats slow too ill try a different solution
23:33:33 <det0x[m]> these arithmetic errors are giving me a headache though
23:35:53 * hackage pandoc-plantuml-diagrams 0.1.0.4 - Render and insert PlantUML diagrams with Pandoc  https://hackage.haskell.org/package/pandoc-plantuml-diagrams-0.1.0.4 (thriqon)
23:40:58 * det0x[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/xYUnGdABDKQeTwHYunmfXVFm >
23:41:07 <det0x[m]> i'm going to sleep now
23:41:30 <olligobber> det0x[m], maybe look at div and mod functions
23:42:20 <[exa]> div/mod better than sleep for sure!
23:42:23 <det0x[m]> i'll try tomorrow 😜
