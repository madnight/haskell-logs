00:00:33 <zeta_0> MarcelineVQ: it's ok, thanks for helping me, i'll try to get a hold of one of the contributors of ghcide later on to help me
00:01:08 <zeta_0> MarcelineVQ: how come you don't use nix, it's a great tool?
00:02:03 <MarcelineVQ> I've installed it like 5 times and I afterwards I can't think of a thing to actually use it for, it sits there for awhile, and gets uninstalled
00:04:22 <zeta_0> MarcelineVQ: i installed nixos right from the start, so i was forced to learn some nix right away
00:05:04 <dminuoso> Nixos has an odd threshold you need to cross before you feel comfortable with it.
00:05:35 <dminuoso> It's sort of like Haskell in that sense, becaue most of your casual linux experience does not translate well into fixing the usual problems.
00:09:00 <zeta_0> agreed
00:21:43 <aplainzetakind> `cabal v2-haddock someexecutable --haddock-internal` still skips non-exported names. Isn't that the purpose of -internal?
00:22:31 <zeta_0> mpickering: hello again, could you resend me the link on how to set NIX_GHC_LIBDIR, i can't seem to find it?
00:27:04 <zeta_0> mpickering: nevermind i found it, sorry to bother you, i was looking in the wrong github repo
00:37:05 <zeta_0> i forgot, what is the command to see the ghc library directory location?
00:46:24 * hackage servant-ekg 0.3.1 - Helpers for using ekg with servant  https://hackage.haskell.org/package/servant-ekg-0.3.1 (phadej)
00:48:54 * hackage servant-quickcheck 0.0.8.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.8.0 (phadej)
01:06:24 <pdxleif> This recommends making the getter in your HasEnv typeclass for ReaderT a Lens - https://github.com/commercialhaskell/rio#monads
01:07:02 <pdxleif> I'm not using RIO, though, and balking at making my little thing depend on the kmettware stack just for that.
01:07:34 <pdxleif> Also, I was wondering about data-has. I don't see that used really, but it seems like a neat idea.
01:07:55 <merijn> pdxleif: There are more minimal lens implementations, like microlens (but not sure if that supports HasFoo style things)
01:08:43 <merijn> pdxleif: Also, note that FPComplete are...opinionated on how they think you should write Haskell and their opinion is *not* universal consensus :)
01:19:17 <pdxleif> merijn: Thanks! I'll check out microlens.
01:20:39 <cocreature> in the end, youâ€™ll end up depending on 5 different smaller lens implementations + lens itself :)
01:23:22 <pdxleif> :/
01:23:51 <jackdk> pdxleif: microlens-th gives you makeClassy, which generates the HasFoo classes: http://hackage.haskell.org/package/microlens-th-0.4.3.2/docs/Lens-Micro-TH.html#v:makeClassy . If you are writing an application and your deps have not already pulled in lens, then consider microlens-platform, which imports all the useful deps and re-exports for convenience
01:24:22 <pdxleif> Oh nice, thanks!
01:24:55 <Solonarv> I personally find that lens or at least most-of-the-kmettverse often ends up in my transitive closure anyway, so it's not much hardship to depend on it directly
01:25:02 <Taneb> (I'm of the opinion that if you're depending on microlens-platform, and none of your dependencies are depending on microlens, you might as well depend on lens instead)
01:25:15 <Solonarv> and microlens et al have one big missing piece: no prisms
01:25:43 <jackdk> I think microlens' rule is "copy things from lens that can be implemented atop base", and we don't have Profunctor/Choice in base yet
01:25:57 <justsomeguy> In the untyped lambda calculus, is something like \sz.s(s(z)) the same as \sz.ssz ?
01:26:01 <Solonarv> exactly my point
01:26:05 <mpickering> Doesn't mean it's a good rule
01:26:27 <jackdk> Prisms are awesome, 0-1 target Traversals don't quite cut it, so I'm personally happy to depend on lens unless I'm writing libraries
01:26:29 <Solonarv> justsomeguy: no, ssz is (s (s)) (z)
01:26:43 <pdxleif> I thinking to hide some of the C pointer stuff you have to pass around in these libudev bindings in a Reader monad - but it's a small lib and I didn't want to balloon its deps. https://hackage.haskell.org/package/udev-0.1.0.0/docs/System-UDev-Context.html#v:newUDev
01:27:06 <merijn> pdxleif: You could just do it manually?
01:27:29 <pdxleif> The lib's used for my "sense accelerometer and rotate screen" tool, which is quite small, and also taffybar, which doesn't already depend on lens afaik.
01:27:32 <Solonarv> data-has has a virtually nonexistent dependency footprint, so it might be fine to use
01:27:45 <justsomeguy> Solonarv: Thanks, that helps a lot!
01:28:30 <merijn> For small single things, just newtyping and writing something by hand is an underrated solution, imo >.>
01:31:40 <jackdk> is there a convenient helper to expect the _first_ argument of a function to come from a MonadReader?
01:33:17 <jackdk> magic :: (a -> m b) -> ReaderT a m b but also magic :: (a -> b -> m c) -> b -> ReaderT a m c using the printf-typeclass-variadic-function trick?
01:33:18 <jackdk> (and yeah, one of the reasons lens took off is that it is possible to write lenses without depending on a lens lib if you're so inclined)
01:34:41 <Solonarv> hm. that seems to me like it should be possible.
01:35:54 * hackage mmsyn7ukr 0.8.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.8.0.0 (OleksandrZhabenko)
01:36:32 <jackdk> possibly overkill for a system lib like udev
01:44:54 * hackage hedgehog-corpus 0.2.0 - hedgehog-corpus  https://hackage.haskell.org/package/hedgehog-corpus-0.2.0 (lambda_foo)
01:54:39 <aplainzetakind> How can I get cabal v2-haddock to not ignore non-exported names of other-modules in my executable component? I'm using --haddock-internal, which sounds like it should do it, but it doesn't.
02:46:54 * hackage failable 1.2.3.0 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.2.3.0 (erick)
02:50:54 * hackage servant-dhall 0.3 - Servant Dhall content-type  https://hackage.haskell.org/package/servant-dhall-0.3 (phadej)
03:22:53 * hackage mmsyn7ukr 0.9.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.0.0 (OleksandrZhabenko)
03:35:54 * hackage mmsyn7ukr 0.9.1.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.1.0 (OleksandrZhabenko)
03:40:24 * hackage mmsyn7h 0.6.0.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.6.0.0 (OleksandrZhabenko)
03:41:24 * hackage failable 1.2.4.0 - A 'Failable' error monad class to unify failure across monads that can fail  https://hackage.haskell.org/package/failable-1.2.4.0 (erick)
03:51:24 * hackage mmsyn7ukr 0.9.1.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.1.1 (OleksandrZhabenko)
04:49:24 * hackage hhwloc 0.2.0 - Bindings to https://www.open-mpi.org/projects/hwloc  https://hackage.haskell.org/package/hhwloc-0.2.0 (dtaskoff)
04:51:15 <merijn> ooh...neat hwloc bindings :>
04:52:25 <merijn> Does anyone know if anyone has written like cabal integration/wrapper for shake?
04:57:15 <maerwald> what would that wrapper do?
05:03:38 <merijn> maerwald: Either unconditionally call cabal-install based on a .cabal file or (better) track the relevant haskell files and only call cabal when they are updated
05:04:51 <merijn> maerwald: Right now I have a Makefile based build system that calls cabal, but it's kinda shitty and since I already use tons of Haskell I figured i might as well see if replacing it with Shake ends up nicer
05:25:33 <ezzieyguywuf> fog: I was thinking more like "draw a square. now extrude it to make a cube."
05:25:42 <ezzieyguywuf> ðŸ˜‚ðŸ˜‚ðŸ¤£
05:26:30 <maerwald> merijn: I don't see how it's useful to have two systems track the same thing. I just make everything cabal a phony.
05:28:34 <kuribas> cool, ghcide compiled from the first time
05:28:41 <kuribas> no such luck with hie
05:30:12 <maerwald> kuribas: well, it's digital-asset backed, isn't it? So there is hope the development workflow is more professional
05:30:32 <merijn> Also, ghcide does much less than HIE
05:30:39 <maerwald> indeed
05:31:05 <maerwald> but half of the feature in HIE don't work :P
05:31:38 <kuribas> yuck hie forces you to use stack
05:31:50 <maerwald> kuribas: not anymore
05:31:54 <maerwald> I patched that
05:32:38 <kuribas> maerwald: cool.  How do I get it to work?
05:33:01 <maerwald> cabal v2-run ./install.hs --project-file install/shake.project hie-8.6.5
05:33:16 <maerwald> and then pray it builds
05:33:25 <maerwald> (also, don't enable tests, these still need stack)
05:33:48 <maerwald> but it should build, the hackage state is now frozen
05:37:30 <kuribas> cabal: Unrecognised target './install.sh'.
05:38:31 <kuribas> ah, ./cabal-hie-install hie-8.4.4 works
05:38:54 * hackage futhark 0.14.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.14.1 (TroelsHenriksen)
05:39:37 <fendor> kuribas, install.hs not install.sh
05:39:50 <kuribas> ah :)
05:42:21 <kuribas> if I use stack, can I say I'm a full stack developer?
05:43:15 <phadej> if you don't use any other tool
05:44:23 <fendor> there is docker integration for stack. does that count?
05:45:34 <maerwald> there is even nix integration
05:45:44 <maerwald> so now you're devops too
05:47:34 <fendor> is there a safe index function for Text?
06:04:54 * hackage servant-to-elm 0.4.0.0 - Automatically generate Elm clients for Servant APIs  https://hackage.haskell.org/package/servant-to-elm-0.4.0.0 (OlleFredriksson)
06:07:02 <merijn> fendor: "\n -> T.uncons . T.drop n" ?
06:09:13 <fendor> merijn, I would have preferred something in the lib text itself
06:17:03 <ezzieyguywuf> Solonarv: I've been playing around with the Point type we discussed yesterday. one potential issue/shortcoming I see is that there's nothing stopping a user from creating a `P (Just 'a')`, which in this context is nonsensical
06:17:27 <daydaynatation> when a data type derive automatically from Monad, what is the definition of >>= ?
06:17:55 <Solonarv> ezzieyguywuf: sure, but they can't *do* anything incorrect with that
06:18:05 <Solonarv> it's not really a problem
06:18:08 <ezzieyguywuf> hrm
06:18:16 <ezzieyguywuf> is this a common idiom/approach in Haskell?
06:18:27 <ezzieyguywuf> let the user create non-sensical things but don't give them a chance to do anything with them?
06:18:44 <ezzieyguywuf> (due to the `offset (Num a) =>` Num a constraint, right?)
06:18:57 <Solonarv> daydaynatation: Monad can't be derived normally, you need GeneraizedNewtypeDeriving for that
06:19:23 <Solonarv> daydaynatation: which gives you the answer: GND always delegates to the implementation for the wrapped type
06:19:51 <Solonarv> ezzieyguywuf: well, I wouldn't really call this an "approach" at all, but it is fairly common
06:19:55 <ezzieyguywuf> is it possible to place a type constraint on `Point` itself, i.e. `(Num a) => newtype Point v a = P (v a)`
06:20:12 <boxscape> another example would be Data.Set which has Ord constraints on almost all functions
06:20:19 <Solonarv> yes... with a language extension that was removed/deprecated
06:20:22 <Solonarv> and for good reason!
06:20:41 <ezzieyguywuf> Solonarv: I'm interested to know more about why it was removed/deprecated. is there perhaps a wiki or blog you can point me to?
06:20:55 <boxscape> But you could do `newtype Point v a = Num a => P (v a)`, i.e. place it on the constructor rather than on the type
06:20:56 <daydaynatation> Solonarv: Ok, so it's the implementation of the wrapped type
06:21:02 <Solonarv> daydaynatation: yes
06:21:14 <boxscape> or actually
06:21:21 <boxscape> probably not with newtype?
06:21:28 <boxscape> % newtype Point v a = Num a => P (v a)
06:21:28 <yahb> boxscape: ; <interactive>:57:21: error:; * A newtype constructor cannot have a context in its type; P :: forall (v :: * -> *) a. Num a => v a -> Point v a; * In the definition of data constructor `P'; In the newtype declaration for `Point'
06:21:33 <boxscape> yeah
06:21:43 <Solonarv> daydaynatation: btw, you can pass -ddump-deriv to GHC and it will print out the generated code for 'deriving' instances
06:21:46 <daydaynatation> Solonarv: that's why people use newtype to wrap only one inner data type to derive from
06:22:00 <Solonarv> yes, because it lets them re-use instances
06:22:36 <ezzieyguywuf> boxscape: ðŸ˜®there's an idea. I could do that with `data` right?
06:22:45 <boxscape> yes
06:22:51 <boxscape> ezzieyguywuf about the deprecation: https://github.com/monoidal/ghc-proposals/blob/no-datatype-contexts/proposals/0000-remove-datatypecontexts.rst
06:23:01 <Solonarv> ezzieyguywuf: see also this SO question: https://stackoverflow.com/a/7438716
06:23:12 <ezzieyguywuf> but I seem to vaguely recall reading somewhere that placing restrictions in certain places inadvertently makes other type signatures more bulky
06:23:20 <boxscape> I guess that proposal actually doesn't say much about the reason
06:23:25 <boxscape> just says "it doesn't give you anything"
06:23:31 <Solonarv> yup, that's what the SO answer I linked explains
06:24:23 <kuribas> maerwald: it's miracle, it actually compiled!
06:25:24 * hackage mmsyn7h 0.6.0.1 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.6.0.1 (OleksandrZhabenko)
06:32:32 <dminuoso> I have the following issue. I want to constructively generate a graph that has circles. But the way the data is presented, I have Text labels that identify nodes that might not even be there yet. My initial thought was to add these references as extra Text fields, leaving the connected nodes with *bottom*
06:32:55 <dminuoso> Once the tree is finished, I'd go through the entire tree and update those bottoms with actual node references.
06:33:02 <ezzieyguywuf> Solonarv: thanks for the links
06:35:12 <dminuoso> Is that a reasonable method to create circles? Generate bottoms and then update them later?
06:36:13 <ezzieyguywuf> what is the "bottom" of a circle?
06:36:21 <ezzieyguywuf> (or maybe I just completely misunderstand the problem statement)
06:36:29 <dminuoso> ezzieyguywuf: Bottom is the name of a special value in Haskell.
06:37:02 <dminuoso> ezzieyguywuf: We associate failure to evaluate an expression (say because it throws an exception with error, or it loops infinitely) with bottom.
06:37:15 <dminuoso> This lets us talk about what `let f = f in ...` even means. :)
06:38:23 <dminuoso> (The name for it has to do with denotational semantics of Haskell)
06:38:23 * hackage http-directory 0.1.6 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.6 (JensPetersen)
06:38:26 <ezzieyguywuf> ðŸ˜®guess I still have learnin' to do. I though that's what `Maybe` and `Either` were for...
06:38:39 <dminuoso> ezzieyguywuf: It's not about communicating error.
06:38:58 <dminuoso> ezzieyguywuf: Because we have unlimited recursion, you can create code that never terminates.
06:39:13 <dminuoso> Say `f x = ...` is a function that, for some reason, never terminates.
06:39:20 <dminuoso> But what is the value of `f 1` in such a case?
06:39:28 <ezzieyguywuf> .... `Bottom`?
06:40:01 <dminuoso> ezzieyguywuf: Right, we just call the value of that computation bottom.
06:40:26 <dminuoso> Because Haskell is turing complete, we cannot avoid this. :)
06:40:31 <ezzieyguywuf> sounds a bit like infiniti
06:40:37 <ezzieyguywuf> lol, "Principle of Explosion" great name
06:41:41 <dminuoso> ezzieyguywuf: Another common name for bottom is `undefined` :)
06:41:59 <dminuoso> bottom is really interesting for its type signature
06:42:03 <ezzieyguywuf> ðŸ˜±bottom is much less scary
06:42:03 <dminuoso> undefined :: forall a. a
06:42:03 <ezzieyguywuf> lol
06:42:19 <dminuoso> This means, bottom is a member of every type.
06:42:29 <dminuoso> Equivalently, every type has bottom as an inhabitant.
06:42:33 <ezzieyguywuf> `class Any => Bottom where`, i saw that
06:42:41 <dminuoso> ezzieyguywuf: That's something different, even!
06:42:45 <dminuoso> Don't worry about that.
06:42:59 <ezzieyguywuf> ðŸ˜®zounds!
06:43:00 <ezzieyguywuf> lol
06:43:15 <ezzieyguywuf> "Don't worry about that", as an engineer, i've never been able to do this :-P
06:43:41 <ezzieyguywuf> however, as a working professional, i've learned to do this a lot. Well, moreso "trust but verify: let someone else worry about that for now"
06:43:56 <lortabac> dminuoso: if you represent your graph as an adjacency list, you don't need bottom
06:44:03 <lortabac> unless I misunderstood the problem
06:44:07 <dminuoso> ezzieyguywuf: Other notations for bottom that are common include âŠ¥ or ascii stylied _|_
06:45:00 <dminuoso> lortabac: Mmm, could work as well. Thing is, there are very few cycles and it's not of homogenous nodes.
06:45:34 <dminuoso> Which is why Im thinking about trying to just generate the graph and then fixup a few lose bottoms.
06:45:42 <dminuoso> Alternatively I could try and use `fix` and insert forward references (and promise to not evalutae them until the graph is finished)
06:46:05 <dminuoso> Maybe that's the cleaner way.
06:47:15 <dminuoso> (With forward references I mean some `remoteNode = locate label fixGraph` where `graph = fix \fixGraph -> ...`
06:47:38 <lortabac> it's more functional, but probably much harder than an adjacency list Ã  la Data.Graph
06:47:54 * hackage mmsyn7ukr 0.9.2.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.2.0 (OleksandrZhabenko)
06:48:54 <dminuoso> lortabac: The harder thing is that I have to guarantee these forward references will work out. I cant ahead of time proof that the other node will actually exist (and they might not!)
06:48:58 <ezzieyguywuf> Solonarv: to sort of close the loop on our conversation here - technically speaking, there's nothing stopping someone from importing my module and writing a function `someFunc :: Point v a -> Bool`, in which case they _could_ do something with a `P (Just 'a')`
06:49:26 <dminuoso> *prove
06:49:38 <Solonarv> yes, and? that's not breaking your library at all, why does it matter?
06:49:41 <lortabac> dminuoso: I tried a similar technique (tying the knot) to implement a doubly-linked list, I remember it was not easy
06:50:03 <ezzieyguywuf> because that's not what I said a `Point` means!
06:50:10 <ezzieyguywuf> lol, you're right it does not mess with my library
06:50:53 <dminuoso> Oh hold on, Im in a monad... 
06:50:53 <dminuoso> MonadFix to the rescue!
06:57:54 * hackage mmsyn7ukr 0.9.3.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.3.0 (OleksandrZhabenko)
07:04:50 <maerwald> kuribas: not a miracle, it's this magic line https://github.com/haskell/haskell-ide-engine/blob/master/cabal.project#L19 ;P
07:04:53 * hackage mmsyn7h 0.6.1.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.6.1.0 (OleksandrZhabenko)
07:05:09 <ezzieyguywuf> hm, it's hard for me to "let it go" regarding `Point` being constructable as a `Point Maybe a`, however perhaps it's best to 'truck on forward' and see if it presents itself as a problem...
07:05:22 <dminuoso> So I finally understood how MonadFix/fix are easily learned.
07:06:05 <dminuoso> Getting to the point of "Wouldn't it be nice if you had..." on your own, and then realize oh that's just the type of mfix.
07:06:37 <ezzieyguywuf> dminuoso: probably the best way to learn most advanced/intermediate concepts in programming
07:06:48 <ezzieyguywuf> (or....in life?)
07:07:38 <kuribas> maerwald: I see there is hope for haskell tooling :)
07:08:28 <dminuoso> lortabac: Okay spending even 10 minutes on MonadFix makes me appreciate that bottom+fixup is easier.
07:08:40 <maerwald> kuribas: ideally, there should be a cabal feature, which does: 1. pin the current compiler, 2. pin the hackage index state, 3. create a freeze file.
07:08:43 <lortabac> dminuoso: :)
07:08:53 <dminuoso> The error handling alone is way easier. Wish adjacency lists could work, but I have so many different types in this.
07:09:02 <dminuoso> (It's a graph in a moral sense)
07:09:12 <maerwald> there are some issues about that, but currently you have to do all of that yourself and especially 2. is awkward, since you cannot easily get the *current* index timestamp programmatically
07:09:33 <maerwald> cabal update outputs the *previous* index timestamp
07:09:43 <kuribas> maerwald: so tooling will break once you go to another compiler version?
07:10:07 <maerwald> well, you can have different project files for different compiler versions 
07:10:12 <maerwald> and pin different states etc
07:10:35 <maerwald> like stack, but with more flexibility
07:13:07 <merijn> maerwald: Eh, doesn't cabal v2-configure do what you want? :p
07:13:19 <maerwald> merijn: no, it doesn't pin hackage index
07:13:35 <maerwald> and configure creates cabal.project.local
07:13:51 <maerwald> all of this should be in a freeze file (and ideally one with a ghc version suffix)
07:14:27 <AWizzArd> I have a puzzle for the Haskell experts: https://pastecode.xyz/view/de82e214
07:14:36 <maerwald> https://github.com/haskell/cabal/pull/4071
07:14:39 <AWizzArd> Why does the first version not compile?
07:14:52 <lembot> hello, is it ok to ask simple haskell questions on this channel or should I go to another one?
07:15:01 <maerwald> hvr provided a PR for that already, in his wisdom
07:15:08 <AWizzArd> lembot: super fine if you do it here
07:15:21 <lembot> Thanks
07:15:27 <merijn> AWizzArd: 'f' gets monomorphised, I think
07:15:35 <merijn> AWizzArd: Or the other way around, I suppose
07:15:36 <maerwald> and also https://github.com/haskell/cabal/issues/3832
07:15:53 <AWizzArd> lembot: there is also a #Haskell-Beginners
07:16:02 <AWizzArd> merijn: but why and how?
07:16:04 <merijn> AWizzArd: Type inference for RankNTypes isn't possible, so it can't infer the most general type for 'f'
07:16:17 <AWizzArd> Hmm. So it is the RankN extension.
07:16:35 <AWizzArd> Okay, I didnâ€™t know that.
07:16:45 <lembot> I'm having trouble finding information online about this. In a function, can I use a where clause that is in scope of every branch of the pattern match?
07:17:05 <AWizzArd> merijn: I could get it to work by specifying concrete sigs with version 1, si?
07:17:12 <lembot> When I put a 'where' at the botton it just in scope of the last branch
07:17:20 <merijn> lembot: No, but you can trivially solve that by moving the pattern into a "case-of" on the right hand side
07:18:16 <merijn> So instead of "foo Cons1 = ...; foo Cons2 = ...;  where" do "foo x = case x of ...;  where"
07:18:42 <AWizzArd> Is there a way to write a function   ExceptT err IO a -> IO a   without throwing an exception and without getting a warning about not matching the Left case?
07:18:48 <lembot> merijn: oh, thanks :D
07:19:09 <maerwald> silly question: if ghc only inlines fully applied functions, wouldn't it make sense to always write: f = \x y z -> ... instead of f x y z = ?
07:22:57 <merijn> Always inlining isn't necessarily good, so...
07:23:22 <merijn> maerwald: Also renders you unable to access `x`, `y`, and `z` inside where
07:23:47 <maerwald> when is it good? :>
07:25:06 <merijn> maerwald: When it can expose further optimisations/rewrite rules
07:25:39 <merijn> maerwald: inlining itself doesn't really affect performance. The reason to want it is so that it can expose further simplifications/optimisations/rewrite rules
07:26:12 <maerwald> so basically I have to understand all ghc optimisations to make a decision here?
07:27:13 <merijn> maerwald: More realistically: You profile to find hotspots, you look at hotspot, consider why that's slow, then think whether inlining could/would help
07:27:41 <merijn> maerwald: Trying to, a priori, manually predict what should be inlined or not is a doomed effort
07:27:43 <maerwald> profiling often doesn't show the actual hotspot :(
07:27:57 <merijn> maerwald: How so?
07:28:07 <maerwald> Because the call stack depth is arbitrary
07:28:22 <maerwald> because it's simulated, afair
07:28:35 <dmj`> merijn: hey
07:29:00 <merijn> maerwald: I don't know why that wouldn't show the hotspot, it would just show it at a less fine-grained resolution
07:29:07 <maerwald> yep
07:29:13 <dmj`> AWizzArd: you'd need a default value
07:30:33 <dmj`> AWizzArd: \def -> fmap (fromMaybe def) <$> runExceptT (yourThing :: ExceptT err IO a) 
07:31:41 <AWizzArd> dmj`: good idea, thanks!
07:31:49 <dmj`> merijn: want to hear my idea
07:33:24 <merijn> dmj`: Depends on the idea ;)
07:33:37 <dmj`> merijn: it's a good one :)
07:34:53 <ddellacosta> is there a way to create a generalized IsLabel instance for Text such that I don't have to create one everytime I create a new label #foo or #bar, etc.? I found an example but it looks like it used to depend on a proxy argument for fromLabel that no longer exists
07:35:18 <dmj`> merijn: I think it would be possible to reify an entire REST API, CRUD ops, API docs, using only the generic metadata of a record
07:35:28 <dmj`> and SQLite
07:35:45 <dmj`> could use any db, but SQLite is the best DB
07:35:49 <ezzieyguywuf> does cabal distinguish between a "project" and a "module". For example, with the cmake build system, I define a top-level cmake configuration file, and each sub-directory contains its own sub-configuration file to specify what to do with the files in that directory. Is cabal similar?
07:35:49 <merijn> I like the SQLite part, I've never had to do the rest :p
07:35:55 <merijn> SQLite is clearly the best, yes
07:36:10 <merijn> ezzieyguywuf: There's no modules in cabal
07:36:21 <merijn> ezzieyguywuf: There's *packages* and projects
07:36:47 <merijn> ezzieyguywuf: Projects exist to solve the problem of "I develop 4 packages that depend on each other, so during development I need to depend on unreleased versions"
07:37:06 <ezzieyguywuf> merijn: let's say I have a folder, `MyCoolPackage` and it contains only `Main.hs` and some sub-folders, `MyCoolModule`, `MyOtherCoolModule`
07:37:14 <ezzieyguywuf> how would I organize that in cabal?
07:37:22 <lortabac> ddellacosta: you can replace the proxy argument with a type application
07:37:32 <dmj`> merijn: GHC.Generics is the best too though
07:37:35 <ezzieyguywuf> merijn: hrm, I see, I probably don't need to worry about projects (yet) then...
07:37:48 <ddellacosta> lortabac: that's what I was looking for. Thanks!
07:38:16 <merijn> ezzieyguywuf: Something like this: https://github.com/merijn/line-diff/blob/master/line-diff.cabal
07:38:39 <merijn> ezzieyguywuf: With "MyCoolModule" and "MyOtherCoolModule" going on line 33
07:39:50 <geekosaur> ezzieyguywuf, I think what you are calling a module, we call a (sub)project
07:40:03 <geekosaur> "module" doesn't have a meaning in C, it does in Haskell
07:40:29 <heatsink> ezzieguywulf: Cabal packages can have components with different build information.  For example, a package could have a library and a test suite that are built with different options
07:40:32 <merijn> ezzieyguywuf: See also: https://cabal.readthedocs.io/en/latest/concepts-and-development.html
07:41:05 <ezzieyguywuf> merijn: thanks for both links
07:41:16 <ezzieyguywuf> is `-O2 -Wall` pretty typical compile options?
07:41:53 <maerwald> -O2 rarely has any real impact
07:42:13 <geekosaur> -O2 slows compilation down without producing much in the way of additional optimization most of the time
07:42:14 <maerwald> using the llvm code generator has more chances to have an impact than -O2
07:42:33 <merijn> ezzieyguywuf: -Wall should *always* be on. -O2 should probably be -O1 instead
07:46:54 * hackage http-directory 0.1.7 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.7 (JensPetersen)
08:13:43 <Gurkenglas> https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf doesn't work with Ctrl-F. Suggestions?
08:14:43 <yushyin> what?
08:14:57 <MarcelineVQ> Gurkenglas: A better e-reader my man
08:15:19 <MarcelineVQ> open it in its own tab
08:16:05 <Gurkenglas> Oh, I see. I thought it's the pdf's fault, but it was github's/Chrome's.
08:16:15 <Gurkenglas> thx
08:17:54 * hackage libarchive 2.2.0.2 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.0.2 (vmchale)
08:23:54 * hackage bz2 0.1.0.0 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-0.1.0.0 (vmchale)
08:33:24 * hackage bz2 0.1.0.1 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-0.1.0.1 (vmchale)
08:54:57 <Finianb1> Is there a better way of "inverting" map than `pam funl x = map ($ x) funl`
08:55:19 <Finianb1> Where pam maps functions over a single argument
08:57:32 <Gurkenglas> I don't think there's a better way of writing pam, if that's what you're asking. I wouldn't give it a name if you only use it once.
08:58:24 <buc> ciao
08:58:28 <buc> !list
08:58:28 <monochrom> buc: http://okmij.org/ftp
08:58:39 <Finianb1> Ah 
09:01:43 <Finianb1> I Hoogled it and the only other suggestion was `pam funl x = funl <*> (return x)`
09:02:56 <lukebfox[m]> so you have a list of functions and an argument,  and you want to return a list of the results of applying each function to that argument
09:03:40 <lukebfox[m]> sequenceA funl x
09:04:47 <Gurkenglas> Finianb1, Control.Lens implements it for you I suppose https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Operators.html#v:-63--63-
09:06:41 <lukebfox[m]> Prelude contains sequenceA I think
09:06:48 <Finianb1> Oh nice 
09:06:50 <Finianb1> Thank you! 
09:07:33 <Finianb1> Oh wow I forgot how many lens operators there are 
09:08:26 <lukebfox[m]> wow that operator (<<%@=)
09:08:30 <Finianb1> https://hackage.haskell.org/package/plumbers-0.0.4/docs/Control-Plumbers.html
09:08:45 <ezzieyguywuf> hm, 'These modules are needed for compilation but not listed in your .cabal file's other-modules'. But it is: it is listed under "exposed-modules"
09:09:00 <ezzieyguywuf> could it be b/c it's in a subdir 'src'? though I did specify "hs-source-dirs: src"
09:20:32 <ezzieyguywuf> hm nvm, I think it is because my project name and my module name were the same
09:20:48 <ezzieyguywuf> well, I'm probably not using the right terminology there
09:25:32 <sicklork1n> What's options do I have if I wanna compare two version strings (strverscmp)?
09:25:54 <int-e> ezzieyguywuf: if you have a question it would help to have the actual error message and probably .cabal file
09:28:51 <ezzieyguywuf> int-e: duly noted. I think I have it worked out though
09:29:16 <zebrag> In haskell-doc.el there is a set of rules, like: "do { stmts [;] }  stmts -> exp [; stmts] | pat <- exp ; stmts | let decllist ; stmts". If we put aside the "counting of the spaces from the left margin to the first character of the line", do you think that list of 15 rules could be nearly exhaustive? (It seems so simple) https://github.com/haskell/haskell-mode/blob/master/haskell-doc.el
09:29:36 <ezzieyguywuf> If I want to change the behaviour of Show for MyType, is it typical to manually describe `instance Show MyType`, or to define a `prettyPrint :: MyType...` function?
09:29:45 <geekosaur> the latter
09:30:20 <geekosaur> chnging Show is not recommended, it should (a) match the Read instance (b) ideally be a usable Haskell expression, to simplify both nested use and debugging
09:30:27 <geekosaur> Show is not a prettyprinter
09:32:29 <zebrag> Well, it sure is not exhaustive, all rules are associated with keyworkds and consequently then is no entry for 'decl'
09:34:24 <zebrag> But the description of the rules is very nice, and I'd like to have one looking as nice but more complete
09:36:06 <ezzieyguywuf> after cabal init, is it possible to have cabal suggest changes to my .cabal file based on changes in my code? i.e. specifically I'm asking about updating build-depends
09:36:54 <jle`> ezzieyguywuf: what sort of changes to build-depends?
09:37:24 <jle`> one thing that might make sense is being able to automatically update exposed/exported modules
09:37:52 <jle`> oh ah, you mean the times that ghc complains about a hidden package, maybe?
09:38:01 <ezzieyguywuf> jle`: if I add a new `import` to a source file, then my package (module?) now depends on an additional...module
09:41:37 <ezzieyguywuf> I was perusing the documenting of prettyprint, and it mentioned that String is only intended to be used for Hello World programs - is this highly subjective or mostly agreed upon? Should I err on the side of using Data.Text instead?
09:42:07 <geekosaur> small proograms, String is probably okay. anything more involved would really want Text
09:42:35 <geekosaur> that said, I generally use String because I'm not doing anything particularly involved or large (or time-critical for that matter)
09:43:02 <ezzieyguywuf> hm, ok then
09:43:41 <lukebfox[m]> what are the benefits of Text? or the drawbacks of String, if it is that way round?
09:44:45 <lukebfox[m]> I heard a similar thing today but as of yet havent heard the accompanying explanation
09:47:58 <jle`> ezzieyguywuf: yeah that's an uncontroversial statement
09:48:05 <jle`> re: string
09:48:21 <jle`> lukebfox[m]: well string doesn't really make sense as a text data type
09:48:28 <ezzieyguywuf> in ghci, I can easily specify unicode characters at my prompt, and the interpreter seems to handle them fine, but when printed it used the hex code rather than the glyph itself. is there a way to change this behaviour?
09:48:46 <ezzieyguywuf> jle`: ...because it's just a list of 'Char'
09:48:51 <jle`> lukebfox[m]: it's a linked list of character codepoints?  that makes no sense, really
09:49:03 <jle`> ezzieyguywuf: yeah, it's a Char with a pointer to the next Char with a pointer to the next Char ...
09:49:09 <jle`> it doesn't really make sense as a text storage type
09:49:32 <jle`> ezzieyguywuf: using 'print' or 'show' on the string gives you the "literal" you would use to get that string in a file
09:49:41 <jle`> ezzieyguywuf: if you want to just display the string you can use putStrLn
09:50:01 <jle`> just typing in a string is like "inspecting" it
09:50:57 <jle`> ezzieyguywuf: [Char] is a nice toy concept for strings and has easy pattern matching, but it doesn't really make sense an actual text data type
09:51:47 <maerwald> Eq instance is also lying
09:52:27 <jle`> i usually just use String when I want to do some sort of character-based stream processing
09:52:34 <maerwald> would need text-icu package to haver proper comparison
09:53:24 <jle`> ezzieyguywuf: ah, regarding your imports thing, yeah it would sometimes make sense, but a lot of times just having the module name isn't enough to know what package it is from
09:53:25 <ezzieyguywuf> I get it, great thanks for the help!
09:53:43 <ezzieyguywuf> jle`: ok then, so I just manually update my cabal file
09:54:02 <jle`> ezzieyguywuf: the exception is when the module comes from a package that is already imported by another module, but is hidden because it hasn't been explicitly declared as a dependency
09:54:14 <jle`> in that case it might make sense to suggest that package since it already knows about it
09:54:20 <jle`> but i don't think this feature exists yet
09:54:24 <lukebfox[m]> interesting stuff thanks for the explanation I will take a look at Text some time
09:57:36 <ezzieyguywuf> If I want to write a prettyPrint method for `data MyData = D Int Int Int`, is `prettyPrint MyData a b c = "prefix " ++ show a ++ "," ++ show b....` "safe"? I seem to recall someone mentioning in here that "show" wouldn't necessarily always show what I expect it to
09:57:48 <ezzieyguywuf> maybe `putStr a...` etc?
09:58:12 <ezzieyguywuf> well, no that would print to the screen
09:59:50 <hyperisco> ezzieyguywuf, safe, or unsafe, how?
10:00:18 <hyperisco> It isn't going to segfault, if that is what you mean
10:01:22 <ezzieyguywuf> nah, I mean that can I rely on `show` just convert a given type to a [Char] representation of said type
10:01:59 <ezzieyguywuf> really, MyData would be `data MyData a = D a a a`, and prettyPrint `prettyPrint :: MyData a -> Text`
10:02:54 <hyperisco> Usually yes, though for infinite data structures results may vary
10:02:57 <ezzieyguywuf> hm, maybe I want to do `prettyPrint (PrintfArg a) => MyData a -> Text`
10:04:36 <hyperisco> If you're asking whether show will give you a pretty output the answer in the general case is no.
10:05:24 * hackage aur 6.3.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-6.3.0 (fosskers)
10:07:45 <hyperisco> ezzieyguywuf, perhaps  prettyPrint :: (a -> Text) -> MyData a -> Text
10:07:46 <solonarv> however, in a case like 'data MyData = D Int Int Int' you already know exactly what type 'show' will be called at
10:08:02 <solonarv> it's always 'Int', and that instance *does* do what you want
10:08:08 <hyperisco> ezzieyguywuf, or perhaps  prettyPrint :: (a -> DOC) -> MyData a -> DOC
10:08:30 <solonarv> yes, if you want pretty-printing you probably want some sort of "document"
10:08:32 <hyperisco> https://hackage.haskell.org/package/pretty guess it is Doc not DOC
10:08:43 <solonarv> rather than just a plain old Text/String/whatever
10:09:16 <solonarv> because then you end up splitting and re-joining lines all the time as an ad-hoc way to handle indentation
10:11:28 <ezzieyguywuf> This seems to provide a Doc type as well https://hackage.haskell.org/package/prettyprinter
10:11:51 <solonarv> yeah there are a bunch of prettyprinting libraries around
10:12:05 <solonarv> I have to admit I'm not too familiar with them, rarely have cause to use one
10:12:39 <hyperisco> I think prettyprinter was moreso the one I was thinking
10:12:40 <ezzieyguywuf> I'll start simple though - I'll make `prettyPrint :: MyData a -> Text` so that I can see it while playing in ghci and then upgrade to a Doc type as the need arises
10:12:45 <hyperisco> whichever has the paper with it
10:12:53 * hackage archive-sig 0.2.3.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-0.2.3.0 (vmchale)
10:13:05 <ezzieyguywuf> although it'd be nice to do colors in the term, which I believe a Doc type allows for
10:13:54 * hackage archive-tar 0.2.2.1 - Common interface using the tar package  https://hackage.haskell.org/package/archive-tar-0.2.2.1 (vmchale)
10:14:54 * hackage archive-libarchive 0.2.2.1 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-0.2.2.1 (vmchale)
10:19:19 <solonarv> a Doc type doesn't *inherently* allow that, it depends on the library
10:19:57 <solonarv> and you could just embed \ESCblahblah; codes in a Text value as well, but the outupt will be garbled if the terminal doesn't support them
10:22:08 <fendor> @hoogle SomeException
10:22:09 <lambdabot> Control.Exception data SomeException
10:22:09 <lambdabot> Control.Exception SomeException :: e -> SomeException
10:22:09 <lambdabot> Control.Exception.Base data SomeException
10:22:33 <fendor> Can I tell hoogle to give me either the second or the first line?
10:22:56 <fendor> both seem redundant
10:23:03 <fendor> *seems
10:27:24 * hackage cheapskate 0.1.1.2 - Experimental markdown processor.  https://hackage.haskell.org/package/cheapskate-0.1.1.2 (JohnMacFarlane)
10:27:58 <hyperisco> fendor, you can use the website
11:03:37 <Athas> I don't think I understand how cabal.project.freeze works.  It seems that I have pinned 'any.base ==4.13.0.0', but also 'any.directory ==1.3.3.2'.  Yet, that version of directory has a base<4.13 constraint.
11:03:42 <Athas> Things build, but I don't understand why.
11:05:48 <fendor> hyperisco, I want to use the results programmatically
11:06:56 <maerwald> fendor: there is an '-i' flag
11:07:47 <maerwald> I think with that, the first line is always the definition, the second the location/module and the rest description
11:08:08 <maerwald> but it picks the first result always
11:09:05 <fendor> maerwald, thanks, that looks useful! I dont like that it only shows the first result, though
11:10:36 <maerwald> fendor: then you need to use the haskell API
11:11:15 <fendor> maerwald, I have that available! Just hoped the simple api is enough already
11:11:43 <ezzieyguywuf> solonarv: true, but the Renderer that uses the Doc would allow it
11:14:40 <maerwald> Athas: maybe you set allow-newer somewhere?
11:15:39 <Athas> maerwald: not that I can find.  But strangely, the Stackage snapshots with base 4.13 also have a version of directory that seems to claim it cannot handle it!
11:15:43 <Athas> Maybe I've just gone mad.
11:17:11 <maerwald> Athas: https://www.stackage.org/nightly-2020-01-24/package/directory-1.3.4.0
11:17:16 <maerwald> that's 1.3.4.0
11:18:07 <Athas> I'm talking about 1.3.3.2.
11:18:19 <maerwald> yes, but the stackage snapshot doesn't use that
11:20:11 <Athas> nightly-2020-01-03 does.
11:20:52 <aveltras> is there a way to specify ghc-options: -Wall for all local packages in cabal.project.local ?
11:22:48 <gentauro> Athas: what I noticed with `stack` (at least on NixOS) is that some packages from the stable repo are updated
11:23:53 <gentauro> that's why I tend to close my nixos+stack like this -> https://gitlab.com/spisemisu/bornhack-demo-2019/blob/master/stack.yaml#L1-18
11:24:05 <gentauro> that seems to be consistent (reproducible binary files)
11:24:15 <gentauro> but I'm not sure that's what you are aiming for right?
11:25:22 <Athas> I'm just trying to figure out wtf is going on, because I thought I understood it, just to realise that I don't.
11:26:31 <gentauro> I will suggest that you use `debian` cos `nixos` does a lot of strange things under the hood :|
11:26:36 <gentauro> (at least for your build server)
11:27:24 <Athas> This has nothing to do with the operating system.
11:27:26 <maerwald> aveltras: yes, exactly how you did it
11:28:41 <maerwald> Athas: well, stack doesn't use cabal-install, so it's possible it just ignores all version bounds
11:29:23 <gentauro> 20:27 < Athas> This has nothing to do with the operating system.
11:29:31 <maerwald> wrt cabal, I cannot install directory-1.3.3.2 with ghc-8.8.2
11:29:35 <gentauro> if you use `stack` on `nixos` it actually does
11:29:47 <Athas> maerwald: but cabal v2-install also works fine with that freeze file, which I really don't get.  Maybe freeze files supercede bounds?
11:29:59 <Athas> gentauro: I don't.
11:30:08 <gentauro> Athas: roger that
11:30:10 <maerwald> Athas: maybe, but how did it come up with an install plan in the first place? When you create a freeze file, it resolves
11:30:49 <maerwald> Athas: hey wait... I can install directory-1.3.3.2 with ghc-8.8.1, but not 8.8.2
11:30:50 <Athas> This freeze file was generated with 'cabal freeze' in a directory where I normally use stack.  Is there any way for the stack build plan to be picked up?  It sounds unlikely...
11:31:01 <Athas> Oooh, I used 8.8.1 to generate the freeze file!
11:31:01 <aveltras> maerwald: do you put this in cabal.project.local ? it says "Unrecognized field 'ghc-options' on line 1"
11:31:23 <maerwald> cabal v2-install -w ghc-8.8.1 --dry-run directory-1.3.3.2 -- doesn't work
11:31:26 <maerwald> err, does work
11:31:28 <maerwald> 8.8.2 not
11:31:29 <gentauro> Athas: stack tends to create a .cabal file
11:31:41 <gentauro> shouldn't that be enough?
11:31:54 <Athas> gentauro: I don't think that is pertinent here.
11:31:59 <Athas> maerwald: strange.  GHC bug?
11:32:12 <gentauro> "Is there any way for the stack build plan to be picked up?"
11:32:29 <Athas> gentauro: a .cabal file is not a build plan.
11:32:50 <maerwald> 8.8.1 and 8.8.2 should have the same base version
11:32:51 <Athas> maerwald: I don't see anything in the release 8.8.2 notes that would matter.
11:33:12 <Athas> I think a ghost is at work.
11:33:26 <Finianb1> Does anyone have any opinions on *Category Theory for Programmers* vs. *Category Theory in Context* as a category theory textbook? 
11:33:44 <fendor> Can I tell hoogle that I am only searching for types? 
11:35:55 <maerwald> Athas: ah, I know
11:36:34 <maerwald> Athas: https://gitlab.haskell.org/ghc/packages/directory/commit/59883e953d488492487dcda266901080347bbf1e
11:36:50 <maerwald> this was never released to hackage, but ghc bundles the libraries
11:37:13 <Athas> Ah, thanks.
11:37:20 <maerwald> so ghc-8.8.1 ships with directory-1.3.3.2 already
11:37:21 <Athas> That is horrifying.
11:37:23 <maerwald> :D
11:37:52 <Athas> I will go to my grave being confused, upset, and disappointed at the whole notion of a compiler having "wired-in" libraries.
11:38:13 <Athas> Or wait, is that even what is happening here?  Could I just pick a newer directory?
11:38:39 <Athas> And do I just get directory-1.3.3.2 with invisible special GHC patches for convenience?
11:39:15 <maerwald> I think you can install newer directory, unless you have some ghc package in your build plan
11:39:27 <geekosaur> there's procedure to get stuff upstreamed before release. but it slipped a bit here
11:40:12 <maerwald> cabal install -w ghc-8.8.1 --dry-run directory-1.3.5.0 doctest -- this will fail
11:40:16 <maerwald> but without doctest, it will work
11:41:15 <gentauro> 20:32 < Athas> gentauro: a .cabal file is not a build plan.
11:41:19 <maerwald> also, why are you bothering with 8.8.1?
11:41:29 <gentauro> so what is `stacks` build plan then?
11:41:40 <merijn> gentauro: The stackage snapshot
11:41:59 <Athas> maerwald: no deep reason.  I normally use a stack snapshot that uses 8.8.1, and I generated the freeze file on a macOS machine that I hadn't updated to 8.8.2.
11:42:22 <merijn> gentauro: Stackage snapshots are fixed sets of packages and the build plan is "use these exact versions of each package you need"
11:42:32 <gentauro> merijn: got it
11:42:44 <maerwald> curated, well tested, carefully picked set
11:43:21 <merijn> gentauro: As opposed to cabal-install which takes all of hackage and tries to dynamically compute a version for each package that satisfies each (transitive) constraint
11:44:02 <merijn> maerwald: That part is irrelevant for how stack works, though. Stack itself could work with completely ad hoc untested snapshots too. It'd just be kinda pointless ;)
11:44:17 <gentauro> `stack.yaml` (build plan) while `package.yaml` just what cabal is right?
11:44:36 <merijn> gentauro: stack.yaml + cabal file 
11:44:42 <maerwald> merijn: that would be shocking
11:44:44 <Athas> Stackage snapshots are so carefully picked that some of the packages are quite a bit out of date.
11:44:53 <Athas> When I ditch stack one day, it'll be because of that.
11:44:57 <merijn> gentauro: The cabal file specifies which packages you need, the stackage snapshot specifies the version it will use
11:45:07 <maerwald> Athas: what's holding you back?
11:45:30 <gentauro> merijn: but I don't have any .cabal file (they are generated by `stack`) I'm guessing from the `package.yaml` file right?
11:45:33 <Athas> maerwald: partially PTSD from the old cabal days, but mostly that stack really does work for my users (in particular, it gets the right GHC for them).
11:45:47 <merijn> gentauro: package.yaml isn't actually part of stack, it's part of hpack (and stack will automatically run hpack to get a cabal file out of it)
11:46:04 <gentauro> merijn: good to know
11:46:14 <merijn> gentauro: stack can also work directly with cabal files, completely skipping package.yaml
11:46:24 <maerwald> Athas: Is this about an application/executable?
11:46:28 <Athas> maerwald: yes.
11:46:40 <Athas> And most of my users are not Haskell programmers.
11:46:40 <maerwald> Athas: then freezing hackage index state will be interesting for you
11:46:50 <merijn> gentauro: And I would personally recommend that, since this makes it easier for cabal-install users to contribute things to your repos :)
11:47:07 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cfg-field-index-state
11:47:07 <gentauro> merijn: so you are saying I should just write `.cabal` files instead of `package.yaml`?
11:47:18 <Athas> maerwald: ah, as an alternative to freeze files?
11:47:27 <maerwald> it can be used in conjunction with or alone
11:47:38 <Athas> What's the purpose of using it in conjunction?  Avoiding new revisions?
11:47:39 <maerwald> the benefit of using it without freeze file is that base version etc are not locked
11:47:46 <merijn> gentauro: Yes, of course my opinion is biased, since I use cabal-install and get annoyed when I have to go through hoops to build someone's stack project :p
11:47:54 <maerwald> so if you can verify that this hackage state works with all ghc versions... then it's better
11:48:00 <gentauro> merijn: xD
11:48:05 <maerwald> you don't need freeze files for every ghc version then
11:48:10 <Athas> I don't want to support more than a single GHC version anyway.
11:48:12 <glguy> The hoops are often due to neglected package bounds and not just package.yaml
11:48:21 <merijn> glguy: Of course
11:48:22 <gentauro> merijn: I just used `package.yaml` files cos they are described in the `stack` documentation
11:48:27 <maerwald> Athas: another thing is... hackage revision updates can break your build plan, even with a freeze file
11:48:59 <merijn> gentauro: Yeah, I wish stack would put less emphasis on them, that'd make it easier to have repos that are directly usable by everyone :)
11:49:11 <maerwald> Athas: https://github.com/ekmett/contravariant/issues/61
11:49:13 <Athas> maerwald: right, but that's rare, isn't it?  Anyway, freezing the index-state sounds like a good solution, but for tragic reasons, I like the aspect of 'cabal.project.freeze' files that they can also work as 'cabal.config' files for v1-build.
11:49:24 * hackage text-offset 0.1.0.0 - Library for converting between line/column and byte offset.  https://hackage.haskell.org/package/text-offset-0.1.0.0 (robinp)
11:49:29 <maerwald> Athas: well, happened in "production" lol, so I got quite angry
11:49:35 <gentauro> merijn: I will actually give it a look
11:50:08 <gentauro> maybe it will be better (there are some limitations with regard of `package.yaml` with regard to using GHC manually)
11:50:39 <gentauro> to many `with regards` in my last sentence
11:51:38 <maerwald> Athas: then again, freeze files ensure that funny stuff in users cabal config (or on the command line) don't affect the build plan
11:52:25 <Athas> maerwald: so is there any best practice yet?  Lots of knobs to turn it seems.
11:52:50 <maerwald> with-compiler and index-state in cabal.project and a freeze file
11:52:56 <maerwald> that should lock things up
11:53:53 <maerwald> then tell your mac users to use ghcup :P
11:55:16 <merijn> maerwald: I just use the official bindist
11:55:27 <merijn> maerwald: Much simpler on mac than on linux, since there's only one :p
11:55:39 <maerwald> yeah, it's annoying
11:55:56 <maerwald> all this fragile distro detection code
11:58:10 <gentauro> merijn: hmmm
11:58:11 <gentauro> -- This file has been generated from package.yaml by hpack version 0.31.2.
11:58:11 <gentauro> --
11:58:12 <gentauro> -- see: https://github.com/sol/hpack
11:58:18 <gentauro> that repo doesn't even work anymore
11:58:26 <gentauro> I'm guessing I will write .cabal from now on
12:00:29 <merijn> See also the stack/cabal disambiguation thing I wrote: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07 :)
12:01:54 <Athas> Alright, cabal people: is there a way to make v2-build/install perform *all* of its modifications in some designated directory (e.g. CWD) instead of in subdirectories of $HOME?
12:02:02 <Athas> My motivation here is for writing Homebrew formulae.
12:02:18 <Athas> They currently use v1-build, and there's some really nasty scaffolding to avoid polluting $HOME/.cabal and such.
12:02:19 <merijn> Athas: You mean move the store location?
12:02:28 <Athas> merijn: I don't know, you tell me.
12:02:41 <Athas> I want to completely ignore and leave untouched anything outside a fresh, new, pristine environment.
12:02:52 <Athas> Don't read ~/.cabal/config either, for example.
12:03:10 <gentauro> merijn: this -> "package.yaml does not support all CABAL features and requires all your potential users to install extra tooling."
12:03:18 <gentauro> I had to be "creative" sometimes 
12:03:24 <merijn> Athas: I assume you mean you want to automate a workflow that does this? (i.e. requiring a bunch of options is fine)
12:03:30 <gentauro> so def going for `stack` + `.cabal`
12:04:03 <merijn> Athas: because afaik there are flags to control where cabal looks for config files and I think even the store
12:04:26 <Athas> merijn: yes, flags are fine, as long as it doesn't turn into whack-a-mole with new cabal versions.
12:04:44 <Athas> I don't think I would be able to accept a solution that isn't blessed as The Way to do isolated cabal operations.
12:04:49 <merijn> Athas: I think it should be possible, but I don't know the details of my head
12:05:00 <merijn> Athas: Might wanna poke hvr or phadej in #hackage
12:05:28 <merijn> (Although hvr seems rather busy and thus less responsive lately)
12:07:57 <sclv> just read the command line flags
12:22:23 <maerwald> Athas: btw. you can also use ghcup in a sandbox (e.g. installing ghc into the current directory, then adjust PATH etc. to invoke it from a build script)
12:23:24 <maerwald> not sure if that helps with a homebrew formulae
12:23:30 <Athas> maerwald: my motivation is to make it easy for my users to compile the code themselves.  Multiple commands with multiple options, or my own ad-hoc build scripts, is just going to inrease the odds that something will go wrong.
12:23:54 <Athas> For the Homebrew formulae I'm more tolerant of complexity, since it's just a glorified shell script, and it doesn't run that often or on weird systems.
12:24:08 <maerwald> Yes, it would be easy to create a install.hs which downloads ghcup, installs ghc and cabal into the current directory and then uses those to build, basically like stack
12:24:16 <maerwald> *install.sh
12:24:29 <Athas> Wouldn't work on Windows.
12:24:33 <maerwald> yeah
12:24:52 <Athas> And the advantage over using stack isn't clear to me.
12:24:54 * hackage esqueleto 3.3.1.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.1.1 (parsonsmatt)
12:25:15 <maerwald> Athas: the advantage would be that you don't need to use stack
12:25:16 <Athas> Especially since I wouldn't be using that install.sh myself, so it may break without me noticing.
12:26:34 <maerwald> CI :)
12:26:39 <maerwald> but if you target windows, then yeah
12:27:14 <Athas> CI always runs on the *same* environment.  It's not easy to test whether an install script is robust.
12:27:35 <Athas> That's why I'm fine with outsourcing it to stack, because they have more resources to solve it once and for all.  (Would be fine with outsourcing to ghcup or similar, too.)
12:27:55 <maerwald> Athas: I don't believe stack runs CI on all distros either
12:28:13 <maerwald> So there is no difference there if you're concerned with that
12:28:21 <Athas> No, but their installation script gets a lot more use than mine would.
12:28:24 <Athas> It's much more likely to work.
12:28:40 <maerwald> Athas: your install script would just be invoking ghcup and cabal 
12:28:56 <maerwald> ghcup has extensive CI
12:32:07 <Athas> Does ghcup work on Windows?
12:32:41 <maerwald> no, but there's an alternative called 'ghcups', but I don't see how you would unify over those tools without something like shake
12:32:46 <Athas> Anyway, I also have my issues with 'cabal install' requiring extra options to install in a location that is in PATH by default (and still symlinking rather than copying I think?).
12:33:38 <Athas> While I have my issues with Stackage as a package repository, I haven't had to worry about any of this for years, since I told people to just use 'stack install' to install my code.
12:34:39 <maerwald> yeah, for copying you need to use something like: cp -L $(cabal v2-exec --verbose=0 --dry-run --offline sh -- -c 'command -v binary') dest
12:34:58 <Athas> Won't work on Windows, either!
12:35:04 <maerwald> lol
12:35:32 <merijn> maerwald: What
12:35:42 <merijn> maerwald: Why are you doing something that ungodly complex?
12:35:50 <solonarv> actually it can copy, too
12:35:58 <solonarv> you just have to instruct it to do so
12:36:00 <merijn> maerwald: There's literally a flag to copy the binaries
12:36:00 <maerwald> merijn: did they add copy-bins?
12:36:03 <Athas> Well, some day.  For my own uses, cabal is about as good as stack now.  So now I just use stack for the end-user-UX!
12:36:09 <merijn> maerwald: Yes, since way before 3.0
12:36:13 <maerwald> huh?
12:36:36 <Athas> You need something like this: cabal install --installdir=$HOME/.local/bin --install-method=copy --overwrite-policy=always
12:36:48 <Athas> I think that gives me the same as 'stack install'.
12:37:03 <merijn> The overwrite-policy flag is optional, of course, depending on whether you wanna clobber existing files
12:37:04 <maerwald> merijn: it's since 3.0
12:37:22 <maerwald> I think
12:37:31 <merijn> maerwald: I usually run HEAD, it was added very shortly after the first 2.4 release
12:37:45 <maerwald> back when I needed that, it didn't work
12:38:17 <solonarv> I recall having to run HEAD for that reason
12:39:35 <merijn> maerwald: Being able to do that was pretty much mandatory before making v2-build the default
12:56:08 <maerwald> https://git.io/JvqUP this should work
13:03:11 <ezzieyguywuf> I'm confused about what is wrong on line 25: https://repl.it/@WolfgangSanyer/GrowlingVeneratedMatter. The error is very informative, I just don't understand why it is wrong
13:03:28 <ezzieyguywuf> I've tried a few different things here, including `getX (V2' x _)`
13:03:58 <ezzieyguywuf> er, `getX V2' x _`
13:05:34 <geekosaur> because getX :: a -> b does not mean you can choose b to be a, it means the caller / user can choose b to be whatever *they* want
13:05:45 <geekosaur> so you can't simply pass back an a there
13:06:46 <ezzieyguywuf> but in `instance (Num a) => Vector (V2 a)`, when I sub in `V2 a` into the signature for `getX`, I should get `getX :: V2 a -> b`, in other words "take a V2 a and return a b"
13:06:57 <ezzieyguywuf> well, I say "should" and mean "this is what I thought"
13:07:58 <geekosaur> somehow I think my point didn't get across. you are using an a as a b, with no knowledge of what the *caller* chose as b. it is not up to the implementation of getx to choose some appropriate b.
13:09:05 <ezzieyguywuf> hm
13:09:21 <geekosaur> the type signature is a contract. the contract says "hey you calling getX, you can choose any V2 a and any b and I will give you a b". you can't satisfy that contract, because there is no way to know what b is.
13:10:11 <ezzieyguywuf> I think `class Vector a b where getX :: a b -> b` is closer to what I want
13:10:13 <geekosaur> and for the implementation you wrote, the type signature would need to be getX :: a -> a.
13:11:23 <geekosaur> it might be, although I think I'd say v instead of a to clarify its intent.
13:13:28 <ezzieyguywuf> "too many parameters for class Vector"
13:13:45 <ezzieyguywuf> this is seeming like perhaps non-idiomatic haskell
13:21:45 <ezzieyguywuf> hrm, "Fundeps are not standard Haskell 98. (Nor are multi-parameter type classes, for that matter.) They are, however, supported at least in GHC and Hugs and will almost certainly end up in Haskell'"
13:21:55 <iqubic> ezzieyguywuf: It can work, but you'll need to enable MultiParam type class.
13:22:05 <ezzieyguywuf> but I'm wondering if I'm getting in over my head, as I'm still learning with haskell
13:22:15 <ezzieyguywuf> iqubic: yes I see that now
13:23:38 <hyperisco> ezzieyguywuf, you are getting in over your head
13:23:46 <ezzieyguywuf> lol
13:23:56 <hyperisco> what motivates a Vector class?
13:24:23 <ezzieyguywuf> hyperisco: i wanted to write a single `prettyPrint` function
13:24:34 <ezzieyguywuf> rather than `prettyPrintV2`, `prettyPrintV3` etc.
13:24:37 <ezzieyguywuf> maybe that's dumb
13:24:54 <hyperisco> How did you arrive at needing a Vector class to do that, though?
13:25:17 <hyperisco> class PrettyPrint a where prettyPrint :: a -> String
13:25:59 <hyperisco> instance PrettyPrint a => PrettyPrint (MyVector a) where prettyPrint (MyVector x y) = "(" <> prettyPrint x <> "," <> prettyPrint y <> ")"
13:26:07 <ezzieyguywuf> hyperisco: I arrived at the Vector class because I found myself writing a `getXV2`, `getXV3` etc. for each vector type, and it seemed like there was an opportunity to simplify that
13:26:22 <hyperisco> instance PrettyPrint Int where prettyPrint = show
13:26:47 <hyperisco> prettyPrint (MyVector 1 2) = "(1,2)" is true
13:27:59 <hyperisco> ezzieyguywuf, eh maybe but perhaps you'd get more mileage out of using affine algebra or something. Do you really have to deal with components?
13:28:36 <ezzieyguywuf> hyperisco: dunno yet, I'm doing a "bottoms-up" sort of approach. I do know I won't really need higher order vectors
13:28:58 <ezzieyguywuf> just 2 and 3 dimensional. probably could ignore 2-d altogether, but I thought it'd help me as I'm developping to keep things a little more simple
13:29:41 <hyperisco> consider if it is possible to not care about the number of dimensions at all
13:29:52 <ezzieyguywuf> that's deep!
13:30:45 <hyperisco> you don't need it for scaling a vector, or finding the vector between two points, or adding vectors
13:31:00 <hyperisco> or dot product, or cross product
13:31:34 <hyperisco> depends on how you construct your geometry
13:31:44 <ezzieyguywuf> hm, maybe I'm being dense but..how can I add two vectors if I don't know the number of dimensions?
13:31:44 <solonarv> also, why is there a 'Num a' constraint on your 'Vector V2 a' instance? it's not used at all!
13:31:51 <solonarv> you just use (+)
13:31:58 <solonarv> same as you add anything else!
13:32:14 <hyperisco> ezzieyguywuf, it is like asking how you add two numbers if you don't know how many bits they are
13:32:56 * ezzieyguywuf brain explode
13:33:25 <ezzieyguywuf> solonarv: and yes, you're right that the `Num a` constraint is uneeded
13:33:30 <ezzieyguywuf> in my malformed Vector class :-P
13:33:45 <solonarv> obviously something somewhere must know how many bits there are (or how many coordinates your vector has, etc)
13:33:53 <solonarv> but *you* don't have to know, or care about it
13:33:59 <ezzieyguywuf> hm
13:34:16 <ezzieyguywuf> that's pretty abstract
13:34:25 <ezzieyguywuf> ðŸ˜‚
13:35:19 <hyperisco> ezzieyguywuf, like here https://hackage.haskell.org/package/linear-1.20.9/docs/Linear-Affine.html
13:35:33 <hyperisco> The addition of vectors is given by the additive group
13:36:28 <hyperisco> As you can see there, they have instances for V1, V2, V3, V4, and V0, yet the interface remains the same, because they all form affine spaces
13:37:04 <hyperisco> Someone would have to explain a Plucker to me
13:37:07 <ezzieyguywuf> lol, yea I had come across that but stopped reading it because I didn't understand what affine meant :-P
13:37:56 <solonarv> an affine space is a space made of "points" that doesn't have any sort of specially designated origin
13:38:35 <solonarv> if you have two points, you can get a vector which represents the difference between those two points
13:38:50 <solonarv> if you have a point and a vector, you can "add" the vector to the point and get another point
13:39:02 <ezzieyguywuf> hm, but I think abstracting all the way out to the 'affine' level is too much for what I'm doing
13:39:08 <ezzieyguywuf> (and for my poor brain)
13:39:18 <ezzieyguywuf> but I do understand how it _could_ be abstracted out to that level
13:39:28 <solonarv> well, if you are distinguishing between "points" and "vectors" you're already making that distinction
13:40:26 <hyperisco> If you want to work directly with components that's fine. I suggest just having getX_V2 and getX_V3 or however you want to name them though.
13:40:48 <ezzieyguywuf> looks like the linear package defined a class for a handful of different n-spaces, i.e. R1, R2. thus, V2 is an instance of R1 and R2, while V1 is only an instance of R1
13:40:50 <hyperisco> Focus on 2D first perhaps and see how it turns out
13:41:03 <ezzieyguywuf> hyperisco: yea, I'm sort of leaning that way as well
13:41:15 <maerwald> I think this was an old topic, but I forgot what was happening there. POSIX says errno is thread-safe, but how does this play along with green threads?
13:41:56 <hyperisco> My intro to functional programming course had us writing out all those projection functions, so it is a professor-approved approach
13:42:16 <ezzieyguywuf> ah, from linear `ex :: R1 t => E t`, `ey :: R2 t => E t`.
13:44:30 <hyperisco> I am not sure why my professors insisted on us learning through pain
13:45:02 <hyperisco> In C we were not allowed to use arrays, so instead we had to type out a lot of variable declarations.
13:45:26 <earthy> so you learn ot appreciate what you're given? :)
13:46:25 <hyperisco> Stockholm's guide to programming
13:47:34 <hyperisco> First we make you do 5 years of maintaining a legacy dynamically typed code base with no documentation or tests
13:48:29 <Athas> Can't go out-of-bounds without arrays.
13:48:55 <solonarv> if only arrays didn't decay to pointers at the drop of a hat
13:48:56 <maerwald> hyperisco: then modern statically typed languages with microservice architecture? :>
13:49:07 <solonarv> then you could have (some) static bounds checks!
13:49:36 <nshepperd2> i would think that errno is thread local
13:49:46 <maerwald> posix demands it
13:50:08 <hyperisco> Athas, maybe a recursive macro to declare the variables for you then, as well as index and assign. Hm.
13:50:11 <maerwald> but who knows what happens with green threads
13:51:28 <tdammers> in C, you can gain array-like functionality using the file system
13:52:18 <tdammers> use fopen() to allocate an array, fgetc() to read an element, fseek() to say which element you want, etc.
13:53:41 <maerwald> solonarv: you just pass the size along with it (and hope it's correct) :P
13:56:55 <solonarv> maerwald: sad :(
13:57:10 <solonarv> I mean, ideally I would like to have some static checks
13:57:32 <solonarv> so that this is accepted: int snd(int[3] xs) { return xs[1]; }
13:57:56 <solonarv> but this is not: int wrong(int[3] xs) { return xs[3]; }
14:01:16 <maerwald> go has that :P
14:01:50 <ephemient> int xs[3]; return &xs[3]; // is legal
14:02:36 <glguy> If we're talking about C, then int wrong(int xs[3]) { return xs[3]; } is fine because int xs[3] in a function parameter like that actually means: int *xs;
14:02:53 <glguy> The 3 is meaningless in that position
14:03:07 <ephemient> right, but C also allows pointer-to-one-past-end-of-array
14:03:24 <ephemient> you just can't (legally) do much with it
14:03:36 <glguy> You can compare it to other pointers derived from the same allocation
14:03:58 <solonarv> glguy: yes, that is what I meant by "decays to a pointer at the drop of a hat"
14:04:12 <solonarv> if that 3 is meaningless, it should at least be an error instead of being silently discarded!
14:04:58 <glguy> It ends up being useful for some typedef and macro situations
14:05:01 <monochrom> Cementic
14:05:15 <ephemient> maybe for consistency with... int f(int xss[][3]); the 3 is meaningful here
14:06:11 <glguy> Yeah. In Rust syntax that's: pub unsafe extern "C" fn f(mut xss: *mut [libc::c_int; 3]) { }
14:06:27 <solonarv> oh perhaps I meant int wrong(int xs[3]);
14:06:33 <solonarv> is that meaningful?
14:06:37 <glguy> I sometimes use my c2rust.com to see what things in C mean :) https://c2rust.com/
14:06:38 <solonarv> my C syntax is very rusty
14:06:54 <solonarv> or rather it was never pristine in the first place
14:08:29 <glguy> https://imgur.com/a/g4bP4YM
14:09:34 <glguy> Rust beat Haskell to dependent types: int f(int x, int y, int xss[x][y]);
14:09:36 <glguy> errr
14:09:38 <glguy> C beat*
14:10:18 <solonarv> only if they actually do something!
14:10:20 <solonarv> do they?
14:10:27 <glguy> They do something
14:10:33 <solonarv> neat
14:11:04 <glguy> In that case the x doesn't do anything but the y does (similar to ephemient's example earlier)
14:11:22 <ephemient> VLAs are scary though
14:14:12 <glguy> As much as anything that can unrecoverably fail is: function calls, local variable allocation, etc. VLA in arguments aren't necessarily the though
14:14:47 <glguy> And they aren't necessarily stack allocated, either; depends on your compiler
14:18:58 <ephemient> the scary thing about multi-dimensional VLAs to me is that there's no checking for integer overflow
14:19:24 * hackage oeis 0.3.10 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  https://hackage.haskell.org/package/oeis-0.3.10 (niteria)
14:19:31 <ephemient> granted, it's hardly the only way to get UB, but... it just feels too easy to exploit
14:19:37 <glguy> Isn't that the same as any array with element size > 1?
14:25:24 * hackage haxr 3000.11.4 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.4 (BrentYorgey)
14:27:29 <sm[m]> Athas: thanks for your comment on https://github.com/Homebrew/brew/pull/6945
14:31:08 <Athas> sm[m]: well, I have an interest in fixing that mess!
14:31:24 <Athas> It's too much of a gamble whether my formulae will work.
14:35:10 <sm[m]> I tested my formula using stack and the brew's system ghc. It worked, but your point about it being fragile when brew's ghc is updated seems a good one
14:36:15 <sm[m]> it was also really slow. I think if they can allow caching of ~/.stack and stack-managed ghc, this will work great
14:36:44 <sm[m]> do you maintain many brew formulae ?
14:37:47 <Athas> sm[m]: I think it's worse than that.  Your funtion seems to always use the newest lts, which may be too new or too old for many programs.
14:38:10 <Athas> I contributed three Haskell formulae I think (futhark, hpack, komposition).
14:39:03 <Athas> I don't think the build time is a big deal.  That's already hopeless with the current setup, because it's all done from scratch.  Users install from bottles, so only the CI server feels the pain.
14:39:41 <sm[m]> Athas: well don't pay too much attention to that PR commit.. my later-linked paste does it all in the formula, so each formula could control the stackage version
14:40:50 <Athas> That would work, especially if the package itself has a stack.yaml.  I think that would be my recommended solution.
14:41:22 <Athas> But that was against Homebrew policy last time I tried it, so it didn't fly.  Maybe now they're ready to do it!
14:42:12 <sm[m]> maybe related, I was wondering is it better for a formula to install from hackage or stackage, or to clone a tag from github and build from source ? I've seen packages doing both
14:42:29 <Athas> It's best to grab a tarball from GitHub.
14:43:48 <sm[m]> Athas: I'm not sure why the stack build took twice as long as the cabal one. That needs debugging
14:43:53 * hackage opentelemetry 0.0.0.0 -   https://hackage.haskell.org/package/opentelemetry-0.0.0.0 (DmitryIvanov)
14:44:11 <Athas> The Homebrew tooling for cabal is pretty aggressive about seeting a high job count.
14:44:17 <Athas> Stack doesn't parallelise as aggressively by default.
14:44:45 <sm[m]> o really.. interesting
14:44:54 * hackage opentelemetry-lightstep 0.0.0.0 -   https://hackage.haskell.org/package/opentelemetry-lightstep-0.0.0.0 (DmitryIvanov)
14:45:02 <sm[m]> I'll try that next time
14:47:18 <maerwald> Athas: it doesn't? Both stack and cabal have $nproc by default afaik
14:47:22 <maerwald> (which is wrong, but anyway)
14:47:34 <Athas> maerwald: pretty sure stack doesn't do that for the goal package, but only for deps.
14:47:42 <maerwald> Ah
14:49:06 <ddellacosta> when were algebraic/categorial structures first introduced to Haskell? I know that there's a Wadler paper from 1992 on using monads to model computations in Haskell, and I know about the applicative functor paper, but when for example did Functor get added? What about Monoid? Were the rest just outgrowths of using Monad?
14:50:20 <ddellacosta> and if there's a place I can read about this stuff let me know, I just don't know
14:50:24 * hackage cmt 0.6.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.6.0.0 (smallhadroncollider)
15:37:05 <zebrag> In "parser-paper-letter.pdf": (<*>) :: Parser a â†’ Parser (a â†’ b) â†’ Parser b. Has there been a "flip" in the type of (<*>) since 2001?
15:38:17 <ChaiTRex> :t (<*>)
15:38:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:39:15 <zebrag> Yes, looks like the reverse of the type used in the paper
15:39:58 <ChaiTRex> zebrag: Looks like Haskell 98 doesn't have Applicative.
15:40:08 <ChaiTRex> zebrag: Must've been finalized later.
15:40:24 <zebrag> good point
15:55:10 <solonarv> :t (<**>) 
15:55:12 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
15:55:18 <solonarv> ^ there is this, though
15:55:41 <ChaiTRex> ^ zebrag 
15:56:44 <zebrag> tx
16:20:56 <jcowan> lexi-lambda: ping
16:21:13 <lexi-lambda> jcowan: pong?
16:23:37 <jcowan> Ah, good.  I read your 2 posts with great interest, and I wanted to call your attention to a problem about clinical data.  xentrac, who isn't in this channel, kindly wrote up my problem and his OCaml solution at <http://canonical.org/~kragen/sw/dev3/bloodtest.ml>, but neither of us are very happy with it conceptually.  Can you look at it at your convenience and see what the statically typed Right Thing would be?
16:23:54 * hackage zbar 0.1.0.0 - zbar bindings in Haskell  https://hackage.haskell.org/package/zbar-0.1.0.0 (vmchale)
16:25:07 <lexi-lambda> jcowan: I think it really depends on what you intend to do with the data
16:26:22 <jcowan> Sure.  If we are only interested in specific tests, we can ignore the ones we don't care about. But often you don't know what the machine learning part will take an interest in
16:27:23 <jcowan> The original version of this problem came up in trying to construct database tables representing this kind of data, under the constraint that SQL NULL must not be used (it creates too many issues).
16:28:21 <lexi-lambda> If youâ€™re just handing it off to some machine learning algorithm, just store it as a map from property names to values. If you really care that particular keys are mapped to particular types, use a dependent map to declare which keys have which types. Thatâ€™s isomorphic to a giant struct where most of the fields are null, anyway.
16:29:14 <jcowan> Where can i read about dependent maps?
16:29:33 <lexi-lambda> Hereâ€™s a Haskell implementation: https://hackage.haskell.org/package/dependent-map
16:30:05 <lexi-lambda> That library isnâ€™t a toy, either; Iâ€™m running code in production that depends on it.
16:33:56 <jcowan> I see, so the real cleverness is in dependent sums'
16:34:39 <jcowan> which are perilously close to boxes that hold a dynamically typed value.
16:35:12 <lexi-lambda> Not dynamically typed at all! The type associated with each key is known completely statically.
16:35:32 <solonarv> well, assuming you use the right "key" type
16:35:47 <lexi-lambda> Right, but fundamentally you have to declare which keys have which type *somewhere*.
16:35:58 <solonarv> indeed
16:36:08 <lexi-lambda> That said, I donâ€™t know that using the dependent map buys you much over just having a record type with 500 fields. The only difference is in-memory representation. Sure, you save ~490 pointers or whatever. Who cares?
16:36:41 <MarcelineVQ> Should save you some deriving time during compilation at least :>
16:36:56 <jcowan> Depends on how much data you have, I guess.  Aggregated clinical data is vast, though perhaps not by financial-industry standards of vastness.
16:37:20 <lexi-lambda> Sure. If you have a lot of these floating around in memory and thousands of fields, the representation savings could mean something!
16:37:25 <maerwald> them pointers
16:37:37 <lexi-lambda> But this is less about typing discipline and more about choice of data structure.
16:38:12 <jcowan> Indeed, that was the point of the second half of your post.
16:39:57 <lexi-lambda> The major expressiveness advantage of dependent maps over record types is that itâ€™s possibly to synthesize entirely new keys at runtime, so you can theoretically have a dynamic set of keys without giving up on type safety.
16:39:57 <jcowan> "Show me your [algorithms] and conceal your [data structures], and I shall continue to be mystified. Show me your [data structures], and I wonâ€™t usually need your [algorithms]; theyâ€™ll be obvious."  --Fred Brooks, somewhat edited
16:40:25 <maerwald> that's an odd quote
16:41:04 <jcowan> Ah, I didn't realize that.  The problem with Haskell isn't just lack of structural typing (I was a big Algol 68 fan back in the day), it's the attitude that if you know how, you also know why.
16:41:38 <jcowan> maerwald: Actually he said "tables" and "flowcharts", but when I met him he agreed that the change was appropriate.
16:42:10 <jcowan> A terser proverb to the same effect is "smart data, dumb code".
16:42:31 <jcowan> But only natural language can say *why*.
16:43:30 <lexi-lambda> The dependent-map documentation alludes to the capability by referencing the prim-uniq package, which provides this capability. I agree it could be a little clearer, though!
16:43:49 <lexi-lambda> The prim-uniq documentation, for the lazy: https://hackage.haskell.org/package/prim-uniq-0.1.0.1/docs/Data-Unique-Tag.html
16:45:51 <jcowan> Thanks, that's very helpful to an old man whose brain is fried on a Fryday evening.
16:46:44 * hodapp stabs Hakyll in the face.
16:47:37 <nshepperd> seems a bit tragic if you'd have to modify and recompile your kind just because some introduces a new thing to measure the blood concentration of
16:47:54 <nshepperd> your... code*
16:48:10 <maerwald> blood concentration of your code? what?
16:48:22 <nshepperd> modify and recompile your code
16:48:50 <nshepperd> obviously the blood of anyone here is going to be 100% code
16:49:16 * maerwald takes another nanite injection
16:50:29 <evelyn> blood clots are actually tiny lambda expressions, and haemophilia is a severe lack of syntactic sugar
16:50:53 <maerwald> you mean unevaluated thunks?
16:50:58 <hodapp> you guys are weird
16:51:08 <maerwald> my blood veins full of unevaluated thunks :(
16:51:22 <hodapp> mine are full of not enough alcohol for this discussion
16:51:36 <hodapp> nor any other interesting psychoactive substances
16:53:24 <evelyn> if you don't see lambdas most of the time I'm afraid you're simply not in the right mindset
16:53:41 <hodapp> usually when I look at my own blood
16:53:55 <hodapp> my thoughts are more like "AAAAAAH WHY AM I BLEEDING" and "AHHHH I NEED TO STOP THE BLEEDING"
16:54:05 <hodapp> than anything about lambdas
16:54:44 <ChaiTRex> hodapp: You should go to doctor school.
16:55:03 <zeta_0> so i ran cat $(which ghc) and set all of the environment variables, but i am not sure what this means?
16:55:03 <hpc> that's a weird name for a doctor
16:55:05 <zeta_0> exec "/nix/store/hg3na12737n7wws1kndxvs95ai88fgn8-ghc-8.6.5/bin/ghc"  "-B$NIX_GHC_LIBDIR" "${extraFlagsArray[@]}" "$@"
16:55:34 <hodapp> ChaiTRex: meh, I don't feel like making that big of a career change
16:55:40 <zeta_0> do i need to set that `exec`as an environment variable or something?
16:55:50 <solonarv> zeta_0: no, that looks like a shell script
16:56:13 <ChaiTRex> zeta_0: I'd really recommend going that route.
16:56:19 <ChaiTRex> zeta_0: *not
16:56:22 <solonarv> 'exec' is the shell builtin equivalent to exec(3)
16:56:50 <ChaiTRex> zeta_0: That ghc executable is not your friend. Use /usr/bin/ghc or whatever it is on your system.
16:57:33 <zeta_0> so i don't need to do anything with that `exec` then?
16:57:39 <MarcelineVQ> ChaiTRex: his system is NixOS, if that matters, idk if it makes the same structure but mentioning it anyway
16:57:53 <ChaiTRex> MarcelineVQ: No, I've seen that on Ubuntu as well.
16:57:54 <maerwald> I don't even understand the question...
16:58:17 <ChaiTRex> zeta_0: What are you trying to do?
16:58:50 <MarcelineVQ> you'll see that anywhere nix is involved I just don't know if nixos also happens to populate a /usr/bin/ghc
16:59:12 <MarcelineVQ> indeed, where is this exec line even coming from
16:59:18 <ChaiTRex> MarcelineVQ: Well, whatever which ghc gives you.
16:59:29 <hodapp> MarcelineVQ: AFAIK NixOS doesn't (I am using NixOS and GHC now and I see nothing like that)
16:59:34 <ChaiTRex> MarcelineVQ: It's the contents of the file at which ghc.
16:59:38 <maerwald> if you follow the symlinks on nix deep enough, you'll realise there is no binary at the end! 
16:59:44 <MarcelineVQ> oh I see
16:59:58 <MarcelineVQ> Oh right 'cause of $( )
17:00:40 * hodapp throws something at maerwald
17:00:58 * maerwald dodges down a symlink
17:01:01 <zeta_0> in order to get ghcide working correctly with everything enabled i had to set the environment variables: https://hastebin.com/zebufobozu.bash https://hastebin.com/gemobicimo.bash
17:01:52 <maerwald> zeta_0: did you use https://github.com/hercules-ci/ghcide-nix ?
17:02:00 <shapr> mmm, I like ghcide
17:02:05 <zeta_0> ghcide seems to be working correctly now, i am just making sure that i don't need to do anything with that `exec` expression
17:02:31 <shapr> I had to create a hie.yaml and then ghcide worked for my project.
17:02:34 <zeta_0> maerwald: yes i used ghcide-nix
17:03:31 <zeta_0> shapr: have you set the needed environment variables? i set mine in home.nix, the code is in one of the links
17:03:42 <shapr> what env vars?
17:03:56 <shapr> I'm using ghcide with cabal on ubuntu
17:04:37 <solonarv> hm, that sounds promising
17:04:47 <solonarv> I think I'll give ghcide a try as well
17:05:32 <shapr> the only thing I had to create was a hie.yaml specifying ./src for lib:fermatslastmargin and ./ for exe:fermatslastmargin
17:05:50 <maerwald> it breaks less randomly than hie, ime
17:06:25 <shapr> I created this file: https://hastebin.com/hakupuvaga.makefile
17:07:27 <zeta_0> shapr: after i installed some new haskell packages and did a rebuild ghcide was not recognizing some of the modules and was missing functionality so in order to fix the issues i set the environment variables in home.nix: https://hastebin.com/gemobicimo.bash https://hastebin.com/zebufobozu.bash
17:08:10 <shapr> I'm just upgrading everything to ghc 8.8.2 from ghc 8.6 so I think I'll need to rebuild ghcide
17:09:09 <shapr> I like the way ghcide shows popups with the concrete types of calls to mapM_, for example
17:09:49 <zeta_0> solonarv: ghcid and ghcide are great
17:10:35 <zeta_0> and i heard they are going so try and merge a lot of this stuff with haskell-ide-engine soon
17:11:23 <maerwald> hope they don't adopt cabal-helper and all that legacy code
17:11:54 <solonarv> shapr: oh, which editor are you using?
17:11:57 <shapr> emacs
17:12:03 <maerwald> no, which editor :D
17:12:07 <zeta_0> i have been using ghc865 for a while now, when am i going to need to upgrade my ghc version
17:12:44 <MarcelineVQ> whenever you want a new feature you don't have
17:13:30 <zeta_0> maerwald: haskell-ide-engine is going to replace cabal-helper with hie-bios and they are going to be getting rid of ghc-mod, thank goodness, they gave me nightmares, always breaking
17:13:35 <maerwald> there's still a few things that don't build with 8.8, such as cabal-install
17:13:58 <maerwald> and something else I forgot (but was a blocker for me)
17:14:23 <solonarv> I haven't upgraded yet because I don't feel like rebuilding all the packages :>
17:14:26 <MarcelineVQ> ghc-mod would break for the same reason as hie or ghcide but using nix should go a fair ways in alleviating that, iiuc
17:15:32 <zeta_0> MarcelineVQ: agreed, nix solves the dependency hell problem
17:15:47 <MarcelineVQ> Where using nix means enforcing that the edit tooling you're using matchs the compiler tooling you're using
17:16:13 <maerwald> What does nix have to do with ghc-mod or anything else breaking?
17:16:21 <maerwald> It was due to GHC API
17:16:26 <zeta_0> well, i guess i'll stick with ghc865 until the newer ghcVersions are more stable and supported
17:17:28 <MarcelineVQ> maerwald: I would hope that you can set a dependency on ghc version so that when you change that ghc-mod would be rebuilt as well, if that's not the case idk what nix is for hehe
17:17:51 <maerwald> I can't follow
17:18:44 <maerwald> the problem of installing something like ghc-mod for multiple ghc versions is a long solved thing, with or without nix
17:19:02 <maerwald> that's what hie-wrapper is for
17:19:37 <maerwald> cabal-helper, however, is a different story, because it compiles stuff at runtime
17:19:48 <maerwald> in your home dir, somewhere
17:19:55 <maerwald> and sometimes just fails
17:19:56 <zeta_0> does ihaskell still depend on ghc-mod?
17:22:10 <MarcelineVQ> maerwald: Any time I had a ghc-mod issue it was solved by simply building ghc-mod with the same context as my project, e.g.  stack build ghc-mod  would build a ghc-mod specific to the ghc and libraries in the project that was run in. So if that can be automated by whatever sets up the tooling and libraries in the first place it becomes a solved problem. If there's another solution for that now that's good too, I've not used such 
17:22:10 <MarcelineVQ> editor tooling for quite awhile now
17:23:01 <MarcelineVQ> So that's all I meant by nix could help with that since iiuc it's responsible for setting up the project/work environment
17:23:38 <maerwald> MarcelineVQ: that's just a matter of a good build system
17:50:24 <dainichi> :t 6
17:50:26 <lambdabot> Num p => p
17:51:59 <dainichi> > 5
17:52:01 <lambdabot>  5
17:53:32 <dainichi> @pl \xs n -> take n xs
17:53:33 <lambdabot> flip take
18:18:26 <coventry> I installed haskell on ubuntu 18.04 with `sudo apt-get install haskell-platform`, and `ghci` is giving me the error `/usr/lib/ghc/package.conf.d/package.cache: GHC.PackageDb.readPackageDb: inappropriate type (not enough bytes)`. How can I fix this?
18:19:57 <coventry> Also, I am reading "Thinking With Types", and I am stuck on exercises 2.1.3-iii and -iv, i.e. not sure what the kinds are for `Monad` and `MonadTrans`.
18:21:30 <maerwald> coventry: did you run 'cabal update'?
18:21:40 <coventry> maerwald: No, I'll try that now. Thanks.
18:21:49 <solonarv> also, what are the outputs of 'cabal --version' and 'ghc --version' ?
18:22:33 <ChaiTRex> coventry: Isn't the kind for those Constraint?
18:23:23 <ChaiTRex> coventry: Well, almost that.
18:23:25 <coventry> `cabal --version` gives 1.24.0.2, `ghc --version` gives 8.0.2. `ghci` fails in the same way after `cabal update`.
18:24:46 <coventry> ChaiTRex: Sorry, I don't follow.
18:25:17 <solonarv> coventry: oh my. those are pretty old versions.
18:25:18 <maerwald> I wonder if that cabal version is still "working"?
18:25:27 <coventry> ChaiTRex: Oh, I see what you mean, now. Thanks.
18:25:55 <maerwald> coventry: https://launchpad.net/~hvr/+archive/ubuntu/ghc use this ppa for the latest packages
18:26:03 <coventry> maerwald: Thanks.
18:32:37 <jackdk> coventry: Monad [] is a constraint, right?
18:33:14 <jackdk> sorry, to be more precise, the kind of `Monad []` is `Constraint`; i.e. `Monad [] :: Constraint`?
18:35:13 <jackdk> oh, sounds like you might have the help you need in scrollback. nm
18:36:04 <coventry> Well, I'm still struggling with the answer, but hoping I can work back from there. :)
18:36:14 <coventry> @maerwald: Thanks, ghci works now.
18:36:14 <lambdabot> Unknown command, try @list
18:37:31 <jackdk> coventry: if Monad [] :: Constraint, then Monad :: <whatever-the-kind-of-[]-is> -> Constraint. IRC doesn't use @prefix on names btw
18:38:38 <iqubic> jackdk: The kind of [] is (* -> *)
18:39:05 <iqubic> so Monad :: (* -> *) -> Constraint
18:39:38 <coventry> "Thinking With Types" says "CONSTRAINT is the kind of any fully-saturated typeclass". What does "fully-saturated" mean?
18:39:54 <iqubic> It means all the arguments have to given at once.
18:40:07 <iqubic> > map (+5) [1,2,3]
18:40:09 <lambdabot>  [6,7,8]
18:40:09 <ChaiTRex> coventry: Monad a rather than just Monad is fully saturated.
18:42:17 <coventry> Thanks, this is clarifying things for me. I probably need to look at the explicit definition of CONSTRAINT. "Thinking With Types" only gives `show` as something with kind CONSTRAINT.
18:43:57 <iqubic> coventry: Every single time you create a typeclass, you also create a constraint.
18:44:26 <coventry> What's an example of a constraint which is not a typeclass?
18:45:03 <sarahzrf> ~
18:45:07 <iqubic> Those exist. If you keep reading Thinking with Types, you'll son get to the part where those are explained.
18:45:27 <iqubic> But for now, type equality (a ~ b) is a good example.
18:46:26 <coventry> Ah, I see what constraint means, now. Thanks again.
18:46:55 <iqubic> coventry: When you see a type singature like this:
18:47:00 <iqubic> :t (+)
18:47:01 <lambdabot> Num a => a -> a -> a
18:47:18 <iqubic> Every thing to the left of => is a constraint.
18:47:22 <iqubic> :t sort
18:47:24 <lambdabot> Ord a => [a] -> [a]
18:47:50 <iqubic> So Num and Ord can go on the left of a (=>), so those are Constraints.
18:48:40 <coventry> They play a similar role to interfaces in an object-oriented context, right?
18:48:49 <coventry> One other hopefully quick question from what I've read so far, what is `Type` doing in `:kind! (1 + 17) Type 3`? The response is 54, i.e., 3*18, so it's acting as a multiplication operation, I guess. But why?
18:49:13 <solonarv> coventry: uh, that should just be an error...
18:49:25 <solonarv> % :kind! (1 + 17) Type 3
18:49:25 <yahb> solonarv: ; <interactive>:1:4: error: Not in scope: type constructor or class `+'
18:49:46 <solonarv> % import GHC.TypeNats (type (+))
18:49:46 <yahb> solonarv: 
18:49:48 <solonarv> % :kind! (1 + 17) Type 3
18:49:48 <monochrom> What the hell is (1+17) Type 3 ?
18:49:48 <yahb> solonarv: ; <interactive>:1:1: error:; * Expected kind `* -> GHC.Types.Nat -> k0', but `1 + 17' has kind `GHC.Types.Nat'; * In the type `(1 + 17) Type 3'
18:50:11 <solonarv> I have a vague suspicion
18:50:15 <coventry> Ah, OK. That was the reason I'd wanted to spin up ghci. OK, must be a typo, then. :)
18:50:25 <solonarv> Type is/was also written *
18:50:44 <coventry> Ah, he might have done a global find-and-replace.
18:50:44 <solonarv> this notation is in the process of being (slowly, to not break all the code everywhere at once) phased out
18:50:52 <solonarv> yup that must be it
18:51:06 <monochrom> oh haha
18:51:09 <solonarv> obviously using * to mean Type is annoying when you also want to use it for multiplication
18:51:31 <solonarv> all sorts of terrible parser hacks
18:51:51 <monochrom> and dad jokes
18:52:15 <monochrom> "Hi I'm taking an AI course and I'm learning the A Type algorithm"
18:52:39 <solonarv> haha, nice
18:53:24 <lukebfox[m]> a pox on your children
18:53:29 <lukebfox[m]> another one
18:53:42 <lukebfox[m]> pls
18:54:14 <MarcelineVQ> ohho that is in the book too, defintely an error since ^ is used in the example below it, among other reasons that's an error
18:54:34 <coventry> I'll send him a note.
18:54:37 <MarcelineVQ> * as the multiplier of Nat was defintely intended rather than Type
19:31:13 <coventry> In `type family Bar x y ::   Bool ->   Bool ->   Bool`, why do the `x` and `y` slots end up being of kind `Bool` in `:kind Bar`, i.e. `Bar :: * -> * -> Bool -> Bool -> Bool`?
19:32:56 <MarcelineVQ> the x and y are the * there
19:34:22 <coventry> Right, but why aren't they `Bool`?
19:34:54 <coventry> Sorry, I meant "why *don't* the `x` and `y`..."
19:35:22 <MarcelineVQ> The last line in the text above the Foo example says why
19:35:23 <int-e> coventry: how many arguments do you expect Bar to take?
19:36:00 <int-e> But I guess I lack some context. Haven't seen Foo.
19:36:05 <MarcelineVQ> There's nothing telling x and y to be more specific than * and "The kinds of type families are tricky beasts; the kind you write after the :: is the kind of the type returned by the type family, not the kind of the type family itself."
19:36:49 <coventry> Oh, I see, now. I was misinterpreting the `::`.
19:36:51 <coventry> Thanks.
19:37:00 <MarcelineVQ> as opposed to Foo  type family Foo (x :: Bool) (y :: Bool) :: Bool  where we constrain what x and y can be, and we result in a Bool kind
19:37:21 <int-e> (But this is where I was going with my question.)
19:37:38 <coventry> Yep, I see where you were pointing, now.
19:38:03 <MarcelineVQ> int-e: wasn't trying to cut you off, just that I had context open already :>
19:39:28 <int-e> MarcelineVQ: I didn't feel cut off, I just realized at that point that I didn't have the complete picture. Though, apparently, I did actually have enough of it to help in principle :)
19:40:02 <coventry> Yeah, the book was pointing that way, too, I just needed a bit more emphasis to see. :)
19:42:47 <int-e> MarcelineVQ: And of course this channel has a long history of several people answering the same question at about the same time in slightly different ways. So all is well :)
19:47:34 <coventry> The book claims that `newtype T5 a = T5 ((a -> Int) -> Int)` has a viable `Functor` instance, but `Functor` only corresponds to mathematically covariant functors, and `T5` would be contravariant, wouldn't it?
19:48:38 <int-e> coventry: it's kind of contra-contra-variant
19:48:48 <int-e> coventry: which makes it covariant again.
19:50:27 <coventry> How does an `a -> b` give me a `T5 b` from a `T5 a`?
19:50:35 * int-e resists the temptation to do @djinn (a -> b) -> ((a -> c) -> c) -> ((b -> c) -> c)
19:51:31 <int-e> coventry: But writing out the type like that should help :)
19:52:30 <coventry> Sorry, I don't follow.
19:53:29 <int-e> Ignoring the T5 newtype wrapper, you need a function  (a -> b) -> ((a -> c) -> c) -> ((b -> c) -> c), where c = Int (but that could be an arbitrary type)
19:54:59 <coventry> Yeah, I'm not seeing how to define that function.
19:55:23 <coventry> Sounds like I'm going to kick myself when I do. :)
19:55:51 <int-e> Well, -> is right-associative, so that's (a -> b) -> ((a -> c) -> c) -> (b -> c) -> c?
19:56:33 <int-e> At which point the question is how you get c given values of type a -> b, (a -> c) -> c, and b -> c.
19:56:53 <coventry> Ah, got it. Thanks.
19:59:28 <hololeap> i notice that there is no reset function for TChans
19:59:53 <hololeap> is there a reason this is omitted?
20:00:05 <hololeap> reset/clear
20:10:02 <MarcelineVQ> coventry: this is explained just above the T1-T5 examples, it's about positivity/negativity
20:11:21 <MarcelineVQ> oh pardon me, the newtypes do appear before the discussion of positivity/negativity
20:19:17 <hololeap> clearTChan :: TChan a -> STM ()
20:19:18 <hololeap> clearTChan = void . runMaybeT . mapM_ (MaybeT . tryReadTChan) . repeat
20:19:26 <hololeap> would that work?
20:27:29 <rkcy> What would be the alternative to type alias for int .  newtype IntLit = IntLit {i:: Int} appears to be little cumbersome with pattern match required to get to the int value.
20:27:39 <rkcy> Something like opaque type in scala.
20:29:25 <amalloy> how else would you want to get out the value, if you want it to be opaque?
20:38:53 * hackage nix-freeze-tree 0.1.0.0 - Convert a tree of files into fixed-output derivations  https://hackage.haskell.org/package/nix-freeze-tree-0.1.0.0 (jack)
21:15:13 <hololeap> (my clearTChan seems to work)
21:16:56 <jackdk> hololeap: is it meant to drain always and forever?
21:17:24 <hololeap> jackdk: it's supposed to empty the TChan
21:19:31 <hololeap> `mapM_ (MaybeT . tryReadTChan)` will keep reading until it gets Nothing
21:20:31 <hololeap> and it's just reading (lazily) from an infinite list of `TChan a`
21:20:53 <jackdk> ah yes, and the runMaybeT is why it will stop at the first Nothing. clever
21:26:08 <hololeap> in most cases when i see `m (Maybe a)` i reach for MaybeT
21:26:57 <hololeap> but, thanks :)
21:34:47 <remexre> is https://gitlab.haskell.org/ghc/ghc/wikis/building/cross-compiling known to be correct? WITH_TERMINFO=no the build fails
21:53:06 <sicklork1n> Does anyone recognize this format for sorting? I want to sort those numbers from 1.. based on the alhpa numeric string. I have an adhoc sorter but wondered of there was some well-defined way that I'm not familiar with.  https://pastebin.com/1DN1xn2v
21:59:49 <hololeap> sicklork1n: so you want to sort it based on the number in the rightmost field? (assuming whitespace is the delimiter)
22:00:19 <sicklork1n> imagine I have some pairs (AA,1),(AC,3),(AB,2),(Z,A) I would end up with the following: A,1,2,3
22:01:29 <hololeap> so you want to filter based on some common substring?
22:01:50 <hololeap> filter/sort
22:02:23 <sicklork1n> hololeap: the left defines the sort order
22:07:27 <hololeap> sicklork1n: [("AA",1), ("AC",3), ("AB",2), ("Z",'A')] doesn't typecheck
22:08:09 <hololeap> at first the second element in each pair is some sort of Num, but then you have 'A' thrown in there
22:09:56 <hololeap> % let startsWithA = filter (\(c:_,_) -> c == 'A')
22:09:56 <yahb> hololeap: 
22:09:58 <sicklork1n> hololeap: both are alphanum.. and i'm trying to come up w/the rules for the Ord instance for the left hand side.
22:10:22 <hololeap> % let sortByFst = sortBy (compare `on` fst)
22:10:22 <yahb> hololeap: 
22:10:45 <hololeap> % let headOfFst = map (\(f,s) -> (head f, s))
22:10:45 <yahb> hololeap: 
22:11:18 <hololeap> % (headOfFst . sortByFst . startsWithA) [("AA",1),("AC",3),("AB",2),("Z",4)]
22:11:18 <yahb> hololeap: [('A',1),('A',2),('A',3)]
22:13:02 <hololeap> sicklork1n: that does what you asked
22:14:02 <sicklork1n> % [ ("GMYTSORRGY","16"), ("GMYTSORRHA","18"),("GMYTSORRHE","19"),("GMYTSORR","1")]
22:14:02 <yahb> sicklork1n: [("GMYTSORRGY","16"),("GMYTSORRHA","18"),("GMYTSORRHE","19"),("GMYTSORR","1")]
22:14:30 <sicklork1n> % (headOfFst . sortByFst . startsWithA)  [ ("GMYTSORRGY","16"), ("GMYTSORRHA","18"),("GMYTSORRHE","19"),("GMYTSORR","1")]
22:14:30 <yahb> sicklork1n: []
22:14:55 <hololeap> startsWithA only selects strings that start with 'A'
22:16:46 <hololeap> so what do you want it to do? it seems like you want it to somehow detect that "GMYTSORRGY", "GMYTSORRHA", "GMYTSORRHE", ... all have something in common
22:17:47 <hololeap> if you just want to sort by the first element of a pair (e.g. the string on the left), you can use (compare `on` fst)
22:18:05 <hololeap> `on` is just a combinator from Data.Function
22:19:38 <hololeap> % :t (compare `on` fst)
22:19:38 <yahb> hololeap: Ord a => (a, b) -> (a, b) -> Ordering
22:19:56 <hololeap> % :t on
22:19:56 <yahb> hololeap: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:20:10 <hololeap> % :t (compare `on`)
22:20:10 <yahb> hololeap: Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
22:20:50 <hololeap> % :t sortBy (compare `on` fst)
22:20:50 <yahb> hololeap: Ord a => [(a, b)] -> [(a, b)]
22:20:52 <sicklork1n> hololeap: thanks for your help..
22:21:00 <sicklork1n> :t sortOn fst
22:21:03 <lambdabot> Ord b1 => [(b1, b2)] -> [(b1, b2)]
22:21:20 <sicklork1n> :t (.) . (.)
22:21:22 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
22:21:44 <hololeap> sure thing
22:24:32 <sicklork1n> hololeap: So the GMY stuff is some machine readable ID that has an ordering such that [ ("ARG4","17"), ("ARGA","10"), ("AR","1")] natural order is 1, 10, 17.  What I'm trying to figure out is, does this alphanum ID look familiar to anyone?
22:25:14 <hololeap> it seems pretty arbitrary to me
22:25:50 <hololeap> if you're looking for some pattern between the left and the right in each pair, i don't see it
22:26:38 <sicklork1n> fi you strip the common prefix I think the pattern is visible
22:27:01 <sicklork1n> but it's a stretch
22:27:22 <hololeap> so "G4" is worth 7 more than "GA" ?
22:27:26 <Lears> Looks like `sortBy (comparing length <> compare)`, if numerics > alpha.
22:27:32 <sicklork1n> ICU
22:28:01 <sicklork1n> hololeap: yes, that's the universe I'm in
22:29:39 <sicklork1n> i'm looking at ICU collation tables to see if that fits
22:31:40 <Lears> % sortBy (comparing length <> comparing (fmap $ \c -> (c `elem` "0123456789", c))) ["GMYTSORRG4", "GMYTSORRGA", "GMYTSORRGE", "GMYTSORRGI", "GMYTSORRGM", "GMYTSORRGQ", "GMYTSORRGU", "GMYTSORRGY", "GMYTSORRHA", "GMYTSORRHE", "GMYTSORR", "GMYTSORS", "GMYTSORT", "GMYTSORU", "GMYTSORV", "GMYTSORW", "GMYTSORX", "GMYTSORY", "GMYTSORZ"]
22:31:40 <yahb> Lears: ["GMYTSORR","GMYTSORS","GMYTSORT","GMYTSORU","GMYTSORV","GMYTSORW","GMYTSORX","GMYTSORY","GMYTSORZ","GMYTSORRGA","GMYTSORRGE","GMYTSORRGI","GMYTSORRGM","GMYTSORRGQ","GMYTSORRGU","GMYTSORRGY","GMYTSORRG4","GMYTSORRHA","GMYTSORRHE"]
22:32:04 <sicklork1n> Lears: nice
23:24:24 * hackage joint 0.1.5 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.5 (iokasimovmt)
