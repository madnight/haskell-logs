00:49:54 * hackage web-rep 0.3.0 - representations of a web page  https://hackage.haskell.org/package/web-rep-0.3.0 (tonyday567)
01:17:41 <zincy> What type is recommended for representing monetary values. I see there is a library called safe-library. Is this library a good choice? Also curious what is the way of doing this without a library?
01:20:00 <Solonarv> zincy: is that a typo and you meant safe-money ?
01:21:25 <dminuoso> zincy: Id try and use safe-money.
01:21:33 <dminuoso> zincy: Or I would go about encoding something similar.
01:22:25 <dminuoso> In the end it depends a bit. If you need to deal with just a single currency, say EUR/cents, then often you can just keep everything in cents and make the rest a problem of visualization.
01:22:45 <dminuoso> Just be sure to newtype it.
01:22:54 <Philonous> zincy, I think it's common to represent monetary values with integer types, as in $4.15 would become 415. Of course, if you need to deal with fractional cents you'd be out of luck. Depending on your domain you could get away with another fixed-point representation. 
01:23:22 <Philonous> If you only have a fixed, limited number of currencies you need to deal with you could either newtype them or put them in an ADT
01:23:59 <dminuoso> Philonous: Even for fractional cents you can simply use Ratio
01:24:31 <Philonous> True
01:24:50 <dminuoso> The real important lessen is to *not* use Float/Double. :)
01:24:54 * hackage box 0.2.0 - boxes  https://hackage.haskell.org/package/box-0.2.0 (tonyday567)
01:25:24 <Philonous> I think the upshot is that there is no real one-size-fits-all solution and you need to consider your legal and business requirements, but newtype Dollars = Dolalrs Integer is a good start 
01:26:19 <Philonous> dminuoso, Not unless you know exactly what you are doing, at least. Which, let's face it, chances are practically nil anyone does. 
01:26:39 <dminuoso> Philonous: That holds true for Float/Double in general.
01:28:19 <Philonous> But I seem to remember we had a discussion in here where someone said their company did monetrary calculations in IEEE 754, that they had specifically hired mathematicians to make this work and that it was a huge advantage for some reason. 
01:28:31 <__monty__> When would an IEEE float be fine for money? Simulating estimates or something?
01:28:58 <dminuoso> Philonous: There's absolutely nothing wrong with using any implementation if you are fully aware of its consequences.
01:29:08 <__monty__> Maybe the performance is worth it for high frequency trading?
01:29:19 <Philonous> Probably something like that, yes.
01:29:23 <dminuoso> Sounds like a reasonable hypothesis.
01:31:56 <Philonous> Well, all computer representations are finite, so you're dealing with rounding errors anyway. 
01:32:44 <davve_> you should use a custom fraction type instead of float
01:32:44 <davve_> :p
01:33:16 <alfonsox> Usually Currency involves 2 decimal places, and upto 5 decimal places in some cases.
01:34:21 <Solonarv> you do not have to deal with rounding errors
01:34:23 <alfonsox> Is there a lib which guarantee correct calculations 2 to 5 decimal places ?
01:34:56 <Solonarv> instead you can deal with exact computable reals that slowly grow to take ever more memory and time :P
01:35:21 <dminuoso> Philonous: Im not sure how useful that statement is.
01:35:31 <alfonsox> '=D 
01:36:12 <davve_> you can just count by multiple of 100 in that case
01:36:17 <davve_> and divide by 100 when presenting
01:36:34 <davve_> assuming you're using unlimited integers
01:36:34 <MarcelineVQ> just use safe-money plz
01:37:07 <Philonous> dminuoso, I didn't mean to imply that the choice of representation doesn't matter - that would be silly. I meant to say that even if you choose a fixed point representation you're not home free. You still need to check if it fits your requirements, and that "just don't use IEEE 754" isn't enough (which nobody claimed, but sometimes it sounds like that) 
01:38:00 <MarcelineVQ> https://ren.zone/articles/safe-money
01:47:14 <boxscape> Does haddock represent newtype as data if constructors aren't exported? I'm noticing that https://hackage.haskell.org/package/safe-money-0.9/docs/src/Money.Internal.html#Dense is a newtype but https://hackage.haskell.org/package/safe-money-0.9/docs/Money.html#t:Dense shows it as data
01:50:25 <Solonarv> boxscape: your guess is correct
01:51:31 <boxscape> ok, interesting
01:52:24 <__monty__> What's the reasoning? Keeping the implementation as abstract as possible?
01:52:32 <Solonarv> my guess at the reasoning is: when you don't export constructors, you are doing this to hide implementation details. whether a type is newtype or data is an implementation detail.
01:52:59 <Solonarv> also, note that you can't *do* anything with the knowledge that it's a newtype unless the constructor is exported
01:53:38 <Solonarv> the Coercible machinery only makes a 'Coercible Newtype WrappedType' instance available when Newtype's constructor is in scope
01:53:48 <__monty__> You might decide not to use something that looks like data because you want the performance of a newtype?
01:55:00 <Solonarv> if you are that worried about performance, you should be looking at the source anyway
01:55:12 <Solonarv> (or better yet, running benchmarks)
01:55:50 <__monty__> Hmm, I usually look at newtypes more like a harmless optimization. Not really a reason *not* to use them?
01:56:27 <boxscape> they change the strictness properties of values of that type
01:56:38 <boxscape> % newtype F = F F deriving Show
01:56:38 <yahb> boxscape: 
01:56:45 <boxscape> % undefined :: F
01:56:50 <yahb> boxscape: F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F (F
01:56:59 <boxscape> % data G = G G deriving Show
01:57:00 <yahb> boxscape: 
01:57:03 <boxscape> % undefined :: G
01:57:03 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:2:1 in interactive:Ghci5
01:57:40 <phadej> that's just how show for G is written
01:57:48 <boxscape> hm, that's fair
01:57:52 <Solonarv> % data S = S !S
01:57:52 <yahb> Solonarv: 
01:57:55 <Solonarv> % undefined :: S
01:57:56 <yahb> Solonarv: ; <interactive>:4:1: error:; * No instance for (Show S) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
01:58:01 <Solonarv> whoops
01:58:06 <Solonarv> % data S = S !S deriving Show
01:58:06 <yahb> Solonarv: 
01:58:09 <Solonarv> % undefined :: S
01:58:09 <yahb> Solonarv: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:6:1 in interactive:Ghci7
01:58:26 <Solonarv> not just the strictness that's different
01:58:36 <Philonous> You can write your own instance for Show that does the same thing even when it's data
01:58:51 <Solonarv> a strict data constructor is exactly as strict as a newtype constructor
01:59:04 <Solonarv> the difference really is just in 'show'
01:59:38 <phadej> % data L = L { unL :: L }; instance Show L where showsPrec d l = showParen (d > 10) (showString "L " . showsPrec 11 (unL l)); show (undefined :: L)
01:59:38 <yahb> phadej: ; <interactive>:7:146: error: parse error (possibly incorrect indentation or mismatched brackets)
01:59:57 <phadej> ah, too much stuff on one line I guess, but that's the idea ^
02:01:53 <boxscape> Solonarv I disagree:
02:01:59 <boxscape> % newtype F = F Int
02:01:59 <yahb> boxscape: 
02:02:02 <boxscape> % data F = F Int
02:02:02 <yahb> boxscape: 
02:02:05 <boxscape> uh
02:02:08 <Solonarv> heh
02:02:09 <boxscape> % newtype G = G Int
02:02:09 <yahb> boxscape: 
02:02:17 <boxscape> % g (G x) = ()
02:02:18 <yahb> boxscape: 
02:02:22 <boxscape> % f (F x) = ()
02:02:22 <yahb> boxscape: 
02:02:25 <boxscape> % f undefined
02:02:25 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:10:3 in interactive:Ghci11
02:02:31 <boxscape> % g undefined
02:02:31 <yahb> boxscape: ()
02:02:32 <Solonarv> yes, I neglected to mention that pattern matches are desugared differently
02:02:37 <boxscape> okay
02:02:57 <Solonarv> for newtypes they basically just turn into a 'coerce'
02:03:25 <boxscape> like `g (coerce -> x) = ()`?
02:04:04 <Solonarv> that's even more syntax sugar of course, but basically right
02:04:08 <boxscape> okay
02:06:01 <boxscape> (also oops I forgot to make G strict but it shouldn't make a difference)
02:06:07 <boxscape> (uh to make F strict)
02:10:07 <__monty__> % data H = H !Int; h (H x) = ()
02:10:07 <yahb> __monty__: 
02:10:12 <__monty__> % h undefined
02:10:12 <yahb> __monty__: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:13:3 in interactive:Ghci13
02:14:06 <phadej> % data H = H !Int; h ~(H x) = ()
02:14:06 <yahb> phadej: 
02:14:10 <phadej> % h undefined
02:14:10 <yahb> phadej: ()
02:18:44 <boxscape> % let g' (G !x) = () in g' undefined
02:18:44 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:29:26 in interactive:Ghci24
02:21:45 <__monty__> Hmm, I'm having a really hard time finding the GHC user guide section on lazy patterns : /
02:25:10 <boxscape> presumably that's a haskell feature rather than a ghc feature?
02:25:49 <dminuoso> boxscape: No, its a standard haskell feature.
02:25:53 <dminuoso> It's called irrefutable patterns.
02:26:01 <boxscape> that's what I'm saying
02:26:06 <dminuoso> Ah. :)
02:26:16 <boxscape> __monty__ page 30 of the Haskell 2010 report
02:26:21 <boxscape> https://www.haskell.org/definition/haskell2010.pdf
02:27:22 <__monty__> I've read about it in the report, vaguely remembered its existence. But I was hoping for a more detailed explanation in the user guide.
02:27:37 <ggVGc> TIL type roles are a thing...
02:32:17 <dminuoso> ggVGc: https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
02:32:36 <dminuoso> ggVGc: This is quite an easy but yet interesting read into the topic of roles, and why we have them in the first place.
02:32:51 <dminuoso> It's filled with quite a few surprises.
02:33:23 <ggVGc> dminuoso: thanks!
02:58:22 <zincy> thanks dminuoso and Philonous, think I will go with safe-money
02:58:30 <zincy> Solonarv: Yes It was a typo
03:10:54 * hackage cabal2spec 2.5 - Convert Cabal files into rpm spec files  https://hackage.haskell.org/package/cabal2spec-2.5 (PeterSimons)
04:32:54 * hackage wl-pprint-text 1.2.0.1 - A Wadler/Leijen Pretty Printer for Text values  https://hackage.haskell.org/package/wl-pprint-text-1.2.0.1 (IvanMiljenovic)
04:35:54 * hackage mmsyn7ukr 0.10.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.10.0.0 (OleksandrZhabenko)
05:06:54 * hackage mmsyn7h 0.6.2.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.6.2.0 (OleksandrZhabenko)
05:21:28 <joehhh1> hello, how do people go about running multiple hoogle databases at once for non developers to look up?
05:21:56 <joehhh1> Ie an instance of hoogle for each release of our software available internally?
05:26:48 <phadej> why would non-developers look at hoogle?
05:27:47 <gentauro> phadej: cos they can?
05:30:21 <joehhh1> To understand the configuration of our software - they will configure it and need to know what options are available for each version
05:31:01 <joehhh1> is there a standard solution for serving multiple hoogle databases?
05:31:07 <dminuoso> joehhh1: Why not serve from the same hoogle database?
05:31:27 <dminuoso> If you insist on keeping end user documentation in haddock, the trouble of maintaining separate hoogle sites might just give you headaches.
05:31:49 <joehhh1> interesting - how do you keep multiple versions of packages in the one hoogle db?
05:33:01 <dminuoso> joehhh1: You cant, afaik.
05:34:45 <joehhh1> ahh - you had me excited for a minute then :)
05:34:54 * hackage fgl 5.7.0.2 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.7.0.2 (IvanMiljenovic)
05:35:54 * hackage fgl-arbitrary 0.2.0.5 - QuickCheck support for fgl  https://hackage.haskell.org/package/fgl-arbitrary-0.2.0.5 (IvanMiljenovic)
05:41:54 * hackage exceptionfree-readfile 0.0.1.0 - An exception-free readFile for use with '+RTS -xc -RTS' projects  https://hackage.haskell.org/package/exceptionfree-readfile-0.0.1.0 (vados)
05:53:24 * hackage mmsyn7h 0.7.0.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.0.0 (OleksandrZhabenko)
06:02:43 <tabaqui1> how should I use Network.Socket.Splice.hSplice correctly? When I try something like { handle <- acquire addr port; BC.hPut handle "READY"; forkIO $! splice 4096 handle otherHandle }, lazy IO bites my ass
06:03:04 <tabaqui1> *forkIO $! hSplice 4096 handle otherHandle
06:09:54 * hackage mmsyn7h 0.7.0.1 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.0.1 (OleksandrZhabenko)
06:14:41 <tabaqui1> allright
06:14:53 <tabaqui1> How can I force evaluate IO action?
06:15:09 <tabaqui1> like "force $ BC.hPut h datum"
06:15:32 <maerwald> you mean force the value of the IO action?
06:15:43 <tabaqui1> probably
06:15:45 <[exa]> tabaqui1: how did you find it's not evaluated?
06:15:45 <dminuoso> tabaqui1: seq/pseq
06:15:48 <maerwald> deepseq
06:16:05 <tabaqui1> I dunno, I have problems with splice library
06:16:20 <[exa]> problems?
06:16:26 <solonarv> I don't think that's the problem you're having, tbh
06:16:26 <tabaqui1> And I think that some of my preparations before the actual "splice" call are not evaluated
06:16:44 <solonarv> hSplice's return value is IO (), there is no sneaky laziness in there
06:17:12 <[exa]> tabaqui1: like, something is not written into the socket before you splice?
06:17:26 <tabaqui1> I found out, my debugging prints work only if comment these splice calls
06:17:36 <tabaqui1> [exa]: yeah, like so, I guess
06:17:49 <tabaqui1> *if I comment...
06:18:21 <[exa]> tabaqui1: you might want to try strace to see what's actually written to the sockets
06:18:39 <tabaqui1> now I have a code like "do { print 1; getAddrInfo; h <- openSocketSetBufferingConvertToHandle; print 2; splice ... }"
06:18:55 <tabaqui1> and "print 2" shots only if I comment "splice" here
06:19:38 <tabaqui1> strace..., hm, I will try
06:19:55 * tabaqui1 is out for 30 minutes
06:21:22 <[exa]> tabaqui1: the actual splice in that test case is in forkIO or not?
06:28:26 <maerwald> https://leanpub.com/thinking-with-types is this a good book?
06:30:17 <hyperisco> it has some weird diagrams on the front I'd like to read explained
06:31:41 <maerwald> looks like the blueprints for a starship, verified on type level
06:32:42 <Uniaika> maerwald: yes it's a wonderful book
06:32:48 <hyperisco> Type error: vulnerable exhaust port
06:33:29 <maerwald> Hopefully it gets more in-depth into klingon cloaking device technology
06:34:51 <Uniaika> maerwald: nah you need to switch to Agda first :(
06:37:08 <maerwald> Uniaika: does the book have exercises?
06:38:54 * hackage exceptionfree-readfile 0.1.0.0 - An exception-free readFile for use with '+RTS -xc -RTS' projects  https://hackage.haskell.org/package/exceptionfree-readfile-0.1.0.0 (vados)
06:44:22 <MarcelineVQ> maerwald: some
06:44:30 <cruxicheiros> q: wju
06:44:35 <cruxicheiros> okay that was a typo
06:44:54 * hackage text-show 3.8.4 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.8.4 (ryanglscott)
06:45:01 <cruxicheiros> q: why can I not create a data type formed out of a restricted set of numbers, i.e. like this? https://gist.github.com/cruxicheiros/8c626f7c86540418c62ff2e3b9eecd44
06:45:57 <cruxicheiros> I get "Cannot parse data constructor in a data/newtype declaration: 0"
06:46:10 <cruxicheiros> so I take it that using a digit as a symbol in invalid
06:46:16 <cruxicheiros> is*
06:46:25 <cruxicheiros> is there an alternate way that I should be doing this?
06:46:48 <hyperisco> Only in Haskell could one be asked to take the <>~ operator seriously
06:47:17 <cruxicheiros> if I was using One and Zero as my symbols would I be able to map them to numerically represent 1 and 0?
06:47:36 <MarcelineVQ> maerwald: I haven't gone through it so idk if it has 'the right amount' but there are exercises at what appears as a reasonable frequency
06:48:45 <hyperisco> cruxicheiros, yes to what you last said. Constructors must follow a particular naming scheme, and starting with a digit isn't allowed.
06:49:34 <cruxicheiros> cool ok
06:50:49 <Zehle> This is just a test message.
06:51:18 <hyperisco> That test is just a message.
06:51:19 <cruxicheiros> hyperisco: is there something I can derive to add a numeric value? my brain says "ord" but I don't feel like this is right
06:51:44 <boxscape> cruxicheiros using O and I is somewhat common for binary number types
06:51:50 <hyperisco> cruxicheiros, hm. Well, what do you mean by "numeric"? There are many ways to regard numbers.
06:52:07 <Zehle> Haha, hyperisco – nailed it
06:52:14 <hyperisco> cruxicheiros, in other words, what operations are you looking for?
06:52:19 <cruxicheiros> what I want to do is write some functions for converting between different number representations
06:52:42 <hyperisco> cruxicheiros, okay, what is an example? what is the first one you want to do?
06:53:09 <cruxicheiros> first one I want to do is convert binary with no negative number support to decimal
06:53:51 <mjoldfield> cruxicheiros: Data.Digits will convert from an Int(eger) to a list of digits in an arbitrary base
06:54:07 <cruxicheiros> I am not looking for a way to do it in the prelude
06:54:14 <cruxicheiros> This is for revision for a subject I am studying
06:54:27 <hyperisco> Okay, so you would like to do base conversions. If a number in binary is a list of binary digits, and a number in decimal is a list of decimal digits, then converting from one to another is a function on lists, yes?
06:54:41 <cruxicheiros> yes, that is what I think so, it should be a list of digits
06:54:51 <hyperisco> So you would have  binToDec :: BinaryString -> DecimalString  and  decToBin :: DecimalString -> BinaryString
06:55:01 <cruxicheiros> then I can go through the digits recursively or with foldl and multiply by the base to the right power and add them
06:55:34 <cruxicheiros> then I will make different functions for different ways of representing negatives
06:55:48 <cruxicheiros> yeah makes sense
06:56:24 <cruxicheiros> what I am confused about is how to restrict the symbols in the string to only 0 and 1 or 0 through 9 - maybe I should be using chars
06:56:52 <hyperisco> You seem to be doing fine already by defining a constructor for each digit.
06:56:58 <mjoldfield> If you want to separate out the base conversion from the display, you might find functions like unDigits :: [Int] -> Int  and digits :: Int -> [Int] useful.
06:57:21 <hyperisco> There are fancier ways to construct finite types but I don't think you need to bother yourself with that right now.
06:57:38 <cruxicheiros> thanks, I'll check that out mjo
06:57:59 <cruxicheiros> i'll go ahead and write this in the dumbest way I can and then see if I can make it better from there
07:06:24 * hackage mmsyn7h 0.7.0.2 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.0.2 (OleksandrZhabenko)
07:34:24 * hackage mmsyn7l 0.3.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.3.0.0 (OleksandrZhabenko)
07:37:07 <tabaqui1> [exa]: yeah, it is in forked thread
07:37:11 <tabaqui1> but it doesn't matter anyway
07:37:30 <tabaqui1> corsis/splice on hackage doesn't use c_splice
07:38:02 <tabaqui1> and the version with c_splice can't be compiled on modern Linux
07:40:54 * hackage graphviz 2999.20.0.4 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.20.0.4 (IvanMiljenovic)
07:44:53 <dminuoso> Is there an equivalent of local for ChronicleT?
07:46:39 <dminuoso> Concretely, I have some `ChronictleT NIFError ...` where `data NIFError = NIFError ... | NIFWarning` - and I want to condemn if there's any NIFErrors, but not if there's NIFWarnings.
07:46:47 <dminuoso> Or do I have to use a separate WriterT for NIFWarnings?
08:02:17 <solonarv> 'retcon' is the closest, but does not do what you want
08:06:35 <Cale> dminuoso: Wait, are you unironically using ChronicleT? :D
08:07:21 <Cale> (it is actually kind of a cool and natural concept, the names are very memey though)
08:14:04 <hyperisco> I do not know a compelling case for that, given that all the related uses I can think of write with a Monoid
08:15:16 <dminuoso> Cale: Yes.
08:16:07 <dminuoso> The more I use it, the more I recognize that even if it looks like it fits, its still niche.
08:22:25 <bergey> What advice for submitting a useful bug report for a GHC panic?  The panic message itself seems awfully short on details, and it's part of a large (proprietary) work project.
08:23:09 <sm[m]> bergey: I’d discuss with #ghc
08:23:54 * hackage Chart-fltkhs 0.1.0.4 - A backend for the Chart library for FLTKHS  https://hackage.haskell.org/package/Chart-fltkhs-0.1.0.4 (empowerg)
08:24:50 <bergey> Good point, thanks
08:25:24 * hackage blank-canvas 0.7.1 - HTML5 Canvas Graphics Library  https://hackage.haskell.org/package/blank-canvas-0.7.1 (ryanglscott)
08:35:54 * hackage persistent-sqlite 2.10.6 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.6 (parsonsmatt)
08:37:54 * hackage persistent 2.10.5 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.10.5 (parsonsmatt)
08:39:54 * hackage persistent-template 2.8.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.1 (parsonsmatt)
08:42:24 * hackage persistent-template 2.8.2 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.2 (parsonsmatt)
08:44:59 <fresheyeball> so I have tracked down my problem a good bit
08:45:14 <fresheyeball> newPopStateEvent does infact create a valid event object
08:45:44 <fresheyeball> and if I log it to the javascript console with `jsg "console" ^. js2 "log" (toJSVal evt)`
08:45:57 <fresheyeball> I can dispatch the event ghcjs-dom created
08:46:05 <fresheyeball> in the javascript console and it works
08:46:19 <fresheyeball> I also verified that `w` in my code is infact the window
08:46:29 <fresheyeball> but I can't dispatch event on the window
08:46:36 <fresheyeball> for some reason
08:46:56 <fresheyeball> not with GHCJS.DOM.Event `dispatchEvent w evt`
08:47:20 <fresheyeball> or with Language.Javascript.JSaddle `jsg "window" ^. jsf "dispatchEvent" (toJSVal evt)`
08:50:32 <dminuoso> Mmm, is there a reason that Data.Text.Prettyprint.Doc.Doc does not come with an Eq instance?
08:50:55 <fresheyeball> dminuoso: I think it contains a function
08:50:56 <dminuoso> Some `instance Eq ann => Eq (Doc ann)` I mean
08:52:02 <dminuoso> Argh.. indeed.
09:20:24 * hackage semantic-source 0.0.2.0 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.0.2.0 (patrick_thomson)
09:29:24 * hackage aur 6.3.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-6.3.1 (fosskers)
09:54:36 <pavonia> Is there a way to invoke ghc as if runghc was run instead?
09:59:09 <maerwald> runghc is a binary
09:59:34 <geekosaur> looks  like it loads it into ghci and does :set prog <scriptname> and :main
09:59:50 <geekosaur> it's a binary because it can't be done sanely as a script on windows
09:59:57 <int-e> ghc -ignore-dot-ghci -e ':set prog L.hs' -e :main L.hs
10:00:10 <geekosaur> so ... that
10:00:37 <drew_b> is anyone using nix + hie here?
10:00:47 <drew_b> and if so, are you using the all-hies cachix thing?
10:00:50 <int-e> (if you have arguments, those go into the :main command)
10:01:51 <int-e> Anyway, fancy, I had never looked into the runghc program :)
10:02:12 <int-e> And I didn't know about :main either.
10:03:05 <maerwald> geekosaur: damn this windows compatibilities :P
10:03:07 <geekosaur> I did, it's useful in ghci to run a program with arguments during debugging
10:18:14 <hseg> Hi. I want to be able to write a constraint (A r ~ SL d) that rewrites to (d ~ (r+1)) (in particular, I'd like for GHC to infer one from the other)
10:18:26 <hseg> (this is a toy example, I have a more complicated one)
10:19:04 <hseg> Several options present themselves: Rewrite this as a no-method binary typeclass over Nat
10:19:58 <hseg> Use injective type families Nat -> Nat
10:20:31 <hseg> Use data families (already implicitly injective)
10:21:01 <hseg> Any ideas if this is possible, how difficult it is? Tradeoffs?
10:21:16 <pavonia> int-e: Thanks
10:24:54 * hackage mmsyn7ukr 0.11.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.11.0.0 (OleksandrZhabenko)
10:26:23 <hseg> (Just noted: Implicitly I want (A r ~ SL d) to be unsatisfiable at d=0, so I'd want GHC to error with a "couldn't satisfy constraint")
10:27:00 <hseg> (This probably means I'll need to have a 1<=d constraint floating around when trying to infer r from d)
10:35:36 <ph88^> is something like this available for haskell ? https://embed.cs.utah.edu/creduce/ 
10:36:54 * hackage mmsyn7h 0.7.1.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.1.0 (OleksandrZhabenko)
10:39:24 * hackage mmsyn7l 0.3.1.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.3.1.0 (OleksandrZhabenko)
10:41:33 <fresheyeball> I wrapped up my whole problem on SO https://stackoverflow.com/questions/59954787/cant-get-dispatchevent-to-fire-in-ghcjs
10:48:31 <Bloodreaverzor> Hello everyone, I need help getting the word out for a fundraiser, is it ok if I post the link here?
10:48:45 <Cale> Is it in some way related to Haskell?
10:48:58 <Gurkenglas> How would I derive an optic for (s -> Maybe a, a -> Maybe s)?
10:49:21 <glguy> Bloodreaverzor: No, you can't join random freenode channels to advertise a fundraiser
10:49:45 <Bloodreaverzor> Ok no problem
10:49:45 <fresheyeball> Cale: I pinged you in #reflex-frp
10:50:03 <Cale> fresheyeball: I have no idea what's going on in your question
10:50:19 <Bloodreaverzor> I just need help, don't mean to break any rules :)
10:50:19 <fresheyeball> Cale: oh, how can I be more clear?
10:50:24 * hackage mmsyn7h 0.7.1.1 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.1.1 (OleksandrZhabenko)
10:50:29 <hseg> hrm. Am getting <command line>: cannot satisfy -package-id algebra-4.3.1-inplace: from a cabal exec ghci
10:50:34 <hseg> no idea why
10:50:42 <fresheyeball> dispatchEvent is not firing and event
10:50:50 <fresheyeball> firing *an event
10:51:29 <Cale> fresheyeball: Seems like a browser thing? I don't know enough about how dispatchEvent works normally to know why it might not work.
10:51:52 <fresheyeball> Cale: well the big hint is, that if I fire an error right afterword, it works
10:52:04 <fresheyeball> I think this might be a lazy eval thing
10:52:13 <Cale> What return value did you get from it?
10:52:30 <fresheyeball> what do you mean?
10:52:48 <Cale> from dispatchEvent
10:53:04 <fresheyeball> I don't get a return value, its just ()
10:53:22 <fresheyeball> what happens is dispatchEvent should trigger an event in javascript
10:53:26 <Cale> It's supposed to produce a boolean value telling you if one of the handlers called preventDefault
10:53:29 <fresheyeball> which in turn will trigger any event listeners
10:53:45 <fresheyeball> Cale: ah, I can check, I was using dispatchEvent_
10:53:48 <Cale> I don't know if that'd actually be of use, but might be nice to know
10:54:22 <hseg> Nuked dist-newstyle, rebuilding.
10:54:39 <hseg> No help.
10:55:01 <hseg> (possibly relevant: the package cabal complains about (algebra) is patched locally)
10:55:26 <glguy> hseg: I don't know if this is it, but do you have a stale .ghc.environment* file around?
10:55:48 <hseg> No hidden files in my directory
10:56:06 <hseg> and dist-newstyle/tmp is empty
10:57:01 <Gurkenglas> hmm I suppose it's just an Iso s (Maybe s) (Maybe a) a
10:57:01 <maerwald> hseg: is ~/.ghc empty?
10:57:25 <hseg> Contains ghci.conf, ghci_history and x86_64-linux-8.8.1
10:57:52 <maerwald> what's inside x86_64-linux-8.8.1
10:57:55 <hseg> Contents of ~/.ghc/x86_64-linux-8.8.1/environments/default: http://ix.io/28At
10:58:02 <maerwald> delete it
10:58:04 <fresheyeball> Cale: it returns True
10:58:18 <maerwald> (or back it up)
10:58:24 <hseg> Nope
10:59:02 <maerwald> cabal exec ghc -- --interactive
10:59:03 <fresheyeball> Cale: so it wasn't cancelled
10:59:24 <hseg> That works
10:59:26 <hseg> Huh
10:59:28 <hseg> Why?
10:59:35 <maerwald> hahaha
10:59:43 <Cale> So presumably that event was dispatched, it's just whatever side effects you expected it to cause aren't occurring for some reason
10:59:48 <maerwald> cabal exec has special code for 'ghc'
10:59:54 <maerwald> because it knows it is toolchain
11:01:02 <hseg> wtf
11:05:21 <hseg> OK, so I'm trying out the typeclass idea, and am having errors https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
11:05:28 <Cale> fresheyeball: It just struck me that this is a bit of a weird thing to be doing in general, since usually the way to trigger those events to occur is to manipulate the browser history somehow. What happens if you write in the console something closer to the equivalent of your FFI call?
11:05:48 <Cale> fresheyeball: Like, maybe  window.dispatchEvent(new PopStateEvent("popstate"))
11:06:33 <hseg> (Basically, I want GHC to do the hard work of figuring out how to go from d to an r s.t. d ~ (r+1)
11:07:26 <fresheyeball> Cale: it works
11:07:36 <fresheyeball> also I made a gif of me doing that with the ghcjs produced values
11:07:38 <fresheyeball> and it works
11:07:41 <fresheyeball> foreign import javascript unsafe "window.foo()" foo :: JSM ()
11:07:42 <fresheyeball> w <- currentWindowUnchecked
11:07:44 <fresheyeball> e <- newPopStateEvent "popstate" Nothing
11:07:46 <fresheyeball> dispatchEvent_ w e
11:07:48 <fresheyeball> liftJSM foo
11:07:50 <fresheyeball> this also causes the side effect to happen
11:07:54 <dminuoso> Cale: By the way... category-printf. Is that package description a joke?
11:08:12 <fresheyeball> something about foo throwing an error, and the side effect occurs
11:08:26 <dminuoso> Cale: It sounds super intimidating, ripe for demonstrating to non-Haskells that even printf requires black magic category theory.
11:08:27 <Cale> dminuoso: Yes and no, it's an accurate description
11:08:33 <fresheyeball> also the return value doesn't mean the event dispatched
11:08:40 <fresheyeball> it tells us if it's cancelable
11:08:54 * hackage mod 0.1.1.0 - Fast type-safe modular arithmetic  https://hackage.haskell.org/package/mod-0.1.1.0 (Bodigrim)
11:09:07 <geekosaur> printf is black magic, so that's not unreasonable :p
11:09:34 <Cale> dminuoso: That package is a bit of a hilarious triumph of abstract category theory to accomplish something practical in a way
11:10:03 <hseg> Looks pretty readable if you ignore the weird vocabulary
11:10:10 <Cale> dminuoso: There's a category of formatting specifications, where the type of your formatter tells you how using it is going to alter the type of printf
11:11:35 <Cale> for example, something which is going to require an additional argument of type t (while accumulating a string of type m) will have type Format m a (t -> a)
11:11:42 <dmj`> @fresheyeball ping
11:11:43 <lambdabot> Unknown command, try @list
11:11:52 <fresheyeball> dmj`: hiya
11:11:56 <dmj`> fresheyeball: you rang sire?
11:11:59 <Cale> i.e. it turns the result of printf from something of type a to something of type t -> a
11:12:19 <fresheyeball> dmj`: yeah, I thought you might know what is going in my ghcjs code
11:12:22 <dmj`> fresheyeball: saw the SO post
11:12:23 <fresheyeball> and I can't figure it out
11:12:28 <fresheyeball> yeah that's it
11:12:35 <fresheyeball> I just updated it
11:12:50 <dmj`> implementing client side routing?
11:13:24 <fresheyeball> dmj`: yesir
11:13:34 <fresheyeball> this appears to be the last sticking point
11:13:40 <dmj`> fresheyeball: miso has modules built for this already https://github.com/dmjio/miso/blob/master/examples/router/Main.hs
11:13:44 <fresheyeball> it's driving me nuts
11:14:09 <dmj`> fresheyeball: uses servant to route and a subscription for detecting changes, IO actions for going back / forward in history
11:14:16 <dmj`> works with back button out the box
11:14:21 <fresheyeball> dmj`: me too
11:14:23 <dmj`> probably don't need ghcjs-dom for this one (or ever)
11:14:39 <fresheyeball> I like having ghc support
11:15:06 <fresheyeball> ok dmj` when you route, I assume you are using pushState yeah?
11:15:21 <Cale> dminuoso: I was watching a talk that Daniel Patterson was giving at NYHUG (which was fairly ill-fated, a bunch of things were going wrong with his slides...), but one of the examples he provided was an explicit description of type-safe printf in terms of continuations, he had an operator for composing formatters like (%) :: ((String -> b) -> c) -> ((String -> a) -> b) -> ((String -> a) -> c)
11:15:35 <Cale> dminuoso: ... I think that's right anyway :)
11:16:08 <Cale> and I thought "hey, I bet that's a well-known category which is in the libraries somewhere", thought about it a bit, and figured it out
11:16:24 <dmj`> fresheyeball: https://github.com/dmjio/miso/blob/master/ghcjs-ffi/Miso/FFI/History.hs
11:16:25 <dmj`> yea
11:16:51 <dminuoso> Cale: Ohh... okay, inserting that knowledge inserts sense in your previous remarks.
11:16:59 <Cale> It's the Cokleisli category of functions w a -> b where w is the comonad (->) m (where m is the monoid for our Strings)
11:17:07 <dmj`> fresheyeball: I'd just wait for WASM backend to land, GHC support for free
11:17:38 <Cale> and once I realised that, I said, well, let's write printf...
11:17:56 <fresheyeball> dmj`: so yes, I am using pushState, as are you
11:18:05 <Cale> printf f = runCokleisli f putStrLn
11:18:09 <Cale> oh, that was easy!
11:18:12 <dmj`> Cale: hi, do you know if there are plans to merge GHCJS and Asterius/WebGHC into GHC itself (assuming maturity), or is that just too insane.
11:18:15 <fresheyeball> and we know that pushState doesn't fire the popstate event
11:18:41 <dmj`> fresheyeball: popState gets fired back the back button is hit iirc
11:18:44 <fresheyeball> dmj`: how are you listening to changes?
11:18:45 <dmj`> when*
11:19:01 <Cale> dmj`: I'm not sure about GHCJS, but I think there is a plan to eventually have a webassembly backend of some sort in GHC
11:19:12 <dmj`> fresheyeball: very carefully (:
11:19:40 <dminuoso> Cale: Okay I think it clicked. The whole motivation was rather mysterious, but your background story helped. I'll have a deeper look now. :)
11:19:42 <dmj`> fresheyeball: you gotta listen on "popstate"
11:19:42 <Cale> dmj`: But I'm not really certain what the existing plan is, if anything is formalised. I don't know if the wasm stuff is ready enough yet
11:19:42 <dminuoso> Cheers!
11:19:51 <dmj`> fresheyeball: https://github.com/dmjio/miso/blob/5c3d01780bce2f803bf10d531c876250be5eebc6/frontend-src/Miso/Subscription/History.hs#L94
11:20:26 <Cale> dminuoso: And of course, we get to compose formatters with (.) which conveniently enough is the syntax that some languages use for string concatenation ;)
11:20:47 <dminuoso> Right :)
11:20:51 <Cale> dminuoso: So I made an instance of IsString for formatters that would inject an arbitrary string
11:21:14 <Cale> c :: (Monoid m) => m -> Format m a a
11:21:15 <Cale> c x = Cokleisli ($ x)
11:21:20 <Cale> instance (a ~ b, IsString s, Monoid s) => IsString (Cokleisli ((->) s) a b) where
11:21:20 <Cale>   fromString = c . fromString
11:21:42 <fresheyeball> https://github.com/dmjio/miso/blob/master/frontend-src/Miso/Subscription/History.hs#L86
11:21:50 <fresheyeball> dmj`: you dirty birdy
11:21:51 <dminuoso> Cale: Perhaps an article displaying the wonders of that libraries would be quite educational. :)
11:21:55 <dmj`> fresheyeball: do as I say not as I do
11:21:56 <Cale> (there's some constraint wankery there to get GHC to commit to the instance early and insist the types are equal later)
11:22:03 <dminuoso> Unless it already exists and I missed it.
11:22:06 <dmj`> fresheyeball: I plead the 5th
11:22:15 * dmj` blames cocreature 
11:23:09 * cocreature sues dmj` for defamation
11:23:16 <Cale> dminuoso: Yeah, I'd always half-intended to do a talk about it at some point
11:23:54 * dmj` puts briefcase of cash on the table, spins briefcase around towards cocreature
11:24:17 <glguy> Let's settle this like adults in court; don't insult the channel with your cash
11:24:48 <glguy> or with a duel, either way
11:25:11 <dminuoso> Cale: It seems quite approachable for the intermediate/advanced reader, and I've been aching to find some examples of applied category theory in Haskell.
11:26:06 <__monty__> A duel where the offended party gets to pick a wad of cash to hit the other with first? : D
11:26:10 <Gurkenglas> @let gurki = iso (undefined :: String -> Maybe String) (undefined :: String -> Maybe String)
11:26:12 <lambdabot>  Defined.
11:26:16 <Cale> dminuoso: The kind of sad part is that despite this library working out much more beautifully than I could ever have hoped (even the type errors are sensible!), I practically never use it myself
11:26:21 <Gurkenglas> > "asd" ^. gurki -- why not Maybe String?
11:26:24 <lambdabot>  error:
11:26:24 <lambdabot>      • Couldn't match type ‘Maybe String’ with ‘[Char]’
11:26:24 <lambdabot>        Expected type: Getting String [Char] String
11:26:57 <Gurkenglas> or rather, how would i use this correctly to get the two functions out? preferably not just via withIso
11:27:18 <Cale> (basically because printf is a silly idea to begin with -- I just concatenate the text I want to print and print it separately)
11:28:20 <dminuoso> Cale: Yeah.. most of my formatting is delegated to prettyprinter, which I found to be the most elegant way to format output.
11:28:43 <dminuoso> Most problems dont require me to focus on "how many digits do I need to print out". It's mostly a non-issue.
11:28:52 <Cale> But it's pretty cute, you get a whole forth-like mini-language going on there with the stack manipulation operators, which btw, come very easily using arr from the Arrow instance which already existed :)
11:29:13 <Cale> (They're not hard to write manually in terms of the Cokleisli constructor either, but this was a nice realisation)
11:36:34 <Gurkenglas> ah dang, even gurki . gurki doesnt work, i suppose Iso s (Maybe s) (Maybe a) a wasn't right after all
11:37:18 <Gurkenglas> some sort of monadic optics are required
11:38:15 <dmj`> Cale: what do I do if I don't want to wait for a WebAssembly backend to land in GHC but still want to use Haskell
11:38:32 <Gurkenglas> https://hackage.haskell.org/package/lens-action no monadic iso :c
11:38:36 <dminuoso> dmj`: PureScript? :)
11:38:58 <bifunc2> Why are microbenchmarks so popular? I have a lengthy (a minute or two on *my computer*) IO action I want to benchmark. Are there any packages for that? (Alternatives to criterion)
11:39:05 <bifunc2> criterion is focused on microbenchmarks
11:39:40 <dmj`> dminuoso: https://github.com/purescript/purescript/issues/1177#issuecomment-491262908
11:39:42 <Cale> dmj`: Are you aware of reflex-platform?
11:40:00 <koala_man> you need less tooling support when the thing to benchmark takes minutes
11:40:01 <dmj`> Cale: yes
11:40:03 <Cale> dmj`: and/or Obelisk?
11:40:09 <koala_man> you can just look at your watch
11:40:11 <dmj`> Cale: yes
11:40:13 <Cale> I would recommend both of those things :)
11:40:22 <dmj`> Cale: does it support web assembly?
11:40:27 <Cale> Oh, no
11:40:32 <dmj`> Cale: oh :)
11:40:59 <Cale> It's just the easiest way to use ghcjs
11:41:06 <bifunc2> koala_man ok, so basically just roll out my own (measure seconds a few times and compute average)?
11:41:16 <bifunc2> it's easy enough
11:41:21 <bifunc2> just wondering if someone h ad already done it
11:41:22 <dmj`> Cale: eh, nix-shell -p haskell.compiler.ghcjs is easier imo 
11:41:25 <Cale> I wouldn't recommend trying to use webassembly for anything real until it's more baked
11:41:50 <dmj`> Cale: well, not for DOM stuff maybe, but for games it could be cool.
11:42:03 <koala_man> bifunc2: either that, or just once to warm up and once to time it
11:42:04 <Cale> Ah, fair enough -- there's a bunch of other stuff that reflex-platform sorts out for you too, depending on what kind of applications you're writing
11:42:11 <Cale> But yeah, that might be sufficient
11:42:16 <Gurkenglas> ooh http://hackage.haskell.org/package/yall-0.2.1/docs/Data-Yall-Iso.html#g:5
11:42:19 <bifunc2> actually use webassembly. help refine it. why? so that i don't have to.
11:42:26 <fresheyeball> hu, I am trying the forbidden unsafeIO solution
11:42:34 <fresheyeball> but I can't get forkIO to work with JSM
11:42:44 <dmj`> Cale: lots of reflex-platform gets upstreamed into nixpkgs it seems
11:42:45 <bifunc2> koala_man ok thanks
11:42:50 <Cale> yes
11:42:53 <fresheyeball> No instance for (MonadJSM IO(
11:43:16 <Cale> As it happens, I'm on a call right now with the guy who is mostly responsible for that.
11:43:18 <Cale> haha
11:43:31 <Cale> (John Ericson, a.k.a. Sonarpulse)
11:43:36 <Gurkenglas> Where's the compose, though? :(
11:44:07 <Cale> fresheyeball: Yeah, on anything other than ghcjs, IO and JSM are different monads.
11:45:07 <fresheyeball> Cale, any idea how I can forkJSM?
11:45:11 <hseg> Hrm. I'm trying to define a type family on Nats that has one value on even Nats and another on odd Nats
11:45:34 <hseg> But GHC dislikes a declaration of form F (2*n) ... = ...
11:45:53 <Cale> There's a forkJSM in Reflex.Dom.Websocket as it happens, lol
11:46:08 <Cale> http://hackage.haskell.org/package/reflex-dom-core-0.5.3/docs/src/Reflex.Dom.WebSocket.html#forkJSM
11:46:50 <hseg> _Could_ replace the Nat parameter by a Bool parameter given by (k`Mod`2)==0, but was hoping there'd be a more direct way
11:46:57 <Cale> Kind of odd that it discards the ThreadId, but I don't think it was ever intended to be used outside that module :P
11:47:39 <Cale> Probably shouldn't be exporting it tbh
11:48:01 <fresheyeball> oh what is askJSM?!
11:48:11 <fresheyeball> that looks amazing!
11:48:12 <Cale> It gives you the javascript context as a value
11:48:28 <Cale> which in ghcjs will just give you () or something
11:48:40 <Cale> but in jsaddle on ghc, will give you something more interesting
11:49:06 <Cale> JSM is just a reader monad there
11:49:12 <Cale> for that context
11:49:19 <fresheyeball> gotcha
11:49:31 <fresheyeball> I really wish ghc jsaddle worked better
11:49:40 <fresheyeball> if it was fast, I would prefer that to ghcjs
11:50:02 <fresheyeball> the appeal of using a backend io monad in a click handler... so nice
11:50:15 <Cale> Well, it's pretty okay for debugging, but the thing it's doing has been made fundamentally difficult by the browser people...
11:50:35 <dmj`> Cale: can't we just embed a language into Haskell that compiles to WASM, albeit a restricted one.
11:50:46 <Cale> dmj`: Why?
11:50:51 <fresheyeball> well unholy wreched unsafePerformIO saves the day :(
11:51:03 <Cale> fresheyeball: How?
11:51:15 <fresheyeball> instead of actually dispatching the event
11:51:20 <fresheyeball> I did what dmj` does
11:51:29 <dmj`> Cale: why not?
11:51:32 <fresheyeball> in my case keep a top level MVar
11:51:47 <fresheyeball> syncRoute = unsafePerformIO newEmptyMVar
11:52:02 <fresheyeball> then when I pushState I also putMVar
11:52:03 <dmj`> fresheyeball: why not just let the browser handle it
11:52:11 <dmj`> fresheyeball: probably don't even need an MVar
11:52:12 <fresheyeball> dmj`: why don't you?
11:52:25 <dmj`> fresheyeball: what would you put in it
11:52:31 <fresheyeball> ()
11:52:49 <fresheyeball> https://dev.fresheyeball.com/app
11:53:01 <fresheyeball> click the word "Echo"
11:53:04 <fresheyeball> it routes!
11:53:08 <dmj`> fresheyeball: all IO in the browser should by async, imo
11:53:30 <fresheyeball> dmj`: I literally copied your code
11:53:36 <fresheyeball> unless I am missing something
11:53:41 <fresheyeball> it is async
11:54:09 <fresheyeball> this is why I needed forkJSM
11:54:28 <fresheyeball> this is kinda neat actually, it has ideas from both Reflex and Miso to make this work
11:54:45 <fresheyeball> I am pretty happy right now, even though it's ugly
11:54:58 <fresheyeball> I got server side rendering, and frontend routing working
11:55:38 <hseg> Have a couple of maps on Nat I'd like GHC to infer bidirectionally, trying a typeclass approach: https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
11:55:53 <dmj`> fresheyeball: oh, as long as you fork the thread you're find. Yea I'm using a skipchan to keep the event queue from flooding. Sorry thought you were trying to do some thread synchronization w/ the main thread.
11:55:57 <dmj`> you're fine*
11:56:15 <hseg> Unfortunately, GHC seems not to unify stuff
11:56:26 <hseg> (cf error log, attached there)
11:56:27 <fresheyeball> dmj`: yeah, I hear you. I am not worried about flooding in this case
11:56:53 <dmj`> cool
11:57:42 <hseg> Also, I can't get TypeError to forbid instances
11:58:09 <hseg> (in fact, not sure TypeError fits the use I'm putting it to here -- probably should error out at runtime)
11:59:32 <merijn> hseg: I don't think the instances on, say, line 62-63 can work, since they overlap
12:00:06 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/crud-example2/router/Shpadoinkle/Router.hs#L168
12:00:22 <hseg> Right...
12:00:27 <fresheyeball> dmj`: ^^ if you are curious this is my servant based routing solution, and the line where I ripped off your evil
12:01:02 <dmj`> fresheyeball: you ripped off my router ... ?
12:01:22 <dmj`> fresheyeball: I have a confession to make ... 
12:01:23 <fresheyeball> dmj`: no... I was unaware you had a servant based router at all until just now
12:01:35 <fresheyeball> I ripped off the chan approach 
12:01:42 <dmj`> fresheyeball: I ripped the router from ElvishJerrico ;)
12:01:46 <fresheyeball> ha!
12:01:53 <fresheyeball> I think he ripped it from me!
12:02:05 <dmj`> what goes around comes around I guess
12:02:11 <fresheyeball> I wrote front end routing at Formation with servant for reflex-dom
12:02:33 <fresheyeball> and migrated it to the current version
12:02:42 <fresheyeball> which is much nicer than the original I wrote as reflex-servant-router
12:03:26 <fresheyeball> elvishjerricco: am I right in the origin of the code dmj` referres to
12:03:27 <fresheyeball> ?
12:03:40 <hseg> OK, so I replaced the TypeError instances by runtime errors and tried using fundeps to get around the non-unifications
12:03:47 <hseg> GHC complains my fundeps are illegal
12:03:59 <dmj`> elvishjerricco: https://github.com/dmjio/miso/blob/master/src/Miso/Router.hs#L64
12:04:07 <dmj`> I think I got this from you
12:06:58 <merijn> hseg: GHC can be a fuddy-duddy like that :p
12:07:05 <hseg> :)
12:09:51 <dmj`> main :: IO () = toWASM (1 + 1 :: Program)
12:09:58 <dminuoso> Why is the type signature of modifyIORef not `IORef a -> (a -> a) -> IO a`?
12:10:15 <dminuoso> Is there some intrinsic reason for not giving me access to the computed value?
12:10:26 <dminuoso> Forcing me to do an extra readIORef?
12:10:48 <Cale> atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b 
12:11:03 <Cale> You can just use that if you want
12:11:23 <hseg> OK, so https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398 now contains the error log without fundeps
12:11:34 <dminuoso> Cale: Yeah Ive been using it already, it's just slightly annoying to just duplicate the result into the tuple..
12:11:41 <hseg> Ah, wait
12:13:16 <hseg> Hrm. Why isn't instance (1<=d, d ~ (l+1), KnownNat d, KnownNat l) => l `A_SL` d a valid instance of a fundep l -> d, d -> l ?
12:14:24 <jle`> + is not seen as injective, so `l + 1 ~ d` doesn't fix d
12:14:55 <jle`> but it should satisfy l -> d
12:15:30 <jle`> er, might have gotten that backwards
12:15:58 <hseg> Ah right, GHC doesn't yet have injectivity statements on type families of form "any two of these determine the third"
12:16:26 <[itchyjunk]> hey my code works but its filling my screen with more and more Nothings :D
12:16:40 <[itchyjunk]> is there a way to improve it a bit so all i see is the number?
12:16:48 <jle`> whisper sweet nothings in my ear
12:17:12 <hseg> :D
12:17:21 <[itchyjunk]> https://imgur.com/a/rzoPqrh
12:17:34 <hseg> [itchyjunk]: So you want a function [Maybe a] -> [a] that strips the Nothings?
12:17:40 <jle`> maybe use mapMaybe instead of map
12:18:01 <[itchyjunk]> ah that would be nice
12:18:10 <jle`> :t mapMaybe
12:18:12 <lambdabot> (a -> Maybe b) -> [a] -> [b]
12:18:16 <jle`> :t map
12:18:17 <lambdabot> (a -> b) -> [a] -> [b]
12:18:19 <hseg> :i mapMaybe
12:18:19 <[itchyjunk]> hmm
12:18:26 <hseg> :(
12:18:32 <jle`> lambdabot has no :i
12:19:03 <[itchyjunk]> so i want mapMaybe, if i can figure out how to use it
12:20:01 <hseg> Goddammit. Even hiding the + behind a type family doesn't help
12:20:42 <hseg> This approach probably won't work
12:21:06 <[itchyjunk]> who me? :S
12:21:27 <hseg> no, me
12:21:27 <Uniaika> [itchyjunk]: did you take a look at catMaybes?
12:21:35 <jle`> [itchyjunk]: just replace 'map' with 'mapMaybe'
12:21:46 <hseg> (i'm working on something else)
12:21:51 <[itchyjunk]> that gave me error jle` :D
12:21:59 <hseg> What error?
12:21:59 <[itchyjunk]> Uniaika, never heard of that before in my life
12:22:11 <hseg> :t catMaybes
12:22:13 <lambdabot> [Maybe a] -> [a]
12:22:15 <jle`> what is the error?
12:22:17 <jle`> maybe you made a typo
12:22:21 <jle`> it is hard to know without seeing the error
12:22:30 <[itchyjunk]> Variable not in scope:
12:22:30 <[itchyjunk]>       mapMaybe :: (Integer -> Maybe Integer) -> [Integer] -> t
12:22:36 <dmwit> ?index mapMaybe
12:22:37 <lambdabot> Data.Maybe, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.Map.Strict, Data.Map.Lazy, Data.Map
12:22:39 <geekosaur> import Data.Maybe
12:22:44 <hseg> OK, you need to import it
12:22:50 <[itchyjunk]> oh
12:23:13 <[itchyjunk]> I don't need to import for Maybe but i do for mapMaybe?
12:23:34 <hseg> Hm. Is there a way of constructing two data families A and SL such that A l ~ SL d iff d ~ (l+1) ?
12:23:45 <[itchyjunk]> /o\ that works
12:24:19 <hseg> (and more generally, given an injective map F :: Nat -> Nat, is there a way of constructing data families C and D s.t. C x ~ D y iff x ~ F y? 
12:24:22 <dmwit> hseg: No. data families with different type constructors are never equal.
12:24:24 * hackage fclabels 2.0.4 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.4 (ErikHesselink)
12:24:44 <hseg> Hrm.
12:24:50 <jle`> [itchyjunk]: yup, that's what 'variable not in scope' tells you :)
12:24:55 <hseg> OK so that approach is out
12:25:00 <jle`> [itchyjunk]: it does take a while to get used to reading error messages admittedly
12:25:07 <jle`> they have their own sort of lingo
12:25:18 <[itchyjunk]> ah
12:25:37 <dmwit> hseg: What's bad about `type A l = SL (l+1)`?
12:25:49 <geekosaur> Maybe is useful even without those, which are relatively limited usefulness, so they need to be imported to be used
12:25:58 <dmwit> I guess it's that you can't partially apply it...?
12:26:11 <hseg> Could work -- have one be an actual type and the other a synonym
12:26:15 <geekosaur> otherwise we'd end up with a huge slow Prelude with everything and the kitchen sink in it
12:26:38 <[itchyjunk]> ah
12:26:58 <[itchyjunk]> I use kitchen sink everything. You made it sound like kitched sink is not useful :S
12:27:17 <dmwit> Certainly some taste/aesthetics went into deciding what's in Prelude and what isn't. Even so it might be interesting to trawl Hackage to get a data-driven idea of what people use.
12:27:21 * dmwit puts his finger on his nose
12:27:27 <geekosaur> it's not when it takes 5 minutes for ghc to start up because it's loading a huge Prelue
12:28:46 <hseg> Thing is that the edge case is that I want to take a function with a constraint d ~ (NumTrivEigens s (Parity d)+2*l), supply s and one of d/l and have GHC infer the other one
12:29:24 <hseg> (where NumTrivEigens :: Bool -> Bool -> Nat is injective given a fixed s)
12:30:48 <hseg> (got annoyed having to construct the singletons to convince GHC I could call the function
12:30:50 <hseg> )
12:33:11 <hseg> cf https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
12:44:58 <hseg> The type synonym approach doesn't work either: https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
12:45:09 <hseg> *sigh*
12:46:03 <hseg> At least the type synonyms are expanding
12:47:54 <hseg> But yeah, first error is probably because without further constraints, n ~ (r + 1) doesn't necessarily hold
12:48:49 <hseg> Hrm. Can try forcing the parity d unifies to in the definitions of b,d,b',d'
12:50:37 <hseg> OK, that just leaves convincing GHC that ‘If (Mod (2 + (2 * n)) 2 == 0) 'E 'O ~ 'E
12:51:21 <hseg> And the solvers I have installed are not doing the trick
12:52:18 <hseg> Also, need evidence-generating pattern matching for the definitions of sl, so and so'
12:52:48 <hseg> (first to split between 0 and n+1 cases, second to split between even/odd cases, last to split between 0/even/odd)
12:58:02 <dmwit> People always have to see the pain points first-hand before they believe in them. =P
12:58:43 <dmwit> There's always unsafeCoerce.
12:59:41 <hseg> :)
12:59:45 <dmwit> `axiom :: Mod (m*n) m :~: 0; axiom = unsafeCoerce Refl`
13:00:05 <hseg> Yup -- although my bikeshed's color is unsafeRefl
13:00:51 <dmwit> `lemma :: Mod (2+(2*n)) 2 :~: 0; lemma = axiom @2 @(1+n)`
13:01:40 <dmwit> or maybe
13:02:00 <dmwit> `lemma :: If (...) E O :~: E; lemma = case axiom @2 @(1+n) of Refl -> Refl`
13:02:58 <hseg> Hrm -- that could work (for the b,d,b',d' cases)
13:03:11 <hseg> (still need the actual case analysis for so,so')
13:03:32 <hseg> gimme a sec to try that
13:13:44 <hseg_> ... this is kinda defeating the point -- need to calculate what to apply the axiom to
13:13:57 <hseg_> but pursuing this for completeness' sake
13:16:22 <hseg_> :( really unsatisfied by this solution
13:17:38 <hseg_> Yeah, am getting no inference here whatsoever
13:18:40 <hseg_> Might as well just write SO2BD, B2SO, D2SO to compute the values I need
13:19:12 <geekosaur> this is more or less why plugins like natnormalise exist, no?
13:19:21 <geekosaur> inference is rather limited at this level
13:19:36 <hseg_> Yeah, but natnormalise isn't helping here
13:19:59 <geekosaur> (not that natnormalise would necessarily help here, more that you'd need your own to infer and add all the appropriate constraints)
13:20:36 <hseg> Right
13:20:41 <hseg> Isn't worth it
13:22:38 <orzo> Anybody know which is cheaper?  (==) on Handle or ThreadId ?
13:22:49 <Athas> Both are extremely cheap.
13:22:53 <Athas> I doubt this will be your bottleneck.
13:23:33 <orzo> if they're equal, i guess ill go with Handle
13:32:15 <dminuoso> orzo: Id say ThreadId is likely cheaper.
13:33:41 <Athas> dminuoso: Handle is a pattern match and then (==) on MVar, which I guess is pointer comparison.
13:34:03 <Athas> ThreadID calls cmpThreads which does some stuff I don't quite get.
13:34:45 <dminuoso> Ah.
13:35:32 <dminuoso> Athas: well cmp_thread is an rts primitiv
13:35:36 <Athas> I guess ThreadID does have less pattern matching, so it's probably faster.
13:36:38 <dminuoso> It's hard to say though, I reckon if there's any difference its miniscule at best.
13:36:55 <Athas> This is the kind of difference that you need to be very good at statistics to measure.
13:36:57 <dminuoso> It's like you said though. It's unlikely that this is a bottleneck. :)
13:37:17 <dminuoso> I have a hard time coming up with a scenario where this matters.
13:38:44 <hseg> Ugh... my type-level code is a mess, and even dropping all constraints didn't help
13:44:48 <merijn> hseg: I could've predicted that from just "type-level code" ;)
13:44:55 <hseg> :)
13:45:51 <dminuoso> merijn: have you seen their code?
13:46:07 <hseg> Am suspecting I should have gone with Idris or Sage for this project -- Haskell isn't really striking the balance I need here
13:47:04 <merijn> dminuoso: A bit, but in general anything involving type level programming seems to end in pain unless people exercise A LOT of care :p
13:48:06 <hseg> Right. The project started off avoiding the type level, but when I started getting bugs due to misaligned lengths I started using fixed-length vectors
13:49:38 <hseg> But two of the lengths determine each other, and I have written code that makes use of this
13:49:52 <hseg> So I need two typelevel nats to determine each other
13:50:03 <hseg> Not fun
13:51:22 <hseg> ... I'm an idiot. Push the term/type boundary slightly further -- keep the nat mutual-determination at the term level, and promote once I have all the typelevel stuff
14:03:56 <sm[m]> I was going to say..
14:05:51 <hseg> ... and it *still* doesn't work
14:06:09 <hseg> Lemme whip up a short snippet
14:09:46 <hseg> https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
14:10:24 <hseg> Have given up on convincing GHC, am forcing it to substitute its view of reality with my own
14:10:32 <hseg> And it *still* fails
14:15:28 <hseg> ... Unless having the pattern-match before the withKnownNat breaks things?
14:19:35 <hseg> Trying something new -- sidestepping the issue by working with reflection instead
14:23:43 <hseg> OK, so on the upside, the code is *much* cleaner
14:23:49 <hseg> On the downside, the bugs aren't gone
14:27:29 <dminuoso> Im constructing a sort of unordered heterogenous tree, where values can be stored in various buckets at a given level. For various reasons I need an efficient way to find those constructed values without looking through the entire tree.
14:28:15 <dminuoso> My thought was that I keep some `IORef (M.Map Key Value)` around and every time I construct a Value, I insert it into the map to make finding it easier later. 
14:28:40 <dminuoso> Is this idea in principle bad?
14:30:56 <hseg> Updated code at https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
14:40:12 <koz_> How do I get a list of all FilePaths within a directory corresponding to files with a specific extension?
14:49:01 <solonarv> shell "find" [".", "-type", "d", "-name", "*."<> extension] -- :P
14:49:15 <koz_> solonarv: You took about twice as long with that canned response as I expected. :P
14:49:28 <hseg> :D
14:49:34 <solonarv> my excuse is that I was away from my computer ;)
14:49:58 <koz_> solonarv: It's fine, nothing to apologize for. Humour is, after all, about the timing. :P
14:50:11 <hpc> real answer, shell "rm" ["-rf", "/path/to/directory/*"] >> return []
14:50:22 <koz_> hpc: Why stop there?
14:50:36 <hpc> don't want to risk deleting ghc :P
14:50:36 <solonarv> I'm sure you can do something like: allFiles <- getDirectoryContentsRecursive; let myFiles = filter ((=="ext") . takeExtension) allFiles
14:50:37 <koz_> shell "rm" ["-rf --no-preserve-root" "/"] >> return []
14:51:05 <solonarv> er, missing an argument to getDirectoryContentsRecursive there
14:51:23 <koz_> solonarv: I _could_, but I recall someone here mentioning a library just for this purpose which was a lot less awkward.
14:51:38 <solonarv> hm, perhaps
14:51:53 <solonarv> I couldn't point you towards it though
14:52:28 <maerwald> why would there be a library for something that is a simple combination of two functions
14:52:37 <maerwald> check npm maybe ;P
14:52:41 <koz_> maerwald: Lol.
14:53:26 <amalloy> someone could port find2perl to haskell
14:53:47 <schmittlauch[m]> Quick question about the "Stability" of modules displayed in haddock: What is this, how are the levels defined and should I take it seriously?
14:54:06 <koz_> schmittlauch[m]: A user-provided annotation, however people feel like, and no.
14:54:27 <dasli> haha I've been wondering about that as well
14:54:38 <schmittlauch[m]> Even modules that have been around for quite a while (e.g. mtl) are still largely "experimental"
14:54:59 <schmittlauch[m]> koz_: k, thanks. So it's fine to use mtl xD
14:55:08 <koz_> solonarv and maerwald: I think the library I meant was filepattern.
14:55:10 <solonarv> probably the maintainers have forgotten that annotation is there and never thought to update it ;)
14:55:17 <koz_> schmittlauch[m]: Very much so.
14:55:39 <koz_> It's _so_ stable that there's a bunch of changes that are meant to happen on it we're waiting on for _years_ at this point. :P
14:55:47 <hseg> Argh, GHC doesn't trust me https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
14:55:53 <solonarv> mtl is one of the basic libraries you will end up using nearly every time you do... practically anything
14:55:53 <maerwald> koz_: not worth a dependency, imo
14:56:02 <koz_> hseg: Don't take it personally - GHC doesn't trust anyone.
14:56:13 <dasli> yeah I thought "experimental" was supposed to be a good thing
14:56:38 <hseg> Yes, but this is even with the "Trust Me" unsafeCoerce 
14:57:08 <schmittlauch[m]> solonarv: That's why I was utterly confused about it being marked as "experimental"
14:57:33 <solonarv> I'd be confused too if I noticed that!
14:59:47 <koz_> solonarv: Also, isExtensionOf is a thing.
14:59:53 <schmittlauch[m]> solonarv: What if I opened a PR to remove that annotation?
15:00:19 <maerwald> unlike all those effects libraries, mtl is "well defined"
15:00:28 <maerwald> but that doesn't mean you'll like it
15:01:05 <solonarv> schmittlauch[m]: honestly, I have no idea
15:01:26 <solonarv> I'm not involved at all with the maintenance of any libraries and especially not core ones like mtl
15:01:44 <koz_> schmittlauch[m]: You can try, but don't expect any movement this end of eternity.
15:02:53 <maerwald> mtl is a boot library for ghc
15:03:01 <maerwald> that means your PR will probably wait a year or two
15:03:19 <merijn> The stability field of haddock was basically never used
15:03:20 <koz_> maerwald: Wait, mtl is a boot lib? I thought only transformers was a bootlib.
15:03:20 <davean> koz_: why do you say that? https://github.com/haskell/mtl/pulls?q=is%3Apr+is%3Aclosed
15:03:31 <merijn> So it's just a random string field
15:03:35 <maerwald> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history
15:04:32 <koz_> davean: https://github.com/haskell/mtl/pull/51 at least
15:04:40 <merijn> schmittlauch[m]: The reason it's not updated is because there's no consensus to what/how the stability field should be used, so what would you even change it to?
15:05:07 <davean> koz_: for somthing controversail, sure
15:05:18 <merijn> koz_: I don't see any link to libraries@ discussion
15:05:33 * koz_ shrugs.
15:05:41 <koz_> I'm not privy to all the discussion around this, clearly.
15:05:42 <merijn> And those seem fairly non-standard too
15:06:14 <davean> koz_: I mean it says it in the pull request you linked
15:07:59 <davean> koz_: the response was "you need to do more" and then more didn't happen
15:08:13 <koz_> davean: Fair enough. Consider that statement ill-considered on my part.
15:10:41 <koz_> I have a folder in my test directory (called data) which my tests need to load things from. How do I determine where exactly it is?
15:10:53 <koz_> I'm not sure what the working dir for 'cabal new-test' would be.
15:11:13 <hseg> any ideas why the types here fail to unify https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398 ?
15:12:34 <davean> koz_: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
15:13:30 <koz_> davean: Ah, OK. Thanks!
15:18:41 <monochrom> IIRC mtl has gone through "is a boot lib" "now it's not" "now it's again".
15:22:06 <jle`> hseg: those don't sound like unification errors necessarily
15:22:24 <jle`> er well, i guess it depends on how you think about it
15:22:31 <jle`> hseg: the first error is that a type variable is not inferrable because it isn't used
15:22:48 <jle`> the second error is that an existentially bound type variable is trying to escape its scope
15:23:03 <hseg> Yes, but it's supposed to be used by being unified with a variable that's being used
15:25:32 <hseg> omg I can't believe that worked!
15:25:59 <hseg> replacing k by k @td @tr fixes everything
15:28:31 <hseg> See the fixed version on https://gist.github.com/hseg/b88eca5c94eba7fdd2c7456df26eb398
15:32:52 <nickNAmes> is there a function that groups tuples like (1,a) (1,c)  (2,m) (1,g)
15:33:04 <nickNAmes> and takes all beginning with ones
15:33:13 <nickNAmes> groups them into a list
15:33:25 <nickNAmes> all the 2's into another??
15:34:29 <nickNAmes> maybe sth like filter
15:40:44 <monochrom> Combine sortBy and groupBy.
15:41:01 <monochrom> they are in Data.List
15:41:15 <hexagoxel> > M.fromListWith (++) [(1, ['a']), (2, ['b']), (1, ['c'])]
15:41:17 <lambdabot>  fromList [(1,"ca"),(2,"b")]
15:48:44 <schmittlauch[m]> merijn: I'd completely drop that field, because an optional outdated/ confusing field is worse than that field not being present at all.
15:55:57 <schmittlauch[m]> merijn: Can you point me to any discussions indicating that the semantics of the field are unclear/ controversial? As a newbie to Haskell I don't now where to look.
16:02:24 * hackage microlens-th 0.4.3.4 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.4.3.4 (Artyom)
16:03:24 * hackage microlens-platform 0.4.1, microlens-ghc 0.4.12 (Artyom): https://qbin.io/baths-blades-xb0v
16:40:54 * hackage arduino-copilot 1.2.0 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.2.0 (JoeyHess)
16:54:24 * hackage qq-literals 0.1.0.1 - Compile-time checked literal values via QuasiQuoters.  https://hackage.haskell.org/package/qq-literals-0.1.0.1 (hdgarrood)
17:02:15 <dminuoso> If I have multiple alternate pattern guards, and some subsequent of them start with the same patterns, can I reasonably expect GHC to do CSE by nesting case-of to not repeat work
17:03:14 <dminuoso> i.e. is there some guarantee `| Just x <- t, pat1 = ... | Just x <- t, pat2` will not scrutinize t twice?
17:13:48 <amalloy> i'd be surprised if there were such a guarantee
17:50:18 <ivab> o/
17:56:12 <ivab> hope everyone is having a good one
18:44:15 <koz_> Is there some pre-made equivalent of Either, but for three things?
18:44:26 <koz_> SO like, 'data Foo a b c = This a | That b | TheOther c'
18:44:52 <koz_> (if there isn't one, I'm naming it 'Docchi')
18:45:37 <infinisil> I feel like I've seen something like that before
18:46:34 <koz_> I can get around it by nesting Either I guess.
18:58:15 <erisco> what is a simple function I can write two ways and prove equivalence of with induction?
18:58:37 <jle`> koz_: nah and i would think the reason is the same as why we discourage the usage of 3-tuples
18:58:45 <erisco> actually I take just a simple function I can write two ways
18:59:02 <erisco> that has a few steps of equational reasoning
18:59:02 <jle`> erisco: maybe something like how foldr f . map g is the same as foldr (f . g) ?
18:59:08 <koz_> jle`: It turns out for my purposes, nesting Either is actually _closer_ to the spec.
18:59:16 <jle`> erisco: ah, or even just map id = id
18:59:17 <erisco> how about something with integers
18:59:28 <jle`> oh you mean like mathematical induction
18:59:53 <erisco> I am just looking for a good equational reasoning example
19:00:08 <jle`> koz_: my point was, you probably shouldn't be using eithers (anonymous sums), but something with actual names ;)
19:00:25 <jle`> erisco: foldr (+) . map negate ?
19:00:54 <koz_> jle`: I guess that would be better.
19:00:59 <jle`> or x + y = y + x
19:01:00 <koz_> Might be on my next refactor.
19:01:26 <jle`> classic equational reasoning example is x * (y + z) = x * y + x * z
19:23:54 <bachrijae> Has anyone been to Monadic Party? Would you recommend for a junior Haskell dev to pick up intermediate/advanced practical techniques? What kind of networking did you do there?
19:32:53 <MarcelineVQ> erisco: + for data Nat = Z | Suc Nat where + : Nat -> Nat -> Nat is written two ways, via recursion on the left argument or on the right argument.   "<erisco> I am just looking for a good equational reasoning example"   map f . map g = map (f . g)  is a more compelling equational reasoning example though
19:37:41 <MarcelineVQ> actually I wonder if that's even a valid example, since the difference is the choice of how to do induction in the first place
19:37:59 <MarcelineVQ> Could get a little messy showing the intermediate steps/lemmas
20:28:24 * hackage assumpta-core 0.1.0.2 - Core functionality for an SMTP client  https://hackage.haskell.org/package/assumpta-core-0.1.0.2 (phlummox)
22:28:24 * hackage assumpta 0.1.0.0 - An SMTP client library  https://hackage.haskell.org/package/assumpta-0.1.0.0 (phlummox)
22:54:54 * hackage hanabi-dealer 0.4.0.1 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.4.0.1 (SusumuKatayama)
23:53:53 <dminuoso> lortabac: So it turns out, that the most convenient way to construct this cyclic data structure is by doing it in two stages. First I keep some `... res_id :: Int, res :: IORef Res`, I saturate all those IORefs with bottom at first.
23:54:48 <dminuoso> And then when the entire data structure is finished, I traverse over the whole thing mutating the rest in place.
