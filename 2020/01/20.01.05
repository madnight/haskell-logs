00:00:19 <iqubic> This should work, but I'm not sure I like it. http://dpaste.com/18BEH0Q
00:00:23 <Ailrun[m]> it shadows the otherwise in the base library, and it's just a variable pattern and nothing else.
00:01:15 <iqubic> My code does work, it's just not the cleanest I feel.
00:01:33 <iqubic> Also, writing "IO(Int)" is making me twitch.
00:01:35 <MarcelineVQ> iqubic: or to conserve space,    case (`elem`[1,2,3]) <$> input of Just True -> ...; Nothing -> ...
00:01:50 <day> iqubic: yeah i dont quite get that one either. why isnt it 'Int'?
00:02:01 <iqubic> MarcelineVQ: Sure.
00:02:09 <Ailrun[m]> <day "iqubic: yeah i dont quite get th"> I think pattern guard makes yout code better,
00:02:33 <Ailrun[m]> oh, sorry, I was trying to mention iqubic
00:02:41 <iqubic> day: Because getLine is of type IO String, so that forces your whole function to be in IO.
00:03:02 <day> iqubic: but the function will never exit until it is capable of returning 'Int' :|
00:03:08 <iqubic> Once one part of your function uses IO, it requires everthing to be IO.
00:03:41 <iqubic> day: I know. But it's still doing IO, and in haskell you have to explicitly document that in the types.
00:03:49 <day> i see
00:04:31 <iqubic> If you use any amount of IO in a function, however little, then the whole function has to be of type "IO a" for some type "a".
00:04:54 <Ailrun[m]> like "Just x | x `elem` [1,2,3] -> ..."
00:05:09 <iqubic> Ailrun[m]: That works too.
00:06:12 <iqubic> splits xs = zip (inits xs) (tails xs) is a very powerful function.
00:06:15 <day> Ailrun[m]: thanks. i was missing the `elem` :)
00:06:46 <day> damn this io function took me hours to make q.q
00:07:04 <MarcelineVQ> day: consider   Just 1 -> return 1   instead of   return $ (\(Just x) -> x) maybeInput  :>
00:07:13 <iqubic> IO in Haskell is unlike IO in any other language.
00:08:43 <iqubic> MarcelineVQ: Something like this? http://dpaste.com/0BPAAEQ
00:09:41 <Ailrun[m]> Ye, as MarcelineVQ said, using Just 1 -> return 1 (or similar) would be better than using a uni pattern
00:10:11 <MarcelineVQ> I like Ailrun[m]'s the most :>
00:10:15 <iqubic> The latest version of this that I just posted does that.
00:10:54 <Ailrun[m]> or like http://dpaste.com/0KDBTF0
00:11:28 <iqubic> Ailrun[m]: What happens if maybeInput == Just 10?
00:11:34 <iqubic> How does that case work?
00:11:53 <Ailrun[m]> it goes to the next pattern
00:11:58 <day> then the 'else' triggers
00:12:00 <Ailrun[m]> _
00:12:29 <day> wouldnt for 10 the 'Just x' case trigger?
00:12:32 <iqubic> Right. That makes sense.
00:12:36 <iqubic> day: It would.
00:13:22 <iqubic> But than in the Just 10 case, x == 10 and you'd fail the "x `elem` [1,2,3]" check, and go to the _ case anyways.
00:13:23 <MarcelineVQ> both guards and cases fall through to the next pattern on failure
00:13:55 <iqubic> Yeah. I even used that fact yesterday in a piece of code I was writing.
00:14:17 <dsal> day: Curious what the importance of 1..3 is in that example.
00:14:57 <Ailrun[m]> just like this
00:14:58 <Ailrun[m]> > case Just 2 of { Just x | x == 1 -> 0; _ -> 1 }
00:15:00 <lambdabot>  1
00:15:35 <iqubic> dsal: I assume this function is being embedded into a larger program. But even still, I don't like hardcoded values in any sort of function.
00:16:08 <dsal> It might mean something.  Finding that meaning would make things clearer.
00:16:17 <iqubic> Yes indeed.
00:16:26 <Ailrun[m]> Agreed
00:17:54 <dsal> In any case, separating the concerns a bit would help.  The bulk of this function is using readMaybe to verify input, but then deciding that input needs further verification before looping.  Just do that all at once in pure code.
00:18:06 <iqubic> dsal: I went back and did the JS puzzle from AoC 2015 with explicit recursion (I.E. not letting Lens do it for me) and it wasn't too bad.
00:18:42 <iqubic> And it's barely anymore code than the Lens version was.
00:19:09 <dsal> Good, that seems like it'd be pretty straightforward.  I need to learn more lens stuff, though.
00:19:48 <iqubic> Yeah. I know that Chris Penner's new book is quite good. I've read it and highly recommend it.
00:20:47 <dbpq> tdammers: when you mention the paid haskell book, were you talking about the one that the bot gives when you ask it for the haskell book
00:21:51 <dbpq> as in haskellbook.com
00:22:09 <dbpq> I'm thinking of buying it
00:22:33 <dbpq> or did you mean "real world haskell". I'd rather not read a book from 2008 I think
00:23:05 <iqubic> Real World Haskell is horribly out of date. Do not read that ever.
00:23:27 <dsal> dbpq: haskellbook is pretty good
00:23:49 <dsal> There are worse things to read than RWH.
00:24:01 <dbpq> yeah i started reading it, I like the idea of how it's a programming newbies journey to learning haskell as a first language
00:24:10 <dbpq> all their philosophies sound pretty solid
00:24:16 <dbpq> I'm thinking of buying it
00:24:48 <dbpq> I just got the pirated copy to see if I like it
00:27:03 <dsal> day: Consider separating the validation from the IO bits. https://www.irccloud.com/pastebin/1LhAG0ZV/getInt.hs
00:31:04 <MarcelineVQ> please don't say to never read real world haskell, it's old but it's not without value
00:39:15 <Ailrun[m]> Yes, I would say even if it is outdated, it's still quite good for post-newbie users, who are able to learn valuable insight among outdated information.
01:40:23 * hackage joint 0.1.3 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.3 (iokasimovmt)
01:44:00 <day> does this code work for someone on linux? https://pastebin.com/raw/rH0CTCB7 It is in regard to this well aged bug report https://gitlab.haskell.org/ghc/ghc/issues/2189
01:44:58 <day> the bug report kind of makes it sounds that it doesn't work on windows, but is supposed to run on linux. read input from stdin with NoBuffering
01:46:17 <aplainzetakind> Pertaining to RWH, I saw this the other day: ttps://github.com/tssm/up-to-date-real-world-haskell
01:46:32 <aplainzetakind> Haven't looked into it yet though.
01:46:58 <i12321> "abcdef" "aaaaaa" how to get all the sequences like this? length is 6, optional characters are a to z
01:50:07 <MarcelineVQ> day: it works here, in ghci on arch linux, though I do get a handle error when I hit esc for some reason     <stdin>: hGetChar: illegal operation (handle is semi-closed)
01:50:25 <day> :/ but why. i have to press enter
01:50:42 <day> i tried another lib called haskeline, and i get the same result
01:51:41 <MarcelineVQ> are you on windows?
01:51:46 <day> no i am on arch too
01:53:45 <MarcelineVQ> ah hmm. All​I did was save your file and load it in ghci and typed   main     pressing any character echos it immediately, in additon to the terminal echoing of it, so pressing a on the keybaord shows aa  and esc quits main with that error
01:54:28 <day> i see. i didnt use the function in ghci, i just started the executable. that may  be the difference
01:55:31 <MarcelineVQ> alright, yes once compiled it does seem to require hitting enter
01:55:48 <MarcelineVQ> except for ESC which doesn't
01:56:52 <aplainzetakind> > let letters = (: []) <$> ['a'..'c'] in foldl1 (liftA2 (++)) $ replicate 3 letters
01:56:53 <MarcelineVQ> day: seems to be about output
01:56:54 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
01:56:58 <MarcelineVQ> set stdout to no buffering
01:57:21 <aplainzetakind> i12321: Replace 'c' with 'z' and 3 with 6.
01:57:58 <MarcelineVQ> day: set them both to no buffering I mean
01:58:59 <MarcelineVQ> it's acceping your char one at a time but isn't printing them immediately. you can show this by typing a bunch then hitting esc, it'll dupliate them as it exits
01:59:47 <day> i12321: https://pastebin.com/raw/qZxsvJ8j heres one that doesnt require a Dr. :D
02:02:24 <day> MarcelineVQ: that was it! thanks a lot
02:02:25 <aplainzetakind> day: That returns tuples of Chars and not strings though.
02:03:21 <aplainzetakind> day: Actually it returns nothing as it stands, as an IO (), I mean if you took the actual work out of IO.
02:03:33 <iqubic> aplainzetakind: Yes, but you can change it to [x,y,z] and it because a list of strings.
02:04:04 <MarcelineVQ> i12321: can you give a slightly longer example of what you're after?
02:04:43 <day> is (x:y:z:[]) synonymous with [x,y,z] as the result of that looks like [String] when i print it :/
02:04:52 <iqubic> Yes. It is.
02:05:17 <iqubic> in fact, [x,y,z] is just syntactic sugar for (x:y:z:[])/
02:05:49 <aplainzetakind> iqubic: Still, it is prone to becaming a huge hassle if you ever decide to change the length of the output..
02:05:59 <aplainzetakind> s/becaming/becoming
02:06:40 <iqubic> Of course.
02:06:51 <MarcelineVQ> suspect we're looking for  replicateM 6 ['a' .. 'z']  but a better example output could confirm
02:07:51 <iqubic> I actually just did this sort of thing the other day, for this puzzle: https://adventofcode.com/2015/day/11
02:08:23 <iqubic> Where replicateM 6 ['a' .. 'z'] would have worked.
02:23:57 <i12321> aplainzetakind ok
02:25:27 <i12321> MarcelineVQ 6^26 sequences, by abcdef, aabcde, aaabcd,... zzzzzz
02:26:21 <i12321> 26^6
02:35:59 <phanimahesh[m]> 26 independent choices made 6 times. 26^6
02:37:06 <i12321> right
02:56:25 <i12321> why foldl1 (liftA2 (++)) sixL not same as foldl1 . liftA2 <> $ sixL
03:09:58 <dminuoso_> i12321: The operator <> must be placed in parens.
03:10:21 <dminuoso_> % :t foldl1 (liftA2 (++))
03:10:21 <yahb> dminuoso_: (Foldable t, Applicative f) => t (f [a]) -> f [a]
03:10:23 <dminuoso_> % :t foldl1 (liftA2 (<>))
03:10:23 <yahb> dminuoso_: (Foldable t, Applicative f, Semigroup c) => t (f c) -> f c
03:11:09 <dminuoso_> The latter one is more polymorphic, but it can monomorphize to the first one
03:11:41 <dminuoso_> Because (++) is the implementation of (<>) for the `instance Semigroup [a]`
03:14:51 <i12321> liftA2 (<>) need two parameters, but why put it into foldl1?
03:15:13 <dminuoso_> % :t foldl1
03:15:14 <yahb> dminuoso_: Foldable t => (a -> a -> a) -> t a -> a
03:15:40 <dminuoso_> i12321: So the first argument to `foldl1` must be a function of the shape `a -> a -> a` for some choice of a.
03:15:53 <dminuoso_> i12321: That is, it must be a function that takes two arguments of the same type, and returns a result of the same type
03:15:55 <i12321> @let letters = (:[]) <$> ['a'..'z']
03:15:56 <lambdabot>  .L.hs:162:1: error:
03:15:56 <lambdabot>      Multiple declarations of ‘letters’
03:15:56 <lambdabot>      Declared at: .L.hs:160:1
03:16:01 <i12321> @let sixL = replicate 6 letters
03:16:01 <dminuoso_> i12321: Does that so far make sense?
03:16:02 <lambdabot>  .L.hs:162:1: error:
03:16:02 <lambdabot>      Multiple declarations of ‘sixL’
03:16:02 <lambdabot>      Declared at: .L.hs:161:1
03:17:42 <i12321> based on the type, it's right
03:18:04 <dminuoso_> % :t liftA2 (<>)
03:18:04 <yahb> dminuoso_: (Applicative f, Semigroup c) => f c -> f c -> f c
03:18:44 <i12321> > foldl1 (liftA2 (<>)) sixL
03:18:46 <lambdabot>  ["aaaaaa","aaaaab","aaaaac","aaaaad","aaaaae","aaaaaf","aaaaag","aaaaah","aa...
03:19:50 <juri_> hey, nomewhat dumb question, i'm using stateT with IO, but the routine i'm using it with performs no IO. is there a less priviledged monadic state i should combine with?
03:20:10 <i12321> this can be done with <*> and <$>?
03:20:10 <merijn> juri_: State (i.e. StateT s Identity)
03:20:41 <merijn> juri_: Identity being the Identity (aka most boring) monad
03:20:46 <MarcelineVQ>  i12321  yes liftA2 can be defined via <$> and <*>
03:21:06 <dminuoso_> juri_: You can also chose to write it polymorphic over MonadState
03:21:43 <dminuoso_> juri_: That is a different approach that gains "less privileged" by a promise to work with any type of monad.
03:21:45 <i12321> MarcelineVQ can foldl1 be replaced here?
03:23:21 <merijn> i12321: Sure, just use "pure mempty" as identity element with fold
03:24:07 <merijn> Or, alternatively
03:24:15 <merijn> :t getAp . foldMap Ap
03:24:17 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Ap f a)) => t (f a) -> f a
03:24:29 <merijn> That's...a horrific type signature lambdabot
03:24:33 <merijn> % :t getAp . foldMap Ap
03:24:34 <yahb> merijn: forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Ap f a)) => t (f a) -> f a
03:24:37 <merijn> ugh
03:25:03 <dminuoso_> % :set -XNoPolyKinds
03:25:03 <yahb> dminuoso_: 
03:25:08 <dminuoso_> % :t getAp . foldMap Ap
03:25:08 <yahb> dminuoso_: (Foldable t, Applicative f, Monoid a) => t (f a) -> f a
03:25:11 <dminuoso_> merijn: ^-
03:25:46 <merijn> Yeah, that's the sensible signature I wanted
03:26:07 <merijn> i12321: ^^
03:26:49 <asheshambasta> fellow users of brittany: as I understand, brittany currently doesn't support some newer Haskell extensions correct? In my case, Brittany seems to be failing for modules with the `DerivingVia` extension enabled: ```brittany version 0.11.0.0```
03:32:10 <asheshambasta> never mind, it works with the newer versions, my bad. 
03:33:56 <juri_> merijn: thanks. that was easy. :)
03:34:04 <zincy_> with postgres-simple how can I write a query where an update only updates the Just fields based on a product type with a bunch of Maybes
03:34:05 <zincy_> ?
03:34:29 <zincy_> Any example links would be great
03:37:44 <dminuoso_> zincy_: https://gist.github.com/dminuoso/cf08ef768da79f75572026dd2493ca7b
03:40:13 <dminuoso_> zincy_: So the postgres-simple is just an update on *all* fields
03:40:56 <dminuoso_> So I'd start a transaction, grab the current record, apply my patch in which every field is wrapped with Maybe, and then write back the entire record
03:41:15 <dminuoso_> It's much simpler to get right than trying to identify which fields have changed and constructing an appropriate update statement
03:41:34 <merijn> Can't you just update the record to it's current value IFF the argument is NULL?
03:42:43 <merijn> Like "UPDATE Foo SET bar = ifnull(?, bar)"
03:43:05 <merijn> (ifnull is an sqlite function returning the first non-null value, I assume postgres has something similar)
03:43:09 <dminuoso_> merijn: If you have 15 fields this will scale poorly
03:43:17 <merijn> How so?
03:43:25 <dminuoso_> merijn: Do you want to issue 15 such statements?
03:43:37 <merijn> You can just do all in one go?
03:44:56 <merijn> UPDATE Foo SET bar = ifnull(?, bar), baz = ifnull(?, baz), quux = ifnull(?, quux)
03:45:00 <merijn> I don't see the problem?
03:45:47 <merijn> The point is that you just make the query text independent of the number of updates and just pass NULL for values you don't touch
03:46:18 <dminuoso_> Oh
03:46:32 <fog> like a tree with empty leafs?
03:46:36 <merijn> Then you don't have to bother dynamically generating your query text
03:46:45 <dminuoso_> merijn: well you can use COALESCE which gives you the same functionality
03:47:41 <fog> but then it would have to search everywhere for a matching key, instead of knowing where to find it
03:48:20 <dminuoso_> merijn: Or my technique gets the same job done as well. I mean whether I update single fields or update the entire row and implement the "updating logic" in Haskell makes no difference
03:48:52 <fog> thats like using fmap to get at all the leafs, not using the information that there should be exactly one match
03:49:37 <dminuoso_> merijn: Either way, its silly to argue about this. Both solutions are perfectly adequate
03:50:08 <fog> couldnt there be a function that returns the position to navigate to from the key instead?
03:50:14 <merijn> The dynamic query generating parts of my code are the parts that I like the least in terms of maintenance, tbh
03:51:53 <fog> yeah, seems like this function would have to be changed if the tree was reordered
03:52:46 <fog> still not sure if there is any advantage of using a tree instead of an array
03:53:06 <fog> maybe if it was stored distributed over several machines
03:55:07 <fog> then it shouldnt matter what position in a list of branches the address of the machine was
03:55:34 <fog> but that this would basically correspond to a different navigation instruction
03:56:17 <fog> i wonder if all the different equivalent configurations are just permuting the order of the branches at each level
03:57:27 <fog> but then, if there are cyclic references to encode neighboring edges, these location instructions would also have to be updated
03:58:46 <fog> like if a machine went offline, and a backup server was used, but it had been idle during reorderings
03:59:05 <zincy_> dminuoso_: awesome thanks!
03:59:52 <zincy_> dminuoso_: Is it sensible to just default to PUTs which is simpler as you just force the client to give you all the fields upfront?
04:00:09 <dminuoso_> PUT?
04:00:23 <zincy_> yeah
04:00:25 <dminuoso_> Huh?
04:00:33 <zincy_> The http verb
04:00:46 <dminuoso_> What do HTTP verbs have to do with databases?
04:01:22 <day> still trying to get this 'no stdin buffering input' code to work. It does work once now,  but as soon as i use the function twice things crash with `hGetContents: illegal operation (handle is semi-closed)` https://pastebin.com/hQfMc7TS
04:02:02 <zincy_> dminuoso_: They influence the way in which you read and write to the db if you are trying to follow REST
04:02:19 <dminuoso_> zincy_: HTTP verbs refer to the abstract resources represented by URIs.
04:02:23 <dminuoso_> zincy_: They are highly abstract concept.
04:02:32 <dminuoso_> How you map that to the database is implementation details
04:03:06 <dminuoso_> zincy_: All the semanitics are not with respect to what you actually do under the hood, but with what you can observe using the HTTP verbs on the resources behind the URIs.
04:03:08 <zincy_> ah right I thought they had a close representation
04:04:54 <day> the haskell user guide for ghci mentions 'after using getContents, I cant use stdin, until I do :load or :reload" ... But how does that translate to actual programs?
04:10:39 <zincy_> I just realised I have been doing APIs very badly
04:11:08 <zincy_> I guess the whole point of an API is to abstract the resources from the implemenation
04:12:27 <fog> right, but the implementation of an API, eg via a class instance - still needs to be implemented effeciently
04:14:15 <fog> and normally the API is standardised, eg we just want to do updates and access, or maybe some functionality provided by common tools like sql - so the focus is normally on the implementation
04:15:32 <fog> actual API design considerations are rare, and its more to do with what functionality the user demands, which isnt a technical issue, more like a shifting ven diagram intersecting the common requirements from various industrial users
04:16:21 <fog> and if more complex queries can be built from simple operations, then these form the basic API 
04:16:59 <fog> ie, just focusing on update and access speeds over trees or arrays depending on the hardware
04:18:33 <fog> not sure if maybe there is a setting where eg, building a row update from individual value updates could be slower for some reason
04:19:24 <fog> and then i guess the API choice is governed by these design choices to do with efficiency
04:20:28 <fog> i guess you could make some kind of virtual hardware layer so you could simulate eg dynamic latency from a distributed resource
04:22:24 <__monty__> Kind of like how the GoF loves eating monadic burritos, fog?
04:22:31 <fog> then like, if you had a bunch of tail calls where each value was on a different high latency machine, it would make more sense to do something like an MPI gather operation than getting each value accessed to then call for the tail in a recursion
04:23:44 <fog> monty: the squad?
04:26:07 <fog> oh, you mean this; https://www.journaldev.com/31902/gangs-of-four-gof-design-patterns
04:26:18 <fog> yeah, i think we are talking about "bridge"
04:26:42 <fog> and my point is that depending on implementation details this might not be the best approach 
04:27:57 <fog> sorry, i got confused because people keep talking about AoC
04:28:54 * hackage streaming-commons 0.2.1.2 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.2.1.2 (MichaelSnoyman)
04:30:11 <fog> not sure what it means about a factory to generate instances...
04:30:31 <fog> maybe its some OOP thing
04:31:06 <fog> what an "object instance" ?
04:32:03 <Rembane> It is an oop thing 
04:32:23 <Rembane> You have a class, you instantiate it and you get an object. 
04:33:58 <fog> ok so a class could be like, circle or something, and a factory would produce circle objects with different radiuses
04:34:28 <fog> i guess we have datatypes instead, and we would just map the datatype constructor
04:35:14 <fog> or if you just wanted something to call to give a stream, you would use the church encoding...
04:35:54 <fog> hmm maybe thats not the best way to call the argument passed to unfold
04:36:57 <fog> so then an abstract factory would be an argument passed to unfold to create lists of such arguments 
04:37:04 <fog> thats pretty cool
04:37:32 <fog> there was something like that when trying to write unfold instances for nested containers
04:39:00 <fog> like, a depth N abstract factory to unfold a depth N HList... and the varient where the branches have different depths
04:49:51 <p0a> Here we go, studying `stack' once again :)
04:50:59 <Uniaika> p0a: it's utter shite. My new tool “heap” is way better, solves a thousand more problems and has raised $10M in seed series to bring blockchain and AI to your haskell builds, in real-time!!
04:51:24 <madnight> Is there an example for a sum type that is representable?
04:51:27 <MarcelineVQ> jokes are only jokes when both parties are in on them :>
04:52:34 <p0a> Uniaika: k boomer
04:58:16 <Uniaika> p0a: :D
05:12:05 <fog> madnight: whats representable? is a Sum type not just like a HList except with just one constructor taking a singleton index to lookup from the type list?
05:12:58 <fog> where this index is kind of like having many Sum constructors, eg Left, Right
05:13:25 <fog> a nat parametrised sum constructor...
05:22:16 <p0a> so one of the popular things in lisp world is that the configuration files etc are written in lisp 
05:22:29 <p0a> but in haskell it seems this is not the case right? For example, stack uses YAML
05:22:41 <p0a> for configuration files such as stack.yaml
05:22:58 <p0a> in fact I've never heard of yaml before 
05:26:03 <__monty__> YAML is definitely not a "haskell thing". It's fairly popular but not everyone's a fan because it's more complicated than usually necessary. TOML's a simpler similarish format but mainly popular in the Rust community. Dhall is interesting and somewhat haskellish but not very popular yet.
05:27:24 <p0a> __monty__: I'm just suprised that the configuration file is not a haskell type
05:28:14 <__monty__> That's kinda asking for exploitation though.
05:28:41 <p0a> Ah, a security issue. Okay
05:29:30 <merijn> YAML is not a Haskell, thing, but it's kinda terrible, tbh
05:30:10 <merijn> p0a: More importantly, making configuration files Turing complete/flexible is a terrible idea in terms of both maintainability AND security
05:30:16 <maerwald> +1 for toml
05:30:28 <merijn> I hope Dhall takes off
05:30:29 <maerwald> merijn: you mean like nix? ^^
05:30:54 <maerwald> (or porpellor)
05:31:11 <merijn> Dhall seems quite elegant and Tekmo has 1) actually done some research on how to design a language based on theory, rather than random made up junk, and 2) seems quite elegant and well thought out
05:31:17 <p0a> merijn: I was imagining something like ConfFile = [[String]]. This is the most basic thing I could ever come up with, but I'm just saying
05:31:26 <merijn> maerwald: I don't know Nix, tbh
05:31:45 <jackdk> amazing how often #1 pays off, huh
05:31:49 <merijn> p0a: Right, but then it's not really Haskell anymore :)
05:32:07 <maerwald> .ini format is amazing too
05:32:14 <merijn> jackdk: Well, more so "amazing how often things that get popular inevitably end up sucking due to lack of 1"
05:32:29 <merijn> .ini is quite nice, albeit limited
05:32:39 <jackdk> merijn: not wrong
05:33:45 * MarcelineVQ adds a tick to the ini column
05:34:19 <__monty__> I do like rc files for "powertools", like vim. Being limited in your customization just to avoid the risk of code execution isn't always nice.
05:34:26 <p0a> so json is out of the question?
05:34:34 <MarcelineVQ> What's the question?
05:34:49 <p0a> for configuration files for stack etc
05:34:53 <merijn> I don't like JSON, but "at least it's better than yaml" :p
05:35:10 <__monty__> Isn't JSON a valid subset of YAML?
05:35:21 <__monty__> Or like, close enough?
05:35:39 <maerwald> __monty__: I'm starting to disagree. I'd rather change the actual source code and recompile the package if I need that much of customization. But then the code would need to have some sensible architecture
05:36:17 <maerwald> like having two levels of configuration: source code level and configuration level
05:36:35 <maerwald> mixing both is awkward
05:36:36 <__monty__> I wouldn't trust myself to know the ins and outs of all the tools I use. Especially for ones as complicated as vim and emacs.
05:36:42 <merijn> maerwald: "It Depends"
05:37:23 <merijn> On the application and how it's supposed to be used
05:38:00 <merijn> My favourite go to example of "Really Cool Use" of full blown programming as configuration is the WoW user interface, which IMO an underrated technical marvel
05:38:36 <p0a> so my plan to mak ea website in haskell is this: 1) learn git 2) learn stack 3) configure emacs for haskell 4) read on Haskell modules 5) start hacking with happstack
05:38:54 <p0a> seems sensible? I am already past 1) into 2) although I will go back to 1) to learn about branches later
05:39:09 <p0a> there's probably more steps after 5) but it's too far ahead to think about
05:39:25 <maerwald> never tried happstack
05:39:32 <qiao2> never heard of using haskell for web development, why not use elm or something?
05:39:46 <maerwald> qiao2: for backend?
05:39:48 <merijn> I prefer cabal-install over stack, but otherwise seems sensible enough
05:40:22 <maerwald> stack is mainly useful for solving deployment issues these days
05:40:43 <maerwald> if cabal freeze files don't suffice for you for some reason
05:41:00 <qiao2> maerwald: oh i didnt think of that, i was thinking frontend
05:41:07 <qiao2> coool 
05:41:12 <maerwald> qiao2: I agree, I wouldn't use haskell for frontend
05:41:33 <maerwald> frontend needs much faster iterations and better tooling
05:41:39 <p0a> qiao2: what's elm? I have a few reasons for using Haskell: I tried clisp and there's outdated tutorials online; the language is fun.
05:41:57 <MarcelineVQ> Yes, so let's avoid doing frontend so that it continues to need better tooling
05:42:15 <maerwald> That's like saying let's try to fix the gaming industry with haskell :>
05:42:33 <maerwald> haskell is good at backend currently, frontend solutions are somewhat heavy
05:42:38 <MarcelineVQ> I'd prefer to have it be like saying let's try to fix our own projects.
05:42:57 <ytrog[m]> I find stack vs cabal vs nix so confusing 😣
05:43:04 <maerwald> No reason to let newcomers trying to achieve something fall into the trap of being pioneers on unchartered territory
05:43:20 <p0a> Although frontend/backend I'm not familiar with as terminology, I am planning to have a haskell server with javascript
05:43:23 <MarcelineVQ> Wouldn't want new blood on old problems :>
05:43:38 <p0a> so the javascript will make the website fancy and haskell will be managing credentials,logins etc
05:43:49 <ytrog[m]> Ow
05:43:53 <p0a> Does that sound stupid?
05:44:15 * p0a knows very little of what they're doing...
05:44:19 <ytrog[m]> Maybe you would like Elm for the website instead
05:44:23 <ytrog[m]> Or purescript
05:44:35 <maerwald> ytrog[m]: nix: reproducibility, stack: set of curated packages and automatic ghc installation, cabal-install: original build tool best suited for development
05:45:02 <p0a> elm: a language for data visualization? Looks weird
05:45:16 <p0a> oh it's one of the messages 
05:45:41 <maerwald> elm is a safe choice, because it tries hard to allow javascript developers to switch over. Purescript doesn't, so may require more learning
05:46:10 <ytrog[m]> Yeah elm seems easiet
05:46:13 <p0a> Oh nice, so what does elm require?
05:46:15 <ytrog[m]> *easier
05:46:27 <ytrog[m]> Elm requires Elm
05:46:31 <p0a> I mean the browsers support it or does the user see javascript?
05:46:39 <qiao2> p0a: only tried a basic tutorial a few years ago so i cant explain anything about it, just seems like a pretty cool functinoal language for web development
05:46:42 <ytrog[m]> The latter
05:47:05 <p0a> and can you use elm together with a database?
05:47:08 <qiao2> no you dont write JS as far as i remember, it compiles to it though i think
05:47:12 <p0a> for the `backend' I believe is the term
05:47:44 <ytrog[m]> Just make rest services using Haskell
05:48:08 <ytrog[m]> And connect to that with elm
05:48:15 <merijn> p0a: I know at least one commercial website that's using mostly Haskell for the backend (and the non-haskell bits use the even more obscure Ur/Web language :p)
05:48:49 <p0a> so elm is just literally to avoid using javascript
05:48:55 <merijn> p0a: Yes
05:48:59 <p0a> and haskell is still needed for communicating with databases
05:49:02 <qiao2> i heard facebook is using haskell for some parts of its backend for optimizing searching for users or something
05:49:10 <p0a> But why bother avoiding javascript? It's not too bad
05:49:27 <__monty__> merijn: Hmm, that's kinda weird. I thought Ur/web was supposed to serve both front- and backend?
05:49:44 <ytrog[m]> It is very loosely typed
05:49:53 <p0a> That's true but I don't mind
05:50:01 <merijn> qiao2: Haxl is the stuff you're referring to, it's used for optimising complex queries (used heavily by the spam detection)
05:50:13 <ytrog[m]> Easy to make ludicrous mistakes in js
05:50:16 <merijn> __monty__: Real websites need more backend than just "the bits that render pages" :)
05:50:36 <p0a> I've written some JS before and lots of C so I don't mind
05:50:37 <merijn> __monty__: And Ur/Web is mostly optimised for the "bits that render pages"
05:50:53 <maerwald> p0a: then maybe typescript is better for your project
05:50:58 <__monty__> merijn: And this is not bazqux?
05:51:00 <ytrog[m]> Also elm pioneered functional reactive programming
05:51:16 <__monty__> And has since pretty much completely abandoned FRP : )
05:51:17 <merijn> __monty__: Of course it is, I don't think anyone else uses Ur/Web commercially >.>
05:51:38 <__monty__> Didn't know they used haskell.
05:51:48 <merijn> __monty__: Ur/Web isn't really about FRP, though?
05:51:54 <ytrog[m]> p0a: what draws you to haskell?
05:51:59 <__monty__> That was a comment about elm.
05:52:00 <merijn> __monty__: Well, they need to concurrently scrape all the RSS feeds
05:52:11 <merijn> __monty__: That part is mostly Haskell, afaik
05:52:33 <qiao2> merijn: ah that looks pretty cool
05:52:37 <ytrog[m]> monty: has it?
05:52:49 <p0a> ytrog[m]: 1. active community (contrast to common lisp), 2. neat language 3. there's talent so probably if my website is good I could hire someone
05:53:20 <merijn> __monty__: So the site is almost entirely Ur/Web, but Haskell for all the cron like scraping jobs
05:53:34 <merijn> __monty__: Or, at least it was the last time I saw him talk about it
05:53:38 <p0a> I will keep typescript in mind; it lies after my `fifth' step so I am not worried about it currently
05:53:38 <maerwald> p0a: you want to hire haskellers? :>
05:53:55 <p0a> maerwald: `if the website goes well' sure. I mean, if I actually make money out of it
05:54:00 <ytrog[m]> Hmm for concurrent scraping I would use Erlang
05:54:43 <merijn> __monty__: I would argue Elm never was FRP to begin with, it was "event driven architecture", which is, like, missing 95% of the point of FRP
05:55:14 <maerwald> like react?
05:55:36 <__monty__> I'm not really clear on what the point of FRP is, tbh.
05:56:16 <merijn> react is "reactive" in the JS sense of the word (i.e. event driven), then some JS people saw "functional reactive programming" and went "well, this is now our term", despite having no relation to the original meaning
05:57:07 <merijn> __monty__: The point of FRP is "making it easier to write and reason about code with (time) continuous behaviour"
05:57:21 <maerwald> event driven architecture is cool, but sometimes it's also tremendously hard to reason about your stuff, because when you look at your code, you're only looking at the surface, not the logic
05:58:19 <merijn> __monty__: I assume you'r familiar with stuff like delta-stepping (in for example, games) where you update the world according to some delta of time passed each frame?
05:58:21 <maerwald> and although stuff is well-defined, it can be hard to follow how things interact
05:59:04 <ytrog[m]> Well that's software
05:59:13 <maerwald> nah
05:59:58 <ytrog[m]> I always struggled with complexity. That's why I won't code professionally anymore
06:00:12 <__monty__> merijn: Not past what you just said. And I remember we've had this exchange before. Not sure why it didn't stick.
06:00:41 <merijn> __monty__: My current favourite way of thinking/talking about FRP is "delta-invariant" i.e. the ability to compose timestepping code that operates on different timesteps
06:01:11 <merijn> __monty__: Could be
06:01:11 <maerwald> That's not what I meant. You're inverting the architecture. Instead of expressing interaction, you express behavior based on events. For some things, that makes it harder to follow what's going on.
06:01:30 <ytrog[m]> I was the only one in the office continuously using paper pads for making notes and diagrams as I was always lost in complexity
06:01:37 <ytrog[m]> Never again tyvm
06:02:00 <merijn> Anyway, conal has already said that, in hindsight, he should've used a different name from FRP
06:02:16 <__monty__> ytrog[m]: Sounds like you may have been the only person in the office who actually grokked the complexities of the project.
06:02:43 <p0a> so I'm reading this https://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies
06:02:49 <p0a> where supposedly we're adding Text to our project
06:02:55 <ytrog[m]> Nah I have mental problems
06:03:06 <p0a> but `someFunc = T.putStrLn "someFunc"' shouldn't work right? 
06:03:08 <maerwald> We all have :)
06:03:15 <ytrog[m]> Probably on disabilities soon. Will know in a month
06:03:20 <p0a> instead it shoudl be `somefunc = T.putStrLn $ pack "someFunc"'
06:03:46 <MarcelineVQ> p0a: {-# LANGUAGE OverloadedStrings #-} is allowing the use
06:04:17 <ytrog[m]> Software is fun as long as there are no expectations. Otherwise it is a one way street towards a burnout
06:04:34 <p0a> MarcelineVQ: okay, thank you. I don't know why I missed that!
06:04:36 <ytrog[m]> Imho
06:05:57 <p0a> ytrog[m]: well failure is acceptable really, I mean, we're just working to get the $$$ not to burn outselves out
06:06:00 <maerwald> ytrog[m]: I believe in the theory that programmers usually lean either towards intuitional logic or analytical logic and IME people leaning towards analytical logic tend to over-emphasise on structure and details and have trouble "keeping up" on feature pressure.
06:06:00 <maerwald> But you need both types in a healthy team.
06:06:53 <__monty__> What's intuitional logic? Sounds suspiciously like intuitionistic logic.
06:07:07 <maerwald> __monty__: when you only care about the essence of a problem, not its structure
06:07:44 <maerwald> analytical thinkers would decompose the structure to get to the solution instead
06:08:00 <__monty__> Sounds like moralizing tech debt.
06:08:06 <maerwald> it's also said that this exists in maths
06:08:52 <ytrog[m]> <ytrog[m] "Software is fun as long as there"> I am indeed very much into structure and extremely slow creating features
06:08:54 * hackage statistics 0.15.2.0 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.15.2.0 (AlexeyKhudyakov)
06:08:58 <maerwald> __monty__: what?=
06:09:27 <ytrog[m]> Why did I reply like that? 🤔
06:09:35 <ytrog[m]> Riot is weird sometimes
06:09:53 <maerwald> ytrog[m]: IME, those are good properties of a reviewer
06:10:04 <maerwald> But in todays agile, we don't need reviews :)
06:10:13 <maerwald> we need deployments
06:10:19 <p0a> rush
06:10:29 <ytrog[m]> I like reviewing ^^
06:10:44 <ytrog[m]> But executive dysfunction sucks
06:10:46 <p0a> A good read is EAs wives. Has anyone read that?
06:10:59 <ytrog[m]> Heard about it
06:11:08 <ytrog[m]> Was very yikes
06:11:28 <p0a> https://ea-spouse.livejournal.com/274.html it was about burnout in a videogame team
06:11:43 <maerwald> well, video game dev is hard 
06:11:57 <merijn> s/hard/abusive
06:12:00 <maerwald> I dated an EA developer once^^
06:12:18 <maerwald> quite a weird company
06:12:38 <ytrog[m]> Once was the only time they were available? :p
06:12:40 <maerwald> But apparently they made progress with accepting women
06:13:13 <merijn> Let's not kid ourselves, game dev is toxic for the same reason lots of Silicon Valley is toxic. Multi-billion companies abusing youth, optimism, and enthusiasm of young programmers and aggressively exploiting it for money
06:13:22 <maerwald> yeah
06:14:13 <merijn> Actually, add academia to that list. The universities themselves aren't multi-billion companies, but Elsevier's billion plus annual profit certainly is
06:14:20 <ytrog[m]> Software dev companies are running on workaholism
06:14:25 <p0a> well we might've taken a dark turn here 
06:14:45 <p0a> but I was trying to offer solace to ytrog[m] 
06:14:50 <maerwald> It's 2020, time for dark future predictions
06:14:52 <merijn> p0a: Naah, the optimistic message is: Everyone here should work to unionise ;)
06:15:09 <maerwald> merijn: I was thinking about opening a coding monastery once^^
06:15:30 <ytrog[m]> I am a union member
06:15:33 <ytrog[m]> FNV
06:16:37 <int-e> maerwald: . o O ( transcribing emacs source code day in, day out )
06:16:52 <maerwald> lol
06:17:25 <ytrog[m]> Lol
06:17:42 <i12321> actually foldl1 = reduce, right? not foldl
06:17:43 <merijn> Anyway, I should stop procrastinating the revision of my paper >.>
06:18:09 <ytrog[m]> Oh holy RMS 🙏
06:19:26 <ytrog[m]> I'm at my sister's birthday party 🙉
06:22:12 <Clint> does she know?
06:23:20 <ytrog[m]> Yeah
06:23:52 <ytrog[m]> But I don't like the talking
06:24:28 <ytrog[m]> Too much stimuli
06:37:27 <p0a> it's kind of impressive how stack works. There's a lot of bandwidth involved 
06:40:40 <[exa]> merijn: btw did you notice that elsevier seems to be kindof falling apart? all E journals I heard about recently have "unidentified organization problems" causing delays and everything
06:46:26 <merijn> [exa]: Good, I hope they go bankrupt
06:47:47 <[exa]> I personally hope they will burn visibly, but that'd be too optimistic
06:51:34 <[exa]> (I kindof became fan of the F1000 publishing model, open reviews are great. Hope something similar could appear in computer science; F1000 is now roughly 50% various minor results in medicine screening and 50% bioinformatics)
07:13:24 * hackage tasty-rerun 1.1.17 - Rerun only tests which failed in a previous test run  https://hackage.haskell.org/package/tasty-rerun-1.1.17 (Bodigrim)
07:35:37 <perrier-jouet> hi all
07:36:11 <perrier-jouet> I am on archlinux and installed ghcup from haskell platform, but ghcup ghc nor ghcup GHC works
07:36:36 <perrier-jouet> in the tutorial it says install ghc and cabal-install with ghcup
07:37:54 * hackage knead 0.4.2 - Repa-like array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.4.2 (HenningThielemann)
07:39:13 <[exa]> perrier-jouet: what's the error message when it "does not work" ?
07:39:31 <jojoz[m]> perrier-jouet: 
07:39:50 <jojoz[m]>  * perrier-jouet: Also, from where did you install it? The aur-package ghcup-git?
07:40:21 <oats> getConf :: Getter a Config -> BotIO a
07:40:31 <oats> Why is ghc telling me that 'Getter a Config` is an illegal polymorphic type?
07:40:58 <perrier-jouet> jojoz[m]:from https://www.haskell.org/ghcup/
07:42:49 <oats> (I really like how that page directly rips off of rustup :P)
07:42:57 <oats> rust does a lot of things well
07:43:51 <[exa]> oats: do you know there's a 'forall' hidden in the getter?
07:44:05 <jojoz[m]> perrier-jouet: See [exa]'s more important question "what's the error message when it "does not work" ?", in case you missed it
07:44:29 <oats> [exa]: the 'forall f.'?
07:45:18 <[exa]> oats: regarding whateverup, I really hope that the people will re-learn unix packaging in near future and such dirty install scripts won't be necessary
07:45:39 <oats> fair enough :)
07:45:51 <oats> [exa]: I'm not sure I understand, why's the forall f. holding me up?
07:45:55 <[exa]> oats: regarding the polymorphism, does the error message say something more explicit?
07:46:21 <oats> [exa]: https://paste.xinu.at/NnAgb
07:46:21 <[exa]> oats: I'm not sure that you can declare the type just so, without e.g. allowing RankNTypes in your module explicitly
07:46:33 <oats> ah yeah, RankNTypes
07:46:36 <[exa]> y e a h
07:46:39 <oats> guess I'll just enable that :P
07:58:54 * hackage llvm-ffi 9.0.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-9.0.0 (HenningThielemann)
08:02:59 <maerwald> [exa]: I don't see that improving any time soon
08:11:54 * hackage llvm-tf 9.0 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-9.0 (HenningThielemann)
08:16:24 * hackage llvm-extra 0.9 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.9 (HenningThielemann)
08:17:58 <statusfailed> Data.Binary seems to be super slow when I do `replicateM n get` for large n; should I be using something other than replicateM?
08:18:05 <statusfailed> For some reason it doesn't seem to happen lazily
08:18:22 <statusfailed> (large ~= 50M)
08:20:08 <statusfailed> wait i'm dumb
08:20:10 <statusfailed> I should just use get
08:20:14 <statusfailed> nevermind!
08:29:24 * hackage llvm-extension 0.0 - Processor specific intrinsics for the llvm interface  https://hackage.haskell.org/package/llvm-extension-0.0 (HenningThielemann)
08:31:43 <glguy> statusfailed: binary reports errors, it doesn't parse lazily
08:33:31 <statusfailed> glguy: oh, so I can't lazily read a file and take only the first few items?
08:37:24 <aveltras> i'd like to implement some kind of simple session store supporting operations like set, has, get, etc.. behind a string key as is commonly found in other languages like php. Im thinking of using a Map Text Dynamic, are there other common way of tackling this problem ?
08:39:39 <[exa]> aveltras: why not store a nice precise session type? duck-keyed session stores are sooooo 1990
08:41:47 <aveltras> [exa]: i guess the session type would become pretty big for any decently sized app no ?
08:43:22 <merijn> aveltras: How does Dynamic reduce the size?
08:43:32 <merijn> You don't get to magically store less data
08:43:44 <aveltras> i dont mean size in memory but size of the datatype
08:43:52 <madnight> fog: I mean how would you implement the representable instance for e.g. the sum type Maybe?
08:44:43 <merijn> aveltras: So?
08:45:37 <aveltras> do you mean having a big product type with many Maybe fields ? i might have not understood
08:47:26 <[exa]> aveltras: that might work. Also, chances are that if you need to transport N data in the nice type, you will also need to transport the same N in the string-keyed type, additionally with the string keys
08:53:38 <merijn> aveltras: Why do you expect to have so many different session types?
08:54:36 <glguy> if I was going to do a dynamically typed session thing I might use something like this: https://gist.github.com/glguy/11a7583b2086de74237a4ebbad736e8a
08:54:53 <glguy> and then create a newtype for each thing I wanted to store in the session to avoid having to manage the string-based key namespace
08:55:44 <merijn> Or, hear me out, a crazy idea. We only store a session id and just dump everything else in a database!
08:56:10 <merijn> And then each relevant codepath just queries the database for what it needs
08:56:24 <Rembane> And use SQLite! 
08:56:51 <merijn> Rembane: Well, yes, if the counter argument is "I don't want to maintain a postgres install" then SQLite is the next answer :p
08:56:59 <Rembane> merijn: ^^
08:57:33 <aveltras> the end goal is to have this session store as a thin layer over redis, so i thought that having nearly the same api (put, set, etc) would be nice
08:57:41 <merijn> Honestly, at this point I'm just going to stuff SQLite in anything that remotely warrants it :p
08:57:55 <aveltras> Map Text Dynamic would map to a redis hash here
09:03:26 <aveltras> glguy: thanks for your example, seems a bit better indeed
09:03:54 <ryantrinkle> is there a way to turn off the thing where GHC will proceed to typechecking even if there are variables that aren't in scope?
09:04:05 <ryantrinkle> i'm not sure what that's called
09:05:01 <oats> ryantrinkle: -fdefer-type-errors ?
09:05:03 <oats> https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/defer-type-errors.html
09:05:34 <ryantrinkle> oats: i'm looking for something more like the opposite of that
09:05:36 <merijn> ryantrinkle: I think so, but I'll be damned what it is
09:05:46 <oats> uh
09:05:52 <oats> -fnodefer-type-errors ? :P
09:05:54 <ryantrinkle> in old versions of GHC, if a name couldn't be resolved, the compiler would just stop
09:06:28 <ryantrinkle> since 8.something, it seems to just say "well, let's assume it is a thing with some type" and then start inferring stuff
09:06:38 <ryantrinkle> but now with type applications, it seems to *actually lose* the "error: name not found"
09:08:04 <merijn> ryantrinkle: Initially any name starting with an underscore was a typed hole, but at some point they indeed started treating any name that's not in scope as a hole, so you'd wanna go over the hole related warnings/errors to find out how to control that
09:08:32 <merijn> ryantrinkle: Ah, wait
09:08:47 <merijn> ryantrinkle: You probably want -Wno-deferred-out-of-scope-variables
09:08:54 <merijn> Or something along those lines
09:10:01 <merijn> ryantrinkle: Should be off by default, though
09:10:33 <ryantrinkle> merijn: yeah, just saw that; turning it off doesn't seem to have any effect
09:10:55 <ryantrinkle> i think the issue is that, even though it's an error, it's not a *fatal* error - which makes sense
09:10:58 <merijn> ryantrinkle: Which version of GHC?
09:11:23 <ryantrinkle> 8.6.5
09:11:48 <merijn> ryantrinkle: Odd, because that works fine for me? Lemme double check
09:11:55 <ryantrinkle> it's not really that big of a deal, but it definitely screws up the "fix the first type error first" workflow
09:12:13 <ryantrinkle> just to be clear, it *is* correctly reporting it as an error
09:12:21 <ryantrinkle> it just gets buried, and sometimes seems to get totally lost
09:12:45 <ryantrinkle> this is 100% a quality-of-life issue i'm running into, not a correctness issue
09:13:17 <merijn> ryantrinkle: Ah, then it's really just "we decided to try and type check more things in the presence of errors so we can report more issues in one pass"
09:14:07 <merijn> ryantrinkle: If the issue is "the error gets buried" you might wanna consider the great new addition of "-freverse-errors"?
09:14:34 <ryantrinkle> ah interesting
09:14:38 <ryantrinkle> yeah that might help
09:14:43 <ryantrinkle> it *does* look like sometimes it gets totally lost
09:14:51 <ryantrinkle> just grepped through the output and there's no mention of "Variable"
09:14:56 <ryantrinkle> lemme see if I can figure out when that happens
09:15:23 <ryantrinkle> ok, it's when you do something like: f = z @_
09:15:46 <ryantrinkle>     • Cannot apply expression of type ‘t1’
09:15:46 <ryantrinkle>       to a visible type argument ‘_’
09:15:53 <ryantrinkle> but nothing about "Variable not in scope"
09:15:59 <ryantrinkle> (for 'z')
09:17:10 <merijn> Ah, so maybe type applications borks things?
09:20:24 <ryantrinkle> merijn: yup, would seem so :)
09:22:45 <merijn> Score one more, for my heuristic of "don't use type applications" :p
09:31:27 <ryantrinkle> merijn: haha well, i have unfortunately written a bunch of code that does not infer very well
09:31:41 <ryantrinkle> i'd like to improve that, but it's not gonna be quick or easy :P
09:53:17 <madnight> is it possible to enable language extensions for the lambdabot in this channel?
09:56:45 <geekosaur> to some extent, I think?
09:57:05 <hpc> i think yahb can
09:57:13 <geekosaur> although hm, probably not at that, they'd have to go in its special prelude
09:57:31 <geekosaur> yahb accepts :set -Xwhatever
09:57:47 <geekosaur> no way to do that with LB, it's not ghci
10:49:00 <oats> should I be using Alternative if I want to model "trying multiple Applicative things in order until one of them fails"?
10:49:10 <oats> just want to make sure I don't misuse this
10:55:06 <hpc> Alternative more does the opposite
10:55:18 <hpc> > Just 5 <|> Just 6
10:55:20 <lambdabot>  Just 5
10:55:26 <hpc> > Nothing <|> Just 6
10:55:28 <lambdabot>  Just 6
10:56:21 <hpc> perhaps you want something more like (*>) or sequenceA
11:01:27 <merijn> Eh
11:01:29 <merijn> :t asum
11:01:32 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
11:01:40 <merijn> Oh wait, that's the opposite, I guess
11:02:42 <[exa]> oats: First is a monoid, could work for you
11:03:41 <merijn> Not quite either
11:03:53 <merijn> I think this is basically a matter of "write something yourself"
11:04:02 <[exa]> he will need to reverse the failing
11:04:57 <[exa]> the worst problem is how to find which thing of those has failed then
11:06:00 <[exa]> i.e. what should be taken out as the "return" value
11:06:28 <[exa]> b/c then it reduces to either Const or Either
11:11:20 <Lears> % sequenceAlt [] = pure []; sequenceAlt (x:xs) = ((:) <$> x <*> sequenceAlt xs) <|> pure []
11:11:21 <yahb> Lears: 
11:11:27 <Lears> % sequenceAlt [Just 3, Just 4, Nothing, Just 6]
11:11:27 <yahb> Lears: Just [3,4]
11:11:35 <Lears> Something like that.
11:12:17 <oats> hmm
11:12:47 <oats> if it makes any difference, I'm in a (StateT s IO) monad stack
11:12:54 <oats> so there's effecty stuff going on
11:13:22 <merijn> You could use optional + something from monad-loops
11:17:48 <oats> oh shoot
11:17:58 <oats> I messed up my original question lol
11:18:01 <oats> *until one succeeds
11:18:04 <oats> not fails :<
11:18:14 <merijn> oats: Oh, then it's ust asum
11:18:16 <merijn> :t asum
11:18:18 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
11:18:32 <merijn> asum [Nothing, Nothing, Just 1, Nothing, Just 2]
11:18:33 <oats> yeah, I'm on the right path then
11:18:35 <merijn> > asum [Nothing, Nothing, Just 1, Nothing, Just 2]
11:18:37 <oats> sorry for misleading :P
11:18:37 <lambdabot>  Just 1
11:40:53 <maerwald> anyone tried waymonad? does it have title bar icons?
11:42:22 <__monty__> I think someone said it was abandoned a couple days back?
11:55:52 <dsal> Is that a monad for self driving cars?
11:56:01 <steve> Hello, how do I convert  [IO Int] -> [Int]
11:56:09 <dsal> steve: that's not a thing.
11:56:17 <dsal> You can make it IO [Int], though.
11:57:07 <iqubic> Yeah, it's not possible to write a function of type "IO a -> a"
11:57:07 <steve> if I have this:    let z = return 3 :: IO Int     , how do I evaluate z+1  and get 4?
11:57:53 <dsal> steve: You're mixing up effects and computations.  IO Int is not the same concept as Int
11:58:08 <dsal> You can add 1 to the IO Int and get another IO Int
11:59:07 <dsal> IO Int is a recipe to make an Int.  It's not an Int on its own.  You can shove computations into IO to change what it is that the recipe creates, though.
11:59:15 <dsal> What are you trying to do?  That might make things easier.
11:59:25 <oats> :t sequence (pure <$> [1,2,3] :: [IO Int])
11:59:27 <lambdabot> IO [Int]
11:59:56 <merijn> @quote list.of.files
11:59:56 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:00:14 <iqubic> I love that so much.
12:00:37 <oats> that's a pretty good analogy, I like that
12:01:08 <merijn> steve: The answer is "You can't get '4'" you can, however, get an IO action that produces 4
12:02:44 <merijn> steve: If you consider "foo :: IO Int" as "an IO action that produces (for example from your code) '3'" then the question is "how do I turn that into an IO action that produces something else than 3?" then the answer is either: 1) fmap (if you just want to apply a function like (+1)) or 2) >>= (if you want to do some other IO based on the result)
12:03:06 <oats> steve: could you elaborate on what you're trying to achieve?
12:03:24 <merijn> There's also Applicative, which corresponds to "what if I want to apply a function to multiple things that are produced via IO"
12:03:29 <steve> I can :    do a <- z ; a+1    and it prints 4.  and, :t a  is Int
12:04:01 <merijn> steve: This is why I generally recommend avoiding do notation for beginners until they're comfortable with writing the same using >>=
12:04:17 <geekosaur> ghci is going to confuse you here
12:04:25 <dsal> steve: depending on what z is, that doesn't have anything to do with IO.
12:04:56 <merijn> steve: "do { a <- z; a + 1 }" is a type error, but if you meant "do { a <- z; print (a + 1) }" then you're right, but that do notation is merely sugar for "z >> = \a -> print (a + 1)"
12:05:09 <steve> that's what I'm trying to learn now hah.  I'll try to make an example
12:05:19 <geekosaur> merijn, you can do that in ghci
12:05:21 <merijn> steve: i.e. that corresponds to me point 2 from before of using >>= :)
12:05:44 <merijn> geekosaur: Oh, if you type them one by one, you mean?
12:05:49 <merijn> That's because ghci is all lies
12:06:21 <oats> lol
12:06:23 <merijn> I liked ghci better as tool for beginners when it was more aggressively incompatible with "regular code" to avoid this confusion
12:06:38 <merijn> (The current state is nicer for experts, but more confusing for beginners)
12:07:08 <oats> ghci is a weird mix of expression evaluator and IO executor
12:07:24 <merijn> steve: Basically, ghci does some hacky stuff which boils down to interpreting every line independently while also pretending it's do notation for IO
12:07:44 <merijn> % do { a <- return 3; a + 1 } :: IO Int
12:07:44 <yahb> merijn: ; <interactive>:112:18: error:; * No instance for (Num (IO Int)) arising from the literal `3'; * In the first argument of `return', namely `3'; In a stmt of a 'do' block: a <- return 3; In the expression:; do a <- return 3; a + 1 ::; IO Int
12:07:46 <oats> (makes prototyping nice though, if you know what you're doing)
12:08:00 <merijn> % do { a <- return 3; print (a + 1) } :: IO ()
12:08:00 <yahb> merijn: 4
12:08:20 <merijn> Notice the complaint that "a + 1" doesn't have type "IO Int"
12:08:29 <oats> ^ that's console output though, not a expression evaluated
12:08:39 <oats> (just trying to clarify)
12:08:55 <geekosaur> yeh, I was playing locally and iit doesn't actually work even split to separate lines, at least with the do
12:10:48 <geekosaur> so I'm not sure what he was talking about now unless he was synthesizing what he thought was going on (which, ghci, sigh)
12:14:17 <steve> preferred pastebin here?
12:15:03 <merijn> I think the official recommendation is gists since the death of lpaste (*sad sigh*) or some random one that's not full of ads and JS :p
12:16:18 <[exa]> is the lpaste source code online?
12:16:23 <[exa]> somewhere
12:16:31 <steve> https://gist.github.com/bootladder/f1d0ca3c75cff7465f24b1f87abe6fbb
12:18:09 <oats> steve: pro-tip: print = putStrLn . show
12:18:20 <merijn> [exa]: It should be, if not you can always email Chris Done
12:18:59 <merijn> steve: You probably want sequence
12:19:02 <merijn> :t sequence
12:19:04 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
12:19:08 <merijn> Or, probably even better
12:19:23 <merijn> :t traverse -- i.e. "traverse doStuff [1,2]"
12:19:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:19:45 <merijn> :t traverse `asAppliedTo` [] -- i.e. "traverse doStuff [1,2]"
12:19:47 <lambdabot> error:
12:19:47 <lambdabot>     • Couldn't match expected type ‘a -> f b’ with actual type ‘[a0]’
12:19:47 <lambdabot>     • In the second argument of ‘asAppliedTo’, namely ‘[]’
12:19:53 <merijn> oh, wait
12:20:07 <oats> @let doStuff input = (+1) . read <$> getLine
12:20:08 <merijn> I guess I wanted that on the second argument
12:20:09 <lambdabot>  Defined.
12:20:23 <oats> > traverse doStuff [1,2]
12:20:26 <lambdabot>  <IO [Integer]>
12:20:33 <merijn> oats: lambdabot doesn't do IO ;)
12:20:40 <oats> yeah yeah
12:20:43 <merijn> :t traverse doStuff `asAppliedTo` []
12:20:45 <lambdabot> (Num b, Read b) => [p] -> IO [b]
12:21:27 <dsal> steve: Short answer is sequence will turn your [IO Int] into an   IO [Int]    Then you can    myList <- sequence z
12:21:32 <merijn> steve: So like "myList <- traverse doStuff [1,2]; print (sum myList)"
12:22:10 <dsal> traverse is nice here, but it's one step further.  You can basically think of traverse as monadic map.
12:23:04 <fendor> > traverse (\x -> guard (x > 2) >> Just x) [1..5]
12:23:06 <merijn> Applicative map ;)
12:23:07 <lambdabot>  Nothing
12:23:16 <steve> I tried to do mapM , couldn't get it.  Is there a way?
12:23:16 <fendor> > traverse (\x -> guard (x > 2) >> Just x) [3..5]
12:23:19 <lambdabot>  Just [3,4,5]
12:23:35 <oats> mapM is equivalent to traverse, right?
12:23:42 <merijn> steve: "mapM doStuff" is basically "traverse doStuff" (for hysterical raisins)
12:23:49 <merijn> oats: traverse is more general, but yes
12:23:58 <oats> oh, right
12:24:25 <steve> hmm, trying more
12:24:31 <merijn> steve: "mapM doStuff [1,2]" should work (but you might need to import mapM first? I forget if it's in Prelude)
12:24:59 <pablo[m]3> heyo peeps
12:25:13 <steve> oh, I was trying to do mapM z
12:25:36 <steve> mapM (\o -> do o) z
12:25:39 <oats> steve: I think this is most likely what you want https://paste.xinu.at/aQJMWe/hs
12:26:17 <merijn> :t mapM
12:26:19 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:26:32 <merijn> steve: Note the function as first argument
12:26:50 <fendor> > filterM (\ x -> [True, False]) [1..4]
12:26:53 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
12:26:56 <merijn> steve: if you want to write it list first, lambda second then there's for/forM
12:26:58 <merijn> :t for
12:27:00 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
12:27:14 <merijn> for is basically traverse with the arguments reversed
12:27:16 <oats> fendor: huh, that's cool
12:27:41 <fendor> oats, yeah, it ia :) powersets of a list.
12:27:44 <fendor> *is
12:27:47 <phadej> @src for
12:27:48 <lambdabot> Source not found. I am sorry.
12:27:49 <phadej> :(
12:28:01 <oats> fendor: that's some quality haskell poetry there
12:28:16 <oats> well, impressionist poetry :P
12:28:23 <merijn> phadej: for is not in Prelude, thus not in the report and  not in @src ;)
12:28:35 <phadej> :t for
12:28:36 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
12:28:41 <phadej> but that works ^
12:28:56 <merijn> phadej: Because lambdabot imports WAAAAY more than just Prelude
12:29:01 <merijn> :t view
12:29:03 <lambdabot> MonadReader s m => Getting a s a -> m a
12:29:06 <phadej> yeah (but still not enough :)
12:29:13 <phadej> would be nice if 
12:29:14 <phadej> :doc view
12:29:19 <pablo[m]3> heyo peeps
12:29:23 <pablo[m]3> hey peeps. is the a typeclass for mapping error values? for example, i'd like an operator that takes a `a -> b` and maps an `Either a c` to an `Eithet b c`
12:29:27 <phadej> worked, as it does in recent GHC
12:29:28 <merijn> phadej: @src is just a "Map String String", though
12:29:51 <merijn> pablo[m]3: For Either specifically there's Bifunctor
12:29:52 <phadej> merijn: yeah, but it would cool if it would actually look up the def somehow :)
12:30:04 <glguy> phadej: how recent if a GHC is needed?
12:30:04 <merijn> :t Data.Bifunctor.first
12:30:06 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
12:30:24 <merijn> > Data.Bifunctor.first even (Left 2)
12:30:27 <lambdabot>  error:
12:30:27 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
12:30:27 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
12:30:31 <merijn> aww
12:30:34 <phadej> glguy: 8.6 is enough
12:30:42 <phadej> Prelude> :doc maybe The 'maybe' function takes a default value, a function, and a 'Maybe'
12:30:42 <glguy> Neat
12:30:45 <phadej> ....
12:31:14 <merijn> steve: If you mix for with lambda you can basically write foreach-loop style code ;)
12:31:29 <phadej> glguy: it's the result of 2018? GSoC iirc
12:31:34 <phadej> s/the/a/
12:31:50 <phadej> "Hi Haddock!"
12:32:10 <phadej> it's nice that students are motivated to work on tooling :)
12:32:40 <phadej> https://sjakobi.github.io/blog/2018/08/14/hi-haddock-3/
12:32:47 <fendor> phadej, well they get some ects or money out of it ;D 
12:34:15 <steve> ok that helped a lot, I will have to practice.  Thanks everybody!
12:34:17 <phadej> not much though
12:34:46 <fendor> i got like half a semester
12:35:06 <fendor> of uni credits
12:37:06 <merijn> steve: I can also highly recommend readin the wikibook on how do notation's syntactic sugar works and trying to write unsugared code for a while instead
12:37:09 <merijn> steve: https://en.wikibooks.org/wiki/Haskell/do_notation
12:37:17 <phadej> (not much at least for Finland, CS students can get more money (and same uni credits) for writing android apps, e.g.)
12:37:36 <merijn> steve: Do notation is amazing for readability, but it's important to understand what goes on "underneath" to understand when things work and when/why they don't
12:38:52 <steve> merjin: will do thanks
12:44:38 <pablo[m]3> <merijn "@pablo: For Either specifically "> thanks! thats what i was looking for
12:45:23 <pablo[m]3> sorry for the duplicated messages, my matrix clint is not having a good day apparently
12:46:06 <merijn> pablo[m]3: You can actually generalise Functor, Bifunctor, etc. to N-functors, but Haskell's typeclass system and type system have no real way to express that, and I don't think anyone has defined a Trifunctor class and above :p
12:48:07 <phadej> I have written triverse somewhere (and though I need quadverse), but maybe once in past two-three years
12:48:49 <phadej> (Cabal codebase has one "Triversable" type)
12:51:26 <madnight> @src mapM_
12:51:26 <lambdabot> mapM_ f as = sequence_ (map f as)
12:55:16 <madnight> @src forever
12:55:16 <lambdabot> forever a = let a' = a >> a' in a'
12:59:35 <solonarv> I vaguely recall seeing an arbitrary-arity functor typeclass somewhere
12:59:41 <solonarv> using fancy type-level stuff
12:59:53 <solonarv> it could also encode co/contravariance information
13:00:39 <EvanR> don't you technically only need unofunctor and bifunctor
13:01:16 <EvanR> tuple to get more functors
13:01:59 <phadej> yes, in CT there's just one "functor", and co/contra bi/... are all constructed by varying src/tgt categories
13:02:04 <phadej> C^op, C x D, etc.
13:02:20 <solonarv> but regular old Haskell tuples are not general enough to encode that
13:02:45 <solonarv> especially because you can't do something like data Foo '(a, b) = MkFoo a a b
13:03:11 <phadej> with GADT you can (but you probably shouldn't)
13:03:21 <solonarv> well, I guess you could have a huge pile of type families to get at the tuple fields
13:03:35 <solonarv> like so: data Foo ab = MkFoo (Fst ab) (Fst ab) (Snd ab)
13:03:51 <solonarv> but that seems pretty terrible as well
13:04:12 <solonarv> it is also of course very inconvenient to partially apply
13:04:42 <phadej> "until" one gets type level functions :P
13:04:55 <solonarv> yes, those would help
13:05:01 <dolio> In CT they have the human brain figuring out the overloading, which is much more convenient than doing it in Haskell's type system.
13:05:36 <solonarv> oh, I found it!
13:05:39 <solonarv> https://hackage.haskell.org/package/n-ary-functor-0.1.0.0/docs/NAryFunctor.html
13:05:55 <phadej> dolio: yes and no; I think mathematicians abuse notation way more then they should
13:07:00 <solonarv> hm, this one doesn't seem to leave any room for contravariance
13:16:24 * hackage mmsyn7ukr 0.5.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.5.0.0 (OleksandrZhabenko)
13:17:24 * hackage urbit-hob 0.3.1 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.3.1 (JaredTobin)
13:17:27 * hackage mmsyn7h 0.3.0.0 - A program and a library that produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.3.0.0 (OleksandrZhabenko)
13:32:15 <fog> is there any way to get this to compile? https://pastebin.com/raw/Pp5awmsH
13:36:55 <fog> i cant tell why it wont evaluate those type familes
13:38:12 <p0a> Hello a couple question, 1) Does anyone use unicode in haskell? Things like → for -> in source code. 2) is haskell-mode (emacs) good? 3) Do you use Hasktags for tags? 
13:38:40 <oats> I think unicode in haskell source is generally discouraged
13:38:59 <fog> yeah, thats more for languages that use it for autocomplete
13:38:59 <oats> (as far as syntax bits and common operators go)
13:40:26 <[exa]> p0a: 1] yes but it's only good for presentation (sometimes), not good for portability to other people/environments 2] yes, very much 3] I don't use either
13:40:59 <oats> a nice middle ground is using a font with ligatures, if your terminal supports it
13:41:07 <oats> if you just want pretty source :P
13:41:34 <p0a> [exa]: thanks, do you bother with autocompletion? I don't like camelCase
13:41:36 <[exa]> unicode code story: I still don't know how to write the special vector + in Julia in the editor, so I just copypaste it from the interpreter where it magically expands from some shortcut
13:41:46 <p0a> and when I say I don't like it, I mean that I don't like typing it
13:41:50 <[exa]> (luckily I don't have to use julia a lot)
13:43:46 <[exa]> p0a: I never used autocompletion with haskell in fact, there's no good use for it as for e.g. function parameters in Java. The other thing is type-driven program generation (e.g. djinn) and type hints which is much cooler imho
13:44:31 <fog> its more for language that can use type inference to autocomplete types no? and search for functions of some type
13:45:07 <fog> in haskell we end up just copy pasting from what ghci says
13:45:15 <[exa]> :]
13:45:35 <fog> like with typed holes and stuff
13:45:48 <p0a> autocomletion can be useful if you don't want to type some long symbol I believe. Right?
13:46:21 <[exa]> oh for that I have the text-only autocompletion, in vim it's ^p
13:47:30 <oats> ime autocompletion is only really handy in languages with methods
13:47:40 <oats> like obj.something() stuff
13:47:48 <oats> where you want to know really fast what something supports
13:47:55 <p0a> wait so djinn gives you a lambda from a type? I don't quite get what the utility of djinn is
13:48:22 <[exa]> p0a: basically yes, you give it a weird type and it gives you a program that looks reasonable and has that type
13:48:23 <p0a> I'm not talking about what supports what, just being able to complete a symbol
13:48:34 <p0a> [exa]: what is the utility of that?
13:48:34 <[exa]> p0a: what editor do you use?
13:48:37 <p0a> [exa]: emacs
13:48:56 <[exa]> hmeh, I guess it has some built-in alternative for vim's ^p
13:49:18 <p0a> [exa]: what is ^p called in words, if not `autocompletion'? maybe I can look it up
13:49:44 <[exa]> p0a: it's autocompletion, but it doesn't use actual language features, just random tokens from actual file
13:49:56 <[exa]> "random" = whatever looks like the text you're just typing
13:50:41 <MarcelineVQ> "there's things one of the buffers that looks like what you're typing, would like like to insert one of those?"
13:50:48 <MarcelineVQ> *in one of
13:51:25 <[exa]> oats: if 'languages with methods' means C# and Java :] the need for autocompletion is usually driven by poor APIs there that are super-anti-intuitive (have you seen winapi?)
13:51:52 <oats> I have not, fortunately :>
13:52:11 <[exa]> fortunate one, yes.
13:52:17 <p0a> yeah it just occured to me that autocompletion is not as useful when there is no OO involved
13:52:29 <p0a> I mean, object oriented programming
13:53:26 <oats> I've liked it with rust too
13:53:27 <[exa]> common winapi autocompletion trigger: "functions with 15 arguments, ordered historically"
13:53:43 <ricky_clarkson> Rust isn't particularly OO but looks like it would benefit from autocompletion.
13:53:57 <[exa]> rust is verbose in a different way
13:54:03 <fog> if there was enough training data a neural net could do ok
13:54:05 <maerwald> how would you autocomplete servant then without crashing both the auto-completer and the editor? =P
13:54:11 <ricky_clarkson> module::<autocomplete>, variable.<autocomplete>
13:54:36 <[exa]> +1 maerwald
13:54:51 <p0a> [exa]: 14 of them are NULL
13:55:16 <[exa]> p0a: ....and now replace 9th NULL :]
13:55:21 <fog> unless the neural net relies on its approximate representation of you being able to figure out the type error
13:55:53 <fog> knowing me it would just autocomplete it into a huge type error
13:56:44 <[exa]> fog: anyway, how fast is RNN training? like, a button for extracting the next char from RNN could work even for more complicated stuff than identifiers
13:57:38 <fog> like constitutional amendments?
13:58:00 <fog> probably not a good place for type errors...
13:59:32 <fog> exa: more seriously, there is some strong work on towers of approximators that are accelerated learning paths in the space of nets
14:00:09 <fog> its inverse to the process of iterative coarse graining 
14:00:21 <[exa]> interesting
14:00:33 <fog> unless you have autoencoder style bottleneks
14:01:48 <fog> basically, the space of nets is covered more densely by higher complexity nets, so there is a hierarchical partitioning passing from succesivly lower complexity approximators 
14:03:24 * hackage mmsyn7h 0.3.0.1 - A program and a library that produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.3.0.1 (OleksandrZhabenko)
14:03:30 <fog> the terminal object in the training process (universal category?) is the most accurate approximator, and the idea is that you get accelerated learning by taking paths with monotonically increasing complexity
14:04:22 <fog> and then there is some total madness to do with producing such paths which sparsely cover the space
14:04:35 <fog> and approximating the process that produces this, to get a recursion going
14:05:43 <fog> i could make a kickstarter...
14:06:09 <[exa]> man
14:06:26 <fog> le sigh
14:07:06 <dansho_> what does higher complexity mean? kolmogorov complexity?
14:07:12 <fog> bigger nets
14:07:39 <fog> i guess theres a family of measures though
14:08:33 <fog> im thinking "shorter codewords" as these are "close" to some region containing the more dense higher complexity and hence seem to label them
14:08:37 <[exa]> what's the best representation of ASTs for NNs anyway? that would be interesting for guessing and generating just scaffolds for stuff
14:09:43 <fog> one thing thats interesting is using neurons to emulate ram
14:11:23 <fog> there was something to do with lempel-zif complexity being a bad measure of recurrence since a repeated spike train subsequence is a poor measure of similarity of previously observed patterns
14:13:02 <fog> eg. if instead of ram, a subregion of the net was a generative classier trained on some input data (eg. pictures of dogs) then it could generate a picture of a dog and transmit this as a spike train, but a similar net with different training data for its dog memory would produce a different signal
14:13:33 <fog> so you have to have a complex way of measuring similarity of spike trains subsequences
14:14:02 <fog> basically you end up running classifiers on the subnets and the signals which pass between them
14:14:21 <mooch2> hey, i was wondering about maybe learning haskell, but the main type of programs i write are emulators
14:14:34 <mooch2> which require a mutable cpu struct usually
14:14:41 <mooch2> how would you make that work in haskell?
14:16:07 <fendor> Is the author of https://hub.zhox.com/posts/introducing-haskell-dev/ here on irc? I would be interested in their experience with producing hie binaries.
14:16:30 <dsal> mooch2: I did aoc 2019.  Many of the days required you to write an emulator and run programs written for it.
14:16:42 <mooch2> ah
14:16:48 <mooch2> how would you do that in haskell though?
14:16:51 <dsal> I did two implementations of the VM.  One didn't use mutable state.  The other did.
14:16:59 <dsal> Many people did it many different ways.  :)
14:17:05 <mooch2> o.o how do you write an emulator without mutable state???
14:17:25 <dsal> Heh, that was the easier way to do it.
14:17:35 <dsal> The one with mutable state was the tricky one that required me to learn stuff.
14:17:49 <ChaiTRex> mooch2: How do you write a function that returns something other than its argument?
14:18:09 <mooch2> ???
14:18:12 <mooch2> why are you asking me?
14:18:20 <dsal> mooch2: It's restating your question.
14:18:26 <mooch2> uh
14:18:38 <mooch2> i'm used to c and c++ for the most part so :p
14:18:41 <dsal> The program that I run in the VM is a transformation from an initial state to a new state.  It's a function.
14:18:45 <mooch2> i'm just not used to immutability
14:18:55 <mooch2> and i'm used to being able to use structs and stuff
14:19:01 <dsal> It's just like mutability, but with many classes of bugs removed.  :)
14:19:09 <mooch2> dsal, where's your code for that vm implementation?
14:19:21 <dsal> We still have product data types.  :P
14:19:27 <mooch2> wtf is that
14:19:46 <dsal> "structs"
14:19:58 <mooch2> oh
14:20:00 <dsal> mooch2: I wrote this for myself, so I don't know how readable it is:  https://github.com/dustin/aoc2019/blob/master/src/Computer.hs
14:20:03 <ChaiTRex> mooch2: Haskell's data types are a lot like structs. You can take a value into a function and return a new value that has all the changes you want. You didn't change the input, but your output is your input mutated.
14:20:22 <dsal> mooch2: https://github.com/dustin/aoc2019/blob/master/src/Computer.hs#L37-L43 is my VM state.
14:20:58 <mooch2> ...okay i don't get this...
14:21:36 <dsal> It's usually easier to start at the beginning rather than the end.
14:21:50 <dsal> "Can I write the kinds of programs I want?" is a fine question.  The answer is yes.
14:24:24 <oats> that's an unfortunate learning attitude :<
14:24:43 <solonarv> in fact I would say Haskell is pretty great for writing emulators!
14:25:05 <oats> dsal: do you like your stateful or your non-stateful vm implementation better?
14:25:46 <dsal> oats: I learned ST for this, so I liked that.  It's reasonably quick.  I could do better.  I did a pagetable thing that I didn't bother trying to do any improvements on.
14:26:16 <solonarv> dsal: oh heh, I also slapped together a page table
14:26:31 <oats> I'm only on like day 13
14:26:37 <solonarv> I think I linked it here when I did it, actually
14:26:40 <oats> is a pagetable useful later? O.o
14:26:44 <solonarv> oats: oh, that's about when I stopped doing them
14:26:55 <dsal> oats: yeah.  :|
14:27:00 <oats> uh oh
14:27:13 <solonarv> a page table is one way to solve the "programs may now use arbitrary addresses" thing that comes up later
14:27:23 <dsal> Yeah, the one I linked above didn't use a page table.
14:27:46 <solonarv> you could also use some kind of map (e.g. IntMap) as your memory, instead of an array
14:27:56 <dsal> My original implementation was just a Vector.  Then I did MVector.  Then I slapped together the Map thing to solve the arbitrary space issue.
14:28:06 <dsal> Then I did the page table so I could do MVector again.  And now I have two implementations.
14:28:29 <oats> ah, yeah. I just use an IntMap now
14:28:32 <oats> seemed a nice solution
14:28:35 <dsal> Yeah, you're fine then.
14:28:36 <solonarv> yeah you'll be fine
14:28:38 <solonarv> that works
14:28:43 <solonarv> I just felt like being fancy :P
14:28:54 <oats> ^ the curse of haskell
14:28:55 <dsal> I wanted to keep using ST.
14:28:58 <oats> fanciness is contagious
14:29:08 <dsal> Yeah.  You should avoid Fancy Haskell™
14:29:16 <solonarv> it's funny that I went the opposite way
14:29:24 <dsal> Avoid Basic Bits
14:29:25 <solonarv> started with ST, switched to pure
14:29:44 <dsal> I'd never used ST before.
14:30:00 <dsal> It's one of those things I had shelved as like, I know how to do this, but hadn't tried.
14:30:12 * oats is using a ExceptT on a StateT on a Writer for the VM
14:30:26 <dsal> I started doing 2015 and ran into a case where my first solution was kind of slow.  Switched ST and arrays and got a couple order of magnitude speedup.
14:31:03 <solonarv> I am once again baffled that there is no "world's finest imperative language" in lambdabot 's @quote database
14:31:22 <ChaiTRex> dsal: Have you tried vectors?
14:31:25 <oats> haskell is the world's finest imperative programming language
14:31:27 <dsal> Wife's yelling at me go outside and play with my planes and dog since it's beautiful and sunny here...
14:31:35 <dsal> ChaiTRex: Yeah, my first VM thing was just Vector.
14:31:44 <dsal> Now it's MVector.
14:31:55 <dsal> Array was pretty good for this 2015 thing I did, though.
14:32:02 <ChaiTRex> dsal: How was that speedwise compared with array?
14:32:05 <dsal> I like Array, but there are a lot of things I keep wishing it did that it doesn't.
14:32:19 <dsal> Oh, I don't think I've tried array and vector on the same problem.
14:32:26 <ChaiTRex> dsal: Oh, OK.
14:32:27 <dsal> Array is... not very rich.
14:32:47 <solonarv> its main draw is being a boot library and the fancy indexing, I suppose
14:33:00 <solonarv> most of the time I find myself not needing either of those things
14:33:02 <dsal> Yeah, I was using Map before Array because of Ix
14:33:53 <dsal> Ix is a bit of a pain, but is pretty neat in practice.  For day 18, I made a BitSet using Ix to store the character set in a Word32
14:37:26 <aplainzetakind> I used to think bottom means any non-halting computation. I'm reading Conal's Fran paper, and the statement that "\geq -\infty is clearly the bottom element of Time" made me realize something's incomplete in my understanding of bottom.
14:38:28 <aplainzetakind> What exactly is bottom then, in what sense is a value bottom here?
14:38:32 <conal> aplainzetakind: I'm glad you're reconsidering bottom! Nontermination is an operational notion, while bottom is a denotational notion, so they cannot be the same.
14:38:40 <solonarv> it's a more general thing from (semi)lattices
14:39:38 <conal> aplainzetakind: "Bottom" means the bottom of a partial ordering. In the context of meanings of programs, the partial ordering is information content, where bottom means no information.
14:39:40 <aplainzetakind> conal: What is the correspondence that leads to the (apparently so) abuse then?
14:40:01 <solonarv> the ordering in use is "definedness"
14:40:27 <solonarv> (using _ to denote bottom): _ < Just _ < Just 5
14:40:35 <solonarv> also, Just _ < Just 42, and so on
14:40:39 <conal> even "definedness" can be misleading, because bottom is a perfectly well-defined value that contains no information.
14:40:50 <solonarv> (Just 5 and Just 42 are incomparable)
14:41:04 <aplainzetakind> Is Just _ a value?
14:41:37 <conal> aplainzetakind: every computable function is monotonic w.r.t that ordering and is even "continuous" in the sense of monotonic and preserving limits.
14:41:56 <aplainzetakind> Sounds more like a set of values.
14:42:14 <aplainzetakind> Is the partial ordering set inclusion in reverse, in some sense?
14:42:25 <solonarv> yes, "sets of values" is one possible interpretation
14:42:26 <conal> yes, you can think of it as a set as well, with set set of all values (of a given type) being bottom.
14:42:42 <solonarv> the ordering relation is then "is a superset of"
14:43:08 <aplainzetakind> OK, that makes sense.
14:43:35 <aplainzetakind> How come it came to be used to mean non-termination? Total accident or is there some analogy that I'm not seeing?
14:44:06 <MarcelineVQ> if I​ never produce a result you don't get any information, I guess :>
14:44:08 <conal> aplainzetakind: it's not an accident. a computation that hasn't yet terminated hasn't produced any information yet.
14:44:18 <solonarv> another way to look at it is to fill in the blank spots with variable names, then you can use "is a substitution instance of" for ">="
14:44:19 <conal> if it never terminates, it'll never generate any information.
14:44:59 <solonarv> 'Just 5' is a substitution instance of 'Just x', so 'Just 5 >= Just x'
14:45:07 <conal> but information ordering says more than just termination vs nontermination, e.g., (3,_|_).
14:47:01 <conal> aplainzetakind: this information ordering is at the heart of the mathematical meaning ("denotation") of programming languages. For instance, recursion is defined to mean a least fixed-point, where "least" is in the info ordering.
14:48:02 <solonarv> the concrete realization of this "least fixed point" is 'fix', btw
14:49:03 <aplainzetakind> Nice. What should I read for a more organized understanding along these lines?
14:49:20 <conal> Note also that "strict" is defined in terms of this notion of bottom. A function f is strict exactly when _|_ is a fixed point of f, i.e., f _|_ == _|_.
14:50:53 <conal> For this reason, there aren't any genuinely strict, turing-complete, functional programming languages. In such a language, all recursions would yield _|_, since each is a fixed point of a strict function.
14:57:20 <aplainzetakind> conal: Is there a recommended (introductory) textbook on denotational semantics?
14:59:46 <conal> aplainzetakind: I wish I knew what to recommend. There's http://pages.di.unipi.it/corradini/Didattica/PLP-15/DOCS/Tennent-DenotationalSemantics.pdf, which is a classic. 
15:00:30 <conal> aplainzetakind: Most treatments of denotational semantics focus on defining programming languages, and usually imperative ones (historically popular, particularly when DS was invented).
15:01:41 <conal> I find DS to be much more helpful in the context of designing *libraries* for functional programming languages. See https://github.com/conal/talk-2014-lambdajam-denotational-design .
15:03:18 <aplainzetakind> conal: I watched that talk of yours, really illuminating. Thank you for that.
15:03:22 <MarcelineVQ> Denotational Semantics: a methodology for language development   David A. Schmidt  is pretty neat. never did finish it though
15:04:03 <conal> aplainzetakind: :)
15:05:28 <aplainzetakind> MarcelineVQ: Will check, thanks.
15:07:47 <aplainzetakind> I have the inclination to write a music library (which I'm sure would be reinventing the wheel but I didn't even check) starting from something like `data Music = Music (Time -> Sonority)`, which prompted a closer look at the Fran paper.
15:09:30 <conal> Cool. I bet you'll learn a lot in the process. I'm happy to give feedback and answer questions along the way if you'd like.
15:10:33 <aplainzetakind> conal: Thanks, that would be great, once I can clarify what I really intend to express.
15:11:10 <conal> aplainzetakind: great. good luck, and have fun! 
15:11:45 <dolio> conal: That's an interesting argument. How does that work out? Which part isn't really strict?
15:12:08 <dolio> I guess functions `(a -> b) -> a -> b` are not actually required to be strict?
15:12:23 <dolio> Unless they are artificially lifted.
15:12:24 <conal> dolio: usually if-then-else. sometimes additional short-cutting conjunction and disjunction.
15:12:54 * hackage base64 0.1.0.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.1.0.0 (topos)
15:13:07 <conal> which is why one often sees recursive calls inside of a conditional branch. it's not about if-then-else, but rather non-strictness.
15:13:47 <dolio> Well, if could take () -> a arguments instead, but then the non-strictness is probably being pushed to those?
15:14:00 <conal> so I like to call languages like ML "strictifying" rather than "strict".
15:14:13 <conal> (because lambda means abstraction + strictify)
15:14:59 <dolio> I.E. (\() -> ⊥) /= ⊥
15:16:00 <nshepperd2> "strict" languages like C have non-strict binding of functions and conditionals
15:17:00 <dolio> I mean, I know practically most eager languages include some non-strict stuff because it's inconvenient to guard everything by unit lambdas.
15:17:28 <conal> if-then-else *is* a function, but strictifying languages treat it specially. which means one cannot make more such useful tools.
15:17:51 <conal> which breaks composition.
15:18:10 <solonarv> aplainzetakind: 'tidal' looks related
15:18:11 <conal> (anything worth having is worth composing.)
15:20:41 <dolio> Okay, I guess I might have been thinking of something else. My question is then: is it _impossible_ to have a completely strict language? Or just inconvenient?
15:20:52 <solonarv> the ability to define new control structures as plain old library functions is certainly something I miss in other languages
15:21:02 <solonarv> dolio: possible! but then it won't be turing complete
15:22:01 <dolio> What does Turing completeness have to do with it?
15:22:24 <solonarv> what conal said above: in a truly strict language you can't write useful 'fix'
15:22:40 <solonarv> but in any turing complete language, you can write a useful 'fix'
15:22:53 <solonarv> well, I hope that's correct anyway
15:25:17 <conal> dolio: we use general recursion for turing completeness, and recursion is defined via 'fix', which is not useful when all functions are strict (and hence all recursions yield bottom).
15:25:33 <conal> that's the connection i was making.
15:26:47 <dolio> Right, I'm asking what the specific non-strict thing is in that example. Is it the argument to fix that must be non-strict?
15:27:08 <solonarv> yes
15:27:30 <aplainzetakind> solonarv: I took a look at that at some point. I recall that the way it expressed musical entities did not suit me. I will revisit it though.
15:27:53 <conal> yes. for fix f not to be bottom, f would have to be nonstrict.
15:28:30 <solonarv> if the argument 'f' to 'fix' is strict, that means it has _|_ as a fixed point, and since _|_ is the least element, _|_ is in particular the least fixed point of 'f'
15:28:45 <solonarv> so if 'f' is strict, 'fix f' is bottom
15:29:41 <conal> I'd start with the definition of strict, namely having bottom as a fixed point.
15:29:52 <dolio> Yeah. I guess if you want to say things are actually strict, you're forced into the same uglier semantics as with seq.
15:30:27 <nshepperd2> boolean circuits could be interpreted as being a language which is "completely strict"
15:31:08 <dolio> Where there is `\_ -> ⊥` which is apart from ⊥, and `fix` actually gives you the least fixed point above `\_ -> ⊥`, and that isn't required to be preserved.
15:31:12 <conal> nshepperd2: do you mean *combinatorial* boolean circuits?
15:31:38 <conal> sequential circuits rely crucially on nonstrictness.
15:31:43 <orzo> Is there anyway to tell cabal to boycott a library and give tell me which other library wanted it when i do v2-configure?
15:32:16 <solonarv> you should be able to do something like --constraint="bad-library < 0"
15:33:03 <solonarv> but I smell some XY here; why do you want to "boycott" a library?
15:33:58 <nshepperd2> i don't know what sequential circuits are
15:34:01 <dolio> I suppose this is all academic, because most people talking about eager languages tend to reject denotational semantics, maybe because it has to be so much messier to account for all their corner cases. :)
15:34:19 <nshepperd2> i mean a regular circuit with inputs, logic gates and outputs
15:35:32 <EvanR> a sequential logic circuit contains loops that may cause the behavior to have memory
15:35:51 <EvanR> as opposed to combinational logic circuit that basically implements a pure function of the input
15:36:25 <EvanR> xor gate (combinational) vs a flip flop (sequential)
15:37:29 <oats> verilog flashbacks
15:37:31 <nshepperd2> oh
15:40:40 <nshepperd2> yeah, and if there are no loops it's "strict" and obviously not Turing complete
15:52:24 * hackage tree-render-text 0.3.0.0 - Configurable text rendering of trees.  https://hackage.haskell.org/package/tree-render-text-0.3.0.0 (ThomasEding)
15:54:10 <oats> oh that sounds like a fun package
16:06:27 <fendor> how can I write a show instance for an existential data-type wrapper like https://hackage.haskell.org/package/cabal-helper-1.0.0.0/docs/Distribution-Helper.html#t:Ex?
16:08:58 <iqubic> I don't think you can.
16:09:04 <solonarv> indeed, you can't
16:09:24 <iqubic> What happens if K is a data type that doesn't have a Show instance?
16:09:30 <solonarv> well, you can show something unhelpful like "Ex <unknown>"
16:09:55 <iqubic> Right. But that's not very interesting.
16:10:20 <solonarv> oh! actually, if 'forall x. Show (k x)' holds then you can do something useful for 'Show (Ex k)'
16:10:38 <Axman6> show _ = "Ex <Ha! Proof I do exist, but what am I?>"
16:10:58 <solonarv> but there is absolutely no way to figure out what type 'x' is, or get at its 'Show' instance (if one exists)
16:11:08 <Axman6> show _ = "Ex <I am not bottom, therefore I am>"
16:11:34 <fendor> :(
16:11:37 <solonarv> not in general, that is - for some choices of 'a' it could be done
16:13:04 <solonarv> basically the best you can do is: instance (forall x. Show (a x)) => Show (Ex a) where showsPrec p (Ex ax) = parens (p>10) $ showString "Ex " . showsPrec 11 ax
16:14:17 <fendor> oh wow. With QuantifiedConstraints?
16:15:04 <solonarv> yep
16:15:30 <solonarv> obviously 'forall x. Show (a x)' does not hold for most choices of 'a'
16:17:04 <fendor> ok, looks actually easy enough
16:17:27 <fendor> I dont know if I would have thought about it myself, but not that terrible
16:17:38 <iqubic> solonarv: I can't think of an 'a' for which it doesn't hold.
16:17:46 <solonarv> iqubic: really? give me an example
16:17:59 <solonarv> wait no, I can give you one
16:18:06 <iqubic> Let a :: [b].
16:18:11 <solonarv> kind error
16:18:17 <iqubic> It is?
16:18:21 <solonarv> pick 'a ~ Maybe'
16:18:25 <iqubic> Sure.
16:18:31 <solonarv> now 'forall x. Show (Maybe x)' doesn't hold
16:18:36 <iqubic> Why not?
16:18:53 <solonarv> what if I pick 'x ~ (Int -> Char)'?
16:18:57 <iqubic> Oh. Right.
16:19:07 <solonarv> there is no 'Show x =>' antecedent
16:19:11 <solonarv> that's what makes it so hard
16:19:12 <iqubic> So are there any that pass?
16:19:18 <solonarv> sure
16:19:26 <solonarv> Proxy works, for a boring example
16:19:34 <iqubic> because you can always chose 'x ~ (Int -> Char)'
16:20:09 <solonarv> instance Show (Proxy a) where show _ = "Proxy" -- see, no 'Show a =>' antecedent
16:20:15 <iqubic> But Proxy works because of the phantom type.
16:20:20 <solonarv> yes
16:20:32 <solonarv> another example of things-that-work are GADTs
16:21:08 <solonarv> for example: data IntOrChar :: Type -> Type where AnInt :: Int -> IntOrChar Int; AChar :: Char -> IntOrChar Char
16:22:15 <solonarv> or even: data MustBeShowable :: Type -> Type where ShowableThing :: Show a => a -> MustBeShowable a
16:23:28 <fendor> compiler is still not happy, seemingly :(
16:24:14 <oats> you must sacrifice a covariant goat
16:25:01 <fendor> Or I just sacrifice some code succinctness 
16:26:54 * hackage DAV 1.3.4 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.3.4 (ClintAdams)
16:49:08 <ysangkok> i have a function that takes two arguments of type Kleisli (ExceptT String (ReaderT PrimEnv (Either String))) () () and CommitmentRoot a b. when applying the function, those two arguments are always literally identical, but their values of course not, since they do not have the same types
16:49:29 <ysangkok> how can i avoid repeating myself when applying this function?
16:49:56 <solonarv> if they don't have the same types, what does it mean for them to be "literally identical"?
16:50:03 <solonarv> (perhaps an example would help)
16:50:06 <iqubic> type synonyms are your friend
16:50:26 <ysangkok> i think it is just the monomorphism restriction
16:51:07 * Axman6 thinks that type synonyms are rarely your friend
16:51:25 <ysangkok> ypes based on context
16:51:52 <ysangkok> solonarv: because of type classes. i repeat myself, but first time, another instance is used than second time
16:52:34 <ysangkok> like, i could have a funciton a:: Int -> Rational -> () and those two arguments could be 1 and 1, which would be literally equal, but not semantically
16:54:36 <solonarv> I see
16:54:58 <solonarv> well, you can certainly pull this out into a 'let' or 'where' binding
16:55:22 <solonarv> you just need to give a type signature to not run into the monomorphism restrictio
16:55:36 <ysangkok> ok, i guess i have to come up with that manually
16:56:22 <solonarv> you might be able to ask ghc what the inferred type is by using foo :: _ as the type signature
16:57:45 <ysangkok> yeah i thought i could do that, but it doesn't compile if i make those two arguments into one
16:58:52 <solonarv> no, I mean actually pull this duplicated argument out into a 'let' and give it a type signature
16:59:02 <solonarv> but use '_' as the type signature
16:59:25 <solonarv> let foo :: _; foo = some complicated nonsense in twoArgFunction foo foo
16:59:29 <solonarv> did you do that?
17:01:52 <ysangkok> how is that different from putting an underscore in the type signature of twoArgFunction?
17:03:39 <ysangkok> anyway, i did do what you suggest, which is using a let binding on the calling side to avoid repeating myself. but of course the monomorphism restriction kicks in, the foo is inferred to have the type of the first argument and the second doesn't fit anymore
17:04:03 <ysangkok> but i wouldn't really say it qualifies as avoiding repeating myself though :P 
17:04:56 <ysangkok> it is so surprising because i had really internalized all this equaltional reasoning but when you suddenly can't do it anymore, it is really surprising :O 
17:09:27 <solonarv> can you please post your actual code, instead of describing it?
17:13:46 <ysangkok> solonarv: https://github.com/ysangkok/simplicity/blob/noinput/Main.hs
17:14:37 <ysangkok> solonarv: the two last arguments of spendUTXOWith
17:16:02 <solonarv> okay, just to be clear: this code that you linked is failing?
17:16:45 <ysangkok> yeah, not compiling right now because of monomorphism restriction
17:16:57 <ysangkok> and type wildcard
17:17:15 <MarcelineVQ> you can link to specific lines by clicking on the line number
17:17:31 <solonarv> I imagined that you already had a fully-specified type signature for spendUTX0With
17:17:46 <solonarv> it should definitely have one!
17:18:50 <solonarv> my suggestion was that you could perhaps use a wildcard signature on 'spendSig' and 'spendOther' 
17:19:16 <solonarv> but now I am even more confused, because I see commented-out type signatures on lockTimeAtLeast and spendUsingSignature
17:19:38 <ysangkok> yeah, those commented out because they are too specific :P
17:19:49 <ysangkok> (who knows if they are valid now)
17:20:52 <ysangkok> but this discussion did help me, i guess. i think i understand the monomorphism restriction more clearly now. 
17:21:55 <ysangkok> in this language (simplicity), all programs have commitment roots, which is a hash. but you can't run a hash, of course. so Kleisli (which you can run) is another instance
17:25:35 <solonarv> right, so I would expect to see a type signature like spendUsingSig :: SomeClass x => Sig -> x
17:26:27 <solonarv> and perhaps spendSig :: SomeClass x => x
17:28:14 <ysangkok> hmmm though i would speculate that if the function has the right type signature, spendSig shouldn't strictly need one
17:29:03 <solonarv> probably not, no
17:29:25 <solonarv> but it should still have one if you define it at the top level
17:29:52 <solonarv> and if you define it locally (in a 'let' or a 'where'), you need a type signature to stop the MMR from getting in your way
17:36:10 <koz_> I wanna do something similar to filepattern's getDirectoryFiles, but I need a list of directories, not files. Is there something I can use for that?
17:36:42 <koz_> (aka 'Is Koz going to write another streamly interface library' lol)
17:38:15 <jackdk> note also that putting type signatures on things gives you solid boundaries that stop the type inference alg from coming up with bizarre types
17:42:50 <solonarv> obviously the answer is: withProcessWait (proc "find" [".", "-path", pattern, "-type", "d"] & setStdout createPipe) $ \(getStdout -> out) -> ...
17:43:00 <solonarv> koz_: ^ ;)
17:44:06 <koz_> solonarv: Not gonna work on Windows, aside from obvious sarcasm. :P
17:46:12 <solonarv> just tell your users to install cygwin/mingw/msys2 :P
17:46:19 <koz_> solonarv: Not an option.
17:46:30 <solonarv> I know, I was still joking
17:46:38 <koz_> solonarv: I know. :P
17:46:47 <solonarv> also, it took me embarrassingly(?) long to type that
17:47:01 <koz_> solonarv: Having one of those days, are we?
17:53:08 <solonarv> my excuse is that I do not use typed-process or find very often at all
17:54:23 <solonarv> so I had to look up basically every part of that in the respective documentations
17:57:19 <koz_> Well, if nobody suggests anything, I know what I'm doing tomorrow lol.
18:06:09 * dmwit suggests anything
18:06:10 <dmwit> what now
18:06:18 <koz_> dmwit: Lol.
18:06:44 <dmwit> (You can still save yourself. Just point out that I'm not nobody.)
18:07:03 <koz_> dmwit: As you might have gathered, my humour levels are not over 9000 today. :P
18:07:18 <dmwit> uh
18:07:31 <dmwit> s/not// in my last message I guess
18:39:24 * hackage base64 0.2.0.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.2.0.0 (topos)
18:39:38 <topos> phadej ^ i'll have the split done tonight
18:44:54 * hackage base64-lens 0.1.0.0 - Optics for the Base64 library  https://hackage.haskell.org/package/base64-lens-0.1.0.0 (topos)
18:46:54 <i12321> erhandsome, 傻马兰的Servant每集才30分钟，真短
18:47:29 <i12321> sorry, wrong channel...
18:52:35 <koz_> Is there a reason why Kleisli has so few instances?
19:02:09 <dmwit> Probably not. What ones are you sad aren't there?
19:03:43 <koz_> dmwit: I'm not particularly _sad_, just surprised, especially relative the number of instances for ->.
19:03:54 <koz_> (or (->) a)
19:04:21 <dmwit> Oh, neat, maybe a Monoid instance would be nice.
19:04:37 <dmwit> Applicative?
19:04:43 <dmwit> What else?
19:05:59 <dmwit> Contravariant seems like a sneaky one.
19:08:42 <koz_> dmwit: Functor?
19:08:47 <koz_> (to give an obvious one)
19:09:10 <koz_> (I mean, Applicative implies that, I guess)
19:09:15 * dmwit nods
19:09:36 <koz_> I think Alternative is also possible.
19:10:04 <dmwit> Sure!
19:10:19 <dmwit> I double-dog dare you to write these instances and send them in.
19:10:57 <nshepperd2> profunctor, monad
19:11:15 <nshepperd2> MonadReader, even
19:11:41 <dmwit> Profunctor can't go in base.
19:11:46 <dmwit> MonadReader, either.
19:12:02 <nshepperd2> boo
19:12:15 <koz_> I suspect profunctors has an instance for Kleisli?
19:12:15 <dmwit> (But those instances could go in their respective packages, if they aren't there already.)
19:12:26 <dmwit> That seems likely, yeah.
19:12:29 <koz_> MonadReader I'm pretty sure doesn't exist presently for Kleisli.
19:12:59 <nshepperd2> ah yep, profunctors has the instance
19:13:20 <dmwit> It surprised me when you said Monad. Because I had rehearsed "but the composition of monads isn't always a monad" in my head. But of course this is one of the exceptions. Neat!
19:14:15 <dmwit> koz_: Maybe you should just use ReaderT. It's got most of those instances already. =P
19:14:23 <koz_> dmwit: You make a valid point there.
19:15:07 <koz_> Because like, Kleisli m a b is basically ReaderT a m b right?
19:16:34 <dmwit> right
19:16:55 <dmwit> You give up the Category and Arrow* instances, because kinds lmao, but maybe that's not so bad.
19:17:29 <solonarv> you lose Category and Arrow*, you gain... MonadTrans I guess?
19:17:32 <dmwit> And I guess you can't use the Endo newtype wrapper anymore, which is a bit more frustrating.
19:17:37 <solonarv> at least in principle
19:17:55 <solonarv> in practice Kleisli has shockingly few instances, indeed
19:18:00 <dmwit> solonarv: Alternative, Contravariant, Monad, MonadReader and friends, and more
19:18:14 <solonarv> I wonder if Star has more instances?
19:18:41 <nshepperd2> i think MonadTrans is the only useful instance ReaderT can have that Kliesli can't 
19:19:21 <solonarv> I think so too. All the other mtl-style classes only need a Type->Type kind, after all.
19:20:18 <dmwit> Oh, sure. I was talking about what you get in today's world, not what you would get in some hypothetical future world where Kleisli had all the instances it could have.
19:20:53 <nshepperd2> I suppose MFunctor too but i've never used mmorph irl
19:46:26 <alc> why Data.List.splitAt work on a list return a set not a list?
19:47:27 <alc> we know fmap f (a,b) = (a,f b), how to let it fmap f (a,b) = (f a, b)?
19:47:32 <ChaiTRex> :t Data.List.splitAt
19:47:34 <lambdabot> Int -> [a] -> ([a], [a])
19:47:54 <alc> I know that (a,) is a functor
19:48:05 <jle`> alc: fmap only does one thing ;) you can use 'first' to have first f (a, b) = (f a, b)
19:48:25 <jle`> it would be confusing if two functions that do different things on the same type of value had the same name
19:50:11 <dmwit> splitAt doesn't return a set. It does return a list. (It returns two lists.) So I don't understand the first question.
19:51:00 <alc> dmwit: wait, you mean splitAt retuan a multiple value?
19:51:21 <dmwit> It returns a pair, and each part of the pair is a list.
19:51:21 <ChaiTRex> alc: What is it you think splitAt does?
19:51:37 <ChaiTRex> alc: There may be a better function.
19:51:38 <alc> :t (splitAt 3 "abcdefg")
19:51:40 <lambdabot> ([Char], [Char])
19:52:01 <alc> dmwit: a pair is not a tuple is not a set?
19:52:13 <dmwit> A pair is a tuple. A pair is not a set.
19:52:43 <jle`> > splitAt 3 "abcdefg"
19:52:45 <lambdabot>  ("abc","defg")
19:52:51 <jle`> it returns a tuple with "abc" and "defg" :)
19:53:12 <alc> aha, there is Data.Tuple, I thought that tuple is set
19:53:18 <jle`> > let (x,y) = splitAt 3 "abcdefg" in map toUpper x
19:53:19 <lambdabot>  "ABC"
19:53:58 <jle`> tuples are ordered and heterogeneous, but usually when we talk about sets they are unordered and 'homogeneous'
19:54:53 <jle`> koz_: i believe the new version of base (or the upcoming one) adds more instances for Kleisli
19:55:25 <alc> wait a sec, can we concat a tuple? ("abc","efg") to "abcefg"?
19:55:35 <alc> I don't find a concat or <> on Data.Tuple
19:55:39 <dmwit> > uncurry (++) ("abc", "def")
19:55:41 <lambdabot>  "abcdef"
19:55:47 <jle`> alc: usually the main way to do it is via pattern matching
19:56:00 <jle`> > let (x,y) = splitAt 3 "abcdefg" in map toUpper x ++ reverse y
19:56:02 <lambdabot>  "ABCgfed"
19:56:22 <jle`> but uncurry is a nice higher order function that abstracts over a common usage of tuples
19:56:29 <jle`> uncurry f (x, y) = f x y
19:56:49 <jle`> (also pattern matching)
19:56:52 <alc> yeah, pattern matching is more elegant than swap
19:57:27 <jle`> it depends on what you want to do eventually, of course :) swap can be more readable in certain situations
19:57:51 <jle`> > (zip . swap . unzip) [(1,'a'), (2,'b'), (3,'c')]
19:57:53 <lambdabot>  error:
19:57:53 <lambdabot>      • Couldn't match type ‘([Char], [Integer])’ with ‘[a]’
19:57:53 <lambdabot>        Expected type: [(Integer, Char)] -> [a]
19:58:07 <jle`> > (uncurry zip . swap . unzip) [(1,'a'), (2,'b'), (3,'c')]
19:58:10 <lambdabot>  [('a',1),('b',2),('c',3)]
19:58:27 <jle`> > map swap [(1,'a'), (2,'b'), (3,'c')]
19:58:29 <alc> > let (x,y) = splitAt 3 "abcdefg" in uncurry (<>) (x, map toUpper y)
19:58:29 <lambdabot>  [('a',1),('b',2),('c',3)]
19:58:31 <lambdabot>  "abcDEFG"
19:58:48 <jle`> > map (\(x,y) -> (y, x)) [(1,'a'), (2,'b'), (3,'c')]
19:58:50 <lambdabot>  [('a',1),('b',2),('c',3)]
19:58:57 <jle`> the version with swap is arguably more readable than the version with explicit pattern matching
19:59:38 <jle`> but in the case of the code i wrote earlier with map toUpper x ++ reverse y, the version with pattern matching is probably more readable
20:01:28 <ChaiTRex> > uncurry (++) . second (map toUpper) . splitAt 3 $ "abcdefg"
20:01:29 <alc> jle`: my first thought to let "abcdefg" to "abcDEFG" is uncurry (<>) (swap $ fmap toUpper (swap $ splitAt 3 "abcdefg"))
20:01:30 <lambdabot>  "abcDEFG"
20:01:37 <alc> which is very ugly...
20:01:51 <alc> > uncurry (<>) (swap $ fmap toUpper (swap $ splitAt 3 "abcdefg"))
20:01:53 <lambdabot>  error:
20:01:53 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
20:01:53 <lambdabot>        Expected type: (Char, Char)
20:02:35 <dmwit> ...but that would "ABCdefg", no?
20:02:58 <alc> I want "abcDEFG"
20:03:12 <dmwit> Your first thought doesn't do that.
20:03:20 <alc> > fmap toUpper (splitAt 3 "abcdefg")
20:03:23 <lambdabot>  error:
20:03:23 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
20:03:23 <lambdabot>        Expected type: ([Char], Char)
20:03:37 <dmwit> > let swap (a, b) = (b, a) in uncurry (<>) (swap $ fmap toUpper (swap $ splitAt 3 "abcdefg"))
20:03:39 <lambdabot>  error:
20:03:39 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
20:03:39 <lambdabot>        Expected type: (Char, Char)
20:03:47 <dmwit> heh, for two reasons
20:03:54 <dmwit> > let swap (a, b) = (b, a) in uncurry (<>) (swap $ fmap (map toUpper) (swap $ splitAt 3 "abcdefg"))
20:03:55 <alc> Data.Tuple is not a functor?
20:03:57 <lambdabot>  "ABCdefg"
20:04:26 <dmwit> > uncurry (<>) . fmap (map toUpper) . splitAt 3 $ "abcdefg" -- no swap needed
20:04:29 <lambdabot>  "abcDEFG"
20:04:33 <dmwit> Not that I would recommend this.
20:04:55 <alc> err... I didn't expect this
20:05:05 <alc> why this needn't swap?
20:05:13 * dmwit shrugs
20:05:16 <dmwit> Why should it need it?
20:05:31 <alc> fmap f (a,b) = (a, f b)
20:05:37 * dmwit nods agreeably
20:05:48 <alc> a, you're right, I forget it
20:06:12 <alc> my intention is (f a, b)
20:06:19 <alc> my bad...
20:06:33 <dibblego> @type over _1
20:06:35 <lambdabot> Field1 s t a b => (a -> b) -> s -> t
20:06:40 <ChaiTRex> alc: You might want to use first and second rather than swap and fmap.
20:06:47 <dibblego> > over _1 (+1) (3, "abc")
20:06:50 <lambdabot>  (4,"abc")
20:06:53 <ChaiTRex> alc: More readable that way.
20:08:44 <alc> ChaiTRex: if I use fst and snd to get them, I have to do like `uncurry (f $ fst (a,b), b)`
20:09:13 <alc> ooops, I forget (<>)
20:09:43 <ChaiTRex> alc: first and second are different than fst and snd.
20:10:03 <ChaiTRex> > first (map toUpper) . splitAt 3 $ "abcdefg"
20:10:05 <lambdabot>  ("ABC","defg")
20:10:05 <alc> ChaiTRex: but I don't find that first and second in https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Tuple.html
20:10:21 <ChaiTRex> alc: They're in Control.Arrow
20:10:24 * hackage tree-render-text 0.4.0.0 - Configurable text rendering of trees.  https://hackage.haskell.org/package/tree-render-text-0.4.0.0 (ThomasEding)
20:11:00 <zeta_0> Just 5 >>= (\x -> if x == 0 then fail "zero" else Just (x + 1))
20:12:22 <zeta_0> how do i plug this stuff into the type signature of:
20:12:43 <alc> ChaiTRex: oh, Arrow is a typeclass, but I didn't find Data.Tuple is its instance from https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html
20:12:57 <ChaiTRex> alc: Data.Tuple is a module, not a type.
20:13:03 <ChaiTRex> alc: (a, b) is the type.
20:13:09 <zeta_0> (>>=) :: m a -> (a -> m b) -> m b
20:13:12 <zeta_0> ?
20:14:41 <alc> ChaiTRex: (a,) is an instance of typeclass Arrow?
20:16:17 <zeta_0> so: m a is Just a , ( a -> m b) is the whole expression on the right side of the >>= operator, and Just (x + 1) is the final returned m b , is this correct?
20:16:20 <alc> zeta_0: Just 5 :: m a, x :: a
20:17:27 <alc> zeta_0: \x -> ... :: a -> m b
20:17:28 <dmwit> zeta_0: "m a is Just a": no, m a is Maybe Int
20:17:42 <ChaiTRex> :t first
20:17:43 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:18:02 <dmwit> "( a -> m b) is the whole expression on the right side of the >>= operator": no, ( a -> m b) unifies with the type of the whole expression on the right side of the >>= operator
20:18:29 <ChaiTRex> alc: The function will be b -> c or (->) b c, (->) is an instance of Arrow.
20:19:00 <dmwit> "Just (x + 1) is the final returned m b": no, but Just (x + 1) does have a type that unifies with m b. `if x == 0 then fail "zero" else Just (x + 1)` is the thing that is finally returned, and has also has type m b.
20:19:10 <ChaiTRex> alc: As you can see by the type, first with (->) arrow is (b -> c) -> (b, d) -> (c, d)
20:19:11 <alc> ChaiTRex: is there a relation between Arrow and Monad...?
20:19:42 <alc> ChaiTRex: if (->) is an instance of Arrow, what function has to do with Arrow?
20:20:18 <dmwit> zeta_0: Generally: you are being very sloppy about the difference between "is" and "has type". They are two very different relations.
20:20:38 <dmwit> (I am sort of okay with being sloppy about the difference between "is" and "unifies with".)
20:22:38 <EvanR> it depends on what "is" unifies with
20:28:42 <slack1256> For Html parsing, is TagSoup the current go-to solution?
20:28:54 <jle`> alc: first and second are in arrow, but i think nowadays it's nicer to get them from Bifunctor
20:29:03 <jle`> Bifunctor is a nicer abstraction for this kind of stuff i think
20:29:14 <slack1256> I would like to work with something more... structured?
20:29:14 <zeta_0> thanks, this is making a little bit more sense now, there are still some things that confuse me but i am getting there
20:29:17 <jle`> > first negate (Left 3)
20:29:19 <lambdabot>  error:
20:29:19 <lambdabot>      • Couldn't match type ‘(b, d)’ with ‘Either Integer b0’
20:29:19 <lambdabot>        Expected type: Either Integer b0 -> (b, d)
20:29:27 <jle`> > Data.Bifunctor.first negate (Left 3)
20:29:29 <lambdabot>  error:
20:29:29 <lambdabot>      Not in scope: ‘Data.Bifunctor.first’
20:29:29 <lambdabot>      No module named ‘Data.Bifunctor’ is imported.
20:29:47 <jle`> hm yeah, bifunctor first lets you do first :: (a -> b) -> Either a c -> Either b c
20:31:28 <slack1256> Bifunctor is really nice. It has certainly made propagating error values via Either easier.
20:32:10 <slack1256> I don't even use (>>=) with Either anymore. I usually want a combination of join with bimap for the threading.
20:34:21 <dibblego> > let l = over _Left (+1) in (l (Left 9), l (Right "abc"))
20:34:23 <lambdabot>  (Left 10,Right "abc")
20:43:14 <hololeap> slack1256: there's html support in HaXmL and hxt, but they tend to fail on web pages "in the wild". tagsoup is probably your best bet otherwise
20:43:49 <alc> which function can do Int -> [Char]? like 32 to "32"?
20:44:03 <glguy> > show (32::Int)
20:44:05 <lambdabot>  "32"
20:44:11 <alc> glguy: thanks
20:46:10 <hololeap> i had to batch edit some XML documents at one point and had to choose between HaXmL and hxt. neither seemed very intuitive but i went with HaXmL in the end, and did end up getting it to work for me
20:48:52 <alc> glguy: then which one is "32" to 32?
20:49:15 <N3RGY> >  read "32" :: Int 
20:49:17 <lambdabot>  32
20:49:23 <alc> N3RGY: thanks
20:49:36 <jle`> be careful tho using read, it's partial
20:49:41 <jle`> > readMaybe "32" :: Maybe Int
20:49:44 <lambdabot>  error:
20:49:44 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
20:49:50 <jle`> @let import Text.Read
20:49:52 <lambdabot>  Defined.
20:49:53 <jle`> > readMaybe "32" :: Maybe Int
20:49:55 <lambdabot>  Just 32
20:51:43 <N3RGY> Yes, for a "real" application you should use some kind of parser library that handles things like invalid input gracefully
20:52:39 <jle`> > case readMaybe "32" of Just x -> x + 3; Nothing -> 0
20:52:41 <lambdabot>  35
20:52:47 <jle`> > case readMaybe "im not a number" of Just x -> x + 3; Nothing -> 0
20:52:50 <lambdabot>  0
21:03:26 <chambln> Does lambdabot handle semicolons specially or is that proper haskell?
21:03:59 <N3RGY> That's proper. It just doesn't come up very often because it's harder to read than newlines
21:04:06 <iqubic> That works in Haskell. It's just not good form.
21:04:21 <chambln> Cool
21:04:44 <ephemient> useful for code generators
21:05:31 <chambln> But indentation is significant, right? How do you infer indentation with semicolons?
21:06:04 <ephemient> more indentation = continuation. equal indentation = semicolon. less indentation = end
21:06:41 <oats> I never thought about it, but that makes perfect sense
21:06:46 <oats> nice and simple :)
21:07:02 <chambln> Oh yeah, that checks out.
21:07:09 <oats> not as restricting as, eg, python
21:07:55 <ephemient> {-# LANGUAGE NondecreasingIndentation #-} does tweak that a bit
21:09:04 <dmwit> It... actually doesn't, right? You just had a bug in your spec.
21:09:15 <dmwit> It's actually less indentation = as many ends as necessary to get back out to that level of indentation
21:09:26 <dmwit> (Both with and without NondecreasingIndentation.)
21:10:33 <dmwit> Mmm, I see, it does tweak it, because sometimes equal indentation will be an opening brace rather than a semicolon. Okay!
21:16:24 * hackage pandoc 2.9.1.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.9.1.1 (JohnMacFarlane)
21:44:06 <alc> jle`: is there a function make binary to decimal?
21:44:13 <alc> or reverse
21:44:30 <dmwit> Have a look in the Numeric module.
21:44:34 <alc> ok
21:50:43 <alc> there's not readBin
21:51:06 <alc> or I got the wrong name? it doesn't call binary?
21:53:10 <jle`> alc: you can use readInt, right?
21:53:55 <alc> jle`: yes?
21:54:41 <jle`> then you're set :)
21:54:54 * hackage env-extra 1.0.0.0 - Safe helpers for accessing and modifying environment variables  https://hackage.haskell.org/package/env-extra-1.0.0.0 (d12frosted)
22:07:47 <alc> > readInt 2 (`elem` "01") digitToInt "10"
22:07:50 <lambdabot>  [(2,"")]
22:24:16 <heatsink> Is there a way to uninstall one GHC version from .stack while leaving another installed?
22:25:43 <alc> I don't understand it, why binary to decimal or decimal to binary those basic function are not implement in the library
22:26:08 <alc> sorry, I really don't understand readInt, there's no exmaple to help me
22:26:23 <alc> I google it, and not help much
22:26:24 <MarcelineVQ> heatsink: ye, just delete it from .stack/programs
22:26:40 <heatsink> oh good
22:28:18 <jle`> alc: it looks like you used it correctly
22:28:29 <jle`> "10" turns into 2, right?
22:29:07 <jle`> alc: for displaying an Int using binary, i usually use something like printf
22:29:13 <jle`> remember that Int's aren't "decimal"
22:29:39 <jle`> > printf "%b" 52 :: String
22:29:41 <lambdabot>  "110100"
22:30:02 <jle`> 'convering decimal to binary' isn't toooo common of a thing
22:30:19 <jle`> if you mean converting a string containing a decimal representation of a number into a string representing a binary reprsentation
22:30:44 <alc> jle`: yeah, just "10" to 2, or "2" to 10
22:30:56 <alc> just numbers, not strings like 'a' to 'z'
22:30:58 <jle`> "2" the string, to 10 the number ten?
22:31:04 <jle`> er, the number that comes after 9
22:31:07 <alc> yeah
22:31:15 <alc> 10 in binary
22:31:17 <jle`> you want to convert the string "2" into 9+1 ?
22:31:23 <alc> jle`: 0010
22:31:30 <heatsink> 10 in binary is 2
22:31:32 <jle`> you want to convert the string "2" into the string "10" ?
22:31:33 <alc> "2" to binary 0010
22:31:48 <jle`> what sort of data type are you using to represent "binary 0010" ?
22:32:00 <jle`> remember that Int, the data type, is base-agnostic
22:32:04 <jle`> it can represent numbers in any base you want
22:32:09 <alc> forget that strings, just decimal to binary and decimal to binary...
22:32:37 <jle`> alc: remember Int is usable as both decimal and binary ... it is base-agnostic
22:32:49 <jle`> what sort of data type are you thinking of for "binary" and "decimal" ?
22:33:16 <jle`> if not Int or String, then what?
22:33:49 <alc> I don't know...
22:34:07 <chambln> Maybe [Int]?
22:34:14 <jle`> hm ... is this a part of a larger problem or thing you want to do?
22:34:22 <jle`> or is this just a question of curiosity
22:34:30 <jle`> with no practical application
22:34:44 <alc> jle`: https://www.codewars.com/kata/578553c3a1b8d5c40300037c/train/haskell
22:35:15 <jle`> ah, so it's [Int]
22:35:24 <jle`> you don't want to convert binary to decimal
22:35:29 <jle`> in that problem, at least
22:35:33 <jle`> you are converting binary to Int
22:35:41 <alc> jle`:  toNumber = \x -> (read $ foldl1 (<>) $ show <$> x) :: Int
22:35:47 <heatsink> Looks like that problem should be solved without using a library
22:36:20 <jle`> foldl1 (<>) . map f is the same as concat . map f, or concatMap f, btw
22:36:26 <alc> now I get that binary number, I need to turn it to decimal
22:36:36 <jle`> alc: it doesn't ask you to turn it into a decimal
22:36:40 <jle`> it asks you to turn it into Int :)
22:36:49 <jle`> 'turning it into decimal' would be converting it back into [Int]
22:36:59 <jle`> with every digit, like [1,9,9,7]
22:37:05 <alc> but Testing: [1, 1, 1, 1] ==> 15
22:37:08 <jle`> but in this case you don't need to turn it into decimal
22:37:13 <jle`> you just need to turn it into an Int
22:37:27 <jle`> you don't need to return [1,5], you just need to return an Int
22:37:38 <alc> what is INT?
22:37:49 <jle`> Int is an integer number
22:37:56 <jle`> like 0 or 1 or 2 or 3 etc.
22:38:11 <jle`> note that writing '15' is only how we notate the actual Int. the actual Int itself is the mathematical number
22:38:33 <jle`> so the int "1+1+1+1+1" has a Show instance where, if we use 'show' on it, it displays 5
22:38:59 <jle`> and similarly the Int (3*5) has a Show instance where, if we use 'show' on it, it displays "15"
22:39:06 <jle`> the string "15", if you use 'show'
22:39:09 <jle`> but the Int itself is not decimal
22:39:26 <alc> ... I need to think a moment
22:39:27 <jle`> decimal only comes up when we use 'show' on it, to display it for human consumption
22:39:34 <jle`> but Int itself is not decimal.
22:39:47 <heatsink> The toNumber function that you wrote turns [1, 1, 1, 1] into the string "1111".  Then it calls read, which reads it as a decimal number, so the result is 1111.
22:39:48 <alc> it's confused like str in python2 or python3
22:40:14 <jle`> alc: 'decimal' and 'binary' are just ways of notating a number
22:40:22 <jle`> they aren't numbers themselves
22:40:29 <jle`> there is no such thing as a 'decimal' number or a 'binary' number
22:40:48 <alc> just one number show in different ways?
22:40:56 <jle`> there is a number, and we can choose to notate it using the decimal notation or the binary notation
22:40:58 <jle`> yes
22:41:08 <jle`> so the number 3*5, for example, can be notated in binary as [1,1,1,1], or in decimal as [1,5]
22:41:41 <jle`> or "1111" and "15"
22:41:51 <alc> wait, you mean the number 15 in decimal is [1,5]?
22:42:00 <alc> it's [Int]
22:42:03 <jle`> in decimal it is "the digit 1, then the digit 5"
22:42:20 <jle`> in binary it is "the bit 1, then the bit 1, then the bit 1, then the bit 1"
22:42:33 <alc> 15 is [1,5] in decimal?
22:42:40 <jle`> 15 is "1 and then 5" in decimal
22:42:48 <jle`> and one way of reprsenting "1 and then 5" is [1,5]
22:42:55 <jle`> it's not the only way of representing it in haskell, but it's one way :)
22:43:05 <jle`> another way is "15", or ['1','5']
22:43:20 <heatsink> > 0xf == 15
22:43:23 <lambdabot>  True
22:44:05 <alc> > digitToInt "15"
22:44:07 <lambdabot>  error:
22:44:07 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
22:44:07 <lambdabot>      • In the first argument of ‘digitToInt’, namely ‘"15"’
22:44:14 <jle`> alc: er, what i'm trying to say is that the puzzle isn't asking you to convert to decimal, it's asking you to "parse" the [1,0,1,1] etc. into the Int that it represents
22:44:21 <heatsink> You can write the number 15 as 15 or as 0xf in Haskell.  The Haskell parser treats them like the same number.
22:44:26 <jle`> another thing conflating here being conflated is the idea of a *literal*
22:45:06 <jle`> a 'literal' is a thing you type into your source code to denote a value, for the compiler to interpret as that value
22:45:40 <jle`> for example if you type in "15" into a haskell source file (or a python script), it is interpreted as decimal notation for an integer
22:46:14 <jle`> so when ghc or python or c etc. sees the string 15 in a source file, it says "oohhh, you want the integer that is 3*5"
22:46:48 <jle`> we also have hexadecimal literals, like 0xf.  if a compiler or interpreter sees 0xf in a source file, it says, "ooooh, you want the intger that is 3*5"
22:47:00 <jle`> 15 and 0xf and 0b1111 are three literals that all represent the same integer
22:47:26 <jle`> three ways of telling the compiler "hey, i want the integer equal to 3*5 here"
22:47:33 <jle`> > 0xf == 3*5
22:47:35 <lambdabot>  True
22:47:43 <jle`> > 0b1111 == 3*5
22:47:45 <lambdabot>  error: Variable not in scope: b1111
22:47:52 <Orbstheorem> Hi, btw, is there a way to represent octal? ^^
22:47:56 <jle`> ah, that one needs an extension
22:48:34 <heatsink> Orbstheorem: 0O17 :)
22:48:42 <jle`> > 0o17
22:48:44 <lambdabot>  15
22:48:55 <Orbstheorem> Cool ^^
22:49:03 <Orbstheorem> Thanks ^^
22:49:39 <jle`> alc: but remember once 0b111, 0xf, 15, 0o17, etc. get parsed into an Int, then the Int is the Int.  it is "just the number itself", without any care about notation. the notation is only a way of telling the computer what number you actually want
22:49:47 <jle`> but the number itself doesn't have an inherent base
22:49:47 <chambln> > toNumber :: [Int] -> Int; toNumber [] = 0; toNumber xs = last xs + 2 * (toNumber $ init xs)
22:49:50 <lambdabot>  <hint>:1:25: error: parse error on input ‘;’
22:50:23 <jle`> alc: but yeah, this exercise it looks like you are supposed to actually implement the math of turning [1,1,1,1] into 15.  not use a library function i think
22:50:36 <alc> jle`: yes
22:50:54 <alc> jle`: and I don't find a library function to do that yet
22:51:29 <jle`> > readInt 2 (`elem` "01") digitToInt "1111"
22:51:32 <lambdabot>  [(15,"")]
22:51:32 <jle`> fwiw
22:52:46 <heatsink> alc: Given the number sequence 1, 2, 5, what math would you need to do to combine them to make 125?
22:53:02 <heatsink> I wrote those all in decimal, so there's no confusion about binary for this question.
22:53:25 <heatsink> Doing it in binary will be similar
22:54:00 <alc> heatsink: jle` my first thoght was [1,2,5] to ['1','2','5'] then "125" then 125
22:54:11 <suzu> don't use strings
22:54:14 <chambln> https://en.wikipedia.org/wiki/Positional_notation
22:54:21 <suzu> how would you do it with just math operations
22:54:32 <suzu> +-*/
22:54:34 <heatsink> If you do that, then you're relying on the "read" function to convert from "125" to 125
22:54:46 <alc> yes
22:54:51 <heatsink> and "read" has to do that math, still.  What math would "read" do?
22:55:00 <alc> I don't know...
22:55:10 <suzu> how would you do it with pen and paper yourself?
22:55:19 <alc> 1x100+2x10+5
22:55:26 <jle`> bingo :)
22:55:26 <suzu> excellent
22:55:34 <alc> but that's silly
22:55:40 <suzu> no it isn't. that's what read does
22:55:51 <alc> I have to get the lenght of [1,2,5] first
22:56:05 <jle`> that's one way to do it :)
22:56:08 <jle`> now, implement it :D
22:56:22 <jle`> we have lenght :: [a] -> Int already
22:56:24 <suzu> it can be done without knowing the length and just doing math "as you go"
22:56:25 <hololeap> you could probably also use a right fold
22:56:31 <jle`> there are many ways to do it
22:56:37 <jle`> but do the way that feels natural to you first
22:56:45 <alc> then (*1) z + (*10) y + (*100) x in [x,y,z]
22:57:02 <chambln> You're really doing (1 * 10^2) + (2 * 10^1) + (5 * 10^0)
22:57:11 <jle`> looks like you're on the right track. try implementing it as a function :)
22:57:22 <jle`> and then from there it isn't too tricky to turn it into parsing binary instead of decimal
22:57:39 <jle`> basically just turn 1, 10, 100, 1000, 10000 into 1, 2, 4, 8, 16, etc.
22:58:36 <alc> ok...
22:59:05 <alc> just binary to decimal without string involved
22:59:29 <jle`> for example, converting [1,0,1,1] into an Int is just 1*8 + 0*4 + 1*2 + 1*1
22:59:33 <chambln> No strings needed
22:59:35 <chambln> Not even chars
22:59:41 <jle`> but yeah, i would definitely call this problem more of a math problem than a haskell problem
23:00:03 <jle`> it's not very useful as a haskell learning problem unless you are already comfortable with interpreting positional notation
23:02:57 <chambln> Could someone write a solution using fold?
23:03:06 <chambln> I'd like to see that
23:03:15 <iqubic> It can be done.
23:03:18 <jle`> do you mean the haskell function 'fold' or like the idea of a fold?
23:03:22 <jle`> like foldr or foldl etc.
23:03:31 <chambln> the idea of folding
23:03:37 <chambln> so yeah I guess foldr or foldl
23:03:47 <iqubic> jle`: He means, do it with a catamorphism on lists.
23:04:03 <iqubic> So yeah, a fold.
23:04:07 <chambln> nerd :p
23:04:09 <jle`> hm. i've had to do this a few times and i usually reach for foldl
23:04:11 <jle`> which is not a catamorphism
23:04:14 <iqubic> Oh.
23:04:14 <jle`> so does that count?
23:04:25 <jle`> er well, it is not the general catamorphism
23:04:32 <suzu> wtf
23:04:33 <suzu> who cares
23:04:36 <MarcelineVQ> foldl is definitly the clearest example
23:04:50 <jle`> suzu: my point is that talking about catamorphism is a red herring/dead end here
23:04:54 <suzu> ok
23:05:12 <jle`> you can implement this using general catamorphism combinators but it's more natural to do it using something like foldl
23:05:53 <jle`> so bringing up catamorphism as an idea might be misleading
23:06:21 <jle`> chambln: but yeah, foldl is basically the 'imperative algorithm' list processor
23:06:36 <jle`> so the step would basically be "multiply the accumulator by ten, then add the newly seen digit"
23:06:45 <jle`> @let step acc n = acc * 10 + n
23:06:47 <lambdabot>  Defined.
23:07:03 <jle`> > foldl step 0 [1,9,9,7]
23:07:06 <lambdabot>  error:
23:07:06 <lambdabot>      Ambiguous occurrence ‘step’
23:07:06 <lambdabot>      It could refer to either ‘Text.Read.step’,
23:07:10 <jle`> whoops
23:07:15 <jle`> > foldl Main.step 0 [1,9,9,7]
23:07:18 <lambdabot>  error:
23:07:18 <lambdabot>      Not in scope: ‘Main.step’
23:07:18 <lambdabot>      No module named ‘Main’ is imported.
23:07:26 <MarcelineVQ> L.step I think, just go for yahb :>
23:07:36 <jle`> :t L.step
23:07:39 <lambdabot> Num a => a -> a -> a
23:07:44 <jle`> > foldl L.step 0 [1,9,9,7]
23:07:47 <lambdabot>  1997
23:07:51 <jle`> this is all my step btw, i imported Text.Read earlier heh
23:07:55 <jle`> *all my fault
23:08:14 <jle`> foldl is basically doing imperative programming :)
23:08:56 <iqubic> @define decodeInBaseN n = foldl' (\acc x -> acc * n + x) 0
23:08:57 <lambdabot>  Defined.
23:09:13 <iqubic> > decodeInBaseN 2 [1,1]
23:09:16 <lambdabot>  3
23:09:20 <iqubic> There we go.
23:09:47 <chambln> > decodeInBaseN 10 [1,0,0,1]
23:09:49 <lambdabot>  1001
23:09:55 <koz_> You can save yourself a bit of work by carting around the exponent and doing smaller multiplications of it at each step.
23:10:01 <koz_> This may not matter in this context.
23:10:14 <chambln> > decodeInBaseN 10 [9,0,0,1]
23:10:16 <lambdabot>  9001
23:10:21 <chambln> > decodeInBaseN 2 [9,0,0,1]
23:10:23 <jle`> the way i'd probably write this that translates closest from my mathy intuition is probably using zipWith
23:10:24 <lambdabot>  73
23:10:56 <jle`> @let asDecimal = sum . zipWith (*) (iterate (*10) 1) . reverse
23:10:57 <lambdabot>  Defined.
23:11:02 <jle`> > asDecimal [1,9,9,7]
23:11:04 <lambdabot>  1997
23:11:07 <alc> jle`: https://paste.ubuntu.com/p/rhnkvXTT8j/
23:11:09 <koz_> Yeah, that works.
23:11:10 <iqubic> I was just about to do that.
23:11:15 <koz_> Also avoids repeated unnecessary products.
23:11:43 <iqubic> I guess it does.
23:11:44 <jle`> alc: nice :)
23:12:07 <jle`> alc: a more haskelly way of writing that algorithm would probably be to use pattern matching (x:xs) instead of init and first
23:12:20 <jle`> and then you'd have to reverse the list first
23:13:25 <iqubic> I actually had to write a recursive function to turn a list of ones and zeros into its decimal equivalent for one part of CS final in Uni last week.
23:13:35 <alc> jle`: let's back to that question, now I can turn [1,1,1,1] to 1111, how to turn 1111 to 15? write another function?
23:13:38 <iqubic> Doing this in Java is not the cleanest.
23:13:47 <alc> use mod something to do that?
23:13:49 <koz_> iqubic: That sounds unpleasant.
23:13:52 <alc> just like math?
23:13:55 <amalloy> jle`: i think the foldl version is horner's method, right? perfectly mathy
23:14:10 <iqubic> I basically did the exact same thing as in alc's paste, just in Java.
23:14:52 <iqubic> But I first reveresed the list so that at each step I was picking out the first element.
23:15:20 <koz_> iqubic: Because everything I do seems to be about finitary these days, I ran into this problem with finitary and finitary-derive. :P
23:15:59 <iqubic> How so?
23:16:40 <koz_> iqubic: I needed something similar for Data.Vector.Sized.* instances of Finitary types.
23:16:49 <chambln> alc: You want to turn 1111 (base 2) into 15 (base 10)?
23:17:00 <jle`> amalloy: by that i mean, if i were to directly translate how i'd 'think' about doing it by hand into haskell
23:17:00 <alc> chambln: that's right
23:17:12 <chambln> What is the type of your 1111?
23:17:15 <koz_> Since I needed to be able to turn them to and from Finites, which looks _very_ similar to this.
23:17:19 <alc> 1111 :: Int
23:17:23 <jle`> alc: if you can turn [1,1,1,1] into 1111, then just switch the 10's to 2's
23:17:33 <alc> jle`: I don't need [1,1,1,1] to 1111
23:17:33 <jle`> alc: basically the 10 on line 6
23:17:45 <jle`> yeah
23:17:48 <alc> I just need [1,1,1,1] to decimal
23:17:54 <jle`> i'm saying, if you know how to turn [1,1,1,1] into 1111, then you can change the 10's to 2's
23:18:02 <alc> right
23:18:02 <jle`> that would turn [1,1,1,1] into 15
23:18:05 <koz_> For finitary-derive it was also similar, except I was turning things to and from bit/byte arrays.
23:18:20 <jle`> similarly if you turned the 10's into 16's, you'd get ...
23:18:25 <jle`> > 0x1111
23:18:27 <alc> jle`: then, how to reverse, turn 1111 to [1,1,1,]?
23:18:27 <iqubic> "I don't need [1,1,1,1] to 1111" & "I just need [1,1,1,1] to decimal" seem like contradictory statements to me.
23:18:28 <lambdabot>  4369
23:18:42 <chambln> alc: Are you saying you want to take a base 10 number that happens to have only ones and zeroes as digits, and deliberately misinterpret it as base 2?
23:18:46 <alc> jle`: right, div the lenght 
23:18:47 <jle`> alc: well, that's a different math problem :)
23:18:55 <jle`> alc: how would you do it by hand?
23:19:03 <iqubic> jle`: Doesn't have to be math.
23:19:09 <jle`> chambln: heh, check the scrollback, we have been going through some logic along those lines for a while
23:19:12 <iqubic> > map digitToChar [1,1,1,1]
23:19:14 <lambdabot>  error:
23:19:14 <lambdabot>      Variable not in scope: digitToChar :: Integer -> b
23:19:19 <iqubic> Darn.
23:19:22 <jle`> iqubic: it doesn't have to be, but we are treating the exercise alc is doing as a math problem
23:19:28 <alc> jle`: 1111 /10 /10 /10
23:19:30 <iqubic> Also, that doen't actually do what I want it to.
23:19:51 <jle`> alc: yeah. so write that out :)
23:20:02 <jle`> and once you do, just switch the 10's into 2's and now you have a binary notator
23:20:09 <alc> ok
23:20:50 <jle`> alc: ah, i see where i misinterpreted your question eightish minutes ago now
23:21:07 <jle`> alc: but remember that the exercise isn't asking you to turn [1,1,1,1] into 1111 and then 1111 into 15
23:21:17 <jle`> alc: it's just asking you to turn [1,1,1,1] into 15
23:21:20 <iqubic> jle`: I didn't know haskell supported "0x1111" as a literal. That could have helpped me a ton yesterday.
23:21:30 <jle`> so you can do that by just changing the code you pasted a little, changing the 10 to a 2
23:21:39 <jle`> and now you've solved the exercised already
23:21:41 <iqubic> I mean, sure, you can insert extra steps, but why bother?
23:21:56 <iqubic> Just do the simple thing that works.
23:22:46 <jle`> alc: your code has a 10 on line six. right now it turns [1,1,1,1] into 1111. if you changed the 10 to a 2, it'd turn [1,1,1,1] into 15. if you changed it to a 16, it'd turn [1,1,1,1] into 4369, etc.
23:23:04 <jle`> > 0o1111
23:23:07 <lambdabot>  585
23:23:13 <jle`> alc: and if you changed that 10 to an 8, it'd turn [1,1,1,1] into 585
23:23:17 <iqubic> What does that do?
23:23:21 <jle`> octal notation
23:23:28 <jle`> it's an octal literal
23:23:31 <iqubic> Right. And x is hexadecimal?
23:23:37 <iqubic> > 0b1111
23:23:40 <lambdabot>  error: Variable not in scope: b1111
23:23:44 <iqubic> What?
23:23:49 <jle`> it requires a language extension
23:24:05 <jle`> % :set -XBinaryLiterals
23:24:06 <yahb> jle`: 
23:24:20 <jle`> % [0b1111, 0o17, 15, 0xf]
23:24:20 <yahb> jle`: [15,15,15,15]
23:24:30 <iqubic> I see. I could have saved so much time when working on this AoC puzzle from 2015 last night.
23:25:28 <iqubic> I wrote the exact function that alc is writing, and procceded to call it on hard coded literals because I didn't know this binary literals thing existed.
23:25:34 <jle`> % :set -XNumDecimals
23:25:34 <yahb> jle`: 
23:25:40 <jle`> % [0b1111, 0o17, 15, 0xf, 1.5e1]
23:25:40 <yahb> jle`: [15,15,15,15,15]
23:26:01 <iqubic> What is NumDecimals? is that the 1.5e1 thing?
23:26:07 <chambln> Is there one for complex numbers?
23:26:16 <jle`> yeah normally 1.5e1 is parsed as a fractional number
23:26:18 <chambln> Complex valued literals
23:26:19 <jle`> it'd be 15.0
23:26:25 <iqubic> chambln: There is Data.Complex for that.
23:26:32 <iqubic> % import Data.Complex
23:26:33 <yahb> iqubic: 
23:26:39 <jle`> chambln: numeric literals in haskell are already polymorphic so we have complex-valued literals already
23:26:40 <iqubic> % 1 :+ 2
23:26:40 <yahb> iqubic: 1 :+ 2
23:26:46 <jle`> er
23:26:49 <iqubic> It works like that.
23:26:54 <jle`> we have complex number litearls, but not complex-valued literals
23:27:07 <jle`> no built-in language support for complex-valued literals, unfortunately
23:27:11 * jle` cries in fortran
23:27:18 <iqubic> Right. But you can just use the Data.Complex module from base.
23:27:20 <jle`> it's all library-supported
23:27:37 <iqubic> % magnitude (3 :+ 4)
23:27:37 <yahb> iqubic: 5.0
23:27:44 <jle`> implemented within the language, yeah. support in user-space, not language-specification-space
23:27:49 <iqubic> See, that's just a 3-4-5 right triangle.
23:27:58 * jle` cries in matlab
23:28:07 <iqubic> The magnitude of 3 + 4i is 5, as shown there.
23:28:24 <jle`> yeah, we have complex number support at the library level, but there are no complex-valued literals
23:28:32 <iqubic> What difference does that make?
23:28:41 <jle`> convenience mostly
23:28:51 <jle`> same as having negative number litearls
23:28:52 * chambln cries in octave #FreeSoftware
23:28:57 <jle`> i mean you can always write `negate 6` instead of -6
23:29:02 <jle`> but being able to write -6 is pretty convenient
23:29:03 <iqubic> What's the difference between (5 + 4i) and (5 :+ 4)?
23:29:24 <iqubic> Wait? negative literals are a thing?
23:29:31 <jle`> > (-6)
23:29:31 <iqubic> What the hell have I been missing?
23:29:33 <lambdabot>  -6
23:29:51 <jle`> we have built-in syntactic support for negative-valued literals
23:29:52 <iqubic> The hell?
23:30:03 <jle`> > [1, -2, 4, -9]
23:30:05 <lambdabot>  [1,-2,4,-9]
23:30:11 <iqubic> Wait.. That's not new. I've been using that for a long long time.
23:30:14 <iqubic> I'm so stupid.
23:30:23 <chambln> > read "-8" :: Int
23:30:27 <lambdabot>  -8
23:30:32 <jle`> nah you're not stupid. haskell negative literal support is pretty bonkers anyway
23:30:50 <jle`> even something as simple as sin -3 breaks
23:30:57 <iqubic> Yeah. I often find myself writing ".... $ -3"
23:31:09 <iqubic> Which is kinda stupid.
23:31:16 <chambln> > sin $ -3
23:31:18 <lambdabot>  -0.1411200080598672
23:31:20 <chambln> > sin (-3)
23:31:23 <lambdabot>  -0.1411200080598672
23:31:30 <jle`> > sin -3
23:31:32 <lambdabot>  error:
23:31:33 <lambdabot>      • No instance for (Num (Double -> Double))
23:31:33 <lambdabot>          arising from a use of ‘e_13’
23:31:34 <jle`> welp
23:31:48 <hololeap> sinners!
23:31:52 <jle`> we sort of wrote ourselves into a corner there by allowing for user-defined operators
23:31:58 <chambln> It's trying to find the difference between sin and 3, right?
23:32:04 <jle`> yeah, it's parsed as sin - 3
23:32:34 <iqubic> And then it tries to find a num instance for (sin), which doesn't exist.
23:32:43 <iqubic> :t sin
23:32:44 <chambln> The error message it spits out is not particularly helpful
23:32:45 <lambdabot> Floating a => a -> a
23:33:01 <jle`> we sort of wrote ourselves into an error-message-being-not-useful corner there by inventing typeclasses
23:33:19 <chambln> Typicall haskellers writing themselves into corners
23:33:29 <jle`> avoid success, at all costs
23:33:34 <iqubic> I've written myself into a corner.
23:33:41 <iqubic> Also, enum succs.
23:33:54 <iqubic> :t succ
23:33:56 <lambdabot> Enum a => a -> a
23:34:11 <iqubic> See, it literally succs.
23:34:24 <jle`> typeclasses are at the time haskell's greatest tool in expressive power and also the bane of almost all haskell usability problems
23:34:33 <iqubic> Hell yes.
23:34:35 <jle`> s/bane/source
23:34:36 <glguy> C is the same way; number literals are all nonnegative
23:34:58 <iqubic> tagless final is awesome, but also gives weird error messages.
23:35:34 <koz_> iqubic: Yes, Enum succs. :P
23:36:00 <iqubic> that's a silly joke.
23:36:09 <iqubic> Enum isn't that bad.
23:36:21 <iqubic> Without enum "[1..n]" fails to compile.
23:36:25 <jle`> Enum is the bad bad
23:36:33 <jle`> sometimes 1..n should fail to compile
23:36:38 <jle`> * [1..n]
23:36:46 <iqubic> Why do you say that?
23:37:54 <koz_> jle`: Something something everything I do these days comes back to finitary something. ;)
23:38:12 <EvanR> sometimes it compiles and [1..n] would crash at runtime
23:39:45 <EvanR> or not crash and give a weird nonsense
23:40:37 <jle`> > last [1,3..20]
23:40:40 <lambdabot>  19
23:40:44 <jle`> > last [1,3..20] :: Double
23:40:47 <lambdabot>  21.0
23:40:48 <jle`> whoops
23:41:00 <iqubic> What the hell?
23:41:08 <koz_> iqubic: Floating point is why we can't have nice things.
23:41:11 <koz_> (among others)
23:41:21 <jle`> but yeah i'm talking about places where it would crash at runtime or give weird results depending on what n is as well
23:42:41 <jle`> > succ it
23:42:44 <lambdabot>  error:
23:42:44 <lambdabot>      • Variable not in scope: it
23:42:44 <lambdabot>      • Perhaps you meant one of these:
23:42:50 <jle`> aw man this is not ghci
23:44:11 <iqubic> % succ it
23:44:11 <yahb> iqubic: 6.0
23:44:44 <iqubic> Oh, the last thing yahb computed was "magnitude (3 :+ 4)"
23:45:42 <EvanR> the successor of a real, here in lies the nonsense
23:46:54 * koz_ giggles at 'succ it'.
23:47:29 <koz_> Reminds me of some paper, subtitled 'How to make [something I can't recall now] succ less'.
23:48:47 <EvanR> https://hackage.haskell.org/package/bound ?
23:50:38 <koz_> EvanR: Yes, that one.
23:51:00 <koz_> "Making DeBruijn succ less" is a pun worthy of Edward.
23:51:44 <alc> jle`: https://paste.ubuntu.com/p/MMP7cBs3Zy/
23:51:55 <iqubic> DeBruijn indicies are awesome.
23:52:01 <alc> jle`: the reverse version is more difficult...
23:52:42 <koz_> iqubic: I recently discovered those, reading the book on the lambda cube someone here suggested to me.
23:52:44 <chambln> Someone register succless.org and write haskell clones of all the suckless utilities
23:52:54 <koz_> I gotta say, that book is great, and makes a good first read before TAPL.
23:52:59 <koz_> chambln: LOL
23:53:57 <iqubic> I haven't read those.
23:54:11 <iqubic> chambln: XMonad is our version of DWM.
23:54:30 <iqubic> Or something.
23:55:12 <chambln> iqubic: Yes! Any terminal emulators written in haskell?
23:55:42 <chambln> termonad
23:56:13 <chambln> “It can be thought of as the "XMonad" of terminal emulators”
23:57:31 <koz_> So now we need a Haskell implementation of busybox.
23:57:42 <koz_> I propose naming it 'lambda-cube'.
23:57:47 <koz_> For assorted reasons.
23:58:19 <EvanR> lazybox
23:58:47 <chambln> lazybox haha
23:58:51 <chambln> brilliant
23:59:57 <koz_> EvanR: But, the multi-level references!
