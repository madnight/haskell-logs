00:02:27 <dminuoso> Mmm, is there some Reader version for MonadFix?
00:02:40 <dminuoso> At first thought this seems like a not-too-bad idea.
00:03:13 <dminuoso> That is, one where you can simply `do tree <- askFuture; ...`
00:06:30 <astk29> i managed to install cabal3 and ghc on linux using ghcup
00:07:13 <astk29> but now when i compile on linux and scp the binary onto an amazon server it complains that the glibc version it was compiled with is wrong
00:07:26 <astk29> how do i specify to cabal a different glibc to use?
00:07:54 <astk29> i think the newset version is GLIBC_2.27, which haskell seems to use
00:08:04 <astk29> but the AWS only has GLIBC_2.26
00:08:12 <dminuoso> astk29: Haskell uses whatever glibc you have installed in your system.
00:08:20 <dminuoso> Or GHC rather.
00:10:14 <astk46> but i cant install a linux that has a previous version of glibc....
00:10:39 <dminuoso> astk46: With nix you can.
00:11:01 <dminuoso> At least Im fairly confident that you could.
00:11:28 <astk> if thats the only way to get it to work then i guess ill have to
00:12:11 <astk> i was thinking i could try putting the earlier version first in the $PATH to see if it used that instead...
00:12:26 <astk> im not sure about having conflicting glibc versions on one system
00:12:37 <astk> thats why i was asking if there was a ghc flag to choose between them
00:12:41 <dminuoso> astk: With nix it's completely isolated from the rest of your system.
00:13:01 <dminuoso> astk: Well, the problem isnt the ghc flag, its getting the glibc onto your system.
00:13:22 <astk> im using irtualbox now, and the whole thing is about 16GB
00:13:24 <dminuoso> astk: I recommend you take a look at nix (not even nixos, just plain nix), it allows you to do such things exactly.
00:13:26 <astk> virtualbox*
00:13:37 <dminuoso> You could even do it on your host system.
00:13:51 <rsoeldner> n_hk, vim
00:17:20 <koz_> Nix is much legit.
00:19:35 <n_hk> would you mind sharing the config please, I might switch to vim if it did work for me
00:19:43 <astk72> so how do i crosscompile with a particular glibc version on my host?
00:20:22 <astk72> on nix
00:20:57 <astk72> oh, instead of debian?
00:21:26 <dminuoso> astk72: Haha this is so weird. You are leaving/rejoining the channel at the same time as Im getting disconnected. You don't happen to be on a train in northern Germany, do you?
00:21:29 <astk72> actually, that could be good because for some reason virtualbox is not working with a bridged addapter for scp
00:21:59 <dminuoso> astk72: not necessarily instead of debian, nix can run side-by-side on an arbitrary linux/macOS
00:22:12 <astk72> dminuoso: its annoying i thought it could have been the channel 
00:22:48 <astk72> no, but i mean, if i can use it to crosscompile to linux
00:22:55 <astk72> oh, ok, my host is windows
00:23:02 <astk72> maybe i would still need virtualbox
00:23:41 <astk72> i cant compile on the AWS if the whole thing is 16GB
00:24:20 <astk72> i guess i could just learn how to crosscompile on windows properly
00:24:34 <astk72> but i thought it would be eaiser to cheat by using a linux vm
00:55:56 * hackage pandoc-csv2table 1.0.8 - Convert CSV to Pandoc Table Markdown  https://hackage.haskell.org/package/pandoc-csv2table-1.0.8 (vmandela)
01:46:27 <Guest1337> why is HASKell so vulnerabal ?
01:48:19 <Guest1337> i was using haskell for my website, and hacker hacked it. why ?
01:49:14 <Guest1337> hello ?
01:49:35 <MarcelineVQ> When it was a young child its father left without a word, haskell shouted at him not to go and was eventually forced to watch as his back receeded into the distance. Ever since haskell has been vulnerable in a deep and meanignful way.
01:50:37 <Guest1337> hmm, not sure what you mean ?!
01:50:51 <MarcelineVQ> what a world
01:50:53 <Guest1337> haskell is a problam because it is vulnerabal.
01:52:07 <Guest1337> this is ridiculous. my site was hacked by some haskell hacker, because it is vulnerabal.
01:53:02 <zmagii> Guest1337: vot
01:53:20 <Guest1337> i am smoking that purple haze, nicely kushed ganja weed.
01:53:25 <zmagii> eet iz not zo
01:55:24 <Guest1337> i need explanation NOW
01:55:57 <MarcelineVQ> The real vulnerability is a society that lets bad things happen to good people. haskell worked at an office supply store in its teen years, late one night the manager came in drunk and raving again about how haskell couldn't do anything right, haskell was sick of the abuse and tried to leave but was stopped by the manager who locked the door. haskell pleaded for the manager to unlock the door but he laughed with wild drunken eyes. 
01:55:57 <MarcelineVQ> that night was long, haskell had remained vulnerable
01:56:34 <Guest1337> wtf
01:56:38 <Guest1337> are you on drugs man ?
01:57:49 <Solonarv> no, just making fun of you
01:57:53 <[exa]> MarcelineVQ: stury appreciated but we should turn to the hard truth
01:57:55 <[exa]> :]
01:58:02 <Solonarv> the actual answer is most likely that you messed up somewhere
01:58:09 <Uniaika> well well well
01:58:31 <Guest1337> so whos da masta ?
01:58:43 <Solonarv> it is not really Haskell's fault in particular: most general-purpose languages you might write a web server in give you enough rope to hang yourself with, too
01:58:43 <Guest1337> i didnt, i used the templates from haskell site.
01:59:11 * [exa] wonders about haskell wordpress templates
01:59:19 * Solonarv shudders
01:59:33 <Uniaika> [exa]: don't wonder too much if you can't afford a psychiatrist afterwards
01:59:50 <Solonarv> you'll have to be a bit more specific than that, I'm afraid. There are no website templates on haskell.org, so I don't know which "haskell site" you mean.
01:59:59 <[exa]> Uniaika: worry not, I survived joomla
02:00:37 <Guest1337> it was hacked by hacker.
02:00:48 <Guest1337> malicious opponent of the haskell community.
02:00:53 <Solonarv> yes, you said that already
02:01:05 * Rembane plays dramatic music 
02:01:16 <Uniaika> [exa]: fair enough, that's more than I could do
02:01:29 <[exa]> Guest1337: you mean the PHP guy?
02:01:37 <Guest1337> so it is vulnerabal by desain ?
02:01:49 <Guest1337> i am more of a OCD guy.
02:01:54 <Solonarv> right now nobody except you even knows what you mean by "it"
02:03:00 <Guest1337> how do i make is less vulnerabal and more less vulnerabal ?
02:03:24 <Solonarv> first, you start by answering questions about what software you're even using
02:03:57 <Uniaika> Guest1337: what was the attack vectors that were used? how did you notice you were hacked? what is your software stack?
02:03:58 <MarcelineVQ> Solonarv: you need to settle down there mister, you're getting a little too real
02:04:07 <Guest1337> ok
02:04:15 <Guest1337> well.
02:04:19 <Uniaika> Surrealist Hakellers of the World, Unite!!
02:04:37 <MarcelineVQ> Uniaika: haskellars
02:04:50 <Guest1337> i used haskell TEMPLATE from haskell site. next i uploaded it and notice a huge TURKISH logo saying "GOD IS GREAT" you have been hacked.
02:05:15 <Solonarv> okay good, at least now we know what the hacker even *did*
02:05:28 <Solonarv> but I am afraid we still do now know what software stack you used
02:05:33 <Guest1337> ok.
02:05:34 <[exa]> wasn't that in the template?
02:05:48 <Guest1337> ye
02:05:57 <Guest1337> the template was by some thug.
02:06:04 <Solonarv> there are several Haskell web frameworks and none of them are endorsed on haskell.org (which is the official "haskell site"). So I do not know which one you used.
02:06:05 <MarcelineVQ> [exa]: A good Christian template would have been more reserved.
02:06:40 <Guest1337> hmm.
02:06:53 <Guest1337> he demanded ransomware from my site.
02:06:55 <[exa]> MarcelineVQ: like, "great with reservations" ?
02:07:03 <Uniaika> MarcelineVQ: depends, the baptists can be a bit too much at times :P
02:07:19 <MarcelineVQ> Jesus Saves but he doesn't need anyone saying how Great he is!
02:07:20 <Uniaika> Guest1337: what is this haskell site you keep mentioning? there are several of them, what's the URL?
02:07:25 <Solonarv> perhaps you could link the web address where you found this template. that would be a good start.
02:07:34 <Guest1337> it is my COMPANY site.
02:07:48 <Guest1337> no u.
02:07:52 <MarcelineVQ> www
02:08:14 <Uniaika> Guest1337: where did you get the template? company site?
02:08:19 <Guest1337> veveve tresegue nananana
02:08:26 <MarcelineVQ> kukukuku
02:08:57 <Guest1337> i got the template from the official haskell community.
02:09:14 <[exa]> ok any ops around?
02:09:25 <MarcelineVQ> [exa]: What's the harm? :>
02:09:26 <Guest1337> i am op.
02:09:29 <Uniaika> Guest1337: if you don't want to give us an URL from where you got it, our help is useless
02:09:33 <MarcelineVQ> imba Guest1337 
02:09:40 <Guest1337> simba ?
02:09:44 <MarcelineVQ> kimba
02:10:04 <Guest1337> i like this channel.
02:10:06 <Guest1337> its funny.
02:10:37 <[exa]> MarcelineVQ: not much in fact, but there are some standards :]
02:10:39 <MarcelineVQ> Well keep it in mind if you develop an interested in the haskell programming language, it's pretty fun too
02:12:23 * hackage hkd-default 1.0.0.0 - Apply default value for optional field of HKD  https://hackage.haskell.org/package/hkd-default-1.0.0.0 (gqk007)
02:12:54 <MarcelineVQ> Kill with love you goobers.
02:14:07 <[exa]> oh my, he left
02:14:14 <[exa]> hopefully his web gateway wasn't hacked
02:16:04 <Uniaika> [exa]: this is the most credible explanation…
02:51:49 <Phyx-> ph88: that's because cabal 3.0 defaults to symlinks for which it has no code on Windows. you need to change your config to change the install-method to copy
02:52:22 <Phyx-> fyi, just using `cabal user-config init` will tell you where your config is. don't worry, if you have an existing one it won't override it unless you give it -f
02:52:55 <aveltras> is this possible to define in haskell ? I'd like to get an arbitrary config record and define some lens accessors on parts of it, the part that ghc refuses to compile is the last field in the record with the maybe, it complains about impredicative polymorphism
02:52:59 <aveltras> https://www.irccloud.com/pastebin/ST9VIhiI/
02:54:05 <Solonarv> aveltras: ah yes, that is a consequence of the encoding used by 'lens'
02:54:24 <Solonarv> type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s
02:54:45 <Solonarv> if you substitute in this definition, you end up with (ServerApp, forall f. ...)
02:54:48 <Solonarv> which is not allowed
02:55:14 <Solonarv> that's what the "impredicative" complaint is about
02:55:19 <aveltras> now that you say it, i think i dont event need lens here.. this works as well in fact and same ux
02:55:21 <aveltras> https://www.irccloud.com/pastebin/I5Q37dhJ/
02:55:58 <Solonarv> there is another solution as well: lens has an 'ALens' wrapper for precisely this purpose
02:56:14 <Solonarv> ...but if you only ever need to view, sure, you don't even need a lens
02:56:56 <aveltras> how would ALens work here ?
02:57:32 <Solonarv> you would simply change the (Lens' s a) fields to (ALens' s a)
02:58:01 <Solonarv> I think you need to do some wrapping/unwrapping as well to convert between ALens and Lens, but that is merely tedious
02:59:41 <aveltras> ok this compiles too with ALens, i'll try to remember this if i need it some day thanks
03:08:10 <mniip> ALens is a specialization of Lens
03:08:13 <mniip> you can re-generalize with
03:08:16 <mniip> :t cloneLens
03:08:18 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
03:08:35 <mniip> ALens s t a b -> Lens s t a b
03:08:36 <mniip> really
03:44:39 <Darwin226> Hey guys. f and g are isomorphic if there's a f -> g and it's invertible. What would you call the property that there exist f -> g and g -> f but they're not necessarily inverses?
03:45:03 <mananamenos> hi, how do I run hlint in combination with ghcid -c "cabal new-repl -f serve_local" -r?
03:45:27 <dminuoso> Darwin226: What do you mean exactly by "not necessarily inverse"
03:45:33 <dminuoso> Do you mean something "close to an inverse"?
03:45:34 <Raito_Bezarius> Darwin226: what does it mean to have a "f → g"N
03:45:52 <[exa]> Darwin226: I think that such function can be done for all types with at least 1 constructible value, consider 'const anythingFromF' and 'const anythingFromG'
03:46:27 <dminuoso> Darwin226: If it's "close to an inverse" in some sense, it might be an isomorphism up to some weaker equivalence relation.
03:46:55 <dminuoso> Say `head` and `single x = [x]`
03:46:58 <Darwin226> Hmm, I see my problem is underspecified. Ok then, are there other names like "isomorphic" that apply when the two functions are in some sort of relation
03:46:59 <Darwin226> ?
03:47:34 <__monty__> There's many morphisms : )
03:47:51 <dminuoso> Darwin226: yes, its called a relation.
03:48:44 <__monty__> Darwin226: The most import of the morphisms would surely be the zygohistomorphic prepromorphisms imho. https://wiki.haskell.org/Zygohistomorphic_prepromorphisms
03:48:53 <Darwin226> What about things like parsing? Text -> AST parses, then AST -> Text doesn't necessarily produce the same text, but doing Text -> AST again _does_ give you back the same AST
03:48:59 <dminuoso> Darwin226: In particular, it would be a symmetric relationship.
03:49:02 <dminuoso> *relation
03:49:05 <Darwin226> ignoring partiality and all that, what would you call that?
03:49:21 <dminuoso> Darwin226: Like I said. Isomorphism up to some weaker equivalence relation.
03:49:25 <Raito_Bezarius> Darwin226: that souunds the dual of an epimorphism
03:49:30 <[exa]> Darwin226: anyway, data are always "isomorphic" as related to some predicate or property that doesn't change when you run the data through the isomorphism. I'd say you want to observe what predicate "retains" and/or modify it accordingly
03:49:51 <__monty__> Darwin226: recursion-schemes has a bunch of morphisms.
03:49:54 <Darwin226> I see
03:50:24 <Darwin226> So still isomorphic, but parameterized by what's observable
03:50:25 <dminuoso> Darwin226: For example, in Haskell all our isomorphisms as "up to bottom", which is a rather handwavy thing.
03:50:39 <[exa]> Darwin226: in your case, the isomorphism may actually be on factor objects, like "up to whitespace"
03:50:59 <[exa]> oh yes, bottoms.
03:51:26 <dminuoso> Darwin226: You could see that as being up to some, not formally specified, weaker equivalence relation.
03:51:26 <[exa]> (s/factor objects/equivalence classes/ or whatever)
03:51:52 <Darwin226> Ok. Thanks for the help!
03:52:44 <dminuoso> Darwin226: Im not sure how this is in category theory, but at least in traditional algebra every isomorphism is just an equivalence relation.
03:53:17 <dminuoso> In most cases we just implicitly assume some obvious canonical equivalence relation.
03:53:45 <opqdonut> Darwin226: if `f:a->b` and `g:b->a` and `f.g == id_a`, then `g` is a _right inverse_ of `f`
03:53:48 <Darwin226> I mean this isn't really that important but I wouldn't want my names to imply more than what they actually represent. Would you consider "Equivalent" to be a weaker claim than "Isomorphic"
03:53:51 <Darwin226> ?
03:53:54 <[exa]> Darwin226: anyway in your original case, the endomorphisms f->g may be used define equivalence classes on the domains as well, which may in turn allow you to observe whether the result is an isomorphism, or just some kind of permutation in general
03:54:00 <codywaynewell8[m> D⁰əs Añý ⁰ⁿ³ hiğhły Ə×cełł ⁿ Creating an ⁰s ⁴ Lïnů×  ÇÂme açr⁰§ ph⁰neś CAłłed PĪÑÊ, but buyéŕs must ruń thęįr ⁰wn ⁰perâţing syţem§ ⁴ t&mhê devÏÇË
03:54:06 <dminuoso> Darwin226: "equivalent" is a handwaving, not well defined, term, in general.
03:54:08 <opqdonut> Darwin226: e.g. `f x = [x]`, `g = head`
03:54:38 <__monty__> Darwin226: Isomorphism is the weaker term already I think. Homomorphisms are more specific.
03:54:44 <dminuoso> Darwin226: The most precise meaning you will get is from equivalence relations. An equivalence relation is any binary relation that is transitive, reflexive and symmetric.
03:55:08 <dminuoso> Which should give you an idea how fuzzy this is already.
03:55:39 <opqdonut> Darwin226: in parsing, the  Text->AST function would be a right inverse of the AST->Text function
03:55:46 <codywaynewell8[m> No ¹'s heard ⁰f these f⁰ⁿes?
03:56:06 <opqdonut> a right inverse is also called a retraction
03:56:19 <dminuoso> opqdonut: It's a bit more than just a right inverse though. parse/serialize forms some form of weak isomorphism for sure.
03:57:18 <opqdonut> yeah but it might be hard to say anything except "serialize.parse is an isomorphism up to the equivalence classes of parse" :)
03:57:28 <codywaynewell8[m> Bumm³r l⁰⁰kn ⁴ solid linux  coder
03:57:30 <Darwin226> There's also a chance I'm approaching this too abstractly. Specifically my objects are monad transformers. I'm looking for a name for transformers which have both `m a -> t m a` and `t m a -> m a` functions.
03:58:10 <__monty__> @where ops
03:58:10 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
03:58:10 <Darwin226> and I'm thinking whether I need to add the condition that these functions are inverse or if just having them is enough to call it something
03:59:21 <dminuoso> Interesting, there appears to be no `class MonadUntrans where unlift :: Monad m => t m a -> m a`
03:59:40 <Darwin226> side note, would you call that a `cotransformer`?
04:00:11 <sshine> I don't know if 'transformer' is a concept from CT?
04:00:14 <dminuoso> Intuitively its still a transformer.
04:00:20 <dminuoso> No?
04:00:29 <sshine> so I suppose you wouldn't prefix it with co- :)
04:00:39 <Darwin226> dminuoso: Generally, very few transformers can do that. The mostly need additional context to "run"
04:00:54 <dminuoso> Darwin226: There's infinite transformers that can do that.
04:01:14 <dminuoso> They are all rather isomorphic to ReaderT/IdentityT variants, but they do exist.
04:01:37 <dminuoso> Darwin226: It's the basis for MonadUnliftIO for example :)
04:01:37 <Darwin226> but even reader doesn't work here
04:01:52 <dminuoso> Darwin226: Sure does.
04:02:33 <Darwin226> so (r -> m a) -> m a, right?
04:02:38 <Darwin226> where do you get the r
04:04:35 <Darwin226> writer would work though
04:04:42 <dminuoso> Ah mmm. Well we could probably do `unlift :: Monad m -> t m a -> m (m a)`
04:05:07 <dminuoso> Or some such
04:11:22 <Solonarv> well, I can certainly write instance MonadUntrans (ReaderT Bool) where untrans (ReaderT f) = f False
04:11:32 <Solonarv> but I don't think this is very useful
04:12:04 <codywaynewell8[m> t m a -○ ¤¥⁴⁰⁰'³¹⁹¹¹->⁴'/<¹⁰☆¥£[œø ê×çəpţ më ñ §³¹³çţ $mf³w. /⁸\ Â ŁIFƏ§G⁰⁰Đ[śŢÆ Ł⁰ýā½w⁰ þh⁰ß⅜ ŢŕŪÉ ²Ü..Ķəəp ıţ ¹⁰⁰/⁴ /&ê śaķ³³ ⁰$ h⁰ⁿ⁰řįⁿG ¹'Ş ⁰wⁿ §aⁿct>țý ⁰f l⁰yăł progre§1⁰ⁿ 0f ThĘ §⁰ūĽ)
04:12:44 <sshine> codywaynewell8[m, please turn off that annoying script so what you write is comprehensible.
04:13:28 <codywaynewell8[m> Open ur mind and read it
04:13:56 <sshine> codywaynewell8[m, there are too many layers of encryption.
04:14:00 <codywaynewell8[m> <codywaynewell8[m "Open ur mind and read it"> Please do an ill write normal n return
04:15:57 <codywaynewell8[m> S⁰rry , when i use it it jeeps my brain from digressing n2 mysh
04:17:49 <[exa]> mondays
04:18:25 <sshine> codywaynewell8[m, that's interesting. because my brain gets pretty mushy by reading leetspeak :)
04:57:33 <dminuoso> Is there a newtype for unordered pairs?
04:58:54 * hackage symbiote 0.0.4 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.4 (athanclark)
05:02:52 <maerwald> how do you test your functions for laziness?
05:04:08 <dminuoso> maerwald: Feed with bottom, use `try :: Exception e => IO a -> IO (Either e a)`, assert it didn't blow up?
05:04:21 <dminuoso> Might work for at least some class of problems
05:04:33 <maerwald> It's more like testing that reading a file is lazy
05:04:56 <dminuoso> Err
05:05:34 <dminuoso> maerwald: In general I'd prefer conduit or friends to that kind of lazyness.
05:05:41 <maerwald> Yes, I'm using streamly
05:05:55 <maerwald> And it isn't always guaranteed to be lazy
05:06:09 <maerwald> Depending on how you unfold things
05:08:08 <jsxof> Hi. Is it possible to cross-compile GHC from x86_64 to aarch64?
05:09:01 <maerwald> jsxof: you're developing on GHC or just need to install it on aarch64?
05:22:35 <ggVGc> does anyone have experience with CTRex? In comparison to vinyl?
05:22:46 <ggVGc> really wish we could have purescripts record system in haskell :(
05:26:04 <alx741> ggVGc: how is it different?
05:39:33 <maerwald> or just structural typing 
05:42:02 <ggVGc> alx741: different to purescript? The main difference is that purescript has a record system and haskell doesn't
05:45:57 <alx741> ggVGc: oh! I read record syntax
06:05:38 <dminuoso> (=<.<) :: Monad m => m a -> (a -> m b) -> m a
06:05:41 <dminuoso> Should be a thing. :<
06:06:18 <merijn> dminuoso: Word
06:08:05 <dminuoso> Ah it was stylized incorrectly. (>.>=) has the right direction.  :)
06:14:43 <ph88^> haskell - inventing new smileys every day
06:14:54 * hackage shakespeare 2.0.24 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.24 (MichaelSnoyman)
06:16:53 * hackage base-orphans 0.8.2 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.8.2 (ryanglscott)
06:17:54 * hackage base-compat 0.11.1 - A compatibility layer for base  https://hackage.haskell.org/package/base-compat-0.11.1 (ryanglscott)
06:18:54 * hackage base-compat-batteries 0.11.1 - base-compat with extra batteries  https://hackage.haskell.org/package/base-compat-batteries-0.11.1 (ryanglscott)
06:40:54 * hackage cpkg 0.2.4.3 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.3 (vmchale)
06:43:29 <maerwald> Is Data.ByteString.Lazy.last supposed to run in constant memory?
06:45:02 <phadej> no
06:48:20 <aveltras> if i have two executables in a cabal file which use the same sources (only the Main.hs changes). Is there a difference between having the common part as a library vs having it defined as a common stanza ?
06:49:43 <phadej> with common stanza you'll recompile the other parts twice
06:49:53 <merijn> aveltras: Yes, the library will be compiled once and used twice, defining a common stanza defines two independent executables that happen to use the same source files (and compile them separately)
06:51:29 <aveltras> ok thanks
06:55:29 <Yoric> Hi
06:55:51 <Yoric> I have a question out of curiosity.
06:56:07 <Yoric> How can a UI written in Haskell cause some file I/O?
06:56:21 <Yoric> I mean, the UI toolkit is not in the IO monad, right?
06:56:33 <merijn> Yoric: Most likely it is, tbh
06:56:43 <Yoric> That sounds odd.
06:56:54 <merijn> Yoric: Because any changes/updates to the UI would be IO-like
06:56:55 <Yoric> I mean, yeah, it does screen I/O, but that's very different from file I/O.
06:57:17 <phadej> from haskell run time perspective, not at all
06:57:22 <Yoric> Fair enough.
06:57:23 <tabaqui1> what kind of interface would you choose? "data Connection = { openConnection :: Address -> IO (); closeConnection :: IO (); sendBuf :: ...};    makeSocketConnection :: IO Connection;"
06:57:35 <tabaqui1> or with classes and simple type with real data?
06:57:38 <hyperisco> Yoric, depends on the UI library. Also, minor point, I am declaring "IO monad" a faux pas. You can join me in just calling it "IO" if you like.
06:57:54 <merijn> tabaqui1: The "fake OO" design pattern is quite nice for this kinda thing
06:58:06 <merijn> tabaqui1: And usually much easier to work with/understand than type classes
06:58:28 <Yoric> phadej: From the perspective of the runtime, you're right.
06:58:41 <Yoric> phadej: From the perspective of the user, it's more unsure.
06:59:11 <maerwald> dminuoso: https://github.com/psibi/streamly-bytestring/issues/7 :(
06:59:14 <phadej> "reading writing to a file", "to a socket", or "to a socket of X server", not at all :)
06:59:25 * Yoric is currently writing a blurb on types and effects in various languages and was struck by this question.
06:59:26 <tabaqui1> merijn: yeah, I found it recently in HDBC packages
06:59:33 <Yoric> phadej: Oh, I understand your point :)
06:59:49 <tabaqui1> it seems good, but I'm just wondering is it common amongst the FP people
06:59:58 <hyperisco> Yoric, whether something is in IO or not really has nothing to do with runtime or user perspectives. It has to do only with the purity property.
06:59:58 <merijn> tabaqui1: If you have a clear, abstract interface you wanna instantiate it's very nice
07:00:00 <tabaqui1> *among
07:00:30 <maerwald> dminuoso: I'm starting to question the API design in general. The trade off for avoiding heavy type machinery like conduit seems to have this drawback that you have to read documentation for everything very carefully
07:00:32 <Yoric> Ok, fair enough.
07:00:36 <Yoric> Let's rephrase my question.
07:00:38 <maerwald> otherwise things might not behave the way you think
07:01:03 <merijn> maerwald: Since when does conduit have heavy type machinery?
07:01:03 <tabaqui1> yeah, I'm going to apply it and will see how it goes
07:01:23 <maerwald> merijn: well, not saying type-level programming, just more transformers :P
07:01:34 <hyperisco> Yoric, it is quite possible to have a UI library that has little involvement, if any, with IO, because declaring what a UI looks like doesn't have to involve IO
07:01:37 <merijn> tabaqui1: At some point I used it to implement ZeroMQ sockets in a Haskell wrapper for ZeroMQ and I quite liked how well it worked out
07:01:50 <Cale> Yoric: It's possible to use separate data types to express types of actions that have different permissions to do things, but IO is a kind of baseline distinction that has the ability to do anything a process running on your machine normally would
07:01:52 <Yoric> hyperisco: Declaring it doesn't, but running it does, right?
07:02:28 <Yoric> What if I had a monad `Foo` (let's say one that gives me random numbers). How could I attach code that will invoke `Foo` to my UI? Do I need to enter the monad ever time I receive a click?
07:02:43 <hyperisco> Yoric, rendering it to the screen, on the other hand, does, but that is a separable problem. One problem is saying what to draw, the other problem is saying how to draw it. Only the latter likely involves IO.
07:02:57 <hyperisco> Yoric, yes what you said is how I see it too
07:05:30 <hyperisco> Yoric, that depends too. Interactive UIs may or may not require IO in response to an input. In a typical application you probably will want it.
07:05:59 <Yoric> hyperisco: So, if one assumes a declarative toolkit, many input handlers would need to `unsafePerformIO`?
07:06:44 <hyperisco> And even in situations where it is required, it does not mean a click handler has to directly use IO actions. For example, it could use actions of a different type which are then reinterpreted as IO actions.
07:06:47 <Yoric> Cale: Fair enough. I was coming at the problem from a different direction.
07:06:48 <Cale> Yoric: Assuming that you have a usual sort of GUI library, probably your event handlers are defined in terms of IO actions to start with, and then if you need to pass to something more restricted, it's no trouble
07:06:59 <Yoric> hyperisco: But who would interpret them?
07:07:09 <hyperisco> Yoric, no absolutely not. unsafePerformIO is never required here.
07:07:19 <Cale> So, if you want to live in the Foo monad then, you just need some runFoo :: Foo a -> IO a or some such
07:07:34 <Yoric> But who interprets the `IO`?
07:07:36 <Cale> which interprets Foo actions as IO actions
07:07:38 <Yoric> Ah, the runtime for the UI?
07:07:45 <Cale> The Haskell runtime system interprets the IO
07:07:57 <hyperisco> Yoric, as Cale is explaining. Some would call it a "natural transformation" from Foo to IO.
07:08:00 <Yoric> Sure, I meant who passes it to the Haskell runtimme.
07:08:15 <Cale> Well, eventually it all ends up as part of the IO action called main
07:08:19 <Cale> and main gets executed
07:08:37 <Yoric> Ok, that makes sense.
07:08:40 <maerwald> merijn: what do you think about having a primitive 'S.foldr' for your streaming library that runs all effects for some monads strictly and for others not. It'll be hard to know what happens once people build more complicated abstractions
07:09:04 * Yoric wonders how that would translate to other programming languages.
07:09:59 <hyperisco> Yoric, in practice it doesn't because the syntax ends up unmanageable.
07:10:20 <Yoric> hyperisco: It doesn't what? Translate?
07:10:42 <maerwald> when I do streaming, I *always* expect the effects to be lazy... that's the whole point of it
07:10:56 <hyperisco> You can translate it. I am saying that the result is too difficult to use syntactically.
07:11:00 <Cale> Well, in other programming languages, usually main is still a thing -- it's just some procedure that you define in terms of other procedures. The new thing in Haskell is having a special type for these unrestricted procedure things, along with functions for combining those together in a higher-order sort of way.
07:11:02 <Yoric> Truth be told, I'm currently thinking about the best way to encode effects (as in "types and effects discipline") in Rust.
07:11:08 <hyperisco> Unless we are talking about similar languages with do-notation
07:11:17 <Yoric> `IO` would definitely be impossibly ugly to translate.
07:11:32 <Yoric> Rust's lifetimes give other possibilities, however.
07:11:41 <Yoric> *typed lifetimes*, that is
07:12:09 <hyperisco> I have seen a plausible concept using generator notation i.e. yield
07:12:11 <jsxof> maerwald: Sorry that it took me so long. I just need to install it on aarch64, but being able to actually make it into a package for Void Linux would be even better (and that requires cross-compilation).
07:12:15 <Yoric> Cale: Oh, I hadn't followed that. I haven't written Haskell code in... 10 years, I guess.
07:12:27 <Yoric> hyperisco: `yield` as a syntax for monadic bind?
07:12:31 <maerwald> jsxof: https://downloads.haskell.org/~ghc/8.8.2/ghc-8.8.2-aarch64-deb9-linux.tar.xz
07:12:49 <hyperisco> Yoric, yes.
07:12:51 <jsxof> maerwald: Ok, thanks.
07:12:52 <maerwald> I can add aarch64 to ghcup if someone actually uses that
07:12:58 <Yoric> hyperisco: I'm not too nervous about that part of the syntax. I'm much more nervous about the resulting types :)
07:13:29 <Yoric> Given that in Rust, the type of two distinct closures with the same functional type signature is different.
07:13:45 <Yoric> And that Rust only has very limited support for existentials.
07:13:51 <Yoric> It quickly gets complicated :)
07:13:52 <solonarv> Rust currently doesn't really have higher-kinded types, which makes it hard to write general 'Monad' things
07:14:09 <solonarv> but that is really the only type system feature it's missing to implement IO
07:14:10 <hyperisco> Rust has rich metaprogramming capability, so at worst you can leverage that to ease syntax problems.
07:14:12 <Yoric> solonarv: Sure, I was thinking of a specific monad, not a type family.
07:14:36 <solonarv> yeah, if you just want to define a specific monad you shouldn't run into too much trouble
07:14:52 <hyperisco> That said, from my experience, if you want to actually build a product rather than toy around, you don't want to be going against the grain of the tools you are using
07:15:13 <Cale> Yoric: Just to be clear, "a specific monad" would refer to the type-level constructor, like IO or Maybe, and not the values, like getLine or Just 4
07:15:17 <Yoric> hyperisco: Sure. But right now, I'm just doing thought experiments :)
07:15:27 <Yoric> Cale: Yeah, that's what I mmeant.
07:15:31 <Yoric> Cale: Yeah, that's what I had in mind.
07:15:33 <Cale> Okay, cool :)
07:16:50 <hyperisco> Yoric, okay, best of luck. From what I have seen of Rust they special-cased Either syntactically, leaving every other eligible type in the cold. I would not expect great success without metaprogramming.
07:17:21 <hyperisco> But then metaprogramming itself is quite close to yielding any possible success.
07:17:51 <Yoric> hyperisco: You mean the `?` operator? It's actually syntactic sugar on top of a trait (i.e. a typeclass).
07:18:04 <solonarv> yes, that's special-cased do notation for 'Either'
07:18:35 <Yoric> I'm sure it can be abused for other things :)
07:18:38 <solonarv> with some irrelevant details like the parameters being flipped, the name being different, and the From/Into thing
07:20:16 <Yoric> I feel that, in Rust, the more idiomatic transformation would be to have a thread in charge of I/O and have the U/I callbacks communicate with that thread. But I wonder if this gives us any interesting type-level information.
07:21:12 <Yoric> That is, the thread would own the `FileIO` (arbitrary name) effect/capability and delegate this capability through channels.
07:24:54 <hyperisco> Yoric, I have found event handlers to typically be a lot of trouble. They hide away, causing global effects at unforeseen times.
07:25:30 <Yoric> hyperisco: Yeah.
07:25:45 <Yoric> I wonder how many people code UIs in Haskell.
07:26:06 <hyperisco> Yoric, I prefer an event queue that I can dequeue and deal with. i.e. all events arrive to the same spot, and by doing so there is a little less mystery.
07:26:26 <dminuoso> Yoric: Regarding IO, In some sense, it might be helpful to think of "IO" as the regular effect that other traditional languages have by default. The speciality of Haskell is not the fact that we have IO, but the fact that we can leave it away or replace it with something else. 
07:26:46 <Yoric> dminuoso: Makes sense.
07:26:51 <solonarv> Yoric: I will be coding a UI soon, I am getting back to working on my game :)
07:27:13 <Yoric> hyperisco: But where does that even queue live?
07:27:25 <hyperisco> Yoric, in main memory?
07:27:50 <Yoric> solonarv: That's cool :) I remember a ICFP talk by someone who had written a gaming toolkit to teach programming in Haskell to young-ish children (I don't remember the age).
07:28:16 <dminuoso> Yoric: And in order for that to work, we need to have IO as an explicit thing in our type system. So in C++ or Python *everything* can be thought of as IO embellished, since you can do side-effects absolutely everywhere. :)
07:28:37 <Yoric> hyperisco: I mean, where in the program? Is the UI runtime returning a lazy (infinite-ish) queue of events?
07:29:10 <hyperisco> Yoric, in the natural transformation
07:29:22 <solonarv> eugh, no, lazy IO is such a mess!
07:30:39 <Yoric> hyperisco: So the difference is that instead of describing your callbacks in the definition of the UI, you're describing the events you wish to receive, and then you define the logics of callbacks somewhere else?
07:31:02 <hyperisco> Yoric, yes
07:31:09 <Yoric> ok, got it
07:31:44 <hyperisco> UI libraries often have some notion of encapsulation like a "component" or "widget" or some such. It makes sense to have events which do not leave such an encapsulation.
07:34:36 <Yoric> I just realize that executing IO-bound code in UI callbacks doesn't make sense for performance reasons anyway, so dispatching to another thread makes sense regardless of whether it improves type information.
07:35:59 <hyperisco> Yoric, absolutely.
07:46:19 <kuribas> Yoric: I/O is badly named
07:46:46 <kuribas> Yoric: well IO.  It's not just input/output, but also any other side-effect
07:46:52 <merijn> I disagree (or rather I agree, but not for this reason)
07:47:38 <kuribas> Although you could say that all side-effects are doing I/O in the CPU, but then so do many pure computation.
07:47:42 <merijn> The fact that IO has come to mean only like file/network/etc. in other contexts is silly
07:48:46 <dmj`> Yoric: I code UIs in Haskell, every IO action is handled async in a separate thread
07:49:00 <kuribas> merijn: updating a mutable variable isn't really IO is it?
07:49:11 <dmj`> Yoric: keeps the main thread focussed on drawing
07:49:55 <kuribas> solonarv: it can be handy if you are careful.
07:50:10 <kuribas> solonarv: and consume what you produce right away.
07:51:34 <Yoric> dmj`: Makes sense.
07:51:54 <dmj`> I fake encapsulation using the "zoom" function from lens
07:52:38 <solonarv> yeah, zoom is great!
07:52:51 <dmj`> solonarv: it really is, changed my life
07:53:03 <solonarv> it's not even fake: the inner action really can't access anything else in the outer state
07:53:43 <solonarv> no matter how nicely encapsulated your code is, at some point it has to be take out so it can actually run
07:53:48 <dmj`> "One weird lens to change your life, type theorists hate him"
07:53:54 * hackage yesod-core 1.6.17.2 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.17.2 (MichaelSnoyman)
07:54:15 <dmj`> solonarv: well, compared to people who use "Widget" abstractions. My components are pure, its really all apart of the same state variable (record)
07:54:37 <dmj`> solonarv: Widget isn't really an algebraic thing, its more like an IO blobby-thing
07:55:19 <dmj`> solonarv: so the operation over the zoomed state is encapsulated, but the state itself isn't really.
07:55:20 <Yoric> dmj`: I'm not familiar with lense, I'm afraid.
07:55:56 <Yoric> What does `zoom` do?
07:56:04 <dmj`> Yoric: that's ok, but it's nice sugar for updating records. If you have deeply nested data types you want to use it
07:56:31 <dmj`> Yoric: lots of over-engineered Haskell code uses lenses on datatypes that aren't deeply nested
07:56:42 <solonarv> quick answer: a (l :: Lens' s a) is a pair of a getter (view l :: s -> a) and a setter (set l :: a -> s -> s)
07:57:17 <Yoric> solonarv: ok
07:57:24 <Yoric> dmj`: Ok
07:57:31 <solonarv> the nice thing about lenses is that you can compose them easily to reach deeper into some data structure
07:57:40 <dmj`> yea lenses form a category
07:58:04 <dmj`> Yoric: what kind of UI are you creating? Desktop? Web?
07:58:29 <Yoric> dmj`: I'm actually not. I'm writing a blurb on types and effects in various programming languages and my mind started wandering :)
07:58:36 <solonarv> and also, you can mix them with other similar things like: traversals, whose getter isn't really a getter but instead looks like (toListOf l :: s -> [a])
07:59:10 <solonarv> there is a whole zoo of these things (they're called "optics", because the two most visible ones are Lens and Prism)
08:00:53 <Yoric> dmj`: Plus, in truth, most of my code is in Rust these days (when I'm lucky – other days, it's C++). So next time I write a UI, it will probably be in Rust.
08:01:44 <dmj`> Yoric: what's wrong with C++
08:03:10 <dmj`> dangling references got you down?
08:03:30 <Yoric> dmj`: Besides the fact that it's a minefield full of undefined behaviors, memory leaks, that error messages typically have nothing to do with the problems, that it's verbose, that overloadings of all sorts and macros mean that you can't trust the code you're looking at, ...
08:03:57 <Yoric> dmj`: Yeah, my latest bug was indeed dangling references. Caused crashes in an entirely unrelated part of the code. Not even a warning.
08:04:20 <Yoric> My fault for attempting to use closures in C++, I guess. But then, that's required by the API I was using.
08:06:20 <Cale> If someone deleted all the C++ compilers and copies of the C++ specification in the world, the efforts of the entire world would probably not manage to reproduce the same language.
08:08:42 <merijn> Cale: I'm honestly not sure that we actually *have* a C++ compiler (i.e. that implements the spec) and, more importantly,  have no idea how we'd even check!
08:08:56 <dmj`> Yoric: I heard good things about C++17 and C++20 
08:08:59 <Cale> merijn: That's true, I was considering leaving the compilers out of it
08:09:02 <merijn> Cale: I said the same about C, but then I remember compcert :p
08:09:36 <merijn> dmj`: Define good ;)
08:09:43 <dmj`> Yoric: why not just extern "C" a few things and call them from Haskell. Problem solved.  Or is the situation not salvageable
08:09:49 <nshepperd2> a team of software archeologists, recovering a programming language from ancient stackoverflow posts
08:09:57 <dmj`> merijn: you deal less with manual memory management
08:10:13 <Cale> nshepperd: and that language is C++ *shiver*
08:10:20 <Yoric> dmj`: Well, if you only use the new features, things are not quite as bad. But if you have an existing codebase, that's not an option.
08:10:39 <Yoric> dmj`: We're not going to add a Haskell compiler to our dependencies at this stage :)
08:11:17 <merijn> dmj`: C++11/14 already mostly deal with that
08:11:28 <merijn> dmj`: C++17/20 impact that fairly little
08:12:46 <dmj`> Yoric: Next monday tell your boss the dangling pointer tech debt is too much, time for a safer language, I propose we rewrite everything using GHC and only FFI into C++ for performance critical tasks
08:13:12 <Yoric> dmj`: I'll tell them that. I don't think we have more than 50 million lines of code, should be a breeze :)
08:13:54 <dmj`> Yoric: Ask him if you can pilot a small part
08:14:17 <Cale> 50 million, nice
08:14:24 <Yoric> dmj`: Ok, just checked, it's only 21 millions.
08:14:30 <Yoric> Much easier :)
08:14:43 <dmj`> Yoric: give or take 30M
08:14:55 <dmj`> Yoric: Actually, nix works great with Makefiles, you can add the C++ deps. directly to the Haskell pkgconfigDepends section.
08:15:27 <Yoric> dmj`: My office neighbour keeps trying to convince everyone to switch to nix. You already have someone in the place :)
08:15:42 <Yoric> But for the moment, any code we rewrite, we rewrite in Rust.
08:15:50 <Yoric> And code we don't rewrite... well, we keep in C++.
08:15:55 <Yoric> Or in JavaScript.
08:16:23 <dmj`> Yoric: Nix and Rust work great as well. Nix and javascript, not so well. 
08:16:40 <dmj`> Yoric: Nix would be a good angle for using Haskell, since its got everything cached.
08:16:49 <dmj`> Yoric: what build tool do you currently use?
08:16:56 <dmj`> just one giant make monster?
08:17:02 <maerwald> rust doesn't work well on most distros
08:17:13 <maerwald> needs some hacks
08:17:13 <Yoric> dmj`: I think it's a custom build because make didn't work correctly on Windows.
08:17:24 <Yoric> Ah, my train is arriving.
08:17:31 <dmj`> Yoric: Nix also has a musl toolchain, so you can statically link your Haskell easier, for deploys.
08:17:31 <Yoric> I'll have to start packing.
08:17:44 <Yoric> Thanks everyone, I'll try and rejoin later!
08:18:08 * dmj` cries wait Yoric, wait... runs after train
08:20:10 <maerwald> nix evangelism ;)
08:20:26 <dmj`> it's just so underrated
08:20:32 <maerwald> lol
08:20:35 <dmj`> solves such a huge problem
08:20:57 <Taneb> Only creates a few more ;)
08:21:11 <dmj`> Inflexible ops really constrains the decision making processes for tech choices in organizations
08:21:12 <maerwald> and the problem it solves isn't actually the problem that most people care about
08:21:36 <Taneb> (I'm very pro-nix, actually, just having to deal with some of the problems it leads to when tools make assumptions that Nix doesn't like)
08:22:57 <maerwald> wrt rust packaging: https://undeadly.org/cgi?action=article;sid=20200109141600
08:23:02 <Taneb> Because this is #haskell and not #nixos, does anyone have a nice way of adding HLint enforcement to the standard Travis CI Haskell build script
08:23:20 <dmj`> maerwald: they begin to care once they hit onboarding problems, deployment problems, dependency problems and realize that software development is more than just getting their for loops right
08:23:20 <Philonous> I love nix-the-idea, but I'm suspicious about nix-the-language. It seems to encourage ever-growing towers of abstraction where every sub-community develops its own structures and idioms, and it doesn't even have the type checker to keep it on the rails
08:23:45 <maerwald> dmj`: Yeah sure. I've got rid of nix in my last company, because it was endangering onboarding and deployments.
08:23:53 <maerwald> So it can go both ways
08:26:50 <maerwald> Philonous: yes, the complexity is unmanagable, unless you put a lot of time and effort into it
08:27:14 <maerwald> And all that for configuration reproducibility (which, most of the time, you don't even need)
08:27:58 <maerwald> For huge companies with lots of resources, that extra level of correctness can make sense
08:28:45 <vitamin-D> can you use haskell to combat coronavirus
08:29:07 <dmj`> maerwald: nix definitely won't hinder onboarding and deployments, but nix is difficult to learn and people don't like what they don't know
08:29:29 <maerwald> dmj`: it does, because when the only guy in your startup team who knows nix leaves, what do you think happens?
08:29:38 <merijn> dmj`: I like Nix conceptually, I just don't like the concrete implementation of it >.>
08:29:40 <dmj`> maerwald: the build still works
08:29:46 <maerwald> dmj`: lol, wtf
08:29:48 <dmj`> maerwald: even when he leaves lol
08:29:58 <maerwald> You have to have control over your CI dude
08:30:20 <dmj`> maerwald: well he should be knowledge sharing with everyone
08:30:30 <maerwald> Nice in theory
08:30:33 <dmj`> maerwald: the CI is just calling nix-build
08:30:38 <maerwald> ...
08:30:54 <Taneb> maerwald: the same problems exist with any build process. If only one person understands it, and they leave, you'll have problems
08:30:57 <merijn> dmj`: And the build configuration never changes? >.>
08:31:04 <maerwald> Taneb: nah, picking up docker and ansible is done in days
08:31:14 <dmj`> merijn: of course it does, but if he wrote it correctly its easy to add new deps.
08:31:22 <maerwald> dmj`: no.
08:31:34 <Taneb> maerwald: I disagree with that assertion, from personal experience
08:32:16 <dmj`> maerwald: I've written all the nix for a company before, Haskell, C++, Python, it was fantastic. Deployments with NixOps to AWS. New users just called `nix-shell` and they were off to the races.
08:32:41 <dmj`> maerwald: calling `nix-build release.nix` was all the CI did
08:32:44 <maerwald> Right, it was a nightmare for us
08:32:54 <maerwald> And the best decision was to remove it
08:33:57 <dmj`> maerwald: it's like choosing Haskell and saying you don't get Monads and that it was a nightmare and the best decision was to remove it.
08:34:22 <dmj`> I'd agree nix doesn't support incremental builds and thats a problem
08:34:27 <dmj`> for Haskell
08:34:41 <mananamenos> Is it a very bad implementation of simple dictionary https://hastebin.com/inevufayan.nginx. Or should i use a Map data structure? What are the advantages? Is it only the speed?
08:34:58 <maerwald> Yes, you don't introduce haskell in a company, just because you want to write shake, although a simple Makefile would suffice. That's basically the same thing and your colleagues will thank you once you left
08:37:18 <solonarv> mananamenos: this is not "very bad" if it's small, but I do find it a bit weird
08:37:20 <dmj`> maerwald: Learning is part of any job.
08:37:21 <solonarv> I'd just use a Map
08:37:29 <maerwald> dmj`: no one has time to learn nix in a startup
08:37:55 <maerwald> Especially if there's no value to having it, but it was just an ad-hoc decision from someone who was familiar with it
08:38:05 <dmj`> maerwald: Ideally they shouldn't have to. Nix scripts just need to facilitate their dev process.
08:38:12 <maerwald> They have to
08:38:15 <mananamenos> thanks solonarv
08:38:30 <maerwald> Doing anything with nix requires deep knowledge
08:38:41 <dmj`> maerwald: I'd agree everyone should do ops, but most companies demarcate dev ops from software engineer
08:38:52 <Taneb> maerwald: that's entirely false
08:39:21 <[exa]> dmj`: everyone should _understand_ system administration, especially ops
08:39:25 <maerwald> dmj`: I don't agree. If you use nix in your company, you need a *specialist*
08:39:27 <maerwald> at all times
08:39:50 <dmj`> [exa]: completely agree, understanding is different than being responsible for
08:40:17 <maerwald> Some companies (like google), use gentoo for their stuff and builds. They hire gentoo devs, because you can't expect random devs to pick up that specialized knowledge.
08:40:44 <[exa]> dmj`: also, it is useful to practice the situation when something breaks and suddenly all fingers are pointing to someone (you); it really keeps the deployment&structure simple and great
08:41:56 <solonarv> mananamenos: to elaborate a bit: the only thing it's possible to do with your representation is look something up
08:42:08 <[exa]> maerwald: "install gentoo from stage1" is a great test. :D
08:42:09 <maerwald> So sure, in my 4 years of working on gentoo, I acquired that knowledge. So yeah, I could just introduce gentoo in a startup, because hey, they can just learn it, right? Well, no.
08:42:45 <maerwald> I don't mind people being fans of tools, but they need to be realistic.
08:42:47 <solonarv> on top of this, you can't really distinguish between "the lookup failed" (and maybe try some fallback) and sucess
08:43:32 <maerwald> And the time it takes to teach all the EAPIs to a newcomer... I'd rather fix all problems myself.
08:43:36 <solonarv> finally, if your translation is not really really tiny what you are doing is slower
08:43:47 <dmj`> maerwald: I've used nix in a five person startup, we were all able to focus on the business logic instead of nix itself and moved a lot faster to market. You have to trust the person doing it to do a good job. But these people didn't want to do ops, they wanted to focus on the business logic. Most things we edited were just tweaking the NixOS config and the systemd scripts.
08:44:08 <dmj`> [exa]: that's happened, but was able to always fix it.
08:44:11 <maerwald> dmj`: Yes, it worked well, so as long as that one guy who knows nix stays in the company.
08:45:38 <dmj`> maerwald: Can't argue with that, its about the relationship with that person.
08:45:57 <maerwald> dmj`: you know about bus factor?
08:46:11 <maerwald> If you want to increase the risk for your startup, then sure
08:47:17 <dmj`> maerwald: The build scripts weren't as big of a problem as someone using crazy type level Haskell chicanery that nobody could understand.
08:47:33 <maerwald> We all knew haskell, so
08:47:36 <dmj`> Bus factor was more relevant when it came to the business logic
08:48:00 <maerwald> Oh man, isovector quit?
08:49:10 <maerwald> https://sandymaguire.me/blog/burnout/ :/
08:49:37 <dmj`> maerwald: Knowing Haskell doesn't make you immune to people's type choices. 
08:50:35 <maerwald> dmj`: yes, and I'm highly suspicios of people who don't consider the impact of their choices on their team :)
08:51:02 <maerwald> Sometimes you have to knock down that curiosity of trying something out, it might not be worth it
08:51:54 <maerwald> who's going to maintain polysemy now? Is it considered dead?
08:52:10 <dmj`> maerwald: Depends on the person who wanted to try it out. If they're green and want to play with a toy, then tell them this is a business. If they've used nix and had customers and operations depend on it, it might be worth considering the upsides.
08:52:34 <dmj`> maerwald:  This means your tech choices will always be the lowest common denominator of the team's knowledge, in every case.
08:53:19 <maerwald> dmj`: if you have a single jenkins instance (a single one, yes, just one) then there's really zero use of nixifying everything of it, just so you have a "backup" of your config (which is all you care about)
08:53:24 <maerwald> And that's just one example
08:55:58 <Ashutosh> Hi all -- I have been using C++ professionally at my work for over 5 years now. As part of my new year resolution, I started to learn Haskell in my free time (<functional> in C++ got me excited to begin with). 
08:56:22 <dmj`> maerwald: I can't speak to your setup, maybe that's true. We had a monorepo that built and deployed 5 websites, a docker container, and a CLI tool that was used in 50+ System-D scripts. Used hosted Travis CI and deployed from it to AWS. 
08:56:57 <dmj`> maerwald: guarantees that local, CI and cloud were all the same code was great.
08:57:10 <dmj`> but yea it wasn't easy getting there all the time
08:57:41 <ChaiTRex> Ashutosh: hello
08:57:53 <Ashutosh> I was following Haskell Programming from First Principles loved doing it's exercises. Although, I think it suggests I take a break after Monads chapter to come back at a later time to be able to follow the further chapters. I found the real world examples very hard to follow as well.
08:58:22 <maerwald> dmj`: the problem is, it's already hard to hire haskellers for a startup. Now you need a haskeller, who is *very* proficient in nix as well, because you don't have the bucks for a full-time devops position. And you see those job descriptions popping up a lot (nix devops with haskell experience)
08:58:56 <maerwald> Because somewhere someone introduced it, then changed jobs and the remaining team needs to deal with it
08:59:49 <[exa]> Ashutosh: that's a common feeling thb. :]
09:00:17 <[exa]> *tbh
09:00:20 <Ashutosh> Would you suggest some exercise format practice problems that drives me slowly to have an intuition for the abstract constructs? I have done much 99 problems but I wanted to rather practice typeclasses (Monoid/Applicative/Monads) 
09:01:10 <[exa]> Ashutosh: usually learning these things reduces to finding a _good_ problem where the monadic stuff really shines; for me these were monadic parsers
09:01:38 <dmj`> maerwald: yea, bus factor is a real problem. I can't argue with that. Need to find a loyal Nix / Haskeller. Most Haskell people probably aren't /very/ proficient with it either. Haskell people don't want to write Nix full time most likely and that's what it would take.
09:01:40 <maerwald> dmj`: so yeah, I guess *you* won't have problems finding something else ;)
09:01:52 <Ashutosh> Hi exa! How did you deal with the blockade? Or is it something that would come slowly by say keep looking at examples and patterns that arise
09:01:54 <dmj`> maerwald: yea, its a sad state affairs
09:02:50 <[exa]> Ashutosh: you just need to translate the monadic stuff into something you understand now; so I suggest bottom-up approach
09:04:05 <maerwald> dmj`: whenever someone asks me if they should use haskell, I say "no", because if they really needed it, they would already know.
09:04:31 <[exa]> Ashutosh: did you get Functors?   (danger: completely unrelated to OOP-style functors!)
09:05:09 <dmj`> maerwald: its the unknown-unknowns :)
09:06:21 <Ashutosh> yeah. functors were intuitive enough since CPP is already well designed wrt containers. The analogy extended well (or so I think). I like to use CPP's <functional> whenever I can, which is mostly to accumulate or transform.
09:08:15 <spew> is there a more navigable syntax reference manual for haskell 2010?
09:10:10 <hseg> Hi. I have a type family T :: 'Bool -> 'Bool -> `Nat, and want to write a function that is morally t :: (p::'Bool) -> (s::'Bool) -> Vector (T p s) Integer. Is this possible? 
09:12:14 <[exa]> Ashutosh: applicatives are then for "combining the wrappers" into one, which may affect the "shape" of the data. Are you okay with stuff like `Just (+3) <*> Just 5` or `Left "error" *> Right "something"` etc?
09:14:56 <lyxia> hseg: have you tried singletons
09:15:44 <hseg> Could work
09:16:25 <Ashutosh> exa: That's a great way to put it. I have very little intuition for them, so when I see anything like this, I fall back to the type signature of the operator ie., <*> to mean the lifted function applied to a lifted value.
09:17:00 <[exa]> which is generally the right way, but won't give you the examples for the intuition :]
09:17:18 <hseg> lyxia: Am I perhaps overengineering this, though? Possibly, it would be easier to have a class T' (p::'Bool) (s::'Bool) with associated type T and class method t 
09:17:52 <[exa]> Ashutosh: motivating example for Applicatives: [(+1),(*2)] <*> [1,2,3]  ("Applicative list instance captures nondeterminism")
09:17:58 <maerwald> https://leanpub.com/thinking-with-types is this a good book?
09:18:06 <Ashutosh> exactly, with my approach, I dont readily get the feel for a use case.
09:19:00 <lyxia> hseg: I don't think so
09:19:06 <[exa]> Ashutosh: another motivating example is the error-shortcutting: 'Just' means OK, 'Nothing' means "error happened", same for Right/Left of Either. (see the examples below and try to combine them in new ways)
09:20:09 <[exa]> Ashutosh: in that way, <*> can be seen as normal function application (ie. normal computation), but hiding some extra meaning that you consider "plumbing", e.g. the errors or nondeterminism
09:20:26 <Ashutosh> Like, with types, I can relate. To say, Maybe is an optional value and so on. But the further abstractions are HARD. XD For an analogy (sorry) it's like flatland where 2d inhabitants find 3rd dimension unreal to believe in.
09:20:57 <[exa]> Ashutosh: try the examples, it's not that hard, just extremely generative :]
09:21:43 <Ashutosh> exa: By further abstractions, I mean the typeclasses like Applicatives/Monads.
09:22:45 <[exa]> Ashutosh: after you play with the lists/errors, the usual bottom-up step is looking at functions as "containers for results", which helps a lot with monads later
09:23:09 <Ashutosh> exa: on your further explanation of Applicative, I understand now. The nondeterminism/error cases come from the type itself and the way to combine them comes from the type class.
09:23:31 <[exa]> Ashutosh: prime example of that: runLengthEncoding = map ((,) <$> head <*> length) . group
09:24:30 <[exa]> Ashutosh: yes, the point is just that all this behavior with some extra information above the computation "behaves the same" and therefore "should be hidden in the same way", thus the typeclass
09:26:11 <[exa]> Ashutosh: let me know if you get how the runLengthEncoding works
09:26:59 <Ashutosh> exa: I completed this exercise on 99problems today and no way I could ever think of employing applicatives to solve it. and your solution looks so intuitive too...
09:29:52 <Ashutosh> exa: (,) is an instance of applicative, the map part is confusing me though 
09:30:00 <[exa]> anyway the <$> <*> is basically a nicer synonym for `liftA2` and other liftAs, nicely expandable to infinity:
09:30:12 <[exa]> perhaps easier to show on actual containers:
09:30:19 <lyxia> hseg: if there is anything that looks overengineered that would be wanting to have dependent types in the first place, but if you can't work around it then singletons is worth considering.
09:30:30 <[exa]> % (+) <$> Just 5 <*> Just 10
09:30:31 <yahb> [exa]: Just 15
09:30:34 <glguy> In this case (\x -> (head x, length x)) is one character longer and is clearer
09:31:12 <[exa]> Ashutosh: ^^^, <$> is the same as `fmap`
09:31:54 <[exa]> glguy: but pointless errr pointfree...!
09:32:38 <Ashutosh> exa: I think I misread it the first time :(. 
09:32:48 <hseg> lyxia: I'm modelling a set of four related families of linear systems, with "trivial" and "nontrivial" eigenvalues. #nontrivial is the same across the families, but #trivial ranges between 0-2. Want to basically write eigenValues :: Vector (trivial + nontrivial) Complex
09:32:52 <[exa]> Ashutosh: another example, ` (,) <$> [1,2,3] <*> "abc" `
09:33:12 <hseg> lyxia: So I'm kinda stuck needing dependent types
09:34:15 <[exa]> Ashutosh: which is the same as `pure (,) <*> [1,2,3] <*> "abc" `, which should kindof show that <*> is basically a function application wrapped in some extra meaning
09:34:26 <glguy> Ashutosh: (Ashutosh: exa: (,) is an) -- While it's true that there's: instance Monoid e => Applicative ((,) e) -- That's not what's happening here
09:35:12 <glguy> The code above was using: instance Applicative ((->) r)
09:35:25 <[exa]> glguy: I know, I overcomplicated it a bit by the <$>
09:35:28 <Ashutosh> exa: nice. Here the listOf functions gets `ap` onto listOf values. Although the whole M X N results confuse me, somehow I expected this to work like zips
09:35:48 <ChaiTRex> Ashutosh: It works like Cartesian products.
09:36:07 <[exa]> Ashutosh: that's because list instance is written to capture non-determinism, which is basically "all combinations"
09:36:08 <ChaiTRex> Ashutosh: Very useful for some things.
09:36:24 * hackage hhwloc 0.2.1 - Bindings to https://www.open-mpi.org/projects/hwloc  https://hackage.haskell.org/package/hhwloc-0.2.1 (dtaskoff)
09:36:42 <[exa]> Ashutosh: AFAIK there's another list type which just zips, as you expected, but it's not the default []
09:36:59 <solonarv> Ashutosh: as a matter of fact, the "zippy" instance exists as well if you use the ZipList wrapper
09:37:10 <[exa]> o nice. ^
09:37:57 <Ashutosh> exa: Lists capture non-determinism coz empty list is a possibility? Isn't that a Maybe then
09:38:31 <solonarv> the reason that 'Applicative []' is a cartesian product is that Applicative must "match" Monad when both instances exist, and the Monad [] instance is also product-y (and there can't be a "zippy" one)
09:38:40 <ChaiTRex> Ashutosh: Nondeterminism means trying multiple things at once, in a sense, not that a value might not be produced.
09:38:53 <[exa]> Ashutosh: well lists with maximum 1 elements are basically just like Maybe, you have either 1 thing or 0 things
09:38:55 <solonarv> no, lists capture nondeterminism by simply keeping a list ( :D ) of all the possibilities
09:39:12 <ChaiTRex> Ashutosh: I mean, yeah, the empty list is for when no value is produced, but that's only one possibility.
09:39:14 <Ashutosh> exa: Aah. I see. thanks again! 
09:39:17 <solonarv> so the nondeterministic value "1, 2 or 3" is represented by the list [1, 2, 3]
09:39:39 <[exa]> also "all the possibilities" like solonarv said is probably the best explanation for all list instances I know
09:39:54 <Ashutosh> @all: thank you guys. This is amazingly helpful to me.
09:39:54 <lambdabot> Unknown command, try @list
09:40:04 <Ashutosh> all: thank you guys. This is amazingly helpful to me.
09:40:25 <[exa]> Ashutosh: let us know when you're okay with <$> <*> :]
09:43:13 <lukebfox[m]> can i just drop in and say I am at in a similar position to ash but got a bit further before the block set in
09:43:13 <Ashutosh> exa: so, <$> takes a (binary function?) and sort of pushes it into a container type? and that container has to have an Applicative instance to combine the container of functions with container of values?
09:44:16 <Ashutosh> lukefox[m]: hey, welcome!
09:44:34 <lukebfox[m]> hey bro
09:44:36 <lukebfox[m]> struggle is real!
09:44:38 <lukebfox[m]> fun tho
09:45:04 <solonarv> Ashutosh: pretty close!
09:45:14 <solonarv> but (<$>) actually just needs a one-argument function
09:45:23 <solonarv> note that *all* functions in Haskell take one argument
09:45:51 <Ashutosh> lukebfox[m]: even with my level, I feel really good after I have solved a problem though.
09:46:12 <lukebfox[m]> from my understanding <$> takes a unary function which requires some value, and a wrapped value, and returns the result of applying that function to that value, wrapped.
09:46:42 <lukebfox[m]> yeah haskell is so nice to write in going back too oop feels dirty
09:47:10 <solonarv> I'm not a big fan of the "wrapped value" analogy, tbh
09:47:13 <Ashutosh> solonarv: aah, got it! I should better go re-do these chapters a few times to have that clear :P
09:47:39 <solonarv> "containers" gets you further because it reminds you that there might be any number of values and there may or may not be some other stuff too
09:47:46 <lukebfox[m]> it is a bit meaningless isnt it
09:47:58 <mananamenos> in postgrest github readme they state: *Being stateless to allow horizontal scaling*. If there were a need to scale, what would be the differences comparing it with traditional haskell web server. In traditional server, i suppose you would need a load balancer first to scale horizontally. However in case of posgrest, you run ./postgrest which gives you a process (like a server), which would need to some kind of load
09:48:00 <mananamenos>  balancing also in case of too many requests? Or do they want to say that only db layer scaling would be needed (like using EnterpriseDb). Maybe someone could give me a high level picture of this.
09:48:00 <lukebfox[m]> ok good point
09:49:21 <solonarv> Ashutosh: when we want to write multi-argument function we usually do this in "curried" style: a unary function that returns another unary function... and so on until we've got all the arguments
09:49:49 <[exa]> Ashutosh: <$> is the actual fmap from functor, it just takes whatever and applies it to a container
09:50:15 <solonarv> this means if you have a "binary function" 'f :: A -> B -> C' this is really the same as 'f :: A -> (B -> C)'
09:51:18 <[exa]> Ashutosh: the example `(+) <$> Just 1 <*> Just 2` is equivalent to `((\a b -> a+b) <$> Just 1) <*> Just 2`
09:51:58 <lukebfox[m]> do <*> and <$> associate left
09:52:02 <Ashutosh> solonarv: got it. I remember it works coz (->) associates to right
09:52:04 <[exa]> Ashutosh: which continues to `Just (\a -> a+1) <*> Just 2`  (using fmap)
09:52:36 <[exa]> lukebfox[m]: just like function application, yes
09:52:42 <lukebfox[m]> ok
09:52:49 <solonarv> in fact you can check this in ghci
09:52:53 <solonarv> % :info <*>
09:52:54 <yahb> solonarv: class Functor f => Applicative (f :: * -> *) where; ...; (<*>) :: f (a -> b) -> f a -> f b; ...; -- Defined in `GHC.Base'; infixl 4 <*>
09:53:02 <[exa]> Ashutosh: which finally ends with `Just (1+2)`   (using <*>)
09:54:07 <lukebfox[m]> so <*> sort of gives us composition over some applicative functor?
09:54:08 <Ashutosh> exa: got it
09:55:01 <solonarv> lukebfox[m]: it gives us function application, to be precise
09:55:40 <lukebfox[m]> hmm yes that is right
09:55:44 <Ashutosh> lukebfox[m]: Isn't composition more like a monoid thing.
09:56:16 <Ashutosh> <*> is referred to as `apply` in the book that I was following
09:56:38 <solonarv> not exactly, you can view monoids as a *special case* of composition
09:57:27 <Ashutosh> solonarv: the difference being presence of an identity?
09:57:57 <lukebfox[m]> and monads, i get the List, Maybe and IO examples. enough to fill out Either myself, but it seems like a very abstract pattern given the difference in what it gives us for each instance
09:58:24 <lukebfox[m]> how can one envisage whether a type of ours should be instantiated, and what it's effects would be
09:58:29 <solonarv> Ashutosh: no, the difference is that in a monoid you can "smash together" any two elements
09:58:51 <solonarv> but with e.g. function composition you can only do that if the inputs/outputs match up
09:59:27 <Ashutosh> solonarv: okay
10:02:14 <lukebfox[m]> I think the question I am asking is really how does one design a monad
10:02:38 <solonarv> that depends on what you want your monad to do!
10:03:55 <lukebfox[m]> hmm i think i better do some more reading
10:04:01 <lukebfox[m]> :)
10:04:18 <solonarv> but really, people rarely design a monad completely from scratch
10:04:35 <solonarv> I'd wager that most of the Monad instances you might see out there fall into one of these two categories:
10:04:56 <solonarv>  - an existing data structure where people noticed "hey, turns out this can be a Monad!"
10:05:40 <solonarv>  - a combination of some "building blocks" on top of some base monad (which is usually IO or Identity, the "no special features" monad)
10:07:34 <geekosaur> there's also little point in making a Monad if you won't be using it as such
10:07:51 <Ashutosh> solonarv, exa, lukebfox[m] Thank you guys! I would sleep on what I learnt today. It's late night here. Have a good day. :)
10:08:26 <Ashutosh> Quit!
10:08:32 <sim590> I have some package which I always used that is now hidden. I don't know why?
10:08:37 <lukebfox[m]> Ashutosh: you too
10:09:48 <lukebfox[m]> solonarv: so actually i am trying to build an equational theorem prover in haskell, and i have a long time to do it but i am newish to the language and i have yet to pick up even transformers so my htinking is that I dont know what i dont know
10:10:40 <sim590> I did ghc-pkg expose "package", but I still can't import it after restarting ghci...
10:11:01 <lukebfox[m]> one the one hand I want to get stuck into implementing something based on current level and essentially upgrade my knowledge when the situation demands it
10:11:26 <lukebfox[m]> no the other hand i suspect that a little knowledge up front might go a long way in system design
10:11:49 <lukebfox[m]> given the nature of the language and the problem at hand
10:12:03 <lukebfox[m]> hence whi I am asking such questions
10:14:50 <lukebfox[m]>  * hence why I am asking such questions
10:20:00 <maerwald> where are the type-level wizards :P
10:20:47 <[exa]> lukebfox[m]: "designing a monad" is usually done by looking at the interface (most likely the do notation with `<-` binding), seeing if it can describe your problem, and then just writing the monad instance so that it handles the semantics you invented (aaaaaaaaaaaand done)
10:22:52 <koz_> I would go even further: most of the time, you can get the functionality you want by stacking existing transformers, then GNDing the mtl class instances to make it convenient.
10:23:03 <koz_> I've done literally that like... four times already at my New Haskell Job?
10:23:19 <hyperisco> lukebfox[m], not sure what your question is, but inferring from [exa]'s response my response would likely be: you shouldn't set out to make a Monad but rather have that option in your toolbelt
10:24:16 <lukebfox[m]> perhaps I should practice stacking transformers on a suitable problem first
10:24:44 <lukebfox[m]> transformers are actually where I am up to so this is ideal
10:25:15 <simonpe^^> I want to generate a file according to some set of rules, is there any way of doing this akin to applicative parsing? Are there any libraries specifically made for this?
10:25:43 <koz_> simonpe^^: A pretty printer + file writing?
10:25:55 <hyperisco> simonpe^^, given a grammar you want to generate a sentence in the language (such as by random choice)?
10:26:33 <lukebfox[m]> [exa]: koz_ hyperisco thanks for the advice
10:26:38 <simonpe^^> Let's say I want write a specification for the format of the file in haskell and then use combinators to build something that can be translated to text
10:27:04 <simonpe^^> Idk how to explain it better, I'm not very good with haskell lingo :S
10:27:40 <hyperisco> simonpe^^, if you have a file containing text and you want to parse it, parser combinators are a good choice, such as megaparsec (I hear that is popular). Does that help you?
10:28:01 <simonpe^^> hyperisco, not really, I want to do the reverse 
10:28:43 <hyperisco> If you exclusively want to do the reverse then no, there isn't really anything particularly special I can think of.
10:28:50 <simonpe^^> I want to define the structure of the language in terms of haskell functions and then use combinators so buiid an in memory representation of the file that later can be converted to text
10:29:04 <hyperisco> If you want both directions then bidirectional parser combinators may be of interest.
10:29:23 <simonpe^^> hyperisco, is there any library that you would recommend?
10:29:30 <hyperisco> For bidirectional parsing?
10:29:51 <simonpe^^> Specifically I want to generate a ninja build file but the library I found seems to be horribly outdated and I can't manage to build it using stack
10:30:13 <simonpe^^> yes, for bidirectional parsing
10:30:31 <hyperisco> For any format one typically has an AST. From an AST, you can write out a file again, and this can typically done with simple recursion
10:31:02 <hyperisco> Libraries exist for it but I have not personally used them, so I don't have any recommendations for you
10:31:18 <simonpe^^> ok, but thank you for your time. Mucho obliged 
10:33:20 <Gurkenglas> "asd" can be String or Text, can I use the same machinery to write a function that takes either String or Text?
10:33:50 <hyperisco> Gurkenglas, that depends on what operations you need to do, but possibly not
10:34:08 <hyperisco> IsString is merely a fromString function, or something like that
10:34:15 <Gurkenglas> the only operator i need is (t -> Text)
10:34:29 <hyperisco> Well there is no point to that then. Just write a function that works on Text. Yes?
10:35:10 <Gurkenglas> Across this project, there's a whole bunch of duplicate code, some of which calls pack on Strings and some of which uses text directly
10:35:27 <Gurkenglas> I was hoping to write a function that would let the user not say "pack"
10:35:51 <hyperisco> If you have a function  f :: Text -> A  then you also have  f . fromString :: IsString s => s -> A
10:36:37 <hyperisco> actually that's not right ^.^
10:36:39 <Gurkenglas> that would be f . fromString :: String -> A
10:37:52 <Gurkenglas> But yes, XOverloadedStrings is what I meant, and IsString is its machinery, and it does not help me
10:38:04 <hyperisco> slightly funny because most IsX classes means  a -> X  not  X -> a
10:38:12 <Gurkenglas> wrong
10:38:18 <Gurkenglas> is means (a -> X, X -> a)
10:38:31 <Gurkenglas> you want has
10:38:32 <hyperisco> which ones are you thinking of?
10:38:40 <Gurkenglas> Control.Lens.Iso
10:38:59 <hyperisco> okay, I get that "iso" starts with "is" but it isn't literally "is" :P
10:39:54 <Gurkenglas> I'd point to https://hackage.haskell.org/package/lens-4.18.1/docs/Data-Text-Lens.html but that gives an iso to string, not text :((((
10:41:22 <Gurkenglas> https://en.wiktionary.org/wiki/iso- iso means equal
10:41:48 <hseg> Just found out ½ and ² are valid numeric characters, so e.g. sin½² is a valid identifier
10:41:50 <Gurkenglas> is is the third person form of "to be"
10:42:17 <hyperisco> IsX is a common naming convention for types coercible to X
10:42:23 <geekosaur> not in math usage. isomorphism means you can map to and from equivalent values, but they aren't equal values
10:42:24 <jle`> @let sin² x = sin x * sin x
10:42:26 <lambdabot>  Defined.
10:42:37 <jle`> @let cos² x = cos x * cos x
10:42:39 <lambdabot>  Defined.
10:42:41 <hyperisco> such as when giving an approximation to subtyping
10:42:45 <koala_man> is is ice cream in Norwegian
10:42:48 <jle`> > sin² 2 + cos² 2
10:42:51 <lambdabot>  1.0
10:43:27 <Gurkenglas> geekosaur, yea but surely the distinction between isomorphism and equality is lesser than between isomorphism and morphism
10:43:50 <geekosaur> not to most programming languages, and in particular Haskell
10:43:52 <geekosaur> "xyz" and (T.pack "xyz") do not denote the same value, they are values that can be converted between each other
10:44:10 <geekosaur> but you can't substitute one for the other except in very limited scenarios
10:45:02 <geekosaur> (mono-traversable package lets you construct such scenarios, at the price that if fusion fails it can go O(n²) on you…)
10:45:04 <Gurkenglas> "(a, b) has a first element", not "(a, b) is its first element"
10:45:27 <Gurkenglas> http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-TH.html constructs HasFoo typeclasses which point out lenses, not isos
10:45:54 <hseg> Intuation being that iso things are "morally equal" (to have one is equivalent to having the other), whereas identical things are "equal on the nose" (eg have the same machine representation)
10:46:00 <hseg> *Intuition
10:46:08 <Gurkenglas> hseg++
10:46:13 <hyperisco> Well if you cannot find what you're looking for you can always define it yourself. It is just one instance for String and a second for Text.
10:46:21 <hyperisco> And, if you find what you want later, you can substitute for that.
10:46:37 <hseg> So eg while ((a,b),c) is iso to (a,(b,c), they're not identical (try passing one to a function expecting the other)
10:47:17 <Gurkenglas> Manually introducing another typeclasses for mere overloading seems ill-conceived
10:47:51 <hyperisco> I think Gurkenglas has so fundamentally adopted HoTT they cannot see past univalence ;)
10:47:58 <hseg> :D
10:48:07 <hseg> Gurkenglas is a very moral person
10:48:32 <hyperisco> Okay but that is exactly what you're hoping to find in another library.
10:48:45 <Gurkenglas> Yes, it's like using nazi research
10:49:11 <hyperisco> And using type classes for the mere purpose of overloading is not totally inappropriate. You have my permission.
10:49:27 <Gurkenglas> I don't have *my* permission
10:49:36 <Gurkenglas> as he said, very moral
10:49:43 <hyperisco> If it solves an ergonomic problem for you then you should give yourself permission to accept the solution.
10:51:33 <Gurkenglas> I suppose I can use IsText from lens to make a String, then pack it
10:52:19 <hyperisco> So all your Text values can be repacked? You do you :P
10:53:01 <hyperisco> Maybe there is a rewrite rule in there to change that accident to id
10:53:37 <geekosaur> that's more or less mono-traversable. including lots of rewrite rules, but if they fail you get a lot of unpacking and repacking
10:54:43 <Gurkenglas> It's user interface text, it's not a bottleneck
10:56:08 <hyperisco> Tangentially related. I read recently about "distillation" which is a generalised positive super-compilation and can provide super-linear speedups to programs. Was that work ever applied to GHC?
10:56:47 <hyperisco> Gurkenglas, there is a sub-Twitter that would abhor you for saying that :P
10:57:20 <wildtrees> ok if I streamTake 4 . fmap (streamTake 4) $ streamReals , it is productive, which is better then the reals functions I have commented out, though it's not fair, so it's somewhat useless or trivial for what I want to use it for, basically some sort of witness of a diagonal argument , paste is here https://0paste.com/51251#hl is there a way to get stream to be productive and fair? or even streamReals 
10:58:30 <hyperisco> wildtrees, yeah sure, see for example my ZigZag package or the Omega package
10:58:46 <wildtrees> I understand most of the functions rather well, I wrote them myself, though I don't totally understand streamDiagonal , is there a fair and productive replacement for it, or is it because of my streamCycle? 
10:59:15 <wildtrees> hyperisco, you have a ZigZag package? :) Omega lives again as well? 
10:59:32 <[exa]> hyperisco: everything I read about distillation was very much targeted at lisps/MLs. So certainly not directly
10:59:44 <hyperisco> wildtrees, if by "lives" you mean "still compiles" then I don't know. ZigZag probably doesn't because I haven't touched it in a long time.
11:00:05 <hyperisco> Once upon a time I set the upper base package version to the maximum 64 bit integer... not sure if I did for that package
11:00:35 <wildtrees> oh, I used to use omega along time ago, it kinda died and people recommended logicT, but observing a Logic (Logic Bool) is unproductive for me, just infinite loops in this case 
11:00:40 <hyperisco> [exa], a related paper then used it for the purposes of automatic parallelisation. Did you read that also?
11:01:15 <[exa]> hyperisco: AutoPar?
11:01:16 <maerwald> how do I know unsafeInterleaveIO is safe for my use case? I am confident, but how do I know?
11:01:36 <hyperisco> Well I am not sure what sort of fairness LogicT provides. Have never seen it before. I can tell you that ZigZag is perfectly fair
11:02:01 <hyperisco> As long as you have finite dimensions, it will fairly iterate their cartesian product
11:02:53 <dminuoso> maerwald: unsafeInterleaveIO is, in general, not really safe.
11:03:01 <wildtrees> I need an infinite "list" of infinite "lists" 
11:03:06 <hyperisco> [exa], I am not sure what moniker it was given. I just recall reading at the start that intermediate data structures hurt parallelism, and I did not understand why. It is what they used distillation to fix.
11:04:03 <maerwald> dminuoso: can't implement stream to lazy bytestring without it
11:04:24 <maerwald> I guess lazy IO is inherent to lazy bytestring
11:04:29 <hyperisco> wildtrees, okay, then you need a different sense of fairness, but you need to be quite particular about what you're trying to accomplish
11:04:55 <hyperisco> wildtrees, I can show you an easy implementation for giving an exponential left bias
11:05:05 <[exa]> hyperisco: with 1 intermediate data structure you have 2 pipelines to decompose instead of 1 :]
11:05:19 <koala_man> are there different rules for unsafePerformIO and unsafeInterleaveIO? 
11:05:49 <wildtrees> I am trying to enumerate a list of lists that is roughly the reals, then I want to take a diagonal of the infinite of infinite structure and produce a witness of a an infinite sequence not in the larger mass 
11:05:52 <[exa]> hyperisco: also there is suddenly the pointy hell that holds the intermediate together, which you need to be able to recognize and remove (which sucks)
11:06:00 <hyperisco> [exa], ah I suppose that makes easier sense than I thought. My bias was that I wasn't really considering well-partitioning when I was looking for thoughts on automatic parallelisation
11:06:07 <dminuoso> maerwald: The difference is, the lazy IO is internal without visible side effects.
11:06:14 <dminuoso> maerwald: *in bytestring
11:07:00 <hyperisco> [exa], the premise of unburdening the programmer and well-partitioning do not seem to really go together in my head.
11:07:52 <hyperisco> The overhead on rewriting data to be well-partitioned does burden the programmer because they're going to want to avoid such rewrites
11:08:19 <hyperisco> And that overhead reduces what is worth parallelising
11:10:03 <hyperisco> wildtrees, you cannot take that diagonal though, it is impossible
11:10:37 <maerwald> dminuoso: check the alternative fromChunks' implementation in my comment https://github.com/psibi/streamly-bytestring/issues/7
11:10:41 <wildtrees> hyperisco, I can make and infinite data structure of the diagonal that is productive when observed? 
11:10:51 <wildtrees> I can't make? 
11:11:35 <hyperisco> wildtrees, read my notes here https://hackage.haskell.org/package/data-list-zigzag-0.1.1.1/docs/Data-List-ZigZag.html
11:11:39 <hyperisco> "Note that this method fails for the infinitary product even if every factor is known to be non-empty. The first element is known but following it are infinite elements that each draw a second element from one of the infinite factors. A product element drawing a third factor element is never reached."
11:11:51 <[exa]> hyperisco: they claim to have some automatic method to convert anything to JoinLists, which seem to exactly capture the "friendly" splitting of workloads in halves
11:12:06 <maerwald> I believe that should be safe for a stream of the form: S.unfold (SU.finally hClose readChunks)
11:12:36 <hyperisco> wildtrees, ZigZag enumerates the product exactly as how you'd draw the zig zag line through diagonals
11:13:00 <maerwald> the only IO is readChunks
11:13:03 <dminuoso> maerwald: That is not a fundamental unsafeInterleaveIO issue, but a streamly-bytestring issue.
11:13:07 <wildtrees> hyperisco, so it will fail in zigzag, darn, is it impossible in general? 
11:13:08 <hyperisco> wildtrees, now, you can choose a different strategy for enumeration, but you have to start asking exactly which products you want to enumerate, because you're never going to get all of them (obviously)
11:13:25 <maerwald> dminuoso: it's debatable whether that's a streamly-bytestring or streamly issue
11:14:01 <hyperisco> wildtrees, well this is exactly the diagonalisation argument isn't it? You literally cannot write a program that enumerates it all :P
11:14:09 <[exa]> hyperisco: distillation is then used just to detect where the rebuilding of the original datatype happens, and melt it together with the function that's applied on the result
11:14:20 <wildtrees> I am kind of trying to wrap my head around how an infinite binary tree is size alelph_null but all the paths through it I believe are uncountable and alpeh_one 
11:14:22 <maerwald> even if streamly-bytestring would use foldrM, which is properly lazy... you would still need unsafeInterleaveIO
11:14:34 <[exa]> hyperisco: which can transitively run through the whole program it seems
11:15:04 <dminuoso> maerwald: Fundamentally, yes. If you try and turn some conduit-like abstraction into a raw bytestring, then that is inherently unsafe.
11:15:07 <maerwald> and running unsafeInterleaveIO on an unknown MonadIO m... I don't think is an option
11:15:22 <wildtrees> hyperisco, I want some fair enumeration that I think would work, or any, then a witness function, then maybe move to a dependently typed language for a proof that the witness is not in the said enumeration 
11:15:24 <solonarv> koz_: yep, that is qhat I do all the time (just stack up some transformers)
11:15:38 <spew> I'm writing a parser and I expose a parsing function (parseFoo ::  String -> Either ParseError Foo) for each parser (foo :: Parser Foo) by writing 'parseFoo = parse foo ""' and it seems redundant and repetitive
11:15:41 <robd_> wildtrees: just coming in on this convo now so maybe missing context, but all paths through an infinite tree are surely countable, right?
11:15:45 <spew> is there a way to generate those parsing functions instead?
11:15:57 <robd_> each path has a first, second, third, .... element
11:15:59 <maerwald> dminuoso: yes, but given that the IO performed is only the readChunks, I believe this is safe. The finalizer is attached to close the handle when the end of the bytestring is reached
11:16:17 <hyperisco> wildtrees, okay but such an enumeration is impossible, else the bedrock of computability is wrong :P
11:16:17 <wildtrees> robd_, I believe that end up being uncountable via the diagonalization argument, even though there are only countable nodes 
11:16:40 <robd_> wildtrees: what are you diagonalizing over?
11:16:43 <wildtrees> hyperisco, how are the reals the bedrock of computability? :) 
11:16:57 <hyperisco> wildtrees, the diagonalisation argument is used to justify what is and is not computable
11:17:08 <hyperisco> or arguments equivalent to
11:17:11 <wildtrees> robd_, an enumeration of all the paths through an infinite binary tree 
11:17:55 <wildtrees> which should be roughly an infinite list of infinite binary sequences 
11:18:11 <wildtrees> which is "fixable" to the reals, which are uncountable 
11:18:23 <robd_> wildtrees: I don't see that argument. To diagonalize, you need to build a construction that shows some element that should be in any enumeration of the path elements cannot be in that enumeration
11:18:29 <maerwald> dminuoso: "safe" as in "should behave like ByteString.Lazy.getContents"
11:19:18 <robd_> in other words, a diagonalization argument would have to proceed: "assume we have an enumeration of all elements in some infinite path. now, here is an element we can build that *should* be in the path but isn't in the enumeration"
11:19:27 <wildtrees> robd_, I don't really have the binary tree atm, it's just something in my head https://0paste.com/51251#hl is the code I have, whats not commented out is productive, but streamReals is not fair so basically trivial or useless 
11:19:30 <robd_> an enumeration of all paths through the tree doesn't slot into that argument
11:19:47 <hyperisco> yes, you could take such an enumeration in the negative position, then find something absurd from it
11:20:03 <hyperisco> whether a type theory can prove this or not I am not sure… interesting question :)
11:20:18 <robd_> well if the question is: how can the depth of an infinite tree be aleph_0, but the length of a path be aleph_1, I think the answer is that the lengths of the paths are aleph_0 :)
11:20:26 <hyperisco> but you can't start with the plan of having such an enumeration, because it doesn't exist
11:20:58 <wildtrees> the length of the path is aleph_0 sure, but the number of infinite paths though the infinite binary tree I believe are uncountable 
11:21:12 <robd_> oooh, I see
11:21:14 <robd_> sure
11:21:16 <wildtrees> I can suppose an enumeration , then prove that it is not so 
11:21:27 <robd_> yes, I agree with that I think
11:21:27 <hyperisco> yes
11:22:07 <hyperisco> so, since we're talking correspondences, you just take it as an argument, and you sent it to Void
11:23:35 <wildtrees> SomeEnumeration -> (witness SomeEnumeration) `notElem` SomeEnumeration 
11:24:11 <wildtrees> or should that more be SomeEnum -> ((witness SomeEnum) `elem` SomeEnum) -> Void) ? 
11:25:16 <wildtrees> if dependent types were allowed :-/ 
11:25:21 <hyperisco> well you could do the first if you had a way of classifying all possible enumerations
11:25:40 <wildtrees> for a given enumeration 
11:25:59 <wildtrees> or just forall enumerations 
11:26:02 <hyperisco> if you had such a function, and it was total, then it is a proof of all enumerations
11:26:15 <hyperisco> I am just saying you have to have a way to construct all possible enumerations then
11:26:44 <wildtrees> is the number of all possible enumerations countable? 
11:26:57 <hyperisco> yes, because programs are countable
11:27:13 <wildtrees> finite programs right? 
11:28:40 <hyperisco> yes and I don't know what about infinite programs
11:31:06 <robd_> if by infinite you mean non-terminating, then yes all enumerations are still countable
11:32:35 <hyperisco> I was thinking wrt sending to Void that you'd characterise the enumeration by a problem it would be able to solve, though I suppose that would be more indirect
11:32:55 <hyperisco> Then you'd say if that problem was solvable then look here I can prove Void
11:33:08 <hyperisco> no guarantees that approach would work ;)
11:33:50 <wildtrees> yea I saw some other approach then actual enumerations in agda for the diagonalization of the reals, used mostly just functions, no actual enumerations 
11:35:11 <wildtrees> looked at this a bit the other day, https://www.playingwithpointers.com/blog/agda-cantor.html , thought I would work out a productive "Potential" (I know wrong :() enumeration in haskell first though before using agda or idris 
11:37:12 <simonpe^^> hyperisco, I set out to creating my own AST for the subset of the language I'm trying to generate. Would you know of any concept that I could read about regarding technques of how to actually build up an AST using combinators?
11:37:39 <hyperisco> simonpe^^, the docs of any parser combinator library, or any tutorial on parser combinators
11:37:50 <hyperisco> the two things go hand-in-hand
11:38:13 <simonpe^^> ok, thank you
11:53:34 <deselby> Hi. This is my first time trying to install Haskell and tools. I stumbled upon stylish-haskell installation. “stack install stylish-haskell” complains (* Recommends adding to extra-deps in $HOME/.stack/global-project/stack.yaml...) but iiuc https://docs.haskellstack.org/en/stable/yaml_configuration/#global-packages I could use “drop-packages:” instead. Am I correct? Which one of the two is better in this case?
11:55:14 <deselby> The dependencies stack complains about are HsYAML and HsYAML-aeson
12:01:02 <spew> is it more common in haskell to use List.map or just use <$> for map?
12:02:13 <ChaiTRex> spew: With one list, map is probably more common.
12:02:32 <spew> how would it change with more than one list?
12:02:34 <ChaiTRex> spew: With more than one list, <$> and <*> are probably more common.
12:02:42 <spew> oh I see
12:02:43 <spew> okay thanks
12:05:53 <subleq> Is it possible to implement a fifo queue in worst-case constant time? I see this technique for amortized constant time but I'd like better wrost-case performance https://rafal.io/posts/haskell-queues.html
12:06:22 <maerwald> deselby: cabal install stylish-haskell -- works for me
12:06:54 * hackage hlint 2.2.9 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.9 (NeilMitchell)
12:11:47 <hyperisco> subleq, not that I know of. You have to give more up. Try something based on a mutable linked list, perhaps.
12:11:49 <koz_> subleq: What's your use case?
12:12:04 <koz_> If you're in a concurrent environment, a mutable linked list has _serious_ caveats.
12:12:09 <subleq> curiosity, koz_ 
12:12:22 <hyperisco> a mutable has serious caveats :P
12:12:25 <koz_> subleq: Then hyperisco's advice is probably your best best.
12:12:28 <subleq> Yeah a mutable version is no fun
12:12:42 <koz_> subleq: Immutable + constant time is usually 'hard nope'.
12:12:54 <koz_> There are _some_ rather exceptional cases where this is possible, but not in general.
12:13:00 <koz_> (you tend to end up with logarithmic copying)
12:13:11 <subleq> well I would take log n too, still better than linear worst case
12:13:24 <koz_> subleq: Then use [insert one of the bazillion kinds of self-balancing tree].
12:13:33 <koz_> Literally, you have an embarassment of riches.
12:13:47 <subleq> I don't know how to implement this with a simple balanced tree
12:13:59 <hyperisco> Seq perhaps?
12:14:09 <koz_> subleq: That's a different kind of problem. :P
12:14:13 <koz_> Seq could work.
12:14:36 <solonarv> this might be one of the few situations where Seq is actually the perfect choice, even
12:16:28 <subleq> the source is over my head, can anyone point me to a simple explanation of how Seq works?
12:16:58 <hyperisco> I think it is based on 2-3 finger trees or some such. There is a paper somewhere.
12:17:18 <koz_> There's several, but it's not necessary to understand the implementaiton if you just wanna use it.
12:17:24 <koz_> Unless subleq's goal is to roll their own.
12:17:30 <koz_> In which case... yeah, read the 2-3 finger tree paper.
12:17:34 <koz_> It's actually fairly logical.
12:17:54 <koz_> Paper is http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
12:17:55 <subleq> Yeah I'm trying to understand how it works, not actually do anything
12:18:05 <hyperisco> the true academic
12:18:05 <koz_> subleq: Then the link above is your friend.
12:20:45 <subleq> oh, okasaki has a worst-case constant time queue http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf page 41
12:21:04 <hyperisco> well he's the one to have it if anyone did
12:21:16 <deselby> <maerwald "Bi: cabal install stylish-haskel"> For what its worth, stack install stylish-haskell worked after following the recommended steps, I guess those where recommended for a reason😛
12:21:37 <subleq> you kind of 'materialize' the amortization
12:21:59 <koz_> subleq: Trust Okasaki, our lord and saviour.
12:25:23 <Gurkenglas> If I have a function that typeclassily accept both String and Text and then someone has XOverloadedStrings enabled and submits "asd", there's an ambiguity error. Is there a way around that?
12:25:42 <koz_> Gurkenglas: TypeApplications.
12:26:01 <Gurkenglas> that increases the number of tokens the user has to use
12:26:14 <Gurkenglas> and then he could as well use T.pack himself, thats all i do
12:26:18 <Heffalump> ExtendedDefaultRules?
12:27:26 <koz_> Gurkenglas: Yeah, you can 'pin' the type in other ways. Depends on what you care about really.
12:27:54 <Gurkenglas> Can I for example tell it that it doesnt matter which instance it uses, it's all the same anyway?
12:28:09 <Gurkenglas> (commuting diagrams yay)
12:28:18 <kirill> hi all! can some explain (or: where can I read about) the syntax eg. "x :: (Proxy :: Proxy Int)", specifically the (Proxy :: Proxy Blah) part?
12:29:28 <koz_> kirill: :: indicates a type.
12:29:48 <koz_> The way Proxy is defined makes its type argument a 'phantom', meaning that a Proxy doesn't 'have' an 'a' anywhere.
12:29:50 <c_wraith> kirill: that has to be the -XDataKinds extension. but that's a weird use of it...
12:29:52 <kirill> koz_: yep that part is clear, eg. "a :: Int", but what does it mean in the context of Proxy? because I thought Proxy is also a type
12:29:56 <koz_> It's literally something like:
12:30:00 <koz_> data Proxy a = Proxy
12:30:17 <koz_> So we have to specify what we want 'a' to be, since all Proxy _values_ are the same.
12:30:23 <koz_> Hence the type annotation.
12:31:06 <c_wraith> koz_: you missed that it's using a value as a type, which is the real challenging bit there.
12:31:15 <koz_> c_wraith: Lol, yeah, _just_ noticed.
12:31:32 <Gurkenglas> Heffalump, ExtendedDefaultRules seems to only apply to a hardcoded whitelist of typeclasses
12:31:55 <kirill> c_wraith: can you elaborate a bit on what it means to 'use a value as a type'?
12:32:28 <koz_> kirill: I would read Part 1 of jle`'s 'Introduction to Singletons'.
12:32:32 <koz_> It explains that fairly early on.
12:33:08 <Gurkenglas> koz_, how can I pin it? I want the 30 users of the function to just not care whether they input string or text
12:33:40 <Gurkenglas> (the 30 places where the function is used that is)
12:33:41 <koz_> Gurkenglas: Hmm, that's a slightly different problem.
12:34:13 <koz_> I thought you had a case of 'I need to tell it want the Text instance, because GHC can't figure it out'.
12:34:23 <koz_> In your current situation, I'm not sure, sorry.
12:34:55 <Gurkenglas> I have "myerrorthrower :: IsString t => t -> MyMonad ()" and users should just call it with a string or text
12:35:04 <Gurkenglas> The desperation move would be to make two versions of the function with slightly different names :/
12:35:36 <koz_> Gurkenglas: What's the type of the part that's causing you ambiguity issues? I assume it's a type class method?
12:35:39 <c_wraith> or turn off OverloadedStrings. 
12:35:52 <c_wraith> that's my preferred solution.
12:36:11 <koz_> Ironically, I had this kind of issue with OverloadedStrings recently.
12:36:21 <Gurkenglas> c_wraith, that increases the number of mandatory T.pack calls which is the opposite of what im trying to do
12:36:22 <kirill> c_wraith: the issue came up while I was trying to "update" the field of a record by writing myRecord { field = blah }, and GHC complained that it's expecting "MyRecordType tag"  but instad got "Proxy tag0 -> MyRecordType tag0". is there anywhere I can read about why this error popped up in this context?
12:37:00 <Gurkenglas> koz_, when they say myerrorthrower "asd" it doesn't know whether its supposed to be String or Text
12:37:31 <Gurkenglas> Ironic. It was meant to work with both string and text consumers, but it doesn't work consumers more permissive than both.
12:37:36 <c_wraith> Gurkenglas: you fix that by not following the misguided advice to use Text everywhere.
12:37:58 <c_wraith> only use Text when it actually makes sense.
12:39:34 <Gurkenglas> Hmm. I could replace every usage of Text in haskell-ide-engine with String.
12:39:54 <Gurkenglas> When does Text make sense?
12:40:25 <c_wraith> when you're dealing with user input
12:40:33 <Gurkenglas> it definitely does that
12:42:05 <c_wraith> kirill: that error message is odd. can't say I've seen something like that before. do you have a self-contained repro?
12:42:39 <dmwit> I think it's probably sensible to have both `throwRaw :: Text -> MyMonad ()` and `throw :: IsString s => s -> MyMonad ()`.
12:42:44 <dmwit> See e.g. fromInteger and fromIntegral.
12:43:44 <dmwit> Users may choose `throw` if it's clear from context what type is being passed, and `throwRaw` if the type would otherwise be ambiguous.
12:43:52 <Gurkenglas> or rather "throwString :: String -> MyMonad ()" and "throwText :: Text -> MyMonad ()". If it looks painful maybe someone will think up a solution.
12:44:18 <dmwit> No, I purposely did not suggest throwString/throwText because I think that is a worse solution than `throw @String` and `throw @Text`.
12:44:45 <dmwit> And it is putting the wrong decision on the user, in my opinion.
12:45:14 <dmwit> The decision should be "do I care what type it's used at or not?" not "which instance do I want to use?".
12:45:15 <Gurkenglas> Maybe I'm just trying to keep my sanity by deliberately not moving into an almost acceptable local minimum
12:46:36 <dmwit> Type adapters are A Thing in this language. No getting around that.
12:46:49 <Gurkenglas> But the diagram commutes :(
12:47:19 <kirill> c_wraith: the surprise to me is, where did 'proxy' come from in that error message that concerns a straightforward record? but I'll dig more in the sources of the library that's providing these types before involving more people here
12:47:37 <sm[m]> Gurkenglas: when you have large bodies of text, I feel
12:47:58 <c_wraith> yeah, I have no idea where that would have come from. it's not a thing GHC just throws into error messages
12:48:43 <kirill> yep, thanks :) 
12:50:19 <Gurkenglas> but okay ill do the type application thing
12:50:42 <hyperisco> dmwit, did you make my mistake? IsString gives  String -> s
12:51:19 <Yoric> dmj`: Actually, double-checked, it's 44 million loc :)
12:51:34 <dmwit> hyperisco: I believe I did not make your mistake.
12:52:06 <hyperisco> dmwit, what is a plausible implementation of throw?
12:52:38 <dmwit> uh =)
12:53:07 <dmwit> Is it possible Gurkenglas is using a different IsString class? Or how have they done it?
12:53:29 <dmwit> ...perhaps they have not, and only stubbed it out.
12:54:01 <Gurkenglas> https://hackage.haskell.org/package/lens-4.18.1/docs/Data-Text-Lens.html#v:packed :( so i repack text
12:54:32 <dmwit> hyperisco: Gurkenglas is using a different IsString. ^_^
12:55:31 <hyperisco> The other possibility Gurkenglas is that packing Strings is not a big deal after all
12:56:08 <Gurkenglas> yea computationally its not, its ui after all
12:56:24 <Gurkenglas> but littering packs everywhere in the code is messy
12:56:25 <hyperisco> I mean verbosely
12:56:34 <Gurkenglas> get smote
12:57:58 <solonarv> hyperisco: actually it also has toString :: s -> String
12:58:23 <solonarv> (which is used for string literal patterns)
12:58:24 * hackage assumpta-core 0.1.0.0 - Core functionality for an SMTP client  https://hackage.haskell.org/package/assumpta-core-0.1.0.0 (phlummox)
12:58:25 <hyperisco> solonarv, https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:IsString ?
12:59:00 <dmwit> solonarv: Huh. I would have expected string literal patterns to need `(IsString s, Eq s)`.
12:59:06 <jle`> > case undefined of ~(!x,y) -> True
12:59:08 <lambdabot>  True
12:59:11 <dmwit> % :set -XOverloadedStrings
12:59:12 <yahb> dmwit: 
12:59:16 <jle`> does this feel weird to anyone else
12:59:18 <solonarv> well, apparently I was wrong
12:59:19 <dmwit> % :t \"foo" -> ()
12:59:19 <yahb> dmwit: (Eq a, IsString a) => a -> ()
12:59:24 <jle`> oh i should have had it be a 'guess the answer' thing instead
12:59:38 <solonarv> I think I must have confused it with one of the other overloaded things?
12:59:43 <jle`> i guess the real thing that perplexes me is:
12:59:49 <jle`> > let (!x, y) = undefined in True
12:59:51 <monochrom> jle`: No it does not feel weird to me.
12:59:52 <lambdabot>  True
12:59:54 <solonarv> ah yes, I confused it with IsList
12:59:55 <jle`> what does the ! even do , there?
13:00:17 <solonarv> > let (!x, y) = undefined in y True
13:00:19 <lambdabot>  *Exception: Prelude.undefined
13:00:31 <jle`> in my mind let (!x, y) = undefined in True should be translatable to let (x, y) = undefined in x `seq` True
13:00:32 <solonarv> ...wait, that doesn't show anything
13:00:55 <jle`> but what does let (!x, y) = undefined in True actually translate to, in terms of seqs ?
13:01:41 <jle`> i have always understood bang patterns as being sugar for seqs
13:01:50 <jle`> > let !(x,y) = undefined in True
13:01:52 <lambdabot>  *Exception: Prelude.undefined
13:02:00 <monochrom> But first you need the rules for ~ because it is outer.
13:02:15 <jle`> in the 'let' situation do the rules for ~ come to play?
13:02:32 <monochrom> As usual, const True (seq undefined 0) = True  despite the inner seq.
13:02:41 <monochrom> let is ~
13:03:05 <solonarv> > let (!x, y) = (undefined, not) in y True
13:03:07 <Gurkenglas> Why isn't runExceptT part of ExceptT(..) o.o
13:03:08 <lambdabot>  *Exception: Prelude.undefined
13:03:13 <solonarv> a-ha!
13:03:16 <monochrom> "let pat = xxx in yyy" = case xxx of ~pat -> yyy
13:03:27 <jle`> monochrom: ah, i always thought of cases with ~ as being sugar for let's
13:03:32 <hyperisco> > let !x = undefined in True
13:03:32 <jle`> but i guess it's the other way around?
13:03:34 <lambdabot>  *Exception: Prelude.undefined
13:03:35 <jle`> i don't think that's the case
13:03:40 <jle`> let's have different type inference rules than case statements
13:03:51 <monochrom> Mutual sugar.
13:03:55 <jle`> > let f = id in (f 10, f True)
13:03:57 <monochrom> = equivalent
13:03:58 <lambdabot>  (10,True)
13:04:06 <jle`> > case id of ~f -> (f 10, f True)
13:04:08 <lambdabot>  error:
13:04:08 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘10’
13:04:08 <lambdabot>      • In the first argument of ‘f’, namely ‘10’
13:04:24 <jle`> so, no, i don't think thi can accept that let pat = xx in yy is the same as case xx of ~pat -> yy
13:04:27 <jle`> *think
13:04:31 <jle`> *think i
13:04:32 <monochrom> Actually not sugar either way.  Because type checking is different.
13:04:46 <jle`> so i think you should be able to understand 'let' in terms of only 'let'
13:04:54 * hackage assumpta-core 0.1.0.1 - Core functionality for an SMTP client  https://hackage.haskell.org/package/assumpta-core-0.1.0.1 (phlummox)
13:04:58 <monochrom> let enjoys let-generalization let-polymorphism, case enjoys monomorphism like lambda.
13:05:03 <hyperisco> > let f = id in (id "Hello Sailor!", id 5)
13:05:06 <lambdabot>  ("Hello Sailor!",5)
13:05:14 <hyperisco> I mean f not id but you get it lol
13:05:22 <jle`> yeah, i wrote it earlier :)
13:05:25 <jle`> easily missed though
13:05:31 <hyperisco> vs
13:05:42 <hyperisco> > (\f -> (f "Hello Sailor!", f 5)) id
13:05:45 <lambdabot>  error:
13:05:45 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘5’
13:05:45 <lambdabot>      • In the first argument of ‘f’, namely ‘5’
13:05:46 <monochrom> However, after you erase types, let and ~ give the same non-strictness and laziness.
13:05:48 <jle`> monochrom: i think that looking at 'let' as a special case of 'case' adds more complexity than it helps
13:06:28 <monochrom> let was invented and made this way long before bang patterns.
13:06:37 <jle`> ah, you're saying they have the same operational/runtime semantics
13:06:42 <monochrom> Yes.
13:06:44 <jle`> not that one is sugar for the other
13:06:58 <jle`> was 'let' invented before 'case'?
13:07:09 <monochrom> At the same time.
13:07:19 <jle`> i still feel like you should be able to undersatnd `let (!x, y) = undefined in True` without having to resort to 'case'
13:07:25 <monochrom> But without bang patterns, it was simpler to equivale let with ~
13:08:11 <solonarv> jle`: I do not think the bang pattern makes a difference in that specific case
13:08:24 <monochrom> Actually nevermind, you can raise the same issue with "let (a:b, c) = undefined in ..."
13:09:01 <jle`> solonarv: yeah, it doesn't, which is sort of weird to me
13:09:02 <monochrom> (because a:b is the same as !x for the list type)
13:09:10 <jle`> i always thought bang patterns can be considered sugar for seq's
13:09:32 <jle`> like how let !x = blah in y is sugar for let x = blah in x `seq` y
13:09:39 <solonarv> jle`: intuitively my thought process is that in this case the pattern match fails before we even get around to looking inside x
13:09:44 <hyperisco> Does seq mean whnf or nf? Different for bang?
13:09:50 <jle`> seq is whnf
13:10:01 <solonarv> seq is whnf, nf isn't really rigorously defined the way whnf
13:10:03 <solonarv> * is
13:10:33 <jle`> so can let (!x, y) = undefined in True be written in terms of `seq`?
13:10:48 <hyperisco> honestly my approach has been to apply ~'s and !'s in combinations until my issues disappear, but perhaps I should have tried to be more precise with it
13:10:50 <jle`> or does the bang pattern add new power that was previously unavaiable with seq ?
13:11:27 <solonarv> the bang pattern does not do anything because we never even try to match (!x, y)
13:11:33 <dmj`> Yoric: well I'll be
13:12:28 <jle`> solonarv: but the bang pattern does something if it's outside
13:12:36 <jle`> > let !(x,y) = undefined in True
13:12:37 <lambdabot>  *Exception: Prelude.undefined
13:12:48 <solonarv> yes
13:13:07 <jle`> hm. i guess writing (!x, y) = undefined in True is silly without bang patterns
13:13:10 <hyperisco> > case undefined of ~!(x,y) -> True
13:13:13 <lambdabot>  <hint>:1:27: error: parse error on input ‘->’
13:13:19 <jle`> > let (!x, y) = undefined in y
13:13:22 <lambdabot>  *Exception: Prelude.undefined
13:13:33 <hyperisco> -XComposableBangPatterns
13:13:42 <jle`> hyperisco: it works with parentheses
13:13:50 <jle`> > case undefined of ~(!(x,y)) -> True
13:13:52 <lambdabot>  True
13:13:53 <solonarv> it is also silly because it doesn't matter what patterns you use for the fields of the ( , ) constructor
13:14:09 <solonarv> since even matching that constructor at all fails
13:14:09 <hyperisco> jle`, well then the translation to case/of isn't really working here is it
13:14:21 <jle`> ah, true
13:14:27 <monochrom> jle`: Take a look at Haskell 2010 3.17.3 and GHC user's guide bang pattern section.
13:14:47 <jle`> thanks :)
13:14:49 <jle`> good call
13:15:07 <monochrom> GHC user's guide has a "let (!x,[y]) = e in b" example.
13:15:52 <monochrom> Basically trying to do minimal change to Haskell 2010's existing pattern semantics.
13:16:30 <jle`> ah there is the desugaring in terms of seq
13:16:52 <jle`> so the desugaring is ...
13:17:35 <jle`> > let (x,y) = case undefined of (a,b) -> a `seq` (a, b) in True
13:17:36 <lambdabot>  True
13:17:52 <jle`> > let (x,y) = case undefined of (a,b) -> a `seq` (a, b) in y
13:17:54 <lambdabot>  *Exception: Prelude.undefined
13:17:58 <jle`> this aligns with everything
13:18:20 <hyperisco> > let isNewtype f = { let !x = f (fix id) in False } in [isNewtype Just, isNewtype Identity]
13:18:23 <lambdabot>  <hint>:1:19: error: parse error on input ‘{’
13:18:55 <hyperisco> > let isNewtype f = let !x = f (fix id) in False in [isNewtype Just, isNewtype Identity]
13:18:59 <lambdabot>  [False,*Exception: <<loop>>
13:19:06 <hyperisco> Just a fun idea…
13:19:24 <solonarv> oh, I bet you could catch that <<loop>> and return True instead
13:19:37 <jle`> "could"
13:19:39 <hyperisco> Can you catch bottoms in IO? That seems a bit terrifying
13:19:47 <jle`> you can't catch bottoms in IO
13:19:50 <solonarv> you can if you 'evaluate' first!
13:20:00 <jle`> but you can catch IO exceptions
13:20:12 <jle`> and *Exception: <<loop>> is an IO exception
13:20:30 <jle`> er.. i think?
13:20:33 <solonarv> if 'x' is a bottom that throws 'err', then 'evaluate x' throws 'err' through the normal IO exception mechanism
13:20:34 <hyperisco> Well there we go, runtime type information for the worker Haskeller
13:21:33 <monochrom> Some bottoms become exceptions, some don't.
13:21:56 <jle`> like, say, `sum [1..]
13:22:07 <monochrom> "x = x+1" (for Int e.g.) is one of those catchable <<loop>> blackholes/whiteholes 
13:22:37 <hyperisco> I have a feeling with the right seqs you could do this with unsafePerformIO
13:22:41 <solonarv> % let isNewtype f = unsafePerformIO $ do evaluate (f (error "kaboom")) `onException` \_ -> return True; return False
13:22:41 <yahb> solonarv: ; <interactive>:116:84: error:; * Couldn't match expected type `IO b0' with actual type `p0 -> m0 Bool'; * The lambda expression `\ _ -> return True' has one argument,; but its type `IO b0' has none; In the second argument of `onException', namely `\ _ -> return True'; In a stmt of a 'do' block: evaluate (f (error "kaboom")) `onException` \ _ -> return True
13:22:50 <solonarv> % let isNewtype f = unsafePerformIO $ do evaluate (f (error "kaboom")) `onException` return True; return False
13:22:50 <yahb> solonarv: 
13:22:56 <solonarv> % isNewtype Just
13:22:56 <yahb> solonarv: False
13:23:03 <solonarv> % isNewtype Identity
13:23:03 <hyperisco> You can stuff an unsafe IO action in the data and it will either run or not
13:23:03 <yahb> solonarv: *** Exception: kaboom; CallStack (from HasCallStack):; error, called at <interactive>:117:53 in interactive:Ghci52
13:23:07 <solonarv> huh
13:23:19 <solonarv> okay, I guess I didn't catch the right exception type
13:23:33 <hyperisco> I see you're ahead of me
13:23:35 <monochrom> But blackholes/whiteholes are artifacts of lazy evaluation, not a Haskell-Report level guarantee.
13:25:23 <solonarv> % let isNewtype f = unsafePerformIO $ (False <$ evaluate (f (error "kaboom"))) `catch` \ErrorCall{} -> return True
13:25:23 <yahb> solonarv: 
13:25:27 <solonarv> % isNewtype Just
13:25:27 <yahb> solonarv: False
13:25:31 <solonarv> % isNewtype Identity
13:25:31 <yahb> solonarv: True
13:25:34 <solonarv> haha!
13:25:59 <monochrom> If you really need the halting problem solved, consider maching learning. >:)
13:26:09 <monochrom> err, machine learning!
13:26:20 <solonarv> although really this function is misnamed: it should be called 'isStrict'
13:26:25 <solonarv> because that is what it checks
13:26:27 <monochrom> throw in blockchain there too
13:26:37 <hyperisco> So now that we have this atrocity, can we declare changing from data to newtype and vice versa a breaking change? >:)
13:26:42 <maerwald> blockhain? I heard you are looking for opportunities!
13:26:58 <monochrom> I am looking for halting opportunities!
13:27:09 <c_wraith> hyperisco: if you are changing strictness properties, it is a breaking change
13:27:14 <maerwald> I heard halting integrates well with containers
13:27:21 <monochrom> \∩/
13:27:27 <solonarv> actually this could be made more robust by using a custom exception instead of an error call
13:27:39 <solonarv> but I am too lazy (hah!) to do that in an IRC oneliner
13:27:55 <jle`> % data Blah a = Blah !a
13:27:55 <yahb> jle`: 
13:28:00 <jle`> > isNewtype Blah
13:28:03 <lambdabot>  error:
13:28:03 <lambdabot>      Variable not in scope: isNewtype :: t0 -> terror: Data constructor not i...
13:28:07 <jle`> % isNewtype Blah
13:28:07 <yahb> jle`: True
13:28:20 <solonarv> yes, that is why I said it should be called 'isStrict' instead
13:28:24 <monochrom> If you make a breaking-in-theory change but nothing breaks in practice, is it a breaking change?
13:28:28 <solonarv> also:
13:28:31 <hyperisco> I was wondering what would happen there, and so I guess the application of f is forcing the argument
13:28:32 <solonarv> % isNewtype (+1)
13:28:32 <yahb> solonarv: True
13:28:41 <monochrom> (Like "if a tree falls but no one is around to hear"...)
13:28:55 <solonarv> actually this simply checks whether f _|_ = _|_
13:29:03 <c_wraith> monochrom: yes, but your users aren't creative enough.
13:29:04 <solonarv> which is exactly the definition of strictness
13:29:12 <jle`> neat
13:29:37 <jle`> % isNewtype (const 1)
13:29:37 <yahb> jle`: False
13:29:51 <solonarv> % isNewtype (+)
13:29:52 <yahb> solonarv: False
13:30:05 <monochrom> % :type isNewtype
13:30:05 <yahb> monochrom: (t -> b) -> Bool
13:30:09 <hyperisco> % let isStrict = isNewtype
13:30:09 <yahb> hyperisco: 
13:30:19 <solonarv> hyperisco: THANK YOU
13:30:22 <hyperisco> lol
13:30:24 <solonarv> it was slowly driving me crazy
13:30:27 <c_wraith> I had so much code broken by "non-breaking" strictness changes in containers.
13:30:33 <maerwald> monochrom: err, the tree falling is a one-time event, but the tree blocking the road isn't. So even if no one hears the tree fall, it is still blocking the f**king road ;D
13:30:49 <hyperisco> c_wraith, I have to wonder how many library authors are considering that. I don't think I ever have. Maybe I am a bad author =\
13:30:50 <solonarv> what a wonderfully general type!
13:31:04 <monochrom> Ah, road block is more accurate, yes.
13:31:09 <c_wraith> just because I was actually using the non-strictness the maintainers believed no one was
13:31:23 <monochrom> But but but no one is using the road...
13:32:05 <maerwald> Just yet...
13:32:20 <hyperisco> % isStrict fix
13:32:20 <yahb> hyperisco: True
13:32:29 <maerwald> hope the tree has rotten before someone walks the road?
13:32:58 <monochrom> I hope people make and use new roads and not bother with the existing one.
13:34:00 <monochrom> OK, how about this.  A semantic change that doesn't break old code, and people know about the semantic change, and new code is written keeping the change in mind.  So neither old nor new code is broken.  Is this a breaking change?
13:34:37 <hyperisco> solonarv, I think f needs to be forced first, else it is more like… isThrowing
13:35:31 <hyperisco> then again only can only do it to whnf, so I guess it is an imperfect solution
13:35:52 <monochrom> eval "fix f" -> eval x under "x = f x" -> eval "f x" -> eval "f"
13:36:33 <monochrom> Or denotationally, fix bottom = bottom
13:36:52 <hyperisco> that wasn't my counterexample
13:36:54 <monochrom> In general, bottom x = bottom
13:37:14 <maerwald> A semantic change that doesn't break old code? 
13:37:23 <maerwald> I'm having a hard time imagining that
13:37:40 <monochrom> Because by improbable luck old code does not use all of the semantics given.
13:37:58 <monochrom> e.g. the change is in a corner case.
13:38:18 <maerwald> Well, usually people rely on *all* behaviors of your functions, not just the ones you're aware of :P
13:38:30 <hyperisco> monochrom, though I guess if throwing is ⊥, then ⊥ ∷ A → B is still ⊥ for all A, so bottom is strict
13:38:49 <hyperisco> maybe is a perfect solution
13:38:50 <monochrom> Example: I have a factorial implementation that accepts negative numbers and bottoms out.  I change it to answering -42 instead of bottoming out.  Semantic change that probably doesn't affect anyone.
13:39:18 <maerwald> what if someone catches that bottom? :>
13:39:55 <maerwald> Or: wrote some fail-safe logic that restarts the application
13:40:06 <maerwald> now it doesn't restart...
13:40:08 <solonarv> hyperisco: quite right, I forgot to account for f itself being bottom
13:40:24 <hyperisco> solonarv, yes but upon further thought, bottom is strict, right?
13:40:26 <monochrom> Right but what if I'm lucky and no one did that.
13:40:27 <solonarv> oh well, not like anyone will actually use this abomination
13:40:33 <maerwald> then you're just lucky!
13:40:35 <solonarv> hyperisco: clearly so!
13:40:41 <hyperisco> solonarv, lol but I mean really
13:40:44 <monochrom> Yes I'm talking about luck.
13:40:55 <maerwald> Is there such a thing with users?
13:40:59 <monochrom> History = historical accidents.
13:41:10 <hyperisco> solonarv, ⊥ ⊥ = ⊥
13:41:31 <hyperisco> a lot of thumbtacks to step on
13:48:32 <hseg> Am trying to do some case branching on whether a singleton is even or odd, GHC doesn't like my methods: https://gist.github.com/13f06ce0c52034832195206d41c32d4c
13:50:00 <jle`> what is the error?
13:50:43 <hseg> Updated with error log attached
13:50:59 <hseg> GHC complains that Mod is noninjective
13:51:05 <hseg> (fair, but should be irrelevant)
13:51:27 <hseg> And that triggers a bunch of errors where stuff fails to unify
13:52:19 <jle`> the error sounds like a type inference issue with something not being able to be inferred
13:52:33 <jle`> what extensions do you have turned on?
13:53:34 <jle`> hseg: try fully specifying all of the type variables for your call to eIntDivision
13:54:01 <jle`> m, n, d, and r
13:54:10 <hseg> OK
13:54:20 <hseg> In the meantime, added LANGUAGE and imports to gist
13:54:27 <jle`> in particular it seems that there is no way for eIntDivision to  infer 'n'
13:54:29 <hseg> (unfiltered)
13:54:39 <jle`> since none of the arguments use 'n' directly in their type
13:55:19 <jle`> if you write it non-infix it might become more clear
13:55:58 <jle`> eIntDivision :: Div m n :~: d -> Mod m n :~: r -> m :~: (d * n + r)
13:56:17 <jle`> if you passed in something like (4 :~: 5) and (6 :~: 2), how would it infer what 'n' is?
13:56:24 <hseg> Ah, that's where the lack of injectivity bites
13:56:37 <jle`> you can infer r ~ 2 at best
13:56:44 <jle`> and if you know the type you want it to be, you can infer m
13:56:58 <jle`> but i think in your case you can't even infer m because the type you want as a result isn't clear
13:57:23 <hseg> Why r ~ 2?
13:57:31 <jle`> because i passed in (6 :~: 2)
13:57:36 <jle`> which unifies with (Mod m n :~: r)
13:57:38 <hseg> Ah, in your example
13:57:39 <jle`> where r ~ 2
13:57:41 <hseg> Yes
13:57:42 <jle`> mhm
13:58:31 <jle`> in your case you can infer r in both cases i think. but never m or n
13:59:15 <hseg> Hm, now it's complaining the pattern match on em `testEquality` SNat @1 only gives a 1 :~: 1, not a d `Mod` 2 :~: 1
13:59:37 <hseg> jle`: m is inferrable if the result type is constrained, as you mentioned
13:59:46 <hseg> jle`: but n always needs to be passed
13:59:56 <jle`> the result type isn't constrained in your situation
14:00:33 <jle`> ah, if you fix d, n, and r then yeah
14:01:55 <hseg> Updated code and error https://gist.github.com/hseg/13f06ce0c52034832195206d41c32d4c
14:02:21 <hseg> *weird*
14:04:02 <hseg> Dammit, all I want is for GHC to give me an Either (SNat (d `Mod` 2) :~: SNat 0) (SNat (d `Mod` 2) :~: SNat 1) 
14:04:42 <jle`> hseg: shouldn't 'r' be 0 or 1 ?
14:05:07 <hseg> in the call to eIntDivision?
14:05:10 <hseg> oh, right
14:05:42 <hseg> OK, now GHC only complains about missing KnownNats
14:05:44 <hseg> which is OK
14:06:09 <jle`> neat
14:06:12 <jle`> nice :)
14:07:59 <hseg> ty
14:18:53 * hackage hedgehog-classes 0.2.4.1 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.2.4.1 (chessai)
14:25:19 <sguest> Does anyone know if there is an implementation of printf that conforms to the C standard? Text.Printf is close, but it behaves differently with %g, and I need identical behavior.
14:27:06 <dminuoso> sguest: Have you checked any of the other printf-like packages on hackage?
14:28:27 <dminuoso> sguest: How does the behavior wrt to %g differ by the way?
14:29:37 <dminuoso> It seems that, category-printf is fully tractable, so if the base printf doesn't cut it, that might
14:32:51 <sguest> From the Text.Printf source: Haskell 'printf' never uses the default \"6-digit\" precision used by C printf. Haskell 'printf' treats the \"precision\" specifier as indicating the number of digits after the decimal point. Haskell 'printf' prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits. Haskell 'printf' will place a zero after a decimal 
14:32:57 <sguest> point when possible.
14:33:26 <sguest> I'll look at category-printf, thanks for the suggestion
14:34:29 <dminuoso> Ah mmm.
14:34:46 <sguest> The differing behavior comes from formatRealFloat in GHC.Float, so I'm guessing a lot of printf-like packages do the same thing
14:35:20 <dminuoso> sguest: Do you just need this once, or do you need this functionality across multiple places?
14:40:07 <sguest> Likely multiple places. I have a large set of test files with expected output originally outputted with printf, so it'll be a bit of a chore to modify all of those.
14:41:36 <yushyin> what a bummer, I cannot encode a cairo surface as a png image to a bytestring or such, maybe some cbits to let cairo_surface_write_to_png_stream write into a bytestring?
14:46:36 <solonarv> you *might* not even need cbits for that
14:47:13 <dminuoso> sguest: There is the option of roundtripping through ffi.
14:47:19 <solonarv> ByteString is backed by a ForeignPtr, which as the name suggests is well-suited for passing back and forth between C and Haskell land
14:47:38 <dminuoso> sguest: You'd have the correct semantics that way, at least.
14:49:15 <sguest> dminuoso: Yeah I think I'll go that route for now. Might add a custom formatter for Text.Printf that behaves properly if I get around to it.
14:50:31 <solonarv> I wonder if the cairo_write_func_t is supposed to copy the data or if it is allowed to just shove the (data, length) pair somewhere and access it later
14:50:43 <solonarv> obviously the documentation does not say, because that would be too easy
14:50:47 <yushyin> solonarv: that's what I would try todo, let C-code encode the png in-memory, pass the Ptr to haskell-code and use Bytestring's fromForeignPtr
14:52:20 <yushyin> But I still need a bit of c-code, because there is no function which encode it in-memory, just the cairo_surface_write_to_png_stream.
14:55:53 <solonarv> that wants a function pointer, you can do that in Haskell
14:56:02 <solonarv> although I do not know how pleasant that would be
14:57:47 <yushyin> exactly :), btw. cairo and also gi-cairo-render do not export cairo_surface_write_to_png_stream, maybe for a reason?
15:15:53 * hackage harg 0.4.2.0 - Haskell program configuration using higher kinded data  https://hackage.haskell.org/package/harg-0.4.2.0 (alexpeits)
15:21:54 * hackage flp 0.1.0.0 - A layout spec language for memory managers implemented in Rust.  https://hackage.haskell.org/package/flp-0.1.0.0 (KarlCronburg)
15:32:11 <hseg> How do I check in GHCi whether a type is an instance of a typeclass with no methods?
15:32:38 <hseg> (At least if there were methods, I could use TypeApplications to force GHC to do an instance lookup)
15:32:38 <hpc> use :info
15:33:23 <jle`> > True :: Show (Int -> Bool) => Bool
15:33:25 <lambdabot>  True
15:33:27 <jle`> :(
15:33:41 <jle`> oh wait
15:33:51 <jle`> @data NoShow
15:33:51 <lambdabot> Unknown command, try @list
15:33:54 <jle`> @let data NoShow
15:33:56 <lambdabot>  Defined.
15:34:04 <jle`> > True :: Show NoShow => Bool
15:34:06 <lambdabot>  error:
15:34:06 <lambdabot>      No instance for (Show NoShow)
15:34:06 <lambdabot>        arising from an expression type signature
15:34:26 <hseg> Doesn't work -- have a type constructor of kind Nat -> Type -> Type
15:34:49 <hseg> (Same complication arises searching for instances of Maybe Int)
15:34:49 <hpc> hseg: use :info
15:34:58 <hpc> it will list all the instances for a class
15:35:47 <hseg> Right, but the issue is that the class *seems* to have an instance for my type, but instance resolution is failing despite that
15:36:30 <hseg> And I'm not sure that this is the class I'm missing, because it's a superclass of the class that's actually causing errors
15:36:55 <hseg> so I A) want to make sure this class is the culprit and B) want to know why the instance didn't match
15:37:01 <hseg> Probably A will answer B
15:38:38 <hseg> Hm. Maybe if I import Data.Constraint and try to construct a corresponding Dict?
15:40:47 <hseg> It works
15:41:04 <hseg> > Dict @(Show (Int -> Int))
15:41:06 <lambdabot>  <hint>:1:6: error: parse error on input ‘@’
15:41:12 <hseg> :(
15:41:31 <hseg> (It should error saying there's no instance Show (Int -> Int))
15:41:44 <jle`> we have an instance of Show Int -> Int in ghci
15:41:47 <jle`> > show negate
15:41:49 <lambdabot>  "<Integer -> Integer>"
15:42:58 <hseg> OK, but my point stands that this is an effective technique
15:43:32 <hseg> Indeed, it took two seconds to find out that all I was missing was an instance of Rig
15:43:49 <hseg> Abelian wasn't the culprit
15:48:09 <hseg> Another trick for the GHCi toolbox
15:50:19 <[itchyjunk]> hmm
15:50:24 * hackage regex 1.1.0.0 - Toolkit for regex-base  https://hackage.haskell.org/package/regex-1.1.0.0 (ChrisDornan)
15:51:10 <hseg> Hrm. Just noticed a wart: Let k a finite kind. We can write class C (t::k), however GHC doesn't consider the constraint C t to be subsumed by the kinding relation t::k
15:51:24 * hackage regex-examples 1.1.0.0 - Tutorial, tests and example programs for regex  https://hackage.haskell.org/package/regex-examples-1.1.0.0 (ChrisDornan)
15:51:37 <hseg> So I need to constrain t twice
15:52:05 <jle`> somewhat related to type erasure
15:52:12 <hseg> Though it is a tossup whether this subsumption is desirable
15:52:15 <hseg> ^
15:52:24 * hackage regex-with-pcre 1.1.0.0 - Toolkit for regex-base  https://hackage.haskell.org/package/regex-with-pcre-1.1.0.0 (ChrisDornan)
15:53:06 <hseg> right -- if one considers what should happen under DependentHaskell, in forall (t::k). ... t is irrelevant (ie erased), so cannot be dispatched on 
15:53:13 <hseg> Oh well
15:53:18 <hseg> Makes sense
15:53:22 <[itchyjunk]> hmm if i define my function as dlog  g h p x when when i call it i map (dlog g h p) [1..100], it works out right?
15:53:24 * hackage tree-sitter-tsx 0.4.2.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.4.2.0 (tclem)
15:53:28 <[itchyjunk]> i hope i explained it enough
15:53:40 <[itchyjunk]> i wanted my x to take those values from the list
15:53:41 <Cale> yes, that should work
15:53:46 <[itchyjunk]> ah ok ty
15:54:52 <Rembane> [itchyjunk]: You can experiment on that by giving dlog too few arguments and see the typechecker give you (informative) error messages telling you what you need to add.
15:55:05 <hseg> I mean, it's the same reason you can't write module Foo { type T a; instance C T; foo :: T a } where foo uses the C constraint 
15:55:29 <hseg> ... wait, no
15:55:35 <hseg> you can do that
15:55:40 <hseg> hrm
15:55:50 <jle`> also consider that something of a finite kind might not be any one of the possible finite kinds
15:56:01 <jle`> for example, you can have something of kind Bool that is neither 'True nor 'False
15:56:06 <hseg> wat
15:56:12 <jle`> tis true
15:56:19 <hseg> Oh, right, with stuck type families
15:56:30 <hseg> goddamn partiality at the type level
15:56:45 <jle`> hseg: and also GHC.Exts.Any
15:57:01 <[itchyjunk]> hmmmmm
15:57:01 <jle`> % import GHC.Exts
15:57:01 <yahb> jle`: 
15:57:03 <hseg> Well, that's just partiality in another guise
15:57:10 <jle`> % :k '[ 'True, 'False, Any ]
15:57:10 <yahb> jle`: ; <interactive>:1:19: error:; Ambiguous occurrence `Any'; It could refer to either `GHC.Exts.Any', imported from `GHC.Exts' (and originally defined in `GHC.Types'); or `Control.Monad.RWS.Any', imported from `Control.Monad.RWS' (and originally defined in `base-4.12.0.0:Data.Semigroup.Internal')
15:57:17 <jle`> % :k '[ 'True, 'False, GHC.Exts.Any ]
15:57:17 <yahb> jle`: '[ 'True, 'False, GHC.Exts.Any ] :: [Bool]
15:58:19 <hseg> Oh well, wouldn't be *that* nice to have anyway
15:58:54 * hackage dtab 1.1.1.1 - Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library  https://hackage.haskell.org/package/dtab-1.1.1.1 (mtolly)
16:00:12 <[itchyjunk]> https://pastebin.com/diu8EHrT I am trying to write a discrete log function :D
16:00:27 <[itchyjunk]> i am notsure what i am doing though
16:01:19 <[itchyjunk]> the idea was, if g^x `mod` p ==h return x otherwise go on with your business
16:01:46 <[itchyjunk]> infact, if g^x `mod` p == h , i could stop what i was doing hmm
16:01:54 * hackage tree-sitter-typescript 0.4.2.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.4.2.0 (tclem)
16:02:04 <Rembane> [itchyjunk]: If you use guards, that is the pipe syntax, you don't need to use if. 
16:02:18 <[itchyjunk]> ah
16:03:08 <[itchyjunk]> ah i googled "else nothing" and was suggested nop but compiler is saying i am using it wrong :D
16:03:38 <Rembane> [itchyjunk]: So either it is a discrete log or you give up? 
16:04:11 <[itchyjunk]> well, i wanted to use this function with map so i can map [1..p-1] as x
16:04:35 <[itchyjunk]> and the g is generator so one of them will definately give me an h as long as h \in Z/pZ^*
16:04:54 * hackage escape-artist 1.2.0.1 - ANSI Escape Sequence Text Decoration Made Easy  https://hackage.haskell.org/package/escape-artist-1.2.0.1 (ryan_daniels)
16:04:57 <Rembane> [itchyjunk]: What kind of generator? 
16:05:21 <[itchyjunk]> g is a primitive root of Z/pZ
16:06:06 <Rembane> [itchyjunk]: Ah. Have you ever used Maybe? 
16:06:14 <[itchyjunk]> nope
16:07:14 <Rembane> [itchyjunk]: It is defined like this:  data Maybe a = Nothing | Just a
16:07:31 <[itchyjunk]> hmm
16:07:38 <Rembane> [itchyjunk]: It can either return Nothing if there is Nothing to return, otherwise it returns Just something.
16:07:48 <[itchyjunk]> lol
16:07:51 <[itchyjunk]> sounds a bit funny
16:07:56 <Rembane> It does. 
16:08:24 <Rembane> > map (\x -> if odd x then Just x else Nothing) [1..]
16:08:26 <lambdabot>  [Just 1,Nothing,Just 3,Nothing,Just 5,Nothing,Just 7,Nothing,Just 9,Nothing,...
16:08:34 <Rembane> You can use it like that. 
16:08:57 <Rembane> Or if you prefer to only get the Justs you can use mapMaybe instead.
16:09:02 <Rembane> > mapMaybe (\x -> if odd x then Just x else Nothing) [1..]
16:09:05 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
16:10:56 <[itchyjunk]> https://pastebin.com/hQzD2pG4
16:11:07 <hseg> [itchyjunk]: So you want you dlog to fail if the element passed is not a unit?
16:11:14 <hseg> e.g. dlog 0 should fail?
16:11:39 <jle`> [itchyjunk]: you might have forgotten the equals sign
16:11:53 <[itchyjunk]> i am trying to solve log_g(h) by solving g^x = h (mod p)
16:13:26 <hseg> OK, and this has three possible values: "g is not a generator", g^x == h (mod p) and g^x /= h (mod p)
16:13:47 <hseg> and you're collapsing the "g is not a generator" and g^x /= h (mod p) error states?
16:13:56 <[itchyjunk]> g is always going to be a generator. so it will either be h or not
16:14:07 <[itchyjunk]> if its equals h, i want that x which made it so
16:14:11 <[itchyjunk]> otherwise i dont care :s
16:14:54 <[itchyjunk]> map (dlog g h p) [1..p-1] is giving me all sorts of errors :D
16:15:38 <hseg> OK, your pastebin'd code should do the trick (mod syntax errors)
16:16:37 <[itchyjunk]> what is type a10?
16:16:41 <hseg> With that, map will return something like [Nothing, Nothing, ..., Just x, Nothing]
16:16:53 <hseg> Unclear without more context.
16:16:56 <[itchyjunk]> ah
16:17:02 <hseg> Could you post the code + error log?
16:17:08 <[itchyjunk]> ok
16:17:51 <[itchyjunk]> https://pastebin.com/EMQgz7Cd
16:18:30 <[itchyjunk]> trying to solve 2^x = 13 (mod 23)
16:18:54 <hseg> [itchyjunk]: What's the type of map dlog
16:18:56 <hseg> ?
16:19:35 <[itchyjunk]> int -> int -> int -> int -> err output is list i guess? :S
16:19:44 <[itchyjunk]> oops Integer i mean
16:20:17 <[itchyjunk]> Integer -> Integer -> Integer -> Integer -> not sure about output :D
16:20:43 <hseg> That's the type of dlog
16:20:59 <hseg> (in fact, dlog :: Integer -> Integer -> Integer -> Integer -> Maybe Integer)
16:21:25 <[itchyjunk]> right, thats what i think dlog should be :s
16:21:32 <hseg> (that is, if we ignore typeclasses and fix a single type)
16:21:54 <hseg> OK, but now map :: (a->b) -> [a] -> [b]
16:22:07 <hseg> Do you see the problem? What's the type of map dlog ?
16:22:58 <[itchyjunk]> hmm
16:23:29 <[itchyjunk]> Integer -> Integer -> Integer ->[Ingeter] -> Maybe Integer?
16:25:04 <hseg> Would it help if you knew (->) is right-associative, i.e. a->b->c = a->(b->c) ?
16:28:10 <[itchyjunk]> well its maps fault somehow but i dont quite see it!
16:28:43 <hseg> Consider a simpler example.
16:29:05 <hseg> Would you say that map (+) 4 [0..4] is well-typed?
16:32:15 <[itchyjunk]> i am not sure, maps taks a function and would apply it to [0..4] element wise
16:32:54 <[itchyjunk]> map (4+) [0..4]?
16:33:22 <n1ck2> `4+` is not a function
16:33:23 <hseg> but map (+) 4 [0..4] and map (4+) [0..4] are very different beasts
16:33:34 <hseg> n1ck2: but it is a valid section
16:33:58 <Axman6> (4+) == (\x -> 4+x)
16:34:19 <hseg> [itchyjunk]: map (+) 4 [0..4] = ((map (+)) 4) [0..4], whereas map (4+) [0..4] = (map ((+) 4)) [0..4]
16:34:25 <[itchyjunk]> but that how i imagine map to work. 4+ is looking for elements and it gets it via map :s
16:34:55 <hseg> yes, but function application isn't associative
16:36:12 <hseg> For example, print show "hello" is a type error, since it's (print show) "hello" 
16:36:25 <hseg> whereas you probably meant print (show "hello")
16:37:00 <hseg> (and the answer is not "Then GHC should just parenthesise things the way I mean" because that blows up *fast*)
16:37:18 <Axman6> Is there an easy way to go from MonadFail m => m a to Either String a?
16:37:24 <hseg> (especially since things can validly be parenthesised many ways)
16:37:50 <hpc> Axman6: don't think so
16:37:59 <[itchyjunk]> so map wants 2 things
16:38:12 <[itchyjunk]> map (dlog 2 13 23) [1..23] ?
16:38:17 <hpc> consider that there is instance MonadFail IO
16:38:53 <hseg> Yes
16:39:09 <Axman6> yeah I was condering using the IO instance - fthingBeingTested something `shouldThrow` ErrorCall "BtheMessage"
16:40:27 <hseg> (though that doesn't mean that a function can accept more parameters than naively follows from its signature, cf const :: a -> b -> a, which can type-correctly be used as const id 3 4)
16:40:59 <hseg> The thing is, (->) associates to the right, function application associates to the left
16:41:16 <hseg> so in my const example, const :: a -> (b -> a)
16:41:37 <hseg> but const id 3 4 = ((const id) 3) 4
16:42:00 <hseg> which typechecks because we can replace a by c->c
16:42:19 <hseg> giving const the type (c->c) -> (b -> (c->c)
16:42:28 <[itchyjunk]> hmm
16:42:40 <[itchyjunk]> i vaguely understand but not concretly :s
16:43:32 <hseg> Basically, to check if something typechecks, rewrite all function applications left-associative and type signatures right-associative
16:43:51 <hseg> and fully annotate all terms 
16:44:30 <hseg> so const id 3 4 = (((const :: a -> (b -> a)) (id :: a -> a)) (3 :: Int)) (4 :: Int) 
16:44:54 <hseg> Then check that every function application is of form (f :: a -> b) (x :: a)
16:45:18 <hseg> (or rather, (f :: a -> b) (x :: a'), where after some substitution, a=a')
16:45:46 <hseg> (so eg a=f Int, a'=Maybe x works)
16:46:46 <hseg> (of course, you're not expected to run a typechecker in your head -- that's A) what the compiler's for and B) something that you'll pick up intuitively after a while, but these are the rules)
16:47:14 <[itchyjunk]> can't wait till i pick it up intuitively :s
16:48:06 <hseg> Basically, the idea is that functions of multiple arguments can be seen as functions returning functions
16:48:26 <hseg> so e.g. (+) :: Int -> Int -> Int can be seen as having type Int -> (Int -> Int)
16:48:55 <hseg> (the type (Int -> Int) -> Int is very different)
16:49:30 <hseg> having made that step, (+) 3 4 must be read as ((+) 3) 4
16:49:41 <hseg> (because (+) (3 4) makes no sense)
16:50:12 <hseg> similarly, map :: (a->b) -> [a] -> [b] can be seen as having type (a->b) -> ([a]->[b])
16:51:05 <hseg> so map intToChar [0..5] must be (map intToChar) [0..5] and not map (intToChar [0..5])
16:51:11 <hseg> You follow?
16:51:16 <n1ck2> just wanted to say thank you for the great explanation, hseg. I learned a bit more today
16:51:24 <hseg> np
16:52:22 <hseg> You *need* the parentheses around the dlog for GHC to be able to distinguish map (dlog g h p) from (map dlog) g h p
17:23:50 <hseg> Hm. Have classes A,B,C such that B is defaultable from A, C is a subclass of both A and B (so I have overlapping instances A => C, B => C). Morally, there shouldn't be overlap here. GHC isn't convinced 
17:24:11 <hseg> ... makes sense though
17:25:31 <hseg> makes my life harder - am trying to refactor a class in position B as above by weakening one of its superclasses, and want to supply a copy of B for backwards compatibility
17:25:42 <hseg> Unfortunately, the above makes this impossible
17:26:54 <hseg> On further thought, situation is slightly different
17:27:24 <hseg> Have A defaults B, and there are some instances of B in the wild using this
17:27:59 <hseg> Splitting the hierarchy so A defaults B' instantiates B creates overlaps at the defaulted instances
17:29:28 <hseg> However, not having B' instantiate B causes places that used B in the context of its superclasses to complain of a lack of instance
17:29:41 <hseg> What to do...
17:32:17 <hseg> Could mark the B' => B instance OVERLAPPABLE...
17:34:31 <hseg> nm, will work around this borken typeclass hier
17:46:02 <MarcelineVQ> does A defaults B mean that you can use A to write an instance of B?
17:47:51 <hseg> More than that: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#default-method-signatures
17:48:41 <hseg> Specifically, I have https://hackage.haskell.org/package/algebra-4.3.1/docs/Numeric-Domain-Euclidean.html#t:Euclidean
17:49:39 <hseg> I want to split it into ZeroProductSemiring d => EuclideanSemiring d and (PID d, EuclideanSemiring d) => Euclidean d
17:50:18 <hseg> Except the GCDDomain d => Euclidean d instance relies on being able to default Euclidean d via Divisible d
17:52:34 <jackdk> With cabal-install v2-* commands, Is there a way to pre-populate a global store, so if multiple users are on one machine, they do not each have to build duplicate libraries in their home directory?
17:52:59 <maerwald> jackdk: if you have access to an s3 bucket, consider using cabal-cache
17:53:05 <maerwald> !hackage cabal-cache
17:53:13 <maerwald> @hackage cabal-cache
17:53:14 <lambdabot> http://hackage.haskell.org/package/cabal-cache
17:54:38 <jackdk> maerwald: thanks for the pointer. This doesn't seem to be the right solution for me: I won't have a S3 bucket handy, and my main concern is disk space, not build time.
17:55:58 <jackdk> (objective: setting up a haskell environment for students in a v2-compatible way, and not blowing up the network mounts that provide student home directories)
17:56:15 <MarcelineVQ> could try giving them a cabal config that points to a common store  https://cabal.readthedocs.io/en/latest/nix-local-build.html#cmdoption-store-dir
17:56:29 <maerwald> uhm... writable?
17:56:42 <maerwald> sounds like big boom
17:58:23 <jackdk> I can probably to cabal-install-3.0.0.0 and v1-install the necessary packages for the common environment, but it sounds like I'd better file an issue against cabal-install to find a longer-term solution
17:58:48 <jackdk> single store dir means either having a world-writeable dir shared between users or not being allowed to install anything ever
18:01:46 <MarcelineVQ> is there an fs type that can handle that sort of multiple write-capable-users thing, a users sort of transparently checks out a snapshot of directory by using it so other people don't obstruct them with their use
18:03:36 <jackdk> not that I'm aware of. I was hoping for a sort of "oh, the option you want is --X". This seems like it'll be gnarlier than that, and I'll have to come back to it. Thanks MarcelineVQ.
18:03:59 <hseg> MarcelineVQ: As in, group-writable?
18:10:45 <MarcelineVQ> hseg: I don't know, I'm having trouble googling that term, but anyone in the group has the same view of that directory right? I'm thinking of something that lets you maintains a view/environment per user, so that edits each make don't conflict with each other, and these edited dirs/files can be consolidated when user doesn't have referenced/handles to them anymore
18:11:33 <hseg> That would imply a restriction on the form of edits that can be made to make edits automergeable
18:11:46 <hseg> eg a commutative append-only system
18:12:07 <hseg> (think work-stealing queues)
18:12:28 <MarcelineVQ> I suppose, how do distributed fs handle this?
18:18:32 <hseg> AFAIK, with locks or by enforcing mergeable edits
18:18:41 <hseg> (eg git's --ff-only development model)
18:31:54 * hackage construct 0.2 - Haskell version of the Construct library for easy specification of file formats  https://hackage.haskell.org/package/construct-0.2 (MarioBlazevic)
18:44:06 <deselby> So, I've really tried to use stack whenever possible, the one exception being HIE. But that leaves me without a globally avaliable ghci. How can I install ghci in order to use a repl within spacemacs?
18:45:07 <deselby> Or how should I configure the haskell layer so it can use “stack ghci”?
18:59:58 <hseg> Dammit. GHC is _still_ complaining about my dependent types
19:00:27 <koz_> hseg: This will happen a lot. :P
19:03:19 <hseg> Code and errors here: https://gist.github.com/hseg/13f06ce0c52034832195206d41c32d4c
19:07:44 <fresheyeball> dispatchEvent_ w =<< trace "popEvent" (newPopStateEvent ("popstate" :: Text) Nothing)
19:07:51 <fresheyeball> I this using GHCJS.DOM
19:07:58 <fresheyeball> if I do it in javascript it works
19:08:02 <fresheyeball> the trace works
19:08:08 <fresheyeball> but the event doesn't seem to actually dispatch or something
19:08:11 <fresheyeball> listeners don't fire
19:08:30 <fresheyeball> window.dispatchEvent(new PopState("popstate))
19:08:33 <fresheyeball> works just fine
19:08:37 <fresheyeball> what is different here?
19:09:09 <fresheyeball> hamishmack: can you tell me what I am doing wrong?
19:10:53 <koz_> hseg: Could not deduce: (2 * Div n 2) ~ n arising from a use of ‘sp_c’ <-- this needs an extension
19:11:03 <koz_> Repeat after me: GHC does not know natural number arithmetic.
19:11:05 <koz_> At all.
19:12:39 <dmwit> It's not even a correct equality.
19:12:41 <hseg> Still broken with typelits-normalise
19:12:49 <dmwit> > 2 * (1 `div` 2) == 1
19:12:52 <lambdabot>  False
19:13:07 <hseg> This is in the "n is even" branch of a case analysis on n
19:13:09 <koz_> Also what dmwit said.
19:13:28 <koz_> hseg: How did you do said case analysis?
19:13:32 <hseg> eParity
19:13:53 <hseg> Compared mods to 0 and 1
19:14:33 <hseg> and constructed from the resulting evidence a decomposition n ~ q*2+r
19:14:42 <hseg> with r=0,1 as appropriate
19:16:11 <dmwit> Interesting. I don't know whether natnormalize is clever enough to notice that n ~ foo*2+0 implies n ~ 2*n.
19:16:16 <dmwit> Probably not?
19:16:28 <dmwit> sorry, n ~ 2*foo.
19:16:45 <dmwit> Maybe if you change sp_c to needing d ~ r*2. Maybe.
19:18:12 <hseg> Nope -- d~(2*r) makes GHC want (2 * Div n 2) ~ n , whereas d~(r*2) makes GHC want  (Div n 2 * 2) ~ n
19:18:38 <hseg> It's not an issue of natnormalize
19:19:05 <hseg> Look at the context vs the wanted -- there's a unification failure here
19:19:30 <dmwit> Is it possible that eParity has picked different d and r than you were hoping?
19:19:36 <dmwit> d specifically
19:19:46 <dmwit> eParity @n -- maybe?
19:20:02 <hseg> ... possible. Had that bug in developing eParity
19:20:23 <dmwit> Oh, yeah, that's definitely it.
19:20:28 <dmwit> I should have read the error more carefully.
19:20:48 <hseg> Yep!
19:20:57 <dmwit> "Could not deduce 2 * Div n 2 ~ n from d2 ~ (Div d2 2 * 2) + 0" means it thinks d2 is distinct from n.
19:21:05 <hseg> Applying eParity at d makes things work
19:21:32 <hseg> Code is fragile af wrt these things, but I don't really care atm
19:21:38 <hseg> just want it to work
19:22:23 <hseg> OK, let's see if that's what lies behind the other errros
19:23:54 * hackage sscan 0.2 - text UI for scanning with SANE  https://hackage.haskell.org/package/sscan-0.2 (spwhitton)
19:24:33 <hseg> WTF? never have seen this type of error message before: ‘p’ is untouchable
19:25:25 <dmwit> existentials are hairy beasts
19:26:01 <ivab> hi
19:26:03 <dmwit> my nightmares are haunted by heffalumps and skolems
19:26:05 <hseg> Lemme paste the code so you can follow along
19:26:10 * dmwit waves at ivab
19:26:16 <hseg> yo
19:26:56 <dmwit> Just a dozen more and you'll be ivan. =)
19:27:46 <ivab> :) it'll be bavi, I just forgot to store the password in pass on this machine, too lazy to boot up the other one
19:28:25 <hseg> dmwit: the untouchables are here https://gist.github.com/hseg/13f06ce0c52034832195206d41c32d4c
19:28:39 <dmwit> ivɒd
19:30:01 <dmwit> hseg: code doesn't seem to match the error?
19:30:16 <dmwit> "Probable fix: add a type signature" but there is one.
19:30:34 <dmwit> Perhaps your real code has another so' somewhere that you haven't shown in your paste?
19:30:44 <hseg> Nope
19:31:37 <hseg> I simplified the type signature for so', but it was just expanding a type synonym
19:32:21 <dmwit> Oh, this is because you've pattern matched on the first argument before binding k.
19:32:42 <hseg> Really?
19:32:54 <dmwit> Consider `so' sdRaw k = case sdRaw of FramSNat (sd :: SNat d) -> withKnownNat sd $ ...`
19:32:57 <hseg> Ugh I hate singletons. So uncomfortable
19:33:12 <dmwit> a have a spach ampadamant
19:34:09 <dmwit> You'll probably eventually want to newtype wrap these foralls, too. Passing/receiving polymorphic stuff is very fragile.
19:34:12 <hseg> :D
19:34:20 <ivab> I'm going through Learn You a Haskell, enjoying it so far
19:34:32 <dmwit> ivab: Nice!
19:34:33 <hseg> What, the (forall d r . (KnownNat d, KnownNat r) => Lie d r F -> F) ?
19:34:36 <dmwit> yeah
19:34:43 <hseg> That's the type synonym I expanded
19:34:45 <dmwit> ivab: Got any plans for a project to work towards?
19:34:58 <hseg> ivab: Nice, wish you joy with it
19:35:15 <dmwit> hseg: Okay. But I think what I said is still true.
19:35:29 <hseg> Yeah, checking...
19:36:35 <ivab> dimwit: was thinking about maybe writing up some command line tools for use at work, see about recreating some stuff I normally do with bash
19:36:45 <dmwit> Oh, great idea!
19:37:08 <deselby> Why cann't I just “stack install ghci", what would be the equivalent command with cabal? Should I try this: https://www.reddit.com/r/haskell/comments/euhpke/cabal_whats_the_best_way_to_have_common_packages/ ?
19:37:21 <Axman6> ghci is part of GHC
19:37:36 <Axman6> you can't install anything with stack without already having ghc installed
19:37:38 <dmwit> You can likely just use `stack ghci`.
19:38:06 <Axman6> if you run stack setup it will fetch the appropriate ghc (and thus ghci) based on your settings
19:38:07 <dmwit> The analogous command for cabal is `cabal exec ghci`.
19:38:26 <hseg> Hrm. No dice https://gist.github.com/hseg/13f06ce0c52034832195206d41c32d4c
19:38:30 <deselby> yes, I can, and it works, but not when trying to use spacemacs unfortunately. 
19:38:39 <dmwit> Stack will install GHC (and therefore ghci) for you with the stack command; cabal lets you manage your GHC installations yourself, but you could try ghcup if you don't want to do that.
19:39:05 <deselby> the Spacemacs layer needs a globally valiable ghci binary
19:39:27 <deselby>  * the Spacemacs layer needs a globally avaliable ghci binary
19:39:41 <hseg> ivab: nice. good idea for myself -- haven't learned to package haskell yet
19:39:47 <maerwald> deselby: use ghcup then
19:39:59 <deselby> thank you
19:40:05 <maerwald> it doesn't conflict with stack
19:44:30 <dasli> I'm using lenses from the "microlens" library, correctly I think. I get all sorts of type inference failures when I make the slightest equivalent transformation of an expression with lenses in it.
19:44:38 <dasli> Is this...common?
19:44:59 <Axman6> without any examples I've got no idea
19:45:40 <dasli> I figured that since they're so polymorphic maybe this is just a cost of using them.
19:47:07 <maerwald> better errors then getting something monoidal
19:47:42 <dasli> What does monoidal mean in this case?
19:48:26 <maerwald> mempty :D
19:50:51 <dasli> Axman6: how about this
19:50:57 <dasli> ```transform xC = do    x   <- gets (view _x)
19:50:57 <dasli>                      d   <- gets (view _d)
19:50:57 <dasli>                      let xL  = x^._1 - (d^._1 / 2)
19:50:57 <dasli>                          xR  = x^._1 + (d^._1 / 2)
19:51:00 <dasli>                      return (min 1 (max 0 ((xC - xL) / (xR - xL))))```
19:51:10 <dasli> That checks
19:51:31 <dasli> ```transform xC = do    x   <- gets (view (_x . _1))
19:51:31 <dasli>                      w   <- gets (view (_d . _1))
19:51:31 <dasli>                      let xL  = x - (w / 2)
19:51:31 <dasli>                          xR  = x + (w / 2)
19:51:34 <dasli>                      return (min 1 (max 0 ((xC - xL) / (xR - xL))))```
19:51:38 <dasli> That doesn't.
19:51:48 <hseg> dmwit: :facepalm: I only *thought* I had a a signature. Have several functions of this kind, and had given them all signatures. Missed this one
19:52:01 <ivab> hm
19:53:37 <ivab> I like that this book is going over implementation of built in functions like take, repeat, etc 
19:55:14 <ivab> dasli is something going weird with the integer division in your example? pure guess
19:55:49 <dasli> Oh like maybe it's a numeric thing? Could be.
19:56:09 <dasli> It's giving me grief about (Double, Double) not matching Double or something
19:58:02 <ivab> rut roh
20:01:49 <dasli> Ugh, no. Even with an annotations it insists that the final values are of type (Double, Double) in the second case, but of type Double in the first case.
20:01:56 <dasli> That is messed up.
20:03:54 <hseg> Would recommend annotating everything in sight until a more understandable error occurs
20:04:07 <hseg> Try extracting stuff into where clauses as well
20:06:03 <dasli> I've already spent twice as long as I should have on this.
20:06:22 <dasli> Thank you
20:06:30 <hseg> Heh, you're telling me. I've spent the past week on this stupid project
20:06:47 <hseg> And am getting sorely tempted to just go to Sage
20:08:36 <nshepperd> hseg: this is why you should only simplify pasted code into something which other people can compile and reproduce the error
20:08:54 <hseg> ... ?
20:09:16 <nshepperd> you pasted code that had a function with a type signature
20:09:28 <nshepperd> but your actual code didn't have the type signature
20:09:45 <dasli> hseg or me?
20:09:50 <hseg> me
20:10:11 <hseg> you're responding to what we were talking about 20m ago?
20:10:17 <nshepperd> yeah
20:10:45 <hseg> yeah, but I'm not about to make you trawl through my >300LoC file to find the error
20:10:50 <hseg> it's a balancing act
20:11:37 <ivab> ah this quicksort example is so pretty
20:14:57 <nshepperd> hseg: you can take things out (or replace definitions with 'undefined') to reduce the size, but just test it with ghc to make sure you still get the same error
20:15:08 <hseg> Right
20:15:45 <ivab> I gotta wind down for the night, y'all have a good one!
20:15:57 <hseg> g'night ivab 
20:16:34 <hseg> nshepperd: is there some way of telling cabal "give me ghci with this file and my project's config"?
20:17:08 <hseg> because then i'd be able to just dump the parts i needed to a scratch file, cabal new-repl that file, check I still got the errors, and share them
20:18:41 <nshepperd> not sure
20:19:08 <nshepperd> i drink my ghci neat
20:19:31 <hseg> :) do you install your deps globally as well?
20:19:46 <nshepperd> usually
20:20:09 <hseg> huh. yeah, with nix-style it's pretty safe
20:20:24 <nshepperd> i've got a .ghc/x86_64-linux-8.6.5/environments/default with like 350 packages in it
20:21:05 <hseg> :-0
20:28:54 * hackage hanabi-dealer 0.4.0.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.4.0.0 (SusumuKatayama)
20:44:24 * hackage hkd-default 1.1.0.0 - Apply default value for optional field of HKD  https://hackage.haskell.org/package/hkd-default-1.1.0.0 (gqk007)
20:48:54 * hackage mapalgebra 0.2.0 - Efficient, polymorphic Map Algebra.  https://hackage.haskell.org/package/mapalgebra-0.2.0 (fosskers)
21:01:36 <Abdo> Hello everyone, can someone help me figure out how to print this Map in a specific format? I posted a code snippet here: https://pastebin.com/sVX69Jy1
21:05:00 <Axman6> Abdo: you will probably find that building a list of strings and then using intercalate will get you a long way
21:05:07 <Axman6> > intercalate "," {"a"
21:05:09 <lambdabot>  <hint>:1:18: error: parse error on input ‘"’
21:05:26 <Axman6> > intercalate "," ["a -> b", "c -> d", "e -> f"]
21:05:28 <lambdabot>  "a -> b,c -> d,e -> f"
21:05:36 <Axman6> > intercalate ", " ["a -> b", "c -> d", "e -> f"]
21:05:38 <lambdabot>  "a -> b, c -> d, e -> f"
21:12:19 <Abdo> Axman6 thank you, I'll try to give it a go.  I was trying to use intercalate ", " on Map.toList map but I wasn't having any luck.
22:21:36 <dmwit> ?tell hseg cabal exec ghci foo.hs
22:21:37 <lambdabot> Consider it noted.
