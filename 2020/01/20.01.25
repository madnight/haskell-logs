00:04:24 * hackage from-sum 0.2.3.0 - Combinators for working with Maybe and Either  https://hackage.haskell.org/package/from-sum-0.2.3.0 (cdepillabout)
00:14:33 <iqubic> Does ghc have a command line debugger? I'm looking for something like gdb for C.
00:14:44 <iqubic> Except that it debugs haskell code.
01:07:54 * hackage oidc-client 0.5.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.5.0.0 (ShoKuroda)
01:30:08 <gentauro> iqubic: when I (rarely) need to `debug`, I use `trace` (https://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html#v:trace) to do `old-school` pretty-printing :)
01:30:59 <gentauro> maybe it would be more correct to write `insert print statements` than `pretty-printing` to be fair ...
01:38:30 <Uniaika> iqubic: GHCi has :break and some other functions for breakpoints
01:54:36 <jpcooper> Morning. Could someone tell me how infixl and infixr interact? I couldn't get to the bottom of this from https://www.haskell.org/onlinereport/decls.html.
01:56:24 * hackage cabal-cache 1.0.1.4 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.4 (haskellworks)
01:57:18 <jpcooper> For instance, does precedence come first regardless of left/right fixity, and what is the resolution if two operators with equal precedence but differing fixity are encountered?
01:59:30 <jpcooper> Does the algorithm proposed in https://mail.haskell.org/pipermail/haskell-prime/2007-February/002123.html still hold?
02:07:51 <Lears> % let (*~) = (*); infixr 5 *~ in 1 + 2 *~ 3
02:07:51 <yahb> Lears: 9
02:07:54 <Lears> % let (*~) = (*); infixr 6 *~ in 1 + 2 *~ 3
02:07:54 <yahb> Lears: ; <interactive>:96:32: error: Precedence parsing error cannot mix `+' [infixl 6] and `*~' [infixr 6] in the same infix expression
02:07:57 <Lears> % let (*~) = (*); infixr 7 *~ in 1 + 2 *~ 3
02:07:58 <yahb> Lears: 7
02:08:14 <Lears> That's pretty much it.
02:09:25 <jpcooper> In essence it seems that for sequences of operators of equal precedence, either they must be all left or all right, or at most one operator with no fixity
02:38:54 * hackage bz2 0.1.1.0 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-0.1.1.0 (vmchale)
02:48:24 <dmj`> is there a better way to flip all the bits in an unsigned word32 than this
02:48:27 <dmj`> foldl' complementBit n [0..31]
02:48:56 <merijn> eh...
02:48:58 <merijn> :t complement
02:49:00 <lambdabot> Bits a => a -> a
02:51:41 <MarcelineVQ> which seems to xor by maxBound
02:52:38 <dmj`> merijn: ah, nice. My solution avoided the conversion to Word32 and back (assignment only gave Integer)
02:57:24 * hackage cpkg 0.2.4.2 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.2 (vmchale)
03:05:02 <muzzle> hi, I'm currently working on an emacs mode for interacting with ghci. What I want to do are two things: have a n interactive repl and also use ghci for stuff like go-to-definition using :info. I am wondering if there is a way to use one ghci session to do both. The challenge for me is that I don't want to have my 'automated commands' sent by the emacs-mode show up in the users repl.
03:08:57 <Heffalump> muzzle: could you just use an alternative (e.g. ghcide, haskell-ide-engine) for the IDE features?
03:11:18 <muzzle> Heffalump the problem for me is that haskell-ide-engine is still somewhat "heavyweight" and often gives me problems on installation
03:11:31 <muzzle> whereas ghcide is doesn't have proper editor integration
03:11:53 <merijn> muzzle: How does ghcide not have proper editor intergration?
03:11:54 <muzzle> And I want to build something that "just works" with emacs as long as you have your build-tool (cabal/stack) installed
03:11:58 <merijn> muzzle: Are you confusing it with ghcid?
03:12:06 <muzzle> merijn: yes
03:12:14 <muzzle> sorry :-P
03:13:04 <muzzle> My point being, that I don't want to necessarily have a layer of additional haskell code between the editor and ghci which can pretty much already do anything that you could want from an IDE
03:13:54 * hackage cabal-cache 1.0.1.5 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.5 (haskellworks)
03:14:04 <merijn> muzzle: You could write a custom ghci printer and wrap all emacs automated commands with some sentinel values that are stripped out by the printer?
03:16:57 <muzzle> I was thinking along these lines
03:17:17 <muzzle> that all replies to commands sent from emacs begin with a fixed prefix
03:17:35 <muzzle> that allows me to screen it out from the stuff that gets displayed to the user?
03:19:20 <merijn> "maybe"
04:38:24 * hackage logging-effect 1.3.9 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.9 (OliverCharles)
04:42:23 * hackage bz2 0.1.1.1 - Bindings to libbz2  https://hackage.haskell.org/package/bz2-0.1.1.1 (vmchale)
04:54:54 * hackage prometheus-metrics-ghc 1.0.1 - Metrics exposing GHC runtime information for use with prometheus-client.  https://hackage.haskell.org/package/prometheus-metrics-ghc-1.0.1 (OliverCharles)
06:22:52 <foldable> anyone could point me to implementations of lists with prolog-like cut?
06:23:11 <foldable> i found https://hackage.haskell.org/package/monoid-absorbing, i am pretty sure i have seen another one before but couldn't find it again
06:39:54 * hackage equational-reasoning 0.6.0.1 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.6.0.1 (HiromiIshii)
06:52:09 <infinisil> "As such, the final 8.10.1 release will likelycome in two weeks." :oo
06:52:18 <infinisil> From https://mail.haskell.org/pipermail/ghc-devs/2020-January/018530.html
07:05:00 <dmj`> jle`: ping 
07:11:54 * hackage Rasterific 0.7.5.1 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.5.1 (VincentBerthoux)
07:20:32 <maerwald> anyone using LanguageClient-neovim? It shows documentation, but zero diagnostics and there are no errors in the logs
07:42:41 <idnar> @hoogle Functor f => (a -> b) -> (t -> f a) -> t -> f b
07:42:41 <lambdabot> Control.Applicative.Tools (<.>) :: Functor f => (a -> b) -> (c -> f a) -> c -> f b
07:42:54 <idnar> mmm
07:47:11 <dramforever> :t (fmap . fmap) :: Functor f => (a -> b) -> (t -> f a) -> t -> f b
07:47:13 <lambdabot> Functor f => (a -> b) -> (t -> f a) -> t -> f b
07:48:16 <dramforever> :t fmap . fmap
07:48:18 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
08:11:01 <aveltras> anyone using dante with a project involving flags ? my package executable changs based on a flag defined in .cabal file, dante doesn't seem to recognize it even when default value of the flag is True
08:27:57 <justsomeguy> Doing a little arithmetic with the untyped lambda calculus today, and it feels like I'm writing assembly for an imaginary machine.
08:30:42 <justsomeguy> Kind of fun, actually.
08:31:07 <monochrom> No, asm has addition and multiplication ready-made.  What you're doing is building adders and multipliers from imaginary logic gates.
08:43:23 <justsomeguy> Even cooler then!
08:47:12 <Nolrai> Hey so I have a little CLI that reads files and spits out files, and can do so in several formats, whats a good/standard/post-bikeshedded way to enter both the imput and output formats?
08:52:06 <dmj`> Nolrai: json ?
08:52:29 <sm[m]> What do you mean Nolrai ?
08:54:54 * hackage persistent-pagination 0.1.1.1 - Efficient and correct pagination for persistent or esqueleto queries.  https://hackage.haskell.org/package/persistent-pagination-0.1.1.1 (parsonsmatt)
08:55:26 <Nolrai> So the data I am working with goes through a multi step format change, from json, to zlib-compressed into raw bytes, to modified base64, and also a pretty printed version of the data when read into haskell.
08:56:47 <MarcelineVQ> what do you mean by enter?
08:57:07 <Nolrai> As comand line arguments/options?
08:58:39 <c_wraith> optparse-applicative ?
08:58:41 <MarcelineVQ> you're looking for a standard method of formatting cli arguments for your program that has many format options?
09:00:12 <Nolrai> Right now I am using -j to mean input json, -J to mean output json, -b to mean input base64, -B to mean output base64 ect.
09:00:17 <Nolrai> Which feels kind of evil?
09:00:44 <MarcelineVQ> less evil would be   --from=   --to=
09:01:02 <Nolrai> Thank you!
09:01:08 <sm[m]> That’s what pandoc does
09:01:30 <MarcelineVQ> or even   -f json  -t base64
09:01:36 <MarcelineVQ> Which I see is also what pandoc does hehe
09:01:51 <sm[m]> hledger determines it from the file extension
09:08:54 * hackage ghc-lib-parser-ex 8.8.3.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.3.0 (shayne_fletcher)
09:10:33 <maerwald> https://hackage.haskell.org/package/magic is also an option if you don't trust file extension
09:11:52 <geekosaur> that only flies for "from" and is likely to be unreliable then
09:13:46 <sm[m]> it’s used for both input and output files as the default mechanism. But you can override it, with the -O FMT flag for output or the FMT: file path prefix for input
09:14:55 <maerwald> geekosaur: yes, --from could be optional, then it would first look if it has a file extension and determine it from that, if it doesn't, then run libmagic
09:18:57 <Nolrai> Magic would almost certianly work for input.
09:19:33 <Nolrai> Probably not worth the effort though? I'll think about it, thanks for pointing it out though.
09:19:43 <maerwald> API is not that complicated
09:21:19 <maerwald> and the dynamic lib can be assume on most systems
09:21:42 <Nolrai> I wonder if its easier then just trying to read it in each format in turn, they should fail pretty quickly when run on the wrong thing.
09:23:00 <maerwald> does "reading" entail IO?
09:23:31 <Nolrai> Not other then the file read and error messages.
09:23:46 <maerwald> if it's just boring pure parsing, then maybe, although not that elegant. If there's any IO involved, I would avoid that approach
09:24:18 <maerwald> makes handling errors more difficult (alternative instance may hide things)
09:24:55 <Nolrai> Honestly I'm not sure I want it to guess, just failing if I give it the wrong one might be nicer for now.
09:25:28 <maerwald> but if you use libmagic, you could guess from stdin :>
09:25:30 <maerwald> awesome
09:41:29 <sm[m]> ack..
09:45:03 <sm[m]> that’s what hledger does (tried each format in turn, if you don’t specify it). And as you say maerwald, it means sometimes you show the wrong error message with malformed input. I think it’s overall quite nice though as it keeps the default cli simple
09:45:30 <sm[m]> s/default/common case/
09:55:34 <idnar> @djinn (a -> b) -> (a -> c) -> a -> (b,c)
09:55:34 <lambdabot> f a b c = (a c, b c)
09:56:10 <hseg> idnar: mod permutation, = curry $ both ($c)
09:56:28 <idnar> @pl \a b c -> (a c, b c)
09:56:29 <lambdabot> liftM2 (,)
09:56:39 <hseg> Question: How do I tell ghc to trust me that certain patterns are exhaustive?
09:57:16 <hseg> (have patterns (0,_); (a,j) | someGuard; (a,j) | odd j; (a,j) | even j)
10:00:46 <hseg> ... odd that GHC complains about this -- it seems to think (Patterns not matched: (p, _) where p is not one of {0}) the guards are const False
10:02:35 <solonarv> GHC doesn't really inspect boolean guards
10:03:07 <solonarv> in your case: it doesn't know that exactly one of 'odd j' and 'even j' is true
10:03:47 <solonarv> you can get around this by replacing the last guard with 'otherwise' which always succeeds
10:03:50 <hseg> Ah. Any way I can tell GHC (via a pragma?) to trust me on this one?
10:03:50 <hseg> (don't want to turn off -Wincomplete-patterns globally)
10:04:11 <hseg> Yeah, but that's uglier and less true to the semantics
10:04:17 <hseg> *shrugs*
10:04:20 <hseg> no matter
10:04:31 <solonarv> you can also add a '| otherwise = error "impossible"' at the end, if you prefer
10:05:09 <hseg> Sure, that works
10:05:49 <hseg> Just noticed Brittany has the unfortunate default of indenting a long line of a guarded function to the same indent as its guard
10:05:58 <solonarv> eugh
10:06:06 <hseg> Yeah
10:06:08 <solonarv> I really dislike long indents like that
10:06:31 <hseg> Oh, no -- it puts the guard on a new line
10:06:35 <hseg> and indents it
10:06:43 <solonarv> oh, that's alright with me
10:06:52 <hseg> but guard indent = 2 and continuation indent = 4
10:07:16 <hseg> so since it formats guards as "| guard", continuation and guard are at same indent
10:07:26 <hseg> forcing you to check for a | to distinguish
10:08:19 <solonarv> I usually format my guards like this: https://gist.github.com/Solonarv/1cce633cee7322c773774054378bd914
10:10:21 <hseg> Yeah, that makes sense
10:10:32 <maerwald> that looks cryptic
10:10:58 <hseg> Although for guards << body feels wasteful
10:11:31 <nshepperd> I don't like how emacs sometimes indents continued expressions to the same level as the start of the expression. so i surround it in parentheses and end up writing lisp in haskell
10:11:53 <solonarv> if the guard and/or body is small, I'll leave them on one line
10:12:11 <maerwald> nshepperd: I also like parantheses!
10:13:50 <maerwald> especially nice with https://github.com/luochen1990/rainbow
10:14:11 <maerwald> well, that is a must-have plugin for lisp anyway
10:52:54 * hackage vectortiles 1.5.1 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.5.1 (fosskers)
10:54:24 * hackage mmsyn7ukr 0.9.4.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.4.0 (OleksandrZhabenko)
10:56:21 <alephu5> Hi everyone, I recently using Haskell for some side-projects and am really enjoying it. Out of curiosity do any of you use it professionally?
11:00:19 <hseg> Hi, can someone help me with some code review on https://github.com/hseg/experiments/tree/weyl-wip ?
11:00:58 <maerwald> alephu5: haskell is used in industry, if that's your question
11:01:34 <hseg> (That branch isn't working yet, am replacing usage of (->) by Map because 'algebra' has some stupid instances)
11:04:24 * hackage mmsyn7ukr 0.9.4.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.4.1 (OleksandrZhabenko)
11:08:29 <alephu5> maerwald: I know, just wondering if anyone in this channel has personal experience. What kind of projects they use it for and how they came to that decision
11:08:42 <maerwald> backend
11:09:56 <maerwald> alephu5: here is an "industry report" on a haskell backend architecture if that's what you're looking for https://tech-blog.capital-match.com/posts/3-anatomy-of-haskell-web-app.html
11:16:53 <alephu5> Looks interesting, thanks. I understand that it can be used for backend work, I've used yesod, persistent, esqueleto and servant for CRUD + HTTP stuff and it's pleasant but I would have a really hard time persuading my colleagues that we should use a stack like this instead of spring or django.
11:18:50 <piltii-heiskanen> alephu5: There was a good talk at lambdaconf a few years ago about how a person had gone about getting their colleagues on board with a switch over to functional programming in various aspects of the codebase.
11:19:19 <maerwald> alephu5: yes, why would you?
11:19:37 <maerwald> You should have a stronger use case for haskell other than "it's a nice language" imo.
11:19:51 <maerwald> It is a nice language, but it's also a strong commitment.
11:20:13 <piltii-heiskanen> A good starting point would be developing a small tool or utility that is used by the team, to show them.
11:20:48 <piltii-heiskanen> Nice starting point, then they aren't forced to fully commit to something unknown, and you can show them what it is like to do that kind of development there.
11:22:39 <maerwald> alephu5: for the blog I linked, there was no strong use case for haskell. Event sourcing is a solved problem in many languages and there exist frameworks. So what it really did was forcing a team to solve all those problems again.
11:23:05 <maerwald> That's a big trade-off
11:23:27 <alephu5> maerwald: That's why I'm interested in knowing why people decided it was the right choice for their business
11:23:51 <maerwald> If you're doing something more DSL-like, then haskell has far greater value
11:24:21 <maerwald> Which makes me wonder, why microservices are still so unpopular in haskell.
11:24:53 <alephu5> I have used it for prototyping at work and show colleagues the solution. No-one else knows haskell so I just briefly describe the algorithms and look at the performance
11:25:38 <maerwald> Interesting. Never used it for prototyping. I prefer shell or python there
11:25:55 <maerwald> I start to overthing everything once I open a haskell source file
11:25:57 <alephu5> I like python but it doesn't tell you much about performance
11:25:58 <maerwald> *overthink
11:27:32 <alephu5> It can be ~100x slower than a compiled language you have big data sets or streaming
11:28:04 <maerwald> well, one idea I had was rewriting a simple django app in postgrest... I think that's actually a reasonable use case: https://github.com/PostgREST/postgrest
11:29:01 <maerwald> given there's not too much business logic going on
11:30:03 <maerwald> if it becomes a problem, migrating away from haskell won't be a problem
11:37:07 <zincy_> maerwald: have you used postgREST in production? Just wondering how mature it is.
11:37:15 <maerwald> haven't
11:38:18 <zincy_> maerwald: Strong commitment, yes not a language you pick up in a day
11:38:49 <zincy_> just watched someone try and use . on a product value as a field accessor
11:39:32 <maerwald> send him to a 2 weeks lens course...
11:39:51 <zincy_> yeah then he can access a field hehe
11:40:15 <alephu5> zincy_: There are also fewer resources. In mainstream industrial languages you can get battle-tested tools and thousa
11:40:27 <alephu5> thousands of articles + stack overflow threads
11:41:03 <maerwald> alephu5: yes, performance intricacies are surprisingly scarce covered, for example
11:41:04 <zincy_> Yeah my team were talking about using a language that has official stripe bindings
11:41:27 <zincy_> so now its really either python or go, which one is less offensive for a Haskeller?
11:42:12 <maerwald> python can feel more functional-ish if you use the features. Generators etc can be an ok substitute for laziness
11:42:15 <alephu5> If it's network-oriented I'd suggest go, python is a little behind with that stuff
11:42:39 <maerwald> then you get half-typing with mypy if you want, lol
11:43:01 <zincy_> its just a payments api so I guess boring and battle tested from what someone told me is what I want
11:43:13 <maerwald> go is great for performance
11:43:35 <maerwald> and it's not too hard to achieve good performance
11:43:50 <zincy_> at least go is statically typed
11:43:52 <alephu5> I use python for web scraping and have a lot of problems with it, for example the standard library only supports HTTP 1.0
11:44:00 <alephu5> IT
11:44:18 <zincy_> Yeah pythons back end frameworks seem to be terrible in benchmarks
11:44:40 <alephu5> But more than that I have problems establishing propery connections with a lot of servers
11:44:56 <zincy_> interesting
11:45:02 <maerwald> go is used in timing sensitive real-time bidding systems and it works very well
11:46:05 <maerwald> but then again, those are all just things a CTO would think... not sure the people who have to use it will appreciate it :P
11:46:25 <zincy_> are you a CTO?
11:46:30 <maerwald> I hope not
11:46:43 <zincy_> haha
11:47:25 <hseg> WTF? • GHC internal error: ‘r’ is not in scope during type checking, but it passed the renamer
11:51:26 <geekosaur> hseg, is that in ghci? (although I think that was mostly in response to typed holes)
11:52:15 <hseg> no, that's ghci's response when loading a file
11:52:25 <hseg> Unfortunately, the file is pretty big
11:52:33 <hseg> and has other errors
11:53:14 <geekosaur> still ghci, which I think makes it a known issue. try -fobject-code, although I suspect this still fails
11:54:01 <hseg> Nope, still fails
11:57:24 * hackage arduino-copilot 0.0.1 - Arduino programming in haskell using the stream DSL  https://hackage.haskell.org/package/arduino-copilot-0.0.1 (JoeyHess)
11:58:24 * hackage arduino-copilot 1.0.0 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.0.0 (JoeyHess)
11:59:13 <walterclements[m>  * 
11:59:15 * walterclements[m sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/FmAfQKmAMsIdyrjKUmgfWOuD >
12:01:31 * walterclements[m sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/VcDnnbUXJOPSHxbEOdVDMhRe >
12:02:54 * hackage arduino-copilot 1.0.1 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.0.1 (JoeyHess)
12:03:39 <solonarv> walterclements[m: please try not to send such long messages. To people who aren't using matrix, they just turn into a link that we have to click before we have any idea what you're talking about
12:03:54 * hackage mmsyn7ukr 0.9.4.2 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.9.4.2 (OleksandrZhabenko)
12:04:11 <adamwespiser> walterclements[m: (yes, shorter messages, but okay to link to code examples?) .you could use an equality contraint.
12:04:33 * walterclements[m sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/qUQxMQvcQncWLbQWcroTdcMD >
12:05:00 <adamwespiser> myFun :: (Int ~ TypeFam a) => a -> b
12:09:55 * hackage dunai 0.6.0 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.6.0 (IvanPerez)
12:17:10 <hseg> ... Goddamn monomorphisation
12:18:19 <hseg> Wanted to write a function of type (x -> y -> r) -> (x -> y) -> (y -> x) -> (x -> r, y -> r)
12:18:28 <hseg> Of course:
12:18:36 <hseg> @djinn (x -> y -> r) -> (x -> y) -> (y -> x) -> (x -> r, y -> r)
12:18:37 <lambdabot> f a b c = (\ d -> a d (b d), \ e -> a (c e) (b (c e)))
12:19:05 <hseg> But I tried to refactor it with by extracting the common a.
12:19:11 <walterclements[m> thx
12:19:16 <hseg> That should be (a.)
12:19:36 <hseg> And that fails because it forces x ~ y by monomorphisation
12:20:49 <solonarv> the MMR doesn't kick in if you write an explicit type signature
12:21:03 <solonarv> but that hardly saves you any typing (pun intended)
12:21:05 <hseg> ok, then some other monomorphisation is happening here 
12:21:17 <solonarv> well, I don't know what you actually wrote
12:21:27 <hseg> was bitten similarly by defining f &&& g = \x -> both ($x)
12:21:39 <hseg> Wrote:
12:21:41 <hseg> fromIso :: (SNat n -> SNat m -> b) -> (SNat n -> SNat m) -> (SNat m -> SNat n) -> (SNat n -> b, SNat m -> b)
12:21:43 <hseg> fromIso h f f' = both (uncurry h .) (id &&& f, f' &&& id)
12:21:54 <hseg> And GHC complained n /~ m
12:21:57 <solonarv> oh, that's not "monomorphization"
12:22:10 <solonarv> that's just 'both' not being as general as it could be
12:22:16 <hseg> Implicit unification?
12:22:21 <solonarv> nothing implicit about it
12:22:37 <merijn> Where'd you get both from?
12:22:39 <hseg> Oh? Then how general could both be
12:22:59 <solonarv> I suspect 'both :: (a -> b) -> (a,a) -> (b,b)' with the obvious implementation
12:23:01 <hseg> defined myself, too lazy to write \f -> bimap f f
12:24:03 <solonarv> I'm not sure if the more general type can actually be written down even in GHC Haskell
12:24:34 <hseg> Experimenting, it seems both /= \f -> bimap f f
12:24:55 <hseg> Though don't know how to express the difference to ghc
12:25:12 <hseg> hm
12:25:19 <hseg> ghc doesn't know either
12:25:41 <hseg> syntactically, both f /= bimap f f
12:25:56 <hseg> but that distinction is lost once both values are bound
12:26:03 <hseg> wtf
12:26:10 <hseg> makes sense, but sucks
12:26:14 <solonarv> but it would look something like: ((a1 -> b1) <: (a -> b), (a2 -> b2) <: (a -> b)) => (a -> b) -> (a1,a2) -> (b1,b2)
12:26:44 <hseg> Right
12:27:02 <solonarv> where ( T <: Q ) means "T is a substitution instance of Q"
12:27:26 <hseg> oh ffs
12:27:35 <hseg> that means a bunch of refactorings are gonna suck rn
12:28:05 <hseg> have a bunch of sufficiently-general expressions with a common composition
12:28:38 <hseg> but they change types
12:28:50 <hseg> :(
12:36:24 * hackage conferer-hedis 0.2.0.0 - conferer's FromConfig instances for hedis settings  https://hackage.haskell.org/package/conferer-hedis-0.2.0.0 (ludat)
12:37:54 <kartjon> I need a few basic guidelines to get started with Haskell- do I wait in #haskell-beginners>
12:39:00 <maerwald> kartjon: have you installed the toolchain yet?
12:39:06 <hololeap> i'm getting an ambiguity error for this class definition: class IsPage t where defaultPath :: FilePath
12:39:31 <hseg> Have a value of type SNat n, why can't I pass it to a function expecting forall r. SNat r?
12:39:49 <kartjon> Perhaps to  explain first I use Linux- Have Haskell platform installed
12:39:52 <hololeap> Could not deduce (IsPage t0) ... bound by the type signature for: defaultPath :: forall t. IsPage t => FilePath
12:41:08 <kartjon> maerwald I basically need to know what else I need
12:41:20 <hololeap> it's suggesting i enable AllowAmbiguousTypes. is that the best thing to do? i also thought of changing it to `defaultPath :: (Proxy t, FilePath)` (although that seems clunky)
12:42:35 <kartjon> maerwald Every internet link I click refer to a bunch of new software to install for Haskell. 
12:43:00 <maerwald> kartjon: what do you mean with "what else I need"? What do you want to do?
12:43:32 <kartjon> maerwald What is the proper Software to have? Haskell platform, Gloss, ghc, ghci, Cabal, ?
12:43:44 <maerwald> ghc and cabal should be enough
12:44:48 <solonarv> hololeap: there are basically two ways of doing this
12:45:03 <hololeap> `newtype PagePath t = PagePath FilePath ; ... defaultPath :: PagePath t` seems to work
12:45:12 <solonarv> one is to use Proxy (usually as an *argument): defaultPath :: Proxy t -> FilePath
12:45:36 <solonarv> (or some other way to get 't' to appear on the RHS of that type definition, like Tagged)
12:45:48 <kartjon> maerwald then perhaps my knowledge of Linux doesn't get me to do much - I managed to get a Hello world going once
12:45:56 <solonarv> the other is to enable AllowAmbiguousTypes; in that case, TypeApplications is neeeded at the use sites
12:46:28 <maerwald> kartjon: you can start the interactive repl via 'ghci'
12:46:44 <solonarv> (ghci comes with ghc, it's just an alias for 'ghc --interactive'
12:46:46 <solonarv> )
12:47:10 <kartjon> oh ok solonarv
12:47:33 <solonarv> as already said you basically just need to install GHC and cabal to get started
12:47:38 <hololeap> solonarv: i was hoping i could set up `type PagePath t = FilePath`, but it gave me the same error. none of those solutions sound ideal
12:47:47 <solonarv> hololeap: yeah
12:48:27 <solonarv> I find the AAT + TypeApplicatins solution cleanest, but you are requiring the use sites to enable something seen as a fancy newfangled type system extension
12:49:00 <solonarv> kartjon: since you are on linux, I recommend using ghcup to install those two
12:49:02 <solonarv> @where ghcup
12:49:02 <lambdabot> https://www.haskell.org/ghcup/
12:49:05 <kartjon> ok then where my stuff get saved etc. should it be in .cabal or anywhere, ( what is default)
12:49:53 <solonarv> by default, everything cabal does lives in ~/.cabal, yes
12:50:22 <solonarv> ghcup mostly just downloads and manages ghc versions, and lives in ~/.ghcup (again, by default)
12:50:30 <hseg> Ooh, nice. Looks easier than the stack route I used last time
12:51:09 <kartjon> ok I will come back for more info thanks millions- I didn't want to keep installing new stuff- 
12:52:26 <hololeap> actually the TypeApplications idea doesn't sound too bad... it makes sense that you would need to tag something like my defaultPath with the intended type when you use it (since it's not declared anywhere else)
12:52:30 <solonarv> you can install libraries at need, installing them all up front is a... weird approach
12:52:36 <solonarv> hololeap: indeed
12:53:02 <solonarv> if you just use 'defaultPath' somewhere, you need to somehow say which instance you want!
12:53:24 <hseg> Why does GHC hate my calls to sp_c here? http://ix.io/28lL
12:53:59 <kartjon> thanks solonarv
12:54:00 <hseg> (Some code suppressed, available on request)
12:54:45 <hololeap> i remember when i tread beam i had never used TypeApplications before and it did seem really odd to me at first that a library would require it
12:55:01 <hololeap> but then it just became another part of the syntax
12:55:56 <hseg> Basically, idea is that c n should call sp_c @(2*n) @n, then pass it to the continuation, and sp should do the same (with obvious substitutions)
12:56:26 <`Guest00000> coronavirus
12:58:23 <hololeap> on the other hand, using Tagged would be handy if i needed to get the Page type info back from the FilePath
13:00:04 <hseg> Hrm. Just noticed some lists of conditional length that I'll need to convert to vectors. Joy
13:01:38 <walterclements[m> why are so many people leaving
13:03:15 <solonarv> this channel's fairly large (the largest on freenode, I think?), so that happens randomly sometimes
13:06:24 <int-e> lokomotivos: ##linux (1906 users) is biggest followed by #python (1817 users), of the channel alis knows about (numbers a few minutes old).
13:07:12 <hseg> Any ideas why the calls to sp_c here http://ix.io/28lL are illegal?
13:07:23 <hseg> GHC complains n is rigid
13:07:50 <hseg> and of a potential Skolem escape
13:16:54 * hackage cmt 0.7.0.0 - Write consistent git commit messages  https://hackage.haskell.org/package/cmt-0.7.0.0 (smallhadroncollider)
13:29:08 <hseg> Any ideas why the calls to sp_c here http://ix.io/28lL are illegal?
13:30:30 <Heffalump> hseg: the errors would help, I can't execute ghc in my head :-)
13:30:43 <Heffalump> oh, you said them earlier
13:31:02 <Heffalump> do you mean it says that the type of n is rigid?
13:31:06 <hseg> Yep
13:31:19 <hseg>      ‘n’ is a rigid type variable bound by
13:31:21 <hseg>         a pattern with pattern synonym:
13:31:35 <hseg> (Can't post original since I've edited the function since then
13:31:55 <hseg> Latest attempt: http://ix.io/28mn
13:32:34 <hseg> With errors: http://ix.io/28mp
13:33:04 <hseg> I think I might have switched the variables around, a moment
13:33:08 <Heffalump> which error do you want explained, the impredicativity or the rigid type errors?
13:33:40 <hseg> Both, if you don't mind
13:33:52 <hseg> whichever order is easier
13:34:05 <hseg> hrm, checking shows they're in correct order
13:34:46 <hseg> (first function should call at (2l,l), second at (d,d `div` 2), which matches the constraint (d ~ 2*r)
13:35:54 * hackage bearriver 0.13.1.1 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.13.1.1 (IvanPerez)
13:38:25 <hseg> Heffalump: ?
13:39:00 <Heffalump> hseg: do you really need to use a tuple binding for (c,sp)? Your code would be simpler if you made sp_c a top-level definition and had c and sp separately defined
13:39:36 <Heffalump> I'm not sure if the impredicativity complaints come from that but I think type checking does behave a bit differently with lambdas than functions
13:39:53 <Heffalump> at the very least it would be easier to diagnose your real problem
13:39:58 <hseg> No, not really. Original motivation was that they shared code
13:40:24 <Heffalump> the only benefit you get is abstraction ("hiding" sp_c from other code in that module)
13:40:34 <hseg> But turns out (\f -> bimap f f) f /= bimap f f
13:40:58 <hseg> have other code with much more duplication (6 variants on the same function)
13:42:34 <int-e> > (\(f :: forall a. a -> a) -> f f) id ()
13:42:36 <lambdabot>  ()
13:42:42 <hseg> Yep, lost the impredicativity complaints
13:42:48 <hseg> int-e: sorry, misexpressed mysel
13:43:01 <int-e> hseg: could something like that work, giving a sufficiently polymorphic signature?
13:43:05 <hseg> Nope
13:43:34 <Heffalump> hseg: can you repaste the latest code plus remaining errors?
13:45:44 <hseg> Heffalump: http://ix.io/28mv, http://ix.io/28mw
13:47:41 <hseg> int-e: The function that killed my code reuse: \h f f' -> both (uncurry h .) (id &&& f, f' &&& id) 
13:48:26 <Heffalump> hseg: I guess your first two errors are straightforward(-ish) type mismatches/unsatisfied constraints?
13:48:47 <hseg> Looks like it, even though I don't see why
13:49:09 <hseg> BTW, was hoping to extract commonality between c and sp with that lambda
13:49:41 <Heffalump> wha thappened to the type signatures for c, sp? I can't believe they'd type check sensibly without explicit type signatures given you want k to be a polymorphic function
13:49:52 <hseg> oops, missed them
13:50:09 <Heffalump> also try using brackets rather than $
13:50:18 <hseg> http://ix.io/28mA
13:50:19 <Heffalump> $ doesn't work well with rank-n polymorphism
13:50:26 <Heffalump> in the bodies of c/sp
13:51:19 <hseg> Really? as I recall, $ had some magic re that
13:51:37 <Heffalump> perhaps...but it being magic I wouldn't like to predict how well it works
13:51:45 <hseg> Right
13:52:51 <hseg> (cf section on impredicative instantiation here: https://gitlab.haskell.org/ghc/ghc/wikis/status/april07)
13:53:27 <Heffalump> also, in the interests of tracking down your error more clearly, turn your pattern guards into explicit case expressions in the bodies of c/sp
13:53:54 <Heffalump> and inline the pattern synonyms
13:54:19 <Heffalump> it might be that you gave SomeNat_ a bad type, if that's your code. Easy to get the givens and wanteds mixed up...
13:55:58 <hseg> No use: http://ix.io/28mB, http://ix.io/28mC
13:56:12 <hseg> What do you mean by "bad type"?
13:56:45 <Heffalump> too restrictive
13:57:14 <Heffalump> you didn't inline the pattern synonym yet 
13:57:17 <Heffalump> try that too
13:57:28 <Heffalump> even if errors don't go away, they become clearer as you simplify code
13:57:40 <Heffalump> and it helps nail down the real problem
13:58:54 <hseg> Which line of pattern <- foo where bar is it, again?
13:59:01 <hseg> the part after where?
14:00:39 <hseg> If so, how exactly am I supposed to inline pattern SomeNat_ x ... where     SomeNat_ (SNat :: SNat n) = SomeNat (Proxy :: Proxy n) ?
14:01:49 <hseg> OK, so I ripped out all mention of singletons.
14:01:52 <hseg> Still broken
14:02:39 <Heffalump> hseg: put in a Proxy in the pattern, I guess?
14:02:49 <hseg> http://ix.io/28mD, http://ix.io/28mE
14:03:26 <hseg> (Disregard the sd@(..) and sr@(...)
14:04:29 * Heffalump stares at it more closely
14:05:05 <hseg> You want full pragmas and imports?
14:05:20 <hseg> Think it'll be info overload
14:05:54 <Heffalump> well, at some point I might care enough to want to play myself in GHC :-) But right now I don't.
14:06:39 <hseg> OK
14:07:09 <Heffalump> actually, I wonder if it's simply that the type-checker has no idea that n ~ 2*r follows from SNat @d `sDiv` SNat @2
14:07:40 <Heffalump> so then it is an unsatisfied constraint and it needs to escape the scope of n (i.e. the pattern match on SomeNat)
14:07:44 <hseg> That's what
14:07:46 <hseg> {-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}
14:07:48 <hseg> {-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
14:07:50 <hseg> are for
14:07:54 * hackage yesod 1.6.0.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.6.0.1 (MaxGabriel)
14:08:04 <Heffalump> ok, we're now well outside what I have practical experience of :-)
14:08:08 <hseg> :)
14:08:12 <Heffalump> but suppose they aren't being solved?
14:08:21 <hseg> OK, let's assume that
14:08:41 <Heffalump> for example even on an arithmetic level it's not really obvious that n = 2*r follows from r = n `div` 2. What if n is odd?
14:08:55 * hackage yesod-core 1.6.17.1, yesod-auth 1.6.8.1 (MaxGabriel): https://qbin.io/duck-chairs-r9fi
14:09:28 <hseg> Well, I defined sDiv using typelits-witnesses' unsafeLiftNatOp2
14:09:35 <hseg> as having type sDiv :: SNat (m * n) -> SNat n -> SNat m
14:09:52 <hseg> Oh wait
14:09:56 <hseg> :facepalm
14:09:58 <Heffalump> ok, so then you're screwed
14:10:05 <hseg> Yeah, goddammit
14:10:09 <Heffalump> because n is universally quantified over all nats, but you want it to be an even nat
14:10:46 <hseg> Right.
14:11:11 <hseg> What if I gave sDiv the type k<=n => SNat (m*n + k) -> SNat n -> SNat m ?
14:11:14 <Heffalump> and next time you write this code, break it down more :-) If the body of the case had been a separate function it'd have been more obvious.
14:11:23 <Heffalump> well, you presumably want k < n
14:11:42 <Heffalump> but still, unless the solver is clever enough to know that any number can be expressed in that way, you're not going to get any further
14:11:51 <Heffalump> the GHC type checker certainly won't know that on its own
14:12:08 <Heffalump> maybe you could write some type function that can do some case analysis. Beyond my experience though.
14:12:39 <hseg> Yeah
14:12:41 <Heffalump> and then the constraints on sp_c would need to change too
14:13:38 <hseg> Probably could get away with some type family Div2 that would compute this
14:14:03 <hseg> And then have div2 :: SNat n -> SNat (Div2 n)
14:14:29 <hseg> Not sure how breaking the function down more would have shown this
14:14:30 <Heffalump> you still need sp_c's constraints to match up
14:14:45 <Heffalump> because you'd have had to write a clearer type signature for the code that calls k (sp_c ...)
14:14:56 <Heffalump> and then it'd have been obvious that just pattern-matching on SomeNat didn't meet the constraints
14:15:32 <hseg> OK... but there were no obvious breakup points
14:15:53 <Heffalump> this is with the benefit of hindsight, of course. Otherwise I'd have suggested it to begin with :-)
14:16:04 <hseg> Well, don't sp_c's constraints match up? Isn't d~2*r enough?
14:16:23 <hseg> Can add Even d as well, but don't think that will (or should) help
14:16:45 <Heffalump> just literally move k (sp_c ...) to a new function that you call. And write down its type signature.
14:17:15 <Heffalump> It'll be something like forall (d :: KnownNat) . (...) => ...
14:17:22 <Heffalump> and you'll discover that d has some constraints
14:17:30 <hseg> Hrm
14:17:54 * hackage n-ary-functor 1.0 - An n-ary version of Functor  https://hackage.haskell.org/package/n-ary-functor-1.0 (gelisam)
14:18:14 <hseg> Right -- the fact n needs to be even just came up here:
14:18:16 <hseg> • Couldn't match type ‘n’ with ‘2 * Div n 2’
14:18:55 <hseg> And now GHC has a valid complaint - I promised sp_c would only be called at even second parameters
14:21:20 <Heffalump> well, it always had a valid complaint :-)
14:21:27 <Heffalump> it just wasn't very clear
14:21:44 <hseg> :D
14:30:55 <hseg> OK, now to convince ghc that at the typelevel, for (d,r)=(m `divMod` n), m=n*d+r
14:31:16 <hseg> Eh, screw it. I'll just unsafeRefl
14:36:54 * hackage discord-haskell 1.3.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.3.0 (Aquarial)
14:39:18 <Heffalump> hseg: :-)
14:40:06 <Heffalump> hseg: I'd guess you could write it with some (runtime) case analysis that produces a Refl.
14:40:42 <Heffalump> or indeed use an unsafeCoerce Refl to skip that runtime cost
14:40:48 <hseg> Right, which is what I'm doing with the axiom   :: forall m n d r . (m `Div` n :~: d) -> (m `Mod` n :~: r) -> (m :~: d*n+r)
14:41:03 <hseg> (am unsafeRefl'ing that only)
14:44:42 <hseg> OK, now just need to chase down the (n-2) and (2<=?n) constraints
14:47:19 <hseg> Hrm. Errors are nonlocalized...
14:47:38 <hseg> Though they both occur in c, so at least there's that
14:48:09 <hseg> Ah, misread the SNat api
14:48:20 <hseg> (%*) :: SNat n -> SNat m -> SNat (n - m)
14:48:34 <hseg> How on earth did this ship?
14:57:07 <hseg> Dammit. typelits-witnesses only packages for stack
14:57:09 <hseg> wtf?
15:04:08 <hseg> :-S Guess I need to break out singletons *shudders*
15:05:05 <Heffalump> what do you mean "only packages for stack"? I see it on hackage
15:05:18 <mearon> Hi all. I have a problem. I am writing a program (for university) which is based on this: https://github.com/bigmac2k/HSMateLight/
15:05:55 <mearon> The project is nearly finished (and is due / must be uploaded in 7 hours), but there is one final blocker.
15:06:18 <hseg> Yeah, but there's no .cabal file
15:06:24 <hseg> So cabal doesn't pick it up
15:07:02 <mearon> During the development I wrote a very small terminal simulator for the project, so I didn't run the "main" `runMate` here: https://github.com/bigmac2k/HSMateLight/blob/master/Main.hs#L24
15:07:38 <Heffalump> hseg: how did they upload it to hackage without a .cabal file?
15:07:48 <mearon> The thing is that my event function is of type `event :: [Event String] -> State -> IO (ListFrame, State)`
15:07:59 <hseg> Have no idea. sdist?
15:08:09 <Heffalump> it has a package.yaml, isn't there some generator that produces a .cabal file? I forget the name of the widely-used thing that does that.
15:08:11 <mearon> But runMate complains about the `IO` part.
15:08:15 <hseg> Hrm. Just noticed there's stack2cabal
15:08:34 <hseg> I'll just use that and submit a pull request
15:08:35 <Heffalump> hackage will have a .cabal file, I'm sure..
15:08:52 <hseg> instead of rewriting my project hasochistically
15:09:02 <Heffalump> hpack is what I was thinking of
15:09:07 <Heffalump> and here's the generated file: https://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/src/typelits-witnesses.cabal
15:09:08 <ChaiTRex> mearon: What is runMate?
15:09:35 <hseg> This file has been generated from package.yaml by hpack version 0.31.1.
15:09:57 <hseg> Right, so I suppose I could just plop the .cabal file into the directory and be good?
15:10:07 <mearon> So I tried to change the signature here (changed `(f, s)` to `IO (f, s)`): https://github.com/bigmac2k/HSMateLight/blob/master/Network/MateLight/Simple.hs#L26
15:10:15 <mearon> But that sadly didn't work :/
15:10:53 <mearon> ChaiTRex: It's the "main" function in the framework HSMateLight. Sorry, I can't explain it better :/
15:11:09 <mearon> We were provided with this program framework to build our project on top of that.
15:11:12 <Heffalump> hseg: or run hpack..
15:11:24 <Heffalump> or download the package from hackage
15:11:37 <Heffalump> but yes in theory if nothing has changed in git then downloading the one from hackage would work
15:12:10 <ChaiTRex> mearon: So you have a function that returns (ListFrame, State) inside an IO do block?
15:12:11 <hseg> good
15:12:44 <mearon> HSMateLight can be used to create projects which can display stuff on a (physical)  screen of "pixel bottles", like here: https://www.youtube.com/watch?v=8_YbHFF25Rc
15:13:03 <mearon> ChaiTRex: yes.
15:13:45 <mearon> Also, please forgive me for asking possibly stupid sounding questions. We have not actually learned anything about monads yet (and I barely know about them).
15:14:12 <mearon> Most groups decided to implemented a simple jump and run game on that screen, which doesn't require mondas / IO stuff in their functions.
15:14:15 <hseg> And fixing that bug killed the last error message on *that* function
15:14:24 <hseg> Two more functions to go...
15:14:42 <mearon> But I've decided to create an audio visualizer (real time spectrogram), and that requires my even function to read from a file/stream
15:16:08 <ChaiTRex> mearon: And you want to provide your event function as the ([Event String] -> s -> (f, s)) function for runMate?
15:16:36 <ChaiTRex> mearon: Ahh.
15:16:38 <mearon> ChaiTRex: yes!
15:16:53 <mearon> Here is my simple terminal simulator: http://dpaste.com/0JYAB2N
15:17:24 <mearon> I just ran that instead of the runMate function (which connects to a public accessable emulator online and displays stuff there) the whole time.
15:18:54 * hackage configuration-tools 0.4.2 - Tools for specifying and parsing configurations  https://hackage.haskell.org/package/configuration-tools-0.4.2 (fosskers)
15:19:27 <mearon> I can also upload my whole project somewhere if that would help. It's currently in a private gitlab repo.
15:19:47 <ChaiTRex> mearon: My brain isn't operating very well right now.
15:20:45 <mearon> Oh. Hope it's nothing serious and just exhaustion from some hackathon :)
15:21:04 <ChaiTRex> Is there a way to convert a -> b -> IO c to IO (a -> b -> c)?
15:21:21 <mearon> ChaiTRex: you mean my event function?
15:21:43 <mearon> I whish I had more time to learn about monads...
15:22:00 <ChaiTRex> mearon: Yes.
15:22:11 <mearon> Let me check...
15:22:15 <ChaiTRex> mearon: If all else fails, there's unsafePerformIO.
15:22:29 <ChaiTRex> mearon: But I figure there's a nicer way.
15:23:44 <mearon> brb in 2 minutes...
15:25:03 <ChaiTRex> I think there's no way in general to do a -> b -> IO c to IO (a -> b -> c), since the c value can change in the first one from call to call.
15:26:08 <solonarv> you are correct.
15:26:13 <ChaiTRex> mearon: How does your event function work? Maybe there's a way to produce an IO (a -> b -> c) from the start.
15:28:18 <mearon> ChaiTRex: Re. This is my event function: http://dpaste.com/3D2Z31C
15:28:33 <mearon> ChaiTRex: Thanks a lot for looking into this!
15:30:21 <ChaiTRex> mearon: It looks like getSample is the IO part.
15:30:27 <ChaiTRex> mearon: What's the definition of getSample?
15:30:38 <mearon> hang on.
15:31:59 <mearon> getSample: http://dpaste.com/2NXM3DG
15:32:15 <mearon> The putStrLn's can obviously be ignored...
15:33:57 <mearon> And this is the main function: http://dpaste.com/2XDGRPC
15:35:01 <mearon> It just opens a WAV file (can be a stream) and analyzes the header a bit, the relevant part is probably line 25/26
15:36:27 <ChaiTRex> mearon: What does fftspec do?
15:36:46 <mearon> fast fourier transformation
15:37:03 <ChaiTRex> mearon: Does it need to be in IO?
15:37:16 <mearon> I don't think so, let me check...
15:38:08 <mearon> Huh, no it actually doesn't need to be in IO. It's an artifact from earlier...
15:38:47 <ChaiTRex> mearon: Well, the short way is to use unsafePerformIO with event.
15:39:22 <ChaiTRex> mearon: The long way is to provide a lazy bytestring (I think that's what you're using) containing the entire contents of a file to the event function.
15:39:40 <ChaiTRex> mearon: Then, since the IO is done before you enter the event function, event can be done without IO.
15:40:32 <ChaiTRex> mearon: The short way is something like event' a b = unsafePerformIO $ event a b
15:40:40 <mearon> Ah! That makes sense. It doesn't sound like a very long way to me (could be wrong very well, since I'm fairly new to Haskell).
15:40:59 <mearon> It thought I have to dig into the runMate definitions (which looks... looong) to make it work.
15:41:24 <mearon> unsafePerformIO sounds just like the right thing for the situation right now (if everything else fails), due to the time limit.
15:41:37 <mearon> But I'd like to do a more 'clean' solution eventually.
15:42:05 <daydaynatation> How to understand the ((->) r in instance MonadReader r ((->) r) where ...
15:42:09 <ChaiTRex> mearon: With IO, you generally want to limit the IO part to just the stuff that deals with IO. So, reading an entire file, for example.
15:42:20 <ChaiTRex> mearon: Then, you use pure functions on the data you get from the IO functions.
15:42:30 <ChaiTRex> mearon: Pure being non-IO.
15:42:45 <daydaynatation> (->) r is any function that results a r ?
15:42:55 <mearon> ChaiTRex: Okay, that makes sense.
15:43:07 <mearon> ChaiTRex: Thanks a lot for your help again. I really appreciate it.
15:43:11 <solonarv> daydaynatation: no. (->) is partially applied, here
15:43:14 <ChaiTRex> mearon: You're welcome.
15:43:40 <solonarv> (A -> B) can also be written in prefix form as: (->) A B
15:43:54 <solonarv> you can leave off the last argument and you get ((->) A)
15:44:12 <daydaynatation> solonarv: ok so it's any function that takes r as argument?
15:44:15 <solonarv> in pseudo-Haskell syntax, we could write it as (A -> _)
15:44:24 <jle`> daydaynatation: one of the easier ways to understand is just to look at the type of its methods
15:44:24 <solonarv> yes, it is "functions that take r as argument".
15:44:24 * hackage bzip-signature 0.1.1.1 - Backpack signature for BZip compression  https://hackage.haskell.org/package/bzip-signature-0.1.1.1 (vmchale)
15:44:28 <jle`> and maybe see if you can understand it
15:44:34 <ChaiTRex> daydaynatation: As its first argument, in particular.
15:44:42 <jle`> class MonadReader r m where ask :: m r
15:44:57 <jle`> so when m is (->) r, then ask :: ((->) r) r
15:45:01 <jle`> or ask :: r -> r
15:45:16 <jle`> so instance MonadReader r ((->) r) where ask = id
15:45:16 <daydaynatation> so basically any function that takes one argument is of the monadreader type class ?
15:45:31 <jle`> daydaynatation: the function itself isn't an instance, but (->) r, the type, is an instance
15:45:38 <jle`> also all functions in haskell take one argument
15:46:00 <dmwit> Dissenting opinion: `(->) r` is not "functions that take r as argument".
15:46:09 <dmwit> Because it is not the type of any function.
15:46:13 <jle`> so all `(->) r` are instances
15:46:23 <daydaynatation> (reverse "a string") is a MonadReader type?
15:46:29 <jle`> daydaynatation: no, that's a value
15:46:35 <jle`> MonadReader instances are types
15:46:52 <daydaynatation> ok
15:46:58 <jle`> hm, are you familiar with the distinction between values (terms) and types?
15:47:04 <daydaynatation> yes
15:47:18 <daydaynatation> sometimes i'm confused though but i get it
15:47:48 <daydaynatation> could you give me one example of (->) r ?
15:47:54 <daydaynatation> as a type
15:48:19 <jle`> (->) Int)
15:48:25 <jle`> * (->) Int
15:48:29 <jle`> (->) Bool is another
15:48:37 <daydaynatation> ok
15:48:59 <daydaynatation> so (+) is a value of (->) Int
15:49:12 <daydaynatation> (+ 5)
15:49:12 <jle`> no, (+) is a value of type Int -> Int -> Int
15:49:22 <jle`> (+ 5) is ((->) Int) Int
15:49:27 <jle`> so it's ((->) Int), applied to Int
15:49:34 <solonarv> there are no values of type '(->) Int', however
15:49:42 <jle`> just like how `Just 3` is Maybe Int, it's Maybe applied to Int
15:50:18 <daydaynatation> solonarv: why there are no values of type (->) Int ?
15:51:08 <ChaiTRex> daydaynatation: You need to apply (->) Int to another type to get a type that can hold values.
15:51:25 <ChaiTRex> daydaynatation: Like (->) Int Int = Int -> Int has some values.
15:51:34 <daydaynatation> ok i see
15:51:38 <ChaiTRex> daydaynatation: (+1) is one of the values.
15:52:12 <jle`> daydaynatation: there are no values of type Maybe, and no values of type IO
15:52:15 <daydaynatation> so (+1) is one value of type ((->) Int) Int
15:52:20 <jle`> daydaynatation: but there are values of type Maybe String, IO Bool, etc.
15:52:25 <ChaiTRex> daydaynatation: It's like Maybe. There are no values of type Maybe. But if you apply Maybe to another type like in Maybe Int, you can get values like Just 5.
15:53:27 <daydaynatation> I'm just tyring out the MonadReader class for (->) r, it seems quite bizzare and not easy to grasp
15:53:33 <daydaynatation> it's usefulness
15:54:19 <jle`> daydaynatation: ah, so you understand what it does and how to implement
15:54:23 <jle`> but just not why someone would want it?
15:55:35 <daydaynatation> yes
15:55:50 <daydaynatation> and I kinda want to try the do notation on -> r
15:55:55 <jle`> well, the same reason why anyone would want to use any typeclass
15:56:10 <daydaynatation> it's fun to use do notation on such unlikely situation
15:56:11 <jle`> er, the same reason why someone would want to use any typeclass instance
15:56:34 <jle`> the reason is so you can use code polymorphic over all MonadReader r, with (->) r
15:56:44 <jle`> daydaynatation: you don't need MonadReader to use ((->) r) with do notation
15:56:49 <jle`> daydaynatation: you only need Monad
15:57:06 <daydaynatation> I mean use ask in -> r
15:57:06 <jle`> daydaynatation: the reason where you would want to use the MonadReader r ((->) r) is exactly this single reason:
15:57:18 <jle`> daydaynatation: let's say you come across code that someone has written
15:57:28 <jle`> and it is written polymorphic for all MonadReader r m
15:58:07 <jle`> like, theirFunc :: MonadReader Int m => Bool -> m String
15:58:21 <jle`> and you think "oh boy i would liek to use that as a normal function, like theirFunc :: Bool -> Int -> String"
15:58:30 <jle`> so then you can just call `theirFunc True 6`, and it would work
15:58:41 <jle`> because there is an instance for MonadReader Int ((->) Int)
15:58:53 <jle`> daydaynatation: using ask is pointless if you are using ((->) r) already
15:58:58 <jle`> daydaynatation: you might as well just use 'id'
15:59:24 <jle`> if you already know your specific data type/specific instance, there isn't any good reason to use the typeclass version if a specific version exists for your type
15:59:30 <jle`> for example, would you ever write:
15:59:30 <daydaynatation> I'm tyring to understand your example
15:59:34 <jle`> > Sum 3 <> Sum 5
15:59:36 <jle`> instead of:
15:59:36 <lambdabot>  Sum {getSum = 8}
15:59:38 <jle`> > 3 + 5
15:59:40 <lambdabot>  8
15:59:47 <jle`> there is no reason to use <> for Int if you can just use +
16:00:07 <jle`> the only reason why you would use <>/Sum is to use functions that someone else wrote that works for all monoids, theirFunc :: Monoid m => ...
16:00:58 <jle`> daydaynatation: so there is pretty much no reason why anyone would ever use 'ask' if they are already specifically in ((->) r)
16:01:26 <jle`> except maybe if it helps with readability
16:01:26 <daydaynatation> your theirFunc example seems interesting
16:01:31 <daydaynatation> but I dont get it yet
16:01:39 <jle`> let me define a function with that type
16:02:15 <jle`> @let theirFunc :: MonadReader Int m => Bool -> m String; theirFunc b = asks $ \i -> show b ++ show i
16:02:17 <lambdabot>  Defined.
16:02:20 <jle`> :t theirFunc
16:02:22 <lambdabot> MonadReader Int m => Bool -> m String
16:02:44 <jle`> now you're checking around a package and you see such a function with that type
16:03:00 <jle`> the reason why you would use ((->) Int) is so that you can use theirFunc as a normal Bool -> Int -> String function
16:03:03 <jle`> > theirFunc True 5
16:03:05 <lambdabot>  "True5"
16:04:03 <jle`> so the (->) Int instance is only useful if you already have a function that is polymorphic over MonadReader in the first place
16:04:39 <daydaynatation> thank you for the patience. let me read a few times your example to sink in
16:05:41 <jle`> your next question might then be "why would anyone ever want to write a function polymorphic over all MonadReader", perhaps :)
16:06:42 <daydaynatation> I'm making a summary of all the ways Haskell define custom types
16:06:50 <daydaynatation> common ways
16:07:02 <daydaynatation> I know there are product and sum types
16:07:18 <daydaynatation> but in reality there several patterns
16:07:24 * hackage kanji 3.4.1 - Perform 漢字検定 (Japan Kanji Aptitude Test) level analysis on Japanese Kanji  https://hackage.haskell.org/package/kanji-3.4.1 (fosskers)
16:07:51 <daydaynatation>  
16:07:51 <daydaynatation> concret type
16:07:51 <daydaynatation> type with one parameter
16:07:51 <daydaynatation> type with several type parameter such as ReaderT, StateT
16:07:54 <daydaynatation> type by wrapping other existing type
16:07:57 <daydaynatation> type by wrapping functions such as ReaderT
16:08:00 <daydaynatation> type class with one type
16:08:04 <daydaynatation> type class with several types
16:09:09 <jle`> hm, i think those things are in different categories
16:09:34 <jle`> product and sum types are the types themeselves underneath, but the things you are talking about are more different ways of parameterizing types, not creating types
16:09:43 <jle`> in fact all those distinctions are actually what people call 'kinds'
16:10:01 <jle`> er well, some of those
16:10:31 <jle`> but all ADTs are really just some combination of sums and products (and functions)
16:10:47 <jle`> daydaynatation: like data Either a b = Left a | Right b
16:10:57 <jle`> that's a type that is the sum between 'a' and 'b'
16:11:09 <jle`> it just happens to be parameterized by type variables (several of them)
16:11:12 <daydaynatation> I find creating a new type by wrapping a function is hard to understand at first. such as: 
16:11:22 <jle`> but you could also just write data IntOrBool = I Int | B Bool
16:11:35 <daydaynatation>  
16:11:36 <daydaynatation>      newtype ConduitT i o m r = ConduitT
16:11:36 <daydaynatation>          { unConduitT :: forall b.
16:11:36 <daydaynatation>                          (r -> Pipe i i o () m b) -> Pipe i i o () m b
16:11:39 <daydaynatation>          }
16:11:49 <jle`> well that's just a difficult type in general, with a RankN function
16:11:52 <jle`> but how about something like
16:12:00 <daydaynatation> data types such as these are difficult to grasp
16:12:05 <jle`> data FromInt a = FR (Int -> a)
16:12:08 <jle`> is that one difficult?
16:12:39 <daydaynatation> I can understand basic types such as your example
16:12:43 <jle`> i could also give you a very complicated sum/product type as well
16:12:47 <jle`> that are difficult to understand
16:12:52 <jle`> do you see my point?
16:13:04 <jle`> ConduitT isn't difficult to understand because it is a function ... it's just difficult because it's complicated
16:13:09 <daydaynatation> Maybe, Either etc. but when it gets more advance, such as ContuiT, ParsecT etc..
16:13:09 <jle`> and you can have complicated sums or products too
16:13:19 <daydaynatation> I don't know how to reach that level
16:13:35 <jle`> you won't get there by jumping there :) it takes time
16:13:46 <jle`> usually a type like a parser combinator is a midterm project for a Haskell project
16:13:50 <jle`> so about two or so months in
16:14:07 <jle`> and then a parser combinator monad transformer, that sort of stuff might not come up until the second semester
16:14:12 <jle`> *for a Haskell course
16:16:02 <daydaynatation> Thank you man, let me reread your example, it's thought provoking
16:17:06 <dibblego> it's day 3 of data61 course!
16:44:24 * hackage zbar 0.1.1.0 - zbar bindings in Haskell  https://hackage.haskell.org/package/zbar-0.1.1.0 (vmchale)
16:59:53 * hackage smallcheck-kind-generics 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/smallcheck-kind-generics-0.0.0.0 (MatthewFarkasDyck)
17:16:57 <pounce> ugh, gotta figure out how to implement "Read"
17:18:43 <pounce> what is the precedence all about?
17:20:04 <ChaiTRex> pounce: Operator precedence, I'd assume.
17:21:13 <pounce> but why do you have to care about operator precedence when parsing arbitrary values?
17:23:17 <ChaiTRex> pounce: Some values have operators in them.
17:24:04 <MarcelineVQ> and syntax such as bracketing
17:25:53 * hackage password 1.0.0.0 - plain-text password and hashed password datatypes and functions  https://hackage.haskell.org/package/password-1.0.0.0 (cdepillabout)
17:26:53 * hackage password-instances 1.0.0.0 - typeclass instances for password package  https://hackage.haskell.org/package/password-instances-1.0.0.0 (cdepillabout)
17:49:24 <pounce> how do i turn a list into a list of pairs?
17:50:51 <hseg> pounce: There are many implementations, depends on what you want
17:51:01 <ChaiTRex> pounce: map a function that turns an element into a pair?
17:51:12 <hseg> Getting weird behaviour out of typelits-witnesses
17:51:23 <pounce> like, [1,2,3,4] -> [(1,2),(3,4)]
17:51:52 <hseg> http://ix.io/2464 with %+ replaced by %- demands to be shown 1 <=? n ~ 'True
17:52:13 <ChaiTRex> pounce: You can make a function pretty easily, though you need to decide what to do with odd-length lists.
17:52:16 <hseg> However, nowhere in the code for typelits-witnesses do I see this articulated
17:52:19 <solonarv> ah, I see
17:52:33 <solonarv> I would just go with the straightforward recursive implementation
17:52:36 <pounce> oki just didn't know if anything existed
17:52:53 <ChaiTRex> pounce: f (a:b:xs) = (a,b):xs; f _ = []
17:53:09 <ChaiTRex> pounce: Throws out the last element if it's an odd-length list, though.
17:53:30 <hseg> I mean, the types are nearly identical: (%+) :: SNat n -> SNat m -> SNat (n + m) vs (%-) :: SNat n -> SNat m -> SNat (n - m)
17:53:36 <LKoen> I assume it's f f(a:b:xs) = (a,b):f xs
17:53:51 <hseg> (same with implementations unsafeLiftNatOp2 (+) and (-))
17:53:56 <ChaiTRex> LKoen: Ahh, yes.
17:53:59 <solonarv> you could write it as an unfold, I suppose
17:54:16 <hseg> And checking for weirdness at (+),(-) :: Nat -> Nat -> Nat shows nothing
17:54:23 <ChaiTRex> You can also use splitEvery or whatever it is.
17:54:40 <ChaiTRex> @hoogle Int -> [a] -> [[a]]
17:54:41 <lambdabot> Data.List.Split chunksOf :: Int -> [e] -> [[e]]
17:54:41 <lambdabot> Data.List.Split.Internals chunksOf :: Int -> [e] -> [[e]]
17:54:41 <lambdabot> Hedgehog.Internal.Shrink removes :: Int -> [a] -> [[a]]
17:54:47 <ChaiTRex> Ahh, chunksOf
17:55:18 <ChaiTRex> > map (\ [a, b] -> (a, b)) . chunksOf 2 $ [1 .. 10]
17:55:21 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
17:55:23 <solonarv> % :t unfoldr (\case x:y:rest -> Just ((x,y), rest); _ -> Nothing) []
17:55:33 <solonarv> I don't like that partial pattern match
17:55:39 <solonarv> ...huh, yahb isn't here?
17:55:41 <solonarv> :t unfoldr (\case x:y:rest -> Just ((x,y), rest); _ -> Nothing) []
17:55:43 <lambdabot> [(b, b)]
17:55:51 <solonarv> :t unfoldr (\case x:y:rest -> Just ((x,y), rest); _ -> Nothing)
17:55:53 <lambdabot> [b] -> [(b, b)]
17:56:25 <solonarv> this has the advantage of being somewhat more amenable to list fusion (it's a "good producer")
17:57:33 <hseg> BTW, ghc's tracking of the provenance of the error could use some work -- replacing the continuation k in the linked code by an explicit invocation of Data.Vector.Sized.sum makes ghc blame the call to inspect instead
18:04:42 <zebrag> nofail :: [(a, String)]; nofail u = (first (head u), second (head u)) : (tail u); wouldn't it be sufficient to say? nofail u = (head u) : (tail u)
18:06:13 <zebrag> I fail to see in what 'first' and 'second' are adding since we know that the type is a (a, String)
18:06:55 <zebrag> The example is from wadler 85, so there must be something I'm missing
18:09:52 <zebrag> "This problem can be solved by introducing a new function, nofail. Just as cut guarantees that its result list contains at most one match, nofail guarantee that its result list contains a least one match.
18:11:11 <zebrag> I've always been puzzled by the introduction of the pair destructor, immediately followed by the pair constructor, in that formula.
18:11:52 <lukebfox[m]> what would be the point of an expression such as head x : tail x
18:12:12 <ChaiTRex> lukebfox[m]: Well, it ensures that if it succeeds, the list isn't empty.
18:12:13 <zebrag> it fails if x == []
18:12:36 <lukebfox[m]> yep thx
18:13:13 <hseg> 1/quit
18:13:18 <zebrag> but I don't see the need for first and second
18:13:30 <ChaiTRex> zebrag: Well, what if the head is (undefined, undefined)?
18:14:15 <ChaiTRex> zebrag: With just head, you're only evaluating to the (,) constructor.
18:14:18 <solonarv> (fst x, snd x) is not the same as x when x is undefined
18:14:25 <solonarv> s/undefined/bottom/
18:15:13 <zebrag> but bottom means it doesn't terminate?
18:15:29 <zebrag> so we just wouldn't know?
18:15:47 <ChaiTRex> zebrag: undefined terminates, it just doesn't give you a value.
18:16:00 <solonarv> yeah, bottom just means it doesn't compute a value
18:16:15 <zebrag> okay, I got it
18:16:16 <solonarv> we don't care to distinguish between "runs forever" and "throws an exception"
18:16:56 <zebrag> thanks
18:17:04 <zebrag> I missed those cases
18:18:22 <lukebfox[m]> how do you guys learn haskell libraries
18:18:40 <solonarv> depends on the library
18:18:43 <lukebfox[m]> have you picked them up as you go along, or are certain ones universally known to be useful
18:18:51 <lukebfox[m]> eg parsec
18:18:56 <solonarv> these statements are not mutually exclusive!
18:19:02 <solonarv> in fact I would say both are true
18:19:18 <lukebfox[m]> or /= xor
18:19:26 <lukebfox[m]> ok thank
18:19:34 <amalloy> i don't think anyone says, "i know there are 50 useful haskell libraries, so i will study them all before i need them"
18:19:37 <lukebfox[m]> im just starting out 
18:19:48 <solonarv> there are some libraries that are pretty widely used, some examples: containers, text, mtl
18:19:57 <solonarv> but you will pick them up as you go
18:20:10 <yushyin> base :P
18:20:17 <ChaiTRex> lukebfox[m]: Hackage's docs are pretty useful.
18:20:25 * hackage net-spider 0.4.1.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.1.0 (debugito)
18:21:12 <lukebfox[m]> yeah i saw hackage seems very informative when assessing a given library
18:21:31 <lukebfox[m]> but i cant guage best practices in general for haskell
18:21:38 <lukebfox[m]> maybe this is a characteristic of the language that people do things differently here
18:21:43 <fragamus_> so Set is no Functor     I was surprised to see that but I kind of understand
18:22:44 <fragamus> yeah
18:23:50 <fragamus_> I guess the functor laws no workie for Set
18:23:54 * hackage net-spider-rpl 0.4.1.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.1.0 (debugito)
18:24:29 <ChaiTRex> fragamus_: Yes, I think fmap f . fmap g isn't always fmap (f . g).
18:25:31 <solonarv> it is as long as 'f' doesn't produce different results on inputs that compare EQ
18:26:07 <solonarv> so as long as (x `compare` y == EQ) implies (f x `compare` f y == EQ), it works
18:26:37 <solonarv> the problem is that 'Data.Set.map :: forall a b. Ord b => (a -> b) -> Set a -> Set b'
18:27:02 <solonarv> that constraint on 'b' means Data.Set.map has the wrong type to be a valid 'fmap' implementation
18:28:42 <zebrag> > let {x :: [Char]; x = [undefined, 'a']} in case x of {[_, a] -> "hello"} -- I didn't know that was valid expression, that answer the question about wadler85's fail.
18:28:44 <lambdabot>  "hello"
18:29:44 <ChaiTRex> solonarv: Ahh, OK.
18:30:03 <ChaiTRex> :t fmap
18:30:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:31:07 <ChaiTRex> zebrag: _ does nothing special.
18:31:23 <ChaiTRex> > let { x :: [Char]; x = [undefined, 'a'] 
18:31:26 <lambdabot>  <hint>:1:41: error:
18:31:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:31:42 <ChaiTRex> > let { x :: [Char]; x = [undefined, 'a'] } in case x of { [a, b] -> "hello" }
18:31:45 <lambdabot>  "hello"
18:33:18 <zebrag> it was to avoid a ident, but indeed the 'a' hasn't been evaluated at all
18:33:25 <zebrag> an ident*
18:35:40 <zebrag> > let {x :: [Char]; x = [undefined, 'a']} in tail x -- even shorter
18:35:42 <lambdabot>  "a"
18:41:15 <ChaiTRex> > tail [undefined, 'a']
18:41:17 <lambdabot>  "a"
18:45:11 <zebrag> yes, but I wanted to specify the type, can't remember why.
18:45:53 <ChaiTRex> > tail ([undefined, 'a'] :: [Char])
18:45:55 <lambdabot>  "a"
18:48:26 <zebrag> > let nofail ((a,b) : cs) = ((a,b) : cs) in head $ nofail [(1,2), undefined]
18:48:28 <lambdabot>  (1,2)
18:49:37 <zebrag> > let nofail ((a,b) : cs) = ((a,b) : cs) in head $ nofail [undefined, (8,2)]
18:49:40 <lambdabot>  *Exception: Prelude.undefined
18:49:43 <ChaiTRex> It should only evaluate enough to find the (:) and (,) constructors.
18:49:48 <ChaiTRex> For example,
18:50:49 <ChaiTRex> > let nofail ((a, b) : cs) = ((a, b) : cs) in seq (nofail [(undefined, undefined), undefined]) 5
18:50:52 <lambdabot>  5
18:51:13 <ChaiTRex> > let nofail ((a, b) : cs) = ((a, b) : cs) in seq (nofail [undefined, undefined]) 5
18:51:16 <lambdabot>  *Exception: Prelude.undefined
18:51:24 <ChaiTRex> > let nofail ((a, b) : cs) = ((a, b) : cs) in seq (nofail []) 5
18:51:26 <lambdabot>  *Exception: <interactive>:3:5-40: Non-exhaustive patterns in function nofail
18:52:37 <ChaiTRex> It won't evaluate a or b because there's no need to, but there is a need to evaluate the input to get to the (:) and (,) constructors.
19:10:12 <sicklork1n> :t suchThat
19:10:14 <lambdabot> Gen a -> (a -> Bool) -> Gen a
19:12:57 <sicklork1n> Hoogle down for anyone else?
19:13:30 <ChaiTRex> sicklork1n: No.
19:15:30 <sicklork1n> thanks.. was returning 502 for a bit
19:58:32 <pounce> anybody here have experience with SMT solvers in hs
19:59:37 <iqubic> @hackage ersatz
19:59:38 <lambdabot> http://hackage.haskell.org/package/ersatz
19:59:47 <iqubic> glguy: ping
20:05:48 <pounce> hum, whats the point of liftIO
20:07:39 <pounce> unliftIO looks even weirder to me
20:34:03 <iqubic> :t unliftIO
20:34:05 <lambdabot> error:
20:34:05 <lambdabot>     • Variable not in scope: unliftIO
20:34:05 <lambdabot>     • Perhaps you meant ‘liftIO’ (imported from Control.Monad.Writer)
21:17:54 * hackage streamly-bytestring 0.1.0.0 - Library for streamly and bytestring interoperation.  https://hackage.haskell.org/package/streamly-bytestring-0.1.0.0 (psibi)
21:36:01 <quar> ?src (->)
21:36:02 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
21:36:07 <quar> ?src ($)
21:36:07 <lambdabot> f $ x = f x
21:43:18 <quar> ?src ($)
21:43:18 <lambdabot> f $ x = f x
21:57:35 <quar> ?src ($)
21:57:36 <lambdabot> f $ x = f x
21:57:49 <Mrbuck> in tensorflow I heard lazy evaluation, It is same as haskells lazyevaluation?
