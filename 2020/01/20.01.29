00:49:07 <haskeldjiq> hey guys
00:49:17 <haskeldjiq> could someone help me with a FromJSON instance?
00:49:18 <haskeldjiq> https://paste.ofcode.org/9Ld7HMXGVV3kXHF6hXzP6D
00:52:19 <dminuoso> haskeldjiq: Then write that FromJSON instance? :)
00:52:55 <haskeldjiq> well I've obviously failed badly
00:53:03 <dminuoso> haskeldjiq: How did you fail, exactly?
00:53:10 <haskeldjiq> one second
00:55:43 <haskeldjiq> yeah, I did it
00:55:50 <haskeldjiq> it's just that Data.Aeson has weird operators
00:55:56 <haskeldjiq> ended up with this piece of crap
00:55:57 <haskeldjiq> tag <- (.:) @Text value "tag"
00:56:19 <dminuoso> haskeldjiq: Things might be easier to read if you dont use TypeApplications
00:56:54 <haskeldjiq> it's pretty now
00:56:58 <haskeldjiq> thank you
00:57:09 <haskeldjiq> lol..
00:57:13 <haskeldjiq> I feel way too stupid now
00:58:46 <[exa]> haskeldjiq: you might really want a separate enum for "oneOf" and similar things, if that's at least partially static
00:59:28 <haskeldjiq> yeah I know the design is kind of shitty atm but I'm avoiding refactoring at this point
00:59:47 <dminuoso> haskeldjiq: Specifically you probably want to do something like `f x = flip withObject x $ \o -> do { t <- o .: "tag"; case t of "typedFieldDescription" -> p1 x; "oneOfManyDescription" -> p2 x; }
00:59:53 <[exa]> haskeldjiq: refactor first, suffer less
00:59:54 <Solonarv> was just 'tag <- value .: "tag" ' giving you an ambiguity error?
01:00:13 <dminuoso> haskeldjiq: If you need to address ambiguity, you can just write `x <- o .: "foo" :: Parser Text`
01:00:15 <haskeldjiq> Solonarv: no it's not anymore it's just because I had an undefined right below it
01:00:22 <dminuoso> (Just for future reference)
01:00:24 <Solonarv> ah, makes sense
01:00:56 <Solonarv> again for future reference, it's even nicer (IMO) to write 'tag :: Text <- o .: "tag" '
01:01:18 <Solonarv> you do need ScopedTypeVariables for that, but it's a harmless enough extension
01:01:19 <dminuoso> Except that requires ScopedTypeVariables to be enabled.
01:01:58 <dminuoso> Personally I prefer to avoid type ascriptions because they visually mix things.
01:02:47 <haskeldjiq> Solonarv: yeah that looks much nicer
01:05:26 <dminuoso> Mmm, I wish you could do something like
01:05:30 <dminuoso> f :: IO (); f = do { x <- pure "a"; x :: Text; pure () }
01:05:36 <dminuoso> Or perhaps even
01:05:43 <dminuoso> f :: IO (); f = do { x :: Text; x <- pure "a"; pure () }
01:06:01 <dminuoso> The first makes more sense probably
01:06:31 <dminuoso> I mean strictly speaking you can do that, but it still considers x a monadic action
01:06:49 <boxscape> looks like that would clash with something like `f :: IO (); f = do { putStrLn "foo" :: IO () }
01:06:54 <boxscape> ah, as you said
01:07:36 <dminuoso> Or maybe a way to escape into the type world would work
01:07:46 <dminuoso> Like `do { ...; @ x :: Text }`
01:08:01 <dminuoso> Then you could insert arbitrary type annotations, like you could do on any declaration level
01:08:54 <dminuoso> Perhaps part of the problem is that a do-expression is.. just an expression
01:09:26 <dminuoso> So the idea would generalize to having arbitrary type annotations within expressions
01:09:35 <boxscape> but then so are let expressions
01:09:54 <boxscape> (and they do support type annotations)
01:09:54 <dminuoso> boxscape: Well, you have a declaration group in the let construction
01:10:04 <dminuoso> But you raise a valid point
01:16:43 <Phyx-> < int-e> And I didn't know about :main either. <-- I typically just use `echo main | ghc --interactive L.hs`
01:19:40 <Solonarv> isn't that just a worse version of runghc L.hs ?
01:23:24 * hackage apecs 0.8.3 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.8.3 (jonascarpay)
01:26:46 <dminuoso> Oh yes. unsafePerformIO -> Im loving it.
01:45:47 <merijn> unsafePerformIO is best PerformIO ;)
01:46:26 <dminuoso> merijn: Should I make the merge request to rename unsafePerformIO to bestPerformIO or will you?
01:46:34 <merijn> ;)
01:46:56 <merijn> blessedUtterablePerformIO?
01:50:49 <dminuoso> Right now Im wondering how long it will take before I regret writing and using `unsafeRead :: IORef a -> a`...
01:50:58 <dminuoso> Every way I look at it however, this should be perfectly safe.
01:51:36 <dminuoso> In my usecase at least. At the stage where I use it, there are no more writes to my IORefs.
01:51:48 <merijn> dminuoso: That's just STRef?
01:52:59 <dminuoso> merijn: Mmm. You know what, I think you might be right.
01:53:24 <dminuoso> merijn: The ST monad would just be in the way though.
02:02:29 <idnar> @hoogle MonadFail m => Either String a -> m a
02:02:30 <lambdabot> UnliftIO.Exception fromEither :: (Exception e, MonadIO m) => Either e a -> m a
02:02:30 <lambdabot> Stack.Prelude fromEither :: (Exception e, MonadIO m) => Either e a -> m a
02:02:30 <lambdabot> Dhall.Core throws :: (Exception e, MonadIO io) => Either e a -> io a
02:04:23 <MarcelineVQ> % :t either fail pure
02:04:24 <yahb> MarcelineVQ: Monad m => Either String a -> m a
02:04:55 <Solonarv> oh, ew
02:05:05 <Solonarv> % :t either Control.Monad.Fail.fail pure
02:05:05 <yahb> Solonarv: Control.Monad.Fail.MonadFail m => Either String a -> m a
02:52:28 <dminuoso> merijn: Was it you who argued that `a <$ ..` is so much nicer than `... >> pure a` ?
02:53:19 <kuribas> I agree
02:53:25 <merijn> Probably not, but I do prefer it :p
02:54:28 <dminuoso> Ah well. Ive started to really enjoy it as well. :)
02:54:43 <merijn> It's especially nice for parsers
02:54:51 <dminuoso> Especially when the right hand side has some sort of termination semantics.
02:55:07 <dminuoso> `a <$ confError "blabla"` is becoming a pattern here :)
02:55:36 <dminuoso> Ah yeah, parsers seem like a good use case as well
02:55:44 <merijn> Foo <$ string "blah"
02:55:58 <dminuoso> asum [Foo <$ string "foobar", Quux <$ string "baz"]
02:56:01 <dminuoso> indeed
02:56:21 <dminuoso> ^- this by the way exponentially ruins GHC performance in megaparsec
02:56:51 <merijn> That's...bad
02:57:17 <dminuoso> merijn: The sweet spot is around 30 or so. At that point GHC takes over a minute for that single line of code alone.
02:57:30 <dminuoso> Because of its overuse of INLINE
02:57:37 <merijn> Sounds like megaparsec needs less INLINE
03:01:53 <Gurkenglas> Is there a monadic version of the iso optic? What I've found in libraries isn't composable
03:02:06 <Gurkenglas> (using . or even a combinator given by the library)
03:30:23 <Gurkenglas> oh I suppose I could do Iso (m s) (m t) (m a) (m b), then I would have first-class composition and some wrapping/unwrapping
03:37:12 * raichoo waves
03:37:45 <raichoo> Do you fokls have any recommendations to read up on recent cabal improvements?
03:37:53 <raichoo> "recent" that is ^^
03:38:49 <maerwald> raichoo: not particularly, but check out https://github.com/kowainik/awesome-cabal
03:39:49 <dminuoso> phadej: Would you be opposed to restructuring the exceptions in postgresql-simple into a hierarchy according to "An Extensible Dynamically-Typed Hierarchy of Exceptions"?
03:40:14 <raichoo> maerwald: Oh that looks pretty useful. Thanks a bunch!
03:41:31 <phadej> dminuoso: I don't know what you mean. Write an issue explaining the change you are proposing (I won't discuss it on IRC before something concrete). I'm very conservative with postgresql-simple.
04:35:36 <merijn> raichoo: You mean the v2-build stuff?
04:35:49 <merijn> raichoo: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html gives a pretty good overview
04:36:16 <merijn> raichoo: Also has the Package Description format changelog on the left bottom
04:37:34 <raichoo> merijn: Ah didn't know about the v2 prefix. I only knew about the "new" prefix. So that's essentially the same thing?
04:37:51 <Franciman> raichoo, for now, yes
04:37:57 <Franciman> but new isn't guaranteed to stay with the same functionality
04:37:59 <merijn> raichoo: v2- is the "official" non-beta prefix for new
04:38:08 <Franciman> v2- is sort of a snapshot of the current new- functionality
04:38:19 <raichoo> Ah interesting.
04:38:23 <merijn> raichoo: But in cabal-install 3.0 the prefix is redundant, everything defaults to v2/new
04:38:32 <Franciman> ah cool
04:38:48 <merijn> raichoo: v1/v2 prefixes is mostly for people needing to write scripts that are compatible across multiple cabal-install versions
04:39:51 <raichoo> merijn: That's good to know, I was wondering when that was going to happen. Apparently it already did :D
04:45:14 <jusss> ∀ - for all, what the up sidedown E means?
04:45:26 <jusss> and also ⊥
04:45:56 <merijn> jusss: You mean ∃ ?
04:45:58 <hpc> exists, and bottom
04:46:04 <merijn> jusss: That means exists
04:46:06 <jusss> merijn: yeah
04:46:19 <jusss> hpc: what 'bottom' here mean?
04:46:25 <jusss> at least?
04:46:25 <merijn> and yeah _|_ is bottom (and it's opposite, which looks like a T is top)
04:46:39 <merijn> jusss: bottom in haskell parlance is "non-terminating computation"
04:46:52 <hpc> bottom is the value that inhabits every type
04:46:54 <merijn> jusss: In general bottom's occur in lattice theory
04:47:03 <hpc> in haskell it's called undefined
04:47:17 <hpc> there's other meanings of bottom as well
04:48:12 <merijn> jusss: Generally bottom is the "least defined" element in a lattice (and in some sense non-terminating computation is the least defined computation...)
04:48:41 <jusss> ok
04:48:56 <MarcelineVQ> Where did you see these symbols?
04:49:20 <jusss> from some haskeller's tweets
04:52:56 <jusss> there're ghc-proposals about simplify subsumption by Simon PJ himself, and I have no idea what they're talking about lately
04:55:10 <merijn> jusss: That dives more into "knowing type theory and understanding how GHC's typechecker works"
05:00:53 <jusss> MarcelineVQ: there're some symbols on that https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst
05:01:40 <jusss> merijn: aha, that's too away for me
05:02:04 <merijn> jusss: If you wanna learn more I can *highly* recommend Benjamin Pierce's "Types and Programming Languages"
05:02:26 <merijn> jusss: That's the de facto standard (under)grad book on type theory and implementing type checkers
05:02:46 <jusss> merijn: that request a good math background?
05:02:51 <merijn> not really
05:03:00 <jusss> I don't have any math degree
05:03:06 <merijn> Neither do I :p
05:03:34 <merijn> jusss: It basically starts with the untyped lambda calculus and then adds incrementally more complicated type systems on it, with example implementation and everything
05:04:24 * hackage mmsyn7ukr 0.12.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.0 (OleksandrZhabenko)
05:04:30 <merijn> jusss: If you know enough Haskell to keep up to date with GHC development you probably know plenty for, like, the first half of the book (keep in mind that half of the book is probably sufficient to get you up to speed to Haskell98/2010 :p)
05:05:30 <merijn> jusss: The examples are in ocaml, but simple enough that even haskell beginners should be able to follow them without much difficulty
05:06:03 <jusss> merijn: is that ok to use some symbols like build :: ∀a. (∀__. (a->__->__) -> __ -> __) -> [a] ?
05:06:24 <jusss> build mk = mk @[a] (:) []
05:06:56 <merijn> Not sure I can parse that question
05:07:23 <jusss> it's valid to write that code in haskell?
05:07:34 <jusss> sorry, my English is not good
05:08:11 <merijn> "It depends"
05:08:27 <merijn> I think with unicode syntax extension enabled ∀ is a synonym for 'forall'
05:09:01 <merijn> So that example is just "forall a . (forall __ . (a -> __ -> __) -> __ -> __) -> [a]"
05:10:12 <jusss> merijn: it's from here https://twitter.com/Iceland_jack/status/1220326760589471744
05:10:25 <jusss> I have no idea what those are
05:10:38 <jusss> ~>
05:10:47 <jusss> ∃b
05:10:58 <jusss> ∀b
05:12:00 <merijn> jusss: Iceland_Jack is...advanced type level atrocity stuff ;)
05:12:51 <jusss> merijn: yeah, I don't understand his code at all
05:13:08 <merijn> That's natural xD
05:13:11 <boxscape> __ is just a regular variable name right? (on term and type level, unless NamedWildCards or whatever is enabled)
05:13:41 <Solonarv> yup
05:13:45 <boxscape> (and of course it doesn't produce unused warnings but apart from that)
05:13:45 <boxscape> ok
05:14:15 <Solonarv> and identifers starting with _ are only treated as a hole/wildcard if not already in scope
05:14:34 <Solonarv> (_ isn't a valid identifier by itself)
05:14:42 <boxscape> oh, I didn't know that
05:15:03 <boxscape> so even with NamedWildCards, __ in `forall __ . __` would be a variable then
05:16:38 <evelyn> hmm... someodd behaviour on this openbsd box
05:16:54 <evelyn> when installing some package (git-annex), cabal complains that happy could not be found.
05:17:03 <evelyn> but, cabal install happy is working just fine.
05:17:21 <evelyn> cabal: The program 'happy' version >=1.19 is required but it could not be found
05:17:51 <evelyn> nonetheless, cabal install happy fetches and installs it just fine.
05:17:51 <merijn> evelyn: Is ~/.cabal/bin in your path?
05:18:05 <evelyn> yep!
05:18:16 <merijn> evelyn: It installs there by default, so if it's not in your path it can't find it after installing
05:18:20 <tabaqui1> [exa]: about the problem with splice, I trying to solve yesterday
05:18:53 <evelyn> it's not actually installed before I ran cabal install happy, though. it definitely looks likke a dependencies thing.
05:18:56 <tabaqui1> it turned out, that splice does nothing here, and the problem was somewhere inside System.Posix.Process
05:19:24 <tabaqui1> I dunno, I moved this code out as a separate executable, and everything works well since then
05:20:05 <tabaqui1> getAddrInfo was a real trouble if I use it in forked process
05:20:39 <merijn> tabaqui1: Don't call anything except exec after forking
05:21:01 <tabaqui1> merijn: why not? I know how fork works in C on Linux
05:21:04 <merijn> tabaqui1: 99% of all functions are unsafe to call after fork
05:21:20 <merijn> tabaqui1: You can't do that in C either, it's horribly unsafe
05:21:58 <merijn> tabaqui1: If you're not absolutely, 100% sure assume you can't call something after fork() (there's a reason posix has deprecated fork() in favour of posix_spawn years ago)
05:22:04 <tabaqui1> well, I know that threads are inaccessible in forked process, and all data are threatened as CoW
05:22:43 <tabaqui1> I'll consider this, right now I have a lot of much more complicated code that works fine in forked threads
05:22:46 <merijn> tabaqui1: It's worse, since only the forking thread is copied you cannot use anything that uses locks in a multi-threaded setting (like, say, malloc)
05:22:47 <tabaqui1> *processes
05:23:07 <tabaqui1> yeah, I know it
05:23:26 <tabaqui1> posix_spawn, eh?
05:23:33 <merijn> tabaqui1: I don't think the Haskell RTS is very fork-safe, tbh
05:23:51 <merijn> tabaqui1: Is there a reason you can't use the process package, instead of fork?
05:24:14 <tabaqui1> not much, it was just the easiest solution on the moment
05:24:58 <tabaqui1> very likely, that I'll rewrite it after this mess
05:28:46 <evelyn> merijn: I think I worked it out. My ~/.cabal was a symlink, so it didn't think those files were managed by cabal and failed.
05:37:57 <Athas> Does anyone know of a good example for how to use ghcup on Travis?
05:38:13 <Athas> Looks like ghcup is installing GHC 8.6 by default for some reason.
05:38:22 <merijn> Athas: Why not use haskell-ci to config Travis?
05:38:37 <Athas> What is haskell-ci?
05:39:14 <merijn> Athas: Program for generating Travis-CI tests, including stuff like multiple GHCs, caching, etc.
05:39:17 <merijn> Athas: https://github.com/haskell-CI/haskell-ci/
05:39:31 <Athas> The real reason is that I'm not actually using Travis (I'm using Azure pipelines).
05:39:36 <merijn> Ah :)
05:40:10 <merijn> Yeah, non-travis support is still "PRs welcome" :p
05:40:59 <Athas> I don't really care about more than one version of GHC, so I'd rather avoid that complexity.
05:42:40 <c_wraith> Athas: ghcup still considers 8.6.5 to be the "default" ghc.  not sure why.
05:43:23 <c_wraith> 8.10 is in alpha now!
05:43:37 <sm[m]> rc1
05:43:49 <c_wraith> ok, 8.10 is in rcs now!
05:44:13 <evelyn> It says that it's the most stable version. And given 8.10 is in alpha, one would reasonabrly think it's not as stable yet
05:44:20 <opqdonut> c_wraith: surely it's git and not rcs ;)
05:44:44 <c_wraith> I think they wanted to make rcs cool again
05:45:36 <Athas> I'm once again investigating what it would take to use cabal (and I guess ghcup) instead of stack.  Guess I have come to enjoy the pain.
05:46:26 <sm[m]> let us know how you get on 
05:46:35 <MarcelineVQ> Athas: ghcup was so far a painless switch for me
05:47:17 <MarcelineVQ> only real change being that I have to type  ghcid -c "cabal repl"  now instead of  stack exec ghcid
05:47:43 <Athas> MarcelineVQ: it looks like I will have to mention my desired GHC version in both azure-pipelines.yml and in the tested-with field of the .cabal file (or cabal.project, I forget).
05:47:49 <MarcelineVQ> because for some reason ghcid without that -c acts weird despite claiming that its default is ghcid -c "cabal repl"
05:47:53 <Athas> I'm not a big fan of the duplication.
05:51:44 <mpickering> Should I have to appeal to `Sym` in order to use a constraint of type `a ~ b` to transform b into a?
05:51:52 <mpickering> Are constraints directed in this way?
05:58:04 <Athas> Does this mean ghcup also comes with an ancient cabal-install, I wonder...
06:02:46 <MarcelineVQ> you have to tell it to install cabal-install iirc, it has 3.0.0.0 which is the only recent cabal release and is marked as reccomended by the tool
06:03:33 <MarcelineVQ> in the same way that 8,6,5 is marked as reccomended but you can get 8.8.1 or 8.8.2
06:03:40 <haskeldjiq> guys, is anyone familiar with yesod?
06:03:55 <haskeldjiq> I'm looking for a way to get *all* submitted inputs from a form
06:04:00 <MarcelineVQ> Athas: you can ask what it has via ghcup list -t all
06:07:31 <MonoBobo> working with Task in C# really makes me miss higher kinded types
06:08:20 <Athas> MarcelineVQ: do you understand the logic about when a ~/.ghcup/env file is created?
06:08:29 <Athas> The documentation is very unclear.
06:18:06 <tabaqui1> merijn: btw, I didn't find any mentions of deprecated posix fork, but just vfork
06:18:31 <tabaqui1> I hope, that they aren't planning to replace the old friend
06:19:14 <merijn> tabaqui1: deprecated posix APIs never go away. They stay around forever, tricking unsuspecting beginners into writing wildly unsafe code :p
06:19:36 <merijn> tabaqui1: See, signal(2) for example :p
06:20:02 <merijn> That has been deprecated by sigaction(2) for decades
06:21:13 <tabaqui1> merijn: which distro do you use?
06:21:31 <merijn> tabaqui1: I don't use linux :p
06:21:47 <tabaqui1> macos?
06:21:55 <yushyin> windows
06:22:01 <merijn> macOS and FreeBSD
06:23:29 <tabaqui1> huh, fork is not deprecated in Linux systems :)
06:24:50 <Athas> I'm finding 'cabal v2-install' rather fragile, and I suspect the reason is that it makes a separate sdist and then works from that.
06:25:09 <Athas> Is there a way to essentially simulate what v2-install does with v2-build?  I guess I can just build the binaries and then fish them out myself...
06:25:11 <merijn> tabaqui1: It's not marked as deprecated in the manpages, but the macOS manpage for example explicitly calls out: " All APIs, including global data symbols, in any framework or library should be assumed to be unsafe after a fork() unless explicitly documented to be safe or async-signal safe."
06:25:19 <Athas> (This is solely for executables, not libraries.)
06:25:38 <merijn> tabaqui1: And the posix spec recommends using posix_spawn
06:25:59 <tabaqui1> I'm okay with that
06:26:12 <merijn> Athas: The reason it makes a separate sdist is to check your sdist specification actually works
06:26:28 <merijn> Athas: At least, that's what I would assume :p
06:26:34 <tabaqui1> I'm to young to bury fork now
06:28:28 <Athas> merijn: yes, probably, but I don't really care about sdists.
06:28:50 <Athas> The problem with making my own dollar store v2-install is that I don't know which executables exist.
06:29:02 <merijn> Athas: cabal-plan?
06:29:05 <merijn> @hackage cabal-plan
06:29:06 <lambdabot> http://hackage.haskell.org/package/cabal-plan
06:29:08 <tabaqui1> from `man strace`: "-e trace=file ... Betchya woulda forgot that one."
06:29:19 <merijn> Athas: But then you have an extra tool dependency...
06:29:35 <merijn> Athas: Wouldn't it be easier/less work to fix the sdist?
06:30:06 <Athas> merijn: I'm not the upstream of everything.
06:30:24 <Athas> I also suspect some of the problems I see are actual bugs in v2-install, because it generates tarballs with '..' paths.
06:30:33 <merijn> Could be?
06:36:59 <MarcelineVQ> Athas: no but I think maerwald is a good person to ask about ghcup
06:41:41 <siers> is type class a function at the type level?
06:43:02 <merijn> siers: Not quite
06:43:54 <hyperisco> siers, type families are
06:44:49 <siers> ah, right... it's been a long time since I thought about it
06:45:24 * hackage bifunctors 5.5.7 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.5.7 (ryanglscott)
06:45:33 <hyperisco> type classes are predicates
06:50:11 <c_wraith> a multiparameter typeclass with a functional dependency can work as a function, in a very prolog sort of way
06:50:16 <maerwald> Athas: I also wish cabal v2-install would more behave like stacks
06:50:32 <maerwald> that behavior caused non-trivial problems for docker-based CI
06:50:41 <hyperisco> indeed that is what we get by with in PureScript, c_wraith 
06:50:58 <maerwald> e.g. when you end up building the application twice, because v2-install doesn't reuse v2-build/v2-test
06:52:44 <maerwald> I think it might actually not be that hard to fix. cabal has knowledge about what is a "local" package and for local ones it could probably do a different codepath
06:52:56 <boxscape> do type families merely make type level functions more convenient then or do they actually offer more possibilities over prolog-style MPCs with FunDeps?
06:53:19 <maerwald> Athas: ~/.ghcup/env is only created by the bootstrap-haskell script
06:53:25 <boxscape> (modulo having to rearrange your code around a completely different way of writing typelevel functions)
06:53:29 <maerwald> which is what you get when you run the curl | sh command
06:53:30 <merijn> maerwald: I think the v2-install workflow is still up for bikeshedding
06:53:40 <merijn> maerwald: Same for how global installs should behave
06:54:09 <Lears> % :k Eq
06:54:09 <yahb> Lears: Eq :: * -> Constraint
06:54:15 <hyperisco> boxscape, the trouble with just type classes is that you do not have application, so you never get rid of parameters
06:54:19 <Lears> Looks like a function to me. <.<
06:54:31 <boxscape> ah, I see
06:55:21 <maerwald> Athas: https://gitlab.haskell.org/haskell/ghcup/blob/master/bootstrap-haskell#L61
06:55:22 <Athas> maerwald: ah, alright.  I think I got things working now.
06:55:40 <maerwald> the "curl | sh" thing can be re-run multiple times
06:59:24 * hackage keys 3.12.3 - Keyed functors and containers  https://hackage.haskell.org/package/keys-3.12.3 (ryanglscott)
07:00:28 <hyperisco> boxscape, it also has problems with type synonyms. If you want to name a computed type, that is easy to do with type families. With just type classes, on the other hand, you're mostly out of luck
07:00:43 <boxscape> hm, okay
07:04:44 <boxscape> hm, it's actually hard for me to think of an example of where one might use type families to describe the type of some terms without also needing to use type classes (albeit not for prolog-style programming)
07:06:02 <hyperisco> They can work together. That is okay.
07:06:34 <boxscape> right I'm mostly just wondering if it's possible to use them *not* together
07:06:43 <boxscape> well, it's obvious you can use classes without type families
07:06:49 <boxscape> but not sure about the other direction
07:07:04 <merijn> boxscape: You can, but you probably want GADTs for it to be useful
07:07:09 <boxscape> ah, that makes sense
07:07:44 <merijn> boxscape: Consider the apply example from my HList gist: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:07:55 <merijn> boxscape: It can't be written without type families
07:08:08 <boxscape> okay, interesting
07:11:22 <Athas> maerwald: what do you mean "behave more like stacks"?
07:11:40 <Athas> Do you mean just copying the files like any other installer?
07:11:45 <maerwald> stack does what you said... stack install doesn't do sdist
07:12:09 <maerwald> I ended up using v2-build and then v2-exec to manually copy the binaries
07:12:28 <Athas> Yeah, that sucks...
07:13:24 * hackage intervals 0.9.1 - Interval Arithmetic  https://hackage.haskell.org/package/intervals-0.9.1 (ryanglscott)
07:14:36 <dminuoso> Which author/library was infamous for using one module per canonical type, and naming all their types T?
07:15:14 <lortabac> Henning Thielemann?
07:15:25 <ggole> Must have been a former SML programmer...
07:15:43 <Athas> And all the classes are C!
07:16:13 <lortabac> https://hackage.haskell.org/package/sox-0.2.3.1/docs/Sound-Sox-Format.html
07:16:41 <dminuoso> Oh yeah, that's it! Must have been Thielemann.
07:16:51 <Athas> At least those are all the same T.
07:17:11 <dminuoso> class C y => C y where format :: y -> T 
07:17:14 <lortabac> they may be or not, Hackage is not very helpful in this case
07:17:26 <dminuoso> Wait what. You can name a class as its own superclass?
07:17:31 <dminuoso> OH GOSH NO.
07:17:36 <Athas> dminuoso: you are in the Thielemann Zone.
07:17:49 <boxscape> you do need UndecidableInstances though
07:17:59 <Athas> boxscape: not in this case.
07:18:00 <boxscape> uh
07:18:13 <boxscape> UndecidableSuperClasses I mean
07:18:24 <Athas> When you enter the Thielemann Zone, things are not necessarily as they appear...
07:18:32 <lortabac> I guess the two classes are from different modules
07:19:04 <boxscape> ah, yes
07:19:11 <merijn> dminuoso: Those are different Cs >.>
07:19:34 <dminuoso> merijn: Yeah I noticed... :D
07:20:43 <boxscape> I suppose code written in this style could be almost readable, it's mostly hackage that makes it confusing
07:20:54 * hackage structs 0.1.3 - Strict GC'd imperative object-oriented programming with cheap pointers.  https://hackage.haskell.org/package/structs-0.1.3 (ryanglscott)
07:21:33 <boxscape> though I can't really see a reason in favor of it
07:21:40 <dminuoso> boxscape: Well unfortunately things become confusing when you have a module with more than one type.
07:21:45 <dminuoso> Even in the Thieleman zone that happens.
07:21:52 <dminuoso> Then you have Foo.T and Foo.Bar
07:21:55 <merijn> dminuoso: Just add more modules!
07:21:59 <boxscape> oh I thought the idea was to have one module per type
07:22:11 <dminuoso> boxscape: No, one module per "most common/canonical type"
07:22:15 <boxscape> I see
07:22:24 * hackage ersatz 0.4.8 - A monad for expressing SAT or QSAT problems using observable sharing.  https://hackage.haskell.org/package/ersatz-0.4.8 (ryanglscott)
07:23:24 * hackage compensated 0.8.1 - Compensated floating-point arithmetic  https://hackage.haskell.org/package/compensated-0.8.1 (ryanglscott)
07:27:06 <dminuoso> :t \f g -> join <$> mapM f g
07:27:08 <lambdabot> (Traversable m, Monad m, Monad f) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
07:27:24 <dminuoso> Is there a more elegant/expressive way to describe this?
07:29:24 <Taneb> :t (=<<) . mapM
07:29:26 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
07:30:00 <dminuoso> Taneb: Thanks! It's quite obvious now that you point it out.
07:30:32 <Taneb> dminuoso: no, that's not the same
07:30:40 <dminuoso> Oh right. Mmm
07:35:54 * hackage mwc-probability 2.2.0 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-2.2.0 (JaredTobin)
07:35:58 <merijn> bah
07:36:00 <Taneb> (I had fmap join mixed up with join . fmap f)
07:36:14 <merijn> Cabal, why are you not passing the right include flags for me >.<
07:37:08 <dmj`> merijn: did you say please?
07:37:29 <dminuoso> Taneb: Heh, I made the same mistake which is why it looked so right. :P
07:38:24 * hackage llvm-ffi 9.1.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-9.1.0 (HenningThielemann)
07:43:52 <merijn> hmmm
07:44:07 <merijn> Why is it randomly pointing to the include paths for *some* packages, but not all
07:45:21 <maerwald> Is there a way to tell brittany to have imports on a single line? It's linebreaks make it impossible to sort the imports alphabetically in vim
07:45:47 <maerwald> (and it doesn't sort on its own either)
07:46:49 <boxscape> So I tried to implement mereijn's HList example with classes anyway despite him saying that you can't, but I'm not actually sure why it doesn't work. Does it have something to do with instance resolution happening before it gets the type from the GADT constructor, or something like that? Seems like the context l ~ '[], which it has, should in
07:46:50 <boxscape> principle be good enough https://pastebin.com/H7WkvEb1
07:46:58 <boxscape> s/mereijn/merijn
07:47:24 * hackage flat-mcmc 1.5.1 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.5.1 (JaredTobin)
07:48:24 * hackage llvm-tf 9.1 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-9.1 (HenningThielemann)
07:55:07 <boxscape> Hm actually I think my guess must be wrong because adding the constraint l ~ '[] still produces the same error
07:56:55 <boxscape> Ah I think I get it
07:57:15 <boxscape> '[] matches both instances
07:57:26 <boxscape> whereas with a closed type family it selects the first one
07:57:56 <boxscape> or wait no
07:57:58 <boxscape> it doesn't
07:58:12 <boxscape> I was looking at the constraint of the second instance, the actual instance head doesn't match '[]
07:59:07 <boxscape> (not to mention it also compiles with an open type family instead of the closed one)
08:04:20 <boxscape> different question: why can I do this? shouldn't this be a functional dependency conflict?
08:04:21 <boxscape> % class C r t | r -> t; instance C r r; instance C r Int
08:04:22 <yahb> boxscape: 
08:13:48 * dminuoso wish local typeclass instances were a thing.
08:14:10 <merijn> dminuoso: You mean "records of functions"? ;)
08:14:32 <Taneb> dminuoso: you run into coherence issues (imagine defining a local Ord instance and returning a Map)
08:15:02 <dminuoso> merijn: No, I actually mean what I said. Im in the trouble of having IORef added to my data types, and I really wish I could derive a Show instance in which I pretend there was some `instance Show (IORef a)`
08:15:34 <dminuoso> Now I could of course turn it into HKTs, and then start with type families.. but that's overkill for being lazy.
08:16:14 <lortabac> dminuoso: you can have local instances with 'reflection'
08:16:34 <lortabac> but it's probably a little overkill
08:16:35 <Taneb> lortabac: that doesn't help here
08:19:11 <dminuoso> But who knows. perhaps writing an `instance Show (IORef a)` is the saner solution. This is not library code after all.
08:21:15 <lortabac> sometimes I wish there was a magical "debug" functions that shows everything
08:22:15 <merijn> That's called gdb :p
08:23:03 <boxscape> dminuoso: this seems like it could maybe do what you want once accepted/implemented https://github.com/treeowl/ghc-proposals/blob/local-types/proposals/0000-local-types.md
08:23:41 <Taneb> boxscape: that doesn't make deriving instances any different
08:23:58 <boxscape> ah, true
08:53:04 <maerwald> readDirStream blocks on a closed dir stream?
08:56:33 <maerwald> I think neither the syscall, nor the libc function are supposed to block
09:03:07 <remexre> is there a way to get 'class Foo a where foo :: Int' to work? Would I need to make 'foo :: Proxy _ -> Int' or something, perhaps?
09:03:22 <dminuoso> remexre: Yes and no.
09:03:54 <Taneb> remexre: I think the AllowAmbiguousTypes and TypeApplications might make this workable
09:03:58 <dminuoso> remexre: You can either use the Proxy patter, or enable AllowAmbiguousTypes and TypeApplications
09:03:58 <dminuoso> % :set -XAllowAmbiguousTypes
09:03:58 <dminuoso> % :set -XTypeApplicatoins
09:04:00 <yahb> dminuoso: 
09:04:03 <yahb> dminuoso: Some flags have not been recognized: -XTypeApplicatoins
09:04:41 <dminuoso> % class Foo a where foo :: Int
09:04:41 <dminuoso> % instance Foo Bool where foo = 5
09:04:41 <dminuoso> % foo @Bool
09:04:41 <yahb> dminuoso: 
09:04:41 <yahb> dminuoso: 
09:04:41 <yahb> dminuoso: 5
09:05:01 <remexre> ok
09:05:15 <dminuoso> remexre: Overall Id probably prefer the Proxy pattern. :)
09:06:20 <remexre> yeah, I'll probably do that
09:07:24 * hackage fcf-containers 0.1.0 - Data structures and algorithms for first-class-families  https://hackage.haskell.org/package/fcf-containers-0.1.0 (gspia)
09:08:21 <solonarv> remexre: to be clear: you need AllowAmbiguousTypes to *define* that class like you originally wrote. Then, at use sites, TypeApplications are the only way to resolve the ambiguity.
09:09:24 * hackage persistent-template 2.8.2.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.2.1 (parsonsmatt)
09:11:54 * hackage row-types 0.3.1.0 - Open Records and Variants  https://hackage.haskell.org/package/row-types-0.3.1.0 (dwincort)
09:12:54 <shafox_> Where can I read more about ~/.cabal/config cofiguration ? 
09:13:04 <solonarv> 'row-types'? now that's a promising package name!
09:13:48 <shafox_> got it. 
09:17:24 * hackage mmsyn7ukr 0.12.0.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.1 (OleksandrZhabenko)
09:25:14 <reactormonk> Is there a `MonadState s m => ASetter s s a b -> (a -> b) -> m b` somewhere? similar to modifying, but returning the newly set value?
09:27:12 <reactormonk> Is there a class which lets me substract one value of a product type from another? A Generic `-`, so to say.
09:31:29 <solonarv> reactormonk: to your first question: <%=
09:31:33 <solonarv> :t (<%=)
09:31:35 <lambdabot> MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
09:32:56 * hackage llvm-extra 0.9.1 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.9.1 (HenningThielemann)
09:33:55 <solonarv> regarding your second question, I'm not aware of any Generic-based function of that sort, though it is of course entirely possible
09:35:51 <solonarv> but depending on your specific data type, something slightly less general might work
09:36:00 <solonarv> what's it look like?
09:38:03 <nevere> If I have an `Eq a` and `Eq b` constraints in scope, is there any way to bring constraints `Eq (a,b)` into scope, assuming the instance `(Eq a, Eq b) => Eq (a,b)` is not defined anywhere else.
09:38:28 <geekosaur> it's not automatic, but I think one already exists in Prelude
09:38:50 <geekosaur> you would otherwise have to define the instance yourself.
09:40:14 <solonarv> nevere: the instance '(Eq a, Eq b) => Eq (a, b)' *is* defined somewhere else, though
09:41:50 <nevere> solonarv: I am aware. But that was just an example, and what I am trying to do is similar, but for a different user defined type class.
09:42:29 <merijn> nevere: How would you possibly do that automatically without defining a class?
09:42:40 <solonarv> merijn: s/class/instance/ ?
09:42:43 <reactormonk> solonarv, data Budget CPU Mem - where as CPU and Mem are both newtypes over Integer
09:43:09 <solonarv> reactormonk: I assume you mean: data Budget = Budget CPU Mem ?
09:43:20 <geekosaur> perhaps just derive Eq on the newtypes, then on Budget?
09:43:21 <reactormonk> yup
09:43:55 <merijn> solonarv: Yeah, thinking is hard
09:43:55 <geekosaur> (GenericNewtypeDeriving to get Eq on CPU and Mem)
09:43:59 <solonarv> geekosaur: you are mixing up two askers ;)
09:44:17 <geekosaur> hm, whoops
09:44:32 <geekosaur> nevere, what are you actually trying to do?
09:44:47 <solonarv> reactormonk: hm, I don't think there is anything particularly convenient
09:45:11 <solonarv> probably just write it out explicitly
09:45:16 <nevere> merijn: Somehow pack the required instance function implementation (using the constraints in scope) in the instance dictionary for the type dynamically...
09:46:00 <reactormonk> solonarv, :-(
09:47:09 <reactormonk> solonarv, ... in PureScript it's on Ring, and I could do it via DerivingVia + semirings in Haskell
09:47:35 <solonarv> (-) is on Ring? huh, don't they have an AdditiveGroup or something in between?
09:47:47 <geekosaur> you could hypothetically define a Num instance in Haskell, but I don't recommend it
09:47:52 * solonarv is not all that familiar with purescript's numeric hierarchy
09:48:00 <solonarv> yeah, I didn't even bother to suggest that
09:48:04 <reactormonk> solonarv, https://pursuit.purescript.org/packages/purescript-prelude/4.1.1/docs/Data.Ring#t:Ring
09:48:15 <solonarv> Num is kind of a clusterfuck, tbh
09:48:27 <nevere> geekosaur: I have a type class to convert between stuff. So I have `Convert a b` that have a method of type `a -> b`. I have `Convert a b` and `Convert b c` in scope. And I need an instance of `Convert a c`.
09:48:40 <reactormonk> geekosaur, nah, I considered that as well, but because Num also has a funny fromInteger method, I'd rather not
09:48:40 <geekosaur> yeh, that
09:48:41 <reactormonk> solonarv, yeah, but have fun unfucking it :-(
09:48:44 <geekosaur> s why I don't recommend it; fromInteger is waiting to bite you in the butt
09:49:02 <solonarv> nevere: can't (reasonably) be done
09:49:38 <solonarv> suppose that all four of Convert A B1, Convert A B2, Convert B1 C, Convert B2 C are in scope
09:49:43 <solonarv> and you want to solve Convert A C
09:49:44 <reactormonk> Can GHC proposals also be written for the prelude?
09:49:54 <geekosaur> I think that's more the libraries committee?
09:50:00 <solonarv> which path should be chosen - the one through B1 or B2 ?
09:50:01 <geekosaur> (Prelude, that is)
09:50:18 <merijn> ah...
09:50:23 <merijn> Convert classes never go well
09:50:43 <solonarv> definitely not if you expect to auto-compose instances to generate new ones
09:51:02 <merijn> reactormonk: You could try, but there's a reason Num remains unchanged, a lot of alternatives break a lot of things and aren't obviously better
09:51:48 <geekosaur> you could play with numeric-prelude a bit, maybe, to see what you're up against?
09:52:02 <merijn> nevere: I would recommend against going down this road, generic convert classes (even more so with automagic derivations) invariably turn into a messy clusterfuck
09:52:06 <wildtrees> sometimes I wish the additive and subtractive (+), (-) from num was separate from (*), for things like custom classes for vectors
09:52:19 <solonarv> yeah, that would be great
09:52:40 <solonarv> ideally we would have Additive, Semiring, AdditiveGroup, Ring forming a diamond
09:52:55 <reactormonk> Aye, I'll write something up in a week or two.
09:53:29 <solonarv> fromInteger can be in Ring because there is a ring homomorphism Z -> R for any ring R
09:53:32 <wildtrees> I think edwardk wants easy to modify/break typeclasses hierachies with some sort of automatic deriving in his coda language 
09:54:38 <solonarv> abs/signum currently have the wrong type, really - it's too imprecise
09:54:49 <solonarv> but I'm not sure what a better one is
09:54:52 <wildtrees> @type abs 
09:54:53 <lambdabot> Num a => a -> a
09:55:41 <wildtrees> whats the absolute value of a Nat then? 
09:56:03 <ChaiTRex> wildtrees: id
09:56:54 * hackage synthesizer-llvm 0.8.3 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.3 (HenningThielemann)
09:57:02 <wildtrees> :)
09:57:21 <maerwald> this is confusing... readdir works on a closed directory stream?
10:00:24 <geekosaur> huh?
10:01:24 <geekosaur> (I mean, hypothetically something could close the underlying descriptor and continue to give you entries from the buffer, if so written, but that seems unlikely. Unless via clever streaming)
10:02:52 <maerwald> https://git.io/JvOvN line 19 should fail with EBADF imo
10:04:47 <geekosaur> sounds unfortunate, but follows from what I said; it doesn't hit the underlying file descriptor (which it sort-of is) until it hits the end of the current buffer, so it could still produce entries
10:05:10 <geekosaur> as with files, it reads in increments of blocks, not of records (the records here being variable length)
10:05:50 <maerwald> " successful call to closedir() also closes the underlying file descriptor associated with dirp."
10:06:01 <geekosaur> right, but it doesn't clear the buffer\
10:06:18 <geekosaur> there's no reason for it to consult the file descriptor until it hits the end of the current buffer
10:06:19 <maerwald> ok, but it's clear now that readdir never blocks
10:06:25 <maerwald> or does it?
10:07:06 <geekosaur> it will if it hits the end of the current block buffer and needs to read another block from disk
10:07:08 <geekosaur> (note that behavior over NFS will differ)
10:07:40 <maerwald> so reading from a closed directory stream will not throw EBADF, but block forever
10:09:24 <geekosaur> eventually it will try to read from the closed descriptor and return EBADF
10:09:36 <geekosaur> but as long as there's unconsumed data in the buffer, it'll return it
10:09:50 <maerwald> https://github.com/haskell/unix/blob/63a560bf26a052d381cc0662baf2a25e0f3ddc5d/System/Posix/Directory.hsc#L91 this blocks
10:10:29 <astk12> im on #nix trying to work through an error building a project with backpack
10:10:47 <astk12> and apparently it is either not a problem with nix, or at least has such haskell specific error messages as to be worth asking here
10:11:01 <geekosaur> hm, that's a buggy dirent implementation, then, unless it's an NFS directory
10:11:14 <astk12> cloning; https://github.com/fog-hs/rotateDistributed/
10:11:28 <maerwald> the c version segfaults when the buffer is consumed
10:11:41 <geekosaur> but then that's implied by it not marking the DIR as closed in closedir.
10:11:49 <astk12> and adding; https://github.com/astk-hs/hello-nix/blob/master/default.nix
10:12:00 <astk12> to the dir containing the cabal.project file
10:12:13 <astk12> and writing nix-build -A rotateUse
10:12:26 <astk12> gives this error; https://pastebin.com/raw/cNvC114q
10:12:58 <astk12> where it seems to depend on two versions of the rotate package, but with different suffixes
10:13:06 <astk12> which the nix channel has never seen before 
10:13:15 <astk12> and blames haskell for
10:13:18 <astk12> any ideas?
10:13:45 <maerwald> geekosaur: where is the bug :>
10:13:57 <geekosaur> in C
10:13:59 <maerwald> must be somewhere here https://github.com/haskell/unix/blob/63a560bf26a052d381cc0662baf2a25e0f3ddc5d/cbits/HsUnix.c#L60
10:14:17 <maerwald> but for modern glibcs, it just wraps readdir
10:14:17 <geekosaur> haskell is expecting closedir to do something sane but it's not
10:14:23 <maerwald> oh
10:15:01 <maerwald> blocking is so much more worse than crashing...
10:15:24 <geekosaur> so this should probably be reported as a glibc bug where continuing to use a closedir-d DIR misbehaves insted of returning an error
10:15:55 <geekosaur> be interesting to see what freebsd / os x does with the same code
10:17:08 <koz_> If I am dreaming of Haskell code, am I OK?
10:17:26 <geekosaur> you're using haskell a lot. is that a bad thing?
10:17:31 <solonarv> better than okay!
10:18:26 <koz_> (I'm not joking this actually just happened)
10:18:34 <sm[m]> koz_ a happy dream ? Maybe giving insights for your projects ? Or a nightmarish loop of debugging failure dream ? :)
10:18:53 <koz_> geekosaur: I have that elusive unicorn that is a Haskell Job.
10:19:06 * geekosaur keeps looking at one…
10:19:18 <koz_> sm[m]: I don't recall the precise details except for there being a lot of pattern matching.
10:19:56 <mniip> the nightmare of having a *bug* in your *haskell* program
10:20:44 <koz_> mniip: Welcome to 'most of yesterday'.
10:20:47 <koz_> (for me at least)
10:21:24 <mniip> sounds like you need more singletons
10:22:09 <koz_> mniip: I'm not sure singletons would help me here.
10:22:21 <koz_> But that's OK - I have a whole productive day to hammer out said bugs.
10:22:46 <koz_> You'll know when you see me release another library.
10:22:55 <koz_> (I requested that this be open-sourced)
10:23:43 <mniip> I've hammered out a few open source libraries at work...
10:23:48 <mniip> we're yet to use one of them lol
10:25:54 * hackage mmsyn7ukr 0.12.0.2 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.2 (OleksandrZhabenko)
10:28:39 <astk36> clever: im not sure the #haskell can help here...
10:29:29 <astk36> could it be something to do with needing to tell nix which dependency to use/
10:29:35 <astk36> ?
10:30:40 <astk36> oh, wrong channel sorry...
10:30:47 <astk36> whats the code koz? i cant find it in the scrollup
10:57:23 <remexre> what's the syntax to / is it possible to specify constraints for an associated type?
10:57:40 <remexre> in the class declaration, that is
10:57:48 <remexre> or would I need to do them at the use site?
10:58:17 <geekosaur> specify them as part of the class's constraints
10:58:51 <remexre> oh huh neat, didn't realize they'd be "in scope" there
11:00:54 * hackage persistent-sqlite 2.10.6.1 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.10.6.1 (parsonsmatt)
11:34:54 * hackage base64 0.4.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.4.0 (topos)
11:38:56 <remexre> are there tools for generating diagrams of Haskell programs? (diagrams in the sense of UML diagrams)
11:39:07 <remexre> ideally in some editable+annotatable form
11:47:17 <yushyin> https://ro-che.info/ccc/29 :D
11:52:39 <pounce> what's the point of "wrappedMonad" and "WrappedArrow"
11:53:53 <solonarv> pounce: ugly annoying compatibility plumbing
11:53:58 <solonarv> and avoiding orphan instances
11:55:04 <fendor> lol https://ro-che.info/ccc/21
11:56:03 <yushyin> fendor: that's my favorite one
11:56:10 <fendor> when were these comics published? they are almost scaringly accurate, except that it is IPhone X 
11:56:36 <yushyin> 'Published on August 4, 2013'
11:56:54 <fendor> damn, nice prediction
11:57:08 <fendor> and I love the id button
11:58:47 <fendor> shame on you yushyin I was supposed to be studying, not reading comics :P
12:02:54 <maerwald> Since when can't I depend on my own library in a test in cabal?
12:03:47 <maerwald> It can't solve the dependencies... 
12:06:48 <AwoL[m]> I'm reading through the "...for Great Good" Haskell book.  I have a question about a piece of code in Chapter 4: https://bin.privacytools.io/?b39a2b6f89f930e7#CFvNlvxG7E2xgfAJWQxcy06xeWZgCBzGOB7tqAzmzkc=
12:06:59 <AwoL[m]> Is the "weight / height ^ 2" calculation after each guard calculated each time?  Or is the result cached somehow?
12:08:26 <solonarv> hm, by default it gets recalculated
12:09:09 <solonarv> there *is* a compiler optimization that will store it instead, but it doesn't fire very reliably
12:09:26 <fendor> really? shouldnt this be a trivial case of common subexpression elimination?
12:10:23 <solonarv> it is indeed
12:10:36 <solonarv> but GHC does not perform CSE very eagerly, because it does a lot of inlining
12:10:42 <AwoL[m]> And...a couple of examples later, "where" is used to eliminate that problem.
12:10:51 <solonarv> and those two operations are opposites of each other
12:11:12 <solonarv> obviously a compiler that eagerly does CSE *and* inlining will just end up spinning in circles
12:11:25 <AwoL[m]> I believe I saw that with some large calculations (using ghci) that results were cached it seemed.  I wasn't sure about here also.  Thanks!
12:11:26 <solonarv> (or it would take a lot of complexity to avoid that)
12:11:57 <solonarv> the thing to be concerned about is that you have the same code copy-pasted three times and that's not super readable
12:12:21 <fendor> ok, makes sense
12:15:10 <AwoL[m]> Also kind of bad practice for the productively lazy.
12:15:48 <solonarv> cursory investigation shows that with -O1 (the default), no CSE happens
12:16:07 <solonarv> with -O2 the function gets inlined into 'main' and CSE does happen eventually
12:19:22 <AwoL[m]> Neat.
12:19:24 <AwoL[m]> Maybe a bit moot in this example tho.
12:47:05 <tomjaguarpaw> What's the way of using xmonad with cabal v2 style?
12:47:16 <tomjaguarpaw> xmonad seems to want to recompile itself with bare ghc
12:49:18 <solonarv> tomjaguarpaw: I haven't done it myself, but I think you should be able to 'cabal v2-install --lib --package-env env-for-xmonad' all the libraries, and then compile xmonad with 'ghc -package-env env-for-xmonad'
12:49:40 <solonarv> presumably there is some way to tell XMonad to pass some extra GHC arguments
12:50:47 <tomjaguarpaw> This seems to explain it https://github.com/xmonad/xmonad-testing#xmonad-and-custom-build-scripts
12:52:07 <maerwald> is conditionally exposed modules a thing?
12:52:40 <solonarv> tomjaguarpaw: oh, even better!
12:58:42 <tomjaguarpaw> xmonad does not seem to actually restart.  Is anyone familiar with this?
13:01:42 <shapr> tomjaguarpaw: I can't get xmonad edit&restart to work on ubuntu, but it does work in nixOS
13:01:50 <shapr> I forget the reason for that, but someone on #xmonad explained it to me
13:02:08 <shapr> I ended up having to build my own xmonad binary and copy it into ~/.xmonad/
13:10:34 <tomjaguarpaw> shapr: I just worked out an unpleasant hack for this https://github.com/xmonad/xmonad/issues/154#issuecomment-579960556
13:18:20 <ChaiTRex> tomjaguarpaw: You should use ln -s and put it in /usr/local/bin instead.
13:18:52 <ChaiTRex> tomjaguarpaw: That will allow you to update it later and have the symlink updated as well, and /usr/local/bin isn't potentially clobbered by system updates.
13:18:54 * hackage language-puppet 1.4.6.2 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.6.2 (pi3r)
13:23:27 <ChaiTRex> tomjaguarpaw: Oh, and if someone has an encrypted home directory, hard links between filesystems aren't possible.
13:30:05 <topos> incoming
13:30:25 * hackage base64-lens 0.2.0 - Optics for the Base64 library  https://hackage.haskell.org/package/base64-lens-0.2.0 (topos)
14:04:02 <pounce> what the heck are orphan instances
14:04:15 <pounce> how does WrappedMonad fix that
14:04:26 <merijn> pounce: Instances that are not in the module defining the class or the datatype
14:04:39 <Cale> What's WrappedMonad?
14:04:55 <merijn> pounce: Instances are global and must be unique, the easiest way to enforce that is to ban orphans, because that guarantees uniqueness
14:04:59 <Cale> oh, from Control.Applicative?
14:05:01 <jle`> https://wiki.haskell.org/Orphan_instance
14:06:00 <Cale> I'm not sure how it helps with that, honestly.
14:06:11 <jle`> it probably used to help with orphan instances back in the day
14:06:13 <jle`> before AMP
14:06:15 <merijn> Cale: I think it's originally from Control.Arrow
14:06:28 <merijn> hmm, or not?
14:06:38 <jle`> nowadays it's probably only really useful for things like Deriving Via
14:06:57 <jle`> pounce: before back in the day, Applicative was not a superclass of Monad
14:07:12 <jle`> pounce: so sometimes you had libraries defining a type with a Monad instance, but no Functor or Applicative instance
14:07:31 <jle`> pounce: but sometimes you also had functions written for Applicative instances, like myFunc :: Applicative f => ...
14:08:08 <jle`> pounce: myFunc *should have* worked on BadMonad, since BadMonad has a Monad instance. but the people who wrote it did not write an Applicative instance, so you can't use it with myFunc
14:08:16 <Cale> Ah, right, if you had a *library* which wanted to make use of a Functor instance on something with an instance of Monad but not Functor, and were too lazy or in too much of a hurry to contribute to the other library it was defined in...
14:08:49 <jle`> pounce: so one thing you can do is write your own Applicative instance for BadMonad, instance Applicative BadMonad where pure = return; (<*>) = ap
14:08:53 <jle`> but that would be an orphan instance
14:09:12 <Cale> Then something like WrappedMonad would save you from writing an instance, at the cost of making the resulting thing almost intolerable to use, for all the newtype wrapping :D
14:09:13 <jle`> so the way to work around that would be to use `WrappedMonad BadMonad` instead
14:09:31 <jle`> since there was an instance Monad m => Applicative (WrappedMonad m)
14:09:37 <Cale> Instead, you were much more likely to actually just use liftM or ap
14:09:58 <jle`> so you can use `WrappedMonad BadMonad` with myFUnc :: APplicative f => .., since WrappedMonad BadMonad would have an Applicative instance
14:10:11 <Cale> But there are cases where if you wanted to use something which was Functor/Applicative polymorphic, where you'd really need something with an instance.
14:10:14 <jle`> nowadays it's not required anymore for this because all Monad instances now must have an Applicaitve instance, enforced by ghc
14:11:15 <Cale> In any case, the number of times someone has ever put WrappedMonad to good use is very close to zero
14:11:46 <jle`> it's arguably "more" useful these days maybe because DerivingVia gives it a new usecase
14:11:54 <Cale> Yeah, that is cool
14:12:44 <jle`> it's also still useful for that original purposes for typeclasses that "should" be superclasses of Monad, but aren't, i guess
14:12:50 <jle`> like Data.Functor.Bind
14:12:52 <jle`> https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Bind.html
14:12:57 <Cale> Though the instances it replaces are not hard to write by hand either. (e.g. you can always write  instance Functor MyType where fmap = liftM)
14:12:59 <jle`> but nobody is really out there writing bind-polymorphic code
14:13:09 <jle`> except for me
14:13:11 <jle`> hehe
14:32:12 <NemesisD> i'm struggling with this: is it possible to write `f :: Monad m => ConduitT i o m () -> ConduitT (a, i) (a, o) m ()`?
14:33:01 <glguy> I wouldn't think so
14:33:35 <glguy> Oh, maybe; you might be able to do it with an extra StateT layer
14:35:54 <jle`> NemesisD: sort of like a Control.Arrow.first for ConduitT?
14:36:10 <NemesisD> i've probably got a fundamental flaw in my understanding. for each input (a, i), i want to pass along the i to the inner conduit and then preserve the a
14:36:16 <NemesisD> jle`: yes i think so
14:36:23 <jle`> yeah, it doesn't really make tooooo much sense
14:36:28 <glguy> There's not a one-to-one mapping between inputs and outputs
14:36:38 <jle`> since you can have more than one input per output, or more than one output per input
14:36:41 <jle`> yeah, exactly that
14:36:41 <glguy> so at best you could do something like pair up the most recently seen input a to the output
14:37:01 <glguy> and have some initial a value that you start with so you have a pair if the first thing is an output
14:37:31 <glguy> or you could request extra (a,i) inputs and discard the i
14:37:35 <glguy> to get your starting a
14:37:52 <jle`> NemesisD: i think i've had a situation where i was looking for something similar to what you are talking about too
14:37:53 <NemesisD> oh, yeah that makes sense, i was thinking of it as 1-to-1
14:37:54 <glguy> but there's enough choice in behaviors that it's going to be very specific to what you're doing
14:38:06 <jle`> NemesisD: in the end i 'solved' it by having an underlying StateT a
14:38:29 <jle`> what i really wanted was for the downstream pipes to have access to the 'a's that the upstream were using
14:38:49 <jle`> so having the upstream pipes also write to the StateT, the downstream pipes can use it as they like
14:38:53 <jle`> or i think it was StateT [a]
14:39:37 <jle`> i use this for my machine learning pipelines
14:40:47 <NemesisD> hmm yeah i'll think about using StateT. i think maybe though several of the mid sections of my conduit that need to pass things along can actually be just `i -> m o`, in which case its easy to get an `(a, i) -> m (a o)`
14:42:32 <srid-irccloud> Does anyone here use coc.vim (in neovim), and know how to disable this annoying autocompletion behaviour? https://asciinema.org/a/0qDh2fHW8jr9kmbykOlMA9Sn1
14:50:42 <[itchyjunk]> Is there a way to add info to my function that i can see while using it from ghci?
14:50:58 <[itchyjunk]> i forget how i defined by function and i would like to leave a little hint for myself
14:55:40 <ChaiTRex> [itchyjunk]: Is there an example function that has the info that your functions don't have?
14:56:09 <[itchyjunk]> well i wrote the discrete log that take 4 inputs the prime number, generator the power and what value it has to equals
14:56:18 <[itchyjunk]> and i can't remember what order those things line up
14:56:32 <[itchyjunk]> dlog g h p x i think it should be
14:56:43 <[itchyjunk]> but if i forget, i'd like to somehow see the order
14:57:04 <hseg> A) Use newtypes so that the type signature is self-documenting 
14:57:16 <[itchyjunk]> :s
14:57:17 <hseg> B) Possibly https://wiki.haskell.org/GHC/GHCi#Lambdabot_Commands will make :src work
14:57:27 <hseg> (depends if it indexes your code as well)
14:57:29 <ChaiTRex> [itchyjunk]: There's ':doc f' in GHCi.
14:57:45 <ChaiTRex> [itchyjunk]: Let me see how the doc is written in the source file.
14:57:54 * hackage hpath-posix 0.13.0 - Some low-level POSIX glue code, that is not in 'unix'  https://hackage.haskell.org/package/hpath-posix-0.13.0 (maerwald)
14:58:08 <hseg> Oh, nice
14:58:36 <[itchyjunk]> says unknown command ':doc'
14:58:39 <hseg> It basically shows the Haddock for the function
14:58:41 <ChaiTRex> [itchyjunk]: Scroll up slightly at https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#head to see the head function's :doc
14:58:55 <solonarv> jle`: actually, WrappedMonad is not going to be very useful for that because definint 'return' in your 'Monad' instance is going the way of the dodo
14:58:55 * hackage hpath-io 0.13.1, hpath-directory 0.13.1 (maerwald): https://qbin.io/hc-vcr-5hrz
14:58:55 <hseg> [itchyjunk]: Which version of ghci?
14:59:11 <[itchyjunk]> how do i check?
14:59:14 <ChaiTRex> [itchyjunk]: See how it's formatted, and format yours like it. Then save your file and test in GHCi with :r followed by :doc
14:59:20 <[itchyjunk]> 8.0.2
14:59:32 <ChaiTRex> [itchyjunk]: Ahh.
14:59:38 <[itchyjunk]> too old or something? :s
14:59:47 <ChaiTRex> [itchyjunk]: You can use type synonyms.
14:59:55 <hseg> :doc isn't that old
14:59:55 <solonarv> [itchyjunk]: whew, I recommend upgrading
15:00:04 <solonarv> 8.0 doesn't have :doc
15:00:20 <int-e> hseg: it's new in ghc 8.6
15:00:44 <solonarv> it's even out of the (unofficial) "three most recent GHC versions" support window
15:01:02 <hseg> Judging by the copyright notice, that's 12 years old now
15:01:10 <hseg> which doesn't make sense
15:01:11 <ChaiTRex> [itchyjunk]: 'type Modulus = Integer', then 'whatever :: Integer -> Integer -> Modulus -> Integer', then in GHCi, :t whatever
15:01:33 <ChaiTRex> [itchyjunk]: But having :doc is better.
15:01:39 <ChaiTRex> [itchyjunk]: Are you on Ubuntu or something?
15:01:48 <[itchyjunk]> yes ubuntu bionic
15:01:53 <hseg> my bad, copyright wasn't updated
15:01:57 <[itchyjunk]> i got this ghci not too long ago :s
15:02:05 <[itchyjunk]> i dont remember how
15:02:08 <hseg> It's three years old now - relesed 2017-01-11
15:02:24 <[itchyjunk]> i got it few months back. lol. i wonder how i installed it
15:02:37 <ChaiTRex> [itchyjunk]: You can get 8.6 through a PPA.
15:02:50 <ChaiTRex> [itchyjunk]: Also, 8.8 if you want cutting edge.
15:03:11 <int-e> (You probably don't)
15:03:16 <solonarv> 8.8 is released, there's no real reason to prefer 8.6 over it is there?
15:03:41 <solonarv> @where ppa
15:03:41 <lambdabot> I know nothing about ppa.
15:03:53 <solonarv> huh, really?
15:03:59 <int-e> solonarv: The MFP step broke a lot of packages... not all have caught up.
15:04:00 <hseg> https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:04:07 <[itchyjunk]> https://launchpad.net/~ghc/+archive/ubuntu/ppa
15:04:13 <solonarv> int-e: oh, fair point
15:04:15 <[itchyjunk]> i'm follwoing that
15:04:26 <ChaiTRex> [itchyjunk]: No, hvr's PPA.
15:04:35 <ChaiTRex> [itchyjunk]: https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:04:41 <[itchyjunk]> :<
15:04:50 <int-e> https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:04:52 <ChaiTRex> [itchyjunk]: You uninstall GHC, etc.
15:04:53 <int-e> oops
15:04:57 <int-e> @where+ ppa https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:04:57 <lambdabot> Okay.
15:05:17 <[itchyjunk]> Hmm, any guide that will spoon feed me the steps?
15:05:36 <hseg> https://www.howtogeek.com/285042/how-to-install-software-from-third-party-ppas-in-ubuntu/
15:05:50 <maerwald> with pictures
15:05:52 <int-e> solonarv: one of the broken things is lambdabot, incidentally... partly due to waiting on dependencies.
15:05:55 <ChaiTRex> [itchyjunk]: Then, you install that PPA following the directions on that page, then you do `sudo apt install ghc-` and press tab twice to see what versions are available. Then, you complete one of them.
15:05:56 <hseg> actually, seems the https://launchpad.net/~ghc/+archive/ubuntu/ppa has ghc 8.8
15:05:57 <jle`> solonarv: oh no D:
15:06:19 <jle`> solonarv: well it still might be useful for Functor derivingvia
15:06:58 <hseg> hm, but hvr's ppa seems to support multiple compilers
15:07:06 <hseg> *versions
15:07:23 <ChaiTRex> hseg: Yeah, you have to symlink the binaries you want to use to /usr/local/bin.
15:07:24 <solonarv> which is something that might well become necessary for reasons like what int-e outlined
15:07:37 <maerwald> ChaiTRex: no, you use alternative to set it
15:07:40 <ChaiTRex> hseg: Unless you're using something like stack
15:07:51 <solonarv> I actually just use ghcup despite being on (a derivative of) ubuntu
15:08:20 <ChaiTRex> maerwald: How with hvr's?
15:08:23 <maerwald> update-alternatives
15:08:41 <ChaiTRex> maerwald: Well, yes, but what arguments?
15:08:52 <hseg> wait, isn't mfp 4yo by now? why is there still breakage?
15:08:54 <maerwald> It's described in the ppa page
15:09:43 <solonarv> hseg: exactly: it's 4 years old, it's in its final phase where it is enabled
15:09:56 <solonarv> not just by default, but *always* - you can't turn it off
15:10:04 <int-e> hseg: It's a multistep process. ghc-8.8 removed `fail` from the Monad typeclass.
15:10:14 <solonarv> that is why things are breaking
15:10:16 <hseg> ah, right
15:10:18 <ChaiTRex> maerwald: That doesn't put it in the PATH, it just sets /opt/ghc/bin stuff.
15:10:21 <solonarv> all the changes until now were "soft"
15:10:26 <hseg> people didn't update?
15:10:38 <maerwald> ChaiTRex: yes, then you add /opt/ghc/bin to your PATH, as described there
15:10:39 <int-e> (well, the base library, but for me it's easier to think of it in terms of ghc versions.)
15:10:44 <solonarv> well, 8.8 hasn't been out for that long
15:10:44 <hseg> suppose that would happen with abandoned projects
15:10:49 <int-e> (they're tightly coupled anyway)
15:10:50 <maerwald> You shouldn't put symlinks to /usr anywhere
15:10:58 <maerwald> they will be *unmanaged*
15:11:20 <hseg> solonarv: yeah, but we've been warning for this for three years now
15:11:25 <int-e> solonarv: Yeah. The annoying thing is that there is a ghc-8.10 RC before ghc-8.8 is properly adopted.
15:11:46 <remexre> is there some instance of ToJSON1 f => ToJSON (Fix f), and same for Mu, Nu in some package somewhere?
15:11:52 <hseg> int-e: why is that a problem?
15:12:18 <int-e> hseg: well couple that with the 3-major-versions policy and you have a small ecosystem desaster in the making.
15:12:58 <int-e> (Not right away. But soon.)
15:13:07 <hseg> ah... yeah, 3-major-versions as a proxy for timescale doesn't work when major bumps occur too frequently
15:13:48 <int-e> Oh well. I hope I'm wrong. :)
15:15:11 <[itchyjunk]> How does the uninstall part work? :s
15:15:29 <ChaiTRex> [itchyjunk]: Uninstalling GHC 8.0?
15:15:32 <[itchyjunk]> I've the ppa added and ready to install, but maybe i should remove this old one before getting a new one
15:15:33 <[itchyjunk]> yes
15:15:47 <ChaiTRex> [itchyjunk]: sudo apt uninstall ghc
15:16:21 <int-e> isn't it `remove` rather than `uninstall`?
15:16:37 <ChaiTRex> int-e: Let me check
15:16:38 <[itchyjunk]> ah remove worked
15:16:47 <[itchyjunk]> i didn't realize i installed it through apt even
15:16:59 <int-e> ChaiTRex: Sorry, that was rhetorical actually. I have the manpage right here.
15:17:08 <ChaiTRex> [itchyjunk]: If you installed cabal-install, remove that too.
15:17:18 <ChaiTRex> [itchyjunk]: You can get cabal through hvr's PPA.
15:17:38 <ChaiTRex> [itchyjunk]: Just make sure to get the right version for the version of GHC you choose.
15:17:46 <[itchyjunk]> idk what cabal is or if i installed it
15:17:54 <[itchyjunk]> 8.6 right?
15:17:59 <ChaiTRex> [itchyjunk]: Try sudo apt remove cabal-install
15:18:29 <[itchyjunk]> ah dont have that
15:18:40 <astk65> this is the error; https://github.com/astk-hs/hello_backpack_nix/tree/master/hello_backpack
15:18:41 <ChaiTRex> [itchyjunk]: I'm not sure which version is best. I chose 8.6 because some people were having trouble with 8.8.
15:18:51 <int-e> let's see, you'll need ghc (yes, 8.6), haddock (otherwise :doc will never work) and cabal-install is probably a good idea.
15:19:15 <astk65> but this version works;
15:19:15 <astk65> https://github.com/astk-hs/HelloWorld-backpack/tree/master/backpack_example
15:19:51 <astk65> there is some problem with nix and backpack? or did i make a mistake with nix?
15:20:06 <ChaiTRex> [itchyjunk]: For 8.6, do: sudo apt install cabal-install-2.4 ghc-8.6.5 
15:20:20 <ChaiTRex> [itchyjunk]: Not sure how to install haddock. I assume cabal will install it?
15:20:24 <[itchyjunk]> oh install it with cabal?
15:20:27 <[itchyjunk]> let me try
15:20:29 <maerwald> 2.4?
15:20:46 <ChaiTRex> maerwald: What's the correct version for 8.6?
15:20:48 <maerwald> you shouldn't install cabal-2.4, it's old
15:20:55 <maerwald> install cabal-3.0
15:21:01 <[itchyjunk]> the other options are 3.0 and 3.2
15:21:08 <maerwald> 3.2 is not released yet
15:21:13 <maerwald> those are alpha packages
15:21:19 <[itchyjunk]> oh ok
15:21:33 <[itchyjunk]> so sudo install cabal-install-3.0 ghc-8.6.5 ?
15:21:38 <maerwald> yeah
15:22:15 <koz_> I have a fold within a setting where I have MonadReader Foo m, and some other things. As part of each 'step' of said fold, I need to 'call down' something from the environment using 'asks'. Should I do all the call-downs up-front (i.e. before the fold) and pass them to the accumulating function, or as-needed at each step fo the fold?
15:22:16 <[itchyjunk]> *computer explodes*
15:23:03 <int-e> [itchyjunk]: missing an 'apt'?
15:23:28 <[itchyjunk]> ah yes an apt in there somehwere
15:23:41 <Bad_K4rMa> [itchyjunk] are you on windows?
15:23:41 <koz_> Probably 'sudo apt-get install [all the other things]'.
15:23:52 <ChaiTRex> Bad_K4rMa: Windows doesn't have apt.
15:23:58 <maerwald> never run commands from the internet...
15:24:02 <[itchyjunk]> Bad_K4rMa, ububtu
15:24:10 <Bad_K4rMa> ahh nvm then
15:24:44 <[itchyjunk]> so i cabal installed ghci, what does that mean? how do i launch ghci?
15:24:57 <[itchyjunk]> what is cabal? :D
15:25:08 <maerwald> something like npm
15:25:27 <int-e> or pip
15:25:27 <Bad_K4rMa> type "ghci"
15:25:38 <Bad_K4rMa> w/out quotes
15:25:52 <[itchyjunk]> i tried, it says not installed
15:25:52 <ChaiTRex> [itchyjunk]: You don't cabal install GHCi. It comes with GHC.
15:26:13 <ChaiTRex> [itchyjunk]: Now you have to set your systemwide PATH to include /opt/ghc/bin
15:26:16 <maerwald> [itchyjunk]: https://launchpad.net/~hvr/+archive/ubuntu/ghc read the instructions on that page
15:26:17 <[itchyjunk]> ghciCommand 'ghci' not found, but can be installed with:sudo apt install ghc
15:26:23 <[itchyjunk]> ah
15:26:26 <maerwald> it's all described there
15:27:01 <int-e> [itchyjunk]: check whether you actually installed that ghc-8.6.5 package
15:28:03 <[itchyjunk]> int-e, how do i make wether i actually installed that or not?
15:28:16 <[itchyjunk]> i think i did, i just need to figure out how to add this PATH business
15:29:48 <ChaiTRex> [itchyjunk]: https://stackoverflow.com/a/26962251/7208029 describes how to set a systemwide PATH. /etc/environment.d/haskell.conf would be a good file to create, but you can use whatever method you prefer.
15:30:06 <[itchyjunk]> the right package exists in /opt/
15:31:25 <ChaiTRex> [itchyjunk]: Yes, the directory to add to PATH is /opt/ghc/bin
15:32:24 * hackage policeman 0.0.0.0 - Haskell PVP version adviser  https://hackage.haskell.org/package/policeman-0.0.0.0 (vrom911)
15:33:09 <ChaiTRex> [itchyjunk]: It would be a one-liner for the /etc/environment.d/haskell.conf file: PATH=/opt/ghc/bin:$PATH
15:34:08 <ChaiTRex> [itchyjunk]: Then, you test something before rebooting: /opt/ghc/bin/ghci
15:34:49 <[itchyjunk]> well i was just not finding any /etc/environment 
15:35:05 <[itchyjunk]> maybe i need to create it?
15:35:10 <ChaiTRex> [itchyjunk]: You probably need sudo mkdir /etc/environment.d
15:35:30 <ChaiTRex> [itchyjunk]: Then, sudo favoritetextfileeditor /etc/environment.d/haskell.conf
15:35:44 <ChaiTRex> [itchyjunk]: Then add a line to the file: PATH=/opt/ghc/bin:$PATH
15:36:03 <ChaiTRex> [itchyjunk]: Save, then on reboot that will be added to your PATH so you can run the commands in it like ghci.
15:36:40 <ChaiTRex> [itchyjunk]: If you don't have a favorite text file editor, try nano.
15:40:12 <[itchyjunk]> ah i need the actual computer to reboot before it reloads those paths?
15:40:31 <ChaiTRex> [itchyjunk]: Yes, but have you saved the file with just that one line in it?
15:40:39 <[itchyjunk]> yes
15:40:45 <ChaiTRex> [itchyjunk]: Try: cat /etc/environment.d/haskell.conf
15:40:59 <ChaiTRex> [itchyjunk]: Ensure it shows just that one line: PATH=/opt/ghc/bin:$PATH
15:41:04 <[itchyjunk]> yes its there
15:41:29 <ChaiTRex> [itchyjunk]: OK, now see if the files are in that directory. Try running: /opt/ghc/bin/ghci
15:41:47 <[itchyjunk]> yes that launches the right ghci
15:42:03 <ChaiTRex> [itchyjunk]: OK, exit GHCi and paste the results of the cat command here.
15:43:07 <[itchyjunk]> cat /etc/environment.d/haskell.conf 
15:43:08 <[itchyjunk]> PATH=/opt/ghc/bin:$PATH
15:43:24 <int-e> reboot... shouldn't opening a new shell suffice?
15:43:27 <ChaiTRex> [itchyjunk]: OK, reboot, then try ghci by itself with no /opt stuff.
15:43:34 <[itchyjunk]> ok
15:43:37 <int-e> or, failing that, logging out and in again
15:45:48 <hseg> Hm. I have a function meas :: (KnownNat d, KnownNat r) => L d r for which I want to provide an interface where only one of d/r needs to be supplied. Easy - CPS+reflection. However, this must later be passed to a function int :: KnownNat d => L d r -> (F d -> c) -> c.
15:46:10 <hseg> unclear how to add that last design constraint into the mix
15:46:40 <pdxleif> What does the "legacy fallback" listed next to some packages mean when running cabal new-build?
15:47:09 <mniip> hseg, you mean like  Either (Dict (KnownNat d) (KnownNat r)) -> L d r
15:47:16 <mniip> er
15:47:27 <mniip> Either (Dict (KnownNat d)) (Dict (KnownNat r)) -> L d r
15:47:32 <hseg> Yeah
15:47:37 <ChaiTRex> int-e: I'm not sure if /etc/environment.d stuff is boot-time or on a new shell.
15:47:41 <mniip> you could use exactly that
15:47:48 <hseg> CPS+reflection permitted Int -> L d r
15:47:51 <hseg> hrm
15:48:06 <mniip> you can CPS it to something like
15:48:13 <hseg> Actually, your API makes more sense - permits avoidance of cps
15:48:20 <mniip> (forall a. (KnownNat d => a) -> (KnownNat r => a) -> a) -> L d r
15:51:06 <hseg> Right -- can write measDict, then have meas'd = measDict (Left Dict); meas'r = measDict (Right Dict)
15:53:06 <int-e> ChaiTRex: neither, it seems... it looks like a session thing, tied to the user's systemd instance.
15:53:35 <int-e> ChaiTRex: neither, it seems... it looks like a session thing, tied to the user's systemd instance.
15:53:36 <hseg> mniip: Though it is unclear to me how I'd synthesise eg the Dict (KnownNat r) 
15:54:01 <hseg> (d and r can be computed from each other, though this is much more convenient at the term level)
15:54:04 <mniip> Dict :: KnownNat r => Dict (KnownNat r)
15:54:08 <mniip> :P
15:54:33 <hseg> Yeah, but how do I satisfy the KnownNat r constraint without CPS?
15:54:40 <ChaiTRex> int-e: Just tried it here and it doesn't seem to add anything to the PAtH.
15:54:43 <ChaiTRex> int-e: Even after a reboot.
15:55:49 <hseg> Basically, my options seem to be to compute at the term level, requiring a CPS+reflection; or compute at the type level, requiring serious hasochism with singletons
15:58:24 * hackage mmsyn7ukr 0.12.0.3 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.3 (OleksandrZhabenko)
15:58:36 <hseg> Problem with CPS solution is that my resulting L d r is existential in d -- ununifiable with the d in (F d -> c). Problem with the singletons is that they're singletons
15:59:54 <mniip> unless you can lift your relationship between r and d onto the type level - in terms of some constraints or an injective type family or functional dependencies
15:59:58 <hseg> (btw, passing through term level also requires synthesising the relevant equality constraints, but am perfectly willing to unsafeCoerce them into existence)
16:00:03 <mniip> you're pretty much stuck with one of them being existential yes
16:02:24 <hseg> Tried lifting to the type level, but had an equality constraint depending on the parity of d that mucked it all up
16:03:00 <hseg> (specifically, constraints of the form d~(2*r+(d`Mod`2))
16:03:45 <mniip> that does not compute
16:03:52 <hseg> and worse, d~(2*r+(2-d`Mod`2))
16:03:56 <hseg> mniip: ?
16:04:41 <hseg> Ah, I see -- there's the d dependence on both sides
16:04:54 <mniip> d = 2r + 2 - (d mod 2)
16:05:08 <mniip> d + (d mod 2) = 2r + 2
16:05:20 <mniip> 2((d + 1) div 2) = 2r + 2
16:05:27 <mniip> this neither determines d from r, nor r from d
16:05:37 <mniip> ok nvm it determines r from d
16:05:46 <mniip> but not d from r still
16:05:58 <hseg> Right... only determines d from r, d`mod`2
16:07:02 <mniip> maybe split d into d`div`2 and d`mod`2
16:07:05 <hseg> OK, still -- have here d and (r, d `mod` 2) determining each other, want to be able to only supply one
16:09:37 <mniip> (dd ~ r + 1 - dm, r ~ dd + dm - 1, dm ~ r + 1 - dd)
16:11:23 <hseg> yeah, but that's not the interface I want -- want (KnownNat d, C d r) => L d r; (KnownNat r, C d r) => L d r for some constraint C
16:12:32 <mniip> the constraint C can only be reduced once an equation constraint enters scope
16:12:45 <mniip> and there isn't an equation constraint that would determine d`mod`2 without detemrining d
16:13:01 <hseg> Don't understand 
16:13:02 <mniip> unless it's like
16:13:06 <mniip> (d `mod` 2 ~ k)
16:13:08 <mniip> hm
16:15:01 <hseg> Was thinking of using an injective type family D2R with D2R d = (d `Mod` 2, (d- d`Mod`2) `Div` 2) 
16:15:21 <hseg> except Haskell doesn't yet have partial injectivity for type families
16:15:39 <hseg> so GHC doesn't know that _ `Mod` 2 is injective
16:15:45 <hseg> idem for _ `Div` 2
16:16:04 <hseg> ... well, that last one is noninjective
16:16:23 <hseg> but is injective along with _ `Mod` 2
16:17:00 <hseg> hrm. I'm actually just using the injectivity of DivMod
16:19:19 <hseg> So basically, I want to say meas :: ((r,p) ~ d `DivMod` 2) => L d r, with inference requiring either d or (r,p) to be passed
16:20:08 <hseg> Still needs _ `DivMod` 2 to be injective though
16:22:12 <hseg> ... although, if I made DivMod into a data family...
17:24:16 <alc> how to make a polymorphic function f, f :: Int -> Int, f :: String -> String?
17:24:29 <alc> f x = x+1
17:24:35 <alc> f str = str
17:25:13 <pthariensflame> That’s intentionally not possible.
17:25:43 <pthariensflame> (By which I mean it’s technically possible with some advanced features but a really bad idea anyway.)
17:26:03 <alc> pthariensflame: which features?
17:26:35 <pthariensflame> Look up the documentation for the standard library module Data.Typeable for the details.
17:27:05 <pthariensflame> Basically you need a way to inspect the type of your argument at runtime, and that’s not as simple a task in Haskell as it is in, say, Java (on purpose).
17:27:31 <Axman6> Type classes are generally the mechanism for making polymorphic functions like that, but youy should have a good reason for making a new typeclass. Just wanting a generic way of changing the behaviour of id for specifics types isn't a good reason
17:29:51 <alc> Axman6: but that need Int and String as instances of one same typeclass, then implement function f for Int and String?
17:32:09 <alc> it's simple to do that in dynamic languages like python or js, just check if it's Int or String
17:32:10 <Axman6> what you are trying to do is a bad idea
17:32:54 <alc> Axman6: actually I just got that idea from learning rankNTypes
17:33:29 <alc> that rankNTypes can make a function to take a polymorphic function as parameter
17:33:37 <suzu> class Foo a where { f :: a -> a }; instance Foo Int where { f = x + 1 }; instance Foo String where { f str = str };
17:33:39 <alc> so I wonder how the polymorphic function would be
17:33:52 <alc> suzu: thanks
17:34:03 <suzu> it'll do what you want
17:34:08 <suzu> but what you want might not be the right thing
17:34:13 <suzu> for what you're trying to do
17:34:15 <suzu> or it might
17:34:17 <suzu> i don't know
17:34:36 <alc> then what the polymorphic function should be in rankNTypes?
17:34:50 <suzu> what do you need rankntypes for?
17:35:21 <alc> no need now, just learning
17:36:23 <suzu> won't do anything useful here
17:36:37 <alc> instance Foo Int where { f = (+1) };
17:36:42 <suzu> err yeah
17:37:24 <alc> eta-convertion in everywhere, right?
17:38:16 <suzu> eta reduction, yeah
17:38:25 <suzu> or pointfree
17:38:29 <suzu> or whatever
17:38:41 <suzu> i often deliberately leave things not point free
17:38:44 <suzu> because pf can melt your brain
17:43:44 <alc> there's another question, if I `data P = V Int`, so V (3 :: Int) :: P, but I can do `id (V 3)` or `print (V 3)`, cos data type P doesn't has function id or print, right?
17:44:06 <alc> if I make P as instance of Show typeclass, it can print
17:44:24 <jle`> alc: it has 'id'
17:44:30 <jle`> since 'id' is polymorphic over everything
17:44:32 <jle`> :t id
17:44:34 <lambdabot> a -> a
17:44:36 <jle`> alc: but no 'show'
17:44:38 <jle`> :t show
17:44:40 <lambdabot> Show a => a -> String
17:44:42 <alc> > data P = V Int
17:44:44 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
17:44:45 <jle`> note the constraint
17:45:09 <jle`> @let data P = V Int
17:45:10 <lambdabot>  Defined.
17:45:20 <alc> :t id (V 3)
17:45:22 <lambdabot> P
17:45:43 <jle`> you can use it with any polymorphic function that doesn't restrict its arguments
17:45:49 <jle`> like also 'const'
17:45:50 <jle`> :t const
17:45:52 <lambdabot> a -> b -> a
17:45:54 <jle`> :t S.singleton
17:45:56 <lambdabot> a -> S.Set a
17:45:57 <alc> jle`: except for id, is there others polymorphic function that over everything?
17:45:57 <jle`> etc.
17:46:07 <jle`> alc: i just showed some examples :)
17:46:19 <jle`> :t flip
17:46:21 <lambdabot> (a -> b -> c) -> b -> a -> c
17:46:26 <alc> jle`: which module contains those polymorphic functions?
17:46:37 <jle`> const and flip are from Prelude
17:46:44 <jle`> S.singleton is from Data.Set from the containers package
17:46:50 <alc> should there be a module called Functions.Polymorphic
17:46:54 <jle`> but really, polymorphic functions are everywhere
17:46:57 <jle`> they are the bread and butter of haskell
17:47:05 <jle`> pretty much all modules have polymorphic functions
17:47:06 <jle`> :t fmap
17:47:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:47:10 <jle`> :t (<*>)
17:47:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:47:12 <jle`> :t pure
17:47:13 <lambdabot> Applicative f => a -> f a
17:47:14 <jle`> :t (>>=)
17:47:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:47:17 <suzu> polymorphism is stage 1 here
17:47:21 <suzu> of abstraction
17:47:27 <suzu> and yeah it is everywhere in the language
17:47:32 <alc> suzu: then what's stage 2 or 3?
17:47:34 <jle`> alc: basically you can't go anywhere without seeing polymorphic functions
17:47:36 <jle`> :)
17:47:37 <suzu> typeclasses i suppose
17:47:51 <jle`> if they were all in a module then like ... you'd pretty much have every other function in haskell ecosystem
17:47:57 <suzu> just polymorphic functions and typeclasses will really just get you almost all of haskell
17:48:04 <suzu> and you can probably solve everything with just those things
17:48:05 <jle`> :t Just
17:48:07 <lambdabot> a -> Maybe a
17:48:10 <jle`> :t Left
17:48:11 <lambdabot> a -> Either a b
17:48:14 <jle`> :t Right
17:48:16 <lambdabot> b -> Either a b
17:48:20 <suzu> rankntypes and datakinds and other whacko academic stuff is cool but not necessary for solving problems
17:48:20 <jle`> :t (:)
17:48:22 <lambdabot> a -> [a] -> [a]
17:48:22 <jle`> here are a few more :)
17:48:32 <alc> jle`: then why it's not a good intent to do polymorphic function by yourself?
17:48:32 <jle`> :t (,)
17:48:34 <lambdabot> a -> b -> (a, b)
17:48:36 <alc> intentino
17:48:38 <jle`> alc: what do you mean?
17:48:45 <jle`> write your own polymorphic functions?
17:48:49 <suzu> i think we should all be avoiding a lot of the more advanced haskell tbh
17:48:55 <alc> jle`: f :: Int -> Int, f :: String -> String
17:49:06 <jle`> alc: usually the good practice is to be as polymorphic as possible
17:49:17 <jle`> so never write an Int -> Int, if you can get away with an a -> a
17:49:25 <suzu> or Num a => a -> a
17:49:27 <suzu> :)
17:49:34 <jle`> there are some exceptions when exporting functions and library API development
17:49:58 <alc> jle`: but function f justg handle Int and String, no other types
17:50:05 <jle`> alc: right
17:50:09 <jle`> that is true
17:50:15 <jle`> what part confuses you, exactly?
17:50:27 <alc> jle`: RankNTypes
17:50:39 <jle`> ah that is ... an unrelated thing
17:50:39 <alc> jle`: polymorphic functions in RankNTypes
17:51:03 <alc> not related?
17:52:06 <suzu> who cares about rankntypes
17:52:29 <suzu> i've only found a use for it doing the statet trick and thats it
17:52:31 <suzu> meh
17:53:02 <dasli> does anybody know when the Haskell Symposium submission deadline is this year?
17:53:03 <alc> aha
17:53:08 <pthariensflame> If you write a function with the type (forall a. a -> a) -> B for any concrete B, then you won’t be able to pass your function on Int and String into it.
17:53:33 <pthariensflame> suzu: RankNTypes is also useful with lenses.
17:53:34 <dasli> ICFP is March 3, but I think Haskell is later
17:54:00 <suzu> when do you use it with lenses?
17:54:54 <pthariensflame> Concretified lens types need RankNTypes to be written.
17:54:55 <alc> I still don't know what RankNTypes is used to
17:55:54 <pthariensflame> Like data Lens s t a b = Lens (forall f. (Functor f) => (a -> f b) -> s -> f t)
17:56:15 <pthariensflame> If you’re doing van Laarhoven lenses anyway.
17:56:36 <pthariensflame> If you doing store-coalgebra lenses then you don’t need it but they’re also not as general.
17:57:14 <pthariensflame> And if you’re doing residual lenses then you need ExistentialQuantification for writing them and RankNTypes for writing the combinators for them.
17:57:23 <ChaiTRex> Why can't (forall a. a -> a) -> (forall b. b -> b) be converted to forall a b. (a -> a) -> b -> b?
17:58:12 <pthariensflame> Because the first of the two foralls can’t be moved without changing the meaning of the type signature.
17:58:19 <alc> suzu: class Foo a where { f :: a -> a}; instance Foo Int where { f = (+1) }; instance Foo String where { f = id }; why id can't work here?
17:58:40 <pthariensflame> id can work there!
17:58:51 <pthariensflame> It’ll just be specialized to String, like usual.
17:59:02 <alc>  (All instance types must be of the form (T t1 ... tn) where T is not a synonym.
17:59:11 <alc> ? Illegal instance declaration for ‘Foo String’
17:59:13 <ChaiTRex> pthariensflame: What are the distinct meanings?
17:59:17 <pthariensflame> Oh!
18:00:00 <pthariensflame> alc: That’s unrelated to anything else here; that error is because you can’t write an instance over String no matter what, because it’s just a synonym for [Char].
18:00:31 <pthariensflame> You can freely dispense with that restriction by enabling FlexibleInstances.
18:00:34 <alc> pthariensflame: I tried [Char] too, errors are  (All instance types must be of the form (T a1 ... an)  where a1 ... an are *distinct type variables*,
18:00:47 <alc> and each type variable appears at most once in the instance head. Use FlexibleInstances if you want to disable this.)
18:01:01 <alc> why this FlexibleInstances shows every error?
18:01:01 <pthariensflame> Yeah, that’s what it means.
18:01:21 <alc> those most errors I have met, they all have FlexibleInstances
18:01:54 <pthariensflame> Instances need to be of the form (...) => ClassName TypeName ... where the second ... can only be type variables.
18:02:27 <pthariensflame> So instance [a] is okay, but instance [Char] is not because Char isn’t a type variable.
18:02:48 <alc> pthariensflame: but I just want String, not [Int]
18:03:10 <pthariensflame> Right, so you need FlexibleInstances, which disables that particular restriction.
18:03:27 <alc> ok
18:04:57 <pthariensflame> ChaiTRex: forall a. Foo -> Bar (where Foo and Bar might use a) lets anyone who calls the function pick what a is; the function has to be written without knowing what it could be.
18:06:22 <ChaiTRex> pthariensflame: Sure, but why isn't that still satisfied after moving the quantifier outwards? Both have a forall a.
18:06:43 <pthariensflame> (forall a. Foo) -> Bar (where Foo might use a, but Bar can’t because it’s not in scope) lets the function use that input at any choice of a it likes, including multiple different ones in different places, and the caller of the function can’t assume anything about what a might be, because the thing it passes in has to work for all a.
18:07:20 <pthariensflame> It’s about who gets to choose what a is and who has to deal with a being unknown.
18:07:41 <pthariensflame> In the first case the caller is the former and the callee is the latter.
18:07:48 <pthariensflame> In the second case it’s the other way around.
18:09:57 <pthariensflame> ChaiTRex: Sorry; I got disconnected.
18:10:04 <pthariensflame> Was that explanation clear?
18:10:07 <ChaiTRex> So, with (forall a. a -> a) -> (forall b. b -> b), the caller chooses a but with forall a b. (a -> a) -> b -> b, the collee chooses a?
18:10:21 <ChaiTRex> pthariensflame: No, I'm confused.
18:10:30 <pthariensflame> Other way around.
18:10:59 <pthariensflame> Here’s the way to think about it in line with software engineering intuition:
18:11:03 <ChaiTRex> pthariensflame: The caller is the code using the function and the callee is function's definition?
18:11:10 <pthariensflame> Yup!
18:11:25 <pthariensflame> When I call a function, I’m expected to pass arguments of the right type.
18:11:41 <pthariensflame> When a function gets called, it expects to receive arguments of the right type.
18:12:43 <pthariensflame> So when I call a function of type forall a . … -> …, I can chose what a I want to use it for and then I have to give it types corresponding to that for its arguments, and it’s going to give me back a type corresponding to that as it’s result, right?
18:13:22 <ChaiTRex> Right.
18:13:23 <dmwit> ChaiTRex: You might also like https://stackoverflow.com/a/42821578/791604
18:13:53 <pthariensflame> But when I call a function of type (forall a. …) -> …, I need to pass it an argument of type forall a. ….  I need a polymorphic value to pass as an argument, not yet specialized.
18:14:09 <pthariensflame> And then the function can choose to specialize whatever I passed it as part of its definition.
18:15:09 <ChaiTRex> Oh, so I can only pass id or a bottom-producing function with that rather than an Int -> Int function.
18:15:32 <dmwit> yes
18:15:48 <ChaiTRex> Ahh, that makes sense. Thanks.
18:17:09 <ChaiTRex> :t map
18:17:11 <lambdabot> (a -> b) -> [a] -> [b]
18:18:20 <dmwit> That is secretly `forall a b. (a -> b) -> [a] -> [b]`.
18:18:41 <shachaf> It was secret until you spilled the beans! Nice going.
18:25:01 <alc> suzu: data P = V Int deriving Show, can `print (V 3)`, but how to make P as instance by `instance Show P where {...}`?
18:29:04 <alc> suzu: instance Show P where { show (V x) = "V " <> show x } ?
19:45:50 <suzu> yeah that'll work
19:46:07 <suzu> you can also just have GHC write it for you
19:46:22 <suzu> oh i see you already knew that
19:46:24 <suzu> yep
20:42:42 <alc> suzu: this is related to ad-hoc polymorphism?
20:42:50 <alc> this f can work on Int or String
20:43:18 <alc> or parametric polymorphism
20:54:36 <ChaiTRex> alc: Are you talking about typeclass functions that have different implementations for each type? If so, I think that's ad-hoc.
20:56:28 <alc> ChaiTRex: yeah, class Foo a where { f :: a -> a };instance Foo Int where { f = (+1) };instance Foo String where { f = id };  this f is ad-hoc, right?
20:56:47 <alc> ChaiTRex: and id is parametric polimorphism?
20:57:38 <ChaiTRex> alc: Yes, I think that's correct.
21:35:07 <alc> what is first-order logic? related to lambda cube?
21:36:33 <ChaiTRex> alc: I don't know what lambda cube is, but it's a language for logic with quantifiers.
21:36:38 <alc> "The Glasgow Haskell Compiler supports a language extension called RankNTypes which I’ve had my problems to understand. The moment I understood that it mostly refers to first-order logic universal quantification things became easier, though… but first let’s explore why we need it in a step-by-step example."
21:39:07 <heatsink> First-order logic is logic where variables can't stand for terms containing quantifiers
21:40:10 <heatsink> There's a formal equivalence between logic and lambda calculus, called the curry-howard correspondence.  So there's a particular kind of lambda calculus that's equivalent to first-order logic
21:40:57 <heatsink> That's not the right definition of first-order logic
21:42:10 <heatsink> Variables in FOL can't stand for any logical terms.  They can only stand for terms in the language they're describing.
21:43:22 <alc> what `order` here mean?
21:43:30 <heatsink> In FOL, you can say, "for all x, y, and z, if x > y and y > z, then x > z".  The variables stand for numbers, not logical temrs.
21:44:03 <alc> FOL is shortfor ?
21:44:11 <ChaiTRex> alc: First order logic.
21:45:03 <heatsink> I don't know why it's called order
21:45:39 <ChaiTRex> There's higher orders, like second-order logic, I think.
21:45:55 <olligobber> I think order is similar to degree
22:18:54 * hackage json-api-lib 0.1.2.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.1.2.0 (shirren)
23:00:25 * hackage mmsyn7ukr 0.12.0.4 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.12.0.4 (OleksandrZhabenko)
23:06:24 * hackage vformat 0.14.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.14.0.0 (gqk007)
23:15:24 * hackage mmsyn7h 0.7.2.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.2.0 (OleksandrZhabenko)
23:21:54 * hackage mmsyn7l 0.3.2.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.3.2.0 (OleksandrZhabenko)
