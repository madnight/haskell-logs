00:03:11 <edwardk> iqubic: eliza is very little code
00:03:49 <iqubic> I wouldn't expect that. But I guess it make sense.
00:05:24 <edwardk> with a  decent regex engine you're basically  matching out bits of the sentence, then post processing to switch person and fake understanding with a bunch of cases
00:06:01 <iqubic> Now that you meantion it, that makes a ton of sense.
00:06:21 <edwardk> @vixen is vixen still enabled?
00:06:21 <lambdabot> I played by the rules of politics as I found them.
00:07:12 <iqubic> What is vixen? Is that just a simple chat bot?
00:07:22 <iqubic> @vixen What are you?
00:07:22 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
00:07:25 <edwardk> used to be, not sure if its wired up any more, because it was distracting
00:07:38 <iqubic> I have no idea what it's doing there.
00:07:57 <edwardk> yeah ignore it, wasn't sure if it was a full eliza or not
00:08:19 <iqubic> Looks like it's just spitting out random nonsense.
00:08:56 <MarcelineVQ> Yeah, no one would ever say anything like that
00:13:22 <energizer> https://talktotransformer.com/
00:13:45 <energizer> i wonder what a chat-trained one of those would do
00:14:08 <MarcelineVQ> not as much as you'd think
00:14:17 <energizer> you tried it?
00:14:19 <MarcelineVQ> But they're fun to mess around with
00:14:44 <MarcelineVQ> it and derivatives of it, not trained on this chat though :>
00:15:22 <MarcelineVQ> the model used is really bad at maintaining characters, it can sequence events better than many things but conversation in particular falls apart fast
00:15:49 <energizer> ah
00:16:02 <Digit> this is where fatherjackbot.hs exells.  n_n  few lines of code, and smart enough to convince the cardinals it's a genius.
00:16:15 <Digit> less is more.  n_n
00:16:54 <Digit> excels*
00:25:23 <edwardk> MarcelineVQ: you can test that with something like aidungeon. it's pretty bad at mixing folks up
00:25:48 <MarcelineVQ> it really is
00:26:11 <edwardk> i'd love to try to cross-train a model with text to speech diarization and coreference resolution using the latter two to reject  obvious gender mismatches and the like
00:26:23 <iqubic> I know #emacs has rudybot, which is much the same as this sort of thing.
00:26:32 <MarcelineVQ> They'd do well to have an option that presents 3 generated options per action and you choose the one that makes most sense, instead you have to spam /revert
00:27:07 <edwardk> MarcelineVQ: i've been playing around with ways to generate using something like dasher. not quite at the level someone else could run it, but its kinda fun
00:28:24 <edwardk> basically take the top_k  for each position and sort alphabetically giving them size = odds, then give  you the dasher style prompt. what i'd like to be able to do is click somewhere on the text and dash from there for as long as i  want
00:29:11 <MarcelineVQ> What is dasher?
00:29:27 <edwardk> https://en.wikipedia.org/wiki/Dasher_(software)
00:29:30 <MarcelineVQ> ah took a second search to find
00:29:48 <edwardk> further right = faster zoom, up down to pick
00:30:34 <edwardk> good for folks with conditions like ALS with only a couple of movable muscles to twitch type
00:31:41 <edwardk> i'm really liking using that style of ui for spewing text out of transformer (and hopefully reformer) models, for things like autocomplete and maybe codegen in the near future
00:32:49 <mniip> hey edwardk
00:32:54 <edwardk> heya mniip
00:34:37 <mniip> emily is taking me out to lambdajam >.>
00:34:45 <edwardk> sweet
00:34:53 <edwardk> will see  you there!
00:35:37 <edwardk> will be nice to put a face/name/voice to a nick =)
00:36:29 <mniip> could've just been more active on discord ;)
00:36:51 <edwardk> that reminds me i should twitch again sometime
00:37:08 <mniip> I've been contemplating content-creating myself
00:37:26 <edwardk> i've held off mostly because i've been writing mostly kotlin
00:38:01 <edwardk> and the incidence of unresolvable headdesk stupidity there is much higher than in the haskell world for me
00:38:34 <mniip> oh I completely forgot, I *did* make this https://i.imgur.com/CaU6nLH.png
00:39:06 <mniip> was a live lecture over discord screenshare
00:39:09 <mniip> pretty great format
00:39:18 <mniip> means you don't have to actually put effort into video editing
00:41:06 <mniip> edwardk, why do you subject yourself to the pain of writing type trickery in non-haskell
00:42:14 <edwardk> mniip: RAW SPEED
00:42:17 <edwardk> in theory
00:43:22 <edwardk> said in the tone of BRUTE STRENGTH here https://slatestarcodex.com/2015/06/02/and-i-show-you-how-deep-the-rabbit-hole-goes/
00:45:02 <edwardk> mniip: i have all the twitch stuff set up and ready to go really. i just need to remember to move a damn camera and set up a couple of milk crates with my green-screen on it
00:45:57 <mniip> I'm busy for the next couple days unfortunately
00:49:38 <gentauro> edwardk: do you have a guide on when (and why) to use `{-# UNPACK #-}` in the definition of datastructures in Haskell. For example: `data Heap a= Nil | Cons {-# UNPACK #-} !Word (Tree a) (Heap a)`
00:52:06 <edwardk> gentauro: i tend to unpack single word objets  like Word, Int, etc. and multi-word ones when they are going to be used as their constituent parts and not often passed on in aggregateee
00:52:13 <edwardk> er aggregate
00:55:24 <gentauro> edwardk: thx. And this is done for performance right? Do you have numbers on what it means to place `{-# UNPACK #-}` "correctly" in data type definitions?
00:57:38 <edwardk> gentauro: it can save a bunch of  memory a well  as performance. Basically an Int costs something like 2-3 words in a separate heap object (for the constructor and  payload, and maybe some profiling wrapper nonsense depending on the runtime setup), then you need a pointer to it in the structure, so you  spend 3-4x storage, and have to follow a pointer so it means reading that int will usually be a cache miss
00:57:59 <edwardk> gentauro: it is definitely something you get a feel for with time, like with ! annotations
00:58:43 <edwardk> i typically place ! annotations anywhere I don't want thunks to accumulate as i do lots of operations (and know the type). then i unpack the ones that i know the heap representation for. 
01:00:48 <phadej> newer GHC put {-# UNPACK #-} before strict (!) small things automatically, e.g. before !Word
01:00:57 <phadej> edwardk is just used to old GHC not doing it :)
01:01:58 <gentauro> 10:00 < phadej> newer GHC put {-# UNPACK #-} before strict (!) small things automatically, e.g. before !Word
01:02:01 <gentauro> that's cool
01:03:19 <edwardk> phadej: i'm prone to turn that off  actually ;)
01:05:54 <gentauro> edwardk: what's the reason? You don't trust GHC will do a better job than yourself? :)
01:10:25 <edwardk> gentauro: no, there are legitimate times when I _do_ want to be able to explicitly ask for the one word object to be shared especially when i expect to construct and use it lots but dereference it rarely
01:16:54 * hackage Chart 1.9.3 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.9.3 (bravit)
01:17:54 * hackage Chart-cairo 1.9.3 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.9.3 (bravit)
01:18:54 * hackage Chart-gtk3 1.9.3, Chart-gtk 1.9.3, Chart-diagrams 1.9.3 (bravit)
01:19:42 <gentauro> edwardk: any chance you are coming by the Monadic Party (again) this year?
01:19:53 * hackage Chart-tests 1.9.3 - Tests of the Charts library.  https://hackage.haskell.org/package/Chart-tests-1.9.3 (bravit)
01:19:57 <gentauro> you could do a workshop on this topic
01:35:01 <thblt> If a and b are functions, then a . b is stricly equivalent to a <$> b, right?
01:36:18 <phadej> edwardk: there's also NOUNPACK, which is probably good thing to add if you really want it to not be unpacked
01:36:21 <thblt> One should check the code before asking stupid questions: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-818 
01:36:21 <phadej> edwardk: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#nounpack-pragma
01:36:23 <edwardk> gentauro: i'm a bit overbooked this year actually. i might make it to next year
01:36:23 <thblt> Sorry for the noise
01:36:31 <phadej> edwardk: zurihac?
01:37:21 <edwardk> phadej: i'll probably go to zurihac and lambdajam, might make it to compose and ICFP, but otherwise i'm actually trying to take a year to actually write some code
01:38:12 <edwardk> the main thing i have to show for the last ~3 months is cadenza, and that isn't even done
01:38:24 <iqubic> What is cadenza?
01:39:03 <edwardk> it is an exercise in trying to figure out how to get a "free JIT" out of writing an interpreter in a funny way (on the JVM)
01:39:14 <mniip> free
01:39:20 <mniip> which forgetful functor we talking about?
01:39:23 <iqubic> Oh. I really want this to be complete.
01:39:39 <phadej> mniip: i guess there the "free" is as in "free beer"
01:39:41 <edwardk> in particular i want most of the performance of a compiler for functional languages out of writing an interpreterfor one
01:39:54 <edwardk> free as in RSI-reduction ;)
01:40:16 <mniip> the diagnosis or the register?
01:40:30 <iqubic> Reducing Repetitive Strain Injury sounds good.
01:41:11 <edwardk> iqubic: basically the goal is to get truffle/graal on the JVM to work well with trampolining, polymorphic inline caching, normalization by evaluation, and a bunch of other weird toys
01:41:43 <edwardk> with an eye towards using it to speed up not just runtime of a dependent type checker, but the compile time, through NBE
01:41:58 <iqubic> Sounds cool. I'm looking forward to seeing the final result.
01:41:59 <edwardk> and/or even look at it as an alternative way to run GHC at some point in the future
01:42:06 <edwardk> github.com/ekmett/cadenza
01:42:10 <edwardk> has a working repo
01:42:20 <edwardk> right now we're targeting a simply typed lambda calculus
01:42:22 <edwardk> and it does run
01:42:32 <phadej> or walk?
01:42:34 <edwardk> but it doesn't shed quite as many memory allocations as we'd like
01:42:44 <edwardk> nah it currently runs pretty fast
01:42:55 <edwardk> benchmarks are the current goal
01:43:31 <edwardk> that'll help get us a go/no go on whether we should carry on with the dependent type experiments
01:44:19 <edwardk> and that in turn will give us a better idea if it makes sense to try to replace eta from the core layer down with a truffled jit and hack up cabal to feel all the cbits of a regular package to trufflec or sulong
01:45:17 <edwardk> right now i confess acertain probably has a better working model for how well the jit is working than i do
01:45:57 <gentauro> 10:36 < edwardk> gentauro: i'm a bit overbooked this year actually. i might make it to next year
01:46:02 <gentauro> understandable :)
01:47:15 <edwardk> i think lambdajam/zurihac and maybe a couple of talks in japan are all i have hard commits to
01:49:09 <mniip> is there anything interesting going on in canadia
01:49:18 <mniip> wrt FP conferences
01:52:10 <edwardk> nothing i can think of
01:52:43 <edwardk> my one time going to a conference in canada almost resulting in me being trampled to death by a moose and/or freezing to death
01:52:51 <edwardk> er almost resulted
01:53:12 <dibblego> come to the one in Australia, fewer wildlife related incidents
01:53:24 <mniip> that one is already booked ;)
01:53:34 <dibblego> mniip: are you coming to lambdajam?
01:53:34 <gentauro> edwardk: in Newfoundland? (my uncle lives there)
01:53:38 <mniip> yeah
01:53:41 <dibblego> woot!
01:53:42 <edwardk> dibblego: sure, but then i can burn to death or die of smoke inhalation instead, not sure its better
01:53:51 <edwardk> gentauro: up in Banff
01:54:20 <dibblego> heh my student nearly wiped us out in the smoke couple of weeks back
01:54:41 <edwardk> dibblego: how has it affected flying conditions?
01:54:43 <dibblego> mniip: what are we doing when you get here?
01:55:01 <dibblego> edwardk: my student flew us into poor visibility -> dangerous
01:55:31 <dibblego> (and you cannot see it getting worse, since you're already in it)
01:55:47 <mniip> dibblego, I'm visiting some friends at unimelb first
01:55:48 <edwardk> just sneaks up on you?
01:56:02 <dibblego> edwardk: yes, as I was discussing the legal minimums with the student (she didn't know)
01:56:04 <mniip> then flying to BNE - from the on not sure yet
01:56:37 <edwardk> dibblego: you instrument rated yet?a
01:56:43 <dibblego> mniip: ok, we took Bartosz as a couple of others for a drive on the beach for the day, if you're up for that
01:56:52 <mniip> is everyone in haskell a pilot
01:56:53 <dibblego> edwardk: no, and instrument flight is illegal in that aircraft
01:57:01 <dibblego> mniip: we can do flying if ya want
01:57:15 <mniip> you can fly me from MEL ;)
01:57:19 <edwardk> still seems like it might be worth doingif this is just going to be an ongoing concern in .au
01:57:31 <edwardk> mniip: i'm not
01:57:50 <dibblego> edwardk: I'm doing night VFR this year, and yeah, I did an escape maneouvre — we were fine — just that I testing her for a licence, so a bit disappointed
01:58:06 <edwardk> ah
01:58:24 * hackage joint 0.1.4 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.4 (iokasimovmt)
01:58:35 <dibblego> like, you believe in ya student, then she doesn't know min vis, then it's getting worse and worse, then suddenly it's zero — time for me to fix this
02:01:09 <dibblego> I spent the weekend responding to complaints at the flight school, "boo hoo, the office computer is so slow, you're a computer guy, can you fix it?"
02:10:23 * hackage matrix-market-attoparsec 0.1.1.2 - Parsing and serialization functions for the NIST Matrix Market format  https://hackage.haskell.org/package/matrix-market-attoparsec-0.1.1.2 (ocramz)
02:12:24 * hackage matrix-market-attoparsec 0.1.1.3 - Parsing and serialization functions for the NIST Matrix Market format  https://hackage.haskell.org/package/matrix-market-attoparsec-0.1.1.3 (ocramz)
03:21:24 * hackage traversal-template 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/traversal-template-0.0.0.0 (MatthewFarkasDyck)
03:27:54 * hackage traversal-template 0.0.0.1 - See README for more info  https://hackage.haskell.org/package/traversal-template-0.0.0.1 (MatthewFarkasDyck)
04:34:23 <Poscat[m]> Hi all. I'm curious if there's a HTTP API for stackage. I can't seem to find any.
04:49:24 <aveltras> where can i find the list of functions exposed by ghcjs-dom with their type signature ?
05:39:26 <awdadagefasdf> Hello, in ghci, is it possible to dynamically change the definition of a function when changing the a smaller part of a function ? Here is an example: I wrote fact n = product [0..n] (notice the logical error) and then entered n `choose` k = fact n / (fact k * fact (n - k)) and I then corrected my fact function however my choose function was still
05:39:26 <awdadagefasdf> brocken
05:41:31 <awdadagefasdf> I know for performance and safety reasons it's a bad idea in compiled code but it could be useful for quick prototyping in quick throw away code right?
05:42:26 <c_wraith> it isn't possible to make it work like that automatically, but ghci uses readline.  You can just reverse-search for the definitions you want to re-enter with the same textual body
05:42:30 <merijn> awdadagefasdf: tbh, I never write stuff directly in ghci, but in files and then :reload, which would've fixed things in your case
05:43:36 <awdadagefasdf> You are right, it's a better idea to use a file
05:45:33 <nwoob> hello, I was wondering if clean architecture by bob martin is applicable to functional languages too? Sorry if this questions seems off topic, I don't know any other appropriate place to ask this question
05:54:42 <maerwald> https://gist.github.com/hasufell/eeda357c9ba32bc7e2b7bc164e7d0a31 -- is there a way to disallow constructing values on line 94 when 'b' and 'r' are not concrete? Afais the only way here is a typeclass?
05:55:24 <merijn> maerwald: Define concrete?
05:55:44 <maerwald> one of the types of Abs, Rel or Fn
05:56:52 <merijn> maerwald: If you use DataKinds you can define a single sumtype of those three, and use the kind lifted version to restrict it
05:57:20 <merijn> maerwald: So "data PathType = Abs | Rel | Fn" and "data Path (a :: PathType) = ..."
05:57:39 <merijn> maerwald: Then any type other then Abs, Rel, Fn would be a kind error
05:57:45 <amx> nwoob: i just read this very short summary https://gist.github.com/ygrenzinger/14812a56b9221c9feca0b3621518635b and I would say yes
05:58:08 <merijn> maerwald: FYI, EmptyDataDecls in that file is redundant, that's part of Haskell2010
05:59:07 <maerwald> merijn: but that would then require *any* function that uses the Path type to have a "concrete type", right? Not just the concatenating function
05:59:24 <maerwald> (which is the only one that is ill-defined without this property)
06:00:12 <merijn> maerwald: No, it doesn't require a monomorphic type at all, it just disallows types with a kind other than PathType (which, by definition, must be one of the 3 valid ones)
06:01:35 <shafox> I have nix installed also cabal-install as well. Now cabal is in my path. However when I do cabal init in an empty dir, it gives me error saying cabal: The program 'ghc' version >=7.0.1 is required but it could not be found. How do I successfully use nix cabal to create a project ? 
06:01:37 <maerwald> merijn: I mean, the idea was to have a function: parseAny :: FilePath -> Path a -- which could be used for all operations *except* concatenation
06:01:54 <merijn> maerwald: That way lies hasochism
06:02:13 <__monty__> shafox: I recommend working with a shell.nix per project.
06:02:37 <__monty__> shafox: The problem is you don't have a system-wide ghc but that's not recommended when using nix.
06:02:47 <maerwald> merijn: I guess this is why the original Path lib from chrisdone decided to not provide a 'Path Filename" type
06:03:02 <maerwald> because then the relationships become more complicated
06:03:16 <__monty__> shafox: With direnv and lorri the experience is actually quite nice. As soon as I cd into a project my haskell setup's loaded.
06:03:29 <shafox> __monty__, exactly, I dont want to have a system-wide ghc, as it brings in a lot of packages ( I am in archlinux. ) So I have to create shell.nix for every project ? And is there a starter kit that I can look up to ? 
06:03:58 <shafox> __monty__, a dummy project which has no dependencies would be awesome to refer at. Do you have one ? 
06:04:05 <__monty__> shafox: The haskell infrastructure section of the nixpkgs manual: https://nixos.org/nixpkgs/manual/
06:05:07 <amx> nwoob: Those component principles at the top appear to be sound development advice and the five characteristics of clean architecture are usually desirable regardless of what language you program in as well.
06:05:12 <mniip> maerwald, KnownPathType t => FilePath -> Path t
06:05:43 <maerwald> yeah, I considered that
06:07:58 <maerwald> the type errors are quite confusing with that API
06:08:14 <maerwald> Couldn't match type ‘Append Rel r0’ with ‘Append Rel r’
06:12:49 <maerwald> and the KnownPathType will bubble up anywhere...
06:13:38 <mniip> you need it to
06:13:59 <maerwald> yep, but it's awkward API wise
06:13:59 <mniip> otherwise parametricity ensures that functions will have to be uniform wrt the parameter
06:14:11 <maerwald> need to make a trade-off somewhere
06:15:44 <maerwald> merijn: what about creating another Any constructor for PathType and then throwing a type error in the type family for Append, then disallowing polymorphic one alltogether?
06:15:46 <maerwald> That could work
06:15:55 <merijn> I suppose
06:31:05 <Poscat[m]>  * Hi all. I'm curious if there's an HTTP API for stackage. I can't seem to find any.
06:55:51 <Athas> What is the good tooling for profiling Haskell these days?
06:56:02 <Athas> Pure +RTS -p is useless, but I remember there was stuff around to make sense of it.
06:56:59 <merijn> Athas: Which GHC?
06:57:15 <Athas> merijn: 8.8.1.
06:57:19 <merijn> You can use speedscope, but 1 of the 3 views is wrong unless you use mpickering's stuff in 8.10
06:57:29 <merijn> Athas: https://www.speedscope.app/
06:58:09 <merijn> You can use -pj to get JSON to feed to it
06:58:29 <Athas> Oh cool, that looks nifty.
06:58:43 <merijn> There's also profiterole and some other stuff
06:58:59 <Athas> Yeah, that name rings a bell.  I think I used that the last time around.
06:59:14 <merijn> Athas: See also https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html if you can test with 8.10
07:01:20 <Athas> I think profiterole is my go-to this time around.
07:01:32 <Athas> I also have a soft spot for ndmitchell tools.
07:02:49 <merijn> Athas: I found the basic speedscope support in 8.6 was already quite decent at finding simple hotspots
07:04:44 <jlamothe> Anyone here with experience using the ncurses package?
07:05:19 <jlamothe> For some reason, colour doesn't appear to be working?
07:05:58 <jlamothe> s/\?/\./
07:08:31 <jlamothe> Code I'm working with is at https://github.com/mtlstats/mtlstats (wip branch, src/Mtlstats.hs initState function)
07:11:08 <merijn> jlamothe: ncurses (in general, not just haskell) is notorious for having a tricky and painful API. Is using something like vty not an option?
07:12:53 <jlamothe> merijn: Unfortunately, no. I'd have much preferred brick.
07:13:08 <jlamothe> ...but the client runs Windows.
07:13:18 <merijn> oof
07:13:21 <[exa]> oh my
07:13:23 <merijn> ncurses on windows
07:13:29 <merijn> jlamothe: All i can say is godspeed :)
07:13:31 <[exa]> jlamothe: you may want to fake the TERM then
07:14:37 <[exa]> jlamothe: half of ncurses purpose is that it avoids sending control sequences that the terminal can not handle, which depends quite a bit on communicating the type of terminal
07:14:55 <jlamothe> I know ncurses is a pain in the ass on Windows, but it should at least be posdible.
07:15:02 <[exa]> jlamothe: which, in turn, fails notorically for even very simple cases, esp. on windows.
07:15:07 <[exa]> s/cases/reasons/
07:17:08 <jlamothe> Would there be a better underlying library to use?
07:17:37 <jlamothe> At thid point, swapping out will be a PITA, but not impossible.
07:17:41 <[exa]> not sure, very probably not
07:18:41 <jlamothe> I've tried to keep business logic as platform independent as possible.
07:19:07 <[exa]> I know this is not going to sound motivating, but you might want to look at the complexity of the terminal stuff "behind" ncurses... which also kindof explains why there are no similar libs
07:21:53 * hackage vformat 0.10.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.10.0.0 (gqk007)
07:22:05 <jlamothe> I guess I could modify it to run on brick, and run the whole thing under vagrant.
07:22:16 <jlamothe> I just hate to do that.
07:23:17 <shafox> I have installed ghcup and with it I have installed 8.8.2, cabal-install. Now if I do  cabal update, cabal install Cabal cabal-install, getting error like: https://gist.github.com/shadow-fox/334f29dd608a8485839bbfbd604d3220
07:26:40 <merijn> shafox: Have you run "cabal update"?
07:27:02 <maerwald> the error is correct
07:27:11 <maerwald> you can't install cabal-install for now
07:27:32 <maerwald> you can try 'cabal install --allow-newer=base cabal-install', but that will lead to a compile error
07:27:51 <maerwald> there should be a new release soon that will work with 8.8.2
07:28:32 <maerwald> s/build/work/
07:28:40 <maerwald> err, you get what I mean... cabal still works
07:29:42 <int-e> Apparently there's been a major version bump for template-haskell
07:29:53 <maerwald> or install from https://github.com/haskell/cabal/tree/cabal-install-v3.0.1.0-rc4
07:30:52 <int-e> Err I'm looking at the wrong things, ignore me please.
07:40:44 <int-e> Yeah, the hackage version of cabal-install isn't updated for the new base yet (which drops `fail` from Monad so it breaks quite a lot).
07:44:50 <int-e> And I'm tempted to suggest sticking with ghc-8.6.5.
07:45:30 <merijn> I always try and lack GHC releases by half a year or more unless there's a feature/bugfix I urgently need :p
07:45:59 <merijn> Although I heard 8.8 is considerably faster than 8.6, so that's appealing...
08:04:10 <sicklork1n> merijn: 'cause of nonmoving gc merge?
08:04:22 <merijn> sicklork1n: No, faster as in at compiling
08:04:33 <merijn> also, the nonmoving GC is likely slower than the moving one
08:05:11 <sicklork1n> I know generics can 'cause super slow build times
08:08:46 <merijn> sicklork1n: Basically, unless you know specifically why you need the non-moving GC and why it's faster for you, the safe default is to assume that it will *not* be faster
08:10:22 <mniip> >GHC’s runtime linker no longer uses global state.
08:10:32 <mniip> that's a big one
08:10:44 <merijn> mniip: THat sounds like it'd explain much faster compiles, yeah
08:11:01 <mniip> nah I'm talking about something completely different
08:11:17 <maerwald> I think I feel into a type-level programming trap. My API is leaking details and every attempt to fix it makes it more complicated
08:11:24 <mniip> I've been having issues with ghc's linker in the past when embedding ghc as a haskell scripting engine in an application
08:11:42 <merijn> maerwald: I could've told you that about any form of "type safe" paths, tbh :)
08:12:06 <maerwald> I figured I want type families for path casting and stripping prefixes too
08:12:10 <maerwald> now everything is complicated
08:12:14 <int-e> "type-level programming trap" feels redundant.
08:14:00 <mniip> aww
08:14:10 <mniip> the 8.10 changelog doesn't mention my new flag
08:14:44 <maerwald> then: is "relative path" a superset of filename or must it exclude it? If it excludes it, you still want APIs that don't care about that distinction, but care about "this is not absolute"
08:15:14 <sicklork1n> Oh this was killing me, looks like it got fixed.. weeeeee https://gitlab.haskell.org/ghc/ghc/issues/11991
08:15:39 <sicklork1n> wait that's not the tic
08:16:02 <maerwald> merijn: Filename on type level is useful though. Tar for example at some stages relies on things being filenames (as returned from getDirectoryContents)
08:16:14 <mniip> sicklork1n, type families have issues
08:16:19 <mniip> as does System FC in general
08:16:27 <merijn> maerwald: Or...you just handle the exception :p
08:16:33 <maerwald> too easy
08:16:33 <merijn> maerwald: It's also pointless, tbh
08:16:51 <merijn> maerwald: Relying on the type level encoding of a path being a file is a TOC-TOU race
08:16:53 <sicklork1n> mniip: oh was that the issue - it wasn't clear before
08:17:02 <maerwald> merijn: no no, not a file, a filename
08:17:11 <maerwald> a filename can be a directory
08:17:25 <mniip> sicklork1n, the issue is accumulating coercions when reducing type families
08:17:28 <maerwald> the 'path' lib encodes file vs directory, I don't
08:18:31 <sicklork1n> mniip: https://gitlab.haskell.org/ghc/ghc/issues/17223 ?
08:18:34 <mniip> every time a type family is reduced by the typechecker, the elaborator records the fact by adding a respective coercion/cast somewhere
08:21:39 <mniip> let me try to find the underlying ticket
08:22:53 <sicklork1n> mniip: 15703 was what I ran into
08:26:34 <mniip> sicklork1n, https://gitlab.haskell.org/ghc/ghc/issues/8095
08:28:17 <sicklork1n> 30k lines and it takes >30mins to compile with O2
08:29:34 <merijn> sicklork1n: Are you sure you need -O2?
08:29:43 <merijn> -O2 is generally adviced against
08:30:46 <sicklork1n> How about O11?
08:31:31 <sicklork1n> I will try O1 
08:31:42 <merijn> sicklork1n: Cabal (and the GHC user guide, I think?) recommend using -O1, since -O2 makes compilation *much* slower and doesn't provide much additional speed except some specific cases
08:33:14 <sicklork1n> merijn: If i can be 1ms faster than my comptition to lift some instrument then it's a price i'm willing to pay.. 
08:34:05 <sicklork1n> locally I use O0 and CI takes care of prod builds so not a huge problem execpt when there are a lot of MRs
08:35:06 <mniip> heh
08:35:08 <sicklork1n> It has been at least a year and two GHC releases since I last checked my compilation opts and RTS options
08:35:25 <mniip> I can't compile our codebase with -O2 without swap
08:35:43 <sicklork1n> mniip: you need mooooore memory!
08:35:44 <mniip> (16G ram)
08:36:00 <sicklork1n> our dev machines all have 64GB now
08:36:10 <mniip> my dev machine is my laptop so
08:37:04 <sicklork1n> mniip: don't have dual mem slots?
08:37:11 <mniip> maybe getting more memory on that isn't a bad idea but I have no idea whether the motherboard has enough address lanes and this is a real concern these days
08:37:37 <sicklork1n> MSI makes a nice beast these days I think.. 
08:37:47 <mniip> this is an MSI yes
08:38:08 <mniip> also the ram slots are buried deep under the motherboard so maintenance sucks
08:48:31 <jkirch> Hello, should it be required to list a specific version in cabal files if I am using stack?
08:48:57 <merijn> jkirch: Depends, do you want people not using stack to be able to compile your library?
08:49:22 <__monty__> *Or* share the project on hackage.
08:49:26 <merijn> That too
08:50:35 <jkirch> Perfect, thank you for the quick help.
08:51:01 <MarcelineVQ> afaik you can tell stack to/howto insert verison bounds when you package using  --pvp-bounds   for sdist or upload
08:54:07 <sicklork1n> mniip: do you know of any useful set of RTS opts for compliation?
08:54:28 <merijn> sicklork1n: GHC user guide has an option on tweaking compile speed
08:54:34 <merijn> s/option/chapter
08:57:10 <sicklork1n> merijn: been there - tried a few things - no success.. I think bos had some package that took a lot of the guessing out of the process but it cant parse eventlog.. didn't take it any further
09:32:42 <mniip> shrug
09:32:51 <mniip> if anything, haskell performance is my weakness
09:33:04 <mniip> I know the theory but not the pracice
09:35:54 * hackage co-log-core 0.2.1.0 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-core-0.2.1.0 (shersh)
09:38:24 * hackage co-log 0.4.0.0 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-0.4.0.0 (shersh)
09:40:53 * hackage co-log-polysemy 0.0.1.0 - Composable Contravariant Comonadic Logging Library  https://hackage.haskell.org/package/co-log-polysemy-0.0.1.0 (shersh)
10:01:24 * hackage fadno-xml 1.1.2 - XML/XSD combinators/schemas/codegen  https://hackage.haskell.org/package/fadno-xml-1.1.2 (spopejoy)
10:14:53 * hackage fadno-braids 0.1.2 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.1.2 (spopejoy)
10:23:02 <maerwald> merijn: I found a neat trick: https://git.io/Jvkp6 1. ensures 'Any is not used, 2. expresses "can be either Fn or Rel" and 3. allows to promote Fn to Rel in the result type
10:23:33 <maerwald> and doesn't propagate up, unless your types are polymorphic
10:45:54 * hackage fadno 1.1.2 - Minimal library for music generation and notation  https://hackage.haskell.org/package/fadno-1.1.2 (spopejoy)
11:10:54 * hackage fadno-xml 1.1.3 - XML/XSD combinators/schemas/codegen  https://hackage.haskell.org/package/fadno-xml-1.1.3 (spopejoy)
11:12:24 * hackage fadno-braids 0.1.3 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.1.3 (spopejoy)
11:13:24 * hackage lzlib 0.3.2.0, lzlib 0.3.1.2 (vmchale): https://qbin.io/if-them-6zle
11:25:53 * hackage fadno 1.1.3 - Minimal library for music generation and notation  https://hackage.haskell.org/package/fadno-1.1.3 (spopejoy)
11:42:53 * hackage learn-physics 0.6.5 - Haskell code for learning physics  https://hackage.haskell.org/package/learn-physics-0.6.5 (ScottWalck)
12:28:51 <siraben> Anyone know of a way to get indentation in the writer monad? http://ix.io/27QT/haskell
12:29:01 <siraben> I can't indent the body of "while"
12:32:09 <siraben> I could fix it by adding indentation to the state parameter, which currently keeps track of gensyms, but I feel that there should be a better solution.
12:32:41 <__monty__> siraben: Explicit {;} would work I think.
12:33:15 <siraben> __monty__:  I get something like this right now; http://ix.io/27QY
12:33:37 <__monty__> Oh, you want the *output* to be indented?
12:34:00 <siraben> Yes
12:34:06 <siraben> http://ix.io/27QZ
12:35:07 <siraben> http://xion.io/post/code/haskell-printer-monad.html is nice but the author doesn't mention indentation
12:35:17 <__monty__> I don't know a better way than keeping track of the indentation level.
12:38:35 <siraben> Perhaps you're right. Oh well. I'll do that for now then.
12:38:37 <solonarv> you can use 'censor', perhaps
12:38:50 <solonarv> censor :: MonadWriter w m => (w -> w) -> m a -> m a
12:39:02 <siraben> solonarv:  How so?
12:39:54 <hseg> Hi. How do I reflect a value-level Int? Specifically, I want to write a function Int -> T (n :: Nat)
12:40:38 <solonarv> replace the 'sequence body' line with something like 'for body $ \item -> censor ("  " <+>) item'
12:41:10 <solonarv> hseg: you can't do that directly
12:41:29 <solonarv> this is solidly in the realm of dependent types, which Haskell doesn't have
12:41:50 <hseg> Right, need to go through someNatVal and the usual singleton encodings
12:43:31 <hseg> Thought I could just someNatVal . fromIntegral and pattern match on the resulting singleton
12:43:52 <hseg> but am unclear on how to bind the type-level Nat I get that way
12:44:10 <solonarv> that's because you can't: that type variable is not allowed to escape
12:44:51 <hseg> :-(
12:44:54 <siraben> solonarv:  http://ix.io/27R4
12:45:10 <siraben> It's almost working, but I get a weird space before the close paren: http://ix.io/27R5
12:45:11 <hseg> OK, so I'm stuck writing ST-style code
12:45:40 <hseg> That's OK-ish. All my occurrences of the type-level Nat are in negative position
12:46:59 <hseg> I basically have a type T (d::Nat) (r::Nat) = T (Vect r a -> a) ((Vect d a -> c) -> (Vect r a -> c))
12:47:59 <hseg> Which gets consumed by a function T -> (Vect d a -> c) -> c
12:48:42 <hseg> sorry, meant T d r -> (Vect d a -> c) -> c
12:50:41 <hseg> ... inspecting my code, I just noticed I only ever pass continuations that are polymorphic in d, so that could help a little
12:51:57 <hseg> (in fact, I only ever use products of powSumPow k l = (^k) . sum . map (^l))
12:53:23 * hackage hs-functors 0.1.5.0 - Functors from products of Haskell and its dual to Haskell  https://hackage.haskell.org/package/hs-functors-0.1.5.0 (MatthewFarkasDyck)
12:58:24 <hseg> solonarv: OK, toy example: what about choose :: Vect n a -> (d :: Nat) -> Vect (binom n d) (Vect d a) ? Am willing to give up on the Vect (binom n d) part and downgrade it to []
12:59:52 <solonarv> that '(d :: Nat) ->' thing isn't valid Haskell
13:00:05 <solonarv> I suppose it's meant to be dependent-ish?
13:00:11 <hseg> Yeah
13:00:27 <solonarv> that can probably be done with singletons
13:00:38 <hseg> I suppose I'd need to encode it as KnownNat d => Vect n a -> proxy d -> [Vect d a] or something?
13:00:58 <solonarv> sounds about right to me
13:01:19 <solonarv> s/sounds/looks/
13:02:16 <hseg> And I can't precompose this with some function Int -> SomeNat?
13:02:57 <solonarv> you can do that, actually
13:03:21 <solonarv> you just need to also *post*compose it with some function that consumes your [Vect d a] so that 'd' doesn't appear in the final result type
13:04:00 <hseg> OK...
13:04:09 <energizer> in python i can say `y = 3 if x else "3"`. is that possible in haskell or do i need to tell it what types 3 and "3" are?
13:04:43 <solonarv> energizer: it's *possible* in principle, but not very useful
13:04:57 <Rembane> energizer: It's not possible unless you create a sumtype to catch that. What do you want to do on a higher level?
13:05:00 <solonarv> because you need to find some type 't' such that '3 :: t' and also '"3" :: t'
13:05:42 <energizer> solonarv: can't it just figure t is string or integer?
13:05:55 <ChaiTRex> energizer: Of course, but expressions always have one type.
13:06:04 <hseg> solonarv: OK, so why is \x -> (let SomeNat (_ :: Proxy d) = someNatVal x in Data.Vector.Sized.length $ generate @d getFinite) wrong?
13:06:07 <zeta_0> hello there, does anyone here have experience with ghcid, i have a couple of questions?
13:06:08 <ChaiTRex> energizer: So you need to make a type that can handle both 3 and "3".
13:06:33 <hseg> energizer: Because Haskell doesn't have a type that is a subtype of both Int and String
13:06:40 <energizer> why isn't "String or Integer" an adequate type?
13:06:40 <ChaiTRex> energizer: There's probably some more idiomatic way of doing whatever you're doing, though.
13:06:46 <MarcelineVQ> zeta_0: what's the trouble?
13:06:58 <ChaiTRex> energizer: You can make a type that can hold Strings or Integers.
13:07:17 <ChaiTRex> energizer: data Whatever = I Int | S String, for example.
13:07:33 <solonarv> energizer: well, one side of the 'if' will tell it: 't ~ String', the other side will tell it 'Num t'; putting these together, we get 'Num String', which is not an *impossible* constraint
13:07:40 <solonarv> but it is not very sensible either
13:08:09 <mpickering> In reflex, how do I go from `Behavior [a]` to `[Behavior a]`?
13:08:38 <solonarv> I don't think you can do that
13:08:53 <solonarv> consider: the length of that '[a]' inside the Behavior might change
13:09:55 <energizer> ChaiTRex: if i do that, i have to declare that there is a type "StringOrInteger = ..." . once i've done that, can i say `y = 3 if x else "3"`, or will i have to also specify that y is one of those? will i also have to specify that 3 is the "Integer" part of StringOrInteger and "3" is the String part?
13:10:14 <mpickering> ok, then the actual question, how can I use a function `Behavior t a -> VtyWidget ...` with a `Behavior t [a]`
13:10:29 <ChaiTRex> energizer: Sure, let y = if x then I 3 else S "3"
13:10:59 <ChaiTRex> energizer: The type will be figured out automatically as Whatever from my definition above.
13:11:05 <energizer> ChaiTRex: ok so that answers "will i have to also specify that y is one of those?" with "no"
13:11:15 <energizer> ChaiTRex: but it answers "will i also have to specify that 3 is the "Integer" part of StringOrInteger and "3" is the String part?" with yes
13:11:52 <ChaiTRex> energizer: Since those are literal values, there are ways of avoiding specifying that last part.
13:12:14 <ChaiTRex> energizer: For example, you could define fromInteger for Whatever and 3 as a literal would be I 3.
13:12:35 <ChaiTRex> energizer: Then there's some way of having a String literal be accepted as a specific type.
13:13:07 <ChaiTRex> energizer: I think it's called OverloadedStringLiterals.
13:13:36 <solonarv> just OverloadedStrings, actually
13:13:52 <ChaiTRex> solonarv: Ahh
13:14:40 <zeta_0> MarcelineVQ: hello again, i am using ghcide for haskell ide support, but i would also like to setup ghcid to automate some tasks, like for yesod web apps development
13:14:43 <energizer> that's a special case tho -  if i'd said `y = a if x else b` (where `a` and `b` had different types) it wouldn't be able to handle this?
13:15:14 <energizer> ie i'd have to specify how to instantiate the type of y from instances of a's type and b's type
13:15:18 <ChaiTRex> energizer: Only if you make a sum type like Whatever for the types and then put their data constructors, like I and S of Whatever, in there.
13:15:59 <ChaiTRex> energizer: It can't handle just a and b of different types as branches in an if statement.
13:16:05 <zeta_0> do you guys know of a link that has instructions on using ghcid with yesod?
13:16:09 <ChaiTRex> energizer: You have to make them the same type.
13:16:33 <ChaiTRex> energizer: Sum types are just a way of doing that.
13:19:43 <energizer> are there type systems that would be able to just figure it out?
13:21:10 <MarcelineVQ> zeta_0: idk about that specifically but if your project is using yesod then ghcid should be able to just the same, ghcid's purpose is to typecheck a project as you make changes, if a project builds already then ghcid should have no trouble building it as well
13:21:32 <energizer> for example 'pytype' takes `lst = ["3", 3]` as List[Union[str, int]]
13:22:14 <ChaiTRex> energizer: Sure, you can make a type system that's looser.
13:22:27 <energizer> ChaiTRex: no i don't mean looser
13:23:26 <solonarv> yes, you do mean looser. a looser type system is one that accepts more programs.
13:23:30 <hseg> Still stuck. How do I go from a function KnownNat n => T to a function Int -> T? (n unmentioned in T)
13:24:11 <energizer> solonarv: in that case, sure it's looser, but that's not what i'm getting at
13:24:23 <ChaiTRex> energizer: Python essentially uses the sum type solution I talked about. It stores the type with the value. To really tell the value of an element in a List[Union[str, int]], you have to check the type stored with the value.
13:24:43 <MarcelineVQ> zeta_0: iow, what have you tried to do and what was the issue you found?
13:25:10 <ChaiTRex> energizer: You can't just assume that the first element of the list is a string, you have to check each time.
13:25:37 <ChaiTRex> energizer: This is similar to a sum type. You have to pattern match in Haskell to do different things depending on the type of the value.
13:26:46 <solonarv> hseg: assume 'f :: forall n. KnownNat n => T', then '(\n -> case someNatVal n of SomeNat (Proxy :: Proxy n) -> f @n) :: Integer -> T'
13:27:42 <hseg> Ah. Was trying to match in where clauses, got stuck
13:27:44 <hseg> Thanks
13:27:57 <maerwald> https://git.io/JvIvs I was so close
13:28:24 <zeta_0> MarcelineVQ: ok, yeah, i was reading online that ghcid can also be used to automatically refresh a web browser with the compiled changes after saving, this seems very useful: i am am currently reading these 2 links: https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html https://binarin.ru/post/auto-reload-threepenny-gui/
13:28:58 <energizer> ChaiTRex: suppose the next line is `print(repr(y))`. int and str both know how to repr() themselves (that's the debugging printable representation). but in haskell i have to do more work to tell it how to make y out of `a` and `b` even though they'd each be fine as is
13:30:05 <ChaiTRex> energizer: Since both Int and String implement Show, you can derive Show for a sum type. You'd get it printing out I 3 or S "3", I think.
13:30:29 <zeta_0> MarcelineVQ: i also found this link as well, i think i just need to make of couple of changes to these examples for yesod: https://github.com/haskademy/haskell-projects/blob/master/proj-web/Makefile#L1-L2
13:30:46 <ChaiTRex> energizer: It would be data Whatever = I Int | S String deriving (Show, Eq, Ord) or whatever typeclasses you want that can be derived automatically.
13:31:43 <zeta_0> MarcelineVQ: i have ghcide working really good, but i just installed ghcid recently, so i am trying to understand how it works
13:31:49 <ChaiTRex> @let data Whatever = I Int | S String deriving (Show, Eq, Ord)
13:31:51 <lambdabot>  Defined.
13:31:55 <ChaiTRex> > I 3
13:31:57 <lambdabot>  I 3
13:32:09 <ChaiTRex> energizer: See, it knows how to print I 3.
13:33:02 <ChaiTRex> > if True then S "3" else I 3
13:33:04 <lambdabot>  S "3"
13:33:42 <energizer> ChaiTRex: i still have to specify S vs I, even though there are only two options and it already knows how to Show either of them
13:34:02 <ChaiTRex> energizer: You do when you're making the value, but not when you're showing it.
13:34:25 <hseg> OK, so I can push out the reflection to the user code. Now just need to figure out how to do my term-level computations at the type level...
13:34:45 <ChaiTRex> > let y = I 3 in show y
13:34:47 <lambdabot>  "I 3"
13:35:18 <ChaiTRex> energizer: See, show doesn't need you to tell it what kind, that's decided by you when you made the value however long ago you made it.
13:36:20 <energizer> ChaiTRex: i still have to decide at some point, even though it already knows how to handle both of the options
13:36:38 <ChaiTRex> energizer: Yes, you'll have to decide at one point, that's true.
13:37:37 <maerwald> hmm, instance resolution doesn't seem to work well with DataKinds?
13:38:00 <energizer> ChaiTRex: i am curious if there's a fancy type system out there that doesn't require me to decide
13:38:01 <maerwald> I did hope it would be able to infer there is an instance based on the Kind :>
13:38:40 <MarcelineVQ> zeta_0: iiuc it watches any files (such as modules) listed in your cabal file and runs the given command when they change,  e.g.   ghcid -c "cabal repl"  will run  cabal repl
13:38:41 <solonarv> energizer: there is, I think purescript and/or typescript have that sort of union type
13:38:47 <ChaiTRex> energizer: Yeah, type systems that store types alongside values at runtime can do stuff like that. Haskell generally does type erasure for efficiency.
13:39:28 <ChaiTRex> energizer: For example, if you put 3 in Python, that's going to be stored as not just the value 3, but the type integer or whatever right alongside it so that Python can later interpret it.
13:39:59 <ChaiTRex> energizer: Without that, it doesn't know what kind of data it's dealing with.
13:40:20 <remexre> ugh, why isn't GHC.TypeLits.Nat Show
13:40:29 <remexre> wait
13:40:31 <remexre> nvm
13:41:35 <Lears> You can probably write a dependent ifThenElse, but I'm sure it's more trouble than it's worth. Tbh you should just apply show/print where appropriate; there isn't much use for a union type of "anything that can be made a string" when you can just use strings in the first place.
13:41:59 <hseg> Ugh... this is really not the right place to put the term/type boundary. Had Int -> Int -> T with precompositions permitting computation of one parameter from the other. Unclear how to recapture that now that I've moved to (KnownNat d, KnownNat r) => T d r 
13:42:31 <zeta_0> MarcelineVQ: thanks for the information, i need to experiment with ghcid some more
13:43:17 <ChaiTRex> energizer: Languages that use type erasure, on the other hand, have to know at compile time what types things are going to be because they're not going to be able to figure it out at runtime.
13:44:31 <ChaiTRex> energizer: A sum type is a way of saying "yes, I do want to store the type at runtime, even though that's a bit inefficient".
13:45:27 <hseg> (especially since in some cases the computation is a little involved -- have functions d, b, so that need to satisfy so n = mkLie n (floor n/2); d l = mkLie (2l) l; b l = mkLie (2l+1) l)
13:46:34 <ChaiTRex> energizer: The language still has to know which sum type you're using, like it has to know you're using Whatever, at compile time, but it can push the exact branch, I or S, to runtime.
13:47:00 <hseg> ... Guess I *could* just CPSify the functions involved, which would permit moving the term/type barrier inwards
13:47:04 <energizer> ChaiTRex: the sum type as you wrote it seemed pretty mechanical? if we wanted, the compiler could just write it automatically, right?
13:48:04 <ChaiTRex> energizer: I don't know of a way to do that. I've always written them out by hand.
13:48:15 <ChaiTRex> energizer: You could probably pretty quickly write a code generator.
13:49:20 <ChaiTRex> energizer: The deriving part above does write parts like the Show instance, though.
13:49:25 <energizer> ChaiTRex: and likewise it could write the code to build `y` using that sum type at compile type
13:49:26 <monochrom> Everything seems mechanically repeatable after after you master it.
13:49:42 <monochrom> It's why mathematicians keep saying "Proof: Obvious."
13:50:35 <energizer> compile time*
13:51:01 <ChaiTRex> energizer: Do you mean combing through Haskell code to turn 3s into I 3?
13:51:59 <energizer> ChaiTRex: turn `if True then "3" else 3` into `@let data Whatever = I Int | S String deriving (Show, Eq, Ord)` and `if True then S "3" else I 3`
13:52:28 <solonarv> sure, that *could* be done
13:53:07 <monochrom> I would also s/that/*that*/
13:53:14 <ChaiTRex> energizer: Sure, with some effort, but it would be better to make something more idiomatic rather than trying to write Python in Haskell.
13:53:28 <solonarv> but usually, when you write 'if p then x else y' and x and y aren't the same type, that is a sign that you've made a mistake somewhere
13:53:45 <solonarv> and so rather than bending the types into knots it is better to report an error
13:53:54 <monochrom> Because what about "if True then 3 else 3" becoming "data X = A Int | B Int" and "if True then A 3 else B 3".
13:54:33 <energizer> monochrom: what about it?
13:54:54 <monochrom> Should the computer be so "smart" as to do it for you?  "for you"?
13:55:34 <energizer> solonarv: that seems like it'd apply anywhere there's a sum type
13:55:35 <monochrom> I'm trying to do a slippery slope towards GWIM
13:55:58 <solonarv> energizer: sure, that does apply anywhere you want the compiler to magically generate just the right sum type.
13:56:42 <energizer> i dont see the magic. the sum type derives whatever its components have in common
13:59:21 <monochrom> Also what do you have to say about the receiving end of this? 
14:00:09 <energizer> the receiving end can call any supported functions, for example Show
14:00:27 <energizer> (in that example )
14:00:43 <monochrom> Show actual code?
14:00:57 <ChaiTRex> energizer: Sure, but there aren't many functions that are going to be autoderivable.
14:01:08 <ChaiTRex> energizer: deriving only works with some typeclasses.
14:01:25 <koz_> What do I need to turn a package.yaml into a cabal file again?
14:01:27 <monochrom> Actually, correction: show actual type sig?
14:01:36 <ChaiTRex> energizer: If you're only going to use this for a few functions in those typeclasses, great, but otherwise, you have to write functions that handle your sum types properly.
14:02:53 <monochrom> koz_: Does stack have a command for that? Or is it what hspec does?
14:03:23 <koz_> monochrom: I'm actually unsure. Never had to deal with this before, lol./
14:05:03 <energizer> interesting chat, thanks all. cheers :)
14:05:44 <koz_> monochrom: Ah, I need hpack. OK, thanks.
14:06:03 <monochrom> Oops
14:06:17 <koz_> Yeah, hspec does something slightly different.
14:06:31 <koz_> And Haskell has a lot of packages starting with 'h'. Sometimes to hilarious effect.
14:06:35 * koz_ looks at 'hurl'.
14:06:45 <monochrom> I misremember the name.
14:09:31 <ChaiTRex> energizer: No problem.
14:10:11 <maerwald> koz_: rust ecosystem has better names
14:10:56 <maerwald> like lsd
14:11:05 <koz_> maerwald: Lol.
14:11:10 <monochrom> haha
14:11:18 <koz_> maerwald: What does this package do?
14:11:37 <maerwald> it's ls with icons
14:11:48 <koz_> maerwald: ...
14:11:59 <monochrom> I like the crustacean-themed names though.
14:12:40 <monochrom> https://github.com/Peltoche/lsd
14:28:07 <hseg> ... Why can't Haskell disambiguate function references based on type? e.g. have Prelude.sum :: Num a => [a] -> a and Data.Vector.sum :: Vector a -> a in scope. Why doesn't GHC realize sum [1,2,3] should be Prelude.sum, while sum (fromList [1,2,3] :: Vector Int) should be Data.Vector.sum?
14:28:24 <koz_> hseg: Because Haskell doesn't do overloading.
14:28:26 <koz_> (at all)
14:28:32 <hseg> ... why?
14:28:46 <hseg> bc we have typeclasses?
14:28:47 <koz_> hseg: Because Haskell handles ad-hoc polymorphism via type classes exclusively.
14:29:28 <hseg> OK
14:29:43 <koz_> The whole motivation behind type classes was making ad-hoc polymorphism... less ad-hoc.
14:29:54 <koz_> There was a Wadler paper on this topic if memory serves.
14:30:21 <hseg> As for my particular example, odd that GHC doesn't pick up on the fact that Data.Vector.sum is just a specialization of Foldable.sum and shut up about the ambiguity
14:30:30 <monochrom> Just don't bring Data.Vector's sum into scope.  Use Prelude's, because it is now:
14:30:34 <koz_> hseg: Again, this requires type-directed overloading.
14:30:34 <monochrom> % :type sum
14:30:34 <yahb> monochrom: (Foldable t, Num a) => t a -> a
14:30:38 <koz_> Which we don't have.
14:31:06 <monochrom> t can be [] or Vector, both are Foldable instances.
14:31:41 <hseg> OK. Still, annoying that vector-sized exports the specialized sum when Prelude's reexport of Foldable.sum is sufficient
14:32:02 <koz_> hseg: vector-sized tries to follow vector's API inasfar as possible.
14:32:10 <koz_> Also, there are vector types which aren't Foldable.
14:32:19 <koz_> (Data.Vector.Unboxed.Vector for example)
14:32:29 <solonarv> all these modules are meant to be imported qualified, anyway
14:32:39 <koz_> And should be.
14:32:47 <koz_> (disclaimer: I am a co-maintainer of vector-sized)
14:33:11 <hseg> Oh well. Given that I'm not using unboxed vectors anyway, might as well just import what I need.
14:33:17 <hseg> Better discipline anyway
14:33:20 <monochrom> I think that would be s/disclaimer/authority/ :)
14:33:39 <koz_> monochrom: Good point.
14:33:54 <koz_> hseg: If you're using unboxed vectors, monochrom's advice on use of Foldable is _totally_ not helpful.
14:34:04 <koz_> Since unboxed vectors (sized or not) can't be... pretty much anything.
14:34:11 <koz_> (Functor, Foldable, etc are all out)
14:34:30 <monochrom> Legacy and cries for backward compatibility imply that no one dares to shrink an API even when new better options exist.
14:34:54 <monochrom> vector's sum came from before Foldable became cool.
14:35:17 <koz_> monochrom: I agree in general. But unboxed vectors can't be Foldable, so in this case, there isn't a lot we can do.
14:35:38 <koz_> And yanking that out of the _non_-unboxed vectors requires a pretty big redesign of how the vector API works.
14:35:43 <monochrom> Likewise for quite a bit of overlap between some Data.Map functions and Foldable again.
14:35:44 <koz_> (since it all flows from Generic)
14:36:16 <koz_> (well, Data.Vector.Generic, I should specify)
14:36:19 <monochrom> Heck, it even has a specially-typed function that overlaps with fmap
14:37:24 <hseg> koz_: Isn't there a way for Foldable to permit unboxed instances?
14:37:30 <koz_> hseg: No.
14:37:48 <koz_> Because Foldable has kind Type -> Type, and anything unboxed vector requires an Unbox constraint on its elements.
14:37:48 <monochrom> Unless you revamp Foldable to be a multi-param type class.
14:37:51 <koz_> Which Foldable cannot state.
14:37:58 <hseg> ... dammit
14:38:01 <koz_> Storable vectors suffer from the same problem.
14:38:37 <hseg> So basically, we have several types that would be instances of analogues of standard classes in subcategories of Hask?
14:38:44 <monochrom> But if you do that, you also cover "why don't ByteString and Text enjoy Foldable too???!!!" :)
14:39:01 <hseg> e.g. Set being a functor over types that are instances of Ord?
14:39:42 <monochrom> Neato, Foldable should have really been a 2-param type class, or a type family thing!
14:40:15 <hseg> So basically, in order to get all the standard container types to be instances of all the classes they intuitively belong to, we'd need MPTC and ConstraintKinds in the Report, as well as a redefinition of the hierarchy.
14:40:52 <hseg> Not going to happen, I suppose. And a parallel hierarchy hasn't gained traction yet.
14:42:00 <koz_> hseg: I think mono-traversable and its ilk have something similar to that.
14:42:24 <monochrom> Disclaimer: monochrom has nothing to do with mono-traversable!
14:42:49 <hseg> :D
14:43:12 <koz_> monochrom: Because then, you'd be mono-chrom.
14:43:16 <monochrom> But yeah mono-traversable does that.
14:43:37 <hseg> Yeah, but I was thinking more along the lines of what constrained-monads is doing
14:59:15 <hseg> Having some trouble porting some list code to work with sized-vectors.
14:59:46 <hseg> Toy example: Trying to port choose :: [a] -> Int -> [[a]]
15:00:15 <hseg> (so it now has type :: KnownNat d => [a] -> [Vector d a])
15:00:41 <koz_> hseg: What are you trying to do?
15:00:43 <koz_> I might be able to assist.
15:00:44 <hseg> Problem is my original code pattern-matches on the passed integer
15:01:13 <hseg> choose xs d should give all d-tuples in xs
15:01:28 <hseg> (no replacement, so d-element subsets)
15:01:41 <koz_> hseg: You would have to natVal a proxy.
15:01:50 <koz_> Since you'd have to know what d is at runtime.
15:01:57 <koz_> s/proxy/Proxy./
15:02:16 <hseg> ... so I'd need to reify, then re-reflect a type-level natural?
15:02:38 <koz_> hseg: Unfortunately, Haskell has type erasure, so in general, we can't pattern-match on Nats.
15:02:58 <koz_> I believe singletons may have some way of doing this, but without that, the best thing we've got is natVal a Proxy.
15:03:28 <hseg> Ugh. The more I code in haskell, the less I think it's suitable for doing math in. :(
15:05:09 <koz_> hseg: Unfortunately, Haskell doesn't have dependent types.
15:05:21 <koz_> Singletons kinda-sorta gives us this.
15:05:53 <hseg> Yeah. Am surprised at the extent to which algebra needs dependent types
15:06:07 <hseg> not much, but still a significant amount
15:06:18 <hseg> s/significant/non-negligible/
15:07:28 <hseg> also, typeclasses don't quite capture what a mathematician means when they say "this construction is an instance of this structure"
15:08:19 <koz_> hseg: Sorry to disappoint. :(
15:08:49 <hseg> it's ok. at least it's developing my intuitions of what I'm looking for
15:10:21 <hseg> and it's not that bad, it works in 90% of the cases
15:10:31 <solonarv> "you'd have to know what d is at runtime" - yes, KnownNat is technically enough for that
15:10:50 <solonarv> but it is cumbersome to actually use that way
15:11:12 <koz_> solonarv: You can't pattern match on Nats directly. Even if they're Known.
15:11:17 <solonarv> indeed
15:11:23 <solonarv> hence: cumbersome
15:11:37 <hseg> ... actually, checking my code again, can avoid pattern matching on the Nat
15:12:06 <hseg> Just need to be able to call the function with the predecessor of the Nat I want
15:12:19 <hseg> And that should be inferrable, unless I'm mistaken
15:12:52 <koz_> hseg: Yes, but you'd need something like typelits-witnesses for when you hit your base case.
15:13:02 <koz_> Or rather, for _detecting_ when you hit your base case.
15:13:17 <solonarv> pattern NatS :: KnownNat n => (n >= 1, KnownNat m, n ~ m + 1) => Proxy m -> Proxy n; pattern NatS -- TODO
15:14:07 <solonarv> pattern NatZ :: KnownNat n => (n ~ 0) => Proxy n; pattern NatZ <- (natVal -> 0) where NatZ = Proxy
15:14:30 <hseg> ... what's wrong with http://ix.io/27RF ?
15:14:35 <solonarv> hm, might need some more magic in there as well
15:14:54 <solonarv> if it works, nothing
15:15:02 <solonarv> I was just demonstrating how one might pattern-match on Nat
15:15:20 <koz_> hseg: Ah, you're going with natValing a Proxy.
15:15:29 <koz_> Then I think you'll be OK.
15:15:40 <hseg> Yeah, except GHC is complaining d isn't in scope
15:15:49 <koz_> hseg: ScopedTypeVariables.
15:15:56 <hseg> Is on
15:16:22 <koz_> hseg: You need to have choose :: forall d a . (KnownNat d) => [a] -> [Vector d a]
15:16:30 <koz_> You gotta forall any typevars you want to scope.
15:16:57 <hseg> Right
15:17:33 <hseg> Hrm. Can't just use the [x | p] idiom where p needs to be destructed for evidence. Shame
15:18:20 <koz_> (I recommend the d a order, because then TypeApplications can be used to 'fill in' what d should be without having to manually specify a or use snails)
15:18:31 <solonarv> you can, example: [ x | Just Refl <- sameNatVal m n ]
15:18:32 * koz_ thinks back to something he wrote for Finitary which was a giant train of snails.
15:18:49 <koz_> s/Finitary/finitary/
15:18:51 <solonarv> now, I don't know if that works for your use case, but it's certainly possible
15:19:34 <solonarv> oh, but the equality brought into scope by the 'Refl' pattern match won't actually be available in 'x', I think?
15:19:55 <monochrom> Just r@Refl :)
15:20:04 <monochrom> Or even Just r
15:20:18 <solonarv> how does that help?
15:20:30 <monochrom> r is in scope now
15:21:02 <hseg> Yeah, that doesn't work
15:21:21 <solonarv> the problem isn't 'r' being in scope, it's the 'm ~ n' constraint being in scope
15:21:49 <hseg> punting on this for the moment, the second line seems to not do what I want, either
15:22:03 <monochrom> castWith r
15:22:49 <solonarv> yes, that might work
15:22:52 <hseg> Would've thought GHC would infer that since map (cons x) (choose xs) ++ choose xs :: Vector d a and cons x :: Vect (d-1) a -> Vect a, the two calls to choose occur at different d indeces
15:23:06 <hseg> but GHC seems to unify the d indeces.
15:25:58 <koz_> hseg: It's because GHC doesn't understand the laws of arithmetic on Nats.
15:26:08 <koz_> There's a plugin or two you can grab to (partially) fix this.
15:26:12 <koz_> But it doesn't always work.
15:26:40 <erikd> that is sad
15:26:55 <koz_> erikd: Not an ideal situation, I agree.
15:27:22 <erikd> and it is exactly the problem i have at the moment
15:27:48 <hseg> Oh FFS. "Couldn't match type ‘d’ with ‘1 + (d - 1)’"
15:28:00 <koz_> hseg: Perfect example.
15:28:12 <koz_> You know that 1 + x - 1 = x for all x \in N.
15:28:14 <koz_> But GHC doesn't.
15:28:30 <solonarv> also, that equality doesn't actually hold when d = 0
15:28:34 <hseg> Right
15:28:35 <koz_> You want http://hackage.haskell.org/package/ghc-typelits-knownnat and hackage.haskell.org/package/ghc-typelits-natnormalise
15:28:39 <koz_> solonarv: Good catch.
15:28:45 <monochrom> >_<
15:28:48 <koz_> Those might help.
15:29:01 <solonarv> don't give me too much credit: I am just repeating what I saw in the docs of ghc-typelits-natnormalise earlier
15:29:17 <monochrom> type-level numbers in haskell is a deep rabbit hole
15:29:29 <hseg> Dammit. Why is this so hard?!
15:29:30 <solonarv> you need to pass it an extra flag to make it solve d ~ 1 + (d-1), because that can be unsound
15:29:46 <monochrom> because haskell is not dependently typed
15:29:56 <koz_> hseg: Because, as I said, GHC doesn't have dependent types, and GHC doesn't have natural number arithmetic laws wired in.
15:30:08 <monochrom> every time someone says "I know how to encode this" it is going to be a chore.
15:30:20 <hseg> Yeah, this is gonna suck
15:31:07 <hseg> And ~500LoC in, I'm not about to start hunting around for a different language
15:31:33 <hseg> ... though I'm pleasantly surprised I've managed so much in that little 
15:31:39 <monochrom> To be fair, in a dependently typed language, you would be submitting a proof for algebra identities so you could use them.
15:32:03 <hseg> Well, in a dependently typed language, I'd expect the Prelude to contain these proof
15:32:06 <hseg> proofs
15:32:57 <monochrom> In practice yes for well-known arithmetic theorems. But consider one day you define your own data type and you need to use some "obvious" theorems.
15:33:03 <hseg> Hrm. OK, maybe if I case-analyse the Nat index and the list simultaneously, I'll have enough evidence to convince GHC
15:33:48 <hseg> Wait. How do I upgrade d~0 to Vector d a ~ Vector 0 a?
15:34:33 <solonarv> that, GHC should figure out on its own
15:35:22 <hseg> Well, GHC is complaining that it expected a Vector d a :~: Vector 0 a when I pass a d :~: 0
15:35:38 <solonarv> oh, I see
15:36:29 <solonarv> suppose you have 'eq :: d :~: 0', then you can write 'case eq of Refl -> Refl :: Vector d a :~: Vector 0 a'
15:37:03 <solonarv> iow: pattern-match on the 'd :~: 0' and pass 'Refl' for the 'Vector d a :~: Vector 0 a'
15:38:44 <hseg> Ah. OK, so I need to manually upgrade the proof myself
15:40:39 <monochrom> Another way (pretty much compiles to the same code) (also I haven't tested it):  apply (apply Refl eq) Refl
15:41:13 <monochrom> in which the 1st Refl is Vector:~:Vector and the 2nd is a:~:a
15:41:40 <monochrom> "apply" is in Data.Type.Equality.  (similarly "castWith" I mentioned earlier.)
15:41:56 <MarcelineVQ> has it been asked what the task is that even needs this route
15:42:11 <monochrom> vectors with type-level size tracking
15:42:26 <monochrom> package name vector-sized
15:42:30 <MarcelineVQ> No I mean the level above that one
15:42:44 <MarcelineVQ> What is being worked towards
15:42:45 <monochrom> I think no
15:43:27 <MarcelineVQ> "<hseg> Yeah. Am surprised at the extent to which algebra needs dependent types" made me wonder
15:44:02 <MarcelineVQ> hseg: What is the goal you're working towards with your explorations?
15:44:06 <hseg> Am implementing the Weyl integration formula for some classical groups
15:44:59 <monochrom> that one was for type-level "1+d-1 = d" because your vector grows by 1 then shrinks by 1 (or the other order)
15:45:28 <hseg> So I need to take multivariate integrals over the unit circle, want to make sure I'm getting passed functions of the right dimensionality
15:49:09 <hseg> OK, so with these I've managed to reduce my problem to showing sameNat (Proxy @d) (Proxy @0) = Nothing implies 1<=?d ~ True
15:50:03 <hseg> How tf do I do that?
15:50:25 <grumpyvegetable> Would the book "Functional Programming and Parallel Graph Rewriting" be about the closest I can get to a compiler implementation book that uses Haskell?
15:50:40 <grumpyvegetable> I've heard it uses CLEAN as the language but heard it's very similar to Haskell.
15:50:51 <hseg> Alternatively, is there a way I could pattern match on whether 1<=?d ~ True?
15:52:23 <monochrom> I think some of those type families in GHC.TypeNats will help
15:52:40 <MarcelineVQ> grumpyvegetable: dunno but check out https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/
15:53:08 <monochrom> Oh, you already know, you're using <=? already.  Then I don't know. :)
15:53:26 <hseg> Right, but I can't just case (d<=?0) of ..., right?
15:54:08 <hseg> That'd be doing type-level stuff at the term-level, which is verboten 
15:54:13 <MarcelineVQ> hseg: are you interested in proofs here or using this to make larger programs?
15:54:41 <hseg> MarcelineVQ: Making a larger program. This is an incidental proof I'm stuck writing
15:54:42 <MarcelineVQ> as in useful programs
15:56:14 <hseg> Wait! what if I try case (Proxy @(d<=?0)) of { Proxy True -> ; Proxy False } ?
15:56:58 <grumpyvegetable> Darn wish it had labels for each chapter when opening the pdf, instead of page by page.
15:57:05 <grumpyvegetable> MarcelineVQ: Thanks.
15:57:22 <grumpyvegetable> Looks like it uses Miranda. Is that closer to Haskell than the CLEAN language?
15:57:57 <hseg> OK, am getting different errors. Progress!
15:59:00 <hseg> Hrm. Expected kind ‘Proxy 'False’, but ‘Proxy @(d <= 0)’ has kind ‘Proxy (d <= 0)’
16:00:16 <hseg> Isn't case (Proxy @(d <= 0)) of { (_ :: Proxy False) -> ...; (_ :: Proxy True) -> ... } valid?
16:05:04 <hseg> OK, so http://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/docs/GHC-TypeLits-Compare.html#v:-37--60--61--63- might help...
16:06:01 <monochrom> Your *.cabal file will be huge :)
16:10:20 <hseg> :) just three deps for the typelevel hackery
16:11:41 <hseg> Unfortunately, typelits-witnesses doesn't play well with ghc-typelits-natnormalise
16:12:06 <hseg> -- don't see how to convert the evidence to a constraint of type 1 <= d
16:15:22 <monochrom> Yeah the fundamental missing piece is "either d=0 or d>0, no other possibility, d<0 doesn't happen"
16:16:24 <monochrom> type family CmpNat isn't really smart enough to know that
16:18:46 <hseg> That's a later problem. I can't even case (Proxy @(0 `CmpNat` d)) of { (_::Proxy LT) -> ...; (_::Proxy EQ) -> ...; (_::Proxy GT) -> ...}
16:19:00 <hseg> GHC complains that the proxies are of differing types
16:19:02 <nshepperd> proxy doesn't work like that
16:19:22 <nshepperd> it doesn't carry evidence
16:19:37 <hseg> OK, so how *am* I supposed to extract the evidence from CmpNat?
16:20:12 <nshepperd> use the 'cmpNat' function
16:20:36 <hseg> What cmpNat function?
16:20:46 <nshepperd> https://hackage.haskell.org/package/typelits-witnesses-0.4.0.0/docs/GHC-TypeLits-Compare.html#v:cmpNat
16:21:51 <nshepperd> cmpNat x y takes evidence about the values of x and y, and produces evidence about the value of CmpNat x y
16:23:12 <hseg> Could not deduce: (1 <=? d) ~ 'True arising from a use of ‘choose’
16:23:13 <hseg>     from the context: 'LT ~ CmpNat 0 d
16:24:06 <hseg> *headdesk*
16:25:58 <monochrom> Yeah it doesn't know 0<d implies 1<=d either :)
16:26:55 <hseg> I recall there being SAT solver plugins. A sledgehammer, perhaps, but one that'll do the job?
16:27:40 <nshepperd> hseg: i guess isLE is more appropriate in this situation
16:27:58 <nshepperd> case isLE (Proxy @ 1) (Proxy @ d) of Just Refl -> ...
16:28:22 <monochrom> Not quite SAT, but rather SMT. And in this case, you're only using the simplex-method subroutine of an SMT solver because all you have is linear inequality not arbitrary sentences.
16:28:49 <hseg> nshepperd: I need something that gives me either 0 :~: d or 1 <=? d ~ 'True
16:29:13 <hseg> nshepperd: (am using the 0 :~: d to coerce Vector 0 a :~: Vector d a)
16:29:21 <nshepperd> tbh personally I would just reflect d to the term level (as an Integer), case match on it, then unsafeCoerce the type level evidence I need in each branch
16:29:51 <hseg> fuck it, I'll do that
16:35:25 <hseg> ... and GHC complains that d is rigid
16:39:41 <nshepperd> paste your code?
16:40:35 <hseg> Latest attempt, unclean: http://ix.io/27RR
16:41:49 <nshepperd> proxies don't work like that :p
16:41:55 <nshepperd> unsafeRefl :: forall c. (c => r) -> r; unsafeRefl k = case unsafeCoerce (Dict :: Dict (a ~ a)) :: Dict c of { Dict -> k } -- what I would use
16:42:31 <nshepperd> Dict, which is from the 'constraints' package, is a type of values that carry evidence
16:43:47 <hseg> Oh, right. You need the (c=>r) part of Dict's signature in order to pull in the constraint you declare it has.
16:44:13 <nshepperd> to create evidence of 1 <= d, what you do is: 1. create a Dict of something innocuous, like 1 <= 1; 2. unsafeCoerce that Dict to Dict (1 <= d); 3. pattern match on the result
16:44:48 <hseg> ... wait, maybe if I use Dict instead of Proxy I'll be able to get the evidence?
16:46:03 <nshepperd> yes. but you also need to use `case`, not `let`
16:49:10 <nshepperd> here is the definition of the Dict type: data Dict (c :: Constraint) where { Dict :: c => Dict c }
16:49:31 <nshepperd> the Dict constructor has one argument, which is the evidence for c
16:50:47 <nshepperd> in the case of a typeclass constraint, such as when c is Num Int, that evidence would be a record containing method implementations
16:51:44 <nshepperd> compare to the definition of Proxy: data Proxy (a :: k) where { Proxy :: Proxy a }
16:53:30 <hseg> Hrm. How would I case analyse on CmpNat 0 d? I can case analyse on whether I can construct a Dict (CmpNat 0 d ~ Eq), for example
16:53:49 <hseg> but I can't get the case analysis to tell me the _value_ of CmpNat 0 d
16:54:09 <monochrom> CmpNat is a type family (type-level function) so to use its answer you write more type families.
16:55:19 <hseg> Hrm. So something like case (If (1<=d) (Dict (1<=d)) (Dict (0~d))) of ... ?
16:55:51 <hseg> ... or rather case (Dict (If (1<=d) (1<=d) (0~d))) of ...
16:57:37 <monochrom> https://aphyr.com/posts/342-typing-the-technical-interview  does it with classes.  It's probably written before type families.  Today you can do it with type families.  But the catchy saying stay true: "what happens in types stays in types".
16:57:48 <nshepperd> if by 'case analyse' you mean 'obtain information about whether 0 < d at runtime', you don't
16:57:58 <nshepperd> at least, not in the way you're thinking
16:59:32 <monochrom> If at some point you need to downcast from type to value, it will involve an existential type like SomeNat.
16:59:42 <hseg> I'm not looking for runtime information. d is a KnownNat. All I want is to extract the evidence that it's either ~0 or 1<=
16:59:45 <nshepperd> there seems to be some misunderstanding around the meaning of types like CmpNat 0 d
17:03:03 <hseg> nshepperd: I'm trying to implement the sized-vector analogue of foldr (\x acc d -> map (x:) (acc (d-1)) ++ acc d) (\d -> [[] | d ==0])
17:03:20 <nshepperd> the meaning of KnownNat is precisely that there is information at runtime
17:03:32 <nshepperd> 'KnownNat d' is just an Integer in disguise
17:03:55 <nshepperd> it's the Integer that is equal to d on this invocation
17:04:16 <hseg> OK. And I can't case-analyse on this Integer?
17:05:02 <ChaiTRex> hseg: You can write a function using type families that works like a case in the same way that f 1 = ...; f 2 = ... has multiple cases.
17:05:46 <nshepperd> hseg: you can, of course. that's what 'case natVal (Proxy @d) of ...' does
17:06:15 <hseg> nshepperd: Yes, but the evidence I get from that cannot be reflected back to the type level
17:06:52 <hseg> In particular, if I get natVal = 0, I don't know that Vector d a ~ Vector 0 a, or that if natVal > 0 that (d - 1) :: Nat
17:07:39 <nshepperd> *you* know those things
17:07:41 <nshepperd> ghc doesn't
17:07:47 <hseg> Right
17:07:51 <nshepperd> you have to tell it, using unsafeCoerce
17:08:04 <erikd> :screem-face:
17:08:14 <hseg> Looks like it
17:09:33 <nshepperd> case (natVal (proxy @d)) of { 0 -> unsafeRefl @(d ~ 0) your_branch_1;   d -> unsafeRefl @(1 <= d) your_branch_2;  }
17:11:16 <nshepperd> usually, you will want to write helper functions to do this, so your code base doesn't end up filled with unsafeCoerce everywhere
17:11:17 <hseg> ... and unsafeRefl fails an ambiguity check
17:12:09 <nshepperd> yes, that's intentional. since I think resolving the ambiguity using @ looks nicer
17:12:41 <nshepperd> but if it bothers you, you can implement it like unsafeRefl :: forall c. Proxy c -> (c => r) -> r
17:13:27 <nshepperd> and call it like unsafeRefl (Proxy :: Proxy (d ~ 0)) your_branch_1
17:14:21 <hseg> OK, it seems to be working
17:15:12 <hseg> Success
17:15:59 <hseg> Q: Any way I can write choose @n xs in operator form (eg xs `choose` @n) ?
17:16:49 <monochrom> I think no.
17:16:53 <hseg> Shame
17:17:03 <monochrom> @n isn't considered a parameter.
17:17:03 <lambdabot> Maybe you meant: nazi-off nazi-on nixon wn v @ ? .
17:17:49 <hseg> Eh, the new syntax isn't that bad
17:19:39 <pacak> Greetings fellow humans. Suppose you have a bunch of datatypes and a bunch of code that does things to those datatypes. How would you go about finding out fields that you only write to but never read from? Let's say data X = { x :: Int, y :: Int },    foo z  b= z { x = x z + b, y = b }, but x gets used later while y is not?
17:20:02 <nshepperd> as I was saying, normally you would write helper functions, so you don't end up filling your code with unsafeCoerce. typelits-witnesses is a library of such helper functions (but none of them perfectly suited to your compare-to-zero usecase)
17:21:18 <monochrom> If I evaluate "foo X{x=4, y=undefined} 40" and I get a good answer then I know y isn't used.
17:21:24 <hseg> Right. Mostly because GHC's Nat logic isn't smart enough re inequalities
17:21:26 <nshepperd> for this case, maybe the relevant function would look like 'cmpZero :: forall (d :: Nat) r. KnownNat d => ((d ~ 0) => r) -> ((1 <= d) => r) -> r'
17:22:43 <hseg> Hm. Yeah. I'd call it cataKnownNat, but looks right
17:23:04 <nshepperd> you would call it like 'cmpZero @d your_branch_1 your_branch_2' and it would encapsulate the runtime comparison and the manufacture of evidence
17:24:19 <pacak> monochrom: Sure. It's just there's 100k+ lines of code. Testing everything by hands is not very practical.
17:26:49 <nshepperd> or non-church-encoded version ' data CmpZero (d :: Nat) where { IsZero :: (d ~ 0) => CmpZero d;  NotZero :: (1 <= d) => CmpZero d };  cmpZero :: KnownNat d => CmpZero d'
17:30:14 <pacak> ghc warnings can show for some unused code, weeder and some other program can show for exported but unused code but they are not very smart about "unused part". Is there anything better out there?
17:35:55 <koz_> In the context of recusion schemes, do algebras go a -> f b, or f a -> b?
17:35:59 <koz_> I keep forgetting the order.
17:36:14 <c_wraith> the latter
17:36:27 <c_wraith> folds use algebras, unfolds use co-algebras
17:38:45 <monochrom> Actually f a -> a.  (co-algebra, a -> f a)
17:48:51 <hseg> Dammit, brittany keeps removing the space preceding a type application. Any ideas how to stop it?
18:01:54 * hackage bzip-signature 0.1.1.0 - Backpack signature for BZip compression  https://hackage.haskell.org/package/bzip-signature-0.1.1.0 (vmchale)
18:03:31 <koz_> When I do cabal new-repl with a -b argument, is there a way to specify what _version_ of the dependency I want?
18:13:37 <sm[m]> does the obvious -b PKG-X.Y not work ?
18:13:49 <koz_> sm[m]: No, it seems you need --constraint.
18:15:05 <monochrom> I saw --help giving this example: cabal new-repl --build-depends "lens >= 4.15 && < 4.18"
18:15:20 <koz_> Ah, OK. I guess I missed that lol.
18:15:23 <koz_> Good to know though.
18:15:27 <monochrom> --build-depends is also -b
18:16:09 <monochrom> There was some luck in me spotting that one amidst the text wall.
18:17:42 <sm[m]> koz_: aha
18:18:42 <MarcelineVQ> koz_: nope https://hackage.haskell.org/package/Cabal-3.0.0.0/docs/src/Distribution.Parsec.html#parsecCommaList
18:20:40 <MarcelineVQ> hmm spoke too soon, maaybbbee, but probably nooot :> gotta figure out which parser Dependency uses
18:22:07 <MarcelineVQ> maaaaybe https://hackage.haskell.org/package/Cabal-3.0.0.0/docs/src/Distribution.Types.Dependency.html#line-84
18:23:47 <MarcelineVQ> ye ok so try like cabal repl -b "containers == 3.2, foo >= 3"
18:23:53 <MarcelineVQ> since it's the same parser as in a cabal file
18:25:10 <MarcelineVQ> haha... reading, it's a skill. monochrom's way ahead on this one
18:25:23 <MarcelineVQ> Well at least I learned a bit about navigating Cabal
18:25:28 <monochrom> :)
18:26:05 <monochrom> I found out about "optimization: 2" (for $HOME/.cabal/config) by reading cabal-install source code too.
18:37:24 * hackage describe 0.4.0.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.0 (riuga)
18:38:40 <interro[m]> If you were going to learn haskell from scratch, how would you go about it?
18:39:23 <c_wraith> in what context?  If there's a mentor around, it's very different from working only with written resources and a compiler install
18:39:29 <monochrom> I learned haskell from scratch from "the gentle introduction to haskell"
18:39:30 <MarcelineVQ> I'd expect to try to learn and give up twice but get it the third time. Other than that a good text goes a long way, I quite liked haskell programming from first principles
18:40:38 <monochrom> I might have liked one of the textbooks from Hudak or Hutton or Bird too.
18:44:24 * hackage symbiote 0.0.3 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.3 (athanclark)
18:46:22 <interro[m]> c_wraith:  As for context. Well, I'm relatively new to programming. I learned Python in a CS101 class two years ago (but still can't use it to do much). I'm very proficient with tools like git and linux. I spent about five months trying to get through Haskell Programming from First Principles, and then gave up around ch13. I'm thinking of reattempting it, now, though. But I got a little tired of only or mostly reading...
18:46:22 <interro[m]> (the book is 1200 pages, and I'm meticlious). I'd really like to do a practial project, but don't know where to start.
18:47:03 <interro[m]>  * c_wraith:  As for context. Well, I'm relatively new to programming. I learned Python in a CS101 class two years ago (but still can't use it to do much). I'm very proficient with tools like git and linux. I spent about five months trying to get through Haskell Programming from First Principles, and then gave up around ch13. I'm thinking of reattempting it, now, though. But I got a little tired of only or mostly
18:47:03 <interro[m]> reading... (the book is 1200 pages, and I'm meticulous). I'd really like to do a practial project, but don't know where to start.
18:48:36 <MarcelineVQ> There's a practical project in the book :> url shortener iirc
18:49:42 <interro[m]> Found it. I'll have to read through it.
18:51:54 * hackage describe 0.4.0.1 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.4.0.1 (riuga)
18:58:31 <interro[m]> Also, do people really have mentors for this kind of stuff? The only time in my life I had assistance learning something was CS101, and then it's been self-learning from books and experimentation.
18:58:53 <interro[m]>  * Also, do people really have mentors for this kind of stuff? The only time in my life I had assistance learning something was CS101. Otherwise it's been self-learning from books and experimentation.
18:59:08 <interro[m]>  * Also, do people really have mentors for this kind of stuff? The only time in my life I had assistance learning something technical was CS101. Otherwise it's been self-learning from books and experimentation.
18:59:12 <c_wraith> I learned Haskell in a business setting.  In that environment, there's usually someone who knows the language already.
18:59:58 <koz_> interro[m]: I self-taught. Although the nice folks here have been with me pretty much from step 1.
19:00:07 <koz_> (and still are)
19:01:13 <interro[m]> Ah, that makes sense. I don't work with computers, so it's been just me. I guess maybe I should have counted IRC/Matrix. The Haskell community online has been really helpful and encouraging. :)
19:09:55 <mud> Something approaching formal mentors usually only happens in either school or work, and even then it depends. But yeah, having a community like this can really help.
19:25:24 <alc> https://www.codewars.com/kata/5443dd2d7fc4478154000ac6/train/haskell
19:25:32 <alc> I don't know what this kata want me to do?
19:25:40 <alc> write a definition for fix?
19:25:55 <Terang> bego lu alc
19:26:15 <alc> what is "bego lu"?
19:26:20 <alc> English?
19:27:11 <Terang> purely functional programming language
19:28:21 <zeta_0> hello there, i am using xmonad, which works great, but inside of any application like atom text editor or libre office, when i try to do a save as or open a file, it takes me to a blank screen?
19:28:23 <c_wraith> alc: it wants you to write functions named reverse' and foldr' such that reverse = fix reverse' and foldr = fix foldr'
19:29:53 <alc> c_wraith: so reverse x = (fix reverse') x?
19:30:03 <c_wraith> yes
19:30:39 <alc> interesting
19:30:54 <c_wraith> those parenthesis are redundant, for what it's worth
19:31:36 <alc> c_wraith: it want me to know reverse and foldr are who's fixed-points
19:32:18 <c_wraith> more generally, it's an exercise in translating explicitly recursive functions to ones that use a helper for recursion
19:32:30 <c_wraith> It's actually a pretty mechanical translation once you get the hang of it.
19:32:56 <alc> it's related to CPS?
19:32:58 <zeta_0> is there anyone in #xmonad, i don't want to be stuck waiting for hours?
19:33:32 <c_wraith> I guess you could say it's related to CPS, in some sense.
19:34:11 <alc> c_wraith: that fixed-point, CPS, anonymous recursion, those three terms always come along
19:34:14 <c_wraith> But it's not a necessary relation
19:36:56 <c_wraith> In that it's not really necessary to understand CPS to understand combinator-based recursion
19:36:58 <monochrom> alc: See my http://www.vex.net/~trebla/haskell/fix.xhtml
19:37:06 <monochrom> Also, unrelated to CPS.
19:38:06 <alc> monochrom: ok
19:39:09 <alc> I wonder that fix-point can use on what languages?
19:39:30 <alc> any languages support lambda expressions?
19:39:54 <monochrom> Any language that supports higher-order functions.
19:40:20 <alc> it means javascript and python can do, but java can't?
19:40:34 <monochrom> java has lambda too.
19:40:43 <alc> java doesn't have first-class function
19:40:45 <monochrom> C would have some trouble.
19:41:39 <monochrom> OK I've forgotten what java has.
19:41:47 <koz_> monochrom: It has anonymous classes.
19:42:04 <koz_> So lambda is just syntax sugar around that.
19:42:40 <monochrom> You can put a function as a "method" in an object, then pass that object.
19:42:54 <koz_> monochrom: Yep, what C++ calls a functor.
19:42:57 <ChaiTRex> for Java: https://levelup.gitconnected.com/implementing-recursion-with-the-y-combinator-in-any-language-9e83fa369ca
19:43:00 <koz_> (because everyone overloads that poor term)
19:43:45 <monochrom> These days it is easier to name languages that don't have higher-order functions or equivalent.
19:44:17 <monochrom> You can't use fix in BASIC.  And I am not even sure about Fortran.
19:45:46 <alc> what's the meaning to get a function's fixed-point?
19:47:37 <monochrom> I thought I explained it on my page?
19:57:27 <fog> i want to have an explicit representation of variables in scope according to a Symbol named Has () instance
19:58:00 <fog> where this scope is modifiable, as is done on reifying a new variable to scope, or garbage collecting it
19:58:32 <fog> this should be done via constraint continuations somehow
19:58:52 <fog> (Has () a => t) -> t
20:00:06 <fog> so that modifying this explicit record can record which constraint continuations are certain to be able to run as their sconstraints should have been provided on construction
20:01:11 <fog> maybe a type representing a function which returns a modified constraint continuation from an input argument would help
20:02:08 <fog> and maybe a Has () Scope
20:02:48 <fog> where then the reification function would return an updated constraint continuation
20:03:20 <fog> no only of the value of the type being reified into a Has () instance, but also the updated Scope
20:04:30 <fog> then a function can have a required Scope, all of the types of which must be contained in the Scope of the constraint continuation for it to be run in
20:04:52 <fog> allowing that the undefined Has () instance type errors that are returned by the constraints
20:05:46 <fog> can be avoided (as if they were runtime errors avoided by type safety) by the type check that the Scope is adiquate 
20:07:09 <fog> within this setup functions can be drawn from scope and have their arguments provided using type families to lookup the correct named value to retrive to supply as an argument
20:07:17 <fog> allowing eg, for let binding 
20:08:30 <fog> but where these lables include derivation at type level from the name of the position in a computation, directing the lookup of which value to use
20:09:34 <fog> basically that functions reified can have reified arguments supplied automatically by type level computation with an argument that is particular to each call
20:10:17 <fog> so by encoding positions within a program, replacing the lambda binding of variables into regular haskell scope
20:10:45 <fog> and the provision of arguments to evaluate functions by let bound variable names
20:11:25 <fog> allowing that the structure aforded by variable binding and referencing takes place at type level 
20:11:35 <fog> as an intrinsic part of the type level representation of a function
20:11:49 <fog> encoding its implementation as a type
20:12:28 <fog> so being able to check for variable names in scope as a typelevel computation
20:12:41 <fog> which is what im trying to do with this Scope reification
20:13:27 <fog> which then can prove that a function can run, basically typechecking it
20:14:04 <fog> this is pretty neat, as by encoding this using constraints, the haskell typechecker can be used
20:15:13 <fog> then the stage with the scope is that its kind of like a smart constructor that ensures that programs built with certain operations are guarantied to typecheck
20:15:33 <fog> like, we are trying to say that adding a variable into scope will allow for functions which reference it to compile
20:16:27 <fog> so there is some way to ensure properties about the resulting rpograms ability to typecheck when adding variables into the scope, which is why it keeps a record as a constraint continuation morphism
20:17:12 <fog> its then a simple type level computation to determine if the types demanded by a function defined with typelevel function implementaion
20:17:50 <fog> are available in scope, meaning this call ensures that none of the actual Constraints for what variables are in scope should ever fail
20:19:24 <fog> the power of these Scope constraint continuations modifications is that it can ask what constraints are satisfied
20:19:37 <fog> by recording them as they are reified
20:21:00 <fog> and allowing for garbage collection to remove variables from scope by refreshing are re-reifing variables to keep, when it is clear from a downstream function call which can be queried for what variables it references from scope
20:22:00 <fog> which is some kind of type level type checker garbage collector, which increases the speed of lookup of a variable from scope
20:22:09 <fog> i guess the question is if this is any faster
20:22:36 <fog> or does the typechecker already do a good job of making effecient lookup and storage because it can typecheck to see where it is used?
20:22:48 <fog> and if not, how to direct it to do so
20:22:54 <fog> which it seems this does
20:23:39 <zeta_0> i am having this issue if anyone knows the solution please comment, thanks: https://github.com/xmonad/xmonad/issues/210
20:26:37 <fog> also the type level scope annotations can be used to generate functions using a type level range over the implementations, which should be available because the functions in scopes types are visible to see which functions can be made, and typesafe opperations to construct and modify function implementations becomes possible
20:27:46 <fog> this is important when dealing with big nets
20:27:59 <fog> with type level graphs dictating their shape
20:28:11 <fog> they need to take and return functions as arguments
20:28:33 <fog> which means they need to construct nets or implementaions
20:29:06 <fog> and we can have monoidal opperations of partial function application with an input value that has Net type
20:29:20 <fog> so being able to pass functions or nets as arguments
20:30:07 <fog> allowing for the function modifying or generating process to encorperate input nets as a monoidal action
20:30:21 <fog> swapping subfunction implementations
20:30:38 <fog> as actions to update nodes 
20:32:15 <fog> where these generative processes can hopefully be built up in a way that preserves function evaluation, hence making no runtime errors in the type level computations that generate function implementations
20:33:06 <fog> as we can be sure which functions exist in scope which we can use during evaluation
20:33:51 <fog> for a classical neural net, only folding with weighted tanh is in global scope
20:34:16 <fog> and input args must be supplied by reification on evaluation
20:35:07 <fog> adding network evaluation as a function to the scope then gives networks as neurons
20:36:13 <fog> and partial function evaluation allows recursion to evauate functions if their arguments are available in scope, without the user having to write the program which does this, because the let binding is done at type level
20:36:55 <fog> basically making functions as arguments and lambda binding of named variables
20:38:05 <fog> and allowing the restriction to neurons as Doubles a straitforward type level opperation on this encoding of a primitave lambda calculus like language implemented at type level which can use the haskell typechecker via consrtaints!
20:38:51 <fog> this seems like an awesome result, where we get neural networks for free from implementing type level Scope refication machinery
20:39:18 <fog> and a nice representation for type level function implementaions following the structure of deep nets
20:40:08 <fog> a type level functional language with neural nets as a type restriction 
20:40:19 <fog> *bows*
20:46:24 * hackage hackport 0.6.3 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6.3 (solpeth)
21:07:56 <aviD> Is there a way to make a `source-repository-package` in cabal.project conditional on ghc version?
21:13:51 <oats> that was an impressive monologue
21:14:01 <oats> kind of a shame nobody answered :<
21:15:29 <monochrom> Bigger shame if someone answered.
21:16:06 <oats> hmm?
21:16:34 <monochrom> Proven track record: Somone answered in the past, that is why they are so out of touch now.
21:16:43 <oats> ah
21:16:48 <monochrom> both out of touch and still spam us.
21:17:15 <oats> oh, that's the person who's joined, sent like 2 messages, then immediately quits
21:17:45 <oats> or...
21:17:48 <oats> 50
21:25:41 <suzu> that monologue melted my brain
21:28:31 <jle`> we sort of just let fog do their thing i guess
21:28:41 <koz_> Hi jle`!
21:28:58 <jle`> koz_: hi! :)
21:30:44 <dmj`> the fog of war
21:41:51 <siraben> Can anyone write (fst . head . filter (uncurry (==)) . (zip `ap` tail) <$> iterate peephole) better? I'm writing a function that will perform the function "peephole" until the input no longer changes.
21:49:07 <amalloy> siraben: https://stackoverflow.com/q/38955348/625403 has numerous options
21:50:02 <siraben> amalloy:  Thanks, I didn't even think to use until!
21:51:40 <dmj`> siraben: I'd check out unfoldr
21:51:47 <dmj`> @src unfoldr
21:51:47 <siraben> Doesn't until (\x -> x == peephole x) peephole perform "peephole" twice, though?
21:51:48 <lambdabot> unfoldr f b = case f b of
21:51:48 <lambdabot>     Just (a, b') -> a : unfoldr f b'
21:51:48 <lambdabot>     Nothing      -> []
21:52:04 <ChaiTRex> siraben: Looks like head . head . dropWhile (null . tail) . group . iterate peephole
21:52:13 <koz_> ChaiTRex: LOL
21:54:08 <koz_> :t head . head . dropWhile (null . tail) . group . iterate
21:54:09 <lambdabot> error:
21:54:09 <lambdabot>     • Couldn't match type ‘a -> [a]’ with ‘[c]’
21:54:09 <lambdabot>       Expected type: (a -> a) -> [c]
21:54:17 <koz_> :(
21:54:26 <ChaiTRex> koz_: Needs the function at the end.
21:54:46 <siraben> :t head . head . dropWhile (null . tail) . group . iterate id
21:54:47 <lambdabot> Eq c => c -> c
21:54:58 <koz_> Sweet.
21:55:11 <siraben> :t until (\x -> x == id x) id
21:55:13 <lambdabot> Eq a => a -> a
21:55:24 <koz_> That pointless version of until is amazing.
21:55:28 <siraben> but then I feel like it's performing the function twice, once in the twice and once again
21:55:28 <koz_> The one basically made of symbols.
21:55:40 <siraben> koz_:  The one I wrote?
21:55:58 <koz_> siraben: No, this one: https://stackoverflow.com/a/46629803/2629787
21:56:14 <koz_> <<((==)=<<)
21:56:15 * siraben gasps
21:56:18 <koz_> I hereby dub this 'rocket'.
21:56:31 <siraben> :t <<((==)=<<)
21:56:32 <lambdabot> error: parse error on input ‘<<’
21:56:50 <koz_> :t << ((==) =<<)
21:56:51 <lambdabot> error: parse error on input ‘<<’
21:56:53 <siraben> :t until=<<((==)=<<)
21:56:54 <lambdabot> Eq a => (a -> a) -> a -> a
21:57:00 <siraben> Ah
21:57:04 <koz_> siraben: ??
21:57:22 <siraben> Heh
21:57:36 <siraben> Thanks all
21:57:54 <MarcelineVQ> :t (<*((==)=<<))
21:57:56 <lambdabot> Eq a1 => ((a1 -> a1) -> a2) -> (a1 -> a1) -> a2
21:58:17 <koz_> MarcelineVQ: More rocket!
21:58:38 <MarcelineVQ> :t (<*((<*>)=<<))
21:58:40 <lambdabot> Applicative f => ((f a1 -> f (a1 -> b)) -> a2) -> (f a1 -> f (a1 -> b)) -> a2
21:59:26 <koz_> MarcelineVQ: That's some Cont-level shenanigans.
21:59:29 <siraben> :t  :t (<* (<*((<*>)=<<)))
21:59:31 <lambdabot> error: parse error on input ‘:’
21:59:36 <siraben>  :t (<* (<*((<*>)=<<)))
22:00:44 <siraben> :t (<* (<*((<*>)=<<)))
22:00:46 <lambdabot> Applicative f => (((f a1 -> f (a1 -> b)) -> a2) -> a3) -> ((f a1 -> f (a1 -> b)) -> a2) -> a3
22:19:53 <ChaiTRex> Probably more efficient is go . iterate peephole where go (x:xs@(y:_)) | x == y = x | otherwise = go xs
22:23:00 <ChaiTRex> fixpoint f x = let fx = f x in if x == fx then x else fixpoint f fx
22:58:02 <dminuoso> I nominate Witherable for typeclass of the month.
22:59:14 <opqdonut> heh
22:59:18 <opqdonut> nice name at least
23:01:22 <jackdk> seconded. Semialign is pretty cool too
23:03:53 <dminuoso> jackdk: Interesting, it's sort of mixture of selective and applicative functor.
23:04:56 <dmj`> dminuoso: who wins Monad of the year?
23:12:44 <dminuoso> dmj`: My nomination is on `Codensity f`
23:13:46 <dmj`> dminuoso: I was doing to say Identity, for all the work it does behind the scenes, in libraries like transformers. Quietly posting up in the cut while others take the glory for it
23:13:50 <dmj`> s/doing/going
23:15:21 <dminuoso> dmj`: My reasoning for Codensity is that it could be in far more widespread usage if it wasn't for its highly category theoretic appearahce.
23:24:43 <hoppfull> Let's say I have two types, 1. Meters, 2. MetersPer (SecondsPer Seconds). They both have identical meaning and representation. I could make a function f :: MetersPer (SecondsPer Seconds) -> Meters to simplify the type. Is it possible to do this directly on type level? So that x :: MetersPer (SecondsPer Seconds) can be assigned to y :: Meters?
23:27:44 <dminuoso> % :t coerce -- hoppfull 
23:27:45 <yahb> dminuoso: Coercible a b => a -> b
23:28:31 <dmj`> dminuoso: that's fair
23:29:02 <jle`> coerce works, but it sort of circumvents the type safety of what hoppfull is trying to do i think maybe. it at least shouldn't be done by the user at the user level
23:29:49 <dminuoso> I agree. If you have typefitting problems it's more likely that you are either a) producing the wrong types/consuming the wrong types, or your code is not polymorphic enough for ergonomics.
23:29:52 <jle`> you could do it in a typeclass based way maybe. or also you couild have 'Per' as a separate data type that is parameterized by both sides maybe, and use typeclasses to implement canceling-out ?
23:30:02 <opqdonut> hoppfull: you could make MetersPer and SecondsPer type families that compute the reduced form of the type, but that might be harder to use
23:30:31 <jle`> ^ that is what that one dimensions (or something) library does
23:30:34 <dminuoso> Fundamentally I'd say Meters and Meters per second are incompatible units.
23:30:48 <dminuoso> If you are trying to confuse one with another, it strongly suggests there's something awkward.
23:30:50 <opqdonut> dminuoso: you're misreading him
23:30:54 <dminuoso> Mmm?
23:31:01 <opqdonut> dminuoso: 1 is "m", 2 is "m/(s/s)"
23:31:02 <jle`> dminuoso: meters per (seconds per second) is compatible with meters
23:31:04 <jle`> they are the same
23:31:17 <dminuoso> Ahh.
23:31:28 <dminuoso> I was already confused by (SecondsPer Seconds)
23:31:41 <jle`> there is that one dimensions library that uses a generic data type for all units, and then uses type synonyms
23:32:03 <dminuoso> Does this call for a type level sat solver to normalize all units?
23:32:22 <jle`> only if you write dimension-polymorphic code
23:32:25 <opqdonut> is units still the standard answer to things like this? https://hackage.haskell.org/package/units
23:32:42 <jle`> but if you always use statically known dimensions then you don't need anything fancy
23:37:55 <hoppfull> Yeah, I don't need anything fancy. I already know which units are relevant and I am fine with defining them by hand.
23:38:33 <hoppfull> opqdonut: I'll check it out to see if I get some inspiration.
23:38:34 <dminuoso> hoppfull: Is it just a single odd case?
23:39:35 <hoppfull> dminuoso: We have units in our code. The people implementing it doesn't have a physics background and have done some silly things so I'm cleaning it up at the moment.
