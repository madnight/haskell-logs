01:08:16 <absence> why doesn't ExceptT have a Bifunctor instance?
01:09:33 <iqubic> :t runExceptT
01:09:35 <lambdabot> ExceptT e m a -> m (Either e a)
01:10:59 <iqubic> absence: It's because the bifunctor here would have to be "Instance Bifunctor (ExceptT e)" where lmap lets you manipulate the m, and rmap lets you manipulate the a. That's not really something that makes sense.
01:11:10 <iqubic> Also, I'm not sure what value you get from that.
01:11:52 <iqubic> You can just use (fmap (lmap f)) or (fmap (rmap f)) to apply your transformation to the inner Either.
01:12:42 <absence> iqubic: not without unwrapping and rewrapping the ExceptT
01:13:06 <iqubic> Ah. That is an issue. I see now why you might want that.
01:13:35 <absence> iqubic: but it's true that the type arguments are in the wrong order, hadn't thought about that
01:23:58 <dminuoso> Holy. `unsafePerformIO (newIORef Nothing)` has had some disastrous effects on my code.
01:24:05 <dminuoso> It's as if CSE kicked in.
01:25:53 <dminuoso> I produced a graph in which nodes carried that `unsafePerformIO (newIORef Nothing)` in many nodes, and then a single writeIORef mutated *all* of them..
01:26:03 <dminuoso> Should that be possible at all?
01:26:17 <alc> dminuoso: what RankNTypes is used to?
01:26:49 <dminuoso> alc: Let me counter that with something related.
01:26:57 <dminuoso> alc: Do higher order functions make sense to you?
01:27:24 <dminuoso> Like.. is it clear what the difference between `(Int -> Bool) -> Char` and `Bool -> Char` is?
01:28:20 <alc> Int -> Bool is a function?
01:28:51 <alc> I know what is higher order functions
01:28:56 <dminuoso> alc: More to the point, `(Int -> Bool) -> Char` is a function that *itself* takes another function as an argument.
01:29:08 <alc> dminuoso: yes
01:29:24 <dminuoso> alc: Similarly, an example rank 1 type is: `forall a. T a`
01:29:37 <dminuoso> alc: A rank 2 type might be (forall a. T a) -> B
01:29:42 <alc> dminuoso: what T is ?
01:29:43 <dminuoso> alc: So you demand that the argument itself be polymorphic.
01:29:49 <dminuoso> alc: An arbitrary type
01:29:53 <dminuoso> Doesn't really matter
01:30:25 * hackage elynx-seq 0.1.0 - Handle molecular sequences  https://hackage.haskell.org/package/elynx-seq-0.1.0 (dschrempf)
01:30:41 <alc> dminuoso: then what `T a` is?
01:30:55 <dminuoso> alc: Consider the more concrete example
01:31:07 <dminuoso> f :: (forall a. Maybe a) -> Bool
01:31:21 <alc> dminuoso: T is a type constructor
01:31:24 * hackage tlynx 0.1.0, slynx 0.1.0, elynx-tree 0.1.0, elynx-tools 0.1.0 (dschrempf)
01:31:29 <dminuoso> alc: Perhaps, or maybe a type family.
01:31:41 <dminuoso> The T is not relevant, the forall and the placement of the parens is.
01:31:55 <dminuoso> (forall a. ... a ...) -> B
01:32:03 <dminuoso> Where `...` denotes some arbitrary type terms
01:32:37 <alc> f :: (forall a. Maybe a) -> Bool is a rank 2 type?
01:32:43 <lortabac> dminuoso: there is a reason why it's called "unsafe*" :D
01:32:55 <alc> f :: (forall a. Maybe a) is rank 1 type?
01:33:19 <dminuoso> lortabac: Yeah but.. why is it *that* unsafe?
01:33:51 <dminuoso> Ah.. I suppose its not that surprising. 
01:33:58 <alc> what this `forall a. a -> (forall b. b -> b) -> a` is
01:33:59 <dminuoso> It can safely float that out..
01:34:01 <lortabac> it looks like CSE indeed, did you try disabling it?
01:34:24 <dminuoso> alc: That's a rank 2 type as well.
01:34:28 <Solonarv> alc: (forall a. Maybe a) is a rank-1 type, yes
01:34:45 <Solonarv> (forall a. a -> (forall b. b -> b) -> a) is rank 2
01:34:50 <alc> Solonarv: id :: forall a. a -> a is rank ?
01:34:55 <dminuoso> alc: rank 1.
01:35:31 <alc> (forall a. a -> (forall b. b -> b) -> a) is that `const`?
01:35:36 <alc> :t const
01:35:38 <lambdabot> a -> b -> a
01:35:52 <alc> oh, no
01:36:04 <Solonarv> all valid implementations of that turn out to be equivalent to const if we ignore strictness
01:37:32 <MarcelineVQ> though const specifically is  const :: forall a b. a -> b -> a
01:42:04 <alc> f :: (forall a. [a] -> Int) -> [a] -> Int is rank ?
01:42:30 <alc> f g alist = g alist
01:42:41 <alc> f length [1,2,3]
01:42:49 <Solonarv> it's confusing because the two uses of 'a' mean different things
01:43:17 <Solonarv> unfortunately this is not an error
01:43:29 <Solonarv> (or even a warning!)
01:43:29 <alc> f :: (forall a. [a] -> Int) -> [b] -> Int
01:43:57 <Solonarv> instead of simply answering your question, I will ask: what do you think?
01:45:39 <alc> Solonarv: rank 3?
01:45:54 <Solonarv> how did you come to that conclusion?
01:46:21 <alc> (forall a. [a] -> Int) -> ((forall b. [b]) -> Int)
01:46:28 <alc> rank 2?
01:46:34 <alc> I don't know
01:47:37 <alc> forall b. [b] -> Int is same to (forall b. [b]) -> Int?
01:48:06 <Solonarv> no, it's not the same at all!
01:48:49 <alc> type variable a or b need to come from somewhere
01:49:06 <boxscape> does . bind stronger than ->? Or do both have the same precedence binding to the right?
01:49:09 <Solonarv> you can "pull" a forall out of the right side of a ( -> ) or "push" it in if the variable isn't used on the left side
01:49:09 <boxscape> uh
01:49:18 <boxscape> I meant "does -> bind stronger than ."
01:49:36 <Solonarv> forall Q. S -> T is the same as forall Q. (S -> T)
01:50:24 <alc> but not same as (forall Q. S) -> T?
01:50:52 <dminuoso> alc: Correct.
01:51:41 <alc> forall a. [a] -> Int is same to forall a. ([a] -> Int) but not same to (forall a. [a]) -> Int? then what those mean?
01:51:48 <alc> the first and the second
01:52:03 <alc> f :: forall a. ([a] -> Int)
01:52:14 <alc> g :: (forall a.[a]) -> Int
01:52:30 <alc> f is rank 1, g is rank 2
01:52:47 <alc> f can be length, take a list return a Int
01:52:54 <alc> then what g is?
01:54:23 <merijn> alc: A function that can only take polymorphic lists
01:54:36 <merijn> alc: So you can only reall give it [] or a mix of [] and undefined
01:54:41 <jackdk> and [] is the only polymorphic list, neh?
01:54:47 <Solonarv> somehow you have a knack for choosing terrible examples ;)
01:55:10 <merijn> Fortunately, I already wrote a great example gist for RankN
01:55:22 <merijn> https://gist.github.com/merijn/77e3fa9757658e59b01d
01:57:15 <boxscape> hm, what about this? The higher-rankedness happens at the kind level, does that mean it's still a rank 1 type? forall (f :: forall a b . a -> b) . f Int
01:58:02 <Solonarv> depends on your definitions, I suppose
01:58:22 <Solonarv> as far as GHC is concerned I think this is still rank1
01:58:43 <boxscape> It doesn't work without RankNTypes but I don't know if that means ghc considers it not rank 1
01:59:05 <Solonarv> does it work with ExplicitForAll ?
01:59:19 <boxscape> no
01:59:31 <Solonarv> hm, does it suggest RankNTypes or something else?
01:59:32 * dminuoso forgot ExplicitForAll is a thing
01:59:41 * dminuoso always goes for ScopedTypeVariables instead
01:59:50 <boxscape>  Illegal polymorphic type: forall a b. a -> b, Perhaps you intended to use RankNTypes
01:59:52 <dminuoso> ScopedTypeVariables really should be in the standard. :<
02:00:01 <Solonarv> yes!
02:00:19 <Solonarv> it's also kind of strange that typed patterns are linked to it
02:00:59 <Solonarv> I can understand it if the pattern's type ascription mentions a type variable (since then it is brought into scope by the match, or has to already be in scope)
02:01:14 <phadej> 2020 may have ExplicitForAll, small steps at once
02:01:15 <Solonarv> but even ':: Text' requires it
02:01:17 <dminuoso> Solonarv: Another cool feature that is rarely known is
02:01:23 <alc> merijn: f is a ad-hoc function in your code, right?
02:01:37 <phadej> ScopedTypeVariables changes the specification of type inference, so it's trickier to standardize
02:01:40 <alc> f :: Num a => a -> a
02:01:57 <Solonarv> f is not an "ad-hoc function", it's an argument to 'mangle'
02:02:34 <Solonarv> alc: if you want to wrap your head around RankNTypes I would really really suggest always writing out the 'forall'
02:02:54 <Solonarv> in your head, 'f :: Num a => a -> a' should be "error: type variable 'a' not in scope"
02:03:24 <sshine> heh
02:03:47 <alc> f :: forall a. Num a => a -> a?
02:03:52 <Solonarv> yes.
02:04:05 <sshine> it's like math!
02:04:11 <dminuoso> Solonarv: ah btw the rationale behind pattern types requiring scoped type variables is simple:
02:04:41 <dminuoso> `f :: a -> a; f (x :: b) = undefined :: b` 
02:05:02 <dminuoso> (This is an alternate way to bind type variables without an explicit forall)
02:05:25 <Solonarv> dminuoso: that is why I said something about pattern types mentioning type variables!
02:05:27 <dminuoso> Ah
02:06:21 <Solonarv> it is really surprising that e.g. 'do x :: Text <- blah; T.putStrLn x' requires STV, since there are no type variables anywhere in sight!
02:06:40 <alc> f :: forall a. Num a => a -> a  is ad-hoc polymorphic?
02:06:49 <dminuoso> Solonarv: GHC 5.0 had some really strange things in the manual
02:07:05 <dminuoso>   f n :: ([a] -> [a]) = ....
02:07:12 <Solonarv> but I also understand that splitting off another extension for this, and deciding whether it is enough or you need STV, is unnecessary complexity
02:07:21 <dminuoso> Which was result type signatures
02:07:21 <boxscape> % type family Id' a where Id' a = a
02:07:21 <yahb> boxscape: 
02:07:23 <boxscape> % (undefined :: forall (f :: forall a . a -> a) . f Int) @Id'
02:07:23 <yahb> boxscape: ; <interactive>:75:1: error:; * The type family Id' should have 1 argument, but has been given none; * In the expression: (undefined :: forall (f :: forall a. a -> a). f Int) @Id'; In an equation for `it': it = (undefined :: forall (f :: forall a. a -> a). f Int) @Id'
02:07:25 <dminuoso> Apparently that no longer exists.
02:07:53 <Solonarv> boxscape: unsatured type families haven't landed yet!
02:07:53 <boxscape> hm, in HEAD this fails with "expecting kind forall a . a -> a but Id' has kind k -> k", wondering if that's a bug
02:07:56 <boxscape> I know :)
02:08:06 <boxscape> Just the HEAD error seems odd
02:08:09 <boxscape> % :k Id
02:08:10 <yahb> boxscape: ; <interactive>:1:1: error:; Not in scope: type constructor or class `Id'; Perhaps you meant one of these: `IO' (imported from Prelude), `Ix' (imported from Data.Array), Ghci32.Id' (imported from Ghci32)
02:08:11 <dminuoso> From what Ive seen, unsaturated type families will go a long way still.
02:08:11 <boxscape> % :k Id
02:08:11 <yahb> boxscape: ; <interactive>:1:1: error:; Not in scope: type constructor or class `Id'; Perhaps you meant one of these: `IO' (imported from Prelude), `Ix' (imported from Data.Array), Ghci32.Id' (imported from Ghci32)
02:08:18 <boxscape> uhnm
02:08:22 <boxscape> % :k Id'
02:08:23 <yahb> boxscape: Id' :: forall {k}. k -> k
02:08:28 <boxscape> there is a forall here after all
02:08:40 <Solonarv> ah yes, but it is forall {k} rather than forall k
02:08:47 <Solonarv> I think that is the difference?
02:08:55 <boxscape> ah, but it happens even if I give it a standalone kind signature with an explicit forall
02:09:03 <Solonarv> huh, then I don't know.
02:10:15 <alc> @let f :: forall a. Num a => a -> a; f = id
02:10:17 <dminuoso> What was the meaning of { } again? I think it was related to visible type applications somehow.
02:10:17 <lambdabot>  Defined.
02:10:20 <boxscape> Suppose I should open an issue to make sure
02:10:26 <alc> > f 3.5
02:10:29 <lambdabot>  error:
02:10:29 <lambdabot>      Ambiguous occurrence ‘f’
02:10:29 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
02:10:47 <alc> f 3.5 and f 3 both ok
02:10:50 <Solonarv> dminuoso: yes; variables within { } aren't available for VTA
02:10:56 <boxscape> dminuoso IIRC that's an inferred rather than specified variable, you get it if you don't supply a type/kind signature
02:11:03 <dminuoso> Ah so those are hidden type variables
02:11:08 <boxscape> in the future it will even be available for users to write in type sigs
02:12:09 <alc> but why mengle f (Foo i) is not ok?
02:13:30 <merijn> alc: Because in the first version the caller picks what 'a' is
02:13:40 <merijn> alc: And if the caller picks "Int", then you can't call it on a Double
02:14:52 <Solonarv> in the first version, in the body of 'mangle' you have 'f :: exists a. Num a *> a -> a'
02:15:05 <Solonarv> (which is not real Haskell syntax, but could be one day)
02:16:39 <Solonarv> okay, I have to go now
02:53:54 * hackage vformat 0.14.1.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.14.1.0 (gqk007)
03:13:19 <dminuoso> Opinion. For a simple `class HasPK t v | t -> v where primaryKey :: t -> v` would you prefer fundeps or an associated type family? Are there reasons to prefer one over the other?
03:21:11 <phadej> depends on how you'll use it later
03:21:49 <phadej> imho boils down to convinience
03:24:36 <dminuoso> phadej: Mmm, in what situation would you consider fundeps to be more convenient/ergonomic?
03:25:00 <dminuoso> Feature wise it seems that (injective) type families can do anything fundeps can do.
03:25:40 <dminuoso> Then it's truly just an ergonmic point of view.
03:32:19 <phadej> say, sortByPK :: (Ord v, HasPK t v) -> [t] -> [t] -- looks nicer than -- sortByPK' :: (Ord (PK t), HasPK t) -> [t] -> [t]
03:32:37 <phadej> you may have different opinion what's prettier
03:32:52 <Solonarv> dminuoso: injective type families can't really express "two of these determine the third"
03:34:37 <phadej> the question was ambiguous, with two parameters there are no third.
03:35:15 <Solonarv> a two-argument type family can be seen as a three-argument relation
03:35:42 <phadej> TFs are then nicer if you want to have subclass, class HasPK t => SomethingElse t where ...; with FD you'll need to make SOmethingElse parameterised by v too
03:35:47 <phadej> and duplicate the fundep
03:35:50 <phadej> it really depends
03:36:45 <Solonarv> yup
03:37:17 <Solonarv> and you *can* encode any fundep using type families, but in the general case you end up vomiting equality constraints all over the place
04:03:39 <boxscape> % class C a b | a -> b; instance C r r; instance C r Int -- asked this yesterday, but didn't get an answer - this allows the constraint solver to find instances for both `C Bool Int` and for `C Bool Bool`, shouldn't that be a fundep conflict?
04:03:40 <yahb> boxscape: 
04:04:40 <boxscape> % () :: (C Bool Int, C Bool Bool) => ()
04:04:40 <yahb> boxscape: ()
04:08:17 <boxscape> interestingly enough the above also emits the exact same pair of warnings *twice* (about simplifiable class constraints)
04:08:37 <boxscape> haven't seen something like that before
04:20:54 * hackage purescheme-wai-routing-core 0.1.0.0 - Simple Routing functions for Wai Applications  https://hackage.haskell.org/package/purescheme-wai-routing-core-0.1.0.0 (frincon)
04:29:24 * hackage vega-view 0.3.1.6 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.6 (DouglasBurke)
04:39:29 <alc> merijn: Solonarv I see, when f as a parameter to mangle, mangle can't pick a concrete type for f
04:41:34 <alc> Solonarv: is there a keyword called 'exists' in haskell?
04:41:44 <Solonarv> there is not, no
04:44:31 <boxscape> it also produces error messages of which I don't really understand what they mean or how they arise https://pastebin.com/7QfvXLcu
04:44:45 <alc> Solonarv: ok, but I saw some codes yesterday like Build a = (∀b. (a->b->b) -> b -> b); Destroy a = (∃b. (b->Maybe(a,b), b); build :: Build ~> []; destroy :: [] ~> Destroy
04:45:06 <boxscape> it seems like it deduces from the instances that the argument to test has to be an Int, but then it allows other types if you give the result a type annotation
04:46:39 <alc> Solonarv that ∀ is `forall`, ∃ is `exists`, but what `~>` is?
04:46:51 <alc> -> is Kleisli arrow
04:47:03 <Solonarv_> no, -> is not Kleisli arrow
04:47:16 <Solonarv_> it's just the usual function type
04:47:18 <alc> Solonarv_: then what it is?
04:47:35 <alc> Solonarv_: what is Kleisli arrow?
04:47:45 <alc> >=> is Kleisli composition
04:47:57 <Solonarv_> ~> doesn't have any kind of universal definition, but from context I am guessing it is "natural transformation"
04:48:04 <Solonarv_> type f ~> g = forall x. f x -> g x
04:49:27 <Solonarv_> the kleisli arrow for a monad M is _ -> M _
04:49:41 <Solonarv_> which we can't really write as an operator in Haskel syntax
04:49:54 <Solonarv_> and also has very little to do with what you're asking about
04:52:21 <alc> Solonarv_: what is "natural transformation"? I have no idea what this article tells https://wiki.haskell.org/Category_theory/Natural_transformation
04:52:45 <Solonarv_> I don't really have the time to go into that in depth right now
04:52:47 <alc> those symbols, category theory?
04:52:52 <alc> Solonarv_: that's ok
04:53:00 <maerwald> are there existing parser combinators for urls?
04:54:30 <merijn> maerwald: There was a parser in network that got split into it's own package, no?
04:54:51 <maerwald> I only know about the url package, but that doesn't expose a parser afais
04:54:59 <merijn> maerwald: https://hackage.haskell.org/package/network-uri
04:55:33 <merijn> That's not a parser combinator, I suppose. But I think you should be able to make one using it?
04:56:31 <merijn> maerwald: Uses Parsec internally, so I guess you could open a PR to expose the actual parser if you need it
04:59:24 <hmmcookies36> Guys remember lpaste.net? What do you use nowadays? lpaste was my fav because the website name was easy to remember...
05:01:32 <merijn> hmmcookies36: I haven't found an adequate replacement, sadly :\
05:01:54 <merijn> I often use paste.debian.net now because it's clean and minimal, but I don't like it
05:02:18 <hpc> i just haven't pasted stuff
05:02:23 <hpc> i would probably use gist
05:02:49 <hmmcookies36> I usually use https://paste.rs/web, it has easy to remember urls, but it's often down. Today I also found out about https://hastebin.com/ from a coworker
05:05:17 <maerwald> hmmcookies36: my own pastebin, check out privatebin
05:05:37 <maerwald> https://github.com/PrivateBin/PrivateBin/wiki/Docker
05:05:50 <maerwald> very lightweight and pastes are stored encrypted
05:05:59 <hmmcookies36> looks very cool
05:06:07 <maerwald> or just use their official server
05:06:15 <maerwald> https://privatebin.net/
05:22:26 <boxscape> Is there a formal specification somewhere of fundeps in ghc? Looking at the original paper ( https://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf ) still makes me believe that `class C a b | a -> b; instance C r r; instance C r Int` should be impossible.
05:29:32 <MarcelineVQ> I guess beause the class is vacuous
05:30:43 <boxscape> MarcelineVQ does that mean because it doesn't have methods?
05:30:53 <MarcelineVQ> yeah like there's no members/fields (uses of types) to try to constrain with the function dependency, idk tho
05:30:59 <boxscape> MarcelineVQ https://pastebin.com/7QfvXLcu
05:31:09 <maerwald> is there no proper high-level git library? with gitlib, I can't even find basic things like cloning a repo
05:34:30 <maerwald> and the tutorial points to non-existent functions
05:36:00 <MarcelineVQ> boxscape: the manual says "It is fine for there to be a potential of overlap ... an error is only reported if a particular constraint matches more than one." https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-resolution
05:36:35 <alc> how to use unicode operators in haskell? like ∀ is forall, λ is lambda
05:37:10 <alc> I saw there're https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntaxw
05:37:17 <boxscape> MarcelineVQ right, I understand that these are *overlapping*, and that's fine by me. But it still seems like they violate the functional dependency, which seems like a separate issue
05:37:19 <alc> but not too many symbols 
05:37:56 <alc> like how to define ∩ to Data.List.intersect?
05:38:25 <Solonarv> alc: the same way you define any other operator
05:38:39 <boxscape> MarcelineVQ (incidentally the error message in the pastebin also isn't about Overlapping instances)
05:38:56 <Solonarv> (∩) :: Eq a => [a] -> [a] -> [a]; (∩) = Data.List.intersect
05:39:21 <boxscape> you get an overlapping instances error for `test 4 :: Int` though
05:39:31 <Solonarv> unicode characters are always legal as parts of identifiers/operators, you don't even need UnicodeSyntax
05:41:00 <alc> Solonarv: (λ) = \ is wrong
05:41:12 <Solonarv> yes, because \ isn't an operator
05:41:13 <merijn> Because 1) \ is not an operator by itself
05:41:14 <Solonarv> it is syntax
05:41:14 <alc> f = λa -> a
05:41:28 <merijn> and 2) λ is a letter and thus never a legal operator
05:41:49 <merijn> operators can only have characters which are symbols/operators
05:41:59 <merijn> > generalCategory 'λ'
05:42:02 <lambdabot>  LowercaseLetter
05:42:10 <Solonarv> and UnicodeSyntax doesn't let you use λ for lambdas because it is a letter, which means it's legal as part of identifiers, so using it for syntax would cause horrible parser issues
05:42:13 <merijn> > generalCategory '☃'
05:42:16 <lambdabot>  OtherSymbol
05:42:31 <boxscape> > generalCategory '\\'
05:42:33 <lambdabot>  OtherPunctuation
05:42:51 <alc> what is 'letter'?
05:43:21 <Solonarv> it's a unicode category, which includes (unsurprisingly) letters
05:44:09 <MarcelineVQ> boxscape: The link was about functional dependencie's instance resolving in particular but yeah it's unclear to me as well why this works, b = test True :: Int seems like it should be causing a problem already
05:45:18 <merijn> alc: A letter, as in the stuff in an alphabet that you write words with?
05:45:21 <boxscape> MarcelineVQ I don't think the link is about fundeps actually, fundeps are 9.8.2 while instance resolutions (your link) is 9.8.3.1, part of 9.8.3 instance declarations
05:45:41 <alc> merijn: 'f' is a letter, 
05:45:53 <alc> 'f' shouldn't be a operator?
05:46:02 <alc> 3 f 2
05:46:04 <merijn> alc: 'f' can't be an operator in Haskell, no
05:46:49 <MarcelineVQ> boxscape: oh huh, yeah seems so, the header text size differen't wasn't clear to me it looks like
05:46:55 <boxscape> yeah it's confusing
06:04:00 <astk37> I have an example haskel project im trying to build with nix; https://github.com/astk-hs/HelloWorld-backpack/tree/master/backpack_example . but when I add a default.nix using callCabal2nix, i get this error; https://github.com/astk-hs/hello_backpack_nix/tree/master/hello_backpack
06:29:35 <hseg> OK, day n of my type-level adventure. Managed to at least get GHC to at least give me workable type holes, which is less nice than fully-inferred types, but still an improvement
06:31:02 <hseg> Do have some problems though -- GHC dislikes types of the form (Even d, KnownNat d) => L d _
06:31:43 <hseg> (GHC only tells me that (_::Nat), not how to fill the hole)
06:31:48 <hyperisco> My gosh I am seeing McBride everywhere now. What worm has he burrowed into my brain?
06:32:02 <hseg> hyperisco: what has he done this time?
06:32:40 <hyperisco> He pointed out how crazy we all are for being willing slaves to type inference
06:32:59 <hseg> right, and that we should want term inference instead?
06:33:20 <hseg> sure
06:33:55 <hyperisco> In part yes but the larger point, as I understood it, is how limiting it is to stop at "well it can't be inferred in all cases, so we can't do that"
06:34:00 <MarcelineVQ> I wish he'd point out a little better though
06:34:34 <MarcelineVQ> someone asked what he meant on the subject recently and the response was    you can google it
06:34:42 <hseg> yeah. watched the lecture, feel he should write it up as a research paper for me to fully understand what he means
06:35:01 <hyperisco> the response was you can watch my presentation on it, to which the individual was unhappy with the audio quality
06:35:56 <MarcelineVQ> That's not the response I saw but that's a better response for sure
06:36:20 <MarcelineVQ> assuming you can wacth my presentation included a link to it
06:37:58 <MarcelineVQ> pretty interested to see what languages/libraries frank inspires, in the same way that epigram inspired others
06:40:35 <boxscape> merijn you said yesterday that https://gist.github.com/merijn/dc00bc7cebd6df012c5e can't be written without type families - does this count? https://gist.github.com/JakobBruenker/6a87367b1eded2f0a18b73e2333b10c2
06:41:54 <boxscape> (ignore the Zippable class, in fact I'll edit it out, it's unused)
06:45:39 <boxscape> oh I can even replace `error "impossible"` with \case, that's nice
07:03:37 <Athas> Alright, I've used head/tail to make some code work.  Now to go around and make all those lists NonEmpty...
07:15:33 <boxscape> merijn: Though for all I know I might be missing something obvious that makes your version of apply more powerful than mine or something
07:24:08 <merijn> boxscape: Well, the original comment was in the context "can typefamilies do something useful without typeclasses?", not that there was no other way to implement that function
07:26:25 <boxscape> merijn ah, I see, then I misinterpreted that
07:28:14 <merijn> boxscape: So it was just an example of something 1) useful, 2) using type families, 3) that didn't require a typeclass :)
07:28:43 <boxscape> yeah that makes sense :)
07:30:55 <boxscape> (I suppose I misinterpreted it because I asked if there's something you can do with typefams that you can't do with classes a few minutes before I asked if you can do something useful with typefams without classes)
07:38:20 <geekosaur> that feels like the wrong question, tbh; type families are alternatives to functional dependencies, not typeclasses
07:51:46 <dminuoso> I have three sets that are supposed to be equal. Is there some well known algorithmic trick to efficiently figure out which elements in what sets are missing?
07:52:14 <dminuoso> Perhaps even to scale out to n sets.
07:54:33 <kuribas> dminuoso: set difference?
07:55:07 <kuribas> O(n) on ordered sets
07:55:37 <kuribas> O(1) if the sizes differ
07:55:45 <kuribas> you can compare the sizes first
07:56:20 <merijn> geekosaur: To be fair, he did need fundeps to recreate my Type Families example ;)
07:58:07 <boxscape> My question yesterday was actually specifically about MPC with fundeps, I just didn't cite it correctly
07:59:24 <kuribas> dminuoso: or union of all sets - intersection of all sets
08:02:12 <kuribas> dminuoso: that's O(sum of set sizes)
08:04:04 <kuribas> unions sets \\ foldl insersection empty sets
08:06:54 * hackage log4hs 0.7.1.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.7.1.0 (gqk007)
08:08:24 * hackage telega 0.3.0 - Telegram Bot API binding  https://hackage.haskell.org/package/telega-0.3.0 (iokasimovmt)
08:18:06 <hexagoxel> are there any tricks for making the compilation of code that involves a large list literal (1000+ length) faster? It feels like something is superlinear in ghc, but I have not figured out what, or how to work around it.
08:19:30 <MarcelineVQ> hexagoxel: are they monomorphic?
08:19:42 <kuribas> dminuoso: to find which element comes from which, do the intersection of that with each set separately
08:21:32 <hyperisco> I am imagining this glorious 1000+ type unification problem
08:21:40 <hexagoxel> MarcelineVQ: the items all use different instances of the same class, but yielding the same type (of course)
08:21:56 <hexagoxel> I have already peppered type signatures to no avail.
08:24:03 <MarcelineVQ> dminuoso: it wouldn't surprise me if there was an 'align' around that let you zip sets and query which items needed padding
08:25:20 <Cale> hexagoxel: Is there any logical way to break it into smaller parts? That might help.
08:26:07 <MarcelineVQ> dminuoso: like, semialign has isntances for IntMap or Vector
08:26:24 <Cale> There are definitely some cases in dealing with large expressions or modules where GHC's performance appears to be quadratic or worse.
08:27:27 <Cale> (Of course, typechecking in general is superexponential, but usually that's only true of pathological cases)
08:29:09 <hyperisco> A time complexity to be proud of. We only solve computationally hard problems here. :)
08:32:18 <royal_screwup21> what's the haskell offtopic channel? :)
08:32:51 <merijn> royal_screwup21: The deceivingly named #haskell-offtopic ;)
08:33:37 <royal_screwup21> I hope it's ok to ask general-purpose programming questions on there...
08:34:09 <atif> I have a list/vector that I want to randomize and select from to perform computation and I want to do this 1000s of times.  What is a good strategy to do this in haskell?
08:34:59 <ChaiTRex> atif: What do you mean by select from?
08:36:24 <hseg> atif: ie select a random element from a given list, run a computation with it, repeat n times?
08:37:16 <atif> select x% of the elements randomly from a given list, run a computation on them, repeat n times.
08:37:49 <atif> for our purpose we can treat x% as 40$
08:37:52 <ChaiTRex> atif: Use a vector instead of a list.
08:37:52 <atif> 40%
08:38:07 <ChaiTRex> atif: It's fast for random access.
08:38:23 <hexagoxel> Cale: I tried splitting it into 100-elem literals with separate bindings which had no effect. I'll try to make the lists contain only literals and references to monomorphic, local bindings next.
08:38:26 <atif> I am using a vector.  My issue is with random selection
08:38:47 <merijn> atif: You want a partial Fisher-Yates shuffle
08:38:59 <merijn> Implementing one for vector is on my to do list
08:39:08 <merijn> Fortunately it's fairly simple to implement
08:39:30 <[exa]> fisher-yates is another name for knuth shuffle right?
08:39:41 <merijn> [exa]: Knuth wrote about it, yes
08:40:52 <merijn> atif: Fisher-Yates is the cheapest, properly uniform random way to select elements from a collection, so that's the way to go
08:42:53 <atif> so far I shuffle the whole list and select first 40% of the elements.  However, a pure shuffle means that I have to feed it the output of the last shuffle to get a new shuffle.
08:43:16 <ChaiTRex> atif: You would shuffle 40% of the list and use those elements instead.
08:43:43 <ChaiTRex> atif: You don't need to feed it the output of the last shuffle, just a different RNG state.
08:43:56 <ChaiTRex> atif: You can use the same starting vector each time if you want.
08:44:19 <ChaiTRex> atif: The different random numbers generated will give you different 40% selections.
08:45:29 <atif> I can't figure out a good way to create a new RNG recursively.
08:45:49 <ChaiTRex> atif: Just use the old RNG but don't restart it.
08:46:11 <ChaiTRex> atif: Or, if you mean creating it the first time, there are mkStdGen or something you can use.
08:47:13 <atif> I have g <- newStdGen in the do block.  But this means for the same input a pure function give me same output
08:48:16 <ChaiTRex> atif: When you produce a random value, it should give you an StdGen with it. Use that StdGen to generate the next random number, and so on.
08:48:22 <Cale> atif: I'm not sure I understand -- most of the operations for using generator states will produce a new generator state
08:49:37 <ChaiTRex> atif: Then your whole partial shuffle function can produce the shuffled vector along with the last StdGen the last shuffle random value produced.
08:49:50 <ChaiTRex> atif: You can return (Vector whatever, StdGen)
08:49:59 <atif> I'm using Immutable.Shuffle.shuffle inputVec g to shuffle the list
08:50:00 <ChaiTRex> atif: That StdGen can be used in the next shuffle.
08:51:23 <ChaiTRex> atif: That returns a pair (vector, rng)
08:51:33 <ChaiTRex> atif: Use the rng in the next shuffle.
08:51:44 <atif> so what I'm getting from your comment is that I should your its returned rng as the next g.
08:51:54 <atif> got it.
08:51:57 <ChaiTRex> atif: Yep, it'll shuffle the list differently next time.
08:52:32 <atif> Thanks.
08:52:38 <ChaiTRex> atif: No problem.
09:16:05 <maerwald> how do you derive an oprhan Read instance for a Gerneric data type
09:17:05 <phadej> I assume that `deriving instance Read TheType -- doesn't work?
09:17:34 <dmj`> instance Read YourType where read = genericRead
09:17:42 <phadej> looks like, https://hackage.haskell.org/package/generic-deriving doesn't have genericRead :(
09:17:58 <dmj`> maerwald: I have a Generic Read if you want one
09:18:02 <ChaiTRex> @hoogle genericRead
09:18:02 <lambdabot> No results found
09:18:06 <maerwald> Maybe it does work. Just lost in the documentation.
09:19:12 <hseg> Do type family declarations accept where clauses?
09:19:17 <maerwald> yeah, StandaloneDeriving works fine
09:19:40 <hseg> Want to write a type-level divMod so I can say it's injective
09:20:17 <dmj`> hseg: yea, but it makes it a closed type family
09:20:49 <hseg> not on the type family itself (am using a closed family in any case)
09:20:54 <hseg> meant on the instance declaration
09:21:16 <hseg> e.g. DivMod2 (S (S n)) = (S d, m) where (d, m) = DivMod2 n
09:21:43 <hseg> Am getting syntax error
09:26:38 <ChaiTRex> hseg: Maybe you have to do Div and Mod separately and then combine them.
09:26:55 <hseg> No, because that will break my injectivity proof
09:30:30 <ezzieyguywuf> so, if I run `cabal repl MyLib-test`, I succesfully get dumped into a GHCI prompt which loads my `test/Spec.hs`, which auto-detects `test/SomModuleSpec.hs`. awesome! Now, though, if I make a change to `src/SomeModule.hs`, when I run `ghci> :reload`, it does _not_ recompile `src/SomeModule.hs`. Am I doing something wrong here?
09:30:50 <nshepperd2> hseg: nope. you need to write an auxiliary type family
09:31:35 <nshepperd2> DivMod2 (S (S n)) = Aux (DivMod2 n)
09:32:08 <ezzieyguywuf> I think it's the autodetect that's giving me the issue, maybe I need to retrigger that when I `:reload`?
09:32:12 <topos> phadej I shoved a reference to the glassery into that post just for you :P
09:32:32 <solonarv> ezzieyguywuf: nope, nothing you're doing wrong - when you do 'cabal repl some-component', only the modules in some-component are loaded in interpreted mode, and only those are reloaded by :reload
09:32:57 <ezzieyguywuf> solonarv: is there a different way I can leverage cabal and/or ghci to accomplish the work flow I'm looking for?
09:33:23 <hseg> nshepperd2: OK, too bad.
09:33:34 <solonarv> ezzieyguywuf: not "natively", but ghcid exists for exactly this purpose
09:33:40 <hseg> nshepperd2: Does this have something to do with the lack of type-level lambdas?
09:33:50 <phadej> topos: oh, I thought it was because of the outstanding quality of that post! :(
09:34:28 <ezzieyguywuf> solonarv: hrm, I see. I'll take a look at that, but probably just manually issue `cabal test` in the short term
09:35:28 <hseg> Urgh. Why is an injective type family forbidden from the RHS of another injective type family?
09:35:46 <topos> phadej why not both? 
09:35:48 <topos> :D
09:36:04 <topos> no, it's a really good reference. people should see it. 
09:36:18 <topos> Your posts are extremely accessible and cover the whole zoo. they're great
09:37:55 <phadej> yes, I'd like to find time to edit glassery with a bit more stuff (e.g. achroma) and references
09:38:18 <phadej> but IIRC it's 40 pages if printed, so it's a task hard to find time for
09:39:17 <nshepperd2> hseg: oh yeah, that won't work because the injectivity checker is extremely dumb
09:39:26 <hseg> wtf
09:41:11 <hseg> all I want is to be able to have a function (d ~ 2*r) => L d r and have GHC fill in the type hole arising from a signature L d _
09:42:21 <nshepperd2> with what?
09:42:31 <hseg> :)
09:43:14 <hseg> Right, I'd need to either have a relevant case analysis on d around
09:43:25 <hseg> (which I don't know if GHC permits)
09:44:24 * hackage reflex-process 0.2.1.0 - reflex-frp interface for running shell commands  https://hackage.haskell.org/package/reflex-process-0.2.1.0 (abrar)
09:44:27 <hseg> Or need to add some evenness constraint on d in L d _
09:44:53 <topos> phadej if you intend it to be a  more complete glassery, you should take a look at the recent work we did in the paper, which includes a bunch of new optics. The glassery will never be complete though, as we discovered, because there are as many optics as there are strong monoidal functors over hask and subcategories of hask, and you can even compose those actions to form new new optics (like affine travs). 
09:45:22 <hseg> But even if I have a constraint k `WEven` d = (d ~ 2*k), GHC won't offer unifying k~r
09:45:29 <topos> if you intend it to be a glassery of "useful" optics, definitely take a look at adding the coalgebraic optics and kaleidescopes from the paper
09:45:34 <hseg> because 2* isn't viewed as injective
09:45:41 <hseg> topos: Which paper?
09:45:52 <topos> https://arxiv.org/abs/2001.07488
09:46:00 <topos> our recent pape
09:46:09 <hseg> nice
09:46:28 <phadej> topos: glassery has affine trav :), and yes, you only need the closed structure, so you can have weird stuff like "containers with odd numbers of elements"; which isn't generally useful, but **you could** have those
09:47:01 <topos> i'm unsold on what to call useful and not useful tho :P
09:47:23 <phadej> yet, having a reference with stuff you find in libraries is something I could keep up with
09:47:55 <phadej> topos: I tried to find how to represent an applicative-like structure for containers with say >= 2 elements
09:48:01 <phadej> Haskell fights back
09:48:14 <topos> haskell is definitely a problem for container-ey optic
09:48:18 <topos> *optics
09:48:36 <hseg> nshepperd2: any ideas on how to fix this?
09:48:37 <topos> you really need dependent types for some of these
09:49:29 <topos> phadej even the representation of traversal for haskell is scary to me with `forall f. Applicative f => `. It has implicit invariants
09:50:29 <phadej> topos: there's unsolved business whether traversals are finitiary or finitary, I haven't heard good argument to exclude infinite ones
09:50:57 <phadej> except "hard to deal in CT"
09:53:50 <ezzieyguywuf> solonarv: ghcid is very nice, and lightweight which I'm a fan of. I can see how to use it to continuosly check my `src/MyModule.hs` file for errors, however I don't understand how I can use it to continuously run `hspec-discover` on my `test` directory
09:55:39 <topos> phadej you wound me. That's exactly why we didn't deal with them XD
09:55:58 <phadej> topos: I have thought about this things too ;)
09:56:06 <nshepperd2> hseg: give up? :p
09:56:26 <hseg> *sigh*
09:56:40 <nshepperd2> injectivity can be simulated by writing type checker plugins, but i doubt going down that rabbit hole will do anything but cause more problems
09:56:46 <hseg> Right
09:57:36 <hseg> Thought I could avoid this by writing DivMod
09:57:53 <ezzieyguywuf> solonarv: ah I figured it out! just needed to update .ghci to load the hspec package
09:58:04 <hseg> But that requires an auxiliary type family and breaks injectivity
09:58:06 <ezzieyguywuf> then added `:load test/Spec.hs` and `:main` to .ghci
09:58:23 <hseg> ... hrm. Maybe I can make DivMod into a typeclass with fundeps?
10:01:17 <sicklorkin> > fmap (cycleTaking 10) $ Data.Sequence.splitAt 1 (Data.Foldable.fromList [1..10])
10:01:19 <lambdabot>  error:
10:01:20 <lambdabot>      Not in scope: ‘Data.Foldable.fromList’
10:01:20 <lambdabot>      Perhaps you meant one of these:
10:01:25 <reactormonk> I wanna know where my Haskell code is spending most of its time. The wiki on profiling mostly talks about memory - is there anything on CPU out there?
10:02:44 <sicklorkin> > fmap (cycleTaking 10) $ Data.Sequence.splitAt 1 (Data.Sequence.fromList [1..10])
10:02:47 <lambdabot>  error:
10:02:47 <lambdabot>      • Variable not in scope: cycleTaking :: Integer -> Seq.Seq a -> b
10:02:47 <lambdabot>      • Perhaps you meant ‘Seq.cycleTaking’ (imported from Data.Sequence)
10:03:17 <sicklorkin> > fmap (Data.Sequence.cycleTaking 10) $ Data.Sequence.splitAt 1 (Data.Sequence.fromList [1..10])
10:03:20 <lambdabot>  (fromList [1],fromList [2,3,4,5,6,7,8,9,10,2])
10:04:19 <sicklorkin> Is there a canonical way to cycle seq such that the popped item `[1]` is appended to the end?
10:04:56 <hexagoxel> Cale, MarcelineVQ: Adding monomorphic local bindings and using those in the list literal definitely helped. Whether it helped the type-checker or the simplifier I have not checked.
10:05:01 <jle`> sicklorkin: popping and snoccing is probably the best way
10:05:08 <ChaiTRex> sicklorkin: Just write a function to remove it from one end and put it on the other.
10:05:20 <jle`> sicklorkin: popping = pattern matching on :<|
10:05:28 <jle`> sicklorkin: snoccing = using :|>
10:05:47 <jle`> @let cycleSeq (x Seq.:<| xs) = xs Seq.:|> x
10:05:48 <hexagoxel> I would be curious if OverloadedStrings also makes things worse. But I found no easy way to disable the extension just for this module, which makes this tricky to check.
10:05:48 <lambdabot>  Defined.
10:05:59 <jle`> > cycleSeq (Seq.fromList [1..10])
10:06:00 <lambdabot>  fromList [2,3,4,5,6,7,8,9,10,1]
10:06:30 <jle`> @undefine
10:06:30 <lambdabot> Undefined.
10:06:37 <jle`> @let import Data.Sequence (Seq(..))
10:06:38 <lambdabot>  Defined.
10:06:43 * hexagoxel goes to investigate the next module with a 30sec compile time..
10:06:47 <jle`> @let cycleSeq (x :<| xs) = xs :|> x
10:06:48 <lambdabot>  Defined.
10:06:50 <jle`> maybe a little cleaner
10:07:15 <jle`> there's a nice symmetry about it huh
10:07:31 <jle`> cycleSeq = \case x :<| xs -> xs :|> x
10:07:36 <ChaiTRex> You can also make a splitAt version with the concatwhatever function.
10:07:40 <jle`> it's like poetry it rhymes
10:07:59 <hseg> nshepperd2: yeah, fundeps work
10:08:00 <sicklorkin> wait.. is :|> a patternSynonym?
10:08:11 <jle`> yes
10:08:12 <hseg> nshepperd2: gimme a moment, I'll show you
10:08:34 <sicklorkin> jle`: that's beautiful
10:08:46 <jle`> ur beautiful
10:09:40 <sicklorkin> jle`: thanks 
10:10:03 <NemesisD> in haskell is there any concept of annotating type parameters in a labeled way rather than just positionally, e.g. rather than `Foo A B C`, `Foo { inputType :: A, outputType :: B, errorType :: C}`
10:10:16 <sicklorkin> ChaiTRex: thanks
10:10:44 <Cale> NemesisD: Not at present
10:10:52 <jle`> NemesisD: unfortunately not really in a nice way, it's something i've thought would be nice for a while i think.  it would make -XTypeApplications a lot more pleasant to use
10:11:15 <NemesisD> dang
10:11:51 <jle`> for documentation purposes people sometimes like to give their type variables nice names
10:11:59 <jle`> like `data Foo inputType outputType errorType = ...
10:12:19 <jle`> sometimes the typechecker respects these
10:12:32 <Cale> I've been working on adding type applications in patterns, and ran into the weird case of what to do when you have a constructor pattern with record arguments which brought up that same question of whether there ought to be the possibility of named type arguments.
10:12:57 <jle`> named arguments in general might be nice, ocaml seems to have a fun time with it
10:13:00 <Cale> (But yeah, for now, we're just making it impossible)
10:14:48 <hseg> nshepperd2: Hrm. They only do to a certain extent -- while GHC is happy to believe me that DivMod is injective, that doesn't mean it can infer the inverse
10:14:54 <hseg> dammit
10:17:32 <NemesisD> jle`: yeah i'm giving the type variables nice names, its just that when you use them it sort of erases all that information, except i guess if they make a type error the compiler should use the type variable name as a hint
10:18:15 <NemesisD> i guess i could do something stupid like `(inputType ~ A, outputType ~ B, errorType ~ C) => Foo inputType outputType errorType`
10:19:36 <jle`> yeah, the typechecker/ghc error messages makes this not as useful in a lot of situations
10:33:27 <hseg> Hrm. Am slowly getting better results with fundeps
10:36:22 <hseg> Trying to write an inverse to divmod explicitly for GHC to use in inference
10:37:11 <hseg> Problem: can't really write instance UnDivMod2 (2*q+r) '(q,r) because +r is noninjective in general
10:40:03 <solonarv> ezzieyguywuf: no, that's... well you can do that but it's not the recommended approach
10:40:21 <solonarv> ezzieyguywuf: there is a '--command' argument so you can tell ghcid how to start ghci
10:40:55 <solonarv> and you can also pass some extra arguments to tell it to restart when certain files are modified, or to run a specific function after reloading
10:41:06 <solonarv> you do not need to modify .ghci
10:51:54 * hackage fake 0.1.1.3 - Randomly generated fake data  https://hackage.haskell.org/package/fake-0.1.1.3 (DougBeardsley)
10:53:02 <ibloom> can you specify that a type family has a particular constraint?
10:53:56 <ibloom> For example can make a "type FunctorOf t" and force the instance writer to make FunctorOf t a functor.
10:54:17 <ibloom> Or am I way off, in my thinking here.
10:57:41 <dmwit> ibloom: No, you cannot.
10:58:04 <tabaqui1> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#v:oneShot
10:58:21 <tabaqui1> oh, men, does Haskell have linear types?
10:58:27 <ibloom> dmwit: I see, it looks like I can specify it in the member functions, but it may be just making things even more complicated.
10:58:53 <solonarv> tabaqui1: no, it does not (yet - some people are working on it)
10:59:15 <solonarv> ibloom: wait, you are trying to delcar a 'class FunctorOf t' ?
10:59:24 * hackage haskell-lexer 1.1 - A fully compliant Haskell 98 lexer.  https://hackage.haskell.org/package/haskell-lexer-1.1 (IavorDiatchki)
10:59:30 <tabaqui1> solonarv: I heard about this feature 3 years ago, but apparently nothing changed
10:59:41 <tabaqui1> but how does this oneShot function work?
10:59:50 <solonarv> tabaqui1: compiler magic
10:59:54 <ibloom> dmwit: No FunctorOf t is a type family declared inside the class.
11:00:00 <tabaqui1> solonarv: ok, thx:)
11:00:09 <geekosaur> in that case the constraint can go on the class head
11:00:25 <solonarv> ibloom: ah, so you have 'class Blah t where type FunctorOf t :: Type -> Type'
11:00:33 <ibloom> geekosaur: So far that didn't work.
11:00:34 <solonarv> as geekosaur said, constraint goes in the class head
11:00:47 <ibloom> solonarv: that's correct.
11:01:18 <solonarv> ibloom: if that didn't work, it might be a good idea to post your actual code and the actual error message instead of describing them and making us guess the details
11:02:07 <dmwit> ...but even if you do what solonarv and geekosaur are suggesting, the compiler will not know that `Functor (FunctorOf t)` for all `t`. You will still need to add the `Blah t` or `Functor (FunctorOf t)` constraint to tell the compiler this.
11:02:08 <ibloom> I think I'm making sort of a fundamental mistake with all of my type family designs. Let me do some more work and I'll put together a post on /r/haskellquestions. Thanks.
11:03:01 <ibloom> dmwit: I don't think you can put Functor (FunctorOf t) in the typeclass head.
11:03:14 <ibloom> Since FunctorOf t is defined inside the typeclass.
11:04:15 <solonarv> that is not a problem at all
11:04:42 <solonarv> I will demonstrate
11:05:54 <solonarv> % class Functor (FooFunctor t) => Foo t where type FooFunctor t :: Type -> Type; fooblicate :: FooFunctor t a -> t -> a
11:05:55 <yahb> solonarv: 
11:07:54 <jle`> % instance Foo String where type FooFunctor String = (,) String; fooblicate (_, x) _ = x
11:07:54 <yahb> jle`: 
11:08:01 <jle`> booular
11:08:04 <jle`> *foobular
11:09:24 * hackage pretty-show 1.10 - Tools for working with derived `Show` instances and genericinspection of values.  https://hackage.haskell.org/package/pretty-show-1.10 (IavorDiatchki)
11:09:40 <ibloom> solonarv: I see, let me give that a shot.
11:14:56 <ibloom> solonarv: Looks like that's working.
11:31:19 <hseg> Weird. GHC is complaining     Not in scope: type constructor or class ‘Type’
11:31:39 <hseg> Ah, need Data.Kind.Type
11:34:07 <hseg> How do I construct parity-carrying peano integers at the type level?
11:34:21 <merijn> "Painfully"
11:34:25 <hseg> :(
11:34:34 <solonarv> zeroless binary, perhaps?
11:34:41 <hseg> ?
11:35:15 <hseg> Because I need parity info to convince GHC that my type-level map \(d,m)-> 2*d+m is injective
11:35:19 <solonarv> 'data Nat = Zero | Dbl Nat | SuccDbl Nat'
11:36:21 <solonarv> the denotation is: deno Zero = 0; denot (Dbl x) = 2 * denot x; denot (SuccDbl x) = 2 * denot x + 1
11:37:22 <hseg> Hrm. could work -- parity given by whether outermost constructor is SuccDbl...
11:37:38 <jle`> hseg: not sure if this would work for you, but you can also make GADTs with proofs for evenness/oddness
11:37:55 <hseg> jle`: Need promoted GADT
11:38:07 <hseg> And you can't promote nonequality constraints
11:38:10 <jle`> ie a `data IsEven :: N -> Type` and `data IsOdd :: N -> Type`, where it is only possible to conustrct `IsOdd n` if n is odd
11:38:36 <jle`> yeah, this would only work if you are writing term level functions to deal with these N's
11:38:38 <solonarv> I don't think constraint-evidence-carrying constructors can be promoted at all
11:38:41 <jle`> or sing n's
11:38:49 <hseg> solonarv: they can!
11:38:55 <jle`> it depends on the situation really
11:39:02 <solonarv> % data TagFoo a where TagInt :: TagFoo Int
11:39:02 <yahb> solonarv: 
11:39:24 <solonarv> % :t Proxy :: Proxy 'TagInt
11:39:24 <yahb> solonarv: Proxy 'TagInt
11:39:27 <solonarv> hm
11:39:52 <hseg> From GHC guide:
11:39:57 <hseg> data Foo :: Type -> Type where
11:39:59 <hseg>   MkFoo1 :: a ~ Int         => Foo a    -- promotable
11:40:01 <hseg>   MkFoo2 :: a ~~ Int        => Foo a    -- promotable
11:40:03 <hseg>   MkFoo3 :: Show a          => Foo a    -- not promotable
11:40:25 * hackage hcad 0.1 - Haskell CAD library  https://hackage.haskell.org/package/hcad-0.1 (JeanPhilippeBernardy)
11:41:37 <hseg> jle`: so your solution is some kind of data family IsEven (n::Nat) where {IsEven Z = E; IsEven (S (S n)) = IsEven n } ?
11:43:37 <jle`> i'm not sure it works as a data family. but it's situational how you would use one or the other
11:43:41 <jle`> since haskell is awkward
11:44:54 <hseg> yeah... really should have gone for idris if I wanted this much type hackery
11:45:44 <hseg> fuck it, redesigning the project to avoid this. will be less general than desired, but since when was that a design requirement?
11:47:05 <dmj`> Cale: is there a way to override Haskell's lambda syntax. Like how we have fromInteger, and overloaded strings, can we make overloaded lambda, that allows `\x -> x :: Expr a`
11:47:51 <Cale> Not exactly, but see Conal's concat
11:47:55 <hseg> Note: This is a simplified yak shave started by wanting some way of A) constructing a value of type (KnownNat d, KnownNat r) => L d r given only one of d,r with B) d,r reflected at runtime such that C) this value of type L d r can be passed to a function of type L d r -> (F d -> c) -> c
11:48:10 <Cale> https://github.com/conal/concat
11:48:28 <Cale> http://conal.net/papers/compiling-to-categories/
11:48:40 <dmj`> Cale: ideally it wouldn't be a GHC plugin
11:48:43 <hseg> (A has a hope of happening since d~2r+1 is injective)
11:49:21 <Cale> This is basically giving the answer of how you might overload lambda in that way, even if it's not a built-in feature of the language. It's fairly involved, but has some really nice applications.
11:53:44 <rsoeldner> cocreature,Hi - quick question, could it be possible my issue https://github.com/digital-asset/ghcide/issues/387 relates to https://github.com/digital-asset/ghcide/issues/113 due to no v2-build support ? :-/
12:04:37 <cocreature> rsoeldner: if you use a direct cradle no. the libdir thing sounds more likely. you could try playing around with setting `NIX_GHC_LIBDIR`
12:05:54 <fresheyeball> so I wrote this type class inductive dealy do
12:05:56 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/7798505750a94c39d040ee968d8b275cd070f5b8/router/Shpadoinkle/Router/Server.hs#L59
12:05:59 <fresheyeball> and it compiles just fine
12:06:09 <fresheyeball> but consuming it, it says no instance arising
12:06:40 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/7798505750a94c39d040ee968d8b275cd070f5b8/examples/servant-crud/Server.hs#L81
12:06:45 <fresheyeball> here is the consumption
12:06:57 <fresheyeball> I have no idea why it doesn't find the instance, everything looks right
12:07:13 <rsoeldner> cocreature,thank you im not so familiar on how ghc\nix play together. When using `cabal v2-build` it will build all deps. Im using this in a nix-shell,  do you have any suggestion on where to point the NIX_GHC_LIBDIR, is it somewhere under .cabal/ ?
12:08:43 <fresheyeball> like the instances cover all cases
12:08:50 <fresheyeball> why isn't it finding it?
12:09:02 <fresheyeball> I think it has something to do with the `:>` case in servant
12:11:34 <jle`> fresheyeball: what's the error message ?
12:11:36 <cocreature> rsoeldner: ghc --print-libdir
12:11:54 * hackage first-class-families 0.7.0.0 - First class type families  https://hackage.haskell.org/package/first-class-families-0.7.0.0 (lyxia)
12:11:54 <rsoeldner> cocreatur thanks a lot
12:13:33 <fresheyeball>     • No instance for (ServeRouter
12:13:35 <fresheyeball>                          ("app"
12:13:37 <fresheyeball>                           :> (QueryParam "search" Shpadoinkle.Widgets.Types.Form.Search
12:13:39 <fresheyeball>                               :> Raw))
12:13:41 <fresheyeball>                          Route)
12:13:43 <fresheyeball>         arising from a use of ‘serveUI’
12:13:45 <fresheyeball> jle`: ^^
12:14:46 <jle`> can you show where you define that instance ?
12:15:52 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/7798505750a94c39d040ee968d8b275cd070f5b8/router/Shpadoinkle/Router/Server.hs#L96
12:15:55 <fresheyeball> jle`: ^^
12:16:16 <jle`> hm, i see the constraint ((path :> sub) :>> r) ~ (sub :>> r)) . is that satisfied in this situation?
12:16:23 <fresheyeball> yes
12:16:29 <ibloom> Here's another question: is it possible to define an instance as having a constrain such as instance (HasFoo a) => Bar a where... but I want this instance only to be selected if a has an instance of HasFoo. In other words another instance Bar MyType will not overlap this if there is no instance HasFoo MyType.
12:16:34 <fresheyeball> its an artifact of the type family not being injective
12:16:35 <ibloom> I run into this a lot.
12:16:48 <fresheyeball> ibloom: yes
12:17:11 <ibloom> Do I need to use the Overlapping pragmas?
12:17:12 <jle`> fresheyeball: where is (:>>) defined?
12:17:14 <fresheyeball> yes
12:17:37 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/7798505750a94c39d040ee968d8b275cd070f5b8/router/Shpadoinkle/Router.hs#L207
12:17:41 <fresheyeball> jle`: ^^
12:18:07 <ibloom> fresheyeball: So the first instance with HasFoo should be {-# Overlapping #-}
12:18:28 <fresheyeball> ibloom: or you can make the other {-# OVERLAPPABLE #-}
12:18:44 <ibloom> got it. I'll try those.
12:19:22 <ibloom> That worked immediately thanks.
12:19:53 <jle`> fresheyeball: hm, if you try compiling with something similar, like with ServeRouter (QueryParam "search" ... :> Raw) Route, what's the error?
12:19:56 <jle`> *simpler
12:20:30 <fresheyeball> jle`: it seems that no matter how small the api definition, it has the same "no instance arising" error
12:20:40 <jle`> not even like asking for ServeRouter Raw Route ?
12:20:53 <jle`> interesting
12:21:26 <jle`> maybe try cleaning and recompiling everything?
12:22:00 <jle`> or try adding something simple to the exports of Server and see if the main module can access it
12:25:23 <fresheyeball> jle`: it does work with just Raw :(
12:28:47 <stites> hey all! I have a question about modelling "Let" expressions in a free+interpreter style -- would this be a good place to ask it?
12:29:06 <jle`> fresheyeball: funky
12:29:33 <jle`> fresheyeball: so Raw works but now, say, "app" :> Raw ?
12:32:54 <stites> oops! I think I got it, nevermind!
12:35:08 <fresheyeball> jle`: ok, Raw does not work
12:35:22 <fresheyeball> I was wrong, the type checker stopping at a different place, does not mean it works
12:35:25 <fresheyeball> it does not work
12:35:33 <fresheyeball> No instance for (ServeRouter SPA Route)
12:35:36 <fresheyeball>         arising from a use of ‘serveUI’
12:35:39 <fresheyeball> type SPA = Raw
12:35:48 <fresheyeball> data Route = Foo
12:35:55 <fresheyeball> even with that little, it does work
12:36:58 <fresheyeball> jle`: give me a bit, I am making progress with your approach
12:37:35 <phadej> is there a name for (Either a b -> c) <-> (a -> c, b -> c) isomorphism?
12:37:57 <phadej> (a bit like (a -> b -> c) <-> ((a,b) -> c) is curry/uncurry)
12:38:02 <fresheyeball> ok ok
12:38:05 <fresheyeball> Raw DOES work
12:38:09 <fresheyeball> but "app" :> Raw
12:38:12 <fresheyeball> does NOT work
12:38:35 <phadej> :t uncurry either 
12:38:37 <lambdabot> (a -> c, b -> c) -> Either a b -> c
12:38:38 <phadej> hmm
12:38:51 <phadej> other direction is trickier
12:39:35 <solonarv> phadej: hmm, it corresponds to the 'c^(a+b) = c^a c^b' theorem/law in algebra
12:40:03 <solonarv> that probably has a name you can borrow, but I don't remember what it is
12:40:19 <fresheyeball> jle`: it's official it's the :> instance
12:40:34 <fresheyeball> even though it's the case, it's not enough to convince ghc
12:41:59 <jle`> fresheyeball: maybe the path :> sub instance is tripping up on polykinds? try using explicit kind variables maybe
12:43:59 <dmj`> Cale: I think {-# LANGUAGE OverloadedLambdas #-} would be cool, true embedding of ASTs in Haskell
12:44:51 <fresheyeball> jle`: can I have an injective type family associated with a typeclass?
12:45:25 <jle`> fresheyeball: yes
12:45:32 <phadej> solonarv: looking e.g. at awodeys CT book, there's an exercise to show that A^(B+C) ~= A^B x A^C; and indeed it's trivial; but no name
12:45:35 <jle`> type AssType a = c | c -> a
12:45:35 <fresheyeball> jle`: what is the syntax?
12:46:16 <jle`> fresheyeball: ^
12:49:54 <solonarv> phadej: I was actually referring to "good old numbers" when I said "algebra"
12:51:09 <phadej> solonarv: gool old numbers form a category too
12:55:06 <fresheyeball> jle`: well it turns out it's just not injective
12:55:55 <EvanR> numbers alone barely form anything. But numbers with operations and relations 
12:56:24 <fresheyeball> can't fun dep my way out either
12:56:52 <EvanR> numbers alone is like... an infinite set of indistinguishables
12:56:57 <phadej> :t (|||) :: (a -> c) -> (b -> c) -> Either a b -> c
12:56:59 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:57:43 <phadej> that's fanin, but fanout is a bit different; i.e. not an inverse
13:00:30 <dasli> Is it just me or does ScopedTypeVariables only work when you explicitly quantify the variables in question with "forall"?
13:00:48 <jle`> it is all of us
13:01:20 <dasli> Do you know why? The "forall" is there implicitly at the top, I thought.
13:01:32 <jle`> why like why it was chosen this way?
13:02:02 <dasli> Yeah. It seems like the exact same case treated two different ways.
13:02:46 <jle`> hm. i guess maybe one reason why is so that you can still have unscoped variables if you want
13:02:56 <jle`> so you can selectively scope or non-scope within the same file
13:03:10 <EvanR> i call the same bullshit as dasli. If the forall is implicitly there... but it doesn't do what "being there" does, is it there or not?
13:03:27 <boxscape> hm, weird question, once unsaturated type families are a thing, would it in principle be possible to (possibly after more changes) have a "type family Id a where Id a = a" and then "instance Functor Id where fmap = id"?
13:03:29 <EvanR> too many forms of "is"
13:04:06 <solonarv> boxscape: no, unless the definition of Functor is changed as well (and it probably won't be for this)
13:04:21 <EvanR> forall is implicitly half there, with ScopedTypeVars on
13:04:40 <dasli> "Implicitly Half There" haha
13:04:52 <geekosaur> it's because the word "forall" implies scope when used. which is a sort of pun.
13:05:04 <solonarv> unsaturated type families will be implemented by distinguishing between a type family/synonym and a type constructor at the kind level
13:05:58 <boxscape> hm, actually it also looks like there's something more general preventing type families from being instances; "type family X where X = ()", "instance Show X" doesn't work at the moment.
13:06:22 <boxscape> (even with TypeSynonymInstances)
13:06:49 <dasli> I guess ScopedTypeVariables is an extension, so I guess it can be expected to be a little idiosyncratic.
13:07:23 <boxscape> dasli it is an extension, but it is one that many people want to be part of the standard
13:07:42 <geekosaur> actually there's a sizeable group of people who think it should be the default
13:07:54 <geekosaur> without any keyword needed to evoke it
13:08:26 <dasli> Is this "forall" inconsistency going to stay? It took me forever to infer on my own.
13:08:28 <geekosaur> but there's also worry about breaking programs that don't expect it, since H98 specified otherwise
13:08:35 <geekosaur> yes
13:08:38 <fresheyeball> jle`: looks like (path :: Symbol) fixed it
13:09:20 <jle`> hm, that's weird
13:09:31 <jle`> that should have been inferred from the KnownSymbol constraint
13:09:32 <jle`> unless ...
13:09:35 <jle`> % :k KnownSymbol
13:09:36 <yahb> jle`: ; <interactive>:1:1: error: Not in scope: type constructor or class `KnownSymbol'
13:09:43 <fresheyeball> I didn't have a knownSymbol constraint
13:09:44 <jle`> % import GHC.TypeLits
13:09:44 <yahb> jle`: 
13:09:47 <jle`> % :k KnownSymbol
13:09:47 <yahb> jle`: KnownSymbol :: Symbol -> Constraint
13:09:50 <fresheyeball> I had equational constraints
13:09:54 <jle`> fresheyeball: ah. i could have sworn you did
13:10:08 <fresheyeball> I did try it in my debugging though
13:10:09 <jle`> that's interesting :) i wonder what it was being inferred as before
13:10:11 <fresheyeball> and it was not enough
13:10:15 <jle`> did you have PolyKinds or TypeInType on?
13:10:20 <fresheyeball> no
13:10:41 <stites> meerp, got stuck again -- would anyone be able to help me model let expressions in this toy-dsl?
13:10:59 <dasli> ScopedTypeVariables should use a different keyword to create a scope. Reusing `forall` is some C++ kind of stuff.
13:11:28 <EvanR> haskell definitely has a penchant for reusing syntax
13:11:31 <geekosaur> there's not a lot of room to steaal new keywords from without breaking programs
13:11:58 <geekosaur> hence reusing one that already meant some form of scoping in practice, that had already been stolen
13:13:13 <dasli> I get that
13:13:35 <jle`> fresheyeball: ah so it must have gotten inferred as (path :: *)
13:13:38 <jle`> interesting
13:14:10 <dasli> Seems like breaking programs with type variables named "inscope" or something is a small price to pay for consistency, which everywhere else seems to be a priority.
13:14:12 <jle`> but yeah, i think adding KnownSymbol to the constraints should also have the same effect as annotating (  .. :: Symbol )
13:15:31 <dasli> Wait is "forall" itself a GHC thing?
13:15:36 <geekosaur> yes
13:15:46 <dasli> Ah
13:16:48 <jle`> fresheyeball: sometimes when i do type level stuff i like to turn on -fprint-explicit-kinds
13:16:56 <jle`> to catch things that are normally hidden like this
13:17:12 <fresheyeball> jle`: nice tip!
13:17:39 <jle`> it does make the errors a little uglier though for type operators like (:>)
13:18:31 <dasli> So the rule that top-level type variables are implicitly given a "forall" quantifier is not part of the standard. So breaking it is...not breaking the standard, just breaking GHC's convention...
13:18:45 <dasli> Computers.
13:19:30 <jle`> i also suppose my justification for this behavior is moot because you can always just shadow variables with another forall
13:19:38 <fresheyeball> dmj`: one more type class induction to write, and we can derive servers for spa routers (server side spa rendering), and cannonical routes!
13:19:54 <dmj`> fresheyeball: nice :) !
13:20:06 <geekosaur> the rule is sort of part of the standard, but not in that form. there's a discussion of scope, which doesn't allow for either ScopedTypeVariables or RankNTypes
13:21:07 <dasli> OK. Well I do want those features available.
13:21:09 <geekosaur> and in particular "forall" is just an identifier, with no particular meaning (strictly speaking not all "keywords" in Haskell are actually keywords)
13:22:19 <boxscape> geekosaur do you mean by that that they are only keywords if specific extensions are enabled? Or something else?
13:22:41 <geekosaur> "qualified" can be used as an identifier because it can never conflict with its use in import statements, for example
13:22:42 <boxscape> Or that forall isn't a keyword on the term level?
13:22:48 <boxscape> ah, okay
13:22:52 <geekosaur> so it's not a keyword as such
13:25:26 <geekosaur> or "as", which would probably annoy more people if it were a keyword :)
13:25:47 <dasli> Cool thanks for the edification.
13:40:03 <fresheyeball> lets say I have a type like this
13:40:12 <fresheyeball> data Foo = Bar Int | Baz String | Qux
13:40:33 <fresheyeball> is there a way I can automate a lambda for this?
13:40:53 <fresheyeball> right now I am thinking something like this with poly kinds
13:40:58 <maerwald> manually writing a Read instance via Text.Parse is more confusing than any actual parser combinator lib
13:41:29 <fresheyeball> class Lamby (a :: k) where a -> ExistentializedThing
13:41:51 <fresheyeball> then I could do something like
13:42:01 <fresheyeball> class Lamby (a :: k) where process :: a -> ExistentializedThing
13:42:04 <fresheyeball> then I could do something like
13:42:16 <fresheyeball> process <$> [Bar, Baz, Qux]
13:43:24 * hackage refractor 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/refractor-0.0.0.0 (MatthewFarkasDyck)
13:48:17 <maerwald> wonder who came up with that api -.-
13:52:57 <dmj`> shapr: made a PR
13:53:38 <shapr> oh?
13:53:58 <shapr> oh!
13:54:40 <shapr> yeah, davean and I are scratching our heads about property based tests failing with LocalTime, and I suspect timezone weirdness
13:54:53 <solonarv> fresheyeball: [Bar, Baz, Qux] is a type error, so you can't do anything with it
13:55:01 <fresheyeball> solonarv: I know
13:55:29 <solonarv> then I don't know what you want
13:56:20 <solonarv> what do you want the type of 'process Bar' to be?
13:58:29 <fresheyeball> solonarv: https://gitlab.com/fresheyeball/Shpadoinkle/blob/crud-example2/examples/servant-crud/Types.hs#L168
13:58:36 <dmj`> shapr: for the binary instance?
13:58:40 <fresheyeball> I am trying to eliminate having to write this function
13:58:48 <fresheyeball> this is the last thing I want to derive somehow
13:58:57 <fresheyeball> there is no reason I should have to write this out
13:59:07 <fresheyeball> all the needed information is here
13:59:10 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/crud-example2/examples/servant-crud/Types.hs#L157
13:59:23 <fresheyeball> I am trying to get to a point, where I just need the one mapping
13:59:56 <pie_[bnc]> I dont suppose anyone has seen some sort of "database of datastructure invariants" anywhere?
14:01:46 <monochrom> I would not expect the invariants to be taken out of context like this.
14:02:23 <monochrom> "big table of all data structure invariants but not the explanations of the data structures themselves"
14:02:31 <shapr> dmj`: I learned something nifty, there are some format strings that cannot function for read.show / parse.encode 
14:02:57 <shapr> now I'm curious how often that's an interesting property
14:03:13 <dmj`> shapr: that's odd
14:04:41 <shapr> my original format string had a mistake: "%M/%d/%y %H:%M:%S" two uses of capital M when the first one should be lowercase m
14:05:41 <monochrom> This is because nothing checks format strings for redundancy, injectivity, etc.
14:06:02 <monochrom> Nothing stops you from %m/%m%m %m:%m:%m.%m either.
14:06:11 <shapr> if nothing else, you can't expect (read.show x == x) to be true when I haven't put enough of the date/time into the show
14:08:22 <dmj`> shapr: well, maybe we should only care about parsing then
14:09:44 <GreyFaceNoSpace> whats wrong here? https://pastebin.pl/view/67311d13
14:09:50 <GreyFaceNoSpace> i am trying to learn haskell
14:10:24 <monochrom> Yes, what's wrong?
14:11:46 <GreyFaceNoSpace> i had the wrong signature for the function
14:11:50 <GreyFaceNoSpace> it compiles now
14:11:59 <shapr> hurrah!
14:12:07 <koz_> I'm trying to build HIE. Wanted to check options with 'cabal new-run -w /path/to/ghc/bin/ghc ./install.hs help'. This fails, saying it doesn't know what 'hie-install' is. What am I missing?
14:12:10 <GreyFaceNoSpace> but i'll be back soon because i am having some trouble with haskell in general :D
14:12:56 <EvanR> general haskell is an imposing figure
14:13:05 <EvanR> not to be trifled with
14:13:06 <koz_> EvanR: As opposed to Colonel Haskell.
14:13:07 <shapr> GreyFaceNoSpace: got any specific questions?
14:13:14 <koz_> Who will give you immutable fried chicken.
14:13:55 <dmj`> @src nub
14:13:55 <lambdabot> nub = nubBy (==)
14:13:55 <lambdabot> --OR
14:13:55 <lambdabot> nub l = go l []
14:13:55 <lambdabot>   where go []     _       = []
14:13:55 <lambdabot>         go (x:xs) ls
14:13:57 <lambdabot>             | x `elem` ls = go xs ls
14:14:00 <lambdabot>             | otherwise   = x : go xs (x:ls)
14:14:20 <EvanR> immutable fried chicken, now that's point free
14:14:30 <monochrom> haha koz_
14:14:46 <koz_> EvanR: The secret blend of herbs and spices is skolemized.
14:14:53 <GreyFaceNoSpace> shapr, yeah. but i don't have code examples right now. so i'll come back and show you guys the code i am having trouble with
14:15:01 <GreyFaceNoSpace> shapr, i can'
14:15:30 <GreyFaceNoSpace> shapr, i can't seem to take advantage of haskells pattern generation in complex problems.
14:15:46 <GreyFaceNoSpace> shapr, but its better if i show you what i mean when i have an example with some code
14:16:26 <koz_> (also I figured out that my problem came from not reading properly in my exuberance)
14:18:00 <monochrom> I haven't heard of haskell's pattern generation.
14:18:17 <monochrom> Is that why I'm still writing code myself?
14:21:16 <koz_> OK, HIE is being really annoying. My exact command is 'cabal new-run ./install.hs -w /home/koz/ghc-88/bin/ghc --project-file install/shake.project help', but I don't get a list of targets. Instead, I get usage information. What am I not doing here?
14:21:49 <maerwald> list of targets? :>
14:21:53 <maerwald> shake doesn't have that
14:22:09 <koz_> maerwald: Their own docs say that this gives you that information.
14:22:13 <koz_> So does the help text I see when I try that.
14:22:17 <maerwald> Ah, then they wrote that manually
14:22:41 <koz_> maerwald: This is what I get: http://paste.debian.net/1128399/
14:23:11 <koz_> Changing 'help' to '-- help' has no effect.
14:23:29 <koz_> Am I missing something here?
14:23:55 <maerwald> works for me
14:24:23 <koz_> With the -w argument?
14:24:29 <maerwald> https://paste.debian.net/1128400/
14:24:43 <maerwald> maybe omit the -w
14:24:52 <koz_> I can't, because new-run needs a GHC.
14:24:57 <codebam> how do I get cabal to install this package? this is the error I get: https://termbin.com/u10b
14:25:02 <codebam> the package I'm trying to install
14:25:07 <codebam> https://github.com/kbonne/pandoc-plantuml-filter
14:25:22 <maerwald> cabal v2-run -w ghc-8.6.5 install.hs --project-file install/shake.project help -- works for me
14:25:44 <koz_> Ah, order matters, lol.
14:26:00 <maerwald> zomg
14:28:49 <koz_> maerwald: I only see 'latest' as an option. None of 'hie-8.*'.
14:28:53 <koz_> Yours is a git clone?
14:29:12 <fresheyeball> there has got to be a way to polymorphically iterate over type constructors
14:29:31 <fresheyeball> maybe Generics?
14:29:41 <koz_> fresheyeball: Would be the place I'd begin.
14:30:12 <GreyFaceNoSpace> https://pastebin.pl/view/ed4fbaf2      This is the error i get :  foo.hs:4:1:  parse error (possibly incorrect indentation or mismatched brackets) 
14:30:24 * hackage rate-limit 1.4.2 - A basic library for rate-limiting IO actions.  https://hackage.haskell.org/package/rate-limit-1.4.2 (AdamWick)
14:30:27 <GreyFaceNoSpace> can someone explain to me why?
14:32:03 <maerwald> koz_: I see hie-8.8.2 
14:32:06 <fresheyeball> GreyFaceNoSpace: your where statement
14:32:08 <maerwald> and a bunch of others
14:32:10 <fresheyeball> you need to indent
14:32:13 <koz_> maerwald: I don't.
14:32:13 <maerwald> koz_: yes, git clone
14:32:16 <phadej> GreyFaceNoSpace: there's nothing on 3rd lien after =
14:32:17 <koz_> Mine too.
14:32:23 <phadej> fresheyeball: no he doesn't, need to
14:32:39 <koz_> I'll go from a clean clone, and if I still don't see anything, I'm reporting this.
14:32:39 <phadej> (one could, but it's not necessary in this example)
14:32:41 <GreyFaceNoSpace> oh i forgot to type in c
14:32:49 <phadej> GreyFaceNoSpace: +1
14:32:52 <GreyFaceNoSpace> but i still get parse error on '|'
14:33:04 <phadej> no = before |
14:33:13 <phadej> on 4th line, drop =
14:33:22 <phadej> foo x y | x < y = ...
14:33:29 <GreyFaceNoSpace> oh
14:33:30 <phadej> not: foo x y = | x < y = 
14:33:51 <phadej> those are common ones :)
14:33:54 <fresheyeball> oh wait
14:34:00 <fresheyeball> helper [] _ c = 
14:34:03 <fresheyeball> is not a complete expression
14:34:16 <phadej> fresheyeball: already solved ;)
14:34:37 <fresheyeball> phadej: what does your resolution look like?
14:34:58 <fresheyeball> what is the base case for helper?
14:35:14 <monochrom> c
14:35:34 <GreyFaceNoSpace> thank you guys
14:35:49 <GreyFaceNoSpace> i think i am just having trouble with the indentation
14:35:51 <GreyFaceNoSpace> and syntax
14:40:58 <fresheyeball> is there a way I can make ghc poop out the Generic structure it derives?
14:41:40 <maerwald> koz_: just tried to build hie-8.8.2 target... it failed
14:41:50 <maerwald> so you're not missing much :P
14:42:13 <codebam> sorry but would someone be able to help me install this package?
14:42:34 <codebam> using cabal
14:43:19 <shapr> codebam: looks like that package has the bound set for an earlier version of the Haskell compiler
14:43:45 <codebam> oh hmm. is there no way I'd be able to install it then?
14:43:52 <shapr> codebam: you can probably change the dependency and it'll likely work
14:44:27 <codebam> ohh okay
14:44:29 <codebam> trying that
14:44:31 <codebam> thank you
14:44:45 <shapr> codebam: if you change this line: https://github.com/kbonne/pandoc-plantuml-filter/blob/master/pandoc-plantuml-filter.cabal#L63 
14:45:09 <mniip> fresheyeball, -ddump-deriv
14:45:16 <shapr> and replace that last part with <4.13
14:45:18 <fresheyeball> mniip++
14:45:22 <fresheyeball> jle`++
14:45:27 <maerwald> --allow-newer=base
14:45:48 <shapr> yeah, that too
14:46:18 <maerwald> seems the package is dead: https://github.com/kbonne/pandoc-plantuml-filter/pull/8
14:46:49 <codebam> maerwald oh cool thanks
14:47:24 <maerwald> this is one of the few scenarios where trying stack might be worthwhile...
14:47:37 <maerwald> it's supposed to work with lts-5.2
14:56:58 <GreyFaceNoSpace> sorry to bother you again guys. https://pastebin.pl/view/fab20785         ->  i dont understand whats wrong here. the logic seems fine to me. 
14:58:07 <monochrom> How do you know it's wrong?
14:58:21 <fresheyeball> GreyFaceNoSpace: I don't think you can pass _ as a value
14:58:31 <GreyFaceNoSpace> oh
14:58:35 <maerwald> and even if you could, it would be ambiguous
14:58:36 <fresheyeball> you can use _ to ignore values, but I don't thinkg you can pass it in as an argument
14:58:43 <GreyFaceNoSpace> ok
14:58:49 <GreyFaceNoSpace> so i have to use variables here
14:59:11 <ChaiTRex> GreyFaceNoSpace: yep
14:59:51 <koz_> maerwald: Well, I reported what I'm seeing anyway, so let's see.
15:00:13 <koz_> I had some suspicions that they supported cabal new-anything, so I guess it might just be that.
15:00:39 <maerwald> well, they do
15:04:31 <codebam> so that package didn't compile :(
15:04:48 <codebam> this seems more recent, but I also can't get it to compile https://hackage.haskell.org/package/pandoc-plantuml-diagrams
15:05:07 <GreyFaceNoSpace> i dont understand. what the problem is. it won't let me compile and the error is. I changed it to this https://pastebin.pl/view/fc1ae0df because it kept complaining about the tuple
15:05:11 <maerwald> codebam: I thought I would never say that, but maybe try stack
15:05:20 <codebam> lol okay
15:06:00 <maerwald> stack seems like a good idea for archiving software
15:06:59 <ChaiTRex> GreyFaceNoSpace: What error message?
15:08:12 <GreyFaceNoSpace> ChaiTRex, https://pastebin.pl/view/3d56c56d
15:09:17 <ChaiTRex> GreyFaceNoSpace: First line is key. Ord means the comparison functions like (>) and (>=)
15:09:34 <ChaiTRex> GreyFaceNoSpace: You use those comparison functions, but you don't require the type (a) to have them.
15:09:39 <GreyFaceNoSpace> so i cant use < > == with out ord?
15:09:43 <ChaiTRex> GreyFaceNoSpace: Right.
15:09:47 <GreyFaceNoSpace> ...
15:09:53 <GreyFaceNoSpace> is there a reason for this?
15:09:55 <ChaiTRex> GreyFaceNoSpace: So, add that to your (Eq a, Num a) part.
15:10:00 <solonarv> you can use == with Eq
15:10:06 <GreyFaceNoSpace> ok
15:10:10 <solonarv> (and /=)
15:10:17 <GreyFaceNoSpace> ok
15:10:31 <ChaiTRex> GreyFaceNoSpace: Yep, not all types that have Eq or Num are necessarily totally ordered. Sometimes, it doesn't make sense to ask whether one value is less than another.
15:10:46 <solonarv> for a simple example: complex numbers!
15:10:51 <GreyFaceNoSpace> so for this exercise. i have to figure out a way of solving the problem with out using < and > since i cant change the signature
15:11:10 <ChaiTRex> GreyFaceNoSpace: Are you forced to use that signature?
15:11:16 <GreyFaceNoSpace> yeah
15:11:20 <ChaiTRex> :t signum
15:11:21 <GreyFaceNoSpace> but its ok
15:11:22 <lambdabot> Num a => a -> a
15:11:25 <GreyFaceNoSpace> i think i know what to do
15:11:36 <ChaiTRex> GreyFaceNoSpace: OK.
15:11:42 <GreyFaceNoSpace> ChaiTRex, yes i was gonna use signum
15:12:09 <codebam> stack didn't work either. something about ghc-pwd
15:12:12 <codebam> [error] utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: exec: line 3: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: not found
15:12:36 <solonarv> signum doesn't really help here
15:12:57 <solonarv> checking whether the number is <, ==, or > 0 works fine
15:13:15 <ChaiTRex> solonarv: They're forced to use a type signature not including Ord.
15:13:23 <solonarv> oh, how dumb
15:13:25 <solonarv> well then
15:13:49 <solonarv> I guess you'll have to use signum and check whether the result is -1, 0, or 1
15:13:59 <edmundnoble> Is the `*` modifier for `:module` supported when using `-fobject-code`?
15:14:17 <phadej> yes
15:14:23 <edmundnoble> There's a complaint that "module X is not interpreted" when using the `*` modifier
15:14:27 <edmundnoble> But not without iftg
15:14:29 <edmundnoble> it*
15:14:30 <phadej> hmm
15:14:34 <phadej> or maybe it isn't
15:14:49 <maerwald> codebam: what distro is this?
15:14:49 <solonarv> ...and of course there is no guarantee that signum's return value is always one of those three, so you need some awkward fallback case
15:14:51 <phadej> I think it should work, as doctest works
15:15:08 <phadej> no, you right, doctest doesn't work with -fobject-code
15:15:14 <solonarv> now either your function is sneakily partial (if you used 'error' or just omitted the fallback), or sneakily wrong
15:15:23 <ChaiTRex> :t fromInteger
15:15:26 <lambdabot> Num a => Integer -> a
15:15:35 <ChaiTRex> :doc signum
15:15:51 <ChaiTRex> lambdabot has failed us for the last time!
15:16:02 <ChaiTRex> % :doc signum
15:16:02 <yahb> ChaiTRex: ghc: Can't find any documentation for GHC.Num.; This is probably because the module was compiled without '-haddock',; but it's also possible that the module contains no documentation.; Try re-compiling with '-haddock'.
15:16:05 <maerwald> https://github.com/commercialhaskell/stack/issues/2717 maybe that's relevant, I dunno
15:17:06 <solonarv> unfortunately the only law for signum is 'signum x * abs x = x'
15:17:28 <ChaiTRex> It's weird to even have signum in Num.
15:17:37 <solonarv> yes, Num is a weird hodgepodge
15:17:46 <jle`> i have become num to it
15:17:47 <edmundnoble> thanks phadej
15:18:14 <solonarv> and signum/abs are really the worst offender in Num, imo
15:18:18 <jle`> fromInteger
15:18:30 <solonarv> that would not be so bad if it were expected to do 'mod'
15:18:30 <jle`> is a major whoopsie
15:18:59 <solonarv> because then it would just be the canonical injective ring homomorphism from Z
15:20:08 <solonarv> the rest of Num is fixable by simply teasing it apart into a small hierarchy (additive, semiring | additive group, ring)
15:20:09 <ChaiTRex> They also implemented gcd and lcm wrong. They should be typeclass functions with default implementations. As it is, you can't do gcd x y where x and y are variables in some Expr type without weird hacks or bottom.
15:20:25 <ChaiTRex> That's more in Integral, but still.
15:20:36 <solonarv> but I don't even know where signum and abs in those forms are supposed to go
15:29:24 * hackage warp 3.3.9 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.9 (KazuYamamoto)
15:43:27 <dmj`> signum is underrated
15:45:55 <hseg> I have a situation isomorphic to Applicative/Monad -- given an instance of C, I can write an instance of D, but giving an instance once and for all would overlap all other potential instances 
15:46:08 <hseg> Thought DefaultSignatures would help here, it didn't
15:46:20 <hseg> Probably misunderstood the intent of DefaultSignatures
15:47:25 <hseg> Rereading the manual, seems that all it will gain me is not needing to write the instance body
15:47:34 <hseg> but still need to declare the instance
15:56:20 <lyxia> that's right
15:57:51 <Axman6> yeah no types are automatically made an instance of any class
16:04:52 <jle`> there is one 'exception'
16:04:56 <davean> Typeable
16:05:33 <jle`> oh, i was thinking of a different one
16:05:50 <jle`> i guess there are (at least) two exceptions
16:06:04 <davean> I was sitting here wondering if I should start the debate
16:07:00 <jle`> hm
16:07:14 <jle`> i suppose you can actually create a typeclass that every type would be automatically made an instance of
16:08:06 <jle`> but the 'thing' there is that that universal instance would be the *only* non-overlapping instance that can be defined so i guess it's still a weird special case
16:08:32 <jle`> but yeah the example i was thinking of is Coercible
16:08:50 <davean> oh theres that also
16:10:14 <jle`> but yeah, there are only these degenerate cases --- built into the compiler, or universal overlapping-all instances
16:10:38 <davean> They're all extremely existential
16:10:51 <davean> depending on how you define "Haskell"
16:20:52 <dminuoso> I would say that Coercibile is not a typeclass at all.
16:21:02 <dminuoso> It's just a constraint that magically exists.
16:21:18 <dminuoso> You wouldn't say that ~ is a typeclass either, would you?
16:26:19 <hpc> it's just a function with Constraint to the right of the (->)
16:26:47 <dminuoso> fsvo "function"
16:28:32 <aarvar> for the correct value of "function"?
16:28:36 <hpc> you're just not using the haskell 2030 spec :D :D :D
16:32:49 <jle`> dminuoso: that's fair actually
16:32:52 <jle`> this is what the documentation says:
16:32:58 <jle`> Coercible is a special constraint with custom solving rules.
16:32:59 <jle`> It is not a class.
16:33:16 <jle`> er, those last two lines are the quote
16:34:42 <jle`> however you do use it like a typeclass, api-wise and syntactically ...
16:35:06 <dminuoso> jle`: I like to think of `Functor` the typeclass and `Functor` the constraint-producing kind function as two separate entities.
16:35:18 <dminuoso> One just happens to implicitly create the other.
16:35:29 <hpc> it's like thinking of types and data definitions separately, i imagine
16:35:48 <dminuoso> It's how I mentally allow for ~ to exist. :)
16:44:24 * hackage inline-c-cpp 0.4.0.2 - Lets you embed C++ code into Haskell.  https://hackage.haskell.org/package/inline-c-cpp-0.4.0.2 (FrancescoMazzoli)
16:51:00 <ChaiTRex> [itchyjunk]: Did the PATH setting work?
16:51:10 <[itchyjunk]> I didn't :<
16:51:24 <ChaiTRex> [itchyjunk]: Let me find a quick horrid workaround.
16:53:03 <ChaiTRex> [itchyjunk]: sudo ln -s /opt/ghc/bin/* /usr/local/bin
16:53:07 <[itchyjunk]> I was looking at 1) in this https://hackprogramming.com/2-ways-to-permanently-set-path-variable-in-ubuntu/
16:53:15 <ChaiTRex> [itchyjunk]: It's ugly, but it should work.
16:53:24 <ChaiTRex> [itchyjunk]: PATH is preferred to what I just put, though.
16:54:12 <ChaiTRex> [itchyjunk]: Ahh, yes. 1 looks like a good method if it works.
16:54:20 <[itchyjunk]> let me try
16:54:22 <ChaiTRex> [itchyjunk]: It'll set up the PATH for all users.
16:55:26 <ChaiTRex> [itchyjunk]: Hmm, it doesn't edit /etc/environment. Weird.
16:55:45 <[itchyjunk]> Hmm, says PATH command not found :s
16:56:16 <ChaiTRex> [itchyjunk]: Yeah, looking at that page, it's not correct.
16:56:24 <ChaiTRex> [itchyjunk]: Let's see.
16:57:04 <[itchyjunk]> this says i can directly export a new path
16:57:05 <[itchyjunk]> https://linuxize.com/post/how-to-add-directory-to-path-in-linux/
16:57:34 <ChaiTRex> [itchyjunk]: export just changes it for your current shell. Once you close it, it's gone.
16:57:46 <[itchyjunk]> ah
16:57:51 <ChaiTRex> [itchyjunk]: You have to edit a file somewhere to make it work on reboots and such.
16:58:29 <ChaiTRex> [itchyjunk]: https://askubuntu.com/a/170240/616451 says you can edit /etc/environment and add a line like: PATH=/opt/ghc/bin:$PATH
16:58:42 <[itchyjunk]> thhere is a profile.d in /etc/
16:59:00 <[itchyjunk]> hmm i think i added something to environment.d yesterday
16:59:10 <ChaiTRex> [itchyjunk]: Hmm, my /etc/environment has a PATH setting.
16:59:46 <ChaiTRex> [itchyjunk]: If yours says PATH="something", you can change it to PATH="/opt/ghc/bin:what was there before"
16:59:58 <ChaiTRex> [itchyjunk]: Let me see if this works. BRB.
17:00:01 <[itchyjunk]> ah i can add there i suppose
17:01:33 <ChaiTRex> [itchyjunk]: Yep, that worked on 18.04.
17:01:52 <[itchyjunk]> i added /opt/ghc/bin in my /etc/environment
17:01:56 <[itchyjunk]> let me reboot
17:02:50 <ChaiTRex> [itchyjunk]: /etc/environment now contains one line: PATH="/opt/ghc/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
17:05:03 <[itchyjunk]> ah that works now.
17:05:15 <[itchyjunk]> i needed to edit environment
17:05:45 <Bad_K4rMa> you get ghci working [itchyjunk]?
17:06:31 <[itchyjunk]> updated to 8.6 so i can use :doc
17:06:49 <Bad_K4rMa> whats :doc?
17:08:13 <ChaiTRex> Bad_K4rMa: In GHCi, it shows the docstring for a function.
17:08:14 <[itchyjunk]> hmm good question
17:08:19 <ChaiTRex> Bad_K4rMa: Like :doc head gives
17:08:19 <[itchyjunk]> yes that
17:08:43 <ChaiTRex> Prelude> :doc head
17:08:45 <ChaiTRex>  Extract the first element of a list, which must be non-empty.
17:08:58 <ChaiTRex> Bad_K4rMa: I think it requires GHC 8.6.
17:09:14 <ibloom> Ok here's another overlapping typeclass problem: let's say I have a 'class Foo x' and an 'instance {-# OVERLAPPABLE #-} MustBar x => Foo x where , finally I have a function doBar :: Foo x => x -> x. Apparently ghc will assume that doBar will require MustBar x since, it think,  it will assume it can only select the Foo x instance.
17:10:14 <ibloom> I'd like DoBar to work for any instance of Foo, not just the ones with the MustBar constraint.
17:10:28 <Bad_K4rMa> i have v8.8,2
17:11:00 <ChaiTRex> Bad_K4rMa: Try :doc head in GHCi.
17:11:02 <jle`> ibloom: i try to avoid dealing with instance overlaps at all
17:11:12 <ChaiTRex> BRB
17:11:31 <ibloom> jle: I feel you.
17:11:31 <jle`> "just say no" to overlapping instances
17:11:34 <jle`> it's going to bite you sooner or latter
17:12:43 <ibloom> I think the issue is keeping things polymorphic. In my case all of my instances have functors and type parameters that I can't really make concrete so this is popping up alot.
17:13:05 <ChaiTRex> [itchyjunk]: Oh, do: sudo rm /etc/environment.d/haskell.conf
17:13:10 <boxscape> ibloom the constraints of an instance are not part of constraint resolution
17:13:15 <ChaiTRex> [itchyjunk]: That'll get rid of the unworking thing we tried before.
17:14:01 <[itchyjunk]> ok
17:14:22 <boxscape> ibloom though I'm not entirely sure if that's what you're having an issue with
17:14:33 <ibloom> boxscape: That's what I thought but its popping up.
17:15:25 <boxscape> ibloom bottom line, you cannot have `instance Constraint1 => Foo x` and `instance Constraint2 => Foo x`, even with overlapping pragmas, because the instance heads are the same. not sure if that's what you're trying to accomplish.
17:16:26 <ibloom> boxscape: here's the actual code that is causing the problems. https://github.com/ianmbloom/gudni/blob/texturetransformation/src/Graphics/Gudni/Figure/Transformable.hs
17:17:10 <ibloom> In another file the compiler is suggesting that a function requires a pointcontainer.
17:17:27 <ibloom> sorry PointContainer constraint.
17:18:22 <ibloom> So I'm assuming the compiler selected the last instance of SimpleTranslatable and is applying the constraint to the function.
17:18:27 <boxscape> hmm that seems right at first glance assuming you're using the function with a Point2...
17:19:20 <boxscape> you can try adding {-# OVERLAPPING #-} to the non-pragma'd instances but it shouldn't make a difference
17:19:40 <ibloom> Yeah the basic idea is that any datatype that is really a collection of points can be operated on in the same ways.
17:19:59 <ibloom> That's what PointContainer is for.
17:21:05 <boxscape> would it be possible to just make a PointContainer instance for Point2 instead of having overlapping instances here?
17:23:31 <ibloom> Well, I have a lot of data structures that you can just map over all of the points for certain transformations while keeping the underlying structure. So I figured I'd just create one typeclass for mapping over all the points and then I just need one instance of Transformable (and many other things) for all of those data structures.
17:25:00 <boxscape> Yeah, I was suggesting keeping that one general instance, and having it work on Point2 by making Point2 a PointContainer as well, but whether or not that makes sense depends on PointContainer, I suppose
17:25:16 <boxscape> ah wait
17:25:25 <boxscape> that instance uses the Point2 instance of Transformable
17:25:29 <boxscape> that complicates things
17:26:12 <ibloom> Here's the definition for pointContainer https://github.com/ianmbloom/gudni/blob/texturetransformation/src/Graphics/Gudni/Figure/Point.hs
17:27:00 <ibloom> It just defines two basic functions, one for extracting the points, and another for mapping over them.
17:27:29 <boxscape> hm, yeah what I suggested probably doesn't work regardless of PointContainer since what the Transformable instance does needs to be different depending on whether or not it's a Point2
17:40:36 <ezzieyguywuf> if a have a function that takes an "container"-type "MyType a" and, say, an `Int` and uses the `Int` to provide some info about `MyType a`...is there a convention for either `getData :: Int -> MyData a -> a` or `getData :: MyData a -> Int -> a` 
17:55:16 <ibloom> ezzieyguywuf: The way to decide that is to consider which parameter you are most likely to map over.
17:55:33 <ibloom> My guess is you are most likely to map over the Int.
17:56:12 <ibloom> In an expression like 'map (getData someData) indices'
18:06:29 <ezzieyguywuf> ibloom: ah, good point
18:06:56 <ezzieyguywuf> :) thanks
18:10:57 <boxscape> is the best way to combine a list of functions with Endo to do coerce, mconcat and then appEndo? Or is there a syntactically nicer way?
18:18:51 <boxscape> hm though actually that's not as bad as I thought since you don't have to supply any types to coerce like you sometimes have to
18:19:24 * hackage pathological-bytestrings 0.1.0.0 - Pathological ByteStrings for testing  https://hackage.haskell.org/package/pathological-bytestrings-0.1.0.0 (vmchale)
18:20:21 <boxscape> but it looks like what I'm looking for is lens's ala, probably
18:30:30 <dibblego> you can just use Wrapped if you want to sue the Endo monoid
18:30:33 <dibblego> *use
18:32:42 <boxscape> dibblego I'm not sure what exactly that means - right now I have `ala Endh foldMap functionList`
18:32:50 <boxscape> s/Endh/Endo
18:33:46 <Cale> boxscape: maybe you just want foldr (.) id ?
18:34:15 <boxscape> heh, yeah I suppose that works too
18:34:38 <Cale> The main reason to use Endo is if you really need something which is an instance of Monoid for some reason, e.g. if you're using WriterT
18:34:45 <boxscape> I see
18:35:25 <olligobber> Flip Endo is better than Endo
18:35:32 <boxscape> why is that?
18:35:42 <ChaiTRex> Flip Endo is a Harry Potter spell.
18:35:49 <boxscape> fair
18:35:50 <olligobber> left to right function composition
18:35:54 * hackage arduino-copilot 1.3.0 - Arduino programming in haskell using the Copilot stream DSL  https://hackage.haskell.org/package/arduino-copilot-1.3.0 (JoeyHess)
18:36:08 <boxscape> I see
18:39:20 <emg_bfc> first time here was wondering if anyone could point me in the right direction for a problem im having I have a Monad App a = App { unApp :: ReaderT AppEnv IO a } and need access to the App inside of ScottyT e App but can't seem to get the instance right to access it
18:40:58 <ezzieyguywuf> what is `ScottyT e App`?
18:41:42 <emg_bfc> newtype ScottyT e m a  ScottyT	 
18:41:46 <emg_bfc> runS :: State (ScottyState e m) a	
18:42:31 <ezzieyguywuf> *shrug* lol I'm lost sorry
18:42:50 <emg_bfc> so am i
18:44:59 <ezzieyguywuf> lol
18:45:07 <ezzieyguywuf> what do you mean "get the instance right"?
19:02:57 <nshepperd> is there any way to tell ghc to ignore $HOME/.ghc/arch-os-version/environments/default
19:04:52 <ezzieyguywuf> nshepperd: looks like `-i` resets the search path to nothing. I guess that's the "nuke" option, you'd have to rebuild the search path, though, after that...
19:05:33 <nshepperd> yeah i just want it to act like that file doesn't exist
19:06:37 <ezzieyguywuf> hm
19:06:38 <ezzieyguywuf> why?
19:07:04 <nshepperd> i'm trying to write an aur package for cabal-install
19:07:11 <nshepperd> and build it using ./bootstrap.sh
19:07:33 <nshepperd> but ghc finds the default environment file in my $HOME which completely screws up the build
19:08:18 <ezzieyguywuf> shouldn't you be developing the aur package in some sort of 'sandbox'?
19:08:40 <nshepperd> i want it to be buildable on any old user machine
19:09:03 <ezzieyguywuf> a simple solution could be to create a new user and develop the aur package as that user, which would get its own /home/newuser dir without the file in question
19:09:34 <ezzieyguywuf> a better solution would be to develop the aur file in a docker environment or virtual environment
19:09:41 <ezzieyguywuf> nshepperd: I don't see what that has to do with anything
19:10:25 <nshepperd> it's a script that's intended to be run by users to build cabal from source. i'm not distributing the binary
19:10:46 <nshepperd> i want them to not have to muck around with docker or new users
19:11:52 <nshepperd> this used to work by running ./bootstrap.sh --sandbox which used v1-style sandboxes to isolate it from user stuff, but it seems like environment files override even that now or something
19:14:03 <nshepperd> hm, unsetting HOME seems to be working
19:14:10 <nshepperd> bit of a sledgehammer though
19:24:24 * hackage reflex-ghci 0.1.4.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.4.0 (abrar)
19:29:55 <Axman6> emg_bfc: what do you want to do with your App monad?
19:39:21 <nshepperd> aww, bootstrap.sh fails after successfully building cabal due to HOME: getAppUserDataDirectory:getEnv: does not exist (no environment variable)
19:42:11 <koz_> :t flip runStateT
19:42:13 <lambdabot> s -> StateT s m a -> m (a, s)
19:42:26 <koz_> :t flip runStateT 0
19:42:28 <lambdabot> Num s => StateT s m a -> m (a, s)
19:42:33 <koz_> Oh, cool.
19:54:57 <informer[m]> Hi. Anyone know how I can assign a cabal flag? `-fDesktop=False` gives me the following error: `Invalid flag assignment: Desktop=False`.
19:55:33 <informer[m]> I want to set the desktop build settings to be the default and I need to set the desktop flag to false and then set the Web flag via. "-fWeb".
19:55:56 <informer[m]> or maybe there is a better way to do this?
19:57:19 <glguy> Try: -f-Desktop
19:58:08 <informer[m]> glguy: awesome, thank you!
20:01:09 <emg_bfc> I wanted to access my App monad in ScottyT e m a but there's no instance for MonadReader for ScottyT it looks like there were a couple PR's for this that never got merged so instead I did this ugly work around App (ScottyT LText App ()) which works fine but I'm getting a performance drop around 20-30x so I decided to just make my middleware outside my scotty server and pass it as an argument
20:02:26 <emg_bfc> it just would be nice to be able to do appEnv <- ask in ScottyT and then define my middleware before adding the routes 
20:03:25 <Axman6> you should be able to use lift get
20:11:42 <d34df00d> Hi!
20:11:58 <d34df00d> I have a little program that streams in a lazy bytestring and does something to it.
20:12:19 <d34df00d> +RTS -sstderr statistics show `MUT     time    0.101s  (  0.172s elapsed)`
20:13:00 <d34df00d> The file from which the string is streamed is in tmpfs, and this behaviour is pretty stable across runs (so all the OS caching is already happening, if it makes sense for tmpfs).
20:13:16 <d34df00d> Is it possible to make the elapsed time closer to the consumed CPU time?
21:41:14 <alc> why there's no splitOn in Data.ByteString?
21:41:26 <alc> how to split ByteString?
21:51:10 <pavonia> alc: There's breakSubstring which can be used in a loop to get the effect of splitOn
21:52:35 <alc> pavonia: breakSubstring return a tuple, but I'd like that splitOn's list
21:53:19 <pavonia> That's why I said you need to use it in a loop
21:53:52 <alc> pavonia: wait, ByteString is just a list of Word8?
21:54:17 <alc> it means I can use Data.List.Split.splitOn that [Word8] ?
21:54:22 <pavonia> A compact one
21:54:33 <pavonia> No, that won'T work
21:55:07 <alc> map (\i -> if (i == 73) then 79 else i) msg
21:55:14 <alc> this msg :: ByteString
21:55:19 <alc> pavonia: this work
21:56:39 <pavonia> It's a specialized version of map
21:57:48 <alc> pavonia: can I use this Data.ByteString.map to handle ByteString just like handle [Word8]?
21:58:21 <alc> oh, there's no Data.ByteString.splitOn
21:58:28 <alc> meaningless
21:58:40 <pavonia> Depends what you mean by that. You can map a Word8 -> Word8 function
21:59:15 <pavonia> The documentation even has an example function tokenise x y = h : if null t then [] else tokenise x (drop (length x) t) where (h,t) = breakSubstring x y
21:59:45 <pavonia> which is basically splitOn for ByteString
22:00:59 <alc> pavonia: why there's no function can convert ByteString to Text or String?
22:01:22 <sclv> there is!
22:01:35 <sclv> unpack
22:01:59 <alc> unpack :: ByteString -> [Word8]
22:02:08 <alc> it's not [Char]
22:02:59 <sclv> use data.bytestring.char8
22:03:11 <pavonia> alc: Because there a dozens of ways for such a conversion
22:03:23 <pavonia> and there already are packages that provide several of them
22:03:44 <sclv> same underlying type, but as a representation of char instead of word8
22:04:07 <sclv> ?hoogle ByteString -> String
22:04:09 <lambdabot> Control.Lens.Internal.ByteString unpackStrict8 :: ByteString -> String
22:04:09 <lambdabot> Control.Lens.Internal.ByteString unpackLazy8 :: ByteString -> String
22:04:09 <lambdabot> Data.ByteString.Lazy.UTF8 toString :: ByteString -> String
22:04:10 <pavonia> http://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html
22:04:25 <alc> pavonia: then why it shouldn't be Data.ByteString?
22:04:42 <pavonia> "it"?
22:05:13 <alc> the conversion is not in Data.ByteString
22:05:20 <sclv> ByteString is packed Word8. Word8 is _not_ char, because char includes characters that span two words
22:05:26 <sclv> char is codepoints, which don't all fit in a word
22:05:42 <sclv> but Data.ByteString.Char8, in the same package, gives you an API to the same type that does provide functions that pretend it is Char
22:05:47 <sclv> so just use that module if you want
22:06:21 <sclv> ?hoogle ByteString -> [Char]
22:06:22 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
22:06:22 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
22:06:22 <lambdabot> Encoding utf8DecodeByteString :: ByteString -> [Char]
22:07:00 <alc> ok
22:07:02 <pavonia> alc: ByteStrings are binary data without an inhered meaning. If you want to interpret them as text, use the text package
22:14:19 <ChaiTRex> @hoogle ByteString -> Text
22:14:20 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
22:14:20 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
22:14:20 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
22:18:54 * hackage network-uri 2.7.0.0 - URI manipulation  https://hackage.haskell.org/package/network-uri-2.7.0.0 (EzraCooper)
22:52:57 <jackdk> I am fiddling with constraints/constraints-extras stuff and seek to construct a proof of Show (Identity a) => Show a
22:53:18 <jackdk> Here is a pastebin of what I have, and the broken code at the bottom https://www.irccloud.com/pastebin/Gx5gDcVr/Constraints.hs
23:00:29 <dminuoso> Mmm, I remember a talk about an approach lets you do the equivalent of higher kinded datatypes like `data User k = { name :: k String, ...}`, but without type families for getting rid of Identity
23:00:34 <dminuoso> Can someone recall what that might be?
23:02:10 <jackdk> that's the hkd stuff where you have a type family to hide the Identity, but that's not quite what I want here
23:02:52 <dminuoso> jackdk: Oh it's unrelated to your topic.
23:09:54 * hackage directory 1.3.6.0 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.3.6.0 (Rufflewind)
23:15:04 <jackdk> there might be a hack to pass HKD into the various constraints to make it work, which is the type family you talked about: https://reasonablypolymorphic.com/blog/higher-kinded-data/ . That's next week's problem though :-). Peace.
