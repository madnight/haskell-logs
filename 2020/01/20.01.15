00:00:22 <dmj`> swift is only kind of a trash language, not completely trash
00:01:54 <koz_> dmj`: Based on what I've seen, it aggressively lacks any ideas of its own.
00:02:44 <dmj`> koz_: yea its like kotlin, swift and rust are all kind of similar
00:03:07 <koz_> I think Rust actually _has_ ideas of its own.
00:03:12 <koz_> Can't speak for Kotlin.
00:03:58 <dmj`> syntactically they're all a little similar
00:04:01 <dmj`> generics, etc.
00:04:16 <dmj`> but yea, swift doesn't have separation logic borrow checker stuff
00:04:20 <koz_> dmj`: Syntactically, every industry language is C with whistles.
00:04:26 <koz_> (no really)
00:04:45 <dmj`> koz_: whistles are nice
00:04:57 <dmj`> koz_: here's my (hot) take on swift. 
00:05:56 <hyiltiz> Is the definition for `stimes` in the haskell wiki missing the counter by 1? https://wiki.haskell.org/Data.Semigroup
00:06:01 <hyiltiz> https://wiki.haskell.org/Talk:Data.Semigroup
00:06:29 <hyiltiz> The page says `stimes` applies the binary operation `x` times, while in fact, the binary operation is applied `x-1` times to `x` elements in total. In the example `3 * 3 * 3 * 3`, `*` is applied three times (not four), to four elements. 
00:06:48 <dmj`> koz_: the LLVM guy wrote it and only really cared about SIL (swift intermediate lang.) which serves as an IR that can be translated to very efficient LLVM code. The front end of the language was created after the fact and lacks any kind of formal spec and is not amenable to lexing / parsing in any kind of way. Apple didn't care since they like weird languages (objective-C) and stuff closed source... like parts of SwiftUI
00:07:08 <Solonarv> hyiltiz: the phrasing is unclear, yes
00:07:21 <dmj`> koz_: the faux-BNF spec on swift's website even says, "this spec is not meant to serve as a BNF for lexing / parsing"
00:07:42 <Solonarv> I usually prefer the phrasing "stimes n x is n copies of x, combined using <>"
00:08:47 <koz_> dmj`: That explains... a lot.
00:09:43 <dmj`> koz_: it's a sad state of affairs, you'd think a trillion dollar company would care about PLT. They pretend to care, they really do, showing pics of Haskell in their slides (that they copied directly off of haskell.org), but deep down, they don't care at all.
00:10:00 <koz_> dmj`: _That_ doesn't surprise me any.
00:10:48 <dmj`> The one surprising good thing about Swift is its C FFI. Which shows promise for Haskell interoperability. 
00:11:46 <dmj`> But sadly, most Apple frameworks are either large OOP hierarchies (very ugly to model in Haskell), or like SwiftUI, fantastic, yet closed-source in crucial parts necessary for interop.
00:12:36 <dmj`> this is probably why a language-swift package has yet to be written
00:13:17 <dmj`> even if we had it, it wouldn't work well with the iPhone, since that would require an ARM setup, and cross compiling GHC requires nix (or a lot of tolerance for pain)
00:13:27 <dmj`> that's if we wanted an inline-swift package
00:13:55 <dmj`> the empire wins again
00:15:07 <dmj`> it would work well for desktop apps though
00:15:16 <dmj`> but who uses desktop apps
00:22:50 * koz_ raises hand.
00:22:57 <koz_> But I'm not on Apple anything so ehh.
00:23:56 <Solonarv> I'm using a desktop app right now! and it's not even a browser
00:23:57 <dmj`> I mean, but these days its just all about the iPhone
00:24:05 <dmj`> Solonarv: slack doesn't count
00:24:25 <dmj`> anything electron-based might as well be a website
00:24:34 <Solonarv> no, no, by "not even a browser" I meant to exclude electron as well
00:27:49 <dmj`> slack is electron
00:27:59 <dmj`> but I wouldn't classify it as a browser
00:28:09 <dmj`> well, I guess it is kind of a packaged up browser lol
00:30:37 <dmj`> Solonarv: what app
00:30:55 <Solonarv> my IRC client is Quassel
00:31:06 <Solonarv> it's a good old C++ Qt application
00:37:10 <dmj`> I use IRC on my phone via an iOS app :)
00:38:57 * yushyin uses IRC via weechat and weechat-android
01:02:54 * hackage hurl 0.1.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-0.1.0.0 (alcinnz)
01:25:56 <Uniaika> irssi ftw
01:34:54 * hackage gnuplot 0.5.6.1 - 2D and 3D plots using gnuplot  https://hackage.haskell.org/package/gnuplot-0.5.6.1 (HenningThielemann)
01:52:30 <dminuoso_> Is there a name for something like fromJSON and toJSON that is not exactly an isomorphism?
02:03:33 <Putonlalla> Algebraists call satisfying `f . g . f = f` and `g . f . g = g` a generalized inverse, dminuoso_.
02:04:07 <Putonlalla> You could also have an isomorphism up to some weaker equivalence relation.
02:08:32 <cdunklau> is there a pairing function? (\a b -> (a, b)) ? 
02:08:52 <Rembane> :t curry 
02:08:53 <cdunklau> i mean, the lambda is fine, but it seems like this should exist somewhere
02:08:53 <lambdabot> ((a, b) -> c) -> a -> b -> c
02:08:56 <cdunklau> not curry
02:08:57 <Rembane> :t uncurry 
02:08:58 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:08:59 <Putonlalla> Use `(,)`, cdunklau.
02:09:09 <Putonlalla> :t (,)
02:09:11 <lambdabot> a -> b -> (a, b)
02:09:25 <Solonarv> > (,) 1 2
02:09:28 <lambdabot>  (1,2)
02:09:29 <cdunklau> Putonlalla: ... of _course_ that's a function
02:09:30 <cdunklau> looool
02:09:39 <cdunklau> haskell, you never cease to amaze me
02:10:01 <cdunklau> thanks!
02:10:51 <merijn> cdunklau: With -XTupleSections it even works for arbitrary tuples
02:10:58 <merijn> > (,,) 1 'c' True
02:11:00 <lambdabot>  (1,'c',True)
02:11:02 <cdunklau> hahahahah
02:11:08 <merijn> > (,'c',) 1 True
02:11:10 <lambdabot>  (1,'c',True)
02:11:11 <dminuoso_> Putonlalla: Mmm okay
02:16:19 <jackdk> Anyone here have experience with the haskell platform on windows? I have installed the latest HP core onto a win10 machine, and cabal new-install seems to want to write a dist dir in C:\windows\system32, which unsurprisingly fails
02:18:29 <dminuoso_> Putonlalla: The notion of an isomorphism up to a weaker equivalence relation seems to capture my thoughts well enough. Cheers.
02:18:37 <dminuoso_> Let's see what I can do with that.
02:19:57 <AWizzArd> Let’s assume you want to introduce the tagless final style to your existing code. Would you add one file where you define the classes and their implementations? Or would you rather place the classes in some existing file that makes sense and add its implementation(s) right there?
02:22:15 <fendor> jackdk, hey! Personally, haskell platform hardly works for me, I switched to using chocolatey and installing just ghc and cabal with that
02:23:38 <jackdk> fendor: is that the standard recommendation these days? I am writing an install guide for a new wave of students and am happy to switch
02:24:14 <jackdk> also it turns out that uncommenting `-- user-install: True` so it stopped trying to system-wide install things helped
02:24:24 <jackdk> but installing programs still fails because windows doesn't have symlinks
02:24:27 <fendor> jackdk, I am not entirely sure, since I am not a windows dev, but I've read this blog post: https://hub.zhox.com/posts/introducing-haskell-dev/ which looks very promising
02:24:49 <Solonarv> oh, cabal 3.0 is able to install by copying binaries instead
02:25:00 <Solonarv> but I forget what the config option is called
02:25:00 <fendor> jackdk, for that, you need cabal-install 3.0.0.0, then you can do `--installmethod=copy`
02:25:30 <fendor> *--install-method
02:26:48 <jackdk> thanks fendor. I will give chocolatey a whirl. hopefully its msys integration is good enough
02:27:26 <fendor> jackdk, afaik, the haskell-choco maintainer made sure that it is a pleasant experience
02:27:37 <fendor> and since I switched to choco, I have fewer issues
02:42:33 <kahlil> test
02:49:24 * hackage udev 0.1.1.0 - libudev bindings  https://hackage.haskell.org/package/udev-0.1.1.0 (LeifWarner)
02:54:19 <Phyx-> jackdk: I would recommend using chocolatey, there I've tweaked the cabal settings to work out of the box
02:55:10 <Phyx-> cabal 3.0's defaults for `install` don't work on Windows as you've noticed :)
02:55:23 <Phyx-> as fendor mentioned :)
02:55:32 * Phyx- should really start at the top and work down with history
02:56:30 * Phyx- needs to check whether symlink support for Windows made it in..
02:58:02 <phadej> Phyx-: no, iirc I read through issue were you advocate to have default based on whether windows version supports it
02:58:10 <phadej> and I agree, but didn't get to that yet
02:59:10 * Phyx- will roll up his hands and help one of these days but GHC consumes all free time I have for 'other things' :/
02:59:14 <Phyx-> phadej: thanks :)
03:00:01 <phadej> if there's a code snippet to do the sniffing of whether symlinking is supported, that would help alone
03:00:21 <kahlil> Is it possible to have conditional endpoints in servant? Like based on a certain bool or some condition, either serve a certain endpoint or not? 
03:00:42 <Phyx-> phadej: I'll try to whip one up in C this weekend, if I forget do ping me
03:01:07 <Phyx-> and if easy enough I might just do it in Haskell straight away
03:03:46 <Phyx-> jackdk: btw, if switching from platform to chocolatey do make sure your cabal config is reset, if it has an errors in it then the chocolatey script won't touch it. easiest way to do that is run `cabal user-config init -f` before uninstalling platform
03:10:35 <matheus23_> test
03:11:37 <Phyx-> test fail
03:20:48 <Joe17> Hi! I'm doing an exercise with Accelerate where I have to write a segmented version of postscanl and postscanr. I don't really get what is expected of me, could someone help me out? "Implement segmentedPostscanl, segmentedPostscanr :: Elt a => (Exp
03:20:48 <Joe17> of postscanl and postscanr. They should compute a postfix scan per segment, e.g. the postfix should ‘start’ at a position with head flag True. Hints: lift the operator from Exp a -> Exp a -> Exp a to Exp (Bool, a)
03:20:49 <Joe17> -> Exp (Bool, a) -> Exp (Bool, a). Define the functions using the standard
03:20:49 <Joe17> "
03:21:42 <jackdk> Phyx-: Thanks for the heads-up. I wanted to replicate the clean-install experience as much as possible so I deleted all of %APPDATA%\cabal and that was fine
03:40:42 <steevveen> Hi! I'm not used to "mdo" , I saw it in the end of the page "do notation considered harmful"  https://wiki.haskell.org/Do_notation_considered_harmful . I think I saw it once (not sure), and I have no personnal notes about it. Any easy explanation, or idea where I might get an understanding of it ?
03:41:37 <Athas> joeyh: what's a postfix scan?
03:41:44 <Athas> Is that an inclusive scan or what?
03:44:29 <[exa]> steevveen: 'mdo' can magically reorder bindings so that mutually-recursive binding is possible (which is hard to imagine sometimes, but useful e.g. in reactive programming)
03:45:47 <[exa]> steevveen: AFAIK technically it's a generator of MonadFix calls
03:54:37 <haskeldjiq> guys
03:55:12 <haskeldjiq> there was this function
03:55:15 <haskeldjiq> very generic
03:55:19 <haskeldjiq> for Maybe it behaved like
03:55:27 <haskeldjiq> if you have a list [Maybe a] it gives you the first Just
03:55:28 <haskeldjiq> if any
03:55:34 <haskeldjiq> so [Maybe a] -> Maybe a
03:55:36 <haskeldjiq> can't recall the name
03:56:24 <Rembane> :t head . catMaybes
03:56:26 <lambdabot> [Maybe c] -> c
03:56:37 <Rembane> It does not wrap it the value in Maybe though.
03:56:44 <fendor> is `data A = B | C` still a product-type? And is `data A = B Int | C String` a sum-type?
03:56:47 <fendor> :t msum
03:56:49 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
03:56:56 <fendor> > msum [Nothing, Nothing, Just 3]
03:56:58 <lambdabot>  Just 3
03:57:27 <fendor> > asum [Nothing, Nothing, Just 3]
03:57:29 <lambdabot>  Just 3
03:57:32 <fendor> :t asum
03:57:34 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
03:57:47 <haskeldjiq> yeah I think it's asum
03:57:54 <haskeldjiq> thank you guys
03:58:07 <haskeldjiq> perfect
03:58:08 <merijn> steevveen: I would not take that page as community consensus
03:58:46 <merijn> steevveen: I agree that teaching people do notation right away is bad (but other people disagree), but for practically writing code it's fine
04:01:01 <fendor> According to wikipedia: A general algebraic data type is a possibly recursive sum type of product types. yes to both?
04:05:12 <steevveen> @merjin I did not take it as a consensus since do notation has been promoted even for Applicative (as I have not used it I don't remember what it implies for Applicative, I suppose a chaining of <*> stuffs, I have to look at that). However I find the article interesting. Indeed I was searching for resources for mastering do-notation desugaring. I
04:05:13 <lambdabot> Unknown command, try @list
04:05:13 <steevveen> feel it, but the intertwined variable scope is not clear into my mind. By the way, if you have a link that rings you a bell on that matter, I'm currently in the middle of that..
04:16:57 <cdunklau> fendor: both of what
04:32:39 <cdunklau> wow... i just mistakenly made an infinitely recursing thing and it was *efficient* at chewing up resources
04:32:42 <cdunklau> amazing :D
04:33:46 <cdunklau> i think it got up to 24GB within like, 20 seconds
04:34:06 <fendor> cdunklau, > <fendor> is `data A = B | C` still a product-type? And is `data A = B Int | C String` a sum-type?
04:34:58 <cdunklau> fendor: ah sorry missed that
04:35:07 <merijn> fendor: The second is a sum type, yes
04:35:19 <AWizzArd> Would it make sense to put postgresql-simple’s   query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]    into my own typeclass for which I want an IO implementation and a mock implementation?
04:35:23 <AWizzArd> The issue is that I need to put the constraints in there, which is fine for IO but not so much for my mock type.
04:35:52 <AWizzArd> Or is that query function simply too low-level and not worth it?
04:36:17 <AWizzArd> I would love to (mock-)test my simple IO actions that make use of query/fold.
04:36:25 <cdunklau> fendor: `data A = B | C` is a sum type of product types
04:36:45 <cdunklau> fendor: just, the product types are all nullary
04:37:07 <AWizzArd> Is there a way how I can make a generic type class type and specialize it to   query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]   only in the IO impl? And have some different signature in my mock type?
04:39:59 <AWizzArd> Possibly using the InstanceSigs extension?
04:40:09 <Solonarv> InstanceSigs won't help you
04:40:21 <Solonarv> but yes, if you're writing your own typeclass it's quite possible
04:40:34 <Solonarv> what are the two signatures you would like 'query' to specialize to?
04:40:58 <fendor> cdunklau, ok, thanks! wasnt sure about it
04:41:06 <AWizzArd> Solonarv: the first one is identical to the IO one. The one I gave above:  qury :: (FromRow r, ToRow q) => Connection -> Query -> q -> IO [r]
04:41:22 <Solonarv> yes, I was mostly asking what the other one is :)
04:41:54 <AWizzArd> In the `class MonadDB ...` I would like to give a more general signature, and make them more special.
04:42:13 <AWizzArd> Solonarv: The other one: I don't care for the connection and the query and the `q`. I want to throw them away. Instead I have in my test file a global constant which is just a list of tuples, representing my DB.
04:42:51 <AWizzArd> In the mock instance I want to reference that global "db" and use that. So, I don't need the two constraints and I don't care at all for the three parameters.
04:43:28 <Solonarv> instead of wiring in the mock DB I would suggest taking it as an argument
04:44:17 <AWizzArd> Solonarv: I could do that in the case of the mock implementation. But for the IO one I don't have a DB value that I could pass in.
04:46:23 <AWizzArd> So I would like to give a type in the class such as    query :: a -> b -> q -> m [r]     and in the instance for IO I want to “overwrite” this sig with the full sig from above. And in the mock I would want to leave it like that and simply ignore the parameters for a, b and q.
04:46:48 <Solonarv> hmmm
04:47:13 <Solonarv> okay, if you intend to only mock a *specific* set of data then this 'query' function is way more general
04:48:00 <AWizzArd> As soon as I explicitly mention Connection for example I would have to pass it in to the mock implementation too, and I would have to implement FromRow for my mock db.
04:48:17 <Solonarv> the approach should be closer to: MonadMyAppDb m where getThings :: m [Thing]; getStuff :: m Stuff; -- and so on
04:49:10 <AWizzArd> Solonarv: yes, I could do that and go a bit more highlevel. Currently I have a function fetchUser. It is very simple. I could put that one into my DB type class.
04:49:31 <Solonarv> yes, I think that is the right level for this sort of mocking
04:49:34 <AWizzArd> But: in that case I would not be able to test my fetchUser itself. It will have to stay a function returning an IO action.
04:49:59 <AWizzArd> The fetchUser function also some a very tiny bit of business logic. I wouldn't be able to test that against an abstract monad m.
04:50:20 <AWizzArd> So I thought I could start with that query thing so that even the basic DB functions can be tested.
04:50:23 <Solonarv> ah, well in that case fetchUser is not the right thing to turn into a typeclass method!
04:50:34 <Solonarv> you can certainly do that
04:51:36 <Solonarv> I can't really write up useful sample code right now, so the help I can offer is limited
04:51:49 <AWizzArd> My first show right now is to have a low-level class MonadDB or so which can do query/fold/withTransaction from postgresql-simple.
04:52:06 <AWizzArd> Solonarv: are you prett certain that _in principle_ it can be done?
04:52:25 <Solonarv> yes, people have in fact done this
04:52:27 <AWizzArd> That is: giving a more general sig in the class and specialize it only in the instance implementation?
04:52:52 <Solonarv> the things you are "specializing" have to be part of the class head
04:53:04 <Solonarv> that is how typeclasses work in the first place!
04:53:28 <AWizzArd> so, possibly a multi-param class might help?
04:53:28 <Solonarv> consider: class Functor f where fmap :: (a -> b) -> f a -> f b
04:53:46 <Solonarv> in 'instance Functor Maybe', 'f' is "specialized" to 'Maybe'!
04:53:53 <AWizzArd> Yes.
04:54:03 <Solonarv> yes, a multi-parameter type class might help
04:54:06 <AWizzArd> And in my cases it is specialized to IO and to my TestMock type.
04:59:53 <AWizzArd> Solonarv: yes, it seems that MPTCs can help. I could make it accept my implementations and made progress fixing the sigs. Thx. I guess this is the way to go.
06:02:32 <AWizzArd> With methods of a MultiParameterTypeClass I want to implement a function f which is very generic. A template so to say. Only at call sites of f I want to specialize types.
06:02:32 <AWizzArd> Now my issue is that when writing f I get errors of ambiguous type vars when calling methods from C. I know that they are ambiguous. I want them to be, in f.
06:03:14 <merijn> AWizzArd: If a method does not include *all* type parameters of the class you're hosed
06:03:29 <merijn> AWizzArd: Because the ambiguity is unresolvable
06:03:42 <merijn> Well, unless you start using FunctionalDependencies
06:05:28 <AWizzArd> merijn: I just started to look into FunctionalDependencies, but I am not sure that I know how to resolve this. I can have the dependency    ... | a b c -> d
06:05:29 <AWizzArd> But I would more like:   ... | m -> a b c d
06:05:29 <AWizzArd> I don't know if that is possible.
06:05:29 <AWizzArd> Or if that makes sense.
06:06:16 <merijn> It should work
06:06:30 <merijn> It means there can only be one instance for any 'm'
06:07:22 <AWizzArd> I am fine with having just one instance for a specific m.
06:08:01 <merijn> But then why have MPTC at all, as opposed to, say, hardcoding 'a', 'b', 'c', and 'd' or using a TypeFamily
06:08:34 <AWizzArd> But I want there to be an m = IO where a is a Connection for example.   But if my m = TestM I want `a` to be whatever, it just stays `a`.   I am not sure if that is allowed, because now my `a` for TestM is still a generic variable and implicitly also covers the Connection case.
06:09:11 <AWizzArd> merijn: I would be fine using type families if they could resolve my case.
06:09:55 <AWizzArd> merijn: a bit earlier I mentioned that I would like to use the tagless final style and abstract some of postgresql-simple’s functions into a type class. So I can have an IO implementation and one for mocking.
06:11:26 <AWizzArd> I have a    class Monad m => MonadDatabase m pool conn query q r where qry :: conn -> query -> q -> m [r]
06:11:31 <AWizzArd> Now here is the implementation for IO:   instance (FromRow r, ToRow q) => MonadDatabase IO PGConnPool Connection Query q r where  qry = query
06:12:09 <AWizzArd> But when I want to mock, then I don't care for the Connection or the Query or q. And r does not need the FromRow constraint.
06:12:44 <nshepperd> where does the pool come into it
06:13:52 <AWizzArd> nshepperd: The class also contains withPG, which is a wrapper around pg-simple’s  withPGConnPool connPool (\conn -> withTransaction conn (f conn))
06:14:11 <nshepperd> oh ok
06:14:18 <AWizzArd> When I want to mock, then I don't care for the Connection or the Query or q. And r does not need the FromRow constraint.
06:14:38 <AWizzArd> instance MonadDatabase TestM pool conn query q MyResultType where   qry _ _ _ = ...
06:15:59 <merijn> I dunno, why not just run tests against an actual DB?
06:16:34 <AWizzArd> In my fetchUser function I try to do     users <- withPG connPool undefined   and this already causes trouble, because it does not know what connPool is.
06:17:20 <AWizzArd> merijn: I don't want to force the test suite to run through SSH tunnels against AWS-hosted DBs. I want to do in-memory tests because just the business logic matters.
06:17:35 <AWizzArd> The speed gain of factor 1000 is also not bad for tests that should constantly run.
06:17:58 <AWizzArd> (i.e. a few microseconds vs a few milliseconds)
06:18:20 <nshepperd> there's actually two different ways to resolve an ambiguous type class
06:18:43 <nshepperd> (three, if you count TypeApplications, but that's terrible)
06:18:55 <nshepperd> the first way is FunctionalDependencies
06:19:01 <nshepperd> the second way is
06:19:45 <nshepperd> instance (FromRow r, ToRow q, pool ~ PGConnPool, conn ~ Connection, query ~ Query) => MonadDatabase IO pool conn query q r where  qry = query
06:20:37 <lortabac> AWizzArd: rather than mocking the database, an alternative approach would be to keep all the logic pure, by applying the transformations in memory and performing a delete/insert of the modified rows
06:20:50 <lortabac> AWizzArd: this way you can test the logic in isolation
06:21:10 <lortabac> AWizzArd: with a little bit of batching, you can even get good performance
06:21:44 <nshepperd> what I did there is replaced the concrete types in the instance head with type variables
06:22:02 <nshepperd> and then fixed the values of those variables in a constraint
06:22:45 <AWizzArd> nshepperd: I can give it a try. So far however my instance implementations were accepted by the compiler. It's actually calling `withPG` in `fetchUsers` that causes trouble. GHC doesn't know which specific call it has to make. I intentionally would want it to be unspecified here.
06:22:47 <nshepperd> which means that instance now matches whenever m is IO
06:23:09 <AWizzArd> Only callers of `fetchUsers` will either be in the IO monad or in the TestM monad. And then, at this call site, the concrete types will be known.
06:23:34 <AWizzArd> The concrete types of pool conn query and q though might still be generic, because they will be ignored in the case of TestM.
06:25:26 <nshepperd> AWizzArd: yes. the point is by doing this, ghc doesn't have to know what 'pool' is to determine which instance to use
06:26:21 <AWizzArd> nshepperd: I tried this, and I still have:   instance MonadDatabase TestM pool conn query q Malarle where   qry _ _ _ = ...
06:26:29 <AWizzArd> nshepperd: I tried this, and I still have:   instance MonadDatabase TestM pool conn query q MyResult where   qry _ _ _ = ...
06:28:15 <AWizzArd> fetchUser connPool username = ...   withPG connPool undefined  ...
06:28:30 <AWizzArd> It does not know what concrete type connPool has.
06:29:39 <nshepperd> you may or may not want to write 'instance (r ~ MyResult) => MonadDatabase TestM pool conn query q r'
06:29:44 <nshepperd> what's the actual error message
06:30:54 <AWizzArd> Could not deduce (MonadDatabase m pool conn0 query0 q0 r0) arising from a use of ‘withPG’ from the context: MonadDatabase m pool conn query q r  bound by the type signature for:  fetchUser :: forall (m :: * -> *) pool conn query q r. MonadDatabase m pool conn query q r => pool -> Username -> m (Maybe MyResult)
06:31:39 <AWizzArd> I tried   instance (r ~ MyResult) => MonadDatabase TestM pool conn query q r ...   which also did not resolve it yet.
06:31:44 <merijn> AWizzArd: How/why would it know what pool is?
06:32:12 <nshepperd> that looks like the problem is actually that it doesn't know what conn, query, q, or r are
06:32:55 <AWizzArd> nshepperd: very possible. And the thing is: in `fetchUser` I would not want to specify it. But of course, for testing purposes I could make them all Ints and just pass in Zeroes in the test case.
06:33:15 <AWizzArd> Maybe it would work if I specifiy concrete types for the TestM implementation.
06:34:38 <AWizzArd> But alas, also this doesn't resolve it yet.
06:34:53 <AWizzArd> The type variables ‘conn0’, ‘query0’, ‘q0’, ‘r0’ are ambiguous
06:35:12 <AWizzArd> It’s true. In `fetchUser` they _are_ ambiguous.
06:35:53 <AWizzArd> I can't fix them there. If I would specify Connection for example then it'll be the IO instance. But if I specify Int it would be TestM and couldn't be used in production anymore.
06:36:54 <AWizzArd> Essentially I would like to ask GHC to wait until it sees a specific call site of fetchUser. There it will check what Monad we are in. And only then decide which of my two implementations to call.
06:38:18 <nshepperd> you can do that by setting AllowAmbiguousTypes
06:38:42 <nshepperd> it should work as long as it knows the monad at the call site
06:39:16 <nshepperd> however, this abstract seems kind of wrong
06:39:20 <AWizzArd> I already have this extension enabled.
06:39:47 <AWizzArd> Here is a scaled-down version of my real existing IO function, which I want to make testable: https://pastecode.xyz/view/49bd2a6d
06:40:00 <nshepperd> hmm
06:40:01 <AWizzArd> The goal is to remove the concrete IO by an abstract monad m.
06:40:11 <AWizzArd> It’s just 3 lines, that function.
06:40:24 <nshepperd> oh yeah, that won't work sicne it's the call site inside fetchUser which is ambigous
06:41:46 <AWizzArd> I would like to replace it with something like:  https://pastecode.xyz/view/d574c4c4
06:42:06 <AWizzArd> The motivation came from reading about Tagless Final.
06:44:15 <AWizzArd> nshepperd: True, calling wPG there is ambiguous. The type vars are all still unresolved. I thought that this might be an okay idea, being inexperienced with it.
06:44:27 <AWizzArd> The tutorials are much more straightforward and have easier types :)
06:45:57 <AWizzArd> I could of course leave fetchUser as an IO function, and move *it* into a method of a type class. That would simplify things I reckon. But. Then I couldn't mock fetchUser anymore.
06:46:07 <AWizzArd> It has only very little logic in it, but still, it has.
06:46:37 <AWizzArd> If I wanted to test it then I would have to abstract the low-level functions such as query/withPG out, as I was attempting to do.
06:47:36 <AWizzArd> In my case fetchUser is more like a "template" of functions, a family of functions. At call sites this template gets specialized, simply by knowing what Monad I am in.
06:49:46 <nshepperd> the core issue here is that your methods don't contain all the type variables
06:50:40 <nshepperd> you can often solve such issues by splitting up your type class into separate type classes
06:51:00 <AWizzArd> nshepperd: okay, I just wanted to ask if splitting up then helps, if all vars have to be present.
06:51:35 <AWizzArd> nshepperd: is the issue that there is no method in the class that contains all vars? Or is it that I am not calling a method that contains all vars?
06:51:58 <nshepperd> the issue is that there are methods that do not include all vars
06:52:06 <nshepperd> *every* method needs to have all variables
06:52:06 <AWizzArd> I could easily add a foo which does contain all vars. I would just not be calling it. The instance implementation would however have such a method.
06:52:12 <AWizzArd> Ah okay. Every.
06:52:19 <AWizzArd> I will go and try splitting this thing up.
06:53:43 <nshepperd> AWizzArd: https://zlkj.in:9000/uploads/ac7db204f182e2f3/db.hs for instance
06:54:23 <nshepperd> I also think that some of these variables are redundant
06:54:56 <bbear> hello
06:54:57 <nshepperd> your mock instance should support the same Query type
06:55:27 <nshepperd> and the same qs and rs
06:58:01 <nshepperd> you can also add a functional dependency for pool and conn
06:59:10 <nshepperd> AWizzArd: that takes you to https://zlkj.in:9000/uploads/1c5626bdd93bee6f/db.hs
07:01:08 <AWizzArd> nshepperd: one sec, will have a look at your link.
07:01:30 <AWizzArd> nshepperd: in the meantime I tried this, which still has ambigious vars: https://pastecode.xyz/view/070ee576
07:01:43 <AWizzArd> nshepperd: your link doesn't work. Not sure if port 9000 is open to the outside world.
07:02:16 <nshepperd> wat
07:02:20 <nshepperd> it works for me
07:02:31 <shapr> works for me
07:05:15 <AWizzArd> nshepperd: okay, then it is my company’s internal firewall I guess.
07:05:18 <nshepperd> AWizzArd: http://dpaste.com/2T8677F
07:05:27 <AWizzArd> That opens
07:06:24 <AWizzArd> nshepperd: with functional dependencies I got my MonadDBTrans working. But the query version still has a problem, if I look at your paste.
07:07:04 <AWizzArd> nshepperd: there we specify   qry :: (FromRow r, ToRow q) => conn -> Query -> q -> m [r]   and that means that for the mock TestM monad the result would have to fullfil that FromRow constraint too.
07:07:20 <AWizzArd> My idea was to have this constraint only in the implementation for IO, but not in TestM.
07:07:48 <nshepperd> the constraint is something the user has to satisfy, not the implementation
07:07:50 <AWizzArd> For TestM I don't care for the Connection, not for a Query value, not for the query parameters `q`. And the result will just be some list of tuples for testing.
07:08:17 <nshepperd> you can ignore the query parameters in the implementation for TestM
07:12:22 <AWizzArd> nshepperd: okay, will try to work with something like this.
07:14:55 <nshepperd> the return value might be a bit of a sticky situation, if that FromRow class doesn't let you provide synthetic data
07:21:18 <AWizzArd> nshepperd: thanks for your tips, this is now a good bit closer to work it seems. Indeed, the FromRow constraint is still a little bit problematic, but I will look into it and see if I can fix it by giving some implementation for it.
07:22:06 <nshepperd> possibly the best option would be a class FromRow r => TestableRow r where { testRow :: [Text] -> r } or similar
07:22:29 <nshepperd> and then using TestableRow instead of FromRow in the definition of qry
07:22:58 <nshepperd> when you can call testRow in your implementation of TestM to supply the correct test data depending on the query
07:23:23 <AWizzArd> nshepperd: sounds like a good plan.
07:50:54 * hackage postgresql-simple-migration 0.1.15.0 - PostgreSQL Schema Migrations  https://hackage.haskell.org/package/postgresql-simple-migration-0.1.15.0 (ameingast)
08:05:23 * hackage arithmetic-circuits 0.2.0 - Arithmetic circuits for zkSNARKs  https://hackage.haskell.org/package/arithmetic-circuits-0.2.0 (sdiehl)
08:44:54 * hackage pan-os-syslog 0.1.0.0 - Parse syslog traffic from PAN-OS  https://hackage.haskell.org/package/pan-os-syslog-0.1.0.0 (andrewthad)
09:07:49 <Gurkenglas> There's a custom Tree with indices for each node, so I expect to indexed-traverse over all nodes 3 levels deep I want something like "icompose (:) customtreeindexedequality $ foldr (icompose (:)) (itselfwithindex []) $ replicate 3 $ plate .> customtreeindexedequality". Does that sound about right? Where do I find itselfwithindex?
09:08:40 <Gurkenglas> (That would make the index a list of length 4)
09:12:54 * hackage rocksdb-query 0.3.1 - RocksDB database querying library for Haskell  https://hackage.haskell.org/package/rocksdb-query-0.3.1 (jprupp)
10:57:54 * hackage secp256k1-haskell 0.1.7 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.1.7 (jprupp)
11:04:54 * hackage mattermost-api 50200.3.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.3.0 (JonathanDaugherty)
11:05:54 * hackage mattermost-api-qc 50200.3.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-50200.3.0 (JonathanDaugherty)
11:06:53 * hackage matterhorn 50200.6.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.6.0 (JonathanDaugherty)
11:11:53 * hackage call-alloy 0.2.0.4 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.0.4 (marcellus)
11:17:49 <gendarme> hello
11:29:53 * hackage secp256k1-haskell 0.1.8 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.1.8 (jprupp)
12:10:35 <ChaiTRex> > fmap (+1) Nothing
12:10:37 <lambdabot>  Nothing
12:11:54 <jle`> me irl
12:16:24 * hackage base64 0.3.1.1 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.3.1.1 (topos)
12:17:14 <topos> ^ for you stackage nightly people
12:20:58 <dasli> help
12:22:21 <topos> no
12:22:41 <dasli> haha sorry
12:22:49 <topos> yes :)
12:23:04 <topos> i'm joking what help do you need?
12:23:35 <dasli> I'm trying to figure out how to use emacs and irc at the same time.
12:24:04 <topos> ah so you truly need help in these dark times
12:24:20 <dasli> \/help \/help
12:24:42 <topos> i got that working back in the day, but decided Emacs should not have that part of my soul
12:24:54 <dasli> lol
12:32:39 <informer[m]> Hi, is there a way to break execution in GHCI? I need to run my program and then break it, set a new breakpoint and then continue.
12:33:15 <ChaiTRex> informer[m]: You can use error to stop a computation.
12:33:28 <dasli> there is some kind of breakpoint system
12:33:58 <informer[m]> ChaiTRex: sorry, I need to do it interactively.
12:34:22 <informer[m]> I tried breaking it with Ctrl+C but it wont let me continue with `:continue`.
12:34:35 <informer[m]> with the error: `not stopped at a breakpoint`
12:35:02 <ChaiTRex> informer[m]: I've never done it, but this looks useful: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html
12:38:09 <[exa]> informer[m]: you won't be very happy from what you see at the breakpoint, really
12:38:23 <[exa]> informer[m]: you might like to use Debug.Trace instead
12:40:46 <dasli> I've wanted to explore it more, but Mac OS kills ghci when I try to run my graphics stuff because of some BS.
12:41:27 <informer[m]> [exa]: I'm aware of the ghci debugging limitations but it would work suffice in my case.
12:42:38 <informer[m]> I could save program state and then re-inject that into the program but that's a really roundabout way of doing it when I could theoretically just fire up ghci, get the state to what I need it to be and then set a breakpoint when I know it's the next thing that will be triggered.
12:43:26 <informer[m]> for context: it's a game I'm writing.
12:45:11 <solonarv> I dimly recall there being a "break on exception" setting
12:45:24 <solonarv> ChaiTRex: what's with the ancient ghc version?
12:45:29 <solonarv> you linked to 7.6
12:45:46 <ChaiTRex> solonarv: Oh, I just googled and that came up.
12:45:55 <ChaiTRex> Let's see
12:46:43 <solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
12:46:53 <[exa]> informer[m]: the point is that the function and evaluation order is really messed up with comparison to the code, and usually you won't be able to e.g. inspect the variables because laziness
12:47:37 <solonarv> ah yes, it's -fbreak-on-exception or -fbreak-on-error to only break on uncaught exceptions.
13:11:42 <informer[m]> solonarv: awesome, that works. not with Ctrl+C unfortunately, but I just added a debug hotkey to my game that throws and catches an error which then breaks in GHCI.
13:26:12 <sm[m]> nice
13:28:54 * hackage haskoin-core 0.10.0 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.10.0 (jprupp)
13:46:31 <p0a> Hello, what is the mathematical foundation for haskells type system?
13:47:18 <p0a> I think there's atomic and composite types, but I am not sure where type classes fit in, for example
13:47:47 <oats> You know what would be really cool is a Haskell debugger with an interface where you visually move around through the syntax tree inspecting types and evaluating expressions
13:48:12 <p0a> oats: with oculus VR integration?
13:48:18 <oats> Yas
13:48:34 <oats> I guess this wouldn't mesh with lazy evaluation very well :p
13:50:45 <maerwald> I want an interface straight into my brain and not even have to open my eyes.
13:51:10 <p0a> maerwald: pandoras box, if you can do it, others can do it
13:51:19 * MarcelineVQ fetches the tasp
13:56:31 <p0a> ah nice, I found this document, Phil Scott "Some aspects of categories in computer science."
13:57:59 <fendor> oats, https://marketplace.visualstudio.com/items?itemName=phoityne.phoityne-vscode#overview looks cool, did you give it a try?
13:58:19 <oats> Ew, visual studio :P
13:58:57 <fendor> it is based on DAP, so any editor can adapt, I think
13:59:14 <fendor> https://hackage.haskell.org/package/haskell-dap
13:59:30 <oats> Actually it's pretty cool tho
13:59:41 <nil> p0a: system F, with extensions
14:00:27 <oats> Stepping through do-notation, very cool
14:00:41 <p0a> nil: thank you, looks like the document I linked to explains system F
14:02:54 * hackage tasty-hedgehog 1.0.0.2 - Integration for tasty and hedgehog.  https://hackage.haskell.org/package/tasty-hedgehog-1.0.0.2 (qfpl)
14:05:02 <MarcelineVQ> p0a: yeah though learnig about system f won't give you insight into classes afaik because system f is lower than that
14:11:06 <solonarv> typical GHC Haskell is actually based on system F_omega
14:12:24 <solonarv> possibly even standard haskell, if I'm reading things right
14:13:14 <MarcelineVQ> solonarv: quite possible since http://babel.ls.fi.upm.es/~pablo/Papers/Notes/f-fw.pdf seems more relevant to haskell than other papers just on f I saw
14:28:23 * hackage haskoin-node 0.9.15 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.15 (jprupp)
14:28:56 <p0a> MarcelineVQ: well maybe I will get a bit of insight
14:29:07 <p0a> MarcelineVQ: I won't force the reading on myself, if I enjoy it I'll read it :P
14:29:58 <p0a> solonarv: thank you, I don't see F_omega in the doc I linked but I think I can switch to a different document after I read about system F
14:45:18 <solonarv> p0a: I just skimmed the wikipedia article :>
14:48:46 <p0a> solonarv: I've been getting a bit more serious about understanding monads and classes and types because Yesod is quite involved
14:49:04 <p0a> so I have to learn more, but then I get a bit curious about what's under the hood :P
14:51:31 <skksskks> how does Void type work in haskell?
14:51:53 * shapr stares into the Void
14:51:55 <shapr> :t Void
14:51:56 <lambdabot> error:
14:51:56 <lambdabot>     • Data constructor not in scope: Void
14:51:56 <lambdabot>     • Perhaps you meant one of these:
14:52:20 <dansho> :k Void
14:52:22 <lambdabot> *
14:52:30 <solonarv> it is defined like this: 'data Void'
14:52:53 <solonarv> note that it is missing the usual '= <constructors>' part - so it has no constructors
14:53:01 <skksskks> in particular, how is it difference than say, Nothing in Maybe?
14:53:13 <skksskks> *different
14:53:14 <ChaiTRex> skksskks: Nothing is a value. Void has no values.
14:53:16 <dansho> :t Nothing
14:53:18 <lambdabot> Maybe a
14:53:25 <dansho> :k Maybe
14:53:26 <lambdabot> * -> *
14:53:28 <solonarv> this means you can't actually create a value of type 'Void'
14:53:50 <solonarv> if, in some bit of code, you have a 'x :: Void' then this code can't be reached
14:53:54 <skksskks> ah so nothing special about Void, I can make MyVoid and its practically the same
14:53:59 <Axman6> skksskks: its a type which doesn't have any values - it is often used to signify that something will not return any data, or that it is not possible for data to exist. the type Either Void Bool can only be the Right constructor because you cannot create the Left (without using bottom, ie something which never returns a value, like an exception or an infinite loop)
14:54:13 <solonarv> if you have a function that takes an argument of type 'Void', then nobody can ever call your function
14:54:17 <glguy> > [] :: [Void]
14:54:19 <lambdabot>  []
14:54:34 <Axman6> "data MyVoid" is all you need to define something exactly the same as Void
14:54:48 <glguy> With a [Void], you know that if it's anything, it's an empty list
14:55:07 <skksskks> this raises a problem, they must be isomorphic, but how can they be?
14:55:17 <skksskks> i thought there cant be morphism from Type -> Void
14:55:19 <solonarv> important caveat: due to 'undefined' and friends, you *can* create "values" of type 'Void' - this is very annoying for anyone who wants to truly rely on the above properties
14:55:36 <Axman6> All values of tyoe Void are exactly the same as all values of MyVoid, all zero of them
14:55:49 <solonarv> skksskks: that's ill-kinded, and also not quite true
14:56:08 <skksskks> haven't got to Kinds yet xd
14:57:07 <solonarv> hm, actually I guess it isn't necessarily ill-kinded... just rather pointless
14:57:21 <solonarv> but you were using 'Type' as a wild-card there
14:57:31 <solonarv> that's not what 'Type' is
14:57:48 <solonarv> since you haven't gotten to kinds yet and I need to sleep, I'll spare you the explanation of what it is
14:59:37 <skksskks> thats okay, i have much to learn!
15:08:46 <pounce> anybody in here read ``Category Theory in Context'' by riehl
15:12:08 <dansho> skksskks: the empty type is an initial object, so it's unique up to isomorphism by the universal property of initial objects...whether this is actually the case in Hask i dunno
15:12:31 <p0a> so if I have a class `class Foo m where f :: a -> m a'
15:12:38 <p0a> how can I provide an instance for `f' in this class?
15:14:43 <bbear> anybody here uses haskell in production / large scale projects ?
15:15:52 <maerwald> You looking to hire ppl? :P
15:18:11 <barx> I'd be concerned if the answer is no
15:22:02 <sm[m]> probably not what you mean, but I use it to run hub.darcs.net
15:22:44 <maerwald> in production is a technical term, doesn't mean you have to make money with it :)
15:23:39 <sm[m]> actually I do! $6.44 per week! 
15:25:12 <p0a> not too shabby
15:25:36 <MarcelineVQ> sm[m]: dosh
15:26:04 <bbear> well, a large project which makes money is what I call « in production »
15:26:08 <bbear> I'm just curious
15:26:47 <bbear> anyway we've had the C trend, then the PHP trend, then the Java Trend, then the python trend, wanting to know if there is a hint for the haskell trend.
15:28:50 <Axman6> I've used Haskell in production at several jobs, including my current one
15:35:42 <hpc> if you don't just count writing haskell, shellcheck is a big one for me
15:36:25 <sm[m]> https://wiki.haskell.org/Haskell_in_industry, but it's out of date (no mention of facebook's spam system)
15:37:01 <sm[m]> except in the links
15:39:31 <Axman6> yeah Sigma is certainly the largest production HAskell system, a few years ago it was processing 2,000,000 requests per second doing spam filtering for all of facebook, but I don't think we've heard much out of FB around Haskell usage for a while
15:41:45 <sm[m]> also, the haskell-based version of the cardano network should be here pretty soon
15:42:13 <sm[m]> or maybe the current main ("byron") network already is haskell-based, not sure
15:48:55 <p0a> Why do I get an error when I try f 3::Int? https://pastebin.com/ZFwf6cKW
15:50:10 <ChaiTRex> p0a: What error do you get?
15:50:21 <sm[m]> this will be the most distributed production haskell app
15:50:50 <p0a> ChaiTRex: Variable not in scope: foo :: Integer -> Int
15:51:05 <ChaiTRex> p0a: Well, it thinks that 3 is an Integer then.
15:51:13 <ChaiTRex> p0a: You probably want f (3 :: Int)
15:51:34 <p0a> ChaiTRex: Ah you are right, thank you 
15:51:34 <shachaf> p0a: That can't possibly be the error for the code you posted.
15:51:40 <ChaiTRex> p0a: :: applies to the whole expression in front of it, and f 3 as a whole being an Int is already known to be the return type of f.
15:51:42 <p0a> shachaf: that is true, but ignore that fact
15:51:48 <shachaf> No.
15:52:02 <p0a> Well I mistyped f for foo, but I wasn't before
15:52:06 <shachaf> Post the real actual full code with the real actual full error.
15:52:17 <p0a> It's okay the issue was precedence
15:52:54 <shachaf> "not in scope" would still not be the error.
15:53:01 <shachaf> It's good that you figured it out, I suppose.
15:56:54 <p0a> is it possible to define an instance for a method for every typeclass  already defined
15:57:19 <p0a> something like `class (Show m) => ShowExtended m where f :: m -> Int' and then f = length . show for every case of (Show m)
15:57:44 <p0a> instead of instance ShowExtended Int where f = length . show, instance ShowExtended Float where f = length . show, etc
15:58:00 <shachaf> You can just write that.
15:58:23 <shachaf> class Show m => ShowExtended m where { f :: m -> Int; f = length . show }
15:58:49 <amalloy> that doesn't get you the instances, which is the real issue
15:59:19 <ChaiTRex> You can also not use a typeclass and write f :: Show a => a -> Int; f = length . show
15:59:56 <amalloy> i bet you a dollar p0a wants the default behavior for most instances of show, but something fancier for some instances
16:00:29 <p0a> amalloy: that'd be nice
16:00:38 <amalloy> there are a number of reasons this can't work
16:00:54 <p0a> Got it, let's not get into that then :P
16:01:57 <p0a> can someone explain why ShowExtended String doesn't work?
16:02:24 * hackage z3 408.1 - Bindings for the Z3 Theorem Prover  https://hackage.haskell.org/package/z3-408.1 (IagoAbal)
16:02:30 <p0a> "Illegal instance declaration for 'ShowExtended String' (All instance types must be of the form (T t1 ... tn) where T is not a synonym."
16:02:54 <glguy> String is a type synonym, which don't get instances
16:02:56 <p0a> I think `type String = [Char]' is the synonym
16:03:07 <p0a> Why not?
16:03:20 <glguy> type synonyms don't introduce distinct types
16:03:54 <wildtrees> there should be extension you can enable to allow type synonyms in type classes iirc not sure if it would work for this instance though
16:03:55 <glguy> they behave identically to the type they are a synonym for, so you'd make the instance on [Char], introducing a separate issue
16:04:01 <hololeap> what about the TypeSynonymInstances extension?
16:04:19 <p0a> glguy: what is the separate issue introduced? It seems there's no way to know that you're dealing with a synonym or not
16:04:21 <glguy> It's a hack to resolve the type synonyms for you when making the instanaces
16:04:34 <glguy> p0a: type synonyms aren't an abstraction
16:04:48 <glguy> as the user you're expected to know what they are a synonym for
16:04:57 <glguy> They save some keyboard typing
16:05:04 <p0a> I see 
16:05:26 <p0a> so they're generally avoided in a library interface?
16:05:37 <glguy> Under standard Haskell you only make instances for the types you introduce with data and newtype, and on their own, not applied to anything other than type variables
16:05:48 <p0a> i.e. if I have a fantastic `foo' function it's better to have it foo :: ReallyLongType instead of foo :: ShortSynonym, right?
16:05:56 <glguy> They can be included in the library interface as a convenience, but the user will be expected to know what they mean
16:06:23 <p0a> Okay thanks. Is it possible to export a synonym but hide the type it stands for?
16:06:27 <glguy> no
16:06:35 <p0a> okay, thank you! that sounds reasonable
16:07:07 <ChaiTRex> p0a: If you want that, use newtype.
16:07:44 <ChaiTRex> p0a: It won't be a synonym, of course.
16:09:39 <p0a> ChaiTRex: thanks, I was just reading a bit about newtype
16:10:57 <p0a> it seems it has to do with lifting
16:13:05 <p0a> for example, when I write `data Any = Any { getAny :: Bool }' why is `Any' of type Bool -> Any?
16:13:40 <p0a> I thought in `data Any = Any ...', the first `Any' is the type, and the second the constructor. So I thought the constructor was empty (Any :: Any)
16:14:23 <glguy> first let's make it less confusing with: data Any = MkAny { getAny :: Bool }
16:14:28 <glguy> Any is the type constructor
16:14:37 <glguy> MkAny is the data constructor
16:14:47 <glguy> there's one field named getAny
16:15:13 <glguy> If we use MkAny as a value it corresponds to a function that takes all the fields and produces a value with type Any
16:15:26 <glguy> If we use MkAny as a pattern it's a pattern that matches that constructor and one field pattern
16:15:32 <p0a> aah got it, thank you. I will write this down because I will forget it undoubtedly
16:15:33 <glguy> whatever (MkAny True) = ...
16:15:52 <glguy> and then because you named the field getAny, you get a field accessor function for free: getAny :: Any -> Bool
16:16:19 <glguy> and then you can also use record syntax for values and patterns: MkAny { getAny = True }
16:28:15 <p0a> If I want to provide an instance for Show, for example, how can I know what is minimally required of me to provide?
16:28:27 <p0a> hackage shows 3 methods, showsPrec, show, showList
16:28:57 <hpc> there isn't anything automatic, the written documentation tells you
16:29:12 <p0a> got it, thank you
16:29:14 <shachaf> Does Hackage also tell you what the "minimal complete definition" is?
16:29:20 <hpc> oh wait, maybe it is automatic now
16:29:27 <hpc> Minimal complete definition
16:29:27 <hpc> showsPrec | show
16:29:32 <p0a> shachaf: it says showsPrec | show, but I don't know what that means
16:29:37 <p0a> Does it mean either will do?
16:29:38 <hpc> it's either of those
16:29:40 <hpc> one or the other
16:29:55 <p0a> so if both were required it'd be something like showsPrec & show?
16:30:18 <hpc> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num is a good example
16:30:26 <hpc> showsPrec, show
16:31:07 <p0a> hpc: and what did you mean by ``oh it's automatic now''?
16:31:35 <hpc> p0a: you write     {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} and it formats it
16:33:58 <p0a> nice, thank you hp
16:42:16 <maerwald> is there a way to make the imports less verbose in brittany?
16:58:06 <sm[m]> a nice little game prototype: https://www.reddit.com/r/haskellgamedev/comments/ep33o9/gamejamd_a_game_with_apecsgloss_spacemar/
17:09:18 <MarcelineVQ> really quite cool. minus points for not having the cabal file in the repo :>
17:11:20 <MarcelineVQ> it's neat slingshotting around the planets
17:11:41 <hpc> showing the trajectory is nice
17:11:55 <MarcelineVQ> yeah cause you can get a wierd one and just let it ride
17:12:18 <hpc> or get yourself into some sort of orbit where you have to thrust in counterintuitive directions to go the desired direction
17:12:52 <sm[m]> hope they keep going
17:19:46 <MarcelineVQ> are you supposed to be able to buy stuff?
17:20:39 <MarcelineVQ> like, containers/crates are implemented but idk how to get stuff to jettison intro crates in the first place, even looking at the keymap in src
17:24:28 <MarcelineVQ> oh hmm it's left and right when landed
17:24:39 <MarcelineVQ> and you can't have spent all your cash on fuel
18:03:56 <sm[m]> aha
18:15:06 <ontop> Is there really nothing more to automagic currying than not having to write lambdas? It seems like so much more than that.
18:18:57 <p0a> why does this give me an error? https://pastebin.com/CN1MiXrw
18:24:41 <p0a> I do realize the instance is missing but how can I provide the instance?
18:25:12 <amalloy> p0a: <ChaiTRex> You can also not use a typeclass and write f :: Show a => a -> Int; f = length . show
18:25:33 <amalloy> if you want the typeclass to be totally uniform, there's no reason to have a typeclass at all
18:25:49 <p0a> amalloy: got it, what is the use of g = length . show in a typeclass declration?
18:26:11 <amalloy> it's a default, making it easier to write an instance
18:26:24 <amalloy> you still have to declare the instance, but if you don't implement g you get the default
18:26:42 <p0a> Got it, thanks. So there's no way to enrich instances automatically
18:27:10 <amalloy> without a definition of enriching instances, i don't know how to answer that
18:27:41 <p0a> well I appreciate your answer anyway it helps me understand
18:34:44 <p0a> I am trying `haddock -h file.hs' with a file using {-# MINIMAL f #-} for my typeclass with method f, but haddock doesn't document the minimal requirements, is there a way to get that?
18:36:24 * hackage avro 0.4.6.0 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.6.0 (haskellworks)
18:50:53 * hackage conduit-audio-sndfile 0.1.2.2 - conduit-audio interface to the libsndfile audio file library  https://hackage.haskell.org/package/conduit-audio-sndfile-0.1.2.2 (mtolly)
19:46:20 <justsomeguy> Can someone recommend a good overview of the major libraries for working with filesystem paths, and practical examples of their use?
19:56:34 <monochrom> Package "filepath", module "System.FilePath".  TL;DR you can write like "x" </> "y" </> "z" so it becomes "x/y/z" on unix, "x\y\z" on windows, and you never have to think again.
19:57:10 <monochrom> and it has a lot of utility functions to the effect of basename and dirname etc
19:57:21 <monochrom> THE END
20:10:11 <justsomeguy> I've noticed that some functions will give me wrong results. For example takeFileName "/home/chris/Downloads" will return  "Downloads", even though that's a directory. There are lot's of small things like this, in both system-filepath and the path module, which is why I'm curious about the overall landscape of available libraries for working with paths.
20:10:12 <ChaiTRex> That was an excellent bedtime story.
20:11:38 <monochrom> The result is not wrong, the function name is maybe poorly chosen.
20:11:38 <ChaiTRex> justsomeguy: A directory is a file.
20:11:49 <jle`> that's how unix works
20:12:10 <jle`> hm, what do you expect takeFileName to return for that?
20:12:25 <jle`> or do you expect it to not compile
20:12:36 <justsomeguy> jle`: Right, it should return a type error.
20:12:49 <monochrom> There a a ton of use cases where I just want to extract the "Downloads" from "/home/chris/Downloads" without regard whether it is a directory, hell, perhaps the whole path doesn't even exist on the system, I'm just manipulating paths.
20:13:04 <jle`> there are some 'typesafe' filepath libraries that have different types for 'directories' and 'files'
20:13:12 <ChaiTRex> justsomeguy: How should it know at compile time that that's a directory?
20:13:36 <jle`> but you have to tell the type system somehow first that it's a directory and not a filepath
20:15:29 <jle`> https://hackage.haskell.org/package/paths
20:15:41 <jle`> https://hackage.haskell.org/package/path
20:15:54 <jle`> are some, i think
20:16:32 <Axman6> jle`: that type safety doesn't actually buy you much, I can always do touch Douwnloads; <run app>; rm Downloads; mkdir Downloads
20:16:40 <Axman6> uh, justsomeguy
20:17:08 <justsomeguy> Hmm...
20:19:19 <pavonia> You can always test if a path points to a file or directory, and then conditionally apply takeFileName
20:19:39 <ChaiTRex> pavonia: That still allows for the TOCTTOU bug Axman6 mentioned.
20:19:55 <jle`> Axman6: yeah, it only really helps you if you are discplined with where you get your paths from
20:20:04 <jle`> it's more of an abstract data type
20:20:08 <ChaiTRex> pavonia: The path can be changed from a file to a directory while the program is running, between the check and use.
20:20:19 <jle`> the boundary between the 'path' data type and the actual filesystem is always going to be unsafe
20:20:35 <pavonia> ChaiTRex: Sure, but there's no way around that
20:20:57 <jle`> so those libraries don't really give you type safety for working with the filesystem
20:21:11 <jle`> just type safety for dealing with an abstract path data type, independent of any actual filesystem
20:21:47 <MarcelineVQ> I liked when the story went: the end
20:22:29 <MarcelineVQ> the sequel about atomic file system actions wasn't as compelling
20:25:05 <MarcelineVQ> and they killed my favorite character, FilePath
20:27:11 <ChaiTRex> MarcelineVQ: That means they killed String :o
20:28:32 <pavonia> Wait, String and FilePath were the same character?
20:29:23 <Axman6> D:
20:30:58 <jle`> C:
20:30:58 <monochrom> «FilePath: Far from Home Directory» near the end has the compiler reveal publicly that FilePath is String. :)
20:39:54 * hackage reflex-ghci 0.1.0.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.0.0 (abrar)
20:58:24 * hackage cabal-rpm 2.0.0 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.0 (JensPetersen)
21:12:54 * hackage wai-handler-launch 3.0.3 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.3 (MichaelSnoyman)
21:24:13 <alc``> I don't understand why haskell don't take != as not equal?
21:24:36 <alc``> /= or \=, I always confused which one mean not equal
21:24:53 <alc``> :t (!=)
21:24:54 <lambdabot> error:
21:24:54 <lambdabot>     • Variable not in scope: !=
21:24:54 <lambdabot>     • Perhaps you meant one of these:
21:25:03 <alc``> :t (\=)
21:25:05 <lambdabot> error:
21:25:05 <lambdabot>     • Variable not in scope: \=
21:25:05 <lambdabot>     • Perhaps you meant one of these:
21:25:10 <alc``> :t (/=)
21:25:11 <lambdabot> Eq a => a -> a -> Bool
21:25:46 <jle`> alc``: you can define your own
21:25:58 <jle`> remember (==) and (/=) etc. are not built-in operators
21:26:02 <jle`> they are just user-defined
21:26:16 <jle`> @let (!=) = (/=)
21:26:18 <lambdabot>  Defined.
21:26:22 <jle`> > 3 != 4
21:26:26 <lambdabot>  True
21:27:39 <alc``> other languages use !=
21:27:46 <jle`> some others use !=
21:28:20 <jle`> (/=) sort of makes sense mathematically because it's close to ≠, like =/=
21:28:46 <jle`> https://en.wikipedia.org/wiki/Relational_operator#Standard_relational_operators
21:28:47 <alc``> then should use =/=
21:29:01 <alc``> =/ or /= confused too
21:29:09 <rotaerk> too long
21:29:10 <nshepperd> /= is supposed to evoke ≠, but it doesn't do so very well imo. i agree that the conventionality of != seems more compelling
21:29:11 <jle`> =/= is kind of long, yeah
21:29:12 <alc``> :t (=/)
21:29:13 <lambdabot> error:
21:29:13 <lambdabot>     • Variable not in scope: =/
21:29:13 <lambdabot>     • Perhaps you meant one of these:
21:30:11 <jle`> it looks like only c-like languages, erlang, and mathematica use !=
21:30:28 <jle`> all other languages use different operators
21:30:31 <rotaerk> Oracle SQL uses it
21:31:48 <mniip> <>
21:31:49 <mniip> oh wait
21:33:01 <Bad_K4rMa> how to print type in ghc haskell
21:33:17 <alc``> Bad_K4rMa: :t
21:34:22 <Bad_K4rMa> what does that look like in ghc?
21:35:14 <jle`> what do you want to do exactly?
21:35:27 <jle`> if you know the type at compile time you can do something like print a typeRep
21:35:33 <mniip> % :t putStrLn
21:35:34 <yahb> mniip: String -> IO ()
21:35:39 <jle`> > (typeRep @Int)
21:35:41 <lambdabot>  error:
21:35:41 <lambdabot>      Pattern syntax in expression context: typeRep@Int
21:35:42 <lambdabot>      Did you mean to enable TypeApplications?
21:35:46 <jle`> % typeRep @Int
21:35:46 <yahb> jle`: ; <interactive>:22:10: error:; * Expected kind `k0 -> *', but `Int' has kind `*'; * In the type `Int'; In the expression: typeRep @Int; In an equation for `it': it = typeRep @Int; * Relevant bindings include it :: Int a -> TypeRep (bound at <interactive>:22:1)
21:35:50 <jle`> welp
21:36:10 <jle`> but the real answer will depend on what you are really trying to do
21:36:11 <jle`> big picture
21:36:19 <Bad_K4rMa> i just want to do :t for a function
21:36:26 <jle`> :t show
21:36:27 <alc``> > foldl1 (liftA2 (<>)) $ replicate 3 $ (:[]) <$> ['>','=','<','!','@','$','*']
21:36:28 <lambdabot> Show a => a -> String
21:36:29 <jle`> :t negate
21:36:30 <lambdabot>  [">>>",">>=",">><",">>!",">>@",">>$",">>*",">=>",">==",">=<",">=!",">=@",">=...
21:36:31 <lambdabot> Num a => a -> a
21:36:41 <jle`> Bad_K4rMa: :t works for functions just fine :)
21:36:44 <jle`> it works for all values
21:36:46 <jle`> and functions are values
21:36:53 <mniip> alc``, replicateM 3 ">=<!@$*"
21:37:02 <oats> Bad_K4rMa: you cannot use :t in the middle of haskell code, if that's what you're thinking of
21:37:08 <oats> it's a ghci command, not haskell code
21:37:22 <mniip> % typeRep (Proxy @Int)
21:37:22 <yahb> mniip: Int
21:37:39 <mniip> the api is pre-AAT I think
21:37:51 <jle`> % Type.Reflection.typeRep @Int
21:37:51 <yahb> jle`: Int
21:37:59 <jle`> just the wrong one imported D:
21:38:28 <Bad_K4rMa> oats is it possible to print the type of a function in haskell code outside of ghci?
21:38:59 <jle`> Bad_K4rMa: if you know the function at compile-time, you can use typeRep, but really it depends on what you want to do
21:39:23 <Bad_K4rMa> this is like my second day of haskell so all i know is hello world 
21:39:30 <jle`> right
21:39:31 <oats> uffda
21:39:35 <oats> hard place to start out :P
21:39:59 <Bad_K4rMa> i prly end up doing project euler problems or something
21:40:01 <jle`> what is teh bigger problem you are trying to solve?
21:40:02 <oats> Bad_K4rMa: why are you trying to print the type of a function?
21:40:09 <jle`> ah, project euler problems are not very good for learning a language
21:41:00 <dmwit> Many people find Advent of Code more fun than Project Euler, and I think it will give you broader coverage for learning the language as well.
21:41:01 <dasli> :q
21:41:35 <Bad_K4rMa> oats i guess i dont have to
21:41:39 <alc``> mniip: nice!
21:41:48 <oats> Bad_K4rMa: yay! this is good for the learning :P
21:41:54 <oats> start with simple things
21:43:39 <alc``> project Euler, is about math?
21:43:45 <Bad_K4rMa> yup
21:43:57 <alc``> gg
21:44:10 <Bad_K4rMa> gg
21:48:52 <glguy> Did someone say AoC?
21:49:21 * glguy 's spidey sense activates
21:49:32 <oats> glguy: I feel like AoC might still be a bit of a hard start for someone new to haskell
21:50:08 <alc``> what is AoC?
21:50:09 <glguy> why's that?
21:50:13 <glguy> https://adventofcode.com/
21:50:52 <oats> eh
21:50:55 <oats> maybe, I guess
21:51:01 <alc``> Alexandria Ocasio-Cortez?
21:51:17 <glguy> Yes, she's great for learning a new programming language.
21:51:24 <alc``> google aoc, that's the first result
21:51:36 <glguy> It was still a good guess
21:52:03 <Uniaika> o/
21:53:13 <alc``> aha, AoC looks like codewars
21:54:02 <alc``> I spend a week on codewars, 
21:54:29 <alc``> all the stuff I meet are how to handle lists...
21:55:10 <glguy> oats: I think they're good because they require practically no libraries to solve in Haskell; requires some simple text I/O and simple parsing which can be achieved with string manipulation, and there are lots of people who've worked through the problems available to chat with and a lot of solutions to compare to for learning
21:55:42 <oats> my main hangup was the stuff that's easily solved with State
21:56:03 <glguy> Can you elaborate on what that means?
21:56:06 <oats> but I think State is kinda hard to get a good sense for if you're not hip to the whole monad thing
21:56:28 <oats> glguy: not disagreeing with your paragraph though
21:56:54 <glguy> I didn't find it necessary to use the transformers package for any of the days
21:57:07 <alc``> I think Cont is harder to get a sense
21:58:13 <alc``> I wonder which guy introduce or discover continuation is a monad
21:58:15 <jle`> hm, how do you mean that your hangup is stuff that is easily solved with STate
21:58:15 <glguy> I need base, containers, vector, array; and I don't know that there's a good reason why I used vector that one time instead of array
21:58:24 <jle`> are you saying that your easy solutions can be made even easier with STate
21:58:27 <jle`> and that discourages you?
21:59:55 <iqubic> glguy: You know you can turn your IntCode computer into a Free thing.
22:00:10 <glguy> Yes
22:00:14 <jle`> it's already open source so there is no cost
22:00:24 * hackage language-puppet 1.4.6.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.6.1 (SimonMarechal)
22:00:41 <iqubic> Why didn't you do that? Was that a conscious design choice?
22:00:52 <glguy> iqubic: It would have added complexity without payoff
22:01:18 <jle`> cons: many
22:01:20 <jle`> pros: none
22:01:54 <iqubic> Really? No pros?
22:01:57 <jle`> name one :)
22:02:20 <iqubic> I can't actually.
22:02:40 <jle`> there's your answer
22:05:12 <hololeap> for what it's worth, Free has a (Co)Recursive instance
22:05:31 <glguy> What is that worth?
22:05:49 <iqubic> Not much in this case.
22:05:59 <hololeap> not having to write an intermediary Base functor and getting cata/ana
22:06:17 <hololeap> i didn't see this IntCode thing
22:06:21 <mniip> % :t zygoHistoPrepro
22:06:21 <yahb> mniip: (Corecursive t, Recursive t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (Control.Comonad.Trans.Env.EnvT b (Control.Comonad.Cofree.Cofree (Base t)) a) -> a) -> t -> a
22:06:26 <iqubic> hololeap: We don't need cata or ana here.
22:06:58 <glguy> the recursion-schemes package is to show what the paper it's based on would look like in Haskell, not to actually be used to write programs
22:07:13 <oats> is there a relationship between free monads and extensible effects? I've started reading into them and am a little confused by terminology
22:07:33 <hololeap> hmm, well *something* on my system is pulling it in as a dependency
22:07:53 <hololeap> in any case, i find cata and ana to be excellent abstractions
22:07:54 <glguy> hololeap: Sure, not everyone is in on the joke
22:08:50 <jle`> well, intcode does do an ana and cata
22:08:50 <iqubic> glguy: I used recursion-schemes to write a solution to this: https://adventofcode.com/2015/day/12
22:09:00 <iqubic> Day 12: JSAbacusFramework.io
22:09:08 <jle`> so it could be helped with recursion-schemes maybe. but not Free
22:09:11 <electricityZZZZ> there's no sql database (with any traction, anyway) written with a haskell backend right? why hasn't such a thing materialized?
22:09:14 <glguy> I'm not saying you can't write programs with it, I'm saying you shouldn't
22:09:18 <iqubic> I used this: https://hackage.haskell.org/package/aeson-extra-0.4.1.3/docs/Data-Aeson-Extra-Recursive.html
22:09:32 <iqubic> jle`: How does intcode do ana and cata?
22:09:49 <jle`> run is an anamorphism
22:09:57 <iqubic> How so?
22:10:10 <hololeap> glguy: well, why not?
22:10:12 <jle`> do you know what an anamorphism is?
22:10:22 <iqubic> I know what an anamorphism is.
22:10:30 <iqubic> It's a little bit like an unfold.
22:10:33 <iqubic> :t unfoldr
22:10:35 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:10:36 <jle`> https://hackage.haskell.org/package/intcode-0.2.0.0/docs/src/Intcode.html#run
22:10:58 <iqubic> What is the type of the run function?
22:11:06 <jle`> click the link :)
22:11:37 <iqubic> I'm still not seeing how that's an anamorphism.
22:11:41 <Axman6> iqubic has an aversion to ever reading anything which could be considered documentation, you're going to have to explain it jle` :P
22:12:10 <iqubic> run :: Machine -> Effect
22:12:16 <jle`> iqubic: what is the definition of an anamorphism
22:12:29 <iqubic> Wait... That's the coalgebra that you need to pass into ana.
22:12:47 <jle`> that isn't the coalgebra
22:13:14 <iqubic> Oh? It isn't? Is step the coalgebra?
22:13:53 <jle`> the coalgebra isn't explicitly written out there
22:14:11 <jle`> but step is the closest thing to one yeah
22:14:21 <iqubic> Yeah. That makes sense.
22:14:26 <jle`> oh wait actually step exactly the coalgebra
22:14:32 <jle`> neat
22:14:40 <jle`> *is exactly
22:15:16 <iqubic> So, this can't also be a cata can it?
22:15:46 <iqubic> Wait.. it is. Just in a different way.
22:15:58 <jle`> not really in a meaningful way
22:16:08 <jle`> cata takes you from a recursive type
22:16:12 <jle`> but Machine is not a recursive type
22:16:14 <iqubic> effectList is the closest thing we'll get to a catamorphism I think.
22:16:21 <jle`> oh, what do you mean by 'this'
22:16:29 <jle`> are we not talking about 'run' anymore
22:17:09 <iqubic> Well, it looks like the effectList function could be rewritten as a cata.
22:18:06 <jle`> do you mean 'cata' from the recursion schemes library or the mathematical concept of a catamorphism
22:18:31 <iqubic> I'm not sure what I mean at this point.
22:18:41 <iqubic> I'm too tired to think about this properly.
22:30:58 <shachaf> You gotta have some term in your value function that accounts for the cost of added complexity.
22:31:07 <shachaf> If you don't you'll just keep making things more and more complex.
22:31:39 <shachaf> As soon as you remember that term you notice that recursion-schemes doesn't help.
22:33:29 <shachaf> One good heuristic is to optimize for short programs in some objective metric. If zerglingmorphisms make your program shorter -- the whole program, not just a tiny snippet, and the program actually does something meaningful -- then maybe they're a good idea.
22:34:08 <shachaf> Also if you want to do maths that's also fine, but then just say you're doing maths.
22:34:29 <iqubic> They aren't called zerglingmorphisms, that just not a think that exists.
22:34:50 <iqubic> s/think/thing/
22:35:56 <shachaf> I'm sorry, I meant turbomorphic antipromorphisms.
22:36:39 <jle`> zerglingmorphisms are an important part of the starcraft meta
22:37:06 <Axman6> and cometa
22:37:07 <jle`> first there is the speedling upgrade at the spawning pool
22:37:17 <jle`> and the main zergling morphism is the baneling
22:39:33 <shachaf> It's a great risk to forget about the complexity term, if you want to write good software.
22:40:56 <shachaf> For some people it'll manifest as hippomorphisms, and for others as VisitorFactories, but it's the same deal.
22:46:31 <dmwit> (Nonrecursive types are recursive types, too.)
22:47:22 <dmwit> t ~ fix (const t) (or, if you prefer, T ~ Fix (Const T))
22:48:17 <shachaf> Anyway I like initial algebras and all sorts of things.
22:50:30 <iqubic> I prefer terminal coalgebras.
22:52:58 <pavonia> irccloud is the new matrix
22:54:36 <no-n> :(
22:55:01 <Axman6> I though tmatrix was the new irccloud
22:55:09 <glguy> Matrix goes down on its own; but it seems like someone is helping irccloud along
23:01:40 <hoppfull> Exploring https://hackage.haskell.org/package/gdp-0.0.3.0/docs/Data-Refined.html Has anyone used GDP?
23:02:40 <dminuoso_> Downloads: 737 total (85 in the last 30 days)
23:02:42 <dminuoso_> I'd say yes.
23:05:32 <hololeap> data Pylons = KeepBuilding Pylons | NotEnough
23:05:33 <hoppfull> I'm trying to understand how to use type (?). The documentation says it takes a value and a "predicate"
23:06:03 <hoppfull> The predicate has kind * -> * so it's a type constructor.
23:06:51 <hoppfull> Is it a predicate because we think it is or does it have some kind of boolean test to perform?
23:06:53 <glguy> No, that's not what type constructor means.
23:06:59 <hoppfull> oh ok
23:07:42 <hoppfull> confused now
23:08:37 <hoppfull> Does "predicate" mean something special in haskell?
23:08:55 <glguy> No, it's not being used as a Haskell specific term there
23:12:14 <dminuoso_> hoppfull: Refinement types are types with refinement predicates.
23:12:41 <dminuoso_> It's a term specific to refinement types, though it is in some sense related to the predicate you were thinking of.
23:14:36 <glguy> Have you already read this? https://kataskeue.com/gdp.pdf
23:16:39 <hoppfull> glguy: Yes, and Satisfies and (?) isn't explained.
23:16:54 * hackage hanabi-dealer 0.3.2.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.3.2.0 (SusumuKatayama)
23:17:13 <hoppfull> Atleast I don't think it is.
23:20:55 <glguy> That library is built around being able to name arguments and definitions. You might then want to define a subset of definitions that satisfy a property
23:21:35 <glguy> The example shows a predicate NonEmpty that can be applied to some "name" xs
23:22:05 <glguy> NonEmpty xs being a proposition that xs isn't empty
23:23:08 <iqubic> What library are we discussing?
23:23:19 <glguy> [Int] ?NonEmpty would be a list that is asserted not to be the empty list, but without having an explicit name shown
23:23:28 <hoppfull> iqubic: https://hackage.haskell.org/package/gdp-0.0.3.0/docs/GDP.html
23:24:23 * hackage hurl 1.0.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.0.0.0 (alcinnz)
23:25:22 <iqubic> I spent way way too long looking at this: "data a ::: p" before I realized it was an infix data constructor.
23:25:26 <hoppfull> glguy: Okay. It seems like you could write [Int] ::: NonEmtpy as well
23:27:05 <hoppfull> Aha, I think I get it. ([Int] ?NonEmpty) is like a shorthand for ([Int] ~~ x ::: NonEmpty x)
23:28:33 <iqubic> This reminds me of the agda tactics langauge, implemented in Haskell.
23:30:17 <iqubic> How do you use this to write a function that requires a non-empty list?
23:31:32 <iqubic> And how would you feed it a value, along with the right proof? This seems like it's encroaching on dependent types, but also not really.
23:32:00 <hoppfull> As I understand it you need a function that proves a list is nonempty; f :: [a] -> Maybe ([a] ::: NonEmpty)
23:32:10 <c_wraith> the idea of gdp is that library authors create functions to tag values with proofs
23:32:16 <iqubic> Sure. That makes sense.
23:32:50 <dminuoso_> It's an in-haskell version of liquid haskell, if you wish.
23:32:54 <c_wraith> And there is some trickery going on to make sure that functions like that can only be defined within particular modules, via non-exported constructors.
23:34:08 <iqubic> dminuoso_: Oh? How so?
23:34:34 <dminuoso_> iqubic: How so?
23:35:07 <hoppfull> I've heard of Liquid Haskell.
23:35:30 <iqubic> How can this be used as a form of Liquid Haskell?
23:35:30 <hoppfull> My boss said he tried it but couldn't get it to work properly.
23:35:55 <dminuoso_> iqubic: The core idea is the same.
23:36:09 <dminuoso_> iqubic: It's just refinement types.
23:36:56 <c_wraith> liquid haskell's main advantage is that it uses an SMT solver to automate most arithmetic proofs, which is a huge convenience for those cases.
23:39:56 <iqubic> I'll just wait for dependent haskell.
23:40:36 <dminuoso_> dependent haskell is something completely different.
23:40:42 <dminuoso_> Utterly unrelated.
23:41:02 <iqubic> It is?
23:41:04 <c_wraith> not utterly.  Refinement types are a subset of dependent types.
23:41:43 <iqubic> I thought refinement types were the same as dependent types.
23:42:17 <iqubic> c_wraith: Can you give me an example of something that is a dependent type, but not a refinement type?
23:42:18 <c_wraith> Certainly not identical.
23:42:52 <c_wraith> printf using a pi type for the format string?
23:43:02 <iqubic> What is a pi type?
23:43:30 <c_wraith> the core of dependent typing.  It's a binder that binds an argument at both the type and value levels.
23:43:35 <hoppfull> A pi type is a product type with the length paramerized. Like an array of length n
23:43:44 <hoppfull> ... I think <_<
23:43:47 <hoppfull> >_>
23:44:01 <c_wraith> hoppfull: that's a thing that you can do with a pi type, but it's not the definition of one. :)
23:44:04 <iqubic> I see.
23:44:14 <alc``> there're too many parenthesis in (f2 (((fmap snd l) // [(snd smallestTuple)])))
23:44:18 <alc``> how to change it?
23:44:37 <iqubic> Do Idris and Agda have pi types?
23:44:40 <c_wraith> yes
23:44:50 <alc``> there's no $ in 7.10
23:44:59 <dminuoso_> hoppfull: So one way to define it, is to start by considering what polymorphic types are. They give you *terms* abstracted over *types*. In GHC Haskell you can reveal that with TypeApplications.
23:45:18 <dminuoso_> hoppfull: So something like `fmap @[] @Double` is a valid thing to do.
23:45:33 <dminuoso_> hoppfull: Dependent types give you *types* abstracted over *terms* (such that you can apply types to terms)
23:46:02 <dminuoso_> More importantly, it gives you a type system in which abstracting over terms is meaningful and can be checked
23:48:29 <c_wraith> iqubic: so, modulo syntactic issues I can't remember from the current proposal (these details are subject to change anyway), you could have something like....  printf :: pi (format :: String) -> printfType format
23:49:10 <c_wraith> iqubic: and printfType :: String -> Type
23:50:48 <c_wraith> No refinements in there!
23:53:14 <dminuoso_> c_wraith: It seems that you could implement a subset of refinement types with dependent types. But full refinement types over arbitrary predicates.. with a solver.. and ergonomics..
23:56:15 <c_wraith> dminuoso_: The solver is definitely outside the bounds of what full dependent type systems offer (even Coq's tactics aren't as powerful as an SMT solver, iirc).  But that's not an expressiveness issue, it's a usability one.  Proof inference, instead of having to write it out by hand.  In practical terms, yes, that's huge.  In theoretical terms, though, refinement types are dependent types of a particular form.
23:57:14 <c_wraith> limits often make things more usable.  no surprise there!
23:59:28 <dminuoso_> c_wraith: Oh you mean that in dependent typing you have to construct all proofs by hand, whereas an SMT solver can generate proofs on its own?
23:59:41 <dminuoso_> (Or rather, infer them I suppose)
