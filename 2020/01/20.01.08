00:03:53 * hackage mmsyn7l 0.1.1.1 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.1.1.1 (OleksandrZhabenko)
00:18:15 <koz_> Anyone familiar with TAPL: the author of that book takes pains to distinguish 'terms' and 'values' when presenting type systems. However, looking at the presentation of the STLC (9-1), an abstraction _term_ and an abstraction _value_ look identical. Am I missing something here?
00:19:52 <hololeap> i've read some things that imply that functors/applicatives/monads/arrows have some heirarchy of "power", but i haven't seen a definition of what "power" means in this case
00:20:32 <koz_> hololeap: Generally, 'power' refers to expressivity in such a context.
00:20:37 <opqdonut> well one definition of power is that you can express more computations
00:20:51 <koz_> So the idea is, if we have an applicative, we can use its operations to describe operations a functor cannot.
00:20:57 <opqdonut> and a more powerful abstraction (e.g. monad) can do everything a less powerful one can (e.g. applicative)
00:21:00 <koz_> (well, a functor _only_, to be very nitpicky)
00:21:08 <koz_> Yeah, opqdonut beat me to it.
00:21:24 <opqdonut> somebody said the difference between applicatives and monads is that the structure of the computation is fixed in an applicative, but not in a monad
00:21:40 <opqdonut> so in an applicative you can't react to results of previous computations
00:21:44 <koz_> opqdonut: I like to think of it as 'in Applicative, we can't specify the order, but in Monad, we can'.
00:22:01 <koz_> But that's basically very similar.
00:22:15 <opqdonut> btw, when you get more power, you also get less introspectability
00:22:22 <opqdonut> and can do less "optimisations" while interpreting
00:22:29 <koz_> And you become less 'well-behaved'.
00:22:29 <opqdonut> that's why applicative parsers are "better" than monadic ones
00:22:37 <hololeap> huh, this blog post says that arrows are _less_ powerful than monads which through me through a loop
00:22:41 <hololeap> https://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html
00:22:53 <opqdonut> yeah I'm not sure how arrows fit in
00:23:25 <hololeap> from your definition, they should be _more_ powerful than monads since they can do everything a monad can and more
00:23:26 <opqdonut> they don't seem to be used much these days
00:23:33 <koz_> The relationship between arrows and monads is actually surprisingly tricky.
00:23:42 <koz_> There was a paper on this a while back, but I can't recall its title at present.
00:24:10 <hololeap> the only arrow i have any intuition of besides (->) is Kleisli
00:24:32 <koz_> https://stackoverflow.com/a/3663804 <-- Conal to the rescue!
00:24:33 <MarcelineVQ> koz_: iiuc in stlc a value corresponds to an answer, that is to say a value is a term that isn't reduced further. suc (suc (suc zero))) is a value but 2 + 1 isn't, though it's still a term
00:24:53 * hackage hw-dsv 0.3.8 - Unbelievably fast streaming DSV file parser  https://hackage.haskell.org/package/hw-dsv-0.3.8 (haskellworks)
00:24:56 <koz_> MarcelineVQ: So a value is irreducible?
00:25:02 <koz_> While a term might be?
00:26:22 <MarcelineVQ> irreducable on its own. consider that a lambda is a value, thought we can apply it to get something we might need to reduce it farther
00:26:29 <MarcelineVQ> *to reduce futher
00:27:04 <koz_> Ah, so in this case, if we have a lambda, but nothing to apply to it, we gotta stop?
00:27:08 <MarcelineVQ> yes
00:27:23 <koz_> So thus, that's a value. However, a _term_ can be made up of lots of pieces, and _one_ such piece is a lambda?
00:27:27 <koz_> OK, that makes all the sense.
00:27:31 <MarcelineVQ> in this particular case, though there's other systems that 'reduce under lambdas' I think it's called
00:27:58 <koz_> TAPL's presentation divides into terms, values, types and contexts.
00:28:05 <koz_> (for later stuff, there's also kinds)
00:28:25 <koz_> The rest of those things made sense to me on an initial reading, but the values thing threw me a bit.
00:28:35 <MarcelineVQ> that's what I'm familiar with as well so far, from https://plfa.github.io/
00:28:47 <koz_> I suppose that in an STLC with 'atomic' or 'ground' types, values would include inhabitants of said types, right?
00:29:00 <MarcelineVQ> value is defined pretty directly there, https://plfa.github.io/Lambda/   read through or search value
00:29:49 <MarcelineVQ> in this material value includes suc and zero and lambda, and nothing else
00:30:09 <koz_> So basically, that's STLC + nats?
00:31:39 <MarcelineVQ> yeah, and it says Software Foundations used booleans for the base type instead of naturals
00:31:55 <koz_> TAPL provides both as examples.
00:32:44 <koz_> Another book someone here suggested (also very good) talks about 'atomic types' more generally, and basically goes 'you can have some if you like, but it's not gonna change anything, so we'll just not worry about it'.
00:37:20 <orzo> is there a tool out there to measure my per-module compile time?
00:37:54 <orzo> i mean, i want times for each module
00:44:50 <Solonarv> orzo: I'm pretty sure ghc outputs enough information for this if you tell it to be verbose (with one to three -v flags)
00:58:15 <koz_> If you give GHC enough -v flags, does it output in Comic Sans?
01:09:20 <Phyx-> koz_: yes or use -vsimon
01:09:32 <koz_> Phyx-: I believe -vspj also works.
01:17:44 <orzo> is there a way I can change some RTS option defaults without a c module?
01:18:21 <koz_> MarcelineVQ: Does this seem right vis a vis STLC here? https://gist.github.com/kozross/662c6e6cd264cfa0d367a6529aa5c7f5#file-stlc-hs-L44
01:18:43 <dminuoso_> orzo: http://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/runtime-control.html#rts-opts-compile-time
01:19:04 <dminuoso_> Gah old manual version, but you get the idea.
01:19:10 <koz_> I'm somewhat suspect of https://gist.github.com/kozross/662c6e6cd264cfa0d367a6529aa5c7f5#file-stlc-hs-L78, as I've honestly never used do-notation with Maybe before.
01:20:20 <orzo> thanks
01:20:36 <dminuoso_> koz_: Seems fine.
01:20:43 <Phyx-> koz_: oh yeah, forgot about that one
01:20:48 <koz_> dminuoso_: OK, so it _does_ work the way I thought, lol.
01:21:14 <Ferdirand> :t guard
01:21:16 <lambdabot> Alternative f => Bool -> f ()
01:21:25 <dminuoso_> I can't attest to what you think how it works.
01:21:26 <koz_> Ferdirand: I'm aware, lol. :P
01:22:10 <koz_> dminuoso_: Basically, if I have (Foo t) <- funcReturningMaybe bar, if I get back a Nothing, or a Just (NotAFoo t), it'll give Nothing (because of MonadFail instance) and just cut me right out to the end, yielding Nothing.
01:22:50 <koz_> (admittedly, the right thing to return is Either STLCTypeError STLCType, but ehh)
01:23:16 <dminuoso_> koz_: I'd probably use `when` 
01:23:54 <dminuoso_> Oh mmm, that won't hepl
01:23:54 <koz_> dminuoso_: So "when (t == u) (pure t')" in this case?
01:23:56 <dminuoso_> Heh
01:23:58 <dminuoso_> % :t when
01:23:58 <yahb> dminuoso_: Applicative f => Bool -> f () -> f ()
01:23:59 <koz_> Yeah, I figured.
01:24:00 <dminuoso_> Sorry
01:24:08 <koz_> guard with *> would work I think.
01:24:20 <koz_> I didn't write it because I find the explicit if-then-else clearer.
01:24:31 <dminuoso_> If you find it clearer, you have your answer.
01:25:09 <koz_> dminuoso_: Yeah, I was more curious about the behaviour described above. But, givne that you haven't corrected me, I think I must be right. :P
01:25:15 <koz_> Which is actually pretty cool.
01:26:55 <dminuoso_> It's situations like this when the point of Monad becomes clear. :)
01:28:57 <koz_> Monad and MonadFail, in this case.
01:29:07 <dminuoso_> koz_: Though `guard (t == u); pure t'` seems more expressive to me.
01:29:33 <koz_> Wouldn't that unconditionally give back t', regardless of the guard?
01:29:52 <dminuoso_> koz_: No, it's the entire point of guard.
01:30:51 <koz_> But if t /= u, isn't that "Nothing; pure t"? What am I missing here?
01:31:00 <koz_> s/t/t'/
01:31:04 <dminuoso_> @src guard
01:31:04 <lambdabot> guard True  = pure ()
01:31:04 <lambdabot> guard False = empty
01:31:37 <dminuoso_> And by (commonly accepted) laws, this guarantees shortcircuiting behavior.
01:31:56 <dminuoso_> In case of Maybe, it's just the plain "throw Nothing/error when the condition is false"
01:32:06 <Ferdirand> if t /= u then it becomes Nothing >> pure t
01:32:12 <koz_> Ah, I see.
01:33:10 <dminuoso_> koz_: guard is a fairly fine primitive, I especially like to use it inside STM
01:33:19 <dminuoso_> Where failure to meet the guard condition causes a retry. :)
01:33:31 <koz_> Wow, TIL.
01:33:56 <dminuoso_> So `guard` in your mind means "We proceed only if the condition holds", and the "failure to proceed" is whatever your Alternative instance does with empty.
01:34:24 <koz_> Which, in the case of Maybe, is Nothing.
01:34:27 <dminuoso_> Right
01:34:34 <koz_> (as opposed to 'nothing', lol(
01:34:36 <koz_> )&
01:34:38 <koz_> Argh keys.
01:35:13 <MarcelineVQ> &nbsp;
01:36:09 <koz_> Much space, such not break.
01:36:11 <dminuoso_> MarcelineVQ: Haha, I love nbsp. When I was still doing Ruby work, it creeped up on me so hard when accidentally hold Cmd while pressing spacebar produced a perfectly fine space.. but the compiler didn't think so.
01:36:26 <dminuoso_> Getting spurious parser errors in your program, but no useful diagnostic. 
01:37:56 <MarcelineVQ> now​my​parse​errors​come​from​no​spaces​at​all
01:47:53 * hackage aws-lambda-runtime 0.0.0.1 - Haskell on AWS Lambda Runtime API  https://hackage.haskell.org/package/aws-lambda-runtime-0.0.0.1 (phadej)
02:00:23 * hackage hw-dsv 0.4.0 - Unbelievably fast streaming DSV file parser  https://hackage.haskell.org/package/hw-dsv-0.4.0 (haskellworks)
02:05:54 <dminuoso_> MarcelineVQ: It's better than that, the nbsp was visualized normally.
02:06:34 <dminuoso_> So at some point a binary search revealed the offending line. Deleting it, and writing exactly (visually) what was there fixed the error causing nothing but disbelief.
02:06:43 <dminuoso_> Took me quite a bit to figure out what went wrong
02:11:59 <Solonarv> koz_: what you're missing is that 'do { Nothing; x } = Nothing'
02:12:12 <koz_> Solonarv: dminuoso_ already filled me in.
02:12:24 <Solonarv> oops, missed that
02:17:02 <MarcelineVQ> Solonarv: scorch!
02:17:21 <int-e> dminuoso_: it's highly ironic if you expand the "nb".
02:17:33 <int-e> (good story)
02:18:11 <int-e> (And of course the pun has been done already, sorry.)
02:24:41 <koz_> Is kind-generics-derive not on Hackage or something?
02:29:33 <lyxia> that doesn't look like a library for general use. It's more of a random bunch of examples that serve as test cases.
02:30:02 <lyxia> (assuming you're referring to https://gitlab.com/trupill/kind-generics/tree/master/kind-generics-deriving/src/Generics/Kind/Derive)
02:32:34 <koz_> lyxia: I'm looking for something like GEq, but for GenericK. Am I looking in the wrong place? The docs for kind-generics refer to kind-generics-derive.
02:35:49 <aplainzetakind> From the wikibook chapter on denotational semantics: Denotations are compositional, i.e. the meaning of a program like 1+9 only depends on the meaning of its constituents: [[a + b]] = [[a]] + [[a]]. I suppose it's implicitly taken for granted/meant that [[+]] = + here, right?
02:37:30 <opqdonut> yes, and that's quite a big leap too
02:37:51 <opqdonut> also, I guess the second [[a]] was a typo and meant [[b]]
02:38:24 <aplainzetakind> Sure.
02:38:29 <__monty__> Is it? How detailed do you need to go for it not to be a big leap?
02:38:57 <opqdonut> well the denotation of Num.+ is definitely not the mathematical + for e.g. Ints or Floats
02:39:05 <opqdonut> I guess it is for Integer
02:39:16 <aplainzetakind> I don't mind the leap but the notational ambiguity can be removed perhaps.
02:39:18 <opqdonut> modulo bottoms
02:39:28 <int-e> "the mathematical +" is a joke, right?
02:39:47 <opqdonut> sorry :)
02:39:57 <int-e> Also, Ints have a proper ring structure.
02:40:07 <Solonarv_> for Int it is, yes
02:40:30 <int-e> Floats, not so much :)
02:40:39 <Solonarv_> it's just modular arithmetic after all
02:44:03 <aplainzetakind> I think a discussion of primitives and their semantics would be good to have there. I can infer that, for instance [[Maybe a]] is the disjoint union of the empty set and [[a]] (right ?), but what are the things that we have to begin with, before we start making new from old. Also the compartmentalization of types and values is not obvious I think.
02:45:17 <aplainzetakind> (Maybe I'm speculating too eagerly, I just started reading)
02:46:43 <__monty__> I think you may be expecting too much from that page. Afaik it doesn't give a complete denotational semantics of haskell and afaict that's not its goal either.
02:46:51 <int-e> aplainzetakind: {Nothing} is a singleton set. And then there's a bottom value.
02:49:40 <opqdonut> did TAPL have a chapter on poset semantics?
02:49:41 <aplainzetakind> int-e: s/empty set/singleton containing the empty set/
02:50:08 <lyxia> koz_: I don't think such a library exists, but it's probably a one-liner. Also, if you're looking to derive Eq, does StandaloneDeriving not work for you?
02:50:22 <koz_> lyxia: It wasn't working, but I now realize why.
02:55:10 <koz_> I don't think there's an easy way out of my predicament either, lol.
02:56:23 * hackage hw-ip 2.4.1.0 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.4.1.0 (haskellworks)
02:57:27 <lyxia> writing the instance by hand doesn't seem that bad
02:59:03 <koz_> lyxia: Even that won't work. Turns out I need something like GEq from Data.GADT.Compare.
02:59:13 <koz_> But I think I have my solution.
03:00:48 <lyxia> Whatever you can do with generics you can do more verbosely by hand
03:01:26 <lyxia> Maybe the "default" implementation won't work, but to me "by hand" encompasses anything you can think of.
03:07:23 * hackage hoogle 5.0.17.14 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.14 (NeilMitchell)
03:09:26 <koz_> lyxia: If you're curious, this is what I ended up having to do: https://gist.github.com/kozross/423bfbdf01e5d7d2be42faf94089b352
03:30:28 <fog> so i was trying to fold a simple kind of graph that was just a list of neural network layers
03:32:15 <fog> and basically, if instead of summing together all the neuronal sigmoid activations (Doubles returned from tanh), the values on the edges were of arbitrary type, and combined together with a function taking as many arguments as edges to previous nodes (not fully connected)...
03:32:57 <fog> ... then it could serve as a way to hold functions that were compiled from a string (assuming there was a parser for the types aswell somehow)
03:34:01 <fog> where this seems like the best way to place functions at each node - though its (Int,Int) position could be used as with neurons eg to swap a function into the "implementation" at the corresponding position
03:36:31 <fog> i guess it could also be created from just a HList (or an FList with a partially applied pair) of a pair of position and hetrogenously typed functions
03:37:04 <fog> ...or values, which would be nodes with no edge leading into it
03:37:53 <fog> seems like a good model for parallel tasks, with forking threads
03:38:33 <fog> and you could just have id to defer the argument to the next layer, so having edges basically connect distant layers
03:41:53 * hackage warp 3.3.6 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.6 (KazuYamamoto)
03:42:53 * hackage warp-tls 3.2.10 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.10 (KazuYamamoto)
03:47:32 <fog> i guess if the types at each node had symbols to label the names (as well as the type-list param to the overall datatype holding the types of each function, and the values at each node holding the actual function) then the implementation could be pattern matched on 
03:47:58 <fog> actually, the names arent necessary at all....
03:49:31 <fog> this allows the implementations to be pattern matched on just by a combination of their structure (just in terms of arity as the number of edges between nodes) and the types of the functions stored at each node
03:51:56 <fog> it would be annoying to have to parse it from a string though, since there are even module imports to locate the functions themselves. probably would just end up having to write them using the list of list shape but interspersed with the constructors of the correct hetrogenous lists...
03:53:30 <fog> or even, it might be simpler to literally just give a HList of HLists of functions and specify the edges as Ints from the previous layer
03:54:03 <fog> idk how to do recursion though
03:54:44 <fog> seems like that could need a graph with cyclic edges as opposed to the deep net shape. more like a recurrent highway net
04:39:54 <kuribas> is there a type for Natural integers?
04:40:00 <kuribas> unbounded?
04:41:14 <opqdonut> Integer
04:41:27 <kuribas> is not natural
04:41:28 <opqdonut> nothing in the standard library if you don't want negatives
04:42:15 <MarcelineVQ> other than Numeric.Natural :>
04:42:18 <opqdonut> but there's this: http://hackage.haskell.org/package/base-4.12.0.0/docs/Numeric-Natural.html#v:Natural
04:42:25 <opqdonut> heh oh that's in base these days
04:42:49 <kuribas> MarcelineVQ: that's it, thanks!
04:43:07 <MarcelineVQ> it's not ideal since negs are exceptions, but that's the best we can curently do while retaining speed I guess
04:43:25 <opqdonut> I guess it's fine if you don't use Num?
04:43:37 <opqdonut> would need some custom instances though
04:44:10 <kuribas> MarcelineVQ: Integer operations aren't total either
04:44:19 <kuribas> > (5::Integer) `quot` 0
04:44:23 <lambdabot>  *Exception: divide by zero
05:04:55 <nickednamed> Hello all. I'm (still) new to Haskell and programming and I want to learn more. I'm planning to learn Haskell (and cabal, testing, benchmarking, profiling, etc.) by solving Project Euler problems. How should I organise this? I would like to create one project for this. Should I use one executable, and make each solution a seperate library?
05:06:04 <maerwald> nickednamed: I would do multiple executables
05:06:10 <merijn> nickednamed: Honestly, I'd recommend not using Project Euler
05:06:51 <maerwald> https://github.com/merijn/AdventOfCode2019/blob/master/advent.cabal here is a good example
05:07:03 <merijn> nickednamed: Project Euler is mostly numeric trickery (i.e. testin your knowledge of number theory) and the kind of arithmetically intense assignments it has force you into working a lot with some of the least nice bits of Haskell
05:07:09 <merijn> @exercises
05:07:09 <lambdabot> Unknown command, try @list
05:07:14 <merijn> @where exercises
05:07:14 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
05:07:42 <merijn> nickednamed: Instead I'd recommend looking at those links (or maybe old Advent of Code puzzles) https://adventofcode.com/
05:07:51 <merijn> Those resemble "real" programming much more
05:08:19 <merijn> maerwald: Sadly that repository mostly shows when I had an unexpected paper deadline pop up ;)
05:08:40 <opqdonut> https://github.com/opqdonut/haskell-exercises
05:08:56 <maerwald> those are the days when we are most productive: procrastinating something else
05:10:07 <nickednamed> Thank you guys. I'm also hoping to do the same with "Daily Programmer" problems, and 99 Haskell problems (each as a seperate project). I will add the others to the list. 
05:11:07 <maerwald> have you installed the toolchain yet?
05:11:15 <nickednamed> I'm following a book or two along with the problems, but I just like to do them, plus the repetition of creating a (mini) project, commiting changes, profiling, etc., little and often is helping me build up "muscle memory" and stuff.
05:12:23 <nickednamed> The toolchain, as in, ghc, cabal, etc.? yes I have. All working. I have already done a few daily programmer problems, a few books chapters, a few Euler problems, etc., but it's starting to get messy, so I would like to consolidate into "mini projects"
05:13:03 <maerwald> I've never tried it, but there is https://github.com/kowainik/summoner for scaffolding haskell projects 
05:13:11 <maerwald> maybe it's useful for that sort of thing
05:14:57 <nickednamed> maerwald - I'll check it out. But nonetheless, I'd like to know *why* projects get structured they way the do. Can someone give me an idea why I might use seperate executable for each problem, rather than one main executable with a seperate library for each solution?
05:15:47 <maerwald> so you don't have to write a cli interface to pick what you want to run
05:16:17 <maerwald> cabal new-run exe:solution1 -- cabal can do that if those are executables
05:16:59 <maerwald> also, theoretically lower build times (but this might be negligible)
05:17:45 <merijn> In my case mostly because I wrote them to be (individually) as simple as possible to use as examples as others
05:18:07 <merijn> So, relatively mininimal dependency footprint per solution and minimal amount of boilerplate
05:18:24 <merijn> Which is just easier with 1 exe per solution
05:18:56 <nickednamed> OK, I understand. Actually, I was kind of looking forward to writing a CLI interface as most of what I've done so far was purely functional. But it would only be writing on interface, once, so not a lot of practice anyway I guess.
05:19:23 <maerwald> it's rather tedious
05:19:34 <kindaro> Hello! Would someone be willing to talk with me about the book "Types and Programming Languages" by Benjamin Pierce? It seems overly technical to me, but many people praise it, so I wonder if I am reading it the wrong way.
05:19:54 <merijn> kindaro: Do you mean "i often get lost in the proofs"?
05:20:06 <kindaro> No, I mean I get bored instantly.
05:20:26 <opqdonut> kindaro: it's a programming language theory book, were you perhaps expecting a programming book? or a programming language design book?
05:20:38 <merijn> Bored by what? Where are you in the book? What's your goal in reading it?
05:21:26 <opqdonut> the best thing about TAPL in my opinion is that it's the most approachable PLT book, you get used to the natural deduction notation for type systems, and get to know the standard terms for many things
05:21:31 <merijn> I think it's a great book, but if you don't care about "how do I implement a type system?" then, yeah, you're not going to get much out
05:21:42 <Solonarv> > also, theoretically lower build times (but this might be negligible)
05:21:42 <Solonarv> this was not negligible for me at all, and actually quite annoying
05:21:44 <lambdabot>  <hint>:1:5: error: parse error on input ‘,’
05:21:52 <Solonarv> I had waay too much rebuilding
05:23:16 <kindaro> For example, open page 60, where he is talking about single-step and multi-step evaluation of a language of "if" statements. I cannot understand what it is he is talking about, at such length. The statements are painfully trivial.
05:23:16 <nickednamed> So just to check, if I *wanted* to have one executable (a CLI interface) and make each solution a library, it wouldn't be *terrible*, right? In that case, each library would exist in a sub-dir such as lib/lib1 or lib/lib2, with corresponding tests such as test/lib1test and test/lib2test, etc. Right?
05:23:30 <kindaro> `t -> t' & t -> t'' => t' = t''` well duh.
05:23:44 <maerwald> nickednamed: doesn't have to be subdir imo, just different modules
05:24:19 <nickednamed> maerwald: would it be a good idea, just in case one or two of the solutions are best written broken up into helper funcions/files?
05:24:24 <opqdonut> kindaro: sorry I don't have the book with me here
05:24:29 <kindaro> He is offering me a page-long proof, but I do not have doubts in the first place.
05:25:15 <opqdonut> rigorous proofs for simple things can be valuable in teaching what proofs are and how to read or write them
05:25:48 <opqdonut> but if you're already familiar with proofs then its a bit overkill, I get it
05:26:10 <Solonarv> nickednamed: that is how I ended up organizing it
05:26:12 <opqdonut> but then you can just skip the proofs for theorems you find trivial
05:26:27 <kindaro> See pictures of relevant pages here https://imgur.com/a/IpqNGbB
05:26:31 <merijn> Or too complicate ;)
05:26:35 <Solonarv> but as mentioned above I am not really satisfied with it and wish I had gone for the "multiple executables" approach
05:27:34 <kindaro> Let me explain how I see it. What he wants to deliver is that there is a collection of expressions and a certain relation that he claims has certain properties, such as being a transitive reduction of a total order.
05:27:46 <kindaro> What puzzles me is why he cannot just say it.
05:27:59 <kindaro> Or am I completely wrong and the book is about something else entirely?
05:28:12 <kindaro> I mean, all that he says is true, but it is just so small, so zoomed in.
05:28:21 <merijn> kindaro: Because there's a difference between "handwaving something with a claim to be true" and "actually proving, in a mathematical sense, that it is true"
05:28:22 <opqdonut> I guess he wants to keep the presentation elementary
05:28:49 <opqdonut> "transitive reduction of a total order" seems a bit obfuscated to me, the formulation of that theorem is what I'd like to see
05:28:54 <kindaro> merijn, he is not showing me his line of thought anyway. I am not his proof checker.
05:29:25 <merijn> kindaro: You are assuming a total order exists
05:29:27 <kindaro> His text is not formal enough for a proof checker, but too formal for a human.
05:29:28 <merijn> kindaro: Does it?
05:29:46 <opqdonut> if you're not enjoying the book, maybe you should try another one. perhaps "foundations for programming languages"
05:29:53 <kindaro> I would not mind if he claimed that at least he would like there to be a total order.
05:29:58 <merijn> kindaro: Note that the book is written for "undergrads and up"
05:30:47 <kindaro> I mean, what is the goal of his manipulations? Does he want to establish a well-behaved relation? Or something else that I miss entirely?
05:30:55 <nickednamed> Thank you all. I must say, this is a very noob-friendly, patient and helpful community. One of the best I have come across. Thank you!
05:34:55 <kindaro> Or rather, should I ask: is the goal of the book to establish well-behaved relations on expressions?
05:35:17 <kindaro> Is the goal to give me ways to discern between relations that are nice and those that have corner cases?
05:35:58 <merijn> kindaro: The goal of the book is to teach you design type systems and languages and prove things about them
05:36:35 <merijn> And it does so, by walking through all the steps of doing so for (at the start) trivial languages and gradually building more complex extras on top
05:36:51 <kindaro> But what things would I want to prove?
05:36:59 <kindaro> And what is a type system, anyway.
05:37:09 <maerwald> phadej: did you just change the binary format of 01-index.cache? :>
05:37:09 <maerwald> https://github.com/haskell/cabal/commit/a07ef25229217a289433087c241d89e1c08e65e0
05:37:29 <maerwald> imo, it should be stable (because there is no API to parse it currently)
05:37:30 <kindaro> Is it a grammar with a set of rewrite rules? We already have theory of grammars, but I do not see Pierce referring to that.
05:38:14 * Solonarv waves hands furiously in the direction of Curry-Howard isomorphism
05:38:37 <merijn> kindaro: Type systems are meta frameworks for classifying the semantics of an expression based on the static (i.e. syntactical) components
05:39:11 <merijn> What the semantics are/mean depends on the type system
05:39:22 <kindaro> It says so on the box. But it does not tell me what they are actually.
05:39:34 <kindaro> Grammars for reasoning about grammars?
05:39:43 <merijn> Type systems aren't grammars
05:40:11 <merijn> In fact, the entire book doesn't really cover grammar beyond sort of handwaving how you parse things into ASTs
05:41:16 <kindaro> Well, so far I have not made it to the type systems in this book. But I am already not seeing the forest behind the trees.
05:41:36 <kindaro> So, taking a step back, what is he trying to tell me about evaluation of boolean expressions?
05:41:57 <merijn> kindaro: What? That example you showed is already well into type systems
05:42:15 <Flonk> How awesome is that, I was just about to post a question about Types and Programming Languages.
05:42:19 <kindaro> Chapter 5: the untyped lambda calculus.
05:42:21 <Flonk> Of course #haskell is already discussing that
05:43:20 <kindaro> Seeing how his boolean expressions are a context-free language (this is where I would start), I can already know a lot about them from the formal grammar point of view.
05:43:39 <kindaro> But he is never putting it that way.
05:43:57 <merijn> kindaro: He isn't saying anything about boolean expressions, he is *defining* evaluation of boolean expressions and showing how that single step each part of the evaluation is always equivalent to a big evaluation step as shown in the table
05:44:17 <kindaro> Can you explain this?
05:44:38 <kindaro> He is defining a grammar and some rewrite rules on top of it.
05:45:07 <merijn> kindaro: Forget you know such a thing as boolean expressions exist and people have written about. You have just invented it and need to write down exactly how they're specified to behave
05:45:18 <merijn> That's what he's doing
05:45:30 <kindaro> That's what I said, no?
05:45:50 <kindaro> Rewrite rules that reduce expressions to some very simple form.
05:47:19 <kindaro> Flonk, when you post your question, do send me a link.
05:47:22 <merijn> What's the confusion, then?
05:47:38 <kindaro> merijn, am I correct in putting it that way?
05:48:51 <Flonk> Okay I'll throw it out there. He mentions almost in passing (20.1) how the recursive type µD. D->D embeds all of untyped lambda calculus
05:48:52 <merijn> Yes? (I think, tbh, I never really consider evaluation in terms of rewriting)
05:49:00 <Flonk> But that type derailed me a bit. How does that work?
05:51:12 <kindaro> merijn, So how do you consider it? Do you imagine a collection of expressions and a directed graph of evaluation steps upon them?
05:53:06 <merijn> Good question, with a nebulous and ill-defined answer ;)
05:53:39 <kindaro> I like nebulous and ill-defined answers in my math.
05:54:46 <kindaro> For example, as I see it, his statement of "determinacy" is the same as saying that the graph has all outbound degrees 0 or 1. Then he is saying that "every value is in normal form", so vertices with degree 0 are values.
05:55:09 <kindaro> When I put it this way, I can clearly see what he is talking about.
05:55:39 <Putonlalla> When people say rewriting, it usually involves searching for matching subexpressions. In the case of small-step semantics, this search does not happen.
05:56:46 <Putonlalla> That's why it's strange to call it rewriting, kindaro.
05:56:51 <kindaro> Putonlalla, Can you explain?
05:57:27 <kindaro> Do you mean that the sub-expression to be rewritten is pointed at by the structure of the phrase under evaluation?
05:58:47 <Putonlalla> Consider simplifying the logical expression `(x && 0) && 1`.
05:59:14 <kindaro> It evaluates to False.
05:59:31 <Putonlalla> Don't be so hasty.
05:59:39 <kindaro> Sure, I'm with you.
06:00:27 <Putonlalla> Let's say you only have a rewrite rule saying that, for all `x`, the expression `x && 0` becomes `0`.
06:00:51 <kindaro> Then I am lost at `0 && 1`.
06:01:07 <Putonlalla> You cannot apply this rule at top level, because the whole expression has the form `_ && 1`.
06:01:27 <Putonlalla> Typical small-step semantics would get stuck here.
06:02:06 <Putonlalla> In a typical rewriting system, however, you would assume the existence of an additional rewrite rule that allows looking inside and simplifying the `_`.
06:02:06 <kindaro> Even if I evaluate the left branch first, I am still stuck.
06:02:27 <merijn> kindaro: You can't evaluate the left branch, there's no rule for that
06:02:46 <kindaro> So what you are saying is that these rules only apply at the root?
06:02:56 <Putonlalla> That's the difference, yes.
06:03:20 <kindaro> Is it this operation that is called "single step semantics"?
06:03:51 <lyxia> Flonk: Let T = (μD. D -> D), then by definition  T = T -> T. In the untyped lambda calculus everything is a function and can be applied to anything. By giving any term type T, you can always unfold T to (T -> T) and apply it to another term.
06:04:15 <Putonlalla> You can bridge the gap by adding such a rule that, for all `x` and `y`, if `x` becomes `z` and `y` becomes `w`, then `x && y` becomes `z && w`.
06:05:30 <Putonlalla> This is usually called congruence or respectfulness, so keep an eye out for those terms.
06:09:03 <kindaro> So, a "semantic" rule is a rewrite of rooted trees that applies to the root, right? Also, it is allowed to refer to edges between other vertices, given that the vertices being referred to are connected by the relation of inclusion to the vertex under consideration?
06:12:08 <statusfailed> with GHC.TypeNats, is there a way to tell GHC that (KnownNat n, KnownNat m) => KnownNat (n + m) ?
06:13:34 <phadej> no without "cheating"
06:14:27 <statusfailed> aw
06:14:28 <statusfailed> what's cheating?
06:17:17 <phadej> see constraints or ghc-typelits-knownnat
06:19:41 <inkbottle> attoparsec doesn't have a 'many'? However it has a many' which supposes the "type constructor" belongs to MonadPlus. I suppose that it is turned into plain many if I do import Control.Applicative (many)
06:20:41 <statusfailed> phadej: ooh nice, thank you!
06:22:39 <merijn> inkbottle: That's on purpose, Alternative/MonadPlus are part of the API, so it's encouraged to use the existing Alternative functions
06:23:02 <merijn> inkbottle: Same goes for things like guard, optional, asum
06:25:38 <inkbottle> merijn: you mean it's encouraged to use many from Control.Applicative, of many' from Data.Attoparsec.Text?
06:26:28 <Flonk> lyxia, yeeeah, that makes sense actually.
06:26:34 <Flonk> I'll go through more examples but it's clicking.
06:37:28 <inkbottle> merijn: I suppose I guessed which way around you meant; maybe it wasn't even ambiguous in the first place ;)
06:40:21 <kindaro> Maybe it is better to put what I am asking as whether type theory as described by Benjamin Pierce can be connected to the Mathematics at large, and more specifically whether I can give a "geometric", "graphical" meaning to his propositions.
06:42:57 <kindaro> It seems that Benjamin is very fond of a blind "algebraic" way of thinking, and I find it hard to concentrate on his seemingly endless derivations without some large scale vision.
06:44:09 <p0a> don't confuse presentation with thinking
06:44:13 <merijn> kindaro: Well, it brings us back to one of my first questions: Why did you decide to read it and with what goal?
06:44:25 <p0a> Just because he is presenting something in some way doesn't mean he thinks that way
06:44:56 <kindaro> p0a, this is exactly what I want to discover: what is the actual mind behind the book.
06:45:45 <p0a> kindaro: a lot of it just mathematical sophistication
06:45:51 <p0a> if you do a lot of math it just gets easier
06:46:26 <p0a> types didn't spawn out of nowhere, it's a collective work spanning centuries
06:51:41 <kindaro> merijn, It is widely advised as a great introduction to, well, types and programming languages. I was hoping that it will open my mind to research that is yet not approachable.
06:52:09 <kindaro> I mean, there is a lot of papers out there that seem to require some sort of background.
06:52:22 <kindaro> I am trying to assemble that background.
06:52:50 <kindaro> Like maybe this: http://programatica.cs.pdx.edu/P/plogic.pdf
06:53:41 <kindaro> So, I do not really have a specific problem I want to solve.
06:55:57 <p0a> reading others' research is hard already, but if you are not a researcher yourself it might be nigh impossible
06:56:38 <merijn> kindaro: Right, but my point is that you seem to complain that there's a lot of stuff describing "basic" things like boolean logic, but I don't really understand why you think you can skip those
06:56:57 <merijn> kindaro: If you want to support, say, boolean logic in your language you're going to have to define what it means
06:57:37 <merijn> The fact that there's centuries of writing on boolean algebra is irrelevant, because saying "just do that" while handwaving at literature is not (currently) supported by any computer or programming language
06:58:47 <merijn> So you're going to have to define all the tedious bit and you have to understand how and why to define the tedious bits yourself, because you'll have to do it for any other existing mathematical abstraction too
06:59:23 <merijn> If your goal is not "understanding how to describe these things and their meaning" then there's not much value to be had from the book
07:00:20 <merijn> As type systems are mostly about "having tediously defined these things, what sort of things can we prove about them without going through the bother of actually *executing* the tedious steps, and how do we prove our proofs, in fact, correspond to all the tedious steps"
07:00:54 <merijn> Which, yes, requires a lot of tedious formal bookkeeping of mostly trivial facts
07:03:06 <kindaro> merijn, so, what you are saying is that this book is more a practical handbook than a theoretical overview? Where should I go for theory and big connexions then?
07:03:41 <merijn> Theory and big connections? Category theory and homotopy type theory, probably
07:03:54 <merijn> Although that's basically not really related to programming anymore
07:04:22 <kindaro> The basics of Category theory were very useful to me in all kinds of ways.
07:04:44 <kindaro> But I have not been able to approach the Homotopy Type Theory so far.
07:08:26 <amit1> Hi everyone, nice to meet you all. I'm currently learning haskell and just checking out this chat. I'm also new to use irc chats so apologies if I do something stupid!
07:08:37 <amit1> using*
07:08:50 <boxscape> welcome
07:08:54 <fendor> amit1, Hi! 
07:09:09 <Taneb> Hello, amit1! How are you enjoying Haskell so far?
07:10:53 <amit1> I love it so far. Just finished Graham Hutton's "Programming in Haskell" and just starting reading "Haskell Programming from First Principles"
07:12:22 <amit1> Reasons for picking up the second book was that I was hoping to use servant but noticed it uses things like type operators and Kinds which weren't covered in Huttons books.
07:14:34 <Taneb> Yeah, those are non-standard features. They're not too complicated to use, though! For non-standard features I recommend looking them up in the GHC User Guide when you need to, for example https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeOperators
07:15:22 <Taneb> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion is a good resource for data kinds, too
07:15:58 <boxscape> I wouldn't call kinds a non-standard feature. Though I suppose there aren't really any standard features that make them transparent to users
07:16:43 <amit1> Thanks I'll keep that in mind :)
07:18:34 <amit1> Do you think its feasible for me to make a website using a haskell/elm tech stack provided I don't have any web dev experience apart from a little bit of ReactJS? What else do you recommend for the tech stack (Docker, Kubernetes, Stack, etc)
07:19:11 <Taneb> amit1: if it's something you thing you'll enjoy doing and you don't set yourself a time limit, then sure!
07:19:15 <p0a> lol I'm also trying to make a website and in the same boat as you amit1 
07:19:33 <p0a> although maybe even less experienced
07:20:20 <p0a> ah sorry, you said `tech stack'. I am trying to make a website 
07:21:31 <Taneb> amit1: I wouldn't overcomplicate things too much to begin with. GHC and Cabal should be fine for the Haskell side, and Elm for the frontend.
07:21:59 <amit1> @p0a I'm also trying to make a website. By tech stack I just mean languages and tools etc.
07:21:59 <lambdabot> (line 1, column 86):
07:21:59 <lambdabot> unexpected end of input
07:21:59 <lambdabot> expecting white space or simple term
07:22:08 <amit1> :p0a I'm also trying to make a website. By tech stack I just mean languages and tools etc.
07:22:12 <maerwald> amit1: typescript for frontend with react
07:23:00 <amit1> :Taneb and servant too?
07:23:11 <kuribas> is it lawful to make an applicative instance more efficient than a monad instance?
07:23:12 <Taneb> Yes
07:23:24 <Taneb> kuribas: yes, as long as it doesn't change the semantics
07:23:51 <kuribas> Taneb: well, the applicative can combine requests to the engine, while the monad instance cannot
07:24:54 <amit1> :Taneb I think where I'm a bit lost is that I have no idea what I need/what to do for a website apart from the frontend. Eg. Databases and user authentication etc etc. 
07:25:10 <Taneb> Depends what kind of website you're creating
07:25:50 <kuribas> amit1: servant is nice when you have a REST API, otherwise I'd use something like spock or scotty
07:26:43 <amit1> And in what situation is Spock and Scotty preferable?
07:26:48 <maerwald> servant will get you frustration quickly as a beginner
07:27:14 <kuribas> amit1: if you don't have an API that you expose one way or the other, there is not much use for servant.
07:27:28 <kuribas> amit1: it's just overhead for little benifit.
07:27:48 <Solonarv> kuribas: as long as the difference isn't observable using the safe API you expose, that seems totally fine to me
07:28:04 <kuribas> Solonarv: ok, thx
07:28:25 <maybefbi> amit1, you need to get fluent in aeson before writing web APIs in haskell
07:29:10 <Taneb> maybefbi: only if you'll be using JSON
07:29:25 <kuribas> Taneb: why use servant if not for JSON?
07:29:33 <maybefbi> these days most people use JSON
07:29:45 <maybefbi> especially people coming from reactjs world
07:29:54 <Taneb> kuribas: learning to use libraries that use datakinds heavily?
07:30:25 <amit1> :maybefbi and everyone else maybe worth pointing out that I'm a data scientist and my experience with reactJS was because I was bored and helped up the dev team at work for a few months
07:30:49 <kuribas> I don't even see why websites these days all need to have heavy front-end stuff
07:31:00 <kuribas> just html/css is good for most things
07:31:15 <kuribas> and a tiny bit of JS for UI interaction
07:31:52 <amit1> :maybefbi I'm also open to putting building a website on hold if you think I need more knowledge of other things. Is there some sort of suggested road map from learning haskell from scratch up to building websites with haskell?
07:31:53 <maybefbi> kuribas, i bet you have never had to inherit code like that
07:32:11 <kuribas> maybefbi: I looked a bit at wordpress
07:32:28 <kuribas> it's not the greatest code, but the problem is more the language than the model
07:32:41 <kuribas> and to much cruft
07:32:59 <maybefbi> kuribas, my predecessor wrote haskell web apps which emits html + css and JS in global namespace
07:33:20 <maybefbi> it was such a nightmare that even she couldnt deliver future features
07:33:24 <amit1> :kuribas i don't think that's true we make web apps for clients at work and they are essentially single page applications that require a lot of logic handling for the UI
07:33:36 <kuribas> maybefbi: sounds like there may have been other problems
07:33:45 <maybefbi> you underestimate this woman
07:33:55 <maybefbi> her code was elegant
07:34:07 <maybefbi> she was the smartest in the entire company
07:34:08 <kuribas> maybefbi: I don't know, all I have is what you said :)
07:34:14 <maybefbi> :)
07:34:15 <kuribas> maybe the html was contrived
07:34:39 <kuribas> you need clean, semantic html
07:34:49 <amit1> I'm off guys. Thanks for the advice by the way :)
07:34:53 <amit1> cya :)
07:34:56 <maybefbi> amit1, bye
07:35:00 <amit1> *guys and girls
07:36:48 <kuribas> otherwise I would use purescript + FRP to make logic more manageble
07:41:53 * hackage call-alloy 0.2.0.1 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.0.1 (marcellus)
07:50:01 <pounce> >show haskell to my friend "wow this language looks really old"
07:50:08 <pounce> w-what did he mean by this
07:50:29 <merijn> pounce: To be fair, it's pretty old compared to most mainstream languages (except for C/C++) :p
07:50:32 <Putonlalla> Big and ugly.
07:50:38 <yushyin> 30years is old
07:50:51 <MarcelineVQ> attractively dusted with silver
07:50:52 <merijn> yushyin: I can hear Fortran laughing in the background
07:51:09 <pounce> think the only language i use which is newer is rust
07:52:02 <Rembane> Javascript is younger
07:52:10 <pounce> well i don't program in that lol
07:52:11 <Rembane> ...than Haskell but not Rust 
07:52:20 <merijn> pounce: I mean, Haskell predates python/java/javascript/ruby/C#/PHP, so :)
07:52:32 <pounce> yeah i think im just used to old languages
07:52:50 <pounce> but it feels weird to me because all the other old languages i use (lisps, c, awk, perl, etc) feel much more dated than haskell
07:53:05 <pounce> FORTRAN, lol
07:53:14 <merijn> pounce: Why are you laughing? >.>
07:53:16 <chambln> What exactly makes a language feel 'new'?
07:53:27 <pounce> idk that's what got me thinkin
07:53:44 <pounce> i think he equates newness with object oriented scripting languages so maybe that's why?
07:53:45 <merijn> pounce: I mean, C was dated the moment is was first made
07:54:11 <yushyin> a bit like golang
07:54:14 <merijn> pounce: Algol-68 predates it by a good bit (like a decade?) and was considerably more modern
07:54:38 <yushyin> pounce: better ask your friend in more detail about it.
08:08:46 <monochrom> Simula and Smalltalk are so new then. >:)
08:10:21 <monochrom> In fact Smalltalk is so new, their only compiler is inside their IDE, so you must use their IDE and not your own choice, and their IDE is the most graphical of all.
08:11:24 <boxscape> "Smalltalk took second place for "most loved programming language" in the Stack Overflow Developer Survey in 2017,[4] but it was not among the 26 most loved programming languages of the 2018 survey."
08:11:27 <boxscape> interesting
08:11:53 <MarcelineVQ> that's the kind of result that questions the methods
08:12:00 <boxscape> yeah
08:13:04 <monochrom> The Simula guys Ole-Johan Dahl and Kristen Nygaard got a Turing Award for their OOP in Simula.
08:14:11 <Rembane> Are there any Simula code in the wild? 
08:25:44 <merijn> Rembane: Probably
08:26:13 <fgaz> So I just noticed wxHaskell does not build with ghc 8.6 and it doesn't receive an update since 2017. Is it unmaintained? That would be too bad, wx is great imo
08:26:30 <merijn> fgaz: I recal wxHaskell no longer being updated on hackage?
08:27:25 <fgaz> merijin: only on hackage or at all?
08:27:38 <fgaz> I see no activity on sourceforge
08:27:45 <merijn> Ah, wait, maybe I'm thinking of a different GUI library
08:27:48 <merijn> There was one, anyway
08:28:02 <merijn> fgaz: Github has a commit from December and a version newer than on Hackage
08:28:38 <merijn> No, looks like I was right
08:28:58 <merijn> Github has wxHaskell 0.93 as of 3 years ago. Newest on hackage is 0.92
08:29:12 <fgaz> Oh I see, the code is on github. Weeird.
08:30:07 <merijn> Although that also doesn't support 8.6
08:30:41 <fgaz> Well, better than nothing. I could add support I guess
08:31:22 <fgaz> Is there any good alternative that isn't a nightmare to build and supports tree/table views?
08:33:01 <merijn> No clue, I haven't done an GUI stuff yet, I hope that by procrastinating that long enough someone else will fix things for me ;)
08:49:08 <tdammers> I wouldn't dare go to a Turing Awards ceremony... you never know whether it will ever end...
08:50:27 <merijn> >.>
08:53:34 <Rembane> :D
08:59:27 <sm[m]> fgaz[m] (IRC): search recent haskell reddit posts asking this question, there's a summary that gets reposted there
09:00:02 <sm[m]> fltkhs is usually considered the most buildable, though is non-native-looking
09:00:27 <sm[m]> sorry, I meant: fgaz
09:02:35 <fgaz> simonmic[m]: is fltkhs the ugly one?
09:03:03 <fgaz> Oh yes it is, I saw a screenshot :D
09:03:29 <fgaz> Thanks for the reddit advice
09:05:40 <fog> recently was watching the youtube lectures; Designing Dependently-Typed Programming Languages -  Stephanie Weirich
09:06:29 <fog> which are here; https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html
09:07:07 <fog> and there was a github for it; https://github.com/sweirich/pi-forall/tree/2014
09:07:43 <sm[m]> is it ugly if it builds and works on all platforms ? if it has a rich mature set of widgets ? if you can define your own widgets in haskell ? if it's actively maintained ? I dunno, it starts looking more attractive to me :)
09:10:35 <fog> I was trying to find if there was some support for parsing, i rember it was mentioned in the lectures, might have to watch again to try and find it
09:13:25 <fgaz> simonmic: I agree, it was just a joke. I actually tried qtquick earlier today and I'm baffled that there isn't an official tree/table view on the maintained version (qtquickcontrols2). And it's one of the leading gui toolkits! They seem to focus on mobile, apparently…
09:14:19 <fog> ah, i have found mention of the "unbound" library, i think that was it
09:15:24 <fog> http://hackage.haskell.org/package/unbound-0.4.3.1
09:15:37 <sm[m]> there's also the webby options - particularly flutter IMHO
09:16:23 <fog> and heres where it was mentioned, in the context of "variable binding"; https://github.com/sweirich/pi-forall/blob/2014/notes2.md
09:16:56 <fog> any idea what this is?
09:17:28 <fgaz> simonmic: isn't that tightly coupled with dart?
09:22:49 <sm[m]> yes, you'd have to have a dart UI talking to haskell backend (one way or another)
09:25:53 <fog> sm[m]: is that this? https://dart.dev/guides/language/specifications/DartLangSpec-v2.2.pdf
09:26:03 <fog> its built on haskell?
09:26:38 <fog> or are you proposing a new backend?
09:27:48 <fog> or it something to do with "flutter" ?
09:29:02 <sm[m]> woah, take it easy. No connection with haskell and flutter that I know of
09:29:24 <sm[m]> built on haskell ? I wish !
09:29:41 <fog> all i can find is a kotlin to dart tranlator written in haskell; https://github.com/ice1000/Kt2Dart
09:30:38 <fog> how is this dart UI sopposed to drive haskell then? like how haskell drives C for its memory and process managment?
09:31:17 <sm[m]> fog: people often use something like electron to package up a server and web client as a "desktop app"
09:31:42 <sm[m]> people also do custom rpc-type things
09:32:11 <sm[m]> hledger-web runs a yesod server and just spawns a web browser as UI
09:33:03 <sm[m]> directly linking dart to haskell via FFI might be possible, but that's usually much harder
09:33:09 <fog> yeah, makes sense... seems like a fairly cross platform approach
09:33:20 <sm[m]> exactly
09:33:49 <fog> this is for mobile dev right?
09:34:16 <fog> i dont get "why dart" ?
09:34:47 <sm[m]> I'm not sure how much of history you've seen
09:35:24 <fog> just that its used by flutter, which i guess you wanted for the web interface
09:35:53 <sm[m]> I didn't mean mobile specifically. fgaz asked about haskell GUI alternatives to wxwindows. I suggested fltkhs, but also mentioned that web UIs and IMHO specifically flutter are often an option
09:36:05 <fog> hadnt heard of either until you mentioned it
09:37:43 <fog> oh, ok, so like SDL isnt cross platform enough
09:38:04 <fog> i guess GL is fairly outdated by now
09:38:19 <fgaz> SDL is a bit low level for what I have to do...
09:38:22 <fog> wxwindows is difficult to build with cabal
09:38:44 <fog> fgaz: fair
09:39:07 <fog> does it need to be cross platform though?
09:39:46 <fog> not sure about iOS and macOS, mostly just windows and android via obsidian 
09:39:49 <fgaz> fog: re wxwidgets: yeah I am getting some wxc includes errors atm
09:40:02 <fgaz> just linux drsktop
09:40:04 <fgaz> Possibly osx
09:40:48 <fog> i figure building core windows tools is kind of specialist with some build intricacies 
09:41:27 <fgaz> Not planning to support windows
09:45:26 <fgaz> So far I managed to build qtah and fltkhs
09:45:59 <fgaz> Too bad for wx, I liked the mid-level interface
09:48:56 <sm[m]> fgaz[m] (IRC): congrats.. just installed the frameworks, not built your app with them ?
09:49:04 <sm[m]> dangit riot
09:51:49 <fgaz> Well yeah. Little steps :)
09:52:39 <sm> hm. When I click your nick in riot, it shows up corrupted in riot, but appears correctly as fgaz[m] in IRC. Well that's something
09:53:21 <glguy> There's no "fgaz[m]" on IRC
09:53:38 <informer[m]> sm: fgaz[m] (IRC) 
09:53:42 <informer[m]> yep by me too
09:54:23 <fgaz> Matrix being matrix ¯_(ツ)_/¯
09:54:48 <fgaz> (I hope it didn't cut the slash in the kaomoji)
09:54:53 <sm> wow, you're right glguy. So confused.
09:54:58 <geekosaur> it did
09:55:39 <sm> well. fgaz is logged in from matrix. We don't see [m] on IRC because they customized their IRC appearance I guess. But Riot still shows it.
09:56:07 * glguy feigns surprise at matrix being bad at IRC
09:56:35 <sm> I think it does pretty darn well considering
09:56:55 <glguy> considering what?
09:57:07 <sm> bridging such complex chat systems smoothly is a really tough challenge
09:57:28 <sm> and most of the time it works rather well
09:57:42 <fgaz> True. And there are bridges for everything
09:58:42 <fgaz> Well actually just today I discovered another issue: try to join #sr.ht (@freenode) with matrix
10:00:44 <sm[m]> is it ok if I don't try ? I have enough issues
10:03:51 <fgaz> It's nothing harmful. The matrix bot left the room or something so it appears that you have no permission to write (or see messages other than membership changes for that matter)
10:04:56 <sm[m]> back to Haskell. In other news, the Cardano testnet seems to be going well. Currently running on rust nodes which were supposed to be "quick & dirty". In a little while, these are due to be replaced by haskell nodes which are supposed to be "high quality". It's interesting.
10:05:19 <sm[m]> and kind of a high profile event for Haskell in a new market
10:09:28 <glguy> Fingers crossed that high quality Haskell is better than quick and dirty rust!
10:09:49 <sm[m]> yeah! :)
10:18:29 <Phyx-> fog: why ? I was able to build wxhaskell back at uni on Windows fine
10:18:37 <Phyx-> granted that was a decade ago...
10:18:45 <Phyx-> but what makes it hard?
10:19:08 <geekosaur> wxwidgets kept changing in ways that broke the bindings, iirc, and the devs gave up
10:23:22 <ArticulateHacker> Hello. I'm working through the Allen/Moronuki book
10:24:52 <ArticulateHacker> In this example, it looks like https://snipboard.io/Fuhaq0.jpg I'm not getting step 4
10:26:58 <opqdonut> ArticulateHacker: (\p.p) got substituted for y
10:27:16 <opqdonut> so it was one step of beta reduction (function application)
10:29:00 <LordBrain> Hello
10:29:43 <LordBrain> Is there a way to add a named environment to a cabal.project file?
10:30:05 <LordBrain> or a package database
10:35:11 <ArticulateHacker> opqdonut I added some extra brackets and it made sense
10:35:26 <koz_> What's the Allen/Moronuki book?
10:36:28 <ArticulateHacker> it's been pretty awesome so far. it's like 1000 pages... one sec for link
10:36:43 <LordBrain> nvm
10:36:55 <LordBrain> i think all i need is to v2-install all the libs
10:37:09 <MarcelineVQ> koz_: haskell progamming from first principles
10:37:17 <ArticulateHacker> koz_ https://haskellbook.com/
10:37:30 <LordBrain> which i already have
10:43:10 <maerwald> LordBrain: what do you mean with named environment?
10:44:03 <LordBrain> maerwald, well, i dont actually need this, but i meant a named environment that ghc --package-env accepts... the environment files stored in .ghc/environments
10:45:23 <LordBrain> For example, i've created a named environment for gtk apps called gtk.
10:46:10 <LordBrain> so i can compile gtk programs with ghc -package-env gtk Main.hs -o simpleGtkProg
10:46:35 <LordBrain> I like this feature, I hope they continue to support it.
10:47:25 <LordBrain> But since we're talking about it, I find I do get an issue when trying to use ghci with this particular environment
10:48:46 <LordBrain> when i try the command: ghci -pacakge-env gtk
10:49:07 <LordBrain> I get a seeming linker error
10:49:29 <LordBrain> can't load .so/.DLL for: /src/gtkE/dist-newstyle/build/x86_64-linux/ghc-8.6.5/gi-gtk-3.0.32/build/libHSgi-gtk-3.0.32-inplace-ghc8.6.5.so (/src/gtkE/dist-newstyle/build/x86_64-linux/ghc-8.6.5/gi-gtk-3.0.32/build/libHSgi-gtk-3.0.32-inplace-ghc8.6.5.so: undefined symbol: gtk_cell_accessible_parent_get_row_header_cells)
10:49:57 <LordBrain> I don't know why
10:50:08 <LordBrain> I'd like that fixed if at all possible
10:50:19 <LordBrain> using ghc seems to work out fine
10:50:58 <LordBrain> Anyone know what's going on here?
10:53:27 <fgaz> Maybe that library does not support interpreted mode?
10:54:19 <LordBrain> fgaz, that sounds like a possibility, whats involved in supporting interpretted mode tho?  It may be all the gi-* libraries don't... It would be nice if they did tho.
10:54:35 <inkbottle> What is the '!' in 'go !offsetBegin' in https://github.com/jamesdbrock/replace-attoparsec/blob/master/src/Replace/Attoparsec/Text.hs
10:54:55 <glguy> it's a "bang pattern"
10:54:55 <__monty__> inkbottle: A strictness annotation.
10:55:04 <inkbottle> okay
10:55:15 <LordBrain> inkbottle, enabled by BangPatterns
10:55:18 <glguy> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=xbangpatterns#extension-BangPatterns
10:56:02 <inkbottle> ...
10:56:28 <LordBrain> Where can I track down if there is an issue pertaining to gi-gtk and related libraries and interpretting?
10:57:48 <LordBrain> one can write gtk apps from other interpretted langauges, like python, it would be nice if we could use haskell... 
10:58:55 <dsal> What do you mean "other interpreted languages" ?
10:59:01 <dsal> It seems to be UI day in here, though. heh
10:59:02 <inkbottle> thanks for the strictness annotation; I remember now what it is
10:59:43 <LordBrain> dsal, i am looking at an issue that applies only when using ghci not ghc
10:59:47 <orzo> When I try to use -with-rtsopts="-I0" to default disable on-idle garbage collection, at run time, I get immediate termination with 'unexpected RTS argument: "-I0"'.  Is it not possible to disable idle garbage collection by default?
11:00:23 * hackage genvalidity-hspec 0.7.0.3 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.7.0.3 (Norfair)
11:01:32 <orzo> it accepted +RTS -I0 just fine on the command line before i tried to default it with -with-rtsopts="-I0"
11:03:23 * hackage genvalidity-path 0.3.0.3 - GenValidity support for Path  https://hackage.haskell.org/package/genvalidity-path-0.3.0.3 (Norfair)
11:04:19 <sm[m]> LordBrain: how about checking gi-gtk's issue tracker ?
11:04:46 <MarcelineVQ> orzo: some literal problem maybe e.g.  +RTS \"-I0\"  will give that error
11:06:17 <MarcelineVQ> that is to say the error is unexpected RTS argument: "-I0"     rather than  unexpected RTS argument: -I0
11:06:20 <geekosaur> "on the command line" is this in a cabal file?
11:06:25 <geekosaur> or stack?
11:06:37 <LordBrain> sm[m], i looked at haskell-gi's issue tracker, gi-gtk is generated i'm not sure it has a separate github, does it?
11:06:57 <geekosaur> because cabal doesn't support shell-style quoting so you'd need to omit the ""
11:07:15 <orzo> In the cabal file, it tried but it did not work: ghc-options:       -rtsopts -with-rtsopts="-I0"
11:07:26 <geekosaur> right, leave off thhe quotes
11:07:38 <geekosaur> those are understood by shells. cabal files are not read by shells
11:07:43 <orzo> When I say "on the command line" i  mean that before adding that in the cabal file, I ran the binary with +RTS -I0 directly and it was not an issue
11:08:38 <p0a> How do Hamlet files work?
11:08:57 <orzo> if there was more than one option RTS option to be defaulted, how would I indicate that to cabal? Wouldn't a space cause it to pase it as multiple arguments to ghc?
11:09:54 <sm[m]> LordBrain: no it doesn't.. its hackage page links to haskell-gi
11:09:57 <geekosaur> yes. cabal doesn't handle this situation well at present; you would need to use multiple -with-rtsopts options and hope it combines them
11:10:09 <p0a> oh I have a hamlet file and I feed it into the QuasiQuoter right?
11:10:11 <orzo> i see, thanks
11:11:23 <sm[m]> p0a, if you mean how do I use them.. https://www.yesodweb.com/book/shakespearean-templates
11:11:42 <orzo> orzo: your suggestion seems to have worked.  Thanks again.
11:12:43 <orzo> geekosaur: I meant you, not "orzo" who is me. ;)
11:16:03 <p0a> sm[m]: right I realized later I haveto use the shamlet QQ
11:16:12 <p0a> thank you though
11:20:32 <ephemient> orzo: alternately, ghc-options: -threaded -rtsopts "-with-rtsopts=-N -qg" worked in my .cabal
11:21:28 <p0a> sm[m]: is the online book word-for-word the same with the oreilly print
11:21:34 <p0a> Or are they different? Do you know?
11:22:15 <sm[m]> I don't know, but I would guess: they were at publishing time, but now the online is more current
11:23:32 <p0a> I was just a bit confused on the shakespeare chapter because it dropped some hamlet/julius/cassius code without telling me if these are files or what and what's the code about
11:23:37 <p0a> I think I just need to read on though
11:23:57 <orzo> ephemient: ah, okay
11:28:23 * hackage japanese-holidays 1.0.0.0 - Japanese holidays utility  https://hackage.haskell.org/package/japanese-holidays-1.0.0.0 (cohei)
11:41:37 <p0a> I have to admit type safe URLs in yesod have me hooked
11:54:23 * hackage rib 0.6.0.0 - Static site generator using Shake  https://hackage.haskell.org/package/rib-0.6.0.0 (sridca)
11:56:37 <srid> o/
12:04:01 <svipal> o
12:04:04 <svipal> yo*
12:04:25 <svipal> suppose you need a map, but you never need to do toList
12:04:54 <svipal> you'd only need to lookup, insert or modify
12:05:29 <svipal> You already know beforehand all the possible values. is it ok to not use a map and just use a function from the key type to Maybe value type
12:05:38 <svipal> all the possible keys* ^
12:05:53 <svipal> performance wise, usability wise ?
12:06:38 <svipal> by map I mean a datastructure like Data.Map  
12:07:31 <dsal> That's very common.  You wouldn't make a map of Bool -> X in that case just to have a function that takes a bool.
12:08:40 <svipal> yeah
12:10:58 <svipal> the only problem is that to insert I'd do something like `insert key value  holder = newholder where newholder k = if k==key then value else holder k`
12:11:33 <dsal> Will you be inserting a lot?
12:11:36 <svipal> I don t think I d do  a lot of inserts. maybe 1000 at the maximum possible, but wouldnt that make the call stack quite high ?
12:12:39 <dsal> There are data structures, though.  If you're wanting general operations on things, you may  as well just use a data structure.
12:13:24 <svipal> ..I'm aware there are data structures. I'm just asking whether doing what I'm already doing is actually a bad idea in disguise
12:14:52 <nato> ... in the context of comparing monads and arrows, iirc, I can't remember where I thought I read that there are some things a monad cannot do (maybe because it somehow lost data). If that makes any sense, could somebody give a simple example and a little intuition so I can then try it out in code?
12:16:12 <dsal> svipal: You can try it out, for sure.
12:17:53 * hackage patch 0.0.0.0 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.0.0 (JohnEricson)
12:17:58 <johnyginthehouse> As someone who is just starting to do mathematical work in the area of control theory -- a bit divorced I think from the background for category theory -- and just started learning Haskell, I really wanted to have a good place to get the background for Category theory and how it relates to Haskell. 
12:22:30 <merijn> johnyginthehouse: Honestly, the short story of how category theory relates to Haskell is "it doesn't"
12:23:14 <merijn> johnyginthehouse: The long story is "ok, secretly you can make some links, but that's mostly because you can make links from CT to nearly anything systematic"
12:23:37 <johnyginthehouse> yeah i just copied the top comment from an /r/haskell thread 
12:24:26 <merijn> johnyginthehouse: It also depends a bit on what your goals are, if the goal is "learn programming in Haskell" I would personally advice ignoring CT altogether until you reach like intermediate-advanced Haskell levels
12:25:15 <johnyginthehouse> ya but my goal was to post a random comment from r/haskell and see who responded with what
12:26:04 <johnyginthehouse> because I'm training my chat AI on low IQ subjects first and moving on to normal conversation
12:26:33 <dmwit> svipal: It's a pretty bad idea. Lookups will be linear-time. Why do you want to avoid Map?
12:27:55 <merijn> nato: Monads are always in the dark of what inputs generated a certain action
12:28:06 <dmwit> (It's a bad idea for all the same reasons that association lists are bad, and for even more reasons like not being able to garbage-collect after multiple insertions/modifications of a single key.)
12:28:26 <merijn> nato: i.e. suppose you have "a -> IO b" once you apply it to an 'a' and get 'IO b' you cannot (from the IO) recover that the input was an 'a'
12:29:08 --- mode: ChanServ set +o dmwit
12:29:25 --- kick: johnyginthehouse was kicked by dmwit (That's cool and all but we're not your lab rats.)
12:29:31 --- mode: dmwit set -o dmwit
12:29:56 <evelyn> dmwit++
12:36:09 <nato> merjin: that may have been part of it, thanks. Could it also be that in some cases bind can only be implemented in a pretty meaningless way as there is no `a` to apply the `f` too, so you can only return the `m a` (where `a` = `b` in `m a -> (a -> m b) -> m b`)
12:37:37 <svipal> dmwit, thanks
12:40:39 <nato> * passed in `m a`
12:43:04 <monochrom> Nothing >>= \a -> ...  would be a case when the \a -> ... has to be skipped.
12:44:21 <hololeap> data StoreT s w a = StoreT (w (s -> a)) s
12:44:42 <hololeap> is it just me or is it odd that it isn't (StoreT (s -> w a) s) instead?
12:45:23 * hackage usa-holidays 0.1.0.2 -   https://hackage.haskell.org/package/usa-holidays-0.1.0.2 (kkweon)
12:46:19 <hololeap> the way it is now, (StoreT s (Env e) a) is semantically identical to (EnvT e (StoreT s) a)
12:47:12 <hololeap> because the w is on the _outside_ of the function, so peek or peeks won't affect it
12:49:36 <hololeap> @unmtl StateT s (Reader r) a
12:49:36 <lambdabot> s -> r -> (a, s)
12:49:53 <hololeap> @unmtl ReaderT r (State s) a
12:49:53 <lambdabot> r -> s -> (a, s)
12:50:22 <hololeap> hmm, i guess it lines up with that
12:50:42 <nato> monochrom: could it be the case, then, that there was nothing that destructures to pattern-match against/bind to `a`? If so, could that possibly be a law abiding monad?
12:50:45 <hololeap> @unmtl StoreT s (Env e) a
12:50:45 <lambdabot> StoreT s (Env e) a
12:51:20 <monochrom> I don't understand the question.
12:52:02 <nato> well, in your example, iiuc, `Nothing` cannot be destructured to get an `a`
12:52:07 <monochrom> You probably need to come down to the value level and give examples.
12:52:57 <nato> I am actually trying to find an example so I can reverse engineer what I thought I read
12:53:34 <monochrom> By default, distrust wordy explanations.  Trust formulas, they're precise.
12:54:57 <hololeap> % :t \f w = let a = extract w in (a, f w)
12:54:57 <yahb> hololeap: ; <interactive>:1:6: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
12:55:06 <hololeap> % :t \f w -> let a = extract w in (a, f w)
12:55:06 <yahb> hololeap: Comonad w => (w a -> b) -> w a -> (a, b)
12:56:06 <monochrom> But "data Proxy a = Proxy" is a well-known minimal monad.
12:56:07 <dminuoso_> hololeap: Remember that StoreT is a comonad transformer.
12:56:33 <dminuoso_> (Not a monad transformer)
12:57:37 <dminuoso_> hololeap: Perhaps for comparison it might be helpful to use it's less used name CostateT
12:58:15 <hololeap> i know. i was perhaps confused about how StoreT works as a comonad transformer
12:58:57 <hololeap> % :t \f w -> (extract w, f w)
12:58:57 <yahb> hololeap: Comonad w => (w a -> b) -> w a -> (a, b)
12:59:16 <hololeap> i thought maybe there was a way to use a comonad transformer stack instead of this function
12:59:24 <hololeap> but it doesn't work correctly with extend
13:00:31 <hololeap> looking into it, i found out that my problem was that i assumed StoreT looked like (StoreT (s -> w a) s)
13:01:44 <dminuoso_> hololeap: Is it possible you are expecting this to be like ReaderT?
13:03:15 <hololeap> eh, i'm not sure i was expecting that. it was more that i realized that ((,) a) is a comonad that is isomorphic to Env, so i thought, "why not use (StoreT s (Env a) b) instead of (Store s (a,b)) ?"
13:04:15 <nato> so `bind` would just return `Proxy`, which similarly to `Nothing`, is a valid `m a` and `m b` ? If so, then maybe that is it. The `f` is totally unused, if that is the case.
13:04:32 <hololeap> but after i extract the `a` and put it in Env, it "sticks" whenever i use extend, which is not what i want
13:04:57 <hololeap> that `a` is supposed to be relative to what Store is pointing to
13:05:32 <dminuoso_> nato: Right.
13:05:46 <monochrom> Yes the type of Nothing can be Maybe b, the type of Proxy can be Proxy b.
13:05:51 <iqubic> comonads confuse me.
13:05:57 <monochrom> Enjoy polymorphism.
13:06:08 <monochrom> Humans confuse me too.
13:06:30 <dminuoso_> nato: I suppose one could think of Proxy as Const ()
13:06:35 <hololeap> iqubic: a lot of this effort is just me trying to get a better intuition for comonads, because i think they're really cool in principle
13:06:45 <iqubic> I know.
13:06:46 <monochrom> Much disparity between what they claim they want and how they behave (total opposite).
13:07:16 <nato> monochrom, maybe that is polymorphic too?
13:07:33 <monochrom> Err which?  Humans?
13:07:34 <dminuoso_> I think comonads dont have much power in Haskell. Monad is not useful because of its instances, but because we can write polymorphic code over it.
13:07:42 <dminuoso_> People rarely write comonad polymorphic code.
13:07:55 <dminuoso_> Merely using a specific comonad instance doesn't really make you use comonads
13:07:55 <nato> `behaviour -> desire`
13:08:14 <nato> or, vice versa!
13:08:24 <hololeap> well, i'm playing around with making an "advanced" conway's GoL in brick, as a test bed :)
13:08:38 <dminuoso_> hololeap: Sure, but that's rather about using Store/StoreT
13:08:44 <dminuoso_> (Or ComonadStore)
13:09:09 <dminuoso_> The moment you find yourself writing `f :: Comonad w => ...` is when you are truly using comonads.
13:09:37 <dminuoso_> It's sort of like claiming that writing code that adds numbers is about using monoids. It's a red herring
13:10:07 <dminuoso_> What I mean by that is, it
13:10:22 <hololeap> that's why i was trying to use a comonad stack instead! get myself unstuck from Store :)
13:11:19 <dminuoso_> Well there's just not many interesting comonads around sadly. :(
13:12:11 <nato> anyway, merijn (please excuse previous typo of your name), monchrom, thanks for the guidance, I will try to dig up the source to see if it reflects what you say, or there was some other reason for the claim.
13:14:36 <hololeap> type NeighborStrategy x y = BoardStore x y CellState -> (CellState, LivingNeighbors)
13:14:49 <hololeap> type LifeStrategy x y = BoardStore x y (CellState, LivingNeighbors) -> CellState
13:15:11 <hololeap> being able to do `extend (myNeighStrat =>= myLifeStrat) is truly beautiful
13:15:26 <hololeap> lol
13:17:52 <dminuoso_> hololeap: I suppose that's just separation into kernel and convolution. :)
13:18:15 <dminuoso_> Looks a bit weird, that way
13:18:30 <hololeap> get out of here with your fancy vocabulary D:<
13:18:45 <dminuoso_> hololeap: Are you familiar with how gaussian filters work?
13:19:18 <monochrom> Oh w00t, kernel and convolution :)
13:19:34 <monochrom> Much easier than monads and comonads, actually.
13:19:42 <hololeap> sort of... i know of gaussian blur, and i know that it can be implemented with Store on a 2d matrix
13:20:02 <dminuoso_> Actually, its not exactly a kernel though.
13:20:10 <dminuoso_> But it's somewhat similar, anyhow.
13:21:31 <monochrom> Suppose you do "moving-windowi weighted average" of a sequence (discrete time series especially).  You say, the average at time i = 0.2*x[i-2] + 0.5*x[i-1] + 0.3*x[i].
13:21:38 <dminuoso_> hololeap: https://slideplayer.org/slide/216520/1/images/5/1.+Bildvorverarbeitung+Faltung+mit+Gau%C3%9F-Filter.jpg
13:22:23 <monochrom> It is equivalent to the convolution between x[i]s and the finite sequence <0.2, 0.5, 0.3>.  The latter is called "kernel".
13:22:34 <dminuoso_> (So in your case your NeighborStrategy produces "kernel applied to the original image")
13:22:45 <monochrom> That's it.  Apart from generalizing to higher dimensions if you want.
13:22:49 <hololeap> yeah that does look very similar
13:23:11 <dminuoso_> convolutions are comonadic too
13:23:27 <hololeap> Bildvorverarbeitung!
13:24:36 <dminuoso_> hololeap: In fact, many image filters are the result of convolutions with just different kernel matrices.
13:25:32 <dminuoso_> Whether it's gaussian blur, edge detection, sharpening or other things, you could sort of describe it with some `applyKernel =>= convolute`
13:25:48 <hololeap> leet
13:25:51 <dminuoso_> (So different filters would be equivalent to just swapping out the kernel)
13:26:11 <monochrom> How you design kernels for various purposes and what properties different kernels have are down the rabbit hole of digital signal/image processing.
13:26:33 <hololeap> that was where i was hoping to take this "research" eventually
13:27:14 <dminuoso_> hololeap: Though a proper API would probably rather have some `data Kernel = ...` and then `convolute :: Kernel -> Image -> Pixel`
13:27:14 <monochrom> And the beautiful duality of DFT(convolution between x and y) = DFT(x) * DFT(y)  (DFT = discrete Fourier transform)
13:27:50 <dminuoso_> hololeap: Such that you could say `let gaussianBlur = convolute (gauss 2) in image =>= gaussianBlur`
13:28:03 <dminuoso_> where `gauss :: Integer -> Kernel`
13:28:28 <monochrom> To bring us back to ubitiquous category theory, that dualtiy equation is a commuting diagram >:)
13:29:05 <dminuoso_> Uh heh, that code above should read `gauss 3` of course. :)
13:31:40 <iqubic> Well, I'm disappointed. There's no mappendOf in lens.
13:32:09 <iqubic> Looks I'll just use foldlof'
13:35:40 <dminuoso_> iqubic: What would mappendOf do?
13:36:39 <dminuoso_> iqubic: are you possibly looking for just foldOf?
13:37:01 <iqubic> Yes.
13:37:14 <dminuoso_> Not sure what your disappointment is about then.
13:38:03 <iqubic> I was disappointed for a brief moment because I thought I was going to have to manually write this with foldlOf'
13:38:15 <dminuoso_> iqubic: well foldlOf' *is* that thing.
13:38:25 <dminuoso_> (Amongst the other non-strict or l/r versions)
13:42:43 <iqubic> So, I have an Iso' s a. I also have a lens operation that produces values of type 'a'. Is it possible to create a value of type 's'? I.E. apply the lens operation then the inverse of the Iso?
13:43:32 <phadej> :t _Identity
13:43:37 <lambdabot> error:
13:43:37 <lambdabot>     • Found hole: _Identity :: t
13:43:37 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
13:43:49 <phadej> :t iso Identity runIdentity
13:43:50 <lambdabot> (Profunctor p, Functor f) => p (Identity a) (f (Identity t)) -> p a (f t)
13:43:54 <phadej> that's an Iso
13:43:59 <iqubic> I know.
13:44:08 <iqubic> I know what an Iso is.
13:44:14 <phadej> view (iso Identity runIdentity) (Identity 'x')
13:44:20 <phadej> > view (iso Identity runIdentity) (Identity 'x')
13:44:23 <lambdabot>  Identity (Identity 'x')
13:44:28 <phadej> > review (iso Identity runIdentity) (Identity 'x')
13:44:30 <lambdabot>  'x'
13:44:33 <dminuoso_> phadej: When will we have optics in yahb? :)
13:44:47 <phadej> dminuoso_: ask maintainer of yahb :)
13:44:58 <phadej> but I think we won't, as lens and optics clash very badly
13:45:03 <phadej> (on purpose)
13:45:22 <dminuoso_> It would be neat if we could define module sets and unload/load them in GHCi for thus.
13:45:26 <phadej> or also
13:45:34 <phadej> > iso Identity runIdentity # Identity 'x'
13:45:36 <lambdabot>  'x'
13:45:42 <phadej> if you are an operator-fan
13:45:49 <phadej> c.g.
13:45:52 <phadej> > _Just # 'x'
13:45:55 <lambdabot>  Just 'x'
13:46:19 <zeta_0> could you guys break this code down and explain it to me, thanks:
13:46:24 <zeta_0> reverse' = foldl (\acc x -> x : acc) []
13:47:27 <dminuoso_> zeta_0: https://wiki.haskell.org/wikiupload/5/5a/Left-fold-transformation.png
13:47:30 <monochrom> Maybe you're more comfortable with the one missing list parameter?  reverse' xs = foldl (\acc x -> x : acc) [] xs
13:48:43 <maerwald> dminuoso_: that's a confusing picture
13:48:45 <dminuoso_> zeta_0: To emphasize, consider this rewritten form:
13:48:48 <monochrom> And also this explicit recursion version:  rev xs = go [] xs;  go acc [] = acc;  go acc (x:xs) = go (x : acc) xs
13:48:54 <dminuoso_> zeta_0: reverse' = foldl (flip (:)) []
13:48:59 <monochrom> You're using foldl for that go.
13:49:13 <zeta_0> thanks guys, i'll take look at the link
13:49:15 <dminuoso_> zeta_0: The key observation is that `f` is a *flipped* (:)
13:49:46 <dminuoso_> zeta_0: c.f. with:
13:50:01 <zeta_0> i understand recursion pretty good now, so a fold is an abstraction of recursion?
13:50:09 <dminuoso_> zeta_0: https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
13:50:13 <iqubic> I love it when I write code, and GHC infers a horrible type signature.
13:50:14 <dminuoso_> zeta_0: foldr (:) [] = id
13:50:20 <monochrom> Yes, but a very particular form of recursion.
13:50:38 <svipal> >I love it when I write code, and GHC infers a horrible type signature.
13:50:49 <svipal> same here
13:50:50 <dsal> zeta_0: Many languages have a concept of a "loop".  In classic BASIC, you had "goto".  some languages have these fancy "for" loops or "while" loops.  Some even have "foreach."
13:50:53 <svipal> but genuinely
13:51:08 <monochrom> It has to be "go acc [] = acc;  go acc (x:xs) = go (some function of acc and x) xs"
13:51:13 <phadej> foldl f y [1,2,3] = ((y `f` 1) `f` 2) `f` 3
13:51:15 <dsal> zeta_0: But in most of those cases, you're trying to *do* something.  These constructs only describe the "how"
13:51:20 <phadej> "fold from left"
13:51:24 <dminuoso_> zeta_0: foldl/foldr on list is something special. foldr basically replaces `:` and the end of the list [] with arbitrary things.
13:51:28 <monochrom> Because you look at foldl's code, it's exactly doing that, no more no less.
13:51:31 <dsal> fold, map, filter, etc... describe the "what"
13:51:35 <iqubic> But for real, just look at this: http://dpaste.com/3BYW18D
13:51:50 <dminuoso_> zeta_0: and foldl does it as well.. but sort of turned inside out
13:51:58 <dminuoso_> iqubic: That's not GHC, that's lens
13:52:13 <iqubic> dminuoso_: I know.
13:52:14 <dminuoso_> iqubic: If you had used `optics` instead, you would get a clean type signature
13:52:17 <iqubic> I know.
13:52:58 <iqubic> I just wish there was a cleaner way to express that type signature.
13:53:30 <zeta_0> ok, it's making a little bit more, sense, i am going to read those links now, thanks for the help guys
13:53:40 <phadej> iqubic: you can fold-back the type signatures
13:53:42 <phadej> in `lens`
13:53:46 <iqubic> How so?
13:53:47 <phadej> :t Optic
13:53:48 <lambdabot> error: Data constructor not in scope: Optic
13:53:54 <dsal> zeta_0: You'll eventually get frustrated with languages that only let you talk about "how"
13:53:55 <phadej> % :t Optic
13:53:55 <yahb> phadej: ; <interactive>:1:1: error: Data constructor not in scope: Optic
13:54:01 <phadej> % :t Control.Lens.Type.Optic
13:54:01 <yahb> phadej: ; <interactive>:1:1: error:; Not in scope: data constructor `Control.Lens.Type.Optic'; No module named `Control.Lens.Type' is imported.
13:54:04 <iqubic> I ran :t f in hoogle.
13:54:06 <phadej> % :t Control.Lens.Types.Optic
13:54:06 <yahb> phadej: ; <interactive>:1:1: error:; Not in scope: data constructor `Control.Lens.Types.Optic'; No module named `Control.Lens.Types' is imported.
13:54:07 <dminuoso_> zeta_0: Also, https://www.joachim-breitner.de/various/foldl-foldr-original.png might be a helpful diagram to compare foldl with foldr
13:54:08 <phadej> crap
13:54:13 <phadej> there's that optic
13:55:21 <phadej> though, maybe that type signature is actually non-sense, I'm not sure
13:55:34 <phadej> if you only want to reverse the iso, than there's `from`
13:55:36 <phadej> :t from
13:55:38 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
13:55:58 <phadej> :t from (iso Identity runIdentity) # 'x'
13:55:59 <lambdabot> Identity Char
13:56:14 <shachaf> Man, from is so much nicer on pure profunctor optics.
13:56:40 <phadej> shachaf: it's even nicer in `optics`
13:56:53 <iqubic> Maybe I should switch to the optics library and see how that works here.
13:56:53 * hackage patch 0.0.0.1 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.0.1 (JohnEricson)
13:57:11 <shachaf> phadej: How's that?
13:57:30 <iqubic> How hard is it to port code from lens to optics?
13:57:58 <phadej> shachaf: profunctor optics would have AnIso s t a b -> p t s -> p b a signature (for re/from); optics has Iso s t a b -> Iso b a t s
13:58:04 <phadej> *inferred signature
13:58:24 <shachaf> You mean because of a rank-2 thing?
13:58:27 <dminuoso_> bats..hit crazy!
13:58:36 <phadej> shachaf: yes
13:58:56 <phadej> iqubic: if you only use your self defined lenses/optics, then it's quite trivial
13:59:13 <phadej> sed -i 's/Control.Lens/Optics/' **/*.hs
13:59:14 <maerwald> monochrom: I think many get confused about foldr/foldl thinking they walk the input list from different sides or something
13:59:17 <iqubic> Cool. Execpt I'm not using only self defined lenses.
13:59:34 <dminuoso_> re :: "re" `AcceptsEmptyIndices` is => Optic k is s t a b -> Optic (ReversedOptic k) is b a t s 
13:59:53 <monochrom> This is why I don't point them to the pictures.  The pictures convey that message.
14:00:13 <iqubic> phadej: which libraries do I want to grab?
14:00:16 <dminuoso_> maerwald, monochrom: Hence me linking this picture: https://www.joachim-breitner.de/various/foldl-foldr-original.png
14:00:18 <monochrom> I invite them to compare foldl's code and go's code.
14:00:20 <dminuoso_> It can be visualized, but it has to be.
14:00:24 <shachaf> The nice thing about "from" in the pure profunctor case is that it can turn everything around, even things that weren't planned by the library, and it all works the same way.
14:00:26 <iqubic> Optics-core and and thing else?
14:00:36 <phadej> shachaf: so `optics` too
14:00:37 <dminuoso_> Oh holy
14:00:39 <dminuoso_> I mispasted!
14:00:54 <dminuoso_> https://www.joachim-breitner.de/various/foldl-foldr-flipped.png
14:00:56 <dminuoso_> :(
14:00:56 <phadej> shachaf: optics are internally profunctor-y; but the public interface is abstract
14:00:58 <monochrom> (Code clearly shows walking left to right.)
14:01:11 <maerwald> dminuoso_: heh, if that helps, I find it more helpful to write it step by step... 1 : [] -> 2 : 1 : [] -> ...
14:01:14 <dminuoso_> monochrom: Yeah, I had the wrong link in my clipboard and didn't notice.
14:01:17 <shachaf> phadej: I thought "optics" had a hard-wired hierarchy of optics that are supported, with the entire "inheritance" graph specified explicitly.
14:01:39 <iqubic> Which libraries do I want to install to use optics?
14:01:43 <phadej> shachaf: yes, but internally it's still profunctory, so there isn't n^2 implementations of composition e.g.
14:01:48 <shachaf> Sure.
14:01:49 <phadej> iqubic: just `optics`
14:02:08 <phadej> if in doubt
14:02:21 <iqubic> Oh. Oh. Right.
14:02:22 <phadej> optics: This is the "batteries-included" variant with many dependencies; see the optics-core package and other optics-* dependencies if you need a more limited dependency footprint.
14:02:45 <monochrom> I wonder if it's really batteries-depended.
14:02:53 <iqubic> I just realized that one of the things I'm doing in this project mght not work in Optics.
14:03:10 <phadej> which is?
14:03:28 <monochrom> "depends:  aa-battery >= 2, aaa-battery >= 4, lithium-ion >= 1" doesn't strike me as "included".
14:03:43 <iqubic> Lens-Aeson is the main thing: https://hackage.haskell.org/package/lens-aeson
14:04:01 <iqubic> Also using Lens' Deep and Transform combinators.
14:04:07 <phadej> iqubic: there's aeson-optics
14:04:18 <iqubic> There is? I didn't know that.
14:04:31 <phadej> @pkg aeson-optics
14:04:31 <lambdabot> Maybe you meant: pl ping msg bug
14:04:36 <phadej> :(
14:04:41 <dminuoso_> iqubic: https://hackage.haskell.org/package/aeson-optics
14:04:49 <phadej> https://hackage.haskell.org/packages/#cat:Optics
14:04:53 * dminuoso_ is phadej's personal acting lambdabot
14:05:12 <monochrom> w00t artificial human
14:05:21 <iqubic> phadej: Of course you would know about aeson-optics. Hackage lists you as the maintainer.
14:05:23 <shachaf> phadej: Anyway my assumption is that the "optics" thing is equivalent to the profunctor thing, since that's what it uses internally, and the interface is just more designed rather than discovered or something.
14:05:36 <dminuoso_> phadej: I take it you just copy and pasted aeson-lens and replaced it with optics equivalent parts?
14:05:40 <phadej> shachaf: yes
14:05:50 <dminuoso_> Because the implementation looks suspiciously similar. :)
14:05:56 <iqubic> I noticed.
14:06:01 <iqubic> This module also exports orphan Ixed Value and Plated Value instances
14:06:14 <monochrom> Plagiarism!  (Sorry I teach at a university.)
14:06:17 <iqubic> That's a lie. It doesn't seem to export Plated Value instances.
14:06:20 <phadej> dminuoso_: yes, Plated instance is missing, as such class don't  exist
14:06:23 <phadej> that's a mistake :(
14:06:30 <phadej> but, copy & paste
14:06:32 <iqubic> Oh. Damn it to hell.
14:06:45 <phadej> (it's in the code, commented out :)
14:07:09 <phadej> maybe if there's enough requests, we'll make optics-plated packages!
14:07:13 <phadej> package*
14:07:21 <phadej> oplated
14:07:22 <shachaf> i,i do you have upon?
14:07:30 <iqubic> Right, well, a thing I was doing relied on having a Plated instance for Value. Looks like I'll just have to do it the old fashioned way with primitive recursion.
14:07:54 <iqubic> no upon.
14:07:55 <phadej> shachaf: no, we don't have Data stuff, iirc
14:08:06 <shachaf> upon is ridiculous, it's reasonable not to have it.
14:08:12 <shachaf> What a good ridiculous function, though.
14:08:19 <shachaf> > set (upon (!! 2)) 'x' "abcde"
14:08:21 <lambdabot>  "abxde"
14:08:45 <monochrom> To a large extent, the epic type synonyms of lens are ridiculous but good, too.
14:08:52 <iqubic> sumJSON :: Value -> Scientific
14:08:57 <iqubic> sumJSON = sumOf (deep _Number)
14:09:09 <dminuoso_> monochrom: They are, sadly, just type *synonyms* though.
14:09:24 <iqubic> Looks like I'll have to find a different way to sum every single number in my JSON.
14:09:27 <monochrom> gives me the impression that lens is "what a good ridiculous library" :)
14:09:42 <shachaf> monochrom: Man, does anyone really know what all those type synonyms are?
14:09:53 <monochrom> I think the author does...
14:09:56 <iqubic> edward kmett does.
14:10:01 <shachaf> I invented profunctor optics and I don't know what they are.
14:10:03 <iqubic> But I doubt anyone else does.
14:10:08 <monochrom> Ah OK!
14:10:22 <shachaf> But admittedly I wasn't the one who added them to the library.
14:10:25 <monochrom> "What have you done?!"
14:10:50 <maerwald> isn't that generally the description of CT heavy work? "What are we doing?"
14:11:08 <dminuoso_> iqubic: Well you could just be less lazy and traverse your JSON a bit more explicitly
14:11:09 <iqubic> So, time to sum all the numerical values in this JSON object with primitive recursion
14:13:08 <zeta_0> ok, these fold functions are making much more sense, i just needed to figure out where to substitute the arguments and also to keep track of the accumulator for each cycle through the traversal of the list
14:13:43 <phadej> I have recursion-schemes instances in https://hackage.haskell.org/package/aeson-extra-0.4.1.3/docs/Data-Aeson-Extra-Recursive.html :P
14:13:47 <phadej> for Value
14:13:52 <iqubic> Interesting.
14:13:58 <phadej> so you can `cata` Value ;)
14:14:06 <phadej> not that you should
14:14:15 <iqubic> Why shouldn't you do that?
14:14:47 <phadej> I find it slightly silly (at least if you don't yet use recursion-schemes)
14:15:06 <iqubic> I know recursion-schemes
14:15:29 <iqubic> And stripNulls is basically exactly what I want here.
14:17:20 <iqubic> phadej: Why does the example stripNulls use (embed . f) instead of just f?
14:18:23 <phadej> well, it probably should use hoist f
14:18:36 <phadej> but hoist is younger than aeson-extra
14:18:45 <iqubic> Why? Why does it need that?
14:18:53 <phadej> this hoist https://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/Data-Functor-Foldable.html#v:hoist
14:19:10 <iqubic> I know which hoist you were refering to. Why is that needed?
14:19:43 <phadej> see the type of f, it's ValueF Value -> ValueF Value
14:20:01 <iqubic> Oh, right. I see.
14:20:04 <phadej> and it's ValueF .. -> ValueF ... so I don't need to match on other constructors
14:20:41 <iqubic> Right.
14:37:13 <narr> Exit
14:43:51 <iqubic> I just realized that I need a paramorphism here.
14:45:05 <hololeap> preproisotonicshmomomorphism
14:45:34 <jackdk> Supercalifragilisticexpialimorphism
14:46:02 <iqubic> phadej: How does a paramorphism work on JSON objects?
14:46:16 <shachaf> "paramorphism" is not a useful concept. It's using long words gratuitously.
14:46:35 <iqubic> It's the concept I need here.
14:46:38 <zeta_0> i heard that haskell is going to undergo some big changes this year, is this true?
14:46:43 <shachaf> If you have to write a program, and you say "it's a paramorphism", you stll have to write your program just as much as before.
14:46:54 <iqubic> I know.
14:46:55 <shachaf> But now people need to know long words to understand it.
14:47:05 <glguy> zeta_0: It's hard to know what you heard
14:47:33 <iqubic> zeta_0: Did you hear about Dependent Types? I've given up on waiting for those to hit haskell/ghc proper.
14:48:01 <monochrom> No big change.
14:48:13 <zeta_0> well haskell 2010 was the last big change, and i heard that for 2020 there was going to be another big change to the language?
14:48:34 <iqubic> Yeah, that's not ture.
14:48:40 <monochrom> But we can all play with "big" being purely subjective and undefined.
14:48:49 <dmwit> Why are paramorphisms especially hard for JSON objects?
14:48:54 <iqubic> http://reasonablypolymorphic.com/blog/haskell202x/
14:49:05 <monochrom> But Haskell 2010 was not a big change.
14:49:17 <iqubic> dmwit: They shouldn't be. I just can't seem to figure out what the type of the algebra is supposed to be.
14:49:57 <zeta_0> well, i was just curious
14:50:06 <shachaf> Much more interesting: Paramourphisms.
14:50:26 <dmwit> But why is it hard to figure out what the type of the algebra is supposed to be?
14:50:28 <iqubic> alg :: ValueF (Value, Scientific) -> Scientific
14:50:38 <iqubic> It wasn't. I am just a bit tired.
14:52:41 <iqubic> alg (ObjectF (x, ns)) = 0
14:53:06 <iqubic> What's going on here? http://dpaste.com/3QZ71DG
14:53:44 <shachaf> It's an error message. GHC is telling you that your code doesn't type-check.
14:53:53 <monochrom> :)
14:53:55 <iqubic> I'm using this module: https://hackage.haskell.org/package/aeson-extra-0.4.1.3/docs/Data-Aeson-Extra-Recursive.html
14:54:09 <iqubic> Alright... Why doesn't it type-check?
14:54:12 <glguy> iqubic: The lines of the message you pasted explain what went wrong
14:55:02 <shachaf> I think the main reason is that the expected type is "ObjectF (Value, Scientific)", but the actual type is "(a0, b0)".
14:55:12 <shachaf> That would be my guess.
14:55:48 <iqubic> http://dpaste.com/000H5CR
14:55:50 <shachaf> Also, there's a law that says that if you can't figure these errors out yourself, you're not allowed to use paramorphisms.
14:56:07 <monochrom> \∩/
14:56:23 <iqubic> I'm trying to do AoC 2015, Day 12, with recursion-schemes.
14:57:47 <shachaf> But what do you learn if you just paste error messages and program fragments into IRC?
14:57:58 <iqubic> Not much.
14:59:25 <monochrom> A lot about nerd nature.
15:00:04 <shachaf> I suggest the following: Axiom of Choice is about figuring things out yourself, not about having other people figure them out for you.
15:00:26 <monochrom> That against all odds that economics would tell you, when nerds are nerd-sniped they go out of their way to provide free service more valuable than their paid jobs.
15:00:38 <glguy> more fun*
15:01:35 <shachaf> You did figure out the solutions for 2019's problems yourself, right? So just treat it like that.
15:02:22 <shachaf> If you do ask questions, just pasting in code fragments is asking other people to do all the work for you. More polite to do all the work for them, and ask the question about just the parts that you don't know.
15:05:41 <iqubic> shachaf: I will do that.
15:09:11 <iqubic> phadej: The stripNulls example can't use hoist, as that doesn't type-check.
15:12:00 <iqubic> Got it.
15:12:20 <iqubic> http://dpaste.com/2WC4XG0
15:20:08 <iqubic> Well, that's a little bit of a shame.
15:21:33 <iqubic> There are lenses for the fields of a V2 from Linear.V2, but I don't think there are equivalents for Optics.
15:23:24 <iqubic> So, instead of (comparing $ view _x) I need something else.
15:26:33 <jle`> if you're talking about the optics library, you can convert a lens optic into an optics-library optic
15:26:57 <jle`> with lensVL
15:27:17 <iqubic> I didn't know that.
15:27:27 <jle`> that's ok
15:27:32 <jle`> that's why we're here :)
15:28:08 <iqubic> This works: http://dpaste.com/12FDQBH
15:28:20 <jle`> alternatively you can just write view yourself on a van laarhoven lens, it's pretty short and concise
15:28:45 <iqubic> Where points :: [V2 a]
15:29:22 <iqubic> I could probaly simplify that more. that's 4 statements in a where block.
15:29:27 <glguy> or: minimumOf (folded . _x) points
15:30:40 <iqubic> glguy: Does that work in the Optics library?
15:30:48 <glguy> no way to know
15:31:40 <iqubic> Nope. Not working.
15:32:17 <glguy> You'll have to adapt it to the optics library
15:33:02 <iqubic> I know.
15:33:46 <jle`> considering optics has both minimumOf and folded, i feel like it should work. something in my bones
15:34:18 <iqubic> (V2 minX _) = minimumOf (folded % lensVL _x) points
15:34:32 <jle`> my bones are always right
15:34:52 <glguy> iqubic: now look at it and figure out what you did wrong
15:35:02 <amalloy> all we need now is a way to ask your bones questions about any computable function
15:35:10 <amalloy> an oracle for those would be very useful
15:35:12 <iqubic> jle`: That doesn't quite work. http://dpaste.com/1AXH6N9
15:35:33 <shachaf> iqubic: Stop pasting type errors into IRC and asking people what they mean.
15:35:44 <iqubic> shachaf: I know what that one means.
15:35:49 <shachaf> You've been in this channel for three years, you should know what "Couldn't match" means by now.
15:35:59 <shachaf> That error doesn't help anyone else because they don't have access to the code.
15:36:12 <shachaf> If someone tries to help you they'll just get frustrated. So don't do it in the first place.
15:36:56 <iqubic> Alright then.
15:37:04 <shachaf> Instead, apply the following strategy: Think about your problem. If that doesn't work, reduce it to a minimal, self-contained example that other people can run, on their own, to encounter the same error.
15:37:11 <shachaf> If that still hasn't solved your problem, then you can post it.
15:50:35 <iqubic> Yeah, I finally figured it out. http://dpaste.com/2HSE4ZF
15:51:05 <iqubic> Feel free to tell me that my code is crap, and can be improved.
15:51:52 <iqubic> http://dpaste.com/32Q06V4 Example usage.
15:53:10 <iqubic> That nested do block kinda annoys me, but I don't know how to get rid of it, so I'm going to let it stay tere.
15:53:25 <iqubic> I don't want or need advice on how to change it.
15:55:53 <`Guest00000> mrm
16:03:50 <inkbottle> How do you deal with the following discrepancy? Everything to String? Everything to Text? Other solution?  `many (Data.Attoparsec.Text.char 'x') <|> Data.Attoparsec.Text.string (Data.Text.pack "hello")
16:03:50 <zeta_0> infixr 1  =<<
16:03:50 <zeta_0> f =<< x  =  x >>= f
16:03:59 <zeta_0> what does infixr 1 mean ?
16:04:20 <jle`> inkbottle: it depends on what you want to do with the result, or how you want to look at it
16:04:32 <jle`> inkbottle: parsing as a String vs. parsing as a Text can be different things
16:04:34 <ChaiTRex> zeta_0:  It's an infix operator, it's right associative, its operator precedence is 1.
16:04:36 <inkbottle> jle`: okay
16:04:41 <jle`> inkbottle: sort of like the same question of Int vs. Double
16:04:52 <jle`> inkbottle: 'everything to Int or everything to Double' depends on what you actually want to do with the number
16:06:03 <jle`> inkbottle: for example if you are parsing a Text field of some record, you probably want to parse it as Text
16:06:04 <zeta_0> ChaiTRex: thanks
16:06:11 <inkbottle> jle`: there is quite an overhead in trans-typing everything; maybe I should use another parser library? Megaparsec says it can use type string...
16:06:52 <jle`> inkbottle: you can wrap things up for convenience, but you aren't going to get around the fact that text and string are fundamentally different things
16:06:55 <inkbottle> jle`: I'm attempting to make replacements on a small source code file
16:07:05 <jle`> inkbottle: for example if i hae a data type `data Person = P { pName :: Text, pAge :: Int }`
16:07:08 <jle`> pName is Text
16:07:14 <jle`> if i use many, it's necessarily going to give me [a], or String
16:07:28 <jle`> since 'many' fundamentally is a list-of-items parser
16:07:28 <inkbottle> and I use a lot of many
16:07:47 <jle`> if i use many, there isn't any way to get around having to pack to use it with pName :: Text
16:07:56 <jle`> since pName is Text
16:08:06 <jle`> using a library that uses string underneath doesn't change the fact that you need a Text in the end
16:08:34 <jle`> similar for Int vs. Double, if i have a Double parser, i'm still going to have to round to get pAge :: Int
16:08:49 <jle`> i can't just use an Int parser to parse a string Double, since double's are parsed differntly
16:08:52 <inkbottle> sure, but that only in the case where I do need somt Text at some point; I don't think I do
16:09:04 <jle`> inkbottle: yes, that's what i am saying. everything depends on what you need in the end
16:09:14 <jle`> right now we don't have any idea what you need in the end, or at some point
16:09:24 <jle`> so there is no information to advise
16:09:25 <inkbottle> So I was thinking about shifting to megarparsec
16:09:36 <jle`> shifting to megaparsec may or may not help, since it depends on what you need in the end
16:10:05 <jle`> it's sort of orthogonal/unrelated to the problem
16:10:11 <inkbottle> I'll give it a try and see what seems best; thanks
16:10:45 <inkbottle> only because they say in the doc that they can do everyuthing with strings
16:11:35 <jle`> note that instead of using attoparsec's string and pack, you can use something like `traverse single "hello"` maybe
16:12:28 <jle`> or define a helper function if you find yourself doing it often
16:32:47 <dsal> inkbottle: I like megaparsec for text things.  I like attoparsec for blobby things.
16:35:32 <inkbottle> dsal: I'm trying to make small changes on some small source code examples, so megaparsec seems a better choice
16:45:46 <dsal> megaparsec is clearly a better choice when you need stuff like expressions and associativity and precedence and stuff.  It's also got some nice looking errors.  Attoparsec has a few conveniences that are a little harder to find equivalences of in megaparsec.  Primarily that attoparsec is a little more self-contained.  Overall, for "small examples" I don't know that there's a big difference.
16:45:51 <fresheyeball> I am learning about lens
16:46:04 <fresheyeball> and want to see if anyone out there has some slick rewrite rules in their head for this
16:46:30 <fresheyeball> foo fe = flip (set sort) fe <$> simple (fe ^. table) (fe ^. sort)
16:46:58 <fresheyeball> is there a more lensy way I can do that?
16:47:31 <dsal> What are the types?  I see you're flipping some sort of table.
16:47:50 <fresheyeball> sort and table are both lenses
16:48:08 <fresheyeball> fe is a record with these as fields
16:48:17 <fresheyeball> simple is a monadic function
16:49:07 <fresheyeball> basically I have a record and a monadic function
16:49:13 <fresheyeball> I need to pass that function values from the record
16:49:17 <dmj`> > flip execState [2,1] $ do id %= sort
16:49:19 <fresheyeball> and then update the record with the result
16:49:21 <lambdabot>  [1,2]
16:49:28 <fresheyeball> inside the monad
16:55:19 <dsal> TIL:  Building with optimizations makes programs run faster.
16:56:40 * MarcelineVQ writes that down
16:56:52 <Axman6> good tip, thanks
16:59:05 <dmj`> compiling w/ optimizations takes so long
16:59:18 <dmj`> the years of my life wasted because of that
16:59:26 <dmj`> will never get that time back
16:59:49 <dsal> Compiling haskell in general takes long enough that I don't really care about the difference between opt and no opt most of the time.
16:59:56 * nshepperd used trifecta for the first time for a few Advent of Code problems this year. the parse errors seem nice
17:00:10 <sm[m]> --fast does seem faster..
17:00:29 <dsal> sm[m] wait 'til you see --faster
17:00:32 <Axman6> --fast in stack is without optimisations
17:00:46 <ricky_clarkson> "A lot of people experience a curious phenomenon when they start using Haskell: Once your code compiles it usually works."
17:00:47 <Axman6> it means compile fast, not run fast
17:00:48 <nshepperd> --just-make-things-fast-thanks
17:00:51 <maerwald> dsal: difference of -O2 is significant to -O1 on large codebases
17:00:57 <dsal> build time?
17:00:59 <maerwald> yeah
17:01:05 <dsal> Without optimization shouldn't be --fast, it should be --woo
17:01:05 <ricky_clarkson> That's because they're not willing to recompile so they adjust the requirements to fit whatever they built.
17:01:36 <dsal> maerwald: Our code bases are so big that any build just takes a while.  Massively parallel and other magic, but weird stuff happening.
17:02:02 <dsal> One thing I did notice recently is that my stack build is linking executables in transitive dependencies.  That was unexpected.
17:02:17 <maerwald> that's comforting
17:02:55 <dsal> Is that a cabal thing, or is that a "don't put executables in the same project as your libraries" thing?
17:04:28 <sm[m]> standard cabal thing I think. Building a package means building a package (aside from flags which are not worth it)
17:05:10 <dsal> I guess I should split out some executables, then.
17:06:30 <dmj`> I'd rather just build fast without optimizations and FFI into stuff that needs to be fast
17:06:37 <sm[m]> maybe flags are right for this case. Are you often relinking the deps ?
17:07:18 <dmj`> but usually the reason stuff is slow in Haskell is due to representation, pointer indirections, etc. which you can't really fix by just FFI'ing, unless your data type is mutable as well, and that poses other problems like integration w/ other packages in the ecosystem.
17:08:08 <nshepperd> can't you build modules with different levels of optimization
17:09:35 <dmj`> {-# OPTIONS_GHC -O2 #-}
17:09:37 <dmj`> could work ... maybe
17:13:18 <zeta_0> xs >>= return . f = fmap f xs
17:13:28 <zeta_0> what does this mean? ^
17:13:49 <shachaf> It means the thing on the left side of the = is equal to the thing on the right side.
17:14:00 <dmj`> zeta_0: means that all monads are functors
17:14:31 <zeta_0> so this is the 4th monad law?
17:15:01 <dmj`> I don't think its a monad law
17:15:08 <shachaf> I think it's the 18th monad law or the 25th.
17:15:43 <shachaf> Not everything that is true is a law. This is just a thing that's true as a consequence of laws.
17:15:56 <dmj`> monad laws are just left id, right id and assoc.
17:18:11 <zeta_0> so xs passes it's content to return . f, f does a calculation then outputs its value to return which takes that as input, is this the way the left side works?
17:19:12 <shachaf> Words like those will probably just be confusing if you want to figure these things out.
17:19:21 <shachaf> xs has no "contents".
17:19:35 <zeta_0> so xs is the "contents"?
17:19:48 <shachaf> There is no contents.
17:20:06 <zeta_0> then what is xs?
17:20:53 <shachaf> You tell us, you brought it up.
17:21:13 <zeta_0> nevermind
17:21:53 <jle`> is there a nice article that summarize what positive and negative position means in a concise way? i'm writing something that relies on knowing it, but i don't want to spend time going into the details if i can refer the reader to something that already goes over it
17:22:37 <Axman6> zeta_0: xs has type m a, which means the thing on the right must have type a -> m b, because of the type of (>>=). since return has type b -> m b, then f must have type a -> b
17:28:14 <zeta_0> Axman6: thanks, it's started to make a little bit more sense
17:29:38 <jackdk> I'm going to de-pointfree your example, which might make it a little clearer: xs >>= (x -> return (f x)) = fmap f xs
17:29:47 <jackdk> sorry, forgot the backslash
17:30:47 <jackdk> let's look at the types of the things in play: xs :: Monad m => m a; x :: a; f :: a -> b
17:31:31 <jackdk> so what is says is (left side) if we use bind, and do nothing with x but apply f and return it, that is exactly the same as fmapping f over xs
17:40:26 <dmj`> jle`: I'd be very interested in that as well
17:42:58 <MarcelineVQ> jle`: yes, but idk if I can find it, it exists though!
17:44:45 <zeta_0> jackdk: it makes much more sense now, thanks for the help
17:46:47 <MarcelineVQ> jle`: on an only barely related note https://arxiv.org/pdf/1805.08059.pdf is really neat
17:47:22 <jle`> i ended up using https://www.foldl.io/posts/pos-neg-functions/
17:47:48 <jle`> thank you chris coffey
17:49:33 <MarcelineVQ> jle`: the article says it got its info from thinking with types, if you ask sandy I wonder if he'd let you excerpt from that
17:50:13 <MarcelineVQ> I've not read that section though so this article might cover it just fine
17:50:34 <p0a> Hello in ghci I can use `sort [2,1,3]' but in source code I typically do `import Data.List (sort)'. Why is that?
17:50:55 <jle`> ah i'll consider it :) but this is more of a footnote, so i think linking to an article might be better for space efficiency
17:50:56 <shachaf> Probably because you secretly imported sort.
17:51:04 <p0a> ah yeah you're right sha
17:51:06 <p0a> shachaf: 
17:52:35 <p0a> why is (++) in Data.List when it's available in Prelude though?
17:52:59 <shachaf> Because it appends lists, probably.
17:53:19 <jackdk> prelude reexports the function from Data.List
17:53:57 <p0a> got it, thank you. Is there a flag to get a strict haskell environment?
17:53:58 <dmwit> jle`: I wrote https://stackoverflow.com/a/9243982/791604 as an attempt at an approachable intro to the terms.
17:54:38 <jle`> dmwit: ah, thanks. i think this might have been one of the things i originally read, but i couldn't find it in a search
17:55:02 <shachaf> Does it really come from subtyping?
17:55:02 <Ankhers> Is this an acceptable place to ask about Dhall, or is there a better place?
17:55:46 <dmwit> shachaf: I don't know. It makes for a pretty good story, though, doesn't it?
17:56:22 <shachaf> If only I understood subtyping!
17:56:23 * hackage hoauth2 1.10.2 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.10.2 (HaishengWu)
17:56:46 <shachaf> I understand covariance and contravariance, which in my mind is the same thing.
17:57:16 <dmwit> Ankhers: I think it's probably relatively okay to chat about Dhall in here. But keep in mind that the answer to both of those questions might be "no" and that's not contradictory.
17:57:36 <dmwit> shachaf: They're the same in my mind, too.
17:58:14 <jle`> Ankhers: don't ask to ask, just ask
17:58:33 <jle`> if you are afraid of introducing noise into the chatroom, then asking to ask introduces more noise than just asking
17:58:45 <jle`> so there is literally no benefit in asking first
17:58:55 <dmwit> To be fair to Ankhers, we do sometimes kick people from the channel for being off-topic, and that might be a risk they'd like to avoid.
17:59:14 <dmwit> But I think for boundary stuff like this we'll definitely warn before kicking. =)
18:00:27 <jle`> i feel like a rasonable worst outcome from asking an off-topic question is 'don't ask that, it is off topic', not 'too late. ur banned'
18:01:11 <dmwit> I agree.
18:02:58 <Ankhers> I am looking to create some language bindings to Dhall. I was wondering if there is some kind of intro to language bindings document I may have missed. Something that outlines what the API should look like or something.
18:03:08 <shafox> I need to parse protocol buffer file such as osm pbf file. Is there library that suports latest protocol buffer spec ? 
18:04:09 <dmwit> shafox: I suspect if you've already searched on Hackage you pretty much know the ground truth for that question.
18:05:19 <MarcelineVQ> people often know about things not on hackage, or things more up to date than hackage's :>
18:05:50 <dmwit> I challenge this claim.
18:05:56 <dmwit> Or maybe we disagree on what "often" means.
18:06:21 <dmwit> But I don't want to do the legwork to really decide this one way or another and I bet you don't either. hm
18:06:24 <MarcelineVQ> hmm, I wonder how to search logs for that
18:06:46 <shafox> dmwit, The most downloaded one is for 2.x however there is 3.x. Hence asked. 
18:07:06 <dmwit> And I claim that this fact you know is pretty much the ground truth.
18:11:14 --- mode: ChanServ set +o glguy
18:11:14 --- mode: glguy set -bbbb *!*@ngn1-ppp1931.fukuoka.sannet.ne.jp *!*@173.44.36.162 *!*@185.204.212.* *!*@45.116.113.113
18:11:14 --- mode: glguy set -bbbb *!*@145.255.164.139 *!*irc4andro@172.56.12.* *!*thorsten@*.hsi5.kabel-badenwuerttemberg.de *!*pop@185.244.215.*
18:11:14 --- mode: glguy set -bbbo *!*Meepsheep@*.trippy.lsdfor.fun *!*u0_a298@115.164.52.* *!*@181.215.238.97 glguy
18:12:32 <dmj`> Ankhers: what would you want the interface to look like (between dhall and another language)
18:19:56 <Ankhers> dmj`: That is the thing. I was just wondering if there was some sort of suggested API that should be followed.
18:21:06 <p0a> QuasiQuotes do not work interactively right?
18:21:24 <dmj`> Ankhers: what you can do is lex and parse the language into an AST, then expose smart constructors in some Monad that can be used to construct fragments, then you can make a QuasiQuoter and embed dhall in haskell. Someone probably did this
18:21:30 <dmj`> @package language-dhall
18:21:30 <lambdabot> http://hackage.haskell.org/package/language-dhall
18:22:22 <Ankhers> In my case, I am looking to make bindings for Erlang.
18:43:55 <glguy> p0a: what do you mean?
18:46:20 <p0a> glguy: in ghci, [shamlet|<b>Hello|] gives me an error 
18:46:33 <p0a> after the language pragma & import 
18:47:07 <glguy> Those work in ghci
18:47:47 <glguy> Make sure you have the language extension turned on in ghci
18:49:06 <pie_[bnc]> do you guys have any recommendations for materials to learn rust from or should i just go with the usual recommendations?
18:49:25 <p0a> glguy: thank you 
18:49:34 <shachaf> You could try learning Rust from #rust instead of #haskell.
18:57:41 <oats> any haskell-focused youtube channels y'all like?
18:58:46 <maerwald> shachaf: the main channel is on the mozilla network, not on freenode
18:59:08 <glguy> maerwald: pie_[bnc] was asking about Rust
18:59:13 <maerwald> yes
18:59:17 <glguy> not shachaf
19:03:04 <pie_[bnc]> well, I was asking here because I was wondering about haskell people's perspectives
19:03:28 <oats> pie_[bnc]: well, this should probably be asked in a rust-focused channel :)
19:03:31 <oats> but anyways
19:03:40 <oats> you can't beat The Rust Programming Language book
19:03:46 <Axman6> the rust book is quite good from what I've seen of it
19:03:47 <oats> it's quite good
19:06:29 <pie_[bnc]> current plan is to look at that and Programming Rust by Blandy
19:09:54 <ysangkok> oats: i don't know of any youtube channels, but there are a couple of haskell twitch channels now, ocharles has one, kmett has one, gabriel gonzales has one. and puffnfresh, i think
19:10:45 <oats> sweet, thanks :)
19:12:37 <ysangkok> gonzales seems to be streaming from his employer's name: AwakeSecurity
19:13:15 <ysangkok> actually there was a stream just two hours ago: https://www.twitch.tv/videos/533077050
19:48:43 <alc`> Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.
19:48:50 <alc`> "This is a test!", 1 -> "hsi  etTi sats!"
19:49:00 <alc`> I don't understand what this mean
19:50:51 <suzu> 'hsi  et' is every 2nd character
19:51:05 <dsal> alc`: let (odds, evens) = yourSplitFunc in evens <> odds
19:51:08 <suzu> 'Ti sats!' are all the other characters
19:51:13 <MarcelineVQ> "abcde" "bdace"   b and d are every second character in the list "abcde"
19:51:17 <suzu> so the result is "hsi  etTi sats!"
19:51:27 <alc`> I see
19:53:05 <alc`> just [1,2,3,4,5,6] to [2,4,6,1,3,5] right?
19:54:20 <MarcelineVQ> yes
19:54:35 <alc`> ok
20:04:32 <alc`> f x = (fmap (x !!) [2,4..(length x)]) (<>) (fmap (x !!) [1,3..(length x)])
20:04:41 <alc`> where is wrong?
20:07:15 <alc`> f x = g [2,4..l] <> g [1,3..l] where g = fmap (x !!); l = length x
20:12:17 <MarcelineVQ> you really don't want to be using !! to access random points in a list, it repeats a lot of work because lists are single linked lists, you have to start at the beginning of the list every time you want to get to a specific index
20:12:57 <MarcelineVQ> you could get an index bound issue with that code as well since indexes start at 0
20:16:09 <oats> pretty sure you could use partition well here
20:16:24 <oats> > partition odd [1..6]
20:16:26 <lambdabot>  ([1,3,5],[2,4,6])
20:16:41 <MarcelineVQ> oats: it's a position based task
20:16:46 <oats> > uncurry (++) $ partition odd [1..6]
20:16:48 <lambdabot>  [1,3,5,2,4,6]
20:16:56 <oats> oh wait
20:16:58 <oats> I misread
20:17:54 <MarcelineVQ> alc`: you code will work if you fix the fact that the index of a list starts at 0 but it'd still be better to avoid !!
20:18:58 <oats> you could zip with indexes first
20:20:18 <oats> > map snd . uncurry (++) . partition (odd . snd) . zip [0..] $ "This is a test!"
20:20:20 <lambdabot>  error:
20:20:20 <lambdabot>      • No instance for (Integral Char) arising from a use of ‘odd’
20:20:20 <lambdabot>      • In the first argument of ‘(.)’, namely ‘odd’
20:20:40 <oats> oops
20:20:45 <oats> > map snd . uncurry (++) . partition (odd . fst) . zip [0..] $ "This is a test!"
20:20:47 <lambdabot>  "hsi  etTi sats!"
20:20:59 <alc`> MarcelineVQ: what's the right way to access a list? without !!
20:21:58 <oats> alc`: it can be useful to "pre-store" the list indices, with a zip
20:22:00 <oats> like abov
20:22:03 <monochrom> Consume the list from left to right?
20:22:08 <alc`> oats: ok
20:22:10 <oats> > zip [0..] "testing"
20:22:12 <lambdabot>  [(0,'t'),(1,'e'),(2,'s'),(3,'t'),(4,'i'),(5,'n'),(6,'g')]
20:22:24 <oats> then looking at each element, you have the index and the element
20:22:33 <suzu> yeah consume them left to right. if you need a lot of random access then use a different structure like an array or vector
20:23:13 <monochrom> There are also a lot of list functions in the library and you try to just combine them.
20:23:33 <monochrom> (They also consume or transduce lists from left to right.)
20:37:18 <iqubic`> Hello
20:37:54 <alc`> oats: what's the simple way turn [1,2,3,4] to [[1,2],[3,4]]?
20:38:14 <oats> Based on what criteria?
20:38:32 <oats> Split in half? Groups of 2s?
20:38:35 <alc`> combine two near elements to a list
20:38:48 <alc`> based on index
20:38:55 <alc`> (0,1) (2,3) ...
20:38:56 <jle`> what would it do to [1,2,3,4,5,6] ?
20:39:08 <alc`> [[1,2],[3,4],[5,6]]
20:39:13 <dsal> > chunksOf 2 [1..6]
20:39:16 <lambdabot>  [[1,2],[3,4],[5,6]]
20:39:30 <alc`> is that `groupBy` can do?
20:39:43 <jle`> if you use groupBy you have to generate the indices
20:39:51 <jle`> so it's more complicated
20:39:53 <dsal> :t groupBy
20:39:54 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
20:39:56 <jle`> chunksOf is the simple way
20:40:07 <jle`> groupBy is the complicated way
20:40:50 <oats> :t chunksOf
20:40:52 <lambdabot> Int -> [e] -> [[e]]
20:40:53 <alc`> > (foldl1 (<>) . transpose . chunksOf 2) [1..6]
20:40:55 <lambdabot>  [1,3,5,2,4,6]
20:41:10 <dmwit> > map (map snd) . groupBy ((==) `on` fst) . zip (cycle "aabb") $ [1..6]
20:41:13 <lambdabot>  [[1,2],[3,4],[5,6]]
20:41:15 * jle` . o O ( foldl1 (<>) == mconcat )
20:41:29 <oats> Ahh just use chunksOf lol
20:41:56 <dmwit> oh ho ho
20:42:00 <dmwit> I have a cunning plan.
20:42:03 <oats> > chunksOf 2 [1..10]
20:42:06 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
20:42:09 <oats> Easy-peasy
20:42:25 <jle`> > (map . map) snd . groupBy ((==) `on` ((`div` 2) . fst)) . zip [0..] $ [1..6]
20:42:29 <lambdabot>  [[1,2],[3,4],[5,6]]
20:42:33 <jackdk> % :i chunksOf
20:42:33 <yahb> jackdk: chunksOf :: Int -> [e] -> [[e]] -- Defined in `Data.List.Split.Internals'
20:42:49 <jle`> > (map . map) snd . groupBy ((==) `on` ((`div` 3) . fst)) . zip [0..] $ [1..6]
20:42:51 <dmwit> > map (map snd) . groupBy (==) . zip (cycle [False, False, True, True]) $ [1..6]
20:42:51 <lambdabot>  [[1,2,3],[4,5,6]]
20:42:54 <lambdabot>  [[1],[2],[3],[4],[5],[6]]
20:43:03 <jle`> hm
20:43:06 <jle`> zipWith Arg
20:43:15 <dmwit> oh, never mind
20:43:18 <glguy> > replicate 3 =<< [0..]
20:43:20 <lambdabot>  [0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,...
20:43:21 <alc`> > (:[]) <$> [1..6]
20:43:23 <glguy> could be useful ^
20:43:23 <lambdabot>  [[1],[2],[3],[4],[5],[6]]
20:43:26 <dmwit> Cunning plan aborted. I like my previous one better.
20:44:12 <jle`> > group . zipWith Arg (cycle "aabb") $ [1..6]
20:44:13 <alc`> > [0..] >>= replicate 3
20:44:14 <glguy> > takeWhile (not.null) . map (take 2) . iterate (drop 2) $ [1..6]
20:44:17 <lambdabot>  error:
20:44:17 <lambdabot>      • Data constructor not in scope: Arg :: Char -> Integer -> a
20:44:17 <lambdabot>      • Perhaps you meant ‘Args’ (imported from Lambdabot.Plugin.Haskell.Eval....
20:44:17 <lambdabot>  [0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,...
20:44:18 <lambdabot>  [[1,2],[3,4],[5,6]]
20:44:52 <jle`> @let import Data.Semigroup (Arg(..))
20:44:54 <lambdabot>  Defined.
20:45:01 <oats> We have reached the maximum quota of fun, you must cease
20:45:19 <jle`> > (map . map) (\(Arg _ x) -> x) . group . zipWith Arg (cycle "aabb") $ [1..6]
20:45:22 <lambdabot>  [[1,2],[3,4],[5,6]]
20:46:18 <jle`> > (map . map) (\(Arg _ x) -> x) . group . zipWith Arg ([0..] >>= replicate 3) $ [1..6]
20:46:20 <lambdabot>  [[1,2,3],[4,5,6]]
20:46:44 <oats> % :I Arg
20:46:44 <yahb> oats: unknown command ':I'; use :? for help.
20:46:51 <oats> Stupid phone
20:46:56 <jle`> it tried its best
20:47:01 <oats> % :i Arg
20:47:01 <yahb> oats: ; <interactive>:1:1: error: Not in scope: `Arg'
20:47:05 <alc`> dmwit: can we use >>= turn [1..6] to [1,3,5,2,4,6]?
20:47:46 <dmwit> ?let ensure p x = x <$ guard (p x)
20:47:49 <lambdabot>  Defined.
20:48:01 <dmwit> > unfoldr (traverse (ensure (not . null)) . splitAt 2) [1..6]
20:48:03 <lambdabot>  [[1,2],[3,4]]
20:48:12 <dmwit> awww
20:48:26 <hololeap> % let foo f (x:y:xs) = f x y : foo f (y:xs) ; foo _ _ = []
20:48:26 <yahb> hololeap: 
20:48:54 <dmwit> alc`: Sure, by turning [1..6] into [1,3,5,2,4,6] and then tacking >>= return onto the end.
20:49:11 <hololeap> % foo (flip (-)) [2..10]
20:49:11 <yahb> hololeap: [1,1,1,1,1,1,1,1]
20:49:12 <dmwit> alc`: (In case it wasn't obvious, I think you are asking the wrong question.)
20:49:17 <jle`> > [1,2,3] >>= return
20:49:20 <lambdabot>  [1,2,3]
20:49:29 <hololeap> is there a name for my foo function ^ ?
20:49:39 <alc`> we always use famp for list to do that, I wonder what >>= can do with list
20:50:10 <jle`> @quote aztec
20:50:10 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
20:50:28 <dmwit> > unfoldr (\xs -> let (b,e) = splitAt 2 xs in (b,e) <* guard (not (null b))) [1..6]
20:50:31 <lambdabot>  error:
20:50:31 <lambdabot>      • Couldn't match type ‘(,) [Integer]’ with ‘Maybe’
20:50:31 <lambdabot>        Expected type: Maybe (a, [Integer])
20:50:35 <hololeap> alc`: basically, it creates a new list from each element in the list and then concats them all together
20:50:42 <jle`> > (zip`ap`tail) [2..10]
20:50:45 <lambdabot>  [(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
20:51:07 <hololeap> > [1,2,3,4] >>= (\x -> [x,x])
20:51:08 <dmwit> > unfoldr (\xs -> let (b,e) = splitAt 2 xs in (b,e) <$ guard (not (null b))) [1..6]
20:51:10 <lambdabot>  [1,1,2,2,3,3,4,4]
20:51:11 <lambdabot>  [[1,2],[3,4],[5,6]]
20:51:17 <alc`> what's the right way to avoid `head` `tail` on list in case []
20:51:26 <jle`> pattern match
20:51:32 <jle`> but also you can use drop 1 instead of tail
20:51:37 <jle`> it depends on the context
20:51:56 <hololeap> nobody uses tail >_>
20:52:09 <dmj`> jle`: any luck on the positive / negative position info
20:52:22 <alc`> we do recursive and tail list, but we have to check if it's []
20:52:32 <jle`> alc`: you're not really supposed to use tail
20:52:43 <alc`> jle`: bad scheme habbit
20:52:44 <MarcelineVQ> To not use head and tail in the first place,   f [] = ...; f (x:xs) = ...   x is the head, xs is the tail. [] is the case where there are neither.
20:53:14 <hololeap> there's also Data.List.NonEmpty where you can't have [] in the first place
20:53:18 <jle`> the worst sin in haskell is f xs | xs /= [] = ... tail xs ...
20:53:23 <dmwit> > [1..6] >>= \x -> [2*x - 5*(x`div`4) - 1] -- alc`, how to use (>>=) to turn [1..6] into [1,3,5,2,4,6]
20:53:26 <lambdabot>  [1,3,5,2,4,6]
20:53:40 <MarcelineVQ> dmwit: you are full of beans tonight :>
20:53:49 <dmwit> This is an even worse misinterpretation of the question than the last one. =P
20:54:31 <alc`> but there's not all languages support pattern match, if one day I'd like to turn my haskell code to js or python
20:54:45 <jle`> are you asking about haskell or about other languages?
20:54:54 <dmwit> Yes, I really miss pattern matching in languages that don't have it.
20:55:05 <jle`> i guess i'm asking ... what's your question?
20:55:05 <dmwit> When I can, I avoid those languages. ^_^
20:55:44 <dsal> alc`: when in Rome.
20:56:04 <alc`> jle`: I just say pattern match is not good to convert haskell code to others
20:56:18 <jle`> ah, so not a question
20:56:20 <dsal> Translating code is generally not good.
20:56:21 <jle`> just a statement
20:56:31 <jle`> yeah, you can't really translate haskell code to most other languages
20:56:35 <jle`> especially not the development process
20:56:43 * hololeap glances at ghcjs
20:57:02 <jle`> heh, ghcjs doesn't really generate idiomatic javascript
20:57:08 <alc`> but haskell has some powerful functions, like liftA2
20:57:09 <oats> It's a completely 99,99different model of computation than imperative languages employ
20:57:26 <alc`> I really like to copy liftA2 to other languages
20:57:27 <jle`> hm, why is that a 'but' ?
20:57:36 <dsal> why liftA2 in particular?
20:57:53 <alc`> powerful?
20:58:37 <oats> alc`: abstract ideas like Functor, Applicative, and Monad tend to be quite difficult to implement in languages with weaker type systems
20:59:01 <jle`> dmj`: i ended up using https://www.foldl.io/posts/pos-neg-functions/
20:59:01 <alc`> oats: but we only focus on String and List
20:59:12 <oats> You have to result to things like dark OOP magic
20:59:15 <jle`> who is 'we' here?
20:59:36 <alc`> jle`: Me, I, Myself!
20:59:44 <oats> alc`: well, there's nothing stopping you :)
20:59:45 <jle`> ah. so you mean, liftA2 for lists is powerful
20:59:50 <oats> It just won't be as nice
20:59:52 <alc`> jle`: right
21:00:27 <dsal> Most of the time when I use liftA2, it's not for lists.
21:00:55 <hololeap> you probably wouldn't want to use linked lists much in other languages anyway
21:00:56 <jle`> bartosz milewski has a nice series of posts about using list monad/applicdtive in C
21:01:02 <jle`> https://bartoszmilewski.com/2015/05/11/using-monads-in-c-to-solve-constraints-1-the-list-monad/
21:01:23 * hackage log4hs 0.3.1.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.3.1.0 (gqk007)
21:01:49 <oats> That's because bartosz is a beautiful master of dark magic
21:02:48 <hololeap> i've never even used c++, but template metaprogramming sounds nightmarish
21:03:47 <alc`> I like metaprogramming, but I don't know cpp
21:04:07 <dsal> Not all languages have templates.
21:04:15 <alc`> scheme has macros
21:04:49 <alc`> wait, what about template haskell? 
21:04:58 <hololeap> getting bit by ruby's metaprogramming enough times is why i tried haskell :p
21:05:33 <Axman6> template meta programming is just functional oprogramming with ugly syntax
21:07:26 <hololeap> i looked at template haskell and found it way too arcane. i haven't had a need for it, personally, except from other people's libraries
21:07:42 <dsal> I've used it a few times.  It made my lift slightly better.
21:07:52 <dsal> er, life.  I wasn't lifting.
21:08:06 <dmwit> liftA2 isn't that good. cartesianProduct is better. ;-) http://hackage.haskell.org/package/universe-base-1.1.1/docs/Data-Universe-Helpers.html#v:cartesianProduct
21:08:42 <dmwit> (And is also significantly harder to port to other languages, for multiple reasons.)
21:08:44 <hololeap> it made me wonder how many things you could do with template haskell that can't be done with generics
21:09:08 <jle`> the main thing template haskell can do that generics can't is generate identifiers
21:09:11 <MarcelineVQ> anything that needs IO to compute
21:09:21 <MarcelineVQ> *at compile-time
21:09:29 <jle`> er, from a metaprogramming sperctive at least
21:09:38 <jle`> *perspective
21:09:41 <alc`> I still don't understand how to capture continuation with callCC in general
21:09:50 <hololeap> jle`: identifiers?
21:09:54 <jle`> hololeap: yeah
21:10:06 <hololeap> what does that mean in this context?
21:10:06 <Axman6> can't make new lenses in generics for example
21:10:13 <alc`> that callCC is not fancy, but implement `goto` is really fancy
21:10:17 <jle`> like the classic example with lens, data Person = P { pName :: String }
21:10:31 <jle`> you can't use generics to automatically generate an identifier 'lens'
21:10:38 <jle`> er, an identifier 'name'
21:10:39 <alc`> scheme has a primity implement, but haskell's callCC is more generics
21:10:53 <hololeap> well, granted i haven't ever really used lens either :p
21:11:03 <alc`> it's really magic to me, how haskell to do that 
21:11:09 <jle`> hm, it's not just lens, let's just say you wanted to write a function get the name
21:11:15 <jle`> or edit the name
21:11:17 <dsal> alc`: You don't translate concepts across languages.
21:11:22 <dsal> Most language don't have call/cc
21:11:24 <jle`> like overName :: (String -> String) -> Person -> Person
21:11:36 <jle`> hololeap: you can generate the identifier "overName" with TH
21:11:40 <jle`> but you can't generate that identifier in generics
21:11:47 <alc`> dsal: but callCC has a common definition in languages
21:11:47 <dsal> You can do a lot of different things with call/cc.  Many of them you wouldn't do in haskell with call/cc.
21:11:54 <jle`> the closest things you can do is ask the user to provide the 'overName' as a name, hand-writing it
21:12:09 <jle`> and also OverloadedLabels
21:14:57 <alc`> http://matt.might.net/articles/by-example-continuation-passing-style/
21:15:09 <alc`> call/cc => (lambda (f cc) (f (lambda (x k) (cc x)) cc))
21:15:42 <alc`> https://jsdw.me/posts/haskell-cont-monad/
21:16:22 <alc`> same definition, callCC f = ContT $ \ c -> runContT (f (\ x -> ContT $ \ _ -> c x)) c
21:16:29 <alc`> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Cont.html#callCC
21:17:07 <alc`> goto = C.callCC $ \out -> let fn = out fn in return fn
21:17:37 <alc`> but capture this out's fixed-point, how it can be `goto`
21:17:58 <dsal> Yes.   I was worried that I didn't have goto in most most of my codebases.
21:18:22 <hololeap> i tried looking at template haskell late at night and i think my brain just shut down. i'll take a look at it again someday
21:18:43 <dsal> hololeap: You just work with an AST.  The QQ stuff can help you get there quickly.
21:19:07 <alc`> goto :: callCC ((ContT r m b -> ContT r m b) -> ContT r m (ContT r m b)) -> ContT r m (ContT r m b)
21:19:19 <hololeap> yeah i remember trying to understand what a QuasiQuoter was and feeling lost
21:19:55 <dsal> hololeap: for super basic examples, you think, "I want a way to make things that do this." and it does most of the work. 
21:20:39 <dsal> alc`: Do you have an example of whatever code you were writing that that's worse than?
21:20:41 <hololeap> sounds like telepathy :/
21:21:48 <alc`> dsal: I have codes that abuse about `goto` with continuation in scheme, not in haskell, I don't understand how this goto happend in haskell
21:22:29 <dsal> I've implemented threads and exceptions and generators and stuff using call/cc in scheme, but I wouldn't do any of that in haskell because it doesn't make any sense.
21:22:30 <alc`> what's the meaning here to return it's fixed-point in callCC?
21:22:45 <alc`> what's the magic?
21:23:09 <alc`> dsal: but scheme provide call/cc
21:23:27 <dsal> Yeah, and haskell provides threads, exceptions, infinite lists, pattern matching, etc...  So I use haskell features in haskell.
21:23:53 <alc`> dsal: did you never wonder how to do that in haskell?
21:24:19 <alc`> playing call/cc just for fun
21:25:01 <monochrom> alc`: My http://www.vex.net/~trebla/haskell/cont-monad.xhtml has an explanation.
21:25:23 <monochrom> Just need to read up to and including the "setjmp" section.
21:26:17 <dsal> alc`: you're wondering how you use scheme features in Haskell, but you actively avoid core Haskell language features. That's weird.
21:27:15 <alc`> dsal: no, I jsut wonder in a common way
21:30:37 <dsal> The "you can write fortran in any language" kind of common?
21:33:56 <alc`> dsal: then why "fortran"?
21:34:03 <Axman6> gotos are just functions
21:34:16 <Axman6> particularly in Haskell
21:37:05 <alc`> actually I did a ugly Cont Monad in js https://paste.ubuntu.com/p/XGBqjQd5m8/
21:38:34 <monochrom> OK this is truly alarming.  Go into a haskell channel and code up in every language except haskell.  Like there is a singularity you're trying to run away from.
21:41:26 <Axman6> How is pointer arithmetic formed
22:08:20 <`Guest00000> how to code up?
22:08:54 <jle`> stand upside-down and code down
22:10:15 <dsal> I feel like this is some kind of programmer's tree joke.
22:16:53 * hackage hpqtypes-extras 1.10.1.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.10.1.0 (arybczak)
22:26:48 <iqubic> I've having trouble understanding the binary-search package on hackage.
22:28:11 <iqubic> What are the preconditions the predicate given to the search function in Data.Numeric.Search must satisfy? Clearly it won't work on all predicates. But I'm unsure of which ones it will or won't work on.
22:28:58 <iqubic> erm. Numeric.Search.Integer I mean.
22:28:59 <iqubic> https://hackage.haskell.org/package/binary-search-1.0.0.3/docs/Numeric-Search-Integer.html
22:35:53 * hackage bindings-GLFW 3.3.1.0 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.3.1.0 (Mokosha)
22:37:39 <`Guest00000> are there continuous languages?
22:39:19 <kosmikus> iqubic: the docs say the preodicate must be "upward-closed". so if `p x` is `True`, then for all `y` that are greater than `x`, `p y` should also be `True`.
22:40:07 <iqubic> Thanks.
22:41:31 <`Guest00000> monochrom
23:19:08 <dminuoso_> kosmikus: Hey, I've been wondering. Do you know anything about whether skillscasts from Haskell eXchanges could be obtained from skillsmatter so they can be rehosted on say youtube?
23:23:53 * hackage simplelru 0.1.0.0 -   https://hackage.haskell.org/package/simplelru-0.1.0.0 (Murakami)
