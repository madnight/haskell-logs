00:01:14 <sicklork1n> l
00:01:46 <rsoeldner> yushyin, hm for me it looks like this: https://pastebin.com/v1h5B96X
00:03:52 <yushyin> rsoeldner: you need an explicit cradle config (hie.yaml file)
00:04:45 <hololeap> i'm not sure what to put in the cabal.project file
00:04:53 <yushyin> rsoeldner: https://github.com/mpickering/hie-bios#explicit-configuration
00:06:39 <iqubic> jle`: Specifically 2017 Day 25 is a Moore Machine
00:08:13 <rsoeldner> yushyin, thank but now I face `cannot satisfy -package-id servant-server-0...` as well
00:09:15 <yushyin> rsoeldner: now we are issue buddies, yeah!
00:20:22 <rsoeldner> yushyin, not sure if this is a good thing :P
00:20:38 <yushyin> :)
00:26:47 <rsoeldner> yushyin, https://github.com/digital-asset/ghcide/issues/113
00:34:56 <jle`> iqubic: ah, interesting. what do you gain from using the machines library for it?
00:35:45 <mniip> jle`, hey
00:35:59 <mniip> looks like you've had some experience, what are some good numerics libraries?
00:36:45 <jle`> mniip: like for doing number crunching, you mean?
00:37:07 <jle`> intensive numeric stuff
00:37:13 <mniip> I have mostly implicit methods for ODEs and PDEs
00:37:14 <jle`> or do you mean like for algorithms already written for you
00:37:30 <jle`> ah. for ODEs and PDEs and stuff the best way to go now is probably still hmatrix's ffi bindings
00:37:36 <mniip> which would involve some matrix algebra and minimizations
00:37:54 <jle`> particularly hmatrix-gsl
00:38:23 <dmj`> @package arrayfire
00:38:24 <lambdabot> http://hackage.haskell.org/package/arrayfire
00:38:31 <dmj`> @mniip  ^
00:38:31 <lambdabot> Unknown command, try @list
00:38:46 <jle`> oh nice, that's the hot stuff
00:39:32 <cocreature> rsoeldner: you need to specify the component that you are working on. there is no automatic support for working on multiple components at once but if your flags are compatible, you can rely on the .ghc.environment file that cabal generates to provide your packages and use a direct cradle that will then just have to set include paths, ghc-options and default-extensions
00:39:37 <dmj`> jle` :P
00:40:04 <mniip> hmm thanks
00:40:29 <mniip> I'm wondering if there's a way to make numerics code not look terrifying
00:40:35 <yushyin> cocreature: can you have a look at https://paste.xinu.at/m-Reav/#n-XH4rGR-46
00:40:40 <mniip> with type level and EDSL wizardry
00:41:19 <mniip> of course there's no use in doing that if we can't be performant
00:41:32 <jle`> a little bit of typedness can go a long way there
00:41:50 <jle`> i think
00:41:53 <dmj`> mniip: I think going full type-level is overrated, but arrayfire is def. an EDSL. Plus some stuff is dynamic anyways. arrayfire gives you type application goodness
00:42:05 <jle`> most of it would be static, so no performance costs
00:42:34 <jle`> and there are drawbacks if you get tooooo deep in types
00:42:44 <dmj`> yea, like if you want to determine dimensions dynamically from a file, have fun with existentials ... will be a garbage fire
00:43:37 <jle`> existentials don't have to be super bad in code i think but there isn't a nice way to deal with them interactively
00:43:57 <mniip> eh
00:44:01 <jle`> in normal code you'd write everything 'static' anyway and only have to work with existentials at one point, the file loading, to call the static function
00:44:06 <mniip> existentials are okay
00:44:08 <mniip> yeah exactly
00:44:22 <mniip> all of your code is statically typed
00:44:26 <jle`> so it isn't much of a practical cost in writing the code with it, unless you are dyanmically loading a bunch of files along the way or something, which is weird
00:44:37 <jle`> but there isn't really any nice way to do this with interactive/exploratory coding
00:44:53 <jle`> which is like most of the reason i fire up matlab/octave/R
00:45:21 <jle`> but you can go pretty deep into types to optimize for performance, beyond just statically sized dimensions
00:45:27 <mniip> I mean I have a bunch of friends who do computational physics in python
00:45:30 <jle`> like for example a separate type for diagonal matrices
00:45:33 <mniip> but their code just makes me go blergh
00:45:33 <jle`> or triangular matricies
00:45:42 <dmj`> if your dimensions are unknown, and you wanted to statically define your matrix dimensions, your up a creek w/o a paddle
00:45:51 <rsoeldner> cocreature, specifying the cradle, I receive `cannot statisfy..` https://pastebin.com/UdBhM4Mz
00:46:14 <dmj`> unless you want to use TH
00:46:23 <jle`> dmj`: a lot of code you want to write, your dimensions would be known by like a type variable, which is consistent throughout the whole thing
00:46:44 <dmj`> jle`: as kind Nat ?
00:46:46 <jle`> you only have to deal with the 'unknown' at the point of loading in the file, but then you can just pass it off to your fully statically-typed implementation 
00:46:48 <mniip> yes
00:46:50 <jle`> dmj`: yeah
00:47:33 <dmj`> sure, you can do that. but like if you wanted to do (array :: Matrix 100 100) good luck
00:47:48 <jle`> what's wrong with (array :: Matrix 100 100) ?
00:47:50 <mniip> what do you mean by that
00:48:08 <dmj`> suppose your matrix on disk is of different dimensions
00:48:26 <mniip> there's a distinction
00:48:30 <jle`> but if your algorithm only works on 100x100 matrices ...
00:48:33 <jle`> then what's the point?
00:48:40 <mniip> readMatrix :: ... -> Matrix n k
00:48:42 <mniip> versus
00:48:45 <jle`> er by that i mean, your problem is much bigger
00:48:48 <mniip> readMatrix :: ... -> SomeMatrix
00:49:00 <jle`> if your algorithm only works on 100x100 matrices, and your matrix on disk is 99x101, then you have bigger problems than your types not matching up
00:49:13 <mniip> to go from SomeMatrix to Matrix n k you can use TestEquality
00:49:42 <jle`> but if your algorithm works on all `n x m` matrices, then you can write it polymorphic on those matrices, and then do the dispatch of the right function on disk read
00:50:28 <dmj`> yea testEquality is the closest thing you can do
00:50:34 <jle`> but, i am insiduously ignoring one small fact of statically typed programming ... a lot of numeric algorithms are themselves "dynamically typed" --- they can take a vector of known length and return a vector of unknown length until runtime
00:50:50 <mniip> I mean what is the problem with testEquality
00:50:56 <jle`> dmj`: testEquality isn't too bad because you're already going testEquality anyway, even with dynamically sized
00:51:06 <jle`> if your algorithm is only 100x100, then there isn't any way of getting around the check
00:51:10 <mniip> you're essentially asking, is the matrix I read 100x100?
00:51:19 <dmj`> there's nothing wrong with it, that's exactly what you'd have to do
00:51:20 <mniip> if yes please remember that it is, at type level
00:51:35 <mniip> I don't see it as a problem
00:51:41 <jle`> dmj`: it's what you have to do, but you have to do it in both cases :) the static and the dynamic case
00:51:42 <mniip> rather a very descriptive picture of what's happening
00:51:59 <jle`> so you need to test the size in either case, there isn't an advantage or disadvantage either way
00:52:37 <jle`> a simple example of a 'dynamically typed' algorithm would be a function to get the null space of a matrix
00:52:46 <jle`> and this is what makes my rosy picture more of an ideal
00:52:55 <dmj`> in the dynamic case yea, you can read it as Array a, but then you'd have to cast to Array Double sure
00:53:33 <jle`> getting the null space is essentially dynamic, it's a Matrix m n -> (exists k. Matrix n k)
00:53:55 <jle`> so it isn't quite true that you can avoid all dynamic sizes during a typical numeric algorithm
00:55:09 <jle`> in that case existentials can get a bit painful in haskell
00:56:04 <jle`> dmj`: ah, the situation we were talking about is if your algorithm only works on 100x100 matrices, which is what `array :: Matrix 100 100` seems to imply.  in that case, in the dynamic situation, you have to read your matrix dynamically, and then check to verify that it it is 100x100
00:56:17 <jle`> dmj`: if you write an algorithm that works for all n x m matrices, then you don't need to check the size in either case
00:56:20 <jle`> the dynamic or the static case
00:56:22 <mniip> because the null space isn't a matrix
00:56:27 <mniip> it's a list of vectors
00:56:57 <jle`> mniip: ah, that's fair, you could write Matrix m n -> [Vector n]
00:57:11 <mniip> yeah I would consider that better library design
00:57:11 <dmj`> yea, it's just additional runtime checking needed in the testEquality, that example should be more like `array :: Matrix Double 100 100`
00:57:24 <mniip> with a function [a] -> exists n. Vector n a  of course
00:57:37 <jle`> mniip: but, it becomes convenient to treat it as a matrix
00:57:42 <jle`> mniip: because there are a lot of useful matrix operations on it
00:57:50 <jle`> er, a lot of useful operations you have if you treat it as a matrix
00:57:59 <jle`> and at that point you can't get around an existential matrix in the middle of your logic
00:58:01 <dmj`> I chose not to add static dimensions, not that they couldn't be added later
00:58:09 <jle`> dmj`: there's no additional checking in either way, right?
00:58:15 <mniip> fair
00:58:35 <jle`> dmj`: if you don't check int he dynamic situation, you don't check in the typed one.  if you check in the dynamic situation, you check in the typed one
00:59:43 <jle`> but yeah, my statement that 'you push all your existentials to the loading point only, and treat the rest of your program as static' is overly simplistic
00:59:48 <dansho> jle`, do you know of any GAN examples using backprop?
00:59:49 <jle`> for many numerical algorithms
00:59:51 <dmj`> jle`: well, you should :) o/w `array :: Matrix 100 100` might give something different for `dimX array` other than 100
01:00:08 <jle`> dmj`: that's true for both dynamic and static though, right?
01:00:16 <jle`> if your dynamic algorithm expects a 100x100 matrix, you have to check
01:00:48 <jle`> dansho: i'm not aware of any, sorry! i've actually tried to run some implementations but i stopped at trying to find a good test set, and i'm also currently doing some major revisions to backprop
01:01:26 <dmj`> jle`: right, for static the check should occur in the testEquality, and assumed in the function. In dynamic you can have a quick check and return if dimensions are wrong
01:01:33 <dansho> ok thanks! i might try something to do with audio
01:01:58 <jle`> dmj`: yeah, i think we are in agreement here? you have to check in both situations, so there is no difference in static vs dynamic
01:02:52 <jle`> but i think the more interesting things you can do with 'well-typed' numerics aren't the static size checks
01:03:12 <jle`> things like ... a diagonal type, triangular type, symmetric type
01:03:17 <jle`> maybe even a full-rank matrix type
01:03:30 <jle`> if you had a full-rank matrix type then your linear solves would be total
01:03:45 <jle`> and your determinant function could return a positive number type
01:03:48 <dmj`> jle`: well, it depends on the function that operates on the array, is it of type `f :: Matrix 100 100 -> Matrix 100 100` or just `f :: KnownNat x => Matrix x x -> Matrix x x`
01:03:50 <jle`> er wait that's not what it is
01:04:02 <dmj`> jle`: if the later, no checks are needed at all
01:04:09 <dmj`> depends on your algorithm I guess
01:04:13 <jle`> yeah, exactly
01:04:24 <jle`> the dynamic case would be "does your algorithm care about the size, or does it not"
01:04:29 <jle`> the dynamic parallel
01:04:35 <jle`> so it's the same static vs dynamic
01:04:58 <jle`> either (1) your algorithm needs a specific size, so you have to check, or (2) your algorithm doesn't, so you do'nt need a check
01:05:13 <dmj`> jle`: in the latter case, you'd still have to do testEquality if static (1 check), but in the dynamic you'd need no checks.
01:05:27 <jle`> what testEquality would you need to do in the latter case?
01:05:41 <jle`> ah, that your matrix is square?
01:05:43 <dmj`> jle`: when you initially read the array
01:05:53 <jle`> but you need to check for squareness in the dynamic case too
01:05:56 <jle`> dmj`: what are you checking for?
01:06:38 <dmj`> jle`: you'd have a `readArray :: FilePath -> Matrix 100 100` before you call `squareBoy :: KnownNat x => Matrix x x -> Matrix x x`
01:07:02 <dmj`> and `readArray` would need probably need a `testEquality`. So you front load the check
01:07:19 <jle`> you do'nt need to check for 100x100 right?
01:07:28 <jle`> you'd do readArray :: FilePath -> (exists x. Matrix x x)
01:07:42 <jle`> and then call f :: Matrix x x -> ...
01:08:33 <jle`> so you do'nt have to check if the size is 100 since you are able to handle square matrices of any size
01:08:33 <dmj`> you could keep it unknown sure, but if you want to get statically known dimensions you'll have to do an additional check on `100x100` at some point
01:08:52 <dmj`> be at it invocation or matrix constuction
01:09:03 <jle`> 'statically known' here means having the type variables be consistent and stuff
01:09:04 <dmj`> or just unsafeCoerce all the things like I do ;)
01:09:12 <jle`> it doesn't mean checking for 100x100
01:09:31 <mniip> that reminds me
01:09:33 <mniip> http://hackage.haskell.org/package/singleton-typelits-0.1.0.0/docs/GHC-TypeLits-Induction.html
01:09:35 <dmj`> jle`: statically known means , statically known dimensions here
01:09:50 <dmj`> jle`: so maybe we're discussing different things
01:09:53 <jle`> dmj`: yeah, but you don't need statically known actual dimensions to write statically typed programs
01:10:10 <jle`> like mul :: Mat n m -> Vec m -> Vec n
01:10:28 <jle`> dmj`: yeah, i'm imagining the situation where your algorithm is `myAlgo :: Matrix n m -> ...`
01:10:42 <jle`> that's the algorithm with static types, written to work for all n and m
01:11:14 <cocreature> rsoeldner: if you run "ghcide" in a terminal it will just try to load all haskell files. in this particular case it probably ends up picking up files from your executable whereas you are using the library cradle
01:11:24 <jle`> like let's say your algorithm uses a matrix to compute a vector with the same rows, `myAlgo :: Matrix n m -> Vector n`, 
01:11:40 <jle`> you don't ever need any sort of testEquality checks to write that algorithm, or ever throughout your entire program
01:12:00 <jle`> since it doesn't depend on what n and m are, it's polymorphic for all of them, so no need to check against some desired n and m
01:12:11 <dmj`> jle`: that's correct
01:12:22 <dmj`> but Matrix 100 100 is more specific than Matrix n m
01:12:32 <rsoeldner> cocreature, could you elaborate on the .ghc.env* setup ? I created it using `--write-ghc-environment-file=always` and specified a cradle. 
01:12:46 <jle`> dmj`: yeah. so if your function is myAlgo :: Matrix 100 100 -> Vector 3, for instance, then you do have to do checks
01:12:55 <cocreature> rsoeldner: you need to specify a direct cradle and set the GHC flags in there
01:12:55 <jle`> dmj`: but if that's your algorithm, you need to do checks in the dynamic situation as well
01:12:57 <dmj`> jle`: yea, that's what I'm saying
01:13:04 <jle`> dmj`: so you need the same number of checks in both situations
01:13:18 <rsoeldner> cocreature, ah just got it. It still complains when integrating `servant-server` due to missing dependency of `wai-app-static`. But the rest is working now
01:13:23 <jle`> in the dynamic situation, you have to read the file in and check if it's 100x100
01:13:24 <rsoeldner> cocreature, thank you
01:13:34 <jle`> in the static situation, you have to read the file in and check if it's 100x100
01:13:49 <jle`> so neither situation saves or costs any checks
01:14:07 <dmj`> jle`: it depends on what you're doing, suppose the algo doesn't need to know the dimensions 
01:14:12 <cocreature> rsoeldner: but `cabal build` works? that seems odd
01:14:19 <dmj`> yet you still have it as type Matrix 100 100
01:14:23 <dmj`> then you'd have done a check
01:14:31 <rsoeldner> cocreature, I use `cabal v2-build` but yes
01:14:48 <jle`> dmj`: if your algo doesn't need to know the dimensions, then why would you have it take Matrix 100 100?
01:14:53 <jle`> dmj`: that's basically programmer error at that point, heh
01:15:38 <jle`> dmj`: it's equivalent in both situations, still, though.  if it's the situation that (1) your algorithm works on any size, and (2) you reject any matrix besides 100x100, then the analogous case in the dynamic case would still have the same number of checks
01:15:40 <dmj`> jle`: suppose it had to be, to meet some requirement. 
01:15:45 <cocreature> rsoeldner: if you put the flags from your direct cradle into .ghci and run ghci does that work? this sounds like your  package config is messed up somehow
01:15:54 <jle`> dmj`: so, the algorithm is only "allowed" to be run on 100x100 matrices?
01:16:02 <jle`> dmj`: in that case that requirement would also happen in the dynamic situation
01:16:13 <jle`> dmj`: if it's required to only accept 100x100, then the dynamic situation would also need that 100x100 check
01:16:51 <dmj`> jle`: no, the algorithm is defined as `f :: Matrix n m -> Matrix n m`, yet you read the array as `Matrix 100 100`
01:17:17 <dmj`> assuming `KnownNat n, m`
01:17:24 <jle`> ah, but why would you do that?
01:17:36 <dmj`> that's for the user to explain
01:17:48 <jle`> that sounds like the user explicitly wants an extra check on 100x100
01:17:57 <jle`> the user cares enough about 100x100 to enforce that you read in a Matrix 100 100
01:17:59 <dmj`> sure, and that's fair 
01:18:03 <jle`> yeah, that's fair
01:18:06 <dmj`> maybe they do
01:18:07 <jle`> but that's also true in the dynamci case as well
01:18:11 <dmj`> users are crazy
01:18:18 <jle`> in the dynamic case, they care that it's 100x100, so they would check after a dynamic read as well
01:18:18 <dmj`> well no
01:18:43 <jle`> we have a user who cares enough to make sure the array is 100x100
01:18:51 <jle`> so that user would do the same check in both dynamic and static situations
01:19:03 <jle`> and in both cases it's fair
01:19:25 <dmj`> you'd do a check, but it wouldn't be as strong a guarantee throughout your program, it would require lots of manual checks thorughout the program, hence what ghc's typechecker would have done for you if you had testEquality'd up front in the first place
01:19:32 <rsoeldner> cocreature, Not really familiar with the workflow, but running `ghci` mentioned that it picked up the `.ghc.env...` file and I can import all modules as usual
01:19:50 <jle`> dmj`: yeah, you have to do a check either way
01:19:59 <jle`> that's what i've been trying to say, heh
01:20:09 <jle`> dynamic or static, that user would be doing checks
01:20:18 <jle`> so there is no difference in the situation
01:20:46 <dmj`> only one check for static, many checks per call site where it matters in dynamic
01:21:24 <jle`> ah yeah, indeed in practice the dynamic situation will require more checks throughout the algorithm
01:21:25 <cocreature> rsoeldner: and you are sure that you can import the module that depends on servant-server? (probably in your executable or tests and not your library)
01:21:49 <cocreature> rsoeldner: oh and are you sure that ghcide is compiled against the same version of ghc that cabal is using?
01:21:54 <jle`> dmj`: but i think we are in agreement, though. you can't avoid checking-or-not-checking-at-all between static or dynamic. the same checks will happen, it's just a matter of when and how often they are repeated
01:22:12 <dmj`> jle`: yea, I think we agree :)
01:22:41 <rsoeldner> cocreature, yes, both
01:22:58 <dmj`> hence why I opted for more runtime checks over testEquality checks
01:23:07 <cocreature> rsoeldner: not sure what is going wrong there. maybe open an issue with instructions for how to reproduce this
01:23:19 <dmj`> people who want to call svd don't want to call testEquality
01:23:26 <rsoeldner> cocreature, Thanks
01:23:44 <jle`> they wouldn't need to run it if they don't care about the dimensions, right?
01:23:47 <jle`> static or dynamic
01:24:49 <dmj`> that's true, things like matrix multiplication I can see where we'd want the inner dimensions to align
01:25:08 <jle`> yeah, and that requires a check in both situations as well
01:25:13 <dmj`> but if we don't cast the arrays to specific nats, we can't have static guarantees
01:25:39 <dmj`> matmul :: Matrix a x y -> Matrix a y z
01:25:58 <dmj`> this is where you'd want `Matrix 100 100`
01:26:57 <dmj`> o/w it will throw an error
01:27:02 <mniip> dmj`, bottom line is, the only difference between static and dynamic, is that in the statically typed case, once you do an invariant check (testEquality or other), you can "remember" the validity of the invariant in the types
01:27:02 <dmj`> like hmatrix does
01:27:11 <mniip> it doesn't require you to jump through more hoops otherwise
01:27:56 <mniip> the only case you have to jump through hoops is when you want to defer invariant checking to use site (duck typing)
01:28:06 <mniip> which we're not doing here
01:29:18 <dmj`> sure, safety vs. convenience
01:30:30 <jle`> er hm, what mniip is describing is safety *and* convenience
01:30:45 <mniip> you do lose convenience in that you cannot do duck typing
01:30:51 <mniip> everything else - you don't lose out
01:31:00 <jle`> dmj`: mniip is saying that dynamic: unsafe, inconvenient, static: safe, convenient
01:31:47 <mniip> ok to be fair, there is another bit of inconvenience
01:31:54 <mniip> you have to assure the compiler that the invariants are maintained
01:32:58 <dmj`> checking dimensions manually in the testEquality sounds inconvenient, and it would be something the end user has to do
01:33:29 <dmj`> but we could give the end users a TH splice for this
01:33:40 <jle`> dmj`: if the end user cares about dimensions, then they have to check either way
01:33:50 <jle`> dmj`: if they don't, then they don't have to check either way
01:34:39 <mniip> I don't see the point in the TH splice
01:34:41 <jle`> the checking part won't be the source of inconvenience or convenience. the other parts (like ensuring invariants are maintained, etc.) are what can be inconvenient
01:35:23 <mniip> `if a == b then x else error`  vs  `case testEquality a b of Just Refl -> x; Nothing -> error`
01:35:46 <jle`> there is a lot of potential inconveiences from static vs dynamic here, but checking is one of the few things that's going to be consistent/the same either way
01:35:46 <dmj`> mniip: if you did care about being specific in the dimensions, the types could be generated for you using TH (using file I/O at TH time)
01:36:09 <mniip> ah you mean that
01:36:27 <mniip> you should have specified that you're talking about a data file available at compile time
01:36:33 <mniip> sure you can use TH to extract invariants from it
01:37:19 <dmj`> mniip: well I only recently started talking about that (past minute), previously I was referring to users doing it themselves
01:38:23 * hackage hw-excess 0.2.2.2 - Excess  https://hackage.haskell.org/package/hw-excess-0.2.2.2 (haskellworks)
01:44:49 * dmj` wipes sweat off brow
01:45:33 * jle` pours everyone a glass of lemonade
01:46:27 <mniip> the fizzy kind or the juice kind?
01:47:37 <jle`> i don't have enough funds for fancy fizz
01:47:59 <jle`> :'(
02:06:06 * dmj` drinks lemonade profusely
02:19:51 <Taneb> I don't think it's possible right now but does the idea of newtype GADTs with more than one constructor where the constructors have different types make sense
02:20:17 <Taneb> like "newtype Foo a where Bar :: Int -> Foo Int; Baz :: Char -> Foo Char"
02:20:33 <dminuoso> Taneb: How would that be different from a GADT?
02:20:52 <Taneb> dminuoso: it has the storage and strictness guarantess of a newtype
02:20:56 <dminuoso> Taneb: It'd have to have a different representation to carry the coercion proofs, no?
02:21:09 <Taneb> Would it?
02:21:58 <jle`> Taneb: hm, i don't think it has the same storage
02:22:03 <jle`> consider:
02:22:10 <jle`> showFoo :: Foo a -> String
02:22:17 <jle`> showFoo (Bar _) = "Bar"
02:22:21 <jle`> showFoo (Baz _) = "Baz"
02:22:28 <jle`> you need to carry the constructor bit
02:24:44 <Taneb> Couldn't that compile to two different functions, like showFoo@Int :: Int -> String, showFoo@Char :: Char -> String? Or am I missing something els
02:24:44 <Taneb> e
02:25:25 <jle`> how would you know which function to call?
02:25:33 <dminuoso> Taneb: Well if I hand you something of type `Foo a`, you'd need a way to discriminate on the constructor, no?
02:26:00 <dminuoso> The information is not in the call-site, it's on the value.
02:26:49 <jle`> Taneb: it's not always possible to know at compile-time what 'a' showFoo would be called with
02:27:33 <Taneb> Hmm, OK
02:34:44 <ski> Taneb : i've thought of the idea before. i think it would make sense for a notion where one can't discover the indices by matching on the data constructors, but rather must know them, in order to be able to match
02:35:54 <ski> (so, it's not exactly GADTs. more similar to defining a parameterized type in Agda (perhaps more in Agda1 ?), by pattern-matching on the index)
02:38:09 <ski>   Foo :: Bool -> Type
02:38:13 <ski>   Foo = \(b :: Bool) -> case b of {False -> data {MkInt :: Int -> _ False}; True -> data {MkChar :: Char -> _ Char}}
02:38:30 <mniip> that's called a data family
02:38:41 <mniip> you can `newtype instance` a data family
02:39:24 <ski> hm, but then it would be "backed" by different `newtype's, no ?
02:39:24 <mniip> you could see it as a GADT that doesn't store the coercion proofs inside but rather requires the user to carry them around
02:39:30 <mniip> sure
02:40:03 <mniip> but if you say `newtype instance X Y = D Z`
02:40:09 <mniip> the you have `Coercible Z (X Y)`
02:40:16 * ski thinks this is reminiscent of input vs. output modes of predicate parameters in logic programming
02:40:34 <mniip> this has to do with variance ye
02:41:47 <mniip> the constructor is the same in both: `(a ~ Y) => Z -> X a`
02:42:17 <mniip> the pattern match though, `((a ~ Y) => Z -> r) -> X a -> r` versus `(a ~ Y) => (Z -> r) -> X a -> r`
02:43:06 <ski> yes
02:44:58 <ski> in the former, `X a' is conceptually `(a ~ Y) *> Z', while in the latter, i think it's more like `X a' having `a ~ Y' as presupposition .. hmm
02:45:33 * ski . o O ( `(((a ~ Y) => Z) -> r) -> X a -> r' )
02:45:54 * hackage massiv-test 0.1.2 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.2 (lehins)
02:46:03 <mniip> wll the two aren't inveses of each other
02:46:09 <mniip> because the constructor is unaffected
03:39:03 <ski> different converses, mniip
03:50:15 <Guest_41> Hi guys, wenn i write import Test.QuickCheck then it says could not find module 'Test.QuickCheck'
03:50:23 <Guest_41> When i do cabal update
03:50:52 <Guest_41> then cabal install QuickCheck it says "You asked to install executables, but there are no executables intarget: QuickCheck. Perhaps you want to use --lib to install librariesinstead."
03:51:04 <AWizzArd> I had a pretty concrete type in my server, AppT, over my Context and IO, and ServantErr, etc. Now I switched this out against an abstract monad m, but now I need to specify multiple constraints in my handlers. Is it typical to use an alias via ConstraintKinds? Or is this not a good use case?
03:51:06 <Guest_41> How can i fix this?
03:53:51 <merijn> Guest_41: Sounds like you have "cabal-install" v3.0?
03:54:46 <merijn> AWizzArd: That's what I do now, but I don't think it's ideal
03:57:04 <Guest_41> Yes i have cabal 3.0.0.0
04:07:32 <merijn> Guest_41: Did you try running install with "--lib" as it said? (The global installation workflow isn't very worked out for 3.0 and I haven't used that before, so no clue if that works...)
04:07:59 <maerwald> Guest_41: what are you trying to do?
04:08:10 <maerwald> do you need a repl with quickcheck?
04:09:04 <Guest_41> Just want to check some code
04:09:19 <maerwald> in ghci?
04:13:36 <Guest_41> Yes, just started today with haskell, dont know much about cabal ghci etc.
04:14:17 <maerwald> cabal repl --build-depends QuickCheck
04:19:30 <dmj`> AWizzArd: its typical, but a newtype might not be bad either, then you can deriving via all those constraints
04:19:59 <maerwald> half of the packages here fail to build documentation. Can I tell cabal to still keep trying without failing the entire build and having to disable documentation for 50+ packages manually?
04:21:06 <dmj`> maerwald: might be able to set that in cabal.config
04:21:12 <maerwald> where
04:21:15 <dmj`> see ~/.cabal/config
04:21:20 <maerwald> Yes, I don't see it
04:21:44 <dmj`> for me its there
04:21:49 <dmj`> -- documentation: False
04:21:52 <dmj`> can uncomment this
04:22:02 <maerwald> That wasn't my question. I want to build documentation
04:22:32 <maerwald> If building doc for a package fails, it should just skip it
04:22:55 <maerwald> there's no way for a user to know when a package broke documentation
04:23:09 <maerwald> so building becomes a lottery
04:25:13 <dmj`> maerwald: I only know how to do that with nix
04:26:08 <mniip> is there a function like
04:26:19 <mniip> :t (fmap mconcat .) . forM
04:26:21 <lambdabot> (Monoid b, Monad f) => [a] -> (a -> f b) -> f b
04:26:33 <dmj`> :t foldMap
04:26:35 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:26:44 <dmj`> oh you want foldMapM
04:26:48 <mniip> yeah
04:27:22 <dmj`> @def foldMapM f xs = foldlM (\b a -> mappend b <$> (f a)) mempty xs
04:27:23 <lambdabot>  Defined.
04:27:25 <dmj`> :t foldMapM
04:27:26 <lambdabot> (Foldable t1, Monad m, Monoid b) => (t2 -> m b) -> t1 t2 -> m b
04:27:42 <mniip> except I want flip foldMapM
04:27:45 <dmj`> :t flip foldMapM
04:27:47 <lambdabot> (Foldable t1, Monad m, Monoid b) => t1 t2 -> (t2 -> m b) -> m b
04:28:06 <dmj`> @def foldForM = flip foldMapM
04:28:08 <lambdabot>  Defined.
04:31:24 * hackage vformat-aeson 0.1.0.0 - Use vformat format Aeson  https://hackage.haskell.org/package/vformat-aeson-0.1.0.0 (gqk007)
04:31:46 <Lears> % :t flip $ \f -> getAp . foldMap (Ap . f)
04:31:46 <yahb> Lears: (Foldable t, Applicative f, Monoid a1) => t a2 -> (a2 -> f a1) -> f a1
04:32:42 <Lears> Should be foldMapA. Though before we need a flipped version of that, I don't know why we don't have a good `flip foldMap` first.
04:37:54 <mniip> ooh
04:38:16 <mniip> Ap is the evidence that f is lax monoidal because you can lift monoids through it
04:39:54 * hackage mmsyn7ukr 0.7.2.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.7.2.0 (OleksandrZhabenko)
04:41:23 * hackage titan-debug-yampa 1.0.1 - Testing Infrastructure for Temporal AbstractioNs - Interactive Yampa debugging layer.  https://hackage.haskell.org/package/titan-debug-yampa-1.0.1 (keera_studios_ci)
04:42:23 * hackage titan-record-yampa 1.0.1 - Testing Infrastructure for Temporal AbstractioNs - Yampa record-and-replay layer  https://hackage.haskell.org/package/titan-record-yampa-1.0.1 (keera_studios_ci)
04:56:53 * hackage incremental-parser 0.4 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.4 (MarioBlazevic)
05:09:51 <higherorder> Hello! Given a traversal `Traversal' s a` and `s`, can I get `[a]`?
05:11:25 <boxscape> :t (^..)
05:11:26 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
05:11:32 <boxscape> I think that should do it?
05:11:51 <higherorder> ah great, thanks!
05:30:00 <kuribas> :t toListOf
05:30:01 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
05:40:06 <kuribas> I try to avoid the emoji operators as much as possible.
05:43:06 <sshine> I'm somehow unable to learn them. I think instinctive reluctance is the cause.
05:43:24 <sshine> as in, if I were to write ^.. I might as well be coding Perl. :-P
05:43:56 <kuribas> I find the elaborative versions good enough most of the time.
05:53:09 <dminuoso> Wow interesting.
05:53:26 <dminuoso> % ðŸ¤£ = (^..)
05:53:26 <yahb> dminuoso: ; <interactive>:16:1: error: lexical error at character '\129315'
05:53:30 <dminuoso> What's going on here?
05:53:32 <Philonous> Should enabling "ApplicativeDo" in a source file ever be able to lead to the file being rejected by the type checker when it compiles just fine without it?
05:53:40 <dminuoso> Philonous: Yes.
05:54:06 <kuribas> dminuoso: are you trying to assign to a unicode character?
05:54:08 <dmj`> sshine: you can get a lot of mileage w/ just a few of the operators %~, *~, +~, ^., ^?, over, set, view, preview
05:54:42 <dmj`> > over both (*2) (2,2)
05:54:45 <lambdabot>  (4,4)
05:54:47 <dminuoso> Philonous: Consider a case, where you enable ApplicativeDo, constrain the surrounding type to Applicative, but write the do-block in such a way that it requires Monad.
05:55:02 <dminuoso> kuribas: What's wrong with that?
05:55:14 <kuribas> dminuoso: I don't know :-P
05:55:33 <Philonous> dminuoso, But then it would be rejected without ApplicativeDo as well, woudn't it? 
05:55:37 <Philonous> Wait
05:55:48 <kuribas> dminuoso: I think it depends on the character class
05:56:08 <dminuoso> Philonous: The error might be different though.
05:56:18 <Taneb> dminuoso: I think emoji are operators
05:56:25 <dminuoso> Clearly.
05:56:27 <boxscape> % (ðŸ¤£) = (^..)
05:56:27 <yahb> boxscape: ; <interactive>:17:2: error: lexical error at character '\129315'
05:56:52 <Philonous> dminuoso, OK, but I mean only the case where the file compiles without errors, but adding ApplicativeDo then leads to type errors 
05:56:56 <dminuoso> The interesting part is that its a lexical error, here.
05:57:24 <dminuoso> Philonous: Do you have a concrete example?
05:58:24 <boxscape> % generalCategory 'ðŸ¤£'
05:58:24 <yahb> boxscape: ; <interactive>:18:18: error: lexical error in string/character literal at character '\129315'
05:58:30 <Philonous> dminuoso, It seems to be happening to me, but the code is both convoluted and also property of my customer, so I can't post it online 
05:58:32 <boxscape> % generalCategory '\129315'
05:58:32 <yahb> boxscape: NotAssigned
05:59:01 <dminuoso> Philonous: There is an interesting case where you can implicitly loop GHC
05:59:16 <dminuoso> Philonous: The manual lists this as an example: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#applicative-do-pitfall
05:59:38 <dminuoso> But that would present itself as some internal GHC error. 
06:00:26 <Philonous> Wouldn't that just lead to infinite loops during run time?
06:00:29 <dminuoso> Philonous: The best reason I can think of, is if (<*>) or pure have different meaning in your code.
06:00:40 <dminuoso> Oh. Wait you are right.
06:01:11 <Philonous> Differences between ap and <*> would change the semantics, but it should still type check, shouldn't it? 
06:01:12 <dminuoso> Philonous: Say you have no implicit prelude/custom prelude, in which pure and/or (<*>) have a different type signature. Then enabling ApplicativeDo could provoke type errors.
06:01:24 <dminuoso> Philonous: If I define pure = (+), then no.
06:01:58 <Philonous> Shouldn't that only work with NoImplicitPrelude and possibly RebindableSyntax ?
06:02:44 <dminuoso> RebindableSyntax Im not sure, no idea how that interferes with ApplicativeDo at all
06:02:50 <boxscape> either NoImplicitPrelude or explicitly importing Prelude qualified or hiding pure
06:02:53 <dminuoso> But yeah, those seem like the cases.
06:03:19 <dminuoso> (If you enable RebindableSyntax and ApplicativeDo, you should really think about refactoring your code)
06:04:00 <dminuoso> Philonous: Or.. perhaps you have an old GHC version from before AMP?
06:04:02 <Philonous> I don't have RebindableSyntax, and I want ApplicativeDo for a custom Applicative that does something similar to Haxl
06:04:03 <dminuoso> That could explain it.
06:04:19 <Philonous> Also I use the standard Prelude
06:04:29 <Philonous> I think the problem might be in Esqueleto 
06:04:32 <Philonous> Not sure yet
06:04:53 <dminuoso> (Though, was ApplicativeDo even a think from before AMP?)
06:11:26 <Philonous> Ah, problem seems to be about polymorphic local binds
06:16:07 <day> how does one split a Word64 into 8 Word8? or to simplify it how do i convert the lowest byte of a Word64 into a Word8?
06:16:39 <dminuoso> % :t shift
06:16:39 <yahb> dminuoso: Bits a => a -> Int -> a
06:16:41 <day> my idea was (word64 .&. 0xFF) :: Word8, but thats not doing it
06:17:47 <Philonous> > fromIntegral (0xffffff :: Word64) :: Word8 
06:17:49 <lambdabot>  255
06:18:01 <Philonous> > fromIntegral (0xffff10 :: Word64) :: Word8 
06:18:03 <lambdabot>  16
06:18:39 <day> fromIntegral (0xAABB .&. 0xFF) :: Word8
06:18:48 <day> > fromIntegral (0xAABB .&. 0xFF) :: Word8
06:18:50 <lambdabot>  187
06:18:55 <Philonous> You need the explicit conversion function after your bit twiddling. fromIntegral wil also just truncate the high bits, so you don't need anything more
06:19:01 <dminuoso> day: Dont bitmask. Just fromIntegral
06:19:12 <day> i see
06:19:14 <day> ty
06:19:15 <dminuoso> Though, I'd probably still use a bitmask to make it a bit more explicit.
06:19:24 * hackage system-info 0.5.1 - Get the name of the operating system  https://hackage.haskell.org/package/system-info-0.5.1 (dtaskoff)
06:19:24 <dminuoso> And, if you want all bytes, you could do something like
06:19:42 <Philonous> Yes, the fact that fromIntegral will truncate high bits could be seen as an implementation detail and I wouldn't abuse it
06:22:04 <dminuoso>  let nthByte :: Int -> Word64 -> Word8; nthByte n w = fromIntegral (w `shiftR` (n * 8)); 
06:23:12 <dminuoso> % let nthByte :: Int -> Word64 -> Word8; nthByte n w = fromIntegral (w `shiftR` (n * 8)); 
06:23:12 <yahb> dminuoso: 
06:23:15 <dminuoso> % let w64 = 0x12345678 in flip nthByte w64 <$> [0..7] 
06:23:15 <yahb> dminuoso: [120,86,52,18,0,0,0,0]
06:25:23 * hackage hlibcpuid 0.2.0 - Bindings to https://github.com/anrieff/libcpuid  https://hackage.haskell.org/package/hlibcpuid-0.2.0 (dtaskoff)
06:26:13 <dminuoso> Or, using an explicit bitmask
06:26:37 <dminuoso> % let nthByte :: Int -> Word64 -> Word8; nthByte n w = fromIntegral $ (w `shiftR` (n * 8)) .&. 0xff; 
06:26:37 <yahb> dminuoso: 
06:35:24 * hackage stratosphere 0.48.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.48.0 (jdreaver)
06:38:23 * hackage patat 0.8.4.3 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.8.4.3 (JasperVanDerJeugt)
06:39:06 <kuribas> I was thinking about the "dynamic typing is more organic" argument.  Actually in nature, structure is everywhere.  Trees have a trunk, animals and people have a skeleton.
06:39:19 <kuribas> It's seems that having structure is more "natural" than being structure-less.
06:39:34 <dminuoso> kuribas: Dynamic typing has nothing to do with organic
06:39:48 <kuribas> dminuoso: did you ever hear a talk by Rich Hickey
06:39:49 <kuribas> ?
06:39:53 <dminuoso> It's a misconception that fails to grasp the very core idea of type systems.
06:40:24 <dminuoso> A type system is, fundamentally, about filtering out bad programs.
06:40:50 <dminuoso> But, not everything that filters out a bad program is a type system.
06:40:57 <dminuoso> You wouldn't call your test suite a type system, would you?
06:41:41 <kuribas> dminuoso: well, it serves a similar purpose.
06:41:51 <dminuoso> Sure, I don't disagree here.
06:41:59 <kuribas> dminuoso: but I see types as creating structure which keeps your program together.
06:42:24 <dminuoso> They don't provide any structure. It's a meta language designed to prove things about your program.
06:42:27 <kuribas> not necessary at proving correctness, which is very hard anyway.
06:42:44 <dminuoso> (What they prove depends on the type system, really)
06:42:44 <kuribas> dminuoso: structural things :)
06:42:52 <dminuoso> kuribas: Not necessarily at all.
06:42:58 <dminuoso> Is a phantom type "structural"?
06:43:01 <dminuoso> What does "structural" even mean?
06:43:04 <kuribas> dminuoso: yes it is
06:43:12 <dminuoso> kuribas: It's a really narrow and limited view on type systems.
06:43:13 <kuribas> dminuoso: it describe the structure of your data
06:43:24 <dminuoso> Types describe whatever they want, really.
06:43:28 <kuribas> the possible data it can contain
06:43:41 <dminuoso> Not necessarily.
06:43:46 <Philonous> I sometimes feel like Rich Hickey falls into the "hard to teach a man something when their job depends on them not understanding it" category
06:43:49 <dminuoso> That's just one of many possibilities.
06:44:39 <kuribas> dminuoso: of course you can encode anything, like in idris, or agda, ... but in practice it's most useful for describing structure.
06:44:59 <kuribas> I found proving anything in idris quite painful.
06:45:18 <dminuoso> kuribas: The core idea is not that it describes structure
06:45:35 <dminuoso> But that its a meta language that is talks about your program, not its values.
06:46:07 <kuribas> if I write data MySub = Case1 | Case2 | Case3
06:46:12 <dminuoso> If we talk about `t :: Int` we dont mean "t is numbers", but the program part `t` (whatever that means) has type Int.
06:46:14 <kuribas> that says something about the structure right
06:46:31 <dminuoso> So far there's no types in there.
06:46:51 <kuribas> in where?
06:47:40 <dminuoso> kuribas: If you write something like `f :: Int` then that's not as much saying something about "the value the location f refers to", but it's rather a statement about the *term* f itself.
06:47:48 <dminuoso> Think of types as AST annotations.
06:47:53 <dminuoso> They annotate the *AST* itself.
06:47:55 <dminuoso> Not values.
06:48:02 <dminuoso> It's the core idea of a type system.
06:48:43 <kuribas> dminuoso: but it also says something about the values f can take right?
06:49:02 <dminuoso> kuribas: Sure, there is a relationship to that.
06:49:05 <kuribas> Int represents a set of numbers between minBound and maxBound
06:49:15 <dminuoso> kuribas: What Int really means is irrelevant in the type system
06:49:19 <dminuoso> It's not what we care about
06:49:25 <dminuoso> It's just some name.
06:49:31 <kuribas> dminuoso: at a purely technical level, yes that's right.
06:49:35 <dminuoso> Not at a technical level
06:49:45 <dminuoso> That's what type systems are about.
06:50:24 <dminuoso> kuribas: We just know that its some classification that is related to runtime values for the term (in simple type systems). We dont know anything further than that.
06:51:51 <dminuoso> According to the curry howard isomorphism, we can think of type signatures as propositions and programs as proofs. So a type checker really is an automated theorem prover. If a program type checks, the programs are valid proofs for the propositions
06:52:11 <kuribas> dminuoso: the curry howard isomorphism breaks in haskell
06:52:16 <kuribas> due to bottom
06:52:34 <dminuoso> kuribas: No it does not. It merely means our type system is not sound for reasoning.
06:52:58 <dminuoso> Besides, pretending that bottom doesn't exist is generally a useful thing.
06:53:54 * hackage vformat 0.13.0.0 - A Python str.format() like formatter  https://hackage.haskell.org/package/vformat-0.13.0.0 (gqk007)
06:55:51 <dminuoso> kuribas: You can however constrain yourself and still have a consistent logic in Haskell if you dont use the entirety of the Haskell type system.
06:56:00 <dminuoso> But really, the point isn't that its a consistent logic.
06:56:46 <__monty__> kuribas: This is a good read on why something like ignoring bottom can be useful: https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf
06:57:04 <kuribas> __monty__: yeah, I know that one
07:00:30 <dminuoso> kuribas: The point of a type system is not to figure out "Oh, this thing is going to be an Integer" - because then sure, one could argue that this can be addressed with runtime tagging of things.
07:02:32 <dminuoso> It's about proving the absence of program behaviors by term classification.
07:02:35 <dminuoso> Not value classification.
07:02:50 <__monty__> Equivalently, by *syntactic* means.
07:03:16 <dminuoso> For instance, a type system gives you guarantees about "This program wont segfault"
07:03:33 <kuribas> dminuoso: maybe the point of types is not "to add structure", but they do add structure.
07:03:39 <dminuoso> You can't do this at runtime, because there the best you could do "Up until this point with this program path we don't segfault"
07:03:56 <dminuoso> But that's not a proof of anything.
07:04:02 <dminuoso> Other than "this program path does not segfault"
07:04:09 <__monty__> This view that types just represent sets of allowed values pops up quite often with people who insist "dynamic types" are a type system, or types at all.
07:04:26 <kuribas> __monty__: it is a type system
07:04:43 <__monty__> Not in the type theory sense.
07:04:46 <dminuoso> kuribas: Not to any common definition of type theory.
07:05:05 <dminuoso> kuribas: The most authoritative book on type theory has the following definition:
07:05:19 <__monty__> Maybe we should move to -offtopic? Wouldn't want to derail haskell discussion with yet another "dynamic types are/aren't types" discussion : )
07:05:25 <dminuoso> A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.
07:08:15 <dminuoso> Runtime tagging (which people call dynamic typing) is "just classification of values". They miss the *tractable, *syntactic, *proving absence of certain program behaviors and *classification of phrases parts. Literally *everything* from the definition
07:08:40 <kuribas> perhaps unityped is a better name for dynamic types
07:11:02 <__monty__> Usually, yes.
07:11:15 <boxscape> it's probably still useful to have some sort of distinction between what people call a dynamic type system and an untyped language, both of which would fall under that
07:11:27 <__monty__> But that's just a way of saying the type checker doesn't need to be there because it's trivial.
07:11:54 <__monty__> Just to be clear un*i*typed /
07:12:21 <kuribas> I think the difference is that dynamic typing isn't based on the mathematical type theory.
07:12:36 <dminuoso> kuribas: The problem is that the wording of "dynamic typing" suggests that there is some useful relationship.
07:12:44 <dminuoso> Or that they are comparable or similar.
07:12:46 <dminuoso> They are not.
07:12:58 <__monty__> */= untyped
07:13:06 <dminuoso> At best runtime checking is about producing sensible diagnostics, rather than outright crashing if something goes wrong.
07:13:43 <kuribas> dminuoso: our lisp system has a type system used for checking data that goes in the object database.  It has products and co-products.
07:13:56 <kuribas> dminuoso: also sub-typing.  Sadly it's not sound.
07:14:09 <kuribas> dminuoso: I think it would count (almost) as a type system.
07:14:20 <dminuoso> kuribas: Take a good look at that definition I quoted.
07:14:49 <dminuoso> Type systems really are not about "classifying values according to structure". They are about classifying syntactic phrases.
07:15:12 <kuribas> dminuoso: to be honest, I don't like that definition
07:15:13 <dminuoso> `t :: Int` does not classify the value t points at, it classifies the *variable* itself.
07:15:21 <boxscape> actually, is there even really a practical difference between the terms "untyped" and "unityped"?
07:15:22 <dminuoso> kuribas: Well, it is the textbook definition.
07:15:38 <dminuoso> kuribas: Have you considered that perhaps your "intuitive" and "informal" definition is just bad?
07:15:46 <boxscape> whether you classify all your values to fit into one category or don't bother classifying at all seems like it doesn't matter very much
07:15:51 <kuribas> dminuoso: I didn't give a definition
07:16:23 <kuribas> boxscape: it's the same as void versus unit
07:16:31 <kuribas> boxscape: I think unit is better than void
07:16:41 <dminuoso> kuribas: Then whatever you have in mind is not a type system, but something different.
07:16:52 <boxscape> that's void as in the return type or as in "data Void"?
07:17:01 <kuribas> boxscape: void as in java or C
07:17:05 <boxscape> okay
07:17:07 <dminuoso> Im not arguing that you shouldn't validate your data, Im merely suggesting that the term "type system" means something different than what you think it does.
07:17:26 <kuribas> boxscape: which is IO () in haskell
07:17:30 <boxscape> right
07:19:15 <kuribas> the idea is that you return one (uninteresting) value.  Because not returning anything would imply never returning.
07:19:42 <boxscape> fair
07:19:48 <kuribas> unityping is good if you want to implement such a language in haskell
07:19:55 <dminuoso> Perhaps the word "void" is owed to the fact that the function does indeed not return anything on the stack.
07:19:55 <kuribas> you just make a single sum-type :)
07:20:05 <dminuoso> It's a matter of perspective.
07:20:33 <kuribas> dminuoso: so another example where the terminology is different from mathematical type-theory
07:20:37 <boxscape> dminuoso any idea if there's a better name for "dynamic type systems"?
07:20:58 <kuribas> runtime tagging?
07:21:05 <boxscape> oh yeah I guess so
07:23:38 <kuribas> or you could model it with existentials: data Value = forall t. Tagged t => Value t
07:25:16 <dminuoso> kuribas: Its called Typeable in Haskell.
07:26:11 <kuribas> so that means it's possible to describe such a system with a type system, right?
07:26:46 <boxscape> Isn't this Dynamic rather than Typeable?
07:28:22 <merijn> Dynamic is just "Typeable + an existential"
07:29:05 <dminuoso> kuribas: Well it's not exactly the same. Also, runtime tagging has a broad sense of meaning.
07:29:14 <dminuoso> kuribas: How runtime information is actually used is a different matter.
07:29:48 <dminuoso> GHC Haskell uses a sort of "runtime tagging" as well in various places, such as encoding co-products
07:30:11 <dminuoso> Or maybe the runtime tagging is just some kind of assertion that incorrect programs weren't specified
07:30:59 <dminuoso> Both are forms of runtime tagging, but they they are very different.
07:38:57 <Bish> whats haskellers view on rust?
07:39:23 <merijn> Bish: I like it *conceptually*, but I have very little use for it
07:40:05 <merijn> Bish: i.e. it's a nice alternative for situations where (GHC) Haskell's GC was completely unacceptable, but I rarely write code for which that is a problem
07:40:19 <Bish> what is a situation where ghc is unacceptable?
07:40:32 <dminuoso> Bish: When you cant afford the stop-the-world garbage collection.
07:40:38 <merijn> Bish: Real time software that can't handle garbage collection pauses
07:40:41 <dminuoso> Certain real-time applications where low latency is crucial
07:41:24 <sm[m]> and low memory embedded systems perhaps
07:41:38 <merijn> Bish: So, stuff like hardware control systems, embedded, maybe some forms of real-time audio/video (although a whole bunch of people seem to do audio just fine in haskell!)
07:42:06 <dminuoso> Also, Rust can produce faster programs. So if performance is absolutely crucial then Rust can perform better - though arguably very few people get into this kind of problem
07:42:14 <merijn> Bish: Alternatively, "if it could conceivably be written in Python/JS, then Haskell is fine"
07:42:34 <merijn> dminuoso: Sure, but then you have to consider the trade-off between "FFI to C from Haskell for tiny bit of code" vs "write everything in Rust"
07:42:45 <merijn> Usually the former is easier, imo :p
07:43:02 <Bish> but not every program that is fine in python/js is  not not fine in haskell
07:43:03 <Bish> or is it
07:43:09 <dminuoso> Bish: Why not?
07:43:18 <dminuoso> Bish: What does Python/JS have to offer that Haskell does not?
07:43:23 <merijn> Bish: How so?
07:43:39 <dminuoso> 2 years into Haskell I found the opposite to be true.
07:44:00 <dminuoso> There's so many things I wouldn't want to write Python/JS at all.
07:44:01 <Bish> i mean there are prroblems good in haskell but bad in python/js aren't there
07:44:40 <merijn> Bish: Sure
07:45:02 <Bish> so how do you decide for those, i mean you could use rust there :p
07:45:05 <dminuoso> If it's an imperative language you are looking for..  look no further. Haskell is the best imperative language out there! :)
07:45:35 <dminuoso> (It's a bit of humor, don't take it too literally)
07:46:11 <tydeu> ironically, it can somewhat be
07:46:35 <dminuoso> Bish: A common problem in the realm of "traditional languages" is that they are all too similar. There are no relevant facilities that meaningfully impact the way you write, maintain, reason about or debug programs.
07:47:11 <dminuoso> So when you chose between "Ruby/Python/JavaScript" it quickly becomes a matter of "Does it have more libraries in my problem domain" or "Do I like this more"
07:47:25 <merijn> Bish: The borrow checker while great for what it attempts to do (safe resource management without a GC) is more hassle than just writing code in a language with a GC (like Haskell)
07:47:40 <boxscape> hehe quote from wikipedia: "[Gilad Bracha believes that] mandatory type systems make languages less expressive and code more fragile"
07:47:45 <boxscape> sounds absurd to me but okay
07:48:14 <tydeu> boxscape: it certainly can in many cases
07:48:16 <merijn> Bish: Because you have to prove that what you're doing is fine to the borrow checker all the time, which is effort and an annoyance in cases where you don't care about the "cost" of a GC
07:48:27 <fendor> does cabal modify the path somehow when running, similar to stack?
07:48:29 <dminuoso> boxscape: To be fair, Gilad was involved in languages that awere essentially smalltalk clones.
07:48:33 <boxscape> I can kind of see the less expressive case but not the fragility case
07:48:42 <merijn> fendor: when running what?
07:48:57 <dminuoso> Bish: A relevant factor becomes: What semantics and facilities does the language offer to help you write robust code, reason about it, debug it, maintain it.
07:49:16 <fendor> merijn, not sure... for running tests or compiling?
07:49:47 <merijn> fendor: It might automatically add the libexec paths, but not much more. Why?
07:49:54 <dminuoso> Bish: Rust has a full mindset (reflected in all its libraries), burrow checking, safe memory without GC. (GHC) Haskell gives you a highly expressive type system, algebraic data types and type-system guaranteed purity.
07:50:02 <dminuoso> *full imperative mindset
07:50:12 <dminuoso> Rust gives you algebraic data types as well, of course.
07:50:13 <tydeu> boxscape: type systems require you to often predict what the use of the system will be if that changes sufficiently late in development, it can require a near-complete rewrite wheras systems with dynamic/duck typing can often be monkey-patched if necessary
07:50:23 <boxscape> hmm okay
07:50:24 <fendor> merijn, for haskell-ide-engine, that the ghc session has access to the same environemnt as stack or cabal
07:50:55 <dminuoso> tydeu: And how does that fit with the fragility argument?
07:51:01 <solonarv> fendor: this shouldn't be a problem, because HIE uses `cabal repl` or `stack repl` to start the GHCI session
07:51:10 <solonarv> at least it did last I checked
07:51:14 <Bish> well so far im just frustrated with haskell
07:51:21 <Bish> whenever i learn something new, i get 10 more things to learn
07:51:33 <dminuoso> Bish: Perhaps stick to what you know and explore it for a while.
07:51:33 <Bish> in other languages there is code... and the compiler may or may not ooptimize it
07:51:38 <merijn> Bish: Have you seen the Haskell pyramid?
07:51:45 <Bish> merijn: no
07:51:55 <dminuoso> Bish: The amount of core essential Haskell can be learned in 3-6 months.
07:51:57 <merijn> Bish: https://patrickmn.com/software/the-haskell-pyramid/ :)
07:52:03 <fendor> solonarv, no it uses cabal repl and stack repl to find the compile options
07:52:19 <fendor> solonarv, ghc session is not executed in their context
07:52:31 <merijn> Bish: Which raises the question: Do you *actually* need those 10 new things to write useful code?
07:52:37 <Bish> well my problem is that i want to understand it
07:52:39 <solonarv> oh, I must have misremembered
07:52:43 <dminuoso> Bish: That's a personal problem then.
07:52:52 <fendor> solonarv, maybe it was different with ghc-mod. I dont know ghc-mod
07:52:58 <merijn> Bish: I find that many beginners think they need to master much more than they really have to
07:53:17 <Bish> sure, to play badminton i need to get the ball over the net
07:53:28 <Bish> but to enjoy it, it's cool to have some techniques and improve
07:53:34 <Bish> and that improvement seems to be endless in haskell
07:53:48 <tydeu> dminuoso: the approach can be considered "fraill" (as opposed to "flexible") as it can not easily handle certain changes.
07:53:54 <merijn> Bish: Well, yeah, you just gotta make sure to interleave improvement and "doing stuff" :)
07:54:05 <dminuoso> Bish: That deep well is why its an interesting test bed for researchers and people who love to dwell in advanced features.
07:54:21 <dminuoso> Bish: It's not mandatory to keep diving. As you have noticed, it keeps you from being productive.
07:54:23 <fendor> so, e.g. where does cabal take hspec-discover location?
07:54:33 <sm[m]> +1.. balance learning and shipping
07:54:56 <Bish> yeah thing is, it feels wasteful not learning things that make you better in this
07:55:04 <Bish> (i know it's the opposite way around)
07:55:27 <merijn> @quote byorgey math
07:55:27 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
07:55:27 <lambdabot> like learn $ zip math haskell.
07:55:42 <merijn> ;)
07:55:53 <yushyin> haha
07:56:28 <merijn> Bish: For example: It's been...probably a decade since I started writing Haskell. I still haven't bothered to learn 'lens' :)
07:57:08 <Bish> that's really frustrating
07:57:31 <yushyin> and now you could also learn optics
07:57:51 <Bish> is that a word-joke on lens? or does that exist (or both)?
07:57:57 <tydeu> Imo the hardest part of learning Haskell is the most of the documentation (and name conventions) is written from a theoretical mathematical background and while that is great if have that background many of those tools do not really require tha background to understand and could be documented different for different backgrounds (such as a pure CS
07:57:57 <tydeu> background)
07:58:29 <merijn> Bish: People generalised lenses to a bunch of related subjects now called "optics"
07:58:30 <yushyin> Bish: there is an alternative lens library by that name, yes.
07:58:32 <Bish> well, i learn best by reading definitions i certainly don't read the math stuff
07:58:33 <solonarv> Bish: both 'lens' and 'optics' are libraries that exist
07:59:04 <Bish> even started reading category-theory books to understand monads
07:59:08 <merijn> tydeu: The...mathematicl foundations and soundness of Haskell are often exaggerated, tbh :)
07:59:10 <Bish> (didn't help)
07:59:12 <merijn> Bish: Ah, that's a waste of time
07:59:31 <Bish> yeah, i "get" them now, and read some hundred pages without understanding jack shit
07:59:36 <merijn> Bish: Yeah, learning category theory is pointless (for getting better at writing Haskell/getting monads anyway)
07:59:36 <solonarv> they implement the same basic concept(s), but 'optics' is newer and gives up some of the generality for better error messages, if I remember right
07:59:38 <dminuoso> Bish: I think it's quite easy to write quality production code with a bare minimum of "I understand all the base types, functions and type classes" and the standard haskell features like ADTs.
07:59:59 <dminuoso> Bish: And then a small set of essential libraries like vector, containers, network, etc..
08:00:09 <dminuoso> The amount you need is really not much.
08:00:12 <merijn> Bish: So, what would you like to write in Haskell? And where did you get stuck?
08:00:14 <yushyin> Bish: I didn't bother learning cat-theo monads, I just used the monad implementations of [a], Maybe a, IO a etc.
08:00:32 <Bish> merijn: well, simple, i'd like to write something like yesod, but not use yesod? if you catch my drift
08:00:35 <tydeu> dminuoso: but then you end up writing half the standard library which feels silly
08:00:38 <dminuoso> Plus, if you start writing production software you learn Haskell - so when you dive again after being productive for a while, you learn new topics faster.
08:00:45 <merijn> Bish: I mean...Yesod is...a scary beast
08:01:10 <sm[m]> oh pish.. not really
08:01:13 <Bish> yeah, i am wondering right now how i would write models (like i did in ruby for my startup)
08:01:31 <Bish> i like the idea behind yesod, but not how it's done
08:01:37 <fendor> looks like I can use `cabal exec -- printenv`
08:01:57 <dminuoso> Bish: Id try not reinventing Rails for Haskell. You wont succeed for so many reasons. :)
08:02:08 <dminuoso> Bish: I discovered something truly wonderful in Haskell.
08:02:08 <merijn> sm[m]: Tons of opaque TH mess everywhere, quickly becomes frustrating and confusing, imo
08:02:08 <sm[m]> why does everyone have a problem with yesod ? have y'all seen the monster web frameworks in other languages ?
08:02:11 <Bish> dminuoso: well, i didn't like rails already
08:02:15 <Bish> that's why i went for sequel/roda
08:02:18 <dminuoso> Websites using *RAW SQL*.. with a thin postgresql library...
08:02:26 <dminuoso> It's less code than rails, much much faster, easier to reason about..
08:02:27 <merijn> sm[m]: So? Just because all the other languages suck too doesn't make Yesod better
08:02:28 <dminuoso> All around simpler..
08:02:36 <Bish> but my models have many cool stuff in ruby, and im wondering how i would do the same thing in haskell
08:02:57 <dminuoso> Bish: Much of Ruby advocates really shitty code.
08:03:08 <sm[m]> I think most people dissing yesod are not in the business of shipping web apps
08:03:32 <Bish> dminuoso: i agree, that's why i went for haskell, but here i am not able to do the same stuff i am "able" to do in ruby
08:03:44 <dminuoso> Bish: It mostly requires re-thinking.
08:03:45 <Bish> *believing* learning more shit about haskell helps
08:03:46 <Bish> but it doesn't
08:03:56 <merijn> sm[m]: I'm not, no. But that doesn't change that I like my frameworks/setups to be composable and understandable, not big monolithic things where I have to buy into everything or nothing
08:03:56 <dminuoso> Bish: Most of the problems a web developer faces are so fundamentally simple..
08:04:16 <dminuoso> Bish: You'd just write a simple function to do what you want, and then use that function. 
08:05:00 <dminuoso> Trying to do copy ruby idioms to Haskell will leave you with headaches.
08:05:23 <Bish> im not trying to copy idioms, im trying to redo the behaviour  i written in it
08:05:30 <dminuoso> Do you have a concrete example?
08:05:32 <sm[m]> merijn: that's totally fine. But I think the constant yesod criticism in the community is overblown
08:05:39 <adamCS> merijn, Bish: I don't agree that learning CT is "useless". It's massive overkill at the outset, but it sort of helps with thinking about things later on, both in a type-theory way--though I don't understand that part--and here and there with things like folds and lenses and whatever.  It's never the easiest way to learn those things, but it's a way to understand them differently and that often means understanding them better.
08:05:49 <Bish> dminuoso: for example, my startup uses sharding..  and my customers are organized in realms
08:05:53 <sm[m]> it has a certain focus and goal, which is explained up front in the docs, and I think it's very good at that
08:06:01 <Bish> and if i want to access a shard of a realm i do realm.with_shard {}
08:06:04 <merijn> adamCS: If your goal is "the best return-on-investment for getting better at writing Haskell" it is
08:06:06 <Bish> i was pretty proud when i wrote this :D
08:06:25 <merijn> adamCS: Until you've read pretty much "everythng else" already, but by that time you know enough to decide for yourself
08:06:58 <adamCS> merijn: That's prolly true.  At least for most things you'd want to write. 
08:07:26 <merijn> sm[m]: I think a large number of people disagree with its vision and goal and recommend against it for that reason alone
08:07:42 <Bish> or.. i wrote something that let's a user define "custom columns" inside a datatable with jsonb in postgresql, and from ruby they just have been used like the regular ones
08:07:58 <Bish> i have no clue how i would go about that with haskell
08:08:01 <adamCS> merijn: But since people often come to Haskell because of a certain...affection for thinking abstractly, I'm not sure ROI is always the best metric.
08:08:36 <merijn> adamCS: I've seen so many beginners getting tarpitted by the idea that category theory is a good basis for learning to write/understand haskell...
08:08:38 <adamCS> merijn: That is, I think many Haskellers might enjoy the meander through CT enough to compensate for its inefficiency.
08:09:00 <merijn> adamCS: I never recommend against learning CT. I recommend against learning CT *to get better at Haskell*
08:09:04 <adamCS> merijn: Yes! That's no good.  It's hard to even explain which subset is relevant.
08:09:09 <adamCS> right
08:09:37 <sshine> whenever people say they want to get good at doing push-ups, I always recommend crunches.
08:09:46 <DaisyChristieeee> Whats wrong with it ? https://bit.ly/38yoZCp Could you please help me to debug it..
08:09:52 <sshine> you may not get good at push-ups, per se, but those two are just so related.
08:09:56 <merijn> sshine: tbh, that's a bad analogy as that'd actually work rather well :)
08:10:15 <boxscape> perhaps it's better to start by learning about crunches rather than actually doing them
08:10:27 <sshine> merijn, I did crossfit for a year and actually became a decent climber without having climbed. the point is, surely there's transferable knowledge. but then there's technique. :P
08:10:50 <sshine> s/knowledge/skill/
08:10:52 <adamCS> merijn: But I guess I would say that once you have a certain level of competence, CT is one interesting road for deepening the way you think about composition and it's sort of all about composition...But yeah.  Not for beginners and not usually to get "better" in any straightforward sense.
08:10:52 <merijn> sshine: Most people who have shitty push-up form do so because of lack of abs ;)
08:11:14 <merijn> adamCS: Sure, but people who have reached that level of competence don't have to ask anymore ;)
08:11:24 <sshine> merijn, yeah okay, it was as bad as analogies are.
08:11:25 <adamCS> merijn: Fair enough!
08:11:38 <merijn> @quote analogies
08:11:38 <lambdabot> monochrom says: People dig analogies. But you know that if analogies never break, then there is no need to learn new things. By definition "new" means no analogy with old things.
08:11:40 <merijn> aww
08:11:43 <merijn> Wrong one
08:12:03 <merijn> @quote mmorrow analogies
08:12:04 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
08:12:15 <sshine> haha
08:12:17 <yushyin> :D
08:13:49 <DaisyChristieeee> Whats wrong with it ? https://bit.ly/38yoZCp Could you please help me to debug it..
08:14:18 <DaisyChristieeee> Whats wrong with it ? https://bit.ly/38yoZCp Could you please help me to debug it..
08:14:40 <dminuoso> !ops
08:14:45 <dminuoso> ?ops
08:14:45 <lambdabot> Maybe you meant: pl oeis docs
08:14:48 * dminuoso sighs
08:14:58 <merijn> @where ops
08:14:58 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
08:15:02 <merijn> dminuoso: :p
08:15:04 <dminuoso> Thanks.
08:15:12 <sshine> DaisyChristieeee, not possible
08:15:23 <dminuoso> ^- can someone please deal with that spammer? :)
08:20:22 <boxscape> I was about to suggest just autoremoving messages with link-shorteners but then I remembered that we're using IRC...
08:32:36 <ezzieyguywuf> in chapter 10 of Real World Haskell (http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html), the author first presents some functions by providing their type signature, and then later describes these functions, providing the type signature again but commenting them out since they've been described earlier in the file. Is this a common idiom in Haskell? In other 
08:32:42 <ezzieyguywuf> words "here are sum functions types of functions I'll describe at the bottom, but I'll provide them here at the top so you understand my main function more betterer".
08:32:46 <ezzieyguywuf> Or rather, is this simply done this way in order to help the flow of the book?
08:33:25 <solonarv> I don't recall seeing this anywhere other than in educational material
08:33:54 <solonarv> usually a function's type signature stays close to its definition
08:34:00 <ezzieyguywuf> solonarv: great, thanks for the insight.
08:34:16 <merijn> ezzieyguywuf: I have a (good) guess why they're commented out
08:34:29 <merijn> ezzieyguywuf: RWH did doctests to ensure all the Haskell code actually compiles
08:34:37 <merijn> ezzieyguywuf: Duplicate type signatures are a compile error
08:34:48 <merijn> I suspect the commenting is to ensure the doctests can compile properly
08:34:53 <solonarv> sometimes you will see several type signatures given together, like: div, quot, mod, rem :: Int -> Int -> Int -- with all the implementations right below
08:35:09 <ezzieyguywuf> merijn: yes I think you're right
08:35:14 <sshine> merijn, ah, so RWH was a piece of Literate Haskell compiled to book?
08:35:18 <ezzieyguywuf> and a few chapters back a bunch of those tests fail ^_^
08:35:53 * hackage lzlib 0.3.3.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.3.3.0 (vmchale)
08:35:54 <merijn> sshine: Not sure it's literate Haskell or just processed to extract code
08:36:24 <Bish> wtf whats that spam supposed to do
08:36:27 <solonarv> if it can be processed to extract code, then it's literate (although it might not be the usual LHS format)
08:36:46 <sshine> Bish, maybe it's a DDoS attack. the page looked pretty broken.
08:37:05 <Bish> .. good old social engineering ddos?
08:37:13 <Bish> spamming the link so the weak goverment pages die?
08:37:20 <sshine> Bish, I really don't know. could just be a helpless guy?
08:37:36 <Bish> as in shizophrenic?
08:37:55 <sshine> Bish, consistency is a social construct!
08:44:32 * Digit gets scary notion, a package manager and system configuration/definition/installer ... in Haskell.    scared to look, in case finds it, and disruptively uproots everything here.
08:49:15 <ezzieyguywuf> I've noticed a pattern where a type defintion might say `MyFunc :: Maybe a -> (a -> Maybe a) -> Maybe b` and then the implementation might be `MyFunc Just v = ...`. Is there a logic to using `a, b, c...` in the type definition, but then other (more descriptive?) single-letter names in the implementation?
08:49:50 <ezzieyguywuf> my brain expects the implementation to look like `MyFunc Just a = ...`
08:51:40 <dminuoso> ezzieyguywuf: No.
08:52:02 <solonarv> one thing to keep in mind is that type variables will often be repeated
08:52:03 <dminuoso> ezzieyguywuf: Some authors have some conventions, others do not..
08:52:16 <solonarv> e.g. 'bool :: a -> a -> Bool -> a'
08:52:45 <solonarv> but you can't repeat variable names in patterns (and even if you could, there's no way it could mean the right thing)
08:53:03 <solonarv> so the implementation can't be 'bool a a = ...'
08:53:31 <ezzieyguywuf> another question: I read the code for `paseP5_take2` in http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html as "If 'matchHeader... >>? \s -.... ' returns Nothing, then parseP5_take2 returns Nothing, else if" and then keep chaining these "if else"
08:53:51 <ezzieyguywuf> the question: is it typical to refer to something like ">>?" and "parseP5_take2" as "returning" something?
08:53:58 <ezzieyguywuf> I ask due to the `return` keyword
08:54:11 <ezzieyguywuf> I understand (mostly) that `return` in Haskell is used to wrap a value in an IO monad
08:54:12 <dminuoso> ezzieyguywuf: The word `return` is a historic thing. 
08:54:16 <dminuoso> ezzieyguywuf: Yup!
08:54:21 <ezzieyguywuf> so I'm wondering if some other terminology is used elsewhere
08:54:25 <dminuoso> ezzieyguywuf: We can wrap it into any monad in fact.
08:54:36 <dminuoso> ezzieyguywuf: We can use `return` to put a value into a paser.
08:54:41 <dminuoso> `return 5 :: Parser Int`
08:54:56 <ezzieyguywuf> solonarv: that does help!
08:54:58 <dminuoso> It it such a parser that, if you bind to it with >>=, you'd get 5 into the function to the right.
08:55:12 <dminuoso> Even more so, its an effect-less parser that doesnt consume anything.
08:55:39 <ezzieyguywuf> dminuoso: hrm, that's a bit above my comprehension level presently :-P
08:55:45 <Cale> ezzieyguywuf: return isn't a keyword, btw, it's a function
08:55:51 <dminuoso> ezzieyguywuf: That's basically just saying:
08:56:13 <dminuoso> ezzieyguywuf: do { x <- pure 5; ... } is the same as `do { let x = 5; ... }` :)
08:56:17 <dminuoso> or
08:56:20 <dminuoso> ezzieyguywuf: do { x <- return 5; ... } is the same as `do { let x = 5; ... }` :)
08:56:25 <dminuoso> (pure and return are the same thing)
08:56:28 <Cale> return is defined differently for each monad, but the general idea is to make some computation which does nothing except to, well, return the given value.
08:56:44 <ezzieyguywuf> I guess, let my ask my question differently. `let x = MyFunc 10`. Does MyFunct "return" some value that is stored in `x` or does `MyFunct` (say) "produce" some value that is stored in `x`
08:56:56 <ezzieyguywuf> I realize this is purely semantics, but I'm just wondering how you all read these syntaxes in your head
08:57:21 <solonarv> ah, in this case it doesn't really matter that 'return' is also the name of a function in the standard library
08:57:26 <solonarv> just an unfortunate clash of words
08:57:27 <dminuoso> ezzieyguywuf: Strictly speaking it doesnt return anything.
08:57:42 <Cale> ezzieyguywuf: x is defined to be MyFunc 10 (and I'm not sure you intend this, but MyFunc must be a data constructor because its name starts with an uppercase letter)
08:57:49 <dminuoso> ezzieyguywuf: When you write `x = MyFunc 10`, think of it as a statement of equality. You are stating "x" and "MyFunc 10" are the same thing.
08:58:05 <dminuoso> You define "x" to mean "MyFunc 10", such that any appearance of x could be replaced with "MyFunc 10"
08:58:09 <ezzieyguywuf> in my last example, `MyFunc : a -> Int`
08:58:14 <ezzieyguywuf> *shrug* or some such
08:58:29 <dminuoso> ezzieyguywuf: Does that make any sense to you?
08:58:34 <ezzieyguywuf> er... `MyFunct :: a -> Int`
08:58:49 <Cale> That equation is properly a mathematical equation.
08:59:02 <ezzieyguywuf> dminuoso: it's just placeholder for the question I had. The sense it makes to me is "MyFunct always returns an Int"
08:59:08 <Cale> It's not like a variable assignment
08:59:18 <dminuoso> ezzieyguywuf: No, that's a wrong take on it.
08:59:37 <dminuoso> ezzieyguywuf: = is not assignment, it's a way of defining the left hand side to mean the right hand side.
09:03:35 <dminuoso> 17:56:22     ezzieyguywuf | I guess, let my ask my question differently. `let x = MyFunc 10`. Does MyFunct "return" some value that is stored in `x` or does `MyFunct` (say) "produce" some value that is stored in `x`
09:05:18 <dminuoso> ezzieyguywuf: Cale pointed out that you might have inadvertedly capitalized MyFunct. Was that your intention?
09:06:22 <Cale> (but since the question was about the meaning of the = sign, the answer to that doesn't really matter -- in any case, definitions are definitions)
09:07:26 <dminuoso> Fair enough
09:12:20 <pounce> how do i use the identity monad?
09:13:06 <Taneb> :t (runIdentity, return :: a -> Identity a, (>>=) :: Identity a -> (a -> Identity b) -> Identity b)
09:13:08 <lambdabot> (Identity a1 -> a1, a2 -> Identity a2, Identity a3 -> (a3 -> Identity b) -> Identity b)
09:13:18 <Taneb> pounce: honestly there's not much to the identity monad
09:14:08 <Taneb> Pleasant theory aside, the only real use of the monad instance for Identity is as a sort of "default" inner monad for monad transformers, like how StateT Identity is State
09:14:35 <pounce> makes sense makes sense
09:14:36 <ezzieyguywuf> Ah...`MyFunc` should by `myFunc`, because it is a function. Not a, erm..."data type"?
09:15:37 <wildtrees> sometimes I use Identity as a functor or a monad when a function's type signature requires a monad or a functor and I don't really want one 
09:16:19 <Cale> ezzieyguywuf: Data constructor
09:16:24 <solonarv> ezzieyguywuf: "data constructor" if you want to be very specific, or just "constructor"
09:16:26 <ezzieyguywuf> Cale: thanks
09:17:08 <ezzieyguywuf> so it `data MyData = MyConstructor Int`, "MyData" is a...."data constructor". and "MyConstructor" is a...."value constructor"?
09:17:17 <ezzieyguywuf> s/so it/so in/
09:17:51 <solonarv> no
09:18:01 <solonarv> MyConstructor is a data constructor
09:18:09 <solonarv> MyData is a type constructor
09:18:19 <ezzieyguywuf> hmm, I see
09:19:15 <ezzieyguywuf> *nods* yup, I get it.
09:19:48 <ezzieyguywuf> and `MyData` can be made polymorphic by introducing an number of variables to the type constructor, e.g. `data MyData a...`
09:21:56 <Cale> Yeah, or it's probably more correct to say that MyData is parametric, while MyConstructor will be polymorphic
09:24:08 <Cale> That's kind of a subtle nitpick -- a type constructor being polymorphic would mean something like that it may have different *kinds* (which are the types of types)
09:25:11 <ezzieyguywuf> *boom* that was my brain
09:25:57 <Cale> haha, well, to explain a bit about kinds, there is a kind called * which is the kind of all the ordinary types which have values
09:26:23 <Cale> and then for any kinds k1 and k2, there is a kind k1 -> k2 for types which take a parameter of kind k1 and produce a type of kind k2
09:26:38 <Cale> So, if we have e.g. data Foo a = MkFoo a a
09:26:45 <Cale> Foo will have kind * -> *
09:27:16 <Cale> because it takes a parameter which is an ordinary type, and gives us an ordinary type
09:27:38 <Cale> We can also do something like this:  data Bar f = MkBar (f Integer)
09:28:10 <Cale> What kind will this have? Well, in plain Haskell, it will have kind (* -> *) -> *
09:28:27 <ezzieyguywuf> ahh, I remember glossing over this in "Learn you a Haskell for Great Good!"
09:28:49 <ezzieyguywuf> and then forgetting it b/c I figured I'd go back and learn it more better when I needed it :-P
09:28:54 <ezzieyguywuf> thank you for your explanation though
09:28:57 <Cale> i.e. we can apply Bar to something like Foo, and get an ordinary type
09:29:36 <Dale42> Hello. I seem to have a problem with line buffering. Flushing stdout works as expected in ghci, but when compiled it does not. I also noticed that when compiled, som kind of line editing capabilities is enabled when reading input with getLine. Is this the problem? How can this be shut off?
09:30:16 <Cale> Actually, that's not the example I want... let's look at one more
09:30:31 <roconnor> Is unsafeDupablePerformIO safe to use with Foreign.Marshal.Alloc.alloca?
09:31:08 <Cale> data ApplyTo x f = AT (f x)
09:31:40 <Cale> You might think this just has a kind like * -> (* -> *) -> *
09:31:53 <Cale> and that's indeed a valid kind for it to have
09:32:15 <Cale> But it's possible to be polymorphic about it with the PolyKinds extension
09:32:32 <Cale> it'll get the kind: k -> (k -> *) -> *
09:33:16 <Cale> So, then ApplyTo would be polymorphic (or poly-kinded) because its kind has a variable in it
09:34:19 <Cale> Dale42: You can change the buffering mode e.g. with  hSetBuffering stdin NoBuffering
09:34:31 <Cale> Dale42: That stuff comes from System.IO
09:34:41 <roconnor> oh there is unsafeLocalState
09:36:22 <Cale> roconnor: The alloca is inside the unsafeDupablePerformIO?
09:36:39 <Cale> I think that *could* be okay... if you don't mind allocating twice the memory sometimes
09:37:00 <Cale> (and, of course, know that the result of the computation will be the same both times)
09:37:31 <berndl> I'm having a hard time figuring out why the type of callCC is the way it is. Maybe someone can demistify it for me?
09:37:40 <Cale> :t callCC
09:37:42 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
09:37:54 <Dale42> Cale: Yes but I have tried setting NoBuffering. Same problem though
09:38:32 <Cale> berndl: Imagine we have some situation like: callCC $ \abort -> ...
09:38:48 <berndl> Cale: go on
09:39:04 <Cale> berndl: The idea is that the computation in the "..." there can execute  abort x  and it will cause the whole callCC to end immediately with result x
09:39:51 <Cale> i.e. it works like "return" does in most imperative languages, or "break" or any of those sorts of things.
09:40:04 <roconnor> Cale: Seems like Foreign.Marshal.Unsafe.unsafeLocalState is specifically designed to handle alloca
09:40:27 <berndl> Cale: I understand the semantics of it. I just don't understand how to go from the semantics to the type.
09:40:34 <Cale> Every function you define in an imperative language is sort of implicitly wrapped in a callCC, and the return keyword is the only way you have to access the function it gives you
09:40:42 <Cale> So, let's look at the types here
09:41:40 <Cale> For any x :: a, we want abort x to be an m-action
09:41:54 * hackage plucky 0.0.0.0 - A library and technique for handling errors via plucking constraints  https://hackage.haskell.org/package/plucky-0.0.0.0 (parsonsmatt)
09:41:59 <Cale> It's not going to return, because it's going to abort, so its result type can be whatever
09:42:05 <Cale> So abort :: a -> m b
09:42:29 <berndl> Alright.
09:42:48 <Cale> and then the argument to callCC is something which takes abort as a parameter and produces an action of type m a (if it finishes normally, it'll also produce a result of type a)
09:42:54 <roconnor> The type of callCC ought to be ((a -> m Void) -> m a) -> m a but it was written before empty data types were allowed.
09:43:00 <Cale> So that's ((a -> m b) -> m a)
09:43:21 <Cale> that's the type of the argument to callCC
09:43:29 <Cale> and then callCC itself produces an m a action
09:43:40 <Cale> so ((a -> m b) -> m a) -> m a
09:44:40 <Cale> berndl: Make sense?
09:45:07 <berndl> That kinda makes sense. The "we want abort x to be an m-action"  and "so its result type can be whatever" are the parts that get me.
09:45:57 <geekosaur> "m b" is never reached and never produced
09:46:00 <geekosaur> :t forever
09:46:01 <lambdabot> Applicative f => f a -> f b
09:46:22 <geekosaur> same thing going on with the "f b" there, it's never reached so there is never a need to produce a "b"
09:46:22 <Cale> Well, control is never going to be returned to the point where abort x is executed, right?
09:46:54 <berndl> Right.
09:47:27 <Cale> So, the type of value which is returned is a moot point, it could be any type because no value is ever going to be returned
09:47:57 <Cale> So that was expressed with polymorphism
09:48:17 <Cale> Another option would be to express it with an empty data type as roconnor suggests
09:49:26 <berndl> I see. And the "m-action" part is just extra monad goodness. I could have defined callCC without having to deal with monads, right?
09:49:47 <Cale> uhh, well, if you wanted to bake such a thing into the language
09:49:53 <Cale> But then you have effects everywhere
09:50:18 <geekosaur> note that m is something with a MonadCont instance. most of the machinery is in MonadCont
09:50:40 <berndl> I think I can reconcile the definition without the m-action part with the one from SMLNJ: https://smlnj.org/doc/SMLofNJ/pages/cont.html
09:51:31 <Cale> berndl: Yeah, in SML, they implicitly have effects everywhere, so "functions" aren't always proper functions
09:52:53 <Cale> and yeah, they could have had callcc : (('a -> 'b) -> 'a) -> 'a if they wanted
09:55:15 <berndl> Cale: Cool. Thanks for the explanation.
09:55:24 * hackage test-lib 0.2.1 - A library to make a quick test-runner script.  https://hackage.haskell.org/package/test-lib-0.2.1 (IavorDiatchki)
09:56:20 <Cale> berndl: But the callCC operation in Haskell is also more general in some ways, because MonadCont can be (and usually is) implemented by transforming other monads using ContT, so this is really a wide family of related operations.
09:57:10 <berndl> There was a time when I thought that values Cont r a where continutations. That really confused me to no end.
09:57:34 <berndl> *values of type Cont r a
09:57:39 <Cale> :t runCont . sequence . map cont
09:57:40 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
09:58:22 <berndl> It's the a -> r things that are continuations. Cont r a things are like "continuation handlers".
09:58:57 <Cale> Given a list of withFoo-style / CPS functions, this nests them to get you a single one that grants you a list :)
10:00:20 <Cale> ... if you've seen a bunch of that style of function before
10:01:02 <Cale> For example, from the question roconnor was asking earlier, there's a function  alloca :: forall a b. Storable a => (Ptr a -> IO b) -> IO b
10:01:11 <roconnor> :)
10:01:25 <ezzieyguywuf> what would my Ch10.cabal file need to look like in order to have https://github.com/wkoszek/book-real-world-haskell/tree/master/examples/ch10 produce the output shown after `:load Parse` in GHCI here http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html
10:01:36 <Cale> which allocates and deallocates some memory for a value of type a, and then passes a pointer to it to the function you give in between
10:03:15 <solonarv> ezzieyguywuf: first, run 'cabal init' to generate a .cabal file
10:03:16 <Cale> It's pretty common to handle resource management in this way, to make sure you always clean up after yourself, but then you may end up with a lot of deeply nested functions. Cont/ContT can help flatten that out in cases where it becomes annoying to manage.
10:03:30 <ezzieyguywuf> I don't understand how it pulls in the PNM module
10:04:01 <ezzieyguywuf> lol, "command not found: cabal"
10:04:08 <solonarv> simple: Parse.hs has 'import PNM' near the top
10:04:18 <ezzieyguywuf> solonarv: ah hah
10:04:21 <ezzieyguywuf> missed that!
10:04:52 <solonarv> did you install cabal already?
10:06:07 <Dale42> Is it possible that the terminal/shell is messing with my getLine input? I'm not able to fFlush stdout when compiled, but it works in ghci
10:06:21 <ezzieyguywuf> hah no
10:06:36 <ezzieyguywuf> I'm going to do the `ghcup` thing now. I've put it off too long
10:06:46 <solonarv> yes, I was going to suggest that
10:07:17 <Cale> Dale42: Is it possible that your problem is input buffering related?
10:07:55 <Cale> Dale42: Try turning off buffering on stdin and see if that makes a difference
10:08:09 <Dale42> Cale: thanks will try!
10:13:41 <Dale42> Cale: Yes that worked! Did set NoBuffering on stdin. Now it works identically with ghc and ghci. Thanks a lot!
10:13:50 <day> is there a way to pattern match multiple elements of a list at once? e.g. (x:xs) but 'x' here is supposed to be 'take n'
10:14:17 <geekosaur> x:y:z:xs?
10:14:21 <day> i guess i can always use take/drop for recursiveness, but ...
10:14:30 <day> yeah that is fine for smaller quantities
10:14:56 <geekosaur> no way to make it give you a list of them, though
10:15:03 <Cale> Dale42: cool
10:15:16 <day> geekosaur: thanks
10:15:38 <Cale> Well, you could use a view pattern with splitAt
10:15:54 <Cale> I usually wouldn't though
10:16:23 <geekosaur> pattern matches normally can't restructure what they capture, and a list would mean adding a nil to the end of the list which means building a new list from the parts of the original
10:16:48 <geekosaur> view patterns can do this because they run arbitrary code on the matched values; seems not worth it here
10:17:07 <Cale> > let foo (splitAt 10 -> (xs,ys)) = (xs,ys) in foo "here is a string to chop"
10:17:09 <lambdabot>  ("here is a ","string to chop")
10:17:34 <Cale> This is probably less clear than... most other ways of expressing the same thing
10:18:18 <Cale> (even if you're going to do something more involved with the parts, just using a let expression or where clause is an option)
10:21:37 <ezzieyguywuf> how mature is the Cabal suite of tools? I'm used to leveraging "cmake" heavily for writing build-files (I use ninja) in a cross-platform way
10:21:55 <ezzieyguywuf> it seems that Cabal has taken that and added features of, say, pip (from python) so that it is more all-inclusive
10:22:12 <ezzieyguywuf> the motivation for my question is I'm trying to decide how deeply I wish to learn Cabal
10:22:31 <ezzieyguywuf> if it is relatively "young" and likely to change drastically or get replaced altogether, then I'll just learn it very shallowly
10:24:54 * hackage hlint 2.2.8 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.8 (NeilMitchell)
10:25:47 <exarkun> cabal is pretty widely used and has been around a while
10:26:10 <MarcelineVQ> Cabal is a library, the tool is cabal-install which on the cli is called cabal.  You have to learn enough about Cabal to write a .cabal for your project if you want to use haskell to create things. Though you can learn haskell withouth doing that. things that arne't cabal-install, like stack, still use .cabal files of the Cabal libary
10:27:14 <HiRE> What is the difference between `floating` and `double` in a type signature? Is `floating` a general purpose float/double or if I want a double should I use `Double`?
10:28:18 <MarcelineVQ> Double is the type of double precision floating numbers, Floating is a typelcass that things like Float and Double are instances of. Similar to how Int and Integer are instances of the Integral typeclass
10:29:16 <sm> ezzieyguywuf: it's not young. It's not finished either, it's continually evolving. You should also check out stack, it's good at cross platform (windows)
10:29:48 <sm> and no, it's not going to get replaced altogether
10:37:40 <solonarv> it might be good to clarify what exactly you mean by "good at cross-platform"
10:43:41 <ezzieyguywuf> hm, a cursory look at `stack` suggests taht perhaps it would be helpful for setting up continuous integration/development with, say, gitlab
10:44:17 <solonarv> cabal does that about equally well, tbh
10:51:37 <sm> solonarv: stack has generally made it easier to get things building on windows
10:52:29 <solonarv> ah yeah, stack is somewhat more convenient on windows
10:52:43 <solonarv> mostly due to the unavailability of ghcup or a proper package manager
10:52:56 <solonarv> although chocolatey works rather well, and ghcups apparently exists
10:54:54 * hackage plucky 0.0.0.1 - A library and technique for handling errors via plucking constraints  https://hackage.haskell.org/package/plucky-0.0.0.1 (parsonsmatt)
10:55:53 * hackage api-builder 0.17.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.17.0.0 (Intolerable)
11:13:47 <oats> is a good way to convert a `[Word8]` into `Vector Bit`?
11:13:58 <oats> don't know why I can't figure this one out
11:14:40 <dmwit> I think nothing significantly better than writing `explode :: Word8 -> [Bit]` and `fromList . concatMap explode`.
11:15:42 <dmwit> Maybe `explode :: Word8 -> Vector Bit` and `V.concatMap explode . fromList` would be mildly better.
11:16:04 <dmwit> (explode may be implemented in terms of testBit e.g.)
11:16:46 <oats> uh, explode?
11:17:01 <dmwit> You can pick a better name if you want. =)
11:17:33 <oats> lol
11:17:39 <nshepperd2> uncrush
11:17:49 <MarcelineVQ> byteToBits
11:17:54 <Clint> asplode
11:18:09 <dmwit> I think "blast" is fairly standard in the SMT solver world.
11:18:35 <oats> not even sure how to do that one
11:18:44 <oats> maybe I should lay out my bigger problem lol
11:19:17 <oats> I want to convert a string of hex codes (ie "00a0feff") to `Vector Bit`
11:19:24 <cocreature> â€œbitblastâ€ is the term Iâ€™ve usually heard in the STM solver world
11:20:42 <[exa]> oats: it might be better to have a table for the 16 chars and concat the resulting vector from 4bit ones
11:21:52 <oats> hmm
11:21:58 <oats> that kinda makes sense
11:22:39 <[exa]> oats: still, what are you going to do with the Vector Bits?
11:23:04 <oats> uh, crypto homework :P
11:25:06 <[exa]> hm then it's probably okay, just use the specialized operations from https://hackage.haskell.org/package/bitvec-1.0.2.0/docs/Data-Bit.html#g:2
11:25:30 <oats> yeah, that's the package I'm looking at
11:26:16 <oats> I'm just sad there's no 'castFromWord8s :: Vector Word8 -> Vector Bit'
11:30:56 <dmwit> oats: I would use base16-bytestring, then ```V.generate (\vi -> let (bsi, bytei) = i `quotRem` 8 in testBit bytei (bs ! bsi)```
11:31:15 <dmwit> :t V.generate
11:31:16 <lambdabot> error:
11:31:16 <lambdabot>     Not in scope: â€˜V.generateâ€™
11:31:16 <lambdabot>     No module named â€˜Vâ€™ is imported.
11:31:24 <dmwit> ?let import qualified Data.Vector as V
11:31:26 <lambdabot>  .L.hs:129:1: error:
11:31:26 <lambdabot>      Data.Vector: Can't be safely imported!
11:31:26 <lambdabot>      The module itself isn't safe.
11:31:32 <dmwit> % import qualified Data.Vector as V
11:31:32 <yahb> dmwit: 
11:31:43 <dmwit> % import qualified Data.ByteString as BS
11:31:43 <yahb> dmwit: 
11:32:32 <[exa]> oats: btw what kind of crypto? (just curious)
11:33:24 <oats> [exa]: it's something really dumb and simple, based on differential xoring :)
11:33:33 <oats> it's for an "intro to computer security" class
11:33:34 <dmwit> % :t \bs -> V.generate (BS.length bs*8) (\vi -> let (bsi, bytei) = vi `quotRem` 8 in testBit (bs `BS.index` bsi) bytei)
11:33:34 <yahb> dmwit: BS.ByteString -> V.Vector Bool
11:35:16 <dmwit> oats: ^
11:35:44 <dmwit> Hm. Might be right, might not, depending on your desired endianness. ^_^
12:47:02 <ezzieyguywuf> hm, I'm confused with cabal and "v1" vs "v2" commands. I am trying simply to install QuickCheck, however `caba install QuickCheck` tells me that it looks like I'm trying to install an executable when there isn't one, followed by `cabal install QuickCheck --lib` tells me "Up to date", but I still can't` ":load QuickCheck" in ghci
12:48:12 <ezzieyguywuf> whoops, looks like I needed to restart ghci...
12:48:13 <geekosaur> you'd do "import QuickCheck"
12:48:15 <geekosaur> not :load
12:48:29 <geekosaur> aldo yes, ghci only looks at the package db when it starts up
12:48:33 <geekosaur> *also
12:49:57 <evelyn> I think it should be Test.QuickCheck too
12:55:53 * hackage pandoc-plot 0.1.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.1.0.0 (LaurentRDC)
12:56:30 <dazage> say I had a program that stores a person's first name, last name and age. How would that look like following functional programming in haskell?
12:57:31 <merijn> dazage: Stores those where?
12:58:12 <merijn> (Also, don't get me started on the large number of dangerous assumptions about names in just that sentence, but that applies equally to any programming language...)
12:58:18 <dminuoso> dazage: Functional programming is not contrary to effectful or imperative programming. We have the same capabilities that any other programming language has.. :)
12:58:29 <siraben> I'm trying to parse HH:MM:DD time format in a CSV, but I get the error http://ix.io/280S when I try to make LocalTime an instance of FromField 
12:58:44 <siraben> Can I convert from String to Data.ByteString.Internal.ByteString?
12:58:53 <dminuoso> siraben: Using what encoding?
12:59:04 <dminuoso> siraben: Remember that ByteString is just "bunch of bytes" :)
12:59:33 <geekosaur> ezzieyguywuf, you may be confused about the difference between a package (QuickCheck), a module (Test.QuickCheck, which is something you can import), and a source file (which is something you can :load)
12:59:42 <siraben> Well first I have to parse the CSV, and deriving Generic seems to work for the other fields like Text
13:00:23 <geekosaur> when you install a library package, it makes available one or more modules, but doesn't make any source code available.
13:00:33 <dminuoso> siraben: Is this cassava?
13:00:38 <merijn> siraben: Can you? Yes. How? Depends on what the String is, what the ByteString is and what you're trying to do
13:00:48 <siraben> dminuoso:  Yes, cassava
13:01:18 <dminuoso> siraben: class FromField a where parseField :: ByteString -> Parser a 
13:01:26 <dminuoso> siraben: So whatever you implement, it must have that type signature.
13:01:55 <dminuoso> siraben: You gave it something that has the type signature of `String -> Parser ByteString`
13:02:01 <dminuoso> Do you see the problem?
13:02:13 <siraben> Yes
13:02:15 <dazage> merijn: it's not a real progam, just trying to understand functional proramming.
13:02:25 <siraben> So I have to convert from ByteString to String
13:02:36 <dminuoso> siraben: Right, so you have to decode it.
13:02:42 <siraben> I have B.unpack :: B.ByteString -> [GHC.Word.Word8]
13:02:58 <dminuoso> siraben: No, that won't help. What you are looking for is not part of bytestring.
13:03:13 <siraben> I have something like this in the main 
13:03:13 <dminuoso> siraben: You need to consider the encoding of your csv first.
13:03:14 <siraben> http://ix.io/280U
13:03:30 <dminuoso> siraben: Is it unicode? Is it something else?
13:03:39 <siraben> Unicode
13:03:42 <zualk> dazage: You mean assking a user for name and age and storing it in a variable?
13:03:46 <dminuoso> siraben: Then you can use Data.Text.Encoding
13:03:49 <dminuoso> from text
13:04:01 <zualk> It's not exactly something that showcases functional programming at all
13:05:18 <siraben> dminuoso:  where do I use the function from Data.Text.Encoding?
13:05:23 <siraben> in parseField?
13:05:27 <habbah> hey Axman6, sorry to bother you. do you think hasql-th would have helped you with the type safety issue?
13:05:29 <dazage> zualk: you're right. I guess I'm really just asking how to do objects in haskell?
13:05:34 <dminuoso> siraben: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html#v:decodeUtf8-39-
13:05:35 <dminuoso> siraben: Yes.
13:05:42 <dminuoso> dazage: Haskell has no notion of objects.
13:06:25 <dminuoso> dazage: We can do something similar though, we can just create arbitrary data types. Say `data User = User { age :: Int, name :: String }`
13:06:29 <siraben> dminuoso:  parseField = parseTimeM False defaultTimeLocale "%H:%M:%S" . T.unpack . decodeUtf8 works now
13:06:30 <dminuoso> And create values of that data type.
13:06:31 <siraben> Thanks
13:06:35 <zualk> dazage: A data type "data PersonalData = PersonalData { name :: String, age :: Int}"
13:06:37 <dminuoso> siraben: Dont.
13:06:49 <dminuoso> siraben: Use decodeUtf8' and handle the error...
13:07:08 <dminuoso> decodeUtf8 will toss a bottom in your face if there's a decoding error.
13:07:31 <siraben> dminuoso:  Hm?
13:07:55 <dminuoso> siraben: You do know that not all binary data is valid unicode, right? :)
13:08:41 <dazage> dminuoso & zualk: that's precisely it. Thanks for being patient, in retrospect I really should've considered my question better.
13:09:09 <dminuoso> siraben: `decodeUtf8 :: ByteString -> Text` claims that given *ANY* binary data it can give you text. What do you think this does when it receives binary data that is invalid unicode? :)
13:09:26 <siraben> How about
13:09:27 <siraben>     parseField x = case decodeUtf8' x of
13:09:27 <siraben>                      Right s -> parseTimeM False defaultTimeLocale "%H:%M:%S" (unpack s)
13:09:27 <siraben>                      Left err -> fail "wrong date format"
13:09:35 <dminuoso> Yeah, that's better :)
13:09:37 <siraben> I mean time format*
13:09:45 <siraben> Yay
13:09:54 <dminuoso> siraben: Alternatively you can use `decodeUtf8With lenientDecode`, by the way.
13:09:58 <dminuoso> Depends a bit on what semantics you want.
13:10:07 <dminuoso> In this case its better to just use decodeUtf8
13:10:15 <dminuoso> But in some spots the error handling is much harder to fiddle through
13:10:25 <siraben> This is just a toy program, I know the input to be valid, but yeah not all binary data is valid.
13:11:10 <siraben> How is "instance FromRecord Person" valid template haskell?
13:11:12 <ezzieyguywuf> geekosaur: yes, I was confused about those things thank you.
13:11:28 <dminuoso> siraben: Its not. It likely uses a default implementation that in turn uses Generic.
13:11:39 <siraben> Ah
13:12:29 <dminuoso> siraben: Such TemplateHaskell that you thought about can be spotted by top-level splices that look like $(...), or some plain *expression* at module top level.
13:12:38 <dminuoso> siraben: e.g.: makeLenses ''Foo
13:12:48 <dminuoso> (because clearly `makeLenses ''Foo` is not a declaration of any kind)
13:13:35 <dminuoso> siraben: https://hackage.haskell.org/package/cassava-0.5.2.0/docs/src/Data.Csv.Conversion.html#parseRecord
13:13:42 <dminuoso>     default parseRecord :: (Generic a, GFromRecord (Rep a)) => Record -> Parser a
13:13:46 <dminuoso>     parseRecord = genericParseRecord defaultOptions
13:14:48 <siraben> Interesting, first time I've seen the use of "default"
13:16:25 <geekosaur> that's an extension iirc (DefaultSignatures? allowing the default implementation of a class method to have a different signature from instance signatures)
13:19:18 <maerwald> siraben: semi related, but check out tapioca
13:51:27 <fresheyeball> sorry for the hit and run
13:51:39 <fresheyeball> but does anyone know how to target a specifc ghc version in hpack?
13:51:52 <fresheyeball> I should be able to do it with `when`
14:25:42 <zeta_0> if you guys could help me with this xmonad issue, thanks: https://github.com/xmonad/xmonad/issues/210
14:32:11 <abrar> zeta_0: when that happens, what happens if you press mod-t?
14:39:04 <zeta_0> abrar: it works, whenever i press mod-t it brings up the menu for me to open a file, like it should do automatically
14:39:16 <zeta_0> abrar: why is that?
14:39:45 <abrar> zeta_0: the file dialog that it's opening is just sized completely incorrectly
14:40:04 <abrar> mod-t forces the window into your layout
14:40:44 <abrar> you can try a few things
14:40:49 <roconnor> Cale: unsafeLocalState = unsafeDupablePerformIO :D
14:41:02 <abrar> if you hold mod and right-click and drag, you can resize the floating dialog window manually
14:41:14 <abrar> if you size it right and close it, it might remember that size next time
14:43:36 <abrar> zeta_0: if that doesn't work, you can try to set the size in your gtk settings: https://askubuntu.com/questions/96375/why-are-my-file-selection-dialogs-so-big-how-do-i-make-them-smaller
14:47:15 <zeta_0> abrar: i tried to hold mod with right-click and also with left-click but i messed it up worse, so i'll try your other alternative instead
14:49:28 <zeta_0> abrar: thank you for your help, i can finally open files, save files, and upload files onto my web browser now
14:49:44 <abrar> mod left-click is used to move floating windows and mod right-click is used to resize them. you can also press mod-t and then mod left- or right-click so that you're resizing from a reasonably-sized starting point
14:49:58 <abrar> zeta_0: no problem
14:51:04 <zeta_0> abrar: i'll let you know if i the ubuntu instructions worked or not
14:58:56 <siraben> How can I get the value for USD in https://api.exchangeratesapi.io/2010-01-10 with aeson's JSON parser?
14:59:02 <siraben> It's in another object called "rates"
15:04:40 <maerwald> siraben: https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson.html#t:Value
15:04:54 <maerwald> Object is a HashMap
15:05:05 <maerwald> if you parse the string as a JSON Value, then you get that HashMap
15:05:16 <siraben> Yeah, I have that HashMap
15:05:30 <siraben> So I should just look it up USD in the map each time?
15:05:38 <siraben> Or can I extract it
15:06:20 <maerwald> you use the hashmap API to walk the nested hashmaps obviously
15:07:44 <siraben> Got it: http://ix.io/281v
15:07:53 <siraben> Can it be simplified further?
15:09:44 <Axman6> habbah: hey sorry, I wasn't around. I haven't seek hasql-th, I'll have to take a look
15:12:54 <Axman6> habbah: looks like it may help a little, but not a whole lot. I'd certainly use it though
15:20:40 <koz_> If I have FooM a b = FooM (ReaderT Bar (Except (Baz a)) b), and I need to roll its Monad instance by hand, how would I do it?
15:21:04 <koz_> I'm kinda stuck on bind.
15:21:39 <siraben> Got it even shorter: http://ix.io/281w
15:21:55 <merijn> koz_: Why can you not derive it?
15:22:06 <koz_> merijn: Can't use GND?
15:22:13 <merijn> Why not?
15:22:20 <koz_> (plus, I wanna know what happens behind the scenes)
15:22:53 <koz_> It's more the second than the first.
15:23:07 <koz_> (I can request GND, but I wanna know what happens behind the scenes anyway, for my own elucidation)
15:23:36 <merijn> Lots of >>= and lift, that's what happens
15:25:40 <fog> im trying to understand how to store the Scope as a list of named values reified into scope; https://gist.github.com/fog-hs/c5ce3555142cac6e1d3b7e7c63c47e8e
15:25:48 <koz_> merijn: What exactly gets lifted? I have access to f :: c -> FooM a d, and of course bind itself, but I don't see how lifting helps me here.
15:26:42 <merijn> koz_: Given "FooM a b" and "b -> FooM a c" you need to actually *get* a 'b' to run the function
15:27:03 <siraben> I now have a list of IO actions, how do I perform the IO actions in the list in parallel?
15:27:15 <merijn> koz_: The only way to get a 'b' from FooM is to get it from "ReaderT Bar (Except (Baz a)) b"
15:27:20 <siraben> forkIO?
15:27:26 <koz_> merijn: OK, that makes sense.
15:27:48 <merijn> koz_: Since ReaderT and Except are monad instances, you can use their corresponding ">>=", but then you don't have the right return type
15:28:08 <merijn> koz_: Since >>= for ReaderT produces a ReaderT, not a FooM
15:28:08 <koz_> Yeah, because I get [big monadic stack] FooM [etc]?
15:28:25 <merijn> siraben: How large? (i.e. do you need to handle rate limiting)
15:28:53 <siraben> merijn:  336 actions, each one a separate API request
15:29:02 <siraben> Let's say no rate limiting?
15:29:18 <siraben> Is there a built in way to do this or do I need to use a library?
15:29:31 <merijn> siraben: There's the async library, which you probably wanna use instead of forkIO (since it handles stuff like exceptions, waiting, interrupting, etc.)
15:30:24 <merijn> siraben: If you start having thousands of actions and need rate limiting, there was a worker-pool based version of async somewhere and I implemented my own library for use with Foldable and conduits
15:31:23 <solonarv> FooM (ReaderT a) >>= k = FooM . ReaderT $ \bar -> case (runIdentity . runExceptT) (a bar) of Left err -> ExceptT (Identity (Left err)); Right x -> case k x of FooM (ReaderT kf) -> kf bar
15:31:27 <solonarv> I *think* that works
15:31:34 <solonarv> but really, you should just GND it ;)
15:31:39 <merijn> solonarv: Man, spoilers... :p
15:31:50 <solonarv> bah, it's probably wrong somewhere anyway
15:31:55 <koz_> solonarv: Oh, so basically I have to 'take apart' every 'runWhateverT' result, then put them all back together again?
15:31:59 <koz_> ... yeah, I'm GNDing.
15:32:00 <solonarv> koz_: yep
15:32:01 <merijn> koz_: Yes
15:32:05 <koz_> This is work for a compiler, not a human being.
15:32:32 <merijn> koz_: Well, yes, that's why GND was my initial reaction ;)
15:32:39 <koz_> merijn: I can see why.
15:32:54 <merijn> It's boring, error prone, and painful
15:33:18 <solonarv> if you work with people who are scared of GHC extensions, you can also write (>>=) = coerce ((>>=) :: <type of (>>=) @(ReaderT Bar (Except (Baz a))) )
15:33:28 <solonarv> which is more or less what GND generates anyway
15:33:48 <koz_> solonarv: Oh wait, that's a thing?
15:33:51 <koz_> TIL.
15:33:57 <merijn> solonarv: And then I will laugh when someone uses ScopedTypeVariables to fix some base documentation and your code breaks
15:34:20 <merijn> Repeat after me: "Friends don't let friends use -XTypeApplications for serious things"
15:34:23 <solonarv> merijn: ah, but this is a hypothetical outfit of silly people!
15:34:41 <merijn> solonarv: All called Iceland_Jack? >.>
15:34:41 <solonarv> also, I deliberately wrote <type of ...> instead of an actual type application
15:35:08 <solonarv> the idea is that you write (>>=) = coerce ((>>=) :: BIG_UGLY_THING_HERE)
15:35:26 <solonarv> but really you should just use GND
15:35:43 <solonarv> it's entirely harmless, especially when you add DerivingStrategies to specify explicitly what's happening
15:35:58 <koz_> solonarv, merijn: Points well taken, thanks!
15:40:45 <fog> the page here; http://gloss.ouroborus.net/
15:40:49 <fog> says to use cabal
15:40:52 <fog> but thats v1
15:41:10 <fog> and running; cabal install gloss-examples
15:41:19 <fog> gives many conflicting packages
15:43:20 <fog84> if i write; stack install gloss-examples
15:43:40 <fog84> it seems to download all the packages that exist globally from cabal v1-install
15:43:56 <maerwald> :D
15:43:59 <fog84> like, it ignores there alrady existing to avoid conflicts
15:44:21 <fog84> but then, it wouldnt end up globally visible?
15:44:32 <fog84> so how do i use this installation in a project?
15:44:43 <sclv> stack is sandboxes
15:44:54 <fog84> but i didnt do stack init
15:45:00 <sclv> You can only use its stuff in another stack project
15:45:09 <sclv> Stack install just builds the exes
15:45:19 <sclv> Thereâ€™s no way to use the libs
15:45:27 <fog84> oh right, so its visible to anything defined with stack init
15:45:45 <fog84> ?
15:45:49 <maerwald> if the stackage/ghc version match
15:46:09 <fog84> ah, so i can reference the respolver that it mentions at the top of the stack install
15:46:28 <fog84> Downloaded lts-14.1 build plan.
15:46:46 <fog84> is there a way to do this as a call to stack init?
15:48:59 <fog84> oh right there is just a --resolver flag
15:50:30 <fog84> is that the same as what install v2 does?
15:50:35 <fog84> cabal v2-install
15:50:47 <maerwald> it doesn't have resolvers, but also shares installed packages
15:51:11 <fog84> but how does it avoid the package conflicts then?
15:51:33 <fog84> i thought it did away with global installs...
15:52:34 <sm> what was the question again...
15:53:02 <fog84> how does it "share installed packages" like stack that installs to a specific resolver
15:53:28 <fog84> if its different to v1 by the fact that it does not install globally
15:53:36 <fog84> or if im mistaken about this
15:54:27 <sm> both stack and cabal-v2 install most packages somewhere under ~ and reuse them across projects whenever possible
15:55:05 <siraben> Why is it a good idea to make Text fields strict for use with aeson?
15:55:05 <siraben> Or in general?
15:55:59 <fog> cabal v2-install gloss-examples
15:56:04 <fog> complains the same as v1
15:56:08 <fog> about conflicts
15:56:26 <fog> i could do --force-reinstalls, or --allow-new
15:56:33 <fog> but i guess these are essentially unsafe
16:01:48 <MarcelineVQ> "<fog84> is there a way to do this as a call to stack init?" Do what?
16:04:07 <fog> MarcelineVQ: to specify the respover to make use of an existing installation
16:04:15 <fog> resolver*
16:04:30 <MarcelineVQ> all stack init does is chooses a resolver that matches your cabal file's dependencies, if it's able to, and sticks that in a stack.yaml   if you want to 'init' with lts-14.1 you just make a stack.yaml and put  resolver: lts-14.1   in it
16:05:13 <fog> oh ok
16:05:28 <fog> so i need to make a cabal.project and a stack yaml?
16:06:30 <MarcelineVQ> no when I say cabal fileâ€‹ I mean  foolib.cabal   not cabal.project   cabal.project and stack.yaml are unrelated to each other
16:07:03 <fog> oh right yeah, the project just orchestrates several .cabal files
16:07:26 <MarcelineVQ> they do perform related roles but aren't related to each other, but to their respective build system
16:07:36 <fog> so can i do cabal init to setup a template, then just add the version found for a particular resolver
16:07:54 <fog> ie; gloss-1.13.0.1
16:08:24 <fog> i normally just dont use cabal files and .hs files with imports are resolved globally via v1 installs
16:08:50 <MarcelineVQ> what are you trying to do with gloss?
16:08:58 <maerwald> fog: if you just want to play around in ghci with gloss, you don't need to set up a project
16:09:24 <fog> just install it!
16:09:41 <fog> an old project was broken by a recent update
16:13:03 <maerwald> in haskell, you don't just simply install a library! :P
16:13:03 <MarcelineVQ> At this point you'd want to find a modern tutorial on using cabal files. 'installing' a package for a project isn't the concept of modern stack and cabal-install, you're intended to specify dependencies in your project's cabal file and let the tool get them for you.
16:13:23 <maerwald> v1 sandboxes still work fine
16:13:37 <maerwald> I encourage their use
16:13:41 <maerwald> they are more robust
16:15:54 <maerwald> And damage is nicely contained, its easy to start over. While with a broken store, you lost all control to the underlying implementation complexity.
16:16:19 <sm> fog: did you share the output of your failing install ?
16:16:31 <MarcelineVQ> he's dc'd again for a bit
16:16:38 <sm> ack.. thanks
16:17:02 <maerwald> except, tools like hie and ghcide probably will never work with cabal sandboxes again I guess
16:17:40 <sm> maerwald: recommending v1 sandboxes at this point seems really regressive :) Aren't things are complicated enough..
16:18:01 <maerwald> sm: yes, v2 and stack are both complicated :)
16:18:02 <MarcelineVQ> maerwald: fwiw based on the questions that have come up they're not so hot for v2 just yet either, though I'd have to check the logs to see why exactly, something about cradle files
16:18:23 <sm> pity the poor new haskellers :(
16:18:31 <maerwald> sandboxes work fine with far less bugs, but people wanted the cool new stuff, because of build times
16:18:34 <MarcelineVQ> I never did have any trouble with sandboxes, looking back, once I understood a little about how things worked
16:18:50 <sm> you had them filling up your disk, for one
16:19:05 <maerwald> yes, the number of times I had to erase my entire store in the last couple of months is increasing
16:19:19 <maerwald> and then all my binaries are broken/gone
16:19:49 <MarcelineVQ> is the store so flat? you only need to delete certain dirs to reset many stack problems
16:20:08 <maerwald> all the workarounds didn't work
16:20:10 <sm> maerwald: is talking about cabal
16:20:14 <sm> I think
16:20:40 <MarcelineVQ> Ye and I'm relating it to stack :> I've little experience with new cabal so far, though a bit more each day
16:20:55 <maerwald> https://github.com/haskell/cabal/issues/6483
16:21:04 <maerwald> things like that make me want to go back to sandboxes :)
16:21:04 <MarcelineVQ> And every project I dl on git that has a package.yaml and no cabal file is rustling my jimmyjams
16:21:06 <zeta_0> i am trying to setup ihaskell in the atom text editor but i am confused with the language mapping, so what is the `kernel name` and what is the `grammar name` ?
16:21:09 <sm> cabal stores binaries separately just like stack.. no need to delete those
16:21:26 <sm> ..except they do take up surprising space too
16:21:41 <zeta_0> i am guessing the kernel name is ihaskell and the grammar name is haskell, correct?
16:22:02 <maerwald> sm: ah well, they're probably broken, missing files (e.g. be careful how you compile pandoc, e.g. the data files)
16:22:15 <maerwald> binaries are not relocatable, generally
16:22:20 <sm> ugh, I don't like such binaries
16:22:22 <sm> mine are
16:22:30 <maerwald> when you delete your store, you have no idea what's broken
16:23:03 <sm> I've never had a problem from blowing away libs and ghcs, but I typically don't delete binaries
16:23:07 <maerwald> some things even hardcode your ghc path at build time, like doctests
16:23:28 <maerwald> so when I switched from ghcup GHC to system-wide ghc, doctest was unrecoverably broken :P
16:24:57 <maerwald> sandboxes are just superior for languages that have poor dynamic linking capabilities
16:26:20 <sm> zeta_0: no idea, don't they have install docs ?
16:27:53 <MarcelineVQ> sm: I'm not even aware of an ihaskell plugin for atom.  zeta_0: are you referring to setting up hydrogen for atom in order to use ihaskell? or something else?
16:29:08 <sm> wait, wait I know. First, install NixOS...
16:29:30 <wildtrees> I think he already did :) 
16:29:51 <sm> ?! how can it not be working
16:29:51 <lambdabot> Maybe you meant: v @ ? .
16:30:23 <wildtrees> ?list
16:30:23 <lambdabot> What module?  Try @listmodules for some ideas.
16:31:05 <zeta_0> i am using nixos, i got ihaskell working in emacs but was unable to get the auto-completion working, so i decided to try to setup ihaskell in atom instead
16:31:34 <maerwald> nixos, emacs, auto-completion in haskell??? sounds like maximum amount of pain ;P
16:32:02 <maerwald> zeta_0: IMO, vscode currently has the best haskell support
16:32:07 <wildtrees> at least it's not tab completion for python! 
16:32:09 <zeta_0> hydrogen's instructions say that it should work with any kernel
16:32:52 <zeta_0> maerwald: that looks good but i am trying to stay far away from anything proprietary
16:33:02 <maerwald> vscode is open source
16:33:26 <zeta_0> maerwald: i thought some of the plugins are not free and closed source?
16:33:30 <Axman6> it's one of the largest open source projects on github
16:33:47 <Axman6> as far as I've seen all the plugins come from github
16:33:53 <maerwald> Axman6: many people think "Microsoft" and think "proprietary"... especially funny now that github...
16:34:14 <Axman6> yeah - the new Microsoft is a very different beast
16:34:34 <maerwald> it took them a few decades to understand they have no idea about software, but yeah, they are trying to catch up
16:34:49 <zeta_0> i still don't trust microsoft, anyways, i don't want to go off topic, i am trying to get something done
16:35:03 <maerwald> don't have to trust them, read the code :)
16:35:04 <Axman6> and doing a great job at it, I'd rather use anything from Microsoft over Google these days
16:35:15 <maerwald> https://github.com/microsoft/vscode
16:36:57 <zeta_0> ok, if i can't get ihaskell to work in atom, i'll consider giving vscode a try
16:38:03 <Axman6> I'm surprised MS haven't killed Atom yet, VS Code is much more actively maintained, and just better over all in my experience. has none of the performance issues Atom had when I used it
16:38:12 <maerwald> but you gotta love the input lag and the memory leakage in vscode...
16:39:01 <Axman6> all the memory leakage I get in VS Code is from hie and TabNine, the editor itself seems to do fine
16:39:14 <maerwald> I use vscode for typescript a lot and it leaks heavily
16:39:30 <Axman6> ah I guess that's mostly built in
16:40:03 <maerwald> but when it crashes, I just tell it to restart
16:40:04 <maerwald> lol
16:40:31 <maerwald> also, must have when using haskell or vscode: https://github.com/rfjakob/earlyoom
16:42:14 <Axman6> ha
16:42:16 <maerwald> even with swap off, the kernel oom can freeze your machine for minutes after ghc decided to eat all your ram
16:42:43 <zeta_0> my problem in emacs is that i already have ghcide setup as an ide for haskell so when i try to setup emac's haskell-mode for ihaskell it does not work
16:43:26 <zeta_0> then ghc-mod gives me nightmares
16:48:55 <maerwald> ghc-mod used to work better than all the IDE tools combined we have to day. But is broke too quickly with new GHCs
17:11:28 <MarcelineVQ> maerwald: ye, you'd need to revbuild it every version, I used to write  stack build ghc-mod  in every project so that a locally compatable version was in scope for each
17:12:32 <MarcelineVQ> eventually ghcid + writing a hole or giving a wrong ::   was less work for asking the type of some particular scope or expression
17:19:41 <zeta_0> MarcelineVQ: ya, with ghcid/ghcide i am good to go for my haskell projects, as for ihaskell i still haven't figured out how to get the auto-completion working, and ghc-mod is being removed now
17:20:35 <zeta_0> MarcelineVQ: i like ihaskell for learning and experimenting because it is very interactive
17:20:54 * hackage skylighting-core 0.8.3.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.3.1 (JohnMacFarlane)
17:21:32 <MarcelineVQ> I just keep a ghci running next to ghcid but whatever works for you :>
17:21:54 * hackage skylighting 0.8.3.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.3.1 (JohnMacFarlane)
17:25:44 <zeta_0> MarcelineVQ: so you open up ghcid in one terminal then open ghci in another terminal, is this what you mean?
17:25:57 <fresheyeball> is Beam still the best of the haskell sql libraries?
17:26:52 <MarcelineVQ> yes
17:26:59 <MarcelineVQ> zeta_0: yes
17:29:48 <zeta_0> MarcelineVQ: i thought that a haskell project needs to be setup first(like cabal) with a Main module and main function is order for ghcid to work?
17:30:28 <zeta_0> MarcelineVQ: so how do i setup ghcid for ghci repl with haskell?
17:31:10 <zeta_0> MarcelineVQ: i am still new to ghcid, so there are still some things that confuse me
17:31:36 <Axman6> fresheyeball: depends on what you want. Beam is very cool, but not necessarilly the simplest to use. I like the simplicity and speed of hasql
17:31:53 <MarcelineVQ> I mean while working on a project I have these two things open. Do you use cabal-install or stack?
17:32:30 <fresheyeball> Axman6: I am working on a crud example app for my UI library
17:32:37 <fresheyeball> hasql sounds good
17:32:44 <zeta_0> MarcelineVQ: i use cabal-install
17:33:16 <MarcelineVQ> I find it's best to type  ghcid -c "cabal repl"  to run it in a project when using cabal
17:34:27 <zeta_0> MarcelineVQ: ok, thanks for the tip
17:38:24 <MarcelineVQ> ye, weirdly it says  ghcid -c "cabal repl"  is the default behavior, but it's not as far as I can tell since it'l behave differently if you type that yourself vs just typing ghcid
17:40:02 <MarcelineVQ> "<zeta_0> MarcelineVQ: i thought that a haskell project needs to be setup first(like cabal) with a Main module and main function is order for ghcid to work?"  You don't need a project, but it's a good idea, a person can write   ghcid -c "ghci foo.hs"  if they just want to work on a standalone file though like they would without cabal or stack
17:41:08 <zeta_0> MarcelineVQ: ok, that makes sense, good to know
17:55:35 <sm> MarcelineVQ: that still seems to be the case for ghcide (have to rebuild for each ghc version)
17:56:24 * hackage skylighting-core 0.8.3.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.3.2 (JohnMacFarlane)
17:56:43 <MarcelineVQ> ye, one of the hassles of depending on ghc as a lib
17:57:24 * hackage skylighting 0.8.3.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.3.2 (JohnMacFarlane)
18:20:10 <zeta_0> MarcelineVQ: i am confused about the language mapping i need to setup for ihaskell in atom, so i am guessing the kernel name is haskell and the language grammar is haskell as well?
18:31:52 <fresheyeball> can I have a conditional executable in cabal?
18:38:58 <ezzieyguywuf> "Since arrays are immutable, modifying even one element requires copying the entire array. This quickly becomes prohibitively expensive on arrays of even modest size...Don't Lose Hope. t is in fact possible to modify an array efficiently in Haskell, using the ST monad." Does this still hold true?
18:39:09 <koz_> ezzieyguywuf: Why wouldn't it?
18:39:12 <dmwit> fresheyeball: I don't think so. But you can conditionally set one to be unbuildable.
18:39:22 <ezzieyguywuf> is the "store things in an array and modify as needed" idiom simply not needed due to other features in haskell?
18:39:34 <koz_> ezzieyguywuf: Depends what you're trying to do.
18:39:40 <koz_> Sometimes, this is _exactly_ what you need.
18:39:45 <ezzieyguywuf> koz_: maybe things have changed/improved since the book was last edited
18:40:00 <koz_> ezzieyguywuf: I don't think reality editing has been invented.
18:40:08 <infinisil> Arrays do have their uses
18:40:11 <ezzieyguywuf> "reality editing"?
18:40:12 <fresheyeball> dmwit: that seems to work
18:40:14 <ezzieyguywuf> ah, you're trying to be glib
18:40:14 <fresheyeball> let me try that
18:40:18 <koz_> If you're asking 'is there a nicer interface than raw Arrays in ST?', then you can look at Vector.
18:40:22 <koz_> s/Vector/vector/.
18:40:34 <koz_> I guess hashtable kinda applies here as well, since it uses similar techniques.
18:40:35 <infinisil> Aren't vectors just raw arrays as well?
18:40:42 <koz_> infinisil: Underneath, yes.
18:41:02 <koz_> There's the ability to use them outside ST (where copying is kept to a minimum with some kind of streaming magic).
18:41:08 <infinisil> I mean, a Vector in the vector package is still an "array"
18:41:14 <dmwit> (It is also possible to modify an array efficiently in Haskell using IO.)
18:42:19 <koz_> infinisil: Sure. I shouldn't assume specificity of statements, and inconsistently at that.
18:42:27 <koz_> But yeah, if you want mutable state, you want ST or IO.
18:42:47 <koz_> (at least in Haskell as done by GHC, perhaps in general)
18:43:18 <infinisil> Or wait for linear types where you can have mutable arrays without ST or IO!
18:43:45 <infinisil> I wonder if Idris 2 already has an implementation of that
18:44:23 <koz_> infinisil: I dunno if Idris is using the same implementation of linear types as the one proposed for GHC by That Paper Whose Name I Can't Recall. Idris 1 had uniqueness types.
18:44:43 <koz_> You could ask Edwin about Idris 2 I guess.
18:45:01 <koz_> But yeah, linear types are something I'm looking forward to.
18:45:07 <infinisil> koz_: I think it's https://bentnib.org/quantitative-type-theory.html
18:45:20 <infinisil> (not an expert, but that's what's mentioned in idris2's readme)
18:45:49 <koz_> infinisil: In that case, I'm pretty sure it's different to the one proposed for GHC. Though I could be wrong, since I'm about as far from an expert as one gets.
18:46:20 <infinisil> I wouldn't be surprised, GHC isn't really made for this kind of thing, it's probably rather bolted-on
18:46:41 <infinisil> Whereas Idris 2 is designed to have linear types from the start
18:46:45 <infinisil> s/GHC/Haskell
18:47:06 <koz_> infinisil: Said Paper I Keep Mentioning even makes a big point of how they wanna avoid breaking existing things.
18:47:29 <infinisil> Yeah
18:47:37 <fresheyeball> dmwit++
18:47:43 <fresheyeball> that works great
18:48:01 <infinisil> For reference: https://github.com/edwinb/Idris2
19:02:24 <fresheyeball> can I serve a SPA with servant?
19:02:49 <Axman6> of course
19:03:25 <Axman6> but as far as I understand how SPAs work, there';s nothing specific in Servant to help with it - most of the hard work in a SPA is on the front end right?
19:04:31 <fresheyeball> Axman6: well the trouble is having a catch all route
19:04:35 <fresheyeball> and serving index.html there
19:06:08 <Axman6> the latter should be easy, and the former can be handled by having type AIP = AIP' :<|> Raw and using RAW to do whatever you need to do with a catch all - there may be better optiont han Raw these days
19:07:12 <fresheyeball> Axman6: I tried serveDirectoryWebApp
19:07:23 <fresheyeball> you have to fully qualify the file name
19:15:54 * hackage managed 1.0.7 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.7 (GabrielGonzalez)
19:39:54 * hackage vformat-aeson 0.1.0.1 - Extend vformat to Aeson datatypes  https://hackage.haskell.org/package/vformat-aeson-0.1.0.1 (gqk007)
19:51:24 * hackage monoid-subclasses 1.0.1 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-1.0.1 (MarioBlazevic)
19:58:49 <dmj`> fresheyeball: yes
20:03:53 * hackage network-byte-order 0.1.2.1 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.2.1 (KazuYamamoto)
20:13:53 <amalloy> anyone know what's up with https://www.reddit.com/r/dcss/comments/es3bse? at a glance it seems like _fixup_library_spells is doing the right thing, but evidently we get the wrong result
20:13:58 <amalloy> oops, wrong channel
20:19:23 * hackage diagrams-builder 0.8.0.5 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.8.0.5 (BrentYorgey)
20:39:28 <habbah> Axman6: what are a few things which hasql-th does not handle? I'm clueless
20:47:58 <Axman6> there's no checking that the queries that you've written match the schema that the database you're connecting to, whereas persistent will manage migrations and stuff at run timefor you. it's not a big deal, but it is still slightly less safe than one might hope
21:09:24 * hackage musicScroll 0.1.1.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.1.1.0 (RubenAstudillo)
22:15:24 * hackage wide-word 0.1.1.0 - Data types for large but fixed width signed and unsigned integers  https://hackage.haskell.org/package/wide-word-0.1.1.0 (ErikDeCastroLopo)
22:16:24 * hackage titan 1.0.2 - Testing Infrastructure for Temporal AbstractioNs - GUI to debug temporal programs  https://hackage.haskell.org/package/titan-1.0.2 (keera_studios_ci)
22:22:02 <fragamus> hi I would like to find a haskell library that can render graphics to a PDF
22:22:45 <infinisil> fragamus: I suggest going through svg
22:22:54 <fragamus> ok
22:23:15 <fragamus> svg is a libary, no?
22:23:36 <iqubic> No. SVG is a file format. Short for Scalable Vector Graphics.
22:24:04 <infinisil> fragamus: E.g. diagrams can render svg's: https://hackage.haskell.org/package/diagrams
22:24:24 * hackage hasql 1.4.1 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.1 (NikitaVolkov)
22:24:41 <infinisil> And apparently the diagram-cairo backend can render PDFs directly
22:27:34 <MarcelineVQ> fragamus: what graphics did you have in mind?
23:47:53 * hackage envy-extensible 0.1.0.0 - Provides FromEnv in envy instance for Record of extensible.  https://hackage.haskell.org/package/envy-extensible-0.1.0.0 (igrep)
