00:00:16 <m1cl> I want to throw an error in case someone puts an empty list into the function
00:00:29 <m1cl> myFunc [] = error "no, thats wrong!"
00:08:56 <[exa]> m1cl: I'd suggest finding a way to prevent throwing errors (it's ugly)
00:09:33 <[exa]> m1cl: e.g. only accept a type that technically can not be empty, so that the typesystem prevents this kind of error
00:15:27 <m1cl> okay thanks
00:16:35 <[exa]> m1cl: btw what would the function do? (perhaps there's a bit more specific advice)
00:17:01 <[exa]> m1cl: also, the "default" non-empty list is this: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty
00:18:09 <m1cl> very basic, I just wanna return the last item of a list. the last function prelude already has this execption handling, but I wanna do it myself. I m doing the 99 problems 
00:19:24 * hackage ghc-tcplugins-extra 0.3.2 - Utilities for writing GHC type-checker plugins  https://hackage.haskell.org/package/ghc-tcplugins-extra-0.3.2 (ChristiaanBaaij)
00:26:48 <[exa]> m1cl: oh so. Then possibly just `error "empty list"` is correct. If you completely omit the case for empty list it will kindof work too (you'll get a pattern matching failure, which it indeed is)
00:36:27 <erikd> dmwit: yes, the constraints version was the problem. thanks!
00:43:46 <erikd> damn, wrong compiler. 'constraints < 0.11' doesn't fix that means the problem must be with the singletons version, but the singletons version is tied to the ghc version
01:34:12 <merijn> hmm, so anyone know what the best sort from vector-algorithms is for mostly sorted data/fairly short arrays?
01:36:24 <merijn> i.e., ~100 elements comparing via Int64, because there don't seem to be any real performance numbers hints
01:42:59 <shachaf> If you know your use case you can probably make up your mind better than the maintainer of a generic library anyway.
01:43:46 <merijn> shachaf: I mean that vector-algorithms has like 8 sorts and very little indication which is suited for when
01:45:25 <shachaf> Sure, but they're standard algorithms.
01:45:49 <shachaf> .Tim is probably a reasonable default from what I hear?
01:46:03 <shachaf> Depending on what "mostly sorted" means insertion sort might be pretty good. 
01:46:24 * hackage ghc-typelits-extra 0.3.2 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.3.2 (ChristiaanBaaij)
01:46:26 <merijn> That one says it's actually fairly expensive for primitive types, so Tim is the only one I was pretty sure I didn't want :p
01:48:00 <shachaf> Oh, it's possible. It's adaptive, though, which might be what you want.
01:48:06 <merijn> shachaf: Data seems to be 2-4 sorted subsequences, anyway else I'll just toss a coin
01:49:19 <shachaf> Subsequences meaning interleaved or separate?
01:50:17 <merijn> As in dense chunks (i.e. 0-N, N+1-M, M+1-..)
01:52:02 <shachaf> That sounds like the use case that .Tim is designed for, as I understand it, though maybe it's not worth the overhead anyway, I don't know.
01:52:18 <shachaf> You can just try them all if you particularly care.
01:52:58 <shachaf> Haskell code isn't going to be optimal for these things anyway where it really matters.
01:53:36 <merijn> shachaf: Sure, but when you need to sort several million short arrays it pays to ask around a little bit
01:57:55 <shachaf> Oh, it's a one-off thing?
01:58:08 <shachaf> I doubt it matters much.
01:58:17 <merijn> shachaf: No, it's a repeated thing
02:00:54 * hackage matrix-market-attoparsec 0.1.1.0 - Parsing and serialization functions for the NIST Matrix Market format  https://hackage.haskell.org/package/matrix-market-attoparsec-0.1.1.0 (ocramz)
02:09:16 <Nolrai> :pl \ (a, b) -> (f a, f b)
02:11:56 <koz_> :t bimap
02:11:56 <Nolrai> @pl g f (a, b) = (f a, f b)
02:11:56 <lambdabot> g = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:11:57 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
02:12:05 <koz_> No wait.
02:12:14 <merijn> :t join bimap
02:12:15 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
02:13:06 <olligobber> that's an interesting use of monadic join...
02:13:14 <koz_> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html#v:unzip
02:13:16 <merijn> olligobber: "Magic!" ;)
02:13:37 <Nolrai> Its just the (r->) instance, right?
02:13:42 <olligobber> yeah
02:14:15 <madnight> :t dimap
02:14:18 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
02:14:26 <madnight> :t join dimap
02:14:27 <koz_> dimap is different.
02:14:28 <lambdabot> Profunctor p => (c -> d) -> p d c -> p c d
02:14:50 <Nolrai> Huh.
02:15:36 <Rembane> :t \f -> (f *** f)
02:15:38 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
02:15:59 <olligobber> I guess (->) is a Profunctor
02:16:16 <olligobber> based on the type of dimap
02:17:06 <merijn> (->) is a Profunctor, yeah
02:17:35 <merijn> But it's not related to Nolrai's question
02:17:47 <Nolrai> Its kind of "the" Profunctor, in that being (->) alike is the motivation for the existence of profunctors.
02:18:22 <Nolrai> Or to put it a better way, Profunctors are a generalization of (->).
02:18:42 <olligobber> If (,) is a Bifunctor, then wouldn't `join bimap f' be the anser?
02:19:21 <Nolrai> It is, though I was hoping there was shorter name of it.
02:19:27 <Nolrai> * for it
02:19:41 <olligobber> `bimap f f' is 3 characters shorter
02:20:05 <Nolrai> Oh sure but the function I am pulling out is not actually named f.
02:20:31 <olligobber> @pl \f -> bimap f f
02:20:31 <lambdabot> join bimap
02:20:34 <olligobber> lol
02:20:52 <Nolrai> I mean its easy enough to define "onBoth f = (f a, f b)"
02:21:38 <Nolrai> I just don't like defineing basic pair manipulation in an unrelated library.
02:22:01 <olligobber> use a vector of length 2 instead of a pair and fmap?
02:23:04 <Nolrai> Thats... a slightly silly idea, but I might use it.
02:25:50 <merijn> Nolrai: You can just define a shorter name? i.e. "foo = join bimap" <- done
02:26:57 <Nolrai> Yes, thats probablly what I will do, although using V2 is tempting, importing Linear just for it is a bad idea.
02:27:12 <olligobber> `newtype MyPair a = MyPair (a,a); instance Functor MyPair where fmap f (MyPair (x,y)) = MyPair (f x, f y)'
02:30:18 <olligobber> or `type MyPair = Product Identity Identity'
02:49:23 * hackage haskell-stack-trace-plugin 0.1.1.1 - haskell-stack-trace-plugin  https://hackage.haskell.org/package/haskell-stack-trace-plugin-0.1.1.1 (waddlaw)
03:16:59 <maerwald> https://github.com/haskell/tar/blob/master/Codec/Archive/Tar/Types.hs#L306 ouch
03:17:19 <maerwald> guess I'll have to do another fork
03:17:55 <maerwald> char8 is all over the place
03:19:05 <[exa]> why'd that be wrong?
03:20:02 <maerwald> you mean why is converting filepaths with Char8 wrong?
03:20:19 <merijn> It'd be shorter to list what's right :p
03:20:44 <maerwald> merijn: the types :D
03:25:33 <maerwald> I guess they also did that in order to not break things like "The maximum length of a file name is limited to 99 characters." (tar manual)
03:25:51 <maerwald> so truncate, then get the length... err
03:34:07 <merijn> Well, tar itself may specify something about the format
03:40:03 <maerwald> yes, I suspect it may only support ascii
03:40:20 <maerwald> but even, then, silently truncating my filepaths? :>
03:47:45 <maerwald> yep, it breaks it. Behaves different than the C tar
04:02:47 <maerwald> https://github.com/haskell/tar/issues/6 unfixed since 4 years :o
04:05:22 <merijn> maerwald: Looks like tar officially disallows non-ASCII
04:05:40 <maerwald> but the C version packs it just fine
04:05:45 <merijn> So, arguably the C tar that generates tar files with unicode files is broken (which, of course, isn't particularly fine)
04:06:19 <maerwald> I couldn't find where tar says that, it only says things about headers afair
04:08:06 <maerwald> ah, the filename is in the struct posix_header?
04:08:45 <merijn> Posix apparently defines an extension which lets you specify an encoding
04:08:53 <maerwald> "The name, linkname, magic, uname, and gname are null-terminated character strings.  All other fields are zero-filled octal numbers in ASCII."
04:09:01 <maerwald> that sounds like it allows bytes
04:09:18 <merijn> So pax format tar files could handle this correctly
04:09:37 <merijn> But then someone would have to implement the pax format for the tar package
04:09:51 <merijn> And that doesn't help decoding "wrong" files from other implementations
04:10:13 <merijn> maerwald: To be fair, there's no real solution to the decoding problem other than "return ByteString for filenames"
04:10:18 <maerwald> yes 
04:10:32 <maerwald> people shouldn't decode filepaths, unless they have to and then they're in trouble anyway
04:10:45 <merijn> maerwald: Even that comment isn't portable, sadly
04:10:55 <merijn> maerwald: Because it only applies to Linux/BSD
04:11:09 <merijn> maerwald: On macOS and Windows you *should* decode filepaths
04:11:23 <maerwald> I always ignore windows, true.
04:11:23 <merijn> Since they are explicitly unicode
04:11:56 <merijn> And tbh, I think Windows and macOS got it right and linux/BSD fucked up
04:13:33 <ggole> Normalising file names in the kernel doesn't sound like fun, particularly when the normalisation rules change over time
04:14:43 <merijn> ggole: Sure, but the alternative is "you can never name files with unicode paths, because there's no way to know how to display them"
04:14:54 <merijn> And normal people want to be able to name files in their native languge
04:15:00 <ggole> Taking one volume and mounting it on a newer/older machine where a filename is interpreted subtly differently sounds like a problem I'd rather not have
04:15:19 <ggole> Yeah, I don't think there's any perfect solution here
04:15:24 <merijn> ggole: If the encoding is specified it's fine
04:16:04 <maerwald> merijn: I was under the impression macOS is POSIX and treats filepaths as bytestrings too, the AbstractFilePath proposal and both the rust stdlib seem to assume that
04:16:46 <merijn> maerwald: No, there's is a posix interface on macOS, but HFS stores unicode and all the macOS frameworks use that approach
04:16:55 <merijn> So I guess macOS is even more confusing atm >.>
04:17:03 <maerwald> so do things break for mac users when I use bytestring based filepaths?
04:17:14 <merijn> maerwald: "Possibly"?
04:17:28 <maerwald> awesome
04:18:06 <ggole> Hmm, I wonder what people do in practice
04:18:18 <ggole> Assume utf-8, perhaps
04:18:50 <ggole> (On Linux/BSD systems where there is no notion of encoding associated with paths, I mean.)
04:22:19 <merijn> use the locale
04:22:24 <maerwald> As long as the syscalls on macOS accept bytestring it should be fine
04:22:30 <merijn> Which is per user, so also wrong
04:51:51 <maerwald> this is what happens if you try to be cross-platform at all cost: you can't even write correct code for a single platform
05:00:31 <xenon-> is anyone using ginger? I'm trying to find a minimal, compilable example, but without much luck. there's a minimal template example on ginger's hackage page, but without the haskell source file that goes along with it
05:04:38 <merijn> xenon-: Presumably tdammers is using it ;)
05:34:06 <thblt> Is there a common place for hspec tests in an haskell source tree? In the module being tested, next to it, or in a different source folder (like tests/MyModTests.hs for src/MyMod.hs)?
05:38:20 <merijn> thblt: Usually a seperate directory, I'd say
05:38:49 <thblt> merijn: thanks, I'm going for test/ next to src/
05:43:32 <sm[m]> thblt: I like bottom of the same file
05:44:34 <sm[m]> https://www.reddit.com/r/haskell/comments/eljvl5/can_i_put_unit_test_files_alongside_my_source_code/
06:49:53 * hackage titan-record-yampa 1.0.0 - Testing Infrastructure for Temporal AbstractioNs - Yampa record-and-replay layer  https://hackage.haskell.org/package/titan-record-yampa-1.0.0 (keera_studios_ci)
06:52:53 * hackage titan-debug-yampa 1.0.0 - Testing Infrastructure for Temporal AbstractioNs - Interactive Yampa debugging layer.  https://hackage.haskell.org/package/titan-debug-yampa-1.0.0 (keera_studios_ci)
06:56:23 * hackage titan 1.0.0 - Testing Infrastructure for Temporal AbstractioNs - GUI to debug temporal programs  https://hackage.haskell.org/package/titan-1.0.0 (keera_studios_ci)
07:13:46 <merijn> Anyone know what the correct alternative to Conduit's bracketP is when my allocate is already a MonadResource Acquire?
07:14:13 <thblt> What's the point of the NoTraditionalRecordSyntax language extension?  Does it imply there's an alternative?
07:16:37 <merijn> thblt: No
07:17:04 <merijn> thblt: According to the issue tracker it was introduce 10 years ago, in preparation of potential changes in Haskell Prime that never happened
07:21:44 <merijn> Is it me or is Hackage slow?
07:26:22 <dmj`> merijn: it's you :P
07:26:55 <merijn> dmj`: It looks like the issue is the html source links
07:27:05 <merijn> Hackage itself seems fine, but those seem to completely lock up Chrome
07:27:11 <merijn> Can't even right click or select text
07:27:20 <thblt> merijn: thanks
07:27:31 <merijn> It's not even just Hackage, but also stackage
07:27:37 <dmj`> merijn: http://hackage.haskell.org/package/aeson-1.4.6.0/docs/src/Data.Aeson.html#eitherDecode
07:27:43 <dmj`> seems to load for me
07:28:00 <sicklork1n> ditto
07:28:10 <merijn> dmj`: hmm, that one does
07:28:27 <merijn> dmj`: But this one is unusable for me: https://hackage.haskell.org/package/conduit-1.3.1.2/docs/src/Data.Conduit.Internal.Conduit.html#bracketP
07:28:37 <merijn> Can't select text, can't search, even scrolling is slow
07:29:46 <merijn> Same for the stackage version
07:31:19 <dmj`> merijn: that is odd
07:32:19 <dmj`> it partially loads in chrome for me, yet curl will fetch it all
07:32:24 <sicklork1n> it's the sylesheets?
07:32:41 <sicklork1n> and an excessive DOM size 17k elements
07:32:44 <geekosaur> fascinaing. scrolling worked for me unti I scrolled back to yieldM, then stopped completely
07:33:30 <merijn> At least it's not just me >.>
07:33:56 <sicklork1n> lynx has troubles too
07:33:57 <geekosaur> and now it unfroze, after around a minute
07:37:26 <__monty__> That last url just works for me.
07:37:53 <__monty__> Ah, but chrome isn't webkit.
07:38:30 <dmj`> merijn: the bigger question is why are you using conduit :P
07:41:53 * hackage MonadRandom 0.5.1.2 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.5.1.2 (BrentYorgey)
07:44:21 <merijn> dmj`: Because everything uses conduit
07:44:34 <maerwald> how do you convert from EpochTime to POSIXTime?
07:46:32 <sicklork1n> realToFrac?
07:46:57 <sicklork1n> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/time-1.9.3/Data-Time-Clock-POSIX.html
07:47:57 <maerwald> no, that's from POSIXTime to EpochTime
07:48:20 <maerwald> err, I mixed it up^^
07:48:26 <maerwald> I want to go from POSIXTime to EpochTime
07:52:31 <sicklork1n> > let picoToDT a = quot (a + a 500000) 100000
07:52:33 <lambdabot>  <no location info>: error:
07:52:33 <lambdabot>      not an expression: ‘let picoToDT a = quot (a + a 500000) 100000’
07:52:39 <sicklork1n> humm.  not sure If I got that right.
07:52:48 <sicklork1n> a * 500000
07:53:15 <geekosaur> it'd be @let anyway
07:55:24 <dmj`> EpochTime (CTime (Int64 0))) .. NominalDiffTime (Pico (Fixed E12 (Integer 0))
07:56:59 <geekosaur> parens seem off there
08:11:23 * hackage purescript 0.13.6 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.6 (hdgarrood)
08:21:53 <dmj`> anybody know the status of Asterius
08:40:39 <sshine> dmj`, the last I saw was https://www.tweag.io/posts/2019-12-19-asterius-diagrams.html
08:45:07 <sshine> dmj`, do you mean to ask if something's happened since then?
08:45:32 <dmj`> sshine: yea, I just want to start using it.
09:02:02 <mpickering> Is there a combinator to monadically map over an `Event` in reflex? 
09:02:14 <mpickering> The monad is IO, I suppose I could fmap then join
09:04:04 <monochrom> fmap then join is >>= too :)
09:04:38 <solonarv> mpickering: yeah, there are a few
09:07:06 <solonarv> there is 'push :: (a -> PushM t (Maybe b)) -> Event t a -> Event t b'
09:07:30 <solonarv> and there is 'performEvent :: (a -> Performable m b) -> Event t a -> m (Event t b)'
09:11:53 <solonarv> mpickering: if you want to do some IO, then performEvent is probably the one you want
09:12:01 <mpickering> yeah it seems so
09:12:06 <mpickering> now just need to work out how to use it
09:12:43 <solonarv> add a 'MonadIO (Performable m)' constraint, and just liftIO your action
09:14:56 <mpickering> solonarv: Thanks
09:27:16 <mpickering> solonarv: That worked nicely, just a lot of surface area to find the right things
09:27:27 <solonarv> mpickering: yeah, reflex is *big*
09:27:45 <mpickering> Like I understand the concepts but discoverability is not easy
09:27:50 <mpickering> and much faster to ask someone who knows..
09:39:53 * hackage bearriver 0.13.1 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.13.1 (IvanPerez)
10:21:23 * hackage hpath-filepath 0.10.2 - ByteString based filepath manipulation  https://hackage.haskell.org/package/hpath-filepath-0.10.2 (maerwald)
10:22:24 * hackage hpath-io 0.11.0, hpath 0.10.2 (maerwald): https://qbin.io/wise-bent-xo21
10:27:24 * hackage matrix-market-attoparsec 0.1.1.1 - Parsing and serialization functions for the NIST Matrix Market format  https://hackage.haskell.org/package/matrix-market-attoparsec-0.1.1.1 (ocramz)
10:29:54 * hackage tar-bytestring 0.6.0.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.0.0 (maerwald)
11:19:54 <electricityZZZZ> is there any chance we will see a haskell to rust transpiler? i'd like to directly use some haskell libraries in my rust project...
11:21:42 <cocreature> electricityZZZZ: I doubt it but you can call into Haskell via the C FFI
11:22:11 <dmj`> shapr: ping
11:22:32 <dmj`> shapr: saw a link that says you use emacs with a kinesis advantage 2?
11:23:03 <dmj`> https://www.emacswiki.org/emacs/KinesisKeyboard
11:23:29 <merijn> electricityZZZZ: Haskell can FFI to C and so can Rust, so that'd work
11:28:11 <maerwald> sometimes I wonder why I fork half of the libs in the ecosystem
11:29:13 <maerwald> most of the problems are due to "cross platform" imo
11:31:54 * hackage wai-handler-launch 3.0.3.1 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.3.1 (MichaelSnoyman)
11:49:45 <merijn> maerwald: This is why I try and aggressively upstream my patches/fixes so I don't have to maintain forks :)
11:49:58 <maerwald> that works sometimes
11:50:24 <maerwald> but unlikely if my fork breaks a platform :P
11:50:39 <maerwald> it's easier to not support windows, generally
11:50:47 <merijn> maerwald: Can't you expose it as alternate modules and share code?
11:51:34 <maerwald> for the tar case, quite difficult, because I can't use the directory package
11:51:55 <maerwald> so it wasn't just replacing filepath, but also directory...
11:54:27 <reuben364> Hello, I'm trying to follow along edwardk's "Moore for Less" in https://www.schoolofhaskell.com/user/edwardk/moore/for-less, but I'm not sure how to get his definition of Nu to work. If I use it straight up, it quantifies over f in the definition of the Nu constructor, rather than using the type parameter f. Am I missing a language extension?
11:56:52 <jle`> reuben364: are you using exactly the definition in the article?
11:57:04 <jle`> data Nu f where Nu :: (s -> f s) -> s -> Nu f
11:57:28 <reuben364> yes.
11:57:32 <jle`> that should require -XGADTs
11:57:41 <reuben364> Even with that.
11:58:04 <jle`> what happens when you do :t Nu (:[]) True
11:58:59 <reuben364> Nu (:[]) True :: Nu []
11:59:03 <jle`> that sounds right, then
11:59:12 <jle`> the 'f' is being used as the type parameter
11:59:34 <jle`> you might also see Nu written in the more traditional non-GADT way, data Nu f = forall s. Nu (s -> f s) s
11:59:52 <jle`> but it looks like your definition works as expected
12:00:08 <jle`> it's using f as [] (list)
12:00:12 <reuben364> Then should this not typecheck: fixOfNu (Nu f s) = Fix (f s) ?
12:00:17 <solonarv> actually it should only require -XGADTSyntax
12:00:29 <solonarv> oh no, nevermind - 's' is existential
12:00:36 <jle`> reuben364: what is Fix ?
12:00:58 <reuben364> Oh, I'm an idiot.
12:00:59 <solonarv> presumably, 'newtype Fix f = Fix (f (Fix f))'
12:01:06 <reuben364> ye.
12:01:09 <jle`> solonarv: it was a question to lead reuben364 to the answer ;)
12:01:28 <solonarv> ah :)
12:04:01 <reuben364> I should read error messages more carefully. :)
12:04:58 <jle`> btw the typical home of these combinators is in recursion-schemes
12:05:00 <jle`> https://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html
12:54:54 * hackage ghc-lib-parser-ex 8.8.1.20191204 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.1.20191204 (shayne_fletcher)
13:17:24 * hackage ghc-lib-parser-ex 8.8.2 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.2 (shayne_fletcher)
13:28:41 <walterclements[m> hi
13:29:23 * walterclements[m sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/RldABdwmeUAVFXpjolYzdynR >
13:30:07 <walterclements[m> wait no
13:30:07 <walterclements[m> it doesn't
13:30:37 <walterclements[m> i measured it with putStrLn and wc command and it counted the newline
13:30:53 <walterclements[m> thanks
13:30:54 * hackage ghc-lib-parser-ex 0.20200102 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200102 (shayne_fletcher)
13:32:51 <jle`> same
13:39:06 <hseg> Hi. Am trying to debug why GHC expects to find a certain instance, is there some way to get a "backtrace" of the dependencies?
13:39:52 <hseg> (eg instance C T required instance D U to complete, pulling in instance E V etc)
13:41:06 <hseg> (only edit I made was to add a nullary typeclass to the context of a seemingly-unrelated instance declaration)
13:42:38 <jackdk> Not that I'm aware of. Does it help to know that instance resolution is strictly structural? So if I have something like `instance Foo a => Bar (f a)` and I try to use `[Int]` as a `Bar`, GHC will commit to the `Bar ([] a)` instance and go hunting for `Foo Int`?
13:43:11 <jackdk> I would go poking around the `-ddump-blah` options as well. Maybe there's something I don't know about
13:45:20 <hseg> Not really. I'm playing aroudn with edwardk's 'algebra' package, and adding Abelian r to the context of https://github.com/ekmett/algebra/blob/8adf75c00ac6d9b52c60ae3dd7278ba3f8cd691e/src/Numeric/Rng/Zero.hs#L54 caused GHC to complain about a missing Abelian r instance in https://github.com/ekmett/algebra/blob/8adf75c00ac6d9b52c60ae3dd7278ba3f8cd691e/src/Numeric/Rng/Zero.hs#L32
13:45:23 <dmj`> hseg: can you paste the code? a typeclass instance might call itself recursively, which can hit other instances that have constraints
13:46:33 <hseg> dmj`: see above -- only edit is adding Abelian r to the context of the RightModule Integer (ZeroRng r) instance
13:47:11 <hseg> However, the Group (ZeroRng r) instance doesn't use any (ZeroRng r) instances -- it only calls r instances
13:47:24 <dmj`> hseg: Abelian's class definition might have a super class
13:48:30 <dmj`> class Additive r => Abelian r
13:49:07 <hseg> And that stops there
13:49:26 <hseg> Besides, why would that cause the Group (ZeroRng r) instance to error?
13:51:11 <monochrom> jackdk: Yes strictly structure, like your example.
13:51:36 <monochrom> s/structure/structural/
14:04:39 <fendor> is there a project that provides a base library without any sync exceptions?
14:07:32 <hololeap> i'm using attoparsec and ApplicativeDo and i'd like to wrap the Parser in ExceptT (for catching errors that aren't from Parser). because (MonadError e m) has the constraint (Monad m), does that mean that using throwError inside a do block will prevent it from using ApplicativeDo for that block?
14:08:17 <hololeap> (sorry if that's a badly worded question)
14:09:35 <hseg> dmj`: Any ideas?
14:10:01 <jackdk> hololeap: my gut says yes, but this seems like something easily checked by going to a source file, trying it and seeing what happens.
14:11:24 <hololeap> i guess a bigger question is, does ApplcativeDo speed up applicative parsers compared to a monadic do block?
14:11:52 <MarcelineVQ> not as a rule
14:11:57 <dmj`> hseg: instance (Abelian (ZeroRng r), Group r) => RightModule Integer (ZeroRng r) where
14:13:00 <MarcelineVQ> depends on if the Applicative instance is written to be more effcicient for those operations
14:13:54 * hackage consul-haskell 0.5.0 - A consul client for Haskell  https://hackage.haskell.org/package/consul-haskell-0.5.0 (NiklasHambuechen)
14:14:41 <hololeap> i just remember reading somewhere that using the monadic interface for Parser slowed things down a lot. i started using ApplicativeDo in parsers so i could have the convenience without the slowdown
14:14:57 <hseg> dmj`: But why is that instance even relevant for the Group instance?
14:15:09 <hololeap> but maybe leaving everything the same and removing ApplicativeDo wouldn't affect the speed?
14:15:47 <MarcelineVQ> That's not something that can be answered/stated in general it depends on the Applicative and Monad in question
14:16:25 <hseg> dmj`: Indeed, it fixes nothing -- unsurprising since that instance declaration rewrites in one step to what I originally had
14:16:32 <erisco> I am of the mind that if speed is on the req sheet then use Happy
14:16:41 <hololeap> aw, i hate writing benchmarks
14:16:51 <MarcelineVQ> also afaik using something with a Monad constrant also won't neccesarily cause your Applicative do expression to use bind/return instead of <*> pure, it depends on how things are used in the expression, and you would have to -ddump-ds or something to know for sure.  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ApplicativeDo
14:17:50 <dmj`> hseg: no idea then
14:18:05 <hseg> Dammit
14:18:08 <hseg> Oh well, thanks
14:18:17 <remexre> anyone know why there isn't an instance Dhall.FromDhall Int?
14:18:29 <hololeap> i may just write my own ApplicativeError class. too bad MonadError has that Monad constraint
14:18:42 <hseg> Can shelve that bug for the moment.
14:20:39 <hseg> Just found a more pressing one: Have overlapping instances, one with head r (Complex s) and the other with head (Complex r) (Complex s). Suppose I should enable OverlappingInstances despite distaste
14:24:30 <solonarv> hseg: no, you should put a pragma on one (or more) of those instances
14:26:51 <solonarv> hseg: see the GHC manual: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/glasgow_exts.html#overlapping-instances
14:27:29 <hseg> ... right, brain fart
14:27:49 <hseg> The pragmas are much gentler than the flag, right?
14:28:04 <solonarv> yes, and more precise
14:29:27 <solonarv> OVERLAPPABLE says: "another instance may override me"; OVERLAPPING says "I may override another instance"; OVERLAPS says "I may override or be overridden by another instance"
14:29:47 <solonarv> -XOverlappingInstances is like an OVERLAPS pragma on *every* instance defined in that module
14:31:42 <hseg> Ah. So I want OVERLAPPING on that more-specific instance
14:32:13 <solonarv> yes, or OVERLAPPABLE on the other one
14:33:10 <hseg> Yeah, but that feels a little less natural. OK, thanks.
14:34:07 <hololeap> oh, i see. catchError is what needs a monad
14:34:36 <hololeap> i never use that
14:36:54 <hololeap> anyone know of an up-to-applicative version of mtl?
14:37:34 <dmwit> What does "up-to-applicative" mean?
14:38:07 <hololeap> meaning things that require a monad constraint aren't included. all the transformers have a (Applicative m) constraint
14:39:04 <hololeap> for instance MonadError could have an Applicative constraint if catchError wasn't included
14:39:50 <hololeap> i'm pretty sure some other monad transformers don't strictly need a monad constraint either
14:40:13 <hololeap> i mean their respective typeclasses
14:40:49 <hololeap> i doubt MonadReader needs a monad constraint
14:41:08 <dmwit> I believe there is no such library.
14:41:23 <dmwit> It is more annoying than you might suspect to not include those superclass constraints.
14:42:05 <dmwit> You end up adding an extra constraint to just about every single type signature.
14:42:49 <hololeap> how so?
14:43:24 <hololeap> would using (AppError t) be that much different than (MonadError m) ?
14:47:17 <d34df00d> TH question: I have a function that parses a file and produces some Haskell data type. What'd be the best way to run it at compile time to obtain those options for a statically known file?
14:47:31 <d34df00d> $() only runs Q Exp, right? I don't want to manually build the expression that defines the type.
14:48:35 <dmwit> hololeap: Not much different, except that it will have to be `(AppError t, Monad t)` (or `(AppError t, Applicative t)` or whatever) everywhere instead of just `MonadError t`.
14:49:37 <dmwit> What is a statically known file?
14:49:39 <hololeap> eh, i don't think so, since 1) i wouldn't use AppError in places i need a monad and 2) AppError could be a superclass of Applicative
14:50:19 <hololeap> the other way around on 2 ... class Applicative t => AppError e t where
14:50:28 <d34df00d> dmwit: bad wording. A file whose contents are known at compile time.
14:50:35 <dmwit> hololeap: Oh, good, then you get to annotate your things that reuse AppError-polymorphic components and MonadError-polymorphic components with both `(AppError e t, MonadError e t)`.
14:50:59 <d34df00d> I (as a programmer) could read that file myself and hardcode whatever info I need, but I've instead chosen to throw up a parser for it.
14:51:01 <dmwit> Anyway. I'm not saying it's a bad idea. Just warning you of a friction point.
14:51:20 <dmwit> d34df00d: What's getting in your way? You can just `readFile "foo"`.
14:51:23 <dmwit> Q is a MonadIO instance.
14:51:41 <hololeap> dmwit: thanks. i'm going to try it out and see if i have any problems. it could just be my use case is pretty simple, but i don't foresee any problems. i could be wrong though!
14:52:43 <d34df00d> dmwit: yeah, I have `staticOptions :: FilePath -> Q (OptsDescription 'Supported)` and it type checks.
14:52:46 <d34df00d> But how do I use it?
14:53:41 <d34df00d> I tried $(staticOptions "foo"), but I'm (unsurprisingly) getting type mismatch between ExpQ and Q (OptsDescription 'Supported)
14:54:32 <solonarv> what you're looking for is 'Lift'
14:54:41 <solonarv> class Lift a where lift :: a -> Q Exp
14:54:47 <hololeap> oh my glorb, why is this a thing?  (Functor m, Monad m) => Applicative (ExceptT e m)
14:55:12 <solonarv> old!
14:55:23 <solonarv> although, perhaps the Monad is actually required
14:55:42 <hololeap> i don't think so
14:55:57 <hololeap> i could be missing something about the semantics, however
14:56:09 <jle`> monad is required for ExceptT's Applicative instance
14:56:11 <jle`> that's the "point"
14:56:36 <hololeap> ExceptT f <*> ExceptT x = ExceptT $ liftA2 (<*>) f x  ?
14:56:37 <jle`> the point of the Applicative instance of (ExceptT e m) is to be able to short-circuit on results in the underlying Monad
14:56:48 <solonarv> d34df00d: so basically, $(lift =<< staticOptions "foo") should work, assuming there is a Lift (OptsDecription 'Supported) instance
14:56:58 <jle`> so you want to be able to choose to execute the next effect or not, based on whether the thing returns Left or Right
14:57:08 <jle`> hololeap: that's the Applicative instance for Compose (Except e) f, yeah, and that's a valid and useful one
14:57:16 <hololeap> oh, right...
14:57:16 <jle`> hololeap: but that gives the non-short circuiting semantics
14:57:21 <jle`> * Either e
14:57:31 <d34df00d> solonarv: ah, cool, thanks! That's more straightforward than some dataToExpQ that I've googled.
14:57:31 <jle`> the reason why ExceptT e exists is so that we can have a short-circuiting monad transformer
14:57:41 <jle`> otherwise we might as well just use Compose (Either e)
14:58:01 <solonarv> d34df00d: I think you could also write: $(do opts <- staticOptions "foo"; [| opts |] )
14:58:03 <jle`> *short circuiting Applicative transformer, even
14:58:32 <jle`> so for `act1 <*> act2`, we can choose to not perform act2 if act1 returns Left
14:58:48 <jle`> this isn't possible with Applicative, since all of the effects are pre-determined, without ever looking at any results
15:00:04 <d34df00d> solonarv: ah, this is getting beautiful! I own the staticOptions function, so I'll just move [| opts |] there.
15:00:06 <jle`> so you could say that *using* the Monad m in Applicative (ExceptT e m) is the whole point that ExceptT exists, as opposed to Applicative m => Applicative (Compose (Either e) m)
15:00:08 <d34df00d> Yay, there's even DeriveLift!
15:00:12 <hololeap> i suppose it would work if it were SomethingT Either a ... oh well, TIL! :)
15:00:39 <jle`> it's broadcasting, "hey, we do use the Monad instance! we do short-circuit!"
15:00:54 <jle`> whereas Applicative m => would be saying "hey, we don't use the Monad instance, so you can rest assured we don't short circuit"
15:01:45 <hololeap> one nice thing about going against the grain in haskell is that i usually learn something about why what i'm trying to do isn't possible :)
15:02:33 <jle`> yeah, definitely try all of these out :)
15:02:36 <d34df00d> > No instance for (Lift T.Text) arising from a use of ‘lift’
15:02:37 <d34df00d> Gosh.
15:02:39 <lambdabot>  <hint>:1:4: error: parse error on input ‘instance’
15:02:48 <jle`> although i wouldn't say that Applicative m => isn't "possible" -- just that it does different things
15:03:03 <jle`> but the thing that isn't possible is having an Applicative m => instance where <*> = ap for the Monad m => instance
15:03:31 <solonarv> jle`: btw, I think you have your 'Compose' arguments backwards
15:04:09 <solonarv> ExceptT e m a ~ m (Either e a) ~ Compose m (Either e) a
15:04:55 <jle`> ah thanks, you're right :)
15:05:43 <iqubic> What's going on here?
15:05:54 <d34df00d> Ah, they added it in text-1.2.4.0. Time to migrate to a nightly stackage snapshot!
15:06:04 <jle`> just chatting about haskell
15:07:32 <hseg> Is there some way of getting GHCi to spit out the instances of a type alias?
15:07:59 <dmj`> hseg: :info ?
15:08:10 <d34df00d> Uh.. Now I need `Lift Void`.
15:08:14 <hseg> That just says that I have a type alias
15:08:31 <hseg> I want GHCi to look under the alias
15:08:57 <hseg> Can't be bothered to start unwrapping the (IIRC) several layers of aliases hiding the instances
15:09:00 <jle`> hseg: :kind!
15:09:08 <jle`> maybe ?
15:09:22 <jle`> oh, you said type alias, not type family
15:14:10 <d34df00d> solonarv: yeah, all in all that worked like a charm. Thank you!
15:17:02 <hseg> It's late, thanks anyway
15:19:48 <solonarv> hsiktas: :kind! to normalize the type
15:20:12 <hsiktas> O_o
15:20:19 <hsiktas> :)
15:20:51 <MarcelineVQ> :>
15:20:55 <solonarv> then you get 'Foo bar baz ...' where 'Foo' is the outermost type constructor; ':info Foo' will give you the instances for Fii
17:37:24 <alc> elemIndex is O(n)?
17:37:55 <heatsink> yes
17:38:39 <alc> heatsink: is there a other way to get index? O(1), 
17:38:50 <alc> vector?
17:38:56 <[itchyjunk]> How do I ask the bot what type t is? :s
17:38:59 <alc> Data.Vector
17:39:26 <heatsink> To get an index in O(1), you would have to use a data structure that is designed to make searching efficient
17:39:45 <alc> heatsink: what data structure has that?
17:39:57 <heatsink> A hash table can
17:40:10 <heatsink> On the other hand, inserting and deleting is inefficient
17:40:30 <alc> Data.Map?
17:40:43 <solonarv> that's O(log n)
17:40:48 <heatsink> Data.Map has O(log N) lookup
17:41:07 <solonarv> lookup, and insert, and delete... really all its "single-target" operations are log N
17:41:28 <heatsink> I would recommend using Data.Map if you don't have important perfomance requirements.  Data.Map is convenient to use and it has a good API
17:41:45 <alc> heatsink: what's the better?
17:41:58 <solonarv> depends on your data
17:42:15 <alc> [Int]
17:42:22 <[itchyjunk]> isn't the result of the mod operation an Integer?
17:42:29 <solonarv> no, no, that doesn't give us any information
17:42:40 <solonarv> [itchyjunk]: the result of 'mod' is the same as the input type
17:42:47 <solonarv> :t mod
17:42:48 <lambdabot> Integral a => a -> a -> a
17:43:01 <solonarv> so yes, it can be Integer, if the arguments are also Integer
17:43:14 <alc> I turn Int to a [Int] like 12345 to [1,2,3,4,5] I'd like to get index that 5 in the list
17:43:21 <[itchyjunk]> hmm, i wanted a function f x = x `mod` 10 but getting error when i f 1
17:43:33 <[itchyjunk]> isn't 1 and 10 integer so it should be fine?
17:44:32 <solonarv> alc: ah, I see - so you have some input number and you want to know "what is the first position where <some digit> occurs"?
17:44:34 <[itchyjunk]> oh nm me. :| i was typoing my function name and didn't notice
17:44:58 <solonarv> you were mistyping the function name and thought there was a type error? o_O
17:46:02 <[itchyjunk]> yes :<
17:46:16 <alc> solonarv: yeah
17:46:47 <solonarv> alc: okay, you can't do that any faster than O(n) anyway
17:46:57 <solonarv> for this it's fine to use elemIndex
17:51:06 <alc> solonarv: ok
17:55:58 <Guest92218> does anyone know the Optics by Example ISBN?
17:57:40 <Guest92218> or if it's in the Kobo store?
18:05:26 <iqubic> It's not in the Kobo store
18:20:54 <alc> Axman6: "<Axman6> alc: my solution is here, but I would recommend you try as much as you can to come up with your solution before taking a look. https://gist.github.com/axman6/40204856a9c640c675a183fd4f1f4cfd" I tested your code on codewars, and there's a issue, passed 9, failed 1, 935855753 --> (358557539,0,8) expected: (358557539,0,8) but got: (358557593,0,7)
18:21:37 <alc> also that's 32 line, there's a typo, prefixf should be prefixF
18:25:04 <alc> my code run timeout https://paste.ubuntu.com/p/dgddW7vHRH/
18:31:44 <dmwit> I don't like the tests on that kata. The spec has a really cool edge case that doesn't appear in them.
18:32:30 * ski . o O ( having a typing issue, while thinking it was a typing issue )
18:32:34 <dmwit> Two edge cases, depending on how you think about it. Alternately: I don't like the spec, it's too prescriptive. =P
18:35:25 <dmwit> In fact, I don't like the spec for another reason, too: because it says "make i as small as possible" and "make j as small as possible", there is no unique best answer. Sometimes there are two answers, one with a smaller i (but bigger j), and one with a smaller j (but bigger i).
18:38:09 <dmwit> (e.g. for test case 209917, how should one choose between answers (29917, 0, 1) and (29917, 1, 0)? The test case as given chooses the former and rejects the latter, but why?)
18:39:41 * ski . o O ( minimal elements in partial orders. minimal spanning base )
18:47:30 <dmwit> Axman6: By the way, if you thought about this some, you might enjoy the solution I wrote to alc the other day.
18:48:06 <dmwit> > uncurry (:) . fst . foldr (\x ~(~(m,o),w) -> let s :: a -> a -> a; s a b = if x < m then a else b in ((s x m, s w (x:o)), x:w)) ((maxBound, []), []) $ "187863002809"
18:48:09 <lambdabot>  "018786300289"
18:50:45 <dmwit> (In English: find the last occurrence of the smallest element in the list and put it at the head of the list instead.)
18:52:58 <dmwit> (And yes, it does something wonky and wrong when the list has nothing but maxBound in it.)
18:54:53 <remexre> if I'm wrapping something like a REPL, would that be an appropriate use of conduit?
18:56:10 <dmwit> Sounds reasonable to me. You might consider looking at haskeline, though.
18:56:24 <remexre> that's for making repls, not interacting with them, right?
18:56:30 <dmwit> It does some of the work of doing line editing and maintaining a history for you.
18:56:40 <dmwit> Um. Yes.
18:57:14 <remexre> yeah, I'm trying to do the interacting part
18:57:58 <dmwit> Conduit or similar still sounds reasonable to me. I agree haskeline is not reasonable for that.
18:58:14 <remexre> ok cool, thx
18:58:36 <solonarv> if you feel like diving into FRP, reflex-process released a few days ago :>
18:59:12 <remexre> is FRP valuable for non-continuous data?
19:00:22 <solonarv> depends on the approach/implementation
19:00:30 <solonarv> reflex handles it just fine; that's what Event is for
19:03:04 <alc> dmwit: actually this kata has two question, find the samllest, get the position offset
19:03:13 <alc> the first one is simple
19:04:00 <alc> but the second one, like you said, there maybe two anwser for one same case
19:07:44 <alc> dmwit: but there's issues with you code too
19:07:57 <alc> > uncurry (:) . fst . foldr (\x ~(~(m,o),w) -> let s :: a -> a -> a; s a b = if x < m then a else b in ((s x m, s w (x:o)), x:w)) ((maxBound,[]), []) $ "935855753"
19:07:59 <lambdabot>  "393585575"
19:08:15 <alc> should return smallest for n : 935855753 --> (358557539,0,8)
19:08:36 <zeta_0> today i decided to give idris a try, i installed both idris and idris-mode(emacs) with nix in home.nix, but for some reason idris-mode is not loading when i open a .idr file?
19:10:25 <zeta_0> i left a message in the #idris channel, i don't know if i'll get a response, the channel looks pretty empty
19:12:18 <zeta_0> this looks similar to the problem that i am having: https://stackoverflow.com/questions/25833958/idris-mode-buffer-has-no-process
19:15:03 <zeta_0> i just wanted to give it a try, i'll try again some other time
20:02:41 <alc> I wonder if that rust unsafe issue is in haskell too?
20:02:54 <alc> that news about rust's actix-web 
20:24:24 * hackage hurl 1.1.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.1.0.0 (alcinnz)
20:44:25 <energizer> does anybody run ghci as their system shell?
20:45:52 <iqubic> No.
20:46:00 <iqubic> Why would you want that?
20:48:43 <MarcelineVQ> why not
20:49:59 <energizer> i just ran a command in my shell and got a runtime error from cli parsing :'(
20:55:04 * ski . o O ( Scsh <https://scsh.net/> )
20:55:35 <iqubic> I use the emacs eshell as my shell.
20:56:33 <ephemient> there does exist https://hackage.haskell.org/package/turtle/docs/Turtle-Tutorial.html
21:00:48 <glguy> Is it possible to mark the implementation of 'traverse' generated by -XDeriveTraversable to be INLINEd?
21:13:54 * hackage intcode 0.3.0.0 - Advent of Code 2019 intcode interpreter  https://hackage.haskell.org/package/intcode-0.3.0.0 (EricMertens)
21:28:48 <dmwit> alc: Ah, very good!
21:29:08 <dmwit> Thanks for pointing that out.
21:30:10 <dmwit> glguy: I don't know. If not, you could -ddump-deriv, copy-paste, and then mark it.
21:30:16 <alc> dmwit: :) waiting for a better version from you
21:44:10 <dmwit> I only considered how to win by moving things to the left.
21:44:17 <dmwit> But there is a way to win by moving things to the right.
21:44:45 <dmwit> Taking the better of the two should work, and I think finding the best way to win by moving things to the right should still be doable in one pass.
21:49:54 * hackage minilight 0.4.2 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.4.2 (myuon)
22:09:24 * hackage versions 3.5.2 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.5.2 (fosskers)
22:13:54 * hackage scalpel-core 0.6.1 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-core-0.6.1 (fimad)
22:14:53 * hackage sitemap-gen 0.1.0.0 - Generate XML Sitemaps & Sitemap Indexes  https://hackage.haskell.org/package/sitemap-gen-0.1.0.0 (lysergia)
22:14:55 * hackage scalpel 0.6.1 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.6.1 (fimad)
22:19:02 <Digit> curious.  those hackage notifications hilight this chan like i'm being nickpinged here.
22:22:26 <ski> they're actually ACTIONs, not NOTICEs (although, arguably, they ought to be the latter)
22:22:55 <ski> (not sure what they cause highlights/alerts for you, though)
23:14:41 <jle`> Digit: it depends on your client pretty much, you should probably be able to adjust it
23:16:40 <Digit> oh, i see now after that nickping, it's not quite the same colour after all.  maybe if i ever get a haskell irc client... ... *goes to look to see if that exists too, having just got into yi*
23:21:24 <tuiskula[m]> https://wiki.haskell.org/Roll_your_own_IRC_bot
23:21:45 <tuiskula[m]> Thanks for the inspiration Digit
23:22:32 <MarcelineVQ> Digit: glirc
23:23:26 <Digit> hehe.  oh yeah.  i do have a few irc bots that spawned from that irc bot tute.  :D   most recently, i repurposed one to be like Father Jack, from the episode of Father Ted where he only answers either "yes" or "that would be an eccumenical matter".
23:28:09 <Digit> https://notabug.org/Digit/fatherjackbot/  lol
23:29:05 * Digit realises he should figure out which local version to update the repo with
23:29:24 * hackage tldr 0.6.1 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.6.1 (psibi)
23:34:49 <iqubic> glguy: Are you still the maintainer of glirc?
23:35:32 <iqubic> Also, glirc is a cool IRC client. But I'm a #EmacsFanboy so I'm using ERC.
23:37:01 <Digit> ERC here also.  :)  tho i love the dream of transitioning more of what emacs does for me, to haskell things.  ... even one day, just having effectively emacs, but with haskell instead of elisp to configure it.  :D
23:43:03 <iqubic> Digit: Have you heard of XMonad?
23:43:24 <iqubic> It's a WM written and configured entirely in haskell.
23:43:29 <Digit> using it right now.  :)  have been for.... idk, over 12 years.  :)
23:43:57 <iqubic> I'm using a thing called EXWM. It's the Emacs X WM.
23:44:27 <iqubic> It's a WM written in Elisp and it's basically just running emacs for you.
23:44:28 <Digit> xmonad's probably /the/ thing that got me interested in haskell.
23:44:53 <iqubic> XMonad is a great gateway drug.
23:45:14 <iqubic> I just wonder how much FFI XMonad has under the hood.
23:45:41 * Digit tries remember back, n thinks there was a great spj talk introducing haskell, including xmonad
23:46:59 <iqubic> Yeah. Looks like it was called Taste Of Haskell
23:47:23 <iqubic> Link to that is on this page, at the botom of the list. https://xmonad.org/videos.html
23:48:34 <iqubic> Even though I'm quite proficient with Haskell, I'm still going to watch that later.
23:50:21 <Digit> i'm still a newbie, lacking aptitude, may still rewatch too, kindle yet even more haskell love, while i edit my glirc config in yi.  n_n
23:52:03 <iqubic> If you need help with anything, just let me know.
23:52:44 <Digit> got a way to fix my spine so i dont have to do so much physiotherapy so i can spend more time geeking?   ... oh, you meant with haskell.  ;)
23:52:55 <koz_> Digit: Become a cyborg.
23:52:59 <koz_> Or better, an upload. :P
23:53:03 <Digit> *dreams*
23:54:43 <iqubic> I want to make a haskell version of ELIZA. But I feel like that would be a pain.
23:55:11 <iqubic> https://en.wikipedia.org/wiki/ELIZA
23:58:28 <Digit> a haskell based chatter, with voice reccognition, and attatched to a reachy bot... some of these jigsaw pieces for droids exist.  longer over the horizon to get me uploaded into one.  but those sci-fi mountains long been in view.  we know the direction, just not the terain.
