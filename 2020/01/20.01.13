00:03:52 <amy_monnet> Hey everyone, hope you are all going well. A friend and I are currently building a website and we are using Elm for the frontend. We are planning on using Haskell on the backend with servant. It's probably worth pointing out now that we have no web dev experience! But we do know some Haskell and Elm and love both languages so are keen to use this
00:03:53 <amy_monnet> tech stack. We are currently looking at setting up some user authentication. I've seen that you can do this through servant and then we would like the store the user info in a database if they are creating an account or validate that the user exists if they are logging. What is the best database engine to use with our tech stack to do this? We were
00:03:53 <amy_monnet> considering PostgreSQL.
00:04:04 <amy_monnet> Apologies if we've done anything stupid. 
00:07:33 * hackage compendium-client 0.1.0.0 - Client for the Compendium schema server  https://hackage.haskell.org/package/compendium-client-0.1.0.0 (AlejandroSerrano)
00:07:34 <iqubic> jle`: The typical type of a sink is "ConduitT i Void m r" So in general you can't have that preccend a pipe.
00:09:40 <dmj`> amy_monnet: PostgreSQL sounds like a sane choice.
00:10:58 <jle`> iqubic: you can do mySink .| C.map absurd
00:20:38 <iqubic> So, how are people doing?
00:20:58 <iqubic> Also, I don't understand how it's possible to use a different lang for frontend as backend.
00:35:53 * hackage compendium-client 0.1.0.1 - Client for the Compendium schema server  https://hackage.haskell.org/package/compendium-client-0.1.0.1 (AlejandroSerrano)
00:38:59 <amalloy> iqubic: i mean, the frontend runs on a different computer (often someone's browser) than the backend (your server). they have to talk over the network anyway, so it's not clear why you think it matters if they use the same language
00:40:12 <amalloy> you need some defined wire format that the client and server agree on. it's convenient if they can reuse the same encoding library, but by no means necessary
00:41:23 * hackage mu-schema 0.1.0.0 - Format-independent schemas for serialization  https://hackage.haskell.org/package/mu-schema-0.1.0.0 (AlejandroSerrano)
00:41:26 <alp> amy_monnet, just so you know, servant is certainly not the most common option for the background you just described. spock is a typical "KISS"-style framework that is usually seen as quite accessible, while servant doesn't really have that reputation =)
00:44:08 <amy_monnet> I see. But can't servant do everything that other Haskell frameworks do?
00:44:26 <amy_monnet> web framesworks *
00:44:50 <amy_monnet> web frameworks* 
00:44:59 <amy_monnet> alp
00:46:34 <yushyin> it is a web api framework, it can do all the things other web api frameworks can do.
00:47:07 <bitonic> does cabal have non-boolean flags (as in https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations )? e.g. if i want to plumb some string into the .cabal file from outside, is there any way to do that?
00:48:01 <sclv> why would u want that
00:51:00 <amy_monnet> @yushyin do you recommend reading Practical Web Development in Haskell given that my friend and I don't have any web development experience?
00:51:00 <lambdabot> Unknown command, try @list
00:52:23 <yushyin> dunno, I don't know that book.
00:58:50 <alc> how to get all the sequences of [0,1,2] [0,2,1] [1,2,0] [2,1,0] [1,0,2] [2,0,1]?
00:59:00 <davve> amy_monnet: I would recommend elm lang if you're famillar with haskell and want to try building a SPA
00:59:01 <alc> without `permutation` function
01:02:41 <iqubic> alc: Why can't you use the permutation function?
01:03:11 <alc> iqubic: https://www.codewars.com/kata/5254ca2719453dcc0b00027d/train/haskell
01:03:27 <alc> this quesion is about to implement permutations...
01:03:52 <alc> and I saw that defintion of permutation, from https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations
01:04:26 <alc> and I just use it, in that question, guess what, this library function `permutations` let it run timeout
01:04:52 <alc> let the check website run timeout
01:26:43 <bitonic> sclv: I have some nix infrastructure that gets passed what `-march=xxx` flag to pass to GCC, and a Haskell package invokes GCC through inline-c, so I want to pass that information so that I can add the appropriate -march option in `cc-options` in the `.cabal` file
01:56:50 <bitonic> an alternative question might be "how do I pass cc-options through the command line?
01:56:53 * hackage mu-rpc 0.1.0.0 - Protocol-independent declaration of services and servers  https://hackage.haskell.org/package/mu-rpc-0.1.0.0 (AlejandroSerrano)
02:01:53 * hackage mu-avro 0.1.0.0 - Avro serialization support for Mu microservices  https://hackage.haskell.org/package/mu-avro-0.1.0.0 (AlejandroSerrano)
02:06:38 <dminuoso_> alp: What's the point of doing katas and then asking in this channel how to do it?
02:06:46 <dminuoso_> Oh. alp is not alc, pardon me.
02:06:52 <dminuoso_> Tab completion looked just right.
02:07:23 * hackage mu-protobuf 0.1.0.0 - Protocol Buffers serialization and gRPC schema import for Mu microservices  https://hackage.haskell.org/package/mu-protobuf-0.1.0.0 (AlejandroSerrano)
02:12:53 * hackage mu-persistent 0.1.0.0 - Utilities for interoperation between Mu and Persistent  https://hackage.haskell.org/package/mu-persistent-0.1.0.0 (AlejandroSerrano)
02:21:53 * hackage mu-grpc-client 0.1.0.0 - gRPC clients from Mu definitions  https://hackage.haskell.org/package/mu-grpc-client-0.1.0.0 (AlejandroSerrano)
02:30:23 * hackage mu-grpc-server 0.1.0.0 - gRPC servers for Mu definitions  https://hackage.haskell.org/package/mu-grpc-server-0.1.0.0 (AlejandroSerrano)
02:31:23 * hackage science-constants 0.2.0.2 - Mathematical/physical/chemical constants  https://hackage.haskell.org/package/science-constants-0.2.0.2 (cbou)
02:55:55 <kuribas> (cf-uuid-get "/alTask#79914")
02:56:02 <kuribas> oop sorry
02:57:54 * hackage mmsyn7ukr 0.6.2.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.2.0 (OleksandrZhabenko)
03:09:24 * hackage mmsyn7ukr 0.6.2.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.2.1 (OleksandrZhabenko)
03:11:24 * hackage mmsyn7l 0.2.1.0 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.2.1.0 (OleksandrZhabenko)
03:28:23 * hackage ngx-export-tools-extra 0.2.1.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.2.1.0 (lyokha)
03:33:12 <aveltras> am i missing something or there aren't any function is time package to get a number of seconds from a DiffTime ?
03:34:21 <MarcelineVQ> what type of number?
03:34:21 <dminuoso_> aveltras: It has a Num instance
03:34:31 <dminuoso_> Err oh wait heh
03:34:41 <dminuoso_>  diffTimeToPicoseconds
03:34:51 <aveltras> i'd like to go from https://hackage.haskell.org/package/cookie-0.4.5/docs/Web-Cookie.html setCookieMaxAge to a number of seconds
03:34:57 <dminuoso_> aveltras: Use diffTimeToPicoseconds :: DiffTime -> Integer 
03:35:33 <aveltras> but then i have to convert it again from picoseconds to seconds no ?
03:35:45 <dminuoso_> A picosecond is just 1e-12 seconds. :)
03:35:57 <dminuoso_> aveltras: yes.
03:36:51 <aveltras> ok thanks for the answer, seems strange to not have what would appear to me like the most used case
03:37:40 <dminuoso_> aveltras: Well, perhaps some need minutes, other may need hour, days, weeks, months (whatever that even means) or years (for some notion of year)
03:38:23 <dminuoso_> Besides, the complexity of turning picoseconds into seconds is so low...
03:39:05 <dminuoso_> Or maybe you want microseconds or nanoseconds..
03:39:29 <dminuoso_> Im rather surprised the library has secondsToDiffTime at all
03:40:00 <dminuoso_> Or that its Num instance assumes seconds, rather than picoseconds.
03:40:08 <dminuoso_> This is quirky
03:40:29 <Solonarv> eh, seconds is a reasonably canonical choice
03:40:34 <Solonarv> it is the SI unit after all
03:40:45 <dminuoso_> Solonarv: The SI unit was not made for programming.
03:40:53 * hackage science-constants-dimensional 0.1.0.3 - Mathematical/physical/chemical constants  https://hackage.haskell.org/package/science-constants-dimensional-0.1.0.3 (cbou)
03:41:00 <opqdonut> a Num instance for DiffTime makes no sense
03:41:05 <Solonarv> no, it was made for measuring time - which is what this library is doing
03:41:07 <opqdonut> what is Num.*?
03:41:44 <dminuoso_> Solonarv: The SI unit is great on paper because things like precision have flexible meanings
03:41:55 <dminuoso_> Solonarv: Try expressing half a second with that interface.
03:42:06 <dminuoso_> It's perfectly reasonable to say "I want a DiffTime of 100ms"
03:42:36 <opqdonut> what about a DiffTime of 1/3 seconds?-)
03:42:43 <dminuoso_> Solonarv: Plus with things like threadDelay expecting nanoseconds, its reasonable to always expect the parameter to be either Fixed or Integer assuming the highest precision
03:42:49 <dminuoso_> opqdonut: Oh cheeky you!
03:42:53 <Taneb> What's the appropriate place to raise concerns about unreleased changes to "base"?
03:43:26 <opqdonut> implementing DiffTime using picoseconds is reasonable, but also having seconds in the API would feel pretty natural to me
03:43:56 <MarcelineVQ> "any function is time package to get a number of seconds from a DiffTime" floor
03:44:06 <aveltras> my point wasn't so much that picoseconds is used under the hood but that there are no quality of life conversion functions since i think everyone will code those the same way
03:44:40 <opqdonut> dminuoso_: btw in case you think I'm merely joking with the 1/3s thing, see e.g. https://en.wikipedia.org/wiki/Flick_(time)
03:45:08 <dminuoso_> opqdonut: Oh that's interesting.
03:48:12 <MarcelineVQ> "<MarcelineVQ> what type of number?" what I meant by this is it hasn't been specified the seconds are to be denotated. Int, or Integer, or Double or Rational. DiffTime is just a representation for seconds in the first place, so one needs to know what other representation we're wanting in order to find a conversion forit.
03:51:03 <dminuoso_> MarcelineVQ: Mmm, so what we really need is some SI library that exposes `data SI (p :: SIPrefix) = SI Integer` with some machinery to work with this.
03:51:12 <dminuoso_> Such that we can just seamlessly mash things together regardless of SI prefixes.
03:51:23 <dminuoso_> Heck, we could even track the SI units as well.
03:51:42 <dminuoso_> Sounds like a fun thing
03:51:44 <MarcelineVQ> probably is one somewhere :> I'm just saying  "I want the seconds from this DiffTime" doesn't make sense by itself as a question beause DiffTime is already seconds
03:52:30 <aveltras> MarcelineVQ: floor works nicely for my use case :)
03:52:46 <aveltras> https://www.irccloud.com/pastebin/p6BE0fJo/
03:53:05 <dminuoso_> Uh, Id really avoid that.
03:53:31 <dminuoso_> I'd rather have some `picoToNone :: Integer -> Integer` function, because when you stare at this code a month from now, it's really not obvious why you use floor there.
03:55:29 <aveltras> dminuoso_: ye i get what you mean, i dont know why floor is working here without looking at the source from the prelude
03:56:00 <dminuoso_> aveltras: In short, because the Num instance gives you seconds back.
03:56:10 <dminuoso_> Or rather is focused around seconds.
03:56:51 <dminuoso_> Because all the numeric typeclasses form a hierarchy, it's implicitly required that they all share the same semantics
03:57:05 <dminuoso_> (Such that all the instances are coherent)
03:59:01 <dminuoso_> So if Num instance uses seconds, `floor x` will return the greatest second not greater than x
03:59:23 <dminuoso_> Likewise `ceiling x` would return the least second not less than x
03:59:50 <dminuoso_> So `floor (fromInteger (x :: Integer)) == x`
04:00:12 <dminuoso_> (That might not hold for all instances, but for time it does)
04:08:08 <aveltras> on some unrelated subject, i'm trying to implement redis backed session, i was wondering how people usually deal with modification of types which have been serialised and persisted out of the app (redis, database, etc..). For example, you release a new version of a website without downtime, users can have types serialised in their session which don't match with their new version and won't deserialise correctly when 
04:08:08 <aveltras> extracted from session store
04:10:38 <merijn> @hackage safecopy
04:10:38 <lambdabot> http://hackage.haskell.org/package/safecopy
04:10:44 <merijn> aveltras: Sound like you want that
04:11:08 <merijn> Not sure if there's a similar thing for binary
04:13:23 <aveltras> merijn: seems like what i was looking for indeed :) thanks
04:13:51 <merijn> aveltras: Or just do it manually by writing explicit Get/Put actions, rather than relying on the class
04:14:13 <merijn> aveltras: Then you can tag them with a version and parse the old version + migration logic to convert it to the new version
04:14:24 * hackage mmsyn7ukr 0.6.3.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.3.0 (OleksandrZhabenko)
04:17:24 * hackage mmsyn7l 0.2.2.0 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.2.2.0 (OleksandrZhabenko)
04:20:24 * hackage mmsyn7l 0.2.3.0 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.2.3.0 (OleksandrZhabenko)
04:42:23 * hackage raven-haskell 0.1.3.0 - Haskell client for Sentry logging service.  https://hackage.haskell.org/package/raven-haskell-0.1.3.0 (AlexanderBondarenko)
05:02:47 <Cheery> https://github.com/yi-editor/yi/blob/master/example-configs/yi-all-static/stack.yaml
05:03:07 <Cheery> trying to stack install on this gives an error about the location/subdirs -thing
05:03:43 <maerwald> did you check out the submodules?
05:04:06 <maerwald> oh wait, there are none
05:04:32 <Cheery> Error in $.packages[1]: failed to parse field 'packages': expected Text, encountered Object
05:14:37 <Michael24> Can anyone give a function g :: (((Int -> a) -> a) -> a) -> a
05:14:39 <Cheery> I'm amazed how far I'm willing to go just to reuse somebody's text editor.
05:17:04 <lyxia> :t \k -> k (\h -> h 0)   -- Michael24 
05:17:05 <lambdabot> Num t1 => (((t1 -> t2) -> t2) -> t3) -> t3
05:17:38 <opqdonut> @djinn (((Int -> a) -> a) -> a) -> a
05:17:39 <lambdabot> Error: Undefined type Int
05:17:42 <opqdonut> oh
05:17:55 <opqdonut> @djinn b -> (((b -> a) -> a) -> a) -> a
05:17:56 <lambdabot> f a b = b (\ c -> c a)
05:20:01 <Cheery> it's also the only function that can be given.
05:20:09 <Michael24> lyxia, thanks
05:29:49 <Cheery> Graphics/UI/Gtk/General/hsgthread.c: In function ‘gtk2hs_threads_initialise’:
05:30:08 <Cheery> warning: ‘g_static_mutex_init’ is deprecated: Use 'g_mutex_init' instead [-Wdeprecated-declarations]
05:30:37 <Cheery> but there reads this has been fixed.
05:39:27 <Cheery> Amazed how badly tangled this is. Nothing just works.
05:40:07 <AWizzArd> I see that Xeno (SAX parsing for XML) expects a ByteString, which is a strict BS: https://hackage.haskell.org/package/xeno-0.3.5.2/docs/Xeno-SAX.html
05:40:10 <AWizzArd> Why is that and how can I sax-process huge xml via streaming?
05:43:48 <maerwald> https://hackage.haskell.org/package/language-bash what a bliss!
05:43:55 <maerwald> a well maintained bash parser
05:47:14 <Cale> AWizzArd: It doesn't look like that library has support for partial parses. There's this thing though: https://hackage.haskell.org/package/sax-0.1.0.0/docs/SAX.html -- no idea how well it performs or if it's actually good, but it looks okayish at first glance :)
05:49:09 <tdammers> Cale: I think the more important use case for sax parsers is to process large XML documents in constant memory
05:49:14 <Cale> AWizzArd: The other option would be to grab the source code for Xeno and add some ability to return a continuation when the input stream ends prematurely
05:49:48 <tdammers> though of course you automatically get this from a parser that supports partial/incremental parses
05:49:51 <e> constant? that's instantly suspicious
05:50:18 <tdammers> e: well, constant wrt overall document size
05:50:28 <tdammers> asymptotically
05:50:37 <tdammers> it's usually at least linear wrt nesting depth
05:51:10 <tdammers> but for typical xml content, the nesting depth doesn't grow with document size
05:51:15 <e> for a pretty strong value of "usually" :)
05:51:24 <e> yeah
05:52:54 <maerwald> for a bytestring quasiquoter... would people expect Char8 behavior?
05:53:25 <maerwald> I mean, even with unicode extension, it's hard to have binary data in your codebase, isn't it?
05:53:25 <tdammers> I would expect utf-8
05:53:49 <dminuoso_> I would expect there to be a quasiquoter for every way that this is sensible.
05:53:52 <tdammers> I'm not 100% whether ghc demands it, but I think at least the convention is for haskell source files to be utf-8
05:54:04 <dminuoso_> So I'd expect a Char8 quasiquoter, and an utf-8 quasiquoter.
05:54:13 <dminuoso_> (Because why be limited to one?)
05:54:41 <maerwald> https://hackage.haskell.org/package/string-qq-0.0.4/docs/Data-String-QQ.html this one uses Char8
05:54:43 <tdammers> Char8 isn't *that* sensible, but IsString ByteString, so might as well add one that duplicates that
05:54:55 <dminuoso_> tdammers: Depending on your usecase it certainly might be.
05:55:07 <dminuoso_> The quasiquoter could ensure you didn't enter any non-ASCII codepoints
05:55:11 <maerwald> then again, I think for filepaths, Char8 behavior makes sense for a quasiquoter
05:55:47 <maerwald> dminuoso_: that was my idea. to throw an error on non-ascii
05:56:40 <tdammers> dminuoso_: my point being, the only thing you can reasonably have in a haskell source file is utf-8 data, so morally speaking, that's the right thing to use
05:56:59 <tdammers> plus ascii is a subset of utf-8
05:57:11 <tdammers> (but Char8 isn't)
05:57:31 <maerwald> Wish there was a more widely used ascii string type
06:00:14 <maerwald> https://hackage.haskell.org/package/ascii-0.0.5.2/docs/Data-Ascii.html the API looks quite reasonable though
06:13:11 <jpcooper> Could anyone tell me how to get the command string corresponding to a Development.Shake.Command ( CmdArgument )?
06:16:08 <jpcooper> It is possible to get the CmdLine in a command result, but I don't want to run the command yet
06:18:01 <Cale> jpcooper: There's a type called CmdLine there with an instance of CmdResult
06:18:30 <Cale> It says that the command line will be approximate - suitable for user diagnostics but not for direct execution
06:19:00 <jpcooper> Cale: I think I can only get that by running the command. I'm just going to destruct the CmdArgument myself to construct the command line
06:22:05 <Cale> jpcooper: hmm, yeah, I guess you can just hope that there's a Right in there somewhere.
06:22:27 <Cale> Or a Left (UserCommand ...) ?
06:23:03 <jpcooper> I'm constructing these things from Rights only, so it should be okay
06:34:24 * hackage OptDir 0.0.4 - The OptDir type for representing optimization directions.  https://hackage.haskell.org/package/OptDir-0.0.4 (MasahiroSakai)
06:39:02 <absence> lately i've toyed with type-level programming (typefamilies, etc), and i felt that its nature as extensions to an existing language shone through. in many ways the experience was like simulating typeclasses in scala. it made me curious to know if there are languages where type-level programming is more integrated and natural, without being a full-blown dependently typed language?
06:40:32 <tdammers> lisp *runs away*
06:41:04 <maerwald> how do I write a Lift ByteString instance, lol: https://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift
06:41:53 * hackage tamper 0.4.2.3 - Blaze-style HTML templates as a Monad Transformer.  https://hackage.haskell.org/package/tamper-0.4.2.3 (TobiasDammers)
06:41:54 <maerwald> doesn't seem to be a lit: https://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH.html#t:Lit
06:42:52 <Cale> absence: You might want to have a look at dependently typed languages like Idris, Coq, and Agda
06:43:12 <Cale> oh, you mentioned those
06:43:40 <Cale> Yeah, if you're going to do type-level programming, you might as well be dependently-typed.
06:44:38 <absence> Cale: i see, so haskell's type-level stuff is sort of a stopgap towards dependent typing, rather than features that exist by themselves in other languages?
06:46:00 <Cale> Yeah, you can see a lot of the extensions in GHC as being in the direction of supporting the kinds of programming that dependently-typed languages support without going to full-blown dependent types, and at the same time, often giving stronger answers when it comes to how type inference is going to work.
06:46:55 <Cale> Dependently-typed languages usually require a lot of type annotations -- Haskell's extensions generally only require things that themselves have fancy types to be annotated in some way.
06:47:17 <merijn> OTOH, dependently typed programming in something like Idris is infinitely simpler than Haskell
06:47:23 <Cale> Yeah
06:47:25 <boxscape> could you, in principle, replace all the type family stuff with type-level Prolog style typeclass resolver programming?
06:47:45 <merijn> Things that require ungodly amount of painful boilerplate in Haskell can be super straightforward in Idris
06:47:51 <Cale> In Haskell, I would say the point at which you should back off and reconsider your life choices is when you start feeling like you need singletons.
06:48:11 <Cale> There's a lot of stuff you can do with GADTs without being awkward
06:48:23 <merijn> absence: Also, keep in mind that Idris is explicitly designed to be easy for people coming from Haskell, so if you're doing type level stuff in Haskell you should be well prepared
06:48:24 <Cale> and DMap/DSum are pretty nice
06:49:18 <merijn> absence: What was the reason for asking for a non-dependently typed language?
06:49:42 <loli> Cale: you can infer non dependent types for dependently typed languages. F* does this
06:49:45 <merijn> maerwald: Short answer: You can't really do that
06:50:04 <merijn> maerwald: There's no literal type in GHC/haskell for byte blobs
06:50:18 <Cale> loli: Of course, it's just that it requires special attention to make that kind of thing happen.
06:50:43 <Cale> loli: Dependent Haskell will also be such a language
06:50:56 <merijn> maerwald: The way I did it in validated-literals is to generate a Word8 list and pack at runtime, but that's not...great. If you really want a zero overhead byte blob it's possible, but requires a bit of effort
06:50:56 <lortabac> boxscape: type classes and type families do different things, so I'd say no
06:51:12 <loli> I fear Dependent Haskell will be overly complicated, I know working with GADT's and Real dependent typed languages, which one is much simpler
06:51:20 <Cale> In the Haskell of today I start to worry when it comes to things like type-level lists, since you almost always end up wanting to do computation on those, and then end up needing to know properties of those computations, and it becomes annoying and awkward and not usually worth the cost.
06:51:28 <merijn> loli: Oh, I'm pretty sure Dependent Haskell will be over complicated, tbh
06:51:41 <Cale> (to continue my previous thought about where to draw the line on this stuff right now)
06:51:51 <boxscape> lortabac I know that they do different things, but I got the impression that type classes resolving still ought to be turing complete, though I'm not sure
06:51:56 <merijn> Cale: As for working with GADTs, yeah you can do a lot as long as you never have to encode something based on runtime input
06:52:00 <boxscape> s/classes/class
06:52:08 <merijn> boxscape: The default setup is not Turing complete
06:52:12 <Cale> merijn: What do you mean by that?
06:52:12 <boxscape> okay
06:52:20 <merijn> boxscape: IncoherentInstances makes them Turing complete, though
06:52:27 <boxscape> Ah, that makes sense I suppose
06:52:32 <Cale> merijn: I've been using GADTs a lot in serialisation stuff
06:52:52 <merijn> boxscape: By lifting the requirement that instance constraints are smaller than the instance itself
06:53:19 <boxscape> merijn does that mean undecidableinstances is enough?
06:53:37 <merijn> Cale: I mean that you then start having existential wrappers everywhere to hide the unknown type parameters and then you quickly get KnownNat and before you know it you singletons, etc.
06:53:43 <Cale> merijn: in fact, the communication protocols for our applications are often built out of things based on DMaps now, just because it's much more manageable than having to write separate instances of a dozen or so classes for ever-expanding record types.
06:53:53 <merijn> boxscape: Oh wait, maybe I meant UndecidableInstances, not IncoherentInstances
06:53:54 <Cale> Ah, we don't run into that
06:54:22 <maerwald> merijn: damn, that means writing a quasiquoter for a bytestring based file type will be annoying
06:54:36 <maerwald> *filepath type
06:54:42 <merijn> maerwald: Yes
06:54:43 <Cale> Our GADTs are usually keys of DMaps or DSums
06:54:52 <merijn> maerwald: Well, actually I think that'd be fairly easy
06:55:05 <merijn> maerwald: Paths are fairly short, so just encoding as [Word8] should be fine
06:55:32 <maerwald> merijn: hmm, that would change the entire API :o
06:55:33 <merijn> maerwald: So your quasiquote just produces "BS.pack $ [..]"
06:55:50 <merijn> maerwald: No, you can just generate a splice that wraps the [Word8] into bytestring
06:56:02 <boxscape> lortabac see here for a fun example of what you can do with instance resolution https://aphyr.com/posts/342-typing-the-technical-interview
06:56:10 <merijn> maerwald: See https://github.com/merijn/validated-literals/blob/master/examples/ByteString.hs
06:56:21 <cocreature> bytestring does have a rewrite rule to make packing String literals fast so [Char] might be preferable to [Word8] even though it’s terrible
06:56:45 <merijn> cocreature: GHC should just get a primitive way to embed binary blobs, tbh
06:56:59 <absence> merijn: the reason was that i was curious to see how a language with "native" support for type-level programming looks, without having to learn dependent typing at the same time. but it seems they're more connected than i thought, in practice if not by necessity
06:57:02 <cocreature> merijn: sure but it doesn’t have one atm :)
06:57:23 * hackage fromhtml 1.0.2 - Simple adapter for transformation of HTML to other formats  https://hackage.haskell.org/package/fromhtml-1.0.2 (MarekSuchanek)
06:57:26 <Cale> One trick we've found very handy is encoded in constraints-extras
06:57:26 <merijn> absence: Learning dependent typing is relatively easy in languages that support it by design.
06:57:47 <merijn> absence: Hell, if you're writing type families stuff in Haskell you should be fairly well prepared for Idris or something
06:58:09 <Cale> We have constraints like (Has ToJSON Foo) which means that if you give me some value of type Foo a, then I can get you an instance of ToJSON a
06:58:26 <lortabac> boxscape: I still don't see how you could use classes to replace type families
06:58:31 <merijn> absence: There's a nice Idris video/screencast on implementing type-safe printf: https://www.youtube.com/watch?v=fVBck2Zngjo
06:58:39 <Cale> and that helps a lot when it comes to writing instances for dealing with user input
06:58:50 <Cale> (and not writing huge case expressions everywhere)
06:59:03 <boxscape> lortabac yeah, it's very possible that you can't
07:01:35 <Unhammer> So … I have this xml-conduit parser that collects a bunch of strings (attribute-values of the xml). Many of them are the same, so to lower memory usage, I tried caching the duplicates like https://dpaste.org/trW5 – but is there a better way? Seems like something a sufficiently advanced compiler could do for me =P
07:02:51 <merijn>  Unhammer: How big are your text entries and how many do you have?
07:03:24 <merijn> Unhammer: Also, did that trick actually reduce the memory usage?
07:03:58 <merijn> Seems like with conduit it should be fairly constant anyway, since you only keep as many items in memory as you process them
07:05:31 <maerwald> merijn: I don't know why it works, but it does, lol
07:06:00 <merijn> maerwald: My example you mean?
07:06:13 <maerwald> lift (MkPath bs) = AppE <$> [| MkPath . BS.pack |] <*> lift (BS.unpack bs)
07:06:51 <merijn> maerwald: Easy, there's is no way to lift ByteString, but that's not really important, because all you *really* need is to lift "an expression that returns a ByteString"
07:07:30 <merijn> maerwald: So you cheat, because [Word8] (like all lists of Lift values) can be lifted. And arbitrary Haskell expressions (like function application) can be lifted too
07:08:00 <merijn> maerwald: So you produce a splice of "MkPath . BS.pack" applied to a splice of [Word8]
07:08:03 <Unhammer> merijn: it worked well, reduced 600mb to 500mb
07:08:15 <cinayakoshka> what's everyone's favorite, not outdated Haskell book?
07:08:37 <Unhammer> It's a text value that can change per day, but stays the same for fairly long periods 
07:08:40 <maerwald> merijn: yeah, just finding out those intricacies isn't that easy with TH. Documentation is...eh and API is bigger than anything on hackage.
07:08:41 <Cale> I usually recommend Graham Hutton's book to beginners
07:09:01 <merijn> cinayakoshka: I don't have a personal favourite, but Haskell from First Principles seems comprehensive and people seems to like Graham Hutton's "Programming in Haskell"
07:09:43 <cinayakoshka> thanks merijn, Cale 
07:10:00 <Unhammer> merijn: it's not a memory leak really, it's rather that several strings that happen to be the same take up more space than several pointers to the same string.. 
07:11:03 <merijn> Unhammer: I know, I'm asking because there's also ShortText which has less overhead per value than Text, so if you have lots of really short values that could help
07:12:22 <jchia_> I have some verbose record-related code. It involves zooming into nested records to update 2 fields deep inside. I don't think lens are available for the records. Can I reduce the verbosity, perhaps with an extension? https://gist.github.com/jchia/f58b562f1909439a1961006f13213592 L4-5 vs L13-14.
07:13:26 <merijn> jchia_: You can just...define lenses for the record? :)
07:13:41 <jchia_> For one-time use, it's a bit too much
07:13:45 <jchia_> not my library
07:14:18 <jchia_> and i don't use it much
07:16:05 <cinayakoshka> haskell from first principles seems really cool but it's "early access" which - I can't tell if that means it's "only ebook" or "eventually realbook." :(
07:16:17 <Taneb> jchia: can you use Data.Data.Lens.upon?
07:16:38 <inkbottle> I'm searching for package dependencies to run ch18/CountEntries.hs fron RWH
07:16:53 <inkbottle> And I have a real hard time at it
07:17:33 <inkbottle> There must be a place where I can find cabal files for rwh?
07:17:53 <dminuoso_> inkbottle: RWH is very outdated and aged.
07:18:02 <Cale> cinayakoshka: I don't think it's changing any more.
07:18:26 <dminuoso_> inkbottle: I would recommend you use a different resource. :)
07:19:11 <inkbottle> dminuoso_: yes, I know that, but then I stumbled on this example and I just wanted to run it (actually I'm using https://github.com/tssm/up-to-date-real-world-haskell/blob/master/18-monad-transformers.org)
07:19:12 <absence> merijn: i've been reluctant to learn idris due to the lack of laziness, but maybe it's worth it to get a better grasp of how type-level programming could/should work
07:19:14 <Cale> cinayakoshka: But also, I've heard some things about it from experienced Haskell programmers which would make me hesitate to recommend it, though also I've heard some beginners find it quite helpful.
07:19:27 <Cale> cinayakoshka: I haven't read it myself to know for sure
07:19:29 <cinayakoshka> Cale - so it's a $60 ebook without an index, no paper version pending.  That's a bummer.  Even that's discouraging enough for me.
07:19:48 <cinayakoshka> sigh
07:20:02 <dminuoso_> cinayakoshka: The book is quite good though, from what I hear. Assuming you fit into its target audience.
07:20:11 <cinayakoshka> I like paper books.
07:20:34 <Cale> cinayakoshka: You might also find this useful, though it is not really a book https://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:20:54 <dminuoso_> cinayakoshka: Well best you can do is write to him. If enough people annoy him, he might have it printed. :)
07:21:05 <cinayakoshka> Yeah I wrote in.  we'll see!
07:21:18 <dminuoso_> inkbottle: So one easy way is to use hoogle.
07:21:46 <dminuoso_> inkbottle: Use it to search for the module name, and you will find matching packages on hackage. You'll still have to do some (educated) guessing in case of ambiguous hits, but that's what I'd do. :)
07:22:01 <dminuoso_> inkbottle: most likely `transformers` is all you nee
07:22:21 <maerwald> now that I think about it, we should have a string type for https://en.wikipedia.org/wiki/Portable_character_set
07:22:21 <dminuoso_> inkbottle: maybe `bytestring` as well
07:22:56 <dminuoso_> inkbottle: Yeah, this chapter seems to need those two. :)
07:22:56 <inkbottle> dminuoso_: yes, but :hoogle doesDirectoryExist returns several results
07:23:06 <dminuoso_> Let me see
07:23:37 <geekosaur> I think there's both portable and POSIX resp. Win32 versions?
07:24:14 <inkbottle> So I need pacakge directory?
07:24:14 <dminuoso_> inkbottle: I'd say its from `directory`
07:24:34 <inkbottle> okay, I go with that
07:24:37 <geekosaur> yes but it should come with ghc
07:24:44 <geekosaur> it's a boot library
07:24:55 <inkbottle> geekosaur: keep that in mind/ try that
07:25:15 <inkbottle> thanks a lot
07:26:59 <maerwald> doctest hardcodes the ghc path? :>
07:27:02 <merijn> dminuoso_, Cale:Someone is updating RWH to be more modern
07:27:27 <merijn> I saw dons or bos retweet it: https://github.com/tssm/up-to-date-real-world-haskell
07:27:46 <merijn> oh, wait, that was linked already >.>
07:29:11 <merijn> Cale: I know some people seem to really dislike it, but my girlfriend worked through Haskell from First Principles and it seems mostly decent (from what I've seen) I don't quite agree with all the choices on in what order things are introduced (from a pedagogical perspective), but it seems fairly comprehensive and solid
07:29:33 <merijn> Cale: Certainly more principled/complete than LYAH, RWH, etc.
07:30:09 <merijn> Cale: I don't know Hutton's book, but I had the impression that's mostly really *just* Haskell, whereas HFFP also includes stuff on explaining parser combinators and transformers
07:33:45 <inkbottle> Which is Hutton's book?
07:34:48 <Taneb> Programming in Haskell
07:34:54 <AWizzArd> About laziness and GC. When there is a sudden explosion of memory use, caused by laziness, but while I still have enough RAM: why does this slow down my app? Does this have to do with the GC?
07:35:00 <inkbottle> Oh, thanks
07:35:24 <AWizzArd> Is the GC forced to traverse my 10 GB again and again to search for garbage, and thus my program has very little CPU left because the GC is using it?
07:36:45 <Cale> AWizzArd: Well, certainly when there's more memory to manage, the GC can take longer. But also programs that are doing more allocation than they ought to are going to be slower.
07:37:04 <AWizzArd> Cale: why are they slower if they allocate more than they ought to?
07:37:13 <Cale> Because allocation takes time as well
07:37:49 <AWizzArd> Laziness causes some extra allocation. And if this adds up it can require plenty of it.
07:38:26 <Cale> Well, it can also save lots of allocation in general
07:38:29 <AWizzArd> Cale: but can it cause a factor-10 slowdown?
07:38:32 <Cale> But yeah
07:38:58 <AWizzArd> Yes sure, in general it will save memory and cpu cycles, in places of which I wouldn't be aware of in the case of strictness.
07:39:14 <Cale> If you're allocating lots of thunks for Ints for example, that's going to be *far* worse than something which gets compiled into a tight loop operating on a single unboxed machine int
07:41:34 <Cale> More abstractly, sometimes, manipulating abstract expressions for computations is going to be better because you save yourself from having to do that work and maybe save yourself the space that would be required if those evaluations were to actually happen. Other times, you're wasting space and time keeping track of these unevaluated expressions when the final result would be smaller and obtained perhaps as quickly
07:42:23 <Cale> It really depends on what the program is doing, but it's easier to make a program stricter after the fact than it is to recover laziness that was lost.
07:43:58 <AWizzArd> Cale: what do you mean by easier? I can imagine that finding the right spot is the issue. But as soon as it is found, what else than an exclamation mark or seq would be required?
07:44:08 <aveltras> any idea why this doesn't work ? im in the middle of another function
07:44:13 <aveltras> https://www.irccloud.com/pastebin/Mpyvmt8W/
07:44:15 <AWizzArd> Do you say easier because finding the spot is the problematic part?
07:44:31 <solonarv> AWizzArd: exactly, making a lazy program *stricter* isn't all that hard
07:44:41 <merijn> AWizzArd: GHC's GC doesn't traverse memory to find garbage, instead it "copies & compacts" all *none* garbage
07:44:46 <solonarv> but making a stric program lazy? hoo boy, that's a lot of work
07:44:57 <merijn> AWizzArd: Which means that huge amounts of non-garbage cause massive slowdowns, yes
07:45:02 <merijn> AWizzArd: Also, threaded RTS?
07:45:02 <dminuoso_> If you were presented an API where an account can have activeAliases and inactiveAliases, and a REST endpoint `/account/:uid/alias/:alias` would return a 302 pointing towards either `/account/:uid/inactiveAlias/:alias` or `/account/:uid/activeAlias/:alias` would you feel offended I didn't encode this as a (tagged) sum type instead?
07:45:25 <dminuoso_> The thing is, I have operations that only make sense on inactiveAliases - so I really want to present that as separate sub-resources of accounts
07:46:30 <AWizzArd> merijn: ah okay, so if I have my 10 GB chunk of lazy data, the GC then will happily copy it around.
07:46:40 <AWizzArd> merijn: it is the threaded RTS, yes.
07:47:12 <dminuoso_> AWizzArd: By the way, in GHC in garbage collection collecting garbage itself is pretty much for free, it's memory that can't be collected you pay for.
07:47:18 <merijn> AWizzArd: Threaded RTS also enables parallel GC which for lots of cases is super bad/slow
07:47:28 <Cale> AWizzArd: Well, "easier" as in arranging for some evaluation to occur is something which is possible. Un-evaluating something that has already been evaluated is generally impossible.
07:47:45 <merijn> AWizzArd: If you've got RTS options enabled, try "+RTS -qg"
07:48:01 <geekosaur> aveltras, I think we need to see what / where sessionHandle is used. it is likely you're using it in a way that ghc can't tell it's supposed to be the same type as something else in the expression
07:48:13 <merijn> AWizzArd: This disables parallel GC and only uses single thread GC, which is often (usually?) much faster
07:48:53 <dminuoso_> AWizzArd: (That is, the GC doesn't look for garbage, it rather looks for non-garbage and copies that)
07:48:56 <AWizzArd> merijn: oh interesting. If a single threaded GC is typically faster, why then is the parallel GC turned on by default?
07:49:03 <dminuoso_> Everything left behind is just freed instantly. :)
07:49:14 <AWizzArd> I see.
07:49:29 <aveltras> geekosaur: it's not used anywhere right now
07:50:07 <geekosaur> that would be the problem, then. if you give sessionHandle an explicit type signature, it should work I think
07:50:26 <geekosaur> it's trying to infer the type signature and deciding it can't
07:51:18 <merijn> AWizzArd: The plan is to make threaded the default and part of that plan is to also make single threaded GC the default
07:51:20 <aveltras> hmm ok
07:51:32 <aveltras> https://www.irccloud.com/pastebin/mHuQ7oTT/
07:51:54 * hackage doctemplates 0.8.1 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.8.1 (JohnMacFarlane)
07:51:54 <AWizzArd> merijn: sounds good.
07:52:01 <merijn> AWizzArd: See discussion here for details: https://github.com/ghc-proposals/ghc-proposals/pull/240
07:52:02 <aveltras> geekosaur: thanks
07:54:45 <maerwald> hmm, the bytestring doesn't preserve identity law with utf8 symbols or the doctest/show messes something up
07:55:52 <merijn> maerwald: Why would it be the identity for utf8?
07:55:56 <merijn> maerwald: It explicitly isn't
07:56:09 <maerwald> https://git.io/JvJZR
07:56:52 <geekosaur> that looks unsurprising, \61648 is not utf8, it's a unicode codepoint as Char
07:57:07 <geekosaur> you need to decode the utf8, or encode the codepoints to utf8
07:57:35 <maerwald> oh right
07:58:25 <maerwald> how do you do that in a doctest lol
07:59:47 <maerwald> I guess I just copy the result there 
07:59:51 <maerwald> Will just be confusing to read
08:06:37 <Athas> Does anyone know when/how Haskell adopted purple as the identifying colour?
08:07:12 <Athas> It was used in a minor way on the old (~2008?) logo, and was also used on Real World Haskell in 2009.
08:07:18 <dminuoso_> Athas: Perhaps when the thompson wheeler logo came?
08:07:19 <dminuoso_> Just a theory.
08:08:03 <merijn> No, the logo before Thompson Wheeler had purple too: https://wiki.haskell.org/Haskell_logos
08:08:46 <merijn> Also, the Thompson Wheeler one was initially *not* purple
08:08:51 <merijn> See https://wiki.haskell.org/Thompson-Wheeler_logo
08:09:22 <merijn> The current colour was part of the haskell.org revamp, I think?
08:09:29 <aveltras> I'd like to pass values through wai request vault field. Those will be used in handlers of the form "ReaderT Request IO". Is there a way to guarantee that the wai vault contains a certain key in such a way that i could prepare functions like "getSessionValue" for example which would act on "MagicConstraintHereGuaranteeingSessionAccess => ReaderT Request IO" ?
08:09:46 <Athas> merijn: so it's just a coincidence that RWH was also purple?  I guess O'Reilly books don't have that many colors to choose from.
08:09:49 <merijn> The brand wiki page seems rather out of date :p
08:10:02 <merijn> Athas: Many O'Reilly books are purple
08:10:05 <Uniaika> I prefer these nuances https://myfriendshate.me/pieces/2019/06/24/thompson-wheeler-bisexual-pride/
08:10:16 <merijn> Athas: Not sure if it's a coincidence, though
08:10:38 <dminuoso_> Athas: You could mail SPJ, it's quite possible he actually knows.
08:10:52 <merijn> Or just haskell-cafe in general
08:11:16 <dminuoso_> Yeah haskell-cafe is probably even better 
08:11:26 <Athas> I just hope the purple sticks around for the next redesign, too.  It's a pretty colour.
08:11:38 <merijn> Especially given the limited bandwidth of SPJ
08:11:52 <dminuoso_> Athas: Yeah, it's quite unique as well. :)
08:11:56 <merijn> Athas: Well, considering Hackage is slowly rolling out the purple CSS everywhere it seems likely
08:11:58 <Athas> dminuoso_: hm, now that you mention it, I recall SPJ often uses a purple background on his slides.  Maybe that predates the websites!
08:12:09 <merijn> !!!
08:12:13 <merijn> I just realised something
08:12:22 <dminuoso_> Athas: And comic sans! But GHC certainly does not mandate we use editors with that font.
08:12:27 <merijn> New Hackage has deployed fixing my most annoying issue!
08:12:52 <merijn> Athas: SPJ mostly seems to use blue and yellow? At least the talks I've seen
08:13:04 <merijn> The annoying auto-focus of the search box on Hackage is finally fixed \o/
08:13:09 <Athas> Maybe the similarity of blue and purple makes me misremember.
08:18:20 <solonarv> merijn: \o/
08:19:54 <merijn> solonarv: Now I can finally use quickjump without first grabbing the mouse and clicking
08:21:06 <solonarv> quickjump? do you mean the search thingy that's brought up by 's'?
08:22:20 <merijn> yeah
08:22:29 <solonarv> yessss that is awesone
08:43:48 <Cheery> yi works, gtk+pango works, yi + gtk+pango doesn't work.. hm. trying yet once with this.
08:47:13 <Cheery> it works..
09:03:22 <Cheery> There's weirdness here. Font size doesn't update the interface size. But.. I don't want to complain more.
09:03:25 <Cheery> With any other language I couldn't expect even this quality.
09:12:14 <aveltras> is the following error common ?
09:12:18 <aveltras> https://www.irccloud.com/pastebin/KPuSFYek/
09:13:09 <AWizzArd> Bang Patterns. In a lambda I have to place the exclamation mark after the var, while in a let I need to prefix the var?   (\x! -> let !y = ...) ?
09:16:17 <int-e> > (\ !x -> x) () -- needs a space
09:16:18 <lambdabot>  ()
09:16:45 <AWizzArd> What then is (\x! -> ...)?
09:17:05 <int-e> nothing?
09:17:06 <Taneb> A parse error?
09:17:27 <AWizzArd> Taneb: when I tried it then Emacs suggested me to activate the Bang-Patterns extension.
09:17:42 <AWizzArd> It compiles and seems to work.
09:17:54 <Taneb> That is certainly odd. It doesn't work for me in GHCi
09:17:58 <glguy> Maybe you had something like:  \x! y -> _
09:18:11 <int-e> glguy: good guess
09:18:42 <glguy> In which case the ! associated with the y, not the x
09:34:24 * hackage log4hs 0.5.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.5.0.0 (gqk007)
09:36:31 <sm[m]> merijn, you mentioned a hackage upgrade ? Do you know where the changelog might be ?
09:55:08 <elmiko> hi all, haskell novice here, i am reading through my configuration code for xmonad and i see this operator used in an infix manner .|. but i am having trouble locating where this operator comes from. could anyone give me some guidance?
09:55:35 <Cheery> that's a dick
09:55:54 <Cheery> okay.. lets see where it is.
09:55:57 <elmiko> ok, fair enough, is it documented in haskell somewhere?
09:56:20 <heatsink> The documentation is here http://hackage.haskell.org/package/xmonad-0.15/docs/XMonad.html#v:.-124-.
09:56:39 <heatsink> I found it by going to the index of the xmonad documentation on hackage
09:57:05 <heatsink> If you know what library a name is defined in, that's a good way to look it up
09:57:27 <geekosaur> it's from Data.Bits and it's bitwise or
09:57:51 <geekosaur> you can look things like that up in hoogle
09:57:54 <elmiko> heatsink: tyvm! i /thought/ it might be from a lib or something
09:58:07 <elmiko> geekosaur: hoogle?
09:58:15 <geekosaur> @where hoogle
09:58:16 <lambdabot> http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
09:58:28 <elmiko> oh, very cool!
09:58:32 <geekosaur> search engine for haskell library functions and types
09:58:33 <elmiko> heatsink++
09:58:35 <elmiko> geekosaur++
09:58:41 <elmiko> thank you both!
09:58:45 <Cheery> another trick is to check where the operator is used in, then  search with the type
09:59:39 <elmiko> that sounds reasonable Cheery, i'm not sure how i would do that from the configuration file though
09:59:42 <Cheery> but why XMonad needs to define bitwise operators?
09:59:53 * hackage infernal 0.3.0 - The Infernal Machine - An AWS Lambda Custom Runtime for Haskell  https://hackage.haskell.org/package/infernal-0.3.0 (ejconlon)
10:00:37 <elmiko> i'm not sure about that, i'm just trying to learn some haskell /and/ understand my config file XD
10:00:44 <Cheery> well usually you write down the type there somewhere.. but yeah.
10:00:45 <geekosaur> it doesn't define it, it reexports it. and it does so because it's a very thin wrapper over xlib
10:01:10 <geekosaur> so you end up writing a lot of "C in Haskell"
10:02:32 <elmiko> appreciate the discussion, thanks again =)
10:02:33 <geekosaur> in particular, old-style keybindings often involve (modMask .|. shiftMask) or similar
10:02:40 <elmiko> right!
10:02:58 <geekosaur> where modMask is usually a local binding to the default modifier mask extracted from the user config
10:03:14 <elmiko> i mean, i /knew/ it was a bitwise mask but it was driving me nuts not being able to find the definition
10:03:35 <elmiko> well, bitwise or operation
10:04:01 <geekosaur> @hoogle (.|.)
10:04:01 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
10:04:01 <lambdabot> System.Directory.Internal.Prelude (.|.) :: Bits a => a -> a -> a
10:04:02 <lambdabot> Protolude (.|.) :: Bits a => a -> a -> a
10:04:17 <elmiko> ooh, that /is/ fancy
10:05:00 <Cheery> hm.. stack has hoogle built in.. lets see what it does
10:05:54 * hackage api-rpc-pegnet 0.1.1.0 - simple json-rpc client for PegNet  https://hackage.haskell.org/package/api-rpc-pegnet-0.1.1.0 (sigrlami)
10:06:35 <Cheery> requires that hoogle is installed.. well I install and try again.
10:06:49 <geekosaur> I think that builds a local index with the specified packages, which is another way to use hoogle
10:07:23 * hackage api-rpc-pegnet 0.1.1.1 - simple json-rpc client for PegNet  https://hackage.haskell.org/package/api-rpc-pegnet-0.1.1.1 (sigrlami)
10:09:24 * hackage Frames-dsv 0.1.2 - Alternative CSV parser for the Frames package  https://hackage.haskell.org/package/Frames-dsv-0.1.2 (AnthonyCowley)
10:15:29 <Cheery> seems like it's not easy to use hoogle that way.
10:15:54 * hackage api-rpc-pegnet 0.1.1.2 - simple json-rpc client for PegNet  https://hackage.haskell.org/package/api-rpc-pegnet-0.1.1.2 (sigrlami)
10:16:00 <Cheery> or then didn't figure out how to install it.. oh. stack install maybe.
10:16:43 <ovitus> anyone know how I can resolve this:
10:16:49 <ovitus> Could not find module ‘Test.Hspec’
10:18:50 <geekosaur> make the hspec package a dependency of your project? hard to say any more without more detail
10:19:48 <ovitus> just trying to import it
10:20:49 <geekosaur> you need the package that provides it (hspec) installed somehow. what "somehow" is depends on whether you're using cabal or stack, and how you're using cabal if you are
10:27:54 * hackage base64-bytestring 1.0.0.3 - Fast base64 encoding and decoding for ByteStrings  https://hackage.haskell.org/package/base64-bytestring-1.0.0.3 (MikhailGlushenkov)
10:33:50 <pounce> how do i take the last two elements out of a list :?
10:35:16 <pounce> bleh, i have to figure out processes and monad loops
10:36:15 <pounce> i still can't figure out what the first term of untilM_ does since it's just sequenced into the result
10:36:21 <ysangkok> pounce: rearchitecture your app to take the first two elements instead, and you can pattern match on them :)
10:36:55 <pounce> hmmm, maybe can do that. just have to deal with the output of an external process
10:38:09 <ysangkok> pounce: did you see this package https://hackage.haskell.org/package/typed-process
10:38:20 <pounce> ye! i was going to try to figure it out
11:05:00 <amalloy> i'm not totally convinced by the documentation of (<**>). it claims to be "A variant of <*> with the arguments reversed", which would suggest that (<**>) == flip (<*>), but of course the main reason it exists is to run its effects in the opposite order from flip (<*>)
11:06:27 <madnight> > take 2 $ reverse [1..100]
11:06:30 <lambdabot>  [100,99]
11:07:42 <monochrom> Yeah that wording is ambiguous, to be only resolved by taking a look at the type.
11:08:07 <monochrom> Oh wait "arguments reversed" is plain wrong heh.
11:08:43 <monochrom> Err no, it's right.
11:09:19 <ysangkok> madnight: but reverse is O(n)
11:09:40 <monochrom> Right, now I see it is not even ambiguous. The wording points towards flip only.
11:10:57 <polyphem> ysangkok: thats O(2) for take 2 $ reverse [1.100] , right ? because of lazieness 
11:11:12 <monochrom> % (putChar 'x' *> pure False) <**> (putChar 'y' *> pure not)
11:11:12 <yahb> monochrom: xyTrue
11:11:14 <geekosaur> reverse always has to traverse the whole list
11:11:14 <ysangkok> madnight: it is yet another discussion on values vs development speed, but given that pounce claimed himself he could rearchitecture easily, why even take that hit
11:11:33 <monochrom> reverse is not lazy
11:11:51 <geekosaur> (well, unless the take isn't evaluated)
11:12:39 <ysangkok> himself/herself/itself :)
11:12:49 <pounce>  hehe
11:12:50 <polyphem> well , yeah , obviously
11:13:03 <zeta_0> fendor: i fixed most of my problems that i was having with ghcide yesterday, but for some reason ghcide is not recognizing external packages, and modules like yesod, here are my .yaml, .cabal, and .nix pkgs, and here is the error that ghcide is throwing? https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
11:13:07 <pounce> oh, hm didn't notice that about <**>
11:13:37 <madnight> ysangkok, well worst case access time of list is O(n) that's the deal with lists
11:14:26 <zeta_0> my guess is that my issue doesn't have to do with ghcide, i'm guessing it has more to do with cabal, i can't seem to find the cabal documentation that explains how to fix this issue
11:14:28 <ysangkok> madnight: what is your argument? surely you agree that take.reverse is in a more expensive class than plain take
11:14:31 <monochrom> Especially when you insist on the last item, which is what reverse does right up front.
11:14:34 <fendor> zeta_0, is the formatting of the cabal file like you shared or are you missing some spaces?
11:14:42 <fendor> does cabal build work?
11:17:17 <ysangkok> polyphem: there is no O(2) btw, all constant-time functions are in the same complexity class
11:18:32 <madnight> > [1..100] !! 99
11:18:35 <lambdabot>  100
11:18:51 <madnight> that's also O(N)
11:18:59 <solonarv> the way I'd state this is: 'take k xs' is O(min(k, length xs)); 'take k (reverse xs)' is O(length xs)
11:19:05 <amalloy> madnight: well, it's O(1), since 100 is a constant
11:19:25 <solonarv> could even replace that O with a more accurate landau symbol, since those bounds are tight
11:20:44 <madnight> amalloy, what kind of a difference does that make?
11:20:51 <zeta_0> fendor: uhh, let me double check that, ok, so cabal configure/build works without any error, and the .cabal's file's spacing is correct, but it pasted all messed up in the github gists
11:21:17 <amalloy> when you write O(N), you have to have some idea what N represents: some input variable that influences the runtime of your function
11:21:37 <amalloy> in [1..100] !! 99, there is no input variable: it always takes a constant amount of time
11:21:52 <solonarv> madnight: the point of this O notation is to express how the program's runtime/memory usage/whatever varies as the (size of the) input varies
11:22:22 <solonarv> if the input is just some fixed value, it's meaningless to talk about which "O" class it's in
11:22:35 <amalloy> (i specialized to runtime here, but indeed as solonarv says you can use this notation to compare the growth of anything with the growth of anything that influences it)
11:23:00 <madnight> [1..100] !! n is O(n) then
11:23:29 <zeta_0> fendor: do you think my problem has to do with cabal or does it have to do with ghcide, that way i know what to put my focus on?
11:23:29 <solonarv> no, but this time it's because if n > 99 you will get an error in constant time
11:23:33 <amalloy> [1..n] !! n is O(n)
11:24:29 <fendor> zeta_0, Unfortunately, I dont really have an idea. Maybe it is related to nix and ghcide? Are you executing ghcide in the nix-shell?
11:24:32 <madnight> ah okay that makes sense
11:25:03 <solonarv> and of course the thing inside O( ) can depend on multiple variables, too
11:25:10 <ysangkok> there is some kind of misconception that whatever is in O(...) is the amount of iterations. that is not the way i learnt complexity classes, if you write "[1..x] !! x" that is also O(n). i think we are making it needlessly complicated by actually putting haskell syntax inside those paratheses
11:25:32 <solonarv> who's putting haskell syntax in the parentheses?
11:25:43 <ysangkok> you write "O(length xs)"
11:26:02 <madnight> and is reverse + head in the same complexity class as directly access the last element of a list?
11:26:03 <solonarv> well, I have to refer to "the number of items in the list 'xs'" somehoow
11:26:19 <amalloy> madnight: yes
11:26:35 <amalloy> which is to say, it is linear in the size of the list
11:27:05 <solonarv> I could just as well have written "O(n) where n is the number of items in the list 'xs'", but surely you will agree that that is much longer and more cumbersome
11:27:25 <ysangkok> i would totally approve of that :P
11:27:52 <madnight> amalloy: okay this was the argument I was aiming for, unfortunately I didn't expressed it correctly with my examples
11:29:28 <madnight> what would be the formal notation of that sentence?
11:29:34 <zeta_0> fendor: well, the pastebin shows how i installed ghcide in my home pkgs(home.nix), and importing external modules still does not work in a nix-shell either, i think after i fix that one problem i should be good to go with ghcide, but i am just not sure how to troubleshoot it
11:30:02 <pounce> can i open a (unix style)  pipe in haskell?
11:30:09 <solonarv> pounce: yes, you can
11:30:24 <pounce> nice
11:30:31 <solonarv> there is a 'unix' package which has fairly low-level bindings
11:30:41 <solonarv> possibly someone's written a higher-level interface, I don't know.
11:31:40 <polyphem> but O(n) as Complexity-Class only means linear runtime/growth of an operation, and n isnt really refering to the length of the list in this example .. as O(1) is constant complexity without 1 referring to length of list in an constant operation , right ?
11:31:54 <geekosaur> System.Process has such a higher level interface, yes
11:31:57 <fendor> zeta_0, I am not sure if ghcide can find the yesod library files. Does `ghc-pkg list` contain yesod?
11:32:10 <koz_> polyphem: What's the example?
11:33:16 <monochrom> In fact most of the times you should use Θ(n) instead of O(n).
11:36:24 <polyphem> koz_: reversing the list to take first two elements .... 
11:36:26 <fendor> zeta_0, sorry, out of ideas, it looks right
11:36:49 <koz_> polyphem: If you reverse a list, you're in O(n) territory, end of story.
11:37:03 <zeta_0> fendor: https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671 
11:37:35 <polyphem> koz_: right
11:37:53 <koz_> n is 'the size of the input'.
11:37:56 <zeta_0> fendor: well, thank you for the help, i'll see if i can find someone to help me fix this problem
11:37:59 <koz_> In this case, the 'input' is the list.
11:38:00 <monochrom> Bascially accessing the last two items?  You expect O(1) time for that?
11:38:12 <fendor> zeta_0, what is the output of `hie-bios flags Main.hs`?
11:38:37 <koz_> Yeah, not for a list.
11:38:55 <fendor> And can you use the produced flags to compile the file with ghc, like `ghc <flags>`
11:39:45 <zeta_0> [zeta@nixos:/hello-haskell]$ hie-bios flags Main.hs
11:39:45 <zeta_0> "flags" not supported
11:39:51 <madnight> For any monotonic functions f(n) and g(n) from the positive integers to the positive integers, we say that f(n) = O(g(n)) when there exist constants c > 0 and n0 > 0 such that
11:39:52 <madnight> f(n) ≤ c * g(n), for all n ≥ n0
11:40:02 <mpickering> zeta_0: What does the `ghcide` command tell you?
11:40:49 <mpickering> I already explained yesterday what the issue was
11:42:14 <zeta_0> mpickering: https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
11:42:28 <zeta_0> ghcide: : cannot satisfy -package-id yesod-1.6.0-5QFOcEvaOmo6MHKHdlJlmg
11:43:58 <mpickering> Does `cabal v2-repl exe-hello-haskell` work?
11:45:05 <mpickering> Is `NIX_GHC_LIBDIR` envvar set?
11:45:51 <mpickering> I think if you set `NIX_GHC_LIBDIR` to the result of `ghc --print-libdir` then it will work
11:45:53 <mpickering> https://github.com/digital-asset/ghcide/blob/cef3097b7fcd5583886033039d679562247ebe5a/docs/Setup.md#issues-with-nix
11:46:44 <madnight> Hom(A, -) is (->) a and Hom(-, -) is (->) in Hask right?
11:47:22 <zeta_0> mpickering: no that cabal v2-repl exe-hello-haskell command does not work, i pasted the output(scroll all the way to the bottom): https://gist.github.com/zeta-00/4fd70eafd264f8680e62bf222a36a671
11:48:19 <zeta_0> mpickering: ok, i'll try fixing my problem with that nix solution
11:49:24 <solonarv> madnight: correct
11:54:53 * hackage cut-the-crap 1.0.0 - Cuts out uninteresting parts of videos by detecting silences.  https://hackage.haskell.org/package/cut-the-crap-1.0.0 (Jappie)
11:55:54 * hackage persistent-template 2.8.0.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.8.0.1 (MaxGabriel)
12:02:02 <fendor_> @pl \fp -> any (\p -> p fp) [isHidden, isSpecialDir]
12:02:02 <lambdabot> flip any [isHidden, isSpecialDir] . flip id
12:17:27 <ordychan[m]> hoi
12:17:48 <ordychan[m]> is this the right place i ask for something?
12:17:59 <geekosaur> if it's related to Haskell, it is
12:18:14 <juri_> yes. as long as you have three strips of gold pressed latinum.
12:18:54 <ordychan[m]> ok so i am trying to understand how will i write value into a file with haskell, project is fan controll program, for now i just need to make haskell write stuff into file
12:19:53 <ordychan[m]> i couldnt sadly find really what i was looking for online
12:20:20 <ordychan[m]> command i use normally in terminal is `echo level 7 | sudo tee /proc/acpi/ibm/fan`
12:20:27 <sm[m]> https://leanpub.com/haskell-cookbook/read#leanpub-auto-file-io
12:20:35 <sm[m]> ordychan: ^
12:21:25 <madnight> A Bifunctor is covariant in both arguments and a Profunctor is contravariant in its first argument and covariant in the second. What's with the other combinations, e.g. a Functor that is contravariant in both arguments? Is there such a thing?
12:21:58 <sm[m]> also: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#g:7
12:22:03 <aveltras> is there a way to get the following code to compile without having to specify the function signature again in the instance ?
12:22:09 <aveltras> https://www.irccloud.com/pastebin/f0YXw9aQ/
12:22:23 <ordychan[m]> is there way to write into with those things but fill it into one liner?
12:22:31 <aveltras> if i don't, ghc can't guess what typeRep is
12:22:59 <sm[m]> ordychan: do you mean you want to run some haskell code with a one-line shell command ?
12:23:19 <ordychan[m]> nono i wanna have the part that writes something into file in one line if its possible
12:24:02 <sm[m]> writeFile filepath "some text\n"
12:25:03 <ordychan[m]> `  on button #clicked (#writeFile /proc/acpi/ibm/fan "level disengaged")` is this how it should look?
12:25:29 * sm[m] mind blown
12:25:34 <ordychan[m]> hmm dang i tried to run it but yeah thats not how syntaxing works here i guess
12:25:39 <sm[m]> what language are you programming in
12:25:49 <ordychan[m]> haskell
12:26:11 <ordychan[m]> but working with gtk
12:26:17 <sm[m]> in what special environment ? we don't usually see # like that in haskell code
12:26:43 <ordychan[m]> well i found that as guide how its done for gtk
12:26:54 <sm[m]> if you can paste a link to an example from the gtk haskell docs, that might help
12:27:00 <ordychan[m]> https://github.com/haskell-gi/haskell-gii found that here
12:27:25 <ordychan[m]> i am using it as starting refference
12:27:59 <ordychan[m]> later on i would like to be able to generate gui with glade and use that instead of this but for now this will have to do
12:30:20 <geekosaur> it's conceivable that the `on button` is using an overloaded field name, but the # on writeFile is wrong regardless
12:30:42 <ordychan[m]> so how it should look like?
12:30:47 <sm[m]> ordychan: yes it looks like that might work, just don't write # before writeFIle
12:31:22 <ordychan[m]> it does seem to hate the entire path
12:31:35 <sm[m]> oh, and wrap the path in double quotes
12:31:59 <sm[m]> on button #clicked $ writeFile "/proc/acpi/ibm/fan" "level disengaged"
12:32:25 <ordychan[m]> $ is for making it as sudo?
12:32:57 <geekosaur> no, $ is sort of backward parentheses
12:33:19 <ordychan[m]> oh there is oof
12:33:20 <geekosaur> (on button #clicked) (writeFile "/proc/acpi/ibm/fan" "level disengaged")
12:33:42 <ordychan[m]> when i run it with sudo which i need to modify the file it wont detect those libs i use
12:33:43 <ordychan[m]> dangit
12:33:56 <aveltras> is there sth wrong with a signature like "sessionHas :: forall a. Typeable a => ReaderT env m Bool" ? (env and m are in scope because im in an instance declaration)
12:34:08 <ordychan[m]> is there way to make it popup the password prompt so it would work?
12:35:23 <geekosaur> aveltras, you need an extension to write a type signature for an instance method at all, it should infer it normally
12:35:53 <pounce> is the IO monad an mplus
12:35:57 <sm[m]> ordychan: there must be.. maybe look through the examples for a dialog popup
12:36:02 <pounce> so could i stop operating at a certain point by returning mempty
12:36:03 <aveltras> geekosaur: ye ive enabled instance sigs but ghc complains strangely with
12:36:06 <aveltras> https://www.irccloud.com/pastebin/peC7gJt1/
12:36:23 <monochrom> pounce: What does :info! IO say in ghci?
12:37:26 <pounce> ah :(
12:37:35 <geekosaur> sm[m], ordychan[m], note that the password popup is an external program and you'd still need to run a separate program using it to do the write. I don't think this will work nicely unless the program is suid and you still have the problem of it finding its libraries in that case
12:37:58 <geekosaur> aveltras, it says what the problem is, if you provide an instance signature then it must be strictly more general, not the same
12:38:07 <geekosaur> what goes wrong if you leave the signature off entirely?
12:38:18 <aveltras> then i can't use type applications
12:38:25 <aveltras> or i think so at least
12:39:24 <aveltras> here's the whole thing https://gist.github.com/aveltras/84437d749da1bae917066af9ad944d73
12:39:25 <ordychan[m]> but this was bad misstep, i never thought of running it as root wont have the required libs
12:40:16 <geekosaur> they're there, just not where root looks for them. but I can't say any more since I don't know howw you're set up, whether you're using stack or cabal v2, etc.
12:40:18 <aveltras> if i don't add instance signatures (which i would like not to add here), i can't access the "a" type variable which is needed to retrieve the type representation used as a key
12:40:34 <ordychan[m]> stack
12:40:52 <ordychan[m]> so i somehow need to run it as same user while giving it root acces
12:41:02 <ordychan[m]> uuu this is gonna be weird
12:41:52 <geekosaur> stack install it, find where it's installed (usually ~/.local/bin), then chown it to root, and chmod u+s it
12:42:06 <solonarv> % :t (<+>) @IO -- pounce 
12:42:07 <yahb> solonarv: ; <interactive>:1:1: error:; Ambiguous occurrence `<+>'; It could refer to either `Text.PrettyPrint.HughesPJ.<+>', imported from `Text.PrettyPrint.HughesPJ'; or `Control.Arrow.<+>', imported from `Control.Arrow'
12:42:09 <geekosaur> being certain you trust it, which is iffy for gui programs and I think gtk complains
12:42:15 <solonarv> oh, bugger off
12:42:19 <solonarv> % :t mzero @IO -- pounce 
12:42:20 <yahb> solonarv: IO a
12:42:23 <solonarv> there!
12:48:55 <xeno> shouldn't this work?  (input, vm2) = getInput vm
12:50:48 <solonarv> xeno: I don't know! where are 'getInput' and 'vm' coming from?
12:51:06 <geekosaur> and where are you using that?
12:51:44 <jle`> > (input, vm2) = getInput vm
12:51:47 <lambdabot>  <hint>:1:14: error:
12:51:47 <lambdabot>      parse error on input ‘=’
12:51:47 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:51:54 <geekosaur> "getInput" makes me suspect it wants to be <-, anyway, but if it somehow is pure then it'd need a let
12:51:55 <jle`> lots of potential issues :)
12:52:00 <CoffeeCoder[m]> Hello @ordy
12:52:00 <CoffeeCoder[m]>  * 
12:52:00 <CoffeeCoder[m]>  * Hey ﻿ordychan
12:52:23 <ordychan[m]> hey coffee, do i know u from somewhere else? you are fammiliar
12:53:20 <pounce> > mzero >> putChar 'y'
12:53:22 <lambdabot>  <IO ()>
12:53:49 <xeno> solonarv: getInput has this signature: getInput :: Memory -> (Int, Memory)
12:53:59 <pounce> oh wait
12:54:04 <pounce> % mzero >> putChar 'y'
12:54:04 <yahb> pounce: *** Exception: user error (mzero)
12:54:09 <pounce> ah
12:55:04 <jle`> xeno: maybe you can paste the error message?
12:55:07 <jle`> if you have one
12:55:26 <jle`> there are a lot of potential things can can be going wrong here and knowing the error message would answer a lot of questions
12:55:34 <jle`> for example, maybe getInput and vm aren't defined
12:55:40 <jle`> or maybe there's an indentation issue
12:55:41 <xeno> parse error on input ‘=’
12:55:51 <jle`> is that the whole message?
12:56:06 <xeno> it's the usual "maybe you need a let..." 
12:56:14 <jle`> did you try the suggestions?
12:56:20 <xeno> it makes no sense 
12:56:30 <jle`> let us see if we can interpret it
12:56:52 <geekosaur> provide more context on where you're trying to use it (that is, the code around it)
12:56:58 <jle`> can you paste the whole message?
12:57:06 <jle`> which i think includes the code snippet around it
12:57:13 <jle`> there's a reason the error message is long :)
12:57:29 <jle`> imagine if ghc just said "parse error on input '='. it's the usual"
12:57:34 <jle`> how would we ever get anything done :)
12:59:25 <xeno> https://pastebin.com/qwRFFZvB
13:00:07 <geekosaur> do you see the first one has a "let" and an "in"?
13:00:20 <geekosaur> whereas the one throwing the error doesn't?
13:01:18 <xeno> ah true... I blame it being a monday :)
13:03:35 <monochrom> See how 1 minute of posting code is saved by 5 minutes of talking beside the point?
13:03:42 <CoffeeCoder[m]> juri_: *rubs my earlobes* three strips?! not even a disk of my vacuum-desiccated remains shall be worth so much!
13:03:54 * hackage tropical-geometry 0.0.0.1 - A Tropical Geometry package for Haskell  https://hackage.haskell.org/package/tropical-geometry-0.0.0.1 (ferynando7)
13:10:47 <maerwald> monochrom: we should have politicans write code :o
13:16:03 <maralorn[m]> @pl \x -> (f x, g x)
13:16:04 <lambdabot> liftM2 (,) f g
13:16:34 <[exa]> f <,> g
13:17:46 <jle`> (f &&& g) i guess
13:20:23 * hackage libarchive 2.2.0.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.0.1 (vmchale)
13:27:53 * hackage libarchive 2.2.0.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.0.0 (vmchale)
13:30:29 <amalloy> huh, i'm surprised to see lambdabot still uses liftM2 instead of liftA2. is that a historical accident, or are there people who still prefer that style?
13:31:04 <aveltras> is there a way to make a type variable defined in a class function accessible from the instance without using InstanceSigs ?
13:31:18 <geekosaur> nobody has rewritten @pl to speak Applicative
13:33:13 <jle`> yeah i don't remember the last time there was any modification to @pl
13:33:20 <jle`> aveltras: nah
13:33:30 <jle`> unless you mean variables that are a part of the instance head, like Show (Maybe a)
13:33:38 <aveltras> no
13:33:51 <aveltras> i'd like to recover a type variable to use with "typeRep"
13:34:03 <aveltras> using type application
13:34:06 <jle`> are you opposed to instance sigs?
13:34:26 <jle`> there are some workarounds
13:34:38 <jle`> for example you could define the method as a separate function with its own type signature
13:34:56 <jle`> and then use that function as the definition, class MyClass .. where myMethod = theSeparateFunctionImplementation
13:38:31 <CoffeeCoder[m]> I'm almost done with chapter 9 of Learn You a Haskell. 🙂
13:38:45 <jle`> nice :)
13:39:56 <aveltras> jle`: seems i get the same error as before
13:40:23 <jle`> what's the error?
13:40:57 <jle`> if it's exactly the same then that's suspect
13:40:59 <jle`> did you remember to save the file?
13:41:41 <aveltras> jle`: https://gist.github.com/aveltras/139338d465dcab8de1bcc53474b65177
13:42:00 <aveltras> i might misunderstood your suggestion
13:43:16 <jle`> ah
13:43:24 <jle`> sessionHas :: Typeable a => m Bool
13:43:43 <jle`> in that case yeah you're going to need InstanceSigs with -XScopedTypeVariables
13:43:54 <jle`> unless you rewrite the method to something like
13:43:58 <jle`> sessionHas :: TypeRep a -> m Bool
13:44:49 <jle`> the normal way i described only works if the type variable is used within the arguments or result of the function itself
13:45:00 <jle`> but this is an AmbiguousTypes sort of situation
13:45:18 <aveltras> ye, id like to have only a type application to manipulate the session
13:45:52 <jle`> one thing you can do is have sessionHas_ :: TypeRep a -> m Bool be the actual typeclass method
13:46:06 <jle`> and then provide sessionHas :: forall a. Typeable a => m Bool; sessionHas = sessionHas (typRep @a)
13:46:08 <jle`> as a separate function
13:46:14 <jle`> but the simplest way would be to probably just use InstanceSigs ...
13:46:51 <aveltras> ive nothing against instance sigs per se but then.. i has another error
13:47:05 <jle`> but along these lines, one strategy i often use is to use an explicit parameter for all my internal code
13:47:11 <jle`> since it's easier to write/use internally
13:47:19 <jle`> and then provide the implicit forms as a part of the external api only
13:49:26 <aveltras> how can i make forall a. (Serialize a, Typeable a) => ReaderT env m Bool more general than the class signature so that ghc stops complaining ?
13:49:36 <Cale> madnight: Obviously those combinations exist, but usually you just call those things "bifunctors" and choose the categories appropriately.
13:50:46 <jle`> aveltras: what's the error ?
13:51:18 <Cale> madnight: There's not really any special names for the others. Profunctors also wouldn't be a thing except that they have a special extra notion of composition.
13:51:24 <jle`> not exactly sure what your question means
13:51:45 <jle`> what is 'the class signature'
13:51:53 * hackage archive-sig 0.2.2.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-0.2.2.0 (vmchale)
13:52:46 <aveltras> jle`: https://gist.github.com/aveltras/5bf5244c20927c6a3ad864ccf10fc904
13:52:56 <dmwit> aveltras: (Serialize a, Typeable a) => proxy a -> ReaderT env m Bool, for example
13:53:04 <dmwit> or AllowAmbiguousTypes
13:53:07 * dmwit clicks the link
13:53:24 <Cale> Why would you need a Typeable a constraint on that?
13:53:30 <aveltras> ambiguous types are enabled here
13:54:11 <jle`> hm
13:54:12 <dmwit> Oh, this.
13:54:16 <aveltras> because i want to use the type representation as a key in the session
13:54:23 <jle`> i see the problem here
13:54:23 <Cale> I think 'a' should just be a class argument
13:54:39 <Cale> Then you could probably lose Typeable?
13:54:45 <jle`> yeah there isn't any way of getting around needing 'a' somewhere, like taking a type rep
13:55:12 <jle`> Serialize a => TypeRep a -> ReaderT env m Bool, or (Serialize a, Typeable a) => proxy a -> ...
13:55:23 <zeta_0> mpickering: what value do i need to set NIX_GHC_LIBDIR to?
13:55:33 <jle`> that's because the implementation can't necessarily ensure that the 'a' you are binding is the same as the 'a' in the typeclass method definition, i think
13:55:53 * hackage archive-libarchive 0.2.2.0 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-0.2.2.0 (vmchale)
13:56:07 <dmwit> aveltras: You will need to wait for https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0155-type-lambda.rst
13:56:10 <mpickering> zeta_0: I literally explained this already
13:56:42 <mpickering> The path that `ghc --print-libdir` reports
13:56:46 <dmwit> aveltras: Or do something else. e.g. change the class to take a proxy
13:57:21 <Cale> Something feels a little off about this class I think... like why are we distinguishing different pieces of state on their type in this way?
13:58:07 <Cale> It might make more sense to have the user define a GADT of keys, and then the type index on the keys tells you the type of data which the key is paired up with?
13:58:20 <Cale> Then you're not just screwed if you ever need to store two things that have the same type
13:58:21 <zeta_0> mpickering: oh sorry, i missed that from earlier
13:58:49 <aveltras> id like to not have a "limited" set of possible session values
13:59:07 <aveltras> without having to extend a gadt to support a new possible value
13:59:34 <aveltras> i thought newtyping everything wouldn't be to cumbersome here
14:00:05 <jle`> aveltras: yeah, the main issue here is that the Typeable a => ... comes from the typeclass method, but when you write your own Typeable a => in the instance sigs, it isn't necessarily referring to the same 'a' in the class method definition
14:00:21 <jle`> or well, 'main issue' as in the mechanics of the type inference
14:00:49 <jle`> basically when you use InstanceSigs, GHC tries to unify your instancesigs variables with the variables in the typeclass method
14:00:51 <Cale> Maybe I just like to have *some* sort of static guide to what is going to be stored / what we expect the database to contain, but I dunno.
14:01:03 <jle`> but in this case there is no link to unify it
14:01:31 <jle`> if you want to do literally what you have here, then adding some sort of proxy or TypeRep argument would let you do that.
14:01:53 <aveltras> i guess ill go with your sessionHas_ implementation / sessionHas public api then, looks ok to me too
14:03:23 * hackage archive-tar 0.2.2.0 - Common interface using the tar package  https://hackage.haskell.org/package/archive-tar-0.2.2.0 (vmchale)
14:13:35 <inkbottle> > let {f = pure . (+1); f :: Int -> Maybe Int} in (foldr (\a b -> ((:) <$> (f a)) <*> b) (pure []) [1,2], traverse f [1,2]) -- [], seems to be a special element in Traversable, and yet it doesn't have a specific name? empty list, empty tree, do they have a common name when considered as Traversable?
14:13:37 <lambdabot>  (Just [2,3],Just [2,3])
14:14:14 <zeta_0> mpickering: also, i have a couple of quick questions about using ghcide in nix-shell, after i set the hie.yaml to include default.nix, do i also need to include the NIX_GHC_LIBDIR in default.nix, also in home.nix i have ghcWithHoogle setup, so the hoogle and haddock integration with ghcide should work fine when i am locally building projects with my user pkgs, but when i am using a nix-shell, will ghcide be able to 
14:14:14 <zeta_0> work fine with default.nix or will i need to setup ghcWithHoogle in default.nix as well for ghcide to be integrated with hoogle and haddock? here is my default.nix that i am using for haskell yesod development: https://hastebin.com/cohugetexe.cs
14:19:42 <d12frosted> hi everyone :)  does anyone know if there is a name (or maybe some generalisation) for function like `coerce . p1 <> coerce . p2` of type (Semigroup d, Coercible a d, Coercible b d) => (c -> a) -> (c -> b) -> c -> d
14:20:04 <d12frosted> I've tried hoogling, but nothing came upon my sight
14:21:09 <d12frosted> I usually call this function cappend and it's useful in things like p1 .&& p2 = getAll . cappend p1 p2
14:22:03 <zeta_0> mpickering: i am asking all these questions because i want to make sure that ghcide is setup correctly right away from the `beginning`, so that i don't have to come back later to fix things
14:25:24 * hackage composite-base 0.6.1.0 - Shared utilities for composite-* packages.  https://hackage.haskell.org/package/composite-base-0.6.1.0 (dridus)
14:26:24 * hackage composite-aeson 0.6.1.0 - JSON for Vinyl/Frames records  https://hackage.haskell.org/package/composite-aeson-0.6.1.0 (dridus)
14:27:54 * hackage composite-aeson-refined 0.6.1.0 - composite-aeson support for Refined from the refined package  https://hackage.haskell.org/package/composite-aeson-refined-0.6.1.0 (dridus)
14:28:54 * hackage composite-swagger 0.6.1.0, composite-opaleye 0.6.1.0, composite-ekg 0.6.1.0 (dridus)
14:46:12 <[itchyjunk]> Hmm, question: Given a string, i want to find an replace certain chars with some other char
14:46:31 <[itchyjunk]> i saw some searching list stuff on google but not sure about replacing
14:47:45 <ChaiTRex> [itchyjunk]: Well, first, what would be the type of the function?
14:48:13 <[itchyjunk]> hmm it would take Char and spit out Char i think
14:49:02 <ChaiTRex> Well, you need to take in some replacement pairs (assuming I read your question correctly) and the original string and output the string after replacements.
14:49:28 <ChaiTRex> One possibility is [(Char, Char)] -> String -> String
14:49:34 <ChaiTRex> There are other possibilities.
14:49:36 <[itchyjunk]> ah thats true, i want to pass (Char,Char)
14:49:37 <[itchyjunk]> oh
14:50:19 <[itchyjunk]> I want to take a function that take a tuple (Char,Char) apply it to String and get a String back
14:50:21 <[itchyjunk]> right?
14:50:52 <ChaiTRex> Well, you said certain characters in the plural, so you'd need a list of tuples, I think.
14:51:39 <[itchyjunk]> ah, ideally yes. but i was thinking of just getting a string back once, applying the function with another pair rinse and repete
14:51:44 <[itchyjunk]> lot of manual labor
14:52:16 <ChaiTRex> [itchyjunk]: Well, one problem with that is if you replace 'c' with 'a' and you replace 'a' with 'c', you probably want "ac" to be "ca"
14:52:43 <ChaiTRex> [itchyjunk]: But if you do it tuple by tuple like that, it'll just be "cc" or "aa".
14:53:01 <[itchyjunk]> oh no, thats trouble
14:53:26 <[itchyjunk]> but i think i'd replace each one once in this particular case
14:54:04 <ChaiTRex> One other possibility is Map Char Char -> String -> String
14:54:46 <ChaiTRex> Probably be a bit faster to execute, plus Maps have some kind of default thing that would make this problem easy.
14:55:00 <ChaiTRex> I forget the exact function name, but it has default in it.
14:56:24 <[itchyjunk]> i defined replace a b |a = b
14:56:37 <[itchyjunk]> can't i now use map (replace a b) string ?
14:56:40 <amalloy> :t Data.Map.findWithDefault
14:56:41 <lambdabot> Ord k => a -> k -> M.Map k a -> a
14:58:12 <ChaiTRex> [itchyjunk]: Try it.
14:58:15 <[itchyjunk]> hmm it thinks it wands Boolen :(
14:58:29 <[itchyjunk]> <interactive>:30:14: error: Variable not in scope: a :: Bool
14:59:05 <ChaiTRex> [itchyjunk]: Yeah, guards like f a | x = ... require x to be a boolean.
14:59:24 <ChaiTRex> [itchyjunk]: It's f a = ... if x is True.
14:59:40 <[itchyjunk]> There was a :: way to tell it its a char i think hmm
15:00:12 <ChaiTRex> [itchyjunk]: No, I mean, you can't use Chars as guards. If you have f a | x = ..., x must be a Bool.
15:01:11 <ChaiTRex> [itchyjunk]: One function you might make is [(Char, Char)] -> Char -> Char.
15:01:14 <[itchyjunk]> ah
15:01:29 <ChaiTRex> [itchyjunk]: You have a whole list of replacements. You have one Char to maybe replace if it matches one.
15:01:32 <[itchyjunk]> yes i like that char method
15:01:37 <[itchyjunk]> i can use the map function
15:01:39 <[itchyjunk]> after
15:01:49 <ChaiTRex> [itchyjunk]: Yeah, that would work.
15:08:56 <[itchyjunk]> What does this mean? The type signature for ‘replace’ lacks an accompanying binding
15:09:12 <ChaiTRex> [itchyjunk]: You have replace :: ..., but you don't have replace ... = ...
15:09:41 <zeta_0> mpickering: after setting the environment variable that you recommended, ghcide's features do not seem to be activated, and i lsp-log returns this message: https://hastebin.com/rosekunuwu.coffeescript
15:09:46 <ChaiTRex> [itchyjunk]: Basically, you tell the type of it, but you don't define it.
15:10:01 <zeta_0> mpickering: running ghcide returns: ghcide: ghc --print-libdir/settings: openFile: does not exist (No such file or directory)
15:10:02 <[itchyjunk]> ah
15:10:11 <TheCommieDuck> can I somehow have a record field be of type State x Foo (or something achieving the same goal) with constraints rather than being parametric over x?
15:10:47 <TheCommieDuck> like I want Bar { _stateField :: HasFoo a, HasBaz a, HasSomeOtherConstraints a => State a Int }
15:12:41 <[itchyjunk]> so i dont want guard
15:13:31 <[itchyjunk]> but once i define a type, i am not sure how to define a function that takes it. replace :: (Char,Char) -> Char
15:13:40 <ChaiTRex> [itchyjunk]: You can use guards, they just need to be boolean expressions. Like c == d or something.
15:14:15 <ChaiTRex> [itchyjunk]: Well, what does that function do?
15:14:34 <Axman6> replace :: (Char,Char) -> Char; replace (a,b) = ... (where ; = new line)
15:14:57 <[itchyjunk]> function doesn't deal with booleans so thats why i dont wnat guard
15:15:07 <[itchyjunk]> Axman6, ah let me test
15:15:12 <ChaiTRex> [itchyjunk]: OK, but what does it do?
15:15:27 <[itchyjunk]> oh
15:16:35 <[itchyjunk]> if i give it a char and it matches the first component of the tuple, it sets it equal to the second component of the tuple
15:17:08 <ChaiTRex> [itchyjunk]: Oh, OK.
15:17:15 <Axman6> then your type is wrong
15:17:28 <[itchyjunk]> hmm
15:17:45 <Axman6> I assume you want replace ('x','y') 'x' to equal 'y'?
15:17:59 <[itchyjunk]> yes
15:18:20 <Axman6> then you type needs to be replace :: (Char,Char) -> Char -> Char
15:18:32 <[itchyjunk]> right
15:18:36 <Axman6> given a pair of chars, and a char, give back a char
15:20:11 <Axman6> and you probably do want to use guards, or an if statement, to write the function
15:21:09 <[itchyjunk]> i am trying to use if, guard was giving me type errors since i am not using bool
15:21:50 <Axman6> right, and ChaiTRex was trying to explain to you how to use guards
15:22:16 <Axman6> you understand that 'x' == 'y' gives you a Bool right?
15:22:56 <Axman6> since there is an instance for the Eq class for Char, then there is a version of (==) which has type Char -> Char -> Bool
15:23:03 <[itchyjunk]> As in true or false, right
15:23:24 * hackage hpath 0.10.1 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.10.1 (maerwald)
15:23:31 <[itchyjunk]> hmm
15:24:18 <ChaiTRex> [itchyjunk]: And in a lot of cases, guards aren't just one variable, they're some full expression you'd use in the Bool part of an if statement.
15:24:24 * hackage hpath-io 0.10.1, hpath-filepath 0.10.1 (maerwald): https://qbin.io/url-cork-7xxh
15:24:32 <Axman6> yes
15:25:15 <Axman6> > let f :: String -> String; f s | s == "Hello!" = "Hello to you too!" | otherwise = "Hi" in f "Hello!"
15:25:16 <lambdabot>  "Hello to you too!"
15:25:26 <Axman6> an example of using guards
15:25:47 <Axman6> > let f :: String -> String; f s | s == "Hello!" = "Hello to you too!" | otherwise = "Hi" in f "yo"
15:25:49 <lambdabot>  "Hi"
15:32:01 <[itchyjunk]> for my (Char,Char) -> Char -> Char , the tuple is from what character to what character
15:32:12 <[itchyjunk]> err do i want a Char Char Char -> Char?
15:32:20 <[itchyjunk]> |a == c = b
15:32:25 <[itchyjunk]> |otherwise = c ?
15:33:32 <Axman6> how about you try writing the function and show us where you get stuck. I don't know how to interpret that question
15:36:08 <[itchyjunk]> https://pastebin.com/zaxBkp8q
15:36:35 <[itchyjunk]> i understand the error a bit and its making my question the type i picked
15:37:27 <[itchyjunk]> I feel like i need those 3 things to work if
15:37:31 <Axman6> you need to decide if you want to pass in a tuple of two chars or two individual chars - your type for the function says you're passing in a tuple and then another char, but your definition says you're trying to take in three chars
15:37:38 <pounce> hecc did haskell wiki go down
15:38:07 <[itchyjunk]> hmm i'd like to take 3 char in and spit out a char
15:38:12 <[itchyjunk]> want to try out that route :s
15:38:25 <Axman6> ok, then you need to change the type to say that
15:38:53 <Axman6> if you do change the type, it should work though
15:39:11 <[itchyjunk]> hmm something something -> char
15:40:00 <Axman6> what is the type of a function which takes a Char and returns a Char?
15:40:05 <ChaiTRex> [itchyjunk]: Well, the general scheme is argument1 -> argument2 
15:40:09 <ChaiTRex> [itchyjunk]: Well, the general scheme is argument1 -> argument2 -> output
15:40:24 <ChaiTRex> [itchyjunk]: So, you have three arguments and an output.
15:40:32 <[itchyjunk]> (Char->Char->Char)-> Char?
15:40:56 <ChaiTRex> [itchyjunk]: No, not (argument1 -> argument2) -> output.
15:41:27 <[itchyjunk]> ah i see
15:42:04 <[itchyjunk]> what does (Char->Char) end up defining?
15:42:12 <[itchyjunk]> what will the () cause it to think?
15:42:32 <Axman6> (Char -> Char) is a function which takes a Char and returns a Char
15:43:15 <Axman6> (Char->Char->Char)-> Char is the type of a function which )takes a function_, which can accept two Chars and return a Char, and then returns a Char
15:43:27 <Axman6> what you want is Char -> Char -> Char -> Char
15:43:59 <Axman6> -- which is the same a Char -> (Char -> (Char -> Char))
15:44:34 <[itchyjunk]> hmmmm
15:45:46 <ChaiTRex> [itchyjunk]: Another way of looking at it is that it's always argument1 -> argument2 -> ... -> output. If you have (a -> b -> c) -> ..., the a -> b -> c is your argument1.
15:46:11 <ChaiTRex> [itchyjunk]: So, it's not three arguments, an a, a b, and a c. It's one argument, a function.
15:46:16 <Axman6> There is a very important rule in Haskell that remembering it can make a lot of difficult things easier. _all_ functions take _exactly_ _one_ argument
15:46:55 <[itchyjunk]> ah i see, that kinda clicked, ChaiTRex 
15:47:23 <Axman6> we sometimes say that functions take more than one argument, but we're being imprecise. The rule that functions take only one argument is _never_ broken, it's not possible to do anything else
15:47:48 <[itchyjunk]> right
15:48:12 <Axman6>  Char -> Char -> Char -> Char is the type of a functionw which takes a Char and returns  Char -> Char -> Char, which a function which takes a Char and returns  Char -> Char, which is a function which takes a Char and returns a Char
15:49:29 <[itchyjunk]> hmm right, i am composing functions?
15:49:40 <Axman6> no
15:49:50 <Axman6> to compose functions you need to have multiple function to compose
15:52:18 <ChaiTRex> [itchyjunk]: This is more towards currying if you're looking for a name. https://en.wikipedia.org/wiki/Currying
15:56:59 <MarcelineVQ> At this point it's notable that given  foo :: Char -> Char -> Char -> Char     foo a b c  is  (((foo a) b) c)   We're not composing but just applying each function we produce to another argument. Function arrows -> associate to the right, but function application associates to the left.
15:57:52 <[itchyjunk]> hmm
16:00:28 <Axman6> [itchyjunk]: if I give you a function with type f :: Bool -> String -> Int -> Double, and then apply it to True and "Hello",  what is the type of the value returned? f True "Hello" :: ?
16:02:45 <[itchyjunk]> its argument1 -> .. -> output. this has 2 argument, first is Bool and second is String hmm
16:03:14 <[itchyjunk]> so the output part would be Int -> Double but i am not sure
16:03:28 <Axman6> yep that's right
16:07:12 <zeta_0> mpickering: so i setup the nix environment variable but when i try to set Cabal as a dependency like ghcide tells me it throws this error? ghcide: <command line>: cannot satisfy -package-id Cabal-3.0.0.0-CD1INMNwoxXIKVgcu1nec5
16:07:14 <zeta_0> [zeta@nixos:/~]$ echo $NIX_GHC_LIBDIR 
16:11:16 <zeta_0> well, if anyone here could help me solve this problem, let me know, thanks
16:22:03 <[itchyjunk]> hmm, is there a way to now take a bunch of tuples and pass it to my function?
16:22:53 <ChaiTRex> [itchyjunk]: You mean your Char -> Char -> Char -> Char function?
16:23:37 <[itchyjunk]> yes, not i want a list of [(Char,Char),(Char,Char),..]
16:23:47 <[itchyjunk]> and these pairs to be my first to arguments
16:24:10 <[itchyjunk]> this way i can create a list of replacement arguments and such
16:24:29 <ChaiTRex> [itchyjunk]: You can make another function to take in a list of tuples and a Char and recursively apply your first function.
16:24:30 <[itchyjunk]> (i ram into that problem of ac to ca being aa or cc instead trying to do this manually)
16:25:08 <ChaiTRex> [itchyjunk]: Yeah, you'll run into that with this method, since you don't immediately stop trying to do more replacements once you find one.
16:25:27 <[itchyjunk]> right :(
16:25:43 <ChaiTRex> [itchyjunk]: I'd recommend starting over since not much has been done and do it recursively.
16:26:14 <ChaiTRex> [itchyjunk]: You have a [(Char, Char)] and a Char. Now, go recursively through the list until you find the Char.
16:26:20 <[itchyjunk]> :'D feels like a lot has been done. but maybe starting over is better here
16:26:30 <ChaiTRex> [itchyjunk]: Yeah, this way won't pan out.
16:26:45 <ChaiTRex> [itchyjunk]: It's not a bad first stab at it.
16:27:18 <ChaiTRex> [itchyjunk]: You have two cases: the recursive case with a nonempty list of tuples and the base case with an empty list of tuples.
16:27:37 <ChaiTRex> [itchyjunk]: So, write a line for each case.
16:27:45 <ChaiTRex> [itchyjunk]: The base case is probably easier.
16:29:00 <[itchyjunk]> hmm, why would i have an empty list of tuples?
16:29:19 <ChaiTRex> [itchyjunk]: As you go through the list of tuples, you'll have one less to consider each time.
16:29:39 <ChaiTRex> [itchyjunk]: Eventually, if you don't match any of the replacement characters, you'll have no more replacements to consider.
16:29:45 <jle`> [itchyjunk]: it's the same as asking the cost of zero apples and saying "why would i sell zero apples?"
16:30:05 <[itchyjunk]> jle`, why would i?!?
16:30:19 <[itchyjunk]> ChaiTRex, won't this also run into the ac, ca to aa,cc error?
16:30:30 <jle`> you wouldn't, but it's still a useful concept, for completion's sake :O
16:30:46 <jle`> for example if you had grocery list that was like (1) number of apples: _, (2) number of oranges: _
16:30:49 <[itchyjunk]> hmm i've never worked with case
16:30:57 <jle`> and someone wanted to ask what the cost of 0 apples, 3 oranges would be
16:31:00 <jle`> in total
16:31:05 <jle`> it's still useful to think that 0 apples costs $0
16:31:07 <ChaiTRex> [itchyjunk]: No, because you'll use an if statement in the recursive case. If you get a match, you just return the replacement character. Otherwise, you'll go to the next potential replacement.
16:31:13 <jle`> so that you can do $0 + cost of oranges
16:31:22 <jle`> otherwise you'd have to do something like ... write a special case
16:31:48 <jle`> basically the same reason the number 0 is useful in general
16:31:55 <ChaiTRex> [itchyjunk]: Since you immediately return once you get a match, you don't keep on to do further replacements of the replacement characters and so on.
16:31:57 <[itchyjunk]> oh for each character it will go through my list to see what to do, then move to next character
16:32:08 <ChaiTRex> [itchyjunk]: It'll go through the tuples.
16:32:25 <ChaiTRex> [itchyjunk]: If it matches the left element, it'll return immediately the right element.
16:32:35 <ChaiTRex> [itchyjunk]: If it doesn't, you go to the next tuple.
16:32:45 <ChaiTRex> [itchyjunk]: If you have no more tuples, you do something else.
16:33:11 <ChaiTRex> [itchyjunk]: This covers all your cases and won't replace a -> c -> a because it cuts off immediately after a -> c.
16:34:05 <ChaiTRex> [itchyjunk]: Writing recursive code with a recursive case and base case is a very good skill to have with Haskell.
16:34:31 <ChaiTRex> [itchyjunk]: 
16:34:37 <ChaiTRex> [itchyjunk]: You can solve lots of problems with it.
16:34:59 <[itchyjunk]> hmm
16:36:50 <ChaiTRex> [itchyjunk]: In fact, you can write a test case. doesItWork :: Bool; doesItWork = f [('a', 'c'), ('c', 'a')] "ac" == "ca"
16:37:05 <ChaiTRex> [itchyjunk]: When you think you've got it, try doesItWork.
16:37:43 <ChaiTRex> [itchyjunk]: Then you'll know it doesn't have the problem you mentioned.
16:42:46 <[itchyjunk]>  Variable not in scope: f :: [(Char, Char)] -> [Char] -> [Char]
16:43:43 <ChaiTRex> [itchyjunk]: Well, you'll need to change f there to your main function that handles Strings.
16:44:10 <ChaiTRex> [itchyjunk]: So, if it's whatever :: [(Char, Char)] -> String -> String, you'll replace f with whatever.
16:44:44 <[itchyjunk]> Hm, my replace looks like replace :: [(Char,Char)]->Char->Char
16:44:59 <[itchyjunk]> takes a list and a char and spits out a char?
16:46:08 <ChaiTRex> [itchyjunk]: Yeah, you'll have that function, then you'll have a function that maps that over a String.
16:46:17 <[itchyjunk]> ah
16:46:32 <ChaiTRex> [itchyjunk]: The function that maps it over the String is what I called f.
16:55:54 <[itchyjunk]> so my functions take a list and a character. i want to do |fst(list !! 0) == character = snd or somesuch
16:56:06 <[itchyjunk]> i think
16:56:19 <[itchyjunk]> hmm
16:57:20 <amalloy> instead of a list of replacements and a list of input characters, you could separate those two steps: first, consume a list of replacement rules to produce a single function of type Char -> Char, and then map that over a list of input characters
16:57:24 <ChaiTRex> [itchyjunk]: No, it's a bit different. Recursion to loop through a list is like this: f (x:xs) = do something with x
16:58:00 <ChaiTRex> [itchyjunk]: No need to do !! 0. The pattern match (x:xs) will take the first element of the list and assign it to x. The rest of the list after the first element goes into xs.
16:58:26 <ChaiTRex> [itchyjunk]: So, your patterns will be f ((a, b):xs) c = ...; f [] c = ...
16:58:26 <dmwit> (and the `x` can be a pattern match, too, to avoid needing fst and snd)
16:58:47 * dmwit high fives ChaiTRex for being v. helpful
16:59:27 <ChaiTRex> [itchyjunk]: ((a, b):xs) has (a, b) before the :, so that's the first element. It assigns the left element of the tuple to a. It assigns the right element of the tuple to b. It assigns the rest of the list after the first tuple to xs.
17:07:27 <[itchyjunk]> hmmm
17:08:01 <[itchyjunk]> i vaguely understand. i'll take a break and come back to this (x:xs) stuff. maybe finally figure out this magic recursion stuff /0\
17:09:28 <iqubic> Recursion is a fundamental part of Haskell.
17:10:04 <iqubic> However, before you understand recursion, you must understand recursion.
17:11:42 <ChaiTRex> iqubic: Yeah, it's tricky at first.
17:12:10 <iqubic> I know. But know that I understand it, I use it all the time.
17:20:46 <jchia> @Taneb: Thanks, Data.Data.Lens.upon looks like what I want.
17:20:47 <lambdabot> Unknown command, try @list
17:23:36 <jchia> Taneb: Thanks, it looks like Data.Data.Lens.upon is what I want.
17:24:08 <shachaf> jchia: You should probably not use upon in any serious code.
17:24:23 <shachaf> It's kind of a ridiculous function.
17:25:43 <jchia> shachaf: Why? Does it break some law? What about upon', onceUpon or onceUpon'?
17:25:52 <jackdk> how on earth does that work!?
17:28:30 <ChaiTRex> bedtimeStory = onceUpon aTime
17:28:53 * hackage generic-lens-lite 0.1 - Monomorphic field lens like with generic-lens  https://hackage.haskell.org/package/generic-lens-lite-0.1 (phadej)
17:29:54 * hackage generic-optics-lite 0.1 - Monomorphic field opics like with generic-lens  https://hackage.haskell.org/package/generic-optics-lite-0.1 (phadej)
17:30:41 <jackdk> rewriting filesystem timestamps: onceUpon atime
17:32:03 <shachaf> jchia: It's implemented using a ridiculous thing where it replaces different parts of a value with different exceptions, and then sees which exception was thrown.
17:32:27 <shachaf> It's very inefficient and pretty fragile.
17:32:38 <shachaf> It's generally a better idea to just write the lens.
17:32:41 <jackdk> that's cursed!
17:33:48 <jchia> Or, I'll just use generic-lens.
17:34:32 <jchia> Wouldn't have known the shady implementation just looking at the docs
17:39:38 <iqubic> I really wish dependent haskell was a thing I could have right now.
17:40:31 <ChaiTRex> How would a suggested change to how gcd and lcm from Prelude are implemented be proposed?
17:40:34 <dmwit> shachaf: What if the library just didn't export that?
17:40:50 <ChaiTRex> :t gcd
17:40:51 <lambdabot> Integral a => a -> a -> a
17:40:55 <dmwit> Or like. Didn't even define it in the first place.
17:41:24 <dmwit> ChaiTRex: That would probably be at the level of a language proposal.
17:41:31 <dmwit> gcd and lcm are right there in the Prelude, yeah?
17:41:58 <ChaiTRex> dmwit: Yes, they are.
17:42:26 <phadej> of all the things, they are in prelude :)
17:42:36 <ChaiTRex> How are language change proposals made?
17:42:44 <jle`> good question
17:42:49 <jle`> we're still figuring this out :)
17:42:53 <ChaiTRex> For like Haskell 202x.
17:43:04 <dmwit> instructions here: https://github.com/ghc-proposals/ghc-proposals
17:43:08 <ChaiTRex> Thanks.
17:43:29 <phadej> 202x changes don't go there
17:43:31 <phadej> :)
17:44:04 <shachaf> dmwit: Didn't export upon?
17:44:06 <phadej> (libraries related changes go to libraries mailing list, and about actual language report, i have no idea)
17:44:17 <dmwit> Okay. I don't know if the goal is a 202x change, or how the goals would inform the choice between a GHC proposal and a 202x proposal.
17:44:30 <dmwit> shachaf: yes
17:44:55 <phadej> dmwit: 202x change would be "standardize what have been in GHC for last 5 years or so; or better decade"
17:44:57 <shachaf> I guess it's nice for some interactive uses? I don't have a strong opinion.
17:45:22 <ChaiTRex> Basically, I think gcd and lcm should be typeclass functions rather than standalones so that symbolic algebra types can implement them symbolically by replacing the default implementation.
17:45:57 <iqubic> phadej: So will overloaded strings and such useful pragmas get added to haskell 202x
17:46:38 <dmwit> Wow, I really hope OverloadedStrings doesn't go in 202x.
17:46:51 <dmwit> That one would really break a lot of code.
17:46:58 <iqubic> It would? How so?
17:47:21 <dmwit> A lot of things suddenly become more polymorphic; consequently a lot of types suddenly become ambiguous.
17:47:27 <phadej> https://github.com/haskell/rfcs/projects/1 based on that, no.
17:48:21 <iqubic> Wait... What is this about removing Monad Plus?
17:48:37 <iqubic> Is that because it's basically just a stricter version of Alternative?
17:48:51 <jle`> iqubic: you can click the link
17:48:55 <jle`> and it will take you to the discussion
17:49:32 <iqubic> https://github.com/haskell/rfcs/pull/23
17:49:50 <iqubic> jle`: There's no discussion on that front.
17:49:57 <jle`> the link to the rendered proposal
17:50:03 <jle`> describes the motivation and reasoning
17:51:03 <iqubic> Ah.
17:55:46 <nshepperd2> was there some sort of difficulty with allowing IsString a => a to default to [Char]?
19:21:27 <electricityZZZZ> so i just came across the meaning of <$> ... as you can tell i am a noob. i expected that, given how exotic such a thing looks, and how advanced and complex haskell appears to outsiders that it represented something quite advanced... but apparently it's just infix map. my question is:
19:22:03 <electricityZZZZ> it seems crazy that somebody would include such a ridiculous symbol in a language, especially for a concept as trivial as map. why was it included in haskell?
19:22:12 <Axman6> it's just map generalised to all things which can be mapped, also known as Functors
19:22:35 <electricityZZZZ> ok, so it isn't the same thing as map?
19:22:39 <Axman6> because it's very frequently combined with <*>
19:23:10 <dmwit> It is not the same thing as map.
19:23:15 <dmwit> It is the same thing as fmap.
19:23:27 <Axman6> > (\a b c -> (a,b,c)) <$> [1,2,3] <*> "ABC" <*> [True,False]
19:23:29 <lambdabot>  [(1,'A',True),(1,'A',False),(1,'B',True),(1,'B',False),(1,'C',True),(1,'C',F...
19:24:10 <Axman6> many functions in Haskell have an infix version, because it can make code clearer in certain contexts
19:24:32 <dmwit> It was given that symbol because it resembles $ (for function application) in a diamond (which mnemonically means "inside some data structure"). There is also a * inside a diamond, for combining two data structures.
19:24:57 <Axman6> also, <$> isn't part of Haskell the language really, it's just another function, which happens to be insanely useful
19:25:07 <dmwit> (It is the ASCII-ization of a symbol used in an academic paper, and it looks pretty good in the paper and only mildly worse in ASCII.)
19:25:19 <Axman6> you'd be surprised how much code in other languages is just some form of <$>
19:25:35 <electricityZZZZ> hmm?
19:26:08 <Axman6> probably a third of all for loops are just a form of fmap
19:26:22 <dansho> haskell obsession with operators is kind of annoying
19:26:24 <Axman6> another third are some form of Applicative and or fold
19:26:43 <Axman6> not when you're used to them, then it makes the important parts of the code stand out
19:26:45 <electricityZZZZ> oh,... sure,... sorta... except that if you really care about writing a for loop these days you probably care about cache behavior and other low level stuff
19:27:28 * dmwit squints
19:27:43 <dmwit> That's almost certainly not true for most programmers.
19:28:03 <Axman6> yeah I would have to disagree with that statement quite strongly
19:28:29 <dmwit> Also I don't see how it's relevant.
19:28:33 <dmwit> Even if it were true.
19:28:37 <electricityZZZZ> i've written a lot of numeric code and historically i can make things fast only if i 1) tune for loops myself or 2) use some linalg package carefully which has been written by hundreds of phds over years,... cant compete with that
19:29:55 <Axman6> I can pretty much guarantee that those packages were not written by PhDs - they would be much slower if they were :P Engineers on the other hand
19:30:40 <electricityZZZZ> well whatever, numerical linear algebra experts. but i meant to highlight the first case, which is that i've been burned by moving away from simple for loops in the past
19:31:05 <electricityZZZZ> but yeah i'm trying to entertain the haskell philosophy
19:32:56 <dansho> optimized haskell is not very pretty https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/mandelbrot-ghc-3.html
19:34:53 <c_wraith> it's not worse than optimized C.  in fact, it's basically the same.
19:35:03 <Axman6> much of the hand optimisation in there is probably unnecessary these days - it was written that way to ensure it produced exactly the code that was needed. most of the benchmarks are designed to suit imperative languages well, so you end up having to write gross imperative code to compete. this is particularly clear from the number of times they've changed the rules because the Haskell definitions did so much better than the others
19:35:32 <Axman6> having submitted several entries to the shootout, I've seen a lot of what's happened
19:36:06 <electricityZZZZ> somebody should write an "idiomatic shootout"
19:36:41 <c_wraith> yeah, there are a lot of problems where the Haskell code has to do more work than other languages because otherwise it would do less work and they can't allow that.
19:36:50 <Axman6> those code is probably not too far off what the Repa version would produce
19:36:58 <dibblego> fork the rules
19:38:29 <ammar2> hmm, what rules did they change?
19:39:57 <electricityZZZZ> so if i took some random chunks of memory from a variety of haskell programs, am i going to find that they are working principally with lists?
19:40:23 <Axman6> binary trees forced the binary tree to be made manifest in memory, the Haskell version would completely optimise it away before that. they also stopped requiring languages to use their native threading features when the Haskell rung benchmark was smashing everything else using its green threads and MVars. now most of the languages are using "co-routine" libraries which don't have any actual notion of threads
19:40:41 <electricityZZZZ> or are lists one of those beginner constructs which nobody actually uses?
19:40:43 <Axman6> looks like they got rid of that benchmark completely
19:41:25 <dansho> lists in haskell are more for control flow than storing data per se
19:41:32 <Axman6> electricityZZZZ: you'll find that the lists almost never exist at all. lists are control flow just as much as they are data structures
19:42:45 <electricityZZZZ> so what am i going to find in memory... it would be super interesting to see snapshots comparing memory layout across languages
19:44:32 <Axman6> you'll mostly find objects with pointers to other objects. occasionally pointers to thunks which will be replaced by objects. plenty of data in arrays if you're usong a lot of ByteStrings or Text
19:46:01 <Axman6> Haskell programs are very confusing when disassembled - I've spoken to a few security people about what they look like, and I'm pretty convinced if you want to write malware which confuses the hell out of tools, Haskell is a great choice. you'll basically never find a `call1 or `ret` anywhere
19:46:23 <electricityZZZZ> haha ok
19:47:10 <electricityZZZZ> thankfully thats not my interest, i am just trying to see whether haskell is suitable for my productivity, or whether i can take away some learnings at least
19:51:06 <ChaiTRex> electricityZZZZ: it can help you with functional programming in other languages, recursion, ways of thinking through problems, etc even if you don't end up using it as your main language.
19:53:10 <electricityZZZZ> > (+) <$> [1, 2, 3] <*> [2, 3, 4]     // the presence of <*> appears to change the type of the fmap result... it looks like it interprets the array as something which is appended to
19:53:12 <lambdabot>  <hint>:1:53: error: parse error on input ‘of’
19:53:33 <electricityZZZZ> > (+) <$> [1, 2, 3] <*> [2, 3, 4]
19:53:36 <lambdabot>  [3,4,5,4,5,6,5,6,7]
19:53:36 <MarcelineVQ> comments are -- instead of //
19:53:58 <ChaiTRex> electricityZZZZ: no, it's a cartesian product rather than zip
19:54:09 <electricityZZZZ> > (+) <$> [1, 2, 3] <*> [2, 3, 4] <*> [5, 6, 7, 8]
19:54:11 <lambdabot>  error:
19:54:11 <lambdabot>      • Could not deduce (Num a0)
19:54:11 <lambdabot>        from the context: (Num a, Num (a -> b))
19:54:41 <MarcelineVQ> (+) <$> [1, 2, 3]   becomes  [(1 +), (2 +), (3 +)]
19:55:29 <Axman6> there's nothing magic going on here, you just need to follow the types.
19:55:35 <Axman6> :t ((+) <$>)
19:55:37 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
19:56:02 <Axman6> :t (\xs -> (+) <$> xs) -- same thing, just a little more clear
19:56:03 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
19:56:44 <electricityZZZZ> oh so an array is treated as something which can cartesian product with another array, it is both data and a function?
19:56:56 <Axman6> :t (\xs ys -> (+) <$> xs <*> ys) -- because (<*>) :: f (a -> b) -> f a -> f b
19:56:58 <lambdabot> (Applicative f, Num b) => f b -> f b -> f b
19:56:58 <Axman6> no
19:58:10 <Axman6> firstly, these are not arrays, they are lists. secondly there's nothing pspecial about them, they are either empty, or some value appended to another list.
19:58:53 <Axman6> what f <$> xs <*> ys _means_ for lists is apply f to each value in xs, and for each of the applicatins apply that new function to each value in ys
19:59:12 <Axman6> > f <$> [a,b] <*> [x,y] :: [Expr]
19:59:15 <lambdabot>  [f a x,f a y,f b x,f b y]
20:02:32 <electricityZZZZ> so (f <$> list) gives me type list... but if i do (f <$> list <*>) that has type function of list -> list ...?
20:03:13 <Axman6> yes (assuming you've got the brackets in the right place, but conceptually you are correct)
20:03:30 <Axman6> > (+1) <$> Just 7
20:03:32 <lambdabot>  Just 8
20:03:42 <Axman6> > (+1) <$> [1..10]
20:03:45 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:04:09 <Axman6> > (+1) <$> Right 15 :: Either String Int -- needed because GHC needs to know that the other type variable in the Either is
20:04:11 <lambdabot>  Right 16
20:04:26 <Axman6> > (+1) <$> pure 10 :: IO Int
20:04:29 <lambdabot>  <IO Int>
20:05:02 <electricityZZZZ> > [2, 3, 4] <*> [5, 6, 7, 8]
20:05:04 <lambdabot>  error:
20:05:04 <lambdabot>      • Could not deduce (Num a0)
20:05:04 <lambdabot>        from the context: (Num a, Num (a -> b))
20:05:27 <Axman6> % :t (<*>) @[]
20:05:27 <yahb> Axman6: [a -> b] -> [a] -> [b]
20:06:08 <Axman6> for lists, <*> takes a list of functions, and a list of values those functions can be applied to, and applies each function to each value
20:06:17 <electricityZZZZ> typeof( (+) <$> [1, 2, 3] <*> [2, 3, 4] ) is list
20:06:27 <Axman6> :t (+) <$> [1,2,3]
20:06:28 <lambdabot> Num a => [a -> a]
20:06:34 <Axman6> yes
20:06:48 <Axman6> see how that has the right type to pass to <*> now?
20:07:03 <electricityZZZZ> typeof( (+) <$> [1, 2, 3] <*> [2, 3, 4] <*> [5, 6, 7, 8] ) is list
20:07:05 <Axman6> :t \xs -> xs <*> [4,5,6]
20:07:07 <lambdabot> Num a => [a -> b] -> [b]
20:07:14 <Axman6> no, that doesn't type check
20:07:34 <Axman6> because (+) ocan only be applied to two arguments
20:07:57 <electricityZZZZ> but typeof ( [10, 11, 12] <*> [5, 6, 7, 8] ) is error go bug irc
20:08:37 <Axman6> yea
20:08:45 <electricityZZZZ> oh i see, i am making some kind of wrong assumption about operator precedence here
20:08:47 <Axman6> the beackets associate to the left, not the right
20:09:22 <Axman6> (+) <$> [1,2,3] <*> [4,5,6] is ((+) <$> [1,2,3]) <*> [4,5,6]  not (+) <$> ([1,2,3] <*> [4,5,6])
20:10:10 <electricityZZZZ> > ((+) <$> [1, 2, 3]) <*> [2, 3, 4] <*> [5, 6, 7, 8]
20:10:13 <lambdabot>  error:
20:10:13 <lambdabot>      • Could not deduce (Num a0)
20:10:13 <lambdabot>        from the context: (Num a, Num (a -> b))
20:11:43 <Axman6> (+) <$> [1,2,3] <*> [4,5,6] is the same as (\x y -> x+y) <$> [1,2,3] <*> [4,5,6]. after evaluating the <$> we have [\y -> 1+y, \y -> 2+y, \y -> 3+y] <*> [4,5,6]
20:11:59 <Axman6> :t [\y -> 1+y, \y -> 2+y, \y -> 3+y]
20:12:00 <lambdabot> Num a => [a -> a]
20:12:27 <Axman6> maybe this will help
20:12:42 <Axman6> :t \f xs ys -> f <$> xs <*> ys
20:12:43 <lambdabot> Applicative f => (a1 -> a2 -> b) -> f a1 -> f a2 -> f b
20:12:51 <Axman6> :t \f xs ys xs -> f <$> xs <*> ys <*> xs
20:12:53 <lambdabot> error:
20:12:53 <lambdabot>     • Conflicting definitions for ‘xs’
20:12:53 <lambdabot>       Bound at: <interactive>:1:4-5
20:12:57 <Axman6> :t \f xs ys xs -> f <$> xs <*> ys <*> zs -- oops
20:12:58 <lambdabot> error:
20:12:58 <lambdabot>     • Conflicting definitions for ‘xs’
20:12:58 <lambdabot>       Bound at: <interactive>:1:4-5
20:13:05 <Axman6> :t \f xs ys zs -> f <$> xs <*> ys <*> zs -- oops
20:13:06 <lambdabot> Applicative f => (a1 -> a2 -> a3 -> b) -> f a1 -> f a2 -> f a3 -> f b
20:13:51 <Axman6> notice that this idiom take a function of n arguments and lets you apply it to n things in some context f
20:14:01 <electricityZZZZ> it's really hard to read but i'm trying,... to some extent this is a triviality so dont worry too much about it but i am trying to figure out whether the ordering of the parsing is weird or haskell is using some kind of implicit polymorphism
20:14:06 <Axman6> f can be list, it can be Maybe, it can be IO
20:15:01 <electricityZZZZ> does haskell implicitly convert types?
20:15:06 <Axman6> it's nothing to do with parsing, but what you are writing is _technically_ possible, it is possible to write an instance for Num for (a -> a), but we don't actually have one. 
20:15:29 <Axman6> what's happening inmyour code is you are trying to use a list of numbers as if it were a list of functions
20:16:13 <electricityZZZZ> right, and it looks to me like haskell accepts that if i have the fmap and the applicative there, but if i directly denote the list, haskell complains
20:16:18 <electricityZZZZ> which is making my eyes cross
20:16:32 <Axman6> no, it never implicitly converts anything (it sort of looks like it does when you write 1 and it's an Int, and later you write 1 and it's a Double, but this because in Haskell, the string "1" in source code actually means fromInteger (1::Integer)
20:17:33 <electricityZZZZ> ok
20:20:53 * hackage hanabi-dealer 0.3.1.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.3.1.0 (SusumuKatayama)
20:42:41 <iqubic> jle`: I'm just now getting around to reading your Adjunctions and foldl blog post.
20:42:48 <iqubic> It's should be a good read.
20:43:06 <iqubic> I've wondered what good adjunctions are ever since learning about them.
20:52:31 <electricityZZZZ> so i want a 2d array of something, probably simple something like u8 or i64, but sometimes complicated something,... what is the data structure of choice for this?
20:53:38 <ChaiTRex> electricityZZZZ: Vector is pretty good. For u8, Data.Word.Word8 and for i64, Data.Int.Int64.
20:54:36 <ChaiTRex> electricityZZZZ: https://hackage.haskell.org/package/vector
20:55:16 <ChaiTRex> electricityZZZZ: You'll want unboxed vectors for both of those types.
21:19:25 <iqubic> What's the point of Control.Comonad.Representable.Store in adjunctions and how does it differ from a regular store monad?
21:22:22 <Axman6> link?
21:22:48 <shachaf> "A memoized store comonad parameterized by a representable functor g, where the representatation of g, Key g is the index of the store."
21:22:52 <shachaf> That sounds like an answer to me.
21:23:22 <Axman6> whatever that means
21:24:45 <iqubic> But how does it do that memoization?
21:25:10 <jle`> 'it' is the instance of Representable you use
21:25:18 <jle`> and different instances can do it in different ways
21:26:07 <jle`> for example i think you're familiar with vector-sized
21:26:21 <jle`> where 'memoization' is just the items stored in the vector
21:26:45 <iqubic> So, the Representable Store Comonad only does memoization if the base Functor does memoization?
21:26:54 <iqubic> Also, I know of vector-sized.
21:27:10 <jle`> i wouldn't really call it a 'base functor'
21:27:30 <jle`> but yeah `Store f` does whatever memoization that `f` does. its lookup process comes from `f`
21:27:55 <iqubic> I see.
21:28:32 <iqubic> So I found this version of the Game of Life using the comonad.https://stackoverflow.com/questions/45506813/performance-of-conways-game-of-life-using-the-store-comonad
21:28:58 <iqubic> The poster stated that it was slow. The accepted answer shows that you can use MemoTrie to speed it up.
21:29:11 <iqubic> Could you use a Representable Store Comonad instead?
21:29:44 <iqubic> type Pos = (Int, Int)
21:29:57 <iqubic> Store Pos Bool
21:31:21 <iqubic> I mean, would using a Representable Store Comonad provide the same increase in speed as the MemoTrie approach?
21:39:40 <ChaiTRex> Is f n = n:f (n + 1) a corecursive function?
21:40:34 <Axman6> I wouldn't say so
21:41:01 <ChaiTRex> What's an example of a simple corecursive function?
21:41:02 <iqubic> What do you mean by corecursive?
21:41:03 <Axman6> I mean technically (:) is a function, but all it's doing is allocating
21:41:29 <ChaiTRex> iqubic: Whatever CS people mean by it. I'm not sure what it means yet.
21:41:37 <iqubic> Ah. I see.
21:41:45 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000 -- this is my favourite corecursive function, not exactly trivial though
21:41:49 <lambdabot>  104743
21:42:06 <Axman6> primes is defined in terms of isPrime, and isPrime is defined in terms of primes
21:42:49 <iqubic> Is that the Sieve of Eratosthenes?
21:42:53 <ChaiTRex> Axman6: So corecursive, like the dual to recursive, means two functions that call each other?
21:43:38 <iqubic> I think that's also called mutual recursion.
21:43:49 <Axman6> I'm not sure I have a good definition for what it means to be corecursive
21:44:02 <Axman6> hmm, perhaps mutual recursion is a better term for what's going on there
21:44:48 <Axman6> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/corecursive.pdf looks relevant
21:44:53 <iqubic> The only version of corecursion I know of is the stuff from Recursion-Schemes.
21:45:05 <iqubic> So, anamorphism / unfoldr
21:45:44 <iqubic> But I have no idea if that's the same sort of thing.
21:47:13 <ChaiTRex> Axman6: Ahh, that looks nice. Thanks.
21:47:51 <ChaiTRex> iqubic: I haven't learned what anamorphism is and I don't have much experience with unfolds.
21:48:35 <iqubic> Totally fine. It's not really what you're looking for right now.
21:48:54 * hackage network-run 0.2.2 - Simple network runner library  https://hackage.haskell.org/package/network-run-0.2.2 (KazuYamamoto)
21:49:26 <iqubic> In fact, I can safely say it ISN'T what you're looking for.
22:09:24 * hackage bench-show 0.3.1 - Show, plot and compare benchmark results  https://hackage.haskell.org/package/bench-show-0.3.1 (harendra)
22:11:50 <Ailrun[m]> ChaiTRex: "corecursive" as a dual concept of "recursive" is just a dual of "recursive". This is tautological, though.
22:12:35 <iqubic> Which one you decided to call it "obeying the monad laws" instead of "legally binding"?
22:54:37 <mniip> recursive in a fairly specific sense though
22:54:52 <mniip> recursion as in the dependent counterpart to induction
23:39:52 <madnight> Cale: hm, okay
