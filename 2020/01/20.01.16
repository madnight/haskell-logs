00:00:04 <c_wraith> With the sort of dependent typing proposed for the Dependent Haskell project, yes.
00:00:26 <dminuoso_> I see
00:01:12 <c_wraith> You could propose a dependent typing system with special support for throwing an SMT solver at things that the user marks as likely solvable by one.  That sounds somewhere between useful and ad-hoc mess. :)
00:01:24 * hackage mmsyn7h 0.5.1.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.5.1.0 (OleksandrZhabenko)
00:40:23 * hackage mu-grpc-server 0.1.0.1 - gRPC servers for Mu definitions  https://hackage.haskell.org/package/mu-grpc-server-0.1.0.1 (AlejandroSerrano)
01:23:57 <dminuoso_> Mmm, Im trying to use packunused with cabal 3, but specifying ddump-minimal-imports does not appear to generate any import files
01:24:55 <dminuoso_> (Or whatever file packunused wants)
01:42:56 <alc```> @let l = [1,0,0,2,5,3]
01:42:57 <lambdabot>  Defined.
01:43:09 <alc```> @let gl = group l
01:43:10 <lambdabot>  .L.hs:163:12: error:
01:43:10 <lambdabot>      Ambiguous occurrence ‘l’
01:43:10 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.l’,
01:43:39 <alc```> @let gl = group [1,0,0,2,5,3]
01:43:42 <lambdabot>  Defined.
01:43:57 <alc```> what's the easy way to get [2,5,3]?
01:44:12 <dminuoso_> alc```: What's the desired semantics?
01:44:15 <dminuoso_> (I dont want to guess here)
01:44:19 <alc```> in python, gl:[3::]
01:44:33 <alc```> dminuoso_: from position 3 to end
01:44:38 <dminuoso_> % :t drop
01:44:38 <yahb> dminuoso_: Int -> [a] -> [a]
01:44:39 <dminuoso_> alc```: ^_
01:44:45 <dminuoso_> % drop [1,0,0,2,5,3]
01:44:45 <yahb> dminuoso_: ; <interactive>:27:6: error:; * Couldn't match expected type `Int' with actual type `[Integer]'; * In the first argument of `drop', namely `[1, 0, 0, 2, ....]'; In the expression: drop [1, 0, 0, 2, ....]; In an equation for `it': it = drop [1, 0, 0, ....]
01:44:47 <dminuoso_> % drop 3 [1,0,0,2,5,3]
01:44:47 <yahb> dminuoso_: [2,5,3]
01:45:03 <alc```> dminuoso_: what about position 3 to 4?
01:45:10 <alc```> [2,5]
01:45:41 <dminuoso_> alc```: Well random indexing is not really the best idea on lists.
01:45:47 <alc```> dminuoso_: python's slice is very useful, why it's not in Data.List?
01:45:50 <dminuoso_> For [] you could do `take 1 . drop 3` though.
01:45:58 <koz_> alc```: Because Python 'lists' are arrays.
01:46:11 <koz_> And this has been the cause of a lot of broken thinking, because the two structures are nothing alike.
01:46:14 <dminuoso_> alc```: Because Haskell lists are not a good fit for random indexing.
01:46:39 <koz_> An array can be sliced or indexed at random no problem. A (actual normal vocabulary meaning) list does both things very badly.
01:46:50 <alc```> koz_: then haskell has array?
01:47:04 <koz_> alc```: Yes, but we usually use the wrappers in the vector library.
01:47:12 <koz_> 'Raw' arrays aren't very pleasant to work with.
01:47:14 <dminuoso_> or lists or seqs.
01:47:25 <dminuoso_> Huh? Sure they are.
01:47:37 <koz_> dminuoso_: I'm pretty sure neither lists or seqs support random access.
01:47:45 <koz_> (unsure about seqs)
01:47:54 <merijn> Depends on how yu define "support random access"
01:48:05 <koz_> merijn: In the 'efficiently' sense.
01:48:09 <dminuoso_> alc```: Anyhow. If you look at vector, for instance, you have slice.
01:48:18 <dminuoso_> % import Data.Vector
01:48:18 <yahb> dminuoso_: 
01:48:24 <dminuoso_> % import qualified Data.Vector as V
01:48:24 <yahb> dminuoso_: 
01:48:42 <merijn> alc```: We have several array types, the "vector" package is probably the best if you have 1 dimensional arrays
01:48:45 <dminuoso_> $ slice 3 2 V.fromList [1..10]
01:48:47 <dminuoso_> % slice 3 2 V.fromList [1..10]
01:48:47 <yahb> dminuoso_: ; <interactive>:31:1: error:; * Couldn't match expected type `[Integer] -> t' with actual type `Vector a1'; * The function `slice' is applied to four arguments,; but its type `Int -> Int -> Vector a1 -> Vector a1' has only three; In the expression: slice 3 2 Data.Vector.fromList [1 .. 10]; In an equation for `it': it = slice 3 2 Data.Vector.fromList [1 .. 10]; * Relevant bin
01:48:50 <dminuoso_> % V.slice 3 2 V.fromList [1..10]
01:48:50 <yahb> dminuoso_: ; <interactive>:32:1: error:; * Couldn't match expected type `[Integer] -> t' with actual type `Vector a1'; * The function `slice' is applied to four arguments,; but its type `Int -> Int -> Vector a1 -> Vector a1' has only three; In the expression: slice 3 2 Data.Vector.fromList [1 .. 10]; In an equation for `it': it = slice 3 2 Data.Vector.fromList [1 .. 10]; * Relevant bin
01:48:51 <alc```> ok
01:49:00 <merijn> dminuoso_: Parentheses...
01:49:07 <dminuoso_> % V.slice 3 2 (V.fromList [1..10]) -- koz_ 
01:49:08 <yahb> dminuoso_: [4,5]
01:49:25 <dminuoso_> merijn: See, everything associated *just fine* in my mind.
01:49:31 <dminuoso_> I blame GHC.
01:49:40 <merijn> Amateur :p
01:49:52 <dminuoso_> alc```: ^- even. There
01:50:01 <koz_> dminuoso_: Was about to say, lol. :P
01:50:10 * koz_ would like to believe he knows how to use vector. :P
01:50:11 <dminuoso_> alc```: Though, ergonomics wise it's the sake as `take 2 . drop 3` - just with better asymptotics.
01:53:12 <alc```> then what's haskell's list?
01:53:19 <alc```> the other name in other languages
01:53:40 <koz_> alc```: Haskell's list is a singly-linked list in regular parlance.
01:53:44 <alc```> can we think haskell's record is like structure in C?
01:54:05 <koz_> alc```: Similar, but Haskell records are immutable, whereas C structs are mutable.
01:54:12 <dminuoso_> alc```: The names are all synonyms.
01:54:38 <koz_> Also, Haskell record field names are scoped differently to C struct field names.
01:54:47 <dminuoso_> alc```: We have lists, vectors, arrays, seqs... these names don't carry any semantics
01:54:49 <alc```> ok
01:54:59 <dminuoso_> We could have called our lists arrays, and arrays vectors, and called the vectors foothings.
01:55:05 <dminuoso_> Wouldn't have changed anything.
01:55:15 <alc```> that sound stupid like java has
01:55:40 <alc```> I still don't know what's wrong with java's List Array and ArrayList or blablabla
01:55:45 <dminuoso_> alc```: Even String is in the same area. The core idea is that it's a sequential container of sorts
01:55:53 <alc```> why there're so many names
01:56:02 <dminuoso_> alc```: Because there are so many different interpretations, takes and implementations.
01:56:09 <dminuoso_> They are all "sequential containers" of sorts
01:56:12 <koz_> alc```: There's nothing 'wrong' with them. An ArrayList is a dynamic array, and a LinkedList is a doubly-linked list.
01:56:19 <dminuoso_> With different purposes, different asymptotics, different interfaces, different implementations.
01:56:25 <koz_> They have different names as they have different behaviour performance-wise.
01:56:28 <koz_> (and memory-wise)
01:56:59 <alc```> but in other languages, it seems there're not that many names
01:57:09 <dminuoso_> alc```: Some other languages have far less variations.
01:57:13 <dminuoso_> That is limiting in some sense.
01:57:23 <koz_> If they're not outright confusing people.
01:57:24 <merijn> Also, plenty of languages have just as many names
01:57:27 * koz_ looks askance at Python.
01:57:28 <merijn> See Rust, C++, etc.
01:57:53 <dminuoso_> alc```: Having access to all these different things is great because you can always pick the data type best for your task.
01:58:01 <merijn> Data structures have trade-offs and the Python approach is "2-3 data structures is enough for everybody!" and for most common stuff it's fine, but for niche stuff it's not
02:01:21 <dminuoso_> ^^^ this
02:01:52 <koz_> Much this.
02:09:23 <tdammers> you can still do the python thing if you want, and just use Vector, Map and Set for everything
02:09:41 <tdammers> (and obv. Text for strings and ByteString for byte arrays)
02:14:04 <koz_> tdammers: And use Dynamic for everything else. :P
02:14:09 <koz_> (for the authentic Python experience)
02:14:47 <tdammers> not quite, because Dynamic is still type-safe, in the sense that it forces you to deal with runtime type mismatches
02:31:52 <maerwald> golfing question: shorthand for 'fmap (<|>)'?
02:32:24 <merijn> None
02:32:32 <merijn> Unless you have more context/code
02:34:53 <koz_> (<|>) <$> is one symbol less. :P
02:41:27 <Taneb> maerwald: that's a bit of a weird thing to do
02:41:43 <Taneb> (Functor f, Alternative g) => f (g a) -> f (g a -> g a)?
02:45:08 <dminuoso_> tdammers: Nah it doesn't. You can just unsafeCoerce your way out of every corner.
02:45:30 <dminuoso_> So gaining back the *power* to (not) deal with horrible errors at runtime is completely possible with Haskll.
02:47:36 <tdammers> or just import Prelude.PHP from the acme-php package
02:47:48 <tdammers> then you can do math on strings. badly.
02:59:41 <maerwald> :t \x -> fmap (<|> x)
02:59:42 <lambdabot> (Alternative f1, Functor f2) => f1 a -> f2 (f1 a) -> f2 (f1 a)
02:59:43 <maerwald> sorry, meant that
03:00:18 <maerwald> imagine IO (Maybe a)
03:02:23 * hackage aws-lambda-haskell-runtime 2.0.3 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-2.0.3 (NickSeagull)
03:03:33 <Solonarv> guess you could write this as: (<|>x)<$>thng
03:04:01 <maerwald> that's pretty much the same and I usually prefer fmap over <$> unless there already is a $
03:04:59 <Solonarv> you asked for golfing, so you get a less-readable version that saves one character
03:05:02 <maerwald> lol
03:05:03 <Solonarv> no complaining! ;)
03:05:22 <maerwald> maybe there's a lens thing
03:05:41 <Solonarv> I kind of doubt it
03:06:07 <Putonlalla> More and more, I feel like Coq got it right by keeping notations separate from definitions.
03:06:31 <Solonarv> I agree and now have to go
03:06:53 <Putonlalla> You'd have `fmap` with the infix notation `_ <$> _`, which can be toggled.
03:35:18 <Phyx-> 04:11:27 < jle`> that's how unix works <--that's how windows works too
03:37:12 <maerwald> is there a guarantee that MonadError corresponds to Alternative?
03:37:29 <dminuoso_> No.
03:37:45 <maerwald> so I might do throwError and Alternative will crash/short-circuit or something
03:39:10 <dminuoso_> maerwald: Consider `MonadError e (Either e)` on a parser.
03:39:11 <maerwald> the problem is that 'empty' doesn't allow to set the error message... same for MonadFail partial pattern matching
03:39:55 <dminuoso_> Err strike that exampl
03:39:59 <maerwald> I'm in IO, not parsing
03:40:14 <maerwald> so I currently use 'fail' + Alternative, which works fine, but is a bit unwieldy
03:40:22 <maerwald> still requires explicit pattern matching
03:40:35 <dminuoso_> maerwald: Do you need to write polymorphic code?
03:40:45 <dminuoso_> Or do you have a monomorphized monad you are working with?
03:41:21 <maerwald> it would be nice if it works for more than just IO
03:41:39 <dminuoso_> maerwald: You could just set your MonadFail instance up to use the same mechanism that works with Alternative
03:42:11 <maerwald> yes, that's the case for IO, but there is no guarantee
03:42:17 <maerwald> so I was wondering if there is an API that gives that guarantee
03:44:53 <maerwald> seems sketchy to rely on different instances to have corresponding behavior
03:46:03 <dminuoso_> maerwald: The main issue is that MonadThrow requires actually having an error that you can pass around
03:46:17 <dminuoso_> Alternative doesn't care since it's just empty
03:46:40 <dminuoso_> So what you are asking for cant be a law
03:46:41 <maerwald> yeah, you cannot adjust the error for both Alternative and MonadFail
03:46:59 <maerwald> so the error message is basically useless
03:47:05 <dminuoso_> maerwald: Can you elaborate on what you are trying to do?
03:47:19 <dminuoso_> Maybe there's something else that's better suited
03:47:29 <maerwald> carry out several IO actions, all of which might throw different io errors and collect the result of the first succeeding one
03:47:55 <dminuoso_> And you want to shortcircuit on success?
03:47:57 <maerwald> in some cases, I will pattern match on resullts in such an IO action and manually raise another io error
03:48:04 <maerwald> yes
03:48:39 <maerwald> so there is a lot of: Nothing -> fail "blah" -- which is basically throwIO
03:49:16 <maerwald> I was hoping to assemble a combinator that basically does that... now when something is "zero-ish" in the result and translate it into an error
03:49:22 <maerwald> *know
03:50:24 * hackage prettyprinter-graphviz 0.1.0.0 - a prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-0.1.0.0 (GeorgeThomas)
03:50:36 <dminuoso_> maerwald: asum then.
03:50:43 <maerwald> yes, I already use that
03:50:49 <maerwald> but that doesn't solve the problem
03:51:13 <dminuoso_> maerwald: I see. well what you are asking for is MaybeT, essentially, no?
03:51:23 <maerwald> exactly, but without using transformers
03:51:37 <dminuoso_> Well.. the MaybeT transformer is that elegant solution.
03:52:25 <maerwald> I believe there's no reason to have transformers for this problem, there should be a simpler solution
03:52:55 <maerwald> the inner monad sharing a constraint with the outer monad and then being able to propagate the error up
03:53:07 <maerwald> but I don't see a class that can do that sensibly
03:53:14 <Rembane> That sounds like a transformer stack.
03:53:23 <maerwald> no
03:53:34 <dminuoso_> Transformers is that.
03:54:09 <Rembane> maerwald: Why not?
03:55:47 <maerwald> https://git.io/JvUxk
03:56:16 <maerwald> it's more like MonadFail, but with proper error messages
03:56:54 <merijn> MonadFail *may* have proper error messages, it depends on the instance
03:57:06 <maerwald> you cannot adjust the error message ever
03:57:14 <dminuoso_> maerwald: So whenever normal join/bind is used, the errors dont propagate?
03:57:30 <zmagii> sup guys
03:57:48 <maerwald> dminuoso_: the class definition isn't really correct... the inner Monad can be a different one than the outer
03:57:53 <maerwald> so it's not a join
03:58:27 <dminuoso_> maerwald: well that's just MonadFail.
03:58:31 <maerwald> exactly
03:58:53 <maerwald> and now I want to adjust the error message on the fail
03:59:19 <maerwald> I wouldn't mind if that's a GHC extension even
04:00:07 <dminuoso_> maerwald: That's MonadThrow then.
04:00:13 <dminuoso_> Sort of.
04:00:21 <dminuoso_> (Or MonadError)
04:00:29 <maerwald> yep, and now back to my original question ;)
04:00:42 <maerwald> how to know Alternative and MonadError correspond...
04:00:49 <dminuoso_> They don't, in general.
04:00:53 * hackage prettyprinter-graphviz 0.1.0.1 - a prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-0.1.0.1 (GeorgeThomas)
04:00:55 <dminuoso_> They only do for particular instances.
04:01:15 <maerwald> yea, so that combination of classes is dangerous
04:01:41 <maerwald> I want cross-class contracts
04:01:49 <dminuoso_> maerwald: The problem is, if your error type requires an actual value, then you cant generically make up values
04:01:56 <dminuoso_> maerwald: This is because
04:01:58 <dminuoso_> % :t empty
04:01:58 <yahb> dminuoso_: ; <interactive>:1:1: error:; Ambiguous occurrence `empty'; It could refer to either `Data.Vector.empty', imported from `Data.Vector'; or `Control.Applicative.empty', imported from `Control.Applicative' (and originally defined in `GHC.Base')
04:02:06 <dminuoso_> % :t Control.Applicative.empty
04:02:06 <yahb> dminuoso_: Alternative f => f a
04:02:11 <dminuoso_> $ :t catchError
04:02:14 <dminuoso_> % :t catchError
04:02:14 <yahb> dminuoso_: MonadError e m => m a -> (e -> m a) -> m a
04:02:54 <dminuoso_> They cannot be directly linked by law, because there's no Monoid (or equivalent) constraint on the `a` on empty
04:03:17 <dminuoso_> err
04:03:30 <dminuoso_> Wrong side. The constraint would have to be tacked onto the error type of MonadError.
04:03:37 <dminuoso_> somewhere
04:03:57 <maerwald> I would just imagine having Alternative as constraint in MonadError, yes
04:04:01 <merijn> maerwald: Do you not simply want Validation/These?
04:04:04 <maerwald> but that doesn't make sense in its own
04:04:26 <dminuoso_> Ive thought about suggesting These, but it didnt seem like the right fit
04:04:38 <dminuoso_> maerwald: No, it would rather require something like
04:05:19 <dminuoso_> maerwald: `class (Monoid e, Monad m) => MonadError e m | m -> e`
04:05:23 <dminuoso_> Or maybe
04:05:28 <dminuoso_> `class (Default e, Monad m) => MonadError e m | m -> e`
04:05:39 <dminuoso_> This looks wrong already
04:05:48 <merijn> Anything with Default looks wrong by definition
04:06:17 <dminuoso_> Or I dont know. Couldn't even tell you where that Default/Monoid constraint would have to be.
04:06:19 <maerwald> this is an interesting problem... cross-class laws
04:06:37 <dminuoso_> Or maybe you would need something like
04:07:06 <dminuoso_> empty :: Default e, MonadError e f => f a
04:07:12 <dminuoso_> Yeah, that looks about right.
04:07:20 <dminuoso_> (For some value of "right")
04:14:54 * hackage humble-prelude 0.2 - Redefinition-free prelude alternative  https://hackage.haskell.org/package/humble-prelude-0.2 (FumiakiKinoshita)
05:09:54 <hseg> Hi. How can I get the instance information for a composite type (e.g. [Int]) in GHCi?
05:14:26 <dminuoso_> hseg: So in standard Haskell you cant write an instance for [Int]
05:14:57 <hseg> Sure. I just want :i to be able to dump the instances [Int] satisfies
05:15:50 <dminuoso_> hseg: Use `:i []`
05:16:19 <hseg> But that doesn't take into account instances that would be available due to Int being an instance of stuff
05:17:26 <hseg> (My actual case is trying to debug why GHC doesn't want to accept (recip 2 :: Complex (Fraction Integer)) (all of these from 'algebra'))
05:17:55 <dminuoso_> hseg: It would.
05:18:43 <dminuoso_> hseg: I just tried `instance {-# OVERLAPPING #-} Monoid [Char]` - and then `:i []` showed both instances.
05:18:56 <hseg> no, that's not what I want
05:19:26 <hseg> I'm after stuff like instance (Monoid a, Monoid b) => Monoid (a,b)
05:19:53 <hseg> Basically I'm trying to debug why the instance isn't accepted.
05:20:40 <hseg> The actual code I'm checking: http://ix.io/27xC should permit me to write (recip 2 :: Complex (Fraction Integer)), assuming proper imports (all from 'algebra')
05:20:49 <hseg> But GHC disagrees
05:26:12 <hseg> Also, it's a bit annoying that I can't just ask GHC "Under what circumstances is this type an instance of this class"?
05:26:43 <hseg> Instead, I need to dump *all* the instances of a type, then start trawling through them to get the instance I want.
05:28:08 <dminuoso_> 14:25:49       hseg | Also, it's a bit annoying that I can't just ask GHC "Under what circumstances is this type an instance of this class"?
05:28:37 <dminuoso_> hseg: Is it possible you made the common mistake of falsely assuming that instance constraints have an impact on instance selection?
05:29:25 <hseg> ... Possibly. Keep forgetting this isn't the case. Runs counter to my intuition of how these should go.
05:30:05 <hseg> However, the point re GHC dumping all instances stand
05:30:08 <hseg> *stands
05:49:57 <hseg> Hrm. Just found two bugs in 'algebra', and it's looking inactive. Is there a way I can make local patches?
05:52:31 <merijn> hseg: I'm pretty sure if you submit a patch edwardk will merge them reasonably fast
05:52:48 <hseg> OK
05:53:17 <hseg> Just not seeing any updates since three decembers ago
05:53:21 <merijn> hseg: If you use v2-build (or cabal-install 3.0) you can easily depend on a git commit/local patch
05:53:37 <merijn> hseg: Sure, but "not actively developed" /= "no longer maintained"
05:53:42 <hseg> Nice. Pointer, please?
05:53:59 <merijn> hseg: Especially if you realise that it was initially by edwardk and he has like 100+ libraries to worry about :p
05:54:07 <hseg> ofc, ofc
05:54:47 <merijn> hseg: https://github.com/merijn/Belewitte/blob/master/cabal.project#L3-L13
05:55:12 <merijn> hseg: Usually I just develop patches in a fork and then depend on the fork until patches make it in upstream, so I can drop the fork again
05:56:10 <hseg> OK, thanks. *must* the repository be remote? Can I not point cabal to a local repository?
05:56:38 <kuribas> building purescript fails with "Could not find module ‘Data.Functor.Contravariant’"
05:56:48 <kuribas> even when I add contravariant to purescript.cabal
05:57:07 <merijn> hseg: You can point at a local folder too https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-the-local-packages
05:57:09 <AWizzArd> Spelling:   a) type class   or   b) typeclass   ?
05:57:20 <merijn> hseg: See, the optional-packages field there
05:57:27 <AWizzArd> or  c) me no cares
05:57:54 <merijn> AWizzArd: The Haskell Report uses a
05:57:59 <merijn> AWizzArd: But most people don't care
05:58:11 <merijn> AWizzArd: See title: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
05:58:14 <AWizzArd> merijn: the HR is a pretty good argument. Thx for letting me know.
05:58:44 <AWizzArd> merijn: btw, are you coming to ZuriHac 2020?
05:59:34 <hseg> OK, so seems like if I have another .cabal project in a subdirectory cabal will pick it up?
06:00:05 <hseg> (by default)
06:00:43 <kuribas> oh I see, it's the library, not the exe
06:00:48 <merijn> hseg: The docs should specify the default value of "packages"
06:01:07 <hseg> Right, just am unfamiliar with cabal.project
06:01:19 <merijn> AWizzArd: Maybe, if I can con work into paying :p
06:01:46 <hseg> So the default values mean that cabal will build the package at the root + all packages in subdirectories, if I'm reading correctly
06:01:52 <merijn> hseg: cabal.project is for v2-build, pretty much explicitly designed to accomodate things like "being able to depend on unreleased packages"
06:01:56 <maerwald> Zürich is such a cheap city :P
06:01:58 <merijn> hseg: Sounds about right
06:02:01 <hseg> Great
06:02:15 <hseg> Makes it easier to split off new packages as well
06:02:49 <merijn> hseg: Yes. Or testing sets of related packages that are developed in lockstep, but released as independent packages
06:03:04 <merijn> hseg: Just keep them in the same repo with a cabal.project and you can easily test on Travis
06:03:13 <hseg> Nice! Should read through the cabal manual one of these days
06:03:43 <merijn> hseg: If you're not aware of haskell-CI, that's also quite nice: https://github.com/haskell-CI/haskell-ci/
06:04:19 <hseg> Ooh. Probably irrelevant for me atm, but looks useful!
06:04:39 <merijn> hseg: It can generate Travis-CI configs from cabal.project/.cabal files
06:04:56 <hseg> (Am developing a little test harness for some numerical experiments)
06:05:08 <merijn> So you don't have to learn travis' cryptic YAML format, also sets up caching, tests for sdist, etc.
06:09:48 <maerwald> anyone used control-monad-exception? How is usability?
06:17:42 <hseg> OK, thanks! Gotta go though
06:30:47 <absence> is there something similar to Compose that works for bifunctors?
06:43:05 <fizbin> For those of you who are obsessed with following this channel and remember my questions from last week or so about a service with slowly growing CPU usage over time (even though the service should have no state), I think I've narrowed the culprit down to the stats monitoring part.
06:44:42 <kuribas> doesn't servant-client return the status code?
06:45:16 <fizbin> Though there's no state shared among the requests that are the real business end of this service, there's a URL exposed that gives simple stats of the number of requests over the past minute, the past five minutes, and the past 60 minutes, and gives a simple breakdown of "this many requests started, this many returned with HTTP status NNN, this much time taken on average on successful requests, this much on failed requests"
06:45:53 <kuribas> https://hackage.haskell.org/package/servant-client-core-0.16/docs/Servant-Client-Core-ClientError.html#t:ClientError
06:45:56 <kuribas> <= no status code
06:46:47 <kuribas> ah, it's in the response, nvm
06:48:59 <fizbin> And I clearly screwed up the design of that stats-recording structure, because even after double-checking that I'm using modifyIORef' everywhere the stats structure is touched there's something that hangs around using progressively more CPU to update the stats for each new request.
06:49:59 <opqdonut> I assume the ref contains a record. are the fields strict enough?
06:50:06 <fizbin> The good news here from my point of view is that this stats collecting thing is not at all proprietary and so extracting that to a separate thing I can post the code of and get feedback on should be easy.
06:50:21 <opqdonut> note that just marking a field string isn't enough if it contains something like a list
06:50:36 <opqdonut> *marking a field strict
06:50:46 <fizbin> opqdonut: I thought they were, but clearly something's off.
06:51:11 <merijn> fizbin: Note that strictness on fields is only strict to WHNF
06:51:36 <opqdonut> memory profiling should be able to tell you if thunks are building up
06:52:36 <fizbin> Well, more to the point now that I have it narrowed to the stats bit I can simulate stats accumulation over time (since I can feed the stats bit a fake clock) and get to where profiling can help me.
06:52:58 <fizbin> Trying to use profiling on a problem that takes multiple days to become noticeable is tricky.
06:52:59 <maerwald> the problem isn't just thunk build up, but thunk build up and evaluation in a tight loop
06:53:20 <maerwald> so you never really get a large thunk, but very slow execution
06:53:39 <maerwald> that's hard to profile
06:54:38 <cdunklau> i'm diving into Foldable, but i have a feeling my tree isn't going to work with it... it seems like it might require a nullary or unary type, but mine is binary
06:55:09 <opqdonut> cdunklau: you can just walk the elements in some order
06:55:16 <opqdonut> (e.g. in-order)
06:55:34 <fizbin> cdunklau: Isn't the classic example of Foldable a binary tree?
06:55:37 <opqdonut> heh, the example instance for Foldable is actually for a tree
06:55:38 <opqdonut> http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html
06:56:04 <cdunklau> binary type though.
06:56:18 <opqdonut> what do you mean by "binary type"?
06:56:42 <cdunklau> opqdonut: my tree's type constructor is binary. i have: data DecisionTree a b = Decision (Test a) (DecisionTree a b) (DecisionTree a b) | Result b
06:57:08 <opqdonut> right well you can still have an instance `Foldable (DecisionTree a)`
06:57:17 <cdunklau> aaaaaah right
06:57:17 <opqdonut> which will fold over the Result values
06:57:27 <cdunklau> okay, great. that's the bit i was missing
06:57:29 <cdunklau> thanks!
06:58:25 <cdunklau> that reminds me of the Functor bit in learnyouahaskel
07:01:41 <cdunklau> i love this... i start to think i'm maybe getting it, and i'm like hey i think i can use one of these fancy typeclasses to accomplish a thing... and then i get blindsided by kinds and other crap i barely understand
07:01:47 <cdunklau> yay!
07:01:48 <cdunklau> :D
07:01:53 * hackage cobot-io 0.1.2.6 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.6 (zmactep)
07:02:35 <berndl> Foldable is fancy?
07:03:00 <cdunklau> berndl: yes. i'm new. :)
07:05:55 <[itchyjunk]> Hello new. I'm [itchyjunk] 
07:49:58 <Uniaika> phadej: Hi! I was wondering how it would be to add the method of each enpdoint besides them in the output of `layoutWithContext`. It can be quite confusing when an endpoint accepts several methods or several types and you're just beginning to explore an API :)
07:50:53 * hackage reflex-ghci 0.1.1.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.1.0 (abrar)
08:04:41 <phadej> Uniaika: i miss the context
08:07:20 <Uniaika> phadej: if we take this output, for example: https://0bin.net/paste/eGvb70rxDbioUnoc#iJckiYIypgQvtkdBCsTNIMuEIhNDSAb1MHsfvwkvtdp
08:07:34 <Uniaika> the two dots under <capture> don't say much about the nature of these endpoints
08:08:02 <Uniaika> and I was wondering if adding the associated methods (GET/PUT/POST/DELETE/etc) would be easily doable?
08:11:50 <phadej> Uniaika: no with current Router structure, as it doesn't know about HTTP verbs (though I guess it should?)
08:28:21 <Uniaika> arf
08:28:22 <Uniaika> thanks :)
08:35:19 <sm[m]> morning all
08:35:48 <sm[m]> I'm looking at the cabal install method in homebrew. Is --max-backjumps=100000 fine ?
08:39:15 <geekosaur> afaik it just slows down detecting that an install plan can't be found, but makes it more likely to find one? that is, it tells it it can do more work to try to find an install plan
08:45:33 <sm[m]> it seems like it could eat a lot of time, but maybe it's fine
08:46:20 <geekosaur> it being a package system, presumably they know it'll complete in a timely manner
08:46:48 <geekosaur> and dont want to have to guess a number that will reliably work for every individual package, so they just use a big one
08:48:05 <geekosaur> (this said, I don't think much of homebrew, it takes too many liberties for my tastes. but I gave up on Macs in general, so.)
08:49:21 <shapr> what's the latest news on hie or ghcide?
08:49:23 * hackage run-st 0.1.1.0 - runST without boxing penalty  https://hackage.haskell.org/package/run-st-0.1.1.0 (andrewthad)
08:51:32 * shapr hops cheerfully
08:51:44 <shapr> good morning #haskell!
08:54:52 <sm[m]> good morning shapr!
08:57:33 <maerwald> is there a way to tell brittany to separate qualified and non-qualified imports and don't align them horizontally?
08:57:49 <shapr> good morning sm[m]! How's code treating you?
09:02:13 <fizbin> Well that's stupid/a relief. It turns out that if you build a stats structure and design something to be run periodically to cull old data from it and then never actually get around to having that periodic old data cull happen, then the structure grows over time without bound.
09:03:13 <fizbin> I think the lesson here is that when, in one file, you have a comment of "make sure this is called at least every two hours" you then need something in another file that calls it at least once every two hours.
09:05:22 <amx> you could encode that in the types ;)
09:10:26 <sm[m]> shapr: it's early, but so far so good!
09:10:36 <shapr> good early morning!
09:10:50 <sm[m]> working around cabal/hackage bounds issues in homebrew
09:12:00 <shapr> I figure it's time I setup ghcide, is that the most popular completion popup thing in emacs these days?
09:12:56 <MarcelineVQ> idk what's popular but I tend to suggest people try dante before anything more complicated
09:13:26 <MarcelineVQ> though I dunno if dante does what you're imagining, it's just that it's simple to try out and see
09:13:33 <sm[m]> shapr: I don't know that it has reached popular status, but good move
09:13:48 <shapr> is hie or ghcide more popular?
09:14:49 <sm[m]> ghcide is the newest and I think most robust
09:15:27 <sm[m]> https://termbin.com/t20w is the .emacs what worked for me
09:16:02 <MarcelineVQ> shapr: some back-story https://github.com/digital-asset/ghcide#history-and-relationship-to-other-haskell-ides
09:16:10 <sm[m]> (for some value of worked, we are talking about the semi-mythical Haskell IDE beast)
09:16:12 <shapr> MarcelineVQ: thanks!
09:16:21 <shapr> sm[m]: thanks, I'll try it!
09:17:23 <fendor> shapr, on the bristol hackathon next week, maintainers of both projects are hacking together on them
09:17:49 <shapr> fendor: oh marvelous! Will there be a blog post or anything?
09:17:54 * hackage semantic-source 0.0.1.0 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.0.1.0 (robrix)
09:17:57 <sm[m]> installed emacs packages: lsp-ui, lsp-haskell
09:18:09 <fendor> shapr, I hope so, otherwise I will be mad since I can not attend :(
09:28:34 <maerwald> what's the verdict of attoparsec vs megaparsec these days
09:29:01 <shapr> attoparsec is slightly faster, megaparsec has much better error messages when something goes wrong
09:29:19 <Taneb> They're for differecnt circumstances, in my mind
09:29:23 <shapr> I switched from attoparsec to megaparsec last month, after several years of attoparsec usage.
09:29:31 <shapr> Taneb: ooh, tell me more?
09:29:54 <Taneb> attoparsec for when we expect the input to be machine-generated, so error messages matter less
09:30:10 <Taneb> megaparsec for when we expect the input to be hand-written
09:30:19 <[exa]> maerwald: megaparsec for complicated user-facing stuff, attoparsec for relatively simpler datasource-facing stuff
09:31:03 <maerwald> input is rather tiny I'd say
09:31:15 <hololeap> attoparsec fits nicely into streaming libraries since it supports incremental input. it also has some very fast operations on bytestrings
09:31:29 <[exa]> maerwald: "how many ways can it go wrong" is probably the cutting question
09:31:31 <shapr> yeah, I've used streaming attoparsec to good effect
09:31:34 <maerwald> hololeap: ah, can you use it with streamly?
09:31:54 <hololeap> maerwald: i'm literally in the process of trying streamly for the first time :)
09:32:03 <maerwald> I'm already using it for file operations
09:32:10 <maerwald> but it relies on so much internal API
09:32:55 <hololeap> i didn't have very good luck trying to get megaparsec working with conduit
09:33:07 <maerwald> and there are some important bugs to be fixed like https://github.com/composewell/streamly/issues/370
09:33:38 <hololeap> and it seemed pointless to have things like line numbers in the error message if i'm reading from a message transport over the network
09:35:04 <maerwald> streamly is really fast... it performed pretty much the same as a manually written loop with copying chunks of C strings into a buffer
09:35:26 <MarcelineVQ> and the devs are nice :>
09:36:03 <maerwald> just that currently the API and documentation is a bit messy, because half of the things you need are still in internal modules
09:36:14 <maerwald> (which are exposed, mostly, but)
09:37:07 <hololeap> yeah it seems cool although i'm not really sure what it's supposed to be. i found it because i was looking into using FRP for server concurrency stuff. it says it can be used as an alternative to reflex...
09:37:53 <maerwald> It definitely has a simpler API. Some functions need a bit of time to find, but compared to conduit it's dead simple
09:38:24 <MarcelineVQ> hololeap: yeah there's an example for that called acid rain I think
09:38:43 <maerwald> it's something you could think of including in the Prelude without giving a newcomer a heart attack imo
09:39:14 <MarcelineVQ> there's lots of stuff in the examples dir
09:40:48 <hololeap> i just made a gentoo package for it, and i'm compiling it now with examples and llvm support enabled
09:44:44 * hololeap wishes the *ly naming trend would just die already
09:46:40 * shapr creates the hololeaply library
09:46:51 <maerwald> liblaly
09:46:59 <shapr> This library randomly deletes files that end in ly
09:47:31 <maerwald> hololeap: I think because "streaming" was already taken
09:49:01 <hololeap> i wonder if they'll buy the obligatory .ly domain
09:49:18 <maerwald> so sad .hs doesn't exist
09:56:54 <Uniaika> maerwald: when I see the price for the .rs I'm not sad at all :P
09:59:34 <hololeap> haskellcurry.sexy is available for $29.98/yr
10:03:06 <maerwald> sounds like a good place to build my haskell consulting company
10:12:23 <sm[m]> shapr: attoparsec slightly faster than megaparsec - is that a recent data point ?
10:12:29 <shapr> sm
10:12:34 <shapr> no, it's not
10:12:47 <sm[m]> megaparsec says it had some speedups
10:13:08 <shapr> Yeah, I'm curious as well
10:13:10 <MarcelineVQ> I linked megaparsecs own words on the subject earlier
10:14:03 <MarcelineVQ> but appearantly in another channel haha
10:14:07 <sm[m]> MarcelineVQ: oh, https://github.com/mrkkrp/megaparsec#performance  ? I didn't see
10:14:24 <sm[m]> cunning! :)
10:18:51 <maerwald> sm[m]: the bench files are very small
10:23:56 <hololeap> i thought attoparsec was faster when you used these "efficient string handling" combinators: https://hackage.haskell.org/package/attoparsec-0.13.2.3/docs/Data-Attoparsec-ByteString.html#g:10
10:25:03 <solonarv> I think megaparsec has those as well now
10:26:23 * hackage lenz 0.4.2.0 - Van Laarhoven lenses  https://hackage.haskell.org/package/lenz-0.4.2.0 (MatthewFarkasDyck)
10:27:47 <MarcelineVQ> in particular the *While combinators are also fast in megaparsec afaik
10:28:15 <hololeap> i could be mistaken, but it seems like they're using a lot of inefficient combinators like sepEndBy1 in here: https://github.com/mrkkrp/megaparsec/blob/master/parsers-bench/ParsersBench/CSV/Attoparsec.hs
10:32:15 <hololeap> it could probably be re-written to be faster/uglier and would be a more appropriate benchmark
10:33:11 <hololeap> since attoparsec doesn't claim to be faster than any other parsing library unless you use those efficient combinators wherever possible
10:41:57 <cocreature> hololeap: iirc that benchmark is specifically chosen to use the inefficient combinators (both for attoparsec and megaparsec). some of the other benchmark, e.g., the json one are written directly using the primitives of the respective libraries
10:42:58 <hololeap> gotcha
10:51:24 * hackage stratosphere 0.47.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.47.0 (jdreaver)
10:57:29 <titusg> hi, I can't update cabal-install for some reason -- I'm on 2.4, update the list and it still says cabal-install is up to date...?
10:58:48 <maerwald> titusg: how did you install the new cabal?
10:59:03 <maerwald> or do you mean the package index
11:00:32 <titusg> maerwald: I'm trying to install it with cabal but it says it's up to date
11:00:47 <maerwald> did you update the package index?
11:01:52 <titusg> yes
11:02:21 <maerwald> I think 3.0 cannot be built with all GHCs
11:02:29 <solonarv> titusg: so: what command did you run? what did you expect to happen? what happened instead?
11:03:39 * geekosaur guesses $PATH? but need more information
11:03:47 <titusg> I ran cabal update && cabal new-install cabal-install and it told me that it was already up to date
11:03:53 <geekosaur> (also that fun "hash -r" thing)
11:04:16 <titusg> PATH has .cabal/bin at the front
11:04:43 <maerwald> try: cabal new-install cabal-install-3.0.0.0
11:04:45 <geekosaur> what does this command produce?     type cabal
11:08:21 <glguy> [String] -> IO ()
11:14:02 <geekosaur> what I suspect is your shell remembers where it found cabal and is still using it (which that "type" command will report). in this case, "hash -r" will reset it and it'll find the new version
11:14:28 <geekosaur> and 2.4 would be installed somewhere else, possibly in /usr/bin
11:19:46 <titusg> tx geekosaur 
11:26:15 <yushyin> https://paste.xinu.at/m-VZD/#n-bMPcDo-68 seems like ghcide ignores the default-extensions?
11:31:40 <cocreature> yushyin: I recommend making a hie.yaml file and setting the cradle explicitly. it should get picked up. it’s probably just picking the wrong cradle
11:31:42 <sm[m]> are there shells/environments which have solved this constantly troublesome $PATH UX ?
11:53:25 <tydeu> why is the fmap of IO not defined as `fmap = liftM`?
11:57:21 <iqubic> Because there are more efficient ways of doing it.
12:27:24 * hackage matrix-market-attoparsec 0.1.0.9 - Parsing and serialization functions for the NIST Matrix Market format  https://hackage.haskell.org/package/matrix-market-attoparsec-0.1.0.9 (ocramz)
12:30:29 <solonarv> iqubic: actually, the definition of fmap @IO is equivalent to liftM with a little but of inlining
12:30:58 <solonarv> so I really do not know!
12:54:15 <amalloy> solonarv: i'm having trouble imagining how any type could implement fmap more efficiently than liftM. can you think of an example where this is possible?
12:55:47 <geekosaur> do you know the definition of liftM?
12:56:00 <geekosaur> there's some historical baggage here
12:56:12 <iqubic> @src liftM
12:56:12 <lambdabot> liftM f m1 = do
12:56:12 <lambdabot>     x1 <- m1
12:56:12 <lambdabot>     return (f x1)
12:56:18 <iqubic> Huh???
12:56:39 <iqubic> surely you can write that without do notation.
12:56:53 <geekosaur> you can, yes. but that's not the point
12:57:36 <geekosaur> the point is that historically Monad did not imply Functor; liftM "recovered" fmap the hard way via >>=, since it couldn't use fmap directly
12:57:48 <solonarv> note that lambdabot 's @src is just a manually-curated database and often does not correspond to the actual source
12:57:57 <geekosaur> but it's correct here
12:58:12 <solonarv> it is? huh, I would've expected it to be m1 >>= pure . f
12:58:20 <solonarv> I mean s/pure/return/
12:58:28 <geekosaur> you're welcome to dig around in GHC.Base and see for yourself
12:58:56 <amalloy> geekosaur: yeah, i know about that history. but i still don't see a case where using fmap is actually more efficient than the recovered version using bind and return
12:59:10 <solonarv> okay, here is a simple example
12:59:14 <MarcelineVQ> solonarv: if you're gonna use pure you might as well use fmap though, in terms of why you're not using fmap
12:59:26 <solonarv> consider the instance for 'Maybe'
12:59:39 <MarcelineVQ> oh you corrected that, man I'm behind today
13:00:13 <solonarv> hmm, actually that is a bad example
13:00:19 <solonarv> let's use [] instead
13:00:41 <solonarv> there, liftM f xs = concatMap (\x -> [f x]) xs
13:00:44 <amalloy> okay, actually now that you mention [] i get it
13:00:59 <amalloy> i was thinking in terms of Maybe too
13:01:04 <solonarv> this pointlessly creates and then merges together a whole bunch of intermediate lists
13:01:19 <jle`> fmap can be more efficient because it doesn't have to inspect the structure of the returned value
13:01:36 <solonarv> (in the case of [] specifically, rewrite rules and list fusion might take care of that, but other types will have similar issues anyway)
13:02:36 <jle`> amalloy: bind has to be able to handle all `m a`, but fmap can take advantage of the fact that it's always 'a', without worring about the structure
13:02:44 <jle`> amalloy: an extreme example would be something like a tree
13:02:59 <jle`> where bind :: (a -> Tree b) -> Tree a -> Tree b
13:03:12 <jle`> bind has to be able to inspect the 'Treee b' that the function returns and handle each possible tree shape
13:03:29 <jle`> where fmap :: (a -> b) -> Tree a -> Tree b can use the fact that the tree's shape does not change during an fmap
13:04:00 <jle`> so it never has to pattern match on any 'Tree b'
13:05:05 <jle`> also for something implemented as a function like `State s`, you loose sharing with liftM because it can't take advantage of the fact that the state doesn't change
13:05:28 <jle`> er, actually you might loose that in both cases, hm.
13:05:44 <jle`> so maybe the "ADT" monads are a more convincing example
13:06:50 <yushyin> cocreature: thanks I'll try that.
13:11:07 <iqubic> Does anyone know of an emacs plugin that will automatically apply an hlint suggestion when a key-binding of my choice is hit?
13:42:04 <pera> I am trying to read FP with bananas, lenses, envelopes and barbed wire (for the first time). What's the meaning of the double pipe notation? like A||B -> B
13:42:22 <pera> I first thought it was like a cons operator but it doesn't make sense
13:45:06 <glguy> maerwald: What's it take to add 8.8.2 to ghcup?
13:45:19 <maerwald> not much
13:45:46 <maerwald> But I'll probably also adjust CI
14:00:03 <tydeu> so from the previous discussion -- there doesn't seem to be a good reason why the fmap for IO is not `fmap = liftM`
14:00:59 <ph88> does anyone know what this error is about ?? https://bpaste.net/LFMA 
14:11:32 <ocharles> Can anyone help me understand a weird type class resolution problem?
14:11:42 <ocharles> https://gist.github.com/ocharles/ef66e005523f897b508c3dd284338fa7#file-hmmm-hs-L38-L42 is the crux of the problem
14:12:18 <ocharles> Basically, I have a type class that knows how to zip the "leaves" of a type. This is the type class Bar, with the function zippy.
14:12:27 <ph88> oh i found that similar error on some github issue
14:12:37 <ph88> hi ocharles 
14:12:41 <ocharles> hello!
14:13:20 <ocharles> I have a type - Two - that doesn't contain leaves, but contains trees. I want to give it an instance of Bar, but rather than explictly saying (C T c) (to indicate T's leaves can be zipped), I want to defer this to another type class
14:13:27 <ocharles> Yet if I do this, GHC gets stuck, I'll include the error message
14:14:59 <ocharles> https://gist.github.com/ocharles/ef66e005523f897b508c3dd284338fa7#file-hmmm-hs-L43 is the error. Specifically `Could not deduce: (c Int, c Bool)` ... `from the context: C Two c`. But `type C Two c = ( Foo T c )`, and `instance C T c => Foo T c`, and finally `type C T c = ( c Int, c Bool )`
14:15:26 <ocharles> To my eyes, this all should check out just fine. But GHC is unhappy with it. It seems that the context of `instance C T c => Foo T c` isn't considered
14:16:54 * hackage reflex-ghci 0.1.2.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.2.0 (abrar)
14:23:41 <tydeu> ocharles: why do you think it shoudl check out fine?
14:23:53 <ocharles> I'm not sure, I may well have confused myself by now :)
14:24:50 <tydeu> from my (light) perusal, it seems to me that the `Bar Two` instance would need a `C T c`  constraint
14:25:10 <ocharles> Ah, I guess `type C Two c = Foo T c`, then `zippy :: Foo T c => ...`, but that doesn't mean `zippy :: C T c`
14:25:27 <Lears> ocharles: I think Foo b c would need C b c as a superclass constraint.
14:25:39 <ocharles> Even though `instance C T c => Foo T c`, because we could have an overlapping instance so GHC can't really choose that one yet
14:25:52 <ocharles> Yea, I'm gonna have to think about another way of doing this.
14:26:15 <tydeu> good luck :)
14:27:30 <ocharles> Thanks, rubber ducks!
14:32:09 <fog> ok, i gathered together the pieces for this idea; https://gist.github.com/fog-hs/6458c8e9407e5f222907cf83404e7c61
14:33:04 <fog> that is, reification, supplying arguments to functions via Creats constraints, and a scaffolding which stores the types
14:33:30 <fog> now it should be possible to fold up the scaffold, reifying the computed values at each node
14:33:41 <fog> so that they can be used in the evaluation of downstream functions
14:34:15 <fog> where there also needs to be an interface which ensures the types match via specifying edges and node function output types
14:35:16 <maerwald> glguy: should be done
14:36:08 <glguy> Thanks!
14:40:17 <atif> Is Data.ByteString.Read deprecated?
14:42:35 <yushyin> cocreature: yup, with a simple hie.yaml file it works. But I just added aeson as dep and while cabal new-repl works just fine, ghcide stops working once again. https://paste.xinu.at/m-Reav/ 
14:49:53 * hackage cabal-build-programs 0.1.0.0 - Adds executable dependencies to the Cabal build  https://hackage.haskell.org/package/cabal-build-programs-0.1.0.0 (deech)
14:55:34 <jle`> atif: what package is that from?
14:58:35 <atif> bytestring-read
14:59:15 <atif> http://hackage.haskell.org/package/bytestring-read-0.3.1/docs/Data-ByteString-Read.html
15:01:02 <atif> at the bottom of the document has a section DEPRECATED
15:01:04 <phadej> never heard
15:01:19 <atif> and a link to module Data.ByteString.Read.DEPRECATED
15:05:30 <jle`> atif: it looks like only that Data.ByteString.Read.DEPRECATED module and its functions are officialy deprecated by the maintainer
15:05:49 <jle`> http://hackage.haskell.org/package/bytestring-read-0.3.1/docs/Data-ByteString-Read-DEPRECATED.html
15:09:27 <fog> the problem to do with edges is that if the args to the function at the node are specified as a phantom annotation on the constructor
15:09:42 <fog> along with the resulting return type
15:09:51 <fog> which represents the "type of the node"
15:10:29 <fog> then the type of a node at some position should match up with the list of positions stored with the function at each node of where to retrive the value of this type from, constituting an edge
15:11:17 <fog> meaning the constructors of this need to ensure that the wrong node type cant be specified, as determined by matching the types of the function at each node with the list of locations of these types
15:11:51 <fog> this is difficult, since if folding from the left, the head being matched first, with this as being layer added to the net
15:12:15 <fog> none of the downstream layers can see which type is going to be stored at each pos in this layer
15:12:35 <fog> where many functions downstream may reference this and so constrain its type
15:13:21 <fog> where the construction should basically then ensure that all all calls to a particular pos by functions at various nodes should all be of the same type, the type of the node at that pos
15:13:28 <atif> jle`:  Thanks.
15:14:23 <fog> i think the way round this is to unfold the whole thing, according to some auxilary type specifying the edges and node types in a different way
15:15:17 <fog> ie, inferring the types of the functions at the nodes by checking the types of the nodes that have edges leading to this node
15:15:50 <fog> which eliminates the possibility of different functions having conflicting assertions about which type should be found at a node
15:27:35 <maerwald> https://git.io/JvTZV why does the FromJSONKey deriving not work? I have no idea what the error means.
15:28:07 <maerwald> the tojsonkey doesn't give an error, so I find this confusing
15:32:18 <Axman6> that feels like avery odd instance
15:42:55 <maerwald> maybe lol
15:43:50 <jbayardo> .g math
15:58:41 <maerwald> eitherDecode $ encode $ Map.fromList [(1, "abc")]
15:58:45 <maerwald> this fails... 
15:58:51 <maerwald> I don't think it should
15:59:46 <maerwald> Left "Error in $: parsing () failed, expected Array, but encountered Object"
16:04:45 <maerwald> well, even this fails: eitherDecode $ encode $ [(1, "abc")]
16:04:52 <EvanR> the to and from instances for Maps disagree??
16:05:12 <EvanR> and list?
16:05:17 <maerwald> map instances just convert to list and run tojson/fromjson on it
16:05:44 <EvanR> then where did the Object come from
16:06:37 <maerwald> EvanR: the first error is from a more complex example
16:06:45 <maerwald> but it seems it's all wrong, even simple things fail
16:07:05 <maerwald> I'm baffled why aeson would allow things to encode it cannot decode
16:09:50 <maerwald> that's really scary in fact
16:11:01 <glguy> maerwald: Try specifying the type
16:11:25 <glguy> I suspect you're trying to decode something as a ()
16:11:43 <glguy> >>> encode ()
16:11:44 <maerwald> oh right, that could be it
16:11:44 <glguy> "[]"
16:11:53 <glguy> >>> eitherDecode' $ encode $ M.singleton 1 "abc" :: Either String (M.Map Int String)
16:11:53 <glguy> Right (fromList [(1,"abc")])
16:12:08 <maerwald> the error message is absolutely confusing
16:27:54 * hackage warp 3.3.7 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.7 (KazuYamamoto)
16:35:24 * hackage cabal-build-programs 0.1.0.1 - Adds executable dependencies to the Cabal build  https://hackage.haskell.org/package/cabal-build-programs-0.1.0.1 (deech)
16:42:24 * hackage hookup 0.3.0.1 - Abstraction over creating network connections with SOCKS5 and TLS  https://hackage.haskell.org/package/hookup-0.3.0.1 (EricMertens)
16:45:24 * hackage cpkg 0.2.4.1 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.1 (vmchale)
16:46:24 * hackage irc-core 2.7.2 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.7.2 (EricMertens)
16:49:23 <shapr> huh, I can't build ghcide because docs fail to build for monoid-subclasses, that's weird
16:51:54 <maerwald> don't build docs, they're probably empty anyway :P
16:52:08 <shapr> I had to comment out "documentation: True" in my ~/.cabal/config
16:52:13 <shapr> now it's making more progress
16:54:04 <maerwald> you could put that in cabal.project.local instead inside the project folder
16:54:23 * hackage glirc 2.34 - Console IRC client  https://hackage.haskell.org/package/glirc-2.34 (EricMertens)
16:59:52 <electricityZZZZ> conal: are you around?
17:01:13 <Axman6> conal is (probably) human, therefore he is topologically a doughnut
17:05:22 <hpc> noses make that a bit more complicated, but maybe that falls under "(probably)" ;)
17:07:46 <electricityZZZZ> and actually when you consider that your nostrils take turns over time, it's good to realize that your topology is actually a function of time
17:11:51 <Axman6> I have a feeling that since all the holes in the human body are connected that makes us topologically doughnuts - ears aren't holes because od the eardrum
17:12:24 <Axman6> https://www.youtube.com/watch?v=k8Rxep2Mkp8 relevant
17:13:21 <pounce> is there any way to make an array with a literal?
17:13:22 <electricityZZZZ> that guy is so dorky
17:13:31 <pounce> or from a list
17:13:53 <Axman6> I could be wrong though, I can't remember what happens when you have a hole that branches into three different holes
17:14:02 <Axman6> pounce: OverloadedLists
17:14:58 <Axman6> ah the video shows what happens when a hole has forks
17:16:19 <pounce> cool
17:18:57 <amy_monnet> Hello everyone 
17:19:24 <electricityZZZZ> hi amy
17:19:26 <Axman6> Hello!
17:19:52 <amy_monnet> A friend and I are looking to learn servant to a level deep enough to understand the type level machinery behind it. What do we need to learn specifically? And what is some good material to learn it?
17:20:12 <amy_monnet> Assuming we are already familiar with "vanilla" haskell
17:20:33 <electricityZZZZ> why not build something with it instead? i think it's pretty mature
17:20:57 <amy_monnet> So far I've noticed AGDTs, Data.Kinds, Type families, Type operators
17:21:26 <Axman6> amy_monnet: this probably isn't a very satisfactory answer, but I would just spend some time reading the source, particularly the instances for the various classes like HasServer, HasClient
17:21:32 <electricityZZZZ> i dont think there is agreement on which language extensions are standard,...
17:21:32 <pounce> why am i getting the error "No instance for (GHC.Exts.IsList (UArray Int Int))"
17:21:40 <pounce> sorry still trying to figure out array types
17:22:15 <Axman6> pounce: probably because there isn't an instance for IsList for UArray :P (that would surprise me, but it's possible)
17:22:45 <amy_monnet> electricityZZZZ we're more keen on understanding the machinery behind it before we build something
17:22:57 <amy_monnet> @Axman6 I think that's a pretty satisfactory answer
17:22:58 <lambdabot> Unknown command, try @list
17:23:10 <shapr> I think I have ghcide installed and turned on in emacs, now what?
17:23:25 <amy_monnet> Axman6 I think that's a pretty satisfactory answer
17:24:16 <electricityZZZZ> amy_monney: i used to be like you and i get a lot more value per unit time invested by just doing stuff. computers and software are too complicated to fit in any human mind
17:24:30 <electricityZZZZ> "like you" means trying to understand everything in detail first
17:24:32 <shapr> amy_monnet: you could randomly walk the LANGUAGE pragmas in the source and learn those things?
17:25:00 <shapr> electricityZZZZ: eh, I think everybody has their own way of learning.
17:25:24 <Axman6> amy_monnet: I learnt a lot just by reading the source, once you think you have a reasonable understanding of it, try adding your own type level combinator - one that I have suggested to be added to servant in the past is something like a TimeStamp (formatStr :: Symbol) a type which can be used so do things like write "foo :> Capture "from" (TimeStamp "%Y-%m-%d" UTCTime) :> ...
17:25:52 <shapr> I was just reading https://wiki.haskell.org/GADTs_for_dummies earlier
17:26:19 <shapr> I was reading something about DataKinds too, where did I put that ...
17:26:21 <pounce> hmm, wonder how to make it then
17:26:47 <alc> is there a data type, data T = V a b, f $ V a b = a, g $ V a b = b? except tuple, I thought Either, but data Either = Left a | Right b, I need a product type not sum type
17:27:06 <Axman6> that's definitely just a tuple
17:27:10 <alc> ok
17:27:48 <shapr> amy_monnet: do you have any specific questions?
17:27:53 <alc> how to turn (a,b) to (a,b,c)?
17:28:04 <alc> with list we can do [a,b] <> [c]
17:28:09 <amy_monnet> Tjamls Axman6. My friend also talked to their lecturer who codes a lot in haskell and they mentioned to use scotty instead of servant. Supposedly scotty is easier to use? But to be honest I found that there was not much documentation for scotty whilst the servant documentation is great so far
17:28:21 <amy_monnet> Thanks Axman6 *
17:28:33 <Axman6> tuples aren't algebraic types, you do that by writing a function which does it
17:28:48 <alc> Axman6: you mean use fst and snd?
17:28:58 <shapr> amy_monnet: I just built a vaguely useful app with scotty if you have questions
17:29:00 <Axman6> extend :: (a,b) -> c -> (a,b,c); extend (a,b) c = (a,b,c)
17:29:22 <amy_monnet> shapr have you used servant before?
17:29:30 <alc> Axman6: this extend is not in Data.Tuple, right?
17:29:35 <alc> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Tuple.html
17:29:59 <shapr> amy_monnet: I think I tried it once, and decided the type level machinery is too much for the small things I'm building now.
17:30:49 <shapr> amy_monnet: here's the thing I built in scotty: https://imgur.com/gallery/YNez0sA
17:31:02 <shapr> that's the front end, and here's the source: https://github.com/shapr/fermatslastmargin
17:31:14 <Axman6> amy_monnet: personally I find Servant easier to use, bnecause it lets me clearly encode my trhoughts in types, and the compiter tells me when I'm wrong. I'm not sure that scotty really helps there. I've used servant quite a lot (there are services being run by the Australian Government using them, but shhh), and I really like using it for any sized API, just because you get so much for free 
17:31:40 <shapr> scotty definitely does not check your APIs, I'm having issues with that sometimes
17:31:58 <amy_monnet> nice name
17:32:07 <shapr> My http endpoints just skip the type system entirely, and that causes issues
17:32:28 <iqubic> alc: If you think you need to use a function of type "(a,b) -> c -> (a,b,c)" then I recommend thinking long and hard about why. I can't think of a single good use for that function.
17:32:40 <Axman6> shapr: and you have to live with yourself for that - at least it will make the javascript feel familliar :P
17:32:53 <electricityZZZZ> amy_monnet: you're probably familiar with fpcomplete/msnoyman who authors yesod... he offers formal haskell training, if that's useful to you. https://www.fpcomplete.com/blog
17:33:08 <shapr> Axman6: if I get some users I'll clean it up, but it does what I wanted it to do for me
17:33:14 <iqubic> lists and tuples are two very diffeent things. You shouldn't be mixing the two.
17:33:22 <amy_monnet> Axman6 you've done work for the Australian government? I'm also in australia but was unaware you could get a job coding in haskell..
17:33:33 <shapr> amy_monnet: oh I just got a Haskell job this week!
17:33:39 <Axman6> electricityZZZZ: answering someone's question about how to learn about something with "you shouldn't learn that" is very unproductive
17:33:44 <amy_monnet> shapr also in australia?
17:33:48 <shapr> nah, USA
17:33:53 <shapr> Boston to be specific
17:34:05 <Axman6> amy_monnet: I'm currently working at SEEK, wringing Haskell - we exist, but we are few
17:34:10 <electricityZZZZ> axman6: nah i was just saying to dive in :-P
17:34:11 <shapr> wringing, ha!
17:34:14 <Axman6> writing*
17:34:19 <amy_monnet> Axman6 are you guys hiring?
17:34:41 <Axman6> I mean, we've got a few hundred thousand jobs, but most of them aren't ours :P
17:35:22 <Axman6> but no, they have decided that Haskell isn't for them, so they don't have any Haskell jobs. probably some Scala ones, but then you have to use Scala, and )friends don't let friends use Scala
17:36:06 <Axman6> speaking on which, I'll be needing a new job in the next few months, anyone hiring? :)
17:36:22 <shapr> Axman6: want a list?
17:36:30 <shapr> I know a bunch in the USA
17:36:47 <amy_monnet> shapr are there any jobs in USA that would hire Aus developers to work remote?
17:36:49 <alc> iqubic: https://www.codewars.com/kata/573992c724fc289553000e95/train/haskell
17:36:53 <Axman6> Remote would be best, not keen to make the move to Trumpistan at the moment
17:36:57 <alc> smallest(261235) --> [126235, 2, 0] or (126235, 2, 0) or "126235, 2, 0"
17:37:05 <alc> smallest :: Integer -> (Integer, Int, Int)
17:37:06 <shapr> amy_monnet: I don't know, I never thought to ask. I'm a US citizen.
17:37:19 <alc> it should use [Integer, Int, Int) I think
17:37:27 <shachaf> whoa
17:37:39 <shachaf> I've heard of half-open intervals [a,b), but never of half-list half-tuples.
17:37:45 <shapr> I think it's cool
17:37:46 <amy_monnet> *sigh*. The difficulties of living in a smaller city :(
17:37:50 <shachaf> That's a real innovation.
17:38:01 <Axman6> amy_monnet: where are you, if you dson't mind me asking
17:38:06 <amy_monnet> Perth
17:38:10 <shapr> amy_monnet: but if you want to learn Haskell, lots of friendly people on this channel willing to help :-)
17:38:52 <Axman6> "smaller city" pfft, I'm in Canberra
17:39:15 <shapr> I gotta visit Australia someday, I have no idea about any of this.
17:39:35 <amy_monnet> Axman6 you win
17:39:42 <Axman6> shapr: hit me up if you do, you can come and speak at CanFP
17:40:01 <shapr> oh that'd be cool
17:40:13 <shapr> I like giving talks!
17:40:58 <Axman6> I can also get you in touch with the organises of FP-Syd and BFPG if you want to do a speaking tour :P
17:41:31 <shapr> it won't happen soon, I'm starting a job in a few weeks
17:41:41 <shapr> moving to Boston
17:41:45 <shapr> good thing I like moving
17:42:21 <Axman6> Hey, are you walkin there?
17:51:08 <amy_monnet> where are the official docs for ghc language exentions?
17:51:12 <amy_monnet> extensions*
17:51:44 <amy_monnet> Like for example if I wanted to read the official docs on Data.Kinds where would I go?
17:51:49 <amy_monnet> and are the official docs any good?
17:52:30 <ChaiTRex> amy_monnet: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
17:52:44 <Axman6> yes and yes - the documentation can be ofund at haskell.org/ghc I think
17:53:06 <davean> shapr: Australia? I've got to head back soon. You joining?
17:54:21 <amy_monnet> Thank you :)
17:54:41 <alc> can Integer convert to Int?
17:54:50 <davean> alc: partially
17:55:04 <alc> davean: how?
17:55:14 <davean> fromInteger
17:55:26 <davean> but if its out of the Int range ...
17:55:31 <amy_monnet> anyway I better do some work guys thanks for all the help! 
17:55:34 <davean> alc: all the conversions are part of the standard numeric tower
17:55:39 <alc> davean: and the reverse?
17:55:49 <alc> davean: Int to Integer?
17:55:53 <davean> toInteger
17:56:00 <davean> alc: Just look at the Num type class, etc
17:56:38 <Axman6> also fromIntegral will work for both those operations
17:56:47 <davean> Axman6: Yah, in this specific case
17:57:58 <davean> alc: Why do you think its safe to do that conversion though in your case?
18:06:00 <alc> davean: it's just an exercise, not real to use, but Int is big enough I think
18:17:49 <tinysteps> Hello. I am trying to use a MinPrioHeap (https://hackage.haskell.org/package/heap-1.0.4/docs/Data-Heap.html) but I can't seem to figure out how to do anything other than instantiate an empty heap and a singleton.
18:18:34 <davean> tinysteps: you see "insert :: HeapItem pol item => item -> Heap pol item -> Heap pol item"?
18:18:46 <tinysteps> yes
18:19:05 <davean> So are you confused by "HeapItem pol item =>"?
18:20:03 <tinysteps> sort of
18:20:26 <davean> what about it?
18:21:20 <pounce> what's a closed form for something like `let l = [1,2,3,4,5] in do a<-l;b<-l;c<-l;d<-l; [a,b,c,d]`
18:22:01 <ephemient> > replicateM 4 [1,2,3,4,5]
18:22:03 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,2,1],[1,1,2,2],[1,1,...
18:22:11 <tinysteps> I'm not sure. I'm not sure what I'm not understanding. Let's take `viewHead $ singleton (1, "a")` as an example. I get an error saying there is an ambiguous type variable (pol0) and that I should add annotations. I've tried adding annotations and can't seem to figure it out.
18:22:12 <pounce> thank you! i keep forgetting this functios
18:22:32 <davean> tinysteps: you ahven't said if it is a Min or Max queue
18:22:42 <tinysteps> MinPrioQueue
18:22:49 <tinysteps> MinPrioHeap*
18:22:50 <davean> You have to know which direction it needs to be in to construct it even for one element
18:23:00 <tinysteps> I don't understand
18:23:06 <tinysteps> direction?
18:23:08 <ephemient> tinysteps: {-# LANGUAGE TypeApplications #-} may help
18:23:25 <davean> tinysteps: if it should be minimum value first or maximum value first
18:23:40 <tinysteps> minimum
18:23:41 <ephemient> the expression you entered above is ambiguous, you need to disambiguate it somehow
18:23:49 <tinysteps> yes but I don't know how
18:24:07 <tinysteps> I tried this: `viewHead $ singleton (1, "a") :: HeapItem FstMinPolicy (Integer, String) => Maybe (Integer, String)`
18:24:09 <ephemient> you can do it with explicit types or with type applications
18:24:25 <tinysteps> this: `viewHead $ singleton (1, "a") :: Maybe (Integer, String)`
18:24:31 <davean> tinysteps: ok, so you tried to put in the type for viewHead
18:24:43 <davean> but you had already applied view head to something
18:24:55 <ephemient> HeapItem isn't a type
18:25:09 <davean> yah, its a class constraint.
18:25:23 <davean> tinysteps: so lets go step by step
18:25:23 <tinysteps> right hence the `=>`
18:25:28 <ephemient> and isn't part of thet type of the result either, so that doesn't help
18:25:33 <davean> singleton (1, "a")
18:25:43 <davean> Thats typing to build a queue, but it doesn't know what to build
18:26:25 <davean> singleton (1, "a")::Heap FstMinPolicy (Integer, String)
18:26:30 <davean> That specifies what you're building
18:26:45 <tinysteps> right
18:26:54 <tinysteps> I had `singleton (1, "a") :: MinPrioHeap Int String`
18:27:04 <davean> Great, and that worked, right?
18:27:07 <tinysteps> yes
18:27:17 <davean> ok, so then just apply viewHead to that
18:27:45 <tinysteps> ah
18:28:07 <tinysteps> thanks
18:28:11 <tinysteps> another question comes to mind
18:28:13 <davean> Once it knows what to work with, it can work with it
18:28:36 <tinysteps> what if I wanted to annotate the result of `viewHead $ singleton (1, "a")` rather than annotating singleton?
18:28:55 <tinysteps> what would the type signature for the result of viewHead look like?
18:29:12 <ephemient> you can't directly, it's always ambiguous because the policy gets lost
18:29:13 <davean> Irrelivent to the abiguity. It produces a result - the order of the heap is not involved in the result
18:29:13 <tinysteps> it's a `Maybe (Int, String)` but just adding that didn't seem to work
18:29:27 <ephemient> > viewHead $ singleton @FstMinPolicy (1, "a")
18:29:27 <davean> tinysteps: right, the result of viewHead has nothing to do with how that was calculated
18:29:28 <lambdabot>  error:
18:29:28 <lambdabot>      Pattern syntax in expression context: singleton@FstMinPolicy
18:29:28 <lambdabot>      Did you mean to enable TypeApplications?
18:29:55 <tinysteps> I see
18:29:59 <ephemient> that is one way to disambiguate, with extensions
18:30:50 <davean> tinysteps: Think of it this way - if you know my answer is "Yes" you haven't learned anything deep about the question.
18:31:55 <tinysteps> right
18:32:29 <davean> Another arrangement that might make it more clear is paranethesised
18:32:42 <davean> viewHead (singleton (1, "a") :: MinPrioHeap Int String)
18:32:51 <davean> That will work because you've said what thing viewHead is working on
18:33:07 <davean> (These are all different ways to say the same solution BTW)
18:34:20 <tinysteps> right
18:35:02 <ephemient> if you're working with type variables that won't always be easy
18:35:21 <tinysteps> what do you mean?
18:35:54 <ephemient> {-# LANGUAGE ScopedTypeVariables #-} and {-# LANGUAGE TypeApplications #-} to the rescue
18:36:44 <davean> its a crime that ScopedTypeVariables isn't the language standard
18:37:25 <ephemient> ok, imagine a function f a = viewHead (singleton (1, a))
18:37:55 <ephemient> where f :: a -> Maybe (Int, a)
18:38:12 <tinysteps> ok
18:38:45 <ephemient> you can't annotate (singleton ... :: MinPrioHeap Int a) because Haskell doesn't think it's the same a
18:39:43 <tinysteps> hmmmm
18:39:44 <tinysteps> interesting
18:40:02 <tinysteps> is there a way of denoting the type of a in type annotations?
18:40:12 <ephemient> to be pedantic, you can annotate it, it just won't typecheck lol
18:41:06 <tinysteps> I see
18:41:13 <ephemient> so. ScopedTypeVariables lets you bring in a forall. qualified type variable a from the outer scope to the inner scope
18:41:51 <ephemient> or, TypeApplications lets you express this without needing to specify that variable
18:42:21 <tinysteps> I am not sure what outer scope and inner scope refer to in this context
18:43:05 <ephemient> f :: forall a. a -> Maybe (Int, a) -- outer
18:43:44 <ephemient> f a = ... (singleton ... :: ... {- inner -})
18:43:57 <tinysteps> oh I see
18:44:18 <tinysteps> so the inner type annotation can refer to the same type variables as the outer type annotation?
18:44:28 <shapr> davean: when are you going to australia? I'd love to come with
18:44:31 <davean> if you use ScopedTypeVariables
18:44:50 <davean> shapr: lets OOC that
18:44:57 <shapr> ok
18:45:06 <tinysteps> cool
18:45:35 <ephemient> would be nice if we had a Haskell2020 standard that enabled that by default
18:45:51 <davean> It would make my week if the language standard changed to make it just be ScopedTypeVariables - it would match the rest of the language and fix an annoying hole.
18:46:06 <electricityZZZZ> what's this about haskell2020 falling through....?
18:46:57 <ephemient> as I understand it, basically the community needs more cat herders
18:47:20 <davean> I almost want ScopedTypeVariables enough to sign up for it even
18:50:03 <alc> when fmap (\x -> insert x l) l, how to remove x itself from l?
18:50:09 <ephemient> in this case I prefer the https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications though
18:50:35 <Axman6> (`insert` l)
18:50:42 <Axman6> or flip insert l
18:50:54 <davean> ephemient: Yah, this case is a very good use of TypeApplications
18:50:58 <shachaf> But don't ever write flip into any program.
18:51:19 <alc> fmap (\x -> ...) [1,2,3,1]  when x is 1 then insert 1 in [2,3,1], when x is 2 then insert 2 in [1,3,1] ...
18:51:40 <Axman6> flip runReaderT env is something I write quite often
18:51:42 <alc> it needs remove the element itself when fmap apply f on a list
18:52:07 <ephemient> :t delete
18:52:09 <lambdabot> Eq a => a -> [a] -> [a]
18:52:58 <alc> zip [0..] l to tag it?
18:53:18 <alc> so can remove x itself when f (\x -> ..) l
18:54:18 <tinysteps> Thank you very much davean and ephemient. I am not sure why but I had to enable Flexible Contexts to get my code to work (my questions were in the context of writing Dijkstra's algorithm), but it seems to work now! =D 
18:55:56 <alc> how to drop an element of a list with specific index? like drop 1 ['a','b','c','d
18:55:59 <alc> ]
18:56:12 <alc> ['a','c','d']
18:56:44 <ephemient> tinysteps: that would be because you can't have the type MinPrioHeap Int a without FlexibleContexts
18:57:13 <tinysteps> I don't think I had a type variable anywhere though
18:57:20 <tinysteps> `toVisit = Heap.singleton (0, from) :: Heap.MinPrioHeap Int String`
18:57:21 <ChaiTRex> alc: take n xs ++ drop (n + 1) xs
18:57:41 <dmwit> splitAt for max efficiency
18:57:43 <alc> ChaiTRex: filter
18:57:46 <ephemient> the issue is, oddly, that Int isn't a type variable
18:58:04 <ChaiTRex> @src splitAt
18:58:04 <lambdabot> splitAt n xs = (take n xs, drop n xs)
18:58:15 <Axman6> but not actually
18:58:18 <alc> > filter (`elemIndex` $ Just 1) ['a','b','c']
18:58:20 <lambdabot>  <hint>:1:21: error:
18:58:20 <lambdabot>      parse error on input ‘$’
18:58:20 <lambdabot>      Perhaps you intended to use TemplateHaskell
18:58:50 <tinysteps> ephemient: interesting
18:59:03 <dmwit> alc: What do you think `fmap (\x -> insert x l) l` does? Does the compiler agree with you?
18:59:17 <tinysteps> could you explain why?
18:59:36 <dmwit> alc: Your questions smell like an XY problem. (If you don't know what "XY problem" means, I will explain it.)
18:59:39 <alc> dmwit: that's not complete function
19:00:08 <alc> dmwit: no, that's a haskell question, I'm doing an haskell exercise
19:00:35 <dmwit> I agree that it's a Haskell question. But I still believe it is an XY problem.
19:00:44 <dmwit> You can have an XY problem in any language.
19:01:24 <infinisil> though maybe the exercise is exactly what they're asking here
19:01:26 <alc> dmwit: https://paste.ubuntu.com/p/DwHFPJCVMz/
19:01:55 <alc> s x = let l = f4 x in f2 (sort (fmap (\x -> insert x (l \\ [x])) l) !! 0)
19:02:19 <alc> this function has a little issue, 'cause \\ only remove the first it meet, not the element itself
19:02:53 <alc> fmap (\x -> insert x (l \\ [x])) l
19:03:31 <alc> I need remove x itself when this lambda work on the list
19:03:48 <alc> \\ can't work if there're duplicate element
19:03:50 <dmwit> I like `zippers :: [a] -> [([a], a, [a])]; zippers = go [] where go _ [] = []; go ys (x:xs) = (ys, x, xs) : go (x:ys) xs` for this kind of task.
19:04:02 <ephemient> tinysteps: first result https://stackoverflow.com/q/31251163 has some examples that are a bit cumbersome to copy-paste into irc
19:04:11 <dmwit> No need to take+drop, no need to splitAt, no need to filter, no need to label indices, no need to have indices at all.
19:04:46 <dmwit> ?let zippers :: [a] -> [([a], a, [a])]; zippers = go [] where go _ [] = []; go ys (x:xs) = (ys, x, xs) : go (x:ys) xs
19:04:48 <lambdabot>  Defined.
19:04:49 <tinysteps> ephemient: cool, thank you
19:04:50 <dmwit> > zippers "abcde"
19:04:53 <lambdabot>  [("",'a',"bcde"),("a",'b',"cde"),("ba",'c',"de"),("cba",'d',"e"),("dcba",'e'...
19:06:09 <alc> > zippers [1,8,7,8,6,3,0,0,2,8,0,9]
19:06:11 <lambdabot>  [([],1,[8,7,8,6,3,0,0,2,8,0,9]),([1],8,[7,8,6,3,0,0,2,8,0,9]),([8,1],7,[8,6,...
19:06:38 <alc> zippers [1,0,0,2,0,8]
19:07:10 <dmwit> Consider defining it in your file and playing with it in ghci.
19:07:20 <dmwit> That way you get the whole output, not lambdabot's truncated partial output.
19:09:52 <dmwit> alc: But also, if you think a bit more, you can just directly pick the right answer.
19:09:58 <dmwit> You don't need to try a bunch of different choices.
19:11:44 <alc> dmwit: right anwser directly to the whole question or just fmap work on a list remove element itself?
19:11:55 <dmwit> Right answer directly to the whole question.
19:12:29 <alc> yeah, I assume there must be one line or two line haskell code can solve that whole question
19:12:39 <dmwit> One pass over the list will suffice to decide the value of the digit to move. One pass will suffice to decide which copy of that digit to move. One pass over the list will choose the correct location to put it.
19:12:43 <dmwit> Some of the passes can be combined.
19:12:55 <dmwit> -can be +may be able to be
19:20:13 <dmwit> Oh, heck, the last loop isn't needed at all.
19:28:48 <dmwit> > uncurry (:) . fst . foldr (\x ~(~(m,o),w) -> let s :: a -> a -> a; s a b = if x < m then a else b in ((s x m, s w (x:o)), x:w)) ((maxBound, []), []) $ "187863002809"
19:28:50 <lambdabot>  "018786300289"
19:29:26 <dmwit> > uncurry (:) . fst . foldr (\x ~(~(m,o),w) -> let s a b = if x < m then a else b in ((s x m, s w (x:o)), x:w)) ((maxBound, []), []) $ "100208"
19:29:27 <lambdabot>  error:
19:29:28 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
19:29:28 <lambdabot>        Expected type: [[a]]
19:29:31 <monochrom> (me,o),w
19:29:57 <dmwit> why lost polymorphism? =(
19:31:20 <monochrom> Hrm, yeah, that's strange.
19:32:10 <alc> what is ~?
19:32:15 <alc> :t (~)
19:32:17 <lambdabot> error: parse error on input ‘)’
19:32:55 <ChaiTRex> alc: It's magic.
19:33:06 <alc> never saw it before except for type m~(e->a)
19:33:19 <dmwit> ~pat is a pattern that always matches and binds the same things that pat does in the same way, but throws a runtime error if the pattern didn't actually match.
19:33:43 <dmwit> Tuples in particular can never have a different shape, so it's fine there.
19:33:46 <dmwit> But e.g. consider
19:34:00 <dmwit> > let f ~(Just x) = x in (f (Just 3), f Nothing)
19:34:02 <lambdabot>  (3,*Exception: <interactive>:3:5-19: Non-exhaustive patterns in Just x
19:36:03 <alc> too fancy to me now...
19:36:30 <dmwit> Ignore the ~.
19:36:34 <dmwit> Read it as if they aren't there.
19:36:37 <ChaiTRex> > let f ~(Just x) = x; f Nothing = 5 in f Nothing
19:36:39 <dmwit> You will get the important part of it.
19:36:40 <lambdabot>  *Exception: <interactive>:3:5-34: Non-exhaustive patterns in Just x
19:37:05 <dmwit> They are a performance hack, here and almost everwhere they are used.
19:38:26 <dmwit> > let notNot ~True = False; notNot False = True in notNot False
19:38:29 <lambdabot>  False
19:46:23 <ezzieyguywuf> I'm working my way through "Real World Haskell" after getting a bit over halfway through "Learn you a Haskell for Great Good!", and I have a question regarding `showHex` -> what is a `ShowS` and why does the `showHex` usages in the book require a blank `""` at the end?
19:46:41 <ezzieyguywuf> I get that it takes an integer and converts it to hexadecimal, but I don't understand why the empty string is needed
19:47:38 <monochrom> ShowS is a type synoym for String->String
19:48:16 <ezzieyguywuf> monochrom: how can I deduct that, or find documentation of that, in ghci?
19:48:18 <mrkgnao> operations on ShowS is how Show instances "actually" work, and it's needed because concatenating haskell strings is really slow 
19:48:20 <monochrom> > showHex 3 "mystring"
19:48:22 <lambdabot>  "3mystring"
19:48:25 <ezzieyguywuf> I tried `:info ShowS` to no avail
19:48:37 <mrkgnao> > :info ShowS
19:48:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
19:48:54 <monochrom> lambdabot doesn't have :info
19:49:06 <mrkgnao> yeah it's been a long time since i was last on irc
19:49:19 <ezzieyguywuf> hah nvm it did show info
19:49:22 <monochrom> ":info ShowS" works in my ghci
19:49:23 <ezzieyguywuf> I guess I just didn't get it :-P
19:49:50 <ezzieyguywuf> "type ShowS = String -> String   "
19:49:52 <mrkgnao> so to "get the string out of a ShowS" one applies it to the empty string
19:50:16 <ezzieyguywuf> mrkgnao: that makes sense thanks.
19:50:28 <monochrom> In general, showHex 3 yourString = "3" ++ yourString.  There is a technical reason why it can be preferrable to do String->String like this rather than String alone.
19:50:28 <mrkgnao> https://stackoverflow.com/questions/9197913/what-is-the-shows-trick-in-haskell
19:50:48 <ezzieyguywuf> if I run into another function that I can't decipher with the `:info` information, what other resources/references can I use?
19:51:09 <monochrom> I find the library docs.
19:51:14 <mrkgnao> the idea is that composing functions (with (.)) is much more efficient than concatenating haskell strings, so we convert the latter problem into the former with this "trick"
19:51:38 <mrkgnao> ezzieyguywuf: hoogle is a great resource too
19:52:01 <monochrom> I always tell cabal to build docs locally.
19:52:14 <mrkgnao> yup, that's really useful
19:52:24 <ezzieyguywuf> mrkgnao: nice stackoverflow link!
19:52:59 <ezzieyguywuf> haven't gotten far enough in Real World Haskell to get into cabal yet
19:53:01 <monochrom> Problem with online docs is: with Google it always points you to an outdated version, with Hackage you have to carefully compare versions too.
19:53:05 <ezzieyguywuf> although I guess it's some sort of packaging manager?
19:53:41 <monochrom> cabal is extra code builder and installer
19:53:50 <ezzieyguywuf> yes even in Real Work Haskell I can see there are some version specific nuances and even errors versus my version 8.0.2
19:53:58 <monochrom> bordering on package manager but not quite
19:54:31 <mrkgnao> wow, 8.0.2
19:54:36 <ezzieyguywuf> ?
19:54:38 <mrkgnao> is nothing more recent available on your OS/setup?
19:54:43 <ezzieyguywuf> lol I don't think so
19:54:57 <mrkgnao> oh :(
19:55:57 <ezzieyguywuf> yea. At least, it's the latest 'safe' version. looks like I can get as high as 8.8.1, but then I have to start doing wonky stuff
19:56:30 <mrkgnao> interesting, what OS are you on
19:56:34 <ezzieyguywuf> gentoo linux
19:57:05 <mrkgnao> ah
19:57:11 <monochrom> On Windows you should go through Chocolatey.  On Linux and Mac you should use ghcup.  Both of them default to a very sensible recent version.
19:57:44 <mrkgnao> yeah i'd prefer something like that to the OS package manager's (emerge in this case) preferred version of ghc
19:58:01 <ezzieyguywuf> might do that
19:58:06 <mrkgnao> stack is also an option but i don't know how that's doing, i've been Nix-only for so long
19:58:13 <monochrom> Do not religionize your distro's repo.
19:58:25 <ezzieyguywuf> a cursory glance suggests that maybe ghcup installs what it needs in ~, and then...updates PATH to point there?
19:58:36 <mrkgnao> yes, it's similar to rustup etc i guess
19:58:54 <ezzieyguywuf> nah, I don't, I regularly compile local copies of newer stuff as needed, typically for development projcets
19:59:15 <ezzieyguywuf> lol, I don't know about rutsup but perhaps I'll try this ghcup
19:59:27 <alc> monochrom: what Chocolatey is used for?
19:59:30 <ezzieyguywuf> is it any better/different than simply downloading the ghc source and compiling manually?
20:00:01 <monochrom> Yes. Hassle to setup, then takes forever to build.
20:00:47 <monochrom> To build GHC you first need so many extra build tools I lost track and stopped doing it.
20:00:48 <alc> why not cable or stack
20:01:57 <ezzieyguywuf> ah, so ghc just installs some prebuilt binary?
20:02:05 <ezzieyguywuf> *ghcup
20:02:08 <monochrom> Yes.
20:02:25 <monochrom> On Linux don't religionize "it's either from my distro or build from source".
20:02:40 <mrkgnao> compiling ghc is a last-ditch thing for most people and usually haskell build tools go to great lengths to avoid doing that
20:03:13 <mrkgnao> because it takes way too long, eats a lot of memory, and (for non-source-distro-minded people *wink*) provides little benefit
20:04:59 <Logio> only 30 minutes of compile on 16 threads and 32 gigs of memory for me, doesn't keep the house warm for long
20:06:01 <ezzieyguywuf> hah, to a seasoned gentoo user, 30 minutes is nothnig
20:06:23 <Logio> I'm also on Gentoo, for dev stuff I've used a separate ghc install (or stack) before
20:06:27 <monochrom> Combine that with a genetic algorithm to discover how to implement Dependent Haskell.
20:06:30 <mrkgnao> it's going to be 40 degrees celsius in a few months where i live, which is obviously the only reason i'm not a gentoo user :)
20:06:33 <davean> Logio: how are you compiling GHC in 30 minutes?
20:06:39 <Axman6> compile it alongside a FreeBSD and LLVM build
20:07:04 <Logio> davean: with the given specs on a two-year old ryzen
20:07:30 <davean> Logio: you sure you're compiling GHC?
20:07:44 <Logio> don't ask me how long it took with my previous phenom II x4, that was torture
20:07:49 <davean> That doesn't sanity check
20:08:33 <ezzieyguywuf> Logio: yea, I'm thinking that makes sense since the gentoo package is so out of date
20:08:45 <Logio> assuming my build logs are correct, but generally they are never faster than the actual time 
20:08:50 <monochrom> I guess for gentoo people it's "it's both from my distro and I build from source".
20:09:00 <Logio> but that is for 8.0.2, newer ones might take longer
20:09:52 <davean> Logio: Yah, even for 8.0.2 thats way too short
20:09:56 <Logio> ezzieyguywuf: there is the "binary" USE flag, which just installs the binary used for bootstrapping
20:10:04 <davean> (how are you still on 8.0.2?)
20:10:12 <ezzieyguywuf> Logio: yea but everything over 8.0.2 is hard masked
20:10:15 <ezzieyguywuf> at least for me...
20:10:28 <davean> I mean I guess I haven't tried building 8.0.2 on a very modern system
20:10:28 <Logio> ezzieyguywuf: sure, if you really need it then unmask it
20:10:36 <monochrom> (Why is everyone still on 8.0.2? :) )
20:10:39 <davean> but that would be a truely massive speadup
20:10:49 <davean> monochrom: This is the first I've heard of 8.0.2 in years
20:11:26 <Logio> davean: I mean, this system also compiles firefox in 20min (whereas my previous 2010 system took over 2 hours)
20:11:41 <monochrom> It's like a time-wise worm hole has formed and we're now IRCing with people from the past...
20:11:51 <ezzieyguywuf> Logio: hrm, I don't usually have a probably unmasking a keyword, but a hard mask is a different story
20:12:13 <davean> Logio: Yah I mean I'm involved in building GHC a lot
20:12:15 <Logio> ezzieyguywuf: as it should be.
20:12:19 <monochrom> Hey you guys want some lottery numbers from year 2020? :)
20:12:27 <davean> Logio: it would be world changing if it was even theoreticly possible to get a build that fast
20:13:19 * ezzieyguywuf nods
20:13:32 <ezzieyguywuf> thus, I'd probably rather use ghcup rather than the hard masked newer gentoo version
20:13:53 <davean> ezzieyguywuf: any idea why its hard masked?
20:13:56 <Logio> ezzieyguywuf: I guess it depends on whether your system actually has something that depends on ghc
20:14:03 <ezzieyguywuf> davean: do you use ccache? maybe Logio is using distcc as well?
20:14:13 <ezzieyguywuf> or...are those gcc-specific. lol.
20:14:27 <davean> ezzieyguywuf: distcc wouldn't help because the problem is the sequential portions
20:14:36 <ezzieyguywuf> Logio: it doesn't. At least I don't think so. I'm just trying to learn the  language
20:14:44 <ezzieyguywuf> davean: I do not know why
20:14:47 <davean> theres serious bottlenecks in the GHC build graph
20:14:59 <davean> ezzieyguywuf: ccache woudln't be a full build
20:15:19 <ezzieyguywuf> davean: right, ccache would help on incremental changes after the first build
20:15:25 <Logio> not even using a ramdisk for compile on this (though I think the nvme drive is pretty fast already)
20:15:33 <davean> that would be a cache build, which is notably different - but not terribly relivent to GHC since GHC rebuilds its self so the 2nd (and 3rd) stage builds would be the same as they always are anyway.
20:15:44 <davean> ezzieyguywuf: but GHC isn't a one-stage build so it wouldn't.
20:16:01 <davean> ezzieyguywuf: it could only help with stage1
20:16:20 <mrkgnao> is the v2 set of cabal commands ready for use without running it off of Nix?
20:16:30 <mrkgnao> or do i need stack or something
20:16:33 <davean> mrkgnao: "running it off of nix"?
20:16:39 <davean> huh?
20:16:42 <davean> cabal has nothing to do with nix
20:16:44 <sclv> its the official set of commands when using cabal 3.0
20:16:47 <monochrom> v2 does not need nix. merely inspired by nix.
20:16:49 <sclv> so its definitely ready for use
20:16:59 <mrkgnao> as in running it inside a Nix shell that provides all the actual hackage deps
20:17:08 <mrkgnao> so cabal isn't downloading or building the dependencies
20:17:18 <sclv> the v2 stuff never interacted with nix shell stuff
20:17:18 <sclv> its always been independent
20:17:20 <davean> mrkgnao: what are you talking about? That has nothing to do with cabal.
20:17:23 <sclv> nix never helped/hurt v2 stuff
20:17:32 <mrkgnao> ah okay
20:17:38 <sclv> it did/does help/interact with v1 stuff
20:17:56 <sclv> and yeah, if you use a new cabal 3 binary, then `cabal build` already does `cabal v2-build`
20:17:58 <sclv> so its all there
20:18:13 <mrkgnao> davean: apologies, i never really looked very deep into how cabal/nix were/weren't interacting, i had a Nix+Cabal project template of my own that i used for most everything
20:18:29 <mrkgnao> so my understanding of the interactions or lack thereof isn't all there
20:18:57 <davean> mrkgnao: mmm, cabal doesn't know about nix.
20:19:07 <Logio> davean: I don't know if the gentoo package is doing something funny (or rather, there's quite a bit of stuff in the ebuild to figure out what's happening)
20:19:17 <mrkgnao> so right now cabal v2-* is sandboxed-by-default builds that i can use in different projects without worrying about ye olde Cabal Hell(tm)?
20:19:27 <davean> Logio: I think what it is doing is doing the install of the binary distribution
20:20:04 <Logio> davean: that it definitely shouldn't be doing, since that option is not set
20:20:25 <sclv> mrkgnao: yes!
20:20:33 <monochrom> No.
20:21:14 <monochrom> v2 is anti-hell by a technique similar to nix's (so for example expect to see long hash codes), not by sandboxing.
20:21:39 <glguy> cabal heaven?
20:21:51 <mrkgnao> i mean "sandboxed" as in "noninteracting" 
20:22:05 <monochrom> this is why v2 is described "nix-style" and it is really just that, inspired by nix, not using nix.
20:22:07 <davean> mrkgnao: but they do interact - they can reuse builds the same way nix can
20:23:23 <mrkgnao> that's... transparent, the "only" visible change being faster builds. i was thinking of interactions like conflicts in versions of globally installed packages 
20:23:29 <monochrom> this is also why I don't like the wording "nix-style".  People dream up fantastic interpretations all the time.
20:23:51 <mrkgnao> fair
20:24:33 <monochrom> plus they always play that chain-of-phone-conversations game.
20:25:01 <davean> Logio: do you have 'ghcbootstrap' set? 
20:25:30 <monochrom> If the origin says "nix-style" and person A reads that and "explains" to person B, and person B "explains" to person C, and ... you can be sure by person Z it comes out as "it solves the halting problem".
20:26:39 <davean> Logio: looking through this ebuild file you have to do a lot to get it to do an actual build
20:26:51 <davean> and it'll throw warnings that you don't want that
20:30:49 <davean> this sure is complicated though
20:58:53 <dmj`> cabal purgatory
21:35:24 * hackage rio 0.1.13.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.13.0 (MichaelSnoyman)
21:37:42 <alc> what the version of fmap that f can take two list?
21:38:25 <MarcelineVQ> liftA2 possibly
21:38:25 <alc> I don't like to use zip
21:38:30 <c_wraith> a rather key point about Functor is that it can't combine structures.  Are you looking for Applicative and things like liftA2?
21:38:34 <alc> MarcelineVQ: but liftA2 is fmap
21:38:45 <Axman6> no it's not
21:38:47 <alc> it's <$> <*>
21:38:47 <MarcelineVQ> fmap is liftA1
21:39:07 <Axman6> :t fmap
21:39:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:39:12 <Axman6> :t liftA2
21:39:13 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:39:16 <Axman6> :t liftA3
21:39:17 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
21:39:23 <alc> but liftA2 will work on all the element of two lists, get all the permutations
21:39:42 <Axman6> then use zip
21:39:47 <c_wraith> So you want to zip the lists instead, but don't want to use zip?
21:39:48 <Axman6> zipWith*
21:40:02 <c_wraith> Is that like wanting to add numbers but not liking + ?
21:40:16 <alc> but zip give tuple, convertion between tuple and list, ew
21:40:25 <Axman6> use zipWith then
21:40:28 <Axman6> :t zipWith
21:40:30 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:40:36 <alc> ok
21:40:41 <alc> yes,like +
21:40:48 <Axman6> > zipWith (+) [1..10] [100,200..]
21:40:50 <lambdabot>  [101,202,303,404,505,606,707,808,909,1010]
21:41:23 <MarcelineVQ> yes it sounds like you want zipWith, or liftA2 where your list is ZipList.
21:42:20 <alc> > zipWith (fmap (+) [1..10]) [100,200..]
21:42:22 <lambdabot>  error:
21:42:22 <lambdabot>      • Couldn't match expected type ‘Integer -> b -> c’
21:42:22 <lambdabot>                    with actual type ‘[Integer -> Integer]’
21:42:35 <Axman6> if you don't want either of those then you need to tell us the behavour you're expecting
21:42:49 <Axman6> is
21:43:18 <alc> Axman6: still that question, remove element itself from the list when fmap apply function on the list
21:43:28 <alc> Axman6: you give me zippers
21:43:32 <Axman6> I don't understand what that means
21:43:39 <alc> deleteByIndex :: Int -> [a] -> [a]
21:43:43 <alc> deleteByIndex n xs = take n xs ++ drop (n + 1) xs
21:43:48 <alc> deleteByIndex 2 [1,2,3,5,7,8] == [1,2,5,7,8]
21:44:10 <iqubic> And what is the issue you need to overcome?
21:44:31 <alc> Axman6: sorry, I remember wrong
21:44:40 <Axman6> are you still working on https://www.codewars.com/kata/573992c724fc289553000e95/train/haskell?
21:44:41 <alc> "<dmwit> ?let zippers :: [a] -> [([a], a, [a])]; zippers = go [] where go _ [] = []; go ys (x:xs) = (ys, x, xs) : go (x:ys) xs"
21:44:46 <MarcelineVQ> a question you talked to dmwit 3 hours ago will be unknown to everyone else, you should probably repeat it
21:45:09 <alc> Axman6: yeah,
21:45:20 <alc> Axman6: I'd like to change my code to make it work
21:45:28 <dmj`> alc: filter ?
21:45:31 <Axman6> We'd all like to do that :P
21:46:21 <dmj`> alc: do you have to use fmap ?
21:46:28 <dmj`> @src filter
21:46:28 <lambdabot> filter _ []     = []
21:46:28 <lambdabot> filter p (x:xs)
21:46:28 <lambdabot>     | p x       = x : filter p xs
21:46:28 <lambdabot>     | otherwise = filter p xs
21:46:32 <iqubic> dmj`: He certainly doesn't
21:46:40 <dmj`> then filter it is
21:46:52 <alc> "<alc> fmap (\x -> ...) [1,2,3,1]  when x is 1 then insert 1 in [2,3,1], when x is 2 then insert 2 in [1,3,1] ..."
21:46:58 <iqubic> There's no requirement of what he has to use.
21:47:29 <alc> dmj`: because I need `insert` the element to its list for sort
21:47:36 <dmj`> alc: you want to write filterMap
21:47:56 <dmj`> filterMap :: (a -> Bool) -> (a -> b) -> [a] -> [b]
21:48:56 <dmj`> @def filterMap _ _ [] = []; filterMap pred f (x:xs) | pred x = f x : filterMap pred f xs | otherwise = filterMap pred f xs
21:48:58 <lambdabot>  Defined.
21:49:18 <dmj`> filterMap (
21:49:24 <dmj`> :t filterMap
21:49:26 <lambdabot> (t -> Bool) -> (t -> a) -> [t] -> [a]
21:49:42 <dmj`> :t filterMap @a @b
21:49:44 <lambdabot> error:
21:49:44 <lambdabot>     Pattern syntax in expression context: filterMap@a@b
21:49:44 <lambdabot>     Did you mean to enable TypeApplications?
21:50:03 <dmj`> > filterMap even (+1) [1..10]
21:50:05 <lambdabot>  [3,5,7,9,11]
21:51:09 <alc> dmj`: what's the expression to detect if the element equal itself in the list, if there're duplicate element in the list, and you may just want to remove one, 
21:51:18 <iqubic> :t let filterMap p f xs = mapMaybe (\x -> if p x then Just (f x) else nothing) xs
21:51:20 <lambdabot> <no location info>: error:
21:51:20 <lambdabot>     not an expression: ‘let filterMap p f xs = mapMaybe (\x -> if p x then Just (f x) else nothing) xs’
21:51:21 <alc> it may be the first or the second
21:51:40 <alc> remove the specific index is proper way I think
21:51:43 <iqubic> :t let filterMap pred f xs = mapMaybe (\x -> if pred x then Just (f x) else Nothing) xs
21:51:45 <lambdabot> <no location info>: error:
21:51:45 <lambdabot>     not an expression: ‘let filterMap pred f xs = mapMaybe (\x -> if pred x then Just (f x) else Nothing) xs’
21:52:03 <iqubic> :t let filterMap pred f xs = mapMaybe (\x -> if pred x then Just (f x) else Nothing) xs in filterMap
21:52:05 <lambdabot> (t -> Bool) -> (t -> b) -> [t] -> [b]
21:52:09 <iqubic> There we are.
21:52:13 <iqubic> That also works.
21:52:14 <dmj`> iqubic: nice
21:52:22 <dmj`> alc: it's not clear exactly what you're trying to do
21:52:37 <dmj`> alc: if the index given exists, then remove it from the list, if not, then add it to the list?
21:52:59 <iqubic> dmj`: He's trying to solve a programming puzzle. But he's going about it in a strange way.
21:53:25 <alc> dmj`: fmap f [1,2,3,4,5,6,7];  f take 1 and do something on [2,3,4,5,6,7],   f take 2 and do something on [1,3,5,6,7]
21:53:36 <iqubic> He has a set of steps he wants to follow to get the answer. And he's asking for help on each step one by one.
21:53:43 <alc> fmap (\x -> insert x (l \\ [x])) l
21:53:52 <alc> but \\ only remove once, 
21:53:57 <alc> without index
21:54:01 <iqubic> alc: That's not how you use fmap. You can't do that with fmap.
21:54:29 <iqubic> dmj`: He's trying to solve this puzzle: https://www.codewars.com/kata/573992c724fc289553000e95/train/haskell
21:54:55 <iqubic> And he has a set of steps in mind to get to the solution, but he hasn't shared those steps with anyone.
21:54:56 <alc> iqubic: I have my steps https://paste.ubuntu.com/p/DwHFPJCVMz/
21:55:00 <iqubic> Ah.
21:55:08 <alc> I just need one step to complete my code
21:55:24 <iqubic> Right. I see.
21:55:29 <alc> like I said there's just one step fmap (\x -> insert x (l \\ [x])) l
21:55:50 <alc> I just need to resolve this one step
21:57:16 <alc> and I did share here 3 hours ago, "<alc> dmwit: https://paste.ubuntu.com/p/DwHFPJCVMz/"
21:58:33 <alc> I can use zip to tag the list and use fmap to delete the specific element, but that would be ugly
21:59:07 <iqubic> alc: Right. But the things you shared 3 hours ago might not be visible to people just now joining.
21:59:25 <iqubic> Also, there's a reason this seems ugly. This isn't how one is supposed to use fmap.
22:00:07 <alc> but that's a common case, fmap work on a list that list's changing
22:00:16 <alc> maybe its name shouldn't call fmap
22:00:45 <alc> but there should be a basic function that work on a changing list, behavior like fmap, but list is changing
22:01:15 <iqubic> alc: You can use fmap to work on a list is changing.
22:01:20 <iqubic> But not in this way.
22:09:49 <Axman6> `that sounds like mutation to me, that's not how we do things
22:14:05 <iqubic> Yeah.
22:17:31 <alc> aha, I found a new way
22:18:26 <Axman6> alc: I have a solution to that kata if you'd like to see how you could solve it - happy to share it with you if you'd like (happy to wait until you've come up with your own solution though)
22:19:01 <alc> Axman6: yes
22:24:40 <Axman6> alc: my solution is here, but I would recommend you try as much as you can to come up with your solution before taking a look. https://gist.github.com/axman6/40204856a9c640c675a183fd4f1f4cfd
22:25:02 <alc> Axman6: ok
22:28:42 <Axman6> it's definitely not as efficient as it could be (it's at least O(n^2)), but you'd need to start running it with some _very_ big numbers before that would matter - there's definitely smart solutions that involve being more selective about the digits you choose
22:29:59 <iqubic> Does anyone know if it possible to export a module in a qualified way?
22:30:12 <Axman6> no
22:30:23 <Axman6> somewhat annoyingly, it's something I've wanted many times
22:30:43 <MarcelineVQ> What would that mean?
22:30:46 <iqubic> http://dpaste.com/27GQ50J
22:32:17 <iqubic> I want so that any module importing Parser can access the Megaparsec functions, but only if you prefix the names with P. So `P.string "Hello"`
22:33:26 <iqubic> Axman6: Is the answer still no?
22:33:59 <Axman6> yeah I've wanted something like module Foo (module Bar as B) for a while, but it does invisibly insert new prefixes into the name spaces of modules which import Foo, which could conflict
22:35:56 <iqubic> Is it possible to modify my cabal file so that every single file is compile with the OverloadedStrings pragma??
22:36:39 <MarcelineVQ> ye
22:36:44 <Axman6> yes, though it's generally not a good idea (though OverloadedStrings is one of those cases when I don't mind it) - default-extensions IIRC
22:53:05 <iqubic> Yeah. default-extensions is the right thing to add.
22:53:30 <iqubic> And thankfully cabal2nix just supports that out of the box.
22:55:54 * hackage password 0.1.0.1 - plain-text password and hashed password datatypes and functions  https://hackage.haskell.org/package/password-0.1.0.1 (cdepillabout)
22:56:54 * hackage password-instances 0.3.0.1 - typeclass instances for password package  https://hackage.haskell.org/package/password-instances-0.3.0.1 (cdepillabout)
23:02:34 <dminuoso> Yes.
23:03:06 <dminuoso> Also, answering yes/no questions 12 hours after they have been asked is a silly thing to do.
23:03:23 <dminuoso> I think weechat should give me some visual feedback if one is typing things into the line editor when its not scrolled down.
23:06:32 <jle`> dminuoso: sounds like something that can be done with a plugin
23:06:37 * jle` checks plugins ...
23:07:07 <jle`> ah wait, weechat calls those 'scripts'
23:08:58 <glguy> Glirc writes "scrolled" in red when that happens
23:09:20 <jle`> i couldn't find anything but i found a script that can display bitcoin exchange values
23:09:29 <jle`> 05a04l07s08o 03t09h10i11s 02o12n06e
23:09:42 <jle`> so i don't consider my time searching a complete loss
23:15:01 <dminuoso> So it appears like one needs two signal hooks. One for input_text_changed, and one in window_scroll
23:44:56 <subttle> Hi everyone, question for you all. So `a -> b` can be pronounced "a to b", what are good ways to pronounce `a ⊸ b`? Thanks :)
23:46:22 <subttle> I know it is a linear function but I'm just thinking of good ways to "say it" when reading code :)
23:51:45 <subttle> I know the character itself is called "lolipop", or can be called a "linear arrow", but I'm trying to think if there are better yet ways to read it aloud.
