00:00:27 <EvanR> lambda cube is already taken by at least two things
00:00:40 <koz_> EvanR: I can only think of the one by Barendregt.
00:00:44 <chambln> So is lazybox
00:00:49 <koz_> What's the other one?
00:00:58 <EvanR> the 3d graphics engine
00:01:06 <koz_> EvanR: Srsly?
00:01:47 <EvanR> what is lazybox?
00:02:43 <koz_> Then it should be 'strict-box'.
00:02:50 <koz_> (because we're efficient here)
00:02:52 <chambln> “lightweight web application framework that uses xml to define the controls” apparently
00:03:06 <koz_> > lightweight
00:03:08 <koz_> > XML
00:03:08 <lambdabot>  error: Variable not in scope: lightweight
00:03:10 <koz_> > wat
00:03:10 <lambdabot>  error: Data constructor not in scope: XML
00:03:11 <EvanR> that sounds underwhelming
00:03:12 <lambdabot>  error:
00:03:12 <lambdabot>      • Variable not in scope: wat
00:03:12 <lambdabot>      • Perhaps you meant one of these:
00:03:35 <chambln> lambdabot doesn't take well to XML
00:04:48 <jle`> alc: hm, try walking through it step by step with an example number. i think you might be missing an important step
00:05:03 <koz_> We'd also need an IRC client.
00:05:06 <jle`> alc: aslo, just checking to make sure that you know that this isn't necessary to solve the exercise you posted earlier
00:07:07 <EvanR> haskell already has an IRC client that sucks elss
00:07:09 <EvanR> less
00:07:23 <chambln> succs less*
00:07:31 <EvanR> probably that too
00:08:05 <koz_> EvanR: OK, that's easy then.
00:08:34 <koz_> So wait... the Haskell-based distro would be HOS, RIGHT?!?!
00:08:54 <EvanR> higher order succ?
00:09:22 <koz_> EvanR: Higher order {system, succ, success-at-any-cost}.
00:09:48 <koz_> Higher order succ implies we can quantify over succing.
00:10:34 <EvanR> an OS with a garbage collector that tends to freeze the world sounds like windows 95
00:10:43 <chambln> What is it that makes the compiler understand -3 as ‘0 - 3’ but not *2 as ‘1 * 2’?
00:10:44 <alc> jle`: the earlier exercise I have solved, with https://paste.ubuntu.com/p/MMP7cBs3Zy/    this f2 is the anwser
00:10:52 <chambln> > -3
00:10:54 <lambdabot>  -3
00:10:58 <chambln> > **
00:11:00 <lambdabot>  <hint>:1:1: error: parse error on input ‘**’
00:11:02 <chambln> > *2
00:11:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘*’
00:11:14 <EvanR> it's not 0 - 3 it's negate
00:11:21 <EvanR> negate 3
00:11:23 <chambln> Is it just built into the syntax?
00:11:29 <EvanR> yeah
00:12:17 <EvanR> unary minus special case
00:12:26 <chambln> OK
00:12:55 <EvanR> there's an extension to instead make it mean a negative literal
00:13:06 <EvanR> NegativeLiterals i think
00:29:06 <mniip> dolio, monadic strength of arrows gives us `first`. But what about `arr`?
00:29:23 <mniip> is arr even a part of that description
00:29:47 <mniip> and if not, how do we get compatibility between the cartesian structure and the profunctor
00:33:33 <jle`> `Arrow p` is more or less `Profunctor p` + `forall x. Applicative (p x)`
00:35:11 <koz_> jle`: I... never thought about it that way before.
00:35:16 <koz_> Although it makes a lot of sense.
00:36:33 <jle`> arr f = rmap f id
00:36:54 <jle`> or fmap f id
00:37:09 <EvanR> how do you get contravariant functionality from Arrow
00:37:52 <jle`> is this the part where i show off party tricks
00:38:11 <EvanR> my brain will probably explode so maybe no
00:38:39 <jle`> dimap f g x = rmap g id . x . rmap f id
00:39:11 <koz_> jle`: I think there's an lmap missing there?
00:39:11 <jle`> or (g <$> id) . x . (f <$> id)
00:39:24 <jle`> yeah i should be using fmap instead of rmap heh
00:39:27 <jle`> since the point is to define lmap
00:39:37 <jle`> dimap f g x = (g<$>id) . x . (f<$>id)
00:41:32 <jle`> huh i'm mixing the things i'm trying to prove up
00:41:37 <jle`> dimap f g x = arr f . x . arr g
00:41:40 <jle`> yeah that's it, heh.
00:44:23 <EvanR> that works when x is a function...
00:44:39 <EvanR> when p is (->)
00:44:46 <jle`> Control.Category..
00:44:52 <EvanR> oh
00:45:22 <jle`> @let import qualified Control.Category as C
00:45:24 <lambdabot>  Defined.
00:45:30 <jle`> :t \f g x -> arr f C.. x C.. arr g
00:45:32 <lambdabot> Arrow cat => (b1 -> c) -> (a -> b2) -> cat b2 b1 -> cat a c
00:45:51 <jle`> :t dimap
00:45:52 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
00:46:01 <jle`> hm ...
00:46:25 <jle`> :t [dimap, \f g x -> arr f C.. x C.. arr g]
00:46:27 <lambdabot> (Profunctor cat, Arrow cat) => [(b1 -> b2) -> (b1 -> b2) -> cat b2 b1 -> cat b1 b2]
00:46:58 <EvanR> the trick was Arrow pulls in Category
00:47:08 <jle`> ah yeah
00:47:12 <jle`> that's the one dentists won't tell you
00:54:54 <chambln> :t (,)
00:54:56 <lambdabot> a -> b -> (a, b)
00:56:34 <chambln> > "foo" , 5
00:56:37 <lambdabot>  <hint>:1:7: error: parse error on input ‘,’
00:56:48 <chambln> I don't understand why that doesn't parse
00:56:51 <dminuoso_> chambln:  Tuples like (,) is also special cased
00:56:56 <chambln> Ah, OK
00:56:59 <Guest_54> I am trying to run a code I found on Github using Haskell but can't seem to get the installation to work. 
00:57:02 <Guest_54> Welcome to Haskell!This will download and install the Glasgow Haskell Compiler (GHC) for the Haskell programming language, and the Cabal build tool.It will add the 'cabal', 'ghc', and 'ghcup' executables to bin directory located at:   /Users/MaxLobel/.ghcup/binand create the environment file /Users/MaxLobel/.ghcup/envwhich you should source in your
00:57:03 <Guest_54> ~/.bashrc or similar to get the requiredPATH components.To proceed with the ghcup installation press ENTER, to cancel press ctrl-c.Note that this script can be re-run at any given time.ENTERTo install and run GHC you need the following dependencies:  (Note: on OS X, in the course of running ghcup you will be given a dialog box to install the
00:57:03 <Guest_54> command line tools. Accept and the requirements will be installed for you. You will then need to run the command again.)You may want to install these now, then press ENTER to proceedor press ctrl-c to abort. Installation may take a while.ENTERInstalling GHC-8.6.5 for Darwin on architecture x86_64  % Total    % Received % Xferd  Average Speed   Time
00:57:04 <Guest_54> Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  151M  100  151M    0     0  3748k      0  0:00:41  0:00:41 --:--:-- 4942kchecking build system type... x86_64-apple-darwin18.7.0checking host system type... x86_64-apple-darwin18.7.0checking target system type... x86_64-apple-darwin18.7.0Build
00:57:04 <Guest_54> platform inferred as: x86_64-apple-darwinHost platform inferred as: x86_64-apple-darwinTarget platform inferred as: x86_64-apple-darwinGHC build  : x86_64-apple-darwinGHC host   : x86_64-apple-darwinGHC target : x86_64-apple-darwinLLVM target: x86_64-apple-darwinchecking for path to top of build tree...
00:57:05 <Guest_54> /var/folders/fw/6yhhdjtn10l0lwx1wsxm3wtc0000gn/T/ghcup.udXK2r6o/ghc-8.6.5checking for perl... /usr/bin/perlchecking for a BSD-compatible install... /usr/bin/install -cchecking for gfind... nochecking for find... /usr/bin/findchecking whether ln -s works... yeschecking for gsed... sedchecking XCode version... xcode-select: error: tool 'xcodebuild'
00:57:06 <dminuoso_> %:t ("foo", 5)
00:57:09 <dminuoso_> % :t ("foo", 5)
00:57:09 <yahb> dminuoso_: Num b => ([Char], b)
00:57:38 <chambln> What exactly is (,) then?
00:57:41 <dminuoso_> chambln: Behind the scenes this might have been defined as `data Two a b = Two a b`
00:57:54 <dminuoso_> chambln: You can treat it exactly as such with all the consequences
00:58:18 <dminuoso_> Amd (,,) equivalently as `data Three a b c = Three a b c`
00:58:22 <dminuoso_> And so forth
00:58:59 <dminuoso_> The only special thing about it is the mixfix syntax
00:59:51 <chambln> :i (,)
00:59:58 <chambln> > :i (,)
01:00:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:00:22 <dminuoso_> chambln: Use a percent % instead, yahb gives you ghci
01:00:24 <chambln> %:i (,)
01:00:28 <dminuoso_> And a space :)
01:00:31 <dminuoso_> % :i (,)
01:00:31 <yahb> dminuoso_: data (,) a b = (,) a b -- Defined in `GHC.Tuple'; instance Monoid a => Applicative ((,) a) -- Defined in `GHC.Base'; instance (Eq a, Eq b) => Eq (a, b) -- Defined in `GHC.Classes'; instance Functor ((,) a) -- Defined in `GHC.Base'; instance Monoid a => Monad ((,) a) -- Defined in `GHC.Base'; instance (Monoid a, Monoid b) => Monoid (a, b) -- Defined in `GHC.Base'; instance (Ord a, Ord b) => Ord (a, b) -
01:00:54 <dminuoso_> chambln: Note that this definition `data (,) a b = (,) a b` is a fake trick, it's not real.
01:01:55 <chambln> Interesting
01:02:27 <dminuoso_> chambln: If you wanted something similar looking you could do this trick:
01:03:15 <dminuoso_> % :set -XTypeOperators
01:03:15 <yahb> dminuoso_: 
01:03:19 <dminuoso_> data (:*:) a b = (:*:) a b
01:03:25 <dminuoso_> % data (:*:) a b = (:*:) a b
01:03:25 <yahb> dminuoso_: 
01:03:34 <dminuoso_> % let a = 1 :*: 'c'
01:03:34 <yahb> dminuoso_: 
01:04:15 <dminuoso_> We cannot create mixfix operators like (,) though.
01:04:55 <dminuoso_> I think Agda does though (?)
01:05:40 <chambln> % data (:*:) a b = (:*:) a b deriving (Show)
01:05:40 <yahb> chambln: 
01:05:49 <chambln> % let a = 1 :*: 'c'
01:05:50 <yahb> chambln: 
01:05:53 <chambln> % show a
01:05:53 <yahb> chambln: "(:*:) 1 'c'"
01:06:20 <chambln> % 1 :*: 'c' :*: "foo"
01:06:20 <yahb> chambln: (:*:) ((:*:) 1 'c') "foo"
01:06:27 <chambln> woah
01:06:27 <dminuoso_> chambln: You can define it in infix to get a more prettified default instance
01:06:38 <dminuoso_> % data a :*: b = a :*: b
01:06:38 <yahb> dminuoso_: 
01:06:44 <dminuoso_> % 1 :*: 'c' :*: "foo"
01:06:44 <yahb> dminuoso_: ; <interactive>:132:1: error:; * No instance for (Show ((Integer :*: Char) :*: [Char])) arising from a use of `print'; There are instances for similar types:; instance [safe] (Show a, Show b) => Show (a Ghci36.:*: b) -- Defined at <interactive>:127:38; instance forall k (f :: k -> Type) (g :: k -> Type) (p :: k). (Show (f p), Show (g p)) => Show ((GHC.Generics.:*:) f g p) -- D
01:06:48 <guest24601> Hi, I'm having trouble installing using ghcup
01:06:49 <dminuoso_> % data a :*: b = a :*: b deriving Show
01:06:50 <yahb> dminuoso_: 
01:06:51 <dminuoso_> % 1 :*: 'c' :*: "foo"
01:06:51 <yahb> dminuoso_: (1 :*: 'c') :*: "foo"
01:07:04 <dminuoso_> chambln: This is perfectly equivalent to (,) :)
01:07:09 <chambln> cool!
01:07:20 <guest24601> I used the installation method on the website and got the following errors. Can someone help?
01:07:21 <guest24601> https://gist.github.com/maxlobel1/9792148f65323b737ccaa0ff87fcdb7d
01:08:46 <dminuoso_> chambln: Did you know, we can even create lists with a simple data type too. :)
01:09:58 <chambln> dminuoso_: I can see how that's possible, but I'm guessing the syntax would be pretty ugly
01:10:08 <dminuoso_> chambln: Not not at all
01:10:48 <dminuoso_> % data List a = a :.: List a | Nil deriving Show; infixr 4 :.: 
01:10:48 <yahb> dminuoso_: 
01:10:56 <dminuoso_> % 'a' :.: 'b' :.: Nil
01:10:56 <yahb> dminuoso_: 'a' :.: ('b' :.: Nil)
01:11:10 <chambln> What is infixr?
01:11:11 <dminuoso_> chambln: This too is precisely how lists are defined too! But like with tuples the syntax is special cased. :)
01:11:23 <chambln> oh, neat
01:11:30 <dminuoso_> chambln: We can define the fixity of operators, to declare how strong their associate and whether they associate to the left or right
01:12:02 <dminuoso_> So we can control whether `a :.: b :.: c` associates as `(a :.: b) :.: c` or as `a :.: (b :.: c)`
01:12:09 <chambln> Right
01:12:25 <dminuoso_> chambln: Strictly speaking we can define it for data constructors too (because you can use them as infix)
01:12:32 <dminuoso_> But that's are rarely known feature :)
01:13:12 <dminuoso_> chambln: So lists can be thought of as being defined as `data [a] = a : [a] | []
01:13:19 <mniip> jle`, so it is a monad in Prof to begin with
01:13:20 <dminuoso_> (Except that definition is not legal in Haskell)
01:13:42 <chambln> I see what you mean
01:14:04 <mniip> you say id but really you mean eta : 1 => P
01:14:11 <guest24601> Bump! Anyone understand why I'm having trouble installing? https://gist.github.com/maxlobel1/9792148f65323b737ccaa0ff87fcdb7d
01:14:46 <dminuoso_> guest24601: Where is your XCode installed at?
01:16:17 <guest24601> Is that something I need to install first? I'm just trying to run a piece of code off of Github to look at a dataset I'm working with
01:16:23 <jle`> mniip: monad in prof might be too strong i think
01:16:35 <jle`> er. pun not intended?
01:16:45 <guest24601> dminuoso_ Is that something I need to install first? I'm just trying to run a piece of code off of Github to look at a dataset I'm working with
01:16:46 <dminuoso_> guest24601: Yes. You need to install the command line tools for XCode.
01:16:57 <dminuoso_> guest24601: It is a dependency for GHC on macOS
01:17:09 <mniip> a monad in Prof is exactly a profunctor with maps 1 => P and P*P => P
01:17:21 <mniip> which are roughly identity and composition
01:17:52 <guest24601> dminuoso_ Thank you! I'll install that. Can you see any other reason my installation is failing?
01:18:05 <mniip> unitality and associativity are exactly that of a category
01:18:08 <jle`> ah. you're saying Arrow is a Monad in Prof
01:18:20 <jle`> er, lower case m
01:18:35 <dminuoso_> guest24601: No, but the error message is quite clear. What I dont understand is why ghcup doesn't correctly detect it to be missing. This might be a bug since the latest macOS release perhaps.
01:18:35 <mniip> maybe?
01:18:51 <jle`> hm. that doesn't sound wrong to me
01:19:26 <dminuoso_> guest24601: It should be sufficient to type `xcode-select --install` in the console
01:19:34 <mniip> that makes it inherently Hask-valued though as our Prof is enriched over Hask
01:19:35 <jle`> mniip: i think you're right
01:19:45 <jle`> well
01:19:56 <jle`> i can test it out i guess
01:20:10 <guest24601> dminuoso_ awesome thank you!
01:20:24 <mniip> anyway I think this description gives us id and . and arr
01:20:30 <mniip> if what you say about arr <-> dimap is true
01:20:48 <jle`> but i don't see any reason why it wouldn't be true. the only thing iffy is whether or not Arrow laws are stronger than monad in prof maybe.
01:21:01 <mniip> monad in prof is just the category laws
01:21:30 <mniip> I'm ignoring naturality squares cause that's just parametricity
01:21:37 <jle`> Arrow laws are wonky iirc
01:21:44 <mniip> arrow laws are all about first
01:21:49 <mniip> whihc we have not defined yet
01:22:07 <mniip> I think that's where strength comes in?
01:22:18 <jle`> ah, okay. so Category is a monad in Prof
01:22:28 <mniip> also wrong
01:22:43 <mniip> (Profunctor p, Category p) is monad in Prof
01:25:53 <mniip> actually hold on
01:26:01 <Taneb> (what is the Prof category?)
01:26:30 <Taneb> (morphisms are natural transformations p ~> q?)
01:26:50 <mniip> it's the bicategory where objects are categories and morphisms from C to D are profunctors C^op x D -> Set
01:27:27 <mniip> composition is given by an end: PxQ(A, C) = int_(X in B) P(A, B) x Q(B, C)
01:27:43 <mniip> er
01:27:53 <mniip> composition is given by an end: PxQ(A, C) = int_B P(A, B) x Q(B, C)
01:28:20 <mniip> A,B,C are objects of some categories here
01:28:39 <Taneb> Ah, not what I thought
01:28:56 <Taneb> I think I'm with you
01:29:02 <mniip> the 2-morphisms are natural transformations of profunctors
01:29:51 <mniip> a monad on this would be an endomorphism P : C -/-> C
01:30:03 <mniip> with natural transformations 1 => P and PxP => P
01:30:41 <mniip> (and the same commutative diagrams)
01:31:15 <Taneb> Isn't that just a monoid in Prof?
01:32:01 <mniip> P is not an object of Prof
01:32:06 <mniip> it's a 1-morphism
01:32:12 <Taneb> Oh right, yes
01:32:27 <Taneb> (my excuse is I just woke up)
01:32:35 <mniip> so then a Category is such a monad when C is discrete?
01:32:37 <mniip> I guess?
01:34:03 <mniip> by the virtue of being a profunctor you have a map C(X, Y) x C(Z, W) -> Set(P(Y,Z), P(X, W))
01:34:13 <mniip> that's dimap
01:34:16 <dminuoso_> Is there a cleaner way to write: appEndo . foldMap Endo . catMaybes <$> traverse (optional . warnFlagP) wFlags
01:34:28 <mniip> arr means C=Hask
01:35:25 <mniip> consider also
01:35:28 <mniip> :k Category
01:35:30 <lambdabot> (k -> k -> *) -> Constraint
01:35:33 <mniip> :k Arrow
01:35:36 <lambdabot> (* -> * -> *) -> Constraint
01:35:42 <mniip> k vs *
01:36:08 <merijn> dminuoso_: move the Endo to the right and replace "foldMap Endo . catMaybes" with "mconcat"?
01:40:07 <dminuoso_> merijn: Mmm the types dont line up
01:40:54 <merijn> dminuoso_: Why not? what's warnFlagP? A list of functions, yes?
01:45:11 <dminuoso_> merijn: Ah. https://gist.github.com/dminuoso/2aea5e290d49448d22842f217171fb0b
01:45:38 <dminuoso_> Gah those types are anything but nice.
01:46:05 <chambln> What does * mean in a type sig?
01:47:13 <jle`> dminuoso_: appEndo . foldMap Endo is just like foldr (.) id, right?
01:47:48 <jle`> or you can do appEndo . (foldMap . foldMap) Endo
01:47:56 <jle`> appEndo . (foldMap . foldMap) Endo <$> traverse ...
01:48:55 <jle`> or mapMaybe (.) <$> ...
01:48:58 <jle`> :t mapMaybe (.)
01:49:00 <lambdabot> error:
01:49:00 <lambdabot>     • Couldn't match type ‘(a0 -> b) -> a0 -> c’ with ‘Maybe b1’
01:49:00 <lambdabot>       Expected type: (b -> c) -> Maybe b1
01:49:11 <jle`> er i mean maybe id (.)
01:49:32 <jle`> :t foldr (maybe id (.)) id
01:49:33 <lambdabot> Foldable t => t (Maybe (b -> b)) -> b -> b
01:50:17 <jle`> heh, we're dealing with two layers of Foldable so maybe appEndo . (foldMap . foldMap) Endo might be the neatest way to do it
01:50:32 <jle`> but readability maybe i'd do foldr (maybe id (.)) id <$> traverse (optional . warnFlagP) wFlags
01:52:19 <iqubic> What is appEndo?
01:52:23 <iqubic> :t appEndo
01:52:25 <lambdabot> Endo a -> a -> a
01:52:56 <iqubic> :t Endo
01:52:58 <lambdabot> (a -> a) -> Endo a
01:53:10 <merijn> iqubic: The other function Monoid
01:53:19 <iqubic> Oh. Is this a newtype wrapper around an Endomorphism?
01:53:27 <merijn> Yes
01:54:02 <iqubic> Please tell me that there is a monoid instance for this.
01:54:06 <merijn> As opposed to the default monoid instance for functions, which is "instance Monoid m => Monoid (a -> r)"
01:54:16 <iqubic> Right.
01:54:16 <merijn> iqubic: The Monoid instance is the only reason Endo exists
01:54:22 <merijn> eh
01:54:29 <merijn> a -> m in that line, of course >.>
01:54:40 <iqubic> Ah. And let me guess, it behaves somewhat like a monad?
01:54:55 <iqubic> A monad is an endofunctor in the category of endofunctor.
01:55:10 <merijn> I honestly don't even understand what that question means :)
01:55:36 <merijn> Endo is just for the Monoid of "mappend = (.)" and "mempty = id"
01:55:39 <phadej> that "monoid" uses Compose, not .
01:55:49 <phadej> ^^^ that = Monad
01:56:32 <iqubic> How? I've never understood that.
01:56:54 <phadej> it's not important, it will click eventually (= I don't know how to explain it well)
01:58:21 <iqubic> Also, A monad is a monoid in the category of endofunctors.
01:58:49 <phadej> you can massage types (<>) :: Monoid m => Pair m m -> m; and join :: Monad m => Compose m m ~> m; where f ~> g = forall x . f x -> g x
01:59:57 <phadej> (and mempty :: Monoid m => m; pure :: Identity ~> m)
02:00:19 <phadej> adn there's really not much more behind that phrase
02:03:14 <koz_> It's monoids, all the way down.
02:03:26 <koz_> Everything is just fancy State or fancy monoid. :P
02:04:10 * [exa] reminds that State is also basically a fancy monoid
02:04:19 <iqubic> It is? How so?
02:06:10 <alc> where is <> defined in 7.10.3? in 8.6 I just import Data.List and <> works fine
02:06:51 <alc> x - (div x 10) * 10 : [] <> f3 (div x 10)  this code work on 8.6, but not on 7.10.3
02:06:59 <alc> it said <> is not defined
02:07:03 <phadej> in 8.6 you don't need to important anything, (<>) is in Prelude there
02:07:18 <alc> phadej: and in 7.10.3?
02:07:22 <alc> <> is in?
02:08:01 <phadej> Semigroup variant is in Data.Semigroup (which with 7.10.3 is in a separate package, semigroups)
02:08:51 <[exa]> iqubic: if you squish the 'a' a bit in 's -> (a,s)', you have a perfect function-gluing monoid
02:08:58 <alc> phadej: yeah, it is
02:09:16 <phadej> :t (<>)
02:09:18 <lambdabot> Semigroup a => a -> a -> a
02:09:19 <alc> phadej: I wonder we have <>, why need ++ ?
02:09:42 <phadej> alc: the same reasons (or arguments?) about why we have map and fmap
02:09:53 <Taneb> alc: history, type inference, explaining to beginners
02:09:59 <Taneb> Take your pick
02:10:50 <Taneb> (with OverloadedStrings, for example, "hello" <> "world" has an ambiguous type but "hello" ++ "world" does not)
02:11:22 <phadej> .. though with Text you are forced to use <> anyway, (and then you use OverloadedStrings), so you resolve that ambiguity somehow otherwise :)
02:11:49 <Taneb> phadej: you could use T.append
02:12:39 <alc> yeah, I do use <> on Text with OverloadStrings
02:12:39 <phadej> it's ugly as infix and (probably & hopefully) don't have fixity defined
02:12:54 * hackage hasql-th 0.4.0.1 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.1 (NikitaVolkov)
02:13:09 <alc> now I use <> to instead of ++ everywhere, I don't know if it's good
02:13:20 <phadej> it's not bad
02:13:34 <Taneb> So do I, in fact
02:13:37 <iqubic> I use ++ everywhere, and return everywhere too.
02:13:56 <[exa]> if it's just lists, ++ clearly says there's no fishy extra monoid processing
02:14:01 <alc> like you know, fmap can instead of map and (.), so why not to use <$> to instead of map and (.) everywhere?
02:14:24 <iqubic> Well, I use return all the time in my Monadic code.
02:15:14 <iqubic> pure and return seems like overkill.
02:15:15 <phadej> my impression that most people consider use of Functor ((->) e) instance code golfing
02:15:26 <phadej> at least I do
02:15:42 <Taneb> I think most of the time, Functor ((->) e) is the wrong abstraction
02:15:49 <iqubic> Yes
02:15:58 <Taneb> Category (->) is where it's at ;)
02:16:29 <Taneb> (most of the time, there's no point generalizing ., though)
02:16:33 <phadej> but then `map` vs. `fmap` is not bad; especially if your code uses some other containers too
02:16:44 <phadej> no point... :)
02:17:01 <iqubic> There's no point eta reducing things.
02:28:58 <merijn> iqubic: pure and return is hysterical raisins
02:31:18 <alc> merijn: pure return and unit?
02:32:26 <Taneb> alc: I've not seen "unit" used
02:34:54 <dminuoso_> iqubic: https://gist.github.com/dminuoso/d5ab4ba5d8a5142dde9f4d4c736e3ecb
02:35:46 <dminuoso_> iqubic: This is a haskellized version of the commuting diagrams for the monad laws. The monoid is not a regular monoid in the `class Monoid` sense
02:37:24 <dminuoso_> Just like `mappend :: ... => (m, m) -> m` you have `join :: ... => (m :.: m) ~> m`
02:40:18 <gspia> @lyxia hi! are you Lysxia at github? If yes, I'd have some q's about rebase
02:40:18 <lambdabot> Unknown command, try @list
02:40:29 <gspia> lyxia hi! are you Lysxia at github? If yes, I'd have some q's about rebase
02:42:17 <dminuoso_> gspia: He is. You can use @tell to have lambdabot send them a message when they come back if you'd like.
02:42:54 * hackage ghc-tcplugins-extra 0.3.1 - Utilities for writing GHC type-checker plugins  https://hackage.haskell.org/package/ghc-tcplugins-extra-0.3.1 (ChristiaanBaaij)
02:44:46 <gspia> @tell lyxia: ok, will try to send a msg (this is not directly about a fcf-lib, but just to get the things updated so that I can do all necessary actions for the pr)
02:44:46 <lambdabot> Consider it noted.
02:45:34 <gspia> dminuoso_: thanks
03:01:54 * hackage template-haskell-compat-v0208 0.1.2.1 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.2.1 (NikitaVolkov)
03:21:54 * hackage hasql-th 0.4.0.2 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.2 (NikitaVolkov)
03:33:59 <dminuoso_> jle`: parseWarnFlags = appEndo . foldMap Endo <$> wither (optional . warnFlagP) wFlags
03:34:08 <dminuoso_> I think that has the expressivity I was looking for.
03:35:14 <dminuoso_> But the dependency on witherable is hard to justify just for that single line.
03:35:26 <dminuoso_> I think Ill just re-implement wither on the spot, specialized to []
03:39:54 * hackage tzdata 0.1.20190911.0 - Time zone database (as files and as a module)  https://hackage.haskell.org/package/tzdata-0.1.20190911.0 (MihalyBarasz)
03:40:18 <day> when reading stdin the keypress (in case of a printable character) will show up in the terminal. is that surpressable?
03:40:34 <dminuoso_> day: Sure
03:41:00 <dminuoso_> day: What's the grand goal here?
03:41:03 <day> any hint what to look at?
03:41:47 <dminuoso_> day: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetEcho https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hGetEcho
03:42:03 <dminuoso_> day: These are immediate primitives, useful mostly for when you want to prompt for a password.
03:42:08 <day> number input for a spaced repetition program. due to the input being lazy the answer prints right after the question
03:43:24 <day> so my idea was, to be more flexible, do the output of the inputed number via the program that way i can also prevent this question+answer being printed at the smae time behavior
03:45:06 <dminuoso_> day: Well you'd still have enter producing newlines
03:45:15 <day> dminuoso_: perfect, that was much easier than expected :D
03:45:31 <day> i dont need to press enter due to 'stdin NoBuffering'
03:45:34 <dminuoso_> Ah
03:49:16 <p0a> so I ran `stack install stylish-haskell' and my computer is a goner
03:49:28 <p0a> had to switch to a tty 
03:51:37 <p0a> Whoa I ran `stack install stylish-haskell' from the emacs term and my computer crashed
03:51:44 <p0a> (almost).
03:58:16 <statusfailed> Is there a guide on profiling with cabal? The wiki seems out of date (doesn't mention cabal at all)
04:00:33 <dminuoso_> statusfailed: What exactly do you want to do?
04:01:28 <statusfailed> dminuoso_: I want to find out where my program is taking the most time so I can try to speed it up
04:01:38 <dminuoso_> statusfailed: https://www.haskell.org/cabal/users-guide/nix-local-build.html#how-can-i-profile-my-library-application
04:01:44 <merijn> statusfailed: You simply compile with "cabal build --enable-profiling"
04:02:04 <dminuoso_> statusfailed: Remember you then need to specify the appropriate RTS flags to actually collect the appropriate information
04:04:11 <statusfailed> OK, I have it producing a .prof file- thanks!
04:04:21 <statusfailed> I found this as well: https://nikita-volkov.github.io/profiling-cabal-projects/ 
04:05:19 <statusfailed> I'm not sure how to interpret the data on allocations and memory though
04:05:58 <statusfailed> is there some documentation on how to read the .prof file? :)
04:06:09 <dminuoso_> statusfailed: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
04:06:19 <dminuoso_> statusfailed: This is probably a good starting point
04:07:51 <statusfailed> oh, perfect- thanks!
04:09:49 <merijn> GHC user's guide remains the most underutilised Haskell resource :p
04:12:25 <statusfailed> merijn: no matter how many times I get told, I never think to read the manual first
04:12:28 <statusfailed> character flaw :D
04:28:25 <LarryTheCow> Quick question: Are FirePaths semigroups?
04:29:26 <LarryTheCow> FilePath*
04:31:23 <LarryTheCow> I was thinking that it could be an instance if <> = </>
04:31:51 <p0a> LarryTheCow: string concatenation is 
04:32:19 <solonarv> it's associative, so sure
04:32:25 <solonarv> that's all you need for a semigroup
04:32:26 <p0a> LarryTheCow: the problem is that /../ is inverting everything
04:32:59 <solonarv> the special meaning of .. doesn't matter at all
04:33:10 <solonarv> to be a semigroup, all that's needed is an associative operation
04:33:17 <p0a> stop repeating yourself
04:33:36 <mikeplus64> is there a <%~ somewhere? as in <~ but :: MonadState s m => ASetter s s a b -> (a -> m b) -> m ()
04:33:55 <solonarv> the MonadState operators end in = instead of =
04:34:12 <solonarv> er, = instead of ~
04:34:22 <mikeplus64> <~ does not end with a = :)
04:34:35 <mikeplus64> but i guess that is the exception
04:34:37 <solonarv> this one should just be %%=, I think
04:35:06 <solonarv> :t (%%=)
04:35:07 <lambdabot> MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
04:35:08 <p0a> In that sense filepaths are free monoids, not semigroups, as there is no identity
04:35:21 <p0a> unless of course the identity is the path "", but what path is that?
04:35:41 <solonarv> p0a: I think you're mixing up "semigroup" and "monoid"
04:35:54 <solonarv> a monoid has an identity, a semigroup may not
04:36:07 <p0a> solonarv: thank you, I did mix them up. So free semigroup is correct
04:36:18 <solonarv> I guess you could make a case for "." as the identity
04:36:29 <p0a> solonarv: but by your argument "." has no meaning
04:36:38 <p0a> solonarv: therefore / and /./ are different
04:37:06 <solonarv> no, my argument is that (considering only directory paths) "." is an identity of </>
04:37:18 <solonarv> so those do form a monoid, and not just a semigroup
04:37:23 <solonarv> (up to equivalence anyway)
04:37:35 <p0a> So you give . meaning but not .., which is bending over backwards to prove me wrong lol
04:37:41 <p0a> but I agree
04:40:06 <solonarv> hmm, this is not qhat I expected %%= do to...
04:42:54 <mikeplus64> ah i think unfortunately %%= or %<~ or <%~ or whatever =)) is impossible to implement efficiently with just a MonadState constraint
04:43:08 <haskeldjiq> guys, does someone know from the top of their head how can I make getCurrentTime consistent, for some reason it's returning the local time in some parts of the code and UTC+0 in others
04:43:10 <dminuoso_> solonarv: They are not associative because you dont have full closure.
04:43:24 <dminuoso_> At least in the sense of filepaths
04:43:31 <solonarv> what do you mean?
04:43:44 <dminuoso_> "/" <> ".."
04:43:50 <solonarv> ah, yes
04:43:52 <dminuoso_> Or maximal path lengths, maximal file lengths
04:44:02 <dminuoso_> Oh
04:44:04 <dminuoso_> oops!
04:44:11 <dminuoso_> I meant to write "they are not monoids/semigroups"
04:44:13 <dminuoso_> :)
04:44:36 <dminuoso_> Although "/.." might actually be valid
04:45:19 <solonarv> it appears to just refer to '/' again
04:45:24 * hackage algebraic-classes 0.9.3 - Conversions between algebraic classes and F-algebras.  https://hackage.haskell.org/package/algebraic-classes-0.9.3 (SjoerdVisscher)
04:57:05 <haskeldjiq> pf, does anyone know for real
04:57:15 <haskeldjiq> why would getCurrentTime not be consistent
04:57:33 <haskeldjiq> it gives me UTC+0 time when called from one package and the local time when called from another
04:58:42 <p0a> haskeldjiq: why not get unix time and convert to whatever you need?
04:59:22 <haskeldjiq> p0a: because the code is riddled with getCurrentTime and I'm hoping it's something simple that I'm missing
04:59:50 <haskeldjiq> p0a: at least it sounds like something on my end
05:00:31 <p0a> ?src getCurrentTime
05:00:32 <lambdabot> Source not found.
05:00:43 <haskeldjiq> it uses getSystemTime
05:00:46 <haskeldjiq> which I can't find the source for
05:01:09 <p0a> getSystemTime gets the unix time I believe
05:01:38 <p0a> haskeldjiq: https://hackage.haskell.org/package/time-1.8.0.2/docs/src/Data.Time.Clock.Internal.SystemTime.html#getSystemTime
05:01:51 <dminuoso_> 13:57:10    haskeldjiq | it gives me UTC+0 time when called from one package and the local time when called from another
05:01:55 <dminuoso_> haskeldjiq: Can you elaborate what you mean by that?
05:02:43 <haskeldjiq> dminuoso_: one second
05:06:25 <p0a> the examples here may be useful, https://caiorss.github.io/Functional-Programming/haskell/Libraries.html#sec-1-2-3
05:06:29 <haskeldjiq> forget it guys, I'm retarded
05:06:35 <haskeldjiq> it's postgres that's adjusting the time to local
05:06:42 <haskeldjiq> getCurrentTime behaves just as it should
05:08:25 <haskeldjiq> use timestamps without timezone :)
05:09:02 <dminuoso_> haskeldjiq: Just dont localize until you present in a user interface.
05:09:15 <dminuoso_> haskeldjiq: Keep everything as UTC until you localize at the frontend. :)
05:09:38 <dminuoso_> That gets rid of most of the pain involving timezones
05:09:56 <maerwald> https://i.imgur.com/g6rTcZK.png
05:10:00 <maerwald> wrt time :)
05:10:01 <haskeldjiq> yeah, gotta be careful not to overlook
05:28:45 <dminuoso_> Mmm, `witherAlt f = wither (optional . f)` should be a thing. :)
05:45:24 * hackage llvm-hs-pretty 0.9.0.0 - A pretty printer for LLVM IR.  https://hackage.haskell.org/package/llvm-hs-pretty-0.9.0.0 (sdiehl)
06:11:53 <fog> this paper laments the reliance of cloud haskell on template haskell; https://www.scs.stanford.edu/14sp-cs240h/projects/burke.pdf
06:12:24 <fog> a google search for "cloud haskell without template haskell" shows up nothing...
06:12:52 <fog> but this was 7 years ago, do we have anything towards that now?
06:26:48 <fog> i dont get why a function needing to be serializable results in TH use 
06:27:26 <fog> or why they need to be serializable in the first place
06:28:10 <fog> the hotswapping stuff seemed to have everything compiled down to .o files which could be use to swap whole modules during runtime
06:28:59 <fog> if this can swap functions definitions, i cant see why TH is needed simply to call different functions on different remote servers
06:30:10 <fog> i guess what its doing is wrapping a function from scope into a server process so it can be called remotely 
06:30:24 * hackage algebraic-classes 0.9.4 - Conversions between algebraic classes and F-algebras.  https://hackage.haskell.org/package/algebraic-classes-0.9.4 (SjoerdVisscher)
06:31:12 <fog> but again, this seems like the same backpacking/hotswapping thing, where this "main server function" just needs to be swapped via a live alteration to the code
06:31:30 <fog> i guess there might be some problem with then needing different types...
06:32:30 <fog> but if you just had a binary instance for the input args, then this could have bytestrings to pass them via a server
06:34:40 <fog> then you could initialize all the servers to run with some undefined function, distributing the code compiled down to .o files
06:35:08 <fog> and on running the process, designate using hotswapping which functions were to be run at each node
06:36:10 <fog> so to have dynamically reallocatable resources, as opposed to having to push a whole exe wrapping a server function each time a remote machine was used for a different function
06:37:01 <fog> also having the advantage of being able to push updates to function implementations while continuously running
06:37:07 <fog> another kickstarter perhaps?
07:29:39 <basic> hello, can somebody explain to me, why pattern matching works as sort of a filter in catMaybes
07:30:00 <merijn> basic: You mean within a list comprehension?
07:30:03 <basic> yes
07:30:15 <basic> is it just convention?
07:30:32 <dminuoso_> basic: list-comprehensions are basically the list monad with some monadplus sprinkled ontop
07:30:42 <dminuoso_> basic: But yes, its just convention I suppose.
07:30:49 <basic> hm, that's odd
07:30:57 <merijn> basic: Because list comprehensions are defined to map failing matches that way
07:31:09 <basic> hm, okeh
07:31:15 <dminuoso_> basic: Just like `do { Foo r <- bar }` will invoke MonadFail.
07:31:57 <basic> regarding that
07:32:28 <basic> nvm, im an idiot
07:36:44 <merijn> basic: Basically, list comprehensions behave like concatMap with failing patterns/guards producing []
07:38:22 <p0a> Hello what does development using stack and emacs' haskell-mode look like?
07:38:41 <p0a> Does everything happen within emacs or is there a separate terminal and emacs is used to write code?
07:39:41 <ocharles> p0a: I don't use stack, but I use emacs with haskell-mode and projectile. I usually code in Emacs, and then use projectile-compile-command to run `cabal build`
07:39:49 <ocharles> That way I can use emacs built in error-mode to jump to errors
07:40:03 <dminuoso_> % do { Just x <- [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6]; guard (odd x); pure x } -- basic 
07:40:03 <dminuoso_> % [x | Just x <- [Just 1, Just 2, Just 3, Nothing, Just 5, Just 6], odd x]
07:40:03 <yahb> dminuoso_: [1,3,5]
07:40:03 <yahb> dminuoso_: [1,3,5]
07:40:16 <p0a> ocharles: I will try to use stack for now, but thank you for the perspective 
07:40:27 <ocharles> The same idea will work fine with stack, of course
07:40:39 <dminuoso_> basic: These two are the same thing. :)
07:47:18 <dsal> p0a: I just use M-x compile to run "stack test" (possibly with other arguments)
07:47:45 <dsal> Also Dante which occasionally gives me useful flymake mode.
07:47:58 <p0a> dsal: thank you I might bind it to something because I dislike typing M-x comple
07:49:05 <dsal> *shrug* you only have to type it once.
07:49:36 <p0a> well if you modify the code you type it again, right?
07:49:50 <basic> dminuoso_: uh? i thought that would fail, sommeone said that
07:50:02 <basic> 16:30 < dminuoso_> basic: Just like `do { Foo r <- bar }` will invoke MonadFail.
07:50:05 <dsal> No, then you just hit g in the compile window
07:50:27 <p0a> dsal: got it, I don't keep a compile window around, my display screen is small and I dislike pressing C-x b all the time
07:52:16 <dsal> You only have to do that when you're ready to thinker like recompile. Presumably after you fixed all the issues the compile window pointed you to.
07:52:40 <dsal> Since it will step you through the errors line by line
07:53:27 <dsal> Then I'd expect you to want to run the same command. I often limit my tests to just the ones I'm working on when I'm doing a large project. Not that up is hard to press.
07:54:58 <p0a> okay thanks dsal, I have not ever tried M-x compile before
07:55:05 <p0a> except in C where it invokes make
07:55:20 <dsal> It's the general way to build anything in emacs for any language.
07:56:06 <dsal> make is the default, but I have it see if I'm in a stack project and run stack test instead (by default)
07:56:30 <p0a> nice, thanks
08:02:11 <dminuoso_> Is there some trick to write this shorter without MaybeT? https://gist.github.com/dminuoso/8c1590a7d18a1f9cd0843cb2f93109a0
08:02:56 <basic> if i have [a,b,c] how would i check if they're equal, i mean for 3 it's simply done wirth patternmatching, but something like fold?
08:03:24 <p0a> basic: if what is equal?
08:03:36 <basic> a,b,c
08:03:41 <dminuoso_> basic: `length (nub xs) == 1`
08:03:57 <basic> a,b,c baby you and me, babe!
08:04:12 * basic goolges nub
08:04:35 <basic> hm, yah, and if i wanted to do it myself?
08:04:59 <dminuoso_> What do you mean? Isn't that doing it yourself?
08:05:10 <basic> hm, i don't know i hoped there was a reduce style way
08:05:24 <dminuoso_> Well you could, but it would really be cumbersome and probably not idiomatic.
08:06:38 <dminuoso_> This has poor asymptotics though, so keep that in mind if you have large lists
08:08:17 <dminuoso_> (You could address the asymptotics by using https://hackage.haskell.org/package/discrimination-0.4/docs/Data-Discrimination.html#v:nub )
08:09:54 <dsal> > let alleq (x:xs) = all (== x) xs in alleq [1, 1, 2] -- basic 
08:09:55 <dmwit> :t \case _ -> 3
08:09:57 <lambdabot>  False
08:09:57 <lambdabot> Num p1 => p2 -> p1
08:09:59 <dsal> Partial version
08:10:11 <basic> ahh way too much info
08:10:19 <dminuoso_> Ah, perhaps dsal's solution is much smarter indeed heh
08:10:26 <dminuoso_> Gets away with simple O(n) :)
08:10:36 <p0a> basic: and $ map (== head xs) $ tail xs
08:10:38 <basic> yeah i get dsals
08:11:13 <dmwit> :t let f [] = True; f (x:y:rest) = x == y && f (y:rest) in f -- even more basic
08:11:15 <lambdabot> Eq a => [a] -> Bool
08:11:38 <dmwit> whoops
08:11:40 <dmwit> But buggy. ^_^
08:11:50 <dmwit> :t let f (x:y:rest) = x == y && f (y:rest); f _ = True in f -- even more basic
08:11:51 <lambdabot> Eq a => [a] -> Bool
08:12:44 <Orbstheorem> :t nub
08:12:45 <lambdabot> Eq a => [a] -> [a]
08:13:03 <ChaiTRex> (== 1) . length . group
08:13:06 <Orbstheorem> :doc nub
08:13:23 <geekosaur> lambdabot is not ghci
08:13:24 <Orbstheorem> :b nub
08:13:30 <Orbstheorem> x) 
08:13:41 * Orbstheorem will install ghci in his phone
08:23:24 * hackage base64-lens 0.1.0.1 - Optics for the Base64 library  https://hackage.haskell.org/package/base64-lens-0.1.0.1 (topos)
08:27:36 <ChaiTRex> null . drop 1 . group
08:36:17 <maerwald> why is hie still using stack although I told it to use cabal
08:37:03 <maerwald> and then it fails with https://git.io/JejVJ
08:37:24 <maerwald> seems hie is still unusable
08:37:35 <fendor> maerwald, more info please
08:37:43 <maerwald> fendor: of?
08:37:57 <fendor> what is the project, hie installation
08:38:04 <fendor> how did you tell it to use cabal
08:38:18 <maerwald> https://github.com/haskell/haskell-ide-engine#install-via-cabal
08:38:32 <fendor> oh you mean that
08:39:26 <fendor> currently, we still use `stack path --local-bin` to find a installation directory
08:39:53 <fendor> I can guide you through the manual installation process, if you prefer
08:45:32 <maerwald> currently, we still use `stack path --local-bin` to find a installation directory -- why?
08:46:53 <fendor> because cabal doesnt give it to you. Otherwise the installation with `cabal install` fails. Moreover, we need to know the installation directory to create the appropriate symlinks
08:48:41 <fendor> also, we cant garantuee the same behaviour as with `stack install.hs` that is why we are using it
08:49:38 <maerwald> I cannot follow. stack path --local-bin looks totally arbitrary
08:50:03 <maerwald> you could just hardcode that path, because it has nothing to do with cabals internal installdir
08:51:15 <fendor> Yeah, we could, if someone provides a platform independent path that we can use.
08:52:26 <maerwald> https://hackage.haskell.org/package/Cabal-3.0.0.0/docs/Distribution-Simple-InstallDirs.html#v:defaultInstallDirs provides the correct install dir
08:53:10 <fendor> https://hackage.haskell.org/package/cabal-install-parsers-0.2 also provides abstraction over it
08:55:38 <maerwald> doesn't look like that resolves variables
08:56:51 <fendor> are variables now allowed in ~/.cabal/config?
08:57:43 <fendor> I thought there was an discussion about which to allow
08:58:41 <maerwald> I don't know, but I think it's not a good idea to rely on anything except the Cabal library for that
08:58:46 <maerwald> unfortunately its API is odd
08:58:58 <maerwald> and breaks regularly
08:59:20 <maerwald> e.g.: (fromPathTemplate . bindir) <$> defaultInstallDirs GHC True True -- does not return the correct result
08:59:58 <fendor> this library is maintained by cabal devs, so I feel confident in using it
09:00:07 <maerwald> ah
09:00:48 <basic> if i have a function that maybe returns smth
09:01:11 <basic> and i want to pass the value inside it to another function my only hope is pattern matching and or (>>=) right?
09:01:24 <basic> or do i lift my function?
09:01:26 <fendor> and it was suggested to solve the ongoing problem of selecting the right ghc version when using cabal
09:02:52 <basic> oh wow, this is cool
09:03:08 <maerwald> fendor: (\x -> substPathTemplate (installDirsTemplateEnv x) $ bindir x)  <$> defaultInstallDirs GHC True True
09:03:11 <maerwald> this works correctly
09:03:24 * hackage biohazard 2.1 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-2.1 (ustenzel)
09:03:49 <fendor> maerwald, does it resolve variables?
09:03:54 <maerwald> yes
09:04:56 <maerwald> but this is the install-dirs section
09:05:23 <maerwald> I'm not 100% sure what's the difference to 'installdirs'
09:05:37 <maerwald> err, 'installdir'
09:05:49 <jojoz[m]> basic: fmap
09:05:56 <fendor> cabal-install-dirs does not resolve variables
09:08:19 <maerwald> https://git.io/JejVb this has variables
09:11:55 <fendor> maerwald, but that is something different right? Can you variables to `installdir` or something like that?
09:14:09 <fendor> https://github.com/haskell/cabal/issues/1857
09:24:38 <maerwald> fendor: won't suffice, cabal-install-parsers does not resolve $prefix
09:26:48 <maerwald> ah no, I'm actually wrong, it does
09:26:57 <maerwald> variables are tricky in cabal config
09:27:04 <fendor> maerwald, from that issue I read that this path interpolation is not allowed for all fields
09:27:13 <maerwald> for install-dirs it is
09:27:19 <maerwald> but there are no defaults for any variable
09:28:32 <maerwald> anyway, seems to work
09:29:17 <fendor> ah. There is `installDirs` section, `installdir`, and `symlink-bindir`
09:30:09 <basic> jojoz[m]: but would be quite cumbersome to spray fmaps all over the place
09:33:53 <maerwald> fendor: stack is also used to install cabal-install
09:35:26 <fendor> maerwald, yeah, that was intended as a well meaning help for beginners.
09:35:40 <fendor> I suppose, it is not really needed anymore
09:35:44 <maerwald> well, how would I run the script without cabal
09:35:59 <fendor> with stack
09:36:08 <maerwald> -.-
09:36:25 <fendor> at least, if you have cabal on the path, it does not try to install cabal
09:36:31 <fendor> but maybe we can remove that, too
09:37:07 <maerwald> toolchain installation is not for a package to do
09:37:59 <fendor> while I agree, you also have to help newcomers and make it as easy as possible
09:38:38 <maerwald> well, and now I have to rewrite the build system to make it work...
09:39:01 <fendor> I did not argue that we are doing correct.
09:39:17 <fendor> *I dont mean that it is the best way what we are currently doing
09:39:55 <maerwald> execCabalWithOriginalPath -- what's the reasoning behind this
09:41:58 <fendor> naming seems weird. But the initial intention is that when you are executing the script with stack, then it modifies the path and puts an ghc version on it
09:42:07 <geekosaur> can't run it via stack exec, because both set GHC_PACKAGE_PATH and conflict?
09:42:28 <geekosaur> or is that $PATH?
09:43:05 <geekosaur> in any case, need to avoid changes stack makes to the environment so can't use stack to find and run cabal
09:43:17 <fendor> but you probably only want to install hie for ghc versions that you actually installed
09:44:23 <maerwald> stack and cabal don't mix well
09:44:29 <fendor> yeah, they dont
09:47:43 <fendor> maerwald, thanks for the pr
09:52:10 <maerwald> https://gist.github.com/hasufell/a0f78228ff0b3ebd31bee0c02537d5d1 now I get this
09:52:16 <maerwald> what is pinning 'process'?
09:52:23 <maerwald> I certainly didn't
09:53:17 <fendor> maerwald, I get something similar, but not quite the same
09:53:39 <geekosaur> process comes with ghc and is used and possibly exposed by ghc-api, so cabal (and stack) consider it pinned by the ghc version
09:54:35 <maerwald> geekosaur: it is pinning a newer version
09:55:26 <geekosaur> that's not how I read that, the installed one is pinned but something wants the newer version
09:56:24 * hackage squeal-postgresql 0.5.2.0 - Squeal PostgreSQL Library  https://hackage.haskell.org/package/squeal-postgresql-0.5.2.0 (echatav)
09:56:47 <maerwald> geekosaur: yes, but what does
09:57:40 <fendor> something seems to force Cabal 3.0.
09:58:13 <maerwald> cabal-install-parsers
09:58:41 <fendor> but that should be a different project?
09:58:54 <maerwald> should
10:00:28 <fendor> at least in the plan.json, I dont see a change build-plan
10:04:46 <fog> i need a really simple neural net to test an abstraction, do we have that?
10:05:28 <[exa]> fog: https://hackage.haskell.org/package/neural
10:06:05 <[exa]> fog: btw tell me you're not doing the code completion from yesterday :D
10:06:21 <fog> haha
10:06:29 <maerwald> fendor: cabal makes no sense
10:06:36 <maerwald> I can write a freeze file just fine
10:06:37 <fog> no, just the parametric models
10:06:50 <fendor> maerwald, yeah, something it weird. install fails, but build succeeds
10:07:23 <maerwald> fendor: freeze files don't necessarily end up in the sdist
10:07:36 <fog> hmm, the documentation is not great for that package exa
10:07:37 <maerwald> cabal install doesn't run in the current directory
10:08:00 <[exa]> fog: there are examples somewhere
10:08:20 <fendor> maerwald, what, why?
10:08:39 <maerwald> fendor: cabal install creates an sdist, unpacks it to a temp dir and then installs from there
10:09:40 <ChaiTRex> are there any ways for a compiler to automatically figure out that (<= n) . length might be replaceable with the generally more efficient and more likely to terminate null . drop n so that it can suggest it?
10:10:11 <maerwald> fendor: I consider that misdesigned, one of the few things stack does better
10:10:50 <maerwald> (because it allows subtle deviation between new-build and new-install)
10:11:16 <[exa]> ChaiTRex: if you accept that 'undefined <= n' can evaluate to true or false, yes.
10:11:21 <fog_> here is the idea; https://pastebin.com/raw/S8KmTyav
10:11:35 <fendor> and why does it fail now? Would more backjumps eventually solve it?
10:12:22 <geekosaur> ChaiTRex, for some compiler, yes. for ghc, currently no because of what [exa] said and that more generally you want to know that n is a compile time constant or at least less expensive than computing length
10:12:58 <geekosaur> ghc at present has no way to determine that some value is a compile time constant, and that concept has some snags attached
10:13:02 <dsal> Does anyone know of any coverage-driven test stuff for haskell?
10:13:48 <ChaiTRex> geekosaur: Wouldn't drop n be good for a runtime value n? drop terminates early on empty list, much like length terminates on empty list.
10:14:12 <geekosaur> what if n itself diverges?
10:14:28 <maerwald> fendor: but I believe it takes the freeze file into account regardless
10:14:31 <ChaiTRex> geekosaur: Well, assuming that n evaluates.
10:14:36 <maerwald> maybe the cabal store if messed up
10:14:42 <fog_> so if there was just a simple net, you would fix some of the weights to give a particular parametric model, where the remaining weights are split between parameters of the model, and the resulting manifold
10:14:54 <fog_> (coordinates on that manifold)
10:14:57 <ChaiTRex> geekosaur: If it diverges, it seems it would diverge for both code snippets.
10:15:03 <fendor> cabal-store-check says it is alright
10:15:21 <fog_> so basically you just take any function, and split its args into 3
10:15:38 <fog_> fixing the 1st set gives you a parametric model
10:15:38 <geekosaur> the other question is whether computing it is more expensive, which it might be for a short list.
10:15:45 <maerwald> fendor: I can find a build plan after deleting my cabal store. Another reason cabal sandboxes should never be deprecated
10:15:51 <fog_> fixing the 2nd is "tuning" that model
10:15:51 <maerwald> cabal store is just impossible to reason about
10:15:57 <geekosaur> basically, you don't want your optimization to be a pessimization in some cases
10:16:11 <fog_> and the final set are the output space of that tuned model
10:17:02 <fog_> the idea is then that given a particular complexity, that such a parametric model ready to be tuned can be returned
10:17:07 <geekosaur> which is complicated in Haskell by bottom and by strictness, although in this case I'm not sure we see changes due to either (other people are better at this but beware of strictness changes)
10:17:13 <maerwald> fendor: we should create freeze files for all ghc versions
10:17:35 <fog_> and we can search for the lower complexity model which has the output manifold close to that of a higher complexity model
10:17:54 <fendor> maerwald, how can these be used? Just renaming, or is there flag for it?
10:19:03 <maerwald> fendor: I believe they are derived from the project filename, which is configurable. And project files are usually where you define the ghc version to be used
10:19:33 <ChaiTRex> geekosaur: Yeah, that would be more difficult to figure out.
10:19:33 <geekosaur> ChaiTRex, this said, if you want to play with it ignoring bottoms or pessimizations, you can do it in ghc via a RULE
10:19:58 <ChaiTRex> geekosaur: Is there a way to autogenerate RULES like that?
10:20:12 <fendor> so, we could create some freeze files, e.g. `cabal.project.freeze.8.6.4`?
10:20:19 <geekosaur> not so far as I am aware
10:20:44 <maerwald> it would be: cabal.project.8.6.5 and cabal.project.8.6.5.freeze I believe
10:21:17 <geekosaur> I would be worried that, given nobody's included such in ghc, there's a good reason not to
10:21:25 <sclv> cabal store should jsut be a cache
10:21:30 <sclv> it shouldn't affect build plans?
10:22:08 <fendor> maerwald, ok, that sounds pretty good.
10:22:09 <maerwald> fendor: https://github.com/haskell/haskell-ide-engine/blob/master/install/src/HieInstall.hs#L125-L126 this will build twice
10:22:21 <maerwald> cabal new-build and new-install use different methods
10:22:32 <__monty__> sclv: I think that's true for v2-* but doesn't "cabal hell" prove it's not for v1-*?
10:22:45 <sclv> monty: the store is v2-* only.
10:23:15 <fendor> maerwald, but doesnt install swallow compile errors?
10:23:21 <sclv> new-install of exes takes into account existing libs in the global env, but that's a bug that's been fixed
10:23:36 <sclv> new-install of exes is being fixed to have the same build plans as new-build
10:23:40 <sclv> neither should be affected by the _store_
10:24:24 <maerwald> sclv: well, but the current cabal doesn't behave like that
10:24:40 <maerwald> fendor: I don't think it swallows
10:24:42 <sclv> i mean even currently, the store shouldn't affect either
10:24:52 <sclv> the global env can affect new-install of exes when it shouldn't
10:24:54 <sclv> but that's different
10:24:55 <maerwald> sclv: well, it builds twice
10:25:01 <maerwald> including some dependencies
10:26:07 <solonarv> geekosaur: how could '(<= n) . length' ever avoid evaluating 'n', anyway?
10:27:07 <solonarv> I suppose (<=) @Int might be non-strict if one of the arguments happens to be minBound or maxBound, but that definitely seems like a weird edge case considering we are talking about 'length'
10:27:12 <geekosaur> by the list being infinite :)
10:27:22 <maerwald> if tools would support sandboxes properly, I would still use those
10:27:39 <fog_> exa: are you using that lib at all? can you explain how it does the tuning and error steps? those are the parts the abstraction needs to capture
10:27:44 <geekosaur> this is a strictness change, which ghc devs are wary of
10:28:02 <fog_> i guess there is an update morphism and a comparison stage
10:28:13 <fog_> cant really see from; https://hackage.haskell.org/package/neural-0.3.0.1/src/examples/sin/sin.hs
10:28:53 <solonarv> hm, I guess
10:29:43 <solonarv> it does only make things *less* strict, which seems like it shouldn't break as much as the other direction
10:30:20 <geekosaur> les sstrict can put dampers on further optimization/strictness analysis, though
10:34:12 <fog_> also i cant get it to install...
10:34:20 <maerwald> fendor: do you want atomic PRs for everything or is it fine to push more cabal/freeze file stuff to the existing one
10:34:27 <maerwald> (as long as it's separate commits)
10:34:41 <fog_> a fully connected square net cant be that hard to write....
10:35:01 <fendor> maerwald, I would prefer separate prs
10:35:23 <fendor> but we are not that strict
10:35:32 <fog_> i guess its the backpropegation thats more involved
10:35:47 <fog_> but if that was abstracted over it could just use crude monte carlo
10:36:22 <fog_> which seems basically like some form of stochastic gradient descent - maybe hamiltonian monte carlo or something simple
10:37:24 <fog_> probably the most simple abstraction is just to take new params and have a way to determine if to keep them or not, like could be used to implement a metropolis step
10:37:57 <fog_> and maybe there is some less expensive thing than tanh?
10:39:45 <fendor> maerwald, I am not even sure we have a policy for it
10:40:58 <fendor> I am not even sure we have policies...
10:44:26 <koz_> Does not having policies constitute a policy? :P
10:45:56 <fendor> only if you explicitly set it!
10:50:19 <koz_> fendor: policy = _|_ :P
10:55:10 <fendor> koz_, but that is not no policy, right? :D
10:58:16 <koz_> fendor: Good point. Then it should be like, policy :: Void, I guess?
10:58:57 <fendor> a policy that can not be instantiated? sounds lovely!
10:59:27 <geekosaur> policy = absurd
11:30:07 <MoneyFREE> Hello ppl!! OMG there is free money and Bitcoin here!! : https://freebitco.in/?r=599908
11:35:38 <fog> ok, here is a basic template for a simple neural network; https://pastebin.com/raw/60RtskZQ
11:37:23 <fog> its just a HList of Lengthed Nonempty-lists of Doubles so far
11:38:03 <fog> bit daunted about how to fold it with fully connected tanh's!
11:38:57 <fog> not sure if thats the kind of thing you can help with...
11:40:43 <fog> oh wait! they might need to be tensors at each neuron, damn. hang on
11:43:30 <jle`> dminuoso_: i don't think there is any reason to ever write `appEndo . foldMap Endo`
11:43:44 <jle`> dminuoso_: just like there would not be any reason to write getSum . foldMap Sum
11:44:07 <jle`> dminuoso_: just write `sum` for the second case, or `foldr (.) id` for the first one
11:44:37 <jle`> same for writing getProduct . foldMap Product, etc.
11:45:24 <jle`> dminuoso_: or like `getSum (Sum 1 <> Sum 2)` instead of 1 + 2
11:46:30 <jle`> usually these newtype wrappers are only there for us in the case where we can't directly use +, *, ., etc.
11:49:57 <jle`> or to leverage existing functions when it would save a lot of time to re-implement. but using getSum . foldMap Sum vs. foldr (+) 0 or foldl' (+) 0 or sum in this case, the foldMap leveraging doesn't really save us anything i think
12:07:24 * hackage niv 0.2.10 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.10 (nmattia)
12:11:12 <jumper149> I have a problem with understanding the Streamly library. I am already used to Conduit and am now missing an operator to compose my streams.
12:15:01 <jumper149> In Conduit there is `.|` for most purposes.
12:22:35 <jumper149> I guess it's just functional composition?!
12:29:04 <[exa]> jumper149: y not tho.
12:31:24 <jumper149> [exa]: It's simple but I sort of had trouble understanding it^^ I already tried out stuff like (<>) from `Semigroup t m a`...
12:32:16 <maralorn[m]> <MoneyFREE "Hello ppl!! OMG there is free mo"> Has that to do with free monads?
12:36:41 <dsal> free moneyds
12:37:00 <[exa]> jumper149: types of both operands should kindof guide you
12:48:12 <jumper149> Is it correct that I can't use `IO` for the monad in `t m a` from Streamly? I am getting a compiler error that `IO` has no instance for `Monad.Resource`
12:55:08 <maerwald> jumper149: you're probably missing MonadAsync constraint?
13:02:13 <maerwald> also, what do you mean with "combine"?
13:02:20 <maerwald> err "compose"
13:03:19 <maerwald> https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly-Prelude.html#g:37
13:03:23 <maerwald> that?
13:05:25 * hackage byte-order 0.1.2.0 - Portable big-endian and little-endian conversions  https://hackage.haskell.org/package/byte-order-0.1.2.0 (andrewthad)
13:17:46 <jumper149> maerwald: Composition really was just functional composition, that's fine. I have also stumbled upon MonadAsync already but I am not sure how to get that constraint.
13:18:15 <maerwald> MonadAsync m => t m a
13:18:27 <maerwald> then inside you do your liftIO
13:20:47 <jumper149> Should I leave m as a type variable? I just hardcoded IO pretty much everywhere.
13:21:19 <maerwald> that won't work I guess
13:22:30 <maerwald> or well, why not
13:22:58 <maerwald> MonadAsync is just a type alias https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly.html#t:MonadAsync
13:23:16 <maerwald> there should be an IO instance for all of those
13:23:16 <jumper149> Yep thats what I thought too
13:24:04 <jumper149> But well Im not getting any of those instances to be missing but instead MonadResource.
13:24:22 <geekosaur> that's ResourceT, not Async, no?
13:24:31 <geekosaur> or newtypes/type aliases thereof
13:24:31 <jumper149> geekosaur: Yes I think so
13:25:03 <jumper149> Well I'm an idiot
13:25:46 <jumper149> I'm using this wrapper http://hackage.haskell.org/package/streaming-pcap-1.1.1/docs/Network-Pcap-Streaming.html and it literally says `MonadResource m =>` right there x)
13:27:47 <maerwald> well, that's just regular mtl stuff
13:28:16 <aplainzetakind> What does it mean for a multivariable function to be continuous with respect to a complete partial order?
13:28:36 <maerwald> also, not sure that's a good API for something streamly based, looks like this should be an Unfold, which can be bracketed
13:29:57 <jumper149> maerwald: I am using this quick `S.unfoldrM SG.uncons` from https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly-Tutorial.html#g:39
13:29:57 <maerwald> https://github.com/composewell/streamly/blob/master/src/Streamly/Internal/Data/Unfold.hs#L746
13:30:06 <maerwald> I mean Data.Unfold
13:30:36 <maerwald> that's for things that have resources
13:33:01 <jumper149> maerwald: I am kind of lost on how to rewrite that API so I think I will just try if I can get it working in the ResIO Monad for now
13:33:21 <maerwald> I did that recently, wrapping streamly with monadresource I think
13:34:01 <jumper149> What does that mean? Just use `ResourceT IO` as the inner monad?
13:34:38 <maerwald> No, I'm not even sure how they managed to make it the inner monad
13:34:48 <maerwald> myFileStream :: MonadIO m => FilePath -> ResIO (SerialT m (A.Array Word8))
13:35:40 <jumper149> Ahh so that I have ResIO outside of SerialT.
13:36:21 <jumper149> Doesn't ResIO have the necessary instances for MonadAsync?
13:36:30 <maerwald> yeah
13:37:09 <jumper149> Well that sucks..
13:39:14 <maerwald> if it's the inner monad, that means something *during* the stream is acquiring resources, no?
13:39:34 <maerwald> as in: the stepping function
13:39:46 <jumper149> Ye that sounds wrong
13:41:33 <p0a> Hello I'm trying to use happstack in my project so I edited package.yaml to include it in the dependencies, but `stack build' gives m ethe following error: https://pastebin.com/rN9a22an. Before I follow its advice, I'd like to ask, what exactly does it mean?
13:42:34 <glguy> p0a: stack expects you to manually determine the build plan for it before it will build, it's saying you haven't provided a version of that package yet and it is recommending one that might work
13:42:50 <maerwald> happstack is not in stackage it seems
13:43:21 <p0a> glguy: ok but `text' and others work without a version 
13:43:39 <maerwald> because they are in stackage
13:43:49 <glguy> p0a: you manually specified their versions by picking a "resolver"
13:44:03 <glguy> which is an arbitrary collection of packages that have compatible versions with each other
13:44:07 <maerwald> Why are you using stack? This is the main reason to use it :)
13:44:17 <maerwald> making use of stackage
13:44:19 <p0a> glguy: thank you 
13:44:39 <maerwald> https://www.stackage.org/lts-14.20/hoogle?q=happstack
13:45:23 <p0a> maerwald: don't know what to make of your link, I suspect as you/others said happstack is not in stackage
13:45:51 <maerwald> glguy: s/arbitrary/curated/?
13:46:19 <glguy> arbitrarily curated? They get bumped when they can
13:46:31 <glguy> and are arbitrarily added as people choose to add them
13:46:44 <maerwald> p0a: basically you have guarantees that packages build with each other when using stackage. But that also means the set of those packages is limited. Packages outside of that set you have to deal with by yourself and it usually gets ugly real quick
13:47:55 <p0a> maerwald: perhaps I should use yesod which is in stackage then?
13:48:01 <maerwald> ouch
13:48:30 <maerwald> you're going down a rabbit hole, but sure, if you like it
13:48:37 <p0a> well what do you recommend?
13:50:05 <maerwald> use cabal
13:50:15 <maerwald> then pick whatever backend libs you want
13:50:25 <maerwald> servant and snap are also popular
13:51:39 <p0a> servant looks like I would have to learn how http works
13:51:54 <maerwald> servant also is complicated, because of type level programming
13:52:10 <p0a> yeah could you give me something closer to newbie-level? :P
13:52:13 <maerwald> snap is more framework-ish, but still relatively light imo
13:52:35 <maerwald> scotty is good for just building something quick maybe, but it's not well maintained anymore
13:53:14 <maerwald> but well, ppl still use it in production
13:54:14 <p0a> why are you straying away from yesod/happstack, both which seem down to earth and maintained?
13:54:28 * p0a is looking into snap now
13:55:14 <maerwald> never used happstack, no idea
13:55:59 <maerwald> yesod doesn't look like a haskell library to me, but something from Java
13:56:37 <maerwald> ymmv
13:56:45 <maerwald> well-maintained it is indeed
13:57:54 <p0a> should I install cabal with stack?
13:58:05 <p0a> I know stack uses cabal but I don't have a system-wide cabal I think
13:58:27 <maerwald> p0a: what distro do you use? do you have GHC installed outside of stack?
13:59:34 <p0a> maerwald: I am using ubuntu, yeah I have GHC outside stack 
13:59:44 <maerwald> p0a: how?
13:59:46 <maerwald> which version
14:00:00 <p0a> apt install ghc, v 8.6.5
14:00:08 <maerwald> https://launchpad.net/~hvr/+archive/ubuntu/ghc you probably want that
14:00:15 <maerwald> which has multiple versions and cabal as well
14:00:25 <maerwald> and allows to switch between them
14:00:50 <dsal> p0a: what re you wanting from cabal?  If you have stack, then you should already have cabal.
14:01:07 <maerwald> dsal: stack doesn't install cabal-install
14:01:11 <p0a> dsal: well the snap docs assume I have cabal installed and don't mention stack 
14:02:02 <p0a> eh screw it I'm going with happstack 
14:02:39 <dsal> Mine's installed via stack.  I don't know why, though.  It just magically works. *shrug*
14:03:41 <maerwald> dsal: then either you installed it or a package you used silently did so
14:03:57 <maerwald> like hie
14:04:39 <fendor> maerwald, hie does not silently install it
14:04:50 <maerwald> :D
14:05:11 <fendor> yeah just read it again
14:05:12 <fendor> it does
14:05:14 <fendor> take it back
14:05:28 <fendor> *I take it back
14:05:42 <p0a> so I added the line - happstack-7.0.2@sha256:9d1ef7653dfcf33e51acc8ef93bf08995b0fab6121e4ce54094ecc11822ecc70,1365 in my stack.yaml but now it tells me to add another line, - happstack-server-7.3.9@sha256:e8c09b50400de93c4894b0ade97ce0ea861106631c3fef2ce0456e80c3d6cfdb,5993 in my stack.yaml
14:07:40 <p0a> ah I see, happstack-server versus happstack. hm 
14:08:46 <solonarv> this sort of thing is why I stopped using stack
14:09:45 <p0a> solonarv: so that's how stack works? you have to keep running the command and keep adding manually all the lines it tells you?
14:09:59 <maerwald> xD
14:10:00 <p0a> because now it spat like 10 packages it wants me to add 
14:10:07 <maerwald> just use cabal
14:10:46 <p0a> it's so frustrating when the info online tells you cabal is historical and stack is the new shazam
14:10:57 <maerwald> where did you read that
14:11:38 <maerwald> there was a timeframe of about ~2 years where stack was dominating and cabal was undermaintained, but time has changed
14:12:08 <p0a> maerwald: http://dev.stephendiehl.com/hask/#cabal
14:12:42 <maerwald> yeah, that info is wrong
14:13:18 <p0a> You know what, if I have a penny for every first tutorial I've read that was wrong
14:13:23 <nshepperd> that is out of date given it's still talking of sandboxes
14:13:33 <__monty__> It wasn't as much undermaintained as understaffed.
14:13:38 <maerwald> yep, but sandboxes still exist and work fine
14:14:42 <p0a> okay I will install cabal through aptitude and then try to get happstack working (or snap -- we'll see)
14:15:20 <dsal> p0a: You only have to manually add lines for packages that aren't in LTS.  It comes up sometimes and is pretty helpful at resolving.  I don't quite understand what's so bad about it, so I'm happy  to do it when comes up.
14:15:37 <maerwald> p0a: make sure it is cabal version 3.0.0.0
14:15:46 <dsal> cabal is difficult differently.  :)
14:15:48 <p0a> dsal: It's not that I'm not willing to do it - it's just that I am not sure if what I'm doing is right
14:15:49 <maerwald> if your distro doesn't provide it, use the ppa I linked about
14:15:59 <p0a> maerwald: mine was 2.4
14:16:09 <maerwald> use 3 please
14:16:44 <dsal> p0a: There are a few different schools of build stuff here.  I'm somewhat comfortably in stack land.  I should try a project from scratch using cabal, but I've not run into any issues yet.
14:17:04 <maerwald> if you want to complicate stuff further: https://github.com/kowainik/summoner
14:17:16 <p0a> maerwald: I want simple stuff
14:17:28 <p0a> I want to focus on making the thing I want to make lol
14:17:43 <Rembane> p0a: Then go for cabal, it has fewer moving parts. 
14:18:14 <p0a> I'll give stack one last chance by trying to get happstack working
14:20:04 <maerwald> maybe systemd should install stack
14:20:44 <jumper149> maerwald: ?!
14:21:02 <maerwald> that was a joke...
14:21:21 <jumper149> Ye but im not getting it
14:21:32 * p0a slaps jumper149 with a large trout
14:21:41 <maerwald> they both follow unix principles.... not ;)
14:21:59 <sm[m]> p0a: coming in late, but from what I remember of your requirements the other day, you should just go with yesod. It has a book, it's the most mainstream, maintained and well-trodden path for you
14:22:27 <p0a> sm[m]: thanks -- ugh alright then. Yesod it is!
14:22:39 <jumper149> On a more serious note, what does stack actually provide? I have used nix and cabal but never felt like trying out stack
14:22:52 <maerwald> jumper149: you are already using it ;)
14:22:56 <maerwald> nix uses stackage too
14:23:02 <fendor> jumper149, it installs ghc for you
14:23:46 <dsal> jumper149: When you build a project with a particular LTS, it's a particular version of GHC with particular versions of libraries.  You can upgrade all the things at once to a set that should work well together.
14:23:52 <dsal> Does cabal still require listing all the source files?
14:24:16 <maerwald> dsal: stack also does, it just has an internal version of hpack
14:24:20 <dsal> I don't like yaml much, but the cabal format seem just a little worse.
14:24:36 <dsal> maerwald: You mean cabal?
14:24:39 <maerwald> stack cannot use hpack directly, all of them create cabal files
14:24:41 <maerwald> no
14:25:27 <dsal> I was referring to stack in the above.
14:25:47 <maerwald> stack requires listing all source files too.
14:26:00 <dsal> I don't do that.
14:26:13 <dsal> Most of my projects have a lot more files than I list.
14:26:19 <maerwald> yes, because you are using hpack, which *generates* a .cabal file which lists *all* source files
14:26:23 <maerwald> see, people don't even know how the tools work together when they use stack :P
14:27:31 <dsal> Assuming you are correct, does that matter?  Seems like a good thing if I don't have to know all of the extra work that needs to be done to make my program work.
14:28:32 <dsal> I understand the stack/hpack/cabal/ghc/etc... bits.  But I don't have to do extra work when I add a file -- or worse, rename a file or directory.  That's just busy work that can be quite unpleasant.
14:29:33 <sm[m]> jumper149: "Stackage .. is a curated set of packages that work well together.. Stack is a tool made specifically to make using Stackage snapshots easy and convenient" -- https://www.stackage.org . Also as mentioned it auto-installs the right ghc for you (cross platform)
14:29:36 <maerwald> dsal: yes, it has created problems, because library maintainers didn't understand that you still should commit .cabal files to your repository, no matter if you use hpack or not
14:30:01 <sm[m]> maerwald: examples please
14:30:04 <dsal> That's an opinion that was discussed recently.  .cabal ~ .o in my development cycle.
14:30:08 <maerwald> sm[m]: ?
14:30:19 <maerwald> that was the example
14:30:33 <sm[m]> what real projects don't commit cabal files ? I've never seen one 
14:30:42 <dsal> I don't commit cabal files.
14:30:49 <maerwald> https://github.com/y-taka-23/thank-you-stars/issues/4
14:31:17 <sm[m]> thanks
14:31:27 <maerwald> and I provided PRs for quite a few as well
14:31:45 <maerwald> we even had to fork some library, because of this
14:32:15 <sm[m]> I suppose some might say, I'll provide cabal files if you start providing stack.yamls..
14:32:27 <maerwald> because it breaks source-repository-package of cabal
14:32:51 <maerwald> sm[m]: well, stack already generates the .cabal file
14:33:00 <maerwald> people just don't commit it, because they don't understand the tools
14:33:11 <dsal> Are you sure that's why?
14:33:15 <maerwald> yes
14:33:23 <sm[m]> I don't think that's very common, in practice
14:33:28 <dsal> How do I not understand the tools?
14:34:03 <maerwald> sm[m]: https://github.com/codedownio/aeson-typescript/pull/11
14:34:07 <maerwald> still open, no response
14:34:31 <maerwald> and I needed that lib ;)
14:34:53 <p0a> maerwald: so which file is it that you want committed in particular?
14:35:08 <maerwald> <projectname>.cabal
14:35:15 <maerwald> that's the only true definition of a haskell package
14:35:43 <p0a> okay
14:35:46 <dsal> It's similar to committing Makefile when you use autotools.
14:35:58 <maerwald> no, Makefile is more generic
14:36:27 <sm[m]> maerwald, could you explain "it breaks source-repository-package of cabal"
14:36:50 <maerwald> sm[m]: cabal will clone the repo, try to build it and fail, because there is no cabal file :)
14:37:04 <dsal> Have you filed a bug against cabal?
14:37:10 <maerwald> it's not a cabal bug
14:37:19 <p0a> dsal: what would be the fix?
14:37:38 <sm[m]> add hpack capability ?
14:37:40 <maerwald> dsal: you cannot upload a package to hackage without a .cabal file
14:37:47 <dsal> The cabal file is entirely derivable.  It's a slightly higher level, but if the build is already cloning a repo, it can do the hpack.
14:37:49 <maerwald> sm[m]: that won't happen 
14:37:50 <dsal> maerwald: and I don't.
14:38:05 <maerwald> I doubt it at least and it's the correct choice
14:38:12 <sm[m]> never say never! :)
14:38:19 <maerwald> Well, I hope not then.
14:39:39 <dsal> These bugs on random repos are just fanning tool wars.  I wouldn't check in derived artifacts just because someone randomly asked me to.  It doesn't help me, and typically when I tweak my development processes for people other people, I add more burden on myself without getting more contributors.
14:39:58 <dsal> I have had some PRs on my stack projects.  None have .cabal files checked in.  It's only come up in theoretical conversations here.
14:40:18 <maerwald> Well, it wasted a lot of my time in real-life
14:40:34 <dsal> If someone sent me a PR that made a change to committed .cabal file, I'd have to reject it since it'd conflict with generated things anyway.
14:41:28 <LevyElara[m]> I have had to manually write .cabal files to package things so I can use them with Guix
14:41:30 <LevyElara[m]> It's irritating
14:41:52 <maerwald> well yes, it also annoys distro packagers (but that's a different story)
14:42:18 <dsal> I guess I'd be surprised if someone were distributing from my github repo instead of my released packages.
14:42:48 <maerwald> dsal: so are you creating sdist tarballs and upload them to github release page?
14:43:10 <p0a> so if I run `stack install yesod-bin --install-ghc' inside my stack project is that a local (project-wide) install?
14:43:42 <dsal> maerwald: I release through hackagee.
14:43:55 <p0a> I think it's in PATH
14:44:06 <nshepperd> it's always annoying when I'm using something from releases (eg. on hackage), then I need to install the git version (cause it has a fix I need or something) and the git repo uses some different build method
14:44:15 <maerwald> dsal: nice
14:44:41 <maerwald> dsal: hackage maintainers may overwrite your cabal files :P
14:44:56 <dsal> nshepperd: Does that imply there should only be one build system at all?
14:45:05 <dsal> maerwald: Heh, they're not my files... they're generated for release. :)
14:45:35 <nshepperd> no, just that I should be able to build from git in exactly the same way I build from release
14:45:47 <maerwald> dsal: now, that still doesn't cover all use cases for a distro packager
14:45:59 <sm[m]> p0a: executables are installed to ~/.local/bin. The docs explain more
14:46:08 <dsal> nshepperd: Makes sense.  In that case, I'm inconsistent by convention.
14:46:39 <p0a> sm[m]: thank you
14:46:53 <glguy> I try to avoid packages that only provide package.yaml files as that's usually an indicator that there will be other issues with the package
14:47:40 <dsal> Hmm...  I was going to make a change to a package recently, but it was .cabal only and that raised the bar just enough that I didn't want to bother.
14:47:54 <hpc> glguy: extra credit if the hackage docs just say "go look at stackage"
14:48:13 <glguy> In that case I know who uploaded it and also avoid
14:48:25 <hpc> mario! your documentation is in another castle!
14:49:08 <p0a> for a bunch of people here who probably make above-middle-class bucks, the drama is real
14:49:17 <orzo> Is there a way to tell cabal to build *only* profiling versions?
14:49:33 <dsal> p0a: Some days, these are our only problems.
14:49:40 <glguy> orzo: cabal build --enable-profiling
14:49:59 <orzo> glguy, that will build the non profiling versions too making me wait twice as long
14:50:56 <orzo> i want a way to build profiling only
14:51:18 <dsal> sta
14:51:38 <nshepperd> run ghc directly
14:52:07 <orzo> it's a big project with a bunch of libraries
14:53:09 <solonarv> presumably you want to run the result if succesful
14:53:37 <solonarv> haev you tried 'cabal run --enable-profiling'? that *might* only build the profiling versions (but I am not sure)
14:53:48 <solonarv> otherwise you should just be able to invoke ghc directly too
14:54:37 <solonarv> cabal v2-{build,run,etc} writes a .ghc.environment file to the project directory that sets up the correct environment for invoking ghc on your project
14:55:08 <solonarv> ghc will pick up that file and use the environment defined therein
14:55:28 <solonarv> (that is by default; those behaviors can be changed in the respective config files and/or with command-line flags)
14:55:31 <orzo> my project has a cabal.project with 16 subdirectories referenced
15:09:48 <pounce> so im having a parsing problem (believe it or not) using MegaParsec
15:10:19 <pounce> im working on parsing a sort of lisp. im having trouble parsing forms which contain two sets of delimeters
15:11:43 <pounce> here's what i have right now https://gist.github.com/4e554c4c/5652da81509490421af61af6200f0509 my function `inDelimeters` takes a parser and is supposed to run it inside a pair of delimeters or fail; but composing this function with itself has not worked well
15:11:56 <pounce> you can see what im trying to parse on line 72 with my attempt below it
15:13:37 <pounce> oh nevermind fixed it im dumb
15:13:44 <pounce> the case before was too greedy and not backtracking
15:24:40 <maerwald> fendor_: what do you mean with CPP instruction? where?
15:27:19 <fendor_> maerwald, I am not sure yet. A solution could be to only depend on `cabal-install-parsers` if we are running with cabal and guard `getInstallDir` to either use cabal-install-parsers or returning some dummy-filepath
15:27:38 <fendor_> you understand the problem we have?
15:28:00 <maerwald> I was thinking about a cabal flag, but I don't know how to do that with CPP
15:28:16 <fendor_> cabal flag in cabal is fine, but you need some CPP in Cabal.hs
15:28:22 <maerwald> yes sure
15:28:30 <maerwald> ~/.local/bin could then be hardcoded when stack is run
15:28:52 <fog> ok, im just going to leave this here, got fairly close; https://pastebin.com/raw/9XbiLap9
15:28:56 <fendor_> ok, great. I find stack problems hard to explain
15:29:00 <maerwald> :D
15:29:29 <fendor_> yeah, and hardcode some default paths. Maybe dependent on windows, too?
15:29:49 <fendor_> However, if we are not run by cabal, we should not even get to that code-path, right?
15:30:38 <fog> needs yet to unfold an inital net and to fold the net to evaluate it against some inputs
15:30:59 <fog> but has the difficult part of having a function per input node in a fully connected net
15:31:05 <fog> per edge*
15:33:29 <maerwald> fendor_: well, what if someone does: stack install.hs cabal-hie-8.6.5
15:33:35 <maerwald> boom
15:34:05 <maerwald> we can make it an error early, but yeah
15:34:30 <fendor_> We have talked about removing that targets.
15:34:42 <maerwald> so always automagic?
15:34:57 <fendor_> or is there any reason why people want to use stack-script to use cabal install?
15:35:41 <maerwald> dunno
15:35:43 <fendor_> that would be my idea, not sure how jneira thinks about it, yet
15:36:06 <jle`> glguy: looking over some of your cont+conduino code ... is labelCC a thing people use/define anywhere?
15:36:40 <jle`> glguy: or do you just always write it as a one-off. assuming it is a generally reusable sort of hting
15:39:20 <monochrom> Is labelCC callCC (\c -> return (fix c))?
15:40:13 <maerwald> fendor_: can just put 'when isRunFromStack' in front of all those rules, then they will be hidden when run with cabal
15:40:37 <fendor_> maerwald, yeah, that should work
15:58:18 <jle`> monochrom: https://gist.github.com/glguy/6d5250f1c786b7723a0e4722838e4797#file-breakout-hs-L132
15:58:54 <jle`> newtype Label m = Label (forall a. m a)
15:59:07 <jle`> labelCC = ContT \k -> let rec = k (Label (ContT \_ -> rec)) in rec
15:59:29 <glguy> jle`: it's also available here: http://hackage.haskell.org/package/monadLib-3.10/docs/MonadLib.html#t:Label
16:00:23 <jle`> glguy: ah, thanks
16:01:00 <jle`> it feels like something that woulkd be generally reusable/useful
16:02:49 <jle`> glguy: currently trying to implement 'resumable' pipe feeding with ContT, but my cont foo isn't too great
16:02:59 <jle`> cont-fu 
16:05:15 <glguy> jle`: Have you seen this? https://github.com/glguy/advent2019/blob/6c116b12878a1d4c914920ddd02f8768b2841b5c/common/Advent/Intcode/Conduino.hs#L44-L57
16:05:56 <jle`> ah, i haven't. thanks :)
16:06:49 <iqubic> My cont foo is non-existent. I cont understand it.
16:09:09 <jle`> glguy: hm, interesting. that code looks really similar to if you turned Effect into a Monad
16:09:59 <jle`> by adding an (a -> Effect ..) field to Output/Input sorta
16:10:44 <glguy> data Effect a = Halt a | ...
16:10:50 <glguy> if you wanted a monad instance
16:11:20 <jle`> ah, yes.
16:11:52 <jle`> if you turned Effect into a monad like that, you basically can write over Pipe Int Int u Effect instead of Cont OldEffect
16:12:46 <jle`> er, that's my guess at least
16:14:52 <jle`> hm. this way it feels like you are basically extracting the internal structure of Pipe into your own data type, which is nice. but if i'm going to implement this as a part of the library interface i might as well just dig into the internal code
16:15:59 <maerwald> are there pre-built binaries for alex somewhere?
16:24:40 <koz_> iqubic: It can be cont-fusing.
16:29:58 <oats> jle`: oh hey, you're the guy with the AoC reflections I've been reading
16:30:28 <oats> :) I've really been enjoying those, thanks for writing them. Nice to see how other people solve these
16:31:20 <jle`> oats: ah, i'm glad you have enjoyed them :)
16:31:30 <jle`> sorry they're a bit incomplete heh, been meaning to catch up on them :)
16:31:37 <oats> no worries
16:32:18 <oats> on day 13, still refraining from turning my intcode VM to conduit-based
16:32:24 <oats> laziness has gotten me this far :P
16:34:17 <jle`> heh. i think maybe you can do a lot with laziness. but these challenges are actually a pretty nice way of learning about stream processors :) i learned a lot about them myself during this process
16:36:42 <oats> the bit I'm pushing up against is I'm not sure how to compose pipes (streams? conduits? terminology...) with a different underlying monad
16:36:46 <oats> for example, with the paint bot one
16:37:05 <Axman6> generally you can't compose different monads
16:37:09 <oats> yeah
16:37:19 <oats> my paint bot is a simple StateT over a Writer
16:37:32 <Axman6> time to use mtl
16:37:39 <oats> my vm is ExceptT (for early exit) over StateT over Writer
16:38:03 <oats> writer is how "output" is performed, and input is passed into the starting states
16:38:26 <oats> I understand if this were Conduits, they would have to be the same
16:38:28 <jle`> is the StateT handling the raw VM input (Ints) or the hull state?
16:38:32 <oats> but I'm not sure how to make that all work in a nice way
16:39:17 <oats> jle`: for the paintbot? the state contains the input list from the VM, bot direction, location, and a map of hull coords to color
16:39:30 <jle`> oats: for when you said "my VM is ExceptT ..."
16:39:35 <glguy> once you "run" your VM all the writer, state, and except goes away
16:39:35 <oats> oh
16:39:38 <jle`> ah, yeah
16:39:53 <oats> jle`: vm input
16:39:55 <jle`> the conduit interface handles the VM input and output for you
16:40:00 <oats> along with pc, memory, etc.
16:40:03 <jle`> so you shouldn't be using StateT and Writer to handle the input and output
16:40:30 <oats> well, writer would be replaced by a conduit on the outside of a type
16:40:38 <oats> and I could get rid of the input fields in the state records
16:40:40 <glguy> to use conduits you're explicit about the interleaving of inputs and outputs (a detail that your current implementation abstracts over and loses)
16:41:24 <jle`> oats: yeah, so writer and state don't really exist for the conduit version
16:41:58 <jle`> since conduit handles incremental output and incremental input for you already, you wouldn't need to handle it using writer and state
16:42:03 <oats> jle`: so I would have to ditch state alltogether for my VM?
16:42:16 <glguy> ?package intcode
16:42:16 <lambdabot> http://hackage.haskell.org/package/intcode
16:42:17 <glguy> You can use my package and embed it into whichever conduit-like you want :)
16:42:27 <jle`> oats: you can use state to implement your VM internally maybe
16:42:40 <jle`> but your external interface as a Conduit Int Int m will not expose State
16:42:45 <glguy> using state or writer is an implementation detail
16:43:21 <oats> glguy: I've had fun reading your code, but I'm not going to outright borrow your intcode machine :P
16:43:26 <oats> not yet at least
16:43:46 <jle`> whatever your implementation is, Conduit is the thing that handles 'getting the input' and 'popping out output' from the external API perspective
16:43:51 <glguy> oats: The process of using conduit-based intcode to solve the challenges and implementing one are pretty much unrelated
16:44:40 <glguy> so if you're more interested in using conduit to implement the challenges you can always come back later and to your own implementation of intcode on conduit
16:45:05 <jle`> you might find https://hackage.haskell.org/package/conduit-1.3.1.2/docs/Data-Conduit-Lift.html useful, if you wish to use State to implement things like the memory state and base and stuff
16:45:10 <jle`> but you don't have to use state at all
16:45:56 <jle`> the way i wrote it myself was by using State to handle memory state, position, relative base, etc. and then using execStateC to 'hide' the state from the external interface
16:46:02 <jle`> er, hide the State
16:46:08 <jumper149> Hi do I have to use any compiler flags to make my program using Streamly concurrent?
16:46:38 <jle`> oats: but i never use State or Writer to handle the input/output becasue conduit gives us 'yield' and 'await' for just that
16:46:41 <oats> jle`: and you can do that even when you have `await`s and `yields` in the "heart" of the stateful stuff?
16:47:01 <oats> I somehow overlooked the Lift module
16:47:11 <jle`> yeah, if you have Conduit Int Int (StateT Memory m)
16:47:18 <maerwald> jumper149: I don't think so, but 'ghc-options: -O2 -fspec-constr-recursive=16 -fmax-worker-args=16' is recommended
16:48:16 <jumper149> maerwald: Well it's weird because my program runs fastest when using SerialT?!
16:48:17 <maerwald> maybe also add threading: -threaded -rtsopts -with-rtsopts=-N
16:48:34 <iqubic> I'm using State internally and Monad m => Conduit Int Int m externally.
16:49:46 <oats> ok
16:49:52 <iqubic> Can you add those to your cabal file?
16:50:01 <oats> I'm going to go re-tackle day 11 with conduits
16:50:12 <oats> jle`, glguy: thanks for the inspiration :)
16:50:30 <jumper149> maerwald: It's gotten even slower witht these flags wtf x)
16:50:38 <maerwald> lol
16:50:49 <maerwald> jumper149: check the gitter chat, the main dev is active there
16:51:10 <jumper149> maerwald: gitter?
16:52:02 <maerwald> yeah, this pesky proprietary github integrated thing
16:52:10 <maerwald> https://gitter.im/composewell/streamly
16:52:55 <MarcelineVQ> maerwald, jumper149: it doesn't seem frowned upon to ask question via the issue page fwiw
16:53:09 <MarcelineVQ> the devs have so far been really responsive and helpful
16:53:34 <maerwald> https://github.com/composewell/streamly/issues/152
16:56:24 * hackage cpkg 0.2.3.8 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.8 (vmchale)
17:02:24 * hackage cpkg 0.2.3.9 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.9 (vmchale)
17:07:40 <maerwald> hm, ghc-8.8 cannot be bootstrapped with itself?
17:09:17 <jumper149> maerwald: I found a problem I had: I just used "-with-rtsopts=-N" instead "-N2" for example... x)
17:09:47 <jumper149> It's still a little bit slower than serially though
17:10:00 <maerwald> you do a lot of IO?
17:10:08 <jumper149> Maybe I will have to do the file IO from within Streamly
17:11:11 <jumper149> Also a lot of printing on screen. Does that also slow down concurrency?
17:23:51 <iqubic> jumper149: Yeah.
17:28:31 <oats> jle`: so here's my VM's core type: "type VM m a = ConduitT Int Int (ExceptT VMError (StateT VMState m)) a"
17:28:59 <oats> it looks like I now have to add a (Monad m) constraint to all my VM functions??
17:29:06 <oats> not sure if I'm on the right track here or not
17:29:06 <jle`> oats: that's an ok implementation, but to the external user of the VM you shouldn't have to worry about the ExceptT or StateT
17:29:19 <jle`> oats: yeah, Monad m => ... is needed for when you use it
17:30:12 <jle`> so try using `flip execStateC . runExceptC` to turn it into a VMState -> ConduitT Int Int m (Either VMError VMState)
17:30:19 <jle`> and type VM m = ConduitT Int Int m a
17:30:53 <jle`> s/a//
17:31:26 <oats> ah
17:31:32 <oats> I think I see how that works
17:32:20 <oats> but why that VM type? All my type signatures would get pretty long
17:33:26 <jle`> hm, what do you mean long?
17:33:43 <jle`> usually you'd have something like VM (State HullState)
17:33:45 <jle`> or VM Identity
17:34:53 <oats> well then I get sigs like "readInput :: Addr -> VM (ExceptT VMError (State VMState)) ()"
17:35:10 <oats> that doesn't seem super desireable
17:36:13 <oats> or I could do "readInput :: (MonadError m, MonadState VMState m) => Addr -> VM m ()" to be more general
17:36:28 <jle`> neither of those seem that bad to me
17:36:33 <oats> fair enough
17:36:38 <jle`> but if you are worried about long type signatures then you can alias things more
17:36:46 <oats> guess it's just the price to pay
17:37:09 <jle`> i'm not sure i see what price you are talking about
17:37:15 <oats> longer types :P
17:37:18 <jle`> do you mean writing VM (ExceptT VMError (STate VMState)) instead of VM Identity ?
17:37:50 <oats> well when everything's under the same monad I can just use "VM a" for everything
17:38:29 <jle`> yeah, you can write a type alias for when you are writing the internal implementation
17:38:55 <jle`> type InternalVM m = VM (ExceptT VMError (StateT VMState m) or something
17:39:03 <oats> ahh
17:39:06 <jle`> or just State VMState and no m
17:39:31 <oats> thanks for the tips, I really appreciate it
17:39:41 <jle`> no problem :)
17:47:24 * hackage cpkg 0.2.4.0 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.4.0 (vmchale)
18:11:57 <hololeap> Module ‘GHC.TypeLits’ does not export ‘(+)’
18:12:05 <hololeap> 19 | import GHC.TypeLits (KnownNat, (+))
18:12:13 <hololeap> do i need to do something special here?
18:13:09 <jackdk> hololeap: {-# LANGUAGE ExplicitNamespaces #-} and import GHC.TypeLits (type (+)), perhaps?
18:14:19 <hololeap> jackdk: yeah, that did it
18:17:54 * hackage accelerate-kullback-liebler 0.1.0.0 - Kullback-Liebler divergence  https://hackage.haskell.org/package/accelerate-kullback-liebler-0.1.0.0 (vmchale)
18:45:05 <topos> is there any historical reason why Text doesn't have an 'elem' function?
18:48:02 <monochrom> Perhaps find and findIndex are even more informative.
18:49:00 <maerwald> because Text splits into Text and not into a subtype
18:49:36 <oats> interesting
18:49:43 <oats> I got the conduit-based intcode setup working, finally
18:49:49 <oats> significant slowdown in performance though
18:53:18 <maerwald> topos: oh well, actually... elem requires Foldable
18:56:39 <jackdk> % elemOf each 'x' ("hax" :: Text)
18:56:39 <yahb> jackdk: ; <interactive>:140:27: error: Not in scope: type constructor or class `Text'
18:56:54 <jackdk> % import Data.Text (Text)
18:56:54 <yahb> jackdk: 
18:57:01 <jackdk> % elemOf each 'x' ("hax" :: Text)
18:57:01 <yahb> jackdk: ; <interactive>:142:18: error:; * Couldn't match expected type `Text' with actual type `[Char]'; * In the third argument of `elemOf', namely `("hax" :: Text)'; In the expression: elemOf each 'x' ("hax" :: Text); In an equation for `it': it = elemOf each 'x' ("hax" :: Text)
18:57:12 <jackdk> % :set -XOverloadedStrings
18:57:12 <yahb> jackdk: 
18:57:16 <jackdk> % elemOf each 'x' ("hax" :: Text)
18:57:17 <yahb> jackdk: True
18:57:33 <topos> maerwald to be fair, filter, partition, find etc. all deal with char predicates
18:57:43 <topos> You could easily implement `elem` in terms of the existing combinators
18:58:58 <topos> and yes, lens implements this
19:00:22 <topos> monochrom yeah, I'm thinking `elem c t = isjust (find (== c) t)` would do just fine. That's why i'm wondering why it wasn't in the api when so many of the other Foldable functions have parallels
19:00:33 <maerwald> topos: but there is no Foldable instance
19:00:40 <topos> you don't need one
19:01:06 <topos> Text implements its own versions of the Foldable api
19:01:13 <topos> with the exception of elem, of course
19:02:07 <dmwit> maerwald: Think Data.Text.elem instead of Data.Foldable.elem
19:03:09 <topos> or, for parity, consider Data.ByteString.elem which actually exists :P
19:03:31 <maerwald> dmwit: I'm aware. But that's one of the few reasons I could think of it wasn't included.
19:04:32 <maerwald> comparing text is hard anyway
19:04:38 <maerwald> for bytestring it's well defined
19:05:01 <nshepperd> it's probably just not used very often relative to isInfixOf
19:05:10 <monochrom> I take the view of economics and politics whenever something would be easily do-able but not done.
19:05:46 <topos> that takes us back to the original question :)
19:05:54 <topos> hysterical raisins?
19:06:03 <monochrom> Sometimes, no one cares enough to do it (economics). Sometimes, only a few people are in a position to do it (politics), but they don't care enough to (economics).
19:06:28 <maerwald> I guess whenever someone wondered why it didn't exist, they ended up bikeshedding about it here and then went on with their life, never providing a PR :P
19:06:40 <topos> Well, there's no harm in a PR. I'll have one up tonight and see what they say
19:06:42 <monochrom> I'm a reductionist.  I reduce history to unfolding of economics and politics.  :)
19:06:48 <oats> jle`: if you're not too busy, would you mind critiquing my conduit'ed paintbot? https://paste.xinu.at/QGHvwoQ/hs
19:07:03 <maerwald> well, text is part of GHC, and they might want to discuss it on the haskell-libraries mailing list
19:07:03 <topos> That's usually a fair assumption. 
19:07:28 <maerwald> it's not as bad as lkml
19:07:34 <topos> Eh. I'd rather not submit my one-liners to committee approval
19:07:39 <topos> let's see what the maintainers say
19:07:56 <maerwald> last time I provided something trivial, that's exactly what happened
19:08:10 <nshepperd> monochrom: a history metamorphist?
19:08:21 <maerwald> https://github.com/haskell/containers/pull/592 there, almost a year now :P
19:08:52 <topos> ah well the base libraries are glacial. They have to be for good reasons.
19:09:18 <topos> harass treeowl until he gives in 
19:09:20 <topos> :D
19:09:30 <maerwald> can't be bothered, I moved on
19:09:34 <monochrom> Nooo!!!! I have "reduce" there so there is a catamorphism. I have "unfold" there so there is a anamorphism.  So I think I am a history hylomorphist (IIRC what's hylomorphism).
19:10:02 <monochrom> But Text is not in base.
19:10:17 <maerwald> wait, not?
19:10:22 <topos> conjuage histohylomorphicist
19:10:22 <monochrom> And containers is not part of base either.
19:10:26 <topos> *conjugate
19:10:42 <maerwald> yes, but bundled with ghc
19:10:50 <maerwald> so they do all sorts of release coordination
19:11:32 <nshepperd> a hylomorphism is an unfold followed by a fold. a metamorphism is the opposite, so i thought that fitted better
19:12:32 <monochrom> Ah then yes I'm doing a metamorphism.
19:13:19 <topos> that's so meta
19:13:37 <monochrom> Hey I think this helps me remember the order of hylomorphism because now I know the other order is metamorphism and I can re-invent which order it is.
19:14:03 <nshepperd> :)
19:21:10 <iqubic> What is a metamorphism?
19:21:40 <monochrom> unfold . fold
19:21:45 <monochrom> as said
19:21:46 <topos> an anamorphism composed with a catamorphism
19:21:48 <MarcelineVQ> it was literally just said above
19:21:58 <monochrom> Please refer to your scrollback buffer for more details.
19:22:17 <MarcelineVQ> not the easiest thing to google at least
19:22:54 <monochrom> Who needs google when you can just do a ctrl-f search of your IRC scrollback.
19:23:14 <monochrom> except it's ctrl-s if inside emacs.
19:23:29 <shachaf> Who needs to real scrollback when you can just ask a question and have people type the answer in again?
19:23:44 <monochrom> Yeah! Which gets me thinking...
19:24:11 <monochrom> Wouldn't it be nice if before you ask a question, you have to pass an exam on the content of the scrollback buffer?
19:24:36 <monochrom> "Question 1: What is topos planning to submit a PR for?"
19:24:56 <topos> s/is/was 
19:24:56 <topos> https://github.com/haskell/text/pull/274
19:25:02 <monochrom> Oh!
19:25:35 <topos> #productivehaskelldeveloperwithlongenterprisenamingconventions
19:25:39 <monochrom> "Question 2: According to monochrom's theory, what drives the happening and non-happening of FOSS?"
19:25:56 <topos> economy and laziness
19:26:01 <monochrom> :)
19:32:36 <hololeap> i've got (f :: Store s a -> (a,b)) and (g :: Store s (a,b) -> a)
19:33:49 <hololeap> i'm wondering if there's some way to use comonad transformers to get something like: (f :: StoreT s w () -> b) and (g :: StoreT s w b -> a)
19:34:27 <hololeap> which comonad just holds a variable, like Reader?
19:34:48 <hololeap> ultimately i'll be doing (f =>= g)
19:35:20 <dolio> (,) r
19:35:46 <monochrom> And hey, IIRC they are adjoint functors!
19:36:01 <dolio> How about that?
19:36:18 <hololeap> oh, i found Env...
19:36:23 <monochrom> Adjoint functors are BFF
19:36:53 <hololeap> dolio, wait is that same as Env?
19:37:02 <dolio> Yeah, probably.
19:39:17 <iqubic> I have no clue what an adjoint functor is.
19:40:04 <dolio> F ⊣ G means (F A -> B) ≅ (A -> G B)
19:40:14 <dolio> Natural in A and B.
19:40:50 <dolio> So in this case, Kleisli arrows for the monad are equivalent to Kleisli arrows for the comonad.
19:40:56 <iqubic> Weird.
19:41:00 <hololeap> i know that ((,) a) is adjoint to ((->) a), but i don't remember which one's left or right
19:41:00 <monochrom> Although, a definition is still very far from all its beauty and consequences.
19:41:48 <hololeap> and that adjunction is observed by curry and uncurry
19:42:05 <hololeap> or something...
19:43:55 <dolio> Yes.
19:44:16 <hololeap> also, isn't that pretty much the only adjunction where both functors are Hask -> Hask ?
19:44:51 <monochrom> This one, if you use curry and uncurry for the ≅, you find yourself writing "(,) r a -> b" and "a -> (->) r b", so (,)r is the F there, (->)r is the G there.
19:44:53 <dolio> Yes.
19:45:40 <monochrom> #mnemonicgrouptherapyclub
19:45:57 <monochrom> err, I mean #mnemonicmutualsupportgroup
19:46:46 <monochrom> My mnemonic problem is I need to just memorize that "Foo A -> B" makes Foo the left one.
19:55:55 <zeta_0> besides the yesod book, is there a link to updated examples of yesod web programming, most of the yesod examples i find online are outdated?
19:56:37 <zeta_0> i want to find a bunch of small yesod examples that i can quickly run?
19:59:00 <hololeap> monochrom: that helps
20:01:39 <hololeap> woah, what would Cofree ((->) r) be like...
20:02:57 <jle`> oats: looks good to me :)
20:05:14 <hololeap> > :t (:<) @((->) Bool)
20:05:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:05:23 <hololeap> % :t (:<) @((->) Bool)
20:05:23 <yahb> hololeap: ; <interactive>:1:1: error:; * Cannot apply expression of type `a0 -> b0 -> b0'; to a visible type argument `((->) Bool)'; * In the expression: (:<) @((->) Bool)
20:05:32 <hololeap> % :t (:<) @((->) _)
20:05:32 <yahb> hololeap: ; <interactive>:1:1: error:; * Cannot apply expression of type `a0 -> b0 -> b0'; to a visible type argument `((->) _)'; * In the expression: (:<) @((->) _)
20:06:11 <jle`> hololeap: the docs actually give that as one of the examples, if you are looking for spoilers :)
20:06:21 <hololeap> which docs?
20:06:25 <jle`> the docs for Cofree
20:07:32 <hololeap> i'm curious because there's instance Adjunction f u => Adjunction (Free f) (Cofree u)
20:08:23 <hololeap> Free ((,) a) b is basically ([a],b)
20:08:52 <hololeap> but i'm having a hard time imagining Cofree ((->) a)
20:09:02 <hololeap> or how the two would interact
20:09:02 <iqubic> What does Adjuction look like?
20:09:36 <topos> simplistically, a natural isomorphism between hom functors 
20:10:10 <hololeap> never heard of a Moore machine before...
20:10:17 <iqubic> Oh, yes. That clears it up. I barely know what a hom functor is.
20:10:41 <topos> F : C -> D, G: D -> C, F -| G ~ ∃phi : D(F(-), =) =~ C(-, G(=))
20:10:54 <iqubic> Huh?!?!?!
20:10:57 <jle`> hololeap: if you understand Cofree then that's pretty much all there is to it :)
20:11:20 <topos> iqubic if you're going to get pissy i'm not going to explain any further
20:11:44 <hololeap> iqubic: https://bartoszmilewski.com/2016/04/18/adjunctions/
20:11:59 <jle`> hololeap: data Moore r a = Moore a (r -> Moore r a), pretty much
20:12:18 <jle`> hololeap: it's used in the theory of finite automata
20:12:33 <iqubic> What does the adjuction type class do here? https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Adjunction.html
20:12:46 <jle`> although technically when we apply it to haskell types it becomes potentially infinite automata hehe
20:12:53 <jle`> iqubic: the methods are there in the documentation :)
20:13:42 <jle`> hololeap: the 'a' represents the possible states and the 'r' represents the links between states, so a Moore machine is a machine that starts at a state and can move to and from different states based on a given 'r'
20:13:47 <hololeap> iqubic: i haven't found a good use for it yet, but there must be one since it's installed on my computer
20:13:52 <iqubic> I don't understand how those are ever useful.
20:14:08 <iqubic> the one time I used it was for the repersentable stuff.
20:14:34 <iqubic> For tabulate
20:16:26 <hololeap> i'm using Control.Comonad.Representable.Store right now
20:17:16 <hololeap> jle`: it looks almost like the iterate function
20:17:38 <oats> I always misread "Cofree" as "Coffee"
20:17:40 <jle`> hololeap: but the adjunction between \a -> ([r], a) and `Moore r a` is pretty neat maybe
20:17:50 <hololeap> % :t iterate @(a -> b)
20:17:50 <yahb> hololeap: ; <interactive>:1:11: error: Not in scope: type variable `a'; <interactive>:1:16: error: Not in scope: type variable `b'
20:17:56 <hololeap> % :t iterate @(_ -> _)
20:17:56 <yahb> hololeap: ((w1 -> w2) -> w1 -> w2) -> (w1 -> w2) -> [w1 -> w2]
20:17:59 <jle`> hololeap: yeah, that's a good way to think about it. it's 'unfoldr' but without the Maybe
20:18:05 <EvanR> Covfefe
20:18:17 <jle`> :t unfoldr
20:18:19 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:18:23 <oats> Cofrefe
20:18:27 <jle`> :t unfoldr . (Just .)
20:18:28 <lambdabot> (b -> (a, b)) -> b -> [a]
20:19:08 <jle`> where the 'b' is `Moore r a`
20:19:27 <hololeap> is there a way to name the type variables when you use TypeApplications?
20:19:35 <jle`> me using a very loose definition of "it is"
20:19:55 <hololeap> % :t NE.unfoldr
20:19:55 <yahb> hololeap: ; <interactive>:1:1: error:; Not in scope: `NE.unfoldr'; Perhaps you meant one of these: `SEq.unfoldr' (imported from Data.Sequence), `BS.unfoldr' (imported from Data.ByteString), `Seq.unfoldr' (imported from Data.Sequence); No module named `NE' is imported.
20:20:49 <hololeap> oh, no it would be more like unfoldr for a stream
20:21:25 <jle`> ah yeah, my unfoldr thing was not too accurate
20:21:59 <iqubic> Is there such a thing as an identity comonad? Can we write that?
20:22:11 <hololeap> Identity is a comonad
20:22:26 <iqubic> Right. I think that's true.
20:22:35 <hololeap> type Store s = StoreT s Identity
20:22:59 <iqubic> If you can make a lawful instance of "Adjuction f u" then f is a monad, and u is a comonad.
20:23:22 <iqubic> s/is a/can have a lawful instance of/
20:25:18 <hololeap> extract = runIdentity, duplicate = fmap Identity, extend = (Identity .)
20:25:23 * hackage wai-extra 3.0.29 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.29 (MichaelSnoyman)
20:25:48 <topos> u f will be a monad, and f u will be a comonad in Hask. For example, f ~ (,) s -| u ~ (->) s. u f ~ forall a. s -> (s, a) (i.e .State), and f u ~ (s, s -> a) (i.e. Store)
20:26:42 <topos> or rather, `Compose u f`, and `Compose f u` in haskellese
20:27:04 <hololeap> heh  Adjunction Identity Identity
20:27:32 <jle`> so clean
20:30:33 <jle`> ooh i totally forgot about Representable (Cofree u)
20:30:53 <jle`> this jives pretty well with the idea of Cofree ((->) r) as a moore machine
20:31:35 <jle`> since it is like a fundamental moore machine operation
20:31:51 <jle`> foldMoore :: Moore r a -> [r] -> a
20:32:16 <jle`> and that's exaclty index :: Cofree ((->) r) -> Seq r -> a
20:32:28 <jle`> i wonder why Rep for Cofree u is Seq and not []
20:32:50 <jle`> it feels like it's to disallow infinite indices but i don't see why those would be outlawed
20:33:16 <hololeap> maybe it has to do with efficiency
20:34:27 <jle`> hm. i feel like using list is faster, because the main operation is uncons. but they have the same asymptotics
20:35:51 <hololeap> tabulate f = f Seq.empty :< tabulate (\k -> tabulate (f . (k Seq.<|)))
20:36:18 <jle`> ah, faster tabulate
20:36:20 <hololeap> can't grok...
20:36:45 <jle`> oh wait, that tabulate would be pretty fast with list too
20:38:25 <jle`> hololeap: are you familiar with tabulate/representable in general?
20:39:34 <hololeap> more or less, yeah
20:40:44 <jle`> Cofree is sort of like a rose tree so the list is sort of 'which path to go down'
20:40:55 <jle`> for example an index into a rose tree is a list of int's
20:41:10 <jle`> the first int is which first branch to go down to, the second int is which second branch to go down to, etc.
20:41:55 <jle`> and so the reverse, tabulate, is re-populating a rose tree from an ([Int] -> a)
20:42:17 <jle`> um that made a lot more sense in my head before i typed it out
20:42:24 <hololeap> hmm
20:42:28 <jle`> it might be easier to write it out using list instead of seq
20:42:40 <jle`> tabulate f = f [] :< tabulate (\k -> tabulate (f . (k:)))
20:42:42 <hololeap> the Representable i'm most familiar with is Data.Vector.Sized
20:42:57 <jle`> ah yeah. i guess i should also ask, how familiar are you with Cofree
20:43:13 <jle`> or also a rose tree like from Data.Tree from containers
20:44:15 <hololeap> i'm fairly familiar with it
20:44:24 <jle`> so for a rose tree, [] would be an index to the root, [0] would be an index to child #0 of the root, [4,2] would be an index to child #2 of child #4 of the root
20:45:09 <jle`> and so to reach the item indicated by [x,y,z,a,b,c], you would (1) index into child #x, (2) index into that node's child #y, (3) index into that node's child #z ... etc.
20:45:19 <hololeap> oh, ok. i've made a trie using something like that
20:45:21 <jle`> so you can represent an index into a rose tree as a list of int's
20:45:44 <jle`> that's what is going on here, where `Cofree f` is a rose tree over functor f.  `Cofree []` is exactly a normal rose tree
20:46:29 <jle`> so to tabulate, you basically get a (Index -> a) function, and then you have to build the tree that that function represents.  the value at index [] is given by `f []`, the location at index `[x,y]` is given by `f [x,y]`, etc.
20:46:57 <jle`> so if you want to tabulate, you want to first ask, "what is the value at the tippy top?", and that's `f []`, since the index of the tip top root is []
20:48:28 <jle`> and then if you want to ask what the sub-tree #x is, it's tabulate (f . (x:))
20:51:18 <hololeap> jle`: doesn't quite make sense yet, but it helps
20:51:32 <hololeap> is that `f` a function or a functor?
20:51:39 <jle`> f is the (Index -> a) function
20:51:41 <hololeap> in your explaination
20:52:57 <hololeap> tabulate @(Cofree (Vector _))
20:53:07 <hololeap> :: KnownNat w => (Seq (Finite w) -> a) -> Cofree (Vector w) a
20:53:16 <jle`> ah, yeah.
20:53:36 <jle`> so in that case f :: [Finite w] -> a
20:54:24 <jle`> and so if you want to ask "what item should be at index i?" we ask by using `f i`
20:55:12 <hololeap> jle`: yeah that makes sense
20:55:22 <jle`> so if we want to ask "what item should be at the root?" -- well, the root has index []. so we use `f []`
20:56:08 <hololeap> the implementation still boggles me slightly, but at least i get the concept
20:56:50 <jle`> hololeap: let's say then you want to build subtree #0 of the root
20:56:55 <iqubic> I've only used tabulate with Data.Linear to get a list lenses.
20:58:02 <jle`> hololeap: in that case maybe you can see that that is `tabulate (f . (0:))`
20:58:47 <jle`> and the subtree #1 is tabulate (f . (1:)), etc.
20:58:59 <jle`> or tabulate (\subIndex -> f (0:subIndex))
20:59:11 <jle`> tabulate (\subIndex -> f (1:subIndex))
20:59:50 <iqubic> That's interesting.
20:59:54 <hololeap> ok, sure that makes sense
20:59:59 <iqubic> It's like generic on steroids.
21:00:11 <jle`> ah, it's also confusing because tabulate is used with different instances twice
21:00:34 <jle`> tabulate f = f [] :< tabulate @f (\k -> tabulate @(Cofree f) (f . (k:)))
21:01:21 <jle`> so if used with sized vectors that's tabulate f = f [] :< V.generate (\i -> tabulate (f . (i:)))
21:02:17 <jle`> aka "the subtree at index i is tabulate (f . (i:))"
21:03:03 <hololeap> oh, yeah that helps :)
21:03:31 <hololeap> i think that's what was confusing me
21:27:37 <hololeap> let f = tabulate (\s -> case s of ; Empty -> mempty ; (a :<| x) -> a <> f x) in f
21:27:47 <hololeap> :: Monoid a => Seq a -> a
21:28:06 <hololeap> so basically mconcat for Seq
21:29:28 <hololeap> that's about all i can come up with for a use of tabulate for ((->) a)
21:30:51 <hololeap> oh, if the monoid is (Seq a), then it would be concat for Seq
21:31:44 <hololeap> index @((->) _) :: (w -> a) -> w -> a
21:31:50 <hololeap> lol
21:32:04 <hololeap> doesn't seem super useful
21:34:06 <hololeap> something something monoids and comonoids
21:34:26 <iqubic> comonoids don't exist do there?
21:34:38 <hololeap> i remember hearing that a comonoid in Hask is basically id
21:35:01 <hololeap> they do but they're not useful in Set/Hask
21:35:19 <hololeap> a comonad is a comonoid in the category of endofunctors
21:40:58 <jle`> iqubic: comonoids exist
21:41:24 <jle`> it's just monoids but you flip the arrows
21:41:48 <dsal> Does that mean instead of <>, you use <>
21:42:09 <jle`> so instead of `mempty :: () -> m` and `mappend :: (m, m) -> m`, you have `comempty :: m -> ()` and `comappend :: m -> (m, m)`
21:42:26 <jle`> with the backwards laws
21:42:30 <alc> how I can get the index of an element in the list? like the index is 3 that '1' in "ab21"
21:42:48 <jle`> > '1' `elemIndex` "ab21"
21:42:50 <lambdabot>  Just 3
21:43:09 <hololeap> % :t id &&& id
21:43:09 <yahb> hololeap: b -> (b, b)
21:43:16 <alc> jle`: what about the index is from right to left, not left to right?
21:43:29 <dsal> alc: You probably don't want to be using a list in that case.
21:43:30 <alc> then index is 0, '1' in "ab21"
21:43:43 <hololeap> bam, comonoid 8)
21:43:46 <jle`> yea lists aren't a good type for storing items
21:43:59 <alc> dsal: yes, I do, 'cause number 1234, we do right to left
21:44:11 <dsal> 1234 isn't a list.
21:44:13 <hololeap> % :t const ()
21:44:13 <yahb> hololeap: b -> ()
21:44:19 <alc> 4x10^0 + 3x10^1 ...
21:44:33 <jle`> 1234 is a number, not a list
21:44:36 <alc> dsal: [1,2,3,4] is
21:44:38 <hololeap> so, yeah, comonoids are only useful to think about in other categories
21:44:47 <jle`> alc: the point is that don't use a list if you want to find index from the end
21:44:53 <jle`> alc: use a different data structure
21:44:53 <dsal> alc: right, and ^^ that
21:45:02 <jle`> alc: alternatively you can just subtract it from the lenght :)
21:45:42 <dsal> length is O(n), so just knowing how far it is from the right side means finding the right side.
21:45:53 <alc> jle`: dsal there's a list [3,2,1] I need to turn it to [300,20,1]
21:45:55 <jle`> yeah, you have the same asymptotics so no big deal
21:46:48 <jle`> hololeap: wait but make sure it follows the laws ;)
21:46:57 <dsal> @where xy
21:46:57 <lambdabot> http://xyproblem.info/
21:47:26 <hololeap> what would the laws be for comonoids?
21:47:48 <jle`> the same laws but backwards
21:49:53 <hololeap> m -> (m -> (), m) ===
21:50:03 <hololeap> not sure how to invert the identity law
21:50:23 <hololeap> law(s)
21:51:16 <hololeap> i suppose (m -> (m -> (), m)) is isomorphic to m
21:51:24 <iqubic> What are we doing here?
21:51:25 <hololeap> or id...
21:52:13 <hololeap> idk
21:54:06 <hololeap> this is interesting: https://en.wikipedia.org/wiki/File:Monoid_comonoid_laws.svg
21:54:58 <hololeap> i suppose the bottom row would be for commutative (co)monoids
21:56:46 <hololeap> i still don't know how to translate that into analog laws for haskell's monoid
21:57:32 <jle`> hololeap: it's first comempty . comappend == second comempty . comappend == id
21:58:51 <jle`> hololeap: well, assuming ((),m) ~ (m,()) ~ m
21:59:06 <hololeap> (m -> ((), m)) ~ (m -> (m, ())) ~ (m -> m)
21:59:16 <hololeap> something like that
21:59:30 <jle`> well, it's not that the types are isomporphic
21:59:31 <hololeap> this feels pointless somehow... ;)
21:59:34 <jle`> it's that the functions are equal
22:12:07 <alc> is there a function can do [100,20,3] -> [(100,"C"), (20,"XX"), (3,"III")] -> "CXXIII"
22:14:52 <alc> liftA2 f [100,20,3] [(100,"C"), (20,"XX"),(3,"III")]
22:15:05 <jle`> what are the inputs/outputs of that?
22:15:39 <alc> input [100,20,3] and [(100,"C"), (20,"XX"), (3,"III")]  output "CXXIII"
22:15:55 <jle`> f _ xs = map snd xs
22:16:05 <jle`> er, concatMap snd
22:16:22 <jle`> > concatMap snd [(100,"C"), (20, "XX"), (3, "III")]
22:16:23 <lambdabot>  "CXXIII"
22:18:33 <alc> jle`: find the key in [100,20,3] then get the value in [(100,"C")...]
22:18:48 <alc> it's a Data.Map
22:21:05 <jle`> which one is a map?
22:21:18 <jle`> the list of tuples?
22:21:57 <iqubic> The list of tuples is the sort of thing you'd get from the Show instance of a Map.
22:22:52 <hololeap> \indices myMap -> indices >>= (myMap !)
22:23:03 <hololeap> % :t (!)
22:23:03 <yahb> hololeap: Ix i => Array i e -> i -> e
22:23:03 <iqubic> alc: Why do you think you need to use liftA2 here?
22:23:14 <iqubic> That type is a lie.
22:23:20 <iqubic> % :t (M.!)
22:23:20 <yahb> iqubic: Ord k => M.Map k a -> k -> a
22:23:35 <hololeap> % :t \indices myMap -> indices >>= (myMap M.!)
22:23:35 <yahb> hololeap: (Monad m, Ord k) => m k -> M.Map k (m b) -> m b
22:24:03 <jle`> % :t \indices myMap -> concatMap (myMap M.!) indices
22:24:04 <yahb> jle`: (Foldable t, Ord k) => t k -> M.Map k [b] -> [b]
22:24:11 <hololeap> right...
22:25:14 <hololeap> % :t (\indices myMap -> indices >>= (myMap M.!)) :: [Int] -> Map Int String -> String
22:25:14 <yahb> hololeap: ; <interactive>:1:57: error:; Not in scope: type constructor or class `Map'; Perhaps you meant `M.Map' (imported from Data.Map)
22:25:20 <hololeap> % :t (\indices myMap -> indices >>= (myMap M.!)) :: [Int] -> M.Map Int String -> String
22:25:21 <yahb> hololeap: [Int] -> M.Map Int String -> String
22:28:02 <hololeap> alc, so you could use ((myMap M.!) =<< indices) or ((myMap M.!) `concatMap` indices)
22:28:53 <MarcelineVQ> if I asked the above question these answers would be very confusing to me ^^;
22:29:09 <jle`> % :t \indices myMap -> [ x | i <- indices, c <- myMap M.! i ]
22:29:09 <yahb> jle`: ; <interactive>:1:21: error: Variable not in scope: x
22:29:15 <jle`> % :t \indices myMap -> [ c | i <- indices, c <- myMap M.! i ]
22:29:15 <yahb> jle`: Ord k => [k] -> M.Map k [a] -> [a]
22:31:37 <hololeap> alc, are you confused about our answers?
22:42:56 <alc> hololeap: yes, I'm confused
22:43:22 <alc> @let l1 = [100,20,3]
22:43:24 <lambdabot>  Defined.
22:44:09 <alc> @let m1 = [(20,"XX"), (100,"M"), (3,"III"), (5,"V")]
22:44:10 <lambdabot>  Defined.
22:45:15 <alc> jle`: m1 is a map 
22:45:44 <dsal> m1 would be a map if you defined it with M.fromList
22:45:56 <alc> dsal: ok
22:46:32 <dsal> @unlet m1
22:46:32 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
22:46:44 <dsal> @undefine m1
22:46:44 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
22:46:48 <dsal> Damnit
22:47:25 <alc> @let m2 = M.fromList m1
22:47:27 <lambdabot>  Defined.
22:47:29 <dsal> Heh
22:47:40 <jle`> > m2 M.! 20
22:47:42 <lambdabot>  "XX"
22:47:55 <jle`> > map (m2 M.!) [20,3,5]
22:47:57 <lambdabot>  ["XX","III","V"]
22:48:02 <jle`> > concatMap (m2 M.!) [20,3,5]
22:48:04 <lambdabot>  "XXIIIV"
22:48:46 <alc> jle`: you're right, no need for liftA2
22:49:05 <alc> I always thought that if a function take two parameter, we need liftA2
22:49:13 <alc> 'cause fmap's f just take one
22:49:18 <dsal> @src liftA2
22:49:18 <lambdabot> liftA2 f a b = f <$> a <*> b
22:49:22 <alc> I forget currying
22:49:24 <jle`> > liftA2 (M.!) [20, 3, 5] [m2]
22:49:27 <lambdabot>  error:
22:49:27 <lambdabot>      • Could not deduce (Ord k0)
22:49:27 <lambdabot>        from the context: (Ord k, Num k,
22:49:36 <jle`> > liftA2 (M.!) [m2] [20, 3, 5]
22:49:39 <lambdabot>  ["XX","III","V"]
22:49:57 <iqubic> :t liftA2
22:49:59 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:50:23 <iqubic> LiftA2 is only needed if both arguments are functors.
22:50:28 <dminuoso_> jle`: Heh.. regarding that `foldr (.) id` instead of `getApp . foldMap Endo` - I'm a bit torn about this.
22:50:50 <jle`> dminuoso_: are you similarly torn about foldr (+) 0 vs. sum vs. getSum . foldMap Sum? ;)
22:51:21 <jle`> s/foldr/foldl'
22:51:24 <alc> what about liftF2 and liftM2?
22:51:34 <jle`> alc: what about them?
22:51:36 <hololeap> > map (m2 M.!) [20,3,5]
22:51:37 <dminuoso_> jle`: Strictly speaking? Yes
22:51:39 <lambdabot>  ["XX","III","V"]
22:51:45 <alc> jle`: they're used for what
22:51:58 <hololeap> > concat (map (m2 M.!) [20,3,5])
22:52:01 <lambdabot>  "XXIIIV"
22:52:03 <dminuoso_> jle`: The foldMap makes the monoid a bit more explicit, foldr makes no guarantee about the laws.
22:52:12 <jle`> liftM2 is mostly useful if you don't want to define liftA2 yourself
22:52:24 <jle`> if you are in charge of writing an Applicative instance for a type
22:52:25 <hololeap> @src concatMap
22:52:25 <lambdabot> concatMap f = foldr ((++) . f) []
22:52:36 <hololeap> ... that's not very helpful
22:52:37 <alc> I never saw people use liftF2 yet
22:52:38 <jle`> so it's really only useful for a library developer's point of view, or if you are writing a typeclass instance
22:52:44 <dminuoso_> jle`: Though I might perhaps write something like `let compose = appEndo . foldMap Endo in ...`
22:52:51 <alc> liftA2 is so popular
22:52:54 <jle`> for the end-user level liftM2 has no purpose
22:53:05 <iqubic> Not really? liftA2 isn't that popular.
22:53:26 <alc> iqubic: but I saw a lot...
22:53:45 <jle`> alc: liftF2 is only useful if you have an instance of Apply that is not an instance of Applicative
22:54:02 <jle`> so for example `Map k` you can use liftF2 but not liftA2
22:54:09 <dminuoso_> jle`: The thing is, foldMap lets me think more in declarative terms, while foldr has more small-step/imperative semantics
22:54:12 <alc> > (,) <$> "abc" <*> "123"
22:54:14 <lambdabot>  [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...
22:54:25 <alc> > liftA2 (,) "abc" "123"
22:54:29 <lambdabot>  [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...
22:54:43 <dminuoso_> If you like liftA2, use it. If you prefer <$> and <*>, use that.
22:55:09 <dminuoso_> liftA2 is certainly not unpopular.
22:55:20 <jle`> dminuoso_: i would say foldr is just as declarative, but foldl is the imperative semantics one. but still i guess in this case it depends on if you care about associativity or not
22:55:36 <hololeap> `liftA2 f a b` looks cleaner than `f <$> a <*> b`
22:55:37 <iqubic> foldl is awesome.
22:55:49 <jle`> dminuoso_: i would argue in your case, caring about associativity doesn't really gain you much does it? all you need to know is you want to (.) with id
22:56:02 <jle`> since you know exactly what you want to do already
22:56:24 <jle`> using foldMap and caring about associativity is useful if you are dealing with a polymorphic function over different monoids
22:56:28 <hololeap> but `f <$> g a b <*> h c d` looks cleaner than `liftA2 f (g a b) (h c d)`
22:56:34 <hololeap> (just my opinion)
22:56:37 <jle`> so foldMap f is nicer than foldr .. ... in that case maybe
22:56:54 <jle`> but in this case you're directly using (.) id, you're not using (.) and id because they're associative -- you're using them because they give you waht you want
22:57:08 <jle`> dminuoso_: for example, even if (.) and id weren't associative, you'd still be using them
22:57:19 <jle`> their associativity isn't what you are using, their meaning is what you are using
22:57:20 <dminuoso_> jle`: I understand your point
22:57:33 <iqubic> Isn't foldMap just "foldr ((<>) . f) mempty xs"
22:57:53 <dminuoso_> Sure
22:58:00 <jle`> same for like foldr (+) 0 --- i don't care if (+) is associative or not, i just care that i want to add everything up from back to front :) although 'knowing' it's associative means i can pick between foldr and foldl i suppose
22:58:08 <dminuoso_> At least that is what it defaults to, if an instance does not specialize it.
22:58:29 <iqubic> I just realized that foldMap and concatMap do the same thing, but one is more general. Just like map and fmap, and (++) and (<>)?
22:58:50 <iqubic> Why are concatMap, map, and (++) things?
22:58:54 <dminuoso_> jle`: I suppose the annoying thing about foldMap is having to unwrap the result. There's this extra bit of noise you can't get rid of.
22:59:12 <dminuoso_> No matter whether you explicitly unwrap, coerce or use ala, you have to use *something*
22:59:14 <hololeap> iqubic: concatMap = (=<<)
22:59:18 <dminuoso_> hololeap: No
22:59:23 <iqubic> Also, for lists, concatMap, foldMap and (>>=) all do the same thing.
22:59:29 <iqubic> And I just now realized this.
22:59:59 <hololeap> % :t concatMap
22:59:59 <yahb> hololeap: Foldable t => (a -> [b]) -> t a -> [b]
23:00:05 <jle`> well, foldMap is more general so i would say it does a little more for lists. but yeah, concatMap is the same as (=<<) for lists
23:00:06 <dminuoso_> hololeap: Semantically, perhaps. But you get fusion for free along the way because it uses church lists internally
23:00:15 <jle`> :t [(=<<), concatMap, foldMap]
23:00:17 <lambdabot> [(a -> [b]) -> [a] -> [b]]
23:00:32 <hololeap> wtf did you just do, jle` ?
23:00:38 <jle`> i put them all in the same list
23:00:47 <dminuoso_> hololeap: It's a trick to unify two things.
23:00:47 <hololeap> oh i see
23:00:47 <jle`> to 'prove' that they all have the same type
23:00:53 <monochrom> use homogeneous list to unify types :)
23:01:08 <hololeap> that's a neat trick
23:01:09 <iqubic> That's a clever trick.
23:01:49 <dminuoso_> hololeap: The way I read the sources, concatMap is specialized for lists in ways that the [] instance for Monad is not
23:02:07 <dminuoso_> Unless list comprehensions desugar into usages of `build`
23:02:13 <qualiaqq> I just realized the other day that (>>) and (*>) are the same except (*>) works with Applicatives instead of Monads.
23:02:16 <monochrom> "A boy, a wolf, and a goat are on the same boat..."  "OK so this is a mammal boat" :)
23:02:27 <hololeap> dminuoso_: so you're saying use concatMap when i can? i've been using (=<<) for lists
23:02:55 <monochrom> "but wait, there is also a carrot"  "fine, carbon-based life forms then"
23:04:02 <dminuoso_> hololeap: Actually I just found it in the ghc sources. =<< is implemented with list comprehensions, and list comprehensions end up using concatMap. :)
23:04:11 <iqubic> lol.
23:04:12 <dminuoso_> hololeap: TIL. So you are already getting list fusion
23:04:14 <MarcelineVQ> monochrom: or, a boat is any small platform capable of holding a boy a goat and a wolf
23:04:25 <monochrom> "the boy is using a half-plastic, half-silicone container for the carrot"  "ha, I knew it!  But we're still in period IV."
23:05:23 <hololeap> i kinda figured :) glad ghc is intuitive
23:06:12 <hololeap> but does foldMap use concatMap behind the scenes?
23:06:26 <jle`> foldMap cannot, it is more general
23:06:30 <jle`> unless you use RULES or something
23:06:35 <monochrom> It has to do arbitrary monoids.
23:07:18 <jle`> but it can still be smart with streaming/fusion
23:07:25 <jle`> it just can't use concatMap
23:07:49 <hololeap> right...
23:23:56 <hololeap> has anyone ever heard of a representable functor over a kleisli category? they could be useful
23:26:02 <hololeap> for instance, carrying the size of a vector in a Reader instead of at the type level
23:26:20 <dminuoso_> hololeap: Yes. There was a reddit posting by someone named hololeap on reddit a while ago!
23:26:58 <hololeap> wow i'm surprised anyone saw/remembers that ... o_O
23:27:42 <dminuoso_> No, but 4 seconds of googling quickly revealed it. ;)
23:27:43 <hololeap> unless you just looked it up <_<
23:30:03 <MarcelineVQ> hololeap: what would doing that gain you?
23:30:46 <dminuoso_> hololeap: Aren't representable functors limited to functors `f : C^op -> Set` that are naturally isomorphic to Hom_C(-,X)?
23:31:18 <dminuoso_> hololeap: I mean they wouldn't be representable anymore if you replaced Set with something else. 
23:32:01 <hololeap> they're isomprhic to the hom-functor. index and tabulate witness that isomorphism
23:32:56 <dminuoso_> hololeap: Well yes, but what does "representable over a kleisli category" even mean?
23:33:46 <iqubic> I'm having a blast reading Bartosz Milewski's blog posts on repersentable functors and adjunctions.
23:33:55 <alc> -- f5 [1,2,3] = [100,20,3]
23:34:02 <alc> f5 x = if (Data.List.null []) then [] else ((head x) * (10 ^ ((length x) - 1)) :[]) <> f5 (tail x)
23:34:21 <alc> f5 [1,9,9,0] == [] where it's wrong?
23:34:27 <dminuoso_> Or are you talking about presheafs from a kleisli category?
23:34:30 <hololeap> indexM :: f a -> Rep f -> m a ; tabulateM :: (Rep f -> m a) -> m (f a)
23:34:31 <MarcelineVQ> null []  is always True
23:34:35 <alc> it suppose to be [1000,900,90,0]
23:34:45 <hololeap> i'm not sure what the technical term for this is
23:35:06 <alc> ...
23:35:13 <alc> it should be null x
23:35:59 <dminuoso_> alc: Also, use pattern matching.
23:36:08 <dminuoso_> alc: Using null/head/tail is just code smell that is completely avoided by pattern matching. :)
23:37:24 <alc> dminuoso_: but f5 [] = [] will make timeout in ghc 7.10
23:37:41 <dminuoso_> alc: then you likely have a different issue
23:38:13 <MarcelineVQ> such as doing this in ghci and overwriting your last defintion when you make the 2nd case for f5
23:38:20 <alc> dminuoso_: I'm doing some homeworks on codewars, and they use old ghc...
23:38:33 <dminuoso_> alc: You misunderstand, the GHC version is not the problem.
23:38:40 <dminuoso_> alc: You made some other mistake, causing the timeout.
23:39:26 <alc> f5 x = [(head x) * (10 ^ ((length x) - 1))] <> f5 (tail x)
23:39:30 <alc> f5 [] = []
23:39:52 <alc> not equal to f5 x = if (Data.List.null x) then [] else [(head x) * (10 ^ ((length x) - 1))] <> f5 (tail x)?
23:40:02 <dminuoso_> alc: There's so much wrong with that :)
23:40:29 <iqubic> ghci is a pile of lies.
23:40:37 <MarcelineVQ> you want your more specific cases first so   f5 [] = [] should come first, and since we're matching [] you want to pattern match x into  (x:xs)   x is the head, xs is the tail
23:40:50 <dminuoso_> alc: First step, don't take the length of your sub-lists over and over again. You will get n! asymptotics with that.
23:40:59 <MarcelineVQ> 'timeout' isn't a ghc thing in the first place. sounds like it's taking too long and codewars isn't liking that
23:41:02 <alc> MarcelineVQ: I thought order doesn't matter... I'm wrong
23:41:06 <dminuoso_> Or.. no. Something like n^2, but still bad
23:41:12 <MarcelineVQ> nah it matters
23:41:27 <dminuoso_> alc: Next up, don't build lists with <>, it's highly inefficient. Stream them with (:) instead
23:41:40 <MarcelineVQ> patterns go from left to right and top to down
23:42:12 <hololeap> iqubic: it's been fixed up and put into a pdf, just fyi:  https://github.com/hmemcpy/milewski-ctfp-pdf/releases
23:42:14 <alc> > [3] : [5]
23:42:16 <lambdabot>  error:
23:42:16 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_135’
23:42:16 <lambdabot>      • In the expression: e_135
23:42:24 <dminuoso_> alc: Try `3 : [5]` :)
23:42:36 <hololeap> he also has a video series on it
23:42:59 <dminuoso_> alc: `[a] <> b` is just terribly inefficient because it requires going over the entire list to the right.
23:43:13 <MarcelineVQ> dminuoso_: ?
23:43:35 <dminuoso_> oh
23:43:41 <dminuoso_> I better stop no
23:43:42 <alc> dminuoso_: then when f [] =?
23:44:07 <alc> dminuoso_: [] <> [] is ok, [] : [] not what expect
23:45:52 <hololeap> MarcelineVQ: the main reason why i thought of it is because the Store implementation that uses a Representable is really useful, and it would be nice to have more options for what to put "inside" of it
23:47:48 <hololeap> for instance using a Map as the functor and Maybe as the monad. of course, it would have to wrap the resulting Store in Maybe as well
23:49:02 <MarcelineVQ> I don't know sotrable or representable :X I was just wondering what your example was gaining you, since type level things are for compiler enforcement and because they're erased, and vector already carries its size
23:50:54 <MarcelineVQ> *Store
23:51:27 <hololeap> the way vector-sized does it is really cool, but is creating them from a list at runtime possible?
23:51:56 <MarcelineVQ> them?
23:52:19 <hololeap> Data.Vector.Sized.Vector
23:52:36 <hololeap> Vector (n :: Nat) a
23:53:31 <hololeap> Rep (Vector n) = Finite n
23:54:04 <hololeap> but if i wanted to make a Vector with a size determined at runtime, could i do it?
23:55:30 <hololeap> a sized Vector
23:56:33 <hololeap> if not then i will have to use regular vectors and all the type safety that prevents bad index lookups will be lost
23:56:55 <hololeap> and the only way to make it safe is to have the whole thing threaded through the Maybe monad (or something similar)
23:57:40 <MarcelineVQ> I don't uh, understand the turn this conversation has taken, I don't know vector-sized, I was asking what your example gained you
23:58:09 <MarcelineVQ> since vectors carry their size already and your example was about carrying a size afaict
23:58:19 <dminuoso_> alc: : is not list concatenation, it's the list constructor.
23:58:23 <dminuoso_> % :t (:)
23:58:23 <yahb> dminuoso_: a -> [a] -> [a]
23:58:38 <dminuoso_> alc: In Haskell a list is either an empty list, or a list prepended to a list.
23:58:55 <dminuoso_> [1,2,3,4] is just syntax sugar, in truth this is 1:(2:(3:(4:[])))
23:59:11 <dminuoso_> Or, with without explicit parens: 1:2:3:4:[]
23:59:11 <alc> > [] : []
23:59:14 <lambdabot>  [[]]
23:59:34 <alc> > ([] : []) ! 0
23:59:36 <lambdabot>  error:
23:59:36 <lambdabot>      • Couldn't match expected type ‘Array Integer e’
23:59:36 <lambdabot>                    with actual type ‘[[a0]]’
23:59:44 <dminuoso_> alc: Think about what [] : [] does.
23:59:44 <hololeap> MarcelineVQ: the Vector from vector-sized has a nice, complete Representable instance, since it uses Finite as its Rep
