00:01:16 <day> subttle: searching for these operators on google is a bliss too :D
00:02:56 <subttle> day: I'm not sure I know what you meant by that, :) I did search and it came up with "multimap" for the unicode character
00:16:49 <iqubic> What did I miss here?
00:17:14 <iqubic> Why did basically everyone join #haskell all at the same time?
00:17:24 <subttle> maybe old netsplit?
00:17:38 <ammar2> yup
00:18:22 <iqubic> What's a netsplit?
00:20:37 <davve_> https://lmgtfy.com/?q=netsplit&s=&qtype=search&ovr=1
00:48:18 <iqubic> scanl has become my new favorite function.
00:49:30 <iqubic> > scanl (+) 0 [1..10] -- triangle numbers
00:49:33 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
00:59:41 <jeffhappily> Hi guys, I'm having issue with cabal's public sublibraries, an example would be this https://github.com/haskell/cabal/issues/6038 , where I have two package, one depends on the other, but when I try to build, I'm getting "Encountered missing or private dependencies: ", but I have my visibility set to true, it works fine when the dependency is the
00:59:41 <jeffhappily> main library instead of the sub library
01:01:10 <merijn> jeffhappily: iirc the solver doesn't understand sublibraries yet
01:01:42 <merijn> jeffhappily: public sublibraries is very much a "bleeding edge" (as in, you'll cut yourself :p) feature
01:02:17 <merijn> (Note that hackage also currently disallows uploading such packages)
01:02:42 <jeffhappily> I'm still very new in this, I'm assuming the solver you meant is the part of cabal that resolve dependencies?
01:03:13 <merijn> jeffhappily: Yeah
01:03:50 <subttle> iqubic: woah I feel like that should be on https://wiki.haskell.org/Blow_your_mind
01:03:52 <merijn> jeffhappily: The solver computes a build-plan that much all (transitive) dependency constraints, but I don't think any released version of cabal-install supports public sublibraries in the solver
01:04:03 <merijn> s/much/matches
01:05:15 <jeffhappily> merijn hmmm means I can export multiple libraries, but other packages can
01:05:19 <jeffhappily> can't import it
01:06:20 <subttle> iqubic: oh I guess it is, but just disguised as mapAccumL :D
01:06:35 <subttle> mapAccumL (\acc n -> (acc+n,acc+n)) 0 [1..10]
01:09:10 <merijn> jeffhappily: Well, it means they can only import it if they *also* import the main library, yes
01:09:17 <koz_> > mapAccumL (\acc n -> (acc + n, acc + n)) 0 [1..10]
01:09:19 <lambdabot>  (55,[1,3,6,10,15,21,28,36,45,55])
01:09:40 <merijn> jeffhappily: I've briefly looked into using it for a few of my own libraries, but it's not ready for prime-time yet
01:10:41 <koz_> :t mapAccumL
01:10:43 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
01:11:59 <koz_> Is that some kind of fold/scan hybrid?
01:12:17 <Solonarv> indeed it is
01:12:42 <koz_> Cool. I might have to keep it in mind for the future.
01:12:43 <Solonarv> another way of looking at it is: it's 'traverse' using State as the applicative
01:12:44 <subttle> koz_: basically it lets you thread a fold accumulator while mapping
01:14:40 <merijn> jeffhappily: Anyway, make sure to post any problems not already on the issues to the cabal repo, the more testing this stuff gets, the quicker it can be production ready :)
01:14:46 <Solonarv> mapAccumL abac a = swap . runState . traverse (State . flip abac)
01:14:55 <Solonarv>   where swap (x,y) = (y,x)
01:15:32 <Solonarv> bah, need one more 'swap' in there somewhere but you get the idea
01:15:48 <koz_> Solonarv: I get the feeling this wants to be pointfree.
01:15:52 <koz_> With like, ten more swaps.
01:15:54 <jeffhappily> merijn: I did add in main library as a dependency, eg `build-depends: d:{d, sublib}`, but I still got an error saying `cabal: Encountered missing or private dependencies:d : {d, sublib} ==0.1.0.0`
01:16:12 <Solonarv> oh, I also forgot to use 'a'
01:16:15 <merijn> jeffhappily: hmm
01:16:23 <Solonarv> but it's really just juggling argument order
01:18:03 <jeffhappily> merijn: Have you encountered that issue?
01:18:56 <merijn> jeffhappily: No, I decided that it wasn't usable enough yet to migrate to using sublibraries yet, so I haven't really used them much yet
01:20:39 <jeffhappily> merijn: or do you know any public library that exports multiple libraries, that I can try to use it as dependency, instead of a local package
01:22:59 <merijn> jeffhappily: Not really, I think? Since you can't distribute those packages on Hackage yet.
01:23:26 <merijn> jeffhappily: What are you trying to do with multiple libraries? Probably the simplest/most productive solution right now is to simply use one package per library
01:27:05 <jeffhappily> merijn: Actually I'm just trying to figure out is it just my problem, or it just doesn't work, because I can't seem to find any similar issues
01:27:35 <jeffhappily> merijn: Even the issue here https://github.com/haskell/cabal/issues/6038 says that Adding empty main library fixes it, but it doesn't work for me, not sure what I did wrong
01:29:57 <merijn> jeffhappily: Yeah, but does that fix it in HEAD or in 3.0? :)
01:30:05 <merijn> jeffhappily: Have you tried using cabal-install HEAD?
01:32:24 * hackage servant-to-elm 0.3.0.0 - Automatically generate Elm clients for Servant APIs  https://hackage.haskell.org/package/servant-to-elm-0.3.0.0 (OlleFredriksson)
01:37:38 <jeffhappily> merijn: I'm using the 3.0 version
01:40:47 <merijn> jeffhappily: Yeah, my point is that HEAD is newer and since sublibraries aren't officially supported in 3.0 yet, the question is whether the comment of "empty library fixes this" applies to 3.0 or just to HEAD
01:44:18 <jeffhappily> merijn: In 3.0, adding empty main library is fixing another issue as mentioned in the issue `Could not resolve dependencies:`, which is different from the issue I encountered when trying to have sub libraries as dependency, where I'm getting `Encountered missing or private dependencies:`
02:14:23 * hackage amrun 0.0.0.7 - Interpreter for AM  https://hackage.haskell.org/package/amrun-0.0.0.7 (OliverWestphal)
02:34:28 <olligobber> I did not know you could put let statements in do blocks... this will make my code much more readable
02:34:52 <sshine> you can! and you can omit the 'in'
02:35:06 <olligobber> uh, I tried putting the in in and it didn't work
02:35:25 <sshine> right... do-blocks are more sensitive to whitespace.
02:36:11 <sshine> so the indentation will most likely be screwy with 'in'
02:37:27 <olligobber> > do {x <- [1]; let {y = 2}; return y}
02:37:29 <lambdabot>  [2]
02:37:36 <olligobber> where would the `in' go in that?
02:38:27 <sshine> > do {x <- [1]; let y = 2 in return y}
02:38:29 <lambdabot>  [2]
02:38:41 <Taneb> The "in" breaks the do-block
02:38:45 <olligobber> ^
02:38:48 <olligobber> that's what I thought
02:39:03 <Taneb> > do {x <- [1]; let y = 2 in z <- [3]; return y}
02:39:05 <lambdabot>  <hint>:1:15: error:
02:39:05 <lambdabot>      Parse error in pattern: let y = 2 in z
02:39:05 <lambdabot>      Possibly caused by a missing 'do'?
02:39:10 <Taneb> > do {x <- [1]; let y = 2 in do {z <- [3]; return y}}
02:39:13 <lambdabot>  [2]
02:39:28 <olligobber> > do {x <- [1]; let y = 2; z <- [3]; return y}
02:39:30 <lambdabot>  <hint>:1:28: error:
02:39:30 <lambdabot>      parse error on input ‘<-’
02:39:30 <lambdabot>      Perhaps this statement should be within a 'do' block?
02:39:38 <olligobber> > do {x <- [1]; let {y = 2}; z <- [3]; return y}
02:39:40 <lambdabot>  [2]
02:46:09 <kuribas> Hi, I do "cabal v1-install typerep-map", then ghci, "import Data.TypeRepMap"
02:46:22 <kuribas> I get: Could not find module ‘Data.TypeRepMap’ It is not a module in the current program, or in any known package. 
02:46:23 * hackage structured-cli 2.6.0.0 - Application library for building interactive console CLIs  https://hackage.haskell.org/package/structured-cli-2.6.0.0 (erick)
02:46:32 <kuribas> any idea?
02:46:45 <kuribas> GHCi, version 8.4.4:
02:46:55 <merijn> kuribas: Lingering .ghc.environment file?
02:47:19 <kuribas> merijn: no
02:47:32 <kuribas> .ghc/ => ghci_history  x86_64-linux-8.4.4/
02:47:55 <kuribas> and Data.TypeRepMap => https://hackage.haskell.org/package/typerep-map-0.3.2/docs/Data-TypeRepMap.html
02:51:38 <kuribas> and cabal-install version 2.4.1.0
02:52:43 <kuribas> I even see Data.TypeRepMap  in .ghc/x86_64-linux-8.4.4/package.conf.d/typerep-map-0.3.2-LF6cgUyFZKfLcnHdbWE1tG.conf
03:20:40 <Phyx-> @tell alc cabal doesn't manage ghc installs because that's not it's job. chocolatey just allows you to install whatever version of cabal and ghc you want, and if you need msys2 and it'll configure them to work together out of the box in a sensible way
03:20:41 <lambdabot> Consider it noted.
03:24:36 <maerwald> anyone good with low-level unix programming? https://git.io/JvTaC does anything here look wrong?
03:26:24 * hackage niv 0.2.12 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.12 (nmattia)
03:27:15 <maerwald> for example, can I be sure that race terminates the dupTo loop?
03:38:57 <maerwald> also misbehaves on async exception I guess, could like file descriptors
03:43:21 <merijn> maerwald: Consult "Advanced Programming in the UNIX Environment" ;)
03:43:46 <maerwald> well, doing that in C is one thing, haskell just adds to the complexity
03:44:17 <merijn> Most of the unix wrappers are fairly direct
03:57:57 <merijn> maerwald: Why is it racing, though?
03:58:13 <merijn> That seems like a bad idea
03:58:18 <maerwald> dupTo might never terminate?
03:58:58 <maerwald> it's basically a loop without a timeout then
03:59:22 <merijn> maerwald: Why would dupTo not terminate? Like, why even loop at all?
04:00:01 <maerwald> merijn: I followed http://www.microhowto.info/howto/capture_the_output_of_a_child_process_in_c.html initiall, which seems to do that
04:00:45 <maerwald> it seems about handling interruption signal
04:00:54 <merijn> maerwald: That's utterly dumb
04:00:59 <merijn> (the post, I mean)
04:01:05 <maerwald> :>
04:01:42 <merijn> maerwald: If you're blocking inside dup2 (that's already quite unlikely, since it's not a very long lived syscall) *and* you get interrupted by a signal *and* that signal is not fatal, then you *might* fail with EINTR
04:02:27 <merijn> Also, only if the signal affects the thread running this code (and I don't know how the RTS handles signals, but I'd assume those get handled in the event loop thread and masked everywhere else)
04:02:45 <merijn> maerwald: So I would just ignore EINTR and treat it like any other failure
04:02:48 <maerwald> so just drop the block?
04:02:52 <merijn> yeah
04:03:13 <maerwald> then the subprocess dies and fds are released anyway
04:03:21 <merijn> And the person who wrote that guide *also* needs to read APUE :p
04:03:40 <merijn> maerwald: Right, upon process termination all FDs are handled anyway
04:03:45 <maerwald> well, unix is a huge time sink...
04:04:15 <maerwald> so many historical decisions no one understands anymore
04:04:31 <merijn> maerwald: why are you not using process, btw? Then you don't even need to dupTo to change the target of the subprocess' stdin/stdout/stderr
04:04:39 <maerwald> I don't like the API
04:04:44 <maerwald> and I avoid String
04:05:10 <merijn> maerwald: Hence why I keep telling everyone who won't listen to buy APUE, because it explains which parts of POSIX are historical (and why and their failure modes) and what the right way of doing things is :p
04:06:30 <Athas> Wait, can dup2() practically fail with EINTR?
04:06:39 <Athas> I know that in principle everything can, but really now.
04:07:46 <maerwald> the manpage documents it :P
04:08:04 <merijn> Athas: I doubt it
04:08:20 <merijn> Athas: It's not even everything, really only some blocking calls can
04:08:49 <merijn> maerwald: Yeah, but the fix is more likely to break than EINTR is to break your code
04:09:11 <maerwald> it's probably similar to handling malloc failure explicitly
04:09:14 <merijn> maerwald: And I doubt this code is so crucial that if it ever fails through sheer bad luck that it'll cost any lives
04:09:28 <maerwald> I was about to integrate it into an airplane...
04:09:33 <phadej> maerwald: there are cases where malloc can fail and you can recover from it
04:09:38 <merijn> maerwald: honestly, this is even less likely to occur, imo (unless on linux, since linux never fails malloc)
04:09:40 <phadej> or at least fail more gracefully
04:10:55 <phadej> though I don't know what linux malloc does if you try to allocate 1TB
04:11:21 <merijn> phadej: It works, until you try to access to many pages, because infinite overcommit is a great idea!
04:11:21 <dmj`> only one way to find out
04:11:36 <maerwald> last time we saw dmj`...
04:12:14 * dmj` explodes
04:12:40 * maerwald catches a few exceptions, but misses another one
04:12:49 <phadej> merijn: yeah, not great
04:13:09 <phadej> merijn: IIRC in C++ you can at least have different allocators
04:14:52 * dmj` wonders if TB actually means time bomb
04:15:06 <phadej> https://stackoverflow.com/questions/48585079/malloc-on-linux-without-overcommitting e.g. has sad answer, "let the administrator worry if they have high memory pressure"
04:15:57 <merijn> The BSD have a configurable fixed overcommit percentage after which malloc will start returning NULL
04:16:06 <merijn> Usually 150% or so, I think
04:17:06 <phadej> I'd really expect that trying to allocate 1terabyte would fail on my system
04:17:20 <phadej> regarding of any overcommitting settings
04:17:58 <phadej> though, GHC seems to allocate exactly 1TB on startup
04:18:29 <phadej> because continuous memory is nice for heap stuff
04:18:59 <phadej> otoh, valgrind doesn't like that
04:22:02 <kuribas> merijn: https://gist.github.com/kuribas/912a0ae651dea30828e295ce2d82b14f
04:22:14 <kuribas> the output of ghc Test.hs -v
04:22:59 <dmj`> phadej: that's 1TB of virtual memory and its a bug afaik, not indicative of resident memory
04:23:15 <merijn> phadej: GHC doesn't allocate 1TB on startup, though
04:23:24 <merijn> dmj`: It's not a bug, it's by design
04:23:35 <merijn> dmj`: But top is stupid/doesn't show what people think it does
04:23:52 <phadej> yes, I'm not sure what the right term is
04:24:03 <dmj`> merijn: yea, it's top's problem
04:24:11 <merijn> phadej: It reserves 1 TB via mreserve
04:24:29 <merijn> So I'd go with "reserve" 
04:24:54 <merijn> dmj`: I mean, top's not even wrong, top just doesn't show what people think it does, but nothing will fix people making stupid assumptions
04:25:18 <kuribas> strings /home/kristof/.ghc/x86_64-linux-8.4.4/package.conf.d/package.cache | grep Data.TypeRepMap => Data.TypeRepMap ...
04:25:29 <kuribas> so it's there ...
04:26:02 <dmj`> merijn: ok
04:27:29 <merijn> dmj`: i.e. the column shows virtual address space usage, but that doesn't track actual memory usage, of course it also has a resident set tracker, but most people don't look at that, because the column naming is "weird"
04:28:21 <phadej> i still find it unsatisfactory that there's no OS support to processes to negotiate their resource needs
04:28:26 <dmj`> RES = resident, VIRT = virtual
04:28:31 <dmj`> merijn: oh, maybe I'm thinking of htop
04:28:41 <phadej> thus resulting in either overcommitting or underusages
04:28:55 <__monty__> So MEM/%MEM isn't what you should look at if you want to snipe memory hogs?
04:29:53 <merijn> __monty__: Well, you definitely *don't* want to look at VIRT
04:30:09 <merijn> RES is probably the best to look at
04:30:17 <phadej> __monty__: %MEM is RES/all memory
04:30:21 <phadej> so it's reasonable percentage
04:30:27 <merijn> Because it shows how much RAM a program *actually* needs/uses
04:30:59 <phadej> but it's also not so simple, because there's SHR too :)
04:31:01 <merijn> If a program has several (tens of) gigabytes but it's almost all swapped out, that's fine
04:31:39 <phadej> though that is usually quite big
04:33:19 <__monty__> SHR?
04:33:43 <arw> shared memory. 
04:34:19 <merijn> I don't have these 64bit machines just to not use all that extra address space I used for! >.>
04:34:42 <kuribas> anyone?  No wonder people say tooling of haskell is shit
04:35:51 <merijn> kuribas: Wait, you just run "ghc" without any extra flags?
04:36:05 <merijn> kuribas: You need to tell it which package database/packages to use
04:36:12 <arw> merijn: VIRT is interesting in some cases, together with something that nothing will display: pagetable fragmentation is a headache for the OS performance.
04:36:36 <kuribas> merijn: that always worked before
04:36:43 <arw> merijn: and pagetables are limited in size, and depth makes things slow, which is why there is stuff like hugetable support
04:36:52 <arw> err, hugepage
04:37:35 <merijn> kuribas: Ah, no, it's still loading the default database
04:38:08 <__monty__> kuribas: It always worked and this once it doesn't and therefore you conclude haskell tooling is shit?
04:38:08 <merijn> But then you still need -package typed-map, I think?
04:38:47 <merijn> Also, I'd say this is an example of "lack of haskell tooling is shit", since they take care of managing those packages for you :p
04:39:08 <kuribas> merijn: ah that works
04:39:41 <kuribas> merijn: it always worked before.  If I installed a global package with cabal, I could access it in ghci
04:39:43 <merijn> kuribas: I honestly don't recall whether GHC ever allowed you to use dependencies without -package, because I've always just used cabal-install
04:40:10 <kuribas> merijn: so I did it wrong always, and now they stopped supporting it?
04:40:55 <kuribas> merijn: so it means I cannot experiment without creating a .cabal file?
04:41:22 <merijn> You can use .ghc.environment to bring stuff into scope for ghci if you want
04:41:36 <merijn> I don't know if they stopped supporting it or whatever
04:41:54 <dmj`> kuribas: does ghc-pkg list show more than one ghc-pkg list ?
04:41:57 <merijn> Because, as I mentioned, I have never used ghc that way
04:41:59 <maerwald> what's a reasonable checked exceptions library. I see there is the well-typed blog post, safe-exceptions-checked, control-monad-exception, the unpublished exceptions-checked and there is ExceptS from haskus-utils-variant
04:42:20 <merijn> maerwald: imo, none
04:42:22 <dmj`> kuribas: haskell tooling is great if you don't use any of it and just use nix and runghc
04:42:30 <kuribas> merijn: yes
04:42:39 <merijn> Until exceptions are reworked I don't think there can be a reasonable checked exceptions lib
04:43:05 <kuribas> dmj`: /home/kristof/.ghc/x86_64-linux-8.4.4/package.conf.d and /opt/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d
04:43:19 <dmj`> kuribas: that's the only one?
04:43:26 <dmj`> ah, there's two
04:43:42 <kuribas> dmj`: well, opt comes first
04:44:01 <dmj`> maybe remove that one... probably comes from your system pkg manager
04:44:42 <kuribas> dmj`: ghci is in /opt/ghc/bin/ghci
04:44:50 <dmj`> multiple ghc-pkg lists is problematic
04:44:54 <kuribas> dmj`: it's a linux mint package
04:44:54 <dmj`> kuribas: how did you install ghc?
04:45:00 <kuribas> dmj`: apt-get
04:45:07 <dmj`> kuribas: never use your systems package mgmt to install haskell stuff
04:45:16 <dmj`> kuribas: unless you're on NixOS
04:45:19 <kuribas> dmj`: with hvr ppa
04:45:23 <kuribas> dmj`: how else?
04:45:38 <dmj`> kuribas: ghc-up, stack, or just get the bin dist raw, or nix
04:45:49 <dmj`> https://www.haskell.org/ghcup/
04:46:01 <dmj`> personally, I'd only ever use nix w/ haskell, and nothing else
04:47:24 <kuribas> dmj`: no system wide ghc?
04:47:30 <dmj`> kuribas: I'm against it
04:47:32 <kuribas> I don't want to change OS just for haskell
04:47:45 <dmj`> kuribas: you can use nix on linux mint
04:47:46 <Cale> nix isn't an os, nixos is
04:47:55 <kuribas> ah :)
04:48:06 <dmj`> can slowly wade into the pool
04:48:45 <merijn> I use a system wide GHC, but only the ones I install myself from binaries :p
04:49:10 <merijn> Nix requires root though, so that ruins like 90% of its usefulness for me
04:51:31 <maerwald> isn't there a way to have nix on user-level only?
04:52:00 <Solonarv> I vaguely recall seeing that this is *possible*, but has some issues
04:52:06 * earthy nods
04:52:21 <merijn> Solonarv: You can use non-root Nix, but not with the default binary distribution
04:52:23 * hackage asif 6.0.4 - Library for creating and querying segmented feeds  https://hackage.haskell.org/package/asif-6.0.4 (arbornetworks)
04:52:39 <earthy> there's no requirement for nix's formulae to have root, but there's dependencies that do require it and you'd have to replace
04:52:47 <merijn> Solonarv: So bootstrapping a non-root Nix involves...manually downloading, building, and installing all of Nix's 17 or so dependencies
04:52:51 <merijn> (from source)
04:53:05 <Solonarv> anyway, I find ghcup to be a very nice middle ground: it saves the hassle of juggling binaries manually, but it is still very transparent
04:53:10 <merijn> Which is more work than installing the 5 or so dependencies I actually need by hand myself
04:53:19 <yushyin> I still wonder how I can support multiple ghcide for different compiler with ghcup. I don't think I can in a sensible way. With stack the problem is solved with --copy-compiler-tool and it just works.
04:53:31 <merijn> earthy: The default Nix store is in /nix, so you can't use it unless you change the default store
04:53:40 <merijn> earthy: Which can't be done unless you compile Nix yourself
04:53:46 <merijn> earthy: And creating /nix requires root
04:54:14 <merijn> yushyin: cabal install can use cabal.project to configure which GHC to use
04:54:42 <yushyin> yeah but that's only for ghc
04:54:54 <Solonarv> I think yushyin was asking about having multiple ghcide binaries (for working with different ghc versions)
04:55:00 <merijn> Oh, right ghcide is tied to a specific ghc
04:55:05 <Solonarv> and automatically selecting the right one based on ghc version, even
04:55:18 <merijn> That should be actually fairly doable
04:55:34 <merijn> Write a shell script that uses "cabal exec ghc --version" to detect the ghc version used for a project
04:55:34 <Solonarv> oh, for sure
04:55:37 <yushyin> in stack it is a solved problem
04:55:48 <Solonarv> but I don't believe there is a ready-made tool for it
04:55:52 <merijn> Tag multiple ghcide binaries with their GHC version, use that to call ghcide
04:55:54 <Solonarv> hm, perhaps it's in-scope for vabal
04:56:00 <merijn> Solonarv: Be the change you want to see in the world!
04:56:02 <Solonarv> @hackage vabal
04:56:02 <lambdabot> http://hackage.haskell.org/package/vabal
04:56:41 <yushyin> yes, what we really need is even *more* tooling
04:57:34 <Solonarv> managing ghc versions was never in scope for cabal and still isn't
04:57:45 <merijn> Never will be, tbh
04:58:12 <phadej> yes
04:58:23 <phadej> it could start with managing UHC
04:58:47 <Solonarv> hehe
04:58:55 <merijn> cabal builds packages using a compiler, and you can tell it which one, but since it supports multiple compilers having it "auto-install compilers" just doesn't make sense
04:59:02 <Solonarv> anyway, vabal *already exists* and has for a good while
04:59:32 <Franciman> and it will exist
05:00:04 <Franciman> but it is meant as a sort of suboptimal glue 
05:00:16 <merijn> tbh, I'm perfectly happy with having a single compiler on my system that I develop with (and occasionally update) and then having a few others around to occasionally test/debug, but I don't really see the appeal of having a "compiler per project"
05:00:21 <Franciman> if cabal  gets better, it's better to use cabal
05:00:31 <maerwald> yushyin: isn't that to be solved by the application author? hie e.g. allows you to install for different ghc versions, no matter if you use stack or cabal
05:00:44 <Franciman> vabal can manage choosing a compiler and automatically make it available via ghcup
05:00:46 <Solonarv> that is actually a good point
05:00:46 <maerwald> why would a build tool have to solve that
05:01:18 <Franciman> and has some intelligent behaviour and can try to guess a compiler version
05:01:46 <Franciman> (but either it takes some time and tries all compiler versions (without downloading them) until one succedes, or makes a dull choice)
05:01:57 <merijn> Do people really use different compiler versions in every single project they work on?
05:02:10 <maerwald> if you work on tooling, then yes
05:02:23 <Solonarv> *I* don't, but I also only work on my own project
05:02:24 * hackage ghc-lib-parser 8.8.2 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.2 (shayne_fletcher)
05:02:24 <fendor_> or with stack, then yeah
05:02:24 <Franciman> the issue with stack is that stack doesn't support all cabal interesting features
05:02:30 <maerwald> or if you contribute to things like core libraries, you also have
05:02:31 <Solonarv> (and, once in a blue moon, a fork of some library or another)
05:02:35 <Franciman> I hate stack for this
05:02:41 <Franciman> "hate"
05:02:44 <Franciman> dislike
05:02:52 <merijn> maerwald: No, why would core libraries have different GHC versions per library?
05:03:16 <maerwald> ah, that's different
05:03:23 * hackage ghc-lib 8.8.2 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.2 (shayne_fletcher)
05:03:28 <merijn> maerwald: You can still use the same compiler for all of them and then only switch to debug CI failures and let CI test all the older versions you support
05:04:58 <merijn> I'll update my "default" GHC versions once or twice a year (lagging the latest release by a conservative amount) and then I may need to fix a bunch of stuff initially, but it's generally not that hard to make backwards compatible fixes for new GHCs, so once it's fixed for my "new default" the older GHCs will also compile it fine and CI can test if any future changes break
05:06:24 <lortabac> in my experience I only had to install multiple versions of the compiler when I found bugs in GHC
05:06:35 <merijn> I just don't buy that this is such a big issue as people make it out to be, unless you're building utterly bit-rotted libraries every day (in which case you could just make an older GHC your default)
05:06:40 <lortabac> and I wanted to check exactly which versions were affected
05:07:06 <merijn> lortabac: I mean, I still keep multiple installed for testing/locally debugging CI failures, but I don't see the need to pin those per project. I just set them as default "as needed" when debugging
05:07:34 <yushyin> maerwald: I don't understand you question. My problem is, that with ghcup I can only use cabal-install and ghcide gets installed in the user-wide PATH. I cannot have easly different compiler dependent tools for the different ghcs. With stack it is at easy as to use --copy-compiler-tool but stack sucks because of the lack of cabal features (like stack repl doesn't support mixins oO)
05:07:36 <fendor_> merijn, I think it is on windows for example, where the tooling story used to be bad/undocumented/hard to understand
05:08:35 <lortabac> merijn: I mainly work with a monorepo, so one version is enough
05:08:36 <maerwald> yushyin: then ghcide should have a build system that allows to install for different ghc versions
05:08:38 <merijn> yushyin: You could simply rename the tools to include their GHC version?
05:09:53 <jbetz> is there a way to pass arguments through `cabal bench`? e.g., flags for criterion output, so something like `cabal bench --benchmark-options="--csv --output results.csv"`
05:09:58 <maerwald> ghcup cannot really do that, because it doesn't *install* any haskell packages for you
05:10:21 <jbetz> there is a `test-options` option, but it doesn't seem to do anything for benchmark targets
05:13:16 <yushyin> maerwald: I know ghcup cannot deal with it, and I think stack got it right on this one. It is a nice tool-independent solution and just works.
05:13:21 <merijn> jbetz: You can use "cabal run" to run a specific benchmark (instead of all of them) and pass options that way
05:14:01 <yushyin> merijn: yes and use a wrapper-script, i think that works but is not really a pleasant user experience
05:14:36 <yushyin> but thanks for the tip, I guess I will try so.
05:18:31 <yushyin> nevertheless I still have problems to get ghcide working with cabal anyways. https://paste.xinu.at/m-Reav/#n-XH4rGR-46
05:19:04 <maerwald> shouldn't be hard to implement for cabal-install, something like "cabal install --install-dir=foo --compiler-suffix"
05:20:12 <fendor_> maerwald, something similar exists, --program-suffix
05:20:27 <fendor_> yushyin, what is your hie.yaml?
05:20:44 <yushyin> fendor_: https://paste.xinu.at/m-Reav/#n-RnV-16
05:20:53 <maerwald> fendor_: I was referring to the symlink it creates
05:21:05 <fendor_> maerwald, yeah
05:21:20 <maerwald> well, then what's the problem
05:21:33 <fendor_> yushyin, and app/Main.hs is part of the library?
05:21:41 <fendor_> maerwald, it doesnt do anything in cabal 3.0.0.0 :)
05:21:48 <maerwald> nice
05:22:09 <fendor_> but it will in the next release, I think. At least my pr for it got merged
05:22:43 <yushyin> fendor_: before I used stack and it worked ootb, with cabal I run into issues with the aeson dep.
05:22:54 <fendor_> yushyin, what is your cabal file?
05:23:29 <kuribas> dmj`: still, it works with any other package.  I do see a package in blue, z-typerep-map-z-typerep-extra-impls-0.3.2.
05:23:42 <yushyin> fendor_: no the app/Main.hs is not part of it, but does it matter for the issue with aeson? https://paste.xinu.at/jsK4Th/
05:23:45 <kuribas> dmj`: maybe that's an internal package which typerep-map depends on?  And that's what breaking it?
05:24:03 <dmj`> kuribas: can you paste the full error along with the command you invoked to produce it
05:24:35 <kuribas> dmj`: https://gist.github.com/kuribas/912a0ae651dea30828e295ce2d82b14f
05:24:40 <fendor_> yushyin, potentially. Does opening the library work with some lsp-client?
05:24:46 <kuribas> dmj`: command: ghc Test2.hs -v
05:25:30 <fendor_> yushyin, or `ghcide src/MyLib.hs`?
05:26:53 <yushyin> fendor_: cabal new-repl works and I can load/import Data.Aeson and use it just fine. ghcide src/MyLib.hs produces the same error as in my paste.
05:27:13 <kuribas> dmj`: also cabal v1-install typerep-map, ghci, then import Data.TypeRepMap
05:27:40 <dmj`> kuribas: what does ghc-pkg list typerep-map say
05:27:48 <dmj`> `ghc-pkg list typerep-map`
05:28:11 <kuribas> /opt/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d (no packages) /home/kristof/.ghc/x86_64-linux-8.4.4/package.conf.d typerep-map-0.3.2
05:28:11 <kuribas>  
05:28:43 <dmj`> kuribas: I'd delete /opt/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d (no packages)
05:28:57 <kuribas> dmj`: that will not break my system?
05:29:08 <kuribas> dmj`: btw, vector works
05:29:22 <kuribas> dmj`: it's also not in /opt/ ... package.conf.d
05:29:25 <dmj`> kuribas: what does `ghc-pkg list vector` say
05:29:37 <kuribas> /opt/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d (no packages) /home/kristof/.ghc/x86_64-linux-8.4.4/package.conf.d vector-0.12.0.3
05:30:15 <dmj`> hm
05:32:06 <kuribas> dmj`: oh, and renaming package.conf.d did break the system
05:32:12 <fendor> yushyin, ok, a bit weird :/
05:32:39 <kuribas> dmj`: should I file a bug at ghc?
05:33:13 <kuribas> dmj`: can you reproduce the problem?
05:35:15 <dmj`> kuribas: trying to now
05:36:12 <yushyin> fendor: I think so too ^^ Maybe I'll ask cocreature when he comes online otherwise I'll file a bug. And I also think I'm lacking a way to produce more verbose debug info from ghcide.
05:38:16 <dmj`> kuribas: the error I get is that the module is not exposed
05:38:20 <dmj`> which is odd
05:39:22 <dmj`> kuribas: I think I know what it is
05:41:00 <kuribas> yes?
05:41:07 <dmj`> testing my hypothesis
05:42:29 <dmj`> kuribas: the issue is multiple library stanzas
05:42:44 <kuribas> dmj`: yeah, that's a bit weird
05:42:57 <dmj`> kuribas: when I remove the extra library it's able to find the module
05:43:25 <kuribas> so it's a cabal bug?
05:44:10 <merijn> You had cabal 2.4, right? Does that even support multiple library stanzas?
05:44:17 <yushyin> I am a bit sorry for him, always demanding so much support from him ^^
05:44:36 <merijn> Ah, it should
05:44:58 <dmj`> yushyin: cocreature can handle anything ;)
05:45:20 <dmj`> kuribas: I think so
05:45:38 <yushyin> well, if you say so! :)
05:46:31 <dmj`> yushyin: I've seen cocreature code, he doesn't even type, he just looks at his screen and code appears. Don't know how he does it, some say black magic.
05:46:47 <kuribas> dmj`: thanks! I'll file an issue 
05:46:57 <dmj`> kuribas: sounds good 👌 
05:50:45 <__monty__> merijn: Fwiw, you don't need to recompile nix to change the store location. And there have always been chroot-y workarounds.
05:51:06 <merijn> __monty__: Last time I checked you did
05:51:15 <kuribas> dmj`: https://github.com/haskell/cabal/issues/6487
05:52:28 <dmj`> kuribas: upvoted
05:53:17 <merijn> __monty__: Although the link to the wiki that says how to do it has completely died
05:53:34 <__monty__> merijn: https://nixos.wiki/wiki/Nix_Installation_Guide
05:54:33 <merijn> __monty__: That uses user namespace support
05:54:41 <merijn> Which I don't have either
05:55:06 <__monty__> The chroots don't work without that?
05:57:09 <merijn> __monty__: The readme suggests not
05:57:24 <merijn> __monty__: As literally the first thing it does is show a command for checking if its available
05:57:28 <merijn> https://github.com/nix-community/nix-user-chroot
05:58:30 <__monty__> The proot method should still work.
05:59:08 <merijn> __monty__: I discarded the entire thing as too much work by that point
05:59:47 <__monty__> Fair.
05:59:51 <merijn> It's not worth the effort if "figuring out how to get user-local Nix to work" is more work than "just installing the stuff I need directly"
06:01:27 <__monty__> Barring integration over time factors, sure.
06:02:07 <merijn> __monty__: Yeah, but I just needed a "not stupid old C++ compiler", I don't plan to update that, basically, ever
06:16:04 <phadej> ping Phyx-, can you do 8.8.2 choco package, my GitHub experiments fail with 8.8.1, and I'm not sure if its me or GHC
06:25:30 <dmj`> merijn: why is user-local nix a requirement?
06:25:46 <merijn> dmj`: Because I don't have root?
06:25:55 <dmj`> merijn: that's a problem (:
06:26:10 <dmj`> merijn: why not?
06:26:19 <merijn> Everyone always comes with same answers "oh, just use apt-get" "oh, just get root"
06:26:29 <dmj`> sounds reasonable :)
06:26:38 <merijn> dmj`: Because admins of university computer clusters are not in the habit of granting random researchers root on said cluster
06:27:01 <dmj`> merijn: maybe AWS can give you some free credits to do things
06:28:17 <merijn> dmj`: Begging AWS for credits, then porting everything to work there seems like even more work
06:28:32 <dmj`> merijn: are you not on linux?
06:28:44 <dmj`> what's to port?
06:30:10 <merijn> dmj`: Pretty sure AWS doesn't use the same job queue software as the cluster, I'd have to find out which GPUs they have, what driver version of those GPUs, do I actually have exclusive access on said GPUs, figure out how to install CUDA on the VMs, install everything else I need on those VMs
06:30:34 <merijn> Sure, maybe I'd could use Nix to cover that last bit, but then I'd also need to learn how to setup and use Nix
06:31:13 <merijn> dmj`: Meanwhile, building LLVM from source, while an utter pain is far less work, doesn't have any unknown things that could trip me up, etc.
06:31:21 <davve_> bu/17
06:45:41 <dmj`> merijn: you should use AWS GPU batch instances and haskell arrayfire
06:45:59 <dmj`> merijn: you can build a docker image with nix that has all the stuff on it you need
06:46:30 <merijn> dmj`: Yes, this *totally* doesn't sound like more work than "just build LLVM"
06:46:46 <dmj`> sounds like less to me :) 
06:47:08 <merijn> dmj`: I honestly can't even tell if you're being sarcastic with your suggestions
06:47:10 <dmj`> merijn: is this to work w/ accelerate ?
06:47:16 <hc> lol
06:47:26 <merijn> dmj`: No, I write my kernels in CUDA
06:47:46 <dmj`> merijn: I'm not. I've used hmatrix w/ regular AWS batch running in a docker container built by nix
06:47:51 <merijn> Haskell is just for the surrounding bits and boilerplate and data analysis
06:47:56 <dmj`> merijn: writing manual cuda, yikes
06:48:41 <dmj`> merijn: I'd just fetch llvm from the nix cache
06:48:57 <dmj`> merijn: are you customizing it in any way?
06:49:19 <maerwald> is there a good download library that doesn't depend on either libcurl or haskell-tls?
06:49:40 <merijn> dmj`: "I'd just fetch llvm from the nix cache" <- right, but now where back to "nix doesn't work without root"
06:49:52 <dmj`> merijn: *face palm*
06:50:08 <dmj`> merijn: might be time to change universities, or go on strike w/ fellow classmates
06:52:06 <merijn> dmj`: This is national infrastructure, it's shared across universities and none of them are going to give random employees/researchers root, but somehow this idea seems really hard to grok for Nix fans, because they can't seem to accept the notion that Nix can't solve all problems
06:53:00 <dmj`> merijn: so you can't use docker either, because you need root?
06:54:01 <merijn> And if we're going to blame anything, let's put the blame where it belongs: The fact that every single linux package manager in 2019 still thinks "requiring root to install" is perfectly normal/acceptable
06:54:17 <dmj`> merijn: can you petition to get the nix-daemon installed, that would open the door to user local nix
06:54:54 <Athas> merijn: except for Linuxbrew I think!
06:55:04 <merijn> Athas: Perhaps, is that still supported?
06:55:07 <dmj`> merijn: it performs build actions and other operations on the Nix store on behalf of unprivileged users.
06:55:16 <Athas> merijn: yeah, it's even merged with Homebrew now.
06:55:40 <Athas> And whenever I hear about people using Linuxbrew (which admittedly isn't that often), it's HPC people.
06:57:11 <merijn> dmj`: These systems are still Linux 3.10 and the most recent gcc is 6.4.0 I don't see something as niche as Nix getting installed anytime soon
06:57:14 <Athas> "Can install software to your home directory and so does not require sudo"
06:57:22 <Athas> This is listed as the first feature of Linuxbrew.
06:57:43 <dmj`> merijn: *face palm*
06:57:47 <merijn> Athas: There's also stuff like Conda/Anaconda, but it's python based, so I'm skeptical of its robustness
06:57:59 <Athas> Yeah, Linuxbrew is based on Ruby.
06:58:08 <Athas> I think it worked OK last time I tried it, but...
06:58:40 <merijn> dmj`: Welcome outside the world of open source webdev :p
06:59:14 <Athas> 6.4.0?  My RHEL systems are on 4.8.5.
06:59:18 <Athas> You are on the cutting edge!
06:59:26 <merijn> Athas: 4.9 is the default
06:59:37 <merijn> Athas: But someone badgered them into providing a 6.4 module
07:00:45 <dmj`> merijn: so as long as your user owns /nix, you can use nix. But it would require someone w/ root privilege to chown you on it
07:00:56 <merijn> dmj`: Similarly, the default python is still 2.7 and presumably will be for the forseeable future, because updating to 3.x will break some scientist scripts (hell, it broke mine!)
07:01:17 <dmj`> merijn: there's gotta be some server admin in the back room watching youtube that you can go talk to 
07:04:15 * dmj` goes back into his cave, muttering.
07:04:20 <noctux> hmm, when I need to use strange HPC-cluster machines, I usually compile on a vm, and ship loader + copied userland + binary. ld.so --library-path=... binary
07:04:55 <noctux> it's not great for development, but usually works fine. The only issue is finding out what part of the userland is necessary, because ldd does not find all dependencies
07:05:19 <dmj`> merijn: national infrastructure .... that nobody can use because nobody can install anything on it :P 
07:05:21 <noctux> (there is some dlopening within glibc itself for nss-related stuff)
07:05:48 <merijn> dmj`: Scientists just want their 40 year old Fortran to still run, not use the bleeding edge
07:06:09 <merijn> That's probably conservative, by now it's probably more like 50-60 year old Fortran
07:06:31 <noctux> the kernel abi is usally stable enough for that approach to work. I don't know about cuda, though
07:06:46 <dmj`> merijn: yea, all of that is cached in nix in the gfortran derivation, libmpc, etc. All 60 years of it
07:07:26 <dmj`> merijn: why write the CUDA by hand though?
07:07:56 <merijn> dmj`: Have you ever worked with, like, climate scientists? I'd love to see you try and pitch Nix to them, especially given how terrible Nix's UX appears
07:08:35 <merijn> dmj`: What's the alternative? accelerate? That has terrible performance
07:08:36 <heatsink> merijn, IME scientists generally accept that they have to at least modify their code to run it on new hardware
07:09:01 <heatsink> and rewriting parts in CUDA is an option if they're going to use new hardware
07:09:13 <merijn> heatsink: These two are not related
07:09:28 <merijn> heatsink: The infrastructure is slow/dated, because scientists don't care
07:09:52 <merijn> It just happens to also be the infrastructure giving me access to GPUs for my own CUDA stuff
07:10:01 <dmj`> merijn: I've worked with quants in finance who don't care, and just want things to work. When somebody doesn't care you can pitch them anything successfully.
07:10:06 <heatsink> oh, I see
07:10:07 <dmj`> merijn: I'd use arrayfire, its fast
07:11:08 <dmj`> merijn: when people are scared of nix's UI there's a few solutions. 1) put a makefile in front of it. 2) add bash functions into shell.nix and make a README that tells them what to call
07:11:21 <Athas> I'm not sure ArrayFire is fast for the kind of code merijn is writing, since it's not even really array code!
07:11:22 <dmj`> nix-shell --run build-project
07:11:37 <dmj`> merijn: yea what kind of codes are you writing anyways
07:12:22 <merijn> dmj`: Graph algorithms and predicting how their performance relates to input structure
07:13:34 <merijn> dmj`: Right, and who exactly is going to convince, then migrate all 100+ groups of people using this infrastrcture, support those migrated tools and maintain them forever?
07:14:18 <merijn> dmj`: Everything is easy if your sitting on IRC handwaving away reality
07:15:52 <dmj`> if /nix just happens to show up, most will be blissfully ignorant. Who says all 100+ have to change? You can just keep it for yourself on your project.
07:17:19 <dmj`> are you working with 100 people?
07:17:24 <dmj`> merijn: ^
07:18:03 <merijn> I'm not, but I don't get to decide what's on those machines, and the people that do only want to maintain things used by a significant percentage of users
07:19:57 <merijn> Anyway, this conversations useful content is converging increasingly rapidly to a loop of repeating "just use nix"
07:20:36 <Athas> merijn: just use Linuxbrew!
07:22:25 <dmj`> merijn: I'd just use ghcup and arrayfire. Probably don't even need root for that, might have to build arrayfire from source though
07:22:41 <dmj`> merijn: given your restricted environment
07:25:38 <dmj`> or however you get GHC on that machine
07:41:12 * dminuoso finds it interesting, that the constraint system allows for a product of constraints to be written as either `(T1, T2) => ...` or `T1 => T2 => ...`
07:42:27 <dminuoso> Is there a category of constraints in which we have exponentials T2^T1?
07:42:29 <glguy> I like being able to write multiple line type signatures with: T1 =>\nT2=>\n...
07:43:09 <dminuoso> glguy: But haddock won't play nice with that, will it?
07:43:18 <dminuoso> I mean you can't annotate a context, can you?
07:43:23 <glguy> It doesn't break it
07:43:27 <Taneb> dminuoso: there's quantified constraints I guess?
07:43:37 <glguy> But you can't annotate them
07:43:47 <glguy> You can still put comments there
07:44:14 <dminuoso> Taneb: How is quantified constraints related here?
07:45:15 <Taneb> dminuoso: it lets you (sort of) talk about (a => b) => c, right?
07:56:16 <dminuoso> I cant even fathom what higher order constraints mean.
08:00:27 <geekosaur> given TypeInType, neither can ghc :p
08:00:55 <geekosaur> well, not strictly true I guess, but it'd be rather tangled
08:36:21 <nshepperd> when you call foo :: (a => b) => c, ghc tries to supply evidence of a => b by solving for b when a is given
08:49:29 <maerwald> it seems we really have no https client that uses native openssl?
09:02:54 <ezzieyguywuf> so, on my computer, when I type in `toRational 1e23` I get back something like "99999999999999991611329 % 1". While I understand that this is, more or less, equal to 1e23, I don't understand why the Rational type (which I expect to have perfect precision) does not store it properly. Are there floating-point error limitation to the Rational type?
09:03:34 <glguy> ezzieyguywuf: toRational is defaulting to the type: Double -> Rational
09:03:35 <geekosaur> not to the rational type but to the floating point value 1e23
09:03:52 <glguy> > 1e23::Double
09:03:54 <lambdabot>  9.999999999999999e22
09:04:12 <glguy> > 1e23::Rational
09:04:15 <lambdabot>  100000000000000000000000 % 1
09:04:28 <ezzieyguywuf> could it be my version of ghc? 8.0.2?
09:04:40 <glguy> No, what you're seeing is the correct behavior
09:04:41 <geekosaur> no, this is how floating point (Double) works. in any language
09:04:55 <ezzieyguywuf> ah, so my issue is I am sending a Double to toRational
09:04:59 <glguy> Yes.
09:05:19 <merijn> ezzieyguywuf: 1e23 is a Fractional per the Haskell spec
09:05:24 <merijn> ezzieyguywuf: You want NumDecimals
09:05:25 <ezzieyguywuf> how can I construct a Rational directly, i.e. something like `let myRational = Rational 2 4`
09:05:40 <ezzieyguywuf> (in ghci)
09:05:41 <glguy> ezzieyguywuf: You can do what I did above
09:05:42 <merijn> % :t 1e23
09:05:42 <yahb> merijn: Fractional p => p
09:05:49 <merijn> % :seti -XNumDecimals
09:05:49 <yahb> merijn: 
09:05:51 <merijn> % :t 1e23
09:05:51 <yahb> merijn: Num p => p
09:05:54 <merijn> boom
09:05:59 <glguy> ezzieyguywuf: or you can use Data.Ratio's % or just /
09:06:05 <merijn> % toRational 1e23
09:06:05 <yahb> merijn: 100000000000000000000000 % 1
09:06:08 <merijn> tada
09:06:12 <merijn> <- genius
09:06:24 <glguy> merijn: You don't need an extension to use 1e23 as a Rational though...
09:06:34 <merijn> glguy: Also true
09:06:56 <merijn> % :seti -XNoNumDecimals
09:06:56 <yahb> merijn: 
09:07:02 <ezzieyguywuf> hrm. Is Rational a "type constructor" or a "value constructor" or something else entirely?
09:07:03 <merijn> % 1e23 :: Rational
09:07:03 <yahb> merijn: 100000000000000000000000 % 1
09:07:17 <merijn> ezzieyguywuf: Rational is a type (and type constructor)
09:07:19 <glguy> Rational is a type constructor (notice the capital letter)
09:07:30 <glguy> Rational and (Rational a) are types
09:07:38 <solonarv> glguy: kind error
09:07:43 <glguy> erRatio
09:07:45 <glguy> Ratio a
09:07:47 <solonarv> 'type Rational = Ratio Integer'
09:08:27 <merijn> ezzieyguywuf: Anyway, you don't need toRational for literals, since literals are polymorphic.
09:08:40 <merijn> :t toRational
09:08:41 <lambdabot> Real a => a -> Rational
09:09:19 <merijn> ezzieyguywuf: The problem is that toRational is polymorphic too, and the rules for Real default to Double, so it first converts 1e23 to Double, then calls toRational which introduces the error
09:09:26 <ezzieyguywuf> for examle, if I were to do something like `class MyNumbers a = Rational a a ` (please excuse any syntax errors, I'm still learning) I'd expect to be able to construct a MyNumbers using `Rational 1 2`
09:09:41 <merijn> ezzieyguywuf: If you enable -Wall it should warn about defaulting and if you just use the literal directly it "Just Works"
09:09:49 <merijn> ezzieyguywuf: You can use % for that
09:09:55 <merijn> > 1 % 3
09:09:57 <lambdabot>  1 % 3
09:10:01 <merijn> :t 1 % 3
09:10:02 <lambdabot> Integral a => Ratio a
09:10:15 <ezzieyguywuf> is a Ratio a Rational+
09:10:16 <ezzieyguywuf> ?
09:10:23 <merijn> ezzieyguywuf: "Rational = Ratio Integer"
09:10:25 <glguy> ezzieyguywuf: Rational is an abstract type, you can't make one directly because there's an invariant that the fraction it represents is stored in reduced form
09:10:29 <ezzieyguywuf> hrm..or does that question even make sense in haksell?
09:10:29 <ezzieyguywuf> lol
09:10:56 <merijn> ezzieyguywuf: So "Ratio" says "I can represent fractions using any Integral type", "Rational" is specifically "Ratio, using Integer"
09:11:02 <ezzieyguywuf> ah, "Rational is an abstract type". This is still a concept I'm trying to wrap my head around, so perhaps I need to do some more reading and playing in ghci
09:11:15 <ezzieyguywuf> merijn: ah hah, that is also quite helpful
09:11:16 <solonarv> the definition of Ratio is something like 'data Ratio a = <hidden implementation details that aren't exported'
09:11:40 <solonarv> this is somewhat like "templates" in C++, or "generics" in Java
09:13:54 * hackage pure-zlib 0.6.7 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.6.7 (AdamWick)
09:15:37 <ezzieyguywuf> wow, it seems that haskell out-of-the-box takes care of a lot of the things that I might rely on CGAL for in C++
09:15:41 <ezzieyguywuf> that's neat
09:19:23 <solonarv> eh, I wouldn't say "a lot", tbh
09:22:48 <ezzieyguywuf> *shrug* fair
09:22:53 <ezzieyguywuf> but even "some" is more than I would expect
09:22:59 <ezzieyguywuf> i.e. rational numbers and complex numbers
09:23:03 <ezzieyguywuf> and pi out-of-the-box
09:30:50 <solonarv> is pi really that unusual to have? huh
09:31:43 <solonarv> anyway, it has rationals and complex numbers, a few fairly basic arithmetic things, and that's really it as far as base is concerned
09:35:01 <ezzieyguywuf> sin, cos
09:35:47 <solonarv> I am very confused right now
09:35:57 <solonarv> by "out of the box" do you mean that they don't need to be imported?
09:40:03 <ezzieyguywuf> I mean they're built into the language
09:40:07 <ezzieyguywuf> rather than provided by a third-party library
09:40:24 <ezzieyguywuf> in c++ we have stdlib, but it's not exactly "built in"
09:40:42 <solonarv> ah, there are a few different levels of "built in" here
09:41:00 <slack1256> How do I recover my hackage password?
09:41:19 <slack1256> Do I need to send a email or there is a field I haven't seen?
09:41:31 <solonarv> there is a 'Prelude' module, which is implicitly imported into every Haskell source file
09:42:07 <slack1256> Nvm I found it
09:42:13 <solonarv> but it really just reexports (some) contents of other modules; for example, Rational is actually defined in Data.Rational (I think)
09:43:13 <solonarv> apart from being implicitly imported, it's not special in any way; you could write your own as well (and people do)
09:44:16 <joeyh> mempty "eep" == () -- this surprised me
09:44:34 <wildtrees> I found this interesting and it made a bit of sense to me https://www.tweag.io/posts/2020-01-16-data-vs-control.html other than the meat of the appendix 
09:44:36 <solonarv> joeyh: yes, it does look a bit odd at a glance!
09:45:00 <joeyh> it's the Const instance I suppose.. luckily the surprise was in the direction of my code working as desired accidentially
09:45:18 <joeyh> .. this time
09:45:22 <solonarv> not the Const, instance, no, not quite
09:45:30 <joeyh> oh, where is it hiding then?
09:45:57 <__monty__> > (mempty :: _) "eep" ()
09:45:59 <lambdabot>  error:
09:45:59 <lambdabot>      • Found type wildcard ‘_’ standing for ‘[Char] -> () -> t’
09:45:59 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
09:46:03 <solonarv> instance Monoid b => Monoid (x -> b) where mempty = const (mempty :: b)
09:46:42 <sm[m]> hail joeyh, how's git-annex these days
09:46:56 <joeyh> well despite crazy instances..
09:47:17 <sm[m]> 👍🏻
09:47:31 <solonarv> well, not that crazy tbh - it's just point-wise lifting
09:52:24 <koz_> solonarv: All we do in Haskell is lift. :P
09:52:57 <solonarv> <flexing bicep emoji here>
09:53:23 <koz_> solonarv: https://vignette.wikia.nocookie.net/slay-the-spire/images/5/5a/Flex.png/revision/latest/scale-to-width-down/310?cb=20181016205957
09:56:02 * solonarv was thinking of Girya
09:56:48 <koz_> solonarv: Even better. In Haskell, we spend time permanently improving our strength instead of resting. :P
09:56:49 * mrkgnao has caved after a week of trying to tough it out on Arch and installed Nix
10:00:54 * hackage fay 0.24.0.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.24.0.4 (swamp_agr)
10:01:32 <emmanuel_erc> Hello there!
10:02:04 <koz_> emmanuel_erc: Wazzup?
10:02:10 <wildtrees> hi emmanuel_erc 
10:03:37 <emmanuel_erc> koz_: Nothing much, just tinkering around with lenses. I'm really trying to wrap my head around other parts of the library besides getters and setters.
10:07:46 <maerwald> at least one http client that uses openssl: https://hackage.haskell.org/package/http-io-streams
10:19:24 * hackage musicScroll 0.1.0.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.1.0.0 (RubenAstudillo)
10:19:44 <slack1256> Hey I did that!. I hope somebody finds it useful.
10:19:53 <MarcelineVQ> you!
10:19:57 <slack1256> I wonder if [ANN] are still well received on reddit
10:20:37 <MarcelineVQ> You use SMPlayer for music?
10:21:02 <slack1256> .... yes ;_;
10:21:24 <slack1256> I don't know why, I don't like "real music players", plus the m3u files are already present.
10:23:11 <slack1256> But hey, who said Graphical App on haskell are hard?
10:24:19 <iqubic> What is [ANN]?
10:24:26 <MarcelineVQ> hehe, well, tbf both the music players I like for linux crash randomly, mplayer does this slightly less :>
10:24:34 <slack1256> ANNounce
10:25:47 <slack1256> MarcelineVQ: Plus on a real jukebox software, you should supplement the tunes info via plugins on the select $lang of the program
10:26:05 <slack1256> I needed an excuse to use just DBus/MPRIS , lol.
10:30:55 <iqubic> I really wish there was a way I could make this module export Data.Map, in a sane way.
10:31:37 <ezzieyguywuf> https://repl.it/@WolfgangSanyer/ConsiderateSurprisedAstronomy <-- I'm trying to explore/learn about "data type" versus "type classes", and have contrived the example in this link. Now, while I realize I'd probably be better off defining a `(++) in my typeclass and then using that to build up the `say` and `exclaim` functions, I want to leave this as-is for now because I don't understand why I cannot 
10:31:43 <ezzieyguywuf> get this to work correctly with `MySomethingElse` (this is why it is commented out)
10:32:02 <iqubic> But no, either I add Data.Map into the exports list, and none of the Data.Map functions are qualified, or I don't add Data.Map to the exports, and it isn't exported.
10:32:11 <ezzieyguywuf> I can succesfully run `ghci> map ( ++ "!") ["hello", "there"]`, but there is obviously something wrong in my function definition as it does not compile
10:32:58 <geekosaur> iqubic, correct, qualification always comes from the module you import, the information about a re-export loses any qualification information
10:33:08 <iqubic> God damn it to hell.
10:33:14 <iqubic> That's annoying.
10:33:19 <ezzieyguywuf> 😮
10:33:42 <glguy> ezzieyguywuf: use ++ for list append
10:33:59 <solonarv> ezzieyguywuf: the problem is simple: you say that 'exclaim' should return a 'String'
10:34:19 <solonarv> but 'map (++"!") a :: [String]'
10:34:23 <solonarv> that's a type error!
10:34:38 <iqubic> Right.
10:34:56 <ezzieyguywuf> well, this type error is what I am having trouble understanding
10:35:04 <iqubic> And for what it's worth, that version of Punctuate MyData doesn't look to bad.
10:35:17 <ezzieyguywuf> aw shucks I'm blushing :)
10:35:46 <iqubic> ezzieyguywuf: Did you read what solonarv said? That's as good an explanation as any.
10:35:48 <ezzieyguywuf> i guess I need to flaten the result of the map?
10:35:55 <glguy> (oh, this mobile client line wrapped funny and split the ++)
10:36:03 <geekosaur> does it help to know that String is the same thing as [Char] ?
10:36:11 <ezzieyguywuf> geekosaur: it helps, but I already knew that
10:36:21 <ezzieyguywuf> I think solonarv's comment probably key here, I just need to unpack it
10:36:26 <iqubic> :t map
10:36:28 <lambdabot> (a -> b) -> [a] -> [b]
10:36:40 <ezzieyguywuf> yup
10:36:41 <iqubic> :t map (++ "!")
10:36:42 <lambdabot> [[Char]] -> [[Char]]
10:36:47 <geekosaur> with that the type error should make sense; it's telling you that ypu teold it the result should be String, but it's actually [[Char]] which is [String]
10:36:49 <ezzieyguywuf> I got it now, I new to flatten the list
10:36:59 <ezzieyguywuf> so probably fold instead of map...
10:37:02 <geekosaur> *you told
10:37:11 <iqubic> ezzieyguywuf: You can do that, but it won't have the desired effect.
10:37:32 <iqubic> > concatMap (++ "!") "Hello World"
10:37:34 <lambdabot>  error:
10:37:34 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
10:37:34 <lambdabot>        Expected type: [[Char]]
10:37:50 <iqubic> :t concatMap (++ "!")
10:37:51 <lambdabot> Foldable t => t [Char] -> [Char]
10:38:12 <ezzieyguywuf> iqubic: you're right. Because technically the desired affect is "add a punctuation to each word then concat them with a space in between" (even though, grammatically, that doesn't make much sens. But this is for science!)
10:38:25 <iqubic> ezzieyguywuf: Ah. I see.
10:39:50 <ezzieyguywuf> intercalate, maybe?
10:40:54 <ezzieyguywuf> intercalate " " $ map ( ++ "!") ["Hello", "there"]
10:41:06 <emmanuel_erc> I would like to ask if it is possible to write a lens (or traversal perhaps) that would allow to step down into a map like structure and remap its keys?
10:41:07 <ezzieyguywuf> that does the job. is it to...verbose though?
10:41:08 <iqubic> Try it and see.
10:41:21 <iqubic> ezzieyguywuf: Does that work?
10:41:29 <emmanuel_erc> I want to see if this is possbile just as an academic exercise. 
10:41:37 <iqubic> emmanuel_erc: It is.
10:41:52 <iqubic> Look into indexed traversals and the reindexed function.
10:42:45 <ezzieyguywuf> iqubic: yes it does
10:42:47 <emmanuel_erc> I've been looking at that function actually.
10:42:54 <iqubic> > exclaim "Hello World"
10:42:56 <lambdabot>  "Hello! World!"
10:43:13 <emmanuel_erc> I don't quite want the answer, but could I get an extra hint.
10:43:16 <ezzieyguywuf> how did lambdabot do that!?
10:43:17 <ezzieyguywuf> lol
10:43:34 <ezzieyguywuf> :t exclaim
10:43:36 <lambdabot> String -> [Char]
10:43:36 <iqubic> Easy.. I gave lambdabot a function definition in a PM
10:43:41 <ezzieyguywuf> ah hah
10:43:43 <ezzieyguywuf> tricksy
10:43:53 <int-e> @undef
10:43:53 <lambdabot> Undefined.
10:43:58 <iqubic> exclaim a = intercalate " " $ map (++ "!") $ words a
10:44:05 <int-e> > exclaim "Hello World" -- always possible to spoil the fun
10:44:07 <lambdabot>  error:
10:44:07 <lambdabot>      Variable not in scope: exclaim :: [Char] -> t
10:44:17 <ezzieyguywuf> but yes, the intercalate worked. is it possible to make the function more succinct, though, maybe using other functions rather than intercalate and map?
10:44:27 <iqubic> Not that I can see.
10:44:31 <ezzieyguywuf> it seems to be a common enough idiom, "take a list, do something, then join the list with a delimiter"
10:44:43 <gendarme> when programming sequences, you usually have at least a parameter to handle the 
10:44:48 <gendarme> "current iteration
10:44:54 <ezzieyguywuf> exclaim ["hello", "world"]
10:44:56 <gendarme> ah that floped :/
10:45:02 <int-e> > unwords ["hello","world"]
10:45:04 <lambdabot>  "hello world"
10:45:48 <iqubic> @check \x -> words $ unwords x == x
10:45:51 <lambdabot>  error:
10:45:51 <lambdabot>  • Couldn't match type ‘Bool’ with ‘[Char]’ Expected type: String Actual type...
10:46:09 <iqubic> @check \x -> words (unwords x) == x
10:46:12 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 2 shrinks):
10:46:12 <lambdabot>  ["gz\\","\934867\228878",""]
10:46:18 <iqubic> What the hell is that?
10:47:19 <iqubic> @check \x -> unwords (words x) == x
10:47:21 <lambdabot>  *** Failed! Falsifiable (after 17 tests and 5 shrinks):
10:47:21 <lambdabot>  "X\US\ETB\ETB\936145$W\f;)igPz"
10:47:29 <iqubic> Alright then.
10:47:37 <geekosaur> words will split on multiple spaces
10:47:51 <iqubic> Ah. I see.
10:47:54 <geekosaur> > unwords (words "a  b")
10:47:57 <lambdabot>  "a b"
10:48:13 <iqubic> :t worded
10:48:15 <lambdabot> (Indexable Int p, Applicative f) => p String (f String) -> String -> f String
10:48:17 <geekosaur> but also possibly on isSpace rather than just spaces
10:48:36 <iqubic> Although that iso exists, it's not a lawful iso
10:49:34 <int-e> > isSpace '\f'
10:49:36 <lambdabot>  True
10:49:46 <iqubic> The hell is \f?
10:49:47 <int-e> > words "abcde\fghij"
10:49:48 <djanatyn_> i really enjoyed using the hreq package - what are the best ways to show support for developers on hackage?
10:49:49 <lambdabot>  ["abcde","ghij"]
10:50:21 <geekosaur> formfeed
10:50:28 <geekosaur> you're probably too young for that :p
10:51:09 <iqubic> I am indeed.
10:51:34 <geekosaur> otherwise known as control-L
10:54:33 <iqubic>  So like that?
10:55:03 <iqubic> That's what emacs gives me if I ask emacs to insert a literal control-L char.
10:55:06 <geekosaur> irc doesn't speak it. printers do. terminals, not so much these days.
10:55:19 <iqubic> Right. Makes sense.
10:55:38 <iqubic> I would test if my printer supports it, but I don't want waste paper.
10:55:45 <geekosaur> (control characters in IRC generally do things like color instead of printer control)
10:56:16 <iqubic> Right
10:56:20 <MarcelineVQ> ,1or hide things
10:56:26 <iqubic> https://en.wikichip.org/wiki/irc/colors
10:56:46 <iqubic> There's a link to a guide on various IRC control sequences.
10:57:14 <iqubic> I can do trippy things like this
10:57:24 <iqubic> Except that might not have worked.
10:57:50 <geekosaur> didn't work here but I'm on the dumb web client. I got boxes
10:58:13 <MarcelineVQ> it didn't work, iqubic what did you want that to do?
10:58:43 <iqubic> it was supposed to render the phrase "I can do trippy things like this" in reverse video.
10:59:24 * hackage lzlib 0.3.1.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.3.1.0 (vmchale)
11:03:03 <MarcelineVQ> guess it's not well supported/common
11:03:07 <solonarv> emmanuel_erc: no, you can't write a lawful optic that modifies the keys; the problem is that setting isn't allowed to change the number of "targets"
11:03:12 <MarcelineVQ> it being the reverse control code
11:03:36 <iqubic> solonarv: Reindexing can do it though.
11:04:09 <solonarv> iqubic: reindexing changes what "index" other optics see
11:04:24 <solonarv> it doesn't change the Map itself
11:04:54 <iqubic> Ah. Right. True.
11:05:43 <iqubic> perhaps toMapOf can help.
11:05:47 <iqubic> :t toMapOf
11:05:48 <lambdabot> error: Variable not in scope: toMapOf
11:06:07 <iqubic> IndexedGetting i (Map i a) s a -> s -> Map i a
11:06:11 <int-e> iqubic: Yes, like that. (irssi displays those as inverted L characters for me) :)
11:06:32 <iqubic> int-e: You are the only person that has worked for.
11:07:07 <int-e> iqubic: well "work". I can see that you transmitted ^L characters. It didn't leave blank pages in the scrollback.
11:07:28 * MarcelineVQ discovers ^R in a terminal due to this command code stuff
11:08:23 <int-e> geekosaur: Well ^L clears the screen in most shells, I think, which is related (and somehow I was ignorant of that connection before this discussion) :)
11:09:13 <iqubic> Oh. I'm an idiot.
11:17:10 <emmanuel_erc> solonarv: Thanks for letting me know that.
11:17:19 <emmanuel_erc> I suppose that this is a good thing.
11:18:30 <emmanuel_erc> So far, I had written this `itraversed.reindexed succ`
11:18:50 <emmanuel_erc> :t itraversed.reindexed succ
11:18:52 <lambdabot> (TraversableWithIndex i t, Indexable j p, Enum j, Applicative f) => (Indexed j a b1 -> f b2) -> t (p a b1) -> f (t b2)
11:18:53 <ysangkok> MarcelineVQ: if that impresses you, you should check out fzf which can make control-t do an inline fuzzy resursive file search
11:19:10 <emmanuel_erc> I don't know to massage that to make an actual traversal
11:19:17 <emmanuel_erc> but I suppose that doesn't matter any longer.
11:31:54 * hackage hgeometry 0.10.0.0 - Geometric Algorithms, Data structures, and Data types.  https://hackage.haskell.org/package/hgeometry-0.10.0.0 (FrankStaals)
11:32:54 * hackage hgeometry-combinatorial 0.10.0.0 - Data structures, and Data types.  https://hackage.haskell.org/package/hgeometry-combinatorial-0.10.0.0 (FrankStaals)
12:02:20 <gendarme> how would you translate a for clause in math expression to Haskell? I've used an if guard before, is there another way?
12:03:16 <ysangkok> what's a for clause? i tried googling, didn't get good results
12:05:57 <gendarme> ysangkok, like right under the facotiral formula section https://en.wikipedia.org/wiki/Binomial_coefficient
12:22:33 <jle`> hm
12:22:53 <jle`> probably just a guard is the simplest way, and return a Maybe
12:23:06 <jle`> you could also restructure the input to have it work for all integers
12:23:26 <jle`> or pick a type that would make the for's redundant
12:23:43 <gendarme> ok thanks
12:23:44 <jle`> gendarme: for example something like f(n) = ... for n >= 0
12:23:49 <jle`> you can have f :: Natural -> ...
12:23:56 <jle`> f :: Natural -> X
12:23:57 <gendarme> ohhh
12:24:01 <jle`> instead of f :: Integer -> Maybe X
12:24:28 <gendarme> that's a super neat use
12:24:30 <gendarme> thanks man
12:24:35 <jle`> but maybe a direct translation would require using refinement types
12:25:30 <jle`> basically like an f :: (k <= n) => (n : Natural) -> (k : Natural) -> X
12:25:49 <jle`> that would be the most faithful way to translate that sort of 'for' clause into haskell
12:25:59 <jle`> that f is defined whenever k <= n, it's saying
12:26:14 <jle`> however that there isn't quite valid haskell syntax yet, you need to use some of the libraries that support some sort of encoding of it
12:27:46 <gendarme> how do you debug when your sequences spit out odd values?
12:27:58 <gendarme> like I have no idea what would be going on underneath
12:28:13 <jle`> but yeah, ideally these sort of 'for' restrictions would be expressed in the types, not as Maybe or term-level restrictions
12:28:14 <ezzieyguywuf> haha, yes unwords was the droid I was looking for
12:28:18 * gendarme made a function to evaluate some sequences
12:28:40 <jle`> gendarme: it depends on the situation really
12:28:54 <jle`> that quesiton is like asking 'how do you debug when your function returns an odd value'
12:29:47 <gendarme> well I am wondering, I some of my earlier terms for the series is correct, then the method or code was right, but then maybe not
12:30:00 <gendarme> it's ok don't worry about this one :P
12:30:30 <MarcelineVQ> by odd did you mean strange?
12:30:41 <jle`> if you paste some code with the problem you're trying to solve, then we can look at it and give specific advice :)
12:30:53 <jle`> otherwise the question as it is is too broad to give any meaningful advice i think
12:32:59 <gendarme> jle` it's all good, cheers :)
12:39:56 <ezzieyguywuf> if I'm defining a typeclass `class Punctuate' a where...`, is there a way to enforce that `a` implements `Show`?
12:40:20 <topos> ezzieyguywuf `class Show a => Punctuate a where ... `
12:40:27 <ezzieyguywuf> (pretty sure I've read that there is but I can't find the reference...."
12:41:11 <ezzieyguywuf> topos: so, by extension, `class (Show, Num, etc..) a => Punctuate a where...` for multiple restrictions?
12:41:26 <topos> yes
12:41:27 <topos> precisely
12:41:40 <topos> well, small modification to syntax: `class (Show a, Num b ...) => ` etc
12:43:03 <ezzieyguywuf> `(Show a, Num a)` if i only want an `a` but with both...er...instances (?)
12:43:25 <topos> yes
12:43:51 <ezzieyguywuf> great thanks!
12:44:06 <solonarv> ezzieyguywuf: although in your case, there really isn't any good reason I can see for that 'Show a =>' to be there
12:44:31 <ezzieyguywuf> yea I think really what I want is `Char a =>`
12:44:37 <ezzieyguywuf> I'm just 'sperimenting!
12:44:49 <solonarv> what is 'Char a =>' supposed to mean?
12:45:48 <iqubic> It's not a real thing.
12:46:09 <ezzieyguywuf> well, what I want the whole `class Char a => a where` to mean is "here is a new type class, which takes an a, in which a implements `Char`, with the following functions"
12:46:33 <ezzieyguywuf> so I've been mislead?
12:46:36 <iqubic> ezzieyguywuf: That's not something that works.
12:46:45 <ezzieyguywuf> 😮 has the internet failed me?
12:46:49 <ezzieyguywuf> iqubic: ah, I see.
12:46:53 <topos> You should read the haskellwiki regarding typeclasses
12:46:57 <ezzieyguywuf> I cannot place restrictions on `a` in a type class definition?
12:47:04 <ezzieyguywuf> ok then, I'll take a look.
12:47:29 <topos> https://en.wikipedia.org/wiki/Type_class
12:47:36 <iqubic> You can place restrictions, but not in that sort of way.
12:47:51 <solonarv> "a implements Char" is not a meaningful sentence: 'Char' is not a typeclass, it's just a plain old type
12:48:09 <ezzieyguywuf> *face palm* of course
12:48:27 <ezzieyguywuf> well, that's why I started with "a implements Show"
12:48:43 <ezzieyguywuf> but my gut tells me that's still not precicesly what I want
12:48:57 <solonarv> at a guess, probably not
12:49:00 <solonarv> what *do* you want?
12:50:52 <ezzieyguywuf> I want to improve on my `class Punctuate` where, instead of listing every type of punctuation that it adds to `MyData`, instead it is defined such that it will arbitrarily accept an `MyData` and a Char and "do the right thing"
12:51:29 <solonarv> ooh, *that* is what you are doing!
12:51:56 <ezzieyguywuf> for reference, https://repl.it/@WolfgangSanyer/ConsiderateSurprisedAstronomy 
12:52:07 <solonarv> okay, no need to mess with superclasses at all
12:52:13 <solonarv> those are completely unrelated
12:52:16 <ezzieyguywuf> well, although I didn't update it yet with `unwords`
12:52:46 <ezzieyguywuf> ah hah, you mean just define a function that takes a `MyData` and a `String` and go from there
12:52:56 <solonarv> you can simply change 'exclaim' and/or 'say' to take a 'Char' argument (or 'String')
12:53:19 <solonarv> or perhaps add a third method, maybe 'punctuate' would be a good name
12:54:30 <electricityZZZZ> so i just started trying to read the minimal-servant example and came across :<|> ,... which is an operator apparently defined by the servant library,... am i going to encounter a lot of this kind of weird custo operator stuff? is there a library with more modern code legibility standards (which i hope have evolved to avoid this sort of thing?) or does the haskell community like these things?
12:54:39 <electricityZZZZ> *weird custom operator stuff
12:54:50 <ezzieyguywuf> hrm, I'll tinker with this for a bit. My original intent was to learn more about how type classes and data types (? the stuff you describe with the "data" keyword) interact and how those interactions can be useful
12:55:40 <solonarv> electricityZZZZ: yes, you will see a lot of custom operators
12:56:00 <electricityZZZZ> so,... is something wrong with me that i find this Really Bad (tm)?
12:56:09 <solonarv> that might look somewhat odd to newcomers, but really it's not much different from custom functions
12:56:12 <solonarv> eh
12:56:44 <electricityZZZZ> to my eye it parses really strangely
12:56:54 <solonarv> it's sometimes bemoaned, but they can be more legible than some deeply nested chain of plain old functions
12:57:27 <electricityZZZZ> ...deeply nested... so you can't have word based infix?
12:57:41 <electricityZZZZ> you can though, with `this` notation,... but i guess it's an alternative to the backticks...?
12:58:08 <solonarv> yeah, everything could also be infix-ified identifiers
12:58:38 <solonarv> like (foo `OrElse` bar `OrElse` baz) instead of (foo :<|> bar :<|> baz)
12:59:55 <solonarv> ezzieyguywuf: one important note about type classes: if there is only ever a single 'instance' declaration, then having a typeclass is rather pointless
13:00:45 <ezzieyguywuf> solonarv: duly noted, and that makes perfect sense
13:01:21 <solonarv> ezzieyguywuf: a type class is a way of saying: "here is some common behavior that works for a bunch of different types"
13:03:38 <solonarv> a 'data' declaration is sort of a mix between a 'struct' and 'enum' declaration like in C (not C++: there is no inheritance, no methods, no public/private distinction)
13:04:58 <ezzieyguywuf> If I want to turn a Char into a String, is it bad practice to just use `Show`?
13:05:33 <ezzieyguywuf> er, `show`
13:06:11 <solonarv> it likely won't have the result you want
13:06:21 <solonarv> > show 'a' -- you wanted "a", right?
13:06:23 <lambdabot>  "'a'"
13:07:27 <ezzieyguywuf> ah
13:07:38 <ezzieyguywuf> so do I just need to `"" :: 'a'` then?
13:07:50 <solonarv> no, that's also... very wrong
13:07:51 <ezzieyguywuf> or I guess I could just `['a']`
13:07:58 <solonarv> yes!
13:08:01 <ezzieyguywuf> !!!
13:08:11 <electricityZZZZ> so is there anything relatively analogous to postgrest for providing a frontend,... something which can render my tables automatically as html or similar?
13:08:28 <solonarv> 'x :: t' means "x has type t" - but 'a' isn't a type!
13:09:01 <solonarv> I was actually going to give you a hint that String is really just [Char], but you got that on your own :)
13:09:13 <ezzieyguywuf> :)
13:09:22 <ezzieyguywuf> ah, i thought `::` was the "Cons" operator
13:09:25 <ezzieyguywuf> whoops
13:09:44 <ezzieyguywuf> that's just one `:` isn't it?
13:09:46 <solonarv> heh, yeah, some other languages have : and :: the other way 'round
13:09:48 <solonarv> yup
13:10:28 <solonarv> there's been some occasional discussion that maybe Haskell should have them the other way around (: for "has type", and :: for cons)
13:10:44 <solonarv> but that would break basically all the code everywhere, so most likely won't happen
13:12:29 <ezzieyguywuf> *shrug* nbd
13:12:52 <ezzieyguywuf> it's alive! haha most of my new `class Punctuate` works!
13:13:03 <solonarv> you just got the argument order wrong, then: it's 'newElement : restOfTheList'
13:13:26 <solonarv> ('a' : "") works, but it's needlessly verbose: you could just write "a" ;)
13:13:27 <ezzieyguywuf> scratch that, it all works
13:13:35 <solonarv> same for ['a'], of course
13:13:35 <ezzieyguywuf> solonarv: I caught that
13:13:50 <ezzieyguywuf> I ended up `"Some string" ++ ['.']`
13:14:08 <ezzieyguywuf> though surely there's a function for "append an element to the end of a list"
13:14:15 <ezzieyguywuf> I shall try out my hoogle-fu
13:14:21 <solonarv> eh, not for lists afaik
13:14:23 <solonarv> at least not in base
13:14:30 <mpickering> What happened to aelve codesearch?
13:14:49 <solonarv> it's not something you should end up doing all that often, because appending to the *end* of a list is very inefficient
13:15:31 <ezzieyguywuf> is it now?
13:15:33 <ezzieyguywuf> interesting
13:15:43 <ezzieyguywuf> I'll stick with my `++` then :-P
13:16:17 <solonarv> yeah, it's obviously not an issue for small playing-around/learning programs like you are doing right now
13:16:38 <zzualk> ezzieyguywuf: The point is that it's inefficient, so the interface discourages appending at the end
13:16:45 <solonarv> ^ exactly
13:17:56 <ezzieyguywuf> *nods*
13:18:14 <ezzieyguywuf> I'll keep that in mind whenever I get good enough to try writing a CAD kernel in haskell
13:18:17 <ezzieyguywuf> :)
13:19:29 <solonarv> it's inefficient in an algorithmic-complexity sense as well, which tends to mean you will run into it even for programs that don't need to be super-high-performance
13:20:14 <maerwald> is there a better URL type library than Network.URL from url somewhere?
13:20:14 <zzualk> If this intrigues you, look up difference lists, which have efficient append at the end
13:21:53 <solonarv> it's not a full library, but I like the approach used in req: https://hackage.haskell.org/package/req-3.0.0/docs/Network-HTTP-Req.html#g:5
13:22:41 <pablo[m]3> hey peeps. i've got a question here. is there a way to access the GHC stack size at runtime? i'm asking because i'm writing a scheme implementation in Haskell, and i'd like to limit the interpreter's stack size according to the stack size of the binary itself (so that the interpreter doesn't simply crash when a stack overflow happens)
13:22:59 <pablo[m]3> * hey peeps. i've got a question here: is there a way to access the GHC stack size at runtime? i'm asking because i'm writing a scheme implementation in Haskell, and i'd like to limit the interpreter's stack size according to the stack size of the binary itself (so that the interpreter doesn't simply crash when a stack overflow happens)
13:23:24 <solonarv> pablo[m]3: you can get some memory statistics, yes
13:23:42 <MarcelineVQ> are they even the same stack?
13:24:08 <solonarv> however, the GHC RTS doesn't use a "call stack" in the way most languages do, so the exact thing you asked for is probably either impossible or pointless
13:27:06 <pablo[m]3> <MarcelineVQ "are they even the same stack?"> not really. the scheme stack is just an instance of a Haskell ADT. but i image the program could crash if it gets big enought. does that make sense?
13:27:39 <solonarv> it could, yes
13:27:54 <solonarv> but "how much memory do I have available?" is a surprisingly tricky question
13:28:18 <pablo[m]3> <solonarv "however, the GHC RTS doesn't use"> interesting. have you got any recommendations on how to handle this?
13:28:43 <solonarv> yes: allow whoever is calling your program to set a maximum size.
13:28:48 <ezzieyguywuf> if I want my data type to implement the Sum interface (is interface the right word here?), where would I find out which functions I need to implement in order to do that?
13:29:07 <hyperisco> What do you get when you generalise to  m a -> (a `k` m b) -> m b  ?
13:29:23 <solonarv> ezzieyguywuf: there is no "Sum interface"; I assume you want + to be usable on it?
13:29:24 <pablo[m]3> <solonarv "but "how much memory do I have a"> true, i'm surprised by how imprecise these sort of statics can get
13:29:26 <monochrom> "interface" is definitely the wrong word.  But I don't know what "Sum" refers to either.
13:29:52 <hyperisco> Or just  f (a `k` b) -> f a -> f b  but same idea
13:30:08 <solonarv> ezzieyguywuf: instead of jsut gicing you the answer I would like to guide you so you can find it yourself in the future
13:30:34 <ezzieyguywuf> solonarv: `++`
13:30:46 <solonarv> hyperisco: that seems like a half-done generalization: perhaps it should be f (a `k1` b) -> f a `k2` f b ?
13:31:08 <ezzieyguywuf> solonarv: and yes, i'm fine with not being given the answer directly
13:31:12 <solonarv> ezzieyguywuf: go look at the documentation for ++
13:31:33 <pablo[m]3> <solonarv "yes: allow whoever is calling yo"> cool, i'm already doing that! but still, the program could crash if the user could sets a high enought stack size. is there any way to sensibly limit it?
13:31:40 <hyperisco> solonarv, not sure
13:31:55 <ezzieyguywuf> solonarv: how do I "go look at the documentation"? is `:i (++)` all the documentation that is available?
13:32:08 <solonarv> pablo[m]3: eh, not really; I'd say it's on the user to make sure they don't request more than the system can provide
13:32:27 <solonarv> pablo[m]3: in any case, crashing with an "out of memory" error is a pretty clear failure message!
13:32:31 <pablo[m]3> <pablo[m]3 "cool, i'm already doing that! bu"> i wouldn't mind if there isn't, seems pretty resonable
13:32:58 <pablo[m]3> <solonarv "@pablo: eh, not really; I'd say "> alright, fair enougth
13:33:00 <solonarv> ezzieyguywuf: that is only some of the information, but it is enough to answer this specific question
13:33:12 <hyperisco> solonarv,   (b `k` m c) -> (a `k` m b) -> (a `k` m c)  then and I agree
13:33:22 <pablo[m]3> solonarv: thanks for the help!
13:33:43 <solonarv> hyperisco: what I described is basically just generalized 'fmap'
13:35:02 <solonarv> hyperisco: class (Category k1, Category k2) => Functor k1 k2 f where fmap :: (a `k1` b) -> (a `k2` b)
13:35:03 <hyperisco> solonarv, not sure I see that
13:36:07 <monochrom> "(b `k` m c) -> (a `k` m b) -> (a `k` m c)" looks like Kleisli arrow composition now
13:36:07 <MarcelineVQ> generalized  ap  at least
13:36:31 <solonarv> ah, it should be 'fmap :: (a `k1` b) -> (f a `k2` f b)', apologies
13:37:11 <solonarv> then you get for example: instance Prelude.Monad m => Functor (Kleisli m) (->) m where fmap (Kleisli f) ma = f =<< ma
13:37:40 <hyperisco> I'm just thinking, if you have an AST-like Monad implementation, so say  Bind :: M a -> M (a -> M b) -> M b
13:37:48 <zzualk> ezzieyguywuf: You can define (++) to shadow the one in the prelude. ( import Prelude hiding((++)) ). But most likely, you want to implement the typeclass Monoid
13:37:49 <ezzieyguywuf> solonarv: still a bit confused. all I know now is that `(++) :: [a] -> [a] -> [a]`
13:37:56 <hyperisco> There isn't really any constraint on ->, other than for evaluation, but there may be other interesting choices.
13:38:12 <solonarv> sorry, got sidetracked
13:38:24 <solonarv> ezzieyguywuf: you also know that (++) is a standalone function defined somewhere - which means yuo can't modify or extend it
13:38:34 <ezzieyguywuf> true
13:39:08 <solonarv> however, there *is* a typeclas for "associatively mash things together": Semigroup
13:39:28 <hyperisco> Such as a type constructed with bind is typically opaque in the sense you cannot see through the ->'s without applying them
13:39:53 <mpickering> Is anyone familiar with an idiom in reflex to collect together values from an event until a certain condition is met and then fire another event?
13:39:59 <hyperisco> Which means evaluating other things, possibly with side effects, which maybe isn't what you want
13:40:13 <hyperisco> Whereas choices other than -> do not necessarily have that problem
13:40:17 <solonarv> indeed
13:40:24 * hackage kafka-client-sync 0.1.1.1 - Synchronous Kafka Client  https://hackage.haskell.org/package/kafka-client-sync-0.1.1.1 (felixmulder)
13:40:29 <solonarv> you can choose other categories too, of cuorse
13:41:30 <MarcelineVQ> mpickering: something to do with Accumulator perhaps, Cale should know
13:48:03 <hyperisco> I am thinking you can have some fun from the "Overloading Lambda" work from conal
13:48:24 <monochrom> {-# LANGUAGE OverloadedLambda #-}  :)
13:48:49 <chambln> Is there a more concise way to express this?
13:48:49 <chambln> > let transliterate x = maybe x id $ lookup x $ zip "abc" "xyz"
13:48:51 <lambdabot>  <no location info>: error:
13:48:51 <lambdabot>      not an expression: ‘let transliterate x = maybe x id $ lookup x $ zip "a...
13:49:19 <monochrom> I think it's as good as it gets.
13:49:37 <monochrom> Except for $
13:49:38 <MarcelineVQ> fromMaybe but otherwise yeah
13:49:52 <monochrom> (maybe x id . lookup x) (zip "abc" "xyz")
13:50:56 <solonarv> I would prefer splitting the 'zip' out into a where binding
13:51:06 <solonarv> it's slightly *less* concise, but IMO more readable
13:51:39 <solonarv> transliterate x = fromMaybe x (lookup x mapping) where mapping = zip "abc" "xyz"
13:51:41 <chambln> My actual zip is like 40 chars too
13:51:56 <solonarv> okay, *definitely* put that in a 'where' binding then :D
13:51:59 <chambln> OK cool
13:52:05 <chambln> I like fromMaybe
13:54:00 <solonarv> yes, it is quite nice
13:54:17 <solonarv> just don't write 'fromMaybe x . fmap f', or hlint will yell at you! :P
13:54:19 <hyperisco> I am tending to see -> coming in like a metaprogramming feature. Rather than reinvent all the basics of variables and case analysis, you can just use ->
14:04:52 <nshepperd2> conal's thing seems like ArrowSyntax done right
14:05:58 <ski> what's conal's thing ?
14:07:10 <nshepperd2> iirc he wrote some sort of TemplateHaskell to translate pointful code into any cartesian category
14:07:15 <nshepperd2> for his AD paper
14:08:09 <ski> hm, sounds interesting
14:09:28 <nshepperd2> unlike ArrowSyntax, this is actually useful, because you can use it on categories that don't support `arr`
14:12:05 <nshepperd2> http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf
14:12:49 <ski> ty :)
14:14:00 <emmanuel_erc> So when I consider the composition of two functors  I get certain instances (as given by this page https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Compose.html#t:Compose)
14:15:36 <emmanuel_erc> However, a situation came up while I was coding today in which I effectively wanted to do an alternative-computation (like Nothing <|> Just 4)
14:15:56 <emmanuel_erc> But the only difference was that one of the functors had an alternative and the other didn't.
14:16:53 <emmanuel_erc> Is there a way to get an alternative instance given the composition of two functors given that only one of the functors has an alternative instance.
14:17:03 <emmanuel_erc> s/.$/?/
14:17:11 <nshepperd2> isn't that what the existing instance is?
14:17:23 <nshepperd2> (Alternative f, Applicative g) => Alternative (Compose f g)
14:17:29 <emmanuel_erc> Oh my bad, I totally misread that
14:17:34 <emmanuel_erc> I'm sorry for wasting your time.
14:17:39 <nshepperd2> :)
14:18:35 <nshepperd2> (I wonder if you'd ever want to use the other possible instance: (Applicative f, Alternative g) => Alternative (Compose f g))
14:30:11 <solonarv> nshepperd2: eh? I'm pretty sure your "other instance" is the actual instance
14:30:27 <solonarv> huh, it isn't
14:30:30 <solonarv> how odd!
14:31:36 <MarcelineVQ> good though, seems like it'd be the more useful instance
14:31:53 <solonarv> but I'm confused as to why there is an 'Applicative g' constraint
14:32:01 <solonarv> it doesn't seem to be used!
14:32:25 <jle`> solonarv: it's the superclass
14:33:02 <jle`> solonarv: otherwise you could have an instance of something like Alternative (Compose [] (Map k))
14:33:17 <jle`> which isn't allowed because it would have to be an Applicative instance
14:33:24 <jle`> and there is no Applicative instance for that
14:33:38 <solonarv> oooh, right
14:33:43 <solonarv> makes sense, thanks
15:22:31 <maerwald> anyone tried static GHC builds?
15:27:51 <remexre> is there something like rust's doctests for GHC/Haddock?
15:28:48 <maerwald> @hackage doctest
15:28:48 <lambdabot> http://hackage.haskell.org/package/doctest
15:30:54 <remexre> oh, nice
15:31:06 <remexre> thx
15:46:54 * hackage patch 0.0.2.0 - Infrastructure for writing patches which act on other types.  https://hackage.haskell.org/package/patch-0.0.2.0 (JohnEricson)
16:30:53 <remexre> I've got a type like Foo (n :: Nat), and a function foo :: Int -> Foo n; foo @2 3 works in the same module, but not from a different module('s doctests); any clue why?
16:31:24 <remexre> error message is "Cannot apply expression of type ‘t1’ to a visible type argument ‘3’" which makes no sense to me...
16:33:26 <solonarv> remexre: is 'foo' actually in scope?
16:34:09 <solonarv> I've noticed that when you write a type application on an out-of-scope identifier, instead of an out-of-scope error you get that "can't apply ..." error
16:34:24 <remexre> ... /me facepalms
16:34:26 <remexre> no, no it's not
16:34:51 <remexre> that did it, thanks
16:34:52 <solonarv> can't blame you tbh, that error message really needs fixing
16:35:02 <solonarv> (maybe it *is* fixed? lemme check...(
16:37:37 <solonarv> ))
16:38:34 <electricityZZZZ> is there a minimal example of a haskell servant server with a postgres db connection pool which can actually compile ? i have managed to find this, but it's not a .hs i can just compile and check that it works... https://github.com/haskell-servant/servant/blob/master/doc/cookbook/db-postgres-pool/PostgresPool.lhs
16:39:59 <solonarv> electricityZZZZ: "it's not a .hs I can just compile and check that it works" - no, but it's a .lhs that you can just compile and check that it works
16:40:32 <solonarv> @hackage markdown-unlit -- you'll need this
16:40:32 <lambdabot> http://hackage.haskell.org/package/markdown-unlit -- you'll need this
16:41:04 <solonarv> oh, actually there is a cabal file
16:41:24 <solonarv> okay, you can actually just build this
16:42:10 <electricityZZZZ> heh ok, i guess it's like a notebook eh,... makes me cringe a bit though
16:42:24 * hackage lzlib 0.3.1.1 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.3.1.1 (vmchale)
16:42:51 <solonarv> it's not really like a notebook, it's more like... instead of specially marking parts of the file as "this is a comment", you specially mark parts of the file as "this is code"
16:43:17 <maerwald> that's the technical explanation of what lhs is, not the actual
16:43:31 <solonarv> yes, I was about to link the wikipedia article ;)
16:43:39 <solonarv> https://en.wikipedia.org/wiki/Literate_programming
16:43:50 <maerwald> it is how we should be programming
16:44:00 <maerwald> or even better... in pictures, not code
16:44:06 <maerwald> and not words
16:45:57 <solonarv> remexre: apparently this is a known issue: https://gitlab.haskell.org/ghc/ghc/issues/12794
16:46:20 <solonarv> electricityZZZZ: in any case, building it isn't any more difficult than building any other cabal package
16:48:38 <remexre> okay, looks like it's fixed in the repo then
16:49:10 <solonarv> remexre: it is? I don't see any indication that it's fixed
16:49:22 <solonarv> 8.8.2 (which released just days ago) still has the bug
16:49:33 <remexre> oh, hm
16:49:39 <remexre> I followed linked tickets and found https://gitlab.haskell.org/ghc/ghc/issues/13834
16:50:41 <solonarv> ah, that seems to have more discussion
16:51:45 <remexre> unrelatedly, w/ GHC.TypeLits.Nat, is there any way to recurse on the Nat in instances? e.g. I'd like to be able to write smth like:
16:51:59 <remexre> instance Show (Foo 0) where show = "z"
16:52:23 <remexre> instance Show (Foo (Succ n)) where show = "one plus " <> show @(Foo n)
16:52:57 <remexre> er I guess the types don't work for Show, but you get the point
16:54:12 <solonarv> IIRC the answer is "yes, but you need UndecidableInstances and an overlap pragma"
16:54:42 <remexre> er, the "Succ n" part is the part I can't express
16:56:09 <crestfallen> what is the state monad? I will die before I find out :)
16:56:53 <remexre> crestfallen: so let's say you wanted to compute a value of type a with some mutable state of type b
16:57:23 <remexre> you could represent that as b -> (b, a)
16:57:33 <solonarv> the 0 instance can stay as is, the other one becomes: instance {-# OVERLAPPING #-}  (Blah (... m ...), n ~ (m + 1)) => Blah (... n ...) where ...
16:57:56 <remexre> crestfallen: the monad gives you some combinators for combining computations expressed this way together
16:58:43 <remexre> solonarv: oh, the typechecker can run + backwards? didn't realize that was possible for type families
16:58:48 <solonarv> '+' is treated specially, meaning that GHC can figure out any one of p, q, r in 'p ~ (q + r)' if it knows the other two
16:58:56 <remexre> ah, neat
16:58:59 <solonarv> it's unfortunately not possible (yet?) for type families in general
16:59:39 * solonarv mumbles something about an adjunction
17:00:09 <remexre> I know that's category theory, but I died like a chapter into category theory in context, so no clue what it is lol
17:00:36 <remexre> been meaning to pick up seven sketches in compositionality and see if it's more approachable to non-math-heads
17:02:27 <remexre> oh, hm, ghc doesn't seem to be able to realize that this mean that an instance exists forall n. Foo n
17:02:57 <remexre> at least, another module's derived Show instance gets "Could not deduce: (m0 + 1) ~ n arising from a use of ‘showsPrec’"
17:04:31 <remexre> I guess time to go off and do more reading
17:06:24 <solonarv> remexre: yeah, GHC is not very good at deducing general facts about Nat
17:08:54 <solonarv> although the 'm0' makes me suspect that you have two 'm' type variables which you intend to be the same, but actually aren't
17:11:08 <remexre> that's from a 'deriving instance Show (Bar a)' where 'data Bar :: * -> * where Foo :: Foo n -> Bar (Foo n); ...'
17:11:15 <remexre> no m actually appaears
17:12:54 <solonarv> when you write a 'deriving instance' declaration, you have to specify any constraints on the instance
17:13:24 <solonarv> for example, 'deriving instance Show (Maybe a)' fails because it's missing 'Show a'
17:13:39 <solonarv> you would have to write 'deriving instance Show a => Show (Maybe a)'
17:13:51 <remexre> there shouldn't be any in this case though; there should be Show (Foo n) for all n -> no constraint needed, right?
17:14:14 <solonarv> yes, but GHC can't figure out that 'forall n. Show (Foo n)' holds
17:14:51 <remexre> tbh just gonna do the Show instance unsafely
17:14:57 <remexre> since the n is a phantom parameter anyway
17:15:22 <solonarv> you might be able to fix this with a 'deriving instance Show a => Show (Bar a)'
17:15:26 <solonarv> it is actually not phantom
17:15:38 <solonarv> its role should be 'nominal'
17:18:54 <remexre> because it gets applied to a type family?
17:19:39 <solonarv> no, because it's used as an argument to a GADT constructor's return type
17:19:50 <remexre> also the Show a works but breaks something elsewhere; tbh just gonna do the "unsafe" one (since it's not actually memory-unsafe, just potentially semantics-breaking)
17:20:27 <solonarv> ...if you don't care about broken semantics, why are you bothering with this 'Show (Foo n)' instance at all?
17:20:37 <crestfallen> remexre, very sorry had to step away.. thanks reading now.
17:21:34 <remexre> solonarv: I'm confident I can implement the handful of primitive operations I need without breaking the invariants, but I want the larger operations composed of these ones to be checked
17:21:58 <solonarv> hum, makes sense I suppose
17:22:11 <solonarv> do post your code if you want more detailed advice, though
17:23:27 <remexre> this is work code, sadly; hopefully it ends up open-sourced at some point though
17:23:43 <solonarv> ah, I see
17:29:13 <ezzieyguywuf> in python, if I don't know what something does, I can issue `help(somePythonObjectInScope)` to get more info. Is there something similar in ghci? Is that what `:info` is ?
17:29:39 <solonarv> ezzieyguywuf: :info only gives very bare-bones information
17:29:59 <ezzieyguywuf> solonarv: that's what I've found
17:30:12 <ezzieyguywuf> what other documentation is available?
17:30:30 <solonarv> in newer GHC, there is also :doc, which gives you the documentation for that thing
17:30:37 <maerwald> :doc
17:30:45 <remexre> https://hoogle.haskell.org/ is also a godsend
17:31:14 <maerwald> fmap has no documentation, gosh
17:31:18 <solonarv> yeah, I usually just check the docs on hackage.haskell.org
17:31:32 <ezzieyguywuf> what is hackage vs hoogle?
17:31:57 <solonarv> hackage is a repository of Haskell packages (HAskell + pACKAGE)
17:32:01 <remexre> hackage == package repos, hoogle == search engine
17:32:19 <solonarv> hoogle is a search engine (Haskell + gOOGLE)
17:32:34 <remexre> hoogle's results bring you to hackage
17:32:39 <ezzieyguywuf> ah, i get it
17:32:45 <solonarv> maerwald: that is because the docs are tied to Functor
17:32:47 <ezzieyguywuf> ok, so I should get comfortable searching/browsing around on hackage then
17:32:56 <solonarv> but :doc is still very experimental and very new
17:33:25 <solonarv> ezzieyguywuf: you can also build haddocks locally and get a bunch of html pages much like the docs on hackage
17:33:26 <maerwald> solonarv: I don't understand
17:33:35 <solonarv> maerwald: try :doc Functor
17:33:41 <maerwald> of course fmap is tied to functor
17:34:14 <solonarv> I mean that the documentation specifically is all in Functor's doc comment
17:34:33 <mniip> who needs documentation for fmap
17:34:33 <maerwald> doesn't mean ":doc fmap" must be broken
17:34:36 <solonarv> perhaps :doc could fall back to the containing entity when the target doesn't have any documentation...
17:34:40 <mniip> its type signature uniquely determines what it is
17:35:00 <maerwald> mniip: it's a sign that there might be more class things broken
17:35:10 <ezzieyguywuf> solonarv: is there any advantage (other than not needing a network connection) to building this local stuff?
17:35:13 <mniip> (/s)
17:35:42 <solonarv> ezzieyguywuf: the other big advantage is that it works for packages that aren't on hackage!
17:35:48 <mniip> ezzieyguywuf, occasionally you want to use a different version of haddock than the one on site
17:36:03 <mniip> due to a bug, new feature, etc
17:36:06 <ezzieyguywuf> what is haddock? lol
17:36:06 <mniip> or that
17:36:19 <mniip> haddock is the program that generates the html from docs
17:36:26 <ezzieyguywuf> ah, got it
17:36:29 <solonarv> haddock = HAskell + fish + DOCumentation
17:36:43 <mniip> that's not a plus
17:36:49 <ezzieyguywuf> fish shell?
17:36:52 <mniip> haddock = fish | HAskell + DOCumentation
17:37:03 <solonarv> no, haddock is a type of prepared fish
17:37:11 <ezzieyguywuf> har har
17:37:20 <ezzieyguywuf> I'm just surprised that it would require a specific shell
17:37:28 <solonarv> it doesn't :>
17:37:46 <solonarv> "The haddock (Melanogrammus aeglefinus) is a saltwater fish from the family Gadidae..."
17:38:08 <ezzieyguywuf> lol, ah hah
17:38:10 <ezzieyguywuf> I got it
17:39:44 <mniip> yea at work we generate haddocks for our production packages that are nowhere near hackage
17:57:54 <ezzieyguywuf> why doesn't `tail . tail [1,2,3]` do the same as `tail $ tail [1,2,3]`
17:58:49 <shachaf> Because function application is stickier than any operator.
17:59:05 <ezzieyguywuf> "function operation" is `.`?
17:59:47 <shachaf> "function application" is putting two things next to each other, like "f x".
18:00:43 <glguy> What if the application is accepted
18:01:59 <shachaf> Then the applicant becomes a full-fledged function, with all the powers and responsibilities designated thereto.
18:02:00 <ezzieyguywuf> I thought `f . g x` was supposed to be akin to "f(g(x))" from math. in other words, run g(x) and send result to f(x)
18:02:27 <amalloy> that's f . (g x)
18:02:33 <shachaf> You thought that, and then you ran an experiment to test it, and now you know that it's not true.
18:02:41 <shachaf> (Good work!)
18:02:46 <amalloy> but you're thinking of (f . g) x
18:05:54 <ezzieyguywuf> hm
18:06:02 <ezzieyguywuf> I guess I'm confused about how `.` is meant to be used then
18:06:32 <ezzieyguywuf> or rather, I can't think of a way to make `f . g x` to work
18:09:29 <Clint> > let f = negate, g = (+), x = 4 in f . g x $ 8 -- ezzieyguywuf
18:09:32 <lambdabot>  <hint>:1:15: error: parse error on input ‘,’
18:09:34 <Clint> er
18:09:43 <Clint> > let f = negate; g = (+); x = 4 in f . g x $ 8
18:09:45 <lambdabot>  -12
18:13:36 <energizer> how do i find the docs of a package? https://hackage.haskell.org/package/directory
18:13:37 <ezzieyguywuf> hrm, that's kind of cheating though, as you tacked on a `$ 8`
18:13:58 <ezzieyguywuf> the original problem was "what is a case where `f . g x` would work or be useful"
18:14:08 <ezzieyguywuf> maybe the answer is "it is not syntactically sound"....
18:14:25 <shachaf> "f . g x" means (\y -> f (g x y))
18:14:32 <shachaf> It's useful when you want that.
18:15:20 <energizer> do haskell packages... have documentation?
18:15:31 <amalloy> ezzieyguywuf: length . filter even
18:15:38 <ChaiTRex> energizer: Yes, at hackage.
18:15:55 <energizer> ChaiTRex: where is the documentation? https://hackage.haskell.org/package/directory
18:16:30 <ChaiTRex> energizer: Here it is for vector: https://hackage.haskell.org/package/vector
18:16:52 <MarcelineVQ> you're looking at it, click on the name of the module you want to see more
18:17:11 <energizer> got it, thanks :)
18:18:20 <ezzieyguywuf> shachaf: is it (\y -> f (g x y)) or (\y -> f ( g y x))?
18:18:39 <ezzieyguywuf> is it recursive? hah, i'm a bit confused
18:18:54 <shachaf> ezzieyguywuf: I bet you could design an experiment to figure it out, just like you did for the other question.
18:29:21 <zebrag> ghcide, anyone has tried it?
18:29:54 <jle`> zebrag: if you have a question, i recommend just asking it
18:29:58 <shachaf> gh-cide sounds a little violent for this channel.
18:30:36 <MarcelineVQ> shachaf: you are full of beans tonight
18:33:28 <zebrag> I'd like to try the lsp concept, and would like something not too complicated, and there are two options for that, and I'm confused
18:45:43 <fog> this function network idea is really cool
18:46:14 <fog> like a deep net but with arbitrary types as signals
18:46:44 <fog> then a neural net is just a restriction of this...
18:47:33 <fog> it can have networks as neurons, since it has a function at each node, and a network is just defined as a restriction of a functionNet, which is a function of several variables that are the input signals
18:48:04 <fog> and return networks from these functions, and pass them as arguments to downstream neurons
18:48:26 <fog> which is basically just supplying functions as arguments to the function at each node
18:49:21 <fog> which means it could be used to represent genetic programming, where nets can be input and combined into a returned network
18:51:06 <fog> then at deeper layers, more complex networks can be constructed and used at subsequent neurons downstream. 
18:51:40 <hololeap> fog: which function network idea?
18:51:48 <fog> https://pastebin.com/raw/9z1X8ucv
18:51:54 <fog> thats all i have of it so far
18:52:19 <fog> still needs the reification done, and then possibly another representation of a graph for the designation of edges
18:52:39 <fog> like an upper triangular Boolean edge connectivity matrix
18:53:34 <fog> then the nets that are created can be saved as modules exporting this type level scaffold
18:54:37 <fog> as all the elemental functions and input arguments are to be reified into local scope for the evaluation of the function network into its return type
18:55:06 <fog> there also needs to be a function to extract a type from the returned type so there can be multiple outputs
18:57:03 <fog> and a way to ensure from the type demanded by the reification function, that an explicit scope of the available global functions and growing list of available vanues at different positions to accumulate with the inputs allowing the arguments at each node to be provided by the reified instance of Has ()
18:57:32 <hololeap> what is this '=' doing here: type family ToFunction' (xs :: [*]) (o :: *) = (f :: *) where
18:58:12 <fog> probably an artifact from trying to see if it could be made injective
18:58:46 <hololeap> i think you're missing my question; i'm not familiar with what that syntax means
18:58:48 <fog> it just binds the `f' into scope for use in an `| f -> o' statement
18:59:33 <hololeap> oh is that TypeFamilyDependencies?
18:59:40 <fog> yes
18:59:59 <hololeap> ok. i've never used it before
19:00:00 <fog> you could just write the kind returned by the type family,  but this gives a way to refer to this type
19:00:43 <fog> :: Type becomes = (f :: Type) 
19:00:55 <hololeap> oh gotcha
19:02:28 <fog_> is the rest of the paste legible? 
19:04:57 <hololeap> not so much to me. i'm struggling with it. but i think that's just because i'm not at the level where i can parse it easily
19:06:44 <hololeap> documentation would help :)
19:08:47 <fog_> basically you just define global functions and then a graph (eg, from an adjacency matrix with type labled rows/columns) can be evalueated as a function applied to arguments reified into scope by sequential evaluation of the layers of the net
19:10:06 <fog_> then to make eg a traditional net, where there are just Doubles everywhere and tanh functions, only this needs to be a Function definition
19:10:43 <fog_> and there is a mechanism to label the types with the positions so the arguments from the correct node can be retrived just using its type and position
19:11:35 <fog_> the last thing to do is to write the evaluation, where each node needs to reify the value resulting from the evaluation of the function at that node with the arguments reified into scope so far during evaluation or from reified inputs
19:12:36 <fog_> also adding an explicit scope, again as a constraint which can be added to by returing an updated constraint continuation storing the newly reified instance resulting from the evaluation of the result at a neuron
19:12:41 <hololeap> i think you are assuming that i know more than i actually do about these topics
19:13:35 <fog_> a really result of this is that there is intrinsic lazy evaluation by the mechanism of recursive instances used to evaluate the functions by retrieving them from the a constraint 
19:14:08 <fog_> where this also allows that the functions dont need careful matching up of values from a carried result type which would need some lookup mechanism
19:14:44 * hololeap sighs
19:14:52 <fog_> automating the task of matching input args up over edges to the typechecker seems like it allow low cost retrival
19:16:22 <fog_> hololeap: dont worry! i can only describe what I think might help understanding the idea
19:16:53 * hackage bzip-signature 0.1.0.0 - Backpack signature for BZip compression  https://hackage.haskell.org/package/bzip-signature-0.1.0.0 (vmchale)
19:17:20 <hololeap> just because you started all that with "basically," doesn't mean what followed was by any means basic
19:19:33 <fog_> most of the challenge is getting a way to help the user construct things which satifsy the requirements that the types match up over edges
19:20:56 <fog_> ie, somehow proving that casting from some representation of the graph in a certain way to the resulting FunctionNet (like how is done from Scaffold) is guarantied to satisfy the necessary constraints
19:21:25 <fog_> basically proving that given inputs that the function is well formed and will return an output upon evaluation
19:21:43 <fog_> ie that the functionNet typechecks...
19:22:16 <fog_> as it is the representation of a program as nested function evaluation, basically abstracting over lambda binding
19:23:03 <Jonathan15> I am looking to have a fixed length array which is very space efficient.  I think what I want if the unboxed vector from `fixed vector` package, but I am very confused on how it is actually used.
19:24:06 <dmwit> What would go wrong if you used a standard variable-length unboxed vector, and took it on yourself to put the right number of elements in?
19:24:23 <dmwit> I'd strongly recommend starting there if you haven't done much type-level programming in the past.
19:24:39 <dmwit> Yes, it's true: the compiler won't catch as many bugs. But it is also *significantly* simpler.
19:24:59 <fog_> given then that writing a typechecking function consists of providing a network architecture and reified function calls at the nodes, given a set of available functions in scope it should be easy to enumerate the valid programs
19:25:37 <Jonathan15> Well, it would be an excuse to learn more type-level stuff...
19:26:23 <Jonathan15> It seems silly to use a variable length vector for a static length data but I guess Haskell is not very smooth at that stuff.
19:26:57 <fog_> the types corresponding to the names at the nodes specify the number of input edges and the types of the nodes restricts where these edges can originate in order to typecheck
19:28:23 <fog_> giving some kind of space within which to perform range opperations to obtain all valid functions given some choice of functions in scope
19:28:36 <Jonathan15> I guess it wouldn't really be meaningfully faster or more efficient than a dynamic length one.
19:29:01 <Jonathan15> I'll just go with that a switch over when I am feeling adventurous.
19:29:07 <Jonathan15> Thakns.
19:29:23 * hackage reflex-fsnotify 0.2.0.0 - reflex-frp interface for watching files  https://hackage.haskell.org/package/reflex-fsnotify-0.2.0.0 (abrar)
19:30:57 <fog_> then, even if the functions are countable, it is still too costly to enumerate them all, but the representation (in terms of an element of the subset of typed adjacency matricies which satisfy typechecking) is a smaller space than that of all adjacency matricies, so it would be good to have a way to produce them in a low cost way
19:31:24 <fog_> which would consist of a way of generating programs from a set of input functions
19:33:55 <fog_> which then essentially is a genetic algorithms if its the result of a function which by passing functions as arguments over the edges, has the idea of passing and combining networks as a refinement
19:35:46 <fog_> then another nice analogy with neural nets is available, as the ideas of generative and classification nets, and multivaued functions as measures like a classifier, returning functions like a generative model producing nets
19:37:02 <fog_> giving network modifying morphisms as the result generative classifier networks
19:37:34 <fog_> taking and returning nets as arguments
19:38:00 <fog_> measure valued measures on measures...
19:38:53 <fog_> with measures being parametric models, ie functions, corresponding to nets
19:40:36 <hololeap> fog_: why not write this up into a blog post?
19:40:54 * hackage reflex-ghci 0.1.3.0 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.3.0 (abrar)
19:42:37 <sicklorkin> > let splitCamelCase =  groupBy (\a b -> isUpper a && (not $ isUpper b))
19:42:39 <lambdabot>  <no location info>: error:
19:42:39 <lambdabot>      not an expression: ‘let splitCamelCase =  groupBy (\a b -> isUpper a && ...
19:43:22 <sicklorkin> > groupBy (\a b -> isUpper a && (not $ isUpper b)) "TMobile"
19:43:24 <lambdabot>  ["T","Mobile"]
19:43:49 <sicklorkin> > groupBy (\a b -> isUpper a && (not $ isUpper b)) "ATTMobile"
19:43:50 <lambdabot>  ["A","T","T","Mobile"]
19:45:18 <sicklorkin> Should splitCamelCase return ["ATT", "Mobile"] or would one expect otherwise?
19:46:14 <sicklorkin> >  map concat $ groupBy ((==) `on` length) $ groupBy (\a b -> isUpper a && (not $ isUpper b)) "ATTMobile"
19:46:16 <lambdabot>  ["ATT","Mobile"]
20:12:42 <pounce> how can i run an IO action a certain number of times
20:12:53 <glguy> :t replicateM_
20:12:54 <lambdabot> Applicative m => Int -> m a -> m ()
20:13:01 <pounce> ty
20:13:09 <pounce> was using replicateM instead X_X
20:13:56 <pounce> god, i was running replicateM to build up a list of things and then gave that to putstr
20:14:15 <pounce> turns out just putting the putstr in the replicateM is so much faster
20:16:40 <pounce> does the IO [a] from replicateM mean that it can't hold the array in a thunk and has to generate it all at onec?
20:19:34 <dmwit> It's not an array, and roughly yes.
20:23:19 <monochrom> "IO [a]" tells you absolutely nothing.
20:23:22 <pounce> list.... sorry
20:23:51 <pounce> IO [String] :?
20:24:07 <monochrom> Because it could be "return [0..]" or it could be "x <- foo; xs <- recursive call; return (x:xs)".  replicateM (and mapM etc) is the latter.
20:24:58 <monochrom> You can see how the latter is totally unlazy for IO. (But totally lazy too if State.Lazy. Don't assume anything.)
20:25:47 <monochrom> There is no rule of thumb. There is no simple answer. There is always rigorous analysis. Tough.
20:26:25 <monochrom> For rules of thumbs and simple answers please sign up for politics instead of programming.
20:26:54 <pounce> well the monad was IO
20:26:59 <pounce> that's why i was asking....
20:27:05 <pounce> sorry if that were not clear
20:27:37 <monochrom> You could take a look at replicateM's source code.  Or even better, re-implement it yourself.
20:28:18 <vkraven[m]> @monochrom +1 for the politics comment, enjoyed that
20:28:18 <lambdabot> Unknown command, try @list
20:28:31 <pavonia> We should have System.IO.Lazy and .Strict for a cleaner separation
20:28:56 <monochrom> System.IO.Lazy = System.Unsafe.IO.unsafeInterleaveIO
20:29:10 <monochrom> Err, System.IO.Unsafe.unsafeInterleaveIO
20:29:44 <monochrom> I once invented "unsafeInterleaveIO-passing style" in jest. It's more fun than CPS.
20:30:08 <pavonia> Well, not for e.g. replicateM
20:30:53 <pavonia> Or wait, would replicateM (unsafeInterleaveIO foo) even work?
20:31:20 <monochrom> No, you need "xs <- unsafeInterleaveIO (the recursive call)".
20:32:50 <monochrom> Either that, or build unsafeInterleaveIO into >>= like State.Lazy does.
20:36:32 <nshepperd> replicateM (unsafeInterleaveIO foo) would do something very confusing
20:39:57 <nshepperd> % do { ref <- newIORef 0; xs <- Control.Monad.replicateM 10 (unsafeInterleaveIO $ readIORef ref >>= \v -> writeIORef ref (1+v) >> return v); return xs }
20:39:57 <yahb> nshepperd: [0,1,2,3,4,5,6,7,8,9]
20:40:14 <nshepperd> % do { ref <- newIORef 0; xs <- Control.Monad.replicateM 10 (unsafeInterleaveIO $ readIORef ref >>= \v -> writeIORef ref (1+v) >> return v); return (Prelude.reverse xs) }
20:40:14 <yahb> nshepperd: [0,1,2,3,4,5,6,7,8,9]
20:40:35 <nshepperd> spooky
20:46:39 <amy_monnet> Hey everyone :)
20:51:29 <amy_monnet> What is the purpose of the DeriveGeneric ghc language extension?
20:53:00 <iqubic> So, I have a megaparsec parser, number, that parses a single signed number. I am using it in this way: http://dpaste.com/0495GZJ
20:53:07 <iqubic> Is there a better way to write that?
20:54:54 * hackage haskell-stack-trace-plugin 0.1.1.0 - haskell-stack-trace-plugin  https://hackage.haskell.org/package/haskell-stack-trace-plugin-0.1.1.0 (waddlaw)
20:59:05 <MarcelineVQ> is ' ' the only whitespace character you wish to ignore? if not there's a  space  parser already. you could write it as a one liner too but it's not like it's clearer   (,,) <$> sn <*> sn <*> sn where sn = space *> number
20:59:13 <nshepperd> amy_monnet: it lets ghc generate instances of the Generic type class for your data types
21:00:56 <nshepperd> amy_monnet: if your question is what Generic itself is good for, you can read https://wiki.haskell.org/GHC.Generics
21:01:54 <xpika> are there functions written in haskell for calculating trignometric functions like sin with answers in the form of square roots?
21:02:44 <xpika> i know wolfram alpha gives 1/sqrt(2) for sine(pi/4)
21:07:05 <iqubic> Is it possible to see which of the modules I'm importing is responsible for this name clash? http://dpaste.com/0G7KCQ1
21:09:18 <iqubic> I'm not importing Data.Map here.
21:11:18 <iqubic> Reloading GHCi fixes this error.
21:25:50 <ezzieyguywuf> in the definiton of sum `sum :: Num a => t a -> a`, what does the `t` mean?
21:26:03 <dmwit> Wow. Making it to 7498 entries in ghci is kind of impressive.
21:26:17 <dmwit> ezzieyguywuf: It is a type variable, like `a`.
21:26:46 <ezzieyguywuf> so how is that description read? "a `t` of `a` is used to return a `a`"?
21:27:16 <dmwit> For example, it can be instantiated to Maybe, [], or (Foo,), to get sum :: Num a => Maybe a -> a, sum :: Num a => [a] -> a, and sum :: Num a => (Foo, a) -> a, respectively.
21:28:06 <dmwit> That seems like a plausible reading.
21:28:16 <ezzieyguywuf> hrm
21:30:53 <ezzieyguywuf> how might I use sum directly?
21:31:03 <doyougnu> I usually read stuff like that like: "Given an a, in the context, t, where I know t of a supports numerical operations, I can return/compute/conclude an a"
21:31:42 <ezzieyguywuf> hmm, `sum [1,2,3]` does what you'd expect
21:31:54 <ezzieyguywuf> but I'm struggling to see how this connects to the `t a` thing
21:35:10 <dmwit> ezzieyguywuf: Did you know you can write `[a]` as the application of the type constructor `[]` to `a`?
21:35:15 <dmwit> > [1,2,3,4,5] :: [] Int
21:35:17 <lambdabot>  [1,2,3,4,5]
21:35:36 <doyougnu> ah my reading was wrong, ignore me pls
21:35:39 <dmwit> So: `sum :: [] Int -> Int`. The `t` is `[]`, the `a` is `Int`.
21:36:29 <dmwit> (And there is a `Num Int` instance lying around.)
21:37:04 <ezzieyguywuf> ah, so the `t a` means that "a `t` can be constructed from an `a`"
21:37:10 <dmwit> no
21:38:04 <iqubic> `t a` means that the type constructor `t` is being applied to a type `a`
21:38:06 <dmwit> In this case, it means that `t` is some kind of container, and the elements in a `t a` have type `a`.
21:38:33 <dmwit> ezzieyguywuf: `t` is a variable that ranges over parameterized types.
21:38:41 <dmwit> (Or "generics" if you come from Java, I guess?)
21:38:48 <dmwit> The `a` is the parameter.
21:39:38 <ezzieyguywuf> so if I said `data MyData = Something Int | MoreStuff Int Int`, conceivably I could call `sum` where `t` would be `MyData` and `a` could be `Something` or `MoreStuff`.....right?
21:39:54 <dmwit> No, `MyData` is not a parameterized type.
21:40:21 <ezzieyguywuf> hm. ok perhaps I should sleep and come back to this tomorrow
21:40:24 <ezzieyguywuf> thank you all for the help!
21:40:48 <dmwit> You could write like `data MyData a = Something a | MoreStuff a a`.
21:41:18 <dmwit> Then you could call sum like `sum (Something 3)`. The `t` would be `MyData`, and the `a` would be `Int`.
21:44:10 <iqubic> Well, only if you derive Foldable for that datatype.
21:49:35 <iqubic> Well, it turns out that hardest part of doing Advent of Code is the parsing.
21:50:33 * dmwit squints
21:53:01 <iqubic> I have no idea why this megaparsec parser is failing in this way. http://dpaste.com/2Q9W695
21:54:31 <iqubic> Anyone know what's going on there?
21:55:29 <MarcelineVQ> I would guess parseline expects a line ending?
21:56:03 <MarcelineVQ> so, if that's the case, your test input needs to include one or parseLine needs to change
21:56:44 <iqubic> Ah. That is the issue.
22:13:55 * hackage hakyll-dhall 0.2.4.0 - Dhall compiler for Hakyll  https://hackage.haskell.org/package/hakyll-dhall-0.2.4.0 (jle)
22:23:28 <remexre> should it be the case that GHC.TypeLits.KnownNat (n + 1) if KnownNat n is in scope?
22:25:02 <jle`> logically yes, but it's not a built-in rule
22:25:22 <jle`> remexre: this plugin adds it in as a deduction rule the typechecker can use
22:25:24 <jle`> https://hackage.haskell.org/package/ghc-typelits-knownnat
22:25:31 <remexre> ah, thanks
22:26:11 <jle`> np
22:26:26 <jle`> i'm not really sure why it's not built-in either, but it might be to offload some of the complexity outside of the compiler itself
22:29:00 <remexre> hm, haddock doesn't like it now
22:29:14 <remexre> do I need to do something special on that front? (never used a compiler plugin for GHC before)
22:30:21 <jle`> yeah there's a haddock bug that is unfixed in the current releases
22:30:29 <remexre> :(
22:31:03 <dmj`> ;_;
22:31:23 <jle`> remexre: there are some work-arounds here https://github.com/haskell/haddock/issues/900
22:31:31 <jle`> that should get things to build until the working version is out
22:31:58 <remexre> alright, thanks!
22:35:57 <erikd> i am trying to get the grenade library compiling with ghc-8.8 and get this: https://pastebin.com/9QCSzKu4
22:36:02 <erikd> clues?
22:36:36 <iqubic> Is there a good sort of function "isSublistOf :: Eq a => [a] -> Bool"
22:37:10 <iqubic> So, isSublistOf "north" "north pole" == True
22:37:51 <erikd> iqubic: isInfixOf
22:38:16 <iqubic> Nice.
22:39:39 <iqubic> Thanks that works.
22:40:15 <erikd> iqubic: have you seen hoogle?
22:40:32 <iqubic> erikd: I have.
22:41:41 <iqubic> I was looking for things like "contains" or "isSublistOf" I keep forgetting I can search by type signature.
22:41:55 <erikd> in hoogle you could have entered just the type signature https://hoogle.haskell.org/?hoogle=Eq+a+%3D%3E+%5Ba%5D+-%3E+%5Ba%5D+-%3E+Bool&scope=set%3Astackage
22:42:30 <iqubic> I know. I keep forgetting that feature exists.
22:42:46 <erikd> one of the best features of haskell :)
22:43:42 <iqubic> Technically not a haskell feature.
22:44:08 <erikd> no, but a feature that haskell does have
22:50:03 <dmj`> gm
23:08:56 <remexre> hm, doctest now is having trouble finding the plugin, even when I add it as a dep to its testsuite
23:34:51 <remexre> ah, cabal-doctest fixes it
23:34:55 <dmwit> erikd: Have you by chance modified grenade's constraints on the singleton package?
23:35:35 <dmwit> Looks like recent singletons versions switched Sing from a data family to a type family. You'll need to use an old one, therefore (and it looks like grenade already specifies a suitable upper bound, hence my question).
