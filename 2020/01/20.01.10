00:22:38 <sicklorkin> is there an alternative to mfilter that isn't constrained by MonadPlus?
00:26:26 <koz_> :t mfilter
00:26:29 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
00:26:40 <koz_> sicklorkin: What kind of constraint are you after?
00:31:24 <jackdk> sicklorkin: witherable's Data.Witherable.filter has the right shape but I don't know what effects you want: https://hackage.haskell.org/package/witherable-0.3/docs/Data-Witherable.html#v:filter
01:19:50 <nickednamed> Hello all. I'm back with the same noob question: I want to make a little project for myself consiting of programming problems (think Euler, 99 Haskell problems, DailyProgrammer, etc.), and I want to use this as a means to practice Haskell, BDD, testing, profiling, benchmarking, cabal, etc. I was advised to organise my project as a set of executables (one for each problem/solution) so I can run each 
01:19:57 <nickednamed> individually with `cabal run` (for example). I am unable to get this to work with a test-suite as no modules are exposd to the test suite. So I was then advised to use libraries. I've read through the cabal documentation, etc., but I'm still confused. How can I organise this project to achieve my goals (one executable per problem/solution, testable, profilable, benchamarkable, etc.)? Sorry for the 
01:20:03 <nickednamed> long post.
01:21:44 <koz_> Why not do one project per problem?
01:21:56 <koz_> Jamming them all into one seems ... suboptimal.
01:23:35 <Solonarv> eh, they might be related or something
01:23:36 <sclv> nickednamed: why do you want to run them _and_ have a test suite?
01:23:45 <nickednamed> koz_: perhaps, but the number of problems is growing unwieldy, plus it makes version control easier (for my little brain). Also, and now most importantly, I am annoyed as hell I can't seem to do it. I want to do it for the plain fact that it should be possible, but I can't do it.
01:23:56 <sclv> the "standard" configuration would be to have a single library, with one module per problem
01:24:19 <sclv> then have a seperate executable per problem that imports the lib
01:24:32 <sclv> and then the test suite can also import the lib
01:24:42 <koz_> nickednamed: For the version control specifically, you can just have a directory which you put into VC, then subdirs with the projects inside it?
01:24:42 <Solonarv> or you could have multiple libraries, too
01:24:43 <sclv> its a bit verbose
01:25:09 <sclv> but imho you don't need test-suites and also executables for these problems
01:25:15 <Solonarv> they could even be separate packages in one project!
01:25:30 <sclv> a test suite really just _is_ an executable that you invoke in a slightly different way
01:25:35 <Solonarv> I am inclined to agree, those problems tend to be fairly small and not really need a full test suite
01:26:11 <sclv> if you do want tests, you could expose tests in the executables themselves, and just have them get run only when a certain flag is passed
01:26:55 <nickednamed> sclv: Ah, one library with a seperate executable for each module. Makes sense. And yes, will be verbose, but that's fine for me.
01:27:23 <sclv> that's closest to the architecture of a real "production" app
01:27:23 * hackage cabal-toolkit 0.0.6 - Helper functions for writing custom Setup.hs scripts.  https://hackage.haskell.org/package/cabal-toolkit-0.0.6 (sgraf812)
01:27:52 <nickednamed> sclv: Why wouldn't I need executables and a test-suite, if my goal is to have tests *and* be able to execute problems/solutions seperately on the command line?
01:28:10 <sclv> i just mean that all tests are is executables
01:28:15 <sclv> that import a test library
01:28:24 <sclv> and then either have a success or failure exitcode
01:28:38 <sclv> so you don't need _separate_ executables for tests
01:28:50 <sclv> assuming you're using just quickcheck or hspec or something
01:29:11 <Solonarv> your executable's main could look something like:
01:29:11 <Solonarv> main = getArgs >>= \case 
01:29:11 <Solonarv>   "--test":rest -> withArgs rest (run test suite here)
01:29:11 <Solonarv>   args -> normal program execution
01:29:46 <nickednamed> Solonarv: I agree, there is no real need for a test-suite, but part of my reasonging is that writing lots of small tests, for lots of small problems will provide me with the repetition and practice I need to remember these things.
01:33:21 <nickednamed> sclv, Solonarv: So, if I choose to do it that way (expose tests in executable for each module) because it is closer to a real project, the project would have no libraries, just multiple executables, each with one or more Modules behind it (sub-dir, etc.), right?
01:33:35 <Solonarv> yes
01:33:50 <sclv> to be clear, having seperate lib, test suite, and exes is closer to a real project
01:33:52 <Solonarv> well, actually it might well have one or more libraries
01:34:07 <sclv> exposing the test suite in the executable is less standard, but simpler, and probably suitable for your case
01:34:17 <Solonarv> after all there might be shared code between the various solutions
01:34:54 <sclv> indeed for project eulerish things i think people tend to end up with a common core of code for dealing with primes and stuff
01:35:15 <Solonarv> yeah
01:35:35 <Solonarv> and for advent of code, there is often some kind of VM that ends up being used in several of the problems
01:36:14 <Solonarv> and there are some data structures and utility functions that are commonly useful because programming problem writers simply seem to often make problems that way
01:36:48 <nickednamed> Solonarv, sclv: Yes, I thought the same. I already have one or two modules for primes (and similar) and would definitely want to structure the project in a way that allows me to re-use code as much as possible.
01:39:50 <Solonarv> nickednamed: for example here is my .cabal file for advent of code 2019: https://github.com/Solonarv/adventofcode-2019/blob/master/haskell/aoc2019.cabal
01:40:18 <Solonarv> note that I wouldn't quite recommend this setup: I made each problem into a library and have only a single executable that collects them all
01:40:35 <Solonarv> this is actually very inconvenient and they should just be separate executables instead
01:41:18 <nickednamed> So I'm leaning towards the "standard" configuration. Which means one library (one module per problem/solution, and possibly reusable modules for primes,etc.), and multiple executables (one for each problem/solution), plus a test-suite. The adv's would be that I can write tests, benchmarks, etc., run each problem/solution seperately, but the downside is a long, verbose .cabal file. Is this right?
01:42:01 <Solonarv> sounds right to me
01:42:10 <Solonarv> you can have multiple libraries too, btw
01:42:13 <Solonarv> doesn't have to be just one
01:44:24 <nickednamed> OK, why would I / wouldn't I do that? Because, I'm looking at your project and wondering why you did that (not to say there isn't a good reason, but it escapes my little mind)
01:44:55 <Solonarv> just grouping things logically, really
01:45:19 <Solonarv> there's not much of a reason *not* to have multiple internal libraries, so just do it when it makes sense
01:47:45 <nickednamed> Got it.
01:49:06 <nickednamed> Thank you.
01:50:42 --- mode: ChanServ set +o Sigyn
04:10:23 * hackage ngx-export-tools-extra 0.2.0.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.2.0.0 (lyokha)
04:11:23 * hackage hedgehog 1.0.2 - Release with confidence.  https://hackage.haskell.org/package/hedgehog-1.0.2 (moodmosaic)
04:26:53 * hackage cabal2spec 2.4.1 - Convert Cabal files into rpm spec files  https://hackage.haskell.org/package/cabal2spec-2.4.1 (PeterSimons)
04:45:35 <arne_> how do i parallelize the generation of this gamestate tree?
04:45:39 <arne_> http://dpaste.com/2ZCNRW1
04:46:24 <arne_> im happy with my understanding of haskell now, but this is only running on one core
04:52:24 <alx741> arne_: have a look at this gem by Simon Marlow: https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch01.html
04:53:39 <arne_> yeah i tried the strategies thing and read about it, but can't get it quite to work
04:53:45 <arne_> i hoped someone could show me at this example
04:54:24 <arne_> with this*
05:04:25 <jojoz[m]> Anyone know of any alternatives to LLVM/llvm-hs for codegen in Haskell? Like how there's [QBE](https://c9x.me/compile/) for C and [Cranelift](https://github.com/bytecodealliance/cranelift) for Rust.
05:04:51 * Digit gets whim to look for a haskell web browser, comes across spike, starts wondering if this is **it**, keeps looking, starts finding more (& ambiguous/confusing) possibilities... starts to suspect he'd save himself days and weeks of searching if he just asked #haskell "what (if any) haskell web browsers there are to recommend?"
05:16:06 <arne_> if i try to replace map with "parMap" and a strategy i get some nfdata error and don't know what's going on
05:20:35 <c_wraith> is it that there's no instance for NFData?
05:22:02 <arne_> i don't know what that means, to be honest
05:22:47 <c_wraith> Sounds like you've jumped way past the basics
05:23:02 <arne_> i guess so
05:26:27 <c_wraith> Do you know how things like the == operator work in Haskell?
05:26:50 <arne_> is it an operator, i thought it's a function
05:26:57 <arne_> if u mean typeclasses, i get that yeah
05:27:13 <arne_> why 1. == 1., 1 == 1 work while they're different
05:27:23 * hackage humble-prelude 0 - Redefinition-free prelude alternative  https://hackage.haskell.org/package/humble-prelude-0 (FumiakiKinoshita)
05:27:25 <arne_> right now im reading about normal forms, because it seems to be relevant
05:28:06 <c_wraith> NFData is a class for "this type can be fully evaluated"
05:28:25 <hasklol> I am following this tutorial here to setup a haskell env 
05:28:26 <hasklol> https://github.com/GuillaumeDesforges/haskell-nix-dev-template
05:28:35 <arne_> what does that mean, i mean. my type is nothing more than an enum
05:28:36 <hasklol> but how the heck do i compile it into a binary
05:29:02 <arne_> all tutorials need a "start vscode" part in their doc
05:29:03 <maerwald> hasklol: do you have prior experience with nix?
05:29:07 <hasklol> nope
05:29:14 <maerwald> then you shouldn't follow that
05:29:26 <Solonarv> arne_: "operators" are just functions with names made of symbols rather than letters-and-numbers
05:29:35 <Solonarv> (in haskell)
05:29:39 <hasklol> :(  is there an easy way to setup haskell stuff? So far i only use the interactive environment
05:29:43 <arne_> Solonarv: ah okay
05:29:59 <arne_> i wouldn't have that distinction in my head
05:29:59 <maerwald> hasklol: what distro
05:30:04 <c_wraith> arne_: For an enum with no arguments to any constructor, fully evaluating is just figuring out which constructor a value is.
05:30:05 <hasklol> ubuntu
05:30:18 <maerwald> hasklol: https://launchpad.net/~hvr/+archive/ubuntu/ghc
05:30:23 <maerwald> install ghc and cabal-install from there
05:30:40 <arne_> c_wraith: so to understand this i need to know what beta reduction, weak head normal form and stuff is?
05:30:52 <arne_> because where the evaluation "stops" is a matter of these things?
05:31:07 <Solonarv> arne_: to fully understand what NFData means, yes
05:31:08 <boxscape> maerwald hasklol, I assume if you're using ghci (which I think you mean by interactive environment), you already have ghc installed
05:31:12 <c_wraith> arne_: If you want to understand all of the details, yes.  For a minimal practical understanding, you can leave some of it for later.
05:31:24 <arne_> Solonarv: well, in prinicap, i wouldn't care, i just want to multithread my program
05:31:34 <Solonarv> but a rough answer can be quickly given: WHNF means we know which constructor we've got
05:32:12 <arne_> but there might be many data constructors inside my tree. do i only care about the "top-level" one there?
05:32:19 <Solonarv> using 'mx :: Maybe Bool' as an example, we have evaluated mx enough to know whether we have 'Just x' or 'Nothing'
05:32:53 <Solonarv> NF (which is what NFData is for) means that not only do we know which constructor we have, but in the 'Just x' case 'x' must also be in NF
05:33:25 <arne_> hmpf, this is frustrating
05:34:08 <maerwald> control flow in haskell is not as easy as it seems at first :P
05:34:16 <Solonarv> you don't actually have to write an NFData instance yourself, fortunately
05:39:45 <arne_> wait whaa
05:40:26 <boxscape> https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html
05:40:37 <boxscape> look for Generic NFData deriving here
05:40:46 <boxscape> and then the "starting with ghc 7.10" section
05:41:27 * Solonarv really doesn't like DeriveAnyClass
05:41:33 <boxscape> why not?
05:41:40 <arne_> it really feels im then understanding even less
05:42:02 <Solonarv> it's just a sneaky way of writing an empty instance declaration
05:43:02 <boxscape> presumably it warns you if there are unimplemented methods? Which in my mind would make it more a concise way to write empty instance declarations
05:43:29 <boxscape> since it's not like regular instance declarations give you errors for unimplemented methods
05:43:33 <Solonarv> IIRC it only does that if you compile with -Wall
05:43:37 <boxscape> oh, okay
05:44:32 <Solonarv> also, it's a matter of "explicit is better than implicit" - if I were to use DeriveAnyClass, I'd want to use DerivingStrategies as well, as in 'deriving stock (Generic); deriving anyclass (NFData)'
05:44:45 <boxscape> Solonarv It looks to me like it always warns
05:45:02 <Solonarv> oh, that's good
05:45:08 <boxscape> but I mostly agree with your implicit vs explicit point
05:45:22 <Solonarv> DerivingStrategies is a great boon to this principle
05:46:18 <lortabac> we have been bitten by DeriveAnyClass a couple of times at work
05:46:23 <lortabac> we are not using it anymore
05:47:12 <lortabac> you can accidentally derive instances through defaults instead of GeneralizedNewtypeDeriving
05:47:22 <boxscape> ah, good point
05:47:35 <boxscape> though again DerivingStrategies would alleviate that, right?
05:47:48 <Solonarv> yeah, this is why I always specify a deriving strategy whenever I use anything other than stock
05:48:02 <arne_> i thought multithreading is easy qq
05:48:25 <Solonarv> laziness makes it both harder and easier
05:48:38 <arne_> why can't i have nice things
05:48:41 <Solonarv> easier, because you don't have to wrap your value in a function
05:48:54 <boxscape> at least you don't have to worry about two threads mutating the same reference, usually
05:49:02 <Solonarv> harder, because you have to make sure the other thread actually fully computes the thing it's supposed to
05:49:36 <Solonarv> but practically speaking, obtaining an NFData instance is not hard at all
05:49:56 <arne_> yeah that doesn't help me much because i don't know what that means yet or how i would use it
05:50:21 <lortabac> in most cases 'instance NFData MyType' is enough
05:50:25 <Solonarv> data MyType = Foo | Bar -- and so on
05:50:25 <Solonarv>   deriving stock (Eq, Show {- maybe more -}, Generic)
05:50:25 <Solonarv> instance NFData MyType
05:50:50 <arne_> wht does generic do?
05:51:32 <Solonarv> it's a typeclass that converts between MyType (in this case) and a sort of generic tree structure
05:51:49 <Solonarv> many libraries use it to automatically provide instances for their typeclasses
05:52:20 <boxscape> if you look at the source code of NFData you'll see that rnf has a default implementation that requires Generic https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/src/Control.DeepSeq.html#rnf
05:52:45 <arne_> but my type doesn't have a tree :o
05:52:53 * hackage humble-prelude 0.1 - Redefinition-free prelude alternative  https://hackage.haskell.org/package/humble-prelude-0.1 (FumiakiKinoshita)
05:53:30 <boxscape> Any type can be converted into a (possibly empty or trivial) tree of products and sums
05:53:34 <Solonarv> structurally, *all* algebraic data types are tree-like in some sense
05:53:58 <Solonarv> (ADTs are the sort of types you define with a 'data' declaration)
05:54:18 <boxscape> can you derive Generic for GADTs and/or Existential types?
05:54:31 <Solonarv> GHC can't, but there is a library that can
05:54:35 <Solonarv> I forget what it's called
05:54:41 <boxscape> ok, interesting
05:55:30 <Solonarv> https://hackage.haskell.org/package/kind-generics is the one
05:55:38 <boxscape> thanks
05:56:00 <Solonarv> kind-generics-th is the one that generates the instances
05:56:48 <boxscape> ah so it actually uses a more powerful class GenericK it seems
05:57:17 <arne_> phew, that'll be a lot to read
05:57:48 <arne_> what makes types algebraic? that adjective always confused me
05:58:32 <berndl> arne_: sum and product types
05:58:48 <arne_> like, when using them compined?
05:58:56 <arne_> or what is a product type?
05:58:57 <boxscape> arne_:  type Void, without any values (ignoring bottom) is like 0. The type (), with one element (i.e. ()) is like 1. Product is (,) and Sum is Either
05:59:16 <boxscape> so "Either () ()" is 1 + 1, and it has 2 values, Left () and Right ()
05:59:32 <boxscape> (Either () (), Void) is 2 * 0 and has 0 values
05:59:33 <berndl> arne_: tuples are product types
05:59:42 <Solonarv> also,if you have: data Thing = Foo Int | Bar Char Bool
05:59:42 <Solonarv> this is like Thing = Int + Char * Bool
05:59:48 <boxscape> functions can be seen as exponentiation, in addition to that
06:00:19 <Solonarv> they are called "algebraic" because they are built from the algebraic operations +, *, ^
06:00:25 <boxscape> and you can do algebra on them. Presumably if you couldn't they'd just be called arithmetic types.
06:00:31 <Solonarv> indeed
06:00:37 <arne_> i don't get the term thingi
06:00:48 <arne_> what is Int + Char * Bool mean
06:01:02 <arne_> does*
06:01:13 <Solonarv> + means "exclusive or", * means "and"
06:01:24 <boxscape> the number of values that Thing has is the number of values that Int has + the number of values that Char has, times the number of values that Bool has
06:01:36 <Solonarv> so if you have a 'Thing' this means you either have an Int, or you have a Char and a Bool
06:01:50 <arne_> yeha okay, hm
06:01:54 <Solonarv> as boxscape said, the reason we use + and * is that this also corresponds nicely to how many possible values there are
06:02:09 <arne_> yeah i get it, you could kinda plot a graph
06:02:31 <arne_> of all possible values of a type?
06:02:36 <arne_> did i get that correctly?
06:02:53 <Solonarv> yes, indeed
06:03:13 <arne_> cool, thanks
06:04:21 <arne_> and the nfdata class provides functions that signal ghc if a type is evaluated? or can be evaluated furthermore?
06:04:46 <Solonarv> not exactly; it provides *one* function that says "evaluate this value fully"
06:05:11 <arne_> what does evaluate mean in this case? it doesn't have to be because i only have enums?
06:06:00 <Solonarv> well, the meaning of "evaluate fully" depends on the type; that's why it is provided by a type class
06:06:20 <arne_> yeah but for a simple enum it returns itself?
06:06:30 <arne_> because what is there to evaluate left?
06:06:52 <Solonarv> well, for a simple enum it just needs to figure out which constructor we have
06:07:00 <Solonarv> so in that case NF is the same as WHNF
06:07:03 <arne_> what does "we have" mean
06:07:30 <merijn> arne_: You don't have "an enum" you have "an expression that will (when evaluated) produce an enum"
06:07:44 <arne_> hm
06:07:44 <boxscape> imagine something like "id (id (id (id False)))", you can evaluate these three calls for example, even though the result is a value of an enum type
06:07:56 <boxscape> s/three/four
06:08:14 <Solonarv> for example, when you write in code 'x = 3 < 5' this is represented in-memory as something very much like '3 < 5'
06:08:21 <merijn> arne_: "map snd [(1,True),(2,False)] !! 1" :: Bool
06:08:37 <merijn> arne_: But you have to evaluate it to figure out if it's True or False
06:09:00 <Solonarv> "evaluate" means to actually call this (<) function and wait for it to give back a result
06:10:02 <arne_> yeah sure, so that ghci can say True
06:10:37 <Solonarv> yes, when you type an expression into ghci it will (generally) be evaluated, so that it can be printed
06:10:57 <arne_> waht triggers evaluation if i was about to write a webserver?
06:11:14 <Solonarv> in the end, evaluation is triggered by 'case'
06:11:41 <Solonarv> whenever 'case foo of { ... }' is evaluated, first 'foo' must be evaluated
06:12:17 <boxscape> except if you don't pattern match
06:12:23 <arne_> okay.. to summarize.. i mostly ignore this, and derive an empty NFData class
06:12:44 <arne_> then i take my root of my gamestate tree, and map it in parallel with rdeepseq (so each subtree gets evaluated)
06:13:11 <arne_> and then im happy because my cpu cores are pegged?
06:13:19 <Solonarv> hopefully!
06:13:35 <Solonarv> I haven't actually used parallel yet ;)
06:13:37 <arne_> how exactly did i do this empty deriving thing, i don't want vodoo
06:13:46 <arne_> Solonarv: but how do you make fast programs!
06:14:03 <Solonarv> *shrug* generally they have been fast enough anyway
06:14:19 <boxscape> arne_ By using an empty instance you're actually using the default implementation from here https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/src/Control.DeepSeq.html#rnf
06:14:40 <boxscape> (assuming you have derived Generic)
06:24:42 <arne_> it's still just tourtering one core
06:25:17 <kuribas> @hooge Applicative m => m a -> m b -> m a
06:25:18 <lambdabot> Prelude (<*) :: Applicative f => f a -> f b -> f a
06:25:18 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
06:25:18 <lambdabot> Test.Hspec.Discover (<*) :: Applicative f => f a -> f b -> f a
06:25:19 <arne_> tortering*
06:25:27 <arne_> torture*
06:25:30 <arne_> torturing?
06:25:39 <arne_> torturing complete?
06:26:33 <boxscape> arne_ I haven't used this functions, just looking at the docs, but did you use rpar?
06:26:49 <boxscape> or... rparWith? I'm not sure
06:26:57 <Solonarv> arne_: did you compile with -threaded ?
06:27:04 <arne_> Solonarv: oh sure, no i didn't
06:27:22 <boxscape> or is rdeepSeq on its own parallel?
06:27:58 <arne_> boxscape: i used "parMap rdeepseq"
06:28:04 <boxscape> okay
06:29:00 <arne_> well it works, it hits many cores now :D
06:29:04 <arne_> but it's not a bit faster
06:29:37 <arne_> well, maybe i lied
06:30:12 <arne_> if 2 threads see the same thunk, will they be able to notice?
06:30:16 <boxscape> probably a good idea to profile your program to see what actually takes time at this point if you haven't done it yet
06:30:28 <arne_> sorry if i don't use the right terminology there
06:30:28 <Solonarv> arne_: yeah, it won't get evaluated twice
06:30:36 <arne_> cooooool even between threads?
06:30:47 <Solonarv> while a thunk is being evaluated it is "marked" so that it doesn't get entered twice
06:30:48 <arne_> and you never do that because it's never neccessary?
06:31:05 <arne_> (multithreading with par, that is)
06:31:12 <boxscape> thunks are updated in place if my limited knowledge of STG doesn't betray me
06:31:17 <Solonarv> correct
06:31:34 <arne_> so you would consider this too early optimizating in my case
06:31:45 <Solonarv> as a bonus, this helps detect some infinite loops: if, while evaluating a thunk, you end up evaluating the same thunk again, then you have an infinite loop!
06:32:00 <Solonarv> and the RTS is nice enough to throw an exception when that happens ;)
06:32:49 <Solonarv> most of the time I was having a performance problem, the fix was to use a better algorithm
06:32:55 <Solonarv> not to throw parallel at it
06:33:17 <arne_> okay the 1thread thing needs 38s
06:33:19 <Solonarv> afterwards performance was good enough I didn't bother with further optimization
06:33:26 <arne_> with my multithread modification it still does
06:33:33 <arne_> with 4 cores it does 22!! wohooo progres
06:33:46 <Solonarv> hey, not bad!
06:33:53 <Solonarv> > 38/22
06:33:56 <lambdabot>  1.7272727272727273
06:34:05 <Solonarv> 73% speedup!
06:34:08 <arne_> and considering the mtultirheading doesnt destroy the performance on one core i guess i did a good job?
06:34:34 <arne_> or is that ghcs win, because it schedules so nicely
06:35:00 <Solonarv> it's both!
06:35:15 <arne_> and now i have to read what is in generics & the normalform stuff & how deriving works ( i know that's crazy )
06:35:18 <arne_> to get that all?
06:35:22 <Solonarv> you did a good job letting the compiler and libraries make your thing faster
06:35:48 <arne_> well quite cumbersome to derive these instances i don't know what they're doing at every type i use in there
06:35:58 <arne_> but certainly better than everything i would do in c or whatever
06:36:08 <Solonarv> a high-level overview of generics and WHNF / NF should not be too hard to figure out
06:36:24 <Solonarv> the details of GHC.Generics are fiddly and annoying, though
06:36:36 <arne_> everytime i googled " how does deriving work"
06:36:44 <arne_> i just get someone saying "it's magic, lol"
06:37:25 <boxscape> things done by the compiler rather than defined in the core libraries are commonly called magic
06:37:59 <arne_> Solonarv: seems like it's not both
06:38:04 <arne_> i reverted my multithread change
06:38:14 <arne_> and compiled with -threaded, that alone did make it 22s
06:38:19 <arne_> i did nothing all day
06:38:30 <arne_> Just Nothing
06:38:51 <arne_> haskell programms just get faster by giving it multithread!?
06:39:22 <__monty__> Haskell's relation to threads is... complicated.
06:40:05 <arne_> wait wait wait wait.. now when i remove NFData from the types it's slow again
06:40:21 <arne_> does haskell benefit from that nfdata stuff without me using any parallel stuff at all?
06:40:40 <Solonarv> there are three different deriving strategies:
06:40:40 <Solonarv>  - stock: these are typeclasses that the compiler knows about, they are wired in with special hand-written code to generate the instances
06:40:40 <Solonarv>  - newtype: for a 'newtype MyFoo = MkMyFoo (OriginalFoo)', this allows you to simply re-use the instance for OriginalFoo
06:40:40 <Solonarv>  - anyclass: this one just writes empty instances
06:41:16 <Solonarv> so when people say "it's magic", they generally are talking about stock deriving, and it's "magic" because there isn't any nice general thing that is happening
06:41:29 <arne_> and Show and stuff like that is part of stock
06:41:31 <Solonarv> just hand-written code which looks at your datatype and figures out what the instance looks like
06:41:34 <arne_> that doesn't sound magic at all
06:41:44 <Solonarv> yes, classes like Eq, Show, etc are available for stock deriving
06:42:16 <arne_> well, that's actually kinda what i expected if people didn't say "it's magic"
06:42:18 <Solonarv> with appropriate extensions, also Generic, Functor, Foldable, Traversable, and Data (I think that's all of them)
06:43:14 <arne_> my program gets faster just by adding the nfdata, does that make sense?
06:43:50 <Solonarv> depends on what you mean by "adding the NFData"
06:43:56 <arne_> deriving it in the types
06:44:07 <arne_> doing nothing more.. no using, no withStrategy
06:44:10 <Solonarv> if you just mean adding/removing a 'instance NFData MyType' line, then this is confusing to me
06:44:22 <arne_> well.. might be bad benchmarking
06:44:28 <arne_> or something odd
06:44:44 <arne_> can't seem to reproduce it either
06:44:49 <arne_> this would've fucked me up either way
06:44:56 <arne_> well thanks alot for your help, everyone :*
06:44:58 <nshepperd2> it's probably just that changing your file caused ghc to recompile
06:45:18 <arne_> im doing ghc ttt.hs && time ./ttt right now
06:45:22 <arne_> otherwise i would've guessed that, too
06:46:36 <nshepperd2> ghc used to not recompile things after changing flags like -O, that might still be the case
06:46:56 <arne_> if things are numbered like Generic1 Generic
06:47:01 <Solonarv> you can pass -fforce-recomp to force recompiling, btw
06:47:03 <arne_> are those "stages" of some sort?
06:47:15 <arne_> or versions
06:47:17 <Solonarv> ehh, they're not really "numbered"
06:47:24 <Solonarv> there isn't a Generic2 that I'm aware of
06:47:30 <Solonarv> nor a Generic3, and so on
06:47:43 <arne_> looks rather ugly
06:48:14 <arne_> i have to understand kinds to understnad generics?
06:48:16 <Solonarv> spot the difference:
06:48:16 <Solonarv> instance Generic (Maybe a)
06:48:16 <Solonarv> instance Generic1 Maybe
06:48:20 <Solonarv> no, you don't really
06:48:24 <Solonarv> you can mostly ignore Generic1
06:49:39 <arne_> Solonarv: oh that one stands for the "parameter" count
06:49:48 <Solonarv> yes
06:50:01 <Solonarv> there are other similar classes like Eq1, Show1 etc
06:50:17 <boxscape> and NFData1 and NFData2
06:50:52 <boxscape> But I think you can't derive NFData2 because Generic2 doesn't exist
06:50:54 <absence> :t fmap sequenceA . sequenceA
06:50:56 <lambdabot> (Traversable t, Applicative f1, Applicative f2) => t (f2 (f1 a)) -> f2 (f1 (t a))
06:50:57 <nshepperd2> a class suffixed with 1 indicates a variation of the class for types with 1 argument
06:51:01 <absence> is there a better way to write this?
06:51:01 <arne_> i get that you all not need to know these thigns to use haskell for "something real"™
06:51:15 <arne_> but if i see things like that... i can't stop reading about it, i have to know
06:51:26 <boxscape> seems like a good instinct
06:51:43 <arne_> well but it feels like before i start writing production haskell code
06:51:47 <arne_> im a colleage of spj
06:51:54 <Solonarv> :t sequenceA . sequenceA
06:51:57 <lambdabot> (Traversable t, Traversable f, Applicative f, Applicative t) => f (t a) -> f (t a)
06:52:10 <Solonarv> heh, no that's definitely wrong
06:52:15 <Solonarv> :t traverse sequenceA
06:52:17 <lambdabot> (Applicative f, Traversable t1, Traversable t2) => t1 (t2 (f a)) -> f (t1 (t2 a))
06:52:33 <arne_> yeah meant as a joke ofc
06:52:40 <Solonarv> hm, this seems to do something related but slightly different
06:52:53 * hackage math-grads 0.1.6.4 - Library containing graph data structures and graph algorithms  https://hackage.haskell.org/package/math-grads-0.1.6.4 (AlexKane)
06:53:24 <boxscape> arne_: Solonarv was saying that his lambdabot query was wrong I believe ;)
06:53:34 <Solonarv> indeed
06:55:20 <p0a> Hello! Day #lost track of learning yesod :)
06:56:04 <p0a> Learning yesod after doing PHP many years ago is like time traveling to the future
06:56:09 <absence> Solonarv: yes, it's sort of the opposite
06:56:30 <absence> Solonarv: the inner f moves out instead of the outer t moving in
06:56:51 <Solonarv> oh!
06:57:03 <Solonarv> :t getCompose . traverse Compose
06:57:05 <lambdabot> error:
06:57:05 <lambdabot>     Variable not in scope: getCompose :: f0 (t b0) -> c
06:57:05 <lambdabot> error:
06:57:08 <Solonarv> grrr
06:57:14 <Solonarv> @let import Data.Functor.Compose
06:57:16 <lambdabot>  Defined.
06:57:18 <Solonarv> grrr
06:57:20 <Solonarv> :t getCompose . traverse Compose
06:57:23 <lambdabot> forall k1 (t :: * -> *) (f :: k1 -> *) (g :: * -> k1) b. (Traversable t, Applicative (Compose f g)) => t (f (g b)) -> f (g (t b))
06:58:45 <Solonarv> okay, more general than I was expecting but this shold work
07:00:17 <thblt> I'm sure it's obvious, but I'm missing the root cause. NixOS unstable, most stack commands, incl stack init, fail with "error: attribute 'ghc822' missing, at (string):1:43". Any idea?
07:01:58 <thblt> I've `mv ~/.stack` out of sight, but no luck
07:03:27 <Taneb> thblt: the issue is there's no attribute ghc822 in unstable
07:03:41 <absence> Solonarv: it's interesting, but i'm not sure it's better :)
07:04:18 <Solonarv> it is better because it only walks through the structure once
07:04:29 <thblt> Taneb: but how do I fix this? I can't find a reference to this attribute anywhere in my config.
07:04:50 <Taneb> Oh, hmm
07:05:12 <absence> Solonarv: good point
07:05:14 <Taneb> I don't really know how stack and nix interact... is it mentioned in your stack.yaml?
07:05:14 <Solonarv> it clumps both f1 and f2 into one "layer", lifts this "layer" out in a single pass, and the unpacks them again
07:07:24 <absence> Solonarv: isn't it possible/likely that traversing the composed structure is implemented as traversing twice though?
07:08:53 <Solonarv> you're comparing one 'traverse' call to two 'traverse' calls
07:09:00 <Solonarv> (remember that sequenceA = traverse id)
07:09:48 <c_wraith> the things being composed are the Applicative layers. the thing being traversed is not either of those.
07:10:06 <thblt> Taneb: thanks, I've updated the resolver in a stack.yaml and I can build the project again. There's still a broken default somewhere since stack build breaks with the same issue on non-project dirs, but I can live with that.
07:10:14 <c_wraith> so composing the layers can't result in traverse doing more passes.
07:10:34 <absence> Solonarv: the implementation for Compose is "traverse f (Compose t) = Compose <$> traverse (traverse f) t"
07:10:51 <Solonarv> absence: no, that's a law
07:10:54 <c_wraith> that's not the traverse you're calling, though.
07:11:08 <Solonarv> oh no, right, what c_wraith said
07:12:01 <c_wraith> you're not traversing the composed Applicative layers
07:12:17 <absence> right, now i see
07:13:58 <absence> it's a neat trick, if not entirely obvious, but nothing a comment can't remedy. thanks!
07:16:36 <sm[m]> G’day all
07:20:30 <p0a> good day
07:23:53 <MarcelineVQ> sm[m]: wwww
07:35:12 <mac10688> Anyone know a method that will let me do this? [m a -> bool] -> m a -> m bool. Or something to that affect?
07:36:58 <equalizer> hi, noob here. I am looking at the 99 questions solution# 2, specifically this: lastbut1safe = fst . foldl (\(a,b) x -> (b,Just x)) (Nothing,Nothing)
07:37:24 <equalizer> I do not understand the lambda function: (\(a,b) x -> (b,Just x)), how can this be applied to a list?
07:37:50 <equalizer> why can a pair be pattern matched to a list?
07:38:06 <p0a> it can't
07:38:10 <thblt> mac10688: a fold?
07:38:16 <equalizer> yea a foldl
07:38:28 <mac10688> thanks, I'll ponder that for a bit
07:38:51 <p0a> equalizer: the `x' is coming from the list
07:39:07 <p0a> equalizer: the (Nothing, Nothing) feeds into (a,b) initially; then foldl takes care of the rest
07:39:35 <equalizer> ah. that makes sense! thanks a lot
07:40:24 <fendor> why does stack compute a build-plan, just to ignore it and replace it with different packages? 
07:41:46 <sm[m]> What makes you say that fender
07:42:03 <sm[m]> fendOR, pardon me
07:43:07 <fendor> sm[m], in the logs https://gist.github.com/fendor/69bcf0b434a1ec6a40874fd195efcc49 One can see that it ignores `Cabal 2.4.0.1` and replaces it with `Cabal 2.4.1.0`
07:43:36 <arne_> boxscape: i wasn't sure what he meant either, but still -_
07:50:46 <Zemyla> Why isn't it possible to lazy pattern match on a GADT with one constructor and no "front-facing" constraints?
07:52:23 <Zemyla> Like data Coyoneda f a where Coyoneda :: (u -> a) -> f u -> Coyoneda f a; instance Functor (Coyoneda f) where fmap f ~(Coyoneda g u) = Coyoneda (f . g) u?
07:53:20 <nshepperd2> what happens when you try
07:53:52 <boxscape> % instance Functor (Coyoneda f) where fmap f ~(Coyoneda g u) = Coyoneda (f . g) u
07:53:53 <yahb> boxscape: ; <interactive>:257:46: error:; * An existential or GADT data constructor cannot be used inside a lazy (~) pattern; * In the pattern: Coyoneda g u; In the pattern: ~(Coyoneda g u); In an equation for `fmap': fmap f ~(Coyoneda g u) = Coyoneda (f . g) u
07:54:39 <nshepperd2> it's an existential constructor
07:54:43 <i12321> ghc can work on BSD?
07:55:00 <i12321> I really hate systemd
07:55:11 <nshepperd2> i don't know why that's not allowed but i assume there's a good reason
07:57:24 * hackage ghcide 0.0.6 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.6 (cocreature)
07:57:58 <maerwald> i12321: yeah, on freebsd works fine, there are also precompiled tarballs
07:58:38 <Zemyla> nshepperd2: Because if you were to pattern match lazily on Refl, then you could use undefined as a spurious proof that a ~ b.
07:59:26 <i12321> but  I don't understand why there're only five repos for binary packages that freebsd provide
07:59:51 <i12321> no mirror
08:00:28 <arne_> back to my original question
08:00:29 <Zemyla> But is there a way for GHC to tell which types it's okay to do so with and which ones it isn't?
08:00:39 <arne_> i optimized the creation of a tree with "parMap" for multicore-stuff
08:00:50 <arne_> which brought down my runtime from 30s+ to 22s
08:01:07 <arne_> but if i first flatten the tree and THEN do parMap the result is essentially the same
08:01:11 <arne_> how does this magic work!?
08:01:49 <arne_> i the RTS can't know it's a tree?
08:02:40 <nshepperd2> Zemyla: refl is a gadt, not just existential
08:04:08 <nshepperd2> it's unclear to me that you can do anything bad by lazily matching an existential constructor, besides bringing a type variable that doesn't mean anything into scope
08:04:55 <COLAMAroro> Hello everyone. I'm new to the language (and to FP), and I'm having issue on doing an fmap on lookup
08:05:41 <COLAMAroro> I could just make my own function for that, but I'm sure the language of something for that. Basically, I want to avoid that boilerplate: https://gist.github.com/COLAMAroro/011d8e5e7c8baacc1a09cdc85c774f10
08:09:31 <boxscape> So you tried to use fmap on the result of lookup?
08:11:31 <boxscape> COLAMAroro ^
08:11:35 <COLAMAroro> something like `fmap (\x -> lookup x db) array` ? I get a Type error
08:11:54 <boxscape> well, not quite
08:12:00 <COLAMAroro> getting `[Maybe a]` instead of `Maybe ([a])`
08:12:32 <boxscape> I meant more along the lines of `fmap (\x -> ...) (lookup ...)`
08:13:51 <boxscape> because what you're doing right now is taking the result of lookup, and return Nothing if lookup returns Nothing, and modify the value inside Just if lookup returns Just
08:13:55 <boxscape> and that is what fmap does
08:14:48 <arne_> but how would that make the code prettier
08:14:49 <COLAMAroro> Yeah, I saw that, that's why I'm trying to do it using fmap instead of myself
08:15:00 <arne_> i was more amazed that the do makes the Just go away
08:15:34 <boxscape> arne_ return = Just
08:15:42 <arne_> i know i know
08:15:49 <arne_> but hiding that you use the monad at all is prettier to my eye
08:15:53 * hackage cachix-api 0.4.0 - Servant HTTP API specification for https://cachix.org  https://hackage.haskell.org/package/cachix-api-0.4.0 (domenkozar)
08:15:54 <boxscape> you don't need "do" for that ;)
08:15:57 <arne_> isn't that what monads is about?
08:16:06 <arne_> hidings things
08:16:25 <boxscape> abstraction
08:16:41 <arne_> yeah hiding everything that isn't relevant 
08:16:46 <arne_> is abstraction :p
08:16:53 * hackage mmsyn7ukr 0.6.1.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.1.0 (OleksandrZhabenko)
08:16:58 <arne_> i know that doesn't fully make sense
08:17:41 <COLAMAroro> I mean, for a beginner, the Maybe Monad just look like an enum+union, used for error managment, not for abstraction
08:17:53 * hackage cachix 0.3.5 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.5 (domenkozar)
08:18:01 <arne_> yeah but put into a language that is universal
08:18:06 <boxscape> I meant the concept of Monads is an abstraction, rather than any individual Monad
08:18:29 <arne_> you don't need a nil-type for every type you have
08:18:34 <arne_> you hide the fact that you don't have a niltype
08:19:11 <arne_> and if you write functions that work with your non-nilable-type, you can lift them ⇒ your type is nilable, without having it programmed
08:19:31 <COLAMAroro> True, for my use-case Maybe serve only for validating input, after that it's pure, without monads
08:19:50 <arne_> monads don't make things unpure(impure?)
08:20:01 <arne_> but you shouldn't trust me, i don't have a clue
08:20:09 <COLAMAroro> (I think it's impure)
08:20:44 <COLAMAroro> And to be fair, I don't know, started Haskell and FP on monday, it's really new to me
08:20:44 <arne_> but maybe is perfectly pure, im pretty sure about that
08:20:56 <arne_> COLAMAroro: you're faster than me already then
08:21:33 <COLAMAroro> Right now, i'm fighting with the language, not the FP mindset 
08:21:42 <boxscape> COLAMAroro to get back to your original question I think you should be able to write `fmap (\num -> <the stuff you have in the Just case>) (lookup (head arr) matchFuncStr)`
08:21:43 <loli> ADT's in general are type safe tagged unions
08:21:56 <Lears> COLAMAroro: In light of the following do block, the case expression is redundant; you can just pull in `num` like `num <- lookup ...`. But then you have something of the form `do a <- foo; b <- bar; return (f a b)`, which is just `liftA2 f foo bar`.
08:23:43 <haveo> isn't the whole function just `sequenceA . fmap (\x -> lookup x matchFuncStr)'?
08:24:11 <loli> sequenceA . fmap = traverse
08:24:13 <haveo> yeah
08:24:14 <loli> :t traverse
08:24:15 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:24:40 <haveo> I was messing with things in ghci, forgot to simplify
08:25:21 <COLAMAroro> heck, new monads to learns
08:25:38 <arne_> no, hes just saying what you wrote already exists
08:25:56 <arne_> using the rules of applicative(which every monad already is)
08:27:13 <COLAMAroro> time for hoogling
08:27:34 <sm[m]> fendor: you're wondering why it says "Ignoring package Cabal due to wanting version 2.4.1.0 instead of 2.4.0.1" ? I'd guess either one of the deps or stack itself is ignoring a too-old version of Cabal that you have
08:27:37 <haveo> you wanted to use fmap on your input list which is a good idea, then you just need something to go from '[Maybe smthg]' to 'Maybe [smthg]'
08:27:46 <haveo> which is sequence
08:28:02 <arne_> A
08:28:05 <haveo> (and sequence . fmap is traverse as pointed out)
08:28:27 <haveo> doesn't matter, it's all monads here
08:28:35 <COLAMAroro> so `traverse (\x -> lookup x d b) input` ?
08:29:22 <COLAMAroro> no type error on GHC, testing
08:29:49 <fendor> sm[m], yeah, in the lts, it is using the newer one, but where is it determined what to override?
08:30:15 <arne_> the function used in traverse has to use return/pure
08:30:25 <arne_> i can't follow why those are supposed to be equivalent, sorry
08:31:01 <COLAMAroro> Welp, this seems to work for me -> `parseOp arr = traverse (\x -> lookup x matchFuncStr) arr`. Thanks everyone !
08:31:24 <haveo> arne_: it's the same type signature except the constraint on a type variable is Applicative vs Monad
08:31:26 <sm[m]> fendor: I don't know in this case, and it would take too long to track down. Cabal is such a central package there could easily be special rules for it
08:31:42 <haveo> but that variable is instantiated to Maybe
08:31:52 <haveo> (in this specific case)
08:31:53 <fendor> sm[m], yeah... well... 
08:32:14 <arne_> COLAMAroro: https://www.youtube.com/watch?v=BovTQeDK7XI reminds me of this one
08:33:30 <arne_> wrong video, one sec
08:34:23 <sm[m]> fendor: is it causing a problem ?
08:34:51 <arne_> COLAMAroro: https://www.youtube.com/watch?v=RtYWKG_zZrM this one, tl;dw ⇒ dude writes a parser with a big function, notices the signature is kinda sequenceA
08:35:04 <arne_> changes the type so he doesn't need to write it at all
08:36:18 <COLAMAroro> Yeah, I changed prototype (and subsequent call) so I could reuse it
08:36:23 <fendor> sm[m], yeah. in cabal-helper, transitively in haskell-ide-engine
08:36:45 <fendor> gonna ask the author of cabal-helper if they know a solution
08:36:48 <COLAMAroro> `parseOp::Eq(a)=>[a]->[(a,b)]->Maybe([b])` with implementation `parseOp arr db = traverse (\x -> lookup x db) arr`
08:37:36 <COLAMAroro> (Could technically invert db and arr, to make it a partial application, but then it doesn't match with the lookup prototype)
08:38:28 <boxscape> @pl parseOp arr db = traverse (\x -> lookup x db) arr
08:38:29 <lambdabot> parseOp = flip (traverse . flip lookup)
08:38:36 <arne_> Codaraxis_: do you now flip :p
08:38:40 <arne_> there it is already
08:39:23 <boxscape> though that doesn't necessarily make it more readable
08:39:29 <COLAMAroro> It's supposed to invert arguments ?
08:39:34 <arne_> swap them
08:39:54 <COLAMAroro> so (f a b)->(f b a) ?
08:39:59 <boxscape> :t flip
08:40:00 <arne_> flip :: (a -> b -> c) -> b -> a -> c
08:40:00 <lambdabot> (a -> b -> c) -> b -> a -> c
08:40:24 * hackage mmsyn7h 0.4.1.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.4.1.0 (OleksandrZhabenko)
08:41:15 <arne_> does someone else besides me hat the "get"-prefixed functions?
08:41:29 <COLAMAroro> cool tricks, putting it somewhere else for future use, but i'm going to keep this function as-is (and renamed to arrayLookup), could serve me later
08:41:35 <COLAMAroro> thanks for the help !
08:41:44 <boxscape> arne_ example?
08:41:53 <arne_> boxscape: Min { getMin = 1 }
08:42:50 <boxscape> you could use coerce instead
08:43:01 <boxscape> or some generalized un/get that uses coerce
08:43:10 <arne_> that's not my code it's in Data.Monoid
08:43:23 <boxscape> yeah I mean at the call site
08:43:47 <arne_> ah, okay, yeah im not talking about this specific cas ethough
08:43:59 <boxscape> Neither am I ;)
08:44:06 <arne_> if i read "player [GameTurn]"
08:44:16 <arne_> or rather
08:44:18 <arne_> player GameTurn
08:44:23 <arne_> im reading "player of gameturn"
08:44:38 <arne_> that doesn't work anymore if the function is called getPlayer.. it feels imperative
08:44:49 <arne_> seens this alot while learning
08:45:37 <boxscape> is GameTurn a newtype? (Asking because I don't think I've really seen "get" for any types with more than one field)
08:46:00 <arne_> data Turn = Turn { player :: Player, position :: Position}
08:46:12 <arne_> therefore in my code there is a lot of "player t"
08:46:21 <arne_> where t :: Turn
08:46:37 <boxscape> Yeah it would seem unidiomatic to me to have getPlayer there
08:46:51 <arne_> yeah but i see people do that alot
08:46:58 <arne_> and as it seems it's in haskell "core" too
08:47:35 <boxscape> only with newtypes though, I think
08:49:38 <arne_> what is newtype exactly? i never used it
08:49:44 <arne_> type is an alias, if i got that correctly
08:50:25 <boxscape> It's a lot like data, but there must be exactly one constructor with exactly one field, and at runtime there's no overhead compared to using the wrapped value itself
08:50:53 <arne_> so a specialized alias that allows you to change/add some things to a existing type
08:51:09 <boxscape> it's used both to make things more type safe and to be able to provide multiple instances for a given type
08:51:21 <boxscape> so basically, yes
08:51:37 <arne_> co0l, from the category "zero cost abstraction" i guess
08:52:18 <boxscape> hm, not sure what would be abstracted over in this case
08:52:53 * hackage mmsyn7ukr 0.6.1.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.6.1.1 (OleksandrZhabenko)
08:53:10 <arne_> that they're the same type :p
08:53:16 <arne_> (while not being the same)
08:53:50 <boxscape> Ah yeah I can see where you're coming from
08:54:02 <arne_> i learned so much today, yay
08:57:34 <boxscape> % newtype T = T T deriving Show
08:57:34 <yahb> boxscape: 
08:57:42 <boxscape> % take 20 $ show (undefined :: T)
08:57:42 <yahb> boxscape: "T (T (T (T (T (T (T "
08:57:44 <arne_> nonono stop confusing me now
08:57:49 <arne_> im really happy with my haskell knowledge
08:57:51 <arne_> stop
08:58:11 <boxscape> sorry, this was more for my benefit :P
08:58:26 <p0a> boxscape: how do you use take 20 on show?
08:58:47 <boxscape> I understand why this works, but somehow it seems strange to me that show is seemingly not strict in its first argument
08:58:49 <p0a> oh on String
08:58:52 <boxscape> yeah
08:59:41 <p0a> well show doesn't know whether your type is finite or not
08:59:45 <p0a> it just recurses
09:00:06 <arne_> you can "cast" undefined to a type!?
09:00:25 <boxscape> yeah actually if I think about what the actual definition of show in this case looks like it makes sense, the argument is never examined
09:00:30 <p0a> arne_: `undefined :: a' means it's "the most generic type"
09:00:55 <p0a> boxscape: the argument is examined
09:01:06 <arne_> stop confusing me nowz
09:01:08 <arne_> !
09:01:24 <p0a> I'm not pretending to know all this but I'm just offering what I understand 
09:01:58 <arne_> yeah i mean, boxscape no more definitions/code
09:03:14 <boxscape> p0a uh yeah it is examined, true
09:05:46 <boxscape> % showT (T t) = "T (" ++ showT t -- basically this, sorry that is one more definition I suppose
09:05:47 <yahb> boxscape: 
09:05:59 <boxscape> % take 20 $ showT undefined
09:05:59 <yahb> boxscape: "T (T (T (T (T (T (T "
09:06:06 <arne_> stop!
09:06:13 <boxscape> Ok I'm done now
09:06:30 <dsal> COLAMAroro: It's probably worth adjusting your language a bit to not refer to lists as arrays.  They're quite different.
09:07:21 <boxscape> (okay imagine showT has `++ ")"` at the end)
09:07:53 * hackage log4hs 0.4.0.0 - A python logging style log library  https://hackage.haskell.org/package/log4hs-0.4.0.0 (gqk007)
09:10:49 <dsal> The get* monoids let me write some odd looking code on an old AoC thing.  I ended up not going with this, but it basically gives you a different answer depending on how you use it:  https://www.irccloud.com/pastebin/57AfVULO/most.hs
09:12:02 <p0a> if I hire someone for advice for an hour or two, on haskell
09:12:14 <p0a> like what fpcomplete offers, what is the rate? not specifics, but what should I expect?
09:12:47 <p0a> like $100-$200/hr is reasonable? I don't know 
09:13:10 <arne_> .oO( does something like this for ohter languages )?
09:13:59 <dsal> Yes.
09:14:17 <arne_> i wonder what questions you had in .. for example python
09:14:45 <p0a> thanks dsal 
09:21:53 <maralorn[m]> Is there a package that can give me the diff of two hashmaps?
09:22:13 <maralorn[m]> As in something like Map k v -> Map k v -> Map k (These v v)?
09:22:57 <maerwald> @pl traverse f s0 = fmap (fromListN (size s0)) . DT.traverse f . toList $ s0
09:22:57 <lambdabot> traverse = join . flip ((.) . fmap . fromListN . size) . (. toList) . DT.traverse
09:26:23 * hackage mmsyn7l 0.2.0.0 - Modifies the amplitude of the sound representations for the Ukrainian language created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.2.0.0 (OleksandrZhabenko)
09:26:55 <atif> What is the difference between `print . map f . C.lines $ content` and `print . map f . C.lines (content)`?  First one works while the second one throws an error.
09:28:11 <heatsink> $ has low precedence
09:28:18 <heatsink> the first is (print . map f . C.lines) content
09:28:27 <heatsink> the second is print . map f . (C.lines content)
09:29:19 <atif> Thanks.  I clearly misunderstood $.
09:39:32 <dsal> Mo $, mo problems.
09:40:53 <daydaynatation> In the Maybe type do notation,  i <- Nothing . What is i and why?
09:42:51 <heatsink> Let's try it
09:42:57 <heatsink> > do { i <- Nothing; return i }
09:43:00 <lambdabot>  Nothing
09:43:10 <purelazy> What does $! mean. E.g. return $! if S.null x then Nothing else Just x
09:43:14 <heatsink> > do { i <- Just 3; return i }
09:43:17 <lambdabot>  Just 3
09:43:37 <glguy> purelazy: http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-36--33-
09:44:16 <daydaynatation> heatsink: For the Nothing case, before you wrap i, what is i?
09:44:36 <daydaynatation> heatsink: I get it if it's Just 3
09:45:01 <daydaynatation> When it's Just 3, i ==  3
09:45:16 <dsal> purelazy: $! means you don't want the value on the RHS to be pure lazy.
09:45:18 <heatsink> daydaynatation: It is the value that you get out of Nothing.  Since you don't get a value out of Nothing, i isn't anything.  The code using i doesn't run
09:45:50 <heatsink> > do {i <- Nothing; return 100 }
09:45:52 <lambdabot>  Nothing
09:46:12 <daydaynatation> Where is this documented?
09:46:15 <purelazy> Thanks glguy. I should have searched hoogle - I got no luck with Google
09:46:26 <heatsink> There's no 100 in the output because the "return 100" doesn't run
09:47:05 <heatsink> To learn about the Monad instance for Maybe, perhaps Typeclassopedia is the place to look
09:47:33 <daydaynatation> I've checked the ghc source code for the Monad instance of Maybe
09:47:47 <daydaynatation> But it doesn't say anything about what you just mentioned
09:48:01 <daydaynatation> that i <- Nothing doesnt run
09:48:03 <p0a> daydaynatation: http://dev.stephendiehl.com/hask/#maybe
09:48:04 <dsal> daydaynatation: It might be easier to think of it this way:  What else could it do?
09:48:57 <daydaynatation> I get the idea that there's nothing else it does; but this should be at least documented somewhere
09:49:12 <Ailrun[m]> Check the impl of `>>=` for `Maybe`. It provides something equivalent to `i <- Nothing; return 100`
09:49:42 <daydaynatation> I've checked >>= and I think i get it. but no where is mentioned about <-
09:50:01 <dsal> Ah, it's the do syntax that's confusing you.
09:50:12 <dsal> @undo do { i <- Nothing; return i }
09:50:12 <lambdabot> Nothing >>= \ i -> return i
09:50:13 <heatsink> do-notation is translated into calling >>= and >>
09:50:15 <Ailrun[m]> do notation is just a syntatic sugar. You should translate it into `>>=` and `return`
09:50:21 <Ailrun[m]> Oh, I meant `>>`.
09:51:00 <daydaynatation> wow, the undo stuff is cool
09:51:04 <heatsink> It's >>= and return.  The >>= operator is more basic than >>
09:51:37 <p0a> how do I activate production/debug mode with {-# LANGUAGE CPP #-} ?
09:51:40 <dsal> (Where "It's" is "all of monad")
09:52:36 <p0a> daydaynatation: in the `do' notation, the individual steps are not in isolation; it's a sequence of operations, each of which affects the next in a way. If you `desugar' the do notation you will see how it works
09:52:47 <p0a> The link I linked to talks about that 
09:52:51 <daydaynatation> @undo do {3 <- Nothing; return 3}
09:52:51 <lambdabot> Nothing >>= \ a -> case a of { 3 -> return 3; _ -> fail ""}
09:52:51 <Ailrun[m]> heatsink: `return` need to be explicitly used in source code, where `>>` is used by a compiler. That's why I said `>>`.
09:53:23 <sm[m]> p0a: it can span the full range
09:54:01 <dsal> Ailrun[m]: >> is just a function.
09:54:13 <daydaynatation> I understand both >> and >>=
09:54:19 <dsal> And I don't use "return" in any of my source code. heh
09:54:22 <daydaynatation> But I don't understand i <- Nothing
09:54:44 <Ailrun[m]> dsal: I know... but GHC uses `>>` to make do-notation.
09:54:44 <dsal> daydaynatation: It's often suggested people not use do notation for a a bit.
09:55:12 <dsal> i <- Nothing is just    Nothing >>= \i -> ...
09:55:58 <daydaynatation> So in that case, can I write 3 <- Nothing ?
09:56:07 <Ailrun[m]> daydaynatation: As you cannot use `do i <- Nothing` without additional lines, you cannot understand  `i <- Nothing` separately.
09:56:11 <thblt> Sorry for a question that's certainly been asked a gazillion times, but you can't add a constraint on a type variable on a type declaration, and that's The Way Things Should Be, right?  Eg data (Eq a) => MyType a = Whatever a [a]  
09:56:26 <Ailrun[m]> Oh, for that case, it does uni-pattern matching, as `let` does.
09:56:42 <dsal> thblt: Every time I've wanted to do that, I've ended up kind of wrong.
09:57:28 <thblt> dsal: thanks
09:57:29 <dsal> daydaynatation: Yeah, it's slightly fancier.  You did an undo above which showed how it becomes a case.
09:57:39 <cocreature> "do 3 <- Nothing; foobar" desugars into something like `Nothing >>= \x -> case x of 3 -> foobar; _ -> fail "pattern match error"`
09:57:53 <dsal> thblt: e.g., why do you want that constraint?
09:58:56 <p0a> sm[m]: what can?
10:00:16 <daydaynatation> and in the code, there is a do notation inside a maybe:  n <- eval exp1, m <- eval exp2, n `safeDiv` m
10:00:20 <thblt> dsal: I'm writing a classification system, a bit like a filesystem, but where the same entity may live in multiple "directories", so I need them to have a stronger identity than Eq.  But I guess this constrainst belong in the functions, not the type.  
10:01:05 <daydaynatation> I can't understand when eval exp1 == Nothing, how the program somehow automatically deals with it
10:01:15 <dsal> thblt: Right.  You want the constraint because at some point you might call a function that has that constraint.  That will cause your type to also have that constraint.  If you don't call that function, it's just unnecessary overhead.
10:01:29 <Ailrun[m]> It's just how `>>=` for `Maybe` is implemented.
10:01:58 <dsal> daydaynatation: Try it without do.  It'll be more obvious.
10:02:02 <dsal> do is confusing you, I think.
10:02:09 <Ailrun[m]> @undo do { n <- eval exp1; m <- eval exp2; n `safeDiv` m }
10:02:09 <lambdabot> eval exp1 >>= \ n -> eval exp2 >>= \ m -> n `safeDiv` m
10:03:00 <daydaynatation> exactly here! so Nothing >>= \ n -> eval exp2 ...
10:03:06 <Ailrun[m]> If `eval exp1` becomes `Nothing`, then the first `>>=` will just ignore the rest of that code.
10:03:07 <daydaynatation> what is that n ?
10:03:21 <sm[m]> p0a: hourly rates for haskell coaching
10:03:28 <thblt> dsal: thanks!
10:03:37 <Ailrun[m]> `>>=` does not execute that function, so there is no `n`.
10:03:58 <p0a> sm[m]: full range meaning 100 to 1000 or what? how crazy is the bay area these days?
10:04:11 <daydaynatation> ok.. and it's defined in the Monad instance of Maybe?
10:04:17 <p0a> I can't pay 1000 that's for sure but I would like some expert advice on my finished product
10:04:30 <Ailrun[m]> Yes, specifically in the definition of `>>=`.
10:04:41 <sm[m]> $10 for some friently rando on the internet to name-your-price for specialised need it right now help
10:04:51 <MarcelineVQ> @src Maybe (>>=)
10:04:51 <lambdabot> (Just x) >>= k = k x
10:04:51 <lambdabot> Nothing  >>= _ = Nothing
10:05:05 <sm[m]> if you're looking for such help, have you seen codementor.io
10:05:05 <p0a> sm[m]: okay I think I Can figure something out when time comes
10:05:25 <p0a> sm[m]: thank you, I did not know about that. saved
10:05:25 <daydaynatation> I finally got it
10:05:28 <dsal> daydaynatation: ^ I was just about to pull out that thing MarcelineVQ pointed out.  You can sort of think of it like if (without else).  If it's got a value, it calls your function with it.  If it doesn't, then it doesn't.
10:06:00 <sm[m]> there's also some nice haskell consulting firm that offered ongoing support for a quite reasonable flat monthly fee. Does anyone remember the name ?
10:06:04 <dsal> 'do' muddies this a bit because it's not obvious that it's nesting those functions.
10:06:19 <p0a> sm[m]: for me it'd be a 1-time thing. Are you talking about fpcomplete btw?
10:06:27 <daydaynatation> In MarcelineVQ code, in the nothing case, I didn't understand at first that it means **ignore** the rest of the code...
10:06:32 <maerwald> p0a: also check out well-typed
10:06:35 <sm[m]> no, a smaller firm
10:07:02 <dsal> daydaynatation: It doesn't *mean* ignore the code, but it doesn't have a value to call it with, so it doesn't call it, so it's effectively ignored.
10:07:03 <maerwald> sm[m]: https://typeclasses.com/company this one?
10:07:03 <daydaynatation> What did MarcelineVQ do to print out the source?
10:07:28 <daydaynatation> Is it a ghci trick?
10:07:33 <dsal> daydaynatation: See his last message.  But that's not canonical source, it sometimes just tells you how to think about things.
10:07:35 <dsal> It's lambdabot
10:07:38 <Ailrun[m]> No, it's lambda bot.
10:07:41 <sm[m]> p0a: better link: https://www.codementor.io/haskell-experts
10:07:48 <MarcelineVQ> no, lambdabot has a text file with some common definitions in it, I​ just had it print what it had for >>= for Maybe. It's not official source code at all, just a text file.
10:08:03 <Ailrun[m]> https://wiki.haskell.org/Lambdabot
10:08:06 <MarcelineVQ> Though, there's really no other way to write that, so it's official enough :>
10:08:13 <Ailrun[m]> It's an IRC bot
10:08:23 <daydaynatation> I just checked that it's the same as in the ghc source code
10:08:52 <daydaynatation> very handy thanks
10:09:35 <dsal> Some of the definitions are not what the actual code does, but provide a good mental model.
10:11:16 <haveo> sm[m]: https://www.reddit.com/r/haskell/comments/79n679/dirt_cheap_haskell_a_100mo_haskell_consultancy/
10:11:20 <haveo> doesn't seem to exist anymore
10:13:01 <sm[m]> that was it. A pity.. guess they went out of business or became superexpensivehaskell.io
10:17:42 <thblt> sm[m]: They *may* have become https://monadfix.com/
10:18:17 <koz_> sm[m]: Why is there no reasonably-priced-haskell.io? :P
10:18:53 <thblt> reasonably-priced-although-a-bit-on-the-expensive-side-but-honestly-worth-it-haskell.io
10:19:30 <dsal> I assume all these are competitors.
10:19:37 <koz_> worth-it-haskell.io <- deffo needs to be a thing
10:20:06 <dsal> Are there other monad TLDs?   worth-it-haskell.maybe
10:20:14 <koz_> (L'Oreal Haskell? :P)
10:20:21 <p0a> monads-without-gonads.io, the feminist one
10:20:27 <koz_> worth-it-haskell.list probably exists?
10:21:02 <dsal> worth-it-haskell.st is probably easier to reason about than .io
10:21:19 <p0a> I have a feeling we are all pretty bad at choosing domain names
10:21:30 <koz_> dsal: But isn't worth-it-haskell.io really worth-it-haskell-real.world?
10:21:45 <koz_> Well, worth-it-haskell-real-world.st.
10:22:35 <AndreasK> I know things like foo = "affordable-haskell.io" will result in a top level Addr# binding with optimization. What's the best way to get a hold of that if available?
10:23:02 <AndreasK> Or better, is there a simpler way then rewrite rules :)
10:23:24 <koz_> And why we gotta limit ourselves to monad TLDs? worth-it-haskell.store. :D
10:27:47 <maerwald> unfortunately .hs does not exist as top level domain
10:27:54 <thblt> Or steal .rs
10:29:23 <glguy> Declare a new country, get .hs assign, provide Haskell services
10:29:48 <maerwald> become rich.
10:29:52 <dsal> Something about tax haven.
10:30:15 <davean> Its more of a type haven.
10:30:47 <thblt> there's .pf
10:30:53 <thblt> purely functional
10:31:23 * hackage git-brunch 1.1.0.0 - git checkout command-line tool  https://hackage.haskell.org/package/git-brunch-1.1.0.0 (andys8)
10:33:24 * hackage base64 0.3.1.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.3.1.0 (topos)
10:34:19 <topos> @ vaibhavsagar ^ should work fine for lts-11 now
10:36:31 <vaibhavsagar> Thank you!
10:51:24 <madnight> Is there a CoFunctor?
10:52:25 <thekkid[m]> Contravariant functor
10:54:42 <topos> there is in the sense that there's an acme package which is just `cofmap :: (b -> a) -> f b -> f a` (har har har, because Functors are self-dual), there's contravariant functors in the contravariant-* package if you're thinking "contravariance", but there's no such "true cofunctor" package in the sense of discrete opfibrations
11:03:38 <madnight> "Functors are self-dual" could you elaborate on that? What other algebraic structures are also self-dual?
11:04:37 <shapr> I kinda got that when I read up edwardk's intro to comonads.
11:09:24 <koz_> madnight: Essentially, in category theory, you can obtain stuff from other stuff by 'turning the arrows around'. A good example is the monad/comonad thing. However, a cofunctor is just a functor - hence self-dual.
11:09:34 <koz_> In terms of other self-dual things, I dunno - functor is the famous one.
11:18:58 <madnight> Ah ok, so if arrows reversing is structure preserving then it's self-dual
11:22:24 * hackage reflex-vty 0.1.2.1 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.2.1 (abrar)
11:26:42 <Uniaika> good morning (UGT)
11:33:20 <ysangkok> universal greenwich time? :O
11:36:18 <raichoo> tzag (time zone approriate greeting)
11:41:58 <pounce> trying to figure out arrows XwX
11:43:06 <koz_> pounce: You working with HXT or something?
11:43:13 <pounce> no just thonkin
11:43:43 <pounce> trying to figure out what they're about because all i know are arrows and bifunctor people use for tuple combinators sometimes
11:43:49 <shapr> I made a pile of money off HXT once, it was great
11:44:26 <cocreature> pounce: that’s the only thing arrows are used for ;)
11:44:34 <pounce> 🤔
11:44:37 <jle`> arrows are more or less a dead abstraction
11:44:43 <koz_> cocreature: I think Yampa is the other one.
11:44:46 <pounce> but tuples aren't even profunctors right so idk what they have to deal with arrows
11:44:55 <koz_> jle` is like, the Candyman of arrows.
11:45:12 <jle`> pounce: arrows just use them for one of their typeclass methods
11:45:21 <koz_> Say 'arrow' three times in the mirror, and jle` will appear behind you to say 'arrows are more or less a dead abstraction'. :P
11:45:29 <jle`> that's my job :)
11:46:04 <pounce> what about kliesli arrows aren't those a thing that are all over
11:46:21 <cocreature> koz_: yampa is a fairly niche thing so I’m not sure that disproves the point that arrows aren’t used much outside of tuples :)
11:46:29 <jle`> they are all over, but working with them via the Arrow abstraction has no benefit
11:46:46 <pounce> hum
11:46:47 <jle`> the easiest way to use kleisli arrows is just with function application, <=< and =<<, etc.
11:47:08 <pounce> a-are <=< and =<< not kleisli arrows
11:47:10 <pounce> they look like arrows
11:47:12 <jle`> think about this: when was the last time you used Sum the newtype wrapper, instead of just writing 5 + 3 ?
11:47:24 <jle`> pounce: they are functions that take the conceptual idea of kleisli arrows as inputs
11:47:34 <jle`> pounce: but they aren't a part of the Arrow typeclass
11:47:58 <jle`> er, you don't use them via the Arrow typeclass
11:48:22 <pounce> 🤔
11:48:48 <jle`> you use kleisli arrows by just ... using them
11:48:51 <jle`> % putStrLn "hello"
11:48:51 <yahb> jle`: hello
11:48:56 <jle`> there, i just used the `putStrLn` kleisli arrow
11:49:05 <jle`> no need for the Arrow typeclass :)
11:56:55 <ysangkok> but is that not just kleisli in the category sense? (->) is not an actual instance of Kleisli newtype from Control.Arrow
11:57:54 <ysangkok> at least, if i do ":info (->)" it doesn't list Kleisli
11:58:46 <jle`> hm, (->) and Kleisli are both types, not typeclasses
11:58:50 <jle`> i'm not sure what you are asking exactly
11:59:07 <koz_> ysangkok: You could argue that (->) is kinda-sorta Kleisli Identity?
11:59:40 <koz_> Though I am unsure what that gets you - there aren't really any type classes for which Kleisli Identity _is_ an instance, but (->) isn't.
11:59:48 <koz_> (Kleisli is somewhat lacking in instances IMHO)
12:03:01 <p0a> yikes finally done with the shakespeare chapter on the yesod book
12:08:54 * hackage persistent-mongoDB 2.9.0.2 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.9.0.2 (parsonsmatt)
12:12:14 <pounce> how do i exec a program in haskell
12:12:45 <solonarv> @hackage process
12:12:46 <lambdabot> http://hackage.haskell.org/package/process
12:12:47 <solonarv> or:
12:12:51 <solonarv> @hackage typed-process
12:12:51 <lambdabot> http://hackage.haskell.org/package/typed-process
12:12:52 <davean> pounce: "cabal run" does it 
12:13:04 <davean> pounce: or "cabal build" will print out the exectuable location
12:13:17 <davean> pounce: plus you can install it and add the installation location to your path (or reference it directly)
12:13:19 <solonarv> pounce: alright, since you got two entirely different answers: what is it you are trying to do?
12:13:48 <koz_> This is what happens when you get answers in the list monad.
12:14:06 <pounce> solonarv: yours
12:15:43 <solonarv> something at the back of my memory says a nice new process library was recently released, too
12:16:58 <solonarv> but I can't seem to find it, oh well
12:21:47 <davean> solonarv: tops process-lens?
12:21:51 <davean> *topos'
12:22:11 <davean> http://hackage.haskell.org/package/lens-process
12:22:15 <davean> solonarv: that what you mean?
12:22:47 <topos> that's not a rewrite, just something to make typed system processes more amenable
12:23:38 <topos> process definitely needs a haircut, if not a rewrite
12:25:04 <pounce> hmm maybe this isn't a problem for haskell
12:25:11 <pounce> ill do it half in sh or something lol
12:25:29 <jle`> if you're doing shell scripting, i hear the 'turtle' library is nice for that
12:25:33 <jle`> it's like bash with types
12:25:38 <topos> I was planning on doing this solonarv. unfortunately, new cbits would be a PITA - there's decades of nuance there in a little over 1000 lines of code.
12:25:48 <topos> I propose we work together and use the existing cbits, but write a new lib on top of it if you're okay with that 
12:26:03 <solonarv> ah, so I did remember correctly that you were involved somehow
12:26:06 <topos> yeah
12:26:15 <topos> i was probably complaining about it in july ish
12:26:17 <topos> :P
12:26:27 <solonarv> I had just somehow gotten the impression you had released it recently :P
12:26:50 <topos> i released base64 recently, which tackles -a- problem we have, but not that problem :)
12:26:56 <p0a> how does turtle use hoogle and Turtle.Tutorial to have a tutorial?
12:26:57 <p0a> https://hackage.haskell.org/package/turtle-1.5.15/docs/Turtle-Tutorial.html
12:27:37 <solonarv> p0a: haddock, not hoogle
12:28:03 <solonarv> as to how: just click that handy "source" link in the top right ;)
12:28:23 <p0a> solonarv: right, haddock! thanks
12:29:31 <solonarv> mnemonic: haddock = haskell + doc(umentation); hoogle = haskell + google
12:29:39 <p0a> I see 
12:29:45 <p0a> well the source file seems a bit of a mess to maintain to be honest
12:30:50 <solonarv> oh, I'm sure it is
12:31:45 <solonarv> and unfortunately, for this kind of library there's not really a good way to leverage doctests or anything
12:42:20 <jle`> p0a: it's basically just a module header
12:42:27 <jle`> p0a: with no module contents
12:42:40 <jle`> p0a: remember that hackage docs for modules can have module headers to describe the module
12:42:59 <jle`> basically Turtle.Tutorial is one giant module header
12:43:55 <jle`> er well, also section headers too
12:44:03 <p0a> right so it's an empty module
12:44:33 <p0a> it pollutes the namespace (or w/e is called) though
12:45:41 <thblt> It's a relatively common pattern in Haskell, from what I've seen.
12:46:05 <p0a> Well that's good to know, I might in fact imitate it when time comes
12:52:24 * hackage reflex-process 0.1.0.0 - reflex-frp interface for running shell commands  https://hackage.haskell.org/package/reflex-process-0.1.0.0 (abrar)
12:59:53 <topos> abrar nice
13:00:16 <topos> hmu if you want to make that optical and classy. I can piggy back on some existing primitives for it
13:16:14 <deech> Is there a way to specify that an executable must be in PATH in a Cabal file? The closest stanza build-tools is only for Haskell buildable executables like 'c2hs' but does not work for, eg. 'pkg-config' or 'tar' etc.
13:20:24 * hackage reflex-fsnotify 0.1.0.0 - reflex-frp interface for watching files  https://hackage.haskell.org/package/reflex-fsnotify-0.1.0.0 (abrar)
13:34:16 <dmwit> deech: For pkg-config, use pkg-config-depends. Can you use the Haskell tar library instead of the tar executable?
13:34:51 <dmwit> But those are specific answers. The general answer is no, I believe.
13:45:10 <iqubic> I'd love to have a version of div that is Int -> Int -> Int that rounds towards positive inifinity.
13:46:56 <dminuoso_> iqubic: ceiling ?
13:47:00 <dminuoso_> Oh
13:47:02 <dminuoso_> Division
13:47:27 <dminuoso_> My brain processed that wrong
13:47:41 <xcoder> whats up in this room 
13:47:43 <iqubic> Yeah.
13:48:00 <iqubic> xcoder: We are discussing the lovely Haskell programing langauge
13:51:46 <sim590> ... and avoiding the not so lovely packaging system. ( ͡° ͜ʖ ͡°)
13:53:52 <iqubic> So, anyone know what I can use as my `div` that rounds towards positive inifinity?
13:54:38 <nshepperd2> ceilDiv a b = div (a-1) b + 1 
13:56:18 <nshepperd2> this works when a and b are positive. i think maybe you need a different case for when one is negative
13:56:51 <iqubic> This will work for my case. a and b are both positive here.
13:59:54 * hackage reflex-vty 0.1.3.0 - Reflex FRP host and widgets for vty applications  https://hackage.haskell.org/package/reflex-vty-0.1.3.0 (abrar)
14:03:44 <abrar> topos: i'd welcome a pull request. let me know if you want to discuss any aspect of the package
14:04:35 <iqubic> nshepperd2: thanks for your help
14:06:40 <iqubic> And it fails in only one case: b < 0 && a `mod` b == 0
14:08:25 <iqubic> At least that is what my preliminary testing tells me.
14:21:26 <amalloy> sounds like an infinite number of cases
14:24:53 <iqubic> I should have said that it only fails for that specific condition.
14:26:47 <monochrom> "case" and "law" should be uncountable
14:27:02 <iqubic> What does that mean?
14:27:18 <monochrom> Because you can always play with how you group things together and count the whole group as "1".
14:27:38 <amalloy> ceilDiv 4 (-3) also looks incorrect, fwiw: shouldn't -4/3 rounded towards positive infinity be -1?
14:28:15 <monochrom> For example you get to say "I have two laws: x+y=y+x, x+0=x".  But they can also be one law "x+y=y+x ∧ x+0=x"
14:28:59 <iqubic> amalloy: Correct.
14:29:06 <nshepperd2> i have 15 bytes of law
14:29:08 <iqubic> So it doesn't work for negative numbers.
14:29:16 <iqubic> Which is fine for my uses.
14:29:34 <Ailrun[m]> > ceilDiv (-4) 3
14:29:37 <lambdabot>  error:
14:29:37 <lambdabot>      Variable not in scope: ceilDiv :: Integer -> Integer -> t
14:29:38 <monochrom> "case" is even more ubitiquous.  Proofs keep saying like "there are 3 cases.  case 1: x>0.  case 2: x<5.  case 3: the rest".
14:30:03 <iqubic> @let ceilDiv a b = div (a-1) b + 1
14:30:05 <lambdabot>  Defined.
14:30:13 <iqubic> > ceilDiv (-4) 3
14:30:15 <lambdabot>  -1
14:30:44 <monochrom> One person's aleph-1 cases is another person's 0.5 cases.
14:30:53 <iqubic> Lol.
14:30:53 <Ailrun[m]> > ceilDiv 4 (-3)
14:30:56 <lambdabot>  0
14:31:03 <amalloy> imo we should outlaw negative divisors
14:31:22 <monochrom> I can second that.
14:31:49 <amalloy> really they're just even smaller zeros, and so so should be even more illegal to divide by than zero
14:31:51 <nshepperd2> I don't think there's anything wrong with being able to divide cases as you like
14:33:19 <dsal> Division by negative zero is a felony.
14:35:42 <monochrom> nshepperd2: Nothing wrong, but this is why "case" and "law" should be uncountable, like baking soda.
14:36:31 <monochrom> There is nothing wrong with dividing a kilogram of baking soda as you like.
14:37:18 <nshepperd2> "I have three piles of baking soda"
14:37:32 <nshepperd2> "cases" are the piles, not the soda
14:38:51 <monochrom> Like 3 cases of beer? :)
14:38:58 * monochrom prefers 3 cases of wine
14:39:13 <monochrom> desugared grape juice
14:39:25 <nshepperd2> @let ceilDiv' a b = signum (a*b) * (div (abs a - 1) (abs b) + 1)
14:39:27 <lambdabot>  Defined.
14:39:41 <nshepperd2> hm, no
14:40:53 * hackage reflex-process 0.1.0.1 - reflex-frp interface for running shell commands  https://hackage.haskell.org/package/reflex-process-0.1.0.1 (abrar)
14:41:54 <nshepperd2> @let ceilDiv'' a b = if a*b > 0 then div (abs a - 1) (abs b) + 1 else quot a b
14:41:56 <lambdabot>  Defined.
14:42:07 <nshepperd2> > ceilDiv'' (-4) 3
14:42:09 <lambdabot>  -1
14:42:28 <nshepperd2> > ceilDiv'' 4 (-3)
14:42:30 <lambdabot>  -1
14:42:47 <daydaynatation> when do people instantiate them data types with Monad? What's the advantage? Only be to able to use the do notation?
14:43:10 <glguy> or any other definitions that use Monad
14:43:41 <dminuoso_> daydaynatation: Any combinator that is written polymorphically over monads.
14:43:44 <dminuoso_> % :t replicateM
14:43:44 <yahb> dminuoso_: Applicative m => Int -> m a -> m [a]
14:43:59 <p0a> Can I get some help in understanding the identation in the do block here? https://pastebin.com/CaG0PmuA
14:44:01 <dminuoso_> For instance (dont mind the Applicative, assume it says Monad there)
14:44:10 <p0a> in particular lines 3-5
14:44:30 <p0a> they're very sensitive to indentation; tabbing 4 or 5 gives me errors
14:44:42 <nshepperd2> monochrom: i prefer three cases of port
14:44:53 <nshepperd2> that lasts a long time
14:45:19 <monochrom> You have 2 levels of "do", of course indentation affects which level you end up with.
14:45:34 <dminuoso_> monochrom: Why should that matter in that example though?
14:45:37 <monochrom> Better wording: which level the computer thinks you mean.
14:45:42 <p0a> ooooh nevermind, I get it now
14:46:06 <monochrom> "myfunction $ do" is why it matters.
14:46:21 <p0a> monochrom: right, thanks
14:46:34 <nshepperd2> also pc isn't in scope in the inner 'do'
14:46:40 <oats> p0a: what's the error
14:47:04 <oats> ah, nevermind :)
14:47:07 <oats> I was scrolled up a bit
14:49:37 <monochrom> Do they also have a [asYouLikeIt | ...]?  [muchAdoAboutNothing | ...]?  >:)
14:51:13 <p0a> hey I like yesod
14:51:42 <p0a> monochrom: like I said before, learning Yesod after a long hiatus from PHP is a bit of a time travel
14:54:23 <iqubic> What is hamlet doing there?
14:55:44 <monochrom> I have a great idea for [muchAdoAboutNothing| ...].  It takes the string you give and treats it as base-whatever notation for a natural number, call it n.  It computes ackermann(n, n) and tests whether it is positive.  It gives a Boolean answer.
14:55:58 <monochrom> No wait, I have an improvement over that.
14:56:42 <monochrom> Instead of Boolean: It gives a polymorphic "Maybe a" answer.  If positive, the answer is "Nothing".  There!
14:57:08 <p0a> monochrom: are you criticizing yesod for being overly complicated without achieving much?
14:57:18 <p0a> Or what are you saying? I can't tell 
14:57:29 <monochrom> No, I am just having fun with Shakespeare-inspired names.
15:12:58 <iqubic> I love it when I can write polymorphic lens code.
15:16:19 <iqubic> Because I just wrote some code that was polymorphic over what sort of folding operation it would be doing.
15:26:22 <pie_[bnc]> has anyone seen any FFI designs that support passing around ADTs?
15:26:53 <monochrom> No.
15:27:09 <monochrom> May be possible if FFI-ing to SML or something.
15:27:48 <monochrom> If the other language has never heard of ADT, there really nothing you can do.
15:28:13 * pie_[bnc] just wants cool and good haskell/rust interop tbh
15:28:16 <monochrom> Sapir-Worf applied to FFI
15:28:28 <pie_[bnc]> hehe
15:28:32 <monochrom> Yeah Rust is also possible, but no one has done it.
15:28:55 <pie_[bnc]> well, thats the origin of my curiosity
15:29:08 <monochrom> Even FFI-to-JVM is on a 20-year-old TODO list that never got done.
15:29:45 <monochrom> Rust is going to give you a different headache though, from its borrow system.
15:30:23 <iqubic> monochrom: Doesn't Frege exist?
15:31:09 <monochrom> because Haskell's ADTs are created recklessly and destroyed GCly and utterly oblivious to Rust's ownership concerns.
15:31:11 <merijn> iqubic: Frege is an implementation of Haskell on the JVM, *not* an FFI to the jvm
15:31:34 <iqubic> Oh. I didn't know that.
15:31:46 <iqubic> Now, in this case.. I do want FFI to the JVM.
15:32:22 <monochrom> Actually the creation is not reckless, the passing around and sharing is.
15:32:23 * hackage shellmate 0.3.4.3 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.4.3 (AntonEkblad)
15:33:23 * hackage shellmate-extras 0.3.4.3 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3.4.3 (AntonEkblad)
15:40:21 <pie_[bnc]> monochrom: sure but for starters just understanding some plain old serialized data would be nice
15:40:41 <pie_[bnc]> s/serialized//
15:40:58 <pie_[bnc]> just say, f*** it here is some static data, deal with the lifetimes some other way
15:41:04 <pie_[bnc]> or whatever C ffi does
15:41:42 <merijn> pie_[bnc]: C FFI does nothing
15:41:49 * pie_[bnc] shrugs cluelessly
15:42:02 <pie_[bnc]> i see
15:42:08 <monochrom> I guess if Haskell ADT values are presented as immutable data on the Rust side, the borrow issues are much simpler.
15:42:16 <merijn> pie_[bnc]: The C FFI is limited to the C ABI (aka primitive types and pointers)
15:42:23 <pie_[bnc]> merijn: right
15:42:43 <merijn> Although you can serialise stuff to arbirary byte arrays, but then C doesn't understand it anyway
15:42:50 <pie_[bnc]> product and sum types dont sound so far off from that
15:43:00 <pie_[bnc]> i mean, in some abstract notion
15:43:06 <pie_[bnc]> obviously they arent C types
15:43:12 <pie_[bnc]> *arent primitive C types
15:45:17 <pie_[bnc]> I just started learning rust and "wouldnt it be nice if you could return an ADT item from main" crossed my mind
15:45:30 <pie_[bnc]> that of course pulls with it dumping the entire os stack (or not) but yknow ;P
16:11:23 * hackage cyclotomic 1.0.1 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-1.0.1 (ScottWalck)
16:30:49 <adius> Hi,  I have a data-file in one of my projects. Is it possible to let it be compiled into / included in the final binary?
16:31:06 <adius>  Right now I'm getting copyFile:atomicCopyFileContents:withReplacementFile:copyFileToHandle:openBinaryFile: does not exist (No such file or directory)
16:31:14 <adius>  Right now I'm getting `copyFile:atomicCopyFileContents:withReplacementFile:copyFileToHandle:openBinaryFile: does not exist (No such file or directory)`
16:34:32 <leifm> Is there a `pure-able` typeclass? i.e. something that provides `pure :: a -> f a` but not `fmap` or anything else.
16:38:42 <leifm> In Haskell or category theory
16:39:38 <lyxia> https://hackage.haskell.org/package/pointed-5.0.1/docs/Data-Pointed.html#t:Pointed
16:41:18 <leifm> thanks
16:41:26 <leifm> Is it used for anything?
16:41:52 <leifm> found this nvm: https://wiki.haskell.org/Why_not_Pointed%3F
16:44:42 <lyxia> It's not very useful, you might as well just add a (a -> f a) parameter
17:10:09 <oats> so this is really petty, but is there a more elegant way to write this?
17:10:12 <oats> parseDrawCmds = liftM3 (liftM3 (,,)) await await await >>= \case
17:10:13 <oats>   Just (x, y, n) -> yield $ DrawCmd (toEnum n) (V2 x y)
17:10:15 <oats>   _              -> pure ()
17:12:12 <pie_[bnc]> can you uhhhh, fmap those awaits?
17:16:50 <AWizzArd> In ghci I activate :set +s  and then I run  foldl' (+) 0 [1..10000]  from Data.List and see a memory consumption of 1.6 MB. Why?
17:17:00 <AWizzArd> Shouldn't this consume something like, say, 30 Bytes of RAM?
17:19:23 <koz_> AWizzArd: GHCi doesn't optimize as much.
17:19:45 <AWizzArd> koz_: but what might actually allocate this RAM?
17:20:23 <koz_> GHCi might treat every element of that list as an Integer, which is arbitrary-sized. Every Integer is boxed, so that costs something too.
17:20:37 <koz_> GHCi itself may have overheads.
17:20:41 <koz_> There's a lot of possibilities here.
17:21:08 <koz_> If you care about performance, _use a file and compile it_.
17:21:13 <koz_> GHCi is for experimentation.
17:23:41 <AWizzArd> Of course. I was just curious about what might be going on under the hood.
17:26:36 <ChaiTRex> AWizzArd: I think it also adds together the memory allocations without subtracting any deallocations, so that might have used only a few bytes that got recycled over and over again. I once had a line that took 6 GB without swapping when my computer had 2 GB of memory.
17:26:53 <juri_> yay, going to zurihac. :)
17:30:16 <AWizzArd> ChaiTRex: probably something like this
17:32:19 <dmwit> :t liftM3 (liftM3 (,,))
17:32:21 <lambdabot> (Monad m1, Monad m2) => m1 (m2 a) -> m1 (m2 b) -> m1 (m2 c) -> m1 (m2 (a, b, c))
17:33:55 <dmwit> oats: Is pure () really the right thing?
17:34:28 <dmwit> If not, you might consider using MaybeT.
17:36:09 <divVerent> AWizzArd: as for memory usage, this may help:
17:36:11 <divVerent> Prelude Data.List> [1..10000] !! 9999
17:36:13 <divVerent> 10000
17:36:15 <divVerent> (0.01 secs, 783,312 bytes)
17:36:31 <oats> dmwit: ooh, I think that would be easy to add to my stack :)
17:38:02 <divVerent> Prelude Data.List> let f x = if x > 0 then f (x-1) else 0 in f 10000
17:38:05 <divVerent> uses even more space
17:38:48 <ChaiTRex> divVerent: What happens if you have f !x = ...?
17:38:53 <divVerent> basically, it seems like it's all the integer objects
17:40:28 <ChaiTRex> Ahh, seems the same.
17:41:43 <divVerent> same, yes
17:41:52 <divVerent> the function is probably simple enough for strictness analysis
17:42:04 <divVerent> I suspect (without knowing) that each iteration makes a new integer object which eventually gets GC'd
17:42:37 <divVerent> is +s BTW total allocation amount or max memory usage?
17:44:26 <divVerent> yeah, I bet it's total allocation amount
17:44:39 <divVerent> because "top" shows no large increase in RSS while this runs
17:44:57 <divVerent> for let f x = (if x > 0 then f (x-1) else 0) in f 10000000
17:45:07 <divVerent> while +s claims 1.6G
17:45:31 <divVerent> so most likely it is allocating that many objects, but they tend to use the same actual memory space
17:46:29 <AWizzArd> divVerent: maybe this number represents some kind of throughput
17:52:08 <divVerent> yeah, sort of
17:52:16 <ChaiTRex> AWizzArd: No, it gives consistent results regardless of how long the same evaluation takes, so it's not a rate like a throughput. What it acts like is a sum of memory allocations.
17:53:23 <divVerent> in any case
17:53:24 * hackage predicate-transformers 0.7.0.0 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.7.0.0 (edmundnoble)
17:53:34 <divVerent> with normal ghc the code is horrible and really creates a new Int object every subtraction
17:53:40 <divVerent> and only the GC makes this not a huge leak
17:53:50 <divVerent> but with ghc -O2 it almost becomes the simple subtraction loop one would expect
17:55:13 <ChaiTRex> You can also use optimized code in GHCi, but you have to write it to a separate file and compile it first.
17:55:14 <divVerent> actually, the generated code seems very efficient and has the same instruction count as usual, except that it seems like it jumps when there's another iteration rather than when there is none
17:56:04 <divVerent> http://paste.debian.net/
17:56:14 <divVerent> optimized code for this "clear Int by subtraction" function
17:57:07 <divVerent> I find this calling convention kinda odd, but otherwise it's what one would expect
17:57:22 <divVerent> if I don't optimize, however, it actually runtime-resolves the type class members of Ord Int and Num Int
17:57:44 <divVerent> I mean, it uses their instance tables and calls indirect functions from there
17:58:07 <divVerent> and that clearly must create new objects every call then (the code does look that way too but I am not 100% sure)
17:58:13 <divVerent> and I bet the exact same happens inside ghci
17:59:46 <divVerent> http://paste.debian.net/1125546/ - the unoptimized code for just the subtraction
17:59:54 <divVerent> sorry above - http://paste.debian.net/1125544/ is the optimized code
18:00:32 <divVerent> and I would assume the unoptimized code should be a kinda good proxy for what'd happen in ghci
18:01:23 <divVerent> now I don't know the calling convention well enough to know whether GHC.Num.- is called with a pointer to where to store the subtraction result
18:01:27 <divVerent> or whether it actually allocates a new Int
18:03:43 <divVerent> but it looks like stg_ap_pp_info is not a space to write output to, but a symbol of the runtime
18:03:49 <divVerent> with code behind it
18:03:55 <divVerent> (and read only)
18:04:14 <divVerent> so this call to Num.- doesn't look like it receives any information about where to put the output, which means it must allocate it on its own
18:04:39 <ChaiTRex> divVerent: You can probably look at the Core with -ddump-simpl or something to see what it does. Int# is an Int that's unboxed, I# is the constructor that boxes it into a regular Int.
18:05:05 <divVerent> cool, yeah
18:05:22 <divVerent> that would have been simpler than reverse engineering the x86_64 code
18:09:53 * hackage predicate-transformers 0.7.0.1 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.7.0.1 (edmundnoble)
18:21:54 * hackage predicate-transformers 0.7.0.2 - A library for writing predicates and transformations over predicates in Haskell  https://hackage.haskell.org/package/predicate-transformers-0.7.0.2 (edmundnoble)
18:36:53 * hackage persistent-postgresql 2.10.1.2 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.10.1.2 (MaxGabriel)
18:53:57 <fog> how do dictionaries work with recursive GADTs?
18:54:54 <shachaf> I suspect a typical English dictionary would have the word "recursive" but not "GADT".
18:54:58 <shachaf> So about 50% coverage.
18:55:17 <koz_> shachaf: ROFL.
18:55:44 <koz_> shachaf wins the 'Most literal wrong answer' prize.
18:56:15 <fog> i could try and ask in %100 haskell...
18:57:16 <fog> but find english helps
18:57:54 <fog> like, noramlly a dictionary wouldnt have a tail... 
18:58:17 <koz_> fog: Is your question roughly thus? https://gist.github.com/kozross/662ce494a2f6bcd71fb1fc6b746cf415
18:58:34 <fog> it doesnt seem to match all the constraints into scope, i figure i need to fetch them somehow
19:00:06 <fog> no, i have a recursive use that has a type error complaining about how the recursion demands the constraints of the tail are satisfied, but it cant seem to tell that they are because the tail isnt matched over each value 
19:00:23 <koz_> fog: Could you gist up what you've got then? It's a bit vague as-is to answer.
19:00:50 <fog> i could but its an almighty type error
19:01:10 <koz_> fog: It's OK. More information is better - we might be able to tell what's going on.
19:01:29 <fog> your tree example is difficult to addapt too, because it would need a tree of constraints as a param to store them
19:02:00 <fog> koz_: ok, one sec. its far from a least sufficient example though
19:08:27 <fog> https://gist.github.com/fog-hs/e7a2447448f0b478ebdeeac85ad50330
19:09:27 <fog> Could not deduce (ObtainFunction2 (y -> z -> z) c1)
19:10:04 <fog> where it was matching the list of (x ': y ': z ': xs)
19:10:17 <fog> where this constraint is stored as the dictionary of the tail
19:12:11 <fog> the "output type" class is a bit of a hack, because it needs a new version of the function being used to fold, which is polymorphic, but has its type bound to just work on the values for its call to the head
19:13:24 <fog> sorry, not the output type, thats needed for the fold, but the ObtainFunction2 class, so from the constraint itself the function can be determined
19:13:53 <fog> so that its still polymorphic to be used to fold the tail
19:14:12 <fog> so instead of taking a folding function as an argument, it has this as a constraint
19:15:16 <fog> i guess a more simple example would be like your tree version, but with a hetrogenous constraint
19:15:30 <fog> and it would be more simple to do a list to start with than a tree
19:16:35 <koz_> fog: Could you write a small example to demonstrate what you mean by a 'heterogenous constraint' here?
19:16:55 <fog> but then im not sure if it would be possible to reproduce the error on a simple HList, since its the recursion thats making these constraints on the tail need to be brought into scope
19:18:11 <fog> data HConstraitList (xs :: [k->Constraint]) (ys :: [k]) ... 
19:18:41 <koz_> So you want k to be an arbitrary kind?
19:18:48 <fog> where these lists are certainly the same length since they are consed to be the constructor
19:19:06 <fog> i guess k could be *, but its for use at type level so you could want a HList of types
19:19:22 <fog> of wait, the constraint probably doesnt work at type level?
19:19:27 <fog> maybe it could be *, not sure
19:20:13 <koz_> The thing is, what you currently have is _two_ typelevel lists, one full of k -> Constraint, the other, which _bears no relation to the first in any way GHC can see_ full of k. The only thing connecting them is that k _must be the same for every entry of both lists_.
19:20:13 <fog> like, if it just stores values then its *, but if it can store types these could have arbitrary kind
19:20:19 <koz_> I have grave doubts that this is what you seek.
19:20:22 <koz_> On _multiple_ levels.
19:22:08 <fog> i guess it might be better then to have; data HConstraitList (xs :: [(k->Constraint,k)])
19:22:25 <koz_> You can have the constructors of the GADT guarantee it too.
19:22:31 <fog> but the smart constructor basically ensures this zip property holds
19:23:19 <koz_> The thing is, when you have that, why not just have [Constraint]? You already have a k -> Constraint and a k, so you can like, do the whole application thing.
19:23:46 <koz_> You're talking about the difference between an element like (Show, Int) and Show Int.
19:23:50 <fog> because for other things you might want to see the types of each value
19:23:51 <koz_> :k Show Int
19:23:53 <lambdabot> Constraint
19:24:03 <koz_> fog: What's your goal here?
19:24:18 <fog> well the paste is supposed to be making a hetrogenous version of fold
19:24:39 <koz_> Why roll this yourself? Singletons has this kind of machinery last I checked.
19:24:59 <fog> it just has some machinery to let each type consed onto the param to be able to see the head of the tail, as it needs both types for the interspersed fold actions
19:25:18 <koz_> There might not be a head of the tail, if the tail is empty.
19:25:56 <fog> yeah that was the problem that led to it just being an implementation of HNonempty
19:25:59 <fog> over*
19:26:26 <koz_> Doesn't change anything. Your last entry will have a headless tail right after it.
19:27:56 <fog> ah right yeah, thats why the basecase is matching (x ': y ': xs) instead of just (x ': xs)
19:28:14 <koz_> What if you have (x ': [])?
19:28:21 <koz_> This is a valid case, even in the non-empty situation.
19:28:46 <fog> on line 81
19:32:13 <fog> ok, i guess if i rewrote all the uses of C2End x as (C2Cons x []) it would have the same error 
19:32:37 <fog> sorry, C2Empty instead of []
19:33:16 <fog> and i think they need primes, like C2Empty' since its for use with defunctionalised HeadSym
19:33:24 <p0a> Hello what does `import qualified' do?
19:33:48 <koz_> p0a: If you say 'import qualified Foo', then you can only access stuff in Foo by prefixing with Foo.
19:33:56 <dmwit> p0a: First part of this answer covers it: https://stackoverflow.com/a/8331995/791604
19:34:06 <koz_> dmwit: Or that.
19:34:16 <dmwit> koz_'s answer is not precise, read mine instead.
19:34:16 <p0a> Got it, thanks. What does import Data.Arrow ((***)) do?
19:34:23 <p0a> I meant Control.Arrow 
19:34:30 <fog> :t (***)
19:34:31 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:34:40 <koz_> p0a: It imports _only_ (***) from Control.Arrow.
19:34:50 <dmwit> Well. koz_'s answer is good. You should read it, and *also* mine.
19:34:57 <p0a> Aah so *** is defined there. I didn't realize that's what was being used
19:35:02 <sagax> hi all!
19:35:06 <koz_> sagax: Wazzup?
19:35:26 <sagax> i update cabal (last version) and reinstall some packages
19:35:45 <sagax> but cabal not show this packages with `cabal list --installed)
19:35:54 <sagax> don't understand - why
19:36:23 <sagax> but i see this packages in ~/.cabal/store
19:37:16 <sagax> ghc-pkg (v8.8.1) don's see packages too
19:39:49 <fog> i figure i need to somehow do something which pattern matches over each value in the tail to retrieve all the constraints satisfied by the pairs of adjacent type 
19:39:51 <maerwald> I'm not sure if cabal list is a legacy command (as in: if it can handle nix-style build store)
19:40:20 <fog> hence the original question, how do i use dictionaries with recursive GADTs
19:40:30 <sagax> i work in linux
19:40:40 <maerwald> sagax: ?
19:41:06 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
19:41:22 <sagax> maerwald: i just clarifying my question
19:41:24 <maerwald> this way of installing packages is the new default. Some legacy commands might not work with it as expected
19:41:40 <fog> but im not really sure exactly how the dictionary even brings the constraint into scope when pattern matching just the head, so i dont really know what to do with the list of constraints i would expect to retrive
19:42:11 <fog> basically convince the compiler they really are all satisfied by construction
19:44:23 <fog> i *could* make a shorter paste where instead of needing to map the HeadSym it was a GADT that just patter matched the head of the tail, would that be helpful to read? it would make for a shorter paste
19:45:37 <p0a> dmwit: koz_: thanks again for your help
19:46:12 <oats> I love hoogle
19:46:31 <oats> figured out mapM_ was exactly what I needed for something and I didn't realize it
19:53:53 * hackage Color 0.1.0 - Common color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.1.0 (lehins)
19:59:23 <iqubic> Hmm. Does Optics have a (-~) function?
19:59:47 <iqubic> I can't seem to find it, but that seems like such a useful thing. I can't believe they would just not have it.
20:00:42 <fog> https://pastebin.com/3tyc2BRe
20:00:47 <fog> i guess thats where to start
20:05:46 <jonathan7> Can someone explain to me why GHC is complaining about Duplicate Instance with this code?
20:05:47 <jonathan7> class A aclass C ainstance C ainstance {-# INCOHERENT #-} A a => C a
20:05:54 <jonathan7> Can someone explain to me why GHC is complaining about Duplicate Instance with this code?
20:06:08 <jonathan7> class A a
20:06:11 <jonathan7> class C a
20:06:15 <jonathan7> instance C a
20:06:20 <jonathan7> instance {-# INCOHERENT #-} A a => C a
20:07:08 <glguy> jonathan7: C a and C a are in fact duplicates of each other
20:07:31 <jonathan7> But one is constrained?
20:08:16 <nshepperd> constraints don't matter for duplicatedness
20:09:02 <jonathan7> Hum, okay
20:10:36 <monochrom> "instance A a => C a" does not mean: I will check for existence of A instance before choosing this C instance.
20:11:02 <monochrom> It means: I will always choose this C instance.  And now I expect an A instance somewhere too.
20:11:25 <jonathan7> Oh, that make sense.
20:13:18 <sagax> cabal repl write me about some package that - `It is a member of the hidden package`
20:13:30 <sagax> how to install package not as `hidden package` ?
20:13:48 <sclv> add it as a dependency to the cabal file
20:13:55 <monochrom> Iff you list it in "depends:" it is not hidden.
20:13:57 <sagax> hm
20:14:06 <sagax> will try
20:17:25 <Sadie53> Hey, I'm a beginner in Haskell, trying to parse a string 'a b:c, d, e' into a list ['a b:c', 'a b:d', 'a b:e'] as well another question that I may be able to partially figure out from the reply to this one
20:18:48 <lrn2hskll> is there a space between : and c?
20:18:59 <iqubic> That doesn't matter.
20:19:06 <Sadie53> b:c, no space
20:19:30 <iqubic> Right, but ideally we'd like to get a version that works regardless of what the data is.
20:19:40 <iqubic> All we need to do is split on ", ".
20:20:33 <Sadie53> and then how should I handle reattaching that to the a b: ?... (sorry, I'm struggling with being able to say what the code should do but not getting how to code it..)
20:20:38 <lrn2hskll> and prepend the "a b:" to each
20:20:58 <jonathan7> Hoogle is not helping... https://hoogle.haskell.org/?hoogle=String%20-%3E%20String%20-%3E%20%5BString%5D
20:21:38 <iqubic> jonathan7: That's not the right signature for Sadie53's function
20:21:40 <jonathan7> You'll probably have to implement it yourself.
20:21:46 <jonathan7> Oh?
20:21:56 <monochrom> hoogle does not have AI or machine learning.
20:21:59 <iqubic> Right.
20:22:13 <iqubic> https://hackage.haskell.org/package/split-0.2.3.3/docs/Data-List-Split.html#v:splitOn
20:22:49 <Sadie53> I figure using splitOn for the ", ", should I do the same for the "a b:"?..
20:22:59 <jonathan7> Oh duh, why was I looking for a string one specifically.
20:23:16 <iqubic> Oh. I see what the issue is.
20:23:31 <jonathan7> Sadie53: is there guaranteed to be only one ":"
20:23:42 <iqubic> You want to prepend "a b:" to the start of each list.
20:23:53 <monochrom> I think they got disconnected.
20:24:09 <iqubic> Yeah.
20:24:25 <jonathan7> But only if it is not already prefixed.
20:24:33 <iqubic> Yeah. I know.
20:25:01 <iqubic> The question we should really be asking is: "Why do you want to do this particular transformation?"
20:25:14 <iqubic> Because this really really seems like an XY problem.
20:26:07 <iqubic> Sadie53 wrote: "... as well another question that I may be able to partially figure out from the reply to this one" Which makes it seem like this list parsing is not the final goal.
20:34:49 <sagax> hm, if i want recompile my xmonad.hs how i must create `.cabal` file to install xmonad package?
20:41:49 <iqubic> I don't think you need to.
20:42:27 <iqubic> Yeah... Just open a terminal and run "xmonad --recompile"
20:43:22 <iqubic> sagax: If that command gives you errors, then we can attempt to help you debug them.
20:44:03 <sagax> -_-
20:44:24 <sagax> before `xmonad --recompile` i must install packages like as `xmonad` and other
20:44:39 <iqubic> Why do you think that?
20:44:43 <sagax> and i install this packages with cabal, just type `cabal isntall xmonad` and other
20:45:00 <sagax> but all this packages install like as hidden packages
20:45:05 <sagax> and ghc not see this packages
20:45:08 <iqubic> How did you install xmoand on your machine?
20:45:16 <sagax> cabal install xmonad
20:45:32 <iqubic> Ah. I see.
20:46:33 <iqubic> I don't know much about xmonad, so I can't really help you any more than I already have. Sorry.
20:49:49 <sclv> ghc-pkg list
20:50:13 <sclv> Will list all installed packages and if they are hidden or not
20:51:03 <sclv> and “ghc-pkg expose” can unhide them
20:51:14 <sclv> Tho they shouldn’t normally install hidden
20:52:55 <slack1256> What does cabal v2-install do and how does that compare to cabal v2-install?
20:53:24 <slack1256> On cabal v3.0.0 there is a default file on ~/.cabal . I don't what that is.
20:56:51 <iqubic> slack1256: cabal v2-install does the exact same thing as cabal v2-install. I think your question has a typo.
21:10:00 <monochrom> :)
21:10:53 * hackage pretty-simple 3.2.1.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.2.1.0 (cdepillabout)
21:25:00 <koz_> iqubic: I believe the identity principle still holds, yes. :P
21:25:41 <sagax> where ghc-pkg find packages? i think that ghc-pkg just not see ~/.cabal/store
21:25:57 <sclv> it doesn’t!!
21:26:16 <sclv> Exposed packages have to be via v1-install
21:26:39 <sclv> xmonad doesn’t work out of the box with v2
21:26:39 <sagax> ghc-pkg list show that ghc-pkg see packages in `/usr/lib/ghc-8.8.1/package.conf.d` and `~/.ghc/i386-linux-8.8.1/package.conf.d`
21:27:07 <sclv> i know there’s ways to make it work with v2, but you’ll have to dig around to find them
21:27:50 <sagax> ok, try install with v1-
21:27:58 <sclv> if you v2-install the packages and list em in a global ghc env file that should work too...
21:30:13 <sagax> how to do this? how list in a global env?
21:34:57 <nshepperd> shouldn't v2-install add them to the default env file automatically
21:45:08 <slack1256> iqubic: cabal v1-install vs cabal v2-install
21:55:35 <shafox> May I have someone's emacs init file which is minimal (i.e. only haskell is configured.) I am unable use either hie or haskell-mode. Here is my init.el. https://gist.github.com/shadow-fox/0384714a52e727b0631baca3b04292df
22:03:23 * hackage incremental 0.1.1 - incremental update library  https://hackage.haskell.org/package/incremental-0.1.1 (FumiakiKinoshita)
22:15:31 <slack1256> shafox: Spacemacs is valid?
22:16:10 <slack1256> Spoken like a true sudaca. I wanted to say "is a spacemacs config valid?".
22:16:17 <shafox> slack1256, tried spacemacs however not able to configure.
22:39:26 <slack1256> Everytime I do some concurrent stuff on haskell, I end up with an event loop reading some TChan. Is there an alternative I haven't explored?
22:50:38 <dsal> slack1256: I most often use mapConcurrently or similar.
23:31:23 <dminuoso_> slack1256: spacemacs is not emacs.
23:31:50 <dminuoso_> spacemacs is just a wild messy distribution that serves no clear purpose other than annoy users as well as emacs package maintainers
23:31:56 <iqubic> Yeah.
23:32:06 <iqubic> It's a strange beast.
23:39:50 <slack1256> It's convenient <3
