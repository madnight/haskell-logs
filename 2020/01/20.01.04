00:00:04 <dsal> nyc: it's a heuristic.  I know great Java programmers and probably crappy Haskell programmers (other than myself).
00:00:06 <p0a> thank you MarcelineVQ 
00:00:38 <jsomedon> MarcelineVQ: aha the type should match, yes thanks!
00:00:44 <MarcelineVQ> you'll rarely need to use setup yourself scine stack checks whether things are set up when it runs
00:00:45 <dsal> p0a: the help isn't great.  "stack test" if the most useful thing.
00:01:06 <p0a> MarcelineVQ: the stack docs tell me to run setup after the creation of a new project 
00:01:22 <p0a> but I get your point. You're saying `build' runs `setup' ?
00:01:24 <dsal> Weird.  I've not done that.
00:01:45 <dsal> I just "stack new x && cd x && stack test"
00:02:28 <p0a> How is `stack test' different than `stack build' ?
00:02:29 <MarcelineVQ> p0a: I'm not sure it if specifically runs the same stuff setup does but the end result has been the same for me
00:03:00 <nyc> dsal: I think there's something like command of a paradigm and then once you have one language in a paradigm (e.g. functional, logic, circuit, string) the rest aren't really much of a challenge.
00:03:19 <p0a> ah `test' is shortcut for `build --test'
00:03:19 <MarcelineVQ> stack test --help   says  " Shortcut for 'build --test' "
00:03:40 <dsal> nyc: yeah. Don't hire me for logic programming...
00:04:40 <nyc> dsal: I can do logic, but my circuit and string are weak. That said, Verilog and VHDL crossdress circuit pretty well as imperative.
00:15:38 <p0a> so when I run `stack haddock' where are the docs? Right now on an empty project I see a `README.md'.
00:17:24 * hackage haskell-debug-adapter 0.0.32.0 - Haskell Debug Adapter.  https://hackage.haskell.org/package/haskell-debug-adapter-0.0.32.0 (phoityne_hs)
00:26:38 <MarcelineVQ> it should tell you when you run it, though it's quite a mouthful
00:27:50 <MarcelineVQ> while it does tell you you can also write  stack path --local-doc-root  to have stack tell you where it is for that project
00:28:27 <MarcelineVQ> cd $(stack path --local-doc-root) being a nice quick way to get there
00:28:38 <MarcelineVQ> ^ p0a :>
00:28:39 <p0a> nice MarcelineVQ , thank you 
00:28:53 <p0a> I am keeping lots of notes in a file because I will not remember any of this tomorrow 
00:29:05 <p0a> brain's got ram
00:29:13 <MarcelineVQ> you'll pick it up quick once you start using things
00:30:13 <p0a> I'm getting there. As soon as I learn some git now, I should be good to start writing some code; I will learn about packages and then jump into happstack 
00:32:10 <p0a> I'm a bit surprised that the docs are so hidden
00:33:16 <p0a> Like: ~/.../project/.stack-work/install/x86_64-linux-tinfo6/(lots of hex)/8.6.5/doc ?
00:33:28 <p0a> Would it hurt to have it under ./doc? 
00:34:39 <jackdk> p0a: does `stack haddock --open` do a useful thing for you (I haven't used stack in a while)
00:36:35 <p0a> jackdk: sure. It's strange that it opens a page with *all* the docs, including base though
00:37:25 <p0a> but it definitely shows me where they are
00:40:15 <jackdk> p0a: I actually quite like that because it means links in my lib's haddocks can point into the docs of my lib's deps
00:40:31 <jackdk> but at least it's easier than rummaging around .stack-work
00:44:02 <p0a> jackdk: sure. But when uploading the code somewhere, say to github, is that where the docs are supposed to be?
00:44:57 <jackdk> when you publish a release to hackage, it will build docs.
00:45:10 <MarcelineVQ> I also don't know why it's down in  .stack-work/install/x86_64-linux-tinfo6/  because it's not like  x86_64-linux-tinfo6  is going to change especially often in a project since it refers to your architecture and syslibs
00:47:17 <p0a> jackdk: if my project is private?
00:48:14 <jackdk> unrelated to what you just typed, some people will write non-haddock documentation in a wiki, or a project website, or a collection of files to browse on github. I endorse this sort of thing, as it's often hard to infer how to use a larger lib from documentation of individual types and functions
00:48:46 <jackdk> if your project is private then I dunno. I've been happy running cabal new-haddock in projects I'm working on. I hear some businesses run their own internal hackages but don't know anything about that.
00:49:03 <p0a> thanks jackdk 
01:43:00 <krzyzak> hi
02:23:44 <p0a> Can you code mobile apps in haskell?
02:24:58 <LevyElara[m]> with eta and some other work
02:26:39 <p0a> thank you LevyElara[m] 
02:26:53 <p0a> something to keep in mind in case I ever decide to do something like that
02:27:18 <MarcelineVQ> there's a few paths available
02:28:38 <jsomedon> are <- in do block and list comprehension kind of related with each other?
02:30:28 <[exa]> jsomedon: almost the same in fact
02:31:11 <jsomedon> ha is that so? interesting. so <- in a list comprehension also really means bind?
02:31:31 <[exa]> jsomedon: the ones in list comprehension are the '<-' (i.e. >>=) from the list monad instance. You can even allow some extension that allows list comprehension on any monad
02:31:49 <jsomedon> ha
02:31:56 <jsomedon> interesting
02:32:16 <[exa]> basically, [a | a <- b, f a] is rewritten to `do { a <- b; guard (f a); return a}`
02:32:56 <jsomedon> oh
02:33:17 <[exa]> `guard` is probably the only non-obvious part there, but the functionality is straightforward, it returns [()] if the condition holds and [] if not
02:33:58 <[exa]> the latter can be translated as "no possibilities", thus basically short-circuiting the rest of the computation
02:35:12 <jsomedon> does this guard code work because `a <-b ...` really is `b>=\a-> ...`, I mean `guard` can only appear in the function body?
02:35:26 <jsomedon> b>>=a->...
02:35:46 <[exa]> well guard just returns the 1-element or 0-element list
02:36:13 <[exa]> and the lists count as monads, so they can be interpreted as a part of the computation glued together by >>=
02:36:16 <jsomedon> oh I thought guard only works in function
02:36:32 <[exa]> what do you mean by "in function" ?
02:36:59 <jsomedon> I thought I can only write guards code in the function definition
02:38:11 <[exa]> do-block is a part of the function definition right?
02:38:16 <jsomedon> yes
02:38:33 <[exa]> btw the `guard` is not "pattern guards" or anything similar, the name is a coincidence
02:39:01 <[exa]> totally desugared, the above example is:
02:39:20 <jsomedon> ooh I think I confused the guard above with pattern guard haha
02:39:29 <[exa]> b >>= \a -> guard (f a) >> return a
02:40:01 <jsomedon> so this guard here we are talking about is just a function?
02:40:28 <[exa]> yes... even more desugared, `b >>= \a -> (if f a then [()] else []) >> [a]`
02:40:55 <[exa]> s/desugared/substitued/
02:41:09 <jsomedon> ah now I see
02:42:30 <[exa]> I'm not sure if the default `guard` is only for lists or generic, but the generic version that works for any monad would be something like `guard True = pure (); guard False = empty`
02:44:21 <jsomedon> uhm, what does this mean? >> 
02:44:43 <[exa]> it's like >>= but ignores the data returned from left
02:45:07 <[exa]> PE continued: `b >>= \a -> (if f a then [()] else []) >>= \_ -> [a]`
02:45:08 <jsomedon> so the pure purpuse is to compose left and right
02:45:24 <jsomedon> ah
02:45:42 <[exa]> btw you might like this: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#monad-comprehensions
02:46:58 <jsomedon> ha very cool
02:48:25 <[exa]> it's pretty useful with Maybe, and extremely cool with e.g. monadic parsers (given some caution)
02:49:41 <jsomedon> never realized the idea of list comprehension can actually extends to any monad
03:04:37 <__monty__> Most prefer the reverse though, using do-notation for the list monad instead of comprehensions.
03:12:39 <jsomedon> is `type` a function?  I mean the syntax looks like function, just it
03:12:51 <jsomedon> just it's not working on normal values but on types..
03:13:26 <jsomedon> `type AType = AnotherType`
03:20:12 <maralorn[m]> Do you have examples for MonadComprehensions being actually useful in "normal" code?
03:21:03 <maralorn[m]> I mean it‘s a nice generalisation. But I have never considered using it, because it feels like it could produce very incomprehensible code.
03:26:09 <p0a> So using `git' and `stack' together, what files to add to `.gitignore' ?
03:26:21 <p0a> Probably stack generates some files that I do not need to add to my repository
03:27:05 <p0a> jsomedon: I don't think it's a function because it's a keyword for ghc
03:27:08 <fendor> p0a, I use gitignore.io to generate the appropriate .gitignore file
03:27:08 <dminuoso_> p0a: Well you should probably allow for the .cabal file
03:27:36 <dminuoso_> p0a: Sadly its common practice for stack projects to not include the cabal file, which adds an additional hinderance for non-stack users.
03:27:46 <fendor> https://gitignore.io/api/haskell
03:28:15 <p0a> fendor: thank you 
03:28:31 <p0a> dminuoso_: does that https://gitignore.io/api/haskell ignore the cabal file?
03:28:40 <__monty__> Nope.
03:28:47 <MarcelineVQ> dminuoso_: I noticed that recently, and it's like, c'mon now, how are people supposed to stay impartial about the tools we use if you're going to make the tools opinionated
03:28:50 <p0a> thanks __monty__ 
03:31:13 <fendor> MarcelineVQ, I suppose, a lot of people dont want to be impartial?
03:31:33 <MarcelineVQ> Not being impartial is the enemy!
03:31:35 <MarcelineVQ> :>
03:32:00 <fendor> p0a, you can extend your .gitignore with a lot of other tools if you want to: https://gitignore.io/ this pretty cool, imo
03:32:09 <__monty__> I think it's mostly just cargo culting the "never check in generated files" practice.
03:32:13 <p0a> fendor: I don't understand how this website works
03:32:35 <fendor> p0a, you enter the name of the tool you are using, e.g. haskell, and then press generate and you get a .gitignore file
03:32:46 <MarcelineVQ> I really was taken aback though, that the default project templatr would both add a .gitignore for me and add the cabal fileto it. Partly because I like the word aback.
03:33:02 <Athas> How does not checking in the generated .cabal file hinder non-stack users?
03:33:21 <p0a> Athas: presumably they need the cabal file
03:33:23 <fendor> Athas, there is no .cabal file, and cabal does not generate it from pacakge.yaml
03:33:25 <Athas> 'stack upload' includes it for you, and everyone can run hpack manually.
03:33:40 <p0a> Yeah stack does :P
03:34:05 <fendor> It requires for you to have that tool on the path, which normally you dont have on the path
03:34:11 <MarcelineVQ> If you get your package from hackage
03:34:17 <__monty__> Athas: But that's still a tool devs using cabal don't need. And therefore don't know how to work with. It's unnecessary friction.
03:34:24 * hackage hackport 0.6.2 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6.2 (SergeiTrofimovich)
03:35:33 <__monty__> p0a: You can enter several terms in the text field on the homepage and then generates a combined .gitignore for all of them: https://gitignore.io/api/vim,linux,macos,emacs,haskell
03:35:37 <Athas> __monty__: can you outline a situation where it's a problem?  I can only think of "cabal user clones a project that uses stack, but for some reason does not want to use stack to compile it".
03:35:47 <Athas> If you get the project from Hackage, then the .cabal file will be there.
03:35:53 <__monty__> Athas: And why is that not a valid reason?
03:36:12 <Athas> __monty__: does it occur all that often?
03:36:23 <Athas> Odds are a stack-using project will not compile with cabal anyway, because the dependencies are no longer pinned.
03:36:46 <__monty__> Athas: Depends on whether they also neglect to specify bounds properly.
03:36:58 <Athas> That's a major value-add of stack, so I'll assume so.
03:37:04 <__monty__> And how often you run into it depends on how many projects you contribute to.
03:38:20 <__monty__> Even then I rarely run into something that's impossible or even hard to build with cabal given a couple manually specified bounds.
03:38:36 <fendor> cabal works very often even without any version bounds.
03:38:46 <__monty__> Let's turn it around, how much work does it save the stack users *not* to check in the cabal file?
03:39:36 <Athas> Since hpack embeds its own version number and other metadata into the generated .cabal file, and stack regenerates it frequently, you can end up with spurious changes.
03:40:28 <__monty__> What do you mean? Who cares how often the cabal file is checked in? Just generate it every time.
03:40:50 <__monty__> Which is already done if you test your project using stack.
03:40:50 <Athas> That's noisy.
03:41:12 <__monty__> It's not because you never need to pay attention to changes in the cabal file.
03:41:25 <Athas> So kind of a mental .gitignore when reading the VCS log?
03:41:53 <Athas> I don't know, this is hard to sell to me.  I'd personally rather just impose the slightly increased burden on cabal users to run hpack.
03:42:11 <__monty__> Noise only matters if it makes it harder to review changes imo.
03:42:40 <__monty__> Cabal users don't force stack users to install and learn about tools they don't like.
03:42:52 <Athas> What about 'cabal-install'?
03:43:04 <__monty__> How often does a stack user need that?
03:43:21 <__monty__> That'd be a shortcoming of stack imo.
03:43:36 <Athas> Anyway, there is no forcing here.  Feel free not to use my code!  I am saddened if you feel I'm forcing you or anyone else to do anything; that's really not my intent.
03:43:51 <Athas> Different tastes for different people; it's fine.
03:44:16 <__monty__> The generated cabal file is already *there* in your repo, just check it in.
03:44:20 <MarcelineVQ> "I like stack because I don't have to specify version bounds while I develop. I like hpack because I don't have to type in the modules I create as I develop." These are reasonable positions, with the idea being that things you 'release' both have a cabal file included and --pvp-bounds set on that cabal file. I'm just surprised that the tool itself is being used to push a particular development method. Though I really shouldn't be I 
03:44:20 <MarcelineVQ> guess, tools are meant to be used specific ways.
03:44:27 <Athas> I'm certainly cognisant of the fact that it's clunky to run a preprocessor before the build system (and I likely would not use package.yaml if stack didn't do it automatically), but the .cabal file format is still just intolerably bad for me.
03:45:25 <Athas> __monty__: the generated cabal file is present in the snapshots on Hackage.  If you directly clone out my repository, you count as a developer, not a user, and are expected to put in extra work if necessary.  That's my philosophy.
03:45:59 <__monty__> Or you could make it as easy as possible for people to contribute.
03:46:20 <MarcelineVQ> Athas: .cabal file still bad? I thought that by this point the only advantage hpack has is automatic module inclusion, wich has a minor side issue that hasn't been addressed afaik
03:46:52 <Athas> MarcelineVQ: .cabal is much better (common stanzas are great!), but that module inclusion thing is still a deal-breaker for me.
03:47:48 <Athas> __monty__: it's a possibility.  Empirically, that has not been an issue for any of my contributors (in fact, switching to stack was a huge benefit in that regard).  Maybe it is for others.  That's fine, they should include the .cabal file then.  I don't like telling others what to do.
03:48:20 <MarcelineVQ> 'even now the war of the the Implicits and the Explicits rages on, consuming families and clans, brothers and kingdoms, never will it end so long as people are free to choose'
03:49:41 <Athas> YAML is a total abomination on technical grounds of course, so I really do look forward to the day I can just use .cabal.
03:51:09 * MarcelineVQ stowes a ini-to-cabal program
03:51:45 <tydeu> As an observer of this back and forth I think both of you (Athas and __monty__) demonstrate well why codebases often end up opinionated -- there are two strongly held conflicting opinions (even when it seems to both parties like their wouldn't be) and the result is that the codebase's developers end up choosing one over the other.
03:58:19 <hc> __monty__: if the threshold to contribute is too low, one might get less than optimal results, though?
03:58:30 <fendor> how about we introduce a third format, like dhall that fixes everbody's needs ;D 
03:58:53 <hc> such as when the threshold to posting on the internet was much higher than it is today, there used to be much less what is these days known as "trolling", etc
03:59:09 <Athas> hc: incidentally, that is why I still prefer IRC over modern alternatives.
03:59:16 <__monty__> hc: That's what the review process is for. And someone who starts contributing bad code might eventually contribute good code. Whereas someone who never starts contributing will never contribute good code...
03:59:17 <fendor> hc, but you are just preferring one type of developer, developers that are using stack
03:59:55 <__monty__> fendor: You're forgetting about the unsolved problems that leaves, we obviously need a fourth format, like nix, to solve these remaining problems.
04:00:06 <p0a> hc: there used to be less trolling?
04:00:10 <Athas> Nix with a Dhall preprocessor.
04:00:12 <MarcelineVQ> hc: that's more because the meaning of trolling changed, rather than the difficulty of it
04:00:45 <fendor> __monty__, that is a great idea! One file for system deps, 3 for project specification, maybe one more for deployment... do I smell docker?
04:01:18 <LevyElara[m]> just draw equivalences between formats so we can use any of them
04:01:33 <__monty__> fendor: Oh, don't forget to add shake in the mix. And cmake to get shake built for people without shake.
04:01:55 <fendor> LevyElara[m], that would be boring, each file-format needs some custom set of features, otherwise they clearly have no reason to exist 
04:02:23 <MarcelineVQ> fendor: my feature is that licsencing costs 3$ less than the next guy
04:03:09 <fendor> __monty__, some kind of package.json for integration with npm would be nice, too.
04:03:50 <__monty__> Maybe wrap it all up in a jar? Wouldn't want to forget about eta.
04:03:52 <fendor> MarcelineVQ, my feature are custom ads that mine crypto-currency 
04:04:07 <LevyElara[m]> autotools?
04:04:12 <fendor> __monty__, solves my problems with data-files, so let's do this!
04:04:15 <MarcelineVQ> my lawyers don't accept crypto
04:04:28 <MarcelineVQ> But I do have a lot of them.
04:05:00 <MarcelineVQ> I'm pretty sure that's all you need to win a format war. That and a lobbyist if you're big.
04:27:13 * nshepperd . o O (a quine relay that cycles through all build formats)
04:32:24 * hackage yesod-auth-hashdb 1.7.1.2 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.7.1.2 (paulrouse)
05:19:37 <jsomedon> for `a <$> b <*> c`, is it `(a <$> b) <*> c` or `a <$> (b <*> c)`?
05:21:02 <nil> the former
05:21:15 <jsomedon> does infixl means it's left associative?
05:21:40 <nil> yes
05:21:41 <MarcelineVQ> yep
05:21:58 <jsomedon> thanks guys :-)
05:33:24 * hackage cayley-client 0.4.11 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.4.11 (MichelBoucey)
05:35:59 <__dingbat__> Hello, I happened to run a server program for a longer duration today, and it exited with this error.
05:36:00 <__dingbat__> Unable to commit 1048576 bytes of memory
05:36:02 <__dingbat__>     (GHC version 8.6.5 for x86_64_unknown_linux)
05:36:03 <__dingbat__>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
05:36:39 <__dingbat__> Can someone help me resolve this? The machine running it doesn't have GHC or Stack installed
05:37:12 <fgaz> Hi. Anyone knows how environment variables work with ghcjs in the browser?
05:38:21 <p0a> __dingbat__: try #ghc as well maybe
05:38:23 <fgaz> __dingbat__: which program? If it's not written by you you could report it to the authors
05:40:55 <__dingbat__> fgaz: I am the author of the program though...
05:41:16 <__dingbat__> p0a: whats #ghc plz?
05:41:30 <fgaz> Oh sorry the wording confused me
05:41:39 <fgaz> #ghc it is then
05:41:40 <__dingbat__> fgaz: why is this error happening please?
05:42:28 <__dingbat__> fgaz: what is #ghc, how do i use it?
05:42:50 <fgaz> __dingbat__: That message only appears when something "impossible" happens in the Haskell runtime. So it may be a ghc bug
05:43:10 <__dingbat__> fgaz: thats what i thought :)
05:43:22 <__dingbat__> no solution in sight then?
05:43:23 <fgaz> #ghc is the channel for ghc in freenode (the irc server you are in right now)
05:43:39 <MarcelineVQ> #haskell being the current channel
05:43:48 <fgaz> Type /join #ghc and ask there
05:43:55 <__dingbat__> but why exactly around that memory mark? whats the significance of "1048576 bytes of memory"
05:44:12 <__dingbat__> ok thank you
05:44:29 <dminuoso_> __dingbat__: It's just contextual information that may be relevant to the GHC team.
05:44:58 <MarcelineVQ> do note that the error is suggesting you ran out of memory
05:45:14 <MarcelineVQ> So I would examine that first of all.
05:45:38 <dminuoso_> MarcelineVQ: Id argue it's a GHC bug at the least. It tells you to file a GHC bug report.
05:45:40 <__dingbat__> I have 22GB memory left :)
05:45:59 <MarcelineVQ> You do now, did you just before the program exited?
05:46:16 <__dingbat__> I did not catch it before the program exited
05:46:34 <fgaz> Well, then I'd argue the error should mention OOM as a probable cause
05:46:42 <__dingbat__> but I faintly recall the memory didn't generally get beyond a few meager GBs
05:48:04 <p0a> If it got up to a few GBs it may as well use all of 22GB
05:48:10 <f-a> which is the correct way to replicate this experiment for haskell? https://drewdevault.com/2020/01/04/Slow.html ?
05:48:20 <f-a> -S leads to a suspect 240~ line .s file
05:48:54 <fgaz> As for my question I looked at the source code and the answer is: it doesn't do anything
05:49:22 <p0a> f-a: that blog post is sort of missing the point by the way 
05:52:17 <fgaz> p0a: that's Drew for you ;-)
06:08:54 * hackage fused-effects-lens 1.2.0.0 - Monadic lens combinators for fused-effects.  https://hackage.haskell.org/package/fused-effects-lens-1.2.0.0 (patrick_thomson)
06:17:16 <statusfailed> Can I tell cabal.project to use a package in a local directory somehow?
06:17:31 <statusfailed> i.e., my package is in ~/foo/a, and I want it to depend on ~/foo/b
06:17:41 <merijn> statusfailed: Yes
06:18:02 <merijn> statusfailed: Just put that package as extra entry in packages (or in optional-packages)
06:18:45 <statusfailed> merijn: oh, nice! thanks!
06:19:04 <merijn> statusfailed: That's one of the main use cases of having cabal.project files ;)
06:19:20 <merijn> statusfailed: You can depend on specific commits in git repos too
06:19:55 <statusfailed> merijn: I actually had it depending on a git repo, so I was trying to do it the same way for a local project
06:20:16 <statusfailed> I didn't think to try just feeding local paths to the packages: bit heh
06:20:25 <merijn> statusfailed: optional-packages are used if they exist (and ignored if missing), packages *must* be there
06:20:47 <merijn> You may also wanna put that in cabal.project.local if it's just for your current hacking
06:21:01 <statusfailed> dang, that's exactly what I need
06:21:55 <statusfailed> oh, seems like I have to add --project-file though, maybe my cabal is old?
06:22:01 <merijn> It uses the union of cabal.project and cabal.project.local (the idea being that cabal.project gets checked into version control and .local is for stuff you only need on your current dev machine"
06:24:08 <statusfailed> merijn: I'm trying to develop a library and application in parallel, so I wanted the .local one to just reference the local files, but the prod one to reference a specific git commit
06:24:24 <statusfailed> I get this though: TODO: add support for multiple packages in a directory
06:24:41 <merijn> statusfailed: oh, do you have the cabal files in the same directory?
06:24:59 <merijn> (i.e. not the cabal.project, but the cabal files of the application and library)
06:25:13 <merijn> (also, you are aware you can have those in the same cabal file, yes?)
06:26:04 <statusfailed> merijn: no, the library is in a sibling directory
06:26:29 <statusfailed> Yeah I didn't want to have them in the same cabal file 
06:26:51 <merijn> weird...
06:26:58 <merijn> which version of cabal-install?
06:27:06 <statusfailed> oh wait, version 3
06:27:09 <statusfailed> it should be 4 right?
06:27:18 <merijn> No, 3.0 is the latest
06:27:23 <statusfailed> oh
06:27:56 <merijn> can you pastebin the project file?
06:34:51 <aveltras> how would one provide assets other than haskell files when used as a dependency ? For example, if i'd like to build a web dashboard and use it in several projects, the dashboard would require some javascript files, is there some alternative to embedding the javascripts as haskell strings ? 
06:35:42 <merijn> aveltras: You can define data files: https://cabal.readthedocs.io/en/latest/developing-packages.html#accessing-data-files-from-package-code
06:36:50 <statusfailed> merijn: https://pastebin.com/0z4puA0L
06:37:25 <fgaz> aveltras: there's also file-embed if you want a single executable
06:37:54 <merijn> statusfailed: I wonder if the . and ./*.cabal are interpreted doubly. What if you remove one of those?
06:38:09 <aveltras> merijn: fgaz thanks for your answers
06:38:13 <aveltras> fgaz: 
06:41:59 <statusfailed> merijn: yep, that looks like it
06:42:19 <statusfailed> yup
06:42:20 <statusfailed> thanks!!
06:47:37 <maralorn[m]> I have under nixos a ghc.withPackages in my environment. But my ghcide does not find packages that I have included via the ghc.withPackages option. Does anyone have a tipp what I should write in my hie.yaml to fix it?
06:48:17 <maralorn[m]> The point is: runhaskell works. ghcide doesn‘t.
06:48:49 <maralorn[m]> And I am sure it is trivial, but I don‘t know the option.
07:02:25 <dansho> is Data.Set a multiset?
07:02:50 <Rembane> Nope
07:02:54 <Rembane> It's a regular set 
07:02:59 <Rembane> For small values of regular 
07:07:14 <dansho_> maralorn[m], i haave only gotten ghcide to find packages using a cabal2nix generated expression
07:08:03 <maralorn[m]> dansho_: It works fine for me with a simple cabal setup.
07:08:20 <maralorn[m]> Actually even with a complicated cabal setup but without cabal2nix.
07:22:22 <Zemyla> So for a class that defines an unboxed Seq of a certain type a, we'd have type family Seq (a :: *) :: *, and then the necessary operations would be replicateA, (<|), (|>), viewl, viewr, (<>), splitAt, length, null, and the folds, right?
07:27:21 <Zemyla> And derived functions (which could be written from the primary functions, but could also be written more efficiently in other ways) would be things like filter, map0 :: Unbox a => (a -> a) -> Seq a -> Seq a, stimes, take/dropWhile, lookup, adjust, and so on.
07:31:20 <solonarv> sounds about right
07:31:31 <Zemyla> Functions like map and traverse would have to be defined outside the typeclasses, because they would depend on two instances of Unbox.
07:32:00 <Zemyla> I'm planning to write this because I noticed a couple of things.
07:32:06 <solonarv> note that some of these methods are already covered by MonoFoldable/MonoTraversable, so maybe those could be used as superclasses
07:32:37 <Zemyla> > let i = ord maxBound in finiteBitSize i - countLeadingZeros i
07:32:39 <lambdabot>  21
07:33:37 <Zemyla> You can fit 2 or 3 Chars in a Word64 + a bit showing whether there's 2 or 3. That's a Node Char.
07:34:05 <Zemyla> You can fit 8-27 Bools in a Word32 + 5 bits showing how many are in there. That's a Node (Node (Node Bool)).
07:36:11 <Zemyla> A Seq Bool could also count how many values in it are True, and split on that or on how many are False. That's key to creating a derived (Unbox a, Unbox b) => Unbox (Either a b) instance for Seqs.
07:38:10 <Zemyla> That also means that you can define a GUnbox typeclass to automatically derive Unbox instances for types which are Generics.
07:39:37 <Zemyla> (Oh, I plan to have replicateA's type be (Applicative f, Unbox a) => Int -> f a -> (Seq a -> b) -> f b, so that Unbox can be GNDed.
07:40:13 * solonarv squints
07:40:23 <solonarv> I see... Coyoneda?
07:40:33 <Zemyla> No, Yoneda.
07:40:41 <solonarv> dangit, I always get them mixed up
07:40:48 <Zemyla> Noyoneda.
07:41:55 <Zemyla> But don't worry about it. Have yourself a froyoneda.
07:43:24 <MarcelineVQ> that's pretty proyoneda
07:44:11 <MarcelineVQ> but if you keep it up you'll have to goyoneda
07:47:19 <geekosaur> (yoneda scorecard to keep track of this sometimes…)
07:56:24 * hackage shine 0.2.0.4 - Declarative graphics for the browser using GHCJS  https://hackage.haskell.org/package/shine-0.2.0.4 (fgaz)
07:57:24 * hackage shine-examples 0.1 - Examples for the shine package  https://hackage.haskell.org/package/shine-examples-0.1 (fgaz)
08:19:15 <sm[m]> morning all
08:19:24 <sm[m]> is https://hackage.haskell.org/package/extra-1.6.18/docs/Data-List-Extra.html#v:nubSort any more efficient than regular sort ?
08:19:33 <sm[m]> than regular nub . sort, I mean ?
08:19:54 <sm[m]> nubSort is O(n log n)
08:20:35 <solonarv> nub is always n^2 no matter what the input looks like
08:20:42 <solonarv> so nub . sort must also be n^2
08:21:32 <merijn> solonarv: That's...not true
08:22:04 <maerwald> sm[m]: this one has Ord constraint, the one from prelude Eq
08:22:08 <merijn> There's a reason why we have best, average, and worst case complexity
08:23:54 <maerwald> oh, I misread :>
08:23:56 <sm[m]> maerwald: hm, I'm looking at https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:sort (Ord)
08:25:01 <sm[m]> so it sounds like nubSort can be more efficient than nub . sort, indeed
08:25:32 <sm[m]> thanks
08:25:48 <maerwald> I think they are the same
08:26:45 <maerwald> https://hackage.haskell.org/package/extra-1.6.18/docs/src/Data.List.Extra.html#nubSortBy
08:26:55 <maerwald> that's basically nub . sort
08:27:25 <sm[m]> ah.. I couldn't quite tell. Thanks!
08:34:07 <solonarv> huh
08:34:41 <solonarv> Data.List.nub tries to eliminate all duplicates
08:35:00 <solonarv> the local 'f' in nubSortBy only eliminates adjacent duplicates
08:36:46 <solonarv> I guess nub might turn out to be better than n^2 on already-sorted input, but if so it's not obvious to me how
08:37:09 <cpchung> hello !
08:37:32 <cpchung> I am reading the book concurreny in Haskell , ran into this one:
08:37:33 <cpchung> GenSamples.hs:2:1: error:    Could not find module ‘Data.Random.Normal’
08:37:58 <cpchung> in general, how do I find the installation command for particular package?
08:38:22 <fen> cpchung: its just the name of the package from the contents page on hackage
08:38:38 <solonarv> note that Data.Random.Normal is *not* the name of the package
08:38:44 <solonarv> it is the name of a module
08:38:57 <solonarv> one package can (and usually does) contain many modules
08:39:04 <cpchung> thats the question, where can I find the correct module name?
08:39:17 <solonarv> Data.Random.Normal *is* the module name
08:39:21 <fen> cpchung: eg on this page its at the top left corner of the page  http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html
08:39:28 <solonarv> you need to find a/the package containing such a module
08:40:19 <fen> if you then navigate to the "contents" link, and scroll down, its just below "Downloads"
08:40:38 <solonarv> that doesn't help if one hasn't found the package yet
08:40:49 <solonarv> there is a search tool called 'hoogle'
08:40:53 <solonarv> it is hosted online:
08:40:56 <solonarv> @where hoogle
08:40:56 <lambdabot> http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
08:42:18 <cpchung> @fen solonarv thanks! problem resolved!
08:42:18 <lambdabot> Maybe you meant: wn run let free faq
08:42:49 <fen> so there is a question about graph isomorphisms to do with permuting the order of construction, ie instead of unfolding the graph, unfolding a list of the partially applied graph constructors - but then, if this list is permuted, not all permutations preserve the edges
08:42:58 <fen> how do i determine which do?
08:43:37 <fen> i guess i need to do this as a type level commutation, but this is besides the point
08:43:45 <fen> computation*
08:43:58 <cpchung> what irc client do you use for ubuntu?
08:44:35 <solonarv> I use irssi, seems to work
08:44:54 <solonarv> when I get around to it I need to set it up to run on a server via ssh+tmux again
08:46:00 <cpchung> Fen, what is the original question?
08:46:28 <fen> well, just to be able to do graph isomorphisms
08:47:40 <cpchung> do you have to do it in haskell?
08:47:43 <fen> so the strategy is to make use of the get+set implementation of traversable that gives an ordering to the traversal that can be expanded into a DList of partially applied set functions
08:48:54 <fen> cpchung: the machinery for specifying the traversable instance in terms of type level comutations to derive this can only be done in a language like haskell that supports such class machinery and type level functions
08:49:03 <cpchung1> switched to client
08:49:47 <cpchung1> sorry, dont know enough about that
08:49:50 <fen> so, yes, this is possible only in languages with a type system at least as expressive as haskell,
08:51:00 <cpchung1> in haskell, do we have things like anaconda which can install a set of commonly used packages for us in batch?
08:51:42 <solonarv> in haskell, we try not to "install" packages in any global sense, because it breaks things
08:52:01 <fen> cpchung1: normally because it fetches all the required packages this is done via a projects .cabal file
08:52:40 <fen> ie you just specify the dependencies you need and these are installed automatically
08:52:51 <solonarv> instead (for projects) you just say "my project depends on packages X, Y, Z" and whichever build tool you are using will take care of fetching them, building them, and making them available to your project
08:53:06 <solonarv> without interfering with any other projects that may exist on your system
08:53:30 <cpchung1> hm, most of the source code from the books do not come with a .cabal ~~~~
08:54:01 <fen> but if you just want to be able to import them with :m in ghci for example, you would just write cabal install for the packages you need at the terminal
08:54:23 <solonarv> that way lies breakage
08:54:43 <solonarv> before you type 'cabal install', please check that your cabal is version >= 3.0
08:54:51 <fen> saves having to set up a project if a user is yet to learn how to do that
08:55:36 <fen> yeah you maybe should use cabal v2-install, but cabal install seems to work fine
08:55:41 <solonarv> before cabal 3.0, 'cabal install' means 'cabal v1-install' which is the global installation that eventually leads to breakage
08:56:05 <solonarv> cabal v2-install will never leave you in a twisted maze of incompatible package versions
08:56:19 <fen> ah ok
08:56:35 <solonarv> v1-install works fine until suddenly your installed package set is a horrible mess and the only way to fix it is to nuke the whole thing
08:56:53 <cpchung1> I am using cabal 3
08:57:04 <solonarv> good, good
08:57:29 <fen> you could look into how to set up a cabal project which is basically the tool you were after, ie, to write a .cabal file for your project
08:57:38 <cpchung1> going through Marlow's book about concurrency, because I am trying to implement CompletableFuture as in Java or Promise as in JS , in Haskell
08:57:38 <solonarv> here is how 'cabal v2-install foo' works: if 'foo' has any executable, they are built and copied or symlinked to ~/.cabal.bin
08:57:51 <solonarv> if 'foo' has no executables, you get an error message
08:58:00 <cpchung1> so to implement a lazy evaluation algo for parallel dependent tasks
08:58:11 <fen> also that gives a better way to put your code into different directories than faffing around with .ghci files with set -i../.. to specify the top directory
08:58:23 <cpchung1> basically the chapter 13 of the .Net Concurrency book
08:58:58 <solonarv> to "install" libraries, you need to say 'cabal v2-install --lib foo'; this builds the 'foo' library, and adds it to a .ghc.environment file that is loaded by default when you start a "abre" ghc/ghci
08:59:26 <solonarv> for anything more than quick one-shots I recommend setting up a project
08:59:39 <cpchung1> the way Haskell decoupling the what to do and how to run it is very interesting!
08:59:49 <solonarv> it's very easy: mkdir myproject; cd myproject; cabal init
08:59:56 <fen> cpchung1: how does Marlows book say to do that? is it continuations or credit card transforms or something?
09:00:51 <cpchung1> I dont know whether Marlow's book can do it. I am still learning Haskell, trying to understand the basic built-in concurrency construct in haskell first
09:01:26 <fen> ah ok, idk what is a Promise in JS, but i guess its basically a continuation, right?
09:01:47 <cpchung1> I dont know what is continuation~~~
09:01:56 <fen> http://www.haskellforall.com/2012/12/the-continuation-monad.html
09:02:10 <cpchung1> but promise in JS is very similar to CompletableFuture in Java
09:02:23 <fen> cpchung: sorry, that was more a question for some of the other haskellers online that might also know JS
09:03:02 <cpchung1> it sounds very close to what I need! ""Complete me Later""
09:03:31 <fen> maybe if you post it in JS or Java we could translate it for a demonstration of how its done
09:04:09 <fen> cpchung1: yeah the credit card transform with eg callCC is so called "buy now pay later"
09:04:15 <cpchung1> in fact,  I still dont find a satisfactory explanation about Monad, but going to take a course at MIT next week about Programming in Haskell
09:06:12 <cpchung1> I have a working implemenation in Java for what I want to achieve in Haskell. What will be a good way to post it? I cannot post it in my public github
09:06:30 <fen> I think the reference is; Introduction to Programming with Shift and Reset Kenichi & Asai Oleg Kiselyov
09:06:36 <fen> http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf
09:07:11 <solonarv> "I cannot post it in my public github" - why not?
09:07:13 <madnight> Hom_C(a,x) can be written as (a -> x) in Haskell. How would Hom_C(a,-) or Hom_C(-,a) look like?
09:07:13 <fen> cpchung1: you can use; https://pastebin.com/
09:07:41 <solonarv> madnight: for Hom_C(a, -) you can partially apply (->), like so: ((->) a)
09:08:31 <solonarv> for Hom_C(-, a) you need a wrapper of some sort, for example: newtype Op b a = Op { runOp :: a -> b }
09:08:49 <monochrom> But I don't want to read the java version or js version.  Just keep reading on Marlow's book.
09:09:30 <solonarv> then Op b a ≃ a -> b ≃ Hom_C(a, b), and partially applied: Op b ≃ Hom(-, b)
09:10:11 <madnight> solonvarv, okay in theory it would be (`->` a) if Haskell would allow this syntax, right
09:10:38 <solonarv> it would just be (-> a), actually
09:10:48 <madnight> ah right
09:11:01 <solonarv> apart from that you are correct
09:11:21 <solonarv> the reason this isn't allowed is basically that it would make type inference completely horrid
09:11:48 <solonarv> type inference relies on being able to split (f a ~ g b)  into (f ~ g, a ~ b)
09:12:48 <solonarv> but if you allow this sort of thing, suddenly (Int -> Char) could be split into ((Int ->) Char) or into ((-> Char) Int) - no longer unique!
09:13:25 <madnight> can I do this: (flip (->) a)?
09:13:31 <solonarv> you cannot
09:13:56 <fen> any ideas on how to determine which permutations of a graph expanded as a dlist of its linear construction lead to edge preserving isomorphisms?
09:14:16 <solonarv> well, you can write this: type family Flip f a b where Flip f a b = f b a
09:14:33 <solonarv> and then you can write (Flip (->) a b), which reduces to (b -> a)
09:14:41 <solonarv> but type families must be fully applied
09:14:48 <solonarv> so (Flip (->) a) isn't legal
09:14:55 <fen> solonarv: why not use a newtype? then you can invert it by removing the wrapper
09:15:06 <solonarv> I already suggested a newtype
09:15:07 <fen> and partially apply it
09:15:14 <solonarv> I'm currently explaining why a newtype is necessary
09:15:17 <fen> ah ok
09:15:39 <fen> is there any scope for type families to be able to be partially applied ever?
09:15:43 <monochrom> People need to read their scrollbacks more.
09:16:45 <solonarv> there is, yes
09:16:49 <solonarv> but it's far from done
09:16:51 <fen> ha! im currently trying to read the tunes repo to find my posts from a year ago with the get/set/traversable stuff... 
09:16:57 <solonarv> I haven't kept up with it recently
09:17:23 <madnight> https://github.com/ghc-proposals/ghc-proposals/pull/52
09:17:24 <fen> well as long as it seems possible so there isnt a certain reason its impossible, then we can hope
09:18:20 <fen> i seem to remember it having something to do with functions as first class values and how -> works in types
09:18:36 <fen> :k * -> *
09:18:38 <lambdabot> *
09:18:41 <madnight> mniip, proposed such a feature
09:18:46 <cpchung1> https://bitbucket.org/cpchung/scalaast/src/master/src/main/java/completableFuture/
09:19:01 <cpchung1> @fen here it is the code doing what I want to achieve in haskell
09:19:01 <lambdabot> Maybe you meant: wn run let free faq
09:19:27 <mniip> well really it's a natural progression towards implementing eisenberg's thesis
09:19:29 <cpchung1> you only need to download these 3 files and paste it into your local with jdk11, no 3rd dependencies needed
09:20:54 <fen> cpchung1: its completely illegible, it seems to be written in some archaic language
09:21:17 <cpchung1> ?
09:21:44 <fen> the syntax is causing me anxiety, i will have to leave 
09:22:05 <cpchung1> lol
09:23:27 <AS_Jon> check out http://www.desertofthereal.org
09:23:51 --- mode: ChanServ set +o monochrom
09:23:56 --- mode: monochrom set +b *!*@cpe-24-211-225-57.nc.res.rr.com
09:23:56 --- kick: AS_Jon was kicked by monochrom (AS_Jon)
09:23:59 <maerwald> why did I click that
09:24:50 <monochrom> You like desert, but I like dessert.
09:24:56 <maerwald> one of the limitations of IRC: cannot remove anything
09:25:31 <monochrom> On the up side, you can use ConduitT for it. :)
09:25:50 <cpchung1> @monochrom @solonarv 
09:25:50 <lambdabot> Unknown command, try @list
09:25:50 <cpchung1> This is the code I want to achieve in haskell, the crux is whether Haskell supports this kind of concurrency construct using haskell way
09:25:50 <cpchung1>  https://bitbucket.org/cpchung/scalaast/src/master/src/main/java/completableFuture/
09:26:24 <monochrom> <monochrom> But I don't want to read the java version or js version.  Just keep reading on Marlow's book.
09:27:20 <cpchung1> lol, java is not that bad, just that it allows people doing bad things easily~~
09:28:17 <maerwald> how's that different from any programming language :)
09:29:07 <cpchung1> yes, I will keep on reading Marlow's book and get familiar with the built-in construct first. In java 8, all these can be achieved in built-in construct
09:29:14 <maerwald> also, syntax is something you can get used to, even if it takes years (takes quite a few years in clojure)
09:49:21 <monochrom> No, the point is not about "bad", the point is there will be differences.
09:59:35 <madnight> solonvarv, okay and im case of a Profunctor? How does my newtype look like?
10:00:22 <madnight> solonarv,
10:08:01 <dsal> I missed the stack vs. cabal war last night. Who won?  Are we all using nix now?
10:08:33 <dbqp> hello
10:08:45 <dbqp> hear to learn haksell
10:09:08 <tdammers> @where haskellbook
10:09:08 <lambdabot> http://haskellbook.com
10:09:22 <dbqp> thank you
10:09:40 <tdammers> dbqp: ^ standard advice, but if you give us a bit more background info on your previous life, people might make more specific suggestions
10:09:47 <dbqp> ive already just started on "yet another haskell tutorial" and "learn you a haskell for great good"
10:10:01 <f-a> dbqp: CIS194 is another great, gratis resource
10:10:06 <tdammers> ah, alright. don't use "learn you a haskell"
10:10:30 <dbqp> aw really? I liked the pretty pictures
10:10:31 <tdammers> it's a fun read, but for my taste it takes too much liberty with correctness for dubious "didactical" reasons
10:10:39 <dbqp> haha OK
10:10:46 <tdammers> the pictures are great. it's just that many of them are unfortunately wrong.
10:10:58 <tdammers> monads aren't boxes, and the box metaphor is going to hurt more than it helps
10:11:09 <dbqp> ah OK
10:11:11 <dbqp> yeah no
10:11:14 <solonarv> madnight: oops, missed your ping
10:11:15 <dbqp> I don't like metaphors
10:11:20 <dbqp> give it to me how it is
10:11:30 <dbqp> well i barely looked at learn you a haskell 5 seconds ago
10:11:41 <dbqp> but i have been going through "yet another haskell"
10:11:44 <dbqp> and it looks quite solid
10:11:55 <solonarv> madnight: you don't need a newtype wrapper for Hom_C(-, =) because that's just (->)
10:13:08 <tdammers> frankly, I haven't read that one, so can't comment
10:13:15 <madnight> :t (->)
10:13:16 <lambdabot> error: parse error on input ‘->’
10:13:39 <dbqp> "^ standard advice, but if you give us a bit more background info on your previous life, [...]" I have an undergrad in CS. I know python, C++, java, ASM, and a bit of web. Curious about functional programming. Bought a hardcopy of SICP but struggled to find the time to do it properly so gave up for now.
10:13:40 <madnight> :k (->)
10:13:42 <lambdabot> * -> * -> *
10:14:23 <tdammers> dbqp: you might enjoy "Real World Haskell" then. the original edition is horribly outdated, but I hear people are working on updating it to "modern" haskell
10:15:02 <tdammers> dbqp: "Write Yourself A Scheme" is another interesting candidate - it teaches you Haskell by implementing a Scheme interpreter. Tough, but huge fun, and very practical and hands-on.
10:15:04 <tdammers> @where scheme
10:15:04 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
10:15:05 <dbqp> OK thanks tdammers
10:15:25 <dbqp> ya i saw that one on writing scheme interpreter
10:15:29 <dbqp> looked challenging
10:15:37 <dbqp> i thought i'd start with easy stuff like basic syntax
10:15:44 <tdammers> also, I'd highly recommend Stephen Diehls "What I Wish I Knew..." as a companion. It's not a sufficient learning resource on its own, but it's going to be enormously helpful in combination with a structured book.
10:15:47 <tdammers> @where what
10:15:47 <lambdabot> I know nothing about what.
10:15:49 <tdammers> aww
10:15:58 <tdammers> @where hask
10:15:58 <lambdabot> I know nothing about hask.
10:15:59 <maerwald> tdammers: haskellbook, the one where one author sued the other? :>
10:16:02 <madnight> i think Real World Haskell is still good for starters (from personal experience)
10:16:03 <tdammers> maerwald: yeah.
10:16:19 <tdammers> maerwald: the personal situation was terrible, but that doesn't make it a bad book
10:16:23 <siraben> dbqp:  I'd recommend "Programming in Haskell" by Graham Hutton
10:16:26 <siraben> It's good for beginners
10:16:32 <maerwald> tdammers: if only it was actually free
10:16:36 <tdammers> http://dev.stephendiehl.com/hask/ <- the Stephen Diehl one
10:16:42 <tdammers> maerwald: yeah, that's the big downside
10:16:46 <madnight> especially the online version, with the very valuable comments
10:16:49 <dbqp> I'll make a dartboard and throw a dart at one of your suggestions :) Thanks yall
10:17:19 <tdammers> dbqp: apart from the (paid) haskell book, I think they're all free to read online, so why not just sample the first chapter or two and see which one you like best?
10:17:49 <__monty__> Hutton's isn't available for free either, I think?
10:18:53 <madnight> :k (a -> b)
10:18:55 <lambdabot> error: Not in scope: type variable ‘a’
10:18:55 <lambdabot> error: Not in scope: type variable ‘b’
10:22:55 <maerwald> tdammers: well, my point is, given the history, I don't want to support it, but I would be happy to receive a free copy :P
10:23:23 <tdammers> maerwald: yeah, I can understand that.
10:34:07 <cpchung> in haskell there are so many 3rd party packages I need to download, how can I tell whether they are reliable before it breaks? I mean, there is no set of built-in or managed/maintained by big names?
10:36:59 <dsal> cpchung: that question isn't very actionable.
10:37:29 <cpchung> for example, in java, there is java.util
10:37:41 <cpchung> in c++, there is stdlib
10:37:48 <dsal> You're not required to use all available packages in your program, but you might benefit from using one that solves a problem you have.
10:37:54 <dsal> In Haskell there's base
10:38:16 <cpchung> but while reading Marlow's book, many codes are dependent on things out of base
10:38:48 <cpchung> e.g. import qualified Data.Vector as Vectorimport Data.Vector (Vector)import qualified Data.Vector.Mutable as MVector
10:38:58 <dsal> In Java, you get new packages when you need to solve specific problems people have written solutions for.  Some of those are pretty bad, but some are good.
10:39:38 <cpchung> yes, thats why I dont really add dependencies if java.util from jdk11 or 14 can solve it for me
10:40:19 <dsal> Of course. Why would you add dependences unnecessarily?
10:41:24 <ChaiTRex> cpchung: I'm not sure how to get a list of the modules that come with Haskell.
10:41:39 <maerwald> cpchung: there are only a handful of big libraries. Generally you have no idea when things break
10:41:46 <dsal> There are some good, commonly used packages.  Making gigantic standard libs is not great for many reasons.
10:41:47 <ChaiTRex> cpchung: If you don't have to download the package they're in, it's sort of like java.util.
10:42:07 <koz_> ChaiTRex: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history
10:42:13 <cpchung> thanks, i think my question is kind of answered
10:42:25 <ChaiTRex> cpchung: For example, Data.List or Data.IntMap are included.
10:42:34 <koz_> Yep, because they're part of containers.
10:43:08 <maerwald> cpchung: I pick my libraries based on maintainers, less on code
10:43:19 <ChaiTRex> cpchung: Check koz_'s link for things that come with GHC.
10:43:57 <koz_> There is quite a lot of extremely non-trivial functionality that comes with some of them.
10:44:02 <ChaiTRex> cpchung: Each of those packages can be found on Hackage so that you can see what modules they include.
10:44:16 <koz_> Win32 is perhaps the most extreme example, but containers and mtl are also quite chonky.
10:44:22 <koz_> (not saying that this is a bad thing, mind you)
10:44:25 <dsal> containers is super common.  Java ships with a similar thing.  That's very limiting.
10:44:28 <maerwald> and 'base' is no guarantee for quality
10:44:55 <dsal> You don't need set when you have nub!
10:47:03 <siraben> :k RWS
10:47:04 <lambdabot> * -> * -> * -> * -> *
10:56:54 * hackage hpath-filepath 0.10.0 - ByteString based filepath manipulation  https://hackage.haskell.org/package/hpath-filepath-0.10.0 (maerwald)
10:57:55 * hackage hpath-io 0.10.0, hpath 0.10.0 (maerwald): https://qbin.io/home-drums-uqdx
11:05:43 <muzzle> hi, so now that intero is unfortunately deprecated I'm looking into a new development setup for emacs. I got haskell-ide engine running but I'm still missing one key component: a REPL 
11:05:59 <muzzle> is there a way to set this up directly via haskell-ide-engine
11:06:14 <muzzle> or do I need to use something else (like Dante) for a repl?
11:06:20 <Rembane> muzzle: Does intero work for you? 
11:07:39 <muzzle> yeah
11:08:07 <muzzle> but seeing how it's unmaintained I guess it won't take long for it to fall apart?
11:08:20 <Rembane> muzzle: or you could see it as done and feature complete. 
11:09:04 <maerwald> unlikely for anything that is tightly coupled to ghc/ghci
11:09:34 <muzzle> I guess I want something that I can still upgrade when new GHC versions come out
11:09:55 <mpickering> muzzle: I think you could use `vscode-ghc-simple`
11:10:38 <mpickering> how did the intero repl work btw?
11:10:48 <mpickering> did you lose all your bindings when you saved?
11:11:59 <muzzle> mpickering: i added (add-hook 'haskell-mode-hook 'intero-mode) to my init.el and just pressed C-c C-l
11:12:18 <mpickering> yeah but how did you use the repl?
11:12:26 <mpickering> if you define `x = 5` and then save the buffer
11:12:31 <mpickering> did you lose `x`?
11:12:52 <muzzle> mpickering: by the buffer I assume you mean the buffer with the file containing the code
11:13:07 <muzzle> And upon saving that I didn't lose any bindings in the repl
11:13:29 <mpickering> so how did that work?
11:13:30 <muzzle> but upon reloading (C-c C-l) i lost all my bindings
11:13:50 <mpickering> so it didn't reload when you changed the buffer, and you had to manually upload it
11:13:53 <mpickering> *reload
11:13:56 <muzzle> yeah
11:14:05 <muzzle> and that's just the behaviour I would like to have again
11:14:39 <muzzle> For my workflow it's one of the most important features (that and go-to-definition)
11:14:52 <mpickering> you could just start the repl yourself then?
11:15:03 <muzzle> in a separate terminal?
11:15:29 <mpickering> I'm sure emacs can do something to display it in a pane
11:15:47 <mpickering> vscode doesn't support it I don't think and I'm not sure it's in scope for these language servers
11:15:55 <oats> I wrote an ugly thing, is there a nicer way to do this?
11:15:57 <oats> [nick, user, gecos] <- mapM use $ (botConfig .) <$> [confNick, confUser, confGecos]
11:16:03 <oats> (context: lenses and State)
11:16:53 <muzzle> would trying to set up dante in parallel with haskell-ide-engine be useless?
11:17:05 <mpickering> it would use a lot of RAM
11:17:22 <mpickering> I don't see what the issue with just running a command yourself is
11:17:50 <mpickering> it seems like you just want to start a repl with "cabal repl" and periodically send ":r" to it on a key press
11:18:44 <geekosaur> ghcid'
11:18:46 <geekosaur> ?
11:19:20 <monochrom> IDEs and smartphones.  You don't even realize what you need them for until you lose them.
11:19:25 <muzzle> mpickering it's really very inconvenient to dig out the path of each module manually in a larger project where I switch between modules frequently
11:19:41 <monochrom> Or maybe s/need/use/ # #FirstWorldProblems
11:21:05 <maerwald> you mean IDEs are like making and instagram post before you eat?
11:21:37 <monochrom> Yeah! Like hovering an identifier to see its type before you eat. :)
11:23:50 --- mode: monochrom set -o monochrom
11:25:54 <solonarv> Rembane: intero is definitely going to break eventually, when stack changes incompatibly... or when you want to use something other than stack!
11:26:45 <Rembane> solonarv: That's true, but until then it will work fine. I am a laggard though and I want more to be laggards.
11:27:14 <solonarv> oats: writing three separate lines and repeating yourself a little is totally fine
11:28:28 <oats> solonarv: nonsense!
11:28:48 <oats> we must push the boundaries of terseness and readability further!
11:28:56 <solonarv> you could also do something fancy like: (nick, user, gecos) <- zoom botConfig $ liftA3 (,,) (use confNick) (use confUser) (use confGecos)
11:29:05 <oats> ok that's too fancy
11:29:19 <solonarv> there might be a way to compactify that liftA3 thing too but I can't be bothered to look it up right now
11:29:29 <monochrom> Not as fancy as using both $ and <$>
11:29:39 <svipal> Where does the name "tagless final" come from ?
11:30:07 <monochrom> I think "tagless"'s "tag" refers to data constructors of algebraic data types.
11:31:35 <solonarv> oats: btw, 'zoom' is a big part of what makes StateT + lens so nice
11:31:44 <oats> I haven't seen zoom yet
11:32:03 <svipal> hmm
11:32:28 <monochrom> I am not sure I get "final" right, but my impression has something to do with "initial algebra" (that's usually algebraic data types) and "final coalgebra".
11:32:28 <madnight> types of types := kinds; kinds of kinds := ?
11:32:36 <muzzle> Is there a currently maintained way to get a repl that's integrated into emacs like the intero repl?
11:32:46 <muzzle> Or would I have to hack something together myself?
11:33:06 <geekosaur> madnight, it's all collapsed together these days
11:33:07 <svipal> is there a language that implements twin operators for functions with three arguments ? Like say  x <:> y <::> z would translate into f x y z
11:33:21 <Rembane> svipal: Look into APL or J. 
11:33:22 <solonarv> svipal: agda has something like that, I think
11:33:30 <heatsink> monochrom: "tags" refer to the integer labels in the run-time implementation of ADTs
11:33:36 <__monty__> Yeah, Agda's mixfix is close.
11:33:52 <__monty__> muzzle: Doesn't dante do "interro but not necessarily stack?"
11:33:55 <svipal> I wish haskell had it for type operators.
11:34:02 <heatsink> monochrom: so the implementation, given a reference, can do int comparisons to decide what constructor is there
11:34:14 <solonarv> maybe try ghcid or ghcide
11:34:18 <muzzle> __monty__ from what I understood, yeah?
11:34:19 <geekosaur> kinds are types of types, and types of kinds, and so on up
11:34:26 * geekosaur suggested ghcid earlier
11:34:33 <solonarv> indeed you did
11:34:41 <muzzle> I've been using intero for so long I don't really know the ecosystem as it is currently
11:34:44 <solonarv> I am now also tossing ghcide in the ring!
11:35:25 <__monty__> ghcid doesn't get you a repl integrated into emacs. This is not just about having errors.
11:35:43 <__monty__> I don't know what ghcide does. I think it's something to do with hie?
11:36:53 <monochrom> My subjective careless statistics over this channel is that ghcide has the least chance of failing-to-set-up among all the IDE-like choices.
11:37:35 <geekosaur> ghcid set up as the repl gets you something that restarts / reloads itself as needed
11:37:51 <__monty__> But it's not a repl.
11:38:09 <__monty__> You can't poke around in your code using it.
11:40:21 <monochrom> Then again, I cannot know whether ghcide suits you.  Like I said, you don't even know what aspects of intero you need until you lose it.
11:40:25 <sm[m]> speaking of ghcide, did anyone get it working with intellij IDEs ?
11:41:19 <muzzle> I know pretty well whic aspects of intero I need, the repl feature that I can use to test out a module's functions interactively, go-to-definition and (optionally) autocompletion
11:41:26 <muzzle> integrated into an editor
11:41:56 <sm[m]> (I got no response at https://github.com/gtache/intellij-lsp/issues/125 yet)
11:42:06 <monochrom> My low-tech jump-to-definition is I open up speedbar (and probably keep it open) and click around it myself.
11:42:27 <__monty__> I use tags for go-to-definition. And I think my autocompletion's still coming from ghc-mod.
11:42:44 <__monty__> And just ghci for the repl : )
11:43:32 <solonarv> when I want a repl I just type 'cabal repl' into the terminal
11:43:33 <muzzle> __monty__ so how do you switch to a new module? restart the ghci process? :m +Foo.Bar?
11:44:39 <__monty__> muzzle: Yeah, :m +, unless it's already in scope. I think cabal new-repl has stuff in scope at startup?
11:44:48 <oats> solonarv: I am unsure of how to use zoom, could you help me understand what it's for?
11:46:03 <solonarv> I will give a simplified explanation.
11:46:17 <oats> lens types are confusing to me still
11:46:34 <solonarv> suppoes you have (inner :: Lens' Outer Inner), and (foo :: StateT Inner m a)
11:46:51 <solonarv> then (zoom inner foo :: StateT Outer m a)
11:47:24 <monochrom> You know what, haskell-mode already has jump-to-def (I just tried), it is just not bound to a key by default.
11:47:42 <monochrom> So I bet dante too because I know how they both do it.
11:47:50 <solonarv> oats: does that help?
11:48:39 <monochrom> They consult ghci.  ghci has a relatively new command for where-is-the-def, whats-the-expr's-type, etc.
11:49:02 <oats> solonarv: I think so, but I don't have "sub-State"s here
11:49:25 <monochrom> If you feel like talking to machines, you can use those ghci commands yourself too, they're just not too human-friendly, they're meant to be used by dante and haskell-mode etc.
11:50:12 <solonarv> oats: but you do! liftA3 (,,,) (use ...) (use ...) (use ...) :: StateT Config (..., ..., ...)
11:50:40 <monochrom> And a downside is that they don't work until you have had a successful load.  (So I use -fdefer-type-errors to increase the chance, and under really dire situation I also use 2-phase commit i.e. consulting ghcid first to ensure successful load before I commit to load.)
11:52:31 <oats> solonarv: oh, I see
11:52:33 <oats> interesting
11:53:49 <monochrom> They also have autocompletion.  Again there is a ghci command for that.
11:53:55 <solonarv> I used it for some of the Advent of Code problems that I did
11:54:35 <monochrom> I now feel like I should train myself to using ghci directly.  Ah the good old days when I telnetted to newsgroup servers.
11:54:51 <solonarv> my interpreter was a ConduitT Int Int (State VMState) ()
11:55:45 <solonarv> for the problems where you had some intcode program interacting with some "physical world", I ran the whole thing in a ConduitT i o (State (PhysicalWorldState, VMState)) ()
11:55:52 <monochrom> ghci is growing into an IDE minus editor. :)
11:56:05 <solonarv> and used 'zoom _2' to "lift" the interpreter into that
11:56:54 * hackage cipher-aes128 0.7.0.5 - AES and common modes using AES-NI when available.  https://hackage.haskell.org/package/cipher-aes128-0.7.0.5 (ThomasDuBuisson)
11:58:12 <monochrom> Oh wait it's bound.  M-.
12:00:08 <monochrom> Damn, I bound it myself, it is not bound by default.
12:00:31 <fog> so it turns out this graph isomporphism problem is actually a thing and its really difficult. im not sure its what i need either
12:01:15 <fog> i dont really want to compute if two graphs are isomorphic, but that the user should have an interface where they can shuffle the graph around and it will always stay isomprphic
12:01:25 <monochrom> You don't come across as so easily intimidated.
12:02:02 <fog> so its more a case of generating permutations to the construction DList that preserves the edges
12:02:09 <muzzle> monochrom I'll probably try hacking something myself
12:02:21 <muzzle> monochrom to just use what ghci already offers
12:02:33 <fog> which basically just means all the literature on the graph isomorphism problem isnt relavent 
12:03:15 <muzzle> nice as haskell is as a language the IDE situation is a tad disheartening. Not that I can really complain since I've not done anything to improve it I guess.
12:03:34 <fog> this was the closest i found; https://www.cs.bgu.ac.il/~dinitz/Course/SS-12/Ullman_Algorithm.pdf
12:03:52 <zincy_> What is the best way of creating a Map where the keys are 7 consecutive days starting from a date?
12:04:13 <oats> solonarv: interesting
12:04:28 <zincy_> The days bit isn't important just that they have an enum instance i suppose
12:04:34 <svipal> Are you asking about the best datastructure for this case or the best way to create a Map ?
12:04:42 <oats> solonarv: I tried to port my intcode VM to a conduit, but I couldn't figure out how to hook it up with other conduits with a different underlying monad
12:04:45 <zincy_> Best way to create the map
12:04:48 <oats> looks like you solved that bit
12:05:48 <monochrom> Economics and pain level.  Haskell without IDE is only slightly painful.  Java without IDE is impossibly painful so that's why IDEs flourished.  Observe that even C and C++ didn't quite enjoy much of IDEs (outside Microsoft anyway) until Java IDEs became cool.
12:06:09 <oats> @let import qualified Data.Map as Map
12:06:10 <lambdabot>  Defined.
12:06:35 <oats> > Map.fromList $ zip [0 .. 5] [5 .. 10]
12:06:38 <lambdabot>  fromList [(0,5),(1,6),(2,7),(3,8),(4,9),(5,10)]
12:06:43 <svipal> zincy_ there's not really a best way for just creating a map ? I guess I'd just fromList $ zip (fmap (+date) [0..]) values or something 
12:06:47 <oats> zincy_: as long as your type is Enum, you can do the [..] thing
12:06:59 <svipal> [0..7]*
12:07:04 <svipal> 6* actually haha
12:07:33 <solonarv> oats: indeed, the underlying monads have to match
12:07:53 <zincy_> ah zip that is useful
12:08:18 <oats> solonarv: did you have to change your VM's state type to match whatever "interfacing" you were doing?
12:08:20 <solonarv> with 'zoom' I was able to change the underlying monad from 'State VMState' or 'State PhysicalWorldState'  to 'State (PhysicalWorldState, VMState)'
12:09:07 <solonarv> I did have to change it, but it was only a matter of using 'transPipe (zoom someLens)'
12:09:29 <solonarv> the actual interpreter did not need to be changed at all
12:10:06 <fog> is Map like a graph?
12:10:14 <monochrom> No.
12:10:24 <oats> fog: nope, it's like a dictionary from Python
12:10:24 <fog> it would need edges right?
12:10:32 <oats> except statically typed, ofc
12:10:33 <monochrom> No.
12:11:02 <fog> :t Map.fromList
12:11:04 <lambdabot> Ord k => [(k, a)] -> Map.Map k a
12:11:13 <monochrom> It's like a list.
12:11:25 <monochrom> And list, is like array.
12:11:29 <fog> right, so the keys are for lookup
12:11:37 <monochrom> And array, like a lot of boxes.  What edge?
12:12:07 <monochrom> And boxes, like rectangles, they have edges. Oh wait.
12:12:12 <fog> so a graph is like; (Ord k => (Map k a,[(k,k)]))
12:12:32 <solonarv> that is one possible representation, yes.
12:12:36 <fog> the edges are the list of key pairs [(k,k)]
12:12:51 <oats> > Map.lookup 'b' (Map.fromList [('a', 3), ('b', 5)])
12:12:53 <lambdabot>  Just 5
12:13:12 <monochrom> Corollary: Map satisfies that theorem about euler characteristic and number of edges and number of faces. :)
12:13:18 <fog> its not good though because of how it was constructed not having a traversable instance - or maybe it get that from the original list
12:13:28 <zincy_> Is there an alternative to multiple `insertWith` calls for Map?
12:13:54 <maerwald> here is a nice bikeshedding: 'case foo of Just x -> 1 ; Nothing -> 2' or 'case foo of Just x -> 1 ; _ -> 2'
12:14:02 <solonarv> zincy_: make another Map and use 'unionWith' to combine them?
12:14:31 <fog> like if you had a square grid as [[]], then you would traverse the lists in turn, and the adjacents would be kind of implicit
12:14:55 <fog> otherwise i guess k would be (Int,Int)
12:15:19 <zincy_> solonarv: thanks thats a good idea
12:16:16 <solonarv> zincy_:  you could also use something like 'foldr (uncurry (insertWith f)) (startingMap :: Map k v) (xs :: [(k, v)])'
12:16:21 <fog> like, [[]] has get&set instances which just insert into the head of the head list, and the Free [] / Tree is the extension to this, where you then have to specify with an Int how far down the nestings the inserted element goes
12:16:36 <glguy> maerwald: if you're asking I prefer to specify the last pattern so that if I change an earlier one things don't unintentionally fall through to it
12:17:08 <glguy> So: case _ of Just{} -> 1; Nothing -> 2
12:17:59 <monochrom> Oh hey that inspires me, the best of both worlds: Just _ -> 1; _ -> 2  :)
12:18:04 * solonarv keeps forgetting you can use {} on non-record constructors
12:18:09 <maerwald> But if someone ever renames the Nothing constructor...
12:18:10 <fog> where i guess you would have type depthed Free, with the total depth bounding that insertion argument, and then the k would be a list of Ints of the same length
12:18:19 <glguy> If I later added something like Just y | p y -> ... I wouldn't want the _ pattern to swallow up the new possibility on its own
12:19:13 <glguy> And when I'm reading the final case I don't want to have to analyze all the other patterns to figure out what's being handled
12:19:36 <maerwald> that makes sense for more complicated matches yeah
12:19:53 <fog> so then, this isomorphism thing would be if there were also implicit edges making the n-dimensional grid periodic at the boundaries, and that any choice of where to place the boundaries is then equivalent
12:19:57 <maerwald> but _ -> is just less to type ;)
12:20:38 <glguy> That's also true
12:21:23 <fog> which is equivalent to some relabling of the keys or key pair edges of the Map version...
12:22:03 <fog> i just think that with the get/set construction there would be some equivalent way which was to permute the linear unfolding
12:22:49 <fog> i guess the 1d version is most simple, since its just putting the head at the tail, and all the isomorphic graphs are easily generated like this
12:23:35 <fog> but if it were some crazy shaped graph it would be much more difficult
12:24:33 <fog> the 1d version being a doubly linked list
12:24:53 <fog> with stencil via a zipper
12:25:33 <fog> thats why this unfolding via get&set is nice, because its guaranteed traversable so has a zipper to point to the nodes in turn
12:26:26 <fog> though then it cant use the "implicit" edges which were obvious from a grid having cartesian neighbours
12:27:06 <fog> ah, thats right, for that you just have cyclic references to other positions as branches 
12:27:55 <fog> but then it seems more like cofree, with the values at the branches, than Free [] which has them at the leafs
12:29:00 <fog> then the isomorphism problem is like, if you are navigated to some position with a zipper, how do you kind of suspend this node to be the top node and have all the edges dangle from it
12:29:52 <fog> there are probably a bunch of equivalent configurations for each choice of new top node
12:30:13 <fog> how to write this!?
12:32:52 <fog> oh yeah, and there is something with having the cyclic references that are the edges when they are used for stencils, which requires converting from Free to Fix, since the stencils need to gather nodes from the other side of the cyclic reference, so causing this to get evaluated... idk, maybe fix isnt nesacary if the stencils are finite... 
12:35:18 <fog> and that the whole point of this is that the stencil at some position requires plenty of navigating over the edges to gather up the values within some range, or under some navigation generating procedure, and the point of reconfiguring the graph is to make this evaluation of the stencil at this point require the least navigation, because the
12:35:19 <fog> "dangling action" kind of makes them all close 
12:37:25 <fog> then the function being sought would need to take this navigation generating stencil as an argument to determine the permutation over the DList of partially applied set functions 
12:37:52 <fog> seems pretty much impossible!
12:37:57 <fog> and at type level!? 
12:38:08 <fog> argh!
12:38:24 <moet> does anyone here have experience with safecopy and acid-state?
12:38:49 <moet> when doing a migration from an old data store to a new data store, do you need to _also_ do migrations for each query?
12:38:57 <moet> and each _update_?
12:48:05 <merijn> moet: No clue, although I feel compelled to warn you that, despite the name, acid-state is (frustratingly) not actually ACID
12:50:45 <__monty__> Oof, that sounds like a crime.
12:52:04 <merijn> __monty__: I know, I was quite annoyed by learning this
12:52:15 <svipal> what's ACID ?
12:52:53 <merijn> svipal: Atomicity, Consistency, Isolation, Durability, the 4 data guarantees traditional databases provide you with
12:52:57 <moet> merijn: what does it fail to do correctly?
12:53:30 <merijn> moet: https://github.com/acid-state/acid-state/issues/79
12:53:48 <merijn> Although it looks like there's a repair tool as of this summer
13:09:49 <moet> yeah, that's a little disappointing but i'm not doing something critical with this .. mainly trying to understand how the library is meant to be used
13:10:03 <moet> if it doesn't work exactly right, i can fork and fix and pr later
13:10:58 <merijn> What are you using it for?
13:12:48 <moet> a personal app that receives sms messages and does some analysis
13:14:25 <merijn> moet: Time to put evangelism uniform: Have you considered using SQLite? :)
13:17:30 <moet> merijn: yes, i like sqlite lite but i'd like a strong & statically typed interface .. i was trying out acid-state for this project because it sidesteps the impedence mismatch of language-values vs db-values entriely .. if you know of a good interface for sqlite let me know ... i've found persistent + esqueleto to be rather heavyweight and opinionated .. do you know of anything similar?
13:18:15 <moet> i've looked at selda but haven't tried it out yet
13:19:19 <merijn> So I have a bunch of quite elaborate stuff using persistent (without esqueleto) and I agree that that's...not ideal. Selda seems interesting, but at this point I'd probably just use sqlite-simple instead, tbh
13:23:50 <moet> merijn: sqlite-simple looks nice.. standard-ish string based interface with inference .. makes me remember that i have to worry about turning on sqlite's pragmas for enforcing things like foreign keys ..
13:24:48 <moet> merijn: do you have any resources for how to do migrations with sqlite? i suppose it's almost-standard rdms approaches, but since you're here and recommending it i thought i'd ask
13:28:34 <__monty__> moet: For just a personal experiment I'd check out project-m36.
13:29:20 <merijn> moet: SQLite has a reserved "user_version" value, which is a 64bit int applications can use for whatever they want. What I personally do is store a schema version number in there and then have code that migrates from 0 -> 1, 1 -> 2, ..., etc. until current
13:29:48 <merijn> moet: Persistent is so limited that about 50% of my migrations are manual SQL anyway
13:30:11 <merijn> moet: The SQLite docs have a pretty in-depth document on how to do more complex table migrations: https://www.sqlite.org/lang_altertable.html
13:32:10 <moet> __monty__: project-m36 looks interesting, though it doesn't put anything about migrations in the readme.. i'll dig into it morelater
13:32:40 <moet> merijn: yeah, i'll check that out .. the in-application patterns for handling migrations are what i'm most interested in .. thank you
13:40:20 <moet> __monty__: ooooh! m36 is the out-of-the-tarpit thing .. interesting!
13:43:42 <__monty__> Hmm, TIL, looks like it could be an interesting paper.
13:47:52 <comerijn> __monty__: What's the reason you'd recommend project-m36 over sqlite?
13:49:35 <__monty__> comerijn: I wouldn't. I'd recommend it for *personal experiments*.
13:49:46 <comerijn> ah
14:12:35 <jumper149> Hello, what exactly is the difference between Control.Monad.State.Lazy and Control.Monad.State.Strict?
14:15:26 <glguy> The strictness of >>= in it's first argument
14:16:38 <[df]> pics
14:16:51 <[df]> urg, sorry wrong channel
14:17:11 <suzu> ^ lmao
14:17:15 <ChaiTRex> Sorry, you're not getting any pics of it being strict in its first argument, so stop asking.
14:17:30 <suzu> boys only want one thing and it's disgusting!!
14:17:54 <dsal> Control.Monad.State.Lazy: https://usercontent.irccloud-cdn.com/file/ARVvM8M3/Control.Monad.State.Lazy
14:23:39 <swartic> oh epic
14:25:53 <jumper149> Am I right in saying that Strictness can only influence the time a program takes?
14:26:18 <maerwald> jumper149: it can also crash
14:26:31 <maerwald> or run forever
14:26:51 <jumper149> maerwald: It run indefinetely but not crash right?
14:26:54 <maerwald> memory behavior may also drastically change
14:27:05 <ChaiTRex> jumper149: It can do that. For example foldl' (+) 0 xs is generally faster than foldl (+) 0 xs.
14:27:17 <maerwald> jumper149: it can also crash
14:27:59 <ChaiTRex> jumper149: If it evaluates error function when a lazy evaluation wouldn't have bothered, it can crash.
14:28:33 <jumper149> ChaiTRex: nice example 👍
14:30:16 <jumper149> I have never analyzed runtime memory allocation. Can anyone suggest software to run on a test program
14:33:02 <comerijn> jumper149: Simplest thing to do is compiling with -rtsopts and using "+RTS -sstderr" with your program to get basic GC stats
14:34:07 <jumper149> what does rts stand for?
14:34:13 <solonarv> RunTime System
14:35:24 <solonarv> program arguments between "+RTS <<here>> -RTS" are gobbled up by the runtime system
14:35:55 <solonarv> you can make it output some extra information, or tune the garbage collector's parameters, that sort of thing
14:36:17 <solonarv> if you compiled with profiling enabled, you can also control what kind of profiling info gets output and how
14:41:38 <xr605> hey
14:41:48 <solonarv> hello!
14:42:21 <xr605> woo lifeforms! i've just started using IRC and trying to figure out what everything is
14:42:47 <ChaiTRex> xr605: Well, I'm a T. rex.
14:43:15 <xr605> ChaiTRex: fuck
14:43:44 <xr605> is freenode the only server onn irc that everything exists? or are there other servers people use
14:44:03 <glguy> This channel is about Haskell
14:44:17 <ChaiTRex> There are several networks, each with one or more servers. Freenode has several servers that all connect to the same freenode network.
14:44:27 <solonarv> (the functional programming language, not the town or anything else)
14:45:10 <comerijn> solonarv: Pfft, why would you think of a town before thinking of the person?
14:45:12 <jumper149> What if I want to talk about Haskell Curry the person, is that ok too?
14:45:34 <xr605> i assumed so which is why i came here haha, the community is usually alot of help on stackoverflow. never realized it was a town though
14:46:28 <xr605> is there a channel people often use for random noob questions about irc? other than #google?
14:46:40 <ChaiTRex> xr605: On this network, you can try #freenode
14:46:59 <xr605> thanks :)
14:47:33 <dsal> There's no #google channel, it seems.  There's a "how to ask questions the smart way" document which is helpful, though.
14:49:58 <xr605> I was joking about the #google channel, i meant i was too lazy to search myself
15:53:12 <qualiaqq> Why are Monads so well known? I'm sitting here reading https://wiki.haskell.org/Typeclassopedia and wondering that. Is it because that's the first stumbling block that people run into when learning haskell or did Functor et al not exist in older versions of Haskell?
15:53:16 <svipal> tagless final is actually super cool
15:54:10 <maerwald> qualiaqq: because IO uses it as an interface now. I think that's the main reason.
15:55:56 <[exa]> qualiaqq: also, they generalize an awful lot of stuff, and the syntax&tooling around becomes really convenient once you get used to it
15:56:39 <hpc> a particularly illustrative example of both of those points is list comprehension
15:57:20 <hpc> which is secretly the do-notation syntax sugar around Monad
15:57:33 <maerwald> [exa]: well, people overuse them
15:57:36 <hpc> and which pretty much everyone who learns haskell uses on their first or second day
15:59:16 <qualiaqq> I remember this guy I meet in college he was the only other person I've meet that knew haskell and he was further along into it than me at the time. The first thing he asked me was if I got to Monads yet (I had not at the time). Maybe it's all those damn Monad tutorials that hyped the difficulty of it.
15:59:17 <cpchung> I see in Marlow's code there is .cabal file named "parconc-examples.cabal". I have dependencies uninstalled for running some of the codes. Anyway I can install things according to this .cabal?
16:00:17 <dmwit> cpchung: I don't understand the question yet.
16:00:24 <dmwit> cpchung: Can you ask it another way?
16:01:25 <cpchung> while compiling some of the codes mentioned in Marlow's concurrency book , the compiler complained about `cannot find modiles XYZ` 
16:01:46 <cpchung> and I see a "parconc-examples.cabal" file, how can I use it?
16:02:02 <cpchung> https://github.com/simonmar/parconc-examples
16:02:02 <cpchung> I am talking about this repo
16:02:54 <maerwald> qualiaqq: it's a generalisation of a simple pattern and you've most probably seen it in other languages, just not that generalised, e.g. https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then
16:03:18 <cpchung> cpchung:parconc-examples$ ghc --version
16:03:19 <cpchung> The Glorious Glasgow Haskell Compilation System, version 8.6.5
16:03:19 <cpchung> cpchung:parconc-examples$ cabal --version
16:03:19 <cpchung> cabal-install version 3.0.0.0
16:03:19 <cpchung> compiled using version 3.0.0.0 of the Cabal library 
16:03:19 <cpchung> This is my environment
16:04:51 <chambln> Hey, I'm learning about IO in haskell. Is it possible for main to have a type signature other than ‘IO ()’? And what does the ‘()’ mean exactly?
16:04:59 <dmj`> chambln: yes
16:05:04 <dmj`> chambln: try putting IO Int
16:05:39 <qualiaqq> maerwald, oh yea I've seen that in Rust. Haskell is the first language I've seen that genrealises so many things like that.
16:06:00 <dmj`> chambln: () is like calling 'return', it doesn't return a value just void.
16:06:14 <dmj`> chambln: like calling return in C that is
16:08:43 <qualiaqq> generalizes*
16:09:11 <chambln> dmj`: OK, cheers.
16:09:50 <chambln> So what's an example of a function that has type IO Int?
16:10:58 <svipal> some random function
16:11:09 <svipal> randomRIO ?
16:11:26 <dmj`> chambln: pure 4 :: IO Int
16:14:34 <hpc> btw, so you don't end up confusing yourself later, these are "actions" and not "functions"
16:14:55 <chambln> Right, yet
16:14:57 <chambln> yep*
16:15:15 <chambln> Hmm, OK cool.
16:15:39 <chambln> Why would you want to have ‘main :: IO Int’ though?
16:17:13 <wikiemol> https://pastebin.com/b07S5Ea0 So I have this tree structure, and I need a way to append a right most node to it in succession. Is there a way to do this without iterating through the whole tree? In an imperative language, I could just store the pointer to the right most node, and each insertion after the first would be O(1). Is there a way to get
16:17:14 <wikiemol> this in Haskell? 
16:18:41 <hpc> main is weird
16:18:49 <hpc> if it has type IO (), running the program executes main
16:19:02 <dmwit> wikiemol: You may use the same strategy, but you will need a mutable tree.
16:19:08 <hpc> if it has type IO anythingElse, you effectively have main' = main >>= print
16:19:10 <dmwit> wikiemol: Which gives up all the usual benefits of immutability.
16:19:26 <dmwit> hpc: You are mistaken; perhaps misled by running `main` in ghci instead of `:main`.
16:19:45 <monochrom> ghci is the special one.
16:19:48 <hpc> ah
16:19:52 <wikiemol>  dmwit Oh? I haven't used mutability in haskell. Is there not a pure way to do this? Are there any resources to learn about this?
16:20:20 <dmwit> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-STRef.html
16:20:40 <dmwit> You might also look into zippers, depending on exactly what you want.
16:21:11 <wikiemol> Do Zippers work for abitrary trees? I thought they only worked for binary trees
16:21:35 <dmwit> They work for arbitrary trees.
16:22:05 <wikiemol> I think I had trouble understanding them, I will have to look at them closer
16:22:25 <dmj`> chambln: I don't think you would
16:23:09 <chambln> dmj`: Alright, so it's possible but not useful? I was just curious.
16:23:54 <monochrom> wikiemol: I will tell you a simpler story involving just singly-linked lists.  The input is a list of numbers, e.g., [3, 1, 4].  The output is a corresponding list (let's say build a new one, don't change the old one) in which each number is doubled, e.g., [3*2, 1*2, 4*2].
16:24:48 <monochrom> In C, you would say, let me build the first node for the 3*2, then append after it the 2nd node for the 1*2, then append after it the 3rd node for the 4*2.
16:24:54 <chambln> I had a "aha!" moment yesterday regarding fmap. haskell is really cool.
16:25:25 <monochrom> How to do "this" in Haskell?  No, don't do "this".  Instead, f [] = []; f (x:xs) = x*2 : f xs
16:26:24 <wikiemol> monochrom I was actually just typing something I think related
16:26:42 <wikiemol> Could I just store every tree I am going to insert into a list
16:26:53 <chambln> monochrom: Can't you write that f as a fold?
16:26:54 * hackage tree-render-text 0.1.0.0 - Configurable text rendering of trees.  https://hackage.haskell.org/package/tree-render-text-0.1.0.0 (ThomasEding)
16:27:12 <monochrom> chambln: That's beside my point.
16:27:29 <wikiemol> And then iterate over it, in "reverse" order, appending at the top, instead of the bottom
16:27:54 <monochrom> But f doesn't reverse ever.
16:28:06 <wikiemol> Well, you wouldn't have to reverse in reality
16:28:11 <wikiemol> you just create the list in reverse
16:31:18 <wikiemol> Your solution works monochrom, in the case of inserting one thing. But I need to insert multiple things, and f will iterate through the whole tree every time. I don't need to change any of the nodes except for the right most one, so this work of iterating through the whole tree every time is redundant. Can f be generalized to handle this? If so I
16:31:19 <wikiemol> am not understanding
16:31:35 <monochrom> But I'm "inserting" three things.
16:32:10 <wikiemol> The analogous thing would be [3, 1, 4 * 2 * 2 * 2]
16:32:13 <monochrom> Except that my point is that thinking in terms of "insert" is wrong.
16:32:29 <wikiemol> More along those lines
16:32:54 <wikiemol> Not [3 * 2, 1 * 2, 4 * 2]
16:33:20 <wikiemol> monochrom Oh okay, maybe I am just misunderstanding
16:34:48 <monochrom> f doesn't "take an existing prefix like [3*2, 1*2] and how do I append 4*2 to it at the end?".  f produces [3*2, 1*2, 4*2] directly.  Mathematical there is no change.
16:35:47 <maerwald> looks like a haskell course at some uni started :P
16:36:04 <wikiemol> That makes sense. I just want to produce it efficiently, the tree could be very large. 
16:38:30 <monochrom> Oh my f could be used for a really long list too.
16:38:48 <monochrom> In fact it works beautifully even for infinite lists.
16:40:52 <wikiemol> monochrom Could you show me how it works for this specific problem? Maybe I am just misunderstanding
16:40:59 <wikiemol> I have a function that produces the tree
16:41:09 <wikiemol> But it is simply inefficient 
16:41:42 <wikiemol> ++ [x] is O(1) by default
16:41:47 <wikiemol> a tree is different
16:41:52 <wikiemol> At least I think
16:43:53 <monochrom> No, that's my point, foo ++ [x] takes time proportional to the length of foo.
16:45:04 <monochrom> And my f doesn't dabble in such disgusting travesty.
16:46:11 <monochrom> Dually, in C, I wouldn't try to code up or translate f, that would be a disgusting travesty too.
16:49:58 <wikiemol> I just don't see how your example translates to this problem
16:50:30 <wikiemol> monochrom
17:04:13 <monochrom> Don't add little things to the tree one at a time for a thousand times?  Go for the final tree directly?
17:04:42 <wikiemol> I just don't understand how that is possible. I need to build the tree iteratively 
17:05:09 <wikiemol> I have no tree at the beginning
17:05:25 <monochrom> And f has no list at the beginning.
17:06:17 <wikiemol> monochrom f has [3, 1, 4] as input right?
17:06:45 <monochrom> You want an example that doesn't even have an input list?  Input is a positive integer n, produce [1, 2, ..., n]
17:07:21 <wikiemol> sure 
17:07:39 <monochrom> Answer: g n = go 1 where go i = if i<=n then i : go (i+1) else []
17:10:08 <monochrom> Now I need another nerd-sniped code golfer to ask me "monochrom: can't you write that as an unfold?"
17:11:02 <wikiemol> monochrom Okay, so yeah, so I would need to add to the "top" of the tree instead of the bottom correct?
17:11:44 <monochrom> I wouldn't call "i : go (i+1)" "add to the beginning of the list".  I would call it "it's already the final list".
17:12:30 <monochrom> It equals the final list.
17:12:37 <wikiemol> monochrom why wouldn't you say that about [i] ++ go (i + 1)?
17:12:38 <monochrom> math's equal.
17:12:47 <wikiemol> You can say it about any pure code 
17:12:48 <monochrom> I would. Same difference.
17:15:29 <wikiemol> sorry I should say, why wouldn't you say the same about something like g n = go n where go i = if i > 0 then go (i-1) ++ [i] else [0]
17:16:40 <monochrom> Yes, but your question also involve "pointer to the currently last node and use mutation to add a little thing after"
17:17:56 <wikiemol> I suppose, I didn't mean to draw attention that specific implementation. The point was that thats how it would be done in an imperative language. Sorry if it was confusing.
17:18:17 <monochrom> Your code still doesn't use pointer to the currently last node and use mutation to add a little thing after and achieve constant time per addition.  "foo ++ [i]" ends up cloning all of foo just so as to build a new list that has the extra i.  This is linear time per addition.
17:18:35 <monochrom> Meanwhile, my code is constant time per recursive call.
17:19:21 <monochrom> Do you remember everything I said?  Because I already addressed that too.
17:19:48 <monochrom> I wouldn't translate C code to Haskell, and I wouldn't translate Haskell code to C.
17:20:01 <wikiemol> Yes, this conversation has been helpful. However, I wouldn't say that either implementation is less "inserty". One is just more effecient. This is what I am asking for. The analogous way to do yours with trees is still non trivial
17:20:30 <wikiemol> I am sorry if that was confusing, that wasn't my goal
17:22:37 <wikiemol> My point is that I am aware of what you are saying (I wasn't aware that ++ was O(n), but I was aware that the equivalent for my tree was) I just don't know the other way to do it. Thats what I am looking for
17:23:56 <wikiemol> But I think this conversation is helpful, I need a sort of "cons" equivalent for the tree, instead of thinking in terms of a "++" equivalent
17:24:24 <monochrom> The data constructor "ParseTree" is already your cons.
17:24:41 <monochrom> After all, ":" is a data constructor too.
17:26:06 <wikiemol> I wouldn't say so. There are two directions. One is "leftword" in the children of the tree. The other is "upword".
17:26:30 <wikiemol> I need both
17:31:22 <wikiemol> Sorry, I see what you are saying. 
17:49:12 <wikiemol> monochrom thank you for humoring my lack of humility
17:51:54 * hackage tree-render-text 0.1.1.0 - Configurable text rendering of trees.  https://hackage.haskell.org/package/tree-render-text-0.1.1.0 (ThomasEding)
18:07:54 * hackage tree-render-text 0.2.0.0 - Configurable text rendering of trees.  https://hackage.haskell.org/package/tree-render-text-0.2.0.0 (ThomasEding)
18:14:39 <monochrom> Eh, that package looks interesting
18:15:20 <monochrom> And its dependency "boxes" looks handy too.
18:20:08 <svipal> boxes is great
18:28:00 <white_magic> hi, can someone help me understand how to read functional languages' function signatures?
18:28:43 <dibblego> what is an example?
18:29:03 <white_magic> ok.. this may not be entirely appropriate.. but it's from F#.. 
18:29:04 <white_magic> int -> int -> int
18:29:28 <white_magic> This webpage is claiming that the above function signature implies that the function takes in 2 int params and returns a single one
18:29:31 <white_magic> https://fsharpforfunandprofit.com/posts/function-signatures/
18:29:39 <white_magic> shouldn't it be more like int -> int
18:30:27 <MarcelineVQ> what does int -> int mean to you in your own words?
18:30:40 <white_magic> that the function takes in a single int param and returns a single int param
18:30:58 <MarcelineVQ> That is an accurate description of int -> int
18:31:14 <white_magic> it's int -> int -> int that got me confused
18:31:46 <svipal>  The  signature can be rewritten as  int -> (int -> int )
18:32:03 <solonarv> quick and dirty answer: the last 'int' is the *return* type
18:32:03 <dibblego> -> associates to the right
18:32:12 <dibblego> it takes an int argument and returns int -> int
18:33:05 <white_magic> ok so the first 'int' is the input param.. and the return type is a function (which has a signature of 'int -> int') ?
18:33:07 <cpchung> cpchung:books$ cabal install --lib accelerate --minimize-conflict-set
18:33:08 <cpchung> Resolving dependencies...
18:33:08 <cpchung> cabal: Could not resolve dependencies:
18:33:08 <cpchung> [__0] trying: base-4.12.0.0/installed-4.1... (user goal)
18:33:08 <cpchung> [__1] trying: ghc-8.6.5/installed-8.6... (user goal)
18:33:08 <cpchung> [__2] next goal: process (user goal)
18:33:08 <cpchung> [__2] rejecting: process-1.6.7.0 (conflict: ghc =>
18:33:09 <cpchung> process==1.6.5.0/installed-1.6...)
18:33:09 <cpchung> [__2] rejecting: process-1.6.6.0, process-1.6.5.1,
18:33:10 <cpchung> process-1.6.5.0/installed-1.6..., process-1.6.5.0, process-1.6.4.0,
18:33:10 <cpchung> process-1.6.3.0, process-1.6.2.0, process-1.6.1.0, process-1.6.0.0,
18:33:11 <cpchung> process-1.5.0.0, process-1.4.3.0, process-1.4.2.0, process-1.4.1.0,
18:33:11 <cpchung> process-1.4.0.0, process-1.3.0.0, process-1.2.3.0, process-1.2.2.0,
18:33:12 <cpchung> process-1.2.1.0, process-1.2.0.0, process-1.1.0.2, process-1.1.0.1,
18:33:21 <white_magic> ok so the first 'int' is the input param.. and the return type is a function (which has a signature of 'int -> int') ?
18:33:23 <dibblego> white_magic: yes
18:33:29 <white_magic> interesting..
18:33:57 <white_magic> ok I got one more question..  ('T -> 'U) -> 'T list -> 'U list ?
18:34:05 <white_magic> This is for the 'List.map' function in F#
18:34:12 <white_magic> its usage is: "
18:34:12 <white_magic> List.map mapping list"
18:34:38 <dibblego> it takes as its argument, a function ('T -> 'U) and returns a function ('T list -> 'U list)
18:35:07 <white_magic> that's not true - takes in 2 params: a function and a list
18:35:35 <dibblego> no
18:35:37 <dibblego> it is true
18:36:19 <MarcelineVQ> if   int -> int -> int   is also   int -> (int -> int)   then  ('a -> 'b) -> 'a list -> 'b list   is also  ('a -> 'b) -> ('a list -> 'b list)
18:36:58 <dibblego> -> associates to the right
18:37:13 <dibblego> https://blog.tmorris.net/posts/haskell-functions-take-one-argument/
18:37:18 <white_magic> gonna need a few minutes for my organic cpu to process this..
18:42:15 <white_magic> ok i'm slowly accepting it.. thanks for your patience
18:42:31 <white_magic> I can totally handle functional/declarative programming in javascript or C#
18:42:48 <white_magic> but more 'proper' functional programming is quite alien
18:42:51 <dibblego> the book Design Patterns has a whole section about it, though it's called something else there
18:43:12 <dibblego> https://refactoring.guru/replace-parameter-with-method-call
18:44:16 <dibblego> er, book Refactoring
18:47:40 <white_magic> dibblego, I think that example is incomplete, isn't it? It says to 'place a query call inside the method body' instead of passing values through the parameter.. it does no such thing! Whatever happened to 'fees' and 'seasonDiscount'?
18:48:07 <dibblego> it takes a "two argument function" and turns it into a function that takes one argument that returns a function
18:48:43 <white_magic> which function is supposed to be a 2 arg function?
18:48:57 <white_magic> discountedPrice() takes in 3 params in the first example
18:49:12 <dibblego> discountedPrice
18:49:21 <dibblego> well yeah, ok
18:49:56 <white_magic> "double finalPrice = DiscountedPrice(basePrice, seasonDiscount, fees);"
18:49:59 <white_magic> that's in the first example
18:50:26 <white_magic> in the 'solution' example, they just pass in 'basePrice' - just a single param
18:50:34 <white_magic> what am I missing?
18:52:15 <white_magic> wait, i think I got it..
18:52:28 <white_magic> they are simply implying that the retrieval of the other 2 params happens inside the function?
18:52:57 <white_magic> yes, i guess they hinted at it
18:53:08 <white_magic> ok, this is dead simple, i just thought there was more to this
19:02:50 <MarcelineVQ> I must admit that webpage is unclear to me what is being done and why. Is the point that  this.* are available anywhere in the example so you might as well place them where they're used? asking since idk how this.* works.  This would be much clearer if the definition of discountedPrice was given.
19:03:24 * hackage base64 0.0.1.0 - RFC 4648-compliant padded and unpadded base64 and base64url encodings  https://hackage.haskell.org/package/base64-0.0.1.0 (topos)
19:04:10 <dibblego> "refactoring" is *almost* deliberately* unclear
19:04:19 <topos> oh hi dibblego 
19:04:22 <topos> howsit
19:04:24 <dibblego> omg hi topos !!
19:04:28 <topos> ;)
19:04:30 <dibblego> yeah alright, having a weekend off
19:04:45 <dibblego> country is burning anyway
19:04:53 <topos> nice! me too. flipping bits in bed 
19:05:06 <dibblego> sounds rude
19:05:37 <MarcelineVQ> deliberately unclear is an awful combination of words :(
19:05:55 <topos> o shit you're right. 
19:05:57 <topos> HA
19:06:24 <dibblego> all my renewals fall on similar dates, so I am filling out paper forms
19:07:27 <white_magic> MarcelineVQ: I agree, that page/example is needlessly confusing
19:07:29 <white_magic> for something so dead simple
19:07:58 <white_magic> I find Microsoft's F# documentation for the List.map function, for example, as very intuitive and well written: https://msdn.microsoft.com/visualfsharpdocs/conceptual/list.map%5b%27t%2c%27u%5d-function-%5bfsharp%5d
19:08:08 <topos> dibblego sounds magical. 
19:08:11 <dibblego> I just mean, that's what "(ab)normal programmers" are doing, because they don't have this idea of functions taking an argument then returning functions
19:08:20 <dibblego> topos: yeah, paper makes aeroplanes fly
19:08:29 <white_magic> dibblego, Oh god, you're in AUS. Really scary stuff going on there.
19:08:43 <dibblego> yes, I have the news on in the background — a town is being evacuated
19:09:18 <dibblego> Eden and surrounding areas are on leave now
19:10:07 <white_magic> AUS will have to figure out how to desalinate the ocean and how to build mega-megacities
19:10:15 <white_magic> You guys have no other choice
19:10:35 <dibblego> our PM is in damage control, making advertisements on how good he is — ain't nothing useful going to happen
19:11:05 <white_magic> ehh i mean considering the geography and climate of AUS.. not much you can do
19:11:10 <ChaiTRex> didn't he refuse to declare an emergency for this?
19:11:21 <white_magic> people will just have to abandon certain parts of the country for good
19:11:39 <MarcelineVQ> I can't think of more emergency than flaming children but I'm old fashioned that way
19:11:43 <white_magic> it's just like in Southern California (but worse) - the fires are getting worse every year
19:11:48 <dibblego> ChaiTRex: the list is long
19:16:14 <white_magic> curious, can someone tell me if you use functional programming for personal/hobby projects?
19:16:26 <dibblego> white_magic: I use only functional programming, for all programming
19:16:29 <white_magic> I know haskell, for example, has some very specific, albeit infrequent uses
19:16:40 <dibblego> I use dysfunctional programming occasionally, for parody
19:16:45 <white_magic> dibblego, very cool.. I'm trying to come up with some good uses of fn programming
19:17:04 <dibblego> "when you want your program to work" is the main use case
19:17:13 <white_magic> e.g. if I want to create a REST api.. maybe FP is not going to add much
19:17:19 <dibblego> Here's a piccie https://i.imgur.com/KXtEERu.jpg
19:17:39 <dibblego> white_magic: yes it definitely will, I have one http://metar.online
19:17:49 <white_magic> poor Kangaroos of Kangaroo Valley
19:18:01 <dibblego> https://hackage.haskell.org/package/metar  https://hackage.haskell.org/package/metar-http
19:18:27 <white_magic> an aviation related API in haskell?
19:18:37 <dibblego> of course, how else to fly aeroplanes safely?
19:19:01 <dibblego> Here are the town's being evacuated https://imgur.com/a/BDLdVUl
19:19:20 <white_magic> i know exactly 1 programmer who writes code for a component that makes up a plane and it's in C :)
19:19:23 <dibblego> that API exists because international stations do not include YBAF, and I need that
19:19:26 <white_magic> but they test it.. oh do they test it..
19:19:32 <white_magic> it's like 10% coding and 90% testing
19:19:35 <dibblego> yeah tell that guy I turn his software off before flight
19:19:50 <dibblego> it makes my passengers nervous
19:20:01 <white_magic> heh
19:20:28 <white_magic> you must have some refined passengers if they differentiate between haskell and C
19:21:13 <dibblego> I mean, when it doesn't work, and says silly things, they make comments
19:21:51 <dibblego> "why is it flashing red?", "well because it doesn't work <turns off>"
19:21:56 <dibblego> so now I just turn it off before flight
20:25:17 <dsal> white_magic: What do you mean "FP is not going to add much" ?  Are you comparing it to something else?
20:25:57 <white_magic> dsal, I just meant that FP is pretty nifty and I personally like it, but I don't think FP is always better or at least significantly better
20:26:07 <dsal> Better than what?
20:26:11 <white_magic> for certain tasks
20:27:01 <white_magic> to give a contrived example, if you wanted to do some sort of MVP/prototype of a simple CRUD application, you should probably use something like ruby on rails and VueJS or even JQuery
20:27:19 <dsal> Of course there are certain tasks that require specific languages, but just about any task I have to perform, I do in haskell.  Seems easier than most other things I've tried.
20:27:25 <white_magic> instead of some esoteric FP language with a 'work in progress' set of libraries
20:27:43 <white_magic> More than anything, I'm thinking of libraries, or lack thereof
20:28:02 <white_magic> If I'm being honest, I don't know much about haskell, other than that it has a formidable reputation
20:28:09 <white_magic> I'm more familiar with other FP langs
20:29:08 <dsal> I guess.  I needed to do some stuff with MQTT and there wasn't a good implementation, so I wrote one.  And then v5 came out with a bunch of new features, so I made it support that.  Then I made a MQTT RPC thing and now I use a haskell program to talk to my mqtt server to talk to another haskell program that talks to my mqtt server to tell my car how much I want it to charge.
20:29:21 <white_magic> based on what I read over and over on HackerNews discussions, people way smarter than me have found that haskell is a ridiculously steep hill to climb 
20:29:37 <dsal> Maybe?  I don't know.  It's the easiest language I use regularly.
20:29:48 <white_magic> hah..
20:30:05 <dsal> It *allows* for things that you probably aren't aware of if you have a background in like, java or something.  But for the most part, it's super easy to write good code.
20:30:06 <white_magic> That does not match what I read about it
20:30:13 <white_magic> the 'easy' part
20:30:16 <dsal> I use it more than I read about it, I guess.
20:30:18 <MarcelineVQ> learning FP for the first time is a steep hill, and lerning lazyness as well, combining them can be fairly steep yeah, but that's not haskell itself that's hard
20:30:44 <white_magic> MarcelineVQ, I'm quite interesting in learning more of FP, but I'm not convinced that haskell is the most practical among them
20:30:54 <white_magic> practical in terms of the learning curve and the number of libraries available
20:31:01 <white_magic> and libraries are quite important for productivity reasons
20:31:06 <MarcelineVQ> That's fine, no one here is a salesman, we're here to help if you want to explore this direction :>
20:31:10 <dsal> It does kind of have too many libraries, I find.
20:31:13 <MarcelineVQ> haskell has some pretty venerable (as in battle tested) library options, and new ones every day :>
20:31:19 <white_magic> for this reason, languages like F# and Clojure, have an edge over many other FP langs
20:31:32 <white_magic> MarcelineVQ, for sure. Thank you for being understanding :)
20:31:54 <dsal> I've never used F#.  Only casually worked with clojure.  I had a friend who was pretty hardcore into it.  I'm pretty happy to not have to interact with JVMs, though.  :)
20:32:24 <white_magic> eh JVM has a very very good reputation, though
20:32:25 <heatsink> Haskell also does not let you do some of the basic things you habitually do in other languages; it has other ways of solving the same problems.  Less knowledge transfers over from other languages, which is why people say it has a higher learning curve.
20:32:35 <white_magic> Now the Java language, on the other hand..
20:33:19 <heatsink> For example, "just define a global variable" won't work in Haskell.  When you feel you want a global variable, there are other ways of getting what you want.
20:33:32 <dsal> java has a good reputation for running java.  clojure might fit OK.  There are things that it can't do very well.
20:34:26 <heatsink> I mean, it has global variables, but only immutable ones.
20:34:29 <white_magic> dsal, you mean JVM has a good reputation for running Java. All I know is what I've heard from others who are more immersed in the JVM world and they say it is rock solid
20:34:40 <white_magic> and has more libraries than any other ecosystem
20:34:54 <MarcelineVQ> "<heatsink> ... does not let you do some of the basic things you habitually do" oh man and I feel that pain too now, working with total languages. let me use my unbounded recursion and types that aren't strictly positive ;_;
20:34:59 <white_magic> It has not just java or clojure but even more FP langs, e.g. Scala
20:35:11 <white_magic> Myself, I'm a fan of .NET
20:35:20 <white_magic> (don't hate .. heh)
20:35:33 <dsal> I was reading about STM in rust.  In Haskell, when you do STM, you can't* write code that compiles with side effects during a transaction.  The rust library was suggesting you should avoid certain types of things in order to get it right.  Haskell will tell you when you're making a mistake that would be bad.  In other systems, they just tell you to carefully read docs.
20:35:55 <dsal> Writing parallel and/or concurrent haskell is mostly pretty boring.
20:36:08 <dsal> white_magic: Why is the number of libraries interesting?  I don't want a large number, I just want something that works well.
20:36:16 <heatsink> MarcelineVQ, I remember the pain of not having unbounded recursion.  Fortunately that was a side project, so I had the option of just giving up
20:36:23 <heatsink> MarcelineVQ, using coq?
20:36:30 <MarcelineVQ> agda/idris
20:36:40 <heatsink> hmm
20:36:58 <white_magic> dsal, because people have different needs at different times? For example, given some random thing you're interested in.. if you choose either the Python or the Java/JVM ecosystem (or perhaps NodeJS), you are likely to have a library for it
20:37:04 <white_magic> .NET.. also.. to a lesser extent
20:37:22 <white_magic> Now that you have a library (perhaps an API wrapper).. you can get onto actually writing your application
20:37:30 <white_magic> instead of having to do all the piping manually
20:38:00 <heatsink> white_magic, in my experience with Scala vs. Haskell, I had to write a lot more glue code in Scala
20:38:01 <white_magic> Of course.. the quality of the libraries matters greatly
20:38:29 <white_magic> heatsink: that reminds me of Ruby/Ruby on Rails
20:38:30 <dsal> Most of the production haskell I've written this week has been interfacing with an unnecessarily complicated C++ library.
20:38:46 <white_magic> I'm not very experienced with it but i know that Rails has minimal glue clode
20:38:47 <white_magic> *code
20:38:51 <white_magic> and so many libraries
20:39:12 <white_magic> so if you wanted to code something up quickly with authentication and many other features, you probably couldn't beat Rails
20:39:12 <white_magic> or PHP
20:39:20 <white_magic> slash Laravel
20:39:30 <white_magic> I guess it just depends on what your goals are
20:39:36 <dsal> Why would I bother with authentication if I were writing something in PHP?
20:39:39 <white_magic> Let's not forget about Microservices
20:39:55 <white_magic> dsal, you laugh but PHP is probably the most popular language in the world
20:40:03 <dsal> Your position seems to be, "I don't know much about Haskell, but here's why all other languages are better."
20:40:05 <white_magic> granted, with tons of insecure websites that it is powering
20:40:07 <MarcelineVQ> thank god for wordfence
20:40:33 <white_magic> dsal, I'm not saying they are better at all, just better for certain tasks
20:40:45 <white_magic> My understanding is that haskell is excellent for some very specific coding
20:40:47 <white_magic> with very complex logic
20:41:00 <white_magic> OCaml, as well
20:41:01 <dsal> OK, "I don't know much about haskell, and haven't tried actually doing of these tasks with it, but I think it's not as good as other things, probably."
20:41:08 <MarcelineVQ> nah haskell is a general purpose programming language, as complicated or as simple as you want to write it
20:41:12 <white_magic> E.g. Wall Street/Quant algos
20:42:05 <dsal> I wrote an interface to my battery charger in haskell a couple years ago.  Simple REST interface and all the low-level bits talking on the wire to tell me what the state of the thing is.
20:42:33 <white_magic> dsal, I don't want to go about this at length. Suffice it to say, haskell has a great reputation and I'm not knocking on it. I'm just pointing out that FP shines in more specific use cases.
20:43:23 <dsal> In my experience, FP shines in the "I'd like this to be relatively correct and easy to manage without having giant piles of code everywhere" use case.  That's mostly where I use it.
20:43:24 <white_magic> (Based on the countless discussions about it that I read)
20:43:31 <dolio> The other people are just pointing out that it's fine for almost everything.
20:43:47 <white_magic> dsal, I agree with that assessment 100%
20:44:05 <white_magic> imho FP is excellent for complex logic
20:44:06 <dsal> Haskell isn't very good for arduino.  That's unfortunate.
20:44:14 <white_magic> that's where it shines, in my humble opinion
20:44:24 * hackage typelevel-rewrite-rules 0.1 - Solve type equalities using custom type-level rewrite rules  https://hackage.haskell.org/package/typelevel-rewrite-rules-0.1 (gelisam)
20:44:50 <MarcelineVQ> You can compile good-for-arduino code via haskell tho :>   or stm at least, e.g. using ivory
20:44:52 <dsal> So like, don't use FP if your program is trivial?  I guess.  I still use it when my programs are trivial.  heh
20:45:20 <white_magic> dsal, but I think I might end up using FP for trivial tasks anyway because I think FP is super neat and I need to practice it more
20:45:28 <dsal> MarcelineVQ: Oh nice.  I still use C++ for arduino/esp32.
20:45:33 <white_magic> :)
20:45:42 <MarcelineVQ> https://ivorylang.org/index.html
20:47:35 <MarcelineVQ> dsal: idris compiles to ardunio btw :>
20:47:47 <dsal> That's interesting.
20:47:57 <dolio> Whoa.
20:47:59 <dsal> I know some agda, but no idris at all.
20:48:08 <dolio> 1 or 2?
20:48:11 <MarcelineVQ> the rts is a little big stil though so you don't have a ton of room to do stuff, still neat
20:48:13 <MarcelineVQ> 1
20:48:40 <dolio> Idris is really impressive with its backends.
20:49:01 <dsal> dolio: He didn't get sexiest man alive for nothing'
20:49:10 <MarcelineVQ> omy
20:49:20 <MarcelineVQ> sexiest man, grosest cat
20:49:23 <MarcelineVQ> https://github.com/stepcut/idris-blink
20:51:07 <MarcelineVQ> idris2 is based on types which track their useage so it should be even easier to make something nice for embedded systems, no one's doing that yet though afaik
20:51:25 <MarcelineVQ> ux is a little lacking in 2 so far since it's nascent
20:56:35 <dsal> @index _Just
20:56:35 <lambdabot> bzzt
20:56:38 * dsal sigh
20:57:44 <dsal> That thing where lens types are hard to express, and the compiler is making a dumb guess.
21:01:53 <dsal> The answer I was looking for was    (Applicative f, AsValue a) => (Value -> f Value) -> Maybe a -> f (Maybe a)
21:02:07 <dsal> _Just . key "x"
21:02:41 <dsal> The compiler decided 'a' was the first thing it saw, which broke for all the other things.
21:07:21 <dsal> I think part of my problem is just not having a sufficient understanding of optics, while I keep trying to use optics.  There's an easier way to solve this problem, but this was also kind of a throwaway data analysis thing to answer a question someone had on a mailing list at work today.
21:21:39 <dibblego> white_magic: haskell is relatively easy to learn
21:22:04 <white_magic> dibblego, then.. the hackernews crowd is stupid?
21:22:10 <dibblego> white_magic: no, just incorrect
21:22:13 <dsal> Learning everything you can do in haskell with everything people have built is super hard.  But the core language is easy.
21:22:13 <white_magic> hmm 
21:22:26 <dsal> I've not seen much evidence that the HN crowd says anything worth listening to.
21:22:36 <dibblego> both my children had no problems at all; neither did many of the other non-programmers who I have taught
21:22:59 <dibblego> they do have problems with dysfunctional programming though; as the university requires them to do
21:23:04 <dsal> I taught my gf haskell a few months ago.  She got through AoC 2019 this year using Haskell.  Wouldn't share much of her work with me, though. 
21:24:04 <dibblego> one of them learned dysfunctional programming on 21 July 2012 and I recorded it, https://www.youtube.com/watch?v=tRszt-AlKOc
21:24:11 <day> can patternguards generally replace if/else statements? my specific case is this? https://pastebin.com/raw/sCMMedfC
21:26:15 <day> my issue is probably the '= do' '=' (i tried a few things)
21:26:21 <dsal> day: There's kind of a lot going on there.  It's mixing parsing, IO, and comparisons all at the same time.
21:26:44 <dsal> Try making a   Int -> String
21:27:40 <dsal> > let i2s :: Int -> String;  i2s 5 = "five"; i2s _ = "not five"  in    i2s (read "5")
21:27:42 <lambdabot>  "five"
21:27:46 <dsal> > let i2s :: Int -> String;  i2s 5 = "five"; i2s _ = "not five"  in    i2s (read "4")
21:27:48 <lambdabot>  "not five"
21:28:39 <day> hm i guess the pattern guard compares more to an ternary operator then?
21:28:57 <dsal> IO would be separate.  Something like:     main = print =<< (i2s . read <$> getLine)
21:29:02 <day> i2s = i==5 ? "five" : "not five"
21:29:09 <dsal> That's just if else.
21:29:15 <dsal> You can have as many patterns as you want.
21:29:29 <day> yeah but you need to assign something with it?
21:29:39 <dsal> What do you mean?
21:29:49 <amalloy> a pattern guard needs to be attached to a pattern match
21:30:05 <day> what would be the syntax to have an IO() operation as a result?
21:30:09 <dsal> In practice, I almost never use if/else.  It seems a bit clunky and rarely is the best way to do things.
21:30:20 <day> yeah that is why i was curious
21:30:24 <dsal> An IO action is just a response.
21:30:42 <dsal> Part of the problem with your code is that you were trying to do three distinct things in a single statement.  In practice, you probably wouldn't do that, but you could.
21:30:56 <dsal> er, response/value.  I'm a bit distracted. heh
21:32:23 <dsal> You can't just stick guards anywhere...  You could use Control.Monad's when or unless to do something kind of similar, but that's also kind of clunky.
21:33:31 <day> ive to say i was suprised when i figured out that i can plaster my 'where' statements with pattern guards :D
21:39:18 <dsal> day: So, to the other point, 'do' is only slightly magic.  `do print "5"`  is roughly the same as `print "5"`  i.e., that's not the problem you ran into.  If you break that into the three things you were trying to do, you can sort it out pretty easily, but separating the pure from the impure will just make it a ton easier.
21:40:35 <day__> dsal: oh im not doubting/ questioning your solution. im just curious as to if 'if/else' and pattern guards can easily replace one another without having to rewrite the surrounding code
21:41:54 <dsal> Well, no.  They do different things in different places.  If is an expression.
22:05:39 <white_magic> well it was good chatting with you folks! I'm off to sleep
23:54:44 <day> http://dpaste.com/1Z4MVEB are these repetitive case somehow mergeable into 'one' case?
23:55:49 <day> cases*
23:56:38 <ggole> You want or-patterns, but I don't think the proposal for those has got through yet
23:57:17 <Ailrun[m]> You can use a function in the where clause, or to really merge those cases you can use view patterns
23:57:29 <iqubic> day: Does that code compile?
23:57:32 <day> yes
23:57:36 <iqubic> Why?
23:57:42 <iqubic> Why does that compile?
23:57:52 <day> how should i know :D
23:58:04 <iqubic> I don't think the    "otherwise -> getInt" line should work.
23:58:12 <iqubic> Why does that line work>
23:58:23 <MarcelineVQ> because it's just a name  like foo or x
23:58:44 <day> ah wait
23:58:46 <MarcelineVQ> that is to say you're binding the name 'otherwise' right there
23:58:51 <day> i wanted to write Nothing :X
23:58:51 <iqubic> Oh. But isn't it variable shadowing?
23:58:54 <iqubic> :t otherwise
23:58:56 <lambdabot> Bool
23:59:03 <iqubic> @src otherwise
23:59:03 <lambdabot> otherwise = True
23:59:07 <Ailrun[m]> yes, it is shadowing.
23:59:09 <day> no idea how i came up with otherwise
23:59:58 <day> i'll go with '_'
