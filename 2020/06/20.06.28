00:06:12 <jusss> what Control.Arrow is used for?
00:11:07 <arahael2> I think I vaguely remember using that with HXT.
00:28:43 <Waldkauz> It also provides some useful functions like first, second etc.
00:42:55 <fog> some progress on the "named defunctionalization" aka "symbolic" approach
00:42:56 <fog> https://pastebin.com/raw/UnpvQpnE
00:43:15 <fog> now have bivariate version
01:06:34 <koz_> Arrowized FRP is also a thing.
03:46:06 <Cheery> Is there a way to fold the constraint list through aliasing, eg. (X a, Y a) => a down to Z a => a, where (X a, Y a) => Z a
03:47:50 <merijn> Cheery: With the ConstraintKinds extension you can use type aliases for constraints
03:48:16 <merijn> Cheery: So "type Foo a = (Eq a, Monoid a)" and then write "Foo a => a -> Bool" or whatever
04:01:20 <fog> https://gist.github.com/fog-hs/4f0b1c6f05bfaa9b7cb050751e84ec6d
04:01:33 <fog> hfoldable working
05:07:44 * hackage gi-atk 2.0.22 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.22 (inaki)
05:08:45 <hackage> ACTION gi-xlib 2.0.9, gi-wnck 3.0.8, gi-webkit2webextension 4.0.25, gi-webkit2 4.0.26, gi-vte 2.91.26, gi-soup 2.4.23, gi-secret 0.0.12, gi-poppler 0.18.23, gi-pangocairo 1.0.24, gi-pango 1.0.23, gi-ostree 1.0.13, gi-notify 0.7.22, gi-javascriptcore 4.0.22, gi-ibus 1.5.2, gi-harfbuzz 0.0.1, gi-handy 0.0.7, gi-gtksource 3.0.23, gi-gtk-hs 0.3.9, gi-gtk 3.0.34, gi-gstvideo 1.0.23, gi-gsttag 1.0.22, gi-gstpbutils 1.0.22, gi-gstbase 1.0.23, gi-gstaudio 1.0.
05:18:45 * hackage haskell-gi 0.24.0 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.24.0 (inaki)
05:19:45 * hackage haskell-gi-base 0.24.0 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.24.0 (inaki)
05:26:44 * hackage gi-gdk 4.0.2 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-4.0.2 (inaki)
05:27:03 <turion> Any recommendations where to look if I want to cabal build a package in a nix repl with a custom GHC?
05:27:45 * hackage gi-gtk 4.0.2, gi-gsk 4.0.2, gi-graphene 1.0.2, gi-gdkx11 4.0.2 (inaki)
06:19:44 * hackage cabal-rpm 2.0.6 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.6 (JensPetersen)
06:19:49 <maerwald> I wish there was a way for pseudo infix operators, eg.: action1 <|[DoesNotExistError]|> action2
06:20:57 <maerwald> or am I going nuts
06:22:29 <hseg> hi. has someone already written combinators converting between terms :: (forall n. proxy n -> t) and terms :: (forall n. t) ?
06:22:49 <hseg> am trying to bridge between apis using both styles
06:23:59 <hseg> and don't trust my implementation -- for one ghc seems to think my (forall n. t) type has redundant quantification, which is fair
06:24:36 <hseg> but writing (forall n. t n) would restrict me to only terms that have n in their last index
06:24:55 <hseg> which aren't the terms i'm working with
06:34:29 <hseg> more concretely, i have forAllNat :: (forall n proxy. proxy n -> t) -> t, int :: forall n f. (C f, KnownNat n) => I n f -> f, p :: (forall f. C f => i f -> f) -> Bool. I want to write sth like p (forAllNat (byProxy i)), but it's unclear to me how to write byProxy
06:34:58 <merijn> Clippy: "Hi! It looks like you're trying to write Dependent Types. Have you tried using Idris?"
06:35:04 <hseg> :)
06:35:43 <hseg> am lazy
06:35:44 <maerwald> it's in fashion
06:35:53 <hseg> want to use tools i know
06:44:15 <statusfailed> hseg: going from (forall n . t) to (forall n . proxy n -> t) is just const right?
06:45:05 <hseg> except t is supposed to capture n
06:45:14 <hseg> so this is more accurately (forall n. t n)
06:45:30 <hseg> except i want this to work for types of form t n a as well
06:46:53 <statusfailed> hseg: ah I see
06:47:15 <statusfailed> can't you just TypeApplication then? I guess i'm not sure if that works in general though
06:47:29 <hseg> which is why merijn is correct in noting i actually want dependent types
06:47:48 <statusfailed> hseg: you can get pretty far with plugins for GHC for Nat dependent types
06:48:15 <hseg> right, that's what i'm trying to achieve
06:48:24 <statusfailed> I've mostly used them for like arithmetic though, not exactly sure about this 
06:49:21 <hseg> yeah. this is more along the lines of param juggling
06:49:43 <hseg> arith is already handled and was another unholy mess
06:50:06 <hseg> especially cataKnownNat :: forall (n :: Nat) r . KnownNat n => ((n ~ 0) => r) -> ((1 <= n) => r) -> r
06:52:42 <statusfailed> hseg: is this type level induction basically? :D
06:53:34 <hseg> yep
06:54:15 <hseg> in particular, needed it to be able to show that xs `choose` d :: [Vector d a]
06:54:34 <hseg> which once you have the right combinators is pretty nice
06:54:47 <statusfailed> interesting, are you making a library? I could use some of this I think
06:54:54 <statusfailed> I wasn't quite smart enough to figure out how to do it :p
06:55:04 <hseg> :) irc helped me a lot here
06:55:15 <hseg> can break out some of this into some libraries
06:55:34 <statusfailed> don't do it on my account, but i'd be interested to see it if you do :)
06:55:42 <hseg> am planning on upstreaming my multivariate Laurent polynomial code to poly today anyway
06:56:20 <hseg> less technical burden for me, plus issue tracker says it was wanted
06:56:26 <statusfailed> "poly"?
06:56:33 <hseg> https://github.com/Bodigrim/poly
06:57:16 <hseg> pity i'm only doing this several months into the project, but it's a learning experience
06:57:29 <statusfailed> ha, this is basically the same as my use case
06:57:35 <hseg> oh?
06:57:43 <statusfailed> except I specialised to modules over polynomials over z2
06:58:03 <hseg> error correction codes?
06:58:09 <statusfailed> no, circuits! :)
06:58:16 <hseg> interesting
06:58:34 <hseg> i'm implementing Weyl integration for the classical Lie groups
06:59:06 <hseg> which if you're dealing with nice enough functions just consists of taking the constant term of a hairy Laurent polynomial
06:59:16 <statusfailed> gonna have to do some reading before I know what either of those three keywords mean
06:59:19 <statusfailed> hahah
06:59:43 <hseg> using this to compute eg expected values of products of traces over orthogonal matrices
06:59:54 <hseg> (and other types of matrices)
06:59:56 <statusfailed> this sounds a bit like probabilistic programming?
07:00:07 <statusfailed> or at least stochastic matrix stuff?
07:00:42 <hseg> not really -- there's a formula for the probability density
07:00:49 <hseg> and i'm integrating against that
07:01:05 <hseg> except since all my functions are periodic, i can skip the whole "integration" part
07:01:16 <hseg> and just keep the non-periodic terms
07:01:38 <hseg> which in case of polynomials in e^{it} are just the constant terms
07:02:47 <hseg> returning to my original code, it seems ghc's complaint that the foralls are redundant is bogus
07:02:56 <statusfailed> I think it sounds cool, but I am too much of a noob to follow ^^
07:03:09 <hseg> heh. this is for my master's thesis, don't worry
07:03:53 <hseg> but so i'm basically using dependent types to make sure i'm passing around the right number of variables in my integral
07:05:50 <hseg> so eg an orthogonal matrix must have eigenvalues +-1 (depending on degree+determinant), so i have some type-level code breaking down cases and removing 0,1,2 variables from the integrand (since those are fixed by the very fact my matrix is orthogonal)
07:06:04 <kuribas> Is there a way in servant to put parameters in a record, instead of Maybe this -> Maybe that etc...
07:06:06 <kuribas> ?
07:06:22 <kuribas> I have a fucntion: Token -> Maybe AlarmState -> Maybe ObjectRef -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe UTCTime -> Maybe UTCTime -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Text -> Maybe Text -> Bool -> Maybe (SortParam Intervention) -> Maybe Int -> ClientM (Enveloped Intervention)
07:06:29 <kuribas> so easy to get an argument wrong
07:08:00 <kuribas> maybe I need to write a type RecordQueryParams which translates record fields to parameters?
07:09:02 <kuribas> using generic magic?
07:12:43 <kuribas> So instead I'll make a record InterventionParams = InterventionParams { state :: AlarmState, container :: ObjectRef, cause :: Text, ..}
07:13:57 <kuribas> then some generic  magic that maps the parameters to the record fields.
07:18:17 <kuribas> maybe better, something that uses this: https://hackage.haskell.org/package/named-0.3.0.1/docs/Named.html
07:20:29 <statusfailed> hseg: probably would need more background to understand the matrix stuff :)
07:23:42 <hseg> :) the matrix stuff is just context, at the end of the day am basically integrating polynomials in e^{it_k} over products of circles
07:24:38 <hseg> the matrix stuff adds a little complication (basically, multiplies the integrand by a polynomial + composes the integrand by several polynomials)
07:24:45 <hseg> but nothing much beyond that
07:46:44 * hackage shakebook 0.7.3.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.7.3.0 (locallycompact)
07:53:56 <frdg> when I import a library using my .cabal files build-depends, are the libraries installed into my system?
07:57:36 <hexagoxel> frdg: for recent cabal versions and stack, the libraries are installed into a user-local "store" that is user-global.
07:58:01 <hexagoxel> (different build-tools use different store locations)
07:59:02 <frdg> hexagoxel: Thanks. found them
08:02:14 <hexagoxel> (rah my terminology is confusing. user-local as in local-to-the-user and user-global as in "shared across projects as long as you are using the same $HOME..)
08:08:50 <kuribas> is there a way to detect if two values have the same constructor?
08:09:37 <kuribas> for example MySum = Val1 Text | Val2 Int; sameCons (Val1 "foo") (Val1 "bar") == True, sameCons (Val1 "foo") (Val2 42) == False
08:10:46 <maerwald> isn't that already the solution
08:11:44 <kuribas> sameCons isn't defined here
08:12:00 <kuribas> I'd like to define in generically...
08:12:08 <kuribas> or better use a library that does that
08:12:10 <dminuoso> kuribas: Generics
08:12:50 <dminuoso> kuribas: Or, you can use toConstr
08:12:53 <dminuoso> % :t toConstr
08:12:53 <yahb> dminuoso: Data a => a -> Constr
08:13:06 <kuribas> dminuoso: neat :) where does that come from?
08:13:22 <dminuoso> Data.Data
08:13:25 <dminuoso> data D = X Int | Y Int Int deriving (Data,Typeable)
08:13:28 <dminuoso> % data D = X Int | Y Int Int deriving (Data,Typeable)
08:13:28 <yahb> dminuoso: 
08:13:41 <dminuoso> % toConstr (X 42)
08:13:42 <yahb> dminuoso: X
08:14:40 <kuribas> hmm, a generic solution specifically tailored to my problem my be even better
08:16:45 <dmwit> Generics seems like a pretty big hammer.
08:17:12 <kuribas> my actual problem is defining filters for a servant API
08:18:38 <kuribas> like data instance Filter Person = PersonFilter_Male | PersonFilter_Age Int
08:19:21 <kuribas> these are query parameters, and can be multivalued
08:19:32 <kuribas> then I want to collect the multiple values
08:19:53 <kuribas> for example filter=male&filter=age:20&filter=age:21
08:20:20 <kuribas> then get male = True  age=[20, 21]
08:21:50 <dminuoso> Sounds to be like writing a bit of boilerplate by hand beats a generic solution.
08:22:14 <kuribas> dminuoso: but we have filters for many endpoints
08:22:38 <dminuoso> And your filtering would be done on existing haskell structures?
08:22:50 <dminuoso> Do you not have some kind of database to offload this to?
08:23:18 <kuribas> dminuoso: yes it goes to the database
08:23:26 <kuribas> but first I must know the filters from the API
08:24:51 <kuribas> otherwise the filters could be dependend pairs
08:28:33 <kuribas> easiest is of course list comprehensions
08:29:31 <kuribas> the I'll do male = and [True | FilterMale <- filters]
08:29:46 <kuribas> age = [age | FilterAge age <- filters]
08:29:57 <kuribas> but it's not very efficient
08:32:57 <kuribas> I guess it's fine as long as the number of filters stays small...
08:35:36 <dminuoso> kuribas: You could use a trick with some `data Filters = Filters { filterAge :: Maybe Int; filerMale :: Maybe (); }`, and then traverse over the arguments with in a StateT.
08:36:16 <kuribas> dminuoso: but then how do I make it into a servant queryParam?
08:36:46 <kuribas> dminuoso: ah I see now, you make it some kind of monoid?
08:38:09 <kuribas> so the query parameter would be of type Endo Filters?
08:38:20 <dminuoso> Could do that as well, its up to you.
08:39:51 <kuribas> that would work well with the server, but not with the client
08:40:04 <kuribas> because the client expects it to become a single query parameter
08:41:15 <maerwald> tasty does not have `shouldThrow`?
08:44:50 <kuribas> I think the list comprehension is the simplest way
08:45:40 <kuribas> it's meant to showcase haskell to non haskellers, so something overly complex is going to have the opposite effect...
08:47:14 * hackage openweathermap 0.2.0 - Access data at OpenWeatherMap  https://hackage.haskell.org/package/openweathermap-0.2.0 (ip1981)
08:49:20 <kuribas> the goal is to show how nic haskell is, not that you need complicated stuff to do simple things
08:49:24 <kuribas> nice
08:52:12 <maerwald> you don't? :p
08:53:39 <kuribas> don't what?
08:54:51 <maerwald> need complicated stuff to do simple things
08:55:47 <kuribas> indeed.  But some things get harder when you want type safety
08:56:45 <maerwald> tasty looks like it's missing basic functionality to me, or I'm unable to find it
08:57:50 <kuribas> maerwald: I already got some comment on how haskell is "too sofisticated"
08:58:53 <maerwald> most ppl stick with haskell due to stockholms or time over-commitment :p
08:59:06 <maerwald> at some point, it's too painful to go back :p
08:59:59 <kuribas> no, I liked it most of the time.
09:00:14 <merijn> maerwald: What kinda basic functionality?
09:00:24 <maerwald> merijn: shouldThrow
09:00:46 <kuribas> and I found it usually enlightening when solutions exist when I am stuck
09:01:02 <kuribas> while in other languages you eventually resign
09:01:14 <dminuoso> shouldThrow does not sound like it belongs to tasty
09:01:26 <maerwald> yes, it's an hunit function
09:01:29 <merijn> maerwald: Note that tasty is *just* for orchestrating tests, shouldThrow sounds like something you'd have in hunit
09:01:32 <maerwald> hspec
09:01:40 <doyougnu> maerwald: I thought shouldThrow was provided by tasty-expected-failure?
09:01:40 <merijn> maerwald: Right, so you probably want tasty-hunit? :p
09:01:47 <maerwald> merijn: tasty does not use hspec
09:01:49 <doyougnu> never used it tho
09:01:55 <maerwald> I am using tasty-hunig
09:02:07 <maerwald> https://hackage.haskell.org/package/tasty-hunit-0.10.0.2/docs/Test-Tasty-HUnit.html
09:02:15 <maerwald> if it's not there, then where
09:02:36 <maerwald> and there it is not
09:02:52 <dminuoso> Surely you can just catch yourself and write up the assertion.
09:02:55 <merijn> hmm, I think I wrote my own and then forgot to PR it to hunit :)
09:03:53 <doyougnu> ah nevermind, tasty-expected-failure is exactly what is says it is and not exception handling
09:03:57 <maerwald> dminuoso: I can write my own testing framework too :)
09:04:04 <maerwald> the point is not doing that
09:04:33 <dminuoso> maerwald: Such a thing would be a one-liner. Haskellers have a weird tendency to complain that some "I know how to compose these two functions together, why is there no binding for it"
09:04:51 <merijn> maerwald: Well, copy mine and make a PR for hunit? :p
09:05:01 <merijn> https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-tests/BroadcastChan/Test.hs#L74-L83
09:07:14 * hackage rhine-gloss 0.7.0 - Gloss backend for Rhine  https://hackage.haskell.org/package/rhine-gloss-0.7.0 (turion)
09:07:27 <maerwald> dminuoso: not really
09:07:38 <kuribas> I am really missing a newtype over Maybe in Aeson which says, don't include this in the JSON.
09:07:56 <dminuoso> kuribas: If you use the generics, there's a configurable option for it.
09:08:07 <kuribas> dminuoso: but that applies to Maybe
09:08:07 <dminuoso> Or better yet, just dont rely on the generics. :)
09:08:14 * hackage rhine 0.7.0 - Functional Reactive Programming with type-level clocks  https://hackage.haskell.org/package/rhine-0.7.0 (turion)
09:08:22 <kuribas> dminuoso: generics are great.
09:08:36 <dminuoso> I dont think they're a great fit for FromJSON/ToJSON
09:08:46 <kuribas> dminuoso: serialising a large number of fields is tedious and error prone.
09:09:01 <merijn> dminuoso: FromJSON/ToJSON are a mistake anyway
09:09:13 <dminuoso> kuribas: It's just as error prone when you're doing implicitly via an ADT, seriously.
09:09:27 <dminuoso> kuribas: The only difference is, you're tightly coupling wire format to your ADTs.
09:09:43 <merijn> Typeclasses for (de)serialisation is a terrible idea and you shouldn't do it, mark my words.
09:09:47 <dminuoso> You either have to decouple via *another* ADT, but then *nothing* is won because you have to do that "serialize the format into another" *still(
09:09:49 <dminuoso> merijn: Indeed.
09:09:58 <dminuoso> merijn: Every time I unpack binary, Im annoyed by it.
09:10:08 <merijn> dminuoso: You can use binary without the typeclas
09:10:12 <dminuoso> I know :)
09:10:21 <dminuoso> I use aeson, postgresql-simple and binary all without typeclasses
09:10:22 <merijn> Which is, in fact, the *only* way I'd recommend using binary
09:10:37 <kuribas> dminuoso: won't work with servant
09:10:41 <dminuoso> kuribas: sure it does.
09:10:47 <kuribas> it *requires* ToJSON instancse
09:10:51 <dminuoso> kuribas: So?
09:10:57 <kuribas> so I need one?
09:10:58 <maerwald> merijn: I've tried using waargonaut, but API was inaccessible... it doesn't use type classes though
09:10:58 <dminuoso> kuribas: Tying it to a single newtype is fine.
09:11:11 <dminuoso> kuribas: Because you dont usually expose that. The problem is when you're composing it all from instances.
09:11:18 <dminuoso> But you dont have to do that
09:11:43 <merijn> maerwald: I don't actually use JSON, so I don't really have an opinion on JSON libraries
09:13:14 * hackage haskell-gi 0.24.1 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.24.1 (inaki)
09:14:15 * hackage gi-vte 2.91.27 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.27 (inaki)
09:14:19 <maerwald> merijn: http://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#v:shouldThrow 
09:14:24 <kuribas> dminuoso: these types are basically the interface.  
09:14:25 <maerwald> the selector trick is nice
09:14:38 <kuribas> dminuoso: we get the information form the db, then pass them on.
09:15:13 <maerwald> shuold do a predicate too instead of ==
09:15:51 <kuribas> dminuoso: so you would make a newtype over all the types to handle serialization?
09:16:17 <dminuoso> kuribas: Put it this way. If you have some `data` type, I dont mind a single ToJSON instance for the sole reason that servant can latch onto that.
09:16:35 <kuribas> merijn: I dislike the typeclasses for binary, but it's ok for Aeson IMO.
09:16:59 <dminuoso> kuribas: But to implement that ToJSON intsance, I would not use any other instances (unless there was a canonical instance I could rely on, say `instance ToJSON Int`.
09:17:24 <kuribas> dminuoso: but that would ensure consistency, no?
09:17:34 <dminuoso> What would ensure consistency?
09:18:15 * hackage tldr 0.7.0 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.7.0 (psibi)
09:20:36 <kuribas> dminuoso: using the ToJSON instance for nested types?
09:20:48 <dminuoso> kuribas: What does it buy you?
09:21:04 <dminuoso> Fundamentally, what benefit do you get from it?
09:21:31 <kuribas> well convenience mostly I suppose
09:21:37 <dminuoso> What convenience?
09:21:51 <dminuoso> `instance ToJSON Foo where toJSON = ...`
09:21:52 <kuribas> I can make a Ref type, then use that everywhere for references.
09:21:54 <dminuoso> fooToJSON = ....
09:21:59 <dminuoso> What convenince did you buy?
09:22:06 <kuribas> since these need to be consistent in the API
09:22:06 <dminuoso> Except make it really hard to read, since you have to juggle types in your head.
09:22:22 <dminuoso> fooToJSON is easily detectable by simple editors.
09:22:26 <dminuoso> `toJSON` is not.
09:22:48 <kuribas> I search for ToJSON Foo
09:22:53 <dminuoso> With `toJSON` its *not* obvious whats being called, unless you do the whole typeclass resolution process in your head
09:22:58 <dminuoso> How do you know its really a Foo?
09:23:07 <dminuoso> And how do you know which instance is selected?
09:23:32 <kuribas> because my instances are simple
09:23:49 <kuribas> not like ToJSON [Maybe Person]
09:23:55 <kuribas> but just ToJSON Person
09:24:10 <dminuoso> kuribas: My point is, it requires context awareness. for `toJSON v` you need to know that v :: Foo, it might not even be obvious.
09:24:16 <dminuoso> It could even be wrong!
09:24:21 <dminuoso> It would just happily compile regardless.
09:24:39 <dminuoso> If you start sprinkling everything with toJSON, then you'll have more code that is readily accepted.
09:24:51 <dminuoso> With `fooToJSON` it's failing to typecheck instantly.
09:24:58 <dminuoso> `toJSON` is not followable by most editors
09:25:02 <dminuoso> `fooToJSON` is.
09:25:21 <kuribas> ah, you mean in handwritten instances
09:25:31 <dminuoso> handwritten functions.
09:25:55 <kuribas> maybe hie can do that?
09:26:18 <dminuoso> If it takes hie to follow your code, there's something wrong with it.
09:27:03 <kuribas> dminuoso: well, I agree that rely to much on inference is a code smell
09:27:06 <kuribas> in general
09:27:07 <dminuoso> Also there's the fact that with ToJSON, you can make a mistake and it will most likely still compile, because any Value is admissable - and toJSON will happily produce a value out of anything it has an instance for.
09:27:45 <kuribas> you can use type applications
09:28:03 <kuribas> but indeed, that smells
09:28:03 <dminuoso> You can forget it.
09:28:18 <kuribas> in the context of servant it's usefull though...
09:28:29 <dminuoso> kuribas: as an entry to latch onto, sure, but beyond that, no.
09:30:16 <kuribas> ok, I see your point
09:30:43 <kuribas> and generics ties it to the wire format, but in the servant case that's the point.
09:30:56 <kuribas> to have the API as some sort of specification
09:31:18 <dminuoso> I think in case of servant it's done, because there's no other immediately easy way to feed the parser in
09:31:24 <dminuoso> Unless you did it via Context or equivalent
09:31:29 <dminuoso> But the ergonomics of that is annoying
09:32:28 <dminuoso> (And Context is only available to -server currently)
09:38:29 <maralorn> dminuoso: Aren‘t you making a more general case against typeclasses?
09:38:31 <maralorn> I mean stuff like the Monad typeclass für (a ->) can also lead to mean errors.
09:39:16 <dminuoso> maralorn: If you use monadic code in the wrong context, it very likely will produce errors quickly somewhere.
09:39:23 <dminuoso> They might not be obvious, but they will be there.
09:41:23 <maralorn> dminuoso: Yeah. But on the other hand typeclasses are very useful sometimes, right? Do you have a crisp heuristic when to use then and when not?
09:42:34 <dminuoso> That's a tough one. No I don't have a crisp heuristic.
09:42:50 <dminuoso> For code you're writing it's relatively simple, I'd say try not writing typeclasses at all.
09:43:47 <dminuoso> Some people prefer typeclasses for things that have lawful behavior, e.g. like Functor where you have `fmap id = id`
09:51:30 <dminuoso> merijn: What's your stance on Pretty then?
09:52:05 <dminuoso> I found that Pretty is great for primitives like Text or Int, but overall I tend to cook up a lot of `pprXXX` functions in my code for anything that doesn't have a clear canonical representation.
09:57:08 <merijn> maralorn: The difference is that monad instance can't change, they're fixed by laws and "what's sensible"
09:57:19 <merijn> maralorn: (de)serialisation formats change all the time
09:57:21 <rsoeldner> Hi, I struggle to use the `xmlsec` system library under nixos together with cabal. I'm able to compile the project from a hand generated nix shell (including cabal) https://gist.github.com/rsoeldner/b12444077223fbc7aa6958de38383501 but it fails from `cabal2nix` shell. The problem seems to be the `pkgconfig-depends: xmlsec1-openssl` is installed by the nix package `xmlsec`. Has someone encountered such an issue before ?
09:57:58 <merijn> maralorn: Tying your serialisation to a class means you can only ever have one single serialisation format for a datatype, which makes backwards compat super annoying/hard to deal with
10:02:30 <dminuoso> Well you can go through newtypes..
10:02:39 <dminuoso> But that's more a workaround than a solution.
10:23:40 <monochrom> Solution: class VersionedSerializer t (n :: Nat) where ...  use type-level number n to indicate version >:)
10:24:13 <monochrom> "think outside single-param type class" >:)
10:28:01 <monochrom> More seriously, my http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/05-haskell-types-2.html#why has traits of good and bad classes.
10:34:10 <maralorn> merijn: Yeah, I totally understand why you don‘t like ToJSON instances.
10:34:24 <maralorn> So in the end it‘s something like: Only implement typeclass when they are dead obvious?
10:35:00 <maralorn> monochrom: Cool, thx.
10:37:00 <monochrom> ToJSON is based on an unusual reason: It is how you plug your code into their framework.
10:42:02 <maralorn> What about typeclasses for lenses? I am pondering the idea that HasField a f | a -> f where _fielda :: Lens a f. might be nice. But it kinda fails those criteria …
10:43:11 <monochrom> Mine are not mathematical definitions. They are tendencies.
10:44:07 <monochrom> HasField was conceived in lieu of row polymorphism.
10:46:02 <monochrom> still, it satisfies informal expectations about projection or slicing or what you call it
10:47:45 <maralorn> monochrom: I am not sure, if you mean that, but I am not trying to point fingers and say: What you said fails in this special case. I am honestly curious if I can learn something about those situations, because I am really struggling in real life code with how to generate my lenses.
10:48:57 <monochrom> I know.
10:59:45 * hackage rescue 0.2.0 - More understandable exceptions  https://hackage.haskell.org/package/rescue-0.2.0 (expede)
11:09:27 <merijn> maralorn: I'm a bad person to ask, because I'm a luddite and rarely use lenses :p
11:09:36 <dminuoso> maralorn: From what I can tell, classy lenses are fine.
11:10:33 <dminuoso> Consider this: For non-trivial choices of B, chances are there aren't many overlapping choices for `Lens' A B`
11:11:10 <dminuoso> You wouldn't default to class lenses either, but only if there's some very deep levels of nesting and you're handling data at any level of that nesting, but repeatedly need access to the same "deeply nested data"
11:11:11 <merijn> dminuoso: I have a record with 6 different "Double" fields, so that' 6 overlapping "Lens' A Double" right there ;)
11:11:20 <dminuoso> merijn: Non-trivial choices of B.
11:11:29 <dminuoso> It's mostly demand driven anyway.
11:11:46 <dminuoso> If you have a common theme of "I always need Foo", then HasFoo is not bad.
11:13:52 <dminuoso> The major difference wrt to say ToJSON, is that ToJSON doesnt improve ergonomics bsaed on fact of being typeclass based.
11:13:56 <dminuoso> But classy lenses do.
11:26:38 <Cheery> http://boxbase.org/entries/2020/jun/29/hierarchical-free-monads-criticism/
11:28:55 <slack1256> https://pastebin.com/whJk5FkV
11:29:28 <slack1256> If a Async value goes out of scope, is the Async cancelled before so?
11:29:29 <Cale> dmiles: I think ToJSON improves ergonomics, but the fact that Aeson isn't designed in a way that treats the classes as optional is kind of the awkward thing.
11:30:14 <Cale> Like, you want a good combinator library for defining how things are converted to/from JSON, and then once you have that, introducing classes to say "here's a default way" is going to be pretty convenient.
11:30:15 <slack1256> On that pastebin `staticPipeline` blocks, but if I uncomment the `waitAnyCancel` it runs correctly.
11:30:44 * hackage headroom 0.3.0.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.3.0.0 (xwinus)
11:31:22 <solonarv> slack1256: no, it's not cancelled if it goes out of scope
11:31:48 <slack1256> solonarv: Thanks for confirming my intuition.
11:32:10 <Cale> uhhh
11:32:14 <solonarv> you can check this with something like 'main = do async (forever $ do putStrLn "still running;  threadDelay 10000); threadDelay 1000000
11:32:33 <MarcelineVQ> Cheery: "You might have heard that the biggest thing haskellers value is ..." what I want to know is who says any of those things? where are these people? I see assertions about haskellers say x and haskellers think x and haskellers think you are x, but I don't see haskellers saying thus
11:33:27 <Cale> Interesting, I seem to vaguely recall asyncs being killed automatically when the Async value they returned was GCed.
11:33:56 <solonarv> let me jsut check the source
11:33:58 <Cale> But my recollection of that is hazy at best, and I don't often use async
11:33:58 <kuribas> especially "Haskellers claim their programs are without bugs"
11:34:06 <MarcelineVQ> gosh and this article isn't even old :( Who is out there propgating these attitudes, is it self-generating, I heard someone say x so x is true, so I'll say​ I heard someone say x, so x is true
11:34:25 <slack1256> Cale: That would explain what I am seeing but the eventlog doesn't report killed threads.
11:34:28 <dminuoso> slack1256: what does it mean for "something to go out of scope" in Haskell?
11:34:35 <dminuoso> There's no semantics for it.
11:34:55 <dminuoso> We dont have variable lifetime tied to scope, say like you might have in C++.
11:35:07 <slack1256> Reachable by the GC?
11:35:09 <Cale> Well, we kind of do have a notion of that, there's a garbage collector
11:35:36 <dminuoso> Can you tie resource freeing semantics into GC cleanup?
11:35:38 <Cale> and for example, if something is blocked on an MVar, and the MVar is collected, an exception is thrown
11:35:42 <solonarv> dminuoso: sure you can
11:35:48 <slack1256> Yes, there are weak finalizers
11:35:52 <dminuoso> oh.
11:36:00 <solonarv> async has nothing of the sort though (I just checked)
11:36:18 <slack1256> (I just know because the eventlog told me, I am using pipes-concurrent on another part of the project).
11:36:29 <MarcelineVQ> Cheery: "haskellers see their language as something special ... this is not true ... haskell is kinda unique"  www
11:38:22 <Cheery> MarcelineVQ: yeah. I was annoyed as well.
11:38:22 <MarcelineVQ> "... it's no way different in the design space" that must be why people pick it up so easily.   though which design space is meant I wonder.
11:38:55 <solonarv> you could of course do something like 'forkCancel doFork inner = do tid <- doFork inner; mkWeak tid () (killThread tid); pure tid'
11:39:20 <solonarv> and then 'asyncUsing (forkCancel forkIO)' or something similar
11:39:52 <Cale> I see my quote in there, haha
11:40:28 <MarcelineVQ> Would someone use my dismissive criticisms of this article's quotes to show proof of the ivory snob attitude of 'haskellers' I wonder
11:40:58 <Cale> It would have been good to include names
11:41:14 <Cale> Especially as these quotes are not all from the same source
11:41:34 <slack1256> I need to go fix the sink -.-
11:43:59 <Cheery> Cale: I can name you if you want that.
11:44:10 <Cale> Well, don't *just* name me
11:44:14 <Cale> lol
11:44:55 <kuribas> I do cabal new-build, which suceeds
11:45:11 <kuribas> then cabal new-install --lib, which gives Could not resolve dependencies
11:45:28 <kuribas> I want to install my library so I can use it in other projects
11:45:54 <kuribas> with old cabal this was just cabal install
11:47:23 <sm[m]> v2 install is kind of broken UX wise I think
11:47:42 <MarcelineVQ> Cheery: I do welcome yet another approach to software design in haskell, may the best beast win for everyone's sake, but yeah it's not a great starting point they've made themselves. Buries the lead
11:48:41 <Cheery> Cale: 2 quotes outside of the article I reviewed.. I'll put in -- Cale, and -- Wadler to those.
11:49:38 <Cale> Although the rest of the world may not have a name for it, and "expression problem" is not a particularly obvious name for what it is, I'd argue that problem is a foundational one which has inspired many different approaches to programming, which approach it with different tradeoffs.
11:49:54 <Cale> Not just in functional programming, but everywhere
11:52:05 <Cale> You always have this tension between making it easy to extend your program to deal with more kinds of things on the one hand, and making it easy to extend what operations can be done with those things on the other.
11:52:49 <monochrom> kuribas: with new cabal it's still present, v1-install, they just keep scaring you about "it may disappear one day"
11:53:15 <kuribas> monochrom: what is the recommended way to build a local package?
11:53:23 <kuribas> that I don't want on hackage
11:53:48 <sclv>  kuribas you can add it using a cabal.project as a local dep
11:54:04 <sclv> or vendor it, same way, or even point to a repo iirc
11:54:07 <kuribas> ok, so I have an executable sqa, but cabal claims "it is not in this project"
11:54:14 <Cale> Object oriented programming's approach is to fix the operations that can be done on a piece of data, and thereby allowing for more cases easily (so long as they implement the operations), but at a cost that if you want a new fundamental operation (method/message), you'll have to go back and implement it for all the existing objects.
11:54:51 <monochrom> kuribas: https://cabal.readthedocs.io/en/stable/nix-local-build.html#specifying-the-local-packages
11:56:12 <monochrom> You can put it in cabal.project or cabal.project.local, I don't know which one is more right, it depends. But note that "cabal configure" will reset cabal.project.local (but backups the old one as cabal.project.local.somethingIforgot)
11:56:20 <Cale> Algebraic data types (especially sum types) in a way make the opposite tradeoff: determine all the cases up front, and it's "easy" to write new operations which account for all the possibilities, but add a case later and you have to update all the operations
11:58:05 <Cale> There are a whole bunch of ways of decoupling these things, so that you can piecemeal extend the grid of cases vs. operations, and no single best way without being able to predict the future of the piece of software that you're writing.
11:58:43 <Cheery> but you can move from algebraic type representation to an another.
11:59:26 <Cale> You can, but usually that's going to involve a fairly extensive refactoring, if you assume you have a large codebase that relies on that representation.
11:59:38 <monochrom> Ha! I just thought of a sacrilegeous analogy.  cabal v1 : malloc :: cabal v2 : OOP abstract factory.  CHANGE MY MIND
12:00:07 <Cale> monochrom: I'm not sure I understand the difference between v1 and v2 of cabal well enough to get that :)
12:01:03 <Cale> Cheery: But yeah, the fact that we have a compiler that can successfully warn us when our case expressions are missing cases and such does make that a reasonable way to make the tradeoff quite a lot
12:01:42 <Cale> Cheery: Sometimes you end up with so many cases though, that it becomes too awkward to write the case expressions, and you end up with fewer case expressions in your entire application than there are constructors of the type.
12:01:59 <Cale> If that's the case, then transposing into a more "OO" kind of style might be better
12:02:34 <Cale> You can replace your sum type with a product of the conclusions of your case expressions
12:02:37 <dminuoso> monochrom: I think as long as nix remains, v1- will stick around. :)
12:02:47 <monochrom> \∩/
12:03:16 <monochrom> Err no. They only need to support "runghc Setup.hs" for that.
12:03:31 <kuribas> "cabal: No targets given and there is no package in the current directory."
12:03:35 <Cale> Yeah, nix doesn't actually run cabal-install
12:03:43 <kuribas> there is a myproject.cabal in that directory
12:03:51 <Cale> It uses Cabal-the-library via Setup.hs
12:04:20 <dminuoso> Mmm, what's the Setup.hs for anyway?
12:05:23 <Athas> Setup.hs is partially from a primordial time before the CLI cabal-install, and partially when you want to customise the build.
12:05:26 <sm[m]> more cabal folk wisdom (I learned yesterday): cabal.project.local doesn't work unless you have a cabal.project
12:05:29 <monochrom> Suppose you are a package builder working for nix or ubuntu or so. Then you run Setup.hs rather than cabal-install.
12:05:56 <monochrom> You also do your own dependency chasing and curating, you don't rely on automatic "cabal install --dependencies-only"
12:05:57 <Cale> Yeah, initially, cabal-install didn't exist, and people wrote installers using Cabal-the-library. Setup.hs is essentially exactly that.
12:06:00 <dminuoso> Hold on, if running setup.hs is enough anyway, what do I need cabal-install for exactly?
12:06:05 <Cale> You don't.
12:06:16 <Cale> Cabal-install is a convenience tool
12:06:17 <monochrom> automatic dependency chasing
12:06:19 <sclv> setup manages building a single package
12:06:21 <sm[m]> cabal-install will install deps
12:06:26 <Cale> Right
12:06:42 <monochrom> Would you prefer manual dependency chasing? :)
12:06:51 <dminuoso> Ah, so cabal-install v1 will just generate a build plan, fetch those packages, and then do the equivalent of running Setup.hs [build/install] on each of them?
12:06:57 <Cale> Maybe you would, if you're writing a nix expression anyway :)
12:07:02 <monochrom> yes
12:07:20 <sclv> and also with v2 install them into a special nix-like store so they are auto-sandboxed
12:07:22 <sm[m]> isn't it really time to drop all mention of v1-/new-/v2-, btw ? Things are confusing..
12:07:40 <slack1256> I thought cabal-install 3.0.0 would do that.
12:07:46 <sm[m]> also "nix-style"
12:07:47 <dminuoso> slack1256: that just defaults commands to v2
12:07:56 <kuribas> cabal new-build doesn't build an executable?
12:07:59 <monochrom> I agree with dropping "new-".
12:08:09 <monochrom> v1 and v2 still both exist.
12:08:11 <sclv> oh it can build exes too
12:08:24 <sm[m]> cabal user guide says nix-style builds have been supported since cabal 1.24. (But I don't think that's right)
12:08:38 <monochrom> I agree with dropping "nix-style". It is vulnerable to misinterpretation. Stupid humans.
12:09:01 <sclv> no that's roughly right, but v1- commands were the default commands then and only with cabal-install 3.0 did v2 commands become default
12:10:18 <dminuoso> Does cabal-install use the Setup.hs script as well?
12:10:24 <kuribas> isn't there an easy to read guide to using cabal new-stuff?
12:10:36 <monochrom> On condition "build-type: something not Simple"
12:10:49 <dminuoso> kuribas: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
12:11:32 <dminuoso> kuribas: tl;dr do as you did with v1-, except know that every build is essentially "sandboxed" with no packages being installed globally (at least semantically).
12:11:37 <sm[m]> yes but be warned there is much outdated here. Maybe not in this chapter.
12:11:43 <MarcelineVQ> Cheery: "there is no value in composition itself" I'm a bit baffled that a person can write software and have this opinion? :/
12:12:05 <monochrom> which is "build-type: Custom"
12:12:07 <MarcelineVQ> s/?//
12:12:12 <maerwald> dminuoso: the other way around, all packages are installed globally
12:12:18 <kuribas> dminuoso: I tried but I am stuck...  Because I need to refer to a local package.
12:12:34 <dminuoso> kuribas: Put it into the local directory, specify the package in your cabal project files
12:12:56 <kuribas> any directory?
12:13:14 <kuribas> so I need to hard code a path in the project file?  That's ugly
12:13:32 <monochrom> haha the cabal user guide does need a lot of fixing, and it is not just because v2 stuff.
12:13:36 <dminuoso> kuribas: You'd usually put it directly into your repository.
12:13:42 <sclv> kuribas: https://cabal.readthedocs.io/en/latest/cabal-project.html#cfg-field-packages
12:13:46 <sm[m]> kuribas: it can be a relative path. https://cabal.readthedocs.io/en/latest/cabal-project.html
12:13:58 <Cheery> MarcelineVQ: I picked it up to criticize technical things in it, but yeah.
12:14:12 <dminuoso> kuribas: Also know, that you can specify git refs as well, in case the package is up somewhere on git.
12:14:13 <Cheery> there were so many of those things.
12:14:19 <sm[m]> packages: . vendor/pkg1 vendor/pkg2  -- eg
12:14:31 <maerwald> dminuoso: the sandbox equivalent of v1 is `cabal --store-dir=$(pwd)/.store v2-install`
12:14:40 <monochrom> Err nevermind, misread
12:14:58 <dminuoso> monochrom: I take it your mention of build-type was in response to me?
12:15:03 <monochrom> yes
12:15:22 <monochrom> when build-type: Custom, cabal-install honours Setup.hs
12:15:29 <Cheery> there's an interesting thing to think about composition btw. Is there a reason why it's binary?
12:15:50 <Cheery> eg. two ends, you plug the ends and end up with two ends again.
12:16:25 <monochrom> the expectation is that under other build types, Setup.hs should be a 2-line boilerplate that does the same thing as cabal-install without Setup.hs
12:16:45 * hackage zephyr 0.3.2 - Zephyr, tree-shaking for the PureScript language  https://hackage.haskell.org/package/zephyr-0.3.2 (coot)
12:17:00 <koz_> :t concatMap
12:17:01 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
12:17:21 <dminuoso> Cheery: Well if you take it to the fundamentals, you'll observe that the one of the most general and broadest theme to analyze composing systems is category theory.
12:17:29 * slack1256 didn't know about concatMap
12:18:16 <dminuoso> Cheery: If not binary, what else should composition be?
12:18:42 <Cheery> dminuoso: yeah, but if you take one-ended structures, they don't compose, and three-ended structures composing become 4-ended structures
12:18:48 <dminuoso> Cheery: sure they do!
12:19:00 <dminuoso> Cheery: one-ended structures can compose just as fine.
12:19:13 <dminuoso> Cheery: The typeclass `Semigroup` captures it just fine.
12:19:14 <Cheery> well they become zero-ended structures
12:19:19 <dminuoso> % :t (<>)
12:19:19 <yahb> dminuoso: Semigroup a => a -> a -> a
12:19:37 <dminuoso> This is a very general "compose/combine/add" two things together.
12:21:40 <dminuoso> Cheery: There are other things similar to (->) that compose in the same fashion by the way.
12:22:18 <dminuoso> % :t (<=<)
12:22:18 <yahb> dminuoso: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
12:22:18 <Cheery> dminuoso: yup. there's few.
12:22:21 <dminuoso> % :t (.)
12:22:21 <yahb> dminuoso: (b -> c) -> (a -> b) -> a -> c
12:22:49 <dminuoso> monochrom: Maybe I should take a dive and understand what Cabal-the-library is doing then.
12:23:07 <dminuoso> Most of this Ive just taken for granted, and trained all the things to type into muscle memory
12:23:08 <kuribas> ok I put "packages: ../dependent-library/*.cabal" in cabal.project
12:23:17 <kuribas> but it still cannot find dependent-library
12:23:41 <dminuoso> kuribas: Where is dependent-library with respect to the cabal.project file?
12:24:15 <kuribas> dminuoso: in the parent directory
12:24:42 <Cheery> MarcelineVQ: I think if I did dig on my own posts, I'd find some similar things. Maybe it's really just something like first time doing things like that.
12:26:10 <sclv> you may need to reconfigure before you build
12:26:30 <sclv> and you can run with verbosity to see which directories are being searched
12:26:32 <sm[m]> oh is cabal configure still a thing ?
12:26:55 <sm[m]> I thought it was gone as of v2 build
12:27:02 <Cheery> I'd be interested about little bit of history of cabal. what's this v1,v2,v3?
12:27:05 <sm[m]> I mean, no longer needed
12:27:09 <maerwald> kuribas: works here
12:27:11 <sclv> well it now builds a new cabal.project.local iirc, so you may be right
12:27:22 <Cheery> it's probably written down somwehere.
12:27:23 <sclv> its just an old habit in my head of considering if reconfiguring is necessary
12:27:33 <dminuoso> Cheery: There's only v1 and v2. v1 was the old-style builds, which installed packages globally (which introduces problems if two of your projects depend on different versions or flags)
12:27:38 <sclv> also the dep still needs to be in the .cabal file itself
12:28:00 <kuribas> with -v: Resolving dependencies... CallStack (from HasCallStack): die', called at ./Distribution/Client/ProjectPlanning.hs:574:42 in main:Distribution.Client.ProjectPlanning 
12:28:05 <dminuoso> Cheery: The v2 does nix-style builds where packages are installed into a global store, but hashed such as to keep different versions and flags separate, and then they are sort of made "visible to your local project" depending on what you need.
12:28:09 <dminuoso> Thereby avoiding all conflicts.
12:28:10 <maerwald> both v1 and v2 install globally
12:28:29 <Cheery> wow
12:28:32 <sm[m]> "It is never necessary to use the 'configure' command. It is merely a convenience in cases where you do not want to specify flags to 'build' (and other commands) every time and yet do not want to alter the 'cabal.project' persistently."
12:28:40 <kuribas> maerwald: why cannot I install globally then?
12:28:50 <kuribas> maerwald: that was relatively easy in old-cabal
12:28:54 <dminuoso> Cheery: There's also old- and new-, which were just synonym prefixes for v1- and v2-
12:29:18 <dminuoso> Cheery: Starting from cabal-install 3.0.0.0, if you dont specify a prefix it defaults to v2- commands, and before it defaulted to v1- commands.
12:29:23 <sclv> kuribas: waht maerwald means i think is that it still goes into the nix store, which is a global store, even if only a fragment of the store is exposed
12:29:24 <maerwald> kuribas: what exactly do you mean?
12:29:42 <kuribas> ok, so you cannot really access the global store
12:29:46 <maerwald> you can
12:30:05 <Cheery> to access it you need to write a cabal file then?
12:30:05 <maerwald> via environment files, by telling the command you use
12:30:07 <sclv> the whole local/global thing is really imprecise, because even before sandboxing on v1 there was already "local" as in local-to-user vs "global" as in global-to-all-users on a multiuser system, etc
12:30:19 <Cheery> well, various ways then.
12:30:52 <Cheery> with nix-style builds do you even need local/global?
12:31:06 <sclv> they're all different ways of talking about similar stuff
12:31:31 <sclv> the "truly global" stuff is still around but that's like "the libs that ship with the compiler"
12:31:37 <maerwald> kuribas: https://www.haskell.org/cabal/users-guide/nix-local-build.html#cabal-v2-install
12:31:54 <maerwald> it explains a little about environment files there
12:31:58 <walla> on a scale on 1 to 10 how good of a language would you consider Haskell for writing parsers?
12:32:06 <Cheery> walla: 100
12:32:16 <Clint> 50
12:32:40 <slack1256> 50 but all the parser I am interested in writing already have libraries -.-
12:32:48 <walla> ok so very good 
12:32:49 <walla> thanks
12:32:57 <maerwald> kuribas: there is also https://github.com/phadej/cabal-extras/tree/master/cabal-env
12:32:58 <Cheery> walla: any more details?
12:33:23 <dminuoso> walla: it's a mix of bags, what kind of grammar do you have?
12:33:32 <dminuoso> And what kind of error reporting quality do you wish?
12:33:50 <dminuoso> Do you furthermore intend to do anything with the parsed data, or just parse into an AST and be done with it?
12:33:57 <maerwald> you can simulate v1 sandboxes still with the --store-dir argument to cabal
12:34:09 <maerwald> which is useful for CI
12:34:12 <sclv> on parsers, the "easy" place to start before you get anywhere fancy is "just use megaparsec"
12:34:26 <sclv> and if you want to handle binary data and wire protocols and the like "just use attoparsec"
12:34:36 <kuribas> cabal: Ambiguous target 'sqa-api'. It could be: SQA-API (component) pkg:SQA-API (package)
12:35:00 <sm[m]> incidentally, when using cabal.project it seems you must put at least one package on the the packages: line, is that right ? I wanted to put them one per line with a uniform small indent
12:35:02 <sclv> is this the result of specifying sqa-api on the command line?
12:35:14 <Cheery> dminuoso: I'd like error correcting parsers, but the problem seem to be it gets computationally complex fast.
12:35:29 <kuribas> sclv: cabal new-install --lib sqa-api
12:35:44 <sclv> try --lib lib:sqa-api
12:35:53 <maerwald> sm[m]: maybe... I still don't understand why we needed custom formats for all that :)
12:36:14 <Cheery> type directed error correction in a parser, would be pretty.
12:36:34 <kuribas> sclv: that fails with "could not resolve dependencies"
12:36:50 <sclv> well sounds like you better fix that
12:36:54 <kuribas> goals I've had most trouble fulfilling: binary, containers, ghc
12:36:56 <kuribas> wtf
12:37:08 <kuribas> sclv: what do you?  It builds just fine
12:37:21 <maerwald> sm[m]: cabal files are even worse and all tools mangling them have to break the formatting
12:37:23 <kuribas> sclv: with cabal new-build
12:37:28 <sclv> you may have a global ghc-env file that has a bunch of stuff that's incompatible
12:37:48 <sclv> so if you want to install this into that global ghc env you need to rip out that stuff first and start fresh
12:37:59 <sclv> but my advice is again, just get the way with the cabal.project file working
12:38:03 <sclv> that's the recommended way
12:38:20 <maerwald> sm[m]: toml is a bliss
12:38:27 <sm[m]> maerwald: .cabal files require a comma on all but one line (worse), but they do allow you to start the items on the following line (better)
12:38:35 <kuribas> sclv: no luck there
12:38:48 <sclv> literally play around with it, look at verbosity, try harder
12:38:49 <sclv> that's the right way
12:39:04 <sclv> one thing to do is keep the cabal.project file but also add a cabal.project.local file that specifies the packages
12:39:06 <sm[m]> so I'm kind of dealing with three config file formats here
12:39:07 <maerwald> sm[m]: all needless complexity
12:39:32 <sclv> also, you can just symlink or copy the dependency into a subdir of your project that uses it
12:39:43 <sclv> and then use the cabal.project with */*.cabal
12:40:02 <sclv> people have done this successfully forever
12:40:20 <sclv> if you run into a problem, try to understand and fix that problem, don't just go off and try other things that have other problems
12:41:25 <slack1256> That las one seems like a good general advice for life
12:42:11 <maerwald> sclv: for dependencies I recommend `optional-packages: */*.cabal` instead
12:42:38 <sm[m]> maerwald: argh.. what does that do differently ?
12:42:54 <sclv> doesn't fail if the glob matches nothing
12:42:55 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html?highlight=optional%20packages#cfg-field-optional-packages
12:43:03 <kuribas> sclv: The package location glob '*/*.cabal' does not match any files or directories
12:43:10 <sm[m]> sclv: oh, interesting
12:43:22 <sclv> kuribas is there something that should be matched by it?
12:43:25 <maerwald> sm[m]: that's the idea of vendoring
12:43:26 <sm[m]> like php require vs include :)
12:43:46 <kuribas> sclv: the local package I symlinked?
12:44:07 <sm[m]> maerwald: thanks
12:44:16 <sclv> ok so you're in dir foo, and there's a subdir foo/baz with foo/baz/baz.cabal a valid file?
12:44:32 <sclv> and cabal build in the directory foo is not finding it?
12:44:34 <kuribas> foo/deps/baz/baz.cabal
12:44:49 <sclv> ok well foo/deps/baz/baz.cabal won't match the glob you gave it, will it?
12:45:07 <maerwald> in fact, when there is no cabal.project file, you have an implicit default of `optional-packages: ./*/*.cabal`
12:45:27 <maerwald> (which will be gone in the next version)
12:45:30 <sclv> expand out the glob in your head and see if you can figure out the issue for yourself
12:47:06 <kuribas> sclv: well bash can expand the glob just fine
12:47:11 <kuribas> cabal is broken
12:47:45 <maerwald> I argue the problem is in front of the screen :p
12:47:49 <maerwald> it works here
12:47:49 <sm[m]> something's broken
12:48:33 <maerwald> push your stuff to a repo, no one can reproduce like that
12:48:39 <sclv> kuribas: ok so why would */*.cabal expand out to deps/baz/baz.cabal ?
12:48:41 <kuribas> maybe, but I don't see it, and cabal isn't giving meaningfull errors
12:48:43 <sclv> do you see the issue?
12:48:44 <kuribas> sclv: yes
12:48:58 <sclv> a single * won't expand to two directories
12:49:07 <kuribas> sclv: no, I have the right glob
12:49:13 <sclv> ok i'm done helping you goodbye
12:49:18 <kuribas> ./deps/*/*.cabal
12:49:28 <sclv> that wasn't what you pasted earlier
12:49:47 <kuribas> I have the right glob now
12:50:42 <sclv> ok, so that means things work, right?
12:50:54 <kuribas> nope
12:51:03 <kuribas> unknown package: sqa-api (dependency of sqa-server)
12:51:42 <maerwald> I don't believe anything until I see the repo
12:52:19 <kuribas> maerwald: it's not open source code
12:52:50 <maerwald> kuribas: you can push proprietary code too
12:53:40 <sclv> ok and the file that your glob matches is literally named sqa-api.cabal in a directory named sqa-api and sqa-api is in your sqa-server cabal file?
12:53:49 <sclv> there's some basic mismatch in what you're doing here
12:53:50 <kuribas> yes
12:54:23 <kuribas> also this: CallStack (from HasCallStack): die', called at ./Distribution/Client/ProjectPlanning.hs:574:42 in main:Distribution.Client.ProjectPlanning
12:54:23 <kuribas>  
12:54:26 <kuribas> is that normal?
12:54:37 <kuribas> cabal new-build -v
12:55:09 <sclv> no thats not normal
12:55:25 <kuribas> cabal-install version 2.4.1.0
12:55:42 <sclv> jesus 2.4.1 no wonder
12:55:42 <kuribas> The Glorious Glasgow Haskell Compilation System, version 8.4.4
12:55:58 <sclv> lots of bugs in the new-build stuff in that series
12:56:23 <kuribas> sclv: should I try cabal-install-3.2 ?
12:56:28 <sclv> that would be my advice, yes
12:57:17 <slack1256> I got reports with -xc as "*** Exception (reporting due to +RTS -xc): (THUNK_STATIC), stack trace:", how do I interpret this?
12:57:34 <slack1256> THUNK_STATIC is not a exception type, right?
12:58:24 <sclv> looks like an internal GHC error :-/
12:58:44 <sclv> you can look through the tickets on the ghc bugtracker to see if its popped up before
12:59:11 <kuribas> 3.2 still crashing
12:59:12 <slack1256> sclv: That was a answer to kuribas right? :-> ?
12:59:35 <sclv> no my last two posts were to you
13:00:12 <slack1256> Oh, then I will search the bugtracker.
13:00:45 <sm[m]> does someone lead cabal development these days ? phadej ?
13:01:29 <kuribas> maybe I'll use stack after all...
13:04:16 <maerwald> kuribas: I did a stack -> cabal transition of a non-trivial proprietary project. It is generally easy
13:04:54 <kuribas> same bug here: https://github.com/haskell/cabal/issues/6845
13:05:01 <maerwald> there is even http://hackage.haskell.org/package/stack2cabal
13:05:29 <maerwald> kuribas: did you use --lib?
13:05:50 <kuribas> maerwald: no, just cabal new-build
13:06:21 <maerwald> so you are on windows?
13:07:00 <kuribas> ah it works now
13:07:11 <kuribas> I think...
13:08:26 <kuribas> it's compiling now
13:09:13 <kuribas> maerwald: my coworker wants to use intellij, and the plugin requires stack
13:09:39 <maerwald> then the plugin sucks
13:10:04 <kuribas> I told him vscode is much better
13:10:34 <sm[m]> nothing wrong with using stack, it is good at different things
13:10:57 <sm[m]> such as making your intellij plugin work
13:10:58 <kuribas> I am using vscode also, well writing in emacs, and checking types in vscode
13:11:06 <maerwald> sm[m]: a plugin that assumes cabal-install or stack sucks
13:11:27 <EvanR> x requires y doesn't have to suck... if "requires" was simple
13:11:37 <sm[m]> sometimes you have to limit the scope of what you support, even with just one of these the space of failure modes is fricking huge
13:12:08 <sm[m]> focus is sometimes a good thing
13:12:14 <EvanR> reusing code may be a myth but that doesn't mean it sucks
13:13:01 <EvanR> just me trying to convince myself, carry on
13:14:23 <sm[m]> when cabal gets simpler and more reliable, it'll be more attractive for IDE plugins to build on
13:16:42 <EvanR> i am half irrationally suspicious of intellij for haskell
13:17:23 <EvanR> and half inspired to try to set it up
13:17:54 <sm[m]> I am dying to have it, but far too wise to try again until there is a huge new hls/ghcide release
13:18:20 <turion> I tried ghcide today again and I don't know how I managed to be productive without it
13:18:23 <kuribas> the intellij plugin doesn't use ghcide no?
13:18:51 <maerwald> sm[m]: simpler xD
13:19:36 <kuribas> turion: on which editor?
13:19:56 <turion> vscodium
13:20:45 <turion> I make a simple shell.nix and do overrideAttrs with all the build tools, and from that shell I start codium
13:21:12 <maerwald> hoogle plugin for online searches, codex for ctags and a boring repl is the only thing that has ever worked for me (AND scaled)
13:21:34 <kuribas> "the installation files that Microsoft has created contain proprietary telemetry/tracking."
13:21:36 <kuribas> hmm...
13:22:13 <EvanR> unplug the network cable before double clicking
13:22:23 <EvanR> and or insert into faraday cage
13:22:37 <sm[m]> maerwald: not using ghcid ??
13:23:17 <maerwald> sm[m]: either broken or barely useful (the experience as a whole, not necessarily ghcide)
13:23:22 <Cheery> If I wanted functionality that's similar to ghci repl in my own application, eg. that you could run haskell expressions and then plug them into some typeclass interface and see them do something in the app.
13:23:33 <sm[m]> ghcid
13:23:41 <maerwald> sm[m]: ah, ghcid...  no, even less useful
13:23:50 <sm[m]> ah! sacrilege!
13:24:05 <maerwald> I don't rebuild the code every 15 seconds
13:24:43 <EvanR> % what does this use
13:24:43 <yahb> EvanR: ; <interactive>:60:1: error: Variable not in scope: what :: t0 -> t1 -> (Getting a0 s0 a0 -> m0 a0) -> t; <interactive>:60:6: error: Variable not in scope: does; <interactive>:60:11: error: Variable not in scope: this
13:24:53 <maerwald> I discovered that it makes me lazy and I stop reasoning about types if I have too much feedback
13:25:11 <sm[m]> I hear that.. there's a time for everything
13:25:45 <sm[m]> for beginners or when exploring a complicated codebase I find it a must
13:25:53 <EvanR> Cheery: the yahb bot runs this code in some form of sandbox
13:26:09 <sm[m]> or simply for normal development, since I don't have red squiggles yet
13:26:23 <maerwald> so even for an IDE... I don't want instant compile errors. What I care about is documentation on hover, autocomplete on write and jump to definition on key press
13:26:36 <sm[m]> doesn't make me lazy, just backs me up with an extra pair of eyes
13:26:43 <kuribas> maerwald: on emacs I have f5 bound to flycheck-mode
13:26:52 <kuribas> maerwald: so I can disable it when writing new code
13:26:53 <turion> maerwald: I then find myself designing the types in a way such that I will be lead to the correct code automatically, and that feels right :)
13:27:09 <kuribas> maerwald: and enable it when checking the code :)
13:27:40 <maerwald> it is also pleasurable if you manage to code for 15 minutes straight and it compiles without error
13:28:33 <maerwald> maybe that's not industry compatible...
13:28:48 <kuribas> maerwald: maybe you should try clojure
13:28:53 <maerwald> where you code with a gun up your a**
13:29:04 <maerwald> kuribas: I did, no thanks
13:29:12 <kuribas> maerwald: there you have all the fun of no compiler support!
13:29:41 <kuribas> and everything is a hashmap!
13:30:36 <maerwald> the only time things don't compile is when you forgot a bracket
13:30:42 <maerwald> *squint*
13:30:52 <maerwald> which one is it
13:30:58 <EvanR> you can't forget a bracket because you use par edit
13:31:06 <maerwald> then things get ridiculous
13:31:13 <EvanR> (which actually is pretty useful in haskell too)
13:31:30 <maerwald> EvanR: tried that too, too annyoing
13:31:35 <EvanR> understood
13:31:59 <EvanR> too annoying is my baseline for everything. It's like atmospheric pressure at sea level
13:32:19 <EvanR> in march
13:33:19 <maerwald> the amount of key bindings in vim are already annoying me... when you mistype, only god knows what you just did
13:33:29 <maerwald> every plugin makes it worse
13:33:50 <kuribas> the only thing I don't like about lisps syntax is that indentation increases quickly
13:34:23 <EvanR> well, don't mistype. It's like, if you shift gears, slam on brakes, floor it, or turn the wheel to max suddenly at the wrong time, god knows what you just did
13:34:37 <frdg> Question about monad transformers: https://pastebin.com/acCBLNNA
13:34:57 <EvanR> oh yeah, the parking brake
13:35:41 <maerwald> EvanR: I just switched keyboard layout
13:35:42 <kuribas> frdg: it's not unpacking the monad, it's running it.
13:35:52 <maerwald> I'm mistyping right now
13:36:11 <EvanR> impressive
13:36:35 <kuribas> frdg: and then wrapping it again in the state monad
13:36:38 <maerwald> qwertz -> workman
13:36:55 <maerwald> which is a huge difference
13:37:15 <kuribas> sclv: it works now, thanks for the help
13:37:29 <frdg> kuribas: ok the issue isn't that I was confused about transformers but just monads =D 
13:38:22 <kuribas> frdg: you cannot really "unpack" a monad
13:39:09 <maerwald> and workman is not particularly vim friendly
13:39:18 <kuribas> frdg: the computation "result" always stays in the monad.  In general that is.  Particular monad may allow it to "escape".
13:39:44 <Cale> Yeah, lift turns an action of type m a into an action of type t m a, where t is your transformer.
13:40:41 <frdg> so the a from `a <- m a`  is still an `m a` ?
13:40:59 <Cale> The variable names are slightly confusing there
13:41:09 <turion> frdg: The a there isn't a value
13:41:10 <Cale> Though a :: a
13:41:12 <EvanR> a <- m a  is mixing metaphors
13:41:14 <Cale> and m :: m a
13:41:14 <turion> It's a binding
13:41:20 <kuribas> frdg: no; do a <- m; ...  is sugar for m >>= \a -> ...
13:41:26 <Cale> Note that the code reads  a <- m  and not a <- m a
13:41:45 <kuribas> frdg: so the "a" is a variable binding, as turion says.
13:41:55 <Cale> It's probably easier if we rewrite this:
13:42:14 <Cale> lift x = StateT $ \s -> do v <- x; return (v, s)
13:42:20 <Cale> x :: m a
13:42:21 <Cale> v :: a
13:42:46 <frdg> I see it
13:43:03 <frdg> ya I was confused from the variable names 
13:43:42 <Cale> Someone being a little too cute and abusing the fact that types and terms live in separate namespaces
13:44:21 <EvanR> x is often a value, a is often a type, m a is almost certainly a type (not value level code). Not enforced but is general culture
13:45:21 <frdg> Cale: is term synonymous with value?
13:46:09 <monochrom> I think it's simpler than that. Colloquial natural language encourages using types to refer to terms. "I am combining an integer and a double".
13:46:41 <kuribas> can you document an executable?  Or do you need to make an internal module?
13:46:42 <monochrom> actually even omitting "an" and "a", the articles.
13:47:23 <maerwald> kuribas: i think so, but need to tell haddock to also generate for exes
13:52:06 <kuribas> maerwald: ok it works, thanks
13:52:17 <Cale> frdg: Roughly, yeah.
13:52:25 <kuribas> I don't understand how people can code without proper documentation
13:52:31 <kuribas> even just a little
13:53:58 <kuribas> is 4 and 2+2 the same term?
13:54:08 <kuribas> it's the same value
13:54:21 <Cale> frdg: Technically there's a distinction -- values are the mathematical things which terms refer to, and many terms may have the same value.
13:54:23 <monochrom> Different terms. That's the difference between terms and values.
13:54:27 <koz_> kuribas: No - they have different ASTs.
13:54:56 <maerwald> kuribas: most documentation sucks though... they document behavior, not intention/motivation. Behavior I want to see from the types, but I won't know why you came up with it
13:55:23 <Cale> But if you say "value level" or "term level" in this context, people will generally understand those as the same thing :)
13:56:31 <kuribas> maerwald: it's even worse in lisp or any dynamic language.  You see what it does, but have no clue why.
13:56:41 <kuribas> maerwald: at least having just a type helps
13:58:50 <frdg> Cale: I understand. Makes perfect sense why from the earlier example a would be a term not a value
14:13:14 * hackage gitlab-haskell 0.2.1 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.2.1 (RobStewart)
14:36:15 * hackage web-push 0.3 - Send messages using Web Push protocol.  https://hackage.haskell.org/package/web-push-0.3 (sarthakbagaria)
14:57:57 <fog> anyone see this yet? https://gist.github.com/fog-hs/4f0b1c6f05bfaa9b7cb050751e84ec6d
14:58:05 <fog> was hoping for some feedback
15:08:14 * hackage rock 0.3.0.0 - A build system for incremental, parallel, and demand-driven computations  https://hackage.haskell.org/package/rock-0.3.0.0 (OlleFredriksson)
15:14:45 * hackage cabal-debian 5.0.3 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-5.0.3 (ClintAdams)
15:39:43 <reactormonk> I'm trying to figure out why exactly coercing hoist from (forall a. m a -> n a) -> t m b -> t n b to (m () -> n ()) -> t m () -> t n () is unsafe.
15:40:05 <reactormonk> In which situation would that break?
15:41:35 <int-e> const (return ())
15:42:26 <int-e> mm
15:42:50 <reactormonk> Still (), right?
15:45:32 <reactormonk> Ah, I understand, you pass const (return ()) as the first argument. Yeah, that'd break stuff
16:08:07 <the_doctor> hi
16:10:29 <Cale> hello
17:43:59 <hololeap> kleisli_: you asked a day or two ago about recursion schemes over mutually recursive structures? this is something i've been looking into
17:49:39 <hololeap> if you want to use a catamorphism on two different structures at once, you have to allow for the possibility that one structure goes "deeper" than the other, so you have to use something like These
17:52:58 <kleisli_> hololeap: mhm
17:53:51 <hololeap> rather, you need a version of These that takes two functors and is itself, a functor
17:54:21 <kleisli_> there is also a way to do it with type-indexed GADTs
17:54:38 <kleisli_> https://www.reddit.com/r/haskell/comments/3sm1j1/how_to_mix_the_base_functorrecursion_scheme_stuff/ there is a nice description by andras kovacs in this thread
17:55:36 <hololeap> cool. i was looking into it about a year ago and it didn't seem like anyone else had investigated it very far
17:56:01 <hololeap> it didn
17:56:17 <hololeap> *didn't seem to have a practical application from what had seen
17:57:17 <kleisli_> yeah, i agree, which is a little surprising, given that recursion schemes seem like the most elegant way I've found to express syntax trees. but many syntax trees will need to have some kind of mutual recursion
17:57:59 <hololeap> i was messing around with tries of the form `Cofree (Map Char) Bool`, and found you could do any operation on them using mutual recursion
17:59:02 <hololeap> but it was really ugly compared to the normal way to do it
18:01:02 <hololeap> i get the feeling though that there is treasure somewhere down that path though :)
18:01:22 <ski> (ah, yes. that tag-indexed GADT way)
18:02:09 <MarcelineVQ> "<hololeap> if you want to use a catamorphism on two different structures at once" that's also an issue with writing a zipWith that fuses, you're cata-ing two structures at once, and easy fusion is where you're canceling out one cata with one builder at a time
18:02:45 <MarcelineVQ> At least in the paper I was reading, maybe it's a solved problem, or people settled with only fusing one of the lists if that's an option
18:03:04 <kleisli_> MarcelineVQ, can you link the paper?
18:05:30 <hololeap> i felt like the problem needed a class that encoded if the fixed point of a sum-type functor (like Maybe or []) was at the "end"
18:06:06 <MarcelineVQ> kleisli_: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf via http://www.cs.appstate.edu/~johannp/jfp06-revised.pdf which I haven't finished via https://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
18:06:11 <hololeap> meaning the current constructor did not have an `a' argument
18:06:40 <hololeap> if that makes sense...
18:06:42 <MarcelineVQ> apearantly it was just zip not zipWith in particular but apples to apples
18:07:03 <kleisli_> thanks :)
18:07:13 <ski> you can write `zipWith' by using one `foldr' for each input list
18:08:00 <Cale> Don't you just need algebras for both types?
18:08:15 <Cale> If you want to do a catamorphism on mutually recursive structures
18:09:09 <ski> (apparently i did this, in 2007-04-10)
18:09:56 <hololeap> Cale: you need a way to use a combined algebra like `Product f g a -> a` normally, but there is the possibility that one recursive structure is "deeper" than the other, you need a way to encode this as well
18:10:20 <Cale> I'm not sure I understand
18:10:23 <kleisli_> actually, what does it mean for one structure to be deeper?
18:10:27 <ski> what do you mean by "deeper" there ?
18:10:39 <MarcelineVQ> ski: If it was that straightforward it seems odd to mention zip in the paper as an example of where this doesn't work though
18:10:50 <hololeap> for instance, with lists, if the lenghts differ
18:11:05 <Cale> huh?
18:11:18 <Cale> How could that matter?
18:11:35 <Cale> Also lists aren't mutually recursive, they're just plainly recursive
18:11:55 <MarcelineVQ> In particular they say/show you can write a fusing  zip xs ys  where xs is fused but ys will not be
18:12:02 <MarcelineVQ> 'they' of https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf 
18:12:21 <hololeap> maybe my terms aren't correct... what i was experimenting with was a way to take two recursive data structures and have a catamorphism that fused them together
18:12:22 <Cale> I'm confused about why a catamorphism over mutually recursive structures has anything to do with zip
18:12:29 <ski> which of the papers, which page ?
18:12:33 <Cale> oh
18:12:37 <MarcelineVQ> in section 9
18:12:41 <Cale> That's completely different :)
18:12:44 <MarcelineVQ> page 9 too I think
18:12:48 <kleisli_> i also don't see the connection to zip
18:12:52 <ski> Cale : separate topic, i think
18:13:06 <Cale> ahh, maybe I'm just confused
18:13:07 <MarcelineVQ> yes two topics happening :>
18:13:22 <MarcelineVQ> all mine are about deforestation currently
18:13:29 <kleisli_> ah
18:13:29 <ski> ah, yes. they only have a single `foldr', not two of them
18:13:54 <hololeap> in other words, how to write a Recursive instance for (f,g)
18:14:07 <kleisli_> Cale, my understanding of the problem with catamorphisms over mutually recursive structures is that you no longer have a way to express the fixed point of the whole thing as a single type
18:14:28 <MarcelineVQ> They do, but why do they do this if just using two is a solution
18:14:31 <ski> however, thinking about it in terms of coroutines, i was able to define `zipWith', using one `foldr' for each input list
18:14:47 <Cale> There are a bunch of ways you might express that, though you don't need any of them if all you want to do is write down the catamorphism
18:14:49 <ski> also, later, i found out Oleg had done something similar (iirc)
18:15:05 <hololeap> instance (Recursive t, Recursive u) => Recursive (t,u) where ...
18:15:20 <kleisli_> i don't see how to do it with the Fix in the kmett recursion-schemes implementation
18:15:21 <MarcelineVQ> That's unfair of me to ask in that way, how could you know what they were thinking, I'm just trying to communicate that it's odd that they would miss that as an option if it was one
18:15:25 <Cale> (at least, if you don't care about being general)
18:15:42 <hololeap> and ideally expand that to an arbitrary number of Recursives
18:15:55 <hololeap> not sure what that's called ...
18:16:00 <MarcelineVQ> ski: do you happen to have a link to yours and/or oleg's work on that?
18:16:10 <Cale> http://dpaste.com/2QNBNC9 -- here's a dumb example
18:16:10 <ski> MarcelineVQ : i could link to it, if you're curious ? (or maybe you'd rather like to think about how to do it for yourself ?)
18:16:36 <MarcelineVQ> Oh man, that's unfair, now I have to do that and read core and stuff :O
18:16:39 <Cale> oops, half-renamed some things
18:16:56 <MarcelineVQ> "ski: I challenge you!"
18:17:05 <Cale> you get the idea though
18:17:29 <ski> hm, challenge what ?
18:17:42 <MarcelineVQ> to think for myself :>
18:18:10 <kleisli_> sure, maybe i was being unclear. i'm not arguing that it's impossible to define the meaning of a catamorphism over mutually recursive structures in a sensible way. i'm saying that the tools in the standard recursion-schemes implementation don't work for such cases
18:18:10 <ski> well, i thought it was a fun exercise .. so i've occasionally mentioned it, in here
18:18:40 <hololeap> so what i was talking about isn't called mutually recursive data structures?
18:20:28 <ski> MarcelineVQ : my solution is somewhat tricky, conceptually, i suppose. not that hard to write down, though
18:21:41 <Cale> kleisli_: ah okay
18:22:35 <Cale> hololeap: It sounds like you were talking about generically zipping structures together, rather than structures which are recursively defined in terms of each other
18:22:53 <Cale> (look at my One and Two types in the paste)
18:23:02 <kleisli_> hololeap, yeah, what you were referring to is different. types are mutually recursive when they both include each other
18:23:32 <hololeap> i see
18:24:43 <hololeap> although a zip isn't exactly a catamorphism, is it?
18:24:56 <ski> it can be written as one
18:25:53 <MarcelineVQ> ski: My first instinct was something like the foldr trick where you swap a tuple each step that you're consing to one side of to interleave a list, e.g.  foldr (\v ~(x,y) -> (y, v :: x) ([],[])   but that's like, the opposite of what we're after here, 1->2  instead of 2->1
18:26:10 <Cale> newtype MutFix f g = In { out :: f (MutFix f g) (MutFix g f) }
18:26:10 <Cale> cata :: (Bifunctor f, Bifunctor g) => (f a a -> a) -> (g a a -> a) -> MutFix f g -> a
18:26:10 <Cale> cata fAlg gAlg = fAlg . bimap (cata fAlg gAlg) (cata gAlg fAlg) . out
18:26:40 <hololeap> that's more of a metamorphism from two lists to one... which is very close to what i was experimenting with... so generic zips sounds accurate
18:26:57 <Cale> There you go, for a pair of mutually recursive things :)
18:27:53 <ski> yes, MarcelineVQ
18:28:07 <Cale> I wonder if Ed's already done this somewhere
18:28:40 <ski> MarcelineVQ : i guess, in some sense, you could say i'm swapping, though
18:29:37 <ezzieyguywuf> hm, `stack ghci --only-main --main-is MyTarget` works fine, but `stack exec ghcid` with `--comand="stack ghci --only-main -main-is MyTarget` in .ghcid does not work properly, it says "No files loaded, GHCi is not working properly"
18:29:41 <ezzieyguywuf> anyi thoughts?
18:30:37 <ski> sometimes it feels annoying that one can only `newtype' on `Type' ..
18:31:02 <Cale> ski: hmm, what would it mean to newtype a different kind?
18:31:38 <ski> yea, what would the data constructor be ?
18:31:44 <ezzieyguywuf> it even gives me the same "Loaded GHCi configuration from..." messages, even in the failed gchid attempt
18:32:19 <ski> but i'd possibly want `MutFix' to compute a pair of `Type's, there
18:33:19 <ski> though, one could encode `Type * Type' as `2 -> Type', which is the tag-indexed GADT method that was mentioned above
18:33:50 <ski> (i recall suggesting that to Peaker at some point .. i wonder how that went)
18:33:58 <ezzieyguywuf> nvm, I think the "--only-main" might have been the issue."
18:34:10 <hololeap> on the last topic: how would you write a These for an arbitrary number of types instead of just two?
18:34:35 <hololeap> you could do `These3 a b c = These a (These b c)`, but there's got to be a better way using haskell extensions
18:35:14 <hololeap> it would look like a power-set... ?
18:37:45 <ski> i guess one could do something with lists of types
18:38:38 <remexre> hm, when I do make install on a binary-dist tarball I just cross-built, I get /bin/sh: @GhcPkgCmd@: command not found and /bin/sh: @WithGhc@: command not found -- did I screw something up during ./configure, or is this a bug?
18:44:36 <ski> % data Those :: [Type] -> Type where Sing :: a -> Those (a ': as); Skip :: Those as -> Those (a ': as); Cons :: a -> Those as -> Those (a ': as)
18:44:36 <yahb> ski: 
18:44:42 <ski> hololeap : something like that ^ ?
18:47:31 <ski> (an alternative would be to remove `Cons', and replace `Sing' by one that had a `a', and then an ordinary cartesian product of the list of `Maybe' of each remaining type)
18:49:23 <gushys> what is the general http request package recommendation for haskell?
18:49:31 <hololeap> ski: that looks good :)
18:49:32 <MarcelineVQ> req
18:50:20 <MarcelineVQ> req and http-conduit are the most common I see, I liked req more
18:51:08 <gushys> thanks
18:51:37 <hololeap> is there something like `Lens' a c -> Lens' b d -> Lens' (a,b) (c,d)` ?
18:52:56 <glguy> http://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Unsound.html
18:53:13 <glguy> errr, no I guess I misread what you asked for
18:55:25 <hololeap> there's bimapping, but it's specific to Iso... i'm not sure if that's a logical requirement or not
18:57:48 <remexre> :t alongside
18:57:50 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
19:03:40 <hololeap> remexre: perfect, thanks! :D
19:05:56 <gushys> im pretty new to Haskell and im looking at it for little utility im planning on writing, how good/performant is doing concurrency that would be making http requests?
19:12:50 <dmwit> gushys: thiiiiiiis many
19:14:31 <dmwit> With a bit less snark: what would a helpful answer to that actually look like?
19:14:43 <dmwit> What performance target do you actually have to hit?
19:19:16 <MarcelineVQ> alternative answer:  Pretty good. look up how to use the  async  package
19:21:42 <gushys> im between using Go and haskell both as a learning and functionality for some other apps ive written
19:22:00 <gushys> so will haskell be faster and more efficient than another language
19:22:21 <gushys> thats more or less what i meant in my first question
19:22:25 <MarcelineVQ> That one is too vague to answer :>
19:23:14 <koz_> There is no 'fast' - there is only 'fast enough'.
19:23:18 <gushys> true
19:23:27 <koz_> What 'fast enough' means depends on many factors, most of which you can't judge immediately.
19:27:07 <hololeap> concurrency/parallelism is pretty much solved in haskell, and more elegant than pretty much any other language IMO
19:28:20 <hololeap> plus there's FRP libraries like reflex that give an alternative way to approach concurrency
19:28:39 <Cale> Reflex doesn't touch concurrency really
19:29:23 <Cale> That's actually its one weakness, is that if you want concurrency, it's pretty single-threaded. Though, it can give you a single-threaded switchboard for processing the results of things that are running concurrently.
19:30:31 <Cale> We don't use it on the backends of our web applications for that reason though -- it'd be a little too easy to write stuff that's not going to scale appropriately.
19:31:49 <gushys> thanks for the info, i think this has given enough motivation to go with haskell, as im new to the community i wasnt all to sure how mature these things were for the language
19:33:37 <hololeap> "a single-threaded switchboard for processing the results of things that are running concurrently"
19:33:53 <hololeap> the most intuitive way to handle concurrency IMO :)
19:34:16 <Cale> If that thread gets overstressed, there won't be much you can do about it though
19:34:27 <Cale> So, take care
19:34:30 <Axman6> use more threads!
19:34:47 <Cale> But yeah, Reflex is great for UI stuff
19:35:24 <Cale> It's pretty good at managing the frontend side of an application
19:35:34 <hololeap> isn't multi-core reflex in the works, though?
19:36:46 <Cale> We have a completely different style of FRP system in the works which is less higher-order in nature than Reflex is, but much better at dealing with concurrency and partial knowledge about data.
19:38:06 <Cale> It would be quite nice if we could find a way to fit it into the Reflex API (maybe by chopping up Reflex's type classes a bit), but right now it looks extremely different (it's a Category instance)
19:39:23 <Cale> Also, we're not going to release it until we succeed at taking a bunch more sharp edges off, so it may still be a ways out, depending on how things go.
19:41:35 <hololeap> still, that sounds super awesome. the FRP semantics are fantastic
19:41:52 <hololeap> even if it ends up being very different
19:44:04 <hololeap> haskell really is the cutting-edge
19:50:44 * hackage miv 0.4.2 - Vim plugin manager written in Haskell  https://hackage.haskell.org/package/miv-0.4.2 (itchyny)
19:54:09 <sm[m]> ezzieyguywuf: sometimes ghcid -c ‘stack ghci blah blah’ works better
20:00:15 * hackage b9 1.0.1 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-1.0.1 (SvenHeyll)
20:15:46 <ezzieyguywuf> sm[m]: you mean instead of using the config file?
20:16:21 <ezzieyguywuf> I eventually got it to work by explicitly listing my target main in the command, i.e. `--comand="stack ghcid path/to/Main.hs`
20:16:30 <ezzieyguywuf> er, s/ghcid/ghci/
21:35:45 * hackage hedgehog 1.0.3 - Release with confidence.  https://hackage.haskell.org/package/hedgehog-1.0.3 (moodmosaic)
21:36:46 <arpand> is there a way to set breakpoints inside of a stack project?
21:37:07 <arpand> forcing the modules to be interpreted after loading makes ghci ignore the breakpoints
21:54:54 <sm[m]> arpand: nice “breakpoints” is not something we hear much about here.. Do you mean in the ghci debugger ?
21:59:10 <sm[m]> I guess so, and you are losing them when reloading modules ?
22:07:34 <remexre> ugh, is it actually possible to cross-compile ghc... when I follow the instructions on the ghc wiki, I get ghc-pkg (and a couple other bins) for the wrong architecture
22:07:38 <remexre> so make install doesn't work
22:52:58 <nshepperd2> all compiler developers should be legally forced to use at least one exotic architecture
22:53:33 <nshepperd2> the only reason cross-compilation is so hard is because people almost never use it
23:05:50 <EvanR> use it? all the time when spawning a new linux system for distro purposes. Write all the scripts necessary to perform this cross compilation? Almost never
23:08:35 <nshepperd2> 'regular' compilation is easy because it's normal
23:08:58 <nshepperd2> install ghc, run 'ghc my_haskell_file.hs', done
23:11:11 <nshepperd2> cross compilation? no-one ever does that, so it's fine for it to be a tower of kludgy shell scripts that have probably already bitrotted since last time anyone used it
23:16:08 <EvanR> event probability is correlated with workingness
23:20:55 <nshepperd2> every new patch or change to any component in the stack is an opportunity for someone to (intentionally or not) introduce a tacit assumption that the platform you're running on is the one you're building for. the only thing that stops this is people using a cross compiler being annoyed enough to fix it
