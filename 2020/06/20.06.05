00:07:52 <ph88> hi all
01:03:24 <koz_> ph88: Yo wazzup.
01:03:38 <koz_> Axman6: Is that on Hackage?
01:03:44 <Axman6> nah
01:03:54 <Axman6> it could be, but we never got to it
01:04:40 <Axman6> maintaining libraries is hard -_-
01:06:23 <koz_> Axman6: Hear hear.
01:06:35 * koz_ has been procrastinating certain updates for too long.
01:07:10 <Axman6> finally looking at a rewrite of amazonka-s3-streaming
01:30:03 <gbr472> hi. i want to http-fetch some data, requirements being: HTTPS, able to set http-headers, i will fetch the whole response - no streaming needed. what is the simplest library i can use to achieve this?
01:30:04 <ph88_> anyone else finds stack does slow builds in powershell ?
01:33:09 <ph88_> gbr472, https://github.com/mrkkrp/req
01:37:13 <dminuoso> I have found servant to be quite enjoyable even for small stuff. :)
01:38:05 <dminuoso> However, it might not fit your definition of simple, but I'd toss it in regardless.
01:38:44 --- mode: ChanServ set +o Sigyn
01:39:13 <ph88_> i don't remember stack/ghc being this slow on linux ...
01:39:21 <ph88_> something wrong with windows setup or what
01:43:20 <justsomeguy> Windows has really slow filesystem access.
01:45:18 <ph88^> it's that really ??? :/
01:46:15 <justsomeguy> Just a possibility.
02:19:10 <ph88^> anyone know how i go from a list of IO actions to something that i can feed into this function ?  https://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly.html#v:wAsyncly 
02:30:19 <MarcelineVQ> try fromListM or others from Streamly.Prelude
02:30:55 <MarcelineVQ> https://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly.html#t:WAsyncT shows how you might use wAsyncly since it's not really obvious (to me)
02:31:42 <Jon> hm I think I've found some inconsistencies/mistakes in the documentation of hidden packages
02:32:16 <Jon> the claim is that hidden packages cannot have any of their  modules imported. "base" is hidden, and contains the module GHC.Base, which I *can* import, and Data.OldList, which I cannot. 
02:40:18 * hackage hadolint 1.18.0 - Dockerfile Linter JavaScript API  https://hackage.haskell.org/package/hadolint-1.18.0 (lorenzo)
02:53:38 <ph88_> thanks MarcelineVQ i'll have a look :)
03:12:02 <gbr472> ph88_ dminuoso thanks for the recommendations, will try them later.
03:36:18 * hackage tasty-golden 2.3.4 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.4 (RomanCheplyaka)
03:52:55 <dminuoso> Given a `Set IP`, and some function `sameSubnet :: IP -> IP -> Bool`, how do I efficiently test whether all IP addresses belong to the same subnet with shortcircuiting?
03:53:20 <dminuoso> My instinct is to cook up a foldM1
03:57:54 <int-e> dminuoso: Is anything known about sameSubnet? Is it a contiguous range?
03:58:37 <dminuoso> int-e: I dont know what the mathematical property is called, but a linear scan is sufficient, you dont need to test all combinations.
03:58:56 <int-e> (That would help a lot because you'd just have to check the smallest and largest IP address)
03:59:35 <dminuoso> That's an interesting idea, I'll have to check what the Ord instance does.
04:01:35 <Uniaika> we're waiting for TH-generated code to compile
04:01:55 <Uniaika> (shit, my irssi was waaaay up in the convo)
04:02:00 <hc> lol
04:02:02 <hc> happens ;p
04:02:04 <Uniaika> (please disregard my message)
04:02:05 <Uniaika> :P
04:02:21 <Uniaika> how are you hc anyway? 
04:02:24 <int-e> Uniaika: what message?
04:02:39 <hc> Uniaika: just fine, waiting for some rust code to compile, actually ;)
04:02:48 <Uniaika> int-e: :3
04:02:49 <Uniaika> hc: :D
04:03:27 <Uniaika> I'm moving a bunch of company projects to the new stack requirements to have the cabal file committed
04:04:10 <Uniaika> it's not highly intellectual but it's actually quite resting
04:06:59 <dminuoso> int-e: Mmm, the ord instance boils down to `instance Ord Word32`, which is used as the underlying representation.
04:07:04 <dminuoso> So I think that trick will work nicely! :)
04:07:18 <dminuoso> Cheers.
04:07:34 <int-e> dminuoso: oh, now I'd be worried about endianness
04:08:10 <dminuoso> Since CIDR is a thing, you are right.
04:26:43 <kuribas> how can I insert code using haddock?
04:27:04 <kuribas> I tried @ ... @, but the interprets quotes and backticks...
04:27:58 <dminuoso> https://www.haskell.org/haddock/doc/html/index.html has you covered
04:28:02 <dminuoso> ttps://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208
04:28:12 <hpc> https://haskell-haddock.readthedocs.io/en/latest/markup.html#code-blocks
04:28:20 <hpc> heh
04:28:26 <hpc> basically use >
04:28:30 <dminuoso> Ah, yours is newer :)
04:28:34 <kuribas> ah indeed
04:30:06 <ezzieyguywuf> I've seen in haddock documentation that sometimes the implementation of a function (usually a utility or convenience function) is listed in order to make i clear what it does. Is this done simply using the 'birdtrack' >, or is there an actual way to tell haddock "show the next few lines of code"
04:31:00 <dminuoso> ezzieyguywuf: Just click on Source, and then you can see for yourself how it was written.
04:31:15 <dminuoso> Take for instance :https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:map
04:31:32 <dminuoso> (You have to browse a bit above usually after clicking on Source)
04:32:43 <ezzieyguywuf> I've noticed
04:33:04 <sayk> hello
04:36:24 <hpc> usually when you're putting "this is the definition" stuff in docs, it's a much-simplified definition
04:36:30 <hpc> so automating that wouldn't help anyway
04:37:10 <hpc> even on the page you linked, filter just below it has a mismatched implementation
04:39:25 <hc> Hi all, very generic question: I've last used haskell for some non-trivial project at the end of 2017.. is there any site that gives a good summary of interesting/important new stuff I might have missed since then? :)
04:43:20 <dminuoso> hc: There haven't been any major changes since 2017, really. :)
04:43:45 <dminuoso> cabal v2 is finally the real deal
04:43:47 <hc> kkthx
04:43:48 <dminuoso> that's the major one I'd say
04:44:03 <hc> I just read an article on haskell weekly about stagnation/lacking industry adoption
04:44:27 <hc> Wonder if that's really true? I think there are some big users like facebook and fp complete, plus many thesis/postdoc work happening?
04:44:51 <dminuoso> It's really hard to measure adoption.
04:45:51 <hc> Sure, but is that really a reason for stagnation? I never felt haskell's development was much "industry influenced"
04:47:23 <hc> And my gut feeling tells me that's not entirely a negative thing
04:49:48 * hackage interpolate 0.2.1 - String interpolation done right  https://hackage.haskell.org/package/interpolate-0.2.1 (SimonHengel)
04:50:48 * hackage tdlib 0.3.0 - complete binding to the Telegram Database Library  https://hackage.haskell.org/package/tdlib-0.3.0 (Poscat)
04:53:15 <int-e> dminuoso: note that if all you know is that sameSubnet is an equivalence relation, then you'll have to test every element of the set; an easy way is to check whether all elements of the set are in the same subnet as the the smallest one. (Any element would do, but the extreme ones are the easiest to extract.)
04:55:34 <dminuoso> int-e: Ah, indeed. So I guess conceptually like `all (sameSubnet (head ls)) (tail ls)` - without the glaring lack of totality.
04:57:45 <dminuoso> Or actualy then I could just use `foldM` instead of `all`
05:29:18 * hackage processmemory 0.1.0.0 - C bindings for the gnu-extension functions process_vm_readv and process_vm_writev  https://hackage.haskell.org/package/processmemory-0.1.0.0 (martijn)
05:44:47 <ezzieyguywuf> hpc: good point.
05:59:31 <ezzieyguywuf> I like coding in haskell (or, I guess, the FP style) because it forces me to think about my api right from the get-go
05:59:38 <ezzieyguywuf> well, "forces" or "allows"
05:59:39 <ezzieyguywuf> or both.
06:05:49 * hackage egison 4.0.1 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-4.0.1 (SatoshiEgi)
06:10:06 <Axman6> IS there a tool for exploring a program's profiling output than just reading the text output?
06:10:34 <merijn> Axman6: Have you heard of our lord and saviour Speedscope.app? ;)
06:10:41 <Axman6> ... no
06:10:47 <merijn> Axman6: Or rather, first question: Can you use GHC 8.10? :p
06:10:58 <merijn> Axman6: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
06:11:17 <Axman6> I am not currently using GHC 8.10... but perhaps I could
06:11:40 <Axman6> I'd be surprised if I can though, since this is an amazonka based project
06:11:41 <merijn> Axman6: I specifically patches my code to be 8.10 compatible to use speedscope for profiling :p
06:12:03 <merijn> Axman6: Incidentally, 8.10 also sped stuff up by, like, 20%
06:12:06 <Axman6> damn this looks perfect
06:12:09 <Axman6> :o
06:12:13 <mpickering> When I profiled the exact project Axman6 is about to look at I didn't use speedscope
06:12:30 <Axman6> hmm?
06:12:45 <mpickering> You are looking at the streaming upload?
06:12:50 <Axman6> ... yes
06:13:06 <mpickering> You can use speedscope.app with older versions that 8.10 btw
06:13:16 <mpickering> You have to pass `-pj` but the first pane doesn't work
06:13:44 <Axman6> ah cool...
06:14:45 <Axman6> ... how did you know it was streaming?
06:15:04 <mpickering> because I helped Domen with the patch
06:15:11 <Axman6> Man I wish my internet was faster
06:15:12 <Axman6> ah I see
06:15:21 <MarcelineVQ> he's onto you, bail
06:15:36 <mpickering> When I profiled, it was obvious that the chunking part was the bottleneck
06:15:37 <merijn> mpickering: Incidentally, I'm gonna need you to donate your DNA to science, because my haskell productivity will be better if we have a few more clones of you ;)
06:15:46 <Axman6> yeah I'm having a go at rewriting that at the moment. there's a lot I like about the patch but also a fair amount I don't (reinventing memcpy makes me sad)
06:16:53 <mpickering> We just looked at the benchmarks someone else did of the different chunking approaches
06:17:04 <mpickering> and tried the fastest, which worked out very well 
06:17:47 <Axman6> how do I make use of speedscope.app? with the output of -pj isn;'t not looking very helpful
06:18:52 <Axman6> I probably need a faster internet connection to benchmark this properly. lots of time waiting for data to send
06:18:52 <mpickering> You just load the -pj output
06:19:10 <mpickering> Yeah... I definitely feel that
06:19:27 <Axman6> I did, time order shows everythign on the right of the page
06:19:27 <mpickering> Axman6: You can just benchmark the chunking part
06:19:41 <mpickering> time order is the tab which doesn't work
06:19:46 <Axman6> right
06:20:06 <mpickering> The middle tab is like a flamegraph
06:20:48 <Axman6> ctrl-scroll is the key I needed
06:23:21 <Axman6> so what benchmarks did you guys try? if I'm heading down the wrong route with using ByteString.Builder that would be useful to know.
06:24:31 <Axman6> I'm really not a fan of writing all the byte level memory manipulation by hand, particularly explicitly copying byte by byte
06:24:42 <MarcelineVQ> would also like to know, even just to see the chunking data of "<mpickering> We just looked at the benchmarks someone else did of the different chunking approaches"
06:25:08 <MarcelineVQ> s/chunking data/benches
06:25:15 <merijn> Axman6: get a VPS and run the benchmark there? :)
06:25:19 <Axman6> this is a scary number of people depending on this little throwaway package I wrote
06:25:28 <Axman6> yeah I'll need to fire up something on AWS
06:25:28 <mpickering> Axman6: https://github.com/blitzcode/conduit-chunked
06:25:43 <merijn> Axman6: Which package is that?
06:26:07 <Axman6> amazonka-s3-streaming
06:26:21 <Axman6> which it appears I did basically everything wrong when writing
06:27:24 <merijn> :D
06:27:29 <mpickering> Axman6: No one is blaming you, it's a lot easier to fix something than start from scratch
06:27:37 <mpickering> everyone is thankful for you writing the package in the first palce
06:28:49 <Axman6> I honestly never thought anyone would use it, I was so surprised the first time I saw someone using it (in a package for writing lambdas easily in HAskell). then I joined Seek and found they use it... a lot, and IIRC the caches3 tool we used a lot also relied on it.
06:28:57 <Axman6> responsibility is not fun
06:30:47 <merijn> Axman6: I know the feeling ;)
06:31:09 <Axman6> If amazonka used the streaming library this would actually be a lot nicer, you'd end up with a Stream (Of (Stream (Of ByteString))) I think
06:31:12 <merijn> "Why did your package get removed from stackage? We need it." 'wait, it was in stackage?' :p
06:31:36 <Axman6> I remember doing work to get this on stackage, but I have no idea how that works any more
06:32:47 <Axman6> mpickering: I'm not convinced that the processChunk code actually works - I have a feeling it drops chunks (at least I haven't been able to convince myself that it doesn't drop chunks)
06:33:29 <mpickering> perhaps you should write a test 
06:33:35 <merijn> mpickering: Crazy talk!
06:33:43 <merijn> mpickering: It typechecks, it must be correct!
06:33:46 <mpickering> I once wrote one and it found a bug
06:33:56 <MarcelineVQ> or reimplement it in coq just to check some single part you're unsure about
06:34:11 <merijn> I usually write tests after I find bugs :p
06:34:22 <merijn> Mostly to check I *actually* fixed it :p
06:34:56 <merijn> Speaking of which, I have a bug I know but can't figure out how to write a test for, so if anyone wants a nice puzzle :p
06:38:09 <Axman6> this benchmark repo seems to be very focused on the byte at a time case, which is always going to be pretty inefficient. there's a fair amount of discussion of builders but the only place ByteString.Builder is used is when a byte at a time. the bytestrings we're passed can be written a chunk at a time, and it's pretty simple to allocate a single buffer which is exactly the right size once.
06:41:12 <Axman6> mpickering: https://github.com/domenkozar/amazonka-s3-streaming/compare/rewrite...axman6:rewrite-play?expand=1
06:43:11 <Axman6> probably the weirdest thing is having processAndChunkOutputRaw return the new S type, but that's so that the allocation and writing out to the buffer can be pushed into the threads doing the uploading - the parent thread does enough work to gather at least chunkSize bytes and then passes that off to the upload threads
06:59:18 * hackage language-docker 9.1.1 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-9.1.1 (lorenzo)
07:03:23 <Axman6> merijn: what's the bug?
07:04:02 <merijn> I know my library has a race condition in it, I know what the race is, I even know how to fix it. I just don't know how to trigger it in a test :p
07:04:25 <Axman6> the secret to race conditions is running more tests
07:04:36 <Axman6> just use criterion to run the tests :)
07:05:04 <merijn> Naah, I feel like it should be possible to intentionally trigger, or at least intentionally trigger it more often, but I haven't figured it out yet :p
07:05:50 <ph88_> merijn, is speedscoop yours ?
07:06:41 <ezzieyguywuf> merijn: I'll bite, what's the puzzle.
07:07:00 <merijn> ph88_: No
07:09:15 <merijn> ezzieyguywuf: If 2 (or more) instances of the parallel function here https://hackage.haskell.org/package/broadcast-chan-0.2.1.1/docs/BroadcastChan.html#v:parMapM_ throw an exception at the same time, that exception ends up incorrectly leaking out of the overall handler
07:09:23 <merijn> It's...subtle :p
07:09:51 <merijn> I can actually only trigger it on CI nodes and even then only once in every 10 plus runs :p
07:15:18 * hackage laop 0.1.1.0 - Matrix programming library  https://hackage.haskell.org/package/laop-0.1.1.0 (bolt12)
07:15:20 <ezzieyguywuf> lol, workFun
07:18:03 <merijn> I think the tricky bit is to have like a mutex/semaphore blocking all of them, and then unblocking them atomically and having each throw an exception in the hope that that's "atomically" enough to trigger the race
07:19:11 <ezzieyguywuf> merijn: you mean to reproduce the issue?
07:19:19 * hackage laop 0.1.1.1 - Matrix programming library  https://hackage.haskell.org/package/laop-0.1.1.1 (bolt12)
07:21:36 <ezzieyguywuf> merijn: you sure the error isn't in bracketOnError? somewhere between `x <- before` and `throwIO exc`?
07:23:41 <merijn> ezzieyguywuf: No, because exceptions are blocked during the alloc part of bracket. No, the issue is that if 2 (or more) thread simultaneously throw an exception, one of those thread will "win" and interrupt the main loop, which will then interrupt all other threads. Except some of those are already throwing and have exceptions blocked until they finish
07:24:10 <merijn> So the fix is to ensure that only the first throwing child succeeds and then somehow log all simultaneous errors in a different manner
07:27:32 <ezzieyguywuf> yikes, I don' think my brain is ready for concurrency it haskell
07:27:44 <ezzieyguywuf> lol, it can barely handle the handful of concurrency stuff it's done in python
07:27:54 <merijn> ezzieyguywuf: Concurrency is fine, async exceptions are the problem :)
07:28:30 <merijn> ezzieyguywuf: My advice: Don't use async exceptions and rely on masochists like me to (try and) handle them properly ;)
07:35:11 <Cheery> in Haskell it's bit more obvious why the concurrency/async is ugly.
07:35:47 <Cheery> it's the same thing in Python/Js, but you don't see it as easy.
07:39:26 <veverak> hi folks, I found new part of haskell for me...
07:39:47 <veverak> Data.Map.Ordered -> how can I find key in the OMap based on value ?
07:41:18 <Ariakenom> python does have async exceptions with KeyboardException, Ctrl+C, it's just that it's ignored and things break.
07:41:34 <Cheery> yup.
07:42:04 <Cheery> veverak: convert to list, fold and retrieve key by value.
07:42:10 <veverak> I see
07:42:11 <Cheery> the fold must produce Maybe a
07:44:16 <Ariakenom> Cheery, I get more annoyed at concurrency, and exception handling, when I write python. I dont think it is hidden
07:47:22 <merijn> Ariakenom: It's actually much, much worse
07:48:02 <merijn> Ariakenom: Signal handlers are only enabled while the GIL is held, which means that code blocking with the GIL released is completely uninterruptible
07:48:07 <merijn> Ariakenom: Ask me how I know!
07:52:37 <Cheery> well I didn't know that.
07:52:57 <Cheery> so I guess you found out about that with some means.
07:53:09 <Ariakenom> I have done that, running numerical code. So I would guess that 
07:53:10 <Axman6> merijn: well, I have read the scriptures and I would subscribe to the newsletter of our lord and saviour, speedscope.app
07:53:18 <merijn> Axman6: :)
07:53:28 <Ariakenom> like the array module
07:53:58 <Axman6> the good news is that with the code I've wirrten, nearly none of my code shows up as the majority of the computation, it's all crypto and sending to the network
07:54:16 <merijn> Axman6: \o/
07:54:30 <Cheery> is there sense in using comonads for UI?
07:54:47 <Cheery> there's papers about it, but does it make sense?
07:54:55 <Axman6> using bytestring builders seems to perform as well as the hand rolled buffer handling too
07:55:03 <Ariakenom> I dont agree that it's worse though. Ignoring the difference between non-async and async exceptions leads to things getting half done then the exception is caught and the code continues.
07:55:19 <merijn> Axman6: Honestly, Builder and stuff like binary's Get/Put perform pretty well
07:55:57 <Axman6> indeed, which is why I wanted to avoid hand rolled buffer manipulation
07:56:07 <Ariakenom> An annoying example is trying to interrupt a install procedure because it was opening admin prompts. But it just caught the exceptions and opened a prompt for the next package
07:56:59 <Ariakenom> merijn but how do you know?
07:57:14 <merijn> Ariakenom: Code at work deadlocking repeatedly requiring SIGKILL
07:57:24 <Axman6> :'(
07:58:14 <Ariakenom> FFI deadlocks? ooof
08:12:52 <merijn> Ariakenom: I have an edge-case triggering field
08:13:07 <merijn> Whereever I go, I trigger all the most annoying edges cases in software :p
08:13:43 <merijn> And because I'm a stubborn idiot I can't let go and keep digging :p
08:24:46 <monochrom> I have a computer healing field. In my presence, computers behave properly.
08:26:19 <monochrom> My friend bought a used computer from a surplus store. (It was an Apple II clone.) It wouldn't power up. He asked me to go to his place and take a look. The computer powered up fine.
08:33:34 <merijn> I'm not sure which skill is more useful ;)
08:38:48 * hackage snaplet-persistent 0.6.1 - persistent snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-persistent-0.6.1 (MichaelXavier)
08:40:15 <Axman6> does GHC ever free pinned memory?
08:40:28 <merijn> Axman6: Sure, why wouldn't it?
08:40:39 <monochrom> free but never move
08:41:37 <Axman6> because my app isn't - I'm explicitly calling the finaliser on a ForeignPtr allocated using  mallocForeignPtrBytes, and the heap profile shows that PINNED memory just keeps growing
08:41:38 <monochrom> During GC, other live data are relocated, live pinned data are not.
08:42:36 <Axman6> when I pass in 2GB of data to upload, memory usage grows to 2GB, even though it should be processing data about 5MB at a time
08:48:03 <merijn> Axman6: Sounds like stuff's not getting freed
09:13:57 <ph88^> a single constructor type is that a type without sum alternatives ?
09:14:44 <ph88^> https://wiki.haskell.org/Performance/Data_types#Unpacking_strict_fields
09:15:58 <ph88^> how do i know if a function is non-strict ?
09:21:58 <ph88^> what's a good type for line numbers ? something unsigned i suppose
09:24:27 <Cheery> Integer
09:25:00 <Cheery> but you may also want the source location, so you need a path descriptor as well.
09:25:11 <Cheery> (Integer,String) maybe.
09:25:31 <Cheery> you usually don't do arithmetic with them
09:25:59 <Cheery> They're just tags, telling where the stuff came from.
09:26:09 <ph88^> i would prefer a type that has a fixed size
09:29:32 <Cheery> If you had 2-bit field describing the source location, would that work?
09:30:59 <Cheery> 0 = somewhere from /usr, 1 = somewhere from /home, 2 = somewhere from /lib or /include, 3 = anywhere else.
09:34:27 <dsal> Integer is good because you might have a lot of lines.
09:34:48 <dsal> > maxBound :: Int -- you don't want to be limited to like, this many.
09:34:50 <lambdabot>  9223372036854775807
09:35:43 <dsal> ph88^: though for this type of problem, a good idea is to just use something like `type LineNumber = Int` and then not worry about it.  You can change it later if you decide you care.
09:39:17 <merijn> dsal: That's a bad idea >.<
09:39:37 <merijn> Semantic seeming type aliases suck
09:39:48 <dsal> Why is that?
09:40:05 <merijn> dsal: Because it makes it hard to see what a function actually takes as argument
09:40:35 <merijn> I've seen libraries where you have to click through 3 or 4 layers of type aliases to see what the function actually takes. Plus it's just misleading
09:41:22 <merijn> If you want different type names you should just define actually new types via newtype or data that way you actually get type safety
09:43:51 <dsal> I guess.  That's unnecessary overhead in some cases, though.  I take two Texts with different roles and semantics.  I'd like to know which is which, but I don't need to wrap them everywhere.   Or I've got a couple different Word16s in my protocol and I want to name them so it's not confusing.
09:43:54 <justsomeguy> How do you guys pronounce operators like <>, <*>, *>, <*, <$>, and the like when speaking?
09:44:05 <dsal> haskell is a written language.
09:44:09 <merijn> dsal: What do you meany by "unnecessary overhead"?
09:44:27 <merijn> justsomeguy: Honestly, I just don't
09:45:34 <justsomeguy> Hmm... that seems reasonable, but also like it would make code review awkward.
09:45:36 <slack1256> justsomeguy: Speaking only for me, (<>) as mappend, <*> as "ap", <$> as fmap
09:46:05 <slack1256> *> , <* as `then`
09:46:22 <dsal> merijn: Instead of just naming it, I have to, at least, derive a bunch of instances I might need (e.g., working with bits, etc...) and unwrap it in places where I need the inner thing.  And then show starts getting larger.  The latter *might* be an improvement.
09:46:43 <dsal> The type safety thing is real -- it'd be nice to have some kind of typesafe type aliases.
09:46:56 <merijn> We do, they're called newtype ;)
09:46:59 <dsal> heh
09:47:12 <merijn> With DerivingStrategies you can even avoid the Show bloat
09:47:18 <dsal> I want something halfway between type and newtype.
09:47:19 <justsomeguy> slack1256: Thanks, it's good to have something to call them, if only to make reading out loud less frustrating.
09:47:22 <dsal> Huh.  that's interesting, yeah.
09:47:29 <dsal> merijn: I only like, 20% disagree with you.
09:47:48 <dsal> justsomeguy: just remember, fmap is one syllable.
09:50:49 <ph88^> > maxBound :: Word64
09:50:51 <lambdabot>  18446744073709551615
09:51:16 <ph88^> is this the biggest unsigned int type ?
09:52:29 <chloekek> It’s the biggest one in base apart from Natural. There’s a library that implements Word128 using two Word64s.
09:54:51 <dsal> ph88^: It's not particularly hard to make your own number type with your own requirements.  There's one out there that lets you specify the bounds, but I always forget what it's called because I've never managed to actually use it.
09:55:28 <ph88_> doesnt seem like the best idea to create my own number type :/
09:56:29 <dsal> Why not?
10:00:10 <slack1256> justsomeguy: I don't think it is good to readthem out loud. To me <$>, <*>, >>, >>= are a the same level of punctuation on english phrases. You get used to them as cues.
10:00:27 <dsal> Yeah, they should not be read out loud *period*
10:01:09 <justsomeguy> It's going to take me a while to get over that. I tend to read out loud when I trouble concentrating, or during code reviews, since I tend to skim otherwise.
10:01:16 <dsal> If you're reading code out loud, you're probably trying to say what it's doing, not just literally reading the things that are on the screen.
10:01:53 <justsomeguy> No, I literally read it. Except, I have some conventions for reading type signatures.
10:02:14 <justsomeguy> (I may have ADHD, things are different.)
10:02:15 <monochrom> Finally someone who agree with me. You are not a modem, why convert code to voice? Just text it.
10:02:35 <slack1256> Well actually, justsomeguy has a point, it works for him.
10:02:49 * hackage haskoin-core 0.13.6 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.13.6 (PhilippeLaprade)
10:02:50 <monochrom> Last time people gave me shitstorms for my opinion.
10:03:10 <slack1256> For me it doesn't make sense, but I have to recognize it's not a universal experience.
10:03:18 <ezzieyguywuf> merijn: 👍, except I dunno if I trust your library now that I know of all these race conditions 😂😂😂
10:03:27 <ezzieyguywuf> (in response to your message from 10:28:08 EST
10:03:33 <justsomeguy> I don't really think that people should read code out loud in general, but it helps me in particular, in certain situations. I don't care enough to have strong opinions about this topic. 
10:03:35 <dsal> We all have to find what works for us.  I've given up on thinking people think/work like me.
10:03:54 <slack1256> monochrom: You opinion is *objectively* wrong :-) /s
10:04:04 <slack1256> *your
10:04:05 <monochrom> I hate ou
10:04:13 <slack1256> Me too buddy,
10:04:19 <[exa]> justsomeguy: I do "reading the code roughly aloud" to students if they can't see what's wrong with it. Certainly helps. :]
10:04:21 <ezzieyguywuf> but ou is so helpful! loud, proud, mound...
10:04:37 <monochrom> "no, the honour is mine"
10:05:16 <dsal> I think this is just academic elitism looking down on poor Oklahomans.
10:05:57 <slack1256> Oklahomans is the American way to say "common people"? Or there is some history on the term?
10:06:10 <dsal> slack1256: ou.edu
10:06:22 <monochrom> I guess if common operators like + * have names, <$> <*> should have names too. Not exactly punctuation, they actually have semantics.
10:07:01 <dsal> They should teach category theory in elementary school.  They teach useless stuff like plusses and minuses.  Why not fishes?
10:07:19 <monochrom> <$> is fmap, that one is pretty guessable. <*> is ap, this comes from Control.Monad.ap, and it's a generalization of function application, and the name sake of Applicative anyway.
10:07:32 <monochrom> >>= is bind from some old papers
10:08:40 <dsal> >> as 'then' is probably fine.  It's a lossy bind.
10:08:48 <monochrom> >> may have a name but more obscure because people use it much less often explicitly. "then" is one of its obscure names.
10:09:09 <dsal> I read <> as 'append'
10:09:24 <stevenxl> Hi folks. Anyone know what the correct syntax for running a specific test using stack test is. I tried  "stack test hastory-server --file-watch --fast --match "/Data.Hastory.Handler.Users/POST /users/username already exists/equality for a user's name is case insensitive/"" but that is invalid.
10:10:14 <dsal> I guess part of the problem is that you couldn't *transcribe* code from English very well.   Which of these is 'and'?   `and` `(&)` `(&&)` (.&.)`
10:10:16 <monochrom> And now, my real gripe along this line. In "\x -> x+1", "forall a. P a", "exists a. P a", the "->" and "." are really punctuations, no semantics at all.
10:10:18 <dsal> (also, one of them is not and)
10:10:57 <slack1256> dsal: At least on my math department, the algebra guys were seen as the old guard. On latin america there is a single category theorist located in brazil. There is nobody to teach elementary school children about fishes!
10:11:22 <monochrom> Some mathematicians insist on writing "exists a s.t. P a" as though you need a phrase for the "." delimiter.
10:11:40 <dsal> I don't understand that particular `.`.  It came up in thread at work about formatting where it was being placed all over the place.
10:11:59 <monochrom> This is because they think that formulas don't have any semantics other than abbreviations of English.
10:12:21 <dsal> slack1256: I grew up learning that math begins at addition and ends at division.  And a few other weird buttons on the calculator.   Our schools aren't great at even telling us what math is.
10:12:36 <dolio> I can explain why the dot is there, if you really want.
10:12:43 <dsal> dolio: the forall dot?
10:12:53 * slack1256 wants to know
10:13:04 <dolio> Yeah.
10:13:32 <monochrom> What they forget is that English itself is broken. "for all a, P a holds" and "there exists a such that P a holds" should not be your source of inspiration because they deny the beautiful duality or symmetry between universal and existential.
10:14:02 <monochrom> If you are to draw inspiration from English, use "for all a, P a holds" and "for some a, P a holds" at least.
10:14:19 <dolio> The answer is that in early syntax for formal logic, there was less convention about how the connectives worked. Also, quantifiers were really tight.
10:14:25 <monochrom> And now you see you only need a semanticsless comma as separator.
10:14:56 <dolio> So, if you write `∃xP ⊃ Q` that means `(∃xP) ⊃ Q`.
10:15:16 <dolio> But, formal logicians also don't like writing lots of parentheses.
10:15:18 <monochrom> therefore "such that" is also punctuation and has no meaning and no right of existence.
10:16:10 <slack1256> monochrom: What duality? that to consume an existential, the only way is to pass it to an universally quantified function that do not cares about the type of the argument?
10:16:25 <slack1256> monochrom: Or you mean on the introduction/destruction rules on natural deduction?
10:16:37 <dolio> So, they developed a system where if you put a . by a connective, it makes it bind much more loosely. So, like, `P ⊃ Q .⊃. P ⊃ R` means `(P ⊃ Q) ⊃ (P ⊃ R)`
10:16:56 <monochrom> Both and more.
10:17:18 <dolio> This also means that `∃x. P ⊃ Q` now means `∃x (P ⊃ Q)`
10:18:03 <monochrom> And the two-person-game semantics. http://www.vex.net/~trebla/weblog/any-all-some.html
10:18:15 <dolio> So, you put the dot to make the quantifier bind more loosely than the other connectives. However, that's just become part of the syntax at this point, although the quantifiers are still loose instead of really tight.
10:18:44 <dolio> And no one uses the . for other connectives, because it's awful. :)
10:19:11 <slack1256> monochrom: Ah yeah, that is connected to my first phrase about the only way to consume an existential.
10:19:57 <dsal> So `.` is math for `$`?
10:20:05 <dolio> Yeah, basically.
10:20:11 <dsal> Is that because LaTeX uses `$` to mean "this is math!"
10:20:21 <dolio> This was way befor LaTeX.
10:20:48 <monochrom> LaTeX follows TeX in using $. But LaTeX also adds \( \)
10:21:18 <monochrom> TeX chose $ probably because $ wouldn't clash with anything in a math paper.
10:21:29 <dsal> All of the things that occurred before my time were basically big bang and had no chronological ordering.
10:21:52 <monochrom> Hey I have the same feeling, except it's about my grandparents.
10:22:10 <jon1> Hello, how would I write the following without the "where"? 
10:22:15 <jon1> builtRow' = newRow where
10:22:17 <jon1>   newRow = zipWith (+) (replicate 1 0 ++ newRow) [1,0,0,0,0,0]
10:23:03 <monochrom> When I was a kid I imagined this scene. A dark room. Then lights turned on, and shown my grandparents sitting in armchairs or couches or something. And that was the beginning of my world.
10:23:28 <monochrom> I probably watched too much TV before imagining that scene.
10:24:07 <monochrom> jon1, I think it already works?
10:24:28 <monochrom> Oh without.
10:24:55 <jon1> yes, sorry if it's a silly question, but I can't wrap my head around how newRow references itself
10:25:03 <monochrom> builtRow' = zipWith (+) (replicate 1 0 ++ builtRow') [1,0,0,0,0,0]
10:25:35 <monochrom> https://www.google.com/search?q=recursion
10:25:36 <jon1> ok thank you, let me wrap my head around that
10:26:03 <dsal> jon1: It's the same thing you had.  Were you having trouble understanding what you had?
10:26:10 <jon1> yes
10:26:24 <dsal> Ah.  I didn't quite gather that from your question.
10:27:02 <monochrom> You won't be able to eliminate recursion. It's here to stay. Sooner or later you have to cope with it.
10:27:35 <monochrom> Every attempt at reducing recursion to something else ends up only moving the recursion to the meta level.
10:28:33 <dsal> I believed I eliminated the curses, yet I find myself recursing.
10:29:45 <monochrom> My thesis supervisor said "you can't solve problems, you can only make it someone else's problem". It's right for several things and probably not for others. But he said it in the context when we were discussing loops and recursions, and for this it's right on.
10:30:21 <dsal> jon1: There's some obfuscation in there that's additionally confusing.  `repeat 1 0` means `[0]`   `[0] ++ x` means `0:x`
10:30:41 <monochrom> replicate 1 0
10:30:42 <dsal> > let builtRow' = zipWith (+) (repeat 1 0  ++ builtRow') [1,0,0,0,0,0]  in builtRow'
10:30:44 <lambdabot>  error:
10:30:44 <lambdabot>      • Couldn't match expected type ‘Integer -> [c1]’
10:30:44 <lambdabot>                    with actual type ‘[Integer]’
10:30:47 <dsal> er, replicate, yeah
10:30:52 <dsal> > let builtRow' = zipWith (+) (repliate 1 0  ++ builtRow') [1,0,0,0,0,0]  in builtRow'
10:30:53 <dsal> argh
10:30:54 <lambdabot>  error:
10:30:54 <lambdabot>      • Variable not in scope: repliate :: Integer -> Integer -> [c1]
10:30:54 <lambdabot>      • Perhaps you meant one of these:
10:31:01 <dsal> > let builtRow' = zipWith (+) (replicate 1 0  ++ builtRow') [1,0,0,0,0,0]  in builtRow'
10:31:03 <lambdabot>  [1,1,1,1,1,1]
10:31:11 <dsal> > let builtRow' = zipWith (+) (0:builtRow') [1,0,0,0,0,0]  in builtRow'
10:31:13 <lambdabot>  [1,1,1,1,1,1]
10:31:24 <monochrom> I bet "replicate 1 0" came from beginners making XY problems.
10:31:41 <jon1> that's simpler, thanks
10:31:49 <dsal> So you only need to understand what the function does and what zipWith does and what it means to put 0 in front of a list.
10:34:37 <dsal> I'm not sure what you're trying to do there, though.  My brain just says, "Why don't you just write `(replicate 6 1)` and be done?"
10:35:15 <monochrom> :)
10:35:37 <dsal> > let builtRow' = zipWith (+) (z:builtRow') [a,b,c,d,e,f]  in builtRow' :: [Expr] -- jon1 for a good time
10:35:39 <lambdabot>  [z + a,z + a + b,z + a + b + c,z + a + b + c + d,z + a + b + c + d + e,z + a...
10:37:38 <justsomeguy> ...recursion still gives me headaches
10:38:36 <jon1> ok that helps me visualize what's actually going on, thank you dsal!
10:39:06 <dsal> It's very natural most of the time, but you can contrive something that's weird and confusing.  e.g., I think this example is kind of weird and confusing.  It begs to be simplified and then the recursion goes away.
10:40:41 <dsal> justsomeguy: I should point out that 'natural' is probably not the right word.  Nothing I do at my computer is natural, but a lot of it feels that way.
10:41:48 <dolio> It does require the right way of thinking about it, and (at least when I was a student) the right way generally isn't taught.
10:44:44 <jon1> by the way, that Expr type, it's from what package?
10:45:29 <dsal> heh.  I've been meaning to ask.  Someone added a lambdabot feature recently that identifies identifiers, I think, but I forgot how to ask it.
10:46:05 <monochrom> simple-reflect
10:47:27 <jon1> great, thanks
10:47:29 <Cheery> If I wanted to check that MLL proof net satisfies correctness criterion, how would that be best done in Haskell?
11:05:48 * hackage test-lib 0.2.2 - A library to make a quick test-runner script.  https://hackage.haskell.org/package/test-lib-0.2.2 (IavorDiatchki)
11:06:56 <luzaice> hello, can i ask beginner haskell questions here?
11:07:01 <slack1256> Sure
11:07:58 <luzaice> i'm doing a problem from online judge and i'm stuck, should i post my code here?
11:08:13 <dsal> luzaice: links to code in a pastebin of some sort.
11:09:06 <luzaice> https://pastebin.com/FsP27Snw
11:10:32 <luzaice> the problem is: N number of cities is given, from 1 to N. find the lowest number m such that, going from 1 and then going 1+m, every city is removed and number 13 is the last one left
11:11:31 <luzaice> the answer i'm getting is a bit wrong, and i'm stuck because i'm new to haskell and functional languages, so don't know how i can debug
11:17:40 <dsal> luzaice: Debug.Trace is the One True Debugger™
11:21:28 <luzaice> could you explain how to use it?
11:22:06 <luzaice> tried googling, but it's hard to understand
11:22:58 <monochrom> I need to write a tutorial for that too.
11:24:47 * hackage haskell-ci 0.10.2 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.10.2 (phadej)
11:25:17 <luzaice> could try getting by with print statements, but if i try to print a list in a function, i get this error
11:25:23 <luzaice> Couldn't match expected type `Int' with actual type `IO b0'
11:28:28 <ja> luzaice: trace is easy to use
11:28:41 <ja> luzaice: you take an expression in your function that you wanna debug
11:29:42 <ja> luzaice: let's say the expression is "a + b". now, you can debug the value of a and b and by using (trace (show ("my a and b are: ", [a, b])) (a + b)) instead of (a + b)
11:30:23 <ja> that way, the type signature doesn't change, and you won't need to bother converting the function into returning IO, as you'd need to use the print function
11:30:58 <ja> so trace puts the first argument on the console (your debugging statement), and the second argument is returned. 
11:31:14 <ja> so trace has a side effect, but it doesn't affect its behaviour. so that's why it is kinda safe
11:31:30 <ja> (it's behaviour as seen in the types, at least)
11:32:46 <luzaice> so if i have an expression let temp = deleteAt cursor xs, how should i use trace to show the list temp?
11:33:16 <amf> is it possible to check a type level string to see if it contains specific characters? if so, any examples?
11:33:54 <ja> luzaice: i prefer putting the trace call at the use site, not the definition site, since the definition may be unused and you'll be confused... that is the difference to printf
11:34:08 <ja> it is not imperative, it will only dump the output once needed (haskell is lazy)
11:34:17 <luzaice> i only use it when calling another function
11:34:36 <ja> you could put it in the argument in the call site
11:35:04 <ja> let's say you call "f temp". you can substitute it with "f (trace (show temp) temp)"
11:35:41 <ja> but i would recommend tucking it in a tuple as i did above, just so that you won't get so confused when you have more trace expressions
11:36:03 <luzaice> the code is short, so that shouldn't be a problem
11:36:09 <luzaice> i'll try, thanks
11:41:33 <luzaice> thanks ja, only needed to change a few numbers for the program to work, trace was a big help
11:41:43 <ja> great, i am so happy to have helped!
12:08:03 <sm[m]> trace needs a bit of practice and maybe some helpers before it becomes really easy
12:08:34 <sm[m]> traceShowId can be handy, and also combining a pretty printer like pretty-show or similar
12:56:48 * hackage gtk3-helpers 0.1.0 - A collection of auxiliary operations and widgets related to Gtk  https://hackage.haskell.org/package/gtk3-helpers-0.1.0 (keera_studios_ci)
12:57:49 * hackage gtk-helpers 0.1.0 - A collection of auxiliary operations and widgets related to Gtk+  https://hackage.haskell.org/package/gtk-helpers-0.1.0 (keera_studios_ci)
13:56:34 <fog> I'm having difficulty understanding the differences between the options we have available within haskell for composition of streaming approaches
13:56:53 <fog> there are conduity and pipes (not sure if these are connected) and machines, and probably others
13:57:08 <fog> how do these differ, and how are they similar?
13:57:25 <fog> is there a class they all satisfy?
13:57:35 <phadej> no
13:57:48 <phadej> they are to the first approximation very similar
13:57:59 <phadej> you are essentially picking between sub-ecosystems
13:58:34 <phadej> (e.g. there is servant-machines, servant-conduit, servant-pipes)
13:58:59 <fog41> are things like recursion-schemes also part of the same collection of techniques? 
13:59:06 <phadej> `streaming` is slightly different but still the same
13:59:32 <wavemode_> they could all be made into arrows. but nobody really likes arrows :p
13:59:40 <fog41> phadej: from that (servant) it seems that they must do similar things but essentially differ in terms of their API?
14:00:09 <fog41> wavemode_ everyone likes arrows! how are they phrased in that setting?
14:00:34 <fog41> its something to do with Applicative, right?
14:00:42 <solonarv> not really
14:01:21 <phadej> they streaming approaches are conceptually categories, but their kinds prevents them from having an instace
14:01:28 <fog41> oh i got confused, I thought that arrows were kind of superseded since the Applicative Monad proposal took effect.. i could be mistaken.
14:01:37 <phadej> and for streaming, you really mostly care about composition
14:01:52 <phadej> (piping from one to another)
14:02:01 <fog41> that sounds right
14:02:11 <phadej> and not about parallel composition (running two streams side by side, in some "lockstep")
14:02:23 <fog41> oh, i thought that was similar...
14:02:54 <fog41> i never understood wyes or whatever they are called, from machines
14:03:03 <phadej> you don't need to
14:03:06 <fog41> i thought they were something to do with branching connectors
14:03:25 <phadej> yes
14:03:35 <fog41> just in terms of "zip" for streams, this side by side thing you mentioned
14:03:52 <solonarv> in terms of what they were/are/can be used for in practice, arrows sit somewhere in between applicative and monad indeed
14:04:06 <solonarv> but it's messy to write down what exactly this means, so I won't :p
14:04:30 <fog41> oh yeah, so how can we do streaming with arrows? and why particularly arrow, and not apllicative or monad?
14:05:06 <solonarv> you can totally make monadic streams. in fact the 'streaming' library does just that!
14:05:19 <fog41> from what i recall, arrow has something to do with pairs. is that where the zip thing enters?
14:05:21 <solonarv> (conduit and pipes also provide monads, but it's a different monad instance)
14:05:56 <solonarv> oh actually I may be mixing the up the various streaming libraries, sorry
14:05:56 <fog41> ok, well if its more straitforwards just to consider monads and not worry about arrows then thats probably ok
14:06:22 <fog41> so, is "streaming" something to do with church encodings?
14:06:36 <fog41> or is that just one possible approach
14:06:45 <Cale> That's kind of not even the right question to be asking. There are lots of ways that might occur. The right question is: what ways do we have to connect our stream processors together and/or build them up out of smaller pieces? And then decide if there's an Arrow or Applicative or Monad instance or what-have-you.
14:06:58 <solonarv> there's really no particular relation between church encoding and streaming
14:07:01 <Cale> I mean the question about how to use Arrow
14:07:40 <Cale> In general, you can have arrows where the type MyArrow s t is some kind of thing that processes a sequence of inputs of type s and produces a stream of outputs of type t
14:07:42 <solonarv> church encoding is a particular way to encode ADTs which is sometimes more efficient than the straightforward Haskell way, so that is why some libraries use it.
14:07:59 <fog41> that seems fair Cale. i guess its even misleading to think of the Monad or Arrow abstraction if it isnt anything to do with streaming. i think i got the mistaken idea that somehow Arrow or monad kind of captured streaming itself
14:08:36 <fog41> solonarv: oh, what do you call (s,s->(a,s))? is that a scott encoding?
14:09:16 <fog41> im sorry, i feel bad when i get confused about these things. ill look up my ancient Church module, hang on
14:10:11 <solonarv> wait. are you the same person that went by the username 'fog' or 'fen' some time ago?
14:10:19 * ski . o O ( `Stream a' )
14:10:27 <fog41> oh, it seems more like Cont
14:10:28 <fog41> https://gist.github.com/fen-hs/a71ab735bf977d9b948a62416662fe57
14:10:49 <fog41> solonarv: yes, i changed handle when i abandoned that project
14:13:05 <fog41> rrg, something like, a continuation over a "set" function (like cons)
14:13:24 <fog41> "give me a cons, and ill give you back a full container"
14:14:04 <fog41> i guess thats why i thought it somehow embodied a "producer"
14:15:14 <fog41> seems like a partially applied fold
14:15:20 <ski> maybe you intended a quantifier on `s' in that type ?
14:15:51 <fog41> forall s. (s,s->(a,s))
14:15:54 <fog41> like that?
14:15:56 <fog41> why?
14:16:13 <ski> that looks fairly useless
14:16:22 <fog41> what did you mean, sorry
14:16:36 <ski> i was wondering what you meant
14:17:10 <fog41> oh, well (s,s->(a,s)) is just supposed to be "a state, paired with a state update function"
14:17:23 <ski> yes, i got that part
14:17:49 <ski> how were you intending to use that type ?
14:18:04 <fog41> with something like unfold
14:18:07 <fog41> :t unfoldr
14:18:08 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:18:26 <fog41> but for streams its;
14:18:37 <ski> so, something like `myUnfold :: (s -> (a,s)) -> s -> Stream a' ?
14:18:39 <fog41> (s -> (a, s)) -> s -> Stream a
14:18:44 <fog41> yeah!
14:18:53 <ski> well, that's really
14:19:09 <ski>   myUnfold :: forall a s. (s -> (a,s)) -> s -> Stream a
14:19:19 <ski> then
14:19:36 <ski>   flip myUnfold :: forall a s. s -> (s -> (a,s)) -> Stream a
14:19:51 <ski>   uncurry (flip myUnfold) :: forall a s. (s,s -> (a,s)) -> Stream a
14:19:54 <ski> or
14:20:05 <ski>   uncurry (flip myUnfold) :: forall a. (exists s. (s,s -> (a,s))) -> Stream a
14:20:13 <fog41> aha!
14:21:00 <fog41> and then i guess you would have to do the trick with continuation or Dict encodings? (i cent remember how you normally do exists)
14:21:01 <ski> and, you can also write `forall a. Stream a -> (exists s. (s,s -> (a,s)))' (well, presumably, assuming `Stream' is sensibly defined)
14:21:14 <ski> (and these two then ought to be inverse to each other)
14:21:18 <fog41> umm
14:21:21 <fog41> i guess you could
14:21:31 <fog41> but you might as well have s = Stream a
14:21:39 <fog41> and s -> (a,s) as "get"
14:21:45 <ski> anyway, one might call this a "State encoding", perhaps
14:22:25 <fog41> it seems like one way of doing it
14:22:34 <fog41> but i was wondering about conduit and pipes and machines
14:23:05 * ski haven't looked at them in detail
14:23:20 <fog41> (the only reason i like this "state encoding" is beacause it seems closer to haskell Prelude, traversable, Foldable etc)
14:23:57 <fog41> i thought they might have some techniques that could be borrowd
14:24:10 <fog41> like, for combining them, or having them handle monads nicely or something
14:24:39 <ski> @quote separation
14:24:40 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
14:24:40 <lambdabot> state.
14:24:54 <ski> @quote church.and.state!
14:24:54 <lambdabot> shapr says: Haskell separates Church and state!
14:24:54 <monochrom> :)
14:25:03 <ski> @quote are.dual
14:25:03 <fog41> "commingle" ?
14:25:04 <lambdabot> ski says: I'd rather say that in Haskell, Church and State are dual
14:26:03 <fog41> is this to say that the monadic streming (the mention of effects) is something else?
14:26:24 <ski> (call the encoding of `mu r. f r' as `forall r. (f r -> r) -> r' a "Church encoding", and the encoding of `nu s. f r' as `exists s. (s,s -> f s)' a "State encoding". `f' is a covariant functor in both cases)
14:26:51 <fog41> oh, abstracting over the pair, and the Maybe, nice
14:27:25 <ski> (er, s/nu s. f r/nu s. f s/)
14:27:50 <monochrom> Oh haha, that kind of church-state duality.
14:28:20 <fog41> so how do we get to compositionality from this?
14:30:08 <fog41> and, isnt there something like, from conduit, that kind of stream that is finite, and returns a different type as its last output?
14:31:20 <fog41> it seems like from machines thats called an "Iteratee" 
14:31:56 <fog41> data Iteratee i o = Done o | Cont (Input i -> (Iteratee i o, Input i))
14:32:01 <ezzieyguywuf> https://pastebin.com/j1k8aAJS is this hard to follow? could anyone suggest a way to refactor to make the logic more clear? Or do you think it's good as-is? (I realize that's an objective question)
14:32:29 <monochrom> pastebin.com redaction makes it hard to follow :)
14:32:44 <ski> (redaction ?)
14:33:07 <monochrom> Watch how it redacts the rest of the line after '
14:34:05 <ezzieyguywuf> I don't understand redaction either
14:34:14 <ski> ezzieyguywuf : `makeRayEdge : MaybeT TopoState Vertex'
14:34:29 <fog41> urgh, i give up
14:34:40 <ezzieyguywuf> maybe dpaste? http://dpaste.com/2YG83QG
14:34:55 <monochrom> Nah don't worry, I just click the "raw" button.
14:35:27 <monochrom> If you like to help, https://pastebin.com/raw/j1k8aAJS is a much better URL to post. :)
14:35:41 <ski> (you also have three pairs of redundant brackets)
14:35:43 <ezzieyguywuf> ski: ooh, MaybeT, was not aware of that.
14:35:44 <berndl> ezzieyguywuf: How about adding some comments?
14:36:00 <ezzieyguywuf> berndl: are you a freeCADer?
14:36:01 <Cheery> I wonder how I'm supposed to make a GUI in FLTKHS when the size of the window is not clear before it's populated.
14:36:15 <ski> ezzieyguywuf : i'd at least try to reformulate it (and calling code) with `MaybeT', and see whether it looks better
14:36:21 <ezzieyguywuf> also, berndl, fair point about comments
14:36:32 <ezzieyguywuf> ski: definitely worth a shot.
14:37:18 <ski> monochrom : i suppose whatever that redaction was about, it didn't happen when i viewed the page in W3m
14:37:22 <monochrom> I am less enthusiastic about going for MaybeT TopoState unless you have a ton of TopoState (Maybe X).
14:37:36 <fog41> hmm, pipe looks pretty cool;
14:37:37 <fog41> data Pipe i o a = Done a | Yield o (Pipe i o a) | Await (i -> Pipe i o a)
14:38:18 <ski> ezzieyguywuf : instead of `(/= 0) . length', possibly you could use `not . null'
14:38:23 <fog41> seems like it kind of wraps a get and a set function, and somehow has the container stored in cps style
14:39:22 <monochrom> Instead I have a feeling that idioms similar to "t <- get; (/= 0) . length . (Graph.neighbors (unTopology t))" are going to happen all the time, and you may like to package that up.
14:39:28 <merijn> ezzieyguywuf: Instead of having the really long composition in "case of" I'd just move that into, like, a where or let binding
14:39:49 <monochrom> Oh darn, you're going to use t multiple times, nevermind.
14:40:00 <fog41> (s,s -> Either o (a,s),(i,s) -> s)
14:41:02 <fog41> hmm, i guess i would normally have a ~ i
14:41:22 <fog41> i guess this allows pipes to map between types aswell, that seems worth stealing! woop
14:42:52 <ski> ezzieyguywuf : yea. it may be that the pattern you have there with `get' and possible subsequent `put' (perhaps together with the `Maybe' stuff) will be a repeating pattern, that you could in that case package up
14:43:26 * ski idly wonders about the name `unTopology'
14:44:18 <fog41> whats a topology? 
14:44:58 <ski> fog41 : that makes little sense to me, since in `Pipe i o a', `a' occurs covariantly / positively, while `i' occurs contravariantly / negatively
14:45:13 <ski> in ezzieyguywuf's case, it's basically a graph, iirc
14:45:31 <fog41> something to do with constructing a space by having local "charts" or something? like, patches that are glued together into the whole space, like how a remainein manifold is locally euclidean
14:46:01 <Boarders> does anyone know how you are supposed to use this function for a list of tokens as input: https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec.html#v:tokenPrim
14:46:14 <fog41> Await (i -> Pipe i o a) is not like (i,s) -> s ?
14:47:00 <berndl> fog41: topology is what you need to talk about continuity
14:47:46 <fog41> so whats this piece of code doing with vertexes and graphs? i cant see how that can be used to construct something like a smooth manifold
14:49:18 <ski> you could interpret `data Pipe i o a = Done a | Yield o (Pipe i o a) | Await (i -> Pipe i o a)' as `nu s. a + o * s + (i -> s)' which you could encode as `exists s. s * (s -> a + o * s + (i -> s))'
14:49:27 <berndl> fog41: You mean the makeRayEdge code?
14:49:32 <fog41> yeah
14:49:36 <Cale> ezzieyguywuf: (/= 0) . length  might be better as  not . null  if that's a list
14:50:05 <ski> heh, already noted that :)
14:50:08 <Cale> ah
14:50:24 <berndl> fog41: No clue.
14:50:36 <fog41> yah
14:50:40 <fog41> me neither 
14:51:29 <ski> ezzieyguywuf : if `connectNodes' fails, should the `addNode' be rolled back ?
14:51:48 * hackage multibase 0.1.1 - Self-identifying base encodings, implementation of <https://github.com/multiformats/multihash>  https://hackage.haskell.org/package/multibase-0.1.1 (KimAltintop)
14:51:58 <fog41> exists s. s * (s -> a + o * s + (i -> s)), so whats thats saying? and how would (exists s. s*(s ->a)) work? 
14:53:55 <ski> see <https://gitlab.com/ezzieyguywuf/haskellcad/-/raw/Entity/src/Entity.hs> (link provided a day or two ago, iirc) for some more on this topology stuff
14:54:47 <ski> fog41 : for `data Stream a = Cons a (Stream a)', it'd just be `exists s. s * (s -> a * s)', or, if you prefer, `exists s. (s,s -> (a,s))'
14:55:22 <fog41> s*(s->a) = ((s*(->)) s a) = ((\x y -> (x -> (y,s)))) s a = (s->(a,s))
14:55:48 <ski> `((s*(->)) s a)' makes no sense
14:55:55 <crestfallen> I began to understand the section of the hutton book on which I've been stuck for months. champagne reception to follow.
14:56:07 <fog41> i dont know how your mapping that product with s over the function arrow
14:56:38 <ski> i'm not
14:56:47 <fog41> ohh
14:56:52 <ski> crestfallen : great ! :)
14:56:57 <fog41> you must have had a typo
14:57:06 <crestfallen> ski YOU RULE
14:57:11 <fog41> exists s. s * (s -> a + o * s + (i -> s))
14:57:20 <fog41> exists s. s * (s -> (a*s) + o * s + (i -> s))
14:57:33 <fog41> or am i totally confused
14:58:26 <monochrom> I would say total fiction.
14:58:54 <ski> i have no idea how you arrived at your earlier `(s,s -> Either o (a,s),(i,s) -> s)', or your present `exists s. s * (s -> (a*s) + o * s + (i -> s))'
14:59:46 <fog41> you said; `exists s. s * (s -> a * s)
14:59:50 <ski> crestfallen : may i ask which section it was that was delaying you ?
15:00:26 <ski> fog41 : yes. that was for a different type (`data Stream a = Cons a (Stream a)', namely)
15:00:46 <fog41> its not just extrancting an `a' from the `s' but returning a new `s' which is somehow absorbed by the cps pipe
15:01:20 <ski> (anyway, i'm not too sure whether it'd be that   if (message.StartsWith("ACTION ") && message.EndsWith((char)1))
15:01:24 <ski>   {
15:01:26 <ski>       string[] actions = message.Trim((char)1).Split("ACTION ");
15:01:27 <ski>   }er
15:01:29 <ski>       SendPrivmsg(writer, chan, CTCPResponseString($"ACTION {actions[1]} too"));
15:01:32 <ski> sorry
15:02:31 <ski> (anyway, i'm not too sure whether it'd be that useful to reformulate (e.g.) `Pipe i o a' in terms of `exists' in this way ..)
15:02:34 <fog41> well, the (s,s -> Either o (a,s),(i,s) -> s) is supposed to say, a pair of a state, and a way to get an output and updated state, or a final (Done) value, and a way to insert values of type `i' into the state `s'
15:02:57 <fog41> nono, your exists is entirely confusing
15:03:38 <int-e> ski: that was an impressive accident, how'd you get an extra 'er' into the middle of a paste?
15:04:15 <crestfallen> it's the section with the state transformer ski. the state monad is introduced from the inception with ST. the book doesn't begin with ' newtype State s a = State { runState :: (s -> (a,s)) } '    but instead defines a function to use with the State type. I don't understand the pedagogy in that. mr. kmett told me in person "oh that's something completely different" so I lost faith in that section of the book. but on further study and reflection the 
15:04:15 <crestfallen> whole pie started to come into view
15:04:21 <ski> heh, i didn't realize i had a few characters left in my input buffer
15:05:14 * int-e also wonders what ski is doing with those poor CTCP actions.
15:05:35 <fog41> what kind of lexer is ski!?
15:07:28 <fog41> anyway, im not sure about Pipe, it seems too abstracted. i dont want to provide the ability for the eg, Awate function to return a pipe with a different Await function
15:08:08 <fog41> id rather have something like (s,s -> Either o (a,s),(i,s) -> s), where the thing that isnt a function doesnt contain any functions that could change when returned 
15:08:54 <ski> crestfallen : hm. i guess ed meant that the definition of `ST' in the book is different from something that also happens to be called `ST', in libraries (and that was confusing some other people that were looking at some code you were asking about, previously)
15:09:08 <fog41> the "data" that is stored and modified, and used to produce outputs or consume inputs, shouldnt have changing set and get functions
15:09:47 <ski> crestfallen : some books focus more on building things up from the ground, others more on teaching how to use them effectively, i guess
15:09:53 <fog41> ok, im happy to not use pipe or machine
15:09:56 <fog41> for that reason
15:10:00 <fog41> but what about conduit?
15:11:00 <ski> crestfallen : hm, i don't recall if i suggested it to you before, but did you try to write a `labelTree' function that replaces each element of a tree with a pair of that element, and an integer label, starting to count up from zero ?
15:11:27 <fog41> ah, it wraps something similar to pipe, but with even more complexities
15:11:36 <fog41> i think ill just stick with this state encoding
15:11:39 <ski> crestfallen : that might be a nice exercise to do, both without, and with, something like this `ST'
15:11:44 <crestfallen> yeah that rings a bell. my sense was he wasn't happy with how it was presented and dismissed it. but I could be mistaken what he was saying. re: labelTree ....
15:12:13 <crestfallen> the next section of hutton after the State Monad involves that very thing I believe.
15:12:26 <fog41> why wouldnt you just use traversei ? or mapi for that matter...
15:12:28 <ski> mm, could be
15:12:54 <berndl> fog41: how about streamly?
15:12:59 <fog41> ok!
15:13:31 <ski> fog41 : this is to reinforce how to work with state idiom/monad
15:13:48 <fog41> ohh
15:13:49 <crestfallen> after instance Monad ST I should have said
15:14:25 <fog41> well, you could see how mapAccumL is written by traversing with the state transformer to implement traversei
15:15:37 <ski> fog41 : why `Either o (a,s)' rather than `Either a (o,s)' ?
15:15:58 <crestfallen> yeah so now I have a basic understand of monad and the state monad; it's a good day. I was subconsciously intimidated by it
15:17:23 <ski> crestfallen : assuming something like `data Tree a = ..a..', i'd start with attempting to write say `labelTree :: Tree a -> Tree (Int,a)'
15:17:55 <fog41> ski: o is "final output", i got confused about what pipe was doing. but, i need something like that for "tape scanners" that are kind of state consumers combined with list-like things, that can still return a state, even after they have exhausted the values 
15:18:02 <ski> i think it could be instructive, both to see the version that doesn't use a state monad, and to compare with the version that does
15:18:29 <ski> fog41 : oh. in `Pipe i o a', i think it's `a' that's "final output", no ?
15:19:14 <fog41> berndl: streamly looks pretty intense. not sure its what im after, it defines "state" to be just a bunch of data, like, nanoseccond delay and stuff
15:19:38 <fog41> seems like the fundamental Stream datatype is here; https://hackage.haskell.org/package/streamly-0.7.2/docs/src/Streamly.Internal.Data.Stream.StreamK.Type.html#Stream
15:19:51 <fog41> ski: yeah i got mixed up sorry
15:20:40 <fog41> at the moment, all i have is that instead of using Maybe for when it runs out of values, this can be `Either something'
15:21:07 <fog41> which is a modification to the type of "get"
15:21:32 <fog41> set stays the same, i think, though there could be the kind of inverse where it takes a special input to initilize it
15:22:06 <fog41> and other than that, the tripple of the state with its get and set methods still just seems like an instance of Get and Set as classes
15:22:28 <fog41> oh, i was supposed to be seeing how these things managed to make combinators
15:24:02 <fog41> when i think of that, i think of monoid, and concat, and then commuting list through; a list of streams, into a stream of lists
15:24:15 <fog41> idk if im missing some subtle other cases
15:25:03 <ski> tbh, i can't recall in detail your setup with your `Get' and `Set' classes, nor the `Get0',`Get1',`Set0',`Set1' variants
15:25:03 <fog41> like, as long as i can do, end to end composition, which seems like build fold fusion, and side by side composition, which seems like some kind of monoid or zip
15:25:21 <fog41> yeah it was a total mess tbh
15:26:01 <fog41> get0 was for when there was an empty (0 values) 1 varients were for nonempty (at least one value) and the ....
15:26:11 <fog41> wait, thats what would have made sense, but its not that, 
15:26:16 <fog41> anyway never mind
15:26:29 <fog41> i think the 0 values were for infinite streams
15:26:31 <monochrom> This is why programmers need to delete more code.
15:26:51 <fog41> well, i never managed to get the abstraction that captured all the cases exhaustively 
15:27:05 <fog41> and this was the most complete version I had
15:27:11 <fog41> even if it was named like crap
15:28:10 <fog41> i had some insane attempt with type families where there were tags which named if it was finite or not etc, or nested
15:28:18 <fog41> and then i strated trying to write nested states
15:28:30 <fog41> i cant remember what happened after that
15:29:23 <crestfallen> yeah ski it's the same exercise I'm pretty certain. yay!
15:29:56 <ski> so you're on track for it then, crestfallen :)
15:30:38 <fog41> oh right, yeah, then it was trying to do everything hetroginously
15:31:01 <fog41> because the graphs shapes and had graphs with different shapes as leafs 
15:32:36 <fog41> i think this was about as far as I got with that; https://gist.github.com/fog-hs/5e47725b694fdfa3414550ef1eb96b0f
15:35:11 <ph88^> does not being to specialize hurt performance a lot ?
15:36:13 <wavemode_> I wouldn't say a _lot_. and it depends on the application
15:37:01 <wavemode_> it's like a virtual call in an OOP language. usually prevents inlining and certain optimizations
15:38:11 <ph88^> thanks
15:38:47 <ph88^> what's an unsafe warning about ?
15:39:42 <merijn> ph88^: Which warning are you talking about?
15:39:44 <ph88^> i have read this https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/safe-haskell.html 
15:39:54 <ph88^> -Wunsafe
15:40:07 <merijn> ph88^: wow
15:40:14 <merijn> ph88^: You wanna got to more recent docs ;)
15:40:22 <ph88^> ye
15:40:48 <merijn> ph88^: Anyway, That's related to Safe Haskell, I'm not sure how much that's used nowadays
15:41:10 <ph88^> why isn't used ?
15:41:37 <fog41> im slightly worried about pasting code which does not compile that i havent read; https://github.com/fog-hs/mess
15:41:51 <fog41> but i think thats about as close as i got to making "tags" and nested states
15:41:58 <merijn> ph88^: It's not particularly useful, because people most prefer to just not run untrusted code :p
15:42:04 <ph88^> fog41, link doesnt work
15:42:35 <ph88^> merijn, does it give any benefits from preventing code from crashing or performance ?
15:42:50 <crestfallen> I'm so glad ski . in retrospect everything looks easy; but I still haven't gained the confidence to understand that
15:43:34 <merijn> ph88^: Safe Haskell basically tells the compiler to verify there's no unsafe functions (unsafePerformIO, unsafeCoerce, etc.) being called in modules, except in those of trusted packages
15:43:36 <monochrom> Lower confidence is correlated to higher understanding. Dunning-Kruger. All is not lost.
15:43:41 <fog41> ph88^ oh, i think i had to change the privacy
15:43:45 <fog41> does it work now?
15:44:02 <crestfallen> monochrom, that's interesting! I agree
15:44:19 <ph88^> fog41, yes
15:44:20 <merijn> ph88^: But managing that is a lot of busy work, and for what?
15:44:29 <wavemode_> no, safe haskell doesn't protect code from crashing or throwing exceptions. it prevents code from cheating the type system
15:45:20 <fog41> https://github.com/fog-hs/mess/blob/master/current%20-%20Copy/redo%20mad%20Zipper.hs#L82
15:45:50 <ski> crestfallen : hm, to understand what ?
15:46:06 <fog41> im sure thats the worst code ever written
15:46:50 <crestfallen> ski just that although things seem easy in retrospect, I still resume to the attitude that I'll never learn the subject well
15:48:15 <ski> mhm, okay
15:49:34 <crestfallen> but I'm making a breakthrough with my focus. I actually made dietary changes and notice significant improvement in focus/memory. 
15:50:22 * ski nods
15:51:09 <crestfallen> very excited about it
15:51:33 <ph88^> -Wmissing-deriving-strategies  No deriving strategy specified. Did you want stock, newtype, or anyclass?   Use DerivingStrategies to specify a strategy.
15:51:41 <ph88^> why should i care about this ?
15:51:55 <xenon-> crestfallen, interesting, what changes did you make?
15:52:42 <koz_> ph88^: It's not a bad thing to be specific.
15:52:47 <koz_> What are you deriving, and on what?
15:52:54 <crestfallen> xenon-, I'd be happy to explain, in a pm or here in the channel - but I'm near-evangelical, so be warned :)
15:53:00 <ph88^> Generic, Show, Read, Eq
15:53:09 <koz_> ph88^: Is this a data, or a newtype?
15:53:12 <ph88^> on a record
15:53:15 <koz_> Ah.
15:53:21 <koz_> Then do 'deriving stock' for all those.
15:53:25 <xenon-> crestfallen, that's ok. PM is fine, there's on topic conversation going on
15:53:30 <ski> perhaps in #haskell-offtopic then, crestfallen
15:53:36 <xenon-> or that
15:53:37 <ph88^> koz_, can do ... but why
15:53:51 <koz_> Basically, we have a lot of different ways to derive things.
15:54:22 <koz_> We can either use GHC itself, we can 'borrow' stuff from a newtype, or go via Generics.
15:54:40 <koz_> Sometimes, this can cause ambiguity (GeneralizedNewtypeDeriving and DeriveAnyClass is the classic example).
15:54:43 <Cheery> class Functor (b t) => Behavior b where
15:54:50 <koz_> So if you say 'deriving stock', it means 'use GHC itself'.
15:54:50 <Cheery> this thing says t is not in scope
15:55:07 <koz_> As opposed to 'deriving newtype' which says 'borrow whatever definition of the thing we're newtyping over'.
15:55:18 <koz_> Or 'deriving anyclass' which is 'go via Generics' (essentially).
15:55:29 <koz_> (although that's a bit of a white lie before someone bludgeons me over the head)
15:55:35 * ski sometimes writes manual `Show' instances for data types defined with record syntax, in order to have `Show' not output record syntax
15:55:38 <koz_> There's also 'deriving via', which lets you borrow from a _different_ newtype.
15:56:07 <koz_> So I believe spelling these out is good practice anyway, even in cases like yours which are not ambiguous.
15:57:07 <ph88^> thank you koz_ 
15:57:30 <koz_> ph88^: No worries. I'm a recent convert to explicit deriving strategies, and it really makes a lot of things a lot easier.
15:57:49 <ski> Cheery : how's it to know which `t' to consider, when you're making an instance `Behavior b' for some particular `b' ?
15:58:51 <ski> Cheery : is it supposed to assume `Functor (b t)' for all `t's ? or maybe the choice of `b' is supposed to determine a particular choice of `t' that is to be considered ?
15:59:06 <Cheery> yeah, I'd want it to say "for all t2
15:59:37 <ph88^> koz_, what does it make easier ?
16:00:03 <koz_> ph88^: One good example recently - I needed an Arbitrary instance over a newtype that just borrows the underlying Arbitrary instance of the thing I'm wrapping.
16:00:14 <Cheery> ski: mainly so that when there's Behavior b => type constraint, then (b t) is already considered a functor.
16:00:24 <ski> Cheery : could you try with `class (forall t. Functor (b t)) => Behavior b', then ?
16:00:44 <ph88^> koz_, what would happen without specifying the deriving strategy ?
16:00:52 <koz_> I can spell that as 'deriving (Arbitrary) via Foo'.
16:01:08 <koz_> ph88^: There's a default choice you can investigate by reading the GHC user guide.
16:01:32 <koz_> However, I would say that if you have to ask this question, the merits of explicit strategies already speak for themselves.
16:04:17 <ski> jjkhnmyuim,m                          l                                                k,                           
16:04:35 <koz_> ski: Face hit keyboard?
16:04:49 <monochrom> catface facekeyboard
16:05:25 <monochrom> CEBHAK = cat exists between human and keyboard :)
16:05:35 <ja> koz_: if there were no deriving via, would you need to explicitly define the instance?
16:05:40 <koz_> On the Internet, nobody knows you're a cat.
16:05:56 <younder> except haskellers
16:06:04 <koz_> ja: I could probably use 'newtype' there.
16:06:14 <ja> how would that be inferior?
16:06:17 <koz_> Realistically, it's useful for borrowing the instances on another wrapper.
16:06:20 <koz_> In this case, no difference?
16:06:25 <koz_> A good example would be, say something like
16:06:42 <koz_> 'newtype Foo = Foo Word deriving (Semigroup, Monoid) via (Sum Word)'
16:06:52 <koz_> That would be a _lot_ more annoying to write without deriving via.
16:07:28 <ski> (managed to drop something on keyboard)
16:07:39 <koz_> If you want to see true deriving via gore^Wusage, follow Iceland Jack on Twitter for more than 1 day. :P
16:08:05 <ja> yeah i am following him but i am not investing the time in actually understanding the magic
16:08:19 <koz_> ja: All the magic there is really just coerce.
16:08:29 <koz_> Because you can coerce through any number of newtypes in either direction.
16:08:50 <koz_> So in the case above, it would just emit the equivalent of 'coerce' on all class methods, just with some direction as to what we're coercing to and from.
16:09:09 <koz_> It's not really all that magical if you get how coerce works - it's just syntactic sugar over that, basically.
16:09:35 <ja> i don't know how coerce works, better read up on that
16:09:44 <koz_> There's a paper that explains it well.
16:10:37 <koz_> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
16:10:46 <koz_> It pretty much explains the core ideas.
16:11:32 <ja> thanks, i'll read it after the daily venture outside :O
16:11:46 <koz_> ja: It's quite readable.
16:11:51 <koz_> (as SPJ papers tend to be.
16:11:53 <koz_> )
16:12:17 <younder> corerce with koz
16:12:34 <koz_> younder: That sounds like a proposition.
16:17:00 <ezzieyguywuf> ski: yes, I was going to move the 'addNode' till after the case
16:17:42 <ezzieyguywuf> monochrom: I don' expect to have a TON of TopoState (Maybe X). But a few.
16:18:11 <ski> ezzieyguywuf : could be worth it with some `MaybeT TopoState', still
16:18:31 <ezzieyguywuf> (still catching up on y'alls messages, on sec ski)
16:19:20 <ezzieyguywuf> merijn: I was going to ask specifically about the long chains of "case of" - is this atypical haskelling? I was tempted to do an "if-then" but I don't even know how to use if-then in haskell :-P
16:19:49 <ski> there is no `if'-`then', there's only `if'-`then'-`else'
16:19:56 <ski> (and `when',`unless' ..)
16:20:07 <ezzieyguywuf> ski: fog41 (you left) yes, Topology is an fgl Data.Graph
16:21:04 <ezzieyguywuf> sorry for the delayed responses y'all, as soon as I posted the wife and child pulled me away :-D
16:22:22 <ezzieyguywuf> ski: you're not a fan of 'unTopology'? the name or the use?
16:24:40 <ski> ezzieyguywuf : i dunno. the name just sounded a bit confusing to me. perhaps only because i don't recall its type
16:25:35 <ski> @hoogle Alternative i => Bool -> i a -> i a
16:25:37 <lambdabot> Shelly.Lifted escaping :: MonadShControl m => Bool -> m a -> m a
16:25:37 <lambdabot> Shelly.Lifted print_stdout :: MonadShControl m => Bool -> m a -> m a
16:25:37 <lambdabot> Shelly.Lifted print_stderr :: MonadShControl m => Bool -> m a -> m a
16:25:58 <ski> ezzieyguywuf : no worry
16:26:17 <ezzieyguywuf> ski: I thought it was typical to have something like `newtype MyType = MyType {unMyType :: Int}
16:26:20 <ezzieyguywuf> maybe not...
16:28:02 <ezzieyguywuf> anywho, Is there a way to 'bail out' in a chain of >>= if one of them returns a certain value? i.e. `a >>= b >>= c >>= d` but stop at, say, `b` if `a` resulted in a certain value?
16:28:48 <ski> that's basically what `MaybeT' (and `ExceptT') is for
16:29:23 <ski> to "short-circuit" it
16:31:11 <ja> ezzieyguywuf: also, gabriel gonzales (hope i spelt it right this time) has a blog post on making break (from c) in haskell
16:31:21 <ja> but if you're not porting a c program, maybe that isn't the best way
16:31:58 <Cale> You could use ContT/callCC for that, but my recommendation would be to use none of these things
16:32:16 <ja> ContT, is that shift/reset?
16:32:22 <Cale> callCC
16:32:43 <Cale> callCC $ \ret -> do ... ret i ...
16:32:53 <Cale> will work just like return does in most imperative languages
16:32:59 <Cale> and return the value from the callCC
16:33:19 <ja> but does it work well with monad transformers?
16:33:25 <Cale> It is a monad transformer
16:33:34 <ja> oh right, you write ContT
16:34:53 <Cale> Personally, most of the time I much prefer the code to visibly reflect the branching structure
16:35:59 <Cale> MaybeT and ExceptT can be fine for failure, I'm not a huge fan of using them for success
16:36:32 <ski> "for success" ?
16:37:10 <Cale> I mean, throwing an exception to indicate that the operation has finished early
16:37:16 <Cale> (successfully)
16:37:42 <ski> ok
16:37:44 <ja> what is the alternative?
16:37:54 <Cale> if/case expressions
16:41:29 <Cale> There are probably cases where my preference here breaks down, but I usually prefer to be able to think that if a do-block begins executing, unless something goes horribly wrong, all the actions in that block are going to happen.
16:43:19 <EvanR> data Problem e = NoProblem | YesProblem e
16:43:34 <Cale> haha
16:45:06 <EvanR> though having your types designed to mean "no problem" in the first place seems more straightforward
16:50:02 * ski . o O ( `data ExitCode = ExitSuccess | ExitFailure Int' )
16:51:03 <EvanR> ExitFailure 0
16:51:20 <hpc> just use Maybe and unsafeCoerce it
16:52:36 <ski> % import System.Exit
16:52:36 <yahb> ski: 
16:52:39 <ski> % exitWith (ExitFailure 0)
16:52:39 <yahb> ski: *** Exception: exitWith: invalid argument (ExitFailure 0)
16:53:25 <EvanR> lol
16:53:44 <EvanR> terrible
17:03:49 * hackage finitary-optics 1.0.0.0 - Prisms and Isos between finitary types.  https://hackage.haskell.org/package/finitary-optics-1.0.0.0 (koz_ross)
17:19:35 <ezzieyguywuf> do you all have any preferred pretty printing library?
17:19:50 <Clint> prettyprinter
17:19:59 <ezzieyguywuf> I've been using prettyprinter, it works very nicely. It specifically says "you can't do columns though", I'm wondering if there are other stuff out there that can
17:20:11 <ezzieyguywuf> or is prettyprinter like a de facto standard or something?
17:20:17 <koz_> Yep, I agree with prettyprinter as a choice.
17:20:27 <koz_> No, it just happens to be what the given respondents like.
17:20:33 <koz_> And the respondents to me liked.
17:20:35 * ezzieyguywuf nods
17:20:36 <ezzieyguywuf> fair enough
17:20:40 <ezzieyguywuf> as I said, it works very nicely
17:20:45 <ezzieyguywuf> mostly curious
17:20:45 <koz_> It does indeed.
17:20:47 <dmwit> ?hackage boxes
17:20:47 <lambdabot> https://hackage.haskell.org/package/boxes
17:20:59 <dmwit> depending on what you mean by "do columns"
17:23:10 <ezzieyguywuf> http://dpaste.com/1GK7SBM, this was made with pretty printer. It means "V0 has nothing pointing into it, and it points to E0. E0 has V0 pointing into it, and it points to nothing"
17:23:24 <ezzieyguywuf> I'd rather use just "->" and put the "into" relationship to the left
17:23:31 <ezzieyguywuf> that's what I mean by "do columns"
17:24:04 <ezzieyguywuf> maybe there's a way to do this in prettyprinter but I don't think so, especially because V0 could have many things pointing "in" to it, requiring multiple rows
17:24:19 * hackage ipfs 1.0.3 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.0.3 (expede)
17:24:46 <dmwit> boxes can do that
17:25:00 <ezzieyguywuf> neat! I'll make a note to check out boxes.
17:33:34 <fog> ezzieyguywuf: i got your message, but checking Data.Graph, i dont see any mention of topology or topos
17:34:37 <fog> is that just something you were constructing using that library?
17:35:58 <fog> i think its a pretty cool idea. i like the idea of mathematical structures being representable in haskell
17:37:24 <fog> especially things like polynomials, or manifolds
17:37:24 <fog> but whats the advantage of taking the extra stage of abstraction from manifold to topology?
17:37:42 <fog> are there more interesting structures from within programming that could be considered as topologies
17:37:44 <fog> ?
17:37:52 <fog> like how we use categories 
17:39:26 <ski> fog : did you see <https://gitlab.com/ezzieyguywuf/haskellcad/-/raw/Entity/src/Entity.hs> yet ?
17:41:01 <fog> i dont really understand topology at all, but is it something like metric spaces? as in, that there would exist a notion of distance a possibly curvature?
17:41:24 <fog> ski: nice, curves within spaces seems strong
17:41:43 <ezzieyguywuf> fog: when I say "topology" I specifically mean "the relationships between Vertices, Edges, and Faces in a Solid"
17:42:01 <ezzieyguywuf> so my use of the word is extremely specific, whereas generally it means a whole lot more
17:42:07 <fog> what do you call those? polytopes?
17:42:08 <ezzieyguywuf> it as to do with sets and set theory and stuff
17:42:31 <ezzieyguywuf> fog: probably, er,...polyhedra
17:43:13 <fog> i think you get polytopes in compressed sensing, from convex hulls and stuff
17:43:38 <ezzieyguywuf> ski: yes, Entity is going to show a very good use-case for what I'm calling "Topology"
17:43:54 <fog> like, with multiple plane sections in a high dimensional space
17:44:22 <fog> from constrained optimisation problems. so it appears as "polytope" in much of the literature
17:44:33 <ezzieyguywuf> ski: a, maybe you're referring to the helpful description at the top ^_^
17:45:38 <ski> yes
17:46:20 <fog> https://arxiv.org/pdf/math/0607364.pdf
17:49:26 <ezzieyguywuf> fog: I'm really only interested in the three dimensions though
17:49:30 <ezzieyguywuf> maybe a fourth for animating
17:51:11 <fog> fair. the high dimensional stuff is for exploring phase spaces eg. of neural net approximators for hierarchical representations of chemical species  
17:51:43 <ezzieyguywuf> hah, seems too complex for my humble brain
17:52:49 <fog> well, instead of time evolution carving a path in the space of possible configurations of a scene, it could be a learning path for instance
17:53:24 <fog> i think its related to a subset of functional programing dealing with function approximators 
17:53:36 <fog> but i havnt really got my head round it
17:54:06 <fog> i guess i was excited, i thought you had a legit representation of the notion of topology
17:54:30 <fog> i recall something similar to do with rings of polynomials 
17:55:19 * ski . o O ( "Synthetic topology of data types and classical spaces" by Martín Escardó at <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)> )
17:55:51 <fog> https://www.cs.bham.ac.uk/~mhe/papers/syntop.pdf
18:00:33 <fog> "classical topology via the lambda calculus"  
18:00:36 <fog> sounds about right
18:01:34 <fog> pretty heavy material though, well complicated
18:02:06 <fog> would be cool to have a notion of programs as sections of bundles though, everything else seems to be
18:03:13 <dolio> Dependently typed functions are sections of bundles.
18:05:08 <ezzieyguywuf> there's a book called "topology without tears" or something
18:05:10 <ezzieyguywuf> seems very approachable
18:05:13 <ezzieyguywuf> I didn't get too far
18:10:58 <monochrom> And what would be "topology with tears"?
18:11:15 <monochrom> Answer: topology without donuts. :sadface:
18:13:57 <dolio> F : A → Type is a fibration, Σ A F is the total space/bundle, and functions with type Π A F correspond to sections f : A → Σ A F, where fst (f x) = x.
18:17:37 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/tracing.html :)
18:19:11 <fog> and then do you get moduli spaces, of sheaves or something?
18:19:51 <fog> i think that would lead to quantization 
18:24:19 <fog35> and if you could construct weyl chambers you could get spinnors!  
18:24:49 <sshine> today I learned: Data.Bifunctor.first works on Either while Control.Arrow.first doesn't.
18:24:59 <koz_> sshine: Huh. TIL.
18:25:01 <fog35> pretty strange to have complex numbers or Clifford algebras though. but at least then you could get a wick rotation
18:25:38 <fog35> what would an imaginary haskell program be!?
18:25:40 <maralorn> sshine: Yeah, that was listed a few days ago as "the last annoying name collision in base".
18:26:08 <sshine> koz_, I tried Control.Arrow out of habit, and thought afterwards "I could always do 'bimap f id'", and after doing this, I thought "maybe they gave that a name". :-D
18:26:27 <koz_> sshine: THey also gave 'bimap id f' a name! :P
18:27:30 <sshine> maralorn, we've come that far?
18:27:41 <ski> categorical products, and categorical coproducts, are bifunctors
18:27:43 <sshine> maralorn, I suppose there are still annoying things that don't collide, then. :-P
18:28:01 <ski> @type first
18:28:02 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:28:03 <ski> @type left
18:28:04 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
18:36:29 <ezzieyguywuf> monochrom: for a donut you just increase G by one, https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/model/euler.html
18:36:34 <ezzieyguywuf> for a coffee cup, you increase by two.
18:37:01 <ezzieyguywuf> oh no, I think a coffee cup is one
19:19:37 <monochrom> :)
19:54:49 * hackage greskell-core 0.1.3.4 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.3.4 (debugito)
19:55:49 * hackage greskell 1.1.0.2 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.1.0.2 (debugito)
20:13:59 <gcoakes[m]> Hey, is anyone here familiar with Servant? I have a working basic Crud server, and I'm trying to generalize it further by abstracting over the actual data structure which is stored.
20:19:03 <dmwit> Maybe just ask your question?
20:23:56 <gcoakes[m]> I have 4 data types which I think could be abstracted over: the actual domain model of the item, the description of a new item, the description of a partial update of an item, and the data model for persistent.
20:23:56 <gcoakes[m]> I think with functions which tranform between those, I could make a generic server implementation which doesn't deal with inserting or getting from the database. Instead, I would just provide the transformations and get back a ServerT instance. Is this the correct case of making a type family?
20:24:27 <gcoakes[m]> Btw, this is just for learning purposes, I recognize it would probably be easier to just copy and paste the server implementation.
20:25:09 <gcoakes[m]> And, it would probably be better at scale because presumably other models would want additional endpoints.
20:26:50 <gcoakes[m]> I was thinking something like associated types for each of those models, but I'm having a hard time getting a hang of how to use type classes.
20:26:57 <gcoakes[m]> *families
20:32:56 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/ZNqKdNujgEaitBSIDZzCVfSC >
20:40:52 <gcoakes[m]> Nevermind, I'm just moving on.
20:40:59 <ski> `db',`item',`new',`update' are not parameters of `CrudServer'
20:41:24 <gcoakes[m]> Oh
20:42:44 <ski> with `CrudServer' being parameterless, you can have at most one instance of it
20:43:18 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/SHeZWQBvQxgWgBqdCwdoWqCr >
20:43:52 <gcoakes[m]> I'm not certain how I actually use the associated types.
20:44:57 <ski> what is the point of the (associated) `data' types `CrudDbModel',`CrudModel',`CrudNewModel',`CrudUpdate' .. you don't seem to refer to them, in the method signatures, at least ?
20:46:02 <gcoakes[m]> I'm not certain. I originally thought that's how I could use multiple data types in the functions, but I think with them being parameters, I can just remove the associated types.
20:46:04 <ski> associated types is a way to have a type that is implemented differently, in different instances of the type class
20:47:31 <ski> e.g. instead of having `class Foo a b | a -> b where blah :: ..a..b..' you could have `class Foo a where type B a; blah :: ..a..(B a)..'
20:47:50 <gcoakes[m]> Do I have to refer to all the parameters of the type class in all of the functions?
20:48:20 <gcoakes[m]> I'm getting complaints about not being able to deduce some of the types.
20:48:51 <wavemode_> without functional dependencies, multi parameter type classes frequently give rise to ambiguous types
20:49:23 <ski> and instead of `instance Foo Int Bool where blah = ...' and `instance Foo a b => Foo [a] (Maybe b) where blah = ..blah..' you would then have `instance Foo Int where type B Int = Bool; blah = ...' and `instance Foo a => Foo [a] where type B [a] = Maybe (B a); blah = ..blah..'
20:50:17 <ski> gcoakes[m] : "Do I have to refer to all the parameters of the type class in all of the functions?" -- yes, you have to refer to them in all method signatures, unless some of them can be functionally determined from the mentioned ones
20:50:27 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/tXrLOHGXlwdEiAyHjDqqxJnG >
20:51:19 <ski> if there's not enough sensible FDs to add, the usual way around this is the same as in relational database design : normalize your relations (in this case, type classes), i.e. split them into multiple type classes
20:51:47 <wavemode_> oh I see
20:52:22 <wavemode_> yes, haskell won't automatically deduce those constraints. which is why you would put them on the functions, not on the typeclass itself
20:52:29 <dmj`> gcoakes[m]: why not use a vanilla Haskell record for this, most adhoc typeclasses like this are lawless, and get desugared into records anyways
20:52:57 <ski> gcoakes[m] : are there any sensible FDs in your case ?
20:53:00 <dmj`> gcoakes[m]: data DbCtx rec = DbCtx { insert :: rec -> IO () }
20:53:01 <gcoakes[m]> ski: By split them into multiple type classes, do you mean have one type class for the conversion from new to db, one for db to item, etc...
20:53:26 <ski> depends on what FDs you have
20:54:17 <gcoakes[m]> Maybe I'm not really understanding the purpose of functional dependencies.
20:54:54 <ski> gcoakes[m] : do you have multiple instances in mind for your `CrudServer' type class ?
20:55:40 <ski> (if you don't, i'm not sure whether there's much point to define a new type class .. at least at this stage)
20:56:27 <gcoakes[m]> Mostly because it looked like a fun exercise. It's just a toy program right now providing the most basic CRUD operations.
20:56:47 <gcoakes[m]> I currently have a Book model along with the associated new, update, and database representations.
20:57:09 <wavemode_> I agree with dmj that this probably doesn't need to be a typeclass at all
20:57:26 <gcoakes[m]> I thought it wouldn't be terribly difficult to abstract over those types and provide a generic implementation of the server since it would really only require the transformations between each other.
20:58:01 <gcoakes[m]> I'm not set on a type class. I just thought that was the correct way to do it.
20:58:03 <ski> FDs serve two purposes. one is to encode a domain constraint that some parameters determine some other parameters (this will be enforced so that you can't attempt to make multiple instances which together violate the constraint). the other is to reduce the number of ambiguity issues you run into, when using the type class, so that you have to do less type ascriptions or other ways of telling the type checker which type you intended
20:58:56 <ski> generally, you should no reach for defining a new type class, unless you have at least two different instances of it in mind
20:59:48 <ski> .. and, usually there should also be some operation that you'd like to define, which is polymorphic over instances of the type class
20:59:49 <gcoakes[m]> Well, the two instances I had in mind were Books and Movies.
21:00:20 <ski> so, `db' being `Book' respectively `Movie' ?
21:00:50 <ski>   instance CrudServer Book BookItem BookNew BookUpdate where ...
21:00:53 <ski> and
21:00:55 <gcoakes[m]> db being the PersistEntity representing how it is placed in the database.
21:01:07 <ski>   instance CrudServer Movie MovieItem MovieNew MovieUpdate where ...
21:01:08 <ski> ?
21:01:16 <gcoakes[m]> Yes, exactly
21:01:51 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/bOvCKtlfdSTjRMKeHBwekvWA >
21:02:07 <ski> are the `item',`new',`update' parameters to be determined by the `db' parameter ?
21:02:44 <ski> could you possibly have an instance `CrudServer Book BookItemB BookNewB BookUpdateB' with the same `Book' for `db', but different types for `item',`new',`update' ?
21:03:50 <gcoakes[m]> I guess it would be the `db`, `new`, and `update` being determined by the `item` parameter because the item parameter is the broadest record. It contains all the fields that `db` has along with the the database key.
21:04:14 <gcoakes[m]> No, I couldn't have multiple instances of CrudServer for Book.
21:04:40 <ski> well, you should identify all the sensible FDs for `CrudServer'
21:06:42 <ezzieyguywuf> how do I use `when`? I'm confused - this is how I'm trying http://dpaste.com/1RDV5G5#line-4
21:07:14 <ski> gcoakes[m] : i guess you have at least the three FDs `item -> db new update', then
21:07:20 <wavemode_> ezzieyguywuf, what error are you getting?
21:07:32 <ezzieyguywuf> "Couldn't match type ‘()’ with ‘Maybe Vertex’"
21:07:38 <ski> gcoakes[m] : so `db' determines which of the other parameters ?
21:07:43 <ezzieyguywuf> which makes sense given the call signature of `when`. But then...how do I use it? lol
21:07:49 <wavemode_> what is the type of isValidNode
21:07:56 <wavemode_> oh
21:08:06 <ezzieyguywuf> isValidNode :: Topology -> Int -> Bool
21:08:09 <dsal> :t when
21:08:11 <lambdabot> Applicative f => Bool -> f () -> f ()
21:08:28 <dsal> You could use MaybeT
21:08:36 <wavemode_> when does `return ()` if the condition is false. so of course it won't return what you're trying to return
21:09:05 <ezzieyguywuf> indeed
21:09:16 <ezzieyguywuf> is when typicall used in MaybeT?
21:09:26 <ski> ezzieyguywuf : no, you can't use `when' there
21:09:44 <wavemode_> you could just write a manual if then else
21:10:56 <ski> if there was an `Alternative i => Bool -> i a -> i a', you could use it, with `MaybeT'
21:12:52 <ski> @let guardWhen :: Alternative i => Bool -> i a -> i a; guardWhen b act = if b then act else empty
21:12:53 <lambdabot>  Defined.
21:12:57 <ezzieyguywuf> here's what I ended up with http://dpaste.com/2XSYJE4#line-173
21:13:04 <ski> @let guardUnless :: Alternative i => Bool -> i a -> i a; guardWhen b act = if b then empty else act
21:13:05 <lambdabot>  .L.hs:168:1: error:
21:13:06 <lambdabot>      The type signature for ‘guardUnless’ lacks an accompanying binding
21:13:06 <lambdabot>      |
21:13:09 <ezzieyguywuf> my first time using if-then-else
21:13:26 <ezzieyguywuf> seems sloppy, especialy the way it is nested
21:13:36 <ski> @src when
21:13:36 <lambdabot> when p s = if p then s else return ()
21:13:39 <ski> @src unless
21:13:40 <lambdabot> unless p s = if p then return () else s
21:13:48 <ski> @src guard
21:13:48 <lambdabot> guard True  = pure ()
21:13:48 <lambdabot> guard False = empty
21:14:06 <wavemode_> MaybeT would let you write it flat using guard
21:14:30 <ski> i guess one could also have defined them as `guardWhen b act = guard b *> act; guardUnless b act = guard (not b) *> act'
21:15:14 <ezzieyguywuf> I'll keep MaybeT in mind - I'm not familiar yet with monad transformers, nor does my code depend on the transformers library yet (though it does mtl). if this pops up again I'll make the transition
21:16:52 <ski> ezzieyguywuf : yea, those nested `if'-`then'-`else' are annoying .. you could at least use `&&', in that case
21:17:35 <ski> ezzieyguywuf : and the brackets around the `if' conditions are redundant, as is the body of the definition of `m'
21:19:39 <monochrom> Perhaps home-brew an operator (?>>): b ?>> e = if b then pure Nothing else e
21:20:08 <ezzieyguywuf> ski: what do you mean "the body of the definition of 'm'"?
21:20:29 <ski> `let m = (connectNodes (v, e) t)' could be just `let m = connectNodes (v, e) t'
21:20:44 <monochrom> (It is turning out to be liberating if you ban do-notation and use >>= and >> directly. Now you don't feel bad about adding your own operators.)
21:21:01 <ezzieyguywuf> ah
21:22:10 <ezzieyguywuf> monochrom: I use >>= and >> at times, i.e. http://dpaste.com/2XSYJE4#line-173
21:22:49 <ski> ezzieyguywuf : makeRayEdge'  could use `fmap'/`(<$>)', instead of `(>>=)'
21:24:12 <ezzieyguywuf> ski: i'll have to take a second to digest that
21:25:10 <ezzieyguywuf> I think && does clean it up nicely. http://dpaste.com/2XSYJE4#line-173
21:26:28 <ski> ezzieyguywuf : `connectNodes' always gives a `Just' result. will you likely change it in the future so that it can possibly also give a `Nothing', or are you using `Maybe' there to conform to a particular interface (a quick look appears to refute that) ?
21:27:09 <ezzieyguywuf> ah, I `fmap fromJust (makeRayEdge e)` that is more clear I think
21:27:53 <ski>   countNode p t = length . Graph.nodes $ Graph.labfilter p $ unTopology t
21:27:59 <ski> should preferably be
21:28:03 <monochrom> :( fromJust
21:28:05 <ski>   countNode p t = length . Graph.nodes . Graph.labfilter p $ unTopology t
21:28:08 <ski> or even just
21:28:16 <ski>   countNode p = length . Graph.nodes . Graph.labfilter p . unTopology
21:28:40 <ezzieyguywuf> ski: that was a very rough first attempt, I sure it can be improved. I changed it to return a maybe for this : https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/TopoState/src/Topology.hs#L180
21:29:00 <ezzieyguywuf> notice that when case m of Nothing, I don't put t'
21:29:18 <ezzieyguywuf> no that doesn't sound right..
21:29:38 <ezzieyguywuf> monochrom: *shrug* it's a convenience for my unit tests
21:29:57 <ski> monochrom : there's a bunch more of them, some of them wrapping calls to `connectNodes', which (currently) always gives `Just (...)' anyway
21:30:31 <ezzieyguywuf> yes, please feel free to poke holes all over this, I'm very open to constructive feedback
21:30:38 <monochrom> OK raising error from a test case is OK. :)
21:30:42 <ezzieyguywuf> I'm extremely new to haskell and am not very familiar with its idioms
21:31:29 <ski> monochrom, although those uses doesn't seem to be in test cases, but rather in the "main module"
21:33:18 <ski> ezzieyguywuf : i would rewrite `(isValidNode t e) && (not $ hasNeighbors t e)' as `isValidNode t e) && not (hasNeighbors t e)' -- also, why the `not', that flips the behaviour from your previous link ?
21:33:34 <ski> er, as `isValidNode t e && not (hasNeighbors t e)', sorry
21:34:22 <ezzieyguywuf> when you say "flips the behaviour from your previous link" do you mean it's undoing the isValidNode check?
21:34:40 <ski> btw, does `addNode EVertex' change the state ?
21:35:17 <ezzieyguywuf> this 'context' and the one after summarize why I have those two boolean checks: https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/TopoState/src/Topology.hs#L180
21:35:46 <ezzieyguywuf> tldr, makeRayEdge should only operate on (1) a valid node, (2) a node with no 'neighbors'. Otherwise, it should not do anything.
21:35:56 <ezzieyguywuf> ski: yes it does.
21:36:24 <ski> no, i mean you had before (if i remove the redundant brackets) `if isValidNode t e then if hasNeighbors t e then ... else pure Nothing else pure Nothing'. if you factor the two `else's into one, by using `&&', that gets you to `if isValidNode t e && hasNeighbors t e then ... else pure Nothing'
21:36:27 <ezzieyguywuf> I think that link is wrong.
21:36:33 <ezzieyguywuf> https://gitlab.com/ezzieyguywuf/haskellcad/-/blob/TopoState/test/TopologySpec.hs#L43
21:36:38 <ezzieyguywuf> that's what I meant to link in my last comment
21:36:45 <ski> but you added a `not' wrapping the `hasNeighbors t e' conjunct, so i was wondering whether that was intensional
21:36:51 <ezzieyguywuf> ski: ah, that version was wrong
21:36:56 <ezzieyguywuf> I changed it right after I posted that.
21:37:01 <ski> ah, okay
21:37:08 <ezzieyguywuf> nice catch!
21:38:37 <ski> i guess i'd consider changing
21:38:39 <ski>   prep' = prep >>= T.makeRayEdge' >>= vertToAdjEdge
21:38:41 <ski> to
21:38:56 <ski>   prep' = prep >>= T.makeRayEdge >>= vertToAdjEdge . fromJust
21:39:15 <ski> and then remove  makeRayEdge'
21:39:21 <ezzieyguywuf> ski: I sat there and pondered over prep' for a while
21:39:32 <ezzieyguywuf> then decided that I'd leave it for now since it works and it's "just a unit test"
21:39:35 <ezzieyguywuf> hah
21:40:05 <ezzieyguywuf> ah, but you know that's not a bad idea
21:40:13 <ezzieyguywuf> makes it explicit that it's intended only for the test
21:40:21 <ski> or, well, since you're using it in other places in that test file, just define  makeRayEdge' = fromJust <$> T.makeRayEdge  in that module ?
21:41:20 <ezzieyguywuf> ski: yea, or at the top-level 'describe' for that test case, right next to prep and run a
21:41:39 <ezzieyguywuf> (which, again, I pondered over a better way to do things than prep, run a, run', and friends but gave up)
21:42:57 <ski> ezzieyguywuf : "btw, does `addNode EVertex' change the state ?","yes it does." -- so, in the original code, the `t' you checked was the one after `addNode EVertex' changed the state. but in the current code, you're checking the `t' before
21:43:11 <ezzieyguywuf> hm, so I imagine a typical use-case will be as seen in the test, i.e. `addFreeEdge >>= makeRayEdge`, in which case it will be bothersome in client code to always check the return value of makeRayEdge since you know it will be valid
21:44:04 <ezzieyguywuf> ski: yes, the original code was wrong. But the state change didn't affect the change - rather, as someone (you?) pointed out, the state change is invalid when the check fails, that's why I moved it.
21:44:29 <ezzieyguywuf> back to makeRayEdge' though...is this "code smell"?
21:44:59 <ski> btw, `run a = (T.makeRayEdge' a) >>= T.removeVertex' could again be just `run a = T.makeRayEdge' a >>= T.removeVertex' .. or even just `run = T.makeRayEdge' >=> T.removeVertex', if you're familiar with that operator
21:45:52 <ezzieyguywuf> ski: yea, I'm still getting comfortable with the operator precedence in haskell
21:45:55 <ezzieyguywuf> lol, obviously
21:46:44 <ski> (yes, i pointed out you had (partially) changed the state even in the failure case, where you didn't put back the updated `t' after `connectNodes')
21:47:26 <ezzieyguywuf> ski: yea, that was wrong. I wrote a test that caught it then fixed it.
21:47:46 <ski> yea, i suppose i'm just trying to nudge you in the direction of where you feel more comfortable with when some pair of brackets are redundant
21:48:43 <ezzieyguywuf> ski: >=> is cool!
21:48:54 <ezzieyguywuf> ski: I appreciate the nudges.
21:49:05 <ski> (btw, on a similar note, `makeRayEdge e >>= (pure . fromJust)' could of course be just `makeRayEdge e >>= pure . fromJust'. but generally, `act >>= return . f' or `act >>= pure . f' is the same as `fmap f act' / `f <$> act')
21:49:58 <ski> oh, and i think many people would agree that generally it's better to not nest multiple `$'s as in
21:50:01 <ski>   put $ fromJust $ connectNodes (e, v2) t'
21:50:14 <ski> but rather replace all but the first with `.'s, as in
21:50:20 <ski>   put . fromJust $ connectNodes (e, v2) t'
21:50:25 <ski> or (what i often do)
21:50:27 <ezzieyguywuf> ski: yes, I've definitely taken a note to consider fmap in the future for these cases
21:50:34 <ski>   (put . fromJust) (connectNodes (e, v2) t')
21:50:42 <ski> or
21:50:49 <ski>   (put . fromJust . connectNodes (e, v2)) t'
21:50:52 <ski> or even plain
21:51:03 <ski>   put (fromJust (connectNodes (e, v2) t'))
21:51:13 <ezzieyguywuf> ski: yea, I've gradually worked towards replacing all but the last $ with ., but have not refactored all the code yet.
21:52:03 <ski> (a few brackets are nothing to be afraid of)
21:53:03 <dsal> ezzieyguywuf: you can consider hlint to tell you a bunch of these things.  :)
21:54:01 <ski> now i'm wondering about `addEdgeToVertex', whether you want to keep the original state in case of failure
21:55:12 <ski> (one way to do that would be to use `get' before any of the changes, and then `put' that back, in case of failure)
21:55:50 <ezzieyguywuf> dsal: I have hlint! after you (I think) suggested it the other day
21:56:02 <ezzieyguywuf> I just haven't integrated it into ghcid or anything, I run it manually every now and again
21:56:10 <dsal> I've learned a lot of interesting things from it.
21:56:26 <ezzieyguywuf> ski: addEdgeToVertex is probably going away, and addEdge to
21:56:51 <ezzieyguywuf> I'll probably write addRayEdge to replace addEdgeToVertex
21:57:11 <ezzieyguywuf> ah no, nvm, makeRayEdge already replaced addEdgeToVertex
21:57:17 <ezzieyguywuf> no wait, that's wrong...
21:57:20 <ski> @type \act -> do s <- get; catchError act (\e -> do put s; throwError e)
21:57:21 <ezzieyguywuf> it's too late, lol
21:57:22 <lambdabot> (MonadState s m, MonadError e m) => m b -> m b
21:57:50 <ezzieyguywuf> that's right - I'm getting ready to write "closeRayEdge" such that "makeRayEdge >>= closeRayEdge" will replace "addEdgeToVertex"
21:58:13 <ezzieyguywuf> (like I said, I've gone back and forth about the best design for this. I probably won't really know ow I feel about it until I get back to writing Entity and using these things"
21:58:16 <ezzieyguywuf> )
21:58:21 <ski> ezzieyguywuf : i don't always think hlint's suggestions are reasonable to follow, but often they're not too bad
21:58:58 * ski nods to ezzieyguywuf
21:59:18 * hackage servant-static-th 0.2.3.0 - Embed a directory of static files in your Servant server  https://hackage.haskell.org/package/servant-static-th-0.2.3.0 (cdepillabout)
22:00:21 * ezzieyguywuf nods back
22:02:25 <ski> ezzieyguywuf : btw, i think your `Arbitrary' instance could be smarter
22:02:57 <ezzieyguywuf> ski: smarter how?
22:03:21 <ski> you're just randomly selecting between seven particular (quite small) examples
22:03:48 <ezzieyguywuf> yea - the intent was to grow that number over time
22:03:55 <ezzieyguywuf> I couldn't think of another way
22:04:38 <ski> instead, you could have it start from the empty one, and then do a random loop, at each round either deciding you're done, or else add a new vertex or a new edge (in case you have at least one vertex)
22:05:51 <ski> if you have a way of combining two graphs into a single graph, maybe that could be nice to use here
22:06:26 <ski> you'd probably use `sized' to check that you're not generating too large a graph
22:06:31 <ezzieyguywuf> ski: the tough part, though, is rather than just adding a vertex, the loop would also have to randomly connect those vertices to edges, and later, connect those edges in loops to create faces
22:06:42 <ski> can you have multiple edges between the same pair of vertices ?
22:07:08 <ezzieyguywuf> yes and no - a single pair of vertices can only have two edges between them, one in each direction
22:07:15 <ski> yes, so when randomly generating an edge, you'd pick two vertices at random, and connect them
22:07:22 <ezzieyguywuf> so E0: V1 -> V2, E1: V2 -> V1
22:07:27 <ski> ah, okay
22:07:28 <ezzieyguywuf> then no more edges between V1 and V2
22:07:36 <ski> so directed, non-multi- graphs
22:07:44 <ski> can you have loop edges ?
22:07:52 <ezzieyguywuf> yes
22:08:52 <ezzieyguywuf> but the loop edge will have a vertex
22:09:07 <ezzieyguywuf> i.e. a starting/ending point, just like every other edge. it'll just be the same vertex
22:09:13 <ski> it's its own opposite, so to speak
22:09:18 <ski> yep
22:09:51 <ski> (now i'm reminded of Lawvere's approach to graphs, modelling them as actions of a particular monoid ..)
22:12:10 <ski> ezzieyguywuf : in any case, there could well be some property that you're describing, which wouldn't fail for one of your seven selected example graphs, but could fail for some other, perhaps slightly more complicated, graph
22:14:11 <ezzieyguywuf> ski: you're right. But I think that I'll only discover those cases over time and just manually add them to arbitrary
22:14:29 <ezzieyguywuf> I have considered an automated/random approach as you've suggested, and may try that
22:14:33 <ezzieyguywuf> but for now this works :)
22:15:05 <ski> i would think that part of the utility of having an `Arbitrary' instance in the first place would be to have it discover such cases for you
22:15:24 <ski> what's "HalfEdge" ?
22:19:24 <ezzieyguywuf> ski: E0: V1 -> V2
22:19:48 <ezzieyguywuf> the pair of E0: V1->V2 and E1: V2->V1 forms a "whole" Edge
22:19:55 <ski> oh, so just a one-way edge, only in one direction, but not the other ?
22:20:03 <ezzieyguywuf> ski: correct
22:20:18 <ski> i think i'd call that just a (plain) edge
22:20:23 <ezzieyguywuf> HalfEdge can be chained togother in a loop to identify a Face
22:20:55 <ezzieyguywuf> they always go count-clockwise: this way, you can embed a clockwise loop in a counter-clockwise loop to describe a 'hole'
22:20:59 <ski> can you have a loop without a corresponding face ?
22:21:33 <ezzieyguywuf> ski: I haven't decided yet. I don't think there would be a need
22:21:51 <ski> can you have a face that is not circumscribed by a loop ?
22:22:01 <ezzieyguywuf> it's referedd to as 'half edge' in boundary representation literature as well, so it's familiar terminology
22:22:06 <ski> okay
22:22:07 <ezzieyguywuf> ski: no you cannot
22:22:21 <ski> how about representing a cube ?
22:22:26 <ezzieyguywuf> I think half edge makes sense, too, because the idea is to build up a solid by describing all the faces that bound it
22:22:51 <ski> can you make a cube out of half-edges only ?
22:23:11 <ezzieyguywuf> a cube is a good example. Start with a square, made of four half-edges. Take another square, four more half-edges. You can 'glue' these two together along an edge, creating one 'whole' edge
22:23:47 <ski> so you do need at least some edges being two-way, then ?
22:23:57 <ezzieyguywuf> ski: you can't, because by definition a Face is a loop of half-edges going counter-clockwise
22:24:12 <ezzieyguywuf> ski: in a valid solid, _all_ edges will be two-way
22:24:16 <ski> ok
22:24:24 <ezzieyguywuf> the half-edge is merely an intermediate step
22:32:18 <ski> hm, i'm reminded of opetopes .. but i can't seem to find the paper i was thinking of, atm
22:33:05 <ski> ezzieyguywuf : what about representing higher dimensions, like having multiple cells, each delimited by some faces ?
22:36:44 <ezzieyguywuf> ski: what do you mean 'multiple cells'?
22:36:48 <ezzieyguywuf> and how is this higher dimensions?
22:36:57 <ezzieyguywuf> i ultimately wish to model a 3-dimensional solid
22:37:19 <ski> well, e.g. putting eight cubes together to make a four-dimensional hypercube
22:37:33 <ski> okay
22:39:48 <ezzieyguywuf> ah, I don't know anything about 4 dimensions :-P
22:40:59 <ski> anyway, what i was thinking about, was allowing to specify a face, by specifying two (directed) paths of edges, the two paths starting and ending at the same place
22:41:56 <ski> but if, in the end, you're not really interested in the directedness of edges (and probably not orientation of faces, either), then i guess loops work
22:43:33 <ski> (with a similar idea, one could model a solid by pasting together an "upper half" and a "lower half" of it, gluing them together along two paths of edges)
