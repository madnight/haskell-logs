00:02:50 <hololeap> % :t to . from
00:02:50 <yahb> hololeap: (Contravariant f1, Profunctor p1, Profunctor p2, Functor f2) => AnIso s t a b -> Optic' p1 f1 (p2 t (f2 s)) (p2 b (f2 a))
00:03:02 <hololeap> % import qualified GHC.Generics as G
00:03:03 <yahb> hololeap: 
00:03:08 <hololeap> % :t G.to . G.from
00:03:09 <yahb> hololeap: (G.Generic c, G.Generic a, G.Rep a ~ G.Rep c) => a -> c
00:20:35 <freeman42x[m]> what is the best option for getting from: IO [Text] to IO Text using unlines? I think there was an option better than using <-
00:20:55 <EvanR> :t fmap unlines
00:20:57 <lambdabot> Functor f => f [String] -> f String
00:21:13 <EvanR> "the IO functor"
00:21:28 <freeman42x[m]> ah, right, cause IO a only contains 1 item
00:21:35 <freeman42x[m]> I got confused and thought that would go into the list
00:21:40 <EvanR> uhg it doesn't contain anything!
00:21:47 <EvanR> or it contains everything
00:21:55 <freeman42x[m]> EvanR: sorry, not in the mood for semantic m#####n :D
00:22:05 <freeman42x[m]> @karma+ EvanR thank you
00:22:05 <lambdabot> EvanR's karma raised to 21.
00:22:17 <EvanR> damn I have 21 ?
00:22:23 <EvanR> i need to get out more
00:22:29 <MarcelineVQ> @quote /ls
00:22:29 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:22:35 <freeman42x[m]> yeah, 21 is like half of 42, almost there
00:23:52 <freeman42x[m]> ugh more people into semantic m#######n, as I said, not in the mood, either understand what I meant or just don't say anything. It is not useful
00:25:08 <MarcelineVQ> ditto on the don't say anything part then. be aware that that attitude makes people less likely to help you, even people not current in the conversation
00:25:46 <freeman42x[m]> MarcelineVQ: I know, but it only makes closed minded people not want to answer. I am fine with that
00:26:10 <Faye> personally I find that semantic meaning helps me be a better programmer in Haskell, in pratice it reminds me of pragmatic issues, rather than deep philosophical ones
00:26:10 <EvanR> since we didn't drop this, what DID you mean
00:26:22 <MarcelineVQ> That's not the most likely case
00:27:02 <MarcelineVQ> But we'd have to define close minded to continue I guess, so that's where it stops for me.
00:27:09 <Faye> (that's just my opinion, and there can be an addiction to "but what does XYZ mean" when really you just want to build a backend for a website, but IMO every Haskeller should talk about the IO monad correctly bc it's fundamental)
00:27:28 <EvanR> it's the IO functor for the sake of argument
00:27:43 <Faye> well fair :p
00:28:21 <Faye> but I was talking more generally that everyone should be able to discuss the IO monad (and really monads in general) with an understanding. And if you don't have that understanding it's fine, but it's normal to talk about that semantic meaning
00:28:56 <Faye> And acquiring helps you write good code, even if it's long term returns
00:29:31 <EvanR> i'm thinking of IO A as an experiment with an A result
00:30:12 <EvanR> depending on the experiment, it may literally be an A popping out of a box
00:30:23 <EvanR> i'll accept that
00:31:44 <EvanR> but in QM you expect experiments to give different results every time, and they laugh at you if you insisted it was x::A in the box all along
00:32:24 <MarcelineVQ> jokes on you, A was a probability distribution all along
00:32:44 <EvanR> that wouldn't be funny...
00:33:15 <EvanR> new take on... random probability distribution
00:33:25 <freeman42x[m]> no matter how you think about it, it is not constructive to dismiss other peoples description of how you would read IO a, it is irrelevant to their understanding of it
00:34:35 <EvanR> i'm not dismissing it, i'm actually criticizing almost all container analogies for almost everything
00:34:48 <EvanR> which has little to do with you
00:36:30 <EvanR> for posterity rewrite history and replace my follow up with "does it?"
00:38:20 <Athas> I think of IO as a newtype wrapper around a dummy token value whose only purpose is to ensure a predictable forcing order of impure thunks.
00:38:57 <MarcelineVQ> you monster
00:39:45 <EvanR> Athas was that guy in philosophy who switch the minecart to kill all but 1
00:40:26 <Uniaika> ah yes I remember now
00:40:31 <Uniaika> the Minecart Dilemma
00:41:14 <Athas> I just don't think IO needs a model.
00:41:27 <kleisli_> anyone know of an example of using recursion schemes / functor fixed points with mutually recursive structures?
00:41:36 <EvanR> oh you're serious?
00:41:49 <Athas> Like, I can keep a model of a helicopter in my office because a real helicopter wouldn't fit, but a model of the IO monad doesn't take that much less space than the real IO monad.
00:42:02 <MarcelineVQ> That's backwards me for though freeman42x[m], someone's description of something tells me what they understand about it.
00:42:09 <Faye> I have the inverse approach
00:42:19 <Faye> I don't think of a model just the semantic formalism
00:42:23 <Uniaika> MarcelineVQ: yup'
00:42:25 <MarcelineVQ> So it's not relevant _to_ their understanding, it _is_ their understanding
00:42:28 <EvanR> I've never once used the implementation of IO for anything
00:42:30 <Faye> (mathematics time)
00:42:50 <EvanR> i guess some people have to, that sucks
00:42:56 <Athas> Alright, trolling aside, what *is* the mathematical formalism of IO, taking into account also exceptions and concurrency?
00:43:31 <Athas> And do we have something that can also explain unsafePerformIO and maybe even unsafeInterleaveIO?
00:43:32 <EvanR> it's an experiment that may or may not produce an A, and may or may not explode in your face
00:43:53 <EvanR> and may still be running once you have the A
00:43:58 <Athas> Oh, so IO really *is* a probability distribution!
00:44:01 <EvanR> or an explosion
00:44:10 <MarcelineVQ> Though I would say that correcting (or dismissing if you prefer) someone's description is not constructive, iff that description is accurate.
00:44:12 <EvanR> yes it's potentially random
00:46:43 <Uniaika> I more or less understand the nature of IO as "There are no guarantees, but the faeries that make computer run do their job pretty good in general"
00:46:50 <Uniaika> *computers
00:48:06 <Athas> That's not really satisfying to me.  There are lots of impure languages that make promises about IO, and I don't see why Haskell can't do the same.
00:48:21 <Athas> Sure, those promises are not going to be the ironclad "this _will_ happen" of pure functions.
00:48:47 <EvanR> ah you mean "promises"
00:48:54 <Arahael> Well, arguably, doesn't Haskell lie?  So-called "pure" functions that do not have IO in their signature could still use IO.
00:48:59 <Athas> But at some point, it's useful to think of the IO monad in terms of how it actually works, which is pretty simple on a technical level.
00:49:19 <EvanR> there are simpler implementations of IO
00:49:29 <MarcelineVQ> Athas: fwiw tho http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
00:49:33 <Arahael> I mean, Haskell *promises* that such functions do not involve IO, but there are various unsafe ways to do unsafePerformIO and the like.
00:49:43 <Athas> Actually, I'd really like to have a model of when unsafePerformIO is safe (or even just type-safe) to use, which I think requires understand the specifics of IO.
00:49:43 <EvanR> if you don't need the implementation, you can imagine any of them exist
00:50:26 <Athas> MarcelineVQ: yes, but that doesn't work well when you actually need real IO (e.g. launch a thread and call a blocking foreign function).
00:50:37 <MarcelineVQ> I just meant for the modeling
00:51:12 <Athas> Such models work fine for simple cases, where you don't need to think much anyway, but I feel they are insufficient for the tricky cases.
00:51:36 <Athas> Whereas the Reality Of IO isn't really that complex; it just doesn't have a neat mathematical formalism (I think).
00:52:48 <EvanR> it seems like Haskell avoided a high falutin model of IO because they didn't either didn't want to be boxed in and/or didn't want it to be a elaborate bald faced lie
00:52:56 <Athas> I'm not recommending trying to makes asynchronous exceptions in IO seem as simple as the Maybe or Either monads; I'm recommending trying to make them as simple as they are in C.
00:53:27 <Athas> Yeah, I guess I'm advocating for teaching the specifics of GHCs implementation.
00:53:56 <Athas> Haskell 2010 IO could indeed be something else I guess, like maybe a free monad interpreted by a runtime system.
01:06:48 <fog> here, this is pretty cool;
01:06:48 <fog> https://pastebin.com/raw/NL0JmdFn
01:07:14 <fog> to solve the issue of not being able to resolve a type level function from its defunctionalization symbol and visa versa 
01:07:32 <fog> instead, type level functions should be named with string symbols
01:07:54 <fog> and made instances of a class with an associated type for the type level function 
01:08:05 <fog> and an associated defunctionalization symbol
01:08:25 <fog> its slightly redundant to provide the symbol, since the name should do
01:08:54 <fog> but this allows existing code written in terms of defunctionalization symbols as per the Eisenberg paper to be used
01:09:06 * hackage servant-swagger-tags 0.1.0.1 - Swagger Tags for Servant  https://hackage.haskell.org/package/servant-swagger-tags-0.1.0.1 (nakaji_dayo)
01:10:02 <fog> oh sorry, it imports the TyFun module; https://pastebin.com/raw/hD1hGFGM
01:10:53 <fog> not sure about extending to higher numbers of arguments for the type level function
01:11:01 <fog> or if a nonempty list should just be used...
01:11:27 <fog> (thats what all the 1 suffixes are for, anticipating multivariate versions)
01:23:04 <fog> you use it like this;
01:23:06 <fog> :kind! GetTypeSymbol1 "id" Int
01:23:52 <fog> sorry, that was a typo
01:23:54 <fog> ...
01:23:55 <fog> :kind! GetFunction1 "id" Int
01:24:05 <fog> GetTypeSymbol1 "id" Nat @@ 1 :: Nat
01:24:10 <fog> = 1
01:24:23 <fog> ...
01:24:29 <fog> and for the symbol version;
01:24:33 <fog> :kind! GetTypeSymbol1 "id" Nat @@ 1
01:24:42 <fog> GetTypeSymbol1 "id" Nat @@ 1 :: Nat
01:24:47 <fog> = 1
01:25:22 <fog> er, above for the Function1 version that should have been;
01:25:23 <fog> GetFunction "id" Int :: ReturnKind1 "id" Int
01:25:30 <fog> sorry, anyway, could be useful
01:35:37 * hackage string-random 0.1.3.0 - A library for generating random string from a regular experession  https://hackage.haskell.org/package/string-random-0.1.3.0 (hiratara)
01:46:36 * hackage hslua 1.1.2 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.1.2 (tarleb)
02:37:00 <lc> the weird thing about monads for me is it feels like all of the explanations just talk past what the heck they are. Like, they make a bunch of statements *around* monads, but they never get to the point of telling me what monads are or how I'm supposed to do IO in haskell
02:37:51 <Cale> Well, have you looked at the definition?
02:37:56 <lc> It's not like reading dense philosophy papers or complicated math proofs or whatever where you have to reread the content a couple times before you get it.
02:38:18 <xerox_> there are tutorials covering that https://wiki.haskell.org/Introduction_to_IO
02:38:22 <Cale> Also, you shouldn't need to know about monads more generally in order to use IO
02:38:55 <xerox_> or this https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions
02:39:06 <lc> I don't think I can learn monads "selectively" in order to learn io
02:39:11 <Cale> hm?
02:39:44 <Cale> Monad is an abstraction of things like IO
02:40:01 <Cale> You should probably try to understand a few particular examples of monads before you try to really understand Monad
02:40:02 <lc> I just mean as far as I can tell there's no way to learn "only the parts of monads that are involved in IO", so I have to udnerstand monads pretty much all the way to understand IO, right?
02:40:31 <Cale> You don't really have to get the general meaning of things in order to understand what they mean in the context of IO specifically.
02:42:47 <lc> tbh maybe I just need to figure out how classes work in haskell
02:43:22 <Cale> Yeah, understanding type classes is good if you want to understand Monad as an abstraction
02:43:41 <Cale> I wouldn't recommend trying to understand Monad without first understanding some simpler type classes
02:43:54 <Cale> But as for IO...
02:44:03 <Cale> We have these values called "IO actions", they have types like (IO t), where t can be any type of values.
02:44:09 <Arahael> I think do-notation confuses it.
02:44:30 <Cale> IO actions are like programs which can be executed. Evaluating a value of type IO t doesn't cause them to be executed, it just... figures out which program it is.
02:44:48 <Cale> If it runs successfully, an action of type IO t will have a result of type t.
02:45:00 <Cale> For example, there's  getLine :: IO String
02:45:25 <Cale> which describes the action of getting a line of text from the user at the terminal
02:45:38 <Cale> and there's  putStrLn :: String -> IO ()
02:46:01 <Cale> which is a function that constructs the action for printing a string to the termina
02:46:03 <Cale> l*
02:46:39 <Cale> () is the empty-tuple type, used here because there won't be an interesting result
02:47:48 <Cale> You can glue IO actions together into larger IO actions using do-notation, or using the operations provided by the Monad class. It's not important what those operations mean more generally, but it's important to know what they mean for IO
02:48:31 <Cale> So, the methods of the Monad class are  return :: a -> IO a  which takes any value and produces the IO action which does nothing when executed, except that it has the given value as its result
02:48:44 <Cale> and (>>=) :: IO a -> (a -> IO b) -> IO b
02:49:25 <Cale> this is a bit of a mouthful, but what it does to produce the action which when executed will run the first action of type IO a
02:49:33 <Cale> getting some result, say v :: a
02:49:49 <Cale> and then it will apply the given function to it, to get a second action of type IO b
02:50:08 <Cale> and it will run that one as well, producing whatever the result of that second action was as its own result
02:50:37 <Cale> So it gives us a way to determine what should happen next given the result of the first IO action
02:51:29 <Cale> It's in terms of this combining function (>>=) (pronounced "bind") that do-notation does the job of combining actions for you
02:51:59 <Cale> You can write stuff like  do x <- getLine; putStrLn x
02:52:11 <Cale> and that gets translated into  getLine >>= (\x -> putStrLn x)
02:52:45 <Cale> Inside a do-block, when you write v <- x it means "execute the action x, and name its result v in what follows"
02:53:32 <Cale> The do-block as a whole will itself represent an action, and the result of that action will be the result of the last action in the block
02:54:04 <Cale> Does this make sense?
02:54:45 <lc> It makes more sense than it did before.
02:54:47 <Cale> Another question you might have is how actions start to get executed in the first place, given that we so far only have ways of executing actions as part of other actions.
02:55:08 <Cale> But that's actually easy, because the 'main' in a Haskell program actually needs to be one of these IO action values.
02:55:15 <Cale> and it will be executed
02:55:20 <lc> Hmmmm
02:55:45 <Cale> (in some sense, it's the only action which is ever executed in a compiled Haskell program, though it might be built up from many others)
02:56:04 <lc> So the final IO action and result of "main" is actually sort of a description of a meta-sequence of IO actions and computations the program needs to take during its execution
02:56:13 <Cale> You can also type actions at the ghci prompt and it will automatically execute them for you, as well as printing the result if it can
02:56:41 <Cale> Yeah, main itself is a value which describes what your program is going to do
02:57:05 <lc> THe one thing I don't get, even though this type definition is helping a lot honestly
02:57:14 <lc> none of these methods return a itself
02:57:24 <lc> so how do you perform computation on inputted values
02:57:33 <lc> in the "stateless" haskell-famous way
02:57:36 <Cale> Well, consider a small example like this:
02:57:47 <Cale> main = do x <- getLine; putStrLn (reverse x)
02:58:00 <Cale> Here x :: String, it's the result of the getLine
02:58:05 <lc> ah.
02:58:17 <Cale> and reverse :: [a] -> [a] need not know or care that it came from performing IO
02:58:58 <Cale> So, we're able to get some input, apply functions to it that have nothing to do with IO, and then perhaps do some output based on the results of that
02:59:43 <lc> so, all the non-monadic computation, it comes from that (a -> m b) stage of the bind inside main?
02:59:51 <Cale> Yeah
03:00:16 <Cale> Well, it could also be hidden away in the first IO action's definition
03:00:25 <Cale> but ultimately, yeah
03:00:42 <lc> Ok so. This has helped a lot, and I thank you for humoring me
03:02:07 <lc> But I still don't have the intuition of how things like Tetris, web servers, or databases are possible inside haskell. Is that something you just get after programming in the language for a while? How do people architect actual big applications that accept lots of different IO inputs?
03:02:44 <Arahael> My way of thinking about it: Everything in the IO monad is ultimately about building up a structure of "what to do", and this then has to be interpreted/executed by the real world.  Except GHC, the compiler, will "optimise" that and run it whilst you're still defining the program.
03:02:51 <Cale> Well, you eventually just come to think of writing IO actions as not being all that different from writing imperative programs
03:03:30 <Cale> With some important differences, but it's eventually comfortable to ignore what you're actually doing and just write the damn program
03:04:08 <lc> This might be expanding the scope of the question too much, but how is multithreaded/asyncrhonous io done under this system?
03:04:27 <Cale> There's a function  forkIO :: IO a -> IO ThreadId
03:04:56 <Arahael> That is *not* the fork system call, mind you.
03:04:56 <Cale> Which takes an IO action and creates a new thread which will execute the given IO action
03:05:15 <Cale> Yeah, they're green threads, N:M scheduled on your available cores
03:06:52 <Cale> and essentially all the basic I/O stuff that you're given, like getLine and putStrLn that we saw, and almost everything else, is implemented using nonblocking IO, and select/kqueue/epoll (depending on availability)
03:07:31 <Cale> So, you can fork multiple threads, and do "blocking" operations from them, and it'll just work
03:07:41 <lc> cool
03:10:30 <lc> Today I ran into a problem in python where an argument to a function that was strictly evaluated caused a side effect and made it panic, and had to change the argument to a lambda that was evaluated when it was actually necessary >.<
03:11:17 <Cale> Yeah, the fact that IO actions are values whose evaluation doesn't cause their effect to occur is very nice for keeping things sane
03:11:38 <Cale> It makes it easy to write our own control structures (though most of what you need is already in the libraries)
03:11:55 <Cale> For example, let's write  sequence :: [IO a] -> IO [a]
03:12:11 <Cale> which will take a list of IO actions, and produce an IO action that will run each of them in turn, and produce a list of the results
03:12:39 <Cale> sequence [] = return [] -- if the list is empty, we'll produce the IO action that does nothing except has the empty list as its result
03:13:05 <Cale> sequence (x:xs) = do ... -- if the list is nonempty, starting with some action x, and continuing with xs
03:13:23 <Cale> sequence (x:xs) = do v <- x; ... -- first we'll execute x, getting its result v
03:13:48 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then we'll execute the rest of the list, getting a list of the results vs
03:14:18 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and we'll put the complete list together, producing that as the result
03:15:31 <Cale> In terms of that, we have  forM :: [a] -> (a -> IO b) -> IO [b]
03:15:56 <Cale> which is like a for-each loop, it iterates over the given list, applying the function to each element to get an action, and it runs all the actions, collecting a list of the results
03:16:09 <Cale> forM xs f = sequence (map f xs)
03:16:56 <Cale> (There's also mapM which is the same, with the arguments flipped, but forM is perhaps more comfortable to actually use a lot of the time, since usually the code for the function is longer than the code for the list)
03:17:07 <Cale> So you can write stuff like
03:17:17 <Cale> forM [1..10] $ \x -> do
03:17:20 <Cale>   print x
03:17:21 <Cale>   getLine
03:18:52 <lc> i want to be a haskell wizard so bad ;_;
03:19:09 <jchia1> Does System.FilePath.Glob.glob from the Glob package not work properly with symlinks? The ls command clearly shows the file (no wildcards) I'm globbing but glob reports zero matches.
03:19:20 <jchia1> One of the parts in the path is a symlink
03:19:21 <lc> just writin web servers and shiz like it's golang
03:20:02 <Cale> Where I work, we write web and mobile applications in Haskell :)
03:20:20 <Cale> https://obsidian.systems/
03:22:01 <lc> lol I just moved off of nix after I found python development too difficult
03:22:25 <Cale> We've open sourced our framework for building web and mobile applications here: https://github.com/obsidiansystems/obelisk
03:23:51 <Cale> We build our frontends using a Haskell library called reflex-dom. They get compiled to javascript for the web, or to ARM code for iOS and Android.
03:25:07 <lc> That sounds nice. I'll bookmark your site and send you my resume if my startup fails ;p
03:26:26 <Cale> The nix stuff, well, actually having to deal with nix code is pretty painful I'll admit (mostly because of people's conventions rather than anything intrinsic), but at the same time, once you get it right, it only rarely needs to change, and it means that someone else at the company can figure out the toolchain issues for iOS and Android builds, and I don't have to think about it, haha
03:27:33 <Arahael> I actually find nix nice in theory, but I can never figure out the 'correct' way to do something.
03:28:07 <Arahael> And I struggle heaps because I don't know the difference between doing something as nixpkg's, doing something in your tree, or as part of the project - there's no conventions. :(
03:28:16 <lc> I mean everybody finds nix nice in theory. There's nothing bad about it "in theory". What's the problem with completely reproducible oses?
03:28:46 <lc> "I have to do what to make a django repo?"
03:29:22 <Cale> The thing is, nix is just a normal functional programming language, but the people who write nix code for whatever reason thought that would be too easy to understand, and so in order to make it more like imperative programming, they typically pass the entire universe as an argument to every function, and then tie everything together with giant fixed points
03:30:14 <Cale> and then manipulate those giant records of everything and involve them in yet other fixed points, and it becomes almost impossible to determine what keys are in any particular attrset, because its definition is spread across dozens of files
03:31:44 <Cale> and for whatever reason, this is also true of all their standard library functions, they're just lumped in with all the packages (in the same git repo as well)
03:32:09 <Cale> and they're passed around to everything as an argument as part of the same giant records
03:32:17 <Cale> ...which are being manipulated...
03:32:25 <Cale> and it's just shenanigans
03:32:41 <Cale> If they didn't do this, it would all be much easier to understand
03:33:04 <Cale> The downside being that then the nix code would have to express what all the dependencies between packages are.
03:33:38 <Entroacceptor> I've never looked at guix, does it have that same problem?
03:33:42 <Cale> (They sort of sidestep the problem of figuring that out by shoving it all into a big fixed point combinator)
03:33:45 <lc> Yeah, the company I run is a two man show at this point, so if I can't get my terminal to write linted, code-completed python/go code on a new repo in 10 minutes it's on me x.x. I'll come back in a couple years when there's more than three pages on the internet about how to run a python program or they find some way to un-imperatize a the functional language
03:34:05 <lc> s/a the/the/
03:35:10 <Cale> lc: If you can figure out just enough tricks with nix, it can be pretty nice for casual usage. I have a shell script with this in it:
03:35:11 <Cale> nix-shell -p "(import <nixpkgs> {}).haskell.packages.ghc865.ghcWithPackages (pkgs: with pkgs; [ $* ])"
03:35:43 <Cale> and if I pass that a bunch of haskell package names on the commandline, it drops me into a shell with just those packages and GHC 8.6.5
03:35:56 <Cale> It's really handy for when I'm trying to help random people on the internet :)
03:36:07 * srk is using similar alias too
03:37:21 <Cale> I don't actually use nixos, just the nix package manager for Haskell stuff (especially work-related Haskell stuff, but at this point I also use it a bit for personal projects)
03:38:47 <lc> If I ever get around to porting the go code we've written I'll probably make an attempt to incorporate nix as a packaging solution
03:40:22 <Cale> It's also really nice for deployment
03:40:39 <Arahael> Cale: Right, exactly, all that.
03:41:22 <Arahael> I currently use nixOS as well, actually.  Some really nice things in that.
03:41:39 <Arahael> But also some quirks, in particular, it means that whatever I run on it, *has* to be nix-ified.
03:41:55 <Arahael> And this is why I have moved to more docker, and even the odd flatpak or two.
03:42:03 <lc> But like, what does it have over docker containers for deployment?
03:42:17 <Arahael> lc: It means I don't have to patch the binaries or anythign.
03:42:54 <maralorn> Cale: I am not sure I have yet read such a clear description about what is wrong with nixpkgs. Nice
03:43:38 <Arahael> The problem becomes exponentially worse if you're a polyglot dev, as well.
03:46:43 <Arahael> Honestly, I sometimes think about wiping the system and going back to debian, but with nixpkg's and that's it - but it's so nice to basically have your OS versioned as well.  I can - at boot time - select any previous configuration.
03:47:42 <Cale> Arahael: Yeah, in principle, that would make it really convenient to get new computers set up the way I like them
03:48:13 <Arahael> Cale: nixOS makes that relatively easy - in principle.  Just copy over the environment.nix and do the rebuild. Done.
03:48:24 <Cale> In practice, I was like "okay, fuck this" after a short period and went back to slightly tweaking a Linux Mint installation by hand afterward
03:48:32 <Arahael> Right. :(
03:48:51 <Arahael> Still, many months in, I'm still using nixOS out of inertia, and it's pretty good, except for the infuriating nix language.
03:49:42 <Arahael> I still haven't figured out how to write a nix for an arbitrary package that, by chance, happens to already be in nixOS, but I wanted to be able to use it in macOS as well and well, not to have it as *part* of my channel - anyway.
03:50:18 <Arahael> I've come to learn that nixpkg's is essentially a giant, dynamic script.
03:50:29 <srk> you just import another version of nixpkgs
03:50:42 <maralorn> Arahael: I don‘t understand your problem. But it sounds like it shouldn‘t be one.
03:50:54 <Arahael> For someone who understands nix, it's trivial.
03:51:02 <srk> something like https://nixos.wiki/wiki/FAQ#How_can_I_install_a_package_from_unstable_while_remaining_on_the_stable_channel.3F
03:51:18 <srk> but instead of using a channel you can just fetchFromGitHub or fetchTarball with specific ver
03:51:32 <Arahael> srk: Ah, but I don't want this to be part of nixpkg's official channels - or am I really supposed to clone the entire channel repo for each and every application?
03:51:54 <Arahael> srk: Effectively, that means I shouldn't put it into that package's repo.
03:52:05 <srk> no, only for those you're missing in your channel
03:52:21 <srk> maybe I don't understand the goal
03:53:13 <Arahael> Goal, was really to be able to put the "default.nix" as a file in *random third-party app*, say, for sake of argument, maybe this is a commercial project.
03:53:23 <srk> ok
03:53:33 <Arahael> It's not a commercial project, but anyway.
03:53:49 <Arahael> Now, in stack, this is trivial: stack init; done.
03:53:54 <Arahael> Not so in nix.
03:54:11 <srk> depends on random app, for haskell this is trivial as well
03:54:30 <Arahael> Random app is a Python app.
03:55:03 <Arahael> Oh, and that's the other thing that irritates me - in nix, each language ecosystme has their own way of doing the nix.
03:55:04 <srk> well you look how are these packaged in nixpkgs, there are examples of buildPythonPackage in nixpkgs manual as well
03:55:16 <srk> sure, there are many ways to nix
03:56:06 <srk> some ecosystems need custom wrappers, it makes stuff easy as you don't have to re-invent the derivation each time 
03:56:36 <srk> think like generic builders.. that just run setup.py bla bla which is a standard way of building python pkgs
03:56:39 <Arahael> In the nixpkg's case, I copied the file out of the pkg system into the root of said program's repo.  And yeah, it didn't work.
03:57:03 <srk> it needs to be called via callPackage
03:57:13 <srk> which fills in the arguments from the package set automagically
03:57:21 <Arahael> Indeed, so I had to learn about that - it was quite convoluted.
03:58:17 <Arahael> srk: To be clear, I'm not trying to find a solution tonight - I'm watching a movie and relaxing. :)  What I am doing tonight, is just trying to express the struggles I had with nix.
03:58:36 * hackage cabal-lenses 0.10.0 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.10.0 (DanielTrstenjak)
03:58:37 <srk> yeah, I'm slacking as well :)
03:59:01 <Arahael> :thumbsup:
03:59:15 <turion> Arahael: Yes, there is a lot of struggle. But it pays off. I just wish for better documentation, but I guess that's up to us to improve and extend it.
03:59:21 <srk> there's a lot of tribal knowledge regarding Nix that is often available somewhere but you need to know *where* to look :)
03:59:49 <srk> 3 separate manuals don't make it any easier
03:59:58 <Arahael> srk: Yeah.  Back when I started (which was as recent as last year...), the nixpkg manual wasn't even linked on the nix docs site or something!
04:00:07 <Arahael> There was _another_ manual, I forget which one it was.
04:00:14 <srk> nix, nixos, nixpkgs
04:00:25 <Arahael> So I think they had a nixOS manual, a nix language, and nixpkgs or something was missing.
04:00:26 <srk> and nixops as well :D
04:00:31 <Arahael> Oh, nixops.  Yes.
04:00:59 <Arahael> I actually found nix pills to be *perfect* for what I wanted, except...  There's no goal there.
04:01:16 <Arahael> nix pills lets you learn about the nix language... And then stops.
04:01:30 <Arahael> And it's not really as helpful if you have a very specific goal in mind, either.
04:02:04 <Arahael> Like learning python - it's possible to go and make your script and whatever without once ever learning about classes and objects, you can sort of figure out just what you need to achieve your end result.
04:02:13 <Arahael> It might be a crappy solution, but you have your urgent need met.
04:03:38 <Arahael> Maybe I should try and document my learnings some day.  Blog about it somehow.
04:03:44 <Arahael> Eventually.
04:04:01 * Arahael makes a TODO: Install wordpress in the not so distant future.  In a docker container.
04:06:37 <Arahael> Still, what really attracted me to it was the notion it had deterministic builds and all that, after a fashion. And that it was a generic build system - any language, any ecosystem, and you'd make it work.
04:07:10 <Arahael> but I guess, I'm getting a bit irritated with it because I can't see the likes of the typical Go, Python, Rust, C++, or Javascript dev using it.
04:12:52 <srk> well, it depends, the investment really pays when it comes to deploying these
04:13:01 <srk> *off
04:16:06 <Arahael> Yeah, I guess that's the other trouble.  A lot of the peers I interact with don't use nix.
04:16:11 <Arahael> (And they're on MacOS)
04:29:22 <turion> Still, you can add nix to existing code and make it better for yourself, even if others don't use your nix rig
04:30:16 <Arahael> Yes, I was trying to add it to "existing code", and referring to existing nix files for similar programs that happened to be part of nixpkgs.
04:38:07 * hackage cabal-bounds 2.3.0 - A command line program for managing the dependency versions in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-2.3.0 (DanielTrstenjak)
04:42:38 * hackage cabal-lenses 0.10.1 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.10.1 (DanielTrstenjak)
05:08:51 <sm[m]> +1, that was interesting Cale
05:25:19 <sm[m]> Before reading further, let me ask: will I find cabal.project documented in cabal’s user guide ?
05:27:20 <typetetris> https://www.haskell.org/cabal/users-guide/nix-local-build.html?highlight=cabal%20project#configuring-builds-with-cabal-project
05:27:52 <typetetris> Under "nix local build", find the newbie to haskell finding that.
05:33:50 <sm[m]> phew. Thanks typetetris, I’ll keep reading then
05:34:49 <typetetris> sm[m]: Used that in the past mostly to add vendored packages to the build, or newer versions from github. Worked like a charm.
05:35:11 <sm[m]> the guide needs a serious update
05:35:16 <typetetris> ...
05:35:18 <typetetris> yes
05:35:22 <typetetris> memetic yes
05:36:39 <typetetris> I would also argue it would be good to split it in two parts. A tutorial part and a reference part. (Maybe that is already the case, but I can't remember :))
05:38:29 <sm[m]> agreed
05:40:20 <BAWHWA> /join #vim
05:40:26 <BAWHWA> Disregard.
05:41:06 <sm[m]> I can’t, it burns my eyes
05:55:41 <Arahael> sm[m]: Then use a bit of evil. You'll be fine.
06:01:37 * hackage exigo-schema 0.2.0.1 - database schema for exigo marking/assessment tools  https://hackage.haskell.org/package/exigo-schema-0.2.0.1 (phlummox)
06:20:40 <unsupervised> I find haskell coupling with nix troubling when nix doesn't even install easily on macos anymore
06:22:07 * hackage binary-io 0.3.0 - Read and write values of types that implement Binary  https://hackage.haskell.org/package/binary-io-0.3.0 (vapourismo)
06:22:57 <Arahael> unsupervised: Apparently on Catalina that's "fixed", not entirely sure how but the instructions are supposed to be there for the new nix (are we there yet?).  But I'm curious about Big Sur.  New MacOS releases always break something.
06:23:59 <Lycurgus> why would you expect a commercial platform to be supported at all?
06:24:22 <slack1256> It is a popular platform for developers after all
06:24:35 <Lycurgus> macos?
06:25:02 <slack1256> But yeah, macOS breaks stuff without care for anyone. Maybe is that why nix doesn't support it well?
06:25:06 <Lycurgus> it's popular for people targetting apple
06:25:12 <Lycurgus> because they have to
06:25:33 <Lycurgus> and ofc the fanbase
06:26:03 <Arahael> I'm not sure about the fanbase.
06:26:11 <Arahael> The fanbase is perfectly happy with Swift, right now.
06:26:32 <slack1256> Swift is a good language.
06:26:47 <Lycurgus> i meant macos was (with them, could be their horizon)
06:27:05 <Lycurgus> and other apple os
06:28:37 <Lycurgus> i don't even use quartz on mac anymore, it's a locked proprietary platform and best used as such
06:28:46 <Lycurgus> nix/nixos are antithetical to that
06:29:19 <unsupervised> is this really the place for Free Software evangelism?
06:29:37 <slack1256> I thought that nix support for macOS was genius, as it really popular with webdev who could expand the npm support on nix. win win.
06:31:12 <Arahael> Quartz is dead.
06:32:11 <Lycurgus> well the issue isn't free software per se, but whether free software such as hs or nix should support apple
06:32:29 <Lycurgus> and to what degree
06:33:22 <Lycurgus> well whatever the X thing in mac is called now
06:36:00 <Lycurgus> appears to be quartz still, at least that's what i have installed on my current generation mini
06:57:07 * hackage cabal-cargs 1.3.0 - A command line program for extracting compiler arguments from a cabal file.  https://hackage.haskell.org/package/cabal-cargs-1.3.0 (DanielTrstenjak)
07:09:58 <Guest_49> You may want to source '/Users/shixiongxu/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
07:10:08 <Guest_49> Does anyone know how can I do this ?
07:10:12 <Guest_49> Thanks
07:10:42 <xerox_> Guest_49: you put 'source /...' in your shell profile file
07:10:56 <xerox_> if you already have .bash_profile or .bashrc in your home directory use that
07:11:18 <Guest_49> So I need to do this everytime I run ghci?
07:11:41 <xerox_> the idea is that when you run a shell henceforward, it will automatically run that command for you, so your environment is ready to do any ghc thing
07:11:56 <xerox_> if you don't put it in the shell profile file, you'll have to do it by hand instead
07:12:51 <Guest_49> I see, thanks
07:25:20 <unsupervised> I can't find much documentation on the theory behind code completion engines. Anyone know any?
07:25:27 <unsupervised> like intellisense
07:36:07 * hackage dijkstra-simple 0.1.0 - A simpler Dijkstra shortest paths implementation  https://hackage.haskell.org/package/dijkstra-simple-0.1.0 (gdifolco)
07:37:37 * hackage Gamgine 0.6.0 - Some kind of game library or set of utilities.  https://hackage.haskell.org/package/Gamgine-0.6.0 (DanielTrstenjak)
07:41:06 * hackage wai-saml2 0.1.0.0 - SAML2 assertion validation as WAI middleware  https://hackage.haskell.org/package/wai-saml2-0.1.0.0 (mbg)
08:04:07 * hackage layers-game 0.7.0 - A prototypical 2d platform game.  https://hackage.haskell.org/package/layers-game-0.7.0 (DanielTrstenjak)
08:17:04 <sm[m]> unsupervised: ask in #haskell-ide-engine
08:58:36 <dminuoso> unsupervised: Intellisense is surprisingly unintelligent.
08:59:12 <unsupervised> ok?
09:01:10 <dminuoso> Im confident there's not much deeper theory, you just have some good heuristics + a partial parser..
09:03:28 <dminuoso> One strategy could be to cache an AST every time compilation succeeds, such that when you modify the source code, and the user writes something like `foo.`, then it's already known what foo is, because the tool can statically analyze the AST.
09:03:34 <unsupervised> I'm thinking about keeping the token stream generic and tagging each based on probabilities or SAT solving on the surrounding tokens to try to come up with a probable parsable expression, then I could get autocompletion for typos anywhere in the stream or whatever. This is just a hypothesis though
09:04:17 <dminuoso> Which particular feature are you interested in?
09:04:48 <unsupervised> autocomplete suggestions in context free grammar
09:06:00 <dminuoso> unsupervised: Honestly for that you can just keep a trie of all known identifiers (based on previous successful parses)
09:07:42 <dminuoso> If you consider the modification locally, and just lex the newly inserted string, you can just consider the last written token and offer completion suggestions for that.
09:07:55 <dminuoso> (as opposed to trying to understand the entirety of the code)
09:08:34 <dminuoso> Furthermore, with the added knowledge of *where* in the current AST the modification is inserted, you can limit the trie to identifiers known to be in scope.
09:31:58 <monochrom> In which particular scope, the visible names form a trie.
09:32:56 <monochrom> Zoom out to see all scopes at once, they form a tree, and this tree has a prefix-extension nature too. Meta trie! >:)
09:34:04 <sm[m]> how do you force cabal build to rebuild all local package modules ?
09:36:29 <maerwald> sm[m]: cabal clean?
09:37:10 <sm[m]> seems so, thanks maerwald 
09:41:56 <ezzieyguywuf> So I'm reading through chapter 28 in Real World Haskell (maybe skimming is a more appropriate term), and I came across their function `removeInv :: Eq a => a -> [a] -> Maybe [a]` which uses `    case takeWhile (/= x) xs of`, but wouldn't this remove the target item _and_ any items "greater" than it in the inventory?
09:45:55 <c_wraith> I presume there's something further that adds the rest of the list in
09:47:40 <c_wraith> Nope, there isn't.  You're right, that code looks like nonsense.
09:47:45 <ezzieyguywuf> hah ok
09:47:49 <ezzieyguywuf> at least it's not just me.
09:48:35 <c_wraith> are you reading the online version?
09:48:43 <c_wraith> the comments on that snipped call out that the code is nonsense
09:48:43 <ezzieyguywuf> https://github.com/tssm/up-to-date-real-world-haskell/blob/master/28-software-transactional-memory.org
09:48:53 <ezzieyguywuf> this one, although it doesn't look like this chapter's been updated yet
09:49:04 <c_wraith> ah
09:49:11 <c_wraith> yes, that chapter isn't so up to date.
09:49:11 <ezzieyguywuf> c_wraith: ah, yea maybe I ought to go back to that version with comments.
09:49:17 <ezzieyguywuf> forrill?
09:49:19 <ezzieyguywuf> dang
09:49:43 <c_wraith> I mean, STM hasn't really changed, so there isn't much to update on the actual point of the chapter
09:50:03 <c_wraith> fixing examples that were as wrong originally as they are now might have been considered out of scope
09:50:05 <ezzieyguywuf> ok that's good
09:52:19 <shapr> What's the easiest way to build a concurrent UDP server these days?
09:52:32 <shapr> I want to put together a really simple DNS server, it doesn't have to be production quality.
10:10:34 <dmj`> shapr: probably with network, using Datagram flag
10:16:37 <ja> how do i call eq for two different types that are both instances of the same type class?
10:17:07 <ja> i want to use equality defined using the values that the type class guarantees are available
10:17:43 <ja> i guess the problem is that those only happen to be values because of the way type classes work...
10:18:29 <ja> i could define a function on the type class that converts an instance to a record, and then i could compare that record, but that seems clumsy
10:18:35 <monochrom> The standard Eq cannot. If you create your own class, it will be a two-param type class. You will face quadratic blowup.
10:19:37 <merijn> Clippy popup: "Are you sure you don't want 'a function'?"
10:20:17 <monochrom> Or I misread and you mean comparing two types (as worded), not two values from two types.
10:21:01 <monochrom> Gah, the existence of type-level programming makes casual speech impossible.
10:21:07 <ja> no no, i have A and B, they both are instances of I. and now i want to use hedgehog to do "(a :: A) === (b :: B)"
10:21:15 <merijn> monochrom: I propose we ban it ;)
10:21:59 <ja> merijn: so you propose a custom equality function that i somehow feed into hedgehog? seems reasonable
10:22:37 <monochrom> Normally, two instances of the same class have virtually no relation.
10:22:49 <merijn> ja: I mean, most use cases of "complex interaction of several types based on their typeclasses" can be implemented infinitely simpler as "a -> b -> Bool" ;)
10:23:46 <ja> ah, i understand. in this case A is a FFI-wrapped go implementation, and B is the haskell reimplementation
10:24:03 <ja> so i generate some random actions, and then i want to assert that the resulting structure is the same
10:24:34 <ezzieyguywuf> ja: at runtime?
10:24:35 <merijn> ja: Right, but as long as you can write a function that does that and parameterise over said function you can forget Eq even exists :)
10:25:05 <ezzieyguywuf> why not just convert the go stuff to haskell, and write a unit-test or QuickSpec that gives you confidence that this always works right?
10:25:06 <monochrom> Is === a hedgehog operator? What is its type? What does it do?
10:25:11 <ja> ezzieyguywuf: yeh yeah, everything is runtime
10:26:20 <EvanR> a == b, clearly false
10:26:32 * ezzieyguywuf nods
10:26:36 <EvanR> depending on your font
10:26:47 <ezzieyguywuf> I mean, say you were writing a csv parser
10:27:03 <ezzieyguywuf> would you check `[data] == fileHandle`?
10:27:13 <ja> monochrom: yes, here it is https://hackage.haskell.org/package/hedgehog-1.0.2/docs/Hedgehog.html#v:-61--61--61-
10:27:27 <ja> (===) :: (MonadTest m, Eq a, Show a, HasCallStack) => a -> a -> m () 
10:27:49 <ezzieyguywuf> ah, hedgehog is the test thing
10:27:53 <ezzieyguywuf> this is making a bit more sense.
10:28:12 <ja> ezzieyguywuf: yes i am doing what you described with QuickSpec?
10:28:24 <ezzieyguywuf> ja: I think so yea.
10:29:15 <monochrom> What does it mean for an FFI-wrapped Go implementatin to be "equal" to a Haskell implementation? I would code up that meaning first. I would worry about getting === to use my code later, especially since this part cannot become obvious earlier.
10:30:30 * ezzieyguywuf nods
10:30:35 <monochrom> But I understand that you must get === involved eventually because you are writing a test harness in hedgehog.
10:31:11 <ja> by amending the typeclass with a "toRecord" function, i can just compare that
10:31:25 <ezzieyguywuf> someone in here mentioned Queue once when I was (inadvertently) asking questions about concurrency, specially because Chan is unbounded
10:31:36 <ezzieyguywuf> but I can't seem to find a single Queue data type on hoogle
10:31:42 <ezzieyguywuf> is it maybe named something else?
10:31:43 <merijn> ezzieyguywuf: TQueue probably
10:31:47 <ezzieyguywuf> ah hah, that was it
10:31:50 <monochrom> stm has a TQueue
10:32:01 <merijn> Which isn't bounded either
10:32:08 <merijn> But there's also TBQueue somewhere, which is
10:32:30 <ezzieyguywuf> how is TQueue better than Chan then, just performance?
10:32:31 <monochrom> Are you sure you prefer bounded?
10:32:43 <monochrom> Merely MVar vs STM.
10:32:54 <ezzieyguywuf> yea maybe MVar
10:33:03 <ezzieyguywuf> oh wait, *goggly eyes*
10:33:05 <monochrom> Err, "merely" haha. MVar vs STM has huge consequences.
10:33:12 <MarcelineVQ> @where parconc
10:33:12 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
10:33:16 <ezzieyguywuf> lol, I'm just dipping my toes in this concurrency stuff
10:33:20 <MarcelineVQ> ^ That covers the difference nicely
10:33:39 <MarcelineVQ> At least as far as MVar vs STM, though probably chans too
10:34:17 <MarcelineVQ> despite the advertising the book is avaialable for free at the bottom
10:34:18 <ezzieyguywuf> yea, i should probably read that. and sit down and figure out if i reallllly need concurrency or parallelism
10:34:26 <MarcelineVQ> At least it was..
10:34:45 <MarcelineVQ> ah yeah it is still, just navigates weird
10:35:02 <monochrom> One consequence: Not a fault of MVar per se, but: There are a few library MVar operations that are broken under async exception, and the decision was "wontfix, too hard, use STM".
10:35:34 <ezzieyguywuf> is it generally 'better' to use STM, or is it one of those 'right tool for the job' things
10:35:54 <merijn> ezzieyguywuf: The latter
10:36:05 <ezzieyguywuf> thought so
10:36:08 <MarcelineVQ> it's always right tools even when people say otherwise :>
10:36:15 <MarcelineVQ> *for the job
10:37:02 * ja just noticed that Lean 4 is reference counted! very interesting
10:37:18 <monochrom> right-tool-for-job is always right. But you can always relax to good-enough-tool-for-job, and then you find out that there are cases of one tool being good enough for 90% of the jobs. STM is one of those cases.
10:37:51 <ja> sounds like it makes sense to start out with STM for concurrency
10:37:52 <MarcelineVQ> speaking of tools, deforestation/fusion is so cool, just wrote some and still not sure how it works but it took 1/3 off my maximum memory footprint. 1.5 giggabytes less work
10:37:55 <ezzieyguywuf> I mean, if I want my user to be able to interact with my program in a REPL-style _and_ a GUI at the same time...does that automatically mean concurrency?
10:38:09 <monochrom> Similarly, any of {Data.Map, Data.Hashmap} is good enough for 90% of lookup jobs.
10:38:24 <ja> MarcelineVQ: where does the term deforestation come from?
10:38:34 <ezzieyguywuf> ja: from killing all the trees
10:38:39 <MarcelineVQ> wadler make it up in reference to removing intermediate trees
10:39:02 <MarcelineVQ> https://en.wikipedia.org/wiki/Deforestation_(computer_science)
10:39:06 <ezzieyguywuf> de, greek for "make go away", forest, latin for "lots of trees", ation, mandarin for "no really, there's a lot of them."
10:39:41 <ja> so 'stream fusion' is a special case of it?
10:39:50 <MarcelineVQ> it juxstaposes nicely with with defenestration, which is the act of throwing something (or someone) out a window
10:40:03 <monochrom> hahaha
10:40:14 <ezzieyguywuf> lol
10:40:16 <ezzieyguywuf> nice one.
10:40:57 <MarcelineVQ> ja: possibly, that might be called shortcut fustion, depends specifically what you mean and I'm not solid on the terms yet myself
10:41:08 <MarcelineVQ> *fusion
10:41:29 <shapr> dmj`: thanks, I'll try that
10:41:52 <MarcelineVQ> And there's probably not even a big difference if there is one anyway
10:42:00 <dmj`> shapr: this seems helpful too http://www.mchaver.com/posts/2017-06-12-haskell-network-programming-1.html
10:42:03 <dolio> Stream fusion is fusion/deforestation of streams, so yes. :)
10:44:06 <shapr> dmj`: oh that's exactly the kind of thing I wanted! thanks so much!
10:44:41 <dmj`> shapr: cool :) 
11:04:12 <lifelearner> Among Haskell, Erlang, and Clojure, which one is the most promising as the mainstream FP?
11:04:49 <merijn> lifelearner: Define "mainstream"
11:05:21 <lifelearner> Just like Java or Python... where there are others.
11:06:05 <merijn> I guess that also depends on how you define promising and "FP" too :)
11:06:21 <monochrom> Why do you ask?
11:07:12 <lifelearner> I want to pick one and invest in learning one of FP languages.
11:07:37 <monochrom> What do you consider to be return of investment?
11:07:51 <monochrom> Especially since you word it as "invest".
11:07:54 <lifelearner> At least on IRC, this channel has 4 times more people than in #erlang or #clojure.
11:08:47 <lifelearner> Investing into a more widely acceptable skill.... e.g. Python than Ruby.... Java than C++
11:09:12 <monochrom> I bet Clojure is more widely accepted than Haskell.
11:09:46 <merijn> I fundamentally disagree with the premise :p
11:10:01 <merijn> i.e. that "investing" in a language only pays off in that language
11:10:23 <lifelearner> Then, what do you think the easiest among those 3?
11:10:27 <monochrom> All programmer channels together have infinitely more times more people than all of accounting, medical doctors, lawyers, pharmaceutical people adding together.
11:10:48 <monochrom> Guess which side has more people IRL and making more money.
11:10:49 <merijn> I mean, Python and Ruby are basically the same thing with a bit of squinting, so pretending that time invested in Ruby is "useless" because python has more jobs seems silly
11:11:19 <monochrom> Clojure is also the easiest.
11:11:27 <merijn> Easiest? Probably Clojure, but that's probably also the one least worth learning :p
11:11:48 <lifelearner> No matter how good, I don't want to invest my focus into something rare.
11:12:08 <merijn> lifelearner: Then this is probably the wrong channel to ask ;)
11:12:36 <lifelearner> How come there are so many people here than in #clojure or #erlang?
11:12:41 <oats> lifelearner: why is it you want to learn one of these languages in the first place? what are you hoping to gain from it?
11:12:43 <shapr> lifelearner: because Haskell is fun!
11:13:02 <shapr> Haskell is brain-stretching, and will change the way you think about programming.
11:13:06 <merijn> lifelearner: because haskell is more fun, more interesting, and more educational :)
11:13:07 <wavemode> frankly, if you're able to relocate anywhere in the world, you can find a programming job in any programming language. but if you're looking for jobs near you, that will obviously restrict your decision
11:13:15 <lifelearner> getting into distributed application development?
11:13:21 <merijn> wavemode: Even then
11:13:23 <maerwald> lifelearner: how much time you got?
11:13:44 <merijn> I don't belive in "being an X programmer" regardless of which language X is
11:13:44 <lifelearner> maerwald: Couple of months
11:14:01 <oats> oh dear hmmm
11:14:07 <lifelearner> I know that I won't be an expert in couple of months.
11:14:12 <maerwald> lifelearner: I'd say haskell takes the longest time for those 3
11:14:26 <maerwald> so pick that if you got the time
11:14:27 <lifelearner> ok.
11:14:36 <oats> I'd be willing to be the job market for clojures is overall the biggest of the three
11:14:49 <maerwald> oats: also pays better
11:15:04 <maerwald> but the language is so boring, god...
11:15:12 <lifelearner> But, Haskell is a more fun language?
11:15:19 <maerwald> depends
11:15:20 <wavemode> but there is still no guarantee that if you learned clojure, you'd get a job in clojure. it is still relatively obscure in the grand scheme of things. so it will depend on where you're willing to go
11:15:28 <merijn> Learning to program well is orthogonal to the language(s) used. That's not to say that language choice is irrelevant, but it means that picking a specific language for demand reasons rather than "what it will teach you" seems unwise
11:15:29 <maerwald> generally yes
11:15:30 <wavemode> which is why "what language should I invest in?" in unanswerable in the general case
11:16:02 <maerwald> merijn: it is wise if you  care about career only
11:16:04 <monochrom> merijn: You're now arguing personal values. It's going to be in vain.
11:16:30 <shapr> I like writing fun tools and toys in Haskell.
11:16:58 <merijn> monochrom: If people are going to ask subjective questions, I'm going to answer them with the one universal truth, i.e. my opinion :p
11:17:09 <lifelearner> I assume Clojure has the least verbose syntax, if it's the easiest?
11:17:27 <maerwald> merijn: I've worked with an extremely smart go dev once who was a photographer by profession and just wanted something that makes more money and taught himself that.
11:17:29 <shapr> A few weekends ago I wrote something that records how long it takes to run a task, and then predicts how long that task will take this time: https://github.com/shapr/sandwatch/
11:18:05 <shapr> I got the idea from my test suite status toy: https://twitter.com/shapr/status/1257789158677872640
11:18:09 <monochrom> Clojure is the easiest because it doesn't make you ask the tough questions.
11:18:16 <shapr> The goal is to have a count-up that predicts how much time you have before a task is completed.
11:18:29 <monochrom> Or rather, it doesn't ask the tough questions.
11:18:34 <merijn> monochrom: Who am I? What do I want?
11:18:55 <merijn> monochrom: "What flavour ice cream do you want?"
11:18:56 <shapr> lifelearner: You could commit to spending two hours with each of the languages on your list and then see how you feel about them?
11:18:59 <monochrom> Erlang asks one tough question. Haskell asks another bunch of tough questions.
11:19:26 <lifelearner> shapr: yep, testing waters.
11:19:29 <shapr> lifelearner: would you like instructions for installing Haskell?
11:19:54 <shapr> I recommend ghcup https://www.haskell.org/ghcup/
11:20:02 <shapr> If you're on Mac or Linux
11:20:09 <lifelearner> shapr: ok, thanks.
11:20:20 <shapr> lifelearner: I'm happy to help you get started if you have any questions!
11:20:24 <shapr> feel free to ask me here
11:20:42 <shapr> Right now I'm building a toy DNS server.
11:21:10 <maerwald> lifelearner: clojure syntax, even after months of using it, is still a visual burden imo
11:21:13 <shapr> I have no idea what I'm doing, it's great fun!
11:21:24 <lifelearner> ok, great. thanks for your offer, shapr!
11:21:52 <maerwald> haskell tends to be dense too, but you don't get eye cancer
11:21:52 <shapr> lifelearner: I also have a job writing Haskell, so if you have questions about Haskell in industry, I can probably help.
11:23:10 <wavemode> lisp parentheses, like many things in programming, are an acquired taste :p
11:24:29 <maerwald> wavemode: euphemism for stockholm syndrome?
11:25:01 <shapr> I think programming is unnatural, I suspect it's all an acquired taste.
11:26:19 <monochrom> How would any programming language give you eye cancer? I thought only CRT monitors had a chance.
11:26:32 <int-e> heh. main = putStrLn "Hello, world!" and it's all downhill from there.
11:27:00 <monochrom> IO is an uphill battle, and it's all downhill from there.
11:27:42 <maerwald> monochrom: fear and pain, which leads to a stressed position, you blink less, your eyes get inflamed... cancer is an inflammation based disease
11:28:08 <monochrom> ("___ is uphill both ways, and it's all downhill from there" is my new favourite pessimism. :)  My earlier one was: every silver lining has tarnish.)
11:28:27 <oats> hah
11:51:36 <lifelearner> shapr: I installed haskell-platform.
11:52:08 <lifelearner> shapr: How long did it take for you to write your first distributed application with Haskell?
11:52:25 <lifelearner> regardless of the complexity
11:52:31 <shapr> lifelearner: what do you mean by a distributed application?
11:53:20 <shapr> do you mean "can use all the cores in my computer" ?
11:53:27 <lifelearner> One of good things using a FP language is to develop a distributed application, right?
11:53:36 <shapr> or perhaps "web application that pushes work to the browser" ?
11:54:10 <lifelearner> an application that works on different nodes distributed
11:56:00 <lifelearner> "can use all the cores in my computer" = multi-threaded application, right?
11:56:01 <arianvp> anybody here worked with the cborg library?
11:58:05 <joncol> Forgot too much Haskell... What's a more succinct way of writing `\sc -> sendToScreen def sc >> viewScreen def sc`? Can you make it pointfree?
11:58:51 <arianvp> http://pointfree.io/
11:59:25 <arianvp> ap ((>>) . sendToScreen def) (viewScreen def) apparently :P but i think there's a nicer way?
12:01:12 <joncol> arianvp: Yes, that doesn't look too hot.
12:01:24 <glguy> joncol: You should leave it like you have it
12:01:55 <joncol> glguy: Kk, sounds good :).
12:02:40 <joncol> Maybe even looks better using `do`.
12:05:43 <arianvp> the other trick would be to wrap your monad in a ReaderT so that the arguments are passed along automatically
12:06:00 <arianvp> then you could write     sendToScreen sc >> viewScreen sc
12:06:18 <arianvp> if you're passing around `def` everywhere
12:19:12 <doyougnu> Hi everyone, I'm trying to run haddock on my benchmark suite but haddock cannot find any of the imported modules. Anyone know if I can specify the cabal target?
12:19:36 * hackage text-time 0.3.1 - Library for Time parsing from Text into UTCTime  https://hackage.haskell.org/package/text-time-0.3.1 (klangner)
12:22:52 <shapr> aw, lifelearner left
12:23:00 <shapr> I was on a phone call so I couldn't answer :-(
12:23:14 <shapr> I think I only built a distribute Haskell application once, it wasn't easy.
12:23:20 <shapr> But I haven't looked into Cloud Haskell recently
12:23:46 <maerwald> shapr: cloud haskell has stalled, no?
12:23:52 <shapr> I don't know!
12:24:23 <shapr> I know there were several libraries for running Haskell code on other computers, but I haven't looked recently.
12:43:04 <juri_> looks stalled.
12:43:29 <c_wraith> I think cloud haskell started with a vague mission and is suffering from that.
12:45:53 <maerwald> I want to try a new testing framework, so no hspec
12:46:03 <maerwald> Opinions?
12:46:16 <juri_> hspec.
12:46:21 <juri_> :)
12:46:26 <monochrom> why no hspec?
12:46:34 <maerwald> bc that's not new for me
12:46:39 <monochrom> oh
12:46:44 <MarcelineVQ> is tasty new?
12:46:54 <maerwald> I guess
12:46:58 <maerwald> is it cool?
12:47:05 <MarcelineVQ> idk, the cool kids use it
12:47:42 <maerwald> I don't like tons of boilerplate to set up stuff... so I was actually a doctest fan, until I realised how broken it is
12:51:41 <merijn> maerwald: I prefer tasty to hspec
12:51:51 <sm[m]> Yeah tasty is cool and seems the current mainstream
12:52:11 <merijn> maerwald: Because it's API is more just "datatypes and functions" rather than "pseudo DSL based on typeclasses with all the ambiguity that entails"
12:52:41 <merijn> maerwald: I'm not sure whether tasty has *less* boilerplate than hspec, but unlike hspec it's much simpler to wrap/abstract any boilerplate
12:53:25 <maerwald> yeah, functional programming seems to be less popular these days (writing actual functions)
12:54:04 <maerwald> I never attempted to understand the hspec monads
12:54:22 <merijn> maerwald: I tried for 5s, than looked for an alternative and ended up with tasty :p
12:54:27 <merijn> s/than/then
12:54:32 <maerwald> it's probably not designed, but evolved
13:13:37 * hackage exigo-schema 0.2.0.2 - database schema for exigo marking/assessment tools  https://hackage.haskell.org/package/exigo-schema-0.2.0.2 (phlummox)
13:19:00 <doyougnu> +1 for tasty as well
13:34:06 <lc> Cale: I know it's been twelve hours, but holy shit you have miri as an employer?
13:34:34 <lc> or client or whatever
13:44:32 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/CoFlamedjInRKvsmExBUaqfq >
13:45:21 <gcoakes[m]> i.e.: an instance of `Tile` contains a value that is a `Bits` and allows me to fmap/retrieve that bits value.
13:47:03 <merijn> gcoakes[m]: Your first message is too long matrix moved your message to some link that 95% won't open
13:47:21 <gcoakes[m]> Oh
13:47:35 <gcoakes[m]> What's the best way to show code in here?
13:48:27 <merijn> I'm not sure what the current favourite paste site is
13:49:08 <gcoakes[m]> https://pastebin.com/C5VZsWrk
13:49:12 <gcoakes[m]> This work?
14:04:07 * hackage massiv-test 0.1.3.1 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.3.1 (lehins)
14:10:07 * hackage dobutokO-effects 0.1.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.1.0.0 (OleksandrZhabenko)
14:50:45 <halogenandtoast> I am trying to figure out if something exists. I have a bunch of calls of type (a -> a) currently but what I'd like to do is to chain a bunch of these calls together but have a way of doing two different things, I might want the chain to stop at a certain point so after it hits that it won't run any more of the steps in the chain, alternatively I want a way to specify that it should skip beginning
14:50:46 <halogenandtoast> parts of the chain until it reaches a resumable spot.
14:52:02 <halogenandtoast> Originally I thought, oh this is a monad, but since I don't ever want to change the internal structure (no a -> b) I can't write reasonable Functor or Applicative instances
14:52:03 <dsal> What would the signature look like?
14:52:32 <dsal> How would it know to skip or terminate?
14:53:00 <halogenandtoast> I was thinking of wrapping my a like this: data GameSequence = GoSequence Game | StopSequence Game | ResumeSequence String Game
14:53:28 <halogenandtoast> and then trying to wrap operations with something like this: data GameSequenceComp = Ordinary (Game -> GameSequence) | Resumable Text (Game -> GameSequence)
14:54:16 <halogenandtoast> This is really just a rough sketch of what I'm thinking, the structures might be terrible but maybe that conveys what I am thinking
14:55:00 <dsal> OK.  That's not `a -> a` :)   At that point, you've made something a little like fix.
14:55:02 <dsal> :t fix
14:55:03 <lambdabot> (a -> a) -> a
14:58:04 <Cale> lc: yeah, they're our client
14:58:20 <Cale> lc: We're working on GHC on their behalf
15:00:11 <halogenandtoast> dsal: yeah you are right that it's not (a -> a) I guess it's more like an (a -> ? a)
15:00:44 <lc> Cale: That's so cool
15:08:47 <halogenandtoast> I guess a better way of stating it is that currently I have steps in the shape of (a -> a) and it looks like this `game & step1 & step2 & step3 & step4` but I'd like to change it so any step can prevent steps further in the chain from "updating the value". Additionally I'd like some way to be able to have it ignore step1 and step2 conditionally (for example) and start at step3. 
15:16:26 <c_wraith> So.. You want the monad instance for Either, along with Either a a ?
15:17:05 <halogenandtoast> c_wraith: it's sort of like that, but yeah at some point I want to say, even if this is a left, convert it to a right and "do the thing"
15:17:39 <c_wraith> that doesn't seem like a problme
15:17:45 <c_wraith> or problem, for that matter.
15:17:53 <c_wraith> :t either id id
15:18:04 <wavemode> write your own monoid with those semantics, then. Pause, Resume, Continue
15:18:17 <c_wraith> @botsnack
15:18:26 <c_wraith> huh, guess lambdabot's dead
15:19:46 <halogenandtoast> I'm going to go back to pen and paper for a while and try to map this out...
15:26:30 <dsal> :t asum
15:26:39 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
15:28:32 <Cheery> a person is claiming that "free monads" have a bad reputation, can you open it up a bit?
15:28:43 <dsal> What do you want to know?
15:29:00 <Cheery> Is there some context or history to this? or is it just some rheroric?
15:29:03 <dsal> Monads are like burritos, and some people like burritos for lunch, but then they want free burritos and there is no free lunch.
15:29:14 <Cheery> https://github.com/graninas/hierarchical-free-monads-the-most-developed-approach-in-haskell/blob/master/README.md
15:29:24 <dsal> Most of the implementations of free monads are somewhat costly.
15:29:33 <wavemode> there are papers which go into more detail, but basically, the bind operator for free monads (>>=) is inefficient
15:30:19 <dsal> polysemy evidently fixed that, but then dude wrote a retraction, so maybe it's not fixed yet.
15:30:22 <c_wraith> note that most people's reactions to his post was "what are you talking about?"
15:30:45 * hackage massiv 0.5.3.1 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.3.1 (lehins)
15:31:00 <dsal> c_wraith: Which post?  There are a lot of posts that I have that reaction to. heh
15:31:03 <c_wraith> Not that free monads are necessarily fine, but he spent a long time rambling about how great an unappreciated his approach was, but no time at all on actually explaining what it was or how it fixed pain points in other systems
15:31:10 <c_wraith> dsal: the hierarchical free monads thing
15:31:16 <dsal> Oh.  I hadn't read that.
15:31:33 <Cale> Cheery: This reputation is a bit deserved, since any time you defer the decision about how various operations are implemented, you're putting an obstacle in the way of the compiler optimisations.
15:32:43 <Cale> There may be reasons you still want to do it, but just using free monads for the sake of using free monads is not usually the best idea for performance.
15:33:07 <wavemode> the advantage, though, is that free monads enable ergonomic extensible effect systems
15:33:55 <wavemode> that said, I've never needed extensible effects in my life. but I respect the effort
15:34:06 <Cale> Yeah, imo, people are far too excited about effect systems.
15:34:55 <dsal> I've tried to need them a few times, but failed.
15:36:27 <Cale> My approach is typically to use monad transformers, but strictly as an implementation detail which gets obscured by a module boundary
15:37:58 <merijn> Cale: pfft, you and your "solid engineering" and "maintainable, straight-forward haskell"...
15:38:07 <merijn> That's so early 2000s
15:38:08 <Cale> lol
15:38:18 <merijn> We want unmaintainable type level hasochism in 2020!
15:38:27 <Cale> Yeah, I don't really understand what's happened
15:38:39 <Cale> There seem to be a lot of people writing some very strange Haskell these days
15:38:51 <merijn> Cale: Beginners come in and learn about the power of types and then they wanna do everything in the type level
15:39:25 <dsal> Wait until we get Kind-level metaprogramming.
15:39:30 <merijn> The number of people I've seen come in here, do Haskell for 1-2 months and decide to do type-level validation of all their code enabling -XKitchenSink is entirely too high >.>
15:39:39 <Cale> I think it's also that nobody's talking about more straightforward programming in Haskell as much as they did back when that was new
15:39:41 <int-e> Everybody read https://aphyr.com/posts/342-typing-the-technical-interview and thought they wanted to be like that?
15:39:57 <merijn> Invariably they'll be stuck, struggling and asking people to suffer through their incomprehensible mess
15:40:04 <merijn> int-e: I do want to be like that :p
15:40:08 <merijn> int-e: He's my hero :p
15:40:45 <merijn> Cale: honestly, I blame the overfocus on "safe" :p
15:41:05 <glguy> If people want to just write programs and get things done they'd just keep writing them in $LANG they already know. They come to Chotchkie's for the atmosphere and the attitude. Okay? That's what the flair's about. It's about fun.
15:41:23 <dolio> It's also unclear to me how 'effect system' inspired stuff will ever be a significant win in Haskell.
15:41:27 <int-e> The moment you have to fix type errors in obviously correct code you've probably overdone it with the types :-/
15:41:30 * dsal now reads -X as "flair"
15:41:43 <merijn> glguy: How can you have fun without -XMagicHash...
15:42:04 <dolio> It might be somewhat of a performance benefit, but you won't be getting direct-style syntax, right?
15:42:17 <glguy> Or... well, like Brian, for example, has thirty seven language extensions in his file, okay. And a terrific smile.
15:42:44 * hackage termbox 0.2.0.1 - termbox bindings  https://hackage.haskell.org/package/termbox-0.2.0.1 (mitchellwrosen)
15:42:59 <wavemode> researchers won't be satisfied until the type system can not only guarantee statically that the program runs correctly and produces valid results, but also that the product the code is running in will be useful, well-received and profitable for the company
15:43:41 <int-e> wavemode: you lost me at product and useful.
15:44:43 <merijn> wavemode: Amusing that you think researchers are as pragmatic as that :p
15:44:58 <merijn> As long as it publishes! ;)
15:45:31 <Cale> Yeah, sorry, but linear types are definitely not trying to guarantee that anything will be profitable
15:45:33 <c_wraith> Funny.  I keep wanting dependent stuff not for safety, but just so I can pass values as type arguments in instances.
15:45:57 <c_wraith> It occurred to me, at some point, that everything I want to do with that could also be done with local instances.
15:46:09 <merijn> c_wraith: I would like dependent stuff
15:46:14 <merijn> Just not in Haskell :p
15:46:36 <merijn> It's not designed for it and turning it into functional C++ makes me sad
15:46:40 <c_wraith> So...  can we have local data types and instances?
15:46:49 <c_wraith> That requires almost no syntax!
15:46:57 <int-e> c_wraith: no. yes, via an unsafe coerce trick
15:47:01 <Cale> For the dependent stuff, I can think of a lot of good uses for it, but mostly I'm afraid of the monstrosities that I know I'm going to run into
15:47:17 <int-e> (well strictly only for performance)
15:47:27 <c_wraith> int-e: yeah, I'm trying not to use reflection
15:47:39 <Cale> People can already create bureaucratic nightmares with the Haskell type system, and dependent types are just going to make that even more painful/
15:47:42 <Cale> .*
15:48:21 <int-e> c_wraith: reflection is great, except for the terminology
15:48:45 <dolio> Are the local instances only for the local data types?
15:48:48 <c_wraith> I even looked at implicit params, but it turns out putting an implicit param on an instance is an error
15:48:52 <c_wraith> dolio: for my cases, yes
15:49:39 <Cale> I've seen codebases where some people were ensuring things using singletons that absolutely nobody ever cared about guaranteeing, and it just made the code absolutely horrible to work on.
15:49:50 <int-e> Cale: At some point, hopefully, the community will focus on dependable types instead, types you can rely on to make your life easier.
15:50:28 <Cheery> Well.. I'm writing sort of a criticism to the post and collecting material.
15:50:30 <c_wraith> In my experience, the most useful tool in Haskell's type system is parametricity
15:50:32 <dolio> Well that's good, because otherwise local instances fundamentally change type classes into something else that breaks a bunch of common data structures.
15:51:15 <arahael2> Cale: i have the same problem in a swift codebase.  and swift doesnt have dependabt types either.  i think some programmers will do everyhing to try and make sure the code can only be implemented "correctly". :(
15:52:01 <Cale> There's not necessarily anything wrong with ensuring important things
15:52:08 <int-e> re: reflection, who actually thinks of types as more concrete than values?!
15:53:04 <Cale> But yeah, it's really easy to draw the line too far on the side of ensuring properties that aren't necessarily even going to remain requirements forever.
15:54:52 <int-e> Cale: maybe if there was a good weakening mechanisms, selective forms of 'coerce'. Though even that will clutter the code.
15:54:56 <c_wraith> Cale: hmm.  people often go overboard the same way on testing.  A lot of people claim you need so many tests that any mild refactoring will cause many test failures.
15:57:01 <c_wraith> by contrast, yesterday I ripped several test stubs out of some code because they were adding redundancy and complexity and not actually making things any more reliable.
15:57:22 <merijn> c_wraith: Considering the ROI of writing tests and how to most effectively get the greatest return requires thinking, though
15:57:25 <Cale> int-e: Hmm, I had a strange idea the other day that it might be nice in certain cases to have a language construct where you could take some name and give it a new type signature, and rather than checking that the type of the thing could be unified with that type, it would check that the definition of that thing could be given that type (so long as the definition was still transparent)
15:57:40 <merijn> c_wraith: Better to just blindly chase 100% coverage and write pointless tests for every meaningless thing!
15:57:57 <Cale> Not sure if that's related to what you're thinking of
15:58:01 <merijn> c_wraith: Of course, only in isolation, so rearchitecture everything so you can replace everything else with mocks!
15:58:52 <Cale> But yeah, it breaks what is usually an abstraction barrier...
16:00:32 <c_wraith> Yeah, I ran into some testing stubs that were making implementing a new feature harder.  So I just removed them.  It felt good.  (Then I merged the code and deployed it to QA without anyone else looking at it, and it all worked right.  That's surely some sort of anarchy.)
16:02:26 <merijn> c_wraith: But if you don't mock and some code you depends on breaks your tests will fail!
16:02:37 <merijn> 'wasn't that...the point?'
16:02:51 <maerwald> merijn: I'm starting to think only testing what is exposed makes sense (for a library, exposed API, for an application feature integration tests)
16:03:12 <c_wraith> Mostly I don't see the point in unit tests, except in the rare cases where a unit needs to comply with some external specification
16:05:17 <merijn> c_wraith: From highest to lowest return on investment I think the test hierarchy is: smoke tests, regression tests, integration tests, property tests, everything else
16:06:09 <dolio> Cale: Oh, I think another amusing thing is that if you follow effect system literature, there are some issues with type systems for them that people are dealing with, and they're essentially re-inventing type classes/GHC's implicit arguments to have a more disciplined system.
16:06:38 <maerwald> property tests have low value in my opinion, because people rarely can come up with a sophisticated enough generator that triggers the interesting codepaths
16:06:42 <dolio> Where handlers are resolved in a sort of static scoping way.
16:07:02 <merijn> maerwald: Still higher value than having a single hardcoded test value :p
16:07:28 <maerwald> good unit tests are better for complicated API
16:09:19 <maerwald> when your financial function throws out garbage for loan periods starting in 1865 and no one has any idea why
16:09:43 <maerwald> its time to remove that property test :p
16:09:58 <monochrom> I think it's called "machine learning" when that happens.
16:10:16 <Cale> dolio: haha
16:12:23 <dolio> I kind of pity anyone trying to build an untyped system that has algebraic effects, too, because I have no idea how you'd resolve the issue then.
16:12:59 * arahael2 whispers - "scipy/numpy"
16:16:02 <dolio> It reminded me of the old oleg writeup on how "GHC's implicit arguments aren't really dynamic scoping," where apparently the repeated rejoinder is, "good, nobody actually wants dynamic scoping."
16:40:59 <slack1256> I got a program that prints on stderr "thread blocked indefinitely in an STM transaction". Any way to know which thread or variable this is?
17:24:26 <rand809809> Hi, I was doing this assignment https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf(Exercise 2) and I came up with this https://gist.github.com/bananabrick/d7e9e720843d3172d04b0412f393bf7 https://gist.github.com/bananabrick/d7e9e720843d3172d04b0412f393bf7c
17:24:53 <rand809809> I was wondering if that makes sense? It honestly took me longer than expected to figure this one out.
17:26:10 <rand809809> And it was kind of disheartening that it took me long to write like 5 lines of code lol
17:27:14 <rand809809> Sorry, this is the assignment  https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf  and I was doing Exercise 2
17:28:38 <koz_> rand809809: This exercise is actually quite involved, so the fact it took a while is totally OK.
17:29:04 <koz_> Solution seems reasonable to me.
17:31:34 <monochrom> Learn a musical instructment to find out it may also take a lifetime of studying and practicing to play 5 notes---if you want the audience to be very touched by those 5 notes.
17:32:26 <Cheery> especially if it's the world's smallest piano.
17:32:47 <koz_> "Sorry that I wrote you a long letter - I didn't have time to write a short one" also applies - just because something is _short_ doesn't mean it's simple.
17:33:52 <monochrom> I think of it as: The visible output is simple, but it takes so much education and understanding in the background to arrive at.
17:34:48 <rand809809> True. Even now I honestly have no idea how I arrived at the solution. I had to manually look at the types at each step to see if they made sense lol
17:35:05 <koz_> rand809809: This is something you will do a lot.
17:35:25 <koz_> Be a keen student and follower of the types - it will get you surprisingly far.
17:36:13 <monochrom> In the case of the shorter letter, it certainly first requires you to write the long letter by stream of consciousness, then you throw it away and---now that you have thought it through and see how to refactor---write the short letter. It does takes longer and more work.
17:36:27 <monochrom> In other words, prototyping.
17:36:48 <monochrom> I had to do it to my thesis too. (I thought I didn't have too.)
17:37:07 <koz_> monochrom: Hear hear.
17:42:02 <monochrom> Hoare said "so complicated it has no obvious errors vs so simple it obviously has no errors. the latter is hard". I didn't understand why the latter is hard until recently. If it's your first try, you will make a mess. If you haven't explored alternatives, you will make a mess. If you don't know many theories, you will make a mess.
17:42:45 <monochrom> You finally output a simple solution because you have output many messy solutions and felt dissatisfied.
18:14:58 <ezzieyguywuf> hah, parsers seem to be a theme around here the past few days
18:15:01 <ezzieyguywuf> or maybe it's just me.
18:15:53 <koz_> They come up a lot.
18:16:34 <ezzieyguywuf> now I kind of want to do the assignment ^_^
18:18:43 <halogenandtoast1> dsal: btw, this is sort of what I came up with: https://gist.github.com/halogenandtoast/2103d951d48196a783d1923cfbc9b61b
18:29:52 <halogenandtoast1> I still can't decide if that is a good or bad idea
19:05:59 <ezzieyguywuf> yikes, it _is_ tough figuring out this Applicative instance, lol
19:17:07 <fog> im trying to create a way to fold containers of values that have type annotations. but without lazyness at type level, many applications of this fold are impossible
19:17:30 <fog> for instance, if i fold a physical layer over an infinite list of update opperators
19:18:11 <fog> at the value level, I can encode lists using producers of values - and these can be consumed lazily by construction
19:18:52 <fog> this motivates using the state encoding to represent type level lists, to store the type parameters of lzy hetrogenous containers
19:19:54 <fog> then, lazy folding can be conducted, returning the carried value early if specified by the folding function, which then must have a way to access this early exit stratergy
19:20:50 <fog> using this instead of returning the basecase on having exhausted a pottentially infinite stream.
19:20:55 <fog> what is this?
19:22:44 <fog> how to implement take using fold?
19:25:31 <fog> there are some ideas here; https://stackoverflow.com/questions/15879940/implementing-take-using-foldr
19:25:46 <fog> but they seem to rely on haskell being lazy to fold from the left using foldr
19:27:06 <fog> the fact that it takes a decreasing Int as a counter seems to indicate that the descision about if to recurse on the fold should be embeded into the folding function itself, ie to have a different type and not infact be a fold at all
19:32:33 <fog> I checked at;
19:32:34 <fog> https://stackoverflow.com/questions/36851766/histomorphisms-zygomorphisms-and-futumorphisms-specialised-to-lists
19:33:09 <fog> to see if any of the common recursion schemes things fit the bill, but they dont... they are concerned with accessing other parts of this list, and not an early exit stratergy
19:34:49 <fog> aha! there it is here; https://wiki.haskell.org/Foldl_as_foldr_alternative
19:35:00 <fog> at the bottom there is foldl'Breaking
19:35:09 <fog> linked from here; https://stackoverflow.com/questions/51727040/how-to-break-out-from-a-fold-function-in-haskell-when-the-accumulator-met-a-cert
19:35:18 <fog> which also suggests scanning instead of folding
19:35:41 <fog> as the resulting intermediate stages of the fold can be lazily consumed over
19:52:55 <remexre> does cabal-install 3.2.0.0 not support ghc 8.8.3, or is my cabal setup miscellaneously broken
19:54:49 <remexre> or wait, ghc 8.10.1* ?
19:56:35 <remexre> (trying to cross-compile cabal-install, and it's not going well :P)
20:01:20 <ezzieyguywuf> does fmap and liftM do the same thing?
20:03:25 <koz_> :t liftM
20:03:26 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
20:03:29 <koz_> Yes
20:03:52 <ezzieyguywuf> thought so
20:03:59 <ezzieyguywuf> just needed to check, lol
20:20:44 * hackage calamity 0.1.17.0 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.17.0 (nitros12)
22:34:51 <LeafGecko> i encountered this problem during `stack install hindent` that says `Could not deduce (MonadFail m) arising from a use of 'fail' from the context: Monad m`
22:35:11 <LeafGecko> have no idea what is going on ..
22:35:20 <LeafGecko> here is full log: https://pastebin.com/w05xti8g
22:39:52 <LeafGecko> welp
22:53:33 <ptrcmd> LeafGecko: perhaps switch to an older version of GHC?
22:54:23 <ptrcmd> https://wiki.haskell.org/MonadFail_Proposal#Transitional_strategy
