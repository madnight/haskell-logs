00:07:39 <freeman42x[m]> I figure it out, cheers
00:14:43 <gvx> > map digitToInt "11000101101" -- if you don't mind importing Data.Char
00:14:45 <lambdabot>  [1,1,0,0,0,1,0,1,1,0,1]
00:21:49 <freeman42x[m]> is there a function to remove elements of a list from another list?
00:29:09 <MarcelineVQ> yep in Data.List
00:29:35 <gvx> > [1..10] \\ [1,4,6]
00:29:37 <lambdabot>  [2,3,5,7,8,9,10]
00:31:06 <dminuoso> freeman42x[m]: Depending on the size of those lists, you might want to consider Data.Set as well.
00:34:26 <dminuoso> Mmm, if I have a closed type family and apply it directly to a known type, is there some trick to splice in the evaluated type instead?
00:48:07 * hackage derive-lifted-instances 0.1.1 - Derive class instances though various kinds of lifting  https://hackage.haskell.org/package/derive-lifted-instances-0.1.1 (SjoerdVisscher)
00:54:09 <Axman6> dminuoso: do you mean like :kind! MyTypeFamily Double?
00:55:05 <Axman6> or foo :: a ! mMyTypeFamily Double => Foo a -> Bar a?
00:55:14 <Axman6> uh, ! = ~
01:15:37 * hackage path-extensions 0.1.0.1 - Enumeration of common filetype extensions for use with the path library.  https://hackage.haskell.org/package/path-extensions-0.1.0.1 (locallycompact)
01:20:14 <freeman42x[m]> @karma+ gvx thank you
01:20:14 <lambdabot> gvx's karma raised to 4.
01:32:30 <typetetris> \join #latex
01:36:23 <EvanR> #latex doing guerilla marketing
01:37:34 <boxscape> somewhat fitting to have that be the channel where one accidentally uses a backslash to join
01:40:47 * hackage update-nix-fetchgit 0.1.1.0 - A program to update fetchgit values in Nix expressions  https://hackage.haskell.org/package/update-nix-fetchgit-0.1.1.0 (srk)
02:04:47 <kuribas> what is the advantage of the RWST monad?
02:04:51 <kuribas> is it just a convenience?
02:06:28 <maerwald> advantage over?
02:06:36 <kuribas> ReaderT StateT WriterT
02:06:41 <maerwald> none
02:06:55 <srk> just an alias
02:07:06 <kuribas> ok
02:07:09 <merijn> Less nested >>= :p
02:07:30 <srk> RWS monad, RWS*T*ransformer :)
02:07:41 <ph88> when i put stack exec --profile -- myprogram   everything works fine. When i leave out the --profile flag the process gets killed and dmesg says out of memory ... what can i do about this ?
02:07:48 <kuribas> srk: RWST is still a monad :)
02:08:00 <srk> hah, ok :)
02:08:34 <kuribas> I see megaparsec uses a CPS style parser.  Is that for performance?
02:08:57 <kuribas> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/src/Text.Megaparsec.Internal.html#ParsecT
02:09:50 <merijn> kuribas: Probably?
02:10:11 <kuribas> to me it looks like that could have been a sum type.
02:12:19 <kuribas> or ExceptT err (StateT (State s e) (ReaderT Hints (WriterT Consumed))) a
02:14:29 <merijn> kuribas: Why would that be better?
02:14:39 <kuribas> merijn: less plumbing :)
02:14:50 <kuribas> no need to write monad instances etc
02:14:53 <maerwald> that looks horrible
02:15:23 <merijn> kuribas: Looks pretty hard to understand, though
02:15:39 <kuribas> or if you like: ExceptT err (RWST Hints Consumed (State s e)) a
02:15:45 <dminuoso> 09:54:43          Axman6 | or foo :: a ! mMyTypeFamily Double => Foo a -> Bar a?
02:15:47 <dminuoso> That pretty much
02:16:00 <dminuoso> Mmm
02:16:07 * hackage slip32 0.2.1 - SLIP-0032: Extended serialization format for BIP-32 wallets  https://hackage.haskell.org/package/slip32-0.2.1 (RenzoCarbonara)
02:16:26 <kuribas> merijn: why?  It threads the parser state, reads hints, possibly throws an error, and returns if it has consumed stuff.
02:16:36 <kuribas> merijn: I'd say that's as declarative as it can be
02:16:46 <kuribas> merijn: compared to the CPS version
02:18:23 <kuribas> but yeah, the RWST looks much clearer
02:20:29 <merijn> kuribas: Writer has terrible performance, though, both standalone and RWST
02:21:05 <kuribas> also for strict RWST?
02:21:29 <merijn> The correct version of Writer is State :p
02:29:35 <maerwald> yeah, from those 3 transformers, 2 of them are pointless
02:30:05 <kuribas> read isn't pointless
02:30:31 <kuribas> it's a different usecase than state
02:30:38 <maerwald> it's a function argument, except now slower
02:31:06 <kuribas> it's not slower when ghc can optimize it.
02:31:22 <maerwald> we know how well that works
02:31:35 <kuribas> I do.  It works quite well
02:31:46 <merijn> maerwald: That's not entirely true, Reader is useful in exploratory parts of programming so you can easily tweak the core without propagating that manually everywhere
02:32:45 <kuribas> sometimes you need to help ghc a bit with pragmas (INLINE, INLINABLE, SPECIALIZE)
02:33:03 <kuribas> but usually I am quite happy with how ghc removes abstractions
02:33:09 <maerwald> https://www.vidarholen.net/contents/blog/?p=859
02:33:43 <maerwald> ShellCheck switched to ReaderT and the entire application took a hit of 10%
02:34:04 <maerwald> monads are expensive
02:35:03 <kuribas> it depends
02:35:18 <boxscape> Well, the monad part isn't really what makes it slower, since ((->) e) is also a monad
02:36:24 <merijn> maerwald: This just in, the performance impact of changes is entirely dependent on what your bottleneck is
02:36:59 <maerwald> kuribas: relying heavily on inlining is also problematic since simple things like eta reduction can kill your entire performance. So refactoring is fragile
02:37:01 <merijn> "ReaderT is a 10% slowdown" is the wrong take, because if your application spends 90% of its time blocked for network/file IO it's entirely irrelevant
02:37:34 <kuribas> merijn: indeed.  And it could be something else, like not having specialized enough type signatures.
02:38:04 <kuribas> for example using MonadReader m => ...
02:38:07 * hackage ChasingBottoms 1.3.1.9 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1.9 (NilsAndersDanielsson)
02:38:13 <kuribas> that would be slower due to dictionary passing.
02:38:14 <maerwald> merijn: ShellCheck does not do network calls
02:38:18 <merijn> My code spends like 80% of its time waiting for the database, I'm really not going to worry about ReaderT
02:38:38 <kuribas> maerwald: I doubt anyone is going to notice that 10% increase in speed
02:38:40 <merijn> maerwald: That's my point, you can't generalise from ShellCheck to "all other programs" like you're trying to do
02:39:12 <kuribas> maerwald: if the trade of is nicer abstractions, less boilerplate, etc... I am more than willing to take a 10% hit.
02:39:14 <maerwald> kuribas: If this thing runs in your editor, which it does... then you will notice
02:39:31 <kuribas> I doubt it
02:39:45 <maerwald> For editor tools, performance matters
02:40:48 <ph88> is there an option for stack to see which commands are eventually passed to cabal and ghc ?   i like to know what the stack --profile flag does when running the command  stack exec
02:41:27 <maerwald> merijn: I am not. But the performance hit is generally not negligible... whether you care about it or not is ofc up to priorities
02:42:18 <kuribas> maerwald: if it matters, look at the core, add pragmas
02:42:29 <kuribas> or don't use ReaderT.
02:42:34 <kuribas> I wouldn't use it standalone
02:42:47 <kuribas> but when I have a stack, it makes sense
02:43:00 <maerwald> merijn: but the advantage over mere parameter passing are negligible imo, which is why i consider ReaderT useless
02:43:21 <kuribas> maerwald: the advantage is autogenerated instances
02:45:58 <maerwald> I just realised that I overused the bash language package, just to extrach variable assignments
02:46:17 <maerwald> the amount of allocations are crazy
02:47:55 <maerwald> parsing a 10 loc bash file is slower than a 100kb json file :(
02:57:08 <merijn> maerwald: That advantage over parameter passing is only "negligible" if your codebase has already (started to) crystallize and you're not refactoring a lot
02:58:00 <maerwald> I disagree. I refactor a lot and still prefer parameter passing
03:09:01 <tdammers> Reader(T) is nice when the majority of your codebase doesn't care about the majority of those parameters, but needs to pass them on anyway
03:26:46 <kuribas> tdammers: I like to have "high level" functions, which operate in the monad stack, and low level functions where I just pass everything.
03:26:55 <kuribas> and which return IO or just a pure value
03:28:50 <kuribas> in any case I prefer not to use readerT directly, but write my own helper functions for my application stack
03:30:10 <maerwald> tdammers: but it makes it harder to figure out whether you don't need it
03:31:16 <maerwald> with mtl maybe slightly better, but "unnecessary constraints" warnings are best effort only
03:33:52 <tdammers> maerwald: wanna know if you need it? remove it and try to compile.
03:34:21 <kuribas> maerwald: you'l rarely, possibly never see me having a function "a -> ReaderT m b", or "MonadReader m => a -> m b
03:34:24 <tdammers> also, I don't worry too much about that
03:34:49 <tdammers> there is usually a fairly obvious domain boundary where you transition between one monad stack and another, or a monad stack and just passing plain parameters around
03:36:56 <maerwald> These are all excellent points, but I think none of us have a strong opinion on this :p
03:37:13 <maerwald> lets talk about effects systems instead 
03:37:54 <kuribas> I do have a strong opinion about this.  It makes for better structuring of your program.
03:38:13 <kuribas> And improved readability if done right.
03:42:55 <tdammers> effects systems, hah
03:43:12 <kuribas> mtl style works well enough for me
03:43:19 <tdammers> another topic of which my opinion is disappointingly nuanced
03:44:23 <tdammers> but indeed, I'm fairly happy with the situation as it is - picking between "gung ho style everything in IO", using MTL-style MonadSomething typeclasses, and pinning things down with an opaque EDSL
03:45:05 <tdammers> "extensible effects" are a honking great idea, but I have yet to see a system that has good ergonomics AND good performance
03:46:35 <maerwald> tdammers: the fact that you apparently need both deep knowledge of the optimiser AND nontrivial GHC patches to achieve that is maybe not such great advertisements for Haskell performance imo
03:47:29 <maerwald> But then again, would it be easier in another language? Probably not
03:48:40 <kuribas> maerwald: compared to C++... no.  Compared to Python, haskell is miles ahead.
03:49:04 <kuribas> a performance junky C++ programmer is unlikely to choose haskell anyway.
03:49:34 <maerwald> Python is such a low bar. that's like saying our type system is better than JavaScript 
03:50:09 <kuribas> indeed, but the bar is already low, and haskell is above it.
03:50:24 <tdammers> maerwald: that's completely irrelevant, because I haven't seen a proper effect system in any mainstream language yet that gets anywhere near what people are trying to achieve in Haskell
03:50:40 <maerwald> Java?
03:50:47 <tdammers> Java has an effect system?
03:51:08 <tdammers> last time I checked, you can still conjure up a console object anywhere you like, and make it print stuff and all that
03:51:11 <maerwald> I don't know! But I believe it would be easier there
03:51:19 <maerwald> see Jif
03:51:20 <dminuoso> tdammers: well the explicit exceptions is sort of like effects.
03:51:34 <dminuoso> With a bit of squinting
03:51:44 <tdammers> yeah, but that's about as close to a proper effects system as promises are to monadic APIs
03:52:01 <maerwald> http://www.cs.cornell.edu/jif/
03:52:14 <maerwald> Java is amazing for such things 
03:52:38 <maerwald> IFC exists in Haskell too, but is much more convoluted
03:52:41 <dminuoso> tdammers: Im not so sure, you could use phantom exceptions that you never actually throw just to communicate effects.
03:52:55 <dminuoso> tdammers: With effect handlers installing phantom handlers (that will never be invoked) just to consume effects.
03:53:01 <dminuoso> You could definitely rig up an effect system with it
03:53:08 <dminuoso> So I think your comparison is not right.
03:53:23 <tdammers> it'd still be an honor system though
03:53:40 <tdammers> much like unsafePerformIO, except you don't have to go through some awkwardly named function to get it
03:53:59 <dminuoso> You're right, it'd be an honor systen
03:54:04 <tdammers> klopt
03:54:07 <tdammers> sorry wrong chat
04:07:05 <Nolrai> So I hear that Array is slow, but if I want a 2D rectangular array what should I use? Vector (Vector MyThings) is ragged.
04:09:16 <dminuoso> Nolrai: What do you mean by "ragged"?
04:09:42 <Nolrai> The rows can have different lengths.
04:09:50 <dminuoso> Use smart constructors.
04:09:56 <dminuoso> Hide everything behind an interface, so you cant misconstruct it.
04:10:14 <kuribas> Nolrai: use a sparse matrix?
04:10:37 <kuribas> or pad with zeros
04:10:59 <Nolrai> Kuribas: thats the opposite direction of my problem.
04:10:59 <dminuoso> compressed sparse row matrices are really a nice representation :)
04:11:19 <kuribas> or use a boxed vector of unboxed vectors
04:11:22 <Nolrai> They would be if what I was doing was going to have sparse data.
04:11:44 <kuribas> Nolrai: for speed, prefer unboxed over boxed
04:11:57 --- mode: ChanServ set +o Sigyn
04:11:58 <Nolrai> "or use a boxed vector of unboxed vectors" Hmm?
04:13:02 <Nolrai> I mean that in the Vector (Vector MyStuff) representation the rows can be ragged, but I want a rectangle.
04:14:14 <kuribas> Nolrai: an unboxed matrix and an unboxed vector with rowsizes then?
04:14:35 <kuribas> for example: https://hackage.haskell.org/package/matrices
04:15:08 <Nolrai> No I just want a Matrix!
04:15:12 <Nolrai> Thanks!
04:18:06 <merijn> There's also hmatrix and hblas
04:22:19 <fendor> Nolrai, there is also repa and massiv which both provide high level, high performance arrays
04:23:20 <kuribas> welcome to the mess than is numeric haskell!
04:23:59 <Nolrai> These are going to be fairly small, I'm just going to be accessing them like ~4^30 times, which honestly probably array would have been fine now I think about it.
04:29:08 <dminuoso> Nolrai: Depending on your constraints, you might want something that is not just unboxed but packed as well.
04:29:23 <dminuoso> To leverage locality of reference better.
04:32:24 <Nolrai> That makes sense.
04:45:54 <juri_> vectorspace?
05:05:33 <frdg> in an error such as `couldn't match type t0...` does t0 represent the first value of type t that was expected in the expression? 
05:06:37 * hackage haskoin-store-data 0.34.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.34.1 (jprupp)
05:07:06 <merijn> frdg: The naming is pretty much arbitrary
05:07:33 <merijn> frdg: There's some guessing/heuristics like "if this should possibly be 't', maybe we should pick that as a name", but that's it, heuristics
05:07:37 * hackage haskoin-store 0.34.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.34.1 (jprupp)
05:09:02 <frdg> ok that's good to know. I get confused often by this expecting the types to  be not arbitrary =D 
05:21:36 * hackage aws-lambda-haskell-runtime 3.0.1 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.1 (NickSeagull)
05:22:37 * hackage periodic-polynomials 0.1.0.0 - A library for working with periodic polynomials (very basic functionality)  https://hackage.haskell.org/package/periodic-polynomials-0.1.0.0 (OleksandrZhabenko)
05:36:48 <dminuoso> How much pain do I end up with when I use classy lenses?
05:43:09 <Eduard_Munteanu> dminuoso, those ain't bad.
05:49:37 * hackage linear 1.21.1 - Linear Algebra  https://hackage.haskell.org/package/linear-1.21.1 (ryanglscott)
06:49:36 * hackage resourcet 1.2.4.2 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.2.4.2 (MichaelSnoyman)
06:54:34 <srk> > forM [0..10] $ show
06:54:36 <lambdabot>  ["01234567891","01234567890"]
06:54:38 <srk> oO
06:56:36 <boxscape> % forM @((->) _) [0..10] $ show
06:56:37 <yahb> boxscape: ; <interactive>:13:16: error:; * Couldn't match expected type `_ -> a1' with actual type `[a0]'; * In the second argument of `forM', namely `[0 .. 10]'; In the expression: forM @((->) _) [0 .. 10]; In the expression: forM @((->) _) [0 .. 10] $ show; * Relevant bindings include it :: [_ -> Char] (bound at <interactive>:13:1)
06:56:46 <dolio> > forM [0..11] $ show
06:56:48 <lambdabot>  ["012345678911","012345678911","012345678901","012345678901"]
06:56:54 <srk> lol
06:58:29 <xerox_> > forM [12,34] $ show
06:58:31 <lambdabot>  ["13","14","23","24"]
06:59:00 <srk> hah, I see!
06:59:03 <xerox_> (:
07:00:41 <boxscape> > for [0..10] sshow
07:00:44 <lambdabot>  error:
07:00:44 <lambdabot>      • Variable not in scope: sshow :: Integer -> f b
07:00:44 <lambdabot>      • Perhaps you meant ‘show’ (imported from Prelude)
07:00:45 <boxscape> > for [0..10] show
07:00:47 <lambdabot>  ["01234567891","01234567890"]
07:00:54 <boxscape> why even use forM if for saves you a letter? :P
07:01:27 <dolio> There's no reason anymore.
07:01:45 <srk> :) I just forgot to write putStr before show and was wondering about the output :D
07:01:57 <xerox_> > [357,1,1,48] `for` show
07:02:00 <lambdabot>  ["3114","3118","5114","5118","7114","7118"]
07:02:09 <srk> neat
07:02:21 <boxscape> xerox_ unfortunately that reads the other way around from what I would expect, since you using a function for a list
07:02:44 <xerox_> it's a list for show!
07:03:00 <boxscape> I guess, but it's just different from imperative language for usage :/
07:03:28 <xerox_> > [357,1,1,48] `for_` show
07:03:30 <lambdabot>  [(),(),(),(),(),()]
07:03:31 <xerox_> censored version
07:04:41 <xerox_> > show `traverse` [357,1,1,48]
07:04:43 <lambdabot>  ["3114","3118","5114","5118","7114","7118"]
07:05:44 <boxscape> > show & for [0..10]
07:05:46 <lambdabot>  ["01234567891","01234567890"]
07:08:07 * hackage aeson-yaml 1.1.0.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.1.0.0 (patrick)
07:45:30 <slack1256> I got a Connection to a sqlite db, I cannot write to the Connection concurrently. How do I ensure a write order on it?
07:46:00 <merijn> slack1256: Transactions :p
07:46:13 <slack1256> Previously I had a async thread that allocated the Connection and what the only one allowed to write. It received requests via a TChan/stm.
07:46:26 <merijn> slack1256: You can just open multiple connections
07:46:31 <merijn> slack1256: 1 per thread or something
07:46:48 <merijn> (well, unless it's a memory-only db, I guess)
07:46:53 <slack1256> But that required the rest of the code to have the Async and TChan.
07:47:06 <slack1256> merijn: Oh, I can do that? nice!
07:47:32 <merijn> slack1256: Well, yes :p SQLite has locks and stuff to handle multiple parallel connections without you thinking about it
07:47:52 <merijn> slack1256: See also: https://www.sqlite.org/threadsafe.html
07:48:06 <slack1256> Nice
07:49:19 <merijn> slack1256: You can even use it safely from multiple programs, as long as the database isn't on an NFS network share :)
07:49:52 <merijn> (although doing that doesn't have great performance if you have multiple writers, but if you're doing mostly reading there's almost no cost)
07:50:04 <slack1256> And on a more general setting? If I had a file that I want to fseek into, and multiple threads that have access to that handle, I could use modifyMVar or the like to operate on such shared resource?
07:52:23 <dmwit> I... don't think so.
07:53:00 <dmwit> Dunno. There's not enough details in the question yet to answer meaningfully, so I think the best anyone can say is "that's not obviously safe".
07:54:10 <slack1256> Yeah, I am just patching software I haven't written yet.
07:54:10 <merijn> If the Handle is in a single MVar and you never leak it, then the MVar is a good way to do mutual exclusion, yeah
07:54:40 <merijn> Although ensuring writes are properly "on disk" before releasing the Handle is hard
07:57:55 <slack1256> I see, yeah that seems like a problem.
07:58:40 <slack1256> Thanks merijn dmwit, I will stop imagining problems on code I haven't written yet, and see if there are real problems when I implement a prototype.
08:04:07 * hackage pretty-simple 3.3.0.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.3.0.0 (cdepillabout)
08:13:07 * hackage apply-refact 0.8.1.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.8.1.0 (zliu41)
08:39:36 <ezzieyguywuf> What happens when this parse fails? How can I 'catch' it so that I can return a "Nothing" in "maybePoint"? https://gitlab.com/ezzieyguywuf/mycad/-/blob/useTransformers/HaskellCAD/src/CommandParser2.hs#L30
08:42:23 <slack1256> ezzieyguywuf: Which parser combinators libray are you using?
08:42:32 <slack1256> https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-ParserCombinators-ReadP.html this one?
08:43:17 <dminuoso> ezzieyguywuf: You'd use Alternative.
08:43:23 <solonarv> there's a combinator for this: optional :: Applicative f => f a -> f (Maybe a)
08:43:28 <slack1256> It seems you can use the Alternative/Functor instances to handle those cases.
08:43:29 <dminuoso> Or optional
08:43:33 <ezzieyguywuf> slack1256: I'm using ReadP
08:43:39 <ezzieyguywuf> slack1256: yes.
08:43:51 <solonarv> as far as I know, every parser library's Parser type has an Alternative instance
08:43:56 <c_wraith> YOu wouldn't use optional with ReadP
08:44:12 <c_wraith> I don't know why, but its type is not helpful
08:44:17 <ezzieyguywuf> what is Alternative? that <|> thing?
08:44:21 <c_wraith> optional :: ReadP a -> ReadP ()
08:44:26 <slack1256> ezzieyguywuf: Yeah
08:44:38 <ezzieyguywuf> hrm, I'll have to mull this over
08:44:38 <solonarv> Alternative is a typeclass, its methods are 'empty' and '<|>'
08:44:41 <ezzieyguywuf> thanks for the help.
08:44:43 <dminuoso> ezzieyguywuf: Alternative is one of the common things in parsers, where you can provide an "alternate parser to try'
08:44:58 <dminuoso> optional v = Just <$> v <|> pure Nothing
08:45:17 <dminuoso> So "try left parser, if successful wrap with Just, otherwise run the "pure effectful parser that returns Nothing"
08:45:46 <ezzieyguywuf> your syntax is confusing me
08:45:50 <ezzieyguywuf> `optional v =`?
08:45:52 <c_wraith> I think the way you'd want to do things in ReadP is actually (Just <$> v) <+++ pure Nothing
08:45:58 <dminuoso> ezzieyguywuf: That's haskell code.
08:45:59 <c_wraith> ReadP is weird
08:46:03 <solonarv> that's the definition of 'optional'
08:46:03 <slack1256> (Just <$> parsePoint) <|> pure Nothing
08:46:04 <dminuoso> ezzieyguywuf: Its the actual definition of `optional`
08:46:09 <ezzieyguywuf> ah
08:46:13 <c_wraith> it's not like parsec variants, so don't treat it like it is
08:46:15 <solonarv> to be precise: the 'optional' that's exported from Control.Applicative
08:46:37 <solonarv> hm, ReadP being weird might throw a wrench in things
08:46:38 <c_wraith> err, <++
08:46:42 <dminuoso> ezzieyguywuf: It should be said, that if you use `optional` from control.applicative you *might* have to sprinkle an additional `try` or equivalent
08:46:50 <c_wraith> I'm telling you, use <++ instead of <|>
08:46:54 <dminuoso> It depends on whether your parser combinators are by default back tracking..
08:46:59 <dminuoso> c_wraith: Mmm, why?
08:47:01 <c_wraith> dminuoso: there's no try.  what are you talking about
08:47:05 <dminuoso> oh, ReadP
08:47:14 <dminuoso> c_wraith: I was talking in general
08:47:27 <ezzieyguywuf> yea ReadP
08:47:30 <ezzieyguywuf> I thought I'd start 'simple'
08:47:33 <ezzieyguywuf> :\
08:47:37 <dminuoso> ReadP is really weird :<
08:47:38 <ezzieyguywuf> plus I got overwhelmed with megaparsec
08:47:42 <ezzieyguywuf> hah
08:47:57 <dminuoso> ezzieyguywuf: What overwhelmed you with megaparsec?
08:48:11 <dminuoso> I dont really use it, but the few times it seemed simple and intuitive.
08:49:14 <maerwald> I don't find it simple, I'm using it right now
08:49:17 <ezzieyguywuf> the introduction tutorial is supppper long
08:49:20 <ezzieyguywuf> and very thorough
08:49:23 <maerwald> attoparsec is simple
08:49:23 <ezzieyguywuf> but overwhelming
08:49:37 <ezzieyguywuf> perhaps I should look at that...
08:49:48 <ezzieyguywuf> but also I liked the idea of not adding an additional dependency to my project
08:49:53 <ezzieyguywuf> I'm kind of a freak about that
08:49:54 <slack1256> I always feel block when I have to ship code but the tutorial is long, I know your pain ezzieyguywuf
08:50:14 <dminuoso> ezzieyguywuf: I think the vast majority of things that are in there, applies to ReadP just as well.
08:50:33 <dminuoso> Well okay not the vast majority, but the important bits to get started.
08:51:21 <ezzieyguywuf> yea, that's why I'm trying to move to ReadP, this blog was very helpful and made it seem like I could do what I wanted to with ReadP https://two-wrongs.com/parser-combinators-parsing-for-haskell-beginners.html
08:52:09 <c_wraith> anyway. ReadP has an interesting design. it only does a single pass of the input, but the parser constructs are usually non-deterministic
08:52:45 <c_wraith> the only deterministic branch construct is <++ which favors its left arg
08:53:15 <c_wraith> +++ and <|> both parse both arguments in parallel.
08:53:18 <ezzieyguywuf> I used "munch1" instead of "many1" to get one result instead of all results
08:53:33 <dolio> Arbitrarily avoiding 'dependencies' is not an attitude that makes any sense in Haskell.
08:54:04 <maerwald> Avoiding dependencies is a common thing 
08:54:11 <c_wraith> if you want to try one thing and fall back to another if the first doesn't work, deterministically, you want <++
08:54:21 <maerwald> Especially bc of compile times
08:54:41 <ezzieyguywuf> c_wraith: k. I'll have to play aroud with <++
08:54:56 <dolio> There's stuff that ships with GHC that is around for historical purposes, while more recent, better designs are shipped separately.
08:55:10 <maerwald> there are numerous blogs from haskell industry users describing how they made their dependency footprint smaller
08:56:34 <c_wraith> first compile times are helped more by avoiding vector-algorithms than lens, though. dependencies aren't the only cause if slow compilation
08:57:44 <maerwald> a common cause
09:00:07 * hackage gitlab-haskell 0.2 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.2 (RobStewart)
09:22:19 <ezzieyguywuf> c_wraith: I think optional from Data.Applicative is what I want. <++ which you pointed out is if I want to run a different parser if the first parser fails. That's not what I want - I want to return Nothing if the parse fails
09:23:01 <c_wraith> pure Nothing is a parser that returns Nothing
09:23:12 <c_wraith> Control
09:23:54 <ezzieyguywuf> hrm, I see
09:23:56 <ezzieyguywuf> and yea, control
09:24:00 <ezzieyguywuf> ok, I"ll try your way :)
09:25:05 <c_wraith> ReadP produces multiple parse results. if you use the version from Control.Applicative and the first parser matches, you'll get matches for that *and* Nothing
09:25:33 <c_wraith> if you use <++ you'll only ever get one of those results
09:33:38 <merijn> ReadP is super confusing
09:33:44 <merijn> I'd recommend not using it
09:35:17 <ezzieyguywuf> what would you use instead?
09:36:49 <merijn> megaparsec or attoparsec
09:38:09 <merijn> ezzieyguywuf: Ah, I just now saw your note about liking the lack of extra dependency. The problem is that ReadP is notoriously finnicky even for people very familiar with parser combinators and the performance is kinda bad too
09:38:16 <ezzieyguywuf> I mean, even just the imports for megaparsec confuse me - Text.MegaParsec, Text.MegaParsec.Char, I think I need to import something hiding something else...
09:38:44 <merijn> ezzieyguywuf: Megaparsec has a pretty in depth intro (that was originally meant for a book, but now free) though
09:39:05 <merijn> ezzieyguywuf: https://markkarpov.com/tutorial/megaparsec.html
09:39:11 <ezzieyguywuf> merijn: yea, thi intro overwhelmed me :-P
09:39:20 <merijn> ah :)
09:39:21 <ezzieyguywuf> that's why I went to ReadP
09:39:34 <merijn> There's also the Real World Haskell parsec chapter
09:39:38 <ezzieyguywuf> b/c this blog made a lot of sense and seemed simpler https://two-wrongs.com/parser-combinators-parsing-for-haskell-beginners.html
09:39:50 <merijn> Most of the high level explanation generalises to all the parser combinator libraries
09:39:55 <ezzieyguywuf> parsec is akin to megaparsec, right?
09:40:14 <ezzieyguywuf> yea, so maybe take what I learned about ReadP and just apply it to megaparsec?
09:40:17 <merijn> ezzieyguywuf: megaparsec started as a fork of parsec and then evolved further
09:40:41 <merijn> ezzieyguywuf: parsec is a bit dated by now (operators conflict with Control.Applicative, etc.)
09:41:00 <merijn> ezzieyguywuf: attoparsec is somewhat simpler in terms of API than megaparsec, so that might be good too
09:41:06 <merijn> It has worse errors, though
09:41:50 <ezzieyguywuf> yea, the megaparsec errors are pretty sweet
09:41:50 <sm[m]> megaparsec is fantastic
09:41:53 <merijn> ezzieyguywuf: See also: https://github.com/tssm/up-to-date-real-world-haskell/blob/master/14-using-parsec.org
09:42:21 <merijn> ezzieyguywuf: The parser writing is mostly the same between attoparsec/megaparsec so, going from attoparsec to megaparsec later should be easy enough
09:42:37 <merijn> dinner time
09:43:48 <dminuoso> https://gist.github.com/dminuoso/f0a8cdc1da58fe38bc660a9dd1d1cffa
09:43:57 <dminuoso> Is this a faulty diagnostic? All I did was accidentally use a data constructor
09:44:32 <ezzieyguywuf> merijn: enjoi!
09:44:46 <dminuoso> The diagnostic is super weird.
09:44:59 <dminuoso> Or is this just an artifact of DataKinds?
09:47:43 <sm[m]> ph88, to see commands being run, you can use stack -v (and grep for 'Run process'); or stack build --cabal-verbose
09:49:44 <sm[m]> stack exec --profile runs a different executable from stack exec, IIRC (the one you built with --profile, which has different memory usage patterns)
09:53:53 <dminuoso> Is there a way to combine two traversals into a single traversal, that is a sequence of both?
09:55:19 <dminuoso> Ah mmm, that'd be a fold rather I think.
09:55:36 <dminuoso> https://hackage.haskell.org/package/optics-core-0.3/docs/Optics-Fold.html#v:summing
09:55:38 <dminuoso> This looks good.
10:00:43 <maerwald> hmm, I'm starting to wonder why haddock does not show the number of arguments a function has defined, so you know when it would inline
10:01:15 <maerwald> that could be just a seemingly invisible int
10:06:22 <mananamenos> It takes about 3 seconds to open haskell file with haskell-mode in emacs. Is this normal?
10:07:46 <slack1256> mananamenos: For me on spacemacs yes, but I blame yasnippet for it.
10:08:15 <slack1256> I don't know much about haskell-mode nor emacs really.
10:08:40 <slack1256> That's only the first time it seems.
10:09:53 <mananamenos> for me it happens on everything .hs i open :/
10:11:20 <dminuoso> haskell mode is blazing fast
10:11:25 <dminuoso> spacemacs is just weird.
10:11:38 <dminuoso> I learned my lesson a while ago that spacemacs is a bad idea. :)
10:13:04 <dsal> I've never tried spacemacs.  Regular emacs is usually fine.
10:13:30 <dminuoso> Indeed, it takes very little effort to add the few emacs packages you use or make it pretty. 
10:13:34 <mananamenos> well i've deleted haskell-mode from elpa, and then i .hs files open immediatelly, which makes me assume that is must be some config in haskell-mode
10:14:52 <ezzieyguywuf> yikes. emacs.
10:15:06 <davve> king of editors
10:15:30 <ezzieyguywuf> right, vim.
10:15:32 <ezzieyguywuf> lol
10:15:50 <davve> vim is nice too, but emacs can do all that vim can and more
10:16:01 <ezzieyguywuf> *shrug* vim does enough text editing for me.
10:16:02 <mananamenos> I have nothing weird in my haskell-mode config https://ghostbin.co/paste/xmg2e This is really strange. 
10:16:04 <ezzieyguywuf> but to each their own.
10:16:36 <ja> noooo, with enough discussion, i am confident that we can all agree on a text editor to use
10:16:59 <dminuoso> Why should be one?
10:17:02 <dminuoso> Why not emacs with evil mode?
10:17:07 <dminuoso> Best of both worlds.
10:17:10 <dolio> Wrong.
10:17:11 <davve>  
10:17:12 <sm[m]> mananamenos: maybe there's something in the issue tracker, like https://github.com/haskell/haskell-mode/issues/1674
10:17:13 <davve> ^
10:17:28 <dminuoso> dolio: You're provably double wrong.
10:17:45 <dminuoso> There's an emacs command to produce said proof.
10:17:45 <dolio> I've used evil. It has a bunch of annoying differences from vim.
10:18:33 <ja> what i do not understand, is that if you use vim, why not use neovim? that is a compelling advantage of the vim ecosystem, that you can use common programming languages
10:18:40 <davve> dolio: did you spend time configuring it?
10:18:57 <davve> because out of the box I would agree it's not 1:1
10:19:01 <dolio> I don't want to spend a bunch of time configuring it, I already have vim.
10:19:23 <davve> you use standard vim?
10:19:53 <dolio> I use neovim, but they're not incredibly different yet.
10:20:13 <dolio> This seems like a pointless discussion, too.
10:20:28 <davve> indeed
10:20:36 <davve> like discussing politics :P
10:22:34 <maerwald> ja: because it does not have a GUI that is as stable as vim
10:23:03 <maerwald> and lacks fundamental features there
10:23:55 <ja> ah, i never use the gui's
10:24:05 <maerwald> ...
10:24:06 <ja> i did see that there is a haskell plugin host, but i didn't try it https://github.com/neovimhaskell/nvim-hs
10:24:45 <ja> maerwald: what is the most important feature i am missing out on by not using a gui?
10:25:10 <dolio> I've been using a neovim gui for months and I don't think it's ever crashed because of the gui part.
10:25:39 <maerwald> ja: features? Probably none.
10:26:01 <maerwald> except maybe scroll bar
10:26:02 <ja> aah, gotcha, it is some crusade against the vt100 ;)
10:26:20 <maerwald> gvim has scroll bar, neovim guis not
10:27:10 <maerwald> (not yet, because certain viewport events were not exposed and smooth scrolling is much harder in neovim)
10:27:48 <maerwald> ja: well, terminal is trash. Just look at the escape code mess
10:28:41 <maerwald> not that gvim solves much of that, except I have less keybind clashes
10:34:12 <maerwald> ja: oh and balloons don't suck in gui and can be properly implemented
10:35:55 <ja> aaah, so like, if i hover above a symbol, the popup can exceed the window frame? yeah, i could imagine that being useful once i start using ghcide
10:36:26 <maerwald> not just that, but visually distinguishable at all...
10:36:42 <maerwald> a proper popup
10:37:09 <maerwald> in neovim that looks awful and the text is usuall way too big
10:37:38 <maerwald> so completion menus tend to be non-ergonomic
10:38:08 <ja> very useful information, thanks!
10:39:04 <maerwald> also, in gvim I frequently use the serch and replace dialogue so I don't have to bother with sed and escaping stuff
10:42:37 <monochrom> (completely irrelevant tangent >:) )  Terminal can be made equivalent to GUI if, say, you make the terminal 1920x1080, and each character cell displays a solid rectangle of one of the 2^24 colours. >:)
10:42:42 * monochrom is a reductionist!
10:43:47 <ja> or you can just use sixel, which is about to get merged into libvte, so that it will be in all gnome-terminals in a few years
10:44:34 <monochrom> haha nice
10:44:36 <ezzieyguywuf> blah, nvim cli ftw
10:44:54 <maerwald> monochrom: not entirely... a terminal cannot create real popup windows
10:46:29 <maerwald> also, have you seen the attempts of code minimap in terminal? It's a joke
10:46:42 <monochrom> I haven't.
10:47:10 <monochrom> But I think you misunderstood my joke.
10:49:09 <maerwald> Terminal feels more haxx0r though, so we'll be stuck with this crap for 30 more years
10:50:09 <maerwald> The problem is rater that ppl doing GUI assume I'm a mouse user, just because I want a GUI
10:50:23 <ja> given the choice between the 70'es and some Electron app... ;)
10:50:49 <monochrom> I can't use Haskell on 70's hardware. That settles it.
10:51:37 <monochrom> Well, I could, but it would be a us$50000 mainframe. And it's us$50000 in 70's money, not today's money.
10:51:57 <monochrom> No, wait a second, I forgot hugs. :)
10:52:24 <monochrom> OK, then it's "merely" a us$5000 PDP-11.
10:52:45 <maerwald> For example ...I haven't found a single terminal file manager that has as good keyboard navigation as a simple gtk file manager. Instead now I need multiple key presses to get into filter/search mode
10:52:50 <monochrom> Actually I made up those prizes. I may be off by a factor of 10.
10:53:23 <EvanR> terminal on one hand is the epitome of "why reinvent the wheel, target terminal interface". web tech is the epitome of reinvent the wheel for its own sake
10:53:41 <EvanR> be compatible with what already exists
10:54:21 <hc> lol, anyone remember those old mostly DOS applications that tried to be more graphical by altering some of the font characters? :)
10:54:24 <monochrom> Yes, people "adapt" to the status quo.
10:54:30 <hc> FreeBSD still does this today to emulate a real mouse cursor in text mode
10:55:18 <monochrom> aptitude still does
10:55:42 <maerwald> FreeBSD is the epitome of "I have too much time to ponder with all these wonderful half working tools"
10:55:48 <monochrom> but emulating mouse cursor is krad
10:56:12 <maerwald> and in the end you get this crazy feeling of power
10:56:20 <EvanR> hopefully in 2060 web browser is like terminal now, this thing that still works and can't go away, but is a woefully out of date idea. For justice
10:56:47 <monochrom> I don't mean aptitude alters the font. It luckily is post-unicode, so it just has to use unicode box-corner characters.
10:57:02 <hc> terminals aren't really out of date, neither is a turing machine ;p
10:57:15 <monochrom> But yes it was impressive that Norton Utilities did it.
10:57:27 <maerwald> I'm expecting to do my haskell coding in 3d in eve online one day. 
10:57:40 <hc> maerwald: actually, freebsd is a wonderful host for VMs, using bhyve as the hypervisor and zfs as the FS
10:57:49 <maerwald> while blasting some noobs out of the solar system
10:58:20 <maerwald> hc: the linker is also wonderful
10:58:20 <ja> maerwald: the first step would IMHO be to evolve from text into AST manipulation like in https://github.com/lamdu/lamdu#tutorial
10:58:41 <maerwald> ever tried static linking on freebsd? 
10:58:50 <hc> nope, can't say that i ever did  :)
10:59:04 <hc> I never did much development on freebsd, except for a kernel module for a university project ;)
10:59:11 <maerwald> that's why you're still a free man
10:59:22 <hc> this was when linux was still 2.4 with 2.6 just coming round the corner; freebsd felt way more elegant back then :)
10:59:32 <EvanR> yeah moving AST around in 3D with wave of your hand... sounds exhausting
10:59:42 <hc> in 2.4 kernel, every hard drive driver had to be able to parse partitiopn tables, for example ;)
11:00:06 <maerwald> moving those free monads around
11:00:24 <hc> maerwald: I never statically linked anything on nixos either, btw  -- no need ;)
11:00:58 <maerwald> hc: you're lucky you don't need to ship your binaries then
11:01:42 <hc> maerwald: I used haskell for one productive project so far -- it's hosted on the company's own infrastructure, though. Typical REST API stuff
11:02:20 <maerwald> most companies do docker, some do nix, I find both nonsense and vote for static binaries
11:02:30 <hc> ah wait. we did ship that to one partner. it was absolutely painless because persistent does auto schema merges of the db :)
11:03:11 <hc> maerwald: actually, I do more rust stuff these days and here we do the same -- link statically.
11:03:45 <maerwald> yeah and that works only painless on alpine 
11:03:52 <hc> no freebsd involved here, except to host the gnu/linux vms
11:04:58 <hc> why do you need alpine to staticall link stuff?
11:05:23 <maerwald> because gentoo docker images suck
11:05:43 <hc> lol
11:05:54 <monochrom> I think maerwald was commenting on painless, not on necessity.
11:05:54 <maerwald> you need musl 
11:06:01 <hc> never used gentoo in my life. never understood the joy of having to compile everything myself
11:06:32 <monochrom> But isn't it generally true of life? A thing to do is painful iff it's necessary. :)
11:06:34 <maerwald> hc: similar to freebsd: OCD or too much time... I had both
11:06:56 <sm[m]> hmm. Can't stack install happy, because I have no happy. 
11:07:37 <hc> maerwald: I used redhat and slackware before freebsd. I never understood how linux/unix worked while working with these systems. Freebsd taught me many things I can now apply in the gnu/linux world.
11:07:44 <monochrom> stack should be able to install happy. But I don't know stack.
11:07:45 <hc> So I wouldn't call it "too much time" ;)
11:08:17 <monochrom> unless the important factor is that happy is an exe
11:08:44 <sm[m]> stack installs ghc.. but apparently not happy and alex. TIL
11:09:08 <monochrom> recall that build dependencies can only list libs, not exes ("build tools")
11:09:25 <maerwald> sm[m]: happy and alex are not in the ghc bindist at least
11:09:46 <monochrom> I think that a "cabal install happy" won't hurt, even though you use stack.
11:09:50 <maerwald> so they are definitely external
11:10:17 <monochrom> s/install/v2-install/ if you want to be sure
11:10:59 <monochrom> But I would want to believe that stack could do the same.
11:14:35 <ezzieyguywuf> so megaparsec doesn't have parsec's optionMaybe? was it replaced with something else?
11:14:52 <sm[m]> good idea monochrom . Indeed that works. And stack install happy does work too if I move out of this project directory.
11:14:59 <monochrom> it should have something like optionMaybe
11:15:18 <ezzieyguywuf> it has parseMaybe
11:15:33 <ezzieyguywuf> yea  I think that's the same
11:15:42 <ezzieyguywuf> mehhh not quite
11:16:17 <sm[m]> hm and now it works from within the project directory. Some old build artifacts making trouble ? I see Cabal-1.24.2.0 in the output.. dunno
11:17:55 <monochrom> hrm, that's strange indeed
11:19:29 <monochrom> The really strange thing is you look at https://hackage.haskell.org/package/megaparsec-8.0.0/docs/doc-index-O.html and you see "option" and "optional" listed but unavailable.
11:21:27 <ezzieyguywuf> hrm, something funky is amiss
11:22:07 * hackage periodic-polynomials 0.1.1.0 - A library for working with periodic polynomials (very basic functionality)  https://hackage.haskell.org/package/periodic-polynomials-0.1.1.0 (OleksandrZhabenko)
11:24:13 <devalot> Is there a class for Functors that supports `f a -> a`?  I'm familiar with Comonads but that seems like overkill for what I want.
11:24:39 <ezzieyguywuf> well, this does what I wanted and seems readable: https://gitlab.com/ezzieyguywuf/mycad/-/blob/useTransformers/HaskellCAD/src/CommandParser2.hs#L33
11:26:09 <monochrom> fmap (Just . read) (some digitChar)  :)
11:26:37 <monochrom> But not a big deal.
11:27:03 <monochrom> There are people who prefer to see "some digitChar" on the left, "Just . read" on the right.
11:28:07 <ezzieyguywuf> I tried with fmap but couldn't wrap my brain around it :)
11:29:05 <MarcelineVQ> devalot: could use Foldable if a is a Monoid. kind of depends what you want to happen if  f a  doesn't provide a way to produce an  a
11:29:30 <ezzieyguywuf> I think it's because I was trying to also fmap the pure, which I now understand was wrong
11:29:40 <amf> anyone know if there is a package for representing icmp types? cant find anything on hackage
11:29:47 <MarcelineVQ> > fold (Just "foo")
11:29:49 <lambdabot>  "foo"
11:30:09 <devalot> MarcelineVQ: In this case I'm only working with types that always have a single `a'.
11:30:21 <monochrom> You just have to memorize this law and keep looking for its opportunities, until it becomes second nature: p >>= return . f = fmap f p
11:30:38 <devalot> Perhaps Foldable is what I want.
11:33:18 <MarcelineVQ> devalot: idk if it's applicable to what you're doing but https://hackage.haskell.org/package/newtype-0.2.2.0/docs/Control-Newtype.html has some neat stuff that's good to know about regardless
11:35:19 <ezzieyguywuf> monochrom: that's the one I was tryig to remember/rederive
11:37:14 <monochrom> I have those monad laws written down in a study notes file.
11:37:52 <monochrom> (After the nth time I forgot tiny details like this.)
11:37:56 <devalot> MarcelineVQ: Thank you.  Newtype is interesting.  I'll have to think about whether or not I can implement `pack' for my types.
11:39:15 <monochrom> Sometimes the magic is that after you have written it down seriously in your notebook, you will remember it for good and never need the notebook. :)
11:40:37 * hackage birch-beer 0.3.1.1 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.3.1.1 (GregorySchwartz)
11:42:06 <MarcelineVQ> Also if you're just wanting an extractor for something that's always there, you can be using record syntax to name the field and get a function that does that
11:42:33 <devalot> MarcelineVQ: That's also true.  Thank you.
11:47:26 <monochrom> Someone in a math channel needed help solving "4x - 5 = 3". They decided to ask "How do you solve equations?"
11:47:36 <monochrom> Please don't do it again.
11:48:27 <monochrom> I think there were also cases of "What is the general method for solving equations?"
11:49:28 <ja> a general question warrents a general answer, it's fine
11:49:58 <ja> language can never be 100% concrete
11:50:09 <monochrom> (I correctly answered "the halting problem implies it can't be done")
11:51:36 <monochrom> 90% concrete is good enough.
11:52:04 <monochrom> Hiding "4x - 5 = 3" and exposing only "How do you solve equations?" is 1% concrete.
11:52:46 <maerwald> if it's a philosophical questions then I'd bite
11:54:25 <maerwald> The Angst of solving equations
11:54:32 <monochrom> :)
11:55:06 <dmwit> Go on, you're going to tell me there are other equations than 4x - 5 = 3?
11:55:10 <dmwit> Doesn't sound right.
11:55:37 <ja> maybe the person is asking from a linear universe
11:56:07 <dmwit> I suspect both: 1. the person is asking from a linear universe and 2. the person doesn't realize that the universe extends beyond linear.
11:56:32 <dmwit> Riffing on observation (2) is what led to my previous joke about not realizing the universe extended beyond one exact equation. =P
11:58:35 <ja> unlike the XY problem which i believe monochrom has mentioned before, it is actually the opposite, the person tried to generalize the question and is now punished for generalizing to an excessive degree
12:00:59 <maerwald> those are all excellent points, but...
12:01:15 <ja> or i guess it isn't really the opposite of XY, it is merely XY where X and Y are more meta
12:03:20 <MarcelineVQ> that's great and all but what's a derivative
12:03:33 <monochrom> haha
12:03:39 <ezzieyguywuf> monochrom: I do that all the time, i.e. write something down and then never refer to the note b/c now it's in my brain forever
12:04:11 <maerwald> ja: you said meeeta? https://www.youtube.com/watch?v=lYUpjhmoyY8
12:04:12 <ezzieyguywuf> monochrom: what's the math channel? #math?
12:04:38 <monochrom> It was efnet #math a long long time ago, I think 2 decades.
12:05:00 <ezzieyguywuf> so you're just remembering something from 20 years ago?
12:05:03 <ezzieyguywuf> I thought you were in there now
12:05:16 <ezzieyguywuf> MarcelineVQ: A derivative is something that is not as good as the original.
12:05:19 <ezzieyguywuf> 😂
12:05:49 <ezzieyguywuf> srsly though, it's just velocity
12:05:52 <ezzieyguywuf> ....or distance.
12:06:01 <ja> maerwald: oh, it sounds great in german!
12:06:03 <monochrom> It was a remarkable, unforgettable example of a recurring trend.
12:06:35 <ja> oh, like a meme ;)
12:08:06 <ezzieyguywuf> x=2
12:08:08 <ezzieyguywuf> no wait
12:08:10 <ezzieyguywuf> x=42
12:08:15 * ezzieyguywuf wipes brow
12:08:37 <ezzieyguywuf> is this in base 10?
12:08:41 <monochrom> yes
12:08:49 <ezzieyguywuf> lol, I'm just messing around
12:08:54 <ja> ezzieyguywuf: sounds like you're not a platonist ;)
12:09:24 <monochrom> If you like to mess around, we can mess around with "base 10" >:)
12:09:31 <ezzieyguywuf> hah, I'm sure
12:09:46 <ja> would be interesting to know whether there is correlation between platonists and haskellers
12:09:50 <ezzieyguywuf> as long as we all agree that 42 *is* the answer, I think everything else can be derived from that.
12:09:53 <monochrom> "is this in base 10?" the correct answer is always yes. Do you see why?
12:09:55 <dmwit> Every base is base 10.
12:10:03 <dmwit> Oh, beat to the punchline. ^_^
12:10:17 <koz_> dmwit: All your base. :P
12:10:24 <ezzieyguywuf> hrm, unless it's a play on what "this" means, I don't really see
12:10:24 <dmwit> This is why we should adopt "phase" instead of "base", and say the largest single-digit number.
12:10:26 <ezzieyguywuf> koz_: lol.
12:10:34 <dmwit> "Is this phase 9? Or phase f?"
12:10:41 <koz_> ezzieyguywuf: That's about the pinnacle of humour you can expect from me at 7am.
12:10:51 <ezzieyguywuf> 😂
12:11:07 <monochrom> OK, suppose I use base two. How do I say "I use base two" but using base-two numerals?  "base 10".
12:11:13 <dmwit> 6x9 = 42 in phase c
12:11:24 <ezzieyguywuf> monochrom: oh snap!
12:11:31 <ezzieyguywuf> now do it with base 3
12:11:40 <ezzieyguywuf> oh snap!
12:11:51 <ezzieyguywuf> now do it with base 4!!!
12:12:04 <monochrom> there was a comic strip on this
12:12:11 <ezzieyguywuf> surely the joke fails after base 10 though...
12:12:24 <dmwit> How sure are you?
12:12:28 <ezzieyguywuf> not at all
12:12:37 <monochrom> https://web.archive.org/web/20200104173415/http://cowbirdsinlove.com/43
12:12:40 <ja> isn't there a base 0? where are bases formally defined?
12:12:40 <dmwit> That is good. It means you can still come to the truth. ^_^
12:12:43 <ezzieyguywuf> I'm still struggling with parsec, so, you know, I'm like level 1
12:12:58 <ezzieyguywuf> dmwit: lol.
12:13:21 <dmwit> Oh my. It uses my and koz_'s *exact* phrasing.
12:13:53 <koz_> dmwit: Great minds think alike? :P
12:14:06 <dmwit> Sort of damning that the comic was published more than a decade before me; if anybody copied, we know who the courts are going to side with.
12:14:33 <dmwit> But the comic doesn't propose a solution and I do, so maybe I win on that point. ^_^
12:16:05 <ezzieyguywuf> the real question is: how does the alien pronounce "10"
12:17:11 <monochrom> The joke works best in text, not in speech.
12:18:06 <ja> how can the joke work better in text than speech if it has no puns on phonetics?
12:18:07 <ezzieyguywuf> indeed
12:18:20 <ezzieyguywuf> then again, math is supposed to be universal
12:19:01 <ja> surely the only information added in speech is phonetics, so if a phrase has no dependency on phonetics, it should work in text
12:19:27 <monochrom> The pun is on the string "10" so it is better in text. No one really says "one zero" in speech.
12:19:31 <dmwit> The true joke is that the astronaut mistranslated "molecule" as "rock" and the alien actually uses base 25 mol
12:20:07 <monochrom> haha you win
12:20:33 <ezzieyguywuf> lol
12:23:00 <monochrom> Good programming exercise: Roman numerals.
12:23:33 <MarcelineVQ> that's only one step away from unicode
12:23:43 <ja> what does the exercise teach? that encodings can be bad?
12:23:49 <ezzieyguywuf> utf8 or utf16
12:24:11 <ezzieyguywuf> I guess both are utf10 based on the conventions we've established in this channel.
12:24:20 <monochrom> learning conditionals and a bit of string processing
12:24:35 <ezzieyguywuf> I'm not a good programmer.
12:24:36 <ezzieyguywuf> lol.
12:24:45 <monochrom> It's like fizzbuzz but more cases.
12:24:54 <ja> oh, like AI then
12:30:14 <MarcelineVQ> AI is easy, just repeat every 3rd action, and then consider every action to be every third action after some particular point. By the time you're doing that the academics that invented you wrote the paper anyway so they're not paying attention. if you need evidence of this ploy just play with gpt-2 a bit
12:32:07 * hackage primitive 0.7.1.0 - Primitive memory-related operations  https://hackage.haskell.org/package/primitive-0.7.1.0 (andrewthad)
12:32:28 <monochrom> Err what, what is this AI?
12:32:33 <monochrom> err
12:32:37 <monochrom> Err wait, what is this AI?
12:32:52 <nil> meta-err
12:33:12 <ezzieyguywuf> monochrom's humour is just too much for me.
12:33:14 <MarcelineVQ> things like  talk to transformer  and  ai dungeon
12:33:37 <ezzieyguywuf> lol for some reason this made me think of https://xkcd.com/327/
12:36:39 <ja> what roman numerals really optimize for, is arithmetic by adding vectors (lines). like you can turn 5 into 4 by drawing a line. never thought about it like that, i wonder what alternatives exist
12:38:35 <monochrom> Yeah it turns some additions and some subtractions into concatenations.
12:39:05 <monochrom> An alternative would be to turn multiplications into concatenations. I don't know how to do it though.
12:40:40 <ezzieyguywuf> did y'all know that there's alternatives to tally marks?
12:40:48 <ezzieyguywuf> I like the little squares better myself
12:41:12 <monochrom> In general you could look for a funny monoid homorphism between (numbers, operation of your choice) and (string, concatenation)
12:41:40 <monochrom> Please tell me more about the little squares.
12:42:02 <MarcelineVQ> that just means you didn't install the right font
12:42:11 <ezzieyguywuf> https://en.wikipedia.org/wiki/Tally_marks#Clustering
12:42:41 <monochrom> haha MarcelineVQ
12:42:41 <ezzieyguywuf> I also think the chinese version is poetic in a way as (at least in japanese, I'm sure chinese too) that character means "5"
12:42:47 <ezzieyguywuf> nope I'm wrong
12:43:03 <MarcelineVQ> dot+line is pretty neat
12:43:12 <ezzieyguywuf> it means "correct"
12:43:13 <ezzieyguywuf> still poetic
12:43:24 <ezzieyguywuf> yea dot-line is very concise and useful
12:43:35 <ezzieyguywuf> but I use the square with a line through it all the time
12:43:53 <ja> MarcelineVQ: you're not even wrong, when i visit ezzie's link i see boxes for codepoints 1d372 thorough 1d378
12:44:05 <MarcelineVQ> "However, the box tally and dot-and-dash tally characters were not accepted for encoding" ok...
12:44:08 <ezzieyguywuf> ja: lol.
12:44:22 <ezzieyguywuf> ja: you need to update your fonts
12:44:41 <MarcelineVQ> Better not include the one useful tally form on the page, we need more emoji's instead
12:44:44 <MarcelineVQ> And flags
12:45:49 <monochrom> Chinese five, 五, also has 5 line segments. (It's probably 4 strokes though.)  I just have the sudden thought that if you used 五's 5 line segments for tally, it's like a Chinese version of hangman. :)
12:47:02 <ezzieyguywuf> monochrom: it's four strokes
12:47:08 <monochrom> yeah
12:47:24 <ezzieyguywuf> https://jisho.org/search/%E4%BA%94%20%23kanji
12:47:27 <ezzieyguywuf> see "stroke order"
12:47:31 <ezzieyguywuf> well, again, this is japanese
12:47:36 <ezzieyguywuf> but the characters are the same.
12:48:03 <monochrom> don't worry, this one the two cultures agree
12:48:19 <ezzieyguywuf> nice.
12:48:35 <ezzieyguywuf> I've been meaning to finish learning japanese. so I can try to pick up mandarin and see where they differ.
12:49:26 <monochrom> Whenever there is some piece of Chinese culture that you suspect has been butchered by that damn bloody government in the past 5 decades, chances are you can find the original unabridged in Japan or South Korea. Sad but true.
12:51:07 * hackage simple-enumeration 0.2.1 - Finite or countably infinite sequences of values.  https://hackage.haskell.org/package/simple-enumeration-0.2.1 (BrentYorgey)
13:00:00 <typetetris> Can cabal somehow suggest version bounds for me?
13:01:19 <maerwald> What?
13:01:46 <maerwald> use: ^>= x.y 
13:01:56 <Rembane> typetetris: I usually select the exact versions, and then loosen them over time. 
13:02:00 <monochrom> Under a very peculiar circumstance it does. But it involves using it in the v1 way. And it merely gives you, e.g., if the current version is 1.5.7.3, it just mechanically gives ==1.5.*
13:02:01 <maerwald> if you don't know what you are doing
13:02:13 <maerwald> but better know what you are doing
13:03:42 <typetetris> To morally write down wide version bounds, shouldn't I have tried to compile all those versions?
13:03:55 <typetetris> And thats not a task I am looking forward too.
13:04:11 <monochrom> Philosophically I really would write version bounds manually (even if, especially when, it's simply ==1.5.*), and resist automation.
13:05:06 <monochrom> You can morally write narrow bounds.
13:05:20 <monochrom> PVP implies that ==1.5.* is a moral no-brainer.
13:05:23 <merijn> typetetris: Just do what I do, start with the exact version you developed against and relax as new versions become available
13:05:40 <monochrom> PVP was designed so that this moral no-brainer makes sense.
13:05:43 <typetetris> Shouldn't `cabal exec -- ghc-pkg list` list the project specific packages? For me it only lists my compiler packages database and nothing else.
13:05:47 <maerwald> use: ^>= x.y
13:06:05 <maerwald> there is a reason that syntax exists
13:06:16 <merijn> maerwald: You mean "use ^>= with the exact version you have right now"
13:06:22 <monochrom> Does ^< x.y also exist?
13:06:24 <maerwald> yeah
13:06:24 <phadej> typetetris: morally, no, you don't need. PVP is there that you can assume based on testing single version of dependency how some other will behave
13:06:27 <merijn> monochrom: No
13:06:31 <monochrom> Darn.
13:06:36 <merijn> monochrom: Because that makes no sense
13:06:49 <monochrom> I understand.
13:07:22 <monochrom> This is what I do.
13:08:08 <monochrom> When I start my package from scratch, I use ==1.5.*, if 1.5.something is the version I happen to have at the beginning.
13:08:19 <phadej> that's unsafe
13:08:28 <phadej> you have to test hte lowest in 1.5.* range
13:08:37 <phadej> because you may depend on a feature introduced in 1.5.5 e.g.
13:08:45 <monochrom> Later, if I find out that 1.6.* also works (and 1.5.* still works), I relax it to >=1.5 && < 1.7.
13:08:48 <phadej> 1.5.* is bad syntax
13:09:02 <typetetris> What about `cabal gen-bounds` ?
13:09:11 <monochrom> I wouldn't worry about "what if 1.4.*?" until someone make me do it.
13:09:52 <phadej> gen-bounds is "try what's current, and put those"
13:10:20 <monochrom> OK yeah, I may need 1.5.3.* or >= 1.5.3
13:10:59 <ja> phadej: which versioning model are you referring to? in x.y.z, z is usually the 'patch' release. but patches shouldn't add features, right?
13:11:02 <monochrom> I really don't understand the question, unless there is gross misunderstanding of PVP.
13:11:03 <ezzieyguywuf> or just use stack and let snapshots take care of it
13:11:13 <phadej> ja: PVP, https://pvp.haskell.org/
13:11:57 <monochrom> ja, I made the mistake of >=1.5 when I have only tried e.g. 1.5.3.7.  I should be writing >=1.5.3
13:12:28 <ja> is PVP the most popular scheme in haskell versioning?
13:12:28 <maerwald> monochrom: many don't understand PVP, some disagree with it and some follow semver on hackage even (or something entirely different
13:13:04 <monochrom> I can cope when I know what they use when they don't use PVP.
13:13:28 <monochrom> e.g. semvar is easy to cope with too. It's just PVP with one fewer dot.
13:13:51 <monochrom> base and HTTP are funny but they can be figured out too
13:13:54 <maerwald> I don't believe version bounds have ever saved me from bad updates anyway
13:14:29 <phadej> ja: it's the versioning scheme
13:14:59 <phadej> semver vs. pvp is completely orthogonal whether to have upper bounds or not
13:15:26 <merijn> maerwald: Lack of upper bounds has ruined my day at least 8 times so far
13:15:33 <phadej> both say essentially the same (pvp more precisely), these are semantics of version number, put upper bounds according to them
13:15:57 <maerwald> merijn: can't say that here
13:16:17 <typetetris> phew ... `base ^>= 4.12.0.0` feels weird
13:16:18 <ja> merijn: do you think even base should have upper bounds? i had to send 5 PRs last month to relax base version bounds
13:16:56 <phadej> look at about any package.json on npmjs registry, they are  all 
13:16:56 <phadej>   "devDependencies": {
13:16:57 <phadej>     "@babel/cli": "^7.8.0",
13:17:11 <merijn> ja: base has changed in the past and can certainly add new names which may clash and break compilation
13:17:16 <maerwald> I freeze the index and just bump it every other day, when I'm bored. If there are too many problems, I revert
13:17:17 <phadej> where ^7.8.0 is kinda the same as ^>=7.8.0  in pvp syntax
13:18:00 <monochrom> Haha let me bridge it back to another conversation earlier today
13:18:09 <maerwald> In non-libraries I don't do upper bounds 
13:18:13 <monochrom> this is why some people reduce dependencies
13:19:13 <phadej> I see a problem when comsumers require maintainers to bump bounds immediately after the new version is relased
13:19:22 <phadej> that's plainly impossible
13:19:24 <monochrom> If your build-depends list has 1000 items, morally you have to check and update 1000 bounds every once in a while.
13:19:42 <monochrom> One solution is to be immoral. Another is to not have 1000 items.
13:20:03 <merijn> monochrom: packdeps gives you an rss feed whenever your upper bounds need checking :)
13:20:05 <phadej> there is plenty of range between "updating 1min after the dependency release" and "being absent maintainer"
13:20:38 <merijn> monochrom: When a new version releases that falls outside your upperbound you can get an item on the RSS feed so you can check the changelog and update bounds accordingly :p
13:20:47 <ezzieyguywuf> +1
13:20:49 <monochrom> There could also be "is there something like CI but for version bounds". I don't know how many people want to implement it for the rest of us.
13:20:52 <ezzieyguywuf> to monochrom's bold
13:21:04 <merijn> monochrom: You mean hvr's matrix stuff?
13:21:26 <merijn> monochrom: https://matrix.hackage.haskell.org/#/package/broadcast-chan
13:21:31 <monochrom> perhaps? I don't know his matrix stuff.
13:21:46 <merijn> :O
13:22:00 <merijn> Do I say a build failure in my own stuff :O
13:22:44 <phadej> oh a red cell :(
13:22:56 <monochrom> Well, it's a truism that if I think up a cunning plan, then someone else has already implemented it to fruitation 5 years before.
13:22:59 <phadej> luckily I don't have a rss feed for failed builds in matrix.hho
13:23:05 <phadej> that one would make anyone miserable
13:23:15 <phadej> maybe I should ask hvr whethere we should make a twitter bot
13:23:35 <phadej> "@AngryHackageTrustee"
13:23:38 <phadej> or sad
13:23:51 <ja> i prefer PassiveAggressive
13:24:01 <merijn> phadej: oh, I'm a n00b
13:24:28 <phadej> ja: I wonder what's the limit for twitter user names
13:24:31 <phadej> length*
13:24:35 <merijn> phadej: That release I explicitly dropped support for pre 8.0 GHC, but apparently didn't change the lower bound on base
13:25:01 <ja> maybe this explains the issue somebody had building pandoc recently: https://matrix.hackage.haskell.org/#/package/pandoc
13:25:21 <ja> no longer in my backlog :*
13:25:24 <ja> :(
13:25:25 <phadej> merijn: you give me an idea, maybe haskell-ci should have an optional job to test that there *no* install-plans with unsupported GHCs
13:25:29 <ja> didn't mean to kiss the channel :O
13:25:45 <phadej> merijn: if only travis supported completely separate scripts for different jobs
13:25:46 <ezzieyguywuf> ja: I thought it was sweet.
13:26:08 <phadej> ja: pandoc just runs out of memory
13:26:11 <phadej> it's actually fine
13:26:34 <phadej> clicking the cell and looking at hte build log (scroll down) reveals that
13:27:16 <typetetris> Is there a process to take over a package in hackage? HashellNet-SSL has not been updated in a while an dpwright doesn't seem to care any more (pull request not merged, nor closed).
13:27:18 <ja> oooh , i didn't realize i had to do something after clicking
13:28:01 <phadej> pandoc simply have plenty of releases
13:28:51 <phadej> and matrix' UI is not really polished
13:29:09 <phadej> there's a limit what a single person can do, or even two (none of which is me)
13:36:49 <ja> interesting, it is using purescript!
13:40:35 <ezzieyguywuf> I guess learning parsec and cousins is hard, but it's like learning flex and bison
13:40:38 <ezzieyguywuf> which is also hard
13:40:42 <ezzieyguywuf> but ultimately (probably) dead useful
13:41:19 <ezzieyguywuf> actually the part I'm struggling with now is monad transformers, I think I mostly understand the parsing stuff
13:43:02 <ezzieyguywuf> so if I`m using a `Parsec Void Text (Maybe a)` all over the place, and doing `case maybeValue of...` to check for Nothing or Just, doesn't this mean that I could (should?) use `ParsecT` instead and let the Maybe monad "take care" of checking for Nothing for me?
13:43:09 * ezzieyguywuf 's head spins
13:43:26 <phadej> ezzieyguywuf: no
13:44:54 <ezzieyguywuf> well, here's where I run into  problem : https://gitlab.com/ezzieyguywuf/mycad/-/blob/useTransformers/HaskellCAD/src/CommandParser2.hs#L37
13:45:27 <ezzieyguywuf> I have three `Maybe Int`, and if any one of those is Nothing, I want to return `pure Nothing`, otherwise I want to return `Just (V3 x y z)`
13:45:38 <ezzieyguywuf> I can't really understand what a good way to accomplish this is
13:45:41 <phadej> return $ V3 <$> x <*> y <*> z
13:46:03 <phadej> and that is not relaed to parsing at all
13:46:12 <ezzieyguywuf> 😮
13:46:17 <phadej> % :t liftA2 @Maybe
13:46:17 <yahb> phadej: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
13:46:19 <ezzieyguywuf> I have much to learn about Applicative 
13:46:23 <phadej> % :t liftA3 @Maybe
13:46:23 <yahb> phadej: (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d
13:46:45 <phadej> liftA3 V3 x y z -- is another way to say that (and easier to show type-signature)
13:47:00 <phadej> it's not about parsing, it's about working with Maybe's
13:47:05 <ezzieyguywuf> hah, except I already knew that that would work, but it did not occur to me. I must make a note to work through that typeclassopedia some time
13:47:12 <ezzieyguywuf> phadej: you're absolutely right
13:47:35 <ezzieyguywuf> phadej: notice I said (at some point) "I mostly understand the parsing stuff."
13:47:41 <ezzieyguywuf> I intuited that my issue was elsewhere
13:47:53 <ezzieyguywuf> but I was facing the wrong direction, staring down the barrel of monad transformers
13:48:04 <ezzieyguywuf> when my good friend Applicative was there, waiting with a hug
13:48:32 <phadej> fyi, https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec-Combinator.html#v:optionMaybe or https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Applicative.html#v:optional
13:49:13 <phadej> (sadly optional from parsec and Applicative are different, ,be careful with imporots)
13:49:30 <ezzieyguywuf> phadej: I'm using megaparsec, and I think it differs from parsec in this
13:49:39 <ezzieyguywuf> at least, I didn't see optionMaybe in megaparsec
13:50:17 <phadej> megaparsec "says" you should use optional from C.Applicative module
13:50:22 <phadej> it's better in that sense
13:50:33 <ezzieyguywuf> ah, you're right it does say that
13:50:42 <ezzieyguywuf> but in turn you have to roll your own optionMaybe
13:51:18 <phadej> https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Applicative-Combinators.html has plenty of stuff
13:52:34 <ezzieyguywuf> nice package!
13:52:36 <ezzieyguywuf> only depends on base
13:53:59 <phadej> it's by author of megaparsec, and AFAIU meant to be a companion package
13:54:09 <phadej> it's generally useful, not only for megaparsec
13:54:36 <phadej> in fact, megaparsec depnds on parser-combinators
13:54:43 <merijn> megaparsec reexports parser-combinators
13:56:28 <phadej> and with >=1.0 && <2.0) bound
13:56:31 <phadej> not good :(
13:56:48 <phadej> better to not import parser-combinators stuff through megaparsec
13:56:52 <ezzieyguywuf> if megaparsec re-exports it then I don't need to directly import it....right?
13:58:40 <phadej> if you use open imports (which you shouldn't in libraries), than you don't need no
13:58:51 <phadej> Note that we re-export monadic combinators from Control.Monad.Combinators because these are more efficient than Applicative-based ones. Thus many and some may clash with the functions from Control.Applicative. You need to hide the functions like this
13:58:56 <ezzieyguywuf> I just changed it to do explicit imports
13:58:57 <phadej> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#g:1
13:59:07 <ezzieyguywuf> is that the right term? `import Something (something, else)`
13:59:13 <monochrom> yes
13:59:22 <phadej> they are often called import lists
13:59:34 <ezzieyguywuf> yea, I think I may just start doing that every time
13:59:37 * hackage zipper-extra 0.1.2.1 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.2.1 (locallycompact)
13:59:40 <ezzieyguywuf> makes me think more about what I'm doing  and using
14:00:07 <phadej> yes, I do find it useful as you know where from stuff comes, though it's annoying
14:00:16 <phadej> to add stuff to import lists manually
14:00:22 <phadej> trade-offs
14:00:43 <ezzieyguywuf> indeed
14:00:55 <phadej> (especially for parsing nad pretty-printing libraries, where you need dozens of symbols)
14:01:05 <ezzieyguywuf> optional is poorly named I think - I'm not saying this is optional, I'm saying it may not parse correctly
14:01:39 <ezzieyguywuf> phadej: in that case I may just `import qualified PrettyPrint as pp`, but then the symbol use is not so pretty
14:01:45 <monochrom> If it may not parse correctly, you should let parse error happen.
14:02:07 <monochrom> If there is a plan B for parse error, you should use <|> planB
14:02:46 <monochrom> The only use case of option and optional is when your grammar really says "this is optional".
14:03:50 <ezzieyguywuf> hrm
14:04:23 <ezzieyguywuf> but I want to handle the failed parse myself
14:04:31 <ezzieyguywuf> i.e. "Did you mean one of these things?" or something like that
14:04:43 <ezzieyguywuf> maybe I should read through that megaparsec book again, I think it talked about these things.
14:05:05 <monochrom> You may need to learn context-free grammars in the first place.
14:05:09 <phadej> you can recognize wrong stuff, and still call `fail` (or whatever is there in megaparsec for custom errors)
14:05:13 <ezzieyguywuf> I think the errors in megaparsec are really cool, but I don't want it in my 'production' code
14:05:34 <phadej> but you should still try to fail early
14:05:56 <phadej> except if your explicit tgoal is to do recoverable parsing, which is difficult topic
14:06:09 <monochrom> I don't know what kind of "handle the failed parse" you mean. There are many kinds.
14:06:26 <ezzieyguywuf> perhaps I should read up on context free grammar
14:06:51 <ezzieyguywuf> monochrom: yea. I don't know either. I think I need to take a step back and re-evaluate my goals here.
14:06:54 <monochrom> Yes. BNF's | usually corresponds to <|>
14:07:16 <phadej> CNF / parsing is sadly where broad topic, and hard to find good material
14:07:23 <phadej> s/where/very/
14:07:38 <monochrom> In other words, BNF's | never corresponds to "x <- optional xxx; case x of Nothing -> yyy"
14:07:51 <ezzieyguywuf> I have input coming from the user on the command line. I have a pre-determined set of commands they can issue. If the command is wrong, I want to present a helpful "help" text. if the command is right, but used incorrectly (e.g. incorrect number of arguments) I want to provide a context-specific help text
14:08:05 <monochrom> You don't do that yourself. You let <|> do it.  xxx <|> yyy
14:08:16 <ezzieyguywuf> anywho, unfortunately I must go now, time to pick up the kids.
14:08:29 <phadej> yes, better to get parsing working in the first place
14:08:36 <phadej> and then evaluate the quality of error messages :)
14:08:46 <phadej> don't think too far in advance
14:09:08 <phadej> sadly TAOCP Volume 6 – The Theory of Context-Free Languages might not happen :
14:10:26 <Waldkauz> It's too bad that the last books of this series are the most interesting :(
14:10:30 <sm[m]> ezzieyguywuf: command line parsing so specialized and you’re almost certainly better off using a library focussed in that
14:11:19 <monochrom> Yeah, I don't think any of the *parsecs are best suited for this, esp. regarding error messages.
14:12:08 <monochrom> Your scenerio is most likely like "there must be 3 arguments. the 1st must be digits. the 2nd must be true or false. the 3rd is an arbitrary string".
14:12:51 <monochrom> This is something you can code up directly without CFG parsers, and will still end up being simpler than using CFG parsers.
14:13:59 <phadej> that's encodable with megaparsec too, where token type is more elaborate than Char
14:14:12 <phadej> I would still use parser combinator library (of some kind)
14:16:12 <monochrom> I wouldn't. Setting up the token type and the tokenization stage already too much overhead. I don't mean computational resource overhead, I mean programmer's overhead.
14:16:55 <monochrom> If you're requiring 100 arguments, that's different.
14:17:38 <monochrom> If you're implementing Unix's expr or test, that's fair game, they are CFGs.
14:19:37 * hackage smtp-mail 0.2.0.1 - Simple email sending via SMTP  https://hackage.haskell.org/package/smtp-mail-0.2.0.1 (parsonsmatt)
14:20:09 <phadej> vanilla parsec has Monad m => Stream [tok] m tok
14:20:14 <phadej> so there is very little setup
14:20:28 <monochrom> I know.
14:21:02 <phadej> and it forces you to structure your program
14:21:17 <phadej> with ad-hoc solution there isn't such force
14:21:39 <phadej> also `words` is often perfectly valid lexer
14:22:00 <maerwald> hasktags breaks hard with quasi quoters...
14:28:56 <monochrom> I am talking with "words has already been done" in mind. If I do the following checks in the Except monad: 1. there are 3 words (or else the exception is "wrong argument count"); 2. 1st word is a sequence of digits (or else the exception is "1st argument is not a number", and I convert it to a number; 3. 2nd argument is "true" or "false" (or else the exception is "2nd argument is not boolean"), and I convert it to Bool.  Then mine is still well 
14:28:56 <monochrom> structured, with the advantage of being lightweight, and without shoehorning my peculiar exception scheme into that of a parser combinator library (which always has other ideas).
14:34:34 <koz_> What does 'c' refer to here? https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Lazy.html#v:fromStrict
14:35:21 <dsal> number of codepoints?
14:36:05 <dminuoso> number of chunks?
14:36:41 <MarcelineVQ> strict is't chuncked, lazy is
14:36:51 <koz_> MarcelineVQ: I'm referring to lazy Text.
14:37:01 <koz_> I'm rather curious whether it's chunks or codepoints.
14:37:30 <dminuoso> MarcelineVQ: mmm, I guess chunk doesnt split into chunks, but places it into a single celll..
14:37:34 <MarcelineVQ> "O(c) Convert a strict Text into a lazy Text." chunking is just wrap with Chunk constructor, so this should be O(1) if anything
14:37:49 <dminuoso> From the looks of the code, it's O(1)
14:38:02 <koz_> dminuoso: Sweet!
14:38:09 <koz_> The docs could stand to be a lot clearer on this point.
14:38:13 <dsal> Seems like in any case, it'd be good to update the documentation.
14:38:24 <dsal> O(g)  (original gangster)
14:38:52 <dminuoso> For good measure, Id specify `O(2)
14:39:01 <dminuoso> Just to make sure the confusion isn't lost, in the update.
14:39:27 <solonarv> O(π)
14:39:51 <dsal> Scales with Ron Howard
14:41:05 <monochrom> I use "append is O(n/c)" to deduce that c is chunk size.
14:41:12 <MarcelineVQ> probably just got copied from "O(c) Convert a list of strict Texts into a lazy Text." where the c would mean chunks, to differentiate it from n, which would have so far been used to denote the length of one Text
14:42:18 <MarcelineVQ> still the c/n difference isn't very consistent here...
14:42:37 <dsal> Could also be a paper town.  I sent out a bunch of changes to a bunch of people at work referencing a document that described why it was happening.  Lots of people pushed the change through before someone finally pointed out my document was private.
14:42:57 <Rembane> Legendary politicking
14:42:59 <MarcelineVQ> or maybe it is, just not on the one thing I was looking at :>
14:51:16 <koz_> > show (10 :: Word)
14:51:18 <lambdabot>  "10"
14:51:20 <koz_> :D
15:38:00 <gushys> Hello, im pretty new to haskell, done a bit in college but not more than a few small functions, i want to learn functional programming and figure that where better than Haskell. What is a nice recommended starting place, ive been looking at Learn you a Haskell, and messing around with yesod, but maybe there is some other books prefereably online i should check out instead?
15:44:05 <hpc> https://www.haskell.org/documentation/ is the big list
15:44:20 <dminuoso> gushys: CIS 194 is a pretty good starting point.
15:49:38 <gushys> dminuoso++
15:49:40 <gushys> thanks
15:59:38 <oats> the further along I've gotten learning about haskell, the more it feels like LYAH wasn't super useful to me
16:02:59 <gushys> what made the most sense or was the most useful for you ?
16:03:20 <dsal> gushys: haskellbook.com was the best for me.  :)
16:03:34 <dsal> Though no single source is enough.
16:04:15 <oats> gushys: random blog posts I came across as I tried to write my own programs, failing repeatedly :P
16:04:19 <dsal> oats: Also: maybe that.  I had written a few programs before I read that book.  For all I know, whatever got me going in the first place was not very useful in retrospect.  Then again...
16:04:41 <hpc> it was whatever made you think at the time
16:05:04 <dsal> I can say my early haskell programs weren't much written in haskell.
16:05:10 <hpc> i thought LYAH was great, but i also basically locked myself in a room for a month for it
16:05:18 <dsal> (but also, maybe not my current ones)
16:05:24 <dminuoso> Any source that gets you to the point where you can bootstrap yourself from resources is good.
16:05:46 <dminuoso> Even if you might think badly in retrospect about the book, if it brought you where you are now, it did its job.
16:05:58 <oats> I think LYAH teaches you the semantics and syntax of haskell, but I don't feel like it does a great job of actually showing you how to do useful things in haskell
16:06:12 <dminuoso> oats: I dont think any book really does that.
16:06:15 <dsal> It's a question of efficiency at that point.
16:06:18 <gushys> im just finding that i feel like there are so many sources to learn but what ones to choose. i get in my own head about not knowing where to start
16:06:18 <oats> yeah...
16:06:30 <dminuoso> gushys: CIS 194 is a rock solid start.
16:06:47 <dminuoso> It is generally well regarded by the current Haskell community.
16:06:47 <oats> I think haskell could learn a lot from the rust community about education & language resources
16:06:50 <dsal> haskellbook.com showed me how to do a lot of things well enough that I had to build them myself.  I don't know that I understood how to use those things I built that well at the time, but it was still helpful.
16:06:59 <dminuoso> It also has some pretty good excercises that build up well ontop of each other.
16:07:05 <dminuoso> And its pedagogically well structured
16:07:12 <oats> doesn't help that LYAH is a bit out of date
16:07:34 <gushys> thats what im always worried about when looking at the books, everything feels just a bit out of date
16:07:54 <dminuoso> CIS194 is not. There's some mild inconsistencies with CodeWorld, but that's only because CodeWorld was updates a few weeks ago.
16:08:02 <gushys> especially since it seems the environment has shifted in terms of dev setup
16:08:08 <ArtemZ> Hello everyone. Do you guys think it's worth learning Haskell for a devops engineer? 
16:08:08 <ArtemZ> I've just got fed up with python and it's joke of a functional programming support
16:08:10 <dsal> gushys: Everything is always out of date, but the fundamentals are pretty stable.
16:08:23 <dsal> ArtemZ: You had me at "think it's worth learning Haskell"
16:08:35 <dminuoso> ArtemZ: If you can leverage it its worth it.
16:09:20 <gushys> dsal: i can understand that, i just get in my own head about making sure my fundamentals are proper, i would hate to get into bad habits or out of practice habits
16:10:03 <dminuoso> I dont think learning Haskell in general will drastically improve your job chances on its own
16:10:28 <dsal> gushys: haskellbook.com (HPFFP or HFFP or whatever people want to call it) is very large, and very slow, but I found it efficient.
16:10:46 <dminuoso> If you want to learn Haskell to broaden your horizon, then Haskell will give you quite a bit. If you want to learn Haskell to adopt new technologies in your projects, it's also a great pick.
16:10:57 <oats> (also costs money :<)
16:11:04 <oats> understandable, but a bit of a barrier
16:11:15 <ArtemZ> I'm not seeking a job, but I hope it can help with improving my workflow/bring me new ideas etc
16:11:18 <dsal> With the exception of a few weird edges, I find it easier to write reliable software in haskell than most languages I've worked in.
16:11:27 <monochrom> worth learning haskell compared to what?
16:11:42 <monochrom> family time? learning asm? getting an MBA?
16:11:43 <dsal> I assumed COBOL
16:12:06 <dminuoso> ArtemZ: It has the potential to change how you think about programming and architecture.
16:12:10 <monochrom> Similarly, "is haskell code fast?" compared to what?
16:12:12 <dminuoso> Quite radically, but its no guarantee.
16:12:34 <ArtemZ> <dminuoso "ArtemZ: It has the potential to "> Thank you, that's what I'm looking for
16:12:40 <dsal> monochrom: I don't like "compared to what" really.  I just like... "enough"
16:13:32 <monochrom> The problem with "enough" is that it means "compared to a threshold I have in mind and I'm not going to tell you where it is"
16:13:38 <dsal> heh
16:14:01 <dminuoso> ArtemZ: At first, Haskell might have all these totally strange notions that you can't wrap your head around, and once you set a footing - at some point - you will suddenly make the connections to other languages, and it could shift how you think in those languages as well.
16:14:09 <monochrom> However, if you further qualify/quantify "enough" with elaboration, that's good.
16:14:19 <dsal> I replaced a bunch of stuff I'd written in go with haskell.  The go was *probably* faster, but the haskell is easier to work on and I can't tell the difference in performance.
16:14:38 <gushys> I was reading a post on the state of haskell and my biggest take away is that if you can leverage in your work, then you can ease the barrier of entry for adoption of haskell
16:15:02 <dsal> I also replaced my mosquitto server with haskell code.  I didn't work on mosquitto much, but I've had it segfault and/or corrupt its data store a few times.  My haskell code doesn't do those things.
16:15:20 <monochrom> If you're unhappy with python, learning haskell will make you happier. Is it worth making yourself happier?
16:15:21 <gushys> if you want to learn it, and you think its beneficial then go for it
16:15:47 <dsal> I don't deserve happiness.
16:16:03 <monochrom> actually s/will/may/ because some people become unhappier because they still have to use python in jobs after learning haskell.
16:16:28 <dsal> That is a problem.  My group still does primarily go.  It's very frustrating that I *can't* write some really simple stuff in go.
16:16:31 <monochrom> that's empirically sadder than using python in jobs without knowing haskell
16:16:57 <oats> dsal: you must be pretty excited about lambda man helping out with Go generics, then :P
16:16:59 <monochrom> we have a few witnesses and testimonies in this channel actually
16:17:55 <dsal> oats: Eh, I wasn't happy with how java turned out.  I've really hard a hard time following the go generics stuff.  It's pretty boring.  And still, the thing I suffered most recently was the inability to express a sum type.
16:18:05 <oats> programming in python after you've tasted haskell is like drinking starbucks after tasting literally anything else
16:18:14 <boxscape> dsal: can you at least scott encode it or something
16:18:24 <dsal> Someone used a string as a data type.  But it can be a string, an int, or a boolean.  Oh, so it can be anything at all?
16:18:29 <koz_> > intersperse 1 []
16:18:31 <lambdabot>  []
16:18:36 <koz_> > intersperse 1 [2]
16:18:39 <lambdabot>  [2]
16:18:44 <koz_> > intersperse 1 [2, 3, 4, 5]
16:18:46 <lambdabot>  [2,1,3,1,4,1,5]
16:18:49 <koz_> :D
16:19:52 <dsal> > unwords . intersperse ". " . words $ "people like to use intersperse for emphasis"
16:19:54 <lambdabot>  "people .  like .  to .  use .  intersperse .  for .  emphasis"
16:20:06 <boxscape> you need to do that with clap emojis
16:20:11 <dsal> I guess I should've gone with 👏
16:20:14 <boxscape> there you go
16:20:16 <dsal> heh
16:20:16 <gushys> haha
16:20:20 <oats> lolol
16:20:32 <dsal> > unwords . intersperse "👏" . words $ "why do I always ruin my own jokes"
16:20:34 <lambdabot>  "why \128079 do \128079 I \128079 always \128079 ruin \128079 my \128079 own...
16:20:38 <dsal> yay
16:20:39 <oats> aww
16:21:02 <gushys> that didnt work as expected ;(
16:21:13 <infinisil> % putStrLn $ unwords . intersperse "👏" . words $ "why do I always ruin my own jokes"
16:21:13 <yahb> infinisil: why 👏 do 👏 I 👏 always 👏 ruin 👏 my 👏 own 👏 jokes
16:21:21 <dsal> Doh, I was just doing that.
16:21:41 <infinisil> Ayy o/
16:21:42 <dsal> gushys: lambdabot shows the result.  yahb can do IO
16:22:09 <gushys> dsal: thats dope
16:23:59 <dsal> intercalate would make more sense there, but koz_ was interspersing
16:24:18 <oats> :t intercalate
16:24:19 <lambdabot> [a] -> [[a]] -> [a]
16:24:21 <gushys> > intersperse "X" [1..10]
16:24:23 <lambdabot>  error:
16:24:23 <lambdabot>      • No instance for (Enum [Char])
16:24:23 <lambdabot>          arising from the arithmetic sequence ‘1 .. 10’
16:24:35 <gushys> > intersperse 25 [1..10]
16:24:38 <lambdabot>  [1,25,2,25,3,25,4,25,5,25,6,25,7,25,8,25,9,25,10]
16:24:44 <gushys> thats pretty cool
16:25:00 <gushys> > intersperse 'X' [1..10]
16:25:02 <lambdabot>  error:
16:25:02 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
16:25:02 <lambdabot>      • In the expression: 1
16:25:10 <oats> gushys: https://www.youtube.com/watch?v=RqvCNb7fKsg
16:25:14 <oats> you'll like this
16:25:15 <dsal> gushys: A list can only have one type in it.
16:25:19 <gushys> yeah
16:25:46 <gushys> strict typing and all
16:25:49 <dsal> But that error is implying that 'X' would work if you made a Num instance for Char.
16:25:55 <dsal> Like, don't ever do that, but you can.
16:26:42 <fresheyeball> cabal is yelling at me now
16:26:43 <fresheyeball> (package is broken)
16:26:47 <fresheyeball> what is that?
16:27:21 <fresheyeball> why does it think my packge is broken?
16:28:25 <int-e> fresheyeball: what does it say
16:29:56 <fresheyeball> [__0] trying: backend-0.1.0.0 (user goal)
16:29:58 <fresheyeball> [__1] next goal: ikg-http (dependency of backend)
16:30:00 <fresheyeball> [__1] rejecting: ikg-http-0.1.0.0/installed-3bI... (package is broken)
16:30:02 <fresheyeball> int-e: ^
16:30:04 <fresheyeball> in my specific case
16:35:25 <ezzieyguywuf> monochrom: I think you are right, perhaps going down the parser rabbit hole was the wrong path. I came across a SO answer that said something along the lines "You can (1) do it wrong, (2) do it your own way, or (3) admit you have a little language on your hands and write a proper parser". That's what started me on the path
16:36:39 <Chobbes> Hmmm. I'm having some problems with haskell-mode in emacs. Does anybody else notice that when "haskell-indentation-newline-and-indent" is run there's like a half a second delay before anything happens?
16:37:18 <ezzieyguywuf> monochrom: in fact, this was my first attempt, not using any kind of parsing library. I started to feel that it was pretty "hackey" though, and that there must be a better way that allows the 'mini language' to scale: https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/CommandParser.hs#L12
16:38:51 <ezzieyguywuf> but maybe I took the wrong path - maybe I start over with some of the lessons I've learned in the parsing libraries and try some sort of `words` + combinators approach
16:40:15 <int-e> fresheyeball: hrm. so I imagine ghc-pkg reports the package as broken, which may happen, for example, because of a missing (perhaps reinstalled?) dependency.
16:40:42 <int-e> fresheyeball: Not sure what to suggest besides trying a clean build. :/
16:40:44 <ezzieyguywuf> monochrom: I like the basic approach you outlined using the Except monad (or ExceptT?) I started going down this path too but got confused :-P
16:44:07 <superstar64> In my compiler, I come up with this rewriting rule `(\i -> \y -> ...)(x) --> \y -> (\i -> ...)(x) if (y not in free(x))`, is this eta expansion?
16:44:13 <superstar64> I just want to be sure
16:45:45 <dolio> No.
16:46:06 <superstar64> Is there some other name for this then?
16:50:51 <monochrom> it seems to go through a beta and then an unbeta
16:50:53 <mlugg> (I have actually asked this before, I just sort of forgot and sort of didn't really understand in the first place): I'm looking at GHC's primitive things, and I'm confused at why RealWorld is primitive; since it's lifted, it seems like it'd behave identically to an EmptyDataDecl `data RealWorld`. What am I missing here?
16:50:54 <int-e> superstar64: I think it's a form of let-floating, if you think of (\i -> ...) x as let x = i in ...
16:51:03 <int-e> err, let i = x in ...
16:52:26 <monochrom> mlugg: If you rewrite GHC from scratch today, it probably doesn't matter either way. But RealWorld predates EmptyDecl by 3 decades.
16:52:42 <mlugg> Ah, okay, so it's just a legacy thing?
16:52:49 <monochrom> I think so.
16:54:04 <mlugg> (The documentation is a bit weird - it refers to an nonexistent ptrArg, and there's a GHC bug about said doc that's been open for 3 years)
16:54:18 <superstar64> int-e, yea, i'm moving let statements into lambads
16:54:34 <mlugg> And it hypes it up! Tells us it's "deeply magical"! I am sorely disappointed! :P
16:55:20 <monochrom> Oh, "deeply magical" is comic speak for "compiler has special-case code for it"
16:55:48 <monochrom> and "said code not user-writable"
16:56:52 <monochrom> s/has/generates/
16:57:07 <monochrom> err, sometimes it really is "has". nevermind.
16:58:19 <taylskid> .
17:00:02 <monochrom> Another example is GHC.Exts.lazy. Don't even bother reading its source code, that's just a stub. Compiler looks for its occurence and generates code specially. You may also like: It's also in GHC.Magic.
17:00:40 <superstar64> What's the point of modules if the compilers only checks for names?
17:00:58 <monochrom> Huh, that sounds like two orthogonal concerns.
17:00:58 <dsal> ezzieyguywuf: When doing advent of code, I use (fmap read . words) for the most trivial things, otherwise I just start with megaparsec.
17:02:38 <boxscape> superstar64: I imagine it means you can use stock name exporting functionality and just handle the implementation itself specially
17:03:21 <boxscape> superstar64: the compiler then doesn't have to treat the name specially everywhere, just in the module it's supposed to be in
17:03:29 <monochrom> In the case of Haskell, the whole point of modules is names.
17:03:30 <boxscape> s/be in/be defined in/
17:06:20 <superstar64> I made an attempt at embedded logic in haskell https://gist.github.com/Superstar64/d9262b493da18c32839167ad78247341
17:06:27 <superstar64> Any criticisms? 
17:14:10 <superstar64> I'm not too familiar with concatenative programming so I'm not sure If my exchange rules could be simpler  
17:28:53 <dolio> Those aren't actually sufficient, are they?
17:33:14 <superstar64> dolio, i don't think my rules are missing anything
17:33:49 <superstar64> it's basically copied from walder's paper's with some minor tweeks to change
17:34:26 <solonarv> superstar64: the module where something is defined is part of its fully qualified name
17:34:58 <solonarv> and those names are what the various special-case code in the compiler interacts with
17:36:15 <superstar64> Oh, I was talking about my attempt to embed logic in haskell
17:36:51 <solonarv> sorry, that was a response to your earlier question (from half an hour agon)
17:46:50 <Axman6> I feel like "agon" is a word which should exist
17:47:34 <Axman6> MEaning ago, but with the strong implication that the time has passed and is now gone. 
17:48:26 <monochrom> Aragon is agon.
17:51:48 <dminuoso> So Im dissecting a piece of data which, based on a handful of predicates (isA, isB and isC) could be A, B or C. Is there some idiomatic trick to ensure that my data can only be one of three (so there's no conflict)?
17:52:08 <dolio> superstar64: Your rules only let you manipulate one side of the context.
17:53:08 <monochrom> dminuoso: Define literally "data ABC = A | B | C". Your classifier function should be X->ABC.
17:53:10 <superstar64> what is it missing then?
17:53:57 <dminuoso> monochrom: Well, I want the classifyier function to have an error case that properly reports "cant be both A and B"
17:54:00 <monochrom> It doesn't stop you from undefined, but it is clear to readers (if readers and you implicitly agree that you avoid partial functions)
17:54:36 <hyiltiz> hmm dminuoso so u didnt really want to have a function that maps to only one of 'em after all
17:54:55 <dminuoso> Im thinking of handwiring a ModeDet monad that can set the underlying thing only once, and aborts if its already set.
17:55:10 <dolio> superstar64: Exchange is usually like `Γ,A,B,Δ ⊢ B ==> Γ,B,A,Δ ⊢ B` for instance.
17:55:10 <dminuoso> (Just a thin monad ontop of say `State Mode`)
17:55:12 <hyiltiz> Why not just Maybe ABC
17:55:17 <hyiltiz> Or Either ABC?
17:55:20 <monochrom> I don't know, a function f::X->ABC cannot do both f x = A and f x = B for the same x.
17:55:42 <dminuoso> monochrom: The input of X is not under my control. The user could specify something ambiguous.
17:55:54 <superstar64> dolio, isn't that conflating proofs and lists of proofs? 
17:56:21 <superstar64> the real question is if compositions of `rot (x:y:z:xs) = (y:z:x:xs)` `swap (x:y:xs) = (y:x:xs)` enough to create any permutation of a list
17:56:25 <monochrom> OK, how do you like X -> Either MyErrorType ABC ?
17:56:38 <hyiltiz> monochrom: it sounds like u wanna first write a pureF :: x -> ABC then wrap that inside a Maybe; most likely the user input was already wrapped inside one already
17:56:51 <dminuoso> monochrom: I think we're misunderstanding each other.
17:57:01 <dolio> superstar64: No, it can only create permutations of the top three elements of the list.
17:57:33 <superstar64> what other primatives are there then? what do stack programming languages use?
17:59:30 <dolio> Dunno, I don't use them.
18:01:01 <superstar64> https://en.wikipedia.org/wiki/Stack-oriented_programming_language am i missing `over`?
18:02:46 <dminuoso> monochrom: https://gist.github.com/dminuoso/11481da3eb523338c87494e80ff35ad9
18:03:07 * hackage c14n 0.1.0.0 - Bindings to the c14n implementation in libxml.  https://hackage.haskell.org/package/c14n-0.1.0.0 (mbg)
18:03:19 <dminuoso> There's overlapping cases where a user can create ambiguity, and I want to properly report an error "you've specified both x and y"
18:19:10 <yuanlang> I have self-defined wrapper but alex shows unknown wrapper type? What should I do?
18:22:57 <gvx> superstar64: it seems like forth has the two additional commands `pick n stack = (stack!!n):stack` and `roll n s = let (a,b) = splitAt n s in b ++ a`
18:23:27 <superstar64> implementing those at type level seems awful
18:24:38 <gvx> sure. One comment I found while searching was "But the current trend in Forth programming is to avoid making the stack deeper than 3 or 4 elements. A deeper stack than that is generally considered a sign that the program has been insufficiently thought out and needs to be factored.
18:24:58 <gvx> not sure, when that text was written
18:25:15 <superstar64> A logic with those restrictions sounds somewhat interesting
18:25:32 <gvx> but I think you usually have more place to store your data, than just the stack
18:25:58 <dsal> I did a lot of programming on my HP48 in high school.  RPL let you do whatever you wanted, but the machine stack was pretty tiny.
18:28:38 <superstar64> gvx, is `pick` and `drop` enough?
18:29:17 <superstar64> oh, but then it's you can't translate this to linear logic that easily
18:30:15 <superstar64> Embedding logic is tricker then I thought
18:30:26 <gvx> not sure, the only stack-based language I used until now was befunge. maybe dsal can provide better help
18:30:53 <dsal> I wasn't in high school recently.  :)
18:31:02 <gvx> your comment just made me curious so I looked around a little bit
18:31:25 <superstar64> dsal, i'm doing type level stack manipulation to try to emulate logic https://gist.github.com/Superstar64/d9262b493da18c32839167ad78247341
18:32:05 <superstar64> which combinators do i need to create any permutation of a list?
18:32:15 <superstar64> though their composition
18:32:20 <dsal> I tried playing around with Factor a bit ago, but I didn't think I'd actually use it.
18:33:02 <dsal> You mean at the type level?  I don't do much type level programming.
18:33:34 <gvx> could you use two stacks, superstar64?
18:33:57 <superstar64> that would mess with all the other rules no?
20:08:37 * hackage b9 1.0.0 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-1.0.0 (SvenHeyll)
21:11:35 <dmj`> @def hmmm | 1 == 1, let x = 4, Just k <- Just 3, 2 == 2 = k | otherwise = 1
21:11:36 <lambdabot>  Defined.
21:11:38 <dmj`> > hmmmm
21:11:40 <lambdabot>  error:
21:11:40 <lambdabot>      • Variable not in scope: hmmmm
21:11:40 <lambdabot>      • Perhaps you meant ‘hmmm’ (line 169)
21:11:47 <dmj`> > hmmm
21:11:48 <lambdabot>  3
