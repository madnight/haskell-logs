00:04:07 <fnurglewitz> hi, I'm using servant to write some clients for several microservices which share the same auth token but obviously not the same ClientEnv, is there any "smart" way to give to each ClientM the correct ClientEnv? Here's an example of what I tried as of now: https://gist.github.com/fnurglewitz/9a8316bd2d80205070d12b8cb8d9ac7d , not sure if it is an antipattern or not
00:19:34 <wudis> lambdabot: @type mapM
00:19:36 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
00:32:07 * hackage world-peace 1.0.2.0 - Open Union and Open Product Types  https://hackage.haskell.org/package/world-peace-1.0.2.0 (cdepillabout)
00:50:09 <asheshambasta> Say I have a cabal file with `library` and `executable` packages. `cabal new-repl` brings me to a repl using the `library` package. Is there a way to override this to use a package I choose?
00:53:10 <dibblego> cabal new-repl exe:nameofexe
00:57:36 <koz_> Is there a way to write sepBy :: (Monoid a) => a -> Vector a -> a without explicit recursion? Basically, empty vector gives mempty, singleton gives just its element, and anything else sticks the first argument between each pair of adjacent elements.
00:58:40 <fog> that doesnt typecheck koz_
00:59:07 <fog> mempty and "just its element" are type a, but interspersed vector is a vector
00:59:42 <fog> ohh, its seperating them, so you wrap the mempty in a vector?
00:59:57 <asheshambasta> dibblego: this is quite cool, thanks!
01:00:01 <fog> um, but then still its not a -> vector a -> a
01:00:13 <fog> https://pastebin.com/raw/ZFwNVXps
01:00:14 <MarcelineVQ> koz_: you writing intersperse?
01:00:15 <asheshambasta> it also works for `cabal new-repl lib:libname`
01:00:20 <fog> cant get that to work^
01:00:25 <dibblego> np
01:00:34 <MarcelineVQ> oop, I didn't look at the sig well enough :>
01:00:41 <koz_> MarcelineVQ: Not _quite_, lol.
01:00:58 <MarcelineVQ> tho   mconcat . intersperse
01:01:07 * hackage nom 0.1.0.0 - Name-binding & alpha-equivalence  https://hackage.haskell.org/package/nom-0.1.0.0 (gabbay)
01:01:11 <koz_> intersperse is defined for Vector?
01:01:16 <MarcelineVQ> idk :>
01:01:23 <koz_> Not as far as I can tell. :P
01:01:52 <fog> do i have to use Dict or something?
01:02:16 <MarcelineVQ> bytestring has it so I just assume other memory-block libs would
01:02:18 <fog> like, to provide an "environment" in which the constraint is satisfied?
01:03:20 <koz_> I guess explicit recursion it is, sadface.
01:03:37 <fog> im trying to write a "proof" that an operation preserves a constraint
01:03:49 <c_wraith> koz_: (bad advice) you could use fix instead!
01:03:54 <koz_> c_wraith: LOL
01:04:08 <koz_> I guess a _very_ literalist interpretation of what I wrote would lead to such an answer.
01:04:26 <fog> i guess maybe something like "entails" could do, but im not really sure
01:04:48 <fog> does anyone know how to use the Constraints library, or something similar for this? https://pastebin.com/raw/ZFwNVXps
01:05:17 <c_wraith> there are cases where fix actually can result in moderately cleaner code.  You're not describing one of them :)
01:07:52 <fog> ContainsEven a, is kind of like a Dict
01:08:39 <fog> so maybe i need to add the `Even a' constraint... but that still doesnt allow the `Even b' to be determined, even though it should...
01:10:04 <lortabac> fog: why are you using lists to represent nats?
01:10:54 <c_wraith> koz_: actually,  \x -> V.foldr (\y r -> y <> x <> r) mempty
01:11:04 <fog> argh crap, my Defunctionalise is totally wrong
01:11:06 <fog> brb
01:11:30 <koz_> Will that work correctly for a singleton vector?
01:11:32 <fog> lortabac: several reasons, its better
01:11:44 <fog> can recurse on them for eg
01:11:53 <fog> and (+) becomes (++)
01:12:13 <fog> tail recursion ftw
01:12:28 <c_wraith> Oh, I suppose not.  But that just needs one special case, not explicit recursion
01:12:49 <c_wraith> though if you're doing that, there's a better approach
01:12:58 <koz_> Which is?
01:13:42 <lortabac> fog: you can recurse on data Nat = Z | S Nat too
01:14:49 <c_wraith> koz_: \x xs -> if null xs then mempty else V.foldr1 (\y r -> y <> x <> r) xs
01:15:07 <koz_> Ah yeah, that'd do it.
01:15:09 <koz_> Thanks!
01:16:05 <lortabac> fog: and by using a more standard representation you can rely on plenty of existing libraries/tutorials
01:16:11 <fog> bah
01:16:19 <fog> i cant get this to work at all
01:17:22 <lortabac> fog: regarding defunctionalization, have you read this? https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
01:17:41 <fog> lortabac: https://pastebin.com/raw/uC4R1rMQ
01:18:06 <fog> er yeah, i was trying to cheat, i dont think there is any way to determine the defunctionalisation symbol from the type family itself
01:18:20 <fog> thats my normal Nat implementation ^
01:19:07 <fog> oh, thats not going to work without this;
01:19:07 <fog> https://pastebin.com/raw/4CLGhL43
01:19:22 <fog> which coincidentally is defunctionalisation done slightly more properly
01:19:36 <fog> still, no getting round the bug in the first paste
01:19:37 * hackage mmsyn7s 0.7.0.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.7.0.0 (OleksandrZhabenko)
01:19:49 <fog> i lost that, where is it...
01:19:55 <fog> here; https://pastebin.com/raw/ZFwNVXps
01:21:37 * hackage mmsyn7ukr 0.16.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.16.0.0 (OleksandrZhabenko)
01:31:57 <fog> oh wow, you can get it to work using a "placeholder"
01:32:05 <fog> still cant provide the proof though...
01:32:32 <fog> https://pastebin.com/raw/71xdEUuM
01:32:50 <fog> you cant pass the type family
01:32:57 <fog> so you just apply it to some placeholder
01:33:05 <fog> and unwrap this in the "defunctionalise" class
01:33:37 * hackage mmsyn7l 0.7.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.7.0.0 (OleksandrZhabenko)
01:34:35 <fog> any ideas about how to get it to determine that it can use the instance?
01:34:38 * hackage mmsyn7h 0.7.7.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.7.0 (OleksandrZhabenko)
01:34:38 <fog> type instance Even (f a) = (PreservesEvenness (Defunctionalise (f (Placeholder Nat))),Even a)
01:37:09 <fog> basically (Even a,PreservesEvenness f,Functionalise f a ~ b) should equate to Even b
01:42:13 <fog> (Even (TimesTwo (Succ Zero))) evaluates to () :: Constraint fine
01:42:26 <fog> so all the machinery is working
01:42:36 <fog> i just dont know how to do the entailsment thing
01:43:35 <fog> (that test shows that TimesTwo successfully "preserves evenness") 
01:44:39 <fog> argh! no it doesnt, it just timses it by 2 and uses the PlusTwo instance to recurse down!
01:44:55 <fog> otherwise it would have been preserving the evenness of 1...
01:44:58 <fog> :/
01:46:07 * hackage dsp 0.2.5.1 - Haskell Digital Signal Processing  https://hackage.haskell.org/package/dsp-0.2.5.1 (HenningThielemann)
01:47:37 * hackage vector-doublezip 0.2.0.0 - Some special functions to work with Vector (with zip).  https://hackage.haskell.org/package/vector-doublezip-0.2.0.0 (OleksandrZhabenko)
01:49:07 * hackage dobutokO2 0.42.0.0 - Helps to create experimental music from a file (or its part) and a Ukrainian text.  https://hackage.haskell.org/package/dobutokO2-0.42.0.0 (OleksandrZhabenko)
01:49:09 <fog> hmm, now i cant get it to get round the overlap of the Even instances
01:49:41 <fog> i want it to match on TimesTwo, when that is applied to something, before actually timsing it by two and then matching on Succ
01:50:20 <fog> are there any tricks with overlapping type families?
01:50:37 * hackage mega-sdist 0.4.1.0 - Handles uploading to Hackage from mega repos  https://hackage.haskell.org/package/mega-sdist-0.4.1.0 (MichaelSnoyman)
01:51:37 * hackage pantry 0.5.1.1 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.1.1 (MichaelSnoyman)
01:54:43 <fog> i always forget you have to use Or to branch the type families
01:55:07 * hackage dobutokO3 0.2.0.0 - Helps to create more complex experimental music from a file (especially timbre).  https://hackage.haskell.org/package/dobutokO3-0.2.0.0 (OleksandrZhabenko)
01:56:06 * hackage dobutokO4 0.7.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.7.0.0 (OleksandrZhabenko)
01:59:44 <olligobber> I can understand what `data Void = Void Void' does, but what does `newtype Void = Void Void' do?
01:59:54 <olligobber> > newtype Void = Void Void
01:59:56 <lambdabot>  <hint>:1:1: error: parse error on input ‘newtype’
02:00:47 <olligobber> like, how much memory is allocated for values of type Void in the newtype case?
02:00:58 <olligobber> it seems like a circular definition
02:01:42 <boxscape> % newtype Void = Void Void deriving Show
02:01:42 <yahb> boxscape: 
02:01:45 <boxscape> % undefined :: Void
02:01:51 <yahb> boxscape: Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void (Void
02:02:14 <olligobber> oh that's fun
02:03:32 <boxscape> not actually sure how memory allocation works for it though
02:05:01 <fog> ok here!
02:05:02 <fog> https://pastebin.com/raw/Z60Sq6Nt
02:05:22 <fog> it all works now, except the bug
02:06:06 <boxscape> olligobber I'm guessing values of that type will always be an unevaluated closure, so take as much memory as one of those?
02:08:36 <olligobber> that makes sense
02:12:28 <fog> hmm, that "or hack" for overlapping type families is a bit strange
02:12:37 <fog> it can use either branch!
02:12:44 <fog> totally redundant.. 
02:13:07 <fog> so i dont know how im supposed to use the fact that something "preserves evennness" in a proof
02:13:13 <fog> its supposed to be for runtime values
02:13:23 <fog> where because they are not known at compile time
02:13:47 <fog> they are supposed to just be produced by something that "prooves" it always will satisfy the constraint
02:13:55 <fog> and im trying to figure out how to write this
02:15:14 <fog> like, one of the branches is, recurse on the value - which it cant do on these runtime values
02:15:39 <fog> and the other branch, just checks that the input and function combine to produce something even, by the provided proof
02:17:34 <fog> i think i might have to ask again later
02:17:44 <fog> make a cleaner presentation of it
02:22:07 * hackage dobutokO3 0.2.1.0 - Helps to create more complex experimental music from a file (especially timbre).  https://hackage.haskell.org/package/dobutokO3-0.2.1.0 (OleksandrZhabenko)
02:23:02 <boxscape> fog I found this, which I'm not sure will help you, but I thought might be interesting regardless https://gist.github.com/Icelandjack/5afdaa32f41adf3204ef9025d9da2a70#github-or-and-for-constraints
02:31:58 <typetetris> Hi there! How can I render amounts of money localized? (separator for decimals, separator for thousands, etc ...)
02:32:58 <ph88^> how does the "normal" -p -P -pa options of profiling compare to the eventlog profiling ? does it yield different information? is one mechanism superior to the other one ??
02:35:28 <srk> not quite sure about the differences but eventlog allows for traceEvent and co https://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html#g:2
02:38:06 * hackage haskoin-store-data 0.33.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.33.0 (jprupp)
02:39:07 * hackage haskoin-store 0.33.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.33.0 (jprupp)
02:43:24 <ph88^> srk, ye i saw that too. Sounded like eventlog could do "more" .. but not sure
02:44:07 * hackage haskoin-store-data 0.33.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.33.1 (jprupp)
02:45:07 * hackage lentil 1.3.2.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.3.2.0 (fffaaa)
02:45:08 * hackage haskoin-store 0.33.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.33.1 (jprupp)
02:50:06 * hackage IPv6Addr 1.1.5 - Library to deal with IPv6 address text representations.  https://hackage.haskell.org/package/IPv6Addr-1.1.5 (MichelBoucey)
02:51:07 * hackage numeric-prelude 0.4.3.2, pathtype 0.8.1.1 (HenningThielemann): https://qbin.io/cj-granny-ghmn
02:55:37 * hackage quickcheck-transformer 0.3.1.1 - A GenT monad transformer for QuickCheck library.  https://hackage.haskell.org/package/quickcheck-transformer-0.3.1.1 (HenningThielemann)
03:02:24 <fog> boxscape: thanks
03:09:14 <fog> i stripped back all the unnecessary code, now its easier to read; https://pastebin.com/raw/3qmYegvm
03:11:03 <fog> i guess it cant see that defunctionalise and functionalise are inverses...
03:14:36 <fog> is there something like undefined at type level?
03:14:49 <fog> i cant write polykinded; data Undefined :: k
03:14:55 <fog> because datatypes must have kind *
03:15:37 * hackage storablevector 0.2.13.1 - Fast, packed, strict storable arrays with a list interface like ByteString  https://hackage.haskell.org/package/storablevector-0.2.13.1 (HenningThielemann)
03:16:38 <boxscape> fog https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Exts.html#t:Any
03:16:59 <fog> thanks
03:17:07 <fog> i found this
03:17:08 <fog> https://stackoverflow.com/questions/9036554/undefined-at-the-type-level
03:17:29 <fog> it says i *can* write datatypes that are not kind *
03:17:54 <fog> boxscape
03:17:59 <fog> it cant be a type family
03:18:10 <fog> i need to match on it in an associated type
03:18:36 <fog> Illegal type synonym family application
03:21:29 <fog> instance Functionalised (f Any) where
03:22:34 <fog> ah awesome, i can shift it into an equality constraint
03:22:59 <ulidtko> hey, any1 can help me interpret all 4 cores idling in "GC waiting" state for *20ms* ? http://deaddrop.ftp.sh/Kj11IQtauK1F.png
03:24:10 <ulidtko> i've already read: the Simon Marlow paper which describes the GC, the relevant section of GHC User Guide, the +RTS -help output
03:25:02 <ulidtko> there isn't much on google about GHC GC (or I'm bad at ddg.co'ing)
03:26:36 <ulidtko> like, where do I even continue digging this
03:26:44 <ulidtko> gdb?.. lol
03:32:22 <Ariakenom> ulidtko: you can try asking in #ghc too
03:33:04 <ulidtko> yea, this is definitely about GHC-specific RTS
03:33:32 <ulidtko> I've tried posting on r/Haskell -- but it was insta-removed haha
03:33:41 <Ariakenom> really?
03:34:00 <fog> but i cant match on;
03:34:00 <fog> class (forall g. (f ~ g Any)) => Functionalised f where
03:34:05 <ulidtko> yeah Ariakenom 
03:34:06 <ulidtko> Sorry, this post has been removed by the moderators of r/haskell.
03:34:07 <ulidtko> Moderators remove posts from feeds for a variety of reasons, including keeping communities safe, civil, and true to their purpose.
03:34:17 <ulidtko> like, in 0 seconds (bots i guess)
03:38:39 <fog> ok, this is as close as i can get it
03:38:40 <fog> https://pastebin.com/raw/RCUK8GwS
03:41:21 <fog> the constraint of mapEven basically just states that the instance demanded by Even is satisfied
03:41:25 <fog> but it does not compile
03:41:30 <fog> ikd why
03:50:49 <fog> but yeah, imagine redit with no moderators - it would be madness - there would be killing in the streets!!
03:50:54 <fog>  instead of just the "officially permissible maiming" from pepper spray...
03:54:26 <ulidtko> yea, i'm actually pleased my post was banned!
03:54:31 <ulidtko> weird feeling
04:31:38 <kuribas> it seems quite tedious in swagger-servant to use lenses to add documentation.
04:32:15 <kuribas> Wouldn't it be easier if you have two versions, one manually maintained, and one generated?  Then you merge the generated changes with the manual one.
04:32:33 <kuribas> So you can write the documentation in any swagger editor.
04:32:45 <kuribas> but still keep it up to date with the servant API.
04:49:04 <freeman42x[m]> how can I pattern match to get the 1st, 2nd, ignore the 3rd and get rest of list? [m,l,_,xs]=lines s is obviously wrong
04:50:15 <boxscape> freeman42x[m] (m:l:_:xs)
04:56:25 <stefan-__> kuribas, there is https://github.com/WindomZ/swagger-merger which can merge multiple swagger files
04:59:10 <kuribas> stefan-__: nice.  I just hope it's flexible enough to support my proposed workflow.
04:59:35 <kuribas> Like, it needs to take documentation from the second swagger, but endpoints and parameters from the first
05:03:25 <lortabac> kuribas: for simple descriptions, you can use the Description combinator
05:13:50 <Guest2322> hi is it possible to unpack a list e.g. but doesnt work:  (var1, var2, var3) = words "1 2 3"
05:14:09 <boxscape> Guest20621 [var1, var2, var3]
05:14:32 <Guest2322> boxscape, awesome, thank you!
05:14:39 <boxscape> np
05:17:09 <boxscape> (whoops I pinged the wrong person)
05:34:35 <freeman42x[m]> @karma+ boxscape thank you
05:34:35 <lambdabot> boxscape's karma raised to 5.
06:31:36 * hackage massiv-io 0.3.0.1 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.3.0.1 (lehins)
06:35:24 <pie_> whelp https://www.python.org/dev/peps/pep-0622/ python pattern matching. hm.
06:36:51 <pie_> or, wlel, i dont actually know what the status of this is
06:37:06 <boxscape> java is also getting pattern matching https://openjdk.java.net/jeps/305
06:37:51 <boxscape> actually this is a better link https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html
06:40:47 <hseg> hi. i'm using tasty - is it _supposed_ to give up on a group of tests after the first failure?
06:41:09 <hseg> hrm. and now it tries all the tests
06:41:27 <hseg> have no idea what i changed, but it worked
07:04:08 * hackage tidal 1.6.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.6.1 (AlexMcLean)
07:13:37 * hackage exigo-schema 0.2.0.0 - database schema for exigo marking/assessment tools  https://hackage.haskell.org/package/exigo-schema-0.2.0.0 (phlummox)
07:37:28 <ph88^> what does .\ mean in  .prof output ?  i have MAIN.MAIN  Main.main and  Main.main.\  and Main.randomElem  and Main.randomElem.\
07:39:46 <ezzieyguywuf> I'm a little confused here: https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md#do-you-even-lift, specifically the line `input <- liftIOT.getLine`. What is the type of `input`? Is it IO Eithere e a? if so, how is it used in the following line to pass to `getDomain :: Text -> Either LoginError Text`?
07:40:44 <boxscape> ph88^ guessing, but could it be a lambda/closure in main and randomElem?
07:41:24 <merijn> ezzieyguywuf: So liftIO turns "T.getLine :: IO Text" into "EitherIO e Text"
07:41:42 <merijn> ezzieyguywuf: And then we're back into regular monad territory, where the Monad is "EitherIO e"
07:42:13 <merijn> ezzieyguywuf: So, we remember that "do { x <- y; f x }" is just "y >>= \x -> f x"
07:42:22 <merijn> :t (>>=)
07:42:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:42:46 <merijn> So then (with 'm' = 'EitherIO e') we get that 'input :: Text'
07:44:18 <kqr> ezzieyguywuf, The type of `liftIO T.getLine` is `EitherIO e Text`, and then when it's bound with `<-` in a `do` block, it will unwrap the monad and assign the plain `Text` value (or break out and return the failure `e` case – but that's not a possible return value in this case)
07:45:16 <ezzieyguywuf> I think the part that trips me up is that EitherIO (like Either) has kind * -> * -> *, but Monad must be * -> *, so I have to keep in mind that the 'm' = "EitherIO e", just like merijn said
07:45:46 <ph88^> boxscape, ah yes that could definitely be the case
07:46:13 <ph88^> boxscape, do you think i should add a cost centre annotation to it to make the name clear ?
07:46:14 <ezzieyguywuf> merijn: I still don't see how `input :: Text`, even subbing in `EitherIO e` for "m"
07:46:36 <ezzieyguywuf> hrm, h/o, let me squint my eyes at it for a sec
07:47:09 <ezzieyguywuf> ah, ok, b/c `liftIO T.getLine :: EitherIO e Text`
07:47:18 <boxscape> ph88^ i imagine that depends on whether it would be useful to you to have a clearer name for it? To be honest it's been a while since I've needed to do anything related to profiling in Haskell so you probably know that better than me
07:49:04 <merijn> ezzieyguywuf: Yeah
07:49:35 <ezzieyguywuf> whoot, now it makes sense, thanks merijn and kqr 
07:49:43 <ph88^> boxscape, i hardly did anything with it as well .. and it's been 2 years ago
07:50:32 <ph88^> guys, i have this single function which take up nearly 100% of my program time  https://pastebin.com/rjGMhBHd  the first part before the >>= takes about 60% and the lambda about 40%  ... what's going on here ??
07:51:53 <ezzieyguywuf> how long is the list
07:51:58 <ph88^> https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC.html#v:uniformR 
07:52:02 <ezzieyguywuf> pretty sure length has to traverse the entire list
07:52:21 <ph88^> hum ... hundreds of elements i think
07:52:58 <ph88^> 289 elems
07:53:54 <ezzieyguywuf> when you say 60% of your program time, is there like a ton of other stuff your prog is doing? is it seconds? milliseconds? microseconds?
07:54:03 <ezzieyguywuf> i.e., is now the appropriate time to optimize this function
07:54:12 <ph88^> i think there is also another list being put in there, this list has 187960 elements of type Bytestring
07:54:22 <boxscape>  ph88^: see if "let bounds = (0, length lst - 1) in uniformR bounds gen >>= \idx -> pure $ lst !! idx" makes any difference?
07:54:54 <boxscape> actually maybe I'm confused about what this does
07:55:45 <boxscape> probably shouldn't actually matter if you do that or not
07:55:50 <ph88^> ezzieyguywuf, yes it's about a minute at the moment ... but it scales with a parameter to the program. I think the main point is the percentage of time over the total execution time
07:56:50 <ph88^> Maybe instead of a list of Bytestring i could use a Vector of Bytestring ?? i mean 187960 elems does sound a bit long, if i need to do so many pointer derefs
08:00:34 <merijn> ph88^: That's only ~3 MB worth of pointers :p
08:01:10 <ph88^> merijn, i'm just grasping on what the issue could be :/ do you have any idea ?
08:09:06 <merijn> I didn't actually see the original question xD
08:09:34 <merijn> oh, off
08:09:45 <merijn> that's gonna perform terribly for large sizes
08:09:57 <merijn> ph88^: Remember that !! is linear in time to access
08:10:47 <merijn> ph88^: So using a vector will cost you about the same amount of memory, but it should be *much* faster
08:13:16 <merijn> I mean, a boxed array of 187k elements is just like a few MB at most, so that's perfectly doable
08:15:56 <ph88^> thank you merijn i will try vector now
08:16:07 <gentauro> `stack` (which is the best thing that ever happened to the Haskell ecosystem) is not mentioned? http://dev.stephendiehl.com/new_decade.pdf
08:16:10 <gentauro> :(
08:16:28 <merijn> That is a rather personal opinion
08:16:42 <gentauro> it is and it's shared by many
08:16:50 <ph88^> merijn, i got a list because i was using Bytestring.lines  which gives a list. Should i use the Vector fromList method or should i write my own splitting function for Bytestring directly into Vector ?
08:17:02 <merijn> I actually consider it one of the worst. v2-build was already started before stack, so I'd rather all that engineering effort had gone into cabal-install and GHC instead
08:17:25 <gentauro> merijn: `stack` pushed `cabal` to be `usable` for the masses
08:17:27 <merijn> ph88^: I'd use fromList from now
08:17:38 <ph88^> well there is still the package set with stack right
08:17:56 <merijn> gentauro: You say, that but work on v2-build, as I said, already started before work on stack started
08:18:35 <gentauro> merijn: you `hack` on the `cabal` project?
08:18:46 <ph88^> merijn, how do i know if it makes sense to go with Vector.Unboxed in this case ?
08:19:02 <merijn> ph88^: I don't think you can have an unboxed bytestring
08:19:11 <ph88^> ok
08:19:27 <ph88^> ah i understand Unboxed now :))
08:20:13 <ph88^> merijn, i see here that fromList is O(n) https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html#v:fromList  does it not fuse directly into the  line yielding function from Bytestring ??
08:20:22 <merijn> ph88^: It should
08:20:26 <gentauro> OK, I just become a bit of fan of Stephen Diehl -> https://www.stephendiehl.com/pages/hire.html
08:20:28 <merijn> ph88^: But even O(n) is fine
08:20:29 <gentauro> xD
08:20:40 <merijn> ph88^: Since you're going to index into it very often
08:20:45 <ph88^> i refer to this function by the way  https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Char8.html#v:lines 
08:21:02 <ph88^> merijn, true that
08:21:07 <ph88^> thanks for the help
08:27:07 * hackage climb 0.3.3 - Building blocks for a GHCi-like REPL with colon-commands  https://hackage.haskell.org/package/climb-0.3.3 (ejconlon)
08:28:47 <catern> basic naive Haskell question: so if I have an arbitrary opaque IO Int value, if I run it twice I can easily get different results through side effects on the external world (changing a file, say); is there any way that an IO Int might have side-effects "internally" inside the runtime? for example, could the IO Int value, say, have closed over a reference to a mutable address and increment it each time it gets run?
08:30:54 <Ariakenom> catern, yes. thats a good example too
08:31:33 <ph88^> how can i make a function like https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:cycle for Vector ??
08:32:16 <ph88^> after cycle i use take ... so it won't be an infinite vector
08:32:30 <ph88^> so actually i need cycle and take for Vector
08:32:43 <EvanR> yeah IO is kind of badly named. It can do many magical things other than I/O
08:33:15 <catern> Ariakenom: oh? closing over a reference to a mutable address is possible? what's the API for allocating one? (I was just guessing blindly)
08:33:28 <EvanR> newIORef
08:34:32 <EvanR> http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-IORef.html
08:35:17 <EvanR> closing over stuff like that is a good way to make object oriented programming like constructs, private resources
08:36:11 <boxscape> % do {x <- newIORef 4; let {rx = readIORef x}; modifyIORef x (+4); x' <- rx; modifyIORef x (*2); x'' <- rx; pure (x', x'')} -- quick example
08:36:11 <yahb> boxscape: (8,16)
08:37:32 <EvanR> javascript eat your heart out
08:37:51 <merijn> catern: Yes, there are multiple different types of mutable variables
08:38:10 <merijn> catern: IORef, MVar, TVar (for transactional memory with atomic commits!)
08:38:30 <merijn> catern: mutable arrays/vectors too
08:39:01 <EvanR> let catern unlock the high level powerups in the course of play!
08:39:17 <catern> got it, makes sense. the ultimate motivation for my question is effect systems - some people are concerned about preventing closing over effects and getting back values that can just perform arbitrary effects. but it occurred to me that effect systems in Haskell all reduce to IO anyway, so don't they (in some sense, ultimately) have the same problem? and that point is a little more persuasive if you're able to close over mutable
08:39:17 <catern> variables rather than just do IO
08:39:40 <Cale> They don't all just reduce to IO
08:39:48 <merijn> catern: Actually, you have restricted mutation without IO too :)
08:40:07 <Cale> Effect systems usually describe the effects in an abstract way that you can write different interpreters for.
08:40:21 <merijn> catern: The ST monad lets you have/use mutable variables without needing IO
08:40:50 <merijn> catern: The main distinction being that there's no safe function "IO a -> a", but there *is* a safe function "ST a -> a" (slightly simplified type)
08:41:06 <catern> Cale: yes, but you can close over those interpreters and bundle it up into an IO blob that erases the effect information you previously had
08:41:08 <Cale> and yeah, what can be expressed in any given monad will be different -- you can define monads in terms of IO which provide far less functionality
08:41:14 <Cale> Sure
08:41:30 <Cale> Ultimately, your finished program will be such a blob anyway
08:41:55 <merijn> catern: Since pure function (i.e. no IO/randomness) will still be deterministic if they use mutation internally, so you only need to make sure the internal mutation isn't visible externally, which is what ST accomplishes
08:41:56 <Cale> Eventually, you recover all the permissions to do stuff as you go up the hierarchical structure of your program
08:46:50 <ph88^> is there any way i can reserve space for a vector upfront so that it doesn't need to be reallocated when the size grows ?
08:47:57 <ph88^> similar to C++ http://www.cplusplus.com/reference/vector/vector/reserve/ 
08:49:04 <glguy> ph88^: What vector are you using that can grow?
08:49:20 <ph88^> Vector Bytestring
08:49:46 <merijn> ph88^: Yes
08:50:17 <__monty__> Wouldn't that be a Vector of pointers to ByteStrings?
08:50:22 <merijn> ph88^: Like create/generate/iterate
08:50:57 <glguy> ph88^: Vector is immutable, it doesn't grow. You create it once with the final size and values
08:53:01 <ja> maybe it would make sense to have a giant mutable bytestring and then keep track of where the internal indices begin and start? but still keep the underlying storage as a giant bytestring
08:55:25 <ph88^> ja, good point .. maybe it already works by that by default
09:05:37 * hackage hedgehog-fakedata 0.0.1.3 - Use 'fakedata' with 'hedgehog'  https://hackage.haskell.org/package/hedgehog-fakedata-0.0.1.3 (parsonsmatt)
09:06:01 <ph88^> why is there no type class to implement so a vector can also be pattern matched on ??
09:07:56 <Cale> hm?
09:08:27 <Cale> I don't think a type class would help with pattern matching
09:08:35 <Cale> A pattern synonym for a view pattern might
09:08:56 <Cale> Though usually you don't want to pattern match on a vector, since the point of using a vector in the first place was that you wanted to access it randomly
09:09:19 <Cale> It might have been better to use a list if you were going to access it as a list.
09:09:59 <boxscape> aren't pattern synonyms and view patterns rather independent from each other?
09:10:04 <boxscape> Or can they usefully be used together?
09:10:09 <Cale> Well, you'd use them together here
09:10:17 <boxscape> hm, okay
09:10:31 <Cale> In order to define a pattern which decomposed the vector into its head and tail, for example
09:24:55 <ph88^> Cale, thanks i will change that one function back to a list
09:27:28 <ph88^> i have this  import qualified Data.Vector as V ((!))   when using  V.!   i get  error: parse error on input ‘V.!’   how should i use this function qualified ?
09:27:52 <boxscape> vector V.! index
09:28:23 <ph88^> oh it's still infix ..
09:28:33 <boxscape> yeah it's a bit counterintuitive
09:30:20 <ph88^> LOL program runs from 25 seconds (for 2 files) to 0.1 second just by changing List to Vector 
09:30:22 <ph88^> hurray !#
09:30:36 <boxscape> nice
09:41:41 <sm[m]> \o/
09:43:49 <exarkun_> are commonly available/used stack templates enumerable?  `stack templates` doesn't really say much, nor does the wiki page it references.
09:43:58 <exarkun_> and I'm not smart enough to use rio
09:44:07 * hackage birch-beer 0.3.1.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.3.1.0 (GregorySchwartz)
09:45:16 <sm[m]> exarkun_: less than they used to be.. they have moved to some github repo
09:45:19 <thblt> I just noticed that ghc is perfectly happy with the type declaration `data Something`.  No equal sign, no constructors, nothing.  I don't have EmptyDataDecls enabled (at least not explicitely, maybe it's a default?).  What's the point of such a definition? 
09:45:30 <thblt> That's ghc 8.8.3
09:45:41 <sm[m]> https://github.com/commercialhaskell/stack-templates probably
09:45:57 <exarkun_> sm[m]: thanks, that helps a lot
09:46:00 <boxscape> thblt it's enabled by default in Haskell2010, yes
09:46:09 <thblt> boxscape: thanks!
09:46:16 <boxscape> thblt the only point I'm familiar with is for proofs, where it represents falsity
09:46:38 <boxscape> thblt i.e. the type P is a proposition that P is provable, and P -> Void represents that Not P is provable
09:47:08 <boxscape> (read "given a proof for P, I can give you a proof for false", which implies that there can be no proof for P)
09:48:01 <thblt> Thanks again 
09:48:17 <thblt> I hadn't assumed it could just be the extension being enabled by default.
09:48:32 <sm[m]> exarkun_: I see more info at https://docs.haskellstack.org/en/stable/GUIDE/#templates
09:49:38 <boxscape> thblt here you can see all the extensions specifically enabled by Haskell2010 https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-Haskell2010
09:51:07 <exarkun_> sm[m]: ah.  I saw that but I guess I didn't fully appreciate all of the information, like the link to the github project.
09:52:18 <sm[m]> now I understand better how to make your own templates, or pull any repo's templates
09:55:17 <ph88^> so i know the problem i had before is that i was doing a lot of  !! and length  functions on the list. How could i profile this so that specifically the time goes allocated to these functions and not my own functions ??
09:57:32 <ChaiTRex> ph88^: I've never done it, but maybe with SCC: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand
10:01:22 <ph88^> maybe there is a way to add cost centres automatically for calls into library code ?
10:02:17 <remexre> what's the point of Control.Effect.NonDet if all its helpers don't depend on its effects, but rather on Alternative?
10:37:42 <exarkun_> are System.FileSystem, System.FileSystem.IO good?  Should I learn to use them?
10:38:07 * hackage dejafu 2.3.0.1 - A library for unit-testing concurrent programs.  https://hackage.haskell.org/package/dejafu-2.3.0.1 (barrucadu)
10:39:07 * hackage tasty-dejafu 2.0.0.5 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-2.0.0.5 (barrucadu)
10:45:26 <dsal> exarkun_: depends on what you're doing.  I seem to not be using them in places where I'd think I'd be doing that kind of thing, though.
10:54:56 <remexre> hm, for a closed type family, how do I promise "if (F a) reduces, Show (F a)"
10:55:56 <dminuoso> remexre: Show1 ?
10:56:01 <dminuoso> Or.. mmm
10:56:12 <dminuoso> I guess you cant, since instances need a type constructor
10:57:53 <dminuoso> remexre: I was in the same spot yesterday, and I was told by Cale that it's just not possible. :(
10:58:07 <remexre> ugh, that sucks
10:58:49 <dminuoso> remexre: I suppose you *could* wrap it up in a newtype, and then have a Show1 instance
10:59:28 <dminuoso> i.e. `newtype F' a = F (F a)` and then write an `instance Show1 F'` - this is just some random thought - no idea whether that will play out.
10:59:59 <dminuoso> It's possible you have to go through a GADT.
11:00:00 <remexre> won't quite work, since a is a DataKinds arg
11:00:52 <remexre> what would the GADT look like?
11:01:25 <Cale> Since the type family is closed, can't you just enumerate its image and write Show instances?
11:01:46 <remexre> sure, that's just... mildly inconvenient :P
11:01:52 <dminuoso> remexre: Cale has a thing for it in constraints-extras I think
11:01:58 <dminuoso> It's pure magic.
11:06:41 <remexre> heh, I'm inclined to agree, I'll need to sit down for a while to grok it
11:12:32 <Cale> constraints-extras gives you a way of expressing "Given a value x of type F a (where F is some GADT probably), I can show that C (G a) (or simply C a) holds, where C is some type class, and G is some other type function
11:13:00 <Cale> So it's like Pi but for constraints
11:13:12 <Cale> The way it's expressed in the library right now is more complicated than it ought to be
11:13:38 <exarkun_> dsal: System.Directory seems like the alternative but it's both lower level and not as low level as I seem to want
11:14:05 <Cale> I want to rework it to make Has (which is currently an awkward type synonym) the actual class you define instances of, and get rid of the ConstraintsFor type family
11:14:31 <Cale> (just make the instances constrained directly then)
11:15:15 <Cale> i.e. it could just be a class Has c f where has :: f a -> (c a => r) -> r
11:15:49 <Cale> Just haven't gotten around to reworking the template haskell to do that
11:17:29 <Cale> Has' c f g can still be defined in terms of Has and ComposeC, though I'm not absolutely certain that's been a 100% positive thing to have done. Maybe it would be better off a separate class of its own just because there'd be no risk of ComposeC showing up in type errors (which is less helpful than it should be)
11:17:55 <dsal> exarkun_: What are you wanting to do?
11:18:47 <exarkun_> dsal: I have a directory tree, I want to visit all the files and do some IO with them, collecting up some results as I go
11:19:10 <__monty__> Hmm, is anyone familiar with tzdata? I'm wondering why Data.Time.Zones.All from tz has a label for Etc__UTC but not UTC. Reading up on it it seems like the Etc/* names are only included for legacy reasons?
11:19:12 <dsal> I have a thing like that I'm using System.Directory.PathWalk for.
11:19:44 <exarkun_> ah, did not know about that
11:20:13 <exarkun_> seems kind of like what I want, yea
11:32:07 * hackage MonadRandom 0.5.2 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.5.2 (BrentYorgey)
11:46:21 <disconsis> Hey peeps
11:46:41 <disconsis> Is there any way to have stack store development dependencies
11:46:43 <disconsis> ?
11:46:48 <disconsis> Like ghcid, hlint...
11:47:49 <monochrom> I think they haven't gone that far.
11:47:50 <disconsis> Ideally so someone could get up an running with all dependencies with just a single stack command
11:47:59 <dsal> Sounds like you want nix
11:48:15 <disconsis> tbh I hadn't seen that before I encountered npm
11:48:27 <disconsis> Found it a pretty cool concept
11:49:12 <dsal> nix does the thing you want without being language specific, which is useful.  e.g., I have a haskell project that has an embedded elm project that also requires make.  It just does the right thing.
11:49:59 <disconsis> dsal: I have *no* clue what nix is, but from what I hear it sounds a bit too much for a normal machine that's sometimes used for dev
11:50:35 <disconsis> It's a full distro, isn't it?
11:50:49 <boxscape> nixos exists and is built on nix but nix the package manager is separate from it
11:50:50 <dsal> nixos is a distro.  nix is a tool you can install anywhere.  I've got it on this mac.
11:51:10 <disconsis> ahhhh
11:51:39 <disconsis> okay, so is it a layer on top of stack/cabal (for haskell), or does it replace them?
11:51:57 <dsal> It lets you have the 12 different versions of node you need for your 5 projects and all the specific and probably conflicting npms and haskell libraries and random tools.
11:52:00 <dsal> stack integrates with nix
11:52:09 <dsal> https://docs.haskellstack.org/en/stable/nix_integration/
11:52:17 <boxscape> afaik it is usually used with cabal, though it replaces some parts of it
11:52:54 <boxscape> it seems to me like stack is overkill when you're using nix
11:53:02 <disconsis> how much stuff does stack integrate with? god
11:53:20 <disconsis> boxscape: You could be right, but then I'd have to read the cabal docs
11:53:23 <dsal> I still haven't successfully moved a project off of stack.
11:54:10 <dsal> disconsis: I just have 'nix:\n  enable: true' in ~/.stack/config.yaml on my machines and then the right thing happens.
11:54:28 <dsal> Mostly.  I do have to tell projects to require zlib because it seems to be a transitive dependency of everything.
11:55:23 <disconsis> Is anyone else *truly* afraid of the cabal docs?
11:55:33 <disconsis> I seem to get lost every time I try to take the plunge
11:56:00 <dsal> It's almost like the name isn't a joke.
11:56:47 <int-e> . o O ( it started out harmlessly enough but then they teamed up with nix )
11:57:41 <sm[m]> disconsis: I get that feeling about the stack docs
11:59:28 <freeman42x[m]> how could I deduplicate this? \z->(sort$map toLower z)==(sort$map toLower w)
12:02:08 <Rembane> freeman42x[m]: Where does the w come from? 
12:02:15 <boxscape> \z -> liftA2 (==) ($ w) ($ z) (sort . map toLower)
12:02:29 <disconsis> sm[m]: I get what you're saying, but they're only half as bad (at worst) as cabal's
12:02:58 <disconsis> boxscape: I would take the duplicated version over that tbh :P
12:03:04 <boxscape> that's fair
12:03:06 <int-e> :t Data.Function.on
12:03:08 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:03:33 <boxscape> realistically I'd probably just use a let binding for (sort . map toLower)
12:03:42 <int-e> :t (==) `on` (sort . map toLower)
12:03:43 <lambdabot> [Char] -> [Char] -> Bool
12:03:48 <boxscape> or that
12:03:56 <freeman42x[m]> disconsis: haha, yeah, that version is also too complicated. There has to be a better way
12:04:13 <sm[m]> disconsis: ouch, then
12:04:44 <disconsis> int-e: the `on` version is really nice. I can never remember that function exists
12:05:39 <boxscape> :t (==) `on` sort . map toLower
12:05:41 <lambdabot> [Char] -> [Char] -> Bool
12:05:46 <boxscape> hey the fixities work out
12:09:17 <freeman42x[m]> @karma+ int-e thank you, that is brilliant, going to need that in the future a lot
12:09:17 <lambdabot> int-e's karma raised to 21.
12:09:51 * disconsis didn't know karma was a thing on irc
12:11:26 <freeman42x[m]> is it possible to rewrite this to be 1 elegant and readable 1 liner (without the where basically)? https://gist.github.com/razvan-flavius-panda/2d5bdd346a1e82a49a5c6ba02925829f
12:14:12 <int-e> freeman42x[m]: main = interact $ process . lines
12:15:13 <freeman42x[m]> int-e: I do not understand what you mean
12:17:47 <int-e> freeman42x[m]: then you can have process (_:w:ls) = ...  without a where clause
12:24:39 <dsal> freeman42x[m]: It'd be more elegant with a bit of space.
12:28:26 <maerwald> if you have (f . g $ x) where f inlines with zero arguments and g with 1 argument... will the $ prevent g from being inlined?
12:28:37 <p0a> Hello 
12:28:52 <p0a> Is there a tutorial about creating a simple database/records haskell program?
12:29:22 <p0a> demonstrating how to keep track of customers or cars models or something of that sort
12:30:22 <p0a> Preferably of incremental complexity, from a custom data type to sqlite or such
12:36:36 <freeman42x[m]> int-e: sorry, I do not understand what changes you suggested to my code
12:36:41 <monochrom> maerwald: I haven't tried/proved but: It's (f . g) $ (x), so . can be the 1st blocker. However, suppose . and $ are inlined, then that will expose further opportunities to inline f and g.
12:38:05 <kritzefitz> Is there some way to deduce `KnownNat (x GHC.TypeNats.* y)` from `(KnownNat x, KnownNat y)`? It doesn't seem to happen automatically.
12:38:23 <koz_> kritzefitz: Not built-in.
12:38:29 <koz_> You want to use the Clash plugins for that.
12:38:40 <koz_> (I think typelits-knownnat is what you want)
12:41:07 <monochrom> Dependent Haskell makes you realize how painstaking it must have been for Russell and Whitehead to write their Principia Mathematica. :)
12:41:07 <kritzefitz> koz, yes apparently that's what I want.
12:42:24 <koz_> kritzefitz: You might want typelits-natnormalize as well.
12:46:16 <dolio> You mean, because Principia Mathematica is written in a language that is terrible for formalizing mathematics, too?
12:47:01 <monochrom> That's an added hurdle. But starting from scratch is painstaking even in a suitable language.
12:48:40 <monochrom> There are so many theorems and algorithms that you have always taken for granted in the past, and now suddenly you realize "darn, this has to be spelled out too".
12:49:12 <Rembane> It's a very good source of inspiration for now papers
12:49:16 <hyiltiz> monochrom: thx for mentioning dependent haskell; i am reading the haskell wiki on it and am already excited to hear kinds and types are to be merged
12:49:34 <p0a> hyiltiz: in a newer version of Haskell?
12:49:39 <Rembane> hyiltiz: They are? When? 
12:49:48 <hyiltiz> no, in this proposal
12:50:10 <hyiltiz> "here is a chance that this bugfix will enter HEAD"
12:50:31 <p0a> not fair to call a proposal a bugfix 
12:50:47 <p0a> and anyway maintanance has a real cost
12:51:08 <hyiltiz> but i am guessing it may just just stay as a language ext., and yes, it is kinda weird they call it a bugfix lol
12:51:10 <L29Ah> is there some code that sees a GHC.Generics.Generic instance and flattens all those crazy hierarhic :*: and :+: that are produced into, say, a list?
12:52:00 <L29Ah> (a list of lists in fact)
12:55:26 <lally> Is there a reason why the type param isn't binding to its uses inside? https://gist.github.com/lally/e6b08651fcb0760de414ff058db373d2
12:57:55 <sm[m]> p0a: yes there is such a tutorial, and you will like it. Check out the video at ihp.digitallyinduced.com
12:58:11 <p0a> sm[m]: thank you 
13:00:45 <c_wraith> man, "hasochism" is accurate. I just used singletons for the first time, and it makes me long for the ability to just use a pi type
13:00:47 <monochrom> lally: I tried a simple "foo :: Query api -> Int" and it is the same error. Eventually I realized I should take "NB: ‘Query’ is a non-injective type family" seriously.
13:01:03 <p0a> Another question: Is there a tutorial on setting up emacs for haskell development?
13:02:08 <monochrom> You see, suppose there are 2 instances, "QueryResult X" and "QueryResult Y", and it so happens that "type Query X = ()", "type Query Y = ()" too.  Now the user uses "foo ()", is that X or Y?
13:02:18 <dminuoso> p0a: There's not much to it, really.
13:02:32 <dminuoso> p0a: Haskell mode with GHCi+compilation mode is extremely low effort with high gains
13:02:54 <dminuoso> *ghcid
13:03:08 <p0a> dminuoso: thank you, so I should look up `haskell mode' and `compilation mode' and configure them 
13:03:13 <dminuoso> p0a: https://github.com/ndmitchell/ghcid/blob/master/plugins/emacs/ghcid.el
13:03:14 <lally> monochrome: this is because it's only got the 2nd arg of `addContinue` or `setupWithLimit` to work with? 
13:03:19 <monochrom> Solution: add a "p api" parameter, e.g., "foo :: p api -> Query api -> Int".  User says either "foo (Proxy :: Proxy X) ()" or "foo (Proxy :: Proxy Y) ()".
13:03:29 <p0a> dminuoso: thank you 
13:03:42 <dminuoso> p0a: This is a sample how to integrate ghcid with compilation mode. Its using slack but making it use cabal is a very simple excercise in modifying a line or two.
13:04:05 <dminuoso> https://github.com/haskell/haskell-mode
13:04:06 <monochrom> Yes. See my foo example.
13:04:08 <lally> monochrom: Thanks.  That clears it up for me quite well.
13:04:39 <dminuoso> p0a: Note that Im not trying to sell oyu on this, but it's gives you very high bang for low buck. Other more "integrated solutions" exist, but they are more work and more error prone.
13:05:01 <p0a> dminuoso: sounds good enough to me 
13:07:07 * hackage arithmoi 0.11.0.1 - Efficient basic number-theoretic functions.  https://hackage.haskell.org/package/arithmoi-0.11.0.1 (Bodigrim)
13:11:38 * hackage haskoin-store-data 0.34.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.34.0 (jprupp)
13:12:02 <sm[m]> +1
13:12:37 * hackage haskoin-store 0.34.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.34.0 (jprupp)
13:27:44 <christian_oudard> So, cabal-install 3.2 has no sandboxes, but the documentation talks about them: https://cabal.readthedocs.io/en/3.2/installing-packages.html#sandboxes-basic-usage
13:28:16 <christian_oudard> I'm not the first to notice this, right?
13:35:07 * hackage aeson-with 0.1.0.1 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.0.1 (locallycompact)
13:50:37 * hackage stratosphere 0.55.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.55.0 (jdreaver)
13:59:03 <merijn> christian_oudard: Sandboxes are still in there, but only for v1 commands
13:59:15 <merijn> christian_oudard: That said, sandboxes are pretty much entirely obsolete
14:02:11 <christian_oudard> okay, I would expect the docs to say `cabal v1-sandbox init` instead of `cabal sandbox init`
14:03:16 <christian_oudard> and similarly for the other v1 documentation
14:04:06 <christian_oudard> where can I submit an issue to the cabal developers?
14:05:12 <christian_oudard> nvm found it: https://github.com/haskell/cabal/issues/6866
14:06:12 <merijn> the docs need love in general
14:08:20 <merijn> But as always, it's easy to say someone else should do something :)
14:08:24 <c_wraith> is GitHub still the correct location for cabal bugs?
14:08:47 <monochrom> There is that. But there is also the more sinister "it's already in a blog post".
14:08:48 <c_wraith> I would have thought it would move to gitlab with all the rest
14:09:14 <merijn> c_wraith: Yes
14:09:25 <merijn> c_wraith: Wait, it moved to gitlab?
14:09:27 <merijn> Since when?
14:09:37 <c_wraith> well, ghc and most core libraries did
14:09:52 <merijn> c_wraith: Only GHC boot libs, afaik
14:09:56 <c_wraith> I thought cabal would be part of that, but I could be wrong
14:10:04 <merijn> c_wraith: And GHC always had it's own clones of those
14:10:50 <monochrom> I think it's safe to believe that since https://hackage.haskell.org/package/cabal-install refers to github, it's still github.
14:11:54 <c_wraith> in other news. doing stuff with singletons has made me believe I should have used reflection (for this particular use case)
14:13:30 <monochrom> opportunity for pun :)
14:16:09 <lally> How do I indicate that any `ApiResult api` is also an instance of `ResultType`? https://gist.github.com/lally/43550a983ba305795c5088fae2c784ef
14:16:42 <lally> (and thanks in advance for any help, my type-axe is getting some good sharpening today!)
14:16:51 <merijn> c_wraith: Usually "doing stuff with singletons" makes me believe I should "stop doing stuff with singletons" ;)
14:17:19 <boxscape> lally `class ResultType api => ApiResult api`
14:17:44 <c_wraith> I mostly wanted to experiment because it was obvious how to do it with dependent types. I wanted so see where things were. things are still firmly in "hasochism"
14:17:51 <c_wraith> *wanted to
14:17:56 <lally> boxscale: thanks.  Is that in lieu of the 'type ApiResult api :: *', or after it?
14:18:16 <boxscape> lally it replaces `class ApiResult api`
14:18:40 <boxscape> Though I suppose following the naming in the gist it'd be `class ResultMeta api => ApiRequest api`
14:19:22 <lally> But it's not ApiRequest, it's ApiResult
14:19:30 <boxscape> ah, right, it's a different class
14:19:59 <boxscape> doesn't really change anything about what I said though
14:20:12 <monochrom> Where is ResultType defined?
14:21:03 <lally> ApiResult == the resultType of ResultMeta
14:21:34 <lally> This is over the Kubernetes api, so I have to look at the 'meta' property of the returned object to get its length and its 'continue' key
14:21:58 <fog> how do i get round this bug?
14:21:59 <fog> https://pastebin.com/raw/XaVHv1jY
14:22:22 <monochrom> I have a feeling that this is a very wrong design.
14:22:43 <fog> i can match on type-function application in a type family, but not on its defunctionalization symbol
14:23:38 <fog> monochrom: possibly 
14:24:16 <fog> but if there is a way to do something to this effect, it is an easier question to ask than the problem its trying to solve
14:24:37 * hackage bip32 0.2 - BIP-0032: Hierarchical Deterministic Wallets for Bitcoin and other cryptocurrencies  https://hackage.haskell.org/package/bip32-0.2 (RenzoCarbonara)
14:24:46 <monochrom> IIUC, ApiResult is a type family "but it's always an instance of ResultMeta". But how does the computer know which? At present there is zero relation between ResultMeta and ApiReques, you can't even play the "default implementation" card.
14:25:37 * hackage aeson-with 0.1.0.2 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.0.2 (locallycompact)
14:25:37 <fog> wait, how can a type family be an instance?
14:26:24 <fog> you can only make instances over symbols
14:26:55 <monochrom> I don't know Kubernetes, I can only judge the disparity between what you say you want and what classes and type families are meant to do, and deduce that you need a different design.
14:29:41 <fog> hrm, well ok. the idea is to prove that if some constraints are satisfied, that some others can be inferred. so that the type itself need not be available in order to make an instance for it, only that it certainly satisfies the required constraints, combined to give the constraint it cant instantiate, by only being available at runtime 
14:30:13 <lally> Fair enough. So my function decl is fun :: (ApiRequest req) => req -> (req -> IO (MimeResult (ApiResult req))) -> ... -> IO [(ApiResult req)].  I'd like to key on the first arg (req) and somehow enable operations on the (ApiResult req).
14:31:53 <fog> why not have a phantom defunctionalization symbol?
14:32:01 <lally> I don't know what that is
14:32:17 <monochrom> Opertions on ApiResult can simply be methods of ApiRequest.
14:32:32 <fog> well, instead of having a value, you wrap it in a datatype and have this take an extra parameter, that is the symbol for the type family
14:32:38 <lally> But I'd have to pass an unused 'api' param to key to the right type class, correct?
14:33:09 <monochrom> What api? Your only type variable here is req.
14:33:09 <fog> its like, you can store value level information in the datatype itself, and defunctionalised type level functions as type parameters to the datatype
14:34:14 <monochrom> I am taking "(ApiRequest req) => req -> (req -> IO (MimeResult (ApiResult req))) -> ... -> IO [(ApiResult req)]" seriously and literally. It contains no "api".
14:34:43 <lally> oh, sorry.  s/req/api/
14:35:29 <fog> whats this "keying to the right typeclass" ?
14:35:42 <monochrom> OK, (ApiRequest api) => api -> (api -> IO (MimeResult (ApiResult api))) -> ... -> IO [(ApiResult api)]
14:35:56 <fog> is that some kind of "flag" that allows the correct instance to be identified? 
14:36:07 * hackage path-extensions 0.1.0.0 - Enumeration of common filetype extensions for use with the path library.  https://hackage.haskell.org/package/path-extensions-0.1.0.0 (locallycompact)
14:36:11 <monochrom> Notice that you already have a term parameter of type api. So you're fine.
14:37:40 <lally> Ok, so I think what you're telling me is to pass 'api' as the first arg into functions like 'getLength', and move those functions under the same ApiResult typeclass, is that right?
14:38:29 <monochrom> getLength :: (ResultMeta t) => t -> Int is already doing fine.
14:39:37 * hackage within 0.1.0.1 - A value within another path.  https://hackage.haskell.org/package/within-0.1.0.1 (locallycompact)
14:40:01 <monochrom> I don't know why there is a "resultType" type var and there is a "api" type var and whether they should be the same type var.
14:40:13 <monochrom> Meaningful names don't work.
14:42:43 <fog> no its; class ResultMeta (ApiResult api) => ApiRequest api where
14:43:02 <fog> How do I indicate that any `ApiResult api` is also an instance of `ResultType`?
14:43:17 <koz_> What can I direct someone to if they wanna know about how to find, and then avoid, needless memory allocation in Haskell?
14:43:39 <fog> oops, where is ResultType? did you mean ResultMeta?
14:44:05 <lally> resultType is the type arg to the ResultMeta typeclass
14:44:33 <lally> api is an arg indicating the remote function called, resultType is the type of that function's result.
14:44:43 <lally> ResultMeta defines operations on the result.
14:45:05 <lally> Each remote function defines its own result type
14:45:14 <monochrom> That sounds like your class needs 2 params, not 1.
14:45:15 <lally> so ListPods results in PodList
14:45:28 <fog> ah, so if you want to use the type ApiResults, of class ApiRequest, in the constraint of the class ResultMeta, then it needs a superclass constraint along with the constraint satisfied by the associated type
14:46:03 <lally> superclass constraint?
14:46:33 <monochrom> I think it's time to draw some ER diagrams.
14:46:56 <fog> yes, anything that is ResultMeta needs to be ApiRequest, so it can use the associated type of ApiRequest, namely ApiResult
14:47:04 <monochrom> There is a reason the database people invented ER diagrams instead of relying on prose and meaningful names.
14:47:20 <c_wraith> koz_: your question last night made me think "this feels like a foldMap, but the Monoid instance needs dependent types". so I hacked it up with singletons. it works, for the cases where it can convert the type into a singleton. but wow, singletons are.. not pleasant to fix type errors with. https://gist.github.com/chowells79/1f2b74cd1b9a655d9f97db4
14:47:21 <c_wraith> d78fa1762
14:47:32 <c_wraith> shoot.  got chopped up. https://gist.github.com/chowells79/1f2b74cd1b9a655d9f97db4d78fa1762
14:47:34 <monochrom> If necessary I wouldn't even shy away from UML diagrams.
14:47:45 <koz_> c_wraith: Rofl. That's definitely 'much engineer, very design' territory. :P
14:47:48 <lally> monochrom: So 'class ApiRequest api resultType | api -> resultType where... getLength :: resultType -> Int'
14:48:12 <fog> class (ApiRequest api, ? (ApiResult api)) => ResultMeta  api where
14:48:17 <c_wraith> koz_: mostly figured it'd be amusing. it is, now that it's done 
14:48:57 <fog> these statements are contradictory; "resultType is the type arg to the ResultMeta typeclass" , "any `ApiResult api` is also an instance of `ResultType`"
14:49:31 <fog> you cant be an instance of a type arg
14:49:37 * hackage hlint 3.1.6 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.6 (NeilMitchell)
14:50:11 <lally> How so?  I have one line saying "class ResultMeta resultType where..."
14:50:47 <fog> resultType is the type arg, and ResultMeta is the thing you have instances of
14:50:56 <fog> you have instances of classes, not of their parameters 
14:51:06 <lally> And the second statement is one of external reality; that any definition of 'ApiResult api' I will ever make will also be an instance of ResultType.
14:51:25 <fog> there is no typeclass ResultType
14:51:38 <fog> you keep capitalising and then lowercasing the resultType... which is it?
14:51:57 <lally> Its lower-case.  Sorry.
14:52:05 <fog> right, then you cant have instances of it
14:52:21 <lally> Typeclass is called "ResultMeta"
14:52:28 <lally> 'class Resultmeta resultType where...'
14:52:29 <monochrom> What if you don't express that statement at all?
14:52:30 <fog> do you mean that it "should be the instance *of* something"
14:52:39 <monochrom> I don't think it would be a lost.
14:53:39 <fog> i think what your trying to say must be; "ApiResult has ResultType as a superclass"
14:53:41 <fog> is that right?
14:53:42 <lally> if I don't express it, then my 'fun' above won't be able to do use the 'ResultMeta' typeclass functions on the value returned from the remote function call.  The remote function call is typed via fun's 'api' parameter
14:54:02 <monochrom> fun can require two constraints.
14:54:05 <fog> sorry, ResultMeta as a superclass
14:54:59 <fog> you want the associated types of the ApiResult class to be available to the instances of the ResultMeta class ? 
14:55:36 <fog> class ApiResult x => ResultMeta x 
14:56:12 <lally> type (ResultMeta (ApiResult api)) => ApiResult api :: *
14:56:40 <fog> no, the constraint should go at the class head
14:56:49 <fog> not on the associated types
14:57:09 <lally> class (ResultMeta (ApiResult api)) => ApiRequest api where ... type ApiResult api :: *
14:57:28 <fog> that works
14:58:29 <lally> Is that legal Haskell?
14:58:39 <fog> yes
14:59:05 <fog> your constraining an associated type
15:00:22 <fog> so, its not that "an api which is an ApiRequest instance is also a ResultMeta instance" like i saidbefore, its actually;
15:00:29 <fog> "an api which is an ApiRequest instance has an associated type that is also a ResultMeta instance" 
15:00:54 <lally> wow, I didn't ever think that would work.
15:01:07 <lally> Thank you very much
15:01:18 <fog> no worries
15:01:19 <monochrom> For the record, I say no, and you know why if you draw out the ER diagram and see no subclassing relation. I still say the "ResultMeta (ApiResult api)" constraint belongs to fun.
15:02:36 <fog> but since you couldnt write that instance it might as well go as a constraint at the class head
15:03:05 <fog> i guess this kind of enforces that you have to write the associated types...
15:03:46 <_d0t> ohai! I'm looking for a tool to build a type graph. I.e. I wanna see in what other types a certain type is used. Any suggestions?
15:04:03 <fog> impossible
15:04:26 <fog> you would have to store the "scope"
15:04:52 <lally> Would one of the IDE tools (ghcid? intero?) give a 'references' list for a type?
15:05:03 <monochrom> No.
15:05:07 <_d0t> lally: ghcide doesn't seem to have this function
15:05:13 <lally> eww
15:05:19 <monochrom> I wouldn't say impossible but no one has written such a tool.
15:05:39 <_d0t> https://hackage.haskell.org/package/graphtype there is this but it's abandoned and doesn't build
15:05:59 <fog> if you store all the functions as symbols, and all the arguments in a HList, and have lookup references to this to apply the args to the symbols...
15:06:07 <monochrom> Ah, someone did. Oh well.
15:06:21 * ski . o O ( `inits "ghcide"' )
15:06:44 <fog> -- | Parses specified *.hs files and returns a list of all data declarations from them
15:06:55 <fog> from; https://hackage.haskell.org/package/graphtype-0.2.0/src/src/Parse.hs
15:06:56 <_d0t> fog: i'd say this would require building a module graph and working up the tree, accounting for import lists. Doesn't seem really impossible.
15:07:05 <monochrom> Yes ski it's quite more exciting than c/c++ and j/java/javascript, yeah? :)
15:07:32 <fog> you really want to parse the .hs files?
15:07:45 <fog> wouldnt you rather build an environment in haskell land 
15:08:13 <_d0t> fog: i don't want to do anything except to get a beautiful picture :)
15:08:26 <ski> hehe
15:08:42 <fog> well, you could parse the files - which seems less good
15:08:53 <c_wraith> wait, when it gets to just "GH", is that guitar hero?
15:08:54 <monochrom> Someone has to parse the files.
15:09:25 <fog> i mean, if you just have a datatype which is a scope, where all of the types being composed together is stored in a lookup tree
15:10:00 <_d0t> i'd say i use grep is there is no ready to use solution
15:10:00 <fog> then eg, you could add a type to the scope, by composing together the existing types, etc
15:10:16 <_d0t> not gonna implement this tool right now
15:10:26 <_d0t> although this is a nice idea for the future if i'm bored
15:10:35 <fog> well one way seems hacky, and the other is an awesome interface
15:10:59 <fog> rrg, im getting distracted. can anyone help with this bug? https://pastebin.com/raw/XaVHv1jY
15:11:40 <ski> > (map . (++)) `uncurry` (inits <$> splitAt 3 "ghcide")
15:11:42 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:13:00 <ski> > ("ghc" ++) `map` inits "ide"
15:13:02 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:14:02 <ChaiTRex> > drop 3 . inits $ "ghcide"
15:14:05 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:14:57 <ski> ew, `$'
15:15:08 <ski> ;)
15:16:12 <monochrom> > drop 3 . inits $ "ghcide"
15:16:14 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:16:18 <monochrom> err sorry
15:16:29 <boxscape> I predict we'll see "ghcidea" next
15:16:31 <monochrom> > drop 3.inits$"ghcide"
15:16:33 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:16:44 <monochrom> to show how little space you need
15:17:19 <boxscape> > drop 3(inits"ghcide")
15:17:20 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:17:27 <monochrom> yeah, that too
15:17:28 <dmwit> > (.)(3`drop`)inits"ghcide"
15:17:28 <fog> all programs shouls be shorter than their outputs...
15:17:31 <lambdabot>  ["ghc","ghci","ghcid","ghcide"]
15:17:33 <dmwit> Look ma, no spaces!
15:17:45 <monochrom> well done!
15:17:51 <dmwit> And no $ either, to appease ski. =)
15:17:56 <monochrom> :)
15:18:31 <fog> frugal ski
15:18:49 <dmwit> I believe a simple counting argument should suffice to show that it is not possible for all programs to be shorter than their outputs.
15:19:19 <boxscape> fog in a turing complete language, all programs are provably at most as long as their output :)  (*cough* up to a constant *cough*)
15:19:20 <fog> sounds like an old bolshevik astrerix character 
15:19:28 <dmwit> Ah. Apologies. The counting argument shows something else: it shows that it is not possible for all outputs to be produced by a program that is shorter than the output.
15:19:35 <ChaiTRex> Output can be zero long. Get a program shorter than that.
15:20:28 <fog> well you wouldnt need one...
15:20:28 * dmwit proposes the language H, the obvious restriction of HQ9X, which has the property that all programs are shorter than their outputs.
15:21:06 <fog> decoders only! 
15:21:13 <monochrom> What is HQ9X? Should I just google it?
15:21:20 <dmwit> It is a very small language:
15:21:31 <monochrom> I only got ham radio stuff
15:21:39 <fog> all programing languages should be shorter than the programs written in them
15:22:00 <dmwit> there are just four characters, and any sequence of characters is a valid program. H prints "Hello, world!". Q prints the program itself (quine). 9 prints the lyrics to 99 bottles of beer. X increments an accumulator.
15:22:32 <fog> sounds turing complete
15:22:35 <dmwit> It is designed for beginners to get off the ground as quickly as possible, you see? ^_^
15:23:01 <hyiltiz> boxscape: what is counted in "all programs"? Should extremelyLooooongVariableNames count as a single character symbol? What if a variable is deeply nested inside several layers of function that does nothing but to finally return the value of the said variable? In other words, are we only considering already simplified programs?
15:23:07 <ChaiTRex> X should somehow be NAND so that it can be Turing complete.
15:23:15 <boxscape> So HH prints "Hello, world!Hello, world!"?
15:23:18 <monochrom> What is th accumulator used for? It looks like write-only.
15:23:22 <dmwit> boxscape: Right!
15:23:25 <dmwit> monochrom: Right!
15:23:48 <monochrom> OK, I like H more.
15:23:49 <dmwit> (The direct answer is: the accumulator is used for declaring that you have written a program which increments the accumulator.)
15:23:55 <koz_> Any beam experts around? I'm writing runReturningOne, and my backend provides the equivalent of Vector (Header, Value). I have no idea how to write this method, since it wants back _one_ value, provided it's an instance of FromBackendRow.
15:24:00 <boxscape> hyiltiz sorry, I said that wrong - I meant to say, the shortest program that produces an output is provably [...]
15:24:20 <monochrom> haha
15:24:33 <hyiltiz> ah ok; i was coming up with all kinds of bad ways to write programs ;p
15:24:34 <koz_> There's no documentation for this anywhere.
15:24:37 <fog> wat happens if i pass all my source code through an autoencoder? does it get better?
15:25:07 <fog> what are the "features" at the bottleneck? are they the elementary functions?
15:25:09 <hyiltiz>  the shortest program that produces a *given* output is provably ...
15:25:30 <fog> like, can i find all the higher order functions by autoencoding all the code?
15:25:32 <boxscape> right,
15:26:56 <fog> what would that be? a "recompiler" ? 
15:27:17 <fog> like, kind of the opposite of compiling to core
15:27:22 <monochrom> Is that a roast to whoever (I forgot, Paul Graham?) asking you to write "incrememt a counter" in your favourite language, point being Scheme does it best, and Haskell doesn't even qualify because he's specifically saying mutable state not x+1?
15:28:42 <fog> yeah, but you cant do it in types without that thunk
15:28:57 <xerox_> > let p x = 13*x**5/20-65*x**4/8+106*x**3/3-495*x**2/8+2101*x/60+6 in inits ((chr . (97+) . (`mod` 26) . round . p) <$> [0..])
15:28:59 <lambdabot>  ["","g","gh","ghc","ghci","ghcid","ghcide","ghcidep","ghcidepb","ghcidepbs",...
15:29:02 <dmwit> monochrom: it is, yes
15:29:08 <monochrom> \∩/
15:29:10 <hyiltiz> what is the name of the dictionary is defined as the set of all statements?
15:29:12 <xerox_> I was just extrapolating
15:29:32 <ski> "ghcidep" sounds like an interesting suggestion
15:30:18 <dmwit> followed shortly thereafter by ghcirevdep
15:30:56 <monochrom> Why do you use (**)?  (^) should suffice.
15:31:03 <ski> what's not mutable about `IORef' ?
15:31:07 <fog> like, any invertible compiler, and you have to write in the target language of the compiler
15:31:17 <xerox_> sure
15:32:01 <monochrom> ski: Ah OK, he didn't say Haskell doesn't qualify, I butchered it. He said that (\x -> x+1) doesn't qualify. And by the time you use IORef, Scheme does it better.
15:32:27 <dmwit> Oh dear. I have misremembered. It is HQ9+, not HQ9X.
15:32:30 <dmwit> My apologies.
15:32:33 <xsperry> is it that snippet that captures over i and then increments it?
15:32:35 <monochrom> Ah!
15:32:40 <boxscape> just write `main = return ()` and be confident in your assumption that surely the runtime will increment some counter somewhere
15:32:44 <fog> i have something like a hatrogenous foldable container 
15:32:48 <monochrom> Not that the + would be more googlable.
15:32:53 <fog> hetrogenous*
15:33:03 <monochrom> Oh, it's googlable alright
15:33:30 <monochrom> Ah, "haskell $" is the ungooglable one.
15:33:43 <dmwit> There's no $ in Haskell, I'm afraid.
15:33:45 <ski> just write `increment :: Integer -> Integer; increment n = runST (do ref <- newIORef n; m <- readIORef ref; writeIORef ref (m + 1); readIORef ref)' .. best of both worlds
15:33:48 <monochrom> :)
15:33:48 <fog> i need pantom symbols that give the type annotations to the output from those of the inputs, and for the dependencies between these inputs
15:33:59 <ski> s/IO/ST/
15:34:21 <monochrom> Interesting! "haskell >>=" gets you hits on haskell monads.
15:34:55 <dmwit> ski: The actual PG challenge was: write a function which accepts a number, allocates a new mutable value initially equal to that number, and returns a new function (in Haskell we would say action) which increments the newly allocated mutable thing.
15:35:01 <boxscape> looks like "haskell >>=" is the same as "haskell >>"
15:35:13 <dmwit> But because it was PG he didn't explain the requirements clearly, and then blamed readers for sending in non-answers that didn't meet those requirements.
15:35:26 <dmwit> So ¯\_(ツ)_/¯
15:36:06 <fog> you could then fold over a hetrogenous list, with a carry that changes type
15:36:26 <fog> deterministically, based on the types of the values of the HList and the basecase
15:36:41 <boxscape> dmwit hmm what happens if you have an optimizing compiler that gets rid of that because the result of the mutable variable iss never used?
15:36:43 <ski> ok, so `incCounter :: Integer -> IO (IO Integer); incCounter n = do ref <- newIORef n; return (do m <- readIORef ref; writeIORef ref (m + 1); return m)'
15:36:53 <fog> and have it be type safe by the tyfun between the carry and each folded value
15:36:59 <dmwit> ski: right
15:37:22 <dmwit> ski: And it turns out that this is especially concise in his chosen language because the standard library comes with that operation. wow
15:37:31 <boxscape> amazing
15:37:34 <ski> hehe
15:37:40 <spion> does it work with multiple threads though :D
15:38:08 <fog> eg. folding the activations through the weight layers of a net, so that the edges are typesafe accessors over the type lengthed layers
15:38:19 <monochrom> My opinion about the PG challenge is more meta. He knows he's a big shot, therefore he gets to throw his weight around and think up a biased challenge that plays to the strength of his favourite language.
15:38:33 <boxscape> oh returning the updated result *is* part of the requirements
15:39:05 <monochrom> Suppose I were a bigger shot than PG. Then my challenge would be "write a function that maps x to x". Haskell would win here. Would it mean anything though?
15:39:30 <fog> yes, it would demonstrate the point you wanted to make
15:39:44 <dmwit> I mean, to be fair, there are definitely languages where the proposed operation is so cumbersome that you don't even bother thinking it as a thought when you design programs.
15:40:13 <dmwit> And it is a thought I would sometimes consider thinking in some languages (e.g. Haskell or scheme).
15:40:19 <boxscape> the haskell solution on http://www.paulgraham.com/accgen.html says "import IOExts", what is that?
15:40:23 <fog> yeah, higher order functions without functions as first class citizens being the good example
15:40:30 <monochrom> And my point still stands if you go the reasonable "he didn't mean only a counter, he meant objects in general". Well I wouldn't mean only id either, I would mean pure functions.
15:41:08 <ski> boxscape : old module for the `IORef' stuff, i think
15:41:13 <boxscape> I see
15:41:17 <ski> (before hierarchical modules)
15:41:21 <fog> ah, then you would need a label for the functions that can be inverted
15:41:22 <boxscape> Ah
15:41:46 <fog> isnt that "representable" or something?
15:41:51 <fog> like a read instance
15:42:22 <fog> idk, how do you get the types from a bytestream?
15:42:39 <fog> json generic deserialization manages sort of
15:42:54 <spion> AFAIK most of the examples given there are not thread-safe
15:43:18 <boxscape> see the trick is to use a language that can only create programs with one thread
15:43:48 <Uniaika> oh my god, thank you boxscape, I will only do NodeJS now!
15:43:49 <Uniaika> :D
15:43:51 <fog> or have them all editing the same memory block
15:44:14 <fog> for fun "effects"
15:45:06 <fog> thank god haskell doesnt allow you to specify memory addresses! 
15:46:43 <monochrom> until you use Foreign.Ptr.  Consider intPtrToPtir.
15:48:07 * hackage cdeps 0.1.3.1 - Extract dependencies from C code.  https://hackage.haskell.org/package/cdeps-0.1.3.1 (vmchale)
15:48:07 <ski> @type Foreign.Ptr.plusPtr Foreign.Ptr.nullPtr
15:48:09 <lambdabot> Int -> GHC.Ptr.Ptr b
15:51:16 <xsperry> @pl (\i -> do     modifyIORef r (+i)     readIORef r)
15:51:17 <lambdabot> flip (flip (do modifyIORef r . (+)) readIORef) r
15:51:54 <xsperry> @pl \n -> do r <- newIORef n; return (\i -> do modifyIORef r (+i); readIORef r)
15:51:54 <lambdabot> (line 1, column 25):
15:51:54 <lambdabot> unexpected ';'
15:51:54 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:53:10 <ChaiTRex> @pl \ n -> do { r <- newIORef n; return (\ i -> do { modifyIOref r (+i); readIOref r }) }
15:53:10 <lambdabot> (line 1, column 11):
15:53:10 <lambdabot> unexpected '{'
15:53:10 <lambdabot> expecting variable, "(", operator or end of input
15:53:29 <ChaiTRex> @. pl undo \ n -> do { r <- newIORef n; return (\ i -> do { modifyIOref r (+i); readIOref r }) }
15:53:29 <lambdabot> (ap (flip . ((>>) .) . (. (+)) . modifyIOref) readIOref `fmap`) . newIORef
15:54:13 <xsperry> in any case.. it is not a word game. mutable reference is really needed to get described semantics
15:55:22 <remexre> ugh, what's the incantation to tell cabal v2-haddock, "put the HTML docs in /foo/bar"
15:55:51 <remexre> it's neither cabal v2-haddock --htmldir nor cabal v2-install --enable-documentation --installdir, annoyingly
16:01:03 <monochrom> If anything, --htmldir would have a higher chance to be honoured at "cabal v2-configure" time. However, I haven't tried. If even this doesn't do, I think it can't be done.
16:01:59 <monochrom> also one more variable to worry about! --docdir
16:03:41 <monochrom> --installdir is good for exes only, IIUC
16:05:35 <remexre> nope, docdir doesn't do anything to haddock
16:06:37 <remexre> neither install
16:11:16 <xsperry> https://pastebin.com/n6phn7py paul grahams challenge, can't be done without mutable state. (\i -> i + 1) is widely different
16:11:28 <xsperry> and haskell's solution isn't that bad or long either
16:30:51 <edwardk> atomicModifyIORef can do that in one fewer steps
16:31:34 <dsal> The name would imply it would also do it atomically.  :)
16:31:41 <edwardk> indeed
16:38:25 <xsperry> so it is guaranteed to be thread safe. how many solutions on that page are? :)
16:41:51 <monochrom> See, this is why my meta opinion is that his challenge is biased.
16:42:46 <monochrom> It is so important for him to clarify "I mean object, mutable internal state". And goes on to silently exclude atomicity.
16:43:15 <monochrom> Why? Because once you include atomicity, then even Java looks better than Scheme, you just have to add one single reserved word "synchronized".
16:44:03 <monochrom> I deduce that if one's agenda is to make Scheme look better, of course one would contort criteria and non-criteria accordingly.
16:46:17 <monochrom> And the only reason his counter object challenge gets more attention, and my identity function challenge gets no attention, is solely because he already has a lot of worshippers, I don't.
16:46:32 <monochrom> Totally not about technical merits at all.
16:46:35 <dolio> Seems like there are better ways to make scheme look good than, 'I can make a counter closure,' since that's like a toy example that no one cares much about.
16:47:20 <monochrom> I am sympathetic to starting with a toy example. It can be stated in under a minute, even within an elevator pitch.
16:47:58 <monochrom> I am willing to extrapolate "ah you mean objects with encapsulated mutable state is more nicely done in Scheme".
16:48:58 <monochrom> But then my meta opinion simply needs to shift to "why the obsession with objects? who says they are superior? why not pure functions?"
16:49:03 <monochrom> And once again if your agenda is to make objects look better, of course you will contort an object challenge.
16:49:34 <Rembane> He has an article about not properly understanding the idioms of "more powerful" languages you don't know. I guess he has fallen into that trap himself.
16:51:10 <c_wraith> yeah, that's a common observation about that article.
16:51:12 <dolio> I guess I haven't read the example. But, 'you can do objects with lambdas and closures,' with a counter example sounds pretty suspicious to me.
16:51:45 <dolio> That's like, 'you can implement a type system with macros,' and then the people who say that never do it.
16:52:13 <c_wraith> also, doing so doesn't help you when interacting with code that doesn't.
16:52:29 <c_wraith> there's a big difference between optional and mandatory
16:52:41 <dolio> Because when you actually try to do it, you find out that it's pretty awful to not design the language around it better.
16:57:46 <monochrom> Although, somehow, lambda is versatile enough that it is pretty close (pun!) to many things, even though it was not designed upfront for those things. (I think Guy Steele's LtU papers are about this.)
16:59:03 <monochrom> maybe s/pretty/fairly/
17:00:10 <Rembane> What's a lambda in this case? 
17:01:10 <monochrom> Only Smalltalk would beat Scheme on this challenge and/or what it stands for, no? I think PG was exploiting how his young audience haven't heard of Smalltalk, therefore Scheme is naturally the next best approximation.
17:01:28 <Rembane> Cunning. Like a weasel. 
17:01:51 <fog> god damnit why wont this typecheck
17:01:56 <MarcelineVQ> that darn paul giamotti
17:02:04 <fog> https://pastebin.com/raw/KjMcqZnr
17:03:54 <MarcelineVQ> it's good that you're compacting your code to digestable parts but you need to include why ghc says it won't typecheck, and also say what 'this' is that isn't typechecking
17:04:14 <MarcelineVQ> as there's many possible 'this' in that file
17:04:24 <monochrom> Rembane: If you allow me to use haskell syntax but scheme semantics (I'm too lazy to write s-expressions), the model answer for the challenge is (\x -> let c=x in \() -> c++). (Sorry! also had to use C syntax haha)
17:04:32 <monochrom> Does that answer your question?
17:05:30 <monochrom> The problem spec is: take a parameter, use it to initialize a counter, produce a procedure that users can call to increment that counter.
17:05:36 <Rembane> monochrom: It does indeed, and it's dirty as heck. :) 
17:06:15 <Rembane> That sounds like how generators work in Python. But I've probably missed out on some small but important details.
17:08:25 <monochrom> Python generators would do well, yeah.
17:08:54 <monochrom> But Graham is greedy. He would (I think he did) also question about syntactic conciseness.
17:09:29 <koz_> :t fromMaybe
17:09:29 <fog> here is the type error; https://pastebin.com/raw/De9mChab
17:09:31 <lambdabot> a -> Maybe a -> a
17:11:44 <monochrom> This all began when we discussed program length vs output length. Then dmwit brought up H9Q+, a language that restricts possible semantics and outputs so all programs are shorter than their respective outputs.
17:11:49 <Rembane> monochrom: It's a pity that neither APl nor J care about his toy problem, because they are a good way to turn people's reasoning on the head. 
17:12:04 <MarcelineVQ> koz_: that's one of those "why though" kind of defintions,   maybe thing id  vs  fromMaybe thing
17:12:19 <koz_> MarcelineVQ: Just needed a reminder.
17:13:14 <monochrom> and reminded me the + instruction incrememts an accumulator, which is unused by the other 3 instructions. So I thought (correctly I think) "this looks suspiciously like a roast to PG's counter challenge"
17:13:50 <MarcelineVQ> I ​mean why even exist fromMaybe thing when maybe thing id exists and now you can not have to remember yet another thing. dry isn't being accomplished, I still have to write from every time, is that more dry than id every time? weirdness :>
17:14:43 <monochrom> MarcelineVQ: "Based on your recent chat, we thought you may like: ..."
17:14:50 <monochrom> @quote monochrom safeFromJust
17:14:50 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
17:16:28 <remexre> is there something like standalone-haddock for cabal v2- builds?
17:17:42 <MarcelineVQ> fromMaybe, fromLeft, fromRight, the argument I can see for them is not getting the id in the wrong spot, but it's a weak one to me.
17:18:53 <monochrom> I think it was not even that. It was more only "don't want to even write 'id' there".
17:19:04 <fog> if it *did* typecheck, that would be my prototype for the hetrogenous foldable idea
17:19:34 <MarcelineVQ> so I'll write from instead :> oh well, not like it's ruining my crops and pillaging my village, but it's oddness
17:21:13 <fog> i think the problem is to do with the fact it has to be constructed as a snoclist
17:21:19 <fog> "it" being the net
17:21:41 <fog> the reason is that it needs to see the "previous" layers length to bound the accessor edges
17:22:04 <monochrom> oh, then it's a combination of "too lazy to say 'id'" and "but function names must be meaningful"
17:24:07 <monochrom> I may be too harsh, but I feel that people want the standard library to bloat. If there is a function they personally, subjectively useful, they bitch until it's entered into the standard library.
17:24:19 <monochrom> s/useful/find useful/
17:25:07 <monochrom> You can't dissuade them whether the implementation is long or short.
17:25:40 <monochrom> If the implementation is long, "therefore it should be entered into the standard library so I don't have to write again".
17:26:20 <monochrom> If short, "therefore I'm just asking to add one line into the standard library"
17:26:31 <monochrom> You simply can't win.
17:27:07 <EvanR> this proves the argument is independent of implementation size
17:27:26 <monochrom> It's tragedy of commons again.
17:27:32 <EvanR> so the argument can't reasonable refer to implementation size
17:27:38 <EvanR> reasonably
17:28:55 <fog> surely things like folding over hetrogenous things is a good thing to have standardised?
17:29:17 <fog> and there are actual justifications of that, which might be sufficient 
17:29:30 <fog> basically for the sake of the higher order paradigm  
17:29:56 <fog> "is there any point in trying to factor out abstractions" ?
17:30:20 <fog> yes.. since these are the reusable components most useful to become standardized 
17:30:43 <ezzieyguywuf> lol, I think this guy uses dvorak keyboard: https://two-wrongs.com/parser-combinators-parsing-for-haskell-beginners.html
17:30:44 <koz_> Is there a safe Float -> Rational (and Double -> Rational) conversion function?
17:31:22 <koz_> (assuming we don't have NaN or infinity I guess)
17:32:01 <koz_> (guess I just answered my own question lol)
17:32:23 <EvanR> Float -> Maybe Rational
17:32:27 <monochrom> ezzieyguywuf: How come?
17:32:50 <xsperry> funny that maybe x id is shorter than fromMaybe x
17:33:27 <ezzieyguywuf> monochrom: glad you asked! because `isVowel` uses the string literal "aoeui"
17:33:35 <ezzieyguywuf> with is asdfg, but in dvorak layout
17:34:01 <monochrom> Oh!
17:34:03 <ezzieyguywuf> !
17:34:52 <EvanR> that's clearly something you do to make people think you use dvorak
17:34:53 <xsperry> and while maybe (error "...") id is longer than fromJust, that's not necessarily a bad thing
17:34:53 <monochrom> age of empires user interface
17:35:20 <ezzieyguywuf> I use dvorak :)
17:35:43 <monochrom> I just use pattern matching.
17:35:57 <ezzieyguywuf> for typing?!
17:37:26 <EvanR> koz_: scientific seems more appropriate
17:38:04 <monochrom> asymptotically, "maybe z (\a -> ... code length is n here ...) m" and "case m of Nothing -> z; Just a -> ... code length is n here ...)" are both Θ(n) length. But the latter is friendly to more readers.
17:38:11 <koz_> It is.
17:39:26 <monochrom> and when it becomes necessary to code in an advanced way rather than an elementary way, I go all-out to >>= and <|>
17:40:03 <monochrom> "go big or go home"
17:42:10 <xsperry> maybe + lambda is often uglier than pattern matching, but if you already have a function, or can get it with partial applications, it's often nicer
17:42:24 <xsperry> s/often/usually
17:42:27 <monochrom> yes that's true
17:42:58 <ChaiTRex> > let toRat :: RealFloat a => a -> Maybe Rational; toRat x | isInfinite x = Nothing | isNaN x = Nothing | otherwise = Just (toRational x) in toRat (1.0 :: Double)
17:43:00 <lambdabot>  Just (1 % 1)
17:43:08 <ChaiTRex> koz_: ^
17:43:23 <koz_> ChaiTRex: Thanks!
17:43:32 <ChaiTRex> koz_: No problem.
17:51:41 <monochrom> @quote  ehird NaN
17:51:41 <lambdabot> ehird says: the answer to life the universe and everything is NaN
17:52:42 <monochrom> @quote roconnor finance
17:52:42 <lambdabot> roconnor says: don't let Float do your finance homework for you.
18:12:07 * hackage sdr 0.1.0.13 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.13 (adamwalker)
18:18:34 <sm[m]> wow.. I really can't build Cabal-3.2.0.0 on a 4G vps
18:19:23 <sm[m]> tried with old and new ghc, with -j1, with --ghc-options='+RTS -M500M -RTS' ... :(
18:19:44 <sm[m]> I thought -M used to have some effect, but not this time
18:20:24 <sm[m]> any ideas welcome
18:31:28 * sm[m] gives in and downloads a binary
18:31:40 <sm[m]> wow cabal really doesn't want to stop when it's downloading packages
18:35:18 <sm[m]> what does (all, legacy fallback) mean in cabal output ?
18:38:19 <solonarv> cabal packages can have multiple components (executable(s), test suite(s), even multiple libraries)
18:38:48 <solonarv> they aren't necessarily built all at once, and if you depends on a package you can specify which of the component(s) you need
18:39:43 <solonarv> if you don't specify that, cabal will assume you need "all" of them, as a "fallback", and it's "legacy" because going forward you really should specify but not everyone's caught up yet
18:40:47 <yuanlang> CompilerStage(..) CompilerStage is Data what (..) means
18:41:26 <solonarv> it's a shorthand for "all the constructors/fields/method etc"
18:42:01 <yuanlang> Thanks
18:42:25 <solonarv> for example, 'import Prelude ( Maybe(..) )' means the same thing as 'import Prelude ( Maybe(False, True) )' and imports the 'Maybe' type constructor as well as the data constructors 'False' and 'True'
18:43:54 <yuanlang> solonarv Your answer is so detailed.Thank you very much.
18:51:18 <freeman42x[m]> is it the case of what is said here in this code comment? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/90d307e317a057cc58777cca11765dccdb951237/src/Main.hs#L23
19:00:07 * hackage warp-tls 3.3.0 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.3.0 (KazuYamamoto)
19:05:40 <sm[m]> solonarv: thanks! it's just building deps, so of course I haven't specified.. seems like it should just build the required libs
19:06:15 <sm[m]> or.. does build-depends need to specify all that now ?
19:06:35 <solonarv> sm[m]: yes, I think 'build-depends' is where you'd specify that. I haven't looked in detail though.
19:07:01 * sm[m] did not get the memo
19:07:09 * solonarv shrugs
19:07:11 <sm[m]> will check docs later - thanks
19:09:37 * hackage warp 3.3.13 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.13 (KazuYamamoto)
19:18:21 <freeman42x[m]> this safe file path library: https://github.com/haskell-hvr/paths vs this one: https://github.com/mxswd/data-filepath ? which would you recommend? have the impression the HVR one might be better but not sure
19:22:16 <freeman42x[m]> hvr: what do you think? unbiased opinions only haha
19:42:03 <krjst> is there a cabal alternative to `stack ghci --test`? I tried to use `cabal repl test:test-module-name` but the behavior is a bit different. The library modules are not loaded by default and `:reload` won't recompile the library modules.
20:25:40 <fog> man, it typechecks, but its ridiculous 
20:25:42 <fog> https://pastebin.com/raw/5XwX4rmK
20:26:43 <fog> just trying to reverse the thing so it can be folded
20:27:02 <fog> it ends up needing a reference to the *next* layer
20:27:11 <fog> like, the one yet to be consed
20:28:32 <fog> the type checker was putting up a fight - i guess it managed to cause the code to be correct (!?) 
20:29:27 <fog> cant be sure that it wouldnt accept something wrong though...
20:30:11 <fog> ill try and test it at runtime soon
20:36:29 <d34df00d> Suppose I have a `fun :: a -> a -> a` and I also have `v1, v2 :: Maybe a`s. How can I produce `Maybe a` such that if both v1 and v2 are Just something, then it's `Just (fun ...)` of the corresponding underlying things, or v1 if v2 is Nothing, or v2 if v1 is Nothing?
20:38:09 <dolio> d34df00d: liftA2
20:38:17 <d34df00d> Ah, I just figured `fun` makes my `a` in a semigroup nicely, so I can leverage `Semigroup a => Monoid (Maybe a)`. The power of libraries, yay!
20:38:35 <d34df00d> dolio: hmm, why haven't I thought about that? It's seems blatantly obvious now that you've mentioned it.
20:38:36 <d34df00d> Thanks!
20:38:37 <dolio> Yes, that also works.
20:38:46 <d34df00d> I should go to sleep probably .__.
20:38:47 <doublex> > (*) <$> Just 2 <*> Just 3
20:38:49 <lambdabot>  Just 6
20:39:22 <d34df00d> doublex:  (*) <$> Just 2 <*> Nothing would give nothing, but I want Just 2.
20:39:41 <d34df00d> Ah.
20:39:47 <d34df00d> That also explains why liftA2 doesn't work really.
20:39:59 <d34df00d> And why I haven't thought of it.
20:41:52 <dolio> Oh, I misread the Nothing part.
20:45:09 <gvx> > (\f a b -> liftA2 f a b <|> a <|> b) (Just 3) (Just 2)
20:45:10 <lambdabot>  error:
20:45:10 <lambdabot>      • Couldn't match expected type ‘a -> a -> a’
20:45:10 <lambdabot>                    with actual type ‘Maybe Integer’
20:45:19 <gvx> > (\f a b -> liftA2 f a b <|> a <|> b) (*) (Just 3) (Just 2)
20:45:21 <lambdabot>  Just 6
20:45:27 <gvx> > (\f a b -> liftA2 f a b <|> a <|> b) (*) (Just 3) (Nothing)
20:45:29 <lambdabot>  Just 3
20:45:51 <gvx> d34df00d: like this? Maybe not the prettiest solution ^^;
20:46:17 <d34df00d> That's interesting!
20:59:07 * hackage calamity 0.1.16.0 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.16.0 (nitros12)
21:09:59 <jusss> order, rank, kind, anything else?
21:10:32 <jusss> higer-order function, higer-order logic, higher-ranked type, higher-kinded polymorphism, ?
21:14:02 <dmwit> :t \f -> maybe id ((Just .) . (maybe <*> f)) -- perhaps you hate your reader!
21:14:03 <lambdabot> (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
21:15:50 <gvx> :t maybe
21:15:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:20:23 <gvx> @pl \f -> maybe id ((Just .) . (maybe <*> f))
21:20:23 <lambdabot> maybe id . ((Just .) .) . (maybe <*>)
21:21:43 <gvx> @pointful \f -> maybe id ((Just .) . (maybe <*> f))
21:21:44 <lambdabot> \ f -> maybe (\ x -> x) (\ x x0 -> (Just) ((maybe <*> f) x x0))
21:24:39 <dmwit> Oh, heck.
21:24:57 <dmwit> :t \f -> listToMaybe . scanl f . foldl (foldr (:)) []
21:24:59 <lambdabot> error:
21:24:59 <lambdabot>     • Couldn't match type ‘[a1] -> [[a]]’ with ‘[a2]’
21:24:59 <lambdabot>       Expected type: t (t1 a) -> [a2]
21:25:41 <dmwit> :t \f ma mb -> listToMaybe . scanl1 f . foldl (foldr (:)) [] $ [ma, mb]
21:25:44 <lambdabot> Foldable t => (a -> a -> a) -> t a -> t a -> Maybe a
21:28:14 <dmwit> :t \f ma mb -> scanr1 f ([ma, mb] >>= toList) -- more readable
21:28:15 <lambdabot> error:
21:28:15 <lambdabot>     Ambiguous occurrence ‘toList’
21:28:15 <lambdabot>     It could refer to
21:28:22 <dmwit> :t \f ma mb -> scanr1 f ([ma, mb] >>= F.toList) -- more readable
21:28:24 <lambdabot> Foldable t => (a -> a -> a) -> t a -> t a -> [a]
21:28:47 <dmwit> Oh yeah, forgot the listToMaybe. Anyway... this is hilariously gross.
21:36:41 <gvx> :t toList
21:36:42 <lambdabot> error:
21:36:42 <lambdabot>     Ambiguous occurrence ‘toList’
21:36:42 <lambdabot>     It could refer to
21:43:00 <dsal> :t Data.Foldable.toList
21:43:01 <lambdabot> Foldable t => t a -> [a]
21:59:05 <gvx> :t \f ma mb -> listToMaybe $ scanr1 f (catMaybes [ma, mb]) -- more readable?
21:59:06 <lambdabot> (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
22:31:49 <ocramz> hullo!
23:00:07 <int-e> :t \f -> maybe id (fmap . f)
23:00:08 <lambdabot> Functor f => (a1 -> a2 -> a2) -> Maybe a1 -> f a2 -> f a2
23:01:55 <int-e> (not correct, meh)
23:05:37 * hackage min-max-pqueue 0.1.0.2 - Double-ended priority queues.  https://hackage.haskell.org/package/min-max-pqueue-0.1.0.2 (zliu41)
23:13:50 <asheshambasta> Anyone else using Haskell for sound synthesis on SuperCollider here? So far I've heard of hsc and vivid as the haskell frontends to SC. Any others?
23:18:41 <freeman42x[m]> could someone help me understand how to get this function to compile? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/master/src/OS/Common.hs#L58
23:18:58 <freeman42x[m]> I know that it is just about matching types but this is harder than expected and I already spent a lot on it
23:21:54 <freeman42x[m]> thought that liftIO will put the Text into Shell Text
23:24:27 <MarcelineVQ> liftIO lifts  IO a  to  m a,  if you want Text to Shell Text you'd use  pure or return
23:43:06 <freeman42x[m]> MarcelineVQ: I already tried return and it gave same error from what I recall
23:46:12 <MarcelineVQ> which was?
23:47:53 <MarcelineVQ> ah,  sh results in IO ()  but you are asking it to result in  IO Text
23:53:32 <freeman42x[m]> > map (read.(:[])) "11000101101"
23:53:34 <lambdabot>  [*Exception: Prelude.read: no parse
23:53:40 <freeman42x[m]> how do I get above to work?
23:55:47 <MarcelineVQ> > map (read.(:[])) "11000101101" :: [Int] -- give it a type somewhere
23:55:48 <lambdabot>  [1,1,0,0,0,1,0,1,1,0,1]
23:56:05 <MarcelineVQ> otherwise it's probably defaulting to ()
