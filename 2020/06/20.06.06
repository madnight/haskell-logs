00:18:48 * hackage net-spider 0.4.3.3 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.3.3 (debugito)
00:20:48 * hackage net-spider-pangraph 0.2.0.2 - Conversion between net-spider and pangraph  https://hackage.haskell.org/package/net-spider-pangraph-0.2.0.2 (debugito)
00:22:18 * hackage net-spider-cli 0.2.0.3 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.2.0.3 (debugito)
01:04:36 <veverak> hmm
01:04:40 <veverak> I am using cabal v2
01:05:04 <veverak> I have package that needs lower version of base (<4.11) than I have (4.14)
01:05:07 <veverak> how to approach this?
01:07:08 <ja> veverak: probably you can bump the dependency without issues
01:07:28 <ja> veverak: but if you can't, i think you'll need to downgrade ghc
01:07:46 <ja> veverak: base comes with ghc
01:10:01 <[exa]> veverak: sometimes it's easier to upgrade the package to the newer ghc
01:11:49 <veverak> ja: bump?
01:12:06 <veverak> [exa]: I suppose that "github issue for the package" will take some time
01:12:37 <veverak> I mean, I am all for it
01:12:48 <veverak> it's just that I would like to work on this tday :)
01:15:01 <Rembane> veverak: Increase the limit, compile and see what happens. :)
01:15:04 <Rembane> #forscience
01:18:13 <veverak> hmm
01:18:26 <veverak> so, I can somehow easily compile third-party package localy ? :)
01:20:05 <Rembane> Yes, by using cabal or stack. 
01:23:15 <maerwald> veverak: cabal v2-build --allow-newer=base
01:23:43 <maerwald> chances are it fails ofc, but base bounds are often wrong
01:23:48 * hackage threepenny-gui 0.9.0.0 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.9.0.0 (sjakobi)
01:43:26 <veverak> maerwald: thanks
01:43:44 <veverak> maerwald: I can test and if it is ok, this is good issue for the maintainer
01:43:49 <veverak> "hey, it actually works with never?"
01:46:44 <[exa]> veverak: local howto: copy the package into the package subdirectory, `cabal install subdirectory/`
01:47:39 <veverak> I see
01:48:42 <[exa]> the subdirectory thing is weird but it didn't work for me otherwise; I was too lazy to google for an explanation
01:51:43 <veverak> hmm
01:51:55 <veverak> I am writing evaluator for one coding language
01:52:11 <veverak> is there something in haskell for help with evaluation? (just like Parser helps with parsing...)
02:00:20 <[exa]> veverak: depends on how complicated the language is
02:02:16 <[exa]> veverak: like, writing a recursive function that just reduces the AST to the result may be appropriate and correct :]
02:16:08 <veverak> hm
02:16:21 <veverak> well, I wrote something
02:16:27 <veverak> (did not even compiled it yet)
02:16:42 <veverak> and it is just recursive function... but I worry about scope
02:17:06 <veverak> I have concept of scope which is changed in the recursion
02:23:30 <[exa]> veverak: update to RWST (or just State) is usually relatively painless
02:23:50 <veverak> hmm, not sure RWST will help?
02:24:24 <veverak> I also have to decide on proper error handling... 
02:24:25 <veverak> hmm
02:40:10 <[exa]> veverak: RWST can carry a lot of scope-ish info. ExceptT for error handling will work too.
02:40:35 <veverak> btw: scope is stored in Data.Map
02:41:30 <[exa]> so a State or even a Reader should work, depending on how your variables behave
02:43:31 <[exa]> anyway the point where this breaks is when you actually need to represent the program state somewhere in the middle of computation; at that point you're better off transforming the source to intermediate representation and running a tiny vm on that
02:46:31 <merijn> Honestly, for a VM's memory I'd consider just using mutable state for performance
02:47:26 <merijn> (although I missed the larger context, so hard to say what the best solution is)
02:47:37 <[exa]> yeah, I didn't imply we would simulate memory and registers :D
02:48:52 <merijn> I mean, Map/IntMap perform much better than many beginners assume, but there's a limit :)
02:49:15 <veverak> hmm
02:49:18 <veverak> it's not normal coding language
02:49:28 <veverak> it's language for description of 3D models (openscad)
02:49:41 <veverak> and variables are immutable
02:49:44 <veverak> AND
02:49:48 <veverak> I do not need ful evaluation
02:49:55 <veverak> I need to evaluate it enough so I can extract information I need
02:50:10 <veverak> and I may impose some limits on what is actually allowed to be used in the part I am analyzing
02:52:03 <[exa]> oh so, openscad should be simple. Some combination of ExceptT and StateT should work
02:52:22 <sshine> veverak, to answer your question above: I'd also go with Reader, State or RWST. if it's too complex, just continue with your recursive function.
02:53:26 <sshine> yeah, what [exa] suggests sounds good. :)
02:53:30 <[exa]> RWST is extra useful for openscad has the environment (R), it spills out the model (W) and there's the transformation matrix and variables (S)
02:53:46 <[exa]> and you want to transform it atop something you use (T)
02:54:48 <veverak> hmm
02:56:13 <sshine> newtype Eval a = Eval { runEval :: StateT MyState (ExceptT MyError Identity) a }
02:56:47 <merijn> What do you plan to do with the resulting model?
02:56:57 <veverak> well, I do not need the model per se
02:57:05 <veverak> I need to extract "parts" out of the entire thing
02:57:18 <veverak> where "part" is just openscad module that has "part()" as first child
02:57:27 <veverak> (first and only)
02:57:37 <veverak> this way I can automatize generation of "parts you need to build this"
02:57:43 <[exa]> (everytime I see this RWSE combo I hear "with all their powers combined!"...)
02:57:47 <veverak> but that requries evaluation of "assembly of parts"
02:57:51 <merijn> I'm asking, because I'm reminded of a bunch of CAD programs that just store their data as queryable SQLite database :p
02:59:01 <veverak> this is not that kind of CAD :/
02:59:06 <[exa]> veverak: so basically you are scraping a list of modules that are 1] parts 2] invoked for creating some model
02:59:14 <veverak> yeah
02:59:42 <veverak> but, the parts have arguments and I need them evaluated (because each part with different args is unique ofr my purpose)
02:59:57 <[exa]> oh nice
02:59:58 <merijn> veverak: Yeah, I'm just saying that if you need to build once/query multiple times that sorta thing might sense. If you only need to compute one thing of the data, then there's no point
03:00:00 <veverak> and the parts are generate by "for cycleS" and such, so just parsing it is not enough
03:00:11 <sshine> [exa], as in power rangers?
03:00:14 <[exa]> so something like `Writer (Set PartDesc)` would probably work as output?
03:00:21 <[exa]> sshine: imperative rangers in this case
03:00:26 <veverak> yeah, but I wonder if I actually need writer?
03:00:26 <merijn> veverak: Anyway, I only noticed the discussion of solutions, not the original problem/question :)
03:00:38 <merijn> [exa]: tbh, Writer's performance is...not great
03:00:39 <veverak> merijn: yeah, it owuld be long to write it again....
03:00:44 <veverak> what I want to do
03:00:56 <veverak> is just eval of the ATS to "simpler form"
03:01:05 <veverak> (which mean it is still AST)
03:01:31 <veverak> so, instead of for cycle, union of objects... etc etc all arguments evaluated
03:01:47 <[exa]> merijn: is there any alternative that would be similarly simple and useful for just beancounting stuff that occurs in the computation?
03:01:48 <veverak> than I can extract parts from that with quite simple algorithm without anythin complex
03:01:56 <merijn> veverak: Honestly, my main (and trickiest) advice would be to "just start", if you try to make sure that your API for updating/reading/writing state is encapsulated you can always rip it out and replace it later
03:02:00 <veverak> (so no need for writer ...)
03:02:07 <sshine> veverak, you make a recursive function and when you start to think that it's keeping track of too much using arguments, you make a type that encapsulates those arguments in the way that they're used.
03:02:14 <merijn> [exa]: Strict state where you only ever append ;)
03:02:23 <veverak> sshine: yeah, I allready got prototype
03:02:27 <veverak> hmm
03:02:32 <veverak> seems like state/error is only thing I really need
03:02:41 <[exa]> merijn: oh so. wasn't there a strict variant of writer for that?
03:02:42 <sshine> veverak, sounds likely.
03:02:50 <merijn> [exa]: Yeah, but it's still not great
03:03:24 <[exa]> uh I see, semigroup strictness
03:04:54 <merijn> veverak: Ok, so from personal experience I'd say the best way to go is: Define a custom typeclass for "primitive" state operations and one for "primitive" errors. Then implement all convenience wrappers in terms of those APIs and build your code using the "convenience API" you built. This way you can just define a newtype monad around, like, StateT/ExceptT and implement your typeclass for that. And then 
03:05:00 <merijn> you can always rip out/redo/replace it later with something better
03:13:55 <sshine> merijn, why not just use StateT/ExceptT from the start then?
03:14:44 <merijn> sshine: Because if you do that StateT/ExceptT are now *everywhere* in your codebase and ever changing/refactoring will be a pain in the ass
03:15:19 <merijn> sshine: I learned this lesson that hard way, because "just using StateT/ExceptT" was what I did and then I needed something different and it tooks me weeks to refactor everything
03:15:35 <sshine> merijn, and by them being everywhere, you mean their get/put/modify, throwError/catchError?
03:16:13 <merijn> sshine: And hard coded in every type signature (unless you use mtl, but know you have mtl constraints everywhere and that's basically the same problem)
03:17:13 <merijn> Plus, earlier this week I already argued why mtl classes in your "public" (and that includes within your own package) are a bad idea :p
03:17:50 <sshine> merijn, the reason I'm asking is because I haven't been in that situation you describe. but it sounds sensible that you build some small set of combinators that you use throughout, and you switch their implementation. I guess my current project is the first time I've ever experienced weeks of refactoring due to immature choices, and I haven't fully generalised the experience.
03:18:29 <sshine> merijn, ok, good point.
03:19:07 <merijn> sshine: It's basically the core of the "Tagless Final Encoding" you see people use
03:20:13 <merijn> sshine: It also took me scaling my own codebase to larger scales to feel this pain and realise *why* people like Cale advocate for a style like that ;)
03:21:41 <merijn> sshine: Essentially, there's no reason why code *using* your logging/database/etc. APIs/wrapping should be concerned with its implementation, and by hiding it you leave the freedom to aggressively change it. I'm starting to appreciate the "right" kind of boilerplate in Haskell more and more
03:22:09 <sshine> merijn, right :)
03:22:26 <sshine> veverak, if you want a rabbit hole: https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell.html
03:37:46 <[exa]> sshine: wow that's good
03:38:50 <sshine> [exa], yes!
03:39:25 <sshine> I forgot, what's a good pretty-printing library? there are so many.
03:41:17 <merijn> @hackage prettyprinter
03:41:17 <lambdabot> https://hackage.haskell.org/package/prettyprinter
03:41:26 <sshine> right, thanks.
03:43:43 <veverak> hmmm
03:43:45 <veverak> shachaf: cool
03:43:47 <veverak> oh, sorry
03:43:49 <veverak> sshine: cool
04:21:06 <kuribas> :t listen
04:21:08 <lambdabot> MonadWriter w m => m a -> m (a, w)
04:22:01 <kuribas> when you "listen" to a writer, is the output then ignored by the writer?
04:25:55 <sshine> > runWriter (listen (tell "apparently not"))
04:25:58 <lambdabot>  (((),"apparently not"),"apparently not")
04:26:14 <merijn> What do you mean by "ignored"?
04:26:17 <xerox_> :t \m -> WriterT $ do { (a,w) <- runWriterT m; pure ((a,w),w) }
04:26:19 <lambdabot> Monad m => WriterT w m a -> WriterT w m (a, w)
04:27:13 <kuribas> sshine: ah, indeed
04:27:54 <timCF> Hello! Is there some efficient function `(Num a, ByteArrayAccess b) => a -> b` where b can be for example ByteString if there is no polymorphic function. Need something like this to create hash using Cryptonite package
04:31:28 <merijn> timCF: If you use that function for just ByteString it should be efficient
04:31:32 <sshine> timCF, Data.Bits??
04:31:45 <sshine> timCF, wait, you said bytes, not bits. :-P
04:32:19 <merijn> timCF: I guess my question boils down to: Why do you think that function is inefficient? Do you have benchmarks/profiling or is this intuition?
04:33:11 <timCF> I mean, I can't find this kind of function in Hackage, maybe you know something similar? 😀
04:33:33 <merijn> timCF: Let's rewind a bit, what are you trying to do? Serialise data to a binary format?
04:33:57 <timCF> No, create a function to get hash of any Num
04:34:50 <merijn> timCF: I'm not sure one exists, but writing a *fast* one should be fairly if you don't mind getting your hands dirty with unsafe stuff :p
04:36:28 <merijn> So it depends how important fast is and how daring you feel with dangerous stuff ;)
04:36:51 <timCF> well, maybe not *so* fast) Just something faster than `hash . C8.pack . show`
04:38:40 <merijn> timCF: Basically, what I was thinking is: Foreign.Marhsall.Utils.with gives you a temporary stack pointer to a random storable object (aka, most numeric types other than Integer). Then you can use Foreign.ForeignPtr.newForeignPtr_ to wrap it into a ForeignPtr, and Data.ByteString.Internal to wrap the ForeignPtr into a ByteString, which you then hash. Which is about as fast you can get :p
04:39:13 <merijn> Since in the end that'll compile down to "copy value somewhere, some pointer manipulation that should just compile/optimise away" followed by hashing the resulting ByteString
04:39:50 <merijn> timCF: If that's too dangerous you could consider using the binary package to serialise numbers to a ByteString the "safe" way and hash the result
04:40:37 <timCF> Thanks a lot merijn
04:40:58 <merijn> Actually, I guess you can also use the ByteString interface to allocate a Ptr Word8 and then use peek/poke to copy your data into that
04:41:09 <merijn> That's safer and probably about equally fast
04:41:10 <opqdonut> hmm could you write a ByteArrayAccess instance for a Word64 or something?
04:41:30 <sshine> hmm interesting.
04:41:40 <timCF> Will take a look binary package) Pointers is one of the reason why I left C++ many years ago and started functional programming)
04:42:08 <sshine> timCF, you have a reference.
04:42:12 <merijn> timCF: You're not having fun in Haskell until you've got unsafeToForeignPtr ;)
04:42:35 <merijn> timCF: Anyway, it's always useful to know the option exists :)
04:42:52 <opqdonut> ok the ByteArrayAccess impl would require playing with Ptrs anyway
04:51:59 <kuribas> does let generalization work with recursive let?
04:52:39 <phadej> yes
04:53:03 <phadej> as far, as it's not polymorphically recursive (then you need a type annotation to it to type-check in the first place)
04:53:50 <kuribas> phadej: you mean it generalizes over the recursive "groups"?
04:53:56 <phadej> yes
04:54:00 <phadej> *try*
04:55:15 <kuribas> so only the variables which are free in the whole group will be generalized right?
04:56:46 <kuribas> phadej: I think my forall scheme may actually work with let generalization
04:57:05 <kuribas> phadej: the unification engine simply ignores the foralls.
04:59:07 <kuribas> then for checking a type against an expression, I make the outer variables rigid, and the inner variables (in the inputs) fresh, alternating for each level.
04:59:58 <kuribas> phadej: so as far as the unification engine is concerned, rigid variables only check against the same rigid variable.
05:00:33 <kuribas> So: x :: forall a. a -> (forall b. b -> b) -> a
05:00:36 <phadej> I don't understand what you talking about, as far as you do that's is good :)
05:01:12 <kuribas> it becomes  x :: forall a. a -> (_b -> _b) -> a
05:01:43 <kuribas> _b fresh
05:03:25 <kuribas> for example if the inferred type of x is (forall b. b -> (Int -> Int) -> b)
05:03:30 <kuribas> it wil match
05:04:06 <kuribas> by setting _b ~ Int
05:08:58 <kuribas> And when using "x", it's the opposite.
05:09:29 <kuribas> at each usage x will become (x :: _a -> (forall b. b -> b) -> _a)
05:10:17 <kuribas> So the unifier itself doesn't need to understand the foralls.
05:18:22 <juri_> yay! I got my slicer working! :)
05:42:16 <ski> kuribas : hm, i suppose i'd say `x :: ?a -> (_b -> _b) -> ?a' rather than `x :: forall a. a -> (_b -> _b) -> a', where `?a' denotes a skolem / rigid (/ unknown / opaque / forgotten / abstract) type
05:42:44 <ski> kuribas : anyway, what if the expression uses the second (polymorphic) parameter multiple times ?
05:47:14 <kuribas> ski: if x is a lambda, then I don't use this scheme.
05:47:28 <kuribas> ski: in that case I bind the foralls directly to the type environment of the lambda
05:48:37 <ski> and if `x' is `id (\y p -> ..p..y..)', e.g. ?
05:49:05 <kuribas> then inference will fail
05:50:10 <kuribas> more precise, type checking will fail
05:52:00 <ski> what if you want to define `x' by applying some other rank two operation to an argument ?
05:52:03 <kuribas> (id mono) :: poly will fail, even if mono can be polymorphic
05:52:27 <kuribas> ski: I think that will work
05:52:33 <ski> this sounds similar to the value restriction, or something like that, i guess
05:53:06 <ski> say `y :: forall a. Int -> a -> (forall b. b -> b) -> a', and you want to define `x = f 42'
05:53:07 <kuribas> but id (poly :: polytype) should work als
05:53:22 <ski> er, `x = y 42'
05:54:48 <kuribas> so: x :: (_a -> (forall b. b -> b) -> _a)
05:55:01 <kuribas> if I generalize, I can bring back in the _a in the forall
05:55:02 <ski> `x' isn't used here
05:55:41 <ski> you want to check thata `y 42' has type `?a -> (_b -> _b) -> ?a', yes ?
05:56:01 <kuribas> ski: no, that's inferred
05:56:31 <ski> you're trying to check that `x :: forall a. a -> (forall b. b -> b) -> a; x = y 42' is well-typed
05:57:20 <ski> what's inferred ?
05:58:17 <kuribas> y becomes (Int -> _a -> (forall b. b -> b) -> _a) (by making the poly types free).
05:58:31 <ski> yes
05:58:32 <kuribas> applying x => _a -> (forall b. b -> b) -> _a
05:58:52 <ski> or rather `Int -> _a -> (?b -> ?b) -> _a', right ?
05:59:09 <kuribas> so the constraint to solve is Int ~ Int, which is trivial
05:59:48 * hackage slip32 0.1 - SLIP-0032: Extended serialization format for BIP-32 wallets  https://hackage.haskell.org/package/slip32-0.1 (RenzoCarbonara)
06:00:17 <kuribas> then the inferred type of x = y 42 is _a -> (forall b. b -> b) -> _a
06:00:21 <kuribas> which can be generalized
06:00:41 <kuribas> ski: no, if I remove the foralls, I don't have the scope information anymore
06:00:56 <ski> i thought you said that you removed all `forall's from a type, when checking and inferring ?
06:01:07 <kuribas> ski: forall is ignored when inferring
06:01:20 <kuribas> ski: no, when unifying, not inferring
06:01:39 <ski> you mean you don't know where they're quantified, if you remove the `forall's ?
06:01:50 <ski> hm
06:01:52 <kuribas> ski: removing the foralls was my previous plan, I changed it a bit.  But the unifier ignores the foralls.
06:02:26 <kuribas> ski: maybe: Int -> _a -> exists ?b. (?b -> ?b) -> _a ?
06:02:39 <kuribas> ski: if you don't like the forall
06:03:19 <ski> no, i was just going with what i thought i remembered you'd said, that you removed all the quantifiers, to begin with
06:04:08 <ski> (also, that `exists' runs into another problem ..)
06:06:03 <ski> @djinn ((a,b) -> c) -> Either (a -> c) (b -> c)
06:06:03 <lambdabot> -- f cannot be realized.
06:06:08 <ski> @djinn ((a,b) -> c) -> NotNot (Either (a -> c) (b -> c))
06:06:09 <lambdabot> f a b =
06:06:09 <lambdabot>     void (b (Right (\ c ->
06:06:09 <lambdabot>                     void (b (Left (\ d -> void (b (Right (\ _ -> a (d, c))))))))))
06:06:33 <ski> @djinn Not (a,b) -> Either (Not a) (Not b)
06:06:34 <lambdabot> -- f cannot be realized.
06:06:41 <ski> @djinn Not (a,b) -> NotNot (Either (Not a) (Not b))
06:06:42 <lambdabot> f a b = void (b (Right (\ c -> void (b (Left (\ d -> a (d, c)))))))
06:07:38 <ski> (that's more or less the same issue as `((forall a. F a) -> T) -> (exists a. (F a -> T))' has)
06:08:35 <ski> kuribas : hm. so `forall's are ignored, when ?
06:09:02 <kuribas> ski: when unify two type terms
06:09:26 <ski> ignored, in which sense ?
06:09:42 <kuribas> ski: forall a. T is consider the same as T
06:09:58 <kuribas> but the a inside T can only match another a
06:10:08 <kuribas> (and a is made unique)
06:10:14 <ski> by treating `forall'-bound tyvars as either skolems, or placeholders, depending on the current "level" ?
06:10:27 <kuribas> ski: yeah
06:10:36 <ski> and unification is symmetric ?
06:10:43 <kuribas> yes
06:10:51 <ski> or do you treat the two sides differently (perhaps oppositely) ?
06:11:03 <kuribas> no, it's symmetric
06:11:09 <ski> mhm
06:11:23 <kuribas> ski: http://hackage.haskell.org/package/unification-fd-0.10.0.1
06:12:17 <kuribas> ski: when I have an implementation, you can try to break it :)
06:12:44 <ski> i was already trying to break it for you, now ;)
06:13:07 <kuribas> pleaso do
06:17:38 <ski> i'm wondering whether having an asymmetric unification would be helpful, here
06:18:03 <kuribas> wouldn't that make it even more complicated?
06:18:50 <ski> probably
06:23:24 <ski> kuribas : hm, just one and a half hour ago you said "then for checking a type against an expression, I make the outer variables rigid, and the inner variables (in the inputs) fresh, alternating for each level.","so as far as the unification engine is concerned, rigid variables only check against the same rigid variable.","So: x :: forall a. a -> (forall b. b -> b) -> a","it becomes  x :: forall a. a -> (_b -> _b) -> a","_b fresh"
06:24:03 <kuribas> yes
06:24:12 <ski> so, i'm not seeing why you're here removing the inner `forall' in `x :: forall a. a -> (forall b. b -> b) -> a', to arrive at `x :: forall a. a -> (_b -> _b) -> a', and not the outer one
06:25:25 <kuribas> right, the inner forall shouldn't be removed
06:26:44 <kuribas> well, depends if it is checking the type, or inferring it.
06:27:05 <ski> well, in this case, i assume you were checking the given type for `x'
06:27:45 <kuribas> right, so the outer one shouldn't be removed
06:28:09 <ski> so, neither the inner nor the outer `forall' should be removed ?
06:28:47 <kuribas> no the inner should be 
06:29:01 <ski> oh. you were just saying before that it shouldn't
06:29:06 <kuribas> for example forall b. b -> (Int -> Int) -> b
06:29:10 <kuribas> (Int -> Int) has no forall
06:29:24 <ski> do you mean if the body would infer that type ?
06:30:29 <kuribas> yes
06:31:45 <ski> so, from the signature, you're checking that the inferred type of the body unifies with `forall a. a -> (_b -> _b) -> a' ?
06:33:05 <kuribas> right
06:33:30 <ski> so, i was wondering why not check what it unifies with `?a -> (_b -> _b) -> ?a', then ?
06:33:37 <ski> s/what/that/
06:34:02 <kuribas> hmm, I could yes
06:34:23 <ski> and if the inferred type of the body is `_c -> (Int -> Int) -> _c', that'd unify, by instantiating `_b' to `Int', and `_c' to `?a'
06:34:47 <ski> (where `?a' is my notation here for a skolem)
06:36:01 <ski> i'm not sure whether this idea of mine is any good .. i'm just wondering if you need to keep those outer `forall's in the type, during a checking situation like this
06:36:27 <kuribas> hmm, I see a problem
06:36:51 <kuribas> if I generalize after removing the inner foralls, it will only add the in the outer layer
06:37:17 * hackage ghc-check 0.5.0.0 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.5.0.0 (PepeIborra)
06:37:34 <ski> do you mean if there's no accompanying type signature for the definition you're inferring ?
06:37:40 <kuribas> yeah
06:37:51 <kuribas> though I suppose that is how generalization works
06:37:58 <ski> yea
07:03:25 <whataday> fix . const = id?
07:03:36 <Rembane> :t fix . const 
07:03:37 <lambdabot> c -> c
07:03:47 <Rembane> > (fix . const) 7
07:03:49 <lambdabot>  7
07:04:25 <whataday> is that true?
07:04:35 <phadej> @src fix
07:04:35 <lambdabot> fix f = let x = f x in x
07:04:40 <phadej> @src const
07:04:40 <lambdabot> const x _ = x
07:04:45 <phadej> substitute and simplify
07:04:49 <phadej> good exercise
07:05:02 <phadej> @src (.)
07:05:03 <lambdabot> (f . g) x = f (g x)
07:05:41 <Rembane> :i (.)
07:06:03 <Rembane> I was hoping lambdabot knew the info command. 
07:06:16 <whataday> :info (.)
07:06:33 <Rembane> Anyway, it's defined in the prelude. 
07:06:54 <whataday> const f = f'; fix f' = f;
07:07:12 <whataday> so I wonder fix . const = id?
07:07:39 <whataday> > fix . const $ (+1)
07:07:41 <lambdabot>  <Integer -> Integer>
07:08:06 <Rembane> whataday: I say yes, but for real understanding, do what phadej suggested. 
07:09:11 <whataday> can we say const and fix are isomorphic?
07:10:11 <whataday> WriterT and runWriterT are isomorphic?
07:10:37 <whataday> Just and fromJust are isomorphic?
07:11:09 <kuribas> fix . const = \x -> fix (const x) = \x -> fix (\f -> x)
07:11:37 <kuribas> :t fix const
07:11:38 <lambdabot> error:
07:11:38 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ b -> a
07:11:38 <lambdabot>       Expected type: (b -> a) -> b -> a
07:11:48 * hackage multistate 0.8.0.3 - like mtl's ReaderT / WriterT / StateT, but more than onecontained value/type.  https://hackage.haskell.org/package/multistate-0.8.0.3 (lspitzner)
07:12:46 <phadej> kuribas: don't spoil the fun
07:13:08 <phadej> kuribas: exercises are meant to be done yourself, reading solutions of the screen is really not the same
07:13:19 <kuribas> phadej: right ...
07:13:24 <kuribas> didn't know it was an exercise
07:41:12 <Heffalump> TIL that I can't write Maybe (Lens ...) because of impredicativity. Is there a standard workaround/wrapper type?
07:47:24 <wavemode_> couldn't you pull out the type variables manually, i.e. `type MaybeLens s t a b = Maybe (Lens s t a b)`
07:48:47 <Heffalump> I don't think the type alias would work, as they just get inlined
07:49:27 <Heffalump> (just checked) indeed it doesn't
07:50:45 <wavemode_> ah ok
07:52:03 <whataday> what's CoYoned?
07:53:07 <phadej> Heffalump: use `optics`
07:53:18 <phadej> but more to the point, yes, `ALens`
07:53:51 <ski> Heffalump : Church ?
07:53:52 <phadej> also ReifiedLens iirc
07:59:25 <Heffalump> phadej: I did briefly mentally consider optics, but my code is bought in to lens for now :-) Thanks for the ALens/ReifiedLens info.
08:00:20 <Heffalump> think it has to be ReifiedLens, ALens would imply some kind of CPSing wouldn't it?
08:00:32 <ski> Heffalump : that is, instead of `blah :: ... -> Maybe (Lens ...)', could you do `blah :: forall o. ... -> o -> (Lens ... -> o) -> o' ?
08:01:43 <Heffalump> ski: right, that's how I understand ALens.
08:01:54 <Heffalump> but only from skimming the doc
08:02:38 <Heffalump> I find the lens documentation very hard to get anything out of, for someone who doesn't already know lens well.
08:03:18 <Heffalump> oh, I take it back, I didn't read the second line of the documentation. Yes, looks like ALens would also have worked, no need for CPS.
08:03:48 <phadej> Heffalump: that's the problem with `lens`
08:03:52 <phadej> you have to know it to use it.
08:04:14 <phadej> The amount of documentation will be much larger than the code
08:04:19 * hackage ghcid 0.8.7 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.8.7 (NeilMitchell)
08:04:47 <Heffalump> maybe I'll switch this code to optics soon :-)
08:06:46 <phadej> as in, no-one even tries to hide implementation details of lens from public API
08:06:52 <phadej> so you just have to know how it's built :)
08:07:07 <Heffalump> I think the documentation could be clearer though
08:07:19 <phadej> constructive improvements will be appreciated
08:07:37 <phadej> "improve documentation" issues will be however closed as non-actionable
08:07:49 <Heffalump> right, I was just moaning, not raising tickets :-)
08:07:51 <dolio> Hmm, is the main disadvantage that you have to depend on the library to define optics? (I.E. that isn't really much of a disadvantage. :))
08:08:18 * hackage fakedata 0.7.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.7.0 (psibi)
08:08:59 <phadej> dolio: yes, there is that constraint. See https://hackage.haskell.org/package/optics-0.3/docs/Optics.html#g:4
08:09:12 <Heffalump> But I mean, the module that defines the core type has this as the two first lines:
08:09:17 <Heffalump> A Lens s t a b is a purely functional reference.
08:09:22 <Heffalump> While a Traversal could be used for Getting like a valid Fold, it wasn't a valid Getter as a Getter can't require an Applicative constraint.
08:09:25 <dolio> Yeah, I was reading that.
08:09:30 <Heffalump> The first line, I get. The second line, wtf?
08:09:44 <Heffalump> where did Getting come from? What's Getter?
08:09:59 <phadej> Heffalump: haddocks are not meant to read linearly
08:10:11 <phadej> it's impossible to structure them in that way
08:10:37 <wavemode_> some libraries include a Lib.Tutorial module for that purpose
08:10:49 <phadej> the https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens.html documentation is blunt
08:10:57 <phadej> and there one definitely can easily improve
08:11:08 <Heffalump> I would at least expect that any particular haddock - either a module comment or a type comment - would at least have some logical flow to it.
08:11:10 <phadej> but nobody is making PRs!
08:12:19 <wavemode_> for example https://hackage.haskell.org/package/pipes-4.3.13/docs/Pipes-Tutorial.html
08:12:49 <phadej> FWIW, today I merged a documentation PR to recursion-schemes, slightly improving its docs.
08:12:57 <phadej> it's still not a tutorial how to use that package
08:13:18 <Heffalump> I'm not expecting a tutorial. And sure, I should stop whinging and start editing.
08:37:26 <mrg> Hello!
08:37:40 <mrg> New to IRC
08:37:58 <mrg> Is this where froendly Haskell people hang out on the internet?
08:39:03 <[exa]> Well, yeah, subset of them.
08:39:05 <mrd> yes!
09:02:57 <merijn> hmm, if I suspect inlining will improve things should I start with just INLINABLE or just jump straight to INLINE?
09:04:17 <monochrom> What does the GHC user guide says about what they mean?
09:04:54 <merijn> monochrom: INLINABLE ensures the function is dumped into the interface (so that it can be inlined) INLINE *always* inlines
09:07:40 <Ariakenom> poor mrg DCed and missed responses
09:08:41 <dolio> Inlinable can have other nice effects that might improve performance without actually inlining.
09:08:53 <dolio> Like, the ability to specialize based on use-site types.
09:09:46 <merijn> dolio: These aren't polymorphic, though
09:10:32 <dolio> Oh, how large are they?
09:12:48 <merijn> most are pretty tiny (some aren't), so I'm inclined to just INLINE, but I haven't really played with either enough to really know what I'm doing
09:13:17 <merijn> And GHC not tracking foreign calls is making a lot of this kinda guess work too
09:13:48 <dolio> Well, if they're small, GHC might decide to inline it if it can. But maybe it's just better to INLINE anyway.
09:15:13 <merijn> dolio: They're in a different package and according to the profile don't seem to be inlined
09:15:25 <merijn> So GHC doesn't seem to inline them currently
09:18:48 <timCF> Hi! In Haskell is there any best practices of type/value namings? For example if I have `foo :: (Bar a, Buz b) => a -> b -> c` is it good practice to write `foo a b = blabla`  or better `foo x y = blabla` or it does not matter much? 
09:22:46 <monochrom> It does not matter.
09:23:41 <monochrom> Half of the people get confused by the former, the other half get confused by the latter. You may as well toss a coin.
09:24:48 <monochrom> And what if bar :: a -> a -> a? You can't go bar a a = a now.
09:25:31 <monochrom> I lied about half and half. It's more like one third and another one third.
09:25:49 <monochrom> For there is the final one third who are just religiously against "meaningless" names.
09:26:02 <hpc> you usually have more meaningful names at your disposal than a, b, c too
09:26:11 <yushyin> how about 'a' and '𝖺' ;D
09:26:13 <monochrom> even for type parameters
09:26:27 <monochrom> QED
09:27:40 <timCF> sure, I personally think that x y z are less confusing for me, but if I'm defining some big function - I'm running out of meaningful letters pretty soon. With naming where values can have the same names as type parameters - it's at least twice better)
09:28:13 <monochrom> If you run out of the a-z sequence, consider the aa-zz sequence :)
09:28:58 <monochrom> Don't forget the Greek letters either. A few alphas and lambdas can do wonder.
09:29:12 <timCF> I mean, x y z was just an example, usually it's something like this
09:29:22 <yushyin> or u+1d5ba to u+1d5d3
09:29:23 <maerwald>  unicode to the rescue
09:30:11 <monochrom> bar :: a -> a -> (a,a); bar alpha α = (α, alpha)
09:31:56 <dolio> I've never written a function with enough completely arbitrary parameters to run out of letters.
09:32:04 <hpc> foo e Ә = ꬱ a e Ә
09:32:41 <dolio> So it seems like this probably isn't a real issue.
09:32:47 <timCF> I mean not just letters, but meaningful letters) https://github.com/tkachuk-labs/show-safe/blob/80a92491f904fce52a33ac3bcf5683cc0d0ddbb8/src/ShowSafe/Class.hs#L116-L132
09:34:01 <timCF> for example `HashAlgorithm h` represents type class where `h` is type, and at the same time `h`  is value as well
09:35:18 <dolio> But elsewhere you called it 'alg', which is fine.
09:38:15 <dsal> Short identifiers for short functions are great.  Long identifiers for short functions are kind of terrible.  Long functions are pretty bad.
09:50:46 <hyperfekt> Has anyone gotten cabal's --cabal-file parameter to work? Mine seems to ignore it...
10:06:19 * hackage telegram-types 0.4.1 - Types used in Telegram bot API  https://hackage.haskell.org/package/telegram-types-0.4.1 (Poscat)
10:18:19 * hackage lightstep-haskell 0.10.3 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.10.3 (DmitryIvanov)
10:59:44 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1269321790016364544?s=20 i painted
11:00:33 <DigitalKiwi> like a month ago but didn't post the finished one until now
11:21:57 <heatsink> nice painting
11:46:49 * hackage shake-plus 0.1.5.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.5.0 (locallycompact)
11:48:19 * hackage ghc-check 0.5.0.1 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.5.0.1 (PepeIborra)
11:51:16 <lep-delete> i've made something similar for my backpack)
12:03:02 <sm[m]> using a derived aeson ToJSON instance for Map, the generated json uses lists instead of objects, and the derived FromJSON instance can't read it. I wonder why, and what is a good workaround ?
12:11:54 <yushyin> afaik it is because the ToJSONKey instance defaults to a json value rather than a json text. You'll need to implement ToJSONKey for your custom type.
12:12:42 <Boarders> is there a name for the law for afunction: cmp :: a -> a -> Ordering that says cmp x y = LT =< cmp y x = GT?
12:13:07 <Boarders> it is implied by anti-symmetry if you have an ordering
12:32:39 <kuribas> theres no shortcut for @do x <- a; y <- b; c x y@ is there?
12:33:17 <ChaiTRex> @undo \ a b -> do { x <- a; y <- b; c x y }
12:33:17 <lambdabot> \ a b -> a >>= \ x -> b >>= \ y -> c x y
12:33:26 <ChaiTRex> @. pl undo \ a b -> do { x <- a; y <- b; c x y }
12:33:27 <lambdabot> (. ((. c) . (>>=))) . (>>=)
12:33:31 <kuribas> erm ...
12:34:13 <kuribas> do y <- b; c x =<< x
12:34:42 <c_wraith> :t (join .) . liftM2
12:34:44 <lambdabot> error:
12:34:44 <lambdabot>     • Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
12:34:44 <lambdabot>       Expected type: (a1 -> a2 -> a) -> m a1 -> m (m a)
12:34:46 <kuribas> @pl a >>= \ x -> b >>= \ y -> c x y
12:34:47 <lambdabot> (b >>=) . c =<< a
12:35:17 <ChaiTRex> @src liftM2
12:35:17 <lambdabot> liftM2 f m1 m2 = do
12:35:17 <lambdabot>     x1 <- m1
12:35:17 <lambdabot>     x2 <- m2
12:35:17 <lambdabot>     return (f x1 x2)
12:35:59 <c_wraith> :t ((join .) .) . liftM2   -- please don't use this.
12:36:01 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
12:36:13 <kuribas> :t \a b c -> join $ liftM2 c a b
12:36:15 <lambdabot> Monad m => m a1 -> m a2 -> (a1 -> a2 -> m a) -> m a
12:38:54 <kuribas> not sure if this is obfuscation...
12:39:22 <kuribas> I have:  do t1 <- freshTerm; t2 <- freshTerm; inferLam2 name0 expr0 Nothing t1 t2
12:39:53 <kuribas> versus: join $ inferLam2 name0 expr0 Nothing <$> freshTerm <*> freshTerm
12:40:36 <c_wraith> the do expression is a lot more readable there
12:40:48 <kuribas> I think so too
13:14:56 <koz_> Yeah, keep the do.
14:02:16 <ski> @tell kuribas if you define `infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> (m a -> m b); mamb <*>> ma = join (mamb <*> ma)', then you could say `inferLam2 name0 expr0 Nothing <$> freshTerm <*>> freshTerm'. in general, `f <$> ma <*> mb <*> ... <*> my <*>> mz'
14:02:17 <lambdabot> Consider it noted.
14:18:18 * hackage shake 0.19.1 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.19.1 (NeilMitchell)
14:46:19 * hackage list-zipper 0.0.10 - A list zipper  https://hackage.haskell.org/package/list-zipper-0.0.10 (TonyMorris)
15:09:22 <andrei> Is there a timeline for when stackage nightlies will migrate to 8.10? 8.10.1 has been out for a while. Just wondering, because I have to use the new low-latency collector.
15:20:02 <DigitalKiwi> heatsink: thanks
15:25:27 <EvanR> ghc has a low-latency GC? cool
15:25:50 <EvanR> let the MMO RTS FPS games begin
15:27:07 <sm[m]> holy sh*t, thought I knew how big my ~/.stack was but not 38G..
15:30:33 * sm[m] will pay money for stack gc
15:34:19 <EvanR> more or less than for a bigger hdd
15:38:57 <hexagoxel> stack already supports nix, and nix has working store gc. but I guess you are looking for a workflow that does not require additional confusing setup..
15:44:19 * hackage calamity 0.1.12.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.12.0 (nitros12)
16:20:19 * hackage calamity 0.1.13.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.13.0 (nitros12)
16:59:54 <slack1256> Has anyone used the `seqaid` package? What has been your experience?
17:01:16 <ja> oh my, that package sounds amazing
17:02:51 <sm[m]> hexagoxel: correct!
17:03:20 <sm[m]> EvanR: macbook, bigger hard drive is right out
17:03:40 <sm[m]> it's easy to clean with ncdu, but 
17:15:12 <dsal> I started doing the nix thing.  My ~/.stack is 13GB.  I'm not sure how this is supposed to work. heh
17:15:20 <EvanR> so memory access is basically O(1) on macbook due to max hdd
17:15:42 <EvanR> beating windows which can be continually upgraded
17:37:26 <sm[m]> though, to be fair, this was on the VPS not the macbook. So I could totally pay money for more disk space. Certainly not doing that
18:11:49 * hackage miso 1.6.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.6.0.0 (DavidJohnson)
19:39:18 * hackage xml-types 0.3.7 - Basic types for representing XML  https://hackage.haskell.org/package/xml-types-0.3.7 (StephenWeber)
22:15:16 <ja> i am trying to use --with-ld=clang, but it seems not to be affecting the linker command line
22:15:28 <ja> i set it with ghc-options in my cabal file
22:15:46 <ja> what could be the issue? i need it for memorysanitizer
22:30:55 <noided> Is there any way to install Haskell Platform without the whole chocolatey nonsense?
22:41:18 * hackage web3 0.9.1.0 - Web3 API for Haskell.  https://hackage.haskell.org/package/web3-0.9.1.0 (akru)
22:48:52 <shafox> does cabal 3.2* set default to new-style ?
22:54:31 <shafox> I meant the v2-prefixed commands. 
23:00:14 <c_wraith> yes
23:00:45 <c_wraith> cabal-install versions 3+ use v2 commands by default
23:07:49 <shafox> thank you. :) 
23:12:17 <shafox> One more: cabal sandbox is used when using cabal-install version 3+ with every command ? 
23:16:47 <shafox> I am sorry, looks like there is only v1-sandbox not v2-sandbox. Is it safe to believe that whenever cabal build used it will be sandboxed as per the nix-style local build ? 
23:18:19 <sclv> yes
23:18:23 <sclv> v2 is auto-sandboxed
