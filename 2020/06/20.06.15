01:06:02 <kuribas> what does make GADTs so hard to implement?  Don't they just make constructors more like regular functions?
01:06:11 <kuribas> or is the pattern matching which is harder?
01:11:15 <dminuoso> kuribas: The fact that you can write something like
01:11:35 <dminuoso> % data Foo a where FInt :: Int -> Foo Int; FChar :: Char -> Foo Char
01:11:36 <yahb> dminuoso: 
01:11:53 <dminuoso> And then write a function `f :: Foo a -> a`, and have everything type check at the end
01:13:01 <dminuoso> Specifically, in Haskell the difficulty arises that it's inexpressible in System F, which is why System FC was invented.
01:13:01 <kuribas> hmm
01:13:12 <dminuoso> (Or rather in GHC Haskell I should say)
01:13:50 <kuribas> "forall a . Foo a -> a" means it will accept any "Foo a"
01:14:10 <kuribas> but I suppose it works because there are only Foo Int and Foo Char
01:14:19 <lortabac> kuribas: they introduce a kind of bidirectionality in the constraints. With GADTs some constraints are expected and some are "given" by the constructor
01:15:40 <kuribas> how is that different from a function?
01:16:43 <dminuoso> kuribas: Well the thing that makes it special, is that you can write something like `f :: Foo a -> a; f x = case x of FChar x -> toUpper x; FInt x -> x + 1` - you need to express what's happening here in your type system
01:16:50 <dminuoso> For example
01:17:12 <tdammers> the syntax is the easy part about GADT impl
01:17:45 <dminuoso> kuribas: Essentially, give this paper a read https://dl.acm.org/doi/pdf/10.1145/1190315.1190324
01:18:13 <merijn> Everythin si easy if you handwave what it does ;)
01:25:57 <kuribas> "si easy" => spanglish?
01:49:45 <ab9rf> more like egnlihs
01:58:05 <lortabac> kuribas: with ordinary functions, there is no such thing as "bringing constraints into scope". Constraints are predetermined statically via type class instances. With GADTs, constraints can be embedded into values, and brought into scope by pattern matching
01:59:18 <kuribas> lortabac: ah, you mean constraints on type variables, not type classes?
02:00:55 <lortabac> data Foo a where MkFoo :: Foo Int is desugared to data Foo a where MkFoo :: (a ~ Int) => Foo a
02:06:44 <dminuoso> kuribas: Conider the extension ConstraintKinds, where you can make something like `data Dict :: Constraint -> * where Dict :: a => Dict a`
02:07:36 <dminuoso> Now, (and old version of) constraints can do: `withDict :: Dict a -> (a => r) -> r; withDict d r = case d of Dict -> r` - the entire trick here relies on constraints brought into scope by pattern matching
02:51:54 <timCF> Hello! I'm curious, is there any good Haskell library to write interactive server-side rendering *interactive* web applications. To write just Haskell without thinking how do you handle client-server boundary. Something like this (Erlang/Elixir library) https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html
02:52:41 <Cheery> that is a nice question.
02:53:39 <Cheery> I saw some standalone web-app stuff when examining GUI options for Haskell, but I really do not know otherwise.
02:54:19 <Cheery> http://wiki.haskell.org/Applications_and_libraries/GUI_libraries
03:02:21 <srk> timCF: Miso
03:02:30 <srk> https://haskell-miso.org/
03:04:23 <timCF> srk well, it's client-side only. LiveView is fundamentally different - it's still server-side rendering templates, but they are fully interactive with both server or client events at the same time. With miso you still need to solve boundary server-client issue 
03:05:09 <srk> no it's not
03:05:33 <srk> timCF: https://github.com/FPtje/miso-isomorphic-example
03:06:08 <srk> maybe not exactly like LiveView but it allows you to write shared code for both server and client
03:06:09 <timCF> srk hmm interesting, I'll take a look
03:06:10 <hc> https://todo-mvc.haskell-miso.org/ <-- RLS certificate issue
03:06:14 <hc> s/RLS/TLS/
03:06:22 <srk> dmj`: ^
03:22:30 <zincy_> Wow, learning math makes you realise how wonderful Haskell is
03:23:00 <zincy_> Not news to most of you I know :D
03:37:18 * hackage commander-cli 0.4.1.1 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.4.1.1 (sgschlesinger)
03:40:05 <Cheery> zincy_: what kind of math?
03:45:21 <Orbstheorem> Hi. How can I have `stack build --file-watch --exec /path/to/daemon` kill and restart the daemon every time the file changes?
03:45:59 <timCF> really cool idea behind this library https://github.com/pkamenarsky/replica
03:57:13 <zincy_> Cheery, starting off with Discrete maths mainly
03:57:40 <zincy_> Getting to grips with logic and proof methods right now
03:57:51 <zincy_> Don't know many things I can prove though haha
03:59:57 <merijn> zincy_: I'd say learning Haskell makes you realise how wonderful math is ;)
04:00:11 <Orbstheorem> zincy_: If you'®e starting, proving merge sort is fun ^^
04:02:01 <zincy_> It is so weird, at school I never connected with Math, but after 2 years of Haskell Maths just seems exhilarating
04:02:31 <Orbstheorem> Rigidity?
04:02:41 <zincy_> What do you mean?
04:03:39 <Orbstheorem> As in, when I had discrete math at school, they only showed us a way without really giving us flexibility on how to solve it, which made it very tedious.
04:03:54 <zincy_> Right
04:04:15 <zincy_> Follow the algorithm don't understand the actual objects or structure
04:04:50 <zincy_> Maybe what we are told at school is math is not *really* math, it is following recipes
04:04:59 <zincy_> *taught
04:05:52 <zincy_> Is it just me or is Discrete Maths and Logic more accessible than Analysis?
04:06:06 <zincy_> I look at analysis and wouldn't know where to begin with proofs
04:07:06 <merijn> zincy_: Discrete math, logic, and proofs are more creative and free form
04:07:51 <Orbstheorem> zincy_: I think it depends, I agree with you, but I also know people who find it harder.
04:09:11 <Orbstheorem> merijn: Analysis is also pretty free under a set of rule. After you do the trivial examples, one of the hardest parts is imagining and trialing solutions. Though a difference is that sometimes trying a solution that fail does not give you any insight on a better solution.
04:09:25 <Orbstheorem> Anyone for my stack question? :(
04:13:36 <srk> Orbstheorem: pkill?
04:24:06 <Orbstheorem> srk: I wanted stack to kill it, but I ended up adding a binding in my editor to kill the app and save the file
04:28:10 <srk> Orbstheorem: well, that's what I've meant - instead of start server bin, point it to a script that does pkill .. ; /bin/server
05:02:18 * hackage pandoc-plot 0.7.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.7.0.0 (LaurentRDC)
05:12:59 <dminuoso> School does rarely teach math, they just mental arithmetic for many years - maybe randomly confuse students with induction proofs, expect you to memorize derivations of functions...
05:22:21 <timCF> Is there any big advantage of STM in Haskell over ordinary MVar? I usually used just MVar when I need to communicate between threads somehow, but I have seen a lot of people are using STM as well. Is it cooler?
05:23:09 <zincy_> dminuoso: 100% agree
05:29:11 <jumper149> How is it possible, that the only mtl-transformer with an MonadUnliftIO instance is ReaderT, but when I look at MonadBaseControl IO, almost every transformer has an instance?
05:30:58 <kuribas> merijn: solving integrals requires a lot of creativity
05:42:22 <turion> jumper149, MonadBaseControl has more data than MonadUnliftIO
05:43:20 <turion> It has this StM type family which allows to change the output type
05:43:41 <turion> MonadUnliftIO doesn't have that flexibility
05:44:02 <turion> timCF: STM is safer in some ways
05:44:22 <turion> well, I should say STM allows you to do more operations in safe ways
05:44:57 <jumper149> Ahh, I think I get it now, ty! 
05:45:41 <turion> timCF: Compare e.g. Chan vs. TChan: https://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Concurrent-Chan.html https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TChan.html
05:45:58 <timCF> thanks!
05:46:08 <turion> TChans allow you to tryReadTChan or tryPeekTChan. This is not possible in a usual Chan
05:46:24 <turion> (I think it used to be possible but was unsafe and was removed)
05:47:30 <dminuoso> jumper149: Do take note, that MonadUnliftIO works for things isomorphic to ReaderT as well (say LoggingT). Essentially MBC has special edge cases that lead to quirky bugs.
05:48:12 <turion> Basically, whenever you use STM and then transform your STM to IO using atomically (https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Monad-STM.html#v:atomically) and no dirty tricks, you're safe from all the usual concurrency bugs
05:49:45 <jumper149> dminuoso: I don't really understand that, MBC has bugs?
05:49:54 <frdg> parsing question: https://pastebin.com/9uAUb9Bb
05:56:43 <Tom33> Quick question. I try running `ghc -ddump-to-file -ddump-simpl -ddump-cmm main.hs`, but it doesn't dump extra files.
05:57:04 <Tom33> What am I doing wrong?
06:03:50 <turion> frdg: How about posting on stackoverflow? ;)
06:05:01 <frdg> turion: is this not a good place for longer questions? 
06:10:54 <turion> frdg: I guess you can still post on stackoverflow and link here
06:11:54 <turion> I mean, you're free to post wherever you want, I'd just believe that you might get more attention that way. Plus, formatting is nicer so it's easier to read
06:14:12 <frdg> turion: ok I will thank you
06:15:31 <dminuoso> jumper149: https://tech.fpcomplete.com/blog/2017/06/tale-of-two-brackets/
06:16:23 <lordgrenville> Hi all, I've just downloaded GHC with ghcup (curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh) and on trying to run ghc I get this error
06:16:26 <lordgrenville> <no location info>: error:
06:16:27 <dminuoso> Personally (I know some people in here disagree with me), I came to the conclusion, that globally only ReaderT (or things isomorphic to it) based stacks are easy to reason about.
06:16:29 <lordgrenville>     Warning: Couldn't figure out C compiler information!
06:16:31 <lordgrenville>              Make sure you're using GNU gcc, or clang
06:16:32 <lordgrenville> ghc: could not execute: x86_64-apple-darwin13.4.0-clang
06:16:59 <lordgrenville> As far as I can tell I do have both gcc and clang installed
06:17:11 <[exa]> lordgrenville: please use pastebin instead of copypasting stuff longer than 1 line
06:17:21 <lordgrenville> NOted for next time, sorry
06:17:26 <dminuoso> lordgrenville: Do you have xcode installed?
06:17:47 <lordgrenville> Yes
06:18:03 <[exa]> lordgrenville: nevermind. Anyway do you have the actual executable it's trying to find?
06:18:41 <lordgrenville> `which ghc` gives me `/Users/lordgrenville/.ghcup/bin/ghc`
06:19:06 <dminuoso> lordgrenville: Can you pastie the entire output from starting to finish in a gist/snippet/pastie?
06:19:29 <[exa]> lordgrenville: you want `which x86_64-apple......clang`
06:20:18 * hackage float128 0.1 - FFI bindings for C _Float128  https://hackage.haskell.org/package/float128-0.1 (ClaudeHeilandAllen)
06:21:16 <lordgrenville> sure, here it is https://pastebin.com/vC9xgKib
06:22:19 <lordgrenville> [exa] Oh I see, I get x`86_64-apple-darwin13.4.0-clang not found`
06:23:18 <[exa]> I'm completely unsure how the paths are resolved on mac but I'd assume ghc will expect that executable in PATH
06:23:31 <lordgrenville> so my clang targets `x86_64-apple-darwin19.5.0`, while ghc looks for `x86_64-apple-darwin13.4.0`
06:24:25 <[exa]> traditional unixy way to break/fix it: symlink it to the old version and hope :]
06:27:30 <lordgrenville> [exa] will give it a shot, thanks!
06:29:01 <lordgrenville> yeah `ln -s /usr/bin/clang /usr/local/bin/x86_64-apple-darwin13.4.0-clang` seems to have done the trick
06:30:36 <[exa]> great
06:30:55 <[exa]> hopefully it won't break any other stuff :]
06:32:19 * hackage nqe 0.6.3 - Concurrency library in the style of Erlang/OTP  https://hackage.haskell.org/package/nqe-0.6.3 (jprupp)
06:42:18 <dminuoso> Is there a version of Data.Text.breakOn that works on a prefix?
06:43:10 <dminuoso> Oh well I guess stripPrefix with a ViewPattern it is.
06:45:29 <lordgrenville> [exa] haha yup!
07:11:24 <dmj`> srk: thanks, AWS expired all my certs and wants me to pay to renew them. Will just use http for the examples.
07:11:45 <dminuoso> dmj`: lets encrypt is a thing :p
07:11:54 <dmj`> srk: https://haskell-miso.org uses letsencrypt certs so, everything else will be fine
07:12:17 <maerwald> that's life in the cloud
07:13:11 <dmj`> srk: yea, but for the static site examples I just want to upload them to an s3 bucket and distribute with a CDN. AWS should integrate more seamlessly with letsencrypt imo
07:18:53 <srk> makes sense
07:46:38 <dminuoso> Is there some dark and magic way to pass field selectors as first class values, such that you can use them to update a record?
07:47:21 <wavemode> a function with a HasField constraint is a firstclass value, no?
07:47:54 <dminuoso> Mmm, HasField just lets me read from a record
07:48:05 <solonarv> lens? or generic-lens?
07:48:27 <dminuoso> solonarv: I guess you are right.
07:48:52 <wavemode> ahh. yeah though the proposal to add setField as well was accepted a while back
07:48:57 <solonarv> with generic-lens you can write 'field @"fieldName"' and it means the lens into the field named 'fieldName'
07:49:21 <solonarv> (so you don't need to define lenses separately and can still refer to them in a convenient way)
07:51:27 <dminuoso> solonarv: Haha! I think I just intuitively re-derived lens. I was starting to get into the area of "hey.. I could just demand a function `forall f. Functor f => (a -> f b)` and then just pick the functor to Identity or Const...
07:51:51 <wavemode> it probably also wouldn't be too hard to write an equivalent function yourself via GHC.Generics, without adding an extra dependency
07:51:57 <dminuoso> Just pondering about that problem made me realize that lens is a somewhat obvious solution.
07:53:48 <dminuoso> lens is exactly what I want
07:54:18 <dminuoso> The fact that I can use them inside MonadState as well makes it a perfect fit.
07:54:31 <wavemode> lovely
07:58:54 <dminuoso> Now I just need to have text annotated optics..
08:07:18 * hackage req 3.3.0 - Easy-to-use, type-safe, expandable, high-level HTTP client library  https://hackage.haskell.org/package/req-3.3.0 (mrkkrp)
08:29:59 <maralorn> I always very much feel that typeclass instances are not first class values.
08:30:53 <dminuoso> maralorn: In GHC Haskell they are actually just dictionaries, so something like `f :: Foo f => f -> T` internally ends up with 2 arguments of sorts.
08:30:54 <ezzieyguywuf> is there an 'easy' way to check if an IORef has changed since the last time I read it? or would it be best to just wrap up a `hasChanged` boolean somewhere in the data type?
08:31:01 <dminuoso> (Unless specialization kicks in, of course)
08:31:18 <dminuoso> ezzieyguywuf: If that becomes interesting, consider whether maybe TVar is better.
08:31:45 <ezzieyguywuf> dminuoso: ok, I'll look at TVar
08:32:11 <ezzieyguywuf> specifically I have an infinite loop that draws things to the screen, but I don't want it to draw if nothing changed in the IORef that holds the data
08:32:23 <dminuoso> Ah, then TVars are not a good match
08:33:25 <dminuoso> ezzieyguywuf: You'd end up polling a lot then. :)
08:33:41 <ezzieyguywuf> dminuoso: I'd end up polling with the TVar you mean?
08:34:15 <dminuoso> ezzieyguywuf: Is that drawing a one-time action?
08:34:18 * hackage streaming-bracketed 0.1.1.0 - A resource management decorator for "streaming".  https://hackage.haskell.org/package/streaming-bracketed-0.1.1.0 (DanielDiazCarrete)
08:34:42 <dminuoso> That is, do you wish to draw something only once until the variable changes again?
08:35:09 <ezzieyguywuf> dminuoso: not sure I understand the question. I have an IORef GraphicData that contains a set of vertices to draw. The render should be called in the main loop any time GraphicData changes. Currently, it just redraws it every time
08:35:52 <dminuoso> ezzieyguywuf: Okay, so this gets into the very general design space. One way you could go about this, is by having a TQueue in which you push updates.
08:36:10 <ezzieyguywuf> ah hah, you are correct, this _is_ a more general design question
08:36:21 <dminuoso> And your finite loop reads from that TQueue (there's efficient blocking implemented), and calls render every time an item is popped off
08:36:28 <maralorn> dminuoso: I know. (From the great talk from lexilambda yesterday.)
08:36:38 <ezzieyguywuf> i like the idea of a queue!
08:36:49 <dminuoso> ezzieyguywuf: Make sure you use TQueue. :)
08:36:53 <maralorn> But just because they are first class values under the hood does not mean, that they behave like first class values to the programer.
08:37:12 <ezzieyguywuf> dminuoso: I'm thinking the TQueue concept will let me get rid of this IORef altogether
08:37:13 <dminuoso> maralorn: With constraints you can reify them as first class values!
08:37:18 <dminuoso> % :set -XConstraintKinds
08:37:18 <yahb> dminuoso: 
08:37:21 <ezzieyguywuf> if I'm understanding generally the idea
08:37:47 <dminuoso> % data Dict :: Constraint -> * where Dict :: a => Dict a
08:37:47 <yahb> dminuoso: 
08:38:03 <dminuoso> t :: Dict (Functor []); t = Dict
08:38:06 <dminuoso> % t :: Dict (Functor []); t = Dict
08:38:06 <yahb> dminuoso: 
08:38:15 <dminuoso> maralorn: There ^- you can now pass this around as a first class value!
08:38:44 <dminuoso> ezzieyguywuf: Using multiple worker threads communicating via tqueues is a frequent trick in Haskell.
08:38:48 * hackage long-double 0.1.1 - FFI bindings for C long double  https://hackage.haskell.org/package/long-double-0.1.1 (ClaudeHeilandAllen)
08:38:54 <maralorn> dminuoso: Yeah, totally useful.^^
08:39:19 <dminuoso> Do I detect sarcasm? :)
08:40:00 <dminuoso> That thing is actually usable, you can use reified instances to satisfy constraints and please GHC.
08:40:00 <maralorn> You do.^^
08:40:17 <dminuoso> % withDict :: Dict a -> (a => r) -> r; withDict d r = case d of Dict -> r
08:40:17 <yahb> dminuoso: 
08:40:19 <dminuoso> There you go
08:42:44 <ezzieyguywuf> dminuoso: you said "and your finite loop reads from that TQueue", did you mean "infinite"? And for the "read", were you thinking `peekQueue`, as this will continue to try reading until there is something to read?
08:43:30 <dminuoso> ezzieyguywuf: Not peek, but read.
08:44:05 <sm[m]> g'day all
08:44:06 <ezzieyguywuf> dminuoso: what does read return if there is nothing to read?
08:44:24 <dminuoso> ezzieyguywuf: It blocks. :)
08:44:40 <dminuoso> ezzieyguywuf: Best of all, it blocks in an efficient manner wrt to stm, that it's woken up when something writes to it.
08:44:42 <maerwald> sm[m]: my maan!
08:45:10 <dminuoso> Something like `go = r <- atomically (readTQueue q); renderUpdate r; go`
08:45:12 <dminuoso> Err
08:45:19 <dminuoso> `go = do r <- atomically (readTQueue q); renderUpdate r; go`
08:45:21 <ezzieyguywuf> interesting. I guess I'd use peek if I wanted to do other things even if there was nothing to render
08:45:50 <dminuoso> ezzieyguywuf: Probably tryReadTQueue rather
08:46:00 <ezzieyguywuf> right right
08:46:10 <ezzieyguywuf> but for now the basic loop you've outlined is likely all I need
08:47:21 <dminuoso> ezzieyguywuf: Heck, you can even play around in that transaction if you like.
08:47:23 <dminuoso> Say..
08:48:50 <dminuoso> `go = do { r <- atomically getUpdate; renderUpdate r } where getUpdate = do { r <- readTQueue; guard (isRenderRelevant r); pure r }`
08:49:24 <dminuoso> Well okay, that particular example is bad. My point is, you can play around in an STM transaction and just `retry` with low cost.
08:49:58 <ezzieyguywuf> I think I get the main point
08:52:22 <dminuoso> ezzieyguywuf: Some network protocols have surprisingly simple implementations when you use TQueues. So in one ldap library we use, we use one thread that infinitely reads bytes off a second, and chunks it into ldap messages. Then there's another tqueue that does the opposite for outbound data, and another one representing ldap requests - with threads juggling between those tqueues and sockets.
08:55:37 * ezzieyguywuf wonders what an ldap is
08:55:50 <ezzieyguywuf> I added the TQueue thing to my TODO, I was getting a bit sidetracked from the task at hand :-P
09:16:21 <maralorn> I just think the greatest thing about Haskell is, that nearly everything is a first class value. types, functions, lenses and especially programs/(IO) actions.
09:16:34 <maralorn> But typeclasses are not really.
09:17:26 <maralorn> So when you start putting your lenses in typeclasse things get hairy.
09:17:44 <tdammers> modules aren't first class either, and I hate that
09:17:49 <maralorn> Error messages degrade …
09:18:29 <maralorn> Importing/Exporting is implicit.
09:18:41 <maralorn> On the other hand having an own namespace for lenses seems very reasonable to me.
09:18:46 <maralorn> tdammers: That is true.
09:18:50 <maralorn> I agree very much.
09:26:58 <Hopplahase> tdammers: What would be a use case for first-class modules?
09:27:37 <dsal> You could list all the things in a module and do something with them.  You could treat a module like an object call M.someFunction.
09:30:25 <Hopplahase> dsal: If you qualify the module, you still have the latter
09:31:39 <dsal> Hmm...  Yeah, but I could pass M as m to a function that wants more than one someFunction.
09:32:27 <wavemode> first-class modules are usually used to implement typeclasses
09:35:21 <Hopplahase> If there are several modules exporting functions of the same name and type I see some use, but that seems like a rarely needed feature to me
09:35:32 <maralorn> You could take a module, ad how substitute some function and then pass it into another module.
09:36:00 <maralorn> s/ad how/ad-hoc/
09:36:17 <maralorn> I think first-class modules would be great.
09:36:21 <dolio> There are a bunch of modules that do exactly that in Haskell.
09:36:22 <wavemode> you could do the same via the "scrap your typeclasses" technique: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
09:36:59 <Tuplanolla> OCaml and Coq have module functors that allow you to pass in other modules that fit a certain signature.
09:37:44 <dolio> Maps, sets, vector types, string types.
09:37:48 <Tuplanolla> It's common to parametrize collections over some key, whose decidable equality and other properties are supplied by a module.
09:38:34 <dolio> I don't think it's very accurate to say that first-class modules are used to implement type classes, though.
09:38:54 <wavemode> note that I didn't say "only"
09:39:43 <dolio> They are often used to achieve similar results, but modules completely lack essential features of type classes.
09:43:04 <jchia_> hsc2hs question: In my stack project, I want to write a small C++ function that is called from Haskell. The C++ function's implementation uses C++ but the function is extern "C". The C++ function's source code is part of the project and I need to specify certain options that I would normally give to g++, e.g. -std=c++14 -Wl,rpath=... The input and output of the function is effectively a ByteString. Can this be achieved by using hsc2hs i
09:43:04 <jchia_> n stack?
09:44:16 <wavemode> cc-options and cxx-options are the relevant cabal flags
09:44:23 <wavemode> fields*
09:45:00 <wavemode> https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-cxx-sources
09:45:01 <maralorn> I think there is always a big difference between "you can technically do that in this language" and "this is an essential feature that will automatically be useful to the user without them seeking it out"
09:46:49 <wavemode> yeah but that's part of the point
09:47:30 <wavemode> if the technique is already possible, but rarely used, why would the introduction of a "blessed" compiler version of the technique change people's minds about it?
09:49:26 <maralorn> wavemode: Okay I guess there is a step in between.
09:50:24 <maralorn> the "you can do this ergonomically and usefully in this language"
09:50:34 <maralorn> If people don't use it in that state, okay, let's forget it.
09:51:39 <maralorn> It's like saying people won‘t use dependent haskell because there is already singletons and they don't use that all the time.
09:54:35 <wavemode> haha but that argument is perfectly valid. people who currently use singletons would certainly adopt a DependentHaskell extension. happily. plenty of people use singletons. similarly, people who currently emulate first class modules with various hacks, would certainly adopt a FirstClassModules extension. my contention is that there are very few people doing that
09:56:09 <maralorn> Well what are those hacks to have FirstClassModules? 
09:57:34 <wavemode> um well I haven't yet seen an example written with first class modules which couldn't be written either with typeclasses or with manual dictionaries ala "scrap your typeclasses"
09:57:36 <maralorn> (This questions asked out of pure curiosity.)
10:00:12 <maralorn> ﻿wavemode: But I am not really sure what point you are trying to make. You think we shouldn't have those language improvements because people seem to live fine without them?
10:00:44 <maralorn> (Of course this is assuming you are trying to make a point, which you totally don't have to …)
10:04:23 <dolio> How do I parameterize a whole module by a manual dictionary that I open once?
10:04:35 <dolio> Instead of parameterizing every function in the module by the manual dictionary.
10:05:02 <wavemode> maralorn: My opinion (which, hey, could be wrong!) is simply that, at best, such an extension would be a very marginal improvement to the language. At worst, nobody would really use it at all.
10:07:35 <monochrom> Text.Parsec.Token.makeTokenParser shows an example. In general RecordOfInputMethods -> RecordOfOutputMehtods
10:08:29 <monochrom> HOWEVER! This doesn't stop you from the inconsistency of mixing up output methods coming from two origins that shouldn't be mixed up.
10:09:01 <dolio> Yeah, "write your whole module in a where clause."
10:10:17 <dolio> Now you can't test any individual things in a repl.
10:11:25 <monochrom> That sounds contradictory to what I have been able to do all along.
10:17:45 <dolio> monochrom: How do I test caseString?
10:18:08 <monochrom> Where can I find out about caseString?
10:18:18 <dolio> It's in mkTokenParser, the thing you cited.
10:20:35 <monochrom> There is no caseString there.
10:20:48 <monochrom> Am I simply in the wrong universe?
10:21:40 <dolio> It's part of the definition of mkTokenParser.
10:21:48 <dolio> Not the record.
10:22:10 <monochrom> oh you mean the source code
10:22:24 <dolio> It's hidden in a where clause, so you can't refer to it directly to make sure it's working as expected.
10:24:30 <monochrom> Are you attributing it to the MyMethods->YourMethods idiom? Or isn't it what you get with using "where", even when you have simply "f :: Int -> Bool; f x = not y where y = x>0" so "how do I test y?"?
10:26:21 <dolio> I'm saying that `MyMethods -> YourMethods` has serious drawbacks for emulating parameterized modules.
10:26:30 <dolio> Because of how where clauses work.
10:27:41 <dolio> There are reasons why it's not great to put your entire module definition in the local scope of some other definition.
10:28:10 <monochrom> What if, if you want to test some helpers, you have make :: MyMethods->ExternalAndInternalMethods, and project :: ExternalAndInternalMethods->ExternalMethods, you only export project.make, but as a tester you have access to all of ExternalAndInternalMethods.
10:28:12 <dolio> And this explains why people wouldn't actually use it.
10:28:41 <monochrom> for example caseString would be part of ExternalAndInternalMethods
10:28:45 <wavemode> but that's a strawman. they did this because it worked for their use case. if they felt the need to test caseString, they could have defined it at the toplevel instead
10:31:47 <dolio> Defining it at the top level doesn't allow parameterizing all the definitions by a module at once, which is a primary feature.
10:32:35 <dolio> monochrom: Yeah, you can do that; manually implementing structure subtyping.
10:33:02 <monochrom> This is manually implementing modules already. May as well.
10:33:18 <monochrom> s/modules/module system/
10:34:01 <monochrom> Projection is like the least cringy part.
10:34:37 <monochrom> On second thought, let's turn the table around.
10:36:35 <dolio> I just don't think it's valid to say that people wouldn't use a better module system because they aren't prepared to sacrifice to manually emulate them in the current language.
10:37:56 <dolio> A better argument might be that people don't use backpack, but that also involves/involved sacrifices.
10:41:55 <monochrom> Takes me too long to write sample *ML code to turn the table around. But I was wanting to ask how is it different for *ML functors if you have unexported things.
10:43:14 <monochrom> functor F(X : MyMethods) :> ExportedMethods = ... some val/fun not in ExportedMethods ...  How do you test that?
10:43:53 <dolio> I don't know how ML environments behave. GHC allows you to call un-exported functions of a module if you load it in the right way in the repl, though.
10:44:25 <dolio> At least, as I recall.
10:47:23 <dolio> If the answer were that SML/NJ doesn't let you do that, I don't see how that means that you aren't giving up some features by emulating ML in Haskell.
10:50:27 <monochrom> May I butcher your sentence to s/some feature/very specifically the feature of testing an unexported helper/
10:50:42 <dolio> That's just one example.
10:50:48 <monochrom> I know I already gave up "some" feature. I even named one.
10:51:51 <monochrom> Time to say "I regret getting into this, why is everyone speaking obtusely"
10:52:44 <monochrom> If someone has source code in mind, it takes them like 5 minutes to say out loud they're referring to source code, and even very indirectly then.
10:53:56 <dolio> Why are you speaking so obtusely?
10:54:00 <monochrom> If someone happened to have chosen an example that doesn't work out, it takes them 15 minutes to admit it, and even then they just claim "I still have other cards to play" and even then declines to actually play any second card.
10:54:52 <merijn> monochrom: If no one knows what you mean you never have to admit being wrong!
10:54:59 <monochrom> They all speak like everyone is telepathic. And the irony is that if we are all telepathic, why say anything at all.
10:55:06 <dolio> I'm not even sure what you're arguing for. I was originally trying to give an example of something that first-class modules could accomplish nicely that cannot be accomplished nicely in Haskell.
10:55:21 <dolio> And I don't think mkTokenParser contradicts that.
12:02:38 <maerwald> so... mtl is finally trashed? 
12:03:02 <srk> yes!
12:04:23 <maerwald> now just wait 5 years for the ghc proposal to get accepted
12:04:42 <wavemode> which proposal is that?
12:05:49 * hackage shake-plus 0.1.7.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.7.0 (locallycompact)
12:05:56 <yushyin> wavemode: https://github.com/ghc-proposals/ghc-proposals/pull/313
12:06:16 <wavemode> oh that one
12:06:18 <typetetris> Didn't they compare to mtl without specializations and ` -fexpose-all-unfoldings`
12:07:15 <wavemode> I really have to wonder about all this - is the overhead of monadic bind really all that crippling in a real-world application (as opposed to in synthetic benchmarks)?
12:08:33 <typetetris> wavemode: Depends on the use case most certainly. If you make a database query, you probably don't notice hundreds of binds more or less, I would imagine.
12:08:44 <maerwald> typetetris: I don't think it matters much, since it still relies heavily on the optimizer then, which was the entire point of eff
12:08:54 <maerwald> to not do that
12:10:40 <maerwald> instead now you have primitives that are always fast, not just when the optimizations kick in
12:12:14 <typetetris> maerwald: I totally missed that.
12:12:19 <typetetris> maerwald: Thanks.
12:12:23 <srk> maerwald: I'm wondering how's the polysemy performance with polysemy-plugin enabled and -fspecialize-aggresively
12:12:52 <maerwald> srk: isovector already posted a response
12:12:57 <srk> guess I should try to benchmark that 
12:13:08 <srk> cool, as yt comment?
12:13:23 <yushyin> as a blog post
12:13:31 <ezzieyguywuf> is there a de facto way in haskell to 'do filepaths'?
12:13:34 <maerwald> https://reasonablypolymorphic.com/blog/mea-culpa/
12:13:41 <ezzieyguywuf> i.e. "give me a path as a string, I'll go open that file or something"
12:13:47 <srk> thanks
12:14:02 <solonarv> ezzieyguywuf: well, that's what the functions in base do already
12:15:03 <maerwald> ezzieyguywuf: on unix, use hpath :p
12:15:39 <ezzieyguywuf> meh, but I want cross platform. Maybe solonarv is right, and I just readFile and let base either succeed or fail
12:16:21 <maerwald> ezzieyguywuf: cross platform implementations are currently all broken
12:16:47 <solonarv> also, "file path as string" is fundamentally not cross-platform
12:16:48 <maerwald> better do one platform right
12:17:14 <solonarv> "C:\\some\\path" works on windows only, "/home/username/path" doesn't work on windows
12:17:42 <maerwald> and a bazillion other problems
12:18:01 <ezzieyguywuf> but if I have `someFunc :: String -> IO ()` that expects a path, it makes it the users' problem if they pass a bad path
12:18:10 <wavemode> sure but, filepaths are already platform dependent. you aren't going to install something to the same directory on windows as you would on unix
12:18:25 <ezzieyguywuf> right
12:18:35 <maerwald> ezzieyguywuf: which encoding? :)
12:19:37 <wavemode> so if you're specifically dealing with path separators and drives and things to manipulate paths, you run into those issues. but if you're just asking "what file do you want me to open?" a String (or ByteString) does the job
12:20:38 <maerwald> ezzieyguywuf: https://github.com/pcapriotti/optparse-applicative/issues/368
12:20:46 <maerwald> real problems
12:23:28 <srk> that response is nice, explains a lot. It should be relatively straightforward to migrate from polysemy to eff when ready I guess
12:25:23 <maerwald> srk: what??
12:25:38 <maerwald> An entire code base?
12:25:59 <yushyin> srk: https://github.com/polysemy-research/loopbreaker/issues/5#issuecomment-643747804 might be relevant
12:27:31 <Orbstheorem> Hi. I'm trying to use `deleteCascade` in persist with a sqlite-backed db, but I get error "No instance for (DeleteCascade User SqlBackend)" at compile-time. I'm doing the exercises of the web talk at lambdaconf 2015 (https://github.com/serras/lambdaconf-2015-web). I'm on exercise 3 task 5, where it suggests the use of `deleteCascade`.
12:30:39 <srk> maerwald: no, I mean projects built on top of polysemy 
12:31:01 <srk> yushyin: nice, thanks
12:31:33 <maerwald> srk: I understood that
12:32:46 <srk> ah, getting late :) /me off to bed o/
12:39:35 <maerwald> any opinions on reflex-vty vs bricksa
12:39:57 <maerwald> *brick
12:40:30 <Orbstheorem> maerwald: I couldn't get reflex-vty working :(
12:47:06 <grepcake> Hi! I have a minimal piece of code that doesn't compile for reasons. I would like to know whether it's possible to achieve what it's trying to do or why it's impossible. In short, the issue is with type relations/dependencies. https://gist.github.com/grepcake/ad9c7ed6d2fe6a6c13f63d4ec579f040
12:47:36 <grepcake> I would be glad for any help
12:49:07 <koz_> grepcake: What error(s) are you getting?
12:50:49 <grepcake> koz_: 
12:50:51 <grepcake> Ambiguous type variable ‘r0’ arising from a use of ‘entityValue’
12:50:52 <grepcake>       prevents the constraint ‘(DSLEntity
12:50:54 <grepcake>                                   r (LangL r0 Int))’ from being solved.
12:51:56 <grepcake> koz_: I've updated the gist to include the full error message
12:52:01 <koz_> Thanks.
12:58:53 <Orbstheorem> grepcake: I'm no expert, but I would say that the reduction `ValueOf (LangL r a) = a` will not be applied as you expect: I think the `ValueOf` kind in line 17 and line 21 is not the same. But I may be wrong.
13:03:10 <grepcake> Orbstheorem: I'm also no expert and I'll look into that. However, the compilation problem seemed clear to me. There is no dependency between `a` and `r`. So, ghc can't guess from just `LangL r0 int` that `r` in the DSLEntityt parameter is the same `r0`. 
13:04:06 <grepcake> It could have been solved by introducing a functional dependency between r and a. Indeed, if we remove instance for int and write `class DSLEntitity r a | a -> r`, it's going to compile
13:04:57 <grepcake> However, I also need an instance for Int and it can not satisfy the said dependency
13:07:02 <grepcake> Orbstheorem: I've added explicit kind for ValueOf, nothing has change. I guess it's the same actually.
13:08:13 <Orbstheorem> Adding the functional dependency implies that the missing type can be statically deduced, so if you add an Int instance, the r instance should also be known. I assume this is not the case.
13:08:38 <Orbstheorem> grepcake: Yeah, That's the conclusion I'm arriving to.
13:40:18 * hackage smuggler2 0.3.5.2 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.5.2 (jrp)
14:20:18 * hackage morley 1.4.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-1.4.0 (gromak)
14:20:49 <dmwit> grepcake: You probably want `instance r1 ~ r2 => DSLEntity r1 (Lang r2 a)` instead of `instance DSLEntity r (Lang r a)`.
14:21:18 * hackage lorentz 0.4.0 - EDSL for the Michelson Language  https://hackage.haskell.org/package/lorentz-0.4.0 (gromak)
14:21:52 <dmwit> grepcake: Currently, knowing that the argument to entityValue has type `Lang r a` isn't enough info to know we definitely want the `r`/`Lang r a` instance; we might want some other instance (not yet declared) that has `Lang r a` for the second argument but something different for the first argument.
14:22:37 <dmwit> (For example, you could write an `instance Bool (Lang String a)` later that would not overlap with either of these, but could potentially be the one you intended to use.)
14:22:52 <dmwit> o no
14:23:01 <dmwit> I was two minutes too late.
14:23:33 <dmwit> grepcake: You probably want `instance r1 ~ r2 => DSLEntity r1 (Lang r2 a)` instead of `instance DSLEntity r (Lang r a)`.
14:23:44 <dmwit> grepcake: Currently, knowing that the argument to entityValue has type `Lang r a` isn't enough info to know we definitely want the `r`/`Lang r a` instance; we might want some other instance (not yet declared) that has `Lang r a` for the second argument but something different for the first argument.
14:23:56 <dmwit> (For example, you could write an `instance Bool (Lang String a)` later that would not overlap with either of these, but could potentially be the one you intended to use.)
14:25:17 <dmwit> grepcake: Another thing you might want is to just throw the `r` parameter out of the class entirely, as in `class DSLEntity a where type ValueOf a; entityValue :: a -> LangL r (ValueOf a)`.
14:58:30 <grepcake> dmwit: Thank you very much! It is exactly the case. Adding the constraint solves the problem. In the real code I can't unfortunately throw away `r` easily
15:03:03 <_deepfire> maerwald: reflex-vty works and is pleasant, once you get past the initial hurdles of understanding
15:03:41 <_deepfire> the up-front investment into the FRP paradigm of thinking can be a steep cost, though..
15:04:58 <_deepfire> and yes, the implication is that for my taste brick is notably less pleasant to use -- requires quite a lot of plumbing to do, for no real gain
15:05:11 <_deepfire> at least with reflex-vty you know what you are suffering for : -)
15:07:28 <Orbstheorem> _deepfire: Do you know any projects using reflex-vty where to draw inspiration from?
15:10:28 <joelg> Hi - I'm developing a package with cabal using the v2-* commands, so packages are only installed locally to my project. Is there some way to get local documentation for locally installed packages? I used to do this with the global-style cabal.
15:10:44 <sm[m]> not many.. https://packdeps.haskellers.com/reverse/reflex-vty
15:14:44 <sm[m]> example code: https://github.com/reflex-frp/reflex-ghci/blob/develop/src-bin/ghci.hs, https://github.com/reflex-frp/reflex-ghci/blob/develop/src/Reflex/Vty/GHCi.hs
15:16:50 <monochrom> joelg: Somewhere under $HOME/.cabal/store
15:17:11 <ddellacosta> is it possible to work with a sum type like this? data Blah = Int | Thing
15:17:18 * hackage stratosphere 0.54.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.54.0 (jdreaver)
15:17:45 <monochrom> Does that "Int" mean a data constructor?
15:17:56 <ddellacosta> monochrom: no just a normal Int
15:18:14 <monochrom> Then you must add data constructors.
15:18:30 <monochrom> This is the reason "data Either a b = not simply a | b"
15:19:15 <ddellacosta> monochrom: yeah, I guess I'm trying to understand why that is, I still don't really get it.
15:19:25 <EvanR> if Blah = Int | Thing then 3 :: Int | Blah... confusing
15:19:32 <joelg> monochrom: There don't seem to be any documentation .html files anywhere under ~/.cabal/store
15:19:57 <monochrom> then you did not --enable-documentation at build time
15:20:09 <ddellacosta> EvanR: yeah I just tried to write a Num instance as an exercise and came away completely befuddled. So I get that it doesn't work, but I'm also somewhat confused as to what it is that prevents that...there's a layer I'm missing
15:20:33 <monochrom> the good news is that if you "cabal configure --enable-documentation" now and request to build again, you will get the docs there.
15:20:37 <EvanR> the type system as it stands prevents that. You could invent a new one that may make it make sense
15:21:37 <ddellacosta> EvanR: a new type system you mean? Yeah that's what I'm getting at, I wish I had a grasp of what it is in the type system that prevents that
15:21:57 <monochrom> Untagged union types beg more problems than they solve.
15:22:31 <ddellacosta> monochrom: tell me more please!
15:22:41 <dsal> It's better in C, because you don't can have a union with an int and a byte and a string.  Like, three data types in the space of one!
15:22:52 <dsal> WTF, English.
15:23:07 <ddellacosta> it happens to us all\
15:23:32 <monochrom> union types suffer the same type-inference-undecidable problems as subtypes
15:23:52 <ddellacosta> oh man this is starting to make sense finally
15:24:06 <dsal> In one way or another, you need to be able to tell what type you have.  Sometimes, you've got an   `Either Int Int` and you need to know whether it's left or right.
15:24:25 <monochrom> since, for example, if Blah is a union of Int and something, then Int is a subtype of Blah.
15:24:34 <dsal> I've done a few protocol implementations where I have an   `Either Packet Packet` where the format of the packet is the same, but the content can express success or error, and I just return it as an Either.
15:24:39 <joelg> monochrom: I've tried cabal v2-configure --enable-documentation, and rebuilt my project, but that just seems to build documentation for my project. Is there some way to build documentation for the modules that my project imports?
15:25:06 <ddellacosta> monochrom: that's super helpful, thank you
15:25:12 <ddellacosta> dsal: totally see what you mean
15:25:51 <monochrom> That's contradictory to what I found a few days ago. Changing configure options triggered full rebuild of dependencies for me.
15:26:13 <dsal> If you've used unions in C, you get the tagless variant, which is actually kind of neat.  I've used it for conversion before because you can have two representations of the same value (e.g. 32-bit int and IP address) and switch between them with all the type safety of C by just referencing the different field name.
15:27:30 <emmanuel_erc> So a coworker of mine the other day claimed that GHC cannot perform dead code elimination. I just want to know, how valid is this claim?
15:28:05 <dsal> GHC has been around for years, and I still have some old perl in one of my github repos.
15:28:23 <monochrom> Invalid.
15:28:33 <monochrom> Total BS.
15:28:40 <monochrom> cow orker
15:28:48 <dsal> https://wiki.haskell.org/GHC_optimisations <-- you can read more here
15:29:26 <dsal> Shouldn't the linker do further dead code elimination?
15:29:53 <dsal> I've never been a linker, but I thought that was part of the job.
15:30:12 <emmanuel_erc> ok, when I heard them say it, I didn't want to put my foot in my mouth, but it just felt out of sync with my experience with Haskell up until that point and also with my expectations of Haskell's evaluation model.
15:30:26 <emmanuel_erc> I should probably give them that link.
15:30:30 <monochrom> If you write a brand new linker, you can. But not the existing ones.
15:31:18 <monochrom> Existing linkers do a very coarse-grain unreferred code removal, and trust the compiler to mark the boundaries, and compilers mark fairly coarse-grain boundaries.
15:31:44 <dsal> If we let the compilers and linkers run longer, we can get slightly smaller binaries, though.
15:32:34 <monochrom> For example, if you put a.o, b.o, c.o into the same mylib.a, the linker can omit b.o iff nothing in b.o is used.
15:32:53 <monochrom> err that sentence is confusing
15:33:51 <monochrom> For example, if you put a.o, b.o, c.o into the same mylib.a, and then you have a program that uses mylib.a, linking your program against mylib.a can omit b.o if nothing in b.o is used.
15:34:13 <monochrom> However, if a.o contains a million functions, and you use just one of them, all of a.o is brought in.
15:34:30 <koz_> For a good example of something written with exactly what monochrom describes in mind, check out musl.
15:34:37 <monochrom> They decide that the linker won't bother doing further analysis and splitting of a.o
15:34:38 <dsal> Oh, I didn't realize it was that coarse.
15:35:02 <monochrom> So GHC offers two ways out, an old one and a new one.
15:35:08 <koz_> dsal: It's not great.
15:35:45 <monochrom> the old one is -split-objs, so that it's one foo.o per Haskell function.  but this also causes existing linkers to be slow.
15:36:24 <monochrom> (If you write a brand new linker, you can use an efficient algorithm. Google's gold linker did. But no one bothered before that.)
15:36:52 <koz_> monochrom: Does lld do this too?
15:37:02 <koz_> 'This' being 'be efficient like gold'.
15:37:23 <tabaqui1> Which drawbacks has global mask_ except of non-interruptable infinite recursion?
15:37:30 <monochrom> The new one is -split-sections. Apparently, a.o can be further subdivided into sections (compilers can mark these), and linker is happy to cherry-pick code at the section granularity rather than *.o granularity.
15:38:01 <monochrom> I don't know.
15:38:01 <tabaqui1> monochrom: sadly, it doesn't work on Windows
15:38:50 <tabaqui1> not sure about macos, but ghc on mac generates pretty compact code by default
15:40:53 <tabaqui1> ok, in other terms. If I have not heavy calculations and all recursive calls are verified, could "mask_" be a source of problems?
15:41:15 <tabaqui1> my code is highly concurrent, if it is important
15:42:02 <tabaqui1> still, I can't imagine what can go wrong if mask state will be inherited
15:48:30 <joelg> So I used to have some collection of docs in ~/Library/Haskell/... called "Haskell modules on this system" which just sort of accumulated all of the stuff that Cabal had installed into one place. Is there a way to get that sort of a documentation-and-index for the set of dependencies of a cabal v2-* project?
15:48:44 <monochrom> No.
15:50:03 <joelg> Surely it's somehow doable - the IDE tools I have installed manage to collect documentation for all of the depended-on packages ...
15:50:26 <monochrom> Low priority because of the everything-is-on-the-web millenials.
15:51:37 <monochrom> If we can gang up with a mad scientist to cause a world-wide internet blackout, then afterwards the cabal devs will take local doc building more seriously.
15:52:21 <monochrom> Everything you desire is doable, even cheaply doable. But people have opposite values.
15:52:32 <joelg> To be clear, it's specifically a limitation of the v2-* commands? The global-style builds seem to do it just fine
15:53:00 <tabaqui1> Uh, but isn't that haddock's responsiblity?
15:53:23 <monochrom> Research in dependent haskell is much harder and more expensive than endowing v2 local doc organization. Guess which one people prefer to work on.
15:53:30 <tabaqui1> Not quite understand the question, but haddock generates html pages for any modules in the system
15:53:39 <monochrom> Yes it's specifically v2.
15:54:02 <joelg> tabaqui1: If there is some haddock-build-all-my-dependencies-documentation-and-index command I am all ears
15:57:06 <monochrom> tabaqui1: In the v1 days cabal-install updates a $HOME/.cabal/share/doc/<ghc version>/index.html of all links to all module docs.
15:57:51 <monochrom> And even if it didn't, URLs to individual package/module docs were very predictable and guessable.
15:59:02 <monochrom> v2 doesn't generate a similar index.html, and ensures that pathnames are  cryptographical grade unguessable.
16:00:31 <monochrom> If you haven't known of v1's index.html, that's one more data point in support of my "everything-is-on-the-web millenials". Sorry!
16:01:31 <tabaqui1> uh, I missed the point. What does "stack haddock" in this context?
16:01:46 <monochrom> The omission can be trivially fixed. It is the same solution as "make symlinks for the exes" v2 is already doing.
16:01:58 <monochrom> In this context there is no stack.
16:02:22 <monochrom> But research in dependent haskell is much more valuable than a v2 index.html
16:03:58 <monochrom> And I don't know stack anyway.
16:05:19 * hackage hpc-lcov 1.0.1 - Convert HPC output into LCOV format  https://hackage.haskell.org/package/hpc-lcov-1.0.1 (leapyear)
16:05:36 <monochrom> Is there any mad scientist who want to cause a 3-month Internet blackout? I'll join them.
16:08:14 <joelg> I just thought that in all this nix-style stuff where there is such an emphasis on being able to specify versions there would be an easy way of finding all documentation for specific versions - having to look it up online seems at odds with the goal
16:09:18 * hackage hnix 0.9.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.9.0 (AntonLatukha)
16:09:23 <monochrom> In time, even online docs---the systematic, organized kind---won't have values.
16:10:08 <dmwit> joelg: If you want haddocks for all your dependencies, you must specify it in a cabal.project.local file.
16:10:13 <monochrom> Just look at how young people look for "blogs", "tweets", stackoverflow "answers", and chatrooms just to ask "how to use scanl".
16:10:20 <dmwit> The syntax is something like `package *\n\tdocumentation: True`. Then rebuild.
16:10:24 <_deepfire> joelg: hoogle indexes can be auto-generated by Nix
16:11:05 <monochrom> In other words they value ad hoc hearsay, not systematic docs.
16:11:06 <joelg> dmwit: running cabal v2-configure --enable-documentation added that line, but rebuilding didn't create any docs in dist-newstye/* or ~/.cabal/* as far as I could tell
16:11:13 <dmwit> joelg: --enable-documentation at configure-time is not enough, because it only enables documentation for local packages.
16:11:30 <dmwit> joelg: Hm.
16:11:55 <dmwit> joelg: That is not what --enable-documentation *used* to do. Are you sure? Could you paste your cabal.project.local online somewhere for us to see?
16:12:02 <joelg> dmwit: Actually, _some_ docs were created in ~/.cabal/, but not for any of my direct dependencies
16:12:05 <_deepfire> in fact, that's one of the great features of Nix/nix-shell with Haskell -- you enter a particular shell, and you get an automagic Haddock index made by hoogle -- specifically for your versions of packages.
16:12:13 <monochrom> I also got my "`package *\n\tdocumentation: True" automatically from --enable-documentation
16:12:21 <dmwit> huh
16:12:37 <dmwit> Okay. Then I'm out of date (or maybe was never correct) and should probably be ignored.
16:12:45 <monochrom> But perhaps there is divergence between 2.4, 3.0, 3.2
16:13:19 <joelg> Reading the online docs for cabal-install, it does seem that the package * documentation: True thing should have worked
16:13:58 <monochrom> If you don't mind, you could clear out .cabal/store to trigger massive rebuild
16:14:10 <monochrom> you may lose some exe
16:14:35 <monochrom> whoever thought up that symlink idea was evil or stupid
16:15:06 <monochrom> firstly it blocks windows. secondly it blocks a simple GC strategy.
16:15:09 <joelg> _deepfire: That's interesting, I'll check out Nix for real at some point
16:16:18 <monochrom> I almost wrote a "convert symlink to physical copy" program for this.
16:16:20 <sclv> v2-configure sets up the cabal.project.local, which is different than v1-build
16:16:39 <sclv> i think the symlink thing is now overridable to do copy instad
16:16:42 <sclv> by a flag
16:16:58 <monochrom> Yes. Non-default. And afterthought.
16:17:39 <monochrom> My complaint is who thought it was a good idea in the first place.  Like, it would be a problem on Windows. That one didn't need any foresight, hindsight, any sight.
16:18:47 <monochrom> And the flag still doesn't have a corresponding .cabal/config line.
16:22:32 <_deepfire> joelg: one (somewhat overwhelming, but apparently good) introduction to Haskell-on-Nix is https://discourse.nixos.org/t/nix-haskell-development-2020/6170/1
16:23:09 <joelg> _deepfire: Thanks, I'll check it out
16:29:23 <_deepfire> joelg: on a second thought, you'll probably want to read https://nixos.org/nixpkgs/manual/#haskell before embarking on that link, though.
16:41:23 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
16:41:23 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
16:41:54 <glguy> SureYeaah: I don't think you're banned, but that channel is pretty inactive and this one is great for beginner questions
16:42:10 <glguy> Ask your question and if someone is interested in helping they'll jump in
16:42:28 <SureYeaah> Alright, thanks!
16:46:31 <koz_> SureYeaah: Sup?
16:46:40 <koz_> Assuming you are who I think you are - nice seeing you here!
16:47:59 <SureYeaah> koz_: Hi! I'm generally not active on IRC, had issues with Riot but IRCCloud is pretty cool. Nice to see you as well.
16:48:13 <koz_> No worries. I'm here basically all the time (I have a bouncer).
16:49:13 <SureYeaah> koz_: I should also set that up one of these days.
16:49:35 <koz_> SureYeaah: It's not very difficult to do. Mine's a bit of a hack job I should really put some time into though.
17:00:53 <sm[m]> what Riot issues ? it works well for me
17:04:14 <SureYeaah> sm: I think matrix had this bug where you could not send messages, only receive them.
17:04:38 <SureYeaah> sm[m]:
17:05:04 <jared-w> anyone have any opinions on the best way to organize a cabal file for moderate to more complex haskell repositories? Particularly with making sure it plays nicely with ghcide, tooling, and the hie.yaml stuff. One of the downsides of cabal's file format, I'm discovering, is that it's so lax you can throw together a file that barely makes sense yet cabal build will still work, somehow
17:07:25 <sshine> Just to clarify how bad at computers I am: My social network uploads plaintext files to one another that we download via a command-line. I don't know how to use a mouse!!
17:07:30 <sm[m]> SureYeaah: there are temporary issues with the matrix-irc bridge once in a while, but not too often. There's also the need to register to speak on some channels. When using matrix, there's a special procedure for that.
17:09:24 <SureYeaah> sm[m]: yeah I was registered. I'll give it another shot.
17:10:20 <sm[m]> cf https://hledger.org/#help-feedback -> "on Matrix, use..."
17:10:23 <sshine> sm[m], I was going to set up matrix-irc on a channel but learned from some PLT Discord that it sometimes spews HTML into IRC...? it's an uphill battle some places to get any bridge going at all, so I stuck with discord-irc even though it doesn't connect with multiple clients. and freenode is too slow to respond on I-lines to improve it to connect with individual IRC connections per Discord user.
17:10:24 <koz_> jared-w: FWIW, cabal-fmt exists.
17:11:46 <sm[m]> sshine: I can't think of such a "feature", except sometimes people's matrix client quote previous messages which looks verbose in IRC
17:12:31 <sm[m]> and when a matrix user pastes a long messages, it appears on irc as a url instead
17:12:53 <sshine> sm[m], ugh yeah that's a culture clash :) some people on Discord got really annoyed with me for prefixing my messages with their name because their client gives them a notification pop-up for every single thing I say.
17:12:59 <sm[m]> which is actually good, except it would be nice if it also showed an excerpt
17:13:34 <sshine> haha yes. well, we have an IRC bot that wgets and displays the <title> or <h1> of the document.
17:13:39 <sm[m]> there are a few little things to learn for graceful bridging, but it mostly just works great
17:13:53 <sshine> "patching IRC by writing bots"... so nostalgic.
17:14:15 <sshine> the need for bots in other chat systems is so much less, but the options are so much more.
17:15:02 <sshine> I haven't really found a good use-case for Joachim Breitner's Telegram bot blog post :) we use Telegram at work.
17:16:02 <sshine> a possibility for pushing Haskell into publicity :-D like GitHub's API / Kowainik's Hintman
17:16:20 <sshine> except that's only for Haskell code :P
17:18:20 <sm[m]> jared-w: any particular problem you have in mind ?
17:18:50 <jared-w> koz_: does cabal-fmt suggest reorganizing your project in a less dumb way if you have multiple hs-src-dirs as a workaround for not having a cabal.project and "real internal dependencies"?
17:19:05 <koz_> jared-w: No, but it does limit the 'stuff whatever into cabal files' problem somewhat.
17:19:32 <koz_> Hence the FWIW.
17:20:49 <jared-w> ah, I see what you're saying. That makes sense
17:21:08 <koz_> Although a 'cabal-reorganizer' would be awesome. :P
17:21:17 * jared-w mfw "stuffing some random hs file 7 levels deep into the docs folder somehow works"
17:29:18 * hackage flow2dot 0.9.1 - Library and binary to generate sequence/flow diagrams from plain text source  https://hackage.haskell.org/package/flow2dot-0.9.1 (DmitryAstapov)
17:33:36 <maerwald> cabal file format is just too complicated 
18:29:50 <solrize> https://www.youtube.com/watch?v=0jI-AlWEwYI   this was a really great talk (Alexis King on effect systems).  one of the few long videos that i've ever felt was worth watching
18:30:58 <koz_> Yes, much this.
18:31:01 <koz_> :t ($)
18:31:02 <lambdabot> (a -> b) -> a -> b
18:31:16 <koz_> % :src (&)
18:31:17 <yahb> koz_: unknown command ':src'; use :? for help.
18:31:24 <koz_> % :info (&)
18:31:24 <yahb> koz_: (&) :: a -> (a -> b) -> b -- Defined in `Data.Function'; infixl 1 &
18:31:50 <koz_> % :info maybeToRight
18:31:50 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `maybeToRight'
18:36:51 <solrize> "
18:36:51 <solrize> Basically, I think the proletariat should be able to control the means of reduction"
18:36:56 <solrize> (from reddit comment)
18:37:00 <solrize> lol
18:37:05 <koz_> solrize: Rofl.
18:37:24 <halogenandtoast> Would it be a major faux pas to have IO encoding into a typeclass? Basically I want a definition to default to using randomRIO but it feels not great to do that.
18:37:41 <halogenandtoast> s/encoding/encoded_
18:38:19 <wavemode> a faux pas to whom? the haskell police?
18:39:32 <halogenandtoast> I assume future me, when my program grows larger (and/or I want to test it) and I wish I hadn't
18:39:45 <halogenandtoast> The example code is https://gist.github.com/halogenandtoast/124512f79df2111dcc6fa7bd6e157c46
18:40:54 <solonarv> halogenandtoast: instead of stapling it to IO, why not MonadRandom or drawFromBag :: RandomGen g => a -> g -> (g, Token) ?
18:41:29 <halogenandtoast> Yeah I was thinking MonadRandom would be better and then use getRandomR
18:41:42 <solonarv> yeah, something like that
18:42:12 <solonarv> I'm too sleepy to recall the details of the various random libraries but that's the sort of thing you should turn to
18:42:13 <halogenandtoast> I prefer to not have to think about passing RandomGen's around
18:42:26 <halogenandtoast> even though I probably shouldn't
18:42:38 <solonarv> you can always run it in IO with e.g. 'getStdRandom :: (StdGen -> (a, StdGen) -> IO a'
18:42:50 <Boarders> halogenandtoast: the new random v1.2 is currently in the review process but due to be released very soon
18:43:10 <solonarv> then 'getStdRandom . drawFromBag :: a -> IO Token' recovers your current type
18:43:19 <Boarders> And that offers an interface where you don’t have to manually carry around the generator
18:43:28 <Boarders> It will work with state or IO or ST
18:43:37 <Boarders> And have significantly better performance
18:46:00 <halogenandtoast> Boarders: I can't wait to see it
18:59:20 <jchia1> FFI/hsc2hs question: I see examples where a C function return a pointer to a struct. Can I interface with a C function that returns a struct? E.g. struct Foo { char* data; size_t length;}. If I return a Foo pointer, it seems that I have to alloc/dealloc Foo (on the heap) in addition to the actual data. If I can just return Foo (not pointer), I only need to alloc/dealloc data but all the examples I've seen involves returning a pointer to
18:59:20 <jchia1>  a struct. Or, am I missing something about FFI?
19:00:03 <koz_> I believe FFI cannot work with structs directly like that - it has to be via pointer.
19:00:32 <koz_> Boarders: You can also use PrimMonad and mwc-random.
19:00:44 <koz_> Since PrimMonad is basically 'I haz mutable state somehow'.
19:01:49 <Boarders> That is true and in fact that will be an example of the new random interface in the sense that the typeclass they use had an instance for the mwc-random state
19:02:19 <jchia1> koz_: Do you know whether it's safe to have the C function make  Foo on its stack and return a pointer to it to be used immediately by the calling Haskell peek?
19:02:49 <koz_> jchia1: I have no idea, sorry. I'm far from an FFI expert, but I do recall the struct problem being... well, a problem.
19:02:59 <jchia1> It seems mighty redundant to alloc a struct just to pass around a pointer and an int. This is not something that one does in native C or C++
19:03:12 <jchia1> OK
19:27:29 <dolio> That doesn't sound safe.
19:39:36 <Axman6> Boarders: got a link to the changes?
19:40:08 <dmwit> Is there a math term for the class of functions that can be given the type `[a] -> [a]`? I have a document here that's calling them "permuters", but they're definitely not guaranteed to be permutations.
19:40:47 <dmwit> (Let's say total functions with finite-length inputs and outputs.)
19:51:18 * hackage replace-megaparsec 1.4.2.0 - Find, replace, and split string patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.4.2.0 (JamesBrock)
19:54:18 * hackage replace-attoparsec 1.4.1.0 - Find, replace, and split string patterns with Attoparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-attoparsec-1.4.1.0 (JamesBrock)
20:07:28 <gcoakes[m]> Hey, can someone help me with servant-auth? I've gotten JWT authentication working using the "Authorization" header, but I can't get it to work with cookies.
20:13:42 <Axman6> do you have any code to share?
20:19:28 <gcoakes[m]> I just figured it out. It wasn't a code issue. I didn't (still don't really) understand XSRF. I wasn't adding the X-XSRF-TOKEN to my request.
20:20:09 <gcoakes[m]> But, I at least got the POST command to issue correctly.
20:21:24 <Axman6> noice
20:58:01 <crestfallen> * -> * -> * is the kind of a binary type constructor (via currying), e.g. of a pair type constructor, and also that of a function type constructor (not to be confused with the result of its application, which itself is a function type, thus of kind *)
20:59:27 <crestfallen> this line is from wikipedia, kinds in haskell. the last part of that sentence says "which is itself is a function type, thus of kind *."  this is confusing , the way it's written..
20:59:55 <crestfallen> correction: "which itself is a function type,  ...
21:00:18 * hackage blanks 0.4.0 - Fill-in-the-blanks - A library factoring out substitution from ASTs  https://hackage.haskell.org/package/blanks-0.4.0 (ejconlon)
21:00:54 <crestfallen> so the result is *, also a function type (which is first defined as * -> * -> *)
21:02:27 <crestfallen>  if anyone has time, this is the page where I have a few questions https://en.wikipedia.org/wiki/Kind_(type_theory)#Kinds_in_Haskell
21:04:45 <koz_> crestfallen: Let's make this a little bit more concrete.
21:04:50 <koz_> Let's consider Either.
21:05:10 <crestfallen> ok
21:05:11 <koz_> The reason it has the kind that it does is that you have two 'holes' you can 'fill in' with whatever types you please.
21:05:24 <koz_> When you 'fill in' both holes, you get 'a Real Boy type'.
21:05:34 <koz_> So for example, Either Int String.
21:05:43 <koz_> With me so far?
21:05:50 <crestfallen> yeah thanks
21:05:59 <koz_> OK, so let's look at _just_ Either by itself.
21:06:13 <koz_> Either basically says 'if you give me two types to fill those holes, I can give you a Real Boy type'.
21:06:24 <koz_> So thus, we can say its _kind_ is Type -> Type -> Type.
21:06:32 <koz_> (* is pronounced 'Type' in 2020)
21:06:38 <crestfallen> meaning a "proper" type?
21:06:44 <koz_> So, give me two Type things, and I'll give you a Type thing.
21:06:49 <koz_> 'Proper' is a bit of a skunk word.
21:06:54 <koz_> I'm using "Real Boy" instead.
21:07:12 <koz_> Now, let's consider the function arrow (that is (->)).
21:07:25 <koz_> (not to be confused with the _kind_ arrow, which is also unhelpfully written the same way)
21:07:32 <crestfallen> ok
21:07:37 <koz_> First, let's write it prefix.
21:07:45 <koz_> (->) Int String is the same as Int -> String.
21:07:46 <kleisli> hey all, do any of you know how I might derive a show instance for the following: https://paste.ee/p/qg88p ?
21:08:03 <koz_> kleisli: But you invented monadic composition. Surely that's easy? :P
21:08:21 <koz_> Now, we can both agree that (->) Int String is a Real Boy type, right?
21:08:29 <koz_> So let's stack them up above each other
21:08:31 <koz_> Either Int String
21:08:35 <koz_> (->) Int String
21:08:44 <kleisli> koz_: hmm good point
21:08:54 <koz_> So, if Either has kind Type -> Type -> Type, what's the kind of (->), crestfallen?
21:09:15 <crestfallen> same type
21:09:25 <koz_> crestfallen: Same _kind_.
21:09:33 <koz_> This is exactly what this article is saying.
21:09:52 <crestfallen> right. so the result is also a function, but is *
21:09:56 <ab9rf> the hard part of all this for a lot of people seems to be keeping kind and type separate
21:10:14 <koz_> So in its language, 'function type constructor' is (->), whereas 'the result of its application' is something like (->) Int String.
21:10:16 <wavemode__> DataKinds makes that even more fun :p
21:10:30 <koz_> You can think of 'application' in this context as 'filling in those holes to make Real Boy types one day'.
21:10:44 <koz_> It notably _does not_ mean the same thing as 'application' does at the _value_ level.
21:11:14 <koz_> kleisli: I guess a standalone derivation of Show fails you?
21:11:32 <crestfallen> so is Either like IO , in that it takes a parameter(s)?
21:11:55 <koz_> crestfallen: Sorta. 'Either' is like a recipe for making types.
21:12:08 <koz_> You can fill its 'holes' with whatever things you want and get other things out of it.
21:12:12 <crestfallen> IO is unary, it takes a single argument. Either is binary, right?
21:12:22 <koz_> Again, sorta yes.
21:12:35 <koz_> Basically what the article says is what I just spelled.
21:12:38 <ab9rf> eeeeeeh
21:12:53 <koz_> ab9rf: Yes, I admit I'm being _super_ imprecise.
21:12:55 <crestfallen> So the result is also a function in the article, so say [Int] is just kind *
21:12:57 <ab9rf> (partially applied type constructors)
21:13:08 <Axman6> IO :: * -> * (IO :: Type -> Type), Either :: Type -> Type -> Type
21:13:28 <Axman6> Either Int :: Type -> Type
21:13:38 <Axman6> Either Int Bool :: Type
21:13:41 <crestfallen> right IO is unary there, Either, binary. that I get
21:13:52 <koz_> crestfallen: And you are indeed right, the kind of [Int] is indeed Type.
21:14:03 <ab9rf> it's probably best that you not think of them being "unary" or "binary" or what not.
21:14:12 <Axman6> well, sort of, like functions, (->) at the type/kind level also only takes one argument
21:14:15 <ab9rf> that gets into a rabbit hole
21:14:23 <Axman6> _all functions take exactly one argument_
21:14:30 <jchia1> question about cereal: If I have defined only Get for my own type Foo, but not Put, but I want to use the default Get for [Foo], is there a better way than making Foo an instance of Data.Serialize.Serialize with an undefined put?
21:14:32 <ab9rf> all functions take one argument
21:14:39 <ab9rf> if it doesn't have an argument, it's nt a function
21:14:41 <crestfallen> right, the crux of currying I guess
21:14:54 <kleisli> koz_: yep. i'm guessing i need to restrict it to cases where `n k` itself has a show instance but not sure exactly what the syntax is inside a standalone derivation
21:15:22 <jchia1> I've always wondered why in cereal Get & Put are mixed up together in one typeclass.
21:15:27 <crestfallen> but if [Int] is a type kind, then it's not denoted by * -> * -> *, but by *.
21:15:37 <koz_> crestfallen: 'type kind' is not a thing.
21:16:05 <ab9rf> [Int] is a type of kind *
21:16:19 <crestfallen> ok its of kind "function"
21:16:56 * MarcelineVQ hears gears grinding
21:17:18 <d34df00d> Hi!
21:17:42 <d34df00d> Let's say I want to have a monadic action that yields something that can be used in any IsString context.
21:17:53 <d34df00d> So I write this: `freshRefVar :: MonadQ m => m (forall a. IsString a => a)`
21:18:15 <d34df00d> But ghc shouts at me about impredicative polymorphism, and I know it breaks terribly so I don't even try enabling it.
21:18:18 <crestfallen> ok it's actually pretty intuitive, . the last * is the resolved kind, just like when we're reading type signatures we see that the last -> b or similar is the result
21:18:23 <d34df00d> Is there any way to express this without newtyping the wrapped type?
21:18:45 <monochrom> I think that "(IsString a, MonadQ m) => m a" is enough for most purposes.
21:19:15 <monochrom> If you really want an inner forall for this, you have to go through a newtype wrapper.
21:19:29 <d34df00d> monochrom: it's gonna be used like `  v <- freshRefVar ; let refinement = Refinement [AR v $ v |=| ti n]`, and the occurrences of `v` in the let binding have different types.
21:19:42 <crestfallen> koz_: is my last post accurate there?
21:19:53 <monochrom> Then you really have to go through a newtype wrapper.
21:19:53 <d34df00d> (different monomorphised types, both satisfying IsString that is)
21:19:55 <koz_> crestfallen: Sorta.
21:19:56 <d34df00d> :(
21:20:01 * d34df00d don't like newtypes
21:20:09 <koz_> d34df00d: Why? Newtypes are great!
21:20:15 <d34df00d> Too much typing!
21:20:18 <d34df00d> (no pun intended)
21:20:28 <d34df00d> koz_: I mean, in this context as a workaround.
21:20:29 <monochrom> Rumour goes that SPJ has figured out supporting impredicative types (for the second time), so don't hold your breath. >:)
21:20:29 <koz_> kleisli: it's like 'deriving instance _ => _' I think?
21:20:41 <koz_> monochrom: Yeah, Quick Look got approved.
21:20:43 <crestfallen> the holes are filled, the resolved * is still considered a function
21:20:50 <koz_> Probbo will be in GHC 8.20 or something. :P
21:20:58 <koz_> crestfallen: Yeah, you're blending types and kinds in your head.
21:21:03 <d34df00d> Right after dependent haskell I guess.
21:21:03 <koz_> 'Function' is not a kind-level notion.
21:21:10 <monochrom> Ho hum, this one will actually realize? I will be surprised.
21:21:12 <d34df00d> Also, blending types and kinds is great.
21:21:43 <koz_> d34df00d: Not at the stage crestfallen's at, since it appears to be confusing them.
21:21:43 <monochrom> It's becoming like P vs NP.
21:21:54 <ab9rf> please, don't muddy the waters just yet
21:22:36 <ab9rf> type constructors are not functions, although they admittedly do resemble them.
21:23:43 <dolio> Int isn't a function.
21:23:48 <dsal> If I went through life thinking type constructors were functions, where would I suffer?
21:23:55 <crestfallen> so if a result is kind * , it can be a nullary type constructor (no holes, nothing left to resolve?)
21:24:06 <d34df00d> dsal: you'd suffer in haskell.
21:24:28 <dsal> Heh, I mean like, more specifically?  I seem to be able to use them everywhere I can use functions.  I don't think of them as a very special thing.
21:24:49 <koz_> dsal: Let's start with partial application. Trivial at value level, _painful af_ at type level.
21:24:50 <d34df00d> something something dependent types something
21:25:01 <ab9rf> hah
21:25:04 <koz_> (just take one look at the absurdist machinery singletons has to deploy to resolve this)
21:25:48 <crestfallen> I mean, if there's no hole, no parameter after resolution, that is a nullary thing, right?
21:26:09 <dsal> :t TwoThings 5
21:26:10 <lambdabot> Int -> TwoThings
21:26:10 <d34df00d> > Could not deduce (IsString (forall a. IsString a => a)) arising from a use of ‘fromString’
21:26:12 <lambdabot>  <hint>:1:50: error: parse error on input ‘=>’
21:26:13 <d34df00d> So much for impredicativity.
21:26:20 <d34df00d> I guess I should just go through newtype.
21:26:30 <ab9rf> don't talk about nullary things
21:26:33 * d34df00d just tried IT out of curiosity.
21:26:37 <dsal> I can partially apply type constructors.
21:26:45 <dsal> Er wait, value constructors.
21:26:58 <dsal> Did I get my words confused?
21:27:04 <crestfallen> ok I guess I won't learn kinds tonight
21:27:06 <koz_> dsal: I'm not sure what you're trying to say?
21:27:12 <ab9rf> dsal: i suspected that you were confusing data constructors with type constructors, but was going to let you get to that on your own
21:27:17 <dsal> koz_: Sounds like we're on the same page.
21:27:38 <dsal> ab9rf: heh.  Yeah, sloppy language sucks.
21:27:44 <monochrom> You can partially apply type constructors in "instance Functor (Either a) where".
21:28:14 <monochrom> Now please debate on whether "binary type constructor" exists. >:)
21:28:20 <koz_> For extra brownie points, identify the kind of 'Functor' here. :P
21:28:44 <dolio> The only way you can't partially apply (appropriate) type 'constructors' is if you use the word to mean the same thing as 'function' like a lot of people do.
21:28:58 <dolio> But only at the type level.
21:29:35 <dolio> It doesn't seem like there needs to be another word for 'function', though.
21:29:44 <crestfallen> as if the type system is not hard enough
21:30:12 <d34df00d> Alright, so this gets interesting. Now I have `newtype SIS = SIS { unsis :: forall a. IsString a => a }` and `freshRefVar :: MonadQ m => m SIS`
21:30:24 <d34df00d> And I use it as `(v' :: IsString a => a) <- unsis <$> freshRefVar ;  let refinement = Refinement [AR v' $ v' |=| ti n]`
21:30:29 <monochrom> The type system is hard because it has a kind system behind it.
21:30:43 <d34df00d> Yet ghc seems to derive the type of v' according to the first use of v' as the first argument to AR.
21:30:47 <monochrom> For example why [Int] is OK, [Either] is not.
21:30:47 <d34df00d> And rejects the second one.
21:30:58 <d34df00d> When I had a free-standing binding of v :: IsString a => a, it worked perfectly.
21:31:01 <d34df00d> What am I doing wrong?
21:31:27 <d34df00d> s/free-standing/top-level/
21:32:28 <monochrom> (>>=) :: M a -> (a -> M b) -> M b causes monomorphism in "a".
21:32:30 <crestfallen> monochrom: I like it in any case
21:32:40 <d34df00d> monochrom: ah, right.
21:32:46 <d34df00d> I guess I should just unsis at call site.
21:33:33 <d34df00d> Meh, this gets too verbose :(
21:33:52 <crestfallen> so monochrom in your (>>=) example that means there isn't a deconstructor possible?
21:33:56 <monochrom> Or, maybe (>>=) doesn't, but do-notation desugaring to xxx >>= \a -> ..., the lambda does.
21:34:31 <monochrom> crestfallen, that's for d34df00d.
21:34:46 <crestfallen> if something is monomorphic, it can't have deconstruction though? Or did I make that up?
21:35:46 <d34df00d> Yeah, cool, now that works and looks more or less as expected.
21:35:49 <d34df00d> monochrom: thanks!
21:36:01 <d34df00d> (well, not sure about "works", but at least it typechecks)
21:36:14 <ab9rf> close enough
21:37:41 <monochrom> hrm that's interesting
21:37:43 <crestfallen> best resource to read about kinds aside from wikipedia?
21:38:28 <monochrom> > (\(f :: a -> a) -> (f 'c', f True)) id
21:38:30 <lambdabot>  error:
21:38:30 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘Bool’
21:38:30 <lambdabot>      • In the first argument of ‘f’, namely ‘True’
21:38:56 <dsal> crestfallen: Have you read Sandy Macguire's book on types?
21:39:15 <dolio> > (\(f :: a -> a) -> f 'c')
21:39:17 <lambdabot>  <(Char -> Char) -> Char>
21:39:26 <dolio> Wow.
21:39:28 <dsal> crestfallen: https://leanpub.com/thinking-with-types <-- this should explain all the type things.
21:39:49 <crestfallen> no dsal haven't seen it
21:39:55 <dsal> I read it a while back, but I don't do much type level programming (in case that weren't obvious)
21:40:36 <d34df00d> I figured I better learn a language with an easier type system first.
21:40:37 <monochrom> > (\(f :: forall a. a -> a) -> (f 'c', f True)) id
21:40:40 <lambdabot>  ('c',True)
21:40:49 <crestfallen> dsal: thanks
21:41:13 <kleisli> koz_: i got this working, but it will be very verbose in practice because i want to have many more constructors than NAlpha, NBeta, and NGamma : https://paste.ee/p/QUHxE
21:41:34 <kleisli> do you know if there's a way to do a forall (k :: Kind) inside the show implication ?
21:56:35 <koz_> kleisli: You could cart around Show constraints inside the GADT constructors?
21:59:12 <kleisli> hmm yeah that could work
23:33:48 <kuribas> what's a good xml parser?  I've looked at several of them like hxt, haxml, but they look kind of convoluted.
23:34:30 <kuribas> xml-conduit seems to have a good API, but it doesn't give location info, AFAIKS?
23:34:50 <kuribas> no good error messages is a big no for me...
23:35:20 <kuribas> I've been thinking to roll my own library on top of hexpat and streamly.  I already have a partial implementation.
