00:00:22 <freeman42x[m]> LambdaDuck: whe can I find that algorithm?
00:00:37 <dibblego> character counters are driving me a little mad lately
00:00:42 --- mode: ChanServ set -o dibblego
00:01:24 <freeman42x[m]> is there a function like: take :: Int -> [a] -> [a] but that returns the last n elements of a list instead of the first? and yes, I am looking for a function not how to solve that problem
00:01:55 <LambdaDuck> freeman42x[m]: You can look at the source for the "pointless" library for example. But I could teach you the basics
00:03:13 <LambdaDuck> freeman42x[m]: Check out the wiki page. It has a bunch of resources: https://wiki.haskell.org/Pointfree
00:04:17 <Eduard_Munteanu> freeman42x[m], if you need access to the last elements usually a list isn't great. Data.Seq might have something.
00:05:02 <freeman42x[m]> @karma+ LambdaDuck thank you, will check that out
00:05:02 <lambdabot> LambdaDuck's karma raised to 1.
00:06:06 <jackdk> LambdaDuck: there are a few unsound lenses in the package, that basically say "use the same length of list when writing back", but I take your point.
00:06:08 <jackdk> thank you.
00:07:32 <LambdaDuck> freeman42x[m]: If you want to take the last elements anyways, a hoogle search reveals "takeEnd" from Data.List.Extra. But it's probably better to use Seq, or reversing the list first. https://hoogle.haskell.org/?hoogle=%3A%3A%20Int%20%2D%3E%20%5Ba%5D%20%2D%3E%20%5Ba%5D
00:10:04 <LambdaDuck> jackdk: Yes, I was looking for those. Do you remember where they are/what they are called?
00:10:49 <dminuoso> freeman42x[m]: Conciseness is not necessarily as "short and obfuscated" as possible.
00:10:50 <jackdk> LambdaDuck: partsOf is the one I remember
00:11:05 <LambdaDuck> Thanks
00:11:34 <jackdk> and the stuff in Control.Lens.Unsouns
00:11:43 <jackdk> correction, Control.Lens.Unsound
00:12:30 <LambdaDuck> Right. Yes, I guess it could work similarly to partsOf, so extra elements are ignored and missing elements keep their original shape.
00:12:53 <LambdaDuck> But it would have to be `chunksOf :: Int -> Traversal s t a b -> Traversal s t [a] [b]`
00:13:05 <LambdaDuck> But it would have to be `chunksOf :: Int -> Traversal s s a a -> Traversal s s [a] [a]`
00:13:42 <LambdaDuck> In the same way as partsOf, since the missing elements would need to be filled with something.
00:13:57 <ph88> i run my haskell program and then it just says "Killed" .. i don't even know where that message is coming from. How to debug ??
00:14:24 <hc> does dmesg say anything?
00:17:45 <freeman42x[m]> dminuoso: `sparing in the use of words; abrupt.` definition from google. anyway, I was asking for the shortest solution in number of characters. I never said I want a solution that is obfuscated
00:18:21 <freeman42x[m]> and did not claim that conciseness is necessarily as short and obfuscated as possible. Maybe argue with someone else that thinks that?!
00:18:28 <jackdk> LambdaDuck: ah yes, of course.
00:19:24 <ph88> hc, yes  Out of memory
00:20:00 <freeman42x[m]> @karma+ LambdaDuck "takeEnd" from Data.List.Extra was what I needed, ty
00:20:00 <lambdabot> LambdaDuck's karma raised to 2.
00:21:09 <LambdaDuck> jackdk: I suspect that it doesn't exist, but it is probably possible to make one, if one can wrap their head around all the Corepresentable Sellable Bizarre Bazaars. ;)
00:21:49 <jackdk> LambdaDuck: my brain is not galactic, so I'll just have to wait
00:23:39 <LambdaDuck> jackdk: I think those things are mostly about performance optimizations, and generalizations for indexed lenses and such things, so there might be a more straightforward solution possible as well.
00:24:26 <niso> hi, newbie here: Are there any compiler flags i can set to warn about unsafe things like Prelude.head? or improve non-exhaustive pattern errors?
00:24:27 <hc> ph88: then you have your reason right there :)
00:25:25 <ph88> hc, ye but i need the reasons of the reason
00:25:26 <hc> ph88: it's a thing done by the operating system; instead of denying new memory allocations, when out of mem, the system "more or less randomly" terminates processes; those processes can't even intercept that.
00:25:51 <hc> you probably have some memory leak...
00:26:11 <hc> are you doing something that inadvertantly builds up thunks, rather than evaluating? things like using foldl?
00:26:50 <LambdaDuck> You could tell ghc to limit the amount of memory it can use with an RTS flag. And/Or try some of the profiling utilities
00:27:26 <hc> i have a hunch that won't fix their problem ;)
00:28:23 <hc> Prelude> foldl (+) 1 [1..100000000]
00:28:23 <hc> fish: “stack ghci” terminated by signal SIGKILL (Forced quit)
00:28:36 <hc> ph88: ^^ this is an example of how to inadvertantly use a lot of memory
00:28:41 <hc> (i'm glad my computer still responds now ;p)
00:29:08 <freeman42x[m]> niso: use an alternative prelude which does not have problematic functions like that. I use Relude for example
00:30:06 <ph88> hc, yes probably. how to find the leak though ?
00:31:24 <niso> freeman42x[m]: relude looks interesting, thanks!
00:32:14 <freeman42x[m]> niso, Relude seemed to be best for my use-case
00:32:15 <hc> ph88: i have no experience hunting leaks; luckily never had any in my projects and the one leak i produced in a pull request to wai-extra was detected by the maintainer before they merged it ;p
00:32:32 <hc> ph88: other people here probably have advice on how to use profilers to find leaks, etc. :)
00:33:06 <LambdaDuck> ph88: If you limit the amount of memory haskell can use, you can find the leak faster, but I'm not sure if it'll give you better error messages though. Something like this ./mytest +RTS -M4m -RTS There is some info on the wiki page: https://wiki.haskell.org/Memory_leak
00:33:31 <niso> freeman42x[m]: currently reading through the readme, looks great
00:33:31 <ph88> ok i'll try that
00:33:53 <freeman42x[m]> niso, yeah, it has great documentation
00:34:01 <freeman42x[m]> for a Haskell project that is haha
00:35:24 <LambdaDuck> ph88: This blog article has a nice guide for debugging space leaks: http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html
00:35:58 <yushyin> niso: or use the safe package, if you dont want to commit yourself to a different prelude
00:36:48 <LambdaDuck> yushyin: The downside with that is that the partial functions are still in scope, so you could use them by mistake
00:38:13 <niso> yushyin: looks interesting too, thanks! Thanks for the input LambdaDuck 
00:42:14 <dminuoso> class UselessDefault a where useless :: a
00:42:34 <dminuoso> I finally realized, that that's how you use a default class. You make a domain specific one, where you can reason about what values you get.
00:42:53 <dminuoso> In my case, it's for generating useless stub values to proceed compilation, allowing the collection of further errors.
00:43:31 <LambdaDuck> niso: You could also put `import Prelude hiding (head, ...)` at the top of each file, as an extra safety feature if you want. (Even though that is a bit tedious too)
00:43:45 <dminuoso> So I can do something like `default <$ compErr "Bad input"` :)
00:43:55 <dminuoso> Or, `useless <$ compErr "Bad Input"` rather
00:46:06 <LambdaDuck> dminuoso: Nice! Why do you call it "UselessDefault"? It seems very useful. :)
00:47:04 <dminuoso> LambdaDuck: The default values are utterly useless!
00:47:13 <dminuoso> They are acme-default worthy
00:47:34 <niso> LambdaDuck: i'll consider it, kinda wondering why there isn't some kind of safty compiler extension (since there seem to be tons of extensions)
00:48:25 <dminuoso> LambdaDuck: There's this package `default` which I greatly dislike, because default values are usually very domain specific (and for some types, there's no obvious globally valid canonical value).
00:48:38 <dminuoso> E.g. what's a sensible default value for Int? Is it -1? 0? +1? Maybe 17?
00:49:14 <Eduard_Munteanu> nil as in Go
00:49:15 <dminuoso> Im specifically setting magic values that are recognizable, in case I ever accidentally leak a value
00:49:49 <dminuoso> Perhaps I should not even expose `useless`, and provide some `compErrDef` instead.
00:50:26 <Eduard_Munteanu> undefined seems more reasonable
00:51:00 <Eduard_Munteanu> Or maybe   error "should not have escaped"
00:51:05 <LambdaDuck> niso: There is an open issue on hlint about it. Since it is a matter of libraries rather than language, it wouldn't make much sense to include it as a compiler flag. But having it in a linter makes a lot of sense: https://github.com/ndmitchell/hlint/issues/420
00:51:07 <yushyin> niso: the flag -W adds -Wincomplete-patterns which warns you, if you write incomplete patterns. But this does not help you with partial functions. Sometimes you use partial functions intentionally anyways.
00:51:16 <dminuoso> Eduard_Munteanu: Strictness is in the way, sadly :)
00:52:56 <niso> LambdaDuck: good point, makes sense!
00:52:57 <LambdaDuck> dminuoso: Ah, right, so you're using it as a subsitute for exceptions/Left/Nothing.
00:53:14 <freeman42x[m]> niso: hmm, there might be a compiler setting for totality checking, might want to search for that
00:53:29 <niso> yushyin: this doesn't help with partial functions, but it does help with the pattern-stuff i was wondering about :D
00:54:20 <LambdaDuck> yushyin: Do you know why that is not enabled by default? It really should be.
00:54:25 <ph88> LambdaDuck, that is for detecting space leaks, but since my program is already killed for out of memory i don't have to detect the space leak because i already know it's there
00:54:51 <niso> freeman42x[m]: seems to work with LiquidHaskell (which is on my todo list), thanks!
00:55:55 <LambdaDuck> ph88: Was it killed by the GHC Run Time System or the OS. I assumed (but haven't checked) that when the RTS kills it, it would still show the profiling info?
00:57:53 <LambdaDuck> niso: If you want to take it to the extreme, you could always learn Agda or Idris. But those are not (yet) as useful for general purpose programming though. ;)
00:57:57 <dminuoso> LambdaDuck: Not quite.
00:58:31 <yushyin> LambdaDuck: no, i don't know :/
00:58:37 <dminuoso> LambdaDuck: Essentially I have a compilation monad that admits non-fatal errors, where I can use `cut`  to turn non-fatal errors into fatal errors.
00:59:41 <LambdaDuck> I see
00:59:52 <dminuoso> So I have `cut :: NIFComp (); cut = do { e <- askErrors; case e of [] -> pure (); _xs -> throwIO BailOut`
01:00:02 <dminuoso> And then `condemn act = act <* cut`
01:01:01 <niso> LambdaDuck: maybe at a later point, right now i'm looking for a general puprose language
01:01:12 <dminuoso> And then some combinator `>|>` which is essentially `f >|> g g = condemn f >> g`, and then some `f >?> g = ...` that's sort of the opposite "proceed if there is on errors, but dont bail out"
01:01:56 <dminuoso> LambdaDuck: So the default value is because if you have some `parseThing :: String -> NIFComp Int` - and you're throwing a non-fatal error, you still must produce a result of type Int.
01:03:24 <ph88> LambdaDuck, killed by OS
01:04:35 <ClaudiusMaximus> heap profiles .hp are written incrementally, time profiles .prof are written at exit
01:09:59 <LambdaDuck> ph88: The RTS flag should prevent that from happening, since they limit the maximum amount of memory the process can use. Make sure you enable rtsflags (and profiling) when compiling.
01:12:39 <ph88> oki thank you
01:13:21 <hc> ph88: i'd be interested to know what caused your problem :)
01:15:04 <ph88> i use this as build command   stack build --executable-profiling --ghc-options="-rtsopts"
01:15:21 <ph88> and this as run command   stack exec -- program +RTS -hT -s -RTS generate
01:15:33 <ph88> Then i get message:  Most RTS options are disabled. Link with -rtsopts to enable them.  
01:15:47 <ph88> why are the rtsopts not working ??
01:16:56 <hc> ph88: you need the ghc opts also for stack exec
01:17:25 <hc> stack exec --executable-profiling --ghc-options="-rtsopts"  -- program +RTS -hT -s -RTS generate
01:17:33 <ClaudiusMaximus> does   stack exec ...  +RTS    gives RTS options to stack?
01:17:49 <dminuoso> Shouldn't `stack exec --profile` already add the necessary GHC options?
01:17:50 <merijn> ClaudiusMaximus: No, the RTS ignores +RTS after --
01:18:00 <ClaudiusMaximus> oh, thought you need --RTS for that?
01:18:06 <merijn> ClaudiusMaximus: No
01:18:10 <ClaudiusMaximus> cool :)
01:18:19 <dminuoso> ClaudiusMaximus: The -- is a common convention in the linux world.
01:18:33 <merijn> ClaudiusMaximus: At least, with cabal I don't, and since they both use the GHC RTS I see no reason for stack to be different :p
01:18:46 <dminuoso> ClaudiusMaximus: It's designed for when your program invokes some other sub-program, then -- is the separator between "arguments for the outer program" and "arguments for the inner program"
01:18:47 <merijn> dminuoso: s/linux/posix\/*nix
01:18:58 <dminuoso> ClaudiusMaximus: Keep in mind, this is a convention only.
01:19:38 <dminuoso> merijn: I was only making a statement about what I know. :)
01:19:49 <dminuoso> And I only know this to hold true in plenty linux applications.
01:20:36 <ph88> hc, stack does not accept flag "ghc-options" for command "exec"
01:20:51 <dminuoso> ph88: Use `--profile`
01:21:31 <dminuoso> e.g.:  stack exec --profile -- my-exe +RTS -p
01:21:39 <dminuoso> That's the documented method.
01:21:45 <ph88> that seems to work ye ... but so strange that i can not pass the RTS options directly ?!
01:22:35 <hc> welcome to layers of software stacked together :-)
01:22:56 <Rembane> That sounds like a great game show 
01:23:13 <dminuoso> We should have a Haskell Jeopardy show.
01:23:19 <merijn> ph88: Define "pass directly"
01:23:39 <ph88> after -- 
01:24:02 <dminuoso> ph88: So take the standalone binary.
01:24:24 <merijn> ph88: What does "after --" mean? Without the +RTS?
01:24:38 <dminuoso> ph88: GHC binaries come with a RTS, in order to avoid conflicts with flags your program itself accepts, the flags to the RTS must be recognizable.
01:24:57 <dminuoso> So `./foo -p` is the -p an argument to the program or the RTS?
01:26:56 <dminuoso> Now, one possible way in the design space would have been to pass options to the RTS as environment variables. Say `RTS_OPTS="-p" ./foo`, but the way GHC chose it, is that the RTS will consume options +RTS ... -RTS, so that when you have `./foo +RTS -p -RTS -p2`, then if you used `getArgs` in your program you'd only see `-p2`
01:27:13 <dminuoso> Because the RTS would consume the first three argument `+RTS`, `-p` and `-RTS`
01:27:19 <dminuoso> And then feed the rest to your programs
01:27:31 <dminuoso> (And the RTS itself would then consider the content between +RTS and -RTS as flags to the RTS itself)
01:28:29 <ph88> merijn, this was the command i tried before which was not working:   stack exec -- program +RTS -hT -s -RTS generate  
01:28:58 <dminuoso> ph88: Whether or not the RTS will consume flags to itself depends on the linker options.
01:29:31 <dminuoso> If the ghc does not receive `-rtsopts`, then the RTS will *not* consume `+RTS -hT -s -RTS`, and feed them as arguments to your haskell program instead.
01:29:48 <dminuoso> The flag `--profile` will, implicitly, pass that flag `-rtsopts` to ghc.
01:29:48 <ph88> ye
01:30:19 <ph88> but ghc is the compiler so i would expect that to matter only with   stack build,   not with stack exec
01:30:41 <dminuoso> ph88: `stack exec` has to invoke the compiler too. :)
01:30:52 <dminuoso> stack exec is essentially "build, locate the executable and run it"
01:31:10 <ph88> oh i thought since i had already build it that it would just execute
01:31:32 <dminuoso> ph88: Sure, but if it was built without the -rtsopts flag..
01:31:48 <ph88> i had build it with   stack build --executable-profiling --ghc-options="-rtsopts" 
01:32:08 <dminuoso> ph88: Think of exec as "build-and-run" - does that help?
01:32:19 <ph88> ye
01:32:57 <ph88> now i don't get out of memory anymore but i get a lot of GC actions
01:33:36 <ph88> 690,962,104 bytes allocated in the heap    ok 690 megabyte .. not that bad, but still bad
01:33:46 <ph88> but this ..   60,200,459,560 bytes copied during GC  
01:34:36 <dminuoso> ph88: This is normal.
01:35:18 <ph88> 60 gigabytes ?????
01:35:28 <dminuoso> GHC uses a moving garbage collector, so each time the GC runs, it copies the active memory into a second area.
01:35:37 <Rembane> ph88: What does your memory allocation curve look like?
01:35:39 <dminuoso> (Anything left behind is thus implicitly "reclaimed")
01:36:11 <ph88> Rembane, how can i get this curve ?
01:36:38 <ph88> i made a postscript file with hp2ps  it shows like a block and the graph tops out at 30 megabyte
01:36:44 <dminuoso> ph88: 60g might not be much, it depends heavily on how long it runs.
01:37:07 <dminuoso> (It's the total bytes the moving GC copied between the two areas forth and back, accumulated)
01:37:32 <boxscape> how often does the gargabe collector tend to copy the active objects on the heap (rough order of magnitude wise)?
01:37:50 <dminuoso> boxscape: How often? Every time?
01:38:07 <boxscape> what I'm lookin for is something like "once every x seconds"
01:38:17 <boxscape> where "x" or even the unit is approximate
01:38:21 <merijn> boxscape: Impossible to answer
01:38:32 <boxscape> depends on how fast memory fills up?
01:38:50 <merijn> boxscape: How fast it fills, how fast it frees, which generation is filling up/freeing
01:38:54 <boxscape> I see
01:39:35 <merijn> ph88: What's the max residency?
01:39:51 <ph88> 36 megabytes
01:39:57 <merijn> Oh, that's fine
01:39:59 <ph88> but the program is much much slower than i expect
01:40:11 <ph88> maybe instead of looking at memory i should look at where time is spend now
01:40:20 <merijn> The two numbers to care about (with regards to GC) are: max residency and productivity
01:40:28 <merijn> ph88: What's the productivity number?
01:40:41 <ph88> 94%
01:41:12 <merijn> ph88: Ok, so with 94% productivity and 36 max residency it sounds like the problem is "your code is slow" and not the GC being a problem :)
01:41:34 <ph88> it was an out of memory before but then i build with profiling support and it changed to another problem
01:41:48 <dminuoso> merijn: What does productivity measure?
01:42:07 <merijn> dminuoso: Percentage of time doing mutation (i.e. user code) vs time spend GCing
01:42:21 <merijn> So productivity of 94% means only 6% of your time is GC time
01:42:24 <dminuoso> Mutation of memory?
01:42:35 <dminuoso> As in allocations?
01:43:05 <merijn> dminuoso: No, in GC terms "the mutator" is "the bit that executes Haskell" as opposed to the garbage collector
01:43:46 <merijn> ph88: You can get the GC stats without using profiling build, btw
01:44:13 <merijn> "+RTS -s" works even in non-profiled builds, as long as you compile with -rtsopts
01:44:15 <boxscape> this talk was pretty interesting, which, although it's about the alternative gargabe collector, still has a lot of info about the main one https://www.youtube.com/watch?v=7_ig6r2C-d4
01:44:36 <ph88> merijn, and for -hT profiling is needed ??
01:49:16 <merijn> ph88: Possibly? Consult the GHC user's guide :)
01:54:22 <dminuoso> merijn: In what sense is the word mutator taken then?
01:54:26 <dminuoso> As in mutating the expression graph?
02:01:16 <maerwald> I'm finally considering switching to emacs for haskell... it's 2020 and vim still can't distinguish tab from ctrl-i
02:01:17 <merijn> yeah
02:01:54 <merijn> maerwald: That sounds like a terminal config issue, not a vim issue, tbh
02:02:01 <maerwald> merijn: no
02:02:19 <maerwald> tab IS ctrl-i 
02:02:24 <maerwald> in the terminal
02:02:35 <davve> TIL
02:02:51 <maerwald> https://www.emacswiki.org/emacs/TabKey
02:02:57 <merijn> So why would you expect it to distinguish them, then?
02:03:00 <maerwald> guis can support more
02:03:04 <merijn> davve: ctrl-[ is esc ;)
02:03:10 <maerwald> i don't use the terminal.
02:03:23 <merijn> davve: So you don't have to move your hands of homerow :p
02:04:01 <davve> i usually do ctrl-c to get to visual mode
02:04:54 <davve> which is the same as sending a kill/interrupt signal to the process?
02:05:15 <davve> merijn: [ is not a convenient key on my keyboard layout unfortunately
02:05:22 <davve> it would mean 3 presses
02:05:41 <davve> but thanks for the information!
02:11:18 * hackage pusher-http-haskell 1.5.1.14 - Haskell client library for the Pusher Channels HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.14 (willsewell)
02:11:34 <maerwald> merijn: and libtermkey is supposed to be able to distinguish those, yet neovi
02:11:47 <maerwald> neovim doesn't
02:41:04 <jusss> how to get the last number of a long number? like get 3 from 150232341234213
02:41:22 <juri_> mod 10? ;)
02:41:48 <merijn> "last . show" ? >.>
02:42:13 <jusss> merijn: it need to be a Int
02:42:39 <__monty__> > read . last . show $ 1451235252353 :: Int
02:42:42 <lambdabot>  error:
02:42:42 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
02:42:42 <lambdabot>        Expected type: Integer -> String
02:43:04 <__monty__> > read . singleton . last . show $ 1451235252353 :: Int
02:43:06 <lambdabot>  error:
02:43:06 <lambdabot>      • Variable not in scope: singleton :: Char -> String
02:43:06 <lambdabot>      • Perhaps you meant one of these:
02:43:11 <__monty__> > read . pure . last . show $ 1451235252353 :: Int
02:43:12 <lambdabot>  3
02:43:46 <boxscape> I liked juri_'s suggestion
02:44:14 <juri_> > mod 150232341234213 10
02:44:17 <lambdabot>  3
02:52:18 * hackage ormolu 0.1.1.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.1.0 (mrkkrp)
02:54:00 <jusss> I see
03:05:34 <dminuoso> merijn: https://gist.github.com/dminuoso/fcf30cdd54f1d40c6706226deb677ddc gah.
03:06:18 <merijn> :p
03:08:35 <freeman42x[m]> what was that Haskell function that gives 1 for positive, 0 for 0 and -1 for negative numbers?
03:08:48 <merijn> signum?
03:08:50 <merijn> > signum 5
03:08:52 <lambdabot>  1
03:09:18 <Ariakenom> one of 2 Num methods with a law iirc
03:10:58 <dminuoso> merijn: There's something annoying about this though. Ideally I'd like some `Map DevName (HostMeta s)` with an existential s in such a way, that when I lookup a device that is an Underlay device, I dont get those Maybes in my face.
03:16:47 <ClaudiusMaximus> > signum (1 :+ 1)
03:16:49 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
03:19:58 <Ariakenom> dminuoso,  I dont know the question but is the answer dependent-map?
03:23:45 <dminuoso> Ariakenom: Im not sure, every thought I have ends up in singletons or unsafeCoerce. :(
03:24:09 <dminuoso> I have runtime knowledge whether a given DevName is Underlay or not.
03:28:41 <freeman42x[m]> is there a map with index function? I would rather not have to zip
03:29:20 <dminuoso> freeman42x[m]: zip.
03:29:26 <dminuoso> Why would you not have to zip?
03:29:50 <freeman42x[m]> because a function would be better
03:30:37 <Ariakenom> :t \f xs -> zipWith f [0..] xs
03:30:38 <lambdabot> (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
03:30:38 <dminuoso> % mapWithIndex f l = f <$> zip l [0..]
03:30:39 <yahb> dminuoso: 
03:30:45 <dminuoso> freeman42x[m]: There, you have a function.
03:30:53 <dminuoso> Or well, zipWith indeed. :)
03:31:41 <freeman42x[m]> dminuoso: I really wish you would stop this, it is quite annoying
03:31:59 <dminuoso> Provide you with an answer?
03:32:48 * hackage haskell-exp-parser 0.1.2 - Simple parser parser from Haskell to TemplateHaskell expressions  https://hackage.haskell.org/package/haskell-exp-parser-0.1.2 (EmilAxelsson)
03:35:02 <freeman42x[m]> dminuoso: trolling, you know very well that you not only have no answered but added 0 value
03:38:49 * hackage haskell-exp-parser 0.1.3 - Simple parser parser from Haskell to TemplateHaskell expressions  https://hackage.haskell.org/package/haskell-exp-parser-0.1.3 (EmilAxelsson)
03:40:09 <maerwald> freeman42x[m]: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-IntMap-Lazy.html#v:mapWithKey
03:40:23 <maerwald> use fromList first
03:40:57 <maerwald> but it really is the same
03:41:57 <maerwald> I would expect it to fuse if turned into list afterwards again
03:43:30 <dminuoso> Roundtripping through a Map...
03:44:28 <dminuoso> freeman42x[m]: Well zipWith is pretty much the function, if you insist on only accepting exactly what you are looking for, then you're limiting yourself arbitrarily and you risk asking too many XY questions.
03:44:31 <maerwald> well, zip was rejected as an answer ;)
03:44:54 <dminuoso> If you furthermore reject standard solutions to problems you present without reason, I cannot help you.
03:50:08 <phaazon> hey, quick question: if you have a type such as A x y z, if you substitute a single type variable, such as x = Int and re-exports a A y z = A Something y z
03:50:19 <phaazon> how do you call that process?
03:50:23 <phaazon> for sure it’s not « completely » monomorphized
03:50:32 <vaibhavsagar> can I get GHCi on my android phone?
03:50:41 <phaazon> I struggle to find the a suffix for a package I’m writing that does exactly that
03:50:51 <phaazon> re-exports symbols by applying concrete types
03:50:54 <phaazon> (those are backend types)
03:51:07 <boxscape> vaibhavsagar I've installed a nix shell app on my android phone and can get GHCi running in that pretty easily
03:51:15 <vaibhavsagar> oh nice
03:51:24 <vaibhavsagar> what's the app called?
03:51:47 <boxscape> vaibhavsagar it's just called "Nix", but let me see if I can find where I got it
03:52:29 <vaibhavsagar> https://github.com/t184256/nix-on-droid-app?
03:52:51 <boxscape> vaibhavsagar ah, yes, that looks right
03:53:04 <vaibhavsagar> very cool
03:53:56 <vaibhavsagar> phaazon: concrete instantiation?
03:54:24 <phaazon> yeah
03:54:31 <phaazon> so I could name my package foo-concrete
03:54:33 <phaazon> but… that seems weird
03:54:47 <vaibhavsagar> foo-instantiate
03:59:04 <boxscape> vaibhavsagar btw just figured out how I actually got it onto my phone, I installed F-droid and then the nix-on-droid package in there
03:59:52 <boxscape> maybe that's obvious from the nix-on-droid name
03:59:59 <boxscape> but I'd completely forgotten that f-droid exists until now
04:02:47 <vaibhavsagar> oh, good to know, i would have not figured that out on my own
04:03:10 <vaibhavsagar> phaazon: foo-cement
04:03:17 <vaibhavsagar> because it's not concrete but halfway there
04:07:17 <boxscape> vaibhavsagar btw are you familiar with nix?
04:07:43 <vaibhavsagar> boxscape: very much so
04:07:47 <boxscape> ok, good
04:08:00 <lortabac> phaazon: I would append the name of the concrete type I am instantiating to
04:10:56 <phaazon> lortabac: that type is deduced at compile-time
04:10:59 <phaazon> I’ll go with -front
04:11:07 <phaazon> as it’s going to be a front-facing API for end-user
04:11:22 <phaazon> (vs. people writing middlewares, who shouldn’t use that -front API but the regular one)
04:28:27 <Eduard_Munteanu> phaazon, you could call the A x y z the more "generic" type.
04:28:53 <Eduard_Munteanu> phaazon, so API vs GenericAPI maybe?
04:29:13 <Eduard_Munteanu> If you don't have a better name for the more specific stuff, maybe you can find a prefix for the generic stuff.
05:22:22 <jumper149> I have a fundeps type class like `class KnownNat n => A a n | a -> n`. Can I rewrite this with type families? I am currently running into errors, because n has kind Nat and not kind *.
05:29:39 <lortabac> jumper149: try annotating n with a kind signature
05:32:05 <jumper149> Oh ye, I tried that before but messed up the syntax. It works now :)
05:32:31 <solonarv> as a general rule, you can *always* rewrite from fundeps to tyfams and vice versa
05:32:45 <solonarv> (although the mechanical translation is rarely pretty)
05:32:53 <jumper149> solonarv: That's what I have been reading everywhere too :D
06:26:48 * hackage random 1.2.0 - Pseudo-random number generation  https://hackage.haskell.org/package/random-1.2.0 (lehins)
07:09:27 <jusss`> I use cabal v2-install random on alpine, but when I do cabal v2-repl -b random, ghci tell me there's no module System.Random.Shuffle, why this happend?
07:10:19 <merijn> jusss`: Because that module isn't in random?
07:10:25 <solonarv> jusss`: looking at 'random' on hackage, it doesn't seem to contain a System.Random.Shuffle module
07:18:18 * hackage parsek 1.0.2.0 - Parallel Parsing Processes  https://hackage.haskell.org/package/parsek-1.0.2.0 (JeanPhilippeBernardy)
07:21:05 <hseg> Hi. Trying to bundle up a bunch of conversion functions in a highly overlapping class, was hoping typeaps would suffice to guide instance selection. before i embark on this refactor, am i being crazy?
07:22:03 <jusss`> ok, random-shuffle
07:22:23 <dminuoso> hseg: Or use Proxy.
07:22:27 <merijn> hseg: Without further context that sounds like a terrible idea
07:22:30 <dminuoso> hseg: I found that frequently Proxy has far better ergonomics.
07:22:50 <merijn> dminuoso: Or, crazy idea, don't have highly overlapping classes
07:23:00 <dminuoso> Hey Im not one to judge.
07:24:11 <hseg> yeah... actually, on further thought i think i can just use the same type everywhere -- it's not as if the distinction is buying me anything here
07:24:43 <hseg> Pity i'm only realizing this *after* writing the first draft of the code
07:31:49 <dminuoso> hseg: Its probably *because* you wrote the first draft of the code.
07:33:32 <hseg> fair
07:34:39 <hseg> been refactoring the code, noticed i could avoid multiple dependencies, some components are now redundant. a shame about that waste of time, but happens
07:41:12 <ph88> here is a sentence saying "particularly useful" .. how is it particularly useful though ?? https://downloads.haskell.org/ghc/latest/docs/html/users_guide/profiling.html#ghc-flag--fprof-auto-calls 
07:45:33 <bollu> where precisely is IO wired into the compiler?
07:45:55 <bollu> Or, like, where do I find `data IO = ... ` or `type IO a = ...`
07:48:20 <edwardk> bollu: https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/wired-in
07:48:56 <edwardk> "wired ins" aree the things like IO that the compiler has to know about to function
07:49:21 <edwardk> there are various degrees of wired-in-ness
07:50:08 <dminuoso> Mmm, that page doesn't appear to load.
07:50:30 <merijn> IO isn't wired in, though
07:50:34 <merijn> IO is in ghc-prim
07:50:37 <bollu> Ah, I see. Thank you. 
07:50:43 <merijn> @hackage ghc-prim
07:50:43 <lambdabot> https://hackage.haskell.org/package/ghc-prim
07:50:58 <merijn> bollu: If you care about compiler primitives, ghc-prim is (one of) the place to go
07:52:06 <bollu> merijn do you know where in ghc-prim it's defined? I wanted to find the type alias to State# RealWorld#
07:52:21 <dminuoso> merijn: How does one construct arbitrary IO effects correctly?
07:52:39 <merijn> bollu: No one told you about hackage's greatest feature? :>
07:52:41 <edwardk> IO is known to the compiler through https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/GHC/Builtin/Names.hs#L1476
07:52:47 <merijn> bollu: You press 's' and type "IO"
07:53:14 <merijn> dminuoso: Very, very carefully ;)
07:53:24 <edwardk> so you can't move it from its home without moving those references
07:53:29 <bollu> merijn sweet :D 
07:53:37 <dminuoso> merijn: are there examples to look at?
07:54:04 <merijn> dminuoso: Probably, don't ask me where, though ;)
07:54:06 <dminuoso> Heh.
07:54:10 <bollu> I was wondering what the difference was between Hugs and GHC wrt IO: https://github.com/bollu/hugs/blob/6637409dc45be10c559ed4e250acd0c3ced58559/libraries/Hugs/Prelude.hs#L1858
07:54:12 <edwardk> so by the standards of that page, IO isn't "wired in" but it is a "known-key thiing"
07:54:17 <merijn> dminuoso: I mean "stToIO", but that's not very helpful
07:54:18 <bollu> It's been interesting to read Hugs source. 
07:54:39 <merijn> bollu: State# and friends are also discussed in the "Lazy Functional State Threads" paper
07:54:50 <dminuoso> Operationally I understand the the IO effect when the internal thing of an IO is demanded.
07:54:54 <bollu> merijn great, thank you. 
07:54:57 <dminuoso> Operationally I understand the the IO effect *happens* when the internal thing of an IO is demanded.
07:54:59 <merijn> bollu: (Which is mostly about ST, but it covers ST and IO being special cases of State#)
07:55:15 <dminuoso> Does that mean you'd IO effects as STG closures?
07:55:50 <merijn> dminuoso: IO in GHC is really just "State with a non-existent magic token"
07:56:03 <merijn> dminuoso: i.e. it preserves the ordering
07:56:11 <dminuoso> That part Im well aware of.
07:56:50 <merijn> dminuoso: What's the unclear part, then?
07:56:52 <dminuoso> merijn: If you look at it closely, you'll see that the State token is an unlifted unit, so we can pretend that `newtype IO a = IO a` with some squinting, where the value of `a` is produced by forcing it.
07:57:09 <dminuoso> Im just wondering where the effects happen.
07:57:24 <merijn> dminuoso: There's no such thing/notion, really
07:57:28 <merijn> It's all smoke and mirrors
07:57:30 <dminuoso> Do values of type IO get compiled to special STG code where the entry code does regular magic, and then write the result back?
07:57:34 <edwardk> dminuoso: there is a rather subtle distinction being madee. an IO a is State# RealWorld -> (# State# RealWorld, a #) internally. what is being demanded is the (# State# RealWorld, a #) -- which is basically (# a #) with a little tag saying 'please don't reorder me' you're forcing the (# #), not the 'a' to demand the result out of an IO computation behind the scenes. i can give back a lazy result, but do all the computation to deteremine 
07:57:34 <edwardk> it up front in the set up for that (# #) 
07:57:59 <dminuoso> edwardk: I think we're at a crossroads here
07:58:08 <dminuoso> No that's the wrong idiom, heh.
07:58:10 <jusss`> how to exit in IO's do notation? like detect input parameters if it's two parameters, otherwise exit whole program
07:58:23 <merijn> jusss`: You want System.Exit
07:58:30 <dminuoso> edwardk: State# RealWorld is just an unlifted unit, right?
07:58:30 <jusss`> args <- getArgs
07:58:33 <dolio> IO in GHC is just implemented with side effectful functions.
07:58:43 <dolio> Or 'functions'.
07:58:44 <jusss`> merijn: ok
07:58:59 <edwardk> dminuoso: yes,  but (# a #) once you strip it away is more than just 'a'
07:59:34 <merijn> dminuoso: There's no man behind the curtain
08:00:03 <edwardk> dminuoso: there's a reason why, say, all the operations in primitive behind the scenes for reading from Arrays have versions that return (# a #) rather than a. (Well, the deep hidden ones, the surface ones wrap that in a State# s -> (# State# s, a #) dance
08:00:28 <edwardk> because you want to know you did the array access rather than leaving a thunk to do it
08:00:43 <edwardk> dolio++
08:01:46 <dminuoso> Put it differently, say I have some assembly code I want to wrap up in IO.
08:01:50 <dminuoso> How would I go about it?
08:02:12 <dminuoso> (For the sake of discussion, lets ignore portability issues)
08:02:52 <dminuoso> I mean there must be some place where you actually tie in the code that does nasty things with the mutator in GHC, right?
08:03:20 <dminuoso> Or is this (# #) some special GHC shenanigans?
08:03:45 <merijn> dminuoso: The code *is* the nasty things
08:04:07 <merijn> dminuoso: There's no magic separation between "dirty side-effects" and "just a function" at this level
08:04:22 <merijn> dminuoso: The palce where everything ties into the nasty things is...the code
08:04:28 <jusss`> what's the function name to check string if they're digital? like "123" is true, "abc" is false, "a23" is false
08:04:42 <dminuoso> % :t isDigit
08:04:42 <yahb> dminuoso: Char -> Bool
08:04:49 <dminuoso> % :t all isDigit
08:04:49 <yahb> dminuoso: Foldable t => t Char -> Bool
08:04:57 <jusss`> ok
08:05:21 <dolio> It's not very clear what you're asking about, because it seems like you're conflating all kinds of stuff from different levels of abstraction.
08:05:30 <dminuoso> That is quite possible.
08:08:21 <dminuoso> From an STG perspective, where do effects happen?
08:08:29 <dminuoso> (Specifically the IO effects)
08:09:31 <merijn> dminuoso: Everywhere, nowhere, and everything in between
08:09:36 <dolio> There are just functions with side effects, with types similar to `State# RealWord -> (# State# RealWorld, a #)`.
08:09:37 <merijn> dminuoso: STG doesn't care about effects
08:09:41 <merijn> dminuoso: It calls functions
08:09:51 <merijn> dminuoso: Maybe those functions print to the screen, maybe they don't
08:10:23 <merijn> dminuoso: There is not separation, because that's not what STG is for
08:10:28 <dolio> STG just tells you precisely how everything is evaluated.
08:10:41 <merijn> The separation/etc. is already guaranteed and enforced by the compiler
08:10:48 <dolio> Like, precise operational stuff.
08:13:48 <boxscape> is the idea of a haskell program being a pure program that builds up an impure computation not true anymore at the STG level (assuming it's true on any level, I'm not entirely sure)
08:13:51 <boxscape> ?
08:14:40 <merijn> boxscape: Haskell has a certain specified semantics (i.e. what does code mean), "pure program that builds up an impure computation" is a fine mental model for that
08:15:06 <merijn> boxscape: However, where people get confused is: That's all about what code *means*
08:15:07 <boxscape> ok
08:15:26 <boxscape> ok I see what you're getting at
08:15:32 <merijn> boxscape: Compilers (like GHC) promise to do semantics *preserving* transformations. i.e. code goes in, something comes out
08:15:47 <merijn> The compiler promises "whatever comes out has the exact same semantics as the input"
08:16:01 <merijn> The compiler does *not* make any promises on *how*
08:16:18 <boxscape> I see
08:16:32 <merijn> boxscape: So generating code that uses all sorts of dirty mutation/whatever is perfectly fine, *if* that fact is never observable
08:16:42 <boxscape> right
08:17:43 <dolio> You could implement IO in other ways where there wouldn't be 'functions' with side effects at something like the STG level.
08:19:22 <dolio> But I don't know that it would do anyone much good.
08:20:00 <boxscape> is IO in Core treated more like in Haskell or more like in STG? (I would guess Haskell since you can typecheck Core?)
08:20:31 <hseg> i have a bunch of boilerplate of the form deriving newtype instance C (F a) => C (N (F a)) -- is there some way to reduce it?
08:20:42 <dolio> IO is just a newtype of `State# RealWorld -> (# a , State# RealWorld #)`
08:20:55 <hseg> preferably as a deriving clause for N's declaration
08:20:59 <dolio> All of this is accessible in the surface syntax of GHC.
08:24:08 <hseg> similarly, i have a bunch of newtypes over Nat -> * for which i only need an additional KnownNat n context. But that is enough to trip up ghc
08:26:38 <boxscape> dolio so, is the point of saying that to say that you needn't adhere to the pure/impure distinction in (GHC) haskell either? (I suppose by importing the relevant prim modules and using them directly)
08:28:08 <dolio> Well, since it's a newtype in the surface syntax, that tells you what it's like in core.
08:28:22 <boxscape> ah, right, okay, that makes sense
08:28:45 <dolio> And yeah, the point is that a lot of the stuff surrounding IO is just normal stuff that the compiler does.
08:29:02 <boxscape> ok
08:33:36 <dolio> There's lots of other stuff like that. The surface syntax has unboxed ints, and Int is just a data type containing an Int#. That doesn't mean you should write code with Int# directly necessarily, but it means that all the glue code can just be written in GHC's surface language, rather than some extra lower level or something.
08:36:26 <hseg> hrm. this seems like it is doable with constraints, but i don't know enough about how to use the package
08:39:03 <ski> ah, now i see. it was in #asperger
08:53:05 <jusss`> which function can do like getLine but don't show what your input?
08:53:18 <jusss`> like a password input
08:54:20 <[exa]> jusss`: you might want to wrap the related functions from C libraries; reading passwords is not fun
08:55:28 <jusss`> [exa]: I don't ask for a high-secure function, just like that <type=password> in html will be ok
08:55:39 <jusss`> just don't show what your input
08:55:47 <jusss`> replace them with * or anything else
08:56:27 <jusss`> it's just a personal program, not something big
08:57:54 <[exa]> jusss`: the problem is that you need to manipulate terminal settings for that to work
08:58:01 <[exa]> cf https://opensource.apple.com/source/OpenSSH/OpenSSH-209/openssh/openbsd-compat/readpassphrase.c.auto.html
08:58:35 <[exa]> anyway there should be a way to just disable the local echo temporarily
09:00:10 <[exa]> it seems that System.Posix.Terminal has TerminalMode, using which you should be able to set EnableEcho to off
09:00:53 <jusss`> right
09:02:47 <superstar64> are `newtype` wrapper over unboxed types a thing yet?
09:05:30 <boxscape> superstar64 https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0098-unlifted-newtypes.rst was implemented in 8.10 apparently
09:06:12 <superstar64> cool
09:07:07 <ph88> mpickering, you here ?
09:08:34 <ph88> i was wondering what the -l-au flag is to the RTS
09:11:54 <alp> ph88, it suppresses "RTS events", to only emit user events.
09:12:24 <alp> so you wouldn't get all the events about threads doing this or that, etc. just the ones you (and your deps) emit.
09:12:46 <alp> https://downloads.haskell.org/~ghc/8.6.5/docs/html/users_guide/runtime_control.html#rts-eventlog has the long explanation.
09:23:38 <dminuoso> Gah, why cant I do `deriving instance Eq (TyFam T)`?
09:23:58 <Cale> There can't be an instance Eq (TyFam T)
09:24:28 <Cale> You can possibly derive an instance for whatever that type family evaluates to at T, provided that it unfolds
09:24:54 <dminuoso> Mmm, so I cant have automatically derived Eq/Show instances for higher kinded data types?
09:25:10 <Cale> Instances just need a type constructor to match on.
09:25:19 <dminuoso> Ah.
09:25:27 <ezzieyguywuf> if Data.List.filter is 'unsafe' because it is a partial function, what is an alternative?
09:25:37 <superstar64> filter is partial?
09:25:38 <ezzieyguywuf> or is it acceptable to simply check for an empty list prior to using filter?
09:25:46 <Cale> filter isn't partial
09:25:48 <dminuoso> ezzieyguywuf: What makes you say its partial?
09:25:52 <ezzieyguywuf>  filter (const False) [0..] 
09:25:59 <ezzieyguywuf> according to this: https://wiki.haskell.org/List_of_partial_functions#Partial_functions_in_Prelude
09:26:03 <Cale> Ah, haha, I suppose
09:26:27 <dminuoso> Is a non-partial version of filter with that regard even possible?
09:26:44 <Cale> There's no alternative which can fail any more quickly in the case of an infinite list
09:26:57 <Cale> because if you had one, you could use it to solve the Halting Problem
09:27:13 <dminuoso> I dont think this is the halting problem, is it?
09:27:36 <ezzieyguywuf> so probably I can just use filter and be happy then?
09:27:50 <Cale> Yeah
09:27:55 <dminuoso> ezzieyguywuf: Absolutely, its just saying that if you filter with a predicate that never comes true on an infinite list, you will wait a very long time..
09:28:09 <ezzieyguywuf> hrm
09:28:15 <dminuoso> Because filter will try that predicate against every element, and it never produces a single result where you'd stop due to WHNF.
09:28:25 <Cale> You're going to be waiting a very long time if you want to fully evaluate the resulting infinite list anyway
09:28:49 <ezzieyguywuf> what is WHNF+
09:28:49 <dminuoso> Well you might not have to wait that long if filter produced at least one result.
09:29:07 <ezzieyguywuf> I'll satisfy myself with avoiding head and tail for now
09:29:10 <dminuoso> ezzieyguywuf: Evaluation takes place, roughly, until the first data constructor is observed. The contents are not further evaluated unless demanded.
09:30:12 <ph88> thanks alp
09:31:21 <dminuoso> (There's some other boundaries, but I dont want to overly confuse you with this)
09:32:30 <dminuoso> ezzieyguywuf: Consider some `evens = filter even [1..]`, now obviously we cant compute this entire list because its infinite.
09:32:40 <dminuoso> % evens = filter even [1..]
09:32:40 <yahb> dminuoso: 
09:32:44 <dminuoso> % take 1 evens
09:32:44 <yahb> dminuoso: [2]
09:33:03 <dminuoso> This works, because `evens` is only evaluated as far as the first data constructor (:)
09:33:20 <dminuoso> It's not evaluated any further than that.
09:35:16 <amf> what is the newest way to do something like runEitherT (from either package), now that it is deprecated? (a bit surprised by that)
09:35:32 <dminuoso> amf: runExceptT
09:35:47 <amf> dminuoso: from mtl?
09:36:28 <dminuoso> amf: transformers is the correct package
09:36:32 <dminuoso> (mtl just reexports it)
09:37:06 <hc> oh cool, there are multiple bots in here? what's the difference between lambdabot and yahb ?
09:38:57 <amf> ah right, i was hoping for a good way to do avoid the deeply nested error checking, and liked the either `left err` approach. is `throwError` the equivalent? 
09:39:30 <ezzieyguywuf> hrm, I feel like I'm reinventing the wheel. I want to allow my user to provide a stringe "cmd1 arg1 arg2" and turn this into haskell `cmd1 arg1 arg2` where `cmd1 :: arg1 -> arg2 -> String`
09:40:36 <rkaippully> does fused-effects have an equivalent of polysemy's reinterpret?
09:46:14 <dminuoso> hc: yahb is just a GHCi interface, wheras lambdabot not.
09:46:28 <dminuoso> Also, lambdabot has loads of plugins and features beyond compiling code.
09:47:07 <dminuoso> They also differ slightly in available packages.
09:48:29 <zebrag> Beside everything else, one must admire the mastery of ascii diagrams: http://pages.cs.wisc.edu/~horwitz/CS704-NOTES/1.LAMBDA-CALCULUS.html
09:51:37 * [exa] wishes there was a prettyprinter for that
10:02:26 <ezzieyguywuf> perhaps I should just embed ghci in my Main and be done with it...
10:03:05 <monochrom> zebrag: Pretty impressive in the diamonad property proof, yeah
10:03:46 <monochrom> Now, would you marvel at my SVG skill in my http://www.vex.net/~trebla/haskell/lazy.xhtml ? :)
10:12:13 <superstar64> what's an inductive data type?
10:14:00 <monochrom> Is it in contrast to co-inductive data type?
10:14:45 <superstar64> i guess? i'm reading one of oleg's papers
10:14:56 <monochrom> or is it in contrast to arbitrary data types :)
10:15:35 <superstar64> "Therefore, IR h t is not an inductive data type and is not representable as a fix-point of a functor"
10:15:39 <superstar64> from the tagless final paper
10:16:02 <monochrom> I bet you can do induction proofs by structural induction on an inductive data type.
10:17:53 <monochrom> ls /mnt/c
10:18:02 <monochrom> oops wrong window. actually worse.
10:20:08 <dolio> It's just a data type. The initial algebra of a functor. In total languages (but not Haskell), that may be distinct from the final coalgebra of the same functor.
10:21:10 <dolio> Also, depending on how you're defining things, that might mean not a GADT (which would be an 'indexed inductive type' or 'inductive family').
10:23:26 <dolio> Inductive families are still initial algebras/fixed points of functors, though, so it sounds like that paper is not ideal in its precision.
10:24:45 <dolio> At least, it might give someone the wrong idea.
10:24:47 <dmwit> ezzieyguywuf: Maybe relevant: https://stackoverflow.com/q/6846027/791604
10:30:22 <dolio> Actually, it might be correct, depending on what it's talking about (from what I recall about the paper). However, in my experience, a lot of the terminology and categorical claims surrounding 'finally tagless' stuff don't make a whole lot of sense.
10:36:53 <ezzieyguywuf> dmwit: it is relevant thank you. reading now.
10:41:51 <ja> monochrom: for future reference, i think it would be nice if your document had a date of late update. occasionally i stumble upon some document talking about MonadFail only to realize that it is ancient
10:42:00 <ja> *last
10:44:48 * hackage pandoc-citeproc 0.17.0.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.17.0.1 (JohnMacFarlane)
10:46:15 <ja> the images are very nice
10:51:47 <superstar64> where can i learn about skolemization in regards to functional programming?
10:58:47 <freeman42x[m]> if I have a ("something", "else") how can I best extract the values from it and do an operation using both returning another value?
10:59:03 <ezzieyguywuf> freeman42x[m]: fst and snd maybe?
10:59:17 <ezzieyguywuf> although, are you sure a tuple is the correct datatype for this use case?
10:59:25 <hseg> freeman42x[m]: i.e. you want sth :: (a -> b -> c) -> ((a, b) -> c) ?
10:59:45 <superstar64> i already know the basic trick of `forall r. (forall a. f a -> r) -> r = exist a. f a`
10:59:46 <ezzieyguywuf> I guess you could just pattern match, `let (a, b) = ("something", "else")`
10:59:48 <freeman42x[m]> this is what gives me the tuple: (!!2)&&&(!!3)$lines s
10:59:57 <superstar64> i'm just wondering how much more is htere
11:00:10 <ezzieyguywuf> yikes
11:00:16 * ezzieyguywuf steps away
11:00:35 <monochrom> Yeah, what's wrong with pattern matching and KISS?
11:00:37 <hyiltiz> take 2nd then the third then split into lines?
11:00:59 <hyiltiz> freeman42x[m]: u seem to be reimplementing parsec
11:01:45 <monochrom> No, let's not bring up parsec.
11:01:54 <monochrom> or any extrapolation at all
11:02:00 <dsal> :t both -- freeman42x[m] 
11:02:02 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
11:03:21 <hseg> q: is there a naming convention for a version of function reflecting an Int to the type level? (i.e. I have f :: KnownNat n => (f n -> c -> a) -> f n -> a, what should I call f' :: Natural -> (forall n. KnownNat n => f n -> c -> a) -> (forall n. KnownNat n => f n) -> a ?) 
11:05:20 <monochrom> I think it's someNatVal in e.g., GHC.TypeNats
11:05:57 <monochrom> SomeNat is an existential type that does the "KnownNat n =>" for you
11:06:00 <dsal> :t bimap -- freeman42x[m] or bimap... what are you trying to do?
11:06:01 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:07:09 <hseg> yes, i'm just exposing an api where i'm giving the choice bw passing the Nat at the type level or at the term level
11:07:25 <hseg> each is convenient is in its own context
11:07:40 <hseg> was just wondering if there was a convention for such variants
11:09:23 <freeman42x[m]> dsal. I am playing Clash of Code and unfortunately it is using the haskell platform libraries which do not include Lens
11:09:40 <dsal> Do you have binfunctor?
11:09:44 <dsal> er, bifunctor
11:11:10 <freeman42x[m]> dsal: that is in base, so... actually I do not know, it is using: Haskell Platform 8.4.3 so dunno if it was present back then
11:13:48 <dsal> I think it's been a while.
11:14:23 <dsal> > let bof f = bimap f f  in    bof length ("something", "else")
11:14:25 <lambdabot>  (9,4)
11:15:53 <dsal> :t first -- ezzieyguywuf note that fst and snd have first and second in bimap
11:15:54 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
11:16:23 <dsal> Oh weird, that's not the one I expected.
11:16:25 <dsal> @hoogle first
11:16:25 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
11:16:25 <lambdabot> Data.Bifunctor first :: Bifunctor p => (a -> b) -> p a c -> p b c
11:16:25 <lambdabot> Text.PrettyPrint.Annotated.HughesPJ first :: Doc a -> Doc a -> Doc a
11:17:46 <dsal> Also, I meant bifunctor.  I should stop trying to communicate with people until after lunch.
11:20:52 <svipal> crystal /ruby modules are really really weird when you come from haskell wew
11:21:18 <superstar64> idk ruby, what's weird about them?
11:21:55 <superstar64> can't be any weirder then java's
11:22:04 <sm[m]> freeman42x: nice, a fellow hs Clasher !
11:22:23 <monochrom> No, javascript and C are weirder.
11:22:23 <svipal> just realized the reason I couldn't change the String class was because I was inside a module. if I wanted to add methods to it I'd have to do it *outside* a module
11:22:54 <superstar64> c doesn't have a module system
11:22:58 <svipal> writing stuff outside modules is super weird to me after spending my haskell life having everything inside them (and having only 1 module per file and 1 file per module)
11:23:09 <monochrom> That's the source of the weirdness.
11:23:39 <svipal> *honestly feel like ruby is way weirder than javascript on that front but I might just be more used to js
11:24:18 <svipal> includes and extend border into mindfuckery
11:24:29 <dsal> The problem I have with java modules is that I wrote a library over ten years ago and my web server is constantly serving 410s for random java modules that I might have because I had a specific one there once.
11:24:49 <svipal> like, just read this lol https://crystal-lang.org/reference/syntax_and_semantics/modules.html
11:25:21 <dsal> I've thought about just serving up fake jars and letting apps break until they ban me from ever hosting java code again.
11:25:34 <svipal> I don't think there's anything in js where you can write a function where you can just use a variable that's not yet defined and just say, it will be defined in the class that includes the module lololol
11:25:52 <dsal> svipal: I use python libraries like that.
11:26:11 <dsal> It's more common in ruby to write "mixins" like this, but ruby and python are basically the same.
11:26:32 <svipal> yeah, but python likes to put on a front of stability :))
11:26:38 <dsal> (ICYMI: https://github.com/whymirror/unholy )
11:26:56 <superstar64> svipal does crystal use hindley milner?
11:27:08 <ezzieyguywuf> hrm, this seems relevant to me too: https://wiki.haskell.org/Parsing_a_simple_imperative_language
11:27:13 <svipal> I remember reading it uses some other kind of type inference
11:27:24 <superstar64> really? interesting
11:27:24 <svipal> that makes it unable to have a repl
11:27:47 <superstar64> i wonder why they didn't go with hindley milner
11:28:45 <svipal> remember reading it doesn't work if you have any kind of OOP because you can't have inheritance in hindley milner
11:29:10 <superstar64> can't hindley milner with qualified types handle that?
11:29:17 <dsal> ezzieyguywuf: writing proper parsers in haskell is like writing regex in perl, except, you know, it works better and solutions can be understood and maintained.  It's just easy and you'll want probably do it more than you strictly need to.  :)
11:29:25 <superstar64> like, you can fake subtyping with typeclasses right?
11:29:40 <svipal> I'm not well versed in how type inheritance works, sorry !
11:29:42 <freeman42x[m]> sm[m]: yeah, we are playing right now, there is another HS player also: http://twitch.tv/freeman42x
11:30:06 <Cale> superstar64: No, but you can get most of what you need for OO just by having first class functions. Subtyping was always kind of a red herring of OOP.
11:30:38 <Cale> The reason that subtyping exists in OO languages is that they conflate the types of objects with the implementations of methods
11:30:50 <Cale> So if you want to implement methods differently, you need a subtype
11:31:00 <maerwald> I've never understood this parser vs regex war. They are not the same. Regex is less expressive which in it's own has benefits.
11:31:32 <Cale> But if you just make a record of a bunch of methods, and implement different ways of filling those records out, that'll usually get you pretty much what you need.
11:32:42 <hseg> http://ix.io/2pXM ghc is complaining in weylΣGL' that the type-level Nat I'm passing isn't a KnownNat
11:33:47 <Cale> There's additional trickery that often goes on, like the implicit fixed point that gives you "this", and some cases where you have subclasses that have larger interfaces and stuff, but none of that is all that challenging to encode if you really want it. Usually it also comes with some pretty annoying downsides, to the point that people doing OO will avoid it.
11:34:31 <superstar64> i swear i remember reading that subtyping in hindley milner is possile
11:34:35 <hseg> but I don't see what I'm doing wrong -- I have a function weylΣ :: forall (n :: Nat). f n -> g n -> r, which I wrap with reifyNat to get weylΣ' :: Nat -> (forall n. f n) -> (forall n. g n) -> r, but then partial applications of the latter fail
11:35:09 <Cale> superstar64: Well, strictly speaking, type classes also break Hindley-Milner
11:35:29 <superstar64> break it how? the `read . show` problem?
11:35:35 <Cale> But you can get enough type inference that it's still practical
11:37:09 <sm[m]> freeman42x: and streaming eh.. nice. I will jump in to the next one
11:37:16 <superstar64> well, there's this https://www21.in.tum.de/~nipkow/pubs/aplas11.pdf but i haven't read it yet, so i'm unaware of any tradeoffs
11:37:39 <freeman42x[m]> sm[m]: cool, it is a great way to learn Haskell
11:41:05 <c_wraith> superstar64: the main thing it mentions is that the algorithm isn't really compatible with let-generalization
11:41:44 <c_wraith> Which isn't a showstopper.  GHC turns off let generalization in a lot of contexts, and it rarely causes issues.
11:41:54 <c_wraith> But it isn't HM anymore
11:42:08 <superstar64> does that include let for global bindings?
11:42:30 <superstar64> if so, wouldn't that mean everything would be monomorphic?
11:42:33 * sm[m] wonders if there's a list of ClashOfCode haskellers
11:44:12 <frdg> I just wrote a bash program that I wanted to go on forever and I used recursion. I saw in htop that my ram was getting filled very quickly. I have people say Haskell uses tail recursive optimizations. Is this related to what happened in my bash program?
11:44:31 <c_wraith> Nah, when GHC does it, it enables an extension called MonoLocalBinds
11:44:48 <c_wraith> That name suggests (accurately) that it's only local bindings that aren't generalized
11:44:55 <superstar64> frdg, it's only for tail recursion
11:44:57 <[exa]> frdg: bash doesn't do TCO
11:45:11 <[exa]> frdg: instead try something like `while : ; do .... ; done`
11:45:27 <monochrom> gcc -O2 also does TCO.
11:45:38 <frdg> [exa]: Right I realized pretty quick but I was trying to relate it to Haskell.
11:46:01 <superstar64> a while ago, i made a post describing the macro system i have in my language https://old.reddit.com/r/haskell/comments/h9lw97/kind_based_macros_on_terms/
11:46:17 <frdg> Ill look into TCO though thanks
11:46:33 <superstar64> this is similar to levity polymorphism type checking, in that runtime types cannot contain macro types
11:48:00 <monochrom> I wouldn't say that GHC does TCO. It's more subtle. I say that GHC's STG->Cmm stage does TCO.
11:48:41 <ezzieyguywuf> dsal: I like regex!
11:49:06 <frdg> Would recursively calling main be a bad idea?
11:49:33 <[exa]> in haskell? probably not, except for the possible surprise of whoever will read the code
11:49:35 <monochrom> The reason is that between Haskell and STG there is a big abstraction gap regarding evaluation order. At the STG level, evaluation order is sufficiently explicit, now it makes sense to talk of TCO at that point.
11:49:55 <monochrom> It makes much less sense to talk of it at the Haskell level, too high-level for that.
11:50:02 <superstar64> imagine if instead of, `TYPE Lifted`, we have `TYPE (Runtime Lifted)`
11:50:15 <[exa]> frdg: consider using `forever` instead
11:50:33 <frdg> alright thanks
11:50:43 <superstar64> then my macro system can be terms that are of type `TYPE a` but not `TYPE (Runtime a)`
11:50:48 <ezzieyguywuf> is parsec pretty much *the* haskell parser, or are there other good alternatives?
11:50:48 <maerwald> frdg: lol, leg me know how it goes
11:51:00 <maerwald> attoparsec
11:51:05 <[exa]> ezzieyguywuf: megaparsec (better) and attoparsec (faster)
11:51:10 <monochrom> "recursively call main" is ambiguous in whether you mean "main = xxx >> main" or "main = xxx >> main >> main".
11:51:33 <superstar64> are there any parsers combinators that work with `ListT IO Char`?
11:51:44 <monochrom> and whether there is a base case to end it all.
11:52:04 <superstar64> like, what if i need side effects to generate the string
11:52:10 <ezzieyguywuf> [exa]: megaparser is "better" in what sense? i.e. if I was going to take the time to learn one of these, should I bother at all with parsec?
11:52:41 <[exa]> ezzieyguywuf: it is usually faster than standard parsec, has better error messages, extra functionality, less historic cruft, etc.
11:52:44 <monochrom> ezzieyguywuf: parsec comes with GHC. That's a plus.
11:52:50 <Cheery> superstar64: have you thought consequences of that?
11:52:53 <ezzieyguywuf> monochrom: that is def a plus
11:53:02 <ezzieyguywuf> megaparsec seems to have very sensible dependencies though
11:53:04 <superstar64> my macro system?
11:53:28 <ezzieyguywuf> the only two I don't recognize are "case-insentitive" (seems reasonable) and "scientific" (that one has me scratching my head)
11:53:38 <[exa]> ezzieyguywuf: but the general concept of monadic parsing is compatible in all 3 of them; if you learn one you'll be able to start using any other with only very minor effort
11:53:42 <superstar64> or are you talking about a parser combinator that works on ListT
11:53:45 <Cheery> ListT IO Char, do you know how to "open" that up.. that is the corresponding IO monad?
11:53:52 <ezzieyguywuf> oh snap, scientific is cool
11:53:55 <Cheery> well. the corresponding monad.
11:54:06 <superstar64> well, of it should be more general then IO
11:54:06 <ezzieyguywuf> [exa]: thanks for the input!
11:54:24 <superstar64> `data Parser m a = ... ListT m Char`
11:54:28 <superstar64> or something like that
11:54:33 <[exa]> ezzieyguywuf: also, megaparsec has the tutorial collection :]
11:54:48 <monochrom> scientific means use physicists' "scientific notation" e.g. 1.23e5 and take it so seriously you represent floating point in exactly that way.
11:55:05 <monochrom> So, floating point but use base ten.
11:55:09 <[exa]> superstar64: that sounds a bit like ReadS, generally not very efficient
11:55:25 <superstar64> ofc, i'm talking about this ListT https://hackage.haskell.org/package/list-transformer-1.0.6/docs/List-Transformer.html
11:55:31 * ezzieyguywuf wonders if that helps with floating point division errors
11:55:57 <superstar64> i'm not too worried about performance, i just want correctness and composability
11:56:06 <superstar64> if i want performance, i use c++
11:56:17 <monochrom> What's good is it? 0.1 = 1e-1 is exact. What's wrong with it? Knuth proved that rounding error increases with larger bases.
11:56:37 <[exa]> superstar64: if you want correctness, you don't want to put IO into a monad that tries to pretend backtracking :]
11:57:27 <superstar64> i'm not really a fan of backtracking in parsers
11:58:14 <[exa]> superstar64: perhaps check out ReadP
11:58:50 <Logio> monochrom: I'd assume significant figures are preserved
11:58:58 <Logio> haven't checked the package though
11:59:03 <Cheery> though you can stratify it like ReadP (IO ParseResult)
11:59:14 <Cale> monochrom: One thing that kind of scares me still is how unsafe it is to do arithmetic of any kind with untrusted Scientific values, even if something just converts them carelessly with realToFrac, they can fill your memory.
11:59:27 <Cheery> so that the parsing selects the IO, but it only happens after the parse is complete.
11:59:31 <superstar64> how does ReadP do error reporting?
11:59:38 <Cale> (... and yet aeson represents all its numbers with that type)
11:59:50 <electricityZZZZ> is there a meaningful way of characterizing "all possible" binary operations?
11:59:56 <superstar64> and return multiple interpretations isn't that useful for me, which one is the one i want
12:00:09 <Cale> It's theoretically following the JSON spec very exactly, but it's following it more exactly than any other implementation I'm aware of.
12:00:09 <electricityZZZZ> or do binary operations only emerge heuristically from real-world usage
12:00:23 <monochrom> Oh oops, scientific has unlimited mantissa.
12:00:31 <Cale> yes
12:00:45 <monochrom> Yeah consider sin(pi/4)
12:00:57 <Cale> and the exponent is an arbitrary Int value
12:01:11 <Cale> So, it can get pretty ridiculous
12:01:14 <monochrom> nevermind, it can't do sin or pi.
12:01:18 <Cheery> superstar64: last time I checked it might not do that.
12:01:24 <monochrom> But 1/3 is enough to cause troubles :)
12:01:39 <Cale> 1e1000000000000000000
12:01:48 <monochrom> haha
12:02:44 <monochrom> Oh, 1/3 is a run-time error
12:02:50 <dsal> ezzieyguywuf: you'll get past that. :)
12:03:14 <superstar64> where can i learn about arrow based parsers?
12:03:18 * hackage array-list 0.2.0.0 - IsList instances of Array for OverloadedLists extension  https://hackage.haskell.org/package/array-list-0.2.0.0 (epoberezkin)
12:03:37 <Cheery> electricityZZZZ: do you mean for (,) <$> [x,y,z] <*> [x,y,z] ?
12:03:55 <monochrom> Ah, 1e1000000000000 + 1 is the one that takes space. Here be a new kind of scientific machine epsilon! NKSME
12:04:09 <Cheery> > (,) <$> [x,y,z] <*> [x,y,z]
12:04:11 <lambdabot>  [(x,x),(x,y),(x,z),(y,x),(y,y),(y,z),(z,x),(z,y),(z,z)]
12:05:50 <dsal> ezzieyguywuf: I use both mega and attoparsec in different contexts.  The main differences are atto does try by default and mega includes a lot of things it doesn't need to, but are convenient.
12:06:04 <superstar64> like, i need a parser that i can give it an uncons function `f a -> m (Maybe (a, f a))` rather than a list
12:06:42 <dsal> Megaparsec has built-in tools for recursive grammars, though
12:08:49 <monochrom> superstar64: parsec already does that. You write your own Stream instance.
12:12:02 <superstar64> monochrom, i'm not sure i can do it with parsec, i need the `m` in that uncons i show to match the `m` in the parser combinator
12:12:45 <superstar64> does every parser combinator depend on lazy IO?
12:13:08 <monochrom> You can do that with parsec. The m and the m match.
12:13:54 <superstar64> oh, ok i'll try it then
12:14:29 <ania123> hi all
12:14:58 <ania123> does someone knows what caused failure of Ariane 5?
12:15:11 <koz_> ania123: I believe numeric coercion or something?
12:15:13 <c_wraith> yes, someone does.
12:15:18 <ania123> u?
12:15:22 <koz_> Like, someone tried to stuff a float into a 16-bit int or something?
12:15:43 <monochrom> Ariane 5 ought to be off-topic.
12:15:52 <hc> dminuoso: ah, thanks for the explanation of yahb vs lambdabot
12:15:56 <monochrom> There was no Haskell code on it.
12:16:02 <ania123> sorry, it is off topic 
12:16:21 <monochrom> An exemption could be made if you're making a case of resenting not putting Haskell code on it.
12:16:22 <ania123> in which language it was implemented ?
12:17:00 <ania123> if it were implemented in haskell, would same problem occur? 
12:19:20 <hseg> hrm. how do i convince ghc to leave a tyvar parametric? have a type T of kind Nat -> *, with a term t of type forall n. T n. but if I try to construct t in a local binding, ghc sees it as monomorphized
12:19:39 <hseg> and so forbids me from passing it to a function expecting a term of type forall n. T n
12:21:03 <monochrom> a polymorphic type sig would override MonoLocalBind, no?
12:21:11 <hseg> should
12:21:19 <hseg> i might be misunderstanding what i did
12:22:04 <hseg> ghc is complaining "Can't match type T n0 with forall (n :: Nat) . T n"
12:22:20 <hseg> this happens even when i inline the binding
12:23:28 <ania123> if it were implemented in haskell, would same problem occur? 
12:24:02 <Cheery> it depends.
12:24:26 <electricityZZZZ> Cheery: i mean any binary operator, potentially including what is mathematically possible
12:24:47 <ania123> in prolog, you do not need to assign variable value 
12:24:56 <superstar64> what are the main differences between parsec and megaparsec?
12:25:27 <monochrom> I think megaparsec's doc or hackage front page answers that.
12:26:12 <electricityZZZZ> Cheery: we can partially characterize binary operators by describing them as commutative etc
12:27:04 <hseg> ok, seems ghc thinks the tyvar in my term is ambiguous. but i want it to be parametric
12:27:14 <electricityZZZZ> but perhaps it is "rarely the case" that outside of some collection binary operations are from a small collection of functions, etc
12:28:51 <lally> Hi, I've got an type mismatch error, when the top-level decl for the function has a type variable 'u' in a decl like forall u. Lens' (ParsedQuantity u) Int, but then the body has errors related to Couldn't match type 'ParsedQuantity u4' with 'ParsedQuantity u1'.  How do I make them all the same 'u' ?
12:29:06 <hseg> previous working version had reification of the nat happening before invocation of the term, so probably that resolved the ambiguity
12:29:42 <hseg> *reflection
12:30:08 <hseg> *scratch that, reification was correct to begin with
12:30:44 <hseg> but i wanted to put the reification elsewhere, so ghc complains i'm using a term with an ambiguous tyvar where a parametric tyvar is expected
12:31:56 <hseg> ah. found problem: tyvar is *relevant* - replicate @n 'a' :: forall n -> Vector n Char, not forall n. Vector n Char
12:31:59 <hseg> dammit
12:32:09 <hseg> when're we getting dependent types in haskell, again?
12:32:37 <hseg> and how do i hack around their absence here
12:32:39 <hseg> ?
12:33:17 <monochrom> I can only answer the second. Don't use dependent typing techniques in Haskell.
12:34:01 <Uniaika> ^ what he said
12:34:32 <hseg> (-_-)
12:34:36 <monochrom> My overarching principle is: play to the strength, not the weakness, of the language. (If it doesn't have the strength you desire, switch to another language.)
12:34:49 <monochrom> For example I don't use dependent typing techniques in Haskell.
12:34:55 <d34df00d> Or work on bringing those strengths to the language!
12:35:07 <monochrom> For exampl I don't use mutable state algorithms in Haskell.
12:35:20 <monochrom> For example I don't use immutable data algorithms in C.
12:35:48 <Uniaika> (isn't ST the embodiment of mutable algorithms implementation in Haskell?)
12:35:57 <hseg> yeah... unfortunately I don't know agda/idris and there is no transpiler to them
12:36:03 <monochrom> Yes but much slower than C.
12:36:45 <monochrom> Err refinement: individual STRef is much slower than C. vector's unboxed mutable arrays are OK.
12:37:08 <hseg> so dislike second-class features - they lure you into believing you can use them at full force, then break once you're neck-deep in them
12:37:08 <monochrom> I did write random shuffling with the latter.
12:37:27 <Uniaika> monochrom: TIL, thanks
12:37:58 <hseg> hrm. maybe refactoring the dependent code to require passing a Proxy?
12:42:33 <monochrom> Here is my approximation of how much dependent typing technique you can use in Haskell with best ROI.
12:43:25 <monochrom> Iff your kind is simply a promoted ADT.
12:44:12 <monochrom> err not just that. Iff your kind has only a small number of types.
12:46:12 <monochrom> Once you have infinitely many possibilities (e.g., type-level numbers, type-level lists), you now have to write elaborate algorithms for them at the type level. That goes out of hand very quickly.
12:46:58 <monochrom> In particular don't underestimate how much work it is to even handcode multiplication yourself. You never noticed because you have always used a built-in at the term level.
12:47:41 <monochrom> I once handcoded bignum division in x86 asm. That's only at the term level and I already swear would never do again. So nevermind type-level.
12:48:11 <hseg> right. i'm mostly using it with finite types as tags, but i also want linear functions of type-level nats
12:48:41 <hseg> got pretty far with ghc-typelits-knownnat and -natnormalize
12:49:23 <hseg> but my problem code here isn't even manipulating my type-level nats, just reflecting term to type level
12:49:59 <hseg> and that feels like it should be only touching rankntypes stuff
12:50:27 <monochrom> May I tell you the story of the Ship of Theseus? >:)
12:50:56 <hseg> except that somewhere in the middle i have a typeapplication, which is probably downgrading my tyvar from parametric to ambiguous
12:51:04 <hseg> what does theseus have to do with it?
12:52:52 <monochrom> Nevermind, I can't make it funny.
12:53:17 <svipal> Hahaha now I 'm even more curious
12:58:12 <dsal> Haskell -> Haskels -> Haskeus -> Hasseus -> Haeseus -> Hheseus -> Theseus
12:58:29 <koz_> dsal: I wonder what the Levenstein distance between 'Haskell' and 'Theseus' is?
12:59:47 <monochrom> dsal wins :)
13:01:05 <EvanR> idris has a division helper type but it cheats
13:01:16 <monochrom> I was thinking that changing Haskell to dependent typing is such an overhaul that you can't call the result Haskell any more.
13:01:49 <monochrom> But I am not entirely sure, so don't worry.
13:02:19 <EvanR> the last version of the dependent haskell paper i read it sounded like the point was to add dependent types while still being haskell
13:02:31 <EvanR> but everything is a grand experiment
13:03:10 <EvanR> even with rampant cheating dependent types might be valuable
13:03:40 <EvanR> DT on the interface and the implementation cheats
13:03:44 <MarcelineVQ> as long as people keep them out of their api's then everyone wins
13:03:49 <MarcelineVQ> But what are the odds of that..
13:04:08 <EvanR> that's the opposite of what i was thinking
13:04:08 <hseg> what's the point of DT if you can't have it in your api?
13:04:14 <MarcelineVQ> ohno
13:04:45 <rookiehaskeller> any know a better haskell koans than this one? https://github.com/HaskVan/HaskellKoans
13:04:49 <EvanR> the implementation could cheat and users of an API with oddball needs could also cheat
13:05:00 <EvanR> but the API is solid
13:05:37 <MarcelineVQ> by api I mean the public api of your library
13:06:03 <MarcelineVQ> This is not a place that linear types and dependent types should be hanging out. This is called leaking your guts.
13:06:16 <MarcelineVQ> Leaky guts smell and get everywhere and are hard to clean up.
13:06:16 <EvanR> HMMMMM
13:06:43 <EvanR> having dependent types in an API automatically amounts to leaking implementation?
13:07:03 <EvanR> what about the real definition of a monoid
13:07:51 <svipal> Don't know how many times I've gone ahead and downloaded manually a library because it didn't leak enough guts
13:08:04 <svipal> but definitely a lot
13:14:34 <hseg> goddamn ghci and its defaulting hiding errors
13:15:08 <hseg> just wrote a fragment trying to check whether the relevant dependent quantification was at fault
13:15:13 <hseg> ghci happily accepts it
13:15:18 * hackage dobutokO4 0.6.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.6.0.0 (OleksandrZhabenko)
13:15:33 <hseg> but ghc complains of an ambiguous/parametric mismatch
13:15:34 <Cheery> Socks inside
13:15:53 <cjay> MarcelineVQ: "leaky gut" doesn't mean what you think it means https://en.wikipedia.org/wiki/Intestinal_permeability#Leaky_gut_syndrome
13:16:05 <monochrom> yikes
13:16:50 <MarcelineVQ> well I'm thinking more 'treat a sword wound' than take some slippery elm
13:20:17 <svipal> h a s k  e l l 
13:24:42 <hseg> ok, now i'm thoroughly confused. with 'vector-sized' and 'finite-typelits', why is generate getFinite ill-typed?
13:26:28 <hseg> or more accurately, why do both ghc and ghci complain about it when in my production code it doesn't cause any trouble?
13:26:45 <koz_> hseg: What's the error?
13:27:06 <hseg> ttp://ix.io/2q0f
13:27:12 <hseg> ... hhttp://ix.io/2q0f
13:27:19 <hseg> *facepalm*
13:27:21 <hseg> http://ix.io/2q0f
13:27:51 <hseg> sorry, got frustrated and pasted wrong error
13:28:51 <ja> i don't understand, how can it work in production when it isn't compiling with ghc?
13:29:04 <koz_> hseg: Yeah, that is a bit weird. 
13:29:08 <hseg> from a clean slate: http://ix.io/2q0g
13:29:21 <hseg> yeah, my thoughts exactly
13:29:53 <koz_> I guess you get the same issue in GHCi if you give it a type sig?
13:30:05 <koz_> (wait, that's your other paste lol)
13:30:13 <hseg> working code is http://ix.io/2q0h
13:30:32 <hseg> or at least GHC hasn't complained about it yet
13:32:15 <koz_> I suspect there's extra context there it can use - the complaint is basically 'lol, I dunno what n is for getFinite'.
13:33:49 <hseg> wait a sec...
13:34:47 <hseg> no, AAT doesn't seem to help
13:36:33 <koz_> AAT wouldn't in this case.
13:36:47 <hseg> hrm. playing around, am getting different errors
13:36:49 <koz_> It merely allows you to write functions that need call site disambiguation. It doesn't help with said disambiguation.
13:40:56 <hseg> current playground: http://ix.io/2q0n
13:41:33 <hseg> besides the ambiguity complaint, it complains test's n tyvar would escape
13:41:37 <hseg> though i fail to see how
13:43:51 <ezzieyguywuf> yeesh, monad transformers are really cool
13:43:55 <ezzieyguywuf> but hard to wrap my brain around, lol
13:46:03 <Cheery> stack of monads
13:46:22 <Cheery> Maybe (IO (List ...))
13:46:34 <Cale> I actually strongly recommend *not* introducing the idea of a stack into your head when thinking about them :)
13:46:56 <Cheery> is there more to it?
13:46:59 <Cale> If it's important to think about a stack of monad transformers at some point, then something is going wrong
13:47:56 <Cale> Well, it can be fine when you're implementing a few basic operations for the monad you've constructed, and you need to work out how many times to lift to get hold of the things that the transformers give you
13:48:03 <Cheery> then why do you need to know their order when, lets say.. if you want to runMaybeT on it.
13:48:17 <Cheery> or you don't?
13:48:24 <Cale> Well, I mean that it shouldn't be necessary to think about more than one at a time :)
13:48:25 <solonarv> you do need to know the order then
13:48:30 <solonarv> but most of the time you don't
13:48:46 <Cale> When you're implementing your run function and your primitives, you need to know how you implemented your monad to do that
13:49:00 <Cale> But that implementation detail shouldn't escape into your whole program
13:49:01 <Cheery> also Maybe (IO x) is very different to IO (Maybe x)
13:49:19 <Cale> MaybeT IO a is more similar to the latter
13:49:37 <Cale> The former can't easily be made into a monad
13:50:03 <Cheery> said it wrong, but I get what you mean.
13:50:36 <Cale> The order in which you apply monad transformers to get the monad that you're interested in does matter
13:50:44 <hseg> http://ix.io/2q0q help understanding errors?
13:50:54 <Cale> But it's similar to how the order in which you apply functions to a value mattering to get the value you're after
13:51:19 <Cale> You don't usually think of f (g (h x)) as a "value stack" or "function stack"
13:52:06 <Cale> and once you go ahead and do that, you get some result, and the rest of the program shouldn't care how you computed the result
13:52:17 <Cale> the same ought to be true of monad transformers
13:53:30 <Cale> Most often, you'll write functions which are polymorphic in some choice of monad m, and whose class constraint will say what properties m must have in order for the definition to make sense
13:53:57 <Cale> (MonadDB m, MonadSign m) => ... -> m Foo
13:54:50 <Cale> If you don't find that you need that polymorphism, then at least you should have a newtype wrapper around your monad's implementation, so that it's not obvious that transformers are in use
13:55:29 <Cale> ... -> SigningTransaction Foo
13:55:48 <Cale> This lets you change the implementation later without incurring a lot of pain
13:56:42 <Cale> The basic operations of the type classes you define, or basic primitives of the newtyped monad you create will tend to use stuff like lift, and will have to know about the monad transformers
13:56:46 <Cale> The rest of the code shouldn't.
13:58:37 <Cale> I also think that it's usually best to avoid letting mtl's typeclasses spread very far throughout your code. Inventing your own classes gives you an opportunity to come up with more descriptive names than get/put/ask and also an opportunity to do things like restricting how state may be manipulated
13:58:53 <Cale> and it makes your types say more
13:59:18 <hseg> http://ix.io/2q0q why is ghc complaining skolem vars are escaping?
14:00:00 <Cale> Move the $ one back
14:40:14 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
14:40:14 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
14:40:14 --- names: list (clog chou_saar_monk_y JesseL fendor_ carlomagno1 zebrag aarvar erisco Benett livvy m2k otto_s_ crobbins tomku jonathan1 tscholak pera chaosmasttter gioyik leothrix conal energizer kmein o1lo01ol1o cosimone kupi cyphase kleisli shutdown_-h_now efm abracada` Thra11 justanotheruser Neo-- atopuzov[m] Sgeo sagax shock- mossplix wavemode svipal xff0x Gurkenglas nek0 falafel_ bennofs_ boxscape acidjnk_new acarrico evanjs nuncanada Jesin Waldkauz howdoi tom__ zincy__)
14:40:14 --- names: list (sigmundv_ SeMas RoyC m0rphism nineonine cole-h ddellacosta johnw albethere denisse tzh Deide artem tomsen quinn cur8or polyphem ystael chalkmonster Kaivo phaul dme2 styledash gehmehgeh arahael1 metadave dale Kaeipi wroathe whiteline devurandom doyougnu xerox_ gawen noexcept cr3 machinedgod motherfsck nbloomf gekh jumper149 whatisRT urodna dddddd Lord_of_Life perrier-jouet gentauro LKoen Natch Ariakenom solonarv narendraj9 wagle jdt mimi_vx connrs_ zmt00)
14:40:14 --- names: list (dustinm- electrostat Alleria_ azuline {abby} Khisanth carldd Lowl3v3l thc202 mac10688 smatting_ merijn petersen __monty__ jkhaak[m] niso Tuplanolla jjhoo dhouthoo systemfault abuss _ht jusss revprez_stg danvet heredoc vk3wtf_ martin02 andi- rappet m4lvin lep-delete ViCi liff m1cl_ Unhammer Orbstheorem day whataday zaquest theDon lagothrix markus1189 drbean justache codygman hendi hyiltiz tsrt^ annadane justsomeguy xelxebar andreas303 ArtemZ alx741 notzmv dwt)
14:40:14 --- names: list (dysfigured hpc russruss eyenx eyenx|m jb55 reppertj MindlessDrone CitizenSnips acowley Digit thunderrd nfd9001 jassob DavidEichmann stefan-__ Guest2322 OnkelTem tanuki brisbin ephemera_ Tesseraction nshepperd aplainzetakind seliopou Codaraxis_ pdxleif jneira Maxdamantus Jonno_FTW jespada xplat nerdypepper abbe benschza phreedom texasmynsted unlink_ albel727 LnL cp- Vq Fubar^ bcmiller urdh ezzieyguywuf sMuNiX atk Ericson2314 marble_visions eagleflo hiroaki_)
14:40:14 --- names: list (dcoutts_ darjeeling_ javran Chobbes poljar msgctl Cale oak_ mikeqin kptech gienah Profpatsch drewr mozzarella kraem aenesidemus ericsagnes waskell_ pfurla verement revprez_1nzio Dykam jchia_ sm[m] clynamen stepnem aidecoe averell glguy avn afreakk1 leah2 younder rzmt Chi1thangoo kipras`away mupf ChaiTRex nostrodamy Rudd0 thestr4ng3r sw1nn sqrt2 tromp dexterlb jojotastic777[m] tomboy64 parsnip bitonic higherorder ullbeking jonrh drbrule pepeiborra wildsebastian)
14:40:14 --- names: list (alexknvl moobar edwardk liszt betawaffle darthThorik koankeeper angerman runeks amatecha__ ibloom ProofTechnique peel jlpeters caasih jbetz dolio kaychaks_riot d34df00d kadoban amiri MarcelineVQ L1Cafe voyons_osti ashbreeze Guest60204 ixian monochrom elcaro puffnfresh tabemann c6ristian dopplergange @ChanServ ethercrow[m] joshua[m]2 whu[m] michael[m]3 jlorand[m] Derrick[m] darkunicorn[m] mikr[m] potatope[m] dyniec[m] kaushikc unsupervised[m] Noughtmare[m])
14:40:14 --- names: list (jojoz[m] aviD gcoakes[m] dumuzid[m] grizwako[m] hyiltiz[m]1 io_r_us[m] makos[m] solomon[m]1 utdemir[m] zerstroyer[m] jluttine[m] hsiktas[m] redviking[m] domenkozar[m] jthvai roberth tet[m] freeman42x[m] quiet_laika[m] denbrahe[m] supersven[m] srid Elorm[m] fossegrim[m] camlriot42 michaelpj alexfmpe siraben bolti[m] lnxw37d4 sepp2k schum maralorn Poscat[m] execat[m] fgaz vaibhavsagar rednaZ[m] drozdziak1 thejonny unclechu itai33[m] reed[m] boistordu)
14:40:14 --- names: list (Fernando-Basso[m iinuwa e raid PyroLagus Squarism haasn megaTherion cantstanya flux opqdonut sepples mstruebing t36s lthms rom1504 c-rog dan64 Firedancer Tritlo rann klntsky datajerk puffnfresh11 Nistur sim590 Franciman raoulb proteusguy srnty PragCypher chpatrick dogui jcarpenter2 Foritus dmwit Katarushisu Guest17618 is_null uwap dhananjay kjak jakalx sivs Guest84735 dave_uy2 @Sigyn magbo efertone zyeri tinwood spion dxld koz_ dmj` nil zot DocKlobi adius)
14:40:14 --- names: list (PoliticsII__ sethetter nick_h mpickering Argorok_ sgraf hamishmack benl23 terrorjack gluegadget dsturnbull simony heyj affinespaces lexi-lambda loli ajmcmiddlin Taneb aristid recon_-_ mp___ Ekho srhb kqr noecho tdammers rodgzilla samebchase Madars Nikotiini jackdk luite dminuoso kini Hijiri gilbertw1_ Flonk_ shachaf kaol sshine_ towel Ornedan_ andromed1-galaxy tumdedum tasuki_ bcoppens_ exarkun_ dixie kosmikus cjh`_ juri_ ornxka_ coddinkn_ ichimaru_ xlei jmsx)
14:40:14 --- names: list (p3n_ Reiser9 m-renaud oats samebchase- codedmart_ starlord davl saidinwot1 Paks lyxia fre obfusk gareth__ joehh1 bwe amx Nilgeist RusAlex magicman gabiruh mort docontherocks mccoyc1 mud lpsmith SegFaultAX cstrahan Nascha graingert rizary ^[_ Kamuela kip carter cbarrett nh2 Shun131 coot jesyspa ryzokuken alunduil eacameron tazjin NemesisD_ pasukon parisienne___ laxask conjunctive teehemkay entel mudri Adeon PatrickRobotham_ koala_man thi integral scav)
14:40:14 --- names: list (lightandlight sz0 PotatoGim newhoggy chessai billstclair gaze__ buggymcbugfix mankyKitty edmundnoble tnks bgavran rodlogic_ elvishjerricco idnar glittershark hyperfekt srk Arguggi Cathy tms_ Firedancer_ frobnicator obiwahn Drezil atomi fr33domlover _janne EvanR loc Aleksejs sayak voidcontext davean rotaerk ski anishathalye xarian quintasan connrs xyggos dani- parseval kyagrd__ drewolson kozowu pacak polux2001 armin Moyst klardotsh troydm infty AWizzArd)
14:40:14 --- names: list (fliife850 totte SrPx dsal Cir0X natim87 ocharles jetpack_joe ahf Cerise JSharp pent Randy topos dftxbs3e runde feepo stylewarning bjs johs RoguePointer vancz abrar Kneiva arkeet hiredman jorj tomjaguarpaw riatre teqwve i7c PigDude xnyhps miklcct Majiir rawles T0pH4t echoreply jackhill immae xcin mcfilib isacl___ taktoa[c] rdivyanshu_ spoonm Cheery ReinH operand_ agander_m nshepperd1 twk- solarus pong a3f fiadliel totbwf cocreature Bigcheese farn_ liquorice)
14:40:14 --- names: list (bradparker lukelau enemeth79 jared-w interruptinuse _flow_ dequbed ryjm q3k sud0 Batoeh cohn bendo oeblink nlofaro mursu dumptruckman oldsk00l hongminhee cjay joehillen SolarAquarion mingc ByronJohnson ManiacTwister nikola2 yushyin Forkk silver_needles nurupo ggVGc magog typetetris debugloop bspar tolt nisstyre Ferdirand theorbtwo lnx so nshepperd2 SupaYoshi iomonad bobey fionnan drewbarbs_ lambdabot kloeri valdyn fiQ2 chindy zfnmxt digia jonge kAworu orcus)
14:40:14 --- names: list (daGrevis kav robotmay feuerbach arw_ tomsmeding lassulus Techcable esph qz fredcy- NinjaTrappeur zgrep coeus d0liver lally davetapley dgpratt vimto1 Eliel reyu djanatyn deni mantovani Geekingfrog Unode happycoder mr_yogurt oleks hrnz pie_ ashnur anderson nyaomi aweinstock Logio pierrot ps-auxw infinity0 a3Dman_ Someguy123 solrize samiamsam Ankhers electrocat w1gz piele TMA Zemyla johnstein ring0` cpape ent jrm matthew- strangeglyph Philonous byorgey stiell)
14:40:14 --- names: list (hwabyong_ Benzi-Junior amf rotty vin-ivar TimWolla seveg idupree DigitalKiwi Zialus_PT wz1000 copypasteque carbolymer WzC_ PlasmaStar gambpang earthy dh Tene Entroacceptor SquidDev newsham apoc NGravity dragestil d3lxa aurieeeh helpplz ammar2 gothos Clint joeytwiddle forell [df] turq otulp c_wraith MasseR vqrs hive-mind mniip fissureman milessabin glowcoil badzergling rslima____ laghee__ Hotbees bonz060 Rembane meck devalot rawr hvr ab9rf LambdaDuck divVerent)
14:40:14 --- names: list (jhuizy tristanC noan suzu_ ego drdo ij thonkpod dredozubov sphalerite suppi J_Arcane duckonomy Bergle_2 dexterfoo PHO chrpape atle_ spamlessj lortabac irclogger_com myme deu tabaqui joeyh vodkaInferno hexo Adluc bjobjo Jon beaky komasa milli sveit agrif relrod PtxDK sis7 Blkt cheers kkd amosbird zzz noCheese sclv bgamari crtschin_ sarahzrf banjiewen aib joshmeredith cinayakoshka alanz_ cvlad- Boarders FMJz___ adamse HiRE enikar mystfox Klumben iphy zabracks)
14:40:14 --- names: list (verlet64_ raoul peutri anoe Heffalump e2 wspthr rednaZ2 eldritch noctux Athas dennisb atraii int-e mawk yahb vnz fryguybob net4all xwvvvvwx lockshaw Bunogi Delectatio Inoperable nckx ekleog Uniaika thebnq j_klee asm89 mikolaj_ sea-gull lowryder luigy comboy sujeet absence Putonlalla Raito_Bezarius gsingh93 swater Guest20621 ap5 Chousuke quaestor rembo10 seanparsons add^_ niklasb_ epta sigmundv- pta2002_ Jello_Raptor barrucadu malthe_ freeside ptrcmd bind)
14:40:14 --- names: list (hackage Igloo nitrix locallycompact cgfbee wrunt thaumavorio mrus m1dnight_ landonf DTZUZU jonatan cross pyrho mjrosenb Eduard_Munteanu jtcs thecoffemaker jokester gregberns_ sm sdrodge shadowdaemon SomeB `slikts stux|RC-only ivegotasthma nemesit|znc grol nekomune canta vjoki phaazon hexagoxel simplegauss mjuad xacktm ghuntley hodapp bananagram milkii catern rdivacky hc saurik flebron incertia rprosper- jameekim2 micro_ dilinger AndreasK benwr_ ebutleriv)
14:40:14 --- names: list (kristjansson nonzen Arjan alexelcu jchia1 floatingman orion cods APic esotericalgo balbirs lieven dyl_ Tspoon edwtjo supki gargawel dcoutts heath cynick Patternmaster lemald jvanbure ynyounuo bobbytables ridcully Deewiant_ robogoat fiddlerwoaroof jkarni stree ycheng auri_ greymalkin exferenceBot Twey runawayfive davve ft incognito9999 mikolaj Sparadox ambiso mceier uberj rkrishnan phadej ben xe4 steell_ lucianp_ tessier zymurgy ja edigiacomo tureba esg)
14:40:14 --- names: list (reactormonk CindyLinz Uma inimino geal mmaruseacph2 mutantmell ArsenArsen mgaare_ bbear chirpsalot jzl Wamanuz2 joko niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist dibblego Cthalupa tv xintron dmiles zariuq grazfather nopf Niamkik pounce andjjj23 statusfailed bollu wowi42 ahri Bish beka dqd cyberlard mulderr_ haveo madnight_ bandali jfredett bob_twinkles aldum DustyDingo maerwald glamas arianvp)
14:40:14 --- names: list (statusbot pharaun_ acro thallada jsb Guest6919 Iroha haskell_enthusia stilgart DwarfMaster bsima stvc shapr blackdog M2tias tstat fluxit tensorpudding michalrus adamCS)
14:40:16 <dolio> You didn't tell it to default to rationals.
14:40:42 <monochrom> :)
14:41:02 <ja> > [0.1 :: Rational, 0.2 .. 0.9]
14:41:04 <monochrom> use Scientific :)
14:41:04 <lambdabot>  [1 % 10,1 % 5,3 % 10,2 % 5,1 % 2,3 % 5,7 % 10,4 % 5,9 % 10]
14:42:17 <dolio> Doubles also aren't 'incorrect'.
14:42:32 <olligobber> > [0.1 :: Double, 0.2 .. 0.9 ]
14:42:34 <lambdabot>  [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7000000000000001,0.8,0.9]
14:42:43 <ja> they are merely inintuitive and undesired in most non-scientific cases ;)
14:44:13 <ja> i wonder if there is a language where the decimal separator is a function so that in fits with the decimal notation as we know it
14:45:31 <dolio> How does that fit?
14:46:00 <monochrom> You will have problem with 45 . 001 vs 45 . 1
14:46:23 <ja> monochrom: yeah, that was what i was wondering about, that why i asked
14:46:37 <monochrom> I think no language has done this.
14:46:54 <dolio> The decimal notation I know does not have the dot being a function.
14:47:29 <ja> why not? it simply depends on the amount of digits passed as it's second parameter ;)
14:47:40 <ja> it is dependent ;O
14:48:28 <monochrom> you're mad
15:00:34 <fog> when a computation hangs, pressing Ctrl-C will halt it, returning the message; Interrupted. 
15:00:39 <glittershark> I feel like I seem to remember a smalltalk derivative doing that??
15:00:47 <glittershark> but I could be misremembering
15:00:47 <fog> is there any way to see what it was getting stuck on?
15:01:11 <fog> like, quite common is a recursive case that does not match the basecase ever
15:01:26 <fog> then, it would be good to be able to return which function it was that was looping
15:03:16 <ja> glittershark: interesting, if you remember please tell me. there are a lot of smalltalk derivatives by now :P
15:03:27 <glittershark> haha
15:03:48 <boxscape> fog the wiki lists one option https://wiki.haskell.org/Debugging#Infinite_loops
15:04:01 <fog> thanks
15:07:16 <ja> ooh, another advantage of having a dependent numerical literal system is that you could enforce that literals do not get "rounded" like they do when you write "0.3::Double" and haskell 'fixes' it for you 
15:08:12 <fog> ja: whats that for?
15:08:14 <glittershark> ja: agda has dependent numerical literals
15:08:22 <glittershark> idk anything about how they work
15:08:32 <glittershark> but I do know they're overloadable
15:09:18 <dolio> This is not an advantage.
15:09:31 <ja> hmmm, looks like it assumes naturals instead of digits, so wouldn't work with zeros after the decimal separator
15:09:36 <fog> boxscape: when i do that, :history gives the first part of the computation, in a way which is quite easy to read, listing the function being called
15:10:03 <fog> but then :back produces this line by line, allowing the whole history to be gotten at
15:10:10 <fog> but, :back is much less easy to read
15:10:18 <glittershark> oh yeah no decimal literals :/
15:10:22 <fog> is there a way to set it to be more legible? 
15:10:57 <fog> glittershark: wouldnt you only want fractional literals? 
15:11:01 <boxscape> hmm I'm afraid I don't know
15:11:11 <fog> thanks though
15:11:14 <glittershark> wellll you can do reals in agda
15:11:27 <fog> why though?
15:11:38 <glittershark> that and there *is* a formalism of ieee 754
15:11:41 <glittershark> to prove things about reals
15:12:06 <fog> isnt the point of types that they can be matched
15:12:10 <boxscape> I think technically you can only do computable numbers in agda? I'm never quite sure about that but I think that's the case
15:12:12 <fog> like, your just doing equality
15:12:17 <dolio> You don't prove things about reals with IEEE754.
15:12:18 <fog> which reals are no good for
15:12:27 <glittershark> dolio: those were two different statements, haha
15:12:36 <dolio> Oh, I see.
15:12:48 <glittershark> I see the confusion though
15:12:51 <ja> dolio: why is it an advantage to have "0.3::Double" type check?
15:12:52 <Tuplanolla> Tell us about the ehh-psilon.
15:12:53 <dolio> The threads got interleaved.
15:12:55 <fog> as in "why use type level reals? for type level proofs involving reals" 
15:13:08 <glittershark> yes ^
15:13:09 <fog> but thats not really the issue
15:13:27 <fog> you use reals in computations, not proofs.
15:13:29 <glittershark> oh my point was not so much type-level reals as it was just reals in general
15:13:36 <dolio> ja: Because the fact that it rounds doesn't matter. Making someone type the actual value it rounds to doesn't ensure any useful property in a real scenario.
15:13:45 <glittershark> type-level and term-level are sorta the same thing in agda
15:13:45 <fog> the only "proof" would be somthing returning a bool like <
15:13:45 <boxscape> fog you can prove things *about* reals
15:13:59 <fog> yeah, like they are < something
15:14:08 <glittershark> I mean I can prove the ring laws
15:14:10 <fog> but thats not how we use typechecking
15:14:11 <glittershark> that's a relevant proof
15:14:22 <boxscape> though = is uncomputable in general for the set of computable numbers, interestingly
15:14:27 <glittershark> you're not taking quantification into account
15:14:32 <boxscape> undecidable, rather
15:14:34 <fog> at type level, nats are used to say eg. these lists are the same length
15:14:43 <fog> ie, you match on the type
15:14:49 <glittershark> sometimes you want division though
15:14:56 <fog> i guess you could say, the list is less than this long...
15:15:10 <fog> yeah, but if you want division, use fractional
15:15:19 <fog> then it allows for the equality matching to work
15:15:21 <glittershark> sometimes you want a square root :)
15:15:27 <fog> at type level!?
15:15:34 <glittershark> sure why not
15:15:41 <glittershark> what is a type level
15:15:50 <fog> its a big leap from, matching the length of lists, to suddenly doing floating point arithmetic 
15:15:55 <monochrom> Sometimes you want to prove again the fundamental theorem of algebra and you want to do it in Adga. That's one scenerio. It's fringe, I think no one has thought of it, but may as well.
15:16:06 <glittershark> well I've thought of it
15:16:12 <monochrom> err, Agda. I keep misremembering it.
15:16:47 <fog> i think it would be better to reassess why fractionals were needed, and then really see if things like sin anre actually required
15:16:59 <glittershark> what if your types go in a circle, huh?
15:17:05 <fog> lol
15:17:33 <monochrom> But check out https://hackage.haskell.org/package/cyclotomic for most numbers you thought you needed the full real numbers for.
15:17:36 <glittershark> ok but like
15:17:40 <fog> i mean, isnt that more of a stretch than wanting fractionals?
15:17:50 <glittershark> imagine a fourier transform that proves bijectivity
15:17:58 <glittershark> that's totally useful in the real world
15:18:15 <fog> yes monochrom!
15:18:18 <fog> epic
15:18:24 <glittershark> that's a really cool lib
15:18:42 <glittershark> I'm not necessarily saying that you *always* want reals, just that it's better to have them available *just in case*
15:18:57 <fog> ok, thats what we need at type level
15:19:31 <fog> ah, but, would the value level thing from the singletons version be as fast as using Doubles?
15:20:28 <fog> glittershark: i just thought, if they werent available, and fractionals would be easier to provide, and better by being exact, that they would be preferable
15:20:39 <glittershark> most of the time
15:21:00 <fog> when wouldnt the exact computation be better?
15:21:12 <monochrom> when I run out of time
15:21:14 <glittershark> when you care more about performance than precision
15:21:15 <fog> at value level we only have concern about exactness for performance reasons
15:21:21 <glittershark> machine learning etc etc
15:21:24 <fog> at type level!?
15:21:28 <monochrom> when I don't have perfection OCD
15:21:34 <glittershark> oh lol
15:21:36 <glittershark> not at type level
15:21:41 <fog> exactly
15:21:44 <glittershark> I mean I also care about compile time
15:21:53 <fog> thats not the point
15:22:05 <fog> type level computations are for entierly different applications
15:22:05 <monochrom> type-level just means moving my wait to compile-time, yeah
15:22:18 <monochrom> There is an xkcd for that
15:22:20 <fog> not really, its about calculating types
15:22:35 <fog> which is fundamentally different from computing values
15:22:53 * MarcelineVQ presses x to doubt
15:22:58 <fog> its only confusing when these numeric types are considered and people start trying to do machine learning at type level
15:23:17 <fog> that not how i want my types to be derived 
15:23:38 <monochrom> People did not start trying to do machine learning at type level.
15:23:48 <ja> but people are using tactics, they are also wobbly
15:23:58 <fog> like, we have made do until now with no doubles at type level, doent that kind of support the idea that type level computations are totally different
15:24:08 <fog> we would have basically nothing to do at value level without numbers
15:24:40 <monochrom> I don't like this discussion. May I go off a tangent?
15:24:54 <L29Ah> how do i run some action every second? Control.Concurrent doesn't seem to have this
15:25:01 <monochrom> Here are a pair of fun facts in stark contrast and gets you thinking.
15:25:13 <ja> i am sure there is some scientific application where you'd like to precompute some tables with doubles. what is the real distinction between staged programming and type level programming?
15:25:18 * hackage aeson-with 0.1.0.0 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.0.0 (locallycompact)
15:25:21 <fog> L29Ah: you can use threadDelay from control.concurrent
15:26:02 <monochrom> A. 1st-order peano number theory is undecidable.  B. 1st-order real number theory is decidable.
15:26:05 <fog> and you can use sequence to run a list of computations, and from Data.List intersperse, to put the pauses inbetween
15:26:08 <L29Ah> fog: no, that would result in periods longer than a second on average
15:26:17 <fog> how?
15:26:36 <L29Ah> > There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified.
15:26:37 <L29Ah> that's how
15:26:38 <lambdabot>  <hint>:1:94: error: parse error on input ‘,’
15:26:49 <fog> oh, because of the compute time of the things between the pauses, well, then you can do forkIO so it returns almost immidiately
15:27:05 <L29Ah> what
15:27:19 <L29Ah> not only because of that
15:27:33 <fog> intersperse with delays after having map'd forkIO
15:27:46 <monochrom> ja: I think staged programming are more like macros. Do you accept it as a real distinction?
15:28:05 <fog> you mean about the threadDelay getting mismatched with real time even ever so slightly?
15:28:26 <fog> i guess you could do a calculation every so often to see how mad the mismatch was, and adjust the delays
15:28:37 <fog> like a dj
15:28:38 <monochrom> L29Ah: I coded my own loop of "sleep; do". In its own thread, of course.
15:29:00 <ja> monochrom: nah, because you could see the compiler as a macro with impressive error reporting
15:29:13 <L29Ah> fog: yes, it's always longer
15:29:21 <ja> or the other way around. transpiler potahto
15:29:27 <fog> well, its difficult then
15:29:32 <L29Ah> fog: yea that would solve the problem, but i hoped it's already solved as regular timers is not that rare of a task
15:29:36 <fog> you would kind of have to check the machine clock
15:29:41 <monochrom> My application did not need much precision, it's OK to drift, so I left it at that.
15:30:03 <monochrom> I can't see the compiler as a macro!
15:30:17 <fog> i guess sometimes you want a "clock" emiter of signals thats actually really precise 
15:30:30 <fog> like, for synchronising server function networks 
15:30:56 <monochrom> maybe there is no real distinction, only psychological. I'm not ready for this though.
15:31:00 <ja> ghc is a macro running in the language of linux syscalls ;)
15:31:08 <monochrom> (give me more time!)
15:31:28 <fog> L29Ah, i never heard of "regular timers", i wonder if we have them in haskell. but probably not directly from Control.Concurrent
15:32:10 <monochrom> L29Ah: Maybe somthing under System.Posix that does Unix-style alarm will help you.
15:32:24 <fog> monochrom: sometimes an application, like a webpage thats updated frequently, would want to be fetched from as ealy as possible after the update
15:32:55 <fog> if it updated the available data every second, your application should fetch without drift
15:34:06 <fog> and, if server function networks were distributed over several machines, they should use different local clocks, that were synchronised despite not being global
15:34:47 <slack1256> I got a `Connection` from the `sqlite-simple` package. If I get an async exception in the middle of an `execute`, will the `Connection` be valid for other queries after?
15:35:19 <fog> the level of mismatch should be at least no larger than the amount of time for the servers to communicate with each other over the network - so it doesnt need to be totally exact, but within a small tolerance 
15:35:28 <d34df00d> monochrom: hey, so I've been playing with callstacks a bit more, and there's something I don't understand.
15:35:51 <d34df00d> The docs say, in particular, > If there is no CallStack in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a HasCallStack constraint for the enclosing definition (subject to the monomorphism restriction).
15:36:03 <slack1256> I have different pipelines that use the same connection and sometimes I will kill them when some event happens. I want to know if I can keep using it.
15:36:13 <d34df00d> The way I read it is that if I do `foo = error "yay"` without any explicit type signatures, then `foo`'ll have `HasCallStack` constraint, yet it doesn't happing.
15:36:18 <d34df00d> happen that is.
15:36:21 <d34df00d> What am I doing wrong?
15:37:05 <monochrom> Hrm! I think I didn't see that paragraph. Is it in the GHC user's guide? Which GHC version? (I was reading 8.6.3)
15:37:25 <d34df00d> https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Stack.html — base 4.12 is 8.8, right?
15:38:37 <monochrom> OK, have you checked that you're using GHC 8.8 too? :)
15:38:53 <d34df00d> Yea just restarted my repl to see `GHCi, version 8.8.3: https://www.haskell.org/ghc/  :? for help`
15:39:09 <monochrom> However! I think "subject to the monomorphism restriction" may be what you're hitting.
15:39:47 <d34df00d> That was my next question.
15:39:54 <monochrom> If you define "var = ..." (as opposed to "f pattern = ...") you may be eligible for the monomorphism restriction.
15:39:56 <d34df00d> But the result doesn't change whether I add the corresponding language pragma or not.
15:40:06 <L29Ah> yup, seems like the POSIX timers is the way to go; there are other, purely haskell timers, but they are either completely other things or don't care about the aforementioned problems as well
15:40:16 <d34df00d> Also, the type of `foo` is `a` — so it doesn't get monomorphized?
15:40:36 <L29Ah> too bad they would require me to mess with POSIX signals
15:42:04 <L29Ah> https://hackage.haskell.org/package/quarantimer :D
15:42:33 <d34df00d> I thought that last link is about measuring 20 seconds for the hands washing routine.
15:42:37 <d34df00d> I was close enough.
15:42:50 <monochrom> Wait, it is not 15 seconds?!
15:43:41 <maerwald> 30
15:45:42 <MarcelineVQ> use a properly thorough technique instead of a timer and you can do it as fast or as slow as you like.
15:47:16 <ja> dissolve your hands in acid and you will never have to wash them again
15:47:51 <d34df00d> monochrom: oh, you're in grave danger then!
15:49:51 <maerwald> Finally, my clinical OCD is good for something after all
15:50:58 <fog> L29Ah: why would posix alarms be better than the haskell machine clock functions?
15:51:39 <fog> or was your question, how to make such alarms in haskell?
15:51:48 <L29Ah> fog: they won't, they're just more convenient to use, and the caveats are more likely to be taken care of compared to my half-assed implementation
15:52:13 <monochrom> d34df00d: I think GHC.Stack doc disagrees with GHC user's guide on this. In the GHC user's guide, there is no 2, and 3 covers all of not-1. This is true of 8.6, 8.8, and 8.10.  I think for now the story in GHC user's guide is closer to reality.
15:52:56 <d34df00d> monochrom: yeah, I was reading through the guide (once you mentioned it — never thought about looking there before), and I came to a similar conclusion.
15:53:03 <d34df00d> Docs problems.
15:53:27 <fog> wait, why are these Posix signals the right way to go?
15:53:58 <fog> there are many protocols for communicating "signals" right? 
15:54:19 <fog> isnt there even one that allows programs to use the same mutable variables!?
15:54:40 <fog> i thought everything was supposed to be done with ports
15:55:00 <fog> and that any way, like thread handlers, was somehow worse
15:55:22 <fog> "using stding piped from stdout"
15:55:28 <monochrom> I have written like "h xs = map f xs", without type sig. (f has HasCallStack.) Many different ways of testing show that h does not have HasCallStack. Syntactically h is not eligible for the monomorphism restriction, so it is not a factor.
15:55:45 <MarcelineVQ> I would expect other timers to have the same issue, that your wait number is the minimum wait, not the maximum or average.
15:56:41 <monochrom> Posix signals are the wrong way to go. We all already know that.
15:56:46 <d34df00d> I still don't understand the purpose of said restriction even after a few years of haskell.
15:56:53 <fog> idk what they are really, i imagined it was just a way to OS was emiting pulses that could be read in an IO environment, that would be blocking - nd that the point was that the OS people would make them better
15:56:59 <d34df00d> But I always write top-level signatures anwyay.
15:57:06 <monochrom> The problem is it is available here and now.
15:57:50 <monochrom> It's out of a dilemma between type surprise and performance surprise.
15:57:52 <fog> what about a kind of "shared global environment" monad
15:57:56 <MarcelineVQ> d34df00d: specialization during compilation. actually that's touched on in the recent lexi lambda talk
15:58:37 <d34df00d> monochrom: arguably that's a bug if it leads to performance surprise.
15:58:58 <monochrom> Suppose I define "x = 4", except that it's not 4, it's a huge time-consuming formula that evaluates to 4 after an hour. Sorry I am too lazy to cook up an example, but perhaps imagine ackermann(3,3) or something!
15:59:00 <d34df00d> My gut feel is that monomorphisation happens only based on the information withing a single module.
15:59:08 <d34df00d> But then isn't it super cheap for the optimizer to spec it anyway?
15:59:24 <d34df00d> within a single module, that is.
15:59:30 <monochrom> Suppose x is monomorphic, then "print x >> print x" will spend only 1 hour
15:59:34 <fog> like, if i wanted to implement something like this systemwide clock, eg so that the lib exports a function; waitUntilNextSecond :: IO () that is blocking
15:59:39 <d34df00d> Ah.
15:59:55 <d34df00d> Dictionary passing breaks that stuff.
15:59:56 <d34df00d> Right.
15:59:57 <MarcelineVQ> https://www.youtube.com/watch?v=0jI-AlWEwYI this vid I mean, it's not specifically about DMR but it's pretty informative overall
16:00:07 <L29Ah> 01:53:36]<fog> there are many protocols for communicating "signals" right? 
16:00:08 <L29Ah> posix timers use posix signals
16:00:14 <fog> and the way it did this was to somehow have another program emiting signals into the "global environemt" 
16:00:15 <d34df00d> I should probably watch these videos.
16:00:17 <monochrom> Suppose x is polymorphic, then "print x >> print x" will spend 2 hours because polymorphism and/or dictionary passing disuades caching, persuades re-computing.
16:00:51 <fog> L29Ah: yeah, i mean, that these might not be the good signals
16:01:14 <L29Ah> i don't see why would they be bad for my purpose
16:01:15 <monochrom> And of course, the downside of the monomorphic choice is type surprise, "why can't I x::Integer and x::Rational?!"
16:01:22 <d34df00d> monochrom: dunno, what kind of bad stuff would happen if caching was enabled after the optimizer figured it's able to specialize a definition?
16:01:43 <fog> or, maybe they are, and i should have all my programs synchronising message passing, not with ports, or system thread handles, but with these posix threads instead, idk
16:01:52 <d34df00d> I understand that now there might be a space leak or something, but it's super easy to deal with (adding a dummy parameter).
16:01:58 <d34df00d> Doing the reverse is harder.
16:02:31 <monochrom> Optimizer may be able to do it. I think back in the days of adopting the monomorphism restriction, they weren't sure that it could be counted on.
16:02:47 <fog> anyone have a reason to prefer posix threads over or under any other inter-program coms?
16:02:57 <fog> for arguments sake, that are all on the same machine
16:03:55 <fog> that would seem like a good version of the "global enviroment" i was after. you could just kind of send the clock signal into posix land and all the other programs would recieve it
16:04:37 <monochrom> In C programs I prefer posix threads over select/poll loops. In Haskell programs I prefer haskell threads to posix threads.
16:04:52 <fog> saves having to have specific addresses for recipients 
16:04:53 <monochrom> My overarching principle again: play to the strength of the language
16:05:25 <fog> is there a haskell threads thing for this type of "global" coms?
16:06:45 <fog> like, if i didnt want to have to subscribe to the port of the emiter. such as if any of a number of emiters was to broadcast first - so i just want to listen at some kind of universal port for everything thats broadcast into it
16:07:01 <monochrom> Any of the MChan and TChan can be used in broadcast mode.
16:07:25 <fog> between programs?
16:07:25 <monochrom> between haskell threads
16:07:29 <fog> idk if thats a no or not
16:07:55 <L29Ah> fog: i wasn't talking about posix threads
16:07:58 <fog> are haskell threads just within one running program
16:08:15 <L29Ah> but anyway, i have solved my problems with posix timers, thanks
16:08:18 <fog> sorry, posix signals
16:08:22 <monochrom> OK I don't understand your question.
16:09:08 <fog> so, if i have several programs running, like, with different dice rollers, and i want the first dice rollers id when they roll a 6
16:09:32 <fog> so they all broadcast when they do so
16:09:36 <monochrom> There are sockets and pipes and semaphores and even shared memory.
16:10:03 <fog> in order that every other dice roller recieves the signal, i could use sockets to broadcast between them
16:10:13 <fog> or, since it is a global "broadcast"
16:10:37 <fog> they could all just listen to, and emit to, a central "broadcast tower"
16:10:50 <fog> i could write that using any server thing using sockets, sure
16:11:16 <monochrom> Has anyone thought of sending morse code over unix signal so as to send a really long message?
16:11:18 <fog> i just thought that these posix things could somehow replace such "global coms" mechanisms 
16:11:29 <monochrom> I ought to make it an assignment for my unix course!
16:11:56 <fog> im kind of thinking as the posix OS as the ground, and the signals being earthed to it
16:12:33 <fog> is that "shared memory" ?
16:12:43 <fog> i guess not, as nothing is stored
16:12:57 <fog> its more like a global port specific to a machine
16:13:08 <L29Ah> monochrom: i think you don't have a luxury of telling one and many quickly successive signals apart
16:13:46 <monochrom> the receiver has to be superfast to miss nothing, yeah.
16:14:05 <monochrom> Has anyone thought of sending morse code over an error-correcting code over unix signal so as to send a really long message?  >:)
16:14:22 <fog> each of them could have the same series of dices of  progressive size, and they would all move on to the next after one had been "solved" by one of the members
16:14:55 <fog> monochrom: what like sparse parity checking?
16:15:05 <fog> LDPC or whatever its called...
16:15:49 <fog> i think there are some things to do with quantizing and signal compression. but thats a different thing
16:16:58 <fog> i used to think tubocoders were ways of compressing lambda programs! 
16:18:41 <fog> damn runtime errors.... back to it
17:07:06 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
17:07:06 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
17:07:06 --- names: list (clog carlomagno lassulus machinedgod nan` Axman6 quazimodo wroathe codygman Lord_of_Life niklasb_ hackage xsperry metadave falafel_ vicfred justanotheruser kleisli imtravis L29Ah HarveyPwca otto_s hexfive m1cl alp NieDzejkob conal olligobber JesseL zebrag aarvar erisco Benett livvy markh tomku jonathan1 tscholak pera gioyik leothrix energizer kmein kupi cyphase shutdown_-h_now Thra11 Neo-- atopuzov[m] Sgeo sagax shock- wavemode xff0x Gurkenglas nek0 bennofs_)
17:07:06 --- names: list (boxscape acarrico evanjs nuncanada Jesin Waldkauz howdoi tom__ zincy__ sigmundv_ SeMas RoyC m0rphism nineonine cole-h ddellacosta johnw albethere denisse tzh Deide artem quinn polyphem ystael chalkmonster Kaivo phaul dme2 styledash gehmehgeh arahael1 dale Kaeipi whiteline devurandom gawen noexcept cr3 motherfsck gekh urodna dddddd perrier-jouet gentauro LKoen Natch solonarv narendraj9 wagle jdt mimi_vx connrs_ zmt00 dustinm- electrostat Alleria_ blissful {abby})
17:07:06 --- names: list (Khisanth carldd Lowl3v3l thc202 mac10688 smatting_ petersen jkhaak[m] niso Tuplanolla jjhoo systemfault abuss jusss revprez_stg heredoc vk3wtf_ martin02 andi- rappet m4lvin lep-delete ViCi liff Unhammer Orbstheorem day whataday zaquest theDon lagothrix markus1189 drbean justache hendi hyiltiz tsrt^ annadane justsomeguy xelxebar andreas303 ArtemZ alx741 notzmv dwt dysfigured hpc russruss eyenx eyenx|m jb55 reppertj MindlessDrone CitizenSnips acowley Digit)
17:07:06 --- names: list (thunderrd nfd9001 jassob DavidEichmann stefan-__ Guest2322 OnkelTem tanuki brisbin ephemera_ Tesseraction nshepperd aplainzetakind seliopou Codaraxis_ pdxleif Maxdamantus Jonno_FTW jespada xplat nerdypepper abbe benschza phreedom texasmynsted unlink_ albel727 LnL cp- Vq Fubar^ bcmiller urdh ezzieyguywuf sMuNiX atk Ericson2314 marble_visions eagleflo hiroaki_ dcoutts_ darjeeling_ javran Chobbes poljar msgctl Cale oak_ mikeqin kptech gienah Profpatsch drewr)
17:07:06 --- names: list (mozzarella kraem aenesidemus ericsagnes waskell_ pfurla verement revprez_1nzio Dykam jchia_ sm[m] clynamen stepnem aidecoe averell glguy avn afreakk1 leah2 younder rzmt Chi1thangoo kipras`away mupf ChaiTRex nostrodamy Rudd0 thestr4ng3r sw1nn sqrt2 dexterlb jojotastic777[m] parsnip bitonic higherorder ullbeking jonrh drbrule pepeiborra wildsebastian alexknvl moobar edwardk liszt betawaffle darthThorik koankeeper angerman runeks amatecha__ ibloom ProofTechnique)
17:07:06 --- names: list (peel jlpeters caasih jbetz dolio kaychaks_riot d34df00d kadoban amiri MarcelineVQ L1Cafe voyons_osti ashbreeze Guest60204 ixian monochrom elcaro puffnfresh tabemann c6ristian dopplergange @ChanServ ethercrow[m] joshua[m]2 whu[m] michael[m]3 jlorand[m] Derrick[m] darkunicorn[m] mikr[m] potatope[m] dyniec[m] kaushikc unsupervised[m] Noughtmare[m] jojoz[m] aviD gcoakes[m] dumuzid[m] grizwako[m] hyiltiz[m]1 io_r_us[m] makos[m] solomon[m]1 utdemir[m] zerstroyer[m])
17:07:06 --- names: list (jluttine[m] hsiktas[m] redviking[m] domenkozar[m] jthvai roberth tet[m] freeman42x[m] quiet_laika[m] denbrahe[m] supersven[m] srid Elorm[m] fossegrim[m] camlriot42 michaelpj alexfmpe siraben bolti[m] lnxw37d4 sepp2k schum maralorn Poscat[m] execat[m] fgaz vaibhavsagar rednaZ[m] drozdziak1 thejonny unclechu itai33[m] reed[m] boistordu Fernando-Basso[m iinuwa e raid PyroLagus Squarism haasn megaTherion cantstanya flux opqdonut sepples mstruebing t36s lthms rom1504)
17:07:06 --- names: list (c-rog dan64 Firedancer Tritlo rann klntsky datajerk puffnfresh11 Nistur sim590 Franciman raoulb proteusguy srnty PragCypher chpatrick dogui jcarpenter2 Foritus dmwit Katarushisu Guest17618 is_null uwap dhananjay kjak jakalx sivs Guest84735 dave_uy2 @Sigyn magbo efertone tinwood spion dxld koz_ dmj` nil zot DocKlobi adius PoliticsII__ sethetter nick_h mpickering Argorok_ sgraf hamishmack benl23 terrorjack gluegadget dsturnbull simony heyj affinespaces lexi-lambda)
17:07:06 --- names: list (loli ajmcmiddlin Taneb aristid recon_-_ mp___ Ekho srhb kqr noecho tdammers rodgzilla samebchase Madars Nikotiini jackdk luite dminuoso kini Hijiri gilbertw1_ Flonk_ shachaf kaol sshine_ towel Ornedan_ andromed1-galaxy tumdedum tasuki_ bcoppens_ exarkun_ dixie kosmikus cjh`_ juri_ ornxka_ coddinkn_ ichimaru_ xlei jmsx p3n_ Reiser9 m-renaud oats samebchase- codedmart_ starlord davl saidinwot1 Paks lyxia fre obfusk gareth__ joehh1 bwe amx Nilgeist RusAlex magicman)
17:07:06 --- names: list (gabiruh mort docontherocks mccoyc1 mud lpsmith SegFaultAX cstrahan Nascha graingert rizary ^[_ Kamuela kip carter cbarrett nh2 Shun131 coot jesyspa ryzokuken alunduil eacameron tazjin NemesisD_ pasukon parisienne___ laxask conjunctive teehemkay entel mudri Adeon PatrickRobotham_ koala_man thi integral scav lightandlight sz0 PotatoGim newhoggy chessai billstclair gaze__ buggymcbugfix mankyKitty edmundnoble tnks bgavran rodlogic_ elvishjerricco idnar glittershark)
17:07:06 --- names: list (hyperfekt srk Arguggi Cathy tms_ Firedancer_ frobnicator obiwahn Drezil atomi fr33domlover _janne EvanR loc Aleksejs sayak voidcontext davean rotaerk ski anishathalye xarian quintasan connrs xyggos dani- parseval kyagrd__ drewolson kozowu pacak polux2001 armin Moyst klardotsh troydm infty AWizzArd fliife850 totte SrPx dsal Cir0X natim87 ocharles jetpack_joe ahf Cerise JSharp pent Randy topos dftxbs3e runde feepo stylewarning bjs johs RoguePointer vancz abrar)
17:07:06 --- names: list (Kneiva arkeet hiredman jorj tomjaguarpaw riatre teqwve i7c PigDude xnyhps miklcct Majiir rawles T0pH4t echoreply jackhill immae xcin mcfilib isacl___ taktoa[c] rdivyanshu_ spoonm Cheery ReinH operand_ agander_m nshepperd1 twk- solarus pong a3f fiadliel totbwf cocreature Bigcheese farn_ liquorice bradparker lukelau enemeth79 jared-w interruptinuse _flow_ dequbed ryjm q3k sud0 Batoeh cohn bendo oeblink nlofaro mursu dumptruckman oldsk00l hongminhee cjay joehillen)
17:07:06 --- names: list (SolarAquarion mingc ByronJohnson ManiacTwister nikola2 yushyin Forkk silver_needles nurupo ggVGc magog typetetris debugloop bspar tolt nisstyre Ferdirand theorbtwo lnx so nshepperd2 SupaYoshi iomonad bobey fionnan drewbarbs_ lambdabot kloeri valdyn fiQ2 chindy zfnmxt digia jonge kAworu orcus daGrevis kav robotmay feuerbach arw_ tomsmeding Techcable esph qz fredcy- NinjaTrappeur zgrep coeus d0liver lally davetapley dgpratt vimto1 Eliel reyu djanatyn deni)
17:07:06 --- names: list (mantovani Geekingfrog Unode happycoder mr_yogurt oleks hrnz pie_ ashnur anderson nyaomi aweinstock Logio pierrot ps-auxw infinity0 a3Dman_ Someguy123 solrize samiamsam Ankhers electrocat w1gz piele TMA Zemyla johnstein ring0` cpape ent jrm matthew- strangeglyph Philonous byorgey stiell hwabyong_ Benzi-Junior amf rotty vin-ivar TimWolla seveg idupree DigitalKiwi Zialus_PT wz1000 copypasteque carbolymer WzC_ PlasmaStar gambpang earthy dh Tene Entroacceptor)
17:07:06 --- names: list (SquidDev newsham apoc NGravity dragestil d3lxa aurieeeh helpplz ammar2 gothos Clint joeytwiddle forell [df] turq otulp c_wraith MasseR vqrs hive-mind mniip fissureman milessabin glowcoil badzergling rslima____ laghee__ Hotbees bonz060 Rembane meck devalot rawr hvr ab9rf LambdaDuck divVerent jhuizy tristanC noan suzu_ ego drdo ij thonkpod dredozubov sphalerite suppi J_Arcane duckonomy Bergle_2 dexterfoo PHO chrpape atle_ spamlessj lortabac irclogger_com myme deu)
17:07:06 --- names: list (tabaqui joeyh vodkaInferno hexo Adluc bjobjo Jon beaky komasa milli sveit agrif relrod PtxDK sis7 Blkt cheers kkd amosbird zzz noCheese sclv bgamari crtschin_ sarahzrf banjiewen aib joshmeredith cinayakoshka alanz_ cvlad- Boarders FMJz___ adamse HiRE enikar mystfox Klumben iphy zabracks verlet64_ raoul peutri anoe Heffalump e2 wspthr rednaZ2 eldritch noctux Athas dennisb atraii int-e mawk yahb vnz fryguybob net4all xwvvvvwx lockshaw Bunogi Delectatio Inoperable)
17:07:06 --- names: list (nckx ekleog Uniaika thebnq j_klee asm89 mikolaj_ sea-gull lowryder luigy comboy sujeet absence Putonlalla Raito_Bezarius gsingh93 swater Guest20621 ap5 Chousuke quaestor rembo10 seanparsons add^_ epta sigmundv- pta2002_ Jello_Raptor barrucadu malthe_ freeside ptrcmd bind Igloo nitrix locallycompact cgfbee wrunt thaumavorio mrus m1dnight_ landonf DTZUZU jonatan cross pyrho mjrosenb Eduard_Munteanu jtcs thecoffemaker jokester gregberns_ sm sdrodge shadowdaemon)
17:07:06 --- names: list (SomeB `slikts stux|RC-only ivegotasthma nemesit|znc grol nekomune canta vjoki phaazon hexagoxel simplegauss mjuad xacktm ghuntley hodapp bananagram milkii adamCS michalrus tensorpudding fluxit tstat M2tias blackdog shapr stvc bsima DwarfMaster stilgart haskell_enthusia Iroha Guest6919 jsb thallada acro pharaun_ statusbot arianvp glamas maerwald DustyDingo aldum bob_twinkles jfredett bandali madnight_ haveo mulderr_ cyberlard dqd beka Bish ahri wowi42 bollu)
17:07:06 --- names: list (statusfailed andjjj23 pounce Niamkik nopf grazfather zariuq dmiles xintron tv Cthalupa dibblego esotericalgo balbirs lieven dyl_ Tspoon edwtjo supki gargawel dcoutts heath cynick Patternmaster lemald jvanbure ynyounuo bobbytables ridcully Deewiant_ robogoat fiddlerwoaroof jkarni stree ycheng auri_ greymalkin exferenceBot Twey runawayfive davve ft incognito9999 mikolaj Sparadox ambiso mceier uberj rkrishnan phadej ben xe4 steell_ lucianp_ tessier zymurgy ja)
17:07:06 --- names: list (edigiacomo tureba esg reactormonk CindyLinz Uma inimino geal mmaruseacph2 mutantmell ArsenArsen mgaare_ bbear chirpsalot jzl Wamanuz2 joko niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist cods floatingman jchia1 alexelcu Arjan nonzen kristjansson ebutleriv benwr_ AndreasK dilinger micro_ jameekim2 rprosper- incertia flebron saurik hc rdivacky catern)
19:28:23 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
19:28:23 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
19:28:23 --- names: list (clog heatsink theDon lagothrix Digit efm_ oisdk cebola plutoniix cole raid PyroLagus smatting carldd muggermuch xff0x nfd9001 markus1199 nbloomf wroathe Rudd0 codygman st8less falafel__ Lord_of_Life lassulus tomboy64 Welkin hendi_ toorevitimirp xerox_ gvx nineonine zyeri total1ty syswannabe jchia__ carlomagno machinedgod nan` Axman6 quazimodo niklasb_ hackage xsperry vicfred justanotheruser kleisli imtravis L29Ah otto_s hexfive m1cl NieDzejkob conal olligobber)
19:28:23 --- names: list (JesseL zebrag aarvar Benett tomku pera gioyik leothrix energizer kmein kupi cyphase shutdown_-h_now Thra11 Neo-- atopuzov[m] Sgeo sagax shock- wavemode nek0 bennofs_ boxscape acarrico evanjs Jesin Waldkauz howdoi SeMas cole-h ddellacosta johnw albethere denisse tzh artem quinn polyphem ystael chalkmonster Kaivo phaul dme2 styledash gehmehgeh arahael1 dale Kaeipi whiteline devurandom gawen noexcept motherfsck gekh urodna dddddd perrier-jouet gentauro Natch)
19:28:23 --- names: list (narendraj9 wagle jdt mimi_vx connrs_ zmt00 dustinm- electrostat Alleria_ blissful {abby} Khisanth Lowl3v3l mac10688 petersen jkhaak[m] niso jjhoo systemfault abuss jusss revprez_stg heredoc vk3wtf_ martin02 andi- rappet m4lvin lep-delete ViCi liff Unhammer Orbstheorem day whataday zaquest drbean justache hyiltiz tsrt^ annadane justsomeguy xelxebar andreas303 ArtemZ alx741 notzmv dwt dysfigured hpc russruss eyenx eyenx|m jb55 reppertj MindlessDrone CitizenSnips)
19:28:23 --- names: list (acowley thunderrd jassob DavidEichmann stefan-__ Guest2322 OnkelTem tanuki brisbin ephemera_ Tesseraction nshepperd aplainzetakind seliopou Codaraxis_ pdxleif Maxdamantus Jonno_FTW jespada xplat nerdypepper abbe benschza phreedom texasmynsted unlink_ albel727 LnL cp- Vq Fubar^ bcmiller urdh ezzieyguywuf sMuNiX atk Ericson2314 marble_visions eagleflo hiroaki_ dcoutts_ darjeeling_ javran Chobbes poljar msgctl Cale oak_ mikeqin kptech gienah Profpatsch drewr)
19:28:23 --- names: list (mozzarella kraem aenesidemus ericsagnes waskell_ pfurla verement revprez_1nzio Dykam jchia_ sm[m] clynamen stepnem aidecoe averell glguy avn afreakk1 leah2 younder rzmt kipras`away mupf ChaiTRex nostrodamy thestr4ng3r sw1nn sqrt2 dexterlb jojotastic777[m] parsnip bitonic higherorder ullbeking jonrh drbrule pepeiborra wildsebastian alexknvl moobar edwardk liszt betawaffle darthThorik koankeeper angerman runeks amatecha__ ibloom ProofTechnique peel jlpeters caasih)
19:28:23 --- names: list (jbetz dolio kaychaks_riot d34df00d kadoban amiri MarcelineVQ L1Cafe voyons_osti ashbreeze Guest60204 ixian monochrom elcaro puffnfresh tabemann c6ristian dopplergange @ChanServ ethercrow[m] joshua[m]2 whu[m] michael[m]3 jlorand[m] Derrick[m] darkunicorn[m] mikr[m] potatope[m] dyniec[m] kaushikc unsupervised[m] Noughtmare[m] jojoz[m] aviD gcoakes[m] dumuzid[m] grizwako[m] hyiltiz[m]1 io_r_us[m] makos[m] solomon[m]1 utdemir[m] zerstroyer[m] jluttine[m] hsiktas[m])
19:28:23 --- names: list (redviking[m] domenkozar[m] jthvai roberth tet[m] freeman42x[m] quiet_laika[m] denbrahe[m] supersven[m] srid Elorm[m] fossegrim[m] camlriot42 michaelpj alexfmpe siraben bolti[m] lnxw37d4 sepp2k schum maralorn Poscat[m] execat[m] fgaz vaibhavsagar rednaZ[m] drozdziak1 thejonny unclechu itai33[m] reed[m] boistordu Fernando-Basso[m iinuwa e Squarism haasn megaTherion cantstanya flux opqdonut sepples mstruebing t36s lthms rom1504 c-rog dan64 Firedancer Tritlo rann)
19:28:23 --- names: list (klntsky datajerk puffnfresh11 Nistur sim590 Franciman raoulb proteusguy srnty PragCypher chpatrick dogui jcarpenter2 Foritus dmwit Katarushisu Guest17618 is_null uwap dhananjay kjak jakalx sivs Guest84735 dave_uy2 @Sigyn magbo efertone tinwood spion dxld koz_ dmj` nil zot DocKlobi adius PoliticsII__ sethetter nick_h mpickering Argorok_ sgraf hamishmack benl23 terrorjack gluegadget dsturnbull simony heyj affinespaces lexi-lambda loli ajmcmiddlin Taneb aristid)
19:28:23 --- names: list (recon_-_ mp___ Ekho srhb kqr noecho tdammers rodgzilla samebchase Madars Nikotiini jackdk luite dminuoso kini Hijiri gilbertw1_ Flonk_ shachaf kaol sshine_ towel Ornedan_ andromed1-galaxy tumdedum tasuki_ bcoppens_ exarkun_ dixie kosmikus cjh`_ juri_ ornxka_ coddinkn_ ichimaru_ xlei jmsx p3n_ Reiser9 m-renaud oats samebchase- codedmart_ starlord davl saidinwot1 Paks lyxia fre obfusk gareth__ joehh1 bwe amx Nilgeist RusAlex magicman gabiruh mort docontherocks)
19:28:23 --- names: list (mccoyc1 mud lpsmith SegFaultAX cstrahan Nascha graingert rizary ^[_ Kamuela kip carter cbarrett nh2 Shun131 coot jesyspa ryzokuken alunduil eacameron tazjin NemesisD_ pasukon parisienne___ laxask conjunctive teehemkay entel mudri Adeon PatrickRobotham_ koala_man thi integral scav lightandlight sz0 PotatoGim newhoggy chessai billstclair gaze__ buggymcbugfix mankyKitty edmundnoble tnks bgavran rodlogic_ elvishjerricco idnar glittershark hyperfekt srk Arguggi Cathy)
19:28:23 --- names: list (tms_ Firedancer_ frobnicator obiwahn Drezil atomi fr33domlover _janne EvanR loc Aleksejs sayak voidcontext davean rotaerk ski anishathalye xarian quintasan connrs xyggos dani- parseval kyagrd__ drewolson kozowu pacak polux2001 armin Moyst klardotsh troydm infty AWizzArd fliife850 totte SrPx dsal Cir0X natim87 ocharles jetpack_joe ahf Cerise JSharp pent Randy topos dftxbs3e runde feepo stylewarning bjs johs RoguePointer vancz abrar Kneiva arkeet hiredman jorj)
19:28:23 --- names: list (tomjaguarpaw riatre teqwve i7c PigDude xnyhps miklcct Majiir rawles T0pH4t echoreply jackhill immae xcin mcfilib isacl___ taktoa[c] rdivyanshu_ spoonm Cheery ReinH operand_ agander_m nshepperd1 twk- solarus pong a3f fiadliel totbwf cocreature Bigcheese farn_ liquorice bradparker lukelau enemeth79 jared-w interruptinuse _flow_ dequbed ryjm q3k sud0 Batoeh cohn bendo oeblink nlofaro mursu dumptruckman oldsk00l hongminhee cjay joehillen SolarAquarion mingc)
19:28:23 --- names: list (ByronJohnson ManiacTwister nikola2 yushyin Forkk silver_needles nurupo ggVGc magog typetetris debugloop bspar tolt nisstyre Ferdirand theorbtwo lnx so nshepperd2 SupaYoshi iomonad bobey fionnan drewbarbs_ lambdabot kloeri valdyn fiQ2 chindy zfnmxt digia jonge kAworu orcus daGrevis kav robotmay feuerbach arw_ tomsmeding Techcable esph qz fredcy- NinjaTrappeur zgrep coeus d0liver lally davetapley dgpratt vimto1 Eliel reyu djanatyn deni mantovani Geekingfrog Unode)
19:28:23 --- names: list (happycoder mr_yogurt oleks hrnz pie_ ashnur anderson nyaomi aweinstock Logio pierrot ps-auxw infinity0 a3Dman_ Someguy123 solrize samiamsam Ankhers electrocat w1gz piele TMA Zemyla johnstein ring0` cpape ent jrm matthew- strangeglyph Philonous byorgey stiell hwabyong_ Benzi-Junior amf rotty vin-ivar TimWolla seveg idupree DigitalKiwi Zialus_PT wz1000 copypasteque carbolymer WzC_ PlasmaStar gambpang earthy dh Tene Entroacceptor SquidDev newsham apoc NGravity)
19:28:23 --- names: list (dragestil d3lxa aurieeeh helpplz ammar2 gothos Clint joeytwiddle forell [df] turq otulp c_wraith MasseR vqrs hive-mind mniip fissureman milessabin glowcoil badzergling rslima____ laghee__ Hotbees bonz060 Rembane meck devalot rawr hvr ab9rf LambdaDuck divVerent jhuizy tristanC noan suzu_ ego drdo ij thonkpod dredozubov sphalerite suppi J_Arcane duckonomy Bergle_2 dexterfoo PHO chrpape atle_ spamlessj lortabac irclogger_com myme deu tabaqui joeyh vodkaInferno hexo)
19:28:23 --- names: list (Adluc bjobjo Jon beaky komasa milli sveit agrif relrod PtxDK sis7 Blkt cheers kkd amosbird zzz noCheese sclv bgamari crtschin_ sarahzrf banjiewen aib joshmeredith cinayakoshka alanz_ cvlad- Boarders FMJz___ adamse HiRE enikar mystfox Klumben iphy zabracks verlet64_ ekleog Uniaika thebnq j_klee asm89 mikolaj_ sea-gull lowryder luigy comboy sujeet absence Putonlalla Raito_Bezarius gsingh93 swater Guest20621 ap5 Chousuke quaestor rembo10 seanparsons add^_ epta)
19:28:23 --- names: list (sigmundv- pta2002_ Jello_Raptor barrucadu malthe_ freeside ptrcmd bind Igloo nitrix locallycompact cgfbee wrunt thaumavorio mrus m1dnight_ landonf DTZUZU jonatan cross pyrho mjrosenb Eduard_Munteanu jtcs thecoffemaker esotericalgo balbirs lieven dyl_ Tspoon edwtjo supki gargawel dcoutts heath cynick Patternmaster lemald jvanbure ynyounuo bobbytables ridcully Deewiant_ robogoat fiddlerwoaroof jkarni stree ycheng auri_ greymalkin exferenceBot Twey runawayfive)
19:28:23 --- names: list (davve ft incognito9999 mikolaj Sparadox ambiso mceier uberj rkrishnan phadej ben xe4 steell_ lucianp_ tessier zymurgy ja edigiacomo tureba esg reactormonk CindyLinz Uma inimino geal mmaruseacph2 mutantmell ArsenArsen mgaare_ bbear chirpsalot jzl Wamanuz2 joko niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist dibblego Cthalupa tv xintron dmiles zariuq grazfather nopf Niamkik pounce andjjj23 statusfailed)
19:28:23 --- names: list (bollu wowi42 ahri Bish beka dqd cyberlard mulderr_ haveo madnight_ bandali jfredett bob_twinkles aldum DustyDingo maerwald glamas arianvp statusbot pharaun_ acro thallada jsb Guest6919 Iroha haskell_enthusia stilgart DwarfMaster bsima stvc shapr blackdog M2tias tstat fluxit tensorpudding michalrus adamCS cods jchia1 alexelcu Arjan nonzen kristjansson ebutleriv benwr_ AndreasK dilinger micro_ jameekim2 rprosper- incertia flebron saurik hc rdivacky catern milkii)
19:28:23 --- names: list (bananagram hodapp ghuntley xacktm mjuad simplegauss hexagoxel phaazon vjoki canta nekomune grol nemesit|znc ivegotasthma stux|RC-only `slikts SomeB shadowdaemon sdrodge sm gregberns_ jokester nckx Inoperable Delectatio Bunogi lockshaw xwvvvvwx net4all fryguybob vnz yahb mawk int-e atraii dennisb Athas noctux eldritch rednaZ2 wspthr e2 Heffalump anoe peutri raoul)
19:29:46 <Welkin> use a mutable reference then
19:30:01 <Welkin> it's okay to use mutation if it's encapsulated inside of a function
19:30:11 <Welkin> that's what ST is for
19:30:21 <Welkin> IORef is the unsafe way to do mutation
19:30:53 <Welkin> see STArray or MutableVector
19:31:23 <Welkin> then you pass the reference through recursion, simulating a loop
19:31:43 <Welkin> mutation in haskell is ugly though, unfortunately
19:32:32 <cole> Thanks Welkin, I'll see if I can eke by without mutation, but if the runtime sucks i'll look into it 
19:33:48 <cole> in my limited experience with mutation, i'd have to agree
19:42:40 <ezzieyguywuf> what does the `|` represent in `class Monad m => MonadError e m | m -> e where `
19:43:24 <d34df00d> Functional dependency.
19:43:43 <d34df00d> You can read `MonadError e m | m -> e` as "e and m such that m uniquely identifies e".
19:43:50 <ezzieyguywuf> ok thanks!
19:44:10 <d34df00d> I think https://wiki.haskell.org/Functional_dependencies is a pretty good intro.
19:45:40 <ezzieyguywuf> d34df00d: yup, found it after you said "Functional Dependency" :)
19:47:14 <paulasdf> I'm trying to use System.Random.MWC and Statistics.Distribution to generate some random numbers, but I'm getting some error about expecting a Gen (PrimState m0) but getting a Gen (RealWorld), despite me providing a type annotation confirming that I'm passing a Gen (PrimState m0)... Any help? 
19:47:15 <paulasdf> https://pastebin.com/raw/CpQqYum2
19:59:33 <Waldkauz> paulasdf: Where is getContVar from?
20:02:18 <paulasdf> Statistics.Distribution
20:08:03 <Waldkauz> paulasdf: Does "genContVar @ IO" work?
20:08:45 <Waldkauz> I think it's not clever enough to get the m because gen is already given as RealWorld result
20:09:47 <Waldkauz> paulasdf: No wait, you are using it wrong. getContVar returns an IO Double
20:13:37 <Henson> I've got a question about the Pipes library.  The (>->) function connects pipes together, but it requires that their return value "r" in the type (Pipe a b m r) be the same.  Why is this necessary when the final pipe's return value is all that's important?  Is there something else that can connect pipes and doesn't require the return values to be the same?
20:14:14 <paulasdf> Okay, got it working now. TThanks
20:45:07 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
20:45:07 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
20:45:07 --- names: list (clog ryandv glguy zaquest brandly metadave Sgeo wei2912 rabimmel Henson wavemode_ gioyik_ raid PyroLagus jamm_ conal justache paulasdf cebola APic jedws heatsink theDon lagothrix Digit efm_ plutoniix smatting carldd muggermuch xff0x nfd9001 markus1199 nbloomf wroathe Rudd0 codygman st8less Lord_of_Life lassulus tomboy64 hendi_ toorevitimirp xerox_ gvx nineonine zyeri syswannabe jchia__ carlomagno machinedgod nan` Axman6 quazimodo niklasb_ hackage xsperry vicfred)
20:45:07 --- names: list (justanotheruser kleisli imtravis L29Ah otto_s hexfive m1cl NieDzejkob olligobber JesseL zebrag aarvar Benett tomku pera leothrix energizer kmein kupi cyphase shutdown_-h_now Thra11 Neo-- atopuzov[m] sagax shock- nek0 bennofs_ acarrico evanjs Jesin Waldkauz SeMas cole-h johnw albethere denisse tzh artem quinn polyphem ystael chalkmonster Kaivo phaul dme2 styledash gehmehgeh arahael1 dale Kaeipi whiteline devurandom gawen noexcept motherfsck gekh dddddd)
20:45:07 --- names: list (perrier-jouet gentauro Natch narendraj9 wagle jdt mimi_vx connrs_ zmt00 dustinm- electrostat Alleria_ blissful {abby} Khisanth Lowl3v3l mac10688 petersen jkhaak[m] niso jjhoo systemfault abuss revprez_stg heredoc vk3wtf_ martin02 andi- rappet m4lvin lep-delete ViCi liff Unhammer Orbstheorem day whataday drbean hyiltiz tsrt^ annadane justsomeguy xelxebar andreas303 ArtemZ alx741 notzmv dwt dysfigured hpc russruss eyenx eyenx|m jb55 reppertj MindlessDrone)
20:45:07 --- names: list (CitizenSnips acowley thunderrd jassob DavidEichmann stefan-__ Guest2322 OnkelTem tanuki brisbin ephemera_ Tesseraction nshepperd aplainzetakind seliopou Codaraxis_ pdxleif Maxdamantus Jonno_FTW jespada xplat nerdypepper abbe benschza phreedom texasmynsted unlink_ albel727 LnL cp- Vq Fubar^ bcmiller urdh ezzieyguywuf sMuNiX atk Ericson2314 marble_visions eagleflo hiroaki_ dcoutts_ darjeeling_ javran Chobbes poljar msgctl Cale oak_ mikeqin kptech gienah Profpatsch)
20:45:07 --- names: list (drewr mozzarella kraem aenesidemus ericsagnes waskell_ pfurla verement revprez_1nzio Dykam jchia_ sm[m] clynamen stepnem aidecoe averell avn afreakk1 leah2 younder rzmt kipras`away mupf ChaiTRex nostrodamy thestr4ng3r sw1nn sqrt2 dexterlb jojotastic777[m] parsnip bitonic higherorder ullbeking jonrh drbrule pepeiborra wildsebastian alexknvl moobar edwardk liszt betawaffle darthThorik koankeeper angerman runeks amatecha__ ibloom ProofTechnique peel jlpeters caasih)
20:45:07 --- names: list (jbetz dolio kaychaks_riot d34df00d kadoban amiri MarcelineVQ L1Cafe voyons_osti ashbreeze Guest60204 ixian monochrom elcaro puffnfresh tabemann c6ristian dopplergange @ChanServ ethercrow[m] joshua[m]2 whu[m] michael[m]3 jlorand[m] Derrick[m] darkunicorn[m] mikr[m] potatope[m] dyniec[m] kaushikc unsupervised[m] Noughtmare[m] jojoz[m] aviD gcoakes[m] dumuzid[m] grizwako[m] hyiltiz[m]1 io_r_us[m] makos[m] solomon[m]1 utdemir[m] zerstroyer[m] jluttine[m] hsiktas[m])
20:45:07 --- names: list (redviking[m] domenkozar[m] jthvai roberth tet[m] freeman42x[m] quiet_laika[m] denbrahe[m] supersven[m] srid Elorm[m] fossegrim[m] camlriot42 michaelpj alexfmpe siraben bolti[m] lnxw37d4 sepp2k schum maralorn Poscat[m] execat[m] fgaz vaibhavsagar rednaZ[m] drozdziak1 thejonny unclechu itai33[m] reed[m] boistordu Fernando-Basso[m iinuwa e Squarism haasn megaTherion cantstanya flux opqdonut sepples mstruebing t36s lthms rom1504 c-rog dan64 Firedancer Tritlo rann)
20:45:07 --- names: list (klntsky datajerk puffnfresh11 Nistur sim590 Franciman raoulb proteusguy srnty PragCypher chpatrick dogui jcarpenter2 Foritus dmwit Katarushisu Guest17618 is_null uwap dhananjay kjak jakalx sivs Guest84735 dave_uy2 @Sigyn magbo efertone tinwood spion dxld koz_ dmj` nil zot DocKlobi adius PoliticsII__ sethetter nick_h mpickering Argorok_ sgraf hamishmack benl23 terrorjack gluegadget dsturnbull simony heyj affinespaces lexi-lambda loli ajmcmiddlin Taneb aristid)
20:45:07 --- names: list (recon_-_ mp___ Ekho srhb kqr noecho tdammers rodgzilla samebchase Madars Nikotiini jackdk luite dminuoso kini Hijiri gilbertw1_ Flonk_ shachaf kaol sshine_ towel Ornedan_ andromed1-galaxy tumdedum tasuki_ bcoppens_ exarkun_ dixie kosmikus cjh`_ juri_ ornxka_ coddinkn_ ichimaru_ xlei jmsx p3n_ Reiser9 m-renaud oats samebchase- codedmart_ starlord davl saidinwot1 Paks lyxia fre obfusk gareth__ joehh1 bwe amx Nilgeist RusAlex magicman gabiruh mort docontherocks)
20:45:07 --- names: list (mccoyc1 mud lpsmith SegFaultAX cstrahan Nascha graingert rizary ^[_ Kamuela kip carter cbarrett nh2 Shun131 coot jesyspa ryzokuken alunduil eacameron tazjin NemesisD_ pasukon parisienne___ laxask conjunctive teehemkay entel mudri Adeon PatrickRobotham_ koala_man thi integral scav lightandlight sz0 PotatoGim newhoggy chessai billstclair gaze__ buggymcbugfix mankyKitty edmundnoble tnks bgavran rodlogic_ elvishjerricco idnar glittershark hyperfekt srk Arguggi Cathy)
20:45:07 --- names: list (tms_ Firedancer_ frobnicator obiwahn Drezil atomi fr33domlover _janne EvanR loc Aleksejs sayak voidcontext davean rotaerk ski anishathalye xarian quintasan connrs xyggos dani- parseval kyagrd__ drewolson kozowu pacak polux2001 armin Moyst klardotsh troydm infty AWizzArd fliife850 totte SrPx dsal Cir0X natim87 ocharles jetpack_joe ahf Cerise JSharp pent Randy topos dftxbs3e runde feepo stylewarning bjs johs RoguePointer vancz abrar Kneiva arkeet hiredman jorj)
20:45:07 --- names: list (tomjaguarpaw riatre teqwve i7c PigDude xnyhps miklcct Majiir rawles T0pH4t echoreply jackhill immae xcin mcfilib isacl___ taktoa[c] rdivyanshu_ spoonm Cheery ReinH operand_ agander_m nshepperd1 twk- solarus pong a3f fiadliel totbwf cocreature Bigcheese farn_ liquorice bradparker lukelau enemeth79 jared-w interruptinuse _flow_ dequbed ryjm q3k sud0 Batoeh cohn bendo oeblink nlofaro mursu dumptruckman oldsk00l hongminhee cjay joehillen SolarAquarion mingc)
20:45:07 --- names: list (ByronJohnson ManiacTwister nikola2 yushyin Forkk silver_needles nurupo ggVGc magog typetetris debugloop bspar tolt nisstyre Ferdirand theorbtwo lnx so nshepperd2 SupaYoshi iomonad bobey fionnan drewbarbs_ lambdabot kloeri valdyn fiQ2 chindy zfnmxt digia jonge kAworu orcus daGrevis kav robotmay feuerbach arw_ tomsmeding Techcable esph qz fredcy- NinjaTrappeur zgrep coeus d0liver lally davetapley dgpratt vimto1 Eliel reyu djanatyn deni mantovani Geekingfrog Unode)
20:45:07 --- names: list (happycoder mr_yogurt oleks hrnz pie_ ashnur anderson nyaomi aweinstock Logio pierrot ps-auxw infinity0 a3Dman_ Someguy123 solrize samiamsam Ankhers electrocat w1gz piele TMA Zemyla johnstein ring0` cpape ent jrm matthew- strangeglyph Philonous byorgey stiell hwabyong_ Benzi-Junior amf rotty vin-ivar TimWolla seveg idupree DigitalKiwi Zialus_PT wz1000 copypasteque carbolymer WzC_ PlasmaStar gambpang earthy dh Tene Entroacceptor SquidDev newsham apoc NGravity)
20:45:07 --- names: list (dragestil d3lxa aurieeeh helpplz ammar2 gothos Clint joeytwiddle forell [df] turq otulp c_wraith MasseR vqrs hive-mind mniip fissureman milessabin glowcoil badzergling rslima____ laghee__ Hotbees bonz060 Rembane meck devalot rawr hvr ab9rf LambdaDuck divVerent jhuizy tristanC noan suzu_ ego drdo ij thonkpod dredozubov sphalerite suppi J_Arcane duckonomy Bergle_2 dexterfoo PHO chrpape atle_ spamlessj lortabac irclogger_com myme deu tabaqui joeyh vodkaInferno hexo)
20:45:07 --- names: list (Adluc bjobjo Jon beaky komasa milli sveit agrif relrod PtxDK sis7 Blkt cheers kkd amosbird zzz noCheese sclv bgamari crtschin_ sarahzrf banjiewen aib joshmeredith cinayakoshka alanz_ cvlad- Boarders FMJz___ adamse HiRE enikar mystfox Klumben iphy zabracks verlet64_ ekleog Uniaika thebnq j_klee asm89 mikolaj_ sea-gull lowryder luigy comboy sujeet absence Putonlalla Raito_Bezarius gsingh93 swater Guest20621 ap5 Chousuke quaestor rembo10 seanparsons add^_ epta)
20:45:07 --- names: list (sigmundv- pta2002_ Jello_Raptor barrucadu malthe_ freeside ptrcmd bind Igloo nitrix locallycompact cgfbee wrunt thaumavorio mrus m1dnight_ landonf DTZUZU jonatan cross pyrho mjrosenb Eduard_Munteanu jtcs thecoffemaker esotericalgo balbirs lieven dyl_ Tspoon edwtjo supki gargawel dcoutts heath cynick Patternmaster lemald jvanbure ynyounuo bobbytables ridcully Deewiant_ robogoat fiddlerwoaroof jkarni stree ycheng auri_ greymalkin exferenceBot Twey runawayfive)
20:45:07 --- names: list (davve ft incognito9999 mikolaj Sparadox ambiso mceier uberj rkrishnan phadej ben xe4 steell_ lucianp_ tessier zymurgy ja edigiacomo tureba esg reactormonk CindyLinz Uma inimino geal mmaruseacph2 mutantmell ArsenArsen mgaare_ bbear chirpsalot jzl Wamanuz2 joko niko Velpoman infinisil matheus23 jle` jtobin wayne militia duairc wraithm acertain TommyC [exa] sdx23 Tourist dibblego Cthalupa tv xintron dmiles zariuq grazfather nopf Niamkik pounce andjjj23 statusfailed)
20:45:07 --- names: list (bollu wowi42 ahri Bish beka dqd cyberlard mulderr_ haveo madnight_ bandali jfredett bob_twinkles aldum DustyDingo maerwald glamas arianvp statusbot pharaun_ acro thallada jsb Guest6919 Iroha haskell_enthusia stilgart DwarfMaster bsima stvc shapr blackdog M2tias tstat fluxit tensorpudding michalrus adamCS cods jchia1 alexelcu Arjan nonzen kristjansson ebutleriv benwr_ AndreasK dilinger micro_ jameekim2 rprosper- incertia flebron saurik hc rdivacky catern milkii)
20:45:07 --- names: list (bananagram hodapp ghuntley xacktm mjuad simplegauss hexagoxel phaazon vjoki canta nekomune grol nemesit|znc ivegotasthma stux|RC-only `slikts SomeB shadowdaemon sdrodge sm gregberns_ jokester nckx Inoperable Delectatio Bunogi lockshaw xwvvvvwx net4all fryguybob vnz yahb mawk int-e atraii dennisb Athas noctux eldritch rednaZ2 wspthr e2 Heffalump anoe peutri raoul)
20:45:13 <ryandv> is `return` an anamorphism for lists?
20:47:02 <Axman6> Henson: I think it's because you can't guarantee the second pipe will ever execute anything and have a chance to return r - return r >-> someOtherPipe for example should return r
20:47:32 <Axman6> I'm sure there's an explanation somewhere in the docs or a blog post
20:49:48 <Henson> Axman6: ok.  But say I have a chain of pipes and I want to connect them to a consumer.  Say one consumer prints things to stdout and returns (), and another consumer returns the first value it receives (let's say an Int).  It doesn't seem possible to connect these two different kinds of consumers without having a type signature problem.
20:50:33 <Henson> Axman6: but if there was a version of (>->) that didn't require the return values of the two things being connected to be the same, it would be no problem.
20:50:59 <Axman6> maybe try writing that function and see if you run into problems
20:52:25 <Axman6> this feels related to the reasons I never managed to actually write anything using pipes, it's theoretically beautiful but quite painful to do a lot of things that feel like they should be doable
20:53:18 <Henson> Axman6: I have, and I did encounter problems.  I've been working through the 2019 advent of code problems and am trying to chain emulators for the "Intcode" programming language together.  I thought I'd connect the emulators together using Pipes to torture myself through learning, and have one Consumer that prints out the answer, and another that returns the answer from the function.  I can't...
20:53:29 <Henson> Axman6: can't just swap the Consumers at the end due to this problem.
20:54:02 <Axman6> have yoy considered conduit?
20:54:04 <Axman6> you*
20:54:20 <Henson> Axman6: yeah, would Conduit be a better choice?  I see that Conduit is more popular on Hackage than Pipes in terms of downloads, but don't know if Conduit has more downloads because it's bundled as part of Yesod.
20:54:43 <Axman6> I've used it mostly with Amazonka
20:55:15 <Henson> Axman6: bundled as part of -> a requirement of
20:55:44 <Axman6> I don't believe yesod is popular enough to be the primary reason for its downloads.
20:58:29 <Axman6> I've used conduit a lot, and only played with yesod once, I doubt I'm alone (I would have guessed that amazonka is more of a reason for conduit's downloads than yesod)
20:59:23 <Henson> Axman6: so you said you've never managed to write anything using pipes.  Do you find conduit easier to use than pipes?
20:59:48 <Axman6> yes
21:00:16 <Henson> Axman6: ok, I'll give it a try then
21:01:27 <Axman6> IIRC the thing that tripped me up in pipes was not being able to know when there is no further data from upstream - with conduit you just use await :: Conduit a b m (Maybe a) and if you ever get Nothing you know upstream will never send anythign ever again - means you can do things like compute hashes of data
21:04:51 <Henson> Axman6: ok, thanks for helping to tip the scales between conduit and pipes for me :-)
21:24:47 <jchia1> Henson: There's also streaming.
21:27:36 <Henson> jchia1: thanks for pointing that out, I'll take a look at it.
21:30:03 <Axman6> yeah streaming is also a good option, I've used conduit mostly because it integrates well with amazona and we were writing a lot of lambdas to stream data
21:35:06 <Henson> Axman6, jchia1: thank you for your help, I'm going to sleep now!
21:36:50 <jchia1> Axman6: amazonka hasn't been updated on Hackage for eons. How do you deal with that? Do you just use the old Hackage version or get it from github?
21:38:15 <jchia1> I get it from github in my stack projects and find that rather tedious. I'm wondering how others deal with it. Maybe there's a better way.
21:38:46 <Axman6> we'd stayed on an older stack LTS release, but wee could have updated to a newer one which has amazonka included
21:39:23 <jchia1> i c
23:06:40 <Faye>  /msg NickServ VERIFY REGISTER Faye kreqdpmvryur
23:06:44 <Faye> oops!
23:07:22 <MarcelineVQ> best to automate that sort of thing :>
23:29:37 <Axman6> RIP
