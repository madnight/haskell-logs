00:00:32 <suzu_> looking at O2 on/off, it does a lot of optimization
00:00:49 <suzu_> like it doesn't bother saving these registers to the stack or having such a long loop
00:01:00 <suzu_> saving the function arguments *
00:01:46 <suzu_> it doesnt setup a stack frame pointer
00:01:58 <suzu_> looks like all the function arguments stay in registers, which is fast
00:02:55 <suzu_> inside the loop there are a number of instructions done to calculate the target address
00:03:10 <suzu_> the optimization notices they're all intervals of 8 so it just picks a start and walks by 8 bytes every loop
00:04:17 <bifunc2> wow
00:04:29 <suzu_> and the inner loop doesnt do any reading from the stack in the optimized version
00:04:38 <bifunc2> i doubt ghc can come anywhere close if i write similar IO func with Foreign.Ptr
00:05:18 <suzu_> tbh the lazy way of knowing how much faster stuff is, is to just count the instruction difference
00:05:26 <suzu_> it's not perfect but it's good enough
00:05:59 <suzu_> if you can get haskell to compile something tight like this i'd be interested in seeing the asm
00:10:14 <bifunc2> suzu_ presumably here would be the "equivalent" haskell function? https://godbolt.org/z/5tsa4_
00:10:21 <bifunc2> that's LOTS of asm :)
00:14:38 <suzu_> hmm why cant i turn on intel asm syntax here
00:15:41 <suzu_> hmm
00:15:42 <bifunc2> no idea..
00:15:49 <suzu_> i think it's kinda close to the unoptimized output of gcc
00:17:01 <suzu_> hmm no
00:17:08 <suzu_> it does more work than that which i dont understand
00:18:04 <suzu_> sadly i can't try the llvm backend with -fllvm here
00:20:07 <suzu_> or any newer ghc'es
00:20:09 <suzu_> argh
00:20:12 <suzu_> yeah i dunno
00:20:14 <suzu_> lol
00:21:49 <bifunc2> hehe
00:22:16 <suzu_> let me know if you do find a way to get it tighter
00:22:23 <suzu_> without just inlining C :)
00:24:13 <bifunc2> i have no idea where to even start lol
00:24:19 <bifunc2> i wonder if this is even possible
00:24:31 <bifunc2> this is why FFI exists i guess
02:11:43 <jluttine[m]> How could I use setEnv to set such an environment variable that it can consist of arbitrary substrings which I can then loop over in a bash script as `for i in $SOME_ENV_VAR`? that is, how to create an array similar to `$@` with `setEnv`?
02:34:51 <Orbstheorem> Hi, why are the generated record acessors or an associated type not considered implementations of a type class methods?
02:37:51 <Rembane> Orbstheorem: I don't really know what you're asking for, so I'll instead say that's how Lens does it. 
02:42:23 <Orbstheorem> Rembane: consider the following example: https://paste.gnugen.ch/raw/DmQD, ghc complains that there's no explicit implementation for `Main.foo`, even if `foo` is a member of the TBar record.
02:44:08 <Rembane> Orbstheorem: For some reason I can't open that link. 
02:45:43 <Orbstheorem> Oh, sorry: https://paste.gnugen.ch/raw/WXlB
02:46:05 <Orbstheorem> (Don't know what happened with the other link)
02:52:22 <Rembane> Orbstheorem: How would you get foo from Bar? 
02:55:03 <Orbstheorem> `foo :: MyType Bar -> String` (a-conversion of the typeclass) has the same type as `foo :: TBar -> String` (abuse of notation), since TBar is a constructor for `MyType Bar`.
02:58:44 <tomsmeding> jluttine[m]: how would you do that in bash itself?
02:59:23 <tomsmeding> if you just do `for i in $SOMETHING` in bash, then you loop over the words in the value of $SOMETHING, splitted by whitepace (or more accurately, the contents of $IFS)
02:59:55 <tomsmeding> $@ is indeed an actual array, but you can't put an array in the environment of the process; arrays are a bash-only thing (well, and other shells)
03:00:06 <tomsmeding> s/the process/a process/
03:00:08 <Orbstheorem> tomsmeding: You can use a bash array: `foo=(*.hs); for file in ${foo[*]}; do...`
03:00:29 <tomsmeding> yes and my point is that that is a "bash array" for a reason: it's not an environment variable, it's a bash thing
03:00:42 <tomsmeding> so no you cannot do this using setEnv, but then no language can
03:00:50 <Orbstheorem> right ^^
03:02:43 <tomsmeding> apparently if you `export` an array variable in bash, it just ignores the export statement :p
03:03:25 <tomsmeding> Orbstheorem: also, do not forget your quotes, and note the difference between * and @; perhaps you meant "${foo[@]}" ;)
03:03:56 <Orbstheorem> You're corrent ^^
03:04:06 <Orbstheorem> correct* xD
03:17:49 * hackage theatre 1.0.0.1 - Minimalistic actor library  https://hackage.haskell.org/package/theatre-1.0.0.1 (NikitaVolkov)
04:04:39 <freeman42x[m]> is there any way to do something like `type Queue = [ToDo]` but with the change that [ToDo] should not be allowed to be used instead of Queue ?
04:05:03 <koz_> freeman42x[m]: Yes, a newtype.
04:06:59 <freeman42x[m]> koz_: could you provide an example? let's say something equivalent to `type MustUseString = [Char]`. How would you define the newtype?
04:07:14 <koz_> newtype MustUseString = MustUseString [Char]
04:07:25 <koz_> Replace the second 'MustUseString' with anything you like.
04:07:49 <koz_> Now, whenever there's a MustUseString argument, you can't pass a [Char].
04:08:01 <koz_> But representationally, a MustUseString is identical.
04:10:12 <freeman42x[m]> koz_: "Now, whenever there's a MustUseString argument, you can't pass a [Char]." but this is exactly what I was asking for
04:10:33 <freeman42x[m]> so newtype is not a solution
04:10:33 <koz_> So... what is the problem?
04:10:46 <freeman42x[m]> koz_: what is not clear?
04:11:35 <koz_> I believe your original question was 'is there any way to do something like `type Queue = [ToDo]` but with the change that [ToDo] should not be allowed to be used instead of Queue ?'.
04:11:55 <koz_> The newtype solution achieves this, unless I misunderstood your requirements.
04:12:05 <freeman42x[m]> exactly, your answer did not fit that criteria
04:12:11 <koz_> Yes actually it did.
04:12:35 <koz_> If I do 'newtype Queue = Queue [ToDo]', and you have 'f :: Queue -> Int', you can't call f with a [ToDo].
04:12:54 <freeman42x[m]> no, it did not, since when you use type alias you can use a `[Char]` wherever you would need a `String`. While with your solution, you can't. That is why it does not answer my question
04:13:49 <koz_> OK, well, I guess I'm misreading, but the key phrase I read was '... but with the change that [ToDo] should _not_ be allowed to be used instead of Queue...'.
04:13:51 <koz_> Emphasis mine.
04:14:30 <koz_> So now _I'm_ confused what you're asking, because that and what you just said disagree.
04:16:01 <no-n> Hello, I'd like an argument, please.
04:16:43 <juri_> 12.
04:16:51 <koz_> 42.
04:17:29 <freeman42x[m]> if what I said seems to disagree it means that you made a wrong interpretation or that I suck at being clear. What I meant is that you should not be allowed to type it as [Char] instead of String - that should be a compile error
04:17:58 <koz_> freeman42x[m]: Which my solution forces you to do. You _cannot_ use [ToDo] instead of Queue.
04:18:21 <koz_> So by any reasonable definition of the word 'type' and 'compile error', this works.
04:21:20 <freeman42x[m]> koz_: your solution does not work since it does not meet the criteria of my question, first one being, same as `type Queue = [ToDo]`. An answer would be something like: `sametype Queue =  [ToDo]`. Assuming such a keyword existed which allowed type aliasing but still giving compile errors if something typed as [ToDo] where attempted to be used as a Queue
04:21:42 <koz_> freeman42x[m]: OK, then no, no such solution exists.
04:22:17 <koz_> You did not specify that the behaviour had to _also_ be exactly a transparent alias.
04:22:21 <koz_> That's what threw me.
04:22:21 <freeman42x[m]> koz_: I was hoping for some extension or something that would allow something like that to work
04:22:24 <koz_> Nope.
04:22:30 <koz_> And I would argue this is not desirable in the first place.
04:22:33 <no-n> isn't a newtype unwrap free anyway?
04:22:38 <koz_> no-n: Yes.
04:22:39 <freeman42x[m]> yeah, I get it. I need to get better at asking the relevant parts of the question
04:23:14 <koz_> (a newtype and the thing it wraps are representationally equal, to be very precise)
04:23:18 <freeman42x[m]> > And I would argue this is not desirable in the first place.
04:23:18 <freeman42x[m]> Why would this be undesireable but `type` would be?
04:23:20 <lambdabot>  <hint>:1:41: error: parse error on input ‚Äòin‚Äô
04:24:12 <freeman42x[m]> I am asking about this exactly cause I think it is desireable. I think `type` is mainly a mistake, it should have worked the way I described it
04:24:30 <koz_> I don't think type is desirable either.
04:24:37 <koz_> If you're _renaming_ a type, you probably want different semantics.
04:24:39 <freeman42x[m]> ah, I see
04:24:41 <koz_> (or will very soon)
04:24:52 <koz_> And in my opinion, the earlier you newtype the better, because you probably will want to anyway.
04:25:18 <freeman42x[m]> > If you're _renaming_ a type, you probably want different semantics.
04:25:18 <freeman42x[m]> What do you mean?
04:25:20 <lambdabot>  <hint>:1:24: error: parse error on input ‚Äòtype‚Äô
04:25:36 <koz_> That even though the representation is the same, the operations and behaviours of it are not.
04:25:54 <koz_> In the same sense that 'Int' and 'Sum Int' are representationally identical, but behave differently.
04:26:02 <koz_> (as Sum Int has a defined <>, but Int doesn't)
04:26:13 <hpc> or something like FilePath vs HTTPStream
04:26:15 <koz_> (and mempty, I guess)
04:26:22 <hpc> both might be Strings, but both are different from each other and String
04:26:51 <freeman42x[m]> koz_: aren't `String` and `[Char]` having the exact same operations and behavior?
04:27:03 <hpc> when you concat two strings, you just concat them - when you concat two file paths, you put "/" between them, and you don't concat HTTPStreams
04:27:09 <koz_> freeman42x[m]: Yes, and this is _widely_ considered to be an awful mistake.
04:27:13 <koz_> (on multiple levels)
04:27:20 <koz_> And it in no way contradicts anything I have stated so far.
04:27:36 <no-n> why is it considered a mistake?
04:27:49 <hpc> no-n: we're locked into that implementation
04:28:01 <koz_> no-n: Linked list of Ints corresponding to code points is an _awful_ string representation for basically _any_ choice of task.
04:28:05 <hpc> we can never switch to a String that's an encoded ByteString, or something like that
04:28:09 <freeman42x[m]> > That even though the representation is the same, the operations and behaviours of it are not.
04:28:09 <freeman42x[m]> if they are the same why did you say this?
04:28:11 <lambdabot>  <hint>:1:48: error: parse error on input ‚Äò,‚Äô
04:28:29 <no-n> ahh
04:28:32 <koz_> It's horrifically wasteful of space, has atrocious cache behaviour, and is suboptimal for practically any algorithm that works on strings in a conceptual sense.
04:28:47 <koz_> freeman42x[m]: I was referring to your statement regarding what I meant by 'different semantics'.
04:28:52 <koz_> I never claimed this applied to type aliases.
04:29:25 <no-n> because with a newtype you can change the underlying implemenation
04:30:12 <freeman42x[m]> > freeman42x: I was referring to your statement regarding what I meant by 'different semantics'.
04:30:12 <freeman42x[m]> Oh, I understand now. God text communication is horrible. Can we please get structured communication working? this is 2020
04:30:13 <lambdabot>  <hint>:1:95: error:
04:30:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:30:38 <koz_> freeman42x[m]: What do you mean by 'structured communication'?
04:30:51 <koz_> I agree that text is not ideal, but what do you mean by 'structured' in this context?
04:31:23 <koz_> But yeah, no-n - the fact that String is useless is perhaps the biggest gripe about base around.
04:31:27 <koz_> (at least in my experience)
04:31:49 <justsomeguy> freeman42x[m]: I disagree -- God text communication is divine. Hello 2020, this is justsomeguy.
04:31:58 <koz_> Text is much better, although I would argue UTF-16 isn't the best choice of encoding.
04:32:12 <koz_> ByteString is also pretty good for certain cases.
04:32:23 <hpc> koz_: semaphore flags, of course üè≥üè¥üè¥üè≥üè¥üè≥üè≥üè≥üè¥
04:33:44 <freeman42x[m]> > freeman42x: What do you mean by 'structured communication'?
04:33:44 <freeman42x[m]> structured as in structured data, hard to find a definition that is not fishy on the internets. But the main issues with text communication are that it is very slow and easy to misinterpret, that is why I prefer audio / video
04:33:46 <lambdabot>  <hint>:1:60: error:
04:33:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:34:15 <koz_> freeman42x[m]: Audio and video are even slower.
04:34:25 <koz_> I can read _much_ faster than I can listen.
04:34:43 <koz_> So much so that I find learning anything from audio and or video so incalculably slow, that I can't stand to do it at all.
04:35:22 <freeman42x[m]> koz_: you can't read faster than someone can type and can't reply to him faster than you can type. You are bottlenecked by your typing speed and not the read speed. I thought that was obvious
04:35:54 <freeman42x[m]> to read something you first need for the other person to type it -> bottlenech his typing speed, not your read speed
04:36:03 <freeman42x[m]> to reply the bottleneck is your typing speed
04:36:18 <samiamsam> koz_: try something like 'mpv' where you can increase the video/audio speed arbitrary, and you will find that you can play a video faster than you can read
04:36:23 <freeman42x[m]> communication using text is slow and error prone casue of misunderstandings
04:36:35 <samiamsam> koz_: not that i recommend trying to learn like that
04:36:38 <koz_> samiamsam: Play, yes. Actually get meaningful information out of at that speed? No.
04:37:20 <hpc> blind people that use TTS accessibility crank the speech speed up to 4x or more
04:37:22 <freeman42x[m]> if text communication would be structured then there would be much less misunderstandings, and you could improve on typing speed also
04:37:25 <samiamsam> at what speed though?  you choose the speed
04:37:30 <samiamsam> you just said it was too slow
04:37:50 <koz_> samiamsam: Except that I can't crank up audio/video speed to match my reading speed and still have it make any sense.
04:37:55 <koz_> Or get any meaningful information out of it.
04:38:14 <koz_> hpc: And good for them. They're not me.
04:38:16 <samiamsam> but i agree with you that audio/video isn't good, it's just not because it's slow
04:38:31 <koz_> samiamsam: Then you can have whatever opinion on the cause of its badness you like.
04:38:31 <freeman42x[m]> koz_: `Except that I can't crank up audio/video speed to match my reading speed ` just tell the other person to dish some word rapping speed? just tell them to talk faster haha xD
04:38:34 <koz_> I've stated mine.
04:38:48 <koz_> You don't have to agree with it, or even care.
04:38:58 <koz_> (I've also stated the reasons for said)
04:40:04 <freeman42x[m]> well, you said that reading is faster, but that is not why text is slower, text is slower cause of the typing speed
04:40:38 <freeman42x[m]> in general for humans output is the bottleneck, we have huge amounts of input flowing into our mind, but our outputs are very low bandwidth in comparison. Neuralink is working on improving that
04:40:39 <samiamsam> with text you can visually scan back and forth and whatnot, you can skim read, you can search for things, you can glance back at things...  it's not quite random access, but audio/video is much more linear
04:41:24 <veverak> samiamsam: I agree with what koz_ said, it's much mentally exhaustive to extract usefull stuff out of audio than text, given that I need more time to extract information from audio ( no matter the play speed) than e
04:41:26 <veverak> *than text
04:41:29 <veverak> -> audio is slower
04:41:35 <samiamsam> you can linger as necessary with much more control, or skip over things you don't need to hear, etc.  you get more control
04:41:55 <no-n> and you can stare at a sentence you don't understand until you do
04:42:22 <samiamsam> ya
04:42:32 <freeman42x[m]> samiamsam: there is no reason why you could not scan back and forward in audio/video either. And modern audio / video applications also have speech to text so you get better than text and can use the text to scoll back.
04:42:39 <no-n> kinda like staring at haskell types :)
04:42:51 <freeman42x[m]> Anyway, I am not saying that audio/video is better than text in call cases, just for less misunderstandings in general
04:43:12 <samiamsam> freeman42x[m]: no there is reason, what you're saying maybe can be accomplished, but this isn't a use case for which playback software is designed
04:43:33 <no-n> what does speech offer for understanding that text doesn't? there's no punctuation in speech..
04:44:35 <freeman42x[m]> no-n: speech offers less misunderstandings: tone of voice, gesticulations, facial expressions, etc. you get much more context than just the stream of text coming out of someones mouth
05:02:35 <maerwald> freeman42x[m]: that's also more room for interpretation 
05:03:10 <no-n> especially between cultures
05:03:21 <maerwald> yes
05:04:08 <maerwald> and even verbal communication, including tone (eg mandarin)
05:07:42 <maerwald> so it is more misunderstandings (now you don't just have words but a whole new category)
05:08:44 <maerwald> the gap is closed by cultural context, but that one does not translate very well
05:33:19 * hackage registry 0.1.8.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.8.0 (etorreborre)
05:43:44 <freeman42x[m]> > so it is more misunderstandings (now you don't just have words but a whole new category)
05:43:44 <freeman42x[m]> I was arguing for the typical use-case being with less misunderstanding, not for /every/ case
05:43:46 <lambdabot>  error:
05:43:46 <lambdabot>      ‚Ä¢ Variable not in scope: so :: t0 -> t1 -> t2 -> t3 -> t4 -> t
05:43:46 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
05:46:42 <maerwald> freeman42x[m]: if the typical use case is communication in a channel like this... I believe you will get a lot more cross-culture/accent confusion 
05:47:32 <maerwald> if typical use case is talking to your siblings, then yes
05:49:47 <maerwald> I don't understand people verbally in the south of my own country... I wish they would only write letters :)
06:33:20 * stevenxl Hi folks. I am a bit confused by GeneralizedNewtypeDeriving. I have the following code: newtype Username = Username { usernameText :: Text } deriving (Show), and I have {-# LANGUAGE GeneralizedNewtypeDeriving #-}. When I show a username, I get the following: "Username {usernameText = \"Steven\"}". I was expecting to just get "Steven".
06:33:43 * stevenxl Am I using GeneralziedNewtypeDeriving wrong?
06:35:22 <boxscape> stevenxl by default, deriving Show will use the stock deriving strategy, which produces that result. If you want to derive it using generalized newtype deriving, you can enable the DerivingStrategies extension and then write "deriving newtype Show"
06:35:39 <stevenxl> boxscape: Ah - thank you!
06:36:48 <stevenxl> boxscape: This is exactly what I needed. Found documentation for later. 
06:36:49 <stevenxl> https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/deriving_strategies.html
06:36:52 <stevenxl> :-)
06:37:42 <boxscape> yeah the extensions are all pretty well documented :)
06:48:18 * hackage repline 0.4.0.0 - Haskeline wrapper for GHCi-like REPL interfaces.  https://hackage.haskell.org/package/repline-0.4.0.0 (sdiehl)
06:57:44 <wudis> lambdabot: @type dist
06:57:45 <lambdabot> error:
06:57:45 <lambdabot>     ‚Ä¢ Variable not in scope: dist
06:57:45 <lambdabot>     ‚Ä¢ Perhaps you meant data constructor ‚ÄòList‚Äô (imported from Control.Lens)
07:15:53 <jumper149> Is it possible to derive MonadTrans for a monad-transformer that is a newtype on a whole stack of monad-transformers? It works when it's only 1 transformer, but GHC tells me it can't eta-reduce the represantation enough when there are 2 or more transformers in the stack.
07:16:59 <dolio> No, newtype deriving is only for deriving the exact instance of the thing you're wrapping with the newtype.
07:21:42 <Axman6> @src MonadTrans
07:21:42 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
07:21:50 <Axman6> @hoogle MonadTrans
07:21:51 <lambdabot> Control.Monad.Trans.Class class MonadTrans t
07:21:51 <lambdabot> Conduit class MonadTrans (t :: Type -> Type -> Type -> Type)
07:21:51 <lambdabot> Pipes class MonadTrans (t :: Type -> Type -> Type -> Type)
08:02:13 <younder> Math book recommendations again: 'Quantum error correction'  by Lidar and Brun. 'Programming Quantum Computers' by Johnston, Hardigand.. and 'Twist, Tilings and Tessellations' bu Lang
08:02:43 <younder> s/bu/by/
08:16:49 * hackage haskoin-store-data 0.32.3 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.32.3 (jprupp)
08:17:48 * hackage haskoin-store 0.32.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.32.3 (jprupp)
08:22:00 <younder> Did you miss the article in AMS on cylindrical volumes to reduce the ray-tracing problem to a int8 problem
08:23:48 <younder> Time to read up in 'Introduction to lattices and order' by Favey and Priestly
08:24:38 <Axman6> younder: does any of this have to do with haskell?
08:24:44 <younder> By the way I am a applied mathematician not a sales man and I am not making a dime of these recomendation
08:25:30 <younder> At least the latter. But it would have to be the applied bit.
09:01:18 * hackage derive-lifted-instances 0 - Derive class instances though various kinds of lifting  https://hackage.haskell.org/package/derive-lifted-instances-0 (SjoerdVisscher)
09:03:48 * hackage registry 0.1.9.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.9.0 (etorreborre)
09:04:48 * hackage free-functors 1.1 - Free functors, adjoint to functors that forget class constraints.  https://hackage.haskell.org/package/free-functors-1.1 (SjoerdVisscher)
09:30:19 * hackage shell-conduit 5.0.0 - Write shell scripts with Conduit  https://hackage.haskell.org/package/shell-conduit-5.0.0 (psibi)
09:42:11 <m-renaud> Does anyone monitor the haddock github issues? It appears there are several that are 2+ weeks old (including one that I created) that don't have replies (https://github.com/haskell/haddock/issues)
09:42:40 --- mode: monochrom set -bbo *!*@71.19.249.95 muslimm!*@* monochrom
09:56:45 <Guest76374> A bit sad (&) and (>>>) can't mix..
10:03:23 <monochrom> In what sense do they not mix?
10:04:13 <maerwald> foo >>> bar & baz -- ?
10:05:14 <dolio> They have equal fixity but opposite associativity.
10:06:21 <monochrom> Then parentheses will help.
10:10:03 <maerwald> some ppl regard parentheses as junior style code, funnily
10:11:27 <monochrom> the hypocrisy is that they regard lack of curry braces cowboy style code, too
10:12:55 <monochrom> In C for example, if I write "while (cond > 0) cond--;", the pro advice is "put back the curry braces, while (cond > 0) { cond--; }, even if it is syntactically unnecesary, it improves readability".  No one speaks like "how do I get rid of curry braces?"
10:13:19 <monochrom> And then when it comes to "(x + y) * z" suddenly people flip-flop.
10:13:48 <monochrom> Put back the parentheses. It improves readability.
10:15:11 <monochrom> Just another data point showing that programmers are hypocrites.
10:15:41 <hpc> *all programmers are hypocrites except for us :D
10:15:52 <monochrom> I also hate the word "readability".
10:16:15 <monochrom> Your source code file has rwxr-xr-x permissions. It is already readable.
10:16:29 <monochrom> I use "comprehensible" instead.
10:16:59 <monochrom> But of course programmers are uneducated and uncivilized, they can't comprehend "comprehendability".
10:17:26 <monochrom> err "comprehensibility"? I guess I'm uncivilized too. :)
10:19:27 <dolio> What a load of garbage.
10:21:01 <monochrom> Sorry!
10:25:39 <ja> it makes a lot of sense to enforce braces around while loops, in a langauge where indentation means nothing. for the same reason it makes sense to allow trailing commas in lists and arguments for functions (thinking of python)
10:25:58 <ja> but i guess people only really realized this once source control became popular
10:27:03 <ja> it is arguably simpler to *require* trailing commas, but natural language had too much influence
10:27:19 <monochrom> I agree about trailing commas and semicolons, too.
10:27:54 <int-e> i++,;
10:28:05 <monochrom> Also, I support adding the "unnecessary" curry braces, and therefore parentheses.
10:28:30 <monochrom> Did you know: Haskell is already half way there!
10:28:57 <int-e> monochrom: (just (use lisp))?
10:28:59 <monochrom> do { ; xxx ; yyy ; zzz ; } is OK. In fact do { ; ; ; xxx ; ; yyy ; zzz ; ; ; } is also OK.
10:29:14 <maerwald> When I see people in small projects start talking about what they don't like about my style, I usually walk away.
10:29:30 <maerwald> Be glad you have any contributors...
10:29:56 <ja> maerwald: yeah a lot of it is sadly bike-shedding
10:30:19 <ja> it is weird that it isn't considered normal to fix the formatting of other peoples commits
10:30:24 <maerwald> and I avoid that in my PRs too... I can fix the style with a follow up commit
10:30:46 <ja> but the follow up commit clutters the history, some projects have really clean histories
10:31:14 <maerwald> history is never clean
10:31:40 <int-e> right. some projects lie about their history. :P
10:31:56 <ja> oh, you should see the project i am working on recently... nothing is ever merged, everything is in branches because the boss is afraid that something will have to be changes
10:32:13 <monochrom> module M(f, g,) is also OK
10:32:17 <ja> so all us poor workers are rebasing stuff 30% of the time :O
10:32:24 <monochrom> unfortunately module M(,f,g) is not
10:32:55 <int-e> ja: you shouldn't have to rebase anything if nothing is ever merged ;)
10:33:29 <ja> oh, but everything is also force-pushed ;) so feature branch 1 is force pushed to fix a bug, and then feature branch 2 and 3 must be rebased
10:33:38 <int-e> monochrom: isn't the former a ghc extension?
10:34:03 <monochrom> I think no. I'll check again.
10:34:24 <wavemode> jeez. force push is something you do in star wars, not in real production code
10:34:33 <maerwald> lol!
10:34:43 <_deepfire> $ and . mix, but & and >>> don't, so that latter, inverted style is a bit penalised, from visual comprehension standpoint.
10:34:45 <int-e> monochrom: Oh wow, no.
10:34:58 <monochrom> :)
10:35:39 <monochrom> Yeah all Haskell 2010 at least. Pretty sure Haskell 98 and probably further back.
10:37:44 <boxscape> huh I thought that was the whole ExtraCommas proposal that was accepted but never implemented
10:39:00 <boxscape> apparently not
10:41:13 <boxscape> from the title of that it sounds like it was originally about *sub*-export lists, so something like "module (Foo(A,B,))"
10:41:24 <boxscape> er "module M(Foo(A,B,))", rather
10:42:35 <monochrom> @type (&)
10:42:36 <lambdabot> a -> (a -> b) -> b
10:43:50 <monochrom> IMO "5 & (sin >>> negate >>> asin)" is good-looking enough.
10:44:38 <monochrom> If you don't mind, I may also suggest that parentheses can help with humans switching between "this is pointful code" "oh now this part is pointfree code"
10:44:40 <boxscape> In situations like this my first instinct is always to want to write something like "5 & $ sin >>> negate >>> asin" to get rid of the parens :)
10:44:59 <monochrom> haha
10:45:17 <_deepfire> monochrom: would you then advocate that people start using "(a . b . c) $ d" ?
10:45:29 <monochrom> (a . b . c) x, not need for #
10:45:34 <monochrom> err, no need for $
10:45:52 <_deepfire> ..what's wrong then, why don't people use that style?
10:46:03 <_deepfire> why do they prefer "a . b . c $ d" ?
10:46:08 <monochrom> "xs <*> ys = liftA2 ($) xs ys" is one of the few places where one should use $
10:46:11 <jumper149> I want to build a multi-package cabal project with nix. Everything builds fine with cabal, when my nix-shell is right, but can I am not getting it to build with nix-build.
10:46:24 <monochrom> People are wrong. Did you see what I wrote?
10:46:51 <_deepfire> Well, that's certainly a matter of debate, then, I think we can agree on that : -)
10:47:00 <monochrom> I consistently prefer both "while ... { cond--; }" and "(a . b . c) x"
10:47:26 <ja> what's wrong with 'a $ b $ c $ d' ? isn't it simplier because it has only one operator?
10:47:28 <MarcelineVQ> poor  a (b (c x))  no one loves you
10:47:46 <monochrom> I respect another person preferring the consistently opposite, both "while ... cond--;" and "a . b . c $ x".
10:47:58 <boxscape> ja for me, it's just that dollar signs are uglier than dots
10:48:11 <ja> aah, anti-american bias :P
10:48:38 <monochrom> But "while ... { cond--; }" and "a . b . c $ x" at the same time? Sorry I can't respect that, what's the made-up logic?
10:48:59 <_deepfire> I don't see when the "while" bit entered the discussion..
10:49:07 <MarcelineVQ> a while a go
10:49:13 <monochrom> haha
10:49:25 <_deepfire> : -)
10:49:45 <monochrom> It doesn't have to be "while".
10:49:49 <MarcelineVQ> <monochrom> In C for example, if I write "while (cond > 0) cond--;", the pro advice is "put back the curry braces, while (cond > 0) { cond--; }, even if it is syntactically unnecesary, it improves readability".  No one speaks like "how do I get rid of curry braces?"
10:50:12 <boxscape> monochrom for me, in while, the main reason for curly braces isn't readability, it's making sure that they're there if another statement is added to the while loop preemptively
10:50:21 <monochrom> I am going for curry braces and parentheses. Put them on par.  You like one you like the other.  You hate one you hate the other.  Because they both stand for grouping.
10:50:27 <int-e> ja: personally I've used $ as a kind of punctuation. So I could write, say, return $ f . g $ x.
10:50:35 <monochrom> darn, curly braces
10:51:01 <boxscape> (preemptively refers to preemptively making sure, not to preemptively adding statements)
10:51:12 <ja> int-e: and with imprecativity, finally you can rule the world ;)
10:51:19 <ja> *impredicativity
10:51:59 <boxscape> I actually though about writing a C preprocessor that uses indentation rather than curly braces
10:52:12 <boxscape> probably already exists somewhere
10:52:27 <wavemode_> well, nim is a programming language which compiles to C and is indentation-based
10:52:41 <monochrom> Well, when "f", "g", "h", "x" become long names or long expressions themselves, you will be writing ( \n f . \n g . \n h \n ) x. So now () is on par with {}, you keep them "in case you add one more line in the middle"
10:53:15 <monochrom> and because {, }, (, ) are on their own lines.
10:54:53 <maerwald> I prefer writing out lambdas a lot instead of pointfree closures... makes it easier to change things around too
10:56:05 <maerwald> but ppl sometimes think it looks junior, because cool haskellers golf a lot
10:56:40 <wavemode_> easier to change things around? only junior programmers change code. an expert gets it right the first time :p
10:56:46 <maerwald> lol
10:57:00 <monochrom> We can have the best of both worlds.  ( <newline> (\x3 -> ...) . <newline> (\x2 -> ...) . <newline> (\x1 -> ...) <newline> ) expr_for_x
10:57:22 <ja> oooh that is awesome, almost erlang!
10:58:50 <ja> actually reminds my of promise chains in javascript hahah :O
10:59:00 <ja> *reminds me
10:59:10 <monochrom> Not sure if you already get my point, here is a much more parallel articulation, sorry if you already understand me.
10:59:53 <maerwald> especially when destructuring a tuple, I will always do \(x, y) -> instead of (foo . fst)
11:00:34 <monochrom> In future-proving the change "for(;;) stmt;" -> "for(;;) { stmt1; stmt2; }", people do not go "that's annoying, how to get rid of the {}?", they go "so let's add {} preemptive".
11:00:53 <maerwald> it's good to see the data... destructuring makes things more comprehensible
11:01:22 <monochrom> In future-proving the change "f x" -> "(g . f) x", people go "that's annoying, how to get rid of the ()?", they don't go "let's add () preemptively, (f) x".
11:01:28 <monochrom> See what's wrong?
11:02:24 <ja> monochrom: it is wrong because it assumes that statements are distinct from expressions?
11:03:17 <ja> (f) doesn't make sense for them because it has little chance of getting broken up into multiple lines
11:04:27 <ja> maerwald: agreed, and it works better with ide's and dependent types too. i guess another way to put it is: pattern matching is more flexible than lenses?
11:04:58 <monochrom> statements and functions. not really arbitrary expressions.
11:05:27 <monochrom> My parallel is both syntactic and semantic. The semantics of C statement is state transition function.
11:06:37 <monochrom> and stmt -> stmt1; stmt2 is seldom breaking up either.  Rather, adding one more thing to do for a new feature.  This you do to f -> g . f too.
11:11:25 <ja> wait, why isn't "stmt -> stmt1; stmt2" breaking up either? by breaking up, do you mean inserting a newline? i would argue that it is very rare to have two statements on a line in c?
11:12:23 <monochrom> Ah perhaps I should write: stmt -> stmt; stmt2.
11:12:42 <ja> the arrow here means "replaced by" ?
11:12:44 <monochrom> I will be adding stmt2 on its own line, yes.
11:13:12 <monochrom> I will also be adding g on its own line, because in general f and g will be long.
11:13:17 <monochrom> yes
11:14:26 <ja> ok, if i understand you correctly, you'd like people to do things consistently across those two transformations, because they currently do not? i thought that was what you implied by  "see what's wrong"
11:14:40 <monochrom> https://groups.google.com/forum/#!msg/comp.lang.functional/YXnfQ4vUE40/UTNrI90LUhcJ  :)
11:15:59 <monochrom> Maybe not that far.  Just to the point of stop bitching about parentheses is good enough.
11:22:15 <maerwald> never switch your keyboard layout... now mediocre editors are all broken
11:22:18 * hackage free-functors 1.1.1 - Free functors, adjoint to functors that forget class constraints.  https://hackage.haskell.org/package/free-functors-1.1.1 (SjoerdVisscher)
11:22:27 <monochrom> yikes
11:23:30 <monochrom> Which editor(s) broke on you?
11:23:57 <maerwald> vscode... it's a nice IDE, but the editor...
11:24:15 <maerwald> and the vim plugin is buggy
11:25:16 <ja> so is the problem that it maps letters instead of keycodes? or is it that it maps keycodes instead of letters ? ;)
11:25:44 <maerwald> ja: firmware
11:26:07 <ja> damn, didn't know that vscode shipped with firmware yet :O
11:26:12 <maerwald> lol
11:26:36 <monochrom> Yeah, I don't understand, how does firmware come into this?
11:26:36 <maerwald> I mean... I don't even know where to start fixing the bindings
11:28:00 <maerwald> there are no such problems since I don't use software for the layout switch
11:30:10 <ja> oooh, so you made your keyboard firmware actually swap the keycodes? 
11:30:56 <maerwald> ja: ja
11:31:25 <maerwald> ergodox
11:32:10 <maerwald> programming is not healthy (also physically)
11:33:31 <maerwald> only sad thing is I can't figure out how to do a macro for e.g. ->
11:34:23 <monochrom> You need firmware that supports digraphs. :)
11:35:42 <maerwald> maybe it does, but not the online configurator
11:36:37 <monochrom> I hope you don't mean you visit a website on the Internt to configure your keyboard...
11:37:01 <maerwald> I do
11:37:10 <monochrom> haha darn
11:37:22 <ja> maerwald: seems like vscode treats keys differently, some keys are considered not to depend on keyboard layout, others are: https://github.com/microsoft/vscode/blob/c63c97c12848e85769e717209b73110e83c18ef6/src/vs/base/common/scanCode.ts
11:37:55 <maerwald> https://configure.ergodox-ez.com/ergodox-ez/layouts/LMBRq/latest/0 it's actually awesome
11:38:43 <maerwald> alternative is using the qmk firmware
11:38:46 <ja> i don't see the "split by case" key :O
11:41:04 <maerwald> what is that
11:41:52 <ja> heh just a snark ;) sorry
11:42:28 <ja> was thinking of keys for the actions you do in the Idris book
11:42:33 <maerwald> I arranged the symbols carefully with haskell operators in mind
11:42:52 <monochrom> snark eh, I can do that too. Is it the tall { symbol that mathematicians use to define piecewise functions? :)
11:43:45 <maerwald> so -> <- and => >>= are all very close
11:43:53 <monochrom> Haha I see.  Newsflash: ghcup implementation switches to Haskell because author has a Haskell keyboard not a shell script keyboard. :)
11:43:56 <juri_> is there something like do notation for appending lists? I've got a long set of calling functions with <> between them, i'd like it to be a bit more do notationy.
11:44:00 <maerwald> lol
11:45:17 <maerwald> yeah, actually I don't know if it breaks down with eg rust
11:46:01 <wavemode__> juri_, that's what concat is for
11:47:33 <boxscape> is there a good reason to prefer concat [a, b, c, d] over a <> b <> c <> d? (assuming you can't do concatMap or something)
11:48:40 <Rembane> boxscape: It's shorter. :)
11:48:52 <solonarv> lines up better if each of a,b,c,d is on a separate line, precedence is more obvious if some of a,b,c,d contain operators
11:49:02 <maerwald> can concat be theoretically more efficient (as in: different implementation)
11:49:12 <boxscape> Rembane I guess in the limit it is, yeah
11:49:14 <maerwald> that was a question
11:49:43 <wavemode__> they both get fused so they're equivalent, no? but without fusion you'd prefer concat
11:49:46 <boxscape> solonarv you can write them on separate lines with <> too but precedence is a fair point
11:50:19 <maerwald> ah, this is a style question :)
11:50:38 <boxscape> solonarv oh though you're right it does line up better
11:50:57 <monochrom> I have a good way of breaking "a <> b <> c <> d" into 4 lines, so I go with it. But if other people don't like it, concat [a, b, c, d] broken into 4-5 lines is cool too.
11:51:18 <maerwald> why 4 lines?
11:51:31 <boxscape> because it's 4 elements?
11:51:31 <maerwald> how small is your screen?
11:51:34 <monochrom> a \n <> b \n <> c \n <> d \n
11:51:46 <boxscape> monochrom do you line up the a with the b?
11:51:53 <maerwald> I'm trying to imagine
11:51:57 <monochrom> My screen is 5 characters wide, 1000 lines tall, OK?
11:52:06 <maerwald> xD
11:52:08 <monochrom> I line up a with <>
11:52:16 <boxscape> I see
11:52:31 <wavemode__> if instead of a, b, c it's someVeryLongComplexExpression1, someVeryLongComplexExpression2, etc. then monochrom's solution is typical
11:53:05 <monochrom> These are weak preferences to me, not strong preference. If collaborating with people of a different alignment, I'm OK with going with theirs.
11:53:28 <hyiltiz> whats the best way to convert 
11:53:32 <monochrom> Yeah a,b,c,d are meta variables standing for 2000-characters-long expressions.
11:53:42 <maerwald> makes sense
11:53:55 <boxscape> hyiltiz convert from what to what?
11:54:51 <hyiltiz> What's the best way to convert/parse a JSON to some haskell representation? My actual question is, is lens the best thing to traverse and use a deeply nested tree-like object converted from JSON?
11:55:02 <maerwald> imagine you could shuffle through all isomorphic representations of an expression in your IDE
11:55:10 <MarcelineVQ> boxscape, maerwald: bytestring concat is significantly more efficient than repeated <>
11:55:13 <hyiltiz> for random access etc.
11:55:14 <monochrom> Leslie Lamport has a very neat (IMO, you will find it bizzare) notation that balances all stylistic concerns.  If you have read his TLA+ book, you know it.
11:55:17 <maerwald> Ma
11:55:29 <maerwald> ah, I suspected
11:55:33 <boxscape> MarcelineVQ oh, interesting
11:56:23 <wavemode__> MarcelineVQ, you're correct, but this was asked regarding lists. which I believe get fused either way
11:56:28 <monochrom> Whereas we write "a && b && c", he writes (if needed to break into 3 lines) "&& a \n && b \n && c". The idea is that now you have 3 bullet points, and the bullet tells you which operator he wants.
11:56:48 <boxscape> hyiltiz I suspect using something like aeson together with lens-aeson is about as good as you can get
11:56:52 <monochrom> Solves all of your layout and version control issues, no? :)
11:57:16 <maerwald> is GHC smart enough to optimize that out? I guess it doesn't have knowledge that concat is faster
11:57:17 <MarcelineVQ> even then, if you use <> in a silly way you're doing worse than concat, consider ((a <> b) <> c) <> d)
11:57:24 <hyiltiz> @boxscape for conversion, sure; what about manipulating them?
11:57:24 <lambdabot> Unknown command, try @list
11:58:50 <wavemode__> sure but <> is right associative, so you'd have to be _trying_ to shoot yourself in the foot :p
11:58:55 <boxscape> to me lenses sound like the way to go hyiltiz
11:59:46 <MarcelineVQ> You don't have to try too hard tbh. footguns aren't usually in plain sight
12:00:39 <monochrom> What are footguns?!
12:01:09 <MarcelineVQ> they're like snakes but they're guns, if you're not watching your feet they fire
12:01:47 <monochrom> Wait, I thought they fire only after you watch.
12:02:05 <monochrom> Like the way you can walk in air until you look down.
12:02:14 <hyiltiz> k thx!
12:02:18 <monochrom> gravity doesn't fire until you watch :)
12:02:26 <MarcelineVQ> You don't have to look for a footgun to get footshot, it's just that looking doesn't gurantee your safety
12:02:44 <MarcelineVQ> So I was wrong to say what I said just now
12:02:51 <MarcelineVQ> I guess I shot myself in the foot with that one.
12:03:08 <monochrom> I don't fully understand but haha
12:03:31 <MarcelineVQ> " if you're not watching your feet they fire"  " it's just that looking doesn't gurantee your safety"
12:03:43 <wavemode__> "footgun" is an analogy to a product where one of its hidden features is a loaded gun aimed at your foot. even if you include in the instructions to handle the package with care, you'll inevitably end up with lots of complaints from one-footed customers
12:04:06 <MarcelineVQ> It's foot in mouth really, but foot gun in mouth has a social connotation
12:04:24 <monochrom> Why are we so violent? Always speaking of gun shooting and missile launching.
12:04:51 <boxscape> they're missiles of friendship :)
12:04:59 <MarcelineVQ> nevermind, fire and forget
12:05:48 <monochrom> Even Dijkstra was like "lock stock barrel" all the time.
12:13:19 * hackage superrecord 0.5.1.0 - Supercharged anonymous records  https://hackage.haskell.org/package/superrecord-0.5.1.0 (AlexanderThiemann)
12:25:40 <__monty__> Hmm, does Data.Time provide no way to parse timezones like CEST?
12:26:38 <c_wraith> That's not a pure operation
12:26:52 <c_wraith> timezones change legislatively fairly regularly
12:27:50 <c_wraith> There are libraries that handle loading standardized timezone information files and working with them.
12:27:58 <c_wraith> They tend to have "olson" in their name
12:29:50 <__monty__> It doesn't have to be pure. But it seems like a fairly reasonable thing to want to do?
12:29:58 <c_wraith> that's why there are libraries for it.
12:37:58 <ja> ooh, you can even read the tzinfo db compile time with the package timezone-olson-th
12:38:27 <__monty__> I guess I'm looking for tzByName from the tz package. This is for user configuration of displayed times.
12:44:12 <__monty__> c_wraith: Thank you for the answer I was expecting but didn't want : )
13:08:25 <wikiemol> Can anyone explain to me the point of overloaded labels? 
13:09:14 <koz_> wikiemol: Easiest example is 'this is how label optics work'.
13:09:40 <koz_> So like, you can define 'labels' corresponding to record fields, and then access and modify these fields without having to know what record they're from.
13:10:04 <koz_> So when you write something like 'view #foo r', all we need to know is that 'r' has a field labelled 'foo'.
13:10:18 <koz_> In this case, #foo is an overloaded label.
13:12:38 <wikiemol> koz_ hm... I am still kind of confused by this. I suppose it might be helpful to describe where I encountered them https://github.com/haskell-gi/haskell-gi, why are they used  so heavily in the GTK ffi?
13:12:53 <koz_> I would imagine for similar reasons.
13:13:13 <koz_> Consider this line: #add win button
13:13:22 <koz_> #add probably can add 'whatever' to 'whatever else'.
13:13:49 <koz_> This is hard to do in Haskell without resorting to type classes, which for something like GTK (which heavily leans on inheritance) would turn type inference to custard.
13:13:58 <wikiemol> So does this mean overloaded in the way overloaded is used in other languages?
13:14:22 <koz_> wikiemol: 'Overloaded' in this case means 'ad-hoc polymorphic' - meaning, one label can 'do' or 'mean' lots of different things.
13:14:34 <koz_> Where a 'label' is a thing starting with #.
13:15:19 <wikiemol> Okay, so it basically just allows you to define overloaded functions without type classes?
13:15:48 * hackage circular 0.1.1 - Circular fixed-sized mutable vectors  https://hackage.haskell.org/package/circular-0.1.1 (dschrempf)
13:15:50 <koz_> wikiemol: Yeah, something like it.
13:16:00 <koz_> It's not the _only_ usage, but it's the most common one I've seen so far.
13:16:09 <wikiemol> thank you for the explanation!
13:16:27 <koz_> (I'm _massively_ skating on detail here though)
13:16:31 <koz_> (just saying)
13:17:25 <koz_> But to be honest, I'd worry less about what OverloadedLabels _are_, and more about what they can do for you.
13:17:35 <koz_> (they're similar to monads in this regard)
13:17:57 <koz_> (focusing too much on 'WAT IS MONAD RLY' isn't that helpful versus 'what do they let me do that I otherwise couldn't')
13:18:31 <wikiemol> Yeah, I suppose that is my real question
13:19:08 <koz_> In this case, in GTK specifically (as far as I can tell), it lets you pretend you have an inheritance-or-OO-like interface.
13:19:28 <koz_> Again, consider '#add win button'. #add can basically add whatever to whatever-else, because that's how GTK works.
13:19:58 <koz_> Or like 'on win #destroy Gtk.mainQuit'.
13:20:10 <bonz060> Hi. I've just installed GHC and cabal-install from GUIX, but any time I try to use cabal .e.g. `cabal install -n`, I keep getting: `Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)`. How do I fix thing? Anyone have any idea?
13:20:11 <koz_> #destroy can stick a disposal function on 'basically any damn thing'.
13:20:40 <bonz060> /s/fix thing/ fix it/
13:21:28 <wikiemol> gotcha, yeah I think that makes sense. I feel like it will bite me later not knowing what its doing "under the hood", but I really only need to get a window on the screen 
13:21:40 <koz_> In all honestly? I wouldn't worry about it too much.
13:21:48 * hackage linenoise 0.3.2 - A lightweight readline-replacement library for Haskell  https://hackage.haskell.org/package/linenoise-0.3.2 (ejconlon)
13:22:05 <wikiemol> koz_ haha advice taken
13:22:26 <koz_> If you need the specifics of OverloadedLabels, having some use (and mis-use) experience will help you understand what the GHC user's guide says about OverloadedLabels much more than just staring at it without a problem or use case.
13:23:03 <koz_> And I can guess that, at least at first, it won't matter - try using them for your GTK stuff, and cross any bridges about understanding OverloadedLabels per se when you get to them.
13:25:37 <koz_> bonz060: I am not aware of a '-n' flag, and looking at 'cabal -h' or 'cabal install -h' shows me nothing.
13:25:42 <koz_> What version of Cabal is Guix feeding you?
13:25:49 <koz_> (cabal -v)
13:25:57 <koz_> Sorry, cabal -V.
13:26:27 <wikiemol> koz_ thanks for the help
13:26:35 <koz_> wikiemol: No worries - best of luck.
13:26:35 <bonz060> koz_: `cabal-install version 2.4.0.0 compiled using version 2.4.0.1 of the Cabal library`
13:26:44 <koz_> bonz060: That's _extremely_ old.
13:26:54 <koz_> For reference, I'm running 3.2.0.0
13:27:11 <maerwald> guix... >:)
13:27:24 <bonz060> koz_: Wow. Just wow. I reckon I'd need to create a patch to update that...
13:27:38 <koz_> bonz060: Just out of curiosity,what version of GHC did you get?
13:27:59 <bonz060> koz_: I'm using 8.6.5
13:28:50 <koz_> OK, that's not _too_ old. Current is 8.10.1.
13:29:29 <boxscape> %! ghc --version
13:29:29 <yahb> boxscape: [Segmentation fault]
13:29:31 <boxscape> hm
13:29:46 <maerwald> guix is the "best" of both worlds: lisp and nix...
13:30:15 <MarcelineVQ> % :! ghc --version
13:30:15 <yahb> MarcelineVQ: The Glorious Glasgow Haskell Compilation System, version 8.10.1
13:30:23 <MarcelineVQ> funny segfault tho
13:30:34 <koz_> maerwald: I have a friend (long-time Nix user) who had more than a few horror stories regarding Guix, its maintainers and ecosystem. :P
13:30:35 <boxscape> oh huh
13:31:02 <boxscape> I think yahb's bash prompt might just be broken at the moment?
13:31:10 <maerwald> koz_: I have those with nix already :>
13:31:12 <MarcelineVQ> I'd be more interested in horror stories from a long-time guix user
13:31:23 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/06-fam.html  complete with LingLing40hrs reference. :)
13:32:04 <koz_> MarcelineVQ: Those have merit too, but you gotta have newcomers to a community to have a community. :P
13:32:37 <monochrom> What is guix? Is it like nix but for windows? :)
13:32:43 <maerwald> yeah, because most of the old burn out from anger
13:33:07 <monochrom> Err neveermind, didn't read backlog.
13:33:09 <maerwald> especially in distros
13:33:55 <monochrom> Why are things that use Lisp called Gu.* ? For example Guile too.
13:33:59 <maerwald> I'm also afraid ghcup won't help them on guix...
13:34:18 <monochrom> Is it because Guy Steeles wrote the Common Lisp manual?
13:34:25 <koz_> monochrom: Guile is another word for 'having the ability to be conniving and clever'.
13:34:28 <koz_> It's wordplay on 'scheme'.
13:34:39 <monochrom> Oh!
13:34:50 <koz_> (there's a bunch of Scheme-esque languages with that kind of wordplay)
13:34:59 <koz_> Guix is named after Guile.
13:35:06 <MarcelineVQ> and then there's Gambit scheme, but everything it touches explodes, kukukuku
13:35:07 <koz_> (since that's its control language)
13:35:13 <koz_> Yep, Gambit is one.
13:35:17 <koz_> There are a few more.
13:35:19 <monochrom> So is it true that guix is "being clever, but for nix"? :)
13:35:26 <koz_> (someone needs to write Keikaku Scheme)
13:35:35 <MarcelineVQ> kokoro scheme
13:35:40 <koz_> monochrom: I wouldn't go as far as 'clever'.
13:35:42 <MarcelineVQ> "please just work how I want"
13:35:52 <koz_> Guile isn't as much 'designed' as 'thrown together sorta kinda'.
13:35:57 <_deepfire> Frankly, as a long time Nix user, I never got the appeal of guix.
13:36:14 <_deepfire> It also appears to steadily lose on the mindshare and contributions..
13:36:17 <koz_> _deepfire: Your story mirrors the one I hear from my long-time Nix (and NixOS) friend.
13:36:23 <koz_> On both counts!
13:36:35 <aenesidemus> "readFile :: FileSystem :< effs => FilePath -> Eff effs String" what is ":<"
13:37:00 <maerwald> I still don't see what's worse compared to nix >:)
13:37:21 <koz_> aenesidemus: I suspect it means 'includes'? So like, your effects must include 'FileSystem'.
13:37:34 <_deepfire> maerwald: Nothing appears close to solving that many issues at the same time, either.
13:37:48 <monochrom> I think if you gave COBOL syntax to nix config files, that would be worse than nix. >:)
13:38:04 <maerwald> aenesidemus: did you intend to use an effects system or did someone force this on you?
13:38:16 <_deepfire> There's a bunch of efforts by Haskell people at improving the language story in Nix.
13:38:19 <aenesidemus> im just reading the docs of this project and dont know what it means
13:38:32 <koz_> aenesidemus: Which project?
13:38:37 <aenesidemus> https://github.com/hasura/eff
13:38:37 <monochrom> maerwald: I suspect self-infliction, people read blogs and get fascinated by topics they aren't ready for.
13:39:03 <koz_> aenesidemus: Yeah... roughly what I said then.
13:39:11 <maerwald> eff is the new shining star on the effect horizon indeed
13:39:23 <koz_> maerwald: Alexis' talk is very worth watching IMHO.
13:39:28 <maerwald> start with olegs papers first
13:39:29 <koz_> (even if you're not interested in effect systems)
13:39:35 <aenesidemus> okay but what is it? a function? a number? a value? a keyword? 
13:39:38 <koz_> She talks about a lot of rather interesting stuff.
13:39:41 <aenesidemus> is it built into haskell
13:39:48 <maerwald> koz_: I watched it.
13:40:04 <koz_> aenesidemus: Basically, it's an operator on constraints.
13:40:06 <_deepfire> eff's got enough clout to have a GHC proposal for primops, intended to accelerate eff..
13:40:26 <MarcelineVQ> you don't need clout to make a proposal :>
13:40:31 <aenesidemus> what is it syntactically 
13:40:40 <koz_> aenesidemus: A type operator.
13:40:45 <maerwald> aenesidemus: http://okmij.org/ftp/Haskell/extensible/exteff.pdf
13:40:49 <koz_> (but that's not going to aid your understanding I don't think)
13:40:50 <_deepfire> MarcelineVQ: well, it had quite a serious discussion around it -- so attention was available.
13:41:03 <_deepfire> the same attention is not available for many other proposals..
13:41:09 <maerwald> and http://okmij.org/ftp/Haskell/extensible/index.html
13:41:11 <MarcelineVQ> A big factor there was that the proposal came with working code
13:41:16 <MarcelineVQ> That's not so common
13:41:21 <koz_> MarcelineVQ: A full branch of GHC, no less.
13:41:26 <_deepfire> good point..
13:41:27 <aenesidemus> where is the symbol ":<" documented
13:41:33 <koz_> aenesidemus: Probably in 'eff' itself?
13:41:43 <monochrom> Definitely in eff itself.
13:42:27 <maerwald> I'd suggest you read up on the origin of all that and worry about specific operators later, but...
13:42:39 <monochrom> yeah
13:42:40 <boxscape> aenesidemus it's defined here https://github.com/hasura/eff/blob/master/eff/src/Control/Effect/Internal.hs#L80-L82
13:43:06 <boxscape> so, it's a typeclass
13:43:08 <monochrom> something about "I can't learn it for you"
13:43:16 <koz_> boxscape: No it's not.
13:43:19 <koz_> it's a 'type operator'.
13:43:27 <koz_> Oh wait.
13:43:31 <koz_> I should read before I speak. :P
13:43:33 <maerwald> not sure this is going to be enlightening, especially since eff is not a naive implementation
13:43:36 <monochrom> heh
13:43:56 <koz_> OK, now _I'm_ curious.
13:44:14 <koz_> That has 'type (:<) ...' and then 'class eff :< effs where ...'.
13:44:16 <koz_> What gives?
13:44:22 <boxscape> koz_ that's a standalone kind signature
13:44:27 <koz_> ....
13:44:39 <aenesidemus> seems like this is what I was looking for https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/#constraints
13:44:40 <koz_> 'Welcome to GHC. Everything is type.;
13:44:42 <koz_> '
13:44:52 <boxscape> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-StandaloneKindSignatures
13:44:54 <monochrom> "class eff :< effs" makes (:<) a type class that has an infix-notation name and it's a 2-parameter type class.
13:45:26 <bonz060> koz_: I've updated my cabal from pacman's repos; Now I'm using cabal v3.2.0.0 and ghc v8.10.1 but still getting: `Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)`
13:45:38 <monochrom> the preceding type declaration, I haven't learned it, but looks like it's to clarify the kinds of the two type parameters.
13:46:03 <koz_> monochrom: If it's a SAKS, I wish it didn't start with the word 'type'. It's pretty confusing IMHO.
13:46:09 <koz_> 'kind' would have made more sense to me.
13:46:17 <koz_> I looked at that and went 'oh, type synonym, right'.
13:46:28 <boxscape> koz_ there was some discussion about omitting the word type for SAKs but it was easier this way for some reasson
13:46:30 <monochrom> Now we just need :'< to express the sentiment of any reader reading this. :)
13:46:49 <koz_> boxscape: Nobody suggested adding 'kind'?
13:46:56 <jollygood2> read can parse show from UTCTime and LocalTime, but not from ZonedTime. is this a bug?
13:47:04 <maerwald> using :: for kind signatures was already a mistake
13:47:07 <monochrom> Yes "kind" would be clearer. But ever heard of TypeInType? >:)
13:47:14 <boxscape> koz_ someone probably did, and someone else probably didn't like it
13:47:17 <koz_> monochrom: I hardly need reminding.
13:47:26 <koz_> I know that as far as GHC is concerned, kinds aren't a thing.
13:47:35 <koz_> (and I have dealt with some of the amusing consequences of said)
13:47:37 <boxscape> (TypeInType is deprecated, Type :: Type is a thing though :P)
13:47:42 <koz_> Now we truly can say we're all about types. :P
13:47:51 * monochrom cries
13:48:15 <koz_> boxscape: How do you actually _sound_ 'Type :: Type'? 'The type of Type is Type?'.
13:48:27 <boxscape> koz_ uhh I haven't really thought about it
13:48:29 <monochrom> Haskell was so much easier when Monad was the most difficult topic.
13:48:33 <koz_> s/?'./.
13:48:35 <koz_> ?/
13:48:35 <lambdabot> Maybe you meant: v @ ? .
13:48:50 <maerwald> when all you really wanted was dynamic types
13:48:55 <boxscape> koz_ how about Type is a Type
13:49:15 <koz_> boxscape: wow, much zen, very clarity
13:50:29 <maerwald> I can't even tell whether it's a kind or type signature
13:50:47 <maerwald> but does it matter
13:50:49 <boxscape> same same
13:51:25 * maerwald pours a whiskey
13:51:43 <koz_> maerwald: Everything is Type now.
13:51:44 <boxscape> https://www.youtube.com/watch?v=rMApgIeqL24
13:51:56 <koz_> Just accept the one-ness of our goddess. :P
13:51:57 <monochrom> It still matters, there is still a difference between "myterm :: MyType" and "MyType :: MyKind"
13:52:01 <Uniaika> Haskell has become much easier when stopping at MTL transformers
13:52:16 <koz_> boxscape: :D
13:52:20 <maerwald> koz_: the british accent is key
13:52:33 <monochrom> i.e., ther is still a line between the term level and the type level, despite both using the same notation.
13:52:35 <maerwald> oops, boxscape 
13:52:41 <boxscape> it is
13:53:14 <boxscape> monochrom yeah that's fair
13:53:15 <monochrom> :)
13:53:55 <koz_> Listen to monochrom for wisdom.
13:54:05 <koz_> Signed, a dork who has none. :P
13:54:15 <boxscape>  btw, very first comment in the proposal
13:54:19 <boxscape> whoops, sec
13:54:37 <monochrom> Haskell is a bloody pun language. What do you expect, if/since it begins with () :: () and [] :: [] ?!  The stage is set for confusion.
13:54:38 <dsal> koz_: It takes wisdom to realize you have none.
13:54:47 <boxscape> very first comment in the proposal suggested using kind, rae answered "But you're giving a signature to a type, not a kind."
13:54:53 <boxscape> https://github.com/ghc-proposals/ghc-proposals/pull/54
13:55:12 <maerwald> it's all a lie, but often times the lies are even more true: https://www.youtube.com/watch?v=4n8j6z8fQ_c
13:55:15 <koz_> boxscape: Yes, I realize Type :: Type means everything is a type. It's still confusing AF.
13:55:25 <koz_> But that's fine, ship's sailed, that's just how it be.
13:55:48 <koz_> monochrom: Ah, so _that_ is why every library must be named with wordplay or a literary reference?
13:55:58 <boxscape> koz_, well, no, that's not relevant here - basically, using type here because it's a signature for a type would be like saying "term foo :: Int -> Int" for type signatures
13:56:24 <koz_> boxscape: OK, fair, but I still think it looks way too much like a type alias.
13:56:30 <boxscape> yeah I don't disagree
13:56:34 <koz_> Frankly, what even separates the two?
13:56:39 <boxscape> = vs ::
13:56:43 <koz_> Ah.
13:56:56 <koz_> That's definitely confusing.
13:57:14 <koz_> Well, I know now, but I expect this will bite me at least a few times.
13:57:30 <koz_> dsal: wow, very zen, much enlighten
13:59:27 <maerwald> Here is anoter Zen: if you truly want to understand something, ask someone who doesn't know anything about it.
14:00:14 <maerwald> I take your questions now...
14:00:16 <monochrom> Yeah I was not tricked because I saw "type X :: Y" not "type X = Y" so I had to conclude I haven't learned this.
14:00:47 <boxscape> I've used SAKs quite a bit and I *still* though it was a type synonym for a couple seconds
14:01:16 <monochrom> Hi maerwald how do you explain quarks and gluons? :)
14:01:50 * maerwald hides
14:01:59 <dsal> Those are both from Star Trek.
14:02:28 <jollygood2> > TimeOfDay 25 61 61
14:02:30 <lambdabot>  error:
14:02:30 <lambdabot>      Data constructor not in scope:
14:02:30 <lambdabot>        TimeOfDay :: Integer -> Integer -> Integer -> t
14:02:43 <jollygood2> no error
14:03:21 <jollygood2> ?> TimeOfDay 25 61 61 =>  25:61:61
14:03:22 <lambdabot> Maybe you meant: v @ ? .
14:04:42 <monochrom> The bots don't have every library in the world.
14:05:00 <jollygood2> which is why I pasted the result
14:05:58 <monochrom> OK, carry on.
14:06:29 <jollygood2> do you have anything useful to say?
14:06:31 <jollygood2> if not shut up
14:06:56 <c_wraith> It's probably unwise to be so aggressive
14:07:49 <maerwald> :(
14:10:11 <MarcelineVQ> was there a question?
14:10:20 <monochrom> No.
14:21:33 <maerwald> https://www.amazon.com/Haskell-Performance-Programming-Samuli-Thomasson/dp/1786464217 is there a better book than this wrt Haskell performance? 
14:39:00 <ja> MarcelineVQ: yes: 22:46 <. jollygood2> read can parse show from UTCTime and LocalTime, but not from ZonedTime. is this a bug?
14:39:29 <ja> (my timestamp is CEST)
14:41:53 <jollygood2> it works for your time zone? then it is definitely a bug
14:43:29 <ja> i am not answering your question either (please don't cold me!), i was answering MarcelineVQ's question whether you had asked a question or not before the aggression
14:44:51 <jollygood2> ah, ok
14:51:56 <MarcelineVQ> jollygood2: what did you try to see if it worked? my own little test worked out
14:54:05 <jollygood2> read <$> show <$> getZonedTime :: IO ZonedTime     *** Exception: Prelude.read: no parse
14:54:32 <jollygood2> I'll brb
14:56:33 <MarcelineVQ> interesting, that's simpler than what I was doing. your example works here as written
15:04:57 <jumper149> In my ghci editMode: Vi seems to be broken? Is it not configured in .haskeline anymore?
15:07:02 <boxscape> fun fact:
15:07:03 <boxscape> % flip' = (<*>) ((<*>) (pure ((<*>) (pure (<*>)) pure)) (<*>)) (pure pure)
15:07:04 <yahb> boxscape: 
15:07:10 <boxscape> % flip' (/) 2 8
15:07:10 <yahb> boxscape: 4.0
15:08:22 <monochrom> How did you come up with that monster?!
15:08:41 <boxscape> monochrom <*> is the S combinator and pure is the K combinator, flip is the C combinator
15:08:46 <boxscape> monochrom that's just the wikipedia definition of C
15:08:53 * monochrom cries
15:09:23 <monochrom> This is why I lost faith in combinatory logic.
15:10:12 <monochrom> Should I teach this to my students? >:)
15:10:43 <boxscape> I think asymptotically the length of SKI terms is only O(n) compared to the length of lambda expressions, so, could be worse. The naive conversion is O(n^3)
15:10:54 <boxscape> monochrom yes please
15:11:14 <Cale> Combinatory logic is fun to mess around with when starting out, but it doesn't seem like a very practical approach to things.
15:11:46 <boxscape> I'm trying to see if I can prove Rice's theorem in agda using SKI, so that's my main reason for thinking about it atm
15:12:53 <boxscape> though I do wonder how they originally came up with the definitions of the combinators, it's so much easier in LC...
15:14:01 * ski . o O ( `(<*>)',`pure',`ask' )
15:16:53 <boxscape> ski sorry for presumably accidentally pinging you :P
15:17:25 <nil> wait, what does rice's theorem have to do with SKI?
15:17:58 <boxscape> nil I've never seen it proved with combinators, but given the Church-Turing thesis, if you can prove it for Turing machine's, I don't see why you couldn't prove it with them instead
15:18:24 <nil> heh
15:18:30 <ski> nil : i dunno, ask boxscape ?
15:18:35 <ski> boxscape : nw
15:19:11 <boxscape> s/machine's/machines, not sure what happened there
15:19:32 * ski . o O ( "Languages and Machines" by Robert Harper in 2011-03-16 at <https://existentialtype.wordpress.com/2011/03/16/languages-and-machines/> )
15:19:42 <nil> i'm not even sure how one translates the proof of the undecidability of halting to lambda calculus
15:20:47 <monochrom> You can state and prove a version of Rice's theorem for every model of computing.
15:21:07 <nil> ahah, Halting(Œªm.not(Halting(m,m)), Œªm.not(Halting(m,m)))
15:22:39 <monochrom> \‚à©/ "some models are more equivalent than others"
15:24:51 <hpc> if we're going to mess with animal farm quotes, at least say the beginning: "all models are equivalent" :D
15:26:02 <monochrom> I think he already quoted it from his colleagues in previous paragraphs.
15:26:27 <monochrom> even including the lie "to within polynomial time"
15:33:14 <boxscape> % :t flip' @(forall a . (->) a)
15:33:14 <yahb> boxscape: ; <interactive>:1:1: error: No instance for (Applicative (forall a1. (->) a1)) arising from a use of flip'
15:33:18 <boxscape> :(
15:33:56 <boxscape> is there away to use type applications to get the version specialized to (->) but polymorphic in the first parameter to it?
15:34:00 <boxscape> s/away/a way
15:34:20 <monochrom> Predicative something something. You have to write your own newtype wrapper.
15:34:33 <boxscape> hm I see
15:34:36 <dolio> That post doesn't really get into it, but lambda calculus and Turing machines are no longer equivalent when you start thinking about higher-order functions, as I recall.
15:35:10 <dolio> They're only equivalent if you're thinking about first-order recursive functions on the natural numbers.
15:35:30 <ski> oh ?
15:35:44 <boxscape> in what way do they stop being equivalent? Does that mean one can compute more than the other?
15:35:48 <ski> because one has to encode functions ?
15:36:06 <monochrom> That's strange. What if I defunctionalize each individual lambda-calculus program to dumb it down to first-order?
15:36:21 <dolio> Yes. The difference is the 'calling convention' for higher-order functions.
15:37:03 <ski> is it related to OWA, or perhaps to difference between computability and algorithmicity ?
15:37:07 <dolio> For Turing machines, a higher-order machine gets the code for another machine as a natural number or something, and can inspect it. And a lambda term presumably just gets a lambda term that it can only apply.
15:38:03 <dolio> You could say that instead you're going to pass Church numerals for 'higher-order' lambda terms, and then they're probably equivalent, but that's kind of 'unnatural'.
15:39:18 <dolio> Also the Turing version is arguably 'wrong', because it is able to distinguish extensionally equivalent functions.
15:40:34 <solonarv> $ :t flip' @((->) _) -- boxscape 
15:40:38 <solonarv> % :t flip' @((->) _) -- boxscape 
15:40:38 <yahb> solonarv: (_ -> a -> b) -> a -> _ -> b
15:40:43 <boxscape> oh, thank you
15:40:50 <solonarv> % :t flip' @((->) e) -- does this work?
15:40:50 <yahb> solonarv: ; <interactive>:1:14: error: Not in scope: type variable `e'
15:41:03 <solonarv> phew, I remembered right
15:41:38 <monochrom> % :t flip'
15:41:38 <yahb> monochrom: Applicative f => f (a -> b) -> a -> f b
15:41:47 <boxscape> I've used the _ in type applications many times but never considered that it could be used for polymorphicity.. wait what's the actual noun for that again?
15:41:48 * hackage prettyprinter 1.6.2 - A modern, easy to use, well-documented, extensible pretty-printer.  https://hackage.haskell.org/package/prettyprinter-1.6.2 (sjakobi)
15:41:56 <boxscape> polymorphism
15:42:15 <solonarv> _ in a type applications means "GHC, please infer this type"
15:42:20 <monochrom> polymorphicibility and comprehensionism >:)
15:42:34 <boxscape> feels weird whenever there's something GHC can infer but you can't explicitly write down
15:42:37 <solonarv> (it works exactly like PartialTypeSignatures, but you don't have to enable that extension)
15:44:28 <boxscape> (as was the case with "forall k -> ..." kinds before 8.10)
15:46:29 <dolio> monochrom: It's not about the lambda terms being higher-order, I think. It's about the semantics of types, basically. So, when you give semantics to `‚Ñï^k ‚Üí ‚Ñï` in Turing machines and lambda calculus, the same functions are expressible.
15:48:08 <dolio> However, for `(‚Ñï ‚Üí ‚Ñï) ‚Üí ‚Ñï`, there is one choice for Turing machines, and two choices for lambda calculus, I think. The choice for Turing machines is a machine that takes an encoding of the machine that implements the function and outputs an encoding of a natural number.
15:49:09 <dolio> For lambda calculus, you can choose the semantics of that to be 'all lambda terms that when applied to a lambda term that can be given a type ‚Ñï ‚Üí ‚Ñï, produce a ‚Ñï.'
15:50:36 <dolio> Which is different from the Turing machine choice, which is more like, 'all lambda terms that when applied to the Church encoding of the Goedel encoding of a lambda term that can be given type ‚Ñï ‚Üí ‚Ñï, produce an encoding of a ‚Ñï'.
15:51:21 <slack1256> I want to confirm this, the haskell alternatives to the JS library `Rx` are the `pipes/machines/streaming/conduit' libraries, right?
15:52:02 <slack1256> I thought that I could replace `Rx Observables` with `STM's TChan` but that isn't right.
15:55:10 <dolio> boxscape: Yeah, certain higher order functionals are (semi)decidable in one and not the other.
15:55:18 <boxscape> hm, I see
15:58:24 <dolio> Like, walking back, `all : ((Bool -> Bool) -> Bool) -> Bool`. In the 'natural' lambda version, Bool is finite, so it's easy to enumerate all the Bool -> Bool functions and see if the functional accepts all of them.
16:01:57 <dolio> But for the Turing machine version, you're suddenly talking about a machine that is allowed to inspect the source code of the Bool -> Bool function, and may do different things based on different source code for the same function.
16:02:11 <boxscape> right, that makes sense
16:02:14 <dolio> So now you're trying to decide things about infinite sets.
16:04:51 <dolio> You can probably make the Turing version better behaved, but it might still be able to do different things than the lambda version.
16:05:23 <dolio> Because it can do things like race two 'functions'.
16:11:52 <younder> Are you for real. You can't decide things about infinate sets by computation. You need to look at the series and then solve the recurrence relation. Z transforms etc.
16:12:55 <younder> You might get locky and derive on a divergent series, then you have to proove it's divergent
16:16:17 <younder> A turing machine is just a crude form of lamda calculus. It has no more computational power. And for deterening if it is haltable or notit is easier to see fron the invariant in a recurrence relation
16:54:24 <ski> @where impossible
16:54:24 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
16:58:49 * hackage mssql-simple 0.6.0.1 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.6.0.1 (tkmsm)
17:08:39 <monochrom> We are for real.
17:09:09 <monochrom> Some infinite sets are more decidable than others.
17:10:57 <int-e> @where real
17:10:57 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
17:11:08 <int-e> (made me laugh)
17:11:49 <int-e> Haskell, the configuration language for xmonad.
17:14:46 <monochrom> hahaha, like https://www.amazon.com/OReily-XMonad-Book/dp/0596514980/
17:15:12 <wavemode_> Haskell is used for other things? News to me.
17:15:29 <monochrom> I heard Haskell is used for pandoc.
17:15:48 <javran> I heard Haskell is used for compiling GHC
17:16:12 <monochrom> I heard Haskell is used for testing Hugs. :)
17:16:42 <monochrom> Every implemented language is used for testing its implementations. :)
17:30:48 * hackage calamity 0.1.14.7 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.14.7 (nitros12)
17:31:37 <lexi-lambda> aenesidemus: FWIW I know the name (:<) sucks, and I know it‚Äôs not currently documented. I plan to change it before the library is released, but I haven‚Äôt decided yet on a naming scheme for it and related operations, so it‚Äôs cryptic. Sorry.
17:36:03 <aenesidemus> lexi-lambda, no worries. I'm not a regular Haskell user, I just check up every few months to see how the effect story is. I'd never seen a Constraint kind before so I was confused. Thanks for your work!
19:14:58 <freeman42x[m]> how come `cabal repl` does not also import all the modules in the loaded file?
19:15:10 <glguy> lexi-lambda: Have you seen any progress on getting the new primitives into GHC?
19:16:37 <Cale> freeman42x[m]: In some cases, that would just result in lots of name overlap
19:16:43 <lexi-lambda> glguy: No, I still need to follow up on the proposal. I‚Äôve been delaying because I‚Äôve been trying to get my arrow-related proposal accepted first so I don‚Äôt have to worry about both at once, but that might be a lost cause.
19:16:57 <Cale> freeman42x[m]: Like, what if you're working on containers for example?
19:17:17 <Cale> Do you really want all those fromList functions imported unqualified?
19:17:49 <freeman42x[m]> | freeman42x: In some cases, that would just result in lots of name overlap
19:17:49 <freeman42x[m]> why would it result in overlap if the file builds fine?
19:18:20 <Cale> You want to bring all the contents of the modules in the project into scope unqualified?
19:18:31 <Cale> Or should it import everything qualified?
19:18:42 <Cale> (that could also be kind of unhelpful)
19:19:03 <freeman42x[m]> Cale: I want to bring whatever was imported in the file, the way it was imported in the file into the repl
19:19:28 <Cale> In which file?
19:19:37 <freeman42x[m]> If in the file it was imported qualified, then it should be imported qualified in the repl, etc.
19:20:47 <freeman42x[m]> | In which file?
19:20:47 <freeman42x[m]> Whichever the REPL loaded?
19:21:39 <Cale> It already does?
19:22:15 <Cale> Unless it loaded the code from a .o/.hi file, in which case it may not have access to anything which wasn't exported
19:24:30 <freeman42x[m]> Cale: I am using `Atom REPL` extension. It uses cabal REPL underneath to load the file opened while you launch the REPL. And it does not load anything except the module defined in that file.
19:26:22 <Cale> I'm just using cabal repl
19:26:31 <Cale> No idea about Atom's stuff
19:28:35 <Cale> I'm using GHC 8.6.5 here and it's definitely working. Which GHC is it that you're using?
19:28:48 <Cale> Also, what does your GHCi prompt say?
19:29:29 <freeman42x[m]> The Glorious Glasgow Haskell Compilation System, version 8.8.2 . Prompt only displays the name of  the 1 loaded module
19:30:20 <Cale> okay, one sec, I'll change my nix shell to try that one :)
19:30:48 <freeman42x[m]> I have to ask this before I forget: where has the max exodus from this channel go to? did people quit Haskell? did they move to superior communication systems? alien abductions of Haskell users cause of their high photosynthesis?
19:31:17 <freeman42x[m]> Cale: using Nix, ah, another man of culture
19:31:38 <Cale> I suspect it's just that there are too many chats now
19:32:14 <glguy> The biggest cause of loss of people was a couple years ago when someone took over an op account and mass kicked the channel
19:32:21 <freeman42x[m]> I suspect people moved to some other channel(s). But which ones? FP Slack? Discord? Riot? those are the most likely
19:32:22 <glguy> a bunch of lurkers didn't rejoin
19:32:29 <Cale> all of them
19:32:31 <glguy> We've been pretty stable since then
19:33:01 <freeman42x[m]> Cale: lol? I am asking to which they mostly moved to, they certainly did not evenly distribute
19:34:30 <Cale> I doubt anyone can tell -- there's a lot of overlap
19:34:59 <freeman42x[m]> Cale: give me some time and I will be able to tell since I am using all of them
19:38:13 <freeman42x[m]> ok, I can tell for certain they did not move to FP Slack, barely any messages today
19:40:28 <freeman42x[m]> 0 messages last 2 days on Riot Haskell
19:40:43 <freeman42x[m]> I am getting worried. Where could they have gone?!
19:41:02 <freeman42x[m]> Is Haskell dying? Or did it become so good that it hardly has any bugs these days?
19:42:32 <freeman42x[m]> and they are not on any Discord I know of. I created this Discord exactly cause there was no good Haskell Discord: https://discord.gg/rfvNXmE
19:47:09 * freeman42x[m] uploaded an image: image.png (168KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/kVFSMlBNGHTvohTHewmvQuVj >
19:47:19 <freeman42x[m]> what am I doing wrong here?
19:49:07 <no-n> there is a 'functional programming' discord
19:49:23 <freeman42x[m]> oh nice! got a link?
19:49:31 <no-n> sec
19:50:23 <ja> there are also a couple of slacks, and a zulip
19:50:30 <no-n> wow, thanks firefox for not remembering my discord password, rip
19:50:50 <no-n> it's probably on my tablet hold on
19:51:42 <justsomeguy> This one? https://top.gg/servers/280033776820813825
19:52:19 * hackage hspec-need-env 0.1.0.5 - Read environment variables for hspec tests  https://hackage.haskell.org/package/hspec-need-env-0.1.0.5 (debugito)
19:55:20 <no-n> I thnk so yes
19:55:21 <freeman42x[m]> | there are also a couple of slacks, and a zulip
19:55:21 <freeman42x[m]> I am sure there are on almost any platform. But did most users migrate to that?
19:56:40 <justsomeguy> I get the impression that this irc channel and the fp discord that was just mentioned are the most active, just from lurking in a bunch of places.
19:56:40 <no-n> how many went away?
19:56:43 <ja> i never heard about this mass exodus before, so i don't know. where can i read more about it? 
19:58:07 <freeman42x[m]> no-n: ja I have been chatting in this IRC since 2013 and it used to be very active in the past, you would get like a Haskell question every 15 minutes or less and lots of people chatting
19:58:27 <freeman42x[m]> I do not remember when it changed to be so inactive, could be the past half a year? 1 year?
20:00:47 <ja> i can't be the last half year because you can see the logs are roughly the same size
20:00:48 * hackage fold-debounce-conduit 0.2.0.5 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.2.0.5 (debugito)
20:01:42 <freeman42x[m]> ja: check for more than: past 2 years maybe? dunno, I think in 2018 there was still activity
20:01:52 <freeman42x[m]> maybe cause of that mass kick...
20:02:24 <ja> would be kinda weird if people give up on the channel just because they get one spurious kick, no?
20:03:09 <ja> on my friends IRC server, we are all ops and kick each other liberally, it is a great way to communicate (you can put a message after /kick)
20:04:02 <freeman42x[m]> | would be kinda weird if people give up on the channel just because they get one spurious kick, no?
20:04:02 <freeman42x[m]> yeah, most peope are smart enough not to give up that easily
20:04:21 <freeman42x[m]> also, after all of our investigation, it seems there was no mass exodus...
20:05:11 <freeman42x[m]> then what is the expanation as to why this channel became so innactive? is it really aliens kidnapping Haskell developers cause they are lacking them? xD
20:05:37 <ja> maybe you /ignore'd half the channel while drunk
20:06:02 <freeman42x[m]> ja: haha, that would not explain why you guys also notice the lack of activity ;)
20:06:23 <justsomeguy> Could it just be the hype train at work?
20:06:39 <justsomeguy> Hype cycle, rather, I guess.
20:06:39 <freeman42x[m]> justsomeguy: which hype train?
20:07:20 <no-n> if you just want to talk about haskell then you just have to talk about haskell :P
20:08:50 <freeman42x[m]> since no one said anything about that picture I uploaded via Riot and posted here it seems that it did not work
20:09:37 <freeman42x[m]> I run into this issue: https://i.imgur.com/7yJ86dk.png
20:10:01 <ja> freeman42x[m]: the image url did get posted. it is 168kb
20:10:01 <freeman42x[m]> following this: https://stackoverflow.com/a/49594115/750216
20:11:03 <freeman42x[m]> I thought at least some of he chatters did not see the image since  there was no reply. Not even a: `use text paste instead images you pleb `replies
20:11:43 <ja> it is not worth it trying to communicate with people who surrender glorious IRC to matrix ;)
20:12:24 <no-n> freeman42x[m]: idk, I've never learned lenses yet
20:12:36 <freeman42x[m]> what about using https://www.irccloud.com/ ?
20:12:38 <no-n> I went away from Haskell for several years and have recently come back to it
20:13:10 <ja> freeman42x[m]: irccloud doesn't autogenerate urls and doesn't put some suffix on your nick, so i guess people will never know if you use it?
20:13:17 <freeman42x[m]> no-n: extrapolating from 1 sample: this channel is full of beginners and all the pros left it xD
20:13:28 <justsomeguy> I'm too much of a noob to offer advice... not even sure what a lens is. Or where (^.) comes from, or what your code is supposed to do.
20:13:33 <no-n> there are still pros here that I can see
20:13:51 <no-n> but it's not 100% active 100% of the time
20:14:24 <freeman42x[m]> 100% active 100% of the time and free is the main reason I use it
20:15:25 <ja> i guess people are on irc for different reasons? activity just for the sake of it is not desirable
20:15:27 <no-n> maybe everyone got so good they don't need to talk about it anymore, and have haskell jobs anyway
20:16:37 <ja> i don't understand how you can even be so convinced that people are gone. how can you trust your own metrics of how popular an irc channel was 7 years ago? starting to sound like "the ice cream was much sweeter when i was a boy"
20:17:38 <ja> talk to that freenode bot, join all the channels, join all the slack, read all the history, read all the books, is there not enough to do? why do you need activity just for the sake of it?
20:18:08 <freeman42x[m]> | i guess people are on irc for different reasons? activity just for the sake of it is not desirable
20:18:09 <freeman42x[m]> I never claimed that activity for the sake of it is good. Actually doing anything just for the sake of it is not good
20:18:28 <freeman42x[m]> | maybe everyone got so good they don't need to talk about it anymore, and have haskell jobs anyway
20:18:28 <freeman42x[m]> Haha, that is what I was saying also xD
20:19:33 <freeman42x[m]> @ja | i don't understand how you can even be so convinced that people are gone. 
20:19:33 <lambdabot> Sorry, look up one word at a time please.
20:19:33 <freeman42x[m]> I am not convinced, it was a hypothesis I was testing. My observation is that people are no longer chatting much, not that they are not reading the messages
20:20:58 <freeman42x[m]> | how can you trust your own metrics of how popular an irc channel was 7 years ago?
20:20:59 <freeman42x[m]> @ja I remember very well how active this channel was, and it was up to 7 years ago, not only 7 years ago. Are you trying to argue with me on purpose? Not in the mood...
20:20:59 <lambdabot> Sorry, look up one word at a time please.
20:21:33 <freeman42x[m]> why does lamdabot say this?! "Sorry, look up one word at a time please." which part triggers it?
20:21:47 <dolio> The @ symbol.
20:22:04 <freeman42x[m]> @ja "why do you need activity just for the sake of it?" I do not. Jesus christ üòÜ so much straw men you pulled
20:22:04 <lambdabot> Sorry, look up one word at a time please.
20:22:15 <freeman42x[m]> oh, it is the @ isn't it
20:22:26 <freeman42x[m]> @putStrLn
20:22:26 <lambdabot> Unknown command, try @list
20:22:31 <freeman42x[m]> @list
20:22:31 <lambdabot> What module?  Try @listmodules for some ideas.
20:22:37 <freeman42x[m]> @listmodules
20:22:37 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
20:22:37 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
20:22:53 <freeman42x[m]> @help
20:22:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:24:57 <SureYeaah> How is this memoized? 
20:24:57 <SureYeaah> ```
20:24:58 <SureYeaah> memoized_fib :: Int -> Integer
20:24:58 <SureYeaah> memoized_fib = (map fib [0 ..] !!)
20:24:58 <SureYeaah>    where fib 0 = 0
20:24:58 <SureYeaah>          fib 1 = 1
20:24:58 <SureYeaah>          fib n = memoized_fib (n-2) + memoized_fib (n-1)
20:28:04 <int-e> tragic, it was almost done
20:28:19 --- mode: ChanServ set +o ski
20:28:47 --- mode: ChanServ set -o ski
20:29:45 <kiwi_37> I got killed from freenode because of sigyn?
20:29:48 <ski> yes
20:30:11 <ski> presumably because you pasted many lines of text, in a single go
20:30:34 <ski> (i removed the K-line)
20:31:33 <ski> wb
20:32:10 <SureYeaah> Okay thanks!
20:32:12 <ski> SureYeaah : it builds an infinite list of the fibonacci numbers, which it indexes into (linear time)
20:32:50 <int-e> SureYeaah: it's memoized because the `map fib [0 ..]` will only be evaluated once during the lifetime of the program.
20:33:08 <int-e> so that list is where the intermediate values end up being cached
20:33:59 <SureYeaah> Right and how does ghc do that? How do you know what will be cached across different function calls?
20:34:32 <ski> `memoized_fib' is defined with no explicit parameters to the left of `=' (and it's not type class overloaded)
20:34:56 <ski> and `map fib [0 ..]' doesn't occur inside a lambda
20:35:21 <ski> `(map fib [0 ..] !!)' here is the same as `(!!) (map fib [0 ..])' ..
20:35:34 <SureYeaah> ski: aaha. TIL. Is there some place I could read more about this?
20:35:48 <ja> will GHC memoize the actual ints, or the 'thunks'? if value 10 is requested before value 9, will value 9 remain a thunk before value 10 is computed?
20:36:09 <ski> .. iirc, the report specifies it should be `\i -> map fib [0 ..] !! i' (`i' a fresh identifier) ? .. if that was the case, then (at least na√Øvely) it would not be memoized
20:36:16 <int-e> ja: no, because evaluating value 10 will request value 9
20:36:46 <int-e> ja: but more generally, yes, this kind of evaluation can leave holes in the form of thunks in the list.
20:37:04 <int-e> say if you had f 0 = 0, f 1 = 1 and f n = f (n-2) instead.
20:37:07 <ja> ah, perfect, thanks. yeah i was referring to the general memoization style, not just in the application with fib
20:38:05 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
20:38:07 <lambdabot>  Defined.
20:38:40 <freeman42x[m]> I can't believe that I am getting a project to build with stack just to be able to more easily get contributors or help with issues üôÉ
20:39:36 <ski> > let ((!) . L.tabulate (0,12) -> fib) = \case 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fib 12
20:39:39 <lambdabot>  144
20:40:44 <int-e> memoize f = lookup (tabulate f) -- still my favorite vocabulary for this
20:40:59 <ski> > let fib = ((!) . L.tabulate (0,12)) $ \case 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fib 12
20:41:01 <lambdabot>  144
20:41:49 <ski> > let fib = (arr !) where arr = L.tabulate (0,12) $ \case 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fib 12
20:41:51 <lambdabot>  144
20:42:27 <ski> SureYeaah : does those example variants make sense ?
20:43:09 <ski> > let arr = L.tabulate (0,12) $ \case 0 -> 0; 1 -> 1; n -> arr ! (n-2) + arr ! (n-1) in arr ! 12
20:43:11 <lambdabot>  144
20:43:12 <ski> > let arr = L.tabulate (0,12) $ \case 0 -> 0; 1 -> 1; n -> arr ! (n-2) + arr ! (n-1) in arr
20:43:15 <lambdabot>  array (0,12) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34)...
20:43:23 <ja> what is the motivation for the variants?
20:43:50 <ski> > let arr = listArray (0,12) [case n of 0 -> 0; 1 -> 1; _ -> arr ! (n-2) + arr ! (n-1) | n <- [0 .. 12]] in arr ! 12
20:43:53 <lambdabot>  144
20:44:15 <ski> ja : to be able to see more and less abstracted versions of the same idea
20:46:40 <ski> in the last few versions, it's clear that we're defining an array, recursively, so that (most) elements of it are defined in terms of indexing to other elements
20:47:11 <ja> ok. why write L.tabulate and not just 'tabulate'?
20:47:17 <ski> @type tabulate
20:47:18 <lambdabot> error:
20:47:18 <lambdabot>     Ambiguous occurrence ‚Äòtabulate‚Äô
20:47:18 <lambdabot>     It could refer to
20:47:31 <ski> @type Test.QuickCheck.Property.Testable.tabulate
20:47:33 <lambdabot> error:
20:47:33 <lambdabot>     Not in scope: ‚ÄòTest.QuickCheck.Property.Testable.tabulate‚Äô
20:47:33 <lambdabot>     No module named ‚ÄòTest.QuickCheck.Property.Testable‚Äô is imported.
20:47:37 <ski> bah
20:47:54 <ja> but it was defined above? the L is a reference to the scope of this channel?
20:47:56 <ski> @type Test.QuickCheck.Property.tabulate
20:47:58 <lambdabot> Test.QuickCheck.Property.Testable prop => String -> [String] -> prop -> Test.QuickCheck.Property.Property
20:48:02 <ski> @type L.tabulate
20:48:03 <lambdabot> Ix i => (i, i) -> (i -> e) -> Array i e
20:48:18 <ski> `L' is the module in which things you define with `@let' are put
20:49:41 <ski> @type Data.Array.lookup
20:49:42 <lambdabot> error:
20:49:42 <lambdabot>     Not in scope: ‚ÄòData.Array.lookup‚Äô
20:49:42 <lambdabot>     Perhaps you meant ‚ÄòData.Map.lookup‚Äô (imported from Data.Map)
20:49:48 * hackage base64 0.4.2.1 - Fast RFC 4648-compliant Base64 encoding  https://hackage.haskell.org/package/base64-0.4.2.1 (topos)
20:56:56 <ja> ski: i can't even find that function in https://www.haskell.org/onlinereport/haskell2010/haskellch14.html what gives? :O
20:57:59 <ski> which function ?
20:58:12 <ja> Data.Array.lookup
20:58:18 <ski> because it doesn't exist
20:58:20 <ski> @type (Data.Array.!)
20:58:22 <lambdabot> Ix i => Array i e -> i -> e
20:58:22 <ski> exists
20:58:32 <ski> which is what int-e was referring to
20:58:43 <ski> <int-e> memoize f = lookup (tabulate f) -- still my favorite vocabulary for this
20:58:48 <topos> > Data.ByteString.Base64.decode "ZE=="
20:58:49 <topos> damn
20:58:50 <lambdabot>  error:
20:58:51 <lambdabot>      Not in scope: ‚ÄòData.ByteString.Base64.decode‚Äô
20:58:51 <lambdabot>      No module named ‚ÄòData.ByteString.Base64‚Äô is imported.
20:58:55 <topos> ahahaaa
20:59:12 <ski> @type \ix -> (Data.Array.!) . L.tabulate ix
20:59:13 <lambdabot> Ix i => (i, i) -> (i -> e) -> i -> e
20:59:57 <ja> when should i use Data.Array, and when should i use Vector?
21:00:10 <ski> @let memoArray :: Ix i => (i -> e) -> (i -> e); memoArray ix f = (L.tabulate ix f !)
21:00:12 <lambdabot>  .L.hs:173:30: error:
21:00:12 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò(i0, i0)‚Äô with actual type ‚Äòi -> e‚Äô
21:00:12 <lambdabot>      ‚Ä¢ Probable cause: ‚Äòix‚Äô is applied to too few arguments
21:00:26 <ski> @let memoArray :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArray ix f = (L.tabulate ix f !)
21:00:29 <lambdabot>  Defined.
21:01:23 <ski> `Data.Array' is a bit older, and is a bit more general (you can have multiple-dimensions, and indices don't have to start at `0', doesn't even have to be integers)
21:01:42 <ski> vectors have more fusion stuff defined for them, i think
21:02:04 <ja> hmm sounds like it is a pretty minor difference
21:02:29 <ski> iirc, if you make slices of a vector, it doesn't copy ?
21:02:39 <ja> funny that the less-general version is the one outside base...
21:03:13 <ja> oh, so vector is CoW?
21:03:40 <ski> if you want to update an `Array', it'll copy, as well
21:03:46 <ski> @type (//)
21:03:48 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
21:04:06 <ski> (both are immutable)
21:04:47 <freeman42x[m]> if anyone wants to investigate that lens error with me: https://github.com/fairy-tale-agi-solutions/Everything-Manager/blob/master/Everything.hs#L58 also twitch streaming at: http://twitch.tv/freeman42x
21:05:10 <ski> (`vector' also includes `MVector', which is mutable)
21:05:14 <freeman42x[m]> I even got the project to build with stack, god that was difficult
21:08:19 * hackage cryptonite 0.27 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.27 (VincentHanquez)
21:10:36 <ja> i think i should probably migrate my mutation heavy code-base from lists to MVector...  which necesitates learning PrimMonad and ST, i guess
21:11:05 <freeman42x[m]> I was missing deriving generic hahaha
21:21:59 <SureYeaah> ski: yeah they make sense. Especially the arr example. Thanks!
21:25:12 <ski> ja : `PrimMonad' is basically to overload over `ST s' vs. `IO', and tranformers on top of those. `ST s' is basically just like a version of `IO', only including `IORef' and `IOArray' (so, `STRef s' and `STArray s'), similar things, and stuff built on that. `runST' may take a little time to grok, though, why it's safe
21:25:26 <ski> `Data.Vector.Mutable' has the mutable operations you need
21:32:45 <joelg> I think of runST as allowing some imperative mutable computations, then freezing the resulting data structures and returning immutable copies of them - intuitively that seems safe
21:35:41 <ja> hehe i am not too concerned about safety, my code is full of c-bindings with unsafePerformIO. but i wonder if i have to let go of the lens style of updating maps and arrays. 
21:36:35 <ja> i mean, lens assumes copying, right? maybe not necessarily with linear haskell?
21:40:19 <ski> joelg : freezing doesn't need to be involved, but is one usecase
21:51:24 <ja> hmm there is https://github.com/infinity0/hs-mutable-lens
21:51:54 <ja> the readme sounds intruiging! using the lens api for everything!
21:52:09 * ski . o O ( <https://www.reddit.com/r/haskell/comments/5v33qk/forall_a_ioref_a_lens_a_b_is_a_useful_type_does/> )
21:52:27 <ja> @package mutable-lens
21:52:27 <lambdabot> https://hackage.haskell.org/package/mutable-lens
21:54:51 <ski> mm, was glancing at that, just before
22:15:49 * hackage greskell-core 0.1.3.5 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.3.5 (debugito)
22:17:18 * hackage greskell 1.1.0.3 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.1.0.3 (debugito)
22:18:48 * hackage commander-cli 0.6.2.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.6.2.0 (sgschlesinger)
22:19:48 * hackage greskell-websocket 0.1.2.4 - Haskell client for Gremlin Server using WebSocket serializer  https://hackage.haskell.org/package/greskell-websocket-0.1.2.4 (debugito)
22:28:50 * hackage wild-bind 0.1.2.6 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.2.6 (debugito)
22:29:48 * hackage wild-bind-x11 0.2.0.10 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.2.0.10 (debugito)
22:37:07 <myridium> Hello. I'm trying to get 'intero' working in Microsoft Visual Studio Code. However, when I try to install intero (1.4.0) it tells me that my ghc version is too new to be compatible. How do I solve this problem on Arch? Do I set up an older haskell version outside of pacman and set that to be first on PATH or...? I don't know the proper way to solve this.
22:41:41 <c_wraith> myridium: https://www.reddit.com/r/haskell/comments/dr91dv/the_intero_project_has_reached_its_end_of_life/
22:42:04 <myridium> Oh... alright then.
22:43:07 <c_wraith> I don't know what the best path forward is.  That's just why it's not getting updated for new versions of ghc
22:45:42 <joelg> myridium: I have HLS (haskell language server) working for my VSCode and it wasn't too much trouble.
23:09:48 * hackage net-spider 0.4.3.4 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.3.4 (debugito)
23:10:48 * hackage net-spider-cli 0.2.0.4 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.2.0.4 (debugito)
23:11:48 * hackage net-spider-rpl 0.4.1.3 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.1.3 (debugito)
23:12:48 * hackage net-spider-rpl-cli 0.1.3.2 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.3.2 (debugito)
23:26:24 <sgs29> trying to write "swallow :: a #-> (forall b. Void #-> b)" on a recent GHC commit with linear types (hash fa4281d672e462b8421098b3506bd3c4c6a1f819) and I am getting a type error. Is this aspect of the Tweag implementation that hasn't been implemented yet? Read about it in their exceptions article.
23:35:18 * hackage commander-cli 0.7.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.7.0.0 (sgschlesinger)
23:57:46 <MarcelineVQ> wonder how you'd write that function anyway
