00:24:57 <hololeap> Axman6: did you mean to do `BS8.unpack` in your example?
00:25:19 <hololeap> BS8.unpack <$> BS.getLine
00:33:07 <yushyin> and did you mean readLn not readline??
00:33:13 <yushyin> -?
00:34:00 <Axman6> hololeap: I was just showing how you would use Read with a (possibly hypothetical) bytestring version of getLine
00:34:28 <Axman6> get a bytestring from stdin, unpack it into a String, read it using read
00:35:12 <Axman6> read only works on Strings, so the bytestring would need to be unpacked
00:35:48 <hololeap> i was more curious about the composition of a BS8 function after a BS function
00:35:54 <hololeap> is that possible?
00:38:54 <Digit> [reminder to self, add timed notifications/reminders feature to my haskell bot [fatherjackbot].   (there, i've said it in #haskell now, so i have to do it.)]
00:42:28 <EvanR> ah yes the nirvana of treating Word8 as a Char
00:48:16 <EvanR> or having bytes be 32 bits
00:55:56 <hololeap> i'm just going to use utf8-string
00:57:03 <frobnicator> is it possible to use the tuple constructor infix? `(,)` is not working
00:59:23 <tdammers> hololeap: possible: yes, of course. a good idea: probably not.
00:59:39 <hololeap> frobnicator: there's the TupleSections extension, where you can do something like (a,) or (,b)
00:59:50 <tdammers> hololeap: BS8.ByteString and BS.ByteString are the same data type, a sequence of bytes; the "String" part is a misnomer
01:00:35 <dmwit> frobnicator: No, only mixfix: (a,b)
01:00:57 <dminuoso> % let tuple = (,) in 1 `tuple` 'c'
01:00:58 <yahb> dminuoso: (1,'c')
01:01:09 <tdammers> hololeap: the Char8 module provides "string" manipulation functions for the ByteString type that are based on the (usually incorrect) assumption that one byte equals one character
01:01:21 <frobnicator> thanks
01:01:53 <tdammers> hololeap: if you want to perform actual string manipulation, the sane way to do it is to convert the byte sequence into a string data type (like Text), manipulate, and then convert back to ByteString
01:02:28 <hololeap> tdammers: i'm just using utf8-bytestring for encoding and also `lines`
01:03:01 <hololeap> not going to go through the effort of using only base
01:03:48 <tdammers> hololeap: that's fine. just saying that if you need to do actual string manipulation, doing it on bytestrings is asking for pain
01:04:56 <jusss> in haskell, Maybe :: a -> Maybe a, but in other OO languages, that class couldn't do this, what's the unique here?
01:05:18 <dminuoso> jusss: Did you mean `Just :: a -> Maybe a`?
01:05:46 <dminuoso> The only specialty is polymorphism, but plenty OO languages - including Java or C++, can do this.
01:06:01 <jusss> dminuoso: right
01:06:52 <jusss> dminuoso: I tried to implement that Fix f type in kotlin, and Fix Maybe can't be implement
01:07:00 <dminuoso> Another important bit, is that the ease of pattern matching on ADTs is strangely rare. So the act of `case f of Just x -> ...; Nothing -> ...;` is not well supported in many languages.
01:08:08 <jusss> dminuoso: make Maybe as a class with a parameter, Just and Nothing is another class inherit it
01:08:35 <tdammers> jusss: you can't pattern match though
01:08:37 <jusss> dminuoso: but Fix <Maybe> couldn't exist, because Maybe need a A
01:08:49 <jusss> Fix<Maybe<A>> is ok
01:09:05 <jusss> but in haskell, we have Fix Maybe, not Fix (Maybe a)
01:09:11 <dminuoso> tdammers: Sure you can. The visitor pattern is the workaround that Java or C++ doesnt have pattern matching.
01:09:22 <dminuoso> (That revelation was really interesting)
01:10:24 <jusss> sealed class Maybe<A>; data class Just<A>(val x:A): Maybe<A>();  data class Nothing: Maybe<Any>()
01:11:43 <jusss> sealed class Fix<F>; data class MkFix<F:Fix<F>>(val x:F): Fix<F>(); 
01:12:15 <jusss> there couldn't be an object has Fix<Maybe>
01:12:22 <jusss> it Fix<Maybe<A>>
01:12:38 <dminuoso> jusss: Most type systems are fairly limited in expressiveness.
01:12:45 <jusss> but we could have Fix Maybe in haskell, that's where I don't know
01:13:16 <jusss> dminuoso: did their type systems have a name? 
01:13:24 <jusss> in lambda cube?
01:13:45 <dminuoso> The lambda cube is not about such features.
01:14:32 <dmwit> `val x:F` doesn't look right. I don't know if it's possible, but if it is, it should probably be something like `val x:F<Fix<F>>`.
01:14:46 <jusss> dminuoso: so I wonder how they implement Fix type in their type system
01:15:03 <dminuoso> Who is "they"?
01:15:03 <dmwit> But I wouldn't be surprised if there was no higher-kinded polymorphism.
01:15:32 <jusss> dminuoso: Kotlin, Java, other static type languages
01:15:38 <dminuoso> jusss: I reckon they cant.
01:16:00 <jusss> dmwit: they seem implement higer-kind with class
01:16:44 <jusss> dminuoso: aha, I thought that fix type is common stuff in static langauges
01:16:50 <dminuoso> No it's not.
01:17:13 <jusss> dminuoso: fix combinator is a common stuff on value level, even python can have that
01:17:28 <jusss> fix and const
01:17:33 <dminuoso> Even at the value level it's uncommon. The only reason you see it frequently in Haskell is because we use recursion everywhere.
01:18:07 <jusss> dminuoso: fix2 = lambda f: lambda x: f(fix2(f))(x)
01:18:15 <jusss> const = lambda x, _: x
01:18:35 <dminuoso> jusss: That is arguably useless in Python.
01:18:41 <jusss> reverse__ = lambda f: lambda l: [] if l == [] else f(l[1:]) + [l[0]]
01:18:48 <jusss> print(fix2(reverse__)([3,9,2]))
01:18:52 <frobnicator> is there a way to get the binding strength and fixity from within ghci?
01:18:53 <dminuoso> The reason is that Python has call-by-value semantics.
01:18:57 <dmwit> frobnicator: :i
01:18:58 <dminuoso> frobnicator: Use :i
01:19:06 <frobnicator> thanks!
01:19:08 <jusss> _reverse = partial(const, reverse); print(_reverse(_reverse(reverse))([1,2,3]))
01:19:36 <dminuoso> And that is not even remotely idiomatic, and strictness + the lack of a type system makes such things hard to use.
01:19:42 <jusss> dminuoso: we could do that, with eta-conversion
01:19:58 <jusss> dminuoso: fix f = f (fix f); fix f x = \x -> f (fix f) x
01:20:25 <jusss> fix f x = f (fix f) x
01:20:35 <kenran> Do you know whether it's already (via a hack if need be) to get `ghcide` working in a project with multiple packages?
01:22:05 <jusss> dminuoso: https://paste.ubuntu.com/p/Pvp229T3BB/
01:24:26 <jusss> we could have fix combinator on value level in python, but in type level, I don't know
01:36:07 <jsonfreak> Hi guys, I need to return json, and I was wondering if I should return string or in Haskell I can return type json or something like that?
01:37:08 <dminuoso> jsonfreak: You will need a JSON serialization library, like aeson.
01:39:03 <jsonfreak> I saw Aeson, but I don't know if I use it correctly should I do something like ToJson "{key:value}"
01:39:04 <jsonfreak> ?
01:39:23 <jsonfreak> "{key:value}" being Text type ofc
01:39:39 <dminuoso> No, essentially you'd do something like
01:39:52 <dminuoso> encode (object ["key" .= String "someValue"])
01:47:57 <EvanR> 'string' being a misnomer... in another room people call what we would call Vector a a string of a
01:48:32 <EvanR> whether a is Char or Word8
01:50:35 <jusss> dmwit: they could have class Foo: Fix<Foo>()
01:51:13 <jusss> and data class Fix<F: Fix<F>> (val x: F): Fix<F>() is ok
01:51:37 <jusss> they just couldn't have Fix<Maybe>
03:07:52 <tomsen> Hey, i was gone for over a year, and heard that cabal changed things. Are ghcup+cabal and stack competing solution to the same problem, or are they orthogonal? Is there a preferred way, or should i just go with one of them?
03:08:36 <Rembane> tomsen: I'd say, pick the one you know. 
03:08:54 <merijn> Yes, no, maybe, it depends
03:09:32 <maerwald> There's not much you can't achieve with cabal that you would expect from stack, but the philosophy is still different
03:09:41 <merijn> tomsen: ghcup is a tool for installing GHC + cabal-install. Cabal-install can be installed/used just fine without ghcup too, so that's mostly irrelevant
03:09:57 <merijn> See also: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
03:12:47 <tomsen> I used stack before, but only because i didnt use cabal envs properly and destroyed it. Thanks for the read. I think i'll just try both of them, out of curiosity.
03:13:18 <merijn> tomsen: See also this section: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
03:13:21 <fendor> With tasty, when I run the tests and an expectation fails, the HUnit exception is shown directly instead of any pretty rendering. Do I need some special test runner from tasty?
03:14:34 <maerwald> merijn: your doc doesn't mention one of the major differences, that stack installs GHC for you
03:15:10 <merijn> maerwald: Because that's not a confusion I ever encounter here
03:15:31 <merijn> people know cabal doesn't install GHC and stack does, it's all the rest they keep getting wrong
03:15:37 <maerwald> Weird, that's frequently what people were complaining about cabal =)
03:16:09 <maerwald> That was one of the major "I use stack" arguments
03:16:42 <maerwald> And it outlines its philosophy: batteries included
03:17:15 <merijn> maerwald: It's something people dislike, but it's not what they're confused about
03:17:25 <dminuoso> A tool should be tailored to how you spend most of your time with it. "Batteries included" when installing an additional tool costs you a command or two extras is a really weak argument.
03:17:43 <dminuoso> You install only once, update rarely. But the build process is something you interact with on a minute-to-minute basis.
03:17:43 <merijn> maerwald: "knowing cabal doesn't install ghc" and "liking that fact" are orthogonal
03:18:03 <maerwald> merijn: I find the guide incomplete that way
03:18:17 <merijn> I didn't write it to be complete
03:18:23 <maerwald> especially for beginners who have not been expodes to both tools
03:18:32 <merijn> I wrote it so I didn't have to write the same explanation over and over again on IRC
03:20:15 <maerwald> Sure, I'll add it as a comment then
03:21:54 <lortabac> dminuoso: the main point is not that stack installs GHC, it's that installs a GHC version that is known to work with the chosen stackage snapshot
03:22:45 <dminuoso> lortabac: Sure, but that's a different argument from "batteries included
03:25:11 <fog> in a pure setting, I can use the state encoding to model streaming data
03:25:18 <fog> for example, i can do tail recursion
03:25:42 <fog> in a monadic setting, ListT can be used, for example when a "live" stream of data is provided
03:25:50 <fog> how can these be combined?
03:26:24 <fog> im not sure if what i need is a "transformer" version of the state encoding
03:26:50 <dminuoso> fog: ListT is not about lists really, its rather about non-determinism.
03:27:10 <fog> well, it models streaming data in IO fairly well
03:27:19 <dminuoso> What do you mean?
03:27:40 <fog> um, I had an example before, I'll see if I can find it
03:28:40 <fog> i think i kind of reinvented it
03:28:41 <fog> https://gist.github.com/fog-hs/4a8476d37042baa1810a70f743d495f0
03:31:40 <fog> i was writing things like this;
03:31:41 <fog> https://pastebin.com/raw/cBFmgAJy
03:32:45 <Guest31079> I've just installed stack on WSL (after upgrading it to version 2), now I'm unable to install or build anything with it. The error is Connection Timeout. Does anybody else have the problem?
03:33:23 <fog> seems like you must have a problem with the internet connection
03:33:36 <fog> maybe the firewall is blocking the WSL?
03:34:07 <fog> can you try something to see if the connection works? like curl?
03:34:18 <Guest31079> I'm able to send the same requests using curl and wget, they are successful
03:34:23 <fog> hmm
03:34:47 <fog> what about cabal?
03:35:18 <Guest31079> I'm new to haskell and haven't yet tried cabal
03:35:39 <fog> its good to get to know how to use cabal and stack
03:35:47 <ph88> how can i find out if a function was inlined by ghc ?
03:36:09 <Guest31079> I had a previous project with stack and would like to continue working on it. Are stack and cabal compatible?
03:36:24 <fog> ph88: I think normally the advice is to read the core, which is quite rough
03:36:55 <fog> i think there is some option like -fdump-core or something, and some other options to make it more human readable
03:38:21 <fog> Guest31079: kind of. stack is slightly more hefty, cabal is kind of the lazy way of just getting things to work during development, at least, thats how I use it - and then stack for doing it properly, or even nix
03:39:01 <Guest31079> I see, thanks. I'll try using cabal to see if I can get the project to build
03:39:26 <fog> i mean, during dev, cabal can even be bypassed, by just using .ghci files to get the directory structure to work, but cabal is definitely better than that
03:40:05 <fog> and, for getting libraries "installed" from hackage, cabal is the way to go - stack does things like downloading various versions of ghc, and having all the evironments hyper compartmentalised
03:40:19 <fog> not really the best option for "global installs" of libaries
03:40:29 <fog> which is not favoured, since there can be collisions
03:40:38 <fog> but, for development, its often easier
03:40:42 <justsomeguy> When I run "stack haddoc --open turtle", it opens an html file in my text editor. Where can I adjust the program that haddoc uses to launch html files with?
03:40:47 <fog> then you would use the v1-install option of cabal
03:41:58 <fog> for libs from hackage, not for your own project - kind of depends what your trying to do
03:42:40 <fog> i guess its personal preference - like, not installing your own libraries globally
03:42:52 <fog> they tend to be less stable than the ones from hackage
03:44:10 <fog> dminuoso: does that make sense as to the meaning of ListT for streaming in a monadic context?
03:45:26 <fog> im not sure how to combine that with a state encoding, to get something that can be parametrised over by Identity for use in a pure setting, and with IO for "live" streams
03:46:10 <fog> normally i have (s,s->(a,s)), which can be used to produce values
03:46:24 <fog> i guess i should just have an `m' parameter somewhere in that
03:47:09 <fog> though actually, normally values just arrive as `IO a'
03:47:16 <fog> :t getChar
03:47:17 <lambdabot> IO Char
03:47:37 <fog> and there wouldnt be a "state" 
03:48:07 <fog> it doesnt seem easy to get a version that would work the same way in both a pure and an IO setting
03:49:02 <fog> :t sequence $ map (readFile.show) [1..10]
03:49:03 <lambdabot> IO [String]
03:50:35 <ptrcmd> % sequence $ map (readFile . show) [1..10]
03:50:35 <yahb> ptrcmd: *** Exception: 1: openFile: does not exist (No such file or directory)
03:51:08 <fog> though, I guess that can be turned into a ListT... like IO [String] --> (IO String,IO [String]) --> (IO String,(IO String,IO [String])) etc
03:51:51 <fog> % sequence $ map (return . show) [1..10]
03:51:51 <yahb> fog: ["1","2","3","4","5","6","7","8","9","10"]
03:53:21 <fog> :t ("hello",uncons)
03:53:22 <lambdabot> ([Char], [a] -> Maybe (a, [a]))
03:53:41 <fog> % :t ("hello",uncons @Char)
03:53:41 <yahb> fog: ([Char], [Char] -> Maybe (Char, [Char]))
03:54:08 <fog> thats of the "state encoding" form; (s -> Maybe (a,s))
03:54:16 <fog> thats of the "state encoding" form; (s,s -> Maybe (a,s))
03:55:13 <fog> im not sure if it makes sense to have a monad transformer version of this
03:55:25 <fog> and i never use mtl, so im not really sure what it would be
03:59:13 <fog> basically, i want an API that i can use to do something in a pure context, and then, on deployment to the real world, have it easily transfered to work on streaming live data
04:00:06 <fog> like, in a test setting, i could use [1..] as test data, whereas eg, getting ints pushed from a client in a server setting, this would need to have IO somewhere
04:01:08 <fog> im not sure how i can transfer the processing of streaming, like folds or other tail recursive style things, streaming algorithms
04:01:15 <fog> from a pure to a monadic context
04:01:36 <fog> i could use conduit, but everything I have is written using the state encoding style
04:02:08 <fog> which works fine in a pure setting
04:02:40 <fog> but not in IO
04:03:13 <fog> and the pipes over which conduit is built are strictly more general than i want for my application
04:03:37 <fog> where i want to limit at type level that the "state function" (eg get) does not change
04:05:32 <fog> i have (s,s -> (a,s)), whereas pipes is more like; S a s = (s,s -> (a,S a s))
04:05:52 <typetetris> Can I use `Servant.Auth.Server` without providing `CookieSettings` in the context? I don't want to use cookies, just the JWT-Tokens and the `Authorization: Bearer <token>` stuff?
04:06:01 <fog> where it returns a new function aswell, which i want to prevent
04:15:44 <fog> :t randomRIO
04:15:45 <lambdabot> Random a => (a, a) -> IO a
04:16:24 <fog> % sequence $ replicate 5 (randomRIO (0,1::Double))
04:16:25 <yahb> fog: [4.395502957757602e-2,9.796343799486329e-2,0.8767863497533676,0.8478340211974985,0.9222543311952365]
04:16:48 <fog> % :t sequence $ replicate 5 (randomRIO (0,1::Double))
04:16:48 <yahb> fog: IO [Double]
04:17:03 <fog> thats basically how the data arrives
04:17:39 <fog> its a client side, rather than a server side application, so it doesnt have data "pushed" to it
04:17:47 <fog> it fetches the data actively
04:18:26 <fog> which is kind of the same as every few seconds, generating a random number using randomIO
04:19:51 <fog> which is pretty much the perfect use case for ListT
04:22:22 <fog> but i dont know how to convert code written to work with pure data into working with straming IO data
04:25:12 <fog> whats strange is that even though its pull style data, ie, requested
04:25:29 <fog> the thing that does this requesting emits push style data
04:26:19 <fog> if consuming the list of random numbers emitted one per second, and eg. printing them to stdio
04:26:52 <fog> this printing thing would *consume* the data, whereas the thing emiting the randoms would *produce* it
04:27:36 <fog> which is never really a consideration in a pure setting, where the data is just kind of there to begin with
04:28:23 <fog> % traverse print [1,2,3]
04:28:24 <yahb> fog: 1; 2; 3; [(),(),()]
04:29:36 <fog> i dont know what this would be if it were a ListT instead of []
04:30:17 <fog> does ListT have a Traversable instance?
04:30:21 <higherorder> Hi! Quick q: is there a command to get the path of the binary generated by running `cabal build ...`?
04:31:13 <fog> higherorder: not sure, it kind of ends up deeply nested in the dist directory...
04:31:35 <fog> if you use nix however, it puts them in a convenient place
04:31:52 <higherorder> fog: ah ok, thanks. My use-case is I want to write a script that first runs `cabal build ...`, then does something with the executable that got built
04:32:32 <higherorder> Well it ends up in `./dist-newstyle/build/x86_64-osx/ghc-8.8.3/my-project-0.1.0.0/x/server/noopt/build/server/server`
04:32:38 <higherorder> but I don't want to hard-code that path in the script 
04:32:40 <fog> yeah, if there was such a command it would be good, i remember writing the path by hand, but then just used nix
04:32:49 <higherorder> I use it.
04:33:01 <higherorder> I use nix*
04:33:25 <fog> idk much about how nix and cabal and stack interface with each other
04:34:00 <fog> but the nix kind of reads the cabal file with cabal2nix, so i guess it should work aswell...
04:34:34 <fog> is there any reason you want to use cabal directly instead of nix?
04:35:18 <higherorder> fog: that's how our project is set up; we use nix to set up the environment but cabal directly during development
04:35:23 <higherorder> I am not sure why
04:36:44 <fog> well at the point you start juggling binaries im not sure if it counts as "development" - of just compiling to see if things typecheck
04:36:55 <higherorder> yeah you're right
04:38:16 <fog> i think normally the cabal exes were meant more for running unit tests to ensure everything works on the machine, with hardware or platform specific things in mind
04:39:14 <fog> if you were guilding an exe like a server, you would probably want to use nix anyway to ensure the exe could be deployed to the target OS anyway
04:39:22 <fog> building*
04:39:50 <fog> doing nix copy closure etc
04:40:31 <typetetris> can one use guards in case expressions?
04:41:05 <MarcelineVQ> yep
04:45:44 <higherorder> fog: well here I'm building it for a script that auto-reloads the server when some files change
04:45:47 <higherorder> (roughly speaking)
04:48:03 <fog> ooh, that sounds like hot swapping
04:48:13 <fog> i always wanted to know how to do that
04:48:18 <fog> whats your approach?
04:48:41 <tdammers> the basic solution is to write your server such that it keeps persisting its state to disk, and reload it on startup
04:49:06 <tdammers> and then you have a wrapper that uses something like inotify to watch the relevant files for changes and manages the server itself, typically as a child process
04:49:30 <tdammers> if all mutable server state is in a database, the "persist state" part is trivial
04:50:03 <tdammers> and the wrapper can, in the simplest case, be just a shell script
04:50:28 <tdammers> now, if you want zero-downtime hotswapping, then you need a bit more effort
04:50:43 <tdammers> typically, you would run some sort of reverse proxy in front of your application
04:51:07 <fog> the approach they had at facebook involved object files iirc
04:51:29 <tdammers> and then the "restart" procedure is to first start up the new process, listening on a different port, then signalling the proxy to redirect to the new port, wait until all requests to the old process have been handled, and then kill the old process
04:51:38 <fog> and they could patch these in using some GHC interface with almost no linking time
04:51:57 <tdammers> yeah, you can do a similar thing in-process, basically replacing parts of the running program code in RAM
04:52:29 <tdammers> the principles are the same, but instead of switching to a different process, you adjust some function pointers
04:52:39 <typetetris> MarcelineVQ: thanks
04:52:45 <tdammers> the advantage is that you can do it in a more fine-grained fashion, and that there's no process startup overhead
04:53:12 <tdammers> but it's also massively more complicated and error-prone, so I'd only consider it in situations where process startup overhead is a real concern
04:53:28 <fog> like, just having a function that you might want to modify in a seperate module, and just swapping its object file
04:53:59 <ph88> can i unpack records ?
04:54:34 <fog> well, i guess at fb they want almost no downtime - but it seems like there would be no option than like you say, to basically have both versions of the server running at the same time and just switching the trafick from one to the other 
04:56:41 <fog> i guess what your saying about startup process overhead - they mentioned something about having very large numbers of kuberneties style kernals, and that transfering full exes was bandwidth intensive
04:57:04 <fog> and that the object files were more lightweight for transfer 
04:58:49 <fog> i guess by keeping the linker workload down, they also managed to ballence this with cpu time on the kernals, as opposed to shipping source code and having to do a full compilation stage
05:00:28 <fog> but i guess if your not facebook, and dont have such concerns about kuberneties, its probably easier to just ship a compiled exe and be nifty with how traffic is redirected and closing the previous running instance without having the two running instances overlapping
05:02:10 <fog> i guess the problem with the "database" version, is that the thing being changed might be an actual function implementation
05:02:32 <fog> in which case, trying to read in a haskell function and plumb it into running code seems almost impossible
05:02:46 <fog> you really want to be importing a module at compile time then
05:03:47 <fog> i guess there is the temptation to make everything parametric, on things that can be read in from a file
05:03:52 <dminuoso> fog: Im still not sure about the streams notion.
05:04:16 <fog> but its pretty difficult to ensure that none of the function implementations themselves are ever gong to change
05:04:22 <dminuoso> fog: ListT adds non-determinism as its effect. Not streaming.
05:04:44 <fog> so then it seems like avoiding the parametric style and just going for reimplementing functions almost seems more natural 
05:05:09 <fog> dminuoso: im not sure i follow that assertion
05:05:24 <fog> seems like the perfect thing for streaming IO data
05:06:10 <fog> just basically thinking of regular lists as being pretty well suited for streaming just using tail recursion
05:06:41 <fog> they can produce a "stream" of data just by successively nyaming the head value
05:07:05 <MarcelineVQ> you can just use streamly like everyone else does who wants lists and streaming and non-determinism to come together
05:07:19 <MarcelineVQ> instead of spamming the channel with nonsequiturs
05:07:24 <fog> eh?
05:08:19 <fog> you follow the reasoning behind why pipes, conduit, and "streamly" do not follow the same idiom as pure recursion though right?
05:08:22 <dminuoso> fog: In some sense you can think of it as backtracking.
05:08:30 <dminuoso> ListT gives you non-determinism with backtracking
05:08:43 <dminuoso> The usual problem domain is logic programming
05:09:06 <fog> im not familiar with the term backtracking
05:10:19 <dminuoso> https://hackage.haskell.org/package/logict-0.7.0.2/docs/Control-Monad-Logic.html#t:LogicT
05:10:54 <fog> as far as i can tell, conduit comes with its own painstakingly ported version of prelude. there must be a more direct way to obtain the basic traversable properties of linear datatypes
05:10:59 <dminuoso> This is in some very similar to ListT, but it has fairness and properly adheres to monad laws.
05:11:11 <fog> in a monadic setting, i would have thought ListT to be pretty well suited for this
05:11:15 <dminuoso> And it shifts your focus better into what its really about, because it's not lists.
05:11:21 <fog> dminuoso: thanks
05:11:33 <dminuoso> The list is really just an internal implementation detail. :)
05:12:07 <fog> seems like a list
05:12:54 <fog> whats the idea behind "a backtracking computation" /
05:12:55 <fog> ?
05:13:02 <dminuoso> Are you familiar with say prolog?
05:14:03 <fog> !!
05:14:04 <fog> no
05:14:22 <fog> haskell was my first language back in 2007
05:14:30 <fog> no other language experience wither
05:14:32 <fog> either
05:15:04 <fog> except for maybe matlab
05:16:08 <dminuoso> Backtracking is when you are solving something, make some assumptions but figure out that they didn't lead anywhere, so you backtrack.
05:16:31 <dminuoso> parser combinators often come with backtracking, where `try` lets the parser "backtrack on failure"
05:17:45 <fog> is that something like the shift reset style of "recovering the surrounding computation from a continuation" ?
05:19:06 <fog> hmm, so the `try' kind of "saves" the position, and you can branch from there
05:20:00 <dminuoso> Well that's the backtracking part. You also have non-determinism.
05:20:01 <enikar> rather it is like walking in tree of possible solutions.
05:20:09 <fog> i mean, that sounds pretty useful - and might have even motivated the whole ListT invention - but i stumbled upon it, implementing it without ever having seen it before, motivated just for its streaming utility
05:20:38 <fog> so if its context in the literature is that of backtracking, i dont think that should mean its any less the correct thing for monadic streaming
05:20:44 <dminuoso> fog: Perhaps, an introduction into Prolog might be useful. :)
05:21:18 <fog> sounds like a used car salespitch
05:21:24 <fog> no thanks!
05:21:29 <fog> :/
05:22:15 <dminuoso> I think enikar's description is better.
05:22:28 <fog> anyway, that might help me understand that functional pearl;
05:22:29 <fog> Backtracking, Interleaving, and Terminating Monad Transformers
05:22:45 <dminuoso> You search a potentially infinite tree of possible solutions. Non-determinism is when you branch off with multiple possible solutions.
05:22:49 <fog> but im really not sure that LogicT is what I'm after
05:22:57 <fog> i think ListT IO is
05:23:32 <dminuoso> ListT is just an awkward version of LogicT.
05:23:45 <dminuoso> That doesn't even satisfy monad laws
05:23:56 <fog> possibly its not so awkward if the application is restricted to streaming
05:24:22 <dminuoso> You dont get streaming effect from that. You get non-determinism.
05:24:30 <dminuoso> It's not for constructing data, it's for branching out
05:24:35 <dminuoso> And backtracking 
05:24:40 <dminuoso> Even ListT!
05:24:48 <fog> the paste i linked had some basic version of concat, and split, which is kind of (co)monad like
05:25:04 <enikar> basis of prologue are easy to learn. Few hours are enough to understand the principle.
05:25:28 <fog> https://pastebin.com/raw/cBFmgAJy
05:25:47 <fog> you most certainly *do* get streaming
05:25:59 <fog> i cant understand that contention 
05:27:36 <fog> i was using it to periodically get the contents of a directory that was having data written to it, and to read the data as it arrived, split it into lines, and check for repeated data
05:27:44 <dminuoso> fog: But what you wrote is not ListT.
05:28:15 <fog> data MList_ m a = MCons a (MList m a) | MEmpty ; type MList m a = m (MList_ m a)
05:28:20 <unclechu> hi. i'm messing with embedding git commit hash and build date into the code. i'm using TH to call `git parse-rev HEAD` during the build process.
05:28:34 <fog> its identical to ListT from the wiki page
05:28:41 <dminuoso> fog: And transformers `newtype ListT m a = ListT { runListT :: m [a] }`
05:28:49 <dminuoso> Those are not identical.
05:28:58 <fog> https://wiki.haskell.org/ListT_done_right
05:28:58 <unclechu> but this doesn't work with `cabal sdist` because there's no `.git` inside, is there any way to provide git commit hash into `cabal sdist`?
05:29:02 <higherorder> fog: oh my approach is much dumber than that right now sadly. I just want to restart the server binary, haha
05:29:15 <dminuoso> Ah
05:29:17 <fog> argh! that looks like listT done wrong
05:29:35 <dminuoso> Well "done wrong" is a matter of perspective.
05:29:43 <unclechu> or maybe you're aware of a better way of embedding git commit hash into the code?
05:29:48 <fog> i think you can convert between them
05:29:49 <dminuoso> It's morally right if you dont think of lists having an order.. :P
05:30:08 <fog> the paste had; recoverList :: MList IO a -> IO [a]
05:30:21 <merijn> unclechu: honestly, I'd recommend either "using an external script to build your executable" or "not doing that" 
05:30:41 <unclechu> merijn: second isn't
05:30:48 <unclechu> second isn't an option
05:31:11 <unclechu> but okay, i don't see any other way too
05:31:18 <merijn> Then create an external script that generates the git commit
05:31:43 <merijn> I suppose you could switch to a Custom Setup.hs, but that's kinda heavyweight
05:32:19 * hackage oeis2 1.0.4 - Interface for Online Encyclopedia of Integer Sequences (OEIS).  https://hackage.haskell.org/package/oeis2-1.0.4 (23prime)
05:33:27 <merijn> unclechu: cabal doesn't really support that, because versions uploaded to Hackage must already be unique and immutable, so from Cabal's perspective accessing the package version is all you need (which is probably not good enough for, I guess?)
05:33:47 <fog> higherorder: i think that you can do that using ssh?
05:34:29 <higherorder> fog: what do you mean?
05:34:38 <fog> System.Process has a "shell" function which can allow command line things to be called verbatim 
05:35:04 <fog> so you just ++ the comand you want to run on the remote machine after the ssh call
05:36:04 <fog> ssh -i myKey user@server:port pkillServerBashScript 
05:36:10 <fog> or something
05:36:14 <unclechu> merijn: no, this wouldn't fit, i need both version and git commit hash. it's not for hackage, it's for the debugging of the development builds, version is rarely increased, only for releases
05:36:51 <maerwald> unclechu: use a Makefile to generate a .hs file with version and git commit hash?
05:37:23 <fog> or, if you want, you can comunicate directly with the server to trigger it to close, but i dont know if thats particularly secure, i guess you could do some crypto in your haskell code, but i guess its easier just to use the ssh keys
05:37:48 <unclechu> maerwald: this is more or less the same as "external  script" proposed above
05:37:54 <maerwald> Yes
05:39:17 <maerwald> in fact, cabal has support for autotools style configure scripts
05:39:34 <maerwald> Which could roughly do the same
05:39:38 <fog> and, if you dont mind the slight overhead, this allows you to basically use the ghci repl as if it were the remote machines linux repl
05:40:03 <fog> its awesome for communicating with WSL
05:40:58 <fog> basically then the only thing you ever end up typing into the ubuntu window is the ssh-start-server bash script
05:41:29 <fog> and then, mirroring on again for the nix deployment to the actual remote machine
05:41:53 <fog> it allows you to write all of your deployment tooling in haskell, much better 
05:41:59 <fog> damn makefiles
05:44:26 <unclechu> maerwald: could you please point me where to look about this support of autotools style config scripts by cabal?
05:45:23 <unclechu> anyway, it would work only if those scripts run before `cabal sdist`, because after running `sdist` you have no `.git` anymore.
05:49:45 <maerwald> unclechu: https://www.haskell.org/cabal/users-guide/developing-packages.html#system-dependent-parameters and https://www.haskell.org/cabal/users-guide/developing-packages.html#more-complex-packages
05:50:36 <maerwald> unclechu: there are no pre-sdist hooks atm. It is not possible.
05:52:03 <maerwald> Which is why generating that file and checking it into git + adding it to .cabal is a good idea
06:18:00 <tdammers> personally, I would write this such that it only shows a git commit hash if you're building from a git tree; otherwise, assume that a hackage release or similar release tarball is being built, and only report the version number (which is available from the .cabal file itself)
06:18:13 <tdammers> caveat: parsing the version number out of a cabal file the proper way requires depending on the cabal library, which will make your dependency graph blow up
06:21:13 <ClaudiusMaximus> tdammers, unclechu : Paths_pkgname includes Version https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code
06:26:35 <Boarders> with cpp how do you do the equivalent of max version for a package?
06:28:12 <Boarders> do you just do an empty min version if and then in the else branch?
06:32:21 <Philonous> The other day I asked about a "canonical" list of short names for qualified imports. To get closer to an answer I downloaded hackage, grepped for qualified imports and counted the numbers, here's the 1000 most common ones: https://gist.github.com/Philonous/d1d329c09e00fc921c8a85009d1ab56c
06:32:58 <Philonous> Seems like Data.Text as T is by far the most common one, which makes me sad because I prefer Data.Text as Text :>
06:33:11 <Philonous> Data.Map seems to be split right down the middle between Map and M 
06:35:02 <Philonous> Strangely, Data.Set as Set is more popular than Data.Set as S 
06:36:03 <Philonous> One problem is that this is all instances, I should probably count packages, not individual import lines. Still, interesting as a first approximation
06:36:05 <carbolymer> what was the name for `data Foo where` syntax?
06:36:17 <Philonous> GADT syntax
06:36:24 <carbolymer> thx
06:36:49 * hackage shakebook 0.5.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.5.1.0 (locallycompact)
06:38:48 <int-e> Philonous: wow, how do things like "import Prelude as GHC.Integer.Type" come up?
06:39:51 <int-e> Entries 30-39 are odd. They have the same count as well.
06:40:11 <int-e> Err, excluding 30.
06:40:12 <Philonous> Maybe my regexp borked out there, I'll investigate
06:40:39 <int-e> Still, nice numbers.
06:41:46 <Philonous> Those all seem to be from stripeapi-0.1.0.2
06:42:32 <Philonous> OK, I should _really_ group by package, 549 instances in a single package can very easily skew the numbers
06:42:32 <int-e> Oh.
06:43:52 <Philonous> But they really do have »import qualified Prelude as GHC.Integer.Type«, it's not my script that's borked 
06:43:57 <int-e> Right, Prelude is where you import GHC.Integer.Type.Integer from. So generated code might do such crazy thing.
06:44:00 <int-e> s
06:44:29 <int-e> (And I sincerely hope that's generated code.)
06:45:11 <Philonous> Yeah, 549 files with the same set of weird imports screams generated code 
06:45:26 <int-e> So does the file contents :)
06:45:56 <int-e> parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAccountPeoplePersonRequestBody" (\obj -> (((((((((((((((((((((GHC.Base.pure ... (obj Data.Aeson.Types.FromJSON..:? "verification")), 1557 characters
06:46:09 <int-e> That's just one line out of many :)
06:51:23 <Philonous> I wonder how long it takes to compile that
07:15:23 <Philonous> Here's the list by number of  packages rather than number of imports: https://gist.github.com/Philonous/bc503d3c530ad4e55ab1bfcc5717a7a4
07:16:24 <Philonous> Doesn't change much. Data.Map and Data.ByteString being almost equally Split between one-letter and one-word short names is a bit vexing
07:18:42 <int-e> Philonous: Those results look much better in that all the short names are actually short. :)
07:20:28 <Philonous> I think those numbers are closer to what I'm interested in anyway, since this is immune to issues like how into how many modules a package splits its code (more modules = more imports, presumably) 
07:21:17 <Philonous> So one package doing something weird a million time will only show up as 1, rather than 549 
07:22:48 <int-e> Philonous: those numbers don't match up well ;)
07:23:02 <int-e> Philonous: This is also a fun popularity contest between packages.
07:24:28 <int-e> text, containers, bytestring, vector, base, aeson, ...
07:25:02 <Philonous> We already have reverse dependency counts somewhere, which is presumably more accurate. 
07:25:59 <int-e> But they measure something different. Here we have packages that are so pervasive that people feel the need to abbreviate the imports :)
07:26:43 <Philonous> Right, that's an interesting point
07:26:49 <int-e> Anyway I think it's an interesting metric to consider, even if it's not necessarily useful.
07:28:49 <dolio> People would feel the need to abbreviate imports of everything if they couldn't work unqualified.
07:29:29 <dolio> And most of those provide APIs that overlap other stuff, so you can't work unqualified without hiding a bunch of other stuff.
07:30:06 <int-e> One suspiciously absent package is Control.Lens (it finally appear at number 269)
07:30:48 <dolio> Large parts of lens would be awful to use qualified.
07:30:53 <int-e> So I guess that's something people import unqualified, and then maybe qualify or limit other imports for to work around clashes.
07:31:25 <int-e> Yeah, tons of infix operators.
07:31:31 <dolio> It also doesn't really have an API that overlaps with other stuff.
07:33:55 <merijn> int-e: For me the need to abbreviate imports depends on how often function from the same module occur on the same line and how long imported functions are
07:34:51 <dolio> So, you would actually use `Control.Monad.State.foo`?
07:35:55 <ski> iirc, in OCaml, you can locally open a module with `let open M in ...' or `M.(...)'
07:36:22 <dolio> It's quite convenient in Agda.
07:36:31 <dolio> You can open modules in a where clause.
07:38:38 <merijn> dolio: Who are you asking?
07:39:05 <dolio> You.
07:39:15 <dolio> That's the un-abbreviated, qualified name.
07:40:00 <merijn> dolio: No, that's entirely too long, I abbreviate almost all my imports for exactly that reason :p
07:40:15 * int-e lost context (somebody highlighted me but I'll assume it wasn't important :-P)
07:40:19 <merijn> I propose we just drop Control/Data (or even Control.Monad) from the entire hierarchy
07:40:24 <dolio> Okay. I was going to say...
07:41:00 <merijn> dolio: Often with ByteString you end up composing several things in a row (at least I do) so even "ByteString.foo" is entirely too long, hence abbreviation
07:42:01 <dolio> ByteString is already too long for any qualified use, I'd say.
07:42:18 <dolio> Map I can stand.
07:42:29 <merijn> Although I mostly just do explicit import lists. I try to limit open, unqualified imports to one package per module. So in my commandline parser modules I might import all of optparse unqualified (since I use so many names from it), but qualify the rest/use explicit imports
07:48:15 <maerwald> Explicit is nice if you have tooling that does it for you. Otherwise it just slows me down during coding
07:48:45 <maerwald> So I do that in TypeScript a lot, in haskell never
07:49:52 <merijn> maerwald: I usually start out with just open imports while codig and then gradually limit it as the main structures fall into place
07:50:14 <maerwald> I think it is good practice, but I'm just too lazy
07:50:22 <merijn> So when I'm done I just change my imports to "import Foo ()" and then add anything missing :p
07:50:49 <maerwald> Life is so short. Imagine you die during sorting your imports
07:51:02 <maerwald> Could have been something more meaningful
07:51:16 <merijn> Like fixing breakage due to unlimited imports? ;)
07:51:41 <maerwald> I think that's more paranoia than a frequent practical problem
07:53:40 <maerwald> anyone tried workman for haskell coding? https://workmanlayout.org/
07:54:08 <maerwald> I'm not really worried about the special keys, since I use ergodox keyboard
07:54:26 <maerwald> But those layouts are usually tested against prose text books
07:55:16 <maerwald> and in haskell you have frequent keys like a, b, m, x ,y etc
07:55:32 <merijn> tbh I just use qwerty because I like being able to work on "standard" machines :p
07:57:18 <maerwald> I'm not doing it for fun, but as a post surgery measure. Using ergodox is already quite an improvement, but with qwertz your left hand is extremely overused and the fingers travel a lot
07:58:13 <maerwald> Maybe need to assemble some data about common words and keys in haskell code 
07:58:38 <maerwald> Also easy to switch layout with ergodox
07:58:41 <srk> would be cool to have a Haskell layout, with keys for -> and applicative :D
08:06:20 <maerwald> should be possible with qmk keyboards
08:07:11 <maerwald> https://docs.qmk.fm/#/feature_macros?id=macros
08:08:32 <srk> qmk has one issue
08:08:37 <maerwald> The ergodox configurator is lacking some special keys for macros though :/
08:08:38 <srk> it's not haskell :D
08:08:43 <ja> what would the "applicative" key do? 
08:08:56 <maerwald> <*>
08:09:00 <ja> aah
08:09:02 <srk> one for <$> and the other for <*>
08:09:03 <srk> :)
08:10:02 <ja> to go the full length with optimizing for programming, it would make sense to also switch to a non-text based programming language like lamdu ;) given that its editor already has knowledge of the structure of the program
08:13:49 * hackage reflex-ghci 0.1.4.1 - A GHCi widget library for use in reflex applications  https://hackage.haskell.org/package/reflex-ghci-0.1.4.1 (3noch)
08:39:54 <gentauro> is there some way (deterministisk) to create a list based on an (average) value? For example: `(/ 3) $ sum [20.0, 10.0, 20.0] == 16.666666666666668`. I would like to specify the `16.666666666666668` and the number of elements `3`?
08:43:56 <ph88> gentauro, it could yield a lot of different numbers that average to 16.66
08:44:06 <Chousuke> gentauro: You can repeat the same item 3 times, but if you want to go from 3 and 16.666... to [20.0, 10.0, 20.0] then I don't think there's any generic way to accomplish that.
08:44:21 <ClaudiusMaximus> > sum (replicate 3 16.666666666666668) / 3
08:44:23 <lambdabot>  16.666666666666668
08:44:25 <phadej> :)
08:46:42 <Chousuke> I suppose you could come up with a function that gives you one possible set of numbers for a target average and the number of items, but I'm not sure how that's useful.
08:55:52 <ja> gentauro: did you see https://github.com/i-am-tom/holmes/#%EF%B8%8F-running-functions-forwards-and-backwards
09:01:55 <typetetris> Hmm, a colleague of mine is getting this error on a mac when compiling a simple hello world prog: `Udefined symbols ... ___darwin_check_fd_set_overflow ... _awaitEvent in libHSrts.a(Select.o)` is that a known issue?
09:02:14 <merijn> typetetris: Which version of macOS?
09:02:19 <merijn> typetetris: Which version of GHC?
09:04:09 <typetetris> merijn: ghc 8.10.1, macOs Darwin Kernel 19.5.0 
09:04:37 <merijn> I don't know which version corresponds to which kernel version
09:05:11 <typetetris> merijn: Already asked: Catalina 10.15.5. (Didn't know that too)
09:05:57 <merijn> ok, Catalina is the latest, so possibly something changed. Sounds like it might be a problem of GHC build on an older version linking against (now gone) symbols?
09:06:16 <merijn> (I can't really test since I'm still on Mojave)
09:07:30 <typetetris> merijn: He installed via homebrew, so that could be the issue.
09:08:22 <armin> hello and thanks, typetetris 
09:08:36 <merijn> Try the binary distribution?
09:08:54 <merijn> https://www.haskell.org/ghc/download_ghc_8_10_1.html#macosx_x86_64
09:14:12 <armin> merijn: ty!
09:16:25 <merijn> armin: homebrew updates GHC prematurely (imo) anyway, so I'd recommend just using the bindists
09:16:54 <merijn> (or ghcup, I suppose)
09:21:56 <ja> prematurely, does that mean before important libs are updated/
09:22:16 <ja> or does it mean before the ghc itself has been released?
09:34:03 <maerwald> sm[m] had similar issues recently as well, no?
09:34:56 <maerwald> Afair you have to upgrade XCode?
09:35:16 <maerwald> was an xcode 11.4 bug or so?
09:50:49 <ezzieyguywuf> is there a better way to negate a 1 than (-1)?
09:50:52 <ezzieyguywuf> i.e. without the parens?
09:51:11 <wavemode__> > -1
09:51:13 <lambdabot>  -1
09:53:44 <EvanR> you need parens because of how unary - is parsed. But the extension NegativeLiterals lets you write -1 as is. Not exactly your question
09:54:26 <dsal> :t negate
09:54:28 <lambdabot> Num a => a -> a
09:54:34 <ezzieyguywuf> wavemode__: for example, using V3 from linear, `V3 1 -1 1` is a syntax error
09:55:02 <ezzieyguywuf> is it best to just get used to the parens maybe?
09:55:04 <dsal> Oh, yeah.  Because that's  `(V3 1) - (1 1)`
09:55:10 <EvanR> just use parens
09:56:41 <dsal> ezzieyguywuf: Is that really a syntax error?  It seems valid.
09:57:16 <wavemode__> with NegativeLiterals it's valid
09:57:17 <monochrom> I don't understand why programmers are so averse to parentheses. Apart from hating math.
09:57:49 <ezzieyguywuf> I don't hate math
09:57:51 <ezzieyguywuf> I love it.
09:57:58 <ezzieyguywuf> (I'm also not a programmer. I'm an engineer.)
09:57:59 <monochrom> Right, so I don't understand.
09:58:23 <monochrom> There are programmers who hate math. Those I understand.
09:59:13 <monochrom> Perhaps it's just because the qwerty keyboard sucks at parentheses.
10:00:18 <monochrom> In that case the next interesting question is the correlation between aversion to parentheses and aversion to emacs-style ctrl-this meta-that keybindings :)
10:01:32 <dsal> Yeah, it's definitely not a syntax error:   λ> V3 1 -1 1   -->   V3 0
10:01:59 <monochrom> heh
10:04:52 <dsal> I don't know that this is particularly useful, but it does work.  heh.    λ> V3 7 -9 5  -->  V3 2
10:05:25 <dsal> Huh.  When I turn on NegativeLiterals, it breaks my code.
10:09:49 <ezzieyguywuf> I use dvorak
10:10:06 <ezzieyguywuf> I just think `V3 1 -1 1` looks cleaner than `V3 1 (-1) 1`
10:10:28 <ezzieyguywuf> monochrom: I prefer vim.
10:10:35 <wavemode> then turn on NegativeLiterals
10:14:13 <EvanR> V3 1 -1 1 looks alien to me now
10:14:45 <EvanR> after using haskell a lot and writing various parsers that allow negative signs and subtraction
10:15:11 <EvanR> 1-1, 1 -1, 1 - 1, all same? all different?
10:15:30 <EvanR> space was the worst idea ever
10:16:07 <MarcelineVQ> after using enough . record accessors I'm ambivilent to the - issue
10:16:48 <EvanR> the "power" of the .
10:18:17 <justsomeguy> Some languages have the requirement that you put spaces around (in|mix)fix functions. I think that makes sense, and would make negative numeric literals unambiguous.
10:18:18 <maerwald> ezzieyguywuf: ever tried workman? I read dvorak isn't really that good
10:18:47 <dolio> Haskell doesn't, though.
10:19:13 <dolio> It just has like two exceptions to confuse the issue.
10:19:17 <justsomeguy> Yup. Too bad.
10:19:52 <justsomeguy> Overall it's still a pretty minor blemish on a great language.
10:19:56 <EvanR> expand (a+b)^2.   (a + b) ^ 2
10:20:54 <EvanR> in 3020 we will still be stuck with an ascii grid
10:21:31 <monochrom> The alternative is SML, which makes you write ~1
10:21:55 <dolio> The mixfix convention is not great.
10:21:59 <dmwit> Let's design a language that uses - for record access!
10:22:17 * ski . o O ( "No SML above us, below us only C." )
10:22:56 <dolio> It has a few nice implications, but overall I think Haskell is nicer.
10:23:26 <hololeap> would this be considered bad form: runExceptT >=> either (hPutStrLn stderr) putStrLn $ do ...
10:24:05 <hololeap> having the argument to runExceptT after the whole expression without naming it
10:24:52 <dolio> I guess, the space part, I mean. Mixfix stuff is cool.
10:24:52 <wavemode> do you consider it bad form?
10:25:12 <ski> hololeap : i might use `<=<' instead ?
10:25:20 <hololeap> it seems "cool" which is often times code smell for me :p
10:25:57 <hololeap> ski: good idea
10:26:04 <monochrom> hololeap: Turn on BlockArguments so you can delete that $ too! :)  (I don't know whether it's better or worse.)
10:26:30 <dolio> I don't think you can.
10:26:37 <dolio> Not with an operator in there.
10:26:38 <monochrom> Ah OK, precedence
10:26:46 <monochrom> So just add parentheses!
10:26:48 * justsomeguy puts spaces around his operators, anyways, so it would be natural for him.
10:26:55 <ski> was just about to suggest that, monochrom ;)
10:27:12 * monochrom the parenthesis evangelist
10:28:19 * hackage hvega 0.10.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.10.0.0 (DouglasBurke)
10:28:29 <hololeap> i don't think BlockArguments would make it better. personal preference i guess
10:28:57 * ski . o O ( "Have you heard the good news of our lord and saviour, round bracket ?" )
10:29:19 * hackage aura 3.1.2 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.2 (fosskers)
10:32:13 <dmwit> hololeap: Personally, I think I would consider it bad form, but only because I tend to want my monad-runner and my monad-creator to each be named and distinct.
10:32:25 <dmwit> Not because the syntax is bad form.
10:33:19 * hackage ihaskell-hvega 0.3.1.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.3.1.0 (DouglasBurke)
10:33:20 <dmwit> I dunno. I hold this opinion only lightly.
10:37:18 * hackage cabal-rpm 2.0.5 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.5 (JensPetersen)
10:41:52 <ezzieyguywuf> so I want to capture two mouse positions and calculate the offset. GLFW has a setCursorPosCallback that will call a given function when the mouse moves. How do I store the mouses previous state to use in this callback? What if I only want to perform the calculation when the mouse button is clicked?
10:42:02 <ezzieyguywuf> the first solution that comes to mind is a global variable, but this seems wrong
10:45:44 <dmwit> IORef/MVar/TVar is the standard way. Didn't we have this discussion yesterday?
10:53:17 <hololeap> % :t ()
10:53:17 <yahb> hololeap: ()
10:53:25 <hololeap> % baz = \case { [] -> [] ; ([]:ls) -> baz ls ; ((x:xs):ls) -> x : baz (ls ++ [xs]) }
10:53:25 <yahb> hololeap: 
10:53:35 <hololeap> % baz [["a1","a2","a3"],["b1"],["c1","c2"]]
10:53:35 <yahb> hololeap: ["a1","b1","c1","a2","c2","a3"]
10:54:00 <hololeap> does this function exist in any mainstream library?
10:54:58 <ezzieyguywuf> dmwit: we had _a_ discussion about IORef
10:55:09 <ezzieyguywuf> honestly I can't remember what the discussion was, whoops (sorry y'all)
10:56:02 <dsal> > (concat.transpose)  [["a1","a2","a3"],["b1"],["c1","c2"]] -- hololeap 
10:56:04 <lambdabot>  ["a1","b1","c1","a2","c2","a3"]
10:56:30 <hololeap> oh, cool
10:58:47 <monochrom> ezzieyguywuf: Most of it was atomicity :)
10:59:51 <codedmart> I am drawing a blank on the simplest method to sort an array of maybes having the Justs before the Nothings.
10:59:52 <monochrom> how atomic each IORef operation is, and other alternatives such as TVar
11:01:19 <monochrom> I would first sort by default. This means the Nothing comes first. Then I use span/break to split it at the Nothing->Just transition, swap order.
11:01:30 <monochrom> s/transition/boundary/
11:02:29 <monochrom> On second thought, use sortBy and writing your own comparator.
11:02:32 <MarcelineVQ> that's a good option, I'd be cheeky and write   sortOn (Down . fmap Down)
11:02:36 <monochrom> s/writing/write/
11:02:44 <ezzieyguywuf> monochrom: yea! so it wasn't even mouse stuff yesterday...
11:03:37 <MarcelineVQ> but it's only simple if you know both sortOn and Down
11:03:58 <monochrom> This is why the other day I realized why simple is hard.
11:04:25 <ClaudiusMaximus> ezzieyguywuf: typically you do { ref <- newIORef initialState ; registerCallback (callback ref) ; ... } -- i.e. partially apply the pseudo-global ref to your callback actions
11:04:54 <monochrom> To do simpler you have to be more educated in more options, you have to have deeper understanding.
11:05:06 <ezzieyguywuf> ClaudiusMaximus: ah hah. I think I just need to educate myself a bit on IORef
11:06:13 <ClaudiusMaximus> then in the callback use atomicModifyIORef (if you don't need IO to do the actual update)
11:07:30 <frdg> does the `Alternative` type class refer to being an alternative to monads? If so is the difference disjunction vs conjuctions? I'm thinking in terms of the Maybe monad where if one computation fails the entire thing fails. (opposite to Maybe Alternative)
11:08:23 <frdg> *conjunction 
11:08:38 <monochrom> No, it refers to "foo <|> bar" being two alternatives, foo and bar.
11:08:48 <obihann> Beginner here trying to convert binary into ascii, I can execute my code in GHCi no problem however when I execute it as a file in stack it all goes sideways... Specifically this is what fails "main = print (showInAtBase 2 intToDigit 10)
11:09:26 <monochrom> this in turn is inspired by Backus-Naur form for context free grammars, S ::= F <|> B
11:09:32 <monochrom> err, S ::= F | B
11:10:47 <monochrom> HOWEVER! It is true that Alternative is an alternative to MonadPlus. But not to Monad.
11:11:36 <frdg> monochrom: Foo and Bar must be the same type though. I would think that (<|>) would take two types if reffering to the English definition of alternative you are using. 
11:11:44 <frdg> obviously this isn
11:12:04 <frdg> of course this isn't the case though
11:12:07 <monochrom> My S, F, B, foo, bar all have the same type.
11:12:14 <phadej> Left <$> x <|> Right <$> y -- for different types
11:12:28 <phadej> (and yes, precedence works as you would like)
11:12:36 <monochrom> @type (<|>)
11:12:37 <lambdabot> Alternative f => f a -> f a -> f a
11:12:55 <monochrom> <|> is consistent with my S, F, B, foo, bar, F|B, foo<|>bar
11:13:41 <frdg> I understand thanks
11:13:42 <monochrom> English leaves open whether you intend "same type different values" or "different types". Please don't use English as your axioms.
11:13:54 <awpr> an alternative signature for the method of alternative that would allow the alternatives to have different types would be `(<||>) :: f a -> f b -> f (Either a b)`; the downside is this forces you to make data constructors even if you don't want to.  it's a similar idea to `zip` vs. `zipWith`
11:14:01 <monochrom> English doesn't even know types vs terms.
11:14:38 <awpr> the one that's actually in Alternative lets you choose to wrap the two sides in `Left` and `Right` in advance if you wish
11:16:07 <frdg> ya I had things mixed up. Thanks all
11:16:44 <awpr> I guess the form that'd be fully analogous to `zipWith` would be `altWith :: (a -> c) -> (b -> c) -> f a -> f b -> f c`, but that's mildly tedious to implement and usually would end up getting defined as `(f <$> fa) <|> (g <$> fb)` anyway
11:16:55 <codedmart> MarcelineVQ: `sortOn (Down . fmap Down)` but I actually don't want to change the order other then just having the Nothing's first and the Just's last.
11:17:36 <MarcelineVQ> oh, you don't want to sort you're just partitioning by Just?
11:18:13 <monochrom> > sortOn (Down . fmap Down) [Just 3, Nothing, Just 1, Just 4, Nothing]
11:18:15 <lambdabot>  [Just 1,Just 3,Just 4,Nothing,Nothing]
11:18:21 <MarcelineVQ> did you mean to say Nothing's first just now?
11:18:42 <monochrom> OK oh well
11:19:05 <ClaudiusMaximus> > uncurry (++) $ partition isJust [Just 3, Nothing, Just 1, Just 4, Nothing]
11:19:07 <lambdabot>  [Just 3,Just 1,Just 4,Nothing,Nothing]
11:19:15 <glguy> phadej (or anyone): Do you know anything about text-1.2.4.0 blocking GHC-8.10.1 with its build-deps?
11:19:59 <monochrom> I would use partition and then (++). I would not allow any sorting algorithms to touch it. Unless I'm given strong guarantee of "stable sort".
11:19:59 <merijn> glguy: I recall something about 8.10 shipping with a wrong version of text or something like that
11:20:06 <merijn> but I don't recall the details
11:20:36 <monochrom> Hell, partition then (++) is guaranteed to be linear time, sorting is not.
11:20:46 <codedmart> OK thanks all!
11:21:49 <MarcelineVQ> partiton isn't silly enough:  (\xs -> zipWith const (filter isJust xs ++ repeat Nothing) xs)
11:22:16 <monochrom> merijn: I think what I heard is that 8.10 ships with an older version of text because the newer version doesn't fit.
11:23:07 <monochrom> haha if the input list is infinite, yours may be necessary
11:27:35 <dolio> If the input list is infinite, you'll never see a Nothing.
11:29:40 <codedmart> Is there a groupBy function but not tied to consecutive? I want to group elements by, but I don't care if they are consecutive or not.
11:29:48 <sm[m]> hi obihann , you'll need to tell us the error message (paste on a paste site if it's long, eg hastebin.com)
11:29:58 <merijn> codedmart: Just do "groupBy f . sort" :p
11:45:44 <Orbstheorem> How can I delegate a class instance implementation to a record member? Say I have `class C`, `data Foo = ...`, `data Bar = Bar {foo::Foo,...}`  `instance C Foo where...`; I would like to derive `instance C Bar` by delegating it to foo. I could manually unpack foo from Bar for every class method, but it feels wrong...
11:48:16 <berndl> sounds like deriving via
11:49:15 <dmwit> Orbstheorem: Can't do better than that.
11:49:37 <dmwit> Orbstheorem: Think especially: what if the method has two Bar arguments? What if it must return a Bar? How could the compiler possibly make the right choices in those situations?
11:49:47 <wavemode> isn't derivingvia only for newtypes
11:50:07 <wavemode> since it needs Coercible
11:51:14 * Orbstheorem would like a `deriving using` taking a total function :(
11:52:20 <Orbstheorem> `deriving instance C Bar using (foo :: Bar -> Foo)`
11:53:00 <Orbstheorem> dmwit: Thanks, I guess I'll write the extra lines.
11:53:12 <Orbstheorem> I guess I could use quasiquotes, but feels hacky x)
12:05:31 <ski> obihann : assuming you meant `showIntAtBase', not `showInAtBase' (which you wrote), try passing `""' as last argument (after the `10') of it
12:07:01 <scasc> So for VSCode there's the extension called "ghcide" and "Haskell Language Server" which *extension* is the one the new concerted effort will be using?
12:12:47 <sm[m]> who knows
12:25:31 <Philonous> I've updated the list of qualified import abbreviations to make it more readable and comparable. https://gist.github.com/Philonous/b4a435797b64ee5a688d060fd88832ea
12:34:05 <EvanR> oh that's cool
12:34:56 <dsal> There are some bizarre ones in there.
12:36:06 <EvanR> winner for Char8 is 'B'... no one will be confused at all
12:36:07 <sm[m]> very cool
12:36:43 <dsal> Prelude as Prelude
12:37:37 <sm[m]> should put it somewhere official, I'd like to consult this
12:38:06 <dsal> `GHC.Exts` as `Happy_GHC_Exts` sounds generated.
12:39:04 <sm[m]> maybe hlint could make use of it 
12:41:26 <dsal> I like how many different things are named ST
12:41:43 <EvanR> I don't like how many different things are named A
12:43:52 <sm[m]> we should pick some standard abbrevs for all the string types, at least
12:45:18 <dsal> I vote... not ST for Data.Text
12:46:11 <dsal> Maybe hlint could help with some of that.  "Hey, I see you aliased a lot of things to A.  It's probably full.  Maybe consider calling this one B?"
12:47:40 <monochrom> haha
12:47:52 <monochrom> But no. Consider calling this one Eh
12:48:08 * monochrom is Canadian, he
12:48:10 <monochrom> err
12:48:11 <wavemode_> If you're qualified importing many things to the same name, it's probably for a reason
12:48:12 * monochrom is Canadian, eh
12:49:06 * sm[m] thinks: S, T, TL, B, BL, B8, BL8, BU8, BLU8 . And wow, seeing the other "string"s here makes my sympathise with "argh string types!" complaint
12:49:40 <phadej> SB ST
12:50:00 <phadej> FS
12:50:40 <phadej> BA
12:50:59 <phadej> cannot think of more right now
12:51:18 * hackage hlibsass 0.1.10.0 - Low-level bindings to Libsass  https://hackage.haskell.org/package/hlibsass-0.1.10.0 (jakubfijalkowski)
12:51:33 <dsal> import Data.Text as String
12:51:36 <phadej> (ShortByteString, ShortText, FastString (GHC), ByteArray)
12:55:12 <sm[m]> I'd like BSH or BShort rather than SBS, for extra differentiation from "Strict" and consistency with the module name order
12:55:55 <scasc> "winner for Char8 is 'B'... no one will be confused at all" -- well, a Char8 is a **B**yte. And also, an uppercase B reminesces an 8.
12:56:09 <sm[m]> assuming BSS is needed for Data.ByteString.Streaming. Though it seems "Q" means that somehow
12:58:06 <sm[m]> but clearly, Q is quickcheck
12:58:36 * scasc was really missing these kind of message. They seem to be really underused nowadays
13:00:28 <phadej> S is Set not String
13:00:40 <phadej> string should be Z
13:00:44 <sm[m]> true. String doesn't need an abbreviation
13:00:54 <phadej> Data.String ?
13:01:13 <sm[m]> yes, how often do you need to import that qualified and use it heavily
13:01:47 <phadej> :)
13:02:01 <dsal> Right, that's the thing.  Qualified doesn't even make sense for some of these.
13:04:19 * hackage butcher 1.3.3.2 - Chops a command or program invocation into digestable pieces.  https://hackage.haskell.org/package/butcher-1.3.3.2 (lspitzner)
13:04:52 <dminuoso> Philonous: I guess one of the major issues with finding a sort of "convention" is that the module space is rather large. So finding a generic rule is next to impossible (beyond taking the initials of each level in the module namespace, say turning `Data.ByteString` into `DB`. And keeping a really large file on hand is not feasible either.
13:05:03 <dminuoso> Philonous: However, I do like your work for other reasons.
13:06:01 <dminuoso> It would be amazing if you could put that table up somewhere, where sorting by columns is possible. :)
13:06:18 <dminuoso> But.. I guess that being csv data, I can trivially do that myself.
13:06:56 <dsal> Weird that github doesn't do that.  I used to have a bookmarklet that would've made the table sortable.
13:07:09 <dminuoso> Perhaps that only works on markdown rendered tables?
13:07:22 <dminuoso> That's a prettified csv file
13:07:25 <dolio> It's kind of misleading to say that "Char8" is being named "B", because the reason is that it's a ByteString module. They're not naming it after the element type used in the API.
13:07:54 <sm[m]> right. It's a variation/subcomponent of ByteString
13:08:03 <dsal> dminuoso: Yeah, I just figure they're already rendering it, might as well make it sortable.
13:08:09 <dminuoso> Indeed, I myself have frequently imported various modules of the same package into a shared qualifier.
13:08:10 <sm[m]> easier to remember if we leverage the existing module hierarchy
13:15:58 <__monty__> I'd like to pretty print some values depending on a configuration. I can't define `instance Pretty (Reader Config Value)` How is something like this usually dealt with, a newtype? Are there better ways I could design this?
13:17:21 <dmwit> A newtype or a new class.
13:18:19 * hackage commander-cli 0.2.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.2.0.0 (sgschlesinger)
13:18:36 <farmfromjakestat> Alright, so I am looking for a function that will do take in [3,7,9,7] and return [[3,7,9], [3,7], [3]] And I am really not sure how to do that. I was able to do the reverse with a scanr but can't get this 
13:19:08 <Hopplahase> > inits [3,7,9,7]
13:19:11 <lambdabot>  [[],[3],[3,7],[3,7,9],[3,7,9,7]]
13:19:13 <farmfromjakestat> I also don't really know what to call that so I don't know what to do 
13:19:29 <farmfromjakestat> Wow, super useful. Thanks!
13:20:08 <dsal> @hoogle [a] -> [[a]]
13:20:08 <lambdabot> Data.List subsequences :: [a] -> [[a]]
13:20:08 <lambdabot> Data.List permutations :: [a] -> [[a]]
13:20:08 <lambdabot> Data.List inits :: [a] -> [[a]]
13:20:34 <farmfromjakestat> Is there a reverse of that, like returns [[7,9,7], [9,7], [7]]? 
13:20:43 <dsal> :t reverse . inits
13:20:44 <lambdabot> [a] -> [[a]]
13:21:10 <ski> > tails "abcd"
13:21:12 <Hopplahase> > tails [3,7,9,7]  -- farmfromjakestat
13:21:12 <lambdabot>  ["abcd","bcd","cd","d",""]
13:21:14 <lambdabot>  [[3,7,9,7],[7,9,7],[9,7],[7],[]]
13:21:20 <farmfromjakestat> Awesome
13:22:22 <dsal> Oh, tails.  Yeah, "abcd" is a bit more obvious an example.  :)
13:23:01 <dsal> But hoogle gets you there pretty quickly in any case:  https://hoogle.haskell.org/?hoogle=%5Ba%5D+-%3E+%5B%5Ba%5D%5D&scope=set%3Astackage
13:23:03 <ski> @let splits :: Alternative i => [a] -> i ([a],[a]); splits xs0 = pure ([],xs0) <|> case xs0 of [] -> empty; x:xs -> first (x:) <$> splits xs
13:23:05 <lambdabot>  Defined.
13:23:19 <ski> > splits "abcd" :: [(String,String)]
13:23:21 <lambdabot>  [("","abcd"),("a","bcd"),("ab","cd"),("abc","d"),("abcd","")]
13:28:18 * hackage pine 0.1.0.3 - Functional 2D Game Framework  https://hackage.haskell.org/package/pine-0.1.0.3 (Grinshpon)
13:46:21 <phadej> the goal is to get the mail sent!
13:47:19 <Uniaika> and we need more cowbells!
13:48:16 <phadej> > putStr '\a'
13:48:17 <lambdabot>  error:
13:48:17 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
13:48:17 <lambdabot>        Expected type: String
13:48:25 <phadej> % putChar '\a'
13:48:25 <yahb> phadej:  
13:48:34 <phadej> it kind of worked here
13:53:19 * hackage czipwith 1.0.1.3 - CZipWith class and deriving via TH  https://hackage.haskell.org/package/czipwith-1.0.1.3 (lspitzner)
13:56:02 <Philonous> dminuoso, the sqlite file that this table came from is only ~1MB, not really too much to use as a base for a suggestion engine.
13:58:25 <Philonous> Also, I was looking at this in the hopes that there'd be clear winners for most of the popular modules, and maybe even a winning schema. But it seems that neither is true, which is also an answer, I guess, just not the one I was hoping for. 
14:09:49 * hackage ghc-lib-parser-ex 8.10.0.14 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.14 (shayne_fletcher)
14:11:48 * hackage smuggler2 0.3.4.2 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.4.2 (jrp)
14:30:19 * hackage concurrent-output 1.10.12 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.10.12 (JoeyHess)
14:31:49 * hackage smallcheck 1.1.6 - A property-based testing library  https://hackage.haskell.org/package/smallcheck-1.1.6 (Bodigrim)
14:39:37 <joeyh> anyone know if hClose is an interruptable operation, ie if it's blocked flushing a buffer can an async exception interrupt it?
14:44:58 <slack1256> joeyh: I don't really know if hClose is interruptable. But given the pattern with `bracket (openFile "file") hClose \hdl -> ...` and the definition of bracket file:///nix/store/shm9swwd535f7hvihyig2y65f2g16kx2-ghc-8.8.3-doc/share/doc/ghc/html/libraries/base-4.13.0.0/src/Control-Exception-Base.html#bracket I would say it isn't.
14:45:29 <phadej> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.IO.Handle.Internals.html#hClose_help I'd say it is
14:45:39 <slack1256> Notice how on the definition of `bracket`, the `after` binding is evaluated under the `mask`. That `after` would be `hClose` in your case.
14:48:28 <wikiemol> Hello, can anyone tell me if GHC ever does a complete copy of a list? Are lists always passed by reference or are their cases where GHC will create an entirely new list? 
14:50:02 <hexagoxel> bracket masks that because the "release" action _could_ be interruptible. I don't see how that tells you anything about hClose.
14:53:40 <slack1256> wikiemol: Semantically you can think a new list is created everytime a function modifies it. Operationally the list can be copied, but this is rare under lazy evaluation. Better yet, the whole won't be created at all given fusion rules, it will be a `for` loop.
14:54:15 <slack1256> Better yet, the whole list won't be created on lots of cases given the fusion rules.
14:54:41 <wikiemol> slack1256 Okay, thanks. Do you know what those rare cases are where it is copied? Do I just need to understand fusion well enough to know?
14:55:12 <ski> wikiemol : do you understand that lists (in Haskell) are (single-)linked lists ?
14:55:22 <wikiemol> ski Yes
14:56:02 <ski> so, if you do `"foo" ++ str', then `str' is not copied, but is shared with the tail of the new list value that is computed by this expression
14:56:24 <ski> but if you do `str ++ "foo"', then `str' is copied !
14:56:38 <ski> does that make sense ?
14:57:13 <slack1256> You don't need to understand fusion in my opinion. If you absolutely *need* to trigger the fusion, I restrict myself to the knowledge of "good" builder and "good" consumer (foldr expressable functions) that when compossed will trigger the fusion rules under -O1.
14:57:52 <wikiemol> ski Yeah that makes sense, thanks. That was kind of my assumption, but I couldn't find anything to verify. Are there any other cases, or does that rule basically encompass everything you need to know?
14:58:24 <wikiemol> slack1256 What do you mean by "good" builder and "good" consumer?
14:58:41 <jcowan> What are good examples of distinct monads over what is fundamentally the same type, but made distinct by data or newtype?
15:00:49 <slack1256> jcowan: List and ZipList
15:00:55 <shapr> aw, I was about to say that
15:01:05 <dolio> ZipList isn't a monad, though.
15:01:07 <jcowan> great minds think alike, evidently
15:01:12 <shapr> jcowan: coi ko mo do
15:01:28 <berndl> Isn't ZipList a comand?
15:01:36 <shapr> :t ZipList
15:01:37 <lambdabot> [a] -> ZipList a
15:01:54 <ski> no, berndl
15:01:54 <dolio> No, it can be empty.
15:02:06 <shapr> dolio: good point, got something in mind that matches that intuition?
15:02:18 * hackage lsp-test 0.11.0.2 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.11.0.2 (luke_)
15:02:30 <slack1256> dolio: There was a recent mail thread where the was a monad instance with ziplist behaviour for a related data-type (via a codensity transformation which is cheating). But you are right, ZipList as they are don't have a Monad Instance.
15:02:35 <ski> @hoogle NonEmptyZipList
15:02:36 <lambdabot> No results found
15:02:56 <berndl> dolio: Ah, you're right.
15:03:04 <berndl> So extend wouldn't work.
15:03:08 <dolio> Codensity of ZipList isn't isomorophic to ZipList.
15:03:11 <shapr> jcowan: the intuition for list vs ziplist is whether you want cartesian product of two lists, or tuples of the items
15:03:23 <shapr> jcowan: was that the sort of answer you wanted? or did you have something else in mind?
15:03:35 <ski> jcowan : state vs. reverse state, perhaps ?
15:04:01 <dolio> Any type with multiple monoid structures could give rise to multiple writers.
15:04:05 <berndl> My intution of ZipList is that it's just like Stream, except it can be empty.
15:04:19 <berndl> Stream is a comonad.
15:04:41 <slack1256> wikiemol: In practice, every list function expressable as a `foldr` is a good consumer and every function expressable via `build` is a good producer. I don't have the list on top of my mind, so I just go to haddocks of Data.List and click source on a function. If it has a RULES annotation on top of it or the definition is written in terms of foldr, I know it's a good consumer. Same when I want to know if something is a good producer
15:04:42 <slack1256> .
15:04:46 <jcowan> shapr: That was the kind of thing.  (Unfortunately I do not know the illocutionary force of something that is both a command and a question, but in general I am employed and also working on R7RS.)
15:05:03 <shapr> jcowan: ha, I know it was an abuse of lojban :-)
15:06:14 <jcowan> And that's another question: is there a "codata for dummies" paper?  At the moment I only know that a comathematician is a comachine for making cotheorems into ffee.
15:06:34 <shapr> jcowan: have you dug into comonads yet?
15:07:06 <jcowan> No.  Comathematics seems to be a twisty comaze of little copassages, all different.
15:07:29 <shapr> I think the first explanation to me was "monads, but flipped around!"
15:07:46 <dolio> That doesn't seem very helpful. :)
15:07:52 <slack1256> wikiemol: Most of the time I don't care about fusion at all though. Laziness gives good streaming behaviour for lists, so all the passes are naturally done element per element instead of "whole list" to "whole list" and the RTS does the right thing respect allocation.
15:08:30 <shapr> jcowan: spreadsheet calculations are the easiest model of comonads in my brain. You have a bunch of context and you're using that to produce some more limited result.
15:09:03 <berndl> jcowan: Search for the paper "Codata in Action"
15:09:09 <shapr> I recently failed to implement conway's game of life with a comonad, but I understand everything better now.
15:09:11 <tabaqui1> have you seen the best code share service? http://codephoto.ru/
15:09:32 --- mode: ChanServ set +o shapr
15:09:39 --- kick: tabaqui1 was kicked by shapr (Kicked by shapr)
15:09:54 <shapr> tabaqui1: you gonna tell me that wasn't spam?
15:10:03 <tabaqui1> nope :) it's a joke
15:10:14 --- mode: shapr set -o shapr
15:10:15 <tabaqui1> btw, I'm chatting here for 4 years
15:10:31 <shapr> tabaqui1: I know! I thought someone had stolen your connection!
15:10:43 * shapr hugs tabaqui1
15:11:01 * tabaqui1 is sobbing
15:11:16 <berndl> tabaqui: So the code is copy/pasted in PyCharm?
15:11:43 <tabaqui1> Well, at least it is highlighted correctly
15:11:49 * hackage commander-cli 0.2.0.1 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.2.0.1 (sgschlesinger)
15:11:55 <slack1256> Damn, where does time go?
15:11:58 <jcowan> berndl: Thanks.  I found Downen et al. from ESOP 2019, is that it?
15:12:23 <berndl> SPJ is one of the coauthros.
15:12:51 <berndl> *authors
15:12:54 <Philonous> tabaqui1, That's actually brilliant!
15:13:20 <monochrom> "where does time go" is a deep philosophical and scientific question :)
15:13:40 <wikiemol> slack1256 Thanks for the knowledge! Gives me peace of mind
15:14:40 <slack1256> wikiemol: I like peace of mind :-)
15:15:25 <monochrom> Unless your peace of mind is disturbed by the last 1%, e.g., a bit of GC overhead.
15:15:51 <tabaqui1> From SICP: To quote some graffiti seen on a Cambridge building wall: “Time is a device thatwas invented to keep everything from happening at once.”
15:16:18 <monochrom> hh
15:16:21 <monochrom> err, heh
15:16:30 <shapr> I gave a talk at my last job comparing Python vs Haskell webserver performance, that last 1% got real exciting
15:16:41 <slack1256> Do you have slides?
15:16:50 <ski> jcowan : a first approximation is that data is about the finite, termination, while codata is about productivity, the (possibly) infinite. think data structures that you traverse, vs. objects with behaviour that you pass messages
15:17:20 <jcowan> I got that much from Turner's total FP program, but it skimps the discussion of codata
15:18:21 <joeyh> slack1256: that mask does not mask async exceptions if it's interruptable though
15:18:26 <ski> Haskell blurs this distinction, since `data List a = Nil | Cons a (List a)' also contains infinite lists
15:18:42 <slack1256> Do functions over codata, that do something "productive" give the infinite, work as proof/terms of types for the logical interpretation of lambda calculus?
15:18:51 <slack1256> joeyh: You're right.
15:19:28 <ski> @where Charity
15:19:28 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
15:19:45 <ski> is a language which maintains the distinction between data and codata
15:19:46 <joeyh> phadej: aha, there it is!
15:20:10 <joeyh> I've been wondering about this, because it seems a bracket foo (hClose a>>hClose b) may never close b
15:20:22 <ski> all data is terminating in it, and all codata is productive
15:20:26 <slack1256> In my mind, total functions were neccesary for proofs because the represented the "finite steps" that you can realize on a proof by hand.
15:20:58 <shapr> slack1256: I could dig up the slides, I think I used org-present, but the summary was roughly: Haskell takes 1/10 the time of Python to handle a request, 99% of the time. That last 1% is much worse than Python
15:20:58 <ski> slack1256 : btw, i can't make sense of your question
15:22:15 <slack1256> Oh sorry. I will read a little bit so maybe I can articulate better.
15:22:22 <dolio> Or, data is about trees that are built by individual pieces; codata is about trees that you observe by interacting with a process that allows individual observations/interactions at each step.
15:23:28 <ja> shapr: would the new GC in GHC change that?
15:23:29 <nil> slack1256: the way i understand it, coinduction as a proof method maps to corecursion/coprogramming/productivity the same way that induction maps to recursion/termination
15:23:48 <nil> i still have to research this more myself, and i couldn't come up with a practical example
15:23:49 <berndl> Just play with Idris/Agda/Coq. They have codata types.
15:24:28 <ski> jcowan : i'm not sure how much you'd get out of it, but perhaps you could take a glance at "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs,Jan Rutten in 1997 at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf>
15:26:32 <berndl> The Agda stdlib has a bunch of ready-made codata types you can play with: https://github.com/agda/agda-stdlib/tree/master/src/Codata
15:26:40 <slack1256> shapr: That last 1%, how much worse was than the python case? 100x worse?
15:27:11 <slack1256> Was it a latency measure?
15:59:04 <dolio> slack1256: Lots of mathematical stuff can be described coinductively, although it seems like most mathematicians are biased toward induction.
16:03:02 <berndl> Blame that on the axiom of foundation (thanks von Neumann).
16:04:00 * ski . o O ( normal forms in the lambda-calculus )
16:04:50 <EvanR> dolio: thing is all the functions in ByteString.Char8 have the same names as in ByteString so if you see B.head or something...
16:07:03 <obihann> I have some basic haskell code to convert a list of binary numbers to a string of letters... it's not great and uses multiple maps but I was hoping I could get some feedback on it https://pastebin.com/UpSXy97s
16:07:42 <obihann> ignore line 8, forgot to delete that
16:07:55 <EvanR> i question whether your bin is actually a list of binary numbers
16:08:07 <EvanR> they look like regular numbers
16:08:31 <obihann> as a data type there just numbers
16:08:38 <EvanR> right
16:09:03 <obihann> so forget my maps, is there a binary data type that would be easier to convert to integeral?
16:09:29 <EvanR> wait... what do you actually wany. I think it's a terminology problem
16:09:32 <dolio> EvanR: People don't use both APIs at once, I imagine.
16:09:43 <dolio> So they pick B always, which is completely reasonable.
16:09:51 <berndl> obihann: maybe Word8?
16:09:57 <obihann> EvanR: got some binary that I want to turn into plain ascii
16:10:13 <EvanR> Word8 and Integer both represent the same numbers. One is just bounded lower
16:10:31 <dsal> obihann: Do you have ascii data?
16:10:44 <EvanR> > show 101101
16:10:46 <lambdabot>  "101101"
16:11:00 <obihann> I know what it converts to if thats what you mean
16:11:19 * hackage calamity 0.1.14.3 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.3 (nitros12)
16:11:20 <obihann> it was in a tweet and I wanted the most complicated way of turning it into text
16:11:32 <obihann> so I chose haskell :)
16:11:43 <EvanR> you see "binary" makes it sound like you already have ascii '0' and '1'
16:11:58 <obihann> ahhh, my bad then
16:12:35 <obihann> what I have is the 1's and 0's that I copied from twitter, which I'm storing as a list of integrals
16:13:22 <EvanR> > map show [0,1,0,0,1,1,1,0]
16:13:23 <lambdabot>  ["0","1","0","0","1","1","1","0"]
16:13:37 <EvanR> > concatMap show [0,1,0,0,1,1,1,0]
16:13:39 <lambdabot>  "01001110"
16:14:18 <obihann> so every 1 and 0 is not a seperate item in my list
16:14:23 <ski> obihann : `map f (map g xs) = map (f . g) xs'
16:14:41 <EvanR> how could it not be separate
16:15:00 <ski> obihann : perhaps you also wanted `putStrLn', rather than `print'
16:15:03 <obihann> EvanR: [0100010,01001100,etc.]
16:15:29 <EvanR> > 0100010
16:15:32 <lambdabot>  100010
16:15:41 <obihann> so to clarify this does work how I expected it too... I accept I likely could be doing it wrong but it does somehow work :)
16:15:50 <Ariakenom> % chr 0b0100010
16:15:51 <yahb> Ariakenom: '"'
16:15:56 <ski> % 0b0100010
16:15:56 <yahb> ski: 34
16:16:21 <int-e> > text "0100010"
16:16:23 <lambdabot>  0100010
16:16:23 <obihann> ski: I'll give that long map line you sent a try
16:16:48 <ezzieyguywuf> I'm confused about how openGL and GLFW 'talk' to each other - I guess the openGL bindings come from the GLFW-b package itself, and so the interaction somehow happens behind the scenes?
16:17:27 <ezzieyguywuf> all I know is I call GLFW.init, then make a bunch of glSomeOpenGLFunction calls, then GLFW.swapBuffers and things "just work"
16:17:36 <ski> @hoogle (Integral a,Read a) => a -> (Char -> Int) -> ReadS a
16:17:37 <lambdabot> No results found
16:17:49 * hackage commander-cli 0.3.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.3.0.0 (sgschlesinger)
16:18:10 <ski> obihann : it's not intended as a line of code to add, but as a refactoring rule/law to apply
16:18:30 <EvanR> ezzieyguywuf: GLFW and GLFW-b don't bind to opengl itself. You use a different lib for that, such as gl
16:18:32 <ski> @hoogle readIntAtBase
16:18:33 <lambdabot> No results found
16:18:41 <obihann> ski: oh...
16:18:45 <ski> @type showIntAtBase
16:18:46 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
16:19:22 <obihann> ShowIntAtBase would replace my bintodec function correct?
16:19:34 <obihann> not a drop in of course but, in principal
16:19:50 <ski> obihann : that is, if you `map' and then `map' again, over a list, you could replace that by a single `map' (composing the two functions that you `map'ped) .. of course, the equality works in both ways, so you could also replace a single `map' of a composed function with two `map's
16:19:59 <int-e> ezzieyguywuf: There's some (thread-local?) state on the C side of things that keeps track of an opengl context.
16:20:12 <ski> obihann : no, `showIntAtBase' is like
16:20:18 <slack1256> dolio: That is the thing. I don't have a good model onto what coinduction corresponds when doing "proof by hand"
16:20:26 <ski> > showIntAtBase 2 intToDigit 34 ""
16:20:29 <lambdabot>  "100010"
16:20:47 <ski> obihann : that is, recovering the binary numeral from the number
16:20:51 <obihann> ski: so it's good to go the other way around then, int to binary for example
16:20:55 <obihann> gotcha
16:20:56 <ski> but you're going in the opposite direction
16:21:08 <obihann> and for the maps I can combine them and have a map in a map
16:21:35 <ski> obihann : yes, but the refactoring i mentioned was the next step, after having a "map in a map"
16:22:30 <ezzieyguywuf> ah, so all glfw-b does is 'talk' to the c-library thing
16:22:33 <obihann> here we go: print $ map chr (map bintodec xs)
16:22:48 <ezzieyguywuf> so every time I make a glWhatever call, it's literally leaving Haskell and going int c-world
16:22:51 <ski> obihann : and what do you get, if you apply the aforementioned refactoring, to that ?
16:22:54 <ezzieyguywuf> i get it
16:22:56 <ezzieyguywuf> thus it's an IO
16:23:06 <obihann> not applied the refactoring yet ;) hold on haha
16:23:28 <obihann> ok... I don't fully understand that refactoring 
16:23:38 * ski rushes ahead in the distance, glancing back to see whether obihann is following
16:23:48 <obihann> :)
16:23:56 <int-e> ezzieyguywuf: Yep.
16:24:09 <ski> in your case, `f' is `chr', `g' is `bintodec', and `xs' is just `xs'
16:24:19 <Ariakenom> % let char2int = read . (:[]) in sum (zipWith (\index bit -> char2int bit * 2 ^ index) [0..] (reverse "0100010")) -- just playing around
16:24:19 <yahb> Ariakenom: 34
16:25:02 <ski> Ariakenom : now do it, allowing a fractional part, with attribute grammars
16:25:54 <Ariakenom> I refuse. While rational numbers are real, I don't believe they're natural.
16:25:55 <obihann> ski: in the refactoring is the =  just showing it in a different format?
16:26:09 <ski> @hackage uuagc
16:26:09 <lambdabot> https://hackage.haskell.org/package/uuagc
16:26:36 <ski> obihann : yes, both sides are equal, just different ways to express the same thing
16:26:55 <ski> obihann : knowing such laws are useful for refactoring, and for reasoning about code
16:27:41 <ski> another example could be `sum (xs ++ ys) = sum xs + sum ys'. or `reverse (xs ++ ys) = reverse ys ++ reverse xs'
16:35:40 <dolio> slack1256: I don't think it's any different than proofs on a computer, really.
16:39:58 <slack1256> dolio: My intuition is that total functions serve as proof because you can have a demonstration that requires an infinite number of steps. I don't know how co-inductive functions fit on that paradigm.
16:40:44 * ski didn't follow the "you can have a demonstration that requires an infinite number of steps" part
16:40:54 <monochrom> perhaps s/can/can't/
16:42:25 <dolio> Codata doesn't make functions non-total.
16:42:50 <jcowan> FWIU, TFP makes data and codata disjoint: codata is the only thing that can be infinite
16:43:23 <monochrom> This is going to force you to give up "total = terminates" and look for a more encompassing, robust definition of "total".
16:43:34 <ski> (functions are more or less a kind of codata, btw)
16:44:35 <dolio> Right, perhaps it would help to think about how higher-order functions don't cause problems.
16:44:42 <monochrom> functions are how induction-background people encode codata. Just look at "an infinite sequence is a function from Natural to X"
16:45:31 <monochrom> (as opposed to: "infinite sequences are simply postulated to exist and satisfy these axioms: ...")
16:45:55 <monochrom> (recall that we simply postulated sets and naturals to exist and satisfy these other axioms: ...)
16:46:10 <dolio> And functions. :)
16:46:14 <monochrom> (and that shows our induction-biased background)
16:48:00 <shachaf> Should I think of codata as something other than greatest fixed points?
16:48:22 <shachaf> Also should I think of fixed points in terms other than something (exists x. (x, x -> F x))?
16:48:37 <ezzieyguywuf> nope, still don't get it. Even if all the openGL stuff is done on the c-side, there still needs to be some link between the haskell-side saying "hey, do this stuff in context SuchAndSuch" doesn't there?
16:48:40 <monochrom> Yes, it always helps to have multiple equivalent-but-not-obviously angles.
16:48:59 <ezzieyguywuf> I don't ever do anything like `context <- GLFW.getContext` or `GLFW.swapBuffers context`
16:49:16 <ezzieyguywuf> again, I probably don't really need to know, but I am curious
16:49:34 <ezzieyguywuf> ah, you know what, it's all in the GLFW window, nvm
16:50:03 <shachaf> I guess the answer to the first question is yes, and functions are an example.
16:50:08 <ezzieyguywuf> no wait, that doesn't answer the question still, because when I make glSomeFunc calls, they know nothing about the GLFW window
16:50:36 <monochrom> Perhaps there are hidden global variables working behind the scene for you.
16:50:47 <ezzieyguywuf> monochrom: that's what I think.
16:50:58 <monochrom> Learn from the experts! Always blame it on hidden variables! >:)
16:51:08 <ezzieyguywuf> isn't that generally poor form though? wouldn't it be better to explicitly pass the context around or something?
16:51:12 <ezzieyguywuf> monochrom: lol.
16:51:56 <monochrom> My understanding is that the very design of OpenGL is based on a global behind-the-scene state.
16:52:26 <monochrom> When this happens, any language binding cannot easily improve on that.
16:52:47 <monochrom> (even when the language would rather you do things more properly)
16:53:13 * ezzieyguywuf nods
16:53:15 <ezzieyguywuf> fair enough
16:53:27 <ezzieyguywuf> i'll stop worrying about that for now
16:53:35 <ezzieyguywuf> (but what if I want more than one context...)
16:54:14 <monochrom> Then you go to the OpenGL community and go political.
16:54:41 <monochrom> You shout the magic words "this is clearly thread-unsafe" and people will have fear and repent.
16:54:57 <int-e> OpenGL is ancient, it predates the war on global variables. (In fact I imagine that early on, the state may have been kept on the graphics hardware side)
16:55:48 <ezzieyguywuf> hah
16:55:56 <monochrom> Time to also evangelize for "GPU context switching".  *snickers*
16:56:03 <ezzieyguywuf> I wonder if vulkan is any better then...
16:56:26 <int-e> Well it's horrible in a completely different way.
16:57:06 * ski . o O ( `getcontext' and `setcontext' for GPUs ? delimited continuations ? )
16:57:24 * ezzieyguywuf "What's a continuation..."
16:57:40 <monochrom> execution context
16:57:40 <int-e> Sorry, I shouldn't say this really... I never figured out how to even begin using Vulkan.
16:58:30 <int-e> Too many different object types, various buffers, queues... it seems very explicit about how you want to schedule stuff and where you want to place information.
16:58:35 <monochrom> It's OK. I haven't figured out how to use PHP, and it is still safe to say that PHP is horrible :)
16:58:43 <monochrom> Also COBOL
16:58:45 <ski> @quote cornered.me
16:58:45 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
16:58:52 <dolio> int-e: Some might still do that.
17:00:02 <dolio> I think there was some arm mini board where the 'open source' video driver was just a bunch of stubs that called into the GPU firmware, which implemented OpenGL running directly on the GPU or something.
17:00:04 <monochrom> Now just wait for some version of erisco to appear and say they have figured out how to write Haskell in PHP, it's quite alright...
17:00:19 <dolio> And people weren't too happy about that.
17:00:22 <ski> @quote simply.the
17:00:22 <lambdabot> jcowan says: The continuation is simply the stack, the whole stack, and nothing but the stack.
17:02:25 <int-e> dolio: Right, in an embedded devices context people still cut corners a lot, so this kind of thing (global GPU state on the device itself with no real context switching mechanism) wouldn't surprise me.
17:07:39 <ezzieyguywuf> I used to buy mp3 players from a company called cowan...
17:07:45 <ezzieyguywuf> those were the days.
17:08:26 <fog> i was trying to ask a question before, but because I confused ListT, for "ListT done right", the question got nowhere 
17:08:47 <fog> https://hackage.haskell.org/package/list-t
17:09:35 <fog> while the naieve ListT m a = m [a] is arguably no good for streaming applications, and only good for backtraking and non-determinism
17:09:52 <fog> ListT done right *is* useful for streaming
17:10:01 <fog> as it says on the hackage page;
17:10:11 <fog> "A correct implementation of the list monad-transformer. Useful for basic streaming."
17:10:46 <fog> so the original question involved the state encoding, as used for streaming
17:11:06 <fog> and how to reconcile this with ListT
17:12:25 <fog> the desire is for an interface over both, so that the same style of code can be used in both pure, and IO monadic contexts
17:13:30 <fog> the main tool for this is the function "unfold", which takes a state uncoding, and produces any container with a "set" method
17:13:57 <fog> or more generally, via the foldable instance of the state encoding, consumes the produced values with any provided action
17:15:01 <fog> (actually this is slightly wrong, unfold noramlly produces a list, which is then folded over to give any other container, since "set" is an "action")
17:15:06 <fog> :t unfoldr
17:15:07 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:15:58 <fog> :t foldr @[]
17:15:59 <lambdabot> error:
17:16:00 <lambdabot>     Pattern syntax in expression context: foldr@[]
17:16:00 <lambdabot>     Did you mean to enable TypeApplications?
17:16:03 <fog> % :t foldr @[]
17:16:04 <yahb> fog: (a -> b -> b) -> b -> [a] -> b
17:17:15 <fog> we dont have many "set" instances exported by Prelude, but (:) and [] of list can be used to show the idea of folding a container into another
17:17:29 <fog> :t foldr (:) []
17:17:30 <lambdabot> Foldable t => t a -> [a]
17:17:45 <fog> more generally you would have;
17:17:53 <fog> foldr set empty
17:18:38 <fog> :: (Foldable t,Set f) => t a -> f a 
17:19:11 <fog> so basically, because a state encoding can be unfolded
17:19:36 <fog> into a list, which is foldable, this can be folded over with the Set implementation of some other container
17:19:50 <fog> or, the Foldable instance of the state encoding could be used directly
17:20:10 <fog> but that doesnt really show how the state encoding is "producing" values as clearly
17:20:18 <fog> anyway, this seems like a very high level interface
17:20:35 <fog> which, for use with IO streams, it would be good to do with ListT
17:21:32 <fog> so, the list-t package exports;
17:21:33 <fog> uncons :: ListT m a -> m (Maybe (a, ListT m a))
17:22:01 <fog> which is the "get" style argument required by unfold to produce values
17:22:15 <fog> (anything with a get instance has a foldable instance)
17:22:49 <fog> so we can use this to make the usual state encoding
17:23:28 <fog> % type StateEncoding s a = (s,s->Myabe (a,s))
17:23:28 <yahb> fog: ; <interactive>:56:32: error:; Not in scope: type constructor or class `Myabe'; Perhaps you meant `Maybe' (imported from Prelude)
17:23:37 <fog> % type StateEncoding s a = (s,s->Maybe (a,s))
17:23:37 <yahb> fog: 
17:23:56 <fog> % kind! StateEncoding s a
17:23:56 <yahb> fog: ; <interactive>:58:1: error:; * Variable not in scope: kind :: Array i0 e; * Perhaps you meant one of these: `find' (imported from Data.List), `BSL.find' (imported from Data.ByteString.Lazy), `BS.find' (imported from Data.ByteString); <interactive>:58:7: error: Data constructor not in scope: StateEncoding :: t0 -> t1 -> i0; <interactive>:58:21: error: Variable not in scope: s; <interactive>:5
17:24:02 <fog> sorry
17:24:12 <fog> % kind! StateEncoding Int Bool
17:24:12 <yahb> fog: ; <interactive>:59:1: error:; * Variable not in scope: kind :: Array i0 e; * Perhaps you meant one of these: `find' (imported from Data.List), `BSL.find' (imported from Data.ByteString.Lazy), `BS.find' (imported from Data.ByteString); <interactive>:59:7: error: Data constructor not in scope: StateEncoding :: t0 -> t1 -> i0; <interactive>:59:21: error:; * Data constructor not in scope: Int
17:24:15 <fog> ?
17:26:19 <ski> (missing a `:')
17:26:33 <fog> % type family StateEncoding s a where StateEncoding s a = (s,s->Maybe (a,s))
17:26:33 <yahb> fog: 
17:26:40 <fog> % :kind! StateEncoding Int Bool
17:26:40 <yahb> fog: *; = (Int, Int -> Maybe (Bool, Int))
17:27:36 <fog> uncons :: ListT m a -> m (Maybe (a, ListT m a))
17:28:03 <fog> % :kind! StateEncoding (ListT m a) a
17:28:03 <yahb> fog: ; <interactive>:1:16: error:; Not in scope: type constructor or class `ListT'; Perhaps you meant `ListF' (imported from Data.Functor.Foldable); <interactive>:1:22: error: Not in scope: type variable `m'; <interactive>:1:24: error: Not in scope: type variable `a'; <interactive>:1:27: error: Not in scope: type variable `a'
17:28:10 <fog> hmm
17:28:43 <fog> fog: *; = (ListT m a, ListT m a -> Maybe (a, ListT m a))
17:29:57 <fog> comparing the type of ListT's uncons;
17:29:58 <fog> ListT m a -> m (Maybe (a, ListT m a))
17:30:27 <fog> with the rhs of the state encoding (the "get" function)
17:30:29 <fog> ListT m a -> Maybe (a, ListT m a)
17:30:44 <fog> we can see an extra `m' parameter
17:31:28 <fog> so it seems what we need is;
17:31:30 <fog> type StateEncodingM m s a where StateEncoding s a = (s,s-> m (Maybe (a,s)))
17:31:36 <fog> sorry
17:31:44 <fog> type StateEncodingM m s a = (s,s-> m (Maybe (a,s)))
17:32:13 <fog> and that this should be used for streaming in a pure context, with normal state encoding being recovered with m = Identity
17:32:24 <fog> but also for use in IO
17:32:48 <fog> but then what about unfold?
17:32:51 <fog> :t unfoldr
17:32:52 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:33:19 <fog> (b -> m ( Maybe (a, b))) -> b -> ?
17:34:03 <fog> actually, unfoldr :: Set t => (b -> Maybe (a, b)) -> b -> t a
17:34:05 <fog> is better
17:34:12 <ski> nu s. m (Maybe (a,s))
17:34:35 <fog> what does that unfold to?
17:34:48 <ski> that would be the `?'
17:34:57 <fog> yeah
17:35:43 <fog> does it need something like a monadic version of Set, in order to abstract over what kind of things can be unfolded using; nu s. m (Maybe (a,s))
17:36:02 <fog> abstracting over ListT
17:36:25 * ski still doesn't grok these `Get' and `Set' things
17:36:37 <fog> in the same way that Set abstracts over [] by allowing (:) and [] to be replaced by class functions
17:37:14 <fog> get is basically uncons, and set is cons, but curried and wrapped in Maybe so that they can have the empty case handled by Nothing
17:37:46 <fog> like, i would have the type of fold being dual to that of uncons, instead of having the arguments uncurried, and the basecase provided
17:38:16 <fog> basically, the ability to return a value from Nothing is a way of storing the basecase implicitly
17:38:49 <fog> class Set f where set :: Maybe (a,f a) -> f a
17:39:03 <fog> class Get where get :: f a -> Maybe (a,f a)
17:39:55 <fog> the type foldr bing dual to the type of unfoldr * (typo)
17:41:16 <fog> the other way to write the Set and Get classes is;
17:41:36 <fog> class Set s a where set :: Maybe (a,s) -> s
17:41:54 <fog> class Get s a where get :: s -> Maybe (a,s)
17:42:17 <fog> which might be better if we need to add extra parameters such as the monad m
17:43:09 <fog> instead of having different varients SetM and GetM over things of kind ((*->*)->*->*)
17:44:04 <fog> but it might be easier to start with those, since that seems to fit the ? above, that being the kind of ListT
17:44:59 <fog> unfoldrM :: SetM t => (b -> m ( Maybe (a, b))) -> b -> t m a
17:45:06 <fog> that seems ok
17:46:02 <fog> hmmm, im not going to be able to convert that into a version that uses the multiparameter implementation of the Set class
17:46:21 <fog> unless the type of set is more like your nu. encoding
17:46:39 <fog> nu s. m (Maybe (a,s))
17:47:49 <fog> class Set s a where type Nu s a; set :: Nu s a -> s
17:48:17 <fog> hmm, that still isnt going to work, it has no `m' parameter
17:48:41 <fog> actually im not sure how that nu. is working, it seems more like a forall...
17:49:18 <fog> infact, instead of Set taking extra parameters, it seems like it needs a "list of associated types" of changing length
17:49:26 <fog> which is not hopeful
17:50:30 <fog> well, i suppose there is no reason to expect for more than these 3 parameters
17:52:24 <fog> class SetM s m a where setM :: s -> m (Maybe (a, s)) -> s
17:52:41 <fog> which is the version where all the parameters have kind *
17:53:44 <fog> class SetM (f :: ((*->*)->*->*)) where setM :: forall m a. f m a -> m (Maybe (a, f m a)) -> f m a
17:54:03 <fog> being the other way to write it
17:54:28 <fog> i think the previous version is better
17:54:35 <fog> and it allows then also to write;
17:54:50 <fog> type Set s a= SetM s Identity a 
17:55:42 <ezzieyguywuf> isn't tere a function that does something like ["a", "b", "c"] -> ["d". "e", "f"] -> ["ad", "be", "cf"] ?
17:56:03 <fog> that looks like zipWith (++)
17:56:20 <fog> except for the abuse of notation
17:56:25 <ezzieyguywuf> fog: I believe I'm looking for zipWith
17:56:30 <ezzieyguywuf> and yes, I abused the notation :-P
17:56:39 <fog> :t zipWith
17:56:40 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:56:45 <ezzieyguywuf> doh!
17:56:50 <ezzieyguywuf> must learn how to properly search hoogle
18:02:49 <fog> then, since `Traverse m' can have a default implementation in terms of the superclass Constraint (Set m,Get m) 
18:04:16 <fog> I should be able to write TraverseM (f :: (* -> *) -> * -> *) with a default implementation of traverseM from (SetM f,GetM f) 
18:06:12 <fog> i wonder if thats the way to unify streaming in the pure and IO settings
18:44:59 <Partmedia> I want to write a network server, and from https://wiki.haskell.org/Implement_a_chat_server the strategy seems to be "make a bunch of lightweight threads and sync". I come from kqueue()/select()/epoll() land, and my application needs to sync all the threads several times per second, so event-driven is what I think I need. But I'm having trouble finding documentation on using event-driven I/O,
18:45:01 <Partmedia> particularly GHC.Event and how to use it. Does anyone know their way around a resource for GHC.Event?
18:45:29 <Axman6> GHC's IO is all event driven
18:46:01 <Partmedia> So, if I implement something like the wiki suggests, the runtime will make it event-driven for me?
18:47:11 <Axman6> you don't need to worry about managing events yourself, just write threads which act as if they're the only thing running and ask for data from whatever you want to get it from, and GHC will take care of things for you
18:48:55 <Axman6> GHC's IO manager is built on kqueue/epoll btw (and whatever the windows equivalent is)
18:48:57 <Partmedia> I see. The reason this seemed weird to me, was that "Scalable I/O Event Handling for GHC" suggests that there are event-driven programming interfaces, and that I shoehorned myself into keeping this single-threaded, because I don't have a good mental model of what syncing all the threads look like.
18:49:27 <Axman6> what synchronisation do you need?
18:49:46 <Axman6> also, you need to read concurrent and parallel programming in Haskell, it's free online
18:49:58 <Axman6> @where cacph
18:49:59 <lambdabot> I know nothing about cacph.
18:50:01 <Axman6> @where ccph
18:50:01 <lambdabot> I know nothing about ccph.
18:50:05 <Axman6> :(
18:50:12 <solonarv> @where parconc
18:50:12 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
18:50:14 <Partmedia> Thakns for the suggstion, I haven't strayed far from RWH.
18:50:17 <solonarv> that one?
18:50:21 <Axman6> yes
18:51:26 <Partmedia> Axman6, every 100-ish ms, all of the clients' cumulative inputs go into a computation, and the result of that computation needs to go back to all the clients.
18:52:06 <Partmedia> But I suppose that's not really different from the situation in the example that uses Concurrent.Chan
18:52:07 <Axman6> what sort of computation?
18:53:44 <Partmedia> A simulation. Client inputs are u, there is an old state x, every N ms compute x' = simulate(x, u), send all the x's back out
18:55:01 <Axman6> is the timing important? if you had a shared variable which was updated every time a new input was received, could you just loop and delat 100ms and always send out the most recent value?
18:55:14 <Axman6> is it important clients get the same state in every update?
18:58:55 <Partmedia> I suppose that's okay. Maybe I need to step back and re-think this concurrently. Right now, my model is 1) collect inputs, 2) compute, 3) send out updates. Only (2) compute needs to happen at regular intervals, but the updates could be postponed.
19:01:01 <Axman6> depending on your constraints there are many ways to do this, so it depends on things like how important ordering of things is, do clients need to see a consistent state or can you update every time you get new data. if there's no bound on the number of clients then you won't be able to meet a hard realtime constraint of updating every 100ms
19:01:50 <Partmedia> My number of clients is small, 100 ms is also very soft.
19:02:33 <Partmedia> I do also want to handle some client -> server -> client that should be processed instantly -- would that mean Chan's for every pair of client/client?
19:02:37 <Axman6> well it definitely seems like it's time to read that book, it's excellently written and very approachable
19:03:19 <Partmedia> Fair, thanks for your suggestion.
19:03:36 <Axman6> It's not a suggestion, do it now :P
19:12:39 <L29Ah> do i get it right that hoogle no longer searches hackage?
19:13:45 <L29Ah> and hayoo is dead
19:25:36 <ezzieyguywuf> hm, if I have a `data MyData = MyData (V3 Int) (V2 Int)`, which I typically use as `[MyData]`, but in which I'd also like to encode the 'index' of each vector, i.e. the V3 would be index 0, the V2 would be index 1, how might I go about doing that?
19:26:06 <Axman6> I don't understand what you mean
19:26:17 <ezzieyguywuf> yea, I'm trying to think of a better way to explain it
19:26:29 <Axman6> L29Ah: to my knowledge that isn't true, but I haven't followed how they're progressing
19:27:27 <ezzieyguywuf> let's say `data MyData = MyData { first :: V3 Int, second :: V2 Int}`. I want to associate the number 0 with `first` and 1 with `second`
19:28:06 <ezzieyguywuf> it seems wasteful to put it right inside MyData, because if I have a `[MyData]`, the 1 and 0 would be repeated for ever row, but I really only need it once.
19:28:25 <L29Ah> Axman6: just tried to find formatDateTime in hoogle and it failed
19:28:31 <L29Ah> yet it's in https://hackage.haskell.org/package/datetime-0.3.1/docs/Data-DateTime.html
19:28:39 <Axman6> have you tried stackage?
19:28:39 <ezzieyguywuf> L29Ah: sometimes I have to physically hit the search button for hoogle to work
19:28:56 <Axman6> don't break your screen ezzieyguywuf
19:29:01 <ezzieyguywuf> hah
19:30:19 <L29Ah> ezzieyguywuf: zip [0..] [first, second]
19:31:19 <L29Ah> > lookup 1 $ zip [0..] [first, second]
19:31:21 <lambdabot>  error:
19:31:21 <lambdabot>      • No instance for (Typeable a0)
19:31:21 <lambdabot>          arising from a use of ‘show_M909091096257546795920369’
19:32:50 <ezzieyguywuf> nah, I think I just need to define a `data MyDataTypes = First V3 Float | Second V2 Float`, then I can make a `getIndex :: MyDataTypes -> Int` function
19:33:01 <ezzieyguywuf> that should be easily extensible too
19:46:49 <fog82> i cant get this traversableM to typecheck
19:47:02 <fog82> i cant commute the applicative through the monad properly
19:47:36 <fog82> https://pastebin.com/raw/aDQGymVW
19:48:11 <fog82> I end up with; traverseMDefault :: (StackM t,Monad m) => (a -> m b) -> t m a -> m (t m b)
19:48:35 <fog82> but it should be;
19:48:53 <fog82> traverseMDefault :: (StackM t,Applicative f) => (a -> f b) -> t m a -> f (t m b)
19:49:22 <GreyFaceNoSpace>  toList ((x,i):xs) = (replicate i x) ++ toList xs 
19:49:29 <fog82> either its impossible, in which case the first version is actually an OK type for traverseM
19:49:54 <GreyFaceNoSpace> when i try my function out i get error :     Expected type: [([Char], Int)]
19:49:54 <GreyFaceNoSpace>       Actual type: [([Char], Integer)]
19:50:17 <fog82> :t replicate
19:50:19 <lambdabot> Int -> a -> [a]
19:50:28 <GreyFaceNoSpace> why is [("a",1)] of type [([char],Integer)] 
19:50:47 <fog82> :t [("a",1)]
19:50:49 <lambdabot> Num b => [([Char], b)]
19:50:50 <Axman6> it only is if the compiler can't tell it should be something else
19:50:52 <GreyFaceNoSpace> how do i define an Int and not an Integer
19:51:01 <fog82> :t [("a",1::Int)]
19:51:02 <lambdabot> [([Char], Int)]
19:51:08 <GreyFaceNoSpace> and why is there a difference between Int and Integer?
19:51:25 <L29Ah> because Integer is unlimited
19:51:26 <fog82> % :t toList ((x,i::Int):xs) = (replicate i x) ++ toList xs 
19:51:26 <Axman6> if you just run toList [("a",1)] then that list will be the irght type becausse GHC can tell that 1 is supposed to be an Int
19:51:26 <yahb> fog82: ; <interactive>:1:24: error: parse error on input `='
19:51:38 <Axman6> > 3^132 :: Integer
19:51:40 <lambdabot>  955004950796825236893190701774414011919935138974343129836853841
19:51:43 <L29Ah> while Int is just at least 30 bits
19:51:44 <Axman6> > 3^132 :: Int
19:51:46 <lambdabot>  -7716780536159757743
19:51:46 <fog82> % :t \ ((x,i::Int):xs) -> (replicate i x) ++ toList xs 
19:51:46 <yahb> fog82: ; <interactive>:1:41: error:; * Occurs check: cannot construct the infinite type: a ~ (a, Int); Expected type: [a]; Actual type: [(a, Int)]; * In the second argument of `(++)', namely `toList xs'; In the expression: (replicate i x) ++ toList xs; In the expression: \ ((x, i :: Int) : xs) -> (replicate i x) ++ toList xs; * Relevant bindings include; xs :: [(a, In
19:52:25 <fog82> well, anyway, it needs some way to specialise it from Integer to Int, such as a type annotation, a type signature, or a type application
19:52:33 <GreyFaceNoSpace> Axman6, apparently not... i need to specify the type like so as someone mentioned [("a"),1::Int]
19:52:47 <Axman6> that doesn't look valid
19:52:55 <GreyFaceNoSpace> woops
19:53:03 <GreyFaceNoSpace>  [("a",1::Int)]
19:53:29 <Axman6> if you write what I wrote it will work
19:54:28 <Axman6> > let toList ((x,i):xs) = replicate x i ++ toList xs; toList [] = [] in toList [("a",1)]
19:54:30 <lambdabot>  error:
19:54:30 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
19:54:30 <lambdabot>      • In the expression: "a"
19:54:38 <Axman6> > let toList ((x,i):xs) = replicate i x ++ toList xs; toList [] = [] in toList [("a",1)]
19:54:40 <lambdabot>  ["a"]
19:55:47 <Axman6> :t let toList ((x,i):xs) = replicate i x ++ toList xs; toList [] = [] in toList 
19:55:48 <lambdabot> [(a, Int)] -> [a]
19:58:56 <fog82>  can anyone tell if it should be possible to commute the applicative with the internal monad?
19:58:58 <fog82> https://pastebin.com/raw/aDQGymVW
19:59:39 <fog82> list-t is a synonym with the monad wrapping at the leftmost position, so it should be possible for that type
19:59:48 <fog82> but i guess it would need to be able to do that for every instance
19:59:53 <fog82> i dont know how to write that
20:26:14 <ezzieyguywuf> if I have a [IO ()], how can I reduce that down to a single IO () by just executing each one? `fmap >>` or something?
20:26:31 <ptrcmd> :t sequence_
20:26:33 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
20:26:43 <ezzieyguywuf> ah, thank you
20:28:58 <Axman6> :t foldr (>>) (pure ())
20:28:59 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
20:29:41 <ezzieyguywuf> hah it's the same!
20:29:52 <ezzieyguywuf> I was close with fmap i guess
20:30:06 <ezzieyguywuf> (but not really)
20:30:08 <dsal> functor has to retain the same shape
22:55:49 * hackage netcode-io 0.0.2 - Bindings to the low-level netcode.io library.  https://hackage.haskell.org/package/netcode-io-0.0.2 (Mokosha)
23:27:19 * hackage hkgr 0.2.6 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.6 (JensPetersen)
