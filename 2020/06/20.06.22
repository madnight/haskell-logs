00:13:47 <kiwi_45> anyone ?
00:15:30 <koz_> kiwi_45: You might have to wait a while.
00:15:40 <koz_> It's a quiet time, and your question is fairly specialist/involved.
00:16:16 <kiwi_45> okay koz_
00:26:42 <freeman42x[m]> how can I convert this to pointfree? p s=show$popCount$(read$s::Int)
00:30:19 <ja> @pointless p s=show$popCount$(read$s)
00:30:19 <lambdabot> p = show . popCount . read
00:31:37 <ja> you can use TypeApplications for the Int constraint
00:35:58 <MarcelineVQ> you sure don't like spaces :>
00:41:10 <freeman42x[m]> MarcelineVQ: I am playing Clash of Code for shortest code right now http://twitch.tv/freeman42x
00:41:23 <freeman42x[m]> it is a very good way to learn Haskell functions, etc.
00:50:04 <liiae> what higher-kinded polymorphism could be used for?
00:50:58 <dminuoso> liiae: Monad transformers is an example.
00:51:04 <dminuoso> % :k StateT
00:51:04 <yahb> dminuoso: * -> (* -> *) -> * -> *
00:52:54 <liiae> dminuoso: is monad typeclass an example?
00:53:00 <kiwi_45> ?
00:53:25 <liiae> % :k Reader
00:53:25 <yahb> liiae: * -> * -> *
00:53:42 <dminuoso> liiae: Oh, sorry I misread.
00:54:00 <dminuoso> liiae: Functor is a plain and simple example, already.
00:54:04 <dminuoso> % :i Functor
00:54:04 <yahb> dminuoso: type Functor :: (* -> *) -> Constraint; class Functor f where; fmap :: (a -> b) -> f a -> f b; (<$) :: a -> f b -> f a; {-# MINIMAL fmap #-}; -- Defined in `GHC.Base'; instance [safe] Functor Expr -- Defined at <interactive>:5:55; instance [safe] Functor (Magma i t b) -- Defined in `Control.Lens.Internal.Magma'; instance [safe] Functor (Level i) -- Defined in `Control.Lens.Internal.Level'; instanc
00:54:40 <dminuoso> So something functor polymorphic would have some type `forall (f :: * -> *). Functor f => ...`
00:55:00 <liiae> :t fmap
00:55:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:55:25 <liiae> :k fmap
00:55:27 <lambdabot> error: Not in scope: type variable ‘fmap’
00:58:55 <liiae> dminuoso: I thought I asked you about why Fix Maybe couldn't be other languages like Java, and I may  know why, because Java doesn't support higher-kinded polymorphism, it can't take a type which kind is *->* as class parameter, it can't take List as class parameter
00:59:37 <liiae> and I found Kotlin has a simulation for that https://arrow-kt.io/docs/0.10/patterns/polymorphic_programs/
01:32:23 <maerwald> unix doesn't have printf it seems
01:33:15 <merijn> maerwald: Well, of course not, there's no way you could call it
01:34:18 * hackage ghc-typelits-presburger 0.3.0.1 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  https://hackage.haskell.org/package/ghc-typelits-presburger-0.3.0.1 (HiromiIshii)
01:34:29 <maerwald> ah right, variadic function
01:35:18 * hackage singletons-presburger 0.3.0.1 - Presburger Arithmetic Solver for GHC Type-level natural numbers with Singletons package.  https://hackage.haskell.org/package/singletons-presburger-0.3.0.1 (HiromiIshii)
01:35:31 <maerwald> I suspect Text.Printf is not atomic?
01:36:39 <maerwald> but write(2) with the buffer as big as the string should do
01:38:16 <[exa]> what do you want to output btw? formatting is better done in haskell unless you totally need the C printf formatter
01:38:46 <maerwald> I want thread safe printing to stdout without using mvar
01:38:59 <maerwald> write works
01:39:29 <[exa]> by threadsafe you mean "lines do not start in the middle of other lines"?
01:39:36 <maerwald> yes
01:39:50 <koz_> maerwald: Wait, write(2) guarantees this?
01:40:04 <maerwald> koz_: yes, afais 
01:40:05 <[exa]> man 2 write, section 'BUGS'
01:40:27 <koz_> maerwald: Huh, TIL.
01:40:48 <[exa]> but they apparently fixed it in kernel 3.14
01:42:54 <merijn> maerwald: That's certainly not portable behaviour, though
01:43:11 <[exa]> I'd be very careful about the actual standard it's conforming to
01:43:58 <[exa]> the statement about atomicity from posix1-'08 seems to be contradicted in the same standard
01:57:31 <dminuoso> What's the most lighteweight solution to get minimalistic parsing capabilities (specifically I need to parse a simple version string)? Text.ParserCombinators.ReadP?
02:05:58 <MarcelineVQ> like, Data.List
02:06:05 <merijn> string  patterns and takeWhile :p
02:06:16 <merijn> ReadP is a confusing mess
02:06:18 <dminuoso> merijn: Sprinkled with some read ontop?
02:06:27 <dminuoso> well, readMaybe.
02:06:29 <merijn> Yeah
02:06:44 <maerwald> https://hackage.haskell.org/package/versions-3.5.4
02:06:46 <maerwald> done
02:07:02 <dminuoso> yes, and megaparsec with all its transitive dependencies added.
02:07:04 <dminuoso> not lightweight.
02:08:11 <maerwald> merijn: I'm always boggled between ReadP and ReadS and converting back and forth
02:08:48 * hackage type-natural 0.9.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.9.0.0 (HiromiIshii)
02:10:30 <dminuoso> Also, versions is overkill, I need to parse a specific format, not some generic. :)
02:10:37 <dminuoso> cumulus-linux-4-1-1
02:13:38 <DigitalKiwi> write your own parser https://www.stephendiehl.com/llvm/#the-parser
02:14:13 <DigitalKiwi> or does parsec have a lot of transitives too :/
02:15:43 <DigitalKiwi> doesn't seem as bad as megaparsec
02:16:44 <DigitalKiwi> mniip had some super simple one he used for AoC
02:17:28 <srk> nanoparsec? :)
02:18:03 <srk> parser-combinators is even more lightweight on deps it seems
02:18:29 <DigitalKiwi> was that it? idk
02:18:37 <dminuoso> srk: mmm, parser-combinators might do
02:18:53 <merijn> srk: Because it doesn't actually let you do any parsing :p
02:19:10 <srk> merijn: :D
02:19:42 <dminuoso> gah btw, can cabal generate a dot graph of the package dependency tree?
02:19:57 <merijn> dminuoso: No, but cabal-plan can
02:20:18 <dminuoso> That works nicely
02:25:48 * hackage sized 0.5.0.0 - Sized sequence data-types  https://hackage.haskell.org/package/sized-0.5.0.0 (HiromiIshii)
02:32:39 <dminuoso> Haha, pcre-heavy is in my dependencies already.
02:32:46 <dminuoso> Might as well throw a regex at this.
02:41:13 <subttle> dminuoso: No idea what the context was for that but that's what I like to join and see 8)
02:41:17 <subttle> regex <3
02:42:02 <merijn> dminuoso: >:(
02:48:40 <dminuoso> merijn: Heh, what can I say: linIntPat = [re|^[A-Za-z0-9_\-\.]{1,15}$|]
02:50:08 <dminuoso> Is there a replicateM but with Alternative?
02:51:06 <phadej> in parser-combinators
02:51:30 <dminuoso> Ah perfect, count.
02:51:32 <dminuoso> Thanks.
02:51:49 <dminuoso> (Well, count')
02:51:54 <Taneb> getAlt . stimes n . Alt
02:52:28 <phadej> that is different
02:52:45 <Taneb> Oh, so it is
02:52:56 <dminuoso> But it turns out it's just enough for my use as well.
02:52:59 <dminuoso> I dont need the result.
02:53:23 <phadej> there's a link to https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Applicative-Combinators.html#v:skipCount
02:53:51 <phadej> getAlt . stimes n . Alt is cryptic :)
02:54:19 <Taneb> phadej: if I were Iceland_Jack I'd say something like "stimes @(via Alt)"
02:54:47 <xerox_> how is it different?
02:54:56 <Taneb> count is just replicateM_
02:55:08 <xerox_> ah it is different I see
02:55:34 <dminuoso> skipCount is exactly what I'd want, but I think I can just go with `getAlt . stimes n . Alt` and avoid the extra dependency.
02:55:36 <Taneb> What I suggest is like x <|> x <|> x <|> x
02:55:41 <dminuoso> parser-combinators does not appear to be my dependency tree yet.
02:55:48 <Taneb> Like, they are very different
02:56:14 <Taneb> skipCount is x *> x *> x *> x
02:56:17 <xerox_> :t (asum .) . replicate
02:56:18 <lambdabot> Alternative f => Int -> f a -> f a
02:56:29 <dminuoso> Mmm.
02:57:01 <Taneb> dminuoso: which of these two behaviours is what you want?
03:07:00 <basic> is there a better description for deriving mechanisms than "it's sort of magic" ?
03:07:26 <Uniaika> e/29
03:07:29 <Uniaika> (woops)
03:08:10 <merijn> basic: I think the report defines how to derive them
03:08:11 <dminuoso> basic: What do you mean by "deriving mechanisms"?
03:08:25 <basic> i mean what happens if i say deriving show
03:08:35 <basic> how does ghc know how add the instance
03:08:42 <merijn> basic: It's just pretty mechanically deriving an implementation
03:09:03 <basic> and what does that mean ? is it like a c++ macro inserting the code
03:09:09 <basic> before compiling
03:09:26 <basic> (sure it isn't)
03:09:26 <merijn> basic: "for every constructor, use the string matching it's name, for every field, use the show instance of that field" with some logic for separating fields, etc.
03:09:59 <basic> so it is kinda like that?
03:10:06 <merijn> basic: It's not inserting code "before compiling" the compiler is just inserting the relevant code *during* compiling, because it has logic for how to generate that code for specific classes (as defined by the report)
03:10:13 <dminuoso>  basic  https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4
03:10:45 <basic> merijn: same thing, really?
03:10:55 <merijn> basic: Yes, no, maybe? ;)
03:11:31 <dminuoso> basic: The compiler has many phases. :)
03:11:53 <dminuoso> It doesn't really matter when it happens, as thats just a GHC internal detail.
03:12:04 <merijn> basic: There's not a lot of magic in deriving, tbh. For example the Ord instance just orders based on the order you defined constructors in
03:12:47 <merijn> basic: Similarly, Eq is just "compare constructors and if those match, compare each field pointwise"
03:15:44 <__monty__> How do deriving via and generic deriving work?
03:17:43 <dminuoso> https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/deriving_via.html
03:20:29 <boxscape> generic deriving? Does that refer to DeriveAnyClass?
03:21:38 <merijn> boxscape: No, DeriveGeneric derives a Generic instance for a datatype (which can then be used to provide default implementations for a typeclass)
03:21:39 <dminuoso> Im thinking it refers to DeriveGeneric ;)
03:21:59 <boxscape> oh, deriving *of* generic instead of deriving *by means of* generic, got it
03:22:38 <dminuoso> __monty__: And deriving generic is best covered in https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Generics.html#t:Generic
03:22:45 <dminuoso> (It's not as important as what GHC does, as it is what you get)
03:24:07 <dminuoso> Essentially there exists a `class Generic a where type Rep a :: Type -> Type; from :: a -> (Rep a) x;  to :: (Rep a) x -> a`, and GHC will generate an appropriate instance, such that you can use it as documented in the haddock.
03:24:45 <dminuoso> (Or Generic1 for differently kinded things)
03:27:53 <boxscape> Oh, just realized, for some reason I thought the default implementations used typically used in classes used for DeriveAnyClass tend to use Generic, but that's not true, is it
03:29:11 <dminuoso> boxscape: Its not, DefaultAnyClass is useful for classes like FromJSON that has a default implementation.
03:29:16 <boxscape> ok
03:29:18 <dminuoso> *DeriveAnyClass
03:29:31 <dminuoso> You could then just write `data Foo = .... deriving FromJSOn`
03:31:04 <boxscape> though actually the user guide does have one example where the default uses Generic and then says it can be used with DeriveAnyClass, so maybe it is sometimes used? https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-defaults
03:32:25 <boxscape> also is the readthedocs version of the user guide going to replace the other one?
03:33:48 <boxscape> (actually deriving FromJSON would likely also require Generics, no?)
03:43:06 <dminuoso> boxscape: yes.
03:56:42 <timCF> Hi guys! I'm curious how to use `GeneralizedNewtypeDriving` with standard classes like `Read`. Then thing is if even I'm using this extension for `newtype Foo = Foo Int deriving (Read)` for some reason Read is derived like it was without extension, it expects string like "Foo 42" but I want to read from just "42"
03:57:10 <boxscape> timCF By default it uses the stock deriving strategy, you can turn on DerivingStrategies and write "deriving newtype Read"
03:57:41 <boxscape> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-strategies
04:01:07 <timCF> boxscape it worked! Thanks!
04:52:48 <A1kmm> My Hackage uploads seem to fail to build documentation due to errors like: "hClose: resource exhausted (No space left on device)" - https://hackage.haskell.org/package/polysemy-webserver-0.2.0.0/reports/3
04:53:00 <A1kmm> Is this a known issue?
04:53:20 <A1kmm> I see some other builds are succeeding.
04:54:48 * hackage yesod-test 1.6.10 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.6.10 (MichaelSnoyman)
04:58:56 <Athas> I'm trying out the 'stan' static analyser on my program.  It is really upset about my use of 'length'!
05:00:01 <merijn> Athas: To be fair, they do describe it as a very *opinionated* analyser ;)
05:00:06 <Athas> I say.
05:00:18 <Athas> And I thought hlint was picky.
05:00:52 <Athas> Oh wow, it apparently warns on all lazy constructor fields.
05:01:03 <merijn> Athas: What, really?
05:01:15 <merijn> That's dumb
05:01:18 <Athas> "Defining lazy fields in data types can lead to unexpected space leaks"
05:01:23 <Athas> That sure is An Opinion.
05:01:39 <cocreature> “writing code can lead to space leaks, please delete all code”
05:01:42 <merijn> Now I feel doubly justified in my initial assessment that it was "Not For Me"
05:02:00 <merijn> cocreature: Demanding code to be written can lead to space leaks too
05:03:10 <merijn> Athas: Oh, it seems they object to Foldable.length
05:03:20 <Athas> Indeed.
05:03:27 <merijn> The standard FTP whining
05:04:07 <Athas> I like these kinds of tools best when they warn me about stuff that I already know, but make me feel bad enough to actually fix them.
05:04:10 <basic> what do i do if a function has 1 parameter, and 2 different values for that parameter & i want to have one where block for both
05:04:14 <Athas> Like, 'stan' also does not like nub.
05:04:29 <Athas> basic: pattern guards.
05:04:43 <basic> | this = stuff ?
05:04:57 <merijn> yeah
05:04:59 <Athas> Yes.  Define your function with one clause, and use pattern guards to handle the different values for that parameter.
05:05:08 <basic> very explicit for that case i guess
05:05:39 <Athas> Note that you can do pattern matching inside of pattern guards, not just boolean checks: | Just x <- foo
05:05:43 <__monty__> basic: : more | like <- this = example
05:06:07 <basic> __monty__: i don't follow i tried
05:06:12 <basic> value | expression
05:06:35 <ph88> how can i fmap two data constructors ?
05:06:49 <Athas> One at a time.
05:06:56 <Athas> Or do you mean two deep?
05:06:58 <merijn> basic: Something like here https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Query/Variant.hs#L70-L89
05:06:59 <__monty__> basic: function arg | Constructor field <- arg = body
05:07:24 <merijn> The great thing about having a non-trivial codebase is that I can now easily show real world examples of stuff :p
05:07:33 <Athas> Note that merijn's example also uses ViewPatterns, which is an extension.
05:07:36 <ph88> Athas, data A = A B   data B = B Int    i have an Parser Int and i want a  Parser (A (B Int))
05:07:51 <basic> and what if my datatype has no <-
05:07:53 <Athas> ph88: fmap (A . B)
05:07:59 <ph88> thanks
05:08:32 <__monty__> basic: What do you mean? <- is the syntax you use for a pattern guard, as opposed to the boolean expression you'd use in most gualds.
05:08:44 <basic> im confused, i will try
05:09:17 <basic> do you have a simpler example maybe?
05:10:00 <__monty__> basic: head xs | (x:_) <- xs = x
05:10:18 <ph88> Athas, i find that it doesn't work quite right when i also use <*> https://bpa.st/ZLEA 
05:10:35 <basic> yeah but list has (>>=) i get why that works
05:11:16 <merijn> basic: That <- is unrelated to do notation and to Monad
05:11:30 <basic> hm still confused
05:11:42 <basic> data X = A | B
05:12:13 <basic> how would i have a function that has this datatype inside it's guards?
05:12:28 <Athas> ph88: ah, if the inner constructor takes multiple arguments, then you need to do it the manual way: A <$> (B <$> ... <*> ...)
05:12:38 <merijn> "foo x | A <- x = {- stuff here -}"
05:13:03 <__monty__> basic: Here's detailed documentation: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
05:13:13 <ph88> Athas, ye i don't like parathesis, maybe   fmap A $ fmap B $  ?
05:13:22 <ph88> i'll give that a try, thanks
05:13:24 <__monty__> basic: It's just syntax, nothing to do with do-notation.
05:14:28 <merijn> basic: Although in that example you could also just use case
05:14:41 <merijn> basic: "foo x = case x of A -> stuff; B -> otherStuff"
05:17:55 <basic> yeah sure that would work
05:18:18 <ph88> how come this code seems to run in another monad then IO monad and i get a bunch of errors related to that ? https://bpa.st/BIAA 
05:18:34 <basic> but i figured since there is function definition with a concrete value
05:18:42 <basic> i figured there mgiht be one, where you can share the "where" block
05:20:01 <boxscape> basic you can share a "where" block both with the case expression and with pattern guards
05:21:25 <basic> yeah but pattern guards make it really expressive (because i have to write param == Value
05:21:31 <basic> or <-, same thing, really
05:21:40 <basic> and case, yah well, that one looks ugly :D
05:22:19 <boxscape> basic if you only have one parameter you can also use lambdacase
05:22:23 <boxscape> or LambdaCase rather
05:22:44 <boxscape> then you can write `f = \case A -> ... {newline} B -> ...'
05:23:17 <boxscape> though both case and LambdaCase only work if it's the last equation of the function
05:30:55 <__monty__> basic: I usually just use a case expression.
05:31:53 <basic> yeah i guess i will do the same
05:31:59 <basic> but i figured since f A = 1 exist
05:32:03 <basic> there might be
05:32:08 <__monty__> And I also put many things that could go in a where clause on the top level, if there's any chance I might use them more than once, like in multiple where clauses.
05:32:13 <basic> f; A | 1; b | 2; etc
05:34:11 <boxscape> that's what \case is trying to do, basically, except with longer syntax
05:34:57 <boxscape> (specifically \case rather than case)
05:46:37 <kiwi_45> Hello all, I need help with Authentication with cookies in my servant app. I read the docs in hackage of servant-auth  but that is not clear (at least for me). Can someone please help me? what I want to do is . I have login mechanism in postgres and also integrated redis to store generated sessionId  now after login I want to pass the generated
05:46:37 <kiwi_45> session id to browser as a cookie so that in future that request could be checked for session id and access could be given. Please help me I have deployed enough time on this but no luck yet. I might me missing something . Thanks in advance :pray:
05:47:08 <kiwi_45> my repo : https://github.com/DeepakKapiswe/Gyan-Lahari-Backend
05:53:57 <dminuoso> kiwi_45: So provide a login mechanism that sets said cookie.
05:54:29 <dminuoso> kiwi_45: Then just protect the rest of your endpoints with `Auth '[Cookie]`?
05:55:33 <kiwi_45> dminuoso: I can provide that in frontend, I'm missing or not understanding how to do it with servant part, i.e how to use `Auth [Cookie]`
05:57:27 <dminuoso> https://github.com/haskell-servant/servant-auth#readme has some examples
05:58:38 <kiwi_45> dminuoso: Thanks for the pointer, I read those so many time but I'm unable to modify it to my use case 
06:00:14 <dminuoso> kiwi_45: so the idea is roughly this:
06:00:39 <dminuoso> kiwi_45: You take `Auth xs Result`, which wraps some arbitrary (set of) endpoint(s) to require authentication.
06:00:59 <dminuoso> xs is some list of methods that are admissable, e.g Cookie, JWT or BasicAuth
06:01:08 <dminuoso> Result is an arbitrary type of your chosing
06:02:02 <dminuoso> More specifically, whatever you specify as *Result* becomes the argument to https://hackage.haskell.org/package/servant-auth-server-0.4.5.1/docs/Servant-Auth-Server.html#t:AuthResult later
06:02:14 <dminuoso> Usually this will be some `data User = ...` that you have defined.
06:02:33 <kiwi_45> yeah
06:02:50 <kiwi_45> upto this I got
06:02:58 <dminuoso> Once you wrap an endpoint or more with `Auth xs Result`, you get an additional argument of type `AuthResult Result -> ...`
06:03:03 <dminuoso> (So each endpoint gets access to that user)
06:03:08 <dminuoso> For each of your handlers
06:03:35 <kiwi_45> and  we only proceed if we get `Authenticated User`
06:04:43 <dminuoso> From what I can tell, no.
06:04:48 <dminuoso> It's up to you to handle it.
06:05:03 <kiwi_45> yeah thats okay I got
06:05:17 <dminuoso> So there's a good reason to wrap this *outside*
06:05:18 <dminuoso> e.g.
06:05:38 <dminuoso> Auth L T (E1 :<|> E2 :<|> E3 :<|> E4)
06:06:13 <kiwi_45> I am more confused towards the setting and conf side, and also how do I set a cookie in response so browser can use it
06:06:32 <dminuoso> (Because then you only need to handle it once, otherwise if you distribute it over the individual endpoints like `Auth L T E1 :<|> Auth L T E2 :<|> Auth L T E3 :<|> Auth L T E4` you have to handle it on each handler.
06:06:44 <dminuoso> What is "setting and conf side"?
06:07:44 <dminuoso> https://github.com/haskell-servant/servant-auth#cookies
06:07:48 <dminuoso> Has an example on how to set cookies
06:07:50 <kiwi_45> I got your distribution part that is okay too, by conf I mean the extra setup which I need to do to play with Auth / cookie / jwt
06:09:17 <dminuoso> You just include it on the type level, and thats it.
06:09:56 <dminuoso> oh
06:10:03 <dminuoso> you mean how to consume the Auth?
06:10:10 <dminuoso> Yeah the readme is a bit unclear on this
06:10:12 <dminuoso> https://github.com/haskell-servant/servant-auth/blob/master/servant-auth-server/src/Servant/Auth/Server.hs
06:10:16 <dminuoso> The haddock has documentation on it
06:10:28 <dminuoso> https://hackage.haskell.org/package/servant-auth-server-0.4.5.1/docs/Servant-Auth-Server.html
06:11:55 <kiwi_45> not consuption per say, but actually say I generated session id now I want to set it as a cookie and send back as a response header so the browser can include it in next requests
06:18:18 * hackage pantry 0.5.1.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.5.1.0 (MichaelSnoyman)
06:18:53 <dminuoso> kiwi_45: Well that is actually described in the readme
06:19:15 <kiwi_45> and I a'm actually confused there only
06:19:16 <dminuoso> The somewhat annoying thing about the library, is that all the configuration on the authentication handlers is done via global instances..
06:20:19 <dminuoso> What are you confused about
06:24:27 <zincy_> Is the Decimal type essential based on floating point arithmetic?
06:24:50 <dminuoso> zincy_: Decimal is not a base data. Which package are you referring to?
06:27:32 <zincy_> Just the Decimal package
06:27:54 <merijn> zincy_: I dunno, what do the docs say? :p
06:28:06 <zincy_> Looks like it is based on a mantissa and exponent which is basically scientific notation
06:28:09 <merijn> zincy_: Incidentally, do you just want/need a fixed precision type?
06:28:42 <zincy_> merijn: Just wondering how accurate calculations in Decimal are?
06:28:45 <merijn> Because there's Data.Fixed in base
06:28:52 <kiwi_45> dminuoso: about which setting and configuration to do to use cookie and jwt , and also in this line from example of readme ```checkCreds :: CookieSettings
06:28:53 <kiwi_45>            -> JWTSettings
06:28:53 <kiwi_45>            -> Login
06:28:54 <kiwi_45>            -> Handler (Headers '[ Header "Set-Cookie" SetCookie
06:28:54 <kiwi_45>                                 , Header "Set-Cookie" SetCookie]
06:28:55 <kiwi_45>                                NoContent)```
06:28:56 <merijn> Which has exact fized precision
06:29:09 <zincy_> So is decimal just Double with variable precision?
06:29:15 <merijn> > 0.5827 :: Deci
06:29:17 <lambdabot>  0.5
06:29:17 <merijn> > 0.5827 :: Centi
06:29:19 <lambdabot>  0.58
06:29:20 <merijn> > 0.5827 :: Milli
06:29:22 <lambdabot>  0.582
06:30:11 <zincy_> So variable precision is just having a flexible length of mantissa
06:30:21 <merijn> zincy_: Looks like it's using decimal IEEE-754, yes
06:31:18 <zincy_> merijn: Thanks
06:31:51 <L29Ah> @src Deci
06:31:51 <lambdabot> Source not found. Take a stress pill and think things over.
06:31:52 <merijn> zincy_: There's a number of alternatives depending on what you need
06:31:58 <zincy_> Is the reason that floating point isn't accurate purely the fact that you are approximating a number with what is essentially scientific notation
06:32:04 <merijn> L29Ah: Deci/Centi/Milli are type aliases around Data.Fixed
06:32:05 <L29Ah> @info Deci
06:32:05 <lambdabot> Deci
06:32:12 <L29Ah> merijn: thanks
06:32:17 <merijn> L29Ah: Which allows customisable precision
06:32:36 <zincy_> I was having a discussion with someone and they insisted that if you use base 10 instead of base 2 then suddenly calculations are accurate
06:32:43 <merijn> zincy_: Well, consider this: a 64 bit floating point value only has 2^63 - 1 unique possible values
06:32:50 <zincy_> My understanding is that the base is unrelated to the issue
06:32:54 <zincy_> of accuracy
06:32:58 <merijn> zincy_: Given that there's infinite actual numbers, clearly precision can't be exact
06:33:10 <merijn> zincy_: That person was wrong
06:33:28 <zincy_> I thought so I just didn't trust myself enough hehe
06:33:30 <L29Ah> or zincy_ is missing some of that context
06:33:34 <merijn> zincy_: The precision issue comes from mapping an infinite set of values to a limited finite subset
06:33:56 <zincy_> L29Ah: What context?
06:33:58 <L29Ah> as changing the base can in fact improve precision in a limited amount of cases
06:34:11 <merijn> L29Ah: Yeah, but you worsen in others
06:34:18 <merijn> So netto you don't gain precision
06:34:30 <zincy_> Yeah you move the precision about and how can you predict if it will help or hinder?
06:34:51 <merijn> zincy_: Which values can be represented accurately depends on the base, so there are values that can be exact in a base 10 floating point representation, but aren't in base 2
06:35:07 <zincy_> Right
06:35:07 <boxscape> > 0.1 + 0.2 -- presumably the result of this is wrong because of binary precision, but binary-favoring calculations would become incorrect in the same way by using base 10, I think
06:35:10 <lambdabot>  0.30000000000000004
06:35:12 <merijn> zincy_: But then there's also values which can be exact in base 2, but aren't in base 10, so now you're just shifting your error around
06:35:18 <L29Ah> zincy_: say, if you know you only plan to divide stuff by some number, then you can use that number as a base to get perfectly precise results
06:35:19 <boxscape> s/precision/representation
06:35:41 <merijn> > 0.1 + 0.2 :: Rational -- you just need to use the right type :p
06:35:43 <lambdabot>  3 % 10
06:35:57 <merijn> > 0.1 + 0.2 :: Deci
06:35:58 <lambdabot>  0.3
06:36:18 <zincy_> Is 1/3 a case where you wouldn't get precision with base 10 
06:36:31 <zincy_> Yes
06:36:37 <L29Ah> perfect precision, yes
06:36:43 <kiwi_45> dminuoso: I’m stuck, and I could not figure it out how can I change the given example on readme to my use case, I need to see a minimal example setup of using cookie with servant which I can’t find online, my level of understanding is not that high in this field.
06:36:44 <merijn> Rational always has perfect precision
06:36:56 <boxscape> for rational numbers :)
06:37:08 <dminuoso> kiwi_45: I agree the documentation is quite poor.
06:37:11 <merijn> Sure, but hey, that's a whole lotta numbers! ;)
06:37:32 <dminuoso> kiwi_45: Only reason I can work my way through is because I understand how servant works. :<
06:37:36 <zincy_> Selling one apple for pi dollars.
06:38:13 <zincy_> Although pi grams of gold would probably be fairer
06:38:16 <dminuoso> kiwi_45: So essentially setting cookies amounts to adding `Headers '[Header "Set-Cookie" SetCookie]` to the result type of the handler.
06:38:18 <kiwi_45> dminuoso: with me I don't know exactly how servant works, just guess and do,
06:38:19 <zincy_> as you cannot have less than a cent
06:39:09 <kiwi_45> dminuoso : okay so I add that extra type info to my protected endpoints
06:39:13 <boxscape> selling one apple for Chaitin's constant of dollars would be more challenging still
06:39:32 <AWizzArd> dminuoso: this HaskellNet-SSL package worked nicely, we can send mails now. However, we had to deactivate the certificate check. Did you import the AWS certs?
06:40:26 <dminuoso> kiwi_45: not protected ones, but unprotected ones.
06:40:30 <dminuoso> kiwi_45: You want this on just the login endpoint.
06:41:04 <kiwi_45> dminuoso : okay got this
06:41:04 <dminuoso> AWizzArd: Use `openssl s_client -connect` and see whether the certificate chain is setup correctly.
06:41:30 <zincy_> Strings are easier to parse than numbers
06:41:35 <zincy_> I have heard it all now :)
06:41:43 <dminuoso> kiwi_45: and then you use the `addHeader` primitive...
06:41:48 * hackage vulkan 3.5 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.5 (jophish)
06:42:07 <AWizzArd> dminuoso: I remember from the older days, on the JVM, that the runtime already included a set of certificates. Is that also true for GHC? Does it somewhere ship signatures that are trustworthy?
06:42:12 <L29Ah> tfw the best cli tls client/debug tool is a reverend hellhole
06:42:24 <dminuoso> kiwi_45: The reason you dont see that `addHeader` primitive, is because its done implicitly by `applyLogin`
06:42:28 <zincy_> What if I told you the numbers are used to represent strings 
06:42:49 * hackage VulkanMemoryAllocator 0.3.3 - Bindings to the VulkanMemoryAllocator library  https://hackage.haskell.org/package/VulkanMemoryAllocator-0.3.3 (jophish)
06:42:53 <L29Ah> AWizzArd: no it doesn't
06:44:55 <dminuoso> AWizzArd: It's not GHCs business, it'd be the responsibility of the library.
06:44:59 <kiwi_45> dminuoso: yeah I have seen `applyLogin` but not `addHeader`
06:46:08 <dminuoso> kiwi_45: Right, and that uses addHeader
06:46:39 <dminuoso> kiwi_45: https://hackage.haskell.org/package/servant-auth-server-0.4.5.1/docs/src/Servant.Auth.Server.Internal.Cookie.html#acceptLogin
06:47:19 * hackage jira-wiki-markup 1.3.2 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.3.2 (tarleb)
06:47:33 <dminuoso> And it sets 2 headers, which helps explain why it says `Headers '[Header "Set-Cookie" SetCookie, Header "Set-Cookie" SetCookie]`
06:47:48 <dminuoso> But really, you can ignore that code.
06:47:57 <dminuoso> Just use addHeader yourself and then you're good to do.
06:48:09 <zincy_> L29Ah: When you you every be able to guarantee ahead of time that you will only ever divide by some number?
06:48:17 <zincy_> Do you have any examples?
06:48:22 <zincy_> *ever
06:48:49 <kiwi_45> dminuoso: the type sig of accepLogin was such that I could not afford to read it :)
06:49:26 <dminuoso> kiwi_45: It's quite.. thick indeed.
06:50:46 <ezzieyguywuf> wow, reading up on Conduit, it's very neat
06:51:16 <dminuoso> kiwi_45: You can imagine it has the type: `ToJWT session => CookieSettings -> JWTSettings -> session -> IO (Maybe (r -> Headers '[Header "Set-Cookie" SetCookie, Header "Set-Cookie" SetCookie] r)
06:51:27 <dminuoso> Missed a closing parenthesis I think.
06:51:29 <AWizzArd> L29Ah: okay, so maybe this is part of the `connection` package. I haven't looked at it yet.
06:51:44 <dminuoso> kiwi_45: So set `r` to be an arbitrary result, maybe NoContent for you.
06:51:45 <dminuoso> Then this becomes:
06:52:03 <dminuoso> ToJWT session => CookieSettings -> JWTSettings -> session -> IO (Maybe (NoContent -> Headers '[Header "Set-Cookie" SetCookie, Header "Set-Cookie" SetCookie] NoContent)
06:52:16 <dminuoso> Which, if we pretend NoContent to be () and optimize it away, is just equivalent to:
06:52:34 <dminuoso> ToJWT session => CookieSettings -> JWTSettings -> session -> IO (Maybe (Headers '[Header "Set-Cookie" SetCookie, Header "Set-Cookie" SetCookie] NoContent))
06:53:05 <dminuoso> The point of this overly polymorphic thing, is because it just "adds two headers", regardless of whether any headers are already present or not.
06:53:19 <kiwi_45> why two times `Header "Set-Cookie" SetCookie` ?
06:53:30 <dminuoso> kiwi_45: Because it sets two cookies
06:53:54 <dminuoso> (one xsrf cookie and one session cookie)
06:54:27 <kiwi_45> yeah from here `return $ Just $ addHeader sessionCookie . addHeader xsrfCookie`
06:54:35 <kiwi_45> okay got it
06:54:48 <dminuoso> kiwi_45: So this thing gives you a "transformation function" that adds two headers to whatever result you have in your hand.
06:55:24 <dminuoso> In all likelihood that result is going to be NoContent, but the library author cant assume that. Maybe you're returning valuable information, or maybe you actually have some other header set already.
06:55:25 <kiwi_45> so this is the point where I can add a response header in response through cookie
06:55:51 <dminuoso> kiwi_45: Well, just do it yourself..
06:56:07 <kiwi_45> dminuoso: Thanks a lot I got this part now
06:56:14 <dminuoso> kiwi_45: use addHeader 
06:56:54 <kiwi_45> dminuoso: in `login` handler ?
06:57:05 <dminuoso> kiwi_45: Yes.
06:57:22 <kiwi_45> okay
06:59:01 <dminuoso> kiwi_45: You quickly get to the point where you dont need servant-auth though if you roll it on your own.
06:59:32 <dminuoso> Most of servant-auth-server appears to be designed to use JWT serialized sessions from what I can tell
06:59:51 <kiwi_45> Thanks a lot for helping me, I'm really feeling confident now, can I also give you more burden of guiding me about cookie setting and jwt setting
07:00:25 <dminuoso> Honestly, Id just roll it on my own.
07:01:13 <dminuoso> But then again typeclass-fu doesnt scare me..
07:01:18 <kiwi_45> JWT serialised session, Authorization bearer, I don't know about it now, but I need to learn it as I need to have a secured system with multiple authorization levels and also payment procedure in my app.
07:01:55 <dminuoso> kiwi_45: My two cents is this: If you are not ready to dissect this library, dont use it.
07:02:05 <dminuoso> Especially since you're saying that this is going to be payment-related.
07:02:22 <kiwi_45> dminuoso: you can roll your own thats great of you
07:03:00 <kiwi_45> dminuoso : yeah in future I will require to add payment gateways but not now
07:09:02 <dminuoso> kiwi_45: What do you want to know about cookie/jwt settings?
07:09:47 <dminuoso> Do note, that there's no customizable cookie authentication with this. This is some library with 3 choices, and you either have some "JWT", "Cookie/JWT" or "BasicAuth" scheme. And only the last one is customizable (and you dont even if need servant-auth if thats all you care about)
07:13:56 <dminuoso> merijn: Gah! I finally decided you are right, regarding ADTs with loads of maybes... Im sprinking type families ontop of this.
07:15:26 <dminuoso> Just need singletons now..
07:19:07 <kiwi_45> dminuoso : okay I think I have got enough input from you to get started with playing with Auths and cookies with servant, So thanks a lot and let me try, where can I reach you If got stuck again somewhere If you would be happy to help me again ?
07:21:18 <kiwi_45> dminuoso : can you guide me in which way I should proceed If I want to build a secure system which can also handle payment procedures ? I thought to add some encryptions but as I'm completely new to web so I might be missing track.
07:21:33 <dminuoso> kiwi_45: Get a senior on your team that knows how.
07:21:49 <kiwi_45> about knowledge of servant: I just use it and learn it on the way
07:21:50 <dminuoso> Security is a thick forest of things to juggle around.
07:23:08 <kiwi_45> dminuoso: no one on the team yet, I'm building something for my local community as charity and also for learning after being vacant as a Haskell Developer:)
07:26:05 <dminuoso> kiwi_45: Well then I wouldnt handroll this on your own, use the premade primitives from servant-auth.
07:26:39 <dminuoso> Or dissect them and understand the details, why applyLogin sets an xsrf token for example.
07:26:53 <kiwi_45> dminuoso : okay
07:27:03 <dminuoso> From the looks of it, servant-auth is a drop-in solution that adds exactly what you want.
07:27:23 <dminuoso> You can pretty much copy and paste the code, the only spot you need to modify
07:27:25 <dminuoso> is 
07:27:34 <dminuoso> `let usr = User "Ali Baba" "ali@email.com"`
07:27:58 <kiwi_45> okay I will plug my auth logic there
07:28:06 <dminuoso> That should probably do some checking against a database instead, and fail accordingly.
07:28:18 <kiwi_45> yeah
07:31:18 * hackage matrix-sized 0.1.1 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.1.1 (kaizhang)
07:32:48 * hackage stackcollapse-ghc 0.0.1.1 - Program to fold GHC prof files into flamegraph input  https://hackage.haskell.org/package/stackcollapse-ghc-0.0.1.1 (rzeznik)
07:34:53 <kiwi_45> dminuoso : Thanks a lot man, I was stuck understanding this part from quite long , its really nice you help me a lot. We need more people like you.
07:35:31 <dminuoso> Or maybe you need to get acquainted with servant! :-)
07:36:16 <kiwi_45> dminuoso : it will be done in near future
07:36:18 * hackage derive-lifted-instances 0.1 - Derive class instances though various kinds of lifting  https://hackage.haskell.org/package/derive-lifted-instances-0.1 (SjoerdVisscher)
07:53:33 <ph88> how come this code seems to run in another monad then IO monad and i get a bunch of errors related to that ? https://bpa.st/BIAA 
08:01:10 <Cale> ph88: Not quite enough context for me to work out what's going on, but what's the type of uniform?
08:01:45 <Cale> also, you have that if-expression there, I'm guessing used_lines' is not an IO action
08:01:51 <Cale> but it had better be, given where it is
08:02:58 <Cale> If it's a list (as its name somewhat suggests), then that would explain the type errors
08:03:44 <Cale> ph88: An important thing is that all the statements in any given do-expression must be actions in the same monad.
08:44:48 * hackage esqueleto 3.3.3.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.3.2 (parsonsmatt)
09:29:32 <VisionIncision> I think I just accidentally pasted a register command in here
09:30:10 <monochrom> I didn't see it.
09:31:31 <VisionIncision> Thanks, I just checked the log and it's not there. Might be because I changed my nick before going back here. Mini heart attack over.
09:35:11 <sm[m]> --ghc-options=-fforce-recomp will force recompilation of your local packages only, not all deps, right ?
09:42:44 <cjay> has it ever been considered allowing if without else in do-blocks? I find myself often having to change if into when or when into if, which is rather unergonomic because it almost always requires adding parentheses, $, sometimes changing indentation..
09:43:33 <monochrom> No.
09:44:32 <monochrom> Perhaps use "bool" for robustness against these changes.
09:45:19 <cjay> meh
09:45:46 <cjay> I think a slight mitigation would be to always use () around the condition for if in do-blocks
09:46:20 <cjay> (probably resulting in hlint complaining a lot
09:47:30 <monochrom> Or don't change if to when.
09:48:23 <cjay> true, ignoring tools complaining about "else return ()" is another option
09:48:51 <monochrom> This is why I don't even use hlint.
09:49:07 <nshepperd2> (hlint is terrible)
09:49:10 <monochrom> I could use it, but I would be turning off 90% of its options.
09:49:37 <cjay> I see, I should do this too :)
09:50:13 <monochrom> Is there a C lint-thingie that looks at "while (...) { one_single_stmt; }" and warning you about redundant {}?
09:50:43 <monochrom> "hlint" is a misleading, misrepresenting name.
09:51:16 <monochrom> C lint warns about real beginner bugs like "if (x=0)".
09:51:34 <ja> in javascript it used to be really popular to 'minify' programs, and it would removed braces too
09:51:36 <nshepperd2> you could let cond = flip bool; and switch between 'when c foo' and 'cond c foo bar'
09:51:39 <monochrom> hlint warns about "(\x -> x + 1)" which is never a bug.
09:51:52 <monochrom> merely anal peephole style
09:52:11 <ja> and do all kinds of nasty dynamic tricks like using ternary expressions for all kinds of things
09:52:32 <ja> seems like there is at least one minifier for c too: https://github.com/Scylardor/cminify
09:53:26 <cjay> ja: yeah, but nobody ever works with the minified output. except reverse engineers.
09:54:30 <ja> i know, but that is only because of things like shortening variable names. if the minifier has options for every feature, it should be possible to get the "remove uncessary scopes" feature alone
09:55:15 <enikar> if you complain about hlint, you should try pytlint in python or rubocope in ruby.
09:55:47 <enikar> *rubocop
09:55:57 <monochrom> haha that's a cool name
09:55:59 * dsal can't rubocope
09:56:27 <ja> it's not cool anymore because defund the police! ;)
09:56:49 <cjay> so there's a human brain trapped inside that tool :>
09:56:55 <ja> https://github.com/rubocop-hq/rubocop/issues/8091
09:57:41 <VisionIncision> I think the name of the linter is the only thing I like about Ruby.
09:57:53 <dsal> hlint has taught me a few things that are useful.  I don't tend to look at it like "what am I doing wrong?" but "are there better ways to do some of these things?"  There are a couple of cases where I disagree, though.  e.g., it recommends a newtype instead of data when I don't want a newtype and "unwords" or something.
09:59:04 <cjay> my mistake was always having it turned on in the editor. it's on by default in spacemacs iirc.
09:59:28 <cjay> running it occasionally to see if it has anything interesting to say should be fine
10:00:00 <dsal> Yeah, the only problem with that is that I forget to run it at the right times.  I just need the thing that runs it at the right time.
10:00:37 <enikar> I don't always follow hlint advice. But I always use it.
10:04:49 <monochrom> You need a tool with a human brain inside to run hlint at the right time. :)
10:05:05 <enikar> :)
10:05:25 <dsal> Huh.  Like a TA?
10:11:27 <ja> put it in cron!
10:16:18 * hackage rounded-hw 0.1.0.0 - Directed rounding for built-in floating types  https://hackage.haskell.org/package/rounded-hw-0.1.0.0 (aratamizuki)
10:16:19 <bolti[m]> Hi, I'm using arch and I want to install pandoc. I've heard that there are problems because of static linking in arch. How should I install pandoc? I'm also learning haskell, so I don't want problems with my programs and pandoc
10:17:48 <_bo> Guys, if I want to create an edge case in a function, can I do as such? "fibonacci 2 = [0, 1]"
10:17:55 <srk> bolti[m]: with nix :)
10:18:39 <_bo> I get "Non type-variable argument" error this case
10:20:09 <dolio> There shouldn't be problems just installing pandoc on arch, right? The issues people have are with using whatever arch provides for development.
10:20:53 <dolio> And having pandoc installed doesn't require you to use their Haskell stuff for development.
10:22:24 <enikar> _bo: what is the signature of the function: fibonacci ?
10:22:26 <bolti[m]> so it's okay to install it witg pacman?
10:23:14 <ja> bolti[m]: what kinda problems are you worried about? i don't think it is likely that any cabal build will disturb your pacman installed pandoc. but since you are learning haskell, you can just use ghcup and forget about all arch specific details. depends how loyal you are to your distro i guess :P
10:23:36 <bolti[m]> I installed ghc with ghcup
10:23:43 <bolti[m]> so cabal
10:23:49 <_bo> enikar: sorry, my bad, just found the error myself, further in the fuction I was doing "fibonacci n - 1" when it should've been "fibonacci (n - 1)". It couldn't understand how I'm substracting 1 from list :)
10:24:21 <enikar> _bo: ok
10:24:27 <bolti[m]> I want to install pandoc, but then I realise that pacman install many haskell libraries, and that's why I get worried about it
10:24:33 <dolio> I think installing pandoc using the distribution will be fine.
10:24:38 <ja> bolti[m]: i think ghcup isn't necessarily interfering with a pacman installed ghc. but i always think it is confusing to have ghcs from multiple sources installed
10:25:03 <bolti[m]> I just have ghcup and no ghc from pacman
10:25:10 <dolio> There's no reason for installing pandoc to install ghc.
10:25:11 <hexagoxel> bolti[m]: AUR has pandoc-bin which sounds less likely to conflict with other haskell tooling. Personally, I completely avoid pacman for any haskell stuff on arch, and installed pandoc via `cabal install`.
10:25:33 <bolti[m]> that's sounds great
10:25:40 <bolti[m]> I didn't think about looking aur
10:26:04 <ja> i wonder which package has the ghc runtime environment on arch? is it not usually dynamically linked in haskell?
10:26:55 <hexagoxel> `pacman -S pandoc` contains a long list of haskell-* plus `ghc-libs-8.10.1-2` and `cmark-gfm`.
10:27:08 <hexagoxel> I suppose ghc-libs would include the runtime?
10:27:29 <ja> that sounds reasonable, yeah
10:27:47 <yushyin> just yesterday I installed pandoc with cabal install, I had to add more swap space, because it needed 5.5GB RAM to compile ...
10:27:56 <ja> i know on freebsd they often put all the debugging symbols and headers in the same package as the executable, unlike on e.g. ubuntu
10:29:55 <ja> yushyin: do you know which package was so memory intensive? is it the final link step of pandoc?
10:30:10 <yushyin> pandoc
10:30:46 <ja> i don't know their codebase but now i am getting curious
10:31:08 <ja> amazing how everything is just balooning in memory usage, will this never end. oh the calamity
10:32:49 <yushyin> cabal had build and installed all dependancies just fine, but at pandoc it went OOM and ghc got killed :D
10:33:09 <yushyin> dependencies*
10:34:35 <yushyin> well yeah, seems like my 8GB RAM is not enough anymore
10:52:29 <monochrom> Haha, wouldn't it be great to require pandoc to build the GHC user's guide, and require GHC to build pandoc. >:)
10:53:07 <nshepperd2> pandoc doesn't even build on 8.10 when i tried it
10:53:34 <enikar> monochrom: :D
10:53:52 <Uniaika> pandoc builds?? I thought you needed to download a .rar from an obscure mirror located in Nova Scotia
10:53:57 <monochrom> But about space. Maybe cabal-install was forking too many GHC instances?
10:54:13 <monochrom> haha
10:54:38 <yushyin> was just one ghc process afair
10:55:46 <monochrom> cabal-install default (in $HOME/.cabal/config) is explicitly "jobs: $ncpus". Watch out for that. (I now set it to 1.)
10:59:31 <lally> Hi, anyone got a favorite units library to handle KiB, bytes/sec, etc?
10:59:41 <lally> units didn't have anything predefined
11:00:19 * hackage morpheus-graphql-core 0.13.0 - Morpheus GraphQL Core  https://hackage.haskell.org/package/morpheus-graphql-core-0.13.0 (nalchevanidze)
11:01:47 * hackage morpheus-graphql-client 0.13.0 - Morpheus GraphQL Client  https://hackage.haskell.org/package/morpheus-graphql-client-0.13.0 (nalchevanidze)
11:03:48 * hackage morpheus-graphql 0.13.0 - Morpheus GraphQL  https://hackage.haskell.org/package/morpheus-graphql-0.13.0 (nalchevanidze)
11:20:50 <dsal> lally: I've used dimensional before.
11:21:42 <dsal> Huh.  I don't think it does data units, though.
11:26:48 <lally> Thanks, any good?
11:30:32 <ja> oh this looks interesting https://kowainik.github.io/posts/membrain
11:30:49 <ja> but maybe a big much type-level stuff for not much benefit hmmmm
11:30:53 <ja> *bit
11:45:24 <maerwald> monochrom: https://github.com/haskell/cabal/issues/5776
11:46:06 <maerwald> nothing is gonna happen
11:52:54 <monochrom> Not surprised. I always say that devs are spoiled and simply assume that everyone uses 4-head 128GB 8GHz "dev workstations"
11:53:51 <zincy_> Should dhall config files be committed to version control?
11:54:41 <monochrom> Someone please be a troll and add this comment "This is the first time I heard that someone has less than 256GB RAM".
11:55:00 <ja> zincy_: depends what they configure?
11:55:45 <ja> monochrom: i thought RAM was measured in GiB, so indeed unheard of ;)
11:56:04 <monochrom> I hate you.
11:56:54 <zincy_> ja: port and db conn settings for a server etc
11:57:20 <monochrom> There are many factors to consider, zincy_.
11:57:44 <monochrom> One I think of now is who else will be checking out from the version control, and for what purpose.
11:58:20 <monochrom> There are a million other factors.
11:58:29 <ja> zincy_: if you adopt the new hot trends like continuous deployment, you could have a separate repo for production configuration ;) i am just trying to say, like monochrom that it is a compromise
11:59:09 <zincy_> I am arguing for env vars and someone if strongly advocating for config files
11:59:19 <zincy_> Should I give in, is it worth it
11:59:35 <ja> zincy_: i am currently working on a project that needs 50 environment variables to even run the test suite
11:59:48 <monochrom> Oh that's a very different consideration.
11:59:49 <ja> i find myself sympathizing with your colleague ;)
11:59:52 <zincy_> My thought was it is kubernetes so there is your config file why have more
12:00:06 <monochrom> A debate is worth your time iff you would win money if you won.
12:00:13 <zincy_> haha
12:00:46 <monochrom> Maybe not directly win money. Maybe for example your salary would increase because of the aftermath.
12:01:03 <zincy_> Haha
12:01:12 <ja> imho there is not really a large difference between config files and environment, only, there is no standard way to encode sets of configuration options
12:01:12 <zincy_> Yes increase entropy
12:01:13 <monochrom> Or you would need to do less work for the same salary.
12:01:16 <ja> and there is no typing...
12:01:32 <ja> i would prefer something like dhall... but i never used it in production, so you can't take me seriously
12:02:02 <ja> *no standard way to encode environment variables
12:02:03 <zincy_> I don't know I feel like there are so many variables ugh
12:02:26 <ja> zincy_: what is the advantage of environment variables? that you don't need a library to get them?
12:02:40 <zincy_> You don't have to manage config files
12:03:06 <zincy_> you get more flexibility without a combinatorial explosion in varations of config
12:03:38 <monochrom> You're trading config files for shell scripts.
12:03:43 <maerwald> monochrom: I opened the same ticket for stack... a dev seemed willing to accept a patch, but then snoyman joined the discussion
12:04:33 <maerwald> and said devs want more, not less parallelisation
12:04:35 <maerwald> ok...
12:04:39 <zincy_> monochrom: yeah my thought was if you are using a deployment system like docker those are your config files/shell scripts
12:05:13 <monochrom> Whereas you are choosing between 100-line config file and 100 env vars, I am being inflicted either 100-line config file or 100-line shell script that sets those 100 env vars. I don't think I mind one of them less than the other.
12:05:48 <ja> zincy_: now that i think of it, docker is really encouraging environment variables. i don't like it because i see docker only as helping with deployment, not with development
12:06:35 <maerwald> yes and now we have secrets in environment variables and in the bash history
12:06:46 <ja> i had to write a script to extract the environment variables from Dockerfile.development so that i could run it outside docker...
12:06:59 <zincy_> Yeah both are leaky right
12:07:16 <monochrom> But the appeal of config file is more strongly typed with richer choices of types.
12:08:01 <zincy_> What does strongly typed mean
12:08:29 <monochrom> you can support number, boolean, strings with spaces, list of the above, list of list of the above, ...
12:08:54 <zincy_> So is C strongly typed
12:09:11 <maerwald> env make more sens if you think about it as communication... something (not necessarily yourself) sets an env var, such as CC... and *multiple* programs may make use of that
12:09:16 <maerwald> not just one
12:09:19 <monochrom> In theory you could encode all that in env var's "everything is a string", but then you would be doing Gödel numbering.
12:09:32 <zincy_> haha
12:09:34 <ja> zincy_: i have a set of envrionment variables for redis URL's. they can be typed as urls, and they will be validated before starting the app with a configuration that would never work
12:10:17 <maerwald> if the env var is single purpos for a single application, then it's not really an env var
12:10:49 <zincy_> maerwald: That is a bit confusing
12:10:54 <ja> maerwald: what do you mean by "application" here?
12:11:06 <monochrom> Consider LESS for less.
12:11:10 <maerwald> ja: .exe
12:11:30 <monochrom> Consider LS_COLORS
12:12:02 <maerwald> monochrom: those are all terrible (read with french accent)
12:12:16 <monochrom> I like the Russian accent more :)
12:12:28 <monochrom> especially since it's full of r's and l's :)
12:12:57 <maerwald> accent could very well be an env var
12:13:05 <ja> maerwald: ah you mean, if it isn't shared across invocations, it shouldn't be in the environment?
12:13:14 <maerwald> kinda
12:13:44 <monochrom> What do you think of the worst of both worlds?  Support all of: envvar, config file, cmdline arg.  Add a few further cmdline args for user to say which precedence order they want.  >:)
12:13:52 <maerwald> environment also collides...
12:14:18 <ja> maerwald: the motivation for putting the Redis url in the environment is that docker encourages it over e.g. having a CMDLINE with escaped newlines and each cmdline arg on its own line
12:15:07 <monochrom> I think someone should write a library called "uber configvararg" for that. :)
12:15:37 <maerwald> docker is trash, yeah
12:15:38 <ja> nah, just hardcode it and have people write into /proc/mem if they want something changed
12:15:38 <monochrom> configenvopt-parse-applicative
12:16:34 <ja> (that was a joke ;)
12:16:35 <monochrom> with a piece of magnet too, I suppose? :)
12:17:38 <monochrom> Oh, I know. I have a cunning plan!  Hibernate the system.  Modify the swap file.  Wake up.
12:18:00 <ja> not too far from smalltalk images ;)
12:18:17 <monochrom> Darn, every great idea has already been invented.
12:28:19 * hackage mcmc 0.1.3 - Sample from a posterior using Markov chain Monte Carlo  https://hackage.haskell.org/package/mcmc-0.1.3 (dschrempf)
12:32:54 * koz_ giggles at 'sample from a posterior'.
12:33:10 <koz_> Is this what they mean when they accuse you of 'pulling numbers out of your ass'?
12:33:28 <monochrom> haha
12:42:53 <ezzieyguywuf> Is this a decent way to implement a "command" protocol? i.e., the user can issue a command that will be executed and return a status. https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/Commands.hs#L29
12:43:20 <ezzieyguywuf> other questions related to this code: Am I overusing String? I've read that it should, for the most part, be avoided
12:44:03 <dsal> If you're using String, you're probably overusing String.
12:44:20 <ph88^> hi Cale sorry i missed your message earlier. uniform is defined here https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC.html#t:Variate     your hint about the if expression not giving IO was very good. i put  pure $  in front of if expression and all errors but the last one seem to be resolved now. About the last one i'm still scratching my head
12:44:27 <ezzieyguywuf> hah, fair enough
12:44:53 <ezzieyguywuf> I started out using it "you know, just in one spot. I'll fix it later" but now it's everywhere *face palm*
12:44:56 <koz_> I can't really think of a case where String is the right choice, unless it's 'compatibility with something legacy'.
12:45:06 <dminuoso> Honestly, String is not that bad.
12:45:14 <ezzieyguywuf> so really I should just prefer Data.Text every time?
12:45:18 <dminuoso> No.
12:45:23 <koz_> ezzieyguywuf: No, that's not correct either.
12:45:27 <dminuoso> Data.Text is a good default, but String isnt as bad as many people make it out to be.
12:45:30 <dsal> It depends on what it *means*.
12:45:39 <koz_> Yeah, and what you're gonna do with it.
12:45:41 * dsal uses String a lot
12:46:30 <ezzieyguywuf> well, the input I'm getting in IO comes in the form of a String, so I'm just passing that around
12:46:36 <dsal> In many cases, it doesn't really matter.  I would name `EntityState a String`  -- part of your issue is whether that's good.  If you at least name it, you only have to fix it once if you find a better way.
12:47:00 <ezzieyguywuf> dsal: that's a good point
12:47:14 <dsal> Why are you getting a String?
12:47:22 <koz_> FWIW, Data.Text provides replacements for IO stuff which gets Text.
12:47:27 <koz_> (ditto ByteString)
12:47:37 <ezzieyguywuf> b/c I'm using haskeline, https://hackage.haskell.org/package/haskeline-0.8.0.0/docs/System-Console-Haskeline.html#v:getInputLine
12:47:41 <ezzieyguywuf> maybe I should use something else?
12:47:45 <dsal> Similar for ByteString.
12:47:52 <koz_> Huh, I didn't know that haskeline uses String.
12:47:56 <koz_> (I've never used it)
12:48:17 <dsal> Is that a readline like thing?
12:48:29 <ezzieyguywuf> yea it's like a haskell readline alternative
12:48:30 <koz_> dsal: _The_ readline like thing, since it's a boot library.
12:48:33 <dsal> If it's an interactive thing, String vs. something else probably doesn't matter.
12:48:35 <koz_> (it's needed for GHCi I think?)
12:48:41 <ezzieyguywuf> perhaps I oughtn't to use it if so many in here haven't heard of it ^_^
12:48:53 <dsal> There are tens of haskell libraries I've not heard of.
12:49:00 <koz_> ezzieyguywuf: Reverse argumentum ad popularum is just as fallacious as the forward direction.
12:49:07 <dminuoso> dsal: Im in the twenties area.
12:49:12 <ezzieyguywuf> koz_: I actually understood that
12:49:18 <dsal> koz_: try harder!
12:49:20 <dminuoso> You must be good!
12:49:31 <koz_> Lol, wat.
12:49:38 <ezzieyguywuf> alright so I'll keep haskelline
12:49:51 <dsal> I'm sure it's OK.  String isn't awful for commandline like things.
12:50:02 <ezzieyguywuf> I think I'll keep String, but maybe do `type MaybeMutateEntity = EntityState a String` or something
12:50:09 <dminuoso> ezzieyguywuf: Also, regarding command protocol, in an ideal world you'd have a sort of AST in the middle instead.
12:50:16 <ph88^> Cale, ok compiles now, thanks for the help :)
12:50:19 <dsal> Though for actual commandline tools, I use optparse-applicative and my arguments are Text or ByteString or String or whatever.
12:50:29 <dsal> ezzieyguywuf: I wouldn't call something Maybe* if it's not a Maybe.
12:50:34 <ezzieyguywuf> what is an AST?
12:50:41 <dsal> Abstract Syntax Tree
12:50:43 <koz_> Abstract Syntax Tree.
12:50:48 <koz_> (I owe dsal a soda)
12:50:49 <dsal> ™
12:50:53 <ezzieyguywuf> dsal: yea,  I was thinking the same
12:50:57 <dminuoso> ezzieyguywuf: It's a fancy way of saying "represent them with an ADT"
12:50:59 <koz_> It's a data type that represents the command.
12:51:12 <ezzieyguywuf> koz_: I look into Abstract Syntax Tree
12:51:24 <ezzieyguywuf> or Abstract Data (I'm assuming) Tree
12:51:29 <dminuoso> ezzieyguywuf: That decouples your code a bit more, and you can do better analysis later on. And you can extend it easier.
12:51:43 <koz_> An easy example would be something like 'data AST = Plus AST AST | Lit Int' for example.
12:51:44 <dsal> ezzieyguywuf: It's more of what dminuoso said there...  It's a state between your input and your execution.
12:51:49 <ezzieyguywuf> dminuoso: those all sounds like things I'm quite interested in
12:51:54 <koz_> If your two commands are numerical literals and addition requests.
12:51:58 <dminuoso> ezzieyguywuf: So that'd you have `parseCommand :: String -> Command` and then perhaps some `execCommand :: Command -> IO a`
12:52:12 <dminuoso> Or `parseCommand :: String -> Either String Command`, really.
12:52:44 <maralorn> Is there a simple command to print out all dependencies from a cabal file?
12:53:40 <dminuoso> maralorn: Transitive or immediate?
12:54:05 <maralorn> immediate
12:54:06 <ezzieyguywuf> yea I was kind of working my way toward something like that. I had this splitCommand function that I just deleted one commit ago, https://gitlab.com/ezzieyguywuf/mycad/-/blob/e59cf7361e836b5a0acafb1e90aeb3926d00fe6d/HaskellCAD/src/Commands.hs#L25
12:54:11 <sclv> `cabal build --dry-run`
12:54:40 <sclv> that doesn't tell you what you already have, but it tells you what would be built
12:55:07 <dminuoso> maralorn: The best I can think of is cabal-plan, it'd require some pipefitting.
12:55:11 <dminuoso> Or using the cabal library
12:55:17 <dminuoso> The latter is probably saner
12:58:39 <maralorn> Yeah, especially since I am using it on cabal projects where cabal fails to find a correct build plan.
12:59:44 <cjay> safeReverse: "On infinite slists returns the initial slist." from https://hackage.haskell.org/package/slist-0.1.1.0/docs/Slist.html#v:safeReverse
12:59:46 <dminuoso> maralorn: Does --reorder-goals let it find a correct build plan?
12:59:50 <cjay> why would anyone want this?
13:00:04 <maralorn> Sadly that sounds like a lot of work for my use case. I just want to quickly have a list of dependencies because I want to check if they all succesfully build on nixpkgs.
13:00:46 <dminuoso> maralorn: fair enough, Id say cabal library then - should be a quick small program
13:00:57 <maralorn> dminuoso: No, some of the deps are not on hackage and one is supposed to build that stuff with nix.
13:07:52 <dminuoso> maralorn: So? You just asked for a way to quickly obtain dependencies..
13:08:18 * hackage Color 0.2.0 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.2.0 (lehins)
13:08:47 <maralorn> dminuoso: Sorry. That was a response to the question if --reorder-goals helps.
13:08:51 <dminuoso> Ah
13:09:49 <maralorn> dminuoso: thx for the help
13:18:18 * hackage calamity 0.1.15.0 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.15.0 (nitros12)
14:01:48 * hackage array-list 0.1.0.0 - IsList instances of Array for OverloadedLists extension  https://hackage.haskell.org/package/array-list-0.1.0.0 (epoberezkin)
14:24:13 <ezzieyguywuf> dminuoso: koz_: is something like that what you two had in mind when we were chatting earlier? Is the use of Data.Map here not needed? https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/Commands.hs#L21
14:27:24 <ezzieyguywuf> oh, and dsal ^
14:29:47 <monochrom> It looks like they would support it. I support it.
14:31:08 <monochrom> The question to bear in mind is: Is it the responsibility of the Commands module to recognize user-end strings like "add"?
14:31:46 <dsal> ezzieyguywuf: You don't need a map for that.  A map is just a fancy `a -> b` function.  You could write the `a -> b` function yourself and cut out a few lines of code.
14:32:00 <monochrom> Oh, that.
14:32:22 <monochrom> f "add" = Just Add; ... f _ = Nothing ?
14:33:03 <koz_> Is there a package out there for creating a temporary directory, or should I just do it by hand?
14:33:25 <monochrom> base's System.Directory has it IIRC.
14:33:52 <monochrom> err not base, directory, but it comes with GHC already
14:34:21 <ezzieyguywuf> nice feedback monochrom and dsal.
14:34:23 <dsal> ezzieyguywuf: Alternatively, you could compute that map using `fmap toLower . show` since it's a bounded enum.
14:34:36 <ezzieyguywuf> monochrom: to answer your question...currently, I do think it is the Command modules job, but perhaps it is not
14:34:47 <ezzieyguywuf> I guess that could be a Parser module's job...
14:34:52 <koz_> monochrom: I see createDirectory - so I guess I just do that with a name like '/tmp/whatever'?
14:34:54 <monochrom> getTemporaryDirectory
14:35:00 <ezzieyguywuf> and Command would be strictly for taking a Command and doing something  with it
14:35:06 <ezzieyguywuf> yea, that's probably more right
14:35:31 <koz_> monochrom: Ah, yeah, I see it.
14:36:03 <ezzieyguywuf> Also, I'm not a fan of how this turned out, so I think I'm going to change `parseCommand` to return an Either as well, so I can chain it with `execCommond`. https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/app/Main.hs#L21
14:36:20 <ezzieyguywuf> well, I say "chain", I mean ">>=", not sure the correct 'word' for this operator
14:36:26 <koz_> ezzieyguywuf: Bind.
14:36:26 <ezzieyguywuf> apply?
14:36:29 <ezzieyguywuf> ah, bind
14:36:32 <monochrom> ezzieyguywuf: It will always stay as a question because it is "yes" in some designs and "no" in some others, and they are both right, so you just give it your thought and trust your judgment. :)
14:36:35 <koz_> Apply is $.
14:36:46 <dsal> ezzieyguywuf: BTW,  `commands = [(minBound :: Command) ..]` is a little cleaner as `commands = [minBound..]`
14:37:10 <ezzieyguywuf> monochrom: fair enough. I think for me it makes sense to parse in Command until the parsing code becomes "too much", in which case it detracts from the readability of Command and I would break it out.
14:37:22 <monochrom> Yeah, basically like that.
14:37:42 <ezzieyguywuf> dsal: I considered using that. I can't remember why I didn't...
14:37:56 <dsal> It'd be confusing if you didn't have the type declared right above it.
14:37:57 <ezzieyguywuf> I think i tend to err on being as explicit as possible.
14:38:04 <ezzieyguywuf> dsal: ah, gotcha.
14:38:05 <dsal> You were very explicit in defining the types.
14:38:15 <dsal> There's explicitness and there's redundancy.  :)
14:38:31 <dsal> If you're just messing around in GHCI, it wouldn't give you the right thing because the type wasn't clear.
14:38:36 <ezzieyguywuf> yea, you're right, it's not ambiguous at all
14:38:52 <ezzieyguywuf> dsal: right, maybe I've been messing in ghci too much :-P
14:39:00 <ezzieyguywuf> is there such a thing as "too much" though
14:39:04 <ezzieyguywuf> question mark
14:39:11 <dsal> ghci can mislead you sometimes.
14:39:30 <monochrom> If you're messing around in GHCi, you don't press <enter>, you press <;> instead.
14:40:11 <dsal> Once you've properly mastered haskell, you just use :{ for all your code.
14:40:49 <dsal> I type it all correctly on the first pass, and then just upload screenshots to github.
14:40:49 <ezzieyguywuf> 😮
14:41:09 <monochrom> sounds like what beginners would do
14:41:25 <dsal> Being lazy takes a *lot* of work.
14:41:34 <dolio> Master of writing useless things in Haskell?
14:41:53 <monochrom> including the self-declared "I am correct, the computer is wrong" part when it comes to computer-declared fake errors.
14:42:25 <dsal> It's usually just a compiler bug.
14:44:45 <monochrom> Is there a way to tell github that although my filename is Foo.hs the MIME type is image?
14:45:53 <hpc> don't think so
14:46:04 <koz_> monochrom: What sort of sick steganography are you attempting?
14:46:47 <ja> ooh, i just learned about :set +m while reading about :{
14:46:47 <monochrom> haha. nah, just what they said about uploading screenshots for source code to github. I figured if you could keep the filename as Foo.hs it would complete the joke.
14:47:29 <ja> maybe that would be a good default, i never really got used to using ghci because i always get confused about the differences to real ghc
14:47:48 <ja> (i mean a local default)
14:49:12 <ja> oh my, you can even specify the print function! so i could use a sixel outputting function and you practically have ghci as Jupyter!
14:49:30 <monochrom> yikes
14:50:36 <monochrom> ln -s ghci hie; ln -s ghci ghcide
14:50:40 <enikar> ja: take a look at: https://wiki.haskell.org/GHC/GHCi
14:50:48 <ezzieyguywuf> Regarding the earlier conversation about Data.Map vs `f :: a -> b`: I understand the concept, however I was specifically using a Data.Map because of `Data.Map.keys`, see here https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/Commands.hs#L44
14:51:15 <ezzieyguywuf> is that also similar functionality that I could accomplish in some other way, or in this case does it actually make sense to keep the Map?
14:52:47 <monochrom> Then Map is nicer than writing your list in two formats.
14:52:54 <monochrom> s/writing/repeating/
14:53:59 <monochrom> Haha you know what, let's up the game and replace Map by trie. :)
14:54:50 <monochrom> since we're now in "use prefix for auto-completion" territory
14:55:42 <dsal> ezzieyguywuf: It'd be trivial to generate that map you have now.
14:55:50 <dsal> Or trie or whatever.
14:59:58 <monochrom> "introduction to data structures: a million exotic ways to represent a finite-domain function when the finite domain size is just 4".
15:01:33 <superstar64> is there anything you can do with leibniz equality that you can't do with a gadt?
15:02:38 <superstar64> or the other way around
15:04:53 <monochrom> gadt can't do equality. leibniz equality can't do data types. This sounds like asking about apples vs oranges. Clearly I don't understand the question.
15:06:30 <boxscape> what is :~: called if not equality?
15:07:02 <boxscape> propositional equality I suppose
15:07:26 <superstar64> can't you emulate a gadt by using putting :~: as one of the fields in a constructor?
15:07:33 <superstar64> or i mistaken
15:08:11 <boxscape> that sounds more or less right to me though typically I hear it expressed as adding a ~ constraint, but that should amount to the same thing
15:12:04 <dolio> Which one is :~: ?
15:12:16 <boxscape> that's GADT equality
15:12:24 <boxscape> superstar64 https://plfa.github.io/Equality/ has a proof that they imply each other
15:12:27 <monochrom> boxscape, my angle is that "equality" refers to a million things, and by the time one adds "leibniz", Refl's :~: is the last thing I think of.
15:12:31 <boxscape> so presumably they're equally powerful
15:12:45 <boxscape> hm, okay
15:12:48 * hackage massiv-io 0.3.0.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.3.0.0 (lehins)
15:13:42 <boxscape> superstar64 search for ≡-implies-≐ on that page
15:14:04 <monochrom> A more focusing way to ask is, e,g.: Suppose I am not allowed GADT apart from Refl(:~:) as a given and ADT, can I recover the power of GADT anyway?
15:14:18 <boxscape> apparently GADT propositional equality is also called Martin Löf equality
15:15:00 <dolio> What is "GADT equality"?
15:15:24 <boxscape> dolio https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Type-Equality.html#t::-126-:
15:15:41 <dolio> Ah.
15:16:14 <boxscape> ...at least that's what think superstar64 meant
15:16:23 <superstar64> monochrom, i'm not sure you even need a gadt, isn't ``data a :~: b = Refl (forall f. f a -> f b)`` enough? 
15:16:32 <superstar64> oh, how do i quote code?
15:16:48 <ja> not possible
15:16:50 <boxscape> superstar64 there's no general way to do that in IRC because every client is different
15:17:00 <superstar64> alright, thanks
15:17:02 <boxscape> I'm in kiwiirc right now which will render `code` as code
15:17:34 <monochrom> I wonder if you also need forall f. f b -> f b
15:17:43 <monochrom> err, forall f. f b -> f a
15:17:59 <monochrom> and then I haven't thought of how to harness it for real
15:18:08 <boxscape> monochrom "Leibniz equality is usually formalised to state that x ≐ y holds if every property P that holds of x also holds of y. Perhaps surprisingly, this definition is sufficient to also ensure the converse, that every property P that holds of y also holds of x." from https://plfa.github.io/Equality/
15:19:03 <monochrom> Yes yes I learned Leibniz equality from foundations of mathematics and logic, not from dependent type fan work.
15:19:49 <boxscape> it happened to be the second duckduckgo result for leibniz equality and also a book I'm aware of :)
15:19:59 <dsal> I've still never used GADTs.  Every time I start, I hit a point where it's actually more work than `data` for whatever I'm doing.  I think I'm doing the wrong things.
15:20:20 <monochrom> My mistake of having learned it before duckduckgo existed so I never thought of doing that search?
15:21:50 <dolio> monochrom: What is the purpose of your remarks here?
15:22:08 <monochrom> rant
15:22:32 <dolio> To show how much better you are than Philip Wadler (et al)'s book on theorem proving?
15:22:51 <monochrom> No.
15:23:23 <monochrom> to question the purpose of bringing up "second duckduckgo result"
15:24:16 <superstar64> there's this paper https://www.cs.ox.ac.uk/files/3060/gadtless.pdf that probably has what i want, i just haven't gotten around to reading it
15:24:16 <boxscape> I was justifying why I'm citing "dependent type fan-work" rather than... anything else, I suppose
15:27:25 <superstar64> will these new linear types work well with unboxed types?
15:27:30 <superstar64> is haskell rust now?
15:28:08 <ja> i read rusts types are linear affine types and that the affine makes a difference :O
15:29:25 <dolio> Unboxed types don't need linearity.
15:32:07 <ja> sorry if i am ignorant, but what does it mean to "need linearity"? does it mean that linearity is not useful for unboxed types?
15:32:08 <d34df00d> I'm writing something with terms and types (and terms at type level) right now and I feel bad for not using GADTs to encode that, leading to some runtime check and non-probably-nonsense execution paths.
15:32:38 <dolio> Well, I'm not sure what you'd be doing with it. E.G. unboxed ints are passed to functions by value.
15:33:01 <Cale> dolio: Unsafe shit, the same as everything else you're passing around linearly, obviously
15:33:35 <dolio> You only need to examine a single function to determine if you can overwrite or not.
15:35:19 <ja> which function is being examined?
15:35:39 <Cale> The only really believable applications of the new linear stuff I've seen thus far have been in sidestepping usage of the ST monad in some similarly-local context
15:36:19 <MarcelineVQ> which is kinda weird because ST ​is elegant enough that even in a language with linearity I still use it
15:36:37 <Cale> and it's not really all that clear to me that it's a major improvement -- I mean, maybe the code is marginally nicer, but the cost in terms of surrounding shenanigans that were involved to set it all up seems absurd
15:36:53 <ja> Cale: i am making a wrapper for a cryptography API which mutates a context object once the protocol reaches a certain phase. how would you make it secure without linear types?  i would need to copy the whole context, but that should never really happen in an actual use case
15:37:22 <dolio> ja: The function that receives an Int#. You can examine that function and figure out when it has used that argument, and overwrite whateve register it was in.
15:37:33 <monochrom> Perhaps the improvemnt is in type sigs, and in the terms you don't need manual runST's.
15:37:40 <ja> i am thinking of having linear functions that consume the State1 and emit a State2 such that you no longer can use State1
15:37:40 <MarcelineVQ> linearity is exactyly as muhc work anyway because you need a wrapper that creates the linear context :/
15:37:41 <superstar64> are linear mutable arrays as powerful as ST mutable arrays?
15:37:54 <MarcelineVQ> *exactly as much work to code with as ST
15:38:15 <ChaiTRex> Is there a type theory channel on freenode?
15:38:26 <superstar64> suppose you have a function that takes two arrays, couldn't you pass the same array to both arguments in it ST but not linear
15:38:28 <MarcelineVQ> so insetad of runST you have createSomeContext
15:38:51 <d34df00d> ChaiTRex: ##dependent maybe.
15:39:10 <d34df00d> Re linear types, I think describing protocols is really nice with them.
15:39:10 <boxscape> ChaiTRex ##typetheory has 60 people online at the moment
15:39:48 <ChaiTRex> d34df00d and boxscape: Thanks.
15:39:49 * hackage pandoc-types 1.21 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.21 (JohnMacFarlane)
15:39:57 <d34df00d> I have a gut feel that everything expressible via linear types can be expressed with some rank-2 tricks akin to ST and with* functions ensuring things don't escape, but it's gonna look messy.
15:40:35 <superstar64> d34df00d, how would you handle my 2 array arguments problem in linear types? 
15:40:37 <Cale> ja: I'm not entirely clear on the details of your particular case, but it's easy enough to design your API such that it's not possible to touch out-of-date versions of the context
15:41:00 <d34df00d> superstar64: what if I want to forbid passing the same array as both arguments?
15:41:32 <superstar64> i'm just say, are linear mutable array just as powerful?
15:41:49 <Cale> ja: e.g. you can just have actions which manipulate whatever the current context is, without needing to take an explicit reference to it.
15:42:19 <superstar64> ST array have sharing right?
15:42:32 <Cale> ja: Or you can make it so that things take a reference to the current context (like a wrapper around an IORef/STRef), which then gets manipulated in a linear way
15:42:50 <d34df00d> I don't have that much experience with ghc's flavour, but, in idris-speak, if you have `fooTakesTwoArrays : (1 a : Arr) -> (1 b : Arr) -> ...` and `caller : (arr : Arr) -> ...` that's defined as `caller arr = fooTakesTwoArrays arr arr`, then it's no prob.
15:42:54 <ja> ok, i think i kinda understand. i need to play with ST
15:44:26 <Cale> (whether you'd choose the first or second approach depends on how much you think it's valuable to be manipulating more than one context at the same time)
15:44:55 <ja> oooh i hadn't considered that angle
15:45:43 <ja> so many ways to do things in haskell. if i make a library, should i expose a linear version , AND an ST version :O ?
15:46:16 <Cale> I'm fearful that this is what's going to happen
15:46:17 <superstar64> can something like quill https://arxiv.org/pdf/1612.06633.pdf be added on top of linear arrow that ghc currently has?
15:46:40 <gushys> exit
15:46:41 <superstar64> where certain types themselfs are linear
15:46:48 <Cale> We're going to end up with a lot of stupid bifurcation of many libraries, or else libraries with weird linear versions of things mixed in
15:46:51 <dolio> superstar64: Your example is actually an example of linear arrays not being modular.
15:47:12 <MarcelineVQ> Why are these libraries exposing their guts
15:47:14 <superstar64> what do you mean by not modular?
15:47:21 <monochrom> I think ST doesn't express linearity. It expresses mutability and leaves you to worry about aliasing yourself, you decide when and when not to entertain aliasing, and even then your checks and decisions are at run time, not static.
15:47:27 <dolio> If you want to copy a value from one position to another, you can't factor it into a function that copies a value at one index in one array to another one in another array.
15:47:46 <dolio> And then call it with the same array.
15:47:54 <d34df00d> I'm curious what might happen if we allow dependent linearity annotations.
15:48:01 <d34df00d> Like, what interesting might come out of it.
15:48:14 <dolio> You have to write it inline, because reading uses the array.
15:48:27 <d34df00d> Like (n : Linearity) -> (n arg : Ty) -> ... where the first argument defines how many times the second one can be consumed.
15:48:38 <heatsink> That's just linearity polymorphism
15:48:53 <Cale> monochrom: Well, the manipulations done to the contents of an STRef are sort of "linear" -- especially if the thing is wrapped up in a way that doesn't just let you make a new clone of the STRef
15:48:54 <d34df00d> Hmm.
15:48:54 <d34df00d> Right.
15:49:18 <superstar64> wouldn't it be, ``forall n. Fun n a b`` or something like that?
15:49:19 <heatsink> I recall reading about it.  It's important if you want to generalize standard library HOFs over linearity
15:50:00 <d34df00d> I guess parametricity-like considerations imply such function can't consider `arg` itself in any form, but only pass it over to other functions having the same linearity?
15:50:04 <d34df00d> (on that rag)
15:50:06 <d34df00d> arg that is.
15:53:29 <dolio> Anyhow, I'm not down on linear types in general.
15:54:23 <dolio> However, 'linear types can prevent me from passing the same array to two arguments of a function' lacks context on why that would matter.
16:00:32 <Cale> I sort of feel like linear types is too little, too soon, and there's something way more useful which overlaps quite significantly with it. If we were thinking in the context of Conal's constrained categories thing, linear types are simply a restricted set of assumptions on the category used to desugar the lambda calculus / Haskell code.
16:01:14 <Cale> But (1) they're not the only restricted set of assumptions you might want to provide
16:02:21 <Cale> and (2) your category effectively has the same underlying implementation as (->), forcing you to use unsafePerformIO to do anything interesting, and eliminating any interesting interpretations of the categorical building blocks
16:03:54 <heatsink> dolio: Suppose you have a "blur" algorithm that reads an input array and writes an output array of the same size
16:03:55 <koz_> OK, I'm having a weird issue with bracket. I'm spinning up a process (with startProcess) in a bracket, and the action is something like '\dbProc -> do res <- doMyThing; stopProcess dbProc; pure res'. However, bracket (or something) seems to be killing my process before doMyThing has a chance to do anything.
16:04:01 <koz_> Am I using bracket wrong?
16:04:22 <heatsink> dolio: If you want to blur an array in-place, you might pass the same array as both input and output.  But that won't give the right answer
16:04:36 <koz_> I basically want 'spin up that process, do my action, then stop it, and if something bad happens, stop it in any case'.
16:04:51 <koz_> I assumed bracket is the right way to go, but it seems to be happening in the wrong order (or perhaps too soon?).
16:04:51 <heatsink> dolio: The algorithm assumes that writing to the output array does not modify the input, but that assumption is violated
16:04:59 <heatsink> dolio: Linearity would prevent that mistake
16:06:31 <dolio> Okay, that's a good example.
16:07:21 <d34df00d> Cale: what would you recommend reading to build all this categorical interpretation stuff knowledge?
16:08:00 <Cale> d34df00d: https://github.com/conal/concat http://conal.net/papers/compiling-to-categories/
16:08:17 <d34df00d> I"ve seen that latter thing but I think it's out of my reach yet mathematical maturity-wise.
16:08:46 <Cale> Did you see the talk maybe?
16:08:56 <d34df00d> Or, to put my question another way, let's say I understand a thing or two about CT in general (like internalized the notion of universal property, or chased a few diagrams), what should I read next?
16:08:59 <monochrom> koz_: I wonder why "stopProcess" is in the action, not in the "teardown" argument. Also, check bracket's argument order.
16:09:31 <koz_> monochrom: The order is right - it's acquire, release, action.
16:09:47 <koz_> I tried removing that stopProcess, but it still happens in the wrong order.
16:09:59 <dolio> heatsink: Linearity is probably not the essence of that algorithm being safe, though.
16:11:22 <dolio> Like, you could say that linearity would make the algorithm safe even if the arrays are work like ST, but it's because linearity is ensuring separation or something.
16:11:43 <monochrom> koz_: Is your monad close enough to IO so you can add some debugging "print helloworld"? (Or you have already done this, it's how you know?)
16:11:52 <Cale> d34df00d: It's unfortunate that most of the writing about category theory is going to be a little bit of a circuitous route, since it's all written by mathematicians who are thinking about different stuff. The important part here isn't actually so much that the abstractions come from CT (and many of them actually end up not coming from CT), but rather that we can have type classes that capture how we interpret the syntax of lambda 
16:11:52 <Cale> calculus terms and let us reinterpret that
16:11:53 <koz_> monochrom: The latter.
16:11:59 <koz_> (I'm in just plain IO)
16:12:08 <monochrom> then startProcess did not succeed.
16:12:23 <koz_> monochrom: The terminal spew I'm seeing says it did.
16:12:52 <monochrom> this is cosmic ray level and I don't know how it happens.
16:12:54 <koz_> This is why I'm so confused.
16:13:01 <koz_> It's not the first time I've seen this, either.
16:13:12 <koz_> This is why I'm confused.
16:13:12 <d34df00d> Cale: I'm super happy reading about things written by mathematicians (started going through Topoi lately, been fun so far), so that's not a big deal. In fact, it would even be sort of preferable.
16:13:15 <ja> time to run memtest86+ ;)
16:13:18 <Cale> ah, okay
16:13:21 <monochrom> I only know that if I break social distancing and approach your computer, it will work. :)
16:13:23 <d34df00d> Although the part after "but rather that we can have type classes" is a bit mysterious to me.
16:13:53 <Cale> Well, my favourite intro textbook for category theory is Awodey's
16:13:55 <koz_> monochrom: I can gist the code if that'd help? It's ~80 lines.
16:14:01 <koz_> (well, plus a pretty basic main)
16:14:05 <monochrom> If you don't use bracket, does everything succeed?
16:14:09 <koz_> Let me try.
16:14:25 <d34df00d> Cale: nice, thanks!
16:14:49 * hackage predicate-typed 0.6.2.1 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.6.2.1 (gbwey)
16:15:01 <d34df00d> I tried approaching Mac Lane's book a few years ago, but I felt belittled every time he said smth like "as an easy illustrating example, let's consider this topological yada yada yada".
16:15:16 <d34df00d> To be fair, I'm not a working mathematician.
16:15:42 <Cale> Yeah, Awodey's book starts by assuming you have either some level of mathematical maturity or some level of stubbornness, but little else
16:15:55 <Cale> and it develops almost all of its examples internally
16:16:14 <byorgey> d34df00d: MacLane's book is pretty terrible as a book to learn category theory from.
16:16:16 <koz_> monochrom: Then yes, it occurs in the right order.
16:16:27 <d34df00d> Well I have MS in applied math, and I spent last few years gradually building some knowledge in more fundamental stuff, so I presume I have _some_ level of maturity.
16:16:28 <d34df00d> But we'll see.
16:16:31 <byorgey> It's really more of a reference than a textbook.
16:16:35 <monochrom> yikes
16:16:38 <koz_> (except then I immediately get shown why bracket matters, because I get an error unrelated to this)
16:16:51 <d34df00d> byorgey: yea, I figured that as well after a few dozen pages.
16:16:58 <Cale> but yeah, I think this is the talk http://podcasts.ox.ac.uk/compiling-categories
16:17:43 <Cale> Should hopefully make some sense of things :)
16:17:49 <monochrom> Then it is possible that the unrelated error interferes, and bracket detected the interference and aborted.  I really don't know, and I have to go in a minute.
16:18:06 <d34df00d> Yea.
16:18:12 <d34df00d> Cale: thanks for the recommendations!
16:18:17 <dolio> heatsink: Or can you somehow write something like a 'separation logic monad' in a type system with linear types?
16:18:18 <koz_> monochrom: Thanks though - it's at least a way forward.
16:20:07 <koz_> monochrom: ... turns out you were right!
16:20:18 <koz_> Thanks for the help - it all now works, with bracket.
16:20:40 <monochrom> I listed multiple possibilites. It is not called "right", it's called "hedging". >:)
16:20:56 <koz_> monochrom: You can call it whatever. The point is, you helped me fix it.
16:21:10 <monochrom> Then it just means I'm a good duck.
16:21:14 <koz_> We can argue the semantics of English statements when everything is working. :P
16:22:14 <monochrom> Just this afternoon my student emailed me "can't get Valgrind to install on my mac".  I replied "I don't know" since I don't know mac.  Then they happily informed me "OK found my tiny mistake, now it all works".
16:22:22 <koz_> LOL
16:22:27 <koz_> Been there.
16:22:57 <monochrom> I am a great duck. All you need to do is ask me and wait for me to answer "I don't know". Then the solution will unfold itself.
16:23:28 <ja> koz_: so it was startProcess after all?
16:23:48 <koz_> ja: It was the action happening - it was erroring and I missed it in the spew.
16:24:08 <koz_> monochrom: Confirmed for you? https://images.unsplash.com/photo-1551272636-4ef8ecdd836b?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1000&q=80
16:24:11 <monochrom> oooohhhhhh
16:31:13 <d34df00d> Alright, a stupid callstack question.
16:31:25 <d34df00d> A function of mine does Data.HashMap.! (which has HasCallStack constraint).
16:31:39 <d34df00d> This function of mine also has HasCallStack constraint.
16:31:57 <d34df00d> But ghc only shows CallStack (from HasCallStack):\n  error, called at ./Data/HashMap/Base.hs:631:16 in unordered-containers-0.2.10.0-KujsThAgCnwGXBG7PJnkNO:Data.HashMap.Base
16:32:03 <d34df00d> Why no trace of the stack related to my code?
16:33:10 <d34df00d> s/ghc /ghci /
16:49:45 <monochrom> d34df00d: You are at 0.2.10.0, not 0.2.11.0 :)
16:49:53 <monochrom> My process of discovery:
16:49:56 <d34df00d> Oh.
16:50:06 <d34df00d> I haven't thought about the versions.
16:50:20 <d34df00d> Noticed that in the hash, didn't notice that a newer version is on hackage.
16:50:23 <d34df00d> Thanks!
16:50:24 <monochrom> 1. I learned from controlled experiment that your error message is as though ! itself doesn't have HasCallStack
16:50:54 <monochrom> 2. So let's check versions and docs to make sure!
16:51:09 <d34df00d> (1) is already quite a lot of effort for IRC conversations lol.
16:51:14 <d34df00d> monochrom is the duck of the year!
16:51:33 <ja> does it mean we must put him in the oven? :O
16:51:56 <d34df00d> No.
16:51:59 <d34df00d> Who'd help us all then?
16:51:59 <int-e> ja: it's a rubber duck
16:52:15 <monochrom> Oh don't worry, it's amortized over multiple instances of "what happens if the HasCallStack chain is broken in the middle? at the top caller end? at the bottom callee end?"
16:52:36 <int-e> ja: so the proper environment is a bathtub
16:52:50 <d34df00d> This is becoming awkward.
16:53:17 <monochrom> Some time last week someone raised that question, so I cooked up a small example to try. The code still hasn't been automatically deleted today.
16:53:42 <monochrom> I may actually add it to my collection of tutorials.
16:54:46 <monochrom> Anyway, if the chain is broken, you only get information from the bottom callee upwards until the broken point.
16:55:23 <d34df00d> That makes sense.
16:55:26 <monochrom> and excluding the broken point.
16:55:59 <monochrom> "error" is usually the bottom callee. It has HasCallStack as an axiom. :)
16:56:01 <d34df00d> Although I was calling HM.! in a lambda that's passed to Control.Monad.State.gets, but I guess if it worked it'd still show the caller of HM.! being my function that defines the lambda, right?
16:56:46 <monochrom> Hrm, that's complicated.
16:56:49 <d34df00d> That is, I have `getVar :: MonadConvert m => VarName -> m Z3Var ; getVar varName = gets $ (HM.! varName) . variables`, so I'd have getVar as the caller of HM.!?
16:57:06 <d34df00d> With or without HasCallStack on getVar.
16:57:21 <d34df00d> (oh, so that's not even a lambda, but whatever)
16:57:32 <monochrom> getVar not having HasCallStack may break the chain.
16:57:48 <d34df00d> But my point is it wouldn't be gets, right?
16:57:57 <d34df00d> So callstacks aren't really callstacks in a sense, but rather, uh, definition stacks?
16:58:08 <monochrom> I haven't tried this. This is interesting.
17:01:34 <monochrom> My experiement (uses "map" rather than "gets") says yes, it's def stack really.
17:02:00 <monochrom> Although, there is a dynamic aspect, whereas "def" is static.
17:02:10 <d34df00d> Hmm, what do you mean?
17:03:23 <monochrom> Here is the dynamic aspect. Suppose you have recursive function, "f 0 = error "foo"; f n = f (n-1)".  f 3 shows you a stack of 3-4 units tall. The height depends on run time incidentals.
17:03:49 <d34df00d> Haven't thought about that.
17:03:52 <d34df00d> This is fun.
17:04:15 <d34df00d> How would you even call all this?
17:04:54 <dmwit> I think it's all pretty straightforward if you think of the dictionary-passing semantics?
17:05:29 <dmwit> If you need to pass a dictionary and have one, extend the stack; if you need to pass a dictionary and don't have one, start a fresh, empty stack.
17:05:48 <monochrom> Anyway, my experiment is this. If f HasCallStack, main = print (map f [3]) doesn't lose information due to map not having HasCallStack.
17:06:12 <d34df00d> Yay dictionary stacks!
17:06:30 <d34df00d> Should be quite unique to haskell.
17:07:04 <dmwit> "dictionary" is a funny word when there's just one word to look up in it =P
17:07:19 <koz_> dmwit: It's a very concise dictionary.
17:07:53 <monochrom> haha
17:09:56 <monochrom> If f :: HasCallStack => Int->Int, then probably map f :: HasCallStack => [Int] -> [Int], is how the chain is carried.
17:11:02 <monochrom> In this case you have to go out of your way to add a type annotation "[Int] -> [Int]" to break the chain. Who would do that? :)
17:11:22 <monochrom> So I think this carries over to gets as well.
17:11:28 <monochrom> and other HOFs
17:18:19 * hackage bitcoin-address 0.1 - Bitcoin address generation and rendering. Parsing coming soon.  https://hackage.haskell.org/package/bitcoin-address-0.1 (RenzoCarbonara)
17:42:48 * hackage fourmolu 0.1.0.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/fourmolu-0.1.0.0 (GeorgeThomas)
17:47:35 <dmwit> This README could be a lot clearer about the relationship between ormolu and fourmolu, I think.
17:49:37 <boxscape> the github package description is missing from the README: "A fourk of ormolu that uses four space indentation."
17:50:26 <boxscape> unfortunate that the markdown doesn't work in the haddock README
17:50:37 <boxscape> er, hackage README
17:50:57 <dmwit> Woof. I even visited the github page, but that one sentence is *very* easy to miss.
17:51:56 <boxscape> I only saw it because it's part of the link title in search engine results
17:52:01 <dmwit> See, this fork wouldn't be needed if it used one-tab indentation. ;-)
17:52:09 <boxscape> heh
17:54:38 <dolio> This is why it's great to simplify the tools by removing configuration abilities.
17:54:51 <dolio> Then people will just configure it by forking it and uploading separate, renamed tools.
17:56:24 <monochrom> Oh, ~~Ormolu~~ means crossing out Ormolu.
17:56:24 <Cale> Does anyone know whether gitlab.haskell.org moved/changed its host key?
17:56:45 <Cale> I'm getting http://dpaste.com/2SYP5C0 all of a sudden
17:57:47 <boxscape> Cale IIRC Ben Gamari (I think) said in #ghc that he was in the process of moving it a couple days ago but I'm afraid I don't remember why
17:58:11 <Cale> ah, okay
17:58:24 <monochrom> "Implementing one “true” formatting style which admits no configuration." straight from Ormolu's README https://github.com/tweag/ormolu/blob/master/README.md
17:59:12 <monochrom> I think it's more ambitious than merely seeking simplicity.
17:59:50 <dolio> Yeah, I don't really get that perspective.
18:00:02 <monochrom> BUT! Fourmolu adds s/which admits no configuration/requires you to fork the project to configure it (TODO: add a config file)./
18:00:14 <dolio> I don't have one 'true' indentation style that I follow. I just do what looks nice on a case-by-case basis.
18:00:20 <monochrom> So a config file is on the way. All is not lost.
18:00:33 <dolio> Oh, I guess it wasn't true. :)
18:01:04 <monochrom> Let's make xmonad be like that. (Is it already like that?)
18:01:23 <monochrom> (It's half-way there, you have to recompile, right?)
18:04:10 <MarcelineVQ> --indentation=4 *galaxybrain*
18:05:43 <dmwit> "Let's make xmonad be like that." Like what?
18:06:02 <boxscape> you could just add a second formatting processor on top of ormolu that replaces double the number of spaces at the beginning of lines :)
18:06:14 <monochrom> No config file. You have to fork to change key bindings for example. >:)
18:07:27 <monochrom> Remember this? https://www.amazon.com/OReily-XMonad-Book/dp/0596514980/  >:)
18:08:21 <boxscape> luckily the config file isn't technically part of the library and can be in a dotfile, so it doesn't require you to *literally* fork, at least, just recompile, IIRC
18:08:48 <monochrom> or this:
18:08:50 <monochrom> @where real
18:08:50 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
18:09:13 <monochrom> Yeah, thus, half-way there.
18:09:23 <dmwit> Oh, I see, we're doing standup. ^_^
18:09:25 <boxscape> yeah, that makes sense
18:10:11 <monochrom> Sorry for the confusion!
18:10:15 <boxscape> oh just realized, I thought you meant let's make xmonad like fourmolu strives to be, but you meant make xmonad like ormolu is
18:10:26 <monochrom> hehe
18:11:48 * hackage enummaps 0.6.2.1.7 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1.7 (leif)
18:13:35 <boxscape> xmonad is roughly modeled after dmw, right? Which I think does require you to fork
18:14:43 <boxscape> s/dmw/dwm
18:16:27 <ezzieyguywuf> dsal: when you said it'd be trivial to generate the map I have now (back 2.5 hrs ago), did you mean including the `Data.Map.keys` use-case that I had? how would I do that?
18:16:53 <ezzieyguywuf> boxscape: yes to xmonad/dwm
18:18:31 <dsal> > M.fromList [(toLower <$> show x, x) | x <- [False ..]] -- ezzieyguywuf 
18:18:32 <lambdabot>  fromList [("false",False),("true",True)]
18:18:54 <dsal> > M.fromList [(toLower <$> show x, x) | x <- [minBound..]]  :: M.Map String Bool
18:18:56 <lambdabot>  fromList [("false",False),("true",True)]
18:20:36 <ezzieyguywuf> dsal: so you're still using Map?
18:21:30 <dsal> Oh.  I thought you wanted to use map.
18:24:18 <dsal> The Map doesn't seem particularly interesting here.
18:24:20 <dsal> :t lookup
18:24:21 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:26:19 <dsal> > lookup "true" [(toLower <$> show x, x) | x <- [minBound..]] :: Maybe Bool
18:26:21 <lambdabot>  Just True
18:27:08 <dsal> > lookup "'x'" [(toLower <$> show x, x) | x <- [minBound..]] :: Maybe Char
18:27:09 <lambdabot>  Just 'X'
18:27:19 * dsal reinvented toUpper
18:29:13 <ezzieyguywuf> lol
18:29:49 <ezzieyguywuf> I was trying to see if I could get away from Map, someone mentioned I could re-implement the basic functionality with an `f :: a -> b`, but then I realized I needed `Data.Map.keys``
18:36:18 <dsal> Why do you need map at all?
18:36:31 <dsal> I was saying you could just have the one function.
18:36:34 <dsal> :t M.find
18:36:35 <lambdabot> error:
18:36:35 <lambdabot>     Not in scope: ‘M.find’
18:36:35 <lambdabot>     Perhaps you meant one of these:
18:36:42 <dsal> yes.  One of those
18:36:54 <dsal> :t (M.!)
18:36:55 <lambdabot> Ord k => M.Map k a -> k -> a
18:37:43 <dsal> Right.  So that's basically the same thing.  But you don't need a data structure there if you're going to hand write them.  If you don't, you can just use `lookup` in a list.  The numbers are so small, `lookup` on a list is probably generally more efficient than `Map.lookup`
18:41:20 <wavemode> I've actually tested that before. It's not
18:41:34 <wavemode> even for very small N, Map lookup is significantly faster
18:42:23 <wavemode> list lookup is just for situations where you don't care about the lost microseconds
18:42:27 <dsal> Weird.  I suspect it's still in the "probably doesn't matter" range.
18:42:46 <ja> does it make a difference the values of the list have been read once or not?
18:42:59 <wavemode> nope
18:47:32 <dsal> I'm kind of surprised.  I'd expect Map to be slower.
18:47:43 <dsal> For a while, anyway.
18:48:59 <wavemode> I was surprised, too
18:49:17 <wavemode> Wish I still had the code. Though I could write it up again
18:51:00 <wavemode> The way I set it up was 10, 100, 1K, 10K etc. to see where one overtook the other. 
18:51:06 <wavemode> Map was just faster for all of them lol
18:51:16 <freeman42x[m]> trying to get this to compile: zip<$>(repeat.head)<*>(drop 2) ["Your honor, my client..","2","Yaur honor, my client..","Your hanor, my client.."] . Just pasting here while I figure it out
18:51:33 <dsal> For this type of case, the map is strictly more work, though.  The list may not even be entirely instantiated before it finds a match.
18:53:12 <ezzieyguywuf> "I was sayig you could jush have the one function." which one function?
18:53:19 <wavemode> :t repeat . head
18:53:20 <lambdabot> [a] -> [a]
18:54:00 <wavemode> :t (<*>) `asAppliedTo` const
18:54:02 <lambdabot> error: lexical error at character '\SI'
18:54:09 <wavemode> :t (<*>) `asAppliedTo` const
18:54:10 <lambdabot> (b -> a -> b) -> (b -> a) -> b -> b
18:54:40 <wavemode> repeat . head can't be the first argument of <*>
18:55:48 <freeman42x[m]> wavemode: I do not follow
18:56:23 <wavemode> well, in any case, why not just write it out with lambdas :P this pointfree style is out of control
18:56:40 <freeman42x[m]> not sure about the order of evaluation in that code tbh
18:57:09 <freeman42x[m]> wavemode: that is code someone in this IRC chat shared as a solution to a question I asked
18:57:16 <gvx> freeman42x[m]: normal function application has a higher precedence than (<*>) so you either have to put the first part in parantheses or use ($)
18:57:49 <gvx> (zip<$>(repeat.head)<*>(drop 2)) ["Your honor, my client..","2","Bla","Bla"]
18:58:00 <gvx> zip<$>(repeat.head)<*>(drop 2) $ ["Your honor, my client..","2","Bla","Bla"]
18:58:06 <gvx> should both work
18:58:17 <wavemode> ah
18:58:18 <freeman42x[m]> gyx, got it, thank you
18:58:48 <freeman42x[m]> I thought it was supposed to execute fully right to left, god Haskell can be so confusing
18:59:01 <gvx> but if you want to use that for codegolf or clash of code, you can also substitute the (<$>) with (.)
18:59:06 <freeman42x[m]> discussed this before in this channel but Haskell being evaluated right to left was a big mistake
18:59:09 <gvx> zip.(repeat.head)<*>(drop 2) $ ["Your honor, my client..","2","Bla","Bla"]
18:59:55 <freeman42x[m]> gvx: yeah, it is for code golf, more specifically Clash of Code in shortest mode which is code golf multiplayer competition
18:59:57 <wavemode> _some_ operators in haskell are right-associative, sure. many languages are the same way
19:01:34 <freeman42x[m]> why did they think right to leflt evaluation is a good idea, just curious
19:02:27 <freeman42x[m]> gvx: the previous code you shared does not do the same thing, it outputs: [("Your honor, my client..","Bla"),("Your honor, my client..","Bla")]
19:03:50 <gvx> i wasn't completely sure, what you want to do. If you need to zip them with a custom function you can substitue "zip" with "zipWith yourFunction" and it should still work.
19:03:57 <wudis> lambdabot: @type sizeOf
19:03:58 <lambdabot> error:
19:03:58 <lambdabot>     • Variable not in scope: sizeOf
19:03:58 <lambdabot>     • Perhaps you meant one of these:
19:04:59 <freeman42x[m]> gvx: well, you knew what I wanted to do cause of the code I shared. The latest change does not do the same thing
19:05:30 <freeman42x[m]> this: zip<$>(repeat.head)<*>(drop 2) $ ["Your honor, my client..","2","Bla","Bla"] is very good
19:05:50 <freeman42x[m]> and zipWith is what I need to actually perform the task for that problem I had
19:06:17 <freeman42x[m]> I needed to count the accuracy of translators or something like that
19:06:23 <freeman42x[m]> how many letters they got wrong
19:06:34 <fosterite> Is there a binary parsing library that supports offsets? attoparsec and binary seem to assume the data comes in order
19:07:07 <wudis> lambdabot: @type getDirectoryContentsRecursive
19:07:09 <lambdabot> error:
19:07:09 <lambdabot>     Variable not in scope: getDirectoryContentsRecursive
19:07:58 <boxscape> freeman42x[m] the reason for (.) being the way it is because f . g looks similar to f (g x), though of course the opposite exists as well, it's called (>>>)
19:08:27 <boxscape> at least I think you're mainly talking about .
19:08:36 <gvx> in that case you could write a function f, that just compares two strings and substitute the "zip" with "zipWith f"
19:09:38 <fosterite> I found bytearray-parsing but it's unmaintained. Might be my best bet though
19:11:58 <gvx> but also, depending on your program I would consider not going pointfree. If you just bind that to a function you can save 9 bytes by writing "f(x:_:z)=zip(repeat x)z" instead of "f=zip<$>(repeat.head)<*>(drop 2)" (Or "f(x:_:z)=zipWith g(repeat x)z")
19:16:21 <freeman42x[m]> gvx: thank you, will give that a try next time I play CoC
19:17:01 <monochrom> Does CoC mean "concise or compress"? :)
19:18:29 <freeman42x[m]> monochrom: it means Clash of Code, a great way to learn Haskell actually: https://www.codingame.com/multiplayer/clashofcode
19:19:10 <freeman42x[m]> and no it does not mean Calculus of Contructions haha
19:19:22 <freeman42x[m]> not in the context I was talking about
19:35:12 <freeman42x[m]> so, I am starting Clash of Code twitch stream right now if you want to join: http://twitch.tv/freeman42x
19:35:26 <freeman42x[m]> it is a really good way of learning how to write better Haskell code
19:37:53 <fog56> why is there so much confusion about lists being "slow" !?
19:38:02 <fog56> they are lazy!
19:38:21 <Axman6> Lists are a conspiracy, they don;t exist if you're doing things right
19:38:39 <fog56> well fair, they should fuse away, but thats what i was saying!
19:38:53 <fog56> your IntMap style thing wont!
19:39:29 <fog56> its as if people are decided on having their computations mix data 
19:40:00 <fog56> ie, having to randomly shuffle up the stream in some as yet unspecified way, to give control over this to the user
19:40:25 <fog56> ie, they introduce buffers to the stream, possibly consuming all of it! fusion gone
19:40:47 <monochrom> Fusion doesn't always happen.
19:41:11 <monochrom> (In any sense of "always".)
19:41:26 <fog56> right, and in the cases where it cant, then your need for a good buffer is justified, but not until that point
19:42:14 <monochrom> What is the confusion you have in mind? I don't think people are confused.
19:42:48 <fog56> advocating IntMap over List, all the time, with no mention of "when lists are better"
19:43:00 <fog56> simply because it has faster random access
19:43:05 <freeman42x[m]> > Lists are a conspiracy, they don;t exist if you're doing things right
19:43:05 <freeman42x[m]> you got my attention :D
19:43:07 <lambdabot>  <hint>:1:23: error: parse error on input ‘,’
19:43:38 <fog56> i might be able to look up neighbours from an IntMap fast, but if i have to completely evaluate a stream to get the IntMap to begin with...
19:43:56 <fog56> this motivates "streaming stencils"
19:44:09 <fog56> for which *lists* are the perfect thing
19:44:11 <monochrom> Did you read this from a blog that no one really cares?
19:44:33 <fog56>  #haskell
19:45:21 <fog56> anyway, i never implied noone cares, im worried that people are misled by the seemingly "faster" random access containers
19:46:30 <monochrom> I don't want to be envisioned as disbelieving you. So, if you saw it said in #haskell, why not reply right when it was said, why reply now out of the blue and have me (and I'm sure everyone else) wonder "who the heck said so anyway?"
19:48:10 <fog56> well, i have - at the time, but have been left with the constant gripe of not knowing exactly *why* i have been working on lists - despite the dissuasion of others that could simply be encouraging me to "defend my thesis". and, not really being able to understand streaming in a cyclic context - i have never been able to justify using trees of lists
19:48:11 <fog56> for graphs 
19:48:53 <monochrom> Oh, that.
19:48:54 <fog56> i have part of the puzzle, about, why lists would be good for anything at all. and its clearer to me now from working with the state encoding
19:49:38 <monochrom> They don't understand your representation of graphs, or you did a poor job describing it.
19:50:42 <fog56> well, they are just Free List, with the possibility by that representation to refer to a preceding branch, as a leaf, and then join under the monadicity of list and the free monad 
19:51:10 <fog56> that makes sense, but not only lists are monadic, so this could be done with IntMap or any thing
19:51:41 <fog56> the idea was to have a "pointer" which was like a zipper on the graph, and zippers work well with lists
19:52:00 <monochrom> They don't know that your representation is to be produced then immediately discarded (good use case of laziness), or you made a mistake, your representation is seldom discarded, so they are right in telling you that laziness becomes a liability not an asset.
19:52:02 <fog56> so the free list for the graph was essentially an artefact of list zippers
19:52:54 <fog56> well, it could just be completely mind boggling to go from "streaming computations, producing successive values" - for lists.
19:53:07 <fog56> to how the hell that could possibly work on a cyclic graph
19:53:31 <fog56> i know i need lazyness though, because of tying the knot on the cyclic self references
19:53:35 <monochrom> My impression over the years is that no one has ever seen a concrete example.  I am very serious about the logical conclusion of "no one".
19:53:51 <fog56> of which part?
19:54:07 <monochrom> concrete example of your representation of graphs.
19:54:19 <fog56> its trivial
19:54:25 <fog56> Free [] typechecks
19:54:38 <fog56> what more do you need?
19:55:01 <fog56> i did prove it isomorphic to any other representation... (grumbles)
19:55:16 <monochrom> I used to think like that before I taught undergrad courses.
19:56:07 <fog56> fine, my teachers were never evasive 
19:57:01 <fog56> i think your point is valid, something like "less english - more code" and i agree generally
19:57:11 <fog56> i was just wondering what exactly might help
19:57:43 <monochrom> No, neither English nor code.
19:58:02 <fog56> ah, the zen approach 
19:58:20 <monochrom> No, opposite of zen.
19:58:32 <fog56> facetiousness? 
19:58:43 <monochrom> No, I'm setting things up to answer.
19:58:54 <monochrom> Take a look at my http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/l06/forky-applicative.pdf
19:59:19 <fog56> thanks
19:59:26 <monochrom> I want you to focus on "Branch (Tip 2) (Branch (Tip 7) (Tip 8))" and the picture on its right.
19:59:34 <fog56> they have a binary tree
19:59:56 <monochrom> Before I taught an undergrad course, I did not think that it's necessary to give this example. I thought "it's trivial after you read my prose".
20:00:33 <fog56> more pictures! 
20:01:51 <fog56> but, your then suggesting that there is a communication problem - possibly about something different, like, my objective, or whatever.
20:02:02 <fog56> i was just talking about "the usefulness of lists"
20:02:36 <freeman42x[m]> curious if I can remove the parantheses here in a non-pointfree manner: p s=unlines$unwords<$>(transpose$words<$>(tail$lines s))
20:02:45 <fog56> because of some vague recollection of trying to defend against claims i should be using IntMap
20:02:57 <fog56> which i just see as justified
20:03:03 <fog56> dont*
20:03:27 <fog56> in a streaming - or otherwise lazy context
20:03:54 <monochrom> You said they spoke against the usefulness of lists. Have you considered the possibility that they were speaking in the context of your work, not in uncontexted generality?
20:03:56 <fog56> which, coincidentally, i think the graphs are. ie they need lazyness, because they are self referential 
20:04:27 <fog56> certainly, fast random access *is* useful
20:04:40 <monochrom> And even if they were wrong in the context of your work, I am suggesting that it is the result of a communication problem.
20:04:48 <fog56> and it can even be used for part of the algorithm, namely the buffering part
20:05:15 <fog56> for instance, i need to traverse twice, to update values, and then, to go and insert the updated references at the cyclic references
20:05:50 <fog56> then i need a buffer, of the places that are referred too. they might be visited out of order, so i need a nice random access buffer
20:06:44 <fog56> monochrom: i dont think thats what it was though, i think they were saying, just lookup by node number, you can never improve on fast random access
20:06:59 <fog56> citing, pointer chacing and such
20:07:04 <fog56> chasing*
20:07:42 <fog56> that the idea of a list zipper having things to either side of it "just there, so close" was a misimagination of how storage works
20:08:12 <fog56> but this is only relavent if lazyness is ignored completely, which i do not think there was ever justification for
20:08:34 <fog56> in a streaming context, the most recent computation, and the next one, really are closer by
20:08:45 <monochrom> random access array has extra shortcomings in Haskell's immutable setting
20:08:46 <fog56> especially in the presence of a hungry garbage collector 
20:09:16 <fog56> monochrom: right! i was even trying to do everything mutably for a while
20:10:08 <fog56> not that it was bad advice, just that i got some idea it could be a good idea, which sure - mutability is, in general
20:11:17 <fog> and i only just figured out the real significance of lazyness 
20:11:37 <fog> from this, demand based computation or whatever its called
20:11:44 <fog> for getting things from sources 
20:12:49 <fog> suddenly i dont feel like all that list zipper stuff was a waste of time
20:13:37 <fog> it got to the point where i had something like "substructure fusion" - where the intermidiate navigations between the elements, aswell as the resulting stream of elements, could both be fused over
20:14:16 <fog> so that you could change between equivalent tree containers without overhead
20:15:22 <fog> and i wrote up all the "navigational index" traversal stuff... just never got "nested states" finished
20:15:46 <freeman42x[m]> hoogle is down, Haskell productivity dropping down by 300%. Time to host hoogle locally
20:15:49 <fog> but that was to *exhaustively enumerate all traversable instances*, which could have been overambitious 
20:16:03 <freeman42x[m]> ah, it is back up
20:16:49 <fog> oh, and i remebered the overall motivation too
20:16:53 <wavemode> good thing it came back. with productivity of negative 200%, you must have been rapidly deleting code
20:17:03 <fog> covnets and fluid simulations both fit the same structure
20:17:53 <fog> so it was an interface for implementing stencil convolutions - so it makes sense why higher dimensional zippers were a thing
20:17:56 <freeman42x[m]> I kind of needs something that does this: a -> (a -> b) -> (a -> c) -> (b, c)
20:18:15 <freeman42x[m]> needing it for this problem: Given a number N, multiply it by the last character of its hexadecimal form, then print the last digit of its binary representation.
20:18:51 <freeman42x[m]> so I would like to map the number and its last character of the hex form to a list or tuple
20:19:11 <c_wraith> :T (&&&)
20:19:19 <c_wraith> gah, too much shift key
20:19:23 <c_wraith> :t (&&&)
20:19:24 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:19:48 <fog> for fluid sims, then people are saying "use mutable arrays".
20:20:00 <c_wraith> > negate &&& (*2) $ 10
20:20:02 <lambdabot>  (-10,20)
20:20:48 <fog> argh, maybe they are right. as long as the thing is "flat" ie, not streaming, i cant justify not using the fast ram containers
20:21:11 <fog> the updates are streaming, but the carried thing is flat... damn. and it doesnt even go round any cycles! 
20:22:13 <freeman42x[m]> does my question make sense?
20:22:42 <wavemode> &&& is precisely the answer to your question
20:23:04 <Axman6> %:t (&&&) @(->)
20:23:10 <Axman6> % :t (&&&) @(->)
20:23:10 <yahb> Axman6: (b -> c) -> (b -> c') -> b -> (c, c')
20:27:38 <dsal> > let lu "true" = Just True; lu "false" = Just False; lu _ = Nothing in    map lu ["blah", "false", "true"] -- ezzieyguywuf , sorry was outside.  I meant you can just do this
20:27:40 <lambdabot>  [Nothing,Just False,Just True]
20:28:02 <monochrom> freeman42x[m]: I think c_wraith was answering your question.
20:28:33 <monochrom> and Axman6 specializesd the type
20:28:57 <freeman42x[m]> oh, I see, I will try to use it
20:31:45 <fog> so, as for the utility of lazy stencils - if there is no point using them on flat container updates - then the only application seems to be for "graph based representations of computational flow"
20:32:21 <fog> that was what the stuff on function nets was about, but it got confused with an excuse to talk about neural net architectures 
20:33:40 <fog> i guess i got a bit carried away with the implications of neurons as functions, and abstracting over the type of information propagated over edges
20:33:48 <fog> such as being able to pass nets!
20:34:00 <fog> but really there is a very haskelly context
20:34:25 <fog> about the lazy evaluation of recursive functions "unrolled" onto a net scaffold
20:35:10 <fog> and while this might seem needlessly complicated, its the only place these higher dimensional list zippers are ever going to be useful 
20:35:51 <fog> idk, maybe there is some benefit to doing it like that. seems like a lot of machinery to have no advantage
20:38:11 <fog> the good thing about lazy stencils as that they can be streamed to gather more surrounding data, infinitely, and only used lazily
20:38:51 <fog> so that maybe has application for adaptive computations, that call for eg, more refined gradient calculations from wider stencils
20:39:16 <fog> which could be good for automated localised workload refinement  
20:39:42 <fog> and that it results for free from lazyness seems strong syntactically 
20:40:52 <fog> i think some engineering applications only call for a more fine grained representation when necessary   
20:41:01 <fog> could be good for that
20:43:09 <freeman42x[m]> @karma+ c_wraith thank you, that is very cool and basic functionality which I did not know of yet lol
20:43:09 <lambdabot> c_wraith's karma raised to 22.
20:44:53 --- mode: ChanServ set +o glguy
20:44:53 --- mode: glguy set +q *!b23ec967@gateway/web/cgi-irc/kiwiirc.com/*
20:44:58 --- mode: glguy set -o glguy
20:52:08 <d34df00d> So there a sortByM function that allows sorting in an arbitrary monad, with the comparator living in said monad: https://hackage.haskell.org/package/monadlist-0.0.2/docs/Control-Monad-ListM.html#v:sortByM
20:52:19 <d34df00d> What would be the interpretation of a comparator that lives in []?
20:52:28 <d34df00d> Something about non-determinism? But what exactly?
20:53:13 <Cale> It can produce multiple options with regard to whether one element is less than another, and the sorting will continue under those various different assumptions
20:53:44 <d34df00d> Cale: but what'd be the result?
20:53:50 <d34df00d> I defined `myComp a b = [compare a b]`, then `nub $ sortByM myComp [1, 7, 5, 12]` produces the single variant consisting of the usual ordering — that makes sense.
20:53:59 <Cale> It's doubtful that the result means a whole lot, what you get will say a bit more about the sorting algorithm than anything else
20:54:00 <d34df00d> If I define myComp a b = [compare a b, compare b a], then it's all 24 variants.
20:54:16 <d34df00d> But I wonder if I can get something sensible in between.
20:55:20 <d34df00d> What laws should this non-deterministic comparator even have?
20:55:25 <d34df00d> s/have/satisfy/
20:57:11 <Cale> Well, ordinarily, you're required to provide a total ordering. If you were simply to generalise that to saying that the total ordering laws have to hold with all possible choices of results of comparisons, that's probably a bit too strong to do anything interesting
20:57:53 <d34df00d> Yeah, I think it implies either the degenerate underlying set or some in fact deterministic output.
20:59:33 <freeman42x[m]> I do not get what is wrong with this: read &&& (D.hexDigitToInt.last.printf"%08x".(\s->read s::Int))$"142359"
20:59:38 <freeman42x[m]> > read &&& (D.hexDigitToInt.last.printf"%08x".(\s->read s::Int))$"142359"
20:59:40 <lambdabot>  error:
20:59:40 <lambdabot>      Not in scope: ‘D.hexDigitToInt’
20:59:40 <lambdabot>      No module named ‘D’ is imported.
21:00:13 <freeman42x[m]> how do you use imported stuff with lambdabot?
21:00:28 <freeman42x[m]> D is import qualified Data.Text.Internal.Read as D
21:04:29 <freeman42x[m]> ah, this works: (\s->read s::Int)&&&(D.hexDigitToInt.last.printf"%08x".(\s->read s::Int))$"142359"
21:08:11 <freeman42x[m]> looking for a function with this type signature: (a, b) -> (a -> b -> c) -> c but the semantics of applying 2nd function on the 1st argument to get c
21:08:52 <wavemode> :t flip uncurry
21:08:53 <lambdabot> (a, b) -> (a -> b -> c) -> c
21:10:38 <freeman42x[m]> wavemode: facepalming myself haha
21:13:36 <freeman42x[m]> > (flip uncurry (142359,7)) (+)
21:13:38 <lambdabot>  142366
21:13:47 <freeman42x[m]> seems that I started coding LISP in Haskell
21:15:50 <gvx> > (`uncurry`(142359,7)) (+)
21:15:52 <lambdabot>  142366
21:16:07 <gvx> in case you need a shorter way to write it ;)
21:18:57 <freeman42x[m]> @karama+ cheers, works great
21:18:57 <lambdabot> cheers,'s karma raised to 1.
21:19:07 <freeman42x[m]> lol xD
21:19:16 <freeman42x[m]> show is cheers? xD
21:19:31 <freeman42x[m]> and it even worked when I mizpeld karma
21:19:50 <freeman42x[m]> @karma+ wavemode cheers, works great
21:19:50 <lambdabot> wavemode's karma raised to 1.
21:20:16 <wavemode> @hoooogle a -> a
21:20:16 <lambdabot> Prelude id :: a -> a
21:20:16 <lambdabot> Data.Function id :: a -> a
21:20:16 <lambdabot> GHC.Exts breakpoint :: a -> a
21:20:17 <freeman42x[m]> @karama+ gvx yep, I always need a shorter way haha
21:20:17 <lambdabot> gvx's karma raised to 1.
21:20:22 <wavemode> the magic of autocorrect
21:20:42 <freeman42x[m]> @karma+ gvx yep, I always need a shorter way haha
21:20:42 <lambdabot> gvx's karma raised to 2.
21:22:14 <wavemode> @haggle a -> b
21:22:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:22:15 <lambdabot> GHC.Exts unsafeCoerce# :: () => a -> b
21:22:15 <lambdabot> GHC.Prim unsafeCoerce# :: a -> b
21:22:19 <wavemode> lol
21:24:28 <gvx> @version
21:24:28 <lambdabot> lambdabot 5.3
21:24:28 <lambdabot> git clone https://github.com/lambdabot/lambdabot
21:29:11 <freeman42x[m]> how can I think through the process of turning this into pointfree? p s=[last$printf"%b"$(`uncurry`(read&&&(D.hexDigitToInt.last.printf"%08x".(\z->read z::Int))$s))(*)]::String
21:29:20 <freeman42x[m]> more curious of the thinking process than a solution
21:40:39 <gvx> What you want to achieve is getting the s to the end of the expression, so you can remove it, right. So you try to remove everything that is surrounding it. This might not be the best way to write it, but on way to get closer is first removing the []
21:41:04 <gvx> p s=pure.last.printf"%b"$(`uncurry`(read&&&(D.hexDigitToInt.last.printf"%08x".(\z->read z::Int))$s))(*)::String
21:42:30 <gvx> after that, you can remove more parantheses by applying the arguments to uncurry in their normal order
21:42:35 <gvx> p s=pure.last.printf"%b".uncurry(*)$(read&&&(D.hexDigitToInt.last.printf"%08x".(\z->read z::Int))$s)::String
21:44:59 <gvx> and then your basically done.
21:45:01 <gvx> p=pure.last.printf"%b".uncurry(*).(read&&&(D.hexDigitToInt.last.printf"%08x".(\z->read z::Int)))
21:51:10 <freeman42x[m]> @karma+ gvx thank you, I will check this later
21:51:10 <lambdabot> gvx's karma raised to 3.
22:03:49 * hackage dhall 1.33.1 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.33.1 (GabrielGonzalez)
22:18:31 <nate48423> america government and denaro are getting my human brain i am nathan biernatt and i dont want the america government to get my brain pleae tell your leaders and my brain goes through things at times and i dont want the americans to make money off my brain.
22:18:52 --- mode: ChanServ set +o dibblego
22:19:24 --- mode: dibblego set +b *!*nate48423@50.105.118.*
22:29:08 <freeman42x[m]> I can rewrite: c n=any(\i->i^i+i==n)[1..n] as c=ap(any.(.((+)=<<join(^))).(==))(enumFromTo 1) . Is there any more terse way to do it?
22:30:26 <c_wraith> terse?  that's longer.
22:30:39 <c_wraith> I think the word you're looking for is "obfuscated"
22:32:19 <freeman42x[m]> c_wraith: that is the point, rewriting it to pointfree ends up being less terse and I was asking how to make it more terse
22:55:21 <wavemode> one fewer character: c n=or[i^i+i==n|i<-[1..n]]
22:57:20 <freeman42x[m]> how can I make this shorter or pointfree?
22:57:21 <freeman42x[m]> p s=show$product$sum.(digitToInt<$>)<$>words s
22:59:48 <freeman42x[m]> @karma+ wavemode, nice trick
22:59:48 <lambdabot> wavemode,'s karma raised to 1.
23:05:23 <ja> @karma+ lambdabot
23:05:24 <lambdabot> lambdabot's karma raised to 37.
23:06:37 <ja> i welcome the resurgence of karma!
23:12:59 <dminuoso> freeman42x[m]: Use a binding.
23:13:30 <dminuoso> c n = any prop [1..n] where prop i = i^i+i == n
23:18:10 <freeman42x[m]> dminuoso: that uses more characters though
23:18:16 <dminuoso> So what?
23:40:20 <freeman42x[m]> dminuoso: I asked: `Is there any more terse way to do it?`
23:40:21 <freeman42x[m]> terse meanse concise
23:40:28 <freeman42x[m]> less number of characters
23:40:55 <dminuoso> You and I have different ideas about "concise code" then.
23:42:01 <jackdk> Is there a tool in lens to process chunks of a Traversal, a few at a time? something like `chunksOf :: Int -> Traversal s t a b -> Traversal s t [a] [b]`?
23:56:15 <LambdaDuck> freeman42x[m]: There is a general algorithm for converting code to point free style. If you learn how to do it by hand, it can make it easier for you to find the right compromise of pointfreeness when code-golfing.
23:59:31 <LambdaDuck> jackdk: That would have to be an improper lens if it could exist at all, since changing the length of the list would break things.
23:59:57 <freeman42x[m]> dminuoso: I think it is not you and me, I think it is you and most other people...
