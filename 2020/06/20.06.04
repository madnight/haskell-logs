00:15:27 <asheshambasta> Which one of these approaches is better? https://gist.github.com/asheshambasta/f302174f98637fbc17290b62d6e5e29a#org8cb40eb 
00:20:20 <ski> one possibility is
00:20:23 <ski>   jsonRead = WebsiteSettings () <$> J.jsonRead "domain" <*> pure ()
00:20:25 <ski> or even
00:20:32 <ski>   jsonRead = WebsiteSettings <$> pure () <*> J.jsonRead "domain" <*> pure ()
00:21:15 <ski> (also, your alternative with `flip' is slightly incorrect)
00:22:07 <asheshambasta> yeah, it should probably be `flip (WebsiteSettings ()) () <$> ... `
00:22:36 <asheshambasta> (which also makes it uglier to read.)
00:27:05 <ski> if you want to, you could instead say
00:27:26 <ski>   jsonRead = WebsiteSettings () `flip` () <$> J.jsonRead "domain"
00:28:00 <ski> (not sure whether that's easier, or less uglier, to read)
00:29:30 <asheshambasta> Personally, I prefer the version with the arguments flipped; a colleague and I were having this debate over a code-review, and he prefers the RecordWildcards version.
00:30:23 <asheshambasta> But I'd like to know what the best way is: from the perspective of a reader. 
00:46:21 <ph88> does anyone know of a function that guarantees a trailing slash on the end of a path (for a directory) ?
00:47:00 <ph88> oh actually i already found such a function ^^
00:47:08 <ph88> addTrailingPathSeparator
00:50:08 <ski> asheshambasta : well, personally, i don't really like `RecordWildcards' at all ..
00:53:01 <juliusdeane> I'm trying to get `lift` to work in my monad stack but for some reason it's not
00:53:42 <juliusdeane> I have a type Assembler = State ASMState, and a newtype Compile a = Compile { runCompile :: ExceptT CompileError (StateT CompilerState Assembler) a } deriving (all the good stuff)
00:54:32 <merijn> nested state seems like a recipe for pain
00:54:44 <juliusdeane> when I try to lift a computation `f :: Assembler a` into the `Compiler` monad using `lift . lift`, it type errors
00:54:55 <juliusdeane> merijn yeah, the problem is idk how to avoid it
00:55:30 <juliusdeane> I'm writing a compiler that has its own state, plus a monad for storing the state (i.e. instruction list) of the assembler
00:55:43 <merijn> newtype the state and only expose limited primitive operations on it?
00:56:11 <juliusdeane> newtype `Assembler`?
00:57:51 <merijn> For example
01:02:23 <ski> juliusdeane : did you intend to write `Compile . lift . lift' ?
01:03:10 <juliusdeane> I think just `lift . lift`, within a do-block in a `Compile` monad
01:03:37 <timCF> Hello! I have a question. There is a library which exports `(Foo, newFoo)` - newtype Foo and smart constructor for it. Smart constructor there really make sense because it makes code more robust and it's more obvious how to use it. But when I import Foo in some other project and want to use `GeneralizedNewtypeDeriving` and `StandaloneDeriving` to
01:03:38 <timCF> automatically derive some my class, compiler complains that he needs default constructor for the Foo in scope.. Is there some way to workaround it? Probably possible with GHC.Generics but maybe there is simpler way?
01:05:32 <ski> juliusdeane : well, that sounds like it can't work, then
01:07:05 <juliusdeane> hhhhhhhhhh maybe I'll put a Compile in front of the lifts then
01:07:08 <ski> juliusdeane : `lift . lift' will go from `m a' to `t (u m) a', where `m' is a monad, and `t' and `u' are monad transformers. in your case, it could go from `Assembler a' to `ExceptT CompileError (StateT CompilerState Assembler) a' (having `t = ExceptT CompileError',`u = StateT CompilerState',`m = Assembler')
01:07:35 <ski> juliusdeane : but to then get from `ExceptT CompileError (StateT CompilerState Assembler) a' to `Compile a', you need to use the data constructor `Compile'
01:07:42 <juliusdeane> aha
01:07:45 * hackage urbit-hob 0.3.3 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.3.3 (JaredTobin)
01:08:26 <juliusdeane> ski hey, it worked! tsym!!!
01:08:43 <ski> `lift' goes from something of shape `m a' to something of shape `t m a'. `Compile a' does not have shape `t m a' (`Compile a' is not a monad transformer applied to a monad and a type), and so `lift' can't possibly get you to `Compile a'
01:09:23 <juliusdeane> ... is this because it's a newtype?
01:09:50 <ski> yes, `Compile a' is a separate type, distinct from `ExceptT CompileError (StateT CompilerState Assembler) a'
01:10:27 * ski would also personally rename the data constructor to maybe `MkCompile' or something ..
01:11:07 <juliusdeane> k
01:12:25 <ski> timCF : perhaps you could export it from an `Blah.Internal' module
01:12:43 <ski> (assuming it's your library, that is)
01:17:05 <timCF> yes, it's my library, I'm thinking that exporting `(Foo, newFoo, unFoo)` might be better, where `unFoo` is not part of constructor but just a function which is supposed to be used instead of `coerce`
01:18:49 <timCF> then it still be not possible to create nonsense values with default constructor because it's not exported, and at the same time there will be acceess to internal value of newtype
01:22:17 <asheshambasta> ski: and why not RecordWildcards?
01:22:34 <asheshambasta> (as in, why don't you like it?)
01:24:32 <lortabac> some people don't like RecordWildcards because it modifies the meaning of existing identifiers
01:25:22 <lortabac> IMHO they should have come up with a way to distinguish the new identifiers from the record accessors
01:26:47 <asheshambasta> I see, yeah, I also have the same concerns; plus the fact that they cause "forgetting" in cases where say, you're doing something like toJSON Foo{..} = object [ ... ]; with RecordWildcards, adding a new field one may forget to "use" it.
01:27:36 <lortabac> asheshambasta: isn't there the same risk with standard accessors?
01:28:08 <asheshambasta> not with explicit matches; that is toJSON (Foo a b c) = ...
01:28:35 <lortabac> ah sure
01:30:47 <ski> lortabac : well, yes. that's an additional reason
01:31:59 <ski> (but that's more a beef with the basic record syntax, not with `RecordWildcards' per se. it's just that with that extension, and with `NamedFieldPuns', you feel the pain more)
01:33:16 <ski> asheshambasta : but i don't like it since it allows writing an expression that uses identifiers that aren't lexically visible in that expression. also allows writing a pattern that introduces (binds) identifiers that aren't lexically visible in that pattern
01:33:41 <asheshambasta> I see; and yeah, I quite agree. 
01:33:43 <ski> (the second part there is perhaps even more jarring, but i don't like the former, either)
01:34:25 <asheshambasta> For me; something like RecordWildcards is strictly for convenience, never for code quality or more readability.
01:35:21 <kuribas> What would first class label in a language look like?  Lenses?
01:35:32 <ski> "label" meaning ?
01:35:38 <kuribas> record label
01:35:46 * ski . o O ( `goto label;' )
01:36:11 <ski> i guess you mean record field label
01:36:25 <lortabac> ski: what this Pascal? :)
01:36:30 <kuribas> ski: yes
01:36:43 <ski> (some languages has a label thing for the whole "tuple"/"record")
01:37:06 <ski> lortabac : Pascal doesn't have `goto'
01:37:17 <justsomeguy> If I want to write multi-line strings, and have the leading indentation disregarded, is there a way to do that other than "line one\r" "\line two"?
01:37:36 <ski>   myString = "foo\
01:37:44 <ski>              \bar"
01:38:24 <ski> > "foo\    \bar"
01:38:27 <lambdabot>  "foobar"
01:39:43 <kuribas> ski: or they could be a type level thingy
01:39:48 <ski> kuribas : i guess C++ has a "pointer to member" thing ?
01:39:58 <kuribas> yeah
01:41:27 <kuribas> kind of like in genericLens
01:42:21 <ski> lortabac : anyway, imho, the field accessor functions ought to not just be written the same as the field names themselves
01:43:17 <dminuoso> lortabac: RecordWildCards has one really great use that is sometimes forgotten (perhaps a separate extension for this would be great), which is being able to write `do { field1 <- ...; field2 <- ...; field3 <- ...; pure Rec{..} }`
01:43:51 <dminuoso> Together with applicative do you even get to use this for applicatives - this can greatly improve diagnostics and avoid errors when building up large applicatives, say when using optparse-applicative.
01:43:53 <ski> given a type `Person' with fields `name :: String',`age :: Int', it would have been better if the field accessors were written something like `#name :: Person -> String' and `#age :: Person -> Int' (that's the SML syntax)
01:44:00 <justsomeguy>  I was hoping for something like """line1\nline2""".lstrip() in python. The neat-interpolation package seems to do this https://hackage.haskell.org/package/neat-interpolation-0.3.2.1/docs/NeatInterpolation.html.
01:44:11 <dminuoso> justsomeguy: What does that do?
01:44:26 <ski> in OCaml, you'd write `p .name', of type `string', and `p .age' of type `int', given `p' of type `person'
01:44:39 <lortabac> ski: I have this school-time memory of labels as goto destinations in Pascal... I might be wrong though
01:45:12 <lortabac> ski: I agree with you on accessors in general, but RecordWildcards makes the problem worse
01:45:30 <merijn> lortabac: RecordWildCards is great, accessors are bad :p
01:45:36 <asheshambasta> another point I have with RecordWildcards is the diffs it generates when someone renames a field accessor: this would mean there will now be N places where the new name needs to be used where RecordWildcards was used. 
01:45:40 <merijn> Which is why -XNoFieldSelectors will be great
01:45:59 <justsomeguy> dminuoso: It lets you write a multi-line string, but it will disregard the indentation you used on the left (to align it in source code), without having to explicitly write \n\ at the end of each line.
01:46:38 <ski> dminuoso : hm, i wonder whether you'd prefer something like my (vaporware) reflective effects syntax, there
01:46:48 <dminuoso> % span isSpace <$> words "  foo\n  bar" -- justsomeguy 
01:46:48 <yahb> dminuoso: [("","foo"),("","bar")]
01:46:55 <ski> lortabac : yea, it exacerbates the problem, sure
01:47:27 <lortabac> merijn: yes, RecordWildcards + NoFieldSelectors would be definitely better IMHO
01:47:30 <dminuoso> justsomeguy: From that you can trivially go back to your original string.
01:47:34 <ski> asheshambasta : why `N' ?
01:48:05 * justsomeguy goes to look up what "span" and "<$>" do...
01:48:31 <asheshambasta> N being some arbitrary value; so usually sites where I'd pattern match (in my json example) I'd be using the field accessor name; same for "assignments" where I'd be using the field-accessor names. 
01:48:37 <merijn> asheshambasta: If you rename a field you will have to edit things in N places *anyway*
01:48:57 <dminuoso> asheshambasta: <$> is just a generalized version of `map` if you are aware of that.
01:49:01 <dminuoso> Err justsomeguy ^-
01:49:10 <justsomeguy> Ah, that helps. Thanks.
01:49:44 <dminuoso> If you prefer, you can write that as `let str = "  foo\n  bar " in map (span isSpace) str
01:49:53 <dminuoso> Oops
01:49:55 <asheshambasta> not if I'm using (let far = Foo a b c) vs (let f1 = a, f2 = b, f3 = c in Foo{..})
01:50:06 <dminuoso> % let str = "  foo\n  bar " in map (span isSpace) (words str)
01:50:06 <yahb> dminuoso: [("","foo"),("","bar")]
01:51:22 <dminuoso> % lstrip s = concat ((snd . span isSpace) <$> words s)
01:51:22 <yahb> dminuoso: 
01:51:30 <dminuoso> % lstrip " foo\n bar"
01:51:30 <yahb> dminuoso: "foobar"
01:51:35 <dminuoso> % lstrip s = unwords ((snd . span isSpace) <$> words s)
01:51:36 <yahb> dminuoso: 
01:51:38 <dminuoso> % lstrip " foo\n bar"
01:51:38 <yahb> dminuoso: "foo bar"
01:51:42 * ski doesn't follow the point of this `span' example
01:52:54 <dminuoso> Actually words doesnt split on newlines ah.
01:55:40 <dminuoso> % splitOn chr = unfoldr sep where sep [] = Nothing; sep l  = Just . fmap (drop 1) . break (== chr) $ l
01:55:40 <yahb> dminuoso: 
01:55:46 <dminuoso> %  lstrip s = concat (intersperse "\n" (snd . span isSpace <$> splitOn '\n' s))
01:55:47 <yahb> dminuoso: 
01:55:52 <dminuoso> % lstrip " foo\n bar" -- justsomeguy 
01:55:52 <yahb> dminuoso: "foo\nbar"
01:56:10 <dminuoso> I admit this is far from obvious..
01:56:41 <dminuoso> %  lstrip s = concat (intersperse "\n" (dropWhile isSpace <$> splitOn '\n' s))
01:56:41 <yahb> dminuoso: 
01:56:49 <dminuoso> ski: You are right, should have been dropWhile :)
01:58:13 <justsomeguy> Well, I learned a few new list functions thanks to your examples. :^)
01:59:08 <dminuoso> For more fancy you could write `lstrip = concat . intersperse "\n" . fmap dropWhile isSpace . splitOn '\n'` - which I think makes it easier to read.
02:12:14 * hackage tdlib-gen 0.2.0 - Codegen for TDLib  https://hackage.haskell.org/package/tdlib-gen-0.2.0 (Poscat)
02:22:32 <happycoder> hi, how to make stack build just test instead of lib+test?
02:23:24 <happycoder> the test doesn't have library in build-depends. instead the lib folder is added in hs-source-dirs
02:25:02 <merijn> happycoder: That's a bad idea, though. THat forces GHC to recompile your library's code every time you build the tests
02:26:08 <happycoder> yeah, but otherwise I can't put `:break` in library code from `stack ghci --test`
02:27:07 <happycoder> but I don't build the final executable often. So building it twice for library and test is fine.
02:27:25 <happycoder> twice for exe and test*
02:29:03 <happycoder> but currently it builds twice for test alone.
03:32:45 * hackage language-tl 0.1.1 -   https://hackage.haskell.org/package/language-tl-0.1.1 (Poscat)
03:37:16 * hackage th-env 0.1.0.2, th-nowq 0.1.0.5, static-text 0.2.0.6 (DmitryDzhus): https://qbin.io/suffer-fail-srm3
03:37:17 * hackage ghcide 0.2.0 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.2.0 (cocreature)
03:37:18 * hackage VulkanMemoryAllocator 0.3.2, vulkan 3.4 (jophish): https://qbin.io/expand-album-fczn
03:37:21 * hackage json-api-lib 0.3.0.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.3.0.0 (shirren)
03:37:22 * hackage natural 0.3.0.5 - Natural number  https://hackage.haskell.org/package/natural-0.3.0.5 (TonyMorris)
03:37:24 * hackage language-tl 0.1.1, tdlib-gen 0.2.0, tdlib-types 0.2.0, tdlib 0.1.5, tdlib 0.1.4, tdlib 0.1.3 (Poscat)
03:37:26 * hackage shannon-fano 1.0.0.0 - Shannon-fano compression algorithm in Haskell  https://hackage.haskell.org/package/shannon-fano-1.0.0.0 (bolt12)
03:37:28 * hackage gitit 0.13.0.0 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.13.0.0 (JohnMacFarlane)
03:37:30 * hackage hapistrano 0.4.1.0 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.4.1.0 (juanpaucar)
03:37:32 * hackage packcheck 0.5.1 - Universal build and CI testing for Haskell packages  https://hackage.haskell.org/package/packcheck-0.5.1 (harendra)
03:37:33 * hackage dobutokO-poetry 0.4.0.0, dobutokO4 0.1.1.0, dobutokO4 0.1.0.0 (OleksandrZhabenko): https://qbin.io/sizes-nova-nlzh
03:37:35 * hackage derulo 1.0.9, flow 1.0.21, json-feed 1.0.11, lackey 1.0.13, list-singleton 1.0.0.4, rampart 1.1.0.1, salve 1.0.10, wuss 1.1.17, burrito 1.1.0.1, autoexporter 1.1.17 (fozworth)
03:37:37 * hackage lightstep-haskell 0.10.2, lightstep-haskell 0.10.1 (DmitryIvanov): https://qbin.io/zoloft-post-bexr
03:37:39 * hackage aeson-schemas 1.2.0 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.2.0 (leapyear)
03:37:41 * hackage urbit-hob 0.3.3 - Hoon-style atom manipulation and printing functions  https://hackage.haskell.org/package/urbit-hob-0.3.3 (JaredTobin)
03:37:43 * hackage netcode-io 0.0.1 - Bindings to the low-level netcode.io library.  https://hackage.haskell.org/package/netcode-io-0.0.1 (Mokosha)
03:37:45 * hackage aop-prelude 0.3.1.0 - prelude for Algebra of Programming  https://hackage.haskell.org/package/aop-prelude-0.3.1.0 (KatsutoshiItoh)
03:37:47 * hackage influxdb 1.7.1.6 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.7.1.6 (MitsutoshiAoe)
03:37:49 * hackage json-directory 0.1.0.1 - Load JSON from files in a directory structure  https://hackage.haskell.org/package/json-directory-0.1.0.1 (lukec)
03:37:51 * hackage qtah-generator 0.7.1 - Generator for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-generator-0.7.1 (khumba)
03:37:53 * hackage linux-framebuffer 0 - Linux fbdev (framebuffer device, /dev/fbX) utility functions  https://hackage.haskell.org/package/linux-framebuffer-0 (SergeyAlirzaev)
03:37:54 * hackage doctest 0.17 - Test interactive Haskell examples  https://hackage.haskell.org/package/doctest-0.17 (quasicomputational)
03:37:56 * hackage calamity 0.1.11.2 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.11.2 (nitros12)
03:37:58 * hackage cachix 0.3.8 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.8 (domenkozar)
03:37:59 * hackage hvega 0.9.1.0, hvega 0.9.0.1 (DouglasBurke): https://qbin.io/stored-club-fdno
03:38:01 * hackage aura 3.1.1 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.1 (fosskers)
03:38:03 * hackage hpack 0.34.2 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.34.2 (SimonHengel)
03:38:04 * hackage language-docker 9.1.0, hadolint 1.17.7, language-docker 9.0.1 (lorenzo)
03:38:06 * hackage franz 0.3.0.1, tehepero 0, incremental 0.3, mason 0.2.1, barbies-th 0.1.4, winery 1.2, barbies-th 0.1.3, franz 0.3, deriving-aeson 0.2.6 (FumiakiKinoshita)
03:38:08 * hackage nix-narinfo 0.1.0.1 - Parse and render .narinfo files  https://hackage.haskell.org/package/nix-narinfo-0.1.0.1 (srk)
03:38:09 * hackage vector-circular 0.1, hedgehog-classes 0.2.5 (chessai): https://qbin.io/flash-sealed-1z1m
03:38:11 * hackage tagstream-conduit 0.5.6 - streamlined html tag parser  https://hackage.haskell.org/package/tagstream-conduit-0.5.6 (YiHuang)
03:38:13 * hackage partial-semigroup 0.5.1.8, d10 0.2.1.6 (chris_martin): https://qbin.io/tasks-plasma-yqd8
03:38:15 * hackage uri-bytestring-aeson 0.1.0.8 - Aeson instances for URI Bytestring  https://hackage.haskell.org/package/uri-bytestring-aeson-0.1.0.8 (reactormonk)
03:38:17 * hackage hslua 1.1.1 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.1.1 (tarleb)
03:38:19 * hackage reflex-process 0.3.0.0 - reflex-frp interface for running shell commands  https://hackage.haskell.org/package/reflex-process-0.3.0.0 (3noch)
03:41:08 <ezzieyguywuf> geez, someone had a lot to upload t oackage all at once, huh?
03:42:39 <tdammers> those are all different users, maybe that's rather the hackage bot churning through a backlog for some reason?
03:45:37 <dminuoso> Or it was just coincidence.
03:46:18 <maralorn> No, some of those releases are at least 24h old.
03:47:20 <maralorn> And actually at least some of them were already postet here.
03:48:06 <maralorn>  * And actually at least some of them were already posted here.
03:49:35 <dminuoso> Unticked promoted constructor: ‘Entire’. Use ‘'Entire’ instead of ‘Entire’.
03:49:42 <dminuoso> Why is that even warn-worthy?
03:52:34 <int-e> dminuoso: Apparently because it disambiguates namespaces, cf. https://gitlab.haskell.org/ghc/ghc/issues/9778
03:52:45 * hackage simple-vec3 0.6.0.1 - Three-dimensional vectors of doubles with basic operations  https://hackage.haskell.org/package/simple-vec3-0.6.0.1 (DmitryDzhus)
03:53:20 <int-e> "it" being the suggestion of adding a tick.
04:00:43 <comerijn> dminuoso: It's those damn Dependent Haskellers who want to disambiguate things before they horribly re-ambiguate things >.>
04:05:01 <dminuoso> int-e: Ah cheers.
04:34:03 <arahael> I'm trying to write an xml document using HXT, however I am not having much luck finding examples.  How do I write a document that contains an xmlns? Do I have to manually specify the xmlns as a regular attribute and keep track of this myself, or is there a more elegant approach?
04:40:22 <arahael> Eg, I'm currently using: mkelem "foo" [sattr "xmlns" "bar"] [...]
04:41:15 <arahael> And ditto for "xmlns:xsi"
04:46:29 <int-e> merijn: Hmm, plural, there's goldfire but who's the other one ;)
04:48:48 <Athas> I wish to do something similar to 'tail -f' in Haskell - that is, tail some ordinary file, and perform an action whenever a full line has been added to it.  Where should I start?
04:49:00 <dminuoso> conduit/pipes?
04:49:06 <Athas> Isn't that overkill?
04:49:20 <Athas> There is a tailfile-hinotify package, but it is Unix-specific.
04:50:05 <Athas> I can also assume that the file is never deleted or truncated.
04:50:56 <dminuoso> Well you could of course use unsafeInterleaveIO and then attach effects to it with unsafePerformIO...
04:50:57 <[exa]> Athas: tell/seek?
04:50:57 <int-e> dminuoso: does that even solve the underlying low-level problem of re-reading a file even if it was previously at EOF?
04:51:00 <dminuoso> But beyond that?
04:51:23 <int-e> (that = conduit/pipes)
04:51:39 <dminuoso> int-e: No, it rather address the "how do I act on an infinite stream of data" part.
04:52:01 <Athas> [exa]: yes, those are the building blocks.  Doesn't look like anyone has yet put them together in Haskell in exactly the way I need.
04:52:52 <int-e> dminuoso: Meh by the description a simple callback would suffice for that.
04:53:25 <[exa]> Athas: for a prototype you can assume that calling stat() is basically zero-cost and don't care about inotify just as tail does
04:54:34 <[exa]> which reduces to `forever $ getFileSize >> printNewPartIfThereIsAny >> waitOneSecond`
04:55:24 <int-e> Athas: here's another keyword: "follow".
04:55:45 * hackage tdlib-types 0.3.0 - Types and Functions generated from tdlib api spec  https://hackage.haskell.org/package/tdlib-types-0.3.0 (Poscat)
04:56:07 <Athas> [exa]: yes, I think that is the only reasonable way.
04:57:04 <[exa]> Athas: well not the only, but quite likely the quickest working one :]
04:57:11 <int-e> Athas: Though I guess only follow-file is relevant, which a) uses inotify as well, and b) forces the use of conduit.
04:59:04 <aman_>   
05:00:25 <aman_> why is no one saying anything
05:00:45 <Athas> We're shy.
05:01:42 <aman_> oh.
05:07:39 <[exa]> aman_: you arrived in a moment of silence. the situation may change rapidly. :]
05:07:59 <aman_> oh.
05:22:45 * hackage tdlib 0.2.0 - complete binding to the Telegram Database Library  https://hackage.haskell.org/package/tdlib-0.2.0 (Poscat)
05:27:09 <Athas> Is there a function in base for waiting some number of miliseconds?  I could have sworn there was one.
05:27:24 <Athas> Oh, threadDelay.
05:27:56 <phadej> microSeconds
05:28:22 <Athas> Sure, but even as a computer scientist, I think I can manage the unit conversion here.
05:28:53 <phadej> if there's a chance that your code will run on 32bit systems and you have larger delays, consider https://hackage.haskell.org/package/unbounded-delays
05:29:14 * hackage dobutokO-poetry 0.5.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.5.0.0 (OleksandrZhabenko)
05:29:57 <dminuoso> Why doesn't threadDelay accept an Integer in the first place? That seems like a gross oversight.
05:30:22 <dminuoso> Or is that to accomodate real microsecond delays without incuring the cost of pattern matching? ..
05:30:28 <merijn> dminuoso: Presumably because no one understands how to safely handle overflow in Haskell :p
05:30:51 <Athas> I ended up with this: https://gist.github.com/athas/a0641f6a5e42dab0b2b9f184abe49531
05:30:56 <merijn> dminuoso: It tooks 3 attempts to properly handle the type conversion from threadDelay to the scheduling code
05:31:05 <Athas> The only thing I am dissatisfied with is that I may read partial lines.
05:31:28 <merijn> Athas: Eh...
05:31:49 <merijn> Athas: How about you block until there's readable data on the handle? Wouldn't that work more easily and more correctly?
05:32:05 <dminuoso> merijn: Hold on, are you suggesting the constraint is to satisfy some 32 bit integer in some OS api without having to deal with overflow themselves?
05:32:17 <merijn> dminuoso: No
05:32:26 <merijn> dminuoso: I'm saying there was already one bug in it due to that
05:32:31 <dminuoso> Ah.
05:32:42 <merijn> dminuoso: And I fixed it wrong twice, despite 4 people reviewing it before committing :p
05:33:17 <dminuoso> Interesting, so given the bound guarantees of Int, threadDelay only guarantees delays up to half a second..
05:33:28 <dminuoso> Anything more is implementation dependent.
05:36:36 <Athas_> merijn: how would I or anyone know whether there will be more data in the file in the future?
05:37:23 <dminuoso> epoll/select?
05:37:59 <merijn> Athas_: If your Handle is at the EOF and data gets appended it should become readable again, I think? I'd have to dive into the posix stuff on that
05:38:24 <Athas> merijn: that's what I wasn't sure about.  I know that this works, though.
05:38:33 <Athas> Also, my code might run on something that is not POSIX.
05:53:28 <exarkun> epoll and select don't work on regular files
05:54:32 <exarkun> something like inotify on linux will work
05:54:39 <exarkun> and so will "aio" on platforms where that's implemented
05:54:54 <exarkun> (but "aio" is really just "spawn a thread, read 'til you block" hidden from view)
06:00:48 * hackage pretty-simple 3.2.3.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.2.3.0 (cdepillabout)
06:04:04 <ph88> how can i check if i have read permissions on a directory with haskell ?
06:04:37 <cocreature> ph88: try to read from it, catch the exception
06:05:14 <dminuoso> Seconded. The notion of permission is rather complex in a world with unix permissions, extended acls, selinux, and so forth.
06:05:22 <dminuoso> Trying it out is the safest way. :)
06:05:34 <cocreature> and even if you can do the check before it’s racy
06:05:53 <cocreature> of course if you do more than one operation things can change in the middle anyway but still
06:08:04 <dminuoso> How do you sensibly manage versions in such a way to keep git tags in sync with the version in your cabal file and some  `--version` runflag?
06:09:18 <ph88> cocreature, the thing is that i need to read multiple files ... so i think i can not get an atomic operation to lock the read handle
06:09:29 <dminuoso> Or perhaps even get a commit hash into the build process? Can you define CPP macros somehow with cabal?
06:10:04 <dminuoso> ph88: Open all of them? :)
06:10:19 <dminuoso> Once all have been opened, you can proceed to reading from them.
06:10:23 <ph88> ok
06:10:54 <ph88> dminuoso, you can use the cabal library to read the version info from your cabal file inside of your program on build time
06:11:36 <ph88> dminuoso, then for git there are options too to get the version and make the tag
06:11:44 <dminuoso> Oh sneaky, I think Ill use `githash`. A dirty TH library using IO to interface with git is exactly what I want!
06:14:19 <dminuoso> ph88: Mmm. What would that look like with the cabal library?
06:15:09 <cocreature> dminuoso: for a commit hash `gitrev`
06:16:17 <dminuoso> cocreature: Ah, that seems a bit simpler internally than githash, neat
06:46:00 <ph88> dminuoso, https://github.com/philippedev101/bowtie/blob/master/src/Version.hs 
06:47:09 <dminuoso> ph88: Or you could just go `import Paths_project (version)` ;)
06:48:43 <dminuoso> Curiously I cant find any documentation about it.
06:49:58 <LevelChart8> Am I correct to understand that HIE does not work with Obelisk?
06:51:32 <ph88> dminuoso, https://github.com/philippedev101/bowtie/blob/master/src/Main.hs#L41
06:53:46 <dminuoso> ph88: Curious, why the TH magic then?
06:54:03 <dminuoso> Or is that some dead core from before you learned about Paths_pkg?
06:55:37 <ph88> possibly, i don't remember
07:16:56 <nut> test
07:20:06 <merijn> dminuoso: It's in the cabal docs
07:20:21 <merijn> dminuoso: Somewhat awkwardly hiding with getDataFile
07:20:39 <merijn> https://cabal.readthedocs.io/en/latest/cabal-package.html?highlight=getDataDir#accessing-data-files-from-package-code
07:23:51 <dminuoso> The search on readthedocs sucks then. 
07:24:03 <dminuoso> Paths_ did not point me towards that page.
07:24:32 <dminuoso> Thanks though, it's good to have this on hand.
07:31:38 <ezzieyguywuf> if ghc is written in haskell, how was it compiled the first time?
07:32:02 <merijn> ezzieyguywuf: The very first Haskell compiler was written in Lazy ML by Lennart Augustsson
07:32:14 <ezzieyguywuf> ah, I see
07:32:27 <merijn> ezzieyguywuf: There were several other early Haskell compilers written in other languages
07:33:14 <ezzieyguywuf> merijn: you always seem to be around :-P
07:33:17 <dminuoso> The same as with any compiler. The initial implementation is written in some other language. :)
07:33:18 <merijn> ezzieyguywuf: It's essentially the only way to build a self-hosting compiler. You first built one in another language, then write a new compiler in your language, compile it with the first compiler
07:33:25 <ezzieyguywuf> and dminuoso too
07:33:44 <ezzieyguywuf> yea, now that I think of it, that all makes sense.
07:33:54 <dminuoso> ezzieyguywuf: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf
07:34:00 <ezzieyguywuf> I was wondering if they did some weird lazyily evaluated compiler compilation using...itself
07:34:04 <dminuoso> If you want a "brief" read on haskells history..
07:34:06 <ezzieyguywuf> or, like, compile it piece by piece
07:34:17 <dminuoso> ezzieyguywuf: You don't need a languages semantics to implement itself.
07:34:23 <dminuoso> Generally speaking.
07:34:39 <merijn> ezzieyguywuf: I mean, consider how the first C compiler was written ;)
07:34:46 <ezzieyguywuf> how was it?
07:34:47 <dminuoso> That is, the fact that Haskell has non-strict (what many people call lazy) semantics does not mean the compiler itself is lazy.
07:34:50 <ezzieyguywuf> zeros and ones?
07:34:55 <wavemode> lmao `compile' = fix compile`
07:35:01 <merijn> ezzieyguywuf: Assembly, of course :)
07:35:05 <dminuoso> ezzieyguywuf: Probably by handwriting assembly.
07:35:09 <ezzieyguywuf> wavemode: hah, exactly
07:35:12 <merijn> ezzieyguywuf: This process is generlly called "compiler bootstrapping"
07:35:46 <dminuoso> Fun fact, a compiler is surprisingly simple. You can write a self-hosting C compiler in just 2048 bytes of C code.
07:36:50 <wavemode> Implementing the first 90% of a language's compiler is easy. But the remaining 90% takes much longer.
07:37:03 <merijn> ezzieyguywuf: The trick to being here all the time is to have a job that involves a lot of 15 minute to 2 hour compilations ;)
07:37:25 <merijn> Compiler implementation is easy, if you don't care about the performance of your generated code ;)
07:37:52 <lortabac> nor of the compiler itself :)
07:37:58 <merijn> True
07:38:01 <dminuoso> And if you dont care about semantic analysis.
07:38:12 <merijn> Although making a non-optimising compiler fast is usually pretty doable
07:38:14 <dminuoso> Much of GHCs complexity is in the type checker for instance.
07:39:44 <hc> merijn: heh. very good reason to be online all the time. :)
07:40:25 <hc> speaking of simple C compilers: do you know this one: https://bellard.org/otcc/otcc.c ;p
07:40:41 <ezzieyguywuf> ML seems like an interesting language.
07:41:00 <ezzieyguywuf> merijn: lol.
07:41:09 <dminuoso> ML is a whole family of langauges :)
07:41:13 <merijn> ezzieyguywuf: Learning any of the MLs (SML, ocaml, etc.) is pretty easy after learning Haskell
07:41:19 <ezzieyguywuf> "Standard ML is distinguished from Haskell by including references, allowing variables to be updated."
07:41:38 <dminuoso> Until you realize, that we have mutable references in Haskell just fine.
07:42:02 <merijn> ezzieyguywuf: Going from Haskell to SML is, in terms of difficulty, comparable to going from Java to C# or python to ruby
07:42:56 <ezzieyguywuf> I've never done either of those, I know java decently and python very well, i don't know either c# or ruby
07:42:59 <ezzieyguywuf> :-P
07:56:01 <Plazma> SML ? 
07:56:38 <merijn> Plazma: Standard ML
07:56:47 <dminuoso> merijn: Id say that going from python to ruby is a step up.
07:57:03 <dminuoso> Ruby has so much more ugly meta programming facilities, that are actually considered idiomatic...
07:57:04 <Plazma> merijn: ahhh how i forget that's a thing still :P
07:57:41 <Plazma> i actually enjoy ruby , but do python mostly for work and academic and research, wanting to learn haskell though
07:58:07 <wavemode> ruby is great for creating EDSLs
07:58:20 <dminuoso> It's not, really.
07:59:10 <dminuoso> Try creating a non-trivial DSL with the idiomatic missing_method, but it becomes a completely unmaintainable mess in a very short whie.
07:59:38 <dminuoso> You start adhering to completely absurd tricks, abusing the weird method lookup dispatch rules.
07:59:51 <dminuoso> But really you would have been better off writing a simple compiler.
07:59:53 <Chousuke> personally if I hear "ruby dsl" I look elsewhere
08:00:15 <Plazma> yea, i like ruby, i don't want to maintain a ruby application, though
08:00:19 <Plazma> :D
08:00:25 <dminuoso> That sounds a bit contradictory.
08:00:36 <Chousuke> they're all pretty and cool when they work, but turn into a nightmare when something goes  wrong.
08:00:49 <Plazma> ^
08:01:19 <dminuoso> If a language doesn't scale to the point that makes maintaing non-trivial applications desirable, then the language is questionable at the very least.
08:01:36 <wavemode> I don't think that's true
08:01:51 <wavemode> different languages can serve different purposes
08:01:59 <dminuoso> In a modern world where projects are tossed on github and never maintained anymore, I can see why some might think that.
08:03:44 <wavemode> If I needed a scripting language for a video game, I'd want something dynamic. Or else every content change would require a recompile (which also makes the game not really moddable)
08:03:58 <Cale> Hmm
08:04:25 <Cale> By "dynamic" you just mean "interpreted"?
08:06:23 <Cale> I would expect that a type system would be great for allowing mod authors to know how and when their mod needs an update.
08:06:56 <Cale> There are a lot of dynamically-typed mods in the world which just randomly break when games update in ways that might not even be obvious at first.
08:08:04 <merijn> Also, why would a script need to be recompiled, unless the API changes?
08:08:42 <Cale> Indeed
08:09:42 <Cale> It's nice that if it does, you don't need someone to step in and run a compiler by hand
08:10:24 <Cale> (provided that it doesn't change in a way that affects the mod in question)
08:10:27 <wavemode> yes I did mean interpreted. i.e. the engine code and scripting code should be able to communicate with each other dynamically
08:10:31 <Cale> But if the compiler is either built into the game, or the same code is interpreted, that isn't an issue
08:11:00 <Cale> It's probably perfectly okay to just compile the mods at runtime
08:11:10 <Cale> You'll get better performance out of them that way
08:12:04 <Cale> and you can keep the compilation results and reuse them until an API update happens
08:12:09 <wavemode> not sure I understand what you mean. or maybe we're talking about different things
08:12:32 <Cale> I'm saying you can compile the mod code to machine code
08:12:45 <Cale> and have the compiler just be included with the game
08:12:49 <Chousuke> Don't games often use entity component systems? You're likely to end up doing dynamic typing with a statically typed language anyway.
08:13:08 <Cale> hm?
08:13:14 <Cale> I don't see why that would be
08:13:44 <Chousuke> static interfaces don't help against mods not breaking if you have to look up entities by their dynamic attributes at runtime to hook into their behaviour
08:13:59 <wavemode> so I bundle a (for the sake of argument) entire compiler with the game, which compiles their mod as a shared object, then loads that shared object and runs it. eh? 
08:14:49 <Jon> using TH's "Name"s, some functions resolve to odd module names that are hidden e.g. 'words => Data.OldList.words. And trying to import Data.OldList (or other hidden modules)  causes a compile error
08:14:53 <Jon> any idea how to detect this? 
08:15:09 <Cale> Chousuke: Yeah, I suppose if the mod ends up having dangling references to what used to be entities that no longer exist, that's still a problem that can happen
08:15:09 <Chousuke> I'm not saying static typing can't help, but games in particular feel like the sort where you probably don't benefit as much as with other kinds of software.
08:15:43 <kuribas> Chousuke: it would help for the logic
08:16:04 <merijn> That said, IMO one of the best uses of a dynamic interpreted language was the Lua UI stuff in WoW
08:16:05 <Chousuke> and I guess it depends on the game too
08:16:17 <kuribas> Chousuke: besides, you likely take a existing engine.
08:16:19 <merijn> That was so cool
08:16:22 <justsomeguy> Does static just mean that there's a separate step between source code and execution, where errors can be pointed out? (Type checking / optimizations occur before any attempt to run things.)
08:16:51 <kuribas> Chousuke: static typing isn't a problem, but a lack of real-time garbage collector is.
08:16:56 <merijn> justsomeguy: static analysis means "without having to execute"
08:17:25 <merijn> justsomeguy: Static properties of a system (or piece of code) or those that can be established without knowing any runtime specific information
08:17:26 <Cale> Jon: hmm, maybe you could show a bit more of what you're trying to do? I haven't really run into that problem.
08:17:43 <kuribas> justsomeguy: a static type system garantuees lack of type errors at runtime.
08:17:57 <merijn> kuribas: Yes, no, maybe
08:18:30 <merijn> Type safety means that "given a certain model" a well typed expression doesn't violate said model.
08:18:47 <Cale> Jon: 'words should give you a Name which refers to whatever thing called words is currently in scope
08:18:49 <merijn> This is the part everyone always glosses over when discussing "type safety"
08:19:05 <merijn> You need to define with respect to which model you are type safe.
08:19:06 <Cale> Jon: It might be defined in some non-exposed module
08:19:28 <Cale> Jon: but given that it resolves, it's in scope and you ought to be able to refer to it
08:19:40 <merijn> Haskell's model generally rules out stuff like "out of bounds accesses", "segmentation faults", "illegal memory access", etc. (ignoring the FFI anyway)
08:19:50 <merijn> But you can define different models
08:20:20 <kuribas> merijn: "out of bounds accesses" only if you use a dependently typed vector library
08:20:43 <merijn> No, you can rule those out with checked accessors and error returns too
08:21:19 <kuribas> merijn: indeed, but that's not the type system...
08:21:25 <kuribas> that's a runtime check in the library
08:21:26 <Cale> Yeah, out of bounds accesses in the sense that you won't quietly return garbage
08:21:31 <merijn> kuribas: No
08:21:35 <merijn> kuribas: Well, yes, too
08:21:44 <merijn> kuribas: But the type system guarantees no shortcuts
08:21:49 <merijn> Compare Java vs C
08:22:03 <wavemode> well, the fact that they *can* be ruled out doesn't mean that they *are* ruled out. you can certainly access out of bounds memory in haskell if you want to
08:22:04 <merijn> Java's model explicitly defines out of bounds access as impossible.
08:22:17 <Cale> In C, you can easily end up reinterpreting other memory as values of any type
08:22:25 <merijn> wavemode: Oh sure, Haskell has tons of unsafe escape hatches, making the discussion even more confusing
08:22:47 <kuribas> merijn: I mean python has out of bounds checking.  It's orthogonal to a static type system.
08:22:52 * nshepperd2 . o O (out of bounds access vs attempted out of bounds access)
08:23:01 <merijn> kuribas: THe java type system, when combined with "the usual" model guarantees that well typed expressions never access memory out of bounds
08:23:11 <merijn> kuribas: Python does guarantee memory safety, yes
08:23:23 <merijn> kuribas: My point was the type safety guarantees need a model
08:23:58 <wavemode> and let it not be lost that the very existence of ffi makes almost all useful static typing models quite malleable
08:24:00 <merijn> kuribas: "Well typed expressions in Haskell don't access out of bounds" <- this is a useful/verifiable type safety claim
08:24:06 <Boarders> does anyone know how to link to a section (of the form -- * Section) in a haddock?
08:24:15 <merijn> There is no such thing as "type safety in a vacuum"
08:24:32 <merijn> You need to specify which behaviours are ruled out for expressions that are well-typed
08:24:55 <merijn> kuribas: Your initial statement of "static type systems rule out illegal types" is true, but also redundant
08:25:26 <merijn> Since you can also rule out illegal type combinations by taking JS approach of "allow all of them"
08:25:45 <merijn> Boarders: I'm not sure you can?
08:25:49 <kuribas> merijn: I didn't say that?
08:26:34 <merijn> kuribas: "a static type system garantuees lack of type errors at runtime." <- that's what you said
08:26:43 <kuribas> that's a different statement
08:26:46 <merijn> I mean, that's true. But trivially so
08:27:06 <kuribas> merijn: yeah, it's the difinition of a static type system.
08:27:09 <merijn> Type errors can never happen at runtime, since types are a static property
08:27:24 <ja> what if you have reflection?
08:27:56 <merijn> ja: There's lots of things that many people online call types, which are not types in the classical CS sense
08:27:57 <ja> and why cannot you have a type system in a vacuum? if typechecking completes before runtime, how is it not a vacuum?
08:28:06 <kuribas> merijn: it's trivial, yes, since that was what justsomeguy seemed to be asking.
08:28:15 <merijn> ja: YOu can have a type system in a vacuum, you can't have "type safety" in a vacuum
08:28:32 <ja> i still don't understand it, what do you mean?
08:28:43 <ja> i could have a language that only does safe things after type checking
08:28:45 <merijn> ja: Ok, let me ask you: What does type safety mean to you?
08:29:06 <ja> ultimately, type safety means that the program will not crash at runtime
08:29:23 <ja> and that it will terminate ;)
08:29:40 <merijn> ja: I know that many people think like that, but that's actually quite underspecified
08:30:16 <merijn> ja: Let's consider some arbitrary type system T and some arbitrary expression E. Now, E is either well-typed with respect to T or it is not, right?
08:30:56 <kuribas> ja: termination is not typically done in a type system.
08:30:56 <ja> yes
08:31:06 <kuribas> ja: but it's possible yes
08:31:08 <Cale> Expressions might not even make sense independently of a type system
08:31:13 <merijn> Now, when designing a language we need to define what it means for E to be well typed
08:31:14 <ja> kuribas: but dependent types does it, so it must be considered part of that
08:31:51 <merijn> ja: THat is, you need to have some formal model in which you specify "what semantics should my type system guarantee"
08:31:59 <Cale> If you're using the types of values in order to determine what the expression means, for example, via type classes, things get really fun.
08:32:13 <merijn> ja: People tend to implicitly assume a lot of properties like "shouldn't crash"
08:32:38 <merijn> ja: But consider this counter example: Well-typed C and C++ expressions/code crash all the time
08:32:57 <ja> but they are not really well-typed. since they typically rely on undefined behaviour
08:33:08 <lyxia> Boarders:  -- * MyTitle #my-anchor#           and then [you can link to it](#my-anchor)
08:33:25 <Boarders> thanks lyxia!
08:33:39 <lortabac> "type safety means that the program will not crash at runtime" -> makes me think of a language called Pony in which 0 / 0 = 0 :)
08:33:40 <kuribas> ja: termination is a pre-condition for a type-system to become a logic system.
08:33:42 <merijn> ja: Correct, so to talk about "what does type safety in C mean?" you need to define a model (the C abstract machine) and semantics and then specify "exactly what does well-typedness guarantee"?
08:34:01 <merijn> ja: Specifically, well-typedness in C does *not* guarantee the behaviour of your program is defined
08:34:10 <merijn> ja: Now consider Java
08:34:13 <ja> but aren't we mixing up the definitions of types now?
08:34:21 <ja> before, we used some academic definition of type
08:34:38 <ja> why can't we do that for C too, and simply say that it is not untyped unless the C compiler rejects code with UB?
08:34:41 <merijn> It was a concious decision of the Java designers to define a model wherein there is no undefined behaviour
08:34:50 <ja> *not typed
08:34:56 <Cale> You can think of types as properties of your program which are going to be checked by the computer. Not all important properties might be checked, and how many properties you want to encode this way is a matter of how expressive your type system is, and how much of a bureaucratic nightmare you're willing to create for yourself in changing the code later.
08:35:04 <merijn> ja: But we have types and we do typecheck C
08:35:26 <Cale> Well, that could be misleading -- types can just as much help you change the code as make it annoying
08:35:39 <ja> yeah, and there indeed are formal tools for C that allow termination proofs in comments and so on. but that is not C, since it is not required in the C spec
08:35:40 <merijn> ja: Java was designed in a way that guarantees that all well-typed expressions are defined and that you have no memory corruption (out of bounds reads, use after free, etc.)
08:35:42 <Cale> Finding the sweet spot where productivity is improved the most is tricky
08:36:05 <merijn> Part of the way Java guarantees this is by mapping, for example, null dereferences to exceptions
08:36:11 <Cale> But I think plain Haskell strikes a pretty good balance there
08:36:25 <Cale> It's nice to have the extensions though, because sometimes you want more guarantees
08:36:36 <merijn> Note that, to define the properties of well-typed expressions in Java, we need to refer to semantics and runtime behaviour
08:36:36 <ja> merijn: i totally agree that java is safe. i just don't understand why C is inheritly unsafe just because the compilers. it's just so much harder because the spec allows compilers to use UB to their advantage
08:36:47 <merijn> But that doesn't make the type-checking "not static"
08:37:04 <merijn> ja: My point wasn't about safe or unsafe
08:37:08 <ja> has it been proven that proving UB-presence is undecidable?
08:37:09 <Jon> Cale, the issue is I am print out Exps to files and compiling them as a second stage. and all the names in the expression tree are fully qualified as part of that process 
08:37:19 <Jon> Cale, I can try to point at some source if this is not clear enough
08:37:26 <Cale> C's type system just doesn't attempt to enforce a lot of properties that most would consider important. It *does* enforce a lot of things which are important though.
08:37:33 <merijn> My point was "the amount of guarantees provided by well-typedness are external to the type system and need to be explicitly modelled"
08:37:52 <Cale> Jon: ah... why are you doing that?
08:38:07 <Cale> Jon: you might be interested in some of the dumping flags in GHC
08:38:10 <merijn> When we talk about "type safety" in Java we talk about "what does our Java model guarantee about the behaviour of well-typed expressions?" Answer: quite a lot
08:38:29 <Jon> Cale, I'm writing a distributed stream-processing system. User defined a data structure (within which are TH Exps), our system carves it up into sub-programs, writes them out to different source files, which are compiled and then run on different machines
08:38:29 <merijn> What does the C model guarantee about the behaviour of well-typed expressions? Not a lot.
08:38:39 <merijn> "Type safety" is not a boolean property
08:38:56 <merijn> It's a sliding scale of guarantees that well-typedness promises to maintain
08:38:58 <ja> and my point is that the C model actually guarantees more than typically implemented
08:39:04 <Cale> -dth-dec-file will dump expansions of all top-level Template Haskell splices in Module.hs into Module.th.hs
08:39:14 <merijn> Talking about "type safety" in the absence of a model is pointless
08:39:18 <merijn> ja: How so?
08:39:31 <Cale> and it tries to do it in a way that those .th.hs files will actually compile
08:39:40 <Jon> Cale, thanks yes, I've not used that one but I do use -ddump-splices which prints them to the terminal (in GHCi for example); this isn't so much a splicing problem howeer 
08:39:49 <Jon> ah I see. let me give that a go then
08:39:51 <ja> because all the compilers fail to detect UB and warn, and instead produce code that 'fails' (in the eye of the user) at runtime
08:39:52 <merijn> ja: Also, undefinedness is trivially undecidable
08:39:55 <Jon> and see what it does with Names
08:40:00 <Jon> thanks for the hint
08:40:06 <ezzieyguywuf> I could use some help: http://dpaste.com/0GKSWFK
08:40:16 <wavemode> not all UB can be statically determined
08:40:26 <wavemode> in fact most can't
08:40:38 <ezzieyguywuf> I can't figure out how to use State here to execute this test. the `[Int]` being passed in to `runTest` is ultimately being supplied by QuickCheck
08:40:49 <ja> wavemode: all right, then i concede that C is inheritly unsafe
08:40:53 <merijn> ja: "int main(int argc, char** argv) { return argc + 19791717871; }" <- UB or not? depends on the value of argc
08:42:02 <ja> that program is unsafe since unless otherwise specified, argc can have any value that an int can have
08:42:24 <merijn> ja: Right, but then basically every program using addition is unsafe. aka literally all of them :)
08:42:32 <lyxia> ezzieyguywuf: what are "s1" and "s2"
08:42:58 <lyxia> ezzieyguywuf: ah I see they're at the bottom...
08:43:01 <merijn> ja: Which I agree with, but that's not very useful ;)
08:43:02 <ja> merijn: it should be easy to define signed integer overflow, why can't that be done?
08:43:04 <ezzieyguywuf> lyxia: if you look at the last two lines of that comment it shows `runTest` with the call signature
08:43:29 <merijn> ja: It can be done, but it's explicitly not done so it can be used to optimise loops by bounding them
08:43:31 <Jon> hm I think I have thought of a workaround. is "base" alwayt imported?
08:43:36 <Cale> Jon: Where I work, we were using -ddump-splices and then doing a bunch of sed garbage to the output in order to get Template Haskell code working for mobile applications. TH is awful for cross platform stuff, because after you compile the TH code, you end up with stuff that runs on the target platform, not the host platform where you're running the compiler.
08:44:06 <Jon> that's a good point, yes. I'm somewhat abusing TH here. I never actually splice the Exps, I run them in Q and pretty-print them to strings
08:44:29 <ja> anyway, of course i agree that type safety is not binary. cause otherwise, haskell would be just as unsafe because it compiles a division by zero without complaining
08:44:34 <merijn> ja: C's UB isn't undefined because "we can't define it", it's because it's been actively decided "not to"
08:44:36 <Cale> (I'm pretty sure we now use the flag I mentioned earlier)
08:46:38 <Jon> darn, not all of base is automatically imported, no.
08:47:02 <Cale> Yeah, base has too much stuff in it to all be imported automatically
08:47:05 <ja> anyway, would be awesome to see a new C spec release with an official way of limiting memory use of a program. then i could come in here and argue that C is safer than haskell :P
08:47:22 <Jon> I had hoped to filter on namePackage == Just "base", ah well. too easy :)
08:47:29 <Cale> In fact, I'd be surprised if you could import it all unqualified -- there's got to be a name conflict in there somewhere
08:47:34 * Jon nods
08:48:18 <wavemode> ezzieyguywuf, can you clarify what is `initial` here? I see [Int] but s1 appears to use Int
08:50:01 <lyxia> ezzieyguywuf: https://dpaste.org/YAqp
08:50:57 <wavemode> ah I see, I was misreading
08:51:07 <ezzieyguywuf> wavemode: `initial` is the initial state.
08:51:08 <lyxia> ezzieyguywuf: hm, there's a type mismatch because I was assuming both actions return the length of the list...
08:51:33 <ezzieyguywuf> lyxia: the `prepState` returns an index in the list (the list is the State)
08:52:05 <ezzieyguywuf> the `runAction` uses that index to perform some action - in this contrived case, it either does nothing to the State or changes it to []
08:52:59 <lyxia> are you supposed to ignore the result of the two actions? or is s2 supposed to be a function (Int -> MyState ())?
08:53:30 <ezzieyguywuf> lyxia: that might work, i'll try it out (the dpaste you posted)
08:53:51 <ezzieyguywuf> normally, you would s1 >>= s2
08:54:18 <ezzieyguywuf> oh wait, I'm confusing myself...
08:55:19 <ezzieyguywuf> yea that's right, s1 >>= s2 is the typical use-case, but I want to query the intermediate state
08:55:20 <lyxia> ezzieyguywuf: https://dpaste.org/zRaY
08:56:36 <ezzieyguywuf> lyxia: I think the `where test = do` is key here, I had not considered that  I could use this syntax
08:56:54 <ezzieyguywuf> of course, it makes perfect sense - test will be a MyState afterwards
09:03:33 <fresheyeball> hey folks
09:03:54 <fresheyeball> I was posting about this on #nixos just now, but not getting a response, and I am blocked
09:04:10 <fresheyeball> I have a weird one, my project builds with nix-build just fine
09:04:18 <fresheyeball> and for some reason this morning, I can't run ghcid
09:04:29 <fresheyeball> <command line>: can't load .so/.DLL for: /nix/store/g0i87xldn1hxm1gnb3cnjrvrfab67q0d-aeson-1.4.4.0/lib/ghc-8.6.4/x86_64-linux-ghc-8.6.4/libHSaeson-1.4.4.0-6fXoZ2qaEUVDCYBpShqWhf-ghc8.6.4.so (/nix/store/g0i87xldn1hxm1gnb3cnjrvrfab67q0d-aeson-1.4.4.0/lib/ghc-8.6.4/x86_64-linux-ghc-8.6.4/libHSaeson-1.4.4.0-6fXoZ2qaEUVDCYBpShqWhf-ghc8.6.4.so: undefined symbol:
09:04:30 <fresheyeball> thzmabstractionzm0zi3zi1zi0zmKacyXGqFl6k8QB9PBisbIF_LanguageziHaskellziTHziDatatype_zdfTypeSubstitutionConstructorInfozuzdcfreeVariables1_info)
09:04:48 <fresheyeball> I removed .ghc* dist* and ~/.ghc* to no avail 
09:04:56 <fresheyeball> anyone seen this before?
09:05:15 <merijn> Looks like a nix issue
09:05:47 <merijn> It's trying to load a library from the Nix store which doesn't ahve the right symbols, so it's probably the wrong compiler version or library version
09:06:50 <merijn> fresheyeball: wait, ghcid? Did you actually make sure ghcid uses the right nix config?
09:23:46 <aveltras> is there a way to get the following to typecheck ? the member_ and delete_ don't work when used in a record of functions but they do when used standalone with AmbiguousTypes extension
09:24:24 <aveltras> https://www.irccloud.com/pastebin/1m33Ux8c/
09:26:11 <ski> what is the point of the (unused) `auth' parameter ?
09:26:46 <aveltras> i've not finished it, should've removed it from the copy paste
09:26:53 <aveltras> this will be a session handle in the end
09:27:19 <aveltras> i can get it to work by adding proxy a for member_ and delete_ but i'd rather not here
09:27:41 <ski> do `member_' and `delete_' need to the `K a' constraint ?
09:27:49 <ski> s/to //
09:27:54 <aveltras> only the typeable part of it
09:28:08 <aveltras> i used a synonym here to reduce the signatures
09:28:33 <ski> hm, and that doesn't work, with `AmbiguousTypes' ?
09:28:37 <aveltras> it lookups entries in the session map by their type
09:28:38 <aveltras> no
09:28:45 <aveltras> not when used as a record of functions
09:29:16 <aveltras> it complains it cannot deduce the constraints implied by K
09:29:28 <aveltras> surely cause they aren't present in the signature 
09:31:09 <aveltras> i'll just add helper functions if it's not possible
09:32:00 <ski> mhm
09:32:37 <ski> sorry, i dunno whether one can make it work in a nice way :/
09:33:01 <aveltras> not sure either, i'll hide the proxies with helpers
09:33:03 <aveltras> thanks
09:35:31 <ski> aveltras : it seems i can manually define an accessor function, if i don't use record syntax, but enable `TypeApplications' and `ScopedTypeVariables'
09:36:47 <aveltras> ski: can you paste it ?
09:37:49 <ski>   data T = MkT (forall a. Bounded a => IO Bool)
09:38:04 <ski>   foo :: forall a. Bounded a => T -> IO Bool
09:38:10 <ski>   foo (MkT x) = x @a
09:39:48 <aveltras> yes, that's what i had before, np problem without record syntax
09:40:58 <ski> ok
09:43:20 <ezzieyguywuf> here's what I ended up with http://dpaste.com/3G0NWDJ, lyxia there was an error in my original call signature for `runTest` so I couldn't use your example as-is
09:43:35 <dfin> dminuoso: What do you mean? /q
09:43:54 <ezzieyguywuf> I could probably modify what I have using the do-stuff, but maybe I'd need two do's? and in that case I don't think it'd be more readable.
09:44:30 <lyxia> ezzieyguywuf: you wouldn't have to run prep twice
09:45:06 <dmwit> ezzieyguywuf: Odd. What is the error you get when uncommenting line 7 from that paste?
09:46:02 <lyxia> maybe (: xs) should be (++ xs)
09:46:11 <ezzieyguywuf> dmwit: error went away. I think it's because it used to be `runTest :: MyState Int -> MyState a -> [Int] -> Bool`
09:46:53 <ezzieyguywuf> oh no, I had to uncamment line 8 too to get the error
09:47:09 <ezzieyguywuf> and yes, ++ makes the error go away
09:47:23 <dmwit> Okay. What is your question, then?
09:47:28 <dmwit> I'm not sure I'm following along at this point.
09:47:35 <dmwit> Although I admit I'm missing some context.
09:48:44 <ezzieyguywuf> dmwit: lines 21-24, I'm wondering if I could write this differently/clearer using do-notation
09:48:47 <ezzieyguywuf> but I don't think so.
09:49:34 <ezzieyguywuf> lyxia: how could I re-write it without running prep twice?
09:50:06 <dmwit> You could consider something like `runTest prep run initial = flip evalState initial $ do { n <- prep; ns <- length <$> get; run n; ns' <- length <$> get; pure (ns == ns') }`.
09:50:21 <ezzieyguywuf> if I do `prepped <- prep`, I lose the return value of `prepState` which I need for `runAction`
09:50:36 <dmwit> This has the advantage of only running `prep` once.
09:50:57 <dmwit> :t gets
09:50:59 <lambdabot> MonadState s m => (s -> a) -> m a
09:51:20 <dmwit> `gets length` vs `length <$> get` is mostly an aesthetic choice, I think.
09:52:32 <EvanR> length <$> get is optimized to annoy the most anti-operator people
09:52:46 <EvanR> and is longer
09:53:12 <dmwit> By the way, your `runAction` can be simplified: `runAction i = do { xs <- get; when (xs !! i == 2) (put []) }`.
09:53:56 <dmwit> Even if you like your case statement, the `return ()` at the end is completely unnecessary, and the `put xs` can be `return ()` if you want.
09:54:23 <dmwit> Using `otherwise` as the catch-all case is... brave. ^_^
09:54:46 <dmwit> Probably not a good habit to be in.
09:55:25 <dmwit> If you keep that habit, eventually some refactoring you want to do is going to add a guard to your catch-all, and you're going to have an `otherwise` guard that doesn't do what you think it does.
09:56:32 <ezzieyguywuf> dmwit: it's a contrived example, the `runTest` is the main  focus
09:56:49 <ezzieyguywuf> dmwit: I was not aware of that I should not use 'otherwise' in a case
09:57:42 <dmwit> (Another choice you could consider for runTest if you like the current structure but only want to run `prep` once: `runTest prep run initial = ns == ns' where { (n, prepped) = runState prep initial; mutated = execState (run n) prepped; ns = length prepped; ns' = length mutated }`.
09:57:45 <ezzieyguywuf> what is 'run'?
09:57:53 <monochrom> Sometimes I wonder if it's better to never use "otherwise".
09:58:05 <ezzieyguywuf> I don't see 'run' in the State monad documentation
09:58:22 <dmwit> ezzieyguywuf: It's an argument to `runTest`...?
09:58:27 <dmwit> You named it, not me!
09:58:39 <EvanR> how does otherwise even type check
09:58:42 <EvanR> @src otherwise
09:58:43 <lambdabot> otherwise = True
09:58:46 <ezzieyguywuf> doh!
09:58:49 <ezzieyguywuf> yea sorry
09:58:50 <dmwit> EvanR: It shadows the existing one.
09:59:10 <dmwit> > let x = () in case "hi" of x -> () -- same way this type-checks, the two x's are completely unrelated
09:59:11 <EvanR> oh... yeah that's silly
09:59:12 <lambdabot>  ()
10:00:26 <dmwit> > let x = () in (x, case "hi" of x -> x) -- probably more illustrative
10:00:29 <lambdabot>  ((),"hi")
10:02:14 <EvanR> case stuff of 2 -> put xs; notTwo -> put [] -- at least won't cause that confusion
10:02:32 <EvanR> case stuff of 2 -> puts xs; _ -> put [] -- seems more nominal
10:02:40 <ezzieyguywuf> so, here's a part that confuses me: `n <- prep`, is n the resultant state or the value returned from the computation?
10:03:02 <dsal> ezzieyguywuf: _ n
10:03:13 <dsal> You can always ask the compiler when you're confused.  :)
10:03:20 <dmwit> ezzieyguywuf: The value.
10:03:31 <dmwit> ezzieyguywuf: This is why `get` exists: to transfer the state into the value. ^_^
10:04:20 <ezzieyguywuf> hah, my eyes are spinning
10:04:54 <ezzieyguywuf> so `n <- prep`, is the same as `prep >>= \n -> .....<something?....>`
10:05:02 <dmwit> yes
10:05:15 <dmwit> (with some quibbles about when `n` is a more complicated pattern than just a variable name)
10:06:09 <ezzieyguywuf> hm, i see
10:06:26 <ezzieyguywuf> and run n is the same as `run n >> \_ -> ...<something..>`
10:06:44 <ezzieyguywuf> still a bit confused
10:06:47 <ezzieyguywuf> but...i think I'm getting it
10:06:47 <dmwit> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
10:06:55 <dmwit> ezzieyguywuf: Check the box labeled "Translation" there.
10:07:22 <dsal> @undo do { n <- prep; something n }
10:07:23 <lambdabot> prep >>= \ n -> something n
10:08:16 <dmwit> ezzieyguywuf: e.g. your "run n is the same as `run n >> \_ -> ...`" is corrected in the translation box as `do { e; stmts } = e >> do { stmts }`
10:09:05 <ezzieyguywuf> is it important to put a space after the backslash and before the n?
10:09:10 <ezzieyguywuf> i feel like I read that somewhere...
10:09:18 <dmwit> No.
10:10:27 <ezzieyguywuf> ok
10:10:33 <ezzieyguywuf> well, I'm at like 85% comprehension.
10:10:37 <ezzieyguywuf> that's better than the 80/20 rule
10:10:40 <ezzieyguywuf> I'm going to take that as a win :)
10:11:19 <monochrom> Learning >>= itself gets you up to 85%.
10:11:34 <ezzieyguywuf> 👍
10:11:36 <monochrom> Learning how to translate do to >>=, the other 15%.
10:11:49 <monochrom> Learning do without >>=, 0%.
10:12:04 <monochrom> which is known as cargo culting.
10:12:19 <ezzieyguywuf> yea but my confusion is specifically with what's going on in the State monad - my brain is struggling to keep track of how a (of m a) is a function for State
10:12:30 <ezzieyguywuf> cargo culting?
10:12:44 <ezzieyguywuf> ah, i googled it
10:12:45 <ezzieyguywuf> lol
10:12:47 <dmwit> That's okay. Everybody required a little struggle their first time with State.
10:13:10 <dmwit> Be patient with yourself, and with the concept, and you will come out the other end stronger.
10:13:32 <ezzieyguywuf> 😁 thanks for the kind words.
10:13:39 <monochrom> I dread expanding State's >>= by hand, but some students have found it useful.
10:14:03 <ezzieyguywuf> hah, I'd be one of those students. don't worry, I plan to write it out by hand on my own though
10:14:15 <ezzieyguywuf> I must say, State is a pretty neat way to do...well State.
10:14:26 <seanparsons> Does anyone know if there are any RTS options for the IO subsystem? Vague Googling doesn't show anything, but also doesn't outright indicate there's none.
10:14:31 <ezzieyguywuf> it's wonderfully descriptive while still being mostly intuitive and useful.
10:15:06 <[exa]> seanparsons: you want to consult the ghc manual
10:15:43 <monochrom> also "RTS options for the IO subsystem" is criminally vague and broad
10:16:17 <[exa]> seanparsons: roughly around here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#setting-rts-options
10:16:32 <monochrom> but we can combat vague and broad existential question by the simple answer "yes, something exists".
10:17:34 <monochrom> the witness has nothing to do with what you secretly want, but it so satisfies the "IO subsystem" bill.
10:18:13 <monochrom> Why do programmers keep asking overgeneralized questions?
10:18:27 <dmwit> I don't know, but you are certainly keeping up the tradition. ^_^
10:18:42 <monochrom> Tell me if I'm wrong, but I never saw music students speaking like that to their music teachers.
10:18:47 <ivegotasthma> hello, I'm not able to understand if the code that the teacher provided is broken, and if I can fix it without altering the type signature https://pastebin.com/raw/TMwSx4m8 any advice?
10:19:46 <monochrom> If a violin student has a problem with vibrato, they are eager to show and tell their teacher, in person if at all possible, how they are already doing vibrato so the teacher knows exactly where they are at.
10:20:09 <monochrom> Tell me if I'm wrong, but no violin student will just broadly say "so how do you do vibrato again?"
10:20:15 <dmwit> ivegotasthma: Almost certainly the `Var` in the definition of `Subst` is intended to be `Variable`. Other than that the code looks fine to me.
10:20:24 <monochrom> And yet programmers do exactly that.
10:20:41 <dmwit> Oh, nah, this happens in all fields.
10:20:46 <ivegotasthma> dmwit: thanks
10:21:08 <dmwit> The question they ask is even worse. It's "is there a way I can change the sound the instrument is making?".
10:21:16 <dmwit> When what they mean is "how do I do vibrato?".
10:21:32 <monochrom> Damn humanity.
10:21:34 <dsal> ezzieyguywuf: in haskellbook.com, you learn State by implementing it.  It was a bit weird for me, as I understood how it worked before I understood how to do anything useful with it.
10:22:28 <ezzieyguywuf> dsal: that's the one that costs like $70 right?
10:22:49 <SrPx> Hey FP wizards, do you think it is possible to write a `no_overflow` function in JavaScript that acts like the Y-Combinator (by turning a non-recursive function into a recursive one), except that the resulting recursive function **uses a manual stack**? 
10:22:53 <dsal> People complain about both the price and the amount of material it has, heh.
10:23:15 <[exa]> SrPx: what is a manual stack?
10:23:37 <dsal> I bought a mainframe once.  I filled a spare room with stacks of manuals.
10:23:44 <dmwit> Yes, I think that's possible, if you are willing to declare how many arguments the function-to-be-fixed is supposed to have (or take the Haskell approach of "it always has exactly one argument").
10:23:46 <SrPx> Asking here because I obviously won't get that kind of answer in a JS channel. This problem seemed easy to solve with `yield`, until I realized that `yield` doesn't work under lambdas, so the solution would only work if the recursive function doesn't return another function.
10:24:00 <[exa]> dsal: surprisingly Google says roughly the same :]
10:24:03 <SrPx> [exa]: I mean that the function would use its own stack (rather than the JS runtime stack) to perform its recursion.
10:24:15 <SrPx> In other words, it wouldn't overflow.
10:24:17 <SrPx> For example:
10:24:26 <monochrom> SrPx: Look for "trampolining". Also involves continuation-passing style. You will overflow the heap instead.
10:25:12 <seanparsons> [exa]: Seems like the answer is no, unless I'm being a total idiot.
10:25:26 <[exa]> can javascript do tailcall elimination itself?
10:25:41 <monochrom> My http://www.vex.net/~trebla/tail.html is an example. Take a look at its source code.
10:25:42 <SrPx> monochrom: pretty sure trampolining (as I know it) won't work if the function itself returns another function
10:25:44 <SrPx> am I mistaken?
10:25:56 <[exa]> seanparsons: my answer was a bit generic too, seems like there isn't much IO related.. Is there anything specific you want to change with the option?
10:25:59 <solonarv> it's not in the language spec and AFAIK none of the major VMs/interpreters eliminate tail calls
10:26:08 <solonarv> but it should certainly be *possible*.
10:26:24 <monochrom> My functions return moar functions all the time.
10:26:37 <monochrom> err wait, I think I know what you mean.
10:27:34 <SrPx> imagine, for example, that your recursive function is the identity over HOAS lambda terms...
10:27:35 <dmwit> monochrom: Hm. I think this is not an in-JS implementation of fix, but a meta-fix that can be done by an external tool.
10:27:43 <SrPx> surely a naive trampoline won't work with that
10:27:48 <[exa]> SrPx: at the bare minimum you can define your own structures for closures, thunks and everything where you are not forced to return functions that carry their own scope, and just run the thunk evaluator on that
10:27:54 <SrPx> I'm looking for a general solution that *works for any recursive JS function*
10:28:04 <monochrom> Yeah! So maybe make your own object type so you can distinguish "intended function" vs "continuation".
10:28:29 <monochrom> Yes dmwit, I do it by hand.
10:28:36 <SrPx> [exa]: yea but then you're implementing a functional runtime, but this still doesn't solve the problem of having a *js decorator* that works for *js functions*
10:29:20 <SrPx> so, basically this:
10:29:22 <SrPx> no_overflow(function(count) { return (n) => n === 0 ? 1 + count(n - 1); });
10:29:35 <SrPx> here, `no_overflow` would take any recursive function and remove its stack limit
10:29:37 <monochrom> I looked around for in-JS solutions, they all involve doing your own JS parsing. They all decide to be incomplete about it.
10:29:45 <[exa]> SrPx: anyway, this might be related: https://dl.acm.org/doi/pdf/10.1145/773184.773202 (really I'm not sure how deep the rabbit hole you want to go :] )
10:29:46 <SrPx> hmm, I see
10:30:03 <seanparsons> [exa]: Nothing specific. What I'm seeing is a gradual but plateauing consumption of memory when "doing a lot of IO" where the OS is telling me that the process is using 3x+ the memory that `-s` reports for maximum heap space used when the process is terminated.
10:30:10 <wavemode> but how does it intercept the given function's self-call? is rewriting the given function part of this process?
10:30:28 <monochrom> By that point I would rather do manual trampolining or switching to purescript or something.
10:30:40 <seanparsons> Think 100MB versus nearly 400MB reported by the OS and ideally it would be a good chunk lower.
10:31:07 <SrPx> no, in the same sense the Y-combinator doesn't need any sort of quoting or rewriting; basically you should be able to do it by some clever closure manipulation
10:31:16 <monochrom> Like, if you're looking for a TCOing compiler, may as well go all out and use a Purescript compiler. :)
10:31:38 <SrPx> well this is for Formality which is kind of a PureScript competitor lol 
10:31:42 <[exa]> seanparsons: hm, can you get the memory profile on the beginning and compare it with one from the end?
10:32:57 <monochrom> defunctionalizing is unnecessary for javascript, actually plays to the weakness of javascript
10:33:34 <monochrom> defunctionalizing is when, and because, the target language sucks on the HOF front.
10:33:47 <monochrom> (but strong on the data front)
10:33:55 <EvanR> SrPx: the issue with your no_overflow is that the lambda passed in will execute eagerly and you can't stop it (without unparsing and rewriting it)
10:34:02 <monochrom> so you convert your continuations to data tags.
10:34:15 <EvanR> the first time you call it, it blows the stack because it was already compiled
10:34:32 <monochrom> but why would you convert functions to data tags in javascript? it sucks at data tags.
10:34:45 <SrPx> that is not true because the function isn't calling itself recursively, notice the `count` argument
10:35:06 <SrPx> it allows you to intercept recursive calls and manipulate accordingly 
10:35:06 <EvanR> you're right
10:35:15 <SrPx> for example, check this library: https://github.com/maiavictor/diagonalize
10:35:24 <EvanR> but i thought you wanted it to work on any javascript function that is recursive
10:35:27 <SrPx> I've written it to allow BFS-like recursion to search diagonally in infinite spaces
10:35:52 <SrPx> but it also has a DFS mode which allows you to emulate recursion with a heap-based stack
10:35:58 <wavemode> SrPx: the y-combinator turns a function which takes a function as an argument into a recursive function by passing that function to itself. it doesn't take a function that is already recursive and somehow change it
10:36:28 <SrPx> but it requires you to write your function in a monadic style which, among other things, makes it incompatible with recursive functions written for HOAS datatypes 
10:36:43 <SrPx> (because once you get inside a binder you can't return the monadic constructors outside)
10:37:13 <SrPx> wavemode: exactly, that *is* what I'm asking
10:37:22 <SrPx> notice my example isn't a proper recursive function, but one that receives itself
10:37:48 <wavemode> then that's certainly doable
10:37:56 <SrPx> I wouldn't be so sure!
10:38:44 <SrPx> so, for example
10:38:53 <SrPx> no_overflow(function(count) { return (n) => n === 0 ? 1 + count(n - 1); });
10:39:28 <SrPx> since no_overflow receives a function that expects a recursive copy of itself, what it can do is send, instead, an altered version that captures arguments and adds to a stack
10:39:35 <wavemode> if the given function is already written in continuation-passing style, you just need a tail-call optimizing js runtime. which I believe node can with a certain flag 
10:39:55 <SrPx> so, we would run `function(count) { return (n) => n === 0 ? 1 + count(n - 1); }` once, capture its recursive call arguments (in this case, n-1) and add to the stack, plus a continuation
10:39:57 <solonarv> I don't think it's possible here (without unparsing and rewriting the function)
10:40:02 <SrPx> the problem is that the continuation would be in the shape:
10:40:14 <solonarv> however you can do it if you limit to tail calls
10:40:22 <SrPx> `1 + X` (where `X` should be substituted by the result of `count(n - 1)` when we have it)
10:40:49 <SrPx> so that means we'd need a λ somewhere to connect to that `x` and leave it suspended
10:41:01 <wavemode> to be frank, even haskell can stack overflow if you don't use tail calls
10:41:08 <SrPx> *but* we already called the function, so we can't magically make an extra lambda appear
10:41:17 <SrPx> basically, we'd need N lambdas for N recursive calls
10:41:45 <solonarv> tail calls don't help you agaisnt stack overflows in haskell
10:42:00 <solonarv> (because haskell does not *have* a call stack)
10:42:02 <SrPx> as in, `n === 0 ? 1 + f(x - 1) + f(x - 1)` would become `a => b => 1 + a + b`, where `a` and `b` are waiting for the results of the recursion... but there seems to be no way to do it
10:42:02 <dolio> All calls are tail calls.
10:42:08 <SrPx> (sorry for the wall of text)
10:42:50 <merijn> SrPx: Haskell doesn't have a function call stack
10:42:50 <SrPx> @wavemode Formality's compiler is doing tail call optimization already, the problem is those recursive functions that are *not* tail recursive blowing the stack so quickly
10:42:50 <lambdabot> Unknown command, try @list
10:42:59 <merijn> SrPx: Or rather, GHC Haskell doesn't
10:42:59 <SrPx> like you can't fold over a list of 10000 elements without blowing the stack
10:43:17 <SrPx> merijn: I'm aware, all goes on its ""heap""
10:43:36 <merijn> SrPx: Define "all"
10:43:45 <wavemode> the strict foldl can recurse to any depth, specifically because it's tail recursive and strict
10:44:09 <merijn> wavemode: The issue isn't tail recursion or no
10:44:58 <merijn> wavemode: The issue is lazy leaks, the solution is "sufficient strictness". Sometimes the only way to add sufficient strictness is by rewriting in a tail recursive style
10:45:33 <merijn> wavemode: But the tail recursion isn't relevant for fixing the laziness leak, merely facillitating the addition of strictness
10:46:34 <wavemode> that sounds like a distinction without a difference :p
10:46:42 <solonarv> wait. if this is for a compiler, why are you asking about transforming JS functions?
10:46:52 <solonarv> can't you just generate JS that doesn't blow the stack in the first place?
10:46:54 <wavemode> all I'm, saying is that sometimes you need to write things tail recursively, even in haskell
10:47:03 <merijn> wavemode: It is, because if you switch to tail recursion without strictness nothing changes
10:47:36 <SrPx> solonarv: yes, that is a second, related but not identical question. If I had a proper `no_overflow` decorator, I could use it on my compiler *and* in other places where I could need it (it would be immensely useful to have such a thing in JS in general)
10:47:47 <merijn> SrPx: Anyway, if by heap you meant "GHC just has the function call stack on the heap", then that's not what happens. There is no function stack at all
10:47:56 <SrPx> if that's not possible then yea, I'll just need to transform my recursive functions to use manual stacks (which obviously *can* be done)
10:48:01 <merijn> SrPx: Are you familiar with trampolining?
10:48:31 <SrPx> merijn: I just meant that there is no call stack, it is just a big graph that lives on heap as far as I understand
10:48:50 <SrPx> (not sure if it is even called "heap" though)
10:48:58 <solonarv> that's pretty much right
10:49:30 <merijn> SrPx: Yeah, but more fundamentally there's no bookkeeping at all for functions. Function calls are compiled to assembly jumps
10:50:28 <SrPx> but anyway, the #1 challenge would be to have such no_overflow function. it looks like it would be possible with some js hacks, but it may be impossible. i really don't know, which is why I asked (:
10:50:45 <[exa]> SrPx: does "some js hacks" include GOTO ?
10:51:21 <merijn> SrPx: Trampolining is the common way to implement arbitrary recursion without blowing your stack when compiling to something imperative (I've done it in C, but should be just as possible in JS)
10:51:45 <monochrom> JS doesn't have GOTO.
10:52:41 <SrPx> I don't think even `GOTO` would help tbh
10:53:07 <SrPx> I'm leaving the question on SO in case anyone has any idea
10:53:08 <SrPx> https://stackoverflow.com/questions/62200546/is-it-possible-in-general-to-transform-a-recursive-function-in-one-that-uses-a
10:53:14 <SrPx> merijn: I'll read more about it, then
10:53:57 <monochrom> trampolining in C is painful
10:54:11 <monochrom> but perhaps you also defunctionalize
10:54:22 <monochrom> well, that's still extra work
10:54:28 <tdammers> everything is painful in C, but some things are painful in a cleansing way
10:54:35 <SrPx> are you sure trampolining works in the general case?
10:54:49 <monochrom> yes
10:55:23 <monochrom> but it means you write code in a funny way
10:56:58 <SrPx> how can a HOAS identity be written with CPS though? let me see
11:02:56 <ezzieyguywuf> ok, another State question. Let's say I have a State s. If I'm doing `do x <- s; y <- s; pure $ x + y`, is there a way do to something like `x, y <- callTwice s`?
11:04:27 <wavemode> callTwice :: State s a -> State s (a, a) ?
11:04:46 <ezzieyguywuf> wavemode: yea, something like that
11:05:02 <dolio> @type \m -> (,) <$> m <*> m
11:05:04 <lambdabot> Applicative f => f a -> f (a, a)
11:05:20 <mniip> :t liftA2 (,)
11:05:21 <lambdabot> Applicative f => f a -> f b -> f (a, b)
11:06:04 <ezzieyguywuf> dolio: in your example, are the two a's the same value or the same type only?
11:06:06 <mniip> might wanna immediately opt for liftA2 (+)
11:06:32 <ezzieyguywuf> mniip: the simple (+) in my example was only to make a complete example
11:06:48 <ezzieyguywuf> but I guess I could probably liftA2 with myFuncThatNeedsXAndY
11:07:08 <dolio> ezzieyguywuf: In your original example, are x and y the same value or only the same type?
11:07:54 <ezzieyguywuf> dolio: same type
11:07:56 <SrPx> monochrom: I think you're wrong
11:08:06 <dolio> Same answer. :)
11:08:11 <ezzieyguywuf> hah, ok
11:08:16 <wavemode> liftA2 probably makes the most sense. still, for my curiosity there is actually a hoogle result for `m a -> m (a, a)` , in hw-hedgehog
11:08:37 <SrPx> how do you write this with CPS? https://gist.github.com/MaiaVictor/e3566bc80edf25d4d132ea4da800243f
11:08:38 <wavemode> eh I dont' think it works though
11:08:57 <SrPx> I'm not sure how to fill the Lam case on id1
11:09:47 <monochrom> I will have to make major modification to "Lam (Term -> Term)"
11:09:50 <SrPx> (line 15)
11:11:32 <monochrom> But I'm too lazy to do it now. Office hours for a unix course. Ask me about shell scripting instead. :)
11:12:53 <SrPx> what would such major modification do?
11:13:08 <SrPx> just let me know your idea and I can implement it (:
11:13:13 <SrPx> it seems impossible though
11:13:18 <SrPx> I may be missing something obvious though
11:13:19 <SrPx> https://stackoverflow.com/questions/62201446/is-it-possible-to-convert-a-hoas-function-to-continuation-passing-style
11:13:24 <SrPx> posted on SO in case anyone is curious
11:19:33 <frdg> im trying to use the `Text.Trifecta` library.  I put `trifecta`, into my build depends section of my `.cabal` file. When I run `cabal repl` (I have cabal version 3.2), I get this error message:  https://pastebin.com/Ai4dqtxR
11:20:47 <solonarv> frdg: looks like some libraries aren't updated to ghc 8.10 yet
11:21:15 <frdg> solonarv: Am I just out of luck?
11:21:41 <solonarv> no, you can use ghc 8.8 instead
11:22:02 <frdg> solonarv: How do I do that?
11:22:14 <solonarv> how did you install GHC in the first place?
11:23:02 <frdg> one moment
11:23:55 <frdg> zypper install ghc-template-haskell-devel
11:23:56 <dolio> You can tell cabal to allow newer versions for things in a project file, too.
11:24:19 <solonarv> what's zypper? system package manager?
11:24:23 <frdg> yes
11:24:43 <solonarv> does it allow installing multiple versions of a package?
11:25:22 <frdg> not sure ill look into that right now
11:25:30 <dolio> Like `allow-newer: base` in cabal.project.
11:25:42 <wavemode> it might be simplest to use stack, which allows you to specify a ghc version and it will install it and set it up for you
11:26:02 <solonarv> for fuck's sake, stack doesn't magically solve everything
11:26:15 <solonarv> (the lesson here is "don't use system package managers for haskell development", kids)
11:26:21 <wavemode> who hurt you solonarv :p
11:27:24 <solonarv> :p
11:27:57 <solonarv> frdg: btw, I wouldn't exactly recommend doing that even if it turns out to be supported
11:28:11 <solonarv> throw out the package manager-installed GHC and use ghcup
11:28:27 <monochrom> "zypper: package management by differentiating ADTs" :)
11:28:33 <frdg> solonarv: ok
11:29:22 <monochrom> ghcup is more-transparent, fewer-moving-parts magic than stack
11:29:38 <monochrom> so long as you're still looking for magic
11:30:07 <monochrom> (if not, ghcup lives up to the unix do-one-thing-well philosophy)
11:30:16 <solonarv> ghcup pretty much just downloads binaries and places them in ~/.ghcup - very approachable
11:30:27 <frdg> should I keep cabal?
11:31:08 <monochrom> Use stack or use ghcup's cabal. Don't use system package cabal.
11:31:21 <frdg> ok
11:31:40 <monochrom> basically more freedom to move to a newer version without confusing yourself
11:31:59 <monochrom> or even to an older version if necessary
11:32:45 <monochrom> system package is great when you don't care which version you get and it seems to work fine. for example hexchat. browsers. terminals.
11:33:07 <monochrom> ghc? you're going to switch ghc versions faster than any linux distro updates.
11:33:31 <monochrom> This is why I don't understand people religionizing system packages.
11:34:32 <monochrom> And no, "easier to delete" is not a reason. "./configure --prefix=/usr/local/myghc" exists.
11:34:53 <solonarv> and also 'rm -r ~/.ghcup ~/.cabal' - boom, gone'
11:36:17 <maerwald> you can also have ghcup compile the tools, but i guess most people don't use that feature
11:37:04 <monochrom> When will there be a "linuxup" so I can build my linux from the ground up? :)\
11:37:27 <monochrom> "1. Boot windows.  2. linuxup"
11:37:41 * [exa] remembers gentoo
11:37:50 <wavemode> docker?
11:37:59 <slack1256> nix-rebuild
11:38:47 <maerwald> slack1256: you're running out of disk space :p
11:39:08 <maerwald> and wavemode too
11:40:18 <frdg> alright I nuked my haskell stuff and am installing ghcup. Will everything generally work the same as before?
11:40:44 <maerwald> no, only better
11:40:56 <solonarv> if you were using ghc + cabal >=3.0 before, then yes
11:41:03 <solonarv> everything will work the-same-or-better
11:42:29 <frdg> things were going great then this happened: https://pastebin.com/dk0Nq15t
11:43:27 <justsomeguy> Do you have make installed?
11:44:01 <justsomeguy> (You can use "rpm -q make" to check.)
11:44:21 <monochrom> yeah probably lacking make.
11:44:22 <frdg> justsomeguy: It was not.
11:44:36 <monochrom> but $HOME/.ghcup/logs has useful logs
11:44:44 <justsomeguy> Try installing make with "zypper in make", and then try ghcup again.
11:44:56 <frdg> justsomeguy: thanks
11:45:36 <maerwald> did you press enter a lot?
11:46:08 <maerwald> when it told you which deps to install :p
11:49:59 <justsomeguy> Is darcs more pleasant to use than git?
11:50:17 <wavemode> define pleasant
11:50:19 <hakko> heard that merging is easier
11:53:23 <maerwald> I heard that it's easier as long as you don't have actual conflicts
11:53:39 <wavemode> just like marriage
11:53:45 <maerwald> lol
11:54:39 <justsomeguy> The main reason I ask is because I get fussy with rewriting history into a progression of nice independent commits and it just takes a ton of time to do right.
11:55:05 <justsomeguy> This is probably a workflow issue rather than a vcs issue, though.
11:55:49 <dolio> I think it is a VCS issue, because the VCS should have a good enough interface that you don't care about that.
11:55:52 <seanparsons> [exa]: Can you snapshot a memory profile like that? As in without something like gdb/valgrind.
11:56:38 <dmwit> darcs makes creating patches hunk-by-hunk the default. git makes creating patches file-by-file the default. The darcs default is much friendlier to the kind of repo surgery you are describing.
11:56:42 <maerwald> git is about state, not patches. just embrace it
11:56:51 <dolio> Darcs doesn't even track 'history' though. It tracks patches.
11:57:10 <dmwit> ("hunk" here means "collection of adjacent changed lines", roughly)
11:57:23 <frdg> It worked. Before I installed ghcup I made sure I had gotten rid of all my haskell stuff by trying and failing to run `ghci` and `cabal repl`. Because they now work Im assuming the ghcup install was successful. Im back at square one though where I cannot import `Text.Trifecta`. Here is the error message when I run `cabal repl`:
11:57:23 <frdg> https://pastebin.com/qfR6PXMB
11:58:17 <maerwald> create consistent states that represent something reasonable. Atomicity isn't about small patches
11:58:19 <dmwit> GHC version and base version are tied together.
11:58:39 <dmwit> The learning package, by setting the version constraint `base >=4.14 && <4.15`, has claimed it only supports a specific GHC version.
11:59:06 <justsomeguy> Good point, maerwald
11:59:08 <dmwit> You may try porting the learning package to the version of base provided by your GHC (usually this just involves changing the constraint) or you may ask cabal to use the version of GHC that learning already supports.
11:59:21 <dolio> Of course, you're not really tracking history, either. You're tracking a made up narrative. :þ
11:59:39 <frdg> dmwit: Ok so I just need to change the base version?
11:59:52 <maerwald> frdg: run `ghcup list`. It shows u the base versions too
12:00:16 <dmwit> I think I outlined the two possible changes? Neither of them is "change the base version". One is "change the version constraint that learning puts on base", the other is "use a different compiler".
12:00:44 <frdg> dmwit: ok thanks
12:00:53 <frdg> maerwald: ok
12:01:15 <maerwald> u can actuallz run: ghcup set base-4.8.0.0
12:01:21 <maerwald> sth like that
12:01:27 <dmwit> cute
12:01:39 <maerwald> mz new kezbiard is killing me
12:01:50 <monochrom> haha
12:02:14 <monochrom> Did you switch from German to English keyboard? The other direction?
12:02:21 <maerwald> I
12:02:33 <monochrom> "z keyboard ist killing mein"
12:02:37 <maerwald> flashed it and it swallowed the kez
12:03:34 <dmwit> Well, this went in an unexpectedly erotic direction.
12:04:20 <monochrom> justsomeguy: pijul has the potential of becoming more pleasant than both.
12:04:25 <maerwald> can recommend ergodox though
12:04:41 <maerwald> I feel like riding a tank
12:04:49 <monochrom> more efficient than darcs and more pleasant patch theory than git
12:05:21 <dolio> I've heard pijul is kind of stalled. Also there are apparently some darcs improvements coming that are somehow different than pijul.
12:05:25 <maerwald> programming kills u, fix zour k
12:05:29 <maerwald> ergonomics
12:07:24 <dolio> Pijul does have an interesting solution to conflicts, though.
12:08:23 <monochrom> OK maerwald has become a grumpy old-geezer :)
12:08:24 <dolio> I'm not really familiar with the new stuff the darcs folks came up with to address that.
12:09:27 <dolio> Some of the stuff you hear about darcs with respect to conflicts is really old, though, and has already been addressed at least partially.
12:09:35 <slack1256> Do the pijul guys also address the lack of a DAG on darcs?
12:10:09 <monochrom> maerwald: Ubuntu desktop 20.04 doesn't install curl by default. (wget is yes.)  Ubuntu server 20.04 still installs curl by default.
12:10:47 <monochrom> This could affect ghcup in the near future when more newbies with ubuntu desktop (that's going to be my students).
12:14:00 <merijn> monochrom: Was maerwald ever *not* a grumpy old geezer? ;)
12:14:31 <frdg> I got it to work! You all are very helpful. huge thanks.
12:14:35 <justsomeguy> monochrom: Right, I've been looking at darcs, pijul, and fossil lately.
12:14:38 <merijn> dolio: I don't think pijul is stalled, they were working on finishing the v1.0 rewrite in january
12:15:01 <merijn> dolio: They do seem to prefer developing in a closed collaboration and only opening the source when they're done...
12:15:07 <dolio> Ah, okay.
12:17:49 <monochrom> I prefer the cathedral approach too.
12:18:03 <monochrom> or at least a decent-size chapel
12:18:23 <monochrom> a bazaar is where you lose valuables to pick-pockets
12:18:42 <dolio> But it's also a good version control system. :)
12:19:22 <monochrom> hehe
12:19:26 <merijn> monochrom: To be fair, you can have the source publically readable without actually accepting public contributions :p
12:22:24 <wavemode> see: any google project
12:29:57 <dsal> I've contributed to google haskell projects.  :p
12:31:24 <dsal> I still use darcs some, but I don't really understand how to use it.  I don't think I'm going to ever get good at it again.  I used to do neat things with it.
12:33:07 <tdammers> how about a bazaar held in a cathedral that is mainly used as a tourist attraction these days
12:33:10 <tdammers> best of both worlds!
12:33:48 <[exa]> (in the end, everyone builds a garden shed)
12:33:48 * hackage hledger-iadd 1.3.11 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.11 (hpdeifel)
12:55:29 <ezzieyguywuf> is it reasonable to do something like `myFunc :: MyState (Maybe ())`, where I don't need a return value, only whether or not it succeeded?
12:56:51 <timCF> Hi again) Guys, any opinion why do we have both `return` and `pure`? Looks like some people use one, some other, but seems purpose of them is the same. I'm personally like `pure` because it's shorter and not confuse guys with some experience with procedural languages where `return` has very different meaning.
12:56:52 <ezzieyguywuf> hrm, or maybe more appropriate `myFunc :: Maybe (MyState ())`
12:57:02 <comerijn> ezzieyguywuf: Or a custom datatype ;)
12:57:06 <maigner> MyState Bool?
12:57:10 <dsal> ezzieyguywuf: Maybe () is Bool.
12:57:13 <comerijn> timCF: Hysterical raisins
12:57:16 <dsal> Except with even more blindness.  :)
12:57:19 <ezzieyguywuf> timCF: it has something to do with history, i.e. monads came about before functors or something
12:57:28 <Cale> timCF: return was around for much longer. Applicative is relatively new.
12:57:32 <ezzieyguywuf> comerijn: lol, hysterical
12:57:50 <dsal> timCF: https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/monad-of-no-return
12:57:54 <comerijn> ezzieyguywuf: http://www.catb.org/jargon/html/H/hysterical-reasons.html
12:57:54 <Cale> Functor was around I think as long as Monad has been
12:57:57 <ezzieyguywuf> comerijn: a custom data type like what?
12:58:05 <Cale> It's just Applicative that was late to the party
12:58:15 <comerijn> ezzieyguywuf: "data Status = Error | Success" ;)
12:58:15 <Cale> Personally, I like the extra bit of typing information that return gives
12:58:18 <ezzieyguywuf> that's the one, applicative
12:58:38 <comerijn> Cale: I checked, functor is at least as old as Monad, yeah
12:58:44 <dsal> Applicative is the missing link.  Somehow evolution skipped it, but it was later discovered.
12:58:46 <dminuoso> I prefer `pure` because it doesnt incur unnecessarily strong constraints, and because it has a better connotation than return.
12:58:57 <ezzieyguywuf> comerijn: hah, yea i considered that, but on Success I want the MyState, in which case I guess `data Status = Error | Success MyState`
12:59:03 <Cale> When I see someone use "pure", I expect no Monad instance
12:59:12 <dminuoso> dsal: Actually Applicative is not quite a missing link, it's very orthogonal to Monad actually.
12:59:15 <ezzieyguywuf> which is essentially `Maybe (MyState ())`.....
12:59:23 <Cale> and it's always mildly annoying to find out that a Monad instance is known to exist
12:59:24 <comerijn> timCF: Applicative wasn't invented/discovered until ~2004, Monad has been in Haskell since (I think?) Haskell 1.4 which was about 1996?
12:59:38 <dsal> dminuoso: Is it orthogonal if monads are applicative?
12:59:52 <dminuoso> dsal: Sadly the typeclass hierarchy suggests that Monad is sort of "more specialized than Applicative", but the real relationship is that Monads *incidentally* induce trivial Applicatives.
12:59:53 <comerijn> dsal: No, Monads by definition are also Applicative
13:00:18 <maigner> ezzieyguywuf, how is type Status = Error | Success Mystate not just type Status = Maybe MyState?
13:00:25 <dminuoso> dsal: Conceptually, Applicative is more about parallelism/branching in an abstract sense, whereas Monad is more about sequencing in an abstract sense.
13:00:35 <dsal> comerijn: That's what I mean.  If a thing is another thing, then "orthogonal" doesn't quite seem right.
13:00:35 <comerijn> dsal: The monad interface is a superset (i.e., more powerful than) Applicative. Or, alternatively, types that are Monads are a subset of types that are Applicative
13:00:36 <maigner> ezzieyguywuf, whoops ignore that, I misunderstood you
13:00:43 <dolio> What?
13:00:45 <ezzieyguywuf> maigner: I said that
13:00:48 <Cale> dminuoso: I'm not sure I entirely agree about the parallelism remark
13:00:56 <Cale> Applicative can be about sequencing as well
13:01:22 <Cale> The difference is just that you don't get to determine what happens next based on the result of anything
13:01:24 <dminuoso> Cale: Im hinting at the endofunctor monoid story.
13:01:44 <dminuoso> "applicative is a diamond" yada yada
13:02:04 <dminuoso> Think we discussed this at length a couple months ago
13:02:17 <Cale> So you *could* induce parallelism or concurrency, since you're not stuck waiting on results, but if there's a Monad instance, it's probably best not to do so, because you'll make ap work differently from <*>
13:02:39 <comerijn> Cale: That's just a historical flaw in ap, though :p
13:02:50 <dminuoso> The only reason you'd see Applicative as having to do with sequencing, is because Haskell demands coherence.
13:02:52 <comerijn> Cale: If we just redefine "ap = (<*>)" that argument no longer holds
13:03:09 <Cale> I don't think we'd like to do that
13:03:26 <comerijn> Cale: Only because it breaks existing instances, but there's nothing unsound about it
13:03:28 <dsal> What, ap and <*> aren't the same thing?
13:03:28 <Cale> ap is the canonical way to implement the Applicative structure which agrees with the Monad instance
13:03:39 <dminuoso> Cale: That is, if it has that (again, conceptually) sequencing monad, then the applicative has that same sequencing effect built-in for no other reason than "that's what coherence wants"
13:03:41 <comerijn> dsal: "ap" is implemented in terms of >>=
13:03:45 <timCF> Applicative are about parallelism, not sequencing, for example I often write parsers with applicative, something like `User <$> name <*> phone <*> address`. It works fine while data fields are not depend on each other. When they are dependent, Applicative can't help anymore and Monad is coming to the show
13:03:51 <comerijn> dsal: So, define "the same thing"
13:03:53 <Cale> dsal: They don't have to be the same thing, but there's a law which says they are now
13:04:04 <dmwit> Sure, and let's just throw away the fmap = liftM law, too.
13:04:05 <dsal> Oh weird.  I just assumed they were the the same like fmap and <$>
13:04:07 <dminuoso> timCF: Fun fact, you can use selective functors in many cases!
13:04:13 <Cale> and which you'll break by defining <*> to be concurrent
13:04:25 <dminuoso> timCF: They give you the benefits of Applicative, dependent effects *and* static analyzability!
13:04:34 <Cale> I'm uncertain as to whether that law exists
13:04:35 <dmwit> NO! fmap = liftM and (<*>) = ap are good laws. They help us understand what the instances do, and prevent us from writing strange instances.
13:04:39 <comerijn> dsal: ap predates Functor being a superclass of Monad and predates Applicative, so it can't be defined as such
13:04:41 <Cale> er, typo
13:04:52 <Cale> I'm uncertain as to whether that law *ought* to exist
13:04:53 <wavemode> laws /= implementation
13:04:55 <dminuoso> dmwit: And they help us refactor code mechanically.
13:05:05 <dsal> comerijn: I also assume haskell fixes historical artifacts as time passes.  :)
13:05:29 <comerijn> dsal: The problem is that when Applicative was added, people implemented "(<*>) = ap" since they already had Monad instances
13:05:54 <dminuoso> comerijn: Well, without that law the superclass relationship would be silly.
13:05:55 <comerijn> dsal: Defining "ap = (<*>)" breaks those instances in a way that isn't caught by the type checker and turns ap and <*> into infinite loops
13:06:06 <timCF> dminuoso selective functors sounds very smart) Maybe even too smart for me, but I'll take a look, thanks)
13:06:19 <Cale> I have seen a handful of subtle cases where there was a natural Applicative structure on something, and a kind of shitty Monad structure which was present, but which didn't agree with the first Applicative structure
13:06:22 <comerijn> timCF: They're not that complex, tbh
13:06:25 <dminuoso> timCF: It's very simple, really. 
13:06:41 <dminuoso> select :: f (Either a b) -> f (a -> b) -> f b
13:07:01 <dminuoso> The type signature is just a bit odd for improved safety. Essentially `the first action can succeed or fail, if it fails the second action is taken`
13:07:36 <timCF> well sounds simple
13:10:42 <comerijn> timCF: The paper is pretty good in explaining how it relates to Applicative and Monad
13:44:16 <amf> does mempty in Monoid have a name? I'm looking for mempty without Semigroup constraint
13:44:38 <texasmynsted> What is a simple, fast, small, on-disk, data store that works well with haskell. I have been looking at leveldb, but I could not get it to work. Tokyo Cabinet, not sure how to use this.
13:45:20 <solonarv> amf: the thing you're describing has absolutely no properties it's possible to write down in general. what are you looking for?
13:45:48 * hackage proto-lens-arbitrary 0.1.2.9 - Arbitrary instances for proto-lens.  https://hackage.haskell.org/package/proto-lens-arbitrary-0.1.2.9 (JinwooLee)
13:45:57 <dmwit> ?hackage data-default-class amf
13:45:57 <lambdabot> https://hackage.haskell.org/package/data-default-class amf
13:46:37 <dmwit> sqlite?
13:46:40 <dmwit> texasmynsted: ^
13:46:49 * hackage proto-lens-protobuf-types 0.7.0.0, proto-lens-optparse 0.1.1.7 (JinwooLee): https://qbin.io/raised-omega-dslu
13:47:07 <amf> solonarv: yeah im not even sure it makes sense what i want to accomplish, going to have to re-think this
13:47:48 * hackage proto-lens 0.7.0.0, proto-lens-setup 0.4.0.4, proto-lens-runtime 0.7.0.0, proto-lens-protoc 0.7.0.0 (JinwooLee)
13:47:50 <dmwit> texasmynsted: maybe postgres if you need multiple accessors; can't recall whether sqlite supports that or not
13:47:54 <solonarv> what are you looking to do with a potential answer?
13:48:02 <texasmynsted> sqlite has a database engine if I recall correctly.
13:49:06 <texasmynsted> I just need a key value store serialized to disk, ideally atomically.
13:49:40 <solonarv> sqlite is a reasonable choice for this sort of thing; as a bonus, you can access it from other languages or a CLI just as easily
13:50:00 <solonarv> (or a more full-featured DB like postgres if you need that)
13:50:57 <dmwit> Is there some reason to believe that being/having a database engine is mutually exclusive with providing a key-value store that is atomically serialized to disk?
13:51:03 <maerwald> ixset-typed + json?
13:51:12 <dsal> texasmynsted: sqlite is generally the best choice for a file format  in any language unless you have something really specific you want to do.
13:52:16 <dmwit> (yay, three votes for sqlite! makes me feel vindicated)
13:52:18 <maerwald> @hackage ixset-typed
13:52:19 <lambdabot> https://hackage.haskell.org/package/ixset-typed
13:52:21 <dsal> The bonus of sqlite is that it's got billions of users relying on it relatively constantly.  It's hard to find more battle-tested software.
13:52:33 <maerwald> sqlite--
13:52:39 <texasmynsted> I suppose if that is the simplest, smallest option. 
13:52:48 <dsal> And most reliable.
13:52:50 <texasmynsted> I have used it before. It just seems like overkill
13:53:04 <maerwald> it isn't
13:53:19 <maerwald> (reliable)
13:53:43 <dsal> That's a super bold statement with an incredible amount of counter-evidence.
13:53:48 <dsal> https://sqlite.org/testing.html
13:54:13 <dsal> I don't know of any better tested or more broadly deployed software at all.  I don't hear about issues very frequently.
13:57:51 <dsal> https://sqlite.org/mostdeployed.html <-- they're estimating over one trillion deployments currently.  That's pretty good.  heh
14:03:51 <ezzieyguywuf> ok, I have another one: http://dpaste.com/3HEPHXC . My issue with `unBlankData` is that it naively uses Map.Map.insert, which always adds the data
14:04:22 <ezzieyguywuf> How can I implemente `unBlankData'` such that it first checks for the presence of `i` and return `Nothing` if it's not there?
14:05:04 <dsal> ezzieyguywuf: I think your type signature is incorrect.
14:05:32 <ezzieyguywuf> preferably using Map.member not Map.lookup
14:05:34 <ezzieyguywuf> dsal: which one?
14:05:42 <dsal> `unBlankData' :: Int -> Maybe (MyState ())`
14:06:22 <ezzieyguywuf> dsal: I want it to say "unBlankData' will return Nothing or Just a MyState, depending on the contents of your Int"
14:06:44 <dsal> But there's no map to lookup values in.
14:07:05 <koz_> ezzieyguywuf: Seen this? https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html#v:insertWith
14:07:50 <ezzieyguywuf> koz_: yes, but I think dsal is honing in on my issue here
14:08:36 <dsal> I don't quite understand what you're trying to do, but if you're wanting to check presence and maybe update and return a value, etc...  There are a variety of functions like `updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)`
14:08:55 <ezzieyguywuf> dsal: so It'd have to be either `unBlankData' :: Int -> MyData -> Maybe (MyState ())` or `unBlankData' :: Int -> MyState a -> Maybe (MyState ())`
14:09:32 <maerwald> dsal: it doesn't do verz well in the light of concurrent writes
14:09:47 <ezzieyguywuf> https://hackage.haskell.org/package/fgl-5.7.0.2/docs/Data-Graph-Inductive-Graph.html#v:insEdge
14:10:12 <ezzieyguywuf> I want to call insEdge (as linked) only if the Nodes are already in the Graph
14:10:14 <dsal> ezzieyguywuf: Yeah.  But I don't understand what you're trying to do, so it's hard to imagine how to do it well.
14:11:06 <ezzieyguywuf> I was trying to use Map as a simpler example - if the key does not exist, return Nothing, otherwise, proceed with the insert operation
14:11:19 <ezzieyguywuf> (and return Just the new state with the inserted value)
14:11:27 <dsal> maerwald: Maybe.  I write code around what it does well.   I end up just not making a lot of concurrent writes.
14:11:58 <dsal> ezzieyguywuf: But why return a state?  Why not just be the state?
14:12:13 <dsal> Like the one above.
14:12:24 <ezzieyguywuf> dsal: like `addBlankData`?
14:13:09 <maerwald> dsal: after one obligatory switch to postgresql...never again
14:13:21 <dsal> I'm suggesting just start with a signature that makes sense.  `unBlankData :: Int -> MyState ()`  I don't see why you can't just stay within the monad.
14:13:30 <dsal> maerwald: postgresql is a fine database, but it's not a very good file format.
14:14:01 <maerwald> yep
14:14:14 <dsal> sqlite is a *great* file format.  It works as a database.  :)
14:14:51 <ezzieyguywuf> dsal: because I want the user to specifiy _which_ data to unBlank. That's what the Int in the call signature is for.
14:15:07 <tdammers> sqlite is, arguably, not a very good database
14:15:14 <dsal> ezzieyguywuf: Yes, correct.  That's not the part I have a problem with.
14:15:48 <dsal> tdammers: It works.  I think of mostly as a great file format for storing stuff in my programs.
14:16:11 <ezzieyguywuf> hrm, perhaps I should re-write it without State and manually pass around the (a,s) tuples, to see if it makes more sense to me...
14:16:41 <dsal> ezzieyguywuf: That's an option, but the signature of the thing you're trying to replace it seems fine.  I don't understand why you'd want to change it.
14:17:24 <ezzieyguywuf> dsal: ah, you're saying `unBlankData` looks fine, why bother with `unBlankData'` at all?
14:17:48 <dsal> Well, yeah.  The signature at least looks fine.  If you want to change what it *does*, that's a different question.
14:18:05 <ezzieyguywuf> dsal: I want to change what it does
14:18:13 <dsal> Yeah, so do that with the same signature.  :)
14:18:15 <ezzieyguywuf> perhaps I should have named it "unBlankWithCheck"
14:18:29 <dsal> :t M. updateLookupWithKey
14:18:30 <lambdabot> error:
14:18:30 <lambdabot>     Data constructor not in scope: M :: b0 -> c
14:18:30 <lambdabot> error:
14:18:31 <tdammers> dsal: well, from that point of view, its SQL features are actually pretty impressive
14:18:33 <dsal> lame.
14:19:19 <ezzieyguywuf> dsal: but I want the signature for "unBlankDataWithCheck" to return "Maybe", because if it fails I want the caller to propogate te failure
14:19:32 <dsal> tdammers: Yeah, exactly.  I don't think of it as the best database out there, but people make all kinds of mistakes working with filesystems.  Those mistakes are managed much better in the sqlite API.  And you can have a bit of data separation with "tables" and sometimes you can even do a cool query.
14:20:22 <dsal> ezzieyguywuf: What does it mean to propagate failure?  How do you imagine using this thing?
14:20:36 <dsal> On one hand, there's MonadFail, but I don't think that's what you want.
14:21:12 <ezzieyguywuf> I mean that `needsToUseUnBlankDataWithCheck :: a -> Maybe b`
14:23:26 <dsal> `needsUnBlankData :: Int -> MyState Bool`  would give you the ability to do something like `needsUnBlankData x >>= \q ->  when q unBlankDataOrWhatever`
14:24:22 <wavemode> sqlite is a victim of it's own name. there's really nothing "lite" about it - it's an extremely reliable and production-ready database
14:24:58 <dsal> ezzieyguywuf: I feel like I don't understand what you're doing, because I wouldn't do it that way.  e.g., if you check and then update, you're doing two trips down the map and I don't think you need to.
14:25:12 <texasmynsted> Might try redis
14:25:15 <dsal> wavemode: IMO, the 'lite' is you don't need any additional pieces.
14:25:28 <dsal> redis is so unfortunate.
14:25:51 <wavemode> dsal: fair, but the unfortunate connotation that it's a toy remains
14:26:45 <ezzieyguywuf> perhaps this is a clearer example: http://dpaste.com/1WM94WG
14:27:31 <ezzieyguywuf> dsal: "I wouldn't do it that way" is a nice observation, how would you go about it?
14:28:07 <ezzieyguywuf> dsal: I like your suggestion regarding `needsUnBlankData`, however that still goes down the map twice.
14:28:09 <dsal> ezzieyguywuf: I don't understand why you are checking for the presence in the first place.
14:31:00 <ezzieyguywuf> dsal: well, I'm using Map in my example, but in fact I'm using Data.Graph from fgl. The insEdge function does not check whether or not the Edge is actually valid - it just crashes if it's not (with a very helpful error message)
14:31:11 <ezzieyguywuf> I'd rater avoid the crash by first checking if I can actually insert the Edge
14:31:25 <dsal> Oh.  Well, then sure, you can ask before you proceed.
14:31:55 <ezzieyguywuf> (perhaps I should submit a patch to fgl...)
14:31:57 <dsal> canProceed <- get; when canProceed doStuff
14:32:46 <ezzieyguywuf> ah hah
14:32:49 <ezzieyguywuf> I was not aware of 'when'
14:32:58 <ezzieyguywuf> I'll give this a whirl thank you.
14:33:45 <dsal> @src when
14:33:45 <lambdabot> when p s = if p then s else return ()
14:34:09 <ezzieyguywuf> handy
14:43:39 <ezzieyguywuf> dsal: here's what I ended up with, seems to work. http://dpaste.com/29HVBBY
14:43:45 <ezzieyguywuf> dsal: thanks for the help :)
14:44:50 <texasmynsted> https://github.com/verement/lmdb-simple
14:45:00 <ezzieyguywuf> hrm, but what If I want to inform the user that the unBlankData operation did not do anything?
14:46:59 <dsal> ezzieyguywuf: You don't need a do for one line of code. :)
14:47:44 <ezzieyguywuf> dsal: hah, indeed.
14:51:21 <justquark> Hello, everyone. I have some issue building my project with stack. I ran stack build and got following: C:\Users\Alexander Nekrasov\Code\GitHub\haskell-test\package.yaml: Ignoring unrecognized field $.resolver.
14:51:43 <dsal> justquark: resolver is a stack.yaml field
14:52:13 <justquark> Thanks, I'll try it now
14:54:24 <monochrom> ezzieyguywuf: Perhaps change "State ()" to "State Something" and design the Something type for this information?
14:59:13 <ezzieyguywuf> monochrom: that's a great idea
14:59:29 <ezzieyguywuf> and it was like on the tip of my fingers, but I couldn't see the tree for te forest
14:59:39 <monochrom> :)
14:59:42 <ezzieyguywuf> because, it's jsut wasted right now in that function anyway, might as well use it
14:59:45 <ezzieyguywuf> :)
15:00:42 <monochrom> This is why >>= is so complicated. Along with a lot of example monads.
15:01:26 <monochrom> For example "state" would have been simply "s->s", and you would only need function composition (.), if not for this annoying "but I also have an answer of type a".
15:02:11 <monochrom> Now that we have worked so hard to accomodate s->(s,a), may as well use that "a" for good measuree.
15:17:14 <justquark> How do you getLine Utf-8 symbols on Windows?
15:20:00 <koala_man> justquark: give chcp 65001 a go to set the cmd.exe codepage to utf-8
15:24:51 <texasmynsted> when I install a C library. How do I make cabal see the library. It seems I should not need to use --extra-include-dirs= and --extra-lib-dirs= for each project.
15:25:10 <justquark> Now it prints nothing. It printed ?????? before
15:25:28 <dsal> Yay, improvement.
15:25:36 <texasmynsted> hmm. I do see an option in ~/.cabal/config
15:58:01 <ddellacosta> so I was poking around and found this, https://github.com/ekmett/lens/issues/286 and now I'm wondering, is there any way in which lens helps with record construction? 
16:00:22 <solonarv> not a ton
16:00:38 <koz_> It's mostly a record inspection/modification thing.
16:00:48 <solonarv> in theory you can do something like: startingValue & field1 .~ foo & field2 .~ bar & ...
16:00:49 <koz_> (well, rather, it helps primarily with those things vis a vis records)
16:01:07 <solonarv> and if you set all the fields that way startingValue can even be undefined, usually
16:01:27 <ddellacosta> I guess, a lot of record instances get constructed automatically in a lot of Haskell production code, like via e.g. Aeson FromJSON and the like? Wondering how folks in production do this
16:01:46 <solonarv> but that's not particularly better than just plain old record syntax (worse, in fact, because you don't get compiler warnings if you forget a field)
16:01:51 <ddellacosta> solonarv: okay, was wondering about something like that too actually
16:01:51 <koz_> ddellacosta: It depends an awful lot on the record.
16:01:56 <monochrom> There are two cases. You have default values or you don't.
16:02:00 <ddellacosta> koz_: yeah, fair enough
16:02:18 <solonarv> oh yes if there are sensible default values then this is much less terrible
16:02:40 <monochrom> If you have default values, start with a globally available record that has the default values, use lens to modify just the few fields you need to override.
16:02:58 <ddellacosta> monochrom: gotcha, that makes a lot of sense
16:03:02 <monochrom> If you don't have default values, you expect n fields to take Theta(n) code per record.
16:03:39 <ddellacosta> right, I guess that's that
16:03:45 <ddellacosta> thanks all, this was helpful
16:05:15 <texasmynsted> hmm. I am getting all kinds of linking errors. I have not had this problem before.
16:05:44 <texasmynsted> I have tested out several different libraries and each one fails to link.
16:05:52 <texasmynsted> any ideas?
16:07:41 <texasmynsted> errors like this ---> https://gist.github.com/mmynsted/1634f4f409d4c6701d8c4163cf23fd21
16:29:30 <MarcelineVQ> from base huh, hmm...
16:30:25 <MarcelineVQ> what do your .cabal file and (if you have either) cabal.project or stack.yaml look like?
16:45:50 <texasmynsted> I have an sqlitetest.cabal file. 
16:46:50 <texasmynsted> it looks like this https://gist.github.com/mmynsted/b86c5316c8a047cf17346a9a8e73a989
16:47:07 <texasmynsted> I do not have a cabal.project or stack.yaml
16:47:40 <texasmynsted> WOW
16:47:48 <texasmynsted> It worked this time.
16:47:52 <texasmynsted> zomg
16:49:08 <texasmynsted> there was an libiconv installed via homebrew. I removed it and removed my extra lib and include directories from ~/.cabal/config. I think `cabal clean` and `cabal build`. It works now.
16:49:34 <texasmynsted> Wow I wonder if all the other packages I tried from Hackage today (that all failed) would actually work now?
16:49:36 <texasmynsted> :-)
17:53:09 <koz_> Is there a non-empty Text library which supports anything resembling a modern GHC?
18:15:20 <slack1256> What
18:15:59 <slack1256> Oh you meant a text library equivalent of the NonEmpty data type and that build on ghc 8.10 ?
18:22:13 <koz_> slack1256: Yes, this exactly.
19:26:19 * hackage cloudi 2.0.0 - Haskell CloudI API  https://hackage.haskell.org/package/cloudi-2.0.0 (okeuday)
19:48:05 <ezzieyguywuf> isn't one of foldl vs foldr supposed to be 'better' or faster or something?
19:49:10 <wavemode> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
19:52:40 <ezzieyguywuf> wavemode: thanks.
20:19:23 <adam_wespiser> i think of it has foldr is the "right" fold
20:20:02 <adam_wespiser> but I'm sure there is a counter example :)
20:21:20 <wavemode> that very wiki page presents counter examples
20:33:59 <adam_wespiser> :koz_ by non-empty, do you mean supports Text strings where length must be greater than 0?
20:34:07 <koz_> adam_wespiser: Yes.
20:34:11 <koz_> I mean that very thing.
20:35:14 <adam_wespiser> I like that idea: i'm a fan of non-empty maps, but haven't seen one for non-empty text
20:35:25 <koz_> adam_wespiser: Two exist, both are very old and crufty.
20:35:32 <koz_> I may be tempted to write one.
20:36:03 <adam_wespiser> my one comment would be to use HasCallStack where applicable, sometimes the errors in NonEmpty map can be a little annoying to track down :)
20:39:19 <Guest_34> Hey. Can someone help me with Haskell?
20:39:25 <koz_> Guest_34: What's up?
20:39:56 <Guest_34> I just downloaded it. But after starting a new terminal session and running the command "ghci" nothing happend
20:40:15 <Guest_34> I am using a mac
20:40:23 <koz_> Guest_34: What do you mean 'just downloaded it'? Did you use Homebrew? Some other thing?
20:40:57 <Guest_34> I did not use homebrew. I used this command from the haskell website: curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
20:41:20 <koz_> This gives you ghcup I believe.
20:41:34 <Guest_34> ah. So...where do I go from here?
20:41:45 <Guest_34> This happens when I type gchi: bash: ghci: command not found
20:41:47 <koz_> OK, if you type 'which ghcup', do you get anything in your terminal?
20:41:53 <koz_> Yeah, yu ain't even close to there yet lol.
20:41:59 <koz_> ghcup is what you use to set up Haskell.
20:42:06 <koz_> This command you ran set up ghcup.
20:42:25 <Guest_34> ok then. can you help me with the next step then?
20:42:38 <koz_> Type 'which ghcup' and press Enter. What do you get?
20:42:53 <Guest_34> did not do anything
20:43:05 <koz_> Meaning? Did you see nothing, get an error, soemthing else?
20:43:18 <Guest_34> no error, just a new land in the terminal
20:43:29 <koz_> OK, now try 'ghcup --version'.
20:43:39 <Guest_34> I see the .ghcup file when i type ls -a
20:44:02 <Guest_34> bash: ghcup: command not found
20:44:02 <koz_> Yeah, what happens when you do 'ghcup --version' and press enter?
20:44:07 <Guest_34> bash: ghcup: command not found
20:44:10 <koz_> OK, so it's not set up or not on your PATH.
20:44:23 <c_wraith> did you open a new terminal after installing it like the instructions said to?
20:44:29 <Guest_34> I did indeed
20:44:39 <c_wraith> did you let it add to your path when it asked?
20:45:00 <Guest_34> I did. It said type YES and press ENTER, which I did
20:46:25 <Guest_34> any suggestions?
20:46:54 <koz_> Guest_34: Well, I've not used that script, or a Mac. I'm doing the standard checks to see what's going on, but I dunno how to put stuff on your PATH in a Mac.
20:47:02 <koz_> Or where this script sends your ghcup binary.
20:47:13 <koz_> Maybe someone who uses a Mac might be able to help you, but you may have to wait.
20:47:30 <Guest_34> [ -f "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env" ] && source "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env"
20:47:40 <Guest_34> I see this in my .bashrc file
20:47:44 <c_wraith> wait, mac?  are you using bash?
20:47:57 <Guest_34> yes
20:47:58 <c_wraith> new versions of OS X default to zsh instead
20:48:11 <Guest_34> What is your suggestion then. 
20:48:20 <c_wraith> nothing, just making sure it updated the right config
20:48:42 <Guest_34> I'm not sure what to do.
20:48:52 <c_wraith> well, do you have a .ghcup/env file?
20:49:00 <Guest_34> :q
20:49:03 <Guest_34> sorry
20:49:07 <Guest_34> just a sec
20:49:36 <Guest_34> yes
20:49:40 <Guest_34> I do see that file
20:50:25 <c_wraith> if you run "source .ghcup/env" and then "which ghcup" does that change things?
20:50:41 <Guest_34> should I run that command in terminal?
20:50:50 <c_wraith> yes
20:51:19 <Guest_34> this is the result: .ghcup/bin/ghcup
20:52:02 <c_wraith> ok, that would indicate it's working now.  So the problem appears to be that the bash config file that was written into was the wrong one.
20:52:11 <c_wraith> you said it was in .bashrc ?
20:52:51 <Guest_34> this was in my .bashrc: [ -f "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env" ] && source "${GHCUP_INSTALL_BASE_PREFIX:=$HOME}/.ghcup/env"
20:53:05 <c_wraith> do you also have a .bash_profile file?
20:53:13 <Guest_34> yes
20:53:28 <c_wraith> copy that line to the end of that file, too
20:53:37 <c_wraith> that's an OS X thing
20:53:54 <Guest_34> ok. just a sec...
20:54:52 <Guest_34> ok. I added it
20:55:04 <Guest_34> it works!!!
20:55:09 <Guest_34> holy shit it works!!!
20:55:20 <Guest_34> Thank you so much!
21:29:53 <slack1256> koz_: 3 hours ago you asked for a text-like library equivalent of NonEmpty. I was distracted by life, but I had written but not sent that you could use the `newtype` library.
21:30:50 <slack1256> With it you could make a Newtype over text that semantically check it isn't empty, and only allow with the `ala` combinator functions that operate over such text value.
21:55:36 <Axman6> we wrote a text1 package, it's on github and implements basically the same interface as Text, but with appropriate Maybe's/Either's
21:58:43 <Axman6> koz_: https://github.com/tmortiboy/text1
22:04:47 * slack1256 wishes he finds people like Axman6 when in troubles
22:05:54 <iqubic> Cool. I noticed you even have some quick-check interop there.
23:09:01 <Axman6> slack1256: I'm always here for you <3
23:13:10 * slack1256 genuflexs
