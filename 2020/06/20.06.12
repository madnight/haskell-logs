00:12:17 <dmwit> :t (<*>)
00:12:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:06:21 <siraben> Is there a numeric tower package that formulates operations like +, * to mathematical structures like fields, rings, etc?
01:14:58 <EvanR> try package algebra
01:18:25 <siraben> EvanR:  Thanks.
01:35:18 * hackage haskoin-store-data 0.31.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.31.0 (jprupp)
01:37:18 * hackage haskoin-store 0.31.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.31.0 (jprupp)
01:48:43 <rsoeldner> Hi, is it possible to extend the payload size in a wai / servant application ? I'm receiving http status code 413.
01:50:05 <dminuoso> rsoeldner: I think that would be the responsibility of the wai server.
01:50:09 <dminuoso> Are you running warp?
01:51:11 <rsoeldner> dminuoso, you are right, mixed it
01:54:17 <rsoeldner> dminuoso, are you aware of any way to specifing the max size ?
01:55:29 <rsoeldner> dminuoso, warp is offering `settingsMaxTotalHeaderLength` but nothin wrt to payload as far as i can see
03:20:03 <mananamenos> hi, im reading the third answer from this thread https://stackoverflow.com/questions/12031878/what-is-the-purpose-of-rank2types and don't get what the author wanted to say. 
03:20:42 <mananamenos> according to him should't this hold? https://hastebin.com/ajoruperuc.haskell
03:40:37 <ph88> could someone tell me what this error is about ? https://bpa.st/KWWQ
03:43:30 <infinity0> the --benchmark-arguments argument is invalid, run --help to find out what the correct form is
03:45:57 <ph88> great infinity0 thanks
03:46:09 <ph88> i thought i was passing arguments directly to the program
03:46:34 <ph88> how do i pass arguments to the program ?
03:48:33 <byorgey> mananamenos: no, neither of those should compile
03:48:56 <byorgey> mananamenos: the point is that you must give f a function that works on *any* type of list
03:49:18 <byorgey> the function (\_ -> BigEnemy) specifically returns a value of type Country
03:49:24 <byorgey> so it cannot have the type  forall a. [a] -> a
03:51:01 <byorgey> mananamenos: note also that typechecking an application of a function never takes into account the definition of the function, only its type.
03:52:00 <mananamenos> byorgey, i see it now, i was silly of this that should compile :) thank you
03:52:10 <byorgey> sure =)
03:58:09 <ph88> when running a benchmark after each commit, where to store the results of the benchmark ?
04:00:22 <mananamenos> byorgey, https://hastebin.com/buwimoyozu.coffeescript So if this example, `f` does not compile because a type parameter `a` can be anything but in the implementation of function i explicitly initiate it to Country type, which is wrong. While in `f` example compiles, it's that rankNTypes stuff, which locks `a` to whatever my implentation says, which is Country in this case. Right?
04:01:46 <mananamenos> Is it true then that in rankNtypes, it is always never the caller who initiates the concrete type but the implementation details of a function?
04:05:28 <byorgey> mananamenos: yes, the key idea is who gets to choose the instantiation of a type variable.  The type of your function `f` promises that the caller will get to choose `a`, and that it will work no matter what the caller chooses, but then the implementation tries to instantiate it to Country, which is why it does not type check
04:06:04 <byorgey> but the type of f' says that the caller must give it a function which works for any choice of type `a`, so the implementation of f' gets to instantiate `a` when it calls the provided function
04:07:37 <byorgey> mananamenos: it is not accurate to say that with RankNTypes the implementation of a function always instantiates type variables, because it depends on the rank.  The caller gets to choose all type variables at odd rank, and the function implementation gets to choose all type variables at even rank.
04:08:31 <byorgey> for example  f'' :: ((forall a. [a] -> a) -> Int) -> IO ()   -- the caller gets to choose `a` again, though you might have to think for a bit to see why.
04:21:48 * hackage NaCl 0.0.3.0 - Easy-and-safe-to-use high-level Haskell bindings to NaCl  https://hackage.haskell.org/package/NaCl-0.0.3.0 (kirelagin)
04:21:52 <mananamenos> byorgey, thank you very much. Indeed I dont know anything about odd/even rank therefore i can't see why the caller gets to choose the `a` in your example. I gonna search internets for that, once i play a bit more with the basics.
04:22:46 <merijn> mananamenos: "forall a . [a] -> a" means that you must give me a function '[a] -> a' that works for, well, *all* possible values 'a'
04:22:48 * hackage crypto-sodium 0.0.3.0 - Easy-and-safe-to-use high-level cryptography based on Sodium  https://hackage.haskell.org/package/crypto-sodium-0.0.3.0 (kirelagin)
04:23:30 <merijn> mananamenos: I think this is the smallest, concrete example of when you'd need Rank2 types: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:25:05 <mananamenos> merijn, the signture "[a] -> a]" can be applied the very same sentence of your, right? "means that you must give me a function '[a] -> a' that works for, well, *all* possible values 'a'"
04:25:57 <merijn> mananamenos: if you have "foo :: forall a . [a] -> a" then foo is a function that works "for all 'a'"
04:26:33 <merijn> mananamenos: The distinction is between "bar :: forall a . (a -> a) -> Int" and "baz :: (forall a . a -> a) -> Int"
04:26:51 <merijn> mananamenos: In the former *baz* is a function that works for all possible types 'a'
04:27:03 <merijn> eh, s/baz/bar
04:27:21 <merijn> In the latter, baz is a function whose *argument* works for all possible types 'a'
04:28:51 <merijn> The distinction is bar can be used with any function, like "Int -> Int", because bar works for all 'a'. The latter it only works if you give it functions with type 'forall a . a -> a' (i.e. the argument function must be polymorphic and work forall 'a')
04:33:57 <mananamenos> merijn, thank you. Trying to digest :)
04:37:48 * hackage NaCl 0.0.3.1 - Easy-and-safe-to-use high-level Haskell bindings to NaCl  https://hackage.haskell.org/package/NaCl-0.0.3.1 (kirelagin)
04:38:48 * hackage crypto-sodium 0.0.3.1 - Easy-and-safe-to-use high-level cryptography based on Sodium  https://hackage.haskell.org/package/crypto-sodium-0.0.3.1 (kirelagin)
04:43:18 * hackage secp256k1-haskell 0.2.4 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.2.4 (jprupp)
05:28:19 * hackage rocksdb-query 0.3.2 - RocksDB database querying library for Haskell  https://hackage.haskell.org/package/rocksdb-query-0.3.2 (jprupp)
05:36:08 <maerwald> ezzieyguywuf: https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/lib/GHCup/Utils/File.hs#L186
05:36:48 * hackage json-rpc 1.0.2 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-1.0.2 (jprupp)
05:38:19 <maerwald> ezzieyguywuf: also uses https://hackage.haskell.org/package/concurrent-output
05:39:33 <maerwald> there's no such per se functionality, so needs a bit of work
05:52:20 <__monty__> Any sqlite libraries that stand out?
05:52:53 <tdammers> sqlite-simple would be the go-to one
05:54:19 <dminuoso> ^- indeed.
06:00:09 <merijn> Pretty much roll your own stuff using sqlite-simple, yeah
06:02:00 <maerwald> ORM is dead
06:03:13 <Cheery> has been for a while.
06:04:18 * hackage nqe 0.6.2 - Concurrency library in the style of Erlang/OTP  https://hackage.haskell.org/package/nqe-0.6.2 (jprupp)
06:04:29 <wavemode> the idea of ORM-because-I-don't-like-writing-SQL is mostly dead. still, an ORM is great if you need to persist the same data to various storage backends. not that many apps have such a requirement though
06:05:03 <maerwald> it's for managers trying to code
06:05:17 <dminuoso> wavemode: Honestly, the act of writing a thin compatibility layer to support different databases is not hard.
06:06:02 <Cheery> I'd just like a proper common language for querying databases.
06:06:08 <dminuoso> That's SQL. :)
06:06:21 <Cheery> and for describing tables
06:07:04 <maerwald> you can only optimise for one
06:09:17 <phadej> the same as "multi-cloud" applications nowadays
06:09:59 <phadej> paying for all disadvantages of all providers, and not taking advantages of anyone
06:10:18 * hackage rfc1751 0.1.3 - RFC-1751 library for Haskell  https://hackage.haskell.org/package/rfc1751-0.1.3 (jprupp)
06:10:20 <tdammers> 'lightweight' ORM, as in 'map objects to parameter sets, and result sets to collections of objects', is a perfectly fine idea, and it's not dead at all
06:10:22 <wavemode> worst-of-all-worlds :)
06:10:50 <merijn> I just want a nice DSL for integrating SQL into my haskell code with types >.>
06:11:02 <merijn> Like, just dumb column types
06:11:05 <dminuoso> tdammers: Well I do know of some ORMs that internally build up a relational algebra nodes, reorder that tree with knowledge of the database adapter used..
06:11:08 <tdammers> 'heavyweight' ORM, as in 'create a layer between the application code and a relational database that allows the programmer to manipulate database records as if they were plain objects' however is a lousy idea
06:11:26 <dminuoso> But they quickly get into the way, and you very rapidly break out into SQL for non-trivial queries.
06:11:41 <tdammers> SQL is a pretty damn decent DSL for writing relational queries
06:11:49 <merijn> Also, I suppose composing queries would be nice
06:11:51 <dminuoso> It's just incredibly verbose, sadly.
06:12:08 <phadej> is it really
06:12:11 <tdammers> yes, but it has the unbeatable advantage of existing and being standard knowledge
06:12:17 <merijn> phadej: For complicate stuff...kinda
06:12:20 <maerwald> tdammers: I think the main problem is that it doesn't scale (ORM)
06:12:20 <phadej> it's not compositional
06:12:22 <phadej> that's different
06:12:32 <tdammers> maerwald: the main problem is that it's a leaky abstraction
06:12:37 <tdammers> it's not honest
06:12:58 <AWizzArd> I am trying to access AWS's SES (Simple Email Service) via the package `smtp-mail`. Does smtp-mail support TLS communication?
06:13:55 <phadej> AWizzArd: based on its dependencies, no.
06:14:00 <AWizzArd> I saw that smtp-mail has a dependency on the `connection` package which does seem to support TLS.
06:14:34 <maerwald> AWizzArd: https://hackage.haskell.org/package/amazonka-ses
06:14:50 <phadej> oh, then it might
06:15:11 <AWizzArd> However, in the source code of smtp-mail a `Nothing` is passed in, hardcoded, which sets the config parameter `connectionUseSecure`. So this looks as if unencrypted mails are complected into the code.
06:15:27 <maerwald> https://hackage.haskell.org/package/amazonka-ses-1.6.1/docs/Network-AWS-SES-SendEmail.html#v:sendEmail
06:15:34 <maerwald> looks ok
06:15:43 <dminuoso> AWizzArd: Or just use HaskellNet :)
06:16:04 <AWizzArd> maerwald: yeah okay, I could try that, tho I first thought I would be simply using smtp.
06:16:33 <maerwald> one does not simply use smtp
06:16:37 <ezzieyguywuf> thanks maerwald !!! 
06:16:43 <AWizzArd> dminuoso: I only skimmed HaskellNet and didn't find an example of how to do TLS. Have you ever tried it and can confirm that it works with SES?
06:16:48 <AWizzArd> maerwald: hah (-:
06:17:10 <AWizzArd> maerwald: reminds me of Boromir
06:17:35 <dminuoso> AWizzArd: Yes.
06:17:38 <maerwald> ;)
06:17:41 <dminuoso> AWizzArd: We use it in fact. :)
06:17:51 <dminuoso> It's how our haskell applications fling mail around.
06:17:55 <AWizzArd> dminuoso: ah okay, that’s good evidence then that this might work.
06:18:33 <dminuoso> AWizzArd: https://hackage.haskell.org/package/HaskellNet-SSL
06:19:32 <maerwald> dminuoso: that uses haskell tls, which is questionable
06:19:37 <AWizzArd> Ah okay, I just wanted to ask you if `doSMTP` is my friend, but that SSL package has an explicit `doSMTPSSL` function. Good.
06:20:49 * hackage prettyprinter-graphviz 1.0.0.2 - A prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-1.0.0.2 (GeorgeThomas)
06:22:28 <AWizzArd> maerwald: Do you have security concerns about the Haskell TLS implementation?
06:26:16 <dminuoso> AWizzArd: Well I dont think it has ever received much attention by crypto experts. 
06:26:49 <AWizzArd> maerwald: The TLS lib advertises the fact that it is a high-level implementation and uses an advanced type system to eliminate a common set of security issues.
06:27:38 <AWizzArd> dminuoso: The TLS package is using cryptonite under the hood. Do you have any knowledge about cryptonite having been reviewed?
06:30:53 <Cale> Cryptonite is a nice library, but I would really hesitate to use it in any situation where e.g. side-channel attacks might be a threat. It's not nearly as battle-tested as stuff like OpenSSL. It's not like the Haskell bindings to OpenSSL have been highly battle-tested either, but at least there's a better chance that they're not going to leak secrets.
06:31:26 <dminuoso> AWizzArd: If you dig a bit into crypto papers, you quickly notice there's a common theme about side channel attacks.
06:31:37 <maerwald> AWizzArd: type system is largely irrelevant to crypto security concerns
06:31:41 <dminuoso> Timing attacks and caching attacks are very common, and they are easily introduced with naive implementations of even the simplest of things.
06:33:28 <maerwald> haskell type system is not even expressive enough to carry protocol proofs
06:33:30 <merijn> Cale: tbh, if you're worried about side channel attacks I wouldn't use OpenSSL or even Intel either :p
06:33:37 <Cale> Yeah
06:33:43 <merijn> Really
06:34:09 <merijn> My main recommendation if you worried about side channel attacks is to rework your system until you're no longer worried about them :p
06:35:07 <Cale> Yeah, the main way to eliminate side channel attacks is to make sure the attackers don't get access to the side channel in the first place.
06:35:22 <maerwald> Cale: problem with openssl bindings is the undocumented exceptions
06:35:30 <dminuoso> Cale: The main purpose for which TLS was invented however, is to ensure the privacy of communications over unsafe channels.
06:35:38 <maerwald> hard to get it right
06:35:45 <dminuoso> Given how all the intelligence agencies are freely extracting data from IXes...
06:35:55 <dminuoso> It's become a realistic threat to everyone
06:37:40 <maerwald> crypto discussion turned political :p
06:38:00 <dminuoso> But ultimately, most tls is just a convenience issue. If you just have preshared keys, you can go AES and have a lot of profit.
06:40:28 <maerwald> sad, we don't have bindings for mbedtls
06:40:34 <wavemode> that's for the somewhat niche case where both systems are fully trusted. usually, one of the two is a user's computer
06:42:13 <dminuoso> I'd say that even in tls you assume full trust.
06:42:42 <dminuoso> Why worry about a side-channel attack when the host you are talking to itself is malicious.
06:42:46 <tdammers> tls is about deriving trust, mostly
06:43:09 <tdammers> you trust the root CA's, and derive trust in a server from that
06:43:18 <dminuoso> If you cant trust the remote host, you are hosed anyway.
06:43:29 <tdammers> let me rephrase that
06:43:36 <tdammers> you derive trust in the server identity from that
06:43:54 <tdammers> but of course knowing who you are doesn't guarantee that you won't stab me in the face anyway
06:43:58 <tdammers> just that you are you
06:44:02 <dminuoso> Right.
06:44:21 <dminuoso> And Im saying that it's not just niche where both systems are fully trusted, because you generally assume trust on both machines.
06:44:33 <tdammers> not full trust though
06:44:48 <dminuoso> well you fully trust the remote host with your data.. :)
06:44:59 <maerwald> Getting shot after exchanging numbers
06:45:13 <dminuoso> Unless of course you encrypt your payload yourself, and the remote host isnt processing that payload.
06:45:31 <tdammers> which is actually a very common scenario
06:45:41 <dminuoso> Is it?
06:45:42 <tdammers> ("log in with facebook/google/github/...")
06:45:49 * hackage list-tuple 0.1.3.0 - List-like operations for tuples  https://hackage.haskell.org/package/list-tuple-0.1.3.0 (kakkun61)
06:46:01 <dminuoso> That's delegated authorization, a different subject.
06:46:20 <tdammers> it usually involves forwarding trust through an untrusted machine though
06:46:48 * hackage murmur3 1.0.4 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm.  https://hackage.haskell.org/package/murmur3-1.0.4 (jprupp)
06:46:50 <dminuoso> We are digressing.. :)
06:46:59 <tdammers> I agree on this much
06:47:36 <tdammers> oh, and re side channel attacks: the crux with those is of course that people often don't worry about them even though they should
06:47:49 <merijn> I recommend you read up James Mickens "threat classification model" ;p
06:48:52 <Uniaika> merijn: Mossad or ¬Mossad are the only true constants of the universe
06:48:58 <merijn> See table on page 9: https://www.usenix.org/system/files/1401_08-12_mickens.pdf
06:49:00 <merijn> Uniaika: :)
06:49:10 <dminuoso> tdammers: We operate an ISP, and knowing that plenty federal agencies have essentially unbounded and intransparent access to all our customers internet traffic and mail.. (not just by secretly tapping fiber optics, by law we have to give them full access)...
06:49:23 <merijn> James Mickens is the researcher I aspire to be :p
06:49:28 <Cale> Uniaika: You're saying it's possible to decide if someone is Mossad?
06:49:32 <dminuoso> That's Germany for you.
06:49:46 <tdammers> hmhm
06:50:12 <tdammers> you can't give them full access to the plaintext of your users' HTTPS traffic though, unless you actively MITM them somehow
06:50:24 <dminuoso> We have to give them full access to unecrypted mail. ;)
06:50:32 <dminuoso> Isn't that a fun story?
06:50:41 <dminuoso> Best of all, we are unable to (and forbidden as well) even know when the government taps you. Nobody does. 
06:50:48 <dminuoso> There's literally no oversight.
06:50:53 <merijn> Cale: No, but the great thing is that if the mossad's after you your ability to do so is irrelevant anyway ;)
06:51:17 <mananamenos> byorgey, merijn I can't find any source about even, odd ranks. I still don't understand why in the example of byorgey:  f'' :: ((forall a. [a] -> a) -> Int) -> IO ()   -- the caller gets to choose `a` again, though you might have to think for a bit to see why
06:51:30 <mananamenos> could you point me to any good source about this?
06:51:35 <dminuoso> mananamenos: It's the same rationale with higher order functions.
06:52:20 <dminuoso> mananamenos: `f :: Int` - implementor supplies Int. `f :: Int -> Bool` - consumer supplies Int. `f :: (Int -> Bool) -> Bool` - implementor supplies Int.
06:52:33 <dminuoso> `f :: ((Int -> Bool) -> Bool) -> Bool` - consumer supplies Int
06:52:44 <maerwald> merijn: heh, I read that a few years back. The only two good attack surface models are: IO automaton and economical cost of developing zero-days
06:53:06 <merijn> maerwald: He has a bunch of (equally amazing) essays
06:54:06 <wavemode> mananamenos: ertes wrote here about rankNtypes in terms of promises and demands, which I think is a nice intuition: https://ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html
06:55:34 <dminuoso> mananamenos: There's a really cool perspective from thinking of polymorphic things, which is you can think of them as terms binding types (where as functions are terms binding terms), and from that it nicely compares to higher order functions.
06:56:05 <maerwald> wavemode: that makes me sad, reading his old blogs
06:57:16 <Uniaika> < Cale> Uniaika: You're saying it's possible to decide if someone is Mossad? // Yes, but only after the fact that they hold a press conference about your death, saying "it wasn't us", while wearing t-shirts reading "it was totally us"
07:00:25 <Cale> haha
07:02:56 <gentauro> 15:46  * hackage murmur3 1.0.4 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm
07:03:02 <gentauro> why use a strict bytestring?
07:03:03 <gentauro> :|
07:03:24 <merijn> gentauro: Why not?
07:03:25 <Uniaika> is that an issue?
07:03:42 <merijn> You're going to traverse the entire thing while hashing it anyway
07:04:13 <merijn> Cale: He's just cribbing the good bits from James Mickens ;)
07:04:46 <gentauro> merijn: I would rather go for a lazy bytestring
07:05:14 <Uniaika> gentauro: I'm interested in the why :)
07:05:33 <Uniaika> Cale: oh yeah, go read his papers, they extremely hilarious
07:06:59 <gentauro> Uniaika: for a low memory-footprint :)
07:07:16 <gentauro> I recall implementing murmur3 in F# or was it Elm
07:07:59 <wavemode> a lazy bytestring should consume more memory in this case, not less. how would it use less?
07:10:56 <gentauro> wavemode: I can read my own code anymore xD
07:11:12 <gentauro> I mihgt have to use more time to come with a valid answer
07:11:35 * gentauro short value names? I guess it will remember ... did no one EVER
07:11:37 <gentauro> xD
07:11:52 <gentauro> s/I guess it will/I guess I will/
07:17:45 <Uniaika> gentauro: yeah I'm a bit skeptical about this statement of yours :P reasonable datastructures that you eventually evaluate should be lazy by default
07:18:29 <mananamenos> wavemode, the article is really great, thanks
07:19:08 <gentauro> Uniaika: most of these datastructures can be used lazy but working on `chunks` of bytes recursively
07:19:22 <gentauro> but the hole structure shouldn't be strict by default
07:19:29 * gentauro I think that's my point
07:19:47 <dolio> 'I'm going to eventually look at all 30GB, so it might as well all be in memory the whole time.'
07:19:47 <Uniaika> eeh
07:19:53 <Uniaika> I hear your point
07:19:57 <Uniaika> but I'm not convinced
07:20:15 <Uniaika> dolio: I said "reasonable" but I should have written "reasonably-sized"
07:20:23 <Uniaika> of course, context is everything
07:26:35 <merijn> gentauro: Then I'd say you want a strict interface using something like conduit for explicit chunking anyway :)
07:29:04 <gentauro> dolio: I have 64 GB RAM on my laptop
07:29:27 <gentauro> 23 GB RAM space-leak from `taffybar` didn't seem so bad
07:29:33 <gentauro> I kept it alive for 2 weeks
07:29:35 <tdammers> D:
07:29:37 <gentauro> just because I could
07:29:38 <gentauro> xD
07:29:53 <dolio> Wow, I need to upgrade. I only have 32.
07:30:23 <gentauro> dolio: it's very rare that I use the full 64 GB
07:30:37 <gentauro> but Haskell is one of the tools that put that to the test everytime 
07:30:42 <gentauro> ;)
07:31:33 <gentauro> I was just explaining how: `chunksOf _ [] = []; chunksOf n xs = y : (chunksOf n ys) where (y,ys) = splitAt n xs` might `hide` a space-leak
07:31:49 <gentauro> while: `cof n xs = take n xs : cof n (drop n xs)` doesn't
07:31:50 <gentauro> :|
07:33:31 <dolio> The second one introduces one.
07:33:59 <dolio> Potentially.
08:22:49 <typetetris> If I introduce a flag in a cabal file, does Capitalization translate to the cli? So is it -f-Optimized for  `Flag Optimized`?
08:42:11 <bifunc2> How well do you guys know Sequences when used as queues?
08:42:12 <bifunc2> Here is the issue: Processing certain items (ByteStrings) one by one is giving me substantially better performance than accumulating them first in chunks in a Sequence and processing the chunks.
08:42:34 <bifunc2> Can you think of reasons such accumulation into a Seq and then "flushing" could result in a big overhead?
08:43:07 <bifunc2> It ought to be O(1) on both ends, but i wonder if the constant is still quite slow in Seq
08:43:31 <wavemode> sequences have good asymptotics to be used as a queue, but constants sometimes matter more than asymptotics
08:46:15 <wavemode> have you looked at Data.ByteString.Builder ? it sounds like the same as what you're trying to do with Seq
08:47:27 <bifunc2> wavemode well my bytestrings are not of fixed lengths, so i guess i'd need a magic separator value to use builder
08:48:59 <dolio> I haven't measured it myself, but I'm told Seq has bad constant factors.
08:49:15 <dolio> I don't know how bad, though.
08:49:17 <bifunc2> the word is spreading :)
08:50:37 <dolio> That is the general problem with it. It has good asymptotic behavior for a lot of stuff, but its constant factors are worse than a more targeted data structure.
08:51:31 <dolio> Like, if you just want a queue, you can probably beat Seq with some kind of two-list structure, I would guess.
08:51:32 <wavemode> bifunc2, not of fixed length as in they're lazy? can't builder be used anyway?
08:53:39 <wavemode> dolio, yeah, in fact the package `dequeue` on hackage does just that
09:01:26 <typetetris> polysemy promised it would be a zero cost abstraction with ghc 8.10 did that really work out?
09:04:12 <wavemode> yes, with a compiler plugin (read iso's last comment): https://github.com/polysemy-research/polysemy/issues/184
09:09:26 <AWizzArd> Is there a number type for Naturals without the zero?
09:39:09 <dmwit> I don't think there's a pre-rolled one. But your question reminded me of this gross observation I made a little while back: (N, \x y -> x+y-a, a) is a monoid for any a.
09:40:36 <bifunc2> wavemode, not fixed length in the sense that the processor of the chunk needs to get a hold of the bytestrings separately again
09:40:52 <bifunc2> i suppose i could maintain a separate "lengths" structure
09:41:30 <dmwit> At this point maybe you'd better just say what you're doing. Perhaps by posting a link to some code.
09:45:00 <wavemode> bifunc2, then I guess I'm not understanding your use case. why do they need to be merged/batched if they're just going to be separated out again?
09:45:31 <dmwit> See? wavemode agrees with me
09:59:54 <__monty__> It looks like I can't create queries using parameter substitution in sqlite-simple, because it will pass it on to sqlite which will escape the value? `"CREATE TABLE ?"` for example.
10:01:23 <wavemode> I don't understand the question
10:08:49 * hackage homotuple 0.1.2.0 - Homotuple, all whose elements are the same type  https://hackage.haskell.org/package/homotuple-0.1.2.0 (kakkun61)
10:10:18 <wavemode> that package look funny, for a few reasons
10:23:50 <Cale> __monty__: What problem are you having with that?
10:24:18 <Cale> __monty__: I've only really used postgresql-simple a bunch, but they handle parameter substitution pretty similarly from what I understand
10:31:52 <__monty__> Cale: Not really a problem. Just really not familiar with how this is supposed to work. I ended up writing a function that just mappends my "table(field1, field2)" string into a 'CREATE TABLE' query.
10:36:42 <Cale> Ah, I see, for CREATE TABLE, I suppose it's a little weird
10:37:49 * hackage homotuple 0.1.2.1 - Homotuple, all whose elements are the same type  https://hackage.haskell.org/package/homotuple-0.1.2.1 (kakkun61)
10:42:34 <__monty__> I think I assumed it was a library feature for reusable queries but it's actually a sqlite feature only to be used for values, not table/column names?
10:43:26 <Cale> Yeah, at first I was thinking there probably ought to be some way to use this SQLData type for that, but it seems perhaps not. That's a little different from how things look over in postgresql-simple
10:44:13 <Cale> (i.e. you could make your own type for describing the structure of new tables to be created and then a ToField instance that explains how to replace a ? with it
10:44:25 <Cale>  -- but that seems unlikely given the implementation)
10:53:22 <__monty__> Ok, thanks for checking.
10:54:40 <Shiranai> Hello, can someone explain me this syntas? What does that record syntax mean for the newtype construction ` newtype State s a = State { runState :: s -> (a,s) } `
10:57:26 <dsal> Shiranai: Which part is confusing  It's a type that has two type parameters that has a single member that's a function from one of those types to a tuple of the same type and another type.
10:57:46 <dsal> I meant to put a question mark after 'confusing'
10:58:20 <Shiranai> The previous examples I had seen had a member for each type parameter
10:58:35 <Shiranai> but now that you mention "members" I think I get what you mean
11:05:07 <infinity0> with the profiler, what's the difference between -hT (break down by heap closure type) and -hy (break down by type) ?
11:13:01 <nooooop_1> hello
11:13:42 <nooooop_1> Anybody have a good resource for learning Haskell that doesn't stop at hello world? 
11:14:06 <maerwald> @cis194
11:14:06 <lambdabot> Unknown command, try @list
11:14:24 <maerwald> @where cis194
11:14:24 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
11:14:52 <Shiranai> nooooop_1: I am about to finish http://learnyouahaskell.com/chapters and it was pretty good
11:16:19 <Shiranai> what's up with the liftA_ and liftM_ functions? why are they called "lift"? Some cat theory I gues?
11:16:45 <nooooop_1> Shiranai, I'm a c# programmer, and have been for 7 ish years. Will that help?
11:17:12 <Shiranai> yes
11:17:47 <nooooop_1> will learnyouahaskell get me up to production level competency? 
11:17:48 <Shiranai> It makes some parallels to imperative programming in general, but other than knowledge of basic structures (binary trees, stacks, etc) it doesn't really assume anything
11:18:47 <Shiranai> Theoretically yes I guess, though it touches more on haskell as a language rather than haskell tools like cabal or stack
11:18:55 <jumper149> Is there such a thing as deleting a TVar or MVar or is it garbage collected, when all pointers are out of scope?
11:19:16 <nooooop_1> I've seen many parallels drawn between C# interfaces and Haskell Typeclasses. Care to help unwind that?
11:19:18 <nooooop_1> lol
11:20:44 <Shiranai> dunno about C# interfaces but haskell typeclasses are very different from 'classes' in other languages. Basically you can consider them like 'adittional restrictions' on some data type. E.g. floats, ints, Integers, and other pertain to the Num typeclass.
11:21:19 <Shiranai> but strings are not inside the Num typeclass
11:21:52 <Shiranai> just read learnyouahaskell fam, it's really good imo
11:23:03 <nooooop_1> I will!
11:23:18 <nooooop_1> I actually messed around with it a few years ago and never finished it
11:24:01 <nooooop_1> So what is a TypeClass exactly?
11:25:23 <Shiranai> My best try for a one liner is: the types of your types
11:25:51 <Shiranai> As I said, the type `Float` is part of the Typeclass `Num`
11:26:00 <Shiranai> though it is also part of the typeclass `Show`
11:26:15 <Shiranai> (`Show` basically means that it can be converted to string)
11:26:25 <Shiranai> so basically one type can be in many typeclasses
11:27:13 <nooooop_1> I see
11:27:29 <nooooop_1> But it isn't inheritance. It is composition  
11:27:41 <nooooop_1> correct?
11:27:52 <dolio> It's neither.
11:28:06 <nooooop_1> ohh
11:29:59 <Shiranai> maybe inheritance-ish in a not so strict way? because it inherits some properties (e.g. being able to be outputted to the screen); though ofc the implementation of how to do this does not come from the typeclass definition
11:31:49 <nooooop_1> Let's see if I can understand 
11:32:38 <nooooop_1> A type is a category that an expression fits into.
11:32:40 <maerwald> nooooop_1: lyah is not recommended, since it has no exercises
11:32:47 <wavemode> one big problem with treating typeclasses like interfaces is that typeclasses are erased at runtime. so yes, we have a typeclass `Show a` which means `a` can be converted to a string. but no, you can'
11:32:55 <wavemode> can't have a variable of type Show a and show it
11:33:12 <dolio> Not everyone needs books with exercises.
11:33:19 * hackage clash-prelude 1.2.2 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.2.2 (QBayLogic)
11:33:36 <nooooop_1> A type is a category that an expression fits into.
11:34:19 * hackage clash-ghc 1.2.2, clash-lib 1.2.2 (QBayLogic): https://qbin.io/images-ia-6lep
11:34:24 <jumper149> Maybe like this: Typeclasses give restrictions to polymorphic functions (the methods of the typeclass)
11:34:47 <jumper149> nooooop_1: Usually when people speak of a category in Haskell it's the category of types often called Hask.
11:36:13 <wavemode> a type is a set of values. some types have infinitely many possible values. some types have no values except bottom. some types have no values at all
11:38:26 <nooooop_1> I'm just going through learn you a haskell "If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes"
11:38:46 <nooooop_1> "You can think of them kind of as Java interfaces, only better."
11:39:12 <jumper149> nooooop_1: That sounds about right, but also doesn't explain a lot
11:39:46 <nooooop_1> It doesn't give you why it's better than Java interfaces, but it does build some intuition around it
11:40:34 <dolio> Does the book only contain two sentences about type classes?
11:40:41 <justsomeguy> I think of type classes like a collection of overloaded functions, called class methods. Each class method has a seperate implementation for the type that supports that type class.
11:41:15 * justsomeguy got really frustrated with people telling him about java interfaces, since he's never touched java.
11:41:20 <dolio> It might become clear in what sense they're better after the whole chapter or something.
11:41:41 <nooooop_1> I'm still going through it now, :)
11:42:51 <hyperisco> I don't think they're better than Java interfaces… they're different
11:43:20 <justsomeguy> Damnit, I'm going to have to look up what the a java interface is, aren't I.
11:43:38 <dolio> Yes, they are like overloading, but more sensible.
11:43:58 <wavemode> there are things you can do with java interfaces which you can't do with typeclasses, and also vice versa
11:44:32 <dolio> They are essentially what you would come up with to talk about overloading properly in a type system.
11:44:36 <nooooop_1> I'm not sure about Java, but I do know about C# interfaces
11:44:50 <wavemode> same concept
11:44:51 <hyperisco> justsomeguy, Java has subtyping, and an interface is a type
11:45:08 <ja> and they have implementations too now, iirc
11:45:19 * hackage ghc-clippy-plugin 0.0.0.1 - Override GHC error messages to the user's liking  https://hackage.haskell.org/package/ghc-clippy-plugin-0.0.0.1 (arturgajowy)
11:45:32 <ja> maybe a closer comparison could be made to c++ concepts
11:45:46 <ja> but nobody knows those yet, i guess
11:46:12 <ja> maybe the best comparison could be made... to a burrito ;)
11:46:16 <dolio> Are they actually part of C++ yet?
11:46:30 <ja> i believe so, and they are in gcc too
11:47:03 <ja> https://en.wikipedia.org/wiki/C%2B%2B20 says it was finalized in february 2020
11:47:05 <justsomeguy> I think equating type classes to the features of other languages is silly.
11:47:26 <ja> yeah, i prefer food analogies too
11:47:41 <justsomeguy> lol
11:48:26 <dolio> Concepts are probably a good analogy, because they are essentially C++ borrowing type classes.
11:48:37 <dolio> At least, last I heard about them.
11:50:38 <wavemode> yeah concepts are like typeclasses where, instead of "this type T needs to implement these methods" it's a much more flexible system of "this given code must compile for the type T". the given code can be anything (array access, addition, dereferencing ... anything)
11:51:24 <nooooop_1> My brain hurts lol
11:52:09 <ja> but if concepts do not specify explicitly all the requirements, it sounds an awful lot like templates. and the error message you get when using it would leak the internal details
11:52:25 <ja> surely it must be more explicit in some way
11:52:25 <jumper149> nooooop_1: Honestly, try sticking to your book first. Try out the examples given there. It's 20 times easier than trying to understand all the explanations given here.
11:52:27 <wavemode> like, any pointer or array can naturally be indexed via v[i] syntax. but a class can also overload that syntax itself. you can have a concept which applies to both 
11:52:50 <wavemode> ja: well, the point is that now you will get a much more helpful message: "concept CT failed because...."
11:57:14 <dolio> wavemode: So, is it more like each (template) function that uses overloading is a different concept, but there are just a few things that can be overloaded (the usual C++ stuff)?
11:57:37 <dolio> Rather than categorizing each overloaded operation as part of a class.
11:58:59 <dolio> I guess any ordinary function name can be overloaded, though, so that's a lot of things.
12:00:21 <wavemode> concepts are simply a way to add a constraint to a template definition, so that if the user uses a type which doesn't work for that template...
12:00:32 <wavemode> A. they will receive an error early on in the template instantiation process, which is faster
12:00:40 <wavemode> and B. they w3ill get a more helpful error message
12:00:48 * hackage xmobar 0.34 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.34 (JoseAntonioOrtegaRuiz)
12:01:00 <nooooop_1> I'm reading this, https://www.parsonsmatt.org/2017/01/07/how_do_type_classes_differ_from_interfaces.html
12:05:38 <nooooop_1> Hummm
12:06:12 <nooooop_1> "Note that the type signature requires that both parameters to compare have the same type! It is illegal to write compare Smol 10. The Java version allows any two objects to be passed, provided they implement the Ord interface." This seems key
12:06:56 <Cale> yeah, that's pretty crucial
12:08:47 <nooooop_1> How long until your chat is closed for inactivity? 
12:09:38 <wavemode> I don't think it does that
12:09:45 <shapr> Cale has been here for YEARS!
12:12:02 <maerwald> internet age
12:12:04 <nooooop_1> I just saw it on the chat
12:12:19 <nooooop_1> lizzard was the username 
12:13:19 <Cale> That was probably either a broken IRC client, or a message that guy's IRC client put in.
12:13:22 <nooooop_1> Does anyone here know C# and Haskell? 
12:13:43 <Cale> I wouldn't say I really know C# well, but what's your real question? :)
12:14:26 <nooooop_1> I'm trying to find a specific example where C# outright fails to support something like typeclasses, or makes it very hard
12:14:55 <Cale> C# doesn't support type classes
12:15:17 <nooooop_1> lol
12:15:57 <nooooop_1> Can you write psudo C# code that would demonstrate how it would look if it could?
12:16:02 <Cale> Unless someone added them pretty recently?
12:16:26 <nooooop_1> pseudo * 
12:16:42 <maerwald> https://github.com/dotnet/csharplang/issues/110
12:16:53 <Cale> also https://github.com/dotnet/csharplang/issues/164
12:18:00 <nooooop_1> Thanks!
12:25:27 <Shiranai> The word 'funcional' is used to describe haskell in two different ways:
12:25:38 <Shiranai> 1. as funcional vs imperativve
12:25:46 <Shiranai> 2. as functional vs side effect-y
12:26:00 <Shiranai> do these have a specific name?
12:26:08 <wavemode> 2. is pure vs. effectful
12:26:19 <Shiranai> ohhh
12:26:23 <Shiranai> thanks
12:26:45 <Cheery> functional, aka. abstractions somewhat work.
12:26:56 <nooooop_1> How many people here are writing Haskell in production? 
12:27:02 <Shiranai> As for my second question, I get why pure is good, but why is functional good? Compared to some other language with HOFs like javascript
12:27:15 <shapr> Shiranai: equational reasoning
12:27:23 <Shiranai> all the perks like modularity and compositionality follow from HOFs
12:27:27 <electricityZZZZ> shiranai: mutable state is hard to understand and debug
12:27:29 <shapr> wait, uh
12:27:30 * shapr thinks
12:27:39 <shapr> nooooop_1: I get paid to write Haskell
12:27:49 <nooooop_1> That's cool!
12:28:00 <nooooop_1> What domain? 
12:28:07 <shapr> big webapps
12:28:10 <Shiranai> electricityZZZZ: but I could use a state monad in javascript, while keepin the classical imperative programming style
12:28:27 <electricityZZZZ> right, so idiomaticity is part of programming languages
12:28:44 <electricityZZZZ> you could also write a C program which includes all of GHC and then write your code in haskell
12:29:15 <shapr> if by functional you mean "has first class functions" then I'd say the benefit is greater modularity.
12:29:28 <electricityZZZZ> i still regard myself as an amateur programmer, but imo any single approach to programming which is held too tightly ends up becoming wrong or unnatural for a given problem
12:29:35 <shapr> There's an old term for highly advanced C programmers "three star programmers"
12:29:42 <Shiranai> lol I guess that's true but I'd argue that monads in js would be more natural for the average programmer (*I have no evidence for this)
12:30:05 <shapr> It's about how many levels of indirection you have for your pointers.
12:30:19 <dolio> What would your argument be, since you have no evidence?
12:30:28 <shapr> To me, using fmap is very much like multi-star C code, but with extra safety I couldn't get from C.
12:30:33 <electricityZZZZ> shiranai: if you are doing a lot of work with mutable state, you might want to consider looking at rust
12:30:40 <maerwald> Shiranai: the rust doc says: shared global mutable state is the problem. You can fix it by removing the state part or the shared part.
12:30:56 <EvanR> the triple fmap haskeller
12:31:00 <EvanR> :t fmap fmap fmap
12:31:01 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
12:31:32 <maerwald> So it doesn't matter whether you do functional or imperative
12:31:38 <shapr> Shiranai: yeah, I want to hear why you think monads are natural in javascript
12:31:41 <Shiranai> dolio: imperative seems more natural than functional, that's why things like do notation exist. I'd argue that doing mooost things imperatively is easier to do, and think about
12:31:57 <maerwald> Shiranai: true
12:32:00 <shapr> I disagree
12:32:12 <shapr> I think imperative is what you know, not what's natural.
12:32:14 <Shiranai> js was just some random example btw, nothing in particular about it other than there being HOFs
12:32:17 <wavemode> depends on what you're doing
12:32:28 <Cheery> EvanR: the joke is, that type tells what it's doing.
12:32:41 <EvanR> most things funtional are easier for me now
12:32:57 <shapr> I've talked to at least one programmers who learned Haskell before they learned imperative programming, and the shift was equally weird to them.
12:32:58 <dolio> I also don't really understand how exactly #1 and #2 are different.
12:33:10 <maerwald> but functional is just cleaner to reason about denotationally
12:33:14 <Shiranai> shapr: yeah I think that may have a lot of things to do with what feels more natural but still, do notation and 10 `<-` is much easier than composing 10 `<=<` imo
12:33:36 <maerwald> it really sucks in imperative
12:33:44 <shapr> huh, I love using left fish
12:34:04 <EvanR> if you like unix pipes then you'll lose fish operators
12:34:06 <shapr> Shiranai: I'm not convinced programming is natural, at all, any.
12:34:07 <Shiranai> imo `do`, is not just syntatic sugar, it's some mental shift that puts you in imperative mode
12:34:07 <EvanR> love*
12:34:45 <shapr> Shiranai: but I am sure I don't know everything, and these sorts of discussions get me thinking in new directions :-)
12:34:57 <EvanR> nested >>= with lambdas definitely feels imperativey too. Luckily it's the same thing as do
12:35:12 <electricityZZZZ> i guess an interesting question here for haskellers could be, how to recognize when functional vs imperative style is most appropriate?
12:35:19 <Shiranai> shapr: yeah always fun to talk about new stuff I don't really know
12:35:31 <EvanR> electricityZZZZ: lots of examples and experience
12:35:36 <nooooop_1> lol
12:35:52 <maerwald> electricityZZZZ: algorithms -> imperative
12:35:56 <shapr> Shiranai: I got into Haskell because it promised a new way of thinking. It delivered! So did logic programming and stack based languages.
12:36:01 <koz_> maerwald: Yes, unfortunately.
12:36:13 <koz_> It's such a convention in that community, nobody even questions it.
12:36:17 <koz_> Ditto in teaching.
12:36:18 <Shiranai> I do think that at least sooome stuff is really naturally algorithmic; e.g. if you give someone an ordered stack of papers and ask them to search for X, then they will most likely implement binary search
12:36:35 <Cheery> I'm actually wondering why people are still going with imperative languages. *-autonomous categories have been figured out for a while, and it seem to extend functional language to concurrent process-like computing.
12:36:43 <Shiranai> shapr: same reason I got into it too! that and category theory/logic
12:37:01 <koz_> Shiranai: You _vastly_ over-estimate how good people are at problem solving systematically.
12:37:03 <Shiranai> rally wanna get into prolog to taste that paradigm but not not soon I guess
12:37:14 <koz_> Most 'solutions' people come up with is a weird form of heuristic brute force.
12:37:19 <Cheery> why go into prolog when you can bring prolog to haskell?
12:37:22 <koz_> Usually missing like twenty cases.
12:37:25 <EvanR> *-autonomous categories you say?
12:37:32 <shapr> Shiranai: I would also recommend Prolog and APL for brain twisting languages. I like Joy for a stack based language, but it's not a real production language. Maybe FORTH?
12:37:32 <koz_> And only being right about 80% of the time at best.
12:37:39 <nooooop_1> What things can you get with Haskell that you can't with non functionally pure programming languages
12:37:41 <nooooop_1> ?
12:37:52 <shapr> nooooop_1: nobody plays with your toys
12:38:00 <Shiranai> koz_: lol maybe, idk, I know that at least secretaries do use binary search
12:38:09 <koz_> nooooop_1: Optimizations no compiler would dare attempt due to language-level immutability guarantees.
12:38:12 <shapr> nooooop_1: None of the libraries you use will change the values you created
12:38:26 <koz_> Not constantly worrying about mutation wrecking your stuff.
12:38:30 <maerwald> I believe functional vs imperative is mostly just a fun question and not of particular importance.
12:38:31 <wavemode> people will think you're smart
12:38:42 <Shiranai> ^^ true answer
12:38:45 <nooooop_1> lok, @wavemode 
12:38:45 <shapr> nooooop_1: also, when you mutate a variable, you are making a garbage collection decision. You are saying the previous value in that variable name will never be needed again. And *I* at least, am often wrong about that.
12:38:56 <EvanR> if you publish a haskell app, you're super very smart
12:39:08 <shapr> I don't like that about Haskell :-(
12:39:10 <dolio> Is 'imperative' getting credit for binary search now? Why?
12:39:16 <shapr> I don't like the part where people use Haskell to signal that they're smarter.
12:39:21 <koz_> shapr: Me neither.
12:39:44 <EvanR> also  people claim haskell signals you're dumber... which... is likely false
12:39:49 <koz_> Some of the smartest folks I know have nothing to do with Haskell, and I've seen some _shockingly_ terrible takes from Haskellers.
12:39:49 <nooooop_1> Honestly, I just want to make programming easier for myself. Maybe Haskell can help. 
12:39:57 <koz_> nooooop_1: What exactly do you want to do?
12:39:59 <shapr> nooooop_1: that's a good goal
12:40:00 <koz_> In terms of outcomes?
12:40:13 <nooooop_1> @koz_, event sourcing
12:40:13 <lambdabot> Unknown command, try @list
12:40:14 <koz_> 'Make programming easier for myself' is a rather specific set of requirements.
12:40:22 <nooooop_1> lol
12:40:41 <Uniaika> one can achieve such a thing with a carefully crafted set of a hundred perl scripts
12:40:54 <Cheery> EvanR: yup. Basically types themselves can become representations for "protocols" between things.
12:41:01 <koz_> Uniaika: One can achieve such a thing with assembly language and a _very_ strong set of code standards. :P
12:41:02 <nooooop_1> Learn higher level abstractions so I can write more expressive code
12:41:04 <EvanR> nice
12:41:19 <electricityZZZZ> cheery: i have a math degree and i have no idea what this wikipedia article about *-autonomous categories says :-/
12:41:22 <koz_> nooooop_1: If abstractions are your goal, Haskell's a good place.
12:41:57 <koz_> (which is quite sad, because the Simon and Launchbury ST trick is over a quarter century old and basically isn't even a thing outside of Haskell and a few related languages)
12:42:00 <Shiranai> @dolio: you got me thinking for a while. Sure, you can think of binary search as a recursive function but I think most secretaries would think of it as applying n times the same operation `look at the middle and compare`
12:42:00 <lambdabot> Unknown command, try @list
12:42:07 <Cheery> electricityZZZZ: it's hard, but basically we're talking about call-with-current-continuation and what kind of constructs it corresponds to.
12:42:17 <koz_> (I'm not even going to start on the patent absurdism of most proglangs insisting effects can only be tracked in a developer's head and the compiler can't help you)
12:42:24 <electricityZZZZ> the haskell community should probably stop calling things "hard"
12:43:10 <wavemode> it's good to call things hard. when you call something easy, the person who doesn't get it feels like something is wrong with them
12:43:20 <lambdabot> Shiranai: lambdabot commands start with an @ sign, want to try one?
12:43:36 <maerwald> shapr: lol, I got a weird comment on one of my tech challenges once where the reviewer said it looks like junior code because I used lambda in a few places instead of (foo . bar). Haskellers often have this obsession with looking smart.
12:43:40 <EvanR> i distinctly remember some ancient article about haskell stating that monads are hard
12:43:45 <electricityZZZZ> various haskell articles i'ves seen say to "ignore category theory" and that "category theory has little to no relevance to haskell"
12:43:49 <Shiranai> counter point: don't call things hard or easy, just teach them
12:43:50 <electricityZZZZ> is that false?
12:43:54 <EvanR> for a few years i thought they were hard because of tht
12:44:06 <koz_> electricityZZZZ: Do you need to understand Turing machines to write C?
12:44:18 <koz_> Like, how many C programmers can prove Rice's Theorem?
12:44:32 <koz_> This same reasoning translates to category theory and Haskell.
12:44:49 <electricityZZZZ> koz: maybe not in detail but it's probably good to know conceptually what a turing machine is and that their code incantations can become sentient
12:44:56 <maerwald> shapr: even funnier that he didn't seem to know that they are not the same
12:45:03 <wavemode> haskell and category theory are largely (though obviously not entirely) orthogonal. learning one does not mean you will master the other
12:45:08 <koz_> electricityZZZZ: Therein lies the relationship between Haskell and category theory.
12:45:19 <koz_> Knowing category theory gives you some insights which are cool and useful.
12:45:26 <noooop_1> I got kicked off the irc... 
12:45:26 <koz_> They are not mandatory to be a productive or skilled Haskeller.
12:45:31 <Shiranai> hmmm kinda disagree, at least I like the really basic intuition I get from my basic cat knowledge
12:45:39 <koz_> Shiranai: And you likely do!
12:45:42 <Shiranai> I feel it adds at least something
12:45:45 <koz_> I'm not saying it's _useless_.
12:45:47 <electricityZZZZ> i have a question which is somewhat related to shiranai's question
12:45:54 <koz_> I even said that it gives you cool and useful insights, in fact.
12:45:59 <Shiranai> don't know what it adds but it feels like it does lol
12:46:01 <koz_> What I _am_ saying is that it's not _mandatory_.
12:46:11 <Shiranai> oh yeah 100% agree with that then ^^
12:46:14 <koz_> And that you can be a happy, productive and skilled Haskeller without knowing any CT at all.
12:46:34 <koz_> Knowing the 'why' underneath it all is _never_ useless.
12:46:41 <Shiranai> related to that, anyone here read cat theory for programmers?
12:46:45 <Shiranai> thinking on reading it
12:46:46 <Cheery> Understanding the logic / types correspondence is much more important than CT.
12:46:57 <koz_> Shiranai: The Milewski book?
12:47:03 <koz_> Cheery: Yeah, that I can agree with.
12:47:13 <noooop_1> Is there a good event sourcing library for Haskell? 
12:47:21 <Shiranai> koz_: yes that one exactly
12:47:27 <Shiranai> link for others: https://github.com/hmemcpy/milewski-ctfp-pdf
12:47:33 <koz_> In fact, I love Haskell because it lets me state logical concepts without tonnes of irrelevant garbage.
12:47:42 <koz_> Shiranai: I've read the online version.
12:47:47 <koz_> It's certainly interesting.
12:47:52 <maerwald> noooop_1: do it from scratch
12:48:02 <noooop_1> lol
12:48:02 <koz_> I cannot evaluate how good it is as a means of instruction for category theory.
12:48:14 <maerwald> noooop_1: not joking
12:48:14 <Shiranai> koz_: Is it 'in depth'? I have a more mathy background but true cat theory math books are hard af
12:48:17 <koz_> Since I am not a category theorist, and don't even pretend to understand half of what's in it.
12:48:23 <electricityZZZZ> i've had trouble reading articles on category theory because they establish a bunch of definitions and say trivial things and never sell me on the idea that their abstractions are worth my attention in a reasonable amount of time
12:48:28 <Shiranai> ohhh alright, thanks anyways!
12:48:33 <koz_> Shiranai: I can only say 'read it for yourself'. It seemed fairly solid.
12:48:44 <koz_> electricityZZZZ: Welcome to a lot of academic work. Motivation be hard, yo.
12:48:56 <koz_> SPJ is like, a hero in this regard: everything he writes drips motivation.
12:48:57 <electricityZZZZ> i had a little bit of a better time with homotopy type theory
12:49:01 <Shiranai> I read the first chapter of Awodey's book on category theory and I'm completly sold
12:49:05 <koz_> Like, it _exhudes_ motivation from every pore.
12:49:13 <Shiranai> ohhhh you know that thing already?
12:49:19 <Shiranai> I wanna get into HoTT soon
12:49:29 <Shiranai> any opinions you wanna share?
12:49:31 <electricityZZZZ> but i don't know if hott has any relationship to cats and haskell
12:49:33 <koz_> Shiranai: I tried reading Awodey. It's solid mathematics, but I basically gave up after about one chapter.
12:49:35 <Cheery> electricityZZZZ: adjoint functors describe structures that posses soundness/completeness properties, in quite small package.
12:49:45 <koz_> electricityZZZZ: HoTT AFAIK leans on category theory quite a bit.
12:49:48 <maerwald> noooop_1: I've worked with an event sourced platform in haskell. It was all custom
12:49:49 <Shiranai> from what I can tell HoTT has a lot of relation to cats
12:50:00 <electricityZZZZ> um,... the only thing i "understood" which i thought was interesting was that there was some kind of correspondence between algorithms and paths in a continuous space
12:50:02 <noooop_1> koz_, "In fact, I love Haskell because it lets me state logical concepts without tonnes of irrelevant garbage." can you give an example?
12:50:04 <Shiranai> and some vague relation to haskell from cats I guess?
12:50:21 <Shiranai> electricityZZZZ: that sounds insane
12:50:29 <koz_> noooop_1: Sure. Any language with object orientation basically obscures basic things behind layers of 'friendly' 'intuitive' garbage.
12:50:36 <koz_> Which just confuses the core idea and makes it harder to state.
12:50:50 <Cale> electricityZZZZ: This is kind of why category theory is usually not the first thing in every undergrad course in mathematics: it takes a lot of examples to be able to appreciate properly how useful these generalisations are.
12:50:57 <koz_> The impendance mismatch between 'here is the logic in my head' and 'here is the code that runs it' is _gargantuan_ in any language other than haskell in my experience.
12:51:06 <maerwald> OOP is not about control flow :)
12:51:38 <maerwald> it's a simulation of a distributed system
12:51:38 <koz_> (this is before we even get into the fact that 'object' 'orientation' is not well-defined)
12:51:44 <koz_> (and has absolutely no rules)
12:51:49 <koz_> (or laws, or principles, or anything)
12:51:53 <koz_> (it's all fluff and marketing)
12:51:59 <Cheery> OOP is same as putting things into closet then forgetting they're there, so that it's same if you owned it or not.
12:52:11 <wavemode> a true purist would say that OOP is about message passing
12:52:27 <koz_> wavemode: Except no current 'OO' language is Smalltalk.
12:52:33 <maerwald> wavemode: thats what I said
12:52:45 <ja> Cale: do you think it is therefore harder to teach haskell than imperative langauges, as a first language? because students will not appreciate the abstractions?
12:53:01 <koz_> ja: I believe Cale's statement was vis a vis category theory, not Haskell.
12:53:07 <koz_> So I don't think those statements gel.
12:53:22 <Cale> ja: you'll be fine learning Haskell with no knowledge of category theory
12:53:27 <Shiranai> Btw, what do you guys use to code in haskell? Vscode extensions I've found require me to compile the binaries which take years in my WSL1
12:53:36 <EvanR> each practitioner / student must learn what OOP is to them individually
12:53:36 <Cale> and in fact, I recommend avoiding it unless you already have a deep background in mathematics
12:53:36 <koz_> Shiranai: neovim with ALE.
12:53:49 <Cale> (Or want to develop such a background)
12:54:01 <electricityZZZZ> shiranai: here's another introductory discussion https://www.lihaoyi.com/post/WhatsFunctionalProgrammingAllAbout.html
12:54:18 <electricityZZZZ> shiranai: if you are just getting started i really, really recommend that you start with elm
12:54:20 <koz_> I use Neoformat as well, but that's not really to do with programming per se - it just means I never have to think about code layout.
12:54:44 <EvanR> elm has no typeclasses unfortunately
12:54:50 <ja> i am just worried that if i did a introductionary programming course in haskell, people will say things like "my uncle uses python and he says it is much simpler"
12:54:52 <Shiranai> I just finished learyouahaskell but without any linting support and kinda annoying
12:55:04 <koz_> ja: Do you care about getting work done correctly or other people's opinions?
12:55:12 <electricityZZZZ> ja: lol and your uncle can't make small code changes without runtime errors
12:55:21 <ja> if i were to teach, i would need to motivate students
12:55:22 <Cheery> I think I'd use purescript instead of Elm now, the starting boundary is bigger but the stuff you use is useful at least.
12:55:39 <electricityZZZZ> actually i think elm's limited approach is better
12:55:40 <koz_> ja: If you were to teach, you'd have all my sympathies. As someone who's taught people to program.
12:55:43 <koz_> (professionally)
12:55:47 <koz_> (for quite a while)
12:55:48 <wavemode> Shiranai, I just use the vscode haskell-ghcid plugin. I just run ` ghcid -o ghcid.txt --command="cabal repl" ` in a terminal and the errors show up in the editor.
12:55:49 <koz_> (at all levels)
12:55:57 <wavemode> it's a simple setup and it never breaks :)
12:56:15 <ja> koz_: are you implying that teaching is impossible to get 'right'?
12:56:33 <koz_> ja: No such thing. I'm saying it's very difficult, and language choice isn't even the first, second or tenth issue.
12:56:43 <koz_> And concerns vis a vis student motivation won't be fixed by language changes.
12:56:52 <koz_> Especially at the lowest level, where programming instruction tends to begin.
12:57:01 <dolio> Students don't get to make the teacher rewrite the whole curriculum because of something their uncle said.
12:57:26 <ja> heh good point
12:58:07 <koz_> Whenever someone asks me 'should I learn X', the answer depends very heavily on what they care about and want.
12:58:17 <koz_> If they don't know those things, motivation will be an issue irrespective of what X is.
12:58:35 <koz_> Because if you yourself don't know what you seek to gain from the learning you are doing, you'll find it very difficult to even start, much less continue.
12:58:57 <ja> koz_: do you know of some good resources for learning how to teach?
12:59:15 <koz_> ja: Sure. Go do the Cambridge CELTA program. If you survive, you'll learn to teach anything. :P
12:59:19 <electricityZZZZ> so one question i have about programming which the haskell community might understand
12:59:21 <koz_> (yes, it's about teaching English to adults)
12:59:23 <Cheery> I actually have a question of my own, but not sure if it's timely. How would you describe graphical user interfaces in Haskell?
12:59:25 <koz_> (all their methods translate)
12:59:36 <koz_> Cheery: A miserable pile of secrets.
13:00:00 <electricityZZZZ> when i set about writing code i end up finding that what i write is coupled to the machine rather tightly
13:00:30 <ja> ok, thanks, i'll check out CELTA
13:00:48 <electricityZZZZ> if computers can dominate at go, they should be able to absolutely destroy my own capacity to do things like decide what computer a task runs on, whether to have a thread somewhere or not, etc
13:01:27 <electricityZZZZ> but instead of letting a sufficiently smart compiler do the work of translating my code to what the computer does
13:01:50 <electricityZZZZ> i end up describing what the computer does, despite the original promise that i was using a language designed for programming and not for providing machine code
13:02:16 <wavemode> computers and compilers simply aren't as smart as you give them credit for :p
13:02:20 <Uniaika> koz_: wrong three-letters word :P
13:02:21 <electricityZZZZ> a suitable language should know when to divide up tasks across GPU and CPU etc
13:02:35 <electricityZZZZ> and ideally would tell me if i would benefit from having an FPGA, or whatever else
13:02:52 <koz_> electricityZZZZ: Except a compiler doesn't understand what problem you're trying to solve.
13:02:57 <Uniaika> electricityZZZZ: "computers" do not dominate at go
13:02:58 <koz_> And fundamentally can't.
13:02:59 <Cheery> You can use same language to describe either low-level operation or abstract algorithms, but yeah. I'm a bit frustrated about the same thing. Types actually do solve that problem because every instance doesn't need to be implemented the same way.
13:03:00 <koz_> In most cases.
13:03:19 <koz_> Unless your language is _highly_ special-purpose.
13:03:20 <electricityZZZZ> frankly i can't even keep up with algorithms
13:03:30 <koz_> electricityZZZZ: It's hard, but rewarding.
13:03:43 <koz_> (disclaimer: I have a Master's degree in probably the algorithmiest of algorithmy areas)
13:03:50 <koz_> (and most of a PhD in something adjacent)
13:04:04 <electricityZZZZ> it would be best if i could simply specify i'm not sure what, maybe some types and then how i want them to be transformed
13:04:07 <koz_> Uniaika: Rofl.
13:04:12 <electricityZZZZ> maybe the outcomes of those transformations
13:04:26 <electricityZZZZ> and then my compiler should simply decide how to accomplish that
13:04:26 <koz_> electricityZZZZ: Sure, except the problem remains: the compiler doesn't, and cannot, understand what problem you are trying to solve.
13:04:41 <electricityZZZZ> sorry, i don't understand what it doesn't understand
13:04:52 <EvanR> electricityZZZZ you're dwelling heavily on the implementation details
13:04:58 <koz_> What exactly does your program seek to solve?
13:05:05 <koz_> What kind of problem? In what domain? Under what constraints?
13:05:23 <koz_> A compiler knows none of these things.
13:05:37 <koz_> It just knows that 'language construct A corresponds to language construct B according to this set of rules'.
13:05:48 <koz_> And it ensures that the translation from A to B is faithful to said rules.
13:05:54 <koz_> What this _means_ is totally alien to it.
13:05:57 <koz_> Because semantics are hard.
13:06:24 <EvanR> alternatively you only care about semantics and let the B be whatever it needs to be
13:06:34 <EvanR> for the first approximation, which might make you tons of money
13:06:56 <electricityZZZZ> well right so i think i might be okay with specifying types
13:06:59 <koz_> A computer has no idea whether 'write this to this register' is 'make the robot catch the ball' or 'add two numbers in the midst of a giant calculation'.
13:07:22 <electricityZZZZ> well, okay, here's a possible simplification:
13:07:33 <electricityZZZZ> i specify some types, and then i specify how the types are to be transformed
13:07:40 <electricityZZZZ> for example i want something to end up sorted
13:08:01 <koz_> OK, since you've kicked my personal hornet's nest.
13:08:15 <monochrom> On the bright side, there were compilers that recognized standard benchmarking code and emitted cheatingly fast code :)
13:08:18 <koz_> Sorting efficiently is _really really really really_ not as simple as saying 'plz sort thnx bai'.
13:08:25 <koz_> It depends on like, a dozen different factors.
13:08:28 <electricityZZZZ> right
13:08:31 <koz_> First, what's your data? How is it represented?
13:08:34 <electricityZZZZ> so encode your knowledge about sorting
13:08:37 <koz_> Second, do you need a static or dynamic sort?
13:08:39 <electricityZZZZ> into some kind of computer program
13:08:41 <koz_> Third, full or partial?
13:08:48 <electricityZZZZ> right and i don't have time to learn what you know about sorting
13:08:58 <electricityZZZZ> i want your knowledge and expertise built-in to my compiler
13:09:01 <dolio> So use a library.
13:09:02 <koz_> If you want efficiency, you must.
13:09:13 <koz_> Because compilers cannot make these decisions without human-level knowledge of the problem domain.
13:09:17 <koz_> For _every_ problem domain.
13:09:19 <koz_> Ever.
13:09:21 <koz_> In existence.
13:09:29 <electricityZZZZ> i don't even understnd what human level knowledge of the problem domain is
13:09:30 <koz_> You can make choices that are 'pretty good most of the time'.
13:09:32 <EvanR> knowledge: ain't nobody got time for that
13:09:36 <electricityZZZZ> and i don't really understand what human level knowledge is
13:09:49 <monochrom> What is the purpose of this discussion?
13:09:49 <koz_> electricityZZZZ: The point is that it depends heavily on what you actually need done in non-program terms.
13:09:56 <electricityZZZZ> also programmers seem to assume that they can't actually run their program on test data
13:10:05 <electricityZZZZ> and allow the compiler to tune things or make decisions based on empirical performance
13:10:15 <electricityZZZZ> it's like we have to guess how things will go, when that in fact is unreasonable
13:10:32 <koz_> monochrom: At this point, am inclined to agree.
13:10:50 <electricityZZZZ> koz: fine so maybe i can add some constraints
13:10:53 <EvanR> monochrom: the emergency release valve for over-caffeination
13:10:56 <koz_> My point is that choosing a perfect sort for any occasion is a decision a compiler cannot make, as it requires information far beyond its remit.
13:11:08 <maerwald> I can't participate in this discussion with my new keyboard layout. I'm too slow
13:11:09 <electricityZZZZ> like "this computation must be performed in a certain amount of time" (im sure that will kick a hornet's nest too)
13:11:12 <koz_> Like, unless you want to encode problem domain constraints for every domain ever into your compiler logic.
13:11:28 <koz_> electricityZZZZ: Yeah, this _clearly_ reads like you've never studied algorithms.
13:11:39 <electricityZZZZ> why can't i just run my program
13:11:41 <koz_> Since saying 'X must take a certain amount of time' is a fairly meaningless statement for most X.
13:11:50 <Cheery> electricityZZZZ: the starting point is abstract datatypes, eg. representation af natural numbers as zero/succ, then laws over that. Then you have some way to switch the implementation under that thing.
13:11:55 <electricityZZZZ> and then let the compiler try different things, and then decide what's best
13:12:04 <monochrom> That reminds me of the first section of the scheduling chapter in all OS courses and textbooks: clearly if you know the future, you can do perfect scheduling.
13:12:06 <koz_> electricityZZZZ: OK, your program is a nuclear missile controller.
13:12:08 <electricityZZZZ> koz: i have completed at least one course in algos and i knew vazirani ;)
13:12:14 <koz_> Run _that_ lots of times and see what happens. :P
13:12:31 <monochrom> The rest of the scheduling chapter is on the struggle because no one knows the future.
13:12:31 <Cheery> electricityZZZZ: in Haskell typeclasses can achieve that sort of stuff, but they cannot change the specifics "in-the-middle" and neither "runtime"
13:12:42 <electricityZZZZ> koz: but if i have fp, i just decouple the code and run simulation
13:12:59 <koz_> electricityZZZZ: Except now you're lying to yourself, because you now have to write said simulation and have it be faithful to reality.
13:13:06 <koz_> You've just taken a _hard_ problem and made it _harder_.
13:13:12 <dolio> What happens when the simulation doesn't match reality?
13:13:16 <electricityZZZZ> well, simulation can represent requirements
13:13:25 <monochrom> maerwald: I was successful in inciting my students to say: if you can type slowly, you can type quickly :)
13:13:26 <koz_> electricityZZZZ: How do you know that your knowledge of the requirements is right?
13:13:33 <koz_> How does your _compiler_ know those requirements?
13:13:36 <electricityZZZZ> because you're saying that your code needs to represent hypothetical situations which don't occur empirically right?
13:13:48 <koz_> Also, you assume that the search space for a solution is tractable even if you do know.
13:13:57 <wavemode> electricityZZZZ, I don't quite understand what you're really asking for. do you want a programming language, or an application? in a programming language, the programmer is given control of how the program should run. that's the whole point. in an application, the developer decides everything and the user is just along for the ride
13:14:20 <koz_> wavemode: A magic compiler which can figure out magically what algorithm choices you should make.
13:14:24 <koz_> Is how I understand it.
13:14:32 <electricityZZZZ> well, maybe there are hints
13:14:35 <wavemode> you should see the magic I can do in excel! that's an application
13:14:46 <electricityZZZZ> maybe i say that there is so much ram on a system, or that there is some kind of time deadline or soforth
13:14:53 <electricityZZZZ> but ideally i would minimize that kind of instruction
13:14:57 <maerwald> monochrom: you and your manipulations!
13:14:59 <koz_> electricityZZZZ: Except now you're tied to a machine anyway.
13:15:11 <monochrom> May I tell you an Aesop fable?
13:15:13 <electricityZZZZ> well yes i am not saying that i would completely decouple from the machine
13:15:30 <electricityZZZZ> but what if my compiler can tell me the benefit of adding ram
13:15:31 <koz_> electricityZZZZ: Except your _starting point_ was 'I feel it's too coupled to a specific machine and I'm telling a machine what to do'.
13:15:49 <electricityZZZZ> yes, i am tired of hearing about level whatever cache and pipeline bubbles and other nonsense
13:16:03 <koz_> electricityZZZZ: Except performance engineering can require this knowledge.
13:16:07 <koz_> I'm not saying it always does.
13:16:10 <electricityZZZZ> i want to write my code and know that the result is on par or superior to what an expert programmer can create
13:16:12 <koz_> it depends on what you're trying to do.
13:16:13 <electricityZZZZ> on par with
13:16:17 <monochrom> A group of mice convened and agreed that they should optimize their algorithms for practically likely inputs, not theoretically pathological inputs.
13:16:21 <koz_> Yeah... you _can't_ do this automagically.
13:16:30 <koz_> Not for every problem domain we'll ever come up with.
13:16:34 <dolio> electricityZZZZ: You need to hire someone if you don't want to program.
13:16:36 <koz_> This is why you need a human expert.
13:16:37 <monochrom> The also agreed that someone else should find out what the practically likely inputs are.
13:16:45 <EvanR> electricityZZZZ: you need a new language with enough static info discoverable so the computer can prove such things
13:16:46 <wavemode> I can sort in O(1) if I assume the data is already sorted
13:16:47 <electricityZZZZ> but the purpose of programming is to eliminate employment
13:17:01 <koz_> electricityZZZZ: I mean... if you think so, good for you.
13:17:16 <monochrom> I thought programming created programmer employment.
13:17:17 <koz_> I'm checking out of this discussion at this point, since I've said everything I'm gonna say on this topic anyway.
13:17:27 <dolio> Maybe your estimation of how hard Go is is actally way too high.
13:17:43 <maerwald> “Amateurs hack systems, professionals hack people” -- Bruce Schneier
13:17:44 <koz_> And it's veering dangerously close to tech cultism, which just makes me vomit reflexively.
13:18:26 <electricityZZZZ> wavemode: right and maybe empirically if you run your code on real world data, you will find that the data is always sorted or near-sorted
13:18:33 <monochrom> BTW I also want to make my lecture slides and know that the result is on par or superior to award-winning lecture sides. Any tips? Which software can do it for me?
13:18:49 <electricityZZZZ> monochrom: powerpoint
13:19:09 <monochrom> You think it's that simple?
13:19:18 <wavemode> the funny thing is, some of what electricityZZZZ wants is theoretically possible, but not for the purpose of decoupling from hardware. it would only work if you HEAVILY couple the language to the hardware as well as the operating system. it's impossible for a language which is meant to run on a variety of processors and systems, to be able to know that much
13:19:19 <EvanR> the expert programmer got promoted to management
13:19:24 <dolio> Okay, so now the neural net will pick insertion sort, and someone will eventually feed in non-sorted data, and you'll get bad performance.
13:19:48 <electricityZZZZ> wavemode: and so the compiler would thumb through all the papers which have been published, all possible machine configurations, etc, and conclude that some kind of algo which is fast on nearly-sorted data is best
13:20:03 <electricityZZZZ> dolio: right, in the machine learning community that is called generalization
13:20:13 <WinchellsM> For a process `pid`, is there an idiomatic way to get the value of an environment variable for `pid`?
13:20:20 <electricityZZZZ> and you guys are absolutely right that statistical models of things can fail
13:20:37 <monochrom> WinchellsM: I think no, you don't even have permissions.
13:20:41 <maerwald> compilers and AI sounds like a terrible idea
13:20:45 <WinchellsM> In Linux these are stored in /proc/<pid>/environ
13:20:52 <monochrom> Also wrong channel.
13:21:09 <WinchellsM> I mean in Haskell
13:21:29 <monochrom> No.
13:21:47 <monochrom> I mean no portable way.
13:22:31 <EvanR> WinchellsM: check hackage but since it requires root access i doubt someone thought it'd be smart
13:22:52 <monochrom> There is an idiomatic way to read a file.  Your file happens to be calld /proc/45/environ. Syllogism.
13:26:46 <WinchellsM> Ok
13:27:29 <devalot> Is there a package/type class for displaying formatted error messages to users?  I would imagine something like this must exist but searching around Hackage didn't reveal it to me.
13:37:21 <electricityZZZZ> wait, what? type checking can become undecidable?
13:41:28 <dolio> Yes.
13:45:10 <electricityZZZZ> unrelated question: is there any meaningful way of defining a "random algorithm" or "random program"?
13:45:53 <dolio> Probably, but those English phrases are ambiguous.
13:46:29 <merijn> electricityZZZZ: There's not even a way to define "algorithm"
13:46:51 <merijn> At least, not one that's (somewhat) universally accepted
13:47:42 <electricityZZZZ> or i suppose in haskell we could say "random function" 
13:47:59 <jumper149> What do you guys think of stacking multiple ReaderT on top of each other instead of having a product type like a record to be read?
13:48:58 <merijn> jumper149: I'd rate the first option "really bad" and the second one "somewhat bad" 
13:49:06 <dolio> I probably wouldn't do it.
13:49:25 <jumper149> merijn: Is there a better option than those two?
13:49:25 <Rembane> jumper149: Do it just to see if it can be done, and then you go for the record solution.
13:49:44 <merijn> jumper149: persumably each reader represent some concrete functionality
13:50:08 <merijn> jumper149: So I'd say "explicit newtype" + the concrete supported API of that functionality
13:50:28 <jumper149> Rembane: It shouldnt be a problem to do it since `MonadReader a MyMonad` and `MonadReader b MyMonad` should be 2 different instances
13:51:33 <merijn> Publically visible MonadReader (and all other mtl) constraints are bad too, so :p
13:51:43 <Rembane> jumper149: That's good, what's your spontaneous thoughts on the ergonomics of the different solutions? 
13:51:44 <merijn> One reason being exactly what you just mentioned
13:52:01 <merijn> Ugh
13:52:55 <merijn> Like 2 weeks (or something like that) ago I wrote out an entire argument on why the mtl classes are this design is a bad idea, but I forgot to copy and paste it at the time and tbh I can't be bothered to repeat it now...
13:53:07 <merijn> brownie points for whoever finds a link in the logs :p
13:53:49 <Rembane> merijn: Was it the one with MonadDatabase?
13:54:24 <merijn> Rembane: Probably like MonadSql, or something
13:54:29 <dolio> I recently wrote some code using mtl and it worked fine.
13:54:41 <merijn> I know people have written similar blogposts
13:54:52 <merijn> dolio: Note that I'm not arguing against using mtl
13:55:00 <dolio> It was using ReaderT, even.
13:55:04 <Rembane> merijn: Got it. :)
13:55:08 <merijn> dolio: I'm arguing against having mtl classes/types in public APIs
13:55:18 <dolio> Right, against aglebraic effects.
13:55:25 <merijn> dolio: "public" potentially also being "within your own package"
13:55:48 <merijn> dolio: No, the problem isn't even mtl-style classes or tagless final style
13:56:20 <merijn> dammit
13:56:38 <merijn> almost got suckered into writing it all out again at 23:00 :p
13:56:50 <merijn> I'm going to do something useless with my time to relax instead :p
13:57:03 <jumper149> merijn: haha :P
13:57:22 <dolio> Algebraic effects don't have anything to do with 'tagless final style'.
13:57:55 <dolio> I mean, strictly speaking, it's arguing against using any common algebraic specifications.
14:01:33 <dolio> I guess my code doesn't have the classes in 'public APIs,' but jumper149 didn't say anything about public APIs, either.
14:15:38 <heath> will someone point me to the definition of (&&) in Data.Bool :) https://gitlab.haskell.org/ghc/ghc/-/blob/4898df1cc25132dc9e2599d4fa4e1bbc9423cda5/libraries/base/Data/Bool.hs doesn't seem to be what I'm looking for
14:16:54 <merijn> heath: I suspect it's a primop
14:16:57 <merijn> heath: Why?
14:17:12 <heath> curiosity
14:18:34 <merijn> There's an implementation in GHC.Base, but it's commented out with CPP
14:19:35 <merijn> heath: https://hackage.haskell.org/package/ghc-prim-0.6.1/docs/GHC-Classes.html#v:-38--38-
15:01:31 <Cheery> I feel a bit silly when I was asking about gui representation..
15:01:59 <Cheery> A type can describe a GUI
15:02:35 <Cheery> especially if it's a classical linear type
15:50:22 <net4all> Suppose I have a type with "a lot" of constructors (~25). I would like to take several values of this type and put values of each constructor in separate lists. Then do some operations on these lists (some of the constructors are symmetric pairs, and I am looking for those). Then convert back from several lists to a single type with many constructors.
15:52:15 <net4all> Is there a something "nicer" compared to just doing this by hand with a function? Right now I am writing a function for each constructor that returns a tuple of lists. It works but is tedious.
15:55:27 <net4all> (Implementing some multiparty session types and I need to find pairs of constructors in a tree-like type where each level has quite a lot of constructors.)
15:55:35 <johnw> you mean, you just want to split up values by constructors?
15:55:50 <slack1256> That sound something like uniplate could help.
15:56:45 <wavemode_> net4all, could you pastebin some example code of what you mean?
16:09:16 <net4all> (will write example)
16:22:28 <ezzieyguywuf> am I missing it, or does the Linear package not include a function to create a unit vector from a given vector?
16:23:26 <wavemode_>  normalize
16:24:11 <ezzieyguywuf> wavemode_: which module is it in?
16:24:22 <wavemode_> Linear.Metric
16:24:30 <wavemode_> i just hoogled "normalize"
16:24:40 <ezzieyguywuf> wavemode_: ah hah! thank you
16:24:41 <xsperry> any stack users? I want to test new resolver with an old, working project, and if it is too much trouble to get it to work, I want to revert back to the old one
16:24:48 <xsperry> what's the best way of doing that?
16:24:50 <dsal> net4all: generated prisms from lens does this pretty easily.
16:26:29 <dsal> > [Left 3, Right 4, Right 5, Left 6] ^.. folded . _Right -- net4all: like, this sort of thing for retrieving values constructed by a given constructor using its prism.
16:26:31 <lambdabot>  [4,5]
16:29:45 <net4all> (terrible code https://gist.github.com/jdyb/d4fdbfa5c7315a03160897bdd8b923ee)
16:32:02 <net4all> wavemode_: ^^
16:32:13 <net4all> dsal: Ah.
16:33:11 <dsal> I'm not sure what you're trying to do with this, but the type with a product of lists of all of the types of the sum type seems like it might not get you there.
16:34:08 <dsal> [LotsOfParts] seems like a more useful thing in general.  At the very least, you aren't throwing away all of the ordering (in case that matters).
16:38:42 <net4all> dsal: I did start by just traversing the tree in the obvious (recursive way), but what blocked my approach there was that related parts ("pairs of constructors") are not local to a subtree.
16:39:41 <net4all> I could kind of flatten all of the leaves into a single list, but then the performance for real insances degrades far to much.
16:42:43 <net4all> (The ordering of the tree mostly does not matter.)
16:51:04 <ezzieyguywuf> hrm, "Couldn't match expected type ‘V3 Float’ with actual type ‘Float’ In the expression: (sin (theta / 2)) * n :: V3 Float"
16:51:07 <ezzieyguywuf> but this works fine in ghci
16:51:43 <ezzieyguywuf> http://dpaste.com/14KEMPT
16:53:14 <monochrom> what is the type of n?
16:53:29 <monochrom> because it's going to nail the type of the rest
16:53:34 <monochrom> and theta too
16:54:06 <ezzieyguywuf> monochrom: V3 Float
16:54:18 <ezzieyguywuf> I've tried it with `n...:: V3 Float` as well, same result
16:54:25 <monochrom> theta is likely Float because dot product.
16:54:25 <net4all> dsal: I will try to study lenses. Seems like it may be useful for this. Thanks for the help!
16:54:37 <monochrom> this implies sin (theta /2) :: Float too
16:54:47 <ezzieyguywuf> monochrom: but I can multiply a Float by a V3 a
16:54:51 <ezzieyguywuf> I've tested this in ghci
16:55:09 <monochrom> What is your test?  0.3 * n ?
16:55:46 <ezzieyguywuf> (sin (theta / 2)) * v
16:55:51 <ezzieyguywuf> where theta = pi/4
16:56:00 <ezzieyguywuf> theta :: Floating a => a
16:56:27 <monochrom> I say no.
16:56:52 <ezzieyguywuf> you say 'no' to what?
16:57:02 <monochrom> OK misread.
16:57:07 <ezzieyguywuf> ah
16:57:31 <monochrom> "theta = pi/4" has nothing to do with "theta = acos (p1' `dot` p2')".  Please don't use name clash to confuse everyone.
16:57:38 <xsperry> is there a channel specifically for questions related to haskell stack?
16:58:01 <xsperry>  /list is not working for me ATM
16:58:13 <ezzieyguywuf> monochrom: sorry, that was the value I used in ghci
16:58:16 <monochrom> I bet theta's type is going to be Float. You have (foo :: Float) * (bar :: V3 Float).
16:58:32 <monochrom> Therefore your ghci test has nothing to do with your code.
16:58:38 <ezzieyguywuf> trying this - http://dpaste.com/1KKRBKP
16:58:58 <slack1256> xsperry: I usually send @alis a message when searching for a channel. /list never has worked for my on freenode.
16:59:01 <ezzieyguywuf> monochrom: yes, that duplicates the error in ghci!
16:59:07 <ezzieyguywuf> that gets me towards an answer thank you
18:00:32 <ezzieyguywuf> is it possible to distribute cabal compilations, i.e. like I can with distcc?
18:30:35 <infinity0> man, just chased down a space leak with ghc-heap-view
18:31:05 <infinity0> culprit was me storing a (Either a b) in one component of the state in a long-running state monad, which was a thunk depending on previous versions of the state
18:31:14 <infinity0> forcing this before storing worked, one-char fix >.<
18:39:07 <ezzieyguywuf> dang
18:39:12 <ezzieyguywuf> that's rough
18:39:17 <ezzieyguywuf> https://hackage.haskell.org/package/linear-1.21/docs/Linear-Matrix.html#v:transpose how do I use this function?!
18:39:46 <ezzieyguywuf> nvm, I got it
18:39:53 <ezzieyguywuf> i must have been doing something dumb before
18:40:17 <ezzieyguywuf> ah wait, no this was the one https://hackage.haskell.org/package/linear-1.21/docs/Linear-Matrix.html#v:translation
18:43:21 <infinity0> do you know what lens is?
18:43:38 <infinity0> if not, have a look at https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html
18:43:47 <infinity0> that function will give you one of those
18:45:42 <ezzieyguywuf> ah, i see.
18:55:06 <d34df00d> I was discussing something with somebody and I realized I don't fully understand something else.
18:55:41 <d34df00d> So first question: how do you define parametricity for a polymorphic function with a class constraint?
18:56:38 <d34df00d> My mental model is that foo :: SomeClass a => a -> ... is roughly equivalent to some foo :: DictWithFunctions a -> a -> ..., and here it's more obvious. How incorrect is that model?
19:00:31 <solonarv> pretty accurate, AFAIK
19:00:42 <solonarv> that is how GHC implements constraints
19:01:30 <monochrom> Until you have two such functions. Then you have to remember that they must use the same dictionary.
19:02:11 <monochrom> This is why it is unreliable to draw inspiration from implementations. They can do something more flexible than you realize.
19:02:46 <d34df00d> Cool, that's nice.
19:03:05 <d34df00d> But suppose I want to write a function `id' :: a -> a` such that it's not really parametric.
19:03:14 <Shiranai> Hello, silly question, I've noticed that some questions in the 99 haskell questions have one star and some have two stars
19:03:26 <Shiranai> is there something to this?
19:03:30 <monochrom> "Typeable a => a -> a" can help :)
19:03:50 <monochrom> also don't forget "negate :: Num a => a -> a" is along the same line.
19:03:54 <solonarv> you could also use ghc primitives to inspect the argument's heap representation
19:04:00 <d34df00d> If I do `class Stupid a where smth :: a -> a`, `instance Stupid Bool where smth = not`, `instance Stupid a where smth = id`, and if I enable IncoherentInstances, then I can do `id' = smth`, and it'll be non-parametric.
19:04:16 <d34df00d> But here IncoherentInstances is really the culprit.
19:04:33 <c_wraith> if you tell GHC to make your code Incoherent, you get what you deserved.
19:04:43 <d34df00d> Yes, I understand that.
19:04:49 <d34df00d> So let's say I forbid myself from using said extension.
19:04:53 <d34df00d> Can I still get a similar behaviour?
19:05:16 <monochrom> I don't worry the "incoherent" part. "Num a => a -> a" is already unpredictable enough.
19:05:41 <d34df00d> I don't consider Typeable a => ... to be along the same lines, since it's effectively passing runtime representation which I can expect, it's not a purely type-based thing.
19:05:49 <d34df00d> monochrom: why?
19:06:10 <monochrom> Even "[] :: Show a => [a]" has divergent behaviour.
19:06:32 <d34df00d> monochrom: hmm, how? I don't think I see that.
19:07:09 <monochrom> print (([] :: Show a => [a]) :: [Char]) and print (([] :: Show a => [a]) :: [Int]) give you different outputs.
19:07:38 <infinisil> > print (([] :: Show a => [a]) :: [Char])
19:07:39 <lambdabot>  <IO ()>
19:07:47 <infinisil> % print (([] :: Show a => [a]) :: [Char])
19:07:48 <yahb> infinisil: ""
19:07:54 <infinisil> % print (([] :: Show a => [a]) :: [Int])
19:07:54 <yahb> infinisil: []
19:08:11 <infinisil> Nanii
19:08:17 <monochrom> :)
19:08:40 <d34df00d> monochrom: that's fine by me, `print` also takes a Show constraint which is like that extra parameter adjusting the behaviour.
19:09:16 <monochrom> "negate :: Num a => a -> a" must understandably be type-varying, too.
19:09:50 <monochrom> e.g., if you define your own type for mod-2 arithmetic, your negate = id.
19:10:09 <d34df00d> But they all have extra Num a/Show a/etc constraints, so each invocation of those functions must either carry that constraint along or use that with a specific type that satisfies that constraint, right?
19:10:32 <d34df00d> So the source of the possible variance in the behaviour is clearly visible in types.
19:11:04 <d34df00d> But if I have id' :: a -> a, I sort of expect it to be the same (identity) function, no matter what `a` gets instantiated to.
19:11:07 <monochrom> Your "class Stupid" example enjoys as much. You're talking about "Stupid a => a -> a". What difference from Num in this aspect?
19:11:38 <d34df00d> Because if you enable `IncoherentInstances`, then you can write a polymorphic function that doesn't propagate that constraint and that still isn't parametric.
19:11:59 <monochrom> No. You are still stuck with "Stupid a =>".
19:12:38 <d34df00d> Interesting.
19:12:48 <d34df00d> Now I wonder how I managed to achieve non-parametric behaviour without the constraint.
19:13:14 <monochrom> May I guess "you didn't save the new code"? :)
19:13:28 <ezzieyguywuf> 'library' depends on 'library' 
19:13:38 <d34df00d> monochrom: that would be a shame.
19:13:42 <ezzieyguywuf> when cabal tries to build ansi-terminal
19:13:50 <dolio> You can't have non-parametric behavior without a constraint. That's the point.
19:14:34 <ezzieyguywuf> the full error is "Error: Components in the package depend on each other in a cyclic way: 'library' depends on 'library'"
19:14:42 <d34df00d> dolio: I wonder if there's a rigorous proof of that fact.
19:14:53 <d34df00d> Especially given the buttload of ghc type system extensions.
19:15:06 <ezzieyguywuf> oh shoot, nvm it's building like a very old version. why?!
19:32:14 <Shiranai> I am solving the 99 haskell problems and was wondering if my implementation is fine. https://pastebin.com/R5tbxnEa
19:32:48 <Shiranai> specifically, if n<0 then I need to compute `length xs`, is it computed both times in that program or does the compiler "remembers"?
19:34:26 <MarcelineVQ> both times, write   len = length xs  in the where  and use len instead of length xs if you want once
19:34:56 <MarcelineVQ> sharing is created by naming things
19:37:45 <Cale> Shiranai: length xs will be computed once for t, and then shared between the two uses of t
19:38:27 <Cale> Shiranai: However, in the third case, you're computing length xs, and then applying rotate to a new list, where it may be computed again
19:38:55 <MarcelineVQ> oh woops I didn't notice t wasn't used in  the   n < 0  case
19:38:59 <Shiranai> Thanks, how could I avoid it being computed again?
19:39:44 <Shiranai> just adding it to the `where` , right?
19:39:49 <Cale> I'm not sure why you have to handle these cases separately at all
19:39:54 <Cale> The first case should do
19:40:57 <Shiranai> second is useless but third one is needed because of `drop`
19:41:11 <Cale> hm?
19:41:20 <Cale> > (-5) `mod` 17
19:41:21 <lambdabot>  12
19:41:49 <Cale> So long as the length is positive, the mod will be nonnegative
19:42:03 <Cale> You might want to add a case to handle the empty list though
19:42:47 <Shiranai> ohhh because I wasn't using parens when trying that same expression ghci thought I was meant -5 as Int -> Int lol
19:42:55 <Shiranai> > -5 `mod` 17
19:42:57 <lambdabot>  -5
19:43:15 <xsperry> huh
19:43:19 <Shiranai> or not, idk what it's doing but it's not positive
19:43:25 <Cale> Yeah, mod has similar precedence to other multiplicative operations, which means it binds more tightly than negation
19:43:28 <xsperry> > 5 `mod` 17
19:43:30 <lambdabot>  5
19:43:33 <Shiranai> ahhhh makes sense
19:44:20 <Shiranai> Thanks a lot!, though I am still curious on how to avoid those double computation, some binding to a name in a `where` will do right?
19:44:29 <Cale> yeah
19:44:49 <Cale> You shouldn't have any double computations left though, I think
19:45:10 <Cale> It will be slightly more efficient to use splitAt t xs
19:45:44 <Cale> Because both drop and take have to traverse the list from the start
19:46:23 <Cale> (splitAt walks down the list once, and then is able to produce both results)
19:46:50 <Shiranai> yeah no more double computations in that example, was wondering for some other case
19:47:08 <Cale> Yeah
19:47:11 <Shiranai> had forgotten about splitAt, thanks!
19:47:31 <Cale> Any bound variable whose type isn't type class polymorphic will be evaluated at most once
19:48:14 <Shiranai> why could it be evaluated two times if it is polymorphic though?
19:48:40 <Cale> If it's polymorphic, then it's implemented by a function of the type class dictionary to use
19:48:49 <Cale> and that function is not memoised
19:49:14 <Cale> (It's not even always completely clear that it would be a good idea to memoise it)
19:49:55 <Shiranai> aight, thanks!
19:51:32 <Cale> Although the fact that functions are proper mathematical functions means that it wouldn't be wrong to store the result of computing functions on individual arguments, if you did that, you could never collect any garbage
19:51:45 <Cale> So you'd consume memory very quickly
19:52:32 <Cale> There are libraries which can help take advantage of the little bit of memoisation that laziness does (that bound variables are computed at most once) in order to memoise functions though.
19:53:01 <Shiranai> hmm sounds nice, I'll keep that in mind for when I do some project :)
19:53:10 <Cale> http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html -- the implementation of this library is really enlightening
19:53:25 <Cale> I recommend starting with the source link for bool :)
19:54:01 <Shiranai> btw, I ended rewritin my early function as `rotate xs n = (fst $ splitAt t xs) ++ (snd $ splitAt t xs)` . I feel there must be some way of writing it more compositionally without using a where
19:54:12 <Shiranai> it gives me some monad feel but honestly idk
19:54:16 <Cale> You really should use a let/where
19:54:23 <Cale> That will compute the splitAt twice
19:54:39 <Cale> plus, it gives you the chance to pattern match
19:54:57 <Cale> let (us, vs) = splitAt t xs in vs ++ us
19:55:52 <solonarv> d34df00d: there is a slightly handwavy proof: types are erased, and at runtime your function just gets handed a pointer. there is no type information that it could use to behave differently depending on the type!
19:56:18 <solonarv> but I am not convinced that this is actually true; there may be some type information left that you can access using GHC internals
19:57:03 <wavemode_> I believe that function is the same as `rotate xs n = uncurry (++) (splitAt t xs)` 
19:57:52 <d34df00d> solonarv: personally I feel like I'm sweeping a lot under the rug when I'm saying "types are erased hence X".
19:57:57 <Cale> (which is wrong, because it will not rotate the list)
19:58:00 <d34df00d> But maybe that's what you meant by "handwavy" :)
19:58:18 <Cale> You can flip the (++) though
20:01:43 <solonarv> d34df00d: that is indeed what I meant 
20:29:06 <Shiranai> @list
20:29:06 <lambdabot> What module?  Try @listmodules for some ideas.
20:29:11 <Shiranai> @listmodules
20:29:11 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
20:29:11 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
20:29:47 <Shiranai> @pl \x -> x `mod` 10 == 0
20:29:47 <lambdabot> (0 ==) . (`mod` 10)
20:29:57 <Shiranai> damn I'm stupid
21:39:49 <adam_wespiser> is there a way to stream the contents of a file while it's actively being written to?
21:41:06 <adam_wespiser> I have a log file, and I want to read in the lines, as they are being written
21:50:00 <dsal> That's not exactly how filesytems work.  You'd have to read to EOF and then block waiting for more bytes.  You'll get bytes before lines are complete.
21:51:58 <jchia_> question about process package: Why does it pretend stdin and stdout are String instead of ByteString? What can I do if I want to deal with ByteString, which is the reality on Linux at least?
21:52:54 <dsal> Maybe it's bad?
21:53:23 <dsal> @package process
21:53:23 <lambdabot> https://hackage.haskell.org/package/process
21:55:29 <jchia_> On Linux, stdout & stdin are streams of bytes, no streams of unicode characters
21:55:35 <dsal> jchia_: It depends on how you use it.  I'm using it to extract data streams from mpegs with ffmpeg.  It does work fine.
21:55:57 <jchia_> if i want characters i can the the encoding and decoding explicitly myself using an encoding that i choose
21:56:20 <jchia_> how do you convert the Char to Word8?
21:56:38 <jchia_> or the String to ByteString?
21:56:40 <dsal> I never have Char. 
21:56:45 <jchia_> String is [Char]
21:57:15 <dsal> Yes... what API are you looking at?
21:57:32 <jchia_> when you try to read stdout using something like readProcess from process package, you get a String, not ByteString.
21:58:14 <dsal> Yeah, so that's not appropriate for what you're doing.
21:58:23 <jchia_> Then I'm stuck, because IDK how I'm supposed to get back the original ByteString
21:58:52 <dsal> Here's an example that will give you an arbitrary value:  https://github.com/dustin/gopro/blob/master/src/FFMPeg.hs#L10-L12
22:00:31 <samiamsam> jchia_: you need to use a different primitive, one that doesn't decode the stream
22:00:41 <samiamsam> a different primitive to read from the stream
22:01:09 <jchia_> samiamsam: OK, I supposed I can still use createProcess and deal with the Handle myself.
22:01:32 <samiamsam> jchia_: you might want to look into an alternative to 'process' to save yourself some time
22:01:52 <jchia_> samiamsam: E.g.?
22:02:06 <samiamsam> typed-process
22:02:34 <samiamsam> certainly supports what you need
22:02:50 <samiamsam> there are probably a lot of alternatives i don't know about
22:02:53 <dsal> jchia_: The code I've shown above processes stdout as a ByteString and gives you the value type you want.
22:02:58 <dsal> @package typed-process
22:02:58 <lambdabot> https://hackage.haskell.org/package/typed-process
22:03:26 <jchia_> OK, I've heard of that, never seriously read it. I'll check it out
22:03:42 <dsal> I don't know typed-process.  Looks a lot more complicated than my little three lines of code.  :)
22:05:18 <samiamsam> dsal: you imported System.Process
22:05:34 <dsal> Yes.  That was the original thing in question.
22:06:46 <samiamsam> you're saying that calling typed-process looks more complicated than System.Process?
22:06:52 <samiamsam> s/calling//
22:07:48 <dsal> Yeah.  If all I want is to make a subprocess call and process its output into a value of a known type, it's pretty simple.
22:08:29 <samiamsam> i think System.Process.Typed is still simpler though, not more complicated
22:08:47 <samiamsam> check out the dateConfig example on https://hackage.haskell.org/package/typed-process
22:09:04 <samiamsam> anyway, going afk, bye
22:10:04 <dsal> Yeah, I was reading the readme.
22:26:48 <adam_wespiser> use System.Process, or even Turtle, which should have a shell function for that
22:27:02 <gcoakes[m]> Hey, does anyone have any resources on doing account confirmation from a backend perspective? I know this isn't particularly a Haskell question, but I'm implementing it in haskell, so I hope someone here can help me.
22:28:20 <ja> gcoakes[m]: are you using any sort of database?
22:29:46 <gcoakes[m]> Yes, postgresql. I think I understand that. I'm using Servant with Persistent. I just can't find any resources which describe the proper api flow for something like that.
22:30:07 * gcoakes[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/BdetKQUXUkyVdcpwhLWtNYNK >
22:30:24 <gcoakes[m]> That's the Servant API that I'm planning on implementing.
22:30:43 <adam_wespiser> Servant has good support for Auth
22:32:21 <gcoakes[m]> I just realized that login should be returning the JWT, not NoContent.
22:33:20 <gcoakes[m]> adam_wespiser: Yeah, I've been playing around with it. I've gotten BasicAuth to work well in a separate toy application, but now I'm planning on using a form to do login.
22:34:15 <adam_wespiser> yea, Authorization returns the JWT, then every route that is protected by authentication accepts a JWT header parameter
22:35:33 <adam_wespiser> The best guide I can find is this: https://docs.servant.dev/en/stable/tutorial/Authentication.html .
22:49:54 <hari_> looking to compile haskell to js. What options do I have?
22:50:09 <gcoakes[m]> ghcjs?
22:53:58 <hari_> yes ghcjs is the most common recommendation that I found. How is it different from haste?
22:57:20 <dsal> hari_: I've heard of ghcjs.  Does that count?
22:58:05 <dsal> haste's most recent blog post is 2016...
