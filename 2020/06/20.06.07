00:38:04 <kajman> hi
00:38:15 <kajman> does anyone here use haskell-ide-engine?
00:38:37 <kajman> im currently using vim+hie as my ide and I'm missing two features
00:38:55 <kajman> documentation and jumping to source of other functions
00:39:44 <kajman> this would be great for the libraries I use, I find myself wasting a lot of time again and again looking up documentation online
00:50:48 * hackage egison 4.0.2 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-4.0.2 (SatoshiEgi)
00:54:50 <kajman> is anyone here?
00:55:53 <rsoeldner> kajman, yes, but not using haskell-ide-engine
00:56:08 <kajman> what do you use normally?
00:56:32 <kajman> i'm very new to haskell and do not know the tooling that well
00:56:45 <rsoeldner> kajman, I'm with vim + ghcide for the past 3 month and happy with it so far
00:58:16 <kajman> does it have the jump to source feature for dependent libraries?
00:58:33 <kajman> or at least showing the docstrings of imported methods?
00:59:29 <maralorn> kajman:  hie will be superseeded by haskell-language-server in a few months. haskell-language-server does not have a release yet but it is based in part on ghcide.
00:59:52 <rsoeldner> this is something you have to check https://github.com/digital-asset/ghcide , type signatures works at least most of the time
01:00:25 <maralorn> ghcide right now can show docstrings but go to definition only works inside your project.
01:03:49 <kajman> ok, seems i did configred this yesterday but maybe forgot to restart vim, this is how it looks like right now: https://imgur.com/ieMnvxS.png
01:04:34 <kajman> so actually I'm just missing jump to source of external libraries missing, is this even possible right now in haskell?
01:04:54 <kajman> i stumbled upon some discussion saying that this is not supported right now
01:05:02 <kajman> but I find it a little hard to believe
01:29:23 <maralorn> kajman: The Haskell tooling was substellar for a long time. So yeah, it is quite likely that there is no go to source for external dependencies in any lsp implementation right now.
01:29:47 <c_wraith> it's pretty rare to still have source around after installing a third party library, too
01:29:51 <c_wraith> that has an impact.
01:30:36 <maralorn> c_wraith: Well, if it has the haddocks for it, it should also have the source for it.
01:31:27 <c_wraith> if it built html docs with source.  It can keep the docs around without building html docs.  You can build html docs without building hyperlinked source.
01:31:35 <maralorn> c_wraith: But how does ghc actually typecheck? Does it typecheck against the source of a library or against it's so files?
01:31:44 <c_wraith> it checks against .hi files
01:31:51 <c_wraith> (haskell interface)
01:33:10 <c_wraith> those can also include the haddock contents for the ghci :doc command
01:33:37 <maralorn> Ah, okay.
01:43:28 <kajman> thanks guys, i'll stick to hie for now and wait for hls to have a release 
01:43:46 <kajman> i should be mostly fine with docs working finally
01:57:49 * hackage egison 4.0.3 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-4.0.3 (SatoshiEgi)
02:15:21 <turion> Assume I have some GADT corresponding to a syntax tree:
02:15:22 <turion> data AST a where
02:15:22 <turion>   Val :: a -> AST a
02:15:22 <turion>   App :: AST (a -> b) -> AST a -> AST b
02:15:22 <turion>  (...)
02:15:30 <turion> Now I want to randomly generate syntax trees
02:15:43 <turion> (Let's say with quickcheck or smallcheck)
02:18:08 <turion> I can write an instance Arbitrary a => Arbitrary (Ast a) that generates Vals
02:18:45 <turion> But how do I randomly generate Apps?
02:20:19 <turion> I can somehow work with existential types and go through a bunch of different selected types I like, but the choice of types will heavily restrict the shape of ASTs I build
02:21:01 <turion> e.g. If I choose by hand only Int -> Bool as a possible function type, I'll never build ASTs corresponding to higher order functions
02:34:18 * hackage FSM 1.0.0 - Basic concepts of finite state machines.  https://hackage.haskell.org/package/FSM-1.0.0 (KidKoala)
03:17:24 <maralorn> turion: Well for App you would need to pick a type CoArbitrary Type a at random right? That sounds like something without a general solution.
03:23:43 <maralorn> turion: You could do something like `generatedApp :: forall a b. (CoArbitrary a, Arbitrary b)=> Gen (AST b), generatedApp = do {atob <- arbitrary; a <- arbitrary @a ; pure $ App (Val atob) (Val a)}]`. And then you do `oneOf [generatedApp @Int, generatedApp @String, â€¦] for the Types you want to test.
03:24:26 <maralorn> Of course you need to throw quite a few extensions at it to make it compile.
03:26:33 <maralorn> turion: Wait, I used CoArbitrary wrong there.
03:28:49 * hackage shake-plus 0.1.6.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.6.0 (locallycompact)
03:29:06 <maralorn> Better: forall a b. (Fun a b, Arbitrary b), and atob <- appylFun <$> arbitrary
03:29:35 <Yuuri> I'm writing a megaparsec-based PL parser. Is it recommented to add a separate tokenizing stage?
03:29:35 <mlugg> In GHC, why is RealWorld primitive? Given that it's only ever used to parameterise State#, I don't see why it can't just be a normal uninhabited type (`data RealWorld`). The documentation for the type is somewhat unhelpful, as it refers to a nonexistent `ptrArg` (see https://gitlab.haskell.org/ghc/ghc/issues/13146)
04:07:41 <kuribas> is it possible emacs is dropping code lines?  It's the second time I opened a buffer to find a big chunk of code missing.
04:10:04 <kuribas> Even if I quit emacs without saving, shouldn't it have made a backup?
04:25:31 <merijn> mlugg: Well, what would it be if not primitive?
04:27:04 <mlugg> merijn, why not just an empty ADT (hs2010), given that you never actually have to manipulate any value ::RealWorld?
04:27:49 * hackage exact-real 0.12.4 - Exact real arithmetic  https://hackage.haskell.org/package/exact-real-0.12.4 (jophish)
04:28:34 <merijn> mlugg: How would GHC know it does need to generate the code for passing that value around?
04:29:13 <merijn> Function operating on you "data RealWorld" would still need to have code for passing around the boxed "RealWorld" value
04:31:26 <mlugg> I thought the point of RealWorld is you never actually *have* one of them, since it's just used to parameterise State#?
04:35:53 <merijn> mlugg: That is rather orthogonal to what I said, though
04:36:42 <merijn> mlugg: "data Void" doesn't have any constructors, but expressions of type Void still exist and if you write a function that takes Void as argument the compiler will generate code to handle that function argument.
04:37:10 <merijn> What we want is for GHC to be able to avoid generating any code for handling/passing the RealWorld argument
04:37:22 <mlugg> ohhh, i see
04:37:24 <merijn> The only way to do that is to wire the type into the compiler
04:37:45 <merijn> Well, that or "build a special case for a library defined type into the compiler" which is basically the same, but worse
04:39:01 <mlugg> Okay, that makes sense - it's basically to make sure you don't try and use it as a normal type
04:39:04 <mlugg> Thanks
04:45:38 * ski . o O ( `GHC.Types.IO :: (State# RealWorld -> (# State# RealWorld,a #)) -> IO a' )
04:53:29 <timCF> Hello! Any crypto experts here? I'm pretty much noob in math, can you help me to choose HashAlgorithm from Cryptonite package which is the best as default for my package (fastest from list of secure algorithms - don't have collisions etc) https://www.stackage.org/haddock/lts-15.15/cryptonite-0.26/Crypto-Hash-Algorithms.html#t:HashAlgorithm
04:55:21 <merijn> timCF: What do you plan to use it for?
04:59:52 <timCF> just have a hash of data - I'm doing some kind of class similar to Show which will be able to show in logs some data, with GHC.Generic deriving for complex types, similar to Show. But with one difference - instead of some types like Text, String, ByteString, Integer etc it will show harmless hash of it, which will prevent leaking of sensitive data
04:59:53 <timCF> and credentials to logs in every possible scenario
05:00:57 <timCF> It will accept algorithm and hash as argument, but I want to have utility function with default one to simplify usage in most cases
05:01:14 <merijn> timCF: In that case almost all of them will be fine, but I'd probably default to sha256
05:02:17 <merijn> timCF: The thread model to worry about with cryptographic hashes is "how bad is it if someone finds a colliding hash?"
05:02:47 <merijn> timCF: They're all effectively irreversible, but for some it's easier to find text/input that hashes to the same value
05:02:56 <timCF> merijn cool, thanks! Can you give some advice about salt? How many bytes is considered safe there, to give enough randomness to small types like Word8 with this salt
05:03:07 <merijn> timCF: But in your case that's really a non issue, since you're using the hash to output stuff, not validating anything
05:03:23 <merijn> No clue, tbh
05:04:03 <merijn> otoh even without salt it should be fine, unless you're worried that someone knows 1) what specific type was being hashed and 2) is going to brute-force that type and 3) this has actualy negative consequences
05:06:21 <timCF> merijn collisions are not really issues there, because it's just to hide real values in logs. And I'm using hashes, not just "SECRET" placeholder to give ability for people who have access to data (for example devops) still debug incidents and find relevant rows in database (Postgres supports some crypto functions)
05:07:30 <timCF> merijn Yeah, I see what do you mean - if we have very small type, for example Bool, there still will be just 2 possible hashes with any kind of salt
05:07:54 <merijn> timCF: Well, you get 2 * number of salts hashes
05:22:19 * hackage egison-tutorial 4.0.1 - A tutorial program for the Egison programming language  https://hackage.haskell.org/package/egison-tutorial-4.0.1 (SatoshiEgi)
05:27:35 <xerox_> > let xs = [ go i | i <- [1..5] ]; go 1 = 1; go i = xs !! (i-1); in xs
05:27:38 <lambdabot>  [1,*Exception: <<loop>>
05:27:45 <xerox_> why is this?
05:29:21 <merijn> xerox_: lists are zero indexed
05:29:45 <merijn> xerox_: So the 2nd element "go 2" will refer to index "2-1" aka 1 aka itself
05:30:05 <merijn> xerox_: Also, even if that definition works the performance will be *abysmal*
05:30:09 <merijn> It's quadratic
05:30:09 <xerox_> (:
05:36:14 <ski> you could try an array ?
05:36:30 <merijn> ski: That won't solve his exception, though :p
05:36:44 <xerox_> yeah the exception makes sense I confused myself by 1-indexing, appreciate it
05:37:20 <merijn> xerox_: Anyway, lists are linked lists, so random access via !! has terrible performance
05:37:23 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
05:37:24 <lambdabot>  .L.hs:168:1: error:
05:37:25 <lambdabot>      Duplicate type signatures for â€˜tabulateâ€™
05:37:25 <lambdabot>      at .L.hs:160:1-8
05:37:42 <ski> @type L.tabulate
05:37:43 <lambdabot> Ix i => (i, i) -> (i -> e) -> Array i e
05:37:45 <ski> oh
05:38:42 <ski> > let xs = L.tabulate (1,5) $ \i -> go i; go 1 = 1; go i = xs ! (i-1) in xs
05:38:44 <lambdabot>  array (1,5) [(1,1),(2,1),(3,1),(4,1),(5,1)]
05:38:57 <ski> merijn : seems to work, to me .. :)
05:39:25 <merijn> ski: Because you implemented something different from the original code :)
05:39:46 <ski> yes :)
05:39:49 <xerox_> the indexing being customizable helped
05:40:07 <ski> (i switched to arrays, and set the index range to what seemed to be desirable)
05:41:30 <ski> > let ((!) . L.tabulate (1,5) -> go) = \case 1 -> 1; i -> go (i-1) in go `map` [1 .. 5]
05:41:32 <lambdabot>  [1,1,1,1,1]
05:45:46 <ski> (but yes, i figured it being customizable could help, otherwise i'd adjusted to `(0,4)')
05:58:12 <nut> is it common to write MonadIO instance for some random 3rd party library type?
05:58:46 <nut> I'm using Scotty, and I need to run IO actions inside the ScottyM type
06:07:57 <ski> apparently `type ScottyM = ScottyT Text IO', where `ScottyT e m a' happens to be currently implemented as `State (ScottyState e m) a' (NB : no `StateT (..) m a' !)
06:09:01 <ski> `ScottyState e m' involves `ErrorHandler e m', which `ActionT e m', where `ActionT e' is the only `MonadTrans' instance i can see, on a quick look
06:09:25 <ski> s/which/which involves/
06:11:01 <ski> nut : if you actually need to run `IO' when running `ScottyM' (or `ScottyT e m', even), i think you're out of luck .. but perhaps the `m' in the state involves `m'-actions which will be run later, which you maybe could have use of ?
06:11:29 <ski> (mind, i don't really follow the design of `scotty' ..)
06:12:12 <vaibhavsagar> nut: IIRC ActionT is a monad transformer whereas ScottyT is not, could you do what you want inside ActionT?
06:12:33 <nut> vaibhavsagar, I can't run it inside ActionT
06:13:15 <nut> My app needs to scan a folder for changes and pass this to all routes
06:14:18 * hackage pandoc-plot 0.6.0.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.6.0.0 (LaurentRDC)
06:15:14 <vaibhavsagar> nut: could you manually construct a ScottyM value that contains the IO action you want to perform inside it?
06:15:20 <ski> if `ScottyT' used `StateT' instead of `State', i guess you could make it do what you wanted (?)
06:16:02 <ski> mm, i suppose if you could stage things as `ScottyM (IO T)', that's work ?
06:16:04 <nut> vaibhavsagar, seems like a possible idea..let me try
06:16:45 <ski> (but depending on what you want to do, that may be unreasonable)
06:17:35 <ski> hm, do you want to use `IO' (and `ScottyM' ?) as monads, or does using them as idioms suffice ?
06:18:28 * ski . o O ( `ApplicativeIO' )
06:18:42 <nut> ski, I don't know. What I want to liftIO scanfolder
06:18:53 <nut> be able to run liftIO scanfoler
06:19:01 <ski> @hoogle scanFolder
06:19:02 <lambdabot> No results found
06:19:14 <ski> and do what with the result ?
06:19:14 <nut> scanfolder is my own function
06:19:21 <nut> it's just listDirectory
06:19:45 <nut> with the results, i will use addroute to generate routes
06:19:46 <ski> just aggregate it in the result, somehow ? or make further decisions about what `IO' to perform, based on it ?
06:22:04 <nut> addroute :: StdMethod -> RoutePattern -> ActionM () -> ScottyM () 
06:22:18 <nut> addroute is a ScottyM
06:23:14 <ski> are you wanting to pass things based on the result of `scanFolder' to `addroute' ?
06:23:41 <nut> yes, sorry i have to run
06:23:49 <nut> i posted a question in stackoverflow
06:24:06 <nut> if you have ideas, i appreciate if you could answer there
06:24:09 <nut> thanks !
06:24:28 <ski> anyway, it looks like you can incorporate `IO'-actions in `ActionM' ?
06:25:23 <ski> np, hope you can manage to do what you wanted
06:27:23 <nut> https://stackoverflow.com/questions/62245813/how-to-run-io-inside-scottym
06:44:55 <tt> Hello. I want to take a function that takes a string -> enum. I have many enums. For example, `Choices = A | B | C | D deriving (Enum, Show, Read, Eq )` and `Answers = E | F| G deriving (Enum, Show Read, Eq)`. I want a function something like f ("A") = A and f("E") = E. Can you find this `f` for me? 
06:47:11 <ski> tt : what will you do with the result of calling this function ?
06:56:59 <whataday> this is very like a scheme question
06:57:23 <whataday> a symbol to string
06:57:29 <ski> unfortunately, it seems they left the webchat
06:57:41 <thebnq> isn't f just = read
06:57:44 <phadej> sclv: ping
06:57:56 <ski> depends, thebnq
06:58:59 <whataday> I would make them as a Map
06:59:19 <ski> make what a `Map' ?
07:00:12 <ski> (something like `DMap MyEnums ReadS' ?)
07:00:13 <whataday> Map[("A",A)...]
07:00:47 <ski> the problem is that `A',`B',`C',`D' doesn't have the same type as `E',`F',`G'
07:00:55 <whataday> data Alphbet = A | B | C ...
07:01:06 <tt> shoot disconnected 
07:01:19 <ski> (but `DMap' can handle such things, the type of the key determining the type of the corresponding value)
07:01:24 <ski> re tt
07:01:30 <ski> <ski> tt : what will you do with the result of calling this function ?
07:02:33 <tt> @ski
07:02:33 <lambdabot> Maybe you meant: wiki src ask
07:03:05 <tt> Uhmmm  I will use the enums to handle some database stuff like making records. 
07:03:26 <tt> ski But I suppose the output of this function has to be of the `read` type class
07:04:10 <ski> tt : is the caller of `f' intended to know, for each specific call, whether it's expecting a `Choices' or an `Answers' ?
07:05:17 <ski> or do you intend to call `f' where both a `Choices' and an `Answers' could be expected, and then want `f' to tell you which of those two (if any) it got ?
07:06:53 <tt> ski hmmmmm. good question. Im not too sure yet obviously. But the current function which I am modifying deals with returning a generic type `a`
07:07:47 <tt> So I think its inferred when I make a record. But, the function really just returns a generic 
07:07:51 <tt> type
07:08:02 <ski> (.. also, i'm wondering why you're naming `Choices' and `Answers' in plural, when it seems each particular value represents a singular choice/answer ? .. but perhaps that's an incorrect perception, due to you being a bit vague about the particular alternatives ?)
07:08:48 <tt> ski Actually those are just examples I made up. Yea `Choice` and `Answer` is what I meant.
07:09:21 <ski> tt : well, if you have something like `f :: Read a => String -> Maybe a' or perhaps using some other type class than `Read', then the caller of `f' will determine which actual type `a' (here `Choices' or `Answers') to expect, and so `f' will try to parse only one or the other, in each particular sitation/call
07:09:26 <ski> ok
07:10:25 <ski> if you really want the type `a' not to be determined by the caller of `f', but by `f' itself (after seeing its input `String', say), that can also be done ..
07:10:53 <tt> Ooo how would the second case be done?
07:11:21 <ski> however, if you're just wanting to parse either `Choice' or `Answer', it may in such case be simpler just to have the return type be `Maybe (Either Choice Answer)', or perhaps using a custom data type instead of `Either Choice Answer'
07:12:31 <ski> tt : the second option would involve something called "existentials" .. however, how you do that would depend quite a bit on how you intend to call `f' / use its result .. hence my initial question
07:13:52 <ski> note that having a function that can return a value of "any type, determined by the function" is, on its own, fairly useless. since if you know nothing about this type, then you can do nothing with the value of this type
07:14:37 <ski> you need to have some kind of operations you can do with the values of unknown type, for that approach to be useful
07:14:55 <tt> ok the second sounds a bit too involved for my use case. 
07:15:07 <ski> yea .. i was suspecting so
07:15:56 <ski> often, when people first hear of existentials, they tend to reach for them much more often than warranted. they have their pains, can often be overkill
07:17:13 <tt> ok `f :: Read a => String -> Maybe a'. I know the form seems quite simple. But what I really want is sort of a getter for the enum type without needing to enumerate them. 
07:17:16 <tt> readEnum :: (Enum a,Show a,Read a) => String -> Maybe areadEnum = (`lookup` map (showEnum &&& id) [toEnum 0 ..]
07:17:20 <ski> tt : so, i'd suggest either type class overloading, or else returning a value of a type which includes alternatives from both `Choice' and `Answer'
07:17:42 <ski> or (a variant of the first), simply to define two versions of `f', one for `Choice', the other for `Answer'
07:19:52 <tt> ski Yea im not going to use Either  where both types can be used because that would mean I have to change a lot of types underneath all my records. 
07:20:04 <ski> hmm, i suppose possibly you could also derive `Bounded', for that, and use `minBound' and `maxBound' ?
07:21:02 <ski> @hoogle Read a => String -> Maybe a
07:21:03 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
07:21:03 <lambdabot> Test.Tasty.Options safeRead :: Read a => String -> Maybe a
07:21:03 <lambdabot> Safe readMay :: Read a => String -> Maybe a
07:21:51 <ski> tt : could you use `readMaybe' instead of that `readEnum' ?
07:22:45 <ski> (btw, i dunno what you mean by "getter for the enum type")
07:24:41 <tt> ski Bounded sounds like one possible solution. Because I use `readEnum` for all my enums. It would be an issue if I defined infinite enum. So If I use `readEnum` it would be super slow
07:26:26 <ski> tt : and why not `readMaybe' ?
07:28:36 <tt> omg ski 
07:28:45 <tt> `readMaybe` yes `readMaybe`
07:28:52 <tt> That seems to work! 
07:28:59 <tt> Thank you! 
07:29:01 * ski smiles
08:03:48 * hackage musicw 0.3.5 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.5 (dktr0)
08:27:59 <jon1> quit
08:28:37 <jon1> trying and failing to quit weechat :D
08:31:22 <blackdog> jon1: :q!, pretty sure
08:31:30 <jon1> :q!
08:31:33 <blackdog> the second hardest problem in computer science
08:31:39 <jon1> not vim!
08:31:46 <blackdog> :)
08:38:07 <merijn> Ok, my brain is fried, help me figure out which data structure I want.
08:38:38 <merijn> I've got key value pairs (kinda?) and I wanna be able to keep a subset of the keys and then get the one with the smallest value from that subset
08:39:42 <merijn> Actually, I want "the key corresponding to the smallest value of that subset", else Map would already suffice
08:43:46 <fendor_> merijn, are the values important? How about a priority queue where the values are the priority?
08:44:04 <merijn> fendor_: Can't do subset on priority queue, though
08:45:13 <fendor_> does the subset of keys have any properties that might be helpful?
08:45:15 <blackdog> do you also need to keep the non-minimum values around for some other purpose?
08:45:24 <merijn> So basically I have "Map Key Value" -> take subset of keys to get new "Map Key Value" then get the key with the smallest value from the map. I guess the easiest way is to indeed use map and then "sortOn snd . M.toList"
08:45:46 <merijn> blackdog: No
08:45:54 <dmwit> How is the subset specified?
08:45:55 <blackdog> then why not keep the property around on insertion?
08:46:12 <merijn> dmwit: Just through having a "Set Key" (or whatever)
08:46:25 <blackdog> on collision, check if it's the smallest yet-seen, if so, insert else do nothing
08:46:43 <merijn> blackdog: The problem is I need to project like this from the original Map a bunch of times
08:48:45 <ChaiTRex> merijn: Do you not control how the original Map is constructed?
08:48:56 <blackdog> could do that once and reuse it, i guess. but yeah, if the input is a Map k v, and it might change throughout the course of the computation, can't do much better than the postprocessing sort step
08:48:59 <merijn> ChaiTRex: It doesn't have to be a Map it can be whatever
08:49:19 <merijn> ChaiTRex: In fact that's the entire question, how do I easily do that :p
08:49:28 <dmwit> merijn: The subsetting-operation is already the asymptotic bottleneck, not the maximum.
08:49:31 <dmwit> So stop thinking so hard.
08:49:41 <merijn> dmwit: It's not about efficiency
08:49:55 <dmwit> Oh? What's it about?
08:49:56 <merijn> dmwit: It's about me not wanting to write cumbersome code if someone has a convenient way to do it
08:50:09 <merijn> The efficiency is, frankly, irrelevant
08:51:08 <blackdog> oh hang on, you mean you need to project with different subsets of keys. now i guet it.
08:51:41 <dmwit> merijn: foldMapWithKey (\k v -> Max (Arg k v)) (restrictKeys kvs subset)
08:52:35 <dmwit> err
08:52:38 <dmwit> Arg v k, I guess
08:52:43 <merijn> What's Arg?
08:52:57 <dmwit> data Arg a b = Arg a b; instance Ord a => Ord (Arg a b)
08:53:17 <dmwit> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Semigroup.html#t:Arg
08:53:18 <merijn> I guess that works
08:53:22 <merijn> oh
08:53:31 <merijn> A Semigroup I didn't know yet :>
09:02:19 * hackage resourcet 1.2.4.1 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.2.4.1 (MichaelSnoyman)
09:11:04 <sclv> phadej: pong
09:11:10 * pong
09:11:21 <phadej> sclv: did you get my mail reply?
09:11:25 <sclv> Ya
09:11:31 <phadej> ok, nothing else then :)
09:35:23 <kamek> is there a cleaner way to do this ? https://github.com/kamek-pf/ntfd/blob/master/app/Modules/Mpd.hs#L32
09:35:32 <kamek> and avoid the _ -> pure ()
09:35:48 <kamek> branch, I'm doing this sort of match often
09:37:31 <c_wraith> :t traverse_ . traverse_
09:37:32 <lambdabot> (Applicative f, Foldable t1, Foldable t2) => (a -> f b) -> t1 (t2 a) -> f ()
09:37:46 <c_wraith> kamek: 
09:38:33 <kamek> nice, thanks c_wraith !
09:59:31 <freeman42x[m]> could anyone help me with the following haskell / nix issue? https://gist.github.com/razvan-flavius-panda/e7c90e90e8c23d6a046eec9202a2b701
10:05:49 * hackage secp256k1-haskell 0.2.3 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.2.3 (jprupp)
10:26:49 * hackage path-extensions 0.0.1.0 - Enumeration of common filetype extensions for use with the path library.  https://hackage.haskell.org/package/path-extensions-0.0.1.0 (locallycompact)
10:34:54 <maralorn> Is there something like `typename :: a => String`, withe `typename @MyType = "MyType"`?
10:36:51 <solonarv> :t show . typeOf
10:36:53 <lambdabot> Typeable a => a -> String
10:37:04 <solonarv> > show (typeOf False)
10:37:06 <lambdabot>  "Bool"
10:37:17 <solonarv> maralorn: that is what you are looking for?
10:38:06 <maralorn> solonarv: Yeah, that will probably work.
10:39:01 <maralorn> Does Typeable have implict instances?
10:40:33 <monochrom> No. But you can always "deriving Typeable".
10:43:28 <maralorn> Okay
11:10:51 <jcowan> I am confused about how the sequence function works.  Let us say for concreteness that I have [Maybe a].  If all the Maybes are Justs, then I will get Just [a].  But what do I get if one of the list elements is Nothing?
11:11:40 <merijn> jcowan: Well, what does you're intuition say?
11:12:00 <merijn> And have you tried if your intuition is right? :)
11:15:54 <jcowan> My intuition says I get Nothing.
11:16:47 <merijn> Easy enough to test ;)
11:16:51 <frdg> am I correct to say that the state of a parser represents the rest of what needs to be parsed? 
11:17:14 <jcowan> I always forget how to use the bot
11:17:53 <jcowan> But supposing my intuition is correct, my intuition breaks down when going from Maybe to Either.
11:18:02 <jcowan> Left, after all, has to have a payload.
11:18:03 <maralorn> Does anyone have a clue, what could lead optics-th to make me this instance "LabelOptic "$sel:mode:SortPosition" A_Lens (SortPosition_a1V3m t_a1V3r) (SortPosition_a1V3m t_a1V3r) a_a1V3s b_a1V3t" my problem is the label. It should be just "mode" which is the field name, not "$sel:mode:SortPosition".
11:18:21 <maralorn> This broke during refactoring and I have no clue how.
11:22:10 <merijn> jcowan: Basically, sequence is equivalent to: "sequence (x:xs) = do { x' <- x; xs' <- sequence xs; return (x' : xs') }
11:22:58 <merijn> jcowan: In other words, you're just stuffing every value through >>= (or <*>, but I find the intuition easier using >>=) and then reconstructing the list
11:23:30 <merijn> jcowan: So for Either it's just going to return "the first Left you encounter", like >>= would
11:23:57 <jcowan> Okay, thanks, that makes sense.  
11:24:16 <merijn> (the Applicative version would be something like: "sequence (x:xs) = (:) <$> x <*> sequence xs"
11:24:23 <merijn> )
11:25:47 * jcowan nods
11:37:09 <ski> jcowan : `sequence' executes the actions in a specific chosen traversal order, which for lists is the usual left-to-right. and for `Either', the idiom / monad instance will give you (short-circuit to) the first exception, if any
11:38:14 <ski> however, there's a `Validation' data type, which will instead collect all the exceptions, rather than giving just the first one. but it isn't a monad, only an idiom
11:39:46 <ski> @hackage validation
11:39:46 <lambdabot> https://hackage.haskell.org/package/validation
11:39:50 <merijn> Validation is underrated
11:40:30 <merijn> ski: Why not Ed's either package?
11:42:59 <ski> what's the difference in what it provides ?
11:43:17 <merijn> No clue, but either is in far wider use, afaict
11:43:31 <ski> ok
11:48:31 <MarcelineVQ> one is backed by auzzies fwiw
11:53:37 <Boarders> if I wanted to write a generic interface to lists but with different strictness at different types
11:53:40 <Boarders> I could do something like
11:53:50 <Boarders> class List a where; data MyList a
11:53:57 <Boarders> but then I can't write generic functions on that
11:54:04 <Boarders> I would be able to if you could attach patterns to typeclasses
11:54:10 <Boarders> is there any way to fake that in Haskell?
11:54:33 <merijn> This sounds very questionable, tbh >.>
11:54:47 <merijn> What are you trying to actually do?
11:58:03 <Boarders> why does it sound very questionable
11:58:13 <Boarders> the idea is just that at some types you might want to have different strictness
11:58:29 <Boarders> e.g. you might want a type to be strict for Int arguments and non-strict for String arguments or etc
11:58:58 <wavemode_> why do you say you can't attach generic functions to that? all you need to define is a generic head and tail
11:59:22 <wavemode_> and I guess null?
11:59:32 <Boarders> well because I want to be able to generically pattern match on the different representations?
11:59:46 <Boarders> and I don't believe I can have patterns in a type class
11:59:56 <Boarders> like if I had
12:00:11 <Boarders> data IntList = Nil | Cons !Int IntList
12:00:22 <Boarders> data StringList = Nil Cons String StringList
12:00:24 <solonarv> but you can attach constructor / deconstructor functions, and write top-level type synonyms that use those
12:00:30 <Boarders> (not saying this is a good idea for list)
12:01:23 <Boarders> solonarv, ay maybe that is the way
12:01:27 <Boarders> ah*
12:01:50 <solonarv> e.g. 'class List l e where cons :: e -> l -> l; nil :: l; uncons :: l -> Maybe (e,l)'
12:02:18 <Boarders> merijn: it is not that unreasonable: https://gitlab.haskell.org/ghc/ghc/issues/8583
12:02:46 <solonarv> and then 'pattern Nil <- (uncons -> Nothing) where Nil = nil ; pattern Cons x xs <- (uncons -> Just (x,xs)) where Cons x xs = cons x xs'
12:03:39 <merijn> Boarders: I didn't say it's unreasonable, but any implementation of that in Haskell is going to be rather questionable in terms of usability
12:38:14 <ilyakooo0> hello
12:41:58 <koz_> ilyakooo0: What's up?
12:42:45 <infinity0> who should i contact about infrastructure issues? the mailing list server is being arsy about my email address, i don't have DKIM set up on my domain
12:43:12 <maerwald> infinity0: theres an irc channel
12:44:54 <infinity0> found it, thanks
12:48:12 <infinity0> on another topic, is there a process for updating dead packages e.g. https://hackage.haskell.org/package/readline
12:48:19 * hackage hledger-lib 1.18 - A reusable library providing the core functionality of hledger  https://hackage.haskell.org/package/hledger-lib-1.18 (SimonMichael)
12:48:22 <infinity0> the uploader's last activity on hackage was from 2016
12:48:46 <infinity0> it has a NULL dereference i have a fix for, otherwise it's quite handy 
12:49:19 * hackage hledger-web 1.18, hledger-ui 1.18, hledger 1.18 (SimonMichael): https://qbin.io/judge-safari-lqo4
12:49:35 <merijn> infinity0: Yes, there's a takeover procedure
12:49:45 <c_wraith> that one isn't a candidate for takeover, though
12:49:48 <c_wraith> it's a core library
12:49:53 <c_wraith> use the libraries mailing list
12:50:03 <merijn> readline is a core library?
12:50:07 <merijn> I thought haskeline was
12:50:23 <c_wraith> the maintainer is listed as "libraries@haskell.org"
12:50:48 <infinity0> it's not in my standard ghc installation, i assumed it was out-of-date metadata since the last upload was 2015
12:50:50 <merijn> infinity0: I'd just replace readline with haskeline, tbh
12:50:55 <infinity0> i've emailed both the list and him anyway
12:51:04 <merijn> (if an option)
12:51:12 <infinity0> oh, is that what everyone uses these days
12:51:44 <merijn> infinity0: That's what ghci uses, to the best of my knowledge
12:52:03 <maerwald> infinity0: you can request an NMU (non-maintainer-update)
12:52:13 <maerwald> https://github.com/haskell-infra/hackage-trustees/blob/master/policy.md#policyprocedure-2
12:52:14 <infinity0> huh could've fooled me, ctrl-r in ghc shows up the same "reverse-search" thingy as readline
12:52:38 <merijn> infinity0: I might be making that up
12:53:17 <infinity0> well it's certainly possible it duplicated the functionality down to that level of detail
12:54:29 <merijn> infinity0: haskeline certainly allows you to implement custom completion/history operations
12:54:56 <merijn> infinity0: I do tab completions from the SQLite database my code runs against
12:55:26 <merijn> At the very least haskeline is a git submodule in the ghc tree, so I didn't misremember it being a boot package
12:56:49 <merijn> infinity0: Anyway, I don't know your circumstances and the cost of switching, but haskeline is pretty actively maintained, so in that sense it's probably more future proof
12:57:04 <infinity0> cool. this is just a personal pet project so far so i'm pretty flexible
12:57:19 <infinity0> shame to leave a NULL deref floating around in hackage though :)
12:57:24 <merijn> infinity0: Oh, actually the haskeline readme does, in fact, mention incremental history search :)
12:57:31 <wavemode_> create a fork?
12:57:33 <merijn> infinity0: Oh, certainly shoot an email to libraries@ too
12:57:48 <monochrom> Bugs want to be fixed. :)
12:57:56 <merijn> infinity0: If the fix is easy, then it should be fixed, but that's orthogonal to what you actually use ;)
12:58:04 <infinity0> yeah
13:36:53 <Boarders> What is the fastest balanced binary tree for insertion and membership in Haskell?
13:36:59 <Boarders> Using Ord
13:37:46 <monochrom> Data.Map.Strict
13:38:13 <monochrom> or Data.Set if you have just elements rather than key->value
13:38:24 <Boarders> I mean theoretically is the Set version faster than other data structures
13:38:49 <monochrom> theoretically the fastest, i.e., logarithmic.
13:38:57 <Boarders> Like splay trees or B-trees or RB trees or etc
13:39:05 <monochrom> yes
13:39:07 <Boarders> They are all logarithmic
13:39:18 <monochrom> They are all the fastest.
13:39:22 <Boarders> I am asking which of those is fastest for those ops
13:39:57 <monochrom> I regret getting into this.
13:41:24 <Boarders> I mean there is a difference between RB trees and B trees so I was wondering if someone knew what is state of the art for these ops only
13:41:31 <Boarders> Not exactly a weird question
13:43:15 <berndl> Best way to find out is to benchmark.
13:43:27 <Heffalump> Boarders: I guess your use of "theoretically" confuses the question. Clearly constant factors do matter, but I expect the only theoretical analysis is that they are all logarithmic. What you need is some empirical evidence of actual performance.
13:43:31 <monochrom> Then you can safely consider me incompetent and shouldn't speak out in the first place.
13:43:39 <Rembane> Boarders: If you want the theory the functional data structures book is the best. 
13:45:25 <Rembane> Boarders: https://www.amazon.com/Purely-Functional-Data-Structures-Okasaki/dp/0521663504
14:00:19 * hackage tdlib-gen 0.3.0 - Codegen for TDLib  https://hackage.haskell.org/package/tdlib-gen-0.3.0 (Poscat)
14:24:35 <koz_> :t try
14:24:36 <lambdabot> Exception e => IO a -> IO (Either e a)
14:28:23 <koz_> Is there an existing combinator for 'either (const Nothing) Just'?
14:29:10 <berndl> Not inthe prelude.
14:29:17 <berndl> err, not in base
14:29:29 <koz_> berndl: :(
14:29:53 <berndl> I know...
14:30:14 <monochrom> @type either (const Nothing) Just
14:30:15 <lambdabot> Either b a -> Maybe a
14:30:45 <hpc> unsafeCoerce? :P
14:31:06 <koz_> @pl \x -> either (const Nothing) Just x
14:31:07 <lambdabot> either (const Nothing) Just
14:31:11 <koz_> Well damn.
14:31:24 <koz_> hpc: LOL
14:45:46 <phadej> :t preview folded :: Either b a -> Maybe a
14:45:47 <lambdabot> Either b a -> Maybe a
14:45:53 <phadej> lens to the rescue
14:46:28 <koz_> phadej: Nice.
14:48:08 <phadej> :t alaf First foldMap Just :: Either b a -> Maybe a -- is four words but zero parens
14:48:10 <lambdabot> Either b a -> Maybe a
14:49:01 <phadej> long answer shirt: There could be "AffineFoldable" class somewhere, but it's not that useful after all.
14:49:23 <koz_> I clearly still have much to learn of The Way of the Lens.
14:49:24 <phadej> short*
14:49:40 <phadej> alaf is more of `newtype` package area than lens
14:50:13 <phadej> in https://hackage.haskell.org/package/newtype-0.2.2.0/docs/Control-Newtype.html it's called ala' though
14:51:30 <phadej> its type-signature is an art piece
14:52:30 <koz_> Yeah, I'm familiar with the ala* stuff.
14:54:42 <phadej> > alaf ZipList traverse (\x -> [x, x+1]) [4,7,11]
14:54:55 <lambdabot>  [[4,7,11],[5,8,12]]
14:55:41 <phadej> (alaf have to be forbidden to use in code which will be read also by non Conor's students or fans)
14:56:06 <phadej> > alaf ZipList traverse (\x -> [x, x+x]) [4,7,11]
14:56:08 <lambdabot>  [[4,7,11],[8,14,22]]
14:56:17 <phadej> kind of makes sense, but not really.
15:00:19 --- mode: kornbluth.freenode.net set +o Sigyn
15:00:27 --- mode: kornbluth.freenode.net set +o ChanServ
16:34:48 * hackage tdlib-gen 0.4.0 - Codegen for TDLib  https://hackage.haskell.org/package/tdlib-gen-0.4.0 (Poscat)
17:15:55 <justinba1010> Hi everyone, so I'm trying to install cabal on an aarch64 architecture. After some wrangling, installing GHC was relatively straightforward, however, now that I am trying to install cabal, I have the wrong version of `Base`. I need to reinstall the library package, and was wondering if anyone has any information on how to do so. I get this message
17:15:55 <justinba1010> when install cabal from source.
17:16:01 <justinba1010> ```Setup: Encountered missing or private dependencies:base >=4.3.0.0 && <4.13```
17:16:41 <justinba1010> ```/usr/local/lib/ghc-8.10.1/base-4.14.0.0/```
17:17:26 <hpc> what version of cabal?
17:17:30 <justinba1010> 3.2.0
17:17:44 <justinba1010> Actually, let me try dropping back a version, that's a good idea.
17:17:56 <justinba1010> Unfortunately this platform doesn't have binaries for it :(
17:18:17 <hpc> i don't think that's it, base (>=4.6 && <5) is what cabal depends on
17:18:27 <enikar> you can use ghcup, so you don't need to compile cabal to get it installed.
17:18:46 <DigitalKiwi> what OS are you using
17:20:30 <justinba1010> I am on a Pinebook, so a Rockchip on Manjaro.
17:21:21 <justinba1010> I'm not a crazy fan of Manjaro/Arch, I prefer Debian for ARM, but this version of Manjaro is optimized for the Pinebook. And I like having Haskell on my school computer.
17:22:04 <Plazma> oh a pinebook, the new one?
17:22:09 <justinba1010> Yes sir.
17:22:13 <Plazma> nice how you like it? 
17:22:25 <Plazma> i have an older 14" pinebook and the keyboard blows and makes it almost unusable
17:22:28 <justinba1010> It's enjoyable. Packages are very very very scarce though.
17:22:33 <Plazma> yea that too
17:22:41 <Plazma> i forgot what was on it, ubuntu variant thingy 
17:22:48 <justinba1010> I'm not ready to completely replace my work and school computers.
17:22:59 <justinba1010> But I really like RISC, and this is the best out there right now.
17:23:22 <justinba1010> I would've prefered a debian based distro just because of the packages. Debian has many more packages for ARM than Manjaro.
17:23:40 <justinba1010> But they moved away from Debian, because sadly a lot of ARM packages are optimized for the Pi.
17:23:58 <Plazma> ah yea, 
17:23:59 <justinba1010> Hopefully they get the ARM ecosystem in better shape soon.
17:24:13 <justinba1010> But currently looking good with Cabal 3.0.0
17:24:57 <justinba1010> Waiting for it to finish, might be a few hours on this computer...
17:25:19 <justinba1010> Might not either lol, I have no point of reference lol, at least it's chugging along unlike 3.2.0
17:32:19 * hackage popkey 0.1.0.1 - Static key-value storage backed by poppy  https://hackage.haskell.org/package/popkey-0.1.0.1 (identicalsnowflake)
17:40:53 <koz_> :t fromIntegral
17:40:54 <lambdabot> (Integral a, Num b) => a -> b
17:41:29 <MarcelineVQ> howdareyou.jpg
18:10:22 <koz_> MarcelineVQ: Wat.
18:14:01 <fog> hello
18:15:28 <fog> i was wondering about this "state church duality"
18:16:42 <fog> as far as i can tell, state + set = container
18:17:18 <fog> and church is like fold partially applied to a container, so it takes an "action"
18:17:34 <fog> i cant quite see how this means they are dual
18:17:41 <fog> :t foldr
18:17:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:17:54 <pong> you can think of a container as fold partially applied with it
18:18:07 <pong> I think that's one way it's defined in papers
18:18:30 <fog> type Church t a b = Foldable t => (a -> b -> b) -> b -> b
18:18:33 <fog> like that?
18:19:51 <fog> um, wait, that t is ambiguous. its supposed to "hide" the `t a' that it wraps in a cps way
18:20:49 <fog> hmm, and it wouldnt be able to differentiate between a foldable container of `a' and just an `a' on its own...
18:22:35 <fog> i guess, since state is a producer of values, it would seem natural if being dual to it meant that church was a consumer of values
18:23:57 <fog> but i kind of was hoping for get and set to appear in the description
18:24:26 <fog> like, since if i can produce values, then if i can set values aswell, then i can grow a full container
18:24:49 <fog> i guess set is acting like a kind of consumer there
18:25:27 <fog> so i guess the similar statement for church would be that given a producer... something something
18:26:27 <fog> i guess, if state is the archetypal producer, and church the archetypal consumer, then both these statements would start from a combination of church and state
18:26:36 <fog> and then swap one of them for get or set
18:26:49 <fog> um, possibly paired with a container
18:27:29 <fog> i guess, get or set without something to get from or set to wouldnt be a producer or consumer
18:27:54 <fog> container + set = consumer ~ church
18:28:06 <fog> container + get = producer ~ state
18:28:47 <fog> and i guess something happens when you combine a church and a state
18:29:09 <fog> which from that seems like dismantling one container and reasembling another
18:29:36 <koz_> fog: A theocracy? :P
18:29:43 <fog> ?
18:29:50 <koz_> ... combining church and state?
18:29:56 <fog> pff
18:30:01 <koz_> Surely my humour isn't _that_ subtle, lol?
18:30:42 <fog> some kind of producer of religious units like a red alert base 
18:31:31 <fog> unit ready. unit lost
18:39:22 <fog> there was another type that keeps appearing, like, not just an "action", but that which also takes an input
18:39:48 <fog> type Act a b = (a -> b -> b) = ((a,b) -> b)
18:40:25 <fog> type State a b = Co-Act a b = (b -> (a,b))
18:40:37 <fog> and then this new one;
18:41:10 <fog> type ? i x o = (i -> x -> (o,x))
18:41:18 <fog> whats that?
18:41:47 <fog> i guess since; (i -> x -> (o,x)) = ((i,x) -> (o,x))
18:42:03 <fog> Co-? i x o = ? o x i
18:43:12 <fog> wait, maybe its more like a state which also takes an input
18:43:43 <fog> its kind of like a combination of state and act, could call it a state action
18:44:06 <fog> its not like a producer or a consumer
18:44:15 <koz_> This is where you exercise your Haskell wit and make all the political puns.
18:44:24 * koz_ looks at 'state action' in particular.
18:44:38 <fog> state inaction?
18:44:51 <koz_> Nah, I meant more like, use a term from political science for 'state action'.
18:45:04 <fog> oppression?
18:45:07 <koz_> But that's just how I approach naming things in Haskell these days, feel free to ignore me.
18:45:34 <fog> the blunder monad
18:45:49 <fog> anyway....
18:46:04 <fog> um, what was i trying to say
18:46:53 <fog> right, this "state action" is neither a producer or a consumer, unlike state and action...
18:47:11 <fog> but when you couple it with one, it can kind of "scan" over the inputs
18:47:29 <fog>  / outputs
18:48:27 <fog> which is reminiscent of some kind of stream trasducer or whatever they are called
18:49:11 <fog> like, something that sits between a source and a sink, and alters the values that go through it, while keeping an internal state
18:50:02 <fog> maybe you could call it a re-emitter 
18:50:16 <fog> but i was calling it a scanner
18:51:04 <fog> and then, there is this other thing, which is like, where a producer or consumer has a different "end" result (or initial input in the dual sense)
18:52:04 <fog> like, if you have a finite producer, and a scanner, then the combination isnt a just another finite producer
18:52:38 <fog> because when the original producer runs out of values, the scanner still exists and can be returned as this "final" output
18:52:55 <fog> and i guess there is a similar thing that is dual to this
18:54:48 <fog> this was as far as i got with that idea; https://pastebin.com/raw/zeNTJvPv
18:55:23 <fog> where the term "tape" was used to mean a finite producer
18:55:48 <fog> and the thing i was talking about before is "a Finally instance for a TapeScanner"
18:56:08 <fog> which seems to cover end to end composition
18:56:46 <fog> then with side by side composition, lists of tapes being tapes of lists, I guess thats all the kinds of compositionality?
18:57:10 <fog> i had a look at pipes, and some of the other streaming things, but i couldnt see any other combinators
19:15:51 <ezzieyguywuf> yikes, $=
19:15:59 <ezzieyguywuf> wrt to opengl in haskell
19:21:49 * hackage calamity 0.1.14.0 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.0 (nitros12)
19:40:34 <solonarv> ezzieyguywuf: you can blame that pretty much entirely on OpenGL
19:40:54 <solonarv> not the haskell bindings' fault that it's full of "set state, call a function that uses tha state"
19:46:13 <ezzieyguywuf> solonarv: Yea I'm learning that.
19:46:25 <ezzieyguywuf> following this tutorial, seems helpful https://learnopengl.com/Getting-started/Hello-Window
19:46:50 <ezzieyguywuf> I was considering trying to follow along using haskell, but perhaps since I'm completely new to opengl it may help to start with the C++ examples used..
20:03:26 <ezzieyguywuf> although opengl is an API though, right, not a library? so is it opengl's fault, or glut? or something else?
20:04:01 <solonarv> it is an API in the sense that it is a bunch of C function prototypes with specifications of how they should interact
20:04:38 <solonarv> glut is a *separate* library
20:05:10 <solonarv> so yes, definitely the fault of the ogl standard.
20:06:03 <wavemode_> opengl partly suffers from being very old and crufty compared to most other graphics APIs (directx, metal etc.)
20:06:20 <wavemode_> but opengl is cross platform, sooo
20:06:46 <ezzieyguywuf> wavemode_: that's the main reason I'm looking at it
20:06:58 <ezzieyguywuf> although I guess vulkan is supposed to supercede it?!
20:07:00 <ezzieyguywuf> i dunno, lol
20:08:11 <wavemode_> yeah, someday I suppose
20:10:45 <wavemode_> in any case, for most real-world use cases most people end up using some abstract engine on top of a graphics API, rather than writing code for an API directly
20:10:59 <wavemode_> the APIs tend to be very low-level and tedious
20:11:24 <ezzieyguywuf> I just want to make shapes
20:11:26 <ezzieyguywuf> lol
20:13:20 <wavemode_> the vulkan program which draws one triangle to the screen is over 1000 lines of code :p
20:17:52 <ezzieyguywuf> yikes
20:21:46 <EvanR> "opengl is cross platform" yeah it works on more than 1 platform
20:22:10 <EvanR> but "soon" it won't work on osx without hoops
20:24:41 <wavemode_> yeah, classic apple
20:26:04 <koz_> Yeah, I would basically say that unless you have a burning desire to write engine code, just use a wrapper library.
20:26:13 <koz_> Haskell has a few (gloss comes to mind).
20:28:46 <trajafri> ezzieyguywuf: I just joined so not sure what the conversation is but I have a tiny wrapper on top of Gloss which might be fun: https://github.com/trajafri/htdp-image
20:29:21 <trajafri> It can just make some shapes :P
20:33:27 <fog> can anyone explain what is happening with pipes "passing values upstream" ?
20:35:26 <fog> the regular version of pipes, in pipes tutorial, there are several mentions of upstream and downstream directions of dataflow
20:35:27 <fog> https://hackage.haskell.org/package/pipes-4.3.13/docs/Pipes-Tutorial.html
20:35:53 <fog> and the version used by conduit, which is kind of a more complex pipe, with way more pameters
20:35:56 <remexre> hm, does someone remember seeing (or writing!) a blogpost that was something along the lines of "Show Considered Harmful" ?
20:36:06 <remexre> google gets me some tweets, but I remember reading a post
20:36:07 <fog> i think has some of these dedicated to the upstream/downstream thing
20:37:43 <koz_> remexre: I think I know the one you mean - is this the one that defined like, Debug-the-type-class as a solution?
20:38:13 <remexre> koz_: with constructors (or combinators?) for producing the value?
20:38:24 <koz_> remexre: Yeah, something like that.
20:39:14 <fog> The concrete type synonyms use () to close unused inputs and X (the uninhabited type) to close unused outputs:
20:39:15 <fog> Effect: explicitly closes both ends, forbidding awaits and yields
20:39:26 <fog> ^ thats from Pipes.Tutorial
20:39:49 <fog> when it talks about using (), to "close one of the ends" of the pipe
20:40:47 <fog> it makes it seem like this "bidirectionality" results from actually having 2 input/output things composed in parallel in opposite directions
20:40:49 <fog> is that right?
20:41:03 <fog> maybe im getting that from the nice ascii diagrams they have
20:42:56 <fog> ahh, i think i found it. they have "Proxy" as an internal thing, where it says;
20:42:57 <fog> A Proxy is a monad transformer that receives and sends information on both an upstream and downstream interface.
20:43:29 <fog> i still dont understand this though, normally "streaming" things are not bidirectional
20:44:04 <fog> and, if composing 2 one-way streaming processors together, why stop at 2?
20:44:15 <fog> that seems to prevent junctions
20:44:39 <fog> like, they cant do message passing on graphs then
20:44:51 <fog> just on 1d things
20:47:57 <fog> i guess you could have the input and output be over lists, but that would be difficult for connecting them all together into a network
20:48:42 <fog> idk, maybe with a type annotated list they could be composed together as nodes in a type safe way
20:48:57 <fog> im just wondering if this "Proxy" thing is the best atomic constructor for that
20:49:02 <fog> contruct*
20:50:40 <fog> https://hackage.haskell.org/package/pipes-4.3.13/docs/src/Pipes.Internal.html#Proxy
20:51:09 <fog> and whats up with it "request / response" format?
20:51:30 <fog> is that like, active vs passive?
20:51:58 <fog> like, web requests from the client are active, and eg, and echo response is passive
20:53:02 <fog> not sure if thats like in the Message Passing Interface (MPI) where they have scatter and gather, and like a kind of push / pull framework
20:53:30 <fog> i guess thats where you get considerations of blocking threads and stuff
20:54:15 <fog> seems like if Pipes manages to capture all of this then its pretty powerful
20:54:26 <fog> except, it seems too much like a mealy machine
20:54:44 <fog> or a moor machine, i can never remember which is which
20:55:06 <fog> like, eg, the first of the constructors of Proxy;
20:55:16 <fog> data Proxy a' a b' b m r = Request a' (a  -> Proxy a' a b' b m r )
20:55:49 <fog> it returns a new Proxy, so it could be a wrapper around a method to change this method (kind of recursive)
20:56:00 <fog> like "a self modifying machine"
20:56:17 <fog> i would prefer an option which prevented this kind of functionality 
20:56:57 <fog> is there a more sumple thing than pipes for this?
20:57:10 <fog> i dont know if it needs that for being a monad transformer or something
21:00:46 <fog> "conduit exists, go home"...
22:40:17 <dmwit> 1123//d
22:41:25 <MarcelineVQ>  sure Brain, but where are we going to find rubber pants our size?
23:05:14 <Fahi> Hi, I am new here and I have some questions, is there any body who can help me with haskell?
23:08:14 <c_wraith> You don't need permission to ask on-topic questions.
23:08:48 <c_wraith> and Haskell is on-topic in #haskell
23:10:11 <Fahi> So my problem is with @ sign called as "Read as" sign? How does it work in haskell?
23:11:47 <c_wraith> I'm not familiar with calling the @ symbol that.  Do you have an example?
23:14:21 <Fahi> foldr (@) e [x,y,z] = x @ (y @ (z @ e)) 
23:14:48 * hackage postgresql-libpq-notify 0.1.0.0 - Minimal dependency PostgreSQL notifications library  https://hackage.haskell.org/package/postgresql-libpq-notify-0.1.0.0 (JonathanFischoff)
23:14:58 <c_wraith> Oh.  that's not special use.
23:15:10 <c_wraith> The @ symbol has some special use in pattern matching - but that isn't it.
23:15:24 <c_wraith> That's just assigning an argument the name (@) locally.
23:15:42 <Fahi> Yes, I know it's use in pattern matching.
23:16:25 <c_wraith> > let f (@) x y = x @ y in (f (+) 1 2, f (*) 2 5)
23:16:27 <lambdabot>  <hint>:1:8: error: parse error on input â€˜@â€™
23:16:33 <c_wraith> Hah, it's not even valid
23:16:42 <c_wraith> > let f (@@) x y = x @@ y in (f (+) 1 2, f (*) 2 5)
23:16:44 <lambdabot>  (3,10)
23:16:53 <c_wraith> there you go.  It's a syntax error.
23:18:47 <Fahi> foldr (@) e [x,y,z] = x @ (y @ (z @ e))                  [x,y,z] = x : (y : (z : []))
23:19:46 <Fahi> In other words, foldr (@) e applied to a list replaces the empty list by e, and(:) by (@) and evaluates the result. The parentheses group from the right, whencethe name.
23:20:42 <Fahi> My problem is with this example. What @ do in this example?
23:20:52 <c_wraith> it's not syntactically valid
23:20:55 <c_wraith> So nothing.
23:21:32 <c_wraith> If you were to replace it with something syntactically valid, like (@@), it would do... exactly the same thing as x, y, or z
23:21:44 <c_wraith> it's an unknown value
23:22:20 <c_wraith> The only thing you know for sure about it is that it's *some* binary function.
23:23:00 <opticblast> Is there a good way to enable -Wall for a Cabal project in a way that won't be included in `cabal sdist`?
23:23:34 <opticblast> I've tried cabal.project.local but ghc-options doesn't seem to work there.
23:25:09 <opticblast> (From what I've heard, it's frowned upon to enable too many warnings when distributing a library.)
23:25:11 <c_wraith> Fahi: Not knowing what it does is kind of the point.  It's a stand in for anything.
23:29:03 <opticblast> Minor clarification: an operator is a function of order two *or above*, since all functions of order n are also of order n-1 by currying.
23:29:50 <opticblast> But operators of order three or above aren't commonly used, since they can only be used by sections or partial application.
23:30:22 <c_wraith> (.) is used very commonly!
23:31:26 <opticblast> Hah, true.
23:33:53 <c_wraith> > let (!) n = if n == 0 then 1 else n * ((n - 1)!) in (5!) 
23:33:55 <lambdabot>  120
23:34:13 <c_wraith> *technically* operators can use less than 2 arguments
23:34:16 <c_wraith> But, uh.
23:34:21 <c_wraith> Don't do that.
23:44:45 <opticblast> Huh, you can even make a nullary operator:
23:44:52 <opticblast> > let (&.&) = 0 in (&.&)
23:44:54 <lambdabot>  0
23:45:45 <opticblast> Out of the box, the same symbol-sequences that represent operators can also be used, not as type operators, but as type *variables*. Huh.
23:47:34 <opticblast> class Monad (%/$) and so on
