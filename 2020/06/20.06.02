00:27:52 <typetetris> Hi everyone! What is your go to log library for concurrent settings?
00:45:06 <fog> concerning Vector representations, and things like IntMap, which mimic memory access
00:45:24 <fog> if a tree is made of these, then they can be used to construct a graph
00:45:48 <fog> each layer of the tree that is descended into, has a "pointer dereferencing" if i understand correctly
00:46:10 <fog> which is similar to what happens on each tail call of a fold
00:46:58 <fog> the advantage of having eg, direct memory addresses, is that you dont have to dereference all the intermidiate pointers to select a particular branch
00:47:28 <fog> then, there is an issue to do with streaming applications, where this reasoning seems not to apply
00:48:06 <fog> when traversing a tree, just as when traversing over a list - a kind of repeated streaming consumer, producer action
00:48:19 <fog> every value is visited *in order*
00:48:44 <fog> why would you want to visit the values in any other order? why are they in the wrong order? how did they get there?
00:48:58 <fog> the point is that when writing algorithms by composing together streaming processes
00:49:08 <fog> you dont put your data in all the wrong place
00:49:31 <fog> if i have a time evolution process, im not randomly jumping about timesteps using fast random access
00:49:48 <fog> it is the sequential nature of most algorithms that is where list *is better*
00:50:27 <fog> now, its difficult to extend this logic to branching things like trees and graphs, but there are examples
00:50:51 <fog> particularly in cases where order is not used
00:51:22 <fog> if it does not matter in which order you update each value in a tree or graph, then, lists for the branches should be just fine
00:51:43 <fog> and, the argument is that for the syntax of algorithmic design
00:51:57 <fog> in the paradigm of higher order programming patterns
00:52:06 <fog> that these are more intuitive and legible 
00:52:52 <fog> though arguments about "easier to work with" isnt really going to hold for someone from a C background more used to thinking in terms of memory addresses
00:53:24 <fog> but the idea is to establish a tradition of canonical implementations of higher order programming patterns
00:53:49 <fog> and to get people into using them
00:54:20 <fog> various implementations of streaming exist in haskell already
00:54:58 <fog> and have had vast success in serving as the abstractions over which eg. http-conduit is based
00:55:37 <fog> the argument basically, is against representations of graphs which represent nodes by lables, and edges as pairs of labels 
00:56:13 <fog> using the order independent update traversal conducting stencil convolutions on a graph
00:56:27 <fog> which supports data transferal over edges
00:56:58 <fog> this should capture many significant industrial use cases of graphs 
00:57:34 <fog> there is then an argument that, because these exist within a high performance computing setting, and so should use performant datastructures
00:58:31 <fog> however, the convenient API should not prevent the underlying implementation being optimised by the library designer and the compiler
00:59:00 <dminuoso> It's getting increasingly difficult to follow your incoherent markov-chainesque rant.
00:59:19 <fog> providing the user with a stencil convolution API built using traversals
01:02:42 <ph88> does anyone have experience in using nix to put together haskell package dependencies ?
01:03:48 <dminuoso> ph88: Yes, it's best not to ask meta questions though. Just ask your question. :)
01:04:07 <dminuoso> Also know that #nixos is also a great place to ask in.
01:06:49 <ph88> dminuoso, i got an assignment to look into it. Was wondering how good the idea is in the first place. Maybe there are gotcha's
01:13:24 <Ariakenom> ph88: there's a bunch of tooling and work with that so it sounds fairly safe, no?
01:13:54 <dminuoso> ph88: Well, nix is made exactly for that...
01:15:00 <dminuoso> Technically its perfectly viable, operationally you get a lot of benefits from determinism, but the learning hurdle can be high.
01:15:17 <Ariakenom> given that nix is the other lazy language, apart from haskell, its not too surprising that nix was first written in haskell
01:17:25 <ph88> Any pointers on how to start with nix + stack/cabal specifically ? I'm already reading through nix manual but i like some stuff to read on building haskell projects too
01:18:01 <ph88> Ariakenom, interesting ... i see they switched to C++ now .. do you know why they switched ?
01:18:14 <dminuoso> ph88: look into cabal2nix
01:19:06 <ph88> oki
01:21:31 <polux79> ph88: there are several tutorials online
01:21:38 <polux79> https://github.com/Gabriel439/haskell-nix is a popular one I think
01:22:15 <ph88> thanks guys !
01:22:23 <polux79> there is also https://maybevoid.com/posts/2019-01-27-getting-started-haskell-nix.html
01:28:05 <kuribas> how do you call transforming a type into another one?  casting?
01:28:25 <kuribas> like (0 :: Int)
01:28:39 <kuribas> or rather (fromIntegral 0 :: Int)
01:29:03 <dminuoso> A function.
01:29:22 <dminuoso> The general process is usually called conversion I guess?
01:30:24 <Ariakenom> ph88: not sure. I think they wanted more speed and also they werent familiar with haskell
01:31:16 <dminuoso> Staring at how nix performs, I doubt that performance was a motivator..
01:31:21 * dminuoso chuckles
01:34:45 <kuribas> dminuoso: a function is rather generic.  And not really relevant in a non-dependently typed language
01:35:16 <kuribas> dminuoso: or did you mean the fromIntegral?
01:35:28 <kuribas> dminuoso: I was refering to the ':: Int' part
01:35:44 * hackage language-docker 9.0.0 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-9.0.0 (lorenzo)
01:35:58 <kuribas> like turning (Num a => a) into Int
01:36:12 <kuribas> but explicitly, not using inference
01:39:14 <polux79> kuribas: I call that adding a type constraint
01:39:22 <polux79> you're constraining the type of the expression
01:39:39 <polux79> which helps the compiler select unambiguously a typeclass instance
01:39:53 <polux79> sometimes you don't have to explicitely place a constraint
01:39:59 <polux79> the context can provide it
01:40:08 <kuribas> is `casting` wrong in this context?
01:40:17 <polux79> for instance if you have f :: Int -> Int  then f (fromIntegral 0) is unambiguous
01:41:00 <polux79> kuribas: I would say so because you're not really re-interpreting the type of some data, which is what cast is to me
01:41:03 <polux79> but maybe I'm wrong
01:41:09 <MarcelineVQ> kuribas:   ::‚Äã Int is assertion
01:41:20 <dminuoso> I would call it a type application.
01:41:22 <MarcelineVQ> I assert this is Int, check for me compiler
01:41:35 <polux79> dminuoso: that would be fromIntegral @Int 0 no?
01:41:40 <dminuoso> `0 :: Int` is essentially the same as statin `fromIntegral @Int 0`
01:41:42 <dminuoso> Right.
01:42:21 <kuribas> MarcelineVQ: thanks, that sounds like the right word
01:42:48 <dminuoso> MarcelineVQ: I think in this case its more than an assertion, it's guidance.
01:43:30 <polux79> MarcelineVQ: not sure I would call it an assertion in case it adds information that wasn't there before
01:43:56 <tdammers> dminuoso: in this particular case it happens to amount to that, but that's a collateral of numeric literals being polymorphic
01:44:12 <tdammers> the "fromIntegral" is implied
01:44:54 <tdammers> but if you were to write, say, () :: Int, then no conversion function is implied, () isn't polymorphic, but the construct is still the same
01:45:03 <tdammers> calling that a type application is a bit far-fetched IMO
01:45:35 <tdammers> I think the commonly used term is "type annotation", though "type assertion" is more accurate
01:46:46 <tdammers> reading :: as "of type" or ", which is of type" works well enough
01:50:21 <kuribas> :t let x = 2 in (x, (x :: Int))
01:50:22 <lambdabot> Num a => (a, Int)
01:51:24 <kuribas> ok, so the assertion doesn't "infect" the type of x.
01:52:22 <ski> @type (\x -> (x,x :: Int)) 2
01:52:24 <lambdabot> (Int, Int)
01:53:15 <ski> kuribas : i call it a type ascription
01:53:33 <kuribas> ski: does that mean if a language has no let generalization, it doesn't need let as a construct?
01:53:56 <ski> recursion ?
01:54:30 <kuribas> right...
01:54:55 <kuribas> if the language isn't total it can use fix
01:55:19 <ski> i don't follow
01:55:30 <kuribas> you can implement recursion using fix right?
01:55:54 <kuribas> so you don't need let for recursion
01:56:03 <kuribas> perhaps I missed your point
01:57:38 <ski> i just meant that whether you need `let' depends on the `let' you had in mind would still allow recursion
01:58:05 <ski> (and then whether there would be another way of getting the same effect, yes)
01:58:11 <kuribas> @type (\(x :: (forall a. Num a) -> (x, x :: Int)) 2
01:58:12 <lambdabot> error:
01:58:12 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:58:25 <kuribas> @type (\(x :: (forall a. Num a)) -> (x, x :: Int)) 2
01:58:50 <ski> @type (\(x :: forall a. Num a => a) -> (x, x :: Int)) 2
01:58:51 <lambdabot> Num a => (a, Int)
02:00:58 <liiae> how to turn a string to word32? "127.0.0.1" to word32?
02:01:54 <__monty__> Split and then read would probably be easiest.
02:02:26 <__monty__> Well, read as Word32, shift and add.
02:02:49 <__monty__> Or maybe you can read as [Word8] and turn that into Word32?
02:04:02 <liiae> I need a HostAddress
02:04:17 <liiae> tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
02:04:35 <liiae> now how to turn 127::Int to Word8?
02:04:53 <liiae> I only found ByteString -> Word8 in Data.ByteString
02:06:29 <kuribas> liiae: fromIntegral?
02:06:44 <kuribas> > fromIntegral (127 :: Int) :: Word8
02:06:45 <lambdabot>  127
02:07:05 <__monty__> liiae: You should be able to read as Word8
02:07:20 <__monty__> > read "127" :: Word8
02:07:22 <lambdabot>  127
02:07:29 <liiae> kuribas: __monty__ ok
02:07:50 <kuribas> better use readMaybe
02:09:15 <__monty__> Note that my advice is for a one-off thing. If you need to parse a lot of IPs you probably want a parser.
02:17:15 * hackage character-cases 0.1.0.6 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.6 (aiya000)
02:21:49 <dminuoso> Is there an idiomatic way to get a duplicate key error when inserting into a map?
02:22:21 <dminuoso> There doesn't appear to be any `insertWithM` in Data.Map
02:23:08 <liiae> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#t:SockAddr
02:23:20 <liiae> and I import Network.Socket in my a.hs
02:23:43 <liiae> why it tells me data constructor is not in scope: SockAddr 
02:24:15 * hackage dobutokO-poetry 0.3.0.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.3.0.0 (OleksandrZhabenko)
02:24:39 <dminuoso> % insertWithM f k v m = Data.IntMap.alterF (\case Nothing -> return (Just v); Just v' -> Just <$> f v v') k m
02:24:40 <yahb> dminuoso: 
02:24:42 <liiae> oh, it's SockAddrInet
02:24:47 <dminuoso> That is a bit cumbersome..
02:25:05 <dminuoso> % :t insertWithM
02:25:05 <yahb> dminuoso: Monad f => (t -> t -> f t) -> IM.Key -> t -> IM.IntMap t -> f (IM.IntMap t)
02:26:44 <dminuoso> merijn: Didn't you frequently complain about such a thing missing?
02:31:14 * hackage dockerfile-creator 0.1.0.0 -   https://hackage.haskell.org/package/dockerfile-creator-0.1.0.0 (lorenzo)
02:35:11 <liiae> https://hackage.haskell.org/package/network-3.1.1.1/docs/src/Network.Socket.Types.html#SockAddr
02:35:18 <liiae> SockAddrUnix String
02:35:46 <liiae> SockAddrUnix "127.0.0.1:80" :: SockAddr?
02:35:57 <liiae> what value has this String?
02:37:33 <dminuoso> liiae: Check the data constructor at https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#t:SockAddr
02:37:49 <dminuoso> Ah.
02:37:58 <dminuoso> Hold on I misunderstood.
02:38:05 <liiae> :)
02:38:08 <dminuoso> That is for unix domain sockets.
02:39:47 <liiae> what is unix domain sockets look like?
02:40:43 <__monty__> Files
02:40:58 <__monty__> dminuoso: Isn't alterF what you're after?
02:41:02 <__monty__> :t alterF
02:41:04 <lambdabot> error:
02:41:04 <lambdabot>     ‚Ä¢ Variable not in scope: alterF
02:41:04 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
02:41:09 <__monty__> @hoogle alterF
02:41:09 <lambdabot> Data.IntMap.Internal alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
02:41:09 <lambdabot> Data.IntMap.Lazy alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
02:41:09 <lambdabot> Data.IntMap.Strict alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
02:41:20 <dminuoso> __monty__: As I said above, using alterF is a bit cumbersome.
02:41:31 <dminuoso> And Im not sure whether it's actually as efficient
02:41:35 <__monty__> Oh, misread.
02:41:49 <dminuoso> (If I look at the implemnetation of insertWith and friends, they are handcrafted rather than in terms of alterF)
02:42:18 <dminuoso> liiae: The function you are after is called getAddrInfo
02:42:50 <dminuoso> If you check the haddock of https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html there is an extensive example at the top
02:43:15 * hackage dobutokO-poetry 0.3.1.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.3.1.0 (OleksandrZhabenko)
02:47:45 * hackage tdlib-types 0.1.0 - Types and Functions generated from tdlib api spec  https://hackage.haskell.org/package/tdlib-types-0.1.0 (Poscat)
03:04:15 * hackage dobutokO-poetry 0.3.2.0 - Helps to order the 7 or less Ukrainian words to obtain somewhat suitable for poetry or music text  https://hackage.haskell.org/package/dobutokO-poetry-0.3.2.0 (OleksandrZhabenko)
03:06:25 <infinity0> was there ever any discussion on whether the linear haskell proposal would also be able to support strictness polymorphism
03:30:14 <infinity0> dminuoso: if you're into lens, alterF is just a lens. you can factor out your duplicate-key check into a separate function and reuse it with other lens for other data structures
03:30:56 <infinity0> that would be my preferred way, i would imagine there is no "idomatic way" to do a duplicate-key check across different data structures, other than lens
03:31:29 <infinity0> wasInserted <- _lensIntoMap . at k %%= insertIfAbsent vToInsert
03:31:42 <larryba> hi. are there safe equivalents of !!, head, etc, in prelude? 
03:31:42 <infinity0> insertIfAbsent vToInsert = \case Just v -> (Left "duplicate key", Just v); Nothing -> (Right (), Just vToInsert)
03:32:42 <dminuoso> larryba: The safer way is either explicit pattern matching or code restructuring.
03:32:58 <larryba> no safe variants of those functions, though?
03:32:59 <infinity0> ideally this sort of stuff could be added to some lens utilities library maybe. seems a bit too specific for the lens package itself
03:33:06 <dminuoso> larryba: They'd be a red herring.
03:33:10 <infinity0> larryba: there is the safe package
03:33:20 <infinity0> it gives you various options like error with specfic message, return Maybe, etc
03:33:25 <larryba> dminuoso huh?
03:33:44 <larryba> infinity0, yeah, I used that a while ago, but was thinking maybe some of them ended up in prelude
03:34:01 <dminuoso> larryba: In case of (!!), lists are not designed for random access, as you incur an O(n) penalty for random lookup
03:34:14 <dminuoso> And for head, just pattern match really. :)
03:34:16 <larryba> dminuoso, which is often completely irrelevant
03:34:16 <infinity0> it's a bit of a long process getting things into prelude, i just import safe myself, not too much overhead
03:34:59 <larryba> dminuoso, (\xs -> case xs of [] -> Nothing; (x:_) -> x) vs headMay
03:35:13 <larryba> Just x*
03:35:16 <infinity0> yeah, it's much more convenienc than explicit pattern matching
03:36:02 <dminuoso> larryba: I have yet to discover the need to use safeHead, really. I usually structure functions like this
03:36:15 <infinity0> to each their own
03:36:26 <infinity0> he simply asked if there is a utility, no need to pass jugdment on it
03:36:27 <dminuoso> https://gitlab.com/snippets/1982510
03:37:10 <larryba> dminuoso, I've been using haskell for several years, I know how to pattern match. 
03:37:46 <infinity0> using safe is a fine solution and nobody should make anyone feel bad over it, lol
03:40:41 <larryba> I just wish some of those functions made it to prelude
03:40:47 <dminuoso> larryba: I would just write a safeHead on the spot, if I really had a need for it. Incurring a dependency just for that one line is not worth it...
03:40:57 <larryba> listToMaybe is the only one, and the name is kind of clumsy compared to headMay
03:41:48 <dminuoso> Well honestly in case of (!!) I dont think we should have either (!!) or a safe version of it in prelude.
03:42:13 <larryba> I don't mind it, but it should return Maybe a
03:46:26 <larryba> if efficient is argument against !!, then list also shouldn't have find, or lookup
03:46:36 <larryba> efficiency*
03:47:00 <dminuoso> find/lookup need to linearly scan regardless (because its not a set)
03:47:41 <dminuoso> Well actually ignore that comment about sets. 
03:48:24 <dminuoso> Most use cases for safeHead are likely better covered by pattern matching, leading to more idiomatic core.
03:48:26 <dminuoso> *code
03:48:47 <larryba> wasn't that your argument against !!? that you shouldn't use list, because there are data structures that perform the same opreation more efficiently
03:49:25 <dminuoso> No, the statement was silly because sets only behave better in case of lookup, not find.
03:49:28 <dminuoso> Either way
03:49:44 <larryba> there are plenty of cases where I have used safeHead to compose it with other functions, or pass it to higher order functions. lambda + pattern matching is a lot more verbose
03:50:55 <larryba> anyway, I wouldn't mind a break change, where !!, head, etc started returning Maybe :)
03:51:00 <larryba> breaking*
03:52:01 <dminuoso> You'd likely break a large percentage of hackage.
03:53:25 <dminuoso> And then people will complain and want unsafe versions, because they have some internal invariants allowing them to use them safely.
03:53:52 <larryba> a decent percentage of those breaking changes would discover hidden bugs
03:54:35 <dminuoso> Honestly I think `read` is a much more important candidate than `head` or `!!`
03:55:07 <dminuoso> The number of times when some transitive library gave me `read: no parse` bottom in my case is insulting.
03:55:11 * ski . o O ( `reads' )
03:55:12 <dminuoso> *in my code
03:55:14 <larryba> there's readMay
03:55:33 <larryba> but yes, odd that unsafe version gets the priority, shorter name, and being in Prelude
03:55:40 <dminuoso> Sure there is, but hackage has plenty of libraries still using read.
03:56:00 <dminuoso> If your argument is "it would discover hidden bugs", then `read` has much more.
03:56:15 <dminuoso> Well to be fair, hysterical raisins.
03:56:44 <dminuoso> There's plenty of things that could have been solved much better. But it's easy to complain about that in hindsight.
03:57:43 <dminuoso> We should have Text instead of String, no read/reads in Prelude, foldl would be the strict foldl...
04:03:12 <larryba> what's the historical reason for !! and head, read, etc being unsafe? it seems contrary to the spirit of haskell
04:04:32 <cdunklau> larryba: how could head be safe? 
04:04:42 <dminuoso> % :t listToMaybe -- cdunklau 
04:04:42 <yahb> dminuoso: [a] -> Maybe a
04:05:05 <cdunklau> dminuoso: that's not what head does though :)
04:05:17 <cdunklau> (but i think i understand the question now, thanks :) )
04:05:22 <MarcelineVQ> the spirit of haskell is perhaps something different
04:05:27 <dminuoso> cdunklau: No but that's what the discussion is about. They are suggested that head should have been listToMaybe from the beginning
04:05:40 <cdunklau> dminuoso: yeah i fully admit ignorance of the context
04:11:16 <nil> i think the problem might be conflating type safety with totality
04:13:02 <nil> see also https://github.com/haskell/rfcs/pull/8#issuecomment-247769117
04:32:15 * hackage hpack 0.34.2 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.34.2 (SimonHengel)
04:34:04 <Cheery> head likely comes directly from lisp/scheme.
04:34:25 <Cheery> :t (head,tail)
04:34:26 <lambdabot> ([a1] -> a1, [a2] -> [a2])
04:34:40 <dminuoso> Well if it came directly, it'd called car/cdr and not head/tail :P
04:35:32 <hpc> linked lists have been more places than lisp
04:36:00 <solonarv> head/tail is because lists as snakes
04:36:08 <solonarv> that is why we often use 'xs' as a variable name
04:36:14 <dminuoso> I think the most likely explanation is that someone made those functions and didn't think too much about us having this discussion 20 years later.
04:36:14 <solonarv> it hisses! like a snake! ;)
04:38:16 <dminuoso> But I am confident, that the lack of `safeHead` is because pattern matching gets the job done better in most cases - the exotic cases where safeHead would be nice as an argument for higher order functions are trivially handled by you writing it yourself.
04:39:07 <Cheery> but you can write partial functions just as well.
04:43:59 <Cheery> If I were doing it again, I'd probably use head :: [a] -> Maybe a, then have something like (¬§) :: Maybe a -> a
04:45:15 <nil> a unary infix operator? o_√¥
04:46:13 <nil> (well, i guess it works if `a` is a function type...)
04:46:30 <dminuoso> What is an unary infix operator?
04:46:39 <dminuoso> Why do you think its infix at all?
04:47:28 <dminuoso> You have to admit, the way Agda lets you define postfix and prefix operators is sweet. :)
04:49:55 <ichimaru> agda is pretty cool, you can even do mixfix. It comes at the cost of always requiring whitespace between everything.
04:50:39 <kuribas> :t (undefined :: forall c . c -> (forall a b . a -> b) -> c) :: forall a . a -> (forall b c . b -> c) -> a
04:50:40 <lambdabot> error:
04:50:40 <lambdabot>     ‚Ä¢ Cannot instantiate unification variable ‚Äòa0‚Äô
04:50:40 <lambdabot>       with a type involving foralls: c -> (forall a2 b. a2 -> b) -> c
04:50:56 <kuribas> aren't these equivalent?
04:53:14 <kuribas> where does GHC fail?
04:54:01 <kuribas> :t (undefined :: (forall a b . a -> b)) :: forall a. a -> a
04:54:02 <lambdabot> a -> a
04:55:02 <kuribas> is it because the forall is nested?
04:55:18 <dminuoso> That seems to be the condition for this diagnostic, yes.
04:55:46 <kuribas> so foralls cannot be nested in type assertions?
04:56:04 <dminuoso> Sure they can, but I dont think this double type ascription is useful
04:56:15 * hackage json-directory 0.1.0.1 - Load JSON from files in a directory structure  https://hackage.haskell.org/package/json-directory-0.1.0.1 (lukec)
04:56:35 <kuribas> dminuoso: it's not, I am just trying to understand how inference works with nested foralls
04:57:07 <dminuoso> Well first off, we call that higher ranked types, or RankNTypes like the extension.
04:57:16 <merijn> kuribas: "it doesn't
04:57:20 <dminuoso> And for type inference, check out https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf
04:57:27 <merijn> You cannot infer types with Rank >2
04:57:37 <dminuoso> Sure you can.
04:57:48 <merijn> You can (in theory) infer types with Rank2, but the implementation is super hard and GHC doesn't have it
04:57:56 <merijn> dminuoso: No, you can't. It's undecidable
04:58:12 <kuribas> merijn: I mean with given polymorphic annotations
04:58:17 <dminuoso> merijn: complete type inference, sure.
04:58:23 <dminuoso> But you may not need complete type inference.
04:58:29 <dminuoso> Hence, paper above.
04:58:40 <dminuoso> kuribas: Thats not inference anymore, that's type checking.
04:59:06 <kuribas> dminuoso: right
05:06:50 <kuribas> so you cannot have inner foralls?
05:08:01 <dminuoso> kuribas: The diagnostic is not a limitation of the type system, it's a bizarre artifact of the double type signature
05:08:54 <kuribas> dminuoso: but what if the first is the type of an function argument, and the second the value passed?
05:09:10 <dminuoso> I do not understand the question.
05:09:31 <kuribas> well, the other way around
05:10:11 <dminuoso> Haskell has no problems with RankNTypes.
05:10:12 <kuribas> > :t (undefined :: (d -> (forall e f . e -> f) -> d) -> e) (undefined :: c -> (forall a b . a -> b) -> c)
05:10:13 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
05:10:15 * hackage doctest 0.17 - Test interactive Haskell examples  https://hackage.haskell.org/package/doctest-0.17 (quasicomputational)
05:10:28 <kuribas> :t (undefined :: c -> (forall a b . a -> b) -> c) :: d -> (forall e f . e -> f) -> d
05:10:30 <lambdabot> error:
05:10:30 <lambdabot>     ‚Ä¢ Cannot instantiate unification variable ‚Äòa0‚Äô
05:10:30 <lambdabot>       with a type involving foralls: c -> (forall a b. a -> b) -> c
05:10:42 <dminuoso> Right, that's a limitation of the type system now.
05:10:49 <dminuoso> This requires impredicative types to work.
05:10:56 <dminuoso> Which we don't (really) have (yet).
05:11:11 <dminuoso> You can get around that with newtypes
05:11:14 <merijn> We have them, but they're "not even broken" ;)
05:12:00 <dminuoso> kuribas: The shortest example that.. *should* fail to type check I can think of is runST
05:12:02 <dminuoso> % :t runST
05:12:02 <yahb> dminuoso: (forall s. ST s a) -> a
05:12:10 <dminuoso> % :t ($)
05:12:10 <yahb> dminuoso: (a -> b) -> a -> b
05:12:36 <dminuoso> `runST $ ...` should be rejected by the type checker. The only reason its not is because some really trivial hack that makes the ($) disappear if memory serves right
05:18:47 <dminuoso> kuribas: Recall that the type checker roughly works like this. instantiate type variables in the signature with rigids, instantiate type variables in used identifiers with unificationals, solve equations.
05:19:20 <dminuoso> However, unifying a unificational with an forall quantified type requires impredicative types.
05:20:11 <dminuoso> Now, impredicative types themselves are not bad, GHC Core in fact allows for full impredicative types. But together with type inference... until recently it wasnt even understood what that meant - so nobody could even tell whether GHCs implementation of -XImpredicativeTypes was even right or wrong..
05:23:29 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/wikis/impredicative-polymorphism has some more bits about this
05:24:11 <dminuoso> For what its worth, RankNTypes already is a limited form of impredicative types. :)
05:28:36 <lortabac> relevant https://youtu.be/ZuNMo136QqI
05:28:54 <lortabac> IIRC there is a proposal to implement this idea in GHC
06:41:15 * hackage tdlib 0.1.3 - Bidings to the tdlib json interface  https://hackage.haskell.org/package/tdlib-0.1.3 (Poscat)
06:41:35 <fog> is there a way to build up "Words" from smaller words?
06:41:59 <Cheery> yes?
06:42:07 <fog> effeciently?
06:42:25 <fog> i dont want to use lists of bools, for some reason I think would be slow
06:42:51 <Cheery> dunno. what do you mean exactly?
06:43:14 <fog> the idea of descending through the space of nets of increasing complexity by training neurons over smaller words first
06:43:59 <Cheery> That I guess I know too little about to help.
06:44:02 <fog> liek, i could get a very sparse covering at first just by having bools, for which half of the big word it is
06:44:14 <fog> um, matricies might be simpler
06:44:15 * hackage hvega 0.9.0.1 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.9.0.1 (DouglasBurke)
06:44:24 <ClaudiusMaximus> fog: https://hackage.haskell.org/package/largeword
06:45:53 <Cheery> Oh, so no "words", but Word256, etc..
06:46:18 <fog> yah
06:46:40 <fog> these "large words" seem to just be nested pairs
06:46:43 <Cheery> How are they accessed?
06:46:49 <fog> more effecint than lists i guess
06:46:55 <Cheery> if it's accessed in stream, list of booleans might be ok.
06:47:31 <fog> well, then my large word is kind of a binary partition tree with Bools at the leafs
06:48:10 <fog> i guess they are using Word8 as the smallest, because it has efficient Num implementations
06:48:58 <fog> idk if its worth trying to get a smoother interpolation, like a list instead of a length 2^n binary partition tree
06:49:21 <Cheery> implement it with list of booleans first
06:49:30 <Cheery> see how it performs
06:49:49 <fog> but then the Num instance is difficult, and likely slow, i guess there are machine instructions being wrapped up
06:49:50 <Cheery> and what kind of structure there is.
06:50:55 <fog> we were talking about non-determinism modelled as a list before, and it seemed like "range"ing over the set of inhabitants of the type 
06:51:10 <fog> enumerating the values
06:51:29 <fog> (i think range is defined using enumFromTo with the max and min bound)
06:51:57 <fog> i have no hope of ranging over doubles or fractionals
06:52:05 <fog> but thats what i would normally have in matricies
06:52:24 <fog> ranging over matricies then seems even more impossible
06:52:56 <Cheery> implementing it first would be important for performance, so you see what you need to optimize
06:53:39 <Cheery> you know.. simplest abstract data structure that fits
06:53:41 <fog> i guess i was hoping someone would be able to comment on the internal representation of Words, vs lists of Bools
06:54:09 <fog> i dont really know about what machine instructions are available to the compiler
06:54:45 <Cheery> you don't know internal representation of booleans before it's decided
06:54:49 <fog> ( i can have lengthed lists with type level constraints to have them as only length 2^n for better comparison to Words)
06:55:10 <fog> Cheery: how do you mean?
06:55:34 <fog> oh, if its either side of the sum datatype?
06:55:40 <Cheery> You got ghc, and purescript for haskell.
06:55:47 <Cheery> think they use the same boolean representation?
06:55:55 <fog> ok, lets go with ghc
06:56:17 <Cheery> think ghc uses same boolean representation for every boolean?
06:56:26 <fog> there are only 2 of them!
06:56:41 <fog> im guessing your suggesting not...
06:57:15 <Cheery> think a bit about how typeclasses work.. Now consider that datatypes are bit like typeclasses as well.
06:57:20 <fog> or by "every" boolean, do you mean like a custom made; data MyBool = MyTrue | MyFalse
06:57:55 <Cheery> and then consider something like (Bool,Bool)
06:58:09 <Cheery> well you get fst :: X -> Bool, snd :: X -> Bool
06:58:18 <fog> datatypes are kind of like typeclasses, except they store the values of the type corresponding to the functions of the class
06:58:46 <Cheery> so something that constructed from two booleans, and produces two booleans, have you decided yet whether this is a pointer bush or just a single number?
06:59:11 <fog> i thought a number would always have that kind of internal structure
06:59:44 <fog> except for however the hardware does memory allocation for numbers...
06:59:53 <fog> im guessing you dont have to allocate each bit
07:00:10 <Cheery> trying to point out that these things don't completely determine how it maps to hardware representations.
07:00:35 <Cheery> first try to describe the algorithm in general way, then map it to hardware.
07:00:50 <Cheery> You can try different things and see which does it fastest.
07:01:10 <fog> yeah, i guessed so. that was the hesitance of straying from "built in" types, because these might be optimised somehow by the compiler being aware of the architecture its running on 
07:01:17 <Cheery> It's not obvious that the most compact representation would be best anyway.
07:01:45 <fog> compact meaning what? and not best how?
07:02:31 <fog> like, if it needs more memory accesses to build up a length 7 "Word" compared to just one instruction being used for the Word8
07:03:02 <fog> i mean, that was one of the reasons i was wary of using bools
07:03:04 <Cheery> 16:42 < fog> the idea of descending through the space of nets of increasing complexity by training neurons over smaller words first
07:03:29 <Cheery> could you first describe that, write a Haskell program that just does that, disregarding hardware that it runs on?
07:03:56 <Cheery> you likely need to optimize it, but you first need something to optimize
07:04:05 <fog> it might be easier to have a simple tuple, like (,,)
07:04:10 <fog> instead of a whole net
07:04:37 <fog> ok, ill try and write that
07:08:52 <fog> ok, heres the types; https://pastebin.com/raw/TeSbS13y
07:10:46 <fog> hmm, so far i see a problem in stochastically updating the words 
07:11:09 <fog> i need to draw several random bools, or just one random Word8
07:30:38 <fog> i really cant get the random instance to be effecient
07:30:53 <fog> does it matter if i use a really slow hack just for the example?
07:47:15 * hackage tdlib 0.1.4 - complete binding to the Telegram Database Library  https://hackage.haskell.org/package/tdlib-0.1.4 (Poscat)
08:04:11 <fog> oh no, the random numbers dont work well at all
08:04:21 <fog> it wasnt just a slow implementation, it was a terrible implementation!
08:04:35 <fog> https://pastebin.com/9fuSd4q0
08:05:46 <fog> Cheery: ^
08:15:15 * hackage ghcide 0.2.0 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.2.0 (cocreature)
08:16:15 <ja> oooh ghcide has 8.10 support now
08:18:48 <dminuoso> I have a compiler of sorts that produces all kinds of artifacts, that need to be written to disk eventually. It's essentially a dictionary with some fields, but I build it up incrementally (with some passes needing data from previous passes).
08:18:59 <fog> here is the stochastic update; https://pastebin.com/raw/ni5jF6fb
08:19:28 <dminuoso> Is using a big product type that is saturated with bottoms in the beginning, where all bottoms are replaced by real values eventually, a bad style for this?
08:20:00 <merijn> dminuoso: "Yes" :p
08:20:04 <xerox_> after ghcid and ghcide when do we get ghcidef, ghcidefg, ghcidefgh, ...
08:20:16 <dminuoso> merijn: Dont get me started on using a separate data type for each pass...
08:20:26 <dminuoso> I get into naming issues real fsat..
08:20:49 <dminuoso> pass1 :: Artifacts1 -> Comp Artifacts2; pass2 :: Artifacts2 -> Comp Artifacts3; ....
08:21:16 <dminuoso> DictWithA, DictWithAB, DictWithABC...
08:21:54 <merijn> Can't you just have "data Foo f = Foo { field1 :: f X, field2 :: f Y }" and then start with "Foo Maybe" and at the end have a single traversal "Foo Maybe -> Maybe (Foo Identity)" or something along those lines?
08:23:14 <dminuoso> merijn: Sure, that'd be some `data Foo f g h i = Foo { field1 :: f R, field2 :: f S, field3 :: g T; field4 :: h U; field 5 :: i V }`
08:23:32 <wavemode> I'm confused as to why this big product type can't be, like, a Data.Map. Maybe I'm misunderstanding the use case
08:24:42 <merijn> dminuoso: Why?
08:24:51 <dminuoso> So Im compiling networking data. In my first pass I build up list of nodes in my network. In the next pass, I construct a graph of said nodes, then I produce various artifacts like dhcp reservation artifacts, and so on.
08:24:53 <merijn> Keep everything as Maybe until the end, then finalise
08:24:58 <dminuoso> Oh.
08:25:23 <merijn> Of if you want it staged, you can get like a type family to handle the staging?
08:25:32 <dminuoso> Actually that's not so bad
08:25:38 <merijn> Also, isn't there a GHC paper on incrementally decorating trees?
08:25:41 <merijn> I forgot the name
08:25:50 <Cale> Trees that Grow
08:25:52 <MarcelineVQ> trees that grow
08:29:07 <dminuoso> I have this vague feeling that if I toss singletons and type families at this, I get exactly what I want with the exact effort I want to avoid...
08:29:52 <merijn> dminuoso: I just meant using a type family to enforce that some values have to not be maybe by some stage
08:30:21 <dminuoso> merijn: Well actually, I could do something simple with type level nats maybe.
08:31:00 <merijn> dminuoso: Like "data Foo (n :: Nat) = Foo { field1 :: Restrict n 2 a }" which maps to "Maybe a" for n < 2, and "a" afterwards or something like that
08:31:06 <MarcelineVQ> slippery slope, you'll be inventing staged compilation via modal logic next
08:31:29 <merijn> honestly, staged compilation seems a much smarter approach than TH :p
08:31:45 <merijn> I wish we had better staged compilation support in GHC
08:32:38 <dminuoso> That's actually quite neat.
08:32:58 <dminuoso> It can actually map to `Const Void` for less than 2
08:33:31 <dminuoso> Or maybe `Const ()` would be less silly.
08:34:07 <ezzieyguywuf> I'd like some advice: http://dpaste.com/3RTHXXH, this shows a simplified representation of a complex data structur that I'm using. I find myself often modifying one of the sub-structures (MoreStuff), querying the newly changed sub-structure (getMoreStuff), grabbing the last item, and then using that to do something to the other sub-structure (Stuff).
08:34:18 <ezzieyguywuf> don't worry, I think the example in the link is much clearer than all my words
08:34:31 <dminuoso> ezzieyguywuf: Look into lenses.
08:34:34 <ezzieyguywuf> my question is - am I falling into some sort of pitfall here? Am i letting my oop background get in the way?
08:34:41 <merijn>  ezzieyguywuf: Congratulations, you have invented lenses ;)
08:34:44 <ezzieyguywuf> dminuoso: I've heard that term bandied about
08:34:50 <ezzieyguywuf> perhaps it is time to learns what it's all about
08:35:03 <dminuoso> ezzieyguywuf: lenses are, roughly speaking, a way to have composable data access as first class values.
08:35:08 <dminuoso> *data accessors
08:35:11 <merijn> Unfortunately, the only thing I know about beginner explanations to lenses is "don't look at the lens package" ;)
08:35:13 <xerox_> there's a nice spj talk on lenses
08:35:52 <dminuoso> In particular Im a big fan of the library `optics`, which I think has better ergononics, especially to beginner developers
08:36:11 <ezzieyguywuf> i'll be sure to avoid the lens package then
08:36:22 <dminuoso> ezzieyguywuf: Dont be afraid, honestly.
08:36:25 <ezzieyguywuf> so I'm not doing any sort of "hey stop OOPing all over my functional language!" stuff?
08:36:36 <dminuoso> ezzieyguywuf: Dealing with deeply nested data is a common thing in programming.
08:36:38 <merijn> ezzieyguywuf: The package is fine, it's just...intimidating :p
08:36:44 <ezzieyguywuf> I'm trying to be careful to approach problems in haskell using haskell idioms
08:36:51 <ezzieyguywuf> got it
08:36:55 <ezzieyguywuf> i'm ok with intimidating
08:36:59 <dminuoso> I recommend using `optics`, but feel free to use any lens learning tutorial.
08:37:03 <ezzieyguywuf> i figured out fhl
08:37:05 <ezzieyguywuf> *fgl
08:37:13 <ezzieyguywuf> though maybe that's not so intimidating...
08:37:22 <dminuoso> Reason being, it doesn't have freaking confusing rank 2 type aliases that make compiler errors unreadable.
08:39:03 <dminuoso> % let dat = ("Foo", Left 'c', 5)
08:39:03 <yahb> dminuoso: 
08:40:57 <dminuoso> % preview (_2 . _Left) dat
08:40:57 <yahb> dminuoso: Just 'c'
08:41:07 <dminuoso> % preview (_2 . _Right) dat
08:41:07 <yahb> dminuoso: Nothing
08:41:55 <dminuoso> % dat & dat .~ 'd'
08:41:55 <yahb> dminuoso: ; <interactive>:77:7: error:; * Couldn't match type `(a2, Either Char b0, c1)' with `(a0 -> Identity Char) -> (a1, Either Char b1, c0) -> Identity b'; Expected type: ASetter (a1, Either Char b1, c0) b a0 Char; Actual type: (a2, Either Char b0, c1); * In the first argument of `(.~)', namely `dat'; In the second argument of `(&)', namely dat .~ 'd'; In the expression: dat 
08:42:02 <dminuoso> % dat & (_2 . _Left) .~ 'd'
08:42:02 <yahb> dminuoso: ("Foo",Left 'd',5)
08:42:44 <ezzieyguywuf> hrmmm, yes I think perhaps this is the route I need to go
08:42:57 <ezzieyguywuf> I'm assuming & and .~ are operators described in a lens package?
08:43:49 <dminuoso> Yes, though (&) is just a flipped ($) operator for convenience.
08:44:37 <ezzieyguywuf> interesting
08:44:41 <ezzieyguywuf> guess I have more learning to do
08:44:56 <dminuoso> The `optics` package is close to identical to lens, except you compose accessors together with % instead of .
08:45:00 <dminuoso> In case you chose to go down that road
08:45:08 <dminuoso> (And some other bits, but those are not immediately relevant)
08:45:23 <dminuoso> Advantage is readable compiler errors should you make any mistake..
08:46:08 <ezzieyguywuf> I like readable compiler errors...
08:46:12 <dminuoso> Here's a very simple example of how much lens can be:
08:46:13 <dminuoso> % dat ^. (_2 . _Left)
08:46:14 <yahb> dminuoso: ; <interactive>:80:14: error:; * No instance for (Monoid Char) arising from a use of `_Left'; * In the second argument of `(.)', namely `_Left'; In the second argument of `(^.)', namely `(_2 . _Left)'; In the expression: dat ^. (_2 . _Left)
08:47:25 <jlebar> Is it  possible to pass the requisite flags to the `runhaskell` tool to get exception stack traces out of my script?
08:48:07 <ezzieyguywuf> "The end result is a way to efficiently construct and manipulate "methods of poking around inside things" as simple first-class values."
08:48:12 <dminuoso> The optics equivalent error ir:
08:48:14 <dminuoso>     ‚Ä¢ An_AffineTraversal cannot be used as A_Getter
08:48:52 <dminuoso> I mean if you understand exactly how lens works, you can decipher the above error message. But I dont have the time..
08:50:45 * hackage hslua 1.1.1 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.1.1 (tarleb)
08:51:24 <ezzieyguywuf> what about specifically the sequence of "Modify some Data, retrieve getSomeSomeData, get `last` of that sub-data"
08:52:03 <ezzieyguywuf> that seems expensive and repetitive - is that something that can be done better or differently? I could make the modification function return a tuple with the modified MyData and the newly added piece
08:52:15 <ezzieyguywuf> but my gut tells me this approach may be flawed
08:52:24 <dminuoso> I'd say it's premature optimization.
08:53:11 <ezzieyguywuf> I'm not so worried about optimization: just getting tired of re-writing "addSomething; last . getSomethings...", lol
08:53:34 <dminuoso> ezzieyguywuf: Well that's the beauty with lens, you can describe that accessor once.
08:53:57 <dminuoso> Say
08:54:13 <ezzieyguywuf> interesting
08:54:14 <ezzieyguywuf> ok then.
08:54:15 <dminuoso> % dat = (5, Just "foobar", 'c')
08:54:15 <yahb> dminuoso: 
08:54:30 <dminuoso> % opt = _2 . _Just . _Snoc
08:54:30 <yahb> dminuoso: 
08:54:34 <ezzieyguywuf> I'll continue to develop my codebase while getting familiar with lens, and expect that eventually lens will help me refactor these things nicely
08:54:39 <dminuoso> % dat ^? opt
08:54:39 <yahb> dminuoso: ; <interactive>:83:1: error:; * Couldn't match type `()' with `Char'; arising from a functional dependency between:; constraint `Snoc [Char] [Char] () ()' arising from a use of `it'; instance `Snoc [a] [b] a b' at <no location info>; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
08:54:57 <dsal> ezzieyguywuf: https://leanpub.com/optics-by-example
08:55:08 <dminuoso> yeah uh, no idea. told you lens had interesting diagnostics.
08:55:34 <ezzieyguywuf> lol
08:55:50 <dminuoso> Ah wait
08:55:52 <ezzieyguywuf> maybe I will lean towards optics....
08:55:53 <dminuoso> % opt = _2 . _Just . _last
08:55:53 <yahb> dminuoso: 
08:55:56 <dminuoso> % dat ^? opt
08:55:56 <yahb> dminuoso: ; <interactive>:86:1: error:; * Could not deduce (IsString a20); from the context: (IsString a2, Snoc a2 a2 a1 a1); bound by the inferred type for `it':; forall a2 a1. (IsString a2, Snoc a2 a2 a1 a1) => Maybe a1; at <interactive>:86:1-10; The type variable `a20' is ambiguous; * In the ambiguity check for the inferred type for `it'; To defer the a
08:56:01 <ezzieyguywuf> can you redo the error with optics ?
08:56:09 <dminuoso> sure
08:56:58 <dminuoso> Oh haha
08:57:02 <dminuoso> % opt ^? data
08:57:02 <yahb> dminuoso: ; <interactive>:87:8: error: parse error on input `data'
08:57:18 <dsal> % dat ^? _2 . _Just . _last
08:57:18 <yahb> dsal: ; <interactive>:88:1: error:; * Could not deduce (IsString a20); from the context: (IsString a2, Snoc a2 a2 a a); bound by the inferred type for `it':; forall a2 a. (IsString a2, Snoc a2 a2 a a) => Maybe a; at <interactive>:88:1-25; The type variable `a20' is ambiguous; * In the ambiguity check for the inferred type for `it'; To defer the ambigui
08:57:28 <dsal> % :t dat
08:57:28 <yahb> dsal: (Num a1, IsString a2) => (a1, Maybe a2, Char)
08:57:30 <dsal> oh
08:57:34 <dminuoso> Oh indeed.
08:57:38 <dminuoso> % :set -XNoOverloadedStrings
08:57:38 <yahb> dminuoso: 
08:57:44 <dminuoso> % dat ^? _2 . _Just . _last
08:57:44 <yahb> dminuoso: ; <interactive>:91:1: error:; * Could not deduce (IsString a20); from the context: (IsString a2, Snoc a2 a2 a a); bound by the inferred type for `it':; forall a2 a. (IsString a2, Snoc a2 a2 a a) => Maybe a; at <interactive>:91:1-25; The type variable `a20' is ambiguous; * In the ambiguity check for the inferred type for `it'; To defer the ambigui
08:57:51 <dminuoso> % dat = (5, Just "foobar", 'c')
08:57:51 <yahb> dminuoso: 
08:57:54 <dminuoso> % dat ^? _2 . _Just . _last
08:57:54 <yahb> dminuoso: Just 'r'
08:58:01 <[exa]> rejoice!
08:58:03 <dminuoso> ezzieyguywuf: ^- there you go. The errors were actually unrelated.
08:58:12 <dsal> ezzieyguywuf: this kind of stuff doesn't happen in real programs where you know what types you're working with.
08:58:12 <ezzieyguywuf> üëèüëèüëèüëè
08:58:21 <dminuoso> Anyhow. You can simply bind that optic `_2 . _Just . _last` to a variable and then reuse it :)
08:58:22 <dsal> ghci confusion
08:58:36 <ezzieyguywuf> dminuoso: yes I see that. nice.
08:58:52 <dminuoso> The main issue with lens is just, there's a lot of different optics. In lens they are however all represented in this style:
08:58:53 <dminuoso> type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t
08:59:04 <dminuoso> With different lenses having different constraints
08:59:31 <dminuoso> Since this is just a type alias, any mistake will emit some weird constraint errors, where it takes some good understanding of lens to know why it went wrong.
09:00:08 <dminuoso> (And more often than not you will not see any mention of "Lens" but rather the right hand side everywhere)
09:00:20 <dsal> ezzieyguywuf: Here's a fun real world example.  I have this huge sum type that has a variety of different tagged values (from a protocol spec):  https://github.com/dustin/mqtt-hs/blob/master/src/Network/MQTT/Types.hs#L132
09:00:48 <dminuoso> % :t (_2 . _Just . _last)
09:00:48 <yahb> dminuoso: (Field2 s t (Maybe a1) (Maybe a1), Applicative f, Snoc a1 a1 a2 a2) => (a2 -> f a2) -> s -> f t
09:01:07 <dminuoso> (_2 % _Just % _last) :: (Field2 s t (Maybe v) (Maybe v), Snoc v v b b) => Optic An_AffineTraversal '[] s t b b
09:01:23 <dminuoso> The latter one tells me instantly I have constructed an affine traversal, with lens its really not that obvious...
09:01:32 <dsal> Any given packet has a list of those.  When initializing a connection, I need to find the value, if present, of a property called `PropTopicAliasMaximum` from the list of properties sent.  That's `req ^? properties . folded . _PropTopicAliasMaximum` (which is `:: Maybe Word16`)
09:01:39 <dminuoso> (It's actually a Fold in lens, but thats a different story)
09:02:39 <ezzieyguywuf> dminuoso: that's the error using optics?
09:02:41 <dsal> Many different packet types have properties, but I can access them all via `properties`
09:08:07 <dsal> > execState (both += 1) (3, 4)
09:08:09 <lambdabot>  (4,5)
09:08:13 <fog> https://gist.github.com/fog-hs/ce208cafee59133fbd030ed8979fe918
09:11:05 <dsal> ezzieyguywuf: There are a lot of dumb tricks with lens, but when you have complicated nested structure, basic lens actually simplifies things quite a bit.
09:12:42 <fog> can anyone tell why that hangs?
09:39:15 <kuribas> phadej: I think I cracked finally the type checking with foralls...
09:39:58 <MarcelineVQ> once, and, for, all
09:40:18 <kuribas> so when getting the type of a polymorphic variable, the variables are turned into unification variables.  nested variables become rigid variables, etc, alternating...
09:40:28 <kuribas> It's the opposite when checking a type.
09:40:46 <kuribas> type variable become rigid, and nested variables unification variables...
09:41:07 <kuribas> In this way I can eliminate the foralls before using the unification solver.
09:42:04 <kuribas> :t id id
09:42:06 <lambdabot> a -> a
09:43:03 <kuribas> so for the first id, a -> a, each a becomes a unification variable, for the second id, say b -> b, they become rigid.  
09:43:20 <kuribas> then a = b, so the result is forall b . b -> b
09:44:05 <kuribas> And the constraint is U a -> U a ~ V b -> V b
09:49:45 <kuribas> Btw, I wonder if let generalization becomes more of a problem when programming with typed holes.
09:50:37 <kuribas> because all the polymorphic values make it hard to infer the holes when a lot of information is missing.
09:57:15 * hackage aura 3.1.1 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.1 (fosskers)
10:01:15 * hackage dobutokO4 0.1.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.1.0.0 (OleksandrZhabenko)
10:04:29 <ski> kuribas : `a = b' ?
10:04:56 <kuribas> ski: yes?
10:05:05 <kuribas> ski: well a ~ b
10:05:41 <ski> don't you mean `a = b -> b', or something ?
10:05:55 <kuribas> ski: no?
10:06:04 <kuribas> wait...
10:06:10 <kuribas> you're right
10:07:00 <ski> anyway, that alternating stuff is how it works in e.g. lambdaProlog, with logic variables vs. skolem constants
10:07:30 <ski> sortof, at least
10:07:58 <ski> however, i'm wondering if your scheme of just eliding the quantifiers will work with multiple instantiation
10:08:18 <kuribas> ski: I create new bindings for each instantiation
10:09:21 <ski> i was thinking of `foo :: (forall a. [a] -> [a]) -> [String] -> [String]; foo p ss = map p (p ss)'
10:10:59 <ski> if you try to check this, by checking that `\p ss -> map p (p ss)' has type `([_a] -> [_a]) -> [String] -> [String]', with `_a' a fresh logic / meta- variable (aka placeholder, or, as you called it, "unification variable"), that wouldn't work, right ?
10:12:09 <ski> .. but perhaps i misunderstood what you suggested
10:12:16 <kuribas> hmm, let me see
10:14:23 <ski> (that is, i wasn't referring to multiple instantiations of outermost `forall's, resulting from multiple uses of a polymorphic value, but rather to the definition of a rank-2 one whose definition multiply instantiates its polymorphic argument)
10:14:46 <kuribas> so for (p ss) _a1 = String
10:15:10 <kuribas> then for map p (p ss), _a2 = String
10:15:18 <kuribas> that seems to work?
10:15:34 <ski> rather `Char', in the second case
10:15:49 <kuribas> eh, right
10:16:44 <kuribas> I don't get why it wouldn't work?
10:16:50 <kuribas> p gets instantiated twice?
10:16:58 <ski> if you replace `(forall a. [a] -> [a]) -> [String] -> [String]' by `([_a] -> [_a]) -> [String] -> [String]', you're effectively selecting a single instantiation for `p'
10:18:50 <L29Ah> how do i ask cabal to figure out `other-modules` for me like it does when building the source?
10:19:03 <kuribas> ski: I bind p and s when entering the lambda...
10:19:06 <ski> if, on the other hand, you wait with removing all the `forall's, just removing the outermost ones, then you get `p :: forall a. [a] -> [a]' (rather than merely `p :: [_a] -> [_a]), when checking the lambda `\p -> ..p..', and then you can instantiate that `p' more than once, in different ways
10:19:17 <L29Ah> or am i supposed to use kludges even to publish a package on hackage these days?
10:20:23 <ski> kuribas : am i making any sense ?
10:20:35 <kuribas> ski: idk
10:20:59 <kuribas> ski: when entering the lambda, I bind the arguments to it's polymorphic values.
10:21:08 <kuribas> ski: then they can be instantiated multiple times
10:21:44 <ski> i'm just saying that if your first step, in checking `foo :: (forall a. [a] -> [a]) -> [String] -> [String]; foo = \p ss -> map p (p ss)', is to remove all the `forall's from the signature, alternating by introducing skolems and placeholders, then that seems to run into the issue i just described
10:21:46 <monochrom> I think "g :: (forall a. a) -> (Char, Bool); g x = (x, x)" is a shorter example with the same features.
10:22:02 <solonarv> L29Ah: what do you mean by "kludges"? you are simply supposed to list out the modules, explicitly
10:22:13 <ski> .. but perhaps that wasn't what you were suggesting ?
10:22:41 <kuribas> ski: no, that's not what I am doing
10:22:59 <ski> (but that seemed to me to be what you were proposing)
10:23:02 <L29Ah> solonarv: but cabal knows what modules are participating when i hit `cabal build`; why should i manually type them in when i do `cabal sdist`?
10:23:10 <ski> ok, so what were you proposing, then ?
10:23:15 <L29Ah> and by "kludges" i mean "hpack"
10:23:24 <kuribas> ski: not when entering a lambda
10:23:40 <kuribas> ski: but when checking against a variable, for example a function application
10:23:48 <ski> <kuribas> so when getting the type of a polymorphic variable, the variables are turned into unification variables.  nested variables become rigid variables, etc, alternating...  <kuribas> It's the opposite when checking a type.  <kuribas> type variable become rigid, and nested variables unification variables...  <kuribas> In this way I can eliminate the foralls before using the unification solver.
10:24:20 <kuribas> ski: lambda isn't a variable
10:25:03 <ski> monochrom : yea .. although that one would need to involve some bottoms, to actually run :)
10:25:15 * hackage dobutokO4 0.1.1.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.1.1.0 (OleksandrZhabenko)
10:25:22 <ski> kuribas : i don't understand
10:25:47 <kuribas> ski: I don't do this in the foo definition, only in the foo usage
10:26:36 <kuribas> So, not here "foo = \...", but here "x = foo ..."
10:26:52 <ski> you were describing (a) checking the use of a variable whose type involves `forall's; vs. (b) checking the definition of a variable whose type involved `forall's -- yes ?
10:27:09 <kuribas> yes
10:27:19 <ski> my example was a case of (b)
10:27:25 <kuribas> no, not the definition
10:27:38 <kuribas> only in a) not in b)
10:28:03 <ski> oh, then what did "<kuribas> It's the opposite when checking a type." refer to, if not the (b) situation ?
10:29:02 <ski> (also, i have no idea what the "only" there refers to ..)
10:29:36 <kuribas> ski: I have use the information about the polymorphic variables when infering the type of "foo", otherwise it would try to infer a monomorphic type.
10:30:07 <kuribas> ski: it refers to putting a type ascription on a variable
10:30:13 <ski> (anyway, it seems to me that "not when entering a lambda","but when checking against a variable, for example a function application","lambda isn't a variable" is talking about the (a) situation .. but i dunno what you wanted to say there, or what you were objecting to)
10:30:54 <kuribas> ski: when checking a lambda, I bind the variable to it's polymorphic type
10:32:10 <ski> hmm .. i suppose "so when getting the type of a polymorphic variable" might also describe inferring a type signature involving `forall's, from a definition that is lacking an explicit signature
10:32:38 <kuribas> ski: no, I don't infer foralls
10:33:07 <ski> so for `id x = x', you don't infer `id :: forall a. a -> a' ?
10:33:29 <kuribas> well, there I do
10:34:41 <kuribas> well, I require type signatures for toplevel functions...
10:34:41 <ski> "I have use the information about the polymorphic variables when infering the type of \"foo\", otherwise it would try to infer a monomorphic type." -- do you mean `p' ?
10:34:48 <kuribas> And no generalized lets...
10:34:57 <kuribas> so I suppose it will never need to infer that...
10:35:16 <kuribas> ski: yes
10:35:35 <ski> "it refers to putting a type ascription on a variable" -- "it" being ?
10:35:50 <kuribas> ski: so if "id" is passed to (5 :: int), the inferred type will be (Int -> Int)
10:36:25 <kuribas> ski: "<kuribas> It's the opposite when checking a type."
10:36:49 <ski> "I require type signatures for toplevel functions..." -- in some type checker/inferrer that you're writing, or at least designing ?
10:36:55 <kuribas> ski: yeah :)
10:37:09 <kuribas> ski: for my own language experiment
10:37:17 * ski nods
10:38:32 <kuribas> Maybe I'll generalize toplevel functions, if that is possible with my scheme.  Then typed holes would work in toplevel functions.
10:39:00 <ski> hm. so now it sounds to me that you only "touch" top-level `forall's
10:39:43 <kuribas> indeed, I could require the user to use foralls with typed holes.
10:39:46 <ski> (which isn't at all what it sounded like to me, at first)
10:40:19 <kuribas> so toplevel types are required, but they can be holes (with a warning)
10:40:37 <kuribas> and requiring the user to provide a forall isn't so bad anyway...
10:41:11 <ski> could you elaborate about on "It's the opposite when checking a type." -- which two situations are you contrasting with each other ?
10:42:23 <ski> by "checking a type", do you mean checking a use of an identifier, or do you mean checking the definition of an identifier conforms to a given signature ?
10:42:25 <kuribas> for example (undefined :: forall a b. a -> b) :: forall a . a -> a
10:43:16 <kuribas> ski: the first
10:43:33 <kuribas> ski: identifier or expression
10:43:53 <ski> ok, since my immediate initial interpretation of that would have been (and was) the latter
10:44:12 <kuribas> sorry, I wasn't clear about that then.
10:44:52 <kuribas> so in this example, if the outer has nested foralls, they are alternating rigid and free
10:45:10 <ski> hm, so you're talking about the outer type ascription in that example, yes ?
10:45:15 * hackage shannon-fano 1.0.0.0 - Shannon-fano compression algorithm in Haskell  https://hackage.haskell.org/package/shannon-fano-1.0.0.0 (bolt12)
10:46:17 <kuribas> ski: yes
10:46:20 <ski> checking that if the the inner expresison has type `forall a b. a -> b', then it can also be used as having type `forall a. a -> a'
10:46:32 <kuribas> indeed
10:47:43 <ski> (hm, i suppose this corresponds to the checking definition against signature situation)
10:51:19 <ski> kuribas : so, if you're checking `... :: (forall a. ..a..) -> ...' (a type ascription, as in your example) would you then proceed by checking `...' has type `(.._a..) -> ...' ?
10:52:13 <kuribas> that's lots of ...
10:53:10 <ski> so, if you're checking `E :: (forall a. T[a]) -> U' (a type ascription, as in your example) would you then proceed by checking `E' has type `T[_a] -> U' ?
10:53:13 <ski> (that better ?)
10:53:59 <kuribas> yes
10:54:33 <ski> is hat also your answer to the question ?
10:54:42 <kuribas> both
10:55:23 <ski> so, how about `(\p ss -> map p (p ss)) :: (forall a. [a] -> [a]) -> [String] -> [String]' in that case ?
10:55:54 <ski> it seems you're saying you'd proceed by checking that `\p ss -> map p (p ss)' has type `([_a] -> [_a]) -> [String] -> [String]'
10:56:19 <ski> .. which would then run into the trouble i already sketched, above
10:57:45 <kuribas> ski: in that case I pass the polymorphic type to the lambda, *before* inferring.
10:58:00 <ski> oh, that's not what you said, just before
10:58:20 <kuribas> ski: well, I can treat this as a type definition, instead of ascription
10:58:59 <ski> so, the answer to my (two) question(s) before are not (both) "yes", then
10:59:23 <ski> type definition ?
10:59:33 <ski> surely there's no type being defined here
10:59:37 <kuribas> ski: in that Ast, the given type will be in the lambda, so it will be used.
10:59:55 <kuribas> ski: type declaration then
11:01:06 <ski> hm, so if `E' is a lambda, in `E :: (forall a. T[a]) -> U', you proceed (instead) by propagating the type `forall a. T[a]' to its formal parameter, yes ?
11:01:17 <kuribas> yes
11:01:33 <ski> and if it's something else than a lambda ?
11:01:41 <kuribas> also
11:02:00 <kuribas> erm...
11:02:38 <ski> "in that Ast, the given type will be in the lambda, so it will be used." -- oh, you require local parameters (and also locally defined identifiers) to come with their types ?
11:02:57 <kuribas> for example let x = 0; x :: Num a => a
11:03:31 <kuribas> ski: if they are polymorphic, then yes
11:03:57 <ski> they being the parameters, or the lambda expressions they belong to ?
11:04:10 <kuribas> the parameters
11:04:13 <ski> ok
11:04:33 <ski> what about that example ?
11:05:59 <kuribas> well, the type forall a. Num a => a is passed to the checker of x
11:06:06 <kuribas> otherwise x would be monomorphic
11:06:27 <ski> mhm
11:06:51 <ski> so if type signatures are omitted, inferred type includes no `forall's ?
11:06:51 <kuribas> but if you do let x = (0 :: forall a.Num a => a), then x is still monomorphic...
11:07:19 <ski> mm, because it'll be specialized
11:07:22 <kuribas> ski: no
11:07:48 <kuribas> though I could fix that syntactically
11:08:10 <kuribas> that let x = (y:: t) means let (x :: t) = y
11:08:48 <ski> will the inferred type of `x' there be `_a', where `Num _a' is an added constraint that is required to be solved eventually ?
11:09:09 <ski> (in the `let x = (0 :: forall a.Num a => a)' example)
11:09:32 <kuribas> ski: yes
11:10:08 <ski> and if `_a' doesn't get unified eventually ?
11:10:45 <ski> (you can imagine a situation with no constraint, if you prefer)
11:10:47 <kuribas> if it's never used?
11:10:57 <kuribas> I can wrap an forall around the free variables
11:11:10 <ski> that's `let'-generalization
11:11:30 <ski> it seemed you wanted to avoid that, for some reason
11:11:39 <kuribas> ski: it can only be free if it's never used right?
11:12:34 <kuribas> to make inference easier
11:12:55 <ski> well, consider `let rev = \case [] -> []; x:xs -> rev xs ++ [x] in length (rev [])'
11:13:38 <kuribas> but if _a is never bound, it cannot appear in the output type, nor can it give a type error.
11:13:57 <ski> `rev' should hopefully get an inferred type `[_a] -> [_a]'. and then it's used, applied to an empty list, which doesn't pin down `_a'. and the result is passed to `length', which also doesn't pin down `_a'
11:14:35 <kuribas> ski: so _a remains free, and disappears :)
11:14:36 <ski> one option is to just accept this. another would be to raise an error, or at least a warning
11:14:56 <kuribas> why would that be an error?
11:15:32 <ski> i dunno. `rev' is monomorphic, but you haven't figured out an actual specific "ground" type for it
11:16:15 <ski> in this case, `_a' stands for a concrete type, and we know there is at least one concrete type ..
11:17:02 <ski> but if you also have tyvars of other kinds, and you allow kinds to be uninhabited, then this amounts to assuming that something exists, which actually doesn't ..
11:17:24 <kuribas> ah indeed.  Then I'd beter require a type for it...
11:18:21 <ski> like if you allow something like `data Void', interpreting that not as defining a datatype, but a datakind
11:18:22 <kuribas> I wanted to disable type defaulting anyway
11:19:08 <ski> i'm not sure whether you'd run into any type safety issues or the like with this. but, at least from a logical standpoint, it seems unsatisfactory
11:19:46 <kuribas> yeah, so free type errors will be an error
11:19:52 <kuribas> free type variables I mean
11:19:53 <ski> (but if you have general recursion, then you already allow "circular reasoning", seen from the viewpoint of interpreting types of logical formulae)
11:20:47 <kuribas> I'd prefer total
11:21:18 <ski> in SML/NJ, it will turn lingering placeholders (after checking the definition, or the expression, not including checking the use/context) into skolems, actually
11:21:54 <ski> while OCaml will just let the use/context pin down the placeholders
11:22:39 <kuribas> > let rev [] = []; rev (x:xs) = rev xs ++ [x] in length (rev [])'
11:22:41 <lambdabot>  <hint>:1:64: error:
11:22:41 <lambdabot>      lexical error in string/character literal at end of input
11:22:42 <kuribas> > let rev [] = []; rev (x:xs) = rev xs ++ [x] in length (rev [])
11:22:44 <lambdabot>  0
11:22:57 <kuribas> I suppose haskell uses '()' here
11:23:09 <ski> (this occurs when the "value restriction" in the MLs strike. it's somewhat similar to DMR, prohibiting polymorphism in some cases. but it's not just a matter of expected efficiency, but actually of type safety)
11:24:30 <ski> (while, in GHC, iiuc, it will do something like in the SML/NJ case, except it'll use a single type `Any' for all of them, rather than invent a new fresh skolem for each (uninstantiated) placeholder that is not generalized upon .. which seems less sensible, to me)
11:25:38 <ski> > let rev [] = []; rev (x:xs) = rev xs ++ [x] in length (map rev (rev []))  -- `rev' is generalized here, though
11:25:40 <lambdabot>  0
11:26:12 <kuribas> and defaulted to [()] I assume
11:27:13 <ski> something like that, iirc
11:32:08 <twomashi> Would it be ok to use unsafeIOToSTM to kill another thread and wait for it to end as part of an STM transaction? 
11:34:11 <ski> what if your `STM' transaction fails, and need to be tried again later, but mutable cells that it's waiting on to change their value since last time are only changed as a consequence of that thread executing ?
11:35:31 <ski> (that is, in that case, you may want to undo the kill, and let the other thread resume some transaction that it was also in)
11:37:52 <solonarv> STM stuff has to be undoable. how do you undo a killThread ?
11:38:18 <solonarv> (this is because a transaction may run partway through, then realize it needs to abort and roll back what has been done)
11:38:50 <ski> perhaps one could have it only set a flag "i'm killed", and then maybe only actually do it on the end of a successful transaction ?
11:39:02 <ski> not sure whether it'd work out sensibly
11:39:41 <ski> in any case, it's not obvious to me that there's a sensible thing to do this
11:40:21 <ski> (and if there is one, i'd think that it involves the `killThreadSTM' not actually killing it right away)
11:43:03 <Cale> The right way to do this, I would expect, is just to return an IO action from the STM action which will be executed on commit, and which kills the threads.
11:44:11 <Cale> It almost certainly doesn't make sense to kill other threads before you're even sure the transaction is going to commit.
11:44:33 <twomashi> if both threads share a single TMVar exclusively and the thread you are killing has a `finally` handler to vacate it, i would have thought that it would be safe to kill the second thread using unsafeIOToSTM and wait for it to vacate the shared TMVar
11:45:01 <Cale> You don't know that your STM action is actually going to happen at all though.
11:45:45 <Cale> unsafeIOToSTM causes IO to occur while trying to determine what effect that the STM action is going to have, if and when it successfully commits
11:45:54 <twomashi> presumably if it didnt happen it would be because there was a deadlock detected and an exception would be raised in thread A
11:47:01 <Cale> It might just not happen because some other thread wrote to any of the variables that it read from before it was able to commit
11:49:02 <Cale> It might be that the TMVar just became empty immediately after we observed it, and now we're killing another thread that didn't deserve to be killed.
11:49:30 <Cale> We wouldn't have committed, because we'd have discovered that the TMVar became empty
11:49:30 <twomashi> in this weird use case, each thread is killing the lsat
11:49:40 <twomashi> and contending to run exclusively
11:49:54 <Cale> So what happens if both threads kill each other?
11:50:02 <Cale> with no STM transactions committing
11:50:17 <twomashi> they cant, because it's all happening inside an STM transaction that they are only calling once
11:50:18 <Cale> That doesn't seem like it makes sense to me
11:50:31 <Cale> Wait, why?
11:50:53 <Cale> If you're using unsafeIOToSTM, the atomicity guarantees go out the window
11:52:45 <Cale> It probably makes more sense to move that logic out of the STM transaction
11:53:08 <Cale> even if you're going to have threads try to kill each other to fight for control of a resource
11:53:36 <twomashi> it would be, before $routine is called, `tryTakeTMVar lock >>= mapM_ (unsafeIOToSTM cancel); putTMVar lock myHandle`. How could this deadlock if each thread is only calling it once?
11:54:50 <olavx200> Hello guys! I just finished reading LYAH. I'm planning to do read Write You A Scheme v2 https://wespiser.com/writings/wyas/00_overview.html, but I would also like to have a general Haskell book to accompany WYAS. LYAH didn't satisfy me in that regard so I would appreciate any other suggestions for Haskell books. I don't care about the price.
11:58:43 <ski> @where PIH
11:58:43 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
11:58:51 <ski> o1lo01ol1o : perhaps that one ?
11:59:11 <ski> it's suggested in here, relatively often
11:59:42 <Cale> twomashi: Well, it won't deadlock, but it does do silly things: Imagine that transaction starts executing on two threads A and B. The TMVar is initially empty, and both threads see it as such, don't kill each other, and write their handle into the TMVar. Thread A commits, thread B retries. Thread B sees the lock is full, kills thread A, and writes its handle instead.
11:59:42 <ski> @where HPFFP
11:59:42 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
12:00:12 <ski> also seems to often be referred to. some seem to like it, other maybe not as much ?
12:00:18 <scasc> .
12:00:54 <ski> i learned from "Haskell: The Craft of Functional Programming", by Simon Thompson
12:01:04 <Cale> twomashi: In the meantime, thread A will have begun to proceed with whatever IO followed this lock-acquiring transaction
12:01:20 <ski> @where SoE
12:01:20 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
12:01:23 <ski> @where HR
12:01:23 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> (broken ?),<https://web.archive.org/web/20190528043209/https://homepages.cwi.nl/
12:01:23 <lambdabot> ~jve/HR/>
12:01:29 <ski> @where HTAC
12:01:29 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:01:32 <ski> @where wikibook
12:01:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:01:39 <ski> @where CIS194
12:01:39 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
12:01:52 <ski> o1lo01ol1o : those are some more
12:02:31 <Cale> olavx200: I was going to say Graham Hutton's book is pretty good, but I'm not sure whether it would be a suitable *second* book.
12:02:33 <ski> (but yes, LYAH doesn't tend to be recommended much here, nowadays)
12:02:43 <Cale> Maybe you'd get something from it though
12:03:29 <Cale> ("Programming in Haskell")
12:03:39 <olavx200> ski: That seems a bit old.
12:03:50 <ski> which ?
12:04:13 <olavx200> "Haskell the craft of functional programming"
12:04:43 <olavx200> cale: I don't think I have a very good understanding of Haskell though. I will look into it.
12:04:46 <ski> for learning the basics of the language, i think it'd be okay
12:05:28 <wavemode> I feel like every haskell tutorial assumes you're either a complete newbie or a Ph.D.
12:05:35 <ski> i'm not sure which, if any, of the introductory books, go into any of the language extensions
12:06:23 <olavx200> What do you think about https://haskellbook.com?
12:06:40 <wavemode> oh, it's fantastic
12:06:50 <wavemode> just very long, very theoretical and kind of dry
12:09:39 <koz_> There's also PIH, which someone may have mentioned?
12:09:48 <ski> i think i heard some people seemed a bit less enthusiastic about it
12:10:02 <ski> but it seems some people like it, at least ?
12:10:39 <koz_> Personally, my Haskell book is #haskell. And it's an interactive book!
12:10:51 <Cale> ski: (you're referring to haskellbook.com, right?)
12:12:05 <ski> (one potential problem might be that it's often referred to as "the Haskell Book", which might seem to suggest that it's somehow considered an official good starting point or something, while it's just another attempt to write an introductory book)
12:12:11 <olavx200> > Personally, my Haskell book is #haskell. And it's an interactive book!
12:12:11 <olavx200> Haha, I don't want to bother you too much either ;)
12:12:13 <lambdabot>  <hint>:1:11: error: parse error on input ‚Äò,‚Äô
12:12:31 <ski> yes, Cale, HPFFP
12:13:18 <ski> @remember koz_ Personally, my Haskell book is #haskell. And it's an interactive book!
12:13:18 <lambdabot> It is stored.
12:13:53 <merijn> olavx200: It's decent. It's a bit slow paced and *very* long, but it's reasonably thorough and systematic
12:13:56 <koz_> Yay, I said a cool.
12:14:30 <ski> @quote krad
12:14:30 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
12:14:30 <lambdabot> entire human race would have to be rewritten!
12:14:50 <Cale> Yeah, pretty much same here. I haven't read it, heard a fair number of beginners like it, but I've also heard knowledgeable people say it's bad, so I'm not sure what to make of that.
12:15:36 <merijn> Cale: Well, I watched my girlfriend go through it with nearly no programming experience, so honestly the people claiming it's "terrible" are at the very least rather exaggerating
12:16:13 <merijn> koz_: Before you know it you'll be in my curated dump of lambdabot quotes ;)
12:16:36 <Cale> .oO(... or possibly influenced by the author's twitter practices)
12:17:42 <merijn> Cale: yeah, that's more likely, but then I don't stop recommending people read Ender's Game/Speaker for the Dead because Orson Scott Card is a terrible person...
12:18:03 <merijn> (Incidentally, I feel like you can tell a lot about a person by which of those two is their favourite book...)
12:18:24 <merijn> but that's probably a discussion for -offtopic :p
12:19:41 <twomashi> Cale: in this case that would be the desired behaviour. Still nervous about using unsafeIOToSTM though! Thanks
12:20:50 <merijn> twomashi: You should be ;)
12:21:06 <merijn> twomashi: If you're not nervous about using that, you probably don't understand it will enough ;)
12:22:42 <ski> (reminds me of the saying that one shouldn't use `eval' (e.g. in Lisps), unless one understands why one shouldn't use it)
12:23:44 <koz_> Yeah, eval has some very nasty implications.
12:23:50 <koz_> (in any language that has it)
12:24:17 <wavemode> lisps are the only language family in which the use of eval is appropriate and useful
12:24:24 <wavemode> it is terrible almost everywhere else
12:24:32 <koz_> wavemode: It has plenty of caveats in Lisps too.
12:26:56 <twomashi> merijn: after many years i still know only just enough to be dangerous! But that's what keeps me interested.
12:28:54 <merijn> tbh, I think we're marketing Haskell all wrong :p
12:29:34 <merijn> I think we should be bait and switching C programmers by talking about all easy ways you can break everything with super unsafe primitives and then when they're interested we just give them high level type safe programming instead
12:31:37 <wavemode> ahhh
12:31:57 <wavemode> we can attract web developers by showing them Dynamic
12:32:13 <wavemode> and OOP guys would love existentials and Typeable
12:33:00 <merijn> reallyUnsafePtrEquality#
12:36:52 <tdammers> there's acme-php, fwiw
12:37:21 <merijn> And of course, crowd favourite
12:37:27 <merijn> accursedUnutterablePerformIO
12:38:11 <koz_> merijn: What motivates its name?
12:38:24 <koz_> Like, how is it worse than just plain 'unsafePerformIO'?
12:39:45 * hackage lightstep-haskell 0.10.1 - LightStep OpenTracing client library  https://hackage.haskell.org/package/lightstep-haskell-0.10.1 (DmitryIvanov)
12:40:06 <dolio> It has some kind of safety restrictions about inlining or similar stuff turned off.
12:40:20 <solonarv> duplication to be precise
12:40:33 <merijn> solonarv: No
12:40:38 <solonarv> no? okay
12:40:40 <merijn> That's unsafeDupablePerformIO
12:41:05 <solonarv> I thought those were the same, am I misremembering?
12:41:08 <wavemode_> im guessing you're referring to inlinePerformIO?
12:41:26 <merijn> accursedUnutterablePerformIO is for when you look at unsafeDupablePerformIO and go "naah...that's entirely too safe"
12:41:29 <merijn> solonarv: No
12:41:45 <merijn> wavemode_: inlinePerformIO is the old name, yes :p
12:42:12 <solonarv> ah
12:42:16 <solonarv> I see
12:42:20 <merijn> solonarv: No, the warning for accursedUnutterablePerformIO calls out unsafeDupablePerformIO as a safer alternative :p
12:43:50 <koz_> accursedUnutterableDoNotUseThisNoWeMeanItIO
12:48:14 <dsal> Hey, I'm a super manly pro and know what I'm doing.  How do I fit that into my application?
12:48:51 <electricityZZZZ> you might want to reconsider the term "manly" in connection with "know what I'm doing" :)
12:49:11 <wavemode_> he didn't say "because" :p
12:49:41 <merijn> dsal: You can find all the good stuff in GHC.Prim :p
12:49:51 <merijn> @hackage ghc-prim
12:49:52 <lambdabot> https://hackage.haskell.org/package/ghc-prim
12:50:13 <merijn> dsal: Like the constructors of IO and Int, that sorta thing :>
12:50:33 <dsal> Oooh.   reallyUnsafePtrEquality <-- that sounds like me
12:50:55 <dsal> unsafeCoerce :: ACAB
12:51:07 <merijn> dsal: It's really unsafe, because if you use it wrong it can give you both false positives *and* false negatives :D
12:52:01 <merijn> Addr# is also good fun
12:52:03 <dsal> My haskell is too boring.  Things just work and perform well enough.
12:52:13 <maerwald> dsal: then you're just lucky
12:52:28 <dsal> I'm pretty lucky in general.
12:52:44 <maerwald> the thing is... when your luck runs out, you're in some deep sh*t :P
12:53:00 <dsal> I did have one thing that was using more memory than I felt it should.  I could've studied that, but I just shut down the project instead because it had zero users (including me).
12:53:08 <maerwald> lol
12:53:43 <merijn> I've got a great idea for a project for you that has actual users ;)
12:53:48 <dsal> It was neat, but nobody cared.  I had a thing that would allow you to set up webhooks for any arbitrary (public) github project.  A long time ago, it was part of my CI to verify upstream changes weren't in the process of breaking me.
12:54:42 <dsal> merijn: my mqtt broker is at that asymptotic 99% done point.  What kind of thing are you thinking?
12:55:03 <merijn> There's an issue with the GHC profiling that I don't have time to figure out but want fixed anyway :p
12:55:16 <olavx200> hmm
12:55:20 * olavx200 uploaded an image: image.png (34KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/TidNYguSfmWJJSkpWtGwhuqs >
12:55:21 <merijn> Actually, I have like a list of stuff I can't get around too that people should fix for me! :p
12:55:35 <dsal> Is it part of GHC?  I've set up GHC builders a few times, but I'm not super familiar with it.
12:56:12 <merijn> It's in the RTS and (probably?) part of the generated code :p
12:56:15 <merijn> It'll be an adventure!
12:56:23 <dsal> haha.  What could go wrong!?
12:57:05 <dsal> The thing I want that I know almost nothing about is dwarf debugging stuff.  I just want SIGQUIT to do the right thing.
12:57:24 <merijn> Those two are unrelated :p
12:58:03 <dsal> ^\This build does not support backtraces.  <-- that part
13:00:10 <olavx200> Alright. I'm going for PiH
13:00:36 <dsal> Hutton?
13:01:34 <trajafri> :t foldl
13:01:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:02:46 <olavx200> dsal: Yes
13:02:52 <dsal> > foldl f 0 [1..5] :: Expr
13:02:54 <lambdabot>  f (f (f (f (f 0 1) 2) 3) 4) 5
13:03:10 <dsal> olavx200: I've not looked at that one, but people seem to like it.  I should check it out sometime.
13:03:20 <olavx200> üëçÔ∏è
13:06:52 <trajafri> dsal: I forgot that Haskell's foldl function expects the accumulator first :/
13:07:02 <dsal> > foldr f 0 [1..5] :: Expr
13:07:05 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 0))))
13:07:22 <trajafri> Mostly used to Racket where the accumulator for both foldr and foldl comes second
13:07:40 <dsal> Ah.  I generally just use foldr.  My mnemonic is `x o`
13:07:48 <dsal> foldl itself is almost never what you want.
13:07:51 <dsal> foldl' maybe.
13:07:55 <trajafri> That's true
13:08:07 <dsal> If you're sufficiently fancy, just `fold`  :)
13:08:16 <trajafri> :t fold
13:08:17 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:08:28 <dsal> :t foldMap id
13:08:29 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:08:49 <dsal> > foldMap Sum [1..5]
13:08:51 <lambdabot>  Sum {getSum = 15}
13:09:13 <dsal> > getSum . fold . coerce $ [1..5]
13:09:15 <lambdabot>  error:
13:09:16 <lambdabot>      ‚Ä¢ Variable not in scope: coerce :: [Integer] -> [Sum c]
13:09:16 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòcoerced‚Äô (imported from Control.Lens)
13:09:19 <dsal> lame
13:09:56 <trajafri> :t foldMap
13:09:57 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:10:24 <trajafri> Ah nice
13:10:26 <trajafri> :i Sum
13:10:38 <dsal> > foldMap (:[]) [1..5]
13:10:40 <lambdabot>  [1,2,3,4,5]
13:10:44 <dsal> Sum is from Data.Monoid
13:24:31 <chloekek_> ala Sum foldMap [1 .. 5], but I forgot which library ala was from.
13:26:58 <Rembane> chloekek_: lens?
13:27:06 <dsal> @hoogle ala
13:27:06 <lambdabot> Control.Lens.Combinators ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
13:27:07 <lambdabot> Control.Lens.Wrapped ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
13:27:07 <lambdabot> Distribution.Compat.Newtype ala :: (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
13:27:12 <Rembane> chloekek_: https://hoogle.haskell.org/?hoogle=ala <- also
13:27:13 <dsal> When in doubt, probably lens.
13:27:20 <Rembane> It has all functions 
13:28:05 <chloekek_> lens is great, it‚Äôs always the first dependency I add to my projects so I can use <<+= to define the unique number supply function I inevitably need.
13:28:55 <trajafri> lol
13:29:36 <Taneb> chloekek_: :D
13:34:49 <dsal> :t (<<+=)
13:34:50 <lambdabot> (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
13:35:35 <chloekek_> It adds to the value in the state, then returns the old value (the value before adding).
13:36:09 <dsal> Yeah.  Makes sense.  My thing that does that is STM, so I just wrote a variant of that for STM.
13:36:11 <dmwit> ?remember chloekek lens is great, it‚Äôs always the first dependency I add to my projects so I can use <<+= to define the unique number supply function I inevitably need.
13:36:11 <lambdabot> Nice!
13:37:06 <dmwit> (Let me know if you actually consider the underscore to be part of your identity.)
13:37:52 <chloekek_> I don‚Äôt know why it appeared, probably logged in twice.
13:41:12 <tdammers> "how dare you assume I identify as having an underscore!"
13:43:29 <fnurglewitz> hi, anyone knows if there are best practices when writing clients (with servant) for endpoints with a lot of query params? (I would like to avoid functions with 15-20 params)
13:44:20 <wavemode__> you could represent them in a record type. and define a default configuration, so you only need to specify some of them
13:45:08 <fnurglewitz> so I keep the function with 20 parameters only "internally"?
13:46:03 <wavemode__> well I'm saying that if they're all wrapped in a record, you only need to have 1 parameter, which is the record itself
13:47:08 <chloekek> In that case the record constructor will have 20 parameters. One way or the other, if you need to pass 20 values to somewhere, you need to take 20 values elsewhere.
13:48:10 <wavemode__> sure but you could define `defaultParams = ParamsRecord { a = ..., b = ..., c = ... etc. }`
13:48:47 <wavemode__> If I only want to change one param, I can just specify that via update syntax: `defaultParams { one = "value" }`
13:49:02 <sfogarty> Is there a way to get type inference information for the AST obtained from Language.Haskell.Parser? For instance if a function has an undeclared type. If not, is there a pre-processor to annotate variables with types?
13:50:15 * hackage language-docker 9.0.1 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-9.0.1 (lorenzo)
13:56:35 <dmwit> sfogarty: https://hackage.haskell.org/package/thih may be relevant, or the GHC API for a more complete typechecker.
14:22:06 <slack1256> wavemode__: It seems you actually have to tame that complexity of the 20 different parameters your query allows. Servant itself won't do much it seems, apart from actually telling you that you indeed are receiving 20 parameters.
14:39:02 <wavemode_> my response was to fnurglewitz regarding him not wanting to have functions with 20 params. I don't know about any of the other details of his use case
14:53:34 <monochrom> hrm why is ghcup-0.0.2.json's timestamp perpetually Dec 31 1969? :)
14:54:51 <chloekek> Dec 31 1969 is just Jan 1 1970 in another timezone.
14:55:23 <monochrom> Ah yeah, in UTC it's that.
14:55:45 <Clint> that doesn't really answer the question
15:00:43 <chloekek> monochrom: where/how are you observing this timestamp?
15:01:41 <monochrom> .ghcup/cache
15:03:51 <chloekek> Couldn‚Äôt find any explanation in the source code or in git blame. Presumably it is done so as to increase cache utilization with tools that care about access times.
15:03:57 <chloekek> s/access/modification/
15:04:39 <chloekek> The source code explicitly sets the time: https://github.com/haskell/ghcup-hs/blob/a1282b2854efefa6a9dfb24c9a5e0dc42931ced7/lib/GHCup/Download.hs#L288
15:08:58 <maerwald> monochrom: too lazy to parse headers from curl output
15:09:07 <monochrom> heh
15:09:32 <maerwald> with the internal downloader this works better, but handling TLS connections manually is too much of a mess
15:10:28 <maerwald> so if I cannot figure out modification time, I just set it to something nonsensically safe
15:19:03 <trajafri> Need some advice. Say I have a term of type (StateT S (Reader R) A), and I want to use 'withReader' on this term. What is the cleanest way to achieve this?
15:20:35 <trajafri> :t lift
15:20:36 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
15:20:54 <trajafri> Ah wait I remember now (I think)
15:27:12 <trajafri> Nah lift doesn't really work here since the term I have is already wrapped with the StateT type, hmm
15:30:01 <trajafri> My current solution was to just use 'local' since it expects a 'MonadReader'. I would still be interested to see how to make this work with 'withReader' (if that's even possible)
15:30:12 <dsal> I've not used withReader
15:30:14 <dsal> :t withReader
15:30:16 <lambdabot> (r' -> r) -> Reader r a -> Reader r' a
15:30:17 <dsal> :t local
15:30:18 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
15:37:04 <slack1256> It's like a primitive version of `zoom` from before the EE.
16:11:15 * hackage autoexporter 1.1.17 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.17 (fozworth)
16:13:45 * hackage burrito 1.1.0.1 - Parse and render URI templates.  https://hackage.haskell.org/package/burrito-1.1.0.1 (fozworth)
16:15:45 * hackage wuss 1.1.17 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.17 (fozworth)
16:16:45 * hackage salve 1.0.10 - Semantic version numbers and constraints.  https://hackage.haskell.org/package/salve-1.0.10 (fozworth)
16:18:15 * hackage rampart 1.1.0.1 - üè∞ Determine how intervals relate to each other.  https://hackage.haskell.org/package/rampart-1.1.0.1 (fozworth)
16:19:15 * hackage list-singleton 1.0.0.4 - Easily and clearly create lists with only one element in them.  https://hackage.haskell.org/package/list-singleton-1.0.0.4 (fozworth)
16:21:15 * hackage lackey 1.0.13 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-1.0.13 (fozworth)
16:23:15 * hackage json-feed 1.0.11 - JSON Feed  https://hackage.haskell.org/package/json-feed-1.0.11 (fozworth)
16:24:14 * hackage flow 1.0.21 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.21 (fozworth)
16:25:14 * hackage derulo 1.0.9 - Parse and render JSON simply.  https://hackage.haskell.org/package/derulo-1.0.9 (fozworth)
16:26:44 <texasmynsted> Is there some dhall alternative that does not change the ordering?
16:26:56 <dsal> dhallternative, if you will.
16:27:04 <dsal> I wasn't aware dhall affected ordering.
16:27:04 <texasmynsted> lOLOL
16:27:47 <dsal> I tend to use megaparsec.  I've used dhall in one project and it was OK, but doing anything it doesn't already do is kind of a pain.
16:30:36 <texasmynsted> It does change ordering. If I have things defined in dhall and convert to json, the json entities are not in the order I defined them in dhall but in alphabetical order.
16:30:46 <texasmynsted> https://github.com/dhall-lang/dhall-haskell/issues/1187
16:31:40 <texasmynsted> hmm magaparsec sounds overkill for my needs. I will check though
16:33:21 <Rembane> texasmynsted: Are you using it for config files?
16:34:49 <texasmynsted> yes
16:35:08 <texasmynsted> dhall seems improved over using raw JSON
16:37:04 <Rembane> texasmynsted: Do you need arbitrary nesting? 
16:37:19 <texasmynsted> I doubt it
16:37:43 <Rembane> Could this be useful? https://hackage.haskell.org/package/ini-0.4.1/docs/Data-Ini.html
16:37:46 <texasmynsted> If I do, I can change plans at that time
16:38:10 <texasmynsted> nice
16:38:16 <texasmynsted> Looks a bit like TOML
16:38:22 <texasmynsted> Thank you. I will check it out.
16:38:42 <Rembane> It is the older cousin to TOML, it's from the countryside and hasn't gone to college. 
16:39:04 <texasmynsted> LOL
16:39:08 <texasmynsted> :-)
16:39:16 <texasmynsted> Sounds great
16:40:43 <Rembane> ^^ or to put it another way, TOML was IIRC an effort to formalize the syntax of ini files. 
16:43:29 <yushyin> I like it, if you don't need nesting it is mostly like INI, but if you do need nesting eventually there is no problem either
17:03:44 <nshepperd2> did something change in ghc 8.10? the type signature "forall (xs :: [k]) (ys :: [k]). stuff" is now throwing a "Not in scope: type variable ‚Äòk‚Äô" error?
17:04:17 <nshepperd2> i guess i have to explicitly mention k now?
17:05:35 <yushyin> https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/8.10#ghc-810x-migration-guide
17:08:07 <nshepperd2> i see
17:09:03 <nshepperd2> wasn't there some sort of syntax to forall a type variable without making it visible for TypeApplications purposes
17:39:21 <slack1256> If I set up a break point with ghci on a program, can I inspect how deep is currently evaluated an ADT?
17:39:45 <slack1256> I would like to check that the state passed on the event loop of a my program is fully evaluated at each iteration.
17:41:24 <c_wraith> I believe :sprint only shows the evaluated portion of a data structure
17:44:07 <slack1256> c_wraith: This could work!
17:52:26 <koz_> What does optics-core mean by a 'Naperian container'?
17:52:34 <koz_> Specifically here: http://hackage.haskell.org/package/optics-core-0.3/docs/Optics-At-Core.html#t:IxKind
17:56:24 * ski . o O ( "What is a Naperian container?" by Container Types in 2005-06-19 at <https://web.archive.org/web/20170313140037/http://sneezy.cs.nott.ac.uk/containers/blog/?p=14> )
17:57:29 <ski> basically, the valid paths to elements doesn't depend on the particular container value. all containers of the type have the same paths to elements
17:59:06 <slack1256> /Sheer testosterone/
17:59:21 <slack1256> I dropped my tea, I wasn't expecting that.
18:00:33 <ski> sounds like typical McBride
18:05:45 * hackage aop-prelude 0.3.1.0 - prelude for Algebra of Programming  https://hackage.haskell.org/package/aop-prelude-0.3.1.0 (KatsutoshiItoh)
18:16:30 <dmwit> texasmynsted: You might also like http://hackage.haskell.org/package/config-value
18:38:45 <texasmynsted> okay dmwit I will check it out. Thank you
18:39:50 <koz_> :t foldM
18:39:52 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
18:49:15 * hackage static-text 0.2.0.6 - Lists, Texts, ByteStrings and Vectors of statically known length  https://hackage.haskell.org/package/static-text-0.2.0.6 (DmitryDzhus)
19:32:45 * hackage tagstream-conduit 0.5.6 - streamlined html tag parser  https://hackage.haskell.org/package/tagstream-conduit-0.5.6 (YiHuang)
19:38:21 <xe4> how can I make hspec not eat my print statements in my libraries?
19:38:35 <xe4> how can I make Haskell crash with a message?
19:38:50 <xe4> I've tried panic from the GHC library
19:39:09 <xe4> I've tried throw from Control.Exception
19:45:21 <lyxia> You tried that, then what happened?
19:46:25 <lyxia> throw should be the right way but there's a ton of detail you could be omitting about your situtation
19:49:34 <xe4> nothing happened, the test suite kept running
19:49:49 <xe4> there's no way I can put all of this into a gist. guess I will just give up
19:50:41 <wavemode_> xe4: throw and error and panic only do something if they are evaluated. laziness is probably causing them to be ignored
20:02:05 <koz_> @pl \x -> guard (foo . bar $ x) $> Baz x
20:02:05 <lambdabot> ap (($>) . guard . foo . bar) Baz
20:02:47 <koz_> :t \f g -> (($>) . guard . f) <*> g
20:02:48 <lambdabot> error:
20:02:48 <lambdabot>     ‚Ä¢ Variable not in scope: ($>) :: f0 () -> a1 -> b
20:02:48 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
20:02:56 <koz_> % :t \f g -> (($>) . guard . f) <*> g
20:02:56 <yahb> koz_: Alternative f => (a1 -> Bool) -> (a1 -> a2) -> a1 -> f a2
20:03:23 <koz_> Hmmm.
20:04:48 <dsal> xe4: If your problem is too complicated to demonstrate, that might be the problem.
20:05:19 <koz_> % @pl \x -> (x, x)
20:05:19 <yahb> koz_: ; <interactive>:120:1: error: parse error on input `@'
20:05:25 <koz_> Aww, so yahb lacks a PL.
20:07:32 <koz_> Can @pl understand 'case ... of ...'?
20:07:38 <koz_> And if so, how do I spell it for it?
20:12:19 <dsal> Weird.  @pl is the pointfree command.  You might try it interactively.
20:12:43 <dsal> https://hackage.haskell.org/package/pointfree
20:13:28 <koz_> @pl \x -> case x `rem` 2 of 0 -> True; _ -> False
20:13:28 <lambdabot> (line 1, column 29):
20:13:28 <lambdabot> unexpected '>'
20:13:28 <lambdabot> expecting operator
20:13:37 <koz_> ^ is what I'm confused about.
20:14:45 <dsal> Yeah.  I tried a few things and couldn't figure it out.  heh
20:37:15 * hackage d10 0.2.1.6 - Digits 0-9  https://hackage.haskell.org/package/d10-0.2.1.6 (chris_martin)
20:43:14 * hackage partial-semigroup 0.5.1.8 - A partial binary associative operator  https://hackage.haskell.org/package/partial-semigroup-0.5.1.8 (chris_martin)
20:49:04 <monochrom>  @pl doesn't know a lot of haskell syntax.
20:51:59 <koz_> monochrom: I guess case-of is one thing it doesn't know?
20:54:15 * hackage deriving-aeson 0.2.6 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.6 (FumiakiKinoshita)
20:54:40 <monochrom> right
20:56:03 <koz_> :(
20:56:05 <koz_> Oh well.
21:01:44 * hackage franz 0.3 - Append-only database  https://hackage.haskell.org/package/franz-0.3 (FumiakiKinoshita)
22:08:28 <disconsis> Hey, is there any way to have guards inside guards?
22:08:37 <disconsis> Sort of like nested if's
22:08:57 <dsal> disconsis: You can use &&
22:09:02 <dsal> What are you trying to do?
22:09:04 <koz_> disconsis: [insert Xzibit joke]
22:09:15 * hackage barbies-th 0.1.3 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0.1.3 (FumiakiKinoshita)
22:09:16 <utdemir[m]> Otherwise -XMultiWayIf will look pretty similar.
22:09:28 <wavemode_> well a guard can be any Bool expression
22:09:47 <disconsis> basically this: if <something> then  (if <something> then <something> else <something>) else ...
22:10:09 <dsal> something  || (something && something)
22:10:09 <disconsis> I just want to avoid writing the first condition over and over again
22:10:15 <Axman6> sounds  like a data type to me
22:10:29 <Axman6> with a case statement
22:10:39 <dsal> :t and
22:10:40 <lambdabot> Foldable t => t Bool -> Bool
22:11:35 <wavemode_> perhaps `case (<something>,<something>) of (True, False) -> <result>; (False, False) -> <result>` etc.
22:12:25 * utdemir[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/OlerHdwIexBxwRQqCJrnQEQc >
22:12:43 <disconsis> Umm I'm thinking something like this:
22:12:54 <disconsis> f x y
22:12:54 <disconsis> | x == 5 | isOdd y = "first"
22:12:54 <disconsis> | isPrime y = "second"
22:12:54 <disconsis> | y == 8 = "third"
22:12:55 <disconsis> | y == 9 = "fourth"
22:12:56 <disconsis> instead of
22:12:57 <disconsis> f x y
22:12:58 <disconsis> | x == 5 && isOdd y = "first"
22:12:59 <disconsis> | x == 5 && isPrime y = "second"
22:13:07 <Axman6> utdemir[m]: FYI, your message was turned into a link by Matrix, and people may not read it
22:14:03 <Axman6> nice alternative though
22:14:09 <wavemode_> you can write `f 5 y` instead of `f x y`
22:14:46 <Axman6> they got kicked by freenode for spam
22:14:58 <wavemode_> oof
22:18:44 <dmwit> f x y = case x of 5 | isOdd y -> 1 | isPrime y -> 2 | ...
22:22:15 * hackage natural 0.3.0.5 - Natural number  https://hackage.haskell.org/package/natural-0.3.0.5 (TonyMorris)
22:40:34 <liiae> that newtype Fix f = Fix (f (Fix f)) can represent on other languages? like Java?
22:40:40 <liiae> or kotlin
22:40:45 * hackage winery 1.2 - A compact, well-typed seralisation format for Haskell values  https://hackage.haskell.org/package/winery-1.2 (FumiakiKinoshita)
22:42:15 * hackage json-api-lib 0.3.0.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.3.0.0 (shirren)
22:43:50 <liiae> how to random generate 6 digits?
22:44:49 <EvanR> figure out how to generate 1 random digit then use it 6 times in a row
22:45:49 <liiae> @hoogle System.Random
22:45:49 <lambdabot> module System.Random
22:45:49 <lambdabot> System.Random class Random a
22:45:49 <lambdabot> System.Random.TF.Instances class Random a
22:47:35 <dsal> > randomRs (100000, 999999) <$> mkStdGen 42
22:47:37 <lambdabot>  error:
22:47:37 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äòf g0‚Äô with actual type ‚ÄòStdGen‚Äô
22:47:37 <lambdabot>      ‚Ä¢ In the second argument of ‚Äò(<$>)‚Äô, namely ‚ÄòmkStdGen 42‚Äô
22:48:18 <dsal> > randomRs (100000, 999999) $ mkStdGen 42
22:48:19 <lambdabot>  [879909,339109,974555,943952,561954,603629,494356,619509,987496,743113,43900...
22:48:24 <dsal> Wrong random number generator...
22:48:58 <dsal> The best part about doing it that way is you always get the same random numbers.
22:49:28 <liiae> dsal: what about newStdGen?
22:49:39 <liiae> > newStdGen
22:49:41 <lambdabot>  <IO StdGen>
22:52:27 <dsal> :t getStdGen
22:52:28 <lambdabot> IO StdGen
22:54:11 <EvanR> 100000 to 999999 is funny... but doesn't produce e.g. 099999
22:55:00 <dsal> I guess you could do 0 and pad it.
22:55:08 <dsal> % snd . randomR (0, 999999) <$> getStdGen
22:55:08 <yahb> dsal: 683135771 652912057
22:55:32 <EvanR> replicateM 6 (randomRIO (0,9))
22:56:12 <dsal> Oh, I didn't even see that one.  I figured it'd be part of RIO
22:56:36 <EvanR> i forgot how to use yahb 
22:56:36 <dsal> % replicateM 6 (randomRIO (0, 9))
22:56:36 <yahb> dsal: [3,4,0,2,0,8]
22:56:39 <EvanR> ah
22:56:41 <wavemode_> lol. yeah it looks like ramdom RIO but it's randomR IO
22:56:59 <dsal> % replicateM 6 (randomRIO ('0', '9'))
22:56:59 <yahb> dsal: "328038"
22:57:09 <EvanR> noise
23:00:53 <liiae> newStdGen >>= \x -> return $ randomR (0,999999) x
23:01:35 <dsal> Why newStdGen?
23:02:05 <liiae> random seed? different number for different time?
23:02:12 <dsal> And that's a complicated way to do a functor.
23:02:43 <liiae> if the seed isn't random, then how we can get a random number?
23:03:08 <dsal> You just put a random number in the seed.
23:03:15 <dsal> Then out comes random numbers.
23:03:37 <liiae> dsal: how todo that?
23:03:47 <dsal> With a random number generator, obviously.
23:03:47 <wavemode_> you can put in the current time
23:04:19 <dsal> What are you using the random number generator to do?
23:04:58 <liiae> nothing, just for fun
23:05:07 <dsal> I just use getStdGen.  Is that not working for you?
23:05:20 <liiae> getStdGen always get the same seed
23:06:18 <dsal> Weird.  I get different answers every time I run my program.
23:07:30 <liiae> > getStdGen >>= print
23:07:32 <lambdabot>  <IO ()>
23:08:45 <dsal> lambdabot can't print
23:08:49 <liiae> is there a function do f:: IO a -> [a]?
23:09:00 <liiae> natual transformer?
23:09:11 <dsal> :t fmap (:[])
23:09:12 <lambdabot> Functor f => f a -> f [a]
23:09:27 <dsal> Oh wait, you want to extract the value from IO?  That's not a thing.
23:09:39 <liiae> can we?
23:10:22 <dsal> You can send functions into IO, but you can't pull values out of it.
23:12:32 <liiae> unsafePerforIO?
23:13:27 <liiae> > unsafePerformIO getStdGen
23:13:29 <lambdabot>  error:
23:13:29 <lambdabot>      Variable not in scope: unsafePerformIO :: IO StdGen -> t
23:14:36 <liiae> dsal: unsafePerformIO getStdGen works well in my ghci
23:14:49 <liiae> normal?
23:14:58 <Axman6> don't do that
23:14:59 <dsal> The name is kind of a hint.
23:15:18 <liiae> and then why people create it?
23:15:40 <Axman6> because there are legitimate uses for it, but you do not have one
23:15:40 <dsal> That's not the right question.
23:16:08 <liiae> what's the right question?
23:16:38 <wavemode_> it's for when the thing you're doing with it is actually pure (i.e. calling some C code which is pure). generating random numbers is not pure
23:16:51 <Axman6> guns exist, but we don't use them for cleaning dirt off tiles - it could work but asking "then why do guns exist" is definitely the wrong question when "how do I clean tiles" is the real question
23:16:56 <wavemode_> using it with something impure is very unsafe
23:17:12 <dsal> I'm not even sure.  I don't know what you're trying to do.  But if you stumble upon unsafePerformIO to get a value out of IO as a hack, then you're going down a dark path.
23:17:37 <dsal> Whatever it is you're trying to do might have a question that's like,. "how do I do this?"
23:18:11 <dsal> Right now, we're at the http://xyproblem.info/ level of "I know, I'll `unsafePerformIO` a random number generator!"
23:21:24 <liiae> ok
23:24:54 <dsal> The thing you're trying to do, assuming you're in the IO monad, is basically   `arse <- take 6 . randomRs (0, 9) <$> getStdGen`
23:25:11 <dsal> Or just randomRIO
23:33:11 <jchia> Q about streaming package: Let's say I have a Stream (Of Text) IO () and I want to do 2 things with it. I want to putStrLn each item in it and then print the length of the stream. If I separately use mapM_ and length/length_ to putStrLn the elements and compute the length, will I end up going over the stream with 2 passes instead of 1 and thus end up using more than O(1) memory? If this results in 2 passes, how can I fuse the 2 transfor
23:33:11 <jchia> mations so that I do both of them at once in 1 pass?
23:33:55 <jchia> Here's what I mean by doing things separately: 1. mapM_ putStrLn str and then 2. print . length_ $ str
23:34:09 <jchia> where str :: Stream (Of Text) IO ()
23:36:52 <jackdk> this seems like the sort of thing that the `foldl` package lets you avoid in the pure setting. not sure if there's similar stuff for streaming
23:37:10 <jchia> yeah, then the question would be how to use streaming and foldl together
23:38:27 <jackdk> so `length_` is the number of items in the stream?
23:39:21 <jchia> yes. https://hackage.haskell.org/package/streaming-0.2.3.0/docs/Streaming-Prelude.html#v:length_
23:40:04 <jchia> I can probably explicitly combine the two thing myself using some low-level functions from streaming but I wonder if there's a simple idiomatic way.
23:43:50 <liiae> dsal: can we get that random from StdGen?
23:44:07 <liiae> I saw data StdGen = StdGen !Int32 !Int32
23:44:17 <jackdk> maybe you can hoist the IO into a StateT Int IO and increment a counter as you consume the list?
23:45:04 <jackdk> I don't have a good answer but I'm interested to know if there is one
23:45:34 <jchia> Seems likes something that people would want to do very often when they use something like streaming/conduit/pipes
23:45:43 <jchia> combining multiple computations in one pass
23:46:27 <liiae> getN :: StdGen -> Int
23:46:33 <liiae> getN StdGen x y = x
23:46:41 <liiae> why it doesn't work?
23:47:02 <liiae> after import System.Random, and it still said StdGen is not in the scope
23:49:26 <jchia> liiae: When you import that, you can use the type StdGen, but you still can't use the value constructor
23:49:41 <jchia> if you want a value of type StdGen, you still can use something like mkStdGen
23:50:33 <jackdk> jchia: maybe you can do something with the `Alternative` instance, which seems zippy
23:52:24 <dsal> liiae: the code I pasted above does that within io.  If you're writing pure code, the concept of random doesn't even make sense, so you can just generate the number and feed it into pure code.
