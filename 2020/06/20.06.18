00:04:14 <no-n> MOo
00:20:51 <no-n> I have not done much with Haskell for a number of years. I want to relearn it but I also want to learn Rust. Should I learn one before the other for any good reason, or doesn't matter?
00:21:56 <c_wraith> If you were familiar with Haskell at one point, it'll be pretty quick to pick it up again.  Even if the ecosystem has changed in some important ways, the core language is very similar.
00:22:43 <no-n> good point :)
00:23:05 <no-n> also, how much did Haskell influence Rust?
00:23:20 <no-n> sorry if the question is off-topic
00:23:29 <c_wraith> Somewhat.  The trait system is almost identical to type classes
00:23:49 * hackage haskus-utils-compat 1.1 - Compatibility modules with other external packages (ByteString, etc.)  https://hackage.haskell.org/package/haskus-utils-compat-1.1 (SylvainHenry)
00:23:51 <hc_> c_wraith: that sounds reassuring :)
00:24:05 <hc_> I call rust a pragmatic version of haskell ;)
00:24:24 <c_wraith> Meh.  Rust is only pragmatic if you need to care about every allocation and deallocation.
00:24:26 <hc_> though that is kinda misleading, as rust is quite different in many important ways. One thing I miss most is the non-strictness
00:24:59 <c_wraith> If your constraints need that, rust is great.  If they don't, you have to spend a lot of mental energy on it.
00:25:20 <hc_> nah, it becomes quite natural quite easliy
00:25:54 <hc_> the problem imho is more that some constructs that are easily expressed in haskell are complicated to express in rust because they don't really work without a gc
00:26:03 <c_wraith> That's the same thing I meant.
00:26:08 <hc_> :)
00:26:45 <c_wraith> "Here's this really easy decomposition of the problem into trivial parts that work independently in Haskell.  But it doesn't work in Rust because you can't just say the consumer will take care of it."
00:28:47 <c_wraith> Also, I'm the kind of person who misses higher-rank types.  I use them a lot in Haskell, and there's basically no chance they'll ever be in rust.
00:29:56 <c_wraith> They work cleanly in ghc because it uses a uniform runtime representation for (lifted) types.  Rust is committed to never doing that.
00:30:26 <hc_> What I love about rust is its speed (not compilation speed, though;). I implemented a deflate algorithm in haskell a few years ago and then did a very similar one in rust. It's 8 times as fast
00:30:41 <dminuoso> hc_: Why would you suggest that Haskell was not pragmatic?
00:31:05 <hc_> dminuoso: because it doesn't compromise in areas where rust does
00:31:26 <dminuoso> Can you name some examples?
00:31:36 <hc_> dminuoso: it was more an intuition.. let me think of some :)
00:31:48 <no-n> I guess I'm interested in rust because I want a nicer C/C++. sounds like it has some nice things but will never have them all :P
00:32:04 <c_wraith> Rust is a great choice if you want a better C++
00:32:15 <c_wraith> It's just a really bad choice if you want Haskell :)
00:32:51 <no-n> ok, sure. Haskell is attractive to me also for making debugging easier, and writing code with guarantees
00:33:13 <dminuoso> Even the performance argument is relatively mood. GHC Haskell has pretty darn good performance, but not as good as say Clean.
00:33:19 <hc_> dminuoso: rust uses many concepts from haskell, but only when it doesn't affect execution speed. so rust gets pragmatic when it helps the execution speed, while haskell tries to stay correct/elegant first and make it as fast as possible under this condition
00:33:41 <hc_> though I'll admit that's only partly correct
00:33:46 <dminuoso> hc_: That sounds very handwavy. What particular concept did rust people "explicitly forego to include for execution speed"?
00:34:22 <hc_> dminuoso: I'd say a GC (which makes many things impossible/very hard), lazyness mostly
00:34:28 <dminuoso> About the only choice that limits our execution speed is that GHC cant (yet) implement mutability when its provably right to do so.
00:34:42 <dminuoso> hc_: I dont think either is true, really.
00:35:01 <hc_> dminuoso: no thunks in rust... i think thunks make things slower... also memory/cache wise?
00:35:06 <dminuoso> The GC limits our ability to do low latency things (work is being done there currently!), but for general performance the GC is not in the way.
00:35:26 <dminuoso> hc_: You have all the tools to manipulate memory directly in Haskell, to abuse cache as much as you want.
00:35:40 <dminuoso> You can work with unpacked data structures, byte buffers..
00:35:47 <hc_> dminuoso: I meant cache locality for minimizing RAM access
00:36:09 <hc_> dminuoso: okay, fair enough. I did that with the ST monad for the deflate implementation... still much slower than my rust version
00:36:18 <hc_> I never found the precise reason why..
00:36:21 <dminuoso> hc_: Perhaps you made some other mistake? :)
00:36:27 <hc_> Very likely, yes
00:37:23 <hc_> I'll have to revisit that algorithm at some time and try to speed it up again
00:38:29 <dminuoso> For what its worth, if you do have some key parts that need special performance, it's likely isolatable algorithms, for which you can just ffi out of Haskell.
00:38:51 <dminuoso> For general program performance, I'd say Haskell can keep up with other languages because of the large scale program transformations that are doable.
00:38:56 <hc_> I specifically re-implemented that algorithm in haskell to get the safety of it :)
00:39:14 <hc_> The original C version had various security problems
00:45:17 <[exa]> hc_: haskell can be quite fast if you use the memory facilities in the functional way and avoid the usual C and Rust-style array picking
00:46:15 <[exa]> hc_: usually you need to revamp the algorithm design and place a bit of strictness allocations here and there, and then you should get roughly the same speed
00:46:58 <hc_> fair enough
00:47:54 <[exa]> at the same time, it's usually best to invest a tiny bit of time to produce a safe C version that you can FFI (from whatever language you like)
00:48:44 <hc_> C is inherently unsafe IMHO
00:49:31 <[exa]> I usually say that it's a sharp tool with widely misunderstood aims
00:51:06 <[exa]> and the code is just as safe as you write it :]
00:52:17 <srk> .. or generate safe C with Ivory :D
00:52:26 <[exa]> ^ +1
00:53:49 <[exa]> also, the available truckload of static analyzers helps quite a bit
00:55:03 <srk> they only get you so far, then you start poking verification :)
00:55:37 <hc_> srk: ivory is actually a good suggestion :)
00:57:14 <srk> it's even easier to write compared to plain C (especially if you already know Haskell) as it makes it way harder to shoot yourself in the foot
00:57:49 <dminuoso> C makes it harder to do whta?
00:58:04 <merijn> dminuoso: everything :p
00:58:11 <srk> write memory safe programs :)
00:58:45 <dminuoso> :)
00:58:46 <[exa]> hc_: btw what kind of deflate you have there? (try streaming libraries?)
00:58:53 <dminuoso> srk: I have a better idea.
00:58:56 * [exa] hears whizzes of incoming C flame
00:59:02 <dminuoso> Generate C with GHC Haskell!
00:59:04 * srk is a heavy Ivory user for embedded programming
00:59:13 <dminuoso> (Does that C backend still exist?)
00:59:32 <srk> dminuoso: well, if I can disable GC and laziness it could work .. :D
00:59:45 <srk> was that hugs?
00:59:52 <dminuoso> srk: You can malloc things as much as you want.
01:00:17 <hc_> [exa]: it's a "proprietary flavour" of it ;)
01:00:18 <dminuoso> https://hackage.haskell.org/package/base-4.14.0.0/docs/Foreign-Marshal-Alloc.html#v:malloc
01:00:21 <dminuoso> :p
01:00:54 <hc_> [exa]: the implementation is on hackage, though: http://hackage.haskell.org/package/hascar-0.2.2.1/docs/Codec-Archive-SAPCAR-FlatedFile.html
01:01:49 <srk> dminuoso: yes but the reason I'm using ivory/tower is to be able to write programs for e.g. stm32 devices with like 32kb of ram and 128kb of flash. it's not running Haskell per se on these, merely using it as a meta language for code generation
01:03:29 <no-n> srk, nice :o
01:04:11 <[exa]> hc_: okay that could be interesting to profile
01:05:22 <[exa]> hc_: are all the bitstream-handling functions inlined? (inliner is sometimes reluctant to work across modules)
01:06:05 <hc_> [exa]: I don't even know how to check that tbh
01:07:03 <hc_> [exa]: also, I only implement the decompression part (so far). here is a test file ( https://github.com/hce/hascar/blob/master/test/test6.sar ) in case you want to have a look at it ;)
01:07:39 <[exa]> hc_: there's a relatively brutal list of techniques here https://wiki.haskell.org/Performance
01:08:48 <hc_> [exa]: thanks!
01:10:04 <[exa]> hc_: generally, you want to avoid stuff randomly allocating/examining thunks (strictness annotations help a lot) and inline as much as possible (fill INLINE pragmas into the libraries)
01:10:21 <[exa]> s/thunks/boxes in general
01:11:15 <[exa]> ...and well, profile first. ;]
01:19:18 <kuribas> dminuoso: finally I'll go for "IO" or "LoggerT MyMessage IO a" for all my low level functions.
01:19:52 <kuribas> dminuoso: I could also use (MonadIO m, MonadLogger m) => m a, but that's less efficient
01:20:10 <kuribas> dminuoso: I'll pass the reader stuff directly
01:21:48 <joelg> In the definitions of foldl and foldr, it is entirely up to the implementing datastructure to decide what "left" and "right" mean, correct?
01:25:51 <kuribas> joelg: kind of, it should still be a logical choice
01:26:16 <xerox_> joelg: tha doc says «For a general Foldable structure this should be semantically identical to foldl f z = foldl f z . toList» so that does probably give you some constraints (same for foldr)
01:26:56 <joelg> xerox_: So if there is also some toList function (or some other way of extracting a sequence) it should be compatible with that
01:27:11 <joelg> makes sense
01:27:13 <kuribas> joelg: left means "from the start", right "from the end"
01:27:34 <xerox_> it's one of the members of Foldable
01:30:26 <joelg> Right, but if you're deciding how to implement both foldl and toList, you can't use one to figure out the other, but they should be compatible
01:36:22 <kuribas> from left meaning from the start could be a western thing, it may seem backwards for japanese
01:36:47 <kuribas> as for a japanese the start is right
02:02:18 * hackage hercules-ci-agent 0.7.2 - Runs Continuous Integration tasks on your machines  https://hackage.haskell.org/package/hercules-ci-agent-0.7.2 (RobertHensing)
02:09:18 * hackage fast-downward 0.2.1.0 - Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward.  https://hackage.haskell.org/package/fast-downward-0.2.1.0 (OliverCharles)
03:07:55 <wudis> lambdabot: @type msum
03:07:56 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
03:58:12 <boxscape> hm apparently repl.it doesn't stop compiling if you have a file beginning with {-# LANGUAGE RankNTypes ConstraintKinds #-}. Is that normal for ghc 8.6.5 (which it uses)? Would surprise me...
03:58:51 <boxscape> (well it stops compiling if you tell it to stop, but it never successfully completes)
03:59:03 <boxscape> (I think, halting problem and all)
03:59:05 <fog> ok, i still want to update the contents of a hetrogenous list, and i think a good place to strat is;
03:59:05 <fog> type Setter s t a b = (a -> Identity b) -> s -> Identity t
03:59:21 <fog> from the top of;
03:59:21 <fog> http://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Setter.html#t:Settable
03:59:48 <fog> how do i make instances to be able to use that?
04:00:34 <fog> or is that not how lens works (expecting there to be a class to instantiate)
04:02:39 <fog> i can see this, further down the docs;
04:02:40 <fog> sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b
04:02:53 <fog> which somehow is apparently the same as;
04:02:54 <fog> sets :: ((a -> b) -> s -> t) -> Setter s t a b
04:04:27 <fog> i still cant see where there are actual instances that can allow this to work on some container
04:06:10 <fog> it seems more just like a type that could express some setting function if i managed to implement it
04:06:31 <fog> but nothing like a class to instantiate that would actually produce such an implementation
04:08:04 <phadej> :t sets fmap
04:08:05 <lambdabot> (Settable f1, Functor f2) => Optical (->) (->) f1 (f2 a) (f2 b) a b
04:08:17 <phadej> that's how you implement `mapped` setter
04:08:41 <fog> i think; Optical (->) (->) Identity ~ Setter
04:09:08 <fog> and it says all Settable f instances are f ~~~ Identity
04:09:20 <phadej> step 1: implement functon (a -> b) -> HListWithA -> HListWithB
04:09:28 <phadej> step 2: use sets to turn it into Setter
04:09:33 <phadej> step 3: you are done
04:09:50 <fog> phadej: right, it seems like you need to provide it with an implementation directly (your step 1.)
04:09:52 <phadej> there is no step "think about how lens encodes it objects"
04:10:17 <phadej> yes, working with encoding directly is not productive
04:10:22 <phadej> example:
04:10:42 <fog> so there is no interface for like, creating setters. you would have to have a functor instance or something, to use fmap
04:10:59 <phadej> no
04:11:06 <fog> i cant write fmap for hetrogenous containers
04:11:10 <phadej> you need (a -> b) -> (s -> t) function
04:11:16 <fog> every value would require a different mapping opperation
04:11:17 <phadej> fmap just fits that 
04:11:51 <phadej> let me phrase it again, (a -> b) -> (s -> t) and Setter s t a b can be converted into each other
04:11:51 <boxscape> fog every type, not every value
04:12:04 <fog> damn. i thought it could leverage its template haskell magic to be able to derive these kind of things for fairly general types
04:12:15 <phadej> the (a -> b)  -> (s -> t) is in 99% cases easier to construct that Setter directly (in whatever encoding is used)
04:12:57 <fog> surely there would be some way to create it from some more elementary thing
04:13:12 <fog> like, if i can "set" one value, i should be able to make an fmap implementation
04:13:21 <fog> something like that but in reverse
04:13:31 <phadej> compare, writing `myFieldLens = lens myField (\s x -> s { myField = x })`, vs. `myFieldLens f s = f (myField s) <&> \x -> s { myField = x }`
04:13:41 <fog> oh right, thats just using fmap as a setter...
04:14:03 <phadej> I do not recommend writing the latter way, if you are not comfortable with encoding
04:14:06 <phadej> and you aren't
04:14:07 <phadej> so use `sets`
04:14:12 <boxscape> fog keep in mind that you can derive Functor for types that can be Functors, so you can actually do it automatically in those cases
04:14:46 <fog> well, i cant do that for hetrogenous containers
04:15:08 <boxscape> true, but an HList is a relatively complex type
04:15:24 <boxscape> so it's not too surprising that automatic machinery isn't necessarily set up to deal with it
04:15:25 <fog> there are a whole bunch of them. they must fulfil some central abstraction that would allow them to all be handled similarly
04:15:46 <fog> like how all functors have this trivial implementation of a setter in terms of fmap
04:16:35 <fog> phadej: i get what you are saying about not unwrapping the interface functions
04:18:14 <fog> it seems like i would have to make a class that wraps the type synonym Setter itself, and just write all the instances
04:18:24 <phadej> and for HList with say HCons constructor, setter for head is simply overhead f (HCons x xs) = HCons (f x) xs
04:19:00 <fog> right, but there is some kind of requirement to do "set" on the type level list of types!
04:19:19 <phadej> the type would be (a -> b) -> HList (a ': xs) -> HList (b ': xs)
04:19:46 <fog> i dont know how best to make that into a class
04:19:49 <phadej> if you want to set *all* HList values, than Setter is very unsuitable abstraction
04:20:08 <phadej> you might want to look into sop-core and e.g. map_NP function
04:20:08 <fog> like, how to handle the fact that the input types-list is not the same as the output. 
04:20:22 <fog> would it have a functional dependency f xs -> ys, or an associated type?
04:21:09 <phadej> Now I start to think that you try to do something too complicated
04:21:24 <phadej> you might want to look at NP in sop-core
04:21:34 <fog> i jsut did and it hurt my eyes
04:21:41 <phadej> where you have map_NP :: (forall x. f x -> g x) -> NP f xs -> NP g xs
04:21:44 <fog> https://hackage.haskell.org/package/sop-core-0.5.0.1/docs/Data-SOP.html
04:21:57 <phadej> for HLists it's **very hard** to do anything close to that
04:22:40 <phadej> and yes, type-level involved programming hurts eyes. :)
04:22:41 <fog> i think it would be sorter to implement than that haddock is
04:22:52 <fog> shorter*
04:23:13 <phadej> don't look at Data.SOP
04:23:16 <phadej> look at Data.SOP.NP
04:23:48 <hseg> Hi. I'm passing a list around, and am accessing its sum pretty frequently. Will GHC notice and cache the sum?
04:23:56 <phadej> no
04:24:21 <phadej> very unluckily
04:24:28 <fog> how is that module better than my implementation of Datatype?
04:24:42 <hseg> I suppose the proper solution is to (once benchmarks show this is necessary) add a field and use pattern synonyms to hide that caching?
04:24:44 <phadej> it's made by someone else who knew what they are doing ;)
04:24:48 <fog> https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e
04:24:55 <fog> yeah but its way complicated
04:25:16 <phadej> believe me, you want that functor there
04:25:17 <fog> that way is like, actually almost legible 
04:25:24 <phadej> HList is hard to work with
04:25:52 <fog> well, if they manage to make a hetrogenous functor thats a pretty decent effort
04:26:11 <fog> wish it was comprehensible though
04:26:32 <phadej> Higher order functor has `(forall x. f x -> g x) -> t f -> t g` type
04:26:34 <phadej> NP kind of fits
04:26:37 <phadej> HList doesn't
04:26:54 <refried_> Is there someplace I can read about the organization / contents of ~/.stack ?
04:27:05 <phadej> https://github.com/phadej/hkd/blob/master/example/NP.hs
04:27:11 <fog> thanks
04:27:25 <phadej> refried_: I think its implementation detail, so I'd guess "read the source"
04:28:33 <hseg> iiuc, the two versions of my module posted here http://ix.io/2pul are equivalent wrt consumers, right? Just that the lower one forces caching
04:28:50 <fog> hmmm, whats this; http://hackage.haskell.org/package/hkd-0.1/docs/Data-HKD.html ?
04:29:48 <phadej> code :)
04:30:42 <fog> i like how they have;
04:30:43 <fog> instance FTraversable Record where ftraverse = gftraverse
04:30:57 <fog> for any Record deriving Generic
04:31:14 <fog> i guess thats what i  was thinking lens would provide before
04:31:17 <phadej> not for any :)
04:31:31 <fog> just product types?
04:32:10 <dminuoso> hseg: Id call it sharing, but sure.
04:32:16 <phadej> for products with fields wrapped in `f` or instances of `FTraversable` itself
04:32:23 <phadej> e.g like in `NP`
04:32:37 <dminuoso> though huh, I dont think that does what you want it to.
04:32:43 <fog> class FFunctor (t :: (k -> Type) -> Type) where ffmap :: (f ~> g) -> t f -> t g
04:32:44 <fog> type (~>) f g = forall a. f a -> g a
04:32:49 <dminuoso> hseg: All you need is a smart constructor for Domain.
04:33:02 <dminuoso> The pattern will have the same issue.
04:33:46 <hseg> ok. just got bitten with reorganizing a typeclass breaking stuff, thankfully functions are easier in this regard
04:33:47 <mivael> > let f op Nothing jy = jy; f op jx Nothing = jx; f op (Just x) (Just y) = Just (op x y) in [f (+) (Just 3) (Just 70), f (+) Nothing (Just 70), f (+) (Just 3) Nothing, f (+) Nothing Nothing]
04:33:49 <lambdabot>  [Just 73,Just 70,Just 3,Nothing]
04:33:55 <fog> ah ok, your NP i was calling FList
04:34:35 <fog> and that ~> is like a kind of natural transformation
04:34:45 <hseg> q; in QuickCheck, what's the difference bw OrderedList and SortedList?
04:34:57 <mivael> hi all!  Could someone please give me a hint about a point-free way to write the f function (above)
04:35:00 <fog> it can change the f param because its not a list, but it has to leave all the list of types unchanged 
04:35:20 <boxscape> would "pattern Domain d f = Domain' d f (sum f)" even compile? I haven't used pattern synonyms much but it seems like that's not actually a bidirectional pattern?
04:35:39 <merijn> mivael: Well, why does it have to be pointfree? Doubt there's an easy way to do that
04:35:57 <mivael> okay then :)    thank you
04:36:29 <hseg> boxscape: might need to jiggle some stuff for GHC to accept it
04:37:39 <fog> phadej: ok i think i managed to grok your code, but i cant remember why you were showing it me
04:38:18 <hseg> q: I'd like to write a QuickCheck generator for this Domain type I showed. obvs can just liftA2 Domain (arbitrary @(Positive Int)) (arbitrary @(SortedList Int))
04:38:25 <phadej> because map_NP like things don't fit into Setter pattern
04:38:31 <phadej> you'll need  "higher order setter"
04:38:41 <hseg> however, i'd like to be able to restrict the generator to Domains of specific weight
04:38:59 <fog> also, if your using NP or FList, did you get the trick used in the Datatype paste, "unmapping" the f with the To Flist HList thing
04:39:14 <hseg> without falling into the generate-then-test trap
04:39:37 <fog> so wait, because its a natural transformation instead of a functor-like thing?
04:40:01 <fog> then whats a "higher order setter" ? oh, like, just setting one of the wrapping `f' s... 
04:40:23 <fog> i guess thats not possible because they have to all be the same, unlike the types in the type list
04:40:50 <ph88> does anyone know where from i could import the function singleton in https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC.html#v:initialize  ??
04:42:49 <hseg> ... nm, will just write genDomainOfWeight :: Int -> Gen Domain and provide genDomain = arbitrary >>= genDomainOfWeight
04:44:47 <hseg> q: what's the difference bw sortedlist and orderedlist?
04:49:57 <ph88> oh i think it should be from Vector
04:55:00 <ph88> what am i doing wrong here ?  i don't understand the type error  https://bpa.st/4FUA  https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC.html#v:initialize
04:56:19 <byorgey> ph88: I don't think the error is on that line.  The expected type must be coming from how you are using 'gen'
04:57:05 <ph88> byorgey, i also tried to make an explicit type signature but it didn't help -- with the idea is that the error goes to the line where  gen is used
04:57:44 <byorgey> ph88: an explicit type signature on what?
04:58:01 <ph88> gen <- initialize (singleton 0) :: IO (Gen (PrimState IO))
04:58:25 <byorgey> ph88: that's not going to help, you can see from the error message that it has already inferred that type for 'initialize (singleton 0)'
04:58:52 <ph88> still the expected type doesn't change ... maybe i can change the expected type if i move the type signature to the left of the  <-  arrow ?
04:59:31 <byorgey> I don't think you're allowed to put a type signature there.  You can maybe put a type signature on wherever it is that you use 'gen' later
04:59:40 <refried_> thanks phadej 
04:59:47 <ph88> i found the bug now, but still i'm interested in how i can force the error to go to the line where   gen   is used
05:00:07 <refried_> phadej although sometimes source comes with design docs, which would probably be helpful to me
05:00:17 <ph88> I vaguely remember putting a type signature left of arrow before
05:00:42 <Ariakenom> merijn: eh am I misunderstanding or was f=liftA2
05:01:18 <byorgey> ph88: hmm, maybe you can.  Try it and see! =)
05:01:59 <refried_> phadej: also I would think that 14G on my disk that is optional but never gets cleaned up automatically is more user-facing than a typical implementation detail (re ~/.stack contents)
05:04:08 <merijn> Ariakenom: liftA2 returns nothing if either one is Nothing
05:04:15 <merijn> Ariakenom: He only wants Nothing if *both* are
05:04:24 <merijn> So it's a weird mix of asum + liftA2
05:04:24 <Ariakenom> oh yes indeed
05:06:00 <merijn> refried_: Well, the problem is (same as v2-build, tbh) how/when can you possibly decide if it's free to remove dependencies?
05:06:32 <merijn> refried_: As long as there's a projects using those dependencies *somewhere* in the filesystem, they're in use
05:07:19 * hackage haskoin-node 0.14.0 - P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.14.0 (jprupp)
05:11:37 <Ariakenom> use unique identifiers in the paths and look through the bytes of all who could use it :D
05:13:07 <refried_> merijn: *nod* I had originally asked if the ~/.stack directory structure was documented somewhere, and phadej suggested since the directory is an implementation detail, I should look in the source.  I know I can do that, but wondered if it was documented anywhere else.
05:26:24 <puffnfresh> I can't find where the GitLab nightly jobs are for GHC, anybody know?
05:27:18 <ph88> byorgey, i tried it .. it needs ScopedTypeVariables
05:32:21 <puffnfresh> ah, I went back a couple of pages on this: https://gitlab.haskell.org/ghc/ghc/-/jobs and found a batch of nightly jobs
05:43:46 <kuribas`> is there a prepackaged haskell language server for windows?
05:44:49 <kuribas`> if I compile one, could I package it for reuse?
05:45:19 * hackage bip32 0.1.1 - BIP-0032: Hierarchical Deterministic Wallets for Bitcoin and other cryptocurrencies  https://hackage.haskell.org/package/bip32-0.1.1 (RenzoCarbonara)
05:45:20 <puffnfresh> kuribas`: there is work going on for this right now
05:45:30 <kuribas`> puffnfresh: ah great
05:46:00 <kuribas`> if I fix a ghc version, I could just copy my one for my colleages right?
05:46:02 <puffnfresh> https://github.com/bubba/haskell-language-server/releases
05:46:12 <puffnfresh> very very recent and unstable work
05:46:49 * hackage shakespeare 2.0.24.1 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.24.1 (MichaelSnoyman)
05:47:38 <puffnfresh> kuribas`: are you wanting this for VSCode?
05:47:44 <kuribas`> puffnfresh: yeah
05:47:48 * hackage http-client 0.7.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.7.1 (MichaelSnoyman)
05:48:00 <puffnfresh> kuribas`: there's a branch of the VSCode extension to automatically download the binary: https://github.com/bubba/vscode-hie-server/tree/static-binaries
05:49:05 <puffnfresh> this is all quite alpha so probably not appropriate for sending to colleagues
05:51:19 <kuribas`> puffnfresh: I don't mind compiling it myself, and that passing it to colleages
05:52:02 <puffnfresh> kuribas`: if you're gonna do that anyway, I'd try the releases first
05:54:47 <kuribas`> ok, thanks
05:59:16 <frdg> how do you use `let` in a monadic expression without using do notation? Does doing this just not make sense cause you just bind the output of the function to a variable easily by using `>>=`?
06:00:40 <maerwald> frdg: m >>= \x -> let p = 1 in x?
06:02:00 <nate48423> america government and denaro are getting my human brain i am nathan biernatt and i dont wan the america government to get it please tell your leaders and my brain goes through things when they do and i never told them i wanted them to have it
06:03:23 <frdg> maerwald: I get it now. 
06:03:24 <frdg> thanks
06:11:52 <dminuoso> Axman6: Ping
06:12:29 <kuribas`> frdg: you don't need "in"
06:13:13 <kuribas`> > do x <- Just 3; let y = 4; pure $ x+y -- frdg
06:13:15 <lambdabot>  <hint>:1:46: error:
06:13:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:13:49 <Axman6> dminuoso: o/
06:15:53 <kuribas`> > do x <- Just 3; let {y = 4}; pure $ x+y -- frdg
06:15:55 <lambdabot>  Just 7
06:16:21 <kuribas`> the let was stealing the semicolons
06:16:42 <frdg> kuribas`: What is the equivalent without using do notation?
06:17:18 <kuribas`> > do Just 3 >>= \x -> let y = 4 in pure $ x+y -- frdg
06:17:19 <dminuoso> frdg: It's just let in 
06:17:21 <lambdabot>  Just 7
06:17:29 <dminuoso> frdg: You can use the @undo command by the way
06:17:36 <kuribas`> frdg: it's just some sugar, but it's convenient
06:17:55 <dminuoso> @undo do x <- Just 3; let {y = 4}; pure $ x+y 
06:17:55 <lambdabot> Just 3 >>= \ x -> let { y = 4} in pure $ x + y
06:18:03 <kuribas`> because you don't need to indent the code below let .. in
06:18:26 <frdg> ok got it. Not needing the `in` is what was strange to me
06:18:34 <timCF> Hi guys! Is there any good process monitoring library for Haskell? Something similar to this in Erlang https://erlang.org/doc/reference_manual/processes.html#monitors
06:18:56 <dminuoso> timCF: There is indeed a similar thing on hackage.
06:19:01 <dminuoso> Let me try and recall what it was called
06:19:53 <dminuoso> timCF: Depending on your goals, you can cook your own ontop of `async`
06:23:08 <timCF> dminuoso yeah `async` is cool but it's working on its own type `Async` - which is ok in most cases. But in my case, I have some sort of WAI websocket controller process which is already spawned for me by other library, and basically my program wants to know when process terminates (user disconnects from ws) to cleanup allocated resources
06:24:09 <dminuoso> timCF: Then just use async.
06:24:14 <dminuoso> It has the right facilities out of the box
06:25:17 <nohTo> Hi everyone! I'm on my first adventure of debugging a space leak and I have a very simple peace of code that leaks and I have no idea what's going on. Here's the code: https://gist.github.com/voiceofdoubt/07405409be25b3f9ed26e9672ca3be15
06:26:21 <nohTo> In my actual application I have a more interesting monad, but I was very surprised that it leaks even with the Identity monad.
06:26:38 <nohTo> Any pointer would be greatly appreciated.
06:27:16 <Axman6> nohTo: thwe problem is that the first evalaluion of foldl' must a) evaluate cols and b) because cols is referenced by other values, cols must remain in memory
06:27:17 <jumper149> My intuitive guess would be that it has something to with sequence, but I really have no clue about fixing space leaks :D
06:28:40 <nohTo> Axman6: Wonderful! So to fix it, I should only need to make a dummy function so that ghc doesn't see the connection to cols anymore?
06:29:12 <Axman6> so r = ... executes, and normally the compiler would be able to see that cold gets consumed immediately, so the [1..500000] could be inlined and the foldl call would consume values as they're generated
06:29:24 <Axman6> well no, the real fix is to use the foldl package
06:30:05 <Axman6> (r,g,b) = F.fold (liftA3 (,,) F.sum F.sum F.sum) cols
06:30:17 <Axman6> that will do a single pass over the argument list
06:30:56 <Axman6> nohTo: but it is very important that yopu understand why the list [1..500000] remains in membery betweren the evaluation of r and g (for example)
06:31:20 <Axman6> if you passed in three lists, then you'd also be ok
06:31:42 <refried_> is this a good place to ask questions about stack in CI, or is there a better channel?
06:31:58 <Axman6> refried_: might as well ask here
06:33:17 <nohTo> Axman6: I think I understand. Since it will be needed later, and it needs to be evaluated for r, it can't be garbage collected until b is done.
06:34:32 <Axman6> yep
06:34:41 <refried_> Axman6: ok thanks. the haskellstack install page says to use `curl -sSL https://get.haskellstack.org/ | sh`, but the haskellstack travis_ci page says "Currently there is only one reasonable way to install Stack: fetch precompiled binary from the Github."  with `curl -L https://get.haskellstack.org/stable/linux-x86_64.tar.gz | tar xz --wildcards --strip-components=1 -C ~/.local/bin '*/stack'`.
06:35:08 <refried_> I want to understand why the two pages are different; and why is the latter "the only reasonable way to install Stack"?
06:35:37 <nohTo> Axman6: Thank you so much! I'll see if I can fix it and if I can also fix it in the larger context.
06:35:48 <refried_> i.e. Is there something subtly wrong / unreasonable about using `curl -sSL https://get.haskellstack.org/ | sh` in travis?
06:43:12 <Axman6> refried_: have you tried using https://hackage.haskell.org/package/haskell-ci?
06:43:37 <Axman6> I know it's not an answer to your question, but it should implement the best practices
06:50:22 <samiamsam> refried_: https relies on private keys that must be kept online on the server; also, on the integrity of the certificate authorities, which is known to be false
06:50:51 <samiamsam> refried_: it's much better securitywise to have a signature on the data
06:51:14 <Axman6> I'm not sure that's relevant to the problem
06:51:52 <samiamsam> oh, i was only seeing that last question about whether it's unreasoanble to do curl .. | sh
06:52:57 <samiamsam> heh, both of those methods rely on https
06:53:12 <samiamsam> that's not really good.  pretty sure there are gpg signed binaries somehwere
07:04:29 <Axman6> Anyone know what a CPS version of ExceptT would look like?
07:07:13 <dolio> (e -> m r) -> (a -> m r) -> m r
07:16:10 <kuribas`> do you even need ExceptT with continuations?
07:17:11 <Cale> kuribas`: I think the question is how to program something equivalent to ExceptT using continuations.
07:17:22 <kuribas`> right :)
07:20:52 <refried_> samiamsam: *nod* agreed re https vs gpg; I was just wondering why the two pages had different install instructions (especially with the one making a vague statement about reasonability)
07:21:56 <Axman6> thanks dolio
07:30:37 <kuribas`> does conduit-xml support returning a error location?
07:30:48 <kuribas`> I couldn't find it, but maybe I am missing something?
07:32:06 <kuribas`> There is evenPos, but tag, etc... don't seem to use it.
07:33:23 <kuribas`> tag :: MonadThrow m => NameMatcher a -> (a -> AttrParser b) -> (b -> ConduitT Event o m c) -> ConduitT Event o m (Maybe c)
07:33:32 <kuribas`> I don't get why haskell libraries are so sloppy with errors
07:40:38 <sm[m]> more focus on doing things at all, than making them comfortable for industrial use
07:42:35 <sm[m]> though conduit libs should be a bit more production-friendly than some
07:45:18 <sm[m]> kuribas`: some discussion here: https://github.com/snoyberg/xml/issues/67
07:46:53 <kuribas`> hmm, I see
07:54:27 <hseg> what's the difference in quickcheck between sortedlist and orderedlist?
08:07:19 * hackage dhall-lsp-server 1.0.8 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.8 (GabrielGonzalez)
08:11:29 <Cale> hseg: It's weird that those both exist. The implementation of arbitrary seems equivalent, but shrink is implemented differently
08:12:15 <Cale> The shrink for SortedList sorts each of the shrinks of the list. The shrink for OrderedList simply checks whether each shrink is sorted already.
08:12:21 <Cale> (it filters them)
08:12:45 <Cale> This should definitely be documented better.
08:13:02 <dmwit> hseg: https://stackoverflow.com/q/56507810/791604
08:17:18 * hackage dhall-json 1.7.0 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.7.0 (GabrielGonzalez)
08:18:19 * hackage calamity 0.1.14.5 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.5 (nitros12)
08:19:18 * hackage dhall-yaml 1.2.0 - Convert between Dhall and YAML  https://hackage.haskell.org/package/dhall-yaml-1.2.0 (GabrielGonzalez)
08:19:38 <ezzieyguywuf> from the brick demos, I see `drawUI :: () -> [Widget Name]`. Why not just make it `drawUI :: [Widget Name]`? what's the functionality of accepting `()` as an argument?
08:20:19 * hackage dhall-bash 1.0.31 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.31 (GabrielGonzalez)
08:22:20 <Cale> ezzieyguywuf: I think Brick has an App data type which allows that function argument (but allows it to be of any type)
08:22:41 <Cale> and so choosing () is like saying "I don't actually care to have any application state"
08:24:36 <ezzieyguywuf> Cale: ah, I think that makes sense, thank you.
08:25:02 <dminuoso> It's not unlike how you'd have `IO ()` - the fact that you see that as a function argument is just for type inference. :)
08:25:32 <dminuoso> data App s e n = App { appDraw :: s -> [Widget n], ... }
08:25:49 <Cale> I don't actually like that kind of model, personally -- it's a bit anti-compositional
08:25:55 <dminuoso> So by supplying a function `() -> ...` to the field appDraw lets the inference figure out the state is ().
08:26:15 <Cale> If your app is small, it's probably mostly okay though.
08:26:48 * hackage dhall-nix 1.1.15 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.15 (GabrielGonzalez)
08:27:19 <Cale> It's just that the top-level of your app has to be aware of every piece of state that's involved in drawing anything it may want to put on the screen.
08:27:33 <Cale> (because you have to define that top-level type)
08:27:37 <dminuoso> Cale: You mean the model of picking a global state?
08:28:18 * hackage dhall 1.33.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.33.0 (GabrielGonzalez)
08:28:49 <Cale> Yeah, not having any way for widgets to have local state that the rest of the app doesn't need to care about or be potentially affected by
08:28:56 <dminuoso> I suppose it's a difficult spot. If you dont have a single global state, then either your entire tree of rendering functions isnt pure, or...
08:29:14 <Cale> Well, you get into FRP territory pretty quickly :)
08:29:46 <dminuoso> Ive done some react, which largely embraces "have a global state, and then a big honking render in terms of that state".
08:29:56 <dminuoso> So I wouldn't know how real FRP would address this
08:29:59 <Cale> Yeah, not like react :P
08:30:49 <ezzieyguywuf> I had a [String] that I would `take 5 myStrings` to print out to the cli, trying to cleverly make it scroll on only 5 lines using asii escape stuff. And I just let that list grow and grow and grow b/c of lazy evaluation, right?
08:30:57 <ezzieyguywuf> woke up this morning and my comp was dead, i guess it used up all the memory
08:31:15 <ezzieyguywuf> b/c I guess i evaluated every-single-item in that eventually super long list
08:31:26 <dminuoso> ezzieyguywuf: If it runs out of memory on linux, the OOM killer would be triggered and the program would have been killed.
08:31:35 <dminuoso> So if your entire laptop was dead, it was a different issue.
08:31:49 <dminuoso> (Unless of course you have your OOM killer disabled....)
08:32:27 <ezzieyguywuf> it was my tower, not laptop
08:32:33 <ezzieyguywuf> what is OOM killer?
08:32:36 <ezzieyguywuf> how can I check?
08:32:49 <Cale> dminuoso: You tend to have something like what we call hold in Reflex, which takes some initial value of type s, and an (Event s), and produces something of type (Behavior s), which is a thing that changes over time, in this case, having a value which is either the initial value (if the Event has not fired), or the last value that the Event fired with.
08:33:05 <dminuoso> A subsystem in the linux kernel that will kill down processes if the system runs out of memory.
08:33:20 <ezzieyguywuf> hm, I'll check
08:33:53 <Cale> That's the primitive way that you can remember anything that happened in the past in Reflex.
08:34:48 <dminuoso> Cale: Okay, but how does that address having a global state?
08:35:08 <Cale> Well, if you can set up local states anywhere, you don't need a big global one.
08:35:44 <dminuoso> Cale: Haha, actually you can do local states in React just fine too - but the way you write the view logic, it makes it super hard to reason about code.
08:35:45 <Cale> With hold and recursion, you can define something which updates a state
08:36:00 <dminuoso> Mmm, is there something you could point me at to dive into this?
08:37:13 <Cale> blah, was going to point you at the definition of foldDyn in Reflex, but the code has become even less pedagogical than it was before :D
08:38:31 <dminuoso> I've really tried to grok conals talks on frp.. but.. he's so idealistic and non-concrete. :(
08:38:43 <dminuoso> It's a little too abstract for my taste
08:39:40 <Cale> Okay, so we have two basic data types that explain different kinds of things which change over time:
08:40:08 <Cale> There are things which always have a value, whenever you'd care to look at them, which we call behaviours
08:40:29 <dminuoso> Sure, essentially time parametrized things - but over infinite domains right?
08:40:54 <Cale> Things like, the current location of the mouse pointer, or contents of a text field, or the current hitpoints of a monster, or scene to be drawn on the screen
08:41:13 <dminuoso> Right.
08:41:33 <Cale> In Reflex, we never express whether time is discrete or continuous, we only assume that it's totally ordered.
08:42:32 <Cale> But yeah, it's potentially infinite, and you don't ever refer to specific times (at least at the primitive level -- there's a library which adds a bunch of time-related stuff)
08:42:48 * hackage postgresql-pure 0.1.3.0 - pure Haskell PostgreSQL driver  https://hackage.haskell.org/package/postgresql-pure-0.1.3.0 (kakkun61)
08:43:26 <Cale> There's also things which only occur at specific moments in time, and have a value at those times. These we call events
08:44:30 <Cale> Things like the sequence of mouse clicks, or keystrokes, the sequence of attacks made by the player, the sequence of sound effects to be played, the sequence of messages to be sent over the network, or responses coming back
08:45:00 <Cale> We then have a bunch of primitives for combining Event and Behavior values to produce more such things
08:45:20 <Cale> and describe the way that input Events and Behaviors are connected to output Events and Behaviors
08:47:08 <Cale> A good example to start with perhaps is what we call "attach", which takes a (Behavior a) and an (Event b), and produces an Event (a,b), which fires whenever the input event fires, with the value that the given Behavior has at the current moment paired with the value that the Event fired with
08:47:19 <dminuoso> reflex calls an Event a stream of occurences, in what sense is that meant?
08:47:36 <dminuoso> or is "occurence" an frp term as well?
08:47:58 <Cale> You can read that informally and it should make sense
08:48:17 <Cale> Like, it's a thing which occurs zero or more times throughout the lifetime of your program
08:48:38 <Cale> and whenever it occurs, it has a value of the given type
08:49:21 <dminuoso> `attach` sounds trivial enough :)
08:50:32 <Cale> There are also Functor instances for Event and Behavior, so you can apply a pure function to the values involved
08:51:47 <Cale> You might notice these extra 't' type parameters in Reflex, they're sort of ignorable for the most part -- they refer to the implementation of the Reflex primitives
08:52:42 <Cale> If you like, you can imagine that there might be support for multiple independent timelines, or monad-transformer-like means of transforming the FRP implementation -- we haven't made too much use of this yet
08:53:13 <Cale> Anyway, back on track, we can have  attachWith :: (a -> b -> c) -> Behavior t a -> Event t b -> Event t c  -- I'll write the t's in ;)
08:53:39 <Cale> which is just   attachWith f b e = fmap (\(x,y) -> f x y) (attach b e)
08:53:55 <Cale> (or more likely,  attach = attachWith (,)  )
08:55:14 <Cale> you'll notice hold, which I was talking about before, has a type like this:
08:55:16 <Cale> hold :: (MonadHold t m) => a -> Event t a -> m (Behavior t a)
08:56:15 <Cale> The reason for the MonadHold constraint is that the result of a hold doesn't depend on any occurrences of the Event which happened before the current time
08:56:33 <Cale> (we want this to be the case, because we don't want every Event to be a memory leak)
08:57:25 <Cale> So, an instance of MonadHold is in some sense like a Reader for the current time, except you don't actually get access to what the current time *is*, you just get the ability to hold :)
08:58:07 <Cale> (The actual implementation uses IORefs)
08:58:48 <Cale> Another important detail about hold: the Behavior changes value *immediately after* the Event fires.
08:59:32 <Cale> This means that if you attach the resulting Behavior to the same input Event, you will observe successive pairs of values that the Event fired with
09:00:00 <Cale> (well, the first firing will be paired up with the initial value of the hold of course)
09:00:09 <Cale> dminuoso: make sense?
09:02:51 <Cale> dminuoso: If we put these things together recursively, we can build a thing which is effectively like a "fold through time"
09:04:36 <Cale> foldEvent :: (MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> (Behavior t b, Event t b) -- I'll write this right now
09:04:55 <Cale> foldEvent f init ev = do
09:05:04 <infinisil> Signature is missing an m
09:05:08 <Cale> oops
09:05:15 <Cale> foldEvent :: (MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Behavior t b, Event t b)
09:05:33 <Cale> foldEvent f init ev = do
09:07:03 <Cale>   rec current <- hold init (attachWith (\b a -> f a b) current ev)
09:07:46 <Cale>   return (current, attachWith const current ev)
09:08:10 <Cale> (My conventions are fighting each other a little, but hopefully that makes sense anyway)
09:09:30 <Cale> The idea is that the current :: Behavior t b starts off with the given initial value, and then whenever the ev :: Event t a fires, we combine the present value of current with the new value from ev using f to get a new value for current
09:10:23 <Cale> and then here I'm returning that Behavior along with an Event that fires at the same times as the input Event, but with updated values.
09:10:36 <Cale> (Not strictly necessary as you can see)
09:11:29 <Cale> In Reflex, we have an additional type called Dynamic which is effectively a pair of such a Behavior which only changes at discrete moments, and Event which tells you all the times at which it is changing, and the value it's about to change to
09:12:07 <Cale> actually, sorry...
09:12:13 <Cale> let me change that implementation
09:12:20 <Cale> doing the attachWith const is wrong
09:12:29 <Cale> what I actually want is some mutual recursion there
09:12:49 <Cale>   rec current <- hold init updated
09:13:09 <Cale>       let updated = attachWith (\b a -> f a b) current ev
09:13:15 <Cale>   return (current, updated)
09:13:45 <Cale> Why was the previous one wrong? Well, attachWith const current ev will only see the old value of current at the moments when ev fires
09:14:02 <Cale> We want to return an Event that says what the value is changing to, not its previous one.
09:14:40 <Cale> So, what's actually in Reflex is:
09:15:41 <frdg> parsing question: https://pastebin.com/CYA0S96f
09:15:41 <Cale> holdDyn :: (MonadHold t m) => a -> Event t a -> m (Dynamic t a)
09:15:49 <Cale> oh, and...
09:16:09 <Cale> foldDyn :: (MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)
09:16:18 <Cale> yeah, that's the actual thing I wanted to point out
09:16:44 <Cale> So, there are functions   current :: Dynamic t b -> Behavior t b  and  updated :: Dynamic t b -> Event t b
09:16:56 <Cale> which you can think of as "unpairing" the Dynamic
09:17:22 <Cale> Reflex builds in support for Dynamic now though, so that it can have instances of Functor, Applicative, and Monad.
09:17:41 <Cale> Initially it really was just a pair of a Behavior and Event which agree in this way
09:18:43 <Cale> frdg: Well, you'll certainly want to use something like  let timeResult = parseString ...
09:19:05 <Cale> frdg: since time <- ... means "run this IO action, and whatever its result is, name that time"
09:19:15 <Cale> But parseString is not producing an IO action
09:19:21 <Cale> Let's look at what the Result type is
09:19:23 <dminuoso> Cale: Hold on, I was on a call. Reading up now.
09:19:50 <Cale> frdg: https://hackage.haskell.org/package/trifecta-2.1/docs/Text-Trifecta-Result.html
09:20:18 * hackage slip32 0.2 - SLIP-0032: Extended serialization format for BIP-32 wallets  https://hackage.haskell.org/package/slip32-0.2 (RenzoCarbonara)
09:20:18 <frdg> Cale: ohh...of course! thank you I see the problem
09:20:28 * dminuoso got ski'd
09:20:32 <dminuoso> :)
09:20:33 <Cale> frdg: You can see here that Result has two data constructors -- you'll either get something like  Success x  where x is the result of parsing, or Failure e where e :: ErrInfo
09:20:42 <Cale> dminuoso: haha
09:20:59 <Cale> dminuoso: Yeah, I kinda went on a bit there, I had the sense that maybe some other people were listening in as well
09:21:52 <dminuoso> Cale: Based on infinisil's comment, eh? :)
09:22:00 <Cale> yeah, haha
09:25:29 * ski glances around nerveously
09:33:11 <hseg> q: my quickcheck property is hanging. how can i see what it's stuck on?
09:33:21 <hseg> ... oh wait, i have a hung
09:33:26 <hseg> *hunch
09:34:40 <dsal> hseg: It's probably a bad shrinker
09:34:52 <dsal> You could try disabling shrinking.
09:35:06 <hseg> no, just found it -- i was forcing it to evaluate bottom
09:35:08 <hseg> oops
09:35:28 <dsal> Oh.  Yeah, infinite recursion is another thing.
09:35:35 <dsal> Or effectively very large inputs.
09:35:41 <hseg> (i thought i had explicitly guarded against it, made a mistake in my logic)
09:35:56 <dsal> test half-worked. heh
09:39:23 <hseg> still hanging though (replaced undefined with const bogus)
09:39:37 <dsal> verboseCheck ?
09:41:05 <dolio> 'undefined' doesn't just hang.
09:42:13 <hseg> how do i call verboseCheck with a specified generator?
09:42:49 <hseg> nm
09:43:09 <hseg> ok, verboseCheck works
09:43:22 <hseg> quickCheck does as well
09:43:33 <hseg> so why does tasty not?
09:44:01 <dsal> tasty just runs quickCheck.  It won't necessarily fail consistently.
09:44:02 <hseg> ... ok, after jiggling it a bit it now works
09:44:08 <dsal> You can turn on verbosity in tasty as well.
09:44:10 <hseg> have no idea what i did
09:44:44 <dsal> Programmers never know what they did.  That's not an interesting detail.  WFM is all that matters.
09:44:50 <hseg> :)
09:46:51 <hseg> hrm. is there a standard function :: (a -> Bool) -> b -> (a -> b) -> b ?
09:47:18 <dsal> @hoogle (a -> Bool) -> b -> (a -> b) -> b 
09:47:19 <lambdabot> No results found
09:47:27 <hseg> .. that should be (a -> Bool) -> b -> (a -> b) -> (a -> b)
09:48:00 <dsal> What does that do?
09:48:03 <hseg> basically, \p d f x -> if p x then d else f x
09:48:11 <hseg> seems like a useful combinator
09:48:16 <dsal> :t bool
09:48:18 <lambdabot> a -> a -> Bool -> a
09:48:45 <hseg> @djinn (a -> Bool) -> b -> (a -> b) -> (a -> b)
09:48:45 <lambdabot> f a b c d =
09:48:45 <lambdabot>     case a d of
09:48:45 <lambdabot>     False -> c d
09:48:45 <lambdabot>     True -> b
09:48:59 <dsal> What's djinn ?
09:48:59 <hseg> well, it's not wrong
09:49:20 <hseg> djinn :: Type -> Term
09:49:34 <hseg> basically tries to guess your program from its type
09:49:47 <dsal> Oh cool.  I can write fewer functions now.
09:49:56 <hseg> yup
09:50:20 <hseg> anyway, doesn't seem like the combinator i want exists. will just have to write pointedly
09:50:47 <int-e> hseg: I believe it prefers functions that do not erase any arguments. So that excludes \_ b _ _ -> b and \_ _ f -> f
09:51:00 <hseg> right
09:52:47 <int-e> @hoogle ifM
09:52:47 <lambdabot> Control.Monad.Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
09:52:47 <lambdabot> Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
09:52:47 <lambdabot> Protolude ifM :: Monad m => m Bool -> m a -> m a -> m a
09:53:16 <User0192> Important. Please add "like". NO spam: https://www.youtube.com/watch?v=sUt6HIgfQgo
09:53:19 <hseg> :t ifM @((->) a)
09:53:20 <lambdabot> error: parse error on input ‘->’
09:53:21 <int-e> ifM gives you (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)
09:53:53 <hseg> so ifM p f (const d) would do what I want
09:54:12 <hseg> :t ifM even negate (const 0)
09:54:13 <lambdabot> error:
09:54:14 <lambdabot>     Variable not in scope:
09:54:14 <lambdabot>       ifM
09:56:00 <int-e> @let ifM b t f = b >>= \b' -> if b' then t else f
09:56:01 <lambdabot>  Defined.
09:56:09 <int-e> :t ifM even negate (const 0)
09:56:10 <lambdabot> Integral a => a -> a
10:02:56 <lemonpaul> Is there any way to construct regular expression from string in pcre-heavy?
10:04:49 * hackage hw-json 1.3.2.1 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.3.2.1 (haskellworks)
10:05:48 <dsal> lemonpaul: you mean instead of ByteString?
10:06:02 <lemonpaul> Yes
10:06:34 <dsal> You can always pack a String into a ByteString.  Is this a String literal or are you just passing in a String?
10:07:20 <dsal> The documentation assumes OverloadedStrings (which just basically turns every `"x"` into `fromString "x"`)
10:16:11 <tom__> What does a hash prefix to the getter do to a lens in this case   person ^. #name
10:16:34 <merijn> tom__: I think that's overloadedfieldlabels or something extension
10:18:50 <tom__> merijn: Thanks!
10:22:27 <dsal> protolens uses that
10:22:34 <dmwit> :t if' -- hseg
10:22:35 <lambdabot> error:
10:22:36 <lambdabot>     • Variable not in scope: if'
10:22:36 <lambdabot>     • Perhaps you meant one of these:
10:22:40 <dmwit> ehh...
10:22:43 <dsal> https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-OverloadedLabels.html
10:22:44 <dmwit> Only exists in ?pl lmao
10:27:10 <hseg> srsly?
10:44:43 <merijn> You mean
10:44:45 <merijn> :t bool
10:44:46 <lambdabot> a -> a -> Bool -> a
10:44:49 <merijn> ?
10:52:19 <monochrom> Folklore functions that exist only in people's minds.
10:53:09 <monochrom> unicorn, bool, and santa claus
10:54:41 <merijn> monochrom: hmm?
10:54:48 <merijn> bool is in base...
10:54:52 <dsal> Yeah, why can't I have spaces in function names?
10:55:26 <monochrom> Oh oops Data.Bool has it
10:55:52 <merijn> monochrom: For several GHC releases already
10:56:03 <merijn> monochrom: You're just getting old ;)
10:56:22 <monochrom> Folklore functions that non-exist only in people's minds. :)
10:56:34 <dsal> > let santa = ($); claus = id in   santa claus "merry christmas"
10:56:36 <lambdabot>  "merry christmas"
10:56:51 <merijn> We even have strict foldMap now!
10:57:06 <{abby}> we do?
10:57:08 <monochrom> Singletons can be used to fake functions with spaces in names.
10:57:18 <dsal> I don't want to understand that.
10:57:37 <merijn> {abby}: as of GHC 8.8 or 8.10
10:57:56 <merijn> {abby}: foldMap' in Data.Foldable
10:58:06 <{abby}> oh thank the gods
10:58:34 <{abby}> I've lost count of how many times I've written that function... Time to update, I suppose :)
10:59:31 <merijn> Yeah, same
11:00:03 <merijn> basically every single time I used foldMap with Sum or Product :p
11:01:18 <joeyh> I've noticed that cabal new-build uses the package version in dist-newstyle, so if I keep building a package across versions, old cruft builds up in there. Is there any way to clean it without cleaning my current build too?
11:01:46 <merijn> joeyh: Not really, at least not yet
11:02:05 <joeyh> also old ghc versions will have cruft, hmm
11:03:00 <merijn> joeyh: I just nuke dist-newstyle and ~/.cabal/store once or twice a year
11:05:03 <maerwald> new unix way is to assume infinite storage: docker, nix, stack, cabal, ...
11:05:23 <merijn> maerwald: There's work on a cabal cleanup solution. But it's rather low priority
11:06:40 <hseg_> how would you concisely test whether a list xs is of the form [k, -k] ?
11:10:31 <monoidal> sum xs == 0 && length xs == 2, though it feels too clever
11:10:44 <monoidal> I'd just pattern match.
11:11:23 <Hopplahase> With flipped tests, though
11:11:40 <monoidal> right
11:11:57 <hseg> context here is that i'm building a list :: [(a -> Bool, a ->b)] which i then upgrade to a function a -> b
11:12:28 <hseg> so i want some lambda term to use as a guard here that will match [k,-k]
11:14:06 <hseg> so my initial instinct of \[x,y] -> x == negate y is problematic since that throws if it doesn't match
11:14:16 <hseg> instead of returning False
11:14:34 <monochrom> jhc also assumed infinite storage :)
11:15:46 <monoidal> \case [x,y] -> x == negate y; _ -> False
11:16:22 <monochrom> Yeah I would consider \case too.
11:16:45 <maerwald> seems fishy
11:17:21 <hseg> good catch!
11:17:23 <maerwald> it will return true for [-k, k]
11:17:37 <hseg> maerwald: yes... as desired?
11:17:43 <maerwald> is it?
11:18:14 <hseg> yes. i want to match against [k, -k]
11:18:23 <hseg> which is the same as matching against [-k, k]
11:18:34 <monochrom> Let j = -k.  Then [k, -k] = [-j , j]
11:19:10 <maerwald> hseg: depends what k is element of
11:19:54 <monoidal> you can change to y == negate x if there's a possibility of a weird Num instance
11:20:12 <hseg> maerwald: i'm assuming Group a => [a]
11:43:38 <jchia_> My function has the HasCallStack constraint and I'm quite sure that it's accessing a vector out-of-bounds resulting in a crash with a callstack dump with one entry from Data.Vector.Internal.Check. Is it expected that my own function with the HasCallStack constraint does not have a callstack entry in the callstack dump?
11:44:08 <jchia_> That's what I'm seeing and I can't tell where exactly in my own code the crash is happening.
11:45:23 <dolio> Do the vector functions have HasCallStack constraints?
11:45:34 <dolio> If they don't, then your function's call stack won't be passed in.
11:52:20 <jchia_> dolio: IDK whether they do, but if they don't can I get a crash dump like this?
11:52:21 <jchia_> CallStack (from HasCallStack):
11:52:21 <jchia_>   error, called at ./Data/Vector/Internal/Check.hs:87:5 in vector-0.12.1.2-AWRYcz9jfa25Avs2q9Jg9V:Data.Vector.Internal.Check
11:52:42 <jchia_> and that dump has no other entry despite my own function having the constraint
11:56:36 <monochrom> https://github.com/ArturGajowy/ghc-clippy-plugin/tree/0df515a6577715ab100b9b9fa797ff6219fb4a0c heh clippy
11:59:45 <veverak>  hmmm
12:00:02 <veverak> I have state monad that contains HashMap
12:00:21 <veverak> at one moment specific key is inserted into it and I log that to stdout
12:00:29 <veverak> but, later when I try to search for it it is not there
12:00:36 <veverak> and I am pretty lost as to: how to debug this
12:01:36 <veverak> https://paste.vpsfree.cz/7aXsWitV/
12:02:02 <veverak> these are the functions that work with the state inside the monad
12:03:19 <veverak> P.S:
12:03:21 <veverak> "Loading module to scope: \"coxa\""
12:03:23 <veverak> "Getting module: \"coxa\""
12:05:18 <jchia_> veverak: There's no main, so it's hard to tell what exactly you did and what result you were expecting.
12:05:20 <troubledd> I am new to Haskell and would appreciate if somebody could look at my algorithm and let me know if it is a decent one, or if you would do something different, there is a better way, etc. The function takes a list and returns an Int representing the amount of unique elements in the list.
12:05:21 <troubledd> https://pastebin.com/A7NtXMMv
12:05:46 <veverak> jchia_: there is a lot of code and I have still trouble picking up the right thing
12:05:56 <veverak> or, right part of it
12:06:59 <veverak> let me add more
12:07:04 <[exa]> troubledd: why would you convert the data to strings?
12:07:49 <veverak> https://paste.vpsfree.cz/elVTtIu3/
12:07:55 <veverak> hmm, maybe this is the whole thing?
12:08:04 <troubledd> [exa]: I was thinking that this would be neccasary for accumulating values for my `ys` variable
12:08:05 <veverak> schpin-koke: unknnwn module: coxa
12:08:12 <veverak> the error at bottom line is actually fired
12:08:29 <veverak> however, I have logs that the bodule 'coxa' was inserted in loadScope in the scope
12:08:33 <jchia_> troubledd: Depends on your goal. If you want efficiency and you have Ord a, you should probably use a Set for this.
12:08:53 <jchia_> or use a function from a library
12:09:10 <[exa]> troubledd: you can store anything there, not just strings (in fact stuff converted to strings may give false positive equality)
12:09:45 <troubledd> [exa]: ok thanks
12:10:24 <troubledd> jchia_: goal is just to write correct functions that are written in a "proper Haskell style"
12:10:26 <[exa]> troubledd: otherwise you are basically at the implementation of `nub` which does this in the standard library, so unless you want to speed that up with Ordering assumptions, you're pretty much there
12:13:03 <monochrom> This is one reason why some of us hate some other languages.
12:13:25 <Cheery> some
12:13:39 <monochrom> There are some languages that have a poor story on equality tests, and encourage the XY problem "convert to string, compare strings".
12:14:11 <[exa]> veverak: are you sure ErrorT doesn't erase the state change you produced?
12:14:31 <veverak> [exa]: nope really
12:14:31 <monochrom> This is just one example. Many languages are castrated in various ways and encourage many other XY problems.
12:14:44 <veverak> writing "printScope" thingie now to check
12:16:06 <[exa]> veverak: IIRC there are people who objected against ErrorT in favor of ExceptT or others
12:16:22 <monochrom> Then people come to Haskell, bringing with them their full reportoire of XY habits, and just translate to Haskell, and what we see is a full-fledge Rube Goldberg machine that's "beautiful" in a facepalm way.
12:16:24 <veverak> [exa]: I am aware of that, but what is reason?
12:16:34 <veverak> I mean, I am aware that there is some objection, not sure what
12:17:21 <merijn> veverak: Because ErrorT implies, well, an error
12:17:22 <dolio> Wasn't it about changing the behavior of some instance?
12:17:35 <veverak> oh
12:17:37 <veverak> yeah
12:17:44 <veverak> [exa]: after loadScope call, the scope is empty
12:17:51 <merijn> Error instance on 'e', I think
12:18:04 <monochrom> @unmtl ErrorT X (State S) A
12:18:04 <lambdabot> S -> (Either X A, S)
12:18:24 <monochrom> you won't lose state, you always have a post-state.
12:19:12 <troubledd> monochrom: I am a full fledged "change to string then compare strings" guy. Never even really thought much about it until now...
12:19:19 <veverak> ok, error is in loadScope
12:19:36 <veverak> "printModuleScope" at end of insertScopeModule prints scope with previous modules
12:19:42 <veverak> (not just the one inserted)
12:19:47 <veverak> printModuleScope at the end of loadScope is empty
12:20:38 <veverak> waiiiiiiiiiiiiit
12:20:40 <veverak> fu me
12:20:57 <veverak> last recursive call sets emptystate....
12:21:28 <veverak> fuxed \o/
12:21:32 <veverak> * fixed \o/
12:21:34 <veverak> ;)
12:22:04 <monochrom> failure is the mother of success. fuxed is the mother of fixed
12:22:07 <[exa]> oh them folds
12:22:42 <dmwit> ping is the mother of pong; poke is the mother of puke
12:23:10 <monochrom> When using State.Lazy, get is the mother of put. :)
12:31:43 <[exa]> veverak: btw why not `traverse`?
12:32:34 <veverak> discovered it just recently
12:33:44 <hseg> is there some way to tell cabal to use a particular component by default for repls?
12:33:58 <hseg> (i have a dedicated "sandbox" component for that purpose
12:33:59 <[exa]> also there should be some good rememberable rule of thumb for ordering MTL transformers
12:34:01 <hseg> )
12:34:13 <[exa]> preferably without thinking boxes
12:34:31 <monochrom> cabal repl componentname
12:34:48 <monochrom> may need prefix exe: if exe
12:34:50 <veverak> I got the order right i think
12:34:59 <veverak> alternativelly, I would have to lift much more
12:35:02 <hseg> yeah, but is it possible to configure cabal so that cabal repl = cabal repl component?
12:35:32 <monochrom> then I don't know. I bet not but too lazy to verify
12:35:49 <hseg> kthx
12:36:35 <[exa]> hseg: shell alias? ( :D )
12:36:40 <hseg> :)
12:37:21 <veverak> anyway, one thing ofr the State monad
12:37:38 <veverak> I need to "pass" actual state to recursive goal, but ignore it's changes
12:37:39 <monochrom> [exa]: There was a brief moment, just before the invention of MTL, of inventing and using "forward compose" and "backward compose".
12:37:41 <[exa]> veverak: you lift basically everything now :]
12:37:52 <veverak> [exa]: in the pasted part yeah, in actual code: no
12:37:54 <veverak> :)
12:38:16 <veverak> anyway, I need to pas actual state to recursive call of fucntion, but ignote the changes on the state
12:38:27 <[exa]> veverak: also, lifting is generalu unnecessary since there are MonadState and MonadExcept
12:38:33 <veverak> which I can do by extracting state and "running" the monad again, but that seems cumbersome, is there something for that?
12:38:53 <monochrom> They are both functor composition. "forward compose F and G" is like G.F, "backward compose F and G" is like F.G. (Or maybe I have swapped them, I don't know, not important for now.)
12:39:43 <monochrom> So just by reading "FComp X (BComp Y Z)" you know precisely what the author is getting at.
12:40:16 <[exa]> monochrom: I remember seeing something like that. Like, the problem isn't technically complicated at all, but the forward/backward in/out problem deserves a better, rememberable picture in docs :]
12:41:22 <monochrom> This idea went away very quickly and MTL took dominance almost right after.  What we lost is that some transformers are FComps, some others are BComps, this explains the difficulty in remembering "ErrorT State vs StateT Error".
12:43:03 <monochrom> One reason MTL took dominance is that every transformer is known to map monads to monads. Functor compositions, meh, you lose the guarantee that composing two monadic functors results in a monadic functor.
12:43:26 <[exa]> in a distant future someone could mark the transformers like ErrorTF and StateTB
12:43:41 <monochrom> yeah that would be nice
12:43:56 <[exa]> interesting. thanks a lot
12:44:21 <maerwald> in a distant future, transformers will be extinct
12:44:32 <monochrom> haha
12:45:48 <[exa]> veverak: anyway-- "running" the monad is actually not much more complicated than just running a function; each >>= is moreless runState
12:46:41 <veverak> yeah
12:48:19 <[exa]> so I guess that something like `evalState (...) <$> get` will work just right
12:49:34 <veverak> yeah
12:49:38 <veverak> hmm
12:49:48 <veverak> I think I will hide it under some fcall or something
12:50:54 <[exa]> Reader has something similar in `local` (or what's it called)
12:56:48 * hackage mattermost-api 50200.6.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.6.0 (JonathanDaugherty)
12:57:48 * hackage mattermost-api-qc 50200.6.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-50200.6.0 (JonathanDaugherty)
12:58:48 * hackage matterhorn 50200.9.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.9.0 (JonathanDaugherty)
13:01:12 <Hopplahase> That packages have an interesting version numbering
13:02:20 <monochrom> [exa]: http://web.cecs.pdx.edu/~mpj/pubs/springschool.html has the fcomp-bcomp->transformer story. It's the same paper cited by mtl
13:02:39 <monochrom> well, summer school notes, so longer than papers :)
13:03:03 <monochrom> because lecture pace, really
13:07:30 <monochrom> Actually it is long because it first teaches the readers that there are such things as type classes, kind * -> *, and type classes for that kind, and "what is Monad?". :)
13:08:15 <monochrom> You can safely start with the section "combining monads". That's where the real fun begins.
13:18:18 * hackage differential 0.1.2.1 - Finds out whether an entity comes from different distributions (statuses).  https://hackage.haskell.org/package/differential-0.1.2.1 (GregorySchwartz)
13:18:59 <maerwald> I have been contemplating in laziness about literal haskell and hacking documentation. Then it dawned me that hacking docs have a fundamentally different structure than literal haskell
13:19:40 <maerwald> How to do it in a way that does not diverge from the code?
13:21:15 <merijn> maerwald: The problem is that literate Haskell isn't actually literate programming in the Knuth sense
13:21:27 <merijn> The code still dictates the order and structure of things
13:21:56 <maerwald> Yes, but can Knuth save us?
13:22:15 <merijn> If you wanna write Pascal, sure ;)
13:22:33 <merijn> maerwald: A colleague of mine is working on a literate programming tool: https://entangled.github.io/
13:22:53 <maerwald> Hacking docs are about anticipated changes, not necessarily about the code as a whole
13:23:06 <merijn> maerwald: One of the things it does is that, if you debug/fix the tangled code it will propagate the fix back to the literate source
13:23:47 <merijn> Although I'm not sure what you mean by "hacking documentation", so maybe literate programming is not what you want :p
13:24:14 <maerwald> as I said... anticipated changes
13:24:37 <maerwald> you outline the path to carry out such a change
13:25:31 <merijn> Maybe GHC's "notes" style would work?
13:33:20 <maerwald> https://jhidding.github.io/literatept/ can't see the non-pretty code
13:34:32 <merijn> You mean the tangled code?
13:34:39 <maerwald> yeah
13:35:00 <maerwald> and the generated stuff
13:35:28 <merijn> what do you mean generated stuff? Presumably that's the tangled code...
13:35:55 <maerwald> everything
13:37:10 <merijn> hmm, I'll ask him where the example source lives now
13:38:52 <maerwald> it could be a manually written html page after all
13:38:54 <maerwald> :p
13:39:53 <bolti[m]> Hi, I'm learning haskell. Which do you recommend me between cabal and stack?
13:40:06 <maerwald> cabal
13:41:27 <dmwit> second
13:42:35 <dmwit> maerwald: Proposal: give up on "does not diverge from the code".
13:42:56 <maerwald> =(
13:43:04 <bolti[m]> thanks
13:43:06 <dmwit> Accept "there is a maintenance burden to keep it relatively close to the code".
13:43:07 <bolti[m]> what are the major differences?
13:43:13 <maerwald> bol
13:43:17 <maerwald> oops
13:43:41 <ezzieyguywuf> if I take an M44 Float (from linear), and use the `*` operator...whwat does it do? what I actually want is the `!*!` operator, but the `*` compiles and runs but I have no clue what it's doing or why
13:44:19 * hackage calamity 0.1.14.6 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.14.6 (nitros12)
13:44:32 <dmwit> ezzieyguywuf: source is here: https://hackage.haskell.org/package/linear-1.21/docs/src/Linear.V4.html#line-208
13:44:32 <maerwald> bolti[m]: nothing important for a beginner. stack requires you to learn about a few things you don't really care about as a beginner
13:44:47 <dmwit> ezzieyguywuf: In English: elementwise multiplication.
13:44:50 <fredefox> Hi. I was wondering if anyone know if there's a place to globally configure default language extensions to use with GHC. Similarly to how you can do for ghci with ~/.ghci
13:45:18 <dmwit> fredefox: Globally? No. But cabal files have a way to specify extensions to use in every module.
13:46:01 <maerwald> bolti[m]: but they use the same base (.cabal files), so switching later is not a problem
13:46:16 <fredefox> It's just that I sometimes prototype things in a standalone haskell source file. My ghci session works fine, but when I then test it out with e.g. runhaskell then it complains about the missing extensions and I have to go through ye ol' extensions ritual.
13:46:23 <ezzieyguywuf> dmwit: ah hah. thank you for that.
13:46:56 <bolti[m]> which it's a good and up to date book for beginners, but with other programming languages experiences? 
13:47:23 <maerwald> book as in book or course?
13:47:43 <maerwald> @where cis194
13:47:43 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:48:07 <maerwald> that's a course with good exercises
13:48:23 <bolti[m]> well, actually a good source (book/blog/courses)
13:48:59 <maerwald> book maybe https://github.com/tssm/up-to-date-real-world-haskell
13:49:27 <bolti[m]> awesome!
14:02:11 * dsal writes Real Weird Haskell
14:02:33 <no-n> I write Fake News Haskell
14:05:04 * monochrom has dreamed of Complex World Haskell.
14:05:55 <monochrom> "The real world is not enought"
14:05:55 <d34df00d> Computable World Haskell would be even nicer.
14:06:02 <monochrom> haha
14:06:21 <monochrom> How would you like a compromise? Computable Real World Haskell.
14:06:49 <monochrom> I still like my Complex World idea the most.
14:07:08 <[exa]> your words deserve a cojoke
14:07:58 <monochrom> It is a pun of: 1. one-up "real", 2. complex = real part (practical) x imaginary part (theoretical)
14:18:06 <d34df00d> Real part can be equal to zero tho.
14:21:27 <tomsmeding> well, then it would just be an imaginary course, wouldn't it? :)
14:34:19 * hackage preql 0.3 - safe PostgreSQL queries using Quasiquoters  https://hackage.haskell.org/package/preql-0.3 (bergey)
14:38:04 <ja> oh that preql looks easy to use
14:38:59 <monochrom> haha neat name
14:45:04 <Cale> Kinda sorta similar to the quasiquoter I use with postgresql-simple
14:49:21 <ja> Cale: what is it called?
14:50:47 <nshepperd2> https://github.com/bergey/preql#quickstart neat
14:51:52 <Cale> ja: http://dpaste.com/2CYYDHS
14:52:53 <Cale> The idea is that [sqlQ| ... ?foo ... ?bar ... |] gets transformed into ("... ? ... ? ...", [toField foo, toField bar])
14:53:19 <Cale> which can then be used as the arguments to postgresql-simple's query
14:54:43 <Cale> ah, ignore the fromIdRow thing, that's unrelated
14:56:03 <ja> oh that does seem a bit more safe because you cannot mismatch the amount of question marks and parameters
14:56:13 <ja> (more safe than psql-simple)
14:56:35 <Cale> Yeah, and it's just clearer when you're reading complicated queries that would otherwise have a large number of parameters at the end
15:08:10 <koz_> Has anyone used tmp-postgres before? I'm getting ConnectionTimeout from it all the time, and I have no idea why.
15:55:49 <dminuoso> Cale: So I went through everything you said, and I stumbled at hold already - in some sense the rest seems easy, assuming I can make sense of hold.
15:56:16 <dminuoso> It's not quite clear what kind of monadic effects you might be having here.
16:02:58 <xsperry> is it impossible to catch HttpException from http-client? it is defined in http-client, which is a hidden module, and I don't see it being by any other module
16:03:10 <xsperry> HttpExceptionRequest, even
16:04:54 <dminuoso> xsperry: https://hoogle.haskell.org/?hoogle=HttpException
16:05:01 <dminuoso> xsperry: You can instantly see all modules that export said identifier.
16:05:16 <dminuoso> In that list, you can see Network.HTTP.Client, amongst other things.
16:06:09 <xsperry> https://hoogle.haskell.org/?hoogle=HttpExceptionRequest&scope=set%3Astackage
16:07:25 <xsperry> I imported all the modules listed there, it's not defined. I'm probably using an older version, in which it was defined in a hidden module
16:07:38 <xsperry> haskell offers no escape hatch?
16:07:57 <dminuoso> There's highly unsafe escape hatches.
16:08:00 <dminuoso> Just update your http-client?
16:08:25 <xsperry> escape hatch for accessing hidden modules
16:08:37 <dminuoso> Not that, but an escape hatch to do what you want.
16:09:29 <dminuoso> How old is your library, really.
16:09:30 <xsperry> my project is very big, and it is using old ghc and libraries. what I really want is ability to access hidden modules, but it seems that isn't possible
16:09:43 <dminuoso> Back until 0.4 at the least, HttpException(..) is re-exported from Network.HTTP.Client.
16:10:55 <xsperry> data HttpException   = HttpExceptionRequest Request HttpExceptionContent | ...   	-- Defined in http-client-0.5.7.1:Network.HTTP.Client.Types
16:10:56 <dminuoso> back until 0.2...
16:11:23 <dminuoso> xsperry: All versions that have HttpExceptions re-export it.
16:11:36 <xsperry> oh wait, HtptExceptionRequest is a constructor
16:11:41 <xsperry> HttpException is the type
16:11:47 <dminuoso> https://hackage.haskell.org/package/http-client-0.5.7.1/docs/Network-HTTP-Client.html#t:HttpException
16:12:16 <xsperry> I misread error messages
16:12:38 <xsperry> anyway, it would still be nice to have ability to access hidden modules
16:12:53 <xsperry> even though I didn't need it this time
16:13:07 <koz_> Also, if I wanna run something via the shell (CLI program), then let it run in the background while I do other stuff, then kill the background thing I started?
16:13:07 <dminuoso> xsperry: No it would not be nice.
16:13:12 <koz_> If so, what should I use to do that?
16:13:16 <dminuoso> xsperry: It'd defeat the entire point of having hidden modules to begin with.
16:13:35 <xsperry> dminuoso that's like saying that unsafePerformIO defeats the entire point of having IO type
16:13:43 <dminuoso> koz_: Use `process`?
16:14:29 <koz_> dminuoso: So something like this function? http://hackage.haskell.org/package/process-1.6.10.0/docs/System-Process.html#v:createProcess
16:14:31 <dminuoso> xsperry: Encapsulation is so that you don't depend on my moving parts. Perhaps because you could violate preconditions if you had access to internals.
16:14:51 <dminuoso> It doesn't compare to unsafePerformIO at all.
16:14:56 <koz_> (with, like, bracket or something)
16:14:56 <monochrom> Over in #haskell-offtopic, they were just musing that encapsulation is an honour system. :)
16:15:04 <dminuoso> Dont make this a strawman argument. :)
16:15:38 <xsperry> dminuoso, it does, you do both at your own risk
16:15:46 <dminuoso> That being said, if the thing you're talking about appears in a positive position, you can unsafeCoerce... at your own risk.
16:16:22 <dminuoso> With the chance of causing seg faults when GHC versions change, when GHC flags change, when simplifier or other optimizations suddenly kick in because of some metric change..
16:16:29 <dminuoso> On updates..
16:16:40 <dminuoso> unsafePerformIO is relatively benign, in comparison.
16:17:24 <xsperry> unsafePerformIO and unsafeCoerce, or even just messing with FFI, are more dangerous than messing with internals. if things break in the future, you'll get compile error
16:17:33 <dminuoso> no you dont.
16:18:13 <dminuoso> You could also end up with crashes or perhaps random runtime bugs that might attribute to the library
16:18:24 <xsperry> highly unlikely
16:18:58 <xsperry> you could, but that is far less likely than just messing with FFI
16:19:31 <dminuoso> If people can access it, people will use it.
16:19:40 <solonarv> actually, there is a package which does exactly this (violating module boundaries)
16:19:42 <dminuoso> That means, updates will cause breakages if you cant enforce encapsulation.
16:19:43 <solonarv> @hackage true-name
16:19:44 <lambdabot> https://hackage.haskell.org/package/true-name
16:20:24 <xsperry> you could, but that is far less likely than getting a crash when messing with FFI. what's the point of haskell's type system, if you can avoid it by dicking around with raw memory?
16:20:59 <xsperry> people don't mess with FFI if they can do what they want in haskell. likewise, people wouldn't access libraries internals if they could do what they wanted with public interface. but library writers aren't perfect, and sometimes they don't export things they should have
16:21:12 <dminuoso> Then submit your requests upstream.
16:21:17 <dminuoso> Fix the problem the right way.
16:21:39 <xsperry> why not both? do that, and also get working code right away
16:21:43 <dminuoso> Your problem isnt "doesnt have a backdoor", your problem is a (fictional, because it wasnt even your issue!) "library has a bug
16:21:50 <dminuoso> xsperry: Fork the library and fix it.
16:21:54 <dminuoso> It takes very little effort.
16:22:16 <xsperry> dminuoso, it wasn't an issue in this case, that doesn't mean it can't be in another
16:22:38 <xsperry> and do that every time new version appears? for few years, when they get around to fixing it, maybe
16:22:44 <dminuoso> xsperry: Curious how quickly you got to "is there an unsafe backdoor", rather than looking at your problem objectively.
16:22:46 <dminuoso> Isnt it?
16:22:59 <dminuoso> 01:22:16         xsperry | and do that every time new version appears? for few years, when they get around to fixing it, maybe
16:23:01 <dminuoso> Send it upstream.
16:24:20 <dminuoso> That being said, there is good reasons to actually export internal modules.
16:24:34 <dminuoso> e.g. bytestring does this
16:24:53 <xsperry> and a good reason to have escape hatch, when library writers fail to do so. even if you won't admit it
16:25:24 <xsperry> again, same argument could be used against FFI and unsafe*. haskell was pragmatic in those cases
16:25:34 <dminuoso> Well, the way it works right now promotes open source contributions.
16:25:42 <dolio> Why even have hidden modules in that case?
16:25:51 <dminuoso> Rather than you working around libraries by prying into their internals, just fix it and contribute.
16:25:59 <dminuoso> Id say this is a good thing.
16:26:05 <xsperry> dolio, why have IO if there are unsafe functions? why have type safety if you can do FFI?
16:26:17 <dminuoso> xsperry: The unsafe functions are necessary for advanced uses
16:26:22 <dolio> That isn't a good analogy.
16:27:00 <dminuoso> xsperry: For instance, bytestring would have much poorer performance, if it wasnt for accursedUnutterablePerformIO (amongst other things)
16:27:02 <dolio> IO does a lot of work, and it's impossible to wrap certain things without unsafePerformIO.
16:27:16 <xsperry> dminuoso it can encourage some people to fix the library and contribute. but it can also encourage other people to drop the library all together, and maybe even drop haskell
16:27:18 <dolio> What does having hidden modules do if you can just access them?
16:27:39 <xsperry> dolio, implementation writers don't need IO to wrap those things
16:27:51 <xsperry> don't need unsafePerformIO*
16:27:54 <dminuoso> xsperry: They do.
16:28:00 <xsperry> they can do whatever they want, without exposing unsafe* to users
16:28:12 <xsperry> no
16:28:15 <dolio> It's impossible to interact with C libraries that use structures without unsafePerformIO.
16:28:27 <crestfallen> hi I cannot figure out how to supply arguments to (>>=) for the ST monad. given the density of the textbook at this point. (included with ST monad code at bottom of paste). please show me how to use it (the <*> version is above the monad version, with an understood example. thanks https://termbin.com/kl6a 
16:28:34 <dolio> Because you have to access pointers, even if the functions you're wrapping are pure.
16:28:35 <xsperry> don't interact with C libraries. do the Right Thing and write the library in haskell.. from scratch. 
16:28:48 <dminuoso> Sometimes ST is not enough for what you do, you sometimes need full blown IO.
16:28:49 <xsperry> it would encourage people writing pure haskell libraries!
16:29:02 <dminuoso> xsperry: That's a silly argument for so many reasons.
16:29:29 <xsperry> or we could just be pragmatic.. and let consenting adults do what they want. it doesn't affect you. even if haskell had an escape hatch to access hidden modules, you DON'T have to use it
16:29:36 <xsperry> dminuoso, no more silly than yours
16:29:43 <dminuoso> FFI is incredibly useful for a variety of reasons. You can FFI to obtain high performance implementations of algorithms, you can FFI to use *existing* libraries that you dont want to reimplement.
16:29:56 <dminuoso> Or maybe its a security issue, you wouldn't want to reimplement OpenSSL yourself.
16:30:23 <dminuoso> xsperry: Designing a language is always a trade off between how much we constrain a user, and how many tools we give you to shoot off your foot.
16:30:25 <xsperry> accessing library internals can mean the difference between hitting the deadline, and losing the job. pragmatic languages have ability to access internals, or private members, or..
16:30:39 <dminuoso> That's a bit dramatizing it.
16:30:53 <dminuoso> If you really do have a need to access some bits, you change the library.
16:31:11 <xsperry> you think my scenario is impossible?
16:31:31 <dminuoso> If accessing library internals is the difference between hitting the deadline and losing the job, honestly you have far worse problems.
16:31:39 <Cale> dminuoso: MonadHold t m means that m is a monad which is like a reader monad for the current time, insofar as you can perform a hold in it -- hold is specified to ignore any occurrences of the Event which might have occurred in the past
16:31:47 <xsperry> it could be the thing that tips the scale
16:32:04 <dminuoso> xsperry: And based on that argument, we should implement that backdoor? :)
16:32:09 <dminuoso> So you can keep your job?
16:32:23 <dminuoso> You're gonna lose it either way, if that's whats tips the scale.
16:32:39 <xsperry> dminuoso, it's just one example. don't dwell on it too much. but pragmatic languages have escape hatches for a reason
16:32:43 <dminuoso> Cale: Is there some reason why this is called hold?
16:32:45 <Cale> (i.e. you get a Behavior which has the initial value "now", and it changes only when the Event occurs either now or at later times
16:32:48 <Cale> )
16:33:20 <Cale> It's like you're carrying the value of the Event into the future -- without a hold, you would forget it
16:33:50 <crestfallen> scratch that, there's an error. let me re-paste..
16:33:52 <xsperry> dminuoso, if you want another reason.. things like this can drive people away from haskell. especially when people likely you blindly defend it
16:33:54 <Cale> If you want to think operationally, hold creates a new memory cell
16:34:18 <Cale> It stores the value into it whenever the Event fires
16:34:24 <dminuoso> xsperry: If your biggest problem with Haskell is lacking tools to break encapsulation, then Im fine with you not using Haskell. :)
16:34:47 <Cale> What? Haskell doesn't have enough escape hatches?
16:35:06 <dminuoso> Cale: Im a bit confused why this generates some `m (Behavior t a)` rather than `m a`
16:35:19 <xsperry> I'm too deep in the rabbit hole for this to stop me, but some newbies can be discouraged. and contributing to the open source community, and fixing the library they want to use, likely isn't their initial reaction
16:35:20 <Cale> Ah, because it's generating a thing that changes over time
16:35:34 <xsperry> Cale, escape hatch to access hidden modules
16:36:14 <dminuoso> xsperry: How do you think a decent senior would respond, if your argument to not Haskell was "it doesnt allow you to break encapsulation"?
16:36:22 <dminuoso> Ponder about it, for a while.
16:36:31 <Cale> xsperry: Ah, our escape hatch for that is to apply patches to the .cabal file using nix :P
16:36:43 <dolio> I still don't understand why you think hidden modules should even exist.
16:36:55 <xsperry> I'd rather if they didn't exist, than that they do, without an escape hatch
16:37:25 <crestfallen> regrets, please look at the bottom of this paste. trying to figure out how to utilise >>= in State Monad (text included .. very terse! ) thanks https://termbin.com/fee8
16:38:19 <dminuoso> Cale: Huh... but how would hold know what behavior that would be? Is that encoded into the Event somehow?
16:38:45 <dminuoso> Or is that in the sense, that the Event can be repeated - such that you get some sort of.. function out of it?
16:39:07 <Cale> Events can occur zero or more times
16:39:26 <Cale> an Event is morally like a sequence of (time, value) pairs where the times are strictly increasing
16:39:52 <Cale> hold creates a step function from that
16:40:03 <dminuoso> Cale: So hold is sort of turning `[(Time, Value)]` into `Time -> Value`? 
16:40:16 <crestfallen> the textbook text is in {-- comments --}
16:40:30 <Cale> which has the given initial value at all times before now, and then which changes to the value given in the Event whenever the Event occurs
16:40:34 <Cale> yeah
16:40:56 <Cale> and it changes immediately *after* the Event occurs
16:41:09 <Cale> So it will definitely have the given initial value now
16:41:18 <Cale> and if the Event is firing right now as well
16:41:44 <Cale> then it will immediately switch to the new value afterward
16:42:21 <dminuoso> So if I had some `Event t Color`, maybe caused by pressing buttons representing colors, I could use `hold` to generate a Behavior that produces the "current color" of sorts.
16:42:32 <solonarv> yup
16:42:34 <Cale> yes, exactly
16:44:29 <Cale> and if you put the ability to remember the past together with recursion, you get the ability to maintain state over time
16:45:53 <Cale> (which I elaborated on before somewhat)
16:46:49 <Cale> This is the sense in which FRP gives you the ability to have state which is totally confined to the definition of something -- in the end you get some Behaviors or Events which are pure values that represent the entire history of something which is changing over time
16:47:11 <Cale> and the only impurity is this kind of Reader-like notion of needing to know when "now" is
16:47:56 <Cale> We *could* have an operation which is like hold, but pure, but it would potentially require us to retain information about previous occurrences of Events
16:48:32 <Cale> i.e. if it doesn't ignore the occurrences of the input event from the past, then we need to keep those around
16:48:56 <Cale> So, this specification is more convenient, and also usually what you really wanted anyway
16:49:20 <Cale> (more convenient for both the implementor and the user, typically)
16:55:07 <crestfallen> if anyone has time to look at the last section of this paste: https://termbin.com/56fz
16:55:40 <crestfallen> how to supply (>>=) with arguments. I've tried everything; and don't understand the textbook
16:55:57 <xsperry> arg1 >>= arg2
16:56:30 <xsperry> :t getLine >>= putStrLn
16:56:31 <lambdabot> IO ()
16:59:59 <crestfallen> xsperry, thanks, there's not a way to use that is in the <*> example, as with Just evenTick >>= Just [0..3]    ?
17:00:25 <xsperry> there isn't
17:00:48 * hackage checkers 0.5.6 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.6 (sjakobi)
17:00:58 <crestfallen> I need some explanation, esp. help understanding the distinction (attempted in the text included above Monad ST code)
17:01:09 <xsperry> with Applicatives, an action can't depend on a value from a previous action
17:03:11 <crestfallen> ok xsperry yes thanks that is helpful. so in your example ST is used like IO . I mean, is it exactly interchangable ?
17:03:18 <xsperry> np
17:03:48 <xsperry> I have to run, I'm about to be disconnected from my isp
17:04:00 <crestfallen> the book is so bloody terse.. ok thanks!
17:06:48 * hackage math-programming 0.3.0 - A library for formulating and solving math programs.  https://hackage.haskell.org/package/math-programming-0.3.0 (prsteele)
17:10:29 <dsal> crestfallen: I think you're confusing yourself by calling your `State` `ST` and then thinking it has something to do with `ST`
17:11:07 <MarcelineVQ> dsal: why do you say so?
17:11:11 <dsal> Or... something.  I don't know how you're confused.
17:11:35 <dsal> MarcelineVQ: "in your example ST is used like IO . I mean, is it exactly interchangable"
17:11:45 <monochrom> It is possible that the book in question says "ST".
17:11:54 <crestfallen> I thought it could be used precisely as the <*> example Just evenTick <*> ...
17:12:09 <dsal> Yeah, you can call it what you want, but if you think it has something to do with IO, then there might be some confusion.
17:12:17 <monochrom> But yeah by this point everyone ought to know to distrust "meaningful" names.
17:12:32 <crestfallen> please explain monochrom 
17:12:43 <dsal> Well, monochrom is a teacher...
17:12:57 <dsal> I give up.  I can't explain monochrom.
17:13:10 <monochrom> There is nothing to explain about distrusting "meaningful" names. You know it's true, you accept it.
17:13:14 <crestfallen> this is presented as state transformer in the book. without any discussion of state first.. or am I wrong about that?
17:14:12 <crestfallen> I've read that the State Monad is slightly less powerful than IO
17:14:13 <monochrom> Yes. Explaining "state transformer" is equivalent to explaining "state". Two sides of the same coin.
17:14:38 <monochrom> From a mathematical point of view, actually "state transformer" is more real, "state" is more fiction.
17:14:43 <dsal> It's less powerful than IO in the same way that my handgun is less powerful than my car.
17:15:04 <monochrom> And please simply don't drag IO into this.
17:15:43 <crestfallen> I'm just citing something I read and didn't understand 
17:16:15 <crestfallen> so what is the distinction? the car/gun analogy is funny but I don't get it
17:16:16 <dsal> I guess my question is "why is IO part of this discussion?"
17:16:31 <monochrom> In my class notes I actually have great fun saying "how to support the fairy tale of state by the mathematical reality of functions"
17:17:28 <dsal> crestfallen: My car has a gigantic battery, much power.  My handgun is small and doesn't have a lot of power relative to my car.  But the sun is even more powerful than either.  It's weird to compare them, though.  "I like this Sig... but i'd like more power."  "Say no more, check out this car..."   It's confusing and unhelpful.  Like my analogy.
17:17:57 <crestfallen> I was looking for examples on how to use >>= in a State Monad and then:
17:18:05 <monochrom> Tangents upon tangents, are we? I can help with that.
17:18:26 <monochrom> Dijkstra had a few articles saying "lock, stock, and barrel" while we're at guns.
17:18:41 <monochrom> (I never understood the metaphor. Still don't.)
17:18:44 <crestfallen> > :t getLine >>= putStrLn 
17:18:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:19:20 <crestfallen> :t getLine >>= putStrLn 
17:19:21 <monochrom> I presume the book has examples one or two pages later?
17:19:21 <MarcelineVQ> "<crestfallen> how to supply (>>=) with arguments."  write   x >>= y  where x and y are values of a type that fits into the type signature of >>=
17:19:21 <lambdabot> IO ()
17:19:38 <MarcelineVQ> So if your real question is, how do I make a value of ST a, ask that question.
17:20:05 <monochrom> Why are you still dragging IO into this?
17:20:30 <monochrom> No, that's a rhetorical question, I don't want an answer, it's a statement.
17:20:46 <MarcelineVQ> And if it's not that question, then come up with a more specific one, because  "how do I apply a function in haskell" is not a question you should still be asking by this point
17:21:14 <MarcelineVQ> It's actually insulting to be asking that still given all the time people have spend on your tasks
17:21:20 <koz_> Also, I need something that makes building Strings (specifically) less of a pain. Like, I have a record I have to pull apart, stringifying different things differently, and then glomping it all into a big String. What would you folks suggest I use?
17:21:51 <monochrom> I think I like the String->String idiom for that.
17:22:20 <MarcelineVQ> monochrom: is that like ShowS ?
17:22:24 <monochrom> Yes!
17:23:09 <crestfallen> I feel like people gang up on me. it's pretty sad considering that there are "teachers" who use opaque language and talk above my head 
17:23:34 <monochrom> I don't know whether it reduces pain.  It is just replacing "f x ++ f y" by '(g x . g y) "" '
17:23:38 <koz_> monochrom: So would I basically use 'showsPrec' a bunch of times or something?
17:23:59 <MarcelineVQ> I wish people ganged up on you, people seem to gang up for you instead, falling over each other to assist with your inane going-nowhere
17:24:13 <monochrom> But the good news is that all those ByteString.Builder, Text.Builder are based on a similar idea.
17:24:16 <MarcelineVQ> Take responsibility for your learning.
17:24:52 <monochrom> You can use "shows", if you don't have precedence numbers.
17:25:10 <crestfallen> you wish people ganged up on me?
17:25:24 <MarcelineVQ> And the rest of what I said.
17:25:35 <dsal> I feel like the rest was really more interesting.
17:27:48 <crestfallen> MarcelineVQ, give me the word to leave the channel permanently, and I'll do it dsal monochrom 
17:28:27 <dsal> crestfallen: The point he's making is that people are trying really hard to help you.  Would you rather people not try to help you?
17:28:40 <MarcelineVQ> That would again be making it our responsibility.
17:29:49 * hackage timer-wheel 0.3.0 - A timer wheel  https://hackage.haskell.org/package/timer-wheel-0.3.0 (mitchellwrosen)
17:30:46 <crestfallen> without this channel, I cannot learn haskell from books. so I'm not blaming you for my demise, but I'm 59, I don't know what "take responsibility for your learning" means at all
17:31:44 <MarcelineVQ> It means when you don't understand something you work on it yourself instead of asking for a rescure that you so far don't actually learn from.
17:32:26 <MarcelineVQ> It also means when conforted with that you don't try to get people to tell you to leave so that you can say, "well I couldn't learn because people told me to leave, not my fault"
17:32:43 <dsal> I don't think anyone can learn Haskell from books.  I learned Haskell from having programs I needed working.  Books helped, but there's not much I've ever understood from just reading.
17:34:16 <MarcelineVQ> *asking for a rescue
17:34:32 <dsal> I've read books on Haskell that I understand about 3% of because most of the topics don't have anything to do with things I end up doing.  There's some skeletal knowledge I have beyond that where I know that a thing exists, but only enough to know which book I need to grab if I ever encounter that type of problem.
17:34:48 * hackage math-programming-tests 0.3.0 - Utility functions for testing implementations of the math-programming library.  https://hackage.haskell.org/package/math-programming-tests-0.3.0 (prsteele)
17:36:12 <crestfallen> dsal but are you coming from a programming background? I've been a lumberjack most of my life
17:36:23 <dsal> You're a lumberjack, and that's OK.
17:36:41 <dsal> I still think Haskell in particular is harder for programmers than non-programmers.
17:37:19 <monochrom> Yes but on condition that we're comparing has-STEM-aptitude programmers with has-STEM-aptitude non-programmers.
17:37:43 <dsal> Yes, I was going to put a ton of footnotes on that.
17:37:43 <monochrom> For example a biologist some of us brought up a few days ago. :)
17:38:52 <dsal> Many mainstream programmers are so attuned to what they think computers *do* that they have a hard time separating that model from what they actually want happen.
17:39:18 * hackage typed-encoding 0.4.2.0 - Type safe string transformations  https://hackage.haskell.org/package/typed-encoding-0.4.2.0 (rpeszek)
17:39:26 <justsomeguy> Honestly I think Haskell is just hard.
17:40:55 <dsal> Well, programming is kind of hard sometimes.  Haskell is easier for me almost all the time.  Occasionally I realize a thing I want to do is hard to do in Haskell because it was a lie.
17:41:41 <sm[m]> crestfallen: sometimes the "teaching" here fails. Don't give up! Try again another day
17:41:48 <dmj`> justsomeguy: just study the typeclass instances
17:42:28 <dmj`> justsomeguy: when you see a `>>=` and can replace it with flip concatMap in the list monad in your head, you're learning.
17:42:35 <sm[m]> there are other haskell chat channels too, eg on Matrix
17:42:53 <dsal> To sm[m]'s point, I often think I have the perfect way to explain something -- exactly how I wish someone had explained it to me.  Turns out, some people find enlightenment on different paths.
17:44:22 <MarcelineVQ> Yes, do try another day, please continue to waste other human being's time and goodwill on your journey to nowhere
17:44:54 <sm[m]> people here also get burned out and cranky, and don't always give the best possible help at every time. Speaking for myself.
17:45:30 <monochrom> No, IMO today is a case of low-quality, cryptic questions.
17:46:21 <sm[m]> you still fail if you drive off a sincere beginner
17:46:57 <sm[m]> s/you/we/
17:47:23 <MarcelineVQ> I agree
17:48:48 <MarcelineVQ> That would be a bad thing to do and would even have a negative effect on the world
17:49:23 <MarcelineVQ> Since that person could have done something incredible with some help getting going.
17:50:42 <monochrom> I'll draw an analogy with the corporate world in #haskell-offtopic to show you what goes wrong with a vision of a no-risk world!
17:53:39 <sm[m]> crestfallen: also, try another book
18:08:45 <d34df00d> Let's say I have a type for representing terms, parametrized by some annotation:
18:08:53 <d34df00d> https://bpaste.net/QWRQ
18:09:27 <d34df00d> And suppose I want to write a function that recurses over a term, doing something non-trivial just for a single constructor, akin to
18:10:30 <d34df00d> https://bpaste.net/3ZXA
18:10:36 <d34df00d> How can I do this without this much boilerplate?
18:11:48 * hackage math-programming-glpk 0.3.0 - A GLPK backend to the math-programming library.  https://hackage.haskell.org/package/math-programming-glpk-0.3.0 (prsteele)
18:12:51 <koz_> I have something weird happening. For some reason, this code here kills the process before 'act' can fire: https://gist.github.com/kozross/b69670c422edaf7651ea37ebb401b4ae
18:12:59 <koz_> Did I misunderstand something about how System.Process works?
18:15:17 <infinisil> d34df00d: https://hackage.haskell.org/package/data-fix is an option
18:15:52 <dsal> koz_: act is looking for the process exit code, isn't it?
18:16:09 <d34df00d> infinisil: hm, that's an interesting package!
18:16:22 <koz_> dsal: What gives you that idea?
18:16:38 <koz_> act doesn't interact with the process exit code at all.
18:16:40 <d34df00d> Although the intrinsic domain complexity is a bit too high for me at this point, so ideally I'd like to isolate the boilerplate reduction complexity to the function instead of propagating it to the type.
18:16:54 <dsal> koz_: `mec <- getProcessExitCode ph`  and then you case on that and call act on one of the branches.
18:17:17 <koz_> dsal: http://hackage.haskell.org/package/process-1.6.10.0/docs/System-Process.html#v:getProcessExitCode
18:17:31 <koz_> It's non-blocking, so it should give back Nothing instead of waiting around, right?
18:17:36 <dsal> ahh
18:17:59 <koz_> Like, that would make sense if I used waitForProcess, but even then it's a bit weird, since the Redis server needs to be signalled to shut down.
18:18:10 <koz_> And it's somehow getting signalled to shut down even though 'act' never fired in my case.
18:18:35 <infinisil> d34df00d: Might not be possible without changing anything about the type. Mainly because there's nothing special about the first argument of constructors that distinguishes it as the "thing that shouldn't change"
18:19:09 <dsal> koz_: Is it calling act?
18:19:32 <koz_> dsal: Yeah, which then asplodes because it can't find a server to connect to.
18:19:33 <d34df00d> Hmm, this is suddenly making me think about uniplate, where I can literally pattern-match on the ctors to do extra stuff for them.
18:19:47 <dsal> koz_: Any chance you're acting on it before it binds?
18:19:49 <koz_> So, sequence is meant to be 'spin up server, check it actually spun up, act, cleanup'.
18:19:56 * dsal has this problem in his mqttd tests
18:20:04 <koz_> Actual sequence I am seeing is 'spin up server, check it actually spun up, cleanup, act'.
18:20:09 <d34df00d> Haha, yeah, transformM might do the trick!
18:20:23 <d34df00d> ...I think.
18:20:23 <dsal> Oh.  That's even weirder.
18:20:48 <koz_> I could try sleeping the process for a while?
18:21:12 <koz_> So like, just before I call getProcessExitCode I can have it nap for a while.
18:21:37 <koz_> I might actually be reverse-TOCTOUing myself here. :P
18:21:51 <koz_> Would threadDelay be the thing to use here?
18:22:03 <infinisil> d34df00d: (I don't think so)
18:22:19 <frdg> question about Monad instance for Compose: https://pastebin.com/3xEAWsv8
18:22:45 <koz_> frdg: I think the easiest way to see it is to try and write join.
18:22:50 <koz_> You'll see the issue basically right away.
18:23:02 <dsal> koz_: In my case, I'm currently sleeping because my server thread is using conduit and I do't have a good bind-trigger.
18:23:12 <koz_> dsal: Do you use threadDelay?
18:23:27 <dsal> Yeah, I just sleep 1 second out of laziness.
18:23:28 <koz_> Or is there another way?
18:23:30 <koz_> Ah.
18:24:05 <dsal> I have a nice commandline program that waits for a socket to respond, but it's actually kind of a lot of code to shove into a test.  I'll probably do it just to take nearly a second off my tests.
18:24:19 <frdg> koz: what do you mean by try to write join?
18:24:34 <frdg> you mean in the instance decleration?
18:24:37 <dsal> The threadDelay will at least tell you if it's this kind of problem.
18:24:51 <koz_> frdg: Try to write join for Compose, instead of bind.
18:25:00 <koz_> dsal: I tried injecting a threadDelay 1000 - same issue.
18:25:09 <frdg> ok
18:25:10 <dsal> threadDelay is micros.
18:25:25 <koz_> 1000 micros == 0.1 second?
18:25:32 <dsal> seconds = (1000000 *)
18:25:52 <dsal> sleep = threadDelay . seconds  -- I just added a `sleep 1` in my test.
18:25:56 <koz_> Oh, so it's _millionths_ of a second? Argh.
18:26:27 <koz_> frdg: Start with the type signature, specialized for Compose.
18:26:33 <koz_> Even that alone should give you a clue.
18:26:37 <infinisil> Having a standard type for durations would be nice!
18:26:43 <koz_> infinisil: Yes, this.
18:26:56 <koz_> Especially since 'threadDelay -42' is well-typed at present.
18:27:54 <koz_> dsal: Well, doesn't seem to be that kind of issue, so I guess it's back to digging.
18:27:56 <koz_> Thanks anyway.
18:27:57 <dsal> Yeah, I'm really annoyed by all the adhoc durations.
18:28:02 <infinisil> Who knows, this might become relevant when time travel is invented!
18:28:03 <dsal> koz_: News is good news.  :)
18:28:16 <MarcelineVQ> koz_: with bracket, cleanup always runs, so if you see cleanup (terminateProcess?) run before act, it suggests act is too lazy somewhere, or that the result of act is being used too lazily. Though I'm pretty bad with the specifics of what's lazy and not.
18:28:58 <koz_> Would rewriting 'Right <$> act RedisInstance' to do-notation and then !-annotating the result work?
18:29:28 <frdg> join :: f (g (f (g a))) -> f (g a) ?
18:29:33 <koz_> frdg: Yep.
18:29:54 <koz_> Now observe that we can mash f (f a) into f a, and g (g a) into g a, but we can't do anything with f (g a).
18:30:02 <koz_> Unless we can move the layers around.
18:30:11 <koz_> This is what folks mean when they say 'monads aren't commutative'.
18:30:32 <koz_> (the two mashes we _do_ have we get from the fact that f and g are Monads, and thus have joins of their own)
18:30:52 <infinisil> d34df00d: Btw, I happen to know about hnix, which does its AST + annotation representation like this (using data-fix): https://hackage.haskell.org/package/hnix-0.9.0/docs/Nix-Expr-Types-Annotated.html#t:NExprLoc
18:32:31 <koz_> MarcelineVQ: The answer to my question is 'nope lol'.
18:33:35 <koz_> Also, how do I stop the Redis server spewing into my terminal?
18:35:50 <frdg> `join Compose (Compose fga)) = undefined.` Is this how I would pattern match?
18:36:26 <frdg> *with another paren of course!
18:36:35 <koz_> (also, that join type sig isn't 100% right, since it mentions Compose nowhere)
18:36:38 <solonarv> no (try it; you'll get a type error)
18:43:56 <MarcelineVQ> koz_: how do you know terminateProcess is happening before act? and did you try to delay the terminateProcess rather than getProcessExitCode?
18:46:03 <frdg> koz_: Ok I think I see it. The problem is that f and g aren't together. Because f and g are monads we could easily do `f (f a) -> fa` and `g (g a) -> g a` but seperate Monad types cant just be combined like this.
18:46:29 <MarcelineVQ> and is there any chance your act delivers its actual result asyncronously or lazily (e.g. uses  unsafeInterleaveIO) ?
19:02:21 <ezzieyguywuf> I'm struggling figuring out the appropriate way to use the linear package to perform matrix math
19:03:04 <ezzieyguywuf> if I have a 4 x 4 transformation matrix, how do I apply that transformation to a V3? I know I have to make it a V4 by setting the last component to 1, but I'm confused about the !* vs *! operators
19:03:24 <ezzieyguywuf> it seems I want to do myTrans !* myPoint, but I get weird results doing this
19:03:57 <solonarv> weird how?
19:04:13 <ezzieyguywuf> specifically, if I build a transformation matrix `myTrans = perspective (pi/2.0) 1.0 0.1 1000 :: M44 Float`
19:04:33 <ezzieyguywuf> and if I apply that as `myTrns !* (V4 10 10 (-10) 1)`
19:04:53 <neshpion> why shouldn't i just learn F#
19:05:04 <ezzieyguywuf> I expect an answer with (V4 x y z w) where w is not zero. but w ends up as zero
19:05:05 <monochrom> You should.
19:06:49 <MarcelineVQ> neshpion: it's healthy for a human to have a broad perspective and toolkit, for that reason alone you should lean F#, and you shouldn't just learn F#
19:07:17 <ezzieyguywuf> http://dpaste.com/2PNBGCA
19:07:18 <MarcelineVQ> *learn :>
19:07:31 <ezzieyguywuf> this is the code I'm working with for the matrices
19:09:37 <ezzieyguywuf> oh, I accidentally deleted it, but I had `p1 = V3 10 10 0 :: V3 Float` in there as well that I was feeding into `showTrans`
19:17:05 <ezzieyguywuf> ah, nvm I think I got it, I guess I had some parens in the wrong spots or something
20:03:02 <koz_> MarcelineVQ: I guess I should check that, and no.
20:03:10 <koz_> But that can be for Monday, since I'm done with work for the day.
20:34:54 <d34df00d> infinisil: yeah, that makes sense, I don't think so now too.
20:35:18 <d34df00d> The link is interesting! So many abstractions out there to build the representation, that's cool!
22:09:17 <hololeap> are applicatives always composable? if you have (for instance) newtype T a = T (f (Foo a))
22:09:39 <hololeap> if f and Foo are applicatives, can you always make an applicative out of T?
22:10:30 <hololeap> *newtype T f a = ...
22:12:45 <hololeap> it seems like something in the vein of `T f1 <*> T f2 = liftA2 (<*>) f1 f2` would always work
22:13:29 <suzu_> yeah, they compose
22:14:04 <hololeap> suzu_: thanks
22:14:08 <suzu_> Data.Functor.Compose has a: newtype Compose f g a
22:14:26 <suzu_> which represents composing two functors, f and g
22:14:37 <suzu_> and then they provide this instance:
22:14:40 <suzu_> instance (Applicative f, Applicative g) => Applicative (Compose f g) where
22:15:02 <suzu_> and it has this definition that melts my brain
22:15:04 <suzu_>     pure x = Compose (pure (pure x))
22:15:06 <suzu_>     Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)
22:15:13 <suzu_> but it does typecheck so it's probably right
22:15:15 <suzu_> lol
22:16:31 <hololeap> it's not too brain-melty
22:17:46 <hololeap> it's the same definition for (<*>) that i wrote above. (<*>) <$> f <*> x === liftA2 (<*>) f x
22:18:14 <hololeap> but yeah looking at the instances for Compose is a good idea
22:19:04 <hololeap> too bad monads don't compose :p
22:19:29 <hololeap> somebody should fix that :p
22:27:18 * hackage enummaps 0.1.0.0 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.1.0.0 (leif)
22:33:53 <suzu_> lol yes
22:33:57 <suzu_> somebody ought to just make monads compose
22:34:19 <hololeap> if i'm not mistaken, it's `join` that makes monad non-composable. there is no way to join f (g a) for any monads f and g...
22:35:22 <hololeap> no, it's `f (g (f (g a)))`
22:35:35 <hololeap> that's where the trouble lies
22:35:39 <suzu_> what about bind?
22:35:42 <suzu_> what would bind look like
22:35:49 * hackage enummaps 0.6.2.1 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1 (leif)
22:35:56 <hololeap> bind is just a different way of doing join
22:36:09 <hololeap> there's an implicit join inside of bind
22:36:46 <suzu_> hmm i suppose yeah
22:38:53 <suzu_> join = x >>= id
22:42:21 <hololeap> it's a combination of `f = (a -> m b)` and `g = (forall a. m (m a) -> m a)`. g . fmap f == (>>= f)
22:45:20 <hololeap> g being `join`
22:52:49 * hackage enummaps 0.6.2.1.1 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1.1 (leif)
23:06:12 <Axman6> Anyone know if this exists somewhere already? it seems like it would ve very useful in the foldl package https://gist.github.com/axman6-da/19247b127a674ea53fb8667e5a5b150e
23:07:17 <olligobber> I believe monads that compose are related to monad transformers
23:50:28 <dminuoso> olligobber: Yes and no. Monad transformers are a way of imbuing effects of one monad with another, but that's not always the composition of those monads.
23:50:41 <dminuoso> They do address the problem domain of "composing monad effects"
23:55:26 <linarcx> Hi. I wana know that how can i immutable things in haskell. Just with monad?
23:56:13 <Rembane> linarcx: What?
23:56:23 <linarcx> /NAMES list
23:57:15 <Cale> linarcx: Did you mean to ask how you can mutate things in Haskell?
23:57:53 <Cale> ... okay
