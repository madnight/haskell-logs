00:11:27 <ph88> thanks sm 
01:01:51 <ph88> hey guys, my program runs fine with profiling. But when i do a normal build it hogs all the memory and is killed. How can i debug this ??
01:28:14 <Cale> ph88: It runs to completion with profiling, or it just doesn't die?
01:28:45 <ph88> it runs to completion with profiling and it's fast
01:28:50 <Cale> hmm
01:28:59 <ph88> with normal build it runs out of memory quickly then gets killed by linux kernel
01:30:01 <dminuoso> Mmm, is there a way to `nub` a Traversal?
01:31:06 <Cale> Not lawfully
01:31:26 <Cale> All traversals don't change the number of elements they're working with
01:32:03 <Cale> t pure = pure
01:32:46 <Uniaika> Cale: for one weird obscure reason each time I see your nickname on the screen I expect myself to be on #irssi but clearly we're not talking about perl scripting here… :P
01:34:11 <dminuoso> Cale: I suppose I could use partsOf to turn it into a lens and bolt a nub Getter ontop of it..
01:34:29 <dminuoso> mmm
01:35:45 <ph88> Cale, what would you do in my situation ? any tools i can use perhaps ?
01:36:11 <Cale> ph88: Maybe try compiling with fewer optimisations and see if performance improves
01:36:39 <Cale> ph88: It might be that some optimisation is behaving very poorly on your code, which would be a GHC bug
01:36:49 <dminuoso> Cale: Or is there lens combinators that allow this unlawful behavior and keep a traversal?
01:36:50 <ph88> good idea, thanks
01:37:05 <dminuoso> Not quite sure whether Im confused.
01:39:06 <Cale> dminuoso: This is the point at which I would usually say "are you really sure you wanted to use lens-y stuff at all?"
01:40:09 <Cale> It might be clearer to express what you're trying to express without the wacky inversion of control, if you're willing to admit stuff that alters the surrounding structure / loses information in that way.
02:23:31 <freeman42x[m]> stuff like this is so annoying: https://twitter.com/ArtirKel/status/1276434671270797312
02:23:54 <freeman42x[m]> do other people in this Haskell cult think that Haskell is harder to write, less flexible than python and not useful for neural nets?
02:29:07 * hackage periodic-polynomials 0.2.0.0 - A library for working with periodic polynomials (very basic functionality)  https://hackage.haskell.org/package/periodic-polynomials-0.2.0.0 (OleksandrZhabenko)
02:30:47 <kuribas> freeman42x[m]: I went to a haskell talk where they claimed the opposite.
02:31:26 <freeman42x[m]> kuribas: I bet they claim the opposite of what they claimed at that Haskell talk during Python talks :p
02:32:15 <kuribas> that tensorflow was hard to use in Python, because it's so easy to pass the wrong dimensions
02:32:35 <kuribas> and they made a dependently typed wrapper that would catch those errors.
02:33:20 <kuribas> freeman42x[m]: BTW, haskell is harder to write, and less flexible is true in the general case
02:33:27 <boxscape> I did find that really annoying when using tensorflow, though "Tensorflow already enforces tensor coherence" seems to suggest that they have a feature to make sure dimensions match? Or does he mean... at runtime? (or does coherence mean something else?)
02:33:47 <kuribas> but they forget to tell that it is because in a dynamic language you can write anything, without any consistency check.
02:34:13 <kuribas> So it's easier to write, yes, also more flexible, but you don't get any garantee that it works, or even does something useful.
02:34:19 <freeman42x[m]> kuribas: how is Haskell less flexible? in the sense that Python is more flexible into allowing you to write incorrect software? I do not want that flexibility for the use cases I am discussing
02:34:42 <kuribas> freeman42x[m]: yes indeed.  It's also the kind of flexibility I don't care about
02:34:54 <freeman42x[m]> kuribas: and how is Haskell harder to write? have you learned Haskell first and another language after? how else can you tell?
02:35:24 <freeman42x[m]> do you think it is harder to write correct Python on a typical sized app or Haskell?
02:35:25 <kuribas> it's harder to write because types must match
02:35:49 <kuribas> but I find that once they match, it usually is also correct.
02:36:05 <kuribas> and the opposite holds in python/clojure...
02:36:07 <Cale> Types have to match in python and in Haskell, but with one of the languages, the compiler helps you make them match
02:36:33 <freeman42x[m]> I would not call the capability to write broken software faster flexibility, I call that inflexibility. and python is very inflexible in comparison to Haskell
02:36:56 <kuribas> freeman42x[m]: I think it is harder to create correct programs in a dynamic language, yes.
02:37:44 <kuribas> freeman42x[m]: I also think people who use these language care about fast delivery more than correctness.
02:37:44 <boxscape> Cale implicit casting does make it sometimes easier and it sometimes does what you want (though I'd rather not have it)
02:37:56 <freeman42x[m]> kuribas: how can it be harder to write a correct app in Haskell than in Python? if you write a broken app in Python that is not faster, it is not functionally equivalent
02:38:04 <Cale> boxscape: Yeah, that's true
02:38:09 <freeman42x[m]> and the broken parts will take a lot of time to fix, which compiler could have caught
02:38:40 <freeman42x[m]> `I also think people who use these language care about fast delivery more than correctness.` I agree
02:38:52 <freeman42x[m]> but my discussion with him was about humanity creating human-level AI, that is not something we can screw up
02:39:01 <freeman42x[m]> creating HLAI is safety critical
02:39:08 <kuribas> freeman42x[m]: I didn't say it's harder?
02:39:50 <Cale> We create human-level real intelligences all the time, usually by screwing up
02:39:55 <kuribas> freeman42x[m]: but I think AI, neural networks, etc... are orthogonal to PL design.
02:39:55 <freeman42x[m]> kuribas: "it's harder to write because types must match" - kuribas
02:40:17 <freeman42x[m]> Cale: this is about human-level AI and not babies
02:40:35 <kuribas> freeman42x[m]: I didn't say specifically for "correct programs"
02:41:01 <freeman42x[m]> true, but why would you care about incorrect programs for HLAI case?
02:41:04 <boxscape> freeman42x[m] out of curiosity, are you aware that edward kmett works for MIRI?
02:41:36 <freeman42x[m]> boxscape: I am, I contacted him about a year ago and we are speaking every now and then. But he is very busy unfortunately
02:41:44 <boxscape> ah, nice
02:41:52 <kuribas> freeman42x[m]: dynamic programmers see it as a non-problem, because they fix problems as they arrive.
02:41:58 <kuribas> freeman42x[m]: instead of trying to prevent them
02:42:24 <freeman42x[m]> kuribas: that is a terrible idea to do if working on HLAI though
02:42:45 <freeman42x[m]> you can't just run HLAI code and hope it will not destroy us cause of a silly bug that could have been prevented at compile time or other pre-runtime checks
02:42:59 <kuribas> freeman42x[m]: you are conflating things.   AI research and types are orthogonal
02:43:27 <freeman42x[m]> kuribas: you are using very vague words to tell me I am wrong, could you be more clear so I can learn something?
02:44:07 <Cale> I just mean, it might not be the biggest problem to screw that up in some way. There are definitely some ways in which it could become a problem. If there's a type error in the code which trains an HLAI and it manages to achieve human level intelligence regardless, well, maybe the type error didn't really matter?
02:44:19 <kuribas> freeman42x[m]: I am not saying you are wrong, I am just saying the correctness through typing, and AI research are not really related.
02:44:58 <kuribas> unless you have software running life-critical systems, then correctness matters.
02:45:15 <freeman42x[m]> Cale: morality will need to somehow be guaranteed when designing HLAI. Having static checks and maybe even mathematical proof of said morality would be way better than running code and praying
02:45:54 <freeman42x[m]> kuribas: what do you mean they are not related? AI research uses programming languages which range from terrible to great programming languages for that use-case
02:46:21 <Cale> But morality isn't guaranteed for humans
02:46:33 <Cale> and we make those all the time
02:46:38 <freeman42x[m]> kuribas: human-level AI is the most safety critical system you could conceive imo
02:47:02 <freeman42x[m]> Cale: morality not being guaranteed for humans is ok, it is not ok for the first designed HLAI
02:47:11 <kuribas> human-level AI is also something imaginary that doesn't yet exist.
02:47:15 <Cale> Why?
02:47:17 <kuribas> And may never exist.
02:47:18 <freeman42x[m]> the varying levels of morality you see in society are actually justified
02:47:35 <Cale> Justified in terms of what?
02:48:15 <freeman42x[m]> justified in the sense that things are this way because of the computations that run over time, stuff like evolution - life
02:49:22 <freeman42x[m]> kuribas: thinking that AGi will never exist is very niche and it makes little logical sense. There is nothing special about us humans, and creating life on non-biological substrates will happen sooner or later
02:50:58 <kuribas> AGi?
02:51:20 <boxscape> might be worth pointing out that at least one insitute (i.e. the one Ed Kmett works at) working on human-level+ AI safety is/was specifically looking for type theorists https://intelligence.org/2016/03/18/seeking-research-fellows-in-type-theory-and-machine-self-reference/
02:51:26 <kuribas> freeman42x[m]: backed by which evidence?  It sounds like total speculation to me.
02:51:27 <freeman42x[m]> kuribas: https://github.com/fairy-tale-agi-solutions/awesome-artificial-general-intelligence#awesome-artificial-general-intelligence
02:51:38 <freeman42x[m]> AGI = artificial general intelligence = human-level AI = HLAI
02:52:09 <freeman42x[m]> kuribas: "backed by which evidence? It sounds like total speculation to me." it is good that you question things, but you should do your research before questioning
02:52:59 <freeman42x[m]> kuribas: I recommend the Life 3.0 book, you can just jump to the specific chapter that treats your question
02:53:09 <lortabac> freeman42x[m]: is there evidence that "creating life on non-biological substrates will happen sooner or later"?
02:53:27 <lortabac> how can there be evidence for something that hasn't happened yet?
02:53:27 <freeman42x[m]> all you need is critical thinking skills and that will convince you why we are not special and it is just a matter of when not whether it is possible
02:54:09 <freeman42x[m]> `how can there be evidence for something that hasn't happened yet?` good question. the evidence is based on our models of reality, they predict the future, that is how science works
02:54:33 <freeman42x[m]> the same way we can predict global warming even though we have not witnessed it yet
02:54:34 <lortabac> I think we don't have the same definition of "evidence"
02:55:04 <freeman42x[m]> lortabac: check the dictionary to see the definition of evidence, that is what I am using
02:55:04 <boxscape> lortabac freeman42x[m] is likely talking about Bayesian evidenec
02:55:26 <kuribas> freeman42x[m]: one thing we can predict is that we destroying life on this planet.
02:55:31 <freeman42x[m]> lortabac: no, I am talking about evidence based on models of reality
02:55:36 <kuribas> rather than creating it.
02:56:04 <freeman42x[m]> there are lots of things we can predict, that is the power that science gives us
02:56:27 <freeman42x[m]> and creation of AGI is one of the things we can predict to be very likely
02:56:34 <Cale> There are a lot of things we can't predict as well
02:57:03 <freeman42x[m]> of course, but the point was about prediction of AGI being a thing or not
02:57:06 <Cale> We can barely predict the weather in a week from now, I'm not sure I'd be willing to say we can predict AGI.
02:57:33 <freeman42x[m]> Cale: are you an AGI expert? no? please do research and then you will be able to say :)
02:57:42 <boxscape> And yet even though we can't predict the weather next week, we can predict that the average temperature will rise over the next century
02:57:45 <Cale> Predicting something which has never happened is always going to be pretty risky
02:58:16 <Cale> boxscape: Well, sure :)
02:58:26 <kuribas> freeman42x[m]: now, if you would find a way to encode the three laws of robotics into type, I'd be impressed :)
02:58:46 <Cale> I don't see any reason that AGI can't happen. Just that predicting when it will happen is problematic.
02:59:03 <lortabac> when and whether
02:59:30 <Cale> Yeah, there are a lot of other roads we could go down that lead to AGI not happening.
02:59:46 <kuribas> and if humans are an example for general intelligence, were in big problems.
02:59:59 <Cale> e.g. someone could put nukes on the blockchain
03:00:07 <freeman42x[m]> kuribas: why would I staticaly guarantee the 3 laws of robotics if they are broken anyway? we need a way better model of safety
03:00:35 <freeman42x[m]> Cale: "Just that predicting when it will happen is problematic." of course no one knows that, even though there are etsimations about it
03:00:35 <kuribas> freeman42x[m]: don't curse.  Mr asimov is turning in his grave
03:01:54 <boxscape> The point of inventing Asimov's laws was to make it possible to write stories that show how they can fail
03:04:26 <Cale> I love hadrian's predictions of how much longer it'll take to finish my GHC build
03:04:48 <Cale> It's like 5-6s remaining for most of the way
03:05:41 <boxscape> maybe GHC builds are like the weather :)
03:06:01 <Cale> Or like the invention of AGI
03:06:05 <freeman42x[m]> or maybe you can use GHC builds to predict the weather
03:06:15 <furnost> hi all! I'm trying to setup a new projet with stack but launching `stack init` gives me an exception while reading snapshot from lts-16.2 (looks like an error while talking to a server). How should I proceed ?
03:06:56 <freeman42x[m]> furnost: first, share with us a gist of the full error
03:08:43 <furnost> freeman42x[m]: well, it seems the problem resolved itself by eventually choosing another server to pull from... Thanks anyway :D
03:10:07 <Cale> freeman42x[m]: Pretty sure you can use GHC's CI system to predict the weather. Restart the build pipeline on your merge request each day in the evening. If the build fails, you'll have fair weather the next day.
03:11:56 <Cale> (The nondeterministic performance tests especially make it an interesting proposition.)
03:15:40 <Cale> If you attempt a rebase and there's trouble with the utils/haddock submodule, then there will be turmoil in the Middle East.
03:19:36 * hackage readability 0.0.1.0 - Extracts text of main article from HTML document  https://hackage.haskell.org/package/readability-0.0.1.0 (geyaeb)
03:41:54 <freeman42x[m]> can I bitch about how so many programmers that mainly program using dynamically typed languages have very loud mouths about how their language is the best thing ever yet have a close to 0 understanding of the benefits of static typing and higher level abstractions? it is like Dunnig-Kugger or something, the less they know, the more they act like they do
03:43:28 <freeman42x[m]> I mean, look at this haha: https://miro.medium.com/max/589/1*Kbvq1QwWAmPQM_GY3F3GEw.png <- this is not even wrong
03:44:22 <fendor> I will argue that it is in human nature
03:49:42 <freeman42x[m]> like, just read this article and try not to back away slowly: https://medium.com/@richardeng/why-dynamic-typing-is-not-a-genuine-issue-a3ba6943a0f6
03:55:21 <furnost> Another question concerning stack. I'm trying to build my app with docker to be able to deploy it quite
03:55:39 <furnost> easily, is it possible to name the new image that contains my executable ?
03:56:22 <merijn> Isn't that more of a docker question?
03:56:46 <merijn> Also, make sure you don't accidentally ship the entire stack + GHC toolchain + library store with your docker image..
03:57:29 <davve> 731
03:57:32 <davve> sorry
03:57:56 <furnost> merijn: if I use stack's internal "docker" mode (https://docs.haskellstack.org/en/stable/docker_integration/), will it pull everything inside or only what is needed for my app ?
03:58:45 <infinity0> suppose i want to build an extended ghci that auto-converted missing names into strings, what would be the best tool to do that with?
03:59:11 <infinity0> so for example something like `putStrLn whatever` gets converted into `putStrLn "whatever"` if whatever is not in scope as a binding
04:00:11 <merijn> furnost: I don't use stack, so I couldn't tell you :)
04:01:04 <merijn> infinity0: Eh, presumably the best tool would be to just fork+modify ghci?
04:05:38 <arahael2> merijn: "Accidentally"?  How does one "accidentally" do that? :)
04:05:55 <infinity0> merijn: oh, but that would involve compiling GHC :(
04:07:04 <tdammers> why would you ever want that? I think most people will agree that barewords (as in bash or early PHP) were a mistake
04:08:21 <merijn> arahael2: Lots of the docker workflows insist of basically running a bunch of commands and then adding everything new on the disk image
04:08:42 <arahael2> merijn: Yes. I thought it was obvious what that implies.
04:09:04 * arahael2 is a docker user.
04:09:09 <merijn> arahael2: Well, most people don't intend to ship a 2 GB compiler with their 10MB program :)
04:10:30 <Arahael> merijn: My point stands. :)
04:10:46 <Arahael> Docker is for when you're lazy, though, frankly
04:11:02 <Arahael> But even if you're not being lazy, it's pretty easy to make a smaller image.
04:11:49 <dminuoso> furnost: So here we use gitlab-ci, with a simple shell executor in which we build our haskell projects with plain cabal v2. We then just extract the compilation artifact via `cp $(cabal v2-exec which -- exec) ...` - done.
04:12:07 <dminuoso> Docker just doens't buy you much, really. cabal v2- does sandboxing just fine already.
04:12:10 <dminuoso> And it's much much faster.
04:12:27 <dminuoso> And you can use its global store to provide faster rebuilds
04:12:59 <Arahael> The other advantage of docker is that it works the same whether it's running pihole, written in who knows what, wordpress, in php, and whatever else you want.
04:13:33 <dminuoso> Arahael: docker promotes either using `latest` - but you lose all determinism - or its super annoying to handle updates.
04:14:13 <freeman42x[m]> I'd rather use Nix over Docker any day, but then again, you might find some corner case when Docker would make sense
04:16:08 <Arahael> Nix doesn't work so well in windows or macos, though.  Not saying that docker is perfect, but sometimes, it makes sense and it's convenient.
04:16:23 <Arahael> That said, Nix is far better.
04:16:37 <Cale> Nix works on Mac
04:16:37 * hackage shakebook 0.7.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.7.0.0 (locallycompact)
04:16:58 <dminuoso> The semantics of nix are great, its ergonomics suck sadly.
04:16:59 <nek0> hi folks, What widget toolkits are there and do you use for OpenGL applications?
04:17:04 <Arahael> Cale: Did they close that bug about getting it going on Catalina yet?
04:17:17 <dminuoso> Arahael: Well that was a Mac bug, rather.
04:17:22 <dminuoso> not a nix bug.
04:17:33 <dminuoso> Apple announced very shorty they wanted to address it
04:18:01 <Arahael> dminuoso: Normally I'd say that's debatable, but in this case, yeah.  Practically speaking though, it still meant that Nix on Catalina was a problem..
04:18:22 <Arahael> We almost have Big Sur now.
04:19:46 <dminuoso> https://github.com/NixOS/nix/issues/2925#issuecomment-634717820
04:19:48 <dminuoso> Seems fixed
04:22:24 <Uniaika> hurray
04:23:49 <bifunc2> For FFI, can int64_t in C always be said to be Int64 on Haskell?
04:25:23 <Arahael> int64_t would be exactly 64 bits, but I can't remember anything about padding or alignment.
04:26:08 <Arahael> So you'd need to convert it - and you might as well use an Int64 for the marshalled type. If that's what you're asking for?
04:29:04 <bifunc2> Arahael i'm just wondering if a C function that returns int64_t can be FFIed into a haskell func that returns Int64 without conversion.
04:29:23 <bifunc2> rather, returns "IO Int64"
04:29:57 <dminuoso> bifunc2: https://hackage.haskell.org/package/base-4.14.0.0/docs/Foreign-Ptr.html#t:FunPtr
04:39:40 <Cale> Arahael, dminuoso: Yeah I think it's quasi-fixed. I'm not sure we've actually got our build machines using Catalina yet.
04:41:10 <kuribas> hmm, haskell language server works well on vscode.  My setup is now: edit in emacs, check types in vscode :-P
04:41:20 <maerwald> lel
04:41:21 <Cale> haha
04:41:27 <Arahael> i seriously need to get onto that vscode stuff.
04:41:30 <Cale> Have you tried ghcid?
04:41:42 <Cale> If all you're using vscode for is to check types...
04:41:49 <maerwald> vscode is nice if you don't care about memory leaks
04:41:50 <Uniaika> ghcid is <3
04:42:30 <maerwald> Uniaika: I never understood the advantage over normal repl
04:42:53 <maerwald> I'm not saving my code every other minute
04:43:32 <Cale> Well, the advantage is that you just set up a window with ghcid and it tells you the status of your code. It's not a replacement for a repl
04:43:42 <maerwald> I also think that makes the mind lazy and you stop reasoning about types in your head
04:44:08 <Cale> I don't find that so much
04:44:29 <maerwald> I'm reloading repl every 15 minutes and for that I don't need a daemon
04:45:01 <Uniaika> maerwald: indeed if your development cycle makes it that you reload it every 15mn, it's no use for you
04:45:30 <Cale> It's great when you're doing something like modifying some type
04:45:34 <Uniaika> I use the neovim plugin for ghcid, so at soon as I save, a buffer in my editor appears to tell me what I got wrong and it disappears when I fix it
04:45:44 <rnxpyke> hey there, I'm trying to build a basic riscv simulator, and I use the ST monad transformer for storing ram. Now I was looking into using brick for implementing a tui, but you can't use a custom monad or ST with it, is there some possibility to *not* rewrite my existing code?
04:45:49 <Uniaika> (also, hlint integration 👍)
04:46:00 <Cale> and you'd normally get compiler errors, and fix them one by one
04:46:25 <Cale> It's nice to have an automatically-updated todo list on your screen
04:48:30 <petersen> Should/does ghc ship with .hie files?
04:48:32 <Cale> rnxpyke: Probably you want to generalise your code so that it will work in either IO or ST.
04:49:04 <Cale> at least, if you need to stick actual I/O into the middle of computations
04:49:44 <rnxpyke> im using a ReaderT (Ram s) (STT s m .. monad transformer stack
04:49:57 <rnxpyke> the problem is that I can't runST and pull out my STRefs
04:50:10 <rnxpyke> atleast with the ST transformer
04:51:59 <rnxpyke> and I'm not sure if I can do pull out IORefs by using stToIO either
04:54:30 <hc> rnxpyke: perhaps contact the brick author and ask them to support custom monads? Simply writing IO in your types is considered deprecated anyway afaict
04:54:39 <hc> It's supposed to by MonadIO m => m these days iirc
04:54:43 <Cale> huh?
04:54:58 <Cale> Nah, there's plenty of plain IO
04:56:47 <Cale> The point of MonadIO m is that it gives you a way to turn IO actions into m actions. Writing your stuff to produce m actions already will only save someone the effort of typing liftIO.
04:57:03 <Cale> The troublesome part comes when something is higher-order, i.e. it takes an IO action
04:57:29 <Cale> It usually won't suffice for it to take an arbitrary m-action (even if we assume m is an instance of MonadIO)
04:58:38 <dminuoso> hc: Also, `MonadIO m => m T` is not "the way to go". In general, writing overly polymorphic library code impedes inlining.
04:59:24 <dminuoso> Because polymorphic values are, under the hood, implemented as functions taking a dictionary, unless specialization can fire.
04:59:43 <Cale> Yeah, if you don't have -fexpose-all-unfoldings turned on everywhere, you're liable to have problems with that
05:00:27 <Cale> If GHC fails to specialise your monad, it's extremely painful performance-wise
05:01:41 <Cale> (because every (>>=) has to go via an indirection through a Monad type class dictionary that's been implicitly passed in as an argument, and it messes with inlining and other optimisations that would have happened after)
05:02:45 <rnxpyke> I just assume that some newtypes around mtl won't be that bad :)
05:02:55 <dminuoso> *transformers
05:02:58 <hc> okay, thanks for clearing that up :)
05:03:52 <dminuoso> rnxpyke: I have a question. What do you mean by "pull out of my STRefs"?
05:04:40 <rnxpyke> basically, all STRefs are inside the ST monad, like ST s (STRef s Int)
05:04:51 <rnxpyke> and I can't runST on that, obviously
05:06:08 <rnxpyke> brick uses it's own EventM type, which is some mix of ReaderT StateT IO
05:06:43 <dminuoso> rnxpyke: Why not just drag IORefs through instead?
05:06:52 <dminuoso> I mean if you already have IO, ST is not really necessary.
05:07:15 <rnxpyke> I guess I'll do that, but I don't think I can transform STRefs from the ST-trans package into IORefs
05:07:29 <rnxpyke> atleast there doesn't seem to be a safe interface for that
05:08:00 <dminuoso> unsafeSTRefToIORef
05:08:12 <Cale> What monad are you transforming with STT?
05:08:13 <dminuoso> Its not even documented, wonderful!
05:08:34 <dminuoso> rnxpyke: And if it doesnt exist for your version, just unsafeCoerce.
05:08:44 <dminuoso> rnxpyke: STRef and IORef have the same underlying representation... for now.
05:08:50 <rnxpyke> I'm just using STT so that I can create type aliases for the base monad as Identity and as IO respectively
05:09:13 <dminuoso> Disclaimer: This is probably a very unwise idea. :-)
05:09:43 <rnxpyke> it's probably wiser to just use default ST as my base monad and do stToIO on that
05:10:06 <dminuoso> That is, `IORef = STRef RealWorld` currently. :)
05:10:18 <Cale> Yeah, STT is very uncommon
05:11:54 <rnxpyke> I tried writing a runSTTinIO instance with something like MonadIO m => STT s m a -> m a
05:12:03 <rnxpyke> but I didn't get that to work
05:12:17 <rnxpyke> I tried writing a runSTTinIO instance with something like MonadIO m => STT RealWorld m a -> m a
05:12:24 <rnxpyke> thats the correct type signature
05:15:47 <dminuoso> Is there a way to disable GHC accepting underscored identifiers as typed holes?
05:16:03 <dminuoso> (Ideally, such that just `_` is admissable, but `_f` would lead to an undeclared identifier error)
05:16:07 * hackage ormolu 0.1.2.0 - A formatter for Haskell source code  https://hackage.haskell.org/package/ormolu-0.1.2.0 (mrkkrp)
05:17:07 * hackage yapb 0.1.0 - Yet Another Parser Builder (YAPB)  https://hackage.haskell.org/package/yapb-0.1.0 (lazyswamp)
05:22:51 <furnost> dminuoso: the reason I want to use docker is to be able to deploy the app quite easily. Is there another way of pushing to, let's say, heroku without using docker ? I'd still want to be able to compose my image with another (for example my DB). Do you guys have any resources concerning the more devops part of building applications in haskell 
05:25:01 <Arahael> furnost: just understand that when you use docker, you really are ultimately only deploying to linux systems - or to systems that run a linux vm.
05:26:43 <furnost> Arahael: sure, as usual ;)
05:27:15 <dminuoso> furnost: Deploying a GHC artifact is as simple as copying over the binary.
05:27:46 <dminuoso> furnost: Using docker to "simplify deployment" is a complete red herring and overengineering. It drastically complicates deployment.
05:29:12 <Arahael> dminuoso: hang on, are people using docker to redistribute *just* the haskell binary?
05:31:43 <maerwald> dminuoso: only with a fully static binary
05:32:15 <maerwald> which I also prefer, but there are more subtleties to it
05:33:08 <maerwald> some libraries, no matter how they are linked, require certain runtime files
05:33:24 <dminuoso> Cooking up an rpm or deb is usually rather trivial.
05:33:41 <furnost> dminuoso: how do you think one should deploy to Heroku then ?
05:33:44 <maerwald> that is not portable
05:33:45 <dminuoso> furnost: I wouldn't.
05:33:55 <dminuoso> maerwald: it's portable across any machine that eats it.
05:34:04 <maerwald> dminuoso: eat?
05:34:11 <furnost> dminuoso: nice one ;) How do you deploy your apps then ?
05:34:34 <maerwald> dminuoso: some .debs don't run on ubuntu
05:35:13 <maerwald> portability is not trivial
05:35:18 <dminuoso> furnost: Our CI pipeline is built to automatically produce rpms at the other side.
05:36:10 <dminuoso> Some are still lacking the integration, a simple shell script is used to pull releases from gitlab for those.
05:37:06 <furnost> dminuoso: Are you also in charge of the machines on the other side or is managed by a company like Heroku or Digital Ocean, etc ?
05:37:15 <dminuoso> We maintain our own datacenter.
05:39:18 <furnost> ok. Thanks. In our case, we'd like to not maintain our own machines, etc... Maybe later, if we can grow enough, but rn, we'd rather focus on something else. Do you have any recommendations or articles, resources that I could read to have a better idea on how to do this ?
05:40:59 <dminuoso> furnost: For a very very simplistic routine, this can be used to automatically track releases on gitlab. https://gist.github.com/dminuoso/94be5f3fb35e4bf92ab9e7fbf2b5bf68
05:42:29 <dminuoso> At the end, most users dont need the fully fledged highly dynamic/fast/magic solution.
05:43:02 <maerwald> wait for someone to sell you nix
05:43:28 <dminuoso> nix has the right semantics, but really annoying ergonomics. :(
05:43:56 <furnost> maerwald: I've heard about it and would love to try it, but the rest of the team isn't so willing... for now !
05:44:12 <furnost> dminuoso: thanks for the link, will give it a look !
05:44:18 <maerwald> I'd go so far to say it can be a dangerous decision for small companies
05:44:38 <lortabac> TBH even for big companies
05:44:56 <dminuoso> we were very very tempted to deploy nixos on our core network switches.
05:45:01 <maerwald> docker is more of a boring, but not a dangerous decison
05:45:10 <dminuoso> And we might do in the future. :)
05:45:33 <boxscape> freeman42x[m] just watched the video that's linked in the blog post you posted here, and while the talk has "Dynamic typing" in its title, interesting, it looks like all the advantages he mentions are actually advantages of structural typing and weak typing, not of dynamic typing, afaict
05:45:37 <dminuoso> But we'd require a specialized fork of nixops, really.
05:45:46 <boxscape> s/interesting/interestingly
05:46:13 <lortabac> boxscape: reminds me of Rich Hickey when he criticizes static typing
05:46:37 <lortabac> it's really more about nominal typing
05:46:43 <freeman42x[m]> boxscape: I watched that talk also a long time ago, and the arguments were nowhere close to hitting home
05:48:11 <freeman42x[m]> watching talks like that is to me as bad as watching a flat earther video, their reasoning is... isomorphic dear watson
05:48:31 <dminuoso> freeman42x[m]: I think a lot of "dynamic typing proponents" start with deeply flawed arguments that start with "My code works, I dont see the problem you're talking about"
05:48:44 <dminuoso> Which makes any discussion really hard..
05:48:49 <freeman42x[m]> exactly, ignorance is bliss
05:49:34 <freeman42x[m]> they know X works better than the U and T they worked with before, they never used Y or Z, yet they have very strong opinions that X is the best thing ever in general for any purpose
05:49:45 <boxscape> dminuoso the argument in the video started with (paraphrased) "from a couple studies I can't see a higher defect rate in dynamically typed languages", which I suppose is at least somewhat better than "my programs work"
05:49:54 <freeman42x[m]> typical example of getting stuck in a mental local minima
05:50:09 <dminuoso> Also, there's a lot of psychology in this. Im refactoring a project spanning 10k lines at the moment, having rewritten about 1/3 of it. This is day 4 and Im still fixing type errors - I can't even fathom how many weeks Id be sitting here if there was no tool to tell me where code doesn't fit.
05:50:35 <dminuoso> But I might get the impression "static type systems give me errors. dynamic type systems dont. clearly static type systems annoy me and cost time"
05:51:00 <boxscape> well, typically, dynamic languages will tell you where it doesn't fit, too - but only at runtime
05:51:06 <dminuoso> For 4 days Ive been getting *nothing* but type errors. :(
05:51:23 <dminuoso> Right, but you get the feeling of "success" when you see the application do things already.
05:51:27 <dminuoso> It must be more productive.
05:51:32 <boxscape> hm, that may be
05:51:59 <hc> boxscape: not all of them tell you of type errors. try ('b' + 'a' + + 'a' + 'a').toLowerCase() in JavaScript ;p
05:52:12 <dminuoso> hc: That's not really the point, actually.
05:52:32 <dminuoso> That's just highly bananas semantics of javascript, but its orthogonal to "dynamic typing"
05:52:48 <boxscape> still pretty weird though, huh
05:52:57 <freeman42x[m]> dminuoso: you are speaking the truth. They think that the type errors are what makes developing inflexible
05:53:00 <hc> dminuoso: well, it implicitly converts a string to a number, which results in NaN
05:53:20 <dminuoso> hc: Im aware.
05:53:26 <hc> :)
05:54:35 <boxscape> oh, I see, that's the unary operator +
05:55:37 <dminuoso> Anyhow, speaking of type systems, switching to optics is wonderful.
05:55:43 <dminuoso> I love the newtypes and expressive type errors. :)
05:56:13 <hc> dminuoso: I still don't get why this has nothing to do with dynamic typing not warning you, even at runtime, in this case
05:56:36 <freeman42x[m]> dminuoso: as someone who has not used optics much, I am not sure if serious or sarcasm haha
05:56:37 <hc> but perhaps it's not worth your time to enlighten me, I'll stop keep bugging you now :)
05:57:08 <dminuoso> hc: It's precisely because JavaScript opted to "not even warn you at runtime" but default to some "obscure behavior"
05:57:11 <dminuoso> It's the semantics of the language.
05:57:14 <maerwald> optics is generally safer even
05:57:34 <dminuoso> So it's not even part of the supposed "dynamic typing system"
05:58:00 <maerwald> > view (_Just . to (++ "abc")) Nothing
05:58:03 <freeman42x[m]> dminuoso: by obscure behavior are you talking about the "amazing type coercion system"?
05:58:03 <lambdabot>  ""
05:58:17 <maerwald> freeman42x[m]: the above does not compile with optics
05:58:27 <dminuoso> maerwald: This makes perfect sense.
05:58:37 <dminuoso> It's not unsafe because of it, perhaps a bit surprising.
05:58:50 <maerwald> dminuoso: hidde monoid is dangerous
05:58:58 <dminuoso> maerwald: It's not hidden.
05:59:03 <dminuoso> You just opted to not read the haddock of `view
05:59:03 <maerwald> and it caused real world bugs for us
05:59:07 <maerwald> lol
05:59:13 <dminuoso> `View the value pointed to by a Getter, Iso or Lens or the result of folding over all the results of a Fold or Traversal that points at a monoidal value.`
05:59:26 <dminuoso> Seriously. If you use something without referring to the documentation, don't be surprised if it doesnt do what you think it does.
05:59:55 <maerwald> thats naive
06:00:04 <dminuoso> Using primitives without knowing what they do is naive.
06:00:13 <boxscape> % view (_Just . to (++ "abc")) Nothing
06:00:13 <yahb> boxscape: ""
06:00:15 <dminuoso> The information was clearly displayed and documented.
06:00:22 <maerwald> because you might not be using view directlk
06:00:44 <maerwald> you're making lots of assumptions, but nvm
06:01:14 <boxscape> so the optics counterpart just doesn't fold over the result?
06:01:21 <maerwald> documeantation does not propagate up
06:01:24 <maerwald> types do
06:01:35 <dminuoso> maerwald: There must have been some reason you knew about `view`.
06:01:36 <dminuoso> What was it?
06:01:58 <dminuoso> It's reasonable to assume that a user of `lens` will read the documentation.
06:02:00 <maerwald> dminuoso: I can't share the code example
06:02:13 <dminuoso> boxscape: No it wont. Let me show you
06:02:19 <maerwald> dminuoso: then we don't need types right?
06:02:33 <maerwald> bc documentation is enough :)
06:03:07 <dminuoso> Why not have both?
06:03:22 <maerwald> moot point
06:03:46 <dminuoso> maerwald: You just made a strawmans argument. I never meant to imply we dont need types.
06:03:59 <dminuoso> I merely suggested, that reading the documentation of a library exported function should be mandatory.
06:04:15 <maerwald> nah, I explained that docs don't propagate up
06:05:05 <tdammers> I think that's a reasonable argument. Types propagate, documentation doesn't, unless you do it manually. Ideally, library functions don't bleed any documentable details of their own dependencies up, but in practice, they usually do
06:05:13 <dminuoso> boxscape:     • An_AffineFold cannot be used as A_Getter
06:05:23 <boxscape> I see
06:05:25 <dminuoso> boxscape: Is the error you'd get if you tried to view through an AffineFold.
06:05:54 <boxscape> is the reason A_Getter and so are type constructors rather than lifted data constructors so that users don't have to use -XDataKinds?
06:06:12 <boxscape> s/and so/and so on
06:06:18 <maerwald> and lenses are naturally something you compose heavily... and it makes reasoning already hard. Such monoidal behavior makes it worse
06:07:09 <dminuoso> boxscape: That seems like a reasonable explanation.
06:07:12 <boxscape> ok
06:07:12 <maerwald> and you don't lose anything without in this case
06:08:33 <dminuoso> boxscape: To get the equivalent behavior in optics, you'd have to explicitly use `foldOf (_Just % to (++"abs")) Nothing `
06:08:41 <boxscape> I see
06:09:44 <dminuoso> Optics has a similar subtyping, but its done with type families and coercions instead of implicit constraint products
06:10:50 <dminuoso> (So composing optics illegally would produce an error right at the definition point, whereas in lens you'd defer some constraint error to the usage site)
06:11:46 <boxscape> that almost kind of sounds like static vs dynamic type checking, except at a different abstraction layer, or something :)
06:12:27 <boxscape> "abstraction layer" probably not being the correct word
06:12:28 <maerwald> lens is all dynamic typing in category theory disguise
06:13:33 <maerwald> refactoring lens code is generally dangerous... it might compile but do the opposite of what you think it does
06:13:35 <dminuoso> Ultimately the main reason that swayed me over to optics, was being able to type annotate composed optics and not have headaches. :)
06:25:10 <boxscape> are optics categories, in the sense that (%) = (Category..)?
06:26:18 <ezzieyguywuf> if there's a `f :: a -> Either String b`, and I'm writing `g :: a -> Either MyError b`, is there some canonical way to leverage `f` inside `g` to accomplish this, or do I essentially just need to write a `case f val of...` statement to handle it?
06:26:31 <boxscape> or rather, are optics a category?
06:26:33 <ezzieyguywuf> regardless of the `Left String` value I have a single `Left MyError` I want to return
06:28:39 <dminuoso> ezzieyguywuf: The example you provided is not clear. How do you wish to use `f` inside `g` exactly?
06:29:07 <dminuoso> ezzieyguywuf: Do you wish to turn `String` into `MyError`?
06:29:33 <ezzieyguywuf> dminuoso: let me work up an example, just a sec.
06:31:10 <lortabac> ezzieyguywuf: it looks like you need Data.Bifunctor
06:33:07 * hackage hie-bios 0.5.1 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.5.1 (fendor)
06:33:13 <ezzieyguywuf> hm, I guess really what I want to do is parse a Data.Text into a Float, wether "10", "10.", "10.5", etc. I want to use the Data.Text.Read.decimal function to do this
06:33:26 <ezzieyguywuf> but maybe I'm back into parsec(ish) territory...
06:33:41 <dminuoso> ezzieyguywuf: you can use `readMaybe` as a crutch.
06:34:05 <dminuoso> If this is not performance critical.
06:34:45 <ezzieyguywuf> *shrug* I can worry about performance later
06:34:52 <ezzieyguywuf> is that the only thing you meant when you said "crutch"?
06:35:00 <dminuoso> Yeah.
06:35:56 * ezzieyguywuf nods
06:35:57 <ezzieyguywuf> thanks!
06:37:08 <dminuoso> ezzieyguywuf: Oh. `double :: Reader Double` exists.
06:37:11 <dminuoso> You can use that directly.
06:38:35 <ezzieyguywuf> dminuoso: nice find!
06:39:29 <ezzieyguywuf> or rational, for uber precision
06:53:15 <oats> st8less: great nick 
06:53:24 <oats> (especially for this channel :P)
06:59:00 <ezzieyguywuf> lol
07:09:37 * hackage c14n 0.1.0.1 - Bindings to the c14n implementation in libxml.  https://hackage.haskell.org/package/c14n-0.1.0.1 (mbg)
07:18:22 <jonathan_> So I need to do a permutation-agnostic list comparison in a test. Converting to/from set doesn't work, since the data does not support Ord, only Eq. Can't find a proper function. Any ideas?
07:18:35 <jonathan_> Rolling my own for something this generic seems off
07:20:16 <dminuoso> jonathan_: Whats the underlying reason you cant have Ord?
07:21:38 <jonathan_> The lists are json objects
07:21:45 <dminuoso> So?
07:22:02 <jonathan_> hm
07:22:16 <jonathan_> I'll try
07:22:44 <jonathan_> Just hought that since I couldn't come up with a reasonable ord instance for them it wouldn't work. But I can do an auto derive and see if that fits
07:22:46 <jonathan_> ty
07:23:22 <dminuoso> jonathan_: it depends, do all the portions of your data type have a natural ordering on Ord?
07:24:11 <jonathan_> maybe
07:24:18 <jonathan_> I'll get back when I know
07:31:16 <ezzieyguywuf> I originally wanted to implement this line as `<|> throwError PointParseError`, but this is a typeerror. But I don't understand why - I thought <|> was essentially "either this m a or that m b". https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/CommandParser.hs#L98
07:32:54 <dminuoso> ezzieyguywuf: <|> is a non-deterministic choice, usually.
07:33:44 <dminuoso> Ah hold on
07:33:55 <ezzieyguywuf> <|> from Control.Applicative
07:33:55 <dminuoso> The mention of Parser everywhere sidetrackedme
07:34:00 <ezzieyguywuf> yea sorry
07:34:24 <dminuoso> % :t (<|>)
07:34:24 <yahb> dminuoso: Alternative f => f a -> f a -> f a
07:34:55 <dminuoso> ezzieyguywuf: This reads `forall choices of f, such that there exists an instance Alternative f`, ...
07:35:13 <dminuoso> ezzieyguywuf: What's the concrete type error?
07:36:28 <ezzieyguywuf> dminuoso: No instance for (Monoid ParseError) arising from a use of ‘<|>’
07:36:33 <dminuoso> So!
07:36:39 * ezzieyguywuf waits with baited breath
07:36:41 <dminuoso> ezzieyguywuf: Consider what the type checker has to do.
07:37:00 <dminuoso> Set `f ~ Except ParseError`, and look for a matching instance.
07:37:13 <dminuoso> Which matching instance do you think it selects?
07:37:31 <dminuoso> That is, which Alternative instance
07:38:03 <jonathan_> After some time spent realizing I'll need to do it without Ord (third party data type), I did a quick implementation
07:38:13 <jonathan_> isSubsetOf l1 l2 = and $ (`elem` l2) <$> l1
07:38:40 <ezzieyguywuf> what is `~`
07:38:50 <dminuoso> ezzieyguywuf: It's equality on types. :)
07:39:04 <ezzieyguywuf> hah, you know, I think I should probably understand `Alternative` before trying to use <|> ^_^
07:39:16 <dminuoso> ezzieyguywuf: So while in the type level you'd say `f = T`, in the type level you'd (usually informally) write `f ~ T`
07:39:28 <ezzieyguywuf> you said "type level" twice
07:39:47 <dminuoso> oh
07:39:52 <dminuoso> *while in the valu elevel you'd say `f = T
07:39:56 <ezzieyguywuf> gotcha
07:40:37 * ezzieyguywuf shakes head, "Nope, I mostly understand what your asking, but I get lost when you get to 'which Alternative instance'"
07:40:40 <dminuoso> Alright
07:40:49 <ezzieyguywuf> I think I'll come back to this question after I'm more familiar with the Alternative monad
07:40:54 <ezzieyguywuf> but thank you for trying!
07:40:55 <ezzieyguywuf> :)
07:40:56 <dminuoso> Nah, this is very basic typeclass stuff
07:40:59 <ezzieyguywuf> ok cool
07:41:01 <ezzieyguywuf> I'm down
07:41:02 <dminuoso> % :t (<|>)
07:41:02 <yahb> dminuoso: Alternative f => f a -> f a -> f a
07:41:02 <ezzieyguywuf> to learn
07:41:14 <ezzieyguywuf> ok
07:41:18 <dminuoso> ezzieyguywuf: This is just a typeclas polymorphic thing, like Eq.
07:41:18 <ezzieyguywuf> so f is an Alternative
07:41:25 <dminuoso> well rather
07:41:32 <dminuoso> more to the point "f is *required* to have an Alternative instance"
07:41:38 <ezzieyguywuf> ok
07:41:40 <dminuoso> Whatever the choice of f is.
07:41:48 <dminuoso> By inference, what is `f` in your case?
07:42:02 <ezzieyguywuf> I _thought_ it was ExceptT
07:42:09 <dminuoso> Not quite!
07:42:27 <dminuoso> It'd be `Except ParseError`
07:42:43 <dminuoso> (Or `ExceptT Identity ParseError` if we expand the Except type synonym)
07:43:15 <dminuoso> So, the typechecker now has to run and find an instance declaration, whose head matches `Except ParseError`
07:43:20 <dminuoso> It will look and find this:
07:43:24 <dminuoso> instance (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m) where
07:43:26 <dminuoso> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Except.html#line-202
07:43:40 <dminuoso> So, the head matches, the instance was selected based on this fact alone.
07:44:01 <dminuoso> However, that instance has an additional constraint, it requires m to be Functor and Monad (the Functor instance is redundant) and `e` to be Monoid.
07:44:15 <dminuoso> Oh
07:44:19 <dminuoso> I should correct mysef
07:44:20 <dminuoso> 16:42:21        dminuoso | (Or `ExceptT Identity ParseError` if we expand the Except type synonym)
07:44:22 <dminuoso> That was wrong
07:44:28 <dminuoso> Just `ExceptT ParseError` :)
07:44:32 <dminuoso> That being said
07:44:56 <ezzieyguywuf> not `ExceptT ParseError Identity`?
07:45:06 <ezzieyguywuf> (I assumed you just had it flipped on accident)
07:45:51 <dminuoso> Yeah.
07:46:16 <dminuoso> So let's start anew with the right types :)
07:46:22 <ezzieyguywuf> lol ok
07:46:31 <ezzieyguywuf> oh wait!
07:46:32 <ezzieyguywuf> I see it
07:46:45 <dminuoso> You're writing `let f :: ParseError Command; f = ... in f <|> g`
07:46:49 <ezzieyguywuf> `Monoid e` is expecting my `ParseError` to be a `Monoid`
07:46:56 <dminuoso> requiring it to be
07:46:57 <ezzieyguywuf> but _why_ does it have to be a monoid?
07:47:05 <dminuoso> That's a great question! :)
07:47:16 <dminuoso> Lets look at the Alternative instance and see what it does
07:48:20 <dminuoso> ezzieyguywuf: Imagine you run the left hand side first, and you get an error - and then the right hand side - and you get another error.
07:48:22 <dminuoso> What should it do?
07:48:25 <dminuoso> Which error should it present?
07:48:44 <ezzieyguywuf> hrm, I guess that's why we need mempty?
07:49:09 <dminuoso> Alternative's empty needs to behave as an identity wrt to <|>
07:49:17 <ezzieyguywuf> and really, I had _almost_ gotten there on my own, but then my brain was like 😵
07:49:40 <ezzieyguywuf> hm, but then the question becomes: is ParseError truly a Monoid, or isn't it...
07:49:47 <dminuoso> That's your choice.
07:50:03 <ezzieyguywuf> yea
07:50:05 <dminuoso> ezzieyguywuf: You need to decide how two errors must be combined.
07:50:13 <ezzieyguywuf> I guess I could add an "UnknownParseError" value
07:50:21 <ezzieyguywuf> yea, then I can get on board with Monoid for it
07:50:41 <dminuoso> ezzieyguywuf: really though, megaparsec. :
07:50:44 <ezzieyguywuf> I think I'm at 80% comprehension! this was very helpful!
07:50:48 <ezzieyguywuf> dminuoso: yea....
07:50:56 * ezzieyguywuf hems, thinks about hawing
07:51:17 <ezzieyguywuf> I'm on the fence. This approach seems to be working out pretty well, plus it's forcing me to understand how things work
07:51:33 <ezzieyguywuf> megaparsec looks like it ends up being this really big monad transformer stack, and I can see that being ultimately very helpful
07:51:43 <ezzieyguywuf> but I want to get comfortable working with things at this level first
07:51:54 <ezzieyguywuf> I _just_ started understanding how Except and ExceptT work
07:52:22 <srk> https://github.com/sorki/polytype
07:52:26 <srk> merijn: slack1256: ^
07:52:46 <dminuoso> ezzieyguywuf: megaparsec is an abstract interface, you dont need to worry about its internals.
07:52:52 <srk> merijn: thanks for posix-pty! 
07:53:25 <slack1256> Damn
07:54:12 <ezzieyguywuf> dminuoso: that's true, but for using it's error-handling and stuff I need to understand how a monad transformer works (I think)
07:54:15 <ezzieyguywuf> or maybe not
07:54:20 <ezzieyguywuf> *shrug* I may go back to megaparsec
07:54:35 <ezzieyguywuf> right now this approach makes sense to me, and I think it's readable and maintainable.
07:54:36 <dminuoso> ezzieyguywuf: Honestly, error reporting in parsers is a really complicated and hard topic.
07:54:58 <dminuoso> Getting a parser that is fast, expressive, maintainable and has good error diagnostics... that's a tough one
07:55:01 <ezzieyguywuf> dminuoso: except with my current implementation, it works as I want it to
07:55:15 <ezzieyguywuf> and I can add a `catchError` at somepoint that takes a ParseError and returns a helpful descriptive text
07:55:26 <dminuoso> well if its just that, yo ucan do that too.
07:55:47 <ezzieyguywuf> dang, my ParseError needs to be a SemiGroup too?
07:56:02 <dminuoso> ezzieyguywuf: Semigroup was turned into a superclass for Monoid.
07:56:14 <dminuoso> ezzieyguywuf: Essentially you just define the mappend thing on Semigroup, and the mempty on Monoid. :)
07:56:20 <dminuoso> That's it
07:56:34 <ezzieyguywuf> but I can't understand how my ParseError _would_ be a semigroup
07:56:40 <ezzieyguywuf> what does mapped mean for an error?
07:57:14 <ezzieyguywuf> i.e. is an Enum a Semigroup?
07:57:34 <dminuoso> ezzieyguywuf: Like I said, that's for you to decide.
07:57:45 <dminuoso> ezzieyguywuf: The thing is, the Alternative instance isn't ideal for parsing.
07:58:09 <dminuoso> ezzieyguywuf: By the way: https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/CommandParser.hs#L94-96
07:58:21 <dminuoso> ezzieyguywuf: This is just StateT in disguise. So you're starting to be stateful about consumed input.
07:58:34 <dminuoso> But its an honor system.
07:58:38 <ezzieyguywuf> really? "This interface was introduced for parsers by Niklas Röjemo, because it admits more sharing than the monadic interface"
07:59:11 <ezzieyguywuf> dminuoso: yea, I thought about making that a State, but figured I'd wait till I was using it in more places
07:59:15 <dminuoso> Sure. There's more Applicatives than Monads.
07:59:21 <dminuoso> That is, there are some things that are Applicative but not Monad
07:59:37 <dminuoso> A random example, optparse-applicative is a full applicative parser, but without monad power.
07:59:44 <ezzieyguywuf> but you said "Alternative isn't ideal for parsing", but the doc said "this was made for parsing"
08:00:12 <dminuoso> ezzieyguywuf: The applicative interface is, but the particular alternative instance you are selecting is not.
08:00:19 <ezzieyguywuf> ah hah, I see
08:01:25 <ezzieyguywuf> lol, I'll just use `catchError` and move on....
08:01:33 <ezzieyguywuf> although this was definitely a worthwhile excercise
08:02:00 <dminuoso> ezzieyguywuf: I can promise you though, the more you advance with this, the more you'll want to use megaparsec. :)
08:02:29 <dminuoso> You get backtracking control, biased operators, performance, fine error reporting, lexing primitives..
08:03:41 <ezzieyguywuf> dminuoso: I fully expect that to be the case
08:03:50 <ezzieyguywuf> and i'm ready to take the time to transition to megaparsec when that happens
08:04:59 <ezzieyguywuf> I want to be sure I don't build bad habits, and as unfamiliar I am with FP and haskell, I find it helpful to do things the "long/hard/probably sort of dumb" way for now, in order to be sure I actually understand what is going on
08:06:09 <dminuoso> ezzieyguywuf: I personally found the route of http://dev.stephendiehl.com/fun/002_parsers.html helpful to get a footing into parser combinators.
08:06:29 <dminuoso> The implementation is poor plenty of reasons, and the interface is as weird as ReadP, but I think it sets you up with the right mindset.
08:07:35 <ezzieyguywuf> dminuoso: I'll have to give that a read! I went through this the other day and found it very helpful: https://two-wrongs.com/parser-combinators-parsing-for-haskell-beginners.html
08:07:40 <ezzieyguywuf> made megaparsec make a lot more sense
08:50:50 <subttle>  /3
08:52:16 <subttle> (sorry typo, meant to give command :D)
09:23:07 * hackage scheduler 1.4.2.3 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.4.2.3 (lehins)
09:47:32 <maralorn> Is there a library that can help me with a) running a process b) capturing its output into a buffer and c) output that buffer only when the process fails?
09:47:53 <maerwald> @hackage process
09:47:53 <lambdabot> https://hackage.haskell.org/package/process
09:48:02 <maerwald> but I usually just use unix
09:48:07 <maralorn> Would like to do that for running multiple processes concurrently.
09:48:34 <maralorn> And not have them garble the output.
09:49:03 <maerwald> maralorn: write(2) guarantees atomicity
09:49:36 <maralorn> maerwald: Well I would actually prefer to not even interleave the outputs.
09:50:31 <maerwald> interleave?
09:54:15 <maralorn> maerwald: I don‘t want the lines of the programs mixed. I want them to be cached and only printed when there is a problem.
09:54:59 <maerwald> I don't see the problem
09:55:10 <maerwald> just do that
09:56:08 <maerwald> Unless the buffers are huge build logs
09:57:03 <maralorn> maerwald: Yeah, that might potentially be an issue.
09:58:18 <maerwald> write the output to log files, use an mvar to lock stdout and cat those logs of failed processes
10:00:09 <maralorn> maerwald: Good idea.
10:02:41 <asheshambasta> Okay, either I'm really stupid or I cannot see how to ask cabal new-build to put the executable at a path I can specify; I tried `--bindir` but that makes no difference. 
10:03:37 * hackage yesod 1.6.0.2 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.6.0.2 (MaxGabriel)
10:03:44 <solonarv> asheshambasta: (new-)install can copy or symlink the executable somewhere
10:04:01 <solonarv> you can specify the directory with --installdir
10:04:57 <solonarv> and you can tell it to copy (and not symlink) with --install-method=copy
10:06:10 <asheshambasta> solonarv: thanks, ideally I'd like to name the executable based on some args. in a shell script. 
10:10:45 <solonarv> asheshambasta: ah, in that case you'd probably have to make cabal put it in some temporary location and have your script move & rename it
10:11:11 <wallsa> why does `runReader` take two arguments? What do these two arguments represent. To me it would make sense that it would take a `reader r a` and return and `r a`.
10:11:33 <wallsa> I am unsure of what the second argument is.
10:12:20 <solonarv> wallsa: 'Reader r a' computes an 'a' if you give it an environment of type 'r'
10:12:25 <phadej> :t ($)
10:12:27 <lambdabot> (a -> b) -> a -> b
10:12:32 <phadej> ^ two arguments
10:12:47 <solonarv> so to actually run that, you need to provide the environment again
10:13:11 <slack1256> > runReader (ask >>= pure . (+ 2)) 28
10:13:13 <lambdabot>  30
10:15:13 <dsal> > runReader ((2 +) <$> ask) 28 -- so complicated...
10:15:14 <lambdabot>  30
10:15:45 <wallsa> so the `r -> a` means it takes an r and returns an a. The nature of record syntax though is that it creates a function that takes its type and returns its value. So runReader takes a Reader and takes the first argument of the function within the Reader?
10:16:23 <dsal> There's a gap in my brain between "I know how to use that" and "I actually really understand how it works."
10:16:47 <wavemode__> wallsa: that's correct
10:17:11 <hexagoxel> > runReader (asks (+2)) 28 -- :p
10:17:14 <lambdabot>  30
10:17:36 <wallsa> ok thanks everyone
10:17:40 <solonarv> > runReader (reader (+2)) 28 -- :þ
10:17:42 <lambdabot>  30
10:17:49 <dsal> hexagoxel: Nice.  That's not how I use asks.
10:17:54 <wavemode__> > 28 + 2 -- :p
10:17:56 <lambdabot>  30
10:17:58 <dsal> > 30
10:18:00 <lambdabot>  30
10:18:09 <wavemode__> dsal beat all of us
10:18:18 <solonarv> > reader (+2) 28 -- maaagic
10:18:20 <lambdabot>  30
10:18:38 <dsal> That is a problem when people try to have minimal examples, though.  Sometimes I don't understand why they're trying to do something excessively complicated.
10:18:43 <dsal> What's `reader`?  Is it just `asks`?
10:19:39 <maerwald> throw reader away and just pass your environment as-is to the function that needs it... problem solved
10:19:45 <slack1256> @type reader
10:19:46 <lambdabot> MonadReader r m => (r -> a) -> m a
10:20:26 <slack1256> dsal: It is the inyection between (r -> a) and Reader r a
10:21:10 <wavemode__> asks is equivalent to reader, yes
10:21:20 <slack1256> Where (r -> a) is the "obvious" denotation/implementation of Reader r a.
10:39:06 <freeman42x[m]> Turtle has single for returning 1 line of text output from running a shell command: https://hackage.haskell.org/package/turtle-1.5.19/docs/Turtle-Prelude.html#v:single
10:39:11 <hyiltiz>  
10:39:22 <freeman42x[m]> what can I use for multiple lines being returned?
10:45:08 <slack1256> freeman42x[m]: You use `fold`
10:46:02 <slack1256> In general, to return a value of a `Shell a` you need to define a `Fold a b` to obtain a `b`. https://hackage.haskell.org/package/turtle-1.5.19/docs/Turtle-Shell.html#v:fold .
10:46:41 <slack1256> You can use Folds defined on the `foldl` package by Gabriel Gonzalez too.
10:47:30 <slack1256> For example on the docs shows `fold (ls "/usr") Fold.length` equal 8.
10:48:07 * hackage miso 1.7.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.7.0.0 (DavidJohnson)
10:49:07 * hackage miso-examples 1.7.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.7.0.0 (DavidJohnson)
10:53:29 <maralorn> maerwald: Thanks for the inspiration works very well.
10:57:39 <maralorn> I am just a bit fuzzy on why … I have "onException myCommandLoggingToFile catThatFile". And I put that into a "mapConcurrently". Now, when one process dies it correctly outputs the log of that file but not the logs of the other processes. That is fine by me. It's exactly what I want. I just thought that the "onException" should also be triggered by async exceptions …
10:58:30 <freeman42x[m]> slack1256: I need to define something just to be able to get multiple lines out of it?
11:00:01 <slack1256> freeman42x[m]: Yeah, but usually most of the stuff you want is already defined on the prelude of `foldl. Gabriel Gonzalez which is the author of both packages intended them to be used along.
11:00:19 <joels> Good evening all
11:01:52 <freeman42x[m]> slack1256: so if I add the foldl library I can just use a function from there to get multiple lines?
11:02:40 <slack1256> Yes
11:05:53 <slack1256> freeman42x[m]: https://pastebin.com/b76ueuna
11:05:55 <slack1256> Example of use
11:10:52 <maerwald> maralorn: "If any of the actions throw an exception, then all other actions are cancelled and the exception is re-thrown."
11:11:04 <maerwald> doc of mapConcurrently
11:11:54 <maralorn> maerwald: Yeah, I understand. But I thought the "cancelling" would mean throwing an async exception to those actions.
11:28:18 <freeman42x[m]> slack1256: I will just use `T.sortOn (const 42)` since it does the same thing without requiring an extra library
11:29:45 <freeman42x[m]> but I need to do: `T.sortOn (const 42:: a -> Int)` otherwise I get a warning that I need to specify type
11:32:48 <maerwald> maralorn: onException fires on async exception 
11:32:49 <merijn> wait
11:33:00 <merijn> What's the point of doing "T.sortOn (const 42)?
11:33:09 <merijn> I know a cheaper function to do that
11:33:10 <maerwald> I use it to react to Ctrl-c
11:33:14 <merijn> It's called "id"
11:34:07 <maralorn> maerwald: Hm, then I don‘t know, why it behaves the way I want …
11:36:23 <maerwald> make a minimal example
11:36:38 <maerwald> where you expect different behavior
11:37:20 <monochrom> merijn: T.sortOn is Turtle's sortOn, it has IO effects in addition to sorting. However! I would use () instead of 42. :)
11:39:04 <ezzieyguywuf> can someone help me understand why this is wrong? https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/Entity.hs#L106
11:39:07 <monochrom> The original question was: When using Turtle, how to run a shell command that produces multi-line output, and simply obtain those lines (I guess as a list of lines).
11:39:24 <ezzieyguywuf> here is the error: No instance for (Show (Topo.TopoState a)) arising from the third field of ‘Entity’ (type ‘Topo.TopoState a’)
11:39:52 <ezzieyguywuf> also, Possible fix:
11:39:53 <ezzieyguywuf>         use a standalone 'deriving instance' declaration,
11:39:53 <ezzieyguywuf>           so you can specify the instance context yourself
11:40:02 <maerwald> monochrom: but that makes even less sense... now they have a list of [42, ...]?
11:40:04 <ezzieyguywuf> (sorry for the spam)
11:40:19 <dmwit> ezzieyguywuf: Seems like a pretty clear error to me?
11:40:31 <dmwit> If you wanna show an Entity, you gotta show a TopoState.
11:40:36 <ezzieyguywuf> dmwit: it is a very clear error, but I still don't understand what is going on or how to fix it
11:40:46 <monochrom> ezzieyguywuf: For deriving Show to work, each field type should be a Show instance in the first place.
11:40:49 <ezzieyguywuf> TopoState is a `type`
11:40:54 <slack1256> freeman42x[m]: Where `foldl` is an extra library is debatable, it's a dependency of `turtle` already.
11:41:10 <slack1256> s/Where/Whether/
11:41:10 <dmwit> ezzieyguywuf: You may fix it by giving TopoState a Show instance (for example, by deriving it), or by writing a Show instance for Entity by hand that does not show the _getTopology field.
11:41:14 <ezzieyguywuf> https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/src/Topology.hs#L76
11:41:23 <ezzieyguywuf> TopoState is already Showable
11:41:28 <monochrom> Oh hrm
11:41:48 <dmwit> ezzieyguywuf: I challenge the claim that TopoState is already Show-able.
11:41:50 <monochrom> No, is it? What's St.State?
11:41:56 <dmwit> ezzieyguywuf: What evidence do you have for this claim?
11:42:02 <ezzieyguywuf> hm
11:42:10 <ezzieyguywuf> I thought I've show'd it before...
11:42:27 <ezzieyguywuf> St.State is Control.Monad.State
11:42:38 <dmwit> My evidence for the counterclaim is: there is no instance of Show listed here: http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#t:StateT
11:42:39 <monochrom> Topology is an instance of Show, yes. But St.State Topology a is another story because of the St.State
11:42:58 <ezzieyguywuf> dmwit: very good point.
11:43:43 <ezzieyguywuf> I guess the fundamental question is: do I need to be able to Show a State
11:44:03 <dmwit> Now, you *can* get a law-abiding Read/Show instance pair for State if your state space is finite. But I very much doubt that's what you want here.
11:44:11 <ezzieyguywuf> yea probably not
11:44:28 <monochrom> No, you shouldn't. Apart from "this is an opague function inside".
11:44:38 <dmwit> ezzieyguywuf: See my answer above: "You may fix it by giving TopoState a Show instance (for example, by deriving it), or by writing a Show instance for Entity by hand that does not show the _getTopology field."
11:45:19 <dmwit> (There are other options, too, but these are the most likely. And notice that the second answers your "must I show a State?" question in the negative.)
11:45:26 <ezzieyguywuf> dmwit: ah hah!
11:45:48 <ezzieyguywuf> I think I'll take out the deriving for now, but manually add the Show instance if I need it in the future
11:45:52 <ezzieyguywuf> thanks for the help team!
12:28:37 * hackage swish 0.10.0.4 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.10.0.4 (DouglasBurke)
12:37:36 * hackage haskell-postgis 0.2.0 - A haskell library for PostGIS geometry types.  https://hackage.haskell.org/package/haskell-postgis-0.2.0 (petefrance)
13:19:18 <maerwald> ah, I was hoping there is something like list section 
13:19:49 <maerwald> [1,2,3,,5] 4
13:20:11 <maerwald> maybe too fancy
13:20:26 <maerwald> only for the gentleman
13:22:36 <koz_> maerwald: Next - data constructor sections. :P
13:22:43 <maerwald> yay
13:23:02 <koz_> inb4 proposal.
13:24:24 <nshepperd2> (V4 1 _ 3 _) 2 4
13:28:23 <maerwald> with record syntax even
13:29:33 <koz_> {-# LANGUAGE ExtendedSections #-}
13:29:46 <koz_> (which automagically enables TupleSections, naturally)
13:30:13 <dmwit> Oh, are we doing this one again?
13:31:32 <dmwit> https://www.reddit.com/r/haskell/comments/4fqoke/thoughts_on_using_as_syntactic_sugar_for/
13:31:39 <koz_> dmwit: Again? I wasn't aware there was a first one, lol.
13:32:00 <koz_> Ah, syntax.
13:32:00 <dmwit> time travel. answering questions before they're asked
13:32:03 <koz_> Lol.
13:32:21 <koz_> Although honestly, more general sections are a thing I think would be good.
13:32:54 <dmwit> I recommend taking a read through my top-level comment there.
13:33:52 <koz_> Yeah, and I get why _-based syntax for this is a bad idea.
13:33:58 <dmwit> And this one, where I discuss what I think might actually have a chance of working well: https://www.reddit.com/r/haskell/comments/4fqoke/thoughts_on_using_as_syntactic_sugar_for/d2co9nx/?context=1
13:35:16 <maerwald> I really wonder if (.) vs ($) has any impact on inlining
13:38:49 <wavemode__> I think the only difference between them are in cases where optimizations are disabled, so there is no inlining to start with
13:46:33 <maerwald> hmm... I still don't like the ergonomics of parsing subsets of character sets... you can't really say "alpha-num, except for this list of chars"
13:46:49 <maerwald> at least not in the parsers I know
13:53:13 <tdammers> satisfy (\c -> isAlphaNum c && c `notElem` verboten)
13:53:16 <tdammers> vOv
13:57:04 <maerwald> a little inefficient... would be cooler to have a Set of character types and then do intersection etc
14:05:51 <tdammers> cooler, yes. more efficient, depends.
14:06:04 <MarcelineVQ> inefficiet eh?  lookAhead alphaNumChar *> noneOf "abc"
14:09:07 * hackage dobutokO-frequency 0.1.0.0 - Helps to create experimental music. Working with frequencies and types.  https://hackage.haskell.org/package/dobutokO-frequency-0.1.0.0 (OleksandrZhabenko)
14:24:37 * hackage zipper-extra 0.1.3.0 - Zipper utils that weren't in Control.Comonad.Store.Zipper  https://hackage.haskell.org/package/zipper-extra-0.1.3.0 (locallycompact)
14:53:40 <fog> is it possible to make a fast mutable or fast access vector buffer?
14:54:17 <fog> or is it difficult to discard, shift and add a new value in the buffer update?
14:54:43 <fog> like, can this be done in constant time, or do all the operations have cost?
14:55:23 <samiamsam> can be done for sure
14:55:39 <fog> but, done fast?
14:55:42 <samiamsam> ya
14:56:25 <monochrom> The "vector" package already exists.
14:56:38 <fog> hmm, sounds promising. do you know if it can be done with the interface for vectors we have in haskell?
14:56:47 <samiamsam> isn't the vector package boxed vectors?
14:57:13 <monochrom> In the future, immutable-looking code that uses linear typing to safely get compiled to mutable-array code will also be available.
14:57:26 <fog> monochrom: im not experienced enough at using it to understand how it works and if i can expect the performance assumptions i require to hold
14:57:49 <monochrom> the vector package has both boxed and unboxed vectors and one more
14:58:10 <samiamsam> oh.  shows what i know.  anyway there are other packages too that exist for performance reasons of one kind or another.
14:58:21 <monochrom> Then spend time to get experienced at it.
14:58:29 <fog> do you know if i can recombine subsections of a vector, like split as cojoin, and then i want to be able to have join also be constant time?
14:58:54 <fog> monochrom: or ask someone with experience!? 
15:00:53 <fog> you could suppose it be my responsibility to learn and understand the documentation well enough to answer my own question. but anticipating this, and not knowing if it would be successful to do so, like, i could waste time simply to find out that it cant do what i want. then i should ask 
15:01:31 <monochrom> If you refer to "someone else transfer experience to you" then you completely misunderstood the meaning of "experience." If you refer to "how does vector do it?" then it's a mutable array, what more needs to be said?
15:02:01 <fog> samiamsam for instance helpfully confirmed the notion that it should be possible to perform such an operation at all 
15:02:22 <fog> am i to infer from your "the vector package exists" that it contains a solution to the stated problem?
15:02:31 <monochrom> Yes.
15:02:58 <maerwald> you can transfer intuition... if you are lucky, but not the underlying experience
15:03:35 <fog> what more needs to be said, about, how it does it, other than just the fact that it is mutable, is that i could expect that if not done properly, it would for instance, needlessly shift the memory addresses doing the buffering
15:04:06 <monochrom> OK, it doesn't.
15:04:26 <fog> well, now you have transfered the knowledge. thank you
15:04:50 <monochrom> We all have mutual understanding that if I bother to say "mutable array" then no one is moving things around, no?
15:05:12 <monochrom> This is just ridiculous.
15:05:26 <fog> huh?
15:05:35 <monochrom> huh huh?
15:06:16 <fog> your first sentence isnt legible, and cant be therefor understood to lead to the assertion that something is ridiculous, since it isnt clear what that is 
15:06:35 <monochrom> I disagree.
15:06:55 <fog> what do you mean by "We all have mutual understanding that if I bother to say "mutable array" then no one is moving things around, no?" ?
15:07:13 <fog> thats what i mean by, "huh"
15:07:45 <maerwald> huh?
15:07:51 <samiamsam> everything is so black and white to monochrom.  can't even see the shades of gray from fog.
15:08:10 <maerwald> xD
15:08:19 <fog> contrarywise 
15:09:14 <fog> your implication is that mutability implies; "then no one is moving things around, no?"
15:09:18 <fog> which i cant parse
15:09:36 * hackage shakebook 0.7.1.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.7.1.0 (locallycompact)
15:09:37 <monochrom> No. The whole phrase "mutable array".
15:09:38 <fog> your assertion* 
15:10:48 <maerwald> meh, is there a cool way to build a product type from a map of strings, where the strings are the uppercase version of the record selectors?
15:11:12 <maerwald> I guess this is going into generics?
15:11:24 <fog> and by "no one is moving things around, no?" you mean are contradicting what you said before about -:the buffer shifting the values along by one and discarding the end one to make space for the new head value from the incoming value:- not incuring a performance penalty, 
15:11:42 <solonarv> if you want to generate a type declaration, it's template haskell
15:12:03 <maerwald> I have the type
15:12:14 <monochrom> build a value of the product type?
15:12:21 <maerwald> yes
15:12:37 <fog> are you suggesting that it should be implied simply from this name that the questioned functionality should be obviously supported!? i just cant understand what your on about
15:12:39 <fog> im out of here
15:14:14 <maerwald> Product { foo :: String } would be built from [("FOO", "BAR")]
15:14:22 <maerwald> and so on
15:15:03 <maerwald> it's repetitive for 10+ selectors
15:15:49 <fog> ok. if that was your question, which i cant be sure it was - then the answer would be "no! the words *mutable vector* do not imply constant time shiftability" .... or at least, not without some level of experience 
15:15:51 <monochrom> You can use one of generics, template haskell, it's up to you. This is basically what aeson and cassava do, they solve exactly this problem.
15:16:09 <maerwald> (in fact it's Maybe String in case the key does not exist)
15:17:17 <maerwald> the question is if it's worth learning generics for 3 days or just spend 15 minutes doing it manually
15:17:57 <monochrom> It will take 3 days if you haven't learned generics. It still takes an hour if you have learned generics.
15:18:01 <maerwald> I mean the concept of generics is straight forward... but god... the API
15:18:17 <solonarv> yeah, it's pretty clunky
15:19:06 <monochrom> For 15 minutes, a solution is bring in aeson, convert your map to an aeson Value (it's AST for JSON), then tell aeson to "parse" it into your record.
15:19:24 <maerwald> heh
15:19:40 <maerwald> cheater
15:21:01 <monochrom> You could steal aeson's code, the part that does this. Then it's probably just 30 minutes.
15:21:15 <fog> clearly "fast mutability" doesnt imply "fast shiftability" or i wouldnt have asked
15:21:29 <monochrom> to buy the benefit of not putting aeson in your build-depends
15:21:56 <maerwald> it already is, so
15:22:15 <fog> i want to build a "fast binary partitioning zipper" built on mutable vectors
15:23:07 <fog> it also requires fast concatenation, and fast shiftability, which from your statements, seems possible
15:24:13 <fog> then, i have lazy access, the "past" portion of the zipper being a *list* of increasing 2^n length mutable segments
15:25:01 <fog> i can add to this with the new streaming data, on the "forwards" operation of the zipper over the input stream
15:25:08 <monochrom> I am not a cheater. I am a reductionist.
15:27:11 <fog> the algorithm to do so consists of creating a new length 1 mutable vector for the incoming value, and then scanning (which is why it should be lazy over the past part of the zipper) to concatenate the segments into the next most possible coarse chunking
15:28:34 <fog> the resulting shape of these monotonically increasing 2^n length chunks, is conducive to an algorithm for hierarchical dictionary projections - for fast compression
15:29:12 * hackage aeson-with 0.1.1.0 - withXField combinators for aeson  https://hackage.haskell.org/package/aeson-with-0.1.1.0 (locallycompact)
15:29:38 <fog> as an alternative to gradient descent, that im working on, motivated by the advances in deep dictionaries, which with this development im working on, could lead to a faster training scheme than deep neural nets
15:31:37 <fog> since the gradients of backprop are similar to the gradient descent in sparse dictionary projections - and by avoiding them (the gradients) in a constructionist approach to building deep dictionaries, could facilitate faster learning, and faster compressed sensing 
15:33:06 * hackage xmobar 0.35 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.35 (JoseAntonioOrtegaRuiz)
15:33:19 <fog> the algorithm would avoid the krylov subspace linear algebra that is costly in an opperation over all dictionary elements. it would provide a faster alternative to conjugate gradient itterative hard thresholding, which is currently the state of the art for dictionary learning
15:34:22 <fog> sparse truncation of successively less error correcting dictionary elements is a lazy folding opperation, so haskell is well suited for the implementation
15:52:37 * hackage xmobar 0.35.1 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.35.1 (JoseAntonioOrtegaRuiz)
15:53:31 <Tuplanolla> What was that?
15:53:37 * hackage shakebook 0.7.2.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.7.2.0 (locallycompact)
16:43:40 <cole> i would like to write a function that uses type-level modulus but take the modulus as input. Is the right thing to use singletons and take as input an SNat that constarints the type of my function?
16:44:07 <cole> (the mod datatype is defined as data Mod (m :: Nat))
16:44:25 <cole> (*constrains)
16:51:43 <unsupervised> hi, how hard is it to build an autocomplete suggestion on a context free grammar using parser combinators?
16:52:13 <unsupervised> I have one using ANTLR and antlr4-c3 library but want to reduce dependencies
16:56:07 * hackage massiv 0.5.3.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.3.0 (lehins)
16:59:01 <L29Ah> is it better to import Void or to define my own?
16:59:11 <Uniaika> `data Void`
16:59:15 <Uniaika> there, have some
16:59:39 <Uniaika> more seriously, just import it, because I think predefined functions from Data.Void will rely on their definition, not yours
17:00:15 <arahael1> i think L29Ah's question is more about whether he should import npm's leftpad, or define his own.
17:00:28 <arahael1> ie, where is the tradeoff.
17:00:58 <Uniaika> well, as I said, I'm pretty sure Data.Void's functions would rely on their own definition of Void
17:01:06 <L29Ah> arahael1: yup
17:01:09 <Uniaika> … and that's pretty much all the tradeoff I can see
17:01:14 <L29Ah> Uniaika: those functions aren't that useful tbh
17:01:24 <Uniaika> L29Ah: tell me about it… *sigh*
17:01:26 <Uniaika> but they do exist
17:01:40 <L29Ah> i'm more concerned about whether there are APIs that deal with Voids that should be synchronized
17:01:42 <Uniaika> and should you interface with them one day, you'll need to rely on Data.Void's own definition
17:02:04 <Uniaika> uh, if you find such a thing one day ping me
17:02:07 <wavemode__> how could an API deal with voids?
17:02:14 <maerwald> Uniaika: coerce
17:02:25 <L29Ah> wavemode__: well there might be instances defined for Void
17:02:29 <Uniaika> maerwald: damn, I think I never used it directly
17:02:38 <L29Ah> being used as a parameter of some type, for instance
17:02:51 <L29Ah> dunno
17:03:07 <Uniaika> well you've pretty much answered your question on the matter I think
17:03:18 <Uniaika> I would be in favour of reusing Data.Void
17:03:22 <L29Ah> yeah the answer is "it's complicated"!
17:03:27 <Uniaika> that's of course my personal opinion
17:03:33 <Uniaika> considering tradeoffs and such
17:03:49 <Uniaika> and on those words, I'm heading off tae bed
17:03:55 <Uniaika> see you around, void travellers
17:04:19 * L29Ah hands Uniaika a Proxy Void
17:07:05 <wavemode__> I don't like dependencies. I jealously guard my dependency lists except when truly necessary. Void doesn't meet the bar for me
17:07:43 <xsperry> isn't Data.Void in base?
17:07:59 <L29Ah> no it's a separate package
17:08:37 <xsperry> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Void.html
17:08:38 <wavemode__> hmm it's also in base. then whatever
17:08:42 <arahael1> wavemode__: define it as (), then, and refactor later?
17:08:52 <L29Ah> cool
17:09:00 <L29Ah> then we have two incompatible Voids
17:09:04 <L29Ah> already
17:09:51 <L29Ah> only on the ABI level though
17:09:57 <wavemode__> well any two voids can be made compatible via unsafeCoerce :p
17:10:13 <wavemode__> or even safe coerce, I suppose
17:10:36 <L29Ah> what safe coerce?
17:10:56 <wavemode__> Data.Coerce in base
17:13:02 <L29Ah> cool
17:13:24 <dolio> You can't coerce between base's Void and void's Void with that coerce.
17:13:28 <dolio> But you should just use base's.
17:13:36 <L29Ah> too bad it won't save me from most of fromIntegral's :(
17:14:35 <wavemode__> dolio, well if it's being used as a phantom parameter (which is most of its usefulness, in any case)
17:16:39 <dolio> That doesn't seem right to me.
17:57:10 <ezzieyguywuf> I could use some advice: is this `loopAgain` implementation "monstrous", i.e hard to decipher, too much logic in one place, etc? https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/HaskellCAD/app/Main.hs#L49 I realize it's a subjective question but I'd appreciate some input
17:58:26 <ezzieyguywuf> This is the previous implementation, where `runCommand` returned an `ExceptT` rather than a `State`, but I couldn't quite figure out all the lifting etc. to make `runCommand` actually work properly, plus I realized that it didn't need the error handling: https://gitlab.com/ezzieyguywuf/mycad/-/blob/db9d12e8d179ac8ee6dd9d5d18155af5cc9b631c/HaskellCAD/app/Main.hs#L49
18:56:21 <hyiltiz> What's the difference between those voids? Can't "void's Void" just overload "base's Void"?
18:56:31 <hyiltiz> What's the difference between those voids? Can't "void's Void" just overload "base's Void"?
18:56:53 <hyiltiz> :( sorry for double post; finicky client
19:00:49 <EvanR> class Voidable a ; void :: a
19:00:53 <solonarv> hyiltiz: if you mean the package 'void', I'm pretty sure that jsut re-exports the Void from base nowadays
19:02:12 <hyiltiz> hmm i was just reading above saying they are not compatible; it is just a re-export then it sounds it is fully compatible, API or ABI-wise
19:02:59 <dolio> The docs I was looking at said it was `newtype Void = Void Void`. The docs for the absolute latest version don't exist though.
19:18:07 * hackage dbus 1.2.16 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.16 (blaze)
21:00:43 <pagnol> Are there patterns to make writing REST clients less tedious?
21:01:22 <pagnol> (I'm a beginning Haskell user)
21:05:43 <dsal> pagnol: Here's a chunk of my tesla client API:  http://hackage.haskell.org/package/tesla-0.2.0.0/docs/Tesla-Car-Command-Charging.html -- click on source
21:06:47 <dsal> Here's honking horns and flashing lights:  https://github.com/dustin/tesla/blob/master/src/Tesla/Car/Command/Alerts.hs  :)  Not very tedious.
21:06:54 <koz_> dsal: Featuring the Car monad!
21:07:21 <dsal> Monads, mo' problems
21:08:51 <dsal> My GoPro API client is a little more tedious, I guess, but GoPro doesn't have an API and it seems a bit less regular.
21:13:08 <pagnol> dsal: thanks
21:25:18 <ezzieyguywuf> dsal: nice.
21:36:42 <pagnol> so I will be defining my first monad... this is like a rite of passage among Haskell programmers, isn't it?
21:56:53 <arahael1> pagnol: Frankly, I'd do it by hand to start with, but use Wreq. One trap as a newbie, was that Wreq doesn't wrap HTTP Exceptions, so whatever exceptions Wreq documents, you also have to handle any that come from the underlying http implementation, and those are using IO Exceptions
22:40:07 * hackage servant-rawm 1.0.0.0 - Embed a raw 'Application' in a Servant API  https://hackage.haskell.org/package/servant-rawm-1.0.0.0 (cdepillabout)
22:41:08 * hackage servant-rawm-server 1.0.0.0, servant-rawm-docs 1.0.0.0, servant-rawm-client 1.0.0.0 (cdepillabout)
22:56:45 <fog> i have a type error; https://pastebin.com/raw/FNhQ6pvd
22:59:03 <fog> i have a constraint; x + Zero ~ x =>
22:59:13 <fog> which the typechecker seems to need
22:59:20 <fog> but i cant prove it...
22:59:24 <fog> or something...
23:00:30 <fog> is there anyway to get the type checker to think that this is satisfied by brute force - like just telling it that this holds
23:00:31 <fog> ?
23:02:56 <fog> dsal: coproblems? 
23:03:09 <dsal> ha
23:07:18 <fog> it says it cant create the infinite type; (xs :: [Nat]) ++ '[] ~ xs
23:08:30 <fog> it could be the wrong way to approach it, trying to tell the typechecker that this is true, but i cant think how else it might work
23:11:01 <fog> *Main> :kind! One + Zero
23:11:03 <fog> One + Zero :: [()] = '['()]
23:11:22 <fog> so that works...
23:11:43 <fog> its as if it cant apply the identity type family 
23:11:55 <fog> Id x ~ x
23:12:06 <fog> without complaining about this being an infinite type
23:12:24 <fog> which i guess it is, if you tried to expand it...
23:13:05 <fog> also, the other constraint the compiler demanded looked like an associativity law
23:13:15 <fog> (x + (y + Sum xs)) ~ (y + (x + Sum xs))
23:13:39 <fog> how am i supposed to provide these kinds of proofs to it?
23:14:05 <fog> well, not proofs, assertions
23:17:16 <fog> oh! it works, if i write the definition of Sum with arguments flipped
23:17:21 <fog> now it demands that;
23:17:21 <fog> (x ++ (Sum xs ++ y)) ~ ((Sum xs ++ x) ++ y)
23:17:24 <fog> which it can prove
23:17:38 <fog> + = ++ 
23:18:48 <sheepfleece> Hello, I want to implement a pool of predefined objects, from which I can request objects and to which I should return them (almost manual memory management, yes). However I'm not exactly sure how to represent this in haskell. In C++ I would have just created a class, but I'm writing FP now, so.. This problem generalizes to pretty much any "entity" with some state inside. I'm not exactly sure how to 
23:18:54 <sheepfleece> represent it as a set of functions. The best I could come up with is something similar to this https://paste.debian.net/1154055/
23:20:00 <sheepfleece> But it feels too OOP-esque for my liking, I'm not sure
23:25:32 <sheepfleece> This way I create something similar to an "object", which returns a "reference" (write only channel) to itself, and then listens on this channel for requests.  
23:25:55 <sheepfleece> I have quite a few "objects" like that, and I can't stop thinking that I'm doing it the wrong way.
23:36:09 <fog> here is a better presentation of the idea for hetrogenous folding;
23:36:10 <fog> https://pastebin.com/raw/4S5xApRv
23:36:13 <c_wraith> sheepfleece: doesn't seem automatically wrong to me. The only thing there that sets off any alarm bells is the type alias.  Things like that are usually counter-productive for long term reasonability
23:37:55 <c_wraith> (I like to see where functions are in types without having to think about potential aliases)
23:39:42 <sheepfleece> c_wraith: thank you! Why I started thinking this is a bad idea is because I now have two similar objects, to which I can register, and I suddenly understood that I would have done it in C++ via inheritance. 
23:40:49 <c_wraith> Ah.  That does suggest something might benefit from a redesign, but we'd need a lot more context than is in that paste to really make suggestions
23:41:07 <sheepfleece> And I separated them into three different modules, and it feels that I simply recreate classes via Haskell modules.
23:43:04 <sheepfleece> Well, I have two CPU bound threads, to which I can register. Their respective Message types are different, however logic for registration is identical.
23:43:47 <sheepfleece> So I split them into three modules, parametirized `Message` and pretty much made my own inheritance in Haskell.
23:45:53 <sheepfleece> I think I can represent it as just two functions instead of a concrete data type.
23:48:12 <sheepfleece> Still not sure how to make it work in concurrent setting though.
23:48:46 <hololeap> is there any way to take a type like `data Foo t a = Foo (T t) a` and have it derive the classes from (,) ?
23:50:08 <hololeap> i'd like to use `data` because it allows for record syntax which is more descriptive than wrapping a tuple in a newtype
23:50:47 <fog> should be possible using derive via, i think... never used that so cant be sure
23:53:26 <fog> "fold of constraints between types" - seems like i could have got to that sooner by just composing together haskell keywords..
23:54:26 <hololeap> oh, ok. how would i make Foo and (,) coercible?
23:55:40 <fog> hmm, normally when ghc complains about needing instances for coerce, thats a problem because you cant write those...
23:55:53 <fog> not sure how to do the derive via thing, maybe generics?
23:56:17 <fog> could see how it would be able to coerce things that had the same generic representation, but im just guessing
23:56:57 <hololeap> that's a good point. hadn't thought about generics yet
