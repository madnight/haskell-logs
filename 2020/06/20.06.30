00:32:28 <kuribas> can row polymorphism be implemented with constraints?
00:32:31 <kuribas> at least on type level?
00:33:21 <Axman6> do you mean like Vinyl?
00:33:35 <kuribas> I suppose
00:34:01 <kuribas> a language could have special syntax for it, but implement it internally as constraints.
00:36:24 <lortabac> do you mean like GHC.Records.HasField?
00:36:38 <kuribas> yeah
00:37:21 <kuribas> hasfield works on any record?
00:37:32 <lortabac> I guess the hard part would be record extension
00:37:45 <lortabac> yes it works on any record
00:39:15 <kuribas> internally it could be a vector of (recordHash, value)
00:39:46 <kuribas> extension would be O(n) though
00:53:12 <dminuoso> In general, when I want to partially apply a binary function for the purpose of say fmapping over a list, is there a performance penalty for using a section on the second argument?
00:53:41 <dminuoso> That is, is there a meaningful difference in the way GHC optimizes generally between (`f` e) and (g e) where g is written as a flipped version of f?
00:56:47 <lortabac> dminuoso: I don't know the answer, but I guess (`f` e) would be desugared to (\x -> f x e), which has different performance than (g e)
00:58:47 <veverak> hi folks, I am using ExceptT for error handling in computation
00:59:04 <veverak> is there a sane way to get "error path" rather than just the error?
00:59:12 <veverak> as what functions were called until that error or something
00:59:24 <veverak> (I suppose it requires something else than ExceptT)
00:59:37 <dminuoso> veverak: Well there is HasCallStack
01:00:18 <dminuoso> You can also write a thin layer ontop of StateT to automatically push contextual information
01:00:28 <dminuoso> Depends a bit on what you want this for.
01:01:09 <veverak> I have interpreter of functional language
01:01:24 <veverak> which works in ErrorT/State monads
01:01:35 <veverak> (State is scope)
01:01:57 <veverak> and I would like to have same call stack in the interpreter, as the "sole" error messages are not enough
01:02:54 <lortabac> oh this is a harder problem than just having call stacks for you to debug
01:05:46 <int-e> (State is scope) <-- so that's where you can keep track of the call stack too?
01:07:22 <int-e> :t local -- depending on how exactly you deal with recursion this may also be an option
01:07:24 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
01:07:29 <kuribas> dminuoso: I doubt it, after inlining it should all be the same
01:08:43 <veverak> int-e: I do not yet decided how the call stack will work
01:08:48 <veverak> :)
01:08:55 <veverak> but yeah, state is maybe a good place
01:09:16 <kuribas> hmm, smallcheck is weird:
01:09:31 <kuribas> data Test = Test1 Int | Test2 String | Test3 String deriving (Generic, Show)
01:09:41 <kuribas> list 2 series :: [Test] => [Test1 0,Test2 "",Test1 1,Test3 "",Test1 (-1)]
01:09:53 <kuribas> why is there three times Test1?
01:09:57 <kuribas> but only one time Test2?
01:10:19 <kuribas> or does it have to do with the arbitrary ordering of Generic?
01:10:55 <kuribas> I think I answered my own question...
01:11:31 <int-e> kuribas: does it alternate between the Test1 constructor with choices for the remaining constructors?
01:12:04 <kuribas> int-e: does what?
01:12:16 <kuribas> what's "it"?
01:12:29 * int-e is speculating, based on the fact that every second element is a Test1 value
01:13:31 <kuribas> depth 3: [Test1 0,Test2 "",Test1 1,Test3 "",Test1 (-1),Test2 "a",Test1 2,Test3 "a",Test1 (-2),Test2 "b",Test3 "b"]
01:16:45 <kuribas> Rep Test :: * -> * = D1 (C1 "Test1" (S1 (Rec0 Int)) :+: (C1 "Test2") (S1 (Rec0 String)) :+: C1 "Test3" (S1 (Rec0 String)))
01:17:22 <kuribas> looks indeed like it's because of the generic encoding
01:19:29 <veverak> hmmm
01:19:37 <veverak> with 'error' I can use HasCallStack
01:19:44 <veverak> which gives me some form of stack
01:19:58 <veverak> but not with ExceptT monad (and it's throwError)
01:20:11 <veverak> so, which means that ExceptT is useless for me and I should switch to 'error'
01:23:09 <lortabac> veverak: HasCallStack is the Haskell call stack, whereas if I understand correctly you want the call stack of your object language
01:23:17 <veverak> yes
01:23:35 <veverak> lortabac: but I am kind of looking how to get that reasonably easily
01:23:41 <veverak> haskells callstack could work
01:24:54 <veverak> hmm, wait a moment
01:25:02 <veverak> no, that fails as CallStack does not have variables in it
01:26:00 <[exa]> veverak: why'd you want a call stack?
01:26:46 <[exa]> uh I read the scrollback
01:28:44 <int-e> kuribas: ah. I think it does do that kind of interleaving (alternating between two series to merge them) but it also does some balancing, so that for four constructors A B C D, you get them in order A C B D A C B D etc.
01:30:01 <int-e> Or maybe GHC's DeriveGeneric does the balancing.
01:30:39 <kuribas> int-e: yeah, but that's a bug in smallcheck then.
01:30:41 <[exa]> veverak: btw you don't want to rely on haskell's call stack (as there's ideally none); instead I'd just setup some handlers like "enter/leave/tail" and "mark/rollback" for a simple list-style callstack in your State
01:30:54 <kuribas> int-e: because it should use the order of Test, not Rep Test
01:31:06 <int-e> kuribas: in what sense is it a bug?
01:31:44 <kuribas> int-e: in the sense that Rep Test is an implementation detail?
01:32:32 <kuribas> int-e: and that the balancing of Rep Test has nothing to do with Test whatsoever.
01:33:34 <veverak> [exa]: yeah
01:33:38 <int-e> kuribas: but isn't `series` just a fair enumeration of all cases up to a certain depth, with no specific order
01:33:40 <veverak> well, that requires more planning/thinking
01:34:07 <lortabac> [exa]: could you elaborate on what those handlers are? or point to resources?
01:34:52 <int-e> (yes, DeriveGeneric balances the choices)
01:34:53 <kuribas> int-e: yes?
01:35:45 <int-e> kuribas: So if everything works according to specification, where's the bug?
01:36:17 <kuribas> int-e: becuase it doesn't?
01:36:41 <kuribas> int-e: depth 3 != depth 1
01:36:48 <kuribas> so it doesn't follow the specification
01:42:03 <int-e> kuribas: Hmm, bnacktracking... you get Test1 three times because both 1 and -1 are produced at depth 1.
01:46:27 <kuribas> int-e: but it should only backtrace after the last constructor?
01:47:29 <int-e> kuribas: why?
01:48:11 <int-e> It could be prettier I suppose, but this seems entirely servicable.
01:51:11 <kuribas> so depth is binary?
01:51:44 <kuribas> int-e: I wanted to generate all constructors for depth one...
01:51:50 <kuribas> int-e: but it doesn't work if depth is binary
01:56:54 <int-e> kuribas: Oh I see. The real problem is that list 0 series :: [Int] has an element while list 0 series :: [String] does not
01:57:48 <kuribas> I cannot really find any law in it now
01:58:04 <kuribas> but of course depth 1 shouldn't give all integers
01:58:40 <dminuoso> veverak: Also note that the details depend on the semantics of your language. If you take Haskell for instance, it's harder to talk about callstacks.
02:02:31 <anoe> Hello, I would like to reuse doctest in my project, using stack and with many default-extensions, do you have a working example somewhere please ? Thx in advance.
02:04:37 <veverak> dminuoso: yeah, I have an idea for mine
02:06:34 <LambdaDuck> :t ((fix . ((.uncons).) . (.flip (.))).) . (.((.uncurry) . maybe)) . flip (.) . flip (.)
02:06:35 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:07:20 <__monty__> Kinda pushing the pointless style there, huh?
02:07:37 <LambdaDuck> What do you mean? It's perfect!
02:07:46 <LambdaDuck> :P
02:08:27 <boxscape> @unpl ((fix . ((.uncons).) . (.flip (.))).) . (.((.uncurry) . maybe)) . flip (.) . flip (.)
02:08:27 <lambdabot> (\ x x0 -> fix (\ x3 x4 -> maybe x0 (uncurry (\ x6 x0 -> x x6 (x3 x0))) (uncons x4)))
02:08:54 <boxscape> huh it jumps from x0 to x3
02:10:24 <__monty__> Hmm, binding x0 twice is more of a readability issue imo.
02:10:36 <boxscape> fair
02:11:45 <LambdaDuck> Here's a more readable version of the unpl above: \ cons nil -> fix (\ self -> maybe x0 (uncurry (\ x xs -> x `cons` self xs)) . uncons)
02:17:27 <LambdaDuck> And here's a slightly more readable, but still not understandable version of the pointfree version, using the pointless-fun library:
02:17:33 <LambdaDuck> @define arg = flip (.)
02:17:34 <lambdabot>  .L.hs:176:1: error:
02:17:34 <lambdabot>      Multiple declarations of ‘arg’
02:17:34 <lambdabot>      Declared at: .L.hs:175:1
02:17:43 <LambdaDuck> -- @let f ~> g = (.f) . (g.); infixr 2 ~>
02:17:50 <LambdaDuck> :t id ~> arg uncurry . maybe ~> fix . (arg ~> uncons ~> id) $ arg  . arg
02:17:51 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:25:18 <LambdaDuck> It's interesting that `arg = flip (.)` and `res = (.)` commutes, so `arg f . res g = res g . arg f`. I wonder if there is a name for such a commutative profunctor? (lmap = arg, rmap = res)
02:47:28 <jusss> kotlin using arrow-kt to simulate higher-kinded polymorphism, which is really not easy to read, I wonder it's difficult to implement on other languages?
03:08:59 * hackage krank 0.2.2 - Krank checks your code source comments for important markers  https://hackage.haskell.org/package/krank-0.2.2 (guibou)
03:43:44 <typetetris> I have a bunch of functions with different arities. I want to manipulate the result of all of them. Do I have to write inividual lambas or is there some typeclass "pusing the map down to the result value" in same sense?
03:44:59 <peutri> does map not already do that?
03:45:09 <dminuoso> peutri: No, fmap only works on unary functions like that.
03:46:05 <dminuoso> typetetris: You can do typeclass tricks to make this automatic, Im not sure whether it's the best idea though.
03:46:13 <peutri> must be my reading of the question then
03:52:05 <dminuoso> typetetris: The problem begins by "how do you manipulate all of those" - and then you're essentially already in a territory where you need lens, existentials, or custom typeclasses.
03:52:20 <dminuoso> Because different functions have different types. Or you start encoding those functions in an ADT...
03:52:36 <dminuoso> The cleanest would be using an ADT, parametrized over the return type, then you can make it a functor.
03:52:43 <dminuoso> (This is even derivable with DeriveFunctor!)
03:53:13 <dminuoso> i.e. `data F a = F1 (Int -> a) | F2 (Int -> Bool -> a) | F3 (Int -> Bool -> Char -> a)`
03:53:40 <dminuoso> Not quite sure whether you'd like the ergonomics of pattern matching on that type again to even use it.
03:56:14 <typetetris> Hmm, thanks. Not sure If I want to do that any more.
03:57:44 <peutri> seems like they all return a
04:01:29 * hackage filelock 0.1.1.5 - Portable interface to file locking (flock / LockFileEx)  https://hackage.haskell.org/package/filelock-0.1.1.5 (AkioTakano)
04:05:51 <boxscape> % data Funs r = F0 r | F1 (forall a . a -> r) | F2 (forall a b . a -> b -> r) | F3 (forall a b c . a -> b -> c -> r) deriving Functor
04:05:51 <yahb> boxscape: 
04:05:52 <boxscape> nice
04:05:57 <maerwald> https://git.io/JJfHQ can't build tasty main... somehow 2 tasty versions are pulled in?
04:07:14 <maerwald> why does that even resolve
04:19:17 --- mode: ChanServ set +o Sigyn
04:33:52 <maralorn> typetetris: Do you need it for one specific return type or do you want to do it for arbitrary return types?
04:34:16 <maralorn> The latter would be problematic because then in the context of currying it wouldn‘t be clear, what the arity of your function even is.
04:35:35 <maralorn> peutri: That example didn‘t come from typetetris.
04:36:33 <typetetris> maralorn: one specific return type. I get a value from some Auth-Path-Component in a servant app and want to provide it to a polysemy effect stack ... but somehow it ties a knot in my brain.
04:37:43 <typetetris> The Effect needing the value is deep down in the Stack to, so, as I understand it, it is not sufficient to just "runReader" like in the server definition ...
04:38:26 <typetetris> But whatever, don't spend time on it, I have to go on now and will do something not so convient.
04:43:47 <maerwald> how to find test files reliably from within test source code? I forgot how it plays with cabal etc
04:50:17 <merijn> maerwald: data-files?
04:50:39 <maerwald> ?
04:51:59 * hackage shake-plus 0.1.9.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.9.0 (locallycompact)
04:52:14 <maerwald> data-files is for runtime stuff
04:53:04 <maerwald> I want to access my golden test files 
04:53:06 <merijn> data-files, etc. are the only portable method of finding files belonging to a package, afaik
04:56:15 <maerwald> seems I can use __FILE__
05:01:30 <maerwald> https://github.com/haskell/haddock/blob/ghc-8.6/html-test/Main.hs#L24
05:53:29 * hackage blaze-markup 0.8.2.7 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.2.7 (JasperVanDerJeugt)
06:06:29 * hackage hakyll 4.13.4.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.4.0 (JasperVanDerJeugt)
06:10:57 <ocharles> Can anyone help me work out what's causing this error? https://gist.github.com/ocharles/6946ce51082f974307aa98494b31170a This only happens on GHC 8.10, so something has changed in the type checker. The offending line is:  https://github.com/tweag/porcupine/blob/master/reader-soup/src/Control/Monad/ReaderSoup.hs#L125
06:11:23 <ocharles> This uses https://hackage.haskell.org/package/vinyl-0.12.2/docs/src/Data.Vinyl.Lens.html#RecElemFCtx which looks reasonable, but I think that `k` isn't quantified correctly
06:12:48 <ocharles> Interestingly if I take out the `, HasField r l ctxs ctxs (ContextFromName l) (ContextFromName l)` bit I get: `The kind of ‘IsInSoup_’ is ill-scoped. Inferred kind: IsInSoup_ :: forall k k.  ((k -> *) -> [k] -> *) -> k -> k -> Constraint` which looks especially funky
06:14:43 <phadej> ocharles: https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/8.10#implicit-kind-variable-changes
06:14:58 <ocharles> phadej: thanks, taking a look
06:15:00 <phadej> and https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/8.10#ghc-infers-fewer-dependent-kinds
06:15:03 <ocharles> If the page ever loads
06:16:22 <ocharles> So I have a feeling the type of RecElemFCtx needs a forall k. I'll try that
06:18:00 * hackage contiguous 0.5.1 - Unified interface for primitive arrays  https://hackage.haskell.org/package/contiguous-0.5.1 (andrewthad)
06:18:18 <phadej> or kind signatures
06:18:21 <phadej> hard to tell
06:19:00 * hackage toolshed 0.18.0.2 - Ill-defined library.  https://hackage.haskell.org/package/toolshed-0.18.0.2 (AlistairWard)
06:20:00 * hackage fishfood 0.0.1.10, factory 0.3.2.2 (AlistairWard): https://qbin.io/player-party-isze
06:20:30 <ocharles> Yea, I'll have a play around
06:20:34 <ocharles> It's probably vinyl that's broken here though
06:20:59 * hackage regexchar 0.9.0.18, regexdot 0.12.2.2, squeeze 1.0.4.18 (AlistairWard)
06:21:58 * hackage bishbosh 0.0.0.5 - Plays chess.  https://hackage.haskell.org/package/bishbosh-0.0.0.5 (AlistairWard)
06:22:59 * hackage weekdaze 0.0.0.2 - A school-timetable problem-solver.  https://hackage.haskell.org/package/weekdaze-0.0.0.2 (AlistairWard)
06:24:59 * hackage bytebuild 0.3.6.0 - Serialize to a small byte arrays  https://hackage.haskell.org/package/bytebuild-0.3.6.0 (andrewthad)
06:27:06 <ocharles> phadej: thanks - needed some kind signatures which has also screwed up a load of type applications, but it does seem to work. I'll see what the authors think
06:31:30 * hackage HasCacBDD 0.1.0.3 - Haskell bindings for CacBDD  https://hackage.haskell.org/package/HasCacBDD-0.1.0.3 (m4lvin)
06:54:35 <ph88> Is there a predicate function to match on a single data constructor ?
06:56:12 <ph88> like this https://bpa.st/ONLQ but then a function which only takes MyData
06:57:20 <xerox_> not easily
06:58:56 <dminuoso> Mmm, if I want to use c2hs in a package, is there a way to specify this dependency through cabal?
07:03:29 * hackage weeder 2.1.0 - Detect dead code  https://hackage.haskell.org/package/weeder-2.1.0 (OliverCharles)
07:06:47 <ski> ph88 : `\case MyData {} -> True | _ -> False' or maybe `not . null . \x -> [() | MyData {} <- [x]]' ?
07:13:00 <sm[m]> dminuoso: build-tool-depends: I think (or build-tools: in package.yaml)
07:17:45 <maerwald> dminuoso: did you not read the cabal handbook? :p
07:24:33 <ezzieyguywuf> I think refactoring in haskell is a lot more of a pleasant experience than something with heavy OOP
07:25:16 <ezzieyguywuf> or maybe I've just gotten better at writing good code to begin with ^_^
07:25:44 <xsperry> or even worse, something with dynamic typing, whether OOP or not
07:26:13 <ezzieyguywuf> python
07:26:17 <ezzieyguywuf> man I used to love python
07:26:20 <ezzieyguywuf> I wonder if I still do...
07:26:24 <xsperry> same
07:35:56 <dminuoso> sm[m]: Cheers!
07:45:54 <dminuoso> sm[m]: Strangely, I still get errors: cabal: The program 'c2hs' version >=0.15 is required but it could not be
07:45:55 <dminuoso> found.
07:47:26 <merijn> dminuoso: Well, is it in your path?
07:48:16 <[exa]> ezzieyguywuf: if the refactoring touches the type, you are sure you'll get a notification for *all* places that need to be fixed. That's very pleasant in comparison with dynamic "run tests and wait"
07:48:38 * ezzieyguywuf nods
07:48:41 <ezzieyguywuf> [exa]: exactly.
07:51:20 <safinaskar> is there parsing library, which can check grammars for ambiguity?
07:51:32 <phadej> happy :)
07:51:45 <merijn> That sounds  like you want a parser generator (like happy, indeed)
07:52:10 <safinaskar> phadej: merijn: thanks, but i don't have grammar in compile-time
07:52:50 <safinaskar> i. e. user supplies grammar in run-time, then my program should check it for ambiguities and then parse something using this grammar
07:53:01 <safinaskar> grammar is not changed during parsing
07:56:07 <safinaskar> maybe happy has some api for supplying grammar at runtime?
07:56:18 <dminuoso> merijn: Why does that matter? Shouldn't build-tool-depends make it available?
07:56:46 <dminuoso> Or does build-tool-depends only place it into some ~/.cabal/bin path, and Im responsible for adding that to PATH?
07:57:46 <merijn> I have no idea, tbh
07:57:52 <merijn> read the docs? :p
07:58:49 <infinisil> Can ambiguity of grammars even be decided?
07:58:57 <infinisil> In general?
07:58:59 * hackage prometheus-wai-middleware 1.0.0.0 - Instrument a wai application with various metrics  https://hackage.haskell.org/package/prometheus-wai-middleware-1.0.0.0 (IanShipman)
07:59:51 <peutri> trick question?
08:00:21 <peutri> for most classes of grammar, yes: that's (part of) what the parser generator does
08:00:48 <safinaskar> infinisil: i don't know. but my grammars will be simple enough.   my grammar will be typical grammar for functional programming language expressions.  with unary ops, binary ops and binders. maybe we can decide at least for them?
08:01:00 <peutri> tricks -> unless you're using some crazy encoding that needs resolution, I suppose
08:02:10 <sm[m]> dminuoso what I took from the user guide yesterday: it ‘install’s the tool and that’s expected to put it in PATH so later build steps can use it
08:02:27 <infinisil> Wasn't a trick question, I just forgot most of what I was taught about grammars :P
08:03:32 <sm[m]> maybe you need ~/.cabal/bin in PATH, not just ~/.local/bin
08:09:10 <phadej> wikipedia says: The decision problem of whether an arbitrary grammar is ambiguous is undecidable because ....
08:09:28 <phadej> but there are semi-decision tools
08:10:34 <orcus> How can I get cabal repl to load a sensible module by default (e.g. from main-is, rather than other-modules)? I can't get .ghci to work here (it seems to load first, and then cabal re-loads the modules)
08:11:01 <phadej> cabal repl loads main-is, iirc
08:12:13 <orcus> huh, then something is broken with my setup...
08:12:58 <orcus> I have a 'main-is: Main.hs' and 'other-modules: Render', yet cabal repl always drops me into '*Render>', rather than '*Main>'
08:13:11 <orcus> (Perhaps I'm mis-using the terms "load" here)
08:14:22 <phadej> % cabal repl Cabal:unit-tests
08:14:23 <yahb> phadej: ; <interactive>:88:1: error: Variable not in scope: cabal :: t0 -> t1 -> a; <interactive>:88:7: error: Variable not in scope: repl; <interactive>:88:12: error: Data constructor not in scope: Cabal; <interactive>:88:18: error:; * Variable not in scope: unit :: [a]; * Perhaps you meant one of these: `BSL.init' (imported from Data.ByteString.Lazy), `BS.init' (imported from Data.ByteString), `ini
08:14:24 <phadej> ....
08:14:30 <phadej> Ok, 28 modules loaded.
08:14:30 <phadej> *Main> 
08:14:53 <phadej> wild guess, manual .ghci files confuse cabal
08:17:22 <orcus> Huh, I'm getting '[1 of 2] Compiling Render' '[2 of 2] Compiling Main' 'Ok, two modules loaded.' '*Render>' (*without* a .ghci)
08:17:50 <merijn> oh
08:18:02 <orcus> It's really annoying me that I then have to bring '*Main' into scope before I can run ':main' for testing
08:18:06 <merijn> Do you have a library and exe in the same package?
08:18:41 <orcus> Just executable. Though it is in a project with another package with both.
08:18:48 <merijn> hmm
08:18:57 <orcus> I'll see if I can replicate standalone
08:19:17 <ezzieyguywuf> orcus: are you using stack?
08:19:37 <ezzieyguywuf> nvm I scrolled back
08:19:50 <ezzieyguywuf> I'm also having issues trying to get ghci to load my Main
08:20:22 <ezzieyguywuf> I worked around it by just specifying the path to my main, i.e. `stack ghci Path/To/Main.hs`
08:22:29 * hackage sbv 8.7 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.7 (LeventErkok)
08:26:11 <orcus> Welp, in a fresh project it happens. Just have two modules: Main and Lib, and only an executable cabal stanza.
08:26:24 <orcus> This is using cabal-install version 3.0.0.0 btw
08:30:05 <merijn>  oh!
08:30:18 <merijn> what happens of you do "cabal repl exe-name"?
08:30:31 <merijn> orcus: i.e. if you have "executable foo" "cabal repl foo"
08:31:27 <orcus> merijn: exactly the same: drops me to '*Lib>'. Also the same for "cabal repl exe:foo"
08:34:08 * ezzieyguywuf nods
08:44:43 <[exa]> safinaskar: I'm not really sure that it will work with parsec-style parsers, but you can probably put together a simple DSL (free monad!) that can be transformed both to megaparsec code and a description that can be checked for ambiguity. In particular, the algorithm used by bison&happy for transforming LR grammar to parsing tables detects shift/reduce conflicts, which is the usual type of ambiguity you 
08:44:49 <[exa]> want to detect with "normal" languages
08:45:26 <[exa]> safinaskar: the algorithm itself is pretty straightforward, see https://en.wikipedia.org/wiki/LR_parser#Constructing_LR(0)_parsing_tables
08:51:46 <safinaskar> [exa]: thanks
08:52:06 <safinaskar> [exa]: i will do this as last resort if i am unable to find library
08:56:56 <[exa]> safinaskar: perhaps the thing from happy could be extracted and reused ... here https://github.com/simonmar/happy/blob/master/src/LALR.lhs
09:03:48 <ezzieyguywuf> is it pretty rare that one might need to define their own typeclass?
09:03:54 <ezzieyguywuf> i.e. if I find myself doing so, should I think twice?
09:06:03 <ski> yes, probably
09:06:22 <ski> you should probably have at least two different instances of it in mind
09:06:38 <ezzieyguywuf> yea, thought so.
09:06:53 <ski> and, usually, you should want to define at least one operation which is constrained polymorphic over it
09:07:50 <ezzieyguywuf> I was looking specific at this series of three functions: https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/MyCAD/GUI/GL_Helpers.hs#L83
09:09:30 <ezzieyguywuf> rather than righting a new `xxxUniform` function every time I need to create a new `Uniform a`, I was going to change `putUniform` to something like `GLUniform a => Shader -> a -> IO ()` and have the `GLUniform` typeclass include `makeData :: a -> String -> IO ()`
09:09:49 <ezzieyguywuf> or something like that, still a rough concept right now but it seems an appropriate place for a typeclass
09:10:22 <Cale> There's a lot of times where people will make classes when they shouldn't, and a lot of times I've noticed that they won't when they should :)
09:10:59 <ezzieyguywuf> lol
09:11:50 <ezzieyguywuf> well, in this case I'm looking at either creating an exporting a `makeXXXUniform` function for probably each of these (eventually) - https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glUniform.xml
09:12:15 <ezzieyguywuf> or doing the typeclass and writing the instance internally. I think it keeps my public api cleaner
09:19:45 <solonarv> a typeclass seems sensible for this
09:23:05 <ezzieyguywuf> is TypeSynonymInstances generally safe, or should I just use newtype instead?
09:23:51 <solonarv> it's safe, because it doesn't let you write any instances you couldn't already write
09:23:54 <solonarv> explanation:
09:24:07 <ezzieyguywuf> hrm, plus FlexibleInstances
09:24:24 <solonarv> suppose you have 'type Foo = Int'; then 'instance Class Foo' means *exactly the same thing* as 'instance Class Int'
09:26:30 <ezzieyguywuf> I follow.
09:29:13 <solonarv> that makes it safe, but also not all that useful
09:29:31 <solonarv> and arguably a bit confusing, since when looking at the instance you don't see what type it's actually for
09:30:19 * ezzieyguywuf nods
09:30:55 <ezzieyguywuf> so I'm trying to make an instance for Linear.M44, but really that's just `type M44 a = V4 (V4 a)` or something
09:31:24 <ezzieyguywuf> and I see your point, `class MyTypeclass (M44 a)` is much less clear than explicitly `class MyTypeclass (V4 (V4 a))`
09:31:35 <ezzieyguywuf> but I still need FlexibleInstances in this case, right?
09:31:45 <ezzieyguywuf> even if I expand out the type alias?
09:31:48 <solonarv> probably
09:32:11 <solonarv> if GHC says you need FlexibleInstances for an instance, then you need it
09:33:01 <solonarv> but perhaps it'd be better to write 'instance Cls a => Cls (V4 a)' ? that would give you a 'Cls (M44 a)' instance as well
09:34:37 <ezzieyguywuf> solonarv: I'll have to play with it, this is my first time writing a typeclass where it actually seems like the right use-case (previously I was just learning syntax etc)
09:34:58 <Cale> ezzieyguywuf: Of course, if you can do something like  instance MyTypeClass a => MyTypeClass (V4 a)
09:35:08 <Cale> then that's even better
09:35:13 <Cale> but that may not make sense
09:35:21 <Cale> in which case, feel free to use FlexibleInstances
09:35:29 * hackage shake-plus 0.1.10.0 - Re-export of Shake using well-typed paths and ReaderT.  https://hackage.haskell.org/package/shake-plus-0.1.10.0 (locallycompact)
09:36:29 * hackage shakebook 0.8.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.8.0.0 (locallycompact)
09:41:38 <ezzieyguywuf> Cale: solonarv: thanks for the help, I'll let you know how it turns out :)
09:48:37 <solonarv> ezzieyguywuf: hm, looking through the GL docs I might actually split things up a bit
09:49:19 <solonarv> because with 'instance GLUniform a => GLUniform (V4 a)', you get an instance for 'GLUniform (V4 (V4 (V4 a)))', which is wrong
09:56:27 <ezzieyguywuf> solonarv: how would you split it up?
10:00:06 <solonarv> considering that each uniform type is a different GL API function anyway, you probably have to write however many (33, I think?) separate instances
10:01:59 <ezzieyguywuf> (eventually)
10:02:09 <ezzieyguywuf> (up to 33, depending on my needs)
10:13:18 <ezzieyguywuf> solonarv: here's where I got to so far, although this still relies on FlexibleInstances https://gitlab.com/ezzieyguywuf/mycad/-/blob/drawEntity/MyCAD/GUI/GL_Helpers.hs#L103
10:14:50 <ezzieyguywuf> it let me go from `floatUniform 5  "thickness" >>= putUniform shader` to `putUniform shader (makeUniform "thickness" (5 :: Float))`
10:15:33 <solonarv> oh yeah, you'll need FlexibleInstances to represent that correctly
10:15:39 <solonarv> no issue with that
10:15:40 <ezzieyguywuf> probably no more/less readable, but `makeUniform :: GLUniform a => String -> a -> Uniform a` is handy compared to `floatUniform :: String -> Float -> Uniform Float` etc for each type
10:16:05 <ezzieyguywuf> are there any rules of thumb or conventions for naming typeclasses?
10:17:42 <ezzieyguywuf> i.e. in OOP typically a class name is a "thing", i.e. Person, Car, etc. and its member methods are "actions", i.e. "makeOlder", "startEngine" etc.
10:19:41 <dsal> In Haskell, a class name is typically a "obscure concept things nobody has heard of", i.e., Functor, Applicative, Monoid and its member methods are "weird looking", i.e., >>=, <>, fmap, etc...
10:20:17 <erisco> ezzieyguywuf, honestly my experience has been just trying to pick a name that doesn't conflict with other names
10:20:41 <erisco> sometimes you have a data type, a type alias, and a type class all competing for the same name
10:20:54 <dsal> TBH, the one of the problems with the OO thing is that it leads people to really dumb practices.  "Oh, a Car is just a Person with four round legs!"
10:21:07 <ezzieyguywuf> erisco: yea I've noticed.
10:21:17 <solonarv> "name of the concept that all the instances have in common" is a good way to come up with typeclass names IMO
10:21:18 <ezzieyguywuf> dsal: lol.
10:21:25 <solonarv> it doesn't always work, but in this case it does
10:21:27 <ClaudiusMaximus> just don't call all your classes C
10:21:33 <solonarv> 'Uniform' or 'GLUniform' are both fine
10:21:35 <merijn> ezzieyguywuf: There's no real rule of thumb, otoh defining your own class is fairly rare
10:21:37 <erisco> as to whether there is a naming convention... nothing I've universally observed
10:21:52 <ezzieyguywuf> thanks for the input all.
10:21:55 <erisco> there are sometimes patterns like IsX for a class of types that are X-like
10:21:59 <solonarv> yeah there's no *single* convention, more like a bunch of conventions :>
10:22:14 <monochrom> name your classes C0, C1, C2,... :)
10:22:15 <ezzieyguywuf> I'll leave it as `GLUniform` and make sure I think thrice any time I reach for the `class` keyword
10:22:45 <ezzieyguywuf> I was reading through the ghci source yesterday, there's some pretty whacky naming conventions in there
10:22:50 <ezzieyguywuf> even coding conventions
10:23:55 <merijn> whacky how?
10:26:29 * hackage curve25519 0.2.4 - Fast implementations of the curve25519 elliptic curve primitives.  https://hackage.haskell.org/package/curve25519-0.2.4 (AdamWick)
10:27:14 <ezzieyguywuf> whoops, mispoke: ghcid
10:32:31 <monochrom> Class names: if you look at Functor (as opposed to Mappable, Functorial), Num (as opposed to Numerical, Arithmetical), Monoid (as opposed to Monoidal, Associative, Concatenable), you gather than the prevailing culture is to use a classifying noun rather than a classifying adjective.
10:33:25 <monochrom> And then you point at Foldable and Traversable, ah but those were named by millenials, damn them. :)
10:36:33 <dolio> No, they weren't.
10:38:59 <ezzieyguywuf> lol
10:39:12 <ezzieyguywuf> aren't Foldable and Traversable kind of "new"?
10:39:35 <monochrom> yeah
10:40:13 <merijn> Define "new"
10:42:44 <ezzieyguywuf> *shrug* since 2010
10:43:07 <ezzieyguywuf> hah, you know, I've done more refactoring in the past week using haskell than in probably the past 15 years using python, c++, or java.
10:43:20 <dolio> In 2010 they were already 2 years old at least, paper-wise.
10:43:23 <ezzieyguywuf> but, you know, then again, I've never really known what I was doing :-P
10:43:29 <ezzieyguywuf> dolio: what about use-wise
10:43:44 <ezzieyguywuf> s/than in probably/than I probaly/gc
10:47:27 <dminuoso> ezzieyguywuf: weird, I never know what Im doing when I refactor.
10:47:42 <dminuoso> I just please the type checker all across my code base, then it compiles and works right - and I have no clue why.
10:48:11 <ezzieyguywuf> dminuoso: *shrug* just keep running at full speed
10:48:15 <ezzieyguywuf> eventually you'll get where you're going
10:48:36 <dolio> If people weren't already using them, they probably wouldn't have been added to the base libraries.
10:51:52 <carter> Yeah. Traverse is good stuff
10:52:25 <carter> Dolio what are you up to these days ?
10:53:27 <JohnTitor> hi I'm having issues building taffybar, I cloned https://github.com/taffybar/taffybar.git && cd taffybar && affybar stack --jobs "$[$(nproc)+1]" --local-bin-path "bin/" install -- taffybar
10:54:30 * hackage kubernetes-client-core 0.2.0.0 - Auto-generated kubernetes-client-core API Client  https://hackage.haskell.org/package/kubernetes-client-core-0.2.0.0 (axeman)
10:54:36 <dolio> Same old thing, mostly.
10:54:59 <JohnTitor> it fails with https://0x0.st/iJlI.txt
10:55:28 * hackage kubernetes-client 0.2.0.0 - Client library for Kubernetes  https://hackage.haskell.org/package/kubernetes-client-0.2.0.0 (axeman)
10:55:37 <maerwald> what's the reason ghc cannot inline `f x = foo x` as if it was `f = \x -> foo x`?
10:56:36 <ezzieyguywuf> maerwald: isn't that what `f = foo` does?
10:56:46 <maerwald> that wasn't the question
10:56:55 <dminuoso> maerwald: Specifically for unary functions, or functions in general?
10:57:15 * ezzieyguywuf backs away slowly with his hands up.
10:57:22 <maerwald> in genera
10:57:29 <dmj`> JohnTitor: do you have cairo installed
10:57:40 <dminuoso> Well with functions with arbitrary arity, there can be an observable difference.
10:58:05 <maerwald> I can imagine it gets complicated with multiple definitions, guards etc?
10:58:07 <dminuoso> That is `f x y = ...` and `f = \x -> \y -> ...` can be told apart if x is a pattern.
10:58:35 <dminuoso> Or rather if its refutable.
10:58:39 <monochrom> IIRC inliner takes "f x = ..." seriously, no inlining unless you use it as "f xxx".
10:58:47 <maerwald> yes
10:59:17 <dminuoso> maerwald: That alone makes a good case, why such an inlining is not possible in general.
10:59:21 <dminuoso> Because it would change the semantics
11:00:00 <dolio> I think there's no "can't." It just doesn't. The number of arguments is treated as how many you have to give before it considers inlining. If you want it to inline differently, give it a different number of arguments.
11:00:26 <maerwald> dminuoso: so? It could still optimise if they are not patterns
11:01:26 <maerwald> -fmore-aggressive-inlining?
11:01:47 <maerwald> don't see the reason, unless it's just not implemented
11:03:22 <JohnTitor> dmj`: haskell-gi-cairo?
11:03:34 <hseg> q: why does the constraint synonym trick (i.e. class ctx => Syn ts; instance ctx => Syn ts) require MonoLocalBinds?
11:03:52 <hseg> especially, why does it require MonoLocalBinds at use sites as well?
11:04:46 <dmj`> JohnTitor: just cairo. You build failed at "--  While building package gi-cairo-render-0.0.1 using:"
11:04:50 <dmj`> your*
11:05:02 <JohnTitor> ah
11:05:09 <JohnTitor> lemme check
11:05:10 <dmj`> JohnTitor: so you might be missing that third-party dep.
11:05:20 <JohnTitor> thanks!
11:05:49 <dmj`> JohnTitor: well, thank me when it's fixed :) 
11:06:11 <dmj`> just my best guess
11:07:46 <hololeap> is there a name for this "design pattern" and is there anything i need to watch out for when using it? http://dpaste.com/29E0XRJ
11:08:28 <hseg> this is known as higher-kinded data
11:08:46 <hseg> haven't used it enough to know tradeoffs
11:08:51 <JohnTitor> dmj`: hmm there is cairo in stack.yaml https://0x0.st/iJld.yaml
11:09:13 <dmj`> hololeap: really no different than just saying 'type Coords a = (HasAxis 'X a, HasAxis 'Y a)', unless you're using the closed type family elsewhere
11:10:01 <hololeap> yeah, for instance, i'm using `CoordsF Sum Float` in some places
11:10:24 <ezzieyguywuf> JohnTitor: you still need the cairo library installed if the haskell program you're trying to use links to cairo.
11:10:26 <hololeap> i first ran into this idea using beam... i think they mentioned a name for it
11:10:48 <hseg> hololeap: haven't typed up notes for this yet, here's my links file on the topic http://ix.io/2qAo
11:11:04 <JohnTitor> I already have cairo package from OS' repos installed
11:11:16 <ezzieyguywuf> JohnTitor: drat, that must not be it then. unless there's a version mismatch
11:12:02 <monochrom> perhaps libcairo-dev vs cairo
11:12:30 <dmj`> hololeap: beam puts closed type families inside datatype declarations, like data Foo f = Foo { f :- String }
11:12:49 <dmj`> where :- is your closed type family 'type family a :- b where ...'
11:13:07 <JohnTitor> monochrom: this is arch linux so there's only a big fat package with all the stuff
11:13:40 <hseg> i repeat my previous question: why does the "class newtype" trick require MonoLocalBinds?
11:15:56 <hololeap> dmj`: i'm referring to the stuff like `Data UserT f = User { _userName :: Columnar f Text }` ... is Columnar the closed type family you're referring to?
11:16:01 <dmj`> hololeap: it just makes inference harder for the user I think, you'll always need to :kind! Family Type to see what GHC is resolving to, if at all
11:17:33 <dmj`> hololeap: yes, `Columnar` is a type family defined such that `Columnar Identity x ~ x`.
11:18:19 <dmj`> hololeap: the trick beam is doing with a type family alters the Generic Rep, so in the Identity case you derive most things on your data type since it will be vanilla
11:20:55 <hololeap> well, i just got the idea from beam. really, i just wanted to avoid having to extract the inner data from Identity wrappers
11:21:18 <hololeap> although it feels kinda weird, like ad-hoc polymorphism
11:21:23 <merijn> Not sure anyone should be taking API ideas from Beam :p
11:23:22 <hseg> given f :: a -> Maybe b, t :: C b => (a -> b) -> ... where there is no instance C (Maybe b), what is an idiomatic way of passing f to t?
11:23:45 <hololeap> hseg: ok, found what you were talking about! https://reasonablypolymorphic.com/blog/higher-kinded-data/
11:24:58 <hseg> hololeap: np
11:25:35 <hseg> hrm. my want is a no-go -- there's no way of guaranteeing isJust . f is constant
11:25:35 <dmj`> hololeap: I'd just use type synonyms, not type families for your use case. Beam's approach might be obviated with the new "do" stuff coming to GHC
11:25:45 <hseg> dmj`: what new "do" stuff?
11:26:07 <dmj`> overloaded do or something
11:26:44 <hseg> don't we already have https://hackage.haskell.org/package/overloaded ?
11:28:15 <JohnTitor> dmj`: will grabbing binary from debian package just work? I meant appending shared library version?
11:28:27 <hseg> hrm. i can bash my f and t together with some *ugly* ad-hoc code, but that's unsatisfying
11:30:14 <dmj`> JohnTitor: worth a try, or try to get stack to build cairo-render standalone
11:30:26 <hololeap> hseg, write an instance C a => C (Maybe a) ?
11:30:56 <hseg> doesn't make sense in my situation
11:30:59 <hseg> C ~ Field
11:31:28 <hseg> .. however, i think i can refactor t to be a little more polymorphic
11:31:36 <hseg> which might make this work
11:32:38 <dmj`> JohnTitor: I'd just try building standalone with nix
11:38:18 <dmj`> hseg: we have RebindableSyntax, but its be more tedious to work with compared to whats coming.
11:38:38 <hseg> *nice*. RS has been a pain to work with
11:38:44 <hseg> what's coming up?
11:39:46 <hseg> ok, managed to make it work
11:41:48 <dmj`> Since you have to overload at the call site w/ RS. OD lets you export implementations of (>>=) from a module and I think it gives you a 'do' import for free, then anywhere you use that do, it assumes that bind implementation, which isn't as restricted as (>>=) from Monad. hseg Tweag had some blog post on it. The point is you could use it to build a Query DSL w/o polluting your data types, which nobody has done yet
11:45:13 <hseg> dmj`: don't see the post, link?
11:45:32 <hseg> all i can find is https://github.com/ghc-proposals/ghc-proposals/pull/78 which was rejected
11:46:52 <hseg> unless you mean https://github.com/ghc-proposals/ghc-proposals/pull/216 ?
11:53:27 <dmj`> hseg: yea, qualified do is what I meant
11:53:42 <hseg> it's being implemented?
11:54:16 <dmj`> hseg: this is the link I'm referring to https://www.youtube.com/watch?v=TH3cYp3349A
11:54:52 <hseg> ty
11:55:56 <hseg> btw, any ideas re my question from before? why do "constraint newtypes" require MonoLocalBinds?
11:59:29 <dmj`> hseg: constraint synonym trick ?
11:59:49 <hseg> class ctx => Syn ty; instance ctx => Syn ty
12:00:07 <hseg> does the same for constraints that newtype Syn ty = ctx does for types
12:02:13 <hseg> wait wait wait. much more exciting: linear types are finally in!
12:02:37 <hseg> (obvs aren't yet fully implemented or popular, but still)
12:03:28 <dmj`> hseg: something like this? "class Eq a => Foo a; instance Eq ty => Foo (Syn ty); data Syn a = Syn deriving (Eq) "
12:03:41 <monochrom> "linear types can do a bind!"
12:04:01 <hseg> dmj`: no, more along the lines of class (Num a, Show a) => OldNum a; instance (Num a, Show a) => OldNum a
12:04:54 <monochrom> (pun based on Wadler's "linear types can change the world!" but updated with qualified do-bind)
12:05:33 <monochrom> also I wonder if the "!" is important in Wadler's pun!
12:06:56 <dmj`> hseg: I don't see where mono local binds is necessary
12:07:01 <hseg> same
12:07:07 <hseg> but ghc complains without them
12:10:05 <dmj`> hseg: my ghc doesn't
12:10:35 <hseg> ah. ok, seems complaint is *only* at use site
12:10:42 <hseg> that's doubly weird
12:13:05 <hseg> http://ix.io/2qAS
12:14:08 <hseg> already filed: https://gitlab.haskell.org/ghc/ghc/-/issues/16478
12:15:28 <hseg> i suppose the constraint synonym approach might work, lemme see if it breaks anything
12:15:35 <dolio> Why are you describing MonoLocalBinds as 'necessary' when it gives other options, and it's a warning you asked for?
12:15:58 <hseg> *facepalm* because i'm a dumbass who didn't read things through
12:16:42 <wqr> will ale linters work if ghc is not installed but instead only ghcup?
12:17:27 <maerwald> wqr: no
12:17:39 <Uniaika> no
12:17:58 <wqr> ok problem solved I guess. Why is that?
12:18:05 <maerwald> but I'm not sure I parse the question correctly
12:18:47 <maerwald> ghcup is used to install ghc... it doesn't replace ghc
12:19:46 <maerwald> I mean... ale could theoretically invoke ghcup, but it does not
12:20:00 <wqr> good to know. I uninstalled ghc a few days ago figuring I had ghcup so it was fine. It was fine actually until I fired up vim and was not getting any help.
12:20:25 <hseg> hrm. constraint synonyms also trigger a ghc warning
12:20:38 <hseg> (so literally type OldNum a = (Num a, Show a)
12:21:53 <hseg> ... weird. can't trigger it in my toy example, can in my production code
12:27:09 <hseg> ok, type synonyms aren't partially applicable, which means i can't write functions :: _ -> (_ -> Constraint) -> Constraint
12:29:50 <hseg> ok, i give up. suppose i want a constraint synonym as above. how do i implement it with no warnings? am willing to turn on MLB, but the requirement weirds me out
12:29:58 * hackage gi-gtk 3.0.35 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.35 (inaki)
12:30:43 <hseg> note just using ConstraintKinds + type Syn ty = ctx isn't enough for my usecase
12:31:09 <hseg> since i then want to be able to pass Syn to type-level functions expecting params :: _ -> Constraint
12:32:42 <dolio> Turn off the warning.
12:33:08 <hseg> k
12:36:03 <JohnTitor> it does not matter what I try, cabal install or stack, it always fails the same https://0x0.st/iJU2.txt
12:36:30 <JohnTitor> ooof :(
12:37:19 <JohnTitor> I even tried nix but the binary does not find all the libs
12:37:59 <dolio> That error says it's a problem in c2hs, so the build system you're using is irrelevant.
12:38:24 <sclv> do you have cairo-dev installed?
12:38:40 <sclv> and more generally the gtk dev pkgs?
12:38:50 <sclv> not haskell, system pkgs
12:39:09 <JohnTitor> yep
12:39:15 <sclv> Hrm
12:39:37 <hseg> dolio: that doesn't scale -- i get warnings at use sites
12:40:18 <hseg> so now i need to annotate all use sites with either MLB or warning suppression
12:43:27 <hseg> hrm. maybe https://hackage.haskell.org/package/constraint-tuples might work
12:50:33 <hseg> argh. how do you use constraint-tuples without introducing a layer of type synonyms
12:50:36 <hseg> ?
12:51:24 <hseg> either you write type Syn = CTuple2 .. which can't be partially applied, or you write class CTuple2 ... => Syn and you get back to simplifiable class constraints
12:57:27 <dolio> How does disabling the warning for your project not scale? What you say you want to do is specifically what that warning is designed to complain about.
12:58:50 <hseg> because to satisfy ghc, i need to disable the warning at *all use sites*
12:59:02 <hseg> and i'm not about to turn off warnings across the project
12:59:33 <dolio> You only need to turn off one warning. The warning you specifically want to violate.
13:01:12 <dolio> I mean, I think you should probably not be trying to do 'constraint newtypes'.
13:01:43 <hseg> yes. but i'm not going to turn off warnings across a ~50-module project for one identifier causing trouble
13:02:04 <hseg> ok, how else am i going to avoid combinatorial explosion in my constraints?
13:02:29 <hseg> might as well tell me not to use abstraction
13:04:20 <hseg> besides, some of these "constraint newtypes" are a bit more involved than my toy example suggested
13:05:00 <hseg> e.g. i have Map2 c (f,g) a = (c (f a), c (g a))
13:05:18 <hseg> but yeah, i'm stressing the constraint-level language
13:05:35 <hseg> i guess i've been spoiled by the term level
13:17:29 * hackage language-dickinson 0.1.0.1 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-0.1.0.1 (vmchale)
13:28:47 <dmj`> hseg: I'd try to do whatever you're doing w/o typeclasses first, see how far you can get.
13:29:58 <hseg> i can do it all manually. but i get a combinatorial explosion in the number of constraints
13:30:27 <hseg> especially considering that there are patterns in these constraints
13:30:50 <hseg> so i don't really think that avoiding abstraction is the answer
13:31:05 <hseg> am pinching my nose and using monolocalbinds for now
13:31:16 <hseg> have better things to do than rip it out
13:31:24 <hseg> just surprised it's necessary
13:41:32 <hseg> is there some way to pattern match on a parameter and return Nothing if the pattern match fails?
13:42:09 <hseg> i.e. i want to write \(Domain n [i,j]) -> ive (i == negate j) * (i `min` n)
13:42:09 <ski> `case' ?
13:42:17 <hseg> and have this evaluate to Nothing if the pattern fails
13:42:21 <Rembane> MonadFail?
13:42:32 <hseg> sure, but case is a little heavy on the eyes
13:42:42 <hseg> can MonadFail do that?
13:42:54 <ski> `\case (Domain n [i,j]) -> Just (ive (i == negate j) * (i `min` n)); _ -> Nothing' ?
13:43:37 <ezzieyguywuf> `case (Domain n [i,j] of` maybe?
13:43:40 <ezzieyguywuf> or am I misreading that
13:43:42 <ski> `\d -> listToMaybe [ive (i == negate j) * (i `min` n) | Domain n [i,j] <- [d]]' ?
13:43:59 <hseg> good enough
13:44:00 <ski> (with `MonadComprehensions', you could skip the `listToMaybe')
13:44:00 <Rembane> ezzieyguywuf: Have you heard of LambdaCase? 
13:44:14 <ezzieyguywuf> nope, but I'm looking it up now
13:44:20 <Rembane> ezzieyguywuf: It's sweet.
13:45:18 <ezzieyguywuf> hem haw
13:45:40 <ezzieyguywuf> maybe I don't write enough haskell to see it as sweet
13:45:56 <ezzieyguywuf> but also I mostly avoid language extensions because I don't want to accidentally get into bad habits
13:46:19 <Rembane> ezzieyguywuf: http://storm-country.com/blog/LambdaCase
13:46:30 <hseg> ezzieyguywuf: some of these extensions are old enough to be commonly accepted
13:46:50 <hseg> and indeed, are strong contenders for acceptance into the next version of the report
13:47:28 <ezzieyguywuf> I'm sure that's the case, but I"m still green enough that I don't really know where that line is
13:47:32 <ezzieyguywuf> so I just stay away :P
13:47:41 <ezzieyguywuf> until I really really need something
13:48:33 <MarcelineVQ> ski, hseg: could try building with -XMonadComprehensions  example here  (\y -> [x | x@True <- y]) (Just True)
13:48:43 <MarcelineVQ> ski: drat you said that while I was playing :>
13:48:49 <hseg> :)
13:49:41 <hseg> need to remember at times that haskell isn't lisp -- just because a particular reinterpretation of syntax makes sense, doesn't necessarily mean it's available
13:49:46 <ski> hm, said what ?
13:49:56 <hseg> to use monadcomprehensions
13:51:30 <MarcelineVQ> ye
13:53:11 <ezzieyguywuf> Rembane: that blog post makes a great argument for lambacase, I've found  myself wanting to do something like `readLn >>= \case....`
13:53:16 <ski> MarcelineVQ, hm, did you get any time yet, to ponder `zipWith' ?
13:54:44 <Rembane> ezzieyguywuf: It does! And it makes it even easier to avoid do-notation than it usually is 
13:55:03 <MarcelineVQ> ski: I was mucking with it a bit but didn't make progress in treating zipWith as a consumer
13:55:28 <ski> in SML, `case <scrutinee> of <pattern> => <alternative> | ...' is syntactic sugar for `(fn <pattern> => <alternative> | ...) <scrutinee>'
13:56:16 <solonarv> 'blah >>= \case' is most of my uses of LambdaCase and I find it much more readable :D
13:57:10 <ezzieyguywuf> do y'all add extensions file-by-file?
13:57:11 * ski nods to MarcelineVQ
13:57:17 <ezzieyguywuf> or at the project level in the cabal file or something?
13:57:24 <hseg> by-file
13:57:47 <hseg> only activate warnings by project
13:57:48 <monochrom> I add extensions file-by-file. I want to remind the reader.
13:57:54 <hseg> this
13:58:11 <Rembane> File by file 
13:59:02 <ezzieyguywuf> hm, I don't think I do enough of the coding yet to warrant manually adding lambacase to each of my files 😂
13:59:32 <shachaf> I add ".hs" to every Haskell file, rather than only adding it once in the build configuration.
13:59:47 <dolio> You don't add it to the files you don't use it in.
14:00:08 <ezzieyguywuf> good point
14:00:48 <hseg> how do you guys prune unused extensions? delete all and bring them back as complained for?
14:01:50 <ezzieyguywuf> hah, that's what I did whenever I wanted to update my imports to `import Module (fun1, fun2)` etc... I just deleted the whole import and started added stuff that it needed
14:01:55 <MarcelineVQ> My source files don't tend to get big enough that it's unclear what's not used but that sounds like an option I'd use if so
14:01:57 <ezzieyguywuf> worked really well with ghcid
14:02:25 <MarcelineVQ> ghc does have the abililty to tell you what imports are unused, I wonder how hard it would be to add similar for extensions
14:02:42 <MarcelineVQ> well not just what's unused but also what specifically is used iirc
14:03:13 <ezzieyguywuf> I love that it tells me what imports are unused
14:03:17 <hseg> yeah, i've added -Wwarn-unused-imports to my cabal.project.local for exactly that reason
14:03:17 <Rembane> Oh well https://gitlab.haskell.org/ghc/ghc/-/issues/3085
14:03:42 <Rembane> But hlint supports it! http://neilmitchell.blogspot.com/2019/01/hlint-unused-extension-hints.html
14:04:31 <hseg> not completely though. have had instances where it missed some
14:05:08 <Rembane> Oh, but except for the ones it misses it finds them all 
14:05:18 <hseg> :)
14:05:27 <MarcelineVQ> You can query for the exact imports if you want to make your import list a form of documentation, which I happen to think is a good practice
14:05:33 <MarcelineVQ> *query ghc
14:06:53 <hseg> wonder if a fuzz-testing-like tool could do the trick here -- try all choices, keep the minimal one
14:07:05 <MarcelineVQ> that is to say​ I consider  import Data.List  to be less information than  import Data.List (sortOn)
14:07:15 <ezzieyguywuf> ahhh, yea I've been meaning to add hlint to my ghcid setup
14:07:15 <hseg> ... wtf? why is my test suite consuming ~10GB RAM?!
14:07:39 <hseg> no wonder it's getting killed
14:10:06 <hseg> hrm. any way to get a partial profile to tell me who's to blame for the runaway memory allocation?
14:16:08 <freeman42x[m]> any way to get the functionality of using this function but with less ceremony? https://github.com/fairy-tale-agi-solutions/haskell-editor-setup/blob/b9563abf9973c39f150492ae380b319f65d5750a/src/OS/Linux.hs#L30-L33
14:18:22 <hseg> ok, will investigate this tomorrow
14:18:28 <hseg> thanks guys!
14:19:50 <MarcelineVQ> hmm there's not a lot of ceremony there if we use the word the same, which part in particular is bothering you?
14:23:21 <freeman42x[m]> MarcelineVQ: the extra indentation level required is kind of bothering me, it is not always required though
14:24:01 <MarcelineVQ> Oh okay, it's a style choice but I define functions in where or their own top level declaration and use let for variables or simple pattern matches. This can really save on indentation creep
14:25:22 <MarcelineVQ> This has the added benefit that you don't have to play with indentation yet again when you decide you want to use a function in more then one place, or remove it
14:27:38 <sm[m]> hseg: stack profile is an easy way IIRC
14:29:19 <sm[m]> I'm wrong, nm
14:29:37 <sm> and you're gone
14:29:54 <freeman42x[m]> MarcelineVQ: I actually prefer using where over let whenever possible, I do not recall why I used lets there
14:31:27 <freeman42x[m]> MarcelineVQ: I would like to move all other functions at top level but they depend on the logStep functin which is capturing the sink
14:31:54 <freeman42x[m]> would like to move them at top level since that would allow me to easily test them in REPL
14:32:07 <freeman42x[m]> and also since they are more general than the function that calls them
14:32:31 <freeman42x[m]> it is just that the logStep function forces them to be declared inside that function
14:32:48 <freeman42x[m]> any suggestion for how to fix that?
14:35:22 <MarcelineVQ> I don't understand why logStep can't be moved out as well or is forcing anything to be there. there are all functions so if they need some particular parameter to work you can just let them take it as an argument
14:35:57 <MarcelineVQ> *these are all functions
14:37:24 <ski> sometimes i think it would be nice if one could, in the interactor, step inside a definition, and access the local definitions inside, after providing values for parameters
14:39:29 * hackage dobutokO-effects 0.3.0.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.3.0.0 (OleksandrZhabenko)
14:40:47 <freeman42x[m]> MarcelineVQ: to move  them out I would have to add an extra parameter to all functions that use logStep which would make it worse in some ways
14:40:59 <freeman42x[m]> not sure if easy REPL testing would justify complicating the code
14:40:59 * hackage hackport 0.6.5 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.6.5 (solpeth)
14:50:29 * hackage dobutokO-effects 0.3.1.0 - A library to deal with SoX effects and possibilities  https://hackage.haskell.org/package/dobutokO-effects-0.3.1.0 (OleksandrZhabenko)
14:52:20 <MarcelineVQ> I'm having trouble following the types so I can't comment much better, I would try pull it all apart and then see how things can be arranged nicer after that. easy testing is a pretty big win compared to passing an extra argument or two
15:09:30 * hackage vinyl 0.12.3 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.12.3 (AnthonyCowley)
16:10:01 <koz_> Let's say I have 'newtype Foo = Foo Word8', and I wanna write a pattern Bar, which basically represents 'Foo 0'. What's the syntax for that bidirectional pattern synonym?
16:10:29 <solonarv> koz_: you can just write 'patter Bar = Foo 0'
16:10:39 <solonarv> er, well, without the typo :>
16:10:41 <koz_> solonarv: Wait, that would work?
16:10:47 <koz_> Bidirectionally? So both matching and construction?
16:11:08 <koz_> (also, GHC doesn't love that)
16:11:38 <solonarv> really? hm. perhaps it doesn't like the 0, oen sec
16:12:25 <solonarv> eh? 'pattern Just0 = Just 0' works fine for me
16:12:29 <koz_> Wait, lol, forgot to enable the extension.
16:12:32 <koz_> And this is bidirectional?
16:12:40 <solonarv> yep
16:12:45 <koz_> Wow, TIL.
16:12:46 <koz_> Thanks!
16:12:54 <slack1256> With = it is bidirectional. With just <- is just a pattern without construction.
16:13:05 <solonarv> if the RHS is valid both as a pattern and as an expression, you can write = and it'll be bidirectional
16:14:54 <koz_> Haskell is great - every day, I learn something new.
16:15:41 <wkm> is it possible to use hdevtools with ale having only installed ghcup and not ghc?
16:17:47 <solonarv> pattern synonyms are a neat little feature :D
16:21:07 <ski> once i made a squash/zuccini cake
16:21:39 <sm[m]> what do you think was gong on at line 154 here ? Some kind of Haskell98ism: https://hub.darcs.net/simon/ssh/browse/src/SSH.hs#151
16:22:25 <sm[m]> aren't these four lines a noop ?
16:23:12 <sm[m]> corrupted indentation ?
16:24:47 <wkm> Im trying and struggling to install hdevtools with cabal and stack. I have ghc through ghcup. Here is the error that I am getting while building through cabal: https://pastebin.com/CByuVY7B
16:25:41 <wkm> and here is the error when building through stack: https://pastebin.com/hzV0Myp3
16:26:13 <solonarv> sm[m]: it's either corrupted indentation (and then lines 155-178 are inside the do block starting on line 154), or a syntax error (because the do block on line 154 is empty)
16:26:33 <solonarv> :t do { }
16:26:35 <lambdabot> error: Empty 'do' block
16:27:39 <crestfallen> hi there are dependencies missing when I try    $ cabal install pointful    I've update cabal to no effect. any ideas? thanks
16:27:42 <sm[m]> solonarv: weird right ? it was that way in the original author's initial commit. I suspect he disabled the if for testing and forgot about it. With haskell 98 it wasn't an error
16:28:09 <crestfallen> error: pointful-1.1.0.0-9G8vCYnEIOKw9VTuncHny depends on pointful-1.1.0.0 which failed to install.
16:28:48 <sclv> crestfallen: can you use a pastebin to paste more log there?
16:29:09 <crestfallen> sclv, thanks yes one moment
16:30:53 <crestfallen> sclv, https://termbin.com/5s0g
16:32:48 <sclv> crestfallen: here's the key problem -- "cabal: The program 'happy' version >=1.19 is required but it could not be found."
16:33:02 <sclv> so you should install a new enough version of happy first
16:36:29 <crestfallen> happy ?
16:36:43 <crestfallen> ok thanks will do
16:56:24 <sm[m]> sclv: can this problem be solved nowadays by adding build-tool-depends: happy or whatever ?
16:57:24 <sm[m]> to haskell-src-exts ?
16:58:05 <sm[m]> I see it's there as Build-Tools: http://hackage.haskell.org/package/haskell-src-exts-1.23.1/haskell-src-exts.cabal
16:58:55 <sm[m]> how come that didn't make it work ?
17:11:54 <dminuoso> sm[m]: I think its the same issue I had.
17:12:08 <dminuoso> You might have to add ~/.cabal/bin (or wherever your cabal puts it to) to your PATH
17:12:24 <sm[m]> crestfallen: ^
17:12:39 <MarcelineVQ> was writing cabal install even neccesary I instead wonder
17:12:44 <sm[m]> that could be it
17:12:59 <MarcelineVQ> if a project should be used then a dependency should be made. and if not one can write  cabal repl -b pointful
17:13:58 <sm[m]> it's a command line tool, you should certainly be able to cabal install it
17:14:44 <MarcelineVQ> Oh yes I see pardon me then, I had read that as pointed in my head appearantly
17:15:13 <sm[m]> I think basically haskell build tools should have been very proactive about managing and reporting PATH issues from the beginning, it has been the cause of so many puzzles
17:17:04 <sm[m]> In latest doc: "Cabal tries to make sure that all specified programs are atomically built and prepended on the $PATH shell variable before building the component in question [for Nix-style builds]". I wonder what it does exactly
17:17:43 <sm[m]> also, could anyone simplify the discussion of internal/external for me ? https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-build-tool-depends
17:19:29 * hackage hunit-dejafu 2.0.0.4 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-2.0.0.4 (barrucadu)
17:20:30 * hackage dejafu 2.4.0.0, tasty-dejafu 2.0.0.6 (barrucadu): https://qbin.io/mo-coated-lm3t
17:27:29 * hackage string-interpolate 0.3.0.0 - Haskell string/text/bytestring interpolation that just works  https://hackage.haskell.org/package/string-interpolate-0.3.0.0 (williamyaoh)
17:29:43 <sclv> sm[m]: with v2-build itll build exes you depend on for you, and keep then in a store as well
17:30:09 <sclv> internal is if you have a component that depends on an exe defined in the same file
17:30:36 <sclv> like say a test component that drives an executable
17:31:11 <sclv> external is the typical case, like happy
17:32:54 <sm[m]> I see, thanks
18:09:58 <hololeap> anyone know of a lens function like this?
18:10:01 <hololeap> getApply :: Contravariant f => a -> LensLike' f (a -> b) b
18:10:24 <hololeap> getApply a = to ($ a)
18:10:30 <hololeap> is it already in the main library?
18:10:59 <hololeap> ideally as a Lens or Lens'
18:12:44 <hololeap> lensApply :: a -> Lens' (a -> b) b
18:17:14 <jusss> absurd :: Void -> (forall. a) why this is ok?
18:17:24 <jusss> :t Void
18:17:25 <lambdabot> error:
18:17:25 <lambdabot>     • Data constructor not in scope: Void
18:17:25 <lambdabot>     • Perhaps you meant one of these:
18:21:11 <slack1256> absurd :: forall a. Void -> a
18:21:31 <slack1256> But also `absurd :: Void -> (forall a. a)` is a valid type.
18:22:08 <jusss> _ is a bottom value, is Void a bottom type? or is there a bottom type?
18:23:09 <wavemode> er, Void is a type inhabited only by bottom, if that's what you mean
18:23:18 <slack1256> There are different concepts muddled there, the logical view to me is the clearer so I will explain that.
18:24:14 <slack1256> Haskell types like Bool, Int, Void correspond to propositions and the terms that have those types correspond to a proof of the proposition represented by that type.
18:24:15 <jusss> in Java, null value could have any type, any value could have Object type
18:24:53 <slack1256> Void logically corresponds to a proposition without any way to construct a proof/term, because by construction it does not have any.
18:26:07 <slack1256> But haskell is not a logic system but a general programming language, so it has general recursion available at term level. So we can define a proof for any proposition via a `bottom value` which just correspond to define in ghci a value like `mybottom = mybottom` at top level.
18:26:25 <slack1256> Actually do write that on a file and ask what type it has to ghci.
18:27:10 <slack1256> So Void should not have any term/proof available as a value, but given this gotcha of general recursion it has the `bottom` value we just defined.
18:27:17 <jusss> Void correspoinds that value doesn't exist
18:27:54 <dolio> I don't think you should try to think of every type as a proposition.
18:27:59 <jusss> does _ correspond any existed type?
18:28:02 <slack1256> Void correspond to a _proposition_ that has no values/proof available except the one provided by general recursion.
18:28:23 <dolio> The point of 'propositions as types' is that propositions can be encoded as types, not that every type should correspond to a proposition.
18:28:35 <wavemode> jusss: _ is a typed hole. it's just a programming tool provided by ghc
18:29:13 <jusss> wavemode: so _ isn't existed in haskell the language?
18:29:17 <slack1256> dolio: Void probably should be thought logically, it is used mainly for its logical value.
18:29:34 <dolio> Void is fine to think of as a proposition.
18:29:47 <dolio> You just shouldn't bother with Bool and Int.
18:29:52 <slack1256> But yeah, thinking about Int as a proposition takes you no where.
18:30:51 <wavemode> jusss: no
18:30:59 * hackage postgresql-typed 0.6.1.1 - PostgreSQL interface with compile-time SQL type checking, optional HDBC backend  https://hackage.haskell.org/package/postgresql-typed-0.6.1.1 (DylanSimon)
18:31:37 <wavemode> (though _ as used in pattern matching is part of the language. but that's completely different)
18:32:43 <jusss> why ghc has those black magics and they don't exist in the language?
18:33:16 <wavemode> that question is a matter of considerable debate :p
18:34:43 <Axman6> _ isn't anything special, it is just being explicit that an argument to a function or a case match is not used. everywhere you use _ you could also use x and just not use it. unless we're talking about at the type level? this conversations is very confusing
18:35:11 <jusss> so if there're "null" and "Object" in haskell?
18:36:22 <Axman6> _ when not used in a pattern causes a specific kind of error. its not really poart of HAskell, since no program can be compiled if it still contains _ in an expression
18:55:59 <jusss> :t (<<)
18:56:01 <lambdabot> error:
18:56:01 <lambdabot>     • Variable not in scope: <<
18:56:01 <lambdabot>     • Perhaps you meant one of these:
19:03:12 <int-e> well, there is -fdefer-typed-holes in ghc if you feel adventerous
19:06:59 <crestfallen> Cale, ahoy
19:21:28 * hackage invertible 0.2.0.6 - bidirectional arrows, bijective functions, and invariant functors  https://hackage.haskell.org/package/invertible-0.2.0.6 (DylanSimon)
19:42:29 * hackage web-inv-route 0.1.2.3 - Composable, reversible, efficient web routing using invertible invariants and bijections  https://hackage.haskell.org/package/web-inv-route-0.1.2.3 (DylanSimon)
20:46:37 <hihi> @faq Is Predicate a functor?
20:46:37 <lambdabot> https://wiki.haskell.org/FAQ
20:47:11 <hihi> lambdabot hi
21:06:29 * hackage backprop 0.2.6.4 - Heterogeneous automatic differentation  https://hackage.haskell.org/package/backprop-0.2.6.4 (jle)
21:26:49 <tommd> I'm curious what peoples impressions of Stan are.  Have people tried it, liked or disliked it, formed opinions or plans on the tool and its use?
21:46:16 <jle`> tommd: is this a new hot library?
21:50:51 <sicklork1n> I'm (ab)using `#!/usr/bin/env stack script` for a one-off script but need to include a package that's outside hackage.  I tried unpacking it in the local dir and including it in the `-- package` line but doesn't seem to take.  Can anyone think of 
21:51:22 <sicklork1n> a way to accomplish this without having to install the package locally prior to running the script
21:52:14 <sicklork1n> the package is flatbuffers - so including the sources it out of the question
21:52:26 <sicklork1n> s/it/is
21:55:14 <sicklork1n> it's on hackage, not stackage
22:03:50 <sm[m]> sicklork1n: if you write it as —package PKG-X.Y doesn’t it work ?
22:04:41 <sm[m]> usually the version number tells it to fetch from hackage
22:05:15 <sicklork1n> sm[m]: it didn't work - but just to make sure i'll try again
22:06:35 <sm[m]> I’d try also doing stack update once
22:07:08 <sicklork1n> thanks, i've tried all these things
22:07:15 <sm[m]> If that doesn’t do it, maybe the script command is special, docs may say
22:08:56 <sicklork1n> actually I could be misleading you.. it says Could not find module `FlatBuffers`
22:09:06 <sicklork1n> which i'm assuming means it idsn't installed
22:10:46 <sicklork1n> stack --resolver nightly script ghc-pkg list doens't work.. 
22:10:56 <sicklork1n> i'm curious to see if it's picking it up now
22:11:30 <sicklork1n> sm[m]: i didn't see anything in the docs.. wahtever seemed interested I've hammered on.. 
22:11:56 <sicklork1n> thanks for the suggestions.. i may just accept defeat.. i'm spending way to much time on this
22:13:34 <sm[m]> Yes docs don’t mention hackage oackages
22:14:28 <hololeap> is there a monoid instance somewhere for (Arrow a => a b b), like Endo for (->)
22:14:29 <sicklork1n> i can proablby use dep-packages or whatever that one is for curated package
22:15:35 <sm[m]> maybe runghc works ? https://docs.haskellstack.org/en/stable/GUIDE/#writing-independent-and-reliable-scripts
22:16:22 <sicklork1n> sm[m]: I ended up runnig into other issues using runghc
22:16:24 <sicklork1n> lol
22:16:56 <sicklork1n> i'm sure I'm just overlooking something obvious - it's no worries
22:17:38 <sm[m]> Yeah, script is nice. I’ll try this when I get a chance
22:17:51 <sicklork1n> do you want a copy of what I have?
22:18:17 <sm[m]> Sure, a paste of script and error is helpful
22:22:40 <sicklork1n> https://tcp.st/wez_9
22:22:48 <sicklork1n> sm[m]: 
22:23:44 <sicklork1n> ./script.hs -t -f /dev/null should give you the error I'm seeing
22:23:57 <sm[m]> what snare the first two lines ?
22:24:05 <sm[m]> I can’t test just now
22:24:08 <sicklork1n> paste fail
22:24:31 <sm[m]> I would remove the blank line separating the comments though
22:25:03 <sicklork1n> sure, it' won't do anythhing..
22:25:21 <sicklork1n> i've tried {- script -} syntax as well
22:25:49 <sicklork1n> (probably good form tho, now that I think abou tit) cheers
22:26:11 <sm[m]> ok.. and isn’t it —compile with two hyphens ? And what’s -hide-package doing ?
22:27:03 <sm[m]> are we sure the last exec line isn’t get read as more arguments ?
22:28:12 <sm[m]> and what’s the error output ?
22:30:27 <sm[m]> You’ve got me quite curious. don’t fail us, trusty script command
22:34:56 <sm[m]> script is all about reproducibility so maybe it’s specifically disallowed because hackage packages can have revisions
22:35:23 <sm[m]> Ah well, I’m afk,good luck sicklork1n
22:52:47 <sm[m]> https://github.com/commercialhaskell/stack/issues/3218#issuecomment-308725226
22:53:08 <sm[m]> new plan: add flatbuffers to stackage
23:21:28 <sicklork1n> lol i guess thsi works too.
23:23:19 <sicklork1n> i'm not sure I understodd snoy's argument for extra-deps
23:26:10 <sicklork1n> sm[m]: the error output is: Could not find module ‘FlatBuffers’
23:48:59 * hackage http2 2.0.5 - HTTP/2 library  https://hackage.haskell.org/package/http2-2.0.5 (KazuYamamoto)
