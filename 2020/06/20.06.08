00:00:07 <opticblast> Checking Hackage, it seems like vector solved this problem by making a wall flag.
00:27:43 <kuribas> is a type inference algorithm easier in a (functional) logic language?
00:29:20 <kuribas> As unification is done by the language.
00:50:49 * hackage process 1.6.10.0 - Process libraries  https://hackage.haskell.org/package/process-1.6.10.0 (MichaelSnoyman)
01:22:41 <crestfallen> hello
01:22:45 <ania123> hi
01:23:55 <crestfallen> I cannot autojoin the haskell channel of irssi. annoying. tried evewrything to config
01:24:07 <crestfallen> on* irssi
01:29:31 <rsoeldner> Any way to derive a ToJSON/FromJSON instance for beams `Nullable` for PrimaryKeys ? like `toJSON (PrimaryKey t (Nullable f))` ?
01:36:30 <younder> I've been studying homopothological types. Any implementation of fibered categories?
01:40:55 <dminuoso> rsoeldner: Just write out the instances by hand..
01:47:35 <rsoeldner> dminuoso, true :)
03:29:48 * hackage ginger 0.10.0.5 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.10.0.5 (TobiasDammers)
03:37:00 <arjaz> Hello, I wanted to ask if anyone had problems with setting up the scratchpad with st as a terminal in XMonad?
03:44:04 <dminuoso> phadej: Do you think you could export https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/src/Database.PostgreSQL.Simple.FromField.html#atto ? This is a handy primitive for easily adding your own FromField instances for things that need parsers. :)
03:54:49 * hackage haskus-utils-data 1.3 - Haskus data utility modules  https://hackage.haskell.org/package/haskus-utils-data-1.3 (SylvainHenry)
04:05:48 * hackage haskus-binary 1.5 - Haskus binary format manipulation  https://hackage.haskell.org/package/haskus-binary-1.5 (SylvainHenry)
04:06:48 <maralorn> younder: homopothological is a word?
04:08:48 * hackage deriving-compat 0.5.9 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.5.9 (ryanglscott)
04:10:29 <phadej> dminuoso: yes, but not with `atto` name :)
04:10:46 <phadej> maybe `fromAttoparsec`
04:11:54 <phadej> pr welcome. (haddocks, using FieldParser a as return type...)
04:21:10 <dminuoso> Will do
04:34:49 * hackage IntervalMap 0.6.1.2 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.6.1.2 (ChristophBreitkopf)
04:36:19 * hackage cabal2nix 2.15.4 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.15.4 (PeterSimons)
04:37:02 <sheepfleece> I have a type `Foo a b` which is functorial in the first argument. How can I write a Functor instance for it? I can't use typesynonyms nor type families, because I would need to partially apply them to swap arguments.
04:37:20 <sheepfleece> Maybe something with DerivingVia and a new `newtype`?
04:37:28 <merijn> sheepfleece: You can't, unless you swap the argument or use a newtype to do so
04:37:42 <merijn> sheepfleece: Is it also a functor in the 2nd type?
04:37:42 <sheepfleece> I see, thank you.
04:37:45 <sheepfleece> No
04:37:48 <sheepfleece> Yes
04:37:50 <sheepfleece> Yes
04:38:01 <merijn> sheepfleece: Then you may want Bifunctor?
04:38:13 <merijn> :t bimap
04:38:14 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
04:39:00 <solonarv> :t first -- also this
04:39:02 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
04:39:05 <solonarv> ah, wrong one
04:39:06 <sheepfleece> Oh, no it is contravariant (It is a ReaderT in essence and I want to try and write this function :: (a -> b) -> ReaderT b o -> ReaderT a o)
04:39:19 * hackage hledger-interest 1.5.5 - computes interest for a given account  https://hackage.haskell.org/package/hledger-interest-1.5.5 (PeterSimons)
04:39:37 <solonarv> contravariant in the second-to-last argument, covariant in the last one?
04:39:41 <solonarv> that's a Profunctor
04:40:00 <solonarv> :t lmap
04:40:02 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
04:40:12 <solonarv> :t dimap -- the "main method" of Profunctor
04:40:13 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
04:40:27 <sheepfleece> Oh, nice, so ReaderT is a profunctor? I guess I can use that. 
04:41:09 <solonarv> ReaderT isn't, because it takes three parameters in the order 'ReaderT r m a'
04:41:34 <sheepfleece> Than a simple Reader is.
04:41:40 <solonarv> it's contravariant in the first and covariant in the third; the middle argument "gets in the way"
04:41:43 <solonarv> yes
04:41:52 <solonarv> (and a simple Reader is just (->) by another name)
04:42:04 <merijn> That's just Kleisli with extra steps :p
04:42:23 <sheepfleece> Can't you just more the second argument in ReaderT with a newtype? 
04:42:29 <sheepfleece> *move
04:42:57 <merijn> sheepfleece: Sure, but then it's no longer ReaderT and you have reinvented Kleisli ;)
04:43:16 <merijn> sheepfleece: "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }"
04:44:06 <sheepfleece> I see, thank you! (Also can I use `DerivingVia` to make ReaderT also a profuctor? I haven't looked much into it.)
04:44:28 <merijn> (Which, incidentally is also a Profunctor (if 'm' is a Functor) and Category (if m is a monad)
04:46:49 <solonarv> sheepfleece: if you move the arguments of ReaderT around it stops having the right kind for a MonadTrans instance
04:46:52 <solonarv> you just can't win!
04:51:02 <esg> hi, is parsec still the standard parsing library, or is the current practice to use something else?
04:51:09 <dminuoso> esg: There is no standard parsing library
04:51:35 <dminuoso> There's a rich choice of parsing libraries between attoparsec, megaparsec, trifecta, bytesmith, or others.
04:51:43 <dminuoso> All with their own ups and downs.
04:52:05 <maerwald> attoparsec is nice
04:52:14 <esg> thanks: that gives me something to look at. has anyone written about the pros and cons somewhere?
04:52:59 <dminuoso> Megaparsec has compiled how they belief megaparsec compares to some of the other popular parser combinator libraries. https://github.com/mrkkrp/megaparsec#comparison-with-other-solutions
04:53:18 <merijn> esg: megaparsec is a safe default for parsers of "human written" input
04:53:41 <merijn> esg: attoparsec is more geared for parsing machine input (i.e. speed > nice/useful errors)
04:53:58 <esg> thanks very much for the pointers! megaparsec might be what I'm after then.
04:54:03 <maerwald> attoparsec is nice fore everything and the API is simpler
04:54:19 <mniip> what was that relation between profunctors and categories again
04:54:22 <merijn> esg: megaparsec started out as for of parsec, updated for more modern haskell
04:54:44 <merijn> esg: Parsec itself is still "fine", but the API is a bit dated (operators that clash with stuff from Control.Applicative, etc.)
04:54:59 <merijn> Mostly due to Parsec predating the invention of Applicative :p
04:55:07 <dminuoso> mniip: Can you be a bit more concrete? Your question sounds rather rudimentary.
04:55:19 <phadej> fwiw, attoparsec is neither really fast, neither its errors are particularly good
04:55:32 <mniip> a category is a profunctor that ___
04:55:40 <merijn> phadej: I know that megaparsec has caught up in terms of speed
04:55:43 <maerwald> The awful thing about this parsing stuff is that if a library provides a parser for you, you're usually locked into their library choice. So much for composition =)
04:55:46 <esg> merijn: thanks good points
04:55:56 <merijn> phadej: But attoparsec's API is simpler than megaparsec
04:56:10 <mniip> we're looking for an extranatural transformation 1 -> Hom(X, X) and a transformation Hom(X, Y) x Hom(Y, Z) -> Hom(X, Z) natural in X, Z, extranatural in Y
04:56:10 <phadej> yes, one can discuss whether implicit try is good or bad
04:56:21 <mniip> I think?
04:56:43 <maerwald> phadej: it's implicit for string parsers in megaparsec too afaik
04:56:48 <maerwald> which is more confusing
04:56:54 <merijn> phadej: Not just that, but megaparsec's reliance on re-exports and haddocks current (shitty) support for displaying reexports means it can be hard to figure out where to get which combinators
04:57:33 <phadej> merijn: well, say comparing parsec and attoparsec
04:57:37 <mniip> maerwald, hot take, parameterize your parsers by the combinators
04:57:51 <phadej> that what `parsers` does.
04:58:03 <mniip> rats
04:58:04 <phadej> I don't yet know whether it's a good idea
04:58:20 <phadej> even after using that for 4? years
04:58:40 <phadej> (in practice, you just don't swap the "backend")
04:58:46 <dminuoso> phadej: Why should it be either? A package could pretty wrap combinators with implicit try and without via different modules, just like Lazy/Strict things are provided in separate modules.
04:59:19 <dminuoso> Then, a user of the parser combinator library could them him or herself decide whether they want implicit backtracking or not.
04:59:32 <dminuoso> there's arguments to be made both ways
04:59:37 <phadej> that essentially makes you a two libraries in one.
04:59:46 <phadej> you want try in `Alternative` instance...
04:59:50 <phadej> (or then don't)
05:00:23 <phadej> fwiw, `fmap` on Strict Map is still lazy
05:00:31 <phadej> because the `Map` is the same, and there's only one `Functor`.
05:00:42 <phadej> you have to use `Data.Map.Strict.map`
05:01:11 <mniip> just use a free monad to defer the implementation of a parser
05:01:22 <mniip> there's a package that does this :P
05:01:56 <phadej> well, whether it's free monad or MTL-classes like in `parsers` doesn't make a difference
05:02:06 <mniip> kinda does
05:02:14 <mniip> you can implement the free monad approach in 5 lines of code
05:02:35 <phadej> can you? I doubt.
05:02:39 <MarcelineVQ> mniip: like you even know what you're talkin about! :>
05:02:41 <mniip> @hackage yoctoparsec
05:02:41 <lambdabot> https://hackage.haskell.org/package/yoctoparsec
05:03:15 <dminuoso> Well, or you just have a DataKind powered type fam `type family Parser (e :: ParserDefault)` with some `data ParserDefault = Backtracking | OrNot`
05:03:30 <dminuoso> Honestly, there's many ways to get around this
05:03:54 <phadej> mniip: it just makes `newtype Parser b t a = Parser { runParser :: t -> b (t, a) } look fancy
05:03:59 <phadej> value: 0
05:04:12 <mniip> it's not actually  t -> b (t, a)
05:04:30 <mniip> it's  Parser b t a = Either a (t -> Parser b t a)
05:04:42 <mniip> correction: Parser b t a = b (Either a (t -> Parser b t a))
05:04:58 <ski> mniip : `Hom' is divariant, with identity and composition acting in some sense as reflexivity and transitivity ?
05:05:05 <mniip> you're thinking StateT
05:05:09 <maerwald> yeah, something I don't want to use
05:05:21 <mniip> should be thinking FreeT over a single operation "token" : Parser b t t
05:10:09 <phadej> mniip: yes, something - I don't see how using FreeT makes it better than custom made monads. Yes, it's parametrisable by `b`, but is it really useful in practice?
05:10:28 <phadej> it's *not* the case that you can use backtracking here, and not use it there in part of bigger grammar
05:10:31 <phadej> it's still a global choice
05:11:17 <phadej> and one have to think really hard whether hoisting preserves desired behavior
05:11:44 <phadej> TL;DR the should be a paper worth of documentation for that library.
05:14:58 <mniip> you could
05:15:00 <mniip> hoistFreeT
05:15:07 <mniip> ah er
05:15:22 <mniip> right. The gist is it does
05:15:44 <mniip> it's really just a fun little experiment, not intended to be practical
05:16:21 <phadej> so, if beginner asks for a parsing library, can we agreeto say "megaparsec" and leave "but"s to later / blog posts? ;)
05:16:57 <merijn> phadej: You must be new here ;)
05:17:41 <mniip> wait, is that what the original question was
05:17:42 <merijn> Every single time I tell strategically chosen lies for educational reasons someone has to open their big mouth and go "well, actuallly..." while I facepalm
05:17:59 <phadej> mniip: yes: 14:50  esg hi, is parsec still the standard parsing library, or is the current practice to use something else?
05:18:00 <merijn> mniip: The original question was "hey, I'm new, do I still use parsec for writing parsers"
05:18:11 <mniip> oops
05:18:13 <mniip> my bad then
05:20:24 <phadej> (sorry that I assume esg to be a beginner, quite seasoned haskellers do ask what's the parsing lib of the day too)
05:22:09 <esg> phadej: that's ok. i'm a longtime beginner. i've programmed in haskell since around 2002, but seldom enough to not keep up with trends and not become truly competent.
05:22:15 <phadej> (which is https://github.com/AndrasKovacs/setoidtt-proto/tree/256abab736f57bd438c53d5411bb2b23f1f73a39/setoidtt/flatparse if you ask me)
05:25:10 <dminuoso> esg: tl;dr use megaparsec, it's a good default - but know there's other libraries with certain advantages :)
05:27:44 <mniip> phadej, needs more unlifted newtypes
05:27:51 <mniip> (GHC extension of the day)
05:29:11 <esg> dminuoso: after doing a short bit of googling using the names i got here it looks like megaparsec is at least a safe choice. and if it is good enough for idris, it's probably good enough for me.
05:29:49 <esg> thanks all!
05:32:57 <dminuoso> esg: For what its worth, parsers like earley, trifecta or attoparsec as just as battle proven. The issue isn't about "whether it's good enough".
05:33:34 <dminuoso> Two of the larger considerations for parsers is quality of diagnostics on failed parses and performance.
05:34:08 <dminuoso> Compiler input tends to be relatively small, usually.
05:36:30 <dminuoso> There's a history of compiler implementations starting with "easy-to-write" parser styles, then switching to complicated hand-crafted recursive descend parsers later for both maintenance as well as diagnostics reasons.
05:37:43 <esg> dminuoso: no, what i meant was more what you said earlier: a good default choice, even if there might be slightly better choices in different situations.
05:39:16 <Philonous> Is there a list of "canonical" names for common qualified imports? E.g. »Data.Text« => »T« or »Text« Of course I realize that different projects will have different conventions, but I'm thinking maybe there's some convention that has relatively broad consensus?
05:40:46 <dminuoso> Philonous: Not really. Usually for strict/lazy versions, people frequently include one or both in the qualifiers.
05:41:23 <dminuoso> e.g. `import qualified Data.ByteString.Lazy as BSL; import qualified Data.ByteString as SBS` or maybe `import qualified Data.Text.Lazy as TL`
05:41:47 <dminuoso> I'm fairly confident there's no cross-project convention.
05:42:06 <Philonous> I thought I saw some discussion around that on reddit, but I can't seem to find it again
05:42:18 <dminuoso> Philonous: Henning Thielemann has a rather... special... convention too.
05:42:25 <merijn> dminuoso: There's certainly some convetion
05:42:36 <Clint> once in a while you'll come across a library that offers an opinion on how you should import it
05:42:36 <merijn> It's not universal, but it's weird to pretend there's none
05:42:42 <Philonous> Yeah, he seems to like the ML style of imports.
05:42:44 <dminuoso> merijn: There's plenty of conventions.
05:42:49 <Philonous> Which would be fine if haddock could deal with it
05:42:52 <dminuoso> Philonous: Oh is that where it's from?
05:42:57 <dminuoso> That's interesting to know
05:43:15 <Philonous> I don't know if that's where he got it from, but that's where I saw it first. 
05:43:25 <dminuoso> Maybe it was his code there too! ;-)
05:44:09 <ski> it's quite common in the MLs, i think
05:44:15 <Philonous> But actually I don't mean naming modules but rather qualifed import aliases.
05:45:29 <dminuoso> Philonous: Well there's plenty of conventions amongst teams or single developers, but I haven't seen any broadly accepted status quo.
05:45:44 <dminuoso> It differs widely from project to project.
05:45:51 <Philonous> merijn, If there isn't a standard I think there would be value in creating one. 
05:46:03 <dminuoso> A standard is only as good as its adoption.
05:46:12 <dminuoso> You'll have to convince the bulk of hackage. Good luck!
05:46:25 <dminuoso> (Not just convince, but *patch* as well)
05:47:14 <Philonous> Eh, I'm not so sure. Sometimes just having a document that people can point to helps. When tibbe released his style guide people started to coalesce around it just because it was there. 
05:47:57 <Philonous> My goal isn't to convert all the heathens^W^W^W^W get _universal_ adoption
05:48:24 <MarcelineVQ> it helped that it was sane too
05:48:39 <Philonous> True
05:48:44 <dminuoso> Philonous: well why is there no established naming convention on variables (that is the actual names, not how you style them)
05:48:56 <dminuoso> Convention on *names* is going to be a hard one.
05:49:31 <dminuoso> MarcelineVQ: Ontop, it broadly matched how most projects were styled already.
05:49:34 <Philonous> dminuoso, Wait, but there is? i,j,k are indices, k is a constant, in Haskell x and y are elements of a list, xs and ys are tails etc.
05:50:19 <Philonous> Yes, well, any standard on import aliases should start with a survey of what's already done.
05:50:21 <hpc> the kind of mistakes you need a naming convention for are independent of the code being haskell, in my experience
05:50:35 <MarcelineVQ> naming? easy!  snake_case for binders, camelCase for functions and actions. also literally anything else for binders changing every definition
05:50:42 <hpc> single-character names for variables steeped with meaning is a common issue, but you see that from people fresh out of java school too
05:50:55 <dminuoso> MarcelineVQ: I actually like the GHC covention of snake_case for internal identifiers and camelCase for exported ones.
05:51:06 <MarcelineVQ> __internal_identifiers?
05:51:30 <dminuoso> MarcelineVQ: Good lord, you will trick GHC with that one. ;)
05:51:45 <dminuoso> Dunno if you can even turn off the unused variable underscore thingy.
05:51:51 <hpc> __variable_names__ are my least favorite part of python, don't introduce that to haskell
05:52:03 <dminuoso> MarcelineVQ: Rather internal_thing vs externalThing
05:52:06 <dminuoso> Is what I meant
05:52:16 <MarcelineVQ> __actually_im_a_record_field
05:53:20 <MarcelineVQ> where is your __godArglib321cH now?
05:54:05 <Philonous> (How do you run grep over all of github, I wonder) 
05:54:28 <sshine> as someone who isn't employed by GitHub, you mean?
05:54:31 <MarcelineVQ> that's probably a service you can pay for
05:54:39 <Philonous> Yeah
05:54:54 <sshine> I recall from someone working at Google that they had a Google-wide grep that ran in about 10 seconds at the time of me being informed of this. :)
05:55:17 <dminuoso> sshine: That's easy when you have a monolithic mono repo..
05:55:30 <dminuoso> (And use ripgrep)
05:55:31 <sshine> dminuoso, I don't mean grep source code. :-D I meant grep internet. :-D
05:56:13 <sshine> dminuoso, but it's also easy when you control most of the known internet.
05:56:38 <sshine> I think GitHub lets you do GitHub-wide searches via API? but probably not greps.
05:57:54 <dminuoso> That would have to be one might elastic search.
05:58:16 <sshine> ripgrep? ah, this is one of those alternatives like ack. I've used ack for some years now. I see that ripgrep is faster.
05:58:52 <dminuoso> rg is ridiculously fast :)
06:00:25 <Philonous> I'm mostly using ag, strange that there is such a proliferation of code search tools 
06:00:37 <frdg> I'm trying to import a local module from the same project I am currently in. This project was built with Stack. What is strange to me is that my linter recognizes the import statement, yet I am unable to compile the module. When I put the file into my build-depends in try to run `cabal repl`, cabal also does not recognize the module.
06:00:51 <sshine> Philonous, they just kinda work. I mean the only reason I stopped using grep -r was because it was too dumb in some cases.
06:01:30 <sshine> Philonous, most people at my old job used git grep, which is even less of an improvement over gnu grep. and then there was the small group of people who used ack, and I eventually succumbed.
06:02:17 <dminuoso> Philonous: How is it strange? Most of them were invented because alternatives were either slow (in the general case or with regex) or had bad unicode support. ripgrep is pretty much the end of that development.
06:02:18 <sshine> dminuoso, I like that Rust's regexes are actually pushing the state-of-the-art of libraries. there's been so much interesting research and a complete lack of renewal of most popular implementations.
06:02:38 <MarcelineVQ> modules don't go in build-depends, thet go in exposed-modules or other-modules
06:02:50 <sshine> dminuoso, e.g. we have an s// regex bot in one IRC channel, and that feature was made with TCL regex because both PCRE and Perl regex are too powerful to just eval random input online.
06:04:02 <MarcelineVQ> build-depends lists whole packages you depend on, like base, or text, or containers
06:04:28 <sshine> dminuoso, I'd like to see Kleenex in the shape of a Haskell quasi-quoter: https://kleenexlang.org/
06:04:54 <MarcelineVQ> that being said, unable to compile isn't a super clear description, best to link to the actual errors you got
06:05:02 <dminuoso> sshine: Curious to keep reading names you know...
06:05:10 <sshine> dminuoso, huh?
06:06:24 <L29Ah> are there GUI toolkit bindings except gtk that work well with multithreading?
06:06:44 <dminuoso> sshine: When I read Henglein on that, it made me realize that I either know a lot of people, or the Haskell community is really small. Every time I see a package or a paper related to Haskell, I recognize one of their names..
06:07:23 <sshine> dminuoso, it's the same Henglein as in ekmett's discrimination package. :)
06:08:08 <dminuoso> I know.
06:08:17 <sshine> dminuoso, Fritz Henglein is a professor in Copenhagen. I studied with several of the people doing the Kleenex paper. and yeah, Fritz comes up with a lot of interesting stuff once in a while.
06:08:27 <dminuoso> That's sort of what I meant. :)
06:09:12 <frdg> MarcelineVQ: I do not see an exposed-modules or other-modules section of my .cabal file. Maybe because I built the project with `stack build projectname simple`?`Here is the error message from cabal: https://pastebin.com/i5AgjYg5
06:09:14 <sshine> dminuoso, Kleenex is only Haskell-related because it was coded in Haskell, I think. but in spite of that, it produces C code. I'd have liked if it had better Haskell FFI, since the produced C code is super efficient.
06:09:41 <frdg> `stack new projectname simple` actually
06:09:59 <tdammers> sshine: you can always expose your Haskell code to C via Haskell FFI though
06:10:23 <sshine> tdammers, yes! so I'm keeping this idea as a "maybe I'll venture there, but I hope someone else does before I get the time."
06:15:17 <MarcelineVQ> frdg: you can type  stack new blah   without simple to get a better example cabal file to work from, showing a project with a library section and a few starting modules.
06:15:54 <MarcelineVQ> in particular it shows how to have a library section alongside an executable section
06:16:36 <frdg> MarcenlineVQ: This seems to be the issue. I'll make a new project now and just transfer the files. Thanks
06:28:26 <zincy_> If in Servant you have an Env in your monad stack. And in this Env you have a TVar.
06:28:55 <zincy_> Is the TVar field copied for every request or is it shared in memory.
06:29:51 <L29Ah> must be shared memory
06:29:59 <L29Ah> otherwise it would be pointless to keep it as TVar
06:31:45 <Philonous> zincy_, That depends on how you evaluate your monad stack per request. If you create the TVar beforehand and then just pass in that same TVar it will indeed be shared, if you have newTVar as part of your run function then a new TVar will be produced every time 
06:34:35 <zincy_> Philonous: In the first case would that potentially be a performance bottleneck due to the transaction manager having to wait between locks to get access when a lot of threads are concurrently reading?
06:36:11 <Philonous> zincy_, As I understand it STM doesn't use locks but will optimistically run and then retry when when there's a conflict. You might get live-locks, though. 
06:36:48 <Philonous> zincy_, Concurrent reads shouldn't be problematic if you have few writes 
06:37:31 <Philonous> zincy_, I don't have a particularly deep understanding of STM, though, so take what I said with a grain of salt 
06:37:38 <zincy_> ah thanks!
06:41:26 <merijn> zincy_: The STM paper is rather good intro, tbh
06:41:31 <merijn> It should be mentioned in the docs
06:42:32 <merijn> zincy_: In general, for best performance you want short, fine-grained transactions. The optimistic locking implementation especially means that read-only transactions are extremely cheap
06:43:26 <merijn> zincy_: Essentially all transactions optimistically assume the will succeed and only at the very end grab a lock, verify nothing they read has changed and commit (unless something has changed, in which case they restart)
06:44:21 <merijn> zincy_: So fine-grained/short transactions are good, because low likelihood of being invalidated and restarting. Read-only transactions are good (they won't interfere/restart each other)
06:48:41 <ezzieyguywuf> trajafri: that little gloss wrapper might be what I'm looking for, but it may also be too high-level. I dunno I'll have to look. 
06:49:20 <ezzieyguywuf> at the end of the day, I'll have a way to query an arbitrary point on a curve/surface, and I'd like a way to visualize that
07:08:22 <dminuoso> (>.>) :: Monad m => (a -> m b) -> (a -> m b) -> (a -> m b)
07:08:35 <dminuoso> Is there something like this to be found in base via some instance?
07:08:59 <solonarv> what's that supposed to do? f >.> g = \x -> f x >> g x ?
07:09:02 <dminuoso> Right
07:09:18 <Rembane> :t (>=>)
07:09:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:09:31 <Rembane> Almost. 
07:09:32 <solonarv> the first (a -> m b) can actually be generalized since the 'b' isn't used
07:09:42 <dminuoso> % :t liftA2 (>>)
07:09:42 <yahb> dminuoso: (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
07:09:48 <solonarv> yeah, that works
07:10:00 <solonarv> it's also (>>) for (ReaderT a m)
07:10:08 <solonarv> (modulo newtype wrappers)
07:10:36 <solonarv> those are probably the most reasonable solutions, along with just writing it out
07:10:58 <merijn> dminuoso: Isn't that just mappend + Ap? :p
07:12:27 <solonarv> depends on how you want to combine the 'b's
07:12:40 <solonarv> if you want to <> them together then yes
07:13:17 <dminuoso> It just turns out that in my semantic analysis modules I have this pattern everywhere, because I have tons of `Foo -> M ()` things.
07:13:41 <dminuoso> Maybe the solution is actually `ReaderT Foo M ()`
07:16:29 <solonarv> ah! if b ~ () then it does not matter at all if we throw away the first one or combine them with (<>)
07:16:55 <solonarv> perhaps you can write 'instance Semigroup a => Semigroup (M a) where (<>) = liftA2 (<>)' ?
07:17:07 <solonarv> assuming you control M and it doesn't already have a different instance
07:35:01 <ezzieyguywuf> https://github.com/madjestic/Haskell-OpenGL-Tutorial/blob/master/tutorial01/Main.hs#L25 if this doesn't need the return value, why didn't they use `>>` istead of `>>=`?
07:36:13 <dminuoso> ezzieyguywuf: GHC lets you write `do { ... exitWith ExitSuccess; }`
07:36:26 <dminuoso> However, if the monadic return value is anything but (), this will generate a warning on -Wall
07:36:50 <dminuoso> So if you want to explicitly disregard the return value in do-notation to silence the warning, that's what you do
07:36:52 <ezzieyguywuf> ah, so this is to avoid the warning
07:36:55 <dminuoso> Right.
07:37:04 <ezzieyguywuf> thanks for that!
07:37:28 <merijn> I just disable -Wunused-do-binds :p
07:37:36 <MarcelineVQ> looks nicer than    void (exitWith Success)    too 
07:38:12 <merijn> -Wunused-do-binds is, imo, the only utterly useless warning in -Wall
07:38:16 <nshepperd2> the type of exitWith is 'ExitCode -> IO a'
07:38:28 <nshepperd2> shouldn't that just be solved to () without doing anything?
07:38:47 <merijn> nshepperd2: Yeah, so it's double redundant :p
07:40:43 <dminuoso> nshepperd2: Why should it?
07:41:00 <dminuoso> nshepperd2: It's not an ambiguous type, so defaulting rules don't even apply if thats what you were thinking.
07:41:14 <dminuoso> It's a polymorphic value!
07:41:37 <nshepperd2> GLFW.WindowCloseCallback isn't polymorphic
07:42:15 <nshepperd2> the whole '_ <- ...; return ()' rigmarole is redundant, i mean
07:42:19 <dminuoso> nshepperd2: Oh you are saying that exitWith has the wrong type?
07:42:22 <merijn> dminuoso: He's pointing out that the "return ()" means it's type demands "m ()"
07:42:37 <sshine> void ...?
07:42:46 <dminuoso> merijn: That's not the point.
07:42:53 <dminuoso> % :t exitWith
07:42:53 <yahb> dminuoso: ExitCode -> IO a
07:42:54 <merijn> dminuoso: So he's saying that since "exitWith :: ExitCode -> IO a" you could just let 'a' be inferred to () from the outer signature
07:43:02 <dminuoso> merijn: Again, it cant.
07:43:04 <dolio> Anything that's the last line of a `do` block isn't "unused" anyway.
07:43:11 <merijn> dminuoso: It can if you delete "return ()"
07:43:11 <dminuoso> exitWith ExitSuccess >> pure ()
07:43:11 <nshepperd2> that whole do block could have just ended with exitWith ExitSuccess and the type inference would sort it out
07:43:14 <dminuoso> You cant do that inference.
07:43:22 <dminuoso> merijn: sure, then you can.
07:43:27 <merijn> dminuoso: That's his entire point
07:43:30 <dminuoso> Oh. :)
07:43:38 <merijn> dminuoso: That "return ()" and "_ <-" is utterly redundant
07:43:46 <dolio> I think the only reason it's there is because they wanted to write `return ()` at the end.
07:43:50 <dminuoso> merijn: I dont think you can deduce that much from ""shouldn't that be *solved* to ()"
07:44:12 <dminuoso> Because that sounds more like a hint that the type checker could have done more.
07:44:36 <dminuoso> But I guess his statement about `the whole '_ <- ...; return ()' rigmarole is redundant, i mean
07:44:43 <dminuoso> Was enough. Nevermind.
07:46:48 * hackage tdlib-types 0.4.0 - Types and Functions generated from tdlib api spec  https://hackage.haskell.org/package/tdlib-types-0.4.0 (Poscat)
07:47:35 <nshepperd2> i guess i jumped too many steps ahead :p
07:48:15 <nshepperd2> I started by thinking "I'd replace that return () bit with void" then realised the void itself would be redundant
07:48:27 <solonarv> sshine: void :: Functor f => f a -> f (); void x = () <$ x
07:52:17 <Cheery> I'd need some way to represent symmetric monoidal categories in haskell.
07:53:58 <dminuoso> Cheery: Is Control.Category.Monoidal sufficient already?
07:54:28 <dminuoso> (You could impose additional constraints for symmetry on the tensor)
07:55:41 <Cheery> I'm not certain.
07:56:14 <frdg> does anyone here use vim Ale? If so it just broke for me after I uninstalled Airline momentarily and after reverting back my `.vimrc` file back precisely it still is not working. One strange thing though is that it is able to detect import errors but that's it. 
07:57:18 <nil> Monoidal Hask (,) Void -- isn't this wrong? shouldn't it be () instead of Void?
07:58:12 <ezzieyguywuf> this is nice! https://lokathor.gitbooks.io/using-haskell/
07:58:35 <ezzieyguywuf> frdg: try neovim
07:59:11 <ezzieyguywuf> (although I guess vim 8 is supposed to have fixed async problems...)
07:59:36 <nil> nevermind, i was looking at an old version of category-extras
07:59:46 <frdg> ezzieyguywuf: ok I will
08:01:11 <ezzieyguywuf> note: I don't use ALE
08:02:16 <frdg> ezzieguywuf: What do you use? I'm not totally attatched to using ALE but i'm pretty attatched to using Vim?
08:03:16 <dminuoso> frdg: For minimal effort and large benefits, ghcid is a brilliant piece to know.
08:03:17 <justsomeguy> frdg: Ale (and hlint) works fine over here. I think the problem is either with your .vimrc or plugin manager. Maybe try reinstalling ale, first?
08:03:36 <dminuoso> That takes care of compilation at least. :)
08:03:51 <dminuoso> There's some fairly simplistic integrations into (neo)vim or emacs if you like
08:04:22 <frdg> justsomeguy: I've tried every troubleshooting tactic I can think of including unistalling/reinstalling all my `2` plugins
08:05:34 <justsomeguy> Hmm.. bummer.
08:07:18 * hackage ghc-trace-events 0.1.2 - Faster traceEvent and traceMarker, and binary object logging foreventlog  https://hackage.haskell.org/package/ghc-trace-events-0.1.2 (MitsutoshiAoe)
08:15:49 * hackage ghc-trace-events 0.1.2.1 - Faster traceEvent and traceMarker, and binary object logging foreventlog  https://hackage.haskell.org/package/ghc-trace-events-0.1.2.1 (MitsutoshiAoe)
08:23:37 <frdg> After an hour plus of frustration, I learned the problem was with my .cabal file having an incorrect build-depends entry...
08:28:10 <ezzieyguywuf> frdg: I've never gotten around to integrating a linter into my text editor
08:28:13 <ezzieyguywuf> though maybe I should
08:28:27 <ezzieyguywuf> as dminuoso mentions, I do use ghcid
08:29:17 <ezzieyguywuf> frdg: did you try :checkHealth (that might be a neovim specific thing though...)
08:29:29 <frdg> ezzieguywuf: It's amazing IMO. In vim at least its ridiculously easy to set up. 
08:30:03 <ezzieyguywuf> do you have to configure it for each programming language you use?
08:30:21 <frdg> ezziyguywuf: ya
08:31:56 <ezzieyguywuf> I guess you'd need to do that anyways - i.e. find a linter for each language
08:32:06 <ezzieyguywuf> this would just be one extra step: i.e. tell ALE about it.
08:34:31 <frdg> ALE comes with linters for popular languages and you just need to specify which ones you want to use
08:59:48 * hackage tasty-silver 3.1.14 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.14 (PhilippHausmann)
09:42:49 * hackage bzlib 0.5.1.0 - Compression and decompression in the bzip2 format  https://hackage.haskell.org/package/bzlib-0.5.1.0 (VaibhavSagar)
09:45:19 * hackage pandoc-plot 0.6.1.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.6.1.0 (LaurentRDC)
10:05:01 <farmfromjakestat> So I am working on a Project Euler problem: https://projecteuler.net/problem=24 and either my Haskell is wrong or I don't understand the problem. here is my solution: `(sort $ (permutations [0..9])) !! 1000001`
10:05:24 <farmfromjakestat> It runs and seems to look correct, but the output is wrong
10:06:31 <Uniaika> /25/21
10:06:34 <Uniaika> (woops)
10:07:16 <Uniaika> farmfromjakestat: what is the result, and what do you expect?
10:07:50 <farmfromjakestat> The result is 2783915640, but Project Euler says that it is incorrect :/ 
10:08:02 <Shiranai> farmfromjakestat: the first permutation is the 0th in the list, the 2nd permutation is the 1st in the list,... the millionth permutation is the 999999 in the list
10:08:14 <Uniaika> what is the result for 999999? 
10:08:18 <Uniaika> ah, raced :P
10:08:21 <comerijn> farmfromjakestat: tbh, I generally recommend against using Project Euler for practicing with Haskell
10:08:26 <Shiranai> :)  
10:08:40 <farmfromjakestat> Ugh off by one but in the wrong direction 
10:08:45 <Uniaika> comerijn: do you have a suitable replacement?
10:09:03 <comerijn> Project Euler is heavily focussed on, essentially, math tricks and makes you focus on the ugliest bits of Haskell (lots of type conversion between numeric types)
10:09:07 <farmfromjakestat> What makes you not recommend Euler? I have found it decently helpful 
10:09:08 <comerijn> @where exercises
10:09:08 <Shiranai> comerijn: why? Haven't gotten around to doing them yet but wanna push as far asI can
10:09:08 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
10:09:24 <comerijn> Uniaika: Yes, because this is a repeated question/issue ;)
10:09:35 <comerijn> The advent of code puzzles from previous years are also good
10:10:10 <Uniaika> awesome
10:10:50 <Shiranai> nice resource
10:10:55 <comerijn> So basically, Project Euler puzzles aren't very representative of "real" programming problems, which combined with the annoyance of "fromIntegral" everywhere and similar numeric type ugliness just makes it "not great". I mean, it's not terrible and if you like it, by all means go ahead
10:10:56 <ezzieyguywuf> how can I return an IO Int instead of IO ()?
10:11:01 <ezzieyguywuf> and then retrieve that Int in the caller?
10:11:27 <comerijn> ezzieyguywuf: pure, return, <$, fmap const, I'm sure there's a view others ;)
10:11:41 <comerijn> s/view/few
10:12:02 <Shiranai> also silly nomenclature question: the types that belong to the functor typeclass are not the functors per se, right? the functors are the fmap implementations
10:12:15 <ezzieyguywuf> `MyFunc :: IO Int; MyFunc = pure 10` then `i <- MyFunc`?
10:12:46 <wavemode_> a type which has an `instance Functor` is a Functor
10:12:51 <dmj`> Shiranai: `f` in `Functor f` is the functor
10:13:05 <comerijn> Shiranai: If we talk category theory original terminology then a functor is something that maps arrows (functions in Haskell) and object (types in Haskell) to new arrows/object in a new category
10:13:22 <comerijn> Shiranai: So the combination of the type constructor + fmap implementation would be "the functor"
10:13:39 <comerijn> ezzieyguywuf: That works, yes
10:13:49 <comerijn> ezzieyguywuf: You can of course also use >>=
10:14:19 <merijn> Shiranai: In Haskell people usually refer to the typeclass instance specifically (which would mean just fmap)
10:15:48 <biggiepow> Can anyone help me with the basic steps of rendering Picture types onto web browser? I would like to practise modifying images and seeing how they turn out.  
10:15:57 <Shiranai> comerijn: thanks for the explanation but I don't quite see how that works. E.g. take Lists. The objects are lists, the arrows are functions between lists (e.g. concatenate +"a"), what is the functor in this category?
10:16:31 <Cheery> biggiepow: what is Picture ?
10:17:39 <merijn> Shiranai: The object are 'a' and '[a]'
10:18:06 <merijn> Shiranai: The functor consists of the type [] (which maps Haskell types to new Haskell types, i.e. Int to [Int])
10:18:24 <merijn> Shiranai: And fmap, which maps functions 'a -> b' to new functions '[a] -> [b]'
10:19:16 <merijn> Shiranai: So, suppose we have to objects (Haskell types) Int and Bool and one arrow 'even :: Int -> Bool'
10:19:21 <monochrom> In this case it is useful to know you can (should) write like "[] a", "Maybe a". It is the [] part and the Maybe part that are instances of Functor.
10:19:34 <biggiepow> :Cherry SVG images
10:19:43 <biggiepow> Cherry: SVG images
10:19:44 <ezzieyguywuf> comerijn: of course
10:19:49 <ezzieyguywuf> merijn: ^
10:20:03 <merijn> Shiranai: The the functor consisting of [] and fmap maps the object Int to [Int], the object Bool to [Bool] and the function/arrow 'even :: Int -> Bool' to the arrow '[Int] -> [Bool]'
10:20:26 <Shiranai> ahhhh that makes sense now, thanks a lot!
10:22:21 <merijn> Shiranai: Now, in category theory you'd usually just have "a functor" that you can directly use for mapping both objects and types, but that's split apart in Haskell, since we don't have the luxury of handwaving our notation like the mathematicians ;)\
10:22:47 <ph88_> what's the go-to data type to store date and time ?
10:23:12 <merijn> Shiranai: See this diagram: https://bartoszmilewski.files.wordpress.com/2015/01/functor.jpg
10:23:31 <Cale> If we expected more type constructors to be functors, and didn't have the convention that capitalised names at the value level are data constructors, we perhaps could have gone that route, syntactically.
10:23:32 <Cheery> biggiepow: you need to output SVG then.
10:23:54 <merijn> Shiranai: There the functor 'F' maps things from category C to category D. Now, Haskell functors are endofunctors, so they all map things "from category C to category C"
10:24:20 <Cale> There wouldn't be anything too handwavy about e.g. having Maybe at the value level mean fmap
10:24:27 <merijn> Shiranai: (endofunctors simply being the functors where the origin and destination category are the same)
10:24:30 <Cale> It's just... that's not the convention that was chosen :)
10:24:44 <Cale> and it would be super-confusing for []
10:24:52 <Cale> which means an empty list at the term level
10:25:53 <Cale> We probably would not have chosen the punny notation at the type level if we were going that route
10:26:26 <Cale> i.e. the type of lists of values of type a would be written List a, and then we'd be able to have [] be the empty list at the term level, and List would mean fmap
10:27:21 <Cale> However, that kind of thing would be really awkward in another way
10:27:37 <monochrom> We (in Haskell) handwave our notation some other way already. This means an alternative language design would have allowed overloading the same name "F" for both the object map and the arrow map.
10:27:51 <Cale> which is: how should we refer to a functor application at the term level when the functor to be used is not fully determined?
10:28:42 <Cale> Perhaps you'd need the type variable for the functor, say f to introduce a corresponding term variable... which would be kind of wacky
10:28:43 <monochrom> Namely, we already allow both "G" at the type level and "G" at the term level to co-exist.
10:29:13 <monochrom> e.g., "data G = G"
10:29:13 <Cale> (and it doesn't generalise nicely at all... Functor is important, but it's not *this* important)
10:30:24 <monochrom> In the case of [], SML taught us that we could have written "int list" at the type level. They did postfix. But we could do prefix.
10:30:32 <eacameron> (cc phadej) Is there a way to expose the path to ghc to a test running with haskell-ci config on Travis? My test needs to run ghc.
10:31:07 <monochrom> Haskell is already full of these puns like "() :: ()", "(x,y) :: (X, Y)"
10:31:29 <monochrom> To the point of greatly confusing beginners and casual readers, actually.
10:31:47 <dolio> Yeah, I think a lot of those puns are bad ideas.
10:32:38 <dolio> Unless you're going to program in Haskell 98 forever.
10:33:06 <monochrom> Like, I would really love to pitch Haskell as "almost math, and executable". A use case is I would like to show Haskell code to math-apt people and they would understand at once without having learned Haskell properly. Alas, they would understand "(a,b) :: A*B" but not "(a,b) :: (A,B)".
10:33:33 <monochrom> (SML wins this one.)
10:34:33 <monochrom> OTOH SML's "int list" is cute but misguided. It makes English sense but not math prefix convention sense. This is what's wrong with COBOL.
10:34:54 <phadej> oh dear, mathematicians do abuse some symbol for different objects as much
10:34:54 <monochrom> "multiply a by b into c" my ass.
10:35:02 <phadej> F f : F X -> F Y
10:35:17 <phadej> there's no single math "syntax".
10:35:31 <phadej> and in general it's overloaded to undecidable measures
10:36:08 <phadej> (e.g. ambiguous so much that you have to read prose text to understand equations)
10:36:50 <phadej> grep "by abuse of notation" in math papers/textbooks.
10:37:14 <monochrom> I was too harsh on SML's "int list". On second thought, it poses no technical problem, even by the time you want to add "class Functor f where..." to SML.
10:37:51 <phadej> it's a bit unfriendly if you want to have fully dependent language
10:38:08 <monochrom> I.e., if you're self-consistent with "alphabetic type constructors are always postfix" you'll be fine.
10:38:31 <phadej> having postfix type-language is a good way to ensure that type and term language won't unify.
10:38:54 <nshepperd2> the answer is to make term-level function application backwards as well
10:39:24 <monochrom> Actually math notation is to the point it's undecidable even after reading surrounding prose, even if surrounding prose has been formalized for you.
10:39:47 <nshepperd2> (x)f = (x)sin^2
10:40:29 <monochrom> This is because of the expectation on the readers to resolve the ambiguity in "there exists x such that P(x,y) for all y".
10:41:42 <monochrom> There are 4 choices. The expectation is the following. Pick the one choice that is true but not trivially true. Because when a mathematician bothers to communicate at all, it is only because they have something true but not trivially true to communicate.
10:42:07 <monochrom> Therefore resolving ambiguity requires theorem proving, and furthermore, figuring out proof complexity.
10:42:38 <dolio> Your example is too nice, though.
10:42:43 <monochrom> haha
10:43:19 <dolio> I've been hanging out on the category theory discussion 'chat' thing, and there are still many mathematicians there that use "any".
10:43:26 <Cale> My usual expectation is that "late" bindings like that are innermost.
10:43:28 <dolio> In contexts where it's not clear whether it means "forall" or "exists".
10:43:32 <monochrom> \∩/ any
10:43:51 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
10:44:16 <Cale> Many mathematicians don't like that as well though
10:44:34 <Cale> (placing quantifiers after the condition)
10:52:24 <dmwit> Rats, vex.net is down.
10:52:45 <MarcelineVQ> that's sincerely
10:52:50 <monochrom> yeah, was up until a couple minutes ago
10:52:51 <MarcelineVQ> vexing
10:52:54 <monochrom> haha
10:53:41 <monochrom> probably the connectivity kind of down because I can't login to the shell server
10:53:58 <monochrom> (I kind of know that they're different computers)
11:19:19 * hackage tasty-silver 3.1.15 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.15 (PhilippHausmann)
11:26:17 <xe4_> why do I receive the error shown here: https://gist.github.com/xe-4/637b57b06ea1c7bf6611ea98caa50d7d
11:27:32 <merijn> xe4_: You're using map and trying to bind the result with do notation
11:27:42 <wavemode_> xe4_, you want taverse, not map
11:27:44 <merijn> xe4_: But map returns a list and the do block you're in is in IO
11:27:55 <wavemode_> :t traverse
11:27:56 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:28:01 <Cale> Or just mapM
11:28:07 <Cale> But yeah, traverse will do it
11:28:29 <xe4_> that did it
11:28:47 <Cale> Basically, you have a list of IO actions there, where you wanted a single IO action
11:28:53 <xe4_> remove the _x <- map ... and replace it all with traverse x y 
11:29:14 <xe4_> though I suppose that should be traverse_
11:29:23 <Cale> In fact, you might prefer forM_ there, even:
11:29:31 <Cale> forM [1,2,3] $ \x ->
11:29:39 <Cale>   C.writeFile ... (show x)
11:29:51 <xe4_> merijn: what's wrong with using map and binding the result?
11:29:53 <Cale> forM_ rather
11:29:57 <__monty__> Hmm, having trouble understanding imports and instances. I'm importing a module that defines some pretty printing instances. But apparently that doesn't bring the "pretty" instance method into scope?
11:29:58 <Cale> Well, the result of the map is a list
11:30:20 <Cale> So we have a list of IO actions, but we want a single IO action, so we need to glue them together somehow first
11:30:33 <Cale> Let's write that function, since I think it's instructive
11:30:37 <xe4_> Cale: oh, so I could have used "pure" perhaps to lift the list into IO
11:30:45 <Cale> That wouldn't do what you want
11:31:01 <Cale> pure/return make an IO action which does nothing, except to produce the given value as the result
11:31:29 <Cale> In this case, we actually want to write the files, not simply return a list of the actions which would write the files, if we were ever to run them
11:31:45 <Cale> sequence :: [IO a] -> IO [a]
11:31:51 <Cale> sequence [] = ...
11:31:54 <xe4_> confirmed. that did nothing
11:32:19 <Cale> In the case of an empty list, we'll give the action which does nothing, and produces an empty list as its result:
11:32:21 <Cale> sequence [] = return []
11:32:33 <Cale> sequence (x:xs) = ...
11:32:44 <Cale> In the case of a list of actions which isn't empty...
11:32:49 <Cale> sequence (x:xs) = do v <- x; ...
11:32:59 <Cale> first we'll run the first action, getting some result v
11:33:08 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
11:33:21 <Cale> then we'll run the rest of the actions, getting a list of results vs
11:33:27 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:33:42 <Cale> and finally, we'll return a completed list of the results
11:34:02 <Cale> A more general version of this sequence function is already available in the libraries
11:34:04 <Cale> :t sequence
11:34:06 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
11:34:19 * hackage calamity 0.1.14.1 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.1 (nitros12)
11:34:41 <Cale> and in turn, mapM f xs = sequence (map f xs)
11:34:59 <Cale> traverse is a yet-more-general version of mapM
11:35:51 <Cale> forM xs f = mapM f xs  also exists because often the action is longer to specify than the list
11:36:08 <Cale> and that pretty directly corresponds to a for-each loop in most imperative languages
11:36:23 <Cale> xe4_: Make sense?
11:37:16 <Cale> When you write  v <- x  in a do-block, it means "execute the action x, and name its result v", and the do-block as a whole will end up being the same type of action as the action x
11:37:18 <__monty__> You don't need a class constraint when you know a type is an instance, do you?
11:37:26 <Cale> Correct
11:38:25 <Cale> xe4_: So, if the do-block is an IO action, then all the actions we execute inside it had better also be IO actions
11:38:47 <Cale> If the do-block is a list, then the actions executed inside it can also be list
11:38:58 <Cale> "executing" a list just means picking an element from it, in all possible ways:
11:39:15 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:39:17 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:39:38 <__monty__> Hmm, the error goes away if I import "pretty" from the module that defines the class. Is this always necessary?
11:39:57 <xe4_> Cale: you had me up until that last line. let me process that one :)
11:40:28 <Cale> __monty__: You have to import the instance somehow. Even importing nothing from the module that the instance is in ought to work. e.g.  import Foo.Bar ()
11:40:37 <xe4_> Cale: how did lambdabot know you were in the list monad?
11:40:48 <Cale> xe4_: Because the actions in my do-block were lists
11:40:50 <xe4_> because <- [...] I take it
11:41:15 <Cale> and so the do-block as a whole must be a list as well
11:42:11 <Cale> It will use the Monad instance for the list type constructor to determine the implementation of (>>=), which the do-notation desugars into:
11:42:16 <Cale> @undo do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:42:17 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5] >>= \ y -> [6, 7, 8] >>= \ z -> return (x, y, z)
11:42:54 <xe4_> man, that's a weird result
11:42:55 <Cale> A bunch of nested lambdas can be kind of bewildering, which is why this syntax exists.
11:43:03 <Cale> Which result?
11:43:11 <Cale> this? [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:43:34 <Cale> Or the desugaring
11:43:51 <xe4_> I understand why i should use sequence or forM or mapM or traverse and why using pure wouldn't do what I expected and why my original result was wrong
11:44:03 <Cale> cool
11:44:03 <xe4_> I don't understand the [(1,4,6),(1,4,7),(1,4,8),(1,5,6),...
11:44:06 <Cale> ahh, okay
11:44:16 <maerwald>  it's like list comprehension
11:44:32 <Cale> Well, the list monad is a bit funny like that, yeah, it's exactly the same thing as list comprehensions if you're familiar with those
11:44:34 <wavemode_> > [(x,y,z) | x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]]
11:44:36 <lambdabot>  <hint>:1:24: error: parse error on input ‘;’
11:44:43 <wavemode_> > [(x,y,z) | x <- [1,2,3] y <- [4,5] z <- [6,7,8]]
11:44:44 <Cale> xs >>= f is defined as  concat (map f xs)
11:44:45 <lambdabot>  <hint>:1:27: error:
11:44:45 <lambdabot>      parse error on input ‘<-’
11:44:45 <lambdabot>      Perhaps this statement should be within a 'do' block?
11:45:19 <Cale> and so the effect is, for each element of xs, to run the rest of the computation with the function applied to that element
11:45:26 <Cale> and then to concatenate all the resulting lists together
11:45:39 <Cale> So when we have  x <- [1,2,3]  in our do-block
11:45:40 <wavemode_> bah
11:45:44 <wavemode_> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
11:45:46 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:46:03 <xe4_> yeah okay
11:46:07 <Cale> The remainder of the do-block is a function of that x
11:46:09 <xe4_> I'll accept that :) 
11:46:23 <Cale> and we apply it to each of the elements of the list in turn, and concatenate the resulting lists
11:46:34 <xe4_> thanks for addressing my question and introducing a few extra things!
11:46:43 <Cale> no problem! :)
11:47:45 <Cale> (this was mainly to explain why GHC was so confused -- you *were* giving it a list, so the result of your do-block could have been a list, but then the top-level signature said it should be an IO action)
11:48:08 <monochrom> This is what goes wrong when the imperative model "f(x) means call f with param x, complete with the control-flow connotation" is brought to Haskell.
11:49:18 <monochrom> "map f [x,y,z]" totally does not mean "call f now, call f again now, call f for the 3rd time now".
11:49:36 <Cale> well....
11:49:38 <monochrom> It means the mathematical, algebraic, [f x, f y, f z].
11:49:58 <Shiranai> Earlier conversation here taught me that the functor typeclass in haskell is actually just endofunctors; got me wondering if there are some "real" functors in haskell? (I see how I could code one but was wondering if there were some already give)
11:49:59 <monochrom> Therefore, for example, "map print [1,2,3]" causes nothing to happen.
11:50:01 <Cale> I think you could also do this very same thing in a strict imperative language
11:50:35 <Cale> The unusual bit is that evaluating f x doesn't cause any of the effects described by that IO action to occur
11:50:58 <Cale> The weird thing is that there's an IO data type at all
11:51:40 <Cale> and that we're building up this description of what ought to be done, and only executing it at some future itme
11:51:41 <Cale> time*
11:52:45 <Cale> I suppose it would need to be an at-least-somewhat functional programming language to admit anything like IO to exist
11:53:35 <maerwald> Cale: what does that mean
11:53:55 <monochrom> Hence, what goes wrong with bringing an imperative model to a functional world.
11:53:56 <Cale> Well, we won't get very far if we can't have something like (>>=)
11:54:11 <tdammers> I don't think it would have to be functional
11:54:25 <Cale> and if we wanted to implement IO for ourselves in Haskell, we'd end up with data structures that had functions in them
11:54:36 <Cale> for example
11:54:53 <Cale> data MyIO a = Done a | GetChar (Char -> IO a) | PutChar Char (IO a) | ...
11:54:57 <maerwald> Cale: There are at least 2 imperative programming languages that had or have IO
11:54:59 <tdammers> you could very well have an imperative language where the commands you can write all run inside some kind of "sandbox", in which mutation and such is allowed, but no interaction with the outside world, except through the program that we're constructing
11:55:11 <Cale> maerwald: Which ones are you thinking of?
11:55:13 <maerwald> rust had it and mars-lang still has it
11:55:18 <wavemode_> in an imperative language, a set of instructions on how to produce some result, is a subroutine. so `IO` is just `() ->` in such languages
11:55:25 <maerwald> https://mars-lang.appspot.com/
11:55:41 <monochrom> Note: I said model, not language.
11:55:41 <tdammers> maerwald: I think the "IO" we're talking about here is a bit more specific than just "some" notion of reflecting effects in a type system
11:55:48 <Cale> Does it have first class functions?
11:56:26 <Cale> Yeah, I'm talking about having a data type for which evaluation of the values and execution of the actions they describe are two separate things
11:56:35 <monochrom> E.g., if you use a denotation model (but it'd better explain I/O too) on an imperative language, you'll be just fine!
11:57:11 <monochrom> It is the control-flow model that won't port.
11:57:36 <monochrom> This is why I say that programmers (perhaps just imperative programmers) are control freaks.
11:58:10 <Cale> monochrom: They implicitly wrap every function in call/cc
11:58:12 <monochrom> This is another what's wrong with programmers. They have to immediately water down the discussion to languages.
11:58:26 <maerwald> In the end, you also have to understand the implicit control flow in haskell, so you're back to square 1
11:58:27 <Cale> (imperative programmers do)
11:59:05 <tdammers> you could just have an imperative API that allows you to say, "create a variable holding the empty program; now append the 'create variable "a"' instruction; now append to that the 'print value of "a"' instruction; now return the program we just constructed to the caller"
11:59:08 <monochrom> Semantics don't exist. Models don't exist. Specifications don't exist. There are only code and test cases.
11:59:21 <maerwald> mono
11:59:39 <maerwald> monochrom: oops. All those things exist in imperative languages too
11:59:44 <monochrom> "Programming style" exists only to the extent of spacing and naming.
11:59:53 <Cale> tdammers: Yeah, you could eliminate the use of higher-order abstract syntax, which would work
12:00:23 <Cale> tdammers: Then you end up a fun time dealing with resolving variable references at runtime, but yeah.
12:00:29 <monochrom> maerwald: To you and me and enlightened programmers.  Not in the mind of mediocre majority programmers.
12:00:35 <Cale> having*
12:00:50 <tdammers> Cale: I'm more hinting at how you can do it imperatively instead of functionally, i.e., constructing the target program through in-place mutations instead of pure expressions
12:00:59 <monochrom> As another example, look at how they struggle to distinguish between "random" and "non-deterministic".
12:01:00 <Cale> ah, yeah
12:01:11 <maerwald> monochrom: https://www.researchgate.net/publication/221267750_Software_Engineering_with_Formal_Methods_Experiences_with_the_Development_of_a_Storm_Surge_Barrier_Control_System
12:01:24 <monochrom> If you know to talk about semantics and specifications, it's pretty easy to distinguish them.
12:01:50 <maerwald> A success story with formal methods. They used the spec language Z believe and produced C++ code
12:01:54 <tdammers> maerwald: I *knew* this was going to be about the Maeslantkering before even opening the link :D
12:02:03 <maerwald> =)
12:02:06 <maerwald> It's awesome
12:02:10 <tdammers> it is
12:02:15 <tdammers> have you ever been there?
12:02:19 <maerwald> Nope
12:02:22 <tdammers> that thing is INSANE
12:02:25 <maerwald> Does it work? xD
12:02:33 <tdammers> nobody knows XD
12:02:36 <maerwald> loool
12:02:46 <Cale> monochrom: I think that struggle in particular is just a naming thing. A lot of people don't get introduced to the technical sense of "nondeterministic" that NTMs and NFAs use.
12:02:49 <tdammers> I think it was closed twice so far, and only for testing purposes
12:03:41 <monochrom> Also I was open enough to say "specification" not just "formal specification".
12:03:54 <tdammers> but the fun thing about it is that the engineers who designed it came to the conclusion that a fully autonomous computer system would be more reliable than human operators, even if you consider all the possible failure modes of the hardware and software
12:04:09 <__monty__> Cale: That's what I thought. But `import Module.Pretty` (which has my instances) doesn't suffice. I have to also import "pretty" from the module that defines the class.
12:04:30 <maerwald> tdammers: I can imagine in an actual flood case peoples adrenaline would be through the roof
12:04:43 <maerwald> And the only people trained to cope with that is military
12:05:00 <rpep> On filling shoes: Don't try to. Take the responsibilities, roles, and positive querks of the departing person and fill those - often with multiple people. If people are puzzle pieces then you won't ever find one that fits the hole of a missing piece, but you might find a collection of new parts that can add the same value and mesh well with the remaining structure.
12:05:29 <Cale> __monty__: well, you probably have to import that function if you're using it
12:05:51 <monochrom> Cale: NTM and NFA are exactly how you write down a semantics and/or specification to illuminate what you mean by "non-determinism", i.e., you write down the specification for correctness as "there exists a choice sequence that leads to the accept state".
12:06:59 <monochrom> And for randomized algorithms, you write the specification "[given probability distribution of choice sequences] the probability of accept is >= 2/3"
12:09:10 <monochrom> My examples are specification-oriented. If you prefer semantics-oriented, here: NTM and NFA are "every possibility exists, you have a tree of all futures", randomized algorithms are "make choices according to probability"
12:10:24 <maerwald> I think everything will be fine, once we f**cked up a few times more and people realise programming isn't brick-laying, but an engineering science
12:11:42 <monochrom> No, look at Greg Wilson's "programming as a craft" movement that explicitly, honestly, consciously wants to keep programming as brick-laying.
12:11:57 <monochrom> He has my respect because he's honest about it.
12:12:28 <monochrom> Already infinitely better than other programmers who're brick-laying too but want to be called "engineer".
12:14:07 <dolio> Is the goal of the movement to create a list of people you shouldn't hire for anything important?
12:14:12 <monochrom> Well, I was too harsh on Wilson. He is not promoting "all programming is craft". He's promoting "small-scale programming is craft", e.g., you're a physicist and you just want a python script to get some number crunching done.
12:14:18 <maerwald> monochrom: maybe universities are not doing a good enough job about it >:)
12:14:29 <ja> ah, interesting. but aren't there really three kinds of programmers then? academics, brick-layers and engineers?
12:14:53 <ja> hard to call it engineering if it is e.g. category theory, no?
12:15:11 <maerwald> Like... you know. Actually teaching people more about what kind of "layers" (layers of reasoning) code is about
12:15:36 <Cale> There is something a bit fundamentally different about it: civil engineers aren't often faced with weekly changes to the location of the off-ramp that their bridge is meant to line up with.
12:16:17 <phadej> and they don't need to have it down "by yesterday" :)
12:16:20 <phadej> done*
12:16:41 <maerwald> ja: yeah and universities do well producing both brick layers and academics, but not engineers
12:17:47 <maerwald> The few you see in the wild, are just that: wild engineers, hunted by tech corps :p
12:17:57 <phadej> (construction and civil engineering have much more rigid processes, for good and bad)
12:18:44 <xerox_> your discussion reminds me of this passage https://pastebin.com/raw/wA8k2GTV
12:19:11 <tdammers> IMO the fun thing about programming is that it's bricklaying AND engineering AND math AND creative writing
12:19:20 <maerwald> AND madness
12:19:30 <tdammers> that follows from the combination
12:19:54 <maerwald> Like... half of your day you're reading other peoples crazy stuff. I feel more like an investigaro or profiler
12:20:09 <monochrom> heh yeah
12:21:26 <maerwald> Guessing what people meant or what they wanted to do, before they went on writing something that barely resembles the original intention anymore (and the intention was never documented)
12:21:40 * ski . o O ( "The ontology of the lambs" (roughly about the difference between "Technicians","Engineers","Scientists", construed in a certain fashion) by Michael T. Richter (ttmrichter) in 2012-09-17 at <https://web.archive.org/web/20130426040216/http://www.txt.io/t-2hv4m> )
12:25:52 <hakko> I am playing with Semigroup and wanted to write one for cumulative sum
12:26:16 <hakko> in the process I need it to be Applicative too
12:26:28 <koz_> hakko: Could you Gist the code?
12:26:30 <monochrom> You may use the existing Sum wrapper, or you may roll your own.
12:26:41 <koz_> It might give us a point of reference in terms of what precisely you're trying to do.
12:26:46 <koz_> (also, what monochrom said)
12:26:46 <monochrom> No no don't show actual code, let's just talk empty. :)
12:26:51 <koz_> :t empty
12:26:53 <lambdabot> Alternative f => f a
12:26:54 <hakko> So after I've finished I wanted to see if I can derive the Functor and Applicative instances
12:27:01 <koz_> Sure, let's talk about empty, monochrom.
12:27:05 <hakko> and it seems to be hanging
12:27:07 <ski> xerox_ : where's that from ?
12:27:19 <koz_> hakko: By 'derive' you mean 'using DerivingFunctor' or somesuch?
12:27:20 <monochrom> The halting problem is undecidable.
12:27:35 <hakko> DerivingFunctor was slow but still gave a result
12:27:51 <hakko> GenericNewTypeDerive just seems hanged
12:28:05 <koz_> hakko: Yeah, _definitely_ show us what you wrote please.
12:28:11 <koz_> (in a Github Gist if you would)
12:28:46 <hakko> newtype CumulativeSum a = CumulativeSum {getCumulativeSum : [a]} deriving (Show, Functor, Applicative)
12:29:11 <xerox_> ski: an overrated book you should not read, antifragile
12:29:23 <ski> mhm, ok
12:29:28 <koz_> hakko: I am fairly sure that you will not get the Applicative instance you want this way.
12:29:37 <hakko> ok
12:29:40 <koz_> Since the default Applicative that'd GND up is the one for non-determinism.
12:29:40 <ski> hakko : using GND ?
12:29:47 <hakko> newtype CumulativeSum a = CumulativeSum {getCumulativeSum : [a]} deriving (Show, Functor)
12:29:47 <koz_> Whereas what I assume you want isn't that?
12:29:56 <hakko> this hanged too
12:30:14 <hakko> I have already written the instances by hand, just wanted to see
12:30:25 <ski> please show the instances ?
12:30:40 <hakko> a moment
12:30:57 <hakko> https://repl.it/@ylou/GenTreeTraverse
12:31:52 * ski can't find a raw link
12:32:25 <hakko> let me put it in gist too, a moment
12:32:28 <koz_> That Applicative is for non-determinism.
12:32:33 <koz_> Are you _sure_ that's what you want?
12:32:34 <dmwit> What hangs?
12:33:08 <hakko> https://gist.github.com/louy2/23009c481663df4e2f48da58de489306
12:33:21 <hakko> The Applicative I am not sure
12:33:34 <hakko> the derivation hangs
12:33:47 <koz_> hakko: If I understand right, CumulativeSum [1, 2, 3] means 'I want you to sum up 1, 2, and 3'?
12:34:19 <hakko> cumulative sum, so it means [1, 3, 6]
12:34:55 <dmwit> hakko: Could not reproduce. After fixing GeneralizedNewTypeDerive -> GeneralizedNewtypeDeriving (case of Type->type, ending of Derive->Deriving), it loads fine for me.
12:34:56 <koz_> OK, so what should happen when I do 'liftA2 (*) (CumulativeSum [1, 3, 6]) (pure 2)'?  
12:35:11 <dmwit> (i.e. derivation completes)
12:35:16 <koz_> (not 'what the code says' - what your _brain_ says)
12:35:19 <hakko> lol maybe that's why
12:35:21 <koz_> (like, what should the meaning of this be?)
12:35:27 <ezzieyguywuf> hah! I drew a triangle!
12:35:34 <koz_> ezzieyguywuf: :partyhat:
12:35:45 <dmwit> (`main` also completes)
12:35:46 <ezzieyguywuf> ^_^
12:35:50 <ski> hakko : what did you try, that made it hang ?
12:36:50 <hakko> maybe the misspelling was the reason
12:37:08 <ski> koz_ : `CumulativeSum [1, 2, 3]' means that the cumulative sum, seen so far, is, successively, `1',`2',`3', i think
12:37:25 <koz_> ski: OK, makes sense.
12:37:26 <hakko> still thinking about koz_'s question
12:37:37 <dmwit> hakko: Just so you know, traditionally "hangs" means "takes a long time, maybe forever"; not "finishes immediately but prints an error".
12:37:44 <koz_> hakko: My point is that just deriving till something compiles is usually not a good strategy for things like Applicative.
12:37:49 <ski> (so the last element is the final sum, for what we're currently considering. at least that's what i understand from the `Semigroup' instance)
12:38:00 <koz_> _Best_-case scenario is 'you'll get something compiling, but probably not what you wanted'.
12:40:58 <ski> hakko : btw, i'd rather see some pattern-matching on `CumulativeSum', rather than using `getCumulativeSum' to extract the list every time
12:41:14 <maerwald> 3
12:42:16 <__monty__> I need/want to interpolate record fields into a user-specified template string. Do any libraries stand out? Otherwise I'll probably cobble something together with dhall.
12:42:47 * ski would still like to know what the `Applicative' instance is intended to do, e.g. what koz_'s example should result in
12:43:12 * koz_ would also love to know that.
12:43:14 <hakko> ok, `liftA2 (*) ((CumulativeSum 1) <> (CumulativeSum 2) <> (Cumulative 3)) (pure 2) = (Cumulative 2) <> (Cumulative 4) <> (Cumulative 6)` I think
12:43:29 <koz_> hakko: Yeah, your Applicative does nothing of the kind.
12:43:46 <koz_> Or rather, it doesn't do that if we go any further.
12:44:16 <koz_> How about this? 'liftA2 (*) (CumulativeSum [1, 2, 3]) (CumulativeSum [5, 10])'?
12:44:17 <ski> `CumulativeSum' smells like it wants to be something `Writer'esque, i think
12:49:49 <ski> `Monoid' : `Semigroup' :: `Alternative' :: ?
12:50:01 <hakko> i can't tell if it's just repl.it that it was slow lol
12:50:19 <hakko> I am curious what is the current result of that example
12:50:54 * ski is more curious about the intended result
12:51:58 <ski> (but koz_'s last example will, with the current instance you showed, give `CumulativeSum' of a list with six elements, fyi)
12:52:47 <ski> hakko : hm, also, why do you need an `Applicative' instance ?
12:52:49 <hakko> ah yeah, I have seen it
12:53:12 <hakko> just for `pure` honestly. anything better I should use?
12:53:34 <ski> hah .. yea, i was thinking that second `preorder' looked a bit fishy
12:54:12 <ski> (that's also why i was wondering what the `empty'-less version of `Alternative' was)
12:54:57 <ski> i guess maybe you could use `Pointed' ?
12:55:27 <hakko> oh cool
12:56:02 <hakko> oh sad it's not base
12:57:01 <ski> yea
12:57:05 <ski> @hackage pointed
12:57:05 <lambdabot> https://hackage.haskell.org/package/pointed
12:57:59 <solonarv> ski: Alt in semigroupoids, IIRC
13:00:55 <ski> solonarv : nice, ty !
13:03:06 <hakko> yeah Writer feels like a better match
13:26:06 <kaol> I wish Data.Either had something like joinEither :: (b -> c) -> Either c (Either b a) -> Either c a
13:26:16 <hakko> wait otoh, i didn't really care much about the Applicative part as long as it followed the laws
13:27:13 <hakko> which is why I delegated to list
13:32:32 <solonarv> % :t \f -> (>>= lmap @(Either _) f)
13:32:32 <yahb> solonarv: ; <interactive>:1:19: error:; * Expected kind `* -> * -> *', but `Either _' has kind `* -> *'; * In the type `(Either _)'; In the second argument of `(>>=)', namely `lmap @(Either _) f'; In the expression: (>>= lmap @(Either _) f)
13:32:41 <solonarv> % :t \f -> (>>= lmap @Either f)
13:32:41 <yahb> solonarv: ; <interactive>:1:12: error:; * No instance for (Profunctor Either) arising from a use of `lmap'; * In the second argument of `(>>=)', namely `lmap @Either f'; In the expression: (>>= lmap @Either f); In the expression: \ f -> (>>= lmap @Either f)
13:32:52 <solonarv> % :t \f -> (>>= Data.Bifunctor.first @Either f)
13:32:52 <yahb> solonarv: (a -> b1) -> Either b1 (Either a b2) -> Either b1 b2
13:33:10 <solonarv> kaol: that should work
13:34:07 <kaol> It's not exactly hard to roll my own.
14:06:19 * hackage leb128-cereal 1.1 - LEB128 and SLEB128 encoding  https://hackage.haskell.org/package/leb128-cereal-1.1 (JoachimBreitner)
14:07:19 * hackage hsendxmpp 0.1.2.2 - sendxmpp clone, sending XMPP messages via CLI  https://hackage.haskell.org/package/hsendxmpp-0.1.2.2 (SergeyAlirzaev)
14:08:49 * hackage aeson-iproute 0.1.3 - Aeson instances for iproute types  https://hackage.haskell.org/package/aeson-iproute-0.1.3 (sickmind)
14:19:48 * hackage pava 0.1.0.0 - Greatest convex majorants and least concave minorants  https://hackage.haskell.org/package/pava-0.1.0.0 (dschrempf)
14:26:49 * hackage smuggler2 0.3.3.2 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.3.2 (jrp)
14:28:25 <srid> type family QueryActualRes r
14:28:25 <srid> type MyType = DSum Query QueryActualRes
14:28:26 <srid> ^^ This is not possible, unfortunately.
14:28:34 <srid> Type famillies can't be used as first class higher kinded types?
14:32:38 <solonarv> nope.
14:33:23 <solonarv> in current GHC, not at all; there is some work on enabling this, but it's not ready yet
14:34:01 <solonarv> you can work around this with something like 'newtype QueryActualRes__ r = QueryActualRes__ (QueryActualRes r)'
15:01:19 <koz_> How does an AffineTraversal relate to a Lens targeting a (Maybe a)?
15:01:39 <koz_> Maybe I'm missing something, but 'Lens' s (Maybe a)' and 'AffineTraversal' s a' look awful similar.
15:03:41 <Pat> Hello everyone. I'm trying to solve an ergonomics problem, rather than some fundamental technical problem. I want to define a function `f` that operates on three distinct types, say `data A`, `data B`, and `data C`. I can use type classes to do this, but my problem is that at call sites the compiler requires too many type annotations to guide type inference. Is there an established method of accomplishing this 
15:03:42 <Pat> goal?
15:08:52 <solonarv> koz_: with Lens' s (Maybe a) you can change whether the value is there or not
15:08:59 <solonarv> you can't do that with an AffineTraversal
15:09:02 <koz_> Ah, I see.
15:09:19 <koz_> So AffineTraversals can only affect the value if present, not its presence or absence?
15:09:22 <dwt> Pat: can you show an example of how type classes lead to awkward call sites?
15:09:46 <Pat> Sure, I'll make a paste, just a few
15:10:01 <solonarv> koz_: yes, just like every other (lawful) optic
15:10:22 <koz_> OK, that clarifies a lot, thanks.
15:10:53 <solonarv> (and of course if you have a Lens' s (Maybe a) you can turn it into an AffineTraversal' s a by composing with _Just or similar)
15:11:00 <solonarv> (but you can't go back)
15:11:05 <koz_> Yeah, that makes sense.
15:12:19 * hackage shakebook 0.5.0.0 - Shake-based technical documentation generator; HTML & PDF  https://hackage.haskell.org/package/shakebook-0.5.0.0 (locallycompact)
15:18:07 <Pat> I think https://gist.github.com/prsteele/7c17eb5c85ac416cfb89395d7ec28ae8 demonstrates my problem
15:21:47 <solonarv> Pat: right. the problem here is that GHC cannot pick an instance for 'As a b' without knowing *both* what a is and what b is
15:22:06 <solonarv> my recommendation is to just ditch this typeclass entirely, it doesn't seem to be doing anything useful.
15:22:54 <Pat> Yup, I agree that as-written this is entirely ambiguous. And you're right, this type class accomplishes nothing beyond trying to simplify my API. As an extreme example, I could solve this using template haskell, but I have no interest in doing so
15:24:39 <Pat> Put another way, I know how to define e.g. `.+`, `.++`, `.+++`, etc, and make my programs compile without error. I'm just trying to avoid having the user need to pick from these
15:25:16 <Pat> I think I'm trying to subvert the open-world assumption. Not from a safety perspective, but from a helping-the-compiler perspective
15:26:30 <dwt> pat: thanks. what solonarv said - I don't exactly see the utility of As given the example.
15:26:41 <Pat> In this *particular* example I'd be fine using `+`, `.+`, `+.`, and `.+.` to handle the four cases (int int, int var, var int, var var) but in reality I have three types, so it would be 8 possibilities
15:27:04 <solonarv> my recommendation is to just write functions like 'var :: String -> Expr ???', 'int :: Int -> Expr ???'
15:27:12 <dwt> or, better put, I can't quite follow what the goal is. are a and b in Expr only intended to ever be Int or Var?
15:27:20 <solonarv> so your example ends up as 'int 1 + var "x" + var "y"'
15:27:34 <solonarv> (names subject to change of course)
15:28:31 <Pat> My goal is to make something similar to "1 + 2 * x + 3 * y <= 2" evaluate to a rich inequality object. I can do this by exactly what you said, solonarv, but I was hoping to find a clever trick to avoid needing those extra functions
15:28:41 <Pat> this is purely a cosmetic API issue
15:29:37 <Pat> (I'm modeling linear programs, and would love to have an API that doesn't look horrid compared to the alternatives, which typically look very much like pure math)
15:30:33 <solonarv> well, you can write a Num instance; that'll get you numeric literals as well as +, -, *
15:32:08 <Pat> I think that just kicks the problem back, though --- I'd have *3* Num instances, the built-in one for Int, one for Var, and one for Expr, for example. It sounds like the most reasonable course of action is finding some clever short names for functions to convert things to Expr as quickly as possible
15:32:23 <Pat> thanks dwt, solonarv
15:32:26 <dsal> 3 sounds like a small number.
15:32:45 <Rembane> Pat: Are the Num instances trivial? 
15:32:48 <Pat> it's 2^3 interactions
15:33:02 <dwt> you might consider a single expression type, with data constructors for operations - in short, you need to build an abstract syntax tree for the "language" you want to model
15:33:04 <dwt> paste incoming
15:33:15 <solonarv> yes, what dwt said
15:33:25 <Pat> that also sounds reasonable
15:33:44 <dsal> In general, you have to be talking about the same time when doing Num operations.
15:33:48 <dsal> :t (+)
15:33:49 <lambdabot> Num a => a -> a -> a
15:33:53 <Pat> Rembane: yes, if I make them non-law-abiding
15:33:55 <dsal> er, same type.
15:33:59 <dwt> Pat: https://gist.github.com/derrickturk/6c19e2d900672a32927b026a771eca70
15:34:05 <Rembane> Pat: Got it 
15:34:25 <dwt> Pat: you could even implement Num for Expr, turning (+) into (:+:) and so on
15:34:30 <Pat> there's no sane division for the general case, e.g. (1 + x) / (2 + x) is no longer something I want to model
15:34:55 <solonarv> fortunately, Num doesn't include (/), so you don't have to worry about that
15:35:09 <Pat> I want it for floats though :)
15:35:10 <dwt> Pat: I've written the "lower to a sum and a combined list of integers" as an "evaluation" function - I'm sure your real case is more complicated than the example, but in general you can think of your interesting operations as tree transformations (folds, etc)
15:35:31 <Pat> but yes, I could probably get somewhere with Num. I'm not worried about using alternate symbols, though
15:35:52 <dwt> Pat: you can also get fancy with GADTs, if you need the type of a transformation to somehow depend on the expression's type
15:36:06 <Pat> dwt: I was about to say "I can probably enforce some things with GADTs"
15:36:34 <Pat> they do --- Expr * Expr will be forbidden, but Num a => a * Expr is fine. (Linear expressions)
15:37:49 <Pat> I was playing around with closed type families, but that seems just to allow you to prevent people from defining non-law-abiding types, but doesn't seem to help guide type inference enough. I might have just been using them incorrectly, though, and don't have a fast demo for what I tried
15:37:52 <solonarv> ah, once again we are bitten by Num's all-encompassingness
15:38:19 <dwt> Num is kind of annoying that way
15:38:26 <Pat> ya, I'm willing to use alternate operators so I can define group and ring-style operations separately
15:39:31 <solonarv> I can feel another rant coming, but I don't wannto 
15:40:22 <Pat> I think my issue really boils down to wanting to circumvent the open-world assumption in a very limited case
15:40:54 <Pat> which is ordinarily a horrible idea, but whenver I start trying to write library-style code and not application-style code I start wanting it
15:41:05 <sm[m]> ooh, I really dig the rainbow logo at https://dixonary.co.uk/blog/haskell/pain/ . What a refresher for the eyes
15:41:15 <solonarv> well, you can put functional dependencies on your As typeclass (or use an associated type family), or write fancy instances
15:41:32 <solonarv> but 'class As a b where as :: a -> b' is just way too general to work
15:41:46 <Pat> I don't think that helps inference --- yes, I agree
15:42:12 <Pat> without stopping me from writing what I want, at least. Again, just cosmetic, not a problem to write a little bit more
15:42:30 <solonarv> those things do help inference. with 'class As a b | a -> b', GHC can pick an instance based on a alone and use that to figure out what b should be
15:43:19 <Pat> it was the "without stopping" me bit --- a good example would be doing this for the Int case. There's quite a few instances I want like `instance As Int something`
15:43:41 <Pat> in this case the right-hand `Expr` type is *already* an associated data type...
15:43:56 <Pat> (based on what solver backend is being used)
15:44:40 <ski> (`a -> b' is violated by the instances in the original paste though. but `b -> a' isn't ..)
15:44:55 <Pat> ski: yes, but it is in my actual example.
15:45:20 <Pat> ski: I take that back, I have three instances all targeting the same b
15:45:22 <ski> sm[m] : too few colors
15:46:05 <Pat> `As Int (Expr Int Var)`, `As Var (Expr Int Var)`, `As (Expr Int Var) (Expr Int Var)`, in this case
15:46:18 <sm[m]> huh what's missing.. indigo ?
15:46:48 <Pat> thanks everyone, though, I'm more confident I'm not missing some obvious trick, so I can get back to actually implementing features rather than getting hung up on the API
15:46:59 <sm[m]> the top of the equals could be that maybe
15:47:13 <ski> Pat : er, sorry, got the direction mixed up
15:47:25 <ski> sm[m] : i guess
15:50:03 <sm[m]> PS since I shared that link, here's the discussion: https://news.ycombinator.com/item?id=23454352
16:39:42 <ezzieyguywuf> how come this doesn't have any documentation? https://hackage.haskell.org/package/GLFW-b
16:39:53 <ezzieyguywuf> do I just use glfw documentation and assume it's a 1-to-1 transfer?
16:41:28 <wavemode_> go back a few versions: https://hackage.haskell.org/package/GLFW-b-3.2.1.0
16:43:51 <ezzieyguywuf> wavemode_: nice one thanks!
16:43:57 <ezzieyguywuf> why'd they stop shipping the documentation though?
16:44:34 <ezzieyguywuf> Also (and probably I don't really need to care about this...) why does, say, this (https://hackage.haskell.org/package/GLFW-b-3.2.1.0
16:44:53 <ezzieyguywuf> ) function take a 'Maybe KeyCallback' instead of just a KeyCallback? as a parameter that is
16:47:24 <koz_> Suppose I have a type Foo, and another type Bar consisting of precisely four Foos. Their positions matter (think of it as a fixed-length vector). What's an appropriate optic to provide people to mess with it as a collection?
16:48:34 <solonarv> ezzieyguywuf: that Maybe probably mirrors the fact that you're dealing with a pointer on the C side, which can be null
16:49:09 <wavemode_> hackage documentation is automatically generated from your code's comments. I'm not sure why it stopped there. perhaps at the time they uploaded those versions, the docgen was disabled due to server load (I know it's happened before)
16:49:10 <solonarv> koz_: hm, maybe you could give it instance for Field1, Field2, Field3, Field4 ?
16:49:23 <koz_> solonarv: Wait, what are those?
16:49:30 <solonarv> those are the classes lens uses for the _1, _2, ... lenses into tuples
16:49:41 <koz_> solonarv: Does optics-core have an analogue?
16:49:49 <solonarv> I have no idea!
16:50:17 <solonarv> yup, they appear to be there
16:50:31 <koz_> Yes, up to 9.
16:50:38 <koz_> That's perfect.
16:50:40 <koz_> Thanks!
16:50:52 <solonarv> looks like they even have sensible default definitions in terms of Generic
16:50:57 <ezzieyguywuf> solonarv: I still don't understand. For example, KeyCallback is a type alias (https://hackage.haskell.org/package/GLFW-b-3.2.1.0/docs/Graphics-UI-GLFW.html#t:KeyCallback), I still don't see how that's related to a C-pointer
16:51:11 <ezzieyguywuf> it's just a function that I define normally with that exact call signature....
16:51:12 <ezzieyguywuf> ah wait.
16:51:21 <ezzieyguywuf> I guess I'm welcome to define it with a different call signature
16:51:23 <koz_> Yeah, that's just a name for that function.
16:51:30 <koz_> 'type' is an alias.
16:51:32 <ezzieyguywuf> in which case the Maybe probably turns into a Nothing in the implementation
16:51:53 <koz_> So you can basically assume that anywhere you see 'KeyCallback', you can paste in 'Window -> Key -> Int -> KeyState -> ModifierKeys -> IO ()'.
16:51:59 <koz_> It's a notational shorthand.
16:52:16 <sm[m]> ezzieyguywuf: or they made a change that breaks haddock, and didn't notice
16:52:17 <sm[m]> worth a bug report
16:52:27 <ezzieyguywuf> sm[m]: where does one report a bug?
16:52:46 <sm[m]> start at the hackage page, there should be an issue tracker link
16:53:07 <sm[m]> if not, use the source repo link
16:53:27 <ezzieyguywuf> hah, under status "All reported builds failed as of 2019-10-20"
16:53:45 <sm[m]> you can't click that one alas. Tip: copy all except "git://", paste into browser bar
16:53:57 <ezzieyguywuf> source repo doesn't seem to work
16:54:02 <ezzieyguywuf> ah
16:54:30 <sm[m]> and this repo doesn't have issue tracker enabled. So you can sent a pull request, or email the package maintainer
16:55:03 <sm[m]> (s)
16:55:24 <ezzieyguywuf> I'll just open an issue on github, see what happens
16:55:25 <sm[m]> or even the uploader.. not sure why those are different
16:56:27 <sm[m]> oh I'm blind, the issue tracker is right there. I very often get confused between github's two link bars.
16:57:07 <ezzieyguywuf> sm[m]: it's on the hackage page?
16:57:24 <wavemode_> passing in a null function pointer for glfwSetKeyCallback removes the currently set callback. so that function is using Nothing for the same functionality
16:57:26 <sm[m]> you could ask/submit a patch to fix their hackage issue tracker link, and add a changelog too, if you liked
16:57:36 <ezzieyguywuf> oh github. Yea my eyes always get confused too
16:57:37 <ezzieyguywuf> poor design
16:58:01 <ezzieyguywuf> wavemode_: hey thanks for figuring that out!
16:58:20 <hpc> sm[m]: it doesn't help that some stuff is legitimately missing, like the ability to do compares
16:58:29 <hpc> you just have to memorize the url for it
16:58:38 <sm[m]> that too
16:58:49 * sm[m] thinks that haddock should never fail to produce docs
17:01:26 <sm[m]> by default, at least
17:01:46 <hpc> agreed
17:02:05 <hpc> well, almost
17:02:06 <sm[m]> and hackage should make git: hyperlinks clickable
17:02:09 <wavemode_> well hackage has to install your package to generate docs for it
17:02:19 <hpc> it should take the most truly horrendous of syntax errors to make it crap out, at least
17:02:21 <monochrom> "how to turn failure into a list of successes"
17:02:35 <sm[m]> wavemode_: I'm talking about haddock, which hackage or you can use
17:04:01 <sm[m]> ie one bit of obscure syntax it doesn't like shouldn't cause it to completely give up
17:04:02 <dolio> What should it have produced in this scenario?
17:04:51 <sm[m]> it could show a warning in place of that item's doc
17:05:12 <sm[m]> or omit it
17:05:48 <sm[m]> it doesn't help that it's easy to break it, and very time consuming to test it
17:06:46 <dolio> What item?
17:07:03 <sm[m]> the function or type which has the malformed haddock comment
17:07:05 <ski> @type _0
17:07:09 <lambdabot> error:
17:07:09 <lambdabot>     • Found hole: _0 :: t
17:07:09 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
17:07:20 <dolio> The build log says that there are a bunch of C libraries missing.
17:07:31 <ski> @kind Field0
17:07:33 <lambdabot> error:
17:07:33 <lambdabot>     Not in scope: type constructor or class ‘Field0’
17:07:33 <lambdabot>     Perhaps you meant one of these:
17:07:50 <sm[m]> urgh well that's a more serious problem then, agreed
17:09:35 <sm[m]> this also should just not be allowed to happen, but I don't have a crackpot solution ready
17:10:29 <ezzieyguywuf> i also agree
17:11:22 <wavemode_> the weird thing is, GLFW-b's build is failing due to bindings-DSL failing to install. but bindings-DSL's own build is passing
17:11:31 <sm[m]> dolio: where did you click to see that C libs are missing ?
17:11:37 <fog> does anyone know if the types of the constructors of Pipes - or the underlying datatype Proxy, being a "machine" (returning an updated version of themselves, including this update function possibly being modified) is nesacarry for them to be monad transformers?
17:11:50 <dolio> I clicked on the link to the hackage build log.
17:12:14 <fog> wavemode_: i had to switch to SDL a while back, i dont think the haskell openGL stuff is working atm
17:12:25 <sm[m]> Status -> Docs available -> [build log] ?
17:13:05 <sm[m]> ack, I'm viewing the old version. Thanks !
17:13:06 <ezzieyguywuf> fog: which haskel openGL stuff? 
17:13:15 <fog> any of it
17:13:29 <fog> well, im getting a Glut init error
17:13:33 <ezzieyguywuf> fog: I've succesfully used GLFW-b to do a haskell opengl stuff today
17:13:34 <fog> so maybe just that via glut
17:13:55 <ezzieyguywuf> yea, I think glfw and glut are different attempts at the same thing
17:14:21 <fog> ah, that would explain it
17:14:34 <fog> so, is that the advised rout to GL now?
17:14:53 <ezzieyguywuf> *shrug* from what I understand, the GL stuff is entirely independant of the window-manager stuff
17:15:04 <fog> ?
17:15:08 <ezzieyguywuf> glfw just makes a window and a 'context' (which is an openGL thing)
17:15:28 <ezzieyguywuf> fog: are you sure you have glut installed?
17:15:32 <fog> right, but if glut isnt working, and glfw is...
17:15:41 <fog> whats that got to do with windows managers?
17:15:43 <ezzieyguywuf> fog: I haven't tried glut on my computer
17:16:01 <fog> im guessing your not developing that library?
17:16:19 <ezzieyguywuf> i'm not developing neither glut nor glfw, no
17:16:35 <fog> yeah, it was more a question for those that are
17:16:58 <ezzieyguywuf> ah, sorry.
17:17:02 <fog> idk if there was something fundamentally broken about glut... 
17:17:27 <fog> i figure the haskell bindings became bit-rotten when there was some change to the C libs
17:17:41 <fog> and for whatever reason, the haskell port hasnt been able to keep up with that
17:18:13 <fog> pretty anoying having to change libs, 
17:18:38 <fog> i dont know if even with stack it would be a problem, or if the resolver would be able to use the previous working dependencies 
17:18:39 <wavemode_> glut doesn't exactly have a rapid release cycle :p
17:18:47 <fog> idk why it broke
17:19:10 <ezzieyguywuf> fog: is stack supposed to precisely solve this sort of issue?
17:19:22 <ezzieyguywuf> i.e. build it once with a working set of dependencies, build it forever the same way?
17:19:25 <fog> but, it motivated relying on a very small subset of common interface that both SDL and OpenGL libs could provide
17:19:34 <fog> like, some backpack or class based interface
17:19:58 <sm[m]> fog it's probably important to have the right version of GLUT/GL C libs installed that match the haskell lib. 
17:20:14 <fog> ezzieyguywuf: yeah, that was the question, idk if it would be able to do that also for the stuff outside of the haskell ecosystem
17:20:19 <fog> maybe thats what nix is for
17:20:32 <fog> anyway, if i had stuck to pure haskell none of that would be a problem
17:20:41 <fog> but thats not an option for graphics stuff it seems
17:21:31 <fog> sm[m], hmm your right, it might just be that the previous build instructions were at some point no longer the correct stratergy for gathering the workind dependencies
17:21:33 <ezzieyguywuf> I'm still not understanding your problem: can you compile and run a glut program in c (or c++)?
17:21:44 <fog> eh?
17:21:47 <fog> why ask that?
17:22:00 <ezzieyguywuf> because the haskell-glut stuff just uses the same library
17:22:04 <ezzieyguywuf> with a haskell interface for it
17:22:07 <ezzieyguywuf> (I believe)
17:22:10 <fog> i mean, no, i couldnt, but thats just because i cant write c
17:22:48 <ezzieyguywuf> it would be _a_ way to troubleshoot your issue - if it doesn't work in C then the problem is not the haskell bindings but rather the glut library you have installed
17:22:58 <fog> i presume that the opengl or glut people wouldnt have made a relase that didnt work with visual studio, or whatever is the industry standard 
17:23:02 <sm[m]> I've built haskell opengl/glut things many times without trouble. Check their version recommendations/package publish date carefully
17:23:28 <fog> yeah, im pretty sure opengl and glut still work with c! i dont think i need to check that
17:24:02 <fog> well, i have no way of telling which version used to work
17:24:26 <fog> i just have code that used to compile, and a way of installing glut with haskell that used to work
17:24:46 <fog> well, it still compiles, it just throws a "glut init error" at runtime
17:24:58 <fog> quite frustrating 
17:25:33 <sm[m]> I understand the frustration, but used to work typically means nothing in haskell land - especially when mixing haskell and C
17:25:38 <fog> but yeah, with a small set of useful features, drawing circles, triangles, pixles, then i managed to port to SDL. i wonder if the same thing can be done for this GLFW
17:26:08 <sm[m]> I would guess either your GL or the haskell libs got upgraded at some point
17:26:20 <ezzieyguywuf> fog: SDL has openGL context I believe
17:26:21 <fog> i know it sucks having to use only a subset of features, or maintain a larger set of features yourself
17:26:42 <fog> but if it allows several backends to be used, it might not be a bad idea 
17:26:52 <fog> especially if they are going to randomly stop working
17:27:26 <sm[m]> can you build the gloss package ? That'd be the best supported haskell GL thing
17:27:29 <fog> ezzieyguywuf: yeah, i meant more, just using pixles directly, or some greatly reduced interface
17:28:07 <fog> sm[m]: i could probably try harder to get it to work - but i just rage quit and used SDL instead
17:29:15 <sm[m]> alrighty. Glad you got that working. Traditionally it has been harder than opengl
17:29:37 <sm[m]> fltkhs is another worth checking out
17:30:08 <sm[m]> I believe it comes with everything included
17:30:27 <fog> yeah, that was why i was asking, a bunch of viable ways to push pixles and simple primatives, as alternative backends to this bare bones API would help it not go down
17:31:44 <fog> it feels like reinventing the wheel, but for very simple applications (the old project was a "molecule viewer" with no real need for fancy shading or anything) it seems like a good layer of defence against bitrot
17:32:14 <fog> i was making applications at the time, and not being able to show my code working a few days before a meeting was bad
17:32:48 <fog> actually, saying that, is there a way to display pixels from pure haskell?
17:33:11 <fog> like, with the same kind of direct C access as the mallocation for haskell types uses?
17:34:03 <sm[m]> fog, I'm no expert but I'm pretty sure not; you need to talk to some graphics layer
17:34:05 <fog> sm[m] yeah, i found a good walkthrough, but i cant remember which it was. if i get it working again ill make a note for future reference 
17:34:48 <sm[m]> or for low-res things you can plot to the terminal
17:35:02 <fog> hmm?
17:35:30 <fog> idk why its so difficult to just directly access the pixels of the hardware directly
17:35:44 <fog> what do you mean, plot to the terminal?
17:36:03 <sm[m]> because of the diversity of modern hardware, and the number of things that want to talk to that hardware all at once
17:37:38 <fog> ah fair, as a security precaution that makes sense
17:37:40 <sm[m]> I mean, you can show a low-res chart using character graphics, in a terminal emulator. (And actually you can show hi-res graphics too, in terminal emulators supporting some DEC standard, recently discussed on HN but I forget the name.)
17:38:07 <wavemode_> also, you certainly don't want _direct_ access to the pixels. then you'd be writing your own algorithms for things the hardware does automatically and efficiently (scaling, culling, anti aliasing, etc.)
17:38:09 <fog> thats quite difficult to understand
17:38:38 <fog> sm[m]^
17:38:56 <fog> wavemode_ right, sure
17:39:00 <sm[m]> which part fog ?
17:39:38 <fog> well, when you say character graphics i think of ascii, but you say it should be able to do hi-res stuff too, so it cant be that
17:40:08 <fog> also, i dont know what is a DEC standard, or what HN is
17:41:04 <fog> anyway, a different problem is trying to get the web graphics libraries from js, or node, to work with haskell web apps
17:41:11 <sm[m]> no problem. Modern terminal emulator software can show many non-ascii characters too, some of which are designed to make pictures with
17:41:20 <fog> oh
17:41:22 <fog> cool
17:41:45 <fog> my bloomberg terminal clone would be pretty retro
17:42:09 <sm[m]> DEC is the old Digital Equipment Corporation, I'm referring to a particular mode of some terminals where they can display pixel graphics, not just characters. HN is the Hacker News site where I read about it.
17:42:27 <fog> thanks
17:43:03 <fog> im just laughing at the idea of an ascii wealth fund manager shouting "sell"!
17:44:14 <fog> there was an ascii star wars thats like a hello world for using telnet
17:44:39 <fog> so basically, its c3po telling you how worried he is about a particular investment
17:45:31 <sm[m]> here's a nifty package that does plotting using unicode characters: https://github.com/Evizero/UnicodePlots.jl
17:47:14 <sm[m]> someone should port that to haskell
17:47:15 <fog> thats actually awesome!
17:47:34 <sm[m]> http://hackage.haskell.org/package/asciichart is simpler
17:48:27 <fog> woop! no javascript for me
17:49:29 <fog> well, thats not exactly the user experience you want to be offering to clients
17:50:13 <fog> let alone, the high level development environment that would help haskell be used more in real world web dev
17:52:07 <sm[m]> right, for clients I'd go for hvega.. examples: http://hackage.haskell.org/package/hvega-0.9.1.0/docs/Graphics-Vega-Tutorials-VegaLite.html
17:52:12 <fog> now i just have to figure out what i was trying to do with telnet...
17:53:40 <fog> sm[m]: wow that looks really complete, and anything that is designed around grammers seems like a good approach 
17:54:01 <fog> not that i know what grammers actually are... but it sounds like it has the right ethos behind it
17:54:26 <fog> one problem with "plotting" for trading terminals, is that they are "streaming"
17:54:39 <fog> typically i have only found .js libs that do this
17:54:58 <fog> i cant tell just at first glance if vega supports streaming plotting for web apps
17:59:07 <sm[m]> I'm not sure either
17:59:52 <sm[m]> is that more than just regenerating the chart repeatedly ?
17:59:53 <fog> https://plotly.com/javascript/streaming/
18:00:03 <sm[m]> http://hackage.haskell.org/package/Chart is the mature non-js plotting lib
18:00:53 <fog> yeah i saw that before, was trying to get it to work with SDL-diagrams
18:00:55 <fog> but couldnt
18:01:13 <sm[m]> I guess the streaming refers to the fact that the chart live-updates without a page reload. Certainly you can arrange that
18:01:18 <fog> it has a diagrams backend, but it was a total mess
18:01:34 <fog> trying to get several layers of different things to sync up
18:02:09 <fog> hmm, yeah, i guess the page would call for new data from the server and update the scene
18:02:24 <fog> probably not too dificult, but i couldnt get *anything* to work
18:03:28 <fog> even just for producing static plots as a .png was difficult
18:03:34 <fog> i was using juicy pixels
18:03:47 <fog> and some charting thing, i cant remember
18:04:25 <fog> but ended up just using sci-plot or whatever its called, like mat-plot-lib
18:05:01 <sm[m]> another, recently updated: http://hackage.haskell.org/package/chart-svg
18:05:46 <fog> pythin has "pandas" and a bunch of other libs for doing math programing kind of like matlab
18:05:58 <fog> and they all have various proted plotting options
18:06:07 <fog> its what makes python favoured in teaching
18:06:54 <sm[m]> we have matplotlib and r and gnuplot integration things
18:07:04 <fog> whats SVG? "support vector graphics" ?
18:07:22 <wavemode_> scalable
18:07:28 <fog> i thought for r there was something other than ghc that was like half r and half haskell
18:07:33 <sm[m]> it's a vector graphics standard, which can be generated without needing any special libs, so usually easy to install
18:07:44 <fog> cool
18:08:18 <sm[m]> https://tweag.github.io/HaskellR/ (AKA http://hackage.haskell.org/package/inline-r)
18:08:48 <fog> still, which of these plotting options do we have for teaching, or like, simple plotting?
18:09:10 <fog> in pythin its like "here use this and this, and this is how" and all the students just get used to that toolkit
18:10:20 <sm[m]> what's the one "winner" plotting lib in pythong ?
18:10:22 <fog> i guess most haskellers will just be saving their data to .cvs and opening with some third party tool
18:10:23 <c_wraith> are you looking for the diagrams library?
18:10:25 <sm[m]> we don't have one of those in haskell yet
18:10:42 <ezzieyguywuf> I'll say, I've found a few errors here and there, but coupled with the original source tutorial, I've found this immensely helpful: eboP <- malloc
18:10:45 <ezzieyguywuf> glGenBuffers 1 eboP
18:10:48 <ezzieyguywuf> ebo <- peek eboP
18:10:50 <ezzieyguywuf> glBindBuffer GL_ELEMENT_ARRAY_BUFFER ebo
18:10:51 <ezzieyguywuf> hah whoops.
18:10:54 <ezzieyguywuf> https://lokathor.gitbooks.io/using-haskell/opengl/hello-triangle.html
18:11:02 <fog> c_wraith: i had trouble getting diagrams, via sdl-diagrams to work with charts, from chards-diagrams
18:11:32 <fog> sm[m] i think mat-plot-lib is pretty standard
18:11:36 <sm[m]> matplotlib does sound like a possible winner of that kind: "Matplotlib is probably the most full featured plotting library out there. These bindings provide a quick, easy, and extensible way to use it in Haskell."
18:12:02 <sm[m]> I mean, presumably you'll have to deal with python install hassles as well as the haskell ones. There's no perfect answer
18:12:44 <fog> yeah, but because all the demonstrators have experience, they can get it all up and running and teach the steps to the students
18:13:26 <fog> without straitforward demonstrations of how to do plotting, haskell isnt going to get off the ground in scientific teaching
18:13:34 <sm[m]> we sure do have a lot of options for plotting in haskell
18:14:12 <sm[m]> and many of them come with straightforward looking example code. What's wrong with https://github.com/abarbu/matplotlib-haskell then ?
18:14:16 <fog> right, but nothing i have seen everyone using, or that provides the kind of simple use cases (or even, working) 
18:15:04 <sm[m]> we don't have one that everyone uses, and we probably don't have one that reliably installs for everyone (does anyone ?)
18:15:26 <fog> sm[m] thats actually the best haskell plot demonstration i think iv ever seen, nice find
18:15:57 <sm[m]> I hadn't seen it either
18:16:28 <fog> ok, thanks
18:16:32 <sm[m]> highest density of pretty pictures => the winner!
18:16:53 <sm[m]> I will try this next time..
18:17:12 <fog> well, i guess it has source code corresponding to each of the pictures
18:17:36 <fog> yeah, plenty of libs to try
18:17:54 <fog> still dont see an obvious candidate for a web app with a streaming chart though
18:18:24 <fog> especially one thats got the aesthetics to make a competitive product. 
18:20:19 <sm[m]> maybe you can add https://github.com/Lemmih/reanimate in there somehow
18:22:19 <sm[m]> not streaming capable yet I guess
18:22:24 <fog> looks good
18:22:54 <fog> ill just get my genetic lambda machine to smash them together until they work
18:39:23 * ski . o O ( <https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0282-record-dot-syntax.rst#1-motivation> )
18:43:16 <ski> i don't like how `f r .x' is suggested to be illegal, or how `f (g r).x' is suggested to mean `f ((g r).x)'. i'd prefer it to mean `(f (g r)).x' !
18:44:47 <ski> (iow, `.' (not composition, but field selection) should not bind more tightly than function application, imho)
18:47:21 <wavemode_> that was a significant matter of debate. in the end it was decided that field selection should behave somewhat like qualified imports (A.b)
18:47:54 <ski> i'd prefer writing
18:48:14 <ski>   foo  Nothing  .x = ...
18:48:26 <ski>   foo (Just t ) .x = ..t..
18:48:29 <ski> over
18:48:42 <ski>   (foo  Nothing ).x = ...
18:48:49 <ski>   (foo (Just t )).x = ..t..
18:52:56 <ski> (i'd also expect/want `someFun record.field.field2 value' to be parsed as `(((someFun record).field).field2) value'. if i want `someFun (record.field.field2) value', i'd prefer putting in those brackets explicitly)
18:57:49 * hackage calamity 0.1.14.2 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.2 (nitros12)
18:57:49 <wavemode_> frankly I'm just glad they settled on something, rather than debating over it for another 20 years
19:15:20 <fragamus_> howdy I'm having a problem with stack new: https://gist.github.com/fragamus/1b1a85fce45a91a03cb1dfddb524e700
19:17:49 * hackage serverless-haskell 0.12.0 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.12.0 (AlexeyKotlyarov)
19:32:02 <fragamus_> I need to work with a version of stack that supports ghcjs so I am stuck with 1.9.3    can anyone tell me how to get around the 404 error
19:37:38 <random8u89u9> hiDoes anyone know what the type of this function would be?"S f g x = f x (g x)"I got(b -> c -> a) -> (b -> c) -> b -> aI'm not sure what the point of this function is. Is it to just flip the application order?
19:37:50 <random8u89u9> hiDoes anyone know what the type of this function would be?"S f g x = f x (g x)"I got(b -> c -> a) -> (b -> c) -> b -> aI'm not sure what the point of this function is. Is it to just flip the application order?
19:37:55 <random8u89u9> my bad
19:39:56 <dibblego> it's to pass a function down a tree of calls at one level
19:40:03 <dibblego> *function argument
19:40:14 <random8u89u9> yea, my bad it was definitely not application order.
19:40:15 <random8u89u9> hmm
19:40:41 <random8u89u9> Why would you need that?
19:40:50 <random8u89u9> I tried to search hoogle for that type and found nothing
19:41:01 <dibblego> because it is closed under composition, so then you can also do it at any level
19:41:36 <dibblego> \c -> blah (f c) (g c) (h c) -- here it is at three levels
19:41:48 <dibblego> pure blah `S` f `S` g `S` h
19:41:56 <wavemode_> random8u89u9, that function is equivalent to the applicative for functions
19:42:01 <dibblego> S passed the (c) argument down three levels
19:42:18 <wavemode_> > ((+) <*> (* 2)) 10
19:42:20 <lambdabot>  30
19:42:46 <dibblego> it addresses the same problem that "Dependency Injection" attempts to address (with little success)
19:43:21 <random8u89u9> oh interesting
19:43:55 <random8u89u9> I saw it being defined in implementing functional languages: a tutorial, and I wasn't sure why I would need to use it
19:45:14 <dibblego> because "who wants to explicitly pass the argument (c) down the call tree?"
19:46:56 <fragamus_> what's up with this 404:
19:46:57 <fragamus_> https://raw.githubusercontent.com/fpco/lts-haskell/master/lts-15.16.yaml
19:46:58 <wavemode_> random8u89u9: well, who told you you need to use it? the existence of something does not imply its necessity
19:47:37 <random8u89u9> I don't need it I guess. I was mostly wondering why the book was defining the function in the prelude of the "Core" language
19:47:54 <random8u89u9> The prelude only has
19:48:07 <random8u89u9> I x = x ;K x y = x ;K1 x y = y ;S f g x = f x (g x) ;ompose f g x = f (g x) ;twie f = ompose f f
19:48:13 <random8u89u9> oh god
19:48:35 <dibblego> id, const, const id, (<*>), (.), join
19:48:41 <dibblego> (in Haskell)
19:49:16 <random8u89u9> I x = x ;  K x y = x ; K1 x y = y ; S f g x = f x (g x) ; compose f g x = f (g x) ; twice f = compose f f
19:49:25 <random8u89u9> right
19:57:11 <random8u89u9> Still not a 100% why these are essential enough to include in the prelude(except for compose), but I'll find out I suppose
19:58:07 <wavemode_> they're just keeping with tradition. the prelude includes a bunch of things you don't need and leaves out a bunch of things you do :p
20:01:08 <dibblego> random8u89u9: have a look at the SKI combinator calculus
20:01:19 <dibblego> these are quite fundamental and useful operations
20:01:42 <random8u89u9> thanks
20:01:46 <random8u89u9> i'll take a look
20:14:33 <random6786t687> ohh
20:14:49 <random6786t687> now i see why the functions are called S, K, I
20:14:52 <random6786t687> pretty interesting
20:36:58 <libertyprime> hey guys. haskell noob here looking for some intuition. When I do the following: (map read $ words "1 2") :: [Int]    Is this basically creating a new function out of map and read before applying it? And that is why you supply [Int] rather than specifying Int to read somehow? If I were to do the latter, how would that be done?
20:37:17 <koz_> libertyprime: A few things here.
20:37:25 <koz_> :t read
20:37:27 <lambdabot> Read a => String -> a
20:37:41 <koz_> This means 'as long as a has an instance of Read, if you give me a String, I'll give you an a'.
20:37:50 <koz_> Now, if you don't tell the compiler what you want, how is it to read your mind>?
20:37:57 <koz_> If you give it a String and go 'hay read plz'.
20:38:12 <koz_> Do you want Int, [Int], SomeOtherTHing,e tc etc?
20:38:42 <koz_> Secondly, the 'creating a new function out of blah' thing. When you do '1 + 2' are you 'creating a new number out of 1 and 2'?
20:46:07 <dsal> read :: MyMind
20:49:54 <libertyprime> koz_: i take it that because this works: sum $ map read $ words "1 2" :: Int    then there is some type inference going on which propagates down to read?
20:50:21 <koz_> libertyprime: Yeah, basically.
20:50:36 <koz_> Since you specified 'I want an Int in the end', the typechecker can use this to figure out the rest.
20:50:54 <Axman6> libertyprime: you could also do map (read :: String -> Int) $ words "1 2" if you wanted
20:51:20 <koz_> dsal: I guess we can find this in acme-telepathy? :P
20:51:29 <wavemode_> specifying :: Int is not actually necessary
20:51:37 <wavemode_> the type of sum allows for inference as well
20:51:46 <koz_> "The MyMind type is deeply magical. It is primitive, but unlifted."
20:52:00 <Axman6> :t sum $ map read $ words "1 2"
20:52:02 <lambdabot> (Num a, Read a) => a
20:52:10 <libertyprime> thats really interesting. i like this
20:52:38 <dsal> :t map read
20:52:39 <lambdabot> Read b => [String] -> [b]
20:53:00 <koz_> :t sum . map read
20:53:02 <lambdabot> (Num c, Read c) => [String] -> c
21:47:41 <crestfallen> hi I was baffled again by state .. ' type State = Int; newtype ST a = S (State -> (a, State))   here with the type of the dummy constructor: S :: (State -> (a, State)) -> ST a    
21:48:41 <crestfallen> so I'm not sure how that returns ST a. does that have something to do with runState :: State s a -> (s -> (s,a))   ?
21:54:07 <wavemode_> If I define `newtype T a = TC a` , then the constructor TC is now a function of type `a -> T a` . for example, `TC 5` has the type `T Int` . does that make sense?
21:54:46 <wavemode_> crestfallen, so here ` S :: (State -> (a, State)) -> ST a` is just referring to the type of the constructor S, as a function
21:58:31 <crestfallen> wavemode_: thanks kindly working on that
22:10:28 <crestfallen> wavemode_: actually that brings me closer. so State is actually a function:   runState :: (State s a -> (s -> (s,a))
22:11:17 <crestfallen> according to a webpage I'm reading:   we're implicitly defining a function to extract our inner function from the data type: that function is called runState.  "
22:12:20 <crestfallen> but in the first case we dont need {} to indicate a function
22:13:12 <crestfallen> I don't know if this tutorial is well-written in the first section: https://acm.wustl.edu/functional/state-monad.php
22:13:24 <Axman6> if you had writyten newtype ST a = S {runST :: State -> (a,State)} then you would have had the function runST :: ST a -> State -> (a,State) greated for you automatically
22:15:14 <Axman6> written*
22:15:51 <wavemode_> crestfallen, in the definition `newtype State s a = State { runState :: (s -> (a,s)) }` , there are two functions. State is the constructor, as we've mentioned. but now we've also defined a deconstructor called runState, which takes a State and extracts the function it holds
22:17:24 <crestfallen> Axman6: wavemode_: working... thanks
22:21:16 <wavemode_> @define newtype MyState s a = MyState { runSt :: (s -> (a,s)) }
22:21:17 <lambdabot>  .L.hs:160:1: error:
22:21:17 <lambdabot>      Multiple declarations of ‘MyState’
22:21:17 <lambdabot>      Declared at: .L.hs:158:1
22:21:29 <wavemode_> :t MyState
22:21:30 <lambdabot> (s -> (a, s)) -> MyState s a
22:21:41 <wavemode_> :t MyState (\x -> ("hello", x))
22:21:43 <lambdabot> MyState s [Char]
22:21:50 <wavemode_> :t runSt $ MyState (\x -> ("hello", x))
22:21:51 <lambdabot> s -> ([Char], s)
22:28:19 <crestfal1en> it's self-referential, right? meaning its return value can be chained with (>>=) to another action
22:28:47 <crestfal1en> sorry I was disconnected somehow
22:29:20 <wavemode_> is what self-referential? not quite sure what you mean by that
22:29:41 <wavemode_> you can use >>= if a Monad instance is written for it, sure
22:30:11 <crestfal1en> test
22:30:33 <wavemode_> test successful :p
22:30:34 <crestfal1en> sorry irssi is a new client. it's misbehaving
22:33:46 <crestfal1en> thanks wavemode_ this is helpful. I understand much about basic monads but state functor/monad has got me mired..
22:39:44 <crestfal1en> shit anyone know how to make sure I've saved the log of this session in irssi? I did /SET autolog ON    but did I do it too late? dangit
22:40:38 <wavemode_> this channel is logged, in any case: http://tunes.org/~nef/logs/haskell/?C=M;O=D
22:41:24 <crestfal1en> whaa? that's awesome wavemode_ I didn't know that
22:45:58 <crestfal1en> thanks I'll sleep on that wavemode_ appreciate it
22:46:48 * hackage dobutokO4 0.2.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.2.0.0 (OleksandrZhabenko)
22:49:18 * hackage dobutokO4 0.2.1.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.2.1.0 (OleksandrZhabenko)
22:49:42 <vadko> grep >
22:49:45 <crestfal1en> before I leave, if I could ask how isomorphism, under "the short version" on the following page is related to our chat   https://wiki.haskell.org/Newtype
22:49:56 <vadko> hi 
22:50:54 <crestfal1en> I believe that was when wavemode_ was talking about constructor/deconstructor
22:51:18 * hackage postgresql-libpq-notify 0.2.0.0 - Minimal dependency PostgreSQL notifications library  https://hackage.haskell.org/package/postgresql-libpq-notify-0.2.0.0 (JonathanFischoff)
22:52:17 <dmwit> I think it is basically not related in an interesting way to the things we were discussing earlier.
22:52:53 <wavemode_> crestfal1en: without getting into the theoretical, what that wiki page is saying is that a newtype and its contents are exactly the same at runtime. a newtype over an int, for example, is just an int at runtime
22:53:27 <Axman6> but is a completely separate type to the type system
22:53:58 <Axman6> the in memory representation is exactly the same as the type being wrapped, but the type is distinct
22:55:29 <crestfal1en> ok thanks ALL this ain't easy. I'm going to tear through the firstPrinciples book because my book covers this in a faint whisper.
23:38:49 * hackage openapi3-code-generator 0.1.0.6 - OpenAPI3 Haskell Client Code Generator  https://hackage.haskell.org/package/openapi3-code-generator-0.1.0.6 (remo_doerig)
