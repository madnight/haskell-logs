00:56:35 <dminuoso> kuribas: XML is convoluted and complex, that's why hxt and friends look so convoluted and complex.
00:57:00 <dminuoso> At the surface it looks highly trivial, but it's really not.
00:57:02 <koz_> XML is very involved. The standard goes on for pages and pages and pages.
00:57:23 <koz_> And that's before we get to namespaces, its optional type system, schemata of various stripes...
00:57:32 <kuribas> dminuoso: perhaps... but for just parsing stuff I find it not very ergonomic
00:57:54 <dminuoso> kuribas: Blame XML :)
00:58:43 <kuribas> dminuoso: I already have some partial implementation which is much leaner IMNHO
00:58:56 <kuribas> dminuoso: for example it uses parser-combinators
01:00:48 <kuribas> dminuoso: I don't really need schema validation to be in haskell, that can be done with external tools
01:04:17 <c_wraith> why do you need error reporting then?
01:04:27 <c_wraith> are people hand-generating xml inputs to your system?
01:04:42 <[exa]> kuribas: there are people who ship megatons of data in XML, which is one of the main reason the parsers are 1 complexity level ahead of expectations
01:04:52 <kuribas> c_wraith: no, we need to talk with the data engine using XML
01:05:20 <dminuoso> kuribas: Between DTD effects, external entities, namespaces, xml schemas, you get up with a terrible thing to parse and still generate useful errors.
01:05:31 <kuribas> [exa]: right.  So hxt and haxml have good usecases, but it seems overkill for mine...
01:05:42 <dminuoso> And then, there's plenty of libraries that are designed to parse *bad* xml and have a somewhat useful output.
01:05:54 <dminuoso> Sprinkle xlst support for good measure
01:06:21 <dminuoso> The overkill is not in hxt or haxml, its in xml.
01:06:31 <c_wraith> so...  if the xml is being machine-generated and you're not checking it against a DTD/schema in haskell code, the errors that remain are logical errors in the semantic domain.  Why would you need to report those while parsing?
01:06:31 <dminuoso> Haskell just tends to promote "doing it right"
01:06:37 <kuribas> c_wraith: and being able to quickly debug XML is a good feature.
01:06:43 <dminuoso> "quickly debug xml"
01:07:06 <dminuoso> https://www.w3.org/TR/2000/REC-xml-20001006.pdf
01:07:17 <dminuoso> 60 pages describing the mere raw of XML, lacking any of the surrounding features
01:08:00 <kuribas> c_wraith: we don't have a schema
01:08:02 <dminuoso> I dont get why people are under the mistaken impression, that there must be some simple way to parse XML.
01:08:32 <dminuoso> kuribas: But plenty of people do, so people dont even bother writing an XML implementation that lacks a schema validator. ;)
01:09:19 <dminuoso> Anyway, if you add DTDs alone you get into a world of pain.
01:12:13 <[exa]> kuribas: btw how big's the xml?
01:12:23 <kuribas> [exa]: small typically
01:13:32 <[exa]> there will for sure exist a minimal megaparsec not-really-xml-but-almost parser; for software engineering purposes I'd take that one, add some aeson-like conversion to actual haskell datatypes, and F it.
01:13:43 <[exa]> (you want a prototype first anyway)
01:13:45 <kuribas> dminuoso: here's my attempt: https://gist.github.com/kuribas/8abd511d03b60f3113a4c81e0e01308f
01:15:04 * [exa] eyes Text.Megaparsec.TagSoup
01:15:22 <kuribas> it's parsing the sax stream
01:29:35 <kuribas> it also runs in constant space
01:30:02 <kuribas> or you can choose to parse unordered, at the expense of space
01:52:10 <merijn> https://pbs.twimg.com/media/EZD_WZkWkAASBT-?format=jpg ;)
02:01:07 <lemonpaul> Is there support for lazy quantifier in Text.Regex.TDFA?
02:09:28 <lemonpaul> Sorry, is there lazy quantifier support in regex-tdfa?
02:20:49 <merijn> What do you mean by lazy quantifier?
02:22:49 <hc> probably .? / *? instead of . or *
02:22:57 <hc> s/lazy/non-greedy/ ?
02:23:14 <lemonpaul> exactly
02:23:30 <lemonpaul> I try to use ? but got exception
02:24:02 <lemonpaul> *** Exception: Explict error in module Text.Regex.TDFA.String : Text.Regex.TDFA.String died: parseRegex for Text.Regex.TDFA.String failed:"^I( +).*?(II.*)$" (line 1, column 9):
02:24:02 <lemonpaul> unexpected '?'
02:28:30 <enikar> it seems to me, there are non-greedy regexp in Text.Regex.PCRE.
02:28:56 <lemonpaul> Sorry again.
02:28:58 <enikar> it seems to me, there are non-greedy regexp in Text.Regex.PCRE.
02:29:16 <lemonpaul> I use TDFA
02:29:49 <enikar> also, non-greedy regex are not a part of posix regex (or I'm wrong?)
02:30:16 <yushyin> I also think so
02:30:30 <yushyin> and tdfa is posix regex only
02:30:39 <lemonpaul> Yes...
02:30:44 <lemonpaul> full Posix compliance 
02:30:45 <yushyin> so no lazy quantifiers in tdfa
02:32:34 <lemonpaul> Is there any library which support it?
02:33:54 <yushyin> PCRE
02:34:01 <lemonpaul> Thanks.
02:35:33 <enikar> notice, the api is the same in both packages. It's a good point.
02:38:15 <lemonpaul> Yeah, I've already noticed.  Pretty handy.
03:23:45 <dminuoso> Mmm, GHC doesnt allow disabling orphan warnings per-instance, right?
03:30:11 <merijn> dminuoso: Not yet
03:30:56 <merijn> dminuoso: I proposed an ADOPT pragma, but that got shot down in favour of a more general, granular disabling of warnings solution which (to the best of my knowledge) hasn't actually been proposed or implemented yet
03:31:42 <dminuoso> mmm
03:32:22 <cocreature> I even wrote a patch for the ADOPT pragma at some point :(
03:34:16 <dminuoso> https://gitlab.haskell.org/ghc/ghc/issues/602
03:34:19 <dminuoso> Ah well. That's not so old.
03:44:30 <phadej> also my https://gitlab.haskell.org/ghc/ghc/-/merge_requests/2932 is not appreciated
03:45:03 <phadej> which only makes me think that GHC people (won't tell names) don't work on realworld sized projects except the GHC
03:45:14 <phadej> itself
03:46:19 <merijn> phadej: I prefer to just think of myself as a visionary prophet ahead of his time
03:47:36 <merijn> phadej: I think the problem is the kinda thinking that goes "well, an adopt pragma is kinda hacky and niche, we already have a need for more granular control of warnings, so we should do that instead"
03:47:43 <merijn> Which is all true, of course
03:48:53 <merijn> But "adding an ADOPT pragma is something someone could do as a small one-off contribution, whereas "granular control of warnings in source files" is much more complex, meaning no one will do it, except existing committers. Which are all already busy with their own stuff...
03:51:24 <kleisli> is there a standard implementation of free monads?
03:51:33 <dminuoso> merijn: Of course, a valid concern is that adding such an ADOPT pragma will provide headaches if a granular region based warning suppression is ever added.
03:52:09 <phadej> if the issue is open for 15 years...
03:52:27 <merijn> dminuoso: Sure, that's a concern
03:52:31 <phadej> and every 6 months there is a release which breaks something
03:52:57 <dminuoso> kleisli: https://hackage.haskell.org/package/free is pretty much the package to use. :)
03:53:10 <merijn> dminuoso: But "well, we shouldn't do this because in the future we want something better this may conflict with" isn't really relevant if that future is "indefinitely far in the future"
03:53:10 <dminuoso> But we dont have an official package if thats what you mean.
03:53:33 <kleisli> dminuoso, thanks :)
03:53:44 <phadej> IMO if there's a release which would add a granular warning report, it could deprecated or even remove ADOPT in the same release
03:54:33 <phadej> I don't think though that ADOPT is a good idea though, having pragma to control warning reports doesn't feel *right8
03:54:36 <dminuoso> merijn: I guess if, after 15 years, it boils down to just two warnings people frequently want to suppress (orphans and overlapping identifiers), an argument could be made that we don't need a generally tailored solution.
03:55:01 <dminuoso> especially if the problem domain is so complex, that after 15 years nobody could come up with a design for that "overly generalized implementation"
03:55:27 <merijn> I mean, almost all other warnings already have methods of silencing by, you know, fixing them
03:56:04 <dminuoso> phadej: Im having trouble understanding your ticket by the way. Perhaps if the English was refactored, it could have a better chance at succeeding?
03:57:57 <phadej> dminuoso: maybe. I found another way around the problem.
03:58:50 <dminuoso> phadej: Did you move the orphan instances into a helper package and disabled the warnings on that? ;)
04:00:48 <phadej> dminuoso: thank you, you are being very helpful.
04:01:06 <dminuoso> Sorry.
04:19:19 * hackage dotgen 0.4.3 - A simple interface for building .dot graph files.  https://hackage.haskell.org/package/dotgen-0.4.3 (ryanglscott)
04:47:39 <sheepfleece> Hello! What would be the right way (or is this the right way) of using simple `set` lens? 
04:47:42 <sheepfleece>     return $ ( #id .~ handle ) file
04:48:01 <sheepfleece> Because it looks somewhat scary to me.
04:52:23 <sheepfleece> Oh, I think I even wrote it erroneously c 
04:52:52 <[exa]> sheepfleece: uh, what exactly are you trying to achieve?
04:54:32 <sheepfleece> I just want to set a value to `handle` in `file` struct.
04:55:16 <dminuoso> sheepfleece: Sure, that works then.
04:55:24 <[exa]> sheepfleece: I kindof parse that like "return `file` with a modified `id`, which should work as `return (file & id .~ handle)`
04:55:53 <dminuoso> Im not quite sure what your question is, since "the right way to use (.~)" boils down to not mixing up the arguments.. 
04:58:00 <sheepfleece> I see, thank you! The scary error was due to me forgetting to import `Data.Generics.Labels`. And I also forgot about (&)!
04:58:31 <dminuoso> sheepfleece: (&) is not necessary, really. It's just a flipped around ($), it's just a convenience tool :)
04:58:38 <sheepfleece> There is one more question though, I see some people sometimes use (>>>) and (<<<) instead of (.). Is this just a matter of taste? 
04:58:55 <sheepfleece> Or maybe there are some specific reasons for using arrows.
04:59:15 <dminuoso> sheepfleece: Possibly a matter of taste, and (>>>) is a flipped around version - so there's that
04:59:24 <dminuoso> Or they are writing Arrow generic code
04:59:42 <dminuoso> Nowadays it's Category evne
05:01:10 <sheepfleece> I see, thank you!
05:16:29 <veverak> :t Maybe (m a) -> m (Maybe a)
05:16:30 <lambdabot> error: parse error on input ‘->’
05:17:03 <solonarv> veverak: that's not what :t does
05:17:03 <Cheery> :k Maybe (m a) -> m (Maybe a)
05:17:05 <lambdabot> error: Not in scope: type variable ‘m’
05:17:05 <lambdabot> error: Not in scope: type variable ‘a’
05:17:05 <lambdabot> error: Not in scope: type variable ‘m’
05:17:10 <veverak> ah, 'k'
05:17:10 <solonarv> are you looking for a function with that type?
05:17:27 <veverak> yeah, I have Maybe storing value in monad
05:17:35 <Cheery> :t mapM
05:17:36 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:17:36 <veverak> need to convert it to monad of maybe with that value
05:17:49 * hackage hosc 0.18.1 - Haskell Open Sound Control  https://hackage.haskell.org/package/hosc-0.18.1 (RohanDrape)
05:17:50 <wavemode_> :t sequence
05:17:52 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
05:18:08 <solonarv> @hoogle Maybe (m a) -> m (Maybe a)
05:18:09 <lambdabot> No results found
05:18:18 <solonarv> grumble grumble
05:18:28 <veverak> oooh, mapM is even better
05:18:29 <solonarv> :t sequenceA -- this one
05:18:30 <veverak> thanks
05:18:30 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
05:18:48 <veverak> it was actually:   fooo <- f <$> mb_val
05:18:49 <solonarv> :t traverse -- or this if you were already using 'fmap' for something
05:18:50 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:19:08 <Cheery> Hmm.. I wonder if that works
05:19:24 <solonarv> there is a law: traverse f m = sequenceA (f <$> m)
05:19:35 <Cheery> > sequence (Just [1,2,3,4])
05:19:37 <lambdabot>  [Just 1,Just 2,Just 3,Just 4]
05:20:19 <Cheery> interesting
05:21:50 <wavemode_> > sequence [Just 1,Just 2,Just 3,Just 4]
05:21:52 <lambdabot>  Just [1,2,3,4]
06:01:58 <Cheery> Is there Haskell REPL that'd reify and print the expression you give in?
06:03:33 <merijn> Cheery: I think you can actually change and customize the ghci REPL loop
06:03:41 <dminuoso> Cheery: TH can do that
06:03:57 <merijn> Or rather, I *know* you can do that, but I'm not sure if you can enough of it to do what you want
06:04:14 <merijn> Cheery: Or do you mean, like, reify the result of the expression?
06:04:17 <merijn> Something like
06:04:23 <merijn> > foldr f z [a,b,c,d]
06:04:25 <lambdabot>  f a (f b (f c (f d z)))
06:04:42 <Cheery> yup.
06:05:08 <merijn> (that example is done via the simple-reflect package, which you can just get from hackage)
06:06:56 <joelg> I've been experimenting with using the ST monad to get some algorithms to run at their optimal complexity (eg algorithms that mutate an array over and over, then output a final array). But everything I write in the ST monad looks like rubbish. Does anyone know of good guides to using this idiomatically, or code I might read?
06:07:57 <Cheery> does the type declarations seem like rubbish?
06:08:26 <merijn> Cheery: Of what?
06:08:47 <merijn> joelg: Do you have an example?
06:08:57 <Cheery> joelg: Those are the first thing I read from your program.
06:09:39 <joelg> I can write code that works, but it's not nice to read, and I'm using things like whileM in ways that seem a bit weird
06:10:15 <merijn> joelg: Yeah, but do you have a (small-ish) example of something you think is ugly? Maybe there's simpler/more readable ways to write it
06:15:01 <joelg> For example I want to have loop like "while someArray[idx] is not zero, do blah", and the "do blah" part is fine, but when someArray is mutable and idx is an STRef, I need to split that condition out into a few lines to express it
06:17:20 <merijn> hmm, you do?
06:18:00 <joelg> Yeah, I feel like this should not be the case and I can kind of see how to do it, but I was looking for some code to look at for common idioms
06:18:40 <merijn> "val <- readSTRef idx >>= indexM vec" is just one
06:18:55 <merijn> If you need a predicate you can just fmap it over that
06:19:54 <merijn> And, of course, a judicious use of helper functions in where blocks can help
06:20:31 <joelg> merijn: I see, something like (=/ 0) <$> (readSTRef idx >>= indexM vec) would do the trick as the condition
06:21:56 <merijn> joelg: And if you have a fixed index STRef and vector then you can have a helper function in a let/where that abstract that logic out into a single operation and then use that in the main logic
06:22:12 <merijn> joelg: Almost all ugly code can be made less ugly by judicious use of where bindings
06:23:56 <joelg> merijn: I guess my other fear is that it runs the risk of turning my code into something very hard to read in a different way (eg for a different developer) since I'm making up so many helper functions, but perhaps this is unavoidable
06:26:17 <merijn> joelg: Well, I think something like having a single named binding for "stop predicate" helps the logic a lot (when I care about the stop conditions I can look at only that part, and when I don't you can ignore it)
06:29:04 <Cheery> pairs and sums are trivial to print, but functions aren't. Is the representable functors related to this subject?
06:32:09 <berndl> Cheery: no
06:42:48 * hackage ftp-client 0.5.1.4 - Transfer files with FTP and FTPS  https://hackage.haskell.org/package/ftp-client-0.5.1.4 (miscyb)
06:53:21 <dolio> Cheery: Representable functors are about this: every category C is embedded into a category of functors by the Yoneda embedding `y : C -> (C^op -> Set)`. The image of `y` is like a copy of C inside this functor category. However, the functor category automatically has a lot of structure, inherited from Set.
06:54:41 <dolio> The Yoneda lemma says that the embedding can go backwards, though, so a bunch of the structure in the functor category can be pulled back through the embedding.
06:55:13 <dolio> But, this only works if the structure lands in the image of the embedding.
06:56:35 <dolio> So, for instance, the functor category has products automatically. If a product of things in the image of `y` is also in the image of `y`, then we can run it back to the category `C`, and it becomes a product in `C`.
06:57:35 <dolio> And the inverse image is said to 'represent' that the corresponding thing in the functor category.
06:58:05 <dolio> `A×B` represents the functor `yA × yB`.
06:59:00 <berndl> Another example: () represents Identity
06:59:23 <dolio> When people talk about it in Haskell, usually with covariant functors, the situation is for the other embedding, with type `C^op -> (C -> Set)`.
06:59:24 <berndl> Here's another one: Natural represents Stream
07:00:53 <berndl> And if there was a Conatural data type, we could say Conatural represents [].
07:01:23 <Cheery> So it has relevance to the subject, but it's bigger concept.
07:02:05 <philippe__> i have build my program with  stack build --executable-profiling  then when i run   stack exec -- myprogram +RTS -xc   it says it's not build with profiling .. what could be the problem here ?
07:03:11 <merijn> philippe__: Presumably exec needs to be told to use profiling too
07:03:29 <philippe__> thanks merijn 
07:14:29 <kuribas> is it possible to make cabal not choke on haddock documentation?
07:14:49 <kuribas> I set haddock on in the config, but now it chokes on a package (fast-logger) where it fails.
07:34:03 <sm[m]> Kuribas there should be —no-haddock-deps or similar
07:43:24 <jchia_> In C, alloca allocates memory on the stack. In GHC, does Foreign.Marshal.Alloc.alloca also allocate memory on the stack?
07:44:25 <merijn> define "stack"
07:51:48 * hackage commander-cli 0.4.1.2 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.4.1.2 (sgschlesinger)
08:07:38 <amf> What's a good way to parse xml into data structures? never done this with haskell (but plenty of times with aeson/hsyaml)
08:10:46 <srk> amf: hxt / haxml
08:12:55 <amf> going to look at haxml because arrows still scare me
08:24:25 <sheepfleece> Can I somehow define a data types which implements all possible typeclasses? I want something akin to `undefined` but on a type level (so I can use it when defining functions)
08:25:25 <srk> amf: there are some tutorials on haskell wiki for hxt, I'm not that familiar with arrows either but the parsers can be written without really knowing them
08:27:40 <Hopplahase> sheepfleece: Could you give an example usage?
08:27:57 <merijn> sheepfleece: That question isn't really sensible as there's theoretically an infinite number of typeclasses
08:28:24 <merijn> sheepfleece: Do you maybe want PartialTypeSignatures?
08:29:25 <shapr> amf: arrows are pretty much functions with static info attached
08:41:06 <turq> how does <$ work?
08:43:31 <turq> > 3 <$ Just True
08:43:33 <lambdabot>  Just 3
08:43:58 <ja> @src (<$)
08:43:58 <lambdabot> (<$) = (<$>) . const
08:44:59 <turq> it looks like it performs an action and wraps the value on the left side of the operator inside the context on the right
08:46:04 <turq> oh, I see. there isn't necessarily an "action"
08:46:42 <ja> :t (<$)
08:46:43 <lambdabot> Functor f => a -> f b -> f a
08:47:01 <ja> i guess it would be wrong to call functors actions?
09:03:55 <remexre> hm, is there an nthWithDefault :: Foldable t => a -> Int -> t a -> a
09:04:39 <remexre> I can write one (foldr-ing over a (Maybe Int, a)), but it's a lot less efficient than e.g. Data.Sequence.(!)
09:13:30 <__monty__> So, updating all my bounds when bumping GHC is pretty tedious. Is there a cabal-install invocation I can use to ignore the bounds and just tell me a potential plan?
09:14:12 <veverak> hmm
09:14:14 <veverak> I have type EvalM a = ErrorT String (State Scope) a
09:14:22 <veverak> if I want to extraxt state in do block
09:14:32 <veverak> "s <- lift get" 
09:14:34 <veverak> ^^ ?
09:15:22 <monochrom> __monty__: something about --allow-newer
09:16:00 <monochrom> But I am pretty surprised about "all my bounds". I thought it would be only base and a few rare others.
09:17:36 <dolio> Do a bunch of packages not actually update the information on old versions properly, perhaps?
09:17:49 <dolio> To indicate that they can actually function with newer base.
09:18:42 <dolio> I suppose they'd have to be doing that with major version bumps, too.
09:18:58 <__monty__> Maybe not all, but some packages specify base constraints making it cascade.
09:21:47 <ja> __monty__: in that case, wouldn't bumping the base bounds of the direct immediate dependencies fix it? i do that with cabal.project.local
09:22:12 <solonarv> veverak: that would work. if you use the functions in Control.Monad.State.Class (they are reexported from Control.Monad.State), then you don't need to spray 'lift' all over the place
09:22:25 <whataday> is that fixed point related to continuation?
09:22:39 <veverak> solonarv: hmm, I get type error there :/
09:22:49 <whataday> :t id
09:22:50 <lambdabot> a -> a
09:23:07 <solonarv> veverak: then I'll have to see more code than those two lines; can you put up a paste?
09:23:49 <__monty__> ja: I don't think that's what I want to do. Rather I'd like a plan that'll work with my current base/time/etc. I think cabal gen-bounds is pretty much what I wanted.
09:24:43 <veverak> solonarv: https://paste.vpsfree.cz/iRUH0Vlu/
09:24:46 <veverak> I hope that is enough
09:26:40 <solonarv> veverak: that error has nothing to do with the 'lift' being there or not
09:27:07 <solonarv> the issue is 'lookup'; it's unqualified, so you're using Prelude.lookup
09:27:13 <solonarv> but you probably wanted Map.lookup
09:27:17 <veverak> fu me
09:27:19 <veverak> yeah
09:27:21 <veverak> thanks
09:27:45 <solonarv> (also you should probably explictly import Data.Map.Lazy or Data.Map.Strict, rather than Data.Map)
09:29:01 <veverak> ok
09:29:15 <asheshambasta> How does one parse cabal error messages like these: https://gist.github.com/asheshambasta/d2d25c374ee7719f308b4c2982706d0e
09:30:18 <asheshambasta> is this error message saying (correct me if I'm wrong) that hsc3-sf and hosc cannot agree on a version of base?
09:31:47 <whataday> https://jsdw.me/posts/haskell-cont-monad/
09:32:30 <whataday> goto = C.callCC $ \out -> let fn = out fn in return fn
09:32:51 <fendor_> asheshambasta, looks to me like you have hosc version 0.17 installed, but hsc3-sf does only work with hosc ==0.15
09:32:54 <whataday> what's the point to return out's fixed point here?
09:33:09 <whataday> what it has to do with continuation?
09:34:22 <asheshambasta> fendor_: I see, well, I was trying to write nix derivations of hsc3, which has 0.17; but it seems like there's a mismatch in the commit hash I'm using at that tag, or similar. 
09:35:08 <lukelau> Has anyone any luck with working around the MAX_PATH limitations on windows when compiling with ghc?
09:35:21 <lukelau> It doesn’t seem to be enough to enable long paths in the registry
09:36:25 <Cheery> whataday: looks fun
09:37:44 <cocreature> lukelau: shorten paths, I wish I was joking but I’m not
09:38:00 <monochrom> whataday: I think my http://www.vex.net/~trebla/haskell/cont-monad.xhtml is better.  Also, "C.callCC $ \out -> let fn = out fn in return fn" is more like setjmp than the jump itself.
09:38:19 <Cheery> I understand what it means.
09:38:20 <monochrom> i.e., more like setting a label to be jumped to.
09:38:22 <cocreature> lukelau: GHC seems to use some legacy APIs so enabling long paths don’t work. GHC 8.10 includes a patched toolchain that is supposed to resolve some of those issues but I didn’t verify it so far.
09:38:36 <Cheery> you call a continuation with itself.
09:39:13 <Cheery> but it's not so much of "goto" as it's "go back"
09:39:21 <lukelau> cocreature: I’m trying to at the moment but github actions is very limited in where it lets you checkout repos :(
09:40:36 <lukelau> `haskell-language-server-wrapper` built with cabal is a nightmare, since it unfolds into `D:\a\haskell-language-server\haskell-language-server\dist-newstyle\build\x86_64-windows\ghc-8.6.5\haskell-language-server-0.1.0.0\x\haskell-language-server\opt\build\haskell-language-server\haskell-language-server-tmp\Paths_haskell_language_server.o`
09:41:16 <lukelau> Or my personal favourite, D:\a\haskell-language-server\haskell-language-server\../b\build\x86_64-windows\ghc-8.10.1\haskell-language-server-0.1.0.0\x\haskell-language-server-wrapper\opt\build\haskell-language-server-wrapper\haskell-language-server-wrapper-tmp\Paths_haskell_language_server.o
09:41:17 <cocreature> lukelau: rename the binary to hlsw :)
09:42:12 <monochrom> Is path length limits why Nix prefers to be at /nix rather than /usr/local/johnscustomization/nix-experiment/nix ? :)
09:42:29 <lukelau> I tried that by using sed -i -e ’s/haskell-language-server/hls/‘ on the cabal file, but then the build failed because we’re using autogened Paths_haskell_language_server modules somewhere
09:42:38 <cocreature> monochrom: nix doesn’t run on windows :)
09:42:43 <whataday> is there a actually term called 'fixed-point continuation'?
09:42:44 <monochrom> Oh! heh
09:42:49 <cocreature> lukelau: sed that as well?
09:42:55 <monochrom> whataday: I think no.
09:43:17 <lukelau> cocreature: looks like I’ll have to. I didn’t want to end up writing lots of regex but here we are
09:43:48 <lukelau> My last attempt was by using `—disable-per-component` and `—builddir=b` to flatten out the dist dir a bit, which worked
09:43:52 <MarcelineVQ> cocreature: can it be run off ntfs?
09:44:18 <whataday> monochrom I remember I saw your fixed point article, but you didn't put const in it IIRC
09:44:21 <lukelau> But then I turned on -O2 which seemed to create another nested `obj` directory which caused the max path to be exceeded by like 2 characters
09:44:34 <whataday> fix . const = id
09:44:37 <cocreature> MarcelineVQ: dunno but I would be more surprised by it working than not working :)
09:44:46 <monochrom> That one is too boring to discuss.
09:45:50 <monochrom> Recursion occurs everywhere in nature, for example fix blogs and call/cc tutorials.
09:45:57 <cocreature> lukelau: alternatively just change it on all platform? iirc that binary isn’t something users invoke directly so giving it a shitty name isn’t that much of a problem
09:47:03 <Cheery> continuations also turn intuitionistic linear logic into classical linear logic
09:48:25 <monochrom> I think it also does the same to the non-linear ones.
09:49:22 <lukelau> cocreature: this is just for the CI builds though, once the binary is made somehow we can download it as whatever we want thankfully
09:49:59 <cocreature> lukelau: well people might also hit this when trying to build locally so everyone on Windows that wants to hack on hls has to apply this
09:50:08 <solrize> are we now supposed to use pure insead of return to lift something into a monad?
09:50:38 <monochrom> It's up to you.
09:50:58 <Cheery> I like to use pure because 'return' technically doesn't do that.
09:51:21 <monochrom> But "return" is a worse name.
09:51:48 <Cheery> pure is a bit weird name, but I'm ok with it.
09:52:02 <whataday> setjmp :: (MonadCont m) => m (m b) setjmp = callCC (\c -> return (fix c))
09:52:36 <whataday> this is same as I pasted a few minutes ago
09:53:04 <monochrom> except with a more honest name
09:53:18 * hackage fused-effects 1.0.2.1 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-1.0.2.1 (joshvera)
09:53:44 <whataday> I wonder if this can be implemented in other languages like js or python?
09:54:02 <monochrom> yes
09:54:08 <whataday> does this depend on type system?
09:54:15 <monochrom> may be an uphill battle but yes
09:54:19 <monochrom> no
09:54:34 <monochrom> to some extent, actually a type system may get in the way.
09:54:48 <monochrom> for example look at how call/cc was invented in the context of lisp with ease.
09:54:57 <Cheery> translation into continuation passing style is relatively "simple"
09:54:58 <whataday> return is here
09:55:00 <monochrom> definitely not invented in the context of algol.
09:55:36 <Cheery> a => (a -> r) -> r
09:55:50 <whataday> but call/cc is not a normal function in scheme anymore
09:55:59 <Cheery> also you may notice it's double negation if you plug Void to 'r'
09:56:04 <whataday> it's a macro IIRC
09:57:04 <maerwald> Cheery: I propose `isolate` as an alternative name
09:57:11 <Cheery> since your input program is made from small functions, you can take those functions and "fmap" each of them.
09:57:33 <whataday> that's composition
09:58:00 <Cheery> eg. fmap ap, fmap pair, fmap cur, etc...
09:58:59 <monochrom> maerwald: I don't quite understand how to think of it as "isolate". Could you explain a bit? Thanks.
09:59:49 <maerwald> isolate a value "into" this domain
10:01:07 <monochrom> I don't think "isolate into" is a thing. It has always been "isolate out of".
10:01:25 <monochrom> or "isolate from"
10:01:40 <maerwald> possible, not my native tongue :p
10:02:10 <Cheery> so if you think about simply typed lambda calculus in that context, context [a] becomes [(a -> r) -> r]
10:03:26 <monochrom> Are you thinking of, e.g., putting a diamond into a pool of mud, but with some protective bag around the diamond, so the diamond is in the mud pool but still somewhat isolated from the mud?
10:04:48 <maerwald> monochrom: given all monads... what return does is "specialise" a value to this monad and not others. So it's isolated from the rest no?
10:04:54 <Cheery> and then f x must become f (\k -> k x) or smt...
10:06:07 <maerwald> m a -> a -- is very hard
10:06:51 <maerwald> so 'a' is sad, it can't play with the other monads
10:06:52 <monochrom> OK, in the sense of one-way-street no-turning-back beyond-point-of-no-return
10:07:14 <monochrom> and leads me to s/return/noreturn/ haha
10:07:20 <Cheery> well monad vs. comonad..
10:07:28 <Cheery> monad would be like.. lions in a jungle
10:07:31 <monochrom> noreturn :: Monad m => a -> m a
10:07:38 <maerwald> lool
10:07:40 <monochrom> noreturn = return
10:07:41 <Cheery> comonad would be like, a lion in a jungle.
10:09:21 <Cheery> oh right.. but yeah. you get the point maybe.
10:09:27 <maerwald> I'll have my burrito with lion meat
10:09:49 <monochrom> This is interesting. I'll have to think about it. I think people won't interpret "isolate" this way, but I think there is another word for this.
10:10:15 <maerwald> ASCENSION
10:10:34 <monochrom> something about die casting, freezing, symmetry breaking.
10:10:36 <Cheery> Burrito Lion as a monad
10:11:21 <maerwald> and runstatet would be descendStateT
10:11:55 <maerwald> lift would be `pray`
10:13:05 <maerwald> hopefully ending up in the right heaven
10:31:06 <__monty__> monochrom: Re nix at /nix, yes. Another place "short" paths help is when patching ELF binaries. You can patch in any path that's equal in length or shorter.
10:31:27 <monochrom> yikes
10:32:13 <hseg> hi. i'm doing some refactoring, and am moving a function out of a class. however, that breaks imports. is there a way to avoid this breakage? is it desirable?
10:32:48 <hseg> (specifically, am moving away from my homebrew ring hierarchy to that of semirings. however, it defines (+),(-),(*),(/) as derived operations)
10:33:12 <hseg> which breaks imports expecting Ring(..) to pull in (-), for example
10:34:32 <hseg> i suppose i could have clients import (+),(-),(*),(/) explicitly, but that gets tiresome fast
10:35:45 <monochrom> Is semiring a superclass of ring?
10:35:53 <hseg> yes
10:36:19 <hseg> Semiring provides (+), (*), fromNatural, Ring provides (-) and fromInteger
10:37:13 <hseg> actually, since i'm using backpack, i *could* enforce that solution by keeping the typeclasses abstract
10:37:20 <monochrom> I think you can draw inspiration from Semigroup superclassing (but retrospectively) Monoid.
10:37:40 <hseg> and just guaranteeing eg an export of (+) :: Semiring r => r -> r -> r
10:38:51 <hseg> didn't that break stuff?
10:38:59 <hseg> can't find the original threads
10:39:29 <monochrom> No, don't look at threads, just look at the class definitions and think of the redundancy
10:39:54 <monochrom> keeping in mind Semigroup was added later
10:40:44 <monochrom> namely, why Monoid has mappend when Semigroup "already" has <>, and how mappend is not going away
10:41:25 <hseg> ah. i suppose that was there to avoid breakage?
10:41:31 <monochrom> Yes.
10:41:51 <hseg> just found out mappend is going to go this winter
10:41:53 <monochrom> What sucks is that now you have to think up two names for the same "+"
10:42:15 <hseg> well, my case seems to be a little easier
10:42:40 <hseg> in that instead of introducing a superclass, i'm moving a function from being a class method to being a global function
10:44:07 <hseg> ... i suppose i *could* rewrite the module signature to have the typeclasses be abstract, forcing all clients to adapt
10:44:39 <hseg> indeed, if the signature had had abstract classes to begin with, i should have been able to make this change with no breakage
10:45:44 <hseg> although that does raise a little pain point in that it would be convenient to be able to extend the import M (C(..),T(..)) syntax to other bundles of functionality
10:46:02 <hseg> ... but arguably those should be submodules
10:46:36 <hseg> at least this is available for pattern synonyms
10:51:21 <monochrom> The problem with abstract type class is that a user cannot make their type an instance of the class.
10:52:19 <monochrom> This is why the Monoid-Semigroup people chose to add redundancy.
10:52:39 <dsal> Which redundancy?
10:52:56 <dsal> Oh.  Started reading backwards.
10:53:04 <monochrom> and yeah maybe mappend will eventually go away but if you count from the inception of Semigroup it's like a decade
10:53:19 <hseg> ... damn, you're right
10:53:43 <hseg> abstract classes basically give us closed type classes
10:54:43 <monochrom> How many users will you be able to victimize? >:)
10:55:05 <hseg> :)
10:55:31 <hseg> need to go, will try alternatives
11:06:16 <Cheery> Can you help me title a FP related blogpost?
11:06:48 <Cheery> http://boxbase.org/unpublished/people-asking-what-is-a-monad/
11:08:02 <MarcelineVQ> oh no :>
11:09:01 <MarcelineVQ> title it "This is not a monad tutorial"
11:10:18 <Cheery> ok.
11:11:07 <MarcelineVQ> That's just a bit of humor, it's just that writing a monad tutorial is a meme so if you start by saying it's not one it adds a layer to the onion
11:11:52 <MarcelineVQ> That and it's not one :>
11:11:53 <Cheery> http://boxbase.org/entries/2020/jun/16/this-is-not-a-monad-tutorial/
11:25:15 <dminuoso> Cheery: I invite you to give this a read: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:27:19 <dminuoso> I wish people would talk about monad tutorials instead of about how other people talk about monads!
11:27:20 <dminuoso> :p
11:31:59 <dsal> The problem I see has more to do with the question than the answers.  "Hello.  I just completed first grade and I got a solid 87% on my addition tests and have a theoretical understanding of subtraction, though no actual experience (yet!).  I just want a simple, practical, explanation of linear algebra without all those fancy words and to know how I can use it to count my halloween candy."
11:38:15 <Cheery> dminuoso: I got an IO monad blogpost in there as well, but reviews to monad tutorials you say?
11:42:49 <Cheery> Oh right. I'm writing that down there and it's probably wrong because you may want to learn monads through "IO monad, Maybe monad, List monad"... etc. Then catch it up from there.
11:43:05 <hc> Cheery: read your article and enjoyed it :)
11:47:31 <Cheery> dminuoso: you know, that article generalises.
11:49:05 <Cheery> I actually had really darn hard time trying to understand category theory.
11:50:22 <PigDude> What does "AT" stand for? And "TF"? re: <https://mail.haskell.org/pipermail/haskell-cafe/2010-August/081969.html>
11:51:52 <merijn> PigDude: TypeFamily presumably for TF
11:54:22 <MarcelineVQ> associated type, type family, functional dependency
11:54:46 <koz_> MarcelineVQ: AT is a better abbreviation than the one I've seen floated, which is 'asstype'.
11:54:52 <koz_> (in a similar light to 'fundep')
11:55:43 <Cheery> I've been considering to name a programming language with some vulgar name.
11:56:59 <dsal> It's been done.
11:57:08 <merijn> Cheery: Coq already exists ;)
11:57:24 <koz_> merijn: Giggle.
11:58:37 <PigDude> thanks merijn, MarcelineVQ !
11:59:14 <Henson> how can I convert something in the "MaybeT m a" monad into the "ExceptT e m a" monad?
11:59:45 <Cheery> is ExceptT something like Either?
12:00:44 <koz_> Henson: Assuming you have some way to produce an 'e', 'runMaybeT', then pattern match?
12:00:49 <Cheery> nope, it's containing Either
12:01:24 <koz_> Actually wait, that won't work lol.
12:01:45 <koz_> (darned 'm' is in the wrong place and I shouldn't reply at 7am)
12:02:06 <Henson> koz_: I tried doing that, but it complains about constructing an infinite type
12:02:35 <Cheery> :t runMaybeT
12:02:37 <lambdabot> error: Variable not in scope: runMaybeT
12:02:59 <Cheery> maybe it's better that is not there.. I'll pop up ghci
12:04:44 <Cheery> runMaybeT brings to m (Maybe a)
12:08:14 <Cheery> :t pure . (fmap (maybe (Left "this is bad") Right)) . runMaybeT
12:08:15 <lambdabot> error:
12:08:15 <lambdabot>     Variable not in scope: runMaybeT :: a -> f1 (Maybe b)
12:08:47 <Cheery> (Functor f1, Applicative f) => MaybeT f1 b -> f (f1 (Either [Char] b))
12:09:46 <Cheery> oh replace pure with ExceptT
12:11:48 <koz_> Cheery: Yeah, I saw this like, five seconds after walking away from the screen.
12:11:56 <koz_> Derp me.
12:12:35 <Cheery> though in transformers  the point is that they form stacks
12:13:32 <Henson> so why doesn't runMaybeT work inside of ExceptT e m a?  Shouldn't it unwrap the "Maybe a" from the "m" and then make that available in the ExceptT monad?
12:14:23 <maerwald> :t ExceptT
12:14:25 <lambdabot> m (Either e a) -> ExceptT e m a
12:14:36 <koz_> Henson: Maybe and MaybeT aren't the same.
12:15:25 <Henson> koz_: yes, but hitting a "MaybeT m a" with runMaybeT results in "m (Maybe a)"
12:18:04 <Henson> koz_: so I don't understand why I can't do something like "maybeValue <- runMaybeT maybeTWrappedValue" inside of an "ExceptT e m a" monad and then do a case statement on maybeValue to either do a throwE or return with the value.
12:18:36 <koz_> What error do you get when you try?
12:26:24 <merijn> Henson: You can't do that because <- is just sugar for >>= and the type of >>= is determined by the type of the do block you're in
12:27:15 <merijn> Henson: Since you are in an ExceptT do block, you're using the 'ExceptT e m' instance of Monad, which doesn't type check with the result of runMaybeT
12:29:22 <maerwald> and the outer m is determined by the maybet function you're running
12:29:52 <maerwald> which is unlikely to be ExceptT
12:35:33 <maerwald> https://hackage.haskell.org/package/errors-2.3.0/docs/Control-Error-Util.html#v:noteT
12:35:43 <maerwald> check that out
12:36:46 <maerwald> I also use the (!?) a lot
12:37:04 <hseg> want to adapt the class hierarchy of another package, injecting a superclass to the entire hierarchy
12:37:58 <hseg> so obvs, i *can* write class (T, P.C) => C; instance (T, P.C) => C in order to inject a T dependency into my version of C
12:38:44 <hseg> but writing such synonyms means that module M (C(..)) doesn't do what I want
12:40:30 <hseg> ... basically what I seem to want is a flexible way of associating functions to constraints
12:40:42 <hseg> so that C(..) picks up the functions I want
12:43:26 <Henson> maerwald: thank you for pointing out the "note" function, I'll take a look at that.
13:07:48 <merijn> hseg: I recommend forking/upstreaming (if possible/acceptable) your change
13:07:57 <merijn> hseg: Because that's doomed
13:08:33 <hseg> the change i'm after is pretty specific to my use case, i'm afraid
13:08:57 <hseg> upstream might surprise me and say they actually want it
13:09:33 <merijn> If upstreaming isn't an option, then I recommend changing your wants :p
13:10:02 <merijn> Because changing what you want will be considerably easier and more maintenanble than whatever implementation (if any) does what you asked :p
13:10:10 <hseg> :D
13:10:50 <hseg> ... I suppose I could litter my code with explicit constraining on that top class
13:10:57 <hseg> but that would be *ugly*
13:11:44 <merijn> hseg: You know you can define synonyms for (groups of) constraints, right?
13:12:02 <hseg> yeah, but that's where i got stuck
13:12:32 <hseg> i'm using a package that has hierarchy (S => R, E => F), I want to add a class U => S
13:12:44 <hseg> and have all the classes pick up a U dependency
13:13:28 <hseg> if the classes had no methods, a simple class (U, P.S) => S; instance (U, P.S) => S and idem for the others would suffice
13:13:38 <hseg> but that breaks module M (S(..))
13:23:22 <hseg> let's bite the bullet and use the upstream hierarchy, then
13:30:20 <kuribas> cabal new-build fails because I have a documentation: True in my cabal config, and hackage is failing for a single package
13:30:26 <kuribas> (fast-logger)
13:30:36 <merijn> kuribas: You can override the option for that package
13:30:43 <kuribas> how?
13:30:56 <merijn> "package fast-logger\n    documentation: False"
13:31:01 <merijn> in cabal.project
13:31:07 <sclv> iirc newer cabals won’t hard fail if a single doc fails
13:31:10 <merijn> Assuming I recall the correct syntax of the top of my head
13:31:14 <sclv> It was a bug that was fixed?
13:33:15 <kuribas> in fact, the offending line looks perfectly fine: 
13:33:18 <kuribas> LogNone :: LogType' LogStr    -- ^ No logging.
13:34:26 <kuribas> is haddock tied to the ghc version?
13:37:28 <merijn> yes
13:37:42 <kuribas> so I am stuck with a broken haddock?
13:38:11 <kuribas> I want to pin down the ghc version to use
13:38:28 <kuribas> ghc 8.4.4, which is actually quite recent
13:44:51 <kuribas> ok, turning it off in the config helps...
13:48:41 <Tritlo> Is there any way to make GHC fully evaluate a type family with UndecideableInstances?
13:52:34 <Tritlo> https://www.irccloud.com/pastebin/xFeSeA3h/
13:53:08 <koz_> What's the name of the program that draws you an import dependency graph when fed a bunch of .hs files?
13:54:17 <koz_> graphmod, lol.
13:56:26 <dmwit> Tritlo: It will not return "other o" when the type cannot be determined; only when the type can be determined enough to know it definitely isn't A or B.
13:56:29 <dmwit> Which presumably is never.
13:56:58 <dmwit> The answer to "is there any way to make GHC fully evaluate a type family", you can ask ghci to evaluate type family applications with :kind!
13:57:05 <ahmr88> Hi everyone, I'm relatively new to haskell and have recently switched to Arch linux. I'm trying to setup my development environment (cabal and ghcide) but I keep running into static and dynamic linking problems which I don't really understand. Does anyone know of some sort of step-by-step article or guide to properly set this up?
13:57:42 <Tritlo> dmwit: ah, that makes sense
13:57:47 <dmwit> ahmr88: Yes, don't use ghc from arch's package manager.
13:58:00 <dmwit> ahmr88: Get it from GHC's official site or from ghcup.
13:58:17 <koz_> Yeah, this.
13:58:19 <Tritlo> dmwit: the thing is, GHC could do this, since you don't need to have the type when you do "lookupFamInst"
13:58:48 <dmwit> I don't know what the "this" in "GHC could do this" is, and I don't know what lookupFamInst is.
13:58:54 <ahmr88> alright I'll try that now thanks!
13:59:42 <Tritlo> dmwit: The way GHC solves type families internally is that it creates a FamInstEnv and then it does `lookupFamInstEnv envs familyConstructor arguments`
14:01:11 <Tritlo> dmwit: and if there is a "catch-all" match, that's the one that would be returned if the argument was a type variable still, and not a specific type at that point
14:02:00 <dmwit> I don't really know what you're getting at. But I do not think it would be sound to behave in the way you appear to want it to behave.
14:02:07 <Tritlo> dmwit: so in the example above, `lookupFamInstEnv envs F [l]` would return the "Text other case"
14:02:27 <Tritlo> dmwit: I agree, it's not sound... but neither is UndecideableInstances
14:02:47 <dmwit> UndecidableInstances is sound. It can just loop, which is completely different from using a value of one type in a context expecting a different type.
14:03:08 <Tritlo> dmwit: I guess I mean Incoherent instances
14:03:34 <dmwit> Okay. I don't think anybody actually endorses the use of incoherent instances any more, to the point that I don't even bother keeping in my mind what it does.
14:04:02 <dmwit> (So I don't even know whether it's sound. I think it probably is, but... even if it's not, I don't think that makes it a good argument that other extensions should also be unsound.)
14:04:06 <Tritlo> dmwit: it allows GHC to match an arbitrary instance when there are multiple matches
14:04:26 <Tritlo> so I guess what I want is a way to mark type family instances as incoherent
14:04:32 <dmwit> Okay. Nothing about that sounds unsound to me. Perhaps you get surprising behavior, but not type-incorrect. The feature you are proposing would be type-incorrect.
14:04:43 <dolio> Yeah, it's not unsound.
14:05:17 <Tritlo> What's type incorrect here? If you know what the type is, return whatever the match is, otherwise return the catch all
14:05:41 <Tritlo> I'm not using this for any type resolution, I'm trying to make my custom TypeError messages prettier
14:06:12 <ahmr88> dmwit: Do I have to uninstall the ghc installed by pacman?
14:06:30 <dmwit> Imagine `type family Foo a where Foo Int = Int; Foo a = Bool`. Now I implement `foo :: Maybe a -> Foo a -> Bool; foo _ x = x`. This type checks because in the type signature for `foo`, `a` is not known and so it return `Bool`.
14:06:43 <Tritlo> In the sense that I want TypeError (Text "Got value of type " :<>: F l) to either say "A" or "B" if l is known, but say "other" otherwise.
14:07:09 <dmwit> Now I write `foo (Just 3) 3`. This type checks because `Just 3 :: Maybe Int` and `3 :: Foo Int = Int`.
14:07:19 <dmwit> So now after reduction I get `3 :: Bool`. Whoops.
14:07:33 <dmwit> ahmr88: I would.
14:07:37 <Tritlo> dmwit: I know, that's why it has to be labeled "incoherent", known to be unsafe
14:07:47 <dmwit> ahmr88: But the answer is: no, you probably don't have to.
14:08:02 <ahmr88> dmwit: Won't that break xmonad? xD
14:08:07 <ahmr88> I did it anyway
14:08:16 <dmwit> Tritlo: This is worse than merely incoherent. It allows you to treat values of one type as another type. No other extension allows you to do that.
14:08:38 <Tritlo> dmwit: Because you don't need an extension for that, unsafeCoerce works just fine :P
14:08:46 <dolio> Incoherent types are unsound. Incoherent choices between two runtime implementations of the same type aren't.
14:08:53 <dmwit> ahmr88: I don't know. But it is certainly possible to run xmonad without having ghc installed from Arch's package manager. Source: I have run xmonad on a system that is not arch and so didn't even have arch's package manager installed. =P
14:09:26 <dmwit> Tritlo: "X is bad" is not a good argument for "let's allow Y, which is also bad".
14:09:50 <dmwit> Tritlo: What's more, I'm sorry I brought up the fact that other extensions don't do this.
14:10:09 <Tritlo> dmwit: I can't make the messages pretty without something like this. My argument is that I have a use case: generating prettier TypeErrors
14:10:10 <dmwit> Tritlo: It is unsound, and that is enough of an argument against for me, independently of whether other extensions or features are unsound.
14:10:34 <Tritlo> dmwit: whenever you have a value of TypeError, you are already in an error state
14:11:58 <Tritlo> dmwit: so any unsoundness at that point doesn't matter, you can't do anything bad
14:14:42 <dmwit> I would be mildly interested to hear about a solution which enabled prettier error messages but did not give us another potential source of bugs.
14:15:18 * hackage blanks 0.4.1 - Fill-in-the-blanks - A library factoring out substitution from ASTs  https://hackage.haskell.org/package/blanks-0.4.1 (ejconlon)
14:15:33 <Tritlo> dmwit: how about this: whenever you are tying to "solve" a type error constraing, look *really* hard through any type families
14:17:47 <dmwit> How do you avoid having exactly the same problem inside the type error?
14:18:11 <dmwit> (And therefore reporting an incorrect error, because you "simplified" something incorrectly?)
14:18:35 <Tritlo> You do this as the last step I would think
14:18:42 <Tritlo> You could even do it in a plugin
14:19:03 <dmwit> I don't see how that would prevent the bug I am describing.
14:19:29 <monochrom> Hrm, I thought Text.Printf used IncoherentInstance. Maybe it did a long time ago and I remembered it right. But today it's like {-# LANGUAGE Safe, GADTs #-} and that's it.
14:19:50 <Tritlo> The plugin only runs after GHC has given it's best shot. So you only simplify when you know that GHC can't go any further.
14:20:02 <monochrom> Apparently the trick is to write like "instance (a ~ ()) => PrintfType (IO a)"
14:20:05 <dmwit> But you still may do an incorrect simplification.
14:20:19 <dmwit> e.g simplifying something to Bool that might actually become Int in a different instantiation.
14:20:44 <dmwit> And then your type error says "Hey, in my friendly DSL, I was looking for a Bool in this spot" but secretly it would also have accepted an Int there in some circumstances.
14:21:18 <monochrom> The comments in the source code also seem to say that an IsChar class is provided, and that relieves you from needing FlexibleInstances even.
14:21:35 <dmwit> So now you have a bug in your type error reporting code, because you allowed unsoundness in the type family reductions.
14:21:51 <Tritlo> dmwit: you could restrict it to only type families that return error messages
14:22:05 <dmwit> I'm specifically talking about a type family that produces an error message here!
14:22:30 <monochrom> But basically Text.Printf was the last moral use of IncoherentInstances I've ever seen.
14:22:34 <Tritlo> dmwit: and yes, if you write your type error generator and include a catch all, then yes, you might return a sub optimal error
14:23:15 <dmwit> Okay. Since it's really easy to prevent that bug, just by not changing GHC at all, I say we prevent that bug.
14:23:30 <Tritlo> And have suboptimal type errors, fine
14:23:32 <monochrom> Haha even https://aphyr.com/posts/342-typing-the-technical-interview doesn't need IncoherentInstances, only Undecidable.
14:24:07 <merijn> monochrom: That entire post series is absolutely amazing :)
14:24:11 <dmwit> Better a slightly-difficult-to-understand error than an incorrect one, IMO.
14:24:29 <Tritlo> dmwit: I'd want to leave that to the DSL author :)
14:24:50 <dmwit> I don't trust the DSL author (usually, me).
14:24:55 <merijn> Tritlo: Then write a compiler for your DSL :p
14:25:03 <dmwit> He writes too many bugs to eschew tools that rule out entire bug classes.
14:25:41 <Tritlo> merijn: that's what I'm doing :P
14:26:21 <merijn> Tritlo: If you were then it wouldn't be relevant what GHC does/did
14:26:34 <dmwit> Anyway, if you give a bit more detail about what you're trying to do, we may be able to suggest an alternative solution for you.
14:26:45 <Tritlo> merijn: it's using GHC + type checker plugins to do what it should do
14:26:47 <monochrom> I don't understand the purpose of this conversation. Let me know if I'm wrong, here is my understanding.
14:27:15 <monochrom> X claims to ask "I'm using IncoherenceInstances for this use case, what do you think?"
14:27:20 <monochrom> claims
14:27:23 <dmwit> (Like, is `ShowType` good enough?)
14:27:46 <monochrom> Y gives an honest answer. It's what Y thinks. Maybe debatable but the literal question is "what do you think?"
14:27:55 <dmwit> monochrom: Nope. Incoherent instances was brought up only as an example of another extension that does something bad, to defend a proposed change to GHC that does something bad.
14:28:12 <Tritlo> dmwit: I am using ShowType, but I want to pretty print the internal type to not leak details to the user. So it's calling `(ShowType (TyPpr ty))`
14:28:24 <monochrom> Now X reveals their true purpose: To talk and argue and drag on in hope that Y will change to saying "yes good".
14:28:28 <dmwit> monochrom: The actual core of the conversation is "I want `type family Foo a where Foo Int = Bool; Foo a = String` to have `Foo a` reduce to `String`.
14:28:32 <dmwit> "
14:28:59 <merijn> dmwit: Possible with closed type families
14:29:22 <monochrom> Because, like, if you really meant to ask "what do you think?", then no matter whether you like the answer or not, you just conclude "thanks for the feedback, I'll think about it", end of story. That takes only 3 minutes., not this 20 minutes ordeal.
14:29:48 <dmwit> merijn: No. `Foo a` will not reduce to `String` unless we know enough about `a` to know it is not `Int`.
14:29:50 <Tritlo> dmwit: where `TyPpr` pretty prints the type, to remove implementation details. In this context, `ty` is a `Label` for data, used to differentiate between `Public` and `Secret` data.
14:30:29 <merijn> dmwit: Oh, you mean an "forall a . Foo a" as opposed to 'any specific a'
14:30:43 <Tritlo> So you're looking at something like `Labeled (l :: Label) a`
14:31:09 <dolio> merijn: That's the case incoherent instances covers, yeah.
14:31:15 <Tritlo> So, it should print `Public a` if `l ~ L`, `Secret a` if `l ~ H`, but otherwise it should print `Labeled l a`. 
14:31:36 <Tritlo> But since it doesn't try if it doesn't know enough, it prints `TyPpr a`
14:32:14 <Tritlo> Instead of printing `Labeled l`
14:33:00 <Tritlo> monochrom: I don't get what you're saying here, I genuinely think this would improve the situation. I'm not trying to change dmwit's mind :P
14:33:24 <dolio> It lets you use 'instance Foo a ...' even when more specific Foo instances are known to exist.
14:33:27 <monochrom> And me, I don't get why you need say more at all.
14:33:41 <Tritlo> monochrom: sorry I wasted your precious time xD
14:33:59 <monochrom> No, this is not about time, this is about honesty.
14:34:18 <Tritlo> monochrom: what?
14:34:41 <monochrom> There is a difference between "what do you think?" and "you just approve this".
14:35:00 <Tritlo> monochrom: I literally opened with, "how can I do this?"
14:35:10 <Tritlo> monochrom: not trying to get anyones approval
14:35:47 <monochrom> OK, so how do we do this without IncoherentInstances?
14:37:01 <Tritlo> monochrom: You write a type checker plugin that, when it encounters a TypeError wanted, looks through the value and checks if it an improve some type family application in an argument of `ShowTy`
14:38:07 <Tritlo> monochrom: I've learned from dmwit that this would be a bad idea for type families in general, but I think it should be OK for a `TypeError` + explicit opt-in via enabling a plugin.
15:25:49 * hackage glpk-headers 0.3.0 - Low-level Haskell bindings to GLPK.  https://hackage.haskell.org/package/glpk-headers-0.3.0 (prsteele)
15:38:21 --- mode: card.freenode.net set +o ChanServ
15:38:51 --- mode: card.freenode.net set +o Sigyn
15:42:18 * hackage flow2dot 0.9.2 - Library and binary to generate sequence/flow diagrams from plain text source  https://hackage.haskell.org/package/flow2dot-0.9.2 (DmitryAstapov)
15:45:36 <_deepfire> what a beautiful netsplit..
15:45:56 * _deepfire waves at coot
15:45:59 <joeyh> oh nm, those symbols do get stripped
15:46:18 <Rembane> The Matrix went boom. 
15:51:18 * hackage glpk-headers 0.4.0 - Low-level Haskell bindings to GLPK.  https://hackage.haskell.org/package/glpk-headers-0.4.0 (prsteele)
15:54:48 * hackage fused-effects 1.0.2.2 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-1.0.2.2 (joshvera)
16:08:23 <livvy> shameless plug but apt timing I'm teaching myself Haskell by writing (yet another, probably crappy) matrix SDK thingy that someone else has probably already wrote
16:09:26 <monochrom> :)
16:09:36 <MarcelineVQ> competition is healthy
16:09:47 <koz_> Reinventing the wheel for learning purposes is also totes good.
16:10:08 <MarcelineVQ> as long as you're not reinventing spokes too, spokes are a solved problem
16:10:33 <koz_> MarcelineVQ's world: Square wheel fine, spokeless wheel TOTES BADWRONG.
16:11:27 <MarcelineVQ> square wheels are good because gravity does the job for half the rotation, so you can use that stroke half to store power
16:11:34 * monochrom uses a machine learning algorithm to learn "so convex wheels are OK, non-convex wheels are bad".
16:11:59 <koz_> monochrom: Cool, now you can get published!
16:12:06 <MarcelineVQ> your choice of flywheel storage or electric
16:12:16 <koz_> "A new approach to innovation using [insert whatever framework you used for 10 seconds]"
16:12:38 <MarcelineVQ> 'on the unreasonable effectivness of spokeless wheels'
16:12:58 <koz_> 'Non-convex wheels considered harmful'
16:13:25 <MarcelineVQ> concave wheels, a exciting new frontier in quality diversity
16:13:44 <koz_> 'Lazy functional state wheels'
16:14:45 <MarcelineVQ> type-level wheels, minimal example of solving 4 colors problem via rotation
16:15:15 <koz_> "Record syntax: the problem, and its solution, using wheels"
16:15:35 <MarcelineVQ> exensible traversals using wheels
16:15:36 <koz_> (that's probably a ZuriHack talk)
16:15:56 <koz_> "Wheels: a categorical view"
16:17:01 <MarcelineVQ> intuitionistic modal travel, why box wheel and diamond wheel are really the same thing at the appropriate layer of abstraction
16:17:18 <koz_> "Wheels are calling conventions"
16:18:07 <MarcelineVQ> using static wheels to provide analysis of shifts
16:19:01 <koz_> "Recursive functions of symbolic expressions and their computation by wheel"
16:19:14 <MarcelineVQ> spinning disk optics: a new framework for deep data traversal
16:20:00 <koz_> Optimizing the optimizer: how GHC learned the wheel.
16:20:11 <koz_> (I am kinda shocked that this is probably an actual paper title)
16:20:17 <koz_> (or could be)
16:20:26 <MarcelineVQ> the hubless spokeless w machine
16:20:30 <koz_> LOL
16:20:39 <koz_> OK, I can't top that.
16:21:32 * MarcelineVQ spits fire from the mountaintop
16:29:45 <carter> Magnets.
16:30:52 <dsal> Damn.  Just saw this:  https://reasonablypolymorphic.com/blog/mea-culpa/index.html
16:30:58 <dsal> I thought polysemy cured all the things.
16:31:26 <koz_> dsal: It was supposed to, but then Sandy moved on to other things.
16:31:32 <koz_> Have you seen Alexis' talk?
16:31:34 <koz_> If not, _do_.
16:31:41 <koz_> It's fun, educational _and_ insightful.
16:31:58 <dsal> Yeah, I want to check out some of those things.  I need a list.  :)
16:34:28 <livvy> :D
16:40:26 <livvy> dsal: too many tech (talks|librarys|tools|blog posts) for me to keep up on :')
17:53:55 <justape> What is the disadvantage of dependent typing? I’m reading up on it and seems almost too good to be true, yet there are very few dependently typed languages. I’m specifically reading up on Agda.
17:54:06 <koz_> justape: It's fairly involved.
17:54:23 <koz_> The biggest disadvantage of dependent typing is that it requires a lot more from the user.
17:54:33 <koz_> Especially once you start doing bigger stuff with it.
17:54:58 <justape> koz_: ok that makes sense. Seems very worth learning it though.
17:55:25 <koz_> Oh, I agree.
18:00:19 <d34df00d> Uniplate question: let's say I have `data TermT ann  = TName ann VarName | ...` and I wan to write a function that replaces all occurrences of a variable name with another variable in a term.
18:00:37 <d34df00d> This is easy: I just do `renameVar :: forall a. Data a => VarName -> VarName -> TermT a -> TermT a ; renameVar what with = transformBi f` with the obvious `f`
18:01:08 <d34df00d> BTW it seems I do need `Data a` constraint here, otherwise transformBi isn't happy.
18:01:42 <MarcelineVQ> justache, koz_: In particular a big tradeoff is that it's often much more work to refactor dependent things, especially proofs because proofs depend on the specific structure of your datatypes. languages like coq have an advantage there because you can write/use tactics that automate a lot of proof solving which makes proofs more robust against refactoring, but then you have to know one or more more tactic language and many tactic libraries
18:01:54 <d34df00d> Having this, how do I write a function that replaces VarName with another VarName (using renameVar, I guess?) in an arbitrary type containing `TermT a`?
18:01:57 <Cale> justape: One thing I'll say is that just as a more powerful type system can give you a lot of power to ensure things which are important, it can also give you a lot of power to guarantee things which are ultimately unimportant. It's possible to create bureaucratic nightmares, or to simply end up writing your program twice.
18:02:32 <Cale> (once in the form of a specification, and then again in the form of something which satisfies it)
18:02:33 <d34df00d> I tried writing (very obvious) `renameVar' :: Data from => VarName -> VarName -> from -> from ; renameVar' what with = transformBi (renameVar what with)`, but it doesn't typecheck.
18:02:44 <MarcelineVQ> There's also this oddness where you might get a lot of benefit from writing stronger types but you also lose a lot of type inference
18:02:52 <d34df00d> Which makes sense: there's no way to guarantee `Data a` for the terms in `from`.
18:03:29 <MarcelineVQ> And good type inference is really handy to have when refactoring, which (because humans are iterative) tends to be most of coding
18:03:34 <d34df00d> MarcelineVQ: my experience with Coq (following CPDT) is that tactic-based proofs are about as fragile as explicit proof terms.
18:04:05 <d34df00d> It's sometimes sufficient to swap two sides of an equality statement for the proposed tactics script to stop working with uninterpretable error messages.
18:06:52 <Cale> A random thought I had today: how useful/possible might it be to have a language feature which could take a term all of whose definitions are transparent, and re-examine the definitions involved in order to try to give the result a different, specified type? There's probably some limitations on what the term can be, perhaps just a name of something.
18:07:52 <Cale> It obviously breaks referential transparency.
18:08:37 <d34df00d> Alright, another stupid question: I have the following definition with ScopedTypeVariables enabled:
18:08:42 <d34df00d> renameVar' :: (forall a from. Data a, Data from) => Proxy a -> VarName -> VarName -> from -> from
18:08:44 <d34df00d> renameVar' _ what with = transformBi (renameVar @a what with)
18:08:56 <d34df00d> Yet I get `Not in scope: type variable ‘a’`
18:08:56 <d34df00d> Why?
18:09:12 <Cale> Because you bound the a inside the constraint?
18:09:24 <Cale> and so it scopes only over the Data a constraint
18:09:45 <Cale> you probably meant to have forall a from. (Data a, Data from) => ...
18:09:52 <d34df00d> Dammit.
18:10:13 <d34df00d> Cale: you're right, thanks!
18:10:23 <d34df00d> That was a super mindfart on my side.
18:12:45 <jusss> "all animals are equal, but some are more equal than others", so typeclass is a racist?
18:19:50 <ja> that quote is from Animal Farm and it has nothing to do with race
18:55:09 <freeman42x[m]> how can I achieve code reuse similar to inheritance in the example here? https://github.com/razvan-flavius-panda/Everything-Manager/blob/master/Main.hs#L18
19:00:25 <jusss> t = (\k -> k $ (+1) 2) >>= (\r -> (\k2 -> k2 r))
19:00:29 <jusss> t (+3) (+9) == 15
19:00:31 <Cale> freeman42x[m]: What repetition do you want to eliminate?
19:00:41 <jusss> why this don't work?
19:01:06 <jusss>   The type variable ‘a0’ is ambiguous
19:01:15 <jusss>  To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
19:03:12 <koz_> jusss: Does 't' have a type signature?
19:04:26 <justsomeguy> As a beginner, t looks almost obfuscated.
19:04:32 <jusss> koz_: Cont r b?
19:05:11 <jusss> oh,
19:05:17 <jusss> t (+3) == 9
19:06:29 <jusss> I don't know what is passing here in >>= when monad is Cont r
19:07:43 <jusss> when k is (+3) then r is 6, and k2 is (+3) again? then t (+3) is 9
19:07:54 <jusss> but why this k2 need to be same as k?
19:07:58 <monochrom> I don't think Cont is involved at all.
19:08:30 <monochrom> Instead, it seems like the Monad instance inferred is (->) XXX
19:08:47 <jusss> you mean Reader?
19:08:54 <monochrom> No, not even Reader.
19:10:01 <monochrom> Nothing in your expression has any reason to have a Cont type or a Reader type. However, it totally begins with a function type.
19:11:02 <jusss> monochrom: does it need to be with Cont constructor so that to be a Cont type?
19:11:17 <monochrom> or something that has a Cont type.
19:11:39 <jusss> monochrom: \k -> k 3 has a Cont type?
19:11:59 <monochrom> You know how to use the computer to settle that question.
19:12:02 <monochrom> @type \k -> k 3
19:12:04 <lambdabot> Num t1 => (t1 -> t2) -> t2
19:12:38 <monochrom> But I can understand the psychology of not wanting computer facts to burst dreams.
19:13:03 <jusss> monochrom: \k -> k 3 has a Cont type?
19:13:27 <monochrom> You know how to use the computer to settle that question.
19:13:50 <jusss> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
19:14:42 <monochrom> Go argue with the computer.
19:16:39 <jusss> but there's no Cont... there's only ContT in computer...
19:16:50 <jusss> like that ReaderT WriterT StateT
19:17:09 <jusss> why we couldn't have simple types just like Maybe and Either etc...
19:17:27 <monochrom> You can define your own.
19:18:24 <jusss> yeah, with a Identity we can get Reader from ReaderT etc
19:19:58 <jusss> an unary function id, Reader id :: Reader a a, but id doesn't has Reader a a
19:20:02 <jusss> that's not faire
19:20:22 <freeman42x[m]> Cale: For now I would like to eliminate the code duplication coming from having to repeat the description field 3 times. In the future more common fields might be added besides description
19:20:56 <monochrom> "fairness" is a social construct
19:21:38 <jusss> that function composition has the same behavior with Reader apply on fmap
19:21:40 * justsomeguy is an anti-social construct.
19:21:52 <monochrom> :)
19:22:24 <jusss> wait a sec, why function could do >>= ?
19:22:32 <jusss> function is not a type
19:22:44 <Cale> freeman42x[m]: I mean, you can define a data type for Description, and add a field of that type of your other types.
19:22:52 <Cale> freeman42x[m]: But... it's just Text for now.
19:23:45 <int-e> (+3) >>= (*) $ 7 -- (7+3) * 7 = 70
19:23:46 <jusss> why >>= can apply on id? id doesn't have a type for >>=
19:23:55 <Cale> :t (>>=)
19:23:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:24:00 <jusss> :t id
19:24:01 <lambdabot> a -> a
19:24:04 <Cale> If a = m b
19:24:04 <jchia1> cabal question: Why do items in build-depends need to be separated by comma even when they are on different lines but items in exposed-modules don't? What's an efficient way to understand cabal file schema in a 'strongly-typed' way?
19:24:12 <int-e> > (+3) >>= (*) $ 7 -- 7 * (7+3)
19:24:14 <lambdabot>  70
19:24:24 <Cale> then (>>=) can have type m (m b) -> (m b -> m b) -> m b
19:24:39 <jusss> id :: a -> a, id doesn't contain a monad in it
19:24:49 <Cale> a there can be *any* type
19:24:56 <int-e> jusss: There's a Monad instance for (->) r, with return = id and  f (>>=) g = \x -> g x (f x).
19:25:12 <int-e> uh, I mean f >>= g = ...
19:25:14 <jusss> fine, then why >>= can apply on (+1)?
19:25:25 <int-e> (+1) :: Num a => a -> a
19:25:42 <monochrom> No, return = const
19:25:47 <Cale> Ah, you mean id as the other argument?
19:25:50 <int-e> monochrom: ooph
19:25:52 <Cale> id >>= f?
19:26:05 <int-e> which is Num a => (->) a a, so it does fit the type.
19:26:07 <Cale> In that case, we have m a = a -> a
19:26:21 <int-e> monochrom: That was *ask*ing for trouble.
19:26:28 <jusss> int-e: but this (->) r is not same as Reader , right?
19:26:40 <int-e> jusss: It's not the same, but isomorphic.
19:26:41 <jusss> (-> ) r and Reader are two different things
19:26:44 <int-e> :i Reader
19:26:45 <monochrom> jchia1: I'm pretty sure "understand cabal file schema in a 'strongly-typed' way" is barking up the wrong tree.  Someone designed this syntax, you just have to cope with it.
19:27:01 <int-e> oh right, that doesn't exist.
19:27:06 <monochrom> And perhaps the someone was misguided, forgetful, inconsistent. So be it.
19:27:11 <int-e> @src Reader
19:27:11 <lambdabot> type Reader r = ReaderT r Identity
19:27:11 <lambdabot> --OR
19:27:11 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
19:27:13 <jchia1> monochrom: Doesn't the syntax correspond to some internal data structure?
19:27:33 <monochrom> True and irrelevant.
19:28:00 <monochrom> But I should take my own advice.
19:28:03 <jusss> int-e: what is isomorphic?
19:28:07 <monochrom> What's your real question?
19:28:10 <int-e> The older `newtype Reader r a = Reader { runReader :: r -> a }` makes the relation more obvious.
19:28:17 <jusss> a . b = id, a and b are isomorphic?
19:28:33 <jchia1> Is there a good reason for the difference or it's just noise that I don't need to think too much about?
19:28:46 <nshepperd2> like many things in computing, cabal's syntax is a bitter mystery
19:28:50 <monochrom> You're certainly overthinking it.
19:28:56 <jchia1> Like special cases in the English language
19:29:04 <Cale> jusss: X and Y are isomorphic types if there exist functions f :: X -> Y and g :: Y -> X such that f . g = id and g . f = id
19:29:24 <jchia1> well, then, is build-depends the only special case that requires commas?
19:29:26 <dolio> Depedencies are harder to parse without delimiters than module names.
19:29:27 <jusss> int-e: yeah, but they remove it, and define it with ReaderT and Identity
19:29:34 <int-e> jusss: There's a bijection between the two (reader :: (r -> a) -> Reader r a, and runReader :: Reader r a -> r -> a), and furthermore, this bijection preserves the Monad instance.
19:30:27 <int-e> :t reader -- actually this one is more polymorphic but that obscures the fact that it's an inverse of runReader
19:30:29 <lambdabot> MonadReader r m => (r -> a) -> m a
19:30:36 <jusss> Cale: int-e id :: a -> a, could we say id contains a Reader ?
19:30:54 <jusss> id contains (a->)
19:31:02 <int-e> id is an action in the reader monad.
19:31:03 <int-e> :t ask
19:31:04 <lambdabot> MonadReader r m => m r
19:31:43 <jusss> ask is a action, id isn't
19:31:45 <int-e> For m = (->) r,  m r is r -> r, the type of id.
19:32:18 <jusss> id is a function, this ask action get id's result
19:32:25 <int-e> And in fact, instance MonadReader r ((->) r) where ask = id
19:32:38 <Cale> I mean, if you want to call (->) a the "reader monad" -- it's basically the same thing
19:33:21 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:33:22 <lambdabot>  ("hello","olleh","HELLO")
19:33:31 <jusss> Cale: and call (a -> r) -> the Cont monad?
19:33:44 <int-e> > runReader ask 5
19:33:46 <lambdabot>  5
19:33:50 <Cale> You can't use the Cont monad unwrapped like this
19:33:59 <int-e> > ($) id 5
19:34:00 <lambdabot>  5
19:34:06 <jusss> Cale: but you did that with Reader
19:34:27 <Cale> Yeah, that can be done because m a = e -> a can be written as m = (->) e
19:34:28 <int-e> jusss: They are separate class instances.
19:34:42 <Cale> and so we can write an instance like
19:34:52 <Cale> instance Monad ((->) e) where
19:34:56 <Cale>   return = const
19:35:10 <Cale>   (f >>= g) x = g (f x) x
19:35:16 <int-e> jusss: There's a Monad instance for  ReaderT m r  which implies one for Reader r. There's a separate instance for (->) r. They are behaviorally the same.
19:35:51 <jusss> Cale: (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello" ; I think this not gonna work on ghci
19:36:00 <monochrom> jchia1: "Some fields take lists of values, which are optionally separated by commas, except for the build-depends field, where the commas are mandatory."  from the cabal user's guide.
19:36:03 <int-e> Uhm, the order is ReaderT r m.
19:36:05 <Cale> It will if the instance is in scope
19:36:25 <jchia1> monochrom: Thanks
19:36:27 <monochrom> I think it would do you a lot of good to carefully read the cabal user's guide instead of theorizing it.
19:36:33 <Cale> jusss: Which ghci are you using?
19:36:40 <Cale> jusss: Oh, you also need to import Data.Char
19:36:44 <Cale> (for toUpper)
19:37:24 <MarcelineVQ> monochrom: hehe, "cabal dev: so you see, build depends isn't weird, it's the only not weird one! ... that's my story and I'm sticking to it"
19:37:46 <jchia1> monochrom: I know, but it's a long document
19:37:55 <monochrom> something about every natural number is special.
19:37:58 <jusss>  (do x <- (+1); y <- (+2); return x+y) 3  why this don't work?
19:38:22 <int-e> return (x+y)
19:38:47 <jusss> int-e: ...
19:38:49 <Cale> Remember that return is an ordinary function, it's not syntax
19:38:59 <jusss> you're right
19:39:07 <monochrom> I wonder if every real number is special, too.
19:39:42 <monochrom> oops, I would need the set of not-special real numbers to be bounded above or below.
19:40:03 <jusss> int-e: r-> and Reader r have the same behavior, but (a -> r) -> and Cont r don't?
19:41:35 <monochrom> This is when you need to take nominal typing seriously.
19:41:37 <int-e> jusss: You're missing an r, I think. Cont r a and (a -> r) -> r are isomorphic as types but they have fundamentally different Monad instances associated with them.
19:42:28 <int-e> jusss: The Monad instance would be that for (->) (a -> r), so a (somewhat strange) reader.
19:45:26 <wunderbrick> I'm working through Haskell Programming from First Principles and I'm stuck on writing a functor instance. Can anyone tell me what silly thing I'm doing? I just pasted the relevant errors below each fmap attempt in the type class instance:
19:45:32 <wunderbrick> https://pastebin.com/rcnUsPTu
19:46:55 <monochrom> You need both (f b) and (f b'). There are many reasons why. The most visible one is that the types force it.
19:47:27 <monochrom> You're looking at: fmap :: (t -> u) -> Three' a t -> Three' a u
19:47:38 <jusss> int-e: I see, but could we use functions to implement Cont monad?
19:47:56 <jusss> in the other languages, they don't have value constructor
19:48:13 <jusss> or they use class to implement constructor but it's limited
19:48:42 <jusss> and functions are common in most languages
19:48:43 <wunderbrick> monochrom: Thanks!
19:49:32 <wunderbrick> monochrom: I thought if I did (f b) also I would be modifying the structure and not just the inner most value.
19:50:10 <monochrom> No, the only structure here is: 1. You have the Three' constructor; 2. Its first field has value a.
19:51:06 <monochrom> err, there is a 3rd.  Three' a (f b') (f b)  (swapping) would modify the structure.  But we aren't swapping.  We're safe.
19:51:26 <wunderbrick> So is this not valid then?
19:51:27 <wunderbrick> https://pastebin.com/UTM7Ghqa
19:52:19 <monochrom> That one is valid.  fmap :: (t -> u) -> Three a b t -> Three a b u.  You can only work on the c field.
19:52:33 <int-e> jusss: Not plain functions, no. But once you stuff the plain function into a newtype wrapper, you can implement a Monad instance for the continuation monad. That's basically what Cont is.
19:53:57 <wunderbrick> I think I get it now. Thank you!
19:54:21 <int-e> (Of course Cont is a type alias for the most silly "transformer" of all time... with a monad instance that doesn't use the "underlying" monad at all.)
19:54:39 <monochrom> How do I know what counts as structure and what don't?  I don't actually know.  "preserve structure" is deliberately vague, open-ended, vulnerable to misinterpretation, in hope that it's also intuitive.
19:55:01 <monochrom> The only reliable condition is the functor laws.
19:55:24 <monochrom> Functor laws written out for Three and Three' are pretty different.
19:56:36 <monochrom> err, I guess types and functor laws.
19:56:46 <wunderbrick> I think I see.
19:57:28 <int-e> monochrom: Yeah a workable proxy for "structure of x" is the result of `fmap (const ()) x`
19:57:54 <wunderbrick> Sorry if I'm not explaining this well or using the incorrect terms as I'm pretty new to this but without the (f b) in Three' I would be ignoring part of the inner most value.
19:58:07 <wunderbrick> Actually
19:58:21 <int-e> But that makes "structure-preserving" useless for *specifying* how fmap is supposed to work.
19:58:39 <wunderbrick> I'm kind of going off how tuple works with that example.
19:59:53 <int-e> wunderbrick: It's usually fairly easy... when going from  Three' a b = Three' a b b  to  Three' a b' = Three' a b' b', the second and the third component change type, so fmap has to do something to those.
20:00:36 <monochrom> too many b, too many '
20:00:43 <monochrom> it's why I just switch over to t -> u
20:00:57 <wunderbrick> Yes that's better.
20:01:12 <int-e> monochrom: This is Haskell though, you have to learn to love the prime.
20:01:48 <wunderbrick> int-e: I see. Thanks.
20:02:32 <monochrom> I am not against ' , I am against name clashes and low hamming distances.
20:02:48 <int-e> wunderbrick: In fact this is so systematic that ghc has an extension that can derive functor instances for you.
20:03:26 <wunderbrick> I think I was just confused by the amount of b's in the type constructor vs in the data constructor.
20:03:37 <monochrom> It's the reason why we all understand that my "every pixel could be one of 2^24 colours, so just use one pixel per unicode character" is a joke.
20:03:53 <wunderbrick> Oh nice, I need to look into that after I spend some more time reasoning through the basics.
20:04:27 <monochrom> No one goes like "this is the 4K UHD century, learn to love one pixel per unicode character". Or do they?
20:05:32 <int-e> > let а = 23; a = 42 in а * a -- it could be worse
20:05:34 <lambdabot>  966
20:06:28 <monochrom> > 4000*2000/80
20:06:30 <lambdabot>  100000.0
20:06:58 <monochrom> that many lines of code could fit on one screen.
20:07:11 <monochrom> how many lines of code are there in GHC?
20:07:33 <int-e> I don't know about you, but here, ' still takes up a whole character cell.
20:07:52 <monochrom> Yes that's fine.
20:08:16 <int-e> monochrom: the .hs files under compiler/ add up to 375k lines
20:08:23 <monochrom> It will take up one whole pixel, don't worry!
20:08:53 <monochrom> Ah, 4-head monitor setup then!
20:12:18 * hackage GLUtil 0.10.4 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.10.4 (AnthonyCowley)
20:45:05 <dmwit> (What kinds of things does a forehead monitor setup monitor for?)
20:45:34 <dmwit> (Acne? Haircuts? Headware?)
20:47:54 <monochrom> body temperature
20:48:16 <quazimodo> hi 
20:48:39 <quazimodo> is there another way to define generics other than with typeclasses?
20:49:31 <Cale> Sure I guess
20:49:52 <monochrom> What is your real question?
20:50:00 <Cale> You can just write explicit functions which convert your type back and forth from a generic representation type.
20:50:22 <Cale> Of course, as soon as you do that, you'll... probably want a type class for it
20:52:26 <quazimodo> monochrom: was that for me?
20:52:48 <quazimodo> Cale: yeah makes sense
20:54:08 <monochrom> yes
20:55:48 <jusss> int-e: actually I just found one, const bind = ma => amb => cb => ma(a => amb(a)(cb))
20:56:19 <jusss> and it's very twisted...
20:59:12 <jusss> const callcc = f => cc => f( x => _ => cc(x))(cc)
20:59:48 <jusss> const pure = x => cb => cb(x)
20:59:57 <jusss> const cont = bind(callcc(f))( a => pure(a+2))
21:25:58 <quazimodo> that was my real question
21:46:26 <fresheyeball> does anyone out there know the secret formula to make ghci poop out template haskell stuff?
21:46:47 <fresheyeball> I thought [d| imAmATH = 3 |] would work
21:46:50 <fresheyeball> but no show instance
22:08:08 <fresheyeball> grr I still can't figure this out
22:08:30 <fresheyeball> I just want to provide a haskell expression and get it's Q [Dec] equiv
22:13:05 <justin2> Hi I am at the final stage of install cabal-install from source, I've tried moving some version around and stuff, but I cannot decipher this error. Can anyone help?
22:15:15 <sclv> paste the error in a gist or the like
22:16:29 <justin2> https://gist.github.com/justinba1010/172cb6e274e01ebb4ff27d77fedccd33
22:17:29 <fresheyeball> https://hastebin.com/imoguhobez.bash
22:17:33 <fresheyeball> what am I doing wrong here?
22:17:35 <justin2> Supposedly it should be part of Cabal, and I have Cabal installed.
22:17:38 <justin2> https://hackage.haskell.org/package/Cabal-3.2.0.0/docs/Distribution-Text.html
22:17:52 <fresheyeball> I just want to template ma haskell
22:18:25 <EvanR> i feel like there's a better way to express a . b = id
22:18:36 <sclv> justin its trying to do a profiling build
22:18:46 <Axman6> involution?
22:19:06 <EvanR> because a . b acting like id is the important part, not wondering what = means
22:19:08 <justin2> I installed Cabal from scratch to double check.
22:19:29 <justin2> fresheyeball, are you coming from PHP by any chance?
22:19:41 <fresheyeball> justin2: I do Haskell full time
22:19:46 <sclv> you can reinstall the cabal lib with profiling enabled or you can find where the script for cabal-install has the profiling flag and turn that off
22:19:54 <fresheyeball> I just don't want to work out the TH by hand
22:20:13 <justin2> Ahh, I've never seen the $ operator used like that :).
22:20:22 <fresheyeball> I want to either use splices or paste in an expression and get back the Dec
22:20:23 <EvanR> kind of like how "is in such and such set" is often used to mean "has some property"
22:20:27 <fresheyeball> justin2: it's in a QQ
22:20:50 <justin2> I won't be able to help there tbh :(, way outside my skill level.
22:21:04 <fresheyeball> no worries
22:21:09 <fresheyeball> there is a trick to it, I just forget
22:21:22 <justin2> sclv, I'll go ahead and reinstall cabal with profiling, thank you.
22:21:49 <sclv> —enable-profiling iirc
22:24:06 <justin2> Appreciate it, sclv, you've been an amazing help through this. I'm hoping when I inevitably brick this pinebook, when I reinstall Haskell again, I'll try and make a document of how to get it up and running for AArch64, there are some C libs that are linked in the wrong place for a bootstrap GHC build.
22:25:23 <sclv> fresheyeball: I don’t think you can splice in just the name in the type decl, you need to splice in the full decl
22:25:46 <fresheyeball> sclv: do you know how to show a Q [Dec] ?
22:25:49 <sclv> but you can at least use a quotation for the type itself
22:25:51 <fresheyeball> that would be even better
22:26:25 <sclv> you can’t show a Q in general, since it includes effects
22:26:39 <sclv> You can show _inside_ the Q
22:26:41 <fresheyeball> sclv: I know I did this before
22:26:44 <fresheyeball> oh!
22:27:10 <fresheyeball> ack
22:27:39 <fresheyeball> runIO . print <$> ([d| foo = 3 |] :: Q [Dec])
22:27:41 <fresheyeball> did not work
22:28:36 <fresheyeball> runIO . pring =<<
22:28:43 <fresheyeball> runIO . print =<<
22:28:46 <fresheyeball> also did not work
22:31:25 <fresheyeball> sclv: yeah, I don't see how
22:35:12 <MarcelineVQ> fresheyeball: when you say show, do you mean just so you can read it yourself?
22:35:26 <fresheyeball> Yes
22:35:28 <MarcelineVQ> runQ [d| foo = 3 |]
22:36:10 <fresheyeball> MarcelineVQ++
22:36:12 <fresheyeball> YES!
22:36:15 <fresheyeball> That is the trick
22:38:16 <justin2> Is there a way to build Cabal with the profiling libraries? I have been using Setup.hs to install Cabal, and I do not have the cabal-install cli tool.
22:55:15 <fresheyeball> MarcelineVQ: thank you so much
22:55:25 <fresheyeball> I was getting really frustrated missing that trick
22:55:45 <iqubic> What was the trick? I missed it.
22:55:58 <suzu_> runQ
22:56:00 <fresheyeball> > runQ [d| foo = 3 |]
22:56:02 <lambdabot>  <hint>:1:14: error: parse error on input ‘=’
22:56:34 <fresheyeball> hu, why no lambdabot?
22:57:18 <iqubic> lambdabot doesn't do TH.
22:57:46 <iqubic> I'm not sure if you can use TH quasiquoters in the repl.
22:57:56 <iqubic> % runQ [d| foo = 3 |]
22:57:57 <yahb> iqubic: ; <interactive>:114:1: error: Variable not in scope: runQ :: Language.Haskell.TH.Lib.Internal.DecsQ -> t
22:58:07 <iqubic> Weird.
22:58:38 <fresheyeball> [ValD (VarP foo_3) (NormalB (LitE (IntegerL 3))) []]
22:58:42 <fresheyeball> is what it should be printing
22:58:50 <suzu_> do you need TH to do what you're doing?
22:58:56 <iqubic> Correct: You can use quasi-quoters in GHCi, but lambdabot doesn't do TH.
22:59:14 <fresheyeball> I wrote a thing that parses a CSS file at compile time
22:59:15 <iqubic> % import Language.Haskell.TH
22:59:15 <yahb> iqubic: 
22:59:25 <fresheyeball> and generates a module of CSS classes found in that file
22:59:30 <iqubic> % runQ [d| foo = 3 |]
22:59:30 <yahb> iqubic: [ValD (VarP foo_0) (NormalB (LitE (IntegerL 3))) []]
22:59:34 <iqubic> There we go.
23:00:31 <suzu_> ah and it's TH?
23:00:34 <iqubic> fresheyeball: It's a good thing you can do IO in TH.
23:00:41 <fresheyeball> iqubic: yeah
23:00:49 <fresheyeball> I am hoping I will be able to do stuff like
23:01:03 <fresheyeball> $(getClasses "./font-awesome.css")
23:01:12 <fresheyeball> and not be stringly typed
23:01:33 <fresheyeball> classes in my code that are not supported will stop compiling if my css file changes
23:01:35 <suzu_> stringly typed
23:01:35 <fresheyeball> ect.
23:01:37 <suzu_> love it
23:01:47 <fresheyeball> you know what I mean
23:01:53 <suzu_> i certainly do
23:02:08 <fresheyeball> I think it would be cool to update a css file to a new version
23:02:21 <fresheyeball> and get a compile time error about usage of classes with changed names
23:02:46 <fresheyeball> also not worry so much about typos
23:04:24 <fog> how can we ensure global properties are satisfied, such as when marshalling between 2 lists, that values are not destroyed 
23:05:06 <fresheyeball> fog: can you be more concrete?
23:12:47 <fog> sorry
23:12:56 <fog> ok, so, say i have a fishing game
23:13:26 <fog> each player has a number of fishing lines in a river, which they check to see if they have fish on 
23:13:37 <sshine> fresheyeball, along those lines, there are some pretty decent CSS preprocessors today.
23:13:55 <fog> if i model this as a river datatype, with a list of line#
23:14:04 <fog> and a list of players, each with a list of line#
23:14:37 <fog> then, i would expect all the line# to be consistent across both datastructures
23:15:13 <fog> (maybe, the players have lists of lines currently in the river, and a sperate list for lines currently being inspected for having fish on or not)
23:15:41 <fog> anyway, the point is that there should be some consistency
23:16:04 <fog> if i write the program wrong - then the line# lists between player and river, might not match up
23:16:12 <fog> i would consider this to be a runtime error
23:16:22 <fog> and would like to prevent it from being possible at type level
23:16:28 <sshine> fresheyeball, I was thinking https://hackage.haskell.org/package/hsass -- would be neat if there was a TH 'compileFile'. :)
23:16:40 <fog> so that if i write it wrong, the compiler would say so
23:18:07 <fog> when a player casts a line into the river, its own list of active lines should be updated, as should the list of lines in the river
23:18:25 <fog> there should be no opperation that would result in a mismatch between these
23:18:37 <fog> it seems like "the preservation of a global property"
23:19:16 <fog> the sum of all the players active lines should always equal the list of lines in the river
23:19:52 <fog> how can i embed this at type level so that when writing implementations, i cant mess it up somehow
23:20:12 <fog> normally if my program typechecks i can be sure it works
23:20:33 <fog> but whenever these "global consistency" issues crop up - it requires painstaking debuging and unit testing
23:20:51 <fog> and for large complicated programs, this can be a total bottleneck in development 
23:22:05 <fog> i guess its similar to a smart constructor for an "ordered list"
23:22:12 <fog> or, that might be a simpler example
23:22:37 <fog> if i write the constructor correctly, then the list will be ordered
23:22:49 <fog> but there is no way of actually checking this at type level
23:22:56 <fog> and then, i could write the constructor wrong
23:23:31 <fog> what would be better, is to have it enforced at type level, so that an incorrect constructor implementation would be a type error 
23:24:11 <fog> i guess then, the fishing game, is the next level more complicated, anticipating that these consistency considerations could spread accross more and more datatypes to become untractable to manage 
23:24:56 <fog> i guess at the very least, its going to require singletons for the numbers contained in these lists
23:25:17 <fog> but that does not seem very dynamic
23:25:50 <fog> like, if a player gets more fishing lines, i wouldnt want the total number of lines to be fixed at compile time
23:27:08 <fog> i just want to say "two copies of this number exist, and one of them are distributed somewhere between these lists (players active lines), and the other is in this list (lines in river))
23:27:23 <fog> s/)/"
23:28:00 <fog> but if they were singletons, i would be worried that they would all have to exit at compile time.
23:28:45 <fog> idk, maybe i could have a list of like, [1..1000] of singleton #s at compile time, and then could do type safe marshalling operations over these
23:29:15 <fog> like a kind of reservoir that the numbers can be drawn form if needed 
23:29:25 <EvanR> checks of values unknown at compiler time can be done with type classes
23:29:28 <fog> i never heard of anything like that, did i get something wrong?
23:30:03 <fog> EvanR: they are singletons, its the type that is unknown thats the problem, when the value is unknown
23:30:25 <EvanR> yes unknown types can be wrangled with the type class system
23:31:02 <fog> im just trying to get my head round this
23:31:14 <EvanR> when they are unknown but we know more than nothing about them, hence the contexts involving type variables left of .+
23:31:17 <EvanR> =>
23:31:30 <EvanR> constraints
23:31:59 <EvanR> SomeNat for instance
23:32:51 <fog> the simplest thing i can think of is; data Duplicates = Duplicates {allNumbers :: [Int], splitNumbers :: ([Int],[Int]))
23:33:10 <fog> (or whatever the singletons Int version of this is)
23:33:43 <drocsid> is there an errata for learnyouahaskell?
23:34:03 <fog> and i want to shift numbers betweem the splitNumbers list
23:34:26 <fog> and be sure that the implementation of this wont lead to a mismatch between allNumbers and splitNumbers
23:34:37 <drocsid> I found a couple errors previously but am seeing another now but couldn't find when I looked last time...
23:35:54 <fog> i guess i would need something like a "Nat list" which would be like a hetrogenous list, of singletons...
23:36:00 <drocsid> It's a great text also...
23:37:36 <fog> data Duplicates (xs :: [SNat])= Duplicates {allNumbers :: SList xs, splitNumbers :: Sort (ys ++ zs) ~ Sort xs =>  (SList ys,SList zs)}
23:38:04 <fog> i guess that would work
23:38:34 <fog> i get worried everytime there is something like that though
23:38:44 <fog> i know i can handle arbitrary types using classes
23:39:00 <fog> but, im used to all the values that exist existing at compile time
23:39:10 <fog> all the types*
23:39:23 <fog> so for singletons, i cant actually generate new values at runtime
23:40:26 <fog> and then, i dont see how thats different to having them placed into different lists at runtime...
23:40:47 <fog> the SList basically ends up with a different type
23:41:10 <fog> i didnt think the types involved could be different depending on the runtime situation
23:43:13 <fog> i guess a similar situation would be any kind of runtime situation generating a different type
23:43:30 <fog> like, having a binary read instance - and recieving a binary message on a server
23:43:44 <fog> which is supposed to be decoded into one of several different types
23:44:11 <fog> i would have to have a sum type containing each possibility, so that this could be what changes at runtime 
23:44:35 <fog> but if ever i tried to make this singleton, like SMaybe (isJust :: Bool)
23:44:53 <fog> then the ambiguity of the Sum type gets ruined 
23:45:05 <fog> i guess this is whats hapening when Nats are made into SNats
23:46:47 <fog> EvanR: so the idea is that im supposed to be able to ensure properties about the types, without actually resolving them - so allowing arbitrary types to exist?
23:47:16 <fog> like, "the type satisfies a constraint that is less strict than an equality constraint"
23:47:38 <fog> and that as long as my implementations somehow satisfy these constraints
23:47:53 <fog> they dont actually need to resolve the values themselves...
23:48:15 <fog> that kind of makes sense, then they type error would be to do with constraints not being met, as opposed to the wrong types being used
23:50:04 <fog> ..
23:50:33 <fog> still, this isnt exactly a convenient way of "writing global properties" 
23:51:08 <fog> i guess whatever that is would be some kind of magical type level apparatus  
23:51:50 <fog> where everything would consist of being able to prove that constraints were met
23:52:05 <EvanR> fog: arbitrary types subject to the constraints
23:52:21 <EvanR> you're supposed to think of some of these types as values... the datakinds
23:52:43 <EvanR> the fact that theyre not is why singletons exists
23:53:14 <fog> i guess im just more used to type errors eg Bool /~ Int
23:53:36 <EvanR> there are many types of type errors
23:53:44 <fog> as opposed to, whatever this would be, like "constraints are violated, cant prove the value was not discarded"
23:55:27 <fog> i guess the constraints library has some mechanisms for this, like with entails and stuff... but its not quite the "environment in which global properties can be used" that i have an imagnining of
23:56:50 <fog> and i still dont like the idea of new types being generated at runtime
23:57:15 <fog> but i guess, that is because im still thinking in terms of type equality errors
23:57:52 <fog> "how could a type not available at runtime participate in typechecking, in order to be typesafe" by broken intuition says
23:58:18 <fog> but if infact all the typechecking is just ensuring constraints are satisfied, then this as yet unavailable type should be no problem
23:58:26 <fog> i would never need to match on it anyway
