00:32:49 * hackage staversion 0.2.3.7 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.3.7 (debugito)
01:57:50 <aveltras> anyone using emacs lsp-mode having trouble recently ? I've just updated all my emacs packages and now the diagnostics don't get updated, i have to restart the lsp workspace
02:42:53 <jluttine[m]> How can I import a newtype constructor from a module? I tried `import Foo (Bar)` where `Bar` is some newtype (e.g., `newtype Bar = Bar Int`). But I only get the `Bar` type, not the constructor in scope.. Why is that?
02:43:17 <xerox_> Type(Constructor) there's also Type(..) that does more
02:44:33 <xerox_> «When the (..) form of import is used for a type or class, the (..) refers to all of the constructors, methods, or field names exported from the module.»
02:44:44 <jluttine[m]> xerox_: oh, wow, thanks, that worked! never heard about this when reading about newtype or module imports..
02:45:41 <jluttine[m]> xerox_: oh, now i'm confused. doesn't that citation say that it should have imported constructor..
02:45:59 <xerox_> here https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
02:46:50 <xerox_> sorry didn't want to confuse you, you were doing   import tycon   in your initial example using the report language
02:47:05 <xerox_> but you wanted   import tycon(cname)   where cname is the name of the constructor
02:47:19 <xerox_> the quote is about   import tycon(..)  which does all of what it says there
02:49:50 <jluttine[m]> hmm.. i don't understand.. shouldn
02:49:50 <jluttine[m]> oohps
02:50:38 <jluttine[m]> shouldn't there be `import Module Bar(Bar)`? In your example is `tycon` the module name?
02:50:57 <xerox_> oopsie I forgot the module in there :D
02:51:41 <xerox_> import Module (tycon), import Module (tycon(cname)), import Module (tycon(..))
02:51:48 <jluttine[m]> ok, that explains :)
02:51:53 <xerox_> my bad
02:52:44 <jluttine[m]> does this apply to `data` too? so if i import `import Module Foo`, I only get `Foo` type but not `Foo` constructor (if it happens to have a constructor of the same name)?
02:52:49 <xerox_> yes
02:53:12 <dminuoso> jluttine[m]: Equivalently, if you only export Foo you dont re-export the constructors.
02:53:18 <dminuoso> You can use this to do information hiding/encapsulation.
02:53:39 <dminuoso> Where you forbid other users to pattern match (and thus deconstruct the value, and gain access to its internals)
02:53:58 <dminuoso> So writing `Foo` in the export list only exports the type constructor, but not the data constructor(s)
03:01:47 <jluttine[m]> dminuoso: ok, thanks!
03:01:48 * hackage cairo 0.13.8.1 - Binding to the Cairo library.  https://hackage.haskell.org/package/cairo-0.13.8.1 (HamishMackenzie)
03:02:49 * hackage glib 0.13.8.1, gio 0.13.8.1, pango 0.13.8.1 (HamishMackenzie)
03:03:48 * hackage gtk3 0.15.5 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.15.5 (HamishMackenzie)
03:04:49 * hackage gtk 0.15.5 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.15.5 (HamishMackenzie)
03:22:50 <maerwald> should literate programming explain all of the code?
03:27:36 <Franciman> maerwald, it depends on who you are talking to
03:27:42 <Franciman> as usual when writing stuff to communicate
03:28:48 <maerwald> that's the problem with documentation... you never know who you're talking to
03:35:00 <maerwald> the line between "contributor" and "API" user is already a major question
03:35:30 <maerwald> for both the style should be very different
03:35:49 <[exa]> maerwald: the best documentation is terse and precise, provide references to sources if you have a feeling that people might not understand something
03:36:10 <maerwald> API user cares about use cases... contributor cares about descisions
03:36:29 <[exa]> then they probably should not read the same documentation
03:36:47 <maerwald> [exa]: I'm afraid that does not answer my question 
03:37:32 <maerwald> I'm specifically talking about literate programming, not documentation in general
03:38:48 <maerwald> and with a bidirectional literate programming approach you can't have multiple stories for the same code
03:39:22 <maerwald> and if it's not bidirectional, you're screwed anyway
03:42:52 <DigitalKiwi> "note to users" "note to contributors"
03:54:13 <vnz> Guys, I'm trying this example from Hutton's book: https://dpaste.org/w09W
03:54:30 <vnz> but I'm getting the following error: https://dpaste.org/uA1B
03:54:52 <vnz> any idea why?
03:56:45 <gvx> ghc doesn't know what type to use for [1..10] and []
03:56:54 <gvx> https://tio.run/##y0gszk7Nyfn/vzgxLbUkMTNHwcpKIToxVkHXDkRxwYUrihVsFTLTFPJKc8CckozUPIXoWIXUnOJUBagKLq7cxMw8kAme/goamhCerUJKPpeCQkFRZl6JgooC3ECNaEM9PUODWLCFnnklsZrYVSEp@P8fAA
03:57:10 <gvx> you can specify it like ([1..10] :: [Int])
03:59:42 <maerwald> DigitalKiwi: the code block structure for both is not the same, necessarily
04:00:28 <vnz> that did the trick! thanks gvx 
04:01:41 <maerwald> and the entire line of documentation as well... for contributors I'd naturally start with the ENTRY POINT, for API users I'd start with the data structures...
04:03:02 <DigitalKiwi> just do what i do and don't document anything
04:03:23 <DigitalKiwi> i jest
04:03:25 <DigitalKiwi> but do i
04:32:52 <maerwald> DigitalKiwi: https://github.com/entangled/entangled/issues/61#issuecomment-647115460
04:36:17 <DigitalKiwi> i just think it's funny that if you're not doing literate programming you're doing illiterate programming
04:36:51 <DigitalKiwi> hi what kind of software developer are you oh i'm an illiterate programmer
04:52:10 <xsperry> I never used reflection in haskell, is it possible to check if all the maybes in some data are set to Nothing?
04:52:37 <xsperry> it would make it easier to do something if none of the options were set, and I wouldn't have to update the code after I add new options
04:55:57 <boxscape> IIRC that sort of thing can be done with https://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Plated.html ?
04:56:07 <boxscape> I've never used it though
04:56:45 <dminuoso> xsperry: You can also use generics.
04:56:52 <boxscape> actually maybe I'm thinking of something different in the lens library? Not sure
05:02:39 <boxscape> xsperry here's a whole thread on the topic https://www.reddit.com/r/haskell/comments/84p7rl/how_to_use_ghcgenerics_to_extract_values_of_a/
05:04:57 <xsperry> thanks all, I'll take a look!
05:08:49 * hackage polysemy-webserver 0.2.0.0 - Start web servers from within a Polysemy effect stack  https://hackage.haskell.org/package/polysemy-webserver-0.2.0.0 (AndrewMiller)
06:04:10 <xsperry> can you have sub sub commands with opt parse applicative?
06:06:08 <xsperry> or in other words, nested commands
06:08:53 <maerwald> yes
06:21:49 * hackage goldplate 0.1.0 - A lightweight golden test runner  https://hackage.haskell.org/package/goldplate-0.1.0 (JasperVanDerJeugt)
07:45:19 * hackage trial 0.0.0.0 - Trial Data Structure  https://hackage.haskell.org/package/trial-0.0.0.0 (vrom911)
07:47:49 * hackage trial-optparse-applicative 0.0.0.0 - Trial helper functions for optparse-applicative  https://hackage.haskell.org/package/trial-optparse-applicative-0.0.0.0 (shersh)
07:49:49 * hackage trial-tomland 0.0.0.0 - Trial helper functions for tomland  https://hackage.haskell.org/package/trial-tomland-0.0.0.0 (shersh)
08:25:57 <kleisli> is there an alternative version of the either monad where the left state gets monoidally built up rather than overwriting
08:26:40 <whataday> I saw "abstract class ListEq<A>(val a: Eq<A>)" in kotlin, does this mean "data ListEq a = ListEq a (Eq a)" in haskell?
08:27:48 <hpc> more like data ListEq a = ListEq {a :: (Eq a)}, or something like that, afaict
08:28:29 <hpc> although with how OOP works, it could be that it's thinking of class Eq a instead of data Eq a
08:31:07 <whataday> you mean ListEq(a) can be instantiated?
08:31:36 <whataday> not ListEq<A>(a)?
08:34:09 <hpc> it only contains a value of type Eq<A>
08:34:19 <hpc> you also gave it a value of type A
08:34:21 <whataday> I see
08:34:45 <whataday> ListEq(a :: Eq a)
08:35:52 <hpc> is that supposed to be haskell syntax?
08:36:20 <whataday> I mixed up
08:36:38 <cjay> kleisli: the tuple monad uses monoid on the left. How would you want the shortcutting of Either to interact with this behavior?
08:42:59 <kleisli> cjay: i noticed that, but i want a sum type. essentially i want an error message monad where `Left a >> Left b` would produce `Left (a <> b)`
08:43:31 <[exa]> kleisli: what would you expect from `Left 5 >> Right 3` ?
08:43:52 <kleisli> the existing either behaviour, so Left 5
08:44:02 <kleisli> just wondering if something like this already exists
08:44:20 <cjay> the computation would need some value to continue after the first Left occurs
08:44:34 <[exa]> and `Left 5 >>= Right` ?
08:44:58 <[exa]> oh, wrong, this is the example -- `Left 5 >>= Left`
08:45:10 <cjay> maybe specifying default outcomes could work somehow
08:48:03 <mniip> if your errors are non-fatal warnings then you want a writer monad
08:48:41 <cjay> there certainly are cases w
08:48:53 <cjay> there certainly are cases where you would want to accumulate as much errors as possible
08:48:55 <mniip> if your error is such that you cannot produce an intermediate value (you return Left instead of Right), then further computations cannot continue and you have to abort the computation immediately
08:48:56 <cjay> like a compiler
08:49:38 <kleisli> mniip: thank you, need to learn how writer works
08:50:59 <kleisli> cjay: it is a compiler actually, i have a functor of untyped expressions, and a typechecking function that produces Either ErrorMessage TypedExpression
08:51:12 <[exa]> cjay: compilers explicitly recover the errors (ie. turn Lefts to non-intrusive Rights in this case)
08:51:42 <kleisli> and i want to typecheck all the expressions (of which multiple may have errors), and then show all the error messages
09:01:18 * hackage esqueleto 3.3.3.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.3.1 (parsonsmatt)
09:51:49 * hackage persist-state 0.2.0.0 - Serialization library with state and leb128 encoding  https://hackage.haskell.org/package/persist-state-0.2.0.0 (minad)
10:00:07 <ianliu> I've installed GHC with ghcup and now I want to install some packages. Which version of cabal install should I use? Vanilla install, v1, v2 or new-install?
10:00:23 <ianliu> what are the differences between them?
10:00:30 <maerwald> v2 is now default
10:01:24 <maerwald> ianliu: https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
10:04:26 <dminuoso> ianliu: v2 and new are the same.
10:04:43 <dminuoso> ianliu: In newer versions "install" defaults to v2-install, in older versions to v1-install
10:04:49 <dminuoso> new-install is an old alias for v2-install
10:05:04 <dminuoso> (The same holds true for any other command for which v1/v2 versions exist)
10:05:26 <ianliu> Thanks! That clarifies things ;-)
10:13:01 <fresheyeball> so I have a "It is a member of hidden package" error
10:13:07 <fresheyeball> and I have added the package to my cabal file
10:13:10 <fresheyeball> and the error persists
10:13:20 <fresheyeball> is this due to some caching somewhere?
10:13:48 * hackage bitcoin-keys 0.1 - Bitcoin keys  https://hackage.haskell.org/package/bitcoin-keys-0.1 (RenzoCarbonara)
10:13:50 <maralorn> I am trying to use weeder: https://hackage.haskell.org/package/weeder-2.0.1
10:13:53 <maralorn> The documentation says to put 'ghc-options: -fwrite-ide-info' in cabal.project.local.
10:13:55 <maralorn> Then I get: ghc: unrecognised flag: -fwrite-ide-info
10:14:38 <dminuoso> fresheyeball: Show the output of `cabal build -v3`
10:14:57 <maralorn> fresheyeball: Did you add it to the right component, save the cabal file, restarted the tooling?
10:15:19 <dminuoso> fresheyeball: Also.. did you save the cabal file? I make this mistake sometimes, not saving emacs buffers... :)
10:15:53 <fresheyeball> dminuoso: https://hastebin.com/exuniserac.nginx
10:16:20 <fresheyeball> dminuoso: https://hastebin.com/ijizuyitaq.http
10:16:26 <sclv> maralorn: probably yr ghc too old to need that flag?
10:16:32 <dminuoso> Huh, that's strange.
10:17:20 <sclv> may want to clean and reconfigure
10:18:04 <dminuoso> fresheyeball: Can you check your cabal store in the right ghc version, whether jsaddle-dom-0.9.4.0-HyZs4DLSkJQAfK8en5m6R4 exists?
10:18:25 <fresheyeball> dminuoso: well it's a hidden package error, so the dep is there
10:18:46 <dminuoso> `-package-id jsaddle-0.9.7.0-8tEAKwVWoFRD6BpB0ZekFg`
10:21:12 <fresheyeball> dminuoso: what is the full command please
10:21:14 <fresheyeball> ?
10:21:21 <drozdziak1[m]> hello
10:21:21 <maralorn> sclv: Uh, yeah. That was the problem. I didn‘t realize that that specific project is still stuck at ghc 8.6.5
10:21:30 <dminuoso> fresheyeball: Im just suggesting, that the build correctly selected the package.
10:26:49 * hackage stan 0.0.0.0 - Haskell STatic ANalyser  https://hackage.haskell.org/package/stan-0.0.0.0 (vrom911)
10:31:28 <monochrom> The name "static analyzer" gave me high hope, but the examples are a total let-down, merely subjective personal stylistic preferences blown up as "anti-pattern".
10:32:22 <maerwald> monochrom: did you see my literate haskell bikeshedding?
10:32:33 <maerwald> I need answers
10:32:47 <monochrom> No, I didn't.
10:32:55 <maerwald> https://github.com/entangled/entangled/issues/61#issuecomment-647115460
10:33:27 <maerwald> entangled is a bidirectional literate programming daemon
10:34:31 <monochrom> Literate programming is totally not for API users. What was hasufell smoking?!
10:34:46 <maerwald> not?
10:35:03 <monochrom> And in particular, in the case of Literate Haskell, literate comments and haddocks are orthogonal.
10:35:15 <monochrom> Not.
10:35:41 <maerwald> but the comments will show up in the markdown as well
10:35:56 <monochrom> sorry, what markdown?
10:36:09 <maerwald> the one entangled produces
10:36:23 <maerwald> https://github.com/entangled/entangled/tree/master/lit
10:36:45 <monochrom> Then perhaps entangled solved the wrong problem?
10:39:48 * hackage hledger-lib 1.18.1 - A reusable library providing the core functionality of hledger  https://hackage.haskell.org/package/hledger-lib-1.18.1 (SimonMichael)
10:40:49 * hackage hledger-web 1.18.1, hledger-ui 1.18.1, hledger 1.18.1 (SimonMichael): https://qbin.io/assure-coat-dktx
10:40:55 <monochrom> OK, that was unfair. entangled (and all literate programming formats) are agnostic about what your comments are for. They only specify how to write comments, how to write code snippets, and how to concatenate the code snippets.
10:42:14 <monochrom> Within the comments, people have always been greatly confusing external doc with internal doc. I don't understand why, I have to accept that it's human nature, but it is not going away and no tool will solve it.
10:42:25 <maerwald> yes, but you can't have two stories per one codebase
10:43:07 <monochrom> If you invent haddock, some people will think that it's great for internal doc. If you invent literate programming, people will think that it's great for user-side doc. Nothing will stop it.
10:43:18 <maerwald> if you tell a story, don't you adjust it depending on the reader?
10:43:34 <maerwald> so you have actually multiple stories
10:43:48 <maerwald> that emerge from the same truth
10:45:36 <monochrom> I may one day conclude that the constraint "they must all come from the same file" is the root problem, but I am not sure yet. So just keep that in mind and re-think it later.
10:45:58 <monochrom> For now, we already have make-shift ways of putting 3 stories in the same file.
10:46:19 <monochrom> (The 3 stories are: code, internal doc, external doc)
10:46:59 <monochrom> Suppose you use Knuth's web, or Norman Ramsey's noweb, or entangled.
10:47:21 <monochrom> You already know what to do to code. Use literate comments for internal doc.
10:48:00 <monochrom> For external doc, make it "code" (from the POV of the literate programming tool), but it's haddock comments.
10:48:24 <monochrom> This is even compatible (actually required) for *.lhs
10:48:25 <maerwald> now we need another layer that lets me generate external docs from both code and literate docs :p
10:49:01 <monochrom> We already have another layer. "haddock" is a separate program already. You already have to tell cabal to run it separately.
10:49:14 <bolti[m]> Hi, I'm new in haskell and I'm not sure how to install haskell-ide-engine
10:49:39 <monochrom> You can say you dislike this organization, but it already works, and it already fits existing workflow. Hell, it is already existing workflow.
10:49:51 <bolti[m]> I've cloned the repo, and ran `./cabal-hie-install hie` 
10:50:00 <maerwald> monochrom: but my point is...that even external api doc should not be per module
10:50:22 <monochrom> Not the least since entangled is in the background generating the *.hs files for you real-time so you just have to say "cabal buiid; cabal haddock" etc.
10:50:25 <bolti[m]> But I can't find where is hie, it's not in .cabal/bin 
10:50:27 <sm[m]> bolti, #haskell-ide-engine may be the best place to ask
10:50:35 <bolti[m]> thanks
10:51:04 <monochrom> Ah OK. Yeah we need to re-think the whole thing for that. I'll tell you a vision/dream I once had.
10:52:07 <monochrom> I was a grad student. You know how we in academia have to do our research, then submit an internal tech report, then a conference paper, then slides for the talk in the conference, then a journal paper.
10:52:14 <maerwald> often times ppl stuff huge text in the main module ....like, see optics (which has excellent documentation, but could precisely benefit from this)
10:52:47 <monochrom> That's a lot of writing, and worst, writing almost (but not quite) the same stuff over and over again, just in different detail levels, different orders, different omissions, right?
10:53:50 <monochrom> So I had this great vision of "how about write just one big file, from which one program extracts the tech report, another extracts the conference paper, another extracts the slides, another extracts the journal paper? Just like literate programming but on steroid"
10:54:27 <maerwald> we had this conversation before...
10:54:37 <monochrom> I haven't implemented or even evangelize this dream.  I don't know whether you say "fortunately" or "unfortunately". :)
10:54:46 <maerwald> that's a sign something must be done.
10:55:19 * hackage di-polysemy 0.1.4.0 - DI logger wrapped for Polysemy  https://hackage.haskell.org/package/di-polysemy-0.1.4.0 (nitros12)
11:01:28 <monochrom> So, conclusion: Literate programming has only solved writing comments and code in whichever order you like, in hope that you use this freedom to write in a nice order. (You have to make that judgment, all the computer can do is give you freedom.)
11:01:55 <jtreed> wow, I like this channel already
11:02:35 <monochrom> But it still has not acknowledged the obvious but denied-by-many fact that within the comments, you have 2 or even 3 disjoint audience groups wanting disjoint kinds of information.
11:03:46 <monochrom> For now my suggestion is "we need more markups". Whereas current literate programming has 2 markups (code vs comment), we need code vs internal doc vs external doc, perhaps more.
11:04:19 <c_wraith> fortunately, normal haskell has those three!
11:04:29 <c_wraith> (probably still could use more.)
11:04:38 <monochrom> If you find it unsatisfactory, then perhaps time to consider my other hypothesis that maybe the notion of "one single file" is wrong in the first place.
11:07:04 <c_wraith> I still want to know what makes people have trouble with documentation that isn't in the form of a recipe.
11:07:28 <c_wraith> If all you wanted to do was exactly what the recipe says to do, why isn't it just a single function call in the first place?
11:08:10 <monochrom> Those people are cargo-culters.
11:08:55 <monochrom> Actually worse. Cargo-culters who hypocritically want to rationize not getting replaced by a single function call.
11:08:57 <[exa]> monochrom: there are API servers (like the restful stuff from Python, and Servant has a similar thing) that have the "api docs" right in the code that already look like quite comprehensive comments in the code. Perhaps a few typesetting tricks could make the 3 levels work together?
11:09:08 <maerwald> I think it's easy to illustrate the problem this way: how do you connect the GHC code with the language report ;)
11:09:22 <[exa]> maerwald: +1
11:10:06 <monochrom> Something like 50 academic papers is the connection. >:)
11:10:28 <monochrom> or worse, only part of the connection!
11:10:44 <maerwald> very likely
11:11:02 <maerwald> now I have headache
11:11:45 <monochrom> For example if you haven't read the STG paper or equivalent, you are lost. After you have read that, you're much more ready. And then there is the OutsideInX paper, that's also a must-read on the type side.
11:12:27 <maerwald> will this be more or less headache
11:12:45 <monochrom> Ah but before the OutsideInX paper, probably you need "typing haskell in haskll" as kindergarten background, and the HM paper too.
11:13:03 <monochrom> It is headaches all the way down.
11:13:36 <fog> i have a streaming opperation i cant understand
11:13:48 <fog> where the chunks being streamed change size
11:14:15 <fog> where lazy evaluation allows blocks to be taken to some length
11:14:17 <monochrom> Consider the fact that SPJ haven't really done any non-GHC work in the past two decades. That's the kind of dedication one needs if one wants to connect GHC with the language report.
11:14:35 <fog> but that this would result in lazy consumption of a different amount of the original
11:15:54 <fog> eg, if i stream lists of length 10, but restream lists of length 20, then the lazy consumption of one output would require 2 of the inputs to be lazily consumed
11:16:22 <fog> and if these dont overlap nicely, then there seems to be a blocking where they become mismatched
11:17:38 <fog> or rather, because its non blocking, since lazy evaluation forces the consumption of more of the input list
11:17:53 <fog> s/since/-
11:19:33 <fog> but i dont know how to restream lazily like this. if i consumed all the input stream, then the different chunked output stream would be easy to produce
11:19:53 <fog> but because of the demand for lazyness, i only want to consume as much of the input stream as required
11:20:16 <fog> it kind of has to read ahead far enough to get enough values
11:20:34 <fog> maybe i need a buffer...
11:20:36 <ianliu> I've installed tagsoup with `cabal install tagsoup`, but when I open ghci and issue `import Text.HTML.TagSoup` I get an error. How do I import a global library?
11:22:16 <fog> seems strange not to have needed one until now, they are ubiquitous in C
11:22:34 <fog> ianliu: use cabal v1-install
11:22:53 <fog> it changed to v2 recently and now it doesnt install globally by default
11:23:21 <maerwald> ianliu: cabal repl --build-depends tagsoup
11:23:23 <ianliu> so, it installed locally?
11:23:32 <maerwald> don't use v1
11:24:40 <monochrom> "I use v10. What is v2?"  >:)
11:25:08 <fog> previously i had a version that ran two streams in parallel, and combined their values, and this could be lazily consumed
11:25:30 <ianliu> maerwald ty
11:26:00 <fog> no, do...
11:26:15 <fog> idk even what v2 install does though...
11:26:27 <monochrom> But the rest of us do.
11:26:28 <fog> nothing useful it seems
11:27:14 <fog> i get that there were install conflicts from version mismatch and that everything being done locally is reproducable 
11:27:39 <fog> but that means i cant open easily ghci with something that would need a cabal file i guess
11:28:10 <monochrom> Once again most human problems are caused by artificial false-dichotomies.
11:28:43 <monochrom> You don't only have 2 choices, v1-install vs v2-install. There is a 3rd option, what maerwald just said. There are probably more.
11:28:54 <monochrom> You never only have 2 choices.
11:29:04 <monochrom> There is always a 3rd way out.
11:29:05 <fog> you mean you shouldnt be opening ghci on local files with installed libraries somehow? or does it need special flags to open ghci with?
11:29:16 <monochrom> Humanity will take another millenium to understand this.
11:30:49 * hackage interact 0.2.0.0 - instantly create REPL from any function  https://hackage.haskell.org/package/interact-0.2.0.0 (epoberezkin)
11:31:19 <fog> v1 install is fine, if during development .ghci files are used to give modular directory structure, and that each source file should open by double click
11:31:32 <fog> with ghci, with all the libs visible
11:31:44 <fog> and im guessing thats a really common development approach 
11:32:14 <fog> with the alternative being calling cabal to compile it, not just :r in ghci, which is way worse
11:32:59 <fog> unless there are some ghci flags im not aware of that allow it to use v2 installed libs, like an --extra-lib-dir option or something
11:33:23 <fog> and without that, i cant see how v2 install would work at all...
11:33:53 <fog> h,, or is it the "you specified to build exes, no libs will be installed" style error
11:34:17 <fog> like, does v2 install need a -lib flag?
11:34:28 <fog> wouldnt really seem like it should
11:35:34 <ianliu> Is it OK to follow the Getting Started documentation (https://cabal.readthedocs.io/en/latest/getting-started.html)? It seems to be based on Cabal 2.4, does anything changed on 3.0?
11:35:51 <fog> idk if im making a good case for v1 install or if i just dont understand v2 at all...
11:36:31 <fog> ianliu: the only thing i get cabal3 issues with is more recent ghc versions which i think require cabal3 ? not sure...
11:36:52 <maerwald> fog: sandboxes will be removed in the next release and no one is working on v1 much anymore
11:37:11 <fog> still works ok thankfully!
11:37:35 <fog> how are we supposed to use v2 to do what we could before? clicking on .hs files to open them in ghci with globaly installed libs?
11:38:39 <fog> and as long as the answer isnt "you cant do that with v2" then i wont have to keep using v1
11:39:47 <zincy_> Should you check in dhall config files to version control?
11:41:37 <fog> here;
11:41:37 <fog> cabal v2-install --lib Cabal --package-env foo/
11:41:51 <fog> says about installing things *somewhere*
11:42:12 <fog> so i guess i have to open ghci with that package environment
11:42:23 <monochrom> ianliu: chapter 5 "nix-style ..." has the new features. Still, most of the other chapters are good for both old and new versions.
11:42:52 <fog> i guess without the package-env flag it just changes the global one
11:42:56 <monochrom> Someone one day has to completely overhaul the whole thing to make a coherent story. But eh who has time for that?
11:43:01 <fog> so that ghci should just start with this
11:43:23 <fog> making it seems like indeed, v1 style global install is recovered by addition of the --lib flag to v2 install
11:43:55 <fog> monochrom: is that right?
11:59:18 * hackage calamity 0.1.14.8 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.14.8 (nitros12)
12:29:07 <koz_> If you initialize a NominalDiffTime with a numeric literal, does it mean 'that many seconds'?
12:29:34 <c_wraith> yes
12:29:45 <koz_> OK, good to know. Wasn't sure if I was reading the docs correctly.
12:29:48 * hackage climb 0.3.2 - Building blocks for a GHCi-like REPL with colon-commands  https://hackage.haskell.org/package/climb-0.3.2 (ejconlon)
12:37:49 <EvanR> the poor docs :(
12:38:14 <davean> koz_: what would make that clearer?
12:39:05 <koz_> davean: "Conversion functions will treat it as seconds." <-- this is technically true given what its Num instance is doing, but documenting the behaviour of numeric literals typed as it specifically would help a lot.
12:39:28 <koz_> Something like 'therefore, 100 :: NominalDiffTime means 100 seconds' or something.
12:39:34 <davean> koz_: doesn't the Haskell Report fill that in?
12:39:40 <davean> koz_: "Conversion functions will treat it as seconds. For example, (0.010 :: NominalDiffTime) corresponds to 10 milliseconds"
12:39:50 <davean> the second half of that DOES give such an example
12:39:51 <koz_> OH lol.
12:39:55 <koz_> I'm looking at a very old time.
12:39:57 <koz_> My bad.
12:40:06 <koz_> Let me check something more recent.
12:40:34 <koz_> Yep, it does indeed say that. Please ignore me, it's early in the morning and I clearly cannot read. :P
12:41:23 <davean> But also, the Haskell Report section 6.4.1 covers that conversion functions are used?
12:41:31 <davean> "An integer literal represents the application of the function fromInteger to the appropriate value of type Integer."
12:42:08 <davean> etc
12:43:09 <EvanR> knowing that numeric literals are secretly rewritten is one thing but in general i think it's ok for documentation to redundantly explain something even though it's written down in some other remote document, if it's relevant to the lib
12:43:23 <koz_> EvanR: In general agreed.
12:43:30 <koz_> (in this case it already does though)
12:43:35 <EvanR> good
12:44:13 <davean> EvanR: Its more I'm trying to delve into where the lack of clarity was but it does seem koz_ just missread which is harder to fix ;)
12:44:22 <EvanR> maybe if something works because of an obscured line in the haskell report, do a quick review for my benefit
12:44:32 <EvanR> obscure
12:44:49 <EvanR> yeah
12:44:55 <davean> I kinda feel the Haskell report is too short to have anything obscure. I rather wish it was longer in a lot of ways :/
14:47:50 <suzu_> hs 2020 report when
14:48:11 <wavemode> sometime around 2030, I imagine
14:48:19 <koz_> If ever.
14:59:49 <Tuplanolla> You could take matters into your own hands and write such fan fiction.
15:02:23 <MarcelineVQ> Harry Potter and the haskell's report
15:04:25 <hpc> The Lord of the Semigroups
15:05:09 <Rembane> The Two Effect Systems 
15:05:29 <MarcelineVQ> The Return of the Simon
15:05:37 <hpc> really though, the report is much less important now that language extensions are standardized
15:06:04 <hpc> *keeping the report up to date is much less important
15:06:41 <MarcelineVQ> a balrog of marlow
15:06:54 <Rembane> The two Simons 
15:07:12 <MarcelineVQ> the silkmettion
15:07:32 <hpc> and when the story ends on a cliffhanger: "to be called with current continuation"
15:07:49 * hackage Shpadoinkle-debug 0.0.0.1 - Debugging tools for Shpadoinkle applications.  https://hackage.haskell.org/package/Shpadoinkle-debug-0.0.0.1 (fresheyeball)
15:08:23 <Rembane> hpc: that's just evil :O
15:13:38 <Tuplanolla> Imagine representing the first language with an erotic standard.
15:26:48 <dminuoso> 00:05:15           hpc | really though, the report is much less important now that language extensions are standardized
15:26:54 <dminuoso> Hold on. Standardized extensions?
15:28:05 <hpc> https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3
15:54:18 * hackage generic-data-surgery 0.3.0.0 - Surgery for generic data types  https://hackage.haskell.org/package/generic-data-surgery-0.3.0.0 (lyxia)
16:04:15 <glittershark> why is there no instance of nfdata for uarray
16:04:22 <glittershark> this seems remarkably silly
16:05:10 <glittershark> does anyone have an orphan instance NFData UArray somewhere
16:07:45 <glittershark> yeah this is especially silly because uarray is strict anyway
16:07:59 <glittershark> so rnf should just be `seq` ()
16:19:47 <glittershark> https://twitter.com/replygirI/status/1274841634405076993
16:19:55 <glittershark> oops wrong channel
16:20:13 <glittershark> lol
16:20:19 <tazjin> no that's the right channel, thanks
16:20:27 <maerwald> xD
16:31:32 <annadane> if haskell were a food it would be a snackll
16:31:36 <annadane> damn it
16:31:38 <annadane> snackell*
17:03:18 * hackage enummaps 0.6.2.1.4 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1.4 (leif)
17:19:36 <koz_> I'm trying to profile something, but even to collect the profiling info, I have to run heavy 'set up' code, which basically dominates the profile.
17:19:51 <koz_> Is there a way I can get the information I need from the 'lighter' bit I actually care about?
17:20:49 <Cale> You could perhaps turn off automatic cost centres, and instead put a bunch in by hand
17:20:56 <koz_> Cale: How would I do that?
17:21:54 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand
17:22:24 <koz_> Cale: Thank you!
17:23:00 <koz_> And I guess to turn off automatic cost centres, I need to pass `-fno-prof-auto`?
17:23:52 <Cale> Or just don't explicitly build with -fprof-auto, which is the thing that adds all the cost centres
17:24:00 <koz_> OK.
17:24:03 <koz_> WIll try that, thanks.
17:27:32 <ezzieyguywuf> let's say I have a function, `MyFunc :: Int -> MyState a`, and I wish to add "logging" by using the Writer monad (as described in Learn You a Haskell... dunno if there are other generally accepted approaches for logging, but this is just an example.). Would a typical approach be to change the function to `MyFunc :: Int -> Writer [String] (MyState a)`?
17:27:47 <ezzieyguywuf> in other words, is it typical to wrap monads in monads in monads to obtain more functionality?
17:28:22 <ezzieyguywuf> what happens when someone wants to use `MyFunc` but doesn't care about the logging? Would I write two instances of `MyFunc` then, one each with/without logging?
17:28:39 <ezzieyguywuf> are these just basic design problems that need to be addressed individually based on the needs of the project?
17:29:27 <glittershark> that's a pretty common haskell question
17:29:33 <Cale> It's probably more common to use WriterT to add the ability to write to a log to another monad, but really it's an implementation detail.
17:29:48 <glittershark> and I would say almost every haskell engineer will answer it differently, haha
17:29:51 <nshepperd2> hrm, it's getting quite annoying that a lot of stuff on hackage still doesn't support ghc 8.10
17:30:12 <glittershark> one option is to use the mtl typeclasses to make it polymorphic
17:30:16 <nshepperd2> 8.10 isn't even in the https://wiki.haskell.org/Base_package table...
17:30:18 <glittershark> another option is to use an effect system
17:30:18 <Cale> I would say the important thing is to make sure that from outside the implementation of your monad, it's not possible to tell what strategy you used to add this logging facility
17:30:31 <Cale> (or what effect system you're using)
17:30:32 <glittershark> well, unless you care about performance a lot :)
17:30:34 <glittershark> though you might not
17:30:52 <ezzieyguywuf> I'll eventually care about performance
17:30:56 <ezzieyguywuf> but not till a ways later
17:31:01 <ezzieyguywuf> What is an 'effect system'?
17:31:39 <ezzieyguywuf> glittershark: are you referring specifically to my question regarding logging, or in general to my question regarding wrapping monads in monads (when you say that's a pretty common haskell question)
17:31:43 <Cale> Just a way of constructing monads that have many different sorts of effects
17:31:59 <glittershark> ezzieyguywuf: kinda both
17:31:59 <koz_> Cale: How do I turn off auto-generated cost centres with stack? I'm following this: https://stackoverflow.com/a/32130002/2629787
17:32:07 <glittershark> ezzieyguywuf: more the latter
17:32:17 <Cale> I don't know much of anything about stack, you'll have to check out its documentation on that
17:32:30 <koz_> Cale: Fair enough. I'll try that.
17:33:34 <Cale> ezzieyguywuf: It's perfectly okay to have the computations of one monad produce computations of another, but, for example in this instance, it would be a little strange
17:33:56 <Cale> You'd do all the Writer-y stuff before having a chance to run the final MyState computation.
17:34:12 <Cale> (that would be produced by the Writer computation as its final result)
17:34:33 <Cale> That might be fine if what you're logging is something more structural about the computation you're about to proceed with
17:34:50 <Cale> But usually you'd want information about the stuff that's actually going on as the state is changing
17:36:31 <Cale> This is why WriterT w m a is essentially defined to be the same thing as  m (w,a) -- you're running a computation of the transformed monad m, and it's producing a written log (of type w) along with its result of type a
17:36:54 <ezzieyguywuf> hrm, perhaps asking this question was above my current haskell level, lol
17:37:01 <Cale> Whereas Writer w (m a) is essentially the same as (w, m a)
17:37:09 <ezzieyguywuf> I've not yet really delved into monad transformers, and don't really have a need for logging right now
17:37:29 <ezzieyguywuf> though it seems wise to consider logging earlier in a project's lifet rather than later
17:37:51 <Cale> I wouldn't usually do logging with WriterT or really any logging transformer to be honest
17:38:06 <ezzieyguywuf> Cale: how would you do it?
17:38:09 <Cale> Almost always the stuff you're interested in logging is I/O-related parts of your program
17:38:16 <Cale> and so I tend to just do it directly with IO actions
17:38:29 <ezzieyguywuf> ah, I see
17:38:33 <ezzieyguywuf> like putStrLn?
17:38:54 <Cale> and if I need to abstract over what those IO actions are, then I'll add the function for logging to some probably-already-existing configuration record that's passed around my program
17:39:01 <Cale> More or less
17:39:12 <Cale> Probably writing to a file, rather than the terminal
17:39:35 <Cale> But yeah, if you want to abstract over what gets written and when, I don't think you need to transform the IO monad itself for that
17:39:53 <Cale> Just make sure that the things which do logging are abstracted over a way to write the log
17:40:01 * ezzieyguywuf nods
17:40:19 <ezzieyguywuf> I did fid the Write monad discussion in Learn You A Haskell rather insteresting though
17:40:42 <Cale> Writer and WriterT have some really interesting and unexpected use cases though
17:41:05 <Cale> WriterT (Product Rational) [] is a nice monad for keeping track of probabilities
17:41:11 <ezzieyguywuf> ....such as?
17:41:39 <ezzieyguywuf> actully, you know what, probably too advanced for me
17:41:40 <ezzieyguywuf> :-P
17:41:44 <Cale> i.e. here the "log" we're writing is a rational number which is meant to be the probability of the current path of computation
17:41:52 <ezzieyguywuf> took me wayyy to long to understand how Writer works
17:42:22 <Cale> and we're transforming the list monad, which lets you try all possible selections from a list
17:42:27 <koz_> Any profiling-with-Stack experts - how do I profile a Stack project with _only_ explicit cost centres? I can't find any information on this anywhere.
17:42:52 <wavemode__> a lot of real-world code just has an App monad which can handle all of your effects, and then there are really just App functions and non-App functions
17:43:00 <wavemode__> because granular effect tracking is, frankly, annoying
17:43:33 <Cale> http://dpaste.com/2PB09Q4
17:43:47 <Cale> this is a little program I wrote to evaluate probabilities in a card-flipping game
17:44:18 <Cale> https://cale.l5.ca/Demos/Armory/Armory.jsexe/ -- you can see a running example here, though without knowing how the game works, it's a little confusing
17:47:04 <Cale> But basically with that setup, do x <- uniform [1..6]; ... is like rolling a fair die -- x will be bound to a value between 1 and 6 (actually it will get bound to each in turn), and the probability will get tracked as 1/6 in each branch
17:47:22 <Cale> and so if you write something like  do x <- uniform [1..6]; y <- uniform [1..6]; return (x+y)
17:48:26 <Cale> It will produce a list of all the possible results and their probabilities, though at first, they won't be grouped nicely -- you'll just have a list with duplicates, and everything will have probability 1/36
17:48:46 <Cale> But applying that "collect" function I wrote will collapse them again
18:04:19 * hackage predicate-typed 0.6.2.0 - Predicates, Refinement types and Dsl  https://hackage.haskell.org/package/predicate-typed-0.6.2.0 (gbwey)
18:09:18 * hackage calamity 0.1.14.9 - A library for writing discord bots in haskell  https://hackage.haskell.org/package/calamity-0.1.14.9 (nitros12)
19:34:14 <teste> I just ran `cabal-install xmonad` and I would like to delete it. I am not a Haskell person. I looked in `cabal --help` but could not find an answer.
19:39:17 <suzu_> ghc-pkg unregister xmonad
19:39:45 <suzu_> i think that should do it
19:41:13 <teste> suzu_: yup =D 
19:52:12 <freeman42x[m]> how can I apply a binary operation on the 2 elements in this array with minmal code? ["7", "2"] asking for a friend. Getting them by index is too verbose for my friend
19:53:46 <freeman42x[m]> this, is too verbose: show$(z!!0)^(z!!1)where z=read<$>lines s
19:57:39 <wavemode__> foldr1 (^) z
20:02:07 <koz_> Anyone know how I can run an SQL insert in IO with beam?
20:02:14 <koz_> Its documentation isn't being terribly helpful there.
20:03:04 <wavemode__> have you read: https://mmhaskell.com/blog/2018/7/30/beam-database-power-without-template-haskell
20:03:12 <koz_> wavemode__: I will now!
20:03:53 <koz_> OK, I see. I need the PostgreSQL equivalent of 'runBeamSqlite'.
20:04:54 <wavemode__> Database.Beam.Postgres.runBeamPostgres
20:05:30 <koz_> I have no idea why I had such trouble finding it.
20:05:32 <koz_> Thanks!
20:44:01 <freeman42x[m]> wavemode__: thank you, this works: foldr1 (^) [2, 3] I do not understand how though
20:44:35 <Axman6> > foldlr1 (^) [2,3::Expr] 1 :: Expr
20:44:37 <lambdabot>  error:
20:44:37 <lambdabot>      • Variable not in scope:
20:44:37 <lambdabot>          foldlr1
20:44:46 <Axman6> > foldr1 (^) [2,3::Expr] 1 :: Expr
20:44:48 <lambdabot>  error:
20:44:48 <lambdabot>      • Couldn't match expected type ‘Integer -> Expr’
20:44:48 <lambdabot>                    with actual type ‘Expr’
20:45:00 <Axman6> > foldr1 (^) [2,3] 1 :: Expr
20:45:02 <lambdabot>  error:
20:45:02 <lambdabot>      • No instance for (Integral (Integer -> Expr))
20:45:02 <lambdabot>          arising from a use of ‘^’
20:45:40 <wavemode__> freeman42x[m]: well, to illustrate - foldr1 (^) [2] would equal 2. foldr1 (^) [2, 3] would equal 2 ^ 3. foldr1 (^) [2, 3, 4, 5] would equal 2 ^ 3 ^ 4 ^ 5
20:45:54 <wavemode__> foldr1 (^) [] would throw an exception
20:49:13 <freeman42x[m]> oh, I see, so for 1 element it does nothing and for later elements it applies the function between them
20:49:16 <freeman42x[m]> thank you
21:09:09 <freeman42x[m]> > [pure.last,id]<*>lines "9223372036854775807\n515648"
21:09:11 <lambdabot>  ["7","8","9223372036854775807","515648"]
21:09:53 <freeman42x[m]> is there a function which just applies function in first list to associated element in 2nd list without using zipWith or eq ?
21:13:39 <wavemode__> Control.Applicative has the newtype ZipList, which has an Applicative instance with those semantics
21:13:44 <wavemode__> > ZipList [(+1), (*5), (10 -)] <*> ZipList [1, 2, 3]
21:13:46 <lambdabot>  ZipList {getZipList = [2,10,7]}
21:18:04 <freeman42x[m]> ah, unfortunate, that is more verbose
21:18:32 <freeman42x[m]> zipWith($) is shorter
21:18:46 <freeman42x[m]> I can't figure out why this is wrong:
21:18:49 <freeman42x[m]> > read<$>zipWith($)[pure.last,id]$lines "9223372036854775807\n515648" :: [Int]
21:18:51 <lambdabot>  error:
21:18:51 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
21:18:51 <lambdabot>        Expected type: [[Char]] -> String
21:19:17 <freeman42x[m]> read takes a string and is mapped over a list of String, so... I am missing something
21:20:49 <wavemode__> precedence?
21:20:54 <wavemode__> > read<$> (zipWith($)[pure.last,id]$lines "9223372036854775807\n515648") :: [Int]
21:20:56 <lambdabot>  [7,515648]
21:22:05 <freeman42x[m]> thank you
21:23:18 * hackage implicit-hie 0.1.1.0 - Auto generate hie-bios cradles & hie.yaml  https://hackage.haskell.org/package/implicit-hie-0.1.1.0 (Avi_Dessauer)
23:21:53 <freeman42x[m]> for the list: ["Your honor, my client..","2","Yaur honor, my client..","Your hanor, my client.."] what would be a concise way to do something like zipWIth ["Your honor, my client..", ..] ["Yaur honor, my client..","Your hanor, my client.."]  ?
23:22:24 <freeman42x[m]> basically I want to run a map function of the zip of first list item repeated to the length of the elements from 3rd place to the end
23:22:40 <freeman42x[m]> , s/map/zipWith
23:23:10 <freeman42x[m]> trying to do it in 1 expression without any lets even if possible
23:24:32 <aleksd> help
23:25:15 <aleksd> ?src($)
23:25:15 <lambdabot> Unknown command, try @list
23:25:25 <aleksd> @list
23:25:25 <lambdabot> What module?  Try @listmodules for some ideas.
23:25:41 <aleksd> @listmodules
23:25:41 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
23:25:41 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:27:12 <aleksd> ?(src) ($)
23:27:12 <lambdabot> f $ x = f x
23:27:43 <aleksd> ?(src) Identity
23:27:43 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
23:28:11 <aleksd> ?(src) runIdentity
23:28:11 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:29:11 <aleksd> ?(src) Identity(runIdentity)
23:29:11 <lambdabot> Source not found. Are you typing with your feet?
23:29:36 <MarcelineVQ> that is the source of runIdentity:   newtype Identity a = Identity { runIdentity :: a }
23:30:11 <MarcelineVQ> writing that defines a function from  Identity a -> a
23:30:35 <MarcelineVQ> *a function of
23:30:36 <MarcelineVQ> :t runIdentity
23:30:37 <lambdabot> Identity a -> a
23:37:37 <kiwi_45> Hello All
23:38:09 <kiwi_45> I need help / guidance to integrate authentication in my running servant app
23:38:48 <kiwi_45> I have postgres as db and also integrated redis for managing session id in inMemory Db
23:40:21 <kiwi_45> My plan was I , authenticate user using postgres and after successful authentication I use redis to store username and session id tupple, and pass the session id to frontend which should be integrated in newer requests for valid serving
23:41:27 <kiwi_45> I went through servant-auth but still I'm not sure how to use it 
23:42:29 <kiwi_45> please someone help me / give me an idea what I need to do / example will be best / github's example is something I didn't got yet even after reading so many times
23:43:19 <kiwi_45> my repo : https://github.com/DeepakKapiswe/Gyan-Lahari-Backend
23:44:12 <gvx> freeman42x[m]: zip<$>(repeat.head)<*>(tail.tail) would be a way to do that. Is that, what your looking for?
23:44:22 <gvx> > zip<$>(repeat.head)<*>(tail.tail) $ ["Your honor, my client..","2","Yaur honor, my client..","Your hanor, my client.."]
23:44:24 <lambdabot>  [("Your honor, my client..","Yaur honor, my client.."),("Your honor, my clie...
23:50:24 <gvx> freeman42x[m]: Or better (drop 2) instead of (tail.tail) so it just returns an empty list instead of failing if the list is too short.
