00:17:00 <ph88> hello
00:17:36 <ph88> i have set in my package configuration a benchmark. How can i import the main program into the benchmark code ?
00:20:14 <tomsmeding> I believe you can only import a library into another package component; is your "main program" a library?
00:20:50 <tomsmeding> if so, you can just add that library as a dependency for your benchmark in the cabal file; note that the "main library" of a package is named the same as your package
00:31:05 <ph88^> hello all
00:35:04 <gentauro> ph88^: Chousuke: and ja thx for input :)
01:30:15 <ph88_> does ghc inline over modules ?
01:42:51 <phadej> yes
01:42:57 <phadej> sometimes
01:52:00 <ph88> tomsmeding, my main program is not a library yet. how can i make it one ?
01:55:03 <tomsmeding> ph88: you can do something like this: https://www.haskell.org/cabal/users-guide/developing-packages.html#example-a-package-containing-a-library-and-executable-programs
01:55:24 <tomsmeding> and then of course factor the right modules into the library, and keep the right ones in the executable
01:55:33 <tomsmeding> does that make sense?
01:57:09 <ph88^> tomsmeding, then the executable would be nothing more than    main = mainImported
01:58:01 <tomsmeding> for example :p
01:58:19 <tomsmeding> that's one way to split: just throwing everything on one side :)
01:58:42 <tomsmeding> depending, I guess, on what functionality exactly you want in your benchmark
01:59:45 <ph88^> i just want to benchmark the entire program as a whole
02:03:13 <Cheery> https://gist.github.com/cheery/c19e0709d92f5ab50c7d7f9ac05235ec
02:04:14 <tomsmeding> ph88^: yes then I suppose you could do it like that
04:40:47 <ph88_> do i only need   exposed-modules to make library code available for the main app ?
04:42:12 <ph88^> do i only need   exposed-modules to make library code available for the main app ?
04:45:14 <ph88^> should i add my own library as a dependencies on the main executable perhaps ?
04:45:29 <MarcelineVQ> ye must
04:52:51 <dminuoso> I think for all intents and purposes sub-library components are considered packages themselves, no?
04:53:20 <dminuoso> (Or internal libraries as the documentation calls it)
05:02:59 <Marcelo18> hi everyone!
05:03:14 <Marcelo18> can we ask programming questions here?
05:04:46 <enikar> programming questions about haskell are welcome
05:05:14 <Marcelo18> great!
05:08:34 <dminuoso> I wonder whether his hand-crafted IRC client is the Haskell program he has problems with!
05:13:36 <Hopplahase> KiwiIRC is written in JavaScript
05:14:03 <dminuoso> Who knows, ghcjs!
05:41:58 <ezzieyguywuf> how come this page doesn't have documentation for glVertexAttribPointer, even though I am able to use that function from this module? http://hackage.haskell.org/package/gl-0.9/docs/Graphics-GL-Core33.html
05:42:38 <dminuoso> ezzieyguywuf: See the top-most line/
05:43:37 <dminuoso> `module Graphics.GL.Core32`
05:43:38 <ezzieyguywuf> dminuoso: ah hah, thank you.
05:43:44 <dminuoso> I think that indicates it re-exports that entire module.
05:44:33 <ezzieyguywuf> i think you're right.
05:45:22 <merijn> Better rendered docs for re-export is part of the Haddock issue tracker ;)
05:46:32 <ezzieyguywuf> seems that hackage has been getting updated past few days
05:46:48 <ezzieyguywuf> at least, I'm seeing nicer looking formatting, i.e. with the purple themeing and whatnot
05:46:54 <dminuoso> ezzieyguywuf: That's actually not from haddock.
05:46:58 <dminuoso> Well not from hackage!
05:47:15 <dminuoso> I think hackage just displays whatever rendered page you provide it with.
05:47:34 <dminuoso> Some users have a newer version of haddock I guess?
05:48:00 <ezzieyguywuf> ah, i see
05:48:11 <merijn> ezzieyguywuf: The docs are part of the package upload, separate from Hackage
05:48:17 <ezzieyguywuf> yea, I've only ever used the latest haddock (latest as of, like, 4 or so weeks ago) and that's what my docs look like
05:48:27 <merijn> If you back to ancient package releases you'll see ancient styles
05:48:48 <merijn> Old school: https://hackage.haskell.org/package/Cabal-1.1.6/docs/Distribution-Simple.html
05:48:50 <dminuoso> Now.. perhaps an argument could be made that hackage itself generated the haddock documentation?
05:48:55 <ezzieyguywuf> I guess folks have been re-uploading or something, then, because I've noticed packages getting the new-school treatment
05:49:15 <merijn> ezzieyguywuf: Or making new releases :)
05:49:21 <dminuoso> ezzieyguywuf: It's possible that the new haddock version slipped into a stack resolver perhaps?
05:49:28 <dminuoso> (Especially if that was suddenly)
05:50:22 <ezzieyguywuf> hm, I want to build a list from a list, with a value that accumulates as I go
05:50:31 <merijn> :t scanl
05:50:33 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
05:50:33 <ezzieyguywuf> it's like both a map _and_ a fold
05:50:39 <ezzieyguywuf> nice!
05:50:49 <dminuoso> Holld on, a map *and* a fold?
05:50:53 <dminuoso> % :t foldMap
05:50:53 <yahb> dminuoso: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:50:55 * dminuoso chuckles
05:50:57 <merijn> dminuoso: map with state
05:51:05 <dminuoso> merijn: I know. Just wanted to make a funny remark.
05:51:15 <ezzieyguywuf> nah, it's only like a 'fold' insofaras it has a starting value that 'accumulates' as you continue
05:51:18 <ezzieyguywuf> I bet scanl is what I want
05:51:24 <kuribas> :t mapAccumL
05:51:25 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
05:51:41 <dminuoso> I think mapAccumL is the one.
05:51:58 <dminuoso> Well, its more powerful
05:52:08 <dminuoso> (Its useful if the state you want is separate from the values you are generating)
05:52:33 <ezzieyguywuf> it's not seperate. It's something like `length a`
05:53:20 <kuribas> :t \f -> evalState . mapM (State f)
05:53:21 <lambdabot> error:
05:53:21 <lambdabot>     • Data constructor not in scope:
05:53:21 <lambdabot>         State :: t -> a -> StateT s Identity b
05:53:21 <ezzieyguywuf> I don't need the value in the final [b], just need it to produce the b
05:54:16 <ski> @type (runState .) . mapM . (state .)
05:54:17 <lambdabot> Traversable t => (a -> s -> (b, s)) -> t a -> s -> (t b, s)
05:54:22 <merijn> ezzieyguywuf: So you just need a fold, then?
05:55:31 <ezzieyguywuf> merijn: hrm, I don't think so.....maybe. I should just try it and see.
05:57:22 <dminuoso> ezzieyguywuf: Could you elaborate a bit more on what you are trying to do?
05:57:24 <merijn> ezzieyguywuf: What was the "map" supposed to do?
05:58:01 <dminuoso> There's quite a few tools in the rough area you are describing, between State, unfoldr, mapAccumL, scanl, and others..
05:58:08 <ezzieyguywuf> hah, I do think I 'just need a map'. Let me try to sketch it up and I'll show you what I'm trying to do if it doesn't work
05:58:08 <MarcelineVQ> ye, what are you actually doing? because "<ezzieyguywuf> hm, I want to build a list from a list, with a value that accumulates as I go" describes mapAccum  If you want to get more powerful than that you might be in foldl territory   https://hackage.haskell.org/package/foldl
05:58:16 <merijn> Honestly, even foldr might be enough :p
05:58:35 <dminuoso> Or a foldMap? Who knows!
05:58:43 <dminuoso> Never not foldMap. Screw performance.
05:58:54 <merijn> dminuoso: We have strict foldMap now!
05:58:57 <ski> they wanted to build a list
05:58:58 <dminuoso> We do?!
05:59:00 <dminuoso> Where is it?
05:59:15 <frobnicator> :t foldMap
05:59:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:59:16 <merijn> dminuoso: Since 8.8 we have foldMap'
05:59:23 <merijn> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html#v:foldMap-39-
05:59:24 <dminuoso> Oh goodie.
05:59:56 <dminuoso> But that still fuses poorly, doesnt it?
06:12:00 <ezzieyguywuf> hrm, ok so here's where I ran into an issue: https://gitlab.com/ezzieyguywuf/learnopengl/-/blob/master/src/GraphicData.hs#L45
06:12:17 <ezzieyguywuf> you can see on line 39 where I'm trying to use foldl, but foldl is obviously not the right choice here.
06:12:54 <dminuoso> Haha, you too have "cum" prefixes in your code.
06:12:59 <dminuoso> I earned a lot of eyebrows for that
06:13:13 <ezzieyguywuf> maybe I need `makeData` to return a (Int, AttributeData), and then squash it afterwards?
06:13:22 <ezzieyguywuf> dminuoso: lol, I thought it was pretty standard
06:13:33 <merijn> ezzieyguywuf: That's a pretty straightforward solution, yes
06:13:34 <ezzieyguywuf> (which I guess technically is a 'state'
06:13:38 <ezzieyguywuf> )
06:13:39 <dminuoso> ezzieyguywuf: Here we work a lot with cumulus linux, so that's why... :)
06:13:51 * ezzieyguywuf googles cumulus linux
06:14:18 <merijn> ezzieyguywuf: Does the Int correspond to the index field of AttributeData?
06:15:22 <ezzieyguywuf> merijn: the Int in the call signature of `makeData`?
06:15:38 <merijn> ezzieyguywuf: No, I meant the (Int, AttributeData) you were contemplating?
06:16:10 <ezzieyguywuf> ah, no the Int is the accumulated size of the data. hrm...there's a nice graphic that explains this, one sec.
06:16:28 <ezzieyguywuf> https://learnopengl.com/Getting-started/Textures
06:16:42 <ezzieyguywuf> under "applying textures", it shows the 'offset'
06:16:49 <merijn> ezzieyguywuf: I just meant that, depending on what the Int you need for your fold is you might not even need to construct (Int, AttributeData)
06:16:56 <ezzieyguywuf> it's essentially the cumulative sum of the size of the data behind it
06:20:25 <ezzieyguywuf> hrm, the Int comes from a (as of yet unwritten) function `getAttribLength :: VertexAttribute -> Int`, which returns a 3 for Position, 2 for Texture
06:20:36 <ezzieyguywuf> essentially the length of the VertexAttribute
06:27:34 <merijn> ezzieyguywuf: Basically, my point was that if you have a fold "AttributeData -> b -> b" (or whatever) then you can still apply arbitrary functions to AttributeData in that fold function, so if the value is derived directly from that (as it would be with a map) then you can just compute that derived value inside your fold function
06:28:53 <ezzieyguywuf> merijn: yes that makes sense, but the value is comprised of not only data in the `AttributeData` but the data in the `AttributeData` before it in `[AttributeData]`
06:29:11 <merijn> ezzieyguywuf: Right, but then that's just the fold :p
06:29:27 <ezzieyguywuf> ah
06:30:15 <ezzieyguywuf> nah wait - I understand that if I only care about the final `b` in `(b -> a -> b) -> b -> t a -> b`, but I want to store this `b` in each `AttributeData` that I'm building
06:30:41 <merijn> Right, but then you want scanl
06:30:49 <merijn> :t scanl
06:30:50 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
06:31:12 <merijn> That builds a list of bs starting from an initial input of as
06:32:48 * hackage pdftotext 0.0.2.0 - Extracts text from PDF using poppler  https://hackage.haskell.org/package/pdftotext-0.0.2.0 (geyaeb)
06:33:12 <ezzieyguywuf> hah, yea, right back where we started but it does appear tho correct solution
06:33:43 <ezzieyguywuf> it's so nice how in the functional programming methodology I can hone in and focus on precisely these sorts of algorithm questions
06:35:10 <marcelo17> hi
06:35:51 <marcelo17> how can i convert a number to float in haskell?, so that the parameter float could receive int
06:36:07 <merijn> @quote monochrom who.do.you.call
06:36:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:36:45 <ezzieyguywuf> ghost busters theme, I'm imagining
06:36:54 <merijn> ezzieyguywuf: Clearly
06:47:33 <kuribas> is ghc-lib-parser broken?  /opt/ghc/8.4.4/lib/ghc-8.4.4/template-hsc.h:75:24: error: ‘struct StgInfoTable_’ has no member named ‘srt’
06:48:10 <kuribas> ghc-8.4.4
06:49:35 <frdg> So I just learned about using vi mode in ghci and I'm trying to configure it. I have already edited my ~/.haskeline file to set vi mode. I am trying to figure out how to remap my escape key and configure ghci to show me which mode I am in. Any advice?
06:50:12 <merijn> I don't think you can? Pretty sure readline doesn't support that either
06:51:21 <ezzieyguywuf> hrm, I'm still struggling. http://dpaste.com/07QFFC7
06:51:32 <ezzieyguywuf> This distills now the core problem I'm trying to solve.
06:51:34 <frdg> merijn: readline does support these things. I added `set show-mode-in-prompt on` to my .inputrc and it magically worked
06:51:49 <merijn> hmm
06:53:11 <ezzieyguywuf> lol whoops, line 14 should read `, MyData 3 4 "data"`
06:53:23 <ski> ezzieyguywuf : ah, was just about to ask about that :)
06:53:42 <ezzieyguywuf> http://dpaste.com/2T9S4HM corrected examples
06:53:45 <ezzieyguywuf> *example
06:55:22 <ezzieyguywuf> honestly, this does a better job, http://dpaste.com/2885XKT
06:55:28 <merijn> ezzieyguywuf: that one could actually be achieved by having a list partially applied MyData constructors and doing "zipWith ($)" ;)
06:55:28 <ski> ezzieyguywuf : looks to me like a simple `mapAccumL', yes
06:55:35 <ezzieyguywuf> b/c I'm truly interested in "offset", which shows the cumulative effect I was talking about earlier
06:56:17 <merijn> Partially applied MyData gives [String -> MyData]
06:56:34 <ski> ezzieyguywuf : so `offset' doesn't include the white space between the words ?
06:56:34 <merijn> ah
06:57:07 <ezzieyguywuf> ski: it does not, the whitespace is only there so I could easily produce the raw data using `words`
06:58:02 <ski> ezzieyguywuf : should `MyData 3 4 8 "data"' be `MyData 3 4 10 "data"' ?
06:58:27 <ezzieyguywuf> *facepalm* yes
06:58:56 <ski> (i only noticed that discrepancy when comparing the output i got with calling `mapAccumL' with your `finalOutput'(
06:59:02 <ezzieyguywuf> http://dpaste.com/2ZDS0YH with the correction
06:59:59 <ezzieyguywuf> i think you're right about mapAccumL :-P
07:00:07 <ski> anyway, i think `scanl' is less ideal here, since you want to produce a list of the same length, not a list having one more element
07:00:34 <ezzieyguywuf> ski: true. I looked at scanl1 but that wasn't right either
07:00:44 <ski> you could also use `mapM' with `evalState', if you prefer .. it's the same thing, really, just dressed up slightly differently
07:02:00 <ezzieyguywuf> I see that mapAccumL does include a 'state' in it, so I can understand haw the `mapM` approach is doing the same thing
07:02:50 <merijn> It's all folds all the way down ;)
07:05:27 <younder> Aren't all these states a hinder for paralleling these functions over lists
07:06:22 <ezzieyguywuf> hrm, the mapAccumL method nicely produces the final output, but I did want all the intermediates as well
07:06:27 <ezzieyguywuf> like scanl did
07:07:02 <ezzieyguywuf> younder: I'm not worried about parrallizing things yet
07:07:03 <ski> if you wanted to, you should be able to break the list up into a roughly balanced tree, transform the subtrees in parallel, then monoidally recombine the results again
07:07:10 <ezzieyguywuf> figured I'd worry about that when performance became a problem
07:09:12 <ski> ezzieyguywuf : the "final output" should just be the final state
07:10:23 <ezzieyguywuf> ski: I don't understand - notice that the `finalOutput :: [MyData]` which mapAccumL does not produce
07:11:01 <ezzieyguywuf> oh wait, that's on 
07:11:02 <ezzieyguywuf> me
07:11:07 <ezzieyguywuf> I didn't write someFunc correctly
07:11:15 <ski> `mapAccumL' will produce `(s,[b])' for you, where `s' is the state, and the `b's are what you transformed the input `a's into
07:11:23 <ezzieyguywuf> (I think)
07:11:40 <ski> so, in your case, `b' should be `MyData'
07:12:39 <ski>   mapAccumL :: (s -> a -> (s,b)) -> (s -> [a] -> (s,[b]))  -- using this naming
07:20:02 <ezzieyguywuf> wahoo!!! http://dpaste.com/3V30FSB
07:20:05 <ezzieyguywuf> thanks ski and friends!
07:21:48 * hackage cabal-rpm 2.0.5.1 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-2.0.5.1 (JensPetersen)
07:22:46 <ski> ezzieyguywuf : yep, and then you discard the final state (just the offset, in that paste) .. unless you'd have any further use for it
07:23:49 <ezzieyguywuf> ski: no you're right, I discard it. It has served its purpose.
07:41:07 <kuribas> I am trying out vscode (for collegues).  Is there a way to run ghci in vscode?
07:42:38 <kuribas> I must say, hie integration looks much better in vscode than in emacs.
07:43:29 <ph88_> i get this error while compiling Criterion, could someone help ?  https://bpa.st/HMSA 
07:46:57 <kuribas> well, I suppose I can just run cabal v2-repl in the terminal...
07:48:06 <kuribas> ph88_: pthread should come with mingw, no?
07:48:46 <ph88_> kuribas, i don't know if it should ... i also tried installing it seperately with pacman
07:53:46 <kuribas> yuck, Haskell GHCi Debug Adapter Phoityne forces you to use stack
07:57:15 <tdammers> "forces"
07:57:28 <tdammers> as in "holds you at gunpoint" or "threatens to eat your firstborn alive"?
07:57:42 <tdammers> or more like "cannot currently be built without stack"?
07:58:35 <tdammers> this is only half sarcastic, because often the only reason for something like this is because the author uses stack, has no incentive to add cabal support, and nobody else has stepped up yet
08:06:47 <dminuoso> Generally, do you actually need stack? I found that you generally can get away with just hunning hpack and cabal v2-build...
08:07:07 <dminuoso> It's just that projects neglect to keep the .cabal file in the repository...
08:07:56 <kuribas> tdammers: well, perhaps I can customize it to use cabal, as there is a configuration file
08:08:48 * hackage HPDF 1.5.0 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.5.0 (SylvainHenry)
08:09:16 <kuribas> tdammers: I suppose also historically, because before v2, stack was the best solution.
08:11:42 * ski . o O ( "The only real strong opinion I have is that you should avoid Stack's (optional) use of hpack at all costs." )
08:11:46 <jumper149> Hi, I want to derive MonadBaseControl IO for `newtype AppM r a = AppM (ReaderT r Handler a)`, where Handler is from Servant.Server and alreade has the instance `MonadBaseControl IO`
08:12:33 <phadej> historically v2-build was already in development when stack was announced. The first cabal-install with nix-style builds is 1.24 (released in 2016)
08:12:43 <jumper149> If anyone has an idea which deriving mechanism I should use, I would be grateful
08:13:03 <phadej> if everyone (me included) didn't jump on stack hype train, v2-build would been better sooner than "now"
08:13:17 <jumper149> Currently I only tried GeneralizedNewtypeDeriving, but that didn't work
08:13:30 <ph88_> is this a GHC bug ? https://bpa.st/HMSA 
08:14:59 <merijn> phadej: https://imgflip.com/i/44s73i ;)
08:15:14 <phadej> merijn: :D
08:17:13 <kuribas> jumper149: I wouldn't use it at all
08:17:45 <kuribas> jumper149: use IO for resource passing functions.
08:19:27 <kuribas> jumper149: however, since your type doesn't have IO, MonadBaseControl IO wouldn't derive, right?
08:20:31 <jumper149> kuribas: Something was ambiguous, but I don't remember what exactly
08:21:00 <jumper149> Handler has the instance MonadBaseControl IO, so I'm not sure what you mean
08:21:11 <ski> "Handler [..] alreade has the instance `MonadBaseControl IO`" ?
08:21:45 <kuribas> right...
08:22:19 <ski> jumper149 : "Currently I only tried GeneralizedNewtypeDeriving, but that didn't work" -- didn't work, in which way ?
08:23:56 <jumper149> ski: I just noticed a different problem... I want to derive Control.Monad.Trans.Control.Aligned.MonadBaseControl IO, but Handler has the instance Control.Monad.Trans.Control.MonadBaseControl IO
08:24:05 <jumper149> That might be the problem I was facing
08:24:37 <jumper149> But now I really don't know what to do^^
08:24:48 <dminuoso> What the heck is monad-control-aligned...
08:25:17 <dminuoso> Good thing I've went the unliftio route... :(
08:27:45 <jumper149> I guess I should stay away from some libraries...
08:28:41 <dminuoso>  jumper149  If ReaderT is all you have in your stack, you can just use MonadUnliftIO instead.
08:28:56 <dminuoso> It's much much easier to use :)
08:35:39 <jumper149> dminuoso: I will probably add RWST to the stack later on
08:36:03 <jumper149> dminuoso: Thanks for the tip though, it really seems a lot easier^^
08:36:21 <jumper149> dminuoso++
08:37:13 <Cheery> So I understand that cut-free structures are useful in a sense that they can be used to decide equality of proofs/programs.
08:38:05 <Cheery> then there's some procedure to figure out whether two structures are equal, but I wonder if there's papers/books on this.
08:39:32 <tdammers> ski: given the choice of sacrificing my first-born on a satanistic altar vs. using hpack, I'd probably go for the latter, but it's a close call
08:41:14 <kuribas> ah, haskell-linter shows warnings as errors, how annoying...
08:43:51 <ezzieyguywuf> https://hackage.haskell.org/package/GLFW-b-3.2.1.0/docs/src/Graphics.UI.GLFW.Types.html#CursorInputMode
08:43:59 <ezzieyguywuf> what do the apostrophes mean in these constructors?
08:44:08 <ezzieyguywuf> oh nvm
08:45:04 <solonarv> ezzieyguywuf: apostrophes can just be part of identifiers, same as letters number or _
08:45:10 <solonarv> it doesn't mean anything in particular
08:46:12 <ezzieyguywuf> got it
08:48:41 <phadej> Cheery: you might want to look on books of proof theory; and they don't need to be "new"
08:49:04 <phadej> but I haven't found any individual textbook which explains it all
09:06:14 <ezzieyguywuf> ok! cleaned up my code enough that I'm ready to capture the mouse and learn about IORef :)
09:06:18 * hackage zettelkast 0.1.0.0 - Command-line utility for working with zettelkast files  https://hackage.haskell.org/package/zettelkast-0.1.0.0 (MasseR)
09:22:31 <John20> Hi, I would like to process the contents of a file, however, if that file does not exist, I would like to return a default value. currently my code looks something like this:
09:22:35 <John20> `doStuff file = 
09:22:35 <John20>   let        
09:22:35 <John20>     fileExists = doesFileExist file
09:22:35 <John20>   in
09:22:35 <John20>     f <$> fileExists <*> BL.readFile file `
09:23:43 <dminuoso> John20: That's racy. It's better to just read the file and catch the exception.
09:24:02 <ClaudiusMaximus> :t catch
09:24:03 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
09:24:13 <John20> However, even though the fileExists is false, and the contents of the file are not accessed by 'f' the program still reads it. Could someone help me to rearrange the code so that it works the way I would like it to e.g. only read the file if fileExists evaluates to true
09:25:03 <John20> Thanks all. I'm still learning and I'm trying to avoid Exceptions for the time being (until I get to them in the book!)
09:25:17 <dminuoso> John20: Dont be scared of exceptions! :)
09:25:42 <Cale> You should understand how to write the thing you wanted to write though
09:25:45 <Cale> It would look like:
09:25:46 <Cale> do fileExists <- doesFileExist file; if fileExists then ... else BL.readFile file
09:25:54 <infinity0> do you guys know how to use a customer version of "containers" in your workspace?
09:26:03 <infinity0> i added it to cabal.project and now cabal is complaining about dependency resolution
09:26:09 <infinity0> i'm trying to use git HEAD from github
09:27:18 <infinity0> er, custom version* with my own edits not a customer's lol
09:27:28 <Cale> John20: Inside a do-block, the statement  v <- x  means "execute the action x, and name its result v"
09:27:43 <John20> Thanks Cale. That's very close to my applicative code. I'll give it a try. Need to figure out why the evaluation is different for both of them
09:27:51 <Cale> John20: If you write something like  let v = x  you'll just end up defining v to be the same action as x
09:28:03 <Cale> You won't execute x
09:28:55 <John20> I think that it's something about the applicative though as this also fails:
09:28:58 <John20> `doStuff file = 
09:28:58 <John20>   let        
09:28:58 <John20>     fileExists = doesFileExist file
09:28:58 <John20>     content = BL.readFile file 
09:28:58 <John20>   in
09:28:59 <John20>     f <$> fileExists <*> content`
09:29:07 <Cale> John20: Applicative can't decide what computations to execute based on the result of previous computations
09:29:12 <Cale> at all
09:29:42 <yushyin> infinity0: how did you added it to your cabal file, what is the cabal error in detail?
09:29:44 <Cale> If you combine a bunch of things with <*> they will all be executed in turn, and their results will be combined afterward
09:31:33 <Cale> This is why do-notation and the Monad class are more expressive -- x >>= f will first execute x, and then apply f to its result in order to decide what action to proceed with
09:31:41 <Cale> (when executed)
09:32:05 <Cale> Note that what you have there is exactly the same as writing
09:32:22 <Cale> f <$> doesFileExist file <*> BL.readFile file
09:32:39 <Cale> Those names are not particularly good ones
09:33:02 <Cale> because you're naming the actions which are still not executed
09:33:28 <Cale> i.e. fileExists is not a Boolean result, it's an action which each time you execute it, will look and see if that file is there
09:33:59 <cjen1> Hi all, looking for some debugging advice. I have a stack install locally which builds my program perfectly, however in ci (built from the haskell:8.8.3 docker image) it fails with cabal "can't find source for ... in src". What does cabal search, and what possible reasons are there for this to differ between them?
09:34:07 <Cale> and content is not a ByteString, it's an action which will read the file each time it's executed, producing the contents.
09:34:26 <Cale> Does that make sense?
09:34:49 <dminuoso> cjen1: Even stack uses cabal under the hood.
09:35:04 <John20> Thanks Cale. That's really helpful. I've converted my code to use the monad >>= function and it works correctly. 
09:35:32 <dminuoso> The thing that makes stack special, is curating the set of packages available to cabal (a set of such packages is called a resolver), and shipping a GHC version. 
09:35:41 <dminuoso> cjen1: Can you paste/share the full output of the ci pipepine?
09:35:45 <Cale> You might find it easier to use do-syntax
09:36:22 <Cale> @undo do fileExists <- doesFileExist file; content <- BL.readFile file; f fileExists content
09:36:22 <lambdabot> doesFileExist file >>= \ fileExists -> BL.readFile file >>= \ content -> f fileExists content
09:36:31 <John20> I see your point about naming. I'll try to treat IO as more like an action than a value. 
09:36:56 <Cale> Of course, IO actions are values, they're just not the same as the results you'll get from executing them
09:37:00 <cjen1> Ok is it possible to check the versions of cabal which each one is using? (I would have expected something like `stack exec cabal -- -- version` but that doesn't seem to work)
09:37:08 <Cale> It's like the difference between /bin/ls and a list of files in your home directory
09:37:20 <John20> I'm deliberately avoiding do syntax for the time being. I found that it wasn't helping me to properly understand what was going on. So far, I'm quite enjoying working without it! Don't really miss it at all
09:37:21 <Cale> One is a program, the other is a bunch of text
09:37:47 <tdammers> John20: that's a good mindset. keep that spirit :)
09:38:14 <Cale> That's fair, though I actually think that things can be understood just fine either way around
09:38:43 <Cale> We happen to choose (>>=) as the thing which do-syntax desugars into, because that's a little easier to specify in one go
09:38:50 <John20> I'm sure that once I understand stuff, do syntax will make things much faster to write and clearer, it's just that for me, it muddies the water atm
09:38:55 <dminuoso> cjen1: I dont know the internals of stack, it might not use the cabal binary itself.
09:39:02 <Cale> It works roughly like this:
09:39:17 <Cale> do { stmt } = stmt  (base case, when there's just one statement)
09:39:35 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
09:39:58 <Cale> do { let { <decls> }; <stmts> } = let { <decls } in do { <stmts> }
09:40:12 <cjen1> @dminuoso btw I'm getting the same behavior on powershell, it seems like its literally just my wsl ubuntu install which works consistency 
09:40:12 <lambdabot> Unknown command, try @list
09:40:12 <Cale> oh, and:
09:40:25 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
09:40:35 <Cale> which is the same as  x >>= \_ -> do { <stmts> }
09:40:52 <Cale> (i.e. we just discard the result of x and proceed with the rest regardless)
09:41:37 <Cale> There's a *little* more to it than that though -- there's a case for handling pattern match failure on the left of a <-
09:42:29 <Cale> do { pat <- x; <stmts> } = x >>= \v -> case v of pat -> do { <stmts> }; _ -> fail "some message that includes the line number..."
09:42:38 <Cale> Whenever pat is a pattern that could fail to match
09:42:56 <John20> Thanks Cale. I've saved that whole block in a file. It's a great explanation of what do means.
09:44:22 <infinity0> yushyin: it's added to cabal.project and i just symlinked it into my workspace
09:45:58 <maralorn> Is there a way to tell cabal to use an externally provided library instead of the one from the cabal file, when running tests?
09:47:35 <infinity0> generally you can add local dependencies to cabal.project yeah
09:54:40 <monochrom> Too bad John20 has left. Could have been informed that https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14 exists
09:55:37 <monochrom> When the last RTFM dinosaur dies (that's me), humanity will simply assume that knowledge = hearsay.
09:56:30 <MarcelineVQ> I knew that, I read it on wikipedia
09:56:43 <monochrom> They still have written language, but they will use it the same way people used oral pass-downs before there was written language, creating only myths and rumours, not books.
09:56:49 <monochrom> haha
09:57:46 <maerwald> I heard about wikipedia.
09:58:43 <monochrom> also https://xkcd.com/1683/
10:02:03 <justsomeguy> lol, i refreshed the page a few time
10:02:07 <justsomeguy> s
10:02:16 <justsomeguy> fsck
10:02:21 <monochrom> haha
10:02:58 * maerwald disables adblocker
10:06:31 <Cale> I like the mojibake in the image title
10:07:08 <shyam> Can ghc llvm ir be compiled to wasm so that we can compile and run haskell code entirely in the browser?
10:07:16 <pie_> isovector book vibes https://blog.troutwine.us/2018/06/07/hands-on-concurrency-with-rust/
10:07:24 * pie_ queues reading this for later
10:07:43 <pie_> they both wrote some toolin for writing their book and stuff
10:08:02 <Cale> shyam: That's already being worked on, but if you want to run Haskell entirely in the browser today, it's probably better to use ghcjs to do it still
10:08:54 <shyam> I need in browser compilation support? Is that possible with ghcjs?
10:09:05 <Cale> (We use ghcjs where I work to build web applications, and cross compile the same code to ARM and run it on Android and iOS devices)
10:09:26 <Cale> oh, no, I don't think anyone's attempted that yet
10:09:35 <Cale> It would be painfully slow
10:11:24 <monochrom> pie_: I feel better now. I spent forever when making new lecture notes, slides, assignments, exams.
10:11:54 <monochrom> Now I see that 100-1000 hours per lecture-hour is normal :)
10:12:08 <sm[m]> Cale: nifty, what does your app(s) do again ?
10:12:48 <pie_> pff
10:13:55 <maerwald> Cale: does anyone except your company use obelisk?
10:14:37 <Cale> maerwald: Some others, yeah. A lot of them end up being our clients at one point or another.
10:15:20 <maerwald> see, opensource works
10:15:27 <maerwald> ;)
10:15:30 <Cale> yep
10:16:28 <monochrom> haha
10:16:53 <Cale> sm[m]: A bunch of different things for different clients. Most of it breaks down into startups with various services, and blockchain-related tools.
10:17:04 <Cale> https://obsidian.systems/ has a list of a bunch of our clients
10:17:10 <monochrom> But no, it is a clever combination of gateway drug and lock-in-by-theory.
10:17:50 <monochrom> The lock-in-by-theory part is implemented by using FRP so they don't understand it and must come back to you.
10:18:10 <Cale> haha, but we *do* get things done pretty nicely with it
10:19:08 <monochrom> Well yeah, someone has to understand it, lest no one would profit from it.
10:20:15 <Cale> It's not really obfuscation, it's actually quite a productive way to get things done, but like any change in approach, takes some getting used to.
10:20:32 <Cale> I suppose the same can be said about the use of Haskell in general.
10:21:07 <monochrom> We smart people underestimate how average people would rather hire than learn.
10:22:00 <monochrom> A very balanced, down-to-earth worldview can be obtained by observing students in business management major.
10:22:12 <monochrom> even their profs
10:22:54 <monochrom> Did you know: standard practice for those profs to give way too much hint to students so the grades look better.
10:23:19 * hackage aura 3.1.3 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.3 (fosskers)
10:23:34 <sm[m]> Cale: thanks, great home page
10:23:39 <maerwald> most problems in software are man made, not real
10:24:22 <monochrom> And you already know: the students, in turn, offer money to math majors for doing homework. And here the management students are smart, I give them that: the price is cheap, and the math major is too dumb to bargain.
10:24:47 <sm[m]> maerwald: s/in software //. FTFY
10:26:07 <maerwald> if you need to hire smart devs... you're already in trouble :p
10:27:02 <monochrom> Perhaps s/We smart people/We geeks/
10:27:10 <Cale> The tricky thing about having a team full of smart devs is making sure they don't exercise all their cleverness all the time.
10:27:55 <maerwald> yes, so don't hire smart devs
10:27:58 <Cale> haha
10:28:03 <MarcelineVQ> That's why quippy dev's are the better breed
10:28:11 <Cale> There are downsides to the opposite approach as well
10:28:12 <MarcelineVQ> sarcastic beats snappy every time
10:28:34 <monochrom> then hire me! I'm sarcastic
10:28:49 <MarcelineVQ> You're not sarcastic you're curmugeony :>>>
10:29:03 <monochrom> I need to look up curmugeony
10:29:26 <monochrom> haha
10:29:27 <maerwald> Cale: knowledge can be shared, attitude not
10:29:34 <monochrom> Get out of my lawn!
10:29:45 <pie_> get out of my runtime
10:29:59 <MarcelineVQ> pie_: rewrite me out :>
10:31:57 <Cale> maerwald: And wisdom/taste
10:33:35 <maerwald> and haskell is a language predestined for people to exercise their cleverness, so building a haskell team is particularly hard
10:34:30 <maerwald> there, I said it
10:35:12 <maerwald> good languages can be difficult for team building
10:35:52 <pie_> thelispproblem.html
10:36:45 <Cale> maerwald: Yeah, I don't think it's impossible to maintain the right culture, but there's a tendency there which needs to be kept in check. :)
10:38:06 <Cale> I've seen what can happen at other companies who are less successful at it -- singletons and other approximations of dependent types being used to guarantee properties statically that nobody ever once cared about.
10:38:19 * hackage commander-cli 0.4.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.4.0.0 (sgschlesinger)
10:39:07 <monochrom> I met a person, not very smart, but still did that.
10:39:44 <monochrom> So my perspective is more on enthusiasm, less on cleverness.
10:39:53 * sm[m] was never smart enough to try that
10:40:08 <monochrom> (Also, that person was not very successful in that, it's an incomprehensible XY-problem mess)
10:40:46 <monochrom> This is why, instead, if you emphasize enthusiasm when hiring, you are in deep trouble.
10:40:57 * int-e wants to have dependable types.
10:41:10 <monochrom> Because it simply means getting carried away.
10:41:17 <maerwald> some smart people appreciate KISS
10:41:35 <pie_> i appreciate KISS but was never any good at it
10:41:36 <maerwald> find them
10:41:42 <monochrom> Focus? Oh, sure, they will have so much focus. Focus on getting carried away, and OCD, etc.
10:42:11 <pie_> monochrom: been there
10:42:38 <maerwald> monochrom: so hire depressed devs?
10:42:49 <monochrom> level-headed
10:42:49 <pie_> probably helps to have been mentored
10:42:52 * pie_ wouldnt know
10:43:30 <pie_> otherwise yo have to go figure everything out yourself and either that probably selects for enthusiasm
10:43:36 <pie_> s/either//
10:44:01 <pie_> then again maybe the people that actually get anywhere with self study are pragmatic?
10:46:01 <monochrom> success in self study is a function of topic and cleverness in that topic
10:46:07 <maerwald> monochrom: I believe in healthy tension: need a pessimistic dev as well as an optimistic one
10:46:29 <monochrom> so it is stil orthogonal to getting over-excited and getting carried away.
10:47:25 <pie_> some people just cant see ahead of time why some things wont work though , somewhat related, having experience is probably important in deciding
10:47:38 <int-e> maerwald: that sounds like a recipe for desaster :P
10:47:54 <pie_> and now i wonder how engineering conservativism correlates with age or experience 
10:47:58 <monochrom> both smart and dumb people, both successful and failing people, can be either easy-excited or level-headed, there is not going to be a correlation.
10:48:53 <maerwald> int-e: if they don't like each other
10:48:55 <pie_> I guess.
10:49:08 <monochrom> For examples of smart successful people getting carried away, look at haskell wiki and blogs.  For examples of dumb failing people getting carried away, look at ardent followers of religions and cults.
10:50:17 <Cheery> phadej: thanks. I'll see what I find with that search.
10:50:50 <maerwald> monochrom: was L. Ron Hubbard dumb?
10:51:08 <monochrom> No, but he's the leader.
10:51:27 <monochrom> Add his example to the "look at haskell wiki and blogs" category
10:51:31 <int-e> maerwald: I see you're taking the role of the optimist here
10:51:41 <maerwald> monochrom: loool
10:51:46 <int-e> (with some qualifications)
10:51:51 <monochrom> For examples of smart successful people getting carried away, look at haskell wiki and blogs and founders of religions and cults.  There!
10:52:48 <maerwald> int-e: I believe in experiments too ;)
10:53:31 <int-e> watch the fireworks from a distance? hmm
10:53:41 <maerwald> but then I tend to throw everything away
10:54:23 <maerwald> some day it will work
11:01:44 <Cheery> wondering how many ppl got burned by Javascript's promises not being monadic
11:03:27 <berndl> Only the ones that know what "monadic" means.
11:03:49 <monochrom> :)
11:04:07 <monochrom> how is it not monadic? is it applicative?
11:04:59 <Cheery> They did the Promise (Promise x) coercing implicitly to Promise x
11:05:49 <monochrom> hrm
11:06:09 <dolio> It does?
11:06:56 <Cheery> Should check to be sure. I haven't been touching promises much.
11:08:18 <Cheery> but some confusing over bind/map etc.. there were.
11:09:16 <Cheery> https://github.com/promises-aplus/promises-spec/issues/94
11:10:00 <berndl> I don't think anything in Javascript is lawful.
11:10:10 <berndl> https://hgiasac.github.io/posts/2017-20-12-Are-Promises-Monads-Functor-or-Applicative.html
11:10:24 <dolio> Oh yeah, there is some stuff where 'map' will automatically flatten sometimes.
11:10:59 <dolio> But not always, of course.
11:12:18 <ja> i don't know how it can be a surprise to anyone that js is not adhering to fp principles. it's a pointless discussion. you know js advocates will say "but look how much improved productivity we have". now you're just arguing about values. may as well argue about religion
11:13:34 <MarcelineVQ> yeah, take that, you!
11:13:41 <monochrom> I take it further. s/js/"real world"/   s/fp/logical consistency/
11:14:18 <berndl> ilogical inconsistency is what it's all about
11:14:39 <EvanR> iLogic
11:14:54 <EvanR> (tm)
11:20:55 <dolio> Functional programming isn't the opposite of "improved producitivity."
11:21:59 <ja> the js programmer will have "economic proof" by counting number of programmers, number of startups based on language
11:23:37 <dolio> It doesn't sound like that makes any sense.
11:23:48 * hackage aura 3.1.4 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-3.1.4 (fosskers)
11:24:02 <EvanR> yes the current leader in startups is the greatest possible productivity 
11:24:03 <ja> i am just saying that in sociology and economy, all proofs are wonky and based on beliefs
11:24:12 <EvanR> it can't improve any further
11:24:23 <EvanR> this is the singularity, enjoy
11:25:05 <hyperisco> you just narrow until what you want to say is true
11:25:38 <ja> dolio: how do you counter an economic argument? i find that it makes me most confortable just saying "i should stop caring about economy, instead focusing on whatever makes me happy"
11:26:09 <EvanR> how about check whether the economic argument even works first
11:26:13 <obihann> with stack am I possible to run a different base version? I need the Data.Hex library however it doesnt' support 4.13 base which of course I have installed
11:26:19 <EvanR> if not, it doesn't need to be countered
11:26:39 <monochrom> Please don't stop caring about economy. Please care a little bit, just enough for your purpose of happiness.
11:27:04 <dolio> Economic argument for what? Like, you should never argue with some kind of JS zealot, because it's a waste of time.
11:27:19 <monochrom> Heh that's a good one.
11:27:49 <ja> ok, but what do i do when stephen diehl argues that haskell needs to change to be adopted as a mainstream INDUSTRY language?
11:27:54 <monochrom> "Can't argue with that"
11:28:15 <berndl> ja: make a pull request?
11:28:22 <dolio> I don't know. Why do you care what he says?
11:28:43 <EvanR> does haskell need to be an INDUSTRY language
11:28:58 <monochrom> Is Diehl's argument really an economic argument?
11:28:59 <younder> Haskell will simply never be a mainstream industry language. It is to complicated. People hate monads etc.
11:29:07 <ja> EvanR: exactly! that's what i was trying to implicitly ask. by adjusting to 'industry', you'll end up being JS
11:29:25 <berndl> Industry sucks. That's what gave us JS to begin with.
11:29:26 <EvanR> we already have plenty of INDUSTRY languages to choose from
11:29:28 <monochrom> Also my opinion is instead I want Haskell to be and stay as a premium language.
11:29:46 <monochrom> Sometimes I use the fast-food analogy (Haskell is not fast food)
11:29:56 <monochrom> (Python is. Javascript is.)
11:29:58 <EvanR> if people wrote code better in existing languages it might not be bad
11:30:32 <obihann> Anybody have a suggestion if stack can run a different base, or do I need to reinstall / find a different library?
11:31:01 <dolio> 'base' is tied to GHC version, last I heard.
11:31:37 <obihann> dolio: thanks... so I need to downgrade ghc then
11:31:49 <monochrom> But anyone who advocates "Haskell needs to change to become Y" should first study the question of Thessus's ship.
11:31:54 <hyperisco> if you want INDUSTRY to be better get out there and educate
11:31:56 <ja> monochrom: yeah, totally agreed. so please continue doing breaking GHC releases :D
11:32:19 <EvanR> Ship of Theseus ftw
11:32:29 <EvanR> it's a nice party trick
11:32:56 <EvanR> also ship analogies rock
11:33:33 <obihann> any idea how I can figure out what ghc version I need to get base 4.12?
11:34:11 <dolio> obihann: 8.6.x
11:35:07 <monochrom> "Haskell needs to change to become Y" is particularly facetious if Y already exists.
11:35:08 <obihann> dolio: so I have ghc 8.0.2 which has base 4.13
11:35:20 <obihann> 8.6.x has a older base?
11:35:28 <monochrom> You want dynamic typing? There are plenty of those languages, why ruin Haskell
11:35:41 <dolio> 8.0.2? That's really old. Do you mean 8.10.2?
11:35:43 <monochrom> You want "reads like English"? There is already COBOL, why ruin Haskell.
11:35:53 <obihann> ghc --version
11:35:54 <obihann> The Glorious Glasgow Haskell Compilation System, version 8.0.2
11:36:20 <dolio> Maybe your base is too old.
11:36:27 <obihann> oohhh wait... stack ghc -- --version tells me I have 8.8.3
11:36:30 <EvanR> what if HASKELL were an acryonym
11:36:40 <monochrom> 8.0.2 is too old, yes
11:36:51 <dolio> Okay, yeah, 8.8.3 has 4.13. 8.6.5 has 4.12.
11:36:55 <monochrom> But great for compatibility with old blogs.
11:37:11 <obihann> stack, and the ghc that is installed directly on my machine, are differnet versions
11:37:20 <ja> obihann: maybe the old version is from your distrubtion (if on linux). so you could remove that, and the stack one would remain
11:37:22 <obihann> so I need to tell stack to downgrade
11:37:33 <ja> just to prevent confusion...
11:37:34 <obihann> ja: 100% that looks to be the case
11:37:52 <monochrom> telling stack to use newer/older ghc version is extremely easy (I heard). Just choose which LTS version.
11:38:12 <obihann> lts-8.6.5 or something like that I assume?
11:38:21 <obihann> ill just google that lol
11:38:54 <monochrom> Oh the mapping between stack LTS version and GHC version is a rote-memorization table
11:39:04 <monochrom> may as well think of random numbers
11:39:14 <monochrom> (Kolmogorov complexity)
11:40:11 <monochrom> (OK I'm exaggerating. I bet someone can come up with an mx+b formula)
11:40:20 <monochrom> (but why bother :) )
11:41:22 <hyperisco> my summer of code project idea is to train a neural net on these version mappings
11:42:09 <maerwald> obihann: ghcup shows you corresponding base versions as well
11:42:39 <sm[m]> obihann: stack —resolver lts-14 ... or so, check stackage.org
11:43:52 <obihann> thjanks!
11:46:21 <ezzieyguywuf> Can anyone see why this is an error? https://gitlab.com/ezzieyguywuf/learnopengl/-/blob/master/src/GLFW_Helpers.hs#L52
11:46:35 <ezzieyguywuf> the error is "Equations for ‘mouseButtonPressed’ have different numbers of arguments"
11:46:50 <ezzieyguywuf> I've tried it with the expanded call signature shown there, too, commented out
11:47:41 <ezzieyguywuf> nvm I found it, it was in the second definition
11:48:39 <monochrom> :)
11:53:19 <ezzieyguywuf> lol
12:16:48 * hackage commander-cli 0.4.0.1 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.4.0.1 (sgschlesinger)
12:21:59 <heath> was f-no-warn-orphans removed? not seeing it in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html
12:22:52 <heath> looks like it
12:23:49 <solonarv> heath: it's -Wno-orphans now
12:24:12 <solonarv> (I found it with ctrl-F "orphan")
12:24:24 <heath> thanks for making me feel terrible ;)
12:24:33 <heath> appreciate the help
12:27:21 <__monty__> I'm having some trouble combining Reader and ReaderT, I feel like it should be easy to use the former in the context of the latter?
12:28:59 <cocreature> :t mapReaderT (pure . runIdentity)
12:29:00 <lambdabot> Applicative n => ReaderT r Identity b -> ReaderT r n b
12:29:04 <cocreature> ^ __monty__ 
12:29:06 <solonarv> :t reader . runReader -- __monty__ 
12:29:07 <lambdabot> MonadReader r m => Reader r a -> m a
12:29:20 <solonarv> mine is more general, both work
12:29:33 <dmwit> __monty__: Usually the way that's done is to make both the `Reader` action and the `ReaderT` action be class-polymorphic in `MonadReader` instead of concrete.
12:31:20 <__monty__> Thank you, I'll try the suggestions in reverse order : )
12:39:32 <frdg> question related to reading documentation: https://pastebin.com/s32UTWs8
12:40:59 <solonarv> frdg: those are haddock markup (formatting)
12:41:04 <berndl> https://haskell-haddock.readthedocs.io/en/latest/markup.html#code-blocks
12:41:15 <kadoban> Looks like it's supposed to denote "code"   @blah@ is explicitly literal code
12:41:24 <kadoban> The blah part is anyway
12:41:42 <frdg> ok thanks. Ill read that link berndl
13:03:16 <__monty__> I'm having trouble understanding MonadReader. It seems like what I want to do is specify `MonadReader Config m =>` but that requires FlexibleContexts, which I'm not familiar with.
13:04:20 <byorgey> __monty__: you're doing it right.  FlexibleContexts is pretty benign.
13:04:27 <muslimm> no God except Allah he is thee one, He is our true savior hes the God of moses and Jesus and mohammed, (Allah) the only God; our refuge; follow islam The true religion of God to be spared from hell. by doing good 3 u be 7lifted from a cup of agony and illness
13:05:25 <byorgey> __monty__: in this case FlexibleContexts is letting you have a multi-param type class (MonadReader) where not all of the arguments are type variables
13:09:32 <gaze__> what are the key differences between conduit and pipes?
13:09:40 <gaze__> like when would you use one over the other?
13:12:03 <__monty__> byorgey: Ok, thanks. And for my `ReaderT Config IO (Doc ann)`, I'd specify both parameters? `Monadreader Config IO => IO (Doc ann)`?
13:12:05 <ezzieyguywuf> how do I change a Double to a Float?
13:12:33 <ezzieyguywuf> gaze__: conduit is for electricity. pipe is for liquids
13:12:49 <gaze__> that's not helpful.
13:13:17 <ezzieyguywuf> how so? you use conduit when you have wire, pipe when you have a fluid (liquid or gas)
13:14:15 <gaze__> oh you're not joking. These are two different haskell libraries for dealing with streaming data.
13:15:41 <__monty__> ezzieyguywuf: realToFrac, though you should probably deal with Doubles that can't fit a Float.
13:15:53 <dsal> gaze__: I used conduit for everything because I never learned pipes.
13:16:25 * MarcelineVQ pokes Sigyn
13:16:35 <berndl> gaze__: Don't forget Streamly
13:17:34 <ezzieyguywuf> __monty__: what do you mean "deal with Doubles that can't fit a Float"?
13:21:16 <dminuoso> __monty__: Roughly, when working with MPTC (or code that uses that extension), you're almost always forced to use FlexibleContexts and/or FlexibleInstances. They are completely safe, one could assume those should have been part of the core language, but I think that would generally raise the bar as their implementation in the type checker is non-trivial.
13:21:44 <phadej> they are not compeletely safe
13:21:50 <phadej> you can introduce overlapping instances
13:21:58 <__monty__> ezzieyguywuf: Because Doubles have a much larger range than Floats, there's many Doubles that simply don't "fit" a Float.
13:22:16 <phadej> don't trust anyone on IRC, read the GHC manual.
13:22:42 <dsal> don't trust phadej.  Trust everyone on irc.
13:22:50 <__monty__> I really should but I'm still stuck on APUE.
13:23:03 <phadej> dsal: I'm part of "anyone on IRC" ;)
13:23:15 <dminuoso> phadej: Where in the GHC manual is it mentioned, that they allow for overlapping instances?
13:24:02 <ezzieyguywuf> __monty__: so you're saying I could lose some data going from Double -> Float?
13:24:05 <dsal> I use extensions I don't understand...  The most seemingly straightforward ones have unexpected consequences.  Often, it'll just do the thing you meant, but there's subtlety.
13:24:39 <dminuoso> As far as I can see, the GHC manual makes no warning at all.
13:25:14 <phadej> dminuoso: in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances is link to https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap
13:25:18 <dsal> I learned yesterday that NegativeLiterals seems to do things a little differently than is obvious in the docs.
13:25:18 <phadej> instance C Int  b where ..
13:25:21 <phadej> These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings.
13:25:23 <__monty__> ezzieyguywuf: Yep, you got it.
13:25:24 <phadej> instance C a Bool where ..
13:25:44 <phadej> it's there. You just have to read it.
13:26:15 <dsal> ezzieyguywuf: There's also Data.Scientific
13:26:18 <phadej> GHC manual *is really good*
13:26:20 <dminuoso> Well it's really buried.
13:26:28 <phadej> but _it's there_.
13:28:19 <phadej> FWIW, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances section (where that text is) is must read if you start to do anything more involved with type classes
13:28:29 <phadej> as it describes how instance selection algorithm works
13:30:28 <phadej> yet, MonadReader is FunDep so there situation is easier. As it's "morally" a single argument type-class
13:30:52 <phadej> and then FlexibleContexts/FlexibleInstances are indeed formality
13:38:42 <dminuoso> phadej: Im not seeing any danger here.
13:39:56 <dminuoso> I'd take some real creativity to use this to create incoherent instances.
13:41:18 <phadej> claiming it's "completely safe" is *wrong*. THere are "buts". Please be cautions when you make universal claims
13:41:37 <phadej> cautious*
13:42:08 <phadej> in this case FunDeps make it safe
13:43:35 <__monty__> Hmm, I'm getting things to typecheck but I don't think I'm doing it right. `MonadReader Config IO => Event -> IO (Doc ann)`, this doesn't seem right because I can't use runReader or something to pass a Config? And `MonadReader Config IO => Event -> ReaderT Config IO (Doc ann)` seems redundant?
13:44:30 <__monty__> How am I misunderstanding dmwit's suggestion to convert *both* the Reader and *ReaderT* actions to use MonadReader?
13:45:16 <phadej> you want either `Event -> ReaderT Config IO (Doc ann)` or `(MonadReader Config m, MonadIO m) => Event -> m (Doc ann)`
13:45:34 <dminuoso> phadej: Fair enough.
13:47:19 * hackage weeder 1.0.9 - Detect dead code  https://hackage.haskell.org/package/weeder-1.0.9 (NeilMitchell)
13:55:00 <jumper149> Can I unlift `MonadUnliftIO m => a -> m b` to run in IO?
13:55:24 <dminuoso> Yes, that's the point of MonadUnliftIO :)
13:55:34 <jumper149> Without giving the argument
13:55:39 <dminuoso> No.
13:55:49 <jumper149> ya... :(
13:56:04 <jumper149> Why is wai designed without mtl in mind :(
13:56:11 <__monty__> phadej: And with the more general option I'd need to run the equivalent of `runReaderT` for whatever `m` ends up being?
13:57:10 <dminuoso> jumper149: what specific problem do you have in mind?
13:57:12 <phadej> yes, but if there are no other constraints then `runReaderT` is sufficient.
13:59:34 <jumper149> Still the same problem from before: https://hackage.haskell.org/package/wai-transformers-0.1.0/docs/Network-WebSockets-Trans.html#v:websocketsOrT
13:59:49 <jumper149> I want to either use this or UnliftIO
14:01:01 <jumper149> the problem with that library was the dependency on monad-control-aligned. So I either rewrite everything I need from Network.{Wai,WebSockets}.Trans or get UnliftIO working.
14:01:55 <jumper149> I still think that using MonadBaseControl IO is better
14:02:12 <jumper149> But I wouldn't mind using UnliftIO for now
14:02:41 <jumper149> The core of the problem is here:
14:02:44 <jumper149> https://hackage.haskell.org/package/wai-transformers-0.1.0/docs/Network-WebSockets-Trans.html#v:websocketsOrT
14:02:59 <jumper149> Wrong Link, now right: https://hackage.haskell.org/package/wai-3.2.1.2/docs/Network-Wai.html#t:Application
14:03:57 <jumper149> I don't know how to do it with `Response -> IO ResponseReceived`
14:05:21 <dminuoso> jumper149: What's the grand goal here?
14:06:30 <jumper149> The goal is to have a transformer like here: https://hackage.haskell.org/package/wai-transformers-0.1.0/docs/Network-Wai-Trans.html#t:ApplicationT
14:06:50 <dminuoso> Are you writing a wai application directly by hand?
14:07:57 <jumper149> I'm writing a websocket with https://hackage.haskell.org/package/wai-websockets-3.0.1.2/docs/Network-Wai-Handler-WebSockets.html
14:08:53 <jumper149> I would like to be able to have a RWST monad around my wai application.
14:09:22 <jumper149> Then I don't need as many impure MVars or TVars and do almost everything purely.
14:10:46 <dsal> I've written websocket servers and clients.  I have a lot of concurrency, though.
14:13:13 <jumper149> The concurrency might be a problem here, yeah
14:21:15 <dminuoso> jumper149: I've come to the conclusion, that IORefs, MVars and TVars are great!
14:21:24 <dminuoso> That's my personal opinion though.
14:21:41 <jumper149> dminuoso: Might as well use an imperative language ;)
14:22:02 <maerwald> might as well use go
14:22:13 <dminuoso> jumper149: There's plenty of Haskellers who believe that Haskell is the finest imperative language. :)
14:22:24 <maerwald> has nicer concurrency
14:22:35 <mud> go's type system is crap though
14:22:40 <maerwald> yes
14:23:12 <Uniaika> Go has a type system?
14:23:54 <mud> It occasionally pretends to.
14:24:03 <maerwald> Uniaika: learn it... it takes 3 days
14:24:17 <maerwald> max
14:24:21 <dminuoso> jumper149: Anyhow, lets get back to your original problem.
14:24:41 <berndl> FYI: Wadler helped develop Featherweight Go with the goal of adding generics to Go.
14:25:00 <berndl> He gave a talk about this not too long ago.
14:25:01 <Uniaika> maerwald: oh I've dabbled with Go in the past, I'm all too aware of its shortcomings :P
14:25:12 <Uniaika> berndl: yes, the Chalmers seminars on FP!
14:27:01 <jumper149> My problem will be solved, if I can use this library: https://hackage.haskell.org/package/wai-transformers . I just don't know how to get the `MonadBaseControl IO` instance for my stack.
14:27:19 <frdg> I could use some help understanding the difference between `skipSome` and `skipMany` in regards to parsing libraries. `skipMany` applies the parser zero or more times while `skipSome` applies the parser one or more times but I'm struggling to understand the difference in practice.
14:27:56 <jumper149> I will use MVars for now and tackle this problem later on. dminuoso: thank you for you help though 
14:28:32 <dminuoso> jumper149: Thing is, your code gets quite clean and simple if you avoid transformer stacks that span your applications. And it's much easier to interface with libraries.
14:28:50 <maerwald> frdg: skipMany may not consume any input
14:29:05 <dminuoso> They are not essential for solving problems, they are just a pure way to get effects without IO. :)
14:29:14 <dminuoso> But you can just stick to IO and do it the old fashioned way.
14:30:20 <jumper149> dminuoso: To be fair, I do have to use a whole lot of liftIO, when using the whole stack. 
14:30:35 <frdg> maerwald: ohhh ok the code im working with makes much more sense now. Thanks
14:30:35 <monochrom> If my input string is "abc", skipMany space succeeds, skipSome space fails. If you use skipSome space, it means you require mandatory at least one space.
14:30:46 <dminuoso> jumper149: Indeed, and then some more uses of MonadBaseControl when IO appears in negative position.
14:30:53 <maerwald> dminuoso: ++, but at the expense of people saying you are a junior
14:31:00 <dminuoso> jumper149: And even more pain if you want to push that transformer stack into existing libraries.
14:31:40 <frdg> monochrom: makes perfect sense thanks
14:32:25 <jumper149> dminuoso: From a practical pov you are absolutely right. I still think it would be cool though. All the libraries just have to be in mtl style and then it would work.
14:33:21 <jumper149> I'm probably going overboard with my transformer stack though ^^
14:33:23 <maerwald> jumper149: mind that mtl does not specify effect order
14:33:29 <dminuoso> jumper149: The real solution would be if everything was using free monads.
14:33:41 <dminuoso> :P
14:34:02 <dminuoso> Or well, freer monads.
14:34:25 <maerwald> supermonads
14:34:28 <maerwald> ...
14:34:49 <jumper149> transformertransformer?
14:35:30 <maerwald> jumper149: so... I'm not convinced that mtl composes well
14:37:32 <berndl> I believe free(r) monads have the same issues with "control" operations as monad transformers.
14:50:01 <monochrom> free monads simply move the question of interference resolution to the interpreter you write.
14:50:32 <monochrom> The upside is you can now handcode strange resolutions that other people have never thought up.
14:51:00 <ezzieyguywuf> how can I round a float to 1 decimal?
14:51:09 <monochrom> The downside is why would you handcode the same resolution that, e.g., StateT Either has already done for you.
14:51:32 <monochrom> (if you are going for the same resolution as StateT Either)
14:52:32 <monochrom> ezzieyguywuf: I think perhaps this strategy: multiply by 10, round to integer, divide by 10.
14:53:08 <ezzieyguywuf> monochrom: that'll probably work fine
14:53:14 <ezzieyguywuf> I just need it for debug
14:54:09 <monochrom> If you are going for string, that's even better. Consider Numeric.showFFloat
14:54:56 <ezzieyguywuf> monochrom: I'll take a look thanks
14:56:54 <ezzieyguywuf> that's perfect
15:01:03 * monochrom is encyclopedic because he started at a time when the full list of standard modules fit on half a page. :)
15:04:40 <monochrom> If you start with a short list, say half a page, you feel like memorizing that whole list. Over the next 10 years, if the list grows to 4 pages but gradually, you feel like memorizing each bite-size addition. After the 10 years, you have the whole 4 page bloody list memorized, no sweat.
15:04:56 <monochrom> But if you start with that final 4-page bloody list, you just feel like giving up.
15:06:11 <monochrom> A little bit of psychologic explanation why some of us old-geezers totally out-perform google and hoogle. :)
15:25:18 * hackage smallcheck 1.1.7 - A property-based testing library  https://hackage.haskell.org/package/smallcheck-1.1.7 (Bodigrim)
15:40:49 * hackage calamity 0.1.14.4 - A library for writing discord bots  https://hackage.haskell.org/package/calamity-0.1.14.4 (nitros12)
15:57:15 <Cjen1> Any advice on data storage? I'm trying to store some tagless final values in a human editable format and am currently using `readMaybe` etc however the error messages are um very useful...
16:01:38 <freeman42x[m]> I enabled relude using https://github.com/kowainik/relude#mixins but now I am missing the following functions: foldl, userError, ioError What is the best way to fix this issue? I was just thinking of somehow importing them from Prelude but I assume they have been removed for a good reason
16:07:22 <freeman42x[m]> I replaced foldl with foldl' , not sure about the other 2 functions
16:08:37 <jonathan3> hello, does GHCi have a keybinding for jumping to the first character of a line? It doesn't do anything when I press "home"
16:09:36 <heatsink> Ctrl+A
16:09:46 <Cale> jonathan3: hmm, Home works for me
16:10:08 <Cale> What terminal are you running it in?
16:11:42 <jonathan3> default ubuntu terminal (which supports Home), but also in a docker container ... maybe that's why
16:14:51 <ezzieyguywuf> I have a `a -> b -> b` and I'd like to call it such that the result `b` is used to call the function again, with the same a
16:15:05 <ezzieyguywuf> I'd like to keep doing this, preferably step-wise, to see what happens to b over 'time'
16:16:03 <ja> jonathan3: you can use the emacs keybindings in all libreadline based repls
16:16:23 <ja> jonathan3: and you can configure it to use vi bindings too, if you want
16:17:52 <ezzieyguywuf> hm, I think iterate.
16:21:07 <dolio> ghci doesn't actually use readline, it uses haskeline, but it behaves similarly to readline (though the configuration is in a different place).
16:26:24 <jonathan3> ja and dolio where can I read about how to do that? I googled around, came across haskeline, but I when I skimmed it I understood it's some rewrite of GHCi, and I didn't want to introduce subtle bugs into my haskell life just for a nice keybinding. But should I give it a second look?
16:34:36 <dolio> https://github.com/judah/haskeline/wiki/UserPreferences
16:35:36 <monochrom> ezzieyguywuf: yes iterate, but it makes an infinite list. Perhaps combine with take.  take 10 (iterate f x).
16:36:14 <ja> jonathan3: actually, ghci uses haskeline now. i saw that by running ldd $HOME/.ghcup/ghc/8.8.3/lib/ghc-8.8.3/bin/ghc
16:36:36 <ja> jonathan3: only ancient releases use readline. so sorry for the inconvenience
16:37:03 <monochrom> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/ghci.html#the-haskeline-file
16:37:04 <ja> ah, i see dolio already said that
16:39:08 <ezzieyguywuf> monochrom: yea that's what I'm working on
16:42:03 <jonathan3> perfect, thanks everyone for the info!
16:46:03 <jonathan3> got vim keybindings working, feels great :)
16:46:17 <infinity0> so, my program has a small leak in it but when i switch on --enable-profiling there is a second even bigger leak :(
16:46:30 <infinity0> is that really supposde to happen?
16:48:38 <heatsink> Hard to say.  It's possible for optimizations to remove space leaks, and profiling affects optimizations
16:50:18 <monochrom> I use Home so it's both emacs binding and vim binding.
16:50:19 * hackage prettyprinter-graphviz 1.0.0.0 - A prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-1.0.0.0 (GeorgeThomas)
16:53:09 <infinity0> heatsink: really, switching on profiling changes optimisation settings? can i read about that somewhere
16:56:37 <ja> monochrom: home isn't necessarily working in all variants of vi, i think. i remember using a bare-bones vi on debian or something, and home just emitted the control characters. the real vi way is to use 0, i believe
16:57:34 <monochrom> I know.
16:57:57 <monochrom> I was using hjkl before many of you were born.
16:58:49 <ja> ah because keyboard didn't have arrow keys back then?
16:59:23 <monochrom> On some terminals back then (physical ones), or over the modem, not even arrow keys were supported, or maybe the sysadmin didn't get around to configure it.
17:00:03 <mud> They are legit better though. No need to move hands.
17:00:29 <monochrom> They had all the arrow keys and pgup pgdn we have today, probably even more. Doesn't mean vi honoured them.
17:00:31 <dolio> On the keyboard Vi was originally developed on, the arrow keys were on hjkl.
17:01:21 <wavemode_> I got used to pn/bf in emacs. but hjkl never really 'stuck' for me in vim. I always used the arrow keys instead
17:01:32 <monochrom> Recall that back then there was much stronger tie-in between hardware and software from the same vendor. A keyboard had a key because the vendor wrote proprietory software that used it.
17:02:19 <dolio> There are better ways to move around a lot of the time.
17:02:39 <ja> dolio: what do you mean? like paredit?
17:02:52 <heatsink> infinity0: It doesn't change optimization settings.  It inserts profiling-related code, and the inserted code affects optimization decisions
17:03:02 <mud> w, b, (), all those
17:03:15 <dolio> No, like 0 (you mentioned) is better than a bunch of h. And if you know you're going to insert, then I is better than 0.
17:03:30 <monochrom> no-need-to-move-hands is good, but I was disappointed that they didn't go for ijkl instead, equiv to wasd today.  On this front, game developers got it right.
17:04:39 <monochrom> I decide to call ijkl "improved vi binding", short form imvi binding. >:)
17:05:35 <dolio> That's an example of optimizing the wrong thing, though. :)
17:05:49 * hackage prettyprinter-graphviz 1.0.0.1 - A prettyprinter backend for graphviz  https://hackage.haskell.org/package/prettyprinter-graphviz-1.0.0.1 (GeorgeThomas)
17:05:55 <infinity0> heatsink: i see ok, that makes sense. though i never ran into that before, the current project i'm working on is a bit different than the previous projects i used profiling on
17:06:01 <infinity0> kinda sucks the usual tools don't help me here :(
17:06:15 <infinity0> now all i have is -hT, can't use anything else to figure out the problem :(
17:06:40 <crestfallen> jonathan3, hi (n)vim I configured ' let g:haskell_indent_disable = 1 ' because I get whitespace errors. any clue why? (using pathogen) 
17:06:50 <heatsink> I would recommend to debug the new space leak
17:07:00 <wavemode_> ijkl to move and h to insert. I would have loved that
17:07:51 <infinity0> heatsink: you mean the one that happens only when profiling is switched on? i spent today doing that, not realising it was a different leak (didn't notice the inflated numbers on my graph until a few minutes ago)
17:08:03 * yushyin has hardcoded arrow keys on an extra layer at hjkl, all thanks to qmk firmware ;)
17:08:11 <infinity0> didn't figure it out either
17:08:52 <heatsink> Have you used heap profiling by retainers?
17:08:57 <infinity0> removing -fprof-auto reduces it a bit
17:09:06 <infinity0> yes, i tried -hr, didn't find anything obvious
17:09:28 <infinity0> tried sprinkling $! everywhere, coding my own strict versions of lens operators, etc
17:10:00 <infinity0> one stupid thing is i can trigger the leak to go away by feeding it specific types of input
17:10:01 <heatsink> Using $! is a small-scale solution because it forces evaluation of a single object
17:10:53 <heatsink> The NFData class is useful to get control over laziness in a big program
17:11:58 <c_wraith> NFData usually results in asymptotic performance hits and really should only be used for debugging.
17:12:00 <infinity0> i'm pretty sure the unevaluated stuff is containers i.e. Map/Sequence, it's not an instance of NFData
17:14:33 <wavemode_> are you using the strict variants?
17:14:52 <infinity0> yes, Map.Strict, State.Strict
17:15:00 <infinity0> rewrote Lens.At to use Map.Strict (it uses Map.Lazy sadly)
17:18:47 <infinity0> anyway, i'll have another crack at it tomorrow, switching off -fprof-auto gives some different information i didn't have earlier today
17:20:25 <infinity0> heatsink: are you suggesting that the larger leak is simply a result of the smaller leak? i.e. if i fix one the other should go away?
17:21:01 <heatsink> I think the larger leak might be a real leak that was hidden by optimization
17:23:42 <heatsink> Since there are lots of heuristics behind optimizations, it's a bit risky to rely on optimizations to remove space leaks
17:24:21 <infinity0> well if i switch off both -O and profiling, i only get the smaller leak
17:27:40 <crestfallen> hi if I have this   data State = Int; newtype ST a :: S (State -> (State,a))
17:27:50 <crestfallen> I cannot check the type of State
17:28:08 <c_wraith> you haven't defined any value named State
17:28:39 <c_wraith> you've defined a value named Int, and a value named S
17:28:59 <c_wraith> (You probably didn't want to define a value named Int)
17:29:40 <crestfallen> c_wraith, thanks, not a value named Int? It's a book example
17:30:22 <c_wraith> If you expected a value named State to exist, the first declaration probably should have been `data State = State Int`
17:31:04 <crestfallen> thanks let me check I thought I had that right c_wraith 
17:31:23 <d34df00d> So there's this MonadRandom thing: http://hackage.haskell.org/package/MonadRandom-0.5.1.2/docs/Control-Monad-Random-Class.html#t:MonadRandom
17:31:40 <d34df00d> Suppose I have two actions, val1, val2 :: MonadRandom m => m SomeTy
17:32:02 <crestfallen> c_wraith, its here if you have time to look: https://github.com/varreli/haskell/blob/master/monads/state/state.hs
17:32:08 <d34df00d> How do I write an action that interleaves val1 and val2?
17:32:30 <d34df00d> So I basically want `act` such that `s1 <- act ; s2 <- act` is analogous to `s1 <- val1 ; s2 <- val2`
17:32:58 <c_wraith> crestfallen: that uses type instead of data
17:33:31 <crestfallen> oh sorry c_wraith that's correct in any case?
17:33:43 <crestfallen> type is
17:34:13 <c_wraith> then there's no value being defined with the name State, so asking ghci for the type of State is going to fail
17:35:03 <crestfallen> Ok data State = State Int  is preferred? trying it now..
17:36:42 <c_wraith> d34dfood: that isn't something you can do with only a MonadRandom constraint. you could do something like it if you added a MonadIO constraint and wrote a lot of code, but it really would be unpleasant 
17:38:25 <crestfallen> c*wraith thanks kindly sticking with type  .. let sleeping dogs lie!"
17:42:11 <d34df00d> c_wraith: that makes sense, I was looking through MonadRandom methods and found nothing that could help.
17:42:25 <d34df00d> c_wraith: but I'm curious if that's a well-known problem and whether there's an app^W abstraction for that.
17:43:03 <c_wraith> you need to add in either mutation or something that emulates it to get that effect.
18:50:15 <Nolrai> So I think I am running into a bug in IntMap.
18:51:34 <Nolrai> The docs say that "union" is left biased, i.e., if both 'l' and 'r' have values at key k, then 'l `union` r' should have the value at k in l.
18:52:40 <Nolrai> But instead, sometimes (with very large keys, I think), the result is an invalid IntMap that shows _both_ key value pairs.  
18:53:57 <wavemode> can you pastebin an example
18:54:46 <Nolrai> Yes, going to take me a minute.
18:55:27 <Axman6> D:
19:03:55 <Nolrai> Okay..uh, I hope the fact that I don't seem to be able to condense my test case to just the line with 'union' is giving me hope this is my bug, and not the libraray's.
19:04:16 <monochrom> It is very easy to test independently of your code.
19:04:49 <dolio> I'm not really clear how you'd get the behavior you describe with IntMap.
19:04:56 <dolio> Because it isn't a balanced tree.
19:07:02 <Nolrai> While I am some how producing this https://pastebin.com/5SgRssKW
19:07:04 <monochrom> > IM.union (IM.singleton 10 "left") (IM.singleton 10 "right")
19:07:06 <lambdabot>  fromList [(10,"left")]
19:08:24 <monochrom> > 1700431202978776163 == 1700431202978776163
19:08:26 <lambdabot>  True
19:08:31 <monochrom> ha, interesting
19:09:04 <monochrom> > 1700431202978776163 :: Int
19:09:05 <lambdabot>  1700431202978776163
19:09:39 <monochrom> It is a bug to have non-distinct keys in the first place, yeah.
19:10:19 <Nolrai> And I thought this was produced from the union, but well..programing is hard.
19:10:52 <solonarv> if you end up with duplicate keys *without* using unsafe functions that's certainly a bug
19:11:16 <monochrom> might not be union per se, but no matter which IntMap functions you call, simply shouldn't get non-distinct keys. I mean unless fromAscList or something that trusts you too much.
19:11:33 <Nolrai> I am indeed not using the fromAscList.
19:12:02 <solonarv> can you also paste the code that produced this? or rather, the input maps
19:25:04 <dolio> I guess IntMap stores the whole key at the leaves, so that's how. I was thinking it would reconstruct it based on the path, like other tries.
19:30:28 <dolio> Maybe you should show the underlying tree with the debug modules.
19:33:37 <ezzieyguywuf> so, I thought I could multiply two quaternion rotations in order to perform the rotation in one step. http://dpaste.com/23Q1X5F
19:34:06 <ezzieyguywuf> in the code I linked, you can see that I can succesfully perform this operation using _two_ rotations, but I was unable to do it with a single rotation by multipling the quaternions first
19:34:14 <ezzieyguywuf> am I doing something wrong here?
19:37:00 <byorgey> ezzieyguywuf: maybe try (aroundX * aroundY) ?  quaternion multiplication is not commutative.
19:37:13 <dolio> Yeah, is rotation a right or left action?
19:37:19 * hackage pontarius-xmpp-extras 0.1.0.4 - XEPs implementation on top of pontarius-xmpp  https://hackage.haskell.org/package/pontarius-xmpp-extras-0.1.0.4 (SergeyAlirzaev)
19:37:32 <Nolrai> So when I copy the results of showing the maps into my code, so I can test _just that line_ the bug goes away. The only thing I can think of is somehow the show => past into code step is normilizing the inputs?
19:37:44 <ezzieyguywuf> byorgey: yea that works
19:38:05 <ezzieyguywuf> I had tried that before, but didn't believe the answer b/c I assumed it was rotating around X first, which is nothing since my point is on the X-axis
19:38:08 <solonarv> ah that was going to be my suggestion too :)
19:38:27 <ezzieyguywuf> but I'll try it again with different transformations - I think Data.Linear is row-wise or something, which might suggest why that order is needed.
19:38:46 <solonarv> rotations don't commute in general, and so it should be no surprise that quaternion multiplication doesn't either
20:05:19 * hackage postgres-websockets 0.7.0.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.7.0.0 (diogob)
20:57:12 <ezzieyguywuf> I saw ghcup do this really cool thing where it did _not_ clear out the contents of my terminal, but rather just took over the bottom few lines, and kept updating it and scrolling it etc. and when it was done it looked like I had never executed it at all
20:57:16 <ezzieyguywuf> any idea how they did that?
20:58:27 <wavemode> ANSI escape sequences can do that
21:00:18 <ezzieyguywuf> yea
21:00:27 <ezzieyguywuf> I was thinking maybe it was a library they used
21:01:12 <wavemode> mmm maybe look at their dependencies. a variety of libraries provide ansi terminal control. probably the most notable is brick
21:27:54 <GreyFaceNoSpace> hello. how to make quick check show me which parameters caused errors?
21:28:11 <Axman6> what do you mean?
21:29:34 <GreyFaceNoSpace> i am using quick check to test a property called fprop n k
21:29:45 <GreyFaceNoSpace> i want to know which values for n and k are causing the error
21:30:47 <GreyFaceNoSpace> nvm I am stupid. didn't notice that it gave out the values for n and k because my terminal window wasn't showing everything
21:30:50 <GreyFaceNoSpace> sorry
21:31:23 <wavemode> @check \x -> x == x * 2.1 / 2.1
21:31:25 <lambdabot>  *** Failed! Falsifiable (after 12 tests and 1 shrink):
21:31:26 <lambdabot>  3.9144099123948277
21:32:52 <Axman6> @check \x -> x = x / 2 * 2
21:32:52 <lambdabot>  <unknown>.hs:1:9:Parse error: =
21:32:56 <Axman6> @check \x -> x == x / 2 * 2
21:32:58 <lambdabot>  +++ OK, passed 100 tests.
21:50:18 <dmwit> > all (uncurry (==)) . ap zip tail $ iterate (/2) 1
21:50:20 <lambdabot>  False
21:50:34 <dmwit> The dangers of trusting random testing.
21:52:20 <Axman6> > dropWhile (uncurry (==)) . ap zip tail $ iterate (/2) 1
21:52:23 <lambdabot>  [(1.0,0.5),(0.5,0.25),(0.25,0.125),(0.125,6.25e-2),(6.25e-2,3.125e-2),(3.125...
21:52:49 <dmwit> whoops, forgot to double!
21:52:50 <dmwit> still
21:52:54 <Axman6> =)
21:53:08 <dmwit> > all (\(x,y) -> x == y*2) . ap zip tail $ iterate (/2) 1
21:53:08 <Axman6> > dropWhile (uncurry (==)) . ap zip tail $ iterate ((*2).(/2)) 1
21:53:09 <lambdabot>  False
21:53:14 <lambdabot>  mueval-core: Time limit exceeded
21:53:27 <dmwit> > dropWhile (\(x,y) -> x == y*2) . ap zip tail $ iterate (/2) 1
21:53:29 <lambdabot>  [(5.0e-324,0.0),(0.0,0.0),(0.0,0.0),(0.0,0.0),(0.0,0.0),(0.0,0.0),(0.0,0.0),...
22:06:49 * hackage rio 0.1.17.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.17.0 (MichaelSnoyman)
23:49:48 * hackage apecs 0.9.2 - Fast Entity-Component-System library for game programming  https://hackage.haskell.org/package/apecs-0.9.2 (jonascarpay)
