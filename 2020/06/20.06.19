00:26:49 * hackage enummaps 0.6.2.1.2 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1.2 (leif)
00:28:49 * hackage enummaps 0.6.2.1.3 - Enum wrappers for IntMap and IntSet  https://hackage.haskell.org/package/enummaps-0.6.2.1.3 (leif)
00:37:23 <ph88> why do a lot of functions like  take   expect and Int  and not   Integral a => a   ?
00:38:40 <rsoeldner> Morning, when using the `reflex-platform`, I need to provide the system library `xmlsec`, would I just list it in the `override` section; this currently does not work, but using the same application with another shell and `buildInputs = [xmlsec];` works.
00:40:21 <ph88> rsoeldner, pretty vague question, maybe you can trace to see where it's loading the library from
00:40:28 <ClaudiusMaximus> :t genericTake
00:40:29 <lambdabot> Integral i => i -> [a] -> [a]
00:41:19 <ph88> ClaudiusMaximus, nice function .. my original question still stands though :P
00:41:47 <ClaudiusMaximus> true
00:42:19 <dminuoso> ph88: Various reasons. Performance, historical reasons, simplicity of API (for a beginner this is important)
00:42:25 <dminuoso> ph88: There's no single answer.
00:42:35 <ph88> oki
00:42:40 <[exa]> ph88: it prevents lot of ambiguity, and Integer defaults are slower and unnecessarily generic when compared to Ints
00:45:39 <Rembane> And some things might go boom in interesting ways if i > MAX_INT
00:54:02 <ph88> [exa], Integer is not the only instance of Integral ..
00:54:53 <dminuoso> ph88: Polymorphic bindings impose additional performance constraints.
00:54:54 <lortabac> Rembane: if you have lists of more than 9223372036854775807 elements, maybe you should consider using a database
00:55:17 <ph88> dminuoso, they should be monomorphized no ?
00:55:21 <dminuoso> ph88: A polymorphic thing is, under the hood, implemented as a function taking a dictionary - that makes it harder to inline when not specialized.
00:56:23 <Rembane> lortabac: That sounds reasonable. Also, that's many elements.
00:56:25 <ph88> does it specialize though ?
00:56:45 <dminuoso> ph88: It depends on the module. Recall, that base is essentially a separate package.
00:57:19 <ph88> i thought it depended on the compiler doing cross module optimization and not on the package perce
00:58:12 <dminuoso> ph88: The compiler can not magically look into a package, it can only see what its presented with from iface files for example.
00:58:17 <[exa]> ph88: it's the default one
00:58:46 <ph88> not familiar with iface files
00:59:26 <dminuoso> https://downloads.haskell.org/~ghc/8.4.1/docs/html/users_guide/separate_compilation.html#output-files
00:59:45 <dminuoso> Also refer to: https://wiki.haskell.org/Inlining_and_Specialisation
01:00:25 <lortabac> ph88: I suggest you to watch this recent talk by Alexis King https://youtu.be/0jI-AlWEwYI
01:00:40 <dminuoso> The only way you could specialize a function from another package, is if you have its definition available.
01:01:48 <ph88> https://wiki.haskell.org/Inlining_and_Specialisation#When_does_specialisation_occur.3F found this too
01:02:35 <dminuoso> And of course, once you go down that road you're blowing up compilation times
01:03:03 <ph88> does inlinable pragma's on every function equal -fspecialize-aggresively ?
01:03:33 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fspecialise-aggressively
01:04:13 <c_wraith> that sounds likely to kill performance as often as it helps
01:04:45 <ph88> thanks for the video lortabac 
01:05:41 <dminuoso> ph88: Ultimately I think locking APIs to Int is frequently a safe choice. You get 64 bit integers on GHC/usual architectures, which is enough for most choices.
01:06:03 <dminuoso> Now arguably, from a standard perspective there's a different story, since Int only guarantees 29 bits, but oh well.
01:10:23 <TMA> that's only 536870911. how can anyone's list fit?
01:13:26 <hololeap> Int seems like the best choice for most functions that repeat some operation a certain number of times. you could use Char64 or something, but i don't see how that would be an improvement, just a convenience for not having to do fromIntegral
01:56:16 <kuribas> is it not possible to install packages globally with new-install?
01:56:18 <kuribas> just to try out stuff?
01:56:33 <kuribas> cabal new-install streaming => goals I've had most trouble fulfilling: binary, containers, ghc
01:58:02 <kuribas> or do I need to make a v1 sandbox?
01:58:03 <merijn> kuribas: Is it possible? Yes. Is the workflow well documented and convenient right now? Not really.
01:58:24 <kuribas> merijn: then what do you recommend for quick trying out things?
01:58:33 <maerwald> repl
01:58:43 <kuribas> maerwald: funny
01:58:47 <maerwald> ?
01:59:10 <merijn> kuribas: tbh, I almost always try things in the context of projects, so I just add them as dependency to whatever project I'm working on
01:59:14 <maerwald> cabal new-repl --build-depends streamly
01:59:33 <kuribas> maerwald: to use the repl I need the package installed globally
01:59:38 <maerwald> no
01:59:40 <merijn> kuribas: You can install into a specific environment file and have ghci use that, but I can never remember the way to do it
01:59:48 <maerwald> see my command
02:00:35 <kuribas> maerwald: right, that actually works
02:01:10 <kuribas> now I need to figure out how to do that in emacs...
02:01:57 <kuribas> maerwald: thanks
02:02:04 <maerwald> boot a linux vm in your emacs :p
02:02:08 <merijn> kuribas: *all* packages are installed globally with the v2-commands. The problem is "selectively bringing a specific one in scope" which can be done, among other things, via a .ghc.environment file, but the workflow for conveniently doing that is underdocumented
02:04:29 <maerwald> there's also https://github.com/phadej/cabal-extras/tree/master/cabal-env
02:04:39 <maerwald> but never tried it
02:05:00 <kuribas> well, cabal new-repl --build-depends works nicely
02:05:11 <kuribas> only I need to tell emacs to use this command
02:05:18 <kuribas> but for now I can use the command line
02:05:56 <maerwald> it also works in a project when you're too lazy to add the deps to the cabal file
02:05:59 <kuribas> neat, Streaming has span and groupBy function, which the other streaming library seem to miss
02:06:29 <kuribas> maerwald: not just too lazy, also to avoid taking in dependencies your users don't need
02:35:48 * hackage indigo 0.1.0.0 - Convenient imperative eDSL over Lorentz.  https://hackage.haskell.org/package/indigo-0.1.0.0 (gromak)
03:09:32 <basic> why can i only create functor instances on types with type parameter?
03:11:42 <Ariakenom> % fmap (+1) (1,2)
03:11:43 <yahb> Ariakenom: (1,3)
03:12:53 <Ariakenom> % fmap :: (b -> c) -> Either a b -> Either a c
03:12:53 <yahb> Ariakenom: ; <interactive>:139:1: error:; * No instance for (Show ((b0 -> c0) -> Either a0 b0 -> Either a0 c0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
03:13:05 <Ariakenom> % :t fmap :: (b -> c) -> Either a b -> Either a c
03:13:06 <yahb> Ariakenom: (b -> c) -> Either a b -> Either a c
03:13:58 <lortabac> @hackage mono-traversable
03:13:58 <lambdabot> https://hackage.haskell.org/package/mono-traversable
03:13:58 <Ariakenom> basic, you can define it on types with more parameters but only on the last one as you see
03:14:05 <[exa]> basic: so that `fmap` can change that type as it wants
03:14:11 <[exa]> % fmap show (1,2)
03:14:11 <yahb> [exa]: (1,"2")
03:14:57 <basic> hm, i don't get it :/
03:15:03 <lortabac> basic: maybe you are looking for mono-traversable
03:15:22 <basic> i am not looking for something, i created data Something = Val Int
03:15:25 <lortabac> I am not a big fan of that package, but it is an example of an alternative functor definition
03:15:36 <basic> and wanted to implement functor on it, (which only works, if i paramatize Int)
03:15:42 <basic> and i wanted to know why
03:15:48 <[exa]> basic: roughly translated, functor must be completely oblivious to the type it actually "contains"
03:16:16 <[exa]> basic: in your case, how would you implement `fmap show (Val 5)` ?
03:16:50 <basic> yeah that would mean Val [Char], which doesn't exist
03:16:53 <basic> i think that makes sense
03:16:59 <[exa]> yeah
03:17:10 <Ariakenom> basic: good clarification. I think a good way to understand would be to look at something that uses (Functor f) without knowing what f is 
03:17:24 <Ariakenom> % :t fmap show 
03:17:25 <yahb> Ariakenom: (Functor f, Show a) => f a -> f String
03:17:25 <basic> but i could map it to a constant for example.. which "law" would i break?
03:17:26 <[exa]> basic: in particular, Functor as a constrain is a bit stronger than "just being a container"
03:17:57 <Ariakenom> so fmap show should work on all functors. how would that work for Something?
03:18:19 <Ariakenom> i mean how would (fmap show) work on Something
03:18:37 <[exa]> basic: a constructive way to work that around (with benefits of unparametrized Something) would be to `data GenericSomething a = Val a ; type Something = GenericSomething Int`
03:18:45 <basic> Ariakenom: that explicit wouldn't work, but i could "map (const 1) (Val 1)"
03:18:59 <basic> i don't get what "law" it breaks
03:19:11 <Ariakenom> I see I just repeated what [exa] said :D
03:19:27 <[exa]> hm, functor laws...
03:19:47 <basic> [exa] which one exactly?
03:19:58 <basic> isn't it: size stays the same, order doesn't get changed? kinda?
03:20:34 <Ariakenom> I dont think we need laws. You should be able to apply  (fmap show) to all functors. and you cant apply it to (Val 1)
03:20:35 <[exa]> basic: https://wiki.haskell.org/Typeclassopedia#Laws -- nonparametrized functor wouldn't hold for the second law if, say, g=fromString and h=toString
03:20:56 <no-n> :t fmap
03:20:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:21:25 <no-n> the type there says that a's can be replaced by b's
03:21:48 <[exa]> no-n: we wanted something that's explicitly marked as "law" :]
03:21:56 <no-n> since there is only Var Int and no Var Char, it won't work
03:22:10 <basic> ah, you cannot chain them, in every case, i guess
03:23:03 <basic> okay, next stop: applicative
03:23:37 <[exa]> anyway what no-n suggests is basically a formal version of what I said, you can imagine the "forall a b" in the type of fmap to get a logical condition that the functor needs to satisfy
03:23:38 <basic> whats the quickest way to []-code?
03:23:48 <[exa]> []-code?
03:23:55 <basic> the list monads code for the applicative
03:24:24 <dminuoso> (<*>) = ap
03:24:26 <dminuoso> pure = return
03:24:32 <basic> dminuoso: o/
03:24:48 <basic> dminuoso: well what is ap?
03:24:51 <dminuoso> % :t ap
03:24:51 <yahb> dminuoso: Monad m => m (a -> b) -> m a -> m b
03:25:00 <[exa]> basic: the instances are also on typeclassopaedia iirc
03:25:14 <basic> yeah i don't know what to search i tried "applicative []"
03:25:16 <basic> in hoogle
03:25:18 <dminuoso> ap f a = do r <- a; pure (f r)
03:25:22 <dminuoso> Errr hold on
03:25:33 <dminuoso> ap f x = do f' <- f; pure (f' x)
03:25:35 <dminuoso> Sorry :)
03:25:39 <basic> wow, that's simple
03:25:46 <basic> ghci should have a source browser like rubey :/
03:27:02 <dminuoso> ah im bad at this. :(
03:27:07 <dminuoso> ap f x = do f' <- f; x' <- x; pure (f' x')
03:27:16 <no-n> pretty sure lambdabot had one at one stage
03:27:28 <basic> yeah kinda just.. cartesian product
03:27:41 <basic> assuming the container is something containing multiple things
03:28:56 <basic> hm, what do i do if "x" isn't a monad (yet) ?
03:29:03 <basic> wait, that doesn't matter.
03:29:26 <jollygood2> cartesian product isn't required by monad laws. there's another possible implementation of list monad
03:30:50 <koz_> jollygood2: Are you referring to ZipList?
03:30:54 <koz_> Because that's no Monad.
03:32:07 <jollygood2> yeah, I meant to say Applicative not Monad
03:32:39 <basic> dminuoso:  in the f' <- f step it says that my type isn't a monad
03:33:02 <basic> which is confusing to me, i mean i am not using (>>=) of my type.. 
03:33:18 <basic> No instance for (Monad Expr) arising from a do statement • In a stmt of a 'do' block: f <- fa In the expression: do { f <- fa; s <- fs; pure (f s) } In an equation for ‘<*>’: (<*>) fa fs =
03:33:22 <basic> oopsie.
03:36:10 <boxscape> basic here's a web app for browsing haskell packages at least https://haskell-code-explorer.mfix.io/package/base-4.12.0.0
03:38:12 <zincy__> If you use lenses are you better to use them everywhere or is mixing this up with other things like record dot syntax on an ad hoc basis advisable?  
03:40:41 <boxscape> basic do notation is desugared into applications of >>= among other things, see for example https://en.wikibooks.org/wiki/Haskell/do_notation
03:40:44 <Ariakenom> basic: (do f' <- f; pure f')   =   (f >>= (\f' -> pure f'))
03:41:30 <basic> { f <- ff; s <- fv; pure (f s) }
03:41:35 <basic> this is my applicative <*>
03:41:44 <basic> ff is the first parameter, fv the second
03:43:00 <boxscape> that's desugared into ff >>= \f -> fv >>= \s -> pure (f s)
03:45:46 <Ariakenom> with extra parenthesis: ff >>= (\f -> (fv >>= (\s -> (pure (f s)))))
03:48:07 <basic> boxscape: yes exactly, and in my mind ff is a [X] and fv [Y]
03:48:20 <basic> (>>=) of my type shouldn't be used there
03:48:23 <basic> why is the compiler hating on me
03:48:42 <boxscape> basic what is the type of the function you're writing?
03:48:50 <basic> it's supposed to be <*>
03:48:55 <basic> :t (<*>)
03:48:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:49:10 <boxscape> <*> in general or <*> for your specific type?
03:49:16 <basic> <*> for my type
03:49:35 <boxscape> so it's like Expr (a -> b) -> Expr a -> Expr b?
03:49:45 <basic> ah, no, in general
03:49:56 <basic> oh.. wait, i don't know
03:49:58 <basic> hm..
03:50:27 <boxscape> it's hard to say where the error you're getting comes from without knowing the context in which that code appears
03:50:51 <basic> wait, i pastebin it
03:51:05 <basic> http://dpaste.com/1R6X1CK
03:51:43 <basic> is this a chicken egg problem? if my type becomes applicative.. (Expt (+1)) <*> (Expr 1) has to work 
03:51:48 <boxscape> okay, so yeah, in the instance definition, the type f will be replaced by your type, so it is Expr (a -> b) -> Expr a -> Expr b
03:51:52 <basic> but it's not monad yet
03:52:19 * hackage haskoin-node 0.14.1 - P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.14.1 (jprupp)
03:52:29 <boxscape> you can define Applicative in terms of Monad without any issues like you're doing here, but yes, you would need to define the Monad instance before this compiles
03:52:47 <basic> so.. if i added monad instance now.. they would reference themselves?
03:52:57 <basic> monad needs applicative and applicative needs monad?
03:53:18 <boxscape> Monad requires that an Applicative instance is defined, but it doesn't need to be defined *in terms* of the Applicative instance
03:53:38 <boxscape> so as long as you don't use <*> in the Monad instance definition, you're good
03:53:50 <boxscape> if you do, you might get infinite loops, if you also define <*> in terms of do notation like this
03:54:46 <boxscape> that said, you could also define the Applicative instance without do notation, and in such a way that it wouldn't require a Monad instance
03:54:48 * hackage aws-lambda-haskell-runtime 3.0.0 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-3.0.0 (NickSeagull)
03:55:21 <basic> oopsie
03:55:43 <boxscape> it is fairly common to define Applicative in terms of Monad though, since it's often easier
03:55:44 <basic> oopsie, i left
03:56:17 <boxscape> you didn't miss anything
03:56:41 <boxscape> though here's logs if you need them :) http://tunes.org/~nef/logs/haskell/20.06.19
03:58:43 <basic>     (>>=) (Val v) f = pure (f v)
03:58:47 <basic> how is this incorrect?
03:59:52 <merijn> basic: What's the type of 'f'?
04:00:18 <basic> :t (>>=)
04:00:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:00:27 <basic> i guess it's (a -> m b)
04:00:54 <boxscape> what's the type of (f v)?
04:01:04 <boxscape> (and yes that is the type of f)
04:01:08 <basic> i guess it's (m b)
04:01:21 <boxscape> yes, and what's the type of (pure (f v))?
04:01:29 <basic> m m b?
04:01:32 <boxscape> yep
04:01:40 <basic> thank you
04:01:48 <boxscape> (well technically m (m b))
04:02:52 <boxscape> since application is left associative, so m m b would be (m m) b, which wouldn't quite make sense
04:03:44 <basic> hm.. and what happens if i bind an expression
04:03:49 <basic> no clue!!!!!!!!!
04:04:45 <boxscape> hm actually I'm not even sure if there's a sensical Monad instance for a binary tree like this
04:05:06 <boxscape> I think there is
04:05:19 <basic> i have no plan im just looking where types lead me
04:05:24 <basic> just so you know
04:05:26 <boxscape> that's usually a good approach
04:05:28 <basic> this is the way i explore this
04:08:12 <basic>     (>>=) (Val v) f = pure (f v)
04:08:18 <basic>     (>>=) (Expr x y) f = Expr (fmap f x) (fmap f y)
04:08:36 <basic> no, yes?
04:08:38 <boxscape> I think that's close
04:08:53 <boxscape> but again pure (f v) is m (m b) whereas you need m b
04:09:34 <basic> yeah but this time i don't have a pure inside there that i can remove
04:09:44 <boxscape> well, for the Val case you do
04:10:24 <boxscape> for the Expr case you have the same problem, and yes, there you have to take a different approach
04:10:25 <basic> no i mean in this definition of (>>=)
04:11:12 <boxscape> right you pasted two equations that are part of this definition, and the first equation of this definition still has the problem that the pure turns (f v) into a value of type m (m b)
04:11:27 <basic> yeah i removed that pure and atleast the compiler liked that
04:11:44 <basic> i forgot that the pure has to be part of >>= (this lamdba/function)
04:12:05 <basic> ahhhh and that the problem
04:12:17 <basic> hmmmmmmmmmmmmm
04:12:43 <boxscape> do you know what the types of f and x are?
04:12:53 <basic> no :(
04:13:02 <boxscape> :t (>>=)
04:13:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:13:07 <boxscape> f is the same as before, (a -> m b)
04:13:09 <basic> ah you mean like there, yes
04:13:20 <basic> yeah i get it f returns whatever monad i have there
04:13:28 <basic> fmap also, and that would make it m m b again
04:13:35 <basic> but i have no clue what to do now
04:13:37 <boxscape> right
04:14:17 <boxscape> so you have a (Expr a) in x
04:14:22 <boxscape> and you have a (a -> Expr b) in f
04:14:41 <boxscape> or (x :: m a) and (f :: a -> m b)
04:15:00 <boxscape> and now you're trying to get a (m b) result instead of m (m b)
04:15:12 <boxscape> so far so good?
04:15:55 <basic>     (>>=) (Expr (Val x) (Val y)) f = Expr (f x) (f y)
04:16:06 <basic> this would solve it for one case, but is it the way to go?
04:16:18 <basic> writing all 4 cases?
04:16:25 <boxscape> no, you don't need to do that
04:16:40 <basic> hm
04:16:51 <basic> and i guess that wouldnt solve it for all depths
04:16:56 <boxscape> exactly
04:17:10 <boxscape> you have (x :: m a) and (f :: a -> m b) and you want to get (m b), so what you're looking for is a function of type (m a) -> (a -> m b) -> m b
04:17:36 <basic> yeah i have the problem that this looks like
04:17:54 <basic> (m (Expr x y)) -> 
04:17:54 <basic> hmmmmmmmm
04:18:14 <boxscape> we've actually already talked about a function of type (m a) -> (a -> m b) -> m b
04:18:56 <boxscape> any ideas what it might be?
04:19:13 <basic> well that is (>>=)
04:19:17 <boxscape> exactly
04:19:31 <basic> but m a is (Expr a b)
04:19:48 <basic> it includes multiple thingies and that confuses me
04:20:42 <boxscape> it's not much different than if you had `data Pair a = MkPair a a`, and then `MkPair 3 4 :: Pair Int`
04:20:58 <basic> yeah i know that, but it still confuses me
04:22:15 <basic> now clue what i do with x y after unpacking via pattern matching
04:22:23 <basic> i could case them
04:22:25 <boxscape> your previous approach was pretty good, so you had (>>=) (Expr x y) f = Expr (? :: Expr b) (? :: Expr b)
04:22:33 <boxscape> so you just need to fill in the question marks, and
04:22:41 <basic> yeah i got that
04:22:44 <basic> but what is that :/
04:22:47 <koz_> basic: First, rename 'Expr a b' to 'Expr c d'. Then note that m ~ 'Expr c' and a ~ 'd'. Then just substitute.
04:23:02 <koz_> It's the easiest way.
04:23:57 <basic> why would names matter?
04:24:09 <boxscape> focus on the left question mark first: you have (x :: m a); (f :: a -> m b), y isn't going to be necessary for the left one. So you can combine f and x with the aforementioned function of type (m a -> (a - m b) -> m b)
04:25:06 <basic>     (>>=) (Expr x y) f = Expr (f x) (f y)
04:25:20 <basic> that is kinda what i want.. but Expr could be 2 things.. that's why that doesn't work?
04:25:30 <boxscape> koz_ I don't think that's right, the type Expr is of kind * -> *
04:25:43 <koz_> 'Expr a b' is the type right?
04:25:52 <basic> koz_: no, Expr a
04:26:13 <basic> Expr (Expr a) (Expr a) is a constructor
04:26:16 <koz_> "but m a is (Expr a b)" <-- was what you said.
04:26:18 <basic> Expr a b was just an vlaue 
04:26:21 <boxscape> basic I would say the reason it doesn't work is that you're trying to apply an argument of type (m a) to a function that takes an (a)
04:26:31 <basic> koz_: yeah with a = b :D
04:26:43 <koz_> I guess I should read more carefully then.
04:26:50 <basic> boxscape: yes, and to get "a" i would have to pattern match x
04:27:01 <basic> koz_: no, i didn't write that, i just didn't mention it :/
04:27:22 <basic>  ma is typey Expr a b not
04:27:23 <boxscape> basic you don't have to pattern match, you can combine f and x with >>=
04:27:28 <basic> ohhhhhhhhhhhhhhhhhhhhhh
04:27:43 <basic> i'd never think of using >>= inside >>=
04:27:55 <boxscape> yeah it can catch you off guard the first time :)
04:28:14 <basic> yeah well, it's clear that recursiveness is the bread and butter of haskellers and i used it in fmap also
04:28:19 <boxscape> true
04:28:20 <basic> but this is one step more complex
04:28:25 <koz_> "Yo dawg, we heard you like bondage, so we put a >>= in your >>= [complete the joke yourself]"
04:28:41 <basic> back when memes where memes
04:30:38 <basic> (Expr (Val 1) (Val 2)) >>= (\x -> pure x+1) this should work now, right?
04:30:47 <basic> ah parenthesis
04:30:54 <boxscape> I think so
04:30:56 <basic> yaaaaaaaaaaaaaaaaaay, boxscape great teaching, thank you
04:31:02 <boxscape> you're welcome
04:32:15 <basic> and now i can use applicative becuase i implemented monads
04:32:18 <basic> jesus.
04:32:25 <boxscape> right
04:32:52 <koz_> "Yo dawg, we heard you like type classes, so we defined a type class in terms of your type class..."
04:33:25 <basic> well, if i implemented without monad.. i'd basicially implement >>= inside applicative
04:33:28 <basic> wouldn't i?
04:33:43 <basic> inside applicatives definiotion for this type*
04:34:13 <boxscape> you could, but >>= provides more power than you actually need to define <*>
04:34:42 <koz_> In fact, you can cheat if you have >>=, and define <*> = ap.
04:35:17 <basic> yeah that is what i was discvoering here
04:36:37 <boxscape> basic though feel free to try writing <*> directly with pattern matching instead of >>= :)
04:36:49 * hackage haskoin-store-data 0.32.0 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.32.0 (jprupp)
04:37:45 <basic> a weaker version i guess
04:37:48 * hackage haskoin-store 0.32.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.32.0 (jprupp)
04:38:26 <boxscape> the resulting <*> wouldn't be weaker, it's just that in general, there are some types for which you can define Applicative instances but no Monad instances
04:38:49 <basic> yeah but if i just replace <- with >>= it wouldn't be weaker
04:38:53 <basic> so it wouldn't be what i want
04:39:20 <basic> and i have no idea how i would implement it without <-
04:39:57 <merijn> basic: <- *literally* is >>=
04:40:01 <basic> yeah i know
04:40:11 <basic> that's why i wrote if i just replace with the function body of >>=
04:40:28 <boxscape> the first case should be easy enough: Val f <*> Val x = ...
04:40:40 <basic> ah so every case..... hm, yah i guess that works
04:40:53 <basic> but now i don't know how this is useful :D
04:40:59 <basic> i wanted to do something like
04:41:35 <basic> (<*>) [Val (+1)] [(Val 1)]
04:41:43 <basic> and i know why this doesn't work :D
04:41:49 <basic> list applicative != mine
04:42:02 <basic> or /= if u like
04:42:05 <boxscape> right
04:42:37 <basic> i don't think i did something useful there, but learn about monad & applicative relationship
04:42:55 <boxscape> basic you can compose applicative functors like list and Expr to get a new applicative functor that can do this, I think
04:43:10 <boxscape> % :k Compose
04:43:10 <yahb> boxscape: ; <interactive>:1:1: error: Not in scope: type constructor or class `Compose'
04:43:12 <basic> i think that's kinda the idea of applicative
04:43:28 <basic> but that would look even more confusing to me
04:44:13 <basic> that >>= implementation is basicially just walking down a binary tree and using f on the leafes
04:44:19 <boxscape> i.e. you'd have something like (Data.Functor.Compose [] Expr) and you could use its predefined <*> instance for (<*>) [Val (+1)] [(Val 1)]
04:44:22 <basic> and then putting it back inside the tree
04:44:26 <boxscape> yes
04:44:29 <basic> it's odd that you only realize this, when you're done
04:44:35 <merijn> basic: That sounds right for the Monad of a tree, yes :p
04:45:00 <boxscape> (for the Compose thing you'd still have to wrap the values in the newtype but that's the gist)
04:45:07 <basic> then again.. fmap basicially implemented itself since i had no choice
04:45:11 <boxscape> (i.e. wrap them in the Compose newtype)
04:45:39 <boxscape> basic yeah there's always only one lawful Functor instance for algebraic data types
04:45:53 <boxscape> or at most, rather
04:46:07 <basic> i guess Either is an exception?
04:46:31 <boxscape> I don't think it is, technically. You'd have to make a newtype to fmap over the first parameter
04:46:33 <merijn> basic: You didn't have a choice! :)
04:46:43 <merijn> basic: fmap is unique
04:46:59 <merijn> basic: There is only ever *1* lawful implementation of fmap for a type
04:47:17 <basic> then why do i have to write it? if it's predetermined
04:47:26 <boxscape> basic you can derive it :)
04:47:28 <koz_> basic: You don't. DeriveFunctor exists.
04:47:35 <boxscape> % :set -XDerivingFunctor
04:47:35 <yahb> boxscape: Some flags have not been recognized: -XDerivingFunctor
04:47:40 <boxscape> % :set -XDeriveFunctor
04:47:41 <yahb> boxscape: 
04:47:52 <basic> and i write deriving (Functor) then?
04:47:55 <boxscape> % data Expr a = Val a | Expr (Expr a) (Expr a) deriving Functor
04:47:55 <yahb> boxscape: 
04:47:57 <merijn> basic: Yeah
04:48:09 <boxscape> % fmap (+1) (Expr (Val 1) (Val 2))
04:48:09 <yahb> boxscape: ; <interactive>:6:1: error:; * No instance for (Show (Expr Integer)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
04:48:12 <boxscape> meh
04:48:54 <merijn> basic: Applicative and Monad on the other hand are not unique and there may be multiple lawful implementations
04:49:29 <merijn> basic: The most obvious example being [] which has two lawful Applicatives (the one it uses by default, and the one triggered by the ZipList newtype)
04:49:36 <boxscape> question: with type level lambdas, would there still be a unique Functor instance, or could you have `instance Functor (\a -> Either a b)`?
04:50:11 <boxscape> I feel like I'm missing something here
04:50:37 <merijn> boxscape: That's just, like "newtype Flip f b a = Flip (f a b)"
04:50:45 <merijn> boxscape: Basically, Either is a Bifunctor
04:50:51 <basic> boxscape: works for me!
04:50:52 <merijn> :t bimap
04:50:53 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
04:51:12 <merijn> boxscape: But Haskell is bad at expressing such generalisation well
04:51:48 <boxscape> merijn right, it just doesn't feel right to me that you suddenly don't need a newtype, but I guess type level lambdas might just not be something I'm used to
05:00:49 <merijn> boxscape: I mean, you can't just throw type level lambda into Haskell without making major adjustments to the type system anyway, so at that point nearly everything is up in the air
05:01:01 <boxscape> yeah, that makes sense
05:01:18 <boxscape> I guess I just kind of expected "there's a unique functor instance" to be a more general theorem than it is
05:07:28 <Ariakenom> its not instance Functor (Either a b) its instance Functor (Either a). So if there were instance Functor (Either _ b) then it wouldnt be for the same type anyway?
05:08:14 <merijn> Please define "same type" first ;)
05:09:01 <boxscape> Ariakenom I'm not quite sure what you mean - in `instance Functor (Either a)` you map over Rights, in a hypothetical `instance Functor (\a -> Either a b)`, you would map over Lefts
05:09:23 <Ariakenom> its the type in boxscape's "for each type there is a unique functor instance"
05:10:07 <boxscape> so it's `fmap :: (b -> c) -> Either a b -> Either a c` versus `fmap :: (a -> c) -> Either a b -> Either c b`
05:23:30 <boxscape> Ariakenom Oh I get what you mean now
05:25:03 <boxscape> Ariakenom I interpreted the law as meaning "there's at most a unique functor instance for a given type constructor" but I suppose it doesn't need to mean that, just useful because it also means that deriving a Functor instance is unique 
05:25:44 <boxscape> Or, well... I guess you could do "deriving instance Functor (Either a)" and it'd still be unique, with or without type lambdas
05:26:46 <boxscape> so the only uniqueness you lose (I think) with type lambdas is the result of deriving clauses that are part of data declarations
05:27:19 <Ariakenom> yeah that makes sense. it doesnt seem to work out well in haskell with how type classes look.
05:32:48 * hackage aws-lambda-haskell-runtime-wai 1.0.0 - Run wai applications on AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-wai-1.0.0 (dnikolovv)
05:33:59 <Ariakenom> interesting point about "deriving instance Functor (Either a)". I haven't thought about how the deriving clauses dont look like the instance declarations in that way
05:35:23 <boxscape> It becomes especially relevant when you need class constraints (i.e. for something like deriving instance Show a => Show (Maybe a))
05:42:51 <boxscape> interestingly I think you could still only have an instance for one of those two options, since otherwise something like `fmap (f :: Int -> String) (x :: Either Int Int)` would be ambiguous
05:43:09 <boxscape> I was considering if a non-standalone deriving clause could simply generate all possible instances, but no
06:05:24 <Ariakenom> boxscape, yes that leads to more ambiguous type inference. but why do you say "could only have" because of it?
06:06:22 <boxscape> Ariakenom hm, I vaguely assumed that it would get you a duplicate instance declaration but yeah that's not actually true
06:11:01 <Ariakenom> yes I was thinking something like that too first. theory crafting a different haskell seems like it can get confusing :D
06:11:30 <boxscape> true
06:11:48 * hackage interact 0.1.0.0 - instantly create REPL from any function  https://hackage.haskell.org/package/interact-0.1.0.0 (epoberezkin)
06:16:07 <boxscape> Looking at the agda standard library, it looks like they simply don't have any Functor instances for Product and Either (and, in fact, no type called "Either" at all)
06:16:59 <boxscape> oh, nevermind
06:17:52 <boxscape> Product instances exist but are made from Left and Right types rather than from Product
06:20:34 <boxscape> (or rather Product_l and Product_r)
06:22:00 <boxscape> same for Either, except it's called Sum
06:22:24 <boxscape> so yeah it looks like even though they have the option of getting both instances (I think?) without newtyping they still do the equivalent
06:25:47 <boxscape> ehh hold up, Product_l and Product_r are simple functions, not data declarations, so they don't actually newtype it. Though I'm still somewhat confused by what exactly is going on.
06:30:39 <boxscape> I'm pretty sure they define functor records directly on the types, but then don't make actual instances out of those records, so you don't get the instance resolution ambiguity problem
06:30:48 <boxscape> s/directly on/directly for
06:37:49 * hackage json-rpc 1.0.3 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-1.0.3 (jprupp)
06:38:14 <bolti[m]> Hi, what is the best way to use haskell in arch? I've read that there are some problems with the packages
06:39:23 <basic> switch to a good distro </flameWarStartingComment>
06:40:13 <boxscape> bolti[m] I've heard multiple times that you shouldn't use the haskell packages in the arch repository, but apart from that, it's probably up to personal taste whether you want to use stack or cabal to get your haskell packages
06:40:44 <bolti[m]> basic: xd
06:41:06 <bolti[m]> so I should install every package from stack or cabal, right?
06:41:07 <boxscape> (or nix, though most people are proabably better of with stack or cabal)
06:41:10 <boxscape> yes
06:41:52 <boxscape> bolti[m] though you probably won't need to use the "install" command of stack or of cabal for most things
06:42:12 <boxscape> bolti[m] you give them the dependencies of a haskell package you want to build and they handle the rest,
06:42:35 <boxscape> globally installing packages is usually not necessary
06:42:39 <bolti[m]> I was also thinking in packages like xmonad
06:42:49 <boxscape> right, for something like that it makes sense to install it
06:45:58 <bolti[m]> thanks!
07:02:40 <maerwald> bolti[m]: cabal
07:03:30 <maerwald> don't use the package managers GHC
07:22:50 <ezzieyguywuf> I'm perusing this, and these concepts seem to align with FP and haskell-stuff. Do you all know of any such haskell implementation of this "imgui" concept? http://www.johno.se/book/imgui.html
07:23:48 * hackage sparse-tensor 0.2.1.4 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.2.1.4 (nalex)
07:27:54 <dolio> I might know where to look, but I think it is the complete opposite of a functional approach.
07:31:39 <dolio> And it seems like the arguments for it are extremely tailored toward things like games.
07:31:46 <ezzieyguywuf> hrm, perhaps
07:32:09 <ezzieyguywuf> I'm just trying to figure out how to do a cross-platform window with buttons and stuff without having to resort to, say, qt
07:32:13 <ezzieyguywuf> which is very 'big'
07:36:30 <__monty__> I think fltk is cross-platform?
07:37:18 <ezzieyguywuf> yea, fltk is the leading contendor for me, but from I can tell the look-and-feel is "non-native"
07:37:54 <kuribas> are conduit, pipes and stream still so much behind streamly in performance?  This page seems to imply an order of magnitude difference (several orders for some). https://github.com/composewell/streaming-benchmarks
07:38:01 <kuribas> or are these unrealistic test cases?
07:43:08 <ezzieyguywuf> dope, there's an fltks-themes package(s?) that make things look nicer
07:43:51 <kuribas> ezzieyguywuf: why not use wxhaskell?
07:43:52 <ezzieyguywuf> although there's only a light theme
07:44:03 <kuribas> ezzieyguywuf: it looks native on windows, linux and macos
07:44:25 <ezzieyguywuf> kuribas: does it compile/install the wxwidgets dependencies?
07:44:33 <ezzieyguywuf> or does that have to happen outside of cabal/stack?
07:44:53 <kuribas> ezzieyguywuf: you need to have it installed IIRC
07:45:06 <Cale> kuribas: Offhand, it looks like they're using extremely small streams... if I'm reading this right, the streams are... 3 elements long?
07:45:11 <ezzieyguywuf> is it actively developped?
07:45:20 <kuribas> it's a bit behind
07:45:45 <Cale> kuribas: I highly doubt that these benchmarks are a realistic indication of throughput on any task that you're actually putting any of these libraries to use for.
07:46:12 <kuribas> Cale: For example parsing xml using a sax-stream
07:46:31 <Cale> Like, unless your XML is only 3 characters
07:46:41 <ezzieyguywuf> *shrug* maybe I'll just write my entire backend in haskell and do the gui stuff using some toolkit natively rather than a binding
07:46:54 <Cale> I think probably you want a bit of a bigger test to allow the libraries to get warmed up
07:47:12 <Cale> I think they're mostly measuring the constant term
07:47:29 <Cale> (and not really a constant factor)
07:47:45 <kuribas> ezzieyguywuf: what's your usecase?
07:48:23 <ezzieyguywuf> ezzieyguywuf: I'm developping a desktop CAD app. I'm currently using glfw for the opengl context, but I guess I'll eventually have to port that over to whatever gui toolkit I land on
07:48:44 <ezzieyguywuf> the haskell glfw bindings are great, and glfw in general is great, but I don't think it can do much more than just give you somewhere to draw triangles
07:49:00 <Cale> https://github.com/composewell/streaming-benchmarks/blob/master/charts-0/streamly-vs-streams.txt -- yeah, if you look at the actual numbers, the units are microseconds
07:49:19 <srk> ezzieyguywuf: I like GPipe now
07:49:25 <Cale> (hundreds, or tens of thousands of microseconds, but still)
07:49:26 <Boarders> I imagine streamly is consistently the fastest but also it is worth saying that they added a compiler plugin and seem to require special flags so it’s unclear how brittle the good performance is
07:49:39 <srk> ezzieyguywuf: also working on blendish like GL native UI based on nanovg
07:50:07 <srk> ezzieyguywuf: http://48.io/~rmarko/2020-03-22-150905_1015x1056_scrot.png
07:50:35 <Cale> They're basically just measuring the time taken to get from nothing to beginning processing of something, and not the rate at which streams are processed, which is probably what you're usually interested in
07:50:44 <ezzieyguywuf> srk: I looked at GPipe, it was pretty confusing. Besides, it seems like an alternative to glfw itself (which is working fine for me), not a gui toolkit
07:50:52 <ezzieyguywuf> srk: what is 'blendish like GL'?
07:51:19 <Cale> I don't know about you, but the number of microseconds it takes to begin processing a stream is usually not what I care about
07:51:34 <ezzieyguywuf> nice, another scrot user ^_^
07:52:01 <ezzieyguywuf> srk: you made those buttons and menus using gpipe as well?
07:52:09 <ezzieyguywuf> so you're rendering them in your openGL context?
07:52:14 <srk> ezzieyguywuf: nanovg-hs
07:53:25 <ezzieyguywuf> srk: first I've heard of nanovg, looks nice
07:53:26 <srk> ezzieyguywuf: https://hg.sr.ht/~duangle/oui-blendish but no pics as it was moved recently
07:54:46 <srk> ezzieyguywuf: https://hg.sr.ht/~duangle/oui-blendish/raw/doc/images/1457969701-blendish2.png (if you know VCVRack - it is made with nanovg + oui-blendish)
07:54:47 <ezzieyguywuf> srk: are there any pros/cons to rendering the gui in the opengl context rather than keeping it in the OS?
07:55:46 <kuribas> ezzieyguywuf: 3D CAD?
07:55:50 <ezzieyguywuf> I don't know VCVRack, but that looks nice.
07:55:51 <srk> well pros are that you don't have to carry all the baggage of the full blown GUI toolkit around, cons are that you need to do all of what it does yourself (like handling input, DPI, accessibility whatnot)
07:55:51 <ezzieyguywuf> kuribas: yes.
07:56:14 <ezzieyguywuf> srk: seems like a very reasonable tradeoff. Are there any performance implications though?
07:57:00 <srk> probably not since both GL and Haskell are fast :)
07:57:19 <ezzieyguywuf> lol
07:57:36 <ezzieyguywuf> I like this nanovg, I'm definitely going to give it a whirl thanks for the tip
07:57:53 <srk> also portability would be nice, like being able to run with WebGL context :)
07:58:04 <srk> FRP too
07:58:36 <ezzieyguywuf> srk: yes, portability is one of my main concerns
07:58:55 <ezzieyguywuf> srk: are there other neat opengl libraries like this nanovg that you're familiar with that you might recommend?
08:00:03 <srk> ezzieyguywuf: Dear ImGui is interesting :) 
08:00:21 <ezzieyguywuf> srk: I saw that! it's c++ though, probs doesn't have a haskell binding.
08:00:29 <ezzieyguywuf> I was comparing it with nuklear
08:01:01 <srk> yeah, there is abandoned imgui-haskell but something like blendish + nanovg-hs is a better fit for Haskell 
08:01:28 <srk> ezzieyguywuf: is your work open source?
08:02:42 <ezzieyguywuf> srk: yea, def a work in progress though. https://gitlab.com/ezzieyguywuf/mycad
08:02:51 <ezzieyguywuf> you can look at the drawLines branch for the latest commits
08:03:20 <Cale> Interesting to see VCV Rack mentioned here. :D
08:03:21 <ezzieyguywuf> lol, "How To Build" is still for when it was in c++...
08:03:22 <srk> cool, that motivates me a bit to progress with the UI thingie :)
08:03:59 <Cale> (Some people were talking about it in #ardour not so long ago)
08:04:46 <ezzieyguywuf> heyyy I remember when I wanted to make music in Ardour, what a great piece of software
08:05:35 <srk> +1
08:05:49 * hackage influxdb 1.8.0 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.8.0 (MitsutoshiAoe)
08:06:47 <kuribas> Cale: what setup time do streaming solution need though?
08:06:49 * hackage rattletrap 9.1.4 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.1.4 (fozworth)
08:07:19 <dminuoso> What's a simple to use library that gives me indexable pixel access? I dont care about the format, its for pedagogical reasons.
08:07:57 <ezzieyguywuf> juicypixels?
08:08:45 <Cale> kuribas: Not a whole lot
08:09:04 <Cale> Now, they do *claim* to be passing in a million elements, so it could be I'm just not reading this right
08:09:49 <dminuoso> ezzieyguywuf: That looks workable, though it still has annoying complexity.
08:10:07 <Cale> But in any case, the baselines are like, tenths of a millisecond here.
08:10:38 <ezzieyguywuf> dminuoso: good luck!
08:10:52 <kuribas> Cale: yeah, when streaming from a file, the IO likely dominates.
08:11:21 <kuribas> Cale: I suppose streamly is faster by not using an ADT.
08:12:54 <kuribas> newtype Stream m a = MkStream (forall r. State Stream m a -> (a -> Stream m a -> m r) -> (a -> m r) -> m r -> m r
08:16:02 <dminuoso> Cale: by the reason, the reason I haven't responded yet, is because I haven't found time yet. It was quite late yesterday, and today I'm keeping busy.
08:16:12 <dminuoso> Bah. I cant even type sensibly.
08:17:01 <Cale> dminuoso: That's fine :)
08:17:49 <Cale> kuribas: Yeah, it's really unfortunate how much better GHC is at compiling with datatypes that someone has manually CPSed
08:18:33 <kuribas> maybe it's easier to optimize?
08:18:59 <Cale> Yeah
08:21:58 <kuribas> I wonder if it has to do with lazyness
08:23:42 <Cale> kuribas: I think it's more to do with the way that GHC has only one choice about how it encodes data constructors at runtime
08:23:49 * hackage pandoc-plot 0.7.1.0 - A Pandoc filter to include figures generated from code blocks using your plotting toolkit of choice.  https://hackage.haskell.org/package/pandoc-plot-0.7.1.0 (LaurentRDC)
08:24:41 <Cale> kuribas: also, sometimes, that it's completely unable to specialise the representation of a datatype when applied to a given type argument
08:24:53 <maralorn> Can I make the version bounds in cabal dependent on the used ghc version?
08:25:06 <Axman6> @hoogle (a -> k) -> a -> (k,a)
08:25:07 <lambdabot> Relude.Extra.Tuple mapToFst :: (a -> b) -> a -> (b, a)
08:26:28 <kuribas> streamly also seems to be severly lacking in libraries
08:26:40 <kuribas> like streaming from http, files, ...
08:28:32 <Cale> Yeah, I suspect that as soon as they do a benchmark involving actual I/O, the graphs will at least be a lot closer, rather than "oh, it's hundreds of times faster!"
08:29:56 <kuribas> they also claim smart scheduling for concurrency.
08:46:31 <kuribas> it looks like streamly is made for concurrency, while in other streaming libraries it's an add-on
08:46:50 <kuribas> but besides the main streamly library, there isn't much.
08:47:18 <maerwald> kuribas: what are you looking for?
08:47:41 <maerwald> it has both file and tcp streaming
08:47:42 <kuribas> maerwald: I am building an xml parser on top of hexpat
08:47:55 <kuribas> maerwald: but not http?
08:48:08 <kuribas> hexpat uses List, which noone uses.
08:48:18 * hackage foldl 1.4.7 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.4.7 (GabrielGonzalez)
08:48:19 <maerwald> afaik parsing is one of the goals, but they are not there yet
08:48:23 <kuribas> so I am looking for a good streaming library to use instead of List.
08:49:06 <maerwald> https://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly-Network-Inet-TCP.html
08:49:23 <maerwald> This is all there is wrt networking
08:49:44 <kuribas> indeed
08:50:19 <kuribas> For streaming you could use this: https://hackage.haskell.org/package/streaming-utils-0.2.0.0/docs/Data-ByteString-Streaming-HTTP.html
08:51:05 <solonarv_> ski: suppose 'newtype F m a = F (m a)', now since we don't know the roles of 'm' GHC will infer 'type role F _ nominal' (I don't remember what happens to the 'm' parameter)
08:51:10 <solonarv_> so we can never 'coerce :: F m a -> F m a' ', no matter what m, a, or a' are
08:51:54 <solonarv_> even though it seems like we should be able to coerce when (for example) 'm' is Identity and 'Coercible a a' '
08:52:01 <maerwald> kuribas: unfortunately that one uses haskell-tls for https
08:52:18 <ski> hm
08:52:46 <ski> was there any provisions at all for some kind of higher roles ?
08:52:57 <maerwald> http-io-streams is one of the few that uses openssl under the hood
08:53:15 <maerwald> but isn't that cool otherwise
08:53:21 <solonarv_> I'm not sure, probably the fact that parameters of a kind other than Type can have roles has something to do with that
08:53:24 <ski> how would you express it, with `QuantifiedConstraints' ?
08:54:05 <solonarv_> in this case, (forall m a a'. Coercible (m a) (m a') => Coercible (F m a) (F m a'))
08:54:51 <ski> hmm
08:55:04 <ski> how about
08:55:22 <solonarv_> in the Identity case, we'd go from wanted=(Coercible (F Identity a) (F Identity a')) to wanted=(Coercible (Identity a) (Identity a')) and then finally to wanted=(Coercible a a')
08:55:57 <ski>   (Coercible b0 b1,forall m. Coercible a0 a1 => Coercible (m a0) (m a1)) => Coercible (F m b0) (Coercible m b1)
08:56:31 <ski> oh .. something's wrong
08:56:39 <solonarv_> that's also valid, but more restrictive
08:56:44 <ski> the `m' shouldn't be quantified here, i think
08:56:59 <ski> oh, sorry
08:57:08 <ski> i missed the scope of your `forall'
08:57:13 <solonarv_> because if you want to (coerce :: F Proxy a -> F Proxy a') it shouldn't matter at all what a and a' are
08:58:06 <ski> mm
08:58:19 <ski> so you defer to the coercibility of `m' itself
08:58:39 <solonarv_> yep, since that is (morally) what the implementation is doing
08:59:22 <solonarv_> we can imagine something like: instance Coercible (m a) (m a') => Coercible (F m a) (F m a') where coerce (F ma) = F (coerce ma')
08:59:27 <ski> so, if you have
08:59:42 <ski>   data F m = MkF (m Int) (m Bool)
08:59:46 <ski> you should get
09:00:00 <ski> oh, right
09:00:10 <ski> hm
09:01:00 <solonarv_> and actually we can generalize: instance Coercible (m a) (m' a') => Coercible (F m a) (F m' a') where coerce (F ma) = F (coerce m'a')
09:02:35 <solonarv_> for your F, the maximally general instance would be (forall m m'. (Coercible (m Int) (m' Int), Coercible (m Bool) (m' Bool)) => Coercible (F m) (F m'))
09:03:26 <solonarv_> but you could also degeneralize(?) that to to (forall m m'. (forall a. Coercible (m a) (m' a)) => Coercible (F m) (F m')) -- which is simpler in some sense
09:03:36 <ski> (specialize)
09:03:59 <ski> (hm, is that an appropriate term ?)
09:04:44 <ski> anyway, allowing also the operand to vary handles curried style nicely
09:05:19 * hackage commander-cli 0.5.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.5.0.0 (sgschlesinger)
09:12:44 <ski> hm, so iiuc `type role F nominal' means something like`forall a b. (a = b) => Coercible (F a) (F b)', and `type role F representational' means `forall a b. Coercible a b => Coercible (F a) (F b)', while `type role F phantom' means simply `forall a b. Coercible (F a) (F b)'
09:14:12 <ski> hmm .. i wonder how this would look like, if one had (subsumption) subtyping in the system
09:15:40 <ski> in general, we ought to have `forall a b. (a = b) => Coercible a b' (which implies it's reflexive), and also `Coercible' being symmetric and transitive, so an equivalence relation
09:30:54 <solonarv_> ski: yup, that's all correct
09:31:11 <solonarv_> and GHC's magic solver for Coercible does indeed make it an equivalence relation
09:32:18 <solonarv_> (also, equalities in constraints are written with ~ , not = )
09:32:33 <ski> (i know. i was deliberately using `=')
09:34:27 <ski> i was attempting to ponder how a system allowing one to express more nuanced "higher" roles for parameters of non-concrete kind, could look like
09:35:21 <ski> (and, these differences in how the parameters are treated again reminds be back to covariance vs. contravariance of functors .. which is what started this conversation)
09:35:54 <kamek> I'm confused about GHC's -N option for threaded contexts '-' I'm runing something I built with +RTS -maxN2 -RTS but it still spawns about 10 threads somehow
09:36:00 <kamek> am I understanding this wrong
09:38:04 <ski> hm, `Coercible' itself is not polymorphic, right ?
09:39:46 <solonarv_> % :k Coercible
09:39:46 <yahb> solonarv_: k -> k -> Constraint
09:39:52 <solonarv_> surpriringly, it is
09:40:06 <bifunc2> Is there any more detailed time profiling than +RTS -p ? I have a case where "main" and one function in "main" is taking 99.9% of the time. Yet below that I have a function taking up only 11%. I can't see where the remaining 89% of the time is going.
09:40:38 <solonarv_> but I don't know exactly what 'Coercible f g' means when f, g have a kind other than Type
09:42:51 <IanLiu> I have this simple function from String -> IO Text defined as "openURL x = decodeUtf8 <$> simpleHttp x". Is it possible to get rid of the x argument?
09:44:33 <ski> solonarv_ : hm. so i guess generated (?) instances for `Coercible' are made, for parameterized data types, in one of three forms, depending on the role on the parameter in question ?
09:44:54 <ski> kamek : hm, are you sure you're not confusing capabilities for actual Haskell threads ?
09:45:01 <Axman6> kamek: if you go getCapabilities >>= print, what gets printed? I wouldn't be surprised if the binary spawns more threads then you ask for other things (particularly on macOS, where the OS may also spawn Grand Central Dispatch stuff)
09:45:42 <Axman6> bifunc2: have a look at myApp +RTS --help -RTS there's also -P and -Pa IIRC
09:46:23 <solonarv_> ski: yup. I think the GHC manual (or is the haddocks for Coercible) says exactly that
09:47:21 <Axman6> IanLiu: start by replacing the infix fmap with the prefix fmap: openURL x = fmap decodeUtf8 (simpleHttp x). If you rewrite that as getURL = \x -> fmap decodeUtf8 (simpleHttp x), does the right hand side look familiar?
09:48:29 <kamek> ah yes, I need to lookup the distinction, the number of capabilities does match the number of core on my machine
09:48:50 <kamek> or whatever I restrict it to
09:49:53 <Axman6> which OS are you on?
09:50:49 <Axman6> it might be possible to find out what the other threads are for, on macOS they're usually named, and just looking at the stack trace from each thread should tell you what it's doing by sampling it
09:51:16 <kamek> I'm running Linux
09:54:35 <dolio> bifunc2: Is your main pretty large? Or perhaps most time is spent in a library built without profiling information?
09:55:26 <IanLiu> Axman6: Oh, "fmap decodeUtf8 . simpleHttp"
09:55:27 <bifunc2> i was expecting most of the time to be spent within a particular C function, however that is the 11%
09:55:29 <IanLiu> thanks!
09:56:21 <bifunc2> could there be a TON of different near-zero things that add up to 89%?
10:00:11 <dolio> Seems unlikely. They'd have to all be getting called directly from main, too.
10:03:51 <bifunc2> dolio what about haskell stuff like pattern matching, creating tuples, etc.?
10:04:01 <bifunc2> could that be not showing up in the profile results?
10:04:07 <bifunc2> yet adding up to the 89%
10:06:06 <dolio> Are they all directly in main? The costs are attributed to an enclosing scope that is based on definitions (assuming you used auto-all).
10:07:13 <EvanR> you think your program is so fast that most of the work is in creating and destroying tuples?
10:07:45 <bifunc2> yes it's all in main, or rather in that other function i mentioned below main.
10:07:49 <bifunc2> i've kind of a tight loop in there
10:07:50 <dolio> I mean, that can be most of the work in a program, in a way. But it doesn't just all get attributed to main.
10:08:18 * hackage postgresql-placeholder-converter 0.1.0.0 - Converter for question mark style and dollar sign style of PostgreSQL SQL.  https://hackage.haskell.org/package/postgresql-placeholder-converter-0.1.0.0 (kakkun61)
10:08:56 <bifunc2> if 3-tuple pattern matching takes something like 10 ns, that would explain my time already i think
10:09:11 <bifunc2> or ok, 20-30 ns
10:28:59 <dolio> bifunc2: You can add more cost centers to check.
10:29:08 <bitmapper> hmm.
10:29:51 <bitmapper> i'm still wondering how i would compile lexically scoped lambda calculus to a stack based language, like forth
10:30:18 * hackage dobutokO4 0.5.0.0 - Helps to create experimental music. Uses SoX inside.  https://hackage.haskell.org/package/dobutokO4-0.5.0.0 (OleksandrZhabenko)
10:32:19 * hackage bitcoin-hash 0.1 - Bitcoin hash primitives  https://hackage.haskell.org/package/bitcoin-hash-0.1 (RenzoCarbonara)
10:37:24 --- mode: cherryh.freenode.net set +o ChanServ
10:39:48 * hackage bip32 0.1.2 - BIP-0032: Hierarchical Deterministic Wallets for Bitcoin and other cryptocurrencies  https://hackage.haskell.org/package/bip32-0.1.2 (RenzoCarbonara)
10:55:19 * hackage haskoin-store-data 0.32.1 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.32.1 (jprupp)
10:56:18 * hackage haskoin-store 0.32.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.32.1 (jprupp)
10:57:48 * hackage hlint 3.1.5 - Source code suggestions  https://hackage.haskell.org/package/hlint-3.1.5 (NeilMitchell)
11:14:58 <monochrom> I would think static scoping is exactly stack.
11:15:22 <monochrom> This is like why the SECD machine has so many stacks. :)
11:15:57 <monochrom> Even the STG paper has two stacks.
11:16:46 <monochrom> (Retrospectively we now understand that the two stacks can be safely merged, there is a disambiguable interleaving.)
11:17:42 <Mathnerd314> for lexical scope you need heap-allocated closures, not a stack
11:18:52 <Mathnerd314> or at least, in addition to a stack
11:20:41 <bifunc2> Does Foreign.Ptr stuff have primops in GHC?
11:20:46 <bifunc2> so it's  not foreign call overhead
11:29:19 * hackage hedgehog-fakedata 0.0.1.2 - Use 'fakedata' with 'hedgehog'  https://hackage.haskell.org/package/hedgehog-fakedata-0.0.1.2 (parsonsmatt)
11:33:18 <jumper149> Is there anything I should be cautious about when using UndecidableInstances to write this instance: instance (Monad (t m), MonadRules m, MonadTrans t) => MonadRules (t m)
11:33:50 <jumper149> MonadRules is my self defined class
11:37:43 <monochrom> I think you're OK, since there is no "instance MonadRules (t m) => Monad (t m)" to complete the cycle.
11:40:19 <jumper149> Sounds good. On the other hand if there were a cycle, GHC would only tell me if it actually encounters a point where it can't find the right instance right?
11:43:10 <Cale> jumper149: That instance does look a bit fishy though, since it applies to every type application
11:44:02 <Cale> jumper149: You might also want a different one for a particular monad transformer
11:44:11 <Cale> At least, that's commonly the case
11:46:10 <Cale> It's more common/appropriate to put that kind of thing into the default method implementations for your MonadRules type class (you'll probably need DefaultSignatures)
11:46:26 <Cale> and then you can easily write blank instances for particular monad transformers
12:06:06 <bifunc2> <bifunc2>	Does Foreign.Ptr stuff have primops in GHC? so it's  not foreign call overhead
12:06:21 <bifunc2> indeed i got some improvements by doing pointer arith in haskell itself
12:06:27 <bifunc2> so it's gotta be some prim goodness
12:06:54 <bifunc2> (i was previous doing the pointer stuff within a c func that i was FFI calling)
12:10:32 <wavemode> have you looked into inline-c ? sometimes working in C directly is less of a hassle
12:16:09 <bifunc2> wavemode i was indeed using inline-c
12:16:15 <bifunc2> however that still has FFI overhead
12:16:49 * hackage smuggler2 0.3.6.1 - GHC Source Plugin that helps to minimise imports and generate explicit exports  https://hackage.haskell.org/package/smuggler2-0.3.6.1 (jrp)
12:17:06 <wavemode> I'mn guessing you were calling into c in a continuous loop?
12:18:41 <bifunc2> wavemode yeah :)
13:11:49 * hackage haskoin-store-data 0.32.2 - Data for Haskoin Store  https://hackage.haskell.org/package/haskoin-store-data-0.32.2 (jprupp)
13:12:49 * hackage haskoin-store 0.32.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.32.2 (jprupp)
13:20:58 <jumper149> Can I derive non unary type classes like `MonadReader r` for every r?
13:21:27 <dolio> I think newtype deriving can do that.
13:24:15 <jumper149> That doesn't seem to work :(
13:27:00 <L29Ah> i see that ghc's gc is smart enough to close unused file handles and sockets; is there a way i can add my own handler that, say, tells the remote host the proper words about terminating the connection on gc before closing the socket?
13:27:06 <jumper149> Btw, I meant without giving the constraint manually. It does work with StandaloneDeriving and giving constraints!
13:32:15 <dolio> http://dpaste.com/2ZN1HDX <-- this works
13:33:11 <ezzieyguywuf> sweet. https://limperg.de/ghc-extensions/
13:34:03 <jumper149> Ah yeah, that's not what I meant. For me r isn't a parameter to the type constructor R.
13:34:43 <jumper149> It's more like this instance for example: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader
13:35:35 <jumper149> Oh I mean for example: MonadReader r m => MonadReader r (StateT s m)
13:36:14 <jumper149> I don't think it's possible
13:37:17 <ChaiTRex> L29Ah: I don't think that finalizers are available for pure Haskell code, but I could be wrong.
13:38:12 <maerwald> gc hooks are possible no?
13:38:27 <L29Ah> https://hackage.haskell.org/package/base-4.8.1.0/docs/System-Mem-Weak.html#v:addFinalizer found it
13:38:31 <merijn> maerwald: Only for a limited number of special types
13:38:37 <L29Ah> ChaiTRex: thanks for the keyword
13:38:47 <ChaiTRex> L29Ah: No problem.
13:44:25 <dolio> jumper149: That will work, too, if you're just wrapping something that has an instance. That's what GND is for. I'm not sure what standalone deriving would be doing for a case like StateT, because the implementation isn't trivial.
13:45:36 <L29Ah> ouch, it doesn't work
13:45:43 <L29Ah> http://dpaste.com/1XV2NW4 baz never appears
13:45:54 <jumper149> Yeah everything is fine with StandaloneDeriving!
13:46:05 <L29Ah> though maybe gc is never actually called there
13:46:14 <ezzieyguywuf> I didn't know I could do this: `localAddr Configuration { localHost = localHost, localPort = localPort }`
13:46:28 <L29Ah> but then my idea of handling things going out of, ehm, scope, goes into a garbage bin
13:46:45 <ezzieyguywuf> that's out of context, the signature is `localAddr :: Configuration -> String`
13:47:15 <wavemode_> with NamedFieldPuns, it becomes even shorter: `localAddr Configuration { localHost, localPort } = ...`
13:47:50 <jumper149> ezzieyguywuf: or with RecordWildCards even even short: `localAddr Configuration {..}`
13:48:39 <wavemode_> true, though some people dislike the readability loss of RecordWildCards
13:48:49 <jumper149> wavemode_: I actually dislike it :D
13:52:00 <dolio> jumper149: Are you sure it isn't just filling in a blank instance? If not, there must be some difference between your situation and StateT as well.
13:53:27 <jumper149> dolio: Wow you are actually right! It really works :)
13:53:49 <jumper149> dolio++ ty
14:12:02 <maerwald> merijn: did you reach your entangled friend?
14:12:17 <ChaiTRex> L29Ah: bracket is the general way to clean up after using something. https://wiki.haskell.org/Bracket_pattern
14:12:26 <ChaiTRex> L29Ah: At least it's one of the general ways.
14:14:02 <monochrom> And finalizers are well known to be procrastinated. Hell, well guaranteed to be.
14:16:17 <monochrom> I wonder if I should start a rumour regarding this, actually. Since people love rumours and hate official docs. May as well spread rumours that favour defensive programming, to balance dominant rumours out there that favour reckless blame-it-on-other-people programming.
14:17:14 <monochrom> My rumour being: If there is no need for GC at all, the program may very well exit without ever calling the finalizer --- not even at exit time.
14:17:53 <monochrom> Just to strike more fear into opportunistic programmers looking for excuses to cut corners.
14:18:13 <monochrom> (Some of my students definitely behave like that.)
14:18:23 <ClaudiusMaximus> +RTS -A30G might help that use-case
14:18:35 <L29Ah> ChaiTRex: yeah but you can return the handle from bracket
14:18:43 <monochrom> You have 30GB RAM?! I envy you!
14:18:58 <dolio> If you exit the program before all GC occurs, then you may lose the uncollected memory permanently.
14:19:13 <dolio> That's why Haskell is terrible and manual memory management is the only way.
14:19:13 <monochrom> :)
14:19:16 <wavemode_> ^ amazing
14:20:22 <monochrom> I really don't understand some of the cases of cutting corners.
14:20:23 <merijn> monochrom: Didactic lying ;)
14:21:08 <merijn> monochrom: I recall Benjamin Pierce referencing part of TaPL being lies, but he's keeping them because they're educational ;)
14:21:39 <merijn> tbh, I feel #haskell sometimes tends to prefer precise, detailed truth over educational lies a bit too much
14:22:19 <monochrom> There are students---let's say when doing C programming homework---who prefer taking 5 minutes typing up "do I really have to call free(p)? here are reasons why I ask:..." to taking 3 seconds coding up "free(p);".
14:22:31 <nshepperd2> if you pull the power from your computer, it's possible your finalizer might not run
14:22:44 <maerwald> merijn: we're all nitpicking INTPs maybe?
14:23:22 <maerwald> nshepperd2: thanks
14:23:34 <L29Ah> burn this filthy socionist
14:24:15 <monochrom> My desktops have UPSes.
14:24:43 <monochrom> But I guess you really mean pulling the connection between UPS and desktop.
14:25:14 <monochrom> My desktop actually has a huge capacitor that can provide one last second of power in that case. :)
14:26:00 <maerwald> what if your house burns down? (maybe an upset student)
14:26:34 <maerwald> did the finalizer run? will we ever know?
14:27:01 <monochrom> No, but we can get even by labelling the arsoner as terrorist. :)
14:27:06 <nshepperd2> note i only say it's possible, because you can't rule out NSA operatives quickly freezing your computer, recovering ram, and resuming your application
14:27:17 <monochrom> arsonist? damn English
14:27:32 <MarcelineVQ> arsoknee
14:27:49 * hackage cpkg 0.2.5.6 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.6 (vmchale)
14:28:35 <maerwald> arsoknot
14:30:16 <monochrom> So why hasn't anyone suggested "if you open up the chassis and yank out the CPU..."? :)
14:30:35 <monochrom> "then the GPU will step in and step up to the challengen!"
14:57:09 <Martin95> Can someone please tell me how to generate the haddock Docs for the base libraries when building ghc?
14:59:49 * hackage circular 0.1.0 - Circular fixed-sized mutable vectors  https://hackage.haskell.org/package/circular-0.1.0 (dschrempf)
15:09:38 <_d0t> ohai! What would be the best way to implement a Generic instance for a GADT?
15:18:09 <mniip> oh no, they left
15:18:28 <mniip> the answer was GhcLibHcOpts += -haddock
15:31:49 * hackage skylighting-core 0.8.5 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.5 (JohnMacFarlane)
15:32:48 * hackage skylighting 0.8.5 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.5 (JohnMacFarlane)
15:48:12 <ErichHyuuga> Troll lives matter! Defund Freenode Staffers!
15:48:22 --- mode: ChanServ set +o monochrom
15:48:23 <ErichHyuuga> This is about limiting the heavy-handed tactics the globalist Freenode Staffer swine use to oppress minorities like trolls on Freenode!
15:48:27 --- mode: monochrom set +b *!*@71.19.249.95
15:48:27 --- kick: ErichHyuuga was kicked by monochrom (ErichHyuuga)
15:48:42 <monochrom> "talk to my hand"
16:32:42 <hyiltiz> Has @xQuasar the troll ever came back? He seemed to have promised. https://gist.github.com/quchen/5280339
16:36:09 <monochrom> No.
16:36:26 <dsal> I just wrote the best code ever:   liftIO (newChan >>= readChan)
16:48:53 <wavemode_> elaborate
16:50:45 <ChaiTRex> dsal: What's it supposed to do? Just block forever?
16:50:52 <dsal> Yeah.
16:51:21 <dsal> It lets me have a 'finally' over a wad of threads my server is running.
16:51:45 <dsal> `dbc <- async $ finally pause (logDebugN "Closing DB connection" >> liftIO (close db))`
16:52:49 <dsal> It's kind of stupid, but I can't use `withConnection` since it'd basically be    `doStuffWith  (withConnection setupAndStart)`
16:54:31 <dsal> The confusing thing is that I abstracted my main out this way so I could write integration tests.  The integration tests are fine, but when I run it in main instead, the DB stuff is all broken.  I don't really want to understand why it works in the test code, but not in the production code.
16:55:41 <dsal> It looks like laziness...  The test code only uses the list on the exit path of the bracket.  The production code immediately calls `waitAnyCancel` -- so subtle
17:14:13 <samiamsam>  
17:44:47 <jumper149> I have type constructor `data A (n :: Nat) = Finite n`. Is it possible to create a sum type like this without the boilerplate: `data NewA = A 0 | A 1 | ... | A 10`
17:46:37 <jumper149> I forgot to add data constructors just now: `data A (n :: Nat) = A (Finite n` and `data NewA = NewA0 (A 0) | NewA1 (A 1) | ... | NewA10 (A 10)`
17:49:36 <wavemode_> with template haskell, sure
17:50:41 <jumper149> wavemode_: Have never used th before. Is there a different way?
18:01:48 * hackage conferer-source-dhall 0.4.0.1 - Configuration for reading dhall files  https://hackage.haskell.org/package/conferer-source-dhall-0.4.0.1 (ludat)
18:03:18 * hackage conferer-snap 0.4.0.1, conferer-hspec 0.4.0.1, conferer-warp 0.4.0.1, conferer-hedis 0.4.0.1, conferer 0.4.1.1, conferer-source-json 0.4.0.1, conferer-source-yaml 0.4.0.1 (ludat)
18:11:17 <wavemode_> jumper149, dunno
18:15:25 <jusss> Nothing :: Maybe a, a could be any type, is this related to kind?
18:15:32 <jusss> higher kind?
18:16:09 <jusss> we give Maybe any type and we get different type
18:16:10 <jumper149> Maybe :: * -> * is it's kind signature I think
18:16:48 * hackage base16-bytestring 0.1.1.7 - Fast base16 (hex) encoding and decoding for ByteStrings  https://hackage.haskell.org/package/base16-bytestring-0.1.1.7 (topos)
18:16:56 <wavemode_> :k Maybe
18:16:58 <lambdabot> * -> *
18:17:24 <wavemode_> Maybe is a type constructor. it receives a type of kind * and produces a type of kind *
18:17:34 <wavemode_> :k Maybe Int
18:17:36 <lambdabot> *
18:18:00 <EvanR> "higher kind" is a weird way to say "type constructor"
18:18:19 <jusss> in value level, we have function, we give it something, it returns something, in type level, we have that?
18:18:22 <EvanR> reminiscent of higher order function
18:18:26 <jusss> type function?
18:18:32 <EvanR> sure
18:18:46 <jusss> like?
18:20:20 <EvanR> all the typing rules for function types carry over pretty much exactly to type constructors
18:20:45 <EvanR> they also use the same symbol (->)
18:27:58 <whataday> data Fix f = Fix (f (Fix f)); Nothing :: Maybe (Fix Maybe), Fix Nothing :: Fix Maybe, why in other languages , they couldn't express Fix Maybe?
18:28:54 <whataday> what make haskell different to others?
18:30:32 <shachaf> Other languages can also do it.
18:30:42 <c_wraith> Scala could.  I think C++ could.
18:32:02 <whataday> and Java or Kotlin?
18:32:11 <c_wraith> No, not them.
18:32:32 <dolio> Java doesn't let you have variables that could be instantiated to Maybe.
18:32:34 <whataday> what features make some can do, some can't?
18:33:00 <c_wraith> a possibly simpler example:  data Foo f = Foo (f Int)
18:34:21 <wavemode_> @define data Fix f = Fix (f (Fix f))
18:34:23 <lambdabot>  Defined.
18:34:27 <wavemode_> :k Fix
18:34:29 <lambdabot> (* -> *) -> *
18:34:49 <wavemode_> you need a language which supports such kinds (or some equivalent)
18:35:40 <whataday> do this such kinds have a name?
18:41:30 <whataday> they can't implement kind with class?
18:44:21 <wavemode_> in most languages where you can define something like `MyClass<T>`, T cannot itself be generic (such that you could do something like `T<V>`)
18:46:32 <wavemode_> though in c++ it's actually doable with template templates
18:48:49 * hackage dataflower 0.2.1.0 - A Pure-Haskell Timely Dataflow System  https://hackage.haskell.org/package/dataflower-0.2.1.0 (jessekempf)
18:49:15 <whataday> you mean T couldn't be T<V>?
18:49:39 <wavemode_> In most languages, no
18:50:06 <Maxdamantus> Rather, `T` can't be applied an argument, because `T` has to be a type.
18:50:15 <Maxdamantus> In Java, all type parameters are actual types.
18:50:46 <Maxdamantus> eg, https://news.ycombinator.com/item?id=21728256
18:51:46 <Maxdamantus> Can't write a proper `interface Monad<M>` because you need to be able to write `M<T>` in the body, since `M` there is not meant to be a type (that is, something of kind `*`), but a function taking a type and returning a type (that is, something of kind `* -> *`)
18:52:35 <Maxdamantus> It might be feasibly possible with some sort of extension of Java that allows you to write something like `interface Monad<M: Type → Type> { .. }`
18:53:32 <whataday> "The only reason it doesn't actually work is because Java doesn't support higher-kinded polymorphism, so you can't pass type-level functions such as IO or List as type parameters, therefore you can't actually write M<T> as appears in the interface body."
18:54:24 <Maxdamantus> Indeed, so `IO` is an example of a type-level function (since it has kind `* -> *` rather than kind `*`, AKA "type")
18:55:01 <Maxdamantus> > undefined :: IO
18:55:03 <lambdabot>  Terminated
18:55:16 <Maxdamantus> > let x :: IO; x = undefined in x
18:55:18 <lambdabot>  Terminated
18:55:25 <Maxdamantus> Hm, weird.
18:55:33 <Maxdamantus> Maybe lambdabot is broken.
18:56:47 <wavemode_> IO is uninhabited. it's not a type, it's a type constructor
18:56:51 <whataday> so in Java, all types only have kind *?
18:57:03 <Maxdamantus> whataday: not really.
18:57:11 <Maxdamantus> whataday: all type parameters have kind *.
18:57:44 <Maxdamantus> whataday: you can think of `List` as being of kind `* -> *` in Java, but you can't pass `List` as a type parameter since all type parameters are kind `*`.
18:58:30 <Maxdamantus> (confusingly, when you write `List` it actually ends up being a "raw type", but that's just a quirky thing that doesn't really make much type theoretical sense)
18:59:52 <Maxdamantus> wavemode_: right. I was expecting lambdabot to say "Expected a type, but ‘IO’ has kind ‘* -> *’".
19:00:24 <whataday> if it can have kind (* -> *) -> *, then it has higher-kinded polymorphism?
19:01:07 <Maxdamantus> Sure. That would be the kind of `Monad` in my hackernews example.
19:01:13 <whataday> Java's type parameter couldn't have kind * -> *, they only can have kind *
19:02:19 <Maxdamantus> Right, so whenever you write interfaces/classes in Java, they end up having kinds like `*`, `* -> *`, `(*, *) -> *`, `(*, *, *) -> *`, etc
19:02:26 <Maxdamantus> and never `(* -> *) -> *`
19:03:40 <Maxdamantus> in the Java kinds that I just listed, you always have types on the left of the arrow and always have a type on the right of the arrow.
19:03:56 <Maxdamantus> s/a type/type/
19:04:23 <whataday> do you know Kotlin's arrow library?
19:04:47 <Maxdamantus> Nope.
19:06:29 <wavemode_> I know it. I don't really like it
19:07:14 <whataday> https://arrow-kt.io/docs/0.10/patterns/glossary/
19:08:07 <whataday> "In a Higher Kind with the shape Kind<F, A>, if A is the type of the content, then F has to be the type of the container." I don't if this is higher-kinded polymorphism?
19:08:41 <whataday> higher-kinded type and higher-kinded polymorphism are same thing?
19:08:59 <Maxdamantus> "higher-kinded type" has always seemed like a misnomer to me.
19:09:20 <Maxdamantus> But I think it has to do with people referring to, eg, `IO` as a "type".
19:09:49 <wavemode_> whataday: no, they're faking higher kinded polymorphism
19:10:11 <whataday> in that case Kind<F,A>, it has kind ((*->*), *)?
19:10:56 <whataday> ((* ->*), *) -> *
19:11:08 <wavemode_> no, Kind is just a type which takes two type parameters. never is F actually applied to A ala `F<A>`
19:11:53 <wavemode_> Kind<F,A> is just a regular generic type, but it's meant to _represent_ F<A>, artificially
19:13:18 <wavemode_> so it's essentially a simulation of higher-kinded polymorphism, in a language which doesn't support it natively
19:14:06 <d34df00d> I just did something like `join $ binaryAct <$> act1 <*> act2`. Is there a nicer way to write this?
19:14:11 <d34df00d> I'm not sure I like this fmap + join thing.
19:15:30 <whataday> use that simulation, could they express Fix<Maybe>?
19:16:43 <boxscape> wavemode_ when you say you don't like it, is that a slight against the library or against the language?
19:16:57 <MarcelineVQ> d34df00d: it's not so bad, that's liftA2 and join rather than fmap and join which is sillier
19:17:18 <wavemode_> oh, I love kotlin. I dislike arrow-kt
19:17:21 <boxscape> I see
19:18:14 <d34df00d> Hmmm, yeah, I think liftA2 would be nicer.
19:18:27 <whataday> wavemode_, could Kotlin express Fix<Maybe> with that simulation?
19:18:50 <whataday> Fix<Maybe, Any>?
19:19:27 <wavemode_> umm well I don't know. since it's a simulation, I suppose it just depends on the limit of one's imagination
19:25:19 * hackage drunken-bishop 0.1.0.0 - An implementation of the Drunken Bishop visual fingerprinting algorithm  https://hackage.haskell.org/package/drunken-bishop-0.1.0.0 (gdritter)
19:43:56 <BobSacamano> Hello all. Sorry if this is too off-topic, but I have a question about pandoc and #pandoc has few people online. I'm trying to use pandoc to convert latex source to html, but I can't get it to show my equation numbers in the html. Anyone here have any tips by any chance?
19:57:36 <whataday> Maxdamantus, wavemode_, could we fake higher-kinded polymorphism in dynamic language like python?
19:59:02 <whataday> I forget class A(B) if we can pass A to C(A)
19:59:23 <Hopplahase> BobSacamano: https://tex.stackexchange.com/q/111868 has some options
19:59:43 <Maxdamantus> whataday: support for higher-kinded polymorphism is only important in static systems. In a dynamic system, you're not having to prove anything about types to a compiler, so you don't need support for particular patterns around types.
20:01:13 <whataday> Maxdamantus, what about fixed-point function in Java, could we implement it? it's on value level not type level
20:01:15 <Maxdamantus> whataday: in a dynamically typed system, you can think of the types however you want, but nothing's going to check that your thoughts are actually sensible.
20:03:32 <Maxdamantus> whataday: the usefulness of a fixed-point pretty much depends on laziness. You can model laziness in Java in such a way that fixed-point functions can make sense, though you won't simply have a method like `<T> T fix(Function<T, T> fn);`
20:08:52 <whataday> Maxdamantus fix = \f -> \x -> f (fix f) x, this lambda could use in Java?
20:09:26 <whataday> fix f = f (fix f); fix f x = f (fix f) x
20:18:57 <Maxdamantus> whataday: no, that function itself would not really be useful in Java, since it would never return (it would just keep calling itself recursively until the stack overflows)
20:19:58 <whataday> but it worked in python
20:20:01 <Maxdamantus> whataday: but you can obviously, eg, write a model for Haskell-style lazy computation, where you have a separate concept of "function" where a `fix` function would make sense.
20:21:28 <Maxdamantus> whataday: oh right, that fix function can be used, sure.
20:21:50 <Maxdamantus> anyway, I don't really think too much about fixed points, so probably not the best person to answer.
21:12:19 * hackage graphql 0.8.0.0 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.8.0.0 (belka)
21:14:18 * hackage commander-cli 0.6.0.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.6.0.0 (sgschlesinger)
21:22:48 * hackage commander-cli 0.6.1.0 - A command line argument/option parser library built around a monadic metaphor  https://hackage.haskell.org/package/commander-cli-0.6.1.0 (sgschlesinger)
23:25:44 <bifunc2> Can you understand basic assembly? Do  you see what GCC is doing to optimize that code? https://godbolt.org/z/nQKHZL
23:25:45 <bifunc2> I'm wondering how I could similarly optimize equivalent Haskell "advancePtr" code myself.
23:54:12 <suzu_> hmm
23:54:19 <suzu_> no expert but it looks like this:
23:54:41 <suzu_> first it checks if 'factor' is zero. if so, it returns immediately from the function and doesnt ever enter the loop
23:54:51 <suzu_> thats the test esi, esi and jle instruction
23:55:32 <suzu_> then movsx .. to the last 'lea' set up the destination pointer to write to
23:55:43 <suzu_> .L3 is where the loop begins
23:56:13 <suzu_> it copies 'dl' into the target memory address, [rax]
23:56:21 <suzu_> then increments the target memory address by 8
23:56:59 <suzu_> if the target is equal to the upper limit memory * 8 * factor * offset, then it will abort the loop. thats the cmp and jne
23:57:31 <suzu_> and thats the function
23:57:40 <suzu_> bifunc2 ^
23:59:54 <bifunc2> suzu_ hmm ok so the entire loop is actually performed, and the only optimization is that it's on the L3 cache?
