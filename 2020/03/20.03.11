00:05:08 <acubakari> ski: why did you say no to currying as a byproduct of the fact that functions can have only one parameter?
00:06:36 <ski> currying comes later, conceptually speaking, not before talking about functions as having one parameter
00:08:46 <ski> "curried style" and (as one might perhaps call it) "tupled style" are about how one can represent multiple-parameter function in Haskell, which only has single-parameter functions
00:09:17 <ski> "curried style" (and "tupled style") are in your mind, not in Haskell. Haskell doesn't have "curried functions"
00:09:51 <ski> "currying" means changing to "curried style"
00:11:12 <acubakari> ski: yeah I agree thanks
00:20:09 <acubakari> Can I use haskell with ROS instead of python or C++?
00:20:33 <acubakari> ROS is Robot Operating System
00:23:46 * ski has no idea about ROS
00:24:33 <opqdonut> acubakari: it's just a matter of having haskell bindings for the ros libraries, it looks like somebody tried something in 2015: https://hackage.haskell.org/package/roshask
00:26:09 <acubakari> opqdonut: thanks I'll check it out
01:12:04 <bahamas> hello. I want to interact with the digitalocean API, so I need to use an http client. this thread recommends using servant. how involved is that? is it worth taking this approach? https://www.reddit.com/r/haskell/comments/6ra2sv/which_libraries_should_i_use_for_writing_a_simple/
01:12:48 <Rembane> bahamas: Servant is very involved if you aren't very familiar with type level programming in Haskell already. 
01:13:31 <Rembane> bahamas: I recommend req: https://hackage.haskell.org/package/req-3.1.0#readme
01:15:46 <bahamas> Rembane: I see. why req over wreq?
01:16:52 <bahamas> a, I see the readme covers that
02:03:53 * hackage dobutokO2 0.7.2.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.7.2.0 (OleksandrZhabenko)
02:12:23 * hackage xeno 0.4.1 - A fast event-based XML parser in pure Haskell  https://hackage.haskell.org/package/xeno-0.4.1 (ocramz)
02:15:24 * hackage dobutokO2 0.7.2.1 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.7.2.1 (OleksandrZhabenko)
02:33:54 <AWizzArd> In our web server we have several types that describe a reply in json. We like to document the json inputs and outputs to every route. Is there some way to compile a documentation automatically out of the source code, so that the docs are always up-to-date?
02:34:18 <AWizzArd> Or are some kind of automated tests the best way to create a strong coupling between the documentation and the code?
02:36:30 <__monty__> AWizzArd: I *think* swagger does something like this?
02:37:26 <Rembane> AWizzArd: Is the server written using Servant? 
02:48:15 <bahamas> I want to define a sum type to cover all of the values for the size of a digital ocean droplet. how do I convert each value to the corresponding size slug? do I define a function with pattern matching or is there some typeclass for this?
02:49:50 <veverak> hi folks
02:50:01 <AWizzArd> Rembane: yes, Servant
02:50:28 <veverak> I am slightly confused with the API around 'Handle' (stdout/stderr of process in my case) -> how to properly write a function that reads one line from handle if available? (and does not block if not available)
02:50:39 <AWizzArd> __monty__: okay, will have a look and see what this Swagger thing is doing.
03:05:59 <merijn> veverak: That...is a hard question if interpreted exactly as formulated
03:06:21 <veverak> I had a hack for this with subthread
03:06:25 <veverak> but I deleted the file :/
03:06:51 <merijn> veverak: You can't check if a line is complete, because file descriptors and handles don't have an API for that
03:07:20 <merijn> veverak: You can use hGetSome to check if there is some data available and read it, but that still blocks on no data
03:08:00 <veverak> hmm
03:08:07 <veverak> merijn: ok, I will try to reconstruct my thread hack
03:08:17 <merijn> Or hGetNonBlocking, but none of those will guarantee to read a line
03:08:24 <merijn> veverak: What are you trying to do?
03:08:41 <merijn> And why are you trying not to block?
03:09:45 <veverak> the app executes process (gcc) and wants to read it's output and show it to the user as the process generats it
03:10:09 <merijn> veverak: You can let subprocess write directly to your stdout
03:10:22 <merijn> Then you can skip all this
03:10:31 <veverak> nope
03:10:45 <veverak> it shows the output, but not simply printing it
03:10:53 <veverak> there is processing done
03:12:56 <merijn> veverak: Still doesn't really explain why you can't block, though?
03:13:40 <veverak> it is TUI app written with Blocks, I want to control it while gcc is executed
03:15:36 <merijn> veverak: So just run gcc from a different thread and block there?
03:17:53 <veverak> that's what I used to do
03:17:57 <veverak> trying to recreate it now
03:18:26 <xintron> Looking to decode and encode types into a binary network protocol. Each packet contains a fixed size but the fields within a packet have different formats like "var max 16" which would indicate that the string can be max 16 bytes or shorter and would in that case be null terminated. Would the binary package be a good fit here or should I look at
03:18:26 <xintron> attoparsec for this type of decoding/encoding?
03:19:01 <Guest2525> Great
03:19:06 <Guest2525> it seem to work
03:19:40 <merijn> xintron: binary seems perfectly fine
03:20:38 <merijn> xintron: Although, make sure to use the explicit Get/Put modules, not the Binary typeclass, because the typeclass uses its own serialisation format
03:22:58 <xintron> merijn, ok. Been looking into it a bit (used to attoparsec from before for text parsing). Seems like it's lacking some nice to have functions such as `takeWhile` etc which would come in handy for parsing until null. On the other hand, should be easy enough to implement helpers for that with binary
03:25:45 <merijn> xintron: I mean, either works, binary has slightly better support for parsing stuff like serialised words/doubles, though
03:45:24 <kuribas> ugh, lsp is so utterly broken, it's better not to use it all.
03:45:29 <kuribas> in emacs at least
03:45:57 <kuribas> the stuff it adds to my usual workflow (like meta-.) doesn't work most of the time
03:46:15 <kuribas> And it breaks what was working before with just flycheck-mode.
03:48:11 <kuribas> It least I gave it a try, and know I am not missing anything at this moment.
03:48:22 <kuribas> Hopeful they keep working on it until it's useable.
03:50:48 <veverak> merijn: if you are interested
03:50:51 <veverak> merijn: https://github.com/SquirrelCZE/cmplhs/blob/master/src/SideProc.hs
03:51:01 <veverak> merijn: readLines uses subthread, readLines2 is simple blocking approach
03:54:01 <veverak> but there should be better way to do it
03:58:05 <veverak> I mean, it can obviously kill the thread after the line was read and before it was inserted into mvar
03:58:10 <merijn> veverak: Why is it reading only one line at a time? I'd just spawn a thread that reads as many lines as possible, then exits and have the other thread read until then
03:58:30 <merijn> And if you want to manage the lifetime of threads more easily there's the async package
03:59:44 <veverak> was reacreating it out of memory, yeah reading more lines would be better
03:59:50 <veverak> hmm, I will look into the async thing
04:00:17 <veverak> generally... I could have one thread for reading spawned pernamently and only use native sync. tools from haskell
04:00:21 <veverak> (not creating it every time)
04:13:20 <np356> Hello there, is there a way to simplify this expression?:    "token <- issueSecurityToken $ fromJust (fromJust (creds :: Maybe (Maybe Credentials)))"
04:13:35 <np356> I don't like the double fromJust there, seems not very elegant
04:16:15 <ski> @type fromJust . join
04:16:17 <lambdabot> Maybe (Maybe c) -> c
04:16:42 <ski> why do you have double `Maybe's ?
04:16:56 <idnar> np356: I guess you are doing something like `f x` to build `creds`; you can do `f <$> x` or `fmap f x` to get `Maybe Credentials` instead
04:17:05 <ski> what should happen, in case of `Nothing' ? are you sure you shouldn't be handling those cases more properly ?
05:06:03 <AWizzArd> Rembane: I see that Servant has this Docs module. Looks good, thx for the tip!
05:11:59 <zincy_> Is case analysis an anti pattern if you can hide it behind say `either`
05:12:36 <merijn> Trying to find simple rules to avoid thinking about what you're doing is an antipattern :)
05:13:27 <[exa]> zincy_: sometimes it's superuseful if you apply the `either` deconstructor partially. Otherwise an explicit patternmatch may be more readable
05:15:11 <zincy_> What do you mean by partially?
05:15:29 <zincy_> Ok so both can be good depending on the circumstances
05:15:56 <ski> `foo . either bar baz . quux'
05:16:01 <zincy_> I guess when you get into <<$>> then maybe you are better with explicit case analysis
05:16:19 <ski> @hoogle (<<$>>)
05:16:20 <lambdabot> Data.Biapplicative (<<$>>) :: (a -> b) -> a -> b
05:16:20 <lambdabot> Data.Bifunctor.Apply (<<$>>) :: () => (a -> b) -> a -> b
05:16:20 <lambdabot> Protolude (<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
05:16:21 <zincy_> ski: Ok partially applied
05:16:29 <[exa]> :t 0 `maybe` (+1)
05:16:31 <lambdabot> Num b => Maybe b -> b
05:17:18 <zincy_> :t fmap . fmap
05:17:20 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
05:17:35 <zincy_> Yeah the partial application there is very nice
05:17:58 <ski> @type zipWith . zipWith
05:17:59 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
05:18:38 <[exa]> zincy_: also, I've had several nice functions where either was used as 'either squashLeftSomehow' for handling various forms of exception-style problems
05:19:01 <[exa]> ski: wow that I see the first time. :D
05:19:39 <ski> @type liftA2 . liftA2
05:19:41 <lambdabot> (Applicative f1, Applicative f2) => (a -> b -> c) -> f1 (f2 a) -> f1 (f2 b) -> f1 (f2 c)
06:02:19 <lhurttila> Are there any ways to sort an infinite data structure? I'm thinking it might be possible if I somehow traverse it piece by piece
06:05:10 <lyxia> not without any assumptions because you can't ever know whether an element is the maximum
06:08:05 <lortabac> even if you know what the maximum is, I don't see how it would be possible
06:08:31 <Putonlalla> :t infinisort
06:08:32 <lambdabot> [()] -> [()]
06:08:57 <Putonlalla> Works every time.
06:09:16 <merijn> You can't make comparison sort work on infinite data
06:09:21 <merijn> But discrimination sorts can
06:09:38 <merijn> It depends on the structure of your data
06:13:21 <lhurttila> Yes you'd need some assumptions but assuming you could make those? Suppose you're counting a points distance between another points on an infinite 2d plane. Couldn't you sort those points by their distances if you traverse the plane in an iterative way reaching out from the original point?
06:26:15 <lyxia> anything's possible with sufficient information, but you can be less vague with your questions.
06:29:18 <lhurttila> Didn't know if there existed a way to sort infinite data stuctures to begin with, hence the more general question first
06:32:54 <jasagredo> If this is not the proper place to ask this, please point me to the right place, thx.
06:33:00 <jasagredo> Suppose we have two newtypes `A` and `B` that both are instances of class `C`. Then we have another type `T x` where `x` can be either `u` or `v` and we use deriving via to make the following derivations:```deriving via A instance C (T u)deriving via B instance C (T v)```When using a function in the typeclass `C` running in the scope of `T u`, I'm
06:33:01 <jasagredo> experiencing a deadlock somewhere. I added `trace` statements in both implementations for such function and none of them are being triggered. Moreover, when running in `ghci`, the debugger reaches the statement just before the call to that function and when doing `:step` it suddenly hangs indefinitely. Could someone explain what is going on?
06:38:51 <lyxia> what are the actual instances like? do they have any constraints that could be resolved circularly?
06:39:15 <lyxia> in "T u" and "T v", are u and v literally variables or something else?
06:40:32 <jasagredo> `u` and `v` are concrete types, maybe I should have written them in capital letter
06:42:20 <lyxia> are you sure the loop has to do with instances, rather than the implementations being circular (as in accidentally using a variable being defined)
06:44:26 <jasagredo> Using concrete examples, we could say that we have two newtypes `DiskImplementation` and `MemoryImplementation` that both are instances of the class `CanDoX`. Then we have another newtype `Implementations x` where `x` can be either `Memory` or `Disk` (with both declared as empty datatypes). When being inside a `Implementations Memory` scope and
06:44:26 <jasagredo> calling a function from `CanDoX` it freezes. I added `trace` statements in both implementations of the function so even if the implementations were circular, it should print those statements.
06:45:15 <jasagredo> That's why I suspect it is related with the instances. And also ghci should be able to enter the called function but it just freezes
06:48:00 <lyxia> can you show the code?
06:49:19 <jasagredo> The code belongs to my company and I can't show it, that is the bad part
06:58:10 <jasagredo> If the declaration of the instances was circular at some point shouldn't the compilation fail?
06:58:48 <merijn> jasagredo: No
06:58:48 <maerwald> merijn: have you done static linking on mac? You use mac right? 
06:58:57 <merijn> maerwald: Not yet
06:59:04 <merijn> It's on my todo list to figure out
06:59:09 <maerwald> Does nix work reasonably well on mac? 
06:59:22 <merijn> maerwald: does it work reasonably well anywhere?
06:59:26 <maerwald> Lol
06:59:30 <lyxia> jasagredo: do none of your four instances have constraints?
06:59:40 <merijn> maerwald: I don't use Nix, so no idea
07:00:08 <maerwald> There are some projects that try to solve the static linking with nix for haskell. But none of them worked for me
07:00:23 * hackage HPi 0.7.0 - GPIO, I2C and SPI functions for the Raspberry Pi.  https://hackage.haskell.org/package/HPi-0.7.0 (WJWH)
07:00:30 <jasagredo> They do have constraints. I can try to do a scheme on how it is structured, one sec
07:02:18 <maerwald> https://github.com/nh2/static-haskell-nix/issues/85
07:08:57 <sm[m]> nix does not work on mac catalina out of the box, you have to do some shenanigan
07:11:58 <jasagredo> lyxia: something like this
07:11:59 <jasagredo> https://repl.it/repls/GrowingWrithingAssembler
07:13:57 <Jana08> So what is field of study where they describe how or and and works in functional terms?
07:14:34 <Jana08> In abstract terms
07:15:26 <maerwald> sm[m]: it's also hard to get hold of a VM
07:15:29 <maerwald> So... 
07:15:29 <Jana08> I imagine it pertains to proving that functional language is Turing complete
07:15:30 <ski> hm, maybe you mean "logic", Jana08 ?
07:15:46 <ski> "functional terms" being ?
07:16:21 <sm[m]> maerwald: you need a mac vm ?
07:16:37 <maerwald> Well, anything to build static executables there
07:17:08 <sm[m]> vps, rather ? I heard of macstadia / macstadium (used by github CI; or, you could just use that)
07:18:45 <Jana08> Ski: something closer to logic Gates and not languages for example you need just 4 kinds of logic Gates/functions to be Turing complete but some functions become obsene strings of those 4 gates comprising machine
07:19:45 <ski> hm, talking about combinatorial circuits ?
07:20:41 <jasagredo> I had some success in the past compiling static binaries in Haskell in Mac OS maerwald. 
07:20:50 <jasagredo> You just need a GHC with `-fPIC` enabled
07:21:07 <boxscape> Jana08 https://en.wikipedia.org/wiki/Functional_completeness
07:21:07 <ski> hm. if you're talking about types, then you can use product types (records), sum types (variants), and negation types (continuations) to express computation
07:21:21 <AWizzArd> I see that after updating (in Emacs) haskell-mode and intero my prompt looks very strange: ^[>^[=λ 
07:21:27 <AWizzArd> Anybody else has/had this issue as well?
07:22:10 * ski thinks Jana08 is maybe asking about functional programming languages like e.g. Haskell
07:23:56 <lyxia> jasagredo: if you use DiskImplementation and MemoryImplementation on their own, does that still loop?
07:23:59 <Jana08> No, field of study, I didn't know what channel to go to
07:24:23 <Jana08> Here supposedly academic
07:24:41 <ski> oh, ok
07:25:51 <Jana08> I'm asking because I saw a talk that went over how not, or, and works in terms of simple things like identity and stuff
07:26:08 <ski> hm
07:26:18 <Jana08> Turns identity isn't useless as far as logic goes
07:26:45 <ski> still not sure whether you're talking about logic, Boolean algebra, types, or something else
07:26:52 <jasagredo> lyxia this is a bit complicated to check, but I will try
07:28:34 <[exa]> Jana08: generalizations of propositional logic perhaps?
07:55:31 <remexre> hm, is there a nice way to do (!!) on a DataKinds list, such that out-of-bounds -> type error?
07:56:44 <boxscape> remexre I think you should be able to convert the usual (!!) explicitly recursive definition into a type family and then use a custom type error from here on the empty case https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:TypeError
07:57:02 <boxscape> (closed type family)
07:57:22 <remexre> hm, I'll try that, thx
08:06:23 * hackage plugins-multistage 0.6.3 - Dynamic linking for embedded DSLs with staged compilation  https://hackage.haskell.org/package/plugins-multistage-0.6.3 (AndersPersson)
08:09:51 <maerwald> jasagredo: how portable are they across mac releases 
08:13:06 <jasagredo> That I really don't know
08:13:10 <jasagredo> maerwald
08:15:16 <maerwald> Is musl linking possible? 
08:24:15 <jasagredo> I wasn't able to link it with musl
08:24:36 <remexre> is there a good/stable way to use doctest to test error messages, while ignoring e.g. which line GHCi is on
08:24:49 <frdg> (^) 10 $ 1 + 1    Im confused on why this returns 100. To me the answer should be 2^10
08:25:07 <merijn> frdg: No, it's 10 ^ 2
08:25:10 <remexre> frdg: (^) 10 = (\x -> 10 ^ x)
08:25:24 <remexre> you might be thinking (^ 10) = (\x -> x ^ 10)
08:25:44 <remexre> http://wiki.haskell.org/Section_of_an_infix_operator
08:25:57 <frdg> ok thank you
08:26:52 <phadej> remexre: use ...
08:27:19 <phadej> See Matching arbitrary output in doctest README
08:27:43 <remexre> ah, neat, missed that scrolling thru
08:29:10 <phadej> See e.g. https://hackage.haskell.org/package/servant-0.17/docs/Servant-Links.html
08:29:36 <phadej> it becomes tricky if you want to make doctest for error messages work for multiple GHC versions
08:31:42 <remexre> yeah... I guess I'll include a note in a comment about it being somewhat fragile
08:34:05 <markeg> ~/quit
08:46:51 <FooBar008> @help
08:46:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:47:19 <frdg> 2 ^ 2 * 4 ^ 5 + 1    to me this should equal 1029. This seems like basic pemdas. 
08:47:51 <frdg> oh wait 
08:47:58 <frdg> haha I made a mistake 
08:48:17 <Taneb> 4097, right?
08:48:18 <sshine> 4097 you mean? ;)
08:49:54 <int-e> Hmm, trying to reconstruct the mistake: 2^2 + 4^5 + 1 = 1029
08:50:38 <frdg> ^
08:52:53 * hackage holmes 0.2.0.0 - Tools and combinators for solving constraint problems.  https://hackage.haskell.org/package/holmes-0.2.0.0 (i_am_tom)
08:55:56 <jasagredo> lyxia I am not able to test it directly to the underlying monads but I got something interesting
08:56:25 <jasagredo> In the snippet I sent you, there were two classes `DoSth` and `DoSthMore`. They are both derived for the final type in the same way
08:57:04 <jasagredo> Surprisingly, calling functions from `DoSthMore` in the same scope as before works but functions from `DoSth` hang indefinitely
09:00:05 <hexagoxel> Is there an existing type family that maps 'Bool to Constraint? There is (x ~ 'True), but you get useless error messages out of that.
09:01:03 <hexagoxel> Probably need to take a GHC.TypeLits.ErrorMessage as an argument to that type family, to get useful error message in there.
09:03:57 <jle`> hexagoxel: yup
09:04:27 <boxscape> Could you make a type-level version of unsafeCoerce with the means that ghc provides?
09:04:41 <jle`> hexagoxel: er, i misread your message
09:04:42 <jle`> no there isn't
09:05:44 <phadej> type-level unsafeCoerce, reintepret a type as a type of another kind?
09:05:49 <boxscape> yes
09:06:44 <jle`> unsafeCoerce False ~ Nothing
09:06:56 <jle`> whoops pressed enter instead of backspace
09:07:00 <jle`> UnsafeCoerce 'False ~ 'Nothing
09:07:31 <mniip> you cannot make that using haskell
09:07:38 <boxscape> okay
09:07:41 <mniip> but what you can do is craft a custom interface file
09:07:47 <jle`> you can probably make it using a typechecker plugin
09:07:50 <mniip> that would contain a type family with an equation
09:07:50 <boxscape> ooh, interesting
09:08:35 <jle`> hm, actually i'm not so sure you can make it using a typechecker plugin
09:11:45 <jle`> although technically you can make a typechecker plugin say `UnsafeCoerce x ~ y` for all x and y
09:11:50 <jle`> and it wouldn't be wrong ...
09:11:54 <boxscape> hm, okay
09:12:10 <jle`> you can also make `type family UnsafeCoerce a where {}` and it also wouldn't be wrong
09:12:12 <jle`> hehe
09:12:34 <jle`> it would only be wrong if you wanted it to match the term-level unsafeCoerce for lifted kinds
09:12:50 <boxscape> having an empty type family like that seems kind of like doing `unsafeCoerce = const undefined`?
09:13:12 <jle`> not quite since it won't be 'bottom'
09:13:44 <jle`> hm. i guess it sort of behaves like it in some sort of way, since any time you try to use it you won't be able to match on it
09:14:09 <jle`> actually yeah my ideas don't really work. they only address equality, and not how you would actually use it when applied to something
09:14:49 <boxscape> (IIRC the empty type family above without the a parameter is exactly how Undefined is defined in singletons)
10:36:22 <Darwin226> Hey guys. Is there a way to implement swapOrPutMVar :: MVar a -> a -> IO (Maybe a) that doesn't block?
10:36:25 <fog> so should I have a synonym of function arrow -> in the Datatype (representation of datatypes...)
10:36:49 <fog> otherwise all the leafs are just Symbols
10:37:09 <fog> which seems fine if Datatypes are just composed of other Datatypes
10:37:30 <fog> but if they are supposed to also be able to have functions as the type of values stored at the leafs
10:37:53 <fog> then I need a special leaf that takes an input and return type
10:37:59 <fog> which is basically just ->
10:39:02 <fog> "all haskell datatypes are built up as nested Sum and Products, or functions , of atomic datatypes (Symbol labeled Void) 
10:39:26 <fog> so i wouldnt be able to have functions stored within Datatypes if I just used Sum and Product
10:39:27 <ski> `Void' is a sum
10:39:41 <fog> well, an empty sum...
10:39:56 <fog> or an empty product?
10:40:59 <fog> I was thinking to have the Tree use nonempty, but if I have HList that can be empty eg for Product, and the same for Sum, then I can use Fix instead of Free...
10:41:17 * ski has no idea what data type fog is talking about
10:41:45 <fog> oh, im trying to represent "Datatype" to be an extensible version of haskell datatypes
10:43:04 <ski> are you building a language implementation or processor of some kind ?
10:43:25 <fog> so thats hetrogenous Sum types, of hetrogenous Product types (HLists) that are nested, ie, the values that are contained within the Sum of Products are themselves Datatypes
10:43:50 <fog> ski, Datatype is a datatype
10:44:07 <ski> `data Datatype = ...' ?
10:44:08 <fog> it has opperations to insert and delete
10:44:36 <fog> yes, something like that, built from Sum (Var) and Product (HList)
10:45:00 <ski> hm. i wonder what the point of this is
10:45:09 <fog> to have extensible datatypes
10:45:13 <fog> "trees that grow"
10:45:27 <fog> with typelevel machinery to go with it
10:46:51 <fog> eg I had this; https://gist.github.com/fog-hs/4c9eea008358b6d3de20628f9f968278
10:47:00 <fog> where you can filter a HList
10:47:47 <fog> here is my Sum type; https://gist.github.com/fog-hs/b5a4a92dcd8c4a77b4be7dda62b8ecb0
10:48:26 <fog> and an example of it being filtered; https://gist.github.com/fog-hs/3258620036741a4549e99115b5b6c397
10:48:55 <fog> and here is a HTree; https://gist.github.com/fog-hs/4ae0d13122a57d4dd472021b6f6c6b05
10:50:33 <fog> the question is about including functions aswell
10:50:45 <fog> so its not just Free (Sum . Product)
10:51:13 <fog> because it needs to have the option of a special kind of Pair product type to represent functions
10:53:00 <ski> hm. i wonder what the point of this is
10:53:05 <ski> er, sorry
10:53:20 <fog> :-?
10:53:39 <ski> (resent same message, by mistake)
10:54:59 <fog> ooh, I wonder what message you were going to send instead!
10:55:01 <merijn> mpickering: <3 I just finally got around to trying hs-speedscope and ghc 8.10's stuff and the detail compared to previous profiling is amazing
10:56:08 <fog> i guess the function arrow appears as an Either on the contents of the HLists that are the options of the Sum type
10:56:40 <fog> so its Either Datatype (Datatype -> Datatype)
10:57:10 <fog> thats the Free recursion, with option also for Void at the leafs
10:57:43 <jle`> Darwin226: what do you want to happen if the mvar is empty vs. when it is full?
10:58:11 <fog> so if i had EitherF d = Either d (d -> d), then type Datatype = Free (Sum . Product . EitherF) Void
10:59:00 <fog> obviously with some mind boggling way to handle the parameters
11:00:22 <fog> the alternative actually is to have these parameters contatining haskell types, instead of just the args to build equivalent types using the Datatype machinery
11:00:58 <fog> yeah, that sounds like a better option, then functions just appear as regular types at the leafs
11:01:14 <fog> thought there should be some way to translate everything into Datatype...
11:02:12 <fog> and that version would need this EitherF thing
11:03:23 * hackage configurator-pg 0.2.1 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.1 (vollmert)
11:03:42 <fog> my head hurts...
11:05:53 <jle`> why not just like ... type that into a personal journal or something heh
11:06:15 <jle`> if you're just going to log in and type out a few paragraphs of strema of thought and then log out
11:11:56 <MarcelineVQ> just in case someone responds. which I've regretted each time. at the very least start with context.
11:12:27 <MarcelineVQ> if you're going to spew, spew something people don't have to ask about to ask about
11:18:12 <sm[m]> merijn: cool, any example output you could share, or more detail of what that means ?
11:19:33 <sm[m]> this is compared to.. ghc-heap-view ?
11:19:35 * Lycurgus spews bernie regrets or sang froid oder etwas
12:28:12 <fog> sure people should be encouraged to ask questions
12:28:40 <fog> to address the "why do we want extensible datatypes" question
12:29:18 <fog> i could have a database, eg, logging the prices of some stock exchange.
12:29:37 <fog> then, when the exchange adds a new company, I would need to add to my datatype
12:29:57 <fog> its good if aswell as adding data, i can perform opperations which change the datatype
12:31:26 <fog> the "lack of context" comment could also be interpreted in terms of the question which was to do with having functions, not just Sum and Product, as part of the representation of an extensible datatype 
12:31:38 <fog> which is what we were talking about the other day
12:39:23 * hackage zip 1.4.0 - Operations on zip archives  https://hackage.haskell.org/package/zip-1.4.0 (mrkkrp)
12:55:02 <maralorn> makeFields
12:55:04 <maralorn> Why is there no Multiple classes per data type
12:55:06 <maralorn> equivalent for Prisms?
13:05:34 <maralorn> Can someone explain to me what this error means: "Cannot redefine a Name retrieved by a Template Haskell quote:"?
13:09:16 <monochrom> No, people should not be encouraged to "ask questions" unless we further qualify the questions to be asked.
13:09:57 <monochrom> And/or even the target of the asking.  E.g., asking yourself is certainly encouraged.
13:11:27 <MarcelineVQ> maralorn: that wasn't directed at you :>
13:11:30 <monochrom> For examples it looks like in most courses that use Piazza for their course forums, most questions asked there demonstrate lack of due diligence, and should be discouraged.
13:12:11 <monochrom> This is what's wrong with the political correctness surrounding "there are no dumb questions".  Piazza proves that they exist in abundance.
13:12:39 <maralorn> MarcelineVQ: What is not directed at me? ^^
13:14:11 <MarcelineVQ> monochrom's aside on questions appearing when you asked a question
13:14:35 <maralorn> Yeah, I figured.^^
13:15:36 <monochrom> No no no, it's for fog's self-serving "people should be encouraged to ask questions".
13:15:49 <monochrom> Yes, it was clearly self-serving.
13:38:14 <infandum> How can I have a tempfile stay around? Not get deleted? I lik that there is a random name generated with a base.
13:39:30 <MarcelineVQ> how are you generating it?
13:40:27 <infandum> mktempfile from Turtle
13:45:47 <maerwald> infandum: https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Temp-ByteString.html
13:47:02 <infandum> maerwald: Thank you!
13:50:42 <phadej> or https://hackage.haskell.org/package/temporary-1.3/docs/System-IO-Temp.html to be more cross-platform
13:52:12 <maerwald> Is it? Deleting files on windows can fail in weird ways (e.g. because virus scanner is locking them)
13:52:56 <maerwald> Most libs don't do anything special on windows
13:54:01 <maerwald> https://github.com/haskell/directory/issues/96
13:56:11 <phadej> chances are higher that `temporary` works on Windows than that `unix` works there :)
13:56:25 <maerwald> You mean it compiles and does *something* ;P
13:56:37 <phadej> also, going from `turtle` to `unix` might be a bit too long jump
13:57:27 <maerwald> Easiest solution: just shell out and run mktemp :P
13:57:37 <phadej> except that doesn't work on Windows either
13:57:50 <maerwald> infandum: are you running your code on windows?
13:58:37 <phadej> it's irrelevant, you shouldn't go for lowest-level solution if you don't need to
13:58:46 <phadej> and often enough you don't
13:59:03 <phadej> hspec-core, tasty, stack use `temporary`
13:59:13 <phadej> so I guess it works well enough (also on Windows)
13:59:53 <phadej> and in fact, turtle itself
14:03:53 * hackage icepeak 0.7.2.0 - A fast JSON document store with push notification support.  https://hackage.haskell.org/package/icepeak-0.7.2.0 (rkrzr)
14:11:53 * hackage mmsyn7h 0.7.3.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.3.0 (OleksandrZhabenko)
14:16:23 * hackage mmsyn7h 0.7.3.1 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.3.1 (OleksandrZhabenko)
14:19:53 * hackage mmsyn7h 0.7.4.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.4.0 (OleksandrZhabenko)
14:32:31 <merijn> sm[m]: Oh, this is nothing like the heap viewer, but the stuff he worked on to make speedscope.app work
14:32:39 <merijn> sm[m]: See: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
14:58:23 * hackage mmsyn7h 0.7.5.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.7.5.0 (OleksandrZhabenko)
15:01:38 <fog> before, I was describing an approach to representing haskell datatypes as a datatype.
15:07:12 <fog> trying to answer a previous question, which was since all datatypes *cannot* be decomposed into sums of products of datatypes, as this does not capture functions.
15:07:25 <fog> where the answer is to allow arbitrary types at the leafs
16:50:53 * hackage arithmetic 1.6 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.6 (JoeHurd)
16:54:53 * hackage ghc-lib-parser-ex 8.8.5.4 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.4 (shayne_fletcher)
16:59:53 * hackage factor 1.0 - Factoring integers  https://hackage.haskell.org/package/factor-1.0 (JoeHurd)
17:00:55 <d34df00d> Why, a function is just a list of pairs.
17:12:40 <ysangkok> only if lists can be infinite
17:13:34 <Axman6> @src []
17:13:35 <lambdabot> data [] a = [] | a : [a]
17:13:47 <Axman6> Looks like they can be, phew!
17:15:59 <ysangkok> only if lists allow random-access :P
17:18:17 <ysangkok> wait, didn't a recent ghc release fix a bug where a type exists in the type system but wasn't expressable in the syntax?
17:18:25 <ysangkok> i guess that also breaks the statement 
17:25:02 <ysangkok> hmmm can't find it in the ghc blog...
17:29:48 <d2ci8xc5> does there exist some resource/cheatsheet that has the laws that the typeclasses hold? example for Applicitive pure id <*> a = a
17:30:26 <d2ci8xc5> I'm just being a bit lazy and haven't written them all down as I go along
17:30:35 <Axman6> doe the typeclasopeadia have them?
17:31:02 <Axman6> https://wiki.haskell.org/Typeclassopedia
17:31:03 <MarcelineVQ> the typeclass documentation will mention the laws
17:31:43 <d2ci8xc5> oh right. thanks
18:00:24 * hackage hw-uri 0.2.1.0 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.2.1.0 (haskellworks)
18:04:42 <lupulo> could you use haskell with spark?
18:04:49 <lupulo> apache-spark
18:04:53 * hackage objective 1.2 - Composable objects  https://hackage.haskell.org/package/objective-1.2 (FumiakiKinoshita)
18:07:28 <koz_> lupulo: https://github.com/tweag/sparkle#readme
18:08:03 <lupulo> koz_, lol
19:19:23 * hackage rattletrap 9.0.8 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.8 (fozworth)
19:44:06 <slack1256> Hello, to get really good at profiling memory allocations on haskell I have to compile all the way onto STG or with Core is enough?
19:58:49 <koz_> I'm using microlens, and I'm calling down a Map a b with 'use': http://hackage.haskell.org/package/microlens-mtl-0.2.0.1/docs/Lens-Micro-Mtl.html#v:use . Now, what I wanna do is 'call down the Map from inside my state, then do a lookup in it'. How do I phrase this properly?
19:59:19 <koz_> I'm guessing it's something like 'result <- use _', but I am not sure what goes in the _.
19:59:33 <koz_> I have a Lens' for going from state type to Map.
19:59:43 <koz_> But I dunno how to combine it with ix, which I guess is what I'm after.
20:02:00 <koz_> Never mind, I think I want 'at'.
20:02:23 <jackdk> koz_: use $ lensToGetTheMap . at key
20:02:29 <jackdk> er, yeah
20:03:01 <koz_> Ah, yep, that did it. Thanks! Seems I was after the wrong operator lol.
20:08:18 <jackdk> ix gives you a traversal to that index, which often isn't powerful enough to do what you want. at gives you a lens to Maybe the value there, and lets you create by setting it. I have often used at and never used ix
20:08:44 <koz_> Ah, OK.
20:08:46 <jackdk> ix is useful for things like lists, I guess, but I've never needed to use it
20:09:42 <koz_> Fair enough. Still a bit new to lenses.
20:10:01 <koz_> (very convenient when you have 'MonadState SomeGiantRecord m' hovering around)
20:11:03 <jackdk> also good when you have MonadReader SomeGiantRecord (the combinators in lens and I suppose microlens-mtl too are written in terms of MonadReader s m, so they specialise to functions s -> a as well as reading from your MTL stack)
20:11:13 <solonarv> yeah, lenses + MonadState is very pleasant to use
20:11:35 <koz_> I happen to have (MonadReader SomeGiantRecord m, MonadState SomeOtherGiantRecord m).
20:11:45 <jackdk> well, there you go
20:11:46 <koz_> The best of both worlds!
20:11:48 <solonarv> you can even sprinkle some spicy 'Zoom' / 'Magnify' on top :D
20:12:38 <koz_> solonarv: What do those do?
20:13:47 * koz_ just imagined solonarv as the Spiffing Brit.
20:14:25 <koz_> "HELLLOOOOO ladies and gentlemen, I am the Spiffing Brit, and today we will be playing with lenses. These are a fantastic and perfectly-balanced way to interact with MTL-style transformer stacks."
20:14:35 <koz_> [insert jokes about British Empire and Yorkshire Gold tea]
20:18:00 <koz_> Do any monad transformers implement MonadFail?
20:19:18 <jackdk> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Except.html#t:ExceptT
20:19:37 <jackdk> they're provided by the types in transformers and changelog says they've been in since 0.5.0.0
20:20:06 <koz_> Ah, I see, it just lifts up through.
20:20:23 <koz_> Which makes sense I guess.
20:48:42 <ukari> which ghc extension could make this possible?
20:48:46 <ukari> size :: Storable a => [a] -> Int
20:48:46 <ukari> size array = length array * sizeOf (undefined::a)
20:51:54 <pdxleif> Fun stuff you get to write with Servant, like "(Proxy @IndexAPI) (Proxy @(Nth 1 IndexAPI))", where "IndexAPI" is "Flatten ... my real api ..."
20:52:39 <pdxleif> At some point I should just port this stuff to Idris or whatever, it seems.
20:53:17 <MarcelineVQ> ukari ScopedTypeVariables
20:53:45 <ukari> MarcelineVQ, I tried but seems not work
20:54:46 <ukari> it says "The type variable ‘a0’ is ambiguous"
20:55:00 <MarcelineVQ> read the ghc manual entry on how to use it
20:55:29 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
20:58:14 <ukari> thanks you, MarcelineVQ, I add forall a. and it works now
21:40:17 <slack1256> Any alternative to diagnose how some PINNED data got allocated? It is reported on the .hp generated via +RTS -hc --RTS
21:42:31 <suzu> ffi memory?
21:42:41 <suzu> the gc isnt allowed to free stuff the ffi is using
21:42:43 <suzu> that becomes pinned
21:48:54 <slack1256> I am almost sure that that PINNED memory is just a call to readFile. But I can't make ghc say so.
21:49:52 <slack1256> I think bytestring or text does some weird allocation trick underneat and that explains why PINNED always appears when using them.
22:03:43 <anonano> Hello, I am very new to IRC, found this through the Haskell site. Is this just pretty much a giant Haskell related group chat?
22:04:34 <Axman6> yep
22:05:44 <anonano> Cool 
22:06:15 <anonano> Seems a little quiet, but I guess that's a product of it being 1 AM in North America
22:07:06 <Axman6> It's a product of it being IRC, activity fluctuates a lot
22:07:35 <anonano> Ah alright 
22:10:51 <jackdk> yeah you'll get a lot of Australians at this time of day
22:11:02 <MarcelineVQ> gross
22:13:41 <jackdk> strewth
22:14:38 <anonano> Strewth?
22:15:04 <Axman6> Crikey, it is just us eh mate
22:16:20 <jackdk> too right it is cobber
22:16:42 <Axman6> anonano: did you have a haskell question for us? We're pretty quiet because our code is just working and we have no problems :(
22:16:48 <Axman6> questions*
22:17:10 <anonano> Nah, just figured I'd check this place out since I just learned about it 
22:17:38 <jlamothe> anonano: It's a fun little rabbit hole.
22:17:43 <anonano> Will check in and ask when I do have them though
22:17:56 <anonano> And yeah, seems like it.
22:18:48 <anonano> Anyway, since I have "checked it out" and it is currently 1:18 AM where I am, I think I'll head out and sleep
22:19:00 <anonano> Nice chatting briefly though 
22:20:01 <anonano> Wait shit rejoined by accident 
22:20:04 <anonano> Idk how IRC works 
22:20:47 <Lycurgus> some clients do
22:20:55 <Lycurgus> quassel eg
22:21:19 <Lycurgus> most don't
22:22:20 <Lycurgus> an don't say "shit" it's a bunch of church ladies uih
23:39:41 <gravity> Hi, can someone help by answering this question https://stackoverflow.com/questions/60648652/how-does-stack-resolve-dependencies
