00:01:14 <MarcelineVQ> getting a bit of a runaround as google keeps pointing to old lens versions which mention Data.List.Split.Lens I'm not seeing in newer ones
00:04:24 <MarcelineVQ> I'd like to avoid splitting the path myself and would prefer to just 'target' the root directory and modify it at once
00:10:24 <hololeap> ok, here it is ... although i'm not sure what to name it (and why is RankNTypes necessary?): http://dpaste.com/144R2PP
00:21:02 <hololeap> i'm surprised this isn't in the lens library
00:25:29 * hololeap shines the Kmett-Signal
00:30:10 <Axman6> I never assume something doesn't exist in lens, because it ususally does, in a much more general form than you expected
00:32:28 <hololeap> wow... there's actually a lens combinator called "confusing"
00:33:35 <Axman6> it's also the magic go faster combinator
00:35:58 <hololeap> lol wow many combinator such confusing
00:56:09 <edwardk> hololeap: it isn't in the  lens library because its not a legal lens for  all  applicatives
00:57:18 <edwardk> play with m = [] or with a ziplist and  start varying the length of the lists you work with between sets
00:58:26 <hololeap> really... ok
00:59:36 <hololeap> is there a subset of applicatives it works for?
01:00:13 <hololeap> granted, i really only need this for view atm
01:00:56 <edwardk> distributive functors
01:01:07 <edwardk> i'd expect everything else to fail
01:01:37 <edwardk> for the distributive case it _is_ in lens
01:01:44 <edwardk> or at least in linear
01:01:54 <edwardk> see the 'column' combinator in linear
01:02:36 <edwardk> column :: Representable f => LensLike (Context a b) s t a b -> Lens (f s) (f t) (f a) (f b)
01:03:58 <hololeap> edwardk: this is what i abstracted it from. it seems pretty straightforward in this example: http://dpaste.com/380YC0S
01:04:44 <edwardk> now use it with [] with two elements, when you <*> to put them together you get a container with 4!
01:05:04 <edwardk> forget the set/set law you can't even get/set
01:05:41 <edwardk> the distributive thing works because the 'shape' is constant and you aren't destroying any other information because it can't exist.
01:05:50 <edwardk> (,) e fails because you start clobbering 'e's
01:06:20 <edwardk> Either e fails because you have to deal with switching cases and need to manufacture or destroy information
01:06:29 <hololeap> is there something like Lens' that only supports view?
01:06:32 <edwardk> just giving some intuition for why only distributive functors work
01:06:38 <edwardk> sure. 'Getter'
01:06:40 <edwardk> and 'Fold'
01:06:45 <hololeap> Getter... ok
01:06:47 <edwardk> :t to
01:06:48 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
01:06:53 <edwardk> to makes one from any function
01:07:24 <edwardk> > [1,2,3]^..traverse.to (+4)
01:07:27 <lambdabot>  [5,6,7]
01:07:42 <edwardk> > (1,2,3)^..each.to (+4)
01:07:44 <lambdabot>  [5,6,7]
01:07:45 <hololeap> i'm familiar enough with Distributive to know there aren't many instances
01:08:15 <edwardk> they all look like functions from (Rep f -> ...) which is what they are
01:08:32 <edwardk> data Pair a = Pair a a -- aka V2 in linear is that for Bool for instance
01:09:34 <hololeap> right. i've used vector-sized before
01:12:34 <hololeap> so, is there something like `Functor f => Getter a (m b) -> Getter b c -> Getter a (m c)` in lens?
01:12:51 <hololeap> s/m/f
01:17:57 <hololeap> ??? g1 g2 = to (fmap (view g2) . view g1)
01:23:23 <hololeap> or would that be a new combinator, edwardk?
01:38:32 * hackage genvalidity 0.10.0.2 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.10.0.2 (Norfair)
01:45:13 <hololeap> in any case, i wrote my own: (^^.) = to (fmap (view g2) . view g1)
01:46:32 <hololeap> g1 ^^. g2 = to (fmap (view g2) . view g1)
01:47:59 <koz_> hololeap: Not ^.^?
01:48:07 <koz_> Or even <^.^>?
01:49:33 <hololeap> koz_: it is done
01:57:04 <edwardk> holostep: nothing stops you from using `to (fmap f)` -- in general 'getters' are pretty rare birds. we don't really make any in the lens library, because they are just crappy hard to use functions
01:57:10 <edwardk> we offer lots of folds, and 'to'
01:57:19 <edwardk> folds at least give some power to pick the monoid you fold with
01:58:23 <edwardk> er hololeap 
01:59:21 <hololeap> Getters actually work great for my use case here: data types wrapping around (Store s a)
02:01:17 <hololeap> well, (Store s (f a))
02:01:38 <hololeap> i know it's pretty wacky
02:03:47 <hololeap> i don't really need to set them, but reading from deeply nested Stores is something i have to do, so Getter works well
02:06:40 <hololeap> type ObjectOutput t m = (Behavior t (Canvas, InputPassthrough), ChildMap t m)
02:06:50 <hololeap> newtype Canvas = Canvas { getCanvas :: Store Size Picture }
02:06:55 <hololeap> that's an example
02:08:20 <hololeap> for instance, i might want to get `Behavior t Size` from an `ObjectOutput t m`
02:10:18 <hololeap> type ObjectStore t m = Store (ObjectEvents t) (m (ObjectOutput t m))
02:11:19 <hololeap> so ultimately, i might want `m (Behavior t Size)` from `ObjectStore t m`
02:19:13 <hololeap> i can do objectCanvasB :: (Reflex t, Functor f) => Getter (GlossObject t f) (f (Behavior t Canvas))
02:20:10 <hololeap> anyway, thanks edwardk
03:51:11 <dminuoso> For lens to optics conversion, what's the most elegant way to replace `do r <- preview someFold`? Would you just write `do r <- gview (pre someFold)` instead?
05:14:32 * hackage higher-leveldb 0.6.0.0 - A rich monadic API for working with leveldb databases.  https://hackage.haskell.org/package/higher-leveldb-0.6.0.0 (jeremyjh)
05:23:50 <[itchyjunk]> I know python gets used in those little physical robot projects sometimes. Does haskell ever get used ? those little mini projects people do in their garage. :s
05:24:47 <yushyin> i guess copilot can be used for such projects
05:25:29 <MarcelineVQ> sure, srk has some inroads there, there's interested people to be found in #haskell-embedded     https://github.com/cyberbotics/HsWebots#readme  came up in here recently
05:25:52 <merijn> ugh, I can't do sin on Rational? :\
05:26:07 <MarcelineVQ> acowley does robotics that may or may not include haskell lately :>
05:32:07 <[itchyjunk]> I had no idea haskell was used in embeded stuff like that and there was a whole channel for it
05:32:20 <MarcelineVQ> it's not super active but activity is welcome
05:33:33 <Ariakenom> merijn: I know :(
05:38:02 * hackage dobutokO2 0.13.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.13.0.0 (OleksandrZhabenko)
05:41:50 <rsoeldner> Hi, I'm trying to use the `grenade` package under nixos with including `blas` and `liblapack` in my shell.nix. This approach fails to run the tests due to undefined ref https://gist.github.com/rsoeldner/74271d0b109afa4229cb3754f1b25b7b ,is there some fast fix ?
05:44:21 <Cale> rsoeldner: Oh, that looks annoying, hmm
05:45:38 <aveltras> any idea why i get the following behavior trying to use mvars as lock ? I'd expect thread 12684 to not be able to take the MVar before thread 12681 puts it
05:45:42 <aveltras> https://www.irccloud.com/pastebin/TxxpGJgA/
05:46:29 <Cale> rsoeldner: Probably the solution involves overriding the Haskell package and adding something to the librarySystemDepends
05:47:11 <Cale> rsoeldner: Maybe also ask in #nixos if you haven't already
05:52:38 <rsoeldner> Cale, thank you I will try it :)
05:53:02 <MarcelineVQ> Cale: got any reflex-dom + diagrams examples kicking around?
05:56:32 <Cale> MarcelineVQ: I did some experiments... https://cale.l5.ca/Demos/GamePiece/
05:57:33 <Cale> MarcelineVQ: I had trouble scaling this up nicely, and haven't really returned to it, as I want to make use of future Obelisk features we've still not released for this game.
05:57:37 <MarcelineVQ> thank you. aren't blink drives a little dangerous?
05:57:41 <Cale> haha
05:58:48 <aveltras> found why my gist didn't work, the ioref map wasn't created in main but in the request handler..
05:59:17 <Ariakenom> aveltras: :D. did you try any stm?
05:59:36 <aveltras> not yet but seems i won't need it for now
05:59:43 <aveltras> seems to work ok now
06:00:34 <Cale> MarcelineVQ: It turns out that browsers don't take kindly when you throw tens of thousands of new DOM nodes at them all at once, so scaling this up to an entire board filled with pieces didn't work out so nicely. I'd need to actually make the integration between disgrams and reflex-dom go a little deeper to avoid reconstructing elements unnecessarily.
06:00:42 <Ariakenom> aveltras: you should use withMVar instead of take|put for exception safety
06:01:23 <Ariakenom> well, mostly because it's nicer to use
06:03:00 <aveltras> some thing like "withMVar lockMVar $ const f" in the end ye, looks much better
06:03:03 <aveltras> thanks
06:03:31 <MarcelineVQ> Cale: I see, I'm looking for a somewhat low-pain route to create an little app people can place obstacle [symbols] on, specify an order, and have it draw you a route between/around obstacles, reflex or miso seem like the current go-to's for building something that ends up as web app
06:06:09 <MarcelineVQ> you can swap diagram backends at-will for dev purposes but idk how easy it is to swap UI management. at one point I remember being able to build to webkit or to js with reflex which broadened your immediate options in that you could leave the web stuff for later
06:06:19 <Ariakenom> aveltras: nice, good job getting it working!
06:07:14 <MarcelineVQ> Not that that's any requirement, just a thing I felt like saying :>
06:09:08 <aveltras> Ariakenom: im now wondering how to clean the map of locks so that it doesn't get giant over time :)
06:15:58 <merijn> aveltras: Where does the token come from?
06:16:18 <aveltras> from an http request
06:16:27 <merijn> aveltras: Also, if you just use STM then you don't need a map to begin with, so problem gone
06:17:42 <aveltras> how so ?
06:18:08 <merijn> I guess you can't do arbitrary IO in STM, though, so it depends what you're doing for every request
06:18:35 <aveltras> its a web request handler so lookups to db etc
06:18:50 <aveltras> the f in my gist is the request handler
06:19:43 <merijn> Why do they need a lock per token, though?
06:21:05 <aveltras> in case two consecutive requests come with the same token, there is a session token renewal in the f handler,  so i want the second (blocked request) to discover its new token (generated by the handler of the first request) without generating itself a new one and have diverging sessions after
06:21:36 <aveltras> in case a token is about to expire
06:22:34 <aveltras> when i say consecutive i mean here that the first request isn't finished when the second comes in
06:23:33 <aveltras> more like "concurrent requests"
06:32:31 * hackage deriving-aeson 0.2.2 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.2 (FumiakiKinoshita)
06:32:50 <Ariakenom> aveltras: I can't see any easy change that allows you to remove items. the smallest seem to be that you insert empty MVars to begin with and remove them when f is done
06:33:38 <Ariakenom> but that's quite different enough that I would rewrite to stm
06:35:30 <Ariakenom> but maybe im missing a solution
06:50:25 <dmwit> koz_: The Semigroup of interest is `Endo (Kleisli m) a`.
06:50:51 <dmwit> koz_: With this `Endo`, specifically: https://hackage.haskell.org/package/category-0.2.5.0/docs/Data-Morphism-Endo.html#v:Endo
07:03:20 <merijn> Is there a convenient "(a -> b) -> a -> (a, b)" function?
07:05:56 <Cale> (\f x -> (x, f x)) is more convenient than any other combination of shenanigans I can think of
07:06:21 <solonarv> :t (id&&&)
07:06:23 <lambdabot> (b -> c') -> b -> (b, c')
07:06:29 <Cale> :t ((,) <*>)
07:06:30 <lambdabot> (a1 -> a2) -> a1 -> (a1, a2)
07:06:30 <solonarv> I guess you could use that
07:06:42 <Cale> There's that but it's unnecessarily hard to understand
07:09:10 <MarcelineVQ> what's so hard to understand about  fmap f . join (,)  pssssshhhhhhhhhhh
07:21:17 <dmwit> :t bimap id
07:21:18 <lambdabot> Bifunctor p => (c -> d) -> p b c -> p b d
07:21:43 <dmwit> :t right
07:21:44 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
07:21:47 <dmwit> oof
07:21:58 <dmwit> :t second
07:21:59 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:27:32 <hyperisco> lets say I want to write bytes out to a file stream, a Writer seems to be an inherently lazy approach to this
07:27:56 <hyperisco> whereas a Reader would be inherently strict
07:28:33 <solonarv> well, with Writer it depends on which variant you use (strict or lazy) and how lazy/strict the monoid in question is
07:28:46 <hyperisco> I mean in regards to the effects on the stream
07:29:41 <hyperisco> the writer approach would be to construct a list of all the bytes to write to the stream, then write it at the end
07:29:49 <hyperisco> whereas the reader approach would be to write to the stream immediately
07:30:06 <solonarv> ah, now I see what you mean
07:30:16 <Psybur> Is "Just use IO lol" still in style?
07:30:52 <Cale> Yeah, just use IO lol
07:31:35 <hyperisco> so I suppose questions are whether you want backtracking, such as if you might throw an exception while writing
07:32:03 <hyperisco> in which case writer makes sense… but on the other hand you have to have enough memory to hold all the bytes (plus overhead)
07:33:06 <merijn> Psybur: IO heavy Haskell is underrated, IMO
07:34:03 <solonarv> something somethign finest imperative language
07:34:16 <Psybur> I remember always hearing just use IO lol in this channel but I can never seem to find any related articles to this phenomenon with google
07:34:26 <Psybur> Its always "Avoid IO OMG"
07:34:45 <solonarv> you can probably find some articles about this on the fpcomplete blog
07:34:47 <hyperisco> suppose you could also hybridise as a WriterT in a ReaderT, and create commit points
07:34:48 <Cale> Psybur: Oh, I thought you were commenting on hyperisco's situation
07:35:08 <Psybur> Cale, his situation is what triggered it so it was somewhat aimed at his situation
07:35:22 <Cale> Psybur: Obviously, if the program you're writing has nothing to do with IO, don't use the IO type
07:35:41 <Cale> But if you're doing I/O, then using IO is entirely sensible most of the time
07:36:08 <hyperisco> I just find it interesting because in the other direction (ie decoding) just a reader seems sensible in all cases
07:36:12 <Cale> It's really when that starts to become complicated in some way that you begin to reach for other things like an FRP system or something.
07:36:36 <solonarv> hyperisco: but this is not true: usually people use a State(T)
07:36:52 <solonarv> that lets you keep track of where you are currently / how much of the input is left
07:36:52 <Cale> People should be wary that the first monad transformer is always very expensive
07:37:14 <Cale> in terms of how annoying the code becomes to work with
07:37:14 <Psybur> I remember back when I was working on something where I was using reaser/writer/state people were just like USE IO LOL
07:37:38 <solonarv> it depends on what exactly you are doing with them
07:37:48 <solonarv> StateT over IO? I'd avoid that
07:38:18 <solonarv> because it's not very clear to me how the state from StateT works in the presence of exceptions etc
07:38:32 <Cale> There's a place for monad transformers in building up a monad with the features that you want, but I think it's usually important to have a strong understanding of what the actions of the monad you're creating actually mean
07:38:43 <hyperisco> solonarv, I am presuming the file stream has that information available but otherwise yes, additional state would be needed
07:38:51 <merijn> solonarv: StateT over IO is fine, as long as you don't bracket
07:39:06 <solonarv> yeah but I don't want to think about that ;)
07:39:08 <merijn> solonarv: Which is why exceptions only has MonadThrow for StateT and not MonadCatch/MonadMask
07:39:10 <Cale> If the answer is "they're basically like IO actions, but maybe with some extra random stuff..."
07:39:28 <Cale> then maybe you should think about where you're going with it a little more
07:39:37 <solonarv> in practice if I am putting transformers on top of IO they always end up being (isomorphic to) ReaderT anyway
07:40:28 <hyperisco> yes, because you can parameterise on mutable data and essentially have a state anyways
07:40:32 <solonarv> exactly
07:40:53 <Cale> Like, you might have a monad for database transactions, and sure, you might have a ReaderT in there which carries the database connection around
07:41:12 <solonarv> of course for short sections of code there might end up being a MaybeT layered on top or something, but that's never the "main monad"
07:41:18 <Ariakenom> main = setup >>= \chan -> forever $ join $ readChan chan -- next big haskell framework
07:41:27 <Cale> But nobody should need to know that it's a ReaderT, and maybe you don't even want to expose arbitrary IO in that case
07:41:34 <Psybur> merijn, is this article related to your statet io bracket shenanigans? https://www.fpcomplete.com/blog/2017/06/tale-of-two-brackets
07:42:19 <ibloom> Does anyone know of anyone successfully using Accelerate with Intel or AMD chips? I've just been surveying the various projects and I'm trying to determine the state of the art. It looks like the llvm backend is still CUDA only.
07:42:59 <merijn> Psybur: That article tries to implement catch for StateT over IO, but the resulting MonadControl is a mess and you should probably avoid using it
07:43:07 <Athas> ibloom: no, the llvm backend is multicore CPU (and quite fast).  It's the llvm-ptx backend that is CUDA-only.
07:43:35 <Psybur> merijn, I think thats the point, its explaining how this stuff is broken
07:43:37 <merijn> Psybur: Since FPComplete has since stopped recommending it to and instead recommends MonadUnliftIO which doesn't implement an instance for StateT either
07:43:58 <merijn> oh, possible, that's too much reading :p
07:44:09 <Cale> All the things which are in any way similar to MonadBaseControl/MonadTransControl/UnliftIO/etc./etc. are a bit of a mess
07:44:19 <ibloom> @Athas, I see. But still no way to compile for Intel/AMD GPUs as far as you can tell?
07:44:19 <lambdabot> Unknown command, try @list
07:44:29 <Athas> ibloom: there is none, no.
07:44:30 <merijn> Cale: UnliftIO seems clean and sensible
07:44:58 <Cale> I recommend making (or simply finding) classes for the higher order operations that you actually use, and then writing instances for whatever transformers you need.
07:45:24 <ibloom> Athas: ok thank you.
07:45:43 <Cale> It's hard to capture correctly and precisely "lift this arbitrary higher-order something-or-other whose properties we can't know through WhateverT"
07:46:06 <Cale> Writing the instances for each transformer will give you a chance to catch mistakes, and doesn't really take very long
07:46:39 <merijn> Cale: MonadUnliftIO only does ReaderT, which is trivial, though
07:46:47 <Cale> Even if your transformer is built with ReaderT, it's not necessarily okay to just forkIO through it for example.
07:46:48 <merijn> Cale: (Or isomorphic to ReaderT)
07:46:52 <Ariakenom> ibloom: futhark might be of interest to you
07:46:59 <hyperisco> though if you are not fixed to IO, if you choose StateT over ReaderT then you still have mechanism for state
07:47:26 <Ariakenom> not Accelerate or even haskell though
07:47:28 <hyperisco> and when using IO you can just ignore the write feature
07:47:29 <Ariakenom> so maybe not
07:47:57 <Cale> It really depends on what you're reading, and whether it makes sense to share that resource with the action that you're passing as a continuation to whatever higher order thing it is
07:48:32 <Cale> If you have instances of these very general classes, it's easy to miss things that are happening that don't quite make sense.
07:49:18 <ibloom> Ariakenom: That does look really interesting. I'll look into it. Do you know of futhark being deployed anywhere?
07:49:38 <merijn> I'm sure Athas can tell you :p
07:52:36 <hyperisco> if you abstracted the write actions you could, for example, count the bytes needed to encode something before allocating the bytes to encode it
07:52:58 <hyperisco> wouldn't require IO and would take advantage of State
07:53:42 <solonarv> formally it's still just a Writer, not a full State
07:53:55 <solonarv> (the monoid is Sum Int)
07:54:05 <hyperisco> but you need a Reader to for the object that is being encoded
07:54:13 <hyperisco> so both together may as well be State
07:54:13 <Ariakenom> merijn: not the first time I've advertised futhark when Athas is advising someone on parallelism :D
07:54:43 <solonarv> huh? Reader + Writer is not the same as State
07:54:55 <solonarv> especially if they use different types! which they will in this case
07:58:01 * hackage ixset-typed 0.5 - Efficient relational queries on Haskell sets.  https://hackage.haskell.org/package/ixset-typed-0.5 (AndresLoeh)
07:58:04 <hyperisco> solonarv, you can use a 2-tuple
07:59:28 <hyperisco> \x -> \s -> (a, s')  to  \(x, s) -> (a, (x, s'))
08:02:17 <solonarv> I guess, but that seems unnecessary
08:02:30 <hyperisco> I gave a plausible use
08:03:34 <hyperisco> also using ExceptT for errors gives a use of validating an object is encodable without actually writing any bytes
08:05:43 <ibloom> Is there any way to embed futhark functions into an existing haskell project, as I can with OpenCL or Accelerate?
08:07:30 <Athas> ibloom: you can embed OpenCL in Haskell?
08:08:01 <ibloom> Yes. I'm doing it right now.
08:08:19 <Athas> Like with quasiquotes or what?
08:09:27 <ibloom> Athas: You can just send a bytestream with the OpenCL code to compiler and get back a function that you can call. Check out the CLUtil library.
08:09:41 <Athas> Anyway, Futhark is not embedded in Haskell.  Interop via FFI is possible, but it's nowhere as smooth as Accelerate.
08:11:30 <ibloom> I guess, I should back up a second. I'm looking for strategies to move a lot of the embarrassingly parallel parts of my rasterizer onto the GPU and I don't want to write anymore OpenCL by hand, but I recognize that most devices don't have NVIDIA hardware.
08:13:57 <ibloom> Currently I do a lot of work in Haskell and then send some buffers over to a series of OpenCL Kernels. https://github.com/ianmbloom/gudni
08:14:23 <hyperisco> hrm, a fairly naive Applicative approach could be reasonable for binary formats
08:15:07 <hyperisco> the concern is avoiding too much repetition in decoding (because a decoded value may be needed to decode the rest) but I think practically a field is only relevant once
08:15:27 <hyperisco> then you can define full codecs
08:23:18 <Athas> ibloom: that looks like a pretty cool program.  I don't know if Futhark or Accelerate could compete with your hand-written OpenCL, but it'd be interesting to see.
08:23:48 <Athas> And I can certainly symphatise with not wanting to write OpenCL.  Nobody wants that.
08:23:49 <Cale> https://www.cambridge.org/core/books/programming-in-haskell/8FED82E807EF12D390DE0D16FDE217E4 free until the end of May because of Covid-19
08:24:52 <Ariakenom> is book good? I can program in haskell, I think.
08:25:09 <Cale> It's probably mostly useful to beginners
08:25:11 <Athas> Ariakenom: it is an excellent book, but it is for beginners.
08:25:27 <Athas> But it's by far my favourite Haskell introduction.  The previous version was my intro.
08:26:16 <ibloom> Athas: there is a lot of preliminary code that just deals with transforming shapes as well as manipulating textures, that I'm hoping to move onto the GPU. A majority of that code is embarassingly parallel. The current OpenCL code will probably stay though I've been working hard to simplify that as well.
08:27:17 <Ariakenom> well maybe I can learn things about how to teach haskell from it
08:28:06 <ibloom> Athas: An update of Accelerate-OpenCL might be what I need, since Vulkan is going to support OpenCL soon (we hope).
08:31:15 <sshine> Ariakenom, my experience is that you only really learn to teach by teaching. I've been trying to piece a "curriculum" of exercises together on Exercism.io, and it just never resembles anything alike a course. it's just so loosely coupled without a good feedback mechanism.
08:33:00 <Athas> ibloom: realistically, I don't think Accelerate will grow OpenCL support anytime soon.  The old OpenCL prototype is eight years outdated.  And what do you mean by Vulkan supporting OpenCL?
08:33:13 <tdammers> anyone know what it means for cabal update to error out with 'truncated tar archive'?
08:33:27 <Athas> Vulkan has compute shaders, but when we implemented a Vulkan backend for Futhark, we found lots of limitations and poor performance.  Vulkan really is mostly for graphics.
08:34:51 <hyperisco> Was there ever any concerns with OpenCL?
08:35:41 <Athas> Concerns?
08:35:45 <hyperisco> As opposed to OpenGL which has been criticised for implementation inconsistency and being too removed from hardware to achieve high performance
08:36:04 <ibloom> Athas: So this is the information I gathered: https://github.com/KhronosGroup/Vulkan-Ecosystem/issues/42#issuecomment-565764862
08:36:29 <Athas> No, OpenCL is pretty decent.  It's very verbose and has some minor flaws, but the API is modern.  The biggest problem is lack of vendor support, mostly from NVIDIA.
08:36:44 <hyperisco> versus Vulkan which I understand it as more like an instruction set
08:36:54 <Athas> And the verbosity of OpenCL makes it a very good fit for code generation.  Everything is really nice and explicit.
08:37:00 <hyperisco> rather than a graphics library, like OpenGL is
08:37:08 <Athas> Vulkan is _way_ more verbose than OpenCL.
08:37:37 <ibloom> Athas: There is also a project clvk that I'm following on github that is very active: https://github.com/kpet/clvk
08:37:40 <Athas> ibloom: oh, that's just interop, meaning you can pass Vulkan data to OpenCL kernels and the other way.  Presumably just like the existing OpenCL/OpenGL interop.
08:41:12 <ibloom> Athas: I believe the API may provide more than just interop. Tell me what you gather from this post: https://github.com/KhronosGroup/Vulkan-Ecosystem/issues/42#issuecomment-450966378
08:44:17 <Athas> ibloom: well, it all hinges on "if Vulkan compute capabilities expand to increasingly match OpenCL".   I don't see any signs that it will.
08:45:25 <Athas> But also: we *did* successfully write a Vulkan backend for the Futhark compiler that was almost 100% functional.  A bit slower than we'd like, and it needed workarounds for some things, but Vulkan clearly isn't impossible to use for compute.  It's not far from being an OpenCL alternative (at least on GPU).
08:51:22 <Ariakenom> Athas: yikes those numbers look big, 7x slower/faster? https://futhark-lang.org/student-projects/steffen-msc-project.pdf#page=24
08:52:41 <joggg23> Hello. Sorry  for the noob question, but I wasn't successful in searching this. Why does ghc synthesise the type of "f = \x y -> x + y" as "Integer -> Integer -> Integer" (instead of (Num a) => a -> a ->a). If defined in the ghci REPL I get the expected result
08:52:42 <ibloom> Athas: Understood, well keep me in mind if you think of any solutions. I'm currently working on a bunch feature updates for my library but the GPU deployment issues are kind of a problem. The goal is just to have one or two big dependencies as far as graphics and compute are concerned while also writing as little OpenCL as possible.
08:54:12 <ChaiTRex> joggg23: See https://wiki.haskell.org/Monomorphism_restriction
08:54:29 <joggg23> Thank you, I'll look into it
09:00:18 <f-a> Hello. I am building an hakyll site with cabal new-run --verbose -j1 --ghc-options='+RTS -M1G' ariisit-site -- watch
09:00:48 <f-a> and getting this error http://www.ariis.it/link/t/paste21648-0
09:01:10 <f-a> is there anything I can do to succesfully complete the build?
09:03:30 <tdammers> oh lol, I walked right into this trap: in order to properly use ghc 8.8, you need cabal 3.0; but in order to install cabal 3.0, you need cabal, but GHC 8.8 doesn't work with that, so you can't actually install Cabal 3.0
09:03:47 <tdammers> --with-compiler to the rescue
09:04:43 <dmwit> tdammers: The cabal-install package includes a bootstrap.sh
09:04:59 <tdammers> dmwit: yes, but that requires downloading the cabal-install package manually
09:05:07 <tdammers> dmwit: which I am waaaay too lazy for
09:05:21 <dmwit> cabal unpack ?
09:09:23 <tdammers> --with-compiler is doing the trick as we speak
09:09:35 <tdammers> I'll just compile cabal 3 with ghc 8.4
09:33:17 <ukari> https://plaster.tymoon.eu/view/1709, is it possible to make T' to work correctly as T ?
09:34:14 <hyperisco> hmm,  ReaderT x (ExceptT e m) a  seems quite general… perhaps should be called  ProcedureT
09:34:30 <hyperisco> sorry I mean  StateT s (ExceptT e m) a
09:35:24 <hyperisco> just because those are the common features of most procedural programs
09:35:49 <hyperisco> sequentially altering a state and might die
09:35:57 <zeta_0> if anyone here uses #darcs channel, i left some messages there, asking for help, thanks
09:36:59 <solonarv> @unmtl StateT s (ExceptT e m) a
09:36:59 <lambdabot> s -> ExceptT e m (a, s)
09:37:03 <solonarv> grr
09:37:07 <solonarv> @unmtl StateT s (ErrorT e m) a
09:37:07 <lambdabot> s -> m (Either e (a, s))
09:37:26 <solonarv> why that nesting instead of ExceptT e (StateT s m) ?
09:38:35 <hyperisco> because the program always had a last state whether it aborted or not
09:39:00 <hyperisco> as it must have an initial state
09:39:11 <monochrom> "Either e (a,s)" says Left has no last state.
09:39:32 <monochrom> You need s -> (s, Either e a)
09:40:05 <hyperisco> oh I did it inside out
09:40:10 <solonarv> @unmtl ErrorT e (StateT s m) a
09:40:10 <lambdabot> s -> m (Either e a, s)
09:40:14 <monochrom> :)
09:40:17 <solonarv> this is what you want, yes?
09:40:38 <monochrom> Always unmtl it to check :)
09:40:52 <solonarv> "because the program always had a last state whether it aborted or not" - yes, that is why I was confused by your choice :)
09:47:43 <CTHULHUJESUS> #haskell Can someone help me make a function to get a picture of the screen and return it in a matrix or list or somthing?
09:53:36 <solonarv> it's possible, but probably finicky and definitely system-dependent
09:54:19 <solonarv> and it's not a particularly great showcase of haskell's strengths: you will basically just end up finding the right system / OpenGL / whatever function to call and gluing it to an image-encoding library
09:54:51 <maerwald> I'm trying to build a project statically on FreeBSD. It fails with "ld: cannot find -lHSmtl-2.2.2-ghc8.6.5". Doesn't make any sense to me 
09:55:17 <hyperisco> so there is the low tech extensible effects approach where you define a class per set of effects, and members are the effects, parameterised over an arbitrary monad
09:56:46 <hyperisco> feeling like ProcedureT is just enough additional structure on that monad to be helpful without overly constraining
09:58:19 <hyperisco> though doesn't support bracketing
10:00:18 <Cale> CTHULHUJESUS: Which OS are you on and what do you intend to do with the image? It might be easiest just to shell out to something to capture a screenshot, and then load the image. It's possible to use gtk2hs to take a screenshot in a cross-platform way.
10:01:23 <Cale> ah, someone's already written it here: https://stackoverflow.com/questions/11963561/screen-capture-in-haskell
10:01:41 <Cale> (the second answer)
10:02:43 <CTHULHUJESUS> that dosn't work because I need to be able to transform it to a different form (list,matrix,...)
10:02:53 <CTHULHUJESUS> ubuntu
10:04:56 <Cale> I think you can pixbufGetPixels to get a mutable array corresponding to the pixbuf
10:05:13 <Cale> http://hackage.haskell.org/package/gtk-0.15.0/docs/Graphics-UI-Gtk-Gdk-Pixbuf.html#t:PixbufData
10:05:46 <Athas> Ariakenom: yes, some of those 7x faster make no sense to me.  I suspect they were measured on tiny datasets that are almost entirely driver overhead.
10:05:55 <CTHULHUJESUS> but when I call thouse metheds I ghc says that they are privite
10:06:32 * hackage hledger-interest 1.5.4 - computes interest for a given account  https://hackage.haskell.org/package/hledger-interest-1.5.4 (PeterSimons)
10:06:32 <Cale> What exactly does GHC say?
10:06:37 <Ariakenom> Athas, but that was the vulcan implementation you spoke of?
10:08:10 <Athas> Ariakenom: yes.
10:09:46 <Cale> CTHULHUJESUS: I think I'd be tempted though just to take a screenshot some other way (probably by shelling out to something) and then just use JuicyPixels to load the resulting image file. http://hackage.haskell.org/package/JuicyPixels-3.3.5/docs/Codec-Picture.html
10:10:08 <Cale> CTHULHUJESUS: You could also do the same with the pixbuf from GTK
10:10:38 <CTHULHUJESUS> I want to do this every  ~0.5 seconds at least
10:12:41 <Cale> If what you're doing needs to be fast, then probably operating directly with the pixbuf via the MArray operations is your best bet
10:13:24 <Cale> You'll notice there's an instance there: Storable e => MArray PixbufData e IO
10:13:46 <Cale> http://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array-MArray.html#t:MArray -- which means that the functions here will work on it
10:14:01 * hackage jira-wiki-markup 1.1.1 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.1.1 (tarleb)
10:14:33 <Cale> and you get to pick which Storable data type to read the pixbuf data in, probably Word8 is a reasonable choice
10:14:53 <Ariakenom> Athas, do you have any better numbers?
10:15:50 <Athas> Ariakenom: no, we haven't done anything more with it since.
10:17:10 <CTHULHUJESUS> Cale Thanks what module do i need to import to get access to thouse metheds? because I cant find them
10:18:00 <solonarv> CTHULHUJESUS: did you see the SO answer? those functions live in Graphics.UI.Gtk
10:18:49 <Cale> and Graphics.UI.Gtk.Gdk.Pixbuf
10:19:11 <Cale> You'll need to have the gtk package set up as a dependency of your project
10:20:09 <Ariakenom> Athas, maybe an approximate number from memory? 
10:20:51 <Cale> https://github.com/gtk2hs/gtk2hs has some instructions, since you may need to install a bunch of other stuff to develop gtk applications
10:21:05 <Cale> (the readme, scroll down)
10:21:07 <Athas> Ariakenom: I mean, those numbers are correct, I just think they are for extreme cases.
10:21:38 <Cale> It also points out that haskell-gi has a more complete binding, but of course, you'd need to translate the example to use it
10:21:38 <CTHULHUJESUS> Cale I do, but it keeps telling me that I Variable not in scope: getNumElements
10:21:55 <CTHULHUJESUS> Cale same for unsafeRead
10:23:32 <Cale> ahh, those used to be things in MArray
10:23:58 <CTHULHUJESUS> Cale so what do I use now?
10:25:04 <Cale> Wait, actually where are you seeing those things?
10:25:40 <CTHULHUJESUS> Cale here https://hackage.haskell.org/package/gtk-0.15.0/docs/Graphics-UI-Gtk-Gdk-Pixbuf.html#v:unsafeRead
10:26:47 <Cale> You mean in the comment?
10:27:32 <CTHULHUJESUS> Cale ?? what 
10:28:21 <Cale> The only mention of unsafeRead I see on the page you linked is in a comment
10:28:44 <Cale> You can probably get by with readArray to start with
10:29:51 <Cale> and getBounds
10:30:10 <Cale> getBounds will get you the first and last indices
10:30:19 <CTHULHUJESUS> Cale ok Thank you, I have been stuck on this for days
10:31:21 <lupulo> Data/Hashable/Class.hs:397:11: error:
10:31:22 <lupulo>     Not in scope: data constructor ‘Natural’
10:31:30 <Cale> Apparently getNumElements, unsafeRead and unsafeWrite are still there in Data.Array.MArray, but Haddock mysteriously doesn't link them, suggesting they may not be exported
10:31:31 <lupulo> hashable-1.2.7.0 # ./setup build
10:31:54 <Cale> It's hard to imagine they wouldn't be exported from anywhere though.
10:33:02 <Cale> Let me check
10:33:43 <Cale> hmm, yeah, they don't appear to be exported
10:38:01 <Cale> That's mildly obnoxious
11:15:02 <AWizzArd> In the Clojure/Java world there is the (unwritten) convention to name a version of an app/lib that is in development by postfixing it with `-SNAPSHOT`.
11:15:43 <AWizzArd> When a release is made the `-SNAPSHOT` postfix is removed and that commit is then tagged.
11:16:13 <AWizzArd> The next commit would increase the version number and add the snapshot part again, and this commit could be called "next dev cycle"
11:16:26 <AWizzArd> How is this done with Haskell?
11:16:48 <AWizzArd> Is there some comparable convention, to mark dev releases?
11:17:51 <sm[m]> AWizzArd: in the hledger project, the 1.17.99 means "1.18 in development"
11:18:30 <sm[m]> cabal version numbers may contain only digits and periods
11:18:46 <AWizzArd> Oh okay, I didn’t know that. Important information.
11:18:53 <AWizzArd> But… kind of a design flaw.
11:19:10 <sm[m]> it's just my convention. Not widespread.
11:19:12 <AWizzArd> Especially since Semantic Versioning explicitly allows for letters.
11:19:24 <AWizzArd> sm[m]: seems you make the best out of the given situation :)
11:19:37 <sm[m]> yup
11:20:08 <sm[m]> I was using .97, .98, .99 for alpha, beta, rc but that's way too much
11:20:13 <[exa]> AWizzArd: some people might oppose the words "dev" and "release" used together :]
11:21:13 <opqdonut> AWizzArd: isn't -SNAPSHOT directly compatible with semantic versioning? it's a "prerelease" in their terminology
11:21:58 <dignissimus> So, a small bit ago I learned haskell well but and for a bit I used it quite a bit but then I didn't really use it much. What can I do to cement haskell into my mind. I've used python for a long time and if I want to do something with it I can just do it, how do you guys suggest I achieve that with haskell?
11:22:08 <dignissimus> I'll have a lot of time on my hands due to the coronavirus
11:22:27 <opqdonut> hmm I guess reusing 1.2.3-SNAPSHOT is against the semver rule "Once a versioned package has been released, the contents of that version MUST NOT be modified."
11:22:58 <dignissimus> Also by well I don't mean anything advanced, I just understood how to do what I wanted to do. I haven't touched haskell in a while
11:24:37 <sm[m]> dignissimus: use it for scripting tasks
11:25:03 <sm[m]> use shake for building things
11:25:06 <sm[m]> use hakyll or rib for building your website
11:25:32 <sm[m]> modify a haskell-based tool that you use
11:25:44 <phadej> opqdonut: I might be too tried to spot, but semver also doesn't specify how 1.2.3-alpha1 and 1.2.3-alpha2 compare
11:26:17 <phadej> yet importantly
11:26:18 <phadej> A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. 
11:27:28 <phadej> so it could be _anything_. You could allocate some old 0.1.z and use those for "development versions"
11:27:41 <AWizzArd> [exa]: they might have their reasons, I’ll be ignoring those people
11:27:45 <juliusdeane> are there parsing tools preferable to parsec when performance is a big consideration?
11:27:58 <phadej> as *semantically* ^1.2.2 shouldn't match 1.2.3-alpha1 -- there is no spec defined compatibility, only accidental
11:27:59 <AWizzArd> opqdonut: yes, such endings/postfixes are compatible with Semantic Versioning
11:29:16 <phadej> ah, there is a section how endings compare https://semver.org/#spec-item-11
11:29:41 <phadej> which I guess makes versioning non-tranitive
11:29:50 <sm[m]> juliusdeane: megaparsec
11:30:40 <phadej> 1.2.3-alpha < 1.2.3-alpha.beta < 1.2.3-beta.alpha /< 1.2.3 < beta
11:30:44 <phadej> 1.2.3-alpha < 1.2.3-alpha.beta < 1.2.3-beta.alpha /< 1.2.3-beta
11:30:54 <sm[m]> in some cases possibly attoparsec, but you'd need to test
11:31:06 <phadej> ok, there is if all of the preceding identifiers are equal.
11:31:16 <phadej> it's tricky, really have to read into ti :)
11:32:49 <dignissimus> sm[m]: Ty for the ideas
11:33:32 <phadej> that said, you can have `version: 1.2.3-development` in Haskell world too, it just will tell you that tags are recognised but omitted
11:33:45 <phadej> (and you won't be able to publish on Hackage)
11:33:56 <sm[m]> dignissimus: another: use it to solve some exercises/compete - exercism, project euler, advent of code, clash of code are some good ones
11:34:17 <opqdonut> phadej: but the biggest problem is that you can't release 1.2.3-development twice, it needs to be immutable
11:34:33 <opqdonut> so something like 1.2.2.99 might make more sense
11:34:37 <phadej> opqdonut: why would you _release_ -development ;)
11:34:46 <phadej> and 1.2.2.99 would be violation of PVP
11:35:07 <opqdonut> well in the java world people are pushing -SNAPSHOT jars to central etc.
11:35:12 <phadej> (even if it doesn't break, anything only adds stuff)
11:35:46 <sm[m]> phadej: not following the conversation in detail, but when developing your multi-package project you probably need some distinct version number so that you can depend on the dev versions
11:35:50 <phadej> opqdonut: is how java people does stuff some authority here? :)
11:36:00 <sm[m]> that's what I use .99 for
11:36:03 <opqdonut> phadej: the discussion started with java -SNAPSHOT
11:36:10 <sm[m]> but it's never released on hackage
11:36:31 <phadej> sm[m]: you'll keep them in a single repository. and then you can use `-dev` suffix (if you are not too annoyed by parser warnings)
11:37:10 <phadej> as in, you often could just bump to the next version the development will eventually become
11:38:32 <sm[m]> phadej are you saying I could use -dev in cabal files ? I thought that didn't work, or causes problems for some tool at least
11:38:56 <sm[m]> I would definitely be annoyed by extra warnings
11:47:37 <phadej> sm[m]: what's your reason to not bump to the next proper version (in this case 1.18) directly?
11:49:13 <hyperisco> also  elseTry a b = catchError a \e → tell e *> b  is a particularly useful definition for auditing
11:50:07 <hyperisco> one way of writing software is all-or-nothing, but many times it is better to yield a best approximation rather than nothing
11:50:24 <Cale> @tell CTHULHUJESUS http://dpaste.com/0JJTMH4
11:50:24 <lambdabot> Consider it noted.
11:50:38 <hyperisco> and using  elseTry  means you don't lose the information of what went wrong
11:51:33 <AWizzArd> phadej: okay, so Cabal itself will do its job, even with such a version number/name?
11:52:24 <AWizzArd> phadej: I would bump the version but append -SNAPSHOT or something similar. This allows me to release at any time. Users will have to understand that they might get into trouble when they use a snapshot release.
11:52:28 <sm[m]> phadej: I also want to distinguish from the final 1.18.
11:52:48 <AWizzArd> sm[m]: same here, and I would like to be explicit to my users and explain them what they are dealing with.
11:53:02 <AWizzArd> Iff I want to release in the middle of a development process.
11:53:59 <sm[m]> AWizzArd: for telling users exactly what they have, there’s a lib for displaying the git hash etc. in —version, too
11:54:26 <sm[m]> stack uses it I believe
11:58:14 <dzdcnfzd> I'm struggling to understand the definitions of some functions defined in Data.Binary.Get, specifically word16be and word16le. These are functions which read a word from memory in either big-endian or little-endian format. First things first, I don't actually understand why a parser for a datatype intended to hold machine words would need to
11:58:15 <dzdcnfzd> specify endian-ness. What does it mean for a "word" to be little- or big-endian?
11:58:31 <dzdcnfzd> http://hackage.haskell.org/package/binary-0.8.8.0/docs/src/Data.Binary.Get.html#word16be
11:59:25 <dzdcnfzd> Secondly, imagine I have a list of bytes representing 16-bit words, and the first two are 0x0 0x1
12:00:24 <dzdcnfzd> A little-endian parsing of that word as an integer should interpret it as 2^15, whereas a big-endian should interpret it as 2^1
12:00:30 <dzdcnfzd> Sorry, 2^0
12:01:20 <dzdcnfzd> But from what I can see, the definition of word16le would just flip it so that it reads 0x1 0x0
12:03:52 <dzdcnfzd> https://paste.ofcode.org/idrTKHUxjzjJ9e3nvRh8VP
12:05:31 <phadej> sm[m]: how about having `1.18.0.0 ... 1.18.0.999` for development, and have the first release as 1.18.1?
12:06:10 <phadej> AWizzArd: no, Hackage won't accept tagged versions. There are no exceptions, if you have semantics in versioning scheme, all releases have to comply
12:07:46 <dzdcnfzd> Sorry, https://gist.github.com/anthonyrgreen/2a881e4e0e71834e28849e738cdea1d2
12:08:02 <phadej> note, I don't personally care about exact version numbers, so I simply ignore arguments like "it doesn't look nice"
12:09:05 <phadej> "marketing" and "machine readable" versions are better kept separate
12:10:32 * hackage faktory 1.0.1.1 - Faktory Worker for Haskell  https://hackage.haskell.org/package/faktory-1.0.1.1 (PatrickBrisbin)
12:15:07 <dzdcnfzd> Disregard, dumb
12:24:16 <monochrom> :)
12:32:22 <zeta_0> i built darcs with haskell to contribute to darcs, but ghcide is not working with the built darcs files? i have ghcide configured to use ghc865, maybe darcs uses a different version of ghc and that's why ghcide is not working? at this point i have no idea?
12:35:52 <zeta_0> ghcide is not even throwing an error, so it has not even been activated
12:51:45 <zeta_0> typo i build darcs with cabal: http://darcs.net/Development/GettingStarted
13:00:31 * hackage jira-wiki-markup 1.1.2 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.1.2 (tarleb)
13:11:01 * hackage matrix-sized 0.0.2 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.0.2 (kaizhang)
13:19:33 <jaqu3> Hi! Today I'm doing a bubble sort :3 Could someone help me with it :)  http://dpaste.com/1Z5RHN3
13:22:16 <tdammers> bubble sort is surprisingly difficult to implement in haskell, compared to some more efficient sorting algorithms
13:22:23 <[exa]> jaqu3: suggest splitting it into 2 functions, one that does the "single bubble" step, and one that just repeats the bubbling step enough times for the stuff to be sorted
13:23:05 <tdammers> note that you can pattern match on x:y:xs
13:23:28 <jaqu3> Thank You for help btw I have error http://dpaste.com/2W92R28 with infinite type :(  
13:24:01 <mniip> the error message is useless without the source
13:24:31 <tdammers> actually the relevant expression is in the error message
13:24:49 <tdammers> b : bubble (a : tail b)
13:24:54 <int-e> jaqu3: the 'b' is a list, you can't put it in front of the result. (It's a common naming convention to append 's' at the end of variables that are list)
13:24:57 <int-e> *s
13:25:18 <tdammers> the type of tail b is the same as b's type
13:25:31 <int-e> ... so many more things that will go wrong.
13:25:31 <tdammers> the type of a : tail b, then must also be the same as the type of b
13:25:51 <tdammers> and because bubble's type is [a] -> [a], the type of bubble (a : tail b) must be the same type as b's
13:26:10 <tdammers> but (:)'s type is a -> [a] -> [a]
13:26:16 <tdammers> which contradicts that
13:26:31 <tdammers> because we just established that the type of both sides of the outer : must be the type of b
13:26:46 <tdammers> and that's basically what the error message is saying
13:27:06 <tdammers> the type of b cannot be a list type of itself
13:27:24 <jaqu3> Thank you <3  
13:27:34 <jaqu3> I will think about that problem and solution <3
13:27:36 <jaqu3> Gnight <3
13:42:49 <zeta_0> i built darcs with cabal to contribute to darcs, but ghcide is not working with the built darcs files? i have ghcide configured to use ghc865, maybe darcs uses a different version of ghc and that's why ghcide is not working? at this point i have no idea?
13:43:01 <zeta_0> [zeta waits patiently for help]
13:44:31 <[exa]> how does 'not working' manifest precisely?
13:44:47 <[exa]> error message? or just does nothing?
13:44:59 <koz_> :t foldr
13:45:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:47:48 <monochrom> When used for lists, it becomes  (a -> b -> b) -> b -> [a] -> b
13:48:46 <Uniaika> hvr: ping! I would like to fix a bug in haddock for which I've opened an issue (#1134), but I would like to learn more about the innards of the codebase so I can suggest a PR. :) Could I borrow some of your time?
13:55:23 <tdammers> heh, compiling haskell stuff on a 1 GHz Atom CPU is quite slow
13:56:18 <tdammers> 4 cores at solid 100%
14:06:12 <zeta_0> [exa]: it just does nothing when i open a darcs haskell file
14:06:47 <[exa]> okay that's the worse variant
14:08:04 <zeta_0> [exa]: i hope i can eventually get ghcide working with darcs, ghcide really helps me understand the code
14:08:47 <fendor> zeta_0, what happens when you execute ghcide in the root of your project?
14:14:38 <tmontoya_> Login1st
14:15:12 <zeta_0> fendor: https://gist.github.com/zeta-00/807443d4927a59f9c76a6147333da84e
14:15:19 <tmontoya_> Welp not using that temp password lol
14:16:11 <fendor> zeta_0, cradle `Default` is not useful. Add an explicit `hie.yaml`
14:16:20 <fendor> does cabal build or stack build succeed?
14:17:44 <zeta_0> fendor: on the 2nd pastebin, i pasted the entire error: https://gist.github.com/zeta-00/807443d4927a59f9c76a6147333da84e
14:18:26 <zeta_0> fendor: it's a lengthy error
14:18:31 <fendor> zeta_0, I have still the same issue/questions
14:19:25 <fendor> Default cradle is not useful and how are you trying to compile the project and does it succeed?
14:19:47 <zeta_0> fendor: i normally don't like using hie.yaml(because i run into problems so stay at the default), but i'll give it a try
14:20:10 <zeta_0> fendor: yes, i built darcs with cabal, and no errors were thrown
14:20:36 <fendor> ok, so, `cabal build` succeeded?
14:21:01 <fendor> you can try if something like `echo "cradle: { cabal: {}} > hie.yaml"` already succeeds
14:22:23 <zeta_0> fendor: ghcide usually works out of the box without having to configure anything, but so far ghcide does not want to work with ghc, darcs, or xmonad
14:22:40 <fendor> for ghc, that is reasonable
14:22:41 <zeta_0> fendor: just ran: cabal new-build (i'm waiting)
14:22:48 <fendor> you can configure hadrian somehow, but I dont know why
14:22:50 <fendor> ok
14:23:29 <zeta_0> fendor: and, ok, i'll give that echo command a try in a bit when the build is finished
14:25:39 <zeta_0> fendor: one of the contributors of ghcide told me that they were fixing ghcide to work with ghc, and will be pushing the changes(hopefully soon), as for darcs and xmonad, i don't know
14:27:00 <zeta_0> fendor: ok: cabal new-build , worked without any errors
14:31:18 <zeta_0> fendor: https://gist.github.com/zeta-00/71ebdd3c43c84fb38a99a5ec087237aa
14:32:04 <Bish> can i have an class instance on a tuple?
14:33:36 <{abby}> sure
14:33:43 <Bish> how would that look
14:33:48 <Bish> i tried instance (Player, Piece) where
14:34:06 <Tuplanolla> Instance of what class?
14:34:12 <ChaiTRex> Bish: You seem to be missing the typeclass name.
14:34:14 <Bish> my own "Serialize"
14:34:26 <{abby}> try "instance Serialize (Player, Piece) where", thenm
14:34:28 <{abby}> s/m$//
14:34:31 <zeta_0> fendor: ok, i'm not sure what to do next, i'm reading these instructions here: https://github.com/mpickering/hie-bios
14:34:48 <Bish>     • Illegal instance declaration for ‘Serialize (Player, Piece)’
14:34:55 <zeta_0> fendor: oh, your one of the contributors, cool
14:35:21 <Bish> do i have reference player and piece someway?
14:36:10 <{abby}> turn on FlexibleInstances probably
14:36:24 <Bish> me :o?
14:36:28 <{abby}> yes
14:36:31 <{abby}> or you could implement it for Player, Piece, and pairs of serialisable things
14:36:53 <fendor> zeta_0, sorry, I meand `echo "cradle: {cabal: {}}" > hie.yaml`
14:36:54 <{abby}> instance Serialize Player where {...}; instance Serialize Piece where {...}; instance (Serialize a, Serialize b) => Serialize (a, b) where
14:36:59 <fendor> *meant
14:37:04 <{abby}> surely (Player, Piece) isn't the only pair you can serialise
14:37:25 <Bish> hm, okay, the syntax im trying right now is just not acceptable by default?
14:37:53 <Bish> how would i create a type from a tuple?
14:38:02 <{abby}> that's correct, Haskell 98 instances are of the form instance C (D a b c ...) where C is a class, D is a type constructor, and a, b, c are all distinct type variables (if I recall correctly)
14:38:18 <Bish> type playerPiece a b = (Player a, Piece b)? 
14:38:20 <Bish> i don't know
14:38:35 <Bish> what way i can make it a single type and i could write it, right
14:38:49 <Bish> s/what/that
14:41:40 <zeta_0> fendor: running the echo command does not return anything? https://gist.github.com/zeta-00/71ebdd3c43c84fb38a99a5ec087237aa
14:42:02 <ysangkok> Bish: do your Piece and Player type constructors take arguments?
14:42:13 <Bish> no!
14:42:54 <ysangkok> but i think they do in that type definition you just wrote above?
14:43:19 <zeta_0> fendor: it looks like the generated hie.yaml file fixed some of the errors, so progress: https://gist.github.com/zeta-00/71ebdd3c43c84fb38a99a5ec087237aa
14:43:28 <ysangkok> i think you can just write "type PlayerPiece = (Player, Piece)"
14:43:34 <Bish> uh okay
14:43:53 <ysangkok> gotta differentiate between type and data constructors in haskell as it currently is
14:44:00 <Bish> that gives "malformed head"
14:44:45 <ysangkok> works fine here
14:44:59 <{abby}> You can't make an instance of a type synonym without turning on TypeSynonymInstances
14:45:16 <{abby}> Bish: **surely** (Player, Piece) isn't the only pair you can serialise?
14:45:19 <{abby}> instance Serialize Player where {...}; instance Serialize Piece where {...}; instance (Serialize a, Serialize b) => Serialize (a, b) where
14:45:29 <Bish> so far
14:45:33 <Bish> yes, im writing the first instance
14:47:04 <Bish> ohyeah i was trying to name the type playerPosition
14:47:05 <Bish> poor me
14:47:26 <Bish> and flexibleinstances makes the tuple instance possible, thank you
14:49:48 <zeta_0> fendor: so why is ghcide still not working with darcs haskell files? please excuse my ignorance, i don't understand ghcide to well
14:50:44 <{abby}> Bish: you don't need to enable FlexibleInstances if you make your instance for tuples as general as possible
14:51:40 <fendor> zeta_0, I dont know, i dont know the project. I can take a closer look tomorrow
14:53:02 <fendor> and I mean the darcs project, what their build configuration is, etc...
14:53:14 <zeta_0> fendor: ok, thanks for the help, i'll analyze the darcs project code to see if i can find what's causing the errors
14:53:48 <fendor> it should work, but well, sometimes there are some problems
14:54:35 <zeta_0> fendor: ok, and i'll ask you about this tomorrow, if you have some free time to spare
14:56:09 <Bish> {abby}: i can also typealias that tuple that worrks for me atleast
14:56:18 <{abby}> face, meet palm
14:56:29 <Bish> because of me :o?
14:59:28 <{abby}> yes. consider what's going to happen when you try to serialise a tuple that isn't (Player, Position)
14:59:41 <{abby}> you're going to have to write another instance for serialising tuples of (Whatever, Else) instead of composing existing instances
15:01:26 <Bish> yeah sure, but i don't want to go deeper
15:01:47 <zeta_0> ok, i give up now, i'm going to spend the rest of the day coding
15:01:59 <Bish> that does not sound like giving up
15:04:04 <zeta_0> ya
15:04:14 <{abby}> Bish: by insisting on your monomorphic Serialise (Player, Position) instance you've gone deeper. Now you need a language extension for your code to compile
15:04:30 <Bish> but it works without if i typealias it :o
15:06:34 <{abby}> huh, since when is TypeSynonymInstances on by default
15:06:46 <Bish> :}
15:07:29 <{abby}> i guess gone are the days where ghc can be considered a haskell compiler in its normal state
15:07:59 <Bish> because of that single feature?
15:09:06 <{abby}> from the Haskell 2010 report: "The type (T u1 … uk) must take the form of a type constructor T applied to simple type variables u1, … uk; furthermore, *T must not be a type synonym*, and the ui must all be distinct. "
15:09:20 <Bish> well that's not saying "why"
15:10:26 <mmachenry> I am looking to fix issues with my Docker/Haskell build. I'd really like to keep it simple and not have to have a stack.yaml and .cabal file and subdirectories if possible. But I think moving to an accepted common build process is most important as well as fixing the weird issue I have with Alpine not liking my binary. Would anyone like the take a look?
15:10:29 <mmachenry> https://gist.github.com/mmachenry/b20c3baed66e6ddfcfea5ba05cbbeac1
15:12:56 <Bish> well i was wrong, synonyms do not work
15:14:00 <{abby}> oh good
15:14:15 <Bish> my linter wasn't just as quick
15:15:28 <{abby}> now, weigh your options. a) make your instance work in more cases b) enable TypeSynonymInstances and define a type synonym then an instance on that c) enable FlexibleInstances and define the instance for (Player, Position) directly d) make a new data type containing a Player and a Position
15:16:03 <Bish> thing is, the serialization depends on 2 types 
15:16:12 <Bish> Knight of white is k while Knight of black is K
15:16:20 <Bish> i can't serialize them on their own
15:17:05 <{abby}> then you shouldn't be using a tuple in the first place
15:17:22 <Bish> what would i do
15:17:29 <{abby}> make an actual type for it
15:17:31 <Bish> a turn consists of player, piece, position
15:17:43 <Bish> a serialized piece is just player and piece
15:18:14 <Bish> without it's just a tuple, and i don't know if i find an abstraction that fits :o
15:20:02 <{abby}> data Thing = Thing { player :: Player, piece :: Piece } but replace Thing by a descriptive name for the player/piece subset of a turn
15:20:22 <Bish> hm, okay
15:20:28 <Bish> is that also a performance consideration?
15:20:46 <{abby}> not really, no
15:20:50 <Bish> even if i call that thing just conctination of both types?
15:21:01 <Bish> i mean, is it still a good idea then
15:21:25 <{abby}> I'd consider knowing a piece without knowing its owner is kinda useless, maybe change the enumeration data Piece = Rook | ... | King to data PieceClass = ... and data Piece = Piece { name :: PieceClass, owner :: Player }?
15:21:27 <Bish> i could just curry the instance function :p and it would be the same thing
15:21:36 <Bish> absence: well okay
15:49:22 <mmachenry> Does anyone have a recommended process for running simple Haskell scripts in a Docker container? I have one setup I'm not happy with https://gist.github.com/mmachenry/b20c3baed66e6ddfcfea5ba05cbbeac1
16:03:22 <zeta_0> what does lifA2, *> and <* stand for in the Applicative type class?
16:03:41 <zeta_0> or what are their names?
16:04:17 <zeta_0> <*> is the applicative operator, right?
16:04:18 <phadej> A stands for applicative, <* and *> are "halves" of <*>
16:04:18 <Axman6> liftA2 is just lift applicatively a function over two applicative things
16:04:45 <koala_man> mmachenry: I don't know about Stack, but for Cabal I had a Docker image that would 1. Copy the .cabal file, 2. Install dependencies, 3. Copy the source files, 4. Build. This way, when I changed the source files, it wouldn't have to start building dependencies from scratch
16:05:18 <Axman6> <*> is often called ap, because that was its name under Monad - <* is the operator which takes two actions and runs them, but only returns the result from the side it's pointing to
16:05:32 <koala_man> Maybe you can similarly run a dummy file first so that stack can download/install all the stuff it wants first 
16:05:34 <Axman6> :t (<*)
16:05:35 <lambdabot> Applicative f => f a -> f b -> f a
16:05:42 <Axman6> :t (*>)
16:05:44 <lambdabot> Applicative f => f a -> f b -> f b
16:06:16 <Axman6> so you  can do things like: putStr "Enter your age: " *> getLine
16:06:33 <zeta_0> phadej Axman6 thanks, so by ap you mean: applicative operator? i just want to make sure that i am naming these functions correctly
16:06:45 <phadej> ap is short for `apply`
16:06:50 <Axman6> I have a feeling the work ap came from apply
16:06:57 <phadej> :t ($)
16:06:58 <Axman6> :t (<*>)
16:06:58 <lambdabot> (a -> b) -> a -> b
16:06:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:07:02 <phadej> :)
16:07:10 * Axman6 high fives phadej
16:07:10 <solonarv> :t ap -- for comparison
16:07:11 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:09:11 <zeta_0> 'i though ap was applicative, but it's apply, thanks for clarifying
16:09:42 <zeta_0> well what is the difference in meaning between apply and applicative, they seem similar?
16:10:41 <solonarv> I guess "applicative" is an adjective that means something like "able to apply"?
16:10:50 <solonarv> that's probably where the term comes from
16:11:04 <Axman6> something which may be applied is applicative
16:12:55 <zeta_0> ok, that makes sense, thanks for the help
16:14:20 <monochrom> Yes <*> is "like apply"
16:15:40 <zeta_0> i am going to call <*> the applicative operator because i already call $ the apply operator
16:17:07 <solonarv> if you're going to use lengthy names for them, I'd suggest being precise:
16:17:32 <solonarv> $ is "the function application operator", <*> is "the applicative function application operator"
16:19:21 <zeta_0> solonarv: ok, thanks, now i got the terminology down much better
16:21:24 <crestfallen> hi is this correct? I was surprised to find that applicative is non-commutative:     x <*> (*10)  /=  (*10) <*> x   
16:22:23 <crestfallen> I guess <$> is also non-commutative so it makes sense
16:22:41 <crestfallen> just got the term mixed up with associative..
16:24:37 <lyxia> crestfallen: right. similarly, ($) is not commutative
16:26:43 <crestfallen> lyxia, thanks , very strange, not sure why, I had these <x> infix operators as commutative. 
16:27:21 <crestfallen> it actually clarifies a lot. fmap as a prefix function takes the f first. folds as well..
16:28:50 <crestfallen> to understand monads, it helps to know that!
16:31:57 <solonarv> crestfallen: the types aren't even right for it to be commutative! (in general, that is)
16:35:57 <crestfallen> solonarv, the rhs is a tree: Node (Leaf 2) (Node (Leaf 3) (Leaf 4))
16:36:57 <crestfallen> x =  Node (Leaf 2) (Node (Leaf 3) (Leaf 4))    sorry I was asking generally..
16:43:13 <fog> here is (,) expressed using the extensible datatype machinery; https://gist.github.com/fog-hs/19abbf2ee8cf1f9f0c39abf0772da34e#file-pair-hs
16:50:24 <zeta_0> so *> and <* would be called the: right-side left-side applicative function application operators?
16:51:34 <Tuplanolla> You can use any grunt to refer to them and you'll still be understood.
16:52:26 <Axman6> I roughly think of them as "return left" and "return right" but in an applicative context
16:54:16 <zeta_0> thanks, now the Applicative type class makes much more sense now
16:55:29 <Axman6> I find that writing parsers is something that _really_ makes it make sense, lots of parsers can be written nearly entirely applicatively
16:57:18 <zeta_0> Axman6: ok, i'll take a look at the parsers implemented in haskell
16:58:04 <Axman6> Person <$> parseFirstName <* string " - " <*> parseSecondName <* string ";\n" <*> (Phone <$> optional (areaCode <* string " - ") <*> parsePhoneNumber
16:58:44 <jackdk> I got a lot out of reading "Applicative Programming with Effects", and working through the difference between the applicative vs. monadic "if" in that paper (particularly over Maybe)
17:02:26 <zeta_0> jackdk: thanks, i just downloaded the pdf of that paper
17:04:41 <dsal> zeta_0: If you want to watch it, this might be interesting:  https://www.youtube.com/watch?v=N9RUqGYuGfw
17:06:50 <zeta_0> dsal: cool, that looks interesting
17:27:54 <zeta_0> what is the command to look at the code inside a module?
17:28:53 <ChaiTRex> @src Maybe return
17:28:53 <lambdabot> return = Just
17:33:24 <solonarv> there is no such command
17:33:53 <MarcelineVQ> you can use :browse to see signatures at least
17:37:37 <zeta_0> ok, thanks
19:27:50 <koz_> Is there a package which provides a 'fail :: (MonadFail m) => Text -> m a'? I.e. a fail method which consumes Text, not String.
19:30:14 <solonarv> koz_: perhaps, but it'd just be a wrapper around 'Prelude.fail . Text.unpack' anyway
19:30:57 <koz_> solonarv: Fair.
21:21:32 * hackage pvar 0.1.1.0 - Mutable variable with primitive values  https://hackage.haskell.org/package/pvar-0.1.1.0 (lehins)
21:23:37 <u0_a183> is anybody out there?
21:26:30 <Axman6> No one 'ere but us cows. moo
21:34:04 <u0_a183> nice to moo-t you
21:57:59 <stretchp> are there any good haskell modes for emacs for a beginner learning haskell?
22:12:45 <justsomeguy> How can I write a binary numeric literal, like 0b1010 == 10?
22:13:29 <MarcelineVQ> enable https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#binary-integer-literals
22:14:30 <Axman6> enable NumericUnderscores too and you get very pleasant literals: 0b0010_1010 == 42
22:15:37 <justsomeguy> Hmm, cool. There are so many of these extensions that I wish were turned on by default.
22:16:30 * justsomeguy just found out about using OverloadedLists to write Maps in a concise way yesterday.
22:16:47 <justsomeguy> Thanks MarcelineVQ :)
22:17:13 <justsomeguy> Err... Sets, that is, not Maps
22:17:16 <Axman6> yeah I use OverloadedLists a lot to write Objects for Aeson
22:32:42 <hololeap> OverloadedMaps could be cool
22:34:04 <Axman6> well OverloadedLists doe a lot of what that would, you can already create maps using [("key",Value)] :: Map String Value
22:34:40 <hololeap> true, but the overlap between IntMap, HashMap, Map, etc. can't be ignored
22:35:43 <Axman6> I don't understand
22:36:00 <hololeap> one map to rule them all
22:36:32 <hololeap> a single interface for multiple types of maps
22:44:06 <iqubic> Does Map have an IsList instance?
22:44:27 <Axman6> I believe so, HashMap does
22:45:33 <koz_> iqubic: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#t:Map
22:45:35 <koz_> So yes.
22:47:31 <iqubic> For maps with a single key value pair is the overloaded list way of creating a map faster than just using the singleton function?
22:49:06 <hololeap> instance (t ~ Int) => IsMap t (IntMap) ; fromMap = IM.fromList . M.toList
22:49:10 <Axman6> probably not, it might take whole nanoseconds longer
22:49:13 <hololeap> that's the best i could come up with
22:49:24 <hololeap> so this might be a half-baked idea
22:49:36 <iqubic> hololeap: What are you trying to do here?
22:50:06 <hololeap> emulate IsString and IsList, but for maps
22:50:36 <iqubic> IsList already exists for Maps.
22:53:00 <hololeap> so a map can be converted to a list ... and converted back to another map
22:54:50 <hololeap> so the IsList should be sufficient... no need for IsMap ... is that what I should be taking away from this?
23:06:39 <MarcelineVQ> IsList isn't an interface to multiple list types, and IsList isn't for conversion, IsList is for letting you use the list literal syntax for your type. There isn't a map literal syntax :>
23:11:36 <hololeap> the functions of lookup, insert, delete, etc seems to be pretty universal across different types of maps, so doesn't it make sense that there should be some kind of universal interface?
23:15:23 <koz_> hololeap: What's not universal are the constraints.
