00:02:56 <aviD> Be aware ghcide does not work with cabal 3. I tried switching a few days ago. Hie does work.
00:03:39 <yushyin> ghcide also does not work properly with stack 
00:04:21 <yushyin> ghcide was the very reason I switched from stack to cabal
00:26:25 <MarcelineVQ> hmm that's supcicious, wasn't cabal 3 out long before ghcide?
02:05:51 <Uniaika> MarcelineVQ: yes but the ecosystem took so much time to adapt
02:13:16 <MarcelineVQ> but is " ghcide does not work with cabal 3" true?
02:15:04 <Uniaika> I don't know about that, but that wouldn't be surprising
02:16:52 <MarcelineVQ> I would be surprised :>
02:18:15 <merijn> It works fine here. It doesn't support all possible setups, but it works as well with cabal 3.0 as with cabal 2.4
02:19:50 <aviD> Technically it's broken if you add a dependency. https://github.com/TomMD/ghcide-examples#ghcide-fails-for-single-target-projectcabal-builds-that-have-hackage-dependencies
02:24:00 <yushyin> i would say this is just typical for haskell tooling, it works ... occasionally :P
02:28:21 <merijn> It works with those cases, if you use a hie.yaml file
02:28:32 <merijn> Well, some of those cases
02:29:32 <merijn> Oh, I bet I know why he has issues with hackage dependencies
02:29:45 <merijn> I bet he disabled/didn't enable .ghc.environment files
02:30:14 <merijn> Because single target projects with hackage dependencies work perfectly fine here and have since the first ghcide release
03:29:08 <aviD> :merijn I believe(untested) v1-style works. Just tried setting ` --write-ghc-environment-files=always` no luck. What GHC and Cabal are you on?
03:32:24 <merijn> aviD: GHC 8.6.5 and cabal 3.0
03:33:01 <merijn> I use v2-build for everything and for my single package projects it "Just Works" without even a hie.yaml
03:52:10 <aviD> How do you enable `ghc-environment-files`? They are off by default with Cabal 3
03:52:54 <merijn> aviD: Yeah, because lots of people complained about them...
03:53:05 <merijn> aviD: Add the following line to ~/.cabal/config "write-ghc-environment-files: always"
03:57:56 <raoul> Is there anyway of combining a uniplate traversal with zippers? I'd like to be able to do a pattern match search with universeBi on an AST but then zoom out onto the surrounding context but can't figure out if there's a way of doing this
03:58:10 <raoul> I could just pattern match on the surrounding context but that gets a bit messier and verbose
03:58:26 <aviD> merijn: hmm, no luck. Could you post the output of `ghcide` in `ghcide-examples/broken-single-target-project-dot-cabal-with-hackage-deps`? 
04:19:02 * hackage hs-speedscope 0.2 - Convert an eventlog into the speedscope json format  https://hackage.haskell.org/package/hs-speedscope-0.2 (mpickering)
04:26:09 <merijn> aviD: Maybe later when I have some time
04:26:31 <aviD> Thx
04:28:47 <merijn> What's the ettiquette for handling messy PRs? Some of these commits need to be cleaned up before I can merge the whole thing, but I'm not sure what the best way to do that is. Clone the branch, update them to the necessary quality and then clobber the existing PR with the new version? Adding (or having them add) new commits that add the necessary changes will still clutter up the history
04:29:35 <Rembane> merijn: They can squash the commits into something nice before pushing them if they're git-good enough.
04:30:23 <merijn> Rembane: I don't want all commits squashed, though
04:30:49 <Rembane> merijn: not all, just the messes. Like, they can enhance each commit that needs enhancement. 
04:31:04 <Rembane> merijn: But this is a bit complicated
04:31:41 <merijn> Rembane: Yeah, but it's probably easier if I get them up to my standards anyway
04:31:49 <Rembane> merijn: Yeah. 
04:32:20 <merijn> I just dunno a good way to do that, manually making new commits based on those strips of their name which seems a bit rude
04:32:50 <merijn> I guess the clone, edit history, force push PR is probably the "best" way to go
04:33:00 <Rembane> IMO it is 
04:33:32 <suppi> may I ask why don't you want to squash everything to one commit?
04:34:02 <merijn> suppi: Because the PR has several independent things which should just be independent commits
04:34:32 <suppi> Then maybe they should be in separate PRs in general or is this not an option here?
04:35:13 <merijn> suppi: The commits are one single feature. THe conclusion is just "Github UI/workflow sucks"
04:35:27 <merijn> suppi: (as in, all the commits together, are one single thing)
04:35:48 <merijn> So opening individual PRs is 1) annoying work, 2) kinda pointless since they'd dependent on each other
04:35:59 <suppi> hmm, yeah i definitely understand the issue here :\
04:36:25 <merijn> Basically "when is Pijul 1.0 coming out together with a patch-based collaboration site?!"
04:36:56 <suppi> why would patches help? is it with reordering commits?
04:38:11 <merijn> suppi: Patch based workflows make it much easier to approve/change/revise individual patches within a "PR" of a set of patches
04:38:29 <merijn> suppi: In github there's no sane way to go "these 5 commits in the PR are fine, these 3 need work"
04:38:44 <Cale> This is something that I feel in general is seriously messed up about git. You should never be encouraged to discard or falsify the history of your version control system, but that's basically what rebasing is.
04:38:45 <merijn> Because that doesn't make sense in a DAG-based setting
04:39:06 <merijn> While that is intuitive and simple in patch based systems
04:39:58 <Cale> I want a VCS that could be usable and good even if we were to build in editor integrations so that all undo states go into version control as well.
04:41:15 <phadej> you are mixing the fined grained single contributor history vs. "massive" projects development history
04:41:34 <phadej> single contributor line edits two years ago are completely irrelevant
04:42:31 <Cale> Maybe, but disk space is pretty cheap.
04:42:58 <phadej> human (waiting time) and cpu power for `git bisect` isn't
04:43:29 <Cale> If the system is designed well, neither of those things should be too adversely affected.
04:43:50 <merijn> Cale: With patch based approach like I suggested, you'd basically keep a "curated" nice central history and all the messy bits can still be kept
04:44:06 <aviD> Off topic: any one know if Pijul is still being developed. I heard there was a rewrite under way awhile ago, but no updates
04:44:06 <Cale> For one, all states of the repository that have been verified to compile should be flagged as such.
04:44:41 <Cale> Secondly, just because we're recording all that history doesn't mean you should always have to download it all.
04:44:47 <merijn> aviD: It is, I see updates on twitter every few weeks, they're currently working on the v1.0 version
04:45:22 <Cale> and it should be possible to get a reduced history that only shows major milestones, or points at which things got completed
04:45:36 <merijn> aviD: Last tweet is from March 7: https://twitter.com/pijul_org/status/1236244028615806977
04:46:01 <phadej> I think that GitHub-like services made git "worse". If you think it as a system for preparation of patches to be send over email, it's perfect.
04:46:47 <Cale> Except that sending patches manually over email isn't perfect ;)
04:47:00 <Cale> Yeah, it's definitely designed around that though.
04:47:11 <__monty__> Doesn't the fact that it's based on versioning rather than patches make it awkward anyway?
04:47:35 <phadej> I think that not really worse than GitHub suggested workflows
04:48:10 <phadej> GitHub encourages proposing low-quality patches
04:50:19 <phadej> __monty__: it's operational system, my mental model is that Git is for C-thinking people, and pijul/darcs is for Haskell (incl. steep learning curve)
04:51:23 <phadej> but I cannot comment properly, because I don't know darcs nor pijul beyond "these are commands which happen to do what I want"
04:52:00 <tdammers> Cale: that's why git automates part of the process :)
04:52:36 <Cale> tdammers: Yeah, it's just that it's not designed around that automation
04:52:43 <tdammers> IME, though, git is particularly good for a thoroughly "bazaar-style" cooperation model
04:53:23 <tdammers> a "git repo" isn't very monolithic; you can pull from a pluralistic mess of sources and combine that into your own working copy, and no other clone necessarily needs to be structured the same
04:53:34 <tdammers> git is very malleable that way, for better or worse
04:53:56 <tdammers> compare that to models like mercurial, where essentially all clones of a repository have the same branch structure
04:54:28 <Cale> Yeah, that flexibility is something I don't especially find helpful personally. It's more just a source of confusing problems.
04:54:50 <tdammers> it's a sharp tool
04:54:56 <tdammers> so people get hurt
04:55:27 <Cale> Just sync all my shit continuously pls.
04:55:53 <Cale> and then help merge different tracks of development when the time comes to do that
04:56:02 <tdammers> I kind of like git's model for chaotic bazaar-style projects
04:56:33 <phadej> I like it too, and find the centralization (like having wip/* branches in "blessed" repo) awful
04:57:08 <tdammers> "hey, I have an experimental feature on this branch here, wanna give it a spin?" - and then I can selectively pull that branch into a local branch on my end, play with it, see if it merges, whatever; if I like it, I push it upstream, if not, I'll just delete it
04:57:45 <tdammers> phadej: case in point, the "wip/" thing is often just done because the "central" repo is a convenient place to push your stuff so you can continue working on another machine
04:57:57 <__monty__> Sadly that only works with centralized hosting pretty much : /
04:58:02 <tdammers> then again, if you need that, the proper way to do it would be to use a self-hosted repo somewherew
04:58:21 <tdammers> push all your wip branches there, and push the "real" changes upstream when you're ready to
04:58:25 <phadej> tdammers: yes, except your wip branch is shared with all dozens/hundreds contributors
04:58:35 <phadej> that's silly
04:58:38 <tdammers> phadej: exactly, hence the "proper" way I just described
04:58:58 <tdammers> frankly, the whole "central repo" idea is absolutely terrible for open-source dev
04:59:06 <tdammers> github basically ruined things for everyone that way
04:59:22 <tdammers> and I believe they did it knowingly, because it benefits their business model
04:59:26 <phadej> obviously. Corporate world like central repositories :)
04:59:27 <gentauro> tdammers: just because people use git wrong, doesn't mean that it's bad ;)
04:59:54 <merijn> gentauro: It does, though
04:59:57 <merijn> Same reason C is bad
05:00:01 <Cale> I suppose I'm thinking moreso about closed source development with tight-knit teams, and where the time that has been put into work is valuable and any potential risk of losing it sucks.
05:00:11 <merijn> Over time people will do the worst things tools allow
05:00:14 <gentauro> merijn: if C is bad, so is Assembly ...
05:00:16 <tdammers> gentauro: git is alright. it's github and the "github way of doing git" that offends me
05:00:16 <__monty__> Imo self-hosted repos aren't a solution. Far too much setup and maintenance. Distributed git is where it's at.
05:00:26 <gentauro> tdammers: oh, I see
05:00:26 <merijn> gentauro: Assembly is honestly infinitely better than C
05:00:32 <gentauro> I dislike github
05:00:49 <yushyin> It is good for issue tracking ...
05:00:52 <gentauro> so I deleted my account (I was developing at GitLab anyway so ...)
05:00:56 <merijn> Assembly has far less undefined/ambiguous/confusing behaviour than C does
05:01:23 <merijn> I can reasonably reason about assembly code (it becomes hard at scale, but not much more so than C)
05:01:27 <gentauro> merijn: isn't Assemply architecture specific?
05:01:33 <Cale> If only it were guaranteed to be a complete description of what was possible with machine code.
05:01:33 <tdammers> __monty__: here's how I set up a self-hosted repo: ssh git@server 'git init --bare reponame.git'; git remote add mine server:reponame.git; git push mine -u
05:01:34 <merijn> Reasoning about C at any scale is impossible
05:01:50 <phadej> yushyin: not really an improvement over e.g. Jira
05:01:51 <tdammers> as long as you have ssh access for git@server, this is literally all it takes to self-host
05:01:54 <merijn> gentauro: Sure, but nobody writes portable C anyway (unless by accident)
05:02:04 <gentauro> merijn: good point
05:02:34 <merijn> gentauro: Did you know you can't portably store function pointers in a void*, for example? :p
05:02:42 <gentauro> tdammers: I use something similar to host my own repos on my local server (not accessible from outside)
05:02:43 <phadej> one good thing about GitHub is that it is quite fast
05:02:46 <__monty__> tdammers: Yeah, that's too much. How many people just starting out contributing to foss have access to a server let alone one reliable enough for collaboration with others?
05:02:46 <merijn> They're not guaranteed to fit
05:02:54 <Cale> To be fair, porting assembly code is probably going to require a lot more work than porting C code. They're both a lot of work, but...
05:03:05 <yushyin> phadej: I don't know much about Jira, I only know that's a big java monster or so
05:03:09 <merijn> __monty__: VPS costs <$5 per month, though :p
05:03:26 <Cale> I don't want to have to worry about reorganising how a bunch of code uses registers because there are a different number of those available, for example.
05:03:45 <merijn> Cale: Porting C is only less work IFF there's already a C compiler
05:03:52 <Cale> Well, sure
05:03:52 <__monty__> merijn: That's too much if all you'd use it for is hosting this git repo for this project I looked into contributing to a couple months back.
05:04:11 <merijn> Anyway, git is the unix of version control
05:04:20 <phadej> __monty__: note, you need "own wip server" if you work on multiple different machines
05:04:21 <merijn> Just barely good enough to hold us back for decades to come
05:04:27 <phadej> I guess that's already not that common
05:04:39 <phadej> shows "serious envolvment"
05:05:01 <merijn> Cale: Everything's an x64 anyway ;) *duck*
05:05:02 <phadej> otherwise the single local clone is all you need
05:05:06 <__monty__> phadej: I'm not sure that's true. Owning your own computer is a privilege many people assume but not universal IME.
05:05:09 <tdammers> __monty__: you don't *need* such a server. that's just for shoving your own commits around.
05:05:29 <merijn> __monty__: How many people without their own computer can afford to contribute to open source *at all*?
05:05:39 <tdammers> __monty__: and if you're only ever going to work on it on one machine, just make a local clone and call it a day
05:05:42 <merijn> Seems like a weird argument to make
05:05:44 <__monty__> Most of them if they're kids.
05:06:49 <phadej> and how GitHub help kids to work on open source?
05:07:24 <tdammers> also, I'm not super opposed to using github as a dumb git hosting service; the problem is that once you put it on github, people start using other github functionality on it as well
05:07:29 <__monty__> By providing a free hosting solution to share their own projects.
05:07:46 <phadej> what tdammers told
05:10:16 <phadej> Luckily to myself, Finland is very exceptional country. There is non-profit which gives it members shell "without strings attached" for 40eur a year. Something I was already able to afford in high school (back then it was even less, inflation)
05:10:40 <phadej> I'd like to know if there are similar non-profits in other countries
05:10:48 <phadej> so you don't need to rely on GitHub if you don't want to
05:11:36 <phadej> that organisation also doesn't scan your emails like gmail does :)
05:12:07 <[exa]> in cz we have vpsfree, they are giving 1 paravirt server + 1 IP address for similar amount of cash
05:12:39 <[exa]> not much care about content either, unless you damage the network somehow
05:15:16 <phadej> I think I cannot put commercial content onto those services
05:15:34 <phadej> but OSS nor my blog aren't, so ...
05:15:38 <tdammers> how does one enforce that? "commercial" is a bit of an ill-defined concept to begin with
05:15:52 <tdammers> e.g., if I do paid work for a nonprofit, is that commercial?
05:16:11 <phadej> tdammers: I think it's up to organisation meeting to decide
05:16:31 <phadej> convention*
05:25:51 <suppi> tdammers, what kind of functionality do you think people shouldn't use on github?
05:26:09 <tdammers> suppi: pull requests, for starters
05:26:41 <suppi> may i ask why?
05:26:53 <tdammers> suppi: but also the github clone functionality, because it introduces a hierarchy ("forked from") that shouldn't be there, and enables possessive / authoritarian power structures in open source projects
05:27:29 <tdammers> (i.e., where someone is the "maintainer" not because there is community consensus about their clone being the one to pull from, but because they hold the keys to the "official" repo)
05:28:29 <opqdonut> pull request are great for drive-by contributions, I use them a lot when fixing small things in libs that I use
05:28:56 <opqdonut> but they're not perfect for everything of course
05:29:09 <suppi> do you find that being a hindrance often?
05:30:04 <suppi> I feel like github and PRs really help the discoverability of things
05:31:50 <suppi> and drive-by contributions as opqdonut said
05:36:02 <merijn> suppi: But then you get the issue that started this conversation
05:36:11 <merijn> drive-by contributions that need to be improved
05:36:21 <merijn> With no good tooling/support for doing so
05:37:41 <suppi> yeah it's a double edged sword
05:39:10 <__monty__> merijn: I usually just steamroll force-pushes over their branch if it needs a lot of quality improvement of both code or commits.
05:40:07 <phadej> ... but if the reverse communication (feedback) is not required, than `git format-patch` is really as good
05:40:12 <phadej> just that it's not web interface based
05:40:16 <opqdonut> I've sometimes made a new PR with a "closes #123" comment
05:40:29 <opqdonut> where #123 is the original PR I don't want to merge
05:40:40 <opqdonut> i.e. treating the PR as an issue with an attached patch
05:40:59 <phadej> Oh, good to know that you can close PRs via commit messags too
05:41:13 <phadej> never occurred to me to try
05:43:42 <__monty__> opqdonut: Then you have the problem merijn brought up though. Erasing people's attribution by authoring your own commits takes away their "reward" and doesn't motivate repeat contributions.
05:44:07 <opqdonut> __monty__: sure, it's a tradeoff
05:44:45 <opqdonut> if one is "just" repackaging the commits then leaving the author: as-is and just updating committer: is one more option
05:44:54 <opqdonut> also co-authored-by: which is supported by some tools
05:45:05 <opqdonut> (e.g. github)
05:46:09 <Gurkenglas> Why would https://hackage.haskell.org/package/hashable-1.3.0.0/docs/Data-Hashable.html#v:hashWithSalt have that argument order :c
05:46:30 <Gurkenglas> Oh wait, that's the right order, I mixed up what the arguments do
05:46:44 <Gurkenglas> Well, at least I can pat myself on the back for being confused by fiction ^^
05:58:50 <Gurkenglas> How can you usually put fmap concat . traverse f into form _ $ f?
06:01:28 <srk> @pl fmap concat . traverse f
06:01:28 <lambdabot> fmap join . traverse f
06:08:38 <merijn> WTF is this? https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-C-Types.html#t:CTime
06:09:05 <merijn> "CTime Int64", but no instance of Integral and (weirdly) an instance of Real? >.>
06:11:15 <Uniaika> merijn: it's "git blame" time!
06:18:02 <Sden> Hi all, while reading learnyouahaskell, I'm having some problems understanding how to make the monad instance of Prob combine duplicates. See code here: https://pastebin.com/EZ1CnSTU
06:19:12 <merijn> Sden: 'flatten' has a constraint that 'a' has an 'Eq' instance
06:19:56 <merijn> Sden: Which means you can't use flatten in the Monad instance, since you can restrict Monad instances like that
06:20:28 <Sden> ok, and could I add the type constraint on the newtype? 
06:20:40 <zincy_> How can I do the equivalent of `fromJSON` but return an Either instead of a Result?
06:20:50 <merijn> Sden: The current type of 'flatten' is incompatible with *any* Monad instance. So, no.
06:21:09 <merijn> zincy_: By writing "Result a -> Either e a"? :p
06:22:24 <Sden> merijn: so the only thing I can do is run my 'nubBy' function manually?
06:22:37 <merijn> I don't know what you mean by that?
06:23:00 <merijn> Sden: Monad instance cannot make assumptions about the values inside (such as 'Eq' instances)
06:23:19 <zincy_> merijn: :)
06:23:37 <Sden> merijn: ok makes sense, but then my question is: how do I get rid of duplicates in 'flipThree' ?
06:25:00 <merijn> I'm not really sure, because I dunno what it's supposed to do
06:29:38 <Ariakenom> Sden: you can use flatten explicitly in flipThree
06:33:02 <Ariakenom> or rather concatUniq, but I think you missed adding the duplicate probabilities?
06:34:31 <Sden> ariakenom: true, was still working on it :D  ok i'll try thx
06:35:19 <Ariakenom> no not that one either ... I meant just the nub part
06:37:24 <Ariakenom> Sden: something of type Eq a => Prob a -> Prob a
06:43:16 <Sden> @ariak
06:43:16 <lambdabot> Unknown command, try @list
06:43:31 <Sden> Ariakenom: got something that works: `combine = Map.toList . foldr (uncurry (MapStrict.insertWith (+))) Map.empty`
06:46:14 <Ariakenom> Sden: nice. you may want https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#v:fromListWith
06:49:13 <Sden> Ariakenom: yep, much nicer!
06:57:02 * hackage feed 1.3.0.1 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-1.3.0.1 (jkeuhlen)
07:07:02 * hackage dobutokO2 0.16.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.16.0.0 (OleksandrZhabenko)
07:10:44 <frdg> what up with the bot above? How does it decide what libraries to show?
07:12:00 <merijn> frdg: When new versions are uploaded
07:12:36 <frdg> cool!
07:13:35 <frdg> So Haskell is pretty cutting edge cause that bot goes off all day
07:15:29 <merijn> Is there some kind of pragma to indicate a module doesn't compile on some platforms?
07:17:01 <merijn> like {-# WARNING #-} or {-# DEPRECATED #-}, but an error
07:18:23 <lyxia> Maybe there's some CPP macro for it
07:18:25 <sm[m]> I'm not sure that bot reports everything
07:19:16 <sm[m]> I think it's more of a sampling, when it's running
07:22:09 <lyxia> I think it's everything
07:23:17 <sm[m]> lyxia: compare https://hackage.haskell.org/packages/recent .. I see only the most recent two items announced recently
07:23:41 <sm[m]> also even when it's running, I've seen it skip things
07:23:46 <sm[m]> perhaps intentionally
07:26:02 <lyxia> I see the other items higher up the history.
07:26:18 <Uniaika> merijn: I think I would use CPP yeah :/
07:26:30 <mniip> it is all packages
07:26:32 <troydm> sorry for dumb question but how can I use a module which is hidden, I get compile error saying that module is hidden inside package, but I absolutely need to use some function from hidden module
07:26:34 <troydm> ?
07:26:37 <mniip> all of the "recent" items have been announced
07:26:42 <sm[m]> oh really, let me try an irc client
07:27:14 <mniip> it just happened, you know, earlier
07:27:41 <Uniaika> troydm: did you add the package to which the module belongs to your project.cabal or package.yaml?
07:27:51 <troydm> Uniaika: yes
07:27:57 <Uniaika> oh, that's worrying.
07:28:05 <Uniaika> wait
07:28:11 <Uniaika> you're talking about a module that is not exposed, right?
07:28:40 <Uniaika> if you really really need the functions inside it, copy-paste the code, and ask the maintainer to expose the module as an Internal module? troydm 
07:28:42 <sm> lyxia: you're right, I see them too (just not in matrix). That's good. I don't know what the bot's actual uptime is.
07:28:43 <troydm> Uniaika: I'm trying to use this https://github.com/bsl/GLFW-b/blob/master/Graphics/UI/GLFW/C.hs
07:29:10 <sm> oh hello mniip
07:29:28 <mniip> hello hi
07:29:50 <Uniaika> troydm: well thankfully it seems you can use https://github.com/bsl/GLFW-b/blob/master/util/genC.hs to generate it
07:29:58 <MarcelineVQ> troydm, Uniaika: if the message is 'member of the hidden package' it means the package itself isn't in scope/installed
07:30:02 <sm> what's your bot's uptime, and what portion of releases does it announce, do you think ?
07:30:13 <mniip> last time it had an internet hiccup was on the 15th
07:30:33 <mniip> the uptime is 101 days right now
07:30:37 <troydm> MarcelineVQ: Could not load module ï¿½Graphics.UI.GLFW.C, it is a hidden module in the package ï¿½GLFW-b-3.3.0.
07:31:02 <mniip> I think the portion it misses is negligible
07:31:30 <sm> mniip: wow, I'm surprised. I remember hackagebot being much noisier
07:31:50 <mniip> this incarnation thereof?
07:31:56 <Uniaika> MarcelineVQ: by reading the error message, it would seem that the module itself is not exported (which kinda makes sense since it's auto-generated)
07:32:17 <sm> by hackagebot I mean the one I used to run, with nick "hackagebot"
07:32:36 <mniip> maybe there were more packages back in those days
07:33:47 <frdg> can anyone write a bot for this irc? Who approves it?
07:34:07 <sm> well, I wonder why I'm not seeing some announcements in matrix. If I find out anything I'll pass it on
07:35:03 <sm> frdg, the #haskell community. If your bot makes a nuisance, it'll get pushback, or blocked
07:35:16 <sm> but yes, anyone
07:35:19 <mniip> frdg, bring it up with #haskell-ops 
07:35:25 <mniip> ideally before it goes live
07:36:00 <mniip> note that if it makes too much noise it can "accidentally" get blocked by networkwide services
07:36:17 <mniip> there's a whitelist for bots
07:36:55 <frdg> what are examples of bots that have been blocked in the past?
07:37:36 <sm> eg any bot that emits too many messages quickly gets blocked by freenode, unless whitelisted
07:37:57 <mniip> I don't think we've had too many "on-topic" bots in this channel
07:37:59 <sm> probably most new freenode bots have experienced that
07:38:20 <mniip> I really only remember four and they are all still here
07:38:37 <mniip> lambdabot, hackage(bot), yahb, exferenceBot
07:38:44 <MarcelineVQ> @vixen
07:38:44 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
07:38:44 <lambdabot> is because most of them are psychiatrists.
07:39:04 <MarcelineVQ> spicier than I expected
07:39:17 <sm> wow what's got into lambdabot 
07:39:45 <MarcelineVQ> you should see the one I got in /query before that one though
07:39:51 <mniip> frdg, what kind of ideas do you have in mind
07:40:20 <frdg> mniip: none im a beginner, just curious
07:40:28 <mniip> I see
07:41:05 <sm> mniip do you know if there's a best IRC bot framework these days ?
07:41:13 <mniip> best IRC framework is no framework
07:41:36 <merijn> mauke's bot too
07:41:37 <mniip> the "IRC way" is to write your own froms scratch because everyone else's is crappy and has limited features
07:41:45 <MarcelineVQ> though glirc's probably got a worthwile dependency or two
07:41:46 <merijn> Although I guess those were just scripts on his pc
07:42:30 <sm> there are a few things we shouldn't be reinventing every time, I feel
07:42:35 <mniip> that name rings a very distant bell
07:42:39 <MarcelineVQ> like traverse
07:43:21 <mniip> I should work on yahb('s sandbox) more
07:43:24 * sm would like a maintainable flexible custom bot to use elsewhere
07:43:35 <mniip> I had this crazy idea
07:43:43 <mniip> what if we built every version of GHC from git
07:44:34 <MarcelineVQ> that's crazy
07:44:51 <mniip> I know right
07:45:13 <sm> you'd have to plant a tree every minute
07:45:20 <MarcelineVQ> I feel like I have to stop you, for the sake of world peace.
07:45:40 <timCF> hello guys, are any stack users here? I have weird issue - there is extra github dependency in stack.yaml, and this dependency has huge submodule (nixpkgs) - I want say to stack somehow to not fetch submodules of this dependency, or at least do it --depth 1
07:47:09 <timCF> how it can be done?
07:49:22 <sm> timCF: see the examples of "subdirs" in https://docs.haskellstack.org/en/stable/yaml_configuration/ . I think that's the best you can do
07:49:47 <sm> otherwise, clone the repo locally the way you want and have the stack.yaml include that
07:51:39 <suppi> or fork it on github and change it to your liking
07:53:49 <timCF> I don't think submodule update strategy can be configured somehow in gitmodules
07:54:57 <timCF> if stack runs "git submodule update --init --recursive" without --depth parameter, probably it's impossible to configure it in repo side
07:55:07 <timCF> but I'm not sure
08:14:42 <Guest61> Hi. To learn haskell I've been building an framework much like Python Pandas. In this scenario, I've defined a data called Series (https://gist.github.com/gcoimbra/2721e01123e833672c742bef948ad7e9) But due Haskell type system and my ignorance, I program simple functions like a Scalar Sum with this very repetitive coding pattern
08:14:43 <Guest61> (https://gist.github.com/gcoimbra/829f03cb18115b54b354ed6f97fea1aa). Is there any form of overloading to minimize this code?
08:22:38 <ChaiTRex> Guest61: You could have the type Series Int and Series Float.
08:23:33 <Guest61> ChaiTRex: you mean redefining the data Series or creating new types Series Int or Series Float?
08:24:19 <ChaiTRex> Guest61: It would be: data Series a = .... You'd use a on the right rather than Int or Float.
08:24:33 <Guest61> Omg you're right. 
08:24:40 <Guest61> ChaiTRex: thanks
08:24:57 <ChaiTRex> Guest61: No problem.
08:25:02 <merijn> Guest61: You could make it even more general to support ByteString too that way :p
08:25:36 <merijn> Guest61: "Monoid m => (a -> m) -> Series a -> m" (aka foldMap)
08:25:56 <merijn> You could probably use DeriveFoldable to get that for free
08:27:32 <Guest61> merijn: you're suggesting that I use that type signatures in functions like I've tried to implement in above? Or this should be used in the data definition?
08:28:10 <Guest61> merijn: I've put that ByteString in every Series definition because I intend to use it as a Series name. Just like in Pandas
08:28:19 <merijn> Guest61: Your function could be replaced with that
08:28:43 <Guest61> merijn:  I understand now. thanks a lot! 
08:29:45 <Guest61> I've been using this project to learn Haskell. But whar are your opinions on a Pandas made in Haskell? 
08:29:48 <Guest61> *what
08:30:48 <merijn> Guest61: Well, you'd probably want to base that on something like Conduit, but that might be a bit much/complicated if you're just starting :)
08:36:02 * hackage eccrypto 0.2.2 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.2.2 (MarcelFourne)
08:37:02 * hackage eccrypto-ed25519-bindings 0.1.2.0 - provides "ed25519" API using "eccrypto"  https://hackage.haskell.org/package/eccrypto-ed25519-bindings-0.1.2.0 (MarcelFourne)
08:40:36 <kolu> hey guys
08:40:48 <heatsink> hi
08:40:49 <kolu> can I use a lambda in a filter with an outside variable
08:40:54 <kolu> as in here
08:40:58 <kolu> https://pastebin.com/2BTn6Q0k
08:41:08 <merijn> kolu: sure
08:41:12 <kolu> or more like - how can I
08:41:20 <kolu> because that's not working for some reason
08:41:44 <merijn> kolu: Your use of $ is wrong in the guards
08:42:04 <merijn> kolu: You're applying "sum" to a Bool (i.e. the comparison of filter with a number)
08:42:29 <merijn> "sum $ filter (\x -> input `mod` x == 0) [1..input-1] == input" is "sum (filter (\x -> input `mod` x == 0) [1..input-1] == input)"
08:42:59 <frdg> https://pastebin.com/QP5BQVd2
08:43:01 <kolu> doesn' filter return a list with everything that passes the test
08:43:10 <merijn> kolu: Yes
08:43:24 <merijn> kolu: But you're comparing the result of filter with a number and calling sum on that result
08:44:15 <kolu> so
08:44:31 <kolu> (sum $ filter (\x -> input `mod` x == 0) [1..input-1]) == input
08:45:09 <kolu> yes
08:45:12 <kolu> thank you
08:45:28 <ChaiTRex> kolu: Or: (== input) . sum . filter (\ x -> input `mod` x == 0) $ [1 .. input - 1]
08:45:48 <yushyin> si
08:46:07 <kolu> I'm not very comfortable with the . 
08:46:18 <kolu> yet
08:50:05 <frdg> https://pastebin.com/QP5BQVd2 question about using takeWhile/dropWhile
08:51:19 <ChaiTRex> frdg: Use the same function for both.
08:51:31 <ChaiTRex> frdg: takeWhile f and dropWhile f
08:53:50 <frdg> ChaiTRex: Am I correct that I need to use both takeWhile and dropWhile to achieve the correct result?
08:54:06 <ChaiTRex> frdg: Yes, that's correct.
08:54:16 <ChaiTRex> frdg: But you used them with different functions.
08:54:30 <frdg> ok I should have the sufficient hints!
09:01:25 <zincy_> Does stack build --only-depedencies  refrain from actually building your main package ?
09:08:10 <kolu> so when I use timeIt on this script -> https://pastebin.com/2BTn6Q0k with an input number of 33550337 it takes around 1 minute to compute
09:09:00 <kolu> why
09:09:36 <kolu> is it bad code or is the data structure unsuitable
09:11:04 <ChaiTRex> kolu: You compute all four guards.
09:11:11 <ChaiTRex> kolu: That's a lot of duplicated work.
09:11:46 <merijn> Also, sum is bad
09:11:59 <merijn> It's still lazy, afaik
09:12:16 <merijn> But yeah, move the length computation into a where clause
09:19:55 <kolu> okay, 20 seconds
09:19:57 <kolu> that's better
09:20:19 <merijn> Now, for funsies replace "sum" with "foldl' (+) 0"
09:21:07 <oats> is lazy foldl really that bad?
09:21:07 <ChaiTRex> You'll probably need to import foldl' from Data.List.
09:21:11 <merijn> oats: Yes
09:21:15 <oats> yikes
09:21:28 <merijn> oats: The only times it isn't, is when GHC figures it out and makes it strict :p
09:21:32 <oats> hehe
09:21:50 <kolu> still 20 sec
09:22:00 <merijn> kolu: Are you using -O or -O2?
09:22:09 <kolu> what's that
09:22:17 <oats> hrm, digging through 'base' source, sum is defined as 'getSum . foldMap Sum'
09:22:19 <merijn> kolu: Optimisation flags for GHC
09:22:27 <oats> and foldMap uses foldr, not foldl
09:22:45 <merijn> oats: But it's still not strict and strict is better for summing numbers
09:22:54 <oats> gotcha
09:23:05 <kolu> merijn don't know
09:23:06 <oats> is that just because you don't have to build up a huge thunk?
09:23:13 <merijn> oats: Yeah
09:23:18 * oats is a little fuzzy on lazy evaluation still
09:23:28 <tdammers> depends how you represent those numbers and what you do with them
09:23:29 <merijn> oats: And when strict it can be unboxed more easily too
09:23:41 <oats> what is unboxing?
09:23:52 <oats> another one of those things I've read a bunch and never bothered to look up :P
09:24:03 <merijn> oats: There's, effectively, two ways you can implement parametric polymorphism (i.e. generics)
09:24:04 <tdammers> oh no, I did the #haskell thing where you ruin a perfectly reasonable answer to a perfectly reasonable question by talking about obscure counterexample that never occur in real-world programming
09:24:23 <oats> merijn: compile time copy-paste, and vtables?
09:24:53 <merijn> oats: Different types may be different sizes, so either 1) you duplicate code for all possible sizes or 2) you replace all values with pointers/references/whatever you wanna call it, so everything is the same size
09:25:28 <merijn> oats: The latter approach is called "boxing" (the pointer acting like a box, making everything uniform sized). This is also used in Java, C#, etc.
09:25:54 <merijn> oats: Of course, the extra indirection messes with your CPU/cache, etc. so if you can get rid of it, it can make things faster
09:26:24 <merijn> oats: (There's a lot of Java literature on automatic un-/reboxing, for example)
09:27:11 <merijn> oats: In GHC this is usually the domain of the strictness analyzer (which tries to find strict numeric operations and can unbox them, so things happen in registers, rather than in memory through a pointer indirection)
09:27:34 <merijn> oats: This, incidentally, also explains why there's some people who pedantically say "Haskell isn't lazy, but non-strict"
09:27:36 <oats> so does unboxing necessitate using the first method of polymorphism?
09:27:45 <merijn> oats: Yes
09:27:51 <merijn> oats: Well, kinda
09:28:16 <oats> I feel like we're letting the magic smoke out of the compiler box :P
09:28:37 <merijn> oats: If a function is inlined, the redundant boxing can be detected by the compiler and optimised away
09:28:43 <tdammers> there's surprisingly little magic in GHC, considering the impressive amount of stuff it gets done
09:29:14 <oats> I'm both looking forward to, and scared about, the intro to compilers course I'm taking next semester :P
09:29:52 <merijn> oats: If Haskell was defined to be lazy, this would all be illegal, but because Haskell is defined as non-strict (i.e. using it as if it's lazy has to work), gives the compiler the freedom to evaluate stuff strictly when it can determine it's safe to do so
09:43:18 <monochrom> Yes if you have a Num-polymorphic recursive function and then use it on Int, if the stars align you can see optimized code (for that use site) that stays machine int without Int boxing in the tight loop.
09:43:39 <madnight_> https://en.m.wikipedia.org/wiki/Haskell_County,_Kansas
09:56:31 <frdg> is there an equivalent to the .split() method in java? Im looking for a function that takes a String and splits it into a list of string at a specified character.
09:56:32 * hackage scidb-hquery 2.8.0.437 - Haskell query for SciDB via shim  https://hackage.haskell.org/package/scidb-hquery-2.8.0.437 (mdgabriel)
09:57:39 <merijn> frdg: like, at a specific index?
09:57:51 <hyperisco_> monochrom, would astrologers make good programmers then?
09:58:00 <merijn> :t splitAt
09:58:01 <lambdabot> Int -> [a] -> ([a], [a])
09:58:42 <Ariakenom> frdg: for whitespace there is words
09:58:47 <Ariakenom> :t words
09:58:49 <lambdabot> String -> [String]
09:58:58 <frdg> no at a specified character. ie mySplit (" ") Hello my friend" -> ["hello", "my", "friend"]
09:59:06 <monochrom> I don't know, but I think they make good readers of programs, because Gosh have you seen the convoluted rulebooks of astrology they use? :)
09:59:37 <monochrom> Hey new insult: "your code looks like astrology rulebooks" >:)
09:59:37 <frdg> words is what I was looking for!
10:00:11 <frdg> but is there a version where I could split at non-whitespace?
10:00:15 <monochrom> words does your homework, but I think your homework's point is to learn how words does it.
10:00:37 <frdg> monochrome right I was just wondering
10:00:43 <monochrom> And indeed if you learn how words does it, you will know how to split on another criterion.
10:00:52 <hyperisco_> monochrom, so you mean they'd be good at C++
10:01:10 <monochrom> yeah!
10:01:22 <oats> frdg: for more general splitting check out the 'split' package
10:01:29 <oats> frdg: https://hackage.haskell.org/package/split
10:01:43 <monochrom> Hey new insult #2: "Stroustrup, your C++ book looks like astrology rulebooks" >:D
10:01:51 <oats> lol
10:03:12 <dmj`> splitOn n xs = case takeWhile (/=n) xs of [] -> []; ns -> ns ++ splitOn n ns
10:03:25 <dmj`> @def splitOn n xs = case takeWhile (/=n) xs of [] -> []; ns -> ns ++ splitOn n ns
10:03:27 <lambdabot>  .L.hs:246:21: error:
10:03:28 <lambdabot>      Ambiguous occurrence ‘splitOn’
10:03:28 <lambdabot>      It could refer to either ‘Data.List.Split.splitOn’,
10:03:32 <oats> on just use that instead of importing a whole package :P
10:03:35 <dmj`> @src splitOn
10:03:35 <lambdabot> Source not found. stty: unknown mode: doofus
10:03:35 <oats> s/on/or
10:03:44 <oats> lol what
10:06:19 <monochrom> dmj`: Your code looks like a common mistake my students made in a similar question on my midterm test.  Methinks you need dropWhile too, or better yet, use span to do both takeWhile and dropWhile.  The recursive call needs to be on the suffix detected by span or dropWhile, not on the prefix chosen by takeWhile.
10:06:32 <dmj`> yea, it's missing the dropWhile
10:11:36 <oats> I love lambdabot's error :P
10:12:39 <dsal> My brain can't remember whether to use _ or otherwise.
10:15:22 <Uniaika> dsal: if you're matching on boolean conditionals, it's `otherwise` because it's an alias on `true`
10:15:41 <Uniaika> if you need to capture variables, use _ for the catch-all
10:15:58 <sm[m]> zincy_: yes, if nothing depends on it
10:16:09 <Uniaika> oats: I think I prefer the doofus TTY mode to the dummy TTY mode :P
10:16:17 <monochrom> By an evil twist, it is actually safe to use "otherwise" in both cases >:)
10:16:36 <oats> I'm more of a nincompoop myself
10:16:58 <monochrom> If you use it in guards, it evaluates to True. If you use it as a pattern, it is a variable pattern ie catch-all.  Win win!
10:17:10 * dsal starts naming random variables otherwise
10:18:03 <monochrom> Smart beginners notice this phenomenon and are smart enough to ask "wait how can this make sense?" :)
10:20:12 <dsal> I just stuck _ in a guard and it complained about a hole, so I filled the whole with otherwise.
10:20:45 <monochrom> Hey poll question: Which one is better to tell beginners:  A. Don't tell them about otherwise, use True in guards.  B. Tell them about otherwise=True and use otherwise in guards.
10:21:18 <monochrom> I'm actually inclined towards A because less trivia pursuit.
10:21:22 <dsal> IMO, True feels less like magic and helps understand the concept of guards better.
10:21:46 <Uniaika> I would tell 'em up front, who knows what they might infer if they detect that behaviour by themselves 
10:21:52 <monochrom> To be fair my purpose is not to teach Haskell per se, my purpose is to teach enough Haskell for PLT topics later in my course.
10:21:54 <nshepperd2> that certainly is an evil twist - if you use otherwise as a pattern, and then again in a nested guard you could get either confusing errors or incorrect logic, due to shadowing the global one
10:22:09 <Uniaika> at least in my case I know I would never think "omg they aliased otherwise to True!"
10:23:48 <monochrom> In fact I already don't tell them about do-notation.  I use >>= directly in front of them.
10:25:58 <monochrom> I guess it also depends on whether the beginners are smart or mediocre.
10:26:23 <nshepperd2> case condition of { True -> foo;   otherwise | x -> bar | otherwise -> baz } -- whoops
10:26:44 <monochrom> Smart beginners have critical thinking and they will come ask you (or dig deeper themselves) when they get their code to work but it is too magical for them.
10:27:14 <monochrom> You can safely tell them everything and show them professional code because they will dig deeper, they won't cargo cult.
10:28:28 <monochrom> Mediocre beginners? Meh, every new syntax sugar you show them, they're going to cargo-cult it, and then during exam time it'll blow up because they're applying their cult in all kinds of dysfunctional ways.
10:31:06 <monochrom> I am happy to have a few smart beginners among my students.  In some exercises, they got their code to work by just hacking until it type-checks.  But they were smart enough to come to my office hours to ask "I know it type-checks, it also passes test cases so we know it's right, but what does this code mean?"
10:32:22 <frdg> what do you mean by cargo-cult? I looked it up and am unsure of what it means
10:32:52 <monochrom> Superficial imitation.
10:33:33 <frdg> as in writing code you don't actually understand?
10:33:35 <monochrom> For example suppose you see me using do-notation, "do { x<-getChar; print (length x) }"
10:34:39 <monochrom> One day you're asked to write a function for "f x = sin x + cos x" and you're going to cargo-cult my do-notation and write "f x = do { tmp1 <- sin x; tmp2 <- cos x; return (tmp1 + tmp2) }"
10:35:06 <monochrom> or even s/return/print/ which is even more sad.
10:35:34 <monochrom> This is inspired by true stories.  I had previous students doing the like of this on exams.
10:35:38 <Uniaika> frdg: cargo cult means that if you build a airplane runway, airplanes will arrive. You don't know how, why, it that's how it is
10:35:52 <Uniaika> same with the do-notation, on some aspect
10:36:13 <frdg> I see
10:36:17 <Uniaika> monochrom: this is quite tragic
10:36:34 <Uniaika> monochrom: do you tell them not to use `return` but `pure` instead?
10:36:50 <monochrom> Sometimes.
10:37:23 <monochrom> Actually I guess not.  I increase my use of pure.  But I don't ban or omit return.
10:38:21 <solonarv> I definitely agree with the "return is confusingly named, use pure instead" sentiment
10:38:23 <monochrom> I think it looks like "return" will stay indefinitely.  But of course if I'm just using <*> or liftA2, I use pure in conjunction.
10:38:26 <solonarv> but I do not teach anyone.
10:38:29 <mniip> >it also passes test cases so we know it's right
10:38:33 <mniip> ah yes the good ol proof by example
10:38:56 <hyperisco> just only run on those cases and you're solid
10:38:57 <monochrom> No mniip, it's my evil test cases, if your code passes them, your code is right. :)
10:39:04 <solonarv> hey, it's a valid proof technique if the statement to prove is "thing exists" ;)
10:39:40 <monochrom> Also don't forget that parametric polymorphism (free theorems) reduces the need for test cases tremendously.  In some cases you just need like 5 test cases.
10:39:43 <mniip> does the tested program only have a finite domain of inputs?
10:39:58 <monochrom> No but it's parametrically polymorphic.
10:40:11 <monochrom> For example express foldl in terms for foldr.
10:40:31 <mniip> hmm
10:40:39 <monochrom> (Actually weekly exercise I inflicted on them!)
10:40:53 <Uniaika> oof
10:40:53 <mniip> I could probably
10:40:58 <mniip> hijack your tests
10:41:08 <Uniaika> monochrom: which university do you teach at?
10:41:21 <monochrom> University of Toronto Scarborough
10:41:35 <mniip> ((. take n) .) . foldr  satisfies the parametricity condition
10:41:48 <mniip> but for any collection of tests I can pick a high enough n
10:43:15 <solonarv> can I go via foldMap? ;)
10:43:41 <solonarv> yeah mniip , but you kind of have to mess that up "on purpose"
10:44:01 <solonarv> an error that can actually sneak in accidentally is doing it in reverse order
10:44:03 <mniip> 1584985088 [20:38:08] <mniip> ah yes the good ol proof by example
10:44:09 <solonarv> or getting the strictness wrong
10:44:16 <monochrom> I believe it's not worth my time to argue this.
10:44:25 <mniip> probably not
10:44:35 <monochrom> It was not the student's exact wording anyway.
10:45:49 <monochrom> Suffice to say both the student and me (and I endorse the student's judgment on this because when in doubt they're showing me their code and I can check anyway) meant "it passes the tests" in good faith not in adversary trolling faith.
10:48:49 <hyperisco> if you go the "code coverage" route then 100% code coverage with  take n  would reveal the flaw
10:49:55 <monochrom> Although, for code coverage you have to see the code and then tailor-make tests, not the other order.
10:50:19 <hyperisco> yes but if your tests do not hit 100% code coverage then maybe that indicates something odd
10:51:56 <monochrom> For feasibility of testing 150 students, I make test cases without seeing their code.  My weapon is, however, twofold: I use more parametric polymorphism, and I have secret test cases.
10:53:00 <monochrom> Yes you can still pull a take-10 trick on me.  which requires more effort and deeper understanding than solving the problem properly.  It's also just 1% of the course so go waste your time as you see fit.
10:53:46 <monochrom> And developing a habit of trolling me is going to hurt you on the exam, not help.
10:55:13 <monochrom> Like under the utility function of maximizing your whole-course mark why would you waste time honing your skill in trolling me, rather than honing your skill for the exam on which I and my TAs will eyeball your code personally.
10:56:46 <monochrom> It's so refreshing to see that when people get nerd-sniped by a highly localized even hypothesized challenge they forget very basic and obvious premises of economics.
10:57:10 <dmj`> @def splitN _ [] = []; splitN n xs = case span (/=n) xs of { (ls,rs) -> if null ls then splitN n (tail rs) else ls : splitN n rs }
10:57:12 <lambdabot>  Defined.
10:57:27 <dmj`> > splitN 'a' "abcaabda"
10:57:30 <lambdabot>  ["bc","bd"]
10:57:39 <dmj`> \o/
10:57:58 <dmj`> this is different than splitOn, which uses empty lists to demarcate where the delimiter used to be
10:59:29 <monochrom> congrats
10:59:31 <dmj`> splitOn _ [] = []; splitOn n xs = case span (/=n) xs of { (ls,rs) -> ls : splitOn n (tail rs) }
10:59:36 <dmj`> monochrom: thanks :) 
10:59:59 * dmj` kisses baby, receives award
11:08:50 <mniip> I see this I immediately think unfoldr
11:13:52 <monochrom> Also I forgot to mention that if your exam mark is below 35% you still fail the whole course.  This is a good guard against homework cheating (and I caught one case by this) and I learned it from my colleagues.
11:14:38 <monochrom> But I'm evil so I am always thinking "isn't it even better if we make it, say, 50% or a similar fraction, of your assignment marks?" >:)
11:17:16 <solonarv> at my uni (in germany) homework is marked, but you just need to get 50% of the points to be allowed into the exam, they don't matter beyond that
11:17:19 <maerwald> What are marks even for? Humiliating students and inducing toxic competitive culture by having everyone compare against each other :)
11:17:22 <solonarv> makes cheating fairly pointless
11:17:58 <solonarv> (and the exams are pretty similar to the homework problems, just easier)
11:21:15 <monochrom> Marks fight against the Dunning-Kruger effect.
11:21:36 <maerwald> lol
11:21:51 <monochrom> Ah but yes, fighting against the Dunning-Kruger effect causes toxic humiliation.
11:21:54 <maerwald> Absolutely not. That is done by project work.
11:22:21 <monochrom> We mark project work too. So, marks.
11:22:25 <maerwald> Marks are about evaluation, not getting people to their limits.
11:22:27 <maerwald> Orthogonal
11:22:44 <monochrom> Fighting Dunning-Kruger = Evaluation.
11:23:01 <monochrom> Same axis.
11:23:05 <maerwald> And, in the end, no one cares about marks in the real world (where you work), because they have so little meaning there. People rather look at your github profile.
11:23:09 <maerwald> It has more meaning.
11:23:29 <yushyin> ^ false
11:23:49 <maerwald> And a similar concept could be done in university and schools as well. Building up a portfolio of your work. It has been suggested by German philosophers recently.
11:24:05 <maerwald> Marks are from a time of military.
11:25:32 * hackage css-selectors 0.2.0.0 - Parsing, rendering and manipulating css selectors in Haskell.  https://hackage.haskell.org/package/css-selectors-0.2.0.0 (wvanonsem90)
11:26:38 <monochrom> This may be unfair but I found that many philosophers are nerd-sniped and forget very basic premises of economics too.
11:27:06 <monochrom> Just to say that take their recommendations with a grain of salt.
11:27:07 <maerwald> Well, it's supported by brain scientis Gerald Hüther.
11:27:22 <maerwald> But I can't find the book in english, unfortunately.
11:27:36 <maerwald> And most talks are german as well (damn those germans)
11:28:02 * hackage headroom 0.1.3.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.1.3.0 (xwinus)
11:28:42 <maerwald> But changing the system would require to find a better way to motivate students than through fear. That might be tricky.
11:29:06 <maerwald> Punctual change is hard
11:30:33 <[exa]> maerwald: in fact the students don't really care much about marks, but it's a nice method how to preserve a bit of information about the student. Our uni has small stipendia based on marks (which have, in fact, significantly boosted the productivity), and it's also a nice guide if you're evaluating the student say 2 years later at the state exam and thinking whether he just accidentally momentarily forgot 
11:30:39 <[exa]> the important part, or it's a systematic problem
11:30:49 <[exa]> maerwald: that being said, I wouldn't show the marks to students at all. :]
11:31:32 <maerwald> Oh right. If you have that as an internal system, that would be different. E.g. figuring out if a student needs more help, different work, might be suggested to change courses etc.
11:32:19 <[exa]> you need to somehow process the gazillion of data into something that can be handled statistically, sadly we don't have 10 students but 1000s
11:33:04 <[exa]> anyway completely agree that gaming the thresholds for better marks is pure evil :D
11:33:04 <maerwald> Yes, they're treated like factory workers (or as I said: military) ;)
11:33:18 <monochrom> Or happily you have 1000 students so you have a chance to enlighten 1000 people not just 10? :)
11:33:58 <monochrom> Anyone wanna go back to the good old days when only 10% of the people could read, only 1% could add?
11:34:05 <[exa]> you can enlighten quite a bit of people quickly in fact (both of you have already done that here several times I guess :D), but you can't remember all of that until the people actually leave the school
11:34:06 <maerwald> monochrom: no, it just means the smartest people should be *forced* to become mentors (not teachers) instead of getting dried out in industry ;)
11:34:18 <maerwald> But working at uni doesn't seem appealing to many
11:34:23 <maerwald> Which is our fault
11:36:32 <[exa]> monochrom: btw that's a good argument, lot of students (I'd say more than 50%) just decide that it isn't their goal and go doing something else; another 40% go work for money into some uninteresting industry (at least they apply some of the skills), and the rest 10% is 100 vs 1 difference
11:37:40 <maerwald> The only useful thing I learned in uni was the curriculum. I mean, the thing you can write down on a single sheet of paper. I don't even mean the content. That was really all.
11:37:58 <maerwald> So you have a map of how to approach the field.
11:38:05 <maerwald> Everything else was a waste of time.
11:38:29 <monochrom> Anyway at a very fundamental level, moving towards "employer looks at your portfolio" doesn't remove evaluation, it just postpones evaluation. Someone will be telling me "I looked at your profile, I won't hire you".  That's just another form of giving you marks.
11:38:50 <[exa]> maerwald: really? no interesting mathematics or anything else?
11:38:56 <maerwald> Nah, it's fundamentally different.
11:39:09 <maerwald> [exa]: I forgot all of the maths.
11:39:44 <monochrom> It is true that a difference between 65 marks and 66 marks says nothing.  But the difference between failing courses and passing courses is meaningful to employers.  And between A and not A, meaningful to grad school.
11:40:36 <maerwald> If you work portfolio based, you also work project based. People don't learn for exams and memorize random things. It's easier to see their expertise, their style, their workflow, their attitude. Yes, it takes a little more time for the employer than looking at marks.
11:41:22 <monochrom> My exams don't make studente memorize random things.  My students also know this in advance.
11:41:41 <maerwald> [exa]: I was always good at maths, but I always forgot everything after the exams.
11:41:43 <maerwald> xD
11:42:12 <maerwald> Especially with maths. I don't know why.
11:42:50 <maerwald> Probably because application was disconnected from real world problems, most of the time.
11:43:56 <monochrom> Well so far I can only understand that you are only avoiding the words "evaluation" or "marks".  Let me put it back for you.  With portfolios and projects It is easier to evaluate expertise, mark style, evaluate workflow, mark attitude.
11:44:19 <monochrom> As long as an employer doesn't just go "if you apply, I hire you", there will be marks.
11:44:35 <maerwald> Sure, but that evaluation doesn't happen during your studies.
11:44:42 <monochrom> You can tell me to mark projects rather than exams.  Ah but my exams are mini-projects.
11:45:06 <maerwald> And I have no idea how my employer evaluates me (and I usually don't care, as long as I get the job)
11:45:07 <monochrom> That's the stupidest idea of all and it's empirically show in US and Canada.
11:45:45 <monochrom> We now know that postponing telling you "you failed at something" is the main cause of adulthood anxiety.
11:46:03 <maerwald> I think you misunderstand me a bit :)
11:47:38 <jjhoo> one person mini-projects, or multiple participants?
11:48:58 <monochrom> US and Canada have had a decade or two of grade inflation in pre-uni education.  Grade inflation is the equivalent of not giving you real marks during your studies.  Students then go into uni and suddenly are shown proof that they can't do simple algebra, they can't code up simple things.  (Sure it shows in the form of low marks, but the marks are from algebra skills and coding skills.)  Now the lot of them need help for mental health.
11:49:47 <monochrom> People keep saying this shock gives them fears.  I ask the deeper question why the fear and where did it really come from?
11:49:58 <maerwald> If a student failed, then the mentor failed. Because mentoring is all about balancing between challenge and continuous success. Never get to the point of frustration (it isn't useful, even if people tell each other that), never get to the point of missing challenge.
11:50:23 <[exa]> maerwald: btw we have like 2 math courses ("introductory" calculus) that are not supposed to be really remembered, only teach the student the attitude of looking at an incomprehensible inaccessible problem systematically and not running away in fear
11:50:34 <maerwald> So as soon as a student goes out of balance, then something failed. Whether it's the student is up to debate.
11:50:38 <monochrom> If you haven't been told "fail!" for 20 years, then the first time you hear it is going to be fearsome.  But it's those previous 20 years that cause the fear, not the first time you hear an honest "fail1".
11:51:10 <[exa]> maerwald: if you can teach that attitude without failing multiple times, you've won
11:51:37 <maerwald> [exa]: It's more common knowledge in... surprising now... extrem sports (e.g. MMA).
11:51:41 <maerwald> They're ahead of us here.
11:51:54 <maerwald> It's psychology, all the way.
11:52:13 <[exa]> yeah, I guess so
11:52:18 <maerwald> If you get bored during training, you won't memorize. If you get frustrated, you lose motivation.
11:52:21 <maerwald> Always be in the middle.
11:52:28 <monochrom> jjhoo: My exams have to be individual, so it's solo.  Sometimes I give pariwise hard assignments, some other times solo easy assignments.
11:52:40 <monochrom> Still, students can discuss.
11:54:07 <maerwald> Also, I wouldn't mind going to university again. I'll have monochrom teach me! But then again, in our society it's odd to go to uni again after you entered the workforce.
11:54:36 <[exa]> not really, I did that
11:54:48 <maerwald> Surprising
11:55:34 <monochrom> Some unis set up BS bars to re-entrance.  Some don't.  I agree it's a lot of BS.
11:55:36 <maerwald> I also feel your mind becomes a little dull if you don't study anything for several years. At least you need those 3 months unemployment from time to time to get into something non-trivial.
11:55:49 <solonarv> still unusual, tbh
11:56:02 <jared-w> The rewrite of GitHub's `setup-haskell` action is complete! https://github.com/actions/setup-haskell/pull/12
11:56:10 <maerwald> I don't believe in this continuous learning crap everyone tells each other at LinkedIn. Yes, some things you pick up during work, but some things not.
11:56:16 <solonarv> my mother went back to uni later on as well, but people are usually surprised to learn that
11:56:38 <[exa]> maerwald: well if you spend the years slacking around it's gonna be complicated. I spent that programming complicated models. Also the bit of new anti-corporate motivation helped a lot
11:56:40 <frdg> takeWhile / dropWhile question https://pastebin.com/50qSWtc8
11:57:04 <maerwald> [exa]: I think it's healthy for your brain to completely switch field every 10 years, hehe
11:57:19 <jared-w> (I only embarrassingly screwed up committing the MR on haskell-ci/setup by a tiny amount)
11:57:21 <maerwald> You've been a programmer? Become an anthropologist now!
11:57:34 <frdg> anthro
11:57:44 <solonarv> frdg: you are on the right track. it is 'tail' that is the problem here.
11:57:44 <frdg> ...oops
11:58:23 <frdg> solonarv: correct
11:58:53 <[exa]> frdg: what if there are 2 spaces?
11:59:05 <monochrom> frdg: What solonarv said.  For example what happens to myWords "fun" ?
11:59:25 <monochrom> > dropWhile (/= ' ') "fun"
11:59:28 <lambdabot>  ""
11:59:32 <monochrom> > tail ""
11:59:34 <lambdabot>  "*Exception: Prelude.tail: empty list
11:59:49 <monochrom> (BTW this is how I would "debug".)
12:00:06 <frdg> I see. When I take tail out though I have a whole other issue...
12:00:21 <monochrom> So your code for "next" needs to be a bit smarter.  It has a few corner cases to worry about.
12:00:23 <solonarv> yes of course, you still need to do *something* there
12:01:16 <frdg> ok. That something just isn't tail. Ill keep trying different stuff
12:01:32 * hackage pomaps 0.2.0.0 - Maps and sets of partial orders  https://hackage.haskell.org/package/pomaps-0.2.0.0 (sgraf812)
12:01:35 <solonarv> don't try things at random
12:01:50 <solonarv> instead think: okay, what should this function do?
12:02:00 <solonarv> then implement it (or see if it already exists somewhere)
12:02:54 <frdg> ok!
12:03:35 <monochrom> [exa]'s question is useful too.  You can kill both birds with a stone.  There is a way to cover all of "fun", "fun fact", "fun           fact" uniformly.
12:46:01 * hackage derive-storable-plugin 0.2.3.0 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.2.3.0 (mkloczko)
12:53:01 * hackage stratosphere 0.51.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.51.0 (jdreaver)
13:18:11 <Boarders> I am on a laptop I dont normally use and when I try to build my project I get: "/lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29' not found"
13:18:18 <Boarders> does anyone know how to fix that error?
13:18:39 <bbuccianti> Boarders: do you need to install glibc?
13:18:46 <alx741> Boarders: try updating OS packages
13:18:47 <Boarders> I think the version of libc that comes on ubuntu18.04 (which I am using) is 2.27
13:19:35 <Boarders> hmm the software updater says everything is up to date, do you mean something else? (I'm on ubuntu)
13:22:31 <maerwald> Boarders: did you sync dependencies somehow from a remote?
13:22:44 <Boarders> I don't think so
13:23:18 <frdg> https://pastebin.com/yD26U4Hq I DID IT! Could you guys critique my code though?
13:23:25 <maerwald> An error like this happens when you build dependencies on ubuntu 19.10, and transfer them to an older one
13:24:39 <Boarders> hmm I see, I don't think that is the case here
13:24:56 <Boarders> unless it is somehow a result of something I have installed with apt-get
13:25:28 <Boarders> I use the hvr repository to install ghc
13:25:37 <Boarders> and just grabbed ghc-8.8.3 from there if that is relevant
13:27:30 <Boarders> I should note this results specifically when I try to use cabal repl and not cabal build
13:53:40 <zeta_0> what does context mean in computer programming? and specifically in functional programming?
13:54:36 <dsal> zeta_0: It depends on the context.
13:55:23 <zeta_0> dsal: does context mean: `situation`?
13:56:10 <dsal> What is the context you're asking about?
13:57:16 <zeta_0> dsal: i've found it easier to think of functors as boxes, thinking of them as contexts isn't intuitive to me
13:57:57 <zeta_0> containers help me visualize better
13:58:10 <dsal> Ah, analogies are always approximations.
13:58:44 <dsal> Do you think of RealWorld as a box?
13:58:58 <zeta_0> dsal: so it's best to visual functors in terms of category theory?
13:59:08 <zeta_0> arrows mapping objects
13:59:35 <Cale> "contexts" also is very nearly meaningless
14:00:37 <zeta_0> dsal: what do you mean by your question, i am very visual, that helps me understands things
14:00:56 <dsal> In general, I think it's better to think of things in terms of what they are as opposed to things that some of them look like in certain situations.  I'm not a category theorist.  I'm slowly developing an intuition for what different abstractions provide.
14:00:59 <Cale> "Containers" is okay, but sometimes thinking of values of type F a as "programs" or "actions" of some sort is more appropriate
14:01:02 <zeta_0> Cale: agreed, context doesn't describe very much
14:01:04 <dsal> zeta_0: RealWorld ~ IO.   Do you think of IO as a box?
14:01:43 <Cale> You can think of IO as a funky sort of tree that describes what you will do in response to each primitive action taken
14:01:55 <Cale> In response to the results of those actions
14:02:02 * hackage semantic-source 0.1.0.0 - Types and functionality for working with source code  https://hackage.haskell.org/package/semantic-source-0.1.0.0 (rewinfrey)
14:02:11 <Cale> For example, it would be possible to describe terminal IO with the following type
14:02:47 <Cale> data TermIO a = Done | PutChar Char (TermIO a) | GetChar (Char -> TermIO a)
14:02:57 <Cale> oops
14:03:01 <Cale> data TermIO a = Done a | PutChar Char (TermIO a) | GetChar (Char -> TermIO a)
14:03:26 <zeta_0> ya, the containers analogy doesn't make sense for some functors, and yes thinking of IO as a box, is so far the best intuition that i've been able to understand
14:03:53 <Cale> So, an action of type TermIO a is either already finished, with some value of type a, or it starts off with a PutChar, holding some character to print, and another TermIO action
14:04:02 <monochrom> Yeah, a huge tree that branches out on user input.
14:04:24 <Cale> or it starts off by reading a character from the terminal, and has a function that describes which TermIO action to take next depending on which character gets read
14:04:34 <monochrom> It's a game tree, in accordance to two-person-game semantics.  (This is serious.)
14:04:43 <Cale> yeah, exactly
14:05:26 <zeta_0> this has really helped me though: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
14:05:28 <Boarders> that description makes the binding sound weird to me
14:05:28 <Cale> Of course, if we were to take this approach to defining IO for real, we would probably want some fancier primitives for handling different types of primitive FFI and basic I/O
14:05:43 <Cale> Boarders: You mean binding in the sense of (>>=)?
14:05:44 <monochrom> The most ridiculous part about the World->(World,a) model is that this "World" contains the characters I will enter tomorrow, even before I have decided what to enter.  Does anyone actually believe in this prophetic fantasy?!
14:05:56 <Boarders> I mean binding of variables, sorry that is confusing
14:06:21 <Boarders> for instance if I read a char from the input (other player plays a move), I can  continually re-use whatever input I got
14:06:21 <dsal> @package tardis
14:06:21 <lambdabot> http://hackage.haskell.org/package/tardis
14:06:42 <monochrom> zeta_0, those pictures are wrong.
14:06:50 <Cale> Boarders: Yeah, well, a function of type Char -> TermIO a is allowed to use its parameter as many times as it likes
14:07:07 <zeta_0> monochrom: how, they made sense to me?
14:07:13 <monochrom> I understand that some pictures "help" psychologically because you have a picture (even very wrong one) to cling to.
14:07:27 <monochrom> I think they even break laws.
14:07:44 <Boarders> Cale, right but I was just saying that game semantics can be a bit misleading
14:07:50 <dsal> It's possible to make sense and be incorrect at the same time.
14:07:51 <{abby}> The only functor you can accurately explain as "a box" is Identity
14:08:01 <monochrom> Many wrong stories make sense.
14:08:10 <zeta_0> monochrom: ok, you guys are the haskell experts here, i'm not going to argue
14:08:22 <Cale> Boarders: oh, well, from a game perspective, we potentially end up in a different subgame for each potential character that the user types
14:08:22 <monochrom> I just produced some wrong stories and fake news that made total sense yesterday.
14:08:23 <dsal> Some people think the earth is shaped like a giant ball, but if you go outside and look, it's clearly flat.
14:08:56 <Cale> Boarders: and the description of that subgame can mention the character in question as often as it likes, or otherwise depend on it in any way
14:09:38 <Cale> zeta_0: for what it's worth, those pictures mostly seem fine to me as pictures for describing what's going on with Maybe
14:09:54 <Boarders> yeah I think I prefer to think of game semantics like a videogame
14:09:59 <zeta_0> dsal: ok, i get what your saying, if you look at it from the wrong perspective it looks true but it's not(if i understand you correctly)
14:10:20 <Boarders> request response to the environment etc (though it amounts to the same thing)
14:10:30 <monochrom> I had a student who liked those pictures.  I showed them my State monad use case and asked "can you use these picture to predict the output of my code?".  The answer is no.
14:10:31 <Cale> zeta_0: If you understand that the "boxes" might have to look extremely different if your monad was something else, then it's maybe fine
14:10:53 <Cale> We could have a look at what the boxes would need to look like for State :D
14:11:05 <monochrom> Predictive power (in the scientific sense) is my criterion of model vs BS.
14:12:05 <Cale> newtype State s a = S (s -> (s,a)) -- so if we think of functions s -> t as being containers that are indexed by values of type s and contain values of type t
14:12:35 <Cale> this thing is a container that's indexed by values of type s, and at each position contains both a value of type s, and a value of type a
14:13:07 <Cale> and then you have to take care figuring out what the operations do with these indices
14:13:18 <zeta_0> Cale: category theory is very visual and abstract(just arrows and objects), that's why i like it, so i guess i just need to keep developing a better intuition
14:14:23 <dsal> People good at visualization can make lots of things appear to be visual.  :)
14:14:38 <Cale> zeta_0: btw, the article with the cartoon diagrams there didn't have category theoretical diagrams -- at least not the ones which are relevant -- its arrows were more akin to evaluation for the most part.
14:14:47 <{abby}> Stretching the box analogy to things like State and ((->) r) is already hard enough, but what sort of box is Cont?
14:14:49 <Cale> But yeah, I agree with that statement regardless :)
14:14:52 <monochrom> The monad axioms almost say nothing (apart from some common sense). This is a way of telling you there are going to be vastly different dissimilar examples.
14:15:25 <monochrom> What you can do though is to start with various examples of free monads.  (They're all game trees.)
14:15:35 <Cale> {abby}: One which needn't actually contain values of type a :D
14:15:36 <nshepperd2> State s a is a warehouse containing |s| boxes each containing an a and barcode with the next s
14:15:43 <Cale> {abby}: newtype Cont r a = C ((a -> r) -> r)
14:16:01 <Cale> So this is a magic box which answers r-valued questions about values of type a
14:16:14 <nshepperd2> 'join' is Amazon absorbing other warehouses
14:16:19 <Cale> values which may not actually exist, because it might be lying to you :D
14:16:49 <{abby}> Ah, it's a magic lamp, with an r-valued genie, then :p
14:17:03 <Cale> However, if we have an honest value of type a, we can certainly get hold of a question-answering box, which always tells the truth about that particular value
14:17:20 <Boarders> monochrom: intuition is useful iff it gives you a complete evaluator of a situation, that seems a bit much to me
14:17:33 <Cale> But yeah, the double negation makes it weird
14:17:34 <monochrom> No.
14:17:48 <monochrom> Because you said "useful" not "comforting".
14:17:52 <{abby}> Cale: Strangely enough, Cont is no classic box, but it is a classical box :)
14:18:01 <nshepperd2> ah, the s is an SKU :p
14:18:01 <Cale> haha
14:18:05 <monochrom> Also I did not say "complete" either.
14:18:17 <Boarders> well it has to be able to evaluate your code?
14:18:31 <monochrom> At least just my code, not all code.
14:18:53 <monochrom> How about you show me how many situations those picture can predict for.
14:19:09 <monochrom> Maybe the Identity monad only, is my guess.
14:19:46 <Boarders> I dont know this just sounds like some weird scientism, intuitions are useful
14:19:49 <monochrom> So technically it's useful for a very simplistic case but meta-levelly it defeats the point.
14:19:57 <Boarders> that is an empirical fact about human understanding
14:20:25 <Boarders> there is a reason spj draws little input output boxes when teaching IO
14:21:14 <monochrom> His boxes prove to be a useful model, with predictive power, for state monads.
14:21:33 <iqubic> IO in haskell is different from IO in any other language ever.
14:21:39 <monochrom> There is a reason he drew his pictures not the linked pictures.
14:21:41 <jared-w> Intuition doesn't need to be a complete evaluator, it only needs to be a correct approximation for the level of detail you're aiming for
14:22:09 <monochrom> Intuition is unnecessary except for personal comfort.
14:22:26 <monochrom> Some people also confuse intuition with model.
14:22:48 <monochrom> Sometimes they call their very good model "intuition" and so you think intuition is useful.
14:22:48 <Boarders> I am not going to argue the point on irc but you are not an expert whatsoever in teaching or understanding and you are just making random claims
14:22:58 <maerwald> Intuition is a great tool for discovery. And a bad tool for reasoning.
14:23:31 <zeta_0> i'm on ch11 of learn you a haskell: applicative functors, i'm trying to learn functors, applicative functors, and monads in the right order
14:23:49 <monochrom> You are an expert so you are qualified to tell me as a demonstration how to use those pictures, but you haven't.
14:24:00 <zeta_0> so far so good
14:24:36 <Boarders> some pictures are incorrect therefore all intuition is merely comfort and I need to explain some pictures to prove something
14:24:37 <Boarders> ok
14:27:14 <zeta_0> category theory and geometry use pictures to prove things, so i'm not against it, and our brains designed to visualize things, out of the 6 senses, sight is probably the most important
14:27:31 <zeta_0> sorry, i just felt like going on a tangent
14:28:58 <monochrom> No contention from me on that either.
14:29:22 <monochrom> Just want to remind you flatearthers draw gorgeous pictures too.  You saw some thing them?
14:29:30 <monochrom> err You saw some of them?
14:30:58 <maerwald> Where all the animals fall down at one side?
14:31:09 <maerwald> Also, where does the water go... so man questions
14:31:18 <{abby}> Identity a is a box that contains one a. [] a is a box that contains an arbitrary non-negative amount of 'a's. Cont r a is a box that doesn't not contain an a
14:32:06 <monochrom> But you can always try this.  According to that picture, can you draw some testable conclusions?  Are the tests passed?  Which conclusions survive tests, and which tests?  Which ones don't?  Then you get a very good idea of the pros and cons of that picture, and know when to use it and when not to use it.
14:32:53 <monochrom> I certainly use a flatearth picture when I order on Uber Eats.
14:33:08 <tdammers> maerwald: haven't you heard? gravity is a hoax too
14:33:24 <monochrom> Hell, the app shows a flatearth picture!  And I got my food so it works for my small scenerio.
14:33:47 <maerwald> tdammers: no, but I've heard from that flatearth physicist(?), who built an actual rocket (wow) and then took off and died
14:34:45 <monochrom> {abby}: For [] I wonder if it's better to say "one box, n things" or "n boxes, one thing per box".
14:35:04 <tdammers> we're deep in #-blah territory btw
14:35:05 <{abby}> maerwald: https://www.space.com/mad-mike-fatal-homemade-rocket-launch-flat-earth-theory.html
14:35:12 <monochrom> Actually I'm already doing the latter to my students.  I even s/box/universe/ and tell a multiverse story.
14:35:43 <maerwald> {abby}: I expect this to win the next darwin awards
14:35:56 <{abby}> For sure. it's got my vote
14:36:08 <monochrom> Multiverse carries the implicit connotation that two unverses/boxes don't have access to each other, which is right for the [] monad.
14:45:20 <monochrom> Aw no one wants to discuss the choice between "1 box n things" and "n boxes, 1 thing per"?  Because it is actually interesting.
14:46:06 <monochrom> If you look from the outside, bird's eye view, globally, you see [1,2,3], that's one box three things, that much is true.
14:46:29 <tdammers> box metaphors considered harmful
14:46:55 <monochrom> But if you look at [1,2,3] >>= \a -> foo, and zoom into the "\a -> foo" part, you only see 1, or 2, or 3.  Even without the [ and ].
14:47:30 <monochrom> Your \a -> foo is also stateless, so after it sees 1, and then next time it sees 2, it cannot remember it saw 1 a while ago.
14:48:21 <monochrom> For a more complete understanding you need to keep switching between the two views (global and local) as often as is necessary.
14:54:14 <nshepperd2> maybe it's 1 box containing three boxes
14:54:51 <{abby}> 3 boxes linked together?
14:55:09 <{abby}> as if they were in a list of boxes..?
14:55:19 <tdammers> it's boxes all the way down
14:55:21 <{abby}> No, surely not
14:55:27 <MarcelineVQ> _box
14:56:13 <{abby}> We must be thankful that these boxes are all very light, though
14:56:17 <{abby}> Otherwise they couldn't be lifted
14:56:27 <monochrom> har har
14:58:09 <MarcelineVQ> boxes only come in one size though, which is occasionally 32x larger than needed
14:58:23 <maerwald> Yeah, typesafety is like all that plastic wrap around the candy.
14:59:07 <{abby}> Well, you can get unwrapped candy, you just can't put it in a box!
14:59:08 <MarcelineVQ> typesafety is like a writing desk
14:59:22 <tdammers> my metaphor checker just exploded
14:59:34 <maerwald> lolo
15:00:19 <monochrom> Typed lambda calculus is when you type it up on a typewrite/computer.  Untyped is when you use handwriting.
15:00:47 <monochrom> Untyped lambda calculus comes with recursion without an extra construct because your handwriting is cursive.
15:01:29 <nshepperd2> a monad is a container with a child-safe lid. you can ask an adult to help you open it with (>>=), but only if you promise to put the contents back once you're done with them
15:02:04 <MarcelineVQ> >>= is the sippy-cup operator
15:02:22 <sm[m]> nice web app joeyh!
15:03:00 <monochrom> which web app?
15:03:57 <MarcelineVQ> joeyh invented the webapp version of that green velcro you use in the garden for plants which vine
15:04:29 <sm[m]> I'm assuming it's public: https://www.patreon.com/posts/quarantimer-35189401
15:05:12 <ysangkok> hm, i used guard in IO (Maybe a), but that gives me "user error (mzero)" instead of the desired Nothing
15:05:48 <ysangkok> i could make a huge if, but i'd like to avoid indenting
15:05:54 <ysangkok> how can it be done?
15:06:04 <monochrom> Show actual code?
15:06:04 <koz_> For this function: http://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:counterexample - where does the user-provided string get 'added' to the output? At the beginning, at the end, somewhere else?
15:08:44 <solonarv> ysangkok: how do you expect that to "know" it can be 'pure Nothing'? it's 'instance Alternative IO', it has no knowledge at all about the parameter (the 'a' in 'IO a', or the 'Maybe a' in 'IO (Maybe a)')
15:08:46 <monochrom> Both IO and Maybe are instances of Alternative. So be careful at which level you use guard.
15:09:10 <solonarv> perhaps you want to use MaybeT IO. I don't know because I can't see your code.
15:09:26 <ysangkok> i wanted to show you with lambdabot but it doesn't run IO code
15:09:28 <monochrom> Yeah best to show actual code.  Why don't people do this more?
15:09:44 <ysangkok> i'll prepare a gist...
15:09:48 <solonarv> yahb runs IO (it's a ghci session)
15:09:50 <monochrom> You can use a paste website?  You can use yahb?
15:09:57 <solonarv> but if your code is longer than 1-2 lines, use a paste website
15:10:08 <monochrom> Why don't people do this more?
15:11:15 <ysangkok> % (do guard False; return $ Just 1) :: IO (Maybe Int)
15:11:15 <yahb> ysangkok: *** Exception: user error (mzero)
15:11:28 <monochrom> That's at the IO level.
15:12:18 <ysangkok> yeah... i guess there is no way around having a function call or an extra scope
15:12:53 <monochrom> Here is one way of saying that the guard is for Maybe.
15:13:04 <monochrom> % return (guard False) :: IO (Maybe Int)
15:13:05 <yahb> monochrom: ; <interactive>:23:1: error:; * Couldn't match type `()' with `Int'; Expected type: IO (Maybe Int); Actual type: IO (Maybe ()); * In the expression: return (guard False) :: IO (Maybe Int); In an equation for `it': it = return (guard False) :: IO (Maybe Int)
15:13:16 <monochrom> Oh haha
15:13:19 <monochrom> % return (guard False) :: IO (Maybe ())
15:13:19 <yahb> monochrom: Nothing
15:13:30 <solonarv> but also, return x >> foo = foo
15:13:31 <zeta_0> what are the most difficult functional programming concepts to understand?'
15:13:54 <solonarv> so the 'return (guard False)' in 'do return (guard False); blah' doesn't do anything
15:13:58 <maerwald> zeta_0: currying
15:14:04 <monochrom> And I guess for IO (Maybe Int) it goes as...
15:14:23 <ysangkok> yeah, i think i understand it now. just a sign of purity
15:14:29 <monochrom> % return (do guard False; Just 1) :: IO (Maybe Int)
15:14:29 <yahb> monochrom: Nothing
15:14:45 <monochrom> It begins to look like an XY problem though.
15:15:05 <zeta_0> maerwald: currying, i didn't think that it was to difficult, i struggled more with recursion
15:15:21 <monochrom> continuation-passing style is pretty difficult.
15:15:22 <maerwald> zeta_0: Oh, I mean more all the weird applications of it
15:15:41 <monochrom> parametric polymorphism (free theorems) is pretty difficult.
15:15:51 <ysangkok> i'll do 'if ... then return Nothing else [laaaaarge indented block in IO]'
15:16:06 <monochrom> recursion is only difficult for beginners
15:16:15 <zeta_0> monochrom: agreed
15:16:22 <zeta_0> maerwald: agreed
15:16:25 <monochrom> and only for control freaks.
15:16:27 <zeta_0> monochrom: sorry
15:16:28 <solonarv> you can also, as I mentioned above, use 'MaybeT IO a' instead of 'IO (Maybe a)'
15:16:37 <solonarv> perhaps that works better.
15:16:51 <ysangkok> solonarv: i'll read up on it, thanks
15:17:07 <maerwald> then laziness... it's tremendously hard, especially for complex programs
15:17:20 <monochrom> yes laziness
15:17:45 <{abby}> ysangkok: With MaybeT IO a you can use when/unless/guard instead instead of shoving all your code in an 'else' branch
15:18:03 <{abby}> do { guard ...; liftIO (putStrLn "... was true") } or somesuch
15:18:17 <dsal> MaybeT IO a...  that sounds like something obvious I've needed recently.
15:18:46 <{abby}> Mostly guard, actually, when and unless work for everything else. Point is, you can think of MaybeT as upgrading your IO to have "early exits" (without exceptions)
15:21:00 <solonarv> I like MaybeT. it's simple, useful, and doesn't encourage you to shove your entire program into it
15:22:31 <maerwald> MaybeT is almost always wrong. Maybe is something you do when there's only one failure that is possible. 
15:22:53 <maerwald> The point of making it a transformer is to be able to throw it in different places
15:22:56 <maerwald> Now... er
15:23:17 <solonarv> yes, that is why I only want to use it for small sections of the program
15:23:29 <monochrom> Perhaps they really have only one failure to convey?  I mean especially since they say they're using it locally.
15:24:08 <maerwald> I'll let it slide... this time
15:25:24 <monochrom> You know I can join your "MaybeT is almost always wrong" campaign if you join my "intuition is almost always wrong" campaign.  You know I will also agree if we upgrade both to "always".  >:)
15:25:49 <{abby}> Poor MaybeT D:
15:25:59 <monochrom> See? Everyone has a fetish.
15:26:03 <ysangkok> maerwald: hmmm interesting... i am making FFI bindings and there are a few things that have to be in order with the arguments for the call to succeed
15:26:21 <ysangkok> maerwald: the underlying library can either return FALSE or it can abort
15:26:42 <ysangkok> i map both of those inputs to Nothing for simplicity
15:27:08 <solonarv> ;(
15:27:22 <monochrom> {abby}: Just playing Civ5 too much and thinking in diplomatic politics "I will join your war if you give me pearl" or something :)
15:27:26 <ysangkok> if i introduce error types, those will be errors that are not existing in the underlying library
15:28:59 <ysangkok> i think that is a fragile for a FFI binding to try and invent error types. since the underlying library could change and start returning FALSE on something that would previously abort (but that i prevented by checking first), it would be visible to consumers
15:29:05 <monochrom> Your whole point of writing code is you add values not already provided by a library.
15:29:37 <solonarv> my main issue with turning all errors into a blanket 'Nothing' is that a user of your library won't know what the error was
15:29:53 <maerwald> You can always turn an Either into a Maybe
15:29:54 <MarcelineVQ> solonarv: blanket String then :>>>
15:29:54 <maerwald> so
15:30:02 <maerwald> But you can't reasonably go from Maybe to Either :>
15:30:09 <solonarv> MarcelineVQ: that *is* better (a bit)
15:30:13 <berndl> Is anyone familiar with the combinator \ f g h x y -> f (g x) (h y)?
15:30:29 <Axman6> :t on
15:30:30 <koz_> @pl \f g h x y -> f (g x) (h y)
15:30:30 <lambdabot> ((flip . ((.) .)) .) . (.)
15:30:31 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:30:34 <ysangkok> ok will do error types then as best as i manage :) there is consensus
15:30:46 <solonarv> and if String error messages are good enough for you, then you can use MonadFail
15:30:55 <koz_> ysangkok: Basically, the point of view is 'how do I give the user as much useful information about what happened as possible?'.
15:31:02 <solonarv> or you can just use the IO exception mechanism
15:31:45 <berndl> koz_: That's neat. Apparently it's called dovekie in this purescript library: https://pursuit.purescript.org/packages/purescript-birds/1.0.4/docs/Aviary.Birds#v:dovekie
15:32:08 <solonarv> berndl: it looks almost like liftA2 or on
15:32:10 <solonarv> but not quite
15:32:33 <solonarv> on commons up the g and h arguments, liftA2 commons up x and y
15:32:41 <{abby}> berndl: I don't like how that documentation page uses Λ where they mean ∀
15:33:20 <Axman6> :t  \ f g h x y -> f (g x) (h y)
15:33:21 <lambdabot> (t1 -> t2 -> t3) -> (t4 -> t1) -> (t5 -> t2) -> t4 -> t5 -> t3
15:33:28 <Axman6> @hoogle  (t1 -> t2 -> t3) -> (t4 -> t1) -> (t5 -> t2) -> t4 -> t5 -> t3
15:33:28 <lambdabot> Util compose2 :: (a' -> b' -> c) -> (a -> a') -> (b -> b') -> a -> b -> c
15:33:47 <berndl> compose2?
15:34:12 <berndl> Aha.
15:34:17 <berndl> That's it.
15:35:43 <berndl> Thanks Axman6
15:36:49 <Axman6> no idea where that comes from though
15:37:28 <Axman6> it's also (uncurry f .) . (g &&& h) I think
15:37:33 <Axman6> maybe not
15:50:26 <berndl> I never thought this would happen, but sometimes point-free code ends up being longer than the equivalent with lambdas.
15:52:50 <koz_> Pointfree(X) -> Concise(X) is false, who'd have thunk it?
15:52:50 <jared-w> berndl: that'll always happen
15:52:53 <monochrom> point-free code can be better or worse, depending on which point-free tools you use
15:54:39 <monochrom> I use point-free (wisely and with suitable point-free primitives) to show higher-level thinking, not to be short. Short is a side effect.
15:55:00 <berndl> jared-w: Not always. It depends on the names of things.
15:56:06 <jared-w> berndl: I meant that one thing will never always be better than another (by some definition of better).
15:56:13 <monochrom> Point-free is a special case of re-factoring.  As usual, there are obscuring re-factorings and enlightening re-factorings.
15:56:27 <jared-w> There's always going to be some odd pathological case or two or twenty :)
15:57:39 <joeyh> sm[m]: ty! and the backend is servant+lucid
15:59:09 <monochrom> joeyh: I find it a bit too magical.  Does your web app classify pictures to say "this looks like plastic", "this looks like wood", "this looks like a cat", etc?
15:59:24 <monochrom> (How long do I quarantine a cat? :) )
15:59:47 <berndl> Having the right combinators is key to point-free. Having to curry/uncurry stuff is terrible.
15:59:50 <monochrom> Poor quarantined Schrödinger's cat.
16:00:31 <monochrom> Likewise, identifying the right abstractions and building blocks is key to re-factoring
16:01:40 <monochrom> Unqualified "is point-free better/shorter/xxxer?" is always insufficient-information-for-a-meaningful-answer.
16:01:59 <joeyh> monochrom: no, that's why there are check boxes to pick which surface(s) it has
16:02:23 <monochrom> Hrm, then what does the picture do?
16:02:30 <joeyh> reminds you what it is
16:02:37 <monochrom> OK!
16:03:29 <joeyh> much easier to snap bank statement + pay check + medication all lying on the shelf than desribe them :) (actual example)
16:03:30 <monochrom> Do you return a picture that's like the input picture but with a timestamp printed on it?
16:04:11 <joeyh> no, it only downscales it, the countdown timer is JS
16:04:26 <monochrom> I guess you can tell I am too lazy to try...
16:05:21 <monochrom> Ah I need a pair of mutually recursive functions for my weekly exercise (inflicted on my students)
16:05:41 <monochrom> The severse limitation is they can only map integers to integers.
16:05:58 <monochrom> If necessary can take more integer parameters but meh.
16:06:52 <monochrom> I used to use Hofstadter's male-female sequence but it gets old and, I dunno, sexist?
16:07:15 <monochrom> At least it's a very contrived pair of functions.
16:07:22 <{abby}> The only pair of mutually recursive functions I can conjure easily is the dumb definition of odd/even..
16:07:40 <{abby}> You could make a flimsy argument that it maps integers to integers by defining Bool = Z/Z2 :p
16:07:55 <monochrom> Yeah I did that in exam once.
16:08:18 <monochrom> Actually I forgot I also have booleans.
16:08:34 <{abby}> It's a simple spell, but quite unbreakable
16:09:30 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
16:09:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:09:55 <Cale> ^^ nice bit of mutual recursion
16:10:54 <monochrom> What if I don't have div or mod?  This is an untyped lambda calculus plus integer and boolean I'm inflicting on my students.  The exercise is use the self-application trick but for mutual recursion.
16:10:57 <Cale> (but not of the correct type)
16:11:08 <monochrom> Also I don't have lists.
16:11:32 <Cale> You're in the untyped lambda calculus, of course you have lists ;)
16:11:53 <monochrom> For integers I have +, *, ==.  (I have negative literals like -5 if necessary.)  For booleans I have if-then-else.
16:11:57 <Cale> But yeah, this would suck as an exercise in the untyped lambda calculus
16:12:11 <monochrom> Naw I didn't teach them Church encoding, too long story, out of scope for my course.
16:13:05 <koz_> If I have something like 'foo <- makeFoos; guard (amIBar foo); Baz <$> foo' in the context of the list monad, will this produce a list of Baz's full of foos for which amIBar is true?
16:13:27 <monochrom> Some Lucas sequence thing could be OK, I'm just looking for more relatable examples for CS students.
16:14:06 <gentauro> why do I get `stack overflow` with this? `foo 0 = 0; foo n = let a = foo (n-1) in a `seq` a + 0`?
16:14:41 <gentauro> I'm testing with `foo 9223372036854775807 :: Int`
16:14:41 <monochrom> Because you have a deep tall tree of +'s
16:14:56 <monochrom> No, I spoke too fast.
16:15:06 <gentauro> monochrom: shouldn't `seq` force evaluation?
16:15:25 <monochrom> But your rule of thumb is also too simplistic.
16:15:30 <gentauro> I mean, I'm only adding 0 to 0 a lot of times
16:15:53 <gentauro> my guess is that mem usage should be constant
16:15:58 <solonarv> koz_: yes
16:16:18 <Axman6> but GHC doesn't know that - and forcing a means it has to recurse and evaluate f (n-1), which has to evaluate f (n-1) which has to ...
16:16:26 <monochrom> I spoke correctly.  You are still building a deep tall tree of +'s despite your seq.
16:16:31 <solonarv> koz_: that expands to: makeFoos >>= \foo -> if amIBar foo then Baz <$> foos else []
16:16:41 <solonarv> assuming makeFoos :: [[Foo]], is that the right type?
16:17:01 <Axman6> I don't believe GHC has a transformation which turns n + 0 => n
16:18:04 <monochrom> Here is a very short slick proof.  Since + itself is already eager, a `seq` a + 0 = a+0.
16:21:21 <gentauro> monochrom: :|
16:22:04 <monochrom> And that sentence you don't have to take it from me for grant like it's abstract theory.  If you know how to read core (or God forbid GHC-generated asm), you can test it.  With or without your ineffective seq, the generated codes are identical.
16:22:30 <gentauro> I added `:set +s` 
16:23:14 <gentauro> `foo 200000` uses: (0.12 secs, 58,069,224 bytes) which sound like a lot 
16:23:18 <monochrom> Anyway, you asked why, here is why.  Your code builds a tall tree of +'s.  Then the computer has to walk down this tree for the actual addition.  This is when stack is used, stack size proportional to tree depth.
16:23:26 <Axman6> gentauro: can you not see that to return the result of a + 0, you have to evaluate a?
16:23:53 <gentauro> Axman6: I'm probably to tired
16:24:00 <gentauro> and my eyes hurt ...
16:24:09 <monochrom> Then go to sleep.
16:24:44 <gentauro> monochrom: probably a good idea
16:34:32 * hackage quarantimer 1.20200323 - Coronavirus quarantine timer web app for your things  https://hackage.haskell.org/package/quarantimer-1.20200323 (JoeyHess)
16:37:12 <berndl> Is there a name for the code-smell of a recursive function implemented using a fold that is carrying around some bit of state in the accumulated result?
16:39:25 <Cale> > foldr (\x xs s -> s : xs (s + x)) (const []) [1..10] 0
16:39:28 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
16:39:37 <Cale> > foldr (\x xs s -> s : xs (s + x)) (\s -> [s]) [1..10] 0
16:39:40 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
16:39:52 <Cale> berndl: You mean like that?
16:40:11 <Cale> I don't know if there's a name for that
16:41:57 <berndl> Cale: I was thinking of cases where you can achieve the same result using an unfold.
16:42:51 <berndl> For example, the function f such that f n = [0, ...., n].
16:44:55 <phadej> I don't think that implementing that as paramorphism (i.e. fold which carries the current value) a code-smell
16:45:04 <phadej> true, ana/unfold is simpler
16:45:15 <berndl> Yes.
16:45:34 <phadej> but both are IMO valid ways to think about the problem
16:48:38 <monochrom> This shows that people abuse code-smell shaming too much and too overreacting.
16:50:21 <monochrom> "code smell" is something we intend to be applicable broadly. Therefore we should also use more benefit of doubt before classifying something as code smell.
16:50:47 <phadej> yes, I don't think this is code-smell
16:51:03 <phadej> it's usign a paramorphism where more simpler anamorphism (unfold) would be sufficient
16:51:37 <phadej> ... but whether it's simpler is subjective
16:51:54 <berndl> Well, unfoldr is readily avaiable.
16:52:38 <phadej> yes, writing recursion explicitly, when there is a combinator is more smelly
16:53:56 <monochrom> Such as foldl being defined by its own recursion rather than by "simply" calling foldr? >:)
16:54:18 <phadej> monochrom: ...
16:54:31 <berndl> Well, technically foldl is the fold for snoc lists.
16:54:34 <monochrom> Fun fact: In Foldable default implementations, you'll also find foldr' defined by foldl or something >:)
16:55:09 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Winter/l05/FoldlFoldr.hs
16:55:53 <phadej> monochrom: yes, foldMap or foldr is enough
16:55:59 <phadej> or toList, technically
16:56:11 <phadej> s/technically/in theory/
16:56:48 <monochrom> foldr' f z0 xs = foldl f' id xs z0      where f' k x z = k $! f x z
16:57:06 <monochrom> and...
16:57:17 <monochrom> foldl' f z0 xs = foldr f' id xs z0      where f' x k z = k $! f z x
16:57:43 <monochrom> A pair of beauty cuties I need to learn one day.  (Well, I guess I already learned the second one.)
16:58:28 <phadej> Endo a and Dual (Endo a) are your friends
16:58:43 <phadej> i.e. difference lists
16:59:51 <berndl> yeah, foldr is just foldMap with Endo and foldl is foldMap with Dual Endo.
17:00:42 <monochrom> Anyway, I was teasing you, but I'm nerd-sniped by any surprising use of catamorphisms.
17:01:23 <monochrom> not as impressed by foldMap though.  Too easy.
17:03:13 <berndl> That it is too easy suggests that foldMap is a better combinator.
17:09:24 <berndl> Are there isos for Dual and Endo?
17:10:04 <solonarv> berndl: I think that's covered by the more-general newtype isos
17:10:35 <solonarv> assuming you want Iso (Endo a) (Endo b) (a -> a) (b -> b), and Iso (Dual a) (Dual b) a b
17:10:50 <Axman6> like _Wrapped
17:10:57 <Axman6> :t _Wrapped
17:10:59 <lambdabot> (Rewrapped s t, Rewrapped t s, Profunctor p, Functor f) => p (Unwrapped s) (f (Unwrapped t)) -> p s (f t)
17:11:14 <Axman6> % :t _Wrapped @Endo
17:11:14 <yahb> Axman6: ; <interactive>:1:11: error:; * Expecting one more argument to `Endo'; Expected a type, but `Endo' has kind `* -> *'; * In the type `Endo'; In the expression: _Wrapped @Endo
17:11:27 <Axman6> % :t _Wrapped @(Endo a)
17:11:27 <yahb> Axman6: ; <interactive>:1:17: error: Not in scope: type variable `a'
17:11:32 <Axman6> % :t _Wrapped @(Endo Int)
17:11:32 <yahb> Axman6: (Profunctor p, Functor f) => p (Int -> Int) (f (b -> b)) -> p (Endo Int) (f (Endo b))
17:11:49 <berndl> Aha. Cool.
17:34:41 <dsal> : fromRight
17:34:45 <dsal> :t fromRight
17:34:47 <lambdabot> b -> Either a b -> b
17:34:47 <dsal> :t fromJust
17:34:48 <lambdabot> Maybe a -> a
17:34:51 <dsal> That just cost me some time.
17:35:39 <monochrom> How come?
17:43:04 <Axman6> it's not particularly consistent - fromRight is equivalent to fromMaybe not fromJust
17:43:45 <monochrom> Oh! That.
17:43:56 <monochrom> Don't trust meaningful names.
17:44:31 <monochrom> Join my other campaign "meaningful names are misleading" :)
17:44:44 <{abby}> Now that's one I can get behind
17:45:18 <dsal> I had a combination of Maybes and Eithers in a case where I knew I had a Just Right, so I had a    fromJust undefined ...
17:45:44 <jumper149> What is the current situation on formatters for Haskell? Any recommendations?
17:47:25 <Clint> what kind of formatters?
17:53:11 <dmj`> it's hard to get things Just Right sometimes
17:53:50 <{abby}> Oh, you
17:54:04 * dmj` dabs
17:54:17 <Axman6> Yeah all the shops are sold out! https://www.kelloggs.com.au/en_AU/brands/just-right.html/
17:54:40 <jumper149> Clint: I noticed that I can't keep up my formatting in haskell source files regarding whitespace, line breaks etc and would like a tool to check up files for me. I'm currently looking at brittany.
17:57:15 <monochrom> haha dmj`
17:57:19 * dmwit . o O ( fromRight :: Either e a -> Either e a )
17:57:52 <monochrom> That's safeFromRight, like my safeFromJust
17:58:07 <dmwit> jumper149: :set ai pi ci
17:58:07 <dmwit> ;-)
17:58:28 <monochrom> AI pi continuous integration
17:58:43 <monochrom> That's our new skynet and singularity
17:59:01 <Clint> jumper149: hindent has some limitations but if you don't hit them it works well enough
17:59:04 <dmwit> Don't worry, vim's AI is very, very dumb. It's why I like it!
17:59:18 <monochrom> It's AI that uses CI to keep upgrading itself so it's full circle so pi.
17:59:51 <dmwit> There is a dimension that goes from "predictable" to "smart". I like "predictable" when I'm trying to control it.
18:00:26 <monochrom> control freak
18:02:12 <Cale> .oO(vim talktotransformer integration)
18:03:02 <monochrom> what is talktotransformer?
18:03:08 <Cale> https://talktotransformer.com/
18:03:25 <Cale> It's just a website where you can play with GPT-2
18:03:27 <monochrom> haha
18:03:46 <monochrom> That's better than emacs eliza.
18:03:58 <monochrom> emacs needs to catch up
18:03:58 <Cale> It's actually pretty impressive
18:04:08 <Cale> Probably sucks at code
18:05:31 <Cale> Sometimes it's kinda hilarious
18:05:58 <monochrom> Haha I entered "what is talktotransformer?"
18:06:06 <Axman6> The monat tutorial written by GPT-2 was amazing - it spent the whole time talking about how difficult Monads are and apologising for that fact
18:06:39 <Cale> Note that it'll give you a different block of text every time
18:06:40 <Axman6> https://impurepics.com/monad-tutorial/index.html
18:06:43 <Axman6> Monad*
18:07:13 <Cale> "There will be lots of examples but you will not learn them here."
18:07:16 <Cale> hahaha
18:08:22 <Cale> You can try it yourself by putting Monad Tutorial into talktotransformer and then leaving a blank line
18:08:30 <monochrom> I entered "what is monad?" into talktotransformer.  You should too.  It will be cool.
18:08:30 <jumper149> dmwit: that joke went over my head ^^
18:09:07 <monochrom> "In Haskell, all data is fundamentally about strings."
18:09:34 <Axman6> haha
18:09:38 <Axman6> Is there a monad in Haskell that can both read and write its input data structures? The answer is no. The read and write operations are mutually exclusive. A Haskell program that can read one element from a file, but not write another, is still a program that can read data, but not write data. In other words, the program does have a monad, but only in the sense that, given the structure of the program, it can simultaneously read from and writ
18:09:38 <Axman6> e to one single file.
18:09:50 <Axman6> well there we go, state doesn't exist
18:09:56 <{abby}> Hahah :D: 
18:10:05 <monochrom> This is depressing.
18:10:26 <Cale> "The main goal is to reduce Haskell's dependency on other libraries. We're going to be defining a simple monad library, with only two functions: return and bind. We'll then be running it against an example HSP application, and comparing that with how to do things in GHCi."
18:10:30 <Axman6> The binary function addTwoNumbers is simply:
18:10:32 <Axman6> addTwoNumbers :: Int -> Int -> Int -> Int
18:10:34 <monochrom> But you can get different results with different amounts of newlines after.
18:10:42 <Axman6> :thinking_face:
18:10:59 <Cale> monochrom: You'll get a different result just by hitting the button again
18:11:06 <monochrom> Ah OK!
18:11:06 <Cale> (It's randomised)
18:11:42 <monochrom> I'm so devastated I'm now asking it "what is the meaning of life?"
18:11:48 <Axman6> ... he biggest difference between them is that, when you're declaring an instance of a monad in Java, you use what is known as an Functor.
18:12:05 <erisco> this monad article reads like a philosophy text, honestly
18:12:27 <{abby}> Well, either you have a monad tutorial (e.g. burritos, boxes, fish, etc) or a monad treatise
18:12:32 <monochrom> And it lists like 11 bullet points, the first 7 asking about socialism.
18:13:09 <dsal> Elm has functors and monads, but avoids confusion by not calling them that.
18:13:43 <dmj`> not really
18:13:46 <{abby}> Avoid confusion by not generalising over them, thus avoiding the need to name them at all ;)
18:13:52 <dsal> Yeah. :(
18:14:03 <dsal> But they all have the same name, which is... Nice?
18:14:21 <{abby}> Is it all flatMap everywhere?
18:14:43 <monochrom> them flatmappers
18:14:45 <dsal> Everything has a .Map and .AndThen
18:14:53 <Cale> "I went over the mountain and found" -> "a little ruins of the High Road. There the wild animals have been feeding, sucking the milk of the plant-song-cattle, coolsing in the shade and panting out the music of the trees. I sit down and think. Well, this is the best I could do. This is why we must kill them all. Some of the warriors so sick and weak begged for their lives. And some of the highest-lived ones, who were crowned with 
18:14:53 <Cale> splendid and golden armlets, were teetering, like the snow in winter."
18:15:07 <{abby}> ah, andThen, almost as bad as flatMap
18:16:00 <{abby}> "Lately in the Ivory Tower," → "it has become fashionable to talk about myths instead of the past. Just ask us about the reality of slavery in Italy and the legal systems of the 10 colonies that came with it."
18:16:53 <Cale> "Doctors Wednesday" -> " reported that the children have been receiving medical care at an Edmonton hospital, while one teenager is being transferred to the hospital in Saskatoon, and that two others are being treated at a specialist burns unit in Edmonton. RCMP say they have not been contacted by the parents, but no charges have been laid. RCMP began investigating the family after the shooting of Tyler Fortier, 11, and Cooper Fortier, 
18:16:53 <Cale> 13, by an armed man who appeared to have been targeting a power pole that linked the Barton Street church to the mayor's home."
18:17:04 <Cale> It's really good at inventing realistic news stories
18:17:18 <int-e> -blah
18:17:33 <Cale> Yeah, should take it to -offtopic or something
18:35:29 <jumper149> Does it make sense to have ExceptT as the outermost monad transformer stack so you can pattern match on Right and Left?
18:35:45 <jumper149> outermost monad transformer on the stack*
18:36:51 <erisco> Where it occurs in the stack does not change whether you can pattern match Either, but does change semantics, so I would focus there
18:39:58 <jumper149> erisco: My question didn't make sense, but that cleared my head up :)
19:21:32 <koz_> jumper149: Yeah, I would advise heavy use of @unmtl to ensure you're getting the semantics you want.
19:21:57 <koz_> ExceptT is one of those annoying cases which changes (sometimes significantly) what you get based on where in the stack it resides.
19:24:46 <dsal> What's @unmtl ?
19:25:02 <koz_> @unmtl StateT s Maybe a
19:25:02 <lambdabot> s -> Maybe (a, s)
19:25:04 <koz_> ^
19:25:39 <dsal> Oh.  I just tried that without an arg and it gave me an unhelpful error.
19:39:16 <solonarv> jumper149: but beware that @unmtl does not know about ExceptT. use ErrorT instead.
19:39:29 <solonarv> (it has the same representation, just different instances)
19:42:32 * hackage dependent-sum 0.6.2.2 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.6.2.2 (3noch)
19:44:31 * hackage dependent-sum-template 0.1.0.2 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.1.0.2 (3noch)
19:46:48 <jumper149> koz_: Will try that tomorrow, bed time now :p
19:50:02 * hackage generic-random 1.3.0.1 - Generic random generators for QuickCheck  https://hackage.haskell.org/package/generic-random-1.3.0.1 (lyxia)
20:16:20 <slack1256Alt> Hi, on qtah-qt5 is there a way to interface with a qt creator file?
20:16:35 <slack1256Alt> On gi-gtk I can use glade and cast identifiers to Gtk objects.
20:41:53 <dsal> Does anyone know how I can set a non-existent key in a map using lens?  e.g. ,     v % key "x" .~ val     where "x" doesn't exist.
20:46:22 <dsal> % (mempty :: M.Map String String) & at "x" ?~ "y"
20:46:22 <yahb> dsal: fromList [("x","y")]
20:46:28 <dsal> That seems to be the answer.
20:48:30 <solonarv> dsal: or more explicitly: mymap & at "x" .~ Just "y"
20:48:37 <solonarv> (that's what ?~ does)
20:48:57 <dsal> Oh thanks.  I was just trying to figure out ?~
20:49:10 <dsal> % (mempty :: M.Map String String) & at "x" .~ Nothing
20:49:10 <yahb> dsal: fromList []
21:24:18 <ryantm> When my Haskell project compiles, it first makes .o files then it makes .p_o files. Any idea what those are? I tried searching for it, but it is hard to search for.
21:25:33 <Axman6> they're profiling versions of the .o files
21:26:21 <ryantm> Ah okay, thanks!
21:27:02 * hackage cabal-cache 1.0.1.6 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.6 (haskellworks)
21:39:02 * hackage cabal-cache 1.0.1.7 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.7 (haskellworks)
21:45:02 * hackage pandoc 2.9.2.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.9.2.1 (JohnMacFarlane)
22:27:25 <int-e> I wonder why compiling regex-tdfa is such a memory hog... it pushes ghc-8.6.5 to above 2G.
22:28:45 <ysangkok> how do i write the function "Sing n -> CSize"?
22:28:57 <ysangkok> fromSing is not the one...
22:39:52 <gentauro> why does `stylish-haskell` remove `{-# LANGUAGE BangPatterns #-}` as a redundant pragma? I mean, if I don't have that pragam, I'm not allowed to write: `foo !a !b = a + b`
22:40:10 <gentauro> s/pragam/pragma/
22:41:23 <Axman6> were you using bang patterns when it removed it?
22:46:23 <int-e> does `stylish-haskell` look at the default pragmas from a project .cabal file?
22:46:32 <int-e> pragmas -> language extensions
22:49:12 <ysangkok> i figured it out! of course i need a KnownNat constraint
22:51:19 <gentauro> Axman6, no I wasn't 
22:51:28 <gentauro> so that's why ... 
22:51:30 <gentauro> Axman6: thx
22:52:28 <gentauro> (my approach was that I was adding it on the top of the file and then I was saving for the auto-alignment with the others pragmas, but then it suddenlty dissapeared)
