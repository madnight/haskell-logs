01:03:31 * hackage language-javascript 0.7.1.0 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.7.1.0 (ErikDeCastroLopo)
01:17:38 <bwe> Good morning! Is it a good idea to evolve from phantom types to type families for this example? https://bpaste.net/GQGQ
01:51:29 <dmj`> bwe: its a good idea to use newtypes
01:53:02 <dmj`> bwe: type families are when you want to make a relationship between two types, not sure this example warrants that
01:53:55 <dmj`> bwe: you could use a GADT though
01:56:32 * hackage pandora 0.2.4 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.4 (iokasimovmt)
01:58:16 <N3RGY> Is there any way to pattern match on a KnownNat's natSing? I'm trying to write a recursive function over statically sized matrices and I'm having trouble figuring out how to do the base case. I figure I need to pattern match on a singleton type corresponding to the size type variable, but I can't figure out a way to do that
02:01:31 <bwe> dmj`: ok! what I was thinking about is that Metres and Pieces form their own category. yet a type class would make no sense for me because there's no function to define under the instance definition. 
02:01:55 <dmj`> N3RGY: you should use a closed type family
02:02:20 <N3RGY> dmj`: Know any examples of how that will let me get a value I can match on?
02:03:11 <dmj`> N3RGY: technically you'll need an associated type family and a type class
02:03:28 <dmj`> N3RGY: are you trying to extract the Nat value?
02:03:52 <N3RGY> I need to be able to check if the value is equal to 1 and do something different than if the value is greater than one
02:04:24 <dmj`> bwe: you would make your data type an instance of Category, although it's probably not necessary, since fields are functions and you can just compose them and (->) is already a Category
02:05:24 <dmj`> N3RGY: easy way is to just call natVal :: Proxy (k :: Nat) -> Int
02:05:33 <dmj`> N3RGY: and do it at the value level
02:05:43 <N3RGY> I need GHC to also know that k == 1
02:06:23 <N3RGY> I'm calling some library functions with constraints that (1 <= k), so I must discharge those
02:06:53 <bwe> dmj`: I basically feel it makes sense to me to constrain the `a` in to be either Metres or Pieces  `data Size a = Size Int deriving Show`
02:07:23 <N3RGY> I'm thinking something like "case magic :: HowBigIs k of It'sOne -> ...; It'sBigger -> ..." 
02:07:39 <N3RGY> Where HowBigIs is a GADT with constructors for ==1 and >1
02:08:03 <N3RGY> But I can't figure out a way to actually get GHC to do that
02:08:08 <dmj`> N3RGY: just to show that its greater than 0 ?
02:08:16 <dmj`> N3RGY: Nats cannot be negative
02:08:26 <N3RGY> But they can be zero
02:08:36 <dmj`> N3RGY: yea, ok, then that case makes sense
02:08:58 <dmj`> N3RGY: case matching is only relevant if you have a SomeNat and its holding an existential
02:09:44 <N3RGY> The general thing I want to do, which will be useful in more than the exact thing I'm doing right now, is to be able to check if a Nat has some particular value
02:09:54 <N3RGY> And have GHC also know that it has that particular value
02:10:06 <dmj`> bwe: data Size a where Metres :: Int -> Size Metres; Pieces :: Int -> Size Pieces
02:11:40 <dmj`> type family GreaterThanZero (x :: Nat) where GreaterThanZero 0 = TypeError "Value is 0"; GreaterThanZero x = '()
02:12:04 <dmj`> N3RGY: this is like a validation check, it belongs in the context of a function, you'll need -XConstraintKinds enabled
02:12:17 <N3RGY> I don't think that helps with what I'm trying to do
02:12:28 <N3RGY> I already have a constraint proving that (1 <= k)
02:12:52 <bwe> dmj`: https://bpaste.net/DSCQ  -- Not in scope: type constructor or class ‘Metres’
02:13:11 <N3RGY> What I need to do is: check whether k == 1. If it does, do some stuff. That stuff won't typecheck unless GHC also knows k == 1. If k > 1, I need to do some other stuff. That stuff won't typecheck unless GHC knows k > 1
02:14:22 <dmj`> bwe: data Metres; data Pieces;
02:16:27 <N3RGY> I could almost use Data.Type.Equality, except that I really doubt GHC is clever enough to figure out that "(1 <= k)" and "testEquality (Proxy @k) (Proxy @1) == Nothing" implies "(2 <= k)"
02:16:43 <dmj`> N3RGY: so you want to constrain the variables on a GADT constructor by your type family
02:18:13 <bwe> dmj`: https://bpaste.net/JBIA
02:18:54 <N3RGY> dmj`: Something like this? http://paste.best/p/xHwwK-EhNfs=
02:19:06 <dmj`> bwe: data Size a where
02:20:55 <bwe> dmj`: Good. That works now. What do I need for a show instance?
02:29:07 <bahamas> dmj`: hey. can you tell me exactly what jsaddle does for miso? meaning, can I develop with miso without jsaddle?
02:29:28 <dmj`> bahamas: yes, I never use jsaddle for mis
02:29:32 <dmj`> miso*
02:29:46 <dmj`> bahamas: it basically just lets you use GHC instead of GHCJS for development
02:30:23 <dmj`> bahamas: I use `ag -l | entr sh -c 'cabal configure --ghcjs && cabal build <app>'`
02:30:30 <dmj`> and have that open in a terminal
02:30:37 <dmj`> along with the server in a separate one
02:31:54 <bahamas> dmj`: I assume I need to replace <app> with something. in my case, I don't have a server, so I'm just building the client code
02:32:10 <dmj`> N3RGY: almost got it one sec
02:32:17 <N3RGY> cool thanks
02:33:39 <dmj`> bahamas: then I'd just do 'python -m SimpleHTTPServer' to host the assets
02:44:37 <bahamas> dmj`: I got it to work. thank you!
02:44:45 <dmj`> bahamas: nice
02:45:38 <suppi> dmj` are you familiar with wai-app-static? It's a nicer alternative to SimpleHTTPServer
02:48:11 <N3RGY> suppi: Nice, they moved SimpleHTTPServer in python3 and I always forget how to do the new one. Will give that a shot next time I need a server
02:49:26 <dmj`> suppi: indirectly, it comes w/ servant-server so I use it from there, the python is just a one liner so its easy
02:49:45 <dmj`> suppi: did your nick used to be supki ? 
02:49:59 <suppi> nope. supki is unrelated to me :)
02:50:44 <bahamas> dmj`: I don't know if this helps you, but there's something I found confusing. `startApp` returns `JSM ()`, but `main` has type `IO ()`. I had to lookup `JSM` to find that it corresponds to `IO` when compiling with ghcjs
02:50:57 <bahamas> I was using ghcid and I was getting a compile error
02:53:50 <N3RGY> Any luck with the GADT thing dmj`? Going to sign off soon
02:54:12 <dmj`> N3RGY: this solution doesn't use GADTs,  https://gist.github.com/dmjio/f7fca9ab4465b3d37426dfce3c8197c5
02:55:18 <bahamas> dmj`: another question. I'm actually building an electron app. how do I include a css framework in the miso project?
02:55:22 <N3RGY> dmj`: I don't think that solves the problem. Pattern matching on a Result doesn't tell GHC anything about the type variable
02:55:48 <N3RGY> Hence why I suspect GADTs are necessary
02:55:48 <dmj`> N3RGY: the typeclass instance does, GetX 0
02:56:16 <dmj`> N3RGY: you're trying to map a Proxy Nat onto a sum type in a type safe way right
02:56:36 <dmj`> bahamas: I'd just put a link to the css cdn in the index.html 
02:56:51 <dmj`> bahamas: the haskell-miso.org source does this
02:58:08 <N3RGY> dmj`: Each constructor of the sum type also has to witness, at the type level, a constraint on the value of k (either k == 1 or 2 <= k)
02:58:36 <N3RGY> There are two branches, depending on the value of k, but neither branch will compile unless GHC has some idea about the value of k within the branch
02:59:01 <N3RGY> I don't even care about the concrete value of k if it's greater than 1
02:59:23 <dmj`> N3RGY: data K n where IsZ :: K 0; Greater :: Int -> K n, would encode the type in the constructor
02:59:38 <N3RGY> dmj`: Yes
02:59:47 <N3RGY> Do you think your solution would allow me to encode that?
02:59:51 <bahamas> dmj`: does that work with Electron?
03:00:01 <N3RGY> (Also, I would want "Greater :: (2 <= n) => K n"
03:00:43 <dmj`> N3RGY: you don't care about 1 ?
03:00:48 <dmj`> bahamas: CSS should yea
03:01:00 <N3RGY> dmj`: The only two cases I care about are 1 and >1
03:01:12 <N3RGY> I can rule out k == 0 with a constraint on the entire function
03:01:25 <bahamas> dmj`: ok then. thanks
03:04:32 <N3RGY> dmj`: Here's what I think I need: http://paste.best/p/40O2dLPtw7A=
03:04:46 <dmj`> bahamas: you should join the slack, I'd be interested in making an electron app with miso
03:05:17 <N3RGY> Pattern matching on a Wit will A) tell me the value of k B) introduce sufficient constraints on k to allow the code in the branch to compile
03:06:46 <bahamas> dmj`: alright
03:08:18 <dmj`> N3RGY: do you want 0 and 1 to produce type errors
03:08:32 <N3RGY> No, don't worry about that
03:08:38 <N3RGY> It's orthogonal to the problem
03:11:33 <N3RGY> GHC is (I think) smart enough not to bother me about the 0 case if I have (1 <= n) as a constraint
03:11:46 <N3RGY> But anyway, the core of the problem is as specified in that paste
03:12:20 <dmj`>  yea, the core of the problem is you want to go back to a generalized n after providing 0
03:12:39 <dmj`> getX proxy = case natVal proxy of 0 -> Is0 
03:12:45 <N3RGY> I don't understand what you mean by that
03:13:33 <dmj`> this won't compile because Is0's type has nat 0 in it, but the function getX is defined as Proxy n -> K n
03:13:59 <N3RGY> Oh, uh yeah
03:14:07 <N3RGY> NatVal doesn't carry the requisite type information
03:14:17 <N3RGY> Hence the need for a singleton-ish GADT
03:14:20 <dmj`> yea, Is0 is too specific
03:15:47 <dmj`> " Couldn't match type ‘n’ with ‘0’  "
03:19:58 <dmj`> N3RGY: I think it's possible, I believe I've done it before, I just can't think of it right now
03:20:27 <N3RGY> I guess the question boils down to "implement dependent type support", so I can't be too surprised it's not obvious haha
03:20:28 <dmj`> It would work fine with unsafeCoerce :)
03:20:43 <N3RGY> Thanks for looking anyway!
03:20:53 <dmj`> I'm positive I've done something similar like this with type families and GADT constructors
03:28:54 <dycan> hi, is anyone successfully using nix haskell binary caches? I have to recompile all haskell pakcages every time I change package specs.
03:29:38 <Uniaika> I use stack + nix support, it's going fairly well on my side
03:32:15 <Rembane> dycan: What's your setup?
03:32:45 <dycan> Uniaika: I see. Thanks.
03:34:16 <dycan> Rembane: I use nixos. And I am trying snack.  I saw this iohk plutus thing. nix = {   binaryCaches          = [ "https://hydra.iohk.io" "https://iohk.cachix.org" ];   binaryCachePublicKeys = [ "hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=" "iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo=" ]; };
03:36:37 <dycan> I am rebooting to see if I can get nix-env substitutes and get cache when I snack build (nix-build inside) next time.
03:37:28 <dycan> Rembane: Do you use haskell binary caches to speed up compiling?
03:44:06 <Rembane> dycan: Only the local ones. It was a while ago now. I'm hoping for someone else here to give you more help.
03:44:14 <dmj`> dycan: you need to be filtering your source appropriately as well, o/w nix will rebuild haskell code in response to non haskell code changing
03:44:56 <dmj`> dycan: binary caches don't really affect compilation, just time spent acquiring dependencies is diminished. 
03:45:52 <dycan> Thanks for sharing, Rembane.
03:47:03 <kenran> I've been trying to use nim-lang in a tiny project of mine on NixOS. It has a dependency on `SDL2`. I can build it just fine, but when trying to run the binary it can't find the .so. When I had a similar problem in Rust, I created a shell.nix which has `SDL2` in its buildInputs and it worked, but doesn't for nim.
03:47:26 <kenran> args, wrong channel number, so sorry
03:47:45 <dmj`> kenran: make sure you guys are using the same hash of nixpkgs and same OS
03:48:21 <dycan> dmj: ya, diminishing time is what I need. I always bump into version problem. When I change one package version to see if if gets compiled, it always recompile from start.
03:48:54 <dycan> It takes hours.
03:49:11 <dmj`> dycan: then it might be recompiling GHC, in that case that shouldn't be happening
03:49:30 <dmj`> dycan: it should only recompile packages in the dependency tree
03:49:42 <dmj`> that your package depends on
03:51:23 <dycan> dmj: interesting. Maybe somehow snack is asking a ghcWithPackages. Does it lead to recompiling GHC?
03:51:56 <dmj`> dycan: can you change the dep, then paste the build plan that is emitted after calling nix-build
03:53:49 <dycan> okay, let me try again.
03:56:43 <dycan> I have 47 package dependencis. Is it too much to ask/
03:56:45 <dycan> ?
03:57:47 <dmj`> dycan: not the full build output
03:57:52 <dycan> one of them is project-m36, which has a lot of dependencies too. Maybe that's why.
03:58:05 <dycan> what's the build plan?
03:58:13 <dmj`> nix-build --dry-run
04:00:17 <dycan> oops, snack can't pass the -dry-run arg. I need to re-compile it. I'll try to understand it first. Thanks, dmj`!
04:03:30 <dmj`> dycan: ok
04:08:35 <dycan> I get "Exception: user error (unexpected output: []).  Maybe it's something to do with a lot of trace in nix code.
04:30:46 <maerwald> phadej: https://github.com/kowainik/autopack/issues/2 your expertise would be welcome there I think
04:31:04 <phadej> I think autopack is bad idea, and refuse to help with it.
04:31:10 <maerwald> Haha
04:32:14 <phadej> I consider it is unresponsible abused of build-type: Custom powers.
04:33:44 <doyougnu> I don't see what is has to offer over nix, stack + hpack, or even git tbh
04:34:19 <maerwald> it has to offer: not using nix, stack and hpack
04:34:42 <MarcelineVQ> isn't hpack the only application item in that list
04:34:45 <MarcelineVQ> *applicable
04:34:51 <maerwald> Yeah
04:35:19 <srk> I like this idea https://www.reddit.com/r/haskell/comments/14zxvs/could_cabal_be_an_edsl/
04:35:27 <srk> oops https://breaks.for.alienz.org/blog/2012/12/17/cabal-a-haskell-edsl/
04:35:33 <doyougnu> I mean it seems like you could replicate its features with nix and git right? Or am I missing something?
04:35:53 <_deepfire`> phadej: but do you agree with the intent of autopack?  Do you have any better ideas?
04:36:08 <MarcelineVQ> and its advantage over hpack is not needing a package.yaml just for module discovery
04:36:50 <MarcelineVQ> doyougnu: not that I'm aware of. this is what it does https://github.com/kowainik/autopack
04:37:00 <maerwald> _deepfire`: well, for external tools, the idea is bad, because the .cabal metainformation is now useless
04:37:12 <phadej> _deepfire`: no I don't agree. Use dhall-cabal, hpack, cabal-fmt; but don't make .cabal files "dynamic".
04:38:16 <phadej> e.g. cabal-fmt doesn't need extra files, just (comment) annotation inside .cabal files. Bonus, your .cabal files would look like I have written them :)
04:38:42 <fendor> +1 for cabal-fmt
04:38:45 <phadej> dhall-cabal OTOH have all including etc. stuff you get from dhall
04:38:55 <phadej> depends on what you value
04:39:34 <maerwald> phadej: cabal-fmt can auto-add exposed modules etc?
04:39:42 <doyougnu> MarcelineVQ: thanks. I see now, it really is hpack with the package.yaml file
04:39:48 <fendor> maerwald, http://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html#extra-expand-exposed-modules-and-other-modules
04:40:08 <maerwald> oh nice
04:41:39 <maerwald> dhall-to-cabal looks like overkill though :>
04:42:08 <phadej> I guess oliver has dozens similarly looking .cabal files; then it maybe isn't that overkill anymore. YMMV
04:42:50 <srk> oo, cabal-fmt! nice
04:43:18 <srk> phadej: is it possible to use it to rewrite existing cabal files (preserving whitespaces)?
04:43:30 <phadej> no, it's point is to fmt
04:43:39 <srk> I see
04:43:45 <phadej> its*
04:44:08 <srk> I would like to try automatically updating upper bounds when package builds / tests pass
04:44:54 <phadej> one can try to teach that to cabal-fmt (but the side-effect would be that it will reformat everything)
04:44:55 <srk> it's probably not hard to replace these without whitespace preserving parser anyway
04:45:42 <srk> that would need to be part of Distribution.Parsec I guess
04:45:50 <phadej> yet, it is relatively hard, as cabal-fmt doesn't "elaborate" .cabal file, it parses it to simple intermediate representation (think JSON)
04:46:56 <phadej> Proper whitespace preserving parser would be very difficult given Cabal constraints of accepting all the format variations over the history
04:47:27 <phadej> my gut feeling is that the resulting AST would look horrible
04:48:54 <maerwald> srk: don't overuse upper bounds, just use ^>=
04:49:13 <srk> can Haskells own parser preserve whitespace?
04:49:48 <phadej> srk: ghc-exactprint 
04:50:01 <phadej> it can, but it breaks on CPP tricks
04:50:11 <phadej> or at least did previously
04:50:48 <srk> that would be another argument for cabal eDSL
04:51:36 <srk> maerwald: that's new to me. I'm using nix instead of upperbounds quite a lot recently, not sure it's a good idea
04:51:55 <maerwald> see https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=build%20depends#pkg-field-build-depends for an explanation
04:52:40 <srk> yeah, thanks, already reading it :)
05:19:16 * MarcelineVQ officially learns that writing lenses doesn't help you use them
05:21:16 <dmj`> srk: I often ignore version bounds when using nix, its very convenient
05:21:42 <dmj`> srk: nixpkgs goes through stackage's curation process so why not
05:22:33 <maerwald> curation?
05:26:31 <_deepfire`> maerwald, phadej, thank you!
05:27:45 <srk> dmj`: well it mostly follows lts-es I think
05:35:51 <dmj`> used to have some yaml file with all the stackage package versions in it that would create hackage-packages.nix, unsure what it does now
05:38:50 <maerwald> they offloaded proper release management to the stackage ecosystem, which does arbitrary version bumps ;)
05:49:01 <aveltras> has anyone encountered problems with dante on emacs recently ? i've just updated my emacs package and it doesn't seem to infer package name correctly now in a multi package project
05:58:02 * hackage haskell-names 0.9.8 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.9.8 (AlexandrRuchkin)
07:08:01 * hackage imm 1.8.0.0 - Execute arbitrary callbacks for each element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.8.0.0 (koral)
07:25:02 * hackage json-autotype 3.0.4 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-3.0.4 (MichalGajda)
07:26:01 * hackage run-haskell-module 0.0.1 - Running newly generated Haskell source module.  https://hackage.haskell.org/package/run-haskell-module-0.0.1 (MichalGajda)
07:35:24 <maerwald> is it possible to link only *some* libraries statically into a haskell executable?
07:36:00 <merijn> Sure, if you're willing to do the linking yourself. I don't think cabal or stack really support that
07:37:02 * hackage hsdev 0.3.3.8 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.3.3.8 (AlexandrRuchkin)
07:38:06 <geekosaur> Cabal (library) doesn't support it, so neither cabal-install nor stack can. nor ghc
07:38:08 <maerwald> I'm wondering how bad compatibility is between macos releases when I dynamically link against openssl, xz, zlib, bzip2
07:38:45 <geekosaur> the C libs are better at maintaining binary compatibiity, in general
07:39:53 <samlamamma> I remember a language which was a ML-like language with a built-in add-only database of all functions, constants, etc. where everything was accessed by its hash. Does anyone know what I'm talking about? I'm trying to find it through google but "functional programming language hash" obviously doesn't get any good results.
07:40:46 <geekosaur> (annoyingly, ghc explicitly puts dynamic or static libs in the link command and doesn't have a way to switch between them, it's all oe way or the other)
07:41:08 <sm[m]> samlamamma: Unison ?
07:41:51 <geekosaur> for haskell packages, that is; it trusts ld to do the right thing for non-Haskell libs
07:42:05 <samlamamma> sm[m]:Heck yes! Thank you :).
07:42:16 <maerwald> geekosaur: yeah, it basically render static linking useless for non-linux
07:42:25 <maerwald> Too hard on FreeBSD, even harder on mac
07:42:56 <maerwald> on FreeBSD, interestingly, the linker fails to find the *haskell* libs
07:43:03 <maerwald> when you want static builds
07:46:30 <sm[m]> maerwald I wonder if you know the full difficulty of cross macos compatibility, eg that each recent release rewuires more elaborate code signing to run things, Catalina runs only 64 bit binaries, etc ?
07:50:36 <maerwald> well, how does stack do it?
07:50:41 <maerwald> Or does it only run on the latest release
07:51:17 <sm[m]> Maybe the code signing is less of an issue for command line tools ? The ghc devs would know, I think they haven’t figured it out yet
07:51:45 <sm[m]> good question
07:52:54 <geekosaur> it's up to ghc via the Cabal library, not stack or cabal-install
07:53:23 <geekosaur> signing isn't dealt with by ghc at all, asi de from making an installable ghc bindist
07:56:33 <maerwald> and we only have one ghc bindist for mac, so I suspect it runs on different releases
07:57:39 <sm[m]> Last I heard it didn’t “just work” on Catalina yet. I guess that was the 8.10rc I’m thinking of. Maybe it’s not serious.
07:58:44 <sm[m]> maerwald: guess we need some older macOS’s for testing
08:03:29 <maerwald> sm[m]: yeah, I was trying https://github.com/kholia/OSX-KVM but I don't have the bandwidth currently to install :P
08:03:46 <maerwald> It seems legal, even... although no one is 100% sure lol (not court-tested I guess)
08:23:02 * hackage hedis 0.12.12 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.12 (k_bx)
08:25:23 <sm[m]> https://www.macstadium.com/ is what GitHub ci uses
08:26:09 <maerwald> looks like enterprise... 
08:27:34 <sm[m]> $79/mo :/
08:27:41 <sm[m]> https://www.macstadium.com/configure?p=minii58250&c=VGS2
08:29:31 <maerwald> another 34 for hosting
08:31:19 <phadej> supporint macOS is not cheap :)
08:31:32 * hackage esqueleto 3.3.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.2 (parsonsmatt)
08:34:05 <sm[m]> $350/mo for the fast one. A pity, that would come in handy :)
08:34:53 <maerwald> Yeah and then I need the last ~4 releases to do useful testing
08:37:25 <sm[m]> (And that machine cost $2500 to own. But I digress)
08:38:26 <maerwald> remember the times where the machine was part of the monitor? lol
09:03:21 <zincy_> Should we be using Natural instead of Int whenever it doesnt make sense to have a value below zero?
09:03:41 <merijn> zincy_: Maybe, it often becomes rather annoying, though
09:03:55 <merijn> You end up having to do fromIntegral in tons of places
09:04:23 <zincy_> ah ok I thought there must be a downside
09:04:26 <merijn> zincy_: Plus, underflowing in arithmetic will now get weird super huge values that are hard to check/guard against
09:04:32 * hackage sak 0.1.0.2 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.0.2 (vmchale)
09:04:58 <ChaiTRex> zincy_: There's Word for Int and Natural for Integer.
09:05:49 <zincy_> ChaiTRex: Not sure I understand
09:06:07 <zincy_> Sorry don't even know the diff between Int and Integer
09:06:10 <jmcarthur> Doesn't Natural just give an error when you decrease below 0?
09:06:15 <Uniaika> bounded and unbounded integers, zincy_ 
09:06:36 <monochrom> > 0 - 1 :: Natural
09:06:38 <lambdabot>  *Exception: Natural: (-)
09:06:40 <jmcarthur> Word is the one to look out for
09:06:45 <monochrom> Yeah, like that.
09:06:48 <Uniaika> > maxBoud :: Int
09:06:50 <lambdabot>  error:
09:06:50 <lambdabot>      • Variable not in scope: maxBoud :: Int
09:06:50 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
09:06:54 <Uniaika> damnit
09:06:55 <jmcarthur> > 0 - 1 :: Word
09:06:57 <lambdabot>  18446744073709551615
09:06:57 <Uniaika> > maxBound :: Int
09:06:59 <lambdabot>  9223372036854775807
09:08:10 <Uniaika> > maxBoud :: Integer
09:08:13 <lambdabot>  error:
09:08:13 <lambdabot>      • Variable not in scope: maxBoud :: Integer
09:08:13 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
09:08:13 <Uniaika> > maxBound :: Integer
09:08:16 <lambdabot>  error:
09:08:16 <lambdabot>      • No instance for (Bounded Integer)
09:08:16 <lambdabot>          arising from a use of ‘maxBound’
09:08:19 <Uniaika> better.
09:08:48 <merijn> zincy_: Int is finite size machine integer
09:08:51 <maerwald> monochrom: that's even more dangerous than a negative value :>
09:09:00 <jmcarthur> Technically there is a maximum value of Integer, but you wouldn't want to reify it
09:09:11 <merijn> zincy_: Integer is an arbitrary precision integer (i.e. libgmp often called BigInt in other languages)
09:09:38 <monochrom> would have been funny if 0-1 :: Natural = 17976931348623159077293051907890247336179769789423065727343008115773267580550096313270847732240753602112011387987139335765878976881441662249284743063947412437776789342486548527630221960124609411945308295208500576883815068234246288147391311054082723716335051068458629823994724593847971630483535632962422413721
09:09:59 * monochrom is getting dangerous!
09:10:21 <zincy_> merijn: ah cheers
09:10:23 <merijn> zincy_: Small Integer values are basically still 64bit ints, but you can go arbitrary big with them
09:10:54 <merijn> > 10^1024 :: Int
09:10:56 <lambdabot>  0
09:10:59 <merijn> > 10^1024 :: Integer
09:11:01 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
09:11:28 <ziman> > 10^64 :: Int
09:11:31 <lambdabot>  0
09:11:49 <maerwald> this is all scary stuff, can y'all stop plz :(
09:12:16 <merijn> GHC is surprisingly efficient at using libgmp for bigint calculations. I recall this shootout comparing bigint stuff across many languages and there was a massive variety even among all the languages using libgmp with GHC performing ridiculously well
09:12:20 <monochrom> 1. Prove 10^64 :: Word64 = 0.  2. Prove that 64 is the smallest positive exponent for this. :)
09:12:50 <merijn> See: http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
09:12:53 <opqdonut> interesting
09:13:00 <opqdonut> > mod (10^1024 :: Integer) (fromIntegral (maxBound::Int))
09:13:02 <lambdabot>  6948188824352137093
09:13:35 <jmcarthur> > find (\e -> 10^e == (0 :: Word)) [1..]
09:13:39 <lambdabot>  Just 64
09:14:03 <monochrom> opqdonut: Do you really want maxBound::Int? Or (maxBound::Int)+1?
09:14:09 <opqdonut> monochrom: right
09:14:18 <opqdonut> yeah and that's 0
09:14:23 <monochrom> :)
09:14:23 <opqdonut> > mod (10^1024 :: Integer) (fromIntegral (maxBound::Int) + 1)
09:14:26 <lambdabot>  0
09:14:32 <opqdonut> oh right now I see bah
09:15:30 <opqdonut> of course 2^64 divides 10^64
09:15:47 <ChaiTRex> Really, you want 2*(maxBound + 1)
09:16:12 <maerwald> merijn: uh, where's the comparison to C?
09:16:57 <ChaiTRex> > 2^64 == 2*(fromIntegral (maxBound :: Int) + 1)
09:16:59 <lambdabot>  True
09:17:03 <merijn> maerwald: ah, yeah, would've been interesting to compare overhead of handwritten C calls to libgmp vs GHC
09:17:56 <opqdonut> ChaiTRex: you're right
09:19:15 <maerwald> the whole scale is messed up just because of PHP lol
09:19:40 <maerwald> Feel like that was the whole point of the blog post xD
09:20:02 <monochrom> Aww 2^64-1 and 2^63-1 are not primes.
09:21:38 <monochrom> But 2^7-1 and 2^31-1 are!  This is why <fakenews>C char is signed 8 bits and C int is signed 32 bits, they're superior to other 2^n-1 choices!</fakenews>
09:22:18 <monochrom> https://en.wikipedia.org/wiki/Mersenne_prime#List_of_known_Mersenne_primes
09:23:28 <monochrom> P.S. There was an electronic component store near my university. It's street address was 255 College Street. Look at the 255. :)
09:23:35 <jmcarthur> 2^64-59 is the largest 64-bit prime
09:23:36 <monochrom> </base-2-numerology>
09:24:52 <monochrom> err, </base-10-numerology> haha
09:31:21 <merijn> monochrom: Man, don't lie on the internet!
09:31:36 <merijn> "C char is signed 8 bits" <- fake news and misinformation
09:31:59 <monochrom> Don't you think "fake news and misinformation" is redundant? :)
09:32:27 <monochrom> Didn't I already mark it as fakenews?
09:32:28 <merijn> monochrom: FYI, the signedness of char (unlike all other integral types) is implementation defined :p
09:32:40 <monochrom> Don't you think I already know?
09:33:04 <merijn> monochrom: I assume no one knows, because it's clearly insane ;)
09:33:47 <merijn> Like, no sensible person would ever come up with that!
09:34:38 <monochrom> I got my K&R 2ed autographed by Kernighan. He came across as a pretty sensible person.
09:35:21 <merijn> monochrom: K&R C is nothing like the ISO C insanity though :p
09:35:25 <monochrom> Therefore Sherlock Holmes would go "the remaining possibility, no matter how improbable, must be the case, Dennis was the insensible guy!"
09:35:28 <merijn> I'm not sure it's *better*
09:35:41 <monochrom> But K&R 2ed is ANSI C.
09:36:38 <merijn> I think ISO C only came into being during C89? And it's just this slow Lovecraftian grind of slowly losing every last vestige of sanity :p
09:37:31 <merijn> Kinda fascinating to watch, in that sense...
09:37:48 <Uniaika> C11 forevah
09:38:00 <monochrom> https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628/
09:38:13 <monochrom> I'm referring to this book not any language.
09:38:24 <merijn> I know, I've got a copy :p
09:40:11 <monochrom> Actually Holmes was thoroughly formal British so s/Dennis/Ritchie/
09:41:46 <Uniaika> Ritchie M. Ritchie?
09:42:16 <maerwald> ANSI C is for real men!
09:42:51 <evelyn> if you can't compile the examples in the K&R book without a warning from the compiler you're using a mere imitation of proper C!
09:42:56 <juri_> toxic masculinity: ruining software development since Babbage.
09:57:48 <dmwit> monochrom: 2^(2*x)-1 cannot be prime because it equals (2^x-1)*(2^x+1)
09:58:24 <dmwit> I wouldn't be surprised if any composite exponent has a similar argument, though I don't know it off the top of my head.
09:59:07 <dmwit> (...and 63 is composite)
09:59:28 <monochrom> You took a look at the Mersenne prime wikipedia page I linked? :)
09:59:50 <dmwit> err, no, but I did remember that Mersenne primes have prime exponents and started thinking about why that might be.
10:00:39 <dmwit> Oh. The argument is in the like third sentence. Well =)
10:01:32 <d34df00d> So I mentioned yesterday the problem of finding the n-th number from the ordered set { 2^i 3^j 5^k | i, j, k ∊ N }.
10:01:53 <d34df00d> It occurred to me overnight that I can do better than I did yesterday by avoiding Integer's as much as I could, resulting in: https://bpaste.net/ZF7Q
10:02:23 <d34df00d> This finds 10'000'000th number in about 1.5 seconds — about 1.1 seconds MUT time and 0.4 seconds GC time.
10:03:37 <d34df00d> Then I figured that my Power is actually a three-dimensional vector, so I decided to use the linear package instead, along the lines of https://bpaste.net/G7LA
10:03:39 <dmwit> d34df00d: You might also like https://stackoverflow.com/q/12480291/791604
10:03:59 <d34df00d> This one works in about 2.4 seconds though: 1.3 MUT and 1.1 GC time.
10:04:02 <d34df00d> Why is it slower?
10:06:27 <d34df00d> dmwit: cool! And they could have decomposed the Integers into triples of Ints as well, avoiding long arithmetic.
10:08:16 <dmwit> Hm. Well, it seems like a correctness/speed tradeoff. It's not obvious to me that what you've done doesn't start to hit rounding or overflow errors at some point.
10:08:47 <d34df00d> dmwit: it will, indeed, but at this point I'm curious how to make sure all this linear/lenses code desugars to the same code as the manually written one.
10:09:16 <maerwald> d34df00d: how do you build the file?
10:09:45 <d34df00d> Also, the 10'000'000th number is Power {pvec = V3 80 92 162} (note the exponents are relatively tiny for doubles), so I doubt it'll overflow "any time soon".
10:10:15 <d34df00d> maerwald: ghc -O. That's actually a stack package from a default template with no adjustments to ghc-options.
10:10:37 <d34df00d> I tried -O2, -fllvm, and both of them simultaneously, but they either pessimize or have no effect.
10:10:57 <dmwit> > round (2.0^80*3^92*5^162) == (2^80*3^92*5^162 :: Integer)
10:11:00 <lambdabot>  False
10:11:10 <dmwit> ??
10:11:16 <dmwit> It lost precision already.
10:11:17 <d34df00d> Well, when I said "no adjustments" I meant "besides removing -rtsopts=-N`
10:11:41 <d34df00d> dmwit: but I don't need to do the exponentiation anywhere (except when showing the result).
10:11:49 <dmwit> You need to do it, roughly, in your comparison.
10:11:59 <d34df00d> But I do logarithms there!
10:12:08 <dmwit> Logarithms don't magically invent precision out of thin air.
10:12:08 <d34df00d> So I take the log of that and compare to the log of the other number.
10:12:36 <d34df00d> Yes, eventually (for i, j or k large enough) the precision will also be lost.
10:12:55 <d34df00d> But it would be when i, j or k is large enough, not when 2^i, 3^j or 5^k large enough.
10:12:57 <dmwit> i, j, k don't even have to be very large, is what I'm saying. You're *already* hitting it.
10:13:20 <dmwit> I don't think you've internalized (or perhaps agreed with) my claim that logarithms don't invent precision out of thin air yet.
10:13:58 <d34df00d> If you only care about relative ordering, why do you care if you work with a logarithm of a value or the value itself?
10:14:18 <dmwit> You don't. But you *do* care if the logarithm has enough precision for the bottom-most bits you're storing to actually tell you whether the thing is bigger or not.
10:14:40 <d34df00d> I agree with that.
10:14:48 <dmwit> And you *also* care if rounding and order of operations has accidentally put one of the logarithm-based calculations over the "half-and-so-round-up" point but not the other.
10:14:52 <d34df00d> But I don't agree with this already being a factor in this case.
10:15:35 <d34df00d> I'm not sure how to prove that, though, or, better yet, at least estimate the order of magnitude where these effects start to kick in.
10:16:45 <dmwit> You could make a non-rounding implementation and check for equality... =)
10:16:52 <d34df00d> Ah, I did that!
10:17:00 <d34df00d> The result is indeed the same in this case.
10:17:47 <dmwit> Out of curiosity, how long did you let it run before giving up on finding a counterexample (and how deep into the sequence had it made it by then)?
10:19:45 <maerwald> d34df00d: what's the input you tested it with?
10:19:46 <d34df00d> Ah lol, that I didn't. I only checked if the results are the same for 10^7.
10:19:50 <d34df00d> maerwald: 10^7.
10:19:54 <d34df00d> 10000000 that si.
10:19:56 <d34df00d> is
10:20:39 <maerwald> 1.6s here
10:20:43 <dmwit> Well, I mean, you have a list. You could just zip it with the correct list and iterate over it for a while...
10:21:12 <d34df00d> maerwald: sure, I have a somewhat old hardware now. But is the linear/lens version different from the explicit version?
10:21:20 <maerwald> I'll try that
10:22:38 <maerwald> Yeap, the one without linear is 1.0s
10:22:48 <maerwald> I also built all dependencies with -O2
10:22:55 <maerwald> And enabled Strict
10:23:22 <d34df00d> Yeah, the difference is quite similar to what I'm observing.
10:23:26 <d34df00d> Now I'm curious how to avoid that.
10:23:53 <d34df00d> Also the INLINE pragma looks to be necessary in my case.
10:24:08 <d34df00d> I sort of assumed that local let/where-bindings are more eagerly inlined.
10:26:17 <monochrom> log is a group isomorphism (from (*) to (+)). Therefore, log requires the same precision as before log.
10:27:00 <monochrom> In fact, if you go from (Int64, (*)) to (Double, (+)), you're losing precision.
10:30:07 <monochrom> Err actually I was dumb. group isomorphism doesn't help.  The shape of the curve is more important.
10:30:28 <d34df00d> Note that we don't care about the whole set of (Double, (*)) as a whole.
10:30:40 <d34df00d> We only care about the subset that's formed by 2^i * 3^j * 5^k.
10:31:06 <d34df00d> And, moreover, the log-based "representation" allows representing numbers that are strictly outside of Double's representation.
10:32:14 <monochrom> The shape of the log curve works against you.  It becomes flatter for larger input.  You need more output bits to discern different inputs.
10:32:44 <d34df00d> But will I be able to even represent those inputs with the unlogged doubles?
10:42:31 * hackage hsexif 0.6.1.7 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.1.7 (EmmanuelTouzery)
10:43:10 <d34df00d> dmwit: ok, got this till the 10^9th number. The precisely and imprecisely calculated lists match up till that point.
10:44:18 <d34df00d> Oh, hold on, that was 10^8. 10^9 will probably be computed for an hour or two, judging by how the run time grows.
10:47:11 <kwaq> Is there a way to use a where definition in patten matching ? i tried it and it didn't work. Also tried it with case definition but also didn't work.
10:47:29 <kwaq> https://pastecode.xyz/view/be981424#LuSk4TkRUaE0CmFJaLsrPYnOluwudE6z
10:50:38 <slack1256> kwaq: Which expression do you want to share?
10:50:51 <kwaq> left and right definition
10:51:23 <kwaq> its only in the column before the where but i want it to be global for all pattern cases
10:51:30 <slack1256> kwaq: Maybe a let-in form instead of where.
10:52:42 <monochrom> No, you can keep it as "where", but you need to use indentation to indicate its more encompassing scope, i.e., outer indent, not inner indent.
10:53:23 <monochrom> Currently your "where" is eaten by -> rather than by trav
10:53:34 <kwaq> yeah you are right
10:53:36 <kwaq> thanks
10:53:43 <kwaq> to both of you
10:53:47 <kwaq> both worked
10:54:53 <d34df00d> dmwit: actually I got that faster than an hour. All numbers up to the billonth are the same.
10:56:47 <ysangkok> hmm it seems like flags of new-test are not making my #ifdef's work. what could be the issue?
10:58:40 <geekosaur> it's not going to rebuild the library for testing vs. normal, else you're not testing the same thing
11:00:46 <monochrom> :)
11:01:02 * hackage ghc-check 0.1.0.3 - Detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.1.0.3 (PepeIborra)
11:01:14 <monochrom> Sounds like several years ago what graphics card device driver writers did.
11:02:49 <monochrom> You probably know that Microsoft DDK comes with formal verification tools (triumph of formal methods research!) for some very basic bugs such as if you release a lock you should have acquired it beforehand etc, very sane and agreeable minimum requirements.
11:03:52 <monochrom> So somehow the graphics device driver writers thought that instead of making their algorithms both correct and fast, they preferred to write two version, a correct version and a fast version.
11:06:31 <monochrom> And don't forget the Volkswagon ordeal in which their car control firmware had two versions, an environmentally safe version and a performant version.
11:07:32 * hackage synthesizer-llvm 0.9 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.9 (HenningThielemann)
11:08:22 <dmwit> d34df00d: Nice!
11:10:59 <d34df00d> dmwit: also, as a side note, note that we don't compare the (logarithms of the) numbers themselves, but only the result of dividing the numbers by their GCD (which is subtracting the minimum of the corresponding exponents from the corresponding exponents).
11:11:18 <d34df00d> That quite likely extends the range, but it also quite complicates the analysis when the precision will break further.
11:14:17 <monochrom> If you compare diff from GCD, you little very little precision, because like 2^4 is clearly bigger than 3^2 for example.
11:18:37 <d34df00d> monochrom: that's an ambiguous parse for me, what did you mean by the first "little"?
11:18:47 <monochrom> need 
11:19:37 <d34df00d> Ah cool.
11:20:43 <d34df00d> Yeah, that's the point of dividing by the GCD (especially given that you provably only need to keep and compare against the numbers of up to about n/5, where n is the next number being generated).
11:22:12 <monochrom> Suppose I'm comparing 2^30 against 3^20 and it is not clear to me yet which one wins.
11:22:40 <monochrom> I'm thinking maybe 3^20 = 2^20 (3/2)^20
11:23:04 <monochrom> So now I'm comparing 2^10 against (3/2)^20
11:23:18 <d34df00d> But in practice, for this task, you'll probably never compare those.
11:23:39 <monochrom> Yeah, that too.
11:24:41 <d34df00d> Meh, my IEEE754-reasoning-fu just sucks.
11:24:57 <d34df00d> If it were an interview question for me, I'd probably fail lol.
11:25:42 <maerwald> the company is probably not worth it ;P
11:26:58 <monochrom> I'm going to do 2^10 = (3/2)^10 (4/3)^10, so I'm comparing (4/3)^10 vs (3/2)^10 now.
11:27:31 <monochrom> This sounds sinisterly like Euclidean algorithm.
11:31:37 <monochrom> For example I am doing mutual subtractions between the two exponents!
11:33:37 <monochrom> This is exciting!
11:42:18 <Zemyla> I had a dumb thought on how to do a Vector.Unboxed of GMP Integers.
11:43:08 <Zemyla> If the Vector is of base length n, you have a ByteArray# of n Ints and an ArrayArray also of length n.
11:44:13 <Zemyla> If you put in a small Integer, one that fits in an Int, you write the value to the ByteArray and fill the ArrayArray slot with a 0-length ByteArray.
11:44:41 <Zemyla> Otherwise, you put either 0 or -1 in the ByteArray slot and put the BigNat in the ArrayArray.
11:45:15 <monochrom> Haha comparing 4/3 vs 3/2 is the same as comparing 2^3 vs 3^2.
11:45:50 <monochrom> But look how nicely I'm reducing "2^30 vs 3^20" to "2^3 vs 3^2" so there is a GCD going on there!
11:47:08 <monochrom> "exponentiated euclidean algorithm"
11:49:15 <monochrom> Does ArraryArray mean array of pointers?
11:50:03 <ChaiTRex> monochrom: It's an array of pointers to arrays.
11:54:57 <monochrom> I'm on a roll. (row?)  comparing 4/3 vs 3/2 is not the same as comparing 2^3 vs 3^2.  Instead go through: 1+1/3 vs 1+1/2, so 1/3 vs 1/2.
11:56:37 <monochrom> Generally if you're comparing a/b vs c/d, if both are >1, then you do proper fraction, then first maybe the integer parts already settle it, but if not, you're left with two fractions both <1.  In that case...
11:57:50 <monochrom> to compare v/w vs x/y and both are <1, you compare y/x vs w/v, now both are >1, recurse!
11:58:10 <monochrom> And again this is another Euclidean algorithm again!
11:58:59 <monochrom> since proper-fractioning is a divMod, and I also keep swapping arguments.
11:59:19 <monochrom> Gosh this is Euclidean all over the place at multiple levels.
13:01:50 <smunix> is it possible to write the following in Haskell ?
13:02:10 <smunix> class A t where f :: Int 
13:02:32 <merijn> smunix: You wouldn't be able to do anything sensible with it
13:02:40 <smunix> I would like to specify f as I define instances of A
13:02:47 <ziman> you'd usually use a Proxy for that
13:02:57 <smunix> instance A Int where f = 1
13:03:03 <smunix> instance A Bool where f = 2
13:03:21 <smunix> f @Int, f @Bool
13:03:23 <merijn> smunix: This way lies sorrow, sadness and sleepless nights
13:03:47 <smunix> any alternative, merijn ?
13:03:48 <merijn> -XTypeApplications is a terrible extension and it too will come back to bite you in the ass :)
13:03:56 <merijn> smunix: Like ziman said, use Proxy
13:04:02 <ziman> type applications are great :)
13:04:13 <merijn> "class A t where foo :: proxy t -> Int"
13:04:33 <merijn> ziman: Until your code magically breaks in a minor version update of a dependency!
13:04:35 <ziman> but they don't apply in this case because f does not have a type parameter, does it
13:04:58 <merijn> ziman: Mark my words, you *will* regret relying on it sooner or later :)
13:05:39 <merijn> (Maybe I should switch careers to "doom prophet"...)
13:07:13 <smunix> I guess I could then use it with, "foo (Proxy @Int)" or "foo @Int Proxy" ? 
13:07:35 <merijn> smunix: Or just "foo (Proxy :: Proxy Int)"
13:08:24 <merijn> smunix: Also, the reason to use "foo :: proxy t -> Int" instead of "foo :: Proxy t -> Int" is that you can now use types other than proxy too. Suppose you have "Maybe Int" lying around, you can now use that as argument to 'foo'
13:32:04 <monochrom> And even if not, "foo ([] :: [Int])" is a convenience.
13:33:10 <monochrom> To be sure, "foo (Proxy :: Proxy Int)" conveys your intention much better and saves people from needing to read foo's doc to see why "foo []" also makes sense.
13:34:16 <monochrom> But you still want to be less restrictive about which proxy type you accept, because Proxy is not going to be the only choice, even among the good ones.
13:34:44 <ukari> When I try to map from some types to some data constructors in a data, I build two extra helper class and a mapping data to do the convert.However, when I want to support one more type which needs to convert, I must alter three positions in my code. Is there any more clean way to do this? https://plaster.tymoon.eu/view/1715
13:38:58 <frdg> are the curry and uncurry functions used often? It seems to me that using these may be a sign of a poor implementation 
13:39:08 <monochrom> I don't understand "instance ToG a". It looks like you don't need that class at all, just the toG function at top-level as function not method.
13:39:52 <monochrom> And I don't understand "support one more type".  Could you exemplify it by code?  And use comments to draw a line between code before adding one more type and code after.
13:41:16 <ukari> `convert F1` returns `G1`, `convert F2` returns `G2`
13:41:42 <monochrom> frdg: Yeah I think they aren't used often in good code.  Still, there are sensible exceptions.  Also, they are important in theory (cartesian-closed category), and so you will see them in some laws.
13:42:36 <monochrom> Sometimes when you use zip, zipWith, or unzip, you may find curry/uncurry handy.
13:42:37 <ukari> if I want to support `convert F4` which returns `G4`, I need add instance ToMapping G4, add `toG (GF4 _) = G`
13:43:07 <frdg> monochrom: nice to see my intuition is somewhat working!
13:43:35 <ukari> if I want to support `convert F4` which returns `G4`, I need add instance ToMapping G4, add `toG (GF4 _) = G4` in instance ToG, and add `| GF4 !(Wrapper F4)` in `Mapping`
13:45:02 <ukari> yes that class is not necessary
13:46:10 <monochrom> I have two plans, I would choose one depending on how bad this becomes in the future.
13:47:03 <monochrom> But both plans delete your current classes.
13:48:35 <monochrom> Plan A: "class Convert a where convert :: a -> G". For type F1, add "instance Convert F1 where convert _ = G1". Similarly for F2, F3.  When you add one more type, G's definition needs an addition. That's it.
13:49:04 <monochrom> Plan B: "class Convert a where convert :: a -> Int".  Now you don't even need to change G, hell there is no G to maintain.
13:49:27 <ukari> deleted
13:50:46 <monochrom> Now I wonder if I could also have plan C using multiple-parameter type classes, and plan D using type families.
13:51:45 <{abby}> Think not of whether you could but of whether you should
13:54:42 <ukari> plan A works nice
13:54:51 <ukari> how plan C works
13:55:03 <monochrom> Just pick a number?
13:55:12 <monochrom> Oh nevermind, C.
14:05:55 <dsal> This is confusing:   WARNING: Ignoring gopro's bounds on hsexif (>=0.6.1.7); using hsexif-0.6.1.6.  --  Reason: allow-newer enabled.
14:06:13 <dsal> It seems to say it's ignoring my bounds and using an older version because I have allow-newer enabled.
14:11:02 * hackage show-combinators 0.2.0.0 - Combinators to write Show instances  https://hackage.haskell.org/package/show-combinators-0.2.0.0 (lyxia)
14:19:40 <ryantm> I love using ghcid to compile my code quickly. How do I set it up to compile my tests too?
14:19:50 <ryantm> I mean type-check.
14:20:56 <solonarv> you can pass something like '--test=:main' to run ':main' after a successful load
14:21:21 <jakalx> ryantm: might be offtopic, but you may have a look at entr http://eradman.com/entrproject/
14:21:24 <solonarv> ghcid is a wrapper around ghci, so anything that works in ghci works as an argument to --test
14:24:16 <coot> @ryantm you can use `-c` option to laod any component (including tests, benchmarks, executables or libraries), e.g. `ghcid -c "cabal repl my-tests"`
14:24:16 <lambdabot> Unknown command, try @list
14:24:25 <ukari> I get to know how plan D works, thanks you monochrom, it helps a lot
14:30:04 <ryantm> Okay, my test suite was called "spec" so I did `ghcid -c "cabal v2-repl spec"` and it looks like it worked.
14:30:07 <ryantm> Thanks.
14:33:51 <maerwald> Hmm, is there a library that allows fancy block-wise printing of continous output? Let's say you have a process and want all of its output to be printed in a section of 5 terminal lines
14:36:52 <mlugg> Hi, I'm reading about some stuff in GHC.Prim and I'm having trouble understanding State#. Why is it parameterized? I believe it has something to do with ST, but I don't really get it
14:39:43 <phadej> ST s ~= State# s, IO ~ State# RealWorld
14:42:36 <sm[m]> maerwald: maybe https://hackage.haskell.org/package/concurrent-output ?
14:42:45 <mlugg> Yeah, I get that, but I don't really get *why* that's the case - do State# and RealWorld represent concrete things, or is it just "type magic that happens to make those monads work how we want"?
14:43:42 <maerwald> sm[m]: omg, how did you find that
14:44:01 <maerwald> I was almost about to implement something like that, which isn't all that trivial :P
14:44:21 <sm[m]> had it waiting in the memory banks
14:46:04 <monochrom> Nice
14:46:07 <[exa]> sm[m]: oh my
14:48:33 <sm[m]> I haven't experienced this yet, but I'd like to
14:49:52 <sm[m]> using it: https://packdeps.haskellers.com/reverse/concurrent-output
14:50:23 <[exa]> mlugg: AFAIK RealWorld is a very concrete nothing (it's just a token). State# is very roughly like State, but unlifted
14:51:57 <mlugg> But `State` is a monad describing a stateful computation, with a state `s` and result `a`, which makes sense; `State#` however only takes one type param, and it's used in the context of a state-ey function in the IO and ST definitions
14:53:03 <koz_> mlugg: Yeah, because the idea is that the 'state' in this case is merely a token to ensure that we don't leak mutability outside of its scope.
14:53:12 <koz_> You're not meant to _handle_ the 'state' in such a case.
14:54:16 <{abby}> The 'a' is only used to keep different State# threads separate
14:54:32 <[exa]> mlugg: yeah, in IO the 'state' is held only as a tool so that the next computation doesn't start until the previous produces its output state
14:54:41 <koz_> How do you write a deriving strategy in a standalone deriving clause?
14:54:53 <koz_> 'deriving instance stock Foo (Bar Baz)'?
14:55:19 <[exa]> mlugg: saving the actual real world would be inefficient so they just went with Void, which is also universal but takes exactly 0 bytes.
14:55:33 <{abby}> deriving stock instance Foo (Bar Baz)
14:55:40 <koz_> Ah, OK, thanks!
14:55:48 <koz_> (even reads kind of like English)
14:57:17 <mlugg> I think I'm just having trouble understanding the relationship between IO and ST tbh. I know that `IO ~ ST RealWorld`, but I don't get *why*, given that in every other case we see a polymorphic `ST a`
14:58:15 <koz_> mlugg: Basically, IO is a special case of ST.
14:58:22 <koz_> In fact, it's very specifically 'ST RealWorld'.
14:58:41 <koz_> Have you read the 'Functional Lazy State Threads' paper?
14:58:48 <koz_> It might shed some light on things, and is _very_ readavble.
14:58:57 <mlugg> I have not, I'll take a look
14:59:00 <mlugg> Thanks!
14:59:35 <koz_> Probably my fave retro SPJ hit.
14:59:40 <koz_> (not my fave SPJ paper)
14:59:46 <koz_> (but my fave retro SPJ paper)
15:00:35 <mlugg> I haven't really read any FP papers before, although I've watched a few talks on YouTube from SPJ, and I really like the guy :p
15:01:03 <koz_> His writing is amazingly well-motivated and readable.
15:01:15 <koz_> (you have all the detail if you need it, but it's not rubbed in your face or led with)
15:02:02 <mlugg> If you have any other recommendations for general interesting papers, feel free to send them my way xD
15:02:25 <koz_> mlugg: 'Codata in Action' is gold.
15:02:32 * hackage leancheck 0.9.2 - Enumerative property-based testing  https://hackage.haskell.org/package/leancheck-0.9.2 (rudymatela)
15:03:45 <koz_> What's your folks recommendations for an open union package?
15:11:01 <maerwald> koz_: plucky
15:11:32 <maerwald> Maybe not that general
15:11:50 <koz_> maerwald: Not my specific problem space, but _awesome_ recommendation!
15:12:02 <maerwald> https://github.com/i-am-tom/oops another
15:12:14 <maerwald> And then https://hackage.haskell.org/package/haskus-utils-variant is probably more general
15:12:30 <koz_> 'EGADT' is best name.
15:12:38 <koz_> 'EGADTs, what have I done?'
15:12:56 <maerwald> But you know that it's all ugly and has all sorts of problems right?
15:13:14 <koz_> Also wow, haskus-utils-variants has wired-in recursion schemes?
15:13:15 <koz_> Woah.
15:13:33 <maerwald> I've used the Excepts module heavily
15:14:05 <maerwald> Type inference is out the window and it's impossible to know whether you have extraneous constraints
15:14:29 <koz_> I'll give it a whirl and see if it's less painful than my current situation. But yes, aware, and noted.
15:14:55 <maerwald> If you convert constraints via type families to something else, then it appears GHC cannot tell you anymore if you have unnecessary constraints
15:14:55 <solonarv> phadej: mlugg: State# is actually just a token/proxy type
15:15:08 <maerwald> (the GHC warning, that is, not compile error)
15:15:18 <solonarv> the underlying representation of 'ST s a' is 'State# s -> (# State# s, a #)'
15:15:47 <phadej> I used ~= to indicate "relates to"
15:15:53 <phadej> the ~ is typo
15:16:03 <phadej> anyway. I should just pasted the paper reference too
15:16:33 <phadej> sm[m]: concurrent-output works
15:16:37 <phadej> e.g. stack use sit
15:16:46 <phadej> or used to use
15:16:49 <maerwald> Yeah, but it uses process package :/
15:17:14 <maerwald> Very tightly integrated with that it seems
15:17:43 <maerwald> Can't figure out how to do forkProcess and capture the stdout in a region of that forked process
15:17:51 <phadej> hmm. stack doesn't. I remembered wrong.
15:18:06 <maerwald> Might be easier to do it manually after all
15:18:19 <phadej> I actually don't use concurrent-output for process spawning
15:18:29 <phadej> just to handle concurrent output from different application threads
15:19:10 <phadej> the process spawning and output processing feels to be very application depending, in how precisely you want to do that
15:19:15 <maerwald> Well, I have only one process that does stdout, so maybe I don't even need it. I'm more interested in the region abstraction
15:19:49 <phadej> that works nicely
15:20:02 <phadej> at least after you find your way around
15:20:25 <maerwald> Yeah, API isn't particularly intuitive :P
15:21:35 <phadej> I have withConcurrentOutput $ displayConsoleRegions $ do ... at top of my `main`
15:22:47 <phadej> and don't use lockOutput, as `displayConsoleRegions` take the same lock
15:59:53 <mlugg> koz_: that paper's made this make a lot more sense, thanks :)
16:00:10 <koz_> mlugg: Glad to hear!
16:02:32 <EvanR> let's say for the sake of argument there is a bank account with N dollars in it. Now three events happen simultaneously which each attempt to buy something using the account. But the sum of three purchased exceeds N. If negative balance is not allowed, is the only possible way to resolve it by choosing an ordering for the events after all?
16:07:32 * hackage cabal-file-th 0.2.7 - Template Haskell expressions for reading fields from a project's cabal file.  https://hackage.haskell.org/package/cabal-file-th-0.2.7 (NickPartridge)
16:10:09 <EvanR> seems like a relevant concern for FRP
16:11:15 <ClaudiusMaximus> i think in networks, simultaneity is avoided by failing every event and using randomized times for retrying?
16:11:17 <jackdk> indeed. AIUI you'll be forced to use a combinator like `leftmost` to enforce priority, or you will have to deal with the nonempty list of simultaneous firings some other way.
16:14:34 <ziman> yeah, you could fail all three
16:14:40 <maerwald> hmm, unix does not have getLine?
16:25:33 <EvanR> fail all three... maybe that explains randomly getting "declined" on a card purchase which immediately works on a 2nd try
16:26:09 <EvanR> hidden intermediate tubes got conflicted
16:41:04 <EvanR> thanks three ways to resolve the conflict I have so far are: use priorities, higher priority events "happen first". Consistent snapshot, all three events see the original balance which is enough (end result negative balance). And handle potentially conflicting events as one, check all purchases to make sure there's enough to do all of them
16:45:32 * hackage ghc-lib-parser-ex 8.8.6.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.6.0 (shayne_fletcher)
17:07:27 <frdg> where can I find the source code for the " . " operator?
17:09:54 <pavonia> @src (.)
17:09:54 <lambdabot> (f . g) x = f (g x)
17:13:47 <frdg> Interesting, I was not expecting it to be that simple 
17:14:25 <frdg> makes sense though
17:34:02 * hackage matrix-sized 0.0.3 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.0.3 (kaizhang)
17:42:30 <maerwald> hmm, the carriage return trick doesn't work well with fdWrite
17:51:02 * hackage json-api-lib 0.1.3.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.1.3.0 (shirren)
17:51:33 <maerwald> Seems there is no way to flush either
17:53:49 <gaze__> I'm getting a symbol not found error with ghci, in particular "ByteCodeLink: can't find label", but the binary runs fine with stack exec 
17:53:52 <gaze__> what could be happening
18:17:13 <koz_> DO I understand correctly that this function, given [(i1, x), (i2, y), (i3, z)], picks x with probability i1 / (i1 + i2 + i3)? http://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:frequency
18:17:58 <Cale> yes
18:39:53 <koz_> Cale: THanks!
18:42:52 <exit70> for people already good at cs, which book is better? graham hutton or richard bird?
18:43:17 <exit70> i'm reading graham hutton myself 
18:44:58 <jackdk> I was going to say, CUP intend to offer the Hutton book for free for a while, but not right now: https://www.cambridge.org/core/books/programming-in-haskell/8FED82E807EF12D390DE0D16FDE217E4
18:46:14 <Cale> Graham Hutton's book is a good basic introduction to Haskell. Richard Bird wrote a bunch of books, the ones I'm familiar with are a bit more advanced.
18:46:43 <Cale> I think there was a more recent basic intro one that he wrote as well, but I'm not so familiar with it.
18:53:39 <exit70> yeah, i was wondering about the recent book (have not read other books but Bird's name feels familiar)
19:41:12 <monochrom> If you're good at CS and wondering which one is better, Bird's "thinking functionally with haskell" vs Huttons "programming in haskell"... I think they are on par, you won't go wrong with a coin toss if you can only afford one and must choose.
19:42:56 <monochrom> I think this is because they are both recent books and both have borrowed the same ideas from an older generation of books.  Probably also in-person crosstalks.
19:43:55 <monochrom> For example, if you want to see a discussion on lazy evaluate and when to use seq; if you want to see induction proofs, even deriving programs from specs; if you want to see monadic parsing; ... they're in both books.
19:45:21 <monochrom> Hell, if you want to see the dreaded "IO a = World -> (World, a)" model, it's in both books too, death to the lot of them!
19:45:28 <koz_> LOL
19:46:16 <monochrom> But here is a symmetric difference I spot.  Bird has ST and mutable arrays (and immutable arrays).  Hutton has Monoid, Foldable, Traversable.
19:48:24 <monochrom> So I what mean is this.  Among the older generation of books, if you're good in CS, then only Bird's book "FP using haskell 2ed" has lazy evaluation, seq, and induction, so I would suggest it, these are topics that require you to be good at CS to begin with.  But now both authors do them, it is no longer a deciding factor.
19:49:19 <monochrom> If you have the money I recommend buying both.  Or use a library.  Or wait for the library to offer free e-book access online on just cause of the virus that must not be named.
19:52:20 <koz_> Lord Virus.
19:52:50 <monochrom> Although, I'm a bit surprised and disappointed that Bird omits monad transformers in the new book; he had it in the old one.
19:59:02 <fishooter> Hi, let's say I have a list of functions that I'd like to apply a single argument to, like following
19:59:05 <fishooter> [toUpper, toLower] ?? 'a' -> ['A', 'a']
20:00:28 <Axman6> :t \fs x -> fmap ($ x) fs
20:00:31 <lambdabot> Functor f => f (a -> b) -> a -> f b
20:00:42 <Axman6> :t \fs x -> map ($ x) fs
20:00:45 <lambdabot> [a -> b] -> a -> [b]
20:01:16 <fishooter> oh, awesome :)
20:02:05 <Axman6> :t \fs x -> map (\f -> f x) fs -- if you don't like the slightly magic looking ($ x)
20:02:06 <lambdabot> [t -> b] -> t -> [b]
20:04:34 <exit70> monochrom, thanks a lot for the detailed answer!
20:06:19 <fishooter> I like magic
20:54:40 <exit70> is it possible to get doc of prelude function using ghci? :info shows type and "defined in xxx" only
21:00:43 <Axman6> not in GHCi, but all the documentation is on hackage for the base library
21:05:56 <exit70> is it https://hackage.haskell.org/package/base some module is not linked? e.g. GHC.Base
21:07:45 <Axman6> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html is probably where I'd start
21:10:24 <MarcelineVQ> in new enough ghc with the documenation built properly you can write  :doc to get the haddock documenation
21:11:17 <exit70> aha, should've checked :? first 
21:36:32 * hackage bson 0.4.0.1 - BSON documents are JSON-like objects with a standard binaryencoding.  https://hackage.haskell.org/package/bson-0.4.0.1 (VictorDenisov)
22:14:06 <fog> J.H. Friedman mentions that multivariate addaptive regression splines https://projecteuclid.org/download/pdf_1/euclid.aos/1176347963
22:14:48 <fog> are a compression scheme to interpolate high dimensional data, and can be thought of as similar to (2.1) global parametric modeling
22:15:21 <fog> here, the hidden model of the system, instead of taking linearised form such as in filtering and smoothing approaches
22:15:35 <fog> use arbitrary functions to represent the interactions of the grey box system
22:15:54 <fog> which allows us to use lambda calculus to represent programs that represent the agent-based modeling
22:16:46 <fog> eg, i could compress a price curve, if i had could infer the decision processes that motivated each trade that gave rise to this curve 
22:17:09 <fog> essentially then, the parameters being inferred are variables in an underlying functional program
22:17:43 <fog> this is a "grey box modelling" problem, where information about the functional form of the underlying system is proposed by the designer
22:20:50 <fog> the paper suggests eg, polynomial functional forms (in powers of x, relying on the Num instance of the inputs) 
22:21:21 <fog> however, we are familiar with a much more expressive way of implementing function in Haskell
22:24:36 <fog> by considering Haskell functions as parametric models, and learning over their input parameters (AD - conal elliott for backprop, or stochastic monte carlo / gradient free approaches) then we can derive error minimising approximators using functions as parametric models
22:25:58 <fog> this is different from the linear algebra "state space" representation typically using covariance tracking for hidden markov - sytem inference
22:26:52 <fog> (there is always the tensor network feynman approach to path integrals as an alternative to the time evolution opperator, but derving propegators in a functional programming realm seems bizzare)
22:28:06 <fog> essentially what we are confronted with is a turbocoding problem, where we can model uncertainty by introducing a noisy channel 
22:29:55 <fog> similar to an autoencoder, the reduced order representation giving rise to system dynamics observed from the hidden state, and the identification of this, is essentially manifold learning, where we are "unfolding" the manifold according to the interactions of the hidden function implementation
22:31:40 <fog> the sparse covering by low complexity approximators or "codewords" (akin to dictionary elements) can then be seen as the encoder/decoder pair being the inference of variables, and the running of the hidden program given these arguments to recover the data manifold
22:32:47 <fog> from the perspective of dictionary learning, we seek to generate a frame which can be used to generate a sparse approximation, using only few of the most significant partially-correlated dictionary elements 
22:33:10 <fog> this is linear again, as it sums these contributions 
22:33:39 <fog> finally what we seek is to again use arbitrary functionality of haskell programs to replace this linear opperation
22:34:17 <fog> where instead of summing dictionary elements, these are input to an arbitrary function. 
22:34:47 <fog> doing this would solve the long standing difficulty of the restriction of spectral methods to linear algebra settings
22:36:17 <fog> so instead of using several versions of the hidden system to evolve different curves which we can sum like if it were a basis (frame)
22:37:01 <fog> where then we see a mixture of experts as an adaptive dictionary weighting scheme 
22:37:26 <fog> with the dictionary learning problem being the inference of the parameters of the expert systems
22:38:57 <fog> we can combine the constituent models again using the full expressiveness of lambda calculus, and the final model is just a function, or parametric model, where the inputs that are argmin'd over are selections of components (expert systems)
22:39:33 <fog> as this itself can be viewed as a form of expert system, we can proceed recursively, giving a hierarchical functional mixture of experts system
22:41:10 <fog> using lambda calculus based functional programs to extend from linear mixture models to make compound systems using eg. passing functions as arguments, to build up nested implementations as higher order functional programs
22:42:43 <fog> then, the system identification procedure is a mining of functional programs, in a genetic programming setting, eg being able to pass functions into the network which orchestrate the handling of subsequent arguments, and how these are combined with the other functions to implement the program
22:43:47 <fog> motivating genetic functional programming as the next frontier in hidden model inference 
22:44:29 <fog> lets learn to unfold some manifolds!
22:45:10 * MarcelineVQ gets a bingo
22:55:32 * hackage fcf-containers 0.5.0 - Data structures and algorithms for first-class-families  https://hackage.haskell.org/package/fcf-containers-0.5.0 (gspia)
23:27:54 <Focu5> any news about the expired cert used by stack (casa.fpcomplete.com)?
23:42:33 <Focu5> any news about the expired cert used by stack for "casa.fpcomplete.com"?
23:47:48 <yushyin> Ask fpcomplete?
23:49:59 <Focu5> The fpcomplete contact us form doesnt seem to be for stack bugs/site errors
23:50:11 <Focu5> I did put up a stack issue as it prevent stack from working
23:54:08 <yushyin> Filling an issue was right. You will have to wait for an answer from them.
23:54:38 <yushyin> Meanwhile I can recommend cabal-install
23:55:41 <Focu5> Time for cabal to rise I guess
23:56:55 <yushyin> Ghcup+cabal works ok, I guess
