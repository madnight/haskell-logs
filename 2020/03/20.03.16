00:10:33 <iqubic> Select is great.
00:12:16 <iqubic> I also use this:
00:12:19 <iqubic> > let  select' xs = [(x,is++ts) | (is,x:ts) <- zip (inits xs) (tails xs)] in select' "abcde"
00:12:21 <lambdabot>  [('a',"bcde"),('b',"acde"),('c',"abde"),('d',"abce"),('e',"abcd")]
00:12:43 <iqubic> I have no idea if there's a better way of writing that.
00:17:30 <iqubic> I feel like there should be a way to write this without (++) or (<>).
00:24:10 <Axman6> I wrote a slightly more efficient (I hope) version of select' on https://gist.github.com/axman6/40204856a9c640c675a183fd4f1f4cfd#file-find-the-smallest-hs-L31
00:32:02 * hackage crypto-token 0.0.0.0 - crypto tokens  https://hackage.haskell.org/package/crypto-token-0.0.0.0 (KazuYamamoto)
01:23:46 <bahamas> hello. I'm trying to develop an app with miso and jsaddle and the page is freezing (the one I accessed at localhost:8080). anyone know what's wrong?
01:23:58 <bahamas> I see lines like this in the console: Error : Unexpected Duplicate. syncCallbacks=True nBatch=5 nExpected=7
01:28:49 <siraben> What's the difference between these two monad stacks? http://ix.io/2eno
01:29:20 <siraben> As I understand it, the first represents computations that can have non-local exits but maintains a "global" state, whereas the second one can rewind the state back to the point of the non-local exit.
01:32:44 <koz_> siraben: The best way to think about it is to unravel the stacks.
01:33:02 <koz_> StateT s (Cont r) a is isomorphic to s -> Cont r a.
01:33:44 <siraben>  Is it not (s -> (Cont r a, s))
01:33:49 <koz_> Which itself then unravels to s -> (a -> r) -> r.
01:34:01 <koz_> Whoops, hold on.
01:34:09 <koz_> @unmtl StateT s (Cont r) a
01:34:09 <lambdabot> s -> (a -> s -> r) -> r
01:34:13 <koz_> There we go.
01:34:19 <dmj`> bahamas: hey
01:34:22 <koz_> @unmtl ContT r (State s) a
01:34:22 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
01:34:28 <koz_> There's your difference.
01:34:30 <siraben> Ooh, didn't know lambdabot  did unmtl
01:34:35 <dmj`> bahamas: can you paste your code
01:35:12 <siraben> koz_: How does that affect the semantics of each stack?
01:35:40 <koz_> In the first case, you have a state and a 'state-aware continuation handler', and then you get your result, sans the state.
01:35:57 <koz_> In the second, your handler _also_ gives the next state, and you still get the 'final' state as a result.
01:36:13 <bahamas> dmj`: you mean Main.hs?
01:36:19 <siraben> Ah, that makes sense.
01:36:36 <koz_> It can be easier to visualize if we flip the arguments in the second stack.
01:36:55 <koz_> So it's 's -> (a -> s -> r) -> r' versus 's -> (a -> s -> (r, s)) -> (r, s)'.
01:37:12 <MarcelineVQ> sasrr
01:37:13 <koz_> Note that the difference is actually in what the continuation handler 'gives back'.
01:37:21 <bahamas> dmj`: as far as I can tell, it's identical to Main.hs in sample-app-jsaddle
01:37:58 <dmj`> bahamas: are you using miso's pin of nixpkgs
01:38:14 <siraben> koz_: Ah, so the new state is given by the continuation handler in the second stack.
01:38:24 <koz_> Yup.
01:38:40 <koz_> Now, I'm not terribly experienced with Cont (or ContT), so I'm just reading off the types.
01:38:43 <siraben> If these were effects... they don't commute like this right?
01:38:57 <koz_> StateT and Cont very much do not commute.
01:39:06 <koz_> In fact, pretty much anything and Cont does not commute.
01:39:13 <siraben> Haha, of course.
01:39:13 <koz_> Cont is basically the reason we can't have nice things.
01:39:33 <koz_> (and is also not an algebraic effect I believe)
01:39:41 <koz_> (though I suspect some fans of it may rush to correct me)
01:39:46 <koz_> s/it/them/
01:39:51 <dmj`> bahamas: also, I don't use jsaddle, I just use `ag -l | entr sh -c 'cabal configure --ghcjs && cabal build'`
01:40:02 <dmj`> inside of a `nix-shell`
01:40:14 <dmj`> bahamas: I wrap that in a bash function
01:40:16 <siraben> koz_:  Thanks for that.
01:40:27 <koz_> siraben: No worries - @unmtl is very handy for such cases.
01:40:30 <dmj`> bahamas: and then just call `nix-shell --run runner`
01:40:40 <bahamas> dmj`: this is my default.nix https://bpaste.net/OIGA
01:40:43 <koz_> I always need reminding of how StateT and Except stack.
01:40:49 <siraben> Translating Scheme to Haskell code is sometimes hard because Scheme people love writing things with explicit continuations, meanwhile mixing state, exceptions, etc.
01:40:53 <koz_> (since that's _another_ great non-commutative case)
01:41:07 <dmj`> bahamas: looks fine
01:41:09 <bahamas> dmj`: does that give you live-reload?
01:41:17 <koz_> siraben: Yeah... call/cc is rather overused. It's also unhelpful in that call/cc's continuations are _not_ delimited, while Cont is.
01:41:26 <koz_> I think Oleg did a big teardown of this somewhere.
01:41:38 <koz_> http://okmij.org/ftp/continuations/against-callcc.html
01:41:41 <dmj`> bahamas: yea, I have it copy to a `static` directory after its successful and then web server just delivers anything from static
01:41:45 <siraben> Ah, of course Oleg did. Probably his page on continuations?
01:41:46 <siraben> Yes.
01:41:55 <koz_> Oleg's website is a treasure trove.
01:42:26 <siraben> I'm reading his stuff on tagless final, there's a lot to go through.
01:42:35 <koz_> @unmtl StateT s (Error e) a
01:42:35 <lambdabot> s -> Error e (a, s)
01:42:38 <siraben> Beautiful technique, should be covered in more literature.
01:42:38 <bahamas> dmj`: by live realod I mean updating the page but keeping the state. at least, that's what I assumed jsaddle gives you
01:42:39 <koz_> Argh.
01:42:45 <koz_> @unmtl StateT s (Except e) a
01:42:45 <lambdabot> s -> Except e (a, s)
01:42:58 <bahamas> but if I don't make it work, I'll try this alternative solution
01:42:59 <koz_> Damnit.
01:43:10 <bahamas> dmj`: what is `ag` btw?
01:43:33 <dmj`> bahamas: it won't keep the state on the client, but I've never need it do that 
01:43:37 <dmj`> needed*
01:43:39 <dmj`> bahamas: https://gist.github.com/dmjio/4e5bd4efe8d7731f9a74ba6f6b0664ff
01:43:46 <dmj`> is my typical setup
01:44:24 <dmj`> bahamas: ag is the silver searcher
01:44:25 <dmj`> bahamas: https://geoff.greer.fm/ag/
01:45:00 <bahamas> ah, so I could use ripgrep here
01:48:16 <bahamas> dmj`: can you show me the setup for the server of the static files?
01:48:37 <dmj`> bahamas: there should be 2 scripts in that gist
01:48:46 <dmj`> bahamas: or do you mean the Haskell code?
01:51:26 <dmj`> bahamas: the key is to use two different dist directories (ala --builddir)
01:51:45 <dmj`> otherwise cabal can become confused
01:52:08 <bahamas> dmj`: I meant the part about having the server serving your js files.
01:52:27 <bahamas> or maybe there's a project template with all this somewhere
01:53:32 <dmj`> bahamas: https://github.com/dmjio/miso/blob/master/examples/haskell-miso.org/server/Main.hs#L46
01:53:58 <koz_> What exact transformers is @unmtl aware of?
01:54:03 <dmj`> bahamas: lines 56 and 119 are relevant as well for static files
01:54:25 <dmj`> bahamas: we also have a miso slack with other commercial users if you'd like to join
01:55:04 <bahamas> dmj`: sure. where is it?
01:55:41 <dmj`> bahamas: https://haskell-miso-slack.herokuapp.com/
01:55:54 <bahamas> btw, my use case is slightly different, because I want to build an Electron app, so I don't have a server
01:56:11 <dmj`> bahamas: that sounds great
01:56:26 <dmj`> bahamas: you might find https://github.com/taktoa/ghcjs-electron relevant
01:56:44 <bahamas> ok, thanks
01:58:01 <kolu> hello
01:58:14 <kolu> can anyone assist me with understanding exercism
01:58:40 <dmj`> kolu: sure
02:00:34 <dmj`> kolu: what's the q
02:00:57 <koz_> kolu: First, you need a crucifix, a Bible, and strong whiskey.
02:01:04 <koz_> :P
02:01:12 <materiyolo> hi
02:02:56 <kolu> haha
02:03:08 <kolu> well, it's a concrete question
02:03:18 <kolu> Last night I did the first exercise
02:03:37 <kolu> the hello world
02:03:49 <kolu> which unlocked extra exercises
02:04:01 <kolu> the first one - Acronym
02:04:06 <materiyolo> anyone planning on joining GSoC?
02:04:31 <kolu> I managed to do it but I have no clue how to implement it inside the exercism project
02:17:32 * hackage futhark 0.15.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.1 (TroelsHenriksen)
02:17:58 <[exa]> kolu: can you perhaps describe what's the actual problem you're hitting?
02:18:43 <[exa]> kolu: sounds a bit like the exorcism interface forces some code form other than you'd expect?
02:18:55 <[exa]> s/exorcism/exercism/    oh man
02:20:41 <kolu> yes, it's like simple exercises
02:21:12 <kolu> but you have the whole project file with all it's folders and sub files and code that I don't understand
02:21:30 <kolu> and somewhere in between I have to somehow figure out a way to put my code
02:23:33 <bahamas> kolu: you need to have a directory for all exercism projects. in that, you have a dir for each language: python, haskell, etc. inside that, you have a dir for each exercise. I think the command line tool creates that
02:23:52 <kolu> that's t here, yes
02:23:58 <kolu> but inside every exercise
02:24:11 <kolu> there's other folders and files
02:24:26 <kolu> and some of those files have code that is anything but beginner code
02:25:08 <kolu> there's the main module, which is in test\test.hs
02:25:26 <kolu> and then there's the exercise module, in my case src\Acronym.hs
02:26:51 <kolu> inside there's this function -> abbreviate xs = error "You need to implement this function."
02:28:26 <[exa]> oh nice, just replace the 'error ....' part with your solution?
02:33:44 <siraben> Anyone know when and where registration for GSoC takes place?
02:36:54 <kolu> alas, it's not that simple
02:37:31 <kolu> abbreviate xs seems to be a function that takes one argument with the type abbreviate :: String -> String
02:40:45 <[exa]> kolu: so try just: abbreviate xs = xs
02:40:56 <[exa]> it's not the correct solution but it should "compile"
02:41:20 <kolu> but where do I put the correct solution?
02:41:30 <[exa]> after the =
02:41:49 <[exa]> you get the 'xs' as input, and should produce the solution out of that
02:44:58 <kolu> so is xs the input?
02:45:11 <kolu> and I don't have to worry about getting an input in my solution?
02:45:40 <kolu> because my result is an IO String whereas the test wants just a string
02:50:06 <srhb> Is there any standardish library out there that supports DNS lookups using the search list defined in /etc/resolv.conf?
02:51:38 <merijn> libc? *ducks*
02:52:03 <srhb> merijn: :P Yeah, might as well just shell out to getent then. Ugh.
02:53:22 <merijn> srhb: Hey, libc doesn't suck on *all* platforms :p
02:53:52 <srhb> True enough. I was hoping in vain that I was just failing to find the neatly packaged wrapper online. Oh well. :P
03:02:06 <merijn> hmm, liftIO seems to be surprisingly costly for some monad stacks...
03:03:27 <[exa]> kolu: it certainly looks that way. I guess they will wait with IO until some later exercises
03:07:45 <kolu> thank you for your time
03:07:49 <kolu> I will have to figure out
03:08:03 <kolu> how to write the exercise
03:08:26 <kolu> in order to satisfy the requirements
03:08:29 <[exa]> btw what's your solution now?
03:08:50 <[exa]> (use pastebin if you can, pasting code directly here is frowned upon)
03:10:59 <tdammers> merijn: yeah, it's almost embarrassing. some things really trip up GHC's optimizations.
03:11:30 <merijn> tdammers: tbh, this is the "left-heavy" visualisation of speedscope, and I'm not quite sure how to read that yet
03:12:04 <kolu> https://pastebin.com/GxhagDuE
03:12:25 <merijn> hmm...I hope I don't have to recompile everything each time I update a dependency, 'cause this optimisation effort is going to a long time if I do >.>
03:19:00 <kolu> [exa] is it relevant?
03:27:33 <[exa]> kolu: basically yes, you can reorganize that a tiny bit to fit in the framework of exercism
03:28:43 <[exa]> basically, using your code: acronym `input = map toUpper acronym`  and below that: `  where minus=... ` etc
03:30:44 <[exa]> kolu: btw when you get it working, send us the final code, there are minor extra style&safety&terseness hints that you could use
03:32:33 <[exa]> (btw I misplaced the ` in my definition above, behind acronym, but I guess you'll get that :] )
03:35:02 <srk> o/ I'm trying to do a bit of symbolic math with simple language and uniplate - https://paste.rs/MeK.hs is this approach ok? 
03:42:24 <merijn> How does GHC decide up until what code in dependencies to compute cost centers?
03:42:46 <merijn> Like, I see a call stack that *partially* includes stuff from my dependencies, but not everything?
04:03:02 * hackage yeamer 0.1.0.4 - Yesod-based server for interactive presentation slides  https://hackage.haskell.org/package/yeamer-0.1.0.4 (leftaroundabout)
04:03:55 <kolu> [exa] I'm not sure I will continue with exercism. What you recommend I should?
04:05:03 <kolu> would
04:05:49 <[exa]> not sure, if the exercises make any sense for you then please do
04:06:31 <[exa]> kolu: btw did you get that thing working?
04:09:07 <kolu> trying to
04:10:27 <[exa]> kolu: feel free to pastebin immediate code + errors for comments
04:11:12 <kolu> I'll pastebin your suggestion inside the exercism file
04:16:49 <zincy__> Is it better to avoid nesting record types if you aren't using lenses?
04:17:47 <kolu> [exa] I think I got the general idea. I'll try and rewrite the whole thing and will let you know later when I'm done. Thank you very much.
04:23:47 <merijn> zincy__: It depends (TM)
04:24:01 <merijn> zincy__: For example, on how you use them
04:27:21 <zincy__> merijn: Yeah at the moment we are marshalling between different types A and B which both nest a common record type C
04:27:31 <zincy__> Does that count as painful?
04:29:21 <tdammers> clojurists would say that this is the point where you just give up on types entirely and just use hashmaps for everything
04:29:42 <merijn> zincy__: I mean, it's mostly nested updates that are a pain
04:29:55 <merijn> zincy__: If you use them mostly "read-only" there's hardly a problem
04:29:55 <zincy__> Ah right
04:30:36 <merijn> Composing accessors to access deeply nested values works fine if you don't have to update them
04:31:44 <[exa]> kolu: ok great!
04:32:43 <tdammers> there's also the "class Has" approach
04:34:24 <tdammers> e.g.: class HasFoo a where foo :: Lens a a Int Int; instance HasFoo C where foo = cFoo; instance HasFoo A where foo = aC . cFoo; instance HasFoo B where foo = bC . cFoo
04:39:48 <Eduard_Munteanu> Or you can use a minimalistic lens package if you don't need everything.
04:41:07 <tdammers> the lens part there was really just meant as an example, you can also do it manually
04:41:35 <tdammers> e.g.: class HasFoo a where getFoo :: a -> Int; setFoo :: Int -> a -> a
05:04:01 <loops> I want to program a "worker" process that performs some IO, waits a few seconds, then performs IO again. Despite having an exception handler, whenever an exception occurs the program exits with "<<loop>>". What is the idiomatic way to program a "worker" loop which performs IO, waits, then loops, while handling exceptions?
05:05:03 <merijn> loops: "<<loop>>" means you have a direct recursion (i.e. a value pointing to itself such as "let x = x in x")
05:05:26 <merijn> loops: So it sounds like your exception handler is faulty
05:05:34 <merijn> loops: Can you pastebin the code?
05:07:47 <zincy__> merijn: Thanks for the explanation on record nesting!
05:11:45 <merijn> zincy__: Alternately: Just start writing code, once the nesting becomes an issue you can always start using lenses then
05:58:04 <loops> merjin: I'm not sure I understand. Isn't "let x = x in x" the type of all loops? main :: IO () is that same type whether or not it has a loop in it or not. I have a function of type IO () which reads from a DB, does some stuff, calls threadDelay, then calls itself.https://pastebin.com/DUXUD4Ax the behavior is very weird to me, when an exception
05:58:04 <loops> happens the program exits with "<<loop>>" but if no exception happens (no results from DB), it continues to loop.
06:01:01 <merijn> That seems to indicate the problem is in the code producing/catching the exception
06:01:29 <merijn> The catching seems mostly fine, so presumably something goes wrong in the creation of the exception, i.e. MF2.fetchBlogFromUrl
06:02:41 <loops> hmm... I am wrapping a DB call in try to catch exception of the type from the DB library, and rethrowing them as my application exception type using try/throwIO
06:03:36 <merijn> loops: <<loop>> means "the computation of a value depends on its result" (which can never work), so you're somehow/somewhere constructing a broken value
06:04:18 <rwfs> anyone know how to pass RTS options to ghci through cabal repl ? "ghci +RTS -c -M1500M -K1G -A16M -RTS" appears to work, "cabal repl --repl-options="+RTS -c -M1500M -K1G -A16M -RTS"" results in ghci saying "target ‘+RTS -c -M1500M -K1G -A16M -RTS’ is not a module name or a source file"
06:05:23 <loops> merijn: hmm thanks for your help... I'll keep looking.
06:06:42 <tdammers> not all loops are as simple as this one
06:06:53 <tdammers> and GHC cannot detect all of them
06:07:05 <tdammers> ex.:
06:07:17 <tdammers> > let x = 1 : x in take 10 x
06:07:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:07:26 <tdammers> ^ this one is actually fine
06:07:49 <tdammers> if GHC were to call "<<loop>>" on this one, that would actually be quite bad
06:09:28 <siraben> When does GHC actually say <<loop>>? I've never seen it.
06:10:34 <tdammers> siraben: colloquially, when you have an expression that is written in terms of itself, in such a way that evaluation never makes any progress
06:12:06 <merijn> siraben: It's an opportunistic exception, i.e. you cannot rely on ever getting it. It's just GHC noticing "well, this can *never* work" and reporting an error instead of hanging your code indefinitely
06:12:20 <merijn> siraben: More concretely, diving into GHC specifics
06:12:22 <aveltras> is there anything obviously wrong with this instance of Store ? deserialization doesn't work
06:12:26 <aveltras> https://www.irccloud.com/pastebin/HWrAYWqv/
06:12:47 <rwfs> welp it was --ghc-options
06:13:11 <siraben> Ah, I see.
06:13:22 <merijn> siraben: Whenever a Haskell capability starts evaluating a thunk it will "blackhole" that thunk (i.e. mark it as "currently being evaluated"), if evaluation ends up entering a blackhole (i.e. needing to evaluate an expression while it's already being evaluated) then you can *never* compute a result, so it throws <<loop>>
06:13:50 <merijn> siraben: (Not all thunks get blackholed, there's also greyholing, whiteholing and a bunch of other implementation details)
06:14:03 <siraben> Could you write an example?
06:14:08 <siraben> Of how to get <<loop>>
06:14:13 <merijn> siraben: The earlier "let x = x in x" example ;)
06:14:45 <merijn> siraben: When you try to evaluate 'x', you start evaluating the right hand side, but that's just 'x' again! Whoops, now we're infinitely recursing our evaluation of 'x'
06:15:41 <siraben> Right.
06:15:46 <merijn> siraben: Contrast with "let ones = 1 : ones in ones", here when we evaluate "ones" we hit the : constructor and return a result, evaluation finishes (and the 'ones' references on the right now refers back to the evaluated : constructor)
06:16:44 <tdammers> this is what "making progress" means in this context
06:17:17 <tdammers> when you evaluate x = x, you're left with the same thing you started with after the first reduction step - you haven't made any progress
06:17:49 <tdammers> but when you evaluate x = 1 : x, you're left with a different thing, a thing that is presumably "closer" to the final solution - you have made some progress
06:29:40 <siraben> Ah, right.
06:29:58 <siraben> My GHCi doesn't produce <<loop>>, though, it just keeps on going
06:30:48 <tdammers> as said before, it's a convenience feature that allows the program to abort early and without slurping up all your memory in some cases, but there is no guarantee it will happen
06:31:37 <siraben> Right.
06:34:52 <merijn> siraben: ghci uses an interpreter that is implemented rather differently from how the code is compiled to machine code
06:35:09 <siraben> Makes sense.
06:35:09 <merijn> siraben: (Incidentally, this is also why you should never trust timing/profiling of ghci)
06:36:21 <tdammers> also note that even outside of ghci, optimization options and such can alter evaluation order quite radically, and what <<loop>>s with one set of compiler flags may not with antoher
06:37:08 <furnost> hi all. I'm having a bit of trouble understanding how to catch SqlErrors. Is there any good resource you could redirect me to ? I don't really understand why a query doesn't have a return type like Either SqlError [SqlValue] or something like that
06:44:12 <aveltras> furnost: you can take a look at https://tech.fpcomplete.com/haskell/tutorial/exceptions which clarified many things related to exceptions handling in haskell for me
06:47:48 <infandum> Using Turtle (https://hackage.haskell.org/package/turtle-1.5.17/), if I have a Shell stream of lines and do a reduce on it in two independent cases, is it still a stream or does it all get loaded into memory like lists do?
06:48:13 <infandum> using Turtle.Bytes.input
06:50:05 <infandum> so something like with (f :: Shell a -> Shell a) (g :: Shell a -> b) (h :: Shell a -> c), I do `let stream = f . Turtle.Bytes.input $ file; x <- g stream; y <- h stream`
06:50:44 <opqdonut> infandum: looking briefly at the code it looks like it will reread the file on each reduce
06:51:17 <opqdonut> https://hackage.haskell.org/package/turtle-1.5.17/docs/src/Turtle.Bytes.html#inhandle the Shell is just a wrapper for a function like this
06:51:47 <opqdonut> in case of Bytes.input, that is
06:51:50 <infandum> OK, so it shouldn't hold the stream in memory?
06:51:58 <opqdonut> as far as I can see
06:52:02 <opqdonut> the profiler will tell you
06:52:02 <furnost> aveltras: Thanks, will read that !
06:52:17 <infandum> opqdonut: I have a profile, where will it say that?
06:52:26 <infandum> Because right now it says:
06:52:37 <infandum> reduce is 72% alloc
06:52:47 <opqdonut> I meant a heap profile to be exact
06:53:04 <infandum> and decompress is 29% alloc
06:53:15 <opqdonut> if you profile heap usage by type, for instance, you can look at if the amount of ByteString in memory is constant or grows over time
06:53:20 <infandum> and stream is %37 alloc
06:53:47 <infandum> But the bytestrings could be from many different sources, right? Not just this one functions
06:54:07 <opqdonut> sure. you can also profile by cost centre to get more accurate info
06:54:29 <opqdonut> but usually starting with a by-type profile is a good idea to get an overview
06:54:30 <infandum> Right now the main offender is `initInflate` with 58% alloc according to the profile
06:54:54 <opqdonut> %alloc just tells you how much the functions allocate, now how long the stuff stays in memory
06:55:25 <phadej> +RTS -T -h -s -RTS is the first thing you should to try
06:55:30 <infandum> oh, so a big stream that takes up 0.1% memory in reality would show up as much higher in the profiling?
06:55:32 <phadej> doesn't require compiling wiht profilign enabled
06:55:44 <opqdonut> yeah that's a good starting place too
06:56:09 <opqdonut> infandum: yes, it might
06:56:42 <merijn> infandum: The really import number is the "max resident" one at the top
06:56:54 <merijn> infandum: That and "productivity" are the main numbers to care about at first
06:57:02 <opqdonut> the ghc manual says
06:57:03 <opqdonut> > note that the total memory allocation figure isn’t the same as the amount of live memory needed by the program at any one time; the latter can be determined using heap profiling
06:57:06 <lambdabot>  <hint>:1:49: error: lexical error at character 't'
06:57:24 <opqdonut> bah, I always forget that using > to quote isn't a good idea here
06:57:25 <infandum> ah
06:57:53 <infandum> opqdonut: The issue I have with the heap profiling is that it shows a constant rise, but that makes sense as I'm loading a big matrix...
06:57:59 <merijn> infandum: "max resident" is the maximum amount of memory in use at any specific time
06:58:05 <loops_> merijn: I figured it out the "<<loop>>" issue. It was the exception handler that printed my exception, combined with an Exception instance that looked like this: https://pastebin.com/jmcWJnWW
06:58:27 <merijn> infandum: And "productivy" is "percentage of time *NOT* doing garbage collection"
06:58:41 <opqdonut> infandum: yeah it can sometimes be hard to pinpoint where the rise comes from, and if it's suspicious or not
06:59:14 <opqdonut> but profiling by type should definitely tell you if it's the input handling (ByteString) or the matrix (Array or Vector or something)
06:59:47 <infandum> ohhhh
07:00:16 <infandum> that makes sense, so I should theoretically see constant growth in the container of interest, but no growth in the stream
07:00:22 <opqdonut> mhmm
07:24:39 <infandum> opqdonut: Okay, using the command from phadej I got the hp graph. 12.7% productivity total
07:24:47 <infandum> Although it's a much smaller data set
07:25:16 <infandum> So I don't know if that changes things
07:25:33 <infandum> About 500,000 lines instead of 8 million (which was also a bit small)
07:25:49 <merijn> infandum: 12.7% productivity is pretty terrible
07:25:57 <merijn> infandum: Are you using the threaded runtime?
07:26:15 <infandum> What do you mean
07:26:21 <infandum> 6 cores?
07:26:26 <infandum> I can do single
07:26:31 <merijn> infandum: Are you using "-threaded" to compile the code?
07:26:52 <infandum> err I mean it is a single core
07:27:16 <infandum> Yes, threaded is used
07:27:56 <merijn> infandum: Can you try running with "+RTS -qg" ?
07:29:05 <merijn> infandum: The -threaded runtime (currently) enables parallel GC by default, but parallel GC performs terribly for most usecases. Disabling it with -qg can dramatically improve the performance of code compiled with -threaded
07:30:34 <infandum> 13.1% productivity
07:31:00 <infandum> with -qg
07:33:41 <infandum> merijn: Is it a GC issue with my code or a dependencies code?
07:33:49 <merijn> infandum: Hard to say
07:33:57 <infandum> Should I see where it is having trouble?
07:34:49 <merijn> infandum: Can you pastebin the full output of "+RTS -s"?
07:36:01 <infandum> merijn: https://pastebin.com/VCn7FmZ6
07:38:29 <merijn> infandum: You had a big matrix you were loading in, right?
07:39:06 <infandum> something like that
07:39:09 <merijn> Which datatype is said matrix?
07:39:15 <infandum> merijn: I convert each line to a matrix
07:39:20 <infandum> to a matrix entry
07:39:21 <infandum> sorry
07:39:31 <merijn> And do you keep it in memory the entire time?
07:39:42 <infandum> it's: https://hackage.haskell.org/package/sparse-linear-algebra-0.3.1/docs/Data-Sparse-SpMatrix.html
07:39:57 <infandum> And yes, it's used for many processes downstream
07:40:00 <infandum> the matrix
07:40:12 <infandum> the stream to read the matrix should not be used after the matrix is read
07:40:16 <infandum> err file is read
07:40:46 <zincy__> merijn: Is killing a thread done by throwing an async exception at it>?
07:40:54 <merijn> infandum: Basically, the output says you have 320MB resident (that seems fine), but 13% productivity is kinda bad
07:40:57 <merijn> zincy__: Yes
07:41:22 <infandum> merijn: How do pin-point the productivity killer location?
07:41:39 <infandum> And is that what is making it take up so much space
07:41:43 <infandum> or making it slower?
07:41:45 <infandum> than it could be
07:41:52 <merijn> infandum: GHC uses a "copy & compact" GC, which means that every GC the entire set of life data is copied. If your life set is big, then that's a problem due to redundant copying
07:42:23 <zincy__> merijn: thanks as always
07:42:24 <merijn> infandum: 320MB doesn't seem like too much space if you have a huge matrix, but it's hard to say without knowing how big your big matrix is
07:42:48 <infandum> merijn: This is a small example
07:43:00 <infandum> a bit example takes too long to profile
07:43:06 <infandum> big example
07:43:22 <merijn> infandum: What's small? million element matrix? billion?
07:43:34 <infandum> this particular one has 500,000 entries
07:43:43 <infandum> non-zero entries
07:44:11 <infandum> a slightly larger one has 8000000 non-zero entries
07:44:21 <merijn> ok, then 320mb sounds way off
07:44:38 <infandum> as in, way to large, right?
07:44:40 <merijn> infandum: Are you maybe storing thunks in the matrix? (Not sure if that matrix forces elements)
07:45:08 <infandum> how can I check?
07:45:30 <merijn> deepseq everything you put in, reprofile, see if it's way less space ;)
07:45:52 <merijn> If that works then you can think of a way to get the same result without deepseq's huge hammer
07:46:00 <infandum> well the step to put it in is `addToMat m (!i, !j, !x) = HS.insertSpMatrix i j x m
07:46:14 <infandum> reduce fold
07:46:26 <infandum> so those values should already be forced
07:57:11 <infandum> How do I read the retainer plot (-hr)? Like a function vs SYSTEM?
07:57:24 <opqdonut> have you read the manual?
07:57:45 <opqdonut> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#retainer-profiling
07:58:28 <infandum> Yes, but it says "the system stack", which I'm not sure what that is
07:58:50 <infandum> or telling the difference between a thunk or an "explicitly mutable object" in the hp plot
07:59:31 <opqdonut> AFAIU the stack retains stuff that's being "currently evaluated", and thunks retain stuff that's evaluation has been postponed
07:59:34 <merijn> infandum: explicitly mutable objects are (presumably) things like IORef, MVar, etc.
07:59:42 <opqdonut> I don't think I've every really gotten anything out from retainer profiling...
07:59:50 <infandum> OK, so I don't have any of those
07:59:58 <infandum> there is nothing that says thunk either
08:00:04 <infandum> just SYSTEM and some functions
08:00:17 <opqdonut> those functions are the thunks
08:00:22 <opqdonut> the thunks are name by cost center
08:00:42 <infandum> ah
08:01:00 <infandum> there are thunks everywhere then!!
08:03:00 <infandum> But it's not descriptive -- a big one is in fmap.\.step' but I don't know which one
08:03:25 <merijn> infandum: thunk is GHC terminology for "expression that's not been evaluated yet"
08:04:14 <infandum> merijn: Is it possible to have a space leak from a thunk from a function that shows small memory usage in the .prof?
08:05:13 <infandum> and it's fmap.\.step' from toLines from Turtle, but Gabriel is pretty good with that stuff
08:05:23 <infandum> So I would think it's another issue
08:05:32 * hackage ghc-lib-parser-ex 8.8.5.7 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.7 (shayne_fletcher)
08:07:24 <infandum> Could there be a space leak in https://github.com/GregorySchwartz/hierarchical-spectral-clustering/blob/master/src/Math/Clustering/Hierarchical/Spectral/Sparse.hs in "go"?
08:07:32 <infandum> It is recursive
08:08:16 <infandum> But with bangs
08:18:45 <infandum> opqdonut: In terms of the -hy to see if bytestrings are being held in memory in the stream, I see a linear increase twice -- once for each reduce. This implies that the stream is not being held in memory BETWEEN reduces, but rather it's being incorrectly held IN each reduce?
08:19:40 <opqdonut> infandum: that sounds plausible
08:26:31 * hackage dobutokO2 0.11.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.11.0.0 (OleksandrZhabenko)
08:29:32 * hackage dobutokO2 0.11.0.1 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.11.0.1 (OleksandrZhabenko)
08:33:05 <furnost> hello again. I feel like I have the opportunity to use >>= but it doesn't compile and I'm not really sure why... Here's the code: http://dpaste.com/0YDRSY2
08:34:27 <furnost> Here is the errors from ghci: http://dpaste.com/0K5X54Z
08:35:30 <merijn> furnost: Remember that "do { foo <- stuff; bar foo }" is equivalent to "stuff >>= \foo -> bar foo"
08:36:12 <merijn> furnost: So first using do notation to bind "res" on line 41, then using >>= on line 42 seems to do >>= twice, which might be correct, but given your question probably isn't :p
08:37:36 <furnost> merijn, the thing I would like to not do is pattern match on res to propagate the Left value but still apply a function to the Right value. Isn't this the correct way to go about it ?
08:38:32 * hackage dobutokO2 0.11.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.11.1.0 (OleksandrZhabenko)
08:38:41 <merijn> furnost: Ah, "res" is "Either" and you wanna use the monad instance of either?
08:38:46 <furnost> yes
08:39:05 <merijn> That doesn't quite workout, because the right hand of >>= needs to have a return value that matches the left hand
08:39:09 <merijn> :t (>>=)
08:39:09 <furnost> http://dpaste.com/2H04D5Y this works but I feel there is the opportunity to do something cleaner
08:39:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:39:30 <merijn> But "storeNewContactInformation" is "IO (Either...)", not "Either ..."
08:40:12 <merijn> This is exactly what the MaybeT (for Maybe) and ExceptT (for either) transformers do
08:40:46 <merijn> furnost: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Except.html#t:ExceptT
08:41:05 <furnost> merijn: Ok. I read a bit about transformers but I'm at a loss on how to use them correctly... I'll read some more
08:41:32 <merijn> furnost: ExceptT wraps a value "Monad m => m (Either e a)" and defines a new monad instance that short-circuits on the inner Either (if its left)
08:42:44 <merijn> furnost: Honestly, the simplest way to get a grip on them is to implement one yourself. My goto exercise is: First implement State, then generalise to StateT, that generally helps to really understand things: https://gist.github.com/merijn/098106abd45c940dab09
08:43:28 <furnost> merijn: Thanks, I will do that
08:49:01 * hackage dobutokO2 0.11.2.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.11.2.0 (OleksandrZhabenko)
09:49:02 <Uniaika> hello there
09:50:03 <Uniaika> I wish to produce some sort of deprecation warning for a module in a codebase (that alas cannot be simply erased, but I would like to warn newcomers on the codebase who may be tempted to its functions). How can I produce such deprecation warning messages?
09:50:14 <Uniaika> All I can find are lists of GHC's own messages
09:50:39 <merijn> Uniaika: There's a deprecation pragma for functions
09:50:56 <merijn> Uniaika: So I'd just mark all the functions deprecated and include a message at the top of the module by hand
09:51:19 <Uniaika> thank you very much :)
09:53:14 <Uniaika> merijn: that being said, it would seem I can just apply the pragma to the whole module
09:53:23 <Uniaika> (which is exactly what I want)
09:53:36 <merijn> Uniaika: Oh, good, I didn't even know :)
09:53:39 <Uniaika> \o/
09:54:38 <Uniaika> merijn: https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/glasgow_exts.html#warning-and-deprecated-pragmas
09:57:45 <cousteau> Hi!  I installed a package via cabal install, do I need to do anything else before using it? 
09:58:13 <Uniaika> cousteau: hi! is that for project development, or just trying things out in the REPL?
09:58:26 <cousteau> (I have absolutely no idea what I'm doing btw, just following the compilation instructions for a software which aren't working) 
09:58:45 <Uniaika> what's the software in question? maybe we can help? :)
09:58:53 <cousteau> Uniaika: well actually the former, but I tried the latter and it didn't work 
10:00:22 <cousteau> cabal install bv; and then in ghci I tried import Data.BitVector and it says it couldn't find the module 
10:00:43 <cousteau> I don't know if I'm missing something, the path seems to be set correctly 
10:01:20 <cousteau> I installed ghc and cabal from get-ghcup.haskell.org 
10:01:24 <godisded> Hi, what's easiest way to convert list in shape of e.g. [1, 2, 3] into (Pair (Num 1) (Pair (Num 2) (Num 3)))?
10:02:04 <cousteau> I'm probably missing a step or two 
10:03:29 <merijn> cousteau: cabal v3.0?
10:04:08 <cousteau> Yep 
10:04:13 <cousteau> 3.0.0.0
10:04:24 <geekosaur> cousteau, cabal 3.x changed usage a bit, "cabal install" isn't really a thing any more but older packages still talk about the older usage. v1-install might work better, but a sandbox would be safer
10:04:47 <merijn> Or just start using a .cabal file right away ;)
10:05:08 <cousteau> How new is this cabal 3.0?  Like, few months new? 
10:05:43 <geekosaur> yes but that doesn't mean everyone rereleased their packages with new install documentation
10:05:46 <merijn> cousteau: Anyway, asof 3.0 all package are installed in a sort of transparent sandbox, rather than into some "global path". The benefit of this is that it means working on different projects with conflicting dependencies "just works"
10:05:51 <cousteau> If so I'll try to install an older one which was probably what was used for these instructions 
10:06:47 <merijn> cousteau: The downside is that you know need to explicitly tell which package to bring in scope so you can import them. Normally, if you work on existing code you can just use cabal to do that for you, but it does mean that "just playing around in ghci" works less well (until someone figures out how to make a nice workflow)
10:07:18 <cousteau> merijn: sounds awesome tbh, but currently I'm only trying to get one project working.  This is a work PC that probably won't be hosting any other Haskell projects 
10:07:49 <cousteau> Also I have never used haskell in my life.  Well I started learning it once, but didn't get too far. 
10:08:02 <merijn> cousteau: Right, so you have an existing project to work on with a cabal file?
10:08:20 <merijn> cousteau: Try using "cabal repl" in the directory with the cabal file instead
10:08:35 <merijn> cousteau: That will start ghci with all the relevant dependencies available
10:09:13 <cousteau> You're gonna kill me, but what does a cabal file look like? 
10:09:31 <merijn> cousteau: as in a file named "my-project.cabal" :)
10:09:53 <cousteau> OK then no this project doesn't have any *.cabal file
10:10:07 <merijn> existing codebases should almost certainly have that (unless your work uses stack, in which case I can't help you 'cause I dont' use it)
10:10:12 <cousteau> Let me check again though 
10:10:38 <cousteau> Yep. No trace of any .cabal file 
10:10:54 <sclv> a yaml file?
10:11:12 <Uniaika> #OneSentenceHorror
10:12:56 <cousteau> This is a pretty straightforward program.  You just follow the install instructions for its dependencies, then run ./runTests.sh, which calls a bunch of makefiles that do all the magic for you, and eventually yield an error :(
10:12:58 <ski> -!- #OneSentenceHorror: No such channel
10:13:14 <glguy> ski: terrifying
10:13:28 * ski smiles
10:13:56 <cousteau> OK I think I'll try to figure this on my own for a while rather than bugging all of you with little to no helpful info from my side 
10:13:57 <merijn> cousteau: Is the code available publically?
10:14:18 <cousteau> I'll be back when I inevitably fail miserably. 
10:15:06 <shapr> fryguybob: you still doing that HTM project?
10:16:08 <cousteau> Yes, but it's a salad of dependencies and github projects I don't feel OK making you deal with.  I'll try on my own for a while and come back when I give up. 
10:16:45 <monochrom> I bet most of the dependencies can be installed by "cabal v1-install".
10:17:14 <monochrom> But I guess the problem is not there in the first place.
10:22:57 <merijn> So how does GHC decide where in dependencies it'll put cost centres? Because I see *some* invocation of dependency code, but not all
10:23:07 <merijn> And how can I affect that?
10:25:07 <cousteau> I'll try using  v1-install instead of install just to see what happens.  But question: since this was clearly intended for an older version of Cabal, can I download that version from somewhere? 
10:25:52 <cousteau> As I said before, I installed ghc and cabal from get-ghcup.haskell.org, maybe there's a link with an older cabal version 
10:28:16 <cousteau> Can I v1-install a package that has already been installed? 
10:29:03 <merijn> cousteau: Not really an answer for your question, but your mixed use of cabal and Cabal capitalisation suggests you might be mixing up different things named cabal: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
10:29:34 <fryguybob> shapr: I completed my thesis.
10:31:06 <cousteau> fryguybob: congratulations! 
10:31:12 <heatsink> oh, congratulations 🎈
10:31:14 <cousteau> PhD? 
10:36:25 <fryguybob> cousteau: Thanks.  heatsink: yes PhD.
10:37:01 <cousteau> well, congrats and welcome to the club :)
10:38:10 <cousteau> merijn: sorry but I'm a complete noob, have never used the haskell workflow before, and have no idea what I'm doing.  So yes, I am probably mixing terms, sorry about that.  So far the only cabal I've used is the ˋcabalˋ command.  Also I have seen the ˜/.cabal directory (sorry this keyboard doesn't have a proper ˜) but only to see what was inside
10:39:29 <cousteau> I just did ˋcabal v1-install bvˋ and now I can run ˋimport Data.BitVectorˋ from ghci without any drama, so I guess that was the way to go.
10:43:17 <cousteau> about whether or not I can simultaneously install and v1-install a package, I'll just do a clean install of GHC/cAbaL and install stuff with v1- only, because I'm that paranoid.
10:44:51 <geekosaur> you can do so, they do different actions
10:45:15 <cousteau> oh
10:45:27 <cousteau> welp, good to know :D
10:45:55 <geekosaur> v1-install installs to a user package store, v2-install aka install in cabal 3+ installs to an internal registry which will be used to populate a virtual sandbox when needed by a v2 workflow
10:46:15 <cousteau> I see
10:55:40 <fendor> I want to parse a list of filepaths separated by spaces. Files with spaces are enclosed with quotes, e.g. `File1 File2 "Fi le3"`. is there some idiomatic solution to that problem?
10:56:48 <ChaiTRex> fendor: You could use a parsing library or write a small parser yourself.
10:57:29 <monochrom> Yikes. If possible I would require the paths to be separated by \0 instead.
10:57:32 <ChaiTRex> fendor: The parsing libraries are named things like Parsec, Megaparsec, Nanoparsec, etc.
10:57:34 <fendor> ChaiTRex, I tried to write some with Text.ParserCombinators.ReadP, but struggle with filepaths like "File\"test"
10:57:54 <fendor> monochrom, not possible, ghci-script vomited by stack
10:59:21 <geekosaur> http://hackage.haskell.org/package/shellwords might be of interest
11:01:43 <fendor> thank you, that seems helpful
11:11:45 <monochrom> Wait, I think there is no Nanoparsec
11:12:19 <monochrom> Also, I made a typo (I corrected it in time) and invented the awesome name Nonoparsec :)
11:12:37 <geekosaur> neenerparsec?
11:13:03 <monochrom> Let's start a parser war! parsec vs noparsec, and noparsec vs nonoparsec.
11:13:22 <monochrom> Also an abstraction war like monad vs nomonad.
11:13:32 <fog> I have tried to write List using this representation of Datatype; https://gist.github.com/fog-hs/e3b0c7154549165635a80449db78b9d3
11:14:13 * monochrom starts the movement nodependenttype
11:14:45 <fog> but the type of the param, which is Sum_T [a], means that the params in the product fields of the sum type must all have the same kind
11:15:20 <fog> but this leads to an error as it tries to make an infinite type
11:16:48 <fog> because for list, the product type (:) takes [a,List a], where these have different kinds, and it says, cant construct the infinite type a ~ List a
11:17:05 <fog> complaining about the kind hetrogineity of the params list
11:17:47 <fog> it seems like this way of expressing datatypes does not support recursive datatypes
11:18:18 <fog> so either, it has to use the Free mechanism (I would have to write CoFree for expressing Lists...)
11:18:28 <fog> for all recursive datatypes
11:19:53 <fog> or, instead of Sum_T [a], it should be the mapping of HList over the (hetroginous) params, instead of [] over the homogenous `a'
11:20:30 <fog> allowing Datatype to represent recursive Datatypes
11:25:55 <cousteau> Welp, all my issues were solved!  This thing compiled at last.  Thanks everyone for the help! 
11:26:05 <monochrom> congrats
11:27:02 * hackage retrie 0.1.0.0 - A powerful, easy-to-use codemodding tool for Haskell.  https://hackage.haskell.org/package/retrie-0.1.0.0 (AndrewFarmer)
11:59:01 <maerwald> https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons-Prelude-Functor.html#t:-36--62-
11:59:05 <maerwald> what am I looking at here
11:59:50 <fog> looks like some kind of flipped type level fmap?
12:01:00 <fog> yeah, it uses this; https://hackage.haskell.org/package/singletons-2.6/docs/Data-Singletons-Prelude-Functor.html#t:-60--36--64--35--64--36-
12:01:42 <fog> which is inflix fmap symbol judging by the indecipherable type and the other not-infix fmap symbols it appears to be difined next to
12:02:01 <fog> maerwald ^
12:17:30 <monochrom> maerwald: Join my movement of NoDependentType :)
12:17:45 <monochrom> It's like NoSQL but just cause. :)
12:19:30 <{abby}> surely promoting "no dependent types" is arguing in favour of cursed singletons defunctionalisation symbols?
12:28:53 <refusenick> What's the simplest tutorial implementation/explanation of algebraic effects?
12:43:01 <glguy> {abby}: It would be arguing against doing that, too
12:44:02 <maerwald> monochrom: I like dependent types, just not in haskell
12:44:41 <maerwald> I believe in the layered language approach of C# -> F# -> F*
12:44:48 <maerwald> if it is done well
12:45:58 <ysangkok> i don't get f*. i tried reading the documentation and i found it a lot more complicated than idris
12:46:12 <maerwald> It is, but it's also nice
12:46:13 <ysangkok> maybe the complexity is needed to allow for imperative-style programming
12:46:28 <maerwald> It doesn't pretend to be a general purpose language, because it isn't
12:46:40 <ysangkok> both are them are not :P
12:59:58 <monochrom> w00t F* has weakest precondition calculus.
13:01:00 <maerwald> Now we should have enough time to go through the F* tutorial again, lol
13:05:12 <maerwald> Is there a way to convert a megaprsec Parser to an attoparsec Parser?
13:05:14 <maerwald> https://hackage.haskell.org/package/versions-3.5.3/docs/Data-Versions.html#g:3
13:05:22 <maerwald> this package exposes megaparsec parsers only
13:08:31 * hackage reflex 0.6.4.1 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.6.4.1 (JohnEricson)
13:10:39 <refusenick> Hello?
13:12:39 <ysangkok> refusenick: i thought this ocaml intro was easy to understand: https://www.youtube.com/watch?v=z8SI7WBtlcA
13:13:19 <ysangkok> refusenick: IMO ocaml is less ambitious in its feature-set, and their stuff is less general than haskell things are
13:17:02 * hackage zip 1.4.1 - Operations on zip archives  https://hackage.haskell.org/package/zip-1.4.1 (mrkkrp)
13:29:44 <refusenick> ysangkok: Thanks. I've been reading through some of Oleg Kiselyov's work on implementing algebraic effects via delimited continuations in OCaml, but feel a bit lost without a highlevel overview.
13:31:03 <refusenick> I find work in lower-level primitives like continuations unmotivated by itself - reading the code doesn't intuitively give "the big picture".
13:31:42 <ysangkok> i am the same way. better start high-level and you get motivated to learn the details once the high-level abstraction breaks down :O
13:32:24 <refusenick> A smaller scope is probably what I want for an intro - a lot of what's done in Haskell with algebraic effects is cool, but I can't make head or tails of it.
13:34:33 <refusenick> Oh god, the audio.
13:35:21 <ysangkok> could be worse
13:35:26 <refusenick> True
13:35:52 <refusenick> That's the tagline for 2020, isn't it? "could be worse"
13:37:18 <refusenick> My tea just went fascist.
13:38:40 <infandum> If I build with stack --executable-profiling --library-profiling, would the resulting executable be slower / more memory inefficient? It certainly seems like it
13:40:28 <sm[m]> I’d expect so
13:45:11 <Nolrai> So, I guess I don't understand "HasCallStack" I would have thought that if I put it on my main that any error called in my program would have main at the top of its call stack. But I am getting a vector index out of bounds and the call stack consists only of the error call inside the Vector library. 
13:52:26 <sm[m]> it’s an odd thing. You need it on the failing function (and its parents ?)
13:53:10 <sm[m]> though error shows the full call stack by default with modern ghc, I think ?
13:55:09 <Nolrai> Well I am using 8.8.2 
13:56:18 <Nolrai> And all I get is:
13:56:20 <Nolrai> wireworld: ./Data/Vector/Generic.hs:248 ((!)): index out of bounds (24,24)CallStack (from HasCallStack):  error, called at ./Data/Vector/Internal/Check.hs:87:5 in vector-0.12.1.2-9VEK1w6XuCFF3hLj52eD2N:Data.Vector.Internal.Check
13:58:31 * hackage HsWebots 0.1.1.3 - Webots bindings for Haskell  https://hackage.haskell.org/package/HsWebots-0.1.1.3 (junjihashimoto)
14:20:29 <sm[m]> Nolrai: I’m not sure about this, best to check the ghc manual I think
14:21:01 <Nolrai> Well ghci has a way to catch exceptions, so I am using that.
14:24:48 <Nolrai> Well, my 5 by 5 "array" has length 24. Hmm.
14:25:59 <solonarv> sound like an off-by-one
14:34:37 <maerwald> How do you turn a: String -> Either a b back into an attoparsec Parser? Don't have access to the input from looking at the API
14:46:18 <solonarv> maerwald: I'm not sure you can; how much of the input do you want to consume?
14:47:13 <solonarv> and how should the parser know how much of the input to feed into that 'String -> Either a b' function?
14:47:37 <maerwald> Yeah, no idea
14:47:50 <maerwald> Other option is trying to convert a megaparsec into an attoparsec :>
14:48:58 <solonarv> I think that has the same problem
14:49:11 <maerwald> libraries are not polymorphic...
14:50:19 <Nolrai> maerwald: can you zoom out a little on your problem, what are you trying to do?
14:50:34 <maerwald> https://hackage.haskell.org/package/versions-3.5.3/docs/Data-Versions.html#g:3
14:50:39 <maerwald> using that with attoparsec
14:58:19 <remexre> is there a way to write a KnownNat n => proxy n -> Whatever that has different behavior for n~0, and recurses down in the non-zero case?
15:04:57 <solonarv> remexre: should be doable
15:07:10 <solonarv> % let { foo :: KnownNat n => proxy n -> String; foo p = case natVal p of 0 -> "nil"; n -> "succ " ++ case someNatVal (n-1) of SomeNat p' -> foo p' }
15:07:11 <yahb> solonarv: ; <interactive>:38:14: error: Not in scope: type constructor or class `KnownNat'; <interactive>:38:125: error: Not in scope: data constructor `SomeNat'
15:07:22 <solonarv> % import GHC.TypeNats
15:07:23 <yahb> solonarv: 
15:07:26 <solonarv> % let { foo :: KnownNat n => proxy n -> String; foo p = case natVal p of 0 -> "nil"; n -> "succ " ++ case someNatVal (n-1) of SomeNat p' -> foo p' }
15:07:26 <yahb> solonarv: 
15:07:33 <solonarv> % foo (Proxy @5)
15:07:33 <yahb> solonarv: "succ succ succ succ succ nil"
15:07:39 <remexre> oh, by making it dynamic? hm, ok
15:07:39 <solonarv> foo (Proxy @0)
15:07:44 <solonarv> yeah
15:08:09 * nil blushes
15:08:10 <solonarv> you could also write your own typeclass instead of relying on KnownNat
15:09:04 <remexre> one that provides e.g. induction on nats? yeah, probably will at some point if I keep running into things where I need it
15:09:29 <remexre> and have instance KnownNat n => IndNat n where ...
15:09:56 <solonarv> unfortunately Nat isn't inductive, so working inductively with it is hard
15:10:27 <remexre> yeah, I'd probably do it w/ an induction principle
15:10:34 <remexre> like the trick for closed type families
15:11:55 <remexre> like class IndNat n where caseNat :: (n :~: 0 -> a) -> (forall m. n :~: 1 + m -> a) -> Proxy n -> a
15:12:54 <remexre> and indNat :: (n :~: 0 -> f 0) -> (forall i j. j :~: 1 + i -> f i -> f j) -> Proxy n -> f n
15:13:08 <remexre> er, I guess the first arg to indNat would just be (f 00
15:13:10 <remexre> f 0 *
15:17:20 <remexre> hm, though it looks like matching natVal n to 0 isn't enough for GHC to know that n ~ 0 :(
15:19:46 <sarahzrf> you need sameNat
15:19:58 <remexre> ah, neat
15:20:08 <remexre> I really need to memorize all the docs for this lol
15:20:11 <sarahzrf> :)
15:20:26 <remexre> or port this to agda where I understand the rules :P
15:53:32 * hackage launchdarkly-server-sdk 1.0.2 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-1.0.2 (launchdarkly)
16:06:12 <koz_> Is there a way, with microlens (and microlens-mtl) to call down the environment, access a component of it (with lens fooBar available) of type Map Text Quux, and then turn said Map into a list of its keys?
16:06:48 <koz_> So far, I have 'listOfKeys <- view (fooBar . _)', but I'm not sure if there's something that I can put in that hole to get what I want.
16:08:34 <Axman6> o Map.keys?
16:08:43 <Axman6> to Map.keys*
16:09:16 <koz_> Oh yeah, that works perfectly!
16:09:39 <koz_> I keep forgetting that 'to' is a thing.
16:09:45 <Axman6> here's probably some indexed optic thing you could do but this is simple enough
16:10:00 <koz_> I doubt that it exists in microlens.
16:10:09 <Axman6> % :t indices
16:10:10 <yahb> Axman6: Ix i => Array i e -> [i]
16:10:10 <koz_> ${TEXAS}lens might have it.
16:10:53 <Axman6> (That was a complete guess)
16:11:14 <koz_> Yeah, that's sorta-kinda the idea.
16:18:31 <maerwald> how do you reparse with megaparsec... basically p1 >>= p2, but where the result of p1 is the *input* to p2
16:18:57 <koz_> maerwald: Is megaparsec's Parser _not_ a Monad?
16:19:06 <maerwald> It is
16:19:12 <monochrom> Does megaparsec have a setInput?
16:19:24 <koz_> Oh wait, I misread.
16:19:24 <maerwald> monochrom: oh!
16:19:25 <koz_> Derp.
16:19:35 <maerwald> :)
16:40:15 <koz_> Does QuickCheck have something analogous to a combination of a pattern match and ==>? I basically need something like 'if the result of this matches against this pattern, then [some stuff relating to specifics that can only be obtained via this match]'.
16:40:47 <koz_> I can do it crudely by doing a match test to the left of ==> and then writing a partial function (or something which errors) on the right of the ==>, but that seems hideous.
16:44:25 <dmwit> I mean... you can just do what (==>) does...?
16:44:55 <dmwit> https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/src/Test.QuickCheck.Property.html#%3D%3D%3E
16:46:16 <koz_> dmwit: Ah, yeah, I see.
16:46:25 <koz_> That's... pretty easy actually. Thanks!
16:49:08 <remexre> is there some sorta cabal v2-sandbox that makes it so I don't need to recompile all my deps whenever I switch between two projects
16:49:34 <remexre> 'cause rn if I do (cd foo; cabal v2-build; cd ../bar; cabal v2-build; cd ../foo; cabal v2-build) it rebuilds all foo's deps both times
16:50:37 <maerwald> That sounds something is not right
16:51:51 <Axman6> that's essentially what stack does
16:52:39 <maerwald> Axman6: ?
16:53:15 <solonarv> yeah that shouldn't be happening
16:53:32 * hackage postgres-websockets 0.5.0.2 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.5.0.2 (diogob)
16:53:43 <maerwald> remexre: are those directories in the same git repo?
16:53:52 <remexre> maerwald: no
16:53:54 <Axman6> the shared identical library builds cache is something stack does, but this is a different problem
16:54:28 <remexre> er I guess it's not all dependencies
16:54:31 <remexre> I think just the shared ones?
16:54:36 <remexre> if that helps narrow it down
16:57:21 <remexre> uh wait it's also possible that i'm imagining things, or there's other confounding factors, because it only happened when switching foo->bar this time
16:57:42 <remexre> ugh
16:57:51 <maerwald> what's the best way to deal with ambigous suffixes in megaparsec? Write a function that tries to apply the last parser on the rest of the input and consume char by char?
16:58:11 <maerwald> Would be slow as hell, but meh
16:58:34 <maerwald> Otherwise manual inspection of the whole remaining input and splitting by special chars would be an option
16:59:34 <monochrom> Sometimes you can easily resolve the ambiguity by a few lookAhead.
17:00:08 <maerwald> "12-foo", p1 parses "12-foo" and p2 parses only "foo". So there's the possibility of "12-foo-foo" too
17:01:26 <maerwald> but p1 also parses "12"
17:02:36 <maerwald> getInput, parse p2 from the end, feed the rest into p1 :P
17:04:47 <monochrom> remexre: I would try "cabal v2-build foo bar".  This may also need a cabal.project file that says "packages: foo bar" modulo actual syntax.
17:05:19 <remexre> monochrom: the projects are unrelated; one's a work project and the other's a game I work on in my free time
17:05:53 <monochrom> Then that's strange, I haven't experienced unexplained rebuilding.
17:06:34 <maerwald> remexre: do you have ghc-options in a cabal.project of either of those projects set?
17:07:25 <remexre> maerwald: I've got a haddock-options in both, and documentation:true in one
17:08:21 <remexre> no ghc-options in either
17:08:27 <remexre> though there is one in one of the .cabal files
17:08:47 <maerwald> Well, the one in .cabal file only applies for that package, not for deps
17:43:32 * hackage hasql-notifications 0.1.0.0 - LISTEN/NOTIFY support for Hasql  https://hackage.haskell.org/package/hasql-notifications-0.1.0.0 (diogob)
18:27:08 <dmj`> anyone know if llvm-hs can be jit compiled and executed w/ llvm-ptx (targeting the GPU), similar to what accelerate can do
18:44:59 <xacktm> does anyone have an example on how to type functions with beam?  Trying various things to make that signature explicit and failing.. http://dpaste.com/1RRYHHJ
18:45:25 <xacktm> that part does compile if I don't make a signature though
18:48:35 <Axman6> xacktm: what happens if you leave out the type signature? can GHC infer it?
18:50:06 <xacktm> yes it can, but the whole project doesn't compile yet
18:50:44 <xacktm> can I get the type signature from GHC for just that function if the whole project doesn't compile?
18:51:02 <Axman6> what type does GHC give it? if you can lead that file in GHCi you should be able to get the full type (it might not be pretty, In the past we made the backend we were using concrete and that helped)
18:53:47 <xacktm> thanks for the loading tip.. it gives me this :S http://dpaste.com/1R7C9ER
18:54:29 <xacktm> can that be simplified, or do I copy/paste that..?
18:54:53 <Axman6> if you find that the inferred type is enormous, then you might want to make a type alias for the constraint somewhere: type SQLBackend be = (BeamSqlBackend be, HasSqlValueSyntax (Sql92ExpressionValueSyntax (Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax (BeamSqlBackendSyntax be)))))
18:55:23 <Axman6> then you just have uh, there needs to be a Text in there somewhere
18:55:29 <koz_> That's C++ levels of type inference right there. :P
18:56:10 <xacktm> lol
18:56:24 <siraben> @pl \h x -> e (x,h)
18:56:24 <lambdabot> (e .) . flip (,)
18:56:28 <xacktm> I see, I'll try to add taht Text
18:57:04 <Axman6> you could just make an alias for the second bit of that too, since you're likely to need it for more than Text arguments
18:57:33 <Axman6> something like: type SQLBackend be a = (HasSqlValueSyntax (Sql92ExpressionValueSyntax (Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax (BeamSqlBackendSyntax be)))) a)
18:57:58 <Axman6> uh, proibably better as type SQLArg be a = ...
18:58:55 <xacktm> nice, the mroe general the better
19:00:00 <Axman6> you can get real fancy and start using type level lists if you end up needing to add a lot of those constraints, SQLArgs be '[Text, Int, UUID], which would make that constraint for each type in the list
19:01:29 <Axman6> have wrote some related type level stuff for an app using beam in the past, but doing something different: https://github.com/data61/Mirza/blob/7b1026f105649ecf6f5493a1dd61e03c730fb127/projects/mirza-common-haskell/src/Mirza/Common/Types.hs#L249
19:01:32 <xacktm> interesting... I saw that syntax once in servant and didn't understand the voodoo
19:02:08 <Axman6> it's just data types at the type level, what's the problem? :P
19:04:05 <xacktm> hehe, idk, I guess I was doing mindless copy/paste to get it operationally working back then
19:04:15 <xacktm> but when you put it that way.. :)
19:07:50 <Guest_53> total newb here, ran into "configure: error: C compiler cannot create executablesSee `config.log' for more detailsFailed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!"
19:08:11 <Guest_53> whilst trying to install ghcup on my mac
19:08:44 <Axman6> do you have Xcode installed?
19:08:57 <Guest_53> doesn't look like it 
19:09:05 <Axman6> you can run xcode-select --install to install it
19:09:11 <Guest_53> XCode version... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instancenot found (too old?)
19:09:21 <Guest_53> k, trying now
19:11:42 <Guest_53> worked, thank you!
19:12:31 <Guest_53> YES
19:12:39 <Axman6> good luck!
19:37:02 * hackage lzlib 1.0.6.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.6.0 (vmchale)
19:47:21 <Psybur> I made a thing. Maybe someone here will find it amusing heh. () -> Adam : https://jrciii.com/blog/how-it-went-down
19:47:50 <koz_> LOL
19:48:01 <koz_> Shouldn't it be 'Void -> Adam'?
19:49:01 <monochrom> Human was the last creation so it should be the final object. :)
19:49:15 <Psybur> No void is nothing right. God is that which has always existed, they didnt come from nothing so I dont think Void is correct right? :D
19:49:16 <monochrom> or a final object
19:49:47 <MarcelineVQ> depends if god is inhabited
19:50:00 <koz_> In Haskell, all types are inhabited.
19:50:06 <monochrom> category theology
19:50:09 <MarcelineVQ> https://imgur.com/a/Nx9f3rG
19:50:09 <koz_> :D
19:50:41 <Axman6> Void -> God feels like an appropriate miracle
19:51:00 <dmj`> ex-nihilo
19:51:10 <koz_> dmj`: What I was going for exactly.
19:51:12 <Axman6> Therefore, god only exists of a function with that type exists, and it is lazy in the void argument
19:51:54 <iqubic> koz_: How do you explain Void than?
19:51:55 <dmj`> computational trinitarianism
19:52:05 <dmj`> there's def. an iso between Haskell and theology
19:52:30 <dmj`> both Haskell and God are immutable by default
19:52:38 <monochrom> big-bang-big-crunch-cyclic cosmology: void -> unit -> void -> unit -> ...
19:52:41 <koz_> You folks, stop with the zingers, I'm trying to screencap this for memes. :P
19:53:01 <Axman6> Include me in the screenshot
19:53:05 <iqubic> Also, GHC now no longer warns about incomplete pattern matching if one of the branches requires a value that is impossible to construct
19:53:11 <iqubic> Which is cool.
19:53:50 <iqubic> So if you have "Either Void Bool -> Bool" then GHC no longer complains about incomplete pattern matches if your function only has a Right branch.
19:54:54 <koz_> https://twitter.com/KozRoss/status/1239746832302923776
19:54:57 <koz_> Here folks, enjoy.
19:55:01 <iqubic> This is new in GHC 8.8.x.
19:55:41 <iqubic> So, when was Adam created?
19:55:53 <iqubic> A little before Eve. Ba-Dum-Tss.
19:55:55 <MarcelineVQ> anytime before now
19:56:07 <iqubic> My answer was better, and you know it.
19:56:10 <koz_> "In the beginning was the Word. However, The Simon did not approve of this, and begun the work of GHC."
19:56:19 <koz_> [insert something about GHC being finished in 7 days]
19:56:27 <koz_> [with the last one for rest, of course, so actually 6]
19:56:45 <monochrom> koz_! You need to make it an imagemap so when someone clicks on a URL in the picture it acts as a link!  (OK just kidding!)
19:57:04 <Axman6> iqubic: you can only say that if Eve needed Adam, otherwise the order is undefuined, and that sounds like a pretty old school opinion to hold about the weorld these days :P. 
19:57:04 <koz_> monochrom: Lol, you _vastly_ overrate my image editing skills.
19:57:06 <Axman6> world*
19:57:08 <koz_> Or my image _anything_ skills. :P
19:57:17 <iqubic> The word was too limiting. Thus the Int was created.
19:57:40 <koz_> iqubic: And even that was too limiting. So on the second day, the Simon created the ADT.
19:57:41 <MarcelineVQ> It's enough to take for granted than an Adam exists. If we have to have one  we can cosntuct an Adam when it's needed, so exactly when that happens isn't super important as long as it's in the near future.
19:58:07 <monochrom> No no no the 7th day was for the computer to compile GHC!
19:58:10 <MarcelineVQ> Mostly we want to erase the use of Adam's so we should avoid the latter situation when possible
19:58:17 <koz_> monochrom: This is not mutually-exclusive with rest.
19:58:25 <koz_> Especially back in the late 80s. :P
19:58:30 <monochrom> Yeah!
19:58:49 <Axman6> koz_: I'm resisting the urge to report that tweet with the reason "I appear in this photograph and I don't like it" :P
19:58:59 <koz_> Axman6: Lol, want me to tag you? :P
19:59:03 <MarcelineVQ> Adam's have a REST interface anyway
19:59:23 <Axman6> nah I'm good
19:59:29 <monochrom> Haha MarcelineVQ you're great
19:59:43 <MarcelineVQ> yes
20:00:04 <koz_> Supreme irony from SPJ's Microsoft Research page: "I am married to Dorothy, a priest in the Church of England."
20:01:04 <MarcelineVQ> I'm a friend of dorothy
20:01:18 <koz_> If only Edward were around, he'd immediately tell us that trinitarianism is basically a special case of coalgebra costate comonads or something.
20:01:30 <monochrom> hahaha
20:01:43 <koz_> And would publish a library of it within like 2 days.
20:01:55 <MarcelineVQ> it's probably an obvious consequence of the Rel category
20:02:00 <koz_> ROFL
20:02:23 <koz_> So _that's_ why Ed's been interested in relational programming lately...
20:07:54 <dmj`> https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/
20:09:26 <koz_> dmj`: Seems apt.
20:25:15 <dmj`> how do I see my lambda quotes? had a related quote on this topic
20:25:21 <dmj`> lambdabot*
20:28:07 <Axman6> @quote dmj
20:28:07 <lambdabot> heath says: dmjio ensists building subscriptions for the graphql-api library is only a matter of recursion and the IO monad, but that doesn't comfort me :)
20:28:12 <Axman6> @quote dmj`
20:28:12 <lambdabot> dmj` says: ask and you shall receive / seq, and ye shall find / snoc, and the door shall be open to you
20:28:38 <dmj`> there it is :)
20:29:19 <koz_> Brilliant.
20:37:14 <koz_> I'm having a bit of trouble what something like '(Foo bar) <- someComputation baz' means in the context of the list monad.
20:37:50 <koz_> Like, 'bar' appears to be a singular value.
20:38:12 <dmj`> koz_: the list monad lets you operate on all items in bulk, so editing that one value is like editing all values.
20:38:27 <Axman6> it means each foo in the result of the computation
20:38:51 <dmj`> the (<-) desugards to (=<<) :: (a -> [b]) -> [a] -> [b]
20:38:56 <dmj`> desugars*
20:39:48 <koz_> So if I had a function 'f :: TypeOfBar -> Int', how would I continue the computation above to make it spew [Int]?
20:40:06 <koz_> pure (f bar) would only give me _one_ result right?
20:40:31 <dmj`> koz_: the (>>=) will call `concat` for you after the transformation
20:40:39 <dmj`> koz_: (>>=) is just flip concatMap
20:40:43 <dmj`> :t flip concatMap
20:40:44 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
20:41:06 <koz_> dmj`: I'm still confused.
20:41:32 <koz_> If I were to write '(Foo bar) <- someComputation baz; pure (f bar)', I _believe_ I'll get _one_ result.
20:41:34 <koz_> Am I wrong?
20:41:44 <materiyolo> hi
20:41:48 <koz_> If so, what am I missing?
20:42:00 <koz_> materiyolo: Wazzup?
20:42:04 <dmj`> koz_: you'll get multiple results
20:42:15 <dmj`> :t (>>=) @[]
20:42:17 <lambdabot> error:
20:42:17 <lambdabot>     Pattern syntax in expression context: (>>=)@[]
20:42:17 <lambdabot>     Did you mean to enable TypeApplications?
20:42:36 <materiyolo> reeeee
20:42:57 <ysangkok> % :t (>>=) @[]
20:42:58 <yahb> ysangkok: [a] -> (a -> [b]) -> [b]
20:43:06 <dmj`> ysangkok: thanks
20:43:10 <materiyolo> i can't think of a proposal for haskell in GSoC rip
20:43:16 <dmj`> :t @def dupli xs = xs >>= 
20:43:17 <lambdabot> error: parse error on input ‘@’
20:43:27 <dmj`> @def dupli xs = xs >>= \x -> [x,x]
20:43:28 <lambdabot>  Defined.
20:43:39 <dmj`> > dupli "a"
20:43:41 <lambdabot>  "aa"
20:43:45 <koz_> Does that desugar into something like 'someComputation baz >>= \(Foo bar) -> pure bar'?
20:44:08 <dmj`> koz_: yes, well, you can omit the someComputation
20:44:29 <koz_> OK, _now_ it makes sense.
20:44:41 <MarcelineVQ> @undo do (Foo bar) <- someComputation baz; pure (f bar)
20:44:41 <lambdabot> someComputation baz >>= \ a -> case a of { (Foo bar) -> pure (f bar); _ -> fail ""}
20:45:02 <Axman6> except the fail's text will be a little bit more useful than that
20:45:12 <Axman6> hmm, maybe no actually, for lists
20:45:17 <dmj`> koz_: for each element in the list, it maps some f over it that transforms it and puts it back into the list monad, then it concats all of these new lists together
20:45:37 <koz_> For lists wouldn't it just give back []?
20:45:48 <koz_> So if nothing is a Foo match, I'd get an empty?
20:46:11 <Axman6> > fail "" :: [Int]
20:46:13 <lambdabot>  []
20:46:30 <dmj`> koz_: that only happens in the list comp syntax
20:46:46 <dmj`> > [ x | Just x <- [ Nothing, Just 3, Just 3 ] ]
20:46:48 <lambdabot>  [3,3]
20:46:58 <dmj`> koz_: it doesn't hard pattern match fail in the list comp syntax
20:47:19 <dmj`> koz_: but with a (>>=) you'd be in trouble I believe
20:47:35 <koz_> dmj`: So I guess with do-notation, I get the (>>=) behaviour?
20:47:51 <dmj`> > [ Nothing, Just 4 ] >>= \(Just x) -> pure [x]
20:47:53 <lambdabot>  *Exception: <interactive>:3:25-45: Non-exhaustive patterns in lambda
20:47:58 <dmj`> koz_: kaboom
20:48:03 <MarcelineVQ> that's not do
20:48:10 <MarcelineVQ> if it matters
20:48:14 <MarcelineVQ> *to you
20:48:15 <dmj`> koz_: with do-notation you'd still be in trouble I think
20:48:19 <dmj`> depends on fail
20:48:39 <dmj`> > do { Just x <- [ Nothing]; pure x }
20:48:41 <lambdabot>  []
20:48:51 <dmj`> ah, that's nice
20:49:08 <dmj`> as Axman6 demonstrated already :)
20:49:54 <etc_q> hey guys
20:49:59 <koz_> etc_q: Wazzup?
20:50:01 <dmj`> etc_q: hey
20:50:09 * koz_ is not a guy.
20:50:28 <etc_q> I'm making a data Mat a = M http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
20:50:37 <Axman6> Everyone's a guy in "Hey guys"
20:50:37 <etc_q> ops
20:50:53 <etc_q> I'm making a ```data Mat a = M http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a```
20:50:59 <etc_q> damn haha
20:51:04 <Axman6> you'll get there :P
20:51:20 <Axman6> ``` doesn't mean anything on IRC
20:53:21 <etc_q> yeah forgot hahah
20:53:34 <etc_q> i'll put a a pastebin 
20:56:57 <dmj`> ah yes, the wikipedia data type
20:57:26 <etc_q> hahahah
20:57:44 <etc_q> i'm making a 
20:58:47 <etc_q> data Mat a that is equals M list(list(a))
20:59:21 <etc_q> I'm having problems on implementing a instance of a functor for this type Mat a
20:59:44 <koz_> etc_q: So you have 'data Mat a = Mat [[a]]'?
21:02:48 <etc_q> https://imgur.com/yLGaL8Z.png
21:03:30 <etc_q> yeah
21:03:55 <etc_q> 'data Mat a = M http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a'
21:03:58 <etc_q> lol
21:04:14 <monochrom> M [[1]], not Mat [[1]]
21:04:52 <etc_q> https://imgur.com/LXddXEg.png
21:04:56 <etc_q> this, sorry
21:05:29 <Axman6> that instance of functor isn't going to work properly though. don't forget you can use the Functor instance for lists to implement your Functor instance
21:05:43 <etc_q> aw
21:05:59 <etc_q> Thx
21:06:04 <Axman6> like, that code will work for exactly three shapes of matrix, and no others
21:06:15 <etc_q> yeah
21:10:28 <etc_q> I don't know how to implement either, maybe I'll take some rest
21:10:29 <etc_q> haha
21:10:38 <iqubic> koz_: You aren't a guy? What are you? An alien?
21:11:07 <Axman6> twitter definitely says he/him
21:13:44 <iqubic> Yeah, but he sent a the message: "* koz_ is not a guy." around about 20 minutes ago.
21:14:13 <MarcelineVQ> koz_ is an artful construct.
21:14:35 <MarcelineVQ> built by the best mind of a generation, I won't say which generation though
21:58:55 <iqubic> Can a haskell program write to sterr stream?
21:59:19 <iqubic> Like is there an IO action of type "(Show a) => a -> IO ()" that does this?
21:59:46 <iqubic> I'm also fine with "String -> IO ()" because I can compose that with Show myself.
22:07:02 * hackage process 1.6.8.1 - Process libraries  https://hackage.haskell.org/package/process-1.6.8.1 (MichaelSnoyman)
22:19:43 <davean> ttp://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:stderr
22:22:47 <jackdk> C://ProgramData//chocolatey//lib//ghc//tools//ghc-8.6.5//mingw//bin/ld.exe: �Ҳ��� @C:\WINDOWS\TEMP\ccWkhRFW: Invalid argument -- has anyone seen errors of this type before? seems to be a problem when building happy
22:38:18 <iqubic> :t hPrint sterr
22:38:20 <lambdabot> error:
22:38:20 <lambdabot>     • Variable not in scope: hPrint :: t0 -> t
22:38:20 <lambdabot>     • Perhaps you meant one of these:
22:38:29 <iqubic> % :t hPrint sterr
22:38:29 <yahb> iqubic: ; <interactive>:1:8: error:; * Variable not in scope: sterr :: Handle; * Perhaps you meant `stderr' (imported from System.IO)
22:38:45 <iqubic> % :t hPrint stderr
22:38:45 <yahb> iqubic: Show a => a -> IO ()
22:38:51 <iqubic> Ah. Cool.
22:41:06 <materiyolo> reee
22:41:21 <iqubic> so, print = hPrint stdout?
22:41:57 <iqubic> Yeah. It seems that way, looking at the source.
23:07:20 <iqubic> Also, withFile is a good function.
23:07:25 <iqubic> % :t withFile
23:07:26 <yahb> iqubic: FilePath -> IOMode -> (Handle -> IO r) -> IO r
23:38:45 <materiyolo> hm
23:57:24 <kenran> I'm using attoparsec for the first time and now that I'm trying to write a test for a simple parser, I'd like to check that `parse myParser "some input" @=? Done "input" MyResult`, but the Result type has no Eq instance. What should I be doing differently?
23:57:34 <kenran> Are there better ways to test the parsing?
