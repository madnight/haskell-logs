00:00:38 <iqubic> Why does lens use Endo everywhere? Isn't that the newtype wrapper for a function of type "a -> a"?
00:02:48 <mjrosenb> hrm, maybe I'm getting this because I did something wrong when I added the type for a lens?
00:03:43 <mjrosenb> https://gist.github.com/mjrosenb/9cde7c506766f3ad41015bf9757e8ec0
00:12:13 <mjrosenb> https://gist.github.com/mjrosenb/8ca275eb8282d6638db464a17ce60f13 that's the type that I specified for getRogueCellIx
00:12:23 <mjrosenb> is there a better type I should use?
00:12:43 <mjrosenb> I can't leave it untyped because ghc complains that it can't figure out the type.
00:57:22 <merijn> :O
00:57:31 <merijn> Doaitse Swierstra passed away...
00:57:50 <koz_> merijn: Woah.
01:05:14 <merijn> koz_: Yeah, that's a major bummer :\
01:31:24 * hackage extra 1.7 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7 (NeilMitchell)
01:59:40 <earthy> WHU?!
01:59:56 <earthy> he wasn't *that* old.
02:01:35 <__monty__> Uhm, that's a pretty ominous message to join the channel on...
02:08:30 <tdammers> __monty__: how else would you break the news? make some smalltalk first before bringing out the big one?
02:09:02 <isovector1> is there a quickcheck combinator like `suchThat` but that succeeds if a `Property` succeeds, rather than if a predicate does?
02:11:06 <__monty__> tdammers: I missed the news, only got the "he wasn't..."
02:11:31 <MarcelineVQ> everyone over 14 is ancient
02:11:41 <MarcelineVQ> everyone under 14 is a baby
02:12:22 <merijn> __monty__: Doaitse Swierstra passed away
02:15:39 <lhurttila> I've got lens-4.18.1 directory in my project root because I used "stack unpack lens-4.18.1, - lens >= 4.18.1 line in my package.yaml dependencies, lines - lens-4.18.1, - lens-4.18.1\examples and - lens-4.18.1\lens-properties in stack.yaml packages and stack build succeeds  on my project. For some reason stack ghci complains: failed to load
02:15:40 <lhurttila> interface for Control.Lens.Type. no unit id matching lens-4.18.1 was found (This unit ID looks like the source package ID; the real unit ID is `lens-4.18.1-6qW7qxI5Hz7CTf2DAYQ95w')  Then I've  also got makelenses '' marked as red here
02:16:35 <lhurttila> Could someone tell me what am I missing? Tried asking this on #haskell-lens but got no reply so far
02:17:30 <MarcelineVQ> those should probably be in extra-deps instead of packages
02:18:05 <lhurttila> Even though that lens version is included in the snapshot i'm using?
02:19:18 <MarcelineVQ> if you want to use the unpacked version as a dependency then add it to extra-deps     packages  is for things that are part of your package, not dependencies of your package
02:19:53 <MarcelineVQ> *that are part of your project, not dependencies
02:20:15 <MarcelineVQ> idk if that'll fix your issue but it's step 1
02:21:42 <MarcelineVQ> but just writing   - lens-4.18.1  might not be specific enough since it'll probably grab it from hackage  you might need to write   - ./lens-4.18.1  or something similar if you are going to keep the unpackged lens in your project's directory
02:22:24 <MarcelineVQ> *unpacked lens in
02:23:30 <lhurttila> MarcelineVQ Just moving those lines from packages to extra-deps in the stack.yaml did the trick. At least it builds and stack ghci doesn't complain anymore
02:24:51 <MarcelineVQ> it might be using lens from hackage when you just write  - lens-4.18.1  so you'll want to confirm that, one easy way would be to rename an important module from lens and try to rebuild your project, if it's fine then chances are it's not using your local copy
02:25:43 <MarcelineVQ> actually that's probably not enough of a test since that'll just cause examples and lens-properties to not build, hmm...
02:26:31 <MarcelineVQ> ah, well you could just rename the lens folder, and use that other folder name in extra-deps
02:26:58 <lhurttila> Tried moving the unpacked lens directory from root and got a few errors about missing files. After commenting out the lens examples and properties from the yaml it works again. 
02:27:21 <lhurttila> So I'm guessing it's using lens from stackage now?
02:27:46 <MarcelineVQ> hackage
02:28:27 <lhurttila> ok. got it . At least it seems to be working now. Thanks :)
02:28:27 <happycoder> ghci gives the type of `test (n :: (Num a, Ord a) => a) = if n > 10 then "Hello" else "World"` as `test :: (Ord a, Num a) => ((Num a, Ord a) => a) -> [Char]`. Why does ghci put two constraints here? does it matter?
02:29:14 <merijn> happycoder: That's an artifact of how you wrote it
02:29:30 <merijn> happycoder: That type annotation for n is unnecessary
02:29:48 <merijn> :t let test n = if n > 10 then "Hello" else "World" in test
02:29:49 <lambdabot> (Ord a, Num a) => a -> [Char]
02:30:05 <happycoder> merijn, i wrote it to see how it would work :)
02:30:29 <merijn> :t let test (n :: (Num a, Ord a) => a) = if n > 10 then "Hello" else "World" in test --does this even compile without extensions?
02:30:31 <lambdabot> (Ord a, Num a) => ((Num a, Ord a) => a) -> [Char]
02:31:56 <merijn> happycoder: I tried locally and that code doesn't compile without extensions
02:32:18 <merijn> happycoder: So I'm guessing one of the extensions ends up doing something funky, because that type looks like a Rank2 type
02:33:12 <happycoder> yeah it needs -XRankNTypes and -XScopedVariables
02:33:13 <merijn> Right, with no extensions it complains that you need ScopedTypeVariables enabled for that to be legal, and when you enable STV it complains you need to enable Rank2 types
02:33:28 <happycoder> yeah
02:33:32 <merijn> happycoder: And with Rank2Types that does indeed mean something different
02:34:20 <merijn> happycoder: Because that type means n must be a polymorphic value
02:34:57 <merijn> happycoder: Basically, normally the *caller* of a function gets to decide what the types of every variable must be. With RankNTypes sometimes the thing *being called* gets to decide
02:35:05 <merijn> happycoder: The simplest example of this is something like: https://gist.github.com/merijn/77e3fa9757658e59b01d
02:36:01 <merijn> The first version says "If you give me a function "a -> a" for any instance of Num, I can do my job". But that's a lie, because I could give a function "Int -> Int" and that would typecheck, but obviously can't work
02:36:39 <merijn> happycoder: The 2nd, Rank2 version says "if you give me a function "Num a => a -> a" (i.e., one that works on ALL Num instances) then I can do my job"
02:40:02 <happycoder> merijn, isn't there an implicit `forall a.` inserted by ghc in the first version?
02:40:54 * hackage jukebox 0.4.4 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.4.4 (NickSmallbone)
02:43:38 <kuribas> there is no generics for FromHttpApiData, is there?
03:19:24 * hackage gitlab-haskell 0.1.7 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.7 (RobStewart)
04:30:15 <boxscape> @pl listOfWithAcc acc x = listOfWithAcc (x:acc)
04:30:15 <lambdabot> listOfWithAcc = fix ((. flip (:)) . (.))
04:30:22 <boxscape> I didn't know that @pl supported fix
04:30:43 <boxscape> though unfortunately useless in this case since it would have to be polymorphic recursion
04:32:02 <tdammers> textbook example of "pointless style"
04:32:33 <boxscape> true
04:55:54 * hackage hw-bits 0.7.1.1 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.1 (haskellworks)
05:01:02 <boxscape> *sigh* here I am, innocently trying to write a function that takes varargs and produces an HList from them, and *once again*, just like any time I do anything, I find that I need the singletons library
05:02:53 <lyxia> "innocently" committing the crime of varargs in Haskell :P
05:09:05 <AWizzArd> Is there something like replicate for Strings, but not returning a list? I.e.  stringReplicate 2 "Hello" => "HelloHello"
05:09:42 <mpickering> Does anyone know what the point of a shake rule is which contains "alwaysRerun"? 
05:09:52 <mpickering> Why would you not just call the function rather than `use`
05:10:49 <hpc> AWizzArd: you can just join the list
05:11:11 <lyxia> AWizzArd: (concat . replicate n), Data.Semigroup.stimes
05:12:28 <AWizzArd> Yes okay, concat. I was thinking of unwords, but that extra space was undesired.
05:18:25 <astk> I have a HTML websocket example, I would like to translate it into haskell; https://www.bitstamp.net/s/webapp/examples/live_trades_v2.html
05:20:04 <astk> here is an attempt to write this in haskell; https://pastebin.com/raw/hDkkegCr
05:23:37 <boxscape> good news, I've found I don't need singletons if I just insert one unsafeCoerce :)
05:24:06 <astk40> can anyone tell why it fails to make this subscription? and could anyone help me write a version which works?
05:30:51 <Athas> Even in the glorious v2-build future, I still need to do 'cabal update' before 'cabal install', right?
05:31:22 <merijn> Athas: I think so?
05:31:32 <Uniaika> yes
05:31:53 <Uniaika> well, I think it's more `cabal new-update && cabal new-install`, Athas 
05:32:22 <Athas> I wonder how other build systems avoid this.
05:40:02 <Uniaika> Elixir doesn't have a local index, but we must specify the version for every dependency (with of course some latitude allowed, since we follow SemVer, patches and minor version upgrades do not count as bound violations)
05:42:51 <tdammers> Athas: I don't think you can fully avoid it - the local build system needs *some* way of discovering remote packages, and doing it on the fly is just not a super great idea
05:43:07 <tdammers> you could automatically refetch before each build, but that would actually be a bit bad
05:43:37 <tdammers> because it means that when for some reason the new solution turns out to not work, your project will become unbuildable through absolutely no action of your own
05:43:52 <Athas> tdammers: doesn't Rust just do it on the fly?
05:44:17 <tdammers> Athas: no idea. Never looked into it.
05:44:18 <Athas> I really like pain so I'm once again looking at Haskell packages in Homebrew, and I get depressed when I see how much smoother it is for other languages.
05:44:32 <srk> Athas: well you don't have to cabal install at all, just use nix to build environments
05:44:44 <tdammers> point in case, most other languages are more handwaivy about what "compatible" means
05:44:53 <tdammers> haha, "just"
05:45:24 <merijn> tdammers: Yeah, it's almost funny how casually Nix fans throw that sorta thing out :)
05:46:11 <srk> well it's just e.g. nix-shell -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [ cryptonite ])"
05:49:58 <Athas> I don't think the Homebrew maintainers would like that solution.
05:50:22 <merijn> srk: You're skipping over all the steps needed to get that command to run
05:50:44 <merijn> Athas: Does it auto update if you specify an explicit index in your cabal.project?
05:50:59 <srk> merijn: installing nix or nixos? neither is hard 
05:51:02 <Athas> merijn: doesn't look like it.
05:51:28 <merijn> srk: Hah, yes it is
05:52:21 <srk> how come? :) if you don't have nix packaged you can curl | bash "install" it 
05:52:30 <srk> nixos installation is like 5 commands as well
05:52:38 <srk> maybe 10!
05:52:49 <srk> if you also do luks and lvm :D
05:52:53 <merijn> srk: Sure, if you have root and all the dependencies are already present
05:53:05 <merijn> srk: And happen to be on a well supported system...
05:53:12 <srk> root is just an unshare away
05:53:56 <merijn> srk: And now we're already 3-4 steps in deep and not done yet
05:54:40 <srk> well IMO it's worth it even if it would take few days of compiling or so :)
05:54:58 <boxscape> hmm do you really need root to install nix? (if you don't need any other dependencies)
05:55:05 <srk> not really
05:55:20 <merijn> srk: That's not a process that's worth it to users though, so they will just skip and ignore your software
05:55:35 <merijn> boxscape: You do, because it requires /nix, which requires root to make
05:55:42 <srk> boxscape: I'm now running namespaced nix-daemon as part of hnix-store-remote tests so it thinks it runs as root
05:55:46 <merijn> boxscape: You can use a different store path, but then you need to compile from source
05:55:50 <boxscape> I see
05:55:52 <srk> boxscape: you can also run with arbitrary paths not just /nix
05:55:57 <srk> but you loose caching 
05:56:05 <boxscape> interesting
05:56:11 <merijn> srk: You can't with the binary distribution, only with source builds
05:56:12 <srk> there's support for faking /nix/store in dirs iirc
05:56:22 <srk> chroot stores
05:56:24 <srk> yeah
05:56:51 <srk> hah https://github.com/nix-community/nix-user-chroot
05:57:09 <srk> as I've said, root is just an unshare away :D
05:57:21 <merijn> srk: That require unshare to work
05:57:50 <merijn> srk: I've looked at that repository too, it doesn't work either on a bunch of systems I use.
05:58:00 <srk> ah, what kind of systems are that?
05:58:17 <merijn> srk: Clusters, shared compute servers, etc.
05:58:47 <srk> but do you need nix everywhere? you could use nix to build static binaries for these if they are not some weird arches
05:58:54 * hackage ribbit 1.1.0.0 - Type-level Relational DB combinators.  https://hackage.haskell.org/package/ribbit-1.1.0.0 (taphu)
05:59:15 <merijn> srk: I can't build locally because I don't have the tools nor hardware to compile my stuff
05:59:46 <srk> well that's problematic :) is the codebase so large?
06:00:09 <merijn> srk: No, as in, FPGAs, GPUs, etc.
06:00:20 <srk> yeah
06:00:41 <srk> I only do open FPGA toolchains :) 
06:01:09 <srk> spartan 6 in novena might force me to use xillinx ISE as well /o\
06:01:11 <merijn> Those are non-existent for FPGAs of meaningfull size :)
06:01:28 <srk> well for ecp5 
06:01:46 <srk> that's pretty decently sized
06:03:47 <kuribas> is there no generics for FromHttpApiData?
06:03:57 <kuribas> for servant parameters?
06:13:10 <merijn> Time for a little known feature PSA: Did you know you can use packdeps as an RSS feed to notify when your package's dependencies release newer versions that your bounds don't support?
06:13:34 <kuribas> I didn't
06:14:23 <merijn> kuribas: https://packdeps.haskellers.com/feed?needle=broadcast-chan see the "view this information as news feed" link :)
06:17:27 <John_Ivan> sigh. have you ever tried to learn something, know what to do but don't know at the same time?
06:19:26 <John_Ivan> it's rather depressing.
06:19:59 <unclechu> hey, what do you usually use for making kind of void constraints? like if you have type family `Elem` (as term-level function `elem`) and you found an element in the list?
06:20:08 <unclechu> i usually use something like `x ~ x` as a dummy plug (or `() ~ ()`)
06:20:20 <unclechu> but maybe there's better and less confusing way to do so?
06:20:28 <unclechu> like for this pattern `ElemOf x (x ': xs) = x ~ x`
06:20:34 <boxscape> unclechu just use ()
06:20:59 <boxscape> % () :: Constraint
06:20:59 <yahb> boxscape: ; <interactive>:233:1: error:; * Couldn't match expected type `Constraint' with actual type `()'; * In the expression: () :: Constraint; In an equation for `it': it = () :: Constraint
06:21:10 <boxscape> % :k () :: Constraint
06:21:10 <yahb> boxscape: ; <interactive>:1:4: error: parse error on input `::'
06:21:14 <boxscape> god dammit
06:21:48 <unclechu> boxscape: dam, thanks, and why i thought this wouldn't work ðŸ¤”
06:22:19 <boxscape> unclechu it's not obvious that () can be a Constraint, considering it's usually either a () or a Type
06:35:05 <merijn> Whoo! Build failures in my tests because of missing upperbounds in my dependencies >.>
06:38:56 <sshine> % :k Constraint
06:38:57 <yahb> sshine: Constraint :: Type
06:39:50 <sshine> boxscape, is that () as in the empty set of constraints?
06:39:54 <boxscape> yes
06:40:01 <boxscape> or an empty Tuple I suppose
06:40:55 <boxscape> % :t () :: () => ()
06:40:55 <yahb> boxscape: ()
06:41:10 <sshine> heh
06:44:06 <lhurttila> Any lens masters online? I got a tricky problem with modifying fields of  a nested custom data type according to its' indices: https://stackoverflow.com/questions/60545053/how-to-modify-fields-of-a-nested-custom-data-type-with-lenses-when-modification
06:49:43 <AWizzArd> I would like to install https://github.com/haskell/haskell-ide-engine via nix. It links to a page that offers as one option to use `cachix use all-hies`. Would this operation install all versions on my system? A bit below it warns (in a different section) that all versions may consume 30 GBs.
06:50:33 <boxscape> AWizzArd https://github.com/infinisil/all-hies/ has some instructions on how you can install it for only some versions
06:50:52 <boxscape> more specifically here https://github.com/infinisil/all-hies/#declarative-installation-nixos-home-manager-or-similar
06:55:55 <infinisil> AWizzArd: cachix just allows you to use the prebuilt caches, you also need to install it with the instructions boxscape linked
07:11:36 <mjrosenb> https://gist.github.com/mjrosenb/8ca275eb8282d6638db464a17ce60f13 -- I assume I specified a more specific type than I needed to here, since this is causing...
07:12:09 <mjrosenb> https://gist.github.com/mjrosenb/9cde7c506766f3ad41015bf9757e8ec0
07:13:00 <mjrosenb> is there a better type that I should be using there? (I got that by using a type hole, and copying what ghc told me the type was)
07:15:12 <exarkun> I have a Warp onException handler that is getting an error about transaction misuse with sqlite3 from, presumably, some of my application code.  but the scope here is pretty broad and apart from "near the database" I don't have much idea about where the problem is.  is there some approach I can use to get some more information here?
07:21:55 <mjrosenb> ugh, so I had to specify a type when defining that variable because the compiler couldn't determine the type itself
07:22:35 <mjrosenb> so I can only assume that the fact that I want to use the variable in two places with two different types is related.
07:22:55 <mjrosenb> since I can't specify either individual type and have it work in both places.
07:23:55 <AWizzArd> boxscape: yes, I saw exactly that page to which you linked. But I wonder: what exactly is this cachix solution doing?
07:24:16 <AWizzArd> boxscape: is it the same as the nix-env installation, listing all 190 different versions?
07:24:24 * hackage clash-prelude 1.2.0 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-1.2.0 (QBayLogic)
07:24:29 <boxscape> infinisil that's a question for you I think
07:25:15 <infinisil> AWizzArd: The cachix part is optional and doesn't install anything
07:25:24 * hackage clash-ghc 1.2.0, clash-lib 1.2.0 (QBayLogic): https://qbin.io/exceed-beach-79lz
07:25:26 <infinisil> AWizzArd: The installation section is doing the installation
07:25:36 <AWizzArd> I wonder if this `cachix use all-hies` is the same as   nix-env -iA selection --arg selector 'p: { inherit (p) ghc864 ghc863 ghc843; }' -f https://github.com/infinisil/all-hies/tarball/master
07:25:54 <infinisil> If you want to use cached binaries, so you don't have to compile everything yourself, you need to do `cachix use all-hies` before the installation
07:25:54 <AWizzArd> But instead of just ghc864/863 and 843 it implicitly puts in all versions there.
07:26:35 <AWizzArd> So the cachix command will change some state on my system, so that the following nix-env call will now load pre-compiled binaries?
07:26:41 <infinisil> Yup
07:26:45 <AWizzArd> It is doing some kind of configuration. I see.
07:27:04 <AWizzArd> I have to run the nix-env -i command anyway, but it will either give me pre-compiled binaries or not.
07:27:10 <infinisil> Exactly
07:27:11 <AWizzArd> Okay, got you!
07:27:48 <argent0> lhurttila: It's still not clear what you are intending to do. But it seemds you want something like: `setConnections = map setSingleConnection`
07:27:54 <infinisil> AWizzArd: If you do want all versions, even though it takes a lot of space, you can set the selector do `--arg selector 'p: p'`
07:27:55 <lyxia> mjrosenb: how did (First ...) get in there? maybe it can be a variable with suitable constraints?
07:27:59 <infinisil> s/do/to
07:32:37 <lhurttila> argent0 The point ultimately is to somehow add every Typex from the next [Typex] in [[Typex]] as a connection of the Typex being modified
07:33:07 <Guest_56> is it OK to ask questions about Stack here?
07:34:14 <boxscape> yes
07:35:21 <argent0> lhurttila: then that sounds like a fold (probably on the reversed list)
07:37:54 <lhurttila> argent0 Could be but I have no idea hot to implement it when the connections of each Typex depend on indices like I wrote before.
07:38:24 * hackage casa-client 0.0.0 - Client for Casa  https://hackage.haskell.org/package/casa-client-0.0.0 (ChrisDone)
07:41:33 <argent0> lhurttila: you can start with custom recusion: `go current (next:rest) = [current.level + 1, conns] where cons = [x,y = 0..length of next]
07:42:14 <argent0> then handle the csae `go current []` and finally. `setConnections = go`
07:42:39 <Guest_56> I'm newbie trying to learn the ropes, my stack installation keeps using wrong ghc version in spite of me setting system-ghc: true in .stack/config.yaml
07:42:57 <Guest_56> ~/.stack/config.yaml of course
07:43:26 <Guest_56> Details are here: https://stackoverflow.com/questions/60548776/stack-keeps-using-wrong-ghc-version
07:43:34 <merijn> Guest_56: The idea behind stack is to let the project dictate which GHC version is used
07:43:40 <merijn> Or rather, the snapshot
07:44:54 * hackage casa-types 0.0.0 - Types for Casa  https://hackage.haskell.org/package/casa-types-0.0.0 (ChrisDone)
07:46:26 <Guest_56> well stack doesn't want to use project specific version (set by "resolver" I guess?), see the details in https://stackoverflow.com/questions/60548776/stack-keeps-using-wrong-ghc-version
07:46:54 * hackage replace-megaparsec 1.3.0.0 - Find, replace, and edit text patterns with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.3.0.0 (JamesBrock)
07:47:25 <monadin> is it common practice to define your data types at the top of your module then define all your functions below?
07:47:37 <merijn> monadin: It's not uncommon
07:48:21 <monadin> ok it looks nicely organized that way imo
07:49:04 * argent0 is is not not not uncommon
07:49:40 <merijn> Guest_56: It does seem touse the project version, since lts-15 is 8.8.2 according to the internet
07:53:14 <lhurttila> argent0 Thanks for the idea. I'll try get somewhere with that.
07:53:44 <merijn> Guest_56: also, your SO question says "that's the only GHC available", but that's not true, stack installs it's own copies of GHC
07:56:43 <argent0> lhurttila: `go (current:next:rest) = ... ++ go (next:rest)`. Quite non performant but a simple starting point.
07:57:02 <foobar88> @help
07:57:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:03:58 <merijn> Guest_56: oh, btw, I found another SO question that answers your problem
08:04:09 <merijn> Guest_56: https://stackoverflow.com/a/44462470
08:04:23 <merijn> Guest_56: So stack can *only* use your system GHC *if* it matches the resolver's GHC
08:10:04 <lhurttila> argent0 meaning that would be quite slow?
08:11:06 <boxscape> % case [] of _:_@xs -> ()
08:11:06 <yahb> boxscape: ; <interactive>:256:15: error: parse error on input `@'
08:11:09 <boxscape> why is this a parse error
08:11:11 <boxscape> when this works
08:11:15 <boxscape> % case [] of _:ys@xs -> ()
08:11:15 <yahb> boxscape: ; <interactive>:257:12: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: _ : ys@xs -> ...; *** Exception: <interactive>:257:1-24: Non-exhaustive patterns in case
08:12:17 <lhurttila> argent0 I don't need this operation to be very fast but i'll be doing lots of operations on those connections eventually so using lists is probably a bad idea. I'll probably have to change to something else later but they'll do for now
08:12:36 <hyperisco> boxscape, _ is not a valid binder name
08:12:54 <boxscape> But I'm not trying to bind anything, I'm trying to use it as a wildcard
08:13:04 <hyperisco> well lets try that more deliberately
08:13:14 <hyperisco> % case [] of _:(_@xs) -> ()
08:13:15 <yahb> hyperisco: ; <interactive>:259:16: error: parse error on input `@'
08:13:23 <hyperisco> nope
08:13:26 <argent0> lhurttila: yes, m ++ n is O(length m). And that is just one step in `go`. In total that would be O(n_input_list**2)
08:13:42 <hyperisco> well it doesn't matter what you're trying to do, it just matters what the parser thinks you're trying to do ;)
08:13:49 <boxscape> that's fair
08:14:10 <hyperisco> if you want to bind _:_ then it is xs@(_:_)
08:14:25 <tdammers> I suspect that the part left of the @ is supposed to be a name that you bind to - _@ simply doesn't make any sense
08:14:48 <hyperisco> % case [] of _:(_ys@xs) -> ()
08:14:49 <yahb> hyperisco: ; <interactive>:260:12: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: _ : (_ys@xs) -> ...; *** Exception: <interactive>:260:1-27: Non-exhaustive patterns in case
08:14:59 <argent0> lhurttila: haskell performance is tricky
08:15:04 <tdammers> _@xs would basically mean "pattern-match on xs, and also bind the entire match to no identifier
08:15:05 <argent0> plan ahead
08:15:06 <hyperisco> seems if we give it some alpha then it works, so _ is probably a special case in the parser
08:15:08 <boxscape> okay got it, I had the precedence of @ and : reversed
08:15:45 <tdammers> xs@(_:ys) -- is how I'd write it, probs
08:16:53 <lhurttila> argent0 right. I might need to use vectors eventually because i'll have to modify lots of connections all around
08:18:54 * hackage replace-megaparsec 1.3.1.0 - Find, replace, and edit text patterns with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.3.1.0 (JamesBrock)
08:20:31 <newb> is map k v equivalent to using a list comprehension where we run each x through a function?
08:21:13 <merijn> newb: Yes
08:21:24 <merijn> Or rather, I would say the reverse :p
08:21:43 <newb> ill have to think about that one haha
08:21:52 <merijn> newb: Note that Haskell has list comprehensions too (although they're rarely used)
08:22:05 <merijn> newb: In fact, Python's list comprehensions were inspired by/copied from Haskell :p
08:23:08 <newb> @merijn im surprised that they are rarely used I find them to be the coolest and most useful thing ever coming from Java
08:23:09 <lambdabot> Unknown command, try @list
08:23:36 <e> in haskell there's usually a nicer way to spell it
08:23:44 <boxscape> newb they're rarely used because everything else in Haskell is also the coolest and most useful thing ;)
08:24:01 <merijn> newb: Usually some other function is used (like map and filter) because they're more composable
08:24:18 <newb> gotcha
08:25:19 <boxscape> where did list comprehensions come from? Miranda?
08:25:44 <dminuoso> boxscape: Mathematics.
08:25:45 <merijn> boxscape: Set notation in math, but I dunno if some other language implemented them before Haskell
08:25:56 <dminuoso> boxscape: They are a visual mimicry of set builder notation
08:26:01 <dmj`> python and haskell came out around the same time
08:26:11 <dminuoso> dmj`: Im fairly confident that python modelled them after Haskell.
08:26:25 <dmj`> dminuoso: that wouldn't surprise me
08:26:26 <boxscape> right I'm aware they're inspired by sets
08:26:51 <merijn> dmj`: But did that first python version include list comprehensions? :p
08:26:59 <boxscape> oh python is older than I though
08:27:00 <boxscape> t
08:27:01 <dminuoso> https://en.wikipedia.org/wiki/List_comprehension suggests that SETL came up with it
08:27:08 <dminuoso> It has quite a bit on the history subject.
08:27:15 <dminuoso> But sadly its missing references. :(
08:27:43 <dminuoso> The article suggests that Haskell just copied it from Miranda indeed.
08:27:54 <dmj`> merijn: "breaking news, haskell influenced by python"
08:28:40 <boxscape> haskell is in fact listed under the "influenced by" section on the python wiki page :)
08:28:46 <merijn> Looks like Python got them in Python2.x, so in the 2000s
08:29:09 <merijn> boxscape: Another fun one: Java's immutable strings come from python :p
08:29:27 <boxscape> interesting
08:30:22 <tdammers> point in case, going from comprehension-style set definition syntax in math to list comprehensions in haskell isn't a huge leap
08:30:51 <veryconfuses> is it worthwhile to understand GHC assembly code?
08:31:00 <boxscape> (I said that too for a while but it's actually "case in point")
08:31:09 <Zemyla> I thought about how to label containers with unique identifiers on each value, depending on what constraints you have available.
08:31:10 <merijn> veryconfuses: Define worthwhile? And define why you'd be interested :p
08:31:30 <Zemyla> @let newtype UniqueCounter c = UniqueCounter { runUniqueCounter :: forall a s t. (Eq a, c a) => (forall f. Applicative f => (a -> f (Int, a)) -> s -> f t) -> s -> (Int, t) }
08:31:32 <lambdabot>  Defined.
08:31:53 <Zemyla> @let class UniqueCounting c where uniqueCounter :: UniqueCounter c
08:31:55 <lambdabot>  Defined.
08:32:02 <veryconfuses> worthwhile meaning you can do powerful things by understanding it. why would I be interested? no idea
08:32:29 <tdammers> boxscape: "point in case" is so common by now that calling it incorrect borders on language prescriptivism :)
08:32:55 <geekosaur> the assembly language isn't so interesting unless you're also studying the STG
08:33:15 <boxscape> fair, I only said it because I was surprised when I found out, not to prescribe usage
08:33:48 <geekosaur> "case in point" is how I learned it, and I've only seen it the other way a few times
08:34:19 <guhh> i am so angry beacuse this community is promoting racism
08:34:21 <veryconfuses> as long as nobody is saying "I could care less" im happy
08:34:27 <Zemyla> You'd call it with "runUniqueCounter @Eq uniqueCounter traverse ls" or Ord or such.
08:35:10 <dminuoso> veryconfuses: GHC does not produce assembly, mind you.
08:35:11 <dminuoso> But.. I guess that's a silly argument. Nevermind me.
08:36:27 <guhh> i find that arousing that innocent jew children are screaming in terror in a gas chamber while they are being gassed to death by nazis!
08:36:34 --- mode: ChanServ set +o geekosaur
08:36:46 <guhh> sieg heil!
08:37:04 <boxscape> @ops
08:37:04 <lambdabot> Maybe you meant: pl oeis docs
08:37:11 <boxscape> I meant something but not that
08:37:13 <ChaiTRex> dminuoso: Can't it with ghc -S?
08:37:18 <guhh> burn all jews in ove !!!
08:37:40 --- mode: geekosaur set -o geekosaur
08:37:45 <merijn> boxscape: You probably meant "@where ops", but I think geekosaur is already trying to remember how to effectively kick+ban :p
08:37:56 <boxscape> Ah, thank you
08:38:12 * geekosaur was waiting for one more comment which sigyn then responded too (figured he was hitting more than just #haskell)
08:38:35 <geekosaur> also I'm on the blergh webchat interface
08:39:53 <geekosaur> dunno whether ghc generates .o directly or .s these days, to be honest. despite the option being called -fasm
08:40:52 <merijn> hmm, in conduit is there a convenient way to intersperse "every N elements"?
08:41:22 <geekosaur> if it's generating object files directly then it probably doesn't provide asm level output except in debugging mode, which may not be useful as asm source
08:41:56 <geekosaur> but in any case the asm is mostly STG operations translated directly, noting clever in and of itself
08:44:10 <geekosaur> the rest of the asm is translated cmm, which is mostly ghc primitives. those may be of interest but are probably more so at cmm level than asm
08:53:25 --- mode: ChanServ set +q *!~ydgfdhh@*.elisa-mobile.fi
08:54:41 <Guest_56> merijn: thank you!
08:56:22 <wachin> Im not sure I you guys are familiar with learn you a haskell but In the section on type synonyms there is an example where we use "type LockerMap = Map.Map Int (LockerState, Code) 
08:56:42 <wachin> what is the Map.Map Int (LockerState,Code) doing?
08:57:27 <wachin> It doesn't make sense to me that we could map "Int" onto anything
08:58:08 <int-e> Map.Map k v  is a type for finite maps indexed by k (so those are the keys) mapping to v (values).
08:59:17 <wachin> ok so were referring to index numbers but It still doesn't make sense to me that you could map "Int" because Int is a type not a function
08:59:30 <int-e> > M.fromList [(42,world"), (1,"hello"), (23,"cruel")]
08:59:32 <lambdabot>  <hint>:1:52: error:
08:59:32 <lambdabot>      lexical error in string/character literal at end of input
08:59:46 <int-e> > M.fromList [(42,"world"), (1,"hello"), (23,"cruel")]
08:59:48 <lambdabot>  fromList [(1,"hello"),(23,"cruel"),(42,"world")]
09:00:02 <boxscape> wachin Map.Map has basically nothing to do with map
09:00:09 <int-e> > let m = M.fromList [(42,"world"), (1,"hello"), (23,"cruel")] in (m `M.lookup` 23, m `M.lookup` 24)
09:00:12 <lambdabot>  error:
09:00:12 <lambdabot>      â€¢ Could not deduce (Ord k0)
09:00:12 <lambdabot>        from the context: (Ord k, Ord k2, Num k, Num k2,
09:00:22 <int-e> meh.
09:00:35 <wachin> @boxscape ok that would add up haha
09:00:35 <lambdabot> Unknown command, try @list
09:00:36 <hyperisco> wachin,  Int -> Char  is a map of Int to Char and  Map Int Char  is a map of Int to Char. Two maps, different representations
09:01:12 <int-e> > let m = M.fromList [(42,"world"), (1,"hello"), (23,"cruel")] in (M.lookup 23 m, M.lookup 24 m)
09:01:14 <lambdabot>  (Just "cruel",Nothing)
09:02:25 <int-e> wachin: In mathematics, "map" is a synonym for "function". Computer science borrowed that term for data structures that map keys to values.
09:03:04 <boxscape> wachin on a conceptual level, a Map is very similar to an association list, i.e. a list of pairs, like int-e has been using to create Maps (e.g. [(1, "foo"), (5, "bar")]), so each entry associates some key (in this case an Int) to some value (in this case a String)
09:04:00 <boxscape> s/to/with
09:04:35 <wachin> I see. So in this particular case were using map to provide index numbers?
09:05:00 <wachin> Oh it just clicked I get it thanks
09:16:29 <Zemyla> Unpopular opinion: The only functions from Data.Map you need are mergeWithKey and alterF.
09:17:45 <boxscape> how do you look up values in the map?
09:20:42 <ChaiTRex> boxscape: You just use Foldable to look up the key.
09:21:56 <davean> or f is Writer
09:22:36 <idnar> you can lookup with alterF
09:23:52 <boxscape> ah, that makes snese
09:23:54 * hackage casa-types 0.0.1 - Types for Casa  https://hackage.haskell.org/package/casa-types-0.0.1 (ChrisDone)
09:24:54 * hackage casa-client 0.0.1 - Client for Casa  https://hackage.haskell.org/package/casa-client-0.0.1 (ChrisDone)
09:26:57 <idnar> :t M.lookup
09:26:57 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
09:30:03 <idnar> :t M.alterF
09:30:05 <lambdabot> (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> M.Map k a -> f (M.Map k a)
09:38:53 <idnar> :t \k -> M.alterF Const k
09:38:55 <lambdabot> Ord k => k -> M.Map k a -> Const (Maybe a) (M.Map k a)
09:39:40 <idnar> :t \k -> getConst . M.alterF Const k
09:39:41 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
09:43:54 * hackage org-mode 1.0.0 -   https://hackage.haskell.org/package/org-mode-1.0.0 (fosskers)
09:44:54 * hackage org-mode-lucid 1.0.0 -   https://hackage.haskell.org/package/org-mode-lucid-1.0.0 (fosskers)
09:45:57 <idnar> :t \k v -> runIdentity . M.alterF (\_ -> Identity (Just v)) k
09:45:58 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
09:53:24 <solonarv> idnar: 'alterF k' is a Lens (in the sense of the 'lens' package), you've rediscovered the 'view' and 'set' operations
09:53:47 <solonarv> ('view' is the one using 'Const', 'set' the one using 'Identity')
09:54:24 * hackage homplexity 0.4.8.0 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.8.0 (MichalGajda)
09:54:37 <dsal> Is there a convenient way to have a list of functions I want to test for equality on two inputs?  I want    [f, g]   such that (f a == f b) and (g a == g b).     f is  (a -> b) and g is (a -> c)
09:54:40 <dsal> I feel like there should be a way to do this.
09:55:40 <solonarv> dsal: maybe if you use some sort of heterogenous list?
09:56:24 <solonarv> using vinyl you could write this as: f :& g :& RNil :: Rec ((->) a) '[b, c]
09:59:13 <dsal> Hmm...  That isn't super pretty.  heh
09:59:57 <merijn> dsal: Hasochism is never pretty :p
10:00:04 <solonarv> maybe you can also write it as something like: xrec (g, h)
10:00:15 <solonarv> s/g, h/f, g/
10:00:19 <dsal> Just hit one of those conditions where the type system kind of slows me down.  The way I'm using this, [f, g] makes sense, other than the part where I can't say what the type of f and g are.
10:02:10 <dsal> My list has five functions in it.  The actual thing I'm doing is passing two values to each function and comparing them with ==.  I need some kind of type wrapper that is like   :: Eq a => (t -> a) -> t -> t -> Bool    But then I still have that a floating around.
10:02:59 <dsal> (in the meantime, I just have a list of   [f i == f i', g i == g i', ...]
10:04:41 <solonarv> % eqs f x y = f x == f y
10:04:41 <yahb> solonarv: 
10:04:45 <solonarv> % :t eqs
10:04:45 <yahb> solonarv: Eq a => (t -> a) -> t -> t -> Bool
10:05:19 <solonarv> % :set +t
10:05:19 <yahb> solonarv: 
10:06:13 <solonarv> % [eqs $ (`mod` 2) . ord . head, eqs read]
10:06:13 <yahb> solonarv: ; <interactive>:265:1: error:; * No instance for (Show ([Char] -> [Char] -> Bool)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
10:06:14 <ski> @type comparing
10:06:16 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:06:23 <solonarv> % :t [eqs $ (`mod` 2) . ord . head, eqs read]
10:06:23 <yahb> solonarv: [[Char] -> [Char] -> Bool]
10:06:49 <solonarv> dsal: does that look about right? (please ignore the silly examples I chose)
10:06:55 <ski> @let equating :: Eq a => (b -> a) -> (b -> b -> Bool); equating f = (==) `on` f
10:06:57 <lambdabot>  Defined.
10:07:06 <ski> dsal : like that ^ ?
10:08:38 <ski> oh, heterogenous
10:08:54 <dsal> Yeah, e.g.   ("a", 1) and my functions are [fst, snd]
10:09:07 <ski> i suppose you can still manually say `[equating f,equating g,...]'
10:09:54 * hackage launchdarkly-server-sdk 1.0.1 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-1.0.1 (launchdarkly)
10:10:41 <dsal> % let a = ("a", 1) in   all (\f -> f a a) [equating fst, equating snd]
10:10:41 <yahb> dsal: ; <interactive>:267:42: error: Variable not in scope: equating :: ((a0, b0) -> a0) -> ([Char], Integer) -> ([Char], Integer) -> Bool; <interactive>:267:56: error: Variable not in scope: equating :: ((a1, b1) -> b1) -> ([Char], Integer) -> ([Char], Integer) -> Bool
10:10:51 <dsal> >  let a = ("a", 1) in   all (\f -> f a a) [equating fst, equating snd]
10:10:53 <lambdabot>  True
10:11:26 <dsal> % let a = ("a", 1) in   all (\f -> f a a) [eqs fst, eqs snd]
10:11:27 <yahb> dsal: True; it :: Bool
10:11:33 <dsal> Neat.  Thanks.
10:12:41 <dsal> I thought I'd tried the thing solonarv suggested, but I probably had another bug along the way.  The annoying part is that my test isn't failing.
10:14:47 <solonarv> my 'eqs' is exactly the same as 'equating', btw
10:14:53 <solonarv> I just picked a shorter name for it ;)
10:14:55 <ski> yep
10:15:02 * ski only noticed, after the fact
10:16:32 <dsal> Yeah, makes sense.  I don't think `on` comes to mind quickly enough.
10:19:24 * hackage aeson-value-parser 0.17 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.17 (NikitaVolkov)
10:22:49 <dsal> Oh wait.  My test is failing.  yay
10:50:28 <fres> is there a similar command in ghci like :t but for types...for instance if I wanted to see what an Int was I can't say :t Int
10:51:33 <geekosaur> the "type of a type" is a kind, and there's :kâ€¦ but I don't think that's what you're asking about
10:51:37 <geekosaur> :k Int
10:51:39 <lambdabot> *
10:52:05 <geekosaur> hm, these days that probably ought to say "Type"
10:52:19 <geekosaur> % :k Int
10:52:19 <yahb> geekosaur: Int :: Type
10:52:32 <fres> what does the * mean?
10:52:51 <opqdonut> * is the old/traditional syntax for Type
10:52:52 <geekosaur> it's the kind of inhabited types (types with values)
10:53:00 <e> did haskell grow cumulative universes while i wasn't looking?
10:53:39 <geekosaur> but it's going away since we have type operators now and it's painful for * to be both a kind and (part of) a type level operator
10:54:48 <fres> so is there anyway to see how Int is defined?
10:55:07 <geekosaur> not in ghci as such, except :i if you have the right module loaded
10:55:21 <geekosaur> lambdabot has @src, but I'mm not sure that would help you much either
10:55:22 <fres> ok thanks
10:55:26 <geekosaur> @src Int
10:55:26 <lambdabot> data Int = I# Int#
10:55:49 <geekosaur> (which uses a manually curated database, not a search through source code, so it can tell lies or be out of date)
10:56:50 <geekosaur> you need the MagicHash extension for that declaration to be legal. it basically says an Int is a wrapper around a signed machine word; the types (and values) with #s in them are generally primitive machine types
10:57:02 <geekosaur> so this is a ghc implementation detail
11:01:37 <geekosaur> http://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.13.0.0/GHC-Exts.html#t:Int if you really care.
11:06:39 <fres> @geekosaur thanks really appreciate the link
11:06:39 <lambdabot> Unknown command, try @list
11:14:24 * hackage servant-pagination 2.3.0 - Type-safe pagination for Servant APIs  https://hackage.haskell.org/package/servant-pagination-2.3.0 (KtorZ)
11:16:32 <madnight> What is an good example for a Functor that is full but not faithful?
11:24:40 <dmwit> madnight: The distinguished functor 2 -> 1
11:26:09 <dmwit> (Indeed, take any category C which is not already isomorphic to 1 and the induced functor from C to 1.)
11:27:23 <madnight> Okay that makes sense, thx
11:27:35 <dmwit> For faithful but not full, go the other way. 1 -> C for any non-1 C
11:29:59 <madnight> So a full Functor in C is faithful in Cop
11:30:15 <Nolrai> So I have been trying out small check and have had real trouble.
11:30:40 <Nolrai> "in C"?
11:31:15 <madnight> Nolrai: in a category C
11:31:25 <ski> functors go between categories
11:31:48 <remexre> is there a guide to what GHC.TypeLits.KnownNat (Log2 (_)) can be solved?
11:32:02 <remexre> I've got one that should be solvable that isn't
11:32:06 <remexre> (with all the Clash solvers)
11:32:42 <madnight> ski: But there are categories where functors are objects
11:32:57 <Nolrai> The issue I am having is that the number of items per depth goes like: [0,0,108,200000..
11:33:12 <madnight> ski: and arrows are natural transformations
11:33:18 <idnar> solonarv: yeah I tried to inline view/set but I couldn't reduce the crazy coercions
11:33:21 <ski> yes, madnight, but your functors went between `C' and other categories, i thought
11:34:11 <Nolrai> which means that depth 3 takes 0.01 seconds and depth 4 takes 5 minutes. This is not ideal.
11:34:11 <ski> if you have a functor that's an object in `C', that means `C' is something like `E^D', for two categories `D' and `E'
11:34:54 <Nolrai> Is there a solution or should i just scrap smallcheck and use quickcheck instead or what?
11:35:14 <madnight> ski: so what's Cop then? D^E right?
11:35:24 <idnar> I'm not used to working with Profunctor
11:35:43 <Nolrai> Nope. Op is the identity on objects.
11:36:00 <Nolrai> ^ madnight
11:36:54 <madnight> Nolrai: well I talk about the opposite category
11:37:26 <ski> you've have "reverse natural transformations", i suppose
11:37:49 <Nolrai> Right, D^E has different objects then E^D so its not (E^D)^op
11:38:24 <ski> if `F : D >---> E', then `F^op : D^op >---> E^op'
11:38:38 * ski twitches
11:38:47 <Nolrai> I don't think so..
11:39:28 <ski> `^op', when acting on 2-morphisms, turns them around
11:39:47 <madnight> ski: yup that's my point, and thus we go from full to faithful
11:39:53 <Nolrai> Yes but I don't think the D and E get opped.
11:40:08 <Nolrai> Oh, wait..
11:40:13 <Nolrai> Uh..
11:40:15 <Nolrai> ow.
11:40:27 <ski> `C |-> C^op' is "just" a functor on `Cat'
11:40:37 <ski> however, it's contravariant on 2-morphisms
11:41:39 <ski> so, if `F,G : D >---> E' and `eta : F >---> G', then `eta^op : G^op >---> F^op', iirc
11:42:06 <Nolrai> Ah.
11:42:12 <Nolrai> I think that makes sense.
11:42:37 <Nolrai> Talking about category theory applied to category theory always gets me confused.
11:44:08 <ski> so, for any `A : D^op', `(eta^op)_A : G^op A >---> F^op A' in `E^op', which corresponds to `eta_A : F A >---> G A' in `E'
11:45:24 <ski> (`A : D^op' expressing the same thing as `A : D', since `^op' does nothing on objects)
11:49:34 <ski> madnight : hmm .. maybe this means `(E^D)^op' is `(E^op)^(D^op)', then ?
11:51:07 <madnight> ski: uhh that might be, I thought it would be D^E
11:52:52 <ski> pick `D' as `1' and `E' as `0'. then `E^D' is `0', whose opposite category is also `0', but `D^E' is `1' whose opposite is `1'
11:54:16 <ski> (also `D' and `E' are self-opposite)
11:54:49 <catern> what happens in the haskell runtime if I do a readFile, read part of the file so that it opens the file and leaves it open, and then do a lot more readFile calls such that I run out of file descriptor numbers? will the runtime start forcing the earlier readFiles so it can close the files? (asking optimistically, that would be really cool if it does)
11:58:05 <nshepperd2> probably not
11:59:38 <madnight> ski: buy AFAIK the opposite category is the category with all the arrows reversed, and when the arrows are natural transformations, because we are dealing with a category where functors are objects, then these natural transformations should be reversed, shouldn't they?
12:00:49 <Nolrai> @pl f x = h x && g x
12:00:50 <lambdabot> f = liftM2 (&&) h g
12:01:15 <madnight> *but
12:02:34 <dmj`> catern: it definitely won't do that
12:03:15 <solonarv> e: no, the tower is cut short by the Type :: Type axiom, so we don't have cumulative universes in GHC Haskell
12:03:26 <nshepperd2> readFile is basically a loop of unsafeInterleaveIO and read so there's no way for the RTS to know how to do that
12:03:37 <catern> alas - but wait I guess I can ask the same question for memory management - if I have some big thunks and I run out of memory, will Haskell try forcing things to free up memory?
12:03:57 <nshepperd2> also that would have hilarious results if the file is a pipe
12:04:48 <dmj`> catern: no, it will follow the path of lazy evaluation, and if you're spending all your time allocating and not freeing, you'll fall on your own sword.
12:05:08 <ski> madnight : objects in `E^D' look like `F,G : D >---> E'. morphisms looks like `eta : F >---> G'. so objects in `(E^D)^op' ought to be the same, while morphisms go in the opposite direction. but now `F^op,G^op : D^op >---> E^op' is determined by, and determines, `F,G : D >---> E' (`^op' is bijective), and `eta^op : G^op >---> F^op' does go in the opposite direction. so it seems to fit the bill
12:05:34 <catern> (Really what I want to know is whether there are any languages with smart GC stuff for file descriptors, the same way people have smart GC stuff for memory)
12:05:43 <ski> madnight : so, the NTs are reversed, from what i see
12:05:47 <catern> dmj`: alas! but wouldn't that be cool if it did do that though?
12:05:59 <catern> I guess people really don't care about memory pressure though...
12:06:07 <ski> nshepperd2 : could still be GCed, i think ?
12:06:21 <dmj`> catern: it would be cool, but it would adversely affect other things.
12:06:22 <solonarv> it would be cool, yes!
12:06:45 <solonarv> just can't really be done sensibly without reworking a lot of things, and it's just not a huge problem in practice
12:06:46 <madnight> ski: alright, thus faithful is full in the opposite category
12:06:59 <dmj`> catern: It's like trying to put a 8 x 8 ft. rug in an 10 x 10ft room, you might cover one corner, but you're exposed in another
12:07:01 <ski> madnight : i don't see how you reach that conclusion
12:07:15 <ski> madnight : natural transformations are reversed, not functors
12:07:58 <catern> solonarv: well specifically I was saying the "force thunks to free up memory" thing would be cool - running out of memory is a problem in practice sometimes, isn't it? (certainly running out of FDs is rare for most programs, so most languages don't try to be smart about that...)
12:08:54 <catern> (hmm, is there some deep type theory about knowing whether stepping a computation will expand or reduce memory usage?)
12:10:54 * hackage xmlbf 0.6.1 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.6.1 (RenzoCarbonara)
12:11:18 <ski> hm, reminds me of an idea i've seen aired sometimes, to be able to revert from forced state, back to unforced, in order to free up memory
12:11:20 <solonarv> catern: yes, that's part of why it's hard
12:11:50 <catern> ski: oh yeah, like reversible computing
12:12:21 <ski> well, i was thinking about reverting from a materialized large array (say), back to a small thunk
12:13:03 <madnight> "[20:25] (dmwit) (Indeed, take any category C which is not already isomorphic to 1 and the induced functor from C to 1.)" "[20:27] (dmwit) For faithful but not full, go the other way. 1 -> C for any non-1 C" Go the other way around equals arrow reversing?
12:13:03 <ski> (so, caching the thunk code around somewhere, rather than attempting to run the computation that materialized the array backwards, as with reversible computing)
12:13:43 <catern> ah sure - they still sound related at some level though, maybe?
12:14:36 <dmwit> I don't see a reason to think that forcing a thunk would reduce the amount of memory needed.
12:14:42 <nshepperd2> imo the answer to file descriptor problems is to increase the system limit
12:14:53 <catern> (like maybe "just keep the full execution trace around somewhere" is how you could implement reversible computing, and you could use that to reduce memory usage... er, somehow, heh :) )
12:15:13 <dmwit> madnight: I don't have a category in mind where reversing the arrows does what I meant when I said that, no.
12:15:19 <nshepperd2> you're not running haskell on a potato. or if you are, you better be following potato programming practices already :p
12:15:27 <ski> (one could maybe imagine something akin to a weak reference. except instead of being able to check whether the value has been GCed yet, instead you'd have an explicit operation to revert the corresponding thunk (which may be referenced from elsewhere, perhaps))
12:15:45 <dmwit> madnight: I meant nothing more than this: if C is any category which is not isomorphic to 1, and F is any functor from 1 to C, then F is faithful but not full.
12:16:33 <catern> nshepperd2: ugh yeah that stinks though! that's the solution that every language uses. no-one takes resource management seriously :( like, "just increase available memory if your program is too large for what you have" is sometimes applicable but is obviously not a universal rule...
12:17:02 <catern> but way more people take memory seriously than take any other kind of resource management seriously
12:17:38 <dmj`> catern: one thing you might be interested in is whole program optimization, this is something GHC does not have, but would make things more efficient
12:18:19 <dmwit> The question "does evaluating this think increase or decrease memory usage" is almost certainly undecidable.
12:18:29 <dmwit> s/think/thunk/
12:19:14 <dmj`> catern: you usually end up FFI'ing into C to be memory efficient in Haskell, and combining read Handle and write Handle in a tight loop to  keep things out of the GHC heap. Fusion doesn't always work because rewrite rules don't always fire correctly. This is why people use Storable vectors instead of normal vectors (among other reasons)
12:19:59 * ski would like fusion guarantees ..
12:20:01 <madnight> hmm the question that came up in my mind was: what is the inverse of a surjection
12:20:23 <LKoen> not all surjections have inverse functions
12:20:24 <ski> (.. like with tail calls)
12:20:37 <LKoen> think about f : R -> R+   x -> x^2
12:20:51 <nshepperd2> on ssa graphs, finding the evaluation order that minimises memory usage is np-hard iirc
12:20:52 <dmwit> Hm. I guess what I said is not strictly true. F : 2 -> 1 is definitely faithful but not full. But the other two claims about any C and any functor relating C and 1 were not true.
12:21:04 <dmj`> catern: I'm with you though, check out whole program optimization https://grin-compiler.github.io/
12:21:12 <dmj`> catern: this could be a boon for efficient haskell
12:21:18 <dmwit> *is definitely full but not faithful
12:21:19 <LKoen> well, it has a right-inverse, but no left-einverse
12:22:26 <newb> hey im trying to compile my Helloworld.hs file from the Mac terminal but no matter where I put the thing I get the same error that it cannot find the file. I even made a new directory, saved the file to that directory, changed to the new directory and it still did not work
12:22:48 <newb> im clearly doing something wrong
12:22:49 <catern> dmj`: yeah, whole program optimization is good (although, tbh, it seems to me that it's kind of the bare minimum that we should be doing, it should be a given)
12:22:53 <dmwit> What is the exact command you ran? What is the exact error message you got? You can use an online pastebin, then send us a link.
12:22:56 <dmwit> newb: ^
12:23:32 <dmj`> catern: yea, agreed. That's why this is a super cool project
12:24:03 <dmwit> catern: Whole program optimization is not a clear win, because it is typically more expensive, sometimes by quite a lot. Some projects I hack on already take hours to compile from front to back...
12:25:35 <catern> ah, fair enough
12:26:30 <dmj`> well, we could disable optimizations during development, I always use --disable-optimization when working on large projects, its intolerable any other way
12:26:42 <dmj`> then releasing it there's an -O2 
12:27:15 <dminuoso> dmwit: I think something like linear types the way Clean has them, offers far greater performance potential..
12:27:29 <dminuoso> It's still surprising how Clean surpasses GHC performance in quite a few tasks.
12:27:36 <ski> s/linear/uniqueness/
12:27:50 <newb> ok so I explicitly moved Helloworld.hs to my desktop through the "move to" command in Haskell for Mac. From here I go into terminal and use the command "cd Desktop/" then I run the command "ghc --make helloworld.hs" and get the error "can't find file: helloworld.hs".  The thing is this file itself is not on the desktop, instead it is the module
12:27:51 <newb> "FirstProj" So then I tried "ghc --make FirstProj" and I get the error "module â€˜FirstProjâ€™ cannot be found locally"
12:27:56 <dmj`> If Haskell had no GC, lazy and pure by default, extensible records (row polymorphism), and whole program optimization, it would be killer. Not sure if lazy and no GC is possible though
12:28:11 <dminuoso> ski: Ah, what's the distinction here?
12:28:57 <dmj`> catern: There is MLTon, and there was even a HaskellTon, but not sure what became of it
12:28:59 <geekosaur> cd FirstProj
12:29:05 <geekosaur> then ghc helloworld.hs
12:29:06 <ski> dminuoso : uniqueness tells you that you haven't duplicated a value yet (but may do so, in the future). linearity tells you that you're not going to duplicate it in the future (but may have, in the past)
12:29:09 <catern> haha, HaskellTon
12:29:13 <geekosaur> (--make has been unnecessary since ghc 7.0.1)
12:29:43 <igghibu> hi all, I'm setting up to learn Haskell and I was wondering what's best for VS Code HIE or Haskelly? please and thank you. I've seen that both are present here https://wiki.haskell.org/IDEs#Visual_Studio_Code but can't understand what's best.
12:30:01 <ski> dminuoso : uniqueness is what you'd reach for, to enable update-in-place as an optimization on discard&create
12:30:07 <igghibu> (ps: for now i failed at installing either :P)
12:30:08 <dminuoso> ski: Right.
12:30:35 <dmwit> newb: After `cd Desktop/`, what does `find . -name '*.hs'` say?
12:30:47 <ski> dminuoso : however, there's some relation between then two that i don't grok that well. see SPJ's "Linear Haskell" (iirc) paper for some info
12:31:04 <rihardsk[m]> hi, any idea why i might be getting "hGetContents: invalid argument (invalid byte sequence)" error when using readFile (using Linux)? the only way around it that i've found is using hSetEncoding to manually set the encoding for the file handle to utf8. which is weird because afaik all of the locale-related env variables are set to either en_US.UTF-8 or en_US.UTF-8 on my system. can't think of a reason for readFile to
12:31:05 <rihardsk[m]> default to something non-utf8
12:31:37 <ski> dminuoso : Clean, and Mercury, has uniqueness. iiuc, Rust also has support for it
12:31:40 <newb> @geekosaur I ran cd FirstProj and yet again it sais "-bash: cd: FirstProj: No such file or directory" but im literally staring on my desktop at FirstProj haha so confusing
12:31:40 <lambdabot> Unknown command, try @list
12:32:25 <newb> oh wait FirstProj isn't a module it is a project
12:32:53 <newb> though the only module in the project is also called FirstProj
12:32:57 <dmj`> is laziness and no GC possible ?
12:33:12 <geekosaur> that doesn't mean much without context. a project could mean something different for different IDEs
12:33:43 <solonarv> rihardsk[m]: I think there might be a latin1 default squirreled away somewhere
12:33:46 <geekosaur> dmj`, sort of? jhc used to use boehm gc which is a gc-ish thing for C/C++
12:33:57 <geekosaur> rihardsk[m], pastebin the output of the locale command
12:34:17 <newb> Ok the difference between module and project has to be the problem here thanks I should be able to figure it out from here
12:34:20 <ski> Mercury still has a no-GC grade, iirc
12:34:54 <dmj`> geekosaur: hmm, I'll check it out. I essentially want no GC, or a custom GC created for each program when compiled that is efficient specifically for that program. Onus shouldn't be on user to fiddle with GC settings to get efficiency in that regard.
12:34:59 <geekosaur> and latin1 is iirc the default if it can't load the locale as specified, which might even be spelling (some systems want "UTF8", some "UTF-8"; also beware - vs. _)
12:36:14 <geekosaur> in any case ghc doesn't currently provide pluggable GCs
12:36:40 <rihardsk[m]> solonarv: geekosaur https://gist.github.com/rihardsk/66f1b81276b250c0debb2ea5b6d8f916
12:38:14 <rihardsk[m]> not sure why some of the values are quoted and others are not. but everything seems to be utf8
12:39:10 <dminuoso> ski: With Rust, are you talking about burrowing?
12:39:22 <solonarv> I actually meant: squirreled away somewhere in the standard library
12:39:46 <dmwit> latin-1 shouldn't ever cause an invalid byte sequence error. All byte sequences are valid latin-1.
12:40:21 <ski> dminuoso : just ensuring that you have the unique reference to an object
12:40:40 <ski> (i haven't delved enough into borrowing to grok it)
12:41:10 <dmwit> Anyway, reading a file without explicitly setting an encoding seems like a recipe for disaster in the first place.
12:41:31 <geekosaur> good point re invalid encoding
12:41:45 * geekosaur is not sure what's up with his connection, it keeps dropping
12:43:51 <dmj`> geekosaur: well GHC, in the same way that rust has no GC, would it be possible to have no GC w/ any lazy language.
12:43:57 <dmj`> GHC aside*
12:45:17 <geekosaur> seems like it'd be a lot more work at minimum
12:45:18 <astk> is there any easy way to spoof the websockets request issued by a html webpage?
12:46:15 <newb93> hey so after having trouble finding my Helloworld.hs file I was able to find and compile it after I physically dragged the file out of Haskell for Mac and onto my desktop. So I have a few questions here. Can you compile entire modules at once? If anyone has experience with haskell for Mac, what is the difference between a project and a module? When
12:46:16 <newb93> I'm clicking file-save am I saving the source file im working on or the entire module?
12:46:50 <geekosaur> a module is a source file. what a project is depends on the IDE
12:47:12 <geekosaur> re locale and double quotes earlier: Values  for  variables set in the environment are printed without double quotes, implied values are printed       with double quotes.
12:47:28 <dmj`> astk: for testing?
12:48:02 <rihardsk[m]> dmwit: sure, maybe so. but still, every other issue i've found when googling for "hGetContents: invalid argument (invalid byte sequence)" seems to be caused by hGetContents defaulting to utf-8. it's weird that it's defaulting to something else for me
12:48:12 <newb93> ok my issues are definitely Haskell for Mac related
12:48:24 <astk> well, i have a working html version of a websocket subscription, but when i try to subscribe from haskell it returns an error, so there must be something wrong with the format of the subscription message im issuing from haskell, and i want to see what the html page is sending
12:48:27 <rihardsk[m]> despite me using utf-8
12:48:29 <dmj`> geekosaur: it would be so nice though
12:48:55 <dmj`> astk: html pages can't initiate websocket requests
12:49:10 <astk> huh?
12:49:38 <newb93> does ghc automatically compile all associative files?
12:49:52 <dmj`> astk: you need to use the WebSocket javascript API, it initiates with an HTTP POST w/ an upgrade header
12:50:04 <astk> right, same thing...
12:50:28 <dmj`> astk: if you think an html page is javascript, then yes its the same thing
12:50:34 <astk> i have never done js or html, so its all equally as confusing
12:50:38 <solonarv> newb93: it does, yes
12:51:12 <solonarv> in older versions you had to use ghc --make for that behavior, but since 7.0 it's the default behavior
12:52:12 <newb93> solonarv: ok so every file must have some kind of marker on the associated files that stay with it regardless of where you are storing your files
12:53:03 <solonarv> newb93: what "associated files" do you mean, exactly?
12:53:34 <rihardsk[m]> dmj`: regarding lazyness and not having a GC - i recently stumbled upon Formality lang and it seems to be doing just that. no GC because it has an affine and linear type system and it's lazy https://github.com/moonad/Formality
12:54:10 <geekosaur> newb93, ghc can follow imports to see what other files must be compiled
12:55:04 <geekosaur> the old behavior by default was like C, which doesn't work the same way since a .c file doesn't necessarily have or need an associated .h file to be #include-d. this was fairly pointless, so --make was made the default
12:55:45 <newb93> solonarv, geekosaur: So does this mean that every module should have one executable and this executable is the only file you should compile? 
12:56:01 <astk_> newb93: no!
12:56:19 <solonarv> newb93: in Haskell parlance, a "module" is just a file of haskell source code
12:56:24 <astk_> modules can be libs, they dont need executables (a main function)
12:56:36 <geekosaur> every program has one executable, but may be composed of multiple modules. only one module is the main module (distinguisheed by not having a module header, or by explicitly saying "module Main where â€¦")
12:57:22 <newb93> ok my language is confusing everyone myself included haha but ^ is what I meant thanks!
12:58:32 <astk_> and yes, you would write ghc myMain.hs to compile this module and its dependencies
12:58:56 <newb93> ok I got it now thanks guys 
12:59:09 <astk_> and then after a while you should start using .cabal files 
13:00:29 <astk_> dmj' : I was thinking I could make the html page connect to a local websocket server instead to see what message it would send
13:00:59 <dmj`> astk_: what haskell package are you using to do this
13:01:01 <astk_> but then i dont get to see the exact format of the headers, 
13:01:10 <astk_> dmj` wuss
13:01:22 <astk_> https://hackage.haskell.org/package/wuss
13:01:29 <dmj`> astk_: that's just for clients
13:01:33 <dmj`> astk_: you want a server
13:01:47 <dmj`> @package wai-websockets
13:01:47 <lambdabot> http://hackage.haskell.org/package/wai-websockets
13:01:52 <dmj`> I'd use this one
13:01:59 <astk_> oh yeah, i was using wuss to try and make the client that was like the html page, to recieve the packets
13:02:15 <dmj`> astk_: what package are you using for the server
13:02:17 <astk_> oh, i never saw this, whats wai
13:02:24 * hackage tar-bytestring 0.6.3.0 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.3.0 (maerwald)
13:02:29 <dmj`> astk_: common interface for web apps
13:02:47 <astk_> i thought the server would just use https://hackage.haskell.org/package/websockets
13:05:01 <dmj`> astk_: is that what you're currently using
13:05:21 <astk> yes
13:05:30 <astk> whats the advantage of using wai aswell?
13:06:04 <dmj`> astk_: if you want more than just a websocket server 
13:06:09 <dmj`> astk_: https://github.com/jaspervdj/websockets/blob/master/example/server.lhs 
13:06:17 <dmj`> it has examples that should compile
13:07:02 <astk> heres the version i was using for testing; https://pastebin.com/raw/i0EDFMUn
13:08:49 <astk76> what a laboriously elaborate example
13:10:38 <astk76> i guess im basically having to spoof the server im trying to connet to
13:10:48 <astk76> instead of the client...
13:11:25 <astk76> anyway, this doesnt soleve the issue of then not being able to see exactly the format of the data sent by the html version
13:11:47 <astk76> as when this is recieved by my faux server, it will strip the headers from the message
13:12:03 <astk76> and if i use something without websockets, then it fails to perform the handshake with the client
13:12:07 <dmj`> astk76: you gotta fork the thread into an infinite loop, you're immediately closing
13:12:33 <astk76> its shorter doing that, its a least sufficient example
13:12:44 <dmj`> astk76: acceptRequest will block, so will receiveDataMessage, but it will close right after it echoes
13:13:08 <astk76> i think the complete version with the looping is on ocharles blog
13:13:30 <astk76> but this version works anyway, even if its just for one echo
13:13:41 <dmj`> astk76: oh ok, as long as you know this is intended behavior.
13:13:52 <dmj`> astk76: so the browser version doesn't work
13:16:52 <astk> it works just fine
13:16:53 <astk> https://gist.github.com/fog-hs/785c746a74a9c723db7b154d2499a762
13:17:18 <astk> here, a html page with a textbox is used to get an echo response
13:17:55 <astk> however, if i try to put the html page that im trying to spoof, to echo the message it sends to do the subscription, it breaks
13:21:23 <astk> and i cant figure out why, or what to do instead to achieve this haskell subscription
13:22:21 <astk> also, i get the feeling that other languages dont have this problem, like, the html version seems like it was an easy example for the providers of the API to write 
13:22:34 <astk> i guess js is better for socket stuff than haskell
13:23:10 <astk> which is unfortunate, since I would like to think i can use haskell for the whole project, and not have to use python or something to do something so simple
13:29:38 <rihardsk[m]> dmwit geekosaur solonarv: found the cause of my locale issue! forgot to mention that i was using Nix. turns out i have to set LOCALE_ARCHIVE because Nix has a patched glibc https://nixos.org/nixpkgs/manual/#locales
13:32:24 * hackage dobutokO2 0.2.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.2.0.0 (OleksandrZhabenko)
13:35:24 * hackage lz4-hs 0.1.0.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.0.0 (vmchale)
13:38:49 <astk> so how can i write a server to receive the subscription message from the html version, which allows me to dump both the message and the header, so i could submit this via ncat or something to test that it works
14:12:54 * hackage lz4-hs 0.1.1.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.1.0 (vmchale)
14:17:31 <losq> myFunc :: Int -> IntmyFunc x =	let rand = --random num between 1 and 5	in rand * x  
14:17:45 <losq> ignore ill get a pastebin going
14:20:58 <losq> https://pastebin.com/uhnmuiDt        my question is what is easiest way to finish off this simple function by creating the random num
14:22:02 <lyxia> let rand = 3
14:22:12 <{abby}> funny, I got 4
14:24:09 <losq> now that I think about this is impossible because I can get a different result with the same argument
14:24:23 <int-e> losq: exactly, you'd be violating purity
14:26:22 <int-e> {abby}: 4 has the xkcd stamp of approval
14:27:26 <ChaiTRex> no, you have to roll a fair die and use that. you can't trust the xkcd guy's die, it might not actually be fair.
14:28:52 <int-e> ChaiTRex: rolling your own dice is so wasteful when you can reuse somebody else's.
14:29:30 <int-e> . o O ( Not Rolled Here syndrome. )
14:30:29 <dsal> losq: Have you read through https://hackage.haskell.org/package/random-1.1/docs/System-Random.html ?  You can have a pure function that does random stuff, but not the way you have it.
14:30:40 <dsal> Well, pseudorandom.
14:31:12 <losq> I have not but ill copy the link somewhere for later thanks
14:45:30 <maerwald> https://hackage.haskell.org/package/terminal-progress-bar neat package
14:54:54 * hackage hw-bits 0.7.1.2 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.2 (haskellworks)
15:29:39 <merijn> Ha, vindication! Even Snoyman is recommending committing .cabal files even if you're using hpack :p
15:29:50 <jackdk> Link?
15:30:01 <merijn> jackdk: https://tech.fpcomplete.com/blog/storing-generated-cabal-files
15:30:07 <jackdk> tyvm
15:32:12 <phadej> merijn: and ironically by the very similar reason cabal users were asking to keep cabal files there :)
15:33:05 <merijn> :p
15:34:25 <merijn> phadej: I looked into adding a project-root flag, btw. Seems doable enough, so I'll probably PR something in the next week. Although I don't understand cabal-install's testsuite at all, so someone else will have to enlighten me how to add corresponding tests
15:40:29 <phadej> merijn: I'm quite sure there is `--project-file` tests, so grep is your friend
15:40:55 <merijn> We'll see when I have some time :)
15:59:21 <jackdk> merijn: I read that blog post and concluded that all the problems never begin if I continue not using hpack.
16:07:06 <zeta_0> can i run elm on haskell's warp web server?
16:07:52 <Axman6> it just produces static files doesn't it? so of course
16:11:53 <zeta_0> Axman6: cool is there any extra configuration that i need to do with elm? i'm searching for instructions on this now
16:28:48 <dsal> @tell zeta_0 elm just produces assets that can be served up.  If you also want to run the compiler, things are more complicated, but that's not a thing you'd do at deployment time.
16:28:49 <lambdabot> Consider it noted.
16:59:12 <random32> https://pastebin.com/iyb6fEJ3 is a function defined with no ->'s simply a function that doesn't take arguments or is it something else?
16:59:41 <divVerent> random32: in a way, it's just a value
17:00:00 <divVerent> your randScore isn't really a function but just a value of IO Int
17:00:09 <Axman6> all functions are values, but not all values are functions
17:00:10 <divVerent> that, when evaluated, calls getStdRandom with argument randomR (1, 6)
17:00:13 <divVerent> that too
17:00:25 <divVerent> one can see IO x as "an action returning an x"
17:00:43 <divVerent> so as opposed to a function that takes arguments from its callers, an IO action gets its "input" from the outside world
17:00:48 <divVerent> (here, the RNG state)
17:01:07 <divVerent> and of course you can have both in one (e.g. foo :: Int -> IO Int)
17:01:41 <divVerent> or even operate on actions, like this:
17:02:19 <divVerent> ioSeq :: IO a -> IO a
17:02:26 <divVerent> ioSeq a = do
17:02:28 <divVerent>   a
17:02:30 <divVerent>   a
17:02:42 <divVerent> damn, wanted to call it "twice" first :)
17:03:24 <random32> ok so I should basically think of my above function as a value that can be between 1 and 6 ?
17:03:43 <divVerent> it's an action that returns a value between 1 and 6 when executed
17:03:54 <divVerent> this differs from a value between 1 and 6 per se, as the latter would be the same value every time
17:04:14 <divVerent> but your action returns a different value every time (except if the RNG doesn't want to... ;) )
17:04:50 <random32> what would another example of an action be?
17:07:34 <dsal> :t getCurrentTime
17:07:36 <lambdabot> error: Variable not in scope: getCurrentTime
17:07:41 <dsal> % :t getCurrentTime
17:07:41 <yahb> dsal: ; <interactive>:1:1: error:; * Variable not in scope: getCurrentTime; * Perhaps you meant `getCurrentCCS#' (imported from GHC.Exts)
17:07:54 <dsal> man.  Anyway, getCurrentTime is a good example.
17:09:30 <random32> dsal: the "get" part is really what makes it an action right because we don't just have the time in our program, we have to get it from somewhere which is an action ?
17:10:48 <random32> and regular functions aren't really actions because they are more like a plan for a future action
17:13:35 <dsal> random32: the thing about it being inside a monad is what makes it an action.
17:13:42 <ski> @hoogle getCurrentTime
17:13:43 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
17:13:43 <lambdabot> Data.Time.Clock.POSIX getCurrentTime :: IO UTCTime
17:13:43 <lambdabot> Text.Pandoc.Class getCurrentTime :: PandocMonad m => m UTCTime
17:14:32 <ski> random32 : all functions (in Haskell) take exactly one argument
17:15:41 <random32> ski: right I can't forget currying
17:16:29 <ski> @type getLine
17:16:31 <lambdabot> IO String
17:16:36 <ski> is yet another action
17:16:43 <ski> @type putStrLn
17:16:45 <lambdabot> String -> IO ()
17:17:35 <ski> is a function that will produce an action as result. calling the function will not output anything. only when (if) the computed action is (possibly later) executed/run (possibly multiple times) will the action of outputting the `String' be performed
17:17:43 <ski> @quote /bin/ls
17:17:43 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:18:42 <ski> that analogy is meant to illustrate that `getLine' doesn't "contain" any `String'. hence there's no way to "get the `String' out of it"
17:19:47 <ski> however, if you have a function of type `String -> Integer', say, parsing the string, possibly, you can "bring that function inside the `IO'", so that, when the new action, of type `IO Integer' is executed, it'll take the resulting `String' and feed it to that function, to get an `Integer'
17:20:14 <ski> (so, you can "bring things inside `IO'" just not "take them out again")
17:21:00 <random32> so nothing you type into your text editor is an action but instead could be a function that produces an action. its not until you call the function that an action is performed. Is this correct?
17:21:07 <ski> (`liftM :: (a -> b) -> IO a -> IO b' is how you could do that, in this case. `a' being `String' and `b' being `Integer' in my example)
17:21:30 <ski>   putStrLn :: String -> IO ()
17:22:01 <ski> is a function (that produces an action as result (that when executed will yield a result of type `()', iow an uninteresting result))
17:22:16 <ski> you can tell it's a function, because of the `->' in its type
17:22:25 <ski> all functions take exactly one argument
17:22:32 <ski>   getLine :: IO String
17:22:54 <ski> otoh, is not a function (no `->'). it's simply an action (that when executed will yield a result of type `String')
17:23:05 <ski> if you define
17:23:09 <ski>   main :: IO ()
17:23:29 <ski>   main = do putStrLn "Enter a Line :"
17:23:42 <ski>             l <- getLine
17:23:51 <ski>             putStrLn (reverse l)
17:24:01 <ski> then this is also an action (not a function)
17:24:32 <ski> so "nothing you type into your text editor is an action" is incorrect
17:25:06 <ski> some things you define are actions. some are functions. some are other things, like perhaps lists, numbers, tuples, finite maps, trees, &c.
17:25:34 <ski> an `IO'-action is a value of type `IO T', for some type `T'. the actions in the examples above were all `IO'-actions
17:26:06 <ski> you can also have `Parser'-actions, being values of type `Parser T', for some type `T'
17:26:42 <ski> and in general `M'-actions, for `M' not necessarily being `IO' or `Parser'. there's many other examples
17:27:26 <ski> random32 : "its not until you call the function that an action is performed. Is this correct?" -- no. even after you call the function, the action is not performed (by itself)
17:27:54 <ski> > reverse [putStrLn "Hello",putStrLn "Goodbye"]
17:27:56 <lambdabot>  [<IO ()>,<IO ()>]
17:28:14 <ski> that does not perform (/ run / execute) any `IO'-action
17:28:41 <ski> for different choices of `M', there may be different ways of performing `M'-actions
17:29:18 <ski> for `IO'-actions, specifically, there is no way to cause an `IO'-action to be performed/run/executed, merely by calling a function, or evaluating an expression
17:30:29 <ski> the only way you can make an `IO'-action be executed, is (a) to make `main' that action; (b) to enter the action into the interactor (GHCi); (c) to make the action part of a bigger action, that will eventually get executed (so you're back to (a) and (b) then)
17:30:44 <ski> random32 : making any sense ?
17:32:41 <random32> Yes thinking of main as an action is helpful. I think im gonna need to think about it for a bit as in general im a slower learner but I copied all your examples into my notes thanks so much
17:34:04 <ski> random32 : a similar analogy is to think of an action as a recipe, describing some kind of "effects" to perform, typically in a particular order (although, sometimes, the order of the effects of some individual subactions may not matter)
17:35:07 <ski> random32 : an `IO'-action, specifically, say of type `IO T', would correspond to a "recipe" telling the computer how to interact (Input and Output) with the external world, in order to get a result of type `T'
17:36:14 <ski> from the POV of the Haskell program, executing in a process, the "external world" includes everything outside that process, so other processes in the computer, and the file system, and network connections, and input & output devices, like keyboard, screen, audio, &c.
17:36:31 <ski> @quote recipe.is.not
17:36:31 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
17:37:50 <ski> random32 : btw, you should be careful about generalizing from `IO'-actions, to actions in general (that is `M'-actions, for some `M' which doesn't have to be `IO'). `IO' is a bit "special" or "magical", perhaps, in ways that other `M' usually arent
17:39:04 <random32> ok things are definitely starting to make more sense. I really appreciate the help im gonna sit on these thoughts
17:39:43 <ski> e.g. `Parser' or `Maybe' or `State s' can all be defined in the language. but `IO' requires some compiler or run-time support. the `IO' primitives like `getLine' and `putStrLn' are either themselves not defined in Haskell or (more likely) are defined in terms of primitives which aren't defined in Haskell
17:40:36 <ski> (just like e.g. the primitives for addition,&c. on `Float'ing-point numbers aren't defined in the language, but have special support)
17:47:45 <divVerent> an interesting example of a non-action is seq someComputation
17:48:21 <divVerent> as someComputation `seq` otherComputation does evaluate someComputation without using it, sure, but it doesn't really have any effect (except if someComputation is a bottom)
17:51:34 <divVerent> BTW, putStrLn itself is of course defined in Haskell, but its underlying primitives are not
17:52:52 <divVerent> hm... question BTW
17:52:58 <divVerent> what is actually a String internally in ghc?
17:53:18 <divVerent> I know that conceptually it's a linked list of Char
17:53:28 <divVerent> but I'd be very surprised if that's how it is represented in memory
18:02:31 <doesntContribute> is it possible to use ordering operations on an IO Int ?
18:02:57 <Axman6> How would that work?
18:04:29 <doesntContribute> I would think an IO Int would behave similarly to a regular Int because... well I don't know numbers are naturally bigger or smaller than other numbers
18:04:35 <Axman6> what would happen if I had a :: IO Int and b :: IO Int, where a returned 10 or -10 every second call,m and b returned -10 and 10 every second call? a < b half the time
18:05:12 <Axman6> but an IO Int isn't an Int, it's a recipe for how to produce an Int, and can produce a different Int every time it's executed
18:05:36 <doesntContribute> ok thanks you
18:06:18 * glguy . o O ( living up to the nickname... )
18:12:40 <Axman6> glguy: is that a glirc feature I've missed or do you type it every time?
18:14:48 <glguy> Ha, I just type it out :)
18:15:20 * ski nods solemnly
18:18:10 <glguy> If that was a command in glirc it would be /ski
18:26:44 <ski> hahah :)
18:30:54 <iqubic> glguy: Just make a new command.
18:36:10 * glguy .oO( thinks this might work )
18:36:19 <glguy> Added this to macros:   * {name:"ski", arguments:"thought*", commands:"me .oO( $0 )"}
18:37:55 <ski> too little space, heh
18:38:05 <glguy> Yeah, you're right
18:39:52 * ski is amused
19:13:39 <dmwit> divVerent: Prepare to be very surprised.
19:32:54 * hackage libarchive 2.2.3.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.3.0 (vmchale)
20:03:09 <divVerent> % fmap (\ f -> let m = singleton (0/0.0) () in length $ f m m) [const, union, intersection, difference]
20:03:09 <yahb> divVerent: ; <interactive>:271:22: error:; * Variable not in scope: singleton :: Double -> () -> t; * Perhaps you meant one of these: `S.singleton' (imported from Data.Set), `M.singleton' (imported from Data.Map), `IM.singleton' (imported from Data.IntMap); <interactive>:271:77: error:; * Variable not in scope: intersection :: [()] -> [()] -> [()]; * Perhaps you meant one of these: `S.intersection
20:03:31 <divVerent> % fmap (\ f -> let m = M.singleton (0/0.0) () in length $ f m m) [const, M.union, M.intersection, M.difference]
20:03:31 <yahb> divVerent: [1,2,0,1]; it :: [Int]
20:05:04 <divVerent> % fmap (\ f -> let s = S.singleton (0/0.0) in length $ f s s) [const, S.union, S.intersection, S.difference]
20:05:05 <yahb> divVerent: [1,2,0,1]; it :: [Int]
20:05:21 <divVerent> so we got a set of 1 element; union with itself has 2; intersection with itself has zero; difference with itself has one
20:05:25 <divVerent> yeah, right :)
20:07:12 <divVerent> % let i = -9223372036854775808 :: Int in abs i
20:07:12 <yahb> divVerent: -9223372036854775808; it :: Int
20:07:22 <divVerent> and this one has a negative absolute value
20:07:47 <dmwit> Welcome to computing.
20:07:50 <divVerent> I know
20:07:55 <divVerent> I mean, none of this would surprise me in C++
20:08:06 <dmwit> I think you should enjoy your minBound one a bit more.
20:08:09 <divVerent> just, in Haskell it feels wrong, given the language normally tries to be formally correct
20:08:14 <dmwit> Think carefully about the calculation that's being done.
20:08:25 <divVerent> and yes, I am aware of the Integer type
20:08:31 <divVerent> I do object to Double being Ord
20:08:37 <divVerent> in fact, even Eq is doubtful
20:08:50 <dmwit> 1. 9223372036854775808 :: Int, which becomes -922... 2. negate that thing, which doesn't change it 3. abs that thing, which doesn't change it
20:08:56 <divVerent> right
20:09:00 <divVerent> as I said - in C this wouldn't surprise me
20:09:09 <divVerent> in Haskell I am disappointed that it isn't a runtime error
20:09:19 <dmwit> You can have a warning if you want.
20:09:20 <divVerent> % -9223372036854775808 / -1
20:09:20 <yahb> divVerent: ; <interactive>:275:1: error: Precedence parsing error cannot mix `/' [infixl 7] and prefix `-' [infixl 6] in the same infix expression
20:09:23 <divVerent> is nice too
20:09:27 <divVerent> oh right, sorry
20:09:35 <divVerent> % (-9223372036854775808) / (-1)
20:09:35 <yahb> divVerent: 9.223372036854776e18; it :: Fractional a => a
20:09:41 <divVerent> damn
20:09:44 <divVerent> % (-9223372036854775808) `div` (-1)
20:09:44 <yahb> divVerent: 9223372036854775808; it :: Integral a => a
20:09:45 <dmwit> % :set -fwarn-overflowed-literals
20:09:45 <yahb> dmwit: 
20:09:52 <dmwit> % -9223372036854775808 :: Int
20:09:52 <yahb> dmwit: -9223372036854775808; it :: Int
20:09:56 <dmwit> mmm
20:10:01 <divVerent> % (-9223372036854775808 :: Int) `div` (-1)
20:10:02 <yahb> divVerent: *** Exception: arithmetic overflow
20:10:05 <divVerent> finally :)
20:10:10 <divVerent> at least the error message is better
20:10:13 <dmwit> % 9223372036854775808 :: Int
20:10:13 <yahb> dmwit: ; <interactive>:281:1: warning: [-Woverflowed-literals]; Literal 9223372036854775808 is out of the Int range -9223372036854775808..9223372036854775807; If you are trying to write a large negative literal, use NegativeLiterals; -9223372036854775808; it :: Int
20:10:17 <divVerent> this raises SIGFPE normally which isn't even floating point
20:11:04 <divVerent> means every code that does stuff like if b != 0 then something a `div` b something is broken
20:11:15 <divVerent> because b could be -1 and a could be minBound and it still raises SIGFPE
20:11:31 <divVerent> seems like the only proper way is to divide first and catch the error
20:11:35 <divVerent> if one wants robust code
20:12:00 <divVerent> or at least check that the denominator is positive, as that precludes all the bad things
20:12:30 <divVerent> speaking of int shenanigans...
20:12:39 <divVerent> is signed integer overflow "permitted" or undefined?
20:12:55 <divVerent> like, does the compiler potentially optimize based on facts like a + 1 > a?
20:15:01 <glguy> Signed overflow is defined
20:15:15 <divVerent> ah, good to know
20:27:45 <dmwit> Huh. For some reason I had it in my head that overflow was defined for the, like, Int8, Int16, etc.'s, but not for Int.
20:32:10 <dmwit> But I'm wrong; the Report is relatively clear.
20:34:10 <dmwit> "All arithmetic is performed modulo 2^n, where n is the number of bits in the type." seems a bit strange, maybe, since the standard range for "modulo x" operations is 0 to x-1. But -x/2 to x/2-1 is also sometimes used (e.g. in cryptography), I guess, so...
20:57:46 <composeme> What's the difference between `(fmap . fmap) (+ 1)` and `getCompose . fmap (+ 1) . Compose`? They give the same result at https://repl.it/repls/SlateblueDarksalmonDecimals . Does Data.Compose have any advantage over (fmap . fmap)?
21:00:26 <glguy> No, there's no advantage to using Data.Compose there
21:00:56 <nitrix> let (.:) = (.) . (.)
21:14:34 <composeme> glguy: Does Data.Compose become more efficient maybe? I think they are always equivalent but if that's the case it makes me wonder why Data.Compose exists.
21:15:06 <glguy> No, it's not more efficient, it just exists because it can be useful to have a newtype whose instances make use of that behavior
21:15:19 <composeme> okay, thanks
21:21:24 <pie_[bnc]> is this Jack Kelly fellow on IRC? https://www.youtube.com/watch?v=iik7yfB8BGo
21:21:50 <jackdk> maybe
21:23:26 <pie_[bnc]> jackdk: :D
21:23:41 <pie_[bnc]> jackdk: I just started the talk but it seems right up my alley of interest, so yay!
21:24:17 <jackdk> I hope it helps you. I hang out in #reflex-frp too, as do a bunch of good people who wrote all the stuff I'm just talking about
21:25:28 <pie_[bnc]> sadly life usually gets in the way of me actually learning any of this stuff, but I'm definitely interested in going in the direction. a bit of a pipe dream at the moment is getting some better haskell support for Qt (oops, more frontend stuff, but its not pigeonholed into the browser :P)
21:27:59 <pie_[bnc]> there's a fellow that works on a c++ binding generator for haskell called hoppy, and some raw qt bindings that seem to work pretty decently called qtah; I've been slowly nagging / doing research for getting some automatic binding generation to increase the coverage. after that, and doing research about how feasible it even is, ideally a middle-layer for reflex would be nice.
21:29:25 <jackdk> I'm pretty sure all the bindings for the gl package are auto-generated, but IIRC there's an xml file somewhere describing everything and it's C
21:29:41 <jackdk> C++ (and the moc stuff qt needs too?) might be harder
21:31:57 <pie_[bnc]> im really not very clueful about this stuff, but currently overall im scratching my head about getting signatures for qt functions into the binding generator, because that seems like it would help; and the pyside (python qt binding endorsed by qt afaict) people seem to have a tool for doing the extraction, but its "no user servicable parts inside" currently
21:32:29 <pie_[bnc]> so i've been putting off opening an issue on their issue tracker that they asked me to do, for extracting that component into something more usable
21:32:46 <pie_[bnc]> i think it would make a lot of sense because it would probably be good for a lot of other tools *shrug*
21:47:56 <jackdk> pie_[bnc]: I think opening the issue makes sense, even if you don't expect to be able to implement it any time soon. It lets other people say "yes, this is important to me", and lets the project owners signal that they'd be interested in patches.
21:49:19 <pie_[bnc]> Im in no position to implement it haha, I talked to them a bit and they showed *some* interest :I
21:49:33 <pie_[bnc]> but yeah me opening it is overdue and actually I just started doing tat
21:49:34 <pie_[bnc]> *that
21:50:52 <jackdk> cool
21:54:54 * hackage unity-testresult-parser 0.1.0.2 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.2 (incertia)
21:56:16 <mjrosenb> lyxia: I used the expression with ipreview.  I'd also like to use it with ^@?
21:59:43 <mjrosenb> speaking of which, I have an expression that works in both ipreview $ field . foo and bar ^@? field . foo, and I'd like to bind foo to a variable.  How can I do this?
22:11:54 * hackage unity-testresult-parser 0.1.0.3 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.3 (incertia)
22:41:06 <kenran> Is there a state-of-the-art way to nixify a cabal project containing 3 packages in a `cabal.project` file?
22:43:12 <kenran> Switching to stack is not an option for now, but if all else fails I could merge the packages into one. I'm just asking out of curiosity as I only found an open issue (286) to this topic.
22:43:28 <jackdk> https://git.sr.ht/~jack/reflex-libtelnet/tree/a0f920ee119b8fb5faf9b330d0184f1a63cd30f6 is how I did it; no claims that it is best practice.
22:47:46 <kenran> jackdk: thanks! So as a process: you cabal2nix'd the two packages separately, then wrote an overlay where you added your two packages manually?
22:49:19 <jackdk> something like that. The only "overlay" is in the overrides to baseHaskellPackages. default.nix is returning an entire haskell package set which might not be the best but oh well
22:59:52 <kenran> jackdk: it looks feasible to me though. I might merge the packages into one anyway for my project (they do belong together after all), but it's good to know there's a (manual) way after all :)
23:01:06 <jackdk> Yeah the main reason I split packages was to make it clear the example code was BSD-license, but the library is GPL.
23:13:06 <davean> Huh, I guess since you wrote both of them you can do that?
23:13:32 <davean> But clearly the example is a derivative work
23:13:42 <davean> so if anyone else edits the example, does it immediately become GPL?
23:19:54 * hackage deriving-aeson 0.2 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2 (FumiakiKinoshita)
23:21:46 <pie_[bnc]> well, I guess I finally got that out of the way https://bugreports.qt.io/browse/PYSIDE-1240
23:38:07 <myme> Does anybody know about or have any good examples at how to handle multiple layers of application configuration? I find that I'm basically creating several layers of almost identical datatypes. E.g. one for configuration file parsing, option/cli arguments, and the runtime environment.
23:47:33 <hololeap> what could be the reasons for using bang patterns here, in the (:&) constructor: https://hackage.haskell.org/package/vinyl-0.12.1/docs/Data-Vinyl-Core.html#t:Rec
23:48:38 <hololeap> i'm asking because i see them from time to time in docs and i don't know the rhyme or reason
