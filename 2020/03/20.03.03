00:33:46 <idnar> @hoogle Functor f => (a -> c) -> (b -> d) -> f (a, b) -> f (c, d)
00:33:47 <lambdabot> Relude.Extra.Bifunctor bimapF :: (Functor f, Bifunctor p) => (a -> c) -> (b -> d) -> f (p a b) -> f (p c d)
00:35:54 * hackage timezone-olson-th 0.1.0.5 - Load TimeZoneSeries from an Olson file at compile time.  https://hackage.haskell.org/package/timezone-olson-th-0.1.0.5 (petterb)
00:36:09 <idnar> oh wait
00:36:21 <idnar> @hoogle Functor f => (a -> c) -> (a -> d) -> f a -> f (c, d)
00:36:21 <lambdabot> No results found
00:36:44 <idnar> @hoogle (a -> c) -> (a -> d) -> a -> (c, d)
00:36:46 <lambdabot> Data.Tuple.Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
00:36:46 <lambdabot> Extra (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
00:36:46 <lambdabot> Control.Wire.Core (&&&!) :: (a -> b) -> (a -> c) -> (a -> (b, c))
00:37:41 <MarcelineVQ> Control.Arrow &&&
00:39:37 <idnar> my (a -> c) and (a -> d) are actually the same function but I need to instantiate it at different types
00:39:41 <MarcelineVQ> Control.Arrow     &&& for the last   \f g -> fmap (f &&& g)  for the one before it,  \f g -> fmap (f *** g)  for the one before that
00:42:38 <idnar> so `(f &&& f) <$> a` I guess
00:43:58 <idnar> unfortunate precedence there
00:44:38 <idnar> MarcelineVQ: thanks!
00:46:10 <MarcelineVQ> there is an <&> around somewhere if you want to write it in that order
00:46:47 <MarcelineVQ> oh nvm misread that
01:15:24 * hackage servant-purescript 0.10.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.10.0.0 (eskimo)
02:04:00 <tabaqui1> I've forked a library in local stack project
02:04:56 <tabaqui1> and "stack build <forked_lib>" obviously builds the modules, but later fails with error 1
02:05:04 <tabaqui1> Received ExitFailure 1 when running
02:05:06 <tabaqui1> Raw command: /home/spirit/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/bin/ghc-pkg-8.6.5 --user --no-user-package-db --package-db /home/spirit/saas/.stack-work/install/x86_64-linux-tinfo6/c2065939853687d3b917dc14a46e015f4c1b8a675e80255c512c39e2a2b6c846/8.6.5/pkgdb describe --simple-output minio-hs --expand-pkgroot
02:05:24 <tabaqui1> what could cause this?
02:15:26 <tabaqui1> nevermind, "stack clean" solved the problem
02:19:54 * hackage wrecker 1.3.2.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-1.3.2.0 (lorenzo)
02:24:24 * hackage pantry 0.3.0.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.3.0.0 (MichaelSnoyman)
02:31:02 <AWizzArd> Here an excerpt: data AndOrNotTree a = Leaf a | AndNode (AndOrNotTree a) (AndOrNotTree a) | ..         
02:31:27 <AWizzArd> What extension do I need, so that I can write    (AndOrNotTree a) |&&| (AndOrNotTree a)      without the AndNode constructor?
02:32:46 <MarcelineVQ> you can't use | there afaik but you could write:  data AndOrNotTree a = Leaf a | (AndOrNotTree a) :&&: (AndOrNotTree a) | ...
02:32:46 <boxscape> I don't think there's a way around operator constructors having to start with :
02:32:48 <solonarv> you don't need an extension, but the constructor-operator has to start with a :
02:33:23 <AWizzArd> Okay, so then be it   (AndOrNotTree a) :&&: (AndOrNotTree a)
02:33:25 <MarcelineVQ> it's not without a constructor though, :&&: is the constructor
02:33:37 <AWizzArd> But what extension would do this?
02:33:42 <MarcelineVQ> You dn't need one
02:36:04 <SomeDude> @help
02:36:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:36:10 <boxscape> you don't nee the parentheses either by the way, you can write `AndOrNotTree a :&&: AndOrNotTree a`
02:38:58 <hoppfull> Hello, when installing packages with for example "stack install hlint", a file "hlint" appears in "/home/.local/bin". Is that all or does other things happens as well? Because stack doesn't appear to have an "uninstall" option so I just want to be sure that I can clean up my system if I have to.
02:40:22 <AWizzArd> Thx, works!
02:40:47 <MarcelineVQ> hoppfull: it would also place the other things it needed to build hlint, like ghc and hlint dependencies, in ~/.stack/
02:41:52 <hoppfull> MarcelineVQ: ok cool so I can effectively get a clean state by removing ~/.stack and ~/.local/bin
02:42:26 <MarcelineVQ> yes, though take care what's in .local/bin since it's not only stack that might use that
02:42:45 <hoppfull> ok
02:42:54 <hoppfull> awesome, thanks!
02:43:16 <AWizzArd> Can I also have unary prefix-operators instead of alphabetical-named constructors?  I.e.  instead of   NotNode (AndOrNotTree a)       something like   :! (AndOrNotTree a)
02:44:10 <boxscape> you can have (:!) AndOrNotTree a, I don't think it's possible without parentheses
02:47:27 <tdammers> you can also configure stack to install binaries elsewhere
02:47:43 <AWizzArd> boxscape: with parens it works, thx!
02:47:45 <tdammers> e.g., you may want to make it dump binaries in ~/.stack/bin/, and just add that to your path
02:48:00 <phadej> lookup PostfixOperators extension
02:49:05 <hoppfull> tdammers: how do I configure stack to do that?
02:49:28 <boxscape> I had an idea once about how now with the way parsing for @, ! and ~ works, you could have an extension that makes things like `a + b` infix, `b +a` prefix (i.e. b ((+) a)), and `b+ a` suffix (i.e. ((+) b) a) operators
02:49:37 <boxscape> though I suspect it wouldn't be a very popular idea
02:49:58 <boxscape> s/suffix/postfix
02:51:16 <AWizzArd> boxscape: maybe via Template Haskell?
02:51:16 <tdammers> hoppfull: you're on your own, I haven't actually used stack for years. Oh well, it took all of 30 seconds to look it up: https://docs.haskellstack.org/en/stable/yaml_configuration/#non-project-specific-config
02:51:46 <hoppfull> tdammers: my appologies, I realise I should've looked that up myself, thank you for your patience! :S
02:52:01 <tdammers> np, and I'm nowhere near as angry as I made it sound ;)
02:52:45 <MarcelineVQ> I am, grrrr, grrrrr! Why do they package scissors in packaging that needs scissors to open!
02:52:58 <hoppfull> tdammers: you haven't by any chance replaced stack with nix?
02:53:11 <tdammers> nope, just plain old cabal
02:53:19 <AWizzArd> In Servant I can compose my routes via :> and :<|>, for example:    ... :<|> "availableTimeseries" :> QueryParam "until" UTCTime :> Vault :> Get '[JSON] [AvailableTimeseries]  :<|> ...
02:53:19 <tdammers> I gave nix a spin, but didn't like it a bit
02:53:43 <MarcelineVQ> nix is great as long as someone else is writing the configs
02:53:44 <AWizzArd> How can I add my own "QueryParam" or "Vault"  „things”
02:53:49 <tdammers> the idea is lovely, but the practical implementation is just too far from "production ready" for me to consider
02:53:52 <AWizzArd> Types I guess.
02:53:58 <tdammers> MarcelineVQ: that, yes, among other things.
02:54:32 <tdammers> I am convinced that inventing a new language, for example, was a grave mistake
02:54:34 <hoppfull> I'm trying out nix right now and I'm a little bit disapointed that when I uninstall something, it still leaves stuff behind which tells me that it's not as declarative as they claim it is
02:55:11 <dminuoso> For a local repository, how do I create the index tar gz?
02:55:30 <tdammers> people already have to wrap their heads around the semantics and concepts of nix-style package management; asking them to also casually learn a full-blown programming language just to use the system is asking a bit too much
02:55:43 <dminuoso> (And why were file+noindex:// repos removed from cabal *sigh*)
02:55:47 <tdammers> especially when that language is underdocumented and not used for anything else (and thus not a very tempting investment)
02:56:50 <AWizzArd> hoppfull: would the nix GC remove those remains?
02:57:18 <tdammers> I also dislike nix' example-driven culture
02:57:24 <AWizzArd> tdammers: learning this new lang prevents me from getting started faster. Only from time to time I invest somem moments and read a bit more about it.
02:57:26 <hoppfull> AWizzArd: It doesn't appear to be.
02:57:45 <hoppfull> AWizzArd: I'll double check
02:58:01 <tdammers> when you ask a question, people will often just write your nix derivations for you, but what I'd want is some pointers that help me understand what the fuck I'm doing
02:58:11 <tdammers> "teach me to fish"
02:58:27 <tdammers> but all they give me is pickled herring
02:59:32 <AWizzArd> tdammers: I just want to get started and feel tempted to ask someone to just hand me over the 1-3 files that I need, with a few dependencies, such as postgres drivers and megaparsec.
02:59:47 <AWizzArd> I understand tho that this would be the fish, and not the skill to fish.
03:05:58 <dminuoso> Also, why do GHC binaries need a zlib shared library?
03:06:12 <merijn> tdammers: Yeah, this is why I prefer v2-build to Nix :p
03:07:12 <dminuoso> tdammers: Sadly, nixos is much less headache inducing than the alternatives. :P
03:07:23 * hackage tracked-files 0.1.0.0 - Package to list all tracked and untracked existing files via Git.  https://hackage.haskell.org/package/tracked-files-0.1.0.0 (joshuaclayton)
03:08:01 <phadej> dminuoso: as in `ghc` or compiled with `ghc`?
03:08:12 <dminuoso> compiled with ghc
03:08:15 <tdammers> dminuoso: at least with debian, I get to offload much of the headache to a bunch of faceless "contributors"
03:08:29 <merijn> dminuoso: Must be one of your dependencies
03:09:10 <dminuoso> Is there a way to find out which?
03:10:17 <phadej> probably `zlib` :)
03:10:20 <merijn> dminuoso: Run ldd on all the libraries you in your store? :p
03:11:46 <dminuoso> Ohh hold on! phadej, it's ghc itself!
03:12:19 <dminuoso> merijn: Thanks, that actually helped! :)
03:12:42 <dminuoso> A dirty quick `find ~/cabal|grep ".so"|xargs ldd|grep zlib` revealed the culprit :)
03:13:01 <merijn> dminuoso: eh, my ghc doesn't depend on zlib
03:13:15 <merijn> Which GHC version?
03:13:56 <phadej> nor mine
03:14:05 <dminuoso> Oh mmm. I think I read this wrong heh https://gist.github.com/dminuoso/b4292c6ea189f2c5f1cf4cb5022c8a40
03:14:18 <dminuoso> It's the haskell zlib library indede.
03:14:29 <dminuoso> Just spotted `ghc` and made the wrong connectoin
03:29:26 <kuribas> runRedis runs the redis monad: https://hackage.haskell.org/package/hedis-0.12.11/docs/Database-Redis.html#v:runRedis
03:29:34 <kuribas> however this uses lazy IO
03:29:44 <kuribas> doesn't that mean it can use the connection after this function ends?
03:31:23 <kuribas> According to this page: http://informatikr.com/2012/redis-pipelining.html
03:33:37 <phadej> 2012...
03:34:14 <phadej> but yes, there looks to be unsafeInterleaveIO in the source
03:34:31 <kuribas> phadej: it's linked to in the latest version
03:35:36 <kuribas> the only way I would see it work is by doing deepseq on the result
03:35:51 <phadej> there's comment in the source
03:35:51 <phadej>  -- Evaluate last reply to keep lazy IO inside runRedis.
03:35:52 <phadej>   readIORef ref >>= (`seq` return ())
03:37:15 <kuribas> does that garantee the connection is not needed?
03:37:44 <kuribas> if the refs are created eagerly that could work...
03:49:15 <phadej> at this point you should ask the author
04:09:42 <fendor> does `cabal install` read the env file at ~/.ghc/x86_64-linux-8.6.5/environments/default and it influences the install plan?
04:14:52 <AWizzArd> dminuoso: I stumbled upon the same thing, when I wanted to compile our existing code base in a nix-shell. I had to add zlib.
04:15:39 <AWizzArd> phadej: in Servant I have „combinator types” in the routes, such as QueryParam or QueryParams or Vault and GET. Is it possible that I add my own?
04:15:57 <AWizzArd> phadej: for example: I would like to place the permissions that you need to access a route into the route description.
04:16:08 <AWizzArd> And also the information if a user must be logged in or not.
04:22:24 * hackage hip 1.5.5.0 - Haskell Image Processing (HIP) Library.  https://hackage.haskell.org/package/hip-1.5.5.0 (lehins)
04:54:01 <phadej> AWizzArd: yes, but there are no docs for that. Look up how existing combinators are implemented.
04:57:16 <kuribas> AWizzArd: yes, Servant was meant for that.  You need to make your own typeclasses and typefamilies for each consumer of the type (server, client, foreign-code generator, etc...)
04:57:51 <phadej> not typeclasses nor typefamilies, but instances...
04:59:21 <kuribas> yeah
05:23:00 <zincy_> Is it not a big architecture smell if each API service has its own types and another common set of types and these are marshalled between each other for communication?
05:23:20 <zincy_> Surely that is a sign that you have split the same service into two APIs?
05:26:52 <merijn> zincy_: Decoupling types in your code from the "wire format" is generally a good idea
05:27:11 <merijn> zincy_: So "not necessarily"
05:27:53 * hackage homplexity 0.4.7.0 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.7.0 (MichalGajda)
05:31:41 <zincy_> merijn: Thanks
05:32:02 <zincy_> merijn: Is it not bad for services to share data?
05:32:23 <zincy_> I thought each service should own a particular domain of data
05:33:12 <kuribas> merijn: this decoupling I miss in our code, we sometimes go from the database query straight to the endpoint return value.
05:33:16 <merijn> zincy_: You need a common language/protocol for services to talk to eachother
05:34:18 <kuribas> merijn: (as a clojure hashmap)
05:34:20 <merijn> kuribas: Word, every time I skip that decoupling I end up having to retroactively build it in :p
05:34:23 <tabaqui1> how can I make kind alias? like "type MonadLike = Type -> Type; data MonadWrapper (m :: MonadLike) = ..."
05:36:03 <tabaqui1> nvm :)
05:36:16 <lortabac> zincy_: do they need to be different services?
05:38:30 <zincy_> lortabac: I am not sure as I am just helping out
05:38:52 <zincy_> So decoupling types in services generally good. Better to avoid sharing them
05:39:30 <zincy_> merijn and kuribas: When you start a project with multiple services do you generally avoid a shared module with types?
05:39:59 <merijn> zincy_: Well, it's more that decoupling "types inside code" and "types going over the network" is good. Whether different services use a single shared set of types then become irrelevant
05:40:26 <merijn> zincy_: Since you can now change service "foo" to use different types internally (while using the same stuff on the network) without anyone talking to foo noticing
05:43:53 <AWizzArd> kuribas: Can you say more about this? You do a DB query, Clojure gives you a map, and this you return (json/edn) to the client/consumer?
05:44:52 <zincy_> merijn: Ah thanks that is helpful
05:46:54 <merijn> zincy_: And the reverse is true, you can upgrade the network protocol every service speaks without needing to change the actual internal implementations
05:47:23 <zincy_> Are there any good reads on this sort of thing?
05:47:33 <zincy_> I guess it just basic architecture?
05:47:43 <zincy_> Not that Haskell specific
05:49:21 <merijn> zincy_: I learned the hard way, so I don't really have a recommendation :p
05:49:53 * hackage Color 0.1.4 - Color spaces and conversions between them  https://hackage.haskell.org/package/Color-0.1.4 (lehins)
06:00:54 * hackage fused-effects 1.0.2.0 - A fast, flexible, fused effect system.  https://hackage.haskell.org/package/fused-effects-1.0.2.0 (robrix)
06:16:54 * hackage egison-pattern-src 0.2.0.0 - Manipulating Egison patterns: abstract syntax, parser, and pretty-printer  https://hackage.haskell.org/package/egison-pattern-src-0.2.0.0 (coord_e)
06:17:54 * hackage egison-pattern-src-th-mode 0.2.0.0, egison-pattern-src-haskell-mode 0.2.0.0 (coord_e): https://qbin.io/doors-susan-hkf3
06:41:54 * hackage lean-peano 1.0.1.0 - A maximally lazy, simple implementation of the Peano numbers with minimal dependencies  https://hackage.haskell.org/package/lean-peano-1.0.1.0 (oisdk)
06:58:13 <uglyoldbob> If i am using Date.Time (getCurrentTime), how might I get a function of (UTCTime -> Int) ?
06:58:15 <uglyoldbob> *Main Data.Time> getCurrentTime
06:58:52 <uglyoldbob> Perhaps blab getCurrent returns [2020,3, 3, 14, 57]
06:58:57 <merijn> uglyoldbob: Well, what's that Int supposed to be?
07:02:18 <boxscape> seems like you want UTCTime -> [Int]?
07:02:25 <uglyoldbob> ultimately I want all of year, month, day, hour, minute, second. I don't really care if its one function or multiple to get those.
07:02:33 <merijn> That seems like a super broken type :p
07:03:23 <merijn> uglyoldbob: If you look at the Haddock's you'll see that UTCTime is a Day (which encode year/month/day) and DiffTime which encodes the time within that day
07:04:06 <merijn> uglyoldbob: Date.Time.Calendar has (for example) "toGregorian :: Day -> (Integer, Int, Int)"
07:04:58 <uglyoldbob> ah, i see now
07:06:09 <merijn> uglyoldbob: You need to browse through the modules a bit since things are a bit scattered
07:06:25 <merijn> But it's all there somewhere :)
07:11:24 <merijn> uglyoldbob: You probably also want TimeOfDay from Data.Time.LocalTime
07:26:58 <uglyoldbob> merijn: thank you, was exactly what i was looking for
07:58:44 <merijn> hmmm...so anyone here have experience with using head.hackage?
07:59:28 <merijn> What's the simplest/easy way to plug that into my cabal.project?
08:05:28 <boxscape> does the syntax of writing "f x" rather than "f(x)" ultimately derive from lisp (via ML)?
08:07:46 <tdammers> I'd wager it was stolen from math
08:08:01 <ChaiTRex> boxscape: I think it's just because of currying, which Lisp doesn't really do automatically.
08:08:01 <tdammers> lisp uses (f x), not f x
08:08:49 <boxscape> tdammers true, but I figured it might have been inspired by that
08:08:55 <tdammers> ChaiTRex: that's a weird way of putting it. Haskell doesn't "automatically curry", it just doesn't have functions of arities other than 1
08:09:12 <boxscape> but yeah a relation to currying makes a lot of sense
08:09:58 <remexre> asked it before, but I'm getting bugged about it again, so I'll ask it again; does there exist a good diagramming approach for very-high-level documentation of Haskell programs? so far I've been using the dependency graph of the modules, but it's not ideal by a long-shot
08:11:17 <merijn> hmm
08:11:26 <merijn> Is there an alternative to random-fu/random-extras?
08:11:52 <merijn> carter: ping? :)
08:12:25 <sm[m]> remexre: does SourceGraph do anything for you ?
08:13:17 <sm[m]> I once made a UML diagram, using plantuml : https://hledger.org/CONTRIBUTING.html#hledger-lib
08:13:39 <remexre> sm[m]: haven't used it before, I'll look
08:14:40 <sm[m]> here's the source.. pretty maintainable: https://github.com/simonmichael/hledger/blame/master/CONTRIBUTING.md#L349
08:15:38 <sm[m]> I guess you're using https://hackage.haskell.org/package/graphmod
08:16:02 <remexre> heh, I probably ought to be
08:16:04 <remexre> I'm using sed
08:17:47 <remexre> sourcegraph looks more like a really nice IDE than what I'm looking for (just a graph), but I might be missing some graph-view
08:18:19 <remexre> I'll consider the UML
08:18:26 <sm[m]> there's also: draw diagrams on paper or a whiteboard and take a photo
08:18:28 <merijn> remexre: Have you looked at cabal-plan?
08:18:53 <merijn> Oh wait, are we talking dependencies or modules?
08:19:10 <carter> merijn: hey!
08:19:39 <AWizzArd> boxscape:  map even [10, 20, 30]  in sexp syntax ((map even) '(10 20 30))
08:20:07 <AWizzArd> If it would support curried functions.
08:20:36 <remexre> merijn: not necessarily either
08:20:53 <remexre> like the maximally useful documentation for hacking on a codebase
08:21:12 <remexre> which probably is neither just the modules nor just the types
08:21:58 <remexre> honestly, wonder if there's some control/data-flow analysis one could do to "prune" the unimportant parts of a very dense graph... hm
08:22:10 <sm[m]> remexre: I guess it's helpful to think about what insights/aspects you want to communicate, in each case there's probably a different approach that works best
08:23:19 <sm[m]> another thing I find helpful is to generate org outlines, and use org mode to navigate/limit detail
08:25:03 <sm[m]> https://graphcommons.com could be fun, too
08:25:23 <remexre> huh, I'll give that a look; thanks
08:25:45 <remexre> I guess I probably want like 3 or 4 graphs
08:25:54 <remexre> that ideally I'd generate from source
08:26:35 <remexre> and realistically I'll just put a "last updated: $git_commit_hash" in the center, in some position that makes it hard to accidentally miss
08:31:24 * hackage hedgehog-fakedata 0.0.1.1 - Use 'fakedata' with 'hedgehog'  https://hackage.haskell.org/package/hedgehog-fakedata-0.0.1.1 (parsonsmatt)
08:37:25 <boxscape> I asked this before but I don't remember - how can you use something like `makeLenses ''A` inside ghci? (IIRC there was a way)
08:37:33 <glguy> Yes you can
08:37:55 <boxscape> but how :)
08:38:33 <geekosaur> probably need to use $()
08:39:03 <geekosaur> since it's not really a toplevel, so it can't use the implicit toplevel-expression-is-a-splice thing ghc does in a file
08:39:04 <glguy> % data A = MkA { _aInt :: Int, _aBool :: Bool } ; makeLenses ''A
08:39:04 <yahb> glguy: 
08:39:10 <glguy> % :t aInt
08:39:10 <yahb> glguy: Functor f => (Int -> f Int) -> A -> f A
08:39:10 <boxscape> ah, thanks
08:39:41 <glguy> Easiest way is to add a trailing ;
08:39:53 <boxscape> okay
08:40:16 <boxscape> pretty sure that was the advice I got last time as well :)
08:44:20 <boxscape> you can even do
08:44:25 <boxscape> % ; makeLenses ''A
08:44:25 <yahb> boxscape: 
08:44:51 <Zemyla> Okay. In this:
08:44:56 <Zemyla> @let constfoo :: (forall b. Const a b -> c) -> a -> c; constfoo f a = f (Const a)
08:44:58 <lambdabot>  Defined.
08:45:13 <Zemyla> Is b assigned to anything when the universal is instantiated?
08:48:17 <glguy> Zemyla: Looking at -ddump-simpl it appears to be instantiated as GHC.Types.Any
09:07:15 <dminuoso>   error, called at ./Distribution/Client/ProjectOrchestration.hs:532:9 in main:Distribution.Client.ProjectOrchestration
09:07:16 <dminuoso> I feel lucky!
09:08:28 <dminuoso> Haha, this is a funny bug! :)
09:20:10 <remexre> huh, any reason there aren't instances of Generic Word8, Generic Word16, etc?
09:24:52 <boxscape> is there a Generic instance for Int?
09:25:31 <glguy> No, Generic instances are for algebraic data types
09:26:04 <boxscape> data Int = I# Int#
09:26:07 <boxscape> seems like an ADT
09:26:24 <glguy> That's an implementation detail
09:29:04 <solonarv> the Generic mechanism probably can't handle fields with a representation other than 'Lifted
09:29:22 <boxscape> solonarv you can derive Generic for Int
09:29:39 <boxscape> might not be usable though for all I know
09:30:07 <glguy> Int is intended to be abstract, it shouldn't expose incidental details about how it is implemented through Generic
09:31:39 <boxscape> right, I believe you, that was only response to solonarv's statement
09:31:45 <glguy> data A = MkA Int# Int# deriving Generic; > from (MkA 4# 5#); M1 {unM1 = M1 {unM1 = M1 {unM1 = UInt {uInt# = 4#}} :*: M1 {unM1 = UInt {uInt# = 5#}}}}
09:32:01 <boxscape> to (from (4 :: Int)) doesn't seem to work though
09:32:22 <glguy> Int isn't supposed to have a Generic instance, so what you wrote won't work
09:33:13 <boxscape> okay
09:33:49 <boxscape> oh, it does work though if I give it a type annotation?
09:34:08 <boxscape> as in, `to (from (4 :: Int)) :: Int` evaluates to 4
09:34:21 <glguy> Only if you add your own Generic instance for Int
09:34:50 <boxscape> Oh, sorry, I misread what you pasted above and thought that's what we were talking about :)
09:36:40 <urinal666> help help why are some people so fanatic about haskell and why is it better than clojure?
09:38:02 <tabaqui1> you better ask on #closure
09:38:18 <urinal666> but
09:38:33 <urinal666> i am really confused
09:38:46 <tabaqui1> why don't you ask "some" people?
09:38:51 <Uniaika> learn it and you will know why
09:39:47 <boxscape> urinal666 I haven't done much clojure but generally speaking what I like about haskell and miss about other languages is the strict type system that prevents me from making dumb mistakes
09:39:59 <boxscape> at compile time
09:40:13 <tabaqui1> bad answer: "why do you believe in God? make a 10-years journey and you will know why"
09:40:15 <davean> I believe clojure is trying to optimize for a different set of goals.
09:40:16 <tabaqui1> Uniaika: ^
09:40:32 <urinal666> but i am a newbie
09:40:34 <urinal666> well
09:41:00 <tabaqui1> Haskell is more safe and faster than Closure
09:41:04 <davean> If you have any questions about Haskell though I'm sure we'd be glad to help.
09:41:07 <tabaqui1> Closure is better for LOP
09:42:03 <solonarv> oh it does have things for unboxed types, I misremembered
09:49:13 <urinal666> is assembly goo for tacit programming?
10:01:24 * hackage lingo 0.3.1.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.3.1.0 (tclem)
10:02:23 * urinal666 declares: a catholic priest (man) is inserting his penis in to a 6 year old boy who is screaming in terror
10:07:00 --- mode: ChanServ set +q *!*@2001:999:12:56c2:49bb:6018:e19d:cad3
10:09:17 <MarcelineVQ> Now I will never know if assembly is goo for tacit programming
10:20:18 <Uniaika> do we *really* want to know, however?
10:24:54 * hackage hspec-hedgehog 0.0.1.1 - Integrate Hedgehog and Hspec!  https://hackage.haskell.org/package/hspec-hedgehog-0.0.1.1 (parsonsmatt)
10:27:54 * hackage persistent-typed-db 0.1.0.1 - Type safe access to multiple database schemata.  https://hackage.haskell.org/package/persistent-typed-db-0.1.0.1 (parsonsmatt)
10:41:24 * hackage rib 0.7.0.0 - Static site generator using Shake  https://hackage.haskell.org/package/rib-0.7.0.0 (sridca)
10:43:27 <kirill> hi all! let's say I have a type, data Language = English | Spanish. is there a typesafe way to associate specific values with each constructor? eg. something hypothetically like data Language = English ("en", "English") | Spanish ("es", "Spanish)
10:43:56 <evelyn> a Map?
10:44:05 <kirill> sure but... there is a finite number of languages that's known at compile time
10:44:10 <johnw> or a function Language -> String
10:44:16 <ChaiTRex> kirill: You can make two functions.
10:44:31 <kirill> is it possible to get a compiler error if I add another language in the future but forget to update my function?
10:45:07 <solonarv> yes, in fact that's a warning already
10:45:22 <solonarv> you can make it into an error but I forget what the flag for that is
10:46:16 --- mode: ChanServ set +o johnw
10:46:16 --- mode: ChanServ set +o johnw
10:46:16 --- mode: ChanServ set +o johnw
10:46:16 <ChaiTRex> kirill: -Wincomplete-patterns with maybe -Werror
10:46:17 --- mode: johnw set -o johnw
10:46:24 --- mode: ChanServ set +o johnw
10:46:27 --- mode: johnw set +b *!~ydgfdhh@ncsfz8qkmnc9waeab-2.v6.elisa-mobile.fi
10:46:31 --- kick: urinal666 was kicked by johnw (Kicked)
10:46:31 --- mode: johnw set -o johnw
10:47:06 <kirill> ok. I think the issue here is that I want to be able to find a language based on a language code, which obviously returns Maybe (or Either), but I also want to be able to look up a language code based on a language
10:47:13 <kirill> but I don't want to keep the "table" or whatever in two places
10:47:18 <solonarv> yeah, I figured it was something like that
10:47:40 <solonarv> I found myself wanting something similar a few times, but I can't recall finding a really satisfactory situation
10:47:48 <solonarv> I didn't look very hard, though
10:47:48 <geekosaur> you can combine those, I believe: -Werror=incomplete-patterns
10:48:40 <kirill> the problem is that when you're looking up a value using (case x of ...), it's easy to get a compiler error if you missed one. but in the function that looks up a value based on language code, what is being "searched" here? if I had a list of all possible localizations I will no longer get a warning/error if I add a new language and forget to update that list
10:48:43 <ChaiTRex> kirill: Maybe use Data.Bimap
10:49:08 <kirill> ChaiTRex: will I be reminded before the program runs if I'd forgotten to update the bimap with a new language data constructor I added?
10:49:48 --- mode: ChanServ set +o glguy
10:49:49 --- mode: glguy set -qb+b-o *!*@2001:999:12:56c2:49bb:6018:e19d:cad3 *!~ydgfdhh@ncsfz8qkmnc9waeab-2.v6.elisa-mobile.fi *!*@2001:999:12:56c2:49bb:6018:e19d:cad3 glguy
10:49:50 <kirill> I suppose I could hack it by having a function that looks up a language in the map (using English or Spanish in my case) using a case purely to let the compiler take action if I forgot a value
10:50:01 <solonarv> hm, I vaguely recall something (a bit of template haskell, maybe?) to make sure that a function is surjective
10:50:03 <kirill> ... but it still requires some unsafe forcing (ie fromJust)
10:50:33 <ChaiTRex> kirill: You can probably derive Enum and write a test, perhaps with Template Haskell.
10:54:57 <dmwit> kirill: With the universe package, you can implement `Ord a => (Language -> a) -> a -> Maybe Language`. Then you write your `Language -> a` once and for all, getting nice warnings for missing patterns, and invert it using the combinator to get your other direction.
10:55:31 <dmwit> possibly `... -> [Language]` instead, I suppose
10:56:28 <dmwit> invert f = M.findWithDefault [] (M.fromListWith (++) [(f l, [l]) | l <- universeF])
10:56:46 <dmwit> Of course you may also use `[minBound .. maxBound]` instead of `universeF` if you want to avoid the dependency.
10:57:31 <dmwit> :t \f -> M.findWithDefault [] (M.fromListWith (++) [(f l, [l]) | l <- [minBound .. maxBound]])
10:57:33 <lambdabot> (Ord k, Ord a1, Bounded a1, Enum a1) => (a1 -> k) -> M.Map (M.Map k [a1]) [a2] -> [a2]
10:57:49 <dmwit> whoops
10:57:52 <dmwit> :t M.findWithDefault
10:57:53 <lambdabot> Ord k => a -> k -> M.Map k a -> a
10:58:13 <dmwit> :t \f -> flip (M.findWithDefault []) (M.fromListWith (++) [(f l, [l]) | l <- [minBound .. maxBound]])
10:58:15 <lambdabot> (Ord k, Bounded a, Enum a) => (a -> k) -> k -> [a]
11:00:05 <kirill> uhuh, well that's quite a mouthful but I will read it slowly and figure it out. thank you :D 
11:01:17 <dmwit> :t traverse
11:01:19 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:03:17 <dmwit> I find the type signature of invert quite beautiful, actually.
11:05:56 <kirill> sure, I'm definitely a novice haskell programmer so it takes me a sec to get stuff for the time being :D 
11:16:54 * hackage immortal-queue 0.1.0.1 - Build a pool of queue-processing worker threads.  https://hackage.haskell.org/package/immortal-queue-0.1.0.1 (lysergia)
11:20:54 * hackage fast-arithmetic 0.6.5.0 - Fast functions on integers.  https://hackage.haskell.org/package/fast-arithmetic-0.6.5.0 (vmchale)
11:37:08 <merijn> How do I silence the MonadFailDesugaring deprecation warning in GHC 8.10? The warning doesn't mention
11:39:09 <geekosaur> generally with "no-" at the front
11:41:32 <merijn> geekosaur: Somehow I don't think -XNoMonadFailDesugaring combined with a pragma in the source will work great
11:42:53 <geekosaur> hm, but the warning itself isn't related to that, it's -Wno-deprecated-flags I think
11:45:29 * guhh declares: a catholic priest (man) is inserting his penis in to a 6 year old boy who is screaming in terror
11:46:07 <__monty__> @mods
11:46:07 <lambdabot> Maybe you meant: todo more docs
11:46:13 <__monty__> @moderators
11:46:14 <lambdabot> Unknown command, try @list
11:46:15 --- mode: ChanServ set +o geekosaur
11:46:20 <glguy> geekosaur: I already got it
11:46:28 <geekosaur> chanserv's being slow today, sigh
11:46:42 --- mode: geekosaur set -o geekosaur
11:48:54 <iqubic> So, when is 8.10.1 slated to be released?
11:51:24 <dashkal> Hmm.  I wonder what happened to Eta.  No movement since July
11:52:05 <__monty__> dashkal: I've heard on the grapevine that it was basically abandoned : (
11:52:17 <dashkal> It definitely looks that way.
11:52:59 <merijn> No, it's close
11:53:17 <merijn> Although I'm probably partially responsible for it getting delayed again >.>
11:53:23 <dashkal> ?
11:53:25 <geekosaur> eta, not 8.10.1, I think
11:53:44 <dashkal> Yeah.  I was tracking Eta.  Fork of GHC to target the JVM.  Seems to have died last summer.
11:53:45 <merijn> Ah, Eta was "basically abandoned" years ago
11:53:55 <merijn> Had like 1 or 2 people working on it
11:53:55 <__monty__> Yeah, merijn went and pulled an Arthur Dent on 8.10, not Eta.
11:54:32 <dashkal> Meh.  That's going to make using Haskell a ton harder.  I was hoping to use Eta as the gateway drug.
11:55:51 <__monty__> dashkal: I think I've heard something about Truffle/GraalVM, though that might have been about Coda.
12:08:59 <dashkal> I see some discussion on reddit, but it doesn't look like a ton came of it, at least in my quick searching.
12:09:15 <dashkal> Ok, another plan then.  Codegen for the data structures being passed around between components.
12:09:20 <gentauro> what happens when you write: `data Foo a b = F a b; x = F undefined undefined`? (memory wise)
12:12:32 <dmwit> You get a data structure with two pointers, both pointing to undefined.
12:13:23 <dmwit> Sorry, that's not quite right.
12:15:03 <dmwit> You get a closure which has a pointer to F and two pointers, one each to undefined and undefined. When evaluated, that code replaces itself (eventually) with a data structure that is directly a word indicating that it's an F and two pointers, both to undefined.
12:15:55 <dmwit> Optimizations may make it possible to omit the word indicating that it's an F in the second structure. I'm not sure.
12:17:42 <gentauro> dmwit: cool :)
12:17:55 <gentauro> dmwit: I like your answer :)
12:20:39 <solonarv> dmwit: optimizations might also skip the "closure" step, since the constructor is already known even at compile time
12:24:24 <__monty__> dashkal: That sounds a bit closer to inline-java's level of java interop.
12:34:13 <dashkal> __monty__:  I'm pretty ok with codegen, honestly.  Not having my data objects drift apart deals with most of the issue going polyglot.
12:40:06 <pja> Is frege still being developed?
12:48:54 <ChaiTRex> pja: see https://github.com/Frege/frege/tree/master
12:49:41 <pja> Last commit Oct 2019. Not entirely dead then :)
12:50:39 <ChaiTRex> pja: The issues also have committers commenting in like November at least.
12:50:55 <zeta_0> geekosaur: hello there, i would like to contribute to xmonad, i was wondering if tomorrow you could set aside a little bit of time to help me set some things up, i am currently using the nix package manager, so i would like to use that to develop xmonad with
12:51:42 <geekosaur> (a) better asking in #xmonad (b) I don't currently have much control over my own time, and in particular I won't be online much tomorrow
12:52:29 <merijn> heh
12:52:42 <merijn> v2-build doesn't look relative to the specified project file?
12:53:22 <zeta_0> geekosaur: it's ok, i understand, i'll ask this question in #xmonad later on
12:54:54 * hackage ghc-tags-plugin 0.1.1.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.1.0 (coot)
13:07:02 <dmwit> merijn: For what? It should look relative, but deeper-only, for packages.
13:08:45 <merijn> dmwit: If I have cabal.project in "foo/" pointing to subdirs "foo/bar" and "foo/baz" and I run cabal v2-build from foo/baz using "cabal v2-build --project-file=../cabal.project" then it will look for foo/baz/bar and foo/baz/baz
13:09:37 <phadej> locations are relative to cabal.project file
13:10:05 <merijn> phadej: Nope
13:10:16 <merijn> At least, not in the version I'm running
13:10:47 <phadej> at least `foo/baz/bar` is nonsense
13:11:34 <merijn> phadej: Well, that's the only way it could fail to find things from a subdir, but suceed from the root for as far as I can think of. Or there's some even weirder issues going on
13:11:36 <fendor> in hackage, how can I do a package revision as a maintainer? I would like to do a version bump of a dependency, without doing a new release. Or is that something only hackage trustees can do?
13:11:53 <merijn> fendor: Go to the maintainer's corner of your package
13:12:05 <phadej> merijn: project file not in the "root" of project directory is definitely not well-exercised code path
13:12:10 <glguy> fendor: click "edit package metadata" at the bottom
13:12:42 <merijn> phadej: It is in the root, I'm just calling it with an explicit --project-file from "not the root"
13:13:18 <fendor> ah, there I can edit the *.cabal file directly?
13:13:23 <fendor> thank you!
13:13:30 <ukari> https://plaster.tymoon.eu/view/1687 , I have a data Test = Foo | Bar, and have handwriting a show for Foo, is it possible to auto deriving Bar?
13:14:02 <merijn> phadej: i.e. "foo/" in the example was just a placeholder for "wherever my root is"
13:14:03 <geekosaur> no, an instance is for a type, not for specific constructors of the type
13:14:03 <phadej> merijn: do you have some different `cabal.project` in `foo` directory? Not that it should matter, but maybe it does :)
13:14:17 <fendor> still new to package maintenance :) 
13:14:33 <phadej> as --project-file=../cabal.project is redundant, cabal should work from sudirectories too
13:14:52 <merijn> phadej: Not if I want to also call some other cabal.project file from a subdir
13:15:14 <phadej> I have problems following
13:15:19 <phadej> sorry, ->
13:15:20 <merijn> phadej: i.e. I have cabal.project and cabal.project.ghc810 in my rootdir
13:15:44 <geekosaur> also it's generally a bad idea to write custom Read and Show instances unless there are reasons not to expose the internals (for example, something has a function in it or you are relying on an internal invariant like Map expects to be ordered)
13:15:54 * hackage hnix 0.7.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.7.1 (JohnWiegley)
13:17:09 <merijn> phadej: cabal-install is being called from the makefile of my project, and I was trying to set it up so the makefiles can call cabal with different project files (i.e. for different GHC versions), so I can't rely on cabal just "auto-detecting" the project file in the root, because it might need a different one (i.e. the ghc 8.10 version). But I noticed that if I do this then it breaks when I point it 
13:17:15 <merijn> explicitly at ../cabal.project
13:17:18 <c_wraith> I wrote a custom Show instance once because the generated one didn't respect constructor precedence where constructors were infix.
13:20:46 <ukari> geekosaur: I use Data.Text.Lazy with package text and the show function isn't works well when display stuff with utf8 encode, so I handwrite a show, is there any better solution?
13:21:06 <phadej> merijn: I see. Looks like that if you use `--project-file=` explicitly than cabal-install doesn't chdir. Both behaviours (changing and not-changing) are justified, so the best you can do is a write a patch adding `--project-root` flag.
13:21:56 <phadej> If you don't want write a patch, please don't complain and use (cd .. && cabal build --project-file=cabal.project)
13:22:21 <geekosaur> ukari, in general Show is for debugging and should reflect what you can type into ghc. (this has gotchas: you can't enter private use area characters into string literals, for example)
13:23:16 <ukari> well
13:23:37 <geekosaur> there are prettyprinting libraries which provide more control over output
13:23:57 <merijn> phadej: oh, there's a project-root flag? That's easy enough to plug into the makefile
13:24:05 <merijn> oh wait, there *isn't* one
13:24:09 <merijn> Right :p
13:35:05 <maralorn> Hm, I broke my setup very badly: <command line>: can't load .so/.DLL for: /nix/store/3ybbc3vag4mpwaqglpdac4v413na3vhl-ghc-8.6.5/lib/ghc-8.6.5/binary-0.8.6.0/libHSbinary-0.8.6.0-ghc8.6.5.so (/nix/store/3ybbc3vag4mpwaqglpdac4v413na3vhl-ghc-8.6.5/lib/ghc-8.6.5/binary-0.8.6.0/libHSbinary-0.8.6.0-ghc8.6.5.so: undefined symbol: base_DataziTypeableziInternal_typeRepKind1_closure)
13:35:08 <maralorn> But I don‘t know how to fix this.
13:36:12 <maralorn> Apparently entering and leaing nix-shells left me in a state where something got linked about something else which cannot be found anymore?
13:38:25 <maerwald> Hm, when I wrap an alternative in optparse-applicative inside an optional, it somehow defaults to the first constructor if none of the alternative arguments are given.
13:38:31 <maerwald> Although it is wrapped in a Maybe
13:39:10 <merijn> maerwald: code examples, plx
13:40:34 <Jonathan86> Hello.  I am looking for a little advice on a Haskelly solution to a problem I am facing with Typeclasses.
13:41:00 <jle`> how is the advice search going?
13:42:08 <Cale> It may help to describe the problem ;)
13:43:01 <Jonathan86> I am working on a general library for shape collisions.  I have a typeclass `Overlappable` which has a method `distance` to calculate the distance between to colliders.
13:43:02 <jle`> maerwald: not sure what you mean exactly, but `optional x` will never fail
13:43:56 <Jonathan86> It is a multiple param typeclass to allow different types to collide (AABBs with Circles, etc) `Overlappable a b`
13:44:58 <Jonathan86> But the problem is I do not want the number type used to be defined (it could be Float or Double).
13:45:11 <maerwald> I mean this https://gist.github.com/hasufell/b248cb140a3274c8e4a5354e5bc64acf#file-opt-hs-L12
13:45:19 <Cale> You can make the instances depend on the number type
13:45:26 <maerwald> Nothing never happens
13:46:04 <maerwald> so: optional (p1 <|> p2) -- doesn't work as expected
13:46:05 <jle`> define nothing
13:46:12 <Jonathan86> What was working best was doing `Overlappable num a b`.
13:46:26 <Cale> hmm
13:46:30 <Jonathan86> But that requires `num` to be specified on most calls.
13:46:40 <Cale> I don't know why you'd need an additional parameter
13:46:52 <maerwald> jle`: a constructor of Maybe
13:46:59 <jle`> Jonathan86: do you want to restrict what number types are available, or "distance should always work for any number type"
13:47:16 <Cale> What happens if you just define instances like  instance Num a => Overlappable (Ellipsoid a) (AABB a)
13:47:44 <maralorn> Would that be a use case for functional dependencies: a b -> num?
13:48:03 <hyperisco> What if you just have  ellipsoidOverlapsAABB :: Num a => Ellipsoid a -> AABB a -> Boolean  ?
13:48:10 <Cale> You probably would want such functional dependencies
13:48:22 <Cale> If you were going that route
13:48:31 <Cale> Yeah, this class feels a bit suspicious
13:49:08 <Jonathan86> Um, Cale: I did something with that, I don't remember what stopped me.  One sec.
13:49:16 <hyperisco> I am guessing these operations induce some lattice
13:49:22 <jle`> Cale: it was me. i stopped you
13:49:25 <jle`> * Jonathan86 
13:49:37 <jle`> :)
13:49:58 <maralorn> Jonathan86: But are your Object Types even parametrecised over the num type?
13:50:00 <hyperisco> if it is CSG then a Heyting Algebra perhaps
13:50:01 <jle`> but in all seriousness, i'm definitely curious to see
13:50:33 <Cale> I would be tempted to find some way to define a sufficiently generic single type for shapes that I'd need to intersect. I'm imagining in most situations you'll have a scene with many different types of shapes, and specifying all the n^2 instances you want is going to be tedious
13:51:25 <maralorn> Does a .so file that does not define any symbols make any sense?
13:51:35 <Jonathan86> Oh, If I do that Cale, how do I define the return type of distance?  `shapeDistance :: a -> b -> num`.
13:51:59 <Cale> Jonathan86: Ah, right, okay
13:52:28 <Cale> That's fair enough. Another option is to use an associated type, but that's approximately the same thing
13:52:41 <Jonathan86> Actually that might work, I stopped because the `num` would need to be constrained more but it could be constrained in the instance definition.
13:52:47 <hyperisco> class Overlappable (f :: Type -> Type) (g :: Type -> Type) where shapeDistance :: Num a => f a -> g a -> a
13:52:51 <hyperisco> Something like that possibly
13:53:09 <Cale> Yeah, that's another option
13:53:31 <Cale> Forces all the types you're writing instances for to be parametric
13:53:50 <hyperisco> can use a type family, if you must
13:53:58 <solonarv> or perhaps 'Maybe a' - return Nothing if they overlap, Just something positive otherwise
13:54:04 <solonarv> you can bikeshed this endlessly ;(
13:54:07 <solonarv> * ;)
13:54:28 <Jonathan86> lol!
13:55:43 <hyperisco> class Overlappable m n where type Number m n = a; shapeDistance :: Num a => m -> n -> a
13:55:50 <hyperisco> iirc the syntax
13:56:18 <solonarv> er, no, where does 'a' come from?
13:56:24 <hyperisco> the type family
13:56:50 <Cale> class Overlappable m n where type Distance m n; shapeDistance :: m -> n -> Distance m n
13:56:58 <solonarv> doesn't work like that, if you want to refer to the type family it's 'Number m n'
13:57:04 <hyperisco> maybe you can't name it like that, okay
13:57:08 <maralorn> hyperisco: Can‘t you put the Num constraint on the type declaration?
13:57:47 <Cale> There's no need for the Num constraint, presumably each instance will specify a type which has the properties it wants.
13:58:01 <hyperisco> fair :)
13:58:35 <maralorn> I am conceptually a bit confused by the fact that the type of distance between to things is dependent on the type of the things.
13:59:15 <solonarv> the secret is that 'm' and 'n' are probably parameterized somehow
13:59:17 <hyperisco> I think realistically you'd have the things parameterised
13:59:29 <Cale> It's probably sufficient to just say it's a Double :P
13:59:30 <hyperisco> on an affine space or some such
13:59:36 <solonarv> but really, you should always be able to map the distance to R \cup {±\infty}
13:59:55 <solonarv> in a sensible way, that is
14:00:00 <hyperisco> but who likes the extended reals? gross
14:00:28 <solonarv> you probably don't need the infinities, but practically speaking "real numbers" probably means Double
14:00:32 <hyperisco> solonarv, sensible = injective I think ;)
14:00:35 <solonarv> and that has infinities already
14:00:40 <Jonathan86> Ah, shoot.  `Overlappable a b where shapeDistance :: a -> b -> num` is not working.  GHC complains when I make an instance that `num` is not the same as `num1`.  (I understand why.)  I guess I typefamilies is the best solution.
14:00:51 <solonarv> hyperisco: also preserving things like triangle inequality and so on
14:01:19 <Cale> Jonathan86: Well, that says that shapeDistance produces a value of any type demanded whatsoever
14:01:39 <Jonathan86> Right.
14:01:40 <Cale> (which basically means it can only go into an infinite loop or throw an exception)
14:02:05 <hyperisco> *shrug* I like the idea of keeping geometry as simple as possible solonarv
14:02:22 <hyperisco> since there seems to be no end to complications
14:04:01 <Cale> I'm not sure if I 100% believe that this type class is a sensible abstraction to make. I think it's doable, but it's either going to be annoying to use in any real case, or you'll just end up with one instance where you make a general-enough Shape type and then define it all at once.
14:05:19 <hyperisco> particularly if there is any desire to have a collection of overlappable things, this isn't an attractive way to go
14:05:43 <Cale> Yeah, that's specifically what I was about to mention as well :)
14:05:53 <Jonathan86> solonarv: Games typically use `Float`s (I think because of speed or because that is what the GPU needs, not sure).  But I also do not want to rule out Double (I know I might have reason to use it), also in a pixelated game I want to use an `Int`.
14:06:48 <Cale> It's probably best to start by writing more of the actual code for the things, and then worry about what abstractions seem appropriate to clean it up.
14:08:00 <Cale> If you want to make a collection of differently-typed shapes, you won't be able to get away with using existentials that involve this Overlappable class
14:08:16 <Jonathan86> Cale: Physics engines typically have a number of different collider shapes because one cannot also be the right one (concave polygons can represent everything but are stupid slow).
14:08:52 <Cale> Sure, but do they usually have an *open world* of collider shapes?
14:09:14 <Cale> It might be more appropriate to have a single type with multiple data constructors for the cases which are possible in the engine
14:10:02 <Cale> Because ultimately you'll need to know how to collide everything with everything else anyway
14:10:10 <Jonathan86> My goal was to make something more generic rather than make another thing super specific.  I may fail, but I am going to try...and learn in the process.
14:10:30 <Cale> So, if you have an open world, the question becomes how to know whether all the cases are covered
14:10:35 <maralorn> otoh it might be worth it just so that you can later make an [overlappable] Overlappable instance. :-p
14:11:13 <Cale> You might be able to use fancy DataKinds with lists thing to make writing the n^2 Overlappable constraints a little less taxing, I suppose
14:11:22 <Jonathan86> Cale: I think the expectation is that a system build on top of this will define a type with multiple constructors where every instance has been defined.
14:11:46 <Cale> Yeah, maybe...
14:12:22 <Cale> As a way of specifying what the consumer of your algorithms need to provide, it might not be bad
14:12:37 <Cale> I think I'd be tempted to start by just asking for an extra function argument or two
14:14:11 <Cale> Like,  (Num dist) => (shape -> shape -> dist) -> [shape] -> ...
14:24:35 <oats> is there a function anywhere for splitting a (lazy) bytestring into chunks of size 'n' bytes? Maybe even with padding? like `chunksOf :: ByteString -> Int -> [ByteString]`
14:28:21 <Jonathan86> oats: try `toList`ing it hand then `fmap fromList`
14:29:13 <oats> ah, like unpack it, maybe use Data.List.Split and then pack it again
14:29:15 <oats> that makes sense
14:30:06 <Jonathan86> Despite the conversion between types it is not necessarily any slower.  It is better to think of a list as an iterator.  And because you only use the created lists once (making it back into a bytestring), it is never fully stored in memory.
14:30:22 <oats> right, makes sense
14:30:30 <remexre> should https://wiki.haskell.org/Debugging#Infinite_loops still work?
14:30:40 <remexre> for me, it prints Interrupted but doesn't break
14:30:51 <remexre> (after the :set -f...)
14:33:58 <Cale> Jonathan86, oats: while that's pretty much true, the operations for splitting ByteString values do use some low-level pointer trickery, so making use of Data.ByteString.Lazy.splitAt might do much better.
14:35:27 <Cale> (though lazy ByteStrings are effectively lists already, they're lists of strict ByteString chunks, and strict ByteStrings internally have start and end indexes along with a pointer to a chunk of memory, so they can be split by simply adjusting the indexes)
14:36:01 <Jonathan86> Ah, that would probably be faster (although, slightly harder to right).  If you are too lazy now, you can always just put a comment to fix it later :D
14:36:55 <oats> or maybe I could do something with take and fold
14:37:09 <Cale> It's effectively an unfold of sorts
14:39:25 <Cale> chunksOf n bs = if BS.length bs <= n then [bs] else let (bs1, bs2) = splitAt n bs in bs1 : chunksOf n bs2
14:39:29 <Cale> something like that
14:39:50 <Cale> Could write that as an unfoldr
14:39:53 <oats> oh, the simple recursive one is nice
14:40:21 <Cale> Might also want to handle the empty bs case better
14:40:41 <Cale> (perhaps it should give an empty list of chunks instead of a single empty chunk?)
14:46:54 * hackage threadscope 0.2.12 - A graphical tool for profiling parallel Haskell programs.  https://hackage.haskell.org/package/threadscope-0.2.12 (MitsutoshiAoe)
15:03:19 <maerwald> Is there a de-facto standard tutorial for creating static binaries?
15:36:54 * hackage evdev 1.3.0.0 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-1.3.0.0 (GeorgeThomas)
16:07:54 * hackage sdl2-ttf 2.1.1 - Bindings to SDL2_ttf.  https://hackage.haskell.org/package/sdl2-ttf-2.1.1 (MikolajKonarski)
16:10:54 * hackage massiv-io 0.2.1.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.2.1.0 (lehins)
16:11:04 <d34df00d> Hi!
16:11:27 <d34df00d> Let's say I want to give ghc 8.10 (the rc one) a shot on a stack project of mine. What's the easiest way to build a stack project with a newer and unreleased compiler?
16:15:53 <johnw> isn't there a --ghc option or something, that let's you specify a tarball?
16:33:11 <d34df00d> johnw: thanks, looks like it might work!
16:39:11 <sm[m]> d34df00d: there's a github repo keeping stack.yamls for ghc RCs...
16:39:35 <sm[m]> ..at https://github.com/DanBurton/stack-setup-info-gen/tree/master/output
16:41:22 <d34df00d> sm[m]: yay, that's perfect! Thanks!
16:41:22 <sm[m]> johnw, long time no see, hope life is good! We're sharing file layouts at https://www.reddit.com/r/plaintextaccounting/comments/fcx8ls/multifile_ledger_setup , you might be interested
16:42:03 <sm[m]> yes, really handy
17:00:37 <astk> Hi, I'm trying to use Network.WebSockets but the websocket im trying to connect to needs a "HTTP upgrade header"
17:01:01 <astk> i can find the documentation at; https://hackage.haskell.org/package/websockets-0.12.7.0/docs/Network-WebSockets.html#t:Headers
17:01:17 <astk> but the type;
17:01:18 <astk> type Headers = [(CI ByteString, ByteString)]
17:01:24 <astk> is fairly opaque 
17:01:41 <astk> how do I construct a HTTP upgrade header?
17:05:12 <astk35> when I try to send a message to the server without any headers (just using []), it responds with;
17:05:13 <astk35> *** Exception: user error (Network.Socket.gai_strerror not supported: 11001)
17:06:45 <hpc> astk35: make a tuple where the first element is the header name and the second element is the header value
17:07:07 <hpc> you'll need to look up what actually goes in the header
17:17:49 <astk> i tried;
17:17:50 <astk> [("Upgrade:", "WebSocket"),("Connection:","Upgrade
17:17:57 <astk> ")]
17:18:01 <astk> but to no avail
17:18:20 <astk> I have a HTML example which logs responses from the websocket
17:18:35 <astk> it works, so it must be providing the correct headers and message format
17:19:00 <astk> is there any way I can intercept the messages and connection handshake to see exactly what its sending?
17:19:18 <astk> like, by redirecting the websocket it connects to to be a local server
17:19:20 <astk> ?
17:20:23 <astk> i tried redirecting it to echo.websocket.org
17:20:37 <astk> but that would just return the messages, not the handshake headers
17:20:50 <Cale> Maybe wireshark?
17:23:46 <astk> i was hoping for maybe a Haskell solution, or at least something eaiser to use
17:26:50 <astk98> I was thinking that if it was a local websocket server, then it could check what headers were provided during the handshake
17:27:04 <Cale> astk: Oh, one obvious thing to try is get rid of the colons
17:27:10 <astk98> tried that
17:27:21 <Cale> Those are almost certainly put in by whatever is rendering the pairs
17:27:36 <astk98> there are so many permutations to make it a bad approach
17:27:39 <Cale> also, I think websocket upgrade headers require more than just those two lines?
17:27:50 <astk98> yeah, maybe something to do with versions
17:28:15 <astk98> it seems like it would be easier to just check to see what the working HTML version was emmiting 
17:29:07 <Axman6> astk98: netcat?
17:29:47 <Cale> btw, you can see the code for encodeRequestHead definitely puts the colons in for you here: https://hackage.haskell.org/package/websockets-0.12.7.0/docs/src/Network.WebSockets.Http.html#encodeRequestHead
17:30:31 <astk98> ah, great, fewer permutations!
17:30:54 <Cale> Also, it looks like it's encoding the upgrade header itself?
17:31:12 <astk98> hmm, not sure how to use netcat to catch the outgoing signals
17:32:29 <Cale> https://hackage.haskell.org/package/websockets-0.12.7.0/docs/src/Network.WebSockets.Hybi13.html#createRequest
17:32:37 <Cale> check out the definition of createRequest at the bottom there
17:33:00 <Cale> That gets used here: https://hackage.haskell.org/package/websockets-0.12.7.0/docs/src/Network.WebSockets.Client.html#newClientConnection
17:33:14 <Cale> Which is ultimately used by runClient
17:33:39 <Cale> So you probably don't need to include extra custom headers for that
17:35:57 <astk> oh
17:36:02 <astk> so it cant be the headers...
17:36:16 <astk> wait, is that the command used by wuss?
17:43:18 <astk> yeah, it goes Wuss.runSecureClientWith uses Wuss.runSecureClientWithConfig 
17:43:19 <astk> https://hackage.haskell.org/package/wuss-1.1.15/docs/src/Wuss.html#runSecureClientWithConfig
17:43:39 <astk> which uses WebSockets.runClientWithStream
17:44:13 <astk> https://hackage.haskell.org/package/websockets-0.12.7.0/docs/src/Network.WebSockets.Client.html#runClientWithStream
17:44:19 <astk> which uses createRequest
17:45:41 <astk> still, even less of an idea why the haskell version fails now...
17:48:41 <astk43> it doesnt seem like it should be difficult to make a simple haskell program to listen at a port and just dump all the binary data it recieves
17:49:08 <astk43> then i could redirect the html version to that local address
17:49:12 <Axman6> the tls package has a binary for debugging TLS connections, maybe that's useful?
17:49:23 <astk43> ooh
17:50:27 <astk43> https://hackage.haskell.org/package/tls-1.5.4/src/tls.cabal
17:50:47 <astk43> ctrl-f main-is
17:50:54 <astk43> only shows tests and benchmarks...
17:51:10 <Axman6> hmm, maybe it was something else
17:52:44 <Axman6> maybe I was thinking about the http2 package
18:02:54 * hackage prosidyc 0.1.0.0 - A DSL for processing Prosidy documents.  https://hackage.haskell.org/package/prosidyc-0.1.0.0 (jafc)
21:12:49 <hundard> hey guys I was wondering what you believe the simplest way to update records is
21:13:24 <glguy> record update syntax
21:13:24 <c_wraith> depends on what extensions and libraries you're comfortable with.  Because generic-lens is almost magic if you're comfortable with everything it needs.
21:13:54 * hackage with-utf8 1.0.0.0 - Get your IO right on the first try  https://hackage.haskell.org/package/with-utf8-1.0.0.0 (kirelagin)
21:14:42 <hundard> thanks!
21:15:47 <Axman6> Right in between both those answers is just to use lens, that's basically the problem it exists to solvew
21:16:00 <Axman6> solve*
21:19:58 <dmj`> If your data doesn't have a nested structure, I don't see the benefit or recommending lens
21:20:00 <dmj`> of*
21:20:19 <dmj`> data Person = Person { name :: String, age :: Int }
21:20:36 <dmj`> why recommend lens for updateAge :: Person -> Int -> Person
21:20:39 <c_wraith> because then the answer doesn't change when the data inevitably becomes nested
21:20:59 <dmj`> A lot of data doesn't become nested
21:23:05 <c_wraith> But it's rare for a program to never involve nested data.
21:40:18 <dmj`> Depends on the program
21:40:26 <dmj`> in general I'd agree
21:48:12 <Axman6> I tend to find lens is actually more useful for the non-record nested data lots of apps have. Dealing with containers is like the best feature of lens
21:48:27 <c_wraith> I mean...  containers are nested data.
21:50:46 <Axman6> sure, but the examples everyone uses is records with records with records, which isn't all that common, but containers and structures containing records are everywhere
21:51:31 <Axman6> dealing with messages from S3 via SQS via SNS is a single line of code for our lambdas
22:30:37 * dsal needs to learn more AWS stuff
22:57:07 <dminuoso> dmj`: Even without heavily nested data lens/optics have their usage. Consider a case where you have some `data Attr = ...` with many different constructors, and you are being handed some [Attr], perhaps even as part of a MonadReader instance, optics become a convenient tool to probe that list of attrs.
23:00:21 <dminuoso> Lens is so much more than just a way to deconstruct product types (which is what "nested data types is about").
23:06:00 <iqubic> dminuoso: Probing a sum type like that is a great use of optics. Specifically prisms.
23:06:20 <dminuoso> Well in this particular case it'd be an affine fold.
23:06:30 <iqubic> Why?
23:08:00 <hololeap> what the heck are optics anyway?
23:09:11 <dminuoso> hololeap: optics is the more general name that encompasses lenses, prisms, traversals, folds, etc.
23:09:40 <dminuoso> There is also a package called optics, which is a substitute for lens.
23:11:12 <hololeap> what do all those things have in common? i only know of the lens library for deeply nested data, but i haven't used it because it scared me off. i don't know what prisms are and the other two i only know from their respective typeclasses
23:12:19 <dminuoso> hololeap: You know traversals, right?
23:12:33 <hololeap> i know Traversable well enough
23:14:09 <dminuoso> hololeap: a lens is a way to deconstruct product types, a prism is a way to deconstruct sum/coproduct types, a traversal is a kind of optic that can focus on multiple things at the same time..
23:16:18 <dminuoso> % [1,2,3,4] & each %~ (+10)
23:16:18 <yahb> dminuoso: [11,12,13,14]
23:16:48 <dminuoso> % (1,2,3,4) & _1 %~ (+10)
23:16:48 <yahb> dminuoso: (11,2,3,4)
23:16:51 <dminuoso> % (1,2,3,4) & each %~ (+10)
23:16:51 <yahb> dminuoso: (11,12,13,14)
23:17:28 <dminuoso> % (Left 10, Right 'c') & _1 . _Left %~ (+10)
23:17:28 <yahb> dminuoso: (Left 20,Right 'c')
23:17:53 <hololeap> % :t (%~)
23:17:53 <yahb> hololeap: ASetter s t a b -> (a -> b) -> s -> t
23:18:01 <dminuoso> %~ is just an operator for over
23:18:15 <hololeap> % :t (_1)
23:18:15 <yahb> hololeap: (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
23:18:31 <hololeap> this is what scared me off :o
23:18:42 <dminuoso> hololeap: If you take a look at the optics package, the representation is kept internal
23:20:48 <hololeap> ok this might seem like a backwards way to teach this, but i understand what a profunctor is and i know that lenses have something to do with profunctors. so can these type signatures be explained using the concept of profunctors?
23:22:26 <hololeap> % :i ASetter
23:22:26 <yahb> hololeap: type ASetter s t a b = (a -> Identity b) -> s -> Identity t -- Defined in `Control.Lens.Setter'
23:22:59 <dminuoso> Well the relationships is that all of this can be implemented in various terms.
23:22:59 <dminuoso> One possible way to implement all these optics is using profunctors
23:24:38 <hololeap> (%~) :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
23:25:41 <hololeap> % :t (_1 %~)
23:25:41 <yahb> hololeap: Field1 s t a b => (a -> b) -> s -> t
23:25:50 <hololeap> % :i Filed1
23:25:50 <yahb> hololeap: ; <interactive>:1:1: error: Not in scope: `Filed1'
23:25:54 <hololeap> % :i Field1
23:25:54 <yahb> hololeap: class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where; _1 :: Lens s t a b; default _1 :: (GHC.Generics.Generic s, GHC.Generics.Generic t, Control.Lens.Tuple.GIxed Control.Lens.Tuple.N0 (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Lens s t a b; -- Defined in `Control.Lens.Tuple'; instance [safe] Field1 (Identity a) (Identity b) a b -- Defined in `Control.Lens.Tuple'; instance [safe
23:26:03 <dminuoso> hololeap: The representation the package `lens` uses is without profunctors (which creates some limits on their representation)
23:27:30 <dminuoso> hololeap: So there's two parts to _1, really. One is the typeclass Field1 - which essentially exists to allow _1 to work with any tuple
23:27:53 <dminuoso> So if you squint over that, you're left with just the van Laarhoven representation of a lens.
23:29:22 <hololeap> any way you can "tldr" the explanation of what a van Laarhoven lens is?
23:29:33 <dminuoso> It's just an alternate implementation.
23:29:47 <dminuoso> You could say that "van Laarhoven" and "Profunctors" are two possible ways to implement all of these.
23:30:13 <dminuoso> `lens` uses the "van Laarhoven" encoding and exposes all of this directly to you
23:30:26 <dminuoso> `optics` uses the profunctor encoding, and hides all the optics behind newtypes
23:31:44 <hololeap> hmm... perhaps looking at both will help me gain an intuition for this stuff
23:32:29 <dminuoso> Not really
23:32:34 <dminuoso> It's just implementation details
23:32:57 <hololeap> the docs for the optics package seem a little more accessible to me than lens
23:33:53 <dminuoso> hololeap: So in the package `lens`, `type Lens s t a b = forall f . Functor f => (a -> f b) -> s -> f t`, in the profunctor representation you have `type Lens s t a b = forall p. Strong p => p a b -> p s t
23:34:13 <dminuoso> hololeap: And optics choses a different route, it's just newtypes. So you'd just see `Lens' Thing SmallerThing`
23:34:13 <dminuoso> So the the actual representation is hidden and invisible to you
23:34:57 <hololeap> i see. so they both do the same thing essentially?
23:35:24 * hackage egison-pattern-src 0.2.1.0 - Manipulating Egison patterns: abstract syntax, parser, and pretty-printer  https://hackage.haskell.org/package/egison-pattern-src-0.2.1.0 (coord_e)
23:35:26 <hololeap> one of the things that initially confused me with lens was the use of type synonyms everywhere. it just seems... strange to me
23:36:10 <dminuoso> Because it uses newtypes, some of the tricks no longer work with optics. So you can't use function composition to compose optics together, a special operator (%) is prepared for you instead.
23:36:10 <dminuoso> Yes.
23:36:25 * hackage egison-pattern-src-th-mode 0.2.1.0, egison-pattern-src-haskell-mode 0.2.1.0 (coord_e): https://qbin.io/tiles-disks-rc8g
23:36:25 <hololeap> ah ok
23:36:52 <dminuoso> Well in both encoding, profunctor and van laarhoven, optics are just RankNTypes - and the type of optic is determined by its constraints.
23:37:29 <dminuoso> This has some interesting properties, such that composing them combines constraints (and indeed, if you compose different types of optics, you get new ones back)
23:37:38 <dminuoso> But it exposes you to all these nasty details
23:38:15 <dminuoso> So in `lens` if you form an illegal composition, it just works (!) until you try to use that optic, at which point you will get a completely bizarre and unreadable message about constraints that are unsolvable
23:38:50 <hololeap> fun
23:39:04 <tdammers> I suspect that you could gain better and earlier error messages with van Laarhoven encoding too, if you newtype everything and give up on "automatic" composition
23:39:14 <dminuoso> optics addresses this by using type families to calculate how two optics compose, and you get nice and readable diagnostics that certain compositions dont work
23:39:22 <tdammers> but if you're going to do that, might as well ditch van Laarhoven encoding as well
23:39:26 <dminuoso> this again, is hidden from you
23:40:53 <hololeap> optics seems more attractive to me so far
23:41:26 <tdammers> optics is newer, so it is at least in part about addressing ergonomics concerns with lens
23:41:33 <dminuoso> tdammers: Absolutely, the diagnostics are not tied to profunctor encodings. But profunctor encoding does give you juicy things like affine traversals :)
23:42:26 <tdammers> but it also represents a slightly different philosophy; someone a bit more familiar with the big names in the Haskell ecosystem might even infer a rough idea of that from the author names :)
23:42:47 <dminuoso> Edward doesn't seem to like the `optics` approach much. ;)
23:42:56 <tdammers> indeed he doesn't
23:43:25 <tdammers> he literally said "I will not use your library" (when talking to one of the optics authors)
23:44:07 <hololeap> why?
23:44:27 <tdammers> and I understand why - the way he thinks, those error messages make enough sense, he's versed enough in the theory to effortlessly understand how everything fits together under the hood, so this actually reduces his mental footprint
23:45:36 <hololeap> this kind of confirms what i was thinking... that lens looks like a personal research project that grew out of control. of course he can use it effortlessly
23:46:15 <tdammers> that's a bit harsh
23:47:00 <tdammers> I think it did start out of a "oh, van laarhoven encoding looks neat, I wonder what happens if I take it and run with it" kind of idea
23:47:23 <tdammers> but it is very much a finished, documented, tested, industry-strength library
23:47:38 <tdammers> and it's definitely not "out of control"
23:48:17 <tdammers> Edward said something along the lines of "I started with lenses, and then one thing led to another, and eventually everything came together"
23:48:19 <hololeap> i meant for "out of control" to tongue-in-cheek
23:48:22 <tdammers> sure
23:49:34 <hololeap> obviously it's a well-loved library. but optics sounds like it follows the principle of least surprise better, at least for a beginner
23:52:22 <tdammers> optics is definitely more beginner friendly
23:53:49 <hololeap> yay! i'm actually excited to try it, and lens has been on my to-learn list forever
23:54:26 <tdammers> fwiw, when writing code against `lens`, I usually find myself doing the "real" type checking in my head to figure out compiler errors
23:55:21 <tdammers> that is, I ignore everything but the location from the compiler error, and then do a bit of manual semi-formal reasoning to figure out why the types don't work out
23:55:46 <hololeap> yeah, and i may get to that point eventually. but for now i think it would just frustrate me
23:56:01 <tdammers> "oh, this is the flavor that needs a MonadState context, but I'm using it in a non-monadic context"
23:56:47 <hololeap> honestly, your debugging approach sounds similar to what i use in pretty much all haskell code. i could decode the error message but i'll just look in that area for any obvious goofs
23:57:07 <tdammers> I think the biggest nuisance is that due to the "it won't error until you try to use it" thing, error locations often point to symptoms, not causes
23:57:29 <tdammers> instead of "it doesn't make sense to combine these things", you get "it doesn't make sense to use the combination of these things"
23:57:45 <MarcelineVQ> that's a nice line
23:58:23 <hololeap> that sounds frustrating for me in my beginner phase of learning something, where i like to try lots of things to learn the boundaries of what works
