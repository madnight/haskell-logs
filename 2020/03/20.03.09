00:02:32 <MarcelineVQ> m1a1
00:29:53 * hackage http-client 0.6.4.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.6.4.1 (MichaelSnoyman)
00:31:35 <d2ci8xc5> I'm a beginner and attempting to properly understand applicative. How does the following work? 
00:31:44 <d2ci8xc5> pure 1 :: [Int]
00:32:28 <d2ci8xc5> pure takes a single value, how does it know to type it to [Int] without reading the :: [Int] type
00:32:43 <d2ci8xc5> pure :: Applicative f => a -> f a
00:33:34 <d2ci8xc5> pure 1 :: (Num a, Applicative f) => f a
00:34:30 <d2ci8xc5> I see, you can specify the structure after the application (f :: [], a :: Int)
00:34:34 <d2ci8xc5> Is this right?
00:36:53 <iqubic> Yes.
00:36:57 <iqubic> Correct.
00:37:07 <d2ci8xc5> thanks
00:37:08 <iqubic> > pure 1 :: [Int]
00:37:10 <lambdabot>  [1]
00:37:24 <d2ci8xc5> oh sweet there's a bot?
00:37:38 <d2ci8xc5> > fmap (+1) [1,2,3]
00:37:39 <lambdabot>  [2,3,4]
00:37:42 <d2ci8xc5> nice
00:38:23 * hackage rings 0.1.3 - Ring-like objects.  https://hackage.haskell.org/package/rings-0.1.3 (cmk)
00:38:48 <iqubic> Yes. Any line starting with '>' is treated as a haskell expression and executed. It doesn't do IO for you, and if the code takes too long to run, you get an error.
00:39:01 <iqubic> It also can give you types too:
00:39:06 <iqubic> :t fmap
00:39:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:39:34 <iqubic> :t pure
00:39:35 <lambdabot> Applicative f => a -> f a
01:02:23 * hackage xeno 0.4 - A fast event-based XML parser in pure Haskell  https://hackage.haskell.org/package/xeno-0.4 (ocramz)
01:58:23 * hackage polysoup 0.6.4 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.6.4 (JakubWaszczuk)
01:59:23 * hackage ghc-typelits-natnormalise 0.7.2 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7.2 (ChristiaanBaaij)
02:28:53 * hackage wai-enforce-https 0.0.2.1 - Enforce HTTPS in Wai server app safely.  https://hackage.haskell.org/package/wai-enforce-https-0.0.2.1 (MarekFajkus)
02:29:32 <perdent> How do you  calculate the Solubility Product Constant of a chemical e.g AgF in Haskell? I don't know how to do it because you have to either set up system that knows about charges and solubility rules or find pkg to do that, and I didn't find
02:29:57 <perdent> https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Supplemental_Modules_(Physical_and_Theoretical_Chemistry)/Equilibria/Solubilty/Solubility_Product_Constant%2C_Ksp
02:30:22 <perdent> https://www.chemguide.co.uk/inorganic/group7/testing.html
02:37:23 <fakenullie> Hello, is there something like ((a -> b), c) -> (c -> (a, c)) -> (b, c) possible with monads?
02:38:36 <tdammers> fakenullie: it is possible to write such a function, but I don't understand what the "with monads" part is supposed to mean
02:40:36 <[exa]> fakenullie: I'd go for arrows in fact, it seems arrow-ish
02:41:29 <fakenullie> I want to do something like (TreeNode v, x) >>= f >>= f, where x is altered by f
02:41:35 <[exa]> otherwise the implementation of the function, if it's the main aim, is perhaps so simple that it's better to completely avoid any higher-level logic
02:42:00 <[exa]> fakenullie: `f <$> (TreeNode v, x)`  does not work?
02:42:36 <[exa]> (not sure what type `f` is though)
02:43:49 <fakenullie> f :: x -> (TreeNode, x)
02:43:53 <tdammers> there is a Monad instance for (a,)
02:44:16 <tdammers> or rather, Monoid a => Monad (a,)
02:45:24 <[exa]> fakenullie: could you provide a slightly higher perspective on what's the aim? it seems there could be a simpler solution
02:45:40 <fakenullie> okay, wait a minute
02:47:50 <fakenullie> Spoilers if you participate in codesignal daily contests: https://gist.github.com/nullie/3806aa1b77c85f5c38b2c5f64cb39506, I want to get rid of where
02:48:02 <fakenullie> oops, wrong one
02:48:27 <fakenullie> updated
02:48:46 <kenran> Why do I get -Wmissing-home-modules in a foobar project created by cabal init (lib in src, exe in app directory): I added a module FooBar to the lib that imports MyLib and added FooBar to the exposed-modules (MyLib was ofc already in there).
02:49:31 <kenran> Entering a `cabal new-repl`, I get warned that MyLib is not listed in my cabal file's other-modules, which it isn't. Do I need to duplicate the modules in other-modules and exposed-modules?
02:49:37 <kenran> Or what is the reason behind this warning?
02:50:06 <tdammers> fakenullie: looks fine to me, all I'd change is use more descriptive names, and add some documentation
02:50:17 <fakenullie> it's code golf contest
02:50:34 <fakenullie> and anyway, it's sequential computation
02:50:35 <tdammers> ah, silly mode, OK, I'm out :D
02:51:07 <tdammers> (note btw that `head` is partial, so this could bottom out)
02:51:28 <fakenullie> I know
03:20:53 * hackage purescript-bridge 0.14.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.14.0.0 (eskimo)
03:57:25 <Uniaika> hi!
03:58:14 <Uniaika> What would be the canonical way to sequence two IO actions that may throw an exception (DNS resolving), with the 2nd one only triggered if the first one throws?
04:00:26 <idnar> Uniaika: that sounds like `onException`
04:02:59 <idnar> Uniaika: or `catch`
04:06:33 <[exa]> Uniaika: or perhaps Alternative, `tryThis <|> tryThat`
04:18:00 <Uniaika> thank you!
04:45:16 <Uniaika> [exa]: would Alternative allow me to operate on IO computations?
04:45:33 <Uniaika> since it's "inheriting" from Applicative, I'm not sure…
04:51:53 <lyxia> Why would that be a problem?
04:54:23 * hackage rere 0.1 - Regular-expressions extended with fixpoints for context-free powers  https://hackage.haskell.org/package/rere-0.1 (phadej)
04:59:51 <Cale> Uniaika: Yes, IO is an instance of both Alternative and Applicative. The instance for Alternative catches exceptions.
05:01:43 <zincy_> Cale: A long time ago you told me to ask you about trees
05:02:03 <zincy_> Cale: Would it be ok if I use that credit now :)
05:04:56 <[exa]> Uniaika: yes, IO ops are perfectly usable as applicatives
05:16:21 <solonarv> % writeFile "exists.txt" "hello!"
05:16:21 <yahb> solonarv: 
05:16:36 <solonarv> % readFile "exists.txt" <|> readFile "wontbeused.txt"
05:16:37 <yahb> solonarv: "hello!"
05:16:54 <solonarv> % readFile "doesntexist.txt" <|> readFile "exists.txt"
05:16:55 <yahb> solonarv: "hello!"
05:16:58 <solonarv> Uniaika: ^
05:19:42 <Cale> zincy_: Oh, sure
05:20:00 <Cale> uhh, except that I've forgotten which thing I was going to tell you about :)
05:21:28 <zincy_> https://pastebin.com/jhCkAgAZ
05:22:00 <zincy_> Cale: I am trying to generate a sequence of games from a starting point
05:22:26 <zincy_> Each game state is dependent on the one before it
05:23:04 <zincy_> I read you can use CoFree to represent trees so I am trying this out but have no idea if it is a dead end or not.
05:23:20 <zincy_> What I am actually trying to do is build a poker bot.
05:24:05 <zincy_> So I want to separate the generation of random futures for a given hand from the probabilistic calculation of how profitable a move applied to that game state is
05:24:59 <zincy_> So fundamentally you have a tree of possible game states
05:26:18 <zincy_> And you have a set of alternative way of calculting the expected value of applying a valid move to each game state based on given nodes' path through children
05:26:47 <zincy_> I though I could maybe use newtype GameTree = GameTree (Cofree Zipper Game)
05:27:28 <zincy_> To represent a tree so that when we redo a calculation of EV for a given path we don't need to recalculate the ancestors, we just move the zipper's focus in some of the children
05:29:51 <zincy_> Also I am thinking maybe we could use paths through the game tree as indexes for possible outcomes
05:33:02 <carbolymer> what was the name for @f syntax?
05:33:51 <boxscape> you probably mean -XTypeApplications?
05:34:48 <Cale> zincy_: That sounds reasonable
05:34:54 <carbolymer> boxscape, exactly, thanks
05:35:35 <zincy_> Cale: Great so I am not totally mad
05:35:55 <zincy_> thanks
05:51:11 <kritzefitz> If I have a class `C` and a template haskell macro `mInstancesForC` that defines instances for `C`, is there a way to have `C` in scope at the definition of `mInstancesForC` to be able to use it in quotations, but still be able to use `mInstancesForC` in the module where `C` is defined to avoid the defined instances to become orphan instances?
05:52:00 <kritzefitz> That was supposed to be `mkInstancesForC`, but apparently I'm very consistent at misspelling it.
05:52:41 <pataka> Total newbie here. Just started learning Haskell. Playing around in GHCi. Defined 2 functions: tripleL = (\x->x*3) and tripleX x = x*3. Why does Haskell infer tripleL :: Integer -> Integerbut tripleX :: Num a => a -> a?
05:54:25 <kritzefitz> pataka, Some type classes (in your case `Num`) have a default type, which is often inferred instead of the fully polymorphic type you would have expected. This is called the monomorphic restriction: https://wiki.haskell.org/Monomorphism_restriction
05:55:10 <boxscape> kritzefitz pataka the Monomorphism Restriction is turned off by default in ghci
05:55:23 <kritzefitz> Huh, right. I just saw that too.
05:55:48 <boxscape> pataka hm, for me it infers the more general type for both
05:56:08 <boxscape> % tripleL = (\x -> x * 3)
05:56:08 <yahb> boxscape: 
05:56:11 <boxscape> % :t tripleL
05:56:12 <yahb> boxscape: Num a => a -> a
05:56:39 <kritzefitz> pataka, did you define tripleL directly in ghci or did you possibly define it in a file that was then compiled with static ghc (and thus the monomorphism restriction enabled)?
05:57:01 <boxscape> ah, good question
05:57:01 <Uniaika> thank you solonarv, Cale and [exa] :)
05:58:15 <boxscape> kritzefitz I don't think it even has to be static ghc, Extensions from ghci and extensions in files that ghci loads are separate
06:00:55 <pataka> So this was my first Haskell debugging experience : ) I did load it from file. When defined from the GHCi prompt I get the polymorphic type in both cases. So there is a difference between the 2. Noted and thanks! : )
06:01:54 <Cale> pataka: If you give explicit type signatures, there won't be a difference though
06:02:31 <Cale> pataka: The monomorphism restriction is just trying to prevent situations where you might think you're defining a constant, but it's secretly a function and will have to be recomputed each time you use it
06:02:45 <Cale> pataka: For example, if you write  big = product [1..1000]
06:03:12 <Cale> You might expect this number to be computed once when you first use it, and then retained in memory for future uses
06:03:27 <Cale> But if it has a polymorphic type like  big :: Num a => a
06:04:01 <Cale> then internally, it's a function of the Num type class dictionary (which includes the implementation of multiplication, and interpretation for integers for the type a)
06:04:17 <Cale> and so at each usage, that dictionary will be passed to the function, and it'll recompute the product
06:05:18 <Cale> For things which already have the syntactic appearance of being a function, i.e. they have explicit parameters on the left of the = sign, the monomorphism restriction isn't applied, and the compiler allows itself to infer a polymorphic type
06:06:06 <Cale> This can also be turned off with {-# LANGUAGE NoMonomorphismRestriction #-} if it becomes really annoying
06:06:35 <boxscape> (and usually it ends up being more annoying in ghci than in files, which is why it's turned off by default there)
06:07:44 <Cale> There have been some times where the monomorphism restriction bit me in a way that I didn't expect, and cost me a bunch of time pondering what was going on.
06:08:03 <Cale> One was before forM was in the libraries, I'd written forM = flip mapM
06:08:10 <Cale> and then tried to use it in an ST computation
06:08:18 <pataka> Ok. Thanks Cale.   I saw that toplevel definitions get a type signature as documentation.      I also saw that the 2 versions showed different times and memory usage. Was going to look at that next. But your explanation of the dictionary passing covers that.
06:08:50 <kritzefitz> You can also specify -Wmonomorphism-restriction on the command line, so GHC complains whenever it applies the monomorphism restriction.
06:09:00 <Cale> and ST actions are required to be polymorphic in a particular way, and I thought initially the problem was elsewhere, and didn't suspect my little one-liner
06:09:20 <boxscape> Cale huh shouldn't forM = flip mapM already throw an error at the definition site with DMR due to ambiguous m?
06:09:57 <Cale> boxscape: It was being specialised to ST (), obnoxiously.
06:10:10 <boxscape> Oh, right, it can infer it from the callsite I suppose
06:10:13 <pataka> And although I haven't looked yet at Haskell's type classes, am a correct that the (=>) constraints 'desugar' in dictionary passing?
06:10:39 <Cale> pataka: Yeah
06:10:51 <Cale> pataka: The => arrows desugar into -> arrows
06:11:16 <pataka> Nice and consistent : )
06:11:29 <Cale> and the compiler figures out which arguments to pass by using the type of thing that's required and which instances of the type class are available
06:12:33 <Cale> Type classes are designed in such a way that there is always at most one valid instance of a type class for any given type, so you don't have to worry about the exact manner in which the compiler arrives at an instance, they will all be equivalent.
06:13:34 <Cale> (This is a problem in a lot of other languages that have similar features, you end up needing to know details about how the compiler is going to fill in implicit parameters sometimes, and it becomes a source of subtle problems.)
06:14:33 <pataka> Yes, yes, yes ... lots of syntactic sugar ... that boil down to lambda expressions at some point. Rather elegant.
06:15:30 <Cale> It's partly sugar, but the process of sorting out which instance applies to a given situation can do quite a bit of work
06:16:28 <Cale> For example, there's a type class called Monoid for things which can be combined with an associative operation (<>) that has an identity element (mempty)
06:16:59 <Cale> One of the instances of Monoid is for a type called Ordering, which is used to express the results of comparisons
06:17:06 <Cale> data Ordering = LT | EQ | GT
06:17:15 <Cale> (for less than, equal, and greater than)
06:17:30 <Cale> The instance looks like:
06:17:34 <Cale> instance Monoid Ordering where
06:17:39 <Cale>   EQ <> y = y
06:17:44 <Cale>   x <> _ = x
06:17:53 * hackage posix-api 0.3.4.0 - posix bindings  https://hackage.haskell.org/package/posix-api-0.3.4.0 (andrewthad)
06:17:55 <Cale>   mempty = EQ
06:18:27 <pataka> Yes, I figured that that with the type classes you mentioned are done by a constraint solver. I meant that this makes it possible to introduce syntax that looks nice but gets translated into more primitive expressions by having more arguments applied to them if necessary.
06:18:33 <Cale> yeah
06:19:08 <Cale> So, this gets us a way to "break ties" for comparisons, if the left argument isn't EQ, then it's the result, if it is, the right argument is used.
06:19:14 <Cale> and then there's an instance for functions:
06:19:25 <Cale> instance Monoid m => Monoid (e -> m) where
06:19:34 <Cale>   (f <> g) x = f x <> g x
06:19:38 <Cale>   mempty x = mempty
06:19:53 <Cale> and so, functions e -> Ordering have an instance
06:20:01 <Cale> and so do comparison functions e -> e -> Ordering
06:20:06 <Cale> and so we can write things like:
06:20:31 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to be sorted first by length and then alphabetically")
06:20:34 <lambdabot>  ["a","be","by","is","of","to","and","here","then","bunch","first","words","l...
06:21:05 <Cale> It's nice that the compiler can sometimes do a bunch of figuring out how operations are to be implemented like that
06:21:29 <pataka> Interesting. No reason not to look at that now. : ) Thanks again, Cale.
06:22:53 * hackage bytelog 0.1.0.0 - Fast logging  https://hackage.haskell.org/package/bytelog-0.1.0.0 (andrewthad)
06:23:53 * hackage cas-hashable 1.0.0 - A hashing class for content-addressed storage  https://hackage.haskell.org/package/cas-hashable-1.0.0 (YvesPares)
06:24:53 * hackage cas-store 1.0.0 - A content-addressed storage  https://hackage.haskell.org/package/cas-store-1.0.0 (YvesPares)
06:25:53 * hackage sha1 0.1.0.0 - SHA-1 Hash  https://hackage.haskell.org/package/sha1-0.1.0.0 (andrewthad)
06:34:23 * hackage sha1 0.1.0.1 - SHA-1 Hash  https://hackage.haskell.org/package/sha1-0.1.0.1 (andrewthad)
06:41:53 * hackage lz4-bytes 0.1.0.1 - Bindings to LZ4  https://hackage.haskell.org/package/lz4-bytes-0.1.0.1 (andrewthad)
06:42:53 * hackage ghc-typelits-extra 0.4 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.4 (ChristiaanBaaij)
06:44:37 <pataka> The error messages really require some figuring out. Guess that will become easier over time, but for now they are sometimes rather puzzling.
06:45:26 <boxscape> it does become easier over time
06:45:52 <gentauro> pataka: where is that nick from? In Galician it means potato :)
06:46:53 * hackage lz4-bytes 0.1.0.2 - Bindings to LZ4  https://hackage.haskell.org/package/lz4-bytes-0.1.0.2 (andrewthad)
06:50:15 <arianvp> what is setTimeout supposed to do in warp? It seems to be ignored
06:51:47 <pataka> And it means storehouse/pantry/larder in Maori : ) My girlfriend is a logopedist/speech therapist. And pa (front of the mouth) ta (middle) ka is an exercise that she has her deaf clients do so that they can feel where certain sounds come from. Someone was doing that here when I was signing in, so I picked it. : )
06:53:53 * hackage cas-hashable 1.0.1 - A hashing class for content-addressed storage  https://hackage.haskell.org/package/cas-hashable-1.0.1 (YvesPares)
06:54:42 <exarkun> is it accurate that Warp doesn't reset ("tickle") the thread timeout manager while it is writing the response body?  I traced the implementation down to sendRsp and I don't see how it could tickle it from that point down, where the writing happens, because it doesn't even accept the TimeoutManager.Handle.
06:54:53 * hackage cas-store 1.0.1 - A content-addressed storage  https://hackage.haskell.org/package/cas-store-1.0.1 (YvesPares)
06:58:55 <exarkun> arianvp: Hello
06:59:11 <exarkun> arianvp: What did you expect it to do?
07:00:13 <exarkun> arianvp: https://github.com/yesodweb/wai/pull/796/files may help
07:06:53 * hackage funflow 1.6.0 - Workflows with arrows  https://hackage.haskell.org/package/funflow-1.6.0 (nclarke)
07:07:33 <Athas> sm: I see you are still fighting on the Homebrew battlefield.  I got the cabal v2-build stuff accepted, so you might consider using that instead of stack for the hledger formula.
07:10:53 <boxscape> hm I never considered that you can have empty let blocks
07:11:08 <boxscape> % let in Nothing -- e.g.
07:11:09 <yahb> boxscape: Nothing
07:11:58 <geekosaur> they're discussing the do version in #ghc right now. fun
07:12:13 <boxscape> yeah I learned about it by seeing that :)
07:17:56 <AWizzArd> Let’s say you do have an existing Stack project and want to additionally Nix-ize it. What would be the first steps? Let Stack create a .cabal file and run cabal2nix on it, and try in a Nix-Shell if "cabal build" works?
07:21:26 <sshine> AWizzArd, did you see https://docs.haskellstack.org/en/stable/nix_integration/ ?
07:21:41 <sshine> AWizzArd, in particular, stack.yaml has nix-specific properties.
07:21:55 <sshine> AWizzArd, I can't say how well they work.
07:23:28 <sshine> boxscape, incidentally, 'let in Nothing' has a poetic sound to it.
07:23:45 <AWizzArd> sshine: I saw that, but potentially this project will stop using Stack in the future. So I need a solution for Nix that is independent of it.
07:23:49 <boxscape> it's a bit like `do do do do do Nothing`, also known as "much ado about Nothing"
07:23:59 <exarkun> AWizzArd: Probably give haskell.nix a try, then
07:24:11 <exarkun> AWizzArd: https://github.com/input-output-hk/haskell.nix
07:24:54 <AWizzArd> exarkun: this is an alternative to the existing builder infrastructure, yes?
07:25:16 <exarkun> I guess so.  It says "Alternative" right at the top, anyway. ;)
07:25:38 <exarkun> I use it for a couple projects and since I set it up it has done its job and stayed out of my way.
07:31:23 <AWizzArd> exarkun: I imagine it is far easier to start a fresh project from scratch, with just 1-2 dependencies, vs. translating an existing project with 70 HS-Deps, and a few OS-Deps.
07:32:16 <exarkun> It probably doesn't even take very much imagination to get there. ;)
08:48:16 <merijn> boxscape: Fun fact, much ado about nothing is a sex pun :p
08:48:35 <boxscape> huh, go figure
09:12:22 <TMA> merijn: also, in Skakespeare's time "nothing" and "noting" reportedly sounded very much alike. nowadays not so much -- hence nothing is noted about it anymore
09:40:53 * hackage holmes 0.1.0.0 - Tools and combinators for solving constraint problems.  https://hackage.haskell.org/package/holmes-0.1.0.0 (i_am_tom)
09:59:23 * hackage git-annex 7.20200309 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20200309 (JoeyHess)
10:07:55 <mcmoor> Hello, I'm new here! I have a program in procedural that's two parallel programs that one tries to randomly change a value in an array and the other one ties to swap it back to be sorted. Is there anyway to make a similar program in Haskell? I can't imagine how to simulate that in a functional paradigm...
10:13:45 <alx741> mcmoor: I suppose when you say "two parallel programs" you mean one program with 2 threads(?). In haskell you could have a computation in IO (function :: IO ()) that writes to an MVar (https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent-MVar.html) to do the value changing in some mutable vector
10:13:48 <alx741> (https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector-Generic-Mutable.html) and then `forkIO` two threads of that function
10:35:32 <fog> I'm getting a type error; https://pastebin.com/raw/Ef6yBxrR
10:36:23 * hackage cas-hashable-s3 1.0.0 - ContentHashable instances for S3 objects  https://hackage.haskell.org/package/cas-hashable-s3-1.0.0 (YvesPares)
10:36:43 <fog> it cant seem to tell that Transport was made by filtering Transport'
10:39:23 * hackage profunctor-optics 0.0.2 - A compact optics library compatible with the typeclasses in profunctors.  https://hackage.haskell.org/package/profunctor-optics-0.0.2 (cmk)
10:39:46 <fog> I get a better error by removing the Length matching constraint; https://pastebin.com/raw/GBaM0L1J
10:41:32 <mcmoor> alx741 Is it possible to lock a single element in that vector? So yeah this program has an array and two threads. First thread runs a "disruptor" that continuously try to change a value in that array every set time. Second thread will try to scan the array every set time and swap some elements to make the array keep sorted. I can't think of a
10:41:33 <mcmoor> functional equivalent to this because it is two programs that continuously monitor an array and modifies and locks it looks like a procedural program to me. Is there any similar program that I can see as an example?
10:44:22 <maralorn> mcmoor: Since you are more describing what happens in this program and not what the end result should be, it probably doesn‘t make sense to model this completely functional.
10:44:34 <fog> and again if the typelevel filter function is correctly defined; https://pastebin.com/raw/JUzrn3q6
10:44:45 <maralorn> mcmoor: But it is definitely doable in Haskell.
10:45:17 <AWizzArd> Where on disk (Linux) is the prompt of ghci stored?
10:45:58 <fog> mcmoor: there should be no problem with writing that, the idea of needing IO is spurious here
10:46:46 <maralorn> mcmoor: If you really want to do it functional you would probably want as input the list and a random seed and then write a pseudo random scheduler which decides which of the to algorithms to apply next to the list. Though I suspect that would beat the puropose of your problem.
10:46:58 <fog> AWizzArd; which ghci
10:47:02 <fog>  /usr/bin/ghci
10:47:09 <geekosaur> it's wired into ghci, wherever that is installed. you can override it in a .ghci file http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
10:49:00 <geekosaur> and you can customize the prompt with http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20prompt
10:49:01 <fog> maralorn: thats just a function to shuffle the list, if the random number which requires IO is to be used, then this can be abstracted from the core functionality, which does not nesacarily need to run in IO, eg you could define a pure shuffle
10:50:05 <geekosaur> the default shows which modules are active; if you've just opened ghci without loading something, that will be Prelude
10:51:01 <AWizzArd> fog: that looks like the binary, not a config file in which my prompt is stored.
10:51:35 <AWizzArd> In GHCI I run    :set prompt "λ "     for example. Where is this lambda stored?
10:51:42 <geekosaur> because the default isn't in a config file. I explained the config files and linked to how you customize it
10:51:52 <geekosaur> if you run that it's not stored (except maybe in history)
10:51:56 <aveltras> any idea why uncommenting the line with "Indefinite" makes ghcid errors like the following
10:52:00 <aveltras> https://www.irccloud.com/pastebin/FlTYScSQ/
10:52:03 <geekosaur> repeating myself:
10:52:08 <geekosaur> it's wired into ghci, wherever that is installed. you can override it in a .ghci file http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-files
10:52:11 <aveltras> it's in a servant / polysemy context
10:52:36 <AWizzArd> geekosaur: hmm okay I see. I asked because I noticed that on restart I get the same prompt that I had before.
10:53:39 <maralorn> fog: Of course modelling the disrupting and the sorting should be done purely. Modelling "the race" between the two algorithms can be done purely but depending on the purpose of the thing that will at least need a random seed or just not be interesting.
10:56:03 <maralorn> aveltras: Does using the constructor/pattern match Indefinite work in other parts of your Code?
10:56:36 <aveltras> it works if i use "undefined" in place of throw err500
10:57:02 <aveltras> also, it works if i don't try to execute main, as in only watch for errors with ghcid
10:58:59 <aveltras> seems related to the "throw"
10:59:57 <geekosaur> AWizzArd, I'm not aware of anything that automatically remembers your prompt
11:04:26 <fog> ok! it works now
11:04:27 <fog> https://gist.github.com/fog-hs/3258620036741a4549e99115b5b6c397
11:05:04 <fog> (the type families werent getting evaluated because it was matching the name not the data...)
11:05:51 <AWizzArd> I call a function that could throw several different exceptions. What is the right mechanism to check if one of them was matching? My current idea is: use `tryAll` and get a `SomeException`. And at the place where I want to see which one it is I could use `cast` and pattern matching.
11:06:10 <AWizzArd> Is that a sane/normal way? Or is it done with a different method?
11:07:08 <fog> i guess it might actually be better to lookup on the record name for the filter instead...
11:08:11 <fog> AWizzArd: seems sensible, and making the most of the available tooling
11:12:20 <solonarv> AWizzArd: Control.Exception.catches :: IO a -> [Handler a] -> IO a
11:12:42 <solonarv> and data Handler a = forall e. Exception e => Handler (e -> IO a)
11:14:56 <AWizzArd> solonarv: if I understand it correctly this requires me to specify the exceptions that I want to catch/handle at the place where they can occur. The tryAll thing will postpone this descision. Does that make sense?
11:19:37 <aveltras> after using cabal new-repl directly, my problem is coming from this error
11:19:41 <aveltras> https://www.irccloud.com/pastebin/N4CtxYFF/
11:19:45 <aveltras> i'll investigate
11:42:24 <solonarv> AWizzArd: sorry, stepped away. sounds about right to me.
11:48:42 <maerwald> lts-15.3 cannot be downloaded?
11:49:37 <maerwald> https://raw.githubusercontent.com/fpco/lts-haskell/master/lts-15.3.yaml
12:10:52 <benjwadams> Is the sum of an infinite, monotonically increasing list considered a bottom value in haskell?
12:14:42 <Taneb> The sum of any infinite list is bottom in Haskell
12:16:52 <nshepperd> unless it's an infinite list of lazy nats!
12:17:00 <benjwadams> Is there any function which given an infinite, monotonically increasing list will return Infinity rather than a bottom value, or is this not possible with the interpreter alone
12:17:10 <benjwadams> just out of curiosity, I don't have a use case for it.
12:17:40 <benjwadams> IIRC some langs like Mathematica do symbolic interpretation and would return +infinity
12:18:08 <nshepperd> that would require a symbolic representation of the list
12:18:43 <benjwadams> gotcha.  Admittedly I don't know a lot about the innards of symbolic calculation engines, but intuitively I thought the answer would be no.
12:23:00 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/14eb314747293bfdb7a48de3f109f9c1/pasted.txt
12:23:09 <lhurttila> Can't seem to line up the types in the end of this last function. How should I finish it?
12:27:54 <maerwald> anyone using static-haskell-nix?
12:28:25 <maerwald> It fails with: "stack2nix: user error (No such package libiserv-8.6.3 in the cabal database. Did you run cabal update?)"
12:28:33 <maerwald> And indeed, that package does not exist.
12:28:44 <maerwald> Why it tries to download/convert that, I have no idea.
12:28:54 <maerwald> Seems like your average nix project :>
12:53:43 <AWizzArd> solonarv: oki, thx for confirming
12:53:59 <AWizzArd> solonarv: `catches` looks useful, didn’t know it before.
12:57:23 * hackage holmes 0.1.0.1 - Tools and combinators for solving constraint problems.  https://hackage.haskell.org/package/holmes-0.1.0.1 (i_am_tom)
13:41:23 * hackage vty 5.28 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.28 (JonathanDaugherty)
13:47:53 * hackage sha1 0.1.0.2 - SHA-1 Hash  https://hackage.haskell.org/package/sha1-0.1.0.2 (andrewthad)
13:49:14 <fog> ok I had to add something to; https://gist.github.com/fog-hs/3258620036741a4549e99115b5b6c397
13:49:31 <fog> unlike Either, the extensible sum type needs to record the type of the contents 
13:49:47 <fog> how does this compare with eg. Vinyl?
14:05:50 <dmwit> Why not `data Var name (assocs :: [(Symbol, *)]) where Var :: Proxy name -> Lookup name assocs -> Var name assocs`?
14:06:26 <dmwit> I don't understand "unlike Either, the extensible sum type needs to record the type of the contents". Either records the type of its contents.
14:07:49 <d2ci8xc5> how does Either record the type of its contents?
14:08:14 <dmwit> Either takes two type arguments. One of those arguments is the type of its contents.
14:08:39 <dmwit> (Or: how does the extensible sum type record the type of its contents?)
14:10:53 * hackage git-annex 8.20200309 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200309 (JoeyHess)
14:21:23 * hackage stratosphere 0.50.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.50.0 (jdreaver)
14:41:05 <jle`> dmwit: is that proposal in response to anything
14:45:17 <dmwit> It was in response to fog's gist. It seems fog left before I sent it, but I hadn't noticed that at the time I was typing.
14:46:16 <jle`> ah, i see
14:46:48 <jle`> i might not be seeing their messages
14:48:03 <dmwit> Ah. I may have special powers there (as a putative op).
14:49:02 <dmwit> ...other possibilities exist.
15:10:21 <hseg> who do i ping to point out that codex doesn't build with Cabal 3.0?
15:10:31 <koz_> hseg: No maintainer listed for it?
15:10:42 <hseg> Alois Cochard
15:11:32 <davean> So, them
15:12:18 <davean> Also, do you think its Cabal 3.0 that causes that issue? That would be weird.
15:12:46 <hseg> yes. the Dependency constructor got a new field
15:12:52 <hseg> https://github.com/haskell/cabal/commit/e2194d259010fcaedd15319e02643a2f00a020fa
15:13:23 <davean> oh, does it lack setup constraints?
15:13:52 <hseg> hrm. seems not.
15:14:06 <hseg> ok, full sitrep:
15:15:46 <hseg> with current cabal, codex fails to install since it requires yaml<0.9 which in turn requires base<4.13 which conflicts with the fact i have base=4.13 installed, nonupgradeable 
15:16:08 <hseg> so i try relaxing the yaml dep
15:16:53 <hseg> and that causes ghc to complain that Dependency (which I presume is from Cabal) has 3 fields, not 2
15:28:19 <hseg> ok, so i see on the build matrix that it *should* be able to build...
15:28:31 <hseg> but how do I get the build plan that worked?
15:37:33 <davean> hseg: you'll see on matrix it builds on 8.6.5 but not 8.8.1
15:38:09 <hseg> right
15:38:17 <hseg> ... oh
15:38:32 <davean> so back to where I said I expected it wasn't Cabal.
15:39:08 <davean> the problem seems to be that everything is working correctly.
15:39:13 <hseg> yup
15:39:44 <hseg> was confused because cabal is configured to use 8.8.1, but my ghci link is stale and points to 8.6.5
15:39:53 * hackage vty 5.28.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.28.1 (JonathanDaugherty)
15:42:17 <hseg> will having codex compiled with ghc 8.6.5 and hasktags compiled with ghc 8.8.1 be problematic?
15:43:29 <hseg> shouldn't -- codex should be invoking hasktags as a binary, so it should be opaque
16:38:32 <sm[m]> Athas: thanks! will keep in mind
16:48:29 <koz_> :t guard
16:48:31 <lambdabot> Alternative f => Bool -> f ()
16:49:04 <koz_> :src guard
16:49:12 <koz_> @where guard
16:49:13 <lambdabot> I know nothing about guard.
16:49:15 <koz_> :(
16:50:14 <yushyin> is the source of yahb available?
16:50:51 <koz_> :t (<$)
16:50:53 <lambdabot> Functor f => a -> f b -> f a
16:54:53 * hackage mattermost-api 50200.4.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.4.0 (JonathanDaugherty)
16:55:54 * hackage matterhorn 50200.7.0, mattermost-api-qc 50200.4.0 (JonathanDaugherty): https://qbin.io/came-ebony-ahk9
18:19:31 <frdg> (𝜆[𝑥 ∶= 𝑧].𝑥𝑦)   what does the ":=" symbol mean in this lambda?
18:21:34 <shachaf> You wrote it, so presumably you know better than anyone.
18:22:02 * johnw waves to shachaf
18:24:43 <maralorn> frdg: From where do you have it?
18:24:51 <maralorn> frdg: It might be a type declaration?
18:26:07 <maralorn> although that would normally be (𝜆𝑥∶𝑧.𝑥𝑦).
18:26:37 <maralorn> I am completely startled by how pleasing that formula looks in my monospace terminal client.
18:27:21 <koz_> Likewise.
18:27:39 <koz_> The curves on dat lambda.
18:29:25 <johnw> does anyone know which variant of LTL it is that allows one to make a formula dependent on the current element under consideration? E.g., for a sequence of naturals: □ (◇ (λe. e < 3))
18:30:40 <johnw> or another: □ (λe. X (λ e'. e + 1 == e'))
18:31:05 <johnw> or is that just an example of LTL and its use of predicates?
18:32:56 <maxsu> hey all, perhaps not a haskell question, but are there code review systems that introduce people to a new code base?
18:34:54 <maxsu> this kind of system would be able to break down the semantics of the program, and then expose the reader to different sections of the system
18:35:17 <maxsu> then it tests the reader with some multiple choice questions about some of the types the program uses, for instance
18:41:17 <d2ci8xc5> that's a pretty specific requirement
18:58:59 <Nolrai> @pl \b x -> if b then Just x else Nothing
18:58:59 <lambdabot> flip flip Nothing . (. Just) . if'
18:59:36 <Nolrai> :t flip flip
18:59:37 <lambdabot> b -> (a -> b -> c) -> a -> c
19:04:21 <Nolrai> is 'boolToMaybe' a good name for 'boolToMaybe True = Just' 'boolToMaybe False = const Nothing'?
19:04:53 <Lears> % :t \b x -> x <$ guard b
19:04:54 <yahb> Lears: Alternative f => Bool -> a -> f a
19:05:01 <Lears> Nolrai: -^
19:07:51 <koz_> If I have both DeriveAnyClass and GND enabled in the same module, how do I tell GHC which strategy to use for what?
19:09:37 <glguy> koz_:  there's an extension for letting you specify
19:09:58 <koz_> Ah, yes, DerivingStrategies. THanks.
19:10:25 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-strategies
19:12:19 <Nolrai> Lears: Thanks!
21:51:53 * hackage yaml 0.11.3.0 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.11.3.0 (MichaelSnoyman)
22:27:37 <fog> Extensible Sum types cant be Monoids, because as they have heterogeneous types, given by a parameter.
22:28:12 <fog> but this parameter, the list of types that are Summed over, is a Monoid
22:28:22 <fog> and I want the abstraction that captures this
22:28:45 <fog> HLists too...
22:29:26 <fog> they are kind of like Monoids, but actually need the Monoidalness of the parameter which makes them not Monoids
22:30:08 <fog> thats got to be a thing
22:30:45 <fog> and it should have a generalisation over (<>)
22:31:46 <fog> where its type should be doing <> over the type list params 
22:32:31 <fog> then HList and Var could be instances
22:33:17 <fog> but i think this generalisation over (<>) needs the machinery of classes, because it needs to match over the input types
22:33:40 <fog> so does not make a natural class function 
22:43:07 <fog> for instance, I would write it like this; https://pastebin.com/raw/cQZSQQfc
22:43:31 <fog> class HListAppend (xs :: [*]) (ys :: [*]) where (<<>>) :: HList xs -> HList ys -> HList (xs ++ ys)
22:43:54 <iqubic> Hi folks.
23:02:00 <fog> https://pastebin.com/raw/P7QYXYia
23:02:23 <fog> class (<<>>) l (f :: l -> *) (xs :: l) (ys :: l) where (<<>>) :: f xs -> f ys -> f ((<>) l xs ys)
23:02:50 <fog> type family (<>) k (x :: k) (y :: k) :: k
23:03:30 <fog> with instances given for HList
23:04:28 <quiet___laika> (copying from matrix)
23:04:32 <quiet___laika> im trying to write a cli interface similar to the python httpie tool, which allows you to run "http google.com" to perform a get request, but also accepts "http post google.com" if you want to control the request method directly. for some reason, optparse-applicative doesn't seem to be letting me support this style of an optional argument before a
23:04:32 <quiet___laika> required argument: https://gist.github.com/matthewess/99f6c209e1359a19c1f0f10d3d0630de
23:04:42 <quiet___laika> ie, if i supply a single argument, http-hs foo, it complains that it's missing the required argument
23:04:50 <quiet___laika> the help text correctly shows as http-hs [method] url ..., but it seems like it is always parsing a single argument as the optional one rather than the required one
23:05:23 <iqubic> fog: If Standalone Kind Signatures were a thing I could actually understand how that class and type family worked.
23:05:46 <fog> why?
23:06:57 <iqubic> because I'm not used to reading signatures in that format.
23:07:10 <fog> when you get "two layers deep" classes, then you end up with type families that mention the kinds as params
23:07:22 <fog> this is as close to being able to write constraints at type level
23:07:25 <quiet_laika[m]> (still here)
23:07:57 <fog> really we want to be able to use the Monoid Constraint at type level...
23:08:01 <iqubic> What do you mean by "two layers deep"?
23:08:35 <fog> that the function of the class itself requires a class to express it...
23:08:51 <fog> because it needs to match on types
23:09:09 <fog> eg to consume them recursively as in the implementation of (++++)
23:09:39 <wrunt> quiet_laika[m]: the unsatisfactory/lazy/pragmatic solution: put method last
23:10:14 <iqubic> fog: What does it even mean to use the Monoid Constraint at the type level?
23:11:02 <fog> well, we want to be able to (<>) together the type level lists that are the params of the HLists being (<<>>) together
23:11:25 <fog> so we need some kind of polymorphic (<>) function at type level
23:11:35 <iqubic> Right. That sounds hard.
23:11:45 <fog> where we then want to be able to write an instance for type level lists
23:11:58 <iqubic> This seems like a good use case for dependent types.
23:12:01 <fog> type instance (<>) [*] x y = x ++ y
23:12:24 <fog> why even mention them, the haskell version is beautiful 
23:12:36 <iqubic> fog: is there an implementation of (++) at the type level?
23:12:51 <fog> you should check the paste
23:12:52 <fog> https://pastebin.com/raw/P7QYXYia
23:13:53 <fog> type family (++) (xs :: [*]) (ys :: [*]) :: [*] where '[] ++ ys = ys; (x ': xs) ++ ys = x ': (xs ++ ys)
23:14:33 <fog> but we cant do the same this so easily for HLists...
23:14:40 <iqubic> What's the point of <<>>?
23:14:54 <fog> its the abstraction like Monoid for HList
23:14:57 <fog> and Var
23:15:00 <iqubic> Like what is it supposed to do?
23:15:20 <fog> monoid them together like (<>)
23:15:34 <iqubic> What is the purpose of the type l here?
23:15:35 <iqubic> class (<<>>) l (f :: l -> *) (xs :: l) (ys :: l) where
23:15:44 <fog> its superfluous 
23:15:54 <iqubic> And why do you have f?
23:16:05 <fog> because thats where HList goes
23:16:18 <iqubic> How??
23:16:25 <fog> its written in the paste...
23:16:40 <iqubic> HList doesn't have the form of l -> *
23:16:45 <fog> instance HListAppend xs ys => (<<>>) [*] HList xs ys where (<<>>) = (++++)
23:16:53 <fog> yes it does
23:17:09 <fog> :kind HList = [*] -> *
23:17:13 <iqubic> Oh. Right. Yes it does.
23:17:45 <fog> the only reason to mention l is if we could write something like;
23:17:52 <fog> instance (<>) k xs ys => (<<>>) k m xs ys
23:18:03 <iqubic> Right. But can we do that?
23:18:24 <fog> which we cant, as the way the (<>) over the params of kind k is implementation specific
23:18:34 <fog> like, we can for specific instances like HList
23:18:45 <iqubic> It sounds difficult.
23:19:11 <fog> instance HListAppend xs ys => (<<>>) [*] HList xs ys where (<<>>) = (++++)
23:20:06 <fog> im annoyed it needs that constraint, it shouldnt, as it should know that xs and ys are [*] and there is an instance for that provided
23:21:46 <fog> but anyway, the class is enough to show what i meant
23:22:00 <fog> the problem is that there is no way write the superclass to the type family
23:22:21 <fog> what i really meant would be that all instances should have available the (<>) instance on the params
23:22:34 <fog> to each of the parametrised things that are (<<>>) instances
23:23:58 <fog> urm, thats not quite right, i could put that constraint 
23:24:17 <fog> oh no, i cant because its a type family...
23:24:22 <fog> (<>) is...
23:24:40 <fog> so i cant write it as a superclass constraint to the class (<<>>)
23:24:55 <fog> and even worse, if I tried to write (<<>>) as a type family to work at type level
23:25:05 <fog> (for type level HLists!?)
23:25:36 <fog> then there would be no type family superclasses, never mind no type family constraints
23:26:33 <fog> we need type level classes, ie that type families written in this way give rise to Constraints that work at type level
23:27:06 <fog> and that there is a Superclass mechanism possible because of being able to write Constraints for the existence of type family instances
23:27:27 <fog> s/for the existence/demanding the existence 
