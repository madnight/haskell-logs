00:47:02 * hackage hoggl 0.2.0.1 - Bindings to the Toggl.com REST API  https://hackage.haskell.org/package/hoggl-0.2.0.1 (markus1189)
00:58:10 <natpd> What are the pros and cons of compilers automatically inferring dictionaries, subtyping steps and types versus always requiring a programmer to specify those by explicitly passing dictionaries, insisting on explicit casts to mark subtyping steps and requiring that all variable declarations be explicitly typed?
01:11:23 <[exa]> natpd: practical inference of some combinations of the things you mentioned is computationally unfeasible, sometimes undecidable
01:12:05 <[exa]> natpd: other than that I guess the most pros are derived from the ability of the programmer to type less builerplate to make something work
01:15:27 <natpd> [exa] how is it unfeasible and sometimes undecidable? 
01:23:08 <[exa]> natpd: like, too hard to compute. E.g. in case of subtyping there are too many possibilities where to put the implicit conversions, and finding the optimal combination may be a hard problem
01:23:50 <[exa]> natpd: OTOH that works easily e.g. in C where the actual inference is missing
01:29:31 <natpd> [exa] is it considered NP-hard or just difficult? 
01:37:25 <dmj`> Do GHC plugins have to be used from a different package, or can you use a plugin defined in the same package to modify itself
01:41:02 <[exa]> natpd: yeah AFAIK it's computationally complex but I don't remember the precise class
01:43:14 <dmj`> ah, nvm
01:46:49 <natpd> If we consider sorting a list of Booleans using 'sort' such that the result is a list of integers, Howmany dictionaries can be passed to 'sort'?
01:48:07 <[exa]> what do you mean by a 'dictionary' now?
01:50:02 <natpd> so `class Eq a where(==) :: a -> a -> Bool` is a type class, which implicitly declares a data type `data Eq a = Eq { (==) :: a -> a -> Bool }` whose elements are called dictionaries
01:51:38 <[exa]> okay. in your `sort :: ??? => [Bool] -> [Int]`, is it better to pass Ord Bool or Ord Int?
01:52:27 <natpd> Ord Int I guess
01:52:49 <natpd> But the compiler could in reality also choose Ord Bool right?
01:53:34 <[exa]> yeah well both choices are applicable. Also you'd need to pass in something to convert Bools to Ints, let's say `Sub Bool Int`
01:54:32 <[exa]> and there we have it, there are 2 possible "feasible" types for this sort: `(Ord Bool, Sub Bool Int) => [Bool]->[Int]` and the other one with Ord Int
01:54:49 <[exa]> both possibly behaving differently depending on what `Sub Bool Int` does
01:56:02 <[exa]> now, what happens if you use this `sort` twice in one function?
01:56:54 <natpd> `Bool` is a subtype of `Int` in my case
01:57:41 <natpd> On the same list? the second call would be `(Ord Int, Ord Int) => [Bool]->[Int]` right?
01:59:05 <[exa]> anyway let's work with polymorphic types, passing dictionaries in this case doesn't really make sense
02:10:16 <[exa]> natpd: (Ord a, Sub a b) => [a] -> [b]   or    (Ord b, Sub a b) => [a] -> [b]
02:10:58 <[exa]> natpd: also, how many possibilities do you have with `sort . sort`?
02:13:39 <natpd> [exa] second i guess, and idk, it was for an exercise
02:14:08 <natpd> what does `a . b` do
02:22:10 <natpd> how many dictionaries would there be for sorting lists of (Int, Int) pairs?
02:32:27 <[exa]> natpd: it's like `sort (sort a)`
02:43:05 <natpd> [exa] how many dictionaries would there be for sorting lists of (Int, Int) pairs?
02:49:29 <[exa]> natpd: not sure, you might need to subtype and compare both ints and perhaps even the tuple
02:57:39 <natpd> [exa] if we consider no subtyping in this case
02:58:11 <rzmt> Hi. What would be good way to call haskell program from python code?
02:59:17 <[exa]> rzmt: I guess you can use any exec() or popen() call available from your operating system
03:00:15 <[exa]> natpd: in case of no subtyping there'd be exactly 1, guess for `Ord (Int,Int)`
03:00:29 <[exa]> natpd: also, no ambiguity about when to compare
03:03:03 <natpd> [exa] So it must also be 1 for Boolean lists and Int lists right? like `Ord Bool` and `Ord Int` respectively
03:03:41 <rzmt> [exa]: that sounds reasonable. Do you have idea what kind of overhead there is creating a new process for running a haskell program?
03:05:32 <[exa]> rzmt: depending on system. On unixes it's hardly worth optimizing unless you want to call the program many times per second
03:06:54 <[exa]> natpd: btw we totally forgot about the case when the sort is [Bool]->[Bool] but converts the bools to Int before comparison
03:08:16 <rzmt> Ok thanks. I planned to create a haskell library for validating some identifier formats. Then i would create bindings for python and node.js with the library. Not sure if that is generally bad idea
03:09:16 <[exa]> depending on the complexity of the library it might be easier to prototype in haskell and then just easily port the prepared structure&program to python and js
03:09:47 <natpd> @[ex
03:09:47 <lambdabot> Maybe you meant: thx let
03:10:37 <natpd> [exa] yes is also a possible output for `sort :: (Ord a) => [a] -> [a]`, does it change how many dictionaries there would be?
03:11:42 <natpd> and why do we consider `Ord a` to be a dictionary and not `Eq a`?
03:11:54 <[exa]> natpd: you can't sort using Eq
03:12:10 <[exa]> natpd: (and Eq is implied by Ord)
03:15:32 * hackage sop-core 0.5.0.1 - True Sums of Products  https://hackage.haskell.org/package/sop-core-0.5.0.1 (AndresLoeh)
03:16:32 * hackage generics-sop 0.5.1.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.5.1.0 (AndresLoeh)
03:17:32 * hackage twitter-types 0.10.1 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.10.1 (TakahiroHimura)
03:20:03 <natpd> [exa] would you consider `Ord Bool(Ord Int))` to be 1 or 2 dictionaries?
03:26:58 <[exa]> natpd: how would that work?
03:28:45 <natpd> @[ex
03:28:45 <lambdabot> Maybe you meant: thx let
03:29:41 <natpd> [exa] I have them as prolog facts, and for `list(bool)` I get `ordBool(ordInt)` so I guess this is to be interpreted as 2 dictionaries right?
03:31:05 <natpd> @[exa] and for sorting lists of (Int, Int) pairs I get `ordPair(ordInt, ordInt)`, so I guess it must be 3 dictionaries, or am i wrong?
03:31:06 <lambdabot> Unknown command, try @list
03:31:13 <[exa]> I'm kindof missing the semantics of the `ordBool(ordInt)` fact. ordWhatever have different arity?
03:31:51 <natpd> @[e
03:31:51 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
03:32:02 <natpd> [exa] It's because ordBool(X) has type Ord Bool if X has type Ord Int.
03:34:34 <kosmikus> this all sounds very mysterious
03:34:44 <[exa]> very inconsistent in fact
03:35:17 <[exa]> natpd: by "has type" you mean some typing relation that you have in the prolog interpretation?
03:35:22 <kosmikus> I don't see how you can have ordPair/2 and ordInt/0, but ordBool/1
03:36:32 * hackage blaze-markup 0.8.2.4 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.8.2.4 (JasperVanDerJeugt)
03:36:47 <natpd> [exa] yea, I got this closure: hasType(ordBool(X), ord(bool)) :- hasType(X, ord(int)).
03:37:10 <natpd> @kosmi
03:37:11 <lambdabot> Unknown command, try @list
03:37:15 <natpd> kosmikus where?
03:38:08 <[exa]> natpd: and how does 'ordBool(X)' correspond to haskell types? also 'ord(bool)' afaik corresponds to 'Ord Bool' which isn't a type but a constaint
03:39:07 <natpd> [exa] It's not exactly Haskell, but Haskell-like
03:39:46 <[exa]> natpd: we should probably stop using Haskell-style formalisms then, because they don't seem to make much sense
03:40:12 <[exa]> natpd: what would e.g. `ordBool(float)` mean semantically in your case?
03:40:38 <natpd> [exa] floats are not covered, just int and bools
03:40:55 <[exa]> ok, `ordInt(bool)`
03:42:04 <zincy_> Is Proxy a way of getting a value from a phantom type parameter?
03:42:15 <zincy_> You can pattern match on Proxy data constructors right?
03:42:27 <zincy_> Im confused as you can tell
03:42:40 <natpd> [exa] ord Int dont take bools, ordBool takes ints
03:43:46 <natpd> [exa] I can dm you the text
03:44:09 <kosmikus> zincy_: proxies are a way to explicitly tell at which type you want to use a polymorphic function, without the relative recent TypeApplications language extension. you can pattern match on the data constructor of the Proxy type, but it's not really useful.
03:45:41 <[exa]> zincy_: you can patternmatch that "it's a proxy" :]
03:45:51 <zincy_> hehe yeah
03:45:54 <zincy_> thanks
03:46:44 <[exa]> natpd: there seems to be a tremendous amount of rules with no explanation for me, perhaps you could write a short article/blogpost on the system so that others can understand and evaluate it?
03:47:55 <zincy_> kosmikus and [exa]: Makes sense!
03:48:34 <[exa]> zincy_: OTOH it's pretty easy to do some actual "work" with the proxied type with type families and/or MPTCs
03:48:45 <kosmikus> zincy_: you use them in situations where type arguments are difficult or impossible to infer
03:49:09 <natpd> [exa] I've posted the rules here https://pastecode.xyz/view/103eabd8
03:53:21 <[exa]> natpd: ok that's normal haskell typeclasses viewed as dictionary functions
03:53:45 <[exa]> natpd: doesn't explain ordBool(int)
03:54:15 <kosmikus> yes, the paste totally makes sense
03:54:22 <kosmikus> but there's no obvious relation to your prolog
03:57:12 <natpd> I have added the prolog part as well: https://pastecode.xyz/view/344a4ffe
03:59:14 <kosmikus> that only partially makes sense to me
03:59:38 <kosmikus> lines 7/8 seem quite mysterious (why is there a relation between bool and int?)
03:59:42 <kosmikus> and what is "optimizedOrd"?
04:01:51 <natpd> i guess bools are represented as ints, and there's no explanation as to what optimizedOrd is
04:03:28 <natpd> ordBool is a function that constructs a dictionary from its argument dictionary
04:03:28 <kosmikus> you'd have to have an instance declaration like "instance Ord Int => Ord Bool ..." for that rule to make sense.
04:03:49 <kosmikus> but that's a very strange instance
04:06:07 <natpd> If I had `ordPair(ordInt, ordInt)`, how many dictionaries would that be?
04:06:40 <kosmikus> what do you mean, how many? why is that important?
04:06:50 <kosmikus> I'd say 1.
04:07:07 <kosmikus> but depends on how you define how to count.
04:07:45 <kosmikus> you could probably justify at least all of the answers 1, 2, and 3 in this case.
04:08:33 <natpd> thats also what has left me to confusion.
04:09:22 <natpd> as to: how many dictionaries are there in each case for sorting Boolean lists; Int lists; and lists of (Int, Int) pairs.
04:10:24 <kosmikus> well, if this is homework of some sort, you should check whether you've received examples or additional instructions on how to count dictionaries, or ask the person giving you the exercises.
04:14:53 <gentauro> anybody know how to read this from Simon Marlow? "Rule of thumb: a constructor costs one word for a header, and one word for each field. Exception: a constructor with no fields (like Nothing or True) takes no space, because GHC creates a single instance of these constructors and shares it amongst all uses." from https://stackoverflow.com/a/3256825
04:15:39 <gentauro> for example, `foo = True`, would that not use any memory?
04:15:45 <kosmikus> gentauro: that seems mostly self-explanatory to me. what is it you want to know?
04:16:03 <kosmikus> gentauro: not really, right.
04:16:16 <gentauro> kosmikus: `bar = 42 :: Int` would be 8 bytes
04:16:31 <gentauro> (on a x64 machines)
04:16:32 * hackage character-cases 0.1.0.2 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.2 (aiya000)
04:16:52 <kosmikus> an Int is boxed
04:17:15 <kosmikus> so it's actually defined as "data Int = I# Int#"
04:17:35 <kosmikus> so that's one word for the header, one word for the Int#
04:17:35 <gentauro> kosmikus: the Boolean type in haskell is a data type with to constructors but no fields: `data Bool = False | True`
04:17:55 <gentauro> kosmikus: so `Int` is 2 x 8 bytes
04:17:58 <gentauro> so 16 bytes
04:18:10 <kosmikus> yes, that sounds right
04:18:33 <gentauro> so Bool whould just be one Word for the Header (but none for the constructors)
04:18:37 <gentauro> so all Bool are 8 bytes
04:19:05 <kosmikus> depends if you want to count the Bool itself, or a reference to a Bool
04:19:27 <kosmikus> True and False are 0-argument constructors and statically allocated. they don't really take any space.
04:19:46 <kosmikus> if a Bool occurs somewhere, the pointer still takes a word.
04:20:21 <gentauro> kosmikus: so only one pointer is necessary
04:22:13 <kosmikus> essentially, all occurrences of False throughout your program are shared
04:22:19 <kosmikus> similarly, all occurrences of [] are shared
04:22:41 <kosmikus> without any extra effort on your side
04:24:26 <gentauro> kosmikus: so if I define my own Octet type like: `data Octect = B00 | B01 | … | BFE | BFF` I should save `some` memory? :)
04:24:41 <gentauro> s/Octect/Octet/
04:25:02 * hackage ngx-export-tools-extra 0.2.2.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.2.2.0 (lyokha)
04:25:21 <natpd> kosmikus do you know if I can use Prolog to determine whether a given set of instance and conditional instancedeclarations is ambiguous, that is whether there exist two dictionaries with the samedictionary type?
04:31:02 * hackage pandora 0.2.5 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.5 (iokasimovmt)
04:32:32 * hackage buffet 0.4.0 - Assembles many Dockerfiles in one.  https://hackage.haskell.org/package/buffet-0.4.0 (evolutics)
04:46:32 * hackage ngx-export-tools-extra 0.2.2.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.2.2.1 (lyokha)
05:54:32 * hackage ChasingBottoms 1.3.1.8 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1.8 (NilsAndersDanielsson)
05:57:02 * hackage relation 0.5.1.0 - A data structure representing Relations on Sets.  https://hackage.haskell.org/package/relation-0.5.1.0 (haskellworks)
06:28:02 * hackage character-cases 0.1.0.3 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.3 (aiya000)
07:02:03 <Lysanleo> What can't be declareted in the top-level scope? and Why?
07:02:11 <Lysanleo> Like a String?
07:07:44 <Uniaika> Lysanleo: what?
07:09:41 <Lysanleo> sry, I am not good at  using english to descripe my qusetion......
07:11:24 <Lysanleo> Like, I had a .hs file like this https://paste.ubuntu.com/p/V4ndz3yTPg/
07:11:24 <Lysanleo> And then I load it in ghci , It'll return a error
07:11:43 <Uniaika> okay I see your code
07:11:50 <Uniaika> Lysanleo: do you want to be able to access this string?
07:13:32 <kosmikus> syntacticallly, a string literal like "hello" is a Haskell *expression*. Haskell files are supposed to contain syntactic *modules*, which are in essence lists of *declarations*. to turn an expression into a declaration, you have to make it into a binding, i.e., give it a name. so you have to write something like: mystring = "hello"
07:13:40 <Lysanleo> No, If i want to access thin string I'll binding it with a variable , I am wandering why it will return this error.
07:15:11 <Lysanleo> kosmikus: thx a lot
07:15:50 <Lysanleo> There I had another quse, what's the difference between "naked exp" and "exp"
07:16:15 <Uniaika> can't say if there's any difference… do you have an example of both?
07:16:55 <kosmikus> Lysanleo: that's presumably from the GHC error message you're getting in your case
07:17:25 <geekosaur> usually "naked exp" means trying to evaluate an expression at the top level of a program. ghci lets you do this at a prompt, ghc does not allow it in a file
07:17:30 <kosmikus> if GHC encounters an expression at the top-level of a module, it's calling it a "naked expression", as opposed to an expression that is contained in a binding, on the right hand side of the = symbol.
07:17:59 <kosmikus> naked expressions are generally not allowed in Haskell modules (there is a special case, if they refer to a Template Haskell splice, which is presumably why there is a special error message for them).
07:18:01 <Lysanleo> Uniaika: I just see sb use "naked exp", and can't understand why a adj "naked".
07:18:28 <geekosaur> the starting point of a program is a function called "main", as in C or Java; you don't just have expressions like in Python
07:18:45 <geekosaur> "naked" means "not part of a binding"
07:18:54 <kosmikus> I think the "naked" terminology comes from the fact that it is not "wrapped" in any other syntactic construct.
07:19:25 <ChaiTRex> Lysanleo: You can get it to work with `var :: String` on one line and `var = "hello"` on the next. Rename `var` to whatever you want.
07:20:31 <ChaiTRex> Lysanleo: Then, use `var` elsewhere, like in GHCi, and it will be that String.
07:21:00 <Lysanleo> geekosaur;kosmikus: Yes, that's what ghci told me..
07:21:41 <Lysanleo> geekosaur: So sometimes , we say "exp" ,in fact we are meaning a naked exp?
07:22:03 <geekosaur> almost everything in Haskell is an expression
07:22:53 <geekosaur> also there are certain special expressions (Template Haskell splices) allowed at top level; they're not really "naked" because they have special types that are recognized by the compiler and run immediately
07:23:05 <kosmikus> if GHC says "error: naked expression at top level", you can simply read it as "error: expression at top level". it's just for emphasis.
07:25:52 <Lysanleo> geekosaur: thx, I have't touched with template ( a newbee), I'll remb it.
07:26:41 <Lysanleo> If I load my e.g code into ghci, the inter will say: "Parse error: module header, import declaration
07:26:41 <Lysanleo>     or top-level declaration expected.
07:26:41 <Lysanleo> "
07:27:10 <Lysanleo> I don't know if that's the same meaning with the error of exp
07:27:11 <Lysanleo> ..
07:28:01 <kosmikus> it means you've written something that's not recognised as an expression, but also not a syntactically valid declaration
07:28:25 <Lysanleo> Like a naked exp?
07:29:47 <merijn> A (variable/function) binding is "an expression wrapped in a name", so the expression is "naked", because it's not wrapped by a binding
07:29:56 <geekosaur> those are specifically recognized because of template haskell, so it's something else probably
07:35:21 <random-jellyfish> how do I apply a function to the field of a record and return a record with that modified field?
07:35:30 <random-jellyfish> most elegant way
07:36:43 <Lysanleo> I just googled "Teplate Haskell "..didn't understand that much. I am sure the exp is invalid in top-level ,but the ghc8 seems add some magic to interpreter , so a exp is valid in ghci
07:40:02 <geekosaur> ghci is more a glorified exression interpreter that has been expanded to handle some top level-like stuff
07:41:01 <random-jellyfish> how do I apply a function to the field of a record and return the record with that modified field?
07:42:13 <hpc> random-jellyfish: check out lenses
07:43:01 <jcowan> Is there practical use for a function Maybe (Either e a) -> Either e (Maybe a), and if so, what?
07:43:10 * jcowan doesn't know if this is actually provided
07:43:22 <hpc> i don't think that can be defined
07:43:33 <hpc> oh wait, maybe it can
07:43:41 <hpc> @djinn Maybe (Either e a) -> Either e (Maybe a)
07:43:41 <lambdabot> f a =
07:43:41 <lambdabot>     case a of
07:43:41 <lambdabot>     Nothing -> Right Nothing
07:43:41 <lambdabot>     Just b -> case b of
07:43:41 <lambdabot>               Left c -> Left c
07:43:43 <lambdabot>               Right d -> Right (Just d)
07:43:44 <maerwald> It doesn't make much sense though
07:43:53 <maerwald> because the output Maybe must be Just always
07:43:55 <hpc> it's probably just some random situational glue code
07:44:12 <maerwald> So you can just throw away the Maybe from the output
07:44:20 <jcowan> It's in the Rust library, but I don't know why
07:44:47 <jcowan> defined as "None will be mapped to Ok(None). Some(Ok(_)) and Some(Err(_)) will be mapped to Ok(Some(_)) and Err(_)"
07:46:58 <maerwald> ah
07:47:02 <maerwald> That's even more confusing
07:48:43 <jcowan> maybe I mistranslated the type, but it looks right to me
07:50:47 <maerwald> What does Nothing in the input mean? Failure? Warning?
07:50:52 <jcowan> so Nothing -> Right Nothing, Just Right -> Right Just, Just Left -> Left.  Which is exactly what the code says.
07:51:38 <jcowan> "It means what the type says."  I have no idea; I was looking at a list of Maybe/Either libs to collect useful functions.
07:52:11 <jcowan> Alas, it is stilll true that only prose can say _why_.
07:54:08 <maerwald> Maybe (Either e a) -> e -> Either e a -- is better
07:54:26 <jcowan> well, it is `sequence`, that much is clear, but again the use is opaque
07:57:15 <jcowan> I think you have the problem there: it is not clear whether Nothing should be transformed to Left Nothing or right Nothing, because the semantics of Nothing is vague.
07:57:42 <kosmikus> algebraically, Maybe = 1 + _, and Either = _ + _, so Maybe (Either e a) = 1 + (e + a), and Either e (Maybe a) = e + (1 + a).
07:57:46 <kosmikus> it's clear these are isomorphic.
07:57:56 <kosmikus> but filling that with meaning is a different story.
07:58:11 * jcowan chuckles IRL
08:01:02 * hackage pandoc-placetable 0.6 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.6 (mb21)
08:02:15 <jcowan> Okay, given that semantic ambiguity I am going to leave it out of my library
08:03:31 <jcowan> @djinn Maybe (Either e a) -> e -> Either e a
08:03:31 <lambdabot> f a b =
08:03:31 <lambdabot>     case a of
08:03:31 <lambdabot>     Nothing -> Left b
08:03:31 <lambdabot>     Just c -> c
08:04:32 * hackage dbus 1.2.13 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.13 (blaze)
08:05:27 <kosmikus> I don't understand in what sense that type is supposed to be better. The original function has one unique structural implementation. For `Maybe (Either e a) -> e -> Either e a`, there are several options.
08:06:02 <jcowan> Agreed
08:07:00 <jcowan> In any case, other than making Maybe a Traversable, this doesn't seem to be that useful on its own
08:08:12 <jcowan> I do have a maybe-to-either function:  Just c -> Right c; Nothing -> Left Nothing, but adding an argument for the Left payload makes some sense.
08:08:38 <kosmikus> it can be useful, depending on context. but there are lots of potentially useful functions, and the question is whether you're more likely to remember that function's name or to successfully reimplement it when needed. I'd say, probably the latter.
08:10:11 <kosmikus> do you provide `Either a b -> Either b a`, and `Either a (Either b c) -> Either (Either a b) c`, and `Maybe a -> Either () a`, and ... ?
08:12:02 <jcowan> yes to the first: it's called eitherSwap
08:13:39 <jcowan> no to the second, the third is what I was talking about before: providing an argument to maybe->either to provide the payload of the Left generated from Nothing.
08:13:41 <Uniaika> maerwald: thanks for commenting on haddock's issue. Do you wish to join #haskell-docs?
08:14:18 <jcowan> anyhow, thanks all for the insights
08:20:08 <John_Ivan> can anyone see what I'm doing wrong with my "print [(map innerCapitalizeList [a])]" call?
08:20:09 <John_Ivan> https://pastebin.com/jgVKgqpX
08:20:16 <John_Ivan> For some reason, the error is
08:20:36 <John_Ivan> No instance for (Show (IO [Char])) arising from a use of ‘print’
08:20:36 <John_Ivan>     • In a stmt of a 'do' block: print [(map innerCapitalizeList [a])]
08:24:32 <merijn> John_Ivan: innerCapitalizeList returns "IO [Char]"
08:24:40 <merijn> John_Ivan: You're passing the result of that to print
08:24:51 <merijn> And "IO a" is, indeed, not an instance of show
08:25:23 <merijn> John_Ivan: Presumably, you want "traverse innerCapitalizeList" instead of "map innerCapitalizeList" and then use >>= to get the resulting list into print
08:26:28 <John_Ivan> merijn, how would I do the last part?
08:26:44 <muzzle> Hi, so I'm currently looking into hacking on GHC and I've run into a problem. I like to work with emacs and interactive-haskell-mode. Is there a way to make it work with hadrian/ghci-cabal?
08:26:48 <merijn> :t \x -> x >>= print
08:26:49 <lambdabot> Show a => IO a -> IO ()
08:27:01 <muzzle> And how do other GHC devs handle working on GHC from a tooling perspective?
08:27:48 <merijn> muzzle: Might wanna join #ghc :)
08:28:49 <muzzle> merijn: right, will do :)
08:31:03 <John_Ivan> merijn, thanks.
08:49:32 * hackage rainbox 0.26.0.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.26.0.0 (OmariNorman)
09:06:44 <monochrom> why would innerCapitalizeList need IO anyway?
09:09:50 <maerwald> monochrom: do you mind if I pm you real quick?
09:10:03 <monochrom> Let me check if I have +g
09:10:16 <monochrom> Yeah please pm
09:13:05 <MarcelineVQ> he's just going to link you python doing a silly walk
09:13:39 <maerwald> Lol
09:13:58 <maerwald> That is not particularly silly, is it?
09:14:13 <hvr> that'd be worth it, no?
09:14:58 <John_Ivan> ok so I think I have fixed my code. just need to get something figured out
09:15:18 <John_Ivan> <- is taking in a return value from an IO function, correct?
09:15:48 <hyperisco> John_Ivan, not specifically but it can do that
09:16:06 <c_wraith> it's close enough for getting started
09:16:19 <c_wraith> But note that it doesn't need to be a *function*
09:16:23 <c_wraith> :t getLine
09:16:25 <lambdabot> IO String
09:16:25 <John_Ivan> ok
09:16:28 <c_wraith> not a function!
09:16:37 <John_Ivan> so I changed my code
09:17:18 <John_Ivan> https://pastebin.com/qTFRZJ7Q
09:17:25 <John_Ivan> it's still throwing out an error and not sure how to fix it
09:17:42 <John_Ivan>  Couldn't match type ‘Char’ with ‘[Char]’
09:17:45 <hyperisco> what is the error?
09:17:47 <hyperisco> okay
09:17:50 <John_Ivan> In a stmt of a 'do' block: done <- map innerCapitalizeList a
09:17:55 <John_Ivan>    • In the second argument of ‘map’, namely ‘a’
09:17:58 <John_Ivan> that.
09:18:33 <hyperisco> Sorry, what does innerCapitalizeList do? I might have missed that by joining late
09:18:57 <John_Ivan> it just imperatively concatenates a head (which gets capitalized) of a word
09:19:01 <John_Ivan> with a tail.
09:19:21 <John_Ivan> capitalizeEachWord is what applies innerCapitalizeList to all of them
09:19:30 <John_Ivan> the idea is to pass a string
09:19:33 <hyperisco> John_Ivan, can you give me an example input and output?
09:19:36 <John_Ivan> sure
09:19:44 <John_Ivan> input: "this is a string"
09:19:51 <John_Ivan> output: "This Is A String"
09:21:08 <hyperisco> Oh, okay! So if you have a function  capitalize :: String -> String  then you can map this to a list of strings  map capitalize :: [String] -> [String]
09:21:25 <monochrom> I'm going to be harsh but is this simply cargo-culting "do ... return" just so that you get to say "return" because you are used to saying "return" in other languages?
09:22:15 <hyperisco> You are already using  words :: String -> [String]
09:22:27 <hyperisco> so  map capitalize . words :: String -> [String]
09:22:47 <hyperisco> then you lastly want to put the words back together with spaces, is my guess
09:23:19 <hyperisco> https://hoogle.haskell.org/?hoogle=intercalate&scope=set%3Astackage
09:23:48 <maerwald> do ... pure
09:23:59 <hyperisco> do do ... pure
09:24:02 * hackage leancheck 0.9.3 - Enumerative property-based testing  https://hackage.haskell.org/package/leancheck-0.9.3 (rudymatela)
09:24:08 <maerwald> pure vs return is a nice bikeshedding discussion too :P
09:25:49 <monochrom> I see much pun opportunity in saying "you insist on using 'pure', you are a puritan" :)
09:26:14 <maerwald> But since the monad-of-no-return proposal, 'pure' has better arguments, no?
09:26:52 <monochrom> But perhaps if we also use 'pure' instead of 'return', beginners will have to ask "what is 'pure'?" instead of just assuming they know 'return'.
09:27:57 <monochrom> 'pure' has always have better arguments. better name to begin with.
09:28:16 <hyperisco> as long as you rename "extract" to "impure"
09:28:47 <solonarv> hyperisco: no, erup
09:28:54 <monochrom> hahaha
09:28:57 <monochrom> also...
09:29:02 <monochrom> > reverse "live"
09:29:04 <lambdabot>  "evil"
09:29:08 <hyperisco> it has been justified by a paper explaining comonadic purity
09:29:59 <monochrom> I have doubts about carrying the "effectful vs pure" narrative of monads over to comonads.
09:31:44 <hyperisco> you start with impurity by default and then capture a notion of purity, obviously opposite of what we have in Haskell
09:32:50 <monochrom> that works
09:33:54 <hyperisco> if I understood the gist of the paper right, you'd have say  getChar :: IO Char  which is pure, and  extract getChar :: Char  which is impure
09:43:02 * hackage esqueleto 3.3.3.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.3.0 (parsonsmatt)
09:49:51 <maerwald> hyperisco: what paper are you talking about
09:52:15 <John_Ivan> hyperisco, can I have an example code or alternatively see that in the line I pointed at the error in <map>? still not sure I follow.
09:52:36 <John_Ivan> capitalizeEachWord 
09:52:48 <John_Ivan> uhm. sorry. this:
09:52:49 <John_Ivan> done <- map innerCapitalizeList a
09:52:57 <John_Ivan> this part is what's confusing me the most, on why it doesn't work.
09:53:23 <John_Ivan> innerCapitalizeList takes in a [String]
09:53:30 <John_Ivan> which is what the result from "words" fn is
09:53:51 <John_Ivan> and for every String in that list, you get back a IO Char
09:54:04 <John_Ivan> IO [Char]*
09:54:12 <John_Ivan> which is just IO String
09:54:35 <John_Ivan> [IO String, IO String, IO String] is what I expect to see in "done" variable
09:54:44 <John_Ivan> but it doesn't work. and print won't accept that either.
09:57:32 <John_Ivan> https://pastebin.com/qTFRZJ7Q
09:57:40 <hyperisco> John_Ivan, I am not sure innerCapitalizeList is really what you want to be going with, so I would try to do it differently
09:58:13 <John_Ivan> hyperisco, yeah, I know it's a bastardized version of an imperative piece of IO code but I am okay with that function for the moment.
09:58:25 <kosmikus> there are two somewhat independent problems: one is, innerCapitalizeList seems to be of IO type, but from what you're saying it does, it makes no sense that it has one. it should really just be String -> String. the other is that `map innerCapitalizeList a` yields a list, so if you're using it in a do block and bind its result to `done`, you're operating in a list context, non an IO context, which is 
09:58:31 <kosmikus> almost certainly not what you want.
09:59:17 <John_Ivan> dc'd.
09:59:52 <hyperisco> John_Ivan, if you're unwilling to change that definition then I think you need to look at  traverse  rather than  map
10:00:28 <kosmikus> John_Ivan: ok, so your code clearly shows that `innerCapitalizeList` indeed uses `IO` for no reason. you should not be ok with it. it's just making everything needlessly complicated.
10:01:47 <hyperisco> > let f c = concat [[toUpper (head (head c))], tail (head c)] in f ["hello","sailor!"]
10:01:50 <lambdabot>  "Hello"
10:02:06 <John_Ivan> hyperisco, I wish to keep the map function as well. My goal here is to understand what exactly is happening.
10:02:39 <John_Ivan> even if I don't get it to work
10:02:48 <kosmikus> I think it would probably be helpful if you look at an introductory text for Haskell
10:03:24 <kosmikus> something that explains lists, pattern matching, and does not use IO
10:03:57 <John_Ivan> kosmikus, that's perfect. just one question. is it "does not use IO" or "do not use IO"? I'd like a distinction on that first.
10:05:46 <kosmikus> I'm not sure if I understand your question. I was saying that if you look at an introductory Haskell text, it'll almost certainly not start by doing anything IO-related. that comes later, and for good reason. it's worth being comfortable writing "pure" functions first.
10:05:49 <hyperisco> it is sort of twisted in a pretzel, so I don't know how to usefully explain the program
10:05:56 <kosmikus> independently, what you're doing does not actually require any IO.
10:06:06 <kosmikus> so there's also no real reason to use it in your example.
10:06:20 <kosmikus> capitalising certain letters in a string is a function from strings to strings. no IO involved.
10:06:50 <John_Ivan> kosmikus, then I'm afraid an introductory to Haskell isn't gonna help. I'm not attempting to write code the way haskell expects it (in particular, pure-ifying my functions)
10:07:03 <kosmikus> why not?
10:07:04 <John_Ivan> I'm attempting to bend and twists the ways you can use Haskell :)
10:07:12 <kosmikus> why?
10:07:14 <hyperisco> the approach I'd advise is to learn how to approach the problem in a more ordinary fashion and then you can reassess
10:07:31 <John_Ivan> because I simply dislike recursion. And would prefer to do it imperatively.
10:07:41 <hyperisco> don't use Haskell then, easy :P
10:07:42 <kosmikus> then don't use Haskell
10:07:52 <John_Ivan> I do want to use haskell :)
10:07:56 <John_Ivan> minus the recursion.
10:07:59 <John_Ivan> that's all.
10:08:06 <hyperisco> not really, not if you don't want to use it how it is designed to be used
10:08:06 <kosmikus> that doesn't make sense
10:08:11 <{abby}> You want to use Haskell without the Haskell?
10:08:16 <John_Ivan> and if it means achieving the kind of code I've written, that's fine with me.
10:08:27 <John_Ivan> even if it's a monstrosity (grins)
10:08:41 <{abby}> what's the benefit of using haskell if you're just going to embed C into it?
10:08:42 <hyperisco> but either way, the best way to exploit a tool or language, like Haskell, is to first understand how to use it properly
10:09:00 <John_Ivan> {abby}, FFI
10:09:08 <John_Ivan> hyperisco, I will. in time.
10:09:12 <{abby}> erm. what
10:09:40 <John_Ivan> {abby}, foreign function interface.
10:09:59 <{abby}> Yes, I know what a FFI is, thank you. I'm just not sure how using not-Haskell brings FFI as a benefit over any other imperative language
10:10:06 <kosmikus> ok, sure, you're free to put whatever restrictions on your code as you like, including "it must be ugly and as non-idiomatic as possible". but I'm not sure if you'll find a lot of people who are willing to help you with your problems under these preconditions.
10:10:07 <hyperisco> John_Ivan, you are so far behind approaching the problem in a coherent way that I don't know how to directly advise you on it
10:10:22 <hyperisco> John_Ivan, I can explain the type error but what use is that going to be
10:10:30 <{abby}> If you're not going to be using Haskell for its strengths, i.e., functional programming, what the hell are you using it for? GHC's garden-variety FFI?
10:11:13 <John_Ivan> whoa. I must've dropped a bomb or something. My uses shouldn't matter. I already explained why I want it.
10:11:13 <kosmikus> and btw, concat is a recursive function; so is map
10:11:44 <{abby}> John_Ivan: if you want to write loops, go use rust or something; you can't get anything resembling iteration in haskell without recursion
10:11:44 <John_Ivan> but anyway, I am going to do some searching. thanks.
10:11:47 <hyperisco> John_Ivan, I switched to more aggressive language because you're not taking the more gentle hints
10:12:47 <John_Ivan> I did not take it as aggressive. Just, not open minded. I can use haskell or any language in whatever unorthodox way I want to. I just asked a specific question.
10:13:06 <John_Ivan> If it's "wrong" to do so, I'll stop.
10:13:15 <{abby}> anyway, your issue is that map _ _ :: [] a but using it on the left-hand-side of <- expects (in an IO-typed context) a type headed by IO, not [].
10:14:09 <John_Ivan> that's more or less what I needed. thanks {abby} 
10:14:19 <{abby}> what you need is to stop using io
10:14:29 <John_Ivan> noe :)
10:14:44 <kosmikus> the very first answer to your question was to replace map by traverse
10:14:51 <{abby}> now you have a different problem which is "map doesn't work like that"
10:14:52 <kosmikus> for some reason, you did not accept that as an answer
10:15:09 <{abby}> map innerCapitaliseList _ :: [IO String], not IO [String]
10:15:12 <maerwald> "I simply dislike recursion" is quite an odd statement :)
10:15:20 <{abby}> a problem that could be avoided if you just didn't use io...
10:15:38 <monochrom> I wouldn't either, but my reason is innerCapitaliseList doesn't need IO in the first place.
10:16:20 <John_Ivan> realistically, to be honest, I could do everything in IO and get imperative haskell.
10:16:30 <John_Ivan> which is, partially the goal (grins)
10:16:31 <{abby}> why are you using concat instead of (:)
10:16:31 <John_Ivan> but
10:16:33 <Uniaika> (I somehow read that as "insaneCapitalis" and thought "yeah, that's pretty much accurate with the spirit of our time")
10:16:37 <John_Ivan> anyway
10:16:47 <kosmikus> you'd still have to use recursion though
10:17:38 <maerwald> How can we lift your negative relationship with recursion? :>
10:17:55 <monochrom> As for FFI, if you're showing complete misinformation about IO, I don't see how you'll be ready for FFI any time soon.
10:18:28 <MarcelineVQ> no gdi johnny
10:18:33 <MarcelineVQ> just before I link http://www.vex.net/~trebla/haskell/IO.xhtml
10:18:46 <monochrom> So practice pure functions properly and IO properly first?
10:18:55 <MarcelineVQ> every time someone doesn't link http://www.vex.net/~trebla/haskell/IO.xhtml when someone comes in using do for no good reason, a fairy loses it's wings
10:19:16 <monochrom> a tooth fairy loses a tooth
10:19:34 <hyperisco> John_Ivan, your assumption of doing everything in IO gives you imperative Haskell is wrong, at least likely so in the way you might be expecting
10:19:47 <MarcelineVQ> idk why people like repeating themselves so much, I program specifically because I hate repetition
10:20:01 <monochrom> I don't link it when I sense that the asker has dive-in-project-stubbornness against learning.
10:20:06 <hyperisco> it isn't like  String  is declarative and  IO String  is imperative
10:20:19 <{abby}> hyperisco: (they're gone)
10:20:33 <monochrom> Hey, I teach because I like repetition >:)
10:20:53 <kosmikus> monochrom: :)
10:20:53 <monochrom> (No, because I like blowing up people's brains.)
10:21:27 <maerwald> That sentence definitely needs context...
10:21:55 * {abby} dials 911
10:22:00 <maerwald> xD
10:22:03 <ArticulateHacker> if I have a function `addStuff :: Integer -> Integer -> Integer ` bound as `addStuff a b = a + b + 5` is the application of the function to `a` described by the first `(Integer -> Integer)` or the second?
10:22:11 <{abby}> second
10:22:29 <{abby}> ArticulateHacker: (->) associates to the right, so you have Integer -> (Integer -> Integer)
10:22:40 <ArticulateHacker> okay, I was just about to ask that to clarify :D
10:23:01 <{abby}> if you had it the other way around (Integer -> Integer) -> Integer, it'd be a function, taking a function on integers, and evaluating to an integer
10:23:30 <monochrom> X->Y->Z = X->(Y->Z)
10:23:30 <{abby}> e.g. "foo f = f 123" has that type
10:24:24 <ArticulateHacker> if I did partial completion like `addStuff 5`, why isn't the type signature more like ( Integer -> ) because the first function is actually returning a function?
10:24:48 <{abby}> % :t (\a b -> a + b + 5) 123
10:24:48 <monochrom> addStuff 5 :: Integer -> Integer
10:24:48 <yahb> {abby}: Num a => a -> a
10:25:15 <ArticulateHacker> monochrom but it isn't returning an Integer, so isn't that not entirely accurate?
10:25:35 <monochrom> In general, if "f :: D->C" and "x :: D", then "f x :: C".  Today C happens to be Integer->Integer.
10:25:36 <{abby}> addStuff says, given an integer, you get another function that, given an integer, gets you an integer
10:26:34 <monochrom> I don't what what your "it" is, and I don't understand your question, but everything I said is accurate.
10:28:56 <ArticulateHacker> I get most of it, just not how application to `a` has the type `(Integer -> Integer)` because there is not integer returned
10:29:31 <monochrom> Do you accept: if "f :: D->C" and "x :: D", then "f x :: C"
10:29:33 <geekosaur> (Integer -> Integer) is not ab Integer. It is a function
10:30:12 <{abby}> addStuff :: Integer -> (Integer -> Integer), so addStuff a :: (Integer -> Integer), and therefore addStuff a b :: Integer
10:30:51 <ArticulateHacker> which Integer is removed for addStuff 5, the final Integer?
10:30:58 <{abby}> the first
10:31:05 <monochrom> Also this is what's wrong with thinking in terms of "return".
10:31:23 <ArticulateHacker> is it better to think of it as 'state'?
10:31:30 <maerwald> Argh
10:31:32 <monochrom> These are mathematical functions. There are codomains.  There are equalities.  There is no "return".  There is no control-flow.
10:31:33 <{abby}> it's better to think of it as equals
10:31:42 <{abby}> ArticulateHacker: see what monochrom says, set D = Integer and C = Integer -> Integer, and you have your derivation
10:32:43 <monochrom> addStuff equals \a -> \b -> a+b+5
10:32:54 <monochrom> addStuff 5 equals \b -> 5+b+5
10:33:03 <kosmikus> fwiw, I think it's perfectly ok to say that a function `f :: A -> B` "takes" an `A` and "returns" a `B` ...
10:33:07 <monochrom> addStuff equals \a -> \b -> a+b+5.  Type is Integer->(Integer->Integer)
10:33:12 <ArticulateHacker> is -> like the function body?
10:33:14 <monochrom> addStuff 5 equals \b -> 5+b+5.  Type is Integer->Integer
10:33:29 <monochrom> addStuff 5 10 equals 5+10+5.  Type is nteger
10:33:42 <monochrom> -> is like infix notation for function types.
10:34:18 <ArticulateHacker> okay, so also don't think of it like the dot in lambda notation?
10:34:53 <kosmikus> ArticulateHacker: there's a huge difference between the -> appearing in types and the -> appearing in the terms
10:35:06 <monochrom> -> is like when mathematicians write like "f:A->B".  Except we use :: instead of :
10:35:15 <ArticulateHacker> I'm just on types right now
10:35:23 <kosmikus> ArticulateHacker: on the term level, \ x -> e is indeed just the same as \ x . e
10:35:25 <monochrom> Whoever said you don't need math for Haskell are wrong.  You need this much math.
10:35:53 <ArticulateHacker> Yea... I've actually been considering getting an associates or bachelors in math to up my programmin
10:36:55 <ArticulateHacker> kosmikus since I'm at the type level, I take it that does not apply to my questions
10:37:11 <kosmikus> ArticulateHacker: right. on the type level, A -> B is the type of functions from A to B
10:37:25 <kosmikus> ArticulateHacker: nothing to do with any . from lambda calculus
10:38:24 <monochrom> Oh, sorry, you mean "\a -> foo"'s ->.  Yes other people write a dot there.
10:39:04 <kosmikus> ArticulateHacker: so `Integer -> (Integer -> Integer)` is the type of a function that takes an `Integer` as input and has a (function that takes another `Integer` as input and has an `Integer` as output) as output.
10:39:43 <ArticulateHacker> that makes sense
10:40:06 <monochrom> Wouldn't it be nice if we all wrote abstract syntax trees so these immaterial punctuations just don't exist.
10:40:44 <ArticulateHacker> but, when I say addStuff x, that doesn't mean the x is being used in the second function just because of right associativity?
10:40:51 <hyperisco> I've seen structural editing and I'm not convinced
10:41:18 <geekosaur> I've implemented structural editing and I'm a bit dubious
10:41:43 <monochrom> No.
10:42:00 <ArticulateHacker> I think I confused associativity between the level of expression and type
10:42:04 <geekosaur> if you say addStuff x, addStuff consumes the x and produces a function
10:42:06 <{abby}> ArticulateHacker: arrows associate to the right but application associates to the left
10:42:23 <monochrom> The exact opposite.  "(f x) y" and "f :: X->(Y->Z)" go well together.
10:42:26 <geekosaur> if you say addStuff x y, addStuff consumes the x and produces a function, which consumes the y
10:42:38 <{abby}> given f :: A -> B -> C (which parses as A -> (B -> C)), f x y parses as (f x) y, such that f x :: B -> C and (f x) y :: C
10:43:09 <monochrom> You have to work symbolically, not reason wordily "right, therefore right" to see it.
10:43:20 <ArticulateHacker> thanks, this is making better sense
10:44:40 <monochrom> Between symbol games and word games, I choose symbol games all the time.  Because word games bend the rules, symbol games don't.  Word games are to be distrusted.  Wordy argument = word games.
10:44:42 <dmj`> Does anybody have lenses for HsSyn that weren't generated with makeLenses?
10:45:16 <ArticulateHacker> on the level of types, what's the significance of right association. if I had `compareStuff a b :: Integer -> (Integer -> Bool)` what does it mean that (Integer -> Bool) is associated? Is it a precedence thing?
10:45:51 <monochrom> "association" simply means one way to save parentheses.
10:45:53 <c_wraith> association is just how A -> B -> C is parsed.
10:45:56 <monochrom> precedence is another.
10:46:05 <c_wraith> right association means it's A -> (B -> C)
10:46:27 <c_wraith> meaning (A -> B) -> C is a different type than A -> B -> C
10:46:35 <monochrom> Yes it's completely syntactic, without meaning.
10:47:00 <ArticulateHacker> would it even make sense to think of changing the association by `compareStuff a b :: (Integer -> Integer) -> bool
10:47:24 <monochrom> Do you mean you write a new parser?
10:47:29 <ArticulateHacker> er, compareStuff :: (Integer -> Integer) -> Bool
10:47:40 <ArticulateHacker> no, I just mean, does it mean anything?
10:47:46 <{abby}> that's a function that, given a function between integers, returns a bool
10:47:50 <c_wraith> That type means something, but it's not really a comparison anymore
10:47:54 <ArticulateHacker> or is that just nonsense 
10:47:54 <hyperisco> I guess in a mirror
10:47:59 <monochrom> <monochrom> "association" simply means one way to save parentheses.
10:48:04 <monochrom> <monochrom> precedence is another.
10:48:08 <monochrom> <monochrom> Yes it's completely syntactic, without meaning.
10:48:12 <hyperisco> if  a -> b  was changed to mean  b -> a
10:48:25 <c_wraith> :t \f -> f 0 == 1
10:48:27 <lambdabot> (Eq a, Num t, Num a) => (t -> a) -> Bool
10:48:49 <c_wraith> that could specialize to the type (Integer -> Integer) -> Bool
10:48:52 <{abby}> % :t \f -> f (0 :: Integer) == (1 :: Integer)
10:48:52 <yahb> {abby}: (Integer -> Integer) -> Bool
10:48:55 <monochrom> If you change syntax you write a new parser.  If you change meaning you write a new interpreter.
10:49:40 <ArticulateHacker> okay, I think that's a little advanced for me yet
10:50:04 <ArticulateHacker> My question was answered well, though, so I thank you :)
10:59:14 <typetetris> I want to write a server which offers a bunch of services using servant, polysemy (perhaps, If  I have a benefit from it), persistent and esqueleto. What logging package could you recommend?
11:01:49 <MarcelineVQ> I can determine my project's dependency bounds with cabal freeze, can cabal update my .cabal file with those bounds?
11:02:40 <ysangkok> typetetris: did you see this? https://kowainik.github.io/posts/2018-09-25-co-log
11:04:22 <ArticulateHacker> how well does Haskell work with .Net? I saw there is some kind of extension.
11:07:32 <slack1256> ArticulateHacker: I don't think it does.
11:08:06 <d34df00d> koz_: lol will need to look into it actually now that it's released.
11:08:41 <dmj`> ArticulateHacker: you should make a CLR backend for GHC
11:09:08 <ArticulateHacker> not my purpose for studying Haskell, but who knows where life leads
11:09:57 <dmj`> somebody should make lenses for GHC's AST, they'd be a hero
11:10:01 <dmj`> HsSyn
11:10:23 <ArticulateHacker> for me, it's a detour to learning Isabelle
11:11:40 <ArticulateHacker> unless I can get paid to do Haskell *
11:12:59 <dmj`> when you do open source Haskell you're essentially paying yourself to do it
11:13:18 <ysangkok> dmj`: what would use use AST lenses for?
11:13:19 <dmj`> unless somebody else is paying you of course
11:13:27 <dmj`> ysangkok: rewriting the AST
11:13:37 <{abby}> wouldn't those be prisms
11:13:50 <dmj`> {abby}: yes, for the sum types
11:14:12 <ysangkok> dmj`: would you want to use it in a plugin or in GHC itself?
11:14:20 <ysangkok> dmj`: or in templateHaskell?
11:14:28 <dmj`> ysangkok: in a plugin for my specific case
11:14:41 <dmj`> ysangkok: I'm actually using it to rewrite certain template haskell calls
11:15:57 <dmj`> ysangkok: ghc-lens 
11:16:04 <dmj`> @package ghc-lens
11:16:04 <lambdabot> http://hackage.haskell.org/package/ghc-lens
11:16:08 <dmj`> what
11:16:24 <dmj`> oh, it's a 404
11:16:39 <MarcelineVQ> Ah so gen-bounds is the command to get formatted dependency info
11:24:02 * hackage json-autotype 3.0.5 - Automatic type declaration for JSON input data  https://hackage.haskell.org/package/json-autotype-3.0.5 (MichalGajda)
11:25:02 * hackage run-haskell-module 0.0.2 - Running newly generated Haskell source module.  https://hackage.haskell.org/package/run-haskell-module-0.0.2 (MichalGajda)
11:49:28 <typetetris> ysangkok, thanks!
11:49:58 <ysangkok> typetetris: there is a sample on using it with polysemy
11:50:03 <ysangkok> typetetris: that's mostly why i linked it
11:59:32 * hackage express 0.1.3 - Dynamically-typed expressions involving applications and variables.  https://hackage.haskell.org/package/express-0.1.3 (rudymatela)
12:02:32 * hackage fitspec 0.4.8 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.4.8 (rudymatela)
12:07:32 * hackage hspec-leancheck 0.0.4 - LeanCheck support for the Hspec test framework.  https://hackage.haskell.org/package/hspec-leancheck-0.0.4 (rudymatela)
13:03:12 <lembot> hello, does Parsec provides anyway of using a token parser that uses Text instead of String? I'm migrating some stuff from String to Text and the parser is te only thing giving me problems.
13:05:00 <monochrom> Yes, see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#text
13:05:36 <monochrom> If even that is not enough, proceed to "user token type" next.
13:05:51 <monochrom> or even "user input type" after.
13:06:16 <pounce> is there any way to create an array usinga list literal with OverloadedLists
13:07:17 <monochrom> Maybe yes if your array type is an instance of IsList or whatever that class is called.
13:07:54 <pounce> hm
13:08:16 <monochrom> If not then they always have a from-list function but maybe the reason they don't have an IsList instance because the list is not enough.
13:08:40 <pounce> i see
13:08:52 <lembot> monochrom: Thanks!
13:34:32 * hackage cpkg 0.2.5.0 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.5.0 (vmchale)
13:57:17 <berndl> Can someone explain why print 1 <> (print 2 <> print 3) and (print 1 <> print 2) <> print 3 produce the same output?
13:58:04 <koz_> berndl: <> is associative - the Semigroup laws require it.
13:58:53 <berndl> Ah, you're right.
13:59:57 <berndl> Hmm... is there a nonassociative what to chain prints?
14:00:04 <berndl> s/what/way
14:00:49 <koz_> berndl: You can define a non-associative way to chain almost anything with sufficient effort.
14:00:53 <MarcelineVQ> What are you wanting to see?
14:01:17 <berndl> I want the parenthesized stuff to happen first.
14:01:50 <koz_> berndl: Your problem is not associativity then.
14:01:59 <koz_> Your problem is 'put operations in the order you want them'.
14:02:20 <berndl> But I want the order to be controlled by the parentheses.
14:02:38 <koz_> berndl: Then you don't want <>.
14:02:45 <koz_> :t print
14:02:46 <lambdabot> Show a => a -> IO ()
14:02:49 <koz_> :t (>>)
14:02:51 <lambdabot> Monad m => m a -> m b -> m b
14:03:05 <berndl> Ah.
14:03:06 <koz_> :t print 1 >> print 2 >> print 3
14:03:08 <lambdabot> IO ()
14:03:10 <koz_> :D
14:03:20 <urinal666> HELP PLEASE I JUST FIGURED OUT THAT DATA ANALYSIS WITH PYTHON IS NOTHING BUT GLORIFIED EXCEL
14:03:57 <berndl> koz_: >> doesn't seem to work.
14:04:27 <koz_> berndl: What did you try exactly?
14:04:44 <berndl> print 1 >> (print 2 >> print 3) and  (print 1 >> print 2) >> print 3
14:04:58 <koz_> Again, if you want it to print 231, say that.
14:05:03 <koz_> Bracketing does not do what you want here.
14:05:16 <koz_> No amount of bracketing will change effect order here.
14:05:48 <berndl> I see. Good to know.
14:06:19 * koz_ mumbles something about monoids in the category of endofunctors.
14:06:32 <berndl> foldrM (\a _ -> print a) () [1,2,3] <-- Why does this print backwards.
14:06:53 <koz_> berndl: foldrM is right-associative.
14:07:03 <koz_> (like its effect-less friend foldr)
14:07:04 <berndl> I thought associativity didn't matter.
14:07:32 <koz_> berndl: Uhh, it very much matters here. You're reducing a list.
14:07:40 <koz_> Look at the definition of foldrM and you'll see why.
14:07:47 <berndl> I see it uses foldl.
14:07:53 <berndl> But that makes no sense to me.
14:08:01 <koz_> Then look at the transitive definition, and note how it sequences the effects.
14:08:08 <koz_> (also, if you wanna do that, you want traverse_)
14:08:11 <koz_> :t traverse_
14:08:13 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
14:08:26 <koz_> That way, you can write 'traverse_ print [1, 2, 3]'
14:08:46 <berndl> In defining foldrM though, why would you choose to use foldl
14:08:47 <berndl> ?
14:08:55 <koz_> berndl: You'd have to ask the person who wrote it.
14:09:03 <koz_> I have a suspicion, but I don't really know exactly.
14:09:46 <berndl> In my minds, I think it's because you want something like print 1 <> (print 2 <> print 3) where the parenthesis part happens first.
14:09:50 <berndl> *mind
14:10:03 <berndl> *parenthesized
14:10:07 <koz_> Someone here might chime in on that one.
14:16:05 <MarcelineVQ> What does  happens first  mean?
14:17:22 <berndl> MarcelineVQ: order of opertations, e.g. 1 + (2 + 3), the (2 + 3) happens (or should happen) first.
14:19:17 <MarcelineVQ> the actions are sequential, e.g.  foldlM (\y a -> print a *> pure (a:y)) "d" "abc
14:22:01 <MarcelineVQ> we ended up reversing our list but the actions were still done left to right
14:24:29 <MarcelineVQ> well given that foldrM does reverse the actions that's probably not the most clarifying example
14:26:29 <solonarv> berndl: note that (>>) is also associative
14:27:05 <berndl> MarcelineVQ: Yeah. It would be nice to find an example where you realize that implementing foldrM using foldr is wrong.
14:27:31 <berndl> solonarv: Good to know.
14:39:53 <solonarv> berndl: in fact the Monad laws are similar to the monoid laws, this is just obscured if they're written in terms of >>=
14:40:50 <berndl> Sure.
14:43:01 <berndl> Question about list paramorphisms: I realize that you can generalize foldr to para like in this post: https://stackoverflow.com/questions/13317242/what-are-paramorphisms
14:43:19 <berndl> Would there also be a para for foldl?
15:30:13 <kleisli> anyone know a good example to look at to learn how to generate nice error messages with a happy parser?
15:32:37 <glguy> kleisli: One thing you can do is to add error productions to help with things like unclosed blocks, parentheses, etc https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Parser.y#L162-L170
15:34:44 <kleisli> glguy: thanks! this looks useful
15:40:10 <kleisli> in general, is there a way to report what construct the parser expected to see next?
15:40:48 <kleisli> or where it was in the state machine?
15:41:30 <glguy> Not that I know of
15:53:13 <gentauro> what is the `untuple` operator?
15:53:33 <gentauro> opposite to the tuple operator -> `(,)`?
15:54:17 <ChaiTRex> gentauro: fst and snd
15:54:39 <gentauro> ChaiTRex: got it. thx
15:55:39 <gentauro> oh, or just use the arrows -> second {logic} . first {logic}
15:55:47 <gentauro> (always forget about arrows)
15:58:51 <koz_> Or, even better, use bimap!
16:03:02 <MarcelineVQ> :t curry
16:03:04 <lambdabot> ((a, b) -> c) -> a -> b -> c
16:14:32 * hackage selective 0.4.1 - Selective applicative functors  https://hackage.haskell.org/package/selective-0.4.1 (snowleopard)
16:54:59 <d34df00d> So let's say I want to run some tests in parallel with hspec (the `parallel` combinator is strictly related).
16:55:17 <d34df00d> But the tests depend on some external resource that can only handle one test at a time.
16:55:25 <d34df00d> But I can spawn multiple resources, gladly.
16:55:29 <d34df00d> How do I do that with hspec?
16:56:01 <d34df00d> Right now I'm doing the beforeAll/afterAll combinators to start and stop the external resource, but how do I do that per each thread of computation that parallel spawns?
16:57:41 <slack1256> d34df00d: Can you use a MVar that hold the shared resource?
16:58:32 <d34df00d> Hmm, that works, I think.
16:58:47 <d34df00d> But that's quite low-level, so I wondered if there were higher-level primitives readily available.
16:59:05 <d34df00d> (although I understand this task doesn't come up in testing too often, so probably there are none)
16:59:46 <slack1256> You could allocate the MVar on the beforeAll and spawn all the threads independetly. They will only block when acquiring the resource on the mvar but with "single wakeup" semantics.
17:01:06 <slack1256> d34df00d: A higher level API for concurrency is https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html .
17:01:12 <slack1256> The combinators could be usefult for you.
17:01:53 <d34df00d> Yeah, async is cool! I wasn't able to figure out how to connect it with hspec though.
17:02:58 <d34df00d> I guess I'll just go the MVar route cause it is able to get the job done, and I've already over-engineered lots of things in this project.
17:04:02 <slack1256> I would start with a MVar, they are not "low level" as people think, they just mutexes. As other haskell code, testing code can be refactores easily if you identify shortcomings on abstractions.
17:29:39 <dsal> d34df00d: Another thing to consider:  Use tasty.
17:54:15 <gentauro> what's the max amount of a `sum type`? (to avoid getting -> `Pattern match checker exceeded (2000000) iterations in` when patter matching)
17:56:09 <Axman6> ....
17:56:38 <Axman6> I don't understand the question, but do you have a data type with more than 3m constructors???
17:56:41 <Axman6> 2*
18:01:40 <gentauro> Axman6: no
18:01:47 <gentauro> "only 256"
18:02:02 <Axman6> that's pretty insane
18:02:08 <Axman6> what are you doing>
18:02:11 <Axman6> ?*
18:02:11 <lambdabot> Maybe you meant: v @ ? .
18:02:17 <gentauro> Axman6: nothing at all
18:02:25 <gentauro> they are constructors, but with no fields
18:02:26 <gentauro> :)
18:02:46 <gentauro> Axman6: I'm testing Marlows comment from https://stackoverflow.com/a/3256825
18:03:06 <gentauro> "Exception: a constructor with no fields (like Nothing or True) takes no space, because GHC creates a single instance of these constructors and shares it amongst all uses."
18:03:58 <gentauro> Axman6: but I think I recall SPJ talk from Haskell Exchange 2019 where he spoke of pattern matching and how it increases exponentially for every element you add to the pattern match
18:05:37 <gentauro> so `foo A = …` would be `n` and `foo A A = …` `n²`
18:06:19 <MarcelineVQ> what increases exponentially?
18:09:28 <gentauro> iirc it has to do with the amount of data pattern matched on. An example: `tautology True True True True True True True True True True True True = True; tautology … = …` would be pretty slow
18:09:56 <d34df00d> dsal: how tasty does approach this?
18:10:11 <dsal> d34df00d: It runs your tests in parallel by default.
18:15:50 <sMuNiX> gentauro: "...how _it_ increases exponentially for every element you add to the pattern match..." What does increase here ? is that the time to deconstruct the pattern elements ?
18:24:29 <gentauro> sMuNiX: I don't really recall the details, but i think that Skills Matter website is up and running again so SPJ 2019 talk should be accesible once again
18:24:34 <MarcelineVQ> gentauro: These topics seem unrelated to me. There's 2^12 cases to go through for the purposes of pattern matching  tautology  but that doesn't say anything about the space use of True. While I pattern matching does need space, to track where we are in the matches otherwise we wouldn't get [pattern matching] stack overflows, it's probably not related to the space use of True, but to the number of cases Bool has. In other words, True might take no 
18:24:34 <MarcelineVQ> space, but finding out if we have True takes 2 units of pattern maching space, the case count of Bool.
18:24:36 <gentauro> I might re-watch it again
18:31:20 <gentauro> MarcelineVQ: thx for the answer :)
18:32:15 <MarcelineVQ> hopefully it's right :>
19:13:32 * hackage brick 0.52.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.52.1 (JonathanDaugherty)
19:20:32 * hackage base16 0.2.0.0 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.2.0.0 (topos)
19:31:02 * hackage hapistrano 0.4.0.0 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.4.0.0 (juanpaucar)
20:08:32 * hackage base16-lens 0.1.2.0 - Optics for the Base16 library  https://hackage.haskell.org/package/base16-lens-0.1.2.0 (topos)
20:36:00 <gentauro> MarcelineVQ: I tricked the system xD
20:36:04 <gentauro> (the hacker way)
20:36:26 <gentauro> so the problem is that pattern matching isn't happy for more than one data filed to pattern match on
20:36:28 <MarcelineVQ> You decided to use a Map instead of a large sum type? :>
20:37:33 <gentauro> so i just `generated static code` where I refactored `foo A B = …` to `foo A = fooA` and `fooA B = …`
20:37:44 <gentauro> that seems to handle the `heavy` lift :)
20:38:08 <gentauro> I have to kill my `styllish-haskell`
20:38:30 <gentauro> cos it can't handle the `hurdle` :o
20:58:02 * hackage hapistrano 0.4.0.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.4.0.1 (juanpaucar)
21:49:32 * hackage tldr 0.6.4 - Haskell tldr client  https://hackage.haskell.org/package/tldr-0.6.4 (psibi)
