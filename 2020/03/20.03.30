00:32:11 <thyr15t0r> I use Haskell Platform 8.6.5
00:35:12 <thyr15t0r> what does cabal means? Where I can find the new syntax? Warning: The install command is a part of the legacy v1 style of cabal usage.
00:35:12 <thyr15t0r> Please switch to using either the new project style and the new-install
00:35:12 <thyr15t0r> command
00:59:02 <jackdk> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-install
02:39:28 <kenran> What should I do in the following situation: (1) found a bug in a hackage library (2) forked and fixed it (3) my project uses cabal and nix, the lib is a stack project, so I can't use cabal2nix on it (afaik)
02:39:47 <kenran> Is there a way I can just get one package of the stack project on github and use cabal2nix on that?
02:41:27 <tdammers> if it's on hackage, there should be a .cabal file
02:41:46 <merijn> tdammers: Unless it's not committed in the repo because of hpack >.>
02:42:09 <tdammers> merijn: ah yes, that clusterf*. but if it's hpack, then you could generate a .cabal file, no?
02:42:09 <kenran> tdammers: There is one (there are 3), the stack project contains 3 cabal packages
02:42:33 <kenran> But can I use cabal2nix to target "this package" of the stack project somehow?
02:44:35 <zincy_> Is it idiomatic Haskell to define extra functions on typeclass instances as helper functions for the supported methods?
02:44:54 <kenran> the package on hackage seems to consist of only the one package (https://hackage.haskell.org/package/ftp-client), but the whole github project is a stack project containing three
02:45:53 <merijn> tdammers: If you install hpack first :p
02:46:15 <merijn> zincy_: I don't understand the question?
02:48:15 <zincy_> Basically is it okay to define extra methods in the where clause of a typeclass instance?
02:48:38 <Taneb> zincy_: you can't write them inside the where clause
02:48:47 <Taneb> (of the instance declaration)
02:48:48 <zincy_> Well not extra methods just extra functions
02:48:57 <zincy_> Oh will it just not compile
02:51:07 <merijn> zincy_: You can't arbitrarily add new extra functions, because that doesn't make sense for a typeclass
02:51:27 <merijn> zincy_: You can add helper functions in the "where" block of the functions inside the instance or in the surrounding module
02:52:29 <tdammers> zincy_: the typeclass itself should only contain methods that are vital/defining to the typeclass; anything else should be separate functions written in terms of those methods.
02:52:32 <zincy_> Thanks, is it frowned upon to add helpers there?
02:52:39 <tdammers> define "helpers"
02:52:43 <tdammers> but in general, no
02:52:56 <tdammers> the typeclass itself should only contain the methods that define it
02:53:27 <tdammers> default implementations are mainly used to make typeclasses for which alternative implementations are possible
02:54:07 <merijn> tdammers: He was referring to the instance, though
02:54:08 <zincy_> thanks, understood
02:54:21 <zincy_> Yeah the instance
02:54:26 <merijn> It's just not possible in instance declarations, because that doesn't make sense
02:54:47 <tdammers> right, yes
02:54:58 <merijn> It's not "frowned upon" its *not possible*
02:55:17 <tdammers> so yeah, either put them in a where clause, or make them separate functions (and if you consider them highly internal, don't export them from the module)
02:55:52 <tdammers> IMO, it's fairly idiomatic to write the actual method implementation as a separate function too, and then just reference it in the instance definition
02:56:47 <tdammers> e.g.: fooAppend :: Foo -> Foo -> Foo; fooAppend Foo _ = Foo; fooAppend _ Foo = Foo; fooAppend a _ = a; instance Semigroup Foo where { (<>) = fooAppend }
02:57:48 <zincy_> merijn: :D
02:57:57 <zincy_> hehe
04:02:10 <jchia__> Can I have some tips for how to implement a function to modify a particular field of a data type without too much boilerplate? The field exists only in certain data constructors. https://gist.github.com/jchia/43c3adee41d522d03c546142bb79b651. I would like to avoid exhaustively defining for individual data constructors.
04:03:07 <jchia__> If, for example, there are 10 data constructors that have this field, then defining for individual data constructors would be very tedious.
04:03:12 <mniip> sounds like a lens thing
04:03:44 <jchia__> ok, the modification is polymorphic, so i can't use Traversal' from makeLenses
04:04:01 <jchia__> not polymorphic, but it maps from one type to another
04:04:32 * hackage doctest 0.16.3 - Test interactive Haskell examples  https://hackage.haskell.org/package/doctest-0.16.3 (quasicomputational)
04:05:23 <mniip> um
04:05:30 <mniip> lens can generate proper Traversal
04:07:38 <mniip> % data Foo a = X { _foo :: a } | Y { _foo :: a } | Z {}
04:07:38 <yahb> mniip: 
04:07:40 <mniip> % makeLenses ''Foo;
04:07:40 <yahb> mniip: 
04:07:45 <mniip> % :t foo
04:07:46 <yahb> mniip: Applicative f => (a1 -> f a2) -> Foo a1 -> f (Foo a2)
04:07:51 <mniip> this is a traversal
04:07:55 <mniip> type-changing too
04:08:59 <jeetu> Hi. 
04:09:23 <jeetu> Is there a channel dedicated to brick library?
04:10:40 <jeetu> https://github.com/jtdaugherty/brick
04:22:48 <[exa]> jeetu: probably not, brick isn't that substantial imho
04:22:52 <[exa]> jeetu: but you can ask here
04:25:55 <phil81> can somenone kindly explain appplication/reduction of this function as I just dont get it:  ```incTimes :: (Eq a, Num a) => a -> a -> a incTimes 0 n =nincTimes times n =1 + (incTimes (times - 1) n)`
04:26:36 <merijn> phil81: Where do you get confused?
04:27:52 <phil81> merijn, thx. in `incTimes times n =1 + (incTimes (times - 1) n)`
04:29:09 <phil81> when i'm applying incTimes 5 5 why does it yield 10 
04:29:47 <merijn> phil81: because "incTimes 0 n = n" and the 2nd argument is never changed
04:30:37 <merijn> phil81: And the recursive calls do +1 on all the intermediate results
04:30:47 <merijn> phil81: And the recursion happens 5 times
04:30:51 <merijn> 5+5 == 10
04:33:49 <phil81> thx, merijn
04:35:39 <zincy_> With Servant.Auth.Server is there a way of abstracing out the `AuthResult a` from handlers so your handlers are just passed the `a` in the case of successful auth?
04:35:45 <jeetu> exa: Thank. I will ask here itself. 
04:36:10 <zincy_> Kinda annoying to pattern match in every handler for a data constructor representing failed Auth
04:38:34 <jeetu> Is Brick ok for developing a full fledeged REST tui client with JWT auth check etc?
04:44:01 <ohhaihai> Is there a higher order optic for getting exactly one thing. Someting like `\ x -> partsOf x . filtered ((==1) . length) . folded `, but lazier.
04:45:51 <ohhaihai> I guess I can just do (partsOf . taking 2 $ x)
04:58:44 <stilgart> % :t partsOf
04:58:44 <yahb> stilgart: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
05:25:36 <ohhaihai> % [M.fromList [('a', "lol")]] ^.. (ifolded <. ifolded) . withIndex
05:25:36 <yahb> ohhaihai: [(0,"lol")]
05:26:02 <ohhaihai> % [M.fromList [('a', "lol")]] ^.. ifolded <. ifolded . withIndex
05:26:02 <yahb> ohhaihai: [('a',"lol")]
05:58:31 <jchia__> mniip: The documentation seems to say it's not type changing: 
05:58:45 <jchia__> It says Traversal' not Traversal
05:58:57 <mniip> documentation for what
05:59:34 <jchia__> makeLenses for the non-boilerplate field change that I was asking about
05:59:58 <kenran> suppose I want to process something every 2 minutes. what would you recommend to trigger the task? I found timers-tick on hackage, but I'm not sure if there are alternatives I'm not seeing
06:00:22 <jchia__> i was asking about 2 hours ago
06:00:41 <mniip> jchia__, well, in the particular example in the documentation it's not type changing
06:00:42 <kenran> I want to run the computation in the background, that is, fork after starting my app and let the timer run in a different thread
06:00:47 <mniip> doesn't mean it's never type changing
06:01:46 <jchia__> mniip: Traversal' never changes the type, does it?
06:02:01 <kenran> oh nvm, timers-tick isn't even using real times, just the ticks :/
06:02:35 <jchia__> mniip: Perhaps the documentation is just inaccurate in the description of the types being generated, even for the example
06:03:23 <mniip> jchia__, Traversal' s a ~ Traversal s s a a
06:03:41 <jchia__> mniip: Yeah, but don't I need Traversal s t a b?
06:04:34 <mniip> uhhh
06:04:35 <jchia__> Particularly, Traversal Options1 Options2 (Maybe Text) Config
06:04:46 <mniip> I don't understand your question
06:05:11 <mniip> there is not an inaccuracy in the documentation
06:05:43 <mniip> there is perhaps a lack of demonstration of generality
06:05:49 <mniip> but the example is definitely not "wrong"
06:07:00 <jchia__> mniip: Here's the original question, just in case: https://gist.github.com/jchia/43c3adee41d522d03c546142bb79b651 I can't use a "Traversal' Options1 (Maybe Text)" for implementing convertOptions1ToOptions2, can I? I think I need a "Traversal Options1 Options2 (Maybe Text) Config"
06:07:13 <lyxia> kenran: a loop with delayThread?
06:07:42 <mniip> jchia__, no you cannot
06:07:44 <jchia__> So if makeLenses generates a Traversal' not the more general Traversal, then it's not what I need. But the documentation is saying that makeLenses is generating the less general type.
06:07:54 <mniip> it's not saying that
06:10:05 <mniip> all the documentation is saying is that in this particular case there's an identifier  y :: Traversal' FooBar Int
06:10:28 <mniip> i.e.  y :: Applicative f => (Int -> f Int) -> FooBar -> f FooBar
06:12:05 <jchia__> mniip: Just to be clear, are we talking about the same documentation, this one? https://www.stackage.org/haddock/lts-15.5/lens-4.18.1/Control-Lens-TH.html#v:makeLenses
06:12:18 <mniip> yeah sure
06:12:46 <lyxia> jchia__: The documentation does not say that even for a parametric type it will generate a Traversal'
06:13:32 * hackage ghc-lib-parser-ex 8.10.0.2 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.2 (shayne_fletcher)
06:20:32 <lyxia> jchia__: https://dpaste.org/X5Px It took me longer to install lens than to type this and try it out.
06:29:17 <mniip> lyxia, I mean I did try it out with yahb above
06:31:09 <lyxia> ah ok
06:56:05 <frdg> What does "term level" mean in this sentence? Nullary data constructors, such as True and False, are constant values at the term level
06:59:07 <lyxia> There are terms and there are types. Terms make the executable part of your program, and types tell when the program is well-formed.
07:00:16 <lyxia> thisIsATerm :: ThisIsAType,    True :: Bool,    False :: Bool
07:01:07 <frdg> So the term level would be what is on the right side of the equals sign in a data declaration?
07:01:08 <phadej> ... that if, you simplify enough. Which is probably welcomed here.
07:02:46 <phadej> frdg: yes, in data ThisIsAType = ThisIsATerm | ... the equals sign is not "equals" as in "equation".
07:03:15 <phadej> the GADTSyntax is more uniform in that regard
07:03:20 <frdg> ok I understand thank you!
07:03:25 <phadej> data ThisIsAType where ThisIsATerm :: ThisIsAType
07:06:32 * hackage generics-sop-lens 0.2.0.1 - Lenses for types in generics-sop  https://hackage.haskell.org/package/generics-sop-lens-0.2.0.1 (phadej)
07:09:35 <mjrosenb> just to verify, with lens, there isn't a function like %= where rather than the RHS being (a->a), it is (a->m a), where m is the monad that the whole expr is operating in?
07:11:13 <lyxia> probably not
07:11:40 <mjrosenb> :-(
07:14:16 <mjrosenb> I also remember someone claiming that there was already a function that did what I'm actually trying to do, but I am skeptical of that.
07:14:21 <phadej> I think there could be, if m in (a -> m a) is the same as in `MonadState s m`
07:14:31 <phadej> there is
07:14:41 <phadej> :t (%%~)
07:14:42 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
07:15:19 <mjrosenb> not (%%=)?
07:15:25 <phadej> but
07:15:28 <phadej> :t (%%=)
07:15:31 <lambdabot> MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
07:15:31 <phadej> is different
07:16:02 * hackage vitrea 0.1.0.0 - Profunctor optics via the profunctor representation theorem.  https://hackage.haskell.org/package/vitrea-0.1.0.0 (mroman42)
07:16:12 <phadej> it's not MonadState s m => (a -> m b) -> m ()
07:16:19 <phadej> err
07:16:28 <phadej> it's not MonadState s m => ((a -> m b) -> s -> m s) -> m ()
07:16:41 <mjrosenb> "and return a monoidal summary of the changes", well that sounds useful for other things
07:16:45 <phadej> ah, not een that.
07:20:37 <mjrosenb> so, what I have right now is mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]; and I'm doing tmp <- use $ foo . bar; tmp' <- mapMaybeM baz tmp; foo . bar .= tmp'
07:21:54 <mjrosenb> but this is not ideal because baz (the function argument to mapMaybeM) has to handle some extra cases that would probably be better handled by a argument to filtered, so I could do something like
07:22:44 <mjrosenb> foo . bar . traverse . filtered (\x -> foo x >= 3) `crazyOperator` baz'
07:26:49 <Boarders> Does anyone know with criterion if the memory numbers reported when profiling an ffi function are accurate?
07:26:58 <Boarders> I presume the timing information is accurate
07:27:04 <merijn> Boarders: "no"
07:27:17 <Cale> mjrosenb: I haven't fully taken the time to understand what you're looking for, but remember that lenses are themselves functions of type (a -> m b) -> (c -> m d)
07:27:23 <merijn> Boarders: AFAIK criterion uses GHC's GCStats, which obviously won't track any non-GHC allocations
07:27:35 <Boarders> ok, that is what I thought
07:27:41 <Boarders> the timing is ok though, right?
07:27:46 <merijn> Should be
07:28:15 <Cale> mjrosenb: Sometimes it's useful to apply a lens directly to an effectful thing to get another effectful thing
07:29:35 <Boarders> thanks merijn! That is what I expected is the case
07:32:08 <mjrosenb> Cale: and that m is MonadState when the lens is being consumed by use, %=, or +=?
07:52:57 <mjrosenb> mostly idle curiosity, I noticed that the clock package has some C code in it, which presumably gets compiled with something like emscripted when the package is built with ghcjs. Anyone know about the relative perf of calling emscripten-compiled C code vs. calling native js?
07:54:31 <merijn> mjrosenb: Are you sure?
07:55:00 <merijn> I thought ghcjs simply didn't support C FFI? Has this changed?
07:58:27 <merijn> mjrosenb: I can't find anything implying it supports C FFI, tbh
08:01:59 <mjrosenb> merijn: dunno, but I saw it compiling clock without dying.
08:06:56 <merijn> mjrosenb: Looks like the cbits are only used for darwin or windows, and I'm guessing ghcjs's JS is neither
08:08:18 <mjrosenb> otoh, just because it compiles doesn't mean it works: uncaught exception in Haskell main thread: ReferenceError: h$hs_clock_darwin_gettime is not defined
08:14:10 <phadej> no, you don't get "linker errors". it's a pragmatic choice, I'd say.
08:14:40 <phadej> at least it was back in the days. Maybe someone should propose to make it stricter
08:18:49 <bsima> is there a name for 'foldl (flip identity)'?
08:22:41 <lyxia> "foldl (flip id)" sounds like a good enough name
08:28:23 <bsima> i think i'll call it "smoosh"
08:30:09 <Uniaika> that's a very cute name
08:32:25 <phadej> :t foldl (flip id)
08:32:26 <lambdabot> Foldable t => b -> t (b -> b) -> b
08:32:30 <phadej> :t foldr (.) id
08:32:32 <lambdabot> Foldable t => t (b -> b) -> b -> b
08:33:20 <phadej> I have no idea whether those are the same
08:33:29 <phadej> i.e. compose in the same order
08:33:52 <phadej> but I'd use latter, if that's the order I want
08:34:51 <phadej> (and use `foldr (flip (.)) id` if it's the other way around)
08:35:31 <phadej> hmm. that doesn't typecheck
08:35:34 <phadej> anyway, that.
08:36:40 <phadej> oh, I occasionally wrote foldr (flip id) id -- which doesn't typecheck. foldr (flip (.)) id works fine
08:39:16 <kritzefitz> phadej, they are not the same. `foldr (.) id [(*2), (+1)] 5 = 12`, but `foldl (flip id) 5 [(*2), (+1)] = 11`.
08:39:38 <phadej> > foldr (flip (.)) id  [(*2), (+1)] 5
08:39:43 <lambdabot>  11
08:39:50 <phadej> i'd recommends using `foldr`
08:42:31 <phadej> > foldl' (&) 5 [(*2), (+1)]
08:42:34 <lambdabot>  11
08:43:17 <phadej> is another alternative,  (note, both foldl' with tick, and somewhat more direct (&))
08:43:29 <phadej> (&) = flip ($) = flip id
08:43:53 <fendor> phadej, may I ask you a quick question regarding https://github.com/haskell/cabal/pull/6623? On windows, the following works `app/Main.hs`, but the with a package prefix, it does not, e.g. `p:app/Main.hs` fails, but `p:app\Main.hs` works. Is it ok if I fix that in #6623, or separate pr?
08:44:19 <fendor> s/the following works `app/Main.hs`/ the following works `cabal repl app/Main.hs`
08:44:26 <phadej> if you write a test, and it will fail on windows, that it have to be the same. Otherwise it can be separate.
08:45:25 <phadej> if you ask me about PR which has no tests, I'm more likely to be ignorant.
08:46:04 <fendor> I am writing the tests right now, that is why I noticed this behaviour
08:46:46 <phadej> great :)
08:58:57 <dmj`> ya know, there really should be lens + smart constructor library for the GHC API, specifically the AST (HsSyn, etc)
09:12:02 * hackage ngx-export-tools-extra 0.3.0.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.3.0.0 (lyokha)
09:25:26 <fog> I would like to understand how universal approximations can be used as representations of functions implemented in haskell
09:26:28 <fog> i think tensor networks are universal approximators, as the netoworked tensors make up for what linear matrix multiplications lacks
09:28:07 <fog> with the evolution of linear matricies which are time dependent upon a similarly represented function expanded in terms of tensor networks forms an inductive proof of convergence to a hierarchically partitioned tensor network 
09:28:16 <mjrosenb> wtb: better error messages when I forget to lensify a datatype :-p
09:29:14 <fog> this means i should be able to represent functional programs as networks functions over a restricted set to types
09:29:36 <fog> set of types*
09:30:21 <fog> ie. restricting the group action to be tensor contraction instead of some way of incorperating functions as arguments in a function implementation
09:31:25 <fog> as the mechanism of incorporating incoming edges on a graph
09:34:22 <fog> i wonder what higher order functions like map look like in a tensor expansion
09:38:05 <fog> a tensor taking two tensors as arguments returning a tensor that is block diagonal repetitions of the (a -> b) tensor equivalent, to contract over the "columns"  of the input "list"
09:39:30 <fog> i wonder if there is an algorithmic way to convert lambda calculus programs into tensor network form
09:40:04 <fog> linearising them on a network
09:42:32 <fog> then you could make compressions over it
09:44:43 <fog> so that for large program evaluations when interpreted onto a AST scaffold, substitution of regions by approximate patches is possible in the tensor network form
09:48:12 <fog> and i wonder if there is the possibility to invert the process, to determine a haskell program from a tensor network representation of a computation, from the compilation of a haskell program. 
09:48:42 <fog> or if a tensor network could have been a compressed from one of a nearby haskell program
09:50:49 <fog> and by identifying a nearby approximate tensor network that results from a simple program after compilation
09:51:28 <fog> massively compress the representation of tensor netowrks by identifying nearby generative haskell programs
09:53:13 <fog> allowing then to compress a haskell program by finding the program which closely approximates the compressed tensor network representation of the original program
09:54:22 <fog> the way that the patches are substituted in this compression is a stencil convolution on a graph 
09:56:16 <lyxia> Sounds too good to be true but if you do it you'll be famous.
09:56:27 <fog> enabling a learning process to evolve better substitutions in genetic lambda calculus programs 
09:56:55 <monochrom> If I solve the halting problem I'll be famous, too. Or infamous :)
09:57:56 <zincy_> You are already infamous
09:58:45 <zincy_> :D
10:00:02 * hackage prosidy 1.6.0.2 - A simple language for writing documents.  https://hackage.haskell.org/package/prosidy-1.6.0.2 (jafc)
10:02:41 <fog> its just witnessing the turing equivalence of functions represented by programs of type restricted to tensor networks, by a universal approximation theorem on this space / type
10:04:03 <fog> its just refactoring programs into tensors, which should be possible for some types
10:04:53 <fog> nums I guess, since they need the linear opperators on the values/leafs of the tensors
10:06:02 <fog> and the rest of the constraint is that they need to provide functions for the composition of tensors, which i guess are the representations of the function implementations
10:07:02 * hackage dobutokO2 0.21.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.21.0.0 (OleksandrZhabenko)
10:07:44 <fog> eg "make a block diagonal tensor from this one and take an svd truncation of this
10:09:37 <fog> so functions over nums should be representable as tensor networks
10:10:19 <fog> and how to build these, both their composition, and the construction of each tensor, is equivalent to function implementations
10:11:30 <fog> and constructing each tensor is again built of composition, making a hierarchical partitioning of the tensor network that can be like let bound variables when reused in a scope which is a list of network patches
10:12:32 <fog> network compression then appears similar to approximate code refactoring
10:12:55 <fog> tensor network compression*
10:13:28 <fog> and proceeds by stencil convolution
10:14:08 <fog> requiring measures over the patches, and a substitution generating process which depends on this
10:15:53 <fog> there is also a problem with identifying isomorphic tensor networks which are equivalent function implementations and their refactoring by different implementations 
10:17:03 <fog> where we want to identify or encourages use of unfold, in order to compress its representation as a program, making use of higher order programs 
10:17:54 <fog> that is the reuse of patches in generating new patches to be reused
10:19:09 <fog> the fact that things like recursively defined functions are much more brief than their representation after evaluation 
10:20:26 <fog> as a way to massively compress the representation of tensor networks 
10:22:24 <fog> so that recursive function implementations and functional programs can be used to build tensor network approximators, which are compressible under stencil convolution  
10:24:12 <fog> since stencil convolutions are local navigations on a graph, they can be modelled by nearest neighbour interactions or wider and more elaborate stencils, such as patch selection in a hierarchical partitioning as let bound variables 
10:26:47 <fog> where this hierarchical nature makes tensors seem monadic
10:27:07 <fog> and by extension, lambda calculus programs which consist of them
10:27:49 <fog> where tensor contraction or term evaluation collapses the network
10:29:16 <fog> i didnt know Haskell prgrams formed a monad... is that right?
10:30:55 <fog> the substitution of let bound references by their implementations using equational reasoning, is join
10:32:24 <fog> cojoin would be the refactoring of totally unrolled inductive programs 
10:33:17 <fog> into those function implementations that generate them upon compilation and evaluation 
10:36:17 <fog> where genetic coding would memoise, generate and substitute a library of common higer order functions as patches of the reuse of functions as arguments in recursive programs
10:41:39 <fog> genetic generation can incorporate probabilistic programming via the patch selection likelihood and can be used to explore the space of programs
10:43:05 <fog> where then soft computing via fuzzy logic seems natural
10:44:43 <fog> with a fuzzy neural network architecture as a program representation using tensor distributions 
10:45:56 <fog> where again we need to care about isomporphisms and overcounting, if trying to evaluate propegators by summing over diagrams to approximate time evolution integrals 
10:47:42 <fog> being the parameter running over subsequent stages of program evaluation 
10:48:32 * hackage git-annex 8.20200330 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-8.20200330 (JoeyHess)
10:49:06 <fog> and an action minimising trajectory under some path integral
10:49:31 <fog> i wonder what scattering processes are...
10:50:15 <fog> value calls
10:51:13 <fog> downstream tensor contraction
10:52:31 <fog> references to variables with given implementations
10:53:39 <fog> the ingoing legs to the node are the reuse of already defined functions or values in general, and the outgoing legs are the subsequen use sites in a program when unrolled during evaluation
10:55:34 <fog> this representation of programs as function implementation dereferencing and the corresponding version with multivariate functions replaced by multidimensional tensors
10:57:28 <fog> should by universal approximation, be able to represent any function on numbers or tensors - and the correspondence with lambda calculus programs is awesome
10:58:41 <fog> and it makes a great step by linearising arbitrary programs on a network
11:00:26 <fog> with the graph monadic partitioning of variable dereferencing corresponding to a time evolving linear operator that is the time evolution operator 
11:00:54 * gentauro cough cough
11:01:58 <fog> that is the evaluation of the tensor network
11:03:04 <fog> where feynman path integrals become a form of soft computing by probabilistic genetic haskell
11:03:44 <fog> for which we must solve the graph isomorphism problem
11:04:34 <fog> for identifying isomorpic patches, which might be more compressible - identifying speudo-higher order functions 
11:06:04 <fog> and the learning path is code refactoring 
11:07:12 <fog> and MCMC can be used to sparsely cover the space of programs under some exploration scheme 
11:07:31 <fog> maybe with backprop 
11:08:37 <fog> where the subsequent factorisation of these programs giving rise to a library of useful higher order functions or patches
11:09:04 <fog> for genetic recombination
11:09:17 <fog> and gradient descent substitution
11:11:10 <fog> by allowing for closed form expressions to extend the space of functions restricted to be locally linear operations on a tensor network 
11:11:51 <fog> used to generate the tensors, being equivalent to higher order function implemenntations
11:12:56 <fog> where the tensor contraction with the input arguments being program evaluation like term evaluation
11:13:41 <fog> as the propagation of a signal folding over the network to return the output tensor
11:14:15 <fog> where then recurrent networks and covnets can be envisaged 
11:15:07 <fog> where recurrence can serve as a compression similar to recursively defined functions
11:16:58 <fog> having obtained an accelerated learning process using metaheuristic extreemisation as the summing over histories of the diagrematic expansion
11:17:53 <fog> ie, combining several learning paths, which capture the moments of the underlying distribution
11:17:57 <gentauro> MarcelineVQ: (from yesterday night) -> http://blog.stermon.com/articles/2020/03/30/haskell-data-octet-safe-idiomatic-and-big.html 
11:18:41 <gentauro> It's horrible (I know) but at least it's idiomatic :D (I can't load the module in GHCi ...)
11:20:09 <fog> maximising against some measure for convergence 
11:20:30 <fog> so we should be able to learn the tensor network representations of arbitrary functions
11:20:54 <fog> and possibly even interpolate smoothly between programs
11:21:12 <fog> in a shortest path against some measure
11:23:31 <fog> so we can step from a program from a closeby (in terms of similarity the function it approximates) compression (in terms of code reuse)
11:24:18 <fog> to a program*
11:24:39 <fog> as the learning process, incorperating more complexity to better fit the function
11:25:26 <ysangkok> gentauro: what makes it idiomatic?
11:30:32 * hackage copilot-c99 3.1.2 - A compiler for Copilot targeting C99.  https://hackage.haskell.org/package/copilot-c99-3.1.2 (frankdedden)
11:46:16 <gentauro> ysangkok: usage of algebraic datatypes (sum to be more precisely)
11:46:42 <gentauro> ysangkok: every time I look under the hood in Haskell I get dissapointed :(
11:47:13 <ysangkok> but that applies to everything, not just haskell :P
11:47:53 <gentauro> ysangkok: tell me about it
11:51:29 <moistoreos> why do you get disappointed? performance?
11:52:00 <gentauro> moistoreos: corner cutting and claims of how good it is
11:52:41 <gentauro> I rarelly have been able to write decent code without having to do all kind of "strange stuff" (`seq` here ! there, "trustworthy" over here ...)
11:52:47 <moistoreos> i just recently started learning Haskell. what I keep hearing is how easy it is to refactor
11:53:06 <moistoreos> that's what kickstarted my interest
11:53:08 <gentauro> moistoreos: well that is true
11:53:14 <gentauro> if you are really consistent
11:53:36 <gentauro> if you relly on wildcards when pattern matching (foo _ = …) it's not that easy
11:54:02 <gentauro> but it's good for refactoring cos "most stuff break" if you make a change (which is really good)
11:54:53 <ysangkok> gentauro: but it is decent code even if it has bad performance...
11:55:13 <moistoreos> > but it's good for refactoring cos "most stuff breaks"
11:55:15 <lambdabot>  error:
11:55:15 <lambdabot>      • Variable not in scope:
11:55:15 <lambdabot>          but
11:55:21 <moistoreos> isn't that true for any language?
11:55:40 <gentauro> moistoreos: well not really
11:55:48 <gentauro> if you compare the FP vs the OOP approach
11:55:49 <ysangkok> moistoreos: no because if you have side effects everywhere, it is really hard to know if you can reorder two statements and get the same behaviour
11:55:57 <[exa]> moistoreos: "you will know immediately" is the fine difference
11:56:11 <moistoreos> @exa that's true
11:56:12 <lambdabot> Maybe you meant: vera eval
11:56:18 <moistoreos> i suppose that's what i meant
11:56:28 <gentauro> FP mostly rely on algebraic data types while OOP rely on classes
11:56:37 <solonarv> instead of runtime errors you will get compiler errors/warnings, which is very nice
11:57:07 <moistoreos> solonarv that's what i'm aiming for
11:57:15 <sm[m]> Athas: latest attempt at a stack-based formula: https://github.com/Homebrew/homebrew-core/pull/51183/commits/27185268e51007ae6834ca74f05069c918fec8a3#diff-1c61e1422d0335610acd660023553ae3L34
11:57:36 <moistoreos> i've played with Elixir and love elixir
11:57:42 <moistoreos> but in my day job I'm in C#
11:57:47 <moistoreos> i miss types
11:57:55 <moistoreos> i miss types in Elixir*
11:58:19 <ysangkok> but it is dynamically typed
11:58:25 <ysangkok> so that does not count as typed :)
11:58:39 <moistoreos> dynamic and strong typed is a very different experience
11:59:08 <moistoreos> what i do like about the erlang platform is performance without having to think about it
11:59:27 <moistoreos> at least from a web api approach
11:59:40 <moistoreos> i'll get off my soapbox now :)
12:05:19 <ysangkok> moistoreos: did you know haskell supports dynamic typing? ;)
12:06:19 <moistoreos> ysangkok: sure but i'm experimenting with haskell because i'm still on my "what's my favorite developer experience" adventure
12:07:23 <monochrom> "if you re-factor, most stuff breaks" is a very poor wording.  A much better wording is "if you have mistakes (you will) when re-factoring, you get static reminders"
12:14:50 <subleq> Does anyone know how to write a GADT in Typescript? Typescript people don't seem to know what a GADT is. I'm trying to convert this haskell https://pastebin.com/wBG2XqeW
12:18:39 <ysangkok> subleq: try asking in a typescript channel :P
12:19:03 <subleq> ysangkok: I know...like I said, they don't know that much about more advanced types
12:23:20 <ysangkok> subleq: you can never translate languages this different one-to-one
12:23:23 <monochrom> Does it even exist?
12:23:49 <subleq> there are ways to encode lots of things you wouldn't expect
12:24:40 <monochrom> most encodings are unidiomatic and great ways to win code obfuscation contests.
12:24:40 <ysangkok> subleq: in that case, use a javascript x86 emulator to run haskell. voila, you 'translated' your haskell to typescript! :O
12:24:55 <subleq> excellent
12:25:08 <monochrom> but does GADT even exist in typescript?
12:25:33 <ysangkok> are higher-order types a prerequisite for GADTs?
12:25:43 <ysangkok> i don't think typescript has higher-order types
12:30:29 <ysangkok> subleq: typescript isn't even sound though. that makes it even less attractive to do unideomatic things with it. because what if you do something, and the type system fails you?
12:30:56 <subleq> fast and loose reasoning is morally correct
12:34:19 <ysangkok> but partiality only manifests itself upon execution, no? the type system doesn't know about totality
12:36:19 <ysangkok> if you shuffle around a bunch of haskell code without undefined, the worst it can do is loop endlessly
12:36:32 <ysangkok> if you shuffle around a bunch of typescript, it may just compile and error on runtime
12:40:47 <moistoreos> ysangkok: > if you shuffle around a bunch of haskell code without undefined, the worst it can do is loop endlessly
12:40:50 <moistoreos> ok seems bad
12:40:57 <moistoreos> > if you shuffle around a bunch of typescript, it may just compile and error on runtime
12:40:58 <moistoreos> yikes
12:41:00 <lambdabot>  <hint>:1:31: error: parse error on input ‘of’
12:41:01 <moistoreos> seems worse
12:41:39 <ysangkok> that is my point
12:42:12 <moistoreos> gonna have to agree with you..... a lot tho
12:43:01 <ysangkok> moistoreos: did you see the paper? https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf
12:43:45 <moistoreos> nope. but, i for sure will be reading after work
12:45:25 <solonarv> no mainstream language can stop you from writing an infinite loop, because all these languages are turing complete
12:45:52 <solonarv> so in this sense Haskell is the most sound it's possible for a TC language to be
12:47:42 <ysangkok> solonarv: but f* and idris have a way to mark functions total, and the compiler will only compile those functions if it can deduce that they terminate
12:48:05 <moistoreos> f#?
12:48:08 <ysangkok> solonarv: with those features, you don't lose TC but you gain confidence in some parts of the code
12:48:39 <ysangkok> moistoreos: no, f# does not have anything like that. f* is a different language from microsoft research
12:48:39 <moistoreos> so what is the real difference between idris and haskell?
12:48:48 <moistoreos> hmm. gotcha.
12:48:51 <{abby}> actual dependent types
12:58:09 <solonarv> ysangkok: oh that is true, I forgot about that
13:13:32 * hackage aspell-pipe 0.4 - Pipe-based interface to the Aspell program  https://hackage.haskell.org/package/aspell-pipe-0.4 (JonathanDaugherty)
13:14:42 <MarcelineVQ> why is sql still in the pointer-chasing phase? :( I don't want to squish my adt into multiple tables that reference each other...
13:15:36 <dsal> MarcelineVQ: just use show and read.
13:17:12 <dmwit> Because experience with Ruby on Rails taught us that hiding the cost model isn't actually a good idea?
13:20:02 * hackage katip 0.8.4.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.8.4.0 (MichaelXavier)
13:22:12 <MarcelineVQ> But now I have to invent my own (sure to be full of holes) bookeeping ehe
13:26:21 <frdg> these recaptchas are getting harder and harder...anyways, is there a go to one letter variable name for strings? Similar to how we use n for Ints
13:26:50 <MarcelineVQ> s is pretty direct, str would be the more common shortnening though imo
13:27:07 <frdg> ok great
13:27:39 <dsal> Maybe t
13:27:51 <dmwit> `s` for `String`s treated as objects in their own right; `c:cs` for pattern matching.
13:27:57 <MarcelineVQ> String being [Char] in haskell you're as likely to see  xs  for the shortening, depending what you're doing with it
13:28:13 <dmwit> (`c` is for ~cookie~ `Char`)
13:28:27 <maerwald> MarcelineVQ: str is a common identifier though
13:28:59 <dmwit> maerwald: Why the "though"? That doesn't appear to contradict anything MarcelineVQ said.
13:29:06 <maerwald> Sure
13:29:35 <maerwald> I switched to s
13:29:53 <dmwit> Personally, I'd call it dmwitIsGreat and then knock off for the rest of the day.
13:30:25 <MarcelineVQ> dmwit: iow   todo  is a good shortening for things
13:30:28 <maerwald> Hmm, that might be an interesting policy: whenever you run out of naming ideas, use your own nickname.
13:30:50 <maerwald> Then people know at least who to blame (without even checking git blame)
13:31:18 <dmwit> Until you get folks like me who stick other people's nicks in there to avoid responsibility.
13:31:25 <maerwald> lol
13:31:50 <MarcelineVQ> foo marcySaidNotToCamelCaseMyBinders = ...
13:33:06 <maerwald> let me_go = management
13:34:14 <gentauro> 20:17 < gentauro> MarcelineVQ: (from yesterday night) -> http://blog.stermon.com/articles/2020/03/30/haskell-data-octet-safe-idiomatic-and-big.html 
13:34:17 <gentauro> :)
13:35:23 <Ariakenom> let nord_vpn = 
13:40:19 <MarcelineVQ> gentauro: uh, gooood, might want to explain what is happening if that's intended to be shared
13:41:42 <MarcelineVQ> where  happening  means, what is this, what are you doing with it, what would be happening if you were doing this another way
13:44:31 <ysangkok> MarcelineVQ: there is a link to stackoverflow in the bottom
13:45:49 <MarcelineVQ> :battinggeorgeface:
13:47:00 <dmwit> gentauro: Did you know that Enum instance doesn't match Word8's?
13:48:32 * hackage mattermost-api 50200.5.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.5.0 (JonathanDaugherty)
13:49:32 * hackage mattermost-api-qc 50200.5.0 - QuickCheck instances for the Mattermost client API library  https://hackage.haskell.org/package/mattermost-api-qc-50200.5.0 (JonathanDaugherty)
13:49:56 <dmwit> (The derived instance would match.)
13:50:32 * hackage matterhorn 50200.8.0 - Terminal client for the Mattermost chat system  https://hackage.haskell.org/package/matterhorn-50200.8.0 (JonathanDaugherty)
13:52:58 <dmwit> gentauro: It also violates the "laws", if you can call them that, laid down in the Report. "For any type that is an instance of class Bounded as well as Enum, the following should hold: The calls succ maxBound and pred minBound should result in a runtime error.". https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1310006.3.4
13:53:16 <jollygood2> dmwit, what do you mean?
13:53:36 <jollygood2> [I asked that before the last message]
13:53:59 <dmwit> It's sort of a trash law, but I'd say the least surprising thing would be to satisfy it anyway.
13:54:04 <gentauro> dmwit: then I should remove min and max bounds (thx)
13:54:20 <dmwit> That's... one solution. =)
13:54:42 <jollygood2> > succ $ maxBound :: Word8
13:54:44 <lambdabot>  *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
13:54:46 <dmwit> Another is to offer pred- and succ-alikes that do the wrapping behavior but aren't part of `Enum`, and have `Enum` do the runtime error thing.
13:54:54 <gentauro> MarcelineVQ: as ysangkok mentions, I was trying to make a "pure" idiomatic version of an octet data type (sometimes refered as `bytes`)
13:55:04 <gentauro> I noticed that cos I don't really make any calculation
13:55:26 <gentauro> I'm just `looking up` values, it might be closer to math :) (and 100% cpu architecture)
13:56:00 <dmwit> gentauro: Will you accept a patch that adds unboxed vector support? =)
13:56:25 <gentauro> dmwit: oh, I forgot
13:57:18 <gentauro> I build with:
13:57:18 <gentauro>       -XSafe
13:57:18 <gentauro>       -fpackage-trust
13:57:18 <gentauro>       -trust=base
13:57:30 <gentauro> so I don't think I can have that ;) 
13:57:38 <gentauro> (the SAFE part is the main reason I'm doing this)
13:57:54 <dmwit> Right! Orphan instance package coming right up. =P
13:58:10 <gentauro> dmwit: :D
13:58:38 <gentauro> dmwit: but, as it is right now (unless I can reduce the amount of pattern matching clauses) it's not really usefull
13:58:44 <gentauro> as I can't load it in GHCi
13:58:45 <gentauro> :S
13:58:58 <dmwit> Wow! What goes wrong?
14:00:00 <jollygood2> I'm not sure I like that behavior, runtime error for overflowing integers
14:00:04 <dmwit> I wonder if you can convince it to compile e.g. `x + y = toEnum ((fromEnum x + fromEnum y) `mod` 256)` to the same code that all that pattern matching implements.
14:00:28 <pragma-> nil: hey, sup?
14:00:34 <dmwit> jollygood2: Yeah, it's terrible. ¯\_(ツ)_/¯
14:00:45 <gentauro> dmwit: 
14:00:47 <gentauro> ghc: panic! (the 'impossible' happened)
14:00:54 <gentauro>    (GHC version 8.6.5 for x86_64-unknown-linux):
14:01:01 <gentauro>         getLabelBc: Ran out of labels
14:01:11 <gentauro> ¯\_(ツ)_/¯
14:01:18 <gentauro> but I really like the interface
14:01:28 <gentauro> [ Ox00 .. OxFF ]
14:01:42 <gentauro> it's very similar to `usual` hex notation
14:01:42 <gentauro> :)
14:03:01 <gentauro> I'm also surprised by the memory usage (positive) and it's not that slow (I had my doubts)
14:03:04 <gentauro> :D
14:06:23 <gentauro> 22:57 < dmwit> Right! Orphan instance package coming right up. =P
14:06:49 <gentauro> what if I don't expose the type `Octet` and only the `constructors`, then you can add orphans amirite?
14:06:52 <gentauro> :D
14:08:13 <gentauro> but that would limit the usage (signtaures)
14:41:31 <dmwit> yeah =)
15:18:39 <cdsineonwe> Hi. I was going through a tutorial on Haskell and came across the '&' operator, but I don't seem to have access to it in ghci, which I got by installing Haskell platform through apt. Does that mean my Haskell version is out of date?
15:19:07 <glguy> cdsineonwe: Your GHCi version might be too old
15:19:35 <cdsineonwe> Okay I'll try updating it
15:19:37 <glguy> Or you might need to import Data.Function
15:19:40 <glguy> try that one first^
15:20:31 <gentauro> glguy: is `&` Haskell `pipe` operator? (like F# |>)
15:20:41 <jackdk> :t (&)
15:20:43 <lambdabot> a -> (a -> b) -> b
15:20:52 <glguy> gentauro: Could be, I don't know F#
15:21:13 <jackdk> yeah doesn't look like (&) is imported into Prelude. But also, the distribution packages for GHC are often outdated. There is a PPA, or you can use ghcup to install it. This is less a problem for learning, but can be annoying when you're trying to develop a project
15:24:35 <tommd> @gentauro  I think F#'s |> is just a parsing trick - a reverse Haskell $
15:24:36 <lambdabot> Unknown command, try @list
15:24:45 <tommd> Err, long time since I've been on IRC much.
15:31:58 <dmwit> I mean, & is also just a reverse $
15:33:15 <{abby}> (|>) is more of an operator than ($) is :p
15:33:53 <monochrom> (&) is in Data.Function
15:34:13 <hpc> isn't the main motivation for (|>) that F# is impure, and it controls execution order as well?
15:35:59 <{abby}> no? (|>) is just flip ($)
15:36:01 <{abby}> https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/prim-types.fs#L3412
15:36:48 <{abby}> it's also defined like that in OCaml, where F# got its aesthetic from
15:37:04 <Uniaika> As well as in Elixir~
15:37:29 <Uniaika> (where a bit of macro trickery is involved, but the spirit stays the same)
15:37:31 <phadej> in F# (and OCaml) execution order matters.
15:37:47 <phadej> and also function arity, I guess.
15:37:53 <gentauro> {abby}: I prefer my operators to have a single char if possible :)
15:38:11 <phadej> something like let f x = launchMissiles; \y -> x + y
15:38:35 <phadej> the impurity of OCaml makes you keep that in mind
15:38:56 <{abby}> gentauro: i guess you're not a fan of <<%= then?
15:39:21 <phadej> err, not execution order, but order of arguments you give to functions
15:39:26 <gentauro> phadej: I know a similar example by using `unsafePerformIO` ;)
15:39:43 <gentauro> {abby}: eh, no no no cat :)
15:39:51 <{abby}> no <<<>~ either?
15:40:08 <ysangkok> :t (<<<>~)
15:40:10 <lambdabot> Monoid r => LensLike' ((,) r) s r -> r -> s -> (r, s)
15:40:13 <gentauro> is that even an operator?
15:40:16 <ysangkok> aaah lenses :O
15:40:17 <gentauro> oh, lenses
15:40:18 <gentauro> I'm out
15:40:20 <gentauro> (see you) 
15:40:21 <gentauro> :P
15:40:39 <{abby}> get a list of symbols, shuffle it, look at the result. 50/50 chance it's a lens operator
15:40:47 <phadej> it's not.
15:40:53 <{abby}> :t (<#%~)
15:40:55 <lambdabot> ALens s t a b -> (a -> b) -> s -> (b, t)
15:41:01 <gentauro> :o
15:41:06 <phadej> There are clear rules how the operators are made out of "building blocks"
15:41:07 <gentauro> I was going to hit the bed
15:41:21 <gentauro> but now with all those operators I'm going to have nightmares :|
15:41:22 <{abby}> phadej: i am aware of how lens operators are derived but you can not possibly argue that they don't just look like soup
15:42:24 <phadej> {abby}: if you try to consume them as a "single compound word" sure, but if you decouple them into word-parts, then it's clear << # %~
15:42:47 <gentauro> I mean, I don't understand why people just don't use a name and use the convention -> x `foo` y
15:42:50 <gentauro> is way more readable
15:42:56 <ysangkok> :t (<<) . (#) . (%~)
15:42:58 <lambdabot> error: parse error on input ‘)’
15:43:08 <{abby}> ysangkok: no, not like that
15:43:50 <{abby}> you start with %~, decide you want to return the result as well and add a '<', decide you want it to work on ALens and add '#'
15:44:17 <phadej> gentauro: modifyReturningOldValueWithALens ?
15:44:45 <phadej> gentauro: I guess you can give names to them, but if one actually use those more than accidentally once, the conciseness pays off
15:44:52 <gentauro> phadej: that just looks like `Java` :'(
15:45:01 <phadej> gentauro: that said, using them once "for fun" is not good idea.
15:45:11 <ysangkok> gentauro: if you use unicode you can have your fancy lens operators in one char :P hahahaha
15:46:12 <gentauro> ysangkok: well speaking of the devil (actual code)
15:46:14 <gentauro> (.?.) :: Bits a => a -> Int -> Bool
15:46:14 <gentauro> (.?.) = testBit
15:46:14 <gentauro> (.■.) :: Bits a => a -> Int -> a
15:46:14 <gentauro> (.■.) = setBit
15:46:16 <gentauro> (.□.) :: Bits a => a -> Int -> a
15:46:19 <gentauro> (.□.) = clearBit
15:46:21 <gentauro> (.#.) :: Bits a => a -> Int
15:46:32 <{abby}> please use a pastebin for more than 3 lines or so
15:47:46 * ysangkok pastes bigmatix
15:49:05 <dmwit> Why the dots, though?
15:49:29 <ysangkok> that way, you can claim it is a smiley face and it might get more use in asia
15:51:04 <monochrom> The other Bits operators are already surrounded by dots, e.g., .&.
15:56:03 <gentauro> glguy: thx
15:56:16 <gentauro> (to much copy/pasta ...)
15:56:26 --- mode: glguy set -o glguy
15:59:13 <gentauro> so the good thing about my operators is readability
16:00:02 <gentauro> the problem is though that they are not setup with `setxkbmap -option compose:caps`
16:00:27 <gentauro> so I tend to copy/paste, which makes them a bit useless ...
16:01:02 * hackage avro 0.5.1.0 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.5.1.0 (haskellworks)
16:01:14 <ysangkok> gentauro: gui toolkits usually have a way to input a unicode codepoint by number
16:01:27 <ysangkok> gentauro: for example, i use control-shift-u-7-enter to get a tab in a textarea
16:01:47 <ysangkok> (that is gtk, i believe)
16:02:19 <monochrom> yeah
16:03:47 <gentauro> ysangkok: I'm more a fan of doing stuff like this :) https://charlieharvey.org.uk/page/type_lambda_charcter_with_compose_on_xwindows_on_debian
16:04:28 <gentauro> but it requires and xmonad restart which is a bit annoying ...
16:07:59 <ysangkok> if lens gets really widespread, the unicode consortium might find some printouts with the operators in 5000 years. finally haskellers will get the cultural recognition they deserve!
16:08:59 <ysangkok> and we'll get the unicode block :P
16:10:29 <gentauro> ysangkok: I sometimes use greek letters as value bidings (cos it maps directly to math)
16:10:40 <gentauro> I know I shouldn't, but I do :)
16:11:43 <monochrom> It's OK, use λ for eigenvalues. :)
16:12:25 <monochrom> and wavelengths
16:15:37 <koz_> ysangkok: The L in APL stands for 'Lens' right?
16:16:18 <ysangkok> :t Ap Lens
16:16:19 <lambdabot> error:
16:16:19 <lambdabot>     • Couldn't match type ‘f’ with ‘(->) (Lens s t a b)’
16:16:19 <lambdabot>       ‘f’ is a rigid type variable bound by
16:16:23 <ysangkok> i guess not :(
16:17:30 <gentauro> monochrom: and sometimes I even use capital greek letters for constructors like for example: `data Pi = Π Double` ...
16:17:30 <koz_> gentauro: inb4 some pie-ordering app is written in Haskell.
16:18:11 <gentauro> (I like that it works and that Haskell is able to understand that it's capital greek letter pi. If the lowercase is used, computer says no)
16:19:10 <ysangkok> does this mean i can't use a non-breaking-space as an identifier? i want my money back!
16:20:12 <gentauro> I would like to hear if it's the same with the cyrillic alphabet
16:21:03 <{abby}> pretty sure
16:21:23 <dmj`> does anybody want to hear about the ghc plugin I wrote
16:21:31 <koz_> gentauro: So we can write the most VODKA BEAR BALALAIKA Haskell ever?
16:23:29 <ysangkok> dmj`: yesss
16:23:40 <gentauro> koz_: probably :)
16:24:04 <gentauro> dmj`: sure
16:24:15 <dmj`> ysangkok, gentauro: ok so it basically rewrites some TH splice that generates a function, to the function itself. Avoiding TH altogether.
16:24:41 <dmj`> makeLenses ''Person, gets turned into age = lens _age $ \r f -> r { _age = f }
16:24:48 <koz_> newtype Можетбыть a = Можетбыть (Maybe a)
16:24:58 <dmj`> koz_: loool
16:25:26 <koz_> dmj`: :D
16:25:44 <koz_> I think that's probably a lacking translation though.
16:25:44 <dmj`> koz_: ili nichivo :P
16:26:22 <dmj`> ysangkok, gentauro: the purpose is to avoid cross compilation of TH splices
16:26:28 <koz_> dmj`: Well, yeah, you'd want something more like 'data Можетбыть a = Ничего | Только a' right?
16:26:31 <ysangkok> dmj`: that is the same code that TH would generate right? i suppose the code generation is moved from TH-stage to plugin-stage
16:26:36 <koz_> inb4 Russkel joke.
16:26:56 <ysangkok> dmj`: what do you mean by cross compilation, that is not like x86-to-arm cross compilation or?
16:27:30 <gentauro> koz_: what have I done :o
16:27:46 <dmj`> ysangkok: yea, exactly. GHC has a restriction that splices must be compiled on the target
16:28:00 <gentauro> now all code will be written local (job security) :D
16:28:07 <gentauro> try to outsource that code ;)
16:28:16 <dmj`> ysangkok: so this gets around the need to do say compile haskell code on the iphone over the network
16:28:23 <koz_> gentauro: Is this when we need localized-base?
16:28:42 <dmj`> gentauro, koz_: lambdabot is already russian, so we're halfway there
16:29:02 * hackage hw-kafka-avro 5.0.0 - Avro support for Kafka infrastructure  https://hackage.haskell.org/package/hw-kafka-avro-5.0.0 (haskellworks)
16:29:22 <dmj`> @google monad transformers step by step
16:29:23 <lambdabot> http://www.google.com/url?q=https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
16:29:23 <lambdabot> Title: Уведомление о переадресации
16:29:41 <gentauro> dmj`: that title ... 
16:29:41 <koz_> :D
16:29:43 <gentauro> :D
16:30:00 <ysangkok> dmj`: does it need source code modifications? how do you prevent TH from kicking in?
16:30:23 <dmj`> ysangkok: the plugin kicks in right after the parsing phase
16:30:32 <dmj`> a few phases before th is invoked iirc
16:31:43 <ysangkok> so if i compile one module that would normally need TH, but i don't have the language pragma, that means it will either use your plugin or refuse compilation?
16:32:32 <gentauro> dmj`: how to you handle `imports`?
16:33:05 <dmj`> ysangkok: I don't touch language pragmas
16:33:19 <gentauro> dmj`: oh, roger that
16:33:38 <dmj`> gentauro: for this its simple, you don't change anything. Since Control.Lens exports both lens and makeLenses
16:33:54 <gentauro> I played with the idea of adding/removing PRAGMAS, but I didn't got it to work
16:34:04 <gentauro> s/got/get/
16:34:08 <dmj`> it's a cold world out there
16:34:34 <dmj`> gentauro: there should be some lenses and smart constructors for Ghc's AST
16:36:11 <ysangkok> dmj`: so cross compilation is bascially not possible with TH, but with your plugin it is?
16:36:29 <gentauro> dmj`: I looked into so much Haskell stuff, and I get amazed (dissapointed) every time i run into something I haven't seen before ;)
16:36:56 <dmj`> ysangkok: it is, but you need to compile the splices on the target machine first. That's what the ghc-iserv binary is for, to send splices for compilation over the network.
16:37:13 <ysangkok> oh my god, that sounds insane
16:37:18 <dmj`> gentauro: the top of every mountain is just the bottom of another
16:37:43 <dmj`> ysangkok: it is, but I got it to work w/ nix, except it was trying to send XCode (all 12GB of it) to my phone
16:38:01 <ysangkok> dmj`: your work would help the ghcjs people a lot, no?
16:38:29 <dmj`> ysangkok: maybe, ghcjs has its own template haskell situation. It compiles the splices w/ node.js
16:38:45 <dmj`> ysangkok: ghcjsi needs love though, that's a different story though
16:39:15 <gentauro> dmj`: I tried ghcjs and I never really got it to work
16:39:22 <gentauro> so I gave up
16:39:42 <dmj`> gentauro: nix-shell -p haskell.compiler.ghcjs86
16:39:52 <dmj`> is a quick way to get a working ghcjs
16:43:04 <gentauro> dmj`: my NixOS setup is `special`
16:43:28 <gentauro> in the sense that `stack` handles everything and is independent of the OS
16:43:28 <dmj`> gentauro: every nixos is a unique snowflake
16:43:35 <gentauro> dmj`: xD
16:43:35 * dmj` gasps
16:43:41 <gentauro> but I like it
16:43:57 <dmj`> I had issues w/ stack on nixos
16:43:59 <gentauro> I came from QubesOS
16:44:17 <dmj`> gentauro: since moving to nix, I never use stack or cabal (the binary)
16:44:33 <dmj`> gentauro: just runghc in bash functions
16:45:42 <gentauro> I'm quite happy with `stack` :)
16:45:46 <dmj`> gentauro: function ghcid () { ${pkgs.haskellPackages.ghcid.bin}/bin/ghcid -c 'runghc Setup.hs configure && runghc Setup.hs repl compiler' }
16:45:58 <dmj`> gentauro: then I just `nix-shell --run ghcid`
16:46:23 <dmj`> gentauro: it's all the same, both call into Cabal
16:46:27 <dmj`> (the library)
16:46:37 <gentauro> and I also like that merijn gist on stack vs cabal reached /r/Haskell -> https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
16:47:15 <MarcelineVQ> i use stack to make a new project, then delete package.yaml and use cabal :>
16:47:33 <dmj`> MarcelineVQ: cabal init not good enough ? :P
16:47:52 <gentauro> MarcelineVQ: you mean you build once (that generates the .cabal file) and then you remove `package.yaml` right? :D
16:48:03 <dcoutts_> I was just about to ask what's missing from cabal init
16:48:42 <MarcelineVQ> gentauro: it'll make a .cabal to start with as well, my version does anyway
16:48:53 <MarcelineVQ> does init make a skeleton project too?
16:49:33 <monochrom> Yes.
16:50:15 <jumper149> Hi, I want to work on my xmonad config on NixOS and would like to use ghci/ghcid, but it doesn't find the dependencies when I go into nix-shell with: "nix-shell -p haskellPackages.xmonad{,-contrib}"
16:50:40 <jumper149> I think using cabal would be a little overkill here^^
16:50:55 <gentauro> dmj`: you `ghcid` function looks pretty cool. But it's limited to `nix/NixOS` though. I have a (on-going) project on creating reproducible builds for Haskell
16:51:02 <gentauro> so `stack` is really good for that
16:51:14 <gentauro> (specially on Debian/Ubuntu)
16:51:17 <dmj`> jumper149:  nix-shell -p 'haskellPackages.ghcWithPackages (p: with p; [xmonad xmonad-contrib])'
16:52:19 <dmj`> gentauro: yea but with NixOS you can reproducibly build the whole OS down to the kernel. Third-party deps. can switch up on you otherwise.
16:53:03 <MarcelineVQ> monochrom: a little too bare-bones after trying it just now but not bad
16:54:53 <monochrom> "cabal init -i" asks you questions and fills in more.
16:55:46 <monochrom> answer "n" to "Should I generate a simple project with sensible defaults?" because "y" goes back to without -i
16:55:46 <gentauro> dmj`: yes, now we just need to convince the hole world to use NixOS (I'm all up for it) :D
16:55:58 <gentauro> (or at least `nix` as a package manager)
16:56:06 <monochrom> I am actually disappointed that -i is not the default.  It used to be.
16:56:26 <solonarv> I was also surprised by this
16:57:43 <MarcelineVQ> ehe that's good, and all the options do seem to be there which is great, though a bit more time consuming than  stack init foo
16:58:08 <MarcelineVQ> *stack new
16:58:36 <jumper149> dmj`: ty, `haskellPackages.ghcWithPackages` would be in Haskell-terms roughly of type `(Pkgs -> [Pkg]) -> Pkg`? I'm still learning nix^^
17:00:44 <jackdk> something like that, but the arg is the haskell package set specifically
17:01:07 <dmj`> jumper149: yes, sort of. The key thing ghcWithPackages uses is .env, which I believe is responsible for constructing the ghc-pkg list in the shell. Your previous snippet won't even put ghc in the shell.
17:01:57 <dmj`> jumper149: but yea that type looks right... if nix had static types :) 
17:02:00 <monochrom> Is anyone interested in an antique copy of cabal-install 1.22? :)
17:03:56 <ysangkok> monochrom: how is it superior?
17:04:14 <jumper149> dmj`: I have some tools like ghc in my nix-env so I can use ghci occasionaly just to calculate the average of some numbers or something like that :p
17:04:19 <monochrom> which one? antique cabal-install?  cabal init -i ?
17:06:24 <ysangkok> monochrom: the antiquity
17:06:35 <monochrom> It has archaelogical value :)
17:07:15 <monochrom> In Civ5, it can be made a landmark xor put in a mueseum, for culture bonuses
17:07:25 <ysangkok> i imagine it might be smaller, and as such easier to encode in stone for eternity
17:07:59 <sm[m]> monochrom: how much do you want for it ?
17:08:11 <dmj`> monochrom: what will you start the bid at
17:08:15 <monochrom> 5 uraniums :)
17:08:28 <monochrom> wanna build more Giant Death Robot
17:09:45 <jumper149> Does ghcid work with adding and deleting files in the import-path yet?
17:13:20 <hexagoxel> jumper149: --restart file-that-you-touch-if-import-path-has-changed? I suppose import-path is a nix thing, so I don't know how complex that touching is to implement.
17:17:35 <dmj`> jumper149: I don't think so, that's like hot-reloading
17:17:57 <jumper149> hexagoxel: Nix has nothing to with what I mean. I just mean the relative path you give ghc/ghci with the -i flag, like -ilib
17:18:18 <jumper149> It's also not too important, was just curious :)
17:19:24 <jumper149> but `ghcid --restart=lib` might just be exactly what I mean
17:31:48 <jumper149> dmj`: You were right it doesn't work :'(
17:32:12 <dmj`> jumper149: ;_;
17:35:10 <jumper149> But to everyone using xmonad I can only recommend using ghcid to edit its config. How is it even possible that I havent done it before it's just such a smooth experience in comparison to reloading xmonad on and on ^^
17:35:38 <jumper149> And I now even have -Wall in my .ghci file... honestly a dream
17:38:32 * hackage frisby 0.2.4 - Linear time composable parser for PEG grammars  https://hackage.haskell.org/package/frisby-0.2.4 (BenGamari)
17:38:36 <sm[m]> ghcid FTW!
17:39:20 <sm[m]> assisted by entr!
17:50:42 <koz_> :t mapMaybe
17:50:44 <lambdabot> (a -> Maybe b) -> [a] -> [b]
17:59:17 <koz_> Is there a way to write 'maybe [] pure' more concisely?
18:00:12 <mniip> :t asum
18:00:14 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
18:00:39 <jackdk> % :t ala First foldMap
18:00:40 <yahb> jackdk: Foldable t => t (Maybe b) -> Maybe b
18:00:42 <mniip> :t afold
18:00:45 <lambdabot> error:
18:00:46 <lambdabot>     • Variable not in scope: afold
18:00:46 <lambdabot>     • Perhaps you meant one of these:
18:00:48 <jackdk> hm, not quite
18:00:58 <mniip> it is afold
18:01:05 <jackdk> % :t afold
18:01:05 <yahb> jackdk: ; <interactive>:1:1: error:; * Variable not in scope: afold; * Perhaps you meant one of these: `S.fold' (imported from Data.Set), `IS.fold' (imported from Data.IntSet), `fold' (imported from Data.Foldable)
18:01:16 <Axman6> liftToMaybe
18:01:23 <Axman6> listToMaybe*
18:01:44 <monochrom> No, ths is maybeToList
18:01:56 <monochrom> although, maybeToList probably doesn't exist yet.
18:02:07 <mniip> does it not?
18:02:16 <monochrom> @hoogle maybeToList
18:02:17 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:02:17 <lambdabot> System.Directory.Internal.Prelude maybeToList :: () => Maybe a -> [a]
18:02:17 <lambdabot> Distribution.Compat.Prelude.Internal maybeToList :: () => Maybe a -> [a]
18:02:24 <monochrom> Oh, it's already there
18:02:25 <koz_> Go figure lol. Thanks!
18:02:26 <Axman6> :t toListOf _1
18:02:30 <lambdabot> Field1 s s b b => s -> [b]
18:02:47 <monochrom> Oh, and it always exists in lens form haha
18:03:00 <Axman6> % toListOf _Just Nothing
18:03:01 <yahb> Axman6: []
18:03:09 <Axman6> % toListOf _Just (Just 2)
18:03:09 <yahb> Axman6: [2]
18:03:14 <koz_> monochrom: 'There's a lens for that!' should be a catchphrase.
18:03:17 <jackdk> % foldMap (pure @[]) (Just 3)
18:03:17 <yahb> jackdk: [3]
18:03:27 * monochrom cries
18:16:21 <Axman6> yeah foldMap pure is pretty nice
18:16:27 <Axman6> :t foldMap pure
18:16:29 <lambdabot> (Foldable t, Monoid (f a), Applicative f) => t a -> f a
18:25:03 <codeguru> So I just learned about Churchill numbers and now I think they're the  coolest things ever
18:26:02 * hackage tree-sitter-ql 0.1.0.2 - Tree-sitter grammar/parser for QL  https://hackage.haskell.org/package/tree-sitter-ql-0.1.0.2 (rewinfrey)
18:26:25 <Axman6> what are churchill numbers?
18:26:38 <solonarv> "Churchill" numbers? is that a typo for "Church" numerals?
18:29:50 <codeguru> woops yeah
18:29:59 <codeguru> church numerals I mean
18:33:23 <Nolrai> So is it posible/easyt to generate random functions, pass them to an higher order pure function, and have them only actually generate the values needed?
18:33:50 <koz_> Nolrai: In what context?
18:36:29 <Nolrai> I want to effectively "lift" mergeWithKey from IntMap into the Rand monad. The function is only ever going to be called on the same key object pair once per pair of maps, so "observationally" what I pass in can be a pure function.
18:37:08 <mniip> well there is CoArbirary
18:37:16 <mniip> CoArbitrary
18:37:50 <Nolrai> That might work.
18:38:21 <mniip> the gist is that in A -> B you use the A to perturb the Gen B
18:40:34 <Nolrai> That should work.
18:41:27 <Nolrai> I mean I only actually need a little more then one bit of randomness per ..invocation.
18:42:27 <Nolrai> (I just need to choose between two options with some small number odds.)
18:43:17 <lyxia> @check \(Fn f) x -> f (f x) === (x :: Bool)
18:43:20 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 3 shrinks):
18:43:20 <lambdabot>  <fun> False True /= False
18:43:53 <Nolrai> What does that even mean?
18:44:31 <Nolrai> @type ===
18:44:33 <lambdabot> error: parse error on input ‘===’
18:44:39 <Nolrai> @type (===)
18:44:40 <lambdabot> (Eq a, Show a) => a -> a -> Test.QuickCheck.Safe.SProperty
18:52:39 <Axman6> So speaking of church numerals, is there an equivalent for binary numbers? I've been trying to figure out what that would look like, having functions passed in for one and zero I guess?
18:53:17 <koz_> Axman6: Think about the Boehm-Beraducci encoding for lists, except instead of 'a', you have 'Bool'.
18:53:27 <Axman6> so zero would be \one zero x -> zero x, one would be \one zero x -> one x, two = \one zero x -> one (zero x)
18:53:31 <koz_> (well, non-empty lists, but ehh)
18:53:46 <Axman6> not sure if the x is necessary in any of that
18:54:13 <Axman6> I'll take a look I haven't heard of Boehm-Beraducci lists
18:54:17 <monochrom> Do you also want to encode Bool? Or do you want to keep Bool as Bool? :)
18:54:44 <koz_> Axman6: It's basically the build-destroy shindig GHC uses for list fusion.
18:54:48 <monochrom> Boehm-Beraducci is like Church but typed and uses "forall".
18:54:56 <koz_> And monochrom - I guess you're Xzibit now?
18:55:11 <monochrom> what is Xzibit?
18:55:17 <Axman6> yp dawg
18:55:20 <Axman6> yo*
18:55:24 <koz_> monochrom: 'Sup dawg, we herd u like [insert whatever here]...'
18:56:03 <monochrom> heh ok
18:56:10 <Axman6> yo dawg, I heard you like recursion...
18:56:13 <monochrom> just haven't known it has a name
18:56:22 <monochrom> @quote monochrom dawg
18:56:23 <lambdabot> monochrom says: Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
18:56:37 <monochrom> Hmm I forgot why I said Co there.
18:56:57 <monochrom> @quote monochrom yo.dawg
18:56:57 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
18:56:59 <koz_> Co-dawg lolol
18:57:31 <monochrom> I'm sure I was thinking the category-theory "co", but I can't remember what it was coing.
18:57:50 <koz_> Or _where_, seemingly.
18:58:15 <koz_> *ba-doom-psh*
19:00:54 <monochrom> @quote monochrom coproduct
19:00:54 <lambdabot> No quotes match. Take a stress pill and think things over.
19:00:58 <monochrom> aww
19:01:39 <monochrom> Cocartes says: coproduct ergo sum.  :)
19:02:18 <koz_> monochrom: Rofl.
19:02:52 <monochrom> (This is a deep pun.  Recall that Descartes gave us cartesian product.)
19:03:00 <koz_> Is Haskell merely the union of wordplay and category theory?
19:03:20 <monochrom> Yes, there is a lens for that.
19:11:42 <Nolrai> @quote monochrome yes
19:11:42 <lambdabot> No quotes for this person. You type like i drive.
19:11:51 <Nolrai> @quote monochrom yes
19:11:51 <lambdabot> monochrom says: I had a nightmare. haskell-cafe let through spams. My bayesian spam filter let them through too.
19:12:29 <monochrom> Yes I think I actually had that dream.
19:13:00 <Nolrai> I clearly don't understand how quote works.
19:13:27 <monochrom> the good old days when I had nothing to do so nothing to worry about, not even those "late to exam" dreams, but did worry about haskell-cafe because that's the only place I spent time on :)
19:13:41 <monochrom> Oh, it has two conflicting syntaxes.
19:14:21 <monochrom> "@quote xxx" (one word after @quote) means look for xxx, could be nickname could be a word in the quote.
19:14:24 <dmwit> Nolrai: ba*yes*ian
19:14:35 <monochrom> "@quote yyy xxx" now "yyy" is nickname
19:14:45 <monochrom> Also some regexes are supported.
19:14:47 <dmwit> ?quote monochrom \ yes\ 
19:14:47 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"\ yes\" (line 1, column 7):
19:14:47 <lambdabot> unexpected end of input)
19:14:59 <dmwit> hah
19:15:01 <dmwit> ?quote monochrom \ yes\ .
19:15:01 <lambdabot> monochrom says: but yes there is hope that haskell 2039 becomes haskell 1971, all is not lost.
19:15:06 <dmwit> I can defeat your strip.
19:15:28 <Nolrai> I would like to know the context of that quote.
19:15:38 <monochrom> 32-bit unix time
19:15:39 <dmwit> ah... now that is harder
19:16:02 <dmwit> You are lucky monochrom has such a good memory.
19:16:16 <dmwit> I'm like 80% sure if you picked a random dmwit quote I wouldn't remember what it was about.
19:16:19 <monochrom> and also how the next Haskell standard is always procrastinated to one more "next year"
19:16:42 <jackdk> @quote dmwit
19:16:42 <lambdabot> dmwit says: "Any coder worth his salt can do the impossible."
19:17:25 <monochrom> keep procrastinating, and any finite-bitsize clock will wrap around.
19:18:51 <Nolrai> Halting problem, no problem!
19:19:48 <dmwit> Okay. I think I actually do know the context of that one.
19:20:36 <dmwit> There was some discussion about C FFI and the impossibility of something or other relating to touching specific struct fields.
19:21:42 <Nolrai> What does the second sentence of "When mergeWithKey is given three arguments, it is inlined to the call site. You should therefore use mergeWithKey only to define your custom combining functions." mean?
19:21:53 <Nolrai> I don't get the "therefore".
19:22:19 <glguy> It means every time you use this it will make a lot of code, so don't use it much. Use it once and name that use of it
19:23:49 <Nolrai> Hmm. Thats a problem.
19:24:43 <dmwit> Is it?
19:25:03 <dmwit> I mean, you could literally write `notMergeWithKey a b c = mergeWithKey a b c` and then just always use that, right?
19:25:33 <dmwit> Maybe toss a `{-# NOINLINE notMergeWithKey #-}` if you're paranoid.
19:25:45 <glguy> Or you could ignore the advice nad do whatever you had in mind in the first place
19:25:59 <dmwit> That also seems super likely.
19:28:44 <monochrom> Perhaps either you don't mind a little code duplication or you only have one call site so the problem doesn't even exist.
19:59:02 * hackage hoppy-generator 0.7.1 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.7.1 (khumba)
20:00:02 * hackage hoppy-std 0.7.1 - C++ FFI generator - Standard library bindings  https://hackage.haskell.org/package/hoppy-std-0.7.1 (khumba)
20:17:46 <abhixec> how do I convert Maybe String to String? (I am very new to haskell) I just started reading the haskell book. I want to know because I am tweaking my xmonad.hs I am trying to append maybe string to string and getting type match error
20:18:18 <monochrom> Have you thought about "what happens if Nothing?"?
20:18:20 <dsal> abhixec: Are you sure you don't want a Maybe String in that case?
20:19:32 <monochrom> To a large extent you should first understand why someone else was giving you this oh-so-indirect Maybe String in the first place.  Why didn't they simply give you String?  Are they wankers or do they have just cause?
20:20:19 <Axman6> Just "cause"
20:20:20 <monochrom> Because if they are not wankers then your mindset of "convert" is barking up the wrong tree.
20:20:29 <monochrom> Oh haha I didn't notice that!
20:20:50 <monochrom> I'm such a genius, even when I don't design puns I still produce puns.
20:21:08 <Axman6> data DickMaybe cause = Wanker | Just cause
20:21:22 <monochrom> haha
20:21:57 <dsal> > let maybeStringAppend Nothing s = Nothing;  maybeStringAppend (Just ms) s =   Just (ms <> s)  in    maybeStringAppend (Just "cause") " wanker"
20:22:00 <lambdabot>  Just "cause wanker"
20:22:21 <dsal> (of course, that's not how I'd write that)
20:22:31 <MarcelineVQ> data Choice = Yobbo |​​ Wanker
20:23:26 <Axman6> abhixec: we're not being particularly helpful, can you share the code which you're working on? We might be able to help you figure out if it makes sense to appent a Maybe String to a String in the particular case you're working on
20:24:02 <abhixec> give me sec let me upload the code snippet 
20:26:56 <dsal> > let maybeStringAppend ms s = fmap (<> s) ms  in    maybeStringAppend (Just "cause") " wanker"  -- that's not too hard to read, I guess.
20:26:59 <lambdabot>  Just "cause wanker"
20:27:43 <dsal> My first guess used <$> which is probably not great in an answer to a "very new to haskell" question
20:32:53 <Nolrai> @pl fromOdds (aOdds, bOdds) a b = fromList [(aOdds, a), (bOdds, b)]
20:32:54 <lambdabot> fromOdds = uncurry ((((fromList .) .) .) . (. flip (flip . ((:) .) . (,)) []) . flip . (((.) . (:)) .) . (,))
20:33:32 <abhixec> https://pastebin.com/B4NB6xFm
20:35:10 <dsal> Why is windowCount `X (Maybe String)`?
20:36:47 <Axman6> abhixec: try this: https://pastebin.com/vSirbjCN
20:36:49 <dsal> In any case, it's not `Maybe String`
20:37:11 <Axman6> (annoying that pastebin sucks as Haskell syntax highlighting)
20:37:24 <Nolrai> I bet X is a monad or applicative though.
20:37:29 <dsal> Heh, ecological code.
20:37:37 <dsal> xapplicative
20:37:50 <Axman6> yeah I’m pretty sure X is the monad for Xmonad
20:41:08 <mniip> it's more of a XLaxCartesianFunctor
20:42:57 <Axman6> is there an Xmonad lens library?
20:55:57 <abhixec> thanks alot Axman6 
20:56:09 <abhixec> that worked!
20:56:38 <Axman6> hooray
20:57:01 <abhixec> any good recommendation on how to fast tracke learning Haskell?
20:57:25 <Axman6> take dibblego's FP course, preferably with dibblego
20:57:40 <dibblego> sup!
20:58:29 <ysangkok> where can i read more about this course?
21:02:17 <jackdk> https://github.com/data61/fp-course
21:02:32 <Axman6> hopefully soon to move out of the Data61 org
21:04:07 <dsal> abhixec: The fastest way to learn haskell is to take it a bit slow.
21:09:09 <abhixec> dsal: got it!
21:29:20 <sm[m]> I like that
21:30:55 <sm[m]> abhixec I’d also say @where htac
21:31:09 <sm[m]> @where htac
21:31:09 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
21:34:21 <Axman6> I hadn't heard of that, looks nice!
21:40:14 <sm[m]> I think it’s great, but no one has heard of it
21:41:36 <azuline> sm[m], would it be fitting for someone who has experience with other FPs but not haskell specifically?
21:43:21 <abhixec> thanks sm[m] I will that a go!
21:49:02 * hackage oidc-client 0.5.1.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.5.1.0 (ShoKuroda)
21:59:53 <sm[m]> I think it’s a great fast well written hands on intro for any prrigrammer
22:03:44 <isovector1> can i use `syb` to change a parameterized type?
22:03:54 <isovector1> ie use it ala `cata`
22:04:24 <abhixec> sm[m]: just bought that book. Going to start reading it!
22:08:05 <sm[m]> Nice
22:17:32 * hackage generic-override 0.0.0.0 - Provides functionality for overriding instances for generic derivation  https://hackage.haskell.org/package/generic-override-0.0.0.0 (carymrobbins)
22:18:32 * hackage generic-override-aeson 0.0.0.0 - Provides orphan instances necessary for integrating generic-override and aeson  https://hackage.haskell.org/package/generic-override-aeson-0.0.0.0 (carymrobbins)
22:31:03 <angerman> cocreature: can I get some verbosity out of ghcide? We see it randomly segfault 🤷‍♂️
23:32:02 <kamatti> Hello everyone, would any one be able to tell me where i can post job advertisements relating to haskell? For example, a simple assignment for school?
23:51:40 <Axman6> The answer is: nowhere
23:52:09 <koz_> I'm curious if this individual is taught by someone who's in this channel.
