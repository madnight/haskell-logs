00:00:54 <Axman6> It's very likely, I used to find my students
00:02:44 <hwatatiming> is there a split function can split "a=b" to (a,b)?
00:03:00 <hwatatiming> ("a","b")
00:03:49 <hwatatiming> I need to write a simple parser to parse config file, like "a = b\r\n c=d" to [(a,b),(c,d)]
00:06:13 <opqdonut> > break (=='=') "a = b"
00:06:16 <lambdabot>  ("a ","= b")
00:06:37 <opqdonut> > lines "x\ny"
00:06:40 <lambdabot>  ["x","y"]
00:08:18 <hwatatiming> fromList . fmap f . lines . readFile $ "a.conf"
00:08:44 <hwatatiming> a.conf is look like "a = b\r\n c = d"
00:08:57 <hwatatiming> I don't know what this f is
00:09:40 <hwatatiming> f :: String -> (String, String)
00:10:01 <opqdonut> yes, f would parse one line
00:10:18 <opqdonut> (I'm intrigued by the pure `readFile` function... :)
00:10:29 <hwatatiming> f is like splitOn, but splitOn return a list not a tuple
00:10:49 <opqdonut> well you can write a function f that uses splitOn
00:11:02 <opqdonut> this sounds like homework so I'm not going to give you the answer
00:12:38 <hwatatiming> wait, there's no splitOn in Data.List...
00:13:50 <hwatatiming> also Data.String...
00:14:37 <kritzefitz> Data.List.Extra has splitOn, but then you need the extra package.
00:15:07 <opqdonut> the function break I demoed above is in the standard library
00:15:57 <kritzefitz> splitOn should also be sufficiently easy to implement on top of the standard break.
00:16:01 <hwatatiming> split something is a very common operation on String and List
00:16:29 <kritzefitz> ...as long as you only want to break on single characters.
00:23:32 * hackage Cabal 3.2.0.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-3.2.0.0 (HerbertValerioRiedel)
00:24:24 <kritzefitz> Usually yes, but I tend to not need it that often. When I notice that I need splitOn that's usually the point at which I start wondering if I should use a proper parser combinator library.
00:24:58 <kritzefitz> You could also use Text or ByteString instead which have splitOn natively IIRC.
00:26:05 <hwatatiming> yeah
00:27:13 <hwatatiming> Data.Text.Lazy.IO.readFile :: FilePath -> IO Text
00:27:29 <hwatatiming> so I can use Data.Text.splitOn
00:28:08 <kritzefitz> You'd have to use Data.Text.Lazy.splitOn. The two packages should not be mixed up.
00:28:43 <kritzefitz> s/packages/modules/
00:29:42 <gentauro> ski: thx for the link yesterday (Sigyn) :)
00:30:04 <Ariakenom> hwatatiming: you dont want lazy IO
00:32:40 <hwatatiming> but I need readFile from Data.Text.Lazy.IO right?
00:32:46 <hwatatiming> splitOn from Data.Text
00:33:24 <kritzefitz> There is also Data.Text.IO.readFile for strict Texts.
00:34:10 <hwatatiming> what's the different? about lazy and strict?
00:36:14 <kritzefitz> Strict Texts are a continuous block of memory, with the data in it. That means all data in it has to be evaluated at the same time. Lazy Texts are a list of “chunks”. Each of the chunks is a strict Text itself. Each chunk can be evaluated (or not evaluated) separately.
00:38:02 * hackage gdelt 0.1.0.0 - GDELT V2 (Global Database of Events, Language, and Tone)  https://hackage.haskell.org/package/gdelt-0.1.0.0 (ocramz)
00:38:16 <kritzefitz> Lazy Texts are mostly useful when you work with large amounts of Text that shouldn't be kept in memory all at once.
00:39:16 <kritzefitz> In contrast with String (aka [Char]) where every character can be evaluated without evaluating the others.
00:54:17 <hwatatiming> https://paste.ubuntu.com/p/RHQZS28P63/
00:55:09 <hwatatiming> this code is ok?
00:56:02 * hackage ploton 1.2.0.0 - A useful cli tool to draw figures  https://hackage.haskell.org/package/ploton-1.2.0.0 (ishiy)
00:56:28 <hwatatiming> I hate to use qulified...
00:56:57 <hwatatiming> but there're too many same function names in different modules
01:16:09 <__monty__> Qualified names and explicit imports are great.
01:16:38 <__monty__> And many modules are designed to be imported qualified, like Data.Map and Set.
01:17:55 <__monty__> hwatatiming: Looks fine to me. If you're serious about writing an irc client though I'd take a look at glirc.
01:23:26 <merijn> I (try) to make everything either qualified or explicit. (Although I sometimes allow exceptions when I have, like, a "parser module" where I import megaparsec/optparse/whatever unqualified because I use so many different names from it)
01:26:26 <arianvp> The stack version bundled with nix bundles hpack 32 instead of hpack 31 that stack normally does
01:26:36 <arianvp> and this is very annoying. any easy way to override this somehow?
01:30:38 <merijn> "patch stack"? :p
01:32:43 <merijn> Or don't use stack's hpack support, I suppose, which I'd recommend anyway. I try to keep out of Haskell tooling discussions, but "hpack is bad" is the one hill I'll die on >.>
01:44:43 <arianvp> merijn: I am slowly starting to agree
01:44:55 <arianvp> I think stack authors are also starting to agree
01:45:08 <arianvp> they now suggest comitting the generated cabal files; otherwise reproducibility problems etc
01:45:36 <arianvp> Cabal 2.0 format gives me almost everything I want; except for defining DefaultExtesions on a project-level basis
01:46:46 <dcoutts_> arianvp: DefaultExtesions in a cabal.project file would violate the author vs builder role distinction :-(
01:47:06 <dcoutts_> that's why it lives in the package file (author) not project file (builder)
01:47:25 <arianvp> yeh so what hpack  does it allows you to "include" common stanzas from different files
01:47:37 <arianvp> so all our hpack files have an "import default extensiosn.yaml" stanza
01:48:03 <arianvp> but yeh then your cabal file isnt self-contained so also not great
01:50:11 <dcoutts_> arianvp: I've always wanted an include feature for cabal.project files. The cabal.project should explicitly include the cabal.project.{local,freeze} rather than implicitly. And then you could include any others.
01:50:21 <dcoutts_> But that's not inclusions for package .cabal files
01:51:01 <arianvp> all these problems im now having would go away of hpack didnt put the version number in a comment in the cabal file
01:51:16 <arianvp> means two people with  slightly different stack version can not reproduce eachothers builds. even when you commit the cabal file
01:51:29 <arianvp> as the one with the newer version of hpack will just override the cabal file and then complain afterwards
01:51:36 <arianvp> it's super annoying :(
01:51:42 <merijn> I think DefaultExtensions is also bad, to xD
01:51:50 <arianvp> merijn: big disagree :P
01:52:15 <merijn> I prefer having the information about which extensions are on to be obvious from the file I'm editing
01:52:41 <merijn> arianvp: tbh, there's a fairly trivial work around to get package wide extensions
01:52:52 <arianvp> we have one blessed set over the entire codebase. theyr'e documented why they're added. They're all rather uncontroversial and should go into (The now cancelled) Haskell2020 :P
01:53:06 <merijn> You can just enable CPP in the Haskell files and #include a file enabling said extensions
01:53:08 <arianvp> (Or what we invision should be Haskell2020)
01:53:30 <merijn> Of course you'd have to duplicate those extensions between the included file and the cabal file, but that seems manageable
01:53:49 <arianvp> CPP is a nightmare; as it's dependent on undocumented specifics of gcc that vary per gcc release
01:54:45 <arianvp> speaking of bad features of haskell ;P
01:55:53 <merijn> CPP is standardised, so that's not true. Of course GHC doesn't/can't used the standard CPP and has to use the traditional mode which mimics legacy compilers, but that seems unlikely to "change across compiler releases", because that'd defeat the point of having a legacy mode
01:56:21 <merijn> Anyway, there's cpphs for a reliable haskell CPP supported by GHC too
01:57:12 <arianvp> ah yeh cpphs could work
02:09:12 <smatting> Hi, can you recommend resources on how to build a tiny FRP system yourself? For my project I'd like to build a FRP-like abstractions, which need to generate a function (State -> Event -> State) as implementation. All events contains a timestamp, and there are some guaranteed events in like "A new month has started".  I'd like to express things like "delay this behaviour by 2 months". I can't use any
02:09:15 <smatting> exisiting Haskell libraries, because my project is written in Python.
02:10:32 <[exa]> as a first guess, in absence of laziness actual _F_RP may be extremely complicated
02:11:04 <[exa]> but there are various small FRP-supporting libs that you can read for inspiration
02:12:35 <[exa]> smatting: I guess 'wires' or 'netwire' could be first choice for reading but others might have better suggestions
02:12:47 <jackdk> I recall an event/behaviour FRP called "sodium" for java.
02:13:01 <jackdk> the Manning FRP book uses it for all its examples
02:15:42 <koz_> Varying is small and cute: http://hackage.haskell.org/package/varying
02:16:31 <smatting> thank you all
02:17:53 <koz_> Someone needs to make an FRP library named 'kawaii'.
02:30:51 <dmj`> Are there any GHC proposals to split up TH into pure and impure versions?
02:32:49 <dmj`> this would solve cross compilation headaches
02:48:24 <Uniaika> dmj`: you could suggest it :P
02:48:47 <dmj`> Uniaika: someone else has had to have suggested such a thing
03:12:48 <hoppfull> I have a question regarding row types. Intuitively I thought of them as maps but their "keys" don't seem to have to be unique. Then why require that there are keys at all? Is there some particular idea behind this that I am missing? Some deeper truth about row types that require this property?
03:15:38 <jcarpenter2> well if you wanted a row type of 2D floating-point vectors you have to have a way to tell which component is which - without keys it would form a 2D vector 2 different ways and you wouldn't be able to tell which one is the correct one
03:18:10 <hoppfull> jcarpenter2: ok, but I could give the 2D vector three values for examples, two for x and one for y
03:18:25 <jcarpenter2> two for x? what do u mean
03:18:25 <hoppfull> this is what confused me
03:18:57 <hoppfull> I could say that y = 5 and x = 6 and x = 3
03:19:02 * hackage ngx-export-tools-extra 0.3.1.0 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.3.1.0 (lyokha)
03:19:05 <jcarpenter2> oh that's weird
03:19:09 <hoppfull> yeah
03:19:56 <hoppfull> And it's the same in both Haskell in PureScript. At first I thought it might have been a bug or something but twice in two languages? Seems more than a coincidence.
03:20:28 <jcarpenter2> i'm a little doubtful that's useful, since if that's the case you're importing the whole jungle of unordered pairs into your type system
03:20:55 <jcarpenter2> x = (3, 6) or (6, 3) in your example
03:21:06 <jcarpenter2> you can define the type of unordered pairs pretty easily if you want them
03:21:08 <jcarpenter2> so idk
03:21:22 <hoppfull> Yeah
03:22:19 <hoppfull> It's not a huge problem but row types together with the indexed monad becomes very nice because instead of stating that a side effect occurred immediately before, you can say that it has happened sometime in the past.
03:48:36 <kolu> hey guys
03:49:49 <kolu> I have a script that takes a text as input and counts how much time each character occurs + the percentage
03:50:13 <kolu> https://imgur.com/lOVzTmM
03:50:18 <kolu> this is the output\
03:51:35 <kolu> my problem are floats - the x character has such a low frequency that I get an unreal number
03:52:42 <merijn> kolu: That doesn't look like a float problem
03:56:34 <kolu> https://imgur.com/LXUQMZi
03:56:37 <kolu> sry
03:57:03 <kolu> this is how it looks like before I make it pretty
03:57:36 <kolu> x is the problematic character
03:59:03 <merijn> kolu: eh, that number looks correct
03:59:14 <merijn> I don't know how your formatted it, but the problem is your formatting
03:59:27 <merijn> kolu: i.e., you dropped the e-2
04:00:24 <merijn> > 9.71e-2 == 0.0971
04:00:30 <lambdabot>  True
04:01:25 <kolu> I make the number to a string with show and then take 3
04:01:32 <merijn> kolu: Yeah...that's wrong
04:01:34 <kolu> how can I format that
04:01:38 <merijn> as shown here ;)
04:01:47 <kolu> aaah
04:01:48 <merijn> @hoogle showFFloat
04:01:49 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
04:01:49 <lambdabot> Rebase.Prelude showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
04:01:49 <lambdabot> Numeric showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS
04:02:14 <merijn> > showFFloat (Just 2) 9.71e-2 ""
04:02:16 <lambdabot>  "0.10"
04:02:24 <merijn> oh, wait is that the base?
04:02:42 <merijn> Ah, no, it's rounding properly xD
04:02:48 <merijn> > showFFloat (Just 3) 9.71e-2 ""
04:02:51 <lambdabot>  "0.097"
04:03:06 <kolu> showFFloat (Just 3) 9.783287e-2 ''
04:03:17 <kolu> > showFFloat (Just 3) 9.783287e-2 ""
04:03:21 <lambdabot>  "0.098"
04:03:39 <kolu> perfect
04:03:47 <merijn> kolu: You can use "%" as the final argument to immediately get that appended
04:04:01 <kolu> > showFFloat (Just 3) 9.783287e-2 "%"
04:04:04 <lambdabot>  "0.098%"
04:04:18 <kolu> thank you very much, sir
04:04:25 <merijn> kolu: The result is "String -> String" to get more efficient appends when combining a lot of strings
04:05:09 <kolu> do I need to import something for the showFFloat
04:05:41 <merijn> "import Numeric"
04:07:17 <kolu> great
04:07:22 <kolu> thank you again
04:08:50 <merijn> kolu: Numeric has a ton of stuff for displaying numbers (like printing them in different bases, etc.)
04:29:19 <jakov> Hello everyone ! I would like to parse a huge binary file - 50 GB - of Measurement data; in a streaming fashin. I thought about using Conduit but could not quite figure out how to do it. The data is build out of blocks, where each block has a header and a payload, and a field in the header says how long the payload is. I already have working "Data.Binary.Get" Parser for these blocks. Then, I just have to make a Historam from the
04:29:19 <jakov> Payload. The code i have is not streamed but loads the payloads all into memory. I would like to chuck the conduit to blocksize. Now my PROBLEM is that i don't understand how to control the chuncking of the conduit, if the information of the chuncksize is in the header each time. TL;DR: How to control the chucksize of Conduit, if it's dependent on what a parser, which sits in the conduit pipe , gives me ?
04:35:16 <merijn> jakov: Why, precisely do you wanna chunk the conduit to blocksize?
04:36:21 <sm[m]> arianvp I think you should suggest that (option to suppress version & hash) in hpack’s issue tracker
04:37:20 <merijn> jakov: Because I don't think it's actually relevant or necessary to your problem...
04:37:23 <jakov> merijn, You are right. It's not necessary for Histogramming. Another task for me is to perform a fast fourier transform of each block, so i thought it would be practical is I could write a Conduit sink which takes a block and performs the FFT.
04:37:47 <arianvp> sm[m]: seems there is already one https://github.com/sol/hpack/issues/380
04:39:07 <merijn> jakov: Sounds like you want something like "chunksOfE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()"
04:39:29 <merijn> jakov: Data.Conduit.Combinators and/or the conduit-extra package probably have what you need
04:43:57 <gobby> I'm having trouble using activated sockets. I try to get activated sockets via: https://hackage.haskell.org/package/systemd-2.2.0/docs/System-Systemd-Daemon.html
04:45:36 <solonarv> you might even be able to write a parser using a parser combinator library and turn that into a conduit more or less directly
04:45:43 <solonarv> I think attoparsec might support this
04:45:48 <merijn> solonarv: He already he had that
04:46:04 <merijn> solonarv: Conduit supports binary
04:46:15 <solonarv> ah, cool, don't mind me then ;)
04:47:45 <gobby> I always get Nothing from `getActivatedSockets`. This is my code: https://pastebin.com/ZtbHB1xS
04:48:02 <sm[m]> arianvp: great
04:48:15 <jakov> merijn: Thank you for your hint ! I'll try to use "conduitParse" with an Attoparsec, hoping that the 
04:48:26 <jakov> chuncking is already implemented correctly :)
04:48:56 <merijn> jakov: There's a binary library for conduit too
04:49:22 <merijn> https://hackage.haskell.org/package/binary-conduit-1.3.1/docs/Data-Conduit-Serialization-Binary.html
04:49:49 <merijn> jakov: The idea behind conduit is that you don't have to do chunking up front
04:50:26 <merijn> jakov: You just read blobs in chunks that are good for the disk, then feed them to the parser 1 by 1 until it completes, yield the result downstream, then start a new parse with the leftovers
04:58:03 <jakov> merijn: Do you mean "Data.Conduit.Binary" ? Won't it be a problem, if, for example by using a selfwritten Conduit that runs a strict version of the Get () Parser, the parser will fail from time to time, because will run out of bytes ?
04:58:49 <merijn> jakov: No, the one I linked above
04:59:07 <merijn> From the binary-conduit package
04:59:27 <jakov> Sorry, i overlooked the link.
05:09:32 <jakov> merijn, Thank you very much for your help ! This one looks really good. For me as a beginner it takes some time to get a good "thinking - flow", -- so f.e. in order to find the package, what did you google/hoogle for ? I found that hoogling "Get b -> ConduitT Bytestring" is not enough to get a result.   Did you hoogle for the exact type signature ?  
05:11:49 <merijn> No, I just knew that almost all major parser libraries (which includes binary) have conduit adapters, because that's one of the major uses of conduit, so I just google "conduit binary" to recall the name and saw "binary-conduit" in the results :p
05:11:51 <solonarv> one simple technique if you are looking for something that bridges two packages (in this case, conduit and binary) is to search for those two packages' names
05:12:53 <merijn> jakov: Hoogle indexes only a subset of hackage, unfortunately
05:13:49 <jakov> Hm .. That's a little sad. 
05:14:24 <jakov> Again, thank you very much !
05:23:48 <zincy_> Has anyone here managed to abstract AuthResult of of handlers when using the servant-auth-server?
05:24:29 <zincy_> At the moment I am just manually throwing a 401 in every handler for the pattern matching cases on AuthResult representing failure
06:13:07 <siraben> Anyone know of relevant books/papers to read after Algebra of Programming? I'd like to know how relational program derivation has developed since the book's publication.
06:24:02 * hackage yesod-core 1.6.18 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.18 (MichaelSnoyman)
06:38:34 <lg188> Hello. I'm trying to do a little bit of math with haskell. I'm trying to calculate how fast a robot would fly in factorio, given a research level and initial speed. 
06:39:38 <lg188> Maybe I should just post what I have
06:39:53 <hyperisco> why not Lua
06:40:07 <lg188> because I'm trying to learn haskell
06:41:25 <sMuNiX> lg188: pls, go ahead with what you have ...
06:52:07 <lg188> sMuNiX: Yeah just a second. 
06:54:32 * hackage HsOpenSSL 0.11.4.18 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.4.18 (VladimirShabanov)
06:54:43 <lg188> https://paste.centos.org/view/2df57ffd 
06:54:50 <lg188> this is what I have so far
06:55:39 <lg188> oops, some edits got messed up. function name is just speed
06:55:54 <Cale> okay
06:56:37 <lg188> I think I need something like fold to stack up the bonuses 
06:56:59 <lg188> up to a certain point
06:57:11 <lg188> and then multiply it by the base speed 
06:57:11 <Cale> I'm not sure that I understand
06:57:41 <Cale> So the bonus is supposed to be multiplicative and not additive as suggested by this code?
06:58:22 <lg188> that was the part I got confused on
06:58:36 <lg188> So I put something in that was close enough
06:59:03 <Cale> Is this a Factorio question more than a Haskell question?
06:59:35 <sMuNiX> lg188: line 6 wouldn't compile ...
06:59:45 <lg188> More of how to translate a math problem to haskell
07:00:03 <lg188> sMuNiX: because of the `!!` ?
07:00:25 <sMuNiX> lg188: level > 0 = baseSpeed + bonuses!!level
07:01:17 <lg188> ah, yes
07:02:00 <Cale> You probably want to multiply like  baseSpeed * (1 + totalBonus)
07:02:29 <lg188> cale, yes that is what I had in mind. 
07:02:43 <Cale> also, you probably want to make the list of bonuses infinite by appending  repeat 0.65  to it
07:02:44 <lg188> What i couldn't wrap my head around was the totalBonus 
07:03:07 <Cale> because (looking at the factorio wiki) all subsequent bonus levels contribute an additional 65%
07:03:12 <lg188> and infinite lists? I didn't know it could do that
07:03:29 <Cale> Then you can do something like  sum (take level bonuses)
07:03:41 <lg188> I planned on just repeating the last one somehow
07:03:42 <Cale> (oh, and drop the 0 from the start if you do that)
07:04:11 <Cale> > [0.35,0.40..0.65] ++ repeat 0.65
07:04:14 <lambdabot>  [0.35,0.4,0.45000000000000007,0.5000000000000001,0.5500000000000002,0.600000...
07:04:22 <Cale> hah, good ol floating point
07:05:03 <Cale> > [0.35,0.40,0.45,0.55] ++ repeat 0.65
07:05:06 <lambdabot>  [0.35,0.4,0.45,0.55,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0...
07:05:10 <Cale> there
07:05:23 <Cale> > sum (take 6 ([0.35,0.40,0.45,0.55] ++ repeat 0.65))
07:05:27 <lambdabot>  3.05
07:07:08 <lg188> Cale: ah yes, that seembs to be right
07:08:33 <sMuNiX> but, you don't get to use the level input anymore
07:08:49 <lg188> at what indentation should guards be because it seems to cause an error
07:10:56 <sMuNiX> lg188: can you update this, https://paste.centos.org/view/2df57ffd ?
07:12:32 * hackage lifted-async 0.10.0.6 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.10.0.6 (MitsutoshiAoe)
07:12:32 <lg188> https://paste.centos.org/view/c1ec01a6 
07:20:00 <dmwit> You might also consider adding a `| level > 3 = baseSpeed * (2.75 + 0.65*level)` or so to avoid rounding issues at high levels.
07:20:20 <dmwit> (2.75 = 1 + sum [0.35, 0.4, 0.45, 0.55])
07:20:43 <dmwit> er
07:20:49 <comerijn> Just use Rational ;)
07:20:58 <dmwit> > 1 + sum [0.35, 0.4, 0.45, 0.55] - 0.65*4
07:21:01 <lambdabot>  0.1499999999999999
07:21:10 <dmwit> Use 0.15 instead of 2.75. =P
07:21:26 <comerijn> > 1 + sum [0.35, 0.4, 0.45, 0.55] - 0.65*4 :: Rational
07:21:29 <lambdabot>  3 % 20
07:21:31 <comerijn> bam
07:21:46 <merijn> Rational <3
07:25:44 <stilgart> > 0.666666666667 :: Rational
07:25:46 <lambdabot>  666666666667 % 1000000000000
07:26:07 <merijn> stilgart: Rational can exactly represent any finite decimal literal
07:26:50 <stilgart> so it is Integers (and not Ints)
07:26:56 <merijn> (Which is why the floating point class uses fromRational for converting literals to their actual value)
07:27:16 <merijn> As that guarantees lossless conversion (where possible)
07:28:19 <frdg> how can we find the cardinality of `data MyData = Hello String Int` . To me it should be infinite.
07:28:33 <merijn> stilgart: Rational = "Ratio Integer"
07:29:00 <merijn> frdg: Yeah
07:29:18 <merijn> stilgart: Honestly, Rational is underrated and underused in Haskell :)
07:30:44 <frdg> is it problematic to have something like this? In my book the author says that the cardinality roughly equates to how difficult it is to reason about your function. 
07:31:26 <lg188> hlint is saying that my function signature is not parsible. but doesn't specify what
07:31:44 <merijn> lg188: What's the signature?
07:31:57 <lg188> `speed :: Integer -> Float -> Float`
07:32:32 <dmwit> What's the exact error?
07:32:47 <dmwit> Maybe it's time to put up a paste with the exact code and hlint output.
07:32:48 <lg188> dmwit:  just gives a parsing error
07:33:03 <dmwit> Could be an indentation thing, possibly.
07:33:16 <lg188> https://paste.centos.org/view/c1ec01a6  was the last code I wrote
07:34:10 <merijn> lg188: You can't have let there
07:34:34 <lg188> and this hlint https://paste.centos.org/view/b9d89bf3 
07:34:35 <merijn> Assuming that's the whole file
07:34:54 <lg188> merijn:  yeah it is the whole file
07:36:11 <lg188> okay removing the let worked
07:37:28 <jumper149> frdg: your `Hello` constructor constructs a product type `String` and `Int` so with cardinality `#` it should hold: '#myData == #String * #Int'
07:37:31 <merijn> lg188: You can only have bindings (well, and imports) at the top level, not arbitrary expressions
07:37:37 <solonarv> frdg: well, sometimes it might be problematic, but also sometimes it cannot be avoided
07:37:58 <lg188> merijn: ah, yeah. that makes sense
07:38:03 <justsomeguy> frdg: I'm a newbie, and would find that description confusing. I find Integer easy to reason about, and it has an infinite number of inhabitants.
07:38:05 <solonarv> if you want to have an arbitrary unrestricted string in your data type then it will have infinite cardinality, no way around that
07:38:46 <solonarv> yes, beyond a certain size it does not get any harder to reason about because the "hardness" is already maximal ;)
07:38:46 <frdg> solonarv: I figured this was the case.
07:40:08 <Cale> justsomeguy: I kind of find it misleading as well, but at the same time, it's kind of not wrong... there are a lot of reasonable questions about Integer which we don't know the answers to after centuries of trying, and moreover, there are reasonable-seeming questions which don't even have answers.
07:40:14 <justsomeguy> frdg: But... ok, I guess a function that acts on Integer would be harder to reason about than one that acts on a smaller type, since you can't tell which of the numbers in Integer would be the result. So I take it back.
07:40:43 <solonarv> but actually we can cheat a bit
07:41:03 <lg188> okay, seems to compile so far. testing it a little
07:41:16 <solonarv> formally, the cardinality of something like 'Integer -> Integer' or even 'Integer -> Bool' is uncountable
07:41:53 <merijn> solonarv: What? Why would "Integer -> Bool" be uncountable?
07:42:11 <lg188> And it seems to be correct
07:42:12 <lg188> nice
07:42:13 <Cale> merijn: It's the same as binary expansions of real numbers
07:42:16 <lg188> Thank you all
07:42:17 <solonarv> its cardinality is 2^aleph_0
07:42:46 <solonarv> a diagonal argument works to prove that it's uncountable, but you can also reason as Cale did
07:43:21 <dmwit> merijn: Pretty standard diagonalization argument. Pick an enumeration `f :: Integer -> (Integer -> Bool)` you claim covers everything, I'll pick `g n = not (f n n)` as my counterexample.
07:44:46 <solonarv> but! we know that if we actually have such a function, then it is written down somewhere and takes a finite amount of space, so there are only countable many such functions that you can actually encounter
07:46:33 <justsomeguy> frdg: I wonder if saying "how difficult it is to predict the term-level output of your function" would be clearer?
07:46:50 <dmwit> solonarv: Now if we can just get an enumeration of those... ^_^
07:47:08 <dmwit> (Spoilers: halting problem kills you if you actually want the enumeration to be useful.)
07:47:10 <frdg> justsomeguy: That does seem to make more sense
07:47:54 <frdg> justsomeguy: that definitely makes more sense actually thank you
07:48:34 <justsomeguy> frdg: Glad I could help. I really enjoy nitpicking things like that, honestly.
08:03:20 <jumper149> solonarv: #(a -> a) == #(a , a) == #a * #a   
08:03:52 <jumper149> So if #a is countable then #(a -> a) is also countable
08:10:46 <mniip> jumper149, is # cardinality here?
08:10:52 <jumper149> mniip: yes
08:10:52 <ChaiTRex> jumper149: The number of Integer -> Bool functions isn't countable even though (Integer, Bool) is, since it has at least the cardinality of the reals.
08:10:59 <mniip> how'd you come to #(a -> a) = #(a, a)
08:11:08 <mniip> ChaiTRex, depends on your topos
08:11:32 <topos> i am mniip's, for isntance
08:11:44 <jumper149> a function (a -> b) is isomoprhic to the cartesic product a * b
08:11:51 <mniip> shh bby
08:11:57 <mniip> jumper149, no?
08:12:12 <mniip> a function can be seen as a certain subset of the cartesian product A x B
08:12:24 <jumper149> oups I mean: the set of functions (a -> b) and the direct product (A x B)
08:12:26 <mniip> meaning there are possibly at most 2^(A x B) functions
08:13:04 <mniip> ChaiTRex, there's a constructible isomorphism N = 2^(2^N) in the effective topos
08:13:06 <mniip> it's pretty rad
08:14:06 <jumper149> mniip: Oh yeah I got it all mixed up, you're right! Good thing I now noticed though :)
08:14:15 <mniip> anyway
08:14:38 <mniip> for finite sets, the number of functions A -> B is actually the cardinality of B *to the power of* cardinality of A
08:15:41 <mniip> anyway this is all in Set
08:16:21 <mniip> if we talk about *computable* functions only, the picture is completely different
08:16:32 <mniip> I suspect that's what merijn has been referring to
08:17:38 * ski . o O ( "Constructive gem: double exponentials" by Andrej Bauer in 2009-10-12 at <http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/> )
08:18:12 <mniip> yup pretty much
08:27:49 <jumper149> mniip: Ahhm if #(a -> b) == #b^(#a) and #a and #b are countable then #(a -> b) should be countable too right? Still in Set ofcourse.
08:27:54 <mniip> no
08:28:02 <mniip> countable^countable is uncountable
08:29:59 <jumper149> mniip: That is unexpected^^ ty though
08:30:43 <mniip> jumper149, this is what the diagonal argument is all about
08:30:48 <mniip> 2^N is not countable
08:31:19 <mniip> actually the more general argument is that 2^X has a strictly larger cardinality than X
08:33:22 <mniip> an even more general argument goes that in a cartesian closed category if there is a morphism A -> B^A that is surjective on points, then every morphism B -> B has a fixed point
08:34:11 <mniip> what this means for Set is that  A -> B^A can only be surjective if B is a singleton set
08:35:57 <mniip> (|A| >= |B^A| iff |B| = 1)
08:42:33 <hwatatiming> https://github.com/klappvisor/haskell-telegram-api/blob/master/src/Web/Telegram/API/Bot/Requests.hs
08:42:47 <hwatatiming> I'd like to know what this ChatId is?
08:42:52 <hwatatiming> and Token type
08:42:56 <srhb> Is there a nicer/more ergonomic way these days to create heap profiles than runi
08:43:12 <hwatatiming> chatId :: ChatId
08:43:17 <hwatatiming> chatId = 12345
08:43:18 <srhb> running multiple -hr -hc -hwhatever seesions and doing the hp2ps dance? :)
08:43:45 <hwatatiming> how I can turn "123" :: Text to 123 :: ChatId?
08:44:13 <hwatatiming> data ChatId = ChatId Int64 | ChatChannel Text
08:44:35 <mniip> hwatatiming, first turn the string into an Int64?
08:44:42 <mniip> then use the ChatId constructor
08:45:04 <hwatatiming> oh, it's Int64
08:45:20 <hwatatiming> I see, this ChatId is a value constructor
08:45:32 <mniip> ChatId :: Int64 -> ChatId
08:45:36 <srhb> Specifically, while looking for a leak, I feel like I have to do multiple runs to get all the information on: What's the closure (some name), from which module did it happen (some dependency module), why is it being retained (some function name) -- and it feels like a chore not getting all the information at once.
08:45:38 <mniip> there's a type constructor and a data cosntructor
08:46:57 <hwatatiming> then how turn this Text -> Int64?
08:48:40 <polyphem> hwatatiming: you can turn Text to ChatId with the ChatChannel dataconstructor 
08:50:49 <mniip> polyphem, are you sure that is the same thing?
08:51:32 <hwatatiming> no, I need ChatId (x:: Int64) :: ChatId
08:52:01 <hwatatiming> but ChatChannel (x:: Int64) :: ChatId is the same question
08:52:18 <hwatatiming> I need turn x :: Text to x :: Int64
08:52:44 <hwatatiming> oh, my mistake
08:52:50 <hwatatiming> ChatChannel Text
08:53:07 <hwatatiming> but I only need ChatId (x :: Int64)
08:53:47 <sm[m]> srhb: is https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html any better ?
08:55:08 <srhb> sm[m]: Well, that looks quite sexy. No idea how good it is for heap profiling, but it certainly warrants a try. Thanks!
08:56:04 <polyphem> if you *absolutly* need the ChatId Data-Constructor wich takes only Int64 , and you only have Text you need to do some hash of your Text "hashfunc :: Text -> Int64"
08:56:06 <sm[m]> srhb: mpickering has a recent youtube video about it too
08:56:34 <sm[m]> I often get confused about time vs heap vs stack profiling, and can't tell at a glance what this is showing
08:56:52 <sm[m]> time, eh
08:57:00 <hwatatiming> there is not a lib function to do that?
08:57:06 <polyphem> if you only need ChatId datatype you can use ChatChannel Text dataconstructor to give you ChatId
08:57:25 <srhb> sm[m]: I'm afraid that's the case, but it looks useful to learn about regardless. :)
08:57:42 <hwatatiming> but I only need ChatId Int64...
08:59:36 <hwatatiming> b = (read "3") :: Int64
08:59:40 <hwatatiming> this is ok?
09:00:44 <polyphem> if your Text only includes numbers , sure , its however partial function and may blow up in your face ...
09:03:07 <mpickering> srhb: No but you should use eventlog2html rather than hp2ps :) 
09:03:13 * hackage retrie 0.1.0.1 - A powerful, easy-to-use codemodding tool for Haskell.  https://hackage.haskell.org/package/retrie-0.1.0.1 (AndrewFarmer)
09:05:34 <srhb> mpickering: Giving it a shot right now. :-)
09:19:13 * hackage enum-text 0.5.2.0 - A text rendering and parsing toolkit for enumerated types  https://hackage.haskell.org/package/enum-text-0.5.2.0 (ChrisDornan)
09:28:03 <polyphem> hwatatiming: here is an example hashfunction Text -> Int64 ; https://gist.github.com/polyrod/2c12eb86bc5979cdf38f080a567044c1
09:30:21 <mniip> polyphem, what even
09:30:58 <polyphem> mniip: what what even ?
09:31:14 <mniip> how does this have anything to do with the original problem
09:32:29 <polyphem> turning text to Int64 to construct ChatId type with ChatId Int64 constructor and not using read as it is partial function ?
09:36:22 <polyphem> hwatatiming was asking if there was a library function  Text -> Int64 , haven't found one 
09:37:08 <dmj`> polyphem: Data.Hashable
09:37:26 <dmj`> polyphem: it generalizes over other types not just Text
09:38:26 <mniip> but
09:38:31 <mniip> how is any of this about hashing
09:38:43 <mniip> the OP asked about converting a textual representation of a number into a number
09:39:43 * hackage fused-effects-readline 0.0.0.0 - A readline-like effect and carrier for fused-effects  https://hackage.haskell.org/package/fused-effects-readline-0.0.0.0 (patrick_thomson)
09:40:37 <polyphem> mniip: thats why i said yes , he could use "read" to convert but its a partial function from Text -> Int64
09:40:47 <mniip> so?
09:41:13 <mniip> your proposed alternative is not better because it doesn't do what it's supposed to do
09:43:12 <polyphem> i dont know where the Text comes from and if its *absolutly* only numerical ... and hence it may blow up in his face ... unless using a total function to convert any Text to Int64
09:45:06 <polyphem> ... so Text -> Int64 , choose one
10:04:43 * hackage vulkan 3.0.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-3.0.0.0 (jophish)
10:08:16 <polyphem> mniip: what is your ChatId ?
10:17:01 <mniip> polyphem, I suspect the ChatId is a token that you use to refer to a channel in the API
10:17:08 <mniip> i.e. it is a pretty specific number
10:17:32 <mniip> and if you're developing a bot of some sorts you need the ability to use a ChatId from the configuration
10:17:39 <mniip> hence the ability to parse Text into it
10:20:03 <polyphem> mniip: yes i agree it has a scent of user supplied data ... and as I read the datatype definition hwatatiming gave it could be also a ChannelName in the config file 
10:20:21 <mniip> but that is not what they asked for
10:22:05 <polyphem> yea , read is fine , so is head
11:06:08 <ph88> Does anyone know since which ghc version since import became unnecessary ?  https://github.com/spell-music/data-fix/blob/master/src/Data/Fix.hs#L58 
11:07:51 <jlamothe> ph88: I didn't even know that was a thing.
11:08:27 <jlamothe> Do you just use the fully qualified name?
11:11:38 <ph88> me use ?
11:13:26 <monochrom> I think I don't understand the question.
11:15:34 <MarcelineVQ> at what point did Applicative become available in Prelude, maybe
11:17:49 <ph88> i tested it with a GHC from 4 years ago and it's the same ... so a long time at least
11:18:20 <ph88> what's the right way to deal with a warning of an empty list missing in a pattern match when it's guaranteed that the list will never be empty ?
11:18:25 <MarcelineVQ> the oldest version of that file is from 2012 if it matters
11:18:43 <dsal> ph88: NonEmptyList ?
11:19:31 <dsal> :t NonEmpty
11:19:33 <lambdabot> [a] -> NonEmptyList a
11:19:52 <ph88> i'm afraid that will change the API of the module
11:20:19 <MarcelineVQ> if it's a public api you can't gurantee that someone won't give it an empty list, so you might want to have a different api anyway
11:21:14 <ph88> i think it's a type that is first generated by the library, given back the user and then the user should call another function from the library
11:21:39 <maerwald> ph88: you ignore the warning
11:21:43 <maerwald> Next question
11:21:55 <ph88> can it be surpressed with a pragma ?
11:21:59 <maerwald> Why would you?
11:22:11 <maerwald> I would say it's still good to have that warning
11:22:16 <MarcelineVQ> that being said you can use a catch all case   foo _ = error "foo was called with an empty list"  but it's not a great idea usually, ignoring the warning like maerwald suggests is the better option than a catch-all really because not you wno't forget that you have that case
11:22:22 <maerwald> So you don't forget that this is a "tough" spot in your API
11:22:31 <MarcelineVQ> *now you won't forget
11:22:53 <ph88> everyone else using the library will also get this warning
11:23:00 <maerwald> Yes, and they should know
11:23:16 <MarcelineVQ> even better :> If you don't want that then improve the api
11:23:19 <maerwald> Similar with orphan instances. Don't hide the warnings. Let users know
11:23:42 <ph88> i don't think a library should be giving warnings, i'm trying to do something about this warning
11:23:48 <maerwald> I disagree
11:24:21 <maerwald> Keep the warning or make your api total
11:24:49 <maerwald> Otherwise use -Wno-<some-warning>
11:26:18 <maerwald> And then be surprised you broke something in another place in your module
11:26:29 <ph88> it's not my module
11:26:47 <maerwald> Ok, then you can't change it
11:26:56 <ph88> i can send a pull request
11:27:19 <maerwald> Disabling a warning for incomlete pattern match for an entire module is dangerous
11:27:26 <ph88> i understood
11:27:53 <maerwald> Yes, so you have all your options: 1. total API, 2. keep the warning, 3. disable warning on module level 4. use foo _ = error "blah"
11:30:28 <ph88> thank you
11:30:30 <MarcelineVQ> and that option 1 can mean your api to this library is the total one, you don't have to modify their library
11:32:03 <maerwald> I think this is about "I saw a warning in my build log"-OCD =)
11:33:09 <MarcelineVQ> then never compile a c/c++ oss project :X
11:34:41 <sm[m]> I agree with ph88, good packages don't give warnings when you build them
11:35:31 <MarcelineVQ> I bet everyone does, but that the meaning of good packages then changes per person
11:36:17 <dsal> This is why I add -Wnone to all of my modules.  I want them to be good.
11:36:48 <maerwald> sm[m]: http://www.gergely.risko.hu/debian-dsa1571.en.html
11:37:00 <maerwald> if you are considering to fix compiler warnings in a library, think twice :D
11:37:01 <monochrom> I consider the default set of warnings to be well-balanced, and -Wall to be too anal and hypocritic.
11:38:09 <maerwald> -Wall is for development. Put it in cabal.project.local
11:39:28 <monochrom> Also you always need to make a few case-by-case exceptions and judgment.
11:40:03 <sm[m]> if you build any complex haskell packages with warnings visible, the output is truly horrendous. Makes haskell look bad
11:40:26 <sm[m]> stack users are probably more aware of this, I think cabal is less chatty by default
11:40:33 <maerwald> Huh?
11:41:21 <sm[m]> you'll see so many warnings you can hardly follow progress, and emacs can't print fast enough slowing down your builds :)
11:41:39 <monochrom> heh
11:41:56 <monochrom> the joke is always on emacs
11:42:42 <maerwald> Cabal prints all warnings too. What you mean is maybe parallel build. Ofc there's no reasonable way to interleave build logs.
11:43:13 <maerwald> Maybe stack does it, which is why it's confusing you and your editor.
11:43:22 <monochrom> In the case of parallel build, cabal puts separated log files somewhere, so there is that.
11:45:16 <maerwald> s/editor/OS/
11:46:21 <sm[m]> maerwald: I'm talking about warnings from dependencies, cabal doesn't show those (here at least), stack does
11:48:06 <maerwald> sm[m]: ofc it does
11:48:17 <maerwald> As explained above. use --j1
11:48:39 <sm> we're talking past each other, never mind
11:48:46 <maerwald> Nope :)
11:57:18 <ohhaihai> newtype UnionFind s = UnionFind {  unUnionFind :: (STRef s (Maybe (UnionFind s))) }
11:57:18 <ohhaihai>  
11:57:18 <ohhaihai> ancestor :: UnionFind s -> ST s (UnionFind s)
11:57:18 <ohhaihai> ancestor x = (readSTRef . unUnionFind $ x) >>= maybe (pure x) ancestor
11:57:21 <ohhaihai>  
11:57:41 <ohhaihai> Hello, is there a lensy way to do this.
11:57:45 <ohhaihai> *?
12:00:22 <ohhaihai> And now I realize it is wrong too.
12:01:04 <ohhaihai> No it isn't nvm. XD
12:03:37 <zbz5068> Hi I am new to haskell here. Does anyone knows how to fix this "cabal: unrecognised command: v2-build (try --help)"?
12:04:06 <maerwald> zbz5068: cabal --version
12:04:28 <zbz5068> cabal-install version 1.24.0.2compiled using version 1.24.2.0 of the Cabal library 
12:04:35 <maerwald> Too old, update
12:05:17 <maerwald> https://downloads.haskell.org/~cabal/cabal-install-3.0.0.0/ pre-built binaries here
12:05:35 <zbz5068> tried to use cabal install cabal-install, but still get the same version :\
12:05:57 <maerwald> then check your PATH settings
12:06:29 <maerwald> I assume this is mac?
12:06:38 <zbz5068> ubuntu
12:07:30 <maerwald> https://help.ubuntu.com/community/EnvironmentVariables#Persistent_environment_variables
12:08:58 <maerwald> https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html has documentation about what PATH is
12:09:29 <maerwald> 'which' might also be useful
12:10:34 <monochrom> Sorry but hahahaha because the only reason I got hardcore enough to read the POSIX standard document is only because various man pages of shells simply say "go read that for the real grammar".
12:10:47 <maerwald> :P
12:11:18 <monochrom> (And I kind of really need to know because I don't want to lie to my students when I tell them shell operator precedence.)
12:11:31 <maerwald> I use it all the time when writing... erm... posix shell
12:11:49 <monochrom> Yeah
12:12:01 <maerwald> Not that it's a good idea. I suggest everyone use bash.
12:12:20 <monochrom> Hell I re-read Haskell 2010 all the time whenever a technicality about irrefutable patterns comes up.
12:13:18 <MarcelineVQ> zbz5068: the idea here being that one should pay attention to where  cabal install cabal-install  places the new binary it makes, and to have that path at the start of your PATH
12:13:22 <monochrom> "Hi #haskell I have this pattern !(~(!(~(... why doesn't it do what I mean?!"
12:14:49 <maerwald> I like languages that do what you probably meant, not what you wrote :)
12:15:22 <ohhaihai> Is there a lensy way to do STRef pointer chasing.
12:15:25 <ohhaihai> *?
12:15:38 <monochrom> probably yes but why bother
12:18:34 <ohhaihai> Because it's fun
12:19:35 <monochrom> Alright then you'll have to keep waiting.
12:25:40 <MarcelineVQ> Does anyone have an sqlite example/use in haskell with a nontrivial adt? trivial in the db row sense. so far everything I've found, sqlite-simple, groundhog, selda, have examples for things like  data Person = Person Age (Maybe Pet)  but not for things like data Person = Person Age (Maybe​ Pet) [Foods]
12:27:03 <syd> MarcelineVQ: you will need multiple database tables
12:27:05 <MarcelineVQ> er an example of like, going from a value of Person to putting it into a db, including (if neccesary) making the rerquired tables for it
12:29:56 <MarcelineVQ> I do realize/think that I'll need a table for Person, a table for Foods and a table relating the two, but am entirely unsure how to do the actual linking of them in haskell. it almost feels like I will need another ADT (or multiple ADTS) just for the sql-friendly form that I have to convert to the complex adt
12:30:17 <jumper149> Is there an easy way to (newtype?)-derive specific methods of instances and give others by hand?
12:30:34 <syd> MarcelineVQ that's exactly right. There's no magic to do that for you.
12:30:38 <syd> And arguably there shouldn't be
12:31:04 <syd> jumper149: I don't think so. Unless the library that provides the class has some default implementations.
12:31:27 <MarcelineVQ> syd: alright well that gives me a lead to work with thank you
12:31:42 <zeta_0> i'm almost done with learn you a haskell, after i'm done with that book, what book do you guys recommend that go through next? i'd prefer a haskell book that has a lot of real world examples with a lot of problems to work through?
12:35:12 <koala_man> zeta_0: have you had a look at Real World Haskell?
12:36:20 <maerwald> I can never understand how ppl can digest sth like Real World Haskell. I mean, it's great source of knowledge, but I wouldn't be able to memorize 25% of it if I wasn't forced to write something
12:36:22 <solonarv> jumper149: you can do something like that using coerce and a heap of TypeApplications
12:37:03 <zeta_0> koala_man: i've heard about it, do you know when it's expected to be completed? also, i don't know if it's worth paying for a book when i can download other books for free
12:37:19 <koala_man> zeta_0: it's been done for a long time and it's freely available online
12:37:43 * hackage launchdarkly-server-sdk 1.0.3 - Server-side SDK for integrating with LaunchDarkly  https://hackage.haskell.org/package/launchdarkly-server-sdk-1.0.3 (launchdarkly)
12:37:48 <maerwald> zeta_0: I think you're confusing it with the haskell book
12:37:54 <maerwald> real world haskell is free
12:38:16 <solonarv> example: newtype Blah f a = Blah (f a); instance Foldable f => Foldable (Blah f) where foldMap :: forall m a. Monoid m => (a -> m) -> Blah f a -> m; foldMap = coerce (foldMap @f @m a)
12:38:27 <jumper149> solonarv: Don't know either coerce nor TypeApplications but i'll look into it quickly. I only need it for one instance^^
12:38:28 <solonarv> (of course this is a silly example)
12:38:50 <solonarv> most likely you are better off just writing the equivalent of: foldMap f (Blah xs) = foldMap f xs
12:38:52 <Nolrai> What could cause: "Linking .stack-work/dist/x86_64-linux/Cabal-3.0.1.0/build/neat/neat ...gcc: error: .stack-work/dist/x86_64-linux/Cabal-3.0.1.0/build/neat/neat-tmp/Main.o: No such file or directory`gcc' failed in phase `Linker'. (Exit code: 1)" like I didn't even think ghc used gcc anymore..
12:39:01 <solonarv> i.e. doing the little bit of "unwrapping" manually
12:39:13 <zeta_0> i got it confused with haskell from 1st principles, my mistake, also there's a remake of the rwh that i found here: https://github.com/tssm/up-to-date-real-world-haskell
12:39:20 <maerwald> Nolrai: you need gcc
12:39:34 <maerwald> stack installs ghc without checking its requirements?
12:39:58 <zeta_0> koala_man maerwald , so i guess i'll give that a try after i finish with lyah
12:39:58 <Nolrai> Main.o is whats missing, not gcc. I am pretty sure.
12:40:03 <solonarv> coerce is annoying to use because it often tries to be more general than what you want; in the example above I have to write the type signature with the 'forall' and add the type applications for m and a because otherwise GHC does not know that I want them to be the sam
12:40:29 <solonarv> and it would just get stuck with an "ambiguous type" error
12:40:43 <maerwald> Nolrai: it's difficult to parse the log, maybe pastebin it
12:40:45 <zeta_0> does rwh have a lot of questions that i can practice?
12:42:32 <zeta_0> in the up to date real world haskell, they've only finished up to chapter 17, they haven't finished chapters 18-31 yet, hopefully they finish soon
12:43:11 <Nolrai> my weird linker error: https://pastebin.com/RN68tRvm
12:43:17 <maerwald> zeta_0: you learn type is reader? :>
12:43:42 <Nolrai> 'type is reader'?
12:44:32 <zeta_0> maerwald: do i mean have i learned that? i'm not sure what you mean?
12:44:44 <maerwald> zeta_0: if you primarily learn by reading
12:44:57 <jumper149> solonarv: Can you explain what the @ are doing in your example with foldMap?
12:44:58 <MarcelineVQ> oh is that what you meant hehe
12:45:34 <jumper149> solonarv: Ah I see it's the TypeApplications extension^^
12:46:43 <zeta_0> maerwald: yes, i'm a book worm
12:55:42 <salumu> Nolrai: [1 of 1] Compiling Main
12:55:44 <salumu> [1 of 1] Compiling Main
12:55:58 <sm[m]> @where htac, zeta_0 
12:55:58 <lambdabot> I know nothing about htac,.
12:56:04 <salumu> this line shows up twice in your output
12:56:22 <sm[m]> @where htac you fool
12:56:22 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:56:22 <salumu> Nolrai: how many Main.hs do you have around ?
12:57:52 <zeta_0> sm[m]: thanks, is htac a good continuation after finishing lyah ?'
12:57:53 <MarcelineVQ> where in the cabal docs is cabal.project.local described?
12:58:11 <Nolrai> salumu: One in app and one in benchmark.
12:58:11 <sm[m]> I don't remember what's in lyah, but yes
12:59:35 <jumper149> Can I pattern match on ||| ? https://hackage.haskell.org/package/xmonad-0.15/docs/XMonad-Layout.html#v:-124--124--124-
12:59:37 <salumu> Nolrai: does this alone works, stack build ?
12:59:37 <MarcelineVQ> ah seems to be under configure
13:00:48 <zeta_0> sm[m]: thanks for the link, i'll check it out
13:01:16 <zeta_0> it's nice that there's a lot of haskell learning resources these days
13:01:18 <Nolrai> @salumu: no, okay there was an earliar issue that only happened with "stack bench" and not "stack build", gah I hate when I get two bugs conflated.
13:01:19 <lambdabot> Unknown command, try @list
13:02:51 <Nolrai> Which is now happening as well.
13:04:24 <Nolrai> stack build results: https://pastebin.com/9V9NQ2H8
13:07:10 <sm[m]> Nolrai: that's odd.. might you have multiple stack/cabal/ghcid/ghcs running ? stack clean --full doesn't help ?
13:09:50 <Nolrai> Could this be HIE's fault somehow?
13:13:06 <MarcelineVQ> what's your package.yaml look like?
13:13:40 <Nolrai> Well now stack bench is working if I do a stack purge first, but if I touch a source file and then run "stack bench" again it fails to find ".stack-work/dist/x86_64-linux/Cabal-3.0.1.0/build/neat/neat-tmp" !?
13:13:52 <MarcelineVQ> 'cause that's reminiscent of an error I've seen where more than one packaga.yaml stanza uses the same src dir and because hpack expands modules automatically it gets confused
13:15:47 <Nolrai> I don't seem to have a package.yaml?
13:16:10 <MarcelineVQ> alright that's just fine then, what does your .cabal file look like?
13:16:56 <hexagoxel> If you ctrl-c stack builds it is pretty easy to run into linker errors afterwards too, on certain projects.
13:17:45 <hexagoxel> ah, but this seems more consistently reproducable, never mind.
13:17:59 <Nolrai> my .cabal file: https://pastebin.com/biY6A9Xx 
13:18:21 <Nolrai> hexagoxel: might be related though.
13:18:36 <maerwald> hexagoxel: yeah, most file operations are not atomic whatsoever, mainly because directory package etc. make no effort for it
13:18:43 <maerwald> Cabal has similar problems
13:20:04 <MarcelineVQ> hmm, no source-dir problems there at a glance
13:20:40 <MarcelineVQ> Nolrai: lemme know when you get this going if you plan on a public release, I have a fondness for NEAT
13:21:22 <MarcelineVQ> ah there's a git already
13:21:38 <zeta_0> what is the name of the <=< haskell symbol? it doesn't show up when i search it on the internet
13:22:16 <MarcelineVQ> zeta_0: fishtail sometimes but just calling it <=< is good too
13:22:19 <{abby}> i think people call it "a fish" but it's the Kleisli composition operator
13:23:06 <MarcelineVQ> fish sounds more right to me so​ I'm probably misremembering
13:23:57 <zeta_0> MarcelineVQ {abby} thanks, i've heard fish before, but that doesn't describe it's meaning
13:24:35 <hexagoxel> eh, what does -fhide-source-paths do exactly? *opens userguide*
13:24:57 <hvr> hexagoxel: hide the path to the .hs files
13:25:02 <maerwald> would be weird if fish described its meaning 
13:25:38 <hexagoxel> ah, I see.
13:25:49 <{abby}> hexagoxel: GHC prints the path to every module's source path in --make mode without that flag
13:26:21 <MarcelineVQ> weird the modern convetion would be more like   -fno-print-source-path  rather than hide
13:27:11 <Nolrai> Sorry got distracted by xkcd.
13:27:17 <sm[m]> Nolrai: another thing to check: building with and without —profile changes the paths
13:30:48 <Nolrai> One thing that is weird is when I run stack bench it rebuilds the library and executable, even if I have immediately previously run stack build.
13:33:13 * hackage Cabal 3.0.2.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-3.0.2.0 (HerbertValerioRiedel)
13:38:54 <Nolrai> @maerwald: I'll try to let you know when its at 0.1
13:38:54 <lambdabot> Unknown command, try @list
13:39:02 <Nolrai> Doh!
13:39:27 <maerwald> Cool. What is 0.1?
13:39:27 <MarcelineVQ> :>
13:43:16 <Nolrai> When I have at least one feature to pre-alpha. So to speak.
13:46:13 * hackage Cabal 3.0.1.0 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-3.0.1.0 (HerbertValerioRiedel)
13:55:19 <zeta_0> does anyone here know what happened to geekosaur? he was helping me with some xmonad a while back, but then fell off the map, i haven't seen him on #haskell for weeks
13:56:14 <zeta_0> maybe, he's quarantined from the corona virus, i have no idea?
13:56:33 <MarcelineVQ> he's had away periods before but hopefully is doing fie
13:56:34 <MarcelineVQ> fine
13:59:57 <zeta_0> MarcelineVQ: ya, hopefully he's doing fine, he seems like a nice dude, and has helped me a lot, especially with xmonad
14:00:39 <monochrom> Looks like in the past 10 days geekosaur only showed up every once in 2-5 days.
14:03:21 <zeta_0> monochrom: last time i talked to geekosaur, he was all freaked out about this corona virus, so he's probably hunkered down right now
14:04:14 <koz_> Poor geeky dino.
14:12:35 <maerwald> meh, handling threads in rust is so annoying I want async back
14:28:43 * hackage cabal-install 3.2.0.0 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-3.2.0.0 (HerbertValerioRiedel)
14:43:13 * hackage th-expand-syns 0.4.6.0 - Expands type synonyms in Template Haskell ASTs  https://hackage.haskell.org/package/th-expand-syns-0.4.6.0 (DanielSchuessler)
14:58:46 <fendor> new cabal-install release :D 
15:11:21 <koz_> fendor: \o/
15:11:40 <fendor> \o/
15:11:53 <koz_> Doesn't build with 8.10 lol.
15:12:56 <fendor> meh, I am still on 8.6.5 anyways
15:13:10 <fendor> it is nice, stable and cozy
15:13:21 <koz_> Yeah, well, I'm waiting on upstream stuff to update so I can update my libraries.
15:14:22 <monochrom> Does it build with 8.8?
15:14:28 <koz_> monochrom: So far so good.
15:14:50 <fendor> I've heard 8.8 is broken on windows
15:14:52 <monochrom> nice, because ghcup's "recommended" is now bumped to 8.8
15:14:54 <glguy> Yes, it builds with 8.8.3
15:15:04 <glguy> (I didn't try with anything less than that)
15:16:22 <maerwald> there are no binaries yet though
15:16:35 <glguy> fendor: the windows issue I'd heard about was for <8.8.3
15:17:36 <fendor> glguy, yeah, but doesnt 8.8.3 segfault as well?
15:18:16 <glguy> fendor: not for me. You'll have to be more specific with what issue you mean
15:18:43 <fendor> I cant, I *think* I remember reading about some issue
15:20:19 <fendor> But cant find it.
15:20:31 <fendor> maybe it was for an old version
15:20:33 <d34df00d> Meh, hspec's `parallel` doesn't enable parallel execution of quickcheck tests.
15:20:51 <koz_> d34df00d: Did you compile with -threaded?
15:21:01 <d34df00d> koz_: yes. My individual tests run in parallel.
15:21:12 <d34df00d> koz_: but quickcheck apparently runs everything sequentially.
15:21:25 <koz_> d34df00d: Ah, that's definitely true.
15:21:30 <koz_> As far as I'm aware anyways.
15:21:47 <d34df00d> There's http://hackage.haskell.org/package/pqc-0.8/docs/Test-QuickCheck-Parallel.html but I have no freaking clue how to combine it with hspec.
15:22:27 <koz_> d34df00d: Maybe open an issue on hspec?
15:22:30 <koz_> It'd be good to have.
15:22:41 <d34df00d> True.
15:22:51 <koz_> I'd certainly like this for my Official Work Haskell.
15:23:04 <d34df00d> I'll `git stash` a few hours worth of work parallelizing my whatever-is-being-tested for now tho.
15:23:21 <d34df00d> 100 test cases run in 40 seconds sequentially, meh.
15:23:27 <d34df00d> Many cores wasted.
15:23:41 <koz_> d34df00d: Yeah, that kind of waste makes me sadface.
15:24:42 <koz_> d34df00d: Link me the issue when you make it? I'd like these capabilities also.
15:24:53 <d34df00d> Sure, in a few.
15:24:56 <koz_> No rush. :D
15:25:13 <dsal> d34df00d: Did you try tasty?  It improved my life considerably.  :)
15:25:25 <koz_> dsal: I would, but HSpec is work-mandated.
15:25:43 <dsal> Hmm...  It'll still run the hspec tests.
15:25:47 <d34df00d> dsal: I haven't really, but does it run quickcheck prop tests in parallel?
15:26:00 <d34df00d> It'll make me switch for sure at this point.
15:26:07 <dsal> Yeah, it runs hspec, quickcheck, etc...
15:26:11 <dsal> It's really quite nice.
15:26:20 <d34df00d> But does it do so _in parallel_?
15:26:40 <d34df00d> I mean, if I have a single QC prop test, will it test that prop on a single thread or more?
15:27:16 <d34df00d> hspec, for instance, does run any given single QC test sequentially, even with the `parallel` combinator.
15:27:45 <dsal> Yes, by default.
15:27:58 <d34df00d> Wow.
15:28:09 <d34df00d> I'll give it a shot like right now then.
15:28:23 <d34df00d> And I know whom to ping if I don't manage to get it working :)
15:28:32 <dsal> Yeah, I've spent some time with it/done some patching.
15:29:07 <d34df00d> The amount of yak shaving I'm doing on this project is insane tho.
15:29:12 <koz_> d34df00d: Which project?
15:29:14 <koz_> inline-asm?
15:29:33 <d34df00d> Nah, another one. I've suspended the asm fun for now.
15:29:46 <d34df00d> What I'm doing is playing with types and trying to write a toy language that compiles to Idris.
15:29:53 <koz_> d34df00d: Woah, lol.
15:30:01 <d34df00d> (so my prop is basically that a type that's generated according to some rules is accepted by Idris)
15:30:08 <d34df00d> (and that's why it takes so long to check lol)
15:30:27 <dsal> d34df00d: for  complicated example:  https://github.com/dustin/aoc2019/tree/master/test
15:31:03 <d34df00d> I'll hopefully get some good results soon that would be worth sharing.
15:31:48 <dsal> d34df00d: or maybe this one, which actually uses quickcheck: https://github.com/dustin/mqtt-hs/blob/master/test/Spec.hs
15:32:08 <d34df00d> But the furthest I had to go in my shaving is... well, I upgraded ghc to 8.8.3, and hie didn't work with ghc 8.8.3, so I looked at what would it take to fix that
15:32:35 <d34df00d> and then I noticed that one of the libs that hie relies on is written by a guy who I was working with on a previous company
15:32:48 <d34df00d> which made me recall that I need to set up a linkedin account now that I'm unemployed
15:33:08 <d34df00d> so in half an hour I found myself taking a C++ quiz from linkedin.
15:33:28 <d34df00d> (sadly they didn't have haskell quizzes)
15:33:42 <d34df00d> dsal: oh, cool! That's definitely gonna be helpful, thanks for the examples!
15:34:05 <koz_> d34df00d: I think 8.8.3 is still not a done thing. I noticed this myself about a week ago.
15:34:47 <d34df00d> Dunno, lts ≥15.3 IIRC is 8.8.3, and adding support for 8.8.3 to hie boiled down to copying over a stack config from 8.8.2 and adjusting a couple of versions.
15:34:49 <d34df00d> Works like a charm.
15:36:29 <koz_> d34df00d: Well, I can only report what I saw when I ran the hie install script.
15:36:56 <d34df00d> Yeah, I noticed that what they currently have in repo only support 8.8.2.
15:37:23 <d34df00d> But turns out that install.hs just scours the nearby stack-*.yaml, so I did roughly `cp stack-8.8.2.yaml stack-8.8.3.yaml`
15:37:27 <d34df00d> And it worked.
15:37:53 <koz_> Good to know.
15:38:35 <koz_> :t mapMaybe
15:38:37 <lambdabot> (a -> Maybe b) -> [a] -> [b]
15:38:44 <sm[m]> fendor you're thinking of https://gitlab.haskell.org/ghc/ghc/issues/17926 maybe
15:38:44 <koz_> sikk.
15:41:44 <fendor> sm[m], yeah, exactly, thank you!
15:45:05 <koz_> Is there anyplace with an Arbitrary instance for HashMap?
15:45:40 <d34df00d> koz_: as you requested, https://github.com/hspec/hspec/issues/433
15:47:34 <koz_> d34df00d: Thanks!
15:48:39 <koz_> (and to answer my own question, quickcheck-instances got mah back)
15:48:43 * hackage preql 0.2 - safe PostgreSQL queries using Quasiquoters  https://hackage.haskell.org/package/preql-0.2 (bergey)
15:51:19 <koz_> :t concatMap
15:51:21 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:52:18 * jumper149 is happy af, because hour long tinkering finally worked and it's awesome :)
15:54:15 <d34df00d> dsal: does tasty have autodiscovery of test files?
15:54:36 <d34df00d> Akin to https://hspec.github.io/hspec-discover.html
15:55:20 <lyxia> tasty-discover
15:55:47 <d34df00d> https://hackage.haskell.org/package/tasty-auto ah cool.
15:55:50 <d34df00d> Or that, lol.
15:55:55 <d34df00d> lyxia: thanks!
15:56:57 <d34df00d> Yay, I can even still have my hspec tests!
15:57:01 <d34df00d> The level of interoperability is awesome!
16:01:04 <d34df00d> Alright, now to the interesting questions.
16:01:35 <d34df00d> So I have a resource that's shared both by hspec specifications and quickcheck properties. How do I do that with tasty?
16:02:46 <d34df00d> With hspec I had spec = beforeAll startFoo $ afterAll stopFoo $ do ..., and my specifications were of the form `it "does something" $ \resource -> communicateWithResource resource `shouldBe` something`
16:16:00 <dsal> I don't have any tests in that form, but it might fit into the test tree model.
16:22:04 <d34df00d> I figured there's withResource, but its third argument is of the form IO a -> TestTree
16:22:10 <d34df00d> Do I like really have to do unsafePerformIO here?
16:23:04 <d34df00d> Moreover, https://hackage.haskell.org/package/tasty-hspec-1.1.5.1/docs/Test-Tasty-Hspec.html 's testSpec/testSpecs live in IO also, so I'm not sure how to combine all of that together.
16:54:59 <d34df00d> Crap, my quickcheck property returns an IO Bool.
16:55:06 <d34df00d> Dunno how to test that with tasty.
16:55:50 <d34df00d> The library is indeed great, but maybe my use case is funky, so I have too much unsafePerformIO which occasionally bites me cause I have STM's `atomically` inside...
17:01:52 <Cale> d34df00d: Have you seen the stuff in Test.QuickCheck.Monadic?
17:02:19 <Cale> It shouldn't be necessary to unsafePerformIO...
17:02:57 <d34df00d> Cale: that appears on the intersection of quickcheck and tasty.
17:03:30 <d34df00d> Cale: note that the third arg here ( https://hackage.haskell.org/package/tasty-1.2.3/docs/Test-Tasty.html#v:withResource ) is IO a -> TestTree
17:03:41 <d34df00d> While IO a -> IO TestTree would be more reasonable perhaps.
17:04:19 <d34df00d> ...while testSpec here ( https://hackage.haskell.org/package/tasty-hspec-1.1.5.1/docs/Test-Tasty-Hspec.html ) lives in IO.
17:05:22 <Cale> Does tasty really give you all that much that plain IO and QuickCheck don't?
17:06:14 <d34df00d> Well, I sort of started from hspec (because I had lots of specs), and then I figured hspec + quickcheck = no parallelism per qc prop and been advised to use tasty + quickcheck.
17:08:01 <monochrom> No, this is what I think instead.
17:09:57 <monochrom> TestTree stores a bunch of tests. Hell, call them programs.  TestTree stores a bunch of programs.  (Someone else will have to run those programs, but...)  Neither the storer nor a function for building this store need run those programs.  Only store.  withResource is one of them.  IO a -> TestTree is exactly right, putting your IO program in a pure data structure requires no IO.
17:10:26 <monochrom> What you really need is a runner that goes TestTree -> IO Something such as defaultMainWithIngredients.
17:10:49 <d34df00d> But I already don't understand.
17:11:10 <d34df00d> So let's say I need to convert an hspec tree to a tasty tree.
17:11:19 <d34df00d> The function that does so lives in IO and returns IO TestTree.
17:11:30 <d34df00d> But I need the resource that's allocated in withResource in my hspec test tree.
17:11:32 <d34df00d> How do I do that?
17:12:24 <d34df00d> And I also would like to keep autodiscovery, so I don't really have a main that I control (but I can probably do without autodiscovery)
17:20:48 <koz_> Is there a proper name for the argument given to fmap, filter etc that defines their behaviour? Best I can come up with is 'function argument' but that's too long and non-specific.
17:21:25 <monochrom> for filter it's safe to say "predicate" because it is.
17:21:44 <monochrom> for fmap I tell the story of "use f to convert answers" so maybe converter.
17:22:13 <koz_> SO I guess for general names, 'function argument' is as good as I'm getting?
17:24:42 <monochrom> I guess yes. I'm not a fan of being this wordy.
17:25:11 <koz_> Neither am I, which is why I'm asking.
17:25:49 <monochrom> So don't use words?  Use examples?
17:26:46 <monochrom> I have great success using "map behaves like this: map f [a,b,c] = [f a, f b, f c]" on my students.
17:26:50 <koz_> monochrom: This is not for teaching - it's for datatype naming. :P
17:26:56 <koz_> Perhaps I should have been more clear.
17:41:46 <koz_> Is there something I can read about how GHC represents sum types?
17:42:50 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated  scroll down for the link to the pdf slides.
17:42:56 <koz_> monochrom: Thanks!
17:43:10 <monochrom> it's big because it covers everything. sum types is somewhere inside.
17:47:37 <MarcelineVQ> there's also the ghc commentary itself https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects
17:55:34 <jackdk> If I were to relax a constraint on a function in a package from `Monad m` to `Applicative f`, is that a major or minor bump?
17:55:48 <jackdk> (in terms of applying PVP to the next release of the package)
17:56:45 <jackdk> My reading of PVP is that this this falls under point (1), which means "major version bump", but it's also a "backwards compatible change"
17:59:42 <monochrom> I feel that it's a minor bump because you provide a richer API.
18:00:16 <monochrom> You're giving users more tools, not taking away any existing tool.
18:04:34 <hwatatiming> how to split a string with "\r" or "\r\n" or "\n" ?
18:04:37 <hwatatiming> a Text
18:05:04 <hwatatiming> I know we can use splitOn three times to do that
18:05:10 <hwatatiming> is there a better way?
18:05:53 <hwatatiming> "a\r\b\r\nc\nd" to ["a","b","c"]
18:06:11 <hwatatiming> ["a","b","c","d"]
18:09:15 <sm[m]> The lines function, I think
18:09:53 <hwatatiming> but lines can handle \n\n?
18:10:03 <hwatatiming> "a\n\nb"
18:10:38 <hwatatiming> lines can't handle "\r\n"
18:10:38 <sm[m]> it certainly can, but maybe not in the way you mean
18:10:42 <hwatatiming> only "\n"
18:10:48 <sm[m]> ack
18:10:53 <jackdk> > lines "a\n\nb"
18:10:56 <lambdabot>  ["a","","b"]
18:11:04 <hwatatiming> > lines "a\r\nb"
18:11:07 <lambdabot>  ["a\r","b"]
18:12:26 <sm[m]> One of those annoying little challenges in basic Haskell
18:12:59 <hwatatiming> a ugly why is splitOn three times
18:13:09 <hwatatiming> and it's really ugly
18:13:21 <MarcelineVQ> does strip remove trailing \r and such?
18:13:33 <sm[m]> but is it a real problem? Do you get text with those three endings mixed ?
18:14:08 <Cale> Yeah, I'd say that usually the solution is just to open whatever file with the right line ending mode set so that all the newlines become \n
18:14:17 <hwatatiming> yeah, a real problem, there's a config I need to read, but it may on windows, linux or osx
18:14:19 <Cale> But with email, sometimes that's not really a solution
18:14:56 <sm[m]> if I was already using reflexes, I’d probably use a regex replace to normalize to \n and then use lines
18:15:05 <sm[m]> Regexes
18:15:22 <hwatatiming> replace \r to \n then do lines
18:15:31 <hwatatiming> this seems better
18:15:45 <sm[m]> hwatatiming: ok that’s a simpler problem
18:15:51 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:universalNewlineMode
18:15:55 <Cale> ^^ use that
18:16:09 <sm[m]> Haskell will normalize those for you
18:16:15 <hwatatiming> I don't know why splitOn don't filter empty list
18:16:32 <Cale> Are you sure you're getting \r in the strings when you read the file?
18:16:36 <Cale> How are you reading it?
18:16:49 <hwatatiming> readFile
18:17:06 <Cale> The one in the Prelude?
18:17:14 <hwatatiming> Data.Text.IO.readFile
18:18:33 <Cale> Try using openFile explicitly, so that you can hSetNewlineMode hdl universalNewlineMode before using hGetContents
18:18:56 <Cale> (considering that this is the implementation of readFile https://hackage.haskell.org/package/text-1.2.4.0/docs/src/Data.Text.IO.html#readFile )
18:25:00 <monochrom> I have a feeling you should just filter through "Data.Text.filter ('\r' /=)" and then you only have \n to worry about.
18:25:39 <hwatatiming> but there may be "a\rb"
18:26:06 <monochrom> Seriously?
18:26:06 <hwatatiming> so replace "\r" to "\n" then splitOn "\n"
18:26:24 <monochrom> Who makes that?  Apple II?
18:26:41 <hwatatiming> what Apple makes now?
18:26:48 <hwatatiming> \r\n?
18:26:49 <monochrom> is macos and \n
18:26:58 <hwatatiming> aha,
18:27:13 * hackage archive-sig 1.0.0.0 - Backpack signature for archive libraries  https://hackage.haskell.org/package/archive-sig-1.0.0.0 (vmchale)
18:28:13 * hackage archive-libarchive 1.0.0.0 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-1.0.0.0 (vmchale)
18:30:13 * hackage hstar 0.1.0.0 - Haskell version of tar CLI utility  https://hackage.haskell.org/package/hstar-0.1.0.0 (vmchale)
18:33:13 * hackage archive-tar-bytestring 1.0.0.0 - Common interface using the tar-bytestring package  https://hackage.haskell.org/package/archive-tar-bytestring-1.0.0.0 (vmchale)
18:42:43 * hackage shake-bindist 1.0.1.0 - Rules for binary distributions  https://hackage.haskell.org/package/shake-bindist-1.0.1.0 (vmchale)
18:43:42 * hackage replace-attoparsec 1.2.2.0 - Find, replace, and edit text patterns with Attoparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-attoparsec-1.2.2.0 (JamesBrock)
18:44:43 * hackage replace-megaparsec 1.3.2.0 - Find, replace, and edit text patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.3.2.0 (JamesBrock)
18:58:51 <koz_> Does anyone know how Aeson automagics ToJSON instances for sum types via Generic?
18:59:08 <koz_> I tried looking at their source code and it dead-ends at some invisible type class method with no explanation in sight.
18:59:13 <koz_> And it doesn't appear to be documented anyplace.
19:20:10 <lyxia> koz_: the options give some information about it, in particular SumEncoding
19:20:20 <koz_> lyxia: Oh, cool. Will investigate.
19:23:52 <lyxia> don't hesitate to open an issue if anything's not clear!
19:24:00 <koz_> lyxia: Thanks, will do.
19:25:16 <koz_> :t toLower
19:25:18 <lambdabot> Char -> Char
19:25:32 <koz_> :t (toLower <$>)
19:25:34 <lambdabot> Functor f => f Char -> f Char
19:28:09 <koz_> lyxia: Am I correct in assuming that genericParseJSON opts will decode JSON encoded with genericToJSON opts?
19:29:32 <Axman6> in theory yes
19:29:48 <koz_> Axman6: Why not in practice?
19:30:46 <Axman6> I'm not sure there's a proof that they are inverses, but they should be. We rely on that a lot (and verify it with quickcheck tests) and it's never been wrong
19:31:14 * koz_ makes a note to test that to the ends of the earth.
19:32:52 <Axman6> You can make those tests really easily with this one cool trick! roundtrip :: (Eq a, Show a, ToJSON a, FromJSON a) => a -> Expectation; roundtrip a = fromJSON (toJSON a) `shouldBe` Success a; ... prop "JSON round-trippable" $ roundtrip @CategoryType ...
19:33:06 <koz_> Axman6: Or I could use quickcheck-classes. :P
19:33:14 <koz_> Which has automagical properties for this exact case.
19:34:03 <Axman6> ooo, nice
19:34:38 <koz_> lyxia: I've looked at Options, but I'm not clear how it encodes product types which are not records. If I have 'data Foo = Foo Int Text deriving stock (Generic) deriving anyclass (ToJSON)', what would that turn into?
19:34:52 <koz_> Axman6: I introduced it to our codebase, and found a few boo-boos.
19:39:34 <hwatatiming> why there isn't replace in Data.Text
19:40:02 <koz_> https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text.html#v:replace
19:40:22 <hwatatiming> my fault
19:40:29 <koz_> Happens to all of us.
19:53:53 <Nolrai> I have a work around for my weird stack errors, but I don't know what changed to make it nessary.
19:54:19 <Nolrai> If I change the name of my executable from "neat" to "Neat" then everything works.
19:54:39 <Nolrai> But thats obnoxious and weird.
19:54:52 <lyxia> koz_: I think it makes an array by default
19:56:06 <koz_> Ah, so that would take something like 'Foo 3 "bar"' into [3, "bar"]?
19:56:52 <Nolrai> Anyone have a clue why or how this would be nessary? It used to work with the executable name as "neat".
19:59:04 <Axman6> Nolrai: are you on a mac?
19:59:21 <Nolrai> I am on linux mint.
19:59:52 <lyxia> koz_: yeah
19:59:58 <Nolrai> Though..hmm. This folder was originally created on windows?
20:00:05 <koz_> lyxia: Good to know, thanks!
20:00:07 <Axman6> can you share the cabal file, both what's working and what isn't?
20:05:41 <Nolrai> Before the problem: https://pastebin.com/1tY7aLpM
20:10:10 <Nolrai> bugged: https://pastebin.com/QNAtTBGs
20:10:42 <Nolrai> But if i change the "neat" on line 53 to "Neat" it works.
20:13:23 <Axman6> what error do you get?
20:14:01 <Axman6> Also, seeing grenade in the list of imports make me curious what this is :)
20:14:13 * hackage stylist 1.2.0.0 - Apply CSS styles to a document tree.  https://hackage.haskell.org/package/stylist-1.2.0.0 (alcinnz)
20:19:43 * hackage dhall 1.31.1 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.31.1 (GabrielGonzalez)
20:21:21 <Nolrai> Trying to write a haskell implementation of http://www.cs.ucf.edu/~kstanley/neat.html.
20:21:54 <Nolrai> I don't actually have anything to use it for which is a bit of a problem..but I'll burn that can of worms when I get to it.
20:22:52 <cjay-> is there a generic way to make cabal-install find C libraries on NixOS?
20:23:14 <cjay-> it doesn't find zlib for example
20:23:23 <Nolrai> The most reproducible error I get, stack seems to be in a bad state once I get any of them: https://pastebin.com/SvfjA64j
20:24:11 <Axman6> have you tried a stack clean? (and possible a slightly painful stack clean --all?)
20:24:41 <Axman6> "Stack has not been tested with Cabal versions above 2.4, but version 3.0.1.0 was found, this may fail" seems like something you should pay attention to
20:24:50 <Axman6> maybe try an older LTS
20:25:17 <Nolrai> Hmm. Maybe.
20:25:52 <Axman6> I'd be interested to see how difficult representing NEAT in grenade is, since it inherently changes the shape over the network (if I understand it correctly), which might be quite difficult to represent in the type system
20:27:28 <Nolrai> I am probably only going to use grenade in a pretty light way for neat, just have one layer that is a whole neat phenotype.
20:28:18 <Nolrai> But hyperneat should really stress test grenade.
20:29:05 <Axman6> I've wanted to write a package for a long time which takes a grenade network and transforms it into an Accelerate version. I mostly want to do this so I can call the package RPG
20:29:30 <Nolrai> I mean that would be awesome. For both reasons.
20:35:43 * hackage xml-conduit-stylist 1.1.0.0 - Bridge between xml-conduit/html-conduit and stylist  https://hackage.haskell.org/package/xml-conduit-stylist-1.1.0.0 (alcinnz)
20:37:40 <MarcelineVQ> "<Nolrai> I don't actually have anything to use it for which is a bit of a problem..but I'll burn that can of worms when I get to it." sure you do, you can immediately use it to make CPPN's and move onto HyperNEAT
20:38:14 <Nolrai> But then I need a problem for HyperNEAT!
20:38:58 <Nolrai> But I guess if I really want to feel like an academic I should just keep going forever! :P
20:39:49 <Nolrai> I will also need to extend grenade to working with 4+ dimensions.
20:40:32 <monochrom> To really feel like an academic, write a grant proposal.
20:42:22 <MarcelineVQ> it's not quite a problem 'for' HyperNEAT but don't forget to develop ES-HyperNEAT during or after you develop HyperNEAT because it's the logical step to take
20:46:38 <zeta_0> any tips on learning trees in haskell? i'm working through this right now: https://arjunkrishnababu96.gitlab.io/post/2017-10-07-tree-implementation-in-haskell/
20:47:11 <MarcelineVQ> Nolrai: http://eplex.cs.ucf.edu/publications might interest you if you've not seen it
20:50:50 <Axman6> zeta_0: what do you want to learn?
20:51:12 <Axman6> "Trees" is a pretty broad topic
20:51:41 <Axman6> it's kind of liking asking "How do I learn about vehicles". there's quite a lot of those :)
20:53:04 <Nolrai> I mean they did specify in haskell, so 
20:53:13 <whataday> function hsnet_getadd rinfo: warning: Using 'getaddrinfo' in statically linked applications requires at runt ime the shared libraries from the glibc version used for linking
20:53:29 <Nolrai> its closer to "I want to learn about vehicles made in euroupe".
20:53:31 <whataday> when I do ghc with -optl-static
20:53:47 <whataday> is there another function can avoid this?
20:54:02 <whataday> replace getaddrinfo
20:54:40 <Axman6> Nolrai: sure, but that still encompasses mopeds, bicycles, gyrocopters, oil rigs and rollerblades to name a few
20:55:56 <zeta_0> Axman6: ok, i'm back, anyways, i'm not sure, i'm learning trees for the 1st time
20:56:31 <zeta_0> Axman6: i'm working through the link i pasted earlier, it's helping me get some intuition about binary trees
20:56:42 <zeta_0> how are binary trees useful?
20:57:14 <jackdk> I typed your last question verbatim into a search engine and got several promising results.
20:57:55 <zeta_0> in haskell
20:58:27 <jackdk> data structures are generally pretty useful in many languages
20:58:33 <Axman6> well, by themselves they're not particularly useful, but if you have a bit more structure to them, then they can become useful. Binary search trees maintain the invariant that at each node, all the values to the left are smaller than the current node's value, and all values to the irght are greater. This lets you find things very efficiently like looking up a number in a phone book, you start in the middle, and split either the left or right 
20:58:33 <Axman6> chunk of pages depending on what names you find
20:58:34 <Nolrai> I mean I am not sure the "in haskell" changes things that much.
20:58:39 <zeta_0> they look interesting, i'm just trying to find something practical to do with them
20:59:12 <Axman6> the container libraries Data.Map is an example of a binary search tree (possibly with some sneakiness to speed things up)
20:59:33 <Nolrai> Are they red-black trees?
20:59:52 <Nolrai> No its someother similar thing.
21:00:19 <Axman6> I think Data.Map uses "trees of bounded balance) or something, which has slightly more lax rules but achieves similar performance - the docs will tell you more
21:00:39 <zeta_0> haskell's tree syntax still confuses me a bit, but i'll keep trying to understand it
21:00:59 <Nolrai> I mean haskell doesn't have dedicated tree syntax.
21:01:04 <Axman6> Haskell doesn't have tree syntax
21:01:06 <dsal> I do parallel processing on maps by splitting them into chunks of ~50k each.  You can do that significantly better than O(n)  :)
21:01:30 <dsal> The split functionality is a bit weird in that it gives you two ~halves and like, some leftovers.
21:02:00 <Nolrai> Oh, yeah, I looked into that for like 5 seconds.
21:02:24 <zeta_0> i heard that, it's easier to implement trees in haskell than in other languages, so that's good
21:03:25 <dsal> It's easier to do many things in haskell than in other languages, depending on the things and other language.  :)
21:03:33 <Nolrai> "One obstacle to reproducing the phenomenon of majortransitions in biological systems is the sheer amount of timerequired. The Cambrian explosion, for instance, occurredover 3 billion years after the development of the first cell onEarth (Marshall, 2006)." Somehow this feels like understatement.
21:04:27 <MarcelineVQ> Nolrai: That's an argument for open ended evolution, if you close off routes too early you may never arrive at a destination
21:04:52 <MarcelineVQ> Open ended in the sense of not having a very specific fitness function, or one at all
21:05:07 <Nolrai> Hmm.
21:06:40 <MarcelineVQ> Other metrics, like behavioral uniqueness, can prove pretty interesting and lead to an orgnaism that can handle complex situations
21:07:17 <MarcelineVQ> http://eplex.cs.ucf.edu/papers/brant_gecco17.pdf
21:07:57 <MarcelineVQ> and ^ is yet another approach
21:17:51 <Nolrai> I am tentively going for reproducing this I think: http://eplex.cs.ucf.edu/papers/pugh_ecal17.pdf
21:18:04 <Nolrai> Though I probably don't have enough computing power avalible.
21:19:56 <MarcelineVQ> That's also an interesting angle, if computing power is a limited resource then including it's scarcity in your model could be useds to drive evolution to simpler networks
21:29:14 <MarcelineVQ> Including your own computer's resources in your world model could be pretty useful. Since the world you operate in and its resources are an important driver for evolution. e.g. the great extinction event cause by organisms in the world producing too much oxygen and it was killing everything, which drove oxygen consuming things to come about, things like you :>
22:07:06 <whataday> 有没有图形化的diff工具，查看文件的改变
22:07:17 <zeta_0> what is the difference between a node and an object?
22:08:17 <whataday> is there a GUI version of diff?
22:08:49 <dmwit> Nodes are part of the definition of a graph. Objects are part of the definition of a category.
22:09:46 <dmwit> Nodes are typically members of a set. Objects are... often part of a collection that isn't easily described using set theory.
22:10:01 <MarcelineVQ> zeta_0: best to show/link where you saw those terms so that the people you're asking have the same context you do
22:10:31 <dmwit> whataday: I like gvimdiff.
22:10:44 <zeta_0> node(tree data structures), object(category theory)
22:10:47 <dmwit> whataday: If you already know vim, it is very comfortable.
22:10:53 <zeta_0> MarcelineVQ: ^
22:11:23 <zeta_0> i was just curious about the distinction between the 2
22:12:03 <zeta_0> 2 pretty abstract terms
22:13:26 <dmwit> What is the difference between 1 and true?
22:14:13 <dmwit> I dunno. Maybe that's unfair.
22:14:21 <zeta_0> dmwit: they are values of different types
22:15:09 <zeta_0> sorry, i ask dumb questions when i get tired
22:17:15 <dmwit> Nodes and objects are components of different structures.
22:17:44 <dmwit> I'm not sure that helps you much, for... basically the same reason I don't think "they are values of different types" helps much.
22:17:51 <dmwit> Like, why should I care that they are values of different types?
22:18:06 <dmwit> Maybe those types are actually the same in some deep underlying way that makes 1 and true the same in a similar deep underlying way.
22:19:23 <zeta_0> dmwit: ok, that makes sense, thinking in abstractly is confusing sometimes, but i'm starting to get used to it
22:19:47 <dmwit> (For example, there's a ring isomorphism between (Z/2,0,1,+,*) and (Bool,False,True,xor,(&&)) that connects 1 and True.)
22:20:45 <zeta_0> dmwit: ya, i agree with you
22:20:53 <dmwit> By focusing on 1 and True and excluding from view all of the other operations and observations and structure they're connected to, you get this tunnel vision that makes it impossible to truly compare them.
22:21:42 <dmwit> I have the same objection to nodes v. objects: they're each parts of very rich theories, and losing sight of for example edges v. arrows means you don't get to see the whole picture.
22:22:18 <dmwit> Anyway.
22:22:23 <zeta_0> dmwit: ya, category theory taught me how to look from both the local and global perspectives, it blew my mind
22:23:13 <dmwit> There's some similarities and a lot of differences.
22:23:41 <dmwit> For example two nodes in a tree are guaranteed to have exactly one path between them. Two objects in a category may have any number of connections.
22:24:11 <zeta_0> dmwit: ya, i was really trying to see the relationship and difference between nodes, edges and objects arrows
22:24:18 <dmwit> Nodes aren't guaranteed to have any edges. Objects are guaranteed to be connected to arrows.
22:24:43 * hackage th-utilities 0.2.4.0 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.2.4.0 (MichaelSloan)
22:25:05 <dmwit> Nodes often come with a notion of identity/equality that lets you check if two nodes are the same. Checking if two objects are the same is Evil.
22:25:07 <zeta_0> dmwit: oh, i see, they have different properties and rules
22:25:51 <dmwit> uh
22:25:54 <dmwit> yes =)
22:25:55 <zeta_0> dmwit: cool, thanks for clarifying these things, it confused me a little bit'
22:28:43 <dmwit> On the other hand... there's a pretty standard construction that constructs a category out of any graph. Given graph G, define category Gr(G) by: the objects of Gr(G) are the nodes of G; the arrows of Gr(G) are paths in G; the identity arrow is the empty path; arrow composition is path concatenation.
22:29:49 <dmwit> (Precision: the arrows of Gr(G) are triples of a path in G, the source node, and the target node. This deals with some quibbles about whether the identity arrow is "shared" and what this means for the well-formedness of the definition of arrow composition.)
22:35:56 <zeta_0> cool
22:36:41 <zeta_0> dmwit: i'm going to call it a day, thanks for the help
22:41:53 <MarcelineVQ> how did you know he was talking about categories?
22:49:17 <whataday> dmwit yeah, vim -d file1 file2 is very good
22:52:36 <whataday> do you like vim's recording?
22:54:03 <Nolrai> Why does this paper take a whole paragraph and a latex equation to describe computing a mean?
22:54:52 <Nolrai> In what seems to be a very ineficentway too!
23:13:21 <koz_> Nolrai: Link?
23:13:36 <Nolrai> http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf
23:14:06 <koz_> Oh, it's about neural nets.
23:14:14 <Nolrai> Bottom ~half or so of page 110 (the paper starts on page 100).
23:14:17 <koz_> In that case, I'm not even surprised - that entire topic is a giant waste of time.
23:14:33 <Nolrai> ?
23:14:44 <Nolrai> Uh, the entire topic of neuronets?
23:14:48 <koz_> I don't have a high opinion of neural net 'research'.
23:15:20 <Nolrai> I mean I am rather concerned that these papers are just not very good.
23:15:38 <Nolrai> Even if the raw ideas behind them are worth considering.
23:15:47 <Nolrai> If that makes sense?
23:16:01 <Nolrai> Though the algorithem it self seems to work okay.
23:16:06 <koz_> The raw ideas behind them also aren't something I care for.
23:16:16 <koz_> It boils down to 'with enough brute force, I can approximate any function'.
23:16:18 <koz_> Good for you?
23:16:32 <Nolrai> I mean sort of?
23:16:47 <koz_> What does this tell us? What does it actually inform us of that we didn't already know?
23:17:01 <koz_> These so-called 'models' can't even explain their own conclusions.
23:17:05 <koz_> That's not a model, that's guesswork.
23:17:15 <koz_> And no amount of fancy language or corporate backing will change this basic fact.
23:17:24 <Nolrai> Well its not like machine learning hasn't produced real results.
23:17:51 <Nolrai> Even if they aren't 'scientific models' in the philosophic sense.
23:18:06 <koz_> You can throw massive amounts of data into an ANN. It'll produce some kind of results given enough time and resources.
23:18:15 <koz_> These results have zero basis, zero meaning, carry zero explanations.
23:18:19 <koz_> What's the point?
23:18:32 <koz_> You're basically as good as making stuff up.
23:18:38 <Nolrai> Thats just not true.
23:18:45 <Nolrai> The ANN can then be used!
23:19:03 <koz_> And what do its answers truly mean? How do you know you approximated the right function? Or even _which_ function?
23:19:18 <koz_> Your answers are made up, and the fact you can answer questions with them doesn't make them any _less_ made up.
23:19:34 <koz_> But then again, you do you.
23:19:38 <MarcelineVQ> the paper isn't strictly about ann's though that is the thing the machinery being applied to. the paper is about NEAT which is a method of evolving genomes, we can express them any way we like, this happens to use ANN's
23:19:56 <koz_> MarcelineVQ: I guess the moment I see anything ANN-related, my eyes glaze over, lol.
23:19:57 <Nolrai> The same way you tell using any emperical method.
23:19:58 <MarcelineVQ> the major contribution of NEAT is showing that speciation is a good method of protecting innovation and keeping a genome around long enough to become interesting and showing that historical markings make crossover of genes both straightforward and immediately tractable
23:20:31 <MarcelineVQ> I guess that's redundant, straightforward and tracable how about :}>
23:20:33 <Nolrai> (As opposed to theoreticly backed modles.)
23:21:03 <Nolrai> That is it gives the right awnsers when you test it.
23:21:12 <int-e> MarcelineVQ: Is that supposed to make sense...
23:21:24 <koz_> int-e: I dunno, seems logical-sounding to me. :P
23:21:33 <MarcelineVQ> int-e: once you read the paper :>
23:21:37 <Nolrai> I think int-e means the last sentence.
23:21:55 <int-e> I meant "the major contributions"
23:22:09 <Nolrai> At least I cant quite parse "I guess that's redundant, straightforward and tracable how about :}>"
23:23:08 <Nolrai> And the emotiocon is either a sweet goatee or a witches hat?
23:23:25 <MarcelineVQ> a typo so whatever you prefer
23:23:36 <Nolrai> Hard choice that.
23:23:53 <int-e> The thing is, there are quite a few common words in there that (I assume) are actually jargon that I don't know.
23:25:44 <Nolrai> Speciation is really the only one thats not fairly standard.
23:26:04 <Nolrai> In context its more about nitch protection then reproductive barriers.
23:26:58 <Nolrai> But I am a lumper in terms of semantics. I tend to see things as very broad.
23:27:35 <Nolrai> Like I think describing Identity as an container is fine.
23:27:44 <Nolrai> Or even IO.
23:31:16 <MarcelineVQ> @quote /ls
23:31:16 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:31:47 <Nolrai> Yeah. 
23:32:02 <Nolrai> But you can put things in IO.
23:32:31 <Nolrai> Which to me makes the intuition useful.
23:37:50 <Nolrai> So If I want to quickly cluster a bunch of (in the linear algebra sense, they are actually IntMaps) vectors with dimensions in the 10s to 100s into bins what data types should I be useing?
23:38:03 <Nolrai> Hmm. Thats way to vague a question.
23:40:31 <Nolrai> A "Map" with the "Charictaristic Specimen" as the key, pointing to "Set"s of genomes?
23:40:37 <MarcelineVQ> I've not really done that stuff myself, or know what's required exacty, but I'd be looking at  linear  and  hmatrix  as a starting point regardless.
23:42:08 <Nolrai> Well this is more about genome handling then neuronet proscessing..but linear is useful.
23:43:21 <Nolrai> Eh, I'll just use `[(Genotype,[Genotype])]`.
23:44:40 <MarcelineVQ> that's the type of Map essentially https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map.html
23:45:57 <Nolrai> Well map is like [(Key,Value)], but, I see your point.
23:54:03 <hello> hello
23:54:57 <yushyin> hi
