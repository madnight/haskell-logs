01:03:53 * hackage yesod-core 1.6.17.3 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.17.3 (MichaelSnoyman)
01:04:54 * hackage rio 0.1.14.1 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.14.1 (MichaelSnoyman)
01:05:54 * hackage resourcet 1.2.3 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.2.3 (MichaelSnoyman)
01:07:24 * hackage monad-logger 0.3.32 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.32 (MichaelSnoyman)
01:08:24 * hackage unliftio-core 0.2.0.0 - The MonadUnliftIO typeclass for unlifting monads to IO  https://hackage.haskell.org/package/unliftio-core-0.2.0.0 (MichaelSnoyman)
01:09:54 * hackage unliftio 0.2.12.1 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.12.1 (MichaelSnoyman)
01:24:11 <fog> Here is a probabilistic approach the the optimal linear (kalman) filtering problem using switching between "regions"; https://arxiv.org/pdf/1609.00365.pdf 
01:24:45 <fog> Table 1: gives pseudocode that can be translated into haskell.
01:25:08 <fog> however, there are linear algebra, and probability theory terms
01:25:29 <fog> do we have the library support that could make the implementation simple like in Matlab?
01:50:24 * hackage language-docker 8.1.0 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-8.1.0 (lorenzo)
03:54:53 * hackage ghc-lib-parser 0.20200301 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20200301 (shayne_fletcher)
03:55:54 * hackage ghc-lib 0.20200301 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20200301 (shayne_fletcher)
04:55:23 * hackage yesod-fb 0.5.2 - Useful glue functions between the fb library and Yesod.  https://hackage.haskell.org/package/yesod-fb-0.5.2 (psibi)
04:59:21 <Phyx-> ysangkok: the short story is it depends. by default ctrl+c is interpreted by the console host and the Ctrl handler will be called. (i.e. what you register with SetConsoleCtrlHandler)
04:59:58 <Phyx-> however you can turn off this interpretation, especially if you want to see the value in your stream.
05:00:45 <Phyx-> when using a "cooked" console, the console host never interprets control characters, but you get to register any sequence you want.
05:01:15 <Phyx-> the new I/O manager registers both Ctrl+c and Ctrl+z
05:01:29 <Phyx-> the old (current mio) doesn't support cooked inputs on Windows
05:12:59 <aveltras> has anyone used https://hackage.haskell.org/package/forma for a fullstack app ? i'd like to use the type level field names list during form rendering (not only during validation) to ensure that form fields "name" attributes match what's expected during validation
05:16:54 * hackage taffybar 3.2.2 - A desktop bar similar to xmobar, but with more GUI  https://hackage.haskell.org/package/taffybar-3.2.2 (eyevanmalicesun)
05:19:13 <aveltras> just found how . Using showFieldName @ContactFields #name 
05:30:54 * hackage nonlinear-optimization 0.3.12.1 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.12.1 (FelipeLessa)
05:35:53 <jollygood2> what command line options parser do you prefer? 
05:37:37 <oo_miguel> I just got newest stack and get warning that it was untested with the current ghc/cabal versions in lts-15.1. I thought the whole point in using stack is that the combination _has_ been "tested"? Or am I misunderstanding something?
05:38:04 <jollygood2> oo_miguel, did you download ghc yourself, or let stack download and install it for you?
05:38:55 <oo_miguel> I am running "stack ghcrun foo.hs" for example, so my assumption is that stack uses the ghc/cabal that it provides by itself. no?
05:39:12 <oo_miguel> s/ghcrun/runghc
05:39:45 <jollygood2> pressumably, yes. but I'm not entirely sure what that would do if you already had stand-alone ghc installed. 
05:40:01 <oo_miguel> also lts-15.1 on stackage.org claims itself that it is using ghc-8.8.2
05:40:18 <oo_miguel> while I get a warning that stack has not been tested with it/
05:40:52 <oo_miguel> LTS 15.1 for ghc-8.8.2, published a week ago
05:41:01 <jollygood2> did you already have ghc before using stack? 
05:41:04 <oo_miguel> Stack has not been tested with GHC versions above 8.6
05:41:55 <oo_miguel> yes I installed ghc as a debian package before
05:42:46 <jollygood2> I think stack can work alongside stand alone ghc, but I'm not entirely sure. does `stack upgrade' help?
05:43:17 <oo_miguel> the one coming with debian is another verison and is not used by stack. I also did stack upgrade and have the most recent version
05:43:57 <oo_miguel> could you/or someone check what this gives you: $ stack --resolver lts-15.1 ghc -- --version
05:44:53 <jollygood2> I get Downloading lts-15.1 build plan ...RedownloadFailed Request
05:45:08 <jollygood2> but I am using very old ghc, and stack
05:45:51 <jollygood2> lts-9.18, have not upgraded anything since. =)
05:46:02 <oo_miguel> ehehe
05:50:52 <jollygood2> I like stability, I can keep working on several years old programs and library without making any modifications, because ghc or some library had a breaking change. compilation is fast too, as all the libraries are use have been downloaded and compiled years ago. at some point, though, I'll have to make the jump
05:59:42 <thblt> How do I add dependencies to the global stack project?  For example, if I want to have optics, optparse, etc, available from stack ghc[i] without a project? 
06:01:42 <thblt> (Sorry if it's obvious, but I really don't find anything)
06:03:35 <__monty__> jollygood2: I like optparse-applicative.
06:24:38 <sm[m]> thblt: ~/.stack/global-project/stack.yaml
06:26:12 <sm[m]> oo_miguel: yes that "not tested with" warning is annoying. I guess a new stack release must be coming soon, or you could try stack upgrade --git
06:26:44 <sm[m]> (the warning is harmless)
06:28:10 <bapa> Speaking of jollygood2's situation just how common is breakage when upgrading deps / GHC version in large Haskell codebases? I've vaguely heard about this being an issue sometimes.
06:28:53 <merijn> bapa: Depends how you define breakage?
06:29:09 <merijn> And also how soon you upgrade GHC after release
06:30:14 <hpc> in my experience, most issues are going to be with how your environment is set up
06:30:38 <hpc> like if your distro doesn't package the newer ghc, you install it yourself, and have a mixed setup
06:30:48 <hpc> or a newer stack lts that your distro's stack doesn't support, etc etc
06:31:34 <hpc> or i guess if you are an early enough adopter, some packages might not support it
06:32:10 <hpc> usually the ones that are abandoned or use ghc as a library or something like that, if you pick good packages to depend on that won't happen so much
06:32:50 <__monty__> For me it's mostly depending on some libraries that make PVP major version changes on what seems like a daily basis.
06:33:53 <sm[m]> a new major GHC version will cause breakage every time, pretty much
06:35:30 <oo_miguel> sm[m]: oh ok thank you. wasn't sure if it just happens for me
06:35:39 <sm[m]> if you're an early upgrader, you'll have a lot of install plan / dependency work to do. If you wait a long time for the ecosystem to catch up, you'll just have to deal with the changes in GHC & standard libs, for which there's usually migration notes
06:36:12 <sm[m]> that part can take a few minutes to a few hours
06:36:54 * hackage ghc-lib-parser-ex 0.20200301 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-0.20200301 (shayne_fletcher)
06:40:52 <thblt> sm[m]: Thanks!
06:44:40 <justsomeguy> What does it mean for a file handle to be half closed?
06:44:43 <jollygood2> stack can keep multiple ghc versions installed at once, so jump can be gradual (ie using old lts and ghc for projects you wrote years ago, that you don't feel like updating, and latest ghc and libraries for new projects)
06:45:04 <comerijn> jollygood2: I mean, you can do that without stack just as well...
06:45:30 <jollygood2> comerijn, you have to manage multiple ghc versions yourself, IIRC. and how well that works, may depend on the OS
06:45:49 <comerijn> jollygood2: There's not much to manage, just install them in different directories
06:49:11 <justsomeguy> I should have not asked, it's in the docs for System.IO.
06:49:43 * justsomeguy usually is pretty good about looking up things before asking questions, but he was careless this time
06:49:50 <jollygood2> comerijn, does that work on all the OSes? have you tried? how do you pick which one to use, for each project? i guess you can have a script per project that calls appropriate ghc version. what about libraries? stack will use same library versions it used years ago. I'm not sure how far plain ghc has come, but there's something very convenient about just doing "stack install" and have it handle everything for you automatically
06:50:43 <merijn> jollygood2: Cabal just uses whatever is on your path first, or you can use the --with-ghc flag to tell it which version
06:51:58 <merijn> If you want the same package as year ago, then you should just fix your version bounds correctly to use that package or use a freeze file
06:53:23 * hackage ghc-tags-plugin 0.1.0.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.0.0 (coot)
07:08:11 <maerwald> stack is becoming more and more obsolete these days imo. It's just a matter of taste, no fundamental differences.
07:08:54 * hackage ghc-tags-plugin 0.1.0.1 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.0.1 (coot)
07:08:59 <maerwald> And it doesn't offer actual reproducible builds, so for that you're gonna use something else anyway.
07:09:20 <jollygood2> maerwald, it doesn't? how so
07:09:34 <maerwald> Pinning dependencies != reproducible builds
07:09:44 <sm[m]> maerwald: you're talking nonsense, man
07:09:50 <maerwald> huh?
07:10:05 <sm[m]> "stack is becoming obsolete"
07:10:12 <maerwald> Yeah
07:10:48 <maerwald> I said 'imo' :)
07:10:51 <jollygood2> maerwald what is missing to make builds reproducible? in practice, I had no problems reproducing them, including on several of my friend's computers, who had no ghc installed
07:11:04 <maerwald> jollygood2: the binaries produce the same hash? :>
07:11:09 <maerwald> I doubt it
07:11:20 <maerwald> What it requires is pinning the entire environment, including system libs
07:11:20 <jollygood2> maerwald, I did not check, nor care
07:11:28 <maerwald> Yes, then those are not reproducible builds
07:11:32 <sm[m]> there's levels of reproducibility
07:11:43 <maerwald> In distro packaging there's only one meaning
07:11:56 <jollygood2> yeah, stack doesn't manage non-haskell libraries, that is beyond it's scope
07:12:02 <maerwald> Exactly
07:12:14 <maerwald> So if your requirements are reproducible builds, you cannot use stack
07:12:30 <maerwald> If you want "it builds on my friends PC", then it might be enough
07:13:46 <__monty__> maerwald: Well the first requirement for reproducible haskell builds would be a deterministic compiler, and afaik, GHC is not.
07:14:01 <sm[m]> maerwald: I'll bite.. imagine you're talking to a haskell user. If they're interested in "reproducible builds" as they understand that, what's better than stack ?
07:14:11 <maerwald> __monty__: I've heard that claim, but I haven't investigated it
07:14:15 <__monty__> sm[m]: Nix : )
07:14:18 <maerwald> So no idea if it's true
07:14:26 <sm[m]> they're on windows. What now ?
07:14:43 <geekosaur> "good luck"
07:14:54 <__monty__> sm[m]: SOL, no reproducible options afaik.
07:14:59 <sm[m]> "install stack", "move on"
07:15:08 <geekosaur> "and pray"
07:15:10 <jollygood2> so stack comes the closest, is what you're saying?
07:15:15 <sm[m]> "and be happy"
07:15:18 <sm[m]> yup
07:15:19 <maerwald> sm[m]: I don't know what "better" means. Stack offers a more opaque API than the alternatives (ghcup + cabal + freeze file + index pinning ....)
07:15:41 <maerwald> So that is just taste
07:15:45 <maerwald> Nothing fundamental
07:15:54 <geekosaur> it sounds windowsy: great if it all works, god help you if not
07:15:56 <sm[m]> again, windows ? cross platform ? The point is, these blanket statements are no good without defining your context and assumed restrictions
07:16:06 <maerwald> sm[m]: ghcups
07:16:22 <maerwald> You can use cabal fine on windows
07:16:58 <maerwald> My point is: stack doesn't offer something you can't do without it. Reproducible builds *would* be something, but they aren't.
07:17:21 <sm[m]> maerwald: have you used stack heavily ?
07:17:24 <maerwald> yes
07:18:05 <sm[m]> wouldn't you agree it makes some common workflows at least more convenient, more likely to work cross platform, and with typically better QA ?
07:18:15 <maerwald> No
07:18:22 <jollygood2> they are reproducible, on haskell level. there's a value to that. it doesn't have to handle everything to be of value
07:18:29 <sm[m]> alright.. I guess we'll agree to disagree :)
07:18:37 <maerwald> Whenever I use it, I hit inconveniences, e.g. since a few stack versions you can't use tags/branches etc. anymore in stack.yaml :
07:18:41 <maerwald> How is that convenient?
07:19:02 <maerwald> Now you have to reference commit hashes and it doesn't even support short commit hashes
07:19:03 <maerwald> ...
07:19:33 <maerwald> Also, new versions of stack don't work with old stack.yaml formats
07:19:42 <maerwald> Compatibility isn't very good there
07:20:01 <maerwald> So you migrate all your repos, but then... you can't reference branches anymore :D
07:38:24 * hackage derive-storable 0.2.0.0 - Derive Storable instances with GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.2.0.0 (mkloczko)
07:53:54 <jsomedon> just found out that wiwinwlh is updated, thought it's abandoned
07:55:40 <aveltras> how would one recover a data constructor through an aeson serialized value of TypeRep ?
08:04:44 <Phyx-> what makes stack any more reproducible than cabal?
08:05:25 <Phyx-> isn't that what freeze files are for?
08:06:13 <Phyx-> __monty__> maerwald: Well the first requirement for reproducible haskell builds would be a deterministic compiler, and afaik, GHC is not. <- indeed. GHC is far from being able to generate reproducible binaries
08:06:28 <Phyx-> so untill then, anything that claims to offer reproducible builds are just lying
08:07:17 <Phyx-> even *nix* doesn't offer reproducibility in the classical sense, because the compiler itself can't offer it
08:09:49 <__monty__> Phyx-: Yep, though it is working to get closer, https://r13y.com
08:13:11 <maerwald> Phyx-: exactly, stack is as reproducible as cabal
08:13:26 <maerwald> however, not with freeze files, you also need hackage state index pinning
08:39:38 <sm[m]> on another note.. here's a make rule/ghcid command for watching something while you hack. I think it's nifty: https://termbin.com/jrtl
08:42:07 <sm[m]> how could you put multiple GHCI : commands on one line ?
08:44:21 <__monty__> I'm not sure it's possible.
08:52:30 <iqubic> Just use entr. https://eradman.com/entrproject/
08:54:21 <Xnuk> entr is good
08:55:49 <iqubic> I totally agree with that statement.
08:59:11 <geekosaur> if this is for ghc -e, I think you can use multiple -e options
09:13:49 <remexre> is there a standard way to express multi-licensing in a .cabal file?
09:14:37 <remexre> e.g. sources under (Apache / MIT) dual-license, icons etc under CC BY, data files under EULA
09:17:31 <remexre> or do I just do OtherLicense and have a slew of license-files
09:27:08 <freeside> question -- i'm learning hxt. Given a relaxng schema is there some way to automatically derive an unpickler and a set of Haskell types ready to go?
09:29:27 <sm[m]> iqubic: I agree entr is awesome, but it doesn't do what ghcid does here
09:32:18 <Xnuk> remexre: try `Apache-2.0 OR MIT` ?
09:32:46 <remexre> Xnuk: oh, does it do SPDX, then?
09:33:25 <remexre> huh, yeah, looks like it does
09:33:36 <Xnuk> hurray
09:34:41 <remexre> I guess a downside is that SPDX doesn't let me scope licenses though
09:35:03 <remexre> so it's like (Apache-2.0 OR MIT) AND CC-BY-4.0 AND OtherLicense
09:35:10 <remexre> which :|
09:40:25 <remexre> oh, hm, cabal doesn't like the (
09:40:54 <remexre> ah, I need cabal-version: 2.2
09:41:36 <remexre> ugh, and OtherLicense doesn't work w/ SPDX?
09:43:02 <mirk0> http://ix.io/2d74/haskell
09:43:27 <mirk0> can you tell me why line two works as expected, but the third and following two don't
09:43:38 <mirk0> the only difference is that I use function that accepts argument
09:44:32 <mirk0> it doesn't throw errors but I assume that syntax is not right here to accomplish the result I want
09:44:36 <remexre> okay, nice, it's fine with LicenseRef-MyLicense
09:45:25 <mirk0> it's xmonad config file
09:59:20 <Tavixvi> I'm trying to learn Haskell. I'm trying to write a sudoku-solving program, and I'm at the point where I'm trying to represent the grid as a datatype. Originally I was just passing around indecies,  but that felt sloppy. The issue is representing the board as a relation between the squares because it's a cyclic relationship. I'm considering using Data.Graph, but what I don't know is if there's a more appropriate way of doing it?
10:03:48 <monochrom> Use lists or arrays.
10:03:49 <koz_> Tavixvi: What do you mean by 'cyclic relationship' here?
10:04:22 <monochrom> Also, python is the poison that caused people to equate the two.
10:04:28 <koz_> Yes.
10:05:16 <monochrom> Anti-intellectual language.
10:05:35 <Tavixvi> One square can't have the same value as any of the squares in the same row, column, or block. So has to be able to reference each of those squares, and their relations, which contain the original square.
10:06:03 <monochrom> You cannot express all constraints in a type.
10:07:39 <solonarv> in Haskell the datatypes are "dumb", they just hold values
10:07:56 <Tavixvi> Well, the constraints don't need to be expressed in the type, but the type would need cycles in order to allow the contraints to be enforced by the functions that manipulate the type.
10:08:15 <solonarv> why does the type need cycles? surely a 9x9 array would work just fine
10:10:09 <monochrom> I used lists for the n-queen problem. I am not sure what "cycle" means but whatever it is I enforced in my functions not the type.
10:19:59 <Tavixvi> I guess an array would be fine, and slightly less complicated than a graph, even though sudoku solving is a graph coloring problem from my understanding.
10:28:54 * hackage inline-asm 0.4.0.0 - Inline some Assembly in ur Haskell!  https://hackage.haskell.org/package/inline-asm-0.4.0.0 (0xd34df00d)
10:29:32 <nshepperd2> people always seem to reach for fancy knot-tying graph types when they start out in haskell but plain old arrays and indices are best
10:31:24 <nshepperd2> maybe Data.Graph if you need a dynamic graph
10:32:14 <sm[m]> is there a way to use a qualified "X.var" form inside module X ?
10:35:34 <geekosaur> doesn't that just work?
10:38:14 <charh> hello haskellers, i builded my first binary (i'm a haskell beginner) if any can see for give me a possitive review, I'll be very greatful. https://github.com/innaky/lg
10:38:31 <MarcelineVQ> should, sm[m] is the name perhaps more like  Bif.X.var ?
10:39:23 <dminuoso> charh: https://github.com/innaky/lg/blob/master/src/Main.hs#L54-L57 this is highly unidiomatic. Just write `return (isSymbLink && isDir)` instead. :)
10:39:48 <sm[m]> sorry.. not enough screen space here. geekosaur , not for me. 
10:39:53 <dminuoso> charh: Try moving https://github.com/innaky/lg/blob/master/src/Main.hs#L75-L85 into a where binding below getSize
10:40:04 <sm[m]> ah of course - the fully qualified name works, I was wanting just the last part
10:40:15 <sm[m]> but that'll do, thanks
10:40:33 <sm[m]> I thought of importing myself qualified or something
10:40:35 <MarcelineVQ> sm[m]: I don't think it's currently possible to rename the module you're in
10:40:55 <MarcelineVQ> at least, the obvious way to try results in an imporing self error
10:40:56 <dminuoso> charh: Same here https://github.com/innaky/lg/blob/master/src/Main.hs#L75-L85 - you could also try generalizing this and the last into a common top level binding
10:42:14 <dminuoso> charh: Furthermore `[x] ++ xs` is unidiomatic (https://github.com/innaky/lg/blob/master/src/Main.hs#L28). Write `x:xs` instead. 
10:42:14 <charh> dminuoso: i'm taking notes!, wow, thanks! :D
10:42:42 <dminuoso> charh: Overall, that function `mix` is already implemented in:
10:42:45 <dminuoso> % :t zip
10:42:45 <yahb> dminuoso: [a] -> [b] -> [(a, b)]
10:43:03 <dminuoso> So try reimplemting it in terms of zip. :)
10:43:09 <dminuoso> Secret tip for that
10:43:14 <dminuoso> % :t curry
10:43:14 <yahb> dminuoso: ((a, b) -> c) -> a -> b -> c
10:43:17 <dminuoso> % :t uncurry
10:43:17 <yahb> dminuoso: (a -> b -> c) -> (a, b) -> c
10:43:22 <dminuoso> The latter one, sorry! :)
10:44:19 <dminuoso> charh: Next up, instead of using `mySort`, try using the `Down` newtype instead
10:45:08 <dminuoso> Another neat trick is
10:45:16 <charh> oh oki! thanks for your comments mr. dminuoso (i'm taking notes!)
10:45:17 <dminuoso> % :t compare Eq
10:45:17 <yahb> dminuoso: ; <interactive>:1:9: error:; * Data constructor not in scope: Eq; * Perhaps you meant `EQ' (imported from Prelude)
10:45:21 <dminuoso> % :t compare EQ
10:45:21 <yahb> dminuoso: Ordering -> Ordering
10:46:06 <dminuoso> % :t sortBy (compare EQ) [2,1,3,4]
10:46:06 <yahb> dminuoso: ; <interactive>:1:9: error:; * Couldn't match type `Ordering' with `Ordering -> Ordering'; Expected type: Ordering -> Ordering -> Ordering; Actual type: Ordering -> Ordering; * Possible cause: `compare' is applied to too many arguments; In the first argument of `sortBy', namely `(compare EQ)'; In the expression: sortBy (compare EQ) [2, 1, 3, 4]
10:46:32 <dminuoso> % sortBy (compare EQ . compare) [2,1,3,4]
10:46:32 <yahb> dminuoso: ; <interactive>:125:9: error:; * Couldn't match type `Ordering' with `a -> Ordering'; Expected type: a -> a -> Ordering; Actual type: a -> Ordering; * Possible cause: `(.)' is applied to too many arguments; In the first argument of `sortBy', namely `(compare EQ . compare)'; In the expression: sortBy (compare EQ . compare) [2, 1, 3, 4]; In an equation for `it': it = 
10:46:35 <dminuoso> Hold on
10:47:11 <dminuoso> % sortBy (fmap (compare EQ) . compare) [2,1,4,3]
10:47:11 <yahb> dminuoso: [4,3,2,1]
10:47:44 <charh> wow, beautiful
10:47:54 <charh> thanks
10:48:03 <charh> :D
10:55:57 <dminuoso> Or, with a bit more visual pleasantry
10:56:03 <dminuoso> % (.:) = (.) . (.)
10:56:03 <yahb> dminuoso: 
10:56:14 <dminuoso> % sortBy (compare EQ .: compare) [2,1,4,3]
10:56:14 <yahb> dminuoso: [4,3,2,1]
10:56:26 <maerwald> obfuscation complete
10:56:31 <zincy_> Does this make sense "It is important to remember that in Functor f, the f is expected to be a type constructor, not a type"
10:56:43 <dminuoso> zincy_: No.
10:56:51 <zincy_> I read it in a book
10:57:04 <zincy_> Functors /= Type Constructor 
10:57:06 <zincy_> right?
10:57:10 <dminuoso> zincy_: A type constructor is a type in its own right.
10:57:37 <dminuoso> Though GHC diagnostics are a bit fuzzy on this.
10:57:42 <zincy_> Yeah
10:57:49 <zincy_> I mean all types have kinds
10:57:56 <zincy_> and type constructors have kinds
10:58:12 <dminuoso> zincy_: Type constructors are to types as data constructors are to values.
10:58:12 <zincy_> Is that a sufficient set of premises
10:58:26 <dminuoso> zincy_: There can be unary type constructors as well.
10:58:34 <dminuoso> % newtype Foo = Bar
10:58:34 <yahb> dminuoso: ; <interactive>:157:15: error:; * The constructor of a newtype must have exactly one field but `Bar' has none; * In the definition of data constructor `Bar'; In the newtype declaration for `Foo'
10:58:39 <dminuoso> % newtype Foo = Bar Int
10:58:39 <yahb> dminuoso: 
10:58:50 <dminuoso> here Foo is a type constructor, but its clearly not admissable for Functor
10:59:09 <d34df00d> I was trying to measure time spent by a function, and I got two questions:
10:59:22 <zincy_> dminuoso: Ah yes.
10:59:26 <dminuoso> Being a type constructor means being able to pattern match on the type (say in typeclass instances or type families)
10:59:45 <zincy_> So type constructors can be thought of as types which create other types when a parameter is applied to them?
10:59:47 <dminuoso> Similarly to how being a data constructor means being able to pattern match on it via case-of
10:59:52 <dminuoso> No.
10:59:57 <dminuoso> Just as Ive demonstrated to you.
11:00:05 <d34df00d> 1. The commonly recommended timeit uses System.CPUTime.getCPUTime, which includes system time as well, but claims to return the number of picoseconds _used by the current program_. Shall the `base` docs be amended to mention that it also includes system time?
11:00:08 <dminuoso> A type constructor is something you can "pattern match" on.
11:00:28 <d34df00d> 2. Given the above, how do I measure user time of my program without doing C FFI for calling times/getrusage manually?
11:00:36 <zincy_> Right, that makes sense
11:00:49 <dminuoso> In the example above, Foo takes no arguments.
11:00:50 <geekosaur> system time probably doesn't mean what you think: it's time that is spent running in the kernel. completely missing is time blocked or spent doing context switches, etc.
11:00:52 <dminuoso> And yet its a type constructor.
11:01:03 <zincy_> is that example not a nullary type constructor?
11:01:09 <zincy_> As opposed to Unary?
11:01:10 <dminuoso> Pardon me, yes.
11:01:16 <d34df00d> geekosaur: yeah, in this case I'm doing some IO (on tmpfs) and I don't want to measure that.
11:01:18 <geekosaur> and user time is time spent executing in userspace. neither is the same as "wall clock time"
11:01:28 <d34df00d> That is, the amount of time the kernel spends handling page faults and what not.
11:01:33 <zincy_> So that is a counter example to my claim that all type constructors create other types when supplied with a paramter
11:01:38 <dminuoso> Right.
11:01:42 <d34df00d> And I'm interested precisely in the userspace part.
11:02:12 <zincy_> So nullary constructors aren't applied I don't know why I thought they were :)
11:02:42 <dminuoso> zincy_: That being said, the terminology is fuzzy and GHC is not clear about it.
11:03:08 <zincy_> dminuoso: Thanks for your help
11:03:14 <dminuoso> zincy_: GHC currently considers something like `Maybe` not a type, which is why it gives diagnostics like "Expected T to be a type, but gotten a thing of kind * -> *"
11:03:31 <zincy_> I never thought about the pattern matching connection via typefamilies to data constructors
11:03:42 <dminuoso> zincy_: Not just type families, but typeclass instances as well.
11:03:50 <zincy_> Ah yes
11:03:57 <dminuoso> zincy_: You can think of a typeclass instance declaration as specifying a pattern match rule in some sense.
11:04:12 <dminuoso> This line of thinking is leveraged in GHC.Generics
11:04:37 <zincy_> So is `Maybe` a type? I would have thought so
11:05:12 <dminuoso> It depends on your definition of the term "type". I consider a type to be any entity existing in the type universe.
11:05:22 <dminuoso> As in "If it has a kind, its a type"
11:05:30 <zincy_> I guess the error message assumes a particular definition of the word "type"
11:05:47 <dminuoso> GHC itself uses the notion that "any fully applied type-level entity is called a type" in its diagnostics.
11:06:08 <dminuoso> I guess part of the problem is finding an accurate term for "inhabitable types" that doesnt flat out confuse beginners
11:06:27 <zincy_> It is strange that different definitions of "type" can be applied to the same type system.
11:06:49 <dminuoso> This is just about the diagnostics, mind you.
11:06:56 <dminuoso> It's not what GHC believes internally
11:07:02 <zincy_> Right gotcha
11:07:13 <zincy_> That is a difficult line to tread, error messages
11:10:08 <DigitalKiwi> is there a type for numbers 0-9
11:10:34 <geekosaur> nope
11:12:03 <DigitalKiwi> is there an easy way to make one? i really want to work with them as strings/chars anyway but it would be only '0' '1' ... '9'
11:12:59 <DigitalKiwi> or should i data Num = Zero | One | Two...
11:13:23 <zincy_> Peano?
11:13:35 <geekosaur> subset types aren't a thing in Haskell, at least not yet
11:14:13 <geekosaur> and data Num will run into problems because it's in the same namespace as class Num
11:14:37 <DigitalKiwi> different name then
11:14:37 <zincy_> Could you have a typefamily based on Peano numbers which prevents the construction of Ten
11:15:23 <DigitalKiwi> like is it possible or will it work for me? idk and...probably?
11:15:36 <DigitalKiwi> or maybe there's a better way to do this anyway
11:15:39 <dogcat1> Yes, you should be able to
11:16:12 <dogcat1> but like DigitalKiwi said, it might not be a good idea
11:16:23 <dogcat1> what are you trying to achieve?
11:16:29 <DigitalKiwi> trying to convert resistor color codes to and from their values
11:17:38 <DigitalKiwi>   print $ Resistor4 DBlack DBlack MBrown TBrown
11:18:50 --- mode: weber.freenode.net set +o ChanServ
11:19:10 <DigitalKiwi> where DColors is a Digit and working with them is like; strings of length 1 <=> numbers 0-9
11:19:46 <zincy_> DigitalKiwi: Possible maybe but tricky
11:20:37 <DigitalKiwi> https://github.com/seinosuke/resistor/blob/master/lib/resistor/color_code.rb#L111-L133 here's a ruby version
11:21:15 <DigitalKiwi> https://mostlyabsurd.com/files/Main.hs here's whatever i have right now that may or may not be good probably not good
11:21:24 <dogcat1> would a function like "fnResistor :: Band -> Band -> Multiplier -> Tolerance -> Resistor" work?
11:21:38 <geekosaur> I'd just use Int or Integer, that way you also don't need a separate type for the multipliers. don't see much point in a subset because you don't do math on them as such
11:22:05 <geekosaur> that is, you never add green to blue, although you do have positional multipliers and eventually add those together
11:22:24 * hackage aeson-combinators 0.0.1.1 - Aeson combinators for dead simple JSON decoding  https://hackage.haskell.org/package/aeson-combinators-0.0.1.1 (MarekFajkus)
11:22:43 <DigitalKiwi> i was having problems with pattern matching for going between colors and numbers
11:23:25 <dogcat1> Incomplete pattern matching?
11:23:30 <DigitalKiwi> yeah
11:23:49 <dogcat1> one way to handle that is with an Either return type
11:23:54 <geekosaur> this is one of those cases where you just use error because the default case should be unreachable anyway
11:24:10 <geekosaur> but you can't currently encode that in a Hskell type usefully
11:24:24 <DigitalKiwi> i had a version a while ago that was Either but i didn't like the way i was doing it
11:24:54 <DigitalKiwi> https://mostlyabsurd.com/files/Main-bak.hs
11:26:16 <dogcat1> that's exactly what I was going to suggest, lol
11:27:01 <DigitalKiwi> that it was Either wasn't what i didn't like it was more uh idk anymore what i didn't
11:27:10 <DigitalKiwi> is it better than the new one
11:27:45 <dogcat1> IMO either is a great way to handle a failure case when you know what the universe of those failures could be
11:28:51 <DigitalKiwi> i usually convert to Either after to get rid of undefines and errors like this new one will have Either/Maybe but i haven't got there
11:29:23 <DigitalKiwi> it's just easier for me to refactor it than to write it correctly first :P
11:39:21 <SamK57384> hey guys just a quick one - anyone know how to remove ghcup, sorry if this is asked alot it's just not immediately obvious to me from the install page here 
11:39:26 <SamK57384> https://www.haskell.org/ghcup/
11:40:07 <SamK57384> just delete the ~/.ghcup folder or more? (on osx by the way)
11:40:34 <monochrom> Take a look at .ghc and .cabal too
11:41:22 <SamK57384> oh right yeah, so just delete all those manually? or?
11:41:45 <maerwald> wait, you wanna remove all haskell stuff or just ghcup
11:41:47 <__monty__> SamK57384: I'd run `which ghcup` first, install may have added some directory to your PATH.
11:41:58 <monochrom> It is not clear for your question what you want to keep or discard.
11:41:59 <SamK57384> yeah all of it and ghcup 
11:42:07 <monochrom> s/for/from/
11:42:19 <SamK57384> everything haskell related - just for a minute as I want to retrace my steps on something
11:42:45 <monochrom> There is always the trick of "rename, don't remove" when in doubt.
11:44:50 <SamK57384> it's /Users/ME/.ghcup/bin/ghcup __monty__
11:45:20 <SamK57384> yeah guess I'll just stash all those folders somewhere then and see what happens
11:51:28 <__monty__> SamK57384: Ok, that means ~/.ghcup has been added to your PATH somehow. So if you really want to remove all traces you should find out where, bashrc, zshrc are likely candidates.
11:52:28 <SamK57384> yeah sure.. crazy though no mention of uninstall procedures anywhere - including on the repo / issues lists
11:52:47 <SamK57384> https://gitlab.haskell.org/haskell/ghcup#installation
11:53:17 <maerwald> SamK57384: because it's literally just remove ~/.ghcup :>
11:53:36 <SamK57384> ok cool cheers
12:02:52 <pyBlob> I have multiple functions "a, b, c :: X -> X" and I can apply them in squence using "(c . b . a) x", is there an operator so I can write "x >> a >> b >> c"?
12:05:41 <hexagoxel> :t (&)
12:05:42 <idnar> pyBlob: `x & a & b & c`
12:05:43 <lambdabot> a -> (a -> b) -> b
12:08:16 <pyBlob> Thanks, now I was able to find it the docs =)
12:08:43 * Uniaika coughs in (|>)
12:08:50 <Uniaika> (but that's my Elixir side :P)
12:13:06 <pyBlob> Yep, that |> is actually more readable ^^
12:13:27 <d34df00d> `base` doesn't expose `HsBaseConfig.h` does it?
12:13:32 <d34df00d> I could reuse some system checks from it.
12:14:44 <geekosaur> looks exposed to me
12:15:27 <d34df00d> geekosaur: hmm, how do I use it in a different package?
12:15:46 <d34df00d> I never had a change to #include a .h from one haskell package in another one before!
12:15:57 <geekosaur> I expect you need to use it from C code, since #include is not part of Haskell as such
12:16:24 <d34df00d> *.hsc in my case.
12:16:28 <geekosaur> but it's part of the "binary" base package
12:16:44 <geekosaur> that should work but I couldnt tell you how as such.
12:17:30 <d34df00d> BTW how do you know it's exposed? I just looked at the base.cabal and noticed it's present in the extra-source-files. Is it it or is it something else?
12:18:36 <geekosaur> I looked in the installed base package and found it in the include dir
12:19:17 <geekosaur> so it's there but I don't know how you get to it
12:25:11 <d34df00d> geekosaur: haha, I just tried just #include "HsBaseConfig.h" in my module and it worked.
12:25:16 <d34df00d> Well... at least it didn't complain.
12:25:20 <d34df00d> So maybe that's the right way.
12:25:54 <d34df00d> Yeah, it errors out on #include "fdasfdsafasd.h", so presumably it means that I'm OK'ish.
12:27:04 <phadej> hint, read the docs... https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-install-includes
12:29:05 <d34df00d> Oh, thanks for the link!
12:30:51 <phadej> base is indeed special package, and have not-so-correct .cabal file (as it's not "installed" by Cabal)
12:31:53 <phadej> it should have autogen-includes and more sruff in install-includes; maybe it does in ghc head already, i looked only at version on Hackage
12:50:38 * geekosaur looked at the actual installed base on his system for that reason
12:51:13 <geekosaur> figured it'd be more accurate than a cabal file that can't actually be used for bootstrapping reasons
13:02:07 <maerwald> phadej: are you familiar with the tar package?
13:04:21 <remexre> with a new-style cabal project, how do I get haddock to document my dependencies as well?
13:05:20 <remexre> oh, --haddock-internal, got it
13:06:54 <remexre> er, wait, just without --enable-profiling?
13:08:24 <sm[m]> --haddock-internal is about internal modules of your package, I think
13:09:31 <remexre> yeah, and it looks like removing --enable-profiling didn't actually make it generate the docs
13:09:38 <remexre> just rebuilt the deps, which duh
13:12:41 <maerwald> enable the documentation for all non-local packages
13:13:48 <maerwald> package *\n\tdocumentation: True
13:13:54 <remexre> in cabal.project?
13:13:56 <maerwald> yeah
13:14:14 <maerwald> if you put 'documentation: True' that is only enabled for local packages
13:14:29 <remexre> that's certainly doing smth
13:14:29 <maerwald> it's a bit confusing, imo
13:14:33 <remexre> yeah...
13:14:53 <maerwald> Also, if you have source-repository things in your cabal.project, these are considered local as well
13:16:43 <maerwald> sm[m]: one day you will use cabal :P
13:17:23 <sm[m]> I've used it plenty!
13:17:36 <maerwald> The old one maybe :P
13:17:41 <sm[m]> still do from time to time
13:18:12 <maerwald> The configuration is a bit messy and the documentation (e.g. --help output) a bit lacking
13:18:19 <maerwald> or let's say: unstructured
13:18:42 <maerwald> there are lots of flags I don't care about when reading --help lol
13:20:19 <remexre> maerwald: er, where would I find the docs afterwards
13:20:42 <remexre> find dist-newstyle -name '*.html' only shows my package
13:21:35 <maerwald> do the links inside the docs work?
13:21:53 <remexre> uh, don't actually have any, just started a new package
13:22:11 <remexre> doing this 'cause hackage doesn't have docs for the dependency
13:24:40 <remexre> oh, ew, links to ~/.cabal
13:26:07 <remexre> ugh, was hoping it'd use relative links so I could just drop the tarball onto a "dumb" http server
13:37:43 <gentauro> can this code be written to go faster? http://paste.debian.net/1133061/
13:38:16 <gentauro> I'm aiming to implement the FNV-1a to I can handle different hash sizes for `fingerprints` (Bloom Filters and Cuckoo Filters)
13:38:50 <d34df00d> Try throwing {-# LANGUAGE Strict #-} at it.
13:38:55 <gentauro> my question is aimed for any memory thunk not being evaluated and to
13:38:58 <d34df00d> Always helps in cases like this for me.
13:40:46 <d34df00d> I'd also probably consider using ByteString's instead of Strings (especially if you don't care about Unicode, and handling Word8's instead of Chars is fine for you).
13:42:03 <gentauro> d34df00d: I want to be able to hash any type that is `Showable`
13:42:15 <gentauro> % :t show
13:42:16 <yahb> gentauro: Show a => a -> String
13:42:52 <gentauro> so if I used ByteString, I would have to convert `showed` string to `ByteStrings` before I could hash them
13:43:12 <d34df00d> So you're rather gonna be hashing something that's show'ed and not big chunks of text (for some definition of "big")?
13:44:42 <monochrom> fnv-1a is a foldl'.  If you use foldl' you will actually have a chance of enjoying rewrite rules already written for foldl' and optimize away something.
13:45:04 <monochrom> Oh you're already doing that.
13:45:19 <monochrom> But using Integer is going to hurt.
13:45:20 <gentauro> monochrom: yeah. I heard is `strict`
13:46:25 <gentauro> I'm hoping for all my `bit` operations are `strict` as well
13:47:05 <d34df00d> My intuition is that the strictness analyzer is likely to figure out that everything's strict here.
13:47:30 <d34df00d> But I'd benchmark the code you have as-is vs the code with explicit strictness.
13:48:09 <monochrom> bit operations are strict alright.
13:48:42 <gentauro> monochrom: I need Integer in order to handle the greater numbers for up to 256-bit hashes `0xDD268DBCAAC550362D98C384C4E576CCC8B1536847B6BBB31023B4C8CAEE0535` 
13:49:09 <gentauro> even 128-bit hashes `0x6C62272E07BB014262B821756295C58D`
13:49:11 <monochrom> Your greatest inefficiency comes from Integer and trying to be so general about 32-bit, 64-bit, etc.
13:50:08 <koz_> gentauro: Can't you use like, https://hackage.haskell.org/package/data-dword-0.3.1.3/docs/Data-DoubleWord.html and their Word[insert number over 64] types here?
13:51:13 <monochrom> If I were a user, I would already know I chose 32 bits (for example) and I would appreciate using an algorithm that's optimized for 32 bits rather than carrying the baggage that only becomes useful when one goes 1024 bits.
13:53:09 <gentauro> koz_: is stuff like that I'm looking for
13:53:41 <koz_> gentauro: I can't understand that sentence, sorry. Do you mean 'that's the kind of stuff I'm looking for' or 'Is that the kind of stuff I'm looking for?' here?
13:53:50 <monochrom> And for the minority users who need that generality, you can always add a wrapper function that takes your size parameter, calls the appropriate size-tailored version, then fromIntegral back to Integer.
13:54:03 <gentauro> koz_: your feedback is the reason I'm asking here :)
13:54:12 <gentauro> I will look into it
13:54:32 <koz_> gentauro: Glad to be of assistance, then!
13:54:53 <gentauro> koz_: thx :)
13:55:52 <gentauro> monochrom: I'm looking into generelazing this with regard of a datastructure and it's related operations
13:57:06 <monochrom> You should take a look at how Data.Vector.Unbox does it for a generalized interface that covers multiple types and still be optimized for each type.  Namely, type families.
13:58:33 <monochrom> Since it looks like you reject low-tech techniques such as my "fnv_general 64 = fromIntegral . fnv_specifically_64"
13:59:45 <monochrom> fnv_specifically_64 is the tight loop and it need not work on anything more aesthetic as Integer, it can stay Word64.  You just need one single fromIntegral just one time when the loop finishes for Integer.
14:01:05 <monochrom> Do you actually know how Integer is implemented in GHC or base?  You should take a look and re-consider your vision.
14:02:30 <gentauro> monochrom: cool
14:02:40 <gentauro> thx foor feedback as well !!!
14:03:09 <gentauro> I'm not very knowledgeable when it comes to Haskell low-lever
14:07:57 <gentauro> s/lever/level/
14:15:04 <dogcat1> that's okay, everybody in the Haskell community should probably become more familiar with ghc: it's not that bad!
14:16:36 <gentauro> dogcat1: my "problem" with Haskell (and FP languages in general) is that the "nice piece of code" rarely is any usefull for "production ready applications"
14:17:08 <gentauro> what you end up doing is making all kind of "strange stuff in the code" (making it many times unreadable "for normal people" and therefore maintanable)
14:17:39 <gentauro> I'm guessing that we should probably get more "hardcore Haskell" people to work on the compiler instead of ... blockchain technologies? Just a thought
14:17:59 <koz_> gentauro: This is unavoidable in general.
14:18:04 <koz_> You either get fast code or code fast.
14:18:11 <koz_> Optimized code is unreadable in _any_ language.
14:18:21 <koz_> And that's because the compiler has no idea what problem you're solving.
14:18:29 <koz_> (and indeed, it can't)
14:19:05 <gentauro> koz_: Bartosz Milewski wrote recently a really nice blog -> https://bartoszmilewski.com/2020/02/24/math-is-your-insurance-policy/
14:19:39 <gentauro> where he talks about how we just throw "humanpower" to do task a computer should do
14:20:02 <koz_> gentauro: Yes, except that 'generation of optimal code to do X' is undecidable for arbitrary X.
14:20:17 <koz_> This isn't me being lazy or a lack of human-hours investigating it - it's quite literally _maths_.
14:20:40 <koz_> We can make it better for some specific values of X. Usually, these are obvious, or very necessary to a large subset of language users.
14:20:51 <koz_> There will always be cases where neither of these are the case.
14:21:09 <koz_> Your compiler doesn't think, and doesn't understand what you're trying to do.
14:21:24 <gentauro> koz_: I'm guessing that cornercases is not what the majority would reach
14:21:24 <koz_> It does its best, but 'its best' doesn't always mean 'the best it could do given the knowledge of an actual domain expert'.
14:21:39 <koz_> gentauro: I have no idea what you mean by 'reach' here.
14:21:49 <dogcat1> Well, Haskell is used in production all systems all the time, and it's found a pretty successful niche in a few different domains where companies need to ship complex software. So there are a lot of examples of production ready haskell code
14:22:10 <koz_> I would also argue that a lot of optimality-chasing misses the damn point.
14:22:22 <koz_> If your code is I/O bound, optimizing for CPU cycles is mostly a waste of time.
14:22:26 <koz_> Ditto if your code is memory-bound.
14:22:30 <koz_> Which _nearly everything is these days_.
14:23:37 <monochrom> Take a look at qsort in glibc (for example).  This is not something a code optimizer can do for you.
14:24:10 <monochrom> At least not until Skynet takes over.
14:24:22 <koz_> monochrom: I'm pretty sure Rice's Theorem still applies to Skynet.
14:24:25 <koz_> (last I checked)
14:24:54 <monochrom> I'm equally sure that Rice's Theorem applies to humans. And yet we have accomplished something.
14:25:21 <koz_> Still, your original point stands 100%.
14:25:33 <gentauro> monochrom: in my MSc thesis I studied C++ sort (`introsort`) so I have "some knowledge on C++ under the hood"
14:25:42 <gentauro> my initial point is
14:26:00 <gentauro> I can write insanely optimized code in C++ and C which I will not be able to read a week after
14:26:12 <monochrom> This is what comments are for.
14:26:29 <gentauro> this is why I find FP interesting
14:26:39 <koz_> This is also not unique to C or C++.
14:26:53 <monochrom> glibc qsort, much as its clever and a lot of special cases and long and counterintuitive, it's all explained in comments.
14:26:53 <koz_> Optimized code is unreadable in _any_ language.
14:27:03 <monochrom> s/its/it's/
14:27:05 <gentauro> as I said, it's very rare that I get fast code in FP languages if I don't write something as obscure (or even worse) of what I would write in C++ / C
14:27:30 <monochrom> This is why programmers still need to pass tests on reading and writing in natural languages.
14:27:44 <monochrom> Either that, or math.
14:28:01 <koz_> gentauro: Compare glibc's qsort to, say, how unordered-containers implements HAMTs. Which would you rather read?
14:28:30 <koz_> (setting comments aside)
14:30:41 <gentauro> koz_: if we are talking raw speed. Then I would aim for C++ sort (Introsort)
14:31:00 <koz_> gentauro: Your gripes were with readability - that's what I was referring to.
14:31:08 <gentauro> having in mind that C++ sort is `sequential`
14:31:17 <gentauro> so it would also depend on the architecture
14:31:20 <koz_> My point is that 'optimized code is horrendous in any language, and that's not really anybody's fault'.
14:31:36 <koz_> (also, I have a Master's in dynamic partial sorting, so you don't have to convince me :P)
14:31:45 <gentauro> koz_: :)
14:32:10 <koz_> I would, however, rather read (and write!) optimized Haskell than optimized C.
14:32:12 <koz_> Or C++.
14:32:16 <koz_> Or pretty much anything, really.
14:32:17 <gentauro> koz_: I programmed +3 years with C++ on a daily basis
14:32:25 <koz_> Yes, relative other Haskell, optimized Haskell isn't pleasant.
14:32:29 <gentauro> I was hoping not having to do that again in my lifetime :)
14:32:33 <koz_> I don't think it's _worse_ than optimized C.
14:32:34 <monochrom> GHC has rewrite rules. That makes things very nicer.  Take a look at the stream fusion paper on Data.Vector.
14:32:43 <koz_> monochrom: 'very nicer'. :D
14:34:47 <koz_> There's also SPECIALIZE pragmata, which can be helpful.
14:35:31 <monochrom> If you write like "sum (generate 100 (\x -> x*x))" it is likely O(1)-space.
14:35:46 <monochrom> err s/100/n/
14:36:00 <koz_> If you use unboxed Vectors, it's also probably even faster.
14:36:28 <koz_> (although that shouldn't even generate anything, derp)
14:36:59 <koz_> Ugh, I clearly need a tea break lol.
14:37:23 <Foo20> @help
14:37:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:09:44 <d34df00d> I'm getting "Exception when trying to run compile-time code: stack overflow" with my TH code. 1. How do I increase the stack size? 2. How do I know what's blowing it off?
15:13:38 <hseg> hi. unclear how to use Data.Map api to write the equivalent of concatMap
15:14:00 <merijn> hseg: What does concatMap do?
15:14:07 <merijn> (for Map, I mean)
15:14:43 <hseg> should have type :: (k -> v -> Map l u) -> Map k v -> Map l u
15:15:03 <hseg> oh wait
15:15:09 <merijn> That seems...oddly specific
15:15:33 <hseg> yeah, that's basically a fold accumulating the resulting maps, followed by a unionWith
15:15:42 <hseg> the concatMap was a red herring
15:15:50 <hseg> *shrug*
15:17:48 <hseg> hrm. still leaves me looking for foldWithKey :: Monoid m => (k -> v -> m) -> Map k v -> m
15:18:27 <hseg> but i suppose \f m -> foldWith (uncurry f) (toList m) will do
15:18:43 <hseg> seeing as it is subject to fusion
15:19:51 <hseg> (specific use case - have a polynomial encoded as a Map Monomial r, want to write a function substituting a polynomial for an indeterminate)
15:20:08 <ChaiTRex> What happens with collisions?
15:20:59 <solonarv> you could traverseWithKey using 'Const m' as the applicative
15:20:59 <hseg> in this case, (+), note my unionWith _ . fold decomposition above
15:21:18 <solonarv> that should allow you to write foldMapWithKey easily
15:21:25 <hseg> oh, nice
15:21:45 <solonarv> but it looks like Map's Monoid instance doesn't do what you want anyway
15:21:48 <hseg> yeah, that should work
15:21:58 <hseg> why not?
15:22:24 <solonarv> it's (<>) = unionWith (\l _ -> l)
15:22:35 <solonarv> instead of (<>) = unionWith (<>)
15:23:13 <hseg> right, but where would i be using that instance?
15:24:25 <solonarv> I thought you wanted to write something like 'foldMapWithKey :: (k -> v -> Map l u) -> Map k v -> Map l u', combining these maps with unionWith _
15:24:57 <hseg> i'm considering here \p s -> getConst (traverseWithKey (\m c -> Sum (c * subMonom m s)) p)
15:25:19 <solonarv> ah I see
15:25:23 <solonarv> that looks fine
15:25:40 <hseg> right, so the unionWith (<>) takes care of the explicit Monoid instance picking
15:27:24 * hackage parsix 0.2.2.1 - Parser combinators with slicing, error recovery, and syntax highlighting  https://hackage.haskell.org/package/parsix-0.2.2.1 (OlleFredriksson)
15:28:47 <jackdk> @package monoidal-containers is cool, but is forced to introduce a transitive dependency on lens
15:28:47 <lambdabot> http://hackage.haskell.org/package/monoidal-containers is cool, but is forced to introduce a transitive dependency on lens
15:29:11 <jackdk> newtype wrappers for many container types, which uses the monoid instance on the values
15:43:25 <bapa> Hmm, anyone know if there's a good library for expressively describing grammars to read files? Like, I mean, parsing file formats without being insanely verbose and specifying what to do at each and every step.
15:44:31 <remexre> bapa: parsec?
15:44:53 <solonarv> or one of its descendants, like megaparsec
15:44:59 <ChaiTRex> bapa: There are various parser combinator libraries. They generally have parsec somewhere in their name (parsec, megaparsec, nanoparsec, ...)
15:52:02 <bapa> Thanks fellas. I think I'll take a gander at MegaParsec, since its name reminds me of MEGA MILK.
16:51:08 <DigitalKiwi> to add to the list attoparsec may also be an option
16:57:34 <koz_> Or, as just announced, parsix.
17:15:03 <sm[m]> megaparsec is great
17:17:09 <sm[m]> any tips on more efficiently developing reliable parsers with it ?
17:18:58 <sm[m]> I find parser combinators are in a way too easy, you can quickly hang yourself with hard-to-visualise parse states and untested cases, eventually leading to a big rewrite
17:20:05 <sm[m]> I've tried writing a rough EBNF-y grammar in a comment at the top, that helps a bit
17:22:40 <sm[m]> I'd like to generate texts and fuzz test, but it seems hard to tackle
17:30:48 <iqubic> hello
17:32:37 <ChaiTRex> iqubic: Hello.
17:32:42 <iqubic> Hi.
17:32:44 <koz_> iqubic: Wazzup?
17:32:50 <koz_> Also ChaiTRex - how ya doin?
17:32:59 <ChaiTRex> Doing OK.
17:33:01 <iqubic> I was just sending that message to make sure I hadn't disconnected from IRC.
17:33:03 <koz_> Drinking your spiced milk tea with your little dinosaur arms?
17:33:06 <iqubic> I see I haven't.
17:33:11 <ChaiTRex> Keep procrastinating learning category theory.
17:33:22 <iqubic> ChaiTRex: Same here.
17:33:27 <ChaiTRex> koz_: Yes :)
17:34:48 <hpc> the trick is to learn enough category theory to have wrong ideas about how haskell implements it
17:34:58 <hpc> and then use that knowledge to procrastinate on something else :D
17:35:06 <iqubic> Yes.
17:35:12 <iqubic> Indeed.
17:35:15 <ChaiTRex> I have trouble getting anything done, so this is just an effect of that.
17:36:33 <koz_> ChaiTRex: Is it programming trouble, conceptual trouble, or T-rex arm trouble?
17:38:37 <ChaiTRex> Oh, no. When I watch the lessons and do the homework for category theory, I do OK. It's a lot like abstract algebra stuff at the beginning. I'm just unable to get much work of whatever kind done, cognitive stuff or chores or whatever.
17:39:47 <ChaiTRex> I'm about halfway through the first homework and stalled and then about six lectures into the recent programming and category theory MIT YouTube lessons.
17:41:24 * hackage hledger-lib 1.17 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.17 (SimonMichael)
17:42:24 * hackage hledger-web 1.17, hledger-ui 1.17, hledger 1.17 (SimonMichael): https://qbin.io/cap-fp-135m
17:54:54 * hackage inline-asm 0.4.0.1 - Inline some Assembly in ur Haskell!  https://hackage.haskell.org/package/inline-asm-0.4.0.1 (0xd34df00d)
18:10:32 <jollygood2> probably the ugliest haskell code I've ever written... https://pastebin.com/9q8w2yu2
18:11:34 <Axman6> giving those variables actual names would help a lot
18:11:59 <jollygood2> what would better names be? =). I followed this https://en.wikipedia.org/wiki/Computus#Anonymous_Gregorian_algorithm
18:12:17 <Axman6> also divMod/quotRem exist, and make it a little clearer when you're doing a division and remainder of the same value
18:13:07 <Axman6> at the very least a link to the algorithm on wikipedia would give someone some hope of understanding it :)
18:16:54 * hackage skews 0.1.0.3 - A very quick-and-dirty WebSocket server.  https://hackage.haskell.org/package/skews-0.1.0.3 (igrep)
18:21:23 <ChaiTRex> jollygood2: Minor cleanups: https://pastebin.com/cqnC1dTA (check that the quot and rem correspond to / and % properly because I might have erred).
18:23:35 <jollygood2> yeah, quotRem helps readability
18:27:38 <koz_> Those variable names...
18:32:54 <ChaiTRex> koz_: It's hard to get better variable names, since I don't think they represent anything nicely named. They're sort of CSE'd things.
18:35:10 <koz_> CSE?
18:35:30 <ChaiTRex> koz_: Common subexpression elimination.
18:48:51 <koz_> Ah.
18:49:03 <koz_> I _swear_ someone told me what that was just yesterday lol.
18:50:07 <ChaiTRex> koz_: I think someone did CSE by hand on it to make it as efficient as possible even if the compiler didn't bother to do CSE or didn't do it completely.
18:52:44 <koz_> Smells like the root of all evil.
18:52:58 <mmachenry> Does anyone have a favorite way to run Haskell scripts inside Docker containers? I am currently doing a cabal update, then cabal install <my dependencies>, then ghc -optl-static. All this within a haskell:8 temporary image and then I copy. 
18:53:24 * hackage composite-aeson 0.7.0.0 - JSON for Vinyl records  https://hackage.haskell.org/package/composite-aeson-0.7.0.0 (dridus)
18:54:13 <mmachenry> I am interested in potentially using stack script and keeping the dependency list inside the script. This would have the advantage of letting me keep dependencies of scipts with the code in one file and if I have many and things change I dont have to maintain a stack file or update the docker.
18:54:24 * hackage composite-swagger 0.7.0.0, composite-opaleye 0.7.0.0, composite-ekg 0.7.0.0, composite-base 0.7.0.0, composite-aeson-refined 0.7.0.0 (dridus)
18:54:32 <mmachenry> But don't want to pay the cost of running the script for the first time and only then downloading the dependencies.
18:55:05 <sm[m]> mmachenry: the cost is the same with a script or a cabal/stack project, no ?
18:55:36 <sm[m]> maybe give your script a "install deps" mode that does nothing
18:55:49 <Cale> You could use nix to generate a docker container that will already have the dependencies installed in it
18:56:21 <Cale> At least, I'm pretty sure that's what some people do, I haven't really had cause to try it
18:59:45 <Cale> there's an example of how to do it here: https://www.williamyaoh.com/posts/2019-04-09-deploying-haskell-with-ecs-and-nix.html
19:02:49 <sm[m]> yeah, even just a standard image that has the deps you usually use, then any extra stuff scripts install will be minimal
19:06:28 <mmachenry> Hm, I'll try that example, thanks.
19:09:09 <sm[m]> there's also https://hub.docker.com/u/fpco
19:13:10 <koz_> Is there some automagic library for automagicking Arbitrary instances of 'plain sums'?
19:13:20 <koz_> Like, somethign to the tune of data Foo = Bar | Baz | Quux
19:13:22 <koz_> ?
19:15:17 <Axman6> yes, generic-arbitrary or something?
19:15:39 <koz_> Thank you, Man Of Many Hacks.
19:15:50 <Axman6> we use a newtype which lets us use dericing (Arbitrary) via GenericArbitrary Foo
19:16:09 <koz_> I can just do this on my types directly. DeriveGeneric isn't really much of a problem.
19:21:12 <koz_> Also, is there something which Arbitraries Vectors, or do I have to go via fromList?
19:27:51 <koz_> quickcheck-instances, got it.
20:01:24 * hackage aura 2.2.1 - A secure package manager for Arch Linux and the AUR.  https://hackage.haskell.org/package/aura-2.2.1 (fosskers)
20:06:54 * hackage composite-aeson 0.7.1.0 - JSON for Vinyl records  https://hackage.haskell.org/package/composite-aeson-0.7.1.0 (dridus)
20:07:54 * hackage composite-swagger 0.7.1.0, composite-opaleye 0.7.1.0, composite-ekg 0.7.1.0, composite-base 0.7.1.0, composite-aeson-refined 0.7.1.0 (dridus)
20:23:52 <Ethan> Does anyone know what "biplateRef" from "Control.Reference" does?  I cannot find any information on this online
20:25:54 * hackage immortal-queue 0.1.0.0 - Build a pool of queue-processing worker threads.  https://hackage.haskell.org/package/immortal-queue-0.1.0.0 (lysergia)
20:40:18 <happycoder> is there any way to make hindent not mess up CPS style expressions' indentation?
20:48:46 <lyxia> koz_: generic-random!
20:52:18 <lyxia> Ethan: what package
21:00:34 <maxsu> hey can we internalize sets into a category the way we can internalize group objects?
21:01:57 <maxsu> and if so, are discrete, skeletal categories examples of such internalized sets in the category of small categories?
21:03:26 <maxsu> and finally, what should the signature diagram of an internalized set / set object be?
21:28:53 <koz_> lyxia: Wait, so that's not part of your all-singing, all-dancing, all-deriving library?
21:29:55 <MarcelineVQ> now do an all Sing-ing pun
21:42:22 <Ethan> lyxia: Control.Reference
21:46:08 <Axman6> Ethan: that's not a package, that's a module
21:46:21 <MarcelineVQ> That's the name of a module, lyxia is asking what package the module is from. for example Data.Map is provided by the package named 'containers'
21:49:16 <Ethan> im not sure what the difference between a package and a module is.  in this case is the question where it is included from or in what body of code did I find it being included
21:50:19 <MarcelineVQ> from, but both could be helpful to mention
21:50:20 <Axman6> Ethan: we'd like to help you but you're not giving us any information we can use to help you. where did you find this code?
21:50:37 <Ethan> looking up what the difference between a mudle and a package makes it seem like the package can contain modules
21:51:06 <Ethan> hang on let me grab the url
21:52:03 <Axman6> yes
21:52:15 <Axman6> a package is basically a library
21:54:01 <Ethan> so this is the url where i grabbed it from.  based off of the url, it would seem like the package is haskell-tools https://github.com/haskell-tools/haskell-tools/blob/master/src/experimental-refactorings/Language/Haskell/Tools/Refactor/Builtin/DollarApp.hs
21:55:31 <Axman6> https://github.com/haskell-tools/haskell-tools/blob/master/src/experimental-refactorings/haskell-tools-experimental-refactorings.cabal lists all the packages that package depends on, I would guess it;'s the references package which defined that module
21:56:31 <Axman6> https://hackage.haskell.org/package/references-0.3.3.1/docs/Control-Reference-Generators.html#v:biplateRef is where biplateRef comes from
21:57:12 <Axman6> it looks like it's some magic using the Biplate class, which lets you traverse every b within an a (this is pretty magic stuff)
21:58:04 <Ethan> ok, thankyou.  how did you find that?  Searching for "haskell Control.Reference biplate" comes up with nothign usefull for me
21:59:30 <Ethan> nvm, apparently google gets it but the search engine I was using did not
21:59:39 <Axman6> the first result for me when seartching for "haskell Control.Reference" is the references package, but I originally found that by looking at the cabal file
22:00:15 <Ethan> ok, so it seems like when in doubt go to the cabal file?
22:00:33 <Ethan> figure out where it comes from and then based off that look it up
22:00:55 <Axman6> just searching for the module name is usually enough to find the right package
22:01:13 <Ethan> yea thats whats worked for me previously
22:01:21 <Ethan> but it did not work for me this time
22:01:37 <Axman6> and if, as in the case of references, it's not directly in that module but one it reexports, go to the index for the package
22:02:04 <Ethan> ok
22:03:39 <Ethan> thank you for your help, I really appreciate it
22:08:24 * hackage hledger-lib 1.17.0.1 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.17.0.1 (SimonMichael)
