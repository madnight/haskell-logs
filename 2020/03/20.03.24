00:56:38 <whatatiming> :t ($) id
00:56:40 <lambdabot> b -> b
01:28:43 <siraben> @unmtl ReaderT r (Cont c) a
01:28:43 <lambdabot> r -> (a -> c) -> c
01:29:08 <siraben> @unmtl ReaderT r (Reader c) a
01:29:08 <lambdabot> r -> c -> a
01:30:34 <siraben> Heh, better just use Reader (r,c) a then
01:49:24 <iqubic> Yes indeed.
01:49:32 * hackage cobot-io 0.1.2.9 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.9 (zmactep)
02:54:32 * hackage hedis 0.12.13 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.13 (k_bx)
03:23:03 <reactormonk> I'm trying to figure out how to make a record which has functions for all elements of an enum (represented as ADT without fields). To make things more interesting, the functions also have different types depending on which enum it is. If a partial function would be fine, dependent-map would solve th problem rather nicely, but I need a total function.
03:23:32 * hackage cabal-cache 1.0.1.8 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.8 (haskellworks)
03:44:31 <smunix> reactormonk: can you elaborate more with an example ?
03:45:32 * hackage yesod-auth 1.6.10 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.6.10 (MichaelSnoyman)
03:53:56 <reactormonk> smunix, now that I think about it, passing a function around would be easier. But basically `data ADT = Foo | Bar` and then have `
03:53:57 <reactormonk> fun Foo = \x y -> x + y; fun Bar = \z -> z + 3`
03:54:49 <Taneb> reactormonk: surely that won't typecheck?
03:55:22 <Taneb> fun Foo :: Num a => a -> a -> a; fun Bar :: Num a => a -> a
03:56:00 <reactormonk> Taneb, yeah, that's where some advanced typing would come in
03:56:42 <Taneb> You could make ADT a GADT carrying the type you expect fun to return
03:57:02 <Taneb> Like data ADT a where Foo :: ADT (Int -> Int -> Int); Bar :: ADT (Int -> Int)
05:01:37 <smunix> reactormonk: {-# DataKinds, TypeApplications #-}
05:01:48 <smunix> reactormonk: import Data.Kind as K
05:02:20 <smunix> reactormonk: data E = Foo | Bar
05:02:33 <smunix> reactormonk: class Fun (e :: E) where
05:02:41 <smunix>   type family Fn e :: K.Type
05:02:56 <smunix> reactormonk:   type family Fn e :: K.Type 
05:03:13 <smunix> reactormonk:   fun :: Fn e
05:03:27 <smunix> reactormonk: instance Fun Foo where
05:03:47 <smunix> reactormonk:   type instance Fn Foo = Int -> Int -> Maybe Int
05:04:13 <smunix> reactormonk:   fun _ y = Just y
05:04:24 <smunix> reactormonk: instance Fun Bar where
05:04:39 <smunix> reactormonk:   type instance Fn Bar = String -> Maybe String
05:04:51 <smunix> reactormonk:   fun x = Just x
05:05:26 <smunix> reactormonk: then you can invoke this with 1) fun @Foo 1 2
05:05:47 <smunix> reactormonk: or 2) fun @Bar "well..."
05:07:08 <smunix> reactormonk: I believe you'd also have to enable -XTypeFamilies
05:08:30 <smunix> I also find that using GHC.TypeLits.Symbol makes for more readable type-level dispatchers (instead of ADT)
05:09:05 <dmj`> anyone know the status of the Haskell Suite of libraries (decompose GHC into libraries?)
05:09:14 <dmj`> and is Lemmih alive?
05:10:01 <smunix> reactormonk: if you're ready to trade your ADT with "foo" or "bar", which are Symbols defined at the type level, you'd be able to write : fun @"foo" 1 2 >> fun @"bar" "well"
05:31:25 <maerwald> when I race to threads, it seems I cannot distinguish why a thread was cancelled (e.g. it lost the race vs. an async exception happened, such as SIGINT)
05:41:12 <dmj`> maerwald: there is an AsyncCancelled exception
05:41:17 <dmj`> you can catch
05:41:26 <maerwald> Yes, but that doesn't let me distinguish
05:41:44 <maerwald> It happens for both "lost the race" and "SIGINT happened"
05:43:14 <aveltras> any idea why the following code wouldn't work ? Here i expect thread 18 to wait for thread 22 to reach its end. the logs "start" and "ends" are in the function "const f" at the end of withLock. I have a global map of MVar behind an ioref with tokens as keys
05:43:19 <aveltras> https://www.irccloud.com/pastebin/FkxERKq8/
05:43:36 <dmj`> well losing the race and SIGINT should both be cancel, a general async exception should not be able to be cast to AsyncCancelled
05:44:15 <maerwald> Well, then it appears the API doesn't let me do that
05:47:10 <dmj`> maerwald: you should be able to use fromException on the SomeException returned from waitCatch
05:50:57 <berndl> Does someone know a variant of foldl1 that takes a "default" value in case the list is empty?
05:52:03 <maerwald> foldl
05:53:22 <merijn> maerwald: So, just override SIGINT to not throw an exception? :p
05:53:53 <maerwald> merijn: I think I'll just not use async at all and emulate go-like channels with TVars, so I can signal a "cancel" from the other thread.
05:55:09 <berndl> maerwald: No, that's not going to work because the "default" will also be used in the nonempty case.
05:56:01 <maerwald> berndl: I don't think there's one then
05:56:18 <maerwald> just wrap your foldl1 then with a check
05:56:47 <berndl> I guess I can do something like foldl f (if null xs then default else head xs) xs
05:59:15 <merijn> "fromMaybe default . listToMaybe"
06:00:23 <maerwald> https://hackage.haskell.org/package/gochan aww
06:00:30 <maerwald> but seems not well maintained
06:02:18 <berndl> merijn: that's almost as long as the if statement.
06:02:35 <maerwald> But if feels always weird in haskell
06:03:10 <merijn> berndl: But no boolean blindness! ;)
06:04:20 <berndl> maerwald: how about bool?
06:04:45 <berndl> merijn: true that
06:05:16 <merijn> maerwald: How are your async threads getting async exceptions anyway
06:05:25 <merijn> maerwald: That sounds like you're doing something weird
06:05:32 <maerwald> Ctrl+c
06:05:49 <merijn> maerwald: No, Ctrl+c goes to the main thread
06:06:29 <merijn> maerwald: It does not go to random threads you spawned using async or forkIO
06:10:10 <dmwit> berndl, merijn: Won't both of those suggestions use the head twice when the list is non-empty?
06:10:23 <merijn> dmwit: Why?
06:10:33 <maerwald> merijn: when I hit ctrl+c, then my AsyncCancelled handler fires. So I suspect it does.
06:10:40 <dmwit> because foldl uses its second argument and its third argument in their entirety every time?
06:10:47 <merijn> maerwald: Presumably you're using async with exception forwarding
06:11:02 <merijn> maerwald: Some of the async brackets forward exceptions in the parent to the children to abort them
06:11:19 <berndl> dmwit: Ah, you're right. Crap.
06:11:39 <maerwald> yeah, it's impossible to reason about async behavior
06:12:06 <merijn> maerwald: Are you using async the library? Because that pretty explicitly documents what it does...
06:12:19 <maerwald> I'm using race only
06:12:49 <maerwald> It doesn't say anything about exception forwarding.
06:13:15 <berndl> I guess maerwald's suggestion about wrapping foldl1 with a check is the correct one.
06:16:07 <whataname> why stack put everything on aws?
06:16:31 <whataname> but aws is blocked on some countries, wth
06:17:24 <zceejkr> Hello everyone. If I have a multiparameter type-class, like so: class Field f => VectorSpace f v | v -> f where ...,
06:18:02 <zceejkr> and a function like so: vectorSpaceAdditionIsAssociative :: (VectorSpace f v, Eq v) => v -> v -> v -> Bool
06:18:43 <zceejkr> How do I do type applciation on the function? I tried vectorSpaceAdditionIsAssociative @(A B), but it does not work
06:19:04 <zceejkr> Says A should be of kind (* -> *)
06:19:12 <zceejkr> Which makes no sense to me.
06:19:14 <lyxia> what are A and B
06:19:54 <zceejkr> A has instance of Field, for be I have an instance VectorSpace A B
06:20:00 <zceejkr> for B*
06:20:01 <lyxia> vectorSpaceAdditionIsAssociative @A @B
06:20:45 <zceejkr> Thanks lyxia. This works
06:20:47 <zceejkr> :)
06:32:38 <iphy> what's the best way of running a readPrec parser on the result of another readPrec parser?
06:33:47 <iphy> concretely, I want to double-read a String
06:35:31 <iphy> more concretely, I actually want to make the "show" and "read" instances of https://hackage.haskell.org/package/iproute-1.7.9/docs/Data-IP.html behave well, so they produce quoted strings instead of naked IP addresses
06:35:42 <iphy> because naked IP addresses don't play well with Text.Groom
06:39:23 <iphy> for now, I've done read + readMaybe and fail on Nothing
06:44:26 <dmwit> berndl: For what it's worth, pattern matching seems strictly superior to an if for this. To me, at least, it seems so.
06:45:15 <dmwit> foldl1Def def f [] = def; foldl1Def def f xs = foldl1 f xs -- or something
06:45:39 <dmwit> foldl1Def df f = \case [] -> def; xs -> foldl1 f xs -- to avoid some repetition
06:46:21 <berndl> dmwit: Shame that we don't have a such a fold in the prelude.
06:46:27 <dmwit> Is it?
06:46:52 <dmwit> I think it's more likely a sign you haven't thought something through carefully. =P
06:47:02 * hackage dependent-sum 0.7.0.0 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.7.0.0 (3noch)
06:49:02 * hackage dependent-sum-template 0.1.0.3 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.1.0.3 (3noch)
06:53:40 <dmwit> aveltras: Did you get answered?
06:54:18 <aveltras> dmwit: no but im switching to file based locks now, seems a lot simpler and will prevent having huge maps of locks in memory
06:54:20 <dmwit> aveltras: If not, the interleaving is: 22 does atomicModifyIORef'; 22 does print; 18 does atomicModifyIORef' and all its stuff; 22 does withMVar.
06:56:36 <dmwit> You might consider STM.
06:56:37 <aveltras> dmwit: i didn't get how it's possible to be in the withMVar concurrently for 18 and 22
06:56:50 <dmwit> It is never in the withMVar concurrently for both 18 and 22.
06:56:54 <dmwit> oh
06:56:57 <dmwit> I misread the transcript.
06:56:59 <dmwit> Interesting!
06:57:11 <lally> Has anyone gotten proto-lens-setup to work with import paths?
06:57:40 <dmwit> oh, haha
06:57:52 <aveltras> im having issues now with http://hackage.haskell.org/package/filelock :) but at least it looks simpler
06:58:00 <dmwit> aveltras: In `Just (_, oldMVar') -> ...`, you almost certainly want `lockMap`, not `newMap`.
06:58:55 <aveltras> dmwit: the goal was to set the mvar if it wasn't already there
06:59:04 <dmwit> aveltras: In that branch, it *is* already there.
06:59:08 <aveltras> as i see it, it should stay in the ioref map even after the requests
06:59:42 <aveltras> ye, but the timestamp is updated
06:59:58 <aveltras> i set this up to be able to garbage collect locks based on access time
07:00:00 <dmwit> aveltras: Yes, but the MVar is *also* updated to a fresh one that nobody is holding...
07:00:29 <dmwit> aveltras: So if you want to update just the timestamp, you need a third map that has the new time but the old MVar.
07:00:59 <dmwit> aveltras: Just (_, oldMVar') -> (M.insert token (currentTime, oldMVar'), ...)
07:01:09 <dmwit> aveltras: Just (_, oldMVar') -> (M.insert token (currentTime, oldMVar') lockMap, ...) -- I mean
07:01:36 <Ariakenom> is this the same request & token protocol from a few days ago aveltras?
07:01:55 <aveltras> ye
07:02:15 <aveltras> haven't been blocked on it the whole time though :)
07:02:22 <aveltras> im trying to simplify the whole thing
07:02:36 <aveltras> https://github.com/aveltras/session-store in case anyone's interested
07:03:22 <dmwit> Anyway, what happens is: 22 creates an MVar and puts it in the map, then locks it; 20 creates an MVar and puts it in the map, but doesn't yet lock it; 18 creates an MVar and puts it in the map, then locks 20's MVar
07:03:26 <dmwit> aveltras: ^
07:03:46 <aveltras> dmwit: changing the Just case as you said seems to work ok
07:03:59 <dmwit> (20 creates an MVar and puts it in the map, but can't yet lock 22's MVar, I guess)
07:05:27 <aveltras> dmwit: your description fit my old code right ?
07:06:52 <Ariakenom> I did say removing old locks would be hard and suggested stm again :p
07:06:53 <aveltras> dmwit: ah yea now i get it
07:07:20 <aveltras> Ariakenom: sure, but im now thinking that simple file locks but fit better here
07:08:02 <Ariakenom> I dont think I know what that means
07:08:35 <aveltras> having a directory dedicated to file named after tokens and using http://hackage.haskell.org/package/filelock
07:08:48 <aveltras> that'd then be the only point having to deal with concurrency
07:09:43 <Ariakenom> ... how is that simpler?
07:09:46 <aveltras> dmwit: thanks for your help
07:09:54 <dmwit> cheers
07:11:15 <dmwit> I like STM, too, but I think it might actually be sort of hard to use in this case, just because `withMVar` already does the exception-handling thing and you'd have to reimplement that.
07:11:37 <dmwit> I mean, not hard. But tricky, and easy to get wrong.
07:11:47 <aveltras> seems the only thing i'd have to use here is http://hackage.haskell.org/package/filelock-0.1.1.4/docs/System-FileLock.html#v:withFileLock
07:12:23 <aveltras> doesn't work right now, seems to be locking something cause the whole thing gets stuck but then there's also the benefit of not having anything in memory to clean
07:13:24 <Ariakenom> but instead having something in the filesystem to clean?
07:13:57 <aveltras> not if i remove the lock file at the end of the requests
07:15:08 <Ariakenom> not to sound to too negative but thats what I said about the MVars last time
07:15:32 <Ariakenom> can you remove a file while holding the lock?
07:16:54 <aveltras> no but i can try to remove it after releasing the lock, should fail if another request has just taken hold of it and succeed otherwise
07:17:06 <aveltras> that's all theory for now
07:22:02 <Ariakenom> aveltras: I would suggest: insert the new mvar locked to begin with, delete the mvar before unlocking it.
07:25:33 <aveltras> Ariakenom: what do you mean by deleting it ? i'd need a second atomicModifyIORef here right ?
07:29:52 <Ariakenom> aveltras: make new mvar; withmvar {try to insert, if there is already a lock then block on it and then try to insert again, else run `f`; delete mvar;}
07:34:30 <aveltras> but then i still need 2 atomicModify if i get this right
07:34:37 <aveltras> and recursive call
07:35:24 <Ariakenom> yes
07:36:29 <aveltras> ye, i wanted to prevent having to many atomic write, as i understand it, this would lock the whole application
07:38:41 <Ariakenom> no, other things can run concurrently. using the filesystem would probably be much much slower
07:40:54 <asheshambasta> why is "a" not in scope here? https://gist.github.com/asheshambasta/67c53d21fccc89b55d1c0787998e6f67#file-arrow-hs-L3 
07:41:21 <MarcelineVQ> what's the go-to sqlite lib for haskell?
07:41:29 <dmj`> MarcelineVQ: sqlite-simple
07:41:35 <MarcelineVQ> thanks
07:41:35 <Ariakenom> only one thing at a time can access that map at the same time, but the inserts and deletes from it are a small part of your requests total time, compared to talking to database
07:41:36 <dmj`> @package sqlite-simple
07:41:36 <lambdabot> http://hackage.haskell.org/package/sqlite-simple
07:41:45 <dmj`> asheshambasta: is the extension enabled?
07:42:26 <asheshambasta> yes
07:42:38 <asheshambasta> (there are other arrow blocks in the same module that also compile)
07:43:39 <dmj`> asheshambasta: can you paste the full error, maybe restart your ghci session
07:44:06 <dmj`> sometimes errors get stuck in buffer in emacs haskell-mode
07:44:33 <sm[m]> whataname: where is aws blocked ? And are you able to report in the stack issue tracker ? That would be a good place
07:44:47 <asheshambasta> https://gist.github.com/asheshambasta/67c53d21fccc89b55d1c0787998e6f67#file-error 
07:45:13 <asheshambasta> restarting the repl/dante doesn't "fix" it. 
07:46:07 <aveltras> Ariakenom: going to try this
07:52:11 <asheshambasta> yeah, this looks really confusing. I've even tried explicitly instantiating a value using  `let` in the arrow do block, but I'm seeing the same issue.
07:53:18 <asheshambasta> https://i.imgur.com/jHN8mk9.png -- same results.
08:06:53 <dmj`> asheshambasta: https://mail.haskell.org/pipermail/beginners/2012-June/010114.html
08:07:33 <dmj`> asheshambasta: https://stackoverflow.com/questions/51525950/why-arrows-in-input-are-not-useable-in-arrow-commands-in-a-proc-block
08:10:52 <merijn> hmmm, time to master the fine art of "optimising a program with no obvious hotspots"
08:11:01 <aveltras> Ariakenom: that's what i ended up with, seems to work ok, i'll have to clean the now unneeded utctime  though, thanks for your input :)
08:11:05 <aveltras> https://www.irccloud.com/pastebin/3ExkTKxQ/
08:12:38 <Athas> GHC 8.10.1!
08:12:52 <Athas> "A number of improvements in code generation, including changes"
08:12:57 <Athas> Sounds good!
08:14:08 <cocreature> changes are the best kind of changes
08:15:05 <merijn> Can I somehow annotate expression for more fine-grained profiling?
08:15:50 <dmj`> merijn: isn't that what SCC comments are for
08:16:12 <merijn> dmj`: Those can only attach to bindings, though. Right?
08:17:00 <dmj`> docs say any haskell expression https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand
08:19:09 <dmj`> maybe it has to be bound though
08:19:54 <Ariakenom> aveltras: nice. 2 things. you will leave the lock locked on an exception, you can use iwthmvar around the outer takelock. and you arent blocking on th old mvar as far as i can see, it will work but you will chew cpu while waiting.
08:21:49 <glittershark> :q
08:21:55 <glittershark> oops
08:23:52 <asheshambasta> dmj`: thanks!
08:23:58 <dmj`> asheshambasta: np
08:24:17 <maerwald> What IOErrorTypr is "invalid argument"?
08:25:16 <dmj`> merijn: oh you can def. do this inline to any expression, and rename the cost centre to anything you want.  print $ {-# SCC last_xs #-} last xs
08:27:21 <dmj`> maerwald: I think that occurs when the file descriptor is closed and you attempt to read from it
08:27:28 <maerwald> I know
08:28:02 <maerwald> I want to know what IOErrorType it is
08:28:39 <dmj`> maerwald: ioeGetErrorType       :: IOError -> IOErrorType
08:29:08 <maerwald> I currently can't print to the console xD
08:30:34 <dmj`> maerwald: what'd you do :)
08:37:33 <whatatiming> is there any haskell IDE, which lsp server needn't compile?
08:40:36 <whatatiming> why those haskell project woundn't release binary program
08:41:10 <whatatiming> compiling is really killing time
08:41:16 <sm[m]> whatatiming: it depends on your definition of IDE. ghcid is good for getting error feedback. Lots of editors will do syntax highlighting and jump to tag and smart grepping. But no, there's no robust jump to definition/jump to uses without compiling a bunch of stuff
08:41:53 <sm[m]> except possibly one of the projects has recently or is working on providing a bunch of binaries. HIE ?
08:42:30 <whatatiming> HIE release binary file?
08:43:43 <sm[m]> I think alanz was talking about it. Try asking him, or their issue tracker
08:44:37 <sm[m]> https://github.com/haskell/haskell-ide-engine/issues/1383
08:44:54 <whatatiming> I tried to compile HIE a few hours ago, and it's huge, it's out of my disk space
08:45:07 <sm[m]> https://github.com/haskell/haskell-ide-engine/issues/1068
08:45:15 <Uniaika> Athas: just saw your comment on Reddit :P
08:48:08 <sm[m]> ooh! ImportQualifiedPost! finally something I can use :)
08:48:34 <Ariakenom> aveltras: I wrote an stm version for fun again https://gist.github.com/Ariakenom/546022ca68a9ca9a08a18d1e16443d1e
08:50:12 <asheshambasta> another arrow related question: can we nest "proc" blocks? 
08:50:41 <aveltras> Ariakenom: seems i ll try this cause im having trouble here with infinitly blocking on mvars
08:52:56 <fenedor> whatatiming, sm[m], binary releases do not yet work because some libraries use ghc-paths to find the libdir and that does not work with pre-compiled executables
08:53:01 <merijn> ugh...I feel this code should be faster, but I don't see any obvious hotspots :\
08:53:03 <Ariakenom> oh thats too bad
08:54:04 <sm[m]> fenedor: thanks
08:55:18 <fendor> however, I think we have some pre-compiled binaries and it works as long as you are not using brittany
08:58:07 <frdg> I am trying to use the :sprint command but ghci keeps telling me it can find the command. Do I need to use an import? For reference im using Haskell for Mac which I believe could be the problem.
08:58:12 <jumper149> I have a monad transformer stack `t m a` with `MonadError e (t m)`, but whenever I throw an exception the whole program exits immediately.
08:58:35 <whatatiming> I found this https://hub.docker.com/r/alanz/haskell-hie-ci
08:58:46 <fendor> whatatiming, that is ci
08:58:46 <whatatiming> what this docker is used for?
08:58:47 <merijn> jumper149: How are you throwing an exception?
08:58:49 <whatatiming> what is ci?
08:59:08 <fendor> continuous integration, it is for building the project on every commit 
08:59:16 <whatatiming> there's a compiled hie environment in that docker?
09:00:06 <fendor> that docker container contains all the tools required to build hie
09:00:38 <jumper149> I have the whole transformer wrapped in a newtype deriving (Monad, MonadError e, ...) and just use throwError in that Monad.
09:00:50 <whatatiming> so hie is still not been compiled?
09:00:55 <fendor> no
09:02:00 <jumper149> @unmtl StateT s (ExceptT e (ReaderT r IO)) a
09:02:00 <lambdabot> s -> ExceptT e (ReaderT r IO) (a, s)
09:02:14 <aveltras> Ariakenom: well well well... seems cleaner for sure :) 
09:02:19 <aveltras> https://www.irccloud.com/pastebin/7GiAwdQ9/
09:02:32 <merijn> jumper149: You still haven't mentioned *how* you are throwing these exceptions
09:02:41 <bahamas> whatatiming: I remembered being a nix setup for hie. and if you used cachix, you could also get pre-compiled binaries
09:03:09 <bahamas> whatatiming: https://github.com/Infinisil/all-hies
09:03:15 <frdg> I am trying to use the :sprint command but ghci keeps telling me it can find the command. Do I need to use an import? For reference im using Haskell for Mac which I believe could be the problem.
09:03:26 <jumper149> merijn: I'm using throwError. Doesn't that answer it?
09:03:29 <Ariakenom> aveltras: does it work?
09:03:48 <aveltras> Ariakenom: seems so according to my tests
09:03:57 <aveltras> had to create the tvar with newTVarIO
09:04:04 <aveltras> not sure what the big difference is
09:04:09 <whatatiming> https://atom.io/packages/ide-haskell-hie
09:04:14 <sm[m]> frdg: check which version of GHCI that's in, yours may be too old
09:04:19 <aveltras> https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TVar.html#v:newTVarIO
09:04:30 <whatatiming> bahamas is there a binary hie?
09:04:36 <whatatiming> this
09:05:00 <Ariakenom> aveltras: great, I hope you will forgive my nagging :)
09:05:28 <aveltras> Ariakenom: no problem with this at all :) thanks again
09:06:40 <sm[m]> nagging, the power behind FOSS and the world economy :)
09:08:27 <frdg> sm[m]: ya it seems haskell for Mac uses its own thing called "playground" that is different than ghci. I had assumed it was ghci as everything up to now had worked exactly the same in both ghci and playground. I will have to look into this thanks
09:09:16 <Ariakenom> aveltras: good good, you're welcome
09:13:24 <Ariakenom> aveltras: newTVarIO = atomically newTVar; with some minor differences we can ignore
09:16:47 <jumper149> @unmtl ExceptT e (StateT s (ReaderT r IO)) a
09:16:47 <lambdabot> ExceptT e (StateT s (ReaderT r IO)) a
09:20:25 <jumper149> @unmtl ErrorT e (StateT s (ReaderT r IO)) a
09:20:25 <lambdabot> s -> r -> IO (Either e a, s)
09:22:02 * hackage gjk 0.0.0.2 - Gilbert-Johnson-Keerthi (GJK) collision detection algorithm  https://hackage.haskell.org/package/gjk-0.0.0.2 (zaidan)
09:23:39 <jumper149> @unmtl StateT s (ExceptT e (ReaderT r IO)) a
09:23:40 <lambdabot> s -> ExceptT e (ReaderT r IO) (a, s)
09:23:49 <jumper149> @unmtl StateT s (ErrorT e (ReaderT r IO)) a
09:23:49 <lambdabot> s -> r -> IO (Either e (a, s))
09:28:48 <bahamas> whatatiming: that gives you hie binaries
09:31:27 <dmj`> how about that low latency garbage collector though
09:31:54 <dmj`> the all-new GC 5000
09:35:44 <whatatiming> bahamas I installed atom hie package, there's no hie binary in that package
09:36:27 <Ariakenom> dmj`: with speed stripes?!
09:36:39 <whatatiming> ~/ .atom/packages/ide-haskell-hie/ there's no hie binary file
09:37:02 <dmj`> Ariakenom: yep, limited time offer too. 4 easy payments of $399
09:37:03 <fendor> whatatiming, this is just a plugin
09:37:16 <fendor> you still need the executable
09:37:24 <whatatiming> fendor where I can get it?
09:37:44 <fendor> build from source, or use nix, which provides binary packages
09:38:10 <whatatiming> can I use nix on archlinux?
09:38:27 <whatatiming> nix is just package manager, not the nixOS right?
09:38:35 <MarcelineVQ> dmj`: comes with one phial of falmer-blood elixer, yours free
09:38:37 <fendor> yes and yes
09:39:23 <whatatiming> and why other package manager woudn't do that? like apt or pacman
09:40:31 * hackage sak 0.1.1.0 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.1.0 (vmchale)
09:41:05 <fendor> whatatiming, I think because the produced binaries from these package managers are not relocatable
09:41:19 <fendor> e.g. there are paths hard-coded in the produced executable
09:41:38 <fendor> you would have to patch those. Which is definitely possible but no one put in the effort
09:41:40 <{abby}> dmj`: Can I colour it red for extra speed?
09:42:01 <dmj`> {abby}: yes, but mind the warranty
09:47:02 <arianvp> is haskellstack.org broken for anyone else?
09:48:02 <Rembane> arianvp: Me too, just a blank page with broken certificate. Or no certificate.
09:48:36 <dmj`> arianvp: yep
09:50:21 <{abby}> Yeah, broken here too
09:57:37 <monochrom> Does GC 5000 come with RGB? :)
09:59:45 <dmj`> monochrom: that's the new model, the GC 5000 plus
09:59:58 <dmj`> monochrom: will cost you extra
10:05:28 * nshepperd2 . o O (coloured red and black, as a warning to predators as well as for O(log(n)) speed)
10:05:42 <monochrom> hehe
10:14:32 * hackage ghc-lib-parser 8.10.1.20200324 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.1.20200324 (shayne_fletcher)
10:15:32 * hackage ghc-lib 8.10.1.20200324 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.1.20200324 (shayne_fletcher)
10:31:01 <bsima> is is possible to make a unary operator?
10:31:48 <phadej> :t not
10:31:50 <lambdabot> Bool -> Bool
10:31:54 <phadej> > not True
10:31:56 <lambdabot>  False
10:32:30 <ChaiTRex> bsima: You can surround an operator with parentheses.
10:32:56 <ChaiTRex> > let (&&&&) x = x + 1 in (&&&&) 5
10:33:00 <lambdabot>  6
10:33:17 <Ariakenom> also this but I suggest you dont use it https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
10:33:31 <sm[m]> arianvp: that worked for me just now
10:33:56 <arianvp> ah it seems back now
10:33:57 <arianvp> cool
10:38:34 <infandum> Does anyone use static-haskell-nix? I'm trying to build a binary with static-haskell-nix from a stack project but I'm running into issues with p11-kit.
10:40:11 <maerwald> unix does not expose 'select', so how do you figure out if a file descriptor has data available?
10:40:51 <monochrom> I might expose select myself.
10:41:36 <monochrom> That's a last resort.  More often I try to give the fd to a Handle, then use multithreading to wait on it.
10:42:24 <monochrom> Personally last time I tried to use select directly in C I realized I was implementing my own multithreading scheduler.
10:42:38 <monochrom> My own green threads.
10:42:55 <monochrom> even s/implementing/reinventing/
10:43:06 <monochrom> When that happens you know you need to move on.
10:43:14 <bsima> Ariakenom / ChaiTRex: what i really want is a prefix operators extension
10:43:29 <monochrom> I almost inflicted it as an assignment on my poor 2nd year students.
10:44:03 <maerwald> monochrom: we have 'threadWaitRead', which waits until data is available. Would be natural to have one that waits until the Fd hits EOF, imo
10:44:46 <monochrom> "Write a file server. Multiple concurrent clients. If a client isn't responsive, you must not starve other clients."
10:45:09 <maerwald> Especially when you have a separate thread doing the logging and you don't want to kill it too soon, even if the producer side already has finished.
10:45:13 <monochrom> I think threadWaitRead is also for EOF?
10:45:31 <monochrom> I mean EOF doesn't happen until someone tries to read.
10:45:32 * hackage cron 0.7.0 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.7.0 (MichaelXavier)
10:45:54 <maerwald> So the producer finishes... then I want to wait until there's really nothing in the pipe anymore and then kill the logging thread.
10:46:56 <maerwald> The logging thread itself cannot react on EOF, because it doesn't know whether the producer is just waiting or has finished.
10:48:17 <maerwald> Could just do threadDelay 1000 and move on with my life
10:48:44 <maerwald> But my OCD won't let me.
10:50:11 <MarcelineVQ> if it's not perfect what is the point even
10:50:50 <maerwald> https://github.com/haskell/unix/blob/63a560bf26a052d381cc0662baf2a25e0f3ddc5d/System/Posix.hs#L121
10:51:40 <monochrom> Look IIRC it's the same with select.  When EOF happens, select only tells you "ready for reading". So you go read and boom EOF hits you.
10:52:04 <monochrom> I bet threadWaitRead behaves the same.
10:59:47 <maerwald> I'm just gonna abuse the exception handler in the logging thread to carry out the last reads, hehe
11:00:18 <maerwald> If that fails, nothing can save us
11:00:42 <ggVGc> nothing can save us either way
11:01:42 <fendor> can I add a run-time check for integer over-/underflow?
11:01:48 <fendor> in plain ghci
11:03:15 <monochrom> I think no.
11:05:32 * hackage org-mode-lucid 1.3.0 - Lucid integration for org-mode.  https://hackage.haskell.org/package/org-mode-lucid-1.3.0 (fosskers)
11:08:31 <zincy_> Is there a way to prevent a forked thread dying with async
11:08:48 <zincy_> I have this thread and I am trying to print 8 lines to std out
11:08:57 <zincy_> and it only ever makes it to 4 
11:09:01 <dmwit> Depends why it's dying.
11:09:12 <maerwald> This sounds like we want to see code :>
11:09:19 <monochrom> You can only prevent someone else kiling it, by deleting code that kills it.
11:09:25 <dmwit> Probably, given how vague the question is, it's because you didn't know that Haskell programs exit when the main thread exits, and you can fix it by holding the main thread open longer.
11:09:30 <monochrom> If I decide to die, no one can stop me.
11:10:47 <monochrom> I mean, what a strange question.  "The restaurant is closing. Which function call do I make to prevent that."
11:11:31 <zincy_> makeVaccine()
11:11:36 <monochrom> haha
11:12:01 <maerwald> What if you're Erlang and you just get respawned?
11:12:25 <monochrom> respawning has dying as a precondition
11:12:53 <monochrom> Tangentially this is a plot point in a robot story from Asimov.
11:13:24 <maerwald> I was thinking of altered carbon, lol
11:13:30 <zincy_> Okay I know it was a dumb question :D
11:13:33 <maerwald> Imagine the thread gets double sleeved
11:13:40 <zincy_> Everyone behaves irrationally in times like these
11:13:52 <zincy_> https://gist.github.com/therewillbecode/fea4a5c2437ea5b15018c4860cf5ba07
11:13:59 <maerwald> Respawning without dying... well, that's basically forking.
11:14:14 <monochrom> Ah.
11:14:41 <maerwald> zincy_: that's like 500LOC, what are we looking at
11:14:46 <monochrom> This is very long.
11:14:47 <zincy_> So line 120 in that gist is the issue
11:15:08 <zincy_> Yeah but as people say it needs to be reproducible
11:15:12 <monochrom> It's never the issue.
11:15:18 <zincy_> So I should have linked all the code :D
11:15:44 <zincy_> And ill give you the position of the sun in the sky too and the humidity
11:15:56 <monochrom> If a thread is just calling "print", it is not going to kill itself right there.  Clearly.
11:16:50 <monochrom> Either some other code in the same thread says "I'm done, I'm not looping back", or some other code in some other thread kills this thread.
11:16:51 <zincy_> So line 90 is where that function playBot is used
11:17:54 <zincy_> Pipes concurrency has mailboxes
11:18:12 <zincy_> So there are two here that receive game states
11:18:28 <zincy_> They are both running in child threads
11:18:37 <monochrom> Where is your main?  I want to know that what dmwit said is ruled out.
11:18:45 <maerwald> you link both async threads it seems
11:18:48 <zincy_> So the only way either of them should be dying is if main kills them or dies
11:19:08 <maerwald> "Link the given Async to the current thread, such that if the Async raises an exception, that exception will be re-thrown in the current thread"
11:19:34 <maerwald> so if 'a' dies, what happens to the main thread?
11:19:41 <maerwald> you have 'a' and 's'
11:20:43 <zzo38> Did they change sequence for working with Applicative instead of Monad? Hopefully they should if it isn't already
11:20:45 <zincy_> setUpTablePipes is run in a thread forked off main
11:21:03 <maerwald> If a dies, main thread dies, then s dies, no? You're not catching any of it
11:22:15 <maerwald> can you check if a dies? 
11:22:29 <maerwald> Basically... figure out what dies first lol
11:22:49 <maerwald> flip finally (print "I died") ...
11:23:00 <maerwald> or onException
11:23:39 <zincy_> Should I be linking all the things or finally all of them to identify what dies first?
11:24:34 <monochrom> zzo38: I think yes, for a while now.
11:24:38 <monochrom> % :type sequence
11:24:39 <yahb> monochrom: (Traversable t, Monad m) => t (m a) -> m (t a)
11:25:05 <monochrom> Oh darn, I misremembered, but don't worry, they use a new name:
11:25:07 <maerwald> zincy_: why link :o
11:25:12 <maerwald> makes everything just more complicated
11:25:13 <monochrom> % :type sequenceA
11:25:13 <yahb> monochrom: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:25:18 <monochrom> There! Use that.
11:25:22 <atif> I have a program that loads in ghci without errors but hangs when executing putStrLn.  I've tried using BangPatterns but it didn't seem to help.  How to debug such issues?
11:25:24 <zincy_> doesn't link propagate exceptions to another thread>
11:25:28 <maerwald> Yes
11:25:47 <maerwald> I'd put a finally/onException around all my async/forkIOs etc
11:25:57 <zincy_> So if i send my exception that kills to the child to main I can identify what the issue is no?
11:26:23 <maerwald> I feel there should be tooling that helps with thread debugging. Yes, an IDE.
11:26:28 <monochrom> Yes but where is your main and how do you know it's catching exceptions properly.
11:26:46 <zincy_> Ugh I don't know much about exceptions
11:26:58 <zincy_> So an exception unhandled kills a thread right
11:27:01 <maerwald> You will soon, because you're already feeling the pain
11:27:05 <zincy_> :D
11:27:06 <monochrom> OK that means you wrote no code to catch exception and look at it.
11:27:17 <zincy_> Correct
11:27:18 <monochrom> So it's all a day dream.
11:27:23 <maerwald> :D
11:28:13 <fendor> atif, putStrLn fails on some value?  Or when does it hang?
11:28:38 <monochrom> "I don't know much about how to treat knife wounds, I just know it's somehow possible, so I'll stick the knife into you anyway"
11:28:55 <atif> I'm not sure I understand what you mean by 'when does it hang'?
11:29:03 <zzo38> monochrom: O, OK. (Although I am not sure I like the name "sequence", but I don't know of any better name, so perhaps it is OK.)
11:29:31 <atif> It just puts a [ and then hangs.  CPU/memory usage is almost 0.
11:29:42 <atif> so not sure what it is trying to do.
11:29:54 <monochrom> I like the name "sequence", or any derivative of "sequential", because the alternative is "dependent" which is even more obscure.
11:30:32 <monochrom> Basically it's dependent/sequential composition vs independent/parallel composition.
11:30:43 <monochrom> (data dependency)
11:31:19 <zincy_> monochrom: Is it fair that people describe  monad vs applicative that way?
11:31:20 <zzo38> monochrom: Yes, that is what I am saying that I don't know of the better name, "dependent" is worse than "sequence".
11:31:45 <zincy_> I can kind of see it but it feels weird
11:32:28 <monochrom> Trivia: GHC uses "World -> (World, a)" for IO because it uses data dependency to trick code generator into obeying sequential execution.
11:32:55 <fendor> atif, what are you trying to print? But sounds like you are trying to print a list and the first element is evaluated recursively. 
11:33:03 <zincy_> what is data dependency?
11:33:10 <monochrom> The "World" there is a phantom type.  No runtime representation at all.  Not even in cmm.
11:33:15 <fendor> > let x = x + 1 in [x]
11:33:19 <lambdabot>  [*Exception: <<loop>>
11:33:34 <monochrom> zincy_: Yes because I do it.
11:33:41 <fendor> in this case, the run-time detected that it will loop endlessly
11:33:43 <atif> That is correct.  It is a list that is evaluated recursively.
11:33:54 <zincy_> The world is a phantom type - sounds like a post apocalyptic scifi film
11:34:23 <monochrom> This is why meaningful names are misleading.
11:34:41 <monochrom> It's really PhantomToken -> (PhantomToken, a)
11:35:15 <zincy_> I call it pragmatic
11:35:38 <monochrom> But pragmatic practices could use more honest names.
11:35:47 <fendor> atif, so, computation of the first element either never finishes or takes a reeeally long time
11:35:51 <zincy_> Why do people make their own versions of garden variety functions and give them cute businessy names
11:36:06 <zincy_> like getMyAge = const 5
11:36:07 <monochrom> In my book it is not pragmatic to propagate superstition.
11:36:29 <{abby}> zincy_: GHC enforces ordering by having all¹ I/O actions depend on the state token that the previous action returned (¹: we don't talk about unsafeInterleaveIO)
11:37:08 <{abby}> Wait, actually, let's talk about unsafeInterleaveIO. IO (\s -> let r = case m s of (# _, res #) -> res in (# s, r #))
11:37:40 <{abby}> Since the result of the overall action doesn't depend on the state token returned by the inner action (the 'm s') bit, it's only executed when the actual result is demanded
11:38:12 <zincy_> interesting.
11:39:53 <{abby}> The only function of State# is to keep execution order honest by making later actions depend on a token returned by earlier actions; That way, even you don't depend on the result of an action (say, because it's ()), you still need to force it to keep going
11:40:19 <atif> If I unparse the recursive function and do first iteration it all computes very quickly.
11:40:47 <atif> How can I debug such issues?
11:41:17 <monochrom> And this is because the code generator and various optimizations are designed for non-strict semantics and wantonly re-order things whenever no perceived data dependency.
11:41:57 <monochrom> So when compiling IO or ST code you need to put in a fictional data dependency to preserver order.
11:41:57 <{abby}> Well, the idealised execution model of Haskell would do it too (graph reduction)
11:42:06 <monochrom> The alternative is to write a second code generator.
11:43:12 <monochrom> atif: Unit testing?
11:43:44 <monochrom> If you have code that includes a line "print foo", surely you would have various tests for "foo" alone?
11:44:35 <monochrom> Basically I don't understand, or maybe I'm looking at it wrong, how most of you can allow your code to grow to 500 lines and during the whole process apparanetly you tested nothing.
11:45:12 <{abby}> Very stringent types? :P
11:46:27 <monochrom> Q: "How do I debug?"  My answer: Don't debug? For every additon of 10 lines, you increase one more unit test and update your integration test?
11:47:02 <{abby}> Surely those unit tests could all become one property test
11:48:12 <monochrom> I'll mince words and say property-oriented testing is a way to do unit tests and integration tests.
11:48:57 <dmwit> BuT iF iT cOmPiLeS iT mUsT wOrK
11:49:13 <monochrom> :)
11:49:21 <{abby}> If it compiles and it doesn't work, Clearly, you're not using enough Types
11:49:53 <dmwit> I don't think I've met the type yet that didn't permit a sufficiently idiotic dmwit to write a bug.
11:49:54 <atif> but if the function is not evaluating your unit test will hang.  since I'm testing the function for an input.
11:50:16 <monochrom> dmwit: Meet my friend Int. :)
11:50:31 <dmwit> monochrom: hahaha, bugs... bugs EVERYWHERE
11:51:00 <{abby}> The other day I had a typo in one of my type definitions, it was quite embarrassing. 
11:51:37 <monochrom> Yikes. Could also be hard to find.
11:52:23 <Ariakenom> > abs minBound :: Int
11:52:28 <lambdabot>  -9223372036854775808
11:52:39 * {abby} blinks.
11:52:40 <Ariakenom> lgtm shipit
11:53:52 <dmwit> > negate 9223372036854775808 :: Int -- when bugs cancel out
11:53:55 <lambdabot>  -9223372036854775808
11:54:31 <monochrom> More infamous one:
11:54:37 <monochrom> > round (1/0) :: Integer
11:54:40 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:55:30 <Ariakenom> dmwit, nice
11:55:59 <{abby}> I don't think I'm ever touching a number again after this
11:56:59 <maerwald> Stop scaring the kids
11:57:38 <monochrom> Would you prefer strings then? >:)
11:57:40 <maerwald> People breaking integers, they did that a few days ago. It's becoming a habit
11:57:52 <maerwald> monochrom: please no.
11:57:53 <{abby}> monochrom: Neither, really, I'd rather use Bound :p
11:58:13 <monochrom> No, it's me too a few days ago. Don't worry it's not infectious, it's just me all along.
11:58:30 <maerwald> Next thing is you're gonna tell me time is not linear...
11:58:48 <monochrom> If you find numbers and strings both dirty, consider church numerals as an alterantive. >:)
11:59:02 <JohnTalent> > rount(1/10) :: Integer
11:59:05 <lambdabot>  error:
11:59:06 <lambdabot>      • Variable not in scope: rount :: Double -> Integer
11:59:06 <lambdabot>      • Perhaps you meant one of these:
11:59:12 <{abby}> maerwald: People tend to think of time as a linear progression from cause to effect, but in reality it's more like a big ball of... wibbly-wobbly.. timey-wimey.. stuff.
11:59:27 <smunix> > :t 1
11:59:30 <monochrom> Hey maerwald, have you heard of branching-time logics such as CTL (computational tree logic)? >:)
11:59:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:00:37 <monochrom> Edmund Clarke won a Turing Award for that (and related work)
12:00:42 <maerwald> {abby}: https://gist.github.com/timvisee/fcda9bbdff88d45cc9061606b4b923ca already posted here several times, but still nice
12:01:28 <{abby}> Thankfully I'm just a hobbyist (and I don't aspire to be a developer, either, I'd rather stay in comfy academia) and my hobbies steer very clear of the real world
12:01:56 <maerwald> "What time zone are black holes?" -- uhm yeah
12:02:07 <monochrom> haha
12:02:18 <SquidDev> That feels very apt given the Doctor Who quote.
12:02:44 <JohnTalent> > round(1/10) :: Integer
12:02:50 <lambdabot>  mueval-core: Time limit exceeded
12:03:12 <monochrom> Try again.
12:03:17 <JohnTalent> > round(1/10) :: Integer
12:03:21 <lambdabot>  0
12:03:38 <{abby}> "There is a leap year every year divisible by 4." This surprises me, I'd assumed most would know it's divisible by four, not divisible by 100, except when divisible by 400?
12:04:13 <JohnTalent> What kind of chip does lambdabot run on? ... A dorito?! XD
12:05:18 <Ariakenom> not a fan of that list. too many non-interesting and some that are reasonable assumptions
12:08:12 <aviD> I need a favor from anyone who has ghcide working with cabal 3.  Please clone this repo github.com/TomMD/ghcide-examples and post the output of running ghcide in `broken-single-target-project-dot-cabal-with-hackage-deps`. Thanks
12:16:46 <dmwit> Is the "A month always begins and ends in the same year" thing about time zones or what?
12:17:04 <dmwit> Also, what programmer believes "February is always 28 days long."??
12:17:53 <monochrom> I think not so much believe but more "simplifying assumption because my program will only run for 2 days"
12:18:27 <monochrom> So the real wrong belief is "no one will use my program for real, 10 years from now, 24/7/365/whatever"
12:18:57 <monochrom> But that gets too meta.
12:19:22 <monochrom> No no no, the really too meta is: the real wrong belief is "I'm a good programmer". >:)
12:19:31 <maerwald> dmwit: If you freeze your VM and start it up again a year later maybe?
12:20:55 <dmwit> I look forward to seeing the counterexample to "The software will never run on a space ship that is orbiting a black hole.".
12:20:55 <maerwald> Time is a mutable resource. Everything now is broken anyway. Go home.
12:20:59 <monochrom> That only falls under "computer clock time is real world time"
12:21:44 <monochrom> OK also "computer has only one clock"
12:23:34 <maerwald> How about we just measure the increase in entropy and forget about time
12:24:19 <monochrom> How to?
12:24:45 <maerwald> Some physicist will figure it out
12:24:58 <maerwald> I'm just giving the ideas here!
12:25:21 <monochrom> It will be expensive.  Last time they re-defined mass, they spent millions of dollars building a prototype.
12:25:40 <monochrom> A ball of silicon.
12:26:55 <monochrom> Also something says there will be a correlation vulnerability of your clock is based on entropy sensors and your secure PRNG is also based on entropy sensors...
12:27:13 <monochrom> Actually s/something says/I feel that/  # It's just my hunch
12:27:32 <monochrom> s/of your clock/if your clock/
12:28:48 <monochrom> Also I think our clocks are already measuring entropy increase.
12:29:25 <monochrom> The whole problem is not in the definition of the second.  The problem is in the longer units such as "day" and "year".
12:29:57 <{abby}> The definitions of SI base units require a Ph.D. in physics to understand, anyway
12:30:17 <maerwald> I wouldn't mind getting rid of weekdays. For starters.
12:30:51 <maerwald> Everyone should just think in unix time...
12:32:02 <monochrom> I'm bad at math.
12:34:02 * hackage language-ats 1.7.10.1 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.10.1 (vmchale)
12:35:06 <nshepperd2> earth is sort of a space ship that is orbiting a black hole
12:35:26 <nshepperd2> really far away from it though
13:22:09 <frdg> I know im preaching to the quire...but im really starting to see how powerful Haskells type system is. You know everything about everything
13:22:39 <maerwald> Oh. I remember those times where I felt enlightened
13:22:50 <maerwald> Now everything is dark...
13:22:54 <frdg> lol
13:23:07 <{abby}> To the choir
13:23:29 <[exa]> what's the best looking way to write numbers with units in haskell source? Constructor style: 2 centimeters ==  `Cm 2`, any way to write it more like `2 cm` ?
13:24:36 <[exa]> (the other solution I have now: `L 2 cm`)
13:24:38 <{abby}> instance Num a => Num (Unit -> a) where { fromInteger x unit = _ }
13:25:30 <[exa]> {abby}: I'd love `1 in` and `2 cm` and others be different
13:25:50 <[exa]> uuuuh okay I misread that
13:26:06 <[exa]> cool.
13:26:07 <[exa]> thanks :]
13:33:32 * hackage asn1-types 0.3.4 - ASN.1 types  https://hackage.haskell.org/package/asn1-types-0.3.4 (VincentHanquez)
13:47:03 <kolu> Can someone tell me what happens to a data structure when the program ends? Is it immediately erased from memory?
13:47:32 <kolu> Does it stay until something overrides it
13:47:42 <kolu> What happens
13:49:20 <hpc> it goes away
13:49:50 <hpc> the only thing that sticks around after a program ends is anything it's done is stuff like saving files to disk
13:57:34 <tommd> kolu: At what level are you talking?  Many OSes do not zero freed memory.  If you are getting into security research then the answer is no - memory is not gratuitously zeroed by the GHC RTS, it is merely yielded back to the operating system.
14:00:30 <kolu> hmm
14:00:48 <kolu> tommd
14:00:52 <kolu> just really basic stuff
14:01:03 <kolu> a script that puts some value inside a list
14:01:10 <kolu> the ends
14:01:15 <kolu> then*
14:08:43 <maerwald> Is there a high-level API to catch SIGINT?
14:09:20 <maerwald> As in: not catch async exceptions in general, only SIGINT
14:10:12 <ClaudiusMaximus> [exa]: in is a keyword.  maybe you could do suffix sections (2 `cm`) (needs brackets and probably a language extension)
14:10:39 <ClaudiusMaximus> > let in = in in in 
14:10:43 <lambdabot>  <hint>:1:8: error:
14:10:43 <lambdabot>      parse error on input ‘=’
14:10:43 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:10:48 <hpc> maerwald: one of the packages orbiting unix/posix has a nice interface to it, i am sure
14:11:15 <hpc> unix or posix has a global handler you can set, i know that much
14:11:28 <maerwald> Well, that's low-level, yeah. And I have no idea how that interacts with other things from GHC (exceptions during the signal handler)
14:13:32 * hackage ghc-lib-parser-ex 8.10.0.0 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.0 (shayne_fletcher)
14:14:35 <jumper149> Is there a monad, that let's me have a state in IO. This monad should let me access this state by reference and handle read/write access regarding multiple requests that can occur concurrently.
14:15:23 <hpc> you probably want MVar, or something derived from it
14:15:38 <hpc> or STM
14:15:58 <hpc> depends on if you want locking or transactional behavior
14:16:14 <hpc> STM's probably easier to avoid making mistakes with
14:16:19 <jumper149> hpc: What do you mean by transactional
14:18:39 <hpc> basically, you take two operations that wouldn't otherwise be atomic, but happening at the same time with the same resource
14:18:53 <hpc> say one is incrementing a variable and another is decrementing it
14:19:01 <dmwit> Say you have two maps. You want to move some key-value pair from one map to the other.
14:19:07 <hpc> the reads and writes might line up in a way that the variable stays incremented, or decremented
14:19:09 <dmwit> Non-transactional: delete from the first map, insert into the second map.
14:19:21 <dmwit> Other threads may observe the key being in neither map.
14:19:42 <hpc> if both were transactions, at the end of increment it would see that the value has been decremented, and actually saving it would break things
14:19:49 <dmwit> Transactional: instruct the runtime that the deletion and insertion either both happen or neither happen. Other threads may never observe the key being in neither map.
14:19:49 <hpc> so it retries from the beginning
14:20:54 <hpc> with a locking behavior, once it starts decrementing the other thread wouldn't be able to start incrementing
14:21:21 <hpc> and if something bad happens and the first operation never releases its lock, the program never advances
14:21:45 <hpc> or like in dmwit's example, one thread goes "lock map A, then lock map B, then do stuff, then unlock"
14:21:51 <hpc> and another thread locks B before A
14:22:03 <hpc> then you can have two threads with one map locked each, never able to get anywhere
14:26:51 <jumper149> This problem can only occur when I have multiple mutable variables right?
14:27:22 <{abby}> when you have multiple threads working with a single variable, too
14:28:41 <jumper149> I'll look into STM and MVar and will try to understand the difference first. The general problem with locking variables is clear to me.
14:36:32 * hackage tree-sitter 0.9.0.1 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.9.0.1 (rewinfrey)
14:37:08 <jumper149> I think MVar is exactly what I'm looking for, ty :)
14:44:24 <monochrom> maerwald: You can use catchJust or tryJust to restrict to the UserInterrupt case of AsyncException so other cases are passed through.
14:45:39 <maerwald> Right, I forgot AsyncException isn't just an empty data decl
15:04:18 <MarcelineVQ> newhoggy: I'm trying to parse json a value (with waargonaut) that can take the form of both  "id":30  and  "id:"30"  and I want them both to end up as Int. I don't really want to parse the latter as Text and then convert it to Int myself when there's a perfectly good Int parser/decoder in waargonaut already. Is there a direct way to treat "30" as 30 or some other simple way to handle this case?
15:05:32 <MarcelineVQ> newhoggy: oops for some reason I thought you did waargonaut, maybe due to the hw dependencies, pardon me if you're unrelated :>
15:08:39 <newhoggy> mankyKitty is who you want :D
15:09:05 <newhoggy> mankyKitty: Ping
15:14:42 <ryan_> \quit
16:11:32 * hackage PyF 0.9.0.1 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.9.0.1 (guibou)
16:15:46 <Axman6> jumper149: an IORef and appropriate use of atomicModifyIORef can alsoerform very well in the presence of lots of readerand a few writers - any immutable data structure can be turned into a concurrent one with atomic updates quite easily this way and avoid blocking associated with MVars
16:16:35 <monochrom> Yes that's what I do in a program. I needed only one shared priority queue.
16:17:02 <Axman6> I've used it a few times with pretty good success
16:17:11 <Axman6> man english is hard
16:17:34 <monochrom> Nothing says every internal node in the priority queue must be mutable.  Only a mutable pointer to a "current" immutable version.
16:17:54 <monochrom> This is also what Clojure people do.
16:19:02 <monochrom> Elaborate sophisticated mutable lock-free shared data structures are way overrated and extremely niche.
16:20:06 <Axman6> Agreed - I can never find the paper by one or both of the simons looking into concurrent structures implemented in Haskell,m and settling on the one-IORef pattern
16:22:59 <jumper149> I already implemented the MVar approach and have to say it was quite nice :)
16:23:33 <Axman6> I only opt for MVars when I know I need to block other threads
16:23:43 <Axman6> MVars are a synchronisation mechanism
16:26:04 <Axman6> newtype ConcurrentMap k v = CM (IORef (Map k v)). insert (CM ref) k v = atomicModifyIORef' ref (\mp -> (Map.insert k v, ()). lookup (CM ref) k = Map.lookup k <$> readIORef ref
16:27:05 <dsal> Been writing some elm and asked for some elm community people to look at my code.  They suggested I run elm-format for the standard formatting.  It's not quite as bad as dhall, but people really like massive amounts of whitespace in their code.   'let' and 'in' are always on their own lines.  Thing being defined is never on the same line as the definition.   'Just d -> d' split across two lines...
16:27:08 <dsal> People must have very large screens.
16:27:13 <Axman6> the functions inside atomicMpdifyIORef can be arbitrarilly complex but will always be executed atomically, with other threads blocking on lazy evaluation
16:54:39 <hexagoxel> dsal: we had a `bool` function equivalent just to avoid the whitespace of if-then-else. Even though that is strict :/
16:55:20 <monochrom> No it's no more stricter than if-then-else.
16:55:40 <hexagoxel> (talking about elm)
16:55:53 <monochrom> oops
16:56:03 <hexagoxel> my fault
16:57:09 <hexagoxel> (the rule is that talking about other languages is fine, as long it is ranting, right?)
16:57:34 <monochrom> Yes, no worries.
16:58:03 <hexagoxel> :p
17:06:29 <dsal> hexagoxel: It sounds like they're going to relax a bit.  I can't deal with too many single-character lines.  heh
17:08:07 <dsal> Haskell's `bool` feels a bit like `id` in that it seems dumb until that time where it makes something a bit easier.
17:11:17 <jackdk> `id` seems significantly less dumb once you take the "ohhhh this is why zero is useful" and convince people to generalise that idea
17:21:58 <MarcelineVQ> mempty is a silly name still
17:22:15 <monochrom> mzero was taken
17:22:22 <oats> oh that named caused me great confusion when I stumbled across it :P
17:22:25 <Axman6> m'zero wasn't though
17:22:28 <monochrom> I guess you have midentity in mind, yeah that would be good.
17:22:56 <MarcelineVQ> mneutral
17:22:56 <Axman6> m'identity
17:23:10 <monochrom> What's the binary operator again? I can't remember it, <> is so much easier.
17:23:34 <MarcelineVQ> mplus
17:23:47 <monochrom> I thought Oleg-style ' was out of fashion.
17:23:50 <monochrom> @type mplus
17:23:53 <lambdabot> MonadPlus m => m a -> m a -> m a
17:23:56 <monochrom> :)
17:24:23 <monochrom> OK yahb, who's the companion of mempty?
17:24:29 <monochrom> % :info Monoid
17:24:30 <yahb> monochrom: class Semigroup a => Monoid a where; mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a; {-# MINIMAL mempty #-}; -- Defined in `GHC.Base'; instance Monoid BS.ByteString -- Defined in `Data.ByteString.Internal'; instance Monoid BSL.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance [safe] Applicative f => Monoid (Traversed a f) -- Defined in `Control.Lens.Internal.Fold'; ins
17:24:35 <monochrom> mappend
17:25:50 <monochrom> Can we have a bot whose prompt is like "Yo bot" so it's more like "ok google" and "hey siri"?
17:26:00 <oats> ah, it's defaulted to <>
17:26:03 <oats> <> is nice
17:26:04 <monochrom> (Is "hey siri" the siri prompt?)
17:26:33 <oats> if I had any talking devices, I would want them to respond to an authoritative "Computer," with a british accent
17:27:01 <MarcelineVQ> I'd want mine to respond to a bad scottish accent
17:27:11 <monochrom> You also need to pick up your mouse and say that to your mouse :)
17:27:17 <MarcelineVQ> indeed :>>
17:27:24 <oats> hehe
17:28:11 <oats> :»
17:29:10 <Axman6> monochrom: Apple are pretty big on privacy, so they've made the Siri activation phrase: Excuse me Siri, may I have some assistance please?
17:29:18 <monochrom> My thesis supervisor has or had a Mac Classic.  I should acquire it and retrofit it to support that!
17:29:26 <Axman6> so it activates less frequently
17:29:56 <dsal> Names are hard.  I like fmap and mempty and such.  Not the names, but they do the thing.
17:30:10 <MarcelineVQ> fmap's real name is jacob
17:30:34 <oats> lol
17:30:38 <dsal> What's weird, is that elm calls it `map` and *that* confused me.
17:30:48 <oats> hah
17:31:04 <oats> is there a reason plan 'ole map isn't generalized to all functors?
17:31:15 <dsal> It breaks an app somewhere.
17:31:42 <monochrom> I agree with a longer prompt reducing false positives, but the "excuse me" part comes across as insulting users.  Is it true that Steve Job is now living in Siri so that's why you have to beg it for service? >:)
17:32:06 <MarcelineVQ> not especially compelling reasons if you know fmap already. if you don't then fmap has a more daunting type and type errors to read
17:32:52 <monochrom> + being Num and length being Foldable already cause a lot of beginners a few uphill battles.
17:33:30 <monochrom> And some mean souls even recommend beginners to turn on OverloadedStrings
17:34:02 * hackage life-sync 1.1.0.0 - Synchronize personal configs across multiple machines.  https://hackage.haskell.org/package/life-sync-1.1.0.0 (shersh)
17:34:07 <oats> OverloadedLists is where it's t
17:34:08 <oats> *at
17:34:15 <oats> gosh I can't type today
17:35:52 <monochrom> "Oh great Siri, I'm a humble fan of yours, pray would you show me mercy and assist me? btw please don't propell this phone to hit me"
17:36:49 <monochrom> "thy monopoly come, thy will be done"
17:37:37 <monochrom> "my money is yours"
17:37:46 <dsal> OverloadedLisps
17:37:59 <monochrom> What does OverloadedLisps do?
17:38:00 <dsal> oats: my a key is giving out on my mc
17:38:20 <dsal> monochrom: I think it makes $ stop working so you have to use more parens.
17:38:29 <monochrom> Ah!
17:38:36 <oats> monochrom: lets you inline scheme in your haskell
17:49:28 <delimax> hello all, I have a beginner Haskell question regarding the state monad. I'm writing a toy program with http://hackage.haskell.org/package/ncurses-0.2.16/docs/UI-NCurses.html, and I've defined a state monad for some kind of board position, that takes a board and a move, and returns the new state after the move has been applied and that works in isolation, but now I want to extend it so that I can read 
17:49:34 <delimax> the size of the screen from the ncurses library, so as to constrain the legal moves, and I'm struggling to come up with a way to do that. any insights here? ty https://gist.github.com/maxdeliso/68d80c21446af23f8663ba2f63aed3e7
17:53:02 * hackage mpi-hs 0.6.0.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.6.0.0 (eschnett)
17:57:12 <wildtrees> delimax, you might want a StateT monad transformer over an IO monad, you make a small stack of them and get one monad where you can lift things into 
17:59:36 <delimax> wildtrees: ty i'll look into that one. so the inner one updates the state - as now - and the outer one reads the dimensions from an enclosing monad (the ncurses one?)
18:01:19 <wildtrees> delimax, the inner monad in a stack has to be IO iirc if you use IO at all , there is no IOT transformer 
18:01:42 <wildtrees> you will need to liftIO $ your IO actions into your new stack 
18:03:11 <wildtrees> delimax, if you wanted to you could just make the state explicit and pass it around to your functions as an argument 
18:03:20 <wildtrees> gotta run , good luck 
18:03:23 <delimax> ok I'll give this a try, thx. 
18:11:24 <frdg> https://pastebin.com/CXWf6P7N could anyone look at my ceaser shift function and let me know if it is readable / good code?
18:18:41 <jackdk> frdg: do you have a link to the problem?
18:21:24 <frdg> jackdk: https://pastebin.com/gb9cwucT didn't paste so great but should be good enough 
18:22:37 <jackdk> frdg: is this homework or self-study?
18:22:45 <frdg> self study
18:22:52 <jackdk> ok
18:24:23 <dmwit> frdg: I would `caesarShift n = map (shift n)`, I think.
18:24:29 <jackdk> frdg: spelling: `caesarShift`, not `ceaserShift`
18:24:41 <jackdk> about to say that dmwit ++
18:25:08 <dmwit> last (take n xs) is xs !! (n+1)
18:25:13 <dmwit> err
18:25:15 <dmwit> xs !! (n-1)
18:25:56 <frdg> ok noted thanks guys
18:26:07 <dmwit> You can float the `nxt = ord x` definition into the previous `let`.
18:26:58 <jackdk> awkward wraparound logic can go away if you embrace lazy infinite lists: `shift n c = dropWhile (/= c) (cycle ['a'..'z']) !! n`
18:27:28 <dmwit> I think `last` and `(!!)` are both code smells, so I'd be looking for a way to eliminate them.
18:27:48 <dmwit> In this case, since `['z','y'..]` is an arithmetic sequence, you can compute an index into it directly.
18:28:15 <frdg> dimwit: cause of O (n^2) ? 
18:28:17 <dmwit> So `wrap = chr (ord 'z' - (n-1))`
18:28:30 <dmwit> Well, because of O(n).
18:28:36 <frdg> right
18:29:07 <dmwit> You might consider doing some modular arithmetic. Are you familiar with it?
18:29:21 <frdg> no
18:29:32 <dmwit> Okay, check this out by way of a hint:
18:30:00 <dmwit> > let n = 16 in [(3 + n) `mod` 26, (18 + n) `mod` 26]
18:30:04 <lambdabot>  [19,8]
18:30:19 <dmwit> Note that both answers are less than 26, even though 18+n is bigger than 26.
18:30:36 <dmwit> mod is the name of the arithmetic operation that does the kind of wrapping you care about.
18:30:51 <dmwit> > let n = 5 in [x `mod` n | x <- [0..]]
18:30:56 <lambdabot>  [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2...
18:31:01 <frdg> oh right like a clock I see why this makes sense
18:31:09 <dmwit> Yeah!
18:32:26 <frdg> ok I can vastly improve my algorithm ill give it a shot thank you!
18:32:32 <dmwit> Nice, good luck!
19:07:48 <oats> modular arithmetic \o/
19:07:51 <oats> very fun
20:14:02 * hackage miso 1.5.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-1.5.0.0 (DavidJohnson)
20:15:02 * hackage miso-examples 1.5.0.0 - A tasty Haskell front-end framework  https://hackage.haskell.org/package/miso-examples-1.5.0.0 (DavidJohnson)
20:25:40 <dmj`> yooo
20:39:24 <conmute> Hi! I am trying to install intero for Hackero (Visual Studio code) but I always get this: `Could not find module ‘Network’` when `[ 9 of 10] Compiling InteractiveUI` 
20:40:03 <conmute> stack `resolver: lts-13.19`
20:49:20 <lyxia> module Network is a very old thing
20:49:56 <mike20> @djinn (Either (a -> Void) b) -> (a -> b)
20:49:56 <lambdabot> f a b =
20:49:56 <lambdabot>     case a of
20:49:56 <lambdabot>     Left c -> void (c b)
20:49:56 <lambdabot>     Right d -> d
20:56:00 <conmute> lyxia Im on macos Catalina, and trying to configure development environment - intero must be installed, but it always fails… please help
20:56:28 <lyxia> conmute: did you know that intero is no longer maintained?
20:56:56 <conmute> now I know thx! What can I setup to code in haskell then?
20:58:39 <dsal> Is there a convenient way of converting a ByteString to [ByteString] with each chunk being of a specific size?
20:58:47 <lyxia> conmute: sorry I don't know, I don't use an IDE.
20:59:12 <dsal> Actually, I kind of need lazy.  This may not make any sense at all...
20:59:57 <dsal> What I actually need is seek + read exactly X bytes...
21:01:17 <dsal> Ah, unix-bytestring has pread.
21:02:05 <ukari> where is OverloadedLisps? I can't found it in google
21:02:32 <monochrom> It's a joke.
21:03:49 <monochrom> stack LTS is a very old thing. every one of them.
21:05:07 <dsal> I don't think any are old enough for unix-bytestring...
21:05:21 <monochrom> heh
21:06:50 <dsal> Hmm...  This is actually kind of hard.  I guess I just need to make a callback of (Int -> ByteString) for my function and let the caller sort it out.  This upload API is kind of nuts.
21:06:52 <monochrom> But my sentence was for Network being old and a stack command running into Network not found.
21:08:06 <conmute> monochrom lyxia explained this to me, what setup do you use for development?
21:08:32 <monochrom> emacs haskell-mode
21:09:18 <monochrom> and at most cabal v2, more often cabal v1, most often just ghc.
21:10:46 <dsal> It's weird to me that there's nothing like pread in any supported lib.  :|
21:11:29 <conmute> monochrom I am trying to use VSCode on top of it, so I wll not change my tooling drasticly - what can you say about VSCode?
21:11:30 <monochrom> I'm a toolchain vegetarian.
21:11:53 <conmute> …for hasckell, linting etc…
21:11:57 <conmute> haskell*
21:12:01 <monochrom> My students use it.  Their marks are lower than mine.
21:18:05 <monochrom> haskell linting is overrated.
21:19:28 <monochrom> There is a reason lint was invented for C not for Algol Pascal even COBOL.
21:19:46 <conmute> I can write pure text and work with it, but many feature that I can use of before would be nice to setup in haskell. Specificly robust workflow process
21:20:48 <conmute> so in Javascript (you hate it or not, it does not matter) I have ton of custom developer friendly configuration. My take is to find out such for haskell, what are these
21:21:02 <conmute> What you would recommend for me to look into?
21:21:24 <monochrom> Minimalism
21:22:19 <conmute> I would ask in other way, how to setup project environment and editors the best in order to have a 20% efforts to 80% results?
21:22:33 <monochrom> Minimalism again.
21:22:55 <conmute> ok… but this is broad, can you be more specific?
21:23:06 <monochrom> I already did
21:23:14 <monochrom> <monochrom> emacs haskell-mode
21:23:15 <monochrom> <monochrom> and at most cabal v2, more often cabal v1, most often just ghc.
21:23:30 <conmute> you dont use stack?
21:23:40 <monochrom> No.
21:23:44 <conmute> why?
21:23:59 <monochrom> No need, no benefit.
21:24:41 <monochrom> Cost of sucking up to its walled garden and new religion.
21:25:21 <conmute> what do you mean?
21:26:01 <monochrom> It has its own new worldview?
21:26:17 <conmute> I am thinking of building a pet project in haskell, and my take is on how to setup it in most convenient way. I see always `stack` this and `stack` taht
21:26:59 <monochrom> For a pet project, sometimes I use "cabal init", sometimes I dont even bother.
21:27:16 <conmute> How do you write tests?
21:27:44 <monochrom> I have a test program that uses HUnit.
21:28:20 <monochrom> Sometimes I don't even need that.
21:28:31 <conmute> ok, thx!
21:28:38 <glguy> conmute: You can also use doctests: https://github.com/glguy/intcode/blob/master/src/Intcode/Machine.hs#L120-L121
21:28:57 <monochrom> I have a program that is periodically run by cron to go into some directories (specified on command line) and merge log files.
21:29:11 <monochrom> So I just have a sample directory and run my program on it for test.
21:29:36 <monochrom> Doesn't need any "framework" "toolchain" "CI website" "cloud computing" at all.
21:29:54 <conmute> ok…
21:31:17 <conmute> If you would build a scalable modular enterprise solution that would run on your machine as a daemon and can be extended by plugins in Haskell… How you would build the workflow pipeline?
21:31:32 <monochrom> It's like I just need to test it once or twice every year or two.  Currently it's like just 10 keystrokes per test with vanilla ghc no "toolchain".
21:31:41 <monochrom> Tell me how many keystrokes stack will save me.
21:31:56 <monochrom> You said pet project.  Moving goalpost.
21:32:23 <conmute> I am ambitous - so want to figure out what can be used
21:33:40 <monochrom> Have you done that in another language?
21:34:39 <conmute> In JavaScript I would go for monorepo that has multiple of services: daemon;api;client;client2 and libs
21:34:57 <conmute> each of the service should be held by separate processes…
21:35:15 <monochrom> That sounds like category theory for javascript.
21:35:32 <monochrom> I don't understand any of that glorified vagarity.
21:35:36 <conmute> during development of all of the services I would like to reuse the code - so trying to keep things modules, so the libs are for
21:36:18 <monochrom> But I would have a shell script that calls "cabal build" or "make", then calls the test program, then maybe calls the upload program.  Just to save a few keystrokes.
21:37:40 <conmute> the plugin architecture in javascript <- that can be done during the production run, that another topic, but it would be done via loading bundles/dlls…
21:38:22 <conmute> for pipeline I have: static analysis => unit tests => integrations tests (how crucial module are integrated together) => e2e tests
21:38:47 <conmute> another part of the project helds the config for deploying this…
21:39:25 <monochrom> that can be a simple shell script
21:39:32 <conmute> how that work will vary, but its basically shipping to production.
21:39:45 <conmute> All of this, in order to scale -> i could need some peoples for that
21:39:50 <monochrom> This exjubilant framwork exists because javascript people haven't heard of shell scripts.
21:39:54 <conmute> Of course its a shell script ;P
21:40:24 <conmute> so no problems with that
21:40:53 <conmute> What I am interested in: static analysis for haskel, hlint - so code style is consitent
21:41:15 <conmute> then possibly some unit tests and BDD tests
21:41:53 <conmute> and also some black-box testing (system or e2e tests)
21:42:39 <conmute> running the executable can be held by *nix utilities, so thats not a problem… and also! documenation generation
21:43:35 <conmute> so basically - which things are to help out to review haskell code? I use eslint + prettier for js projects, anything similar?
21:43:56 <conmute> … more question will come from the context from above…
21:44:21 <conmute> sry for my bad english, Im from Ukraine ;P & didnt sleep for whatever reasosn…
21:44:35 <monochrom> How much Haskell code have you actually written and improved on?
21:45:10 <conmute> finished "learn you a haskell for great good"
21:45:50 <conmute> I loved how haskel works and philosofy in the source code, thinking now of establishing the project.
21:45:57 <monochrom> Because soon after I wrote a  bunch, I found that it enhances my aesthetic sense. This means I acquired good style and good judgment without being told by a style checker.
21:46:32 <conmute> If its yours yes, but what if there are 2-3… 10 people? it should be consistent
21:46:43 <conmute> and even in haskell you can write things differently
21:46:45 <monochrom> Beginners are in perpetual denial of this because other languages don't work like this so they disbelieve Haskell can work like this.
21:47:40 <monochrom> Just 10 people?  Then just tell them about https://github.com/tibbe/haskell-style-guide and you're done.
21:47:54 <monochrom> Talk to me again when you have 100 people.
21:48:04 <conmute> Haha! Ok
21:48:13 <conmute> What can you say about: https://stackoverflow.com/questions/52085005/haskell-hlint-how-can-i-add-hint-for-wrong-indentation-trailing-spaces-and-e
21:48:35 <monochrom> You also probably underestimate how a layout-sensitive language constrains style already.
21:48:51 <monochrom> Don't use hlint?
21:49:12 <conmute> that was a statement, right?
21:49:17 <monochrom> Yes.
21:49:30 <conmute> why?
21:50:08 <monochrom> Have you actually used hlint for real?  As opposed to just hearing the name "hlint" and assume it's a good idea?
21:50:36 <monochrom> Have you actually looked at the anal unnecessary complaints hlint complains about perfectly reasonable code?
21:50:58 <conmute> No, i am not
21:51:18 <monochrom> Such as suppose you're writing for a less advanced audience so you write like a longer lambda "(\x -> x*10)" and hlint tells you to be a total smartass and change it to "(* 10)"?
21:51:20 <glguy> I think people assume that using something called hlint will be a good idea because it's needed in other languages without as useful of a type system
21:51:30 <monochrom> See? You're full of it.
21:51:39 <conmute> I am from different camp, and I know that I dont want to waste time for keeping the codestyle because people forget (habits etc) and focus on the main thread what code does
21:52:15 <monochrom> What do I recommend?  Invalid all your assumption, start over with a clean slate.
21:52:24 <monochrom> s/Invalid/Invalidate/
21:53:04 <conmute> ok… il try then
21:54:12 <conmute> If so, what saves times the most for during development of projects on Haskell?
21:54:19 <glguy> ghcid
21:54:22 <conmute> sorry for remards
21:54:22 <monochrom> If you have 10 people you have a valid concern about, what, someone indents by 4 and someone else indents by 2, someone uses do-notation and someone else refuses do-notation.
21:54:53 <monochrom> But one single webpage like tibbe's style guide suffices to get everyone on the same page.
21:55:26 <monochrom> And most importantly the intentional absence of a program to enforce it means respect to those 10 people.
21:56:06 <monochrom> Do you really understand, in terms of team player goodwill, what it means to institute a robot police?
21:56:42 <conmute> glguy what would you recommend for me ghcid or haskell-ide-engine?
21:57:06 <conmute> monochrom I understand
21:57:20 <nshepperd2> robot police would be more ok if hlint's advice was always good instead of always bad
21:57:23 <conmute> monochrom which things is best to automate?
21:57:43 <conmute> because for now I see that `hlint` is a bad program
21:57:55 <monochrom> build->test->install
21:58:16 <monochrom> And if you have a shell-script for that, ghcid can loop over it for you.
21:59:02 <conmute> How big files can be? Because on one file we could have different styles - because again, people forget, and "robots" helps to catch that
21:59:05 <monochrom> sometimes build->test can also be a simple cabal command or two, so you can even omit writing your own shell script.
21:59:33 <monochrom> 0.1x of javascript files?
21:59:45 * glguy remembers the great "the top of this file used different identation than the bottom" crisis of 2010
22:00:07 <glguy> I think the company that happened at burned to the ground as a result
22:00:15 <glguy> (don't quote me on this)
22:00:19 <conmute> :)
22:00:26 <monochrom> Wait what was that crisis?
22:01:25 <Axman6> shit man, that's awerful something like that would happen. People need to know the dangers
22:01:48 <Axman6> awful*
22:01:51 <glguy> monochrom: You now know everything about it I purport to know
22:02:03 <monochrom> haha OK!
22:02:36 <conmute> ghcid or haskell-ide-engine?
22:02:53 <monochrom> Have you looked them up and found out that they're like orthogonal?
22:03:08 <dmj`> conmute: I vote ghcid
22:03:10 <Axman6> I use hie with VS code, and it works well, though is often a memory hog
22:03:31 <Axman6> hie + docker = a bad time with 16GB RAM
22:03:42 <conmute> I am not sure that I want to jump straight away into emacs style
22:03:54 <dmj`> conmute: resistance is futile
22:04:00 <conmute> hie + docker = a bad time with 16GB RAM <= Ok, thx
22:04:06 <monochrom> Then don't. I heard that vim takes less investment.
22:04:35 <conmute> dmj` ))) no free time right now, to many things to learn at one time
22:04:40 <monochrom> I agree that emacs is a big and not worthwhile investment today.  But you asked me what I use.
22:05:15 <conmute> So I'l conclude what I have from very helpfull comments
22:05:21 <dmj`> emacs haskell-mode is great, you can use dante to get the type of sub expressions now
22:05:25 <Axman6> I really like VS code though - if you'd told be 5 yearsd ago I'd be using, let along liking, an editror written in JS made by microsoft I'd have laughed at you, but it's very well managed, performance if good, and has lots of extensions available
22:05:36 <monochrom> haskell-mode does too.
22:05:40 <sm[m]> conmute: run don’t walk to install ghcid. Don’t mess with the “IDE” things unless you have three days to spend testing probably failing
22:05:57 <monochrom> Because both haskell-mode and dante simply issue the same ghci command.
22:06:06 <glguy> It sounds like conmute might have time to burn, actually :)
22:06:18 <conmute> time to burn?
22:06:21 <monochrom> Just that haskell-mode doesn't have a default key binding for that function.
22:07:01 <conmute> Axman6 what did you use with VS Code? Only HIE?
22:07:08 <conmute> * Use cabal isntead of stack, because its simpler and more straight forward
22:07:31 <conmute> * dont use hlint, just consent with https://github.com/tibbe/haskell-style-guide
22:07:33 <Axman6> yeah - though I usually use a combination of hie and stack te4st --file-watch --pedantic in the console in VS code
22:08:12 <sm[m]> lots of folks find stack simpler, you should find out for yourself
22:09:03 <conmute> …
22:09:22 <conmute> So the problem I see so far is, that Haskell is very great language and I adore it very much
22:09:41 <conmute> But coding environment and tooling is not that much developer friendly
22:09:46 <glguy> In the age of cabal install 3, it's not worth investing the time in stack unless you know it has a feature you have to have
22:09:49 <sm[m]> and you should look at a lot of successful projects, like the ones you want to make
22:09:54 <Axman6> I certainly find stack simpler for app development, but for library development cabal is probably the better choice
22:09:56 <conmute> So if I will get a new guy there will be a huuuuuge learnign curve
22:10:34 <conmute> not only FP approach, but the developer experience… I am not sure how great it is…
22:10:53 <conmute> syntax hightlight, go tos, etc…
22:10:56 <sm[m]> commute that’s somewhat true. But the language is good enough that it outweighs the tooling problems
22:11:11 <Axman6> glguy: what does cabal 3 offer? I haven't seen much about it. LTSs are a big win when writing apps in production, it means we can schedule when we want to go through the pain of dealing with new versions of libraries
22:11:12 <conmute> Yeah
22:11:14 <dmj`> conmute: you gotta use emacs, it's the morally right thing to do. 
22:11:19 <sm[m]> And it gets better with a bit of experience
22:11:38 <conmute> looks like to write in haskell you need to be a verrry grown up man straight away to nor rely on Dev Exp things
22:11:54 <glguy> Axman6: lts has only served to add incompatibilities with packages not in the lts for be
22:11:57 <glguy> For me
22:12:20 <glguy> Freeze files cover anything I've needed from an lts
22:12:21 <monochrom> This is why I said walled garden.
22:12:32 * hackage json-api-lib 0.2.0.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-lib-0.2.0.0 (shirren)
22:12:40 <dmj`> conmute: yea that fancy stuff is just a crutch, most haskellers have the haddocks essentially downloaded in their brains matrix style, and you end up just programming in your head.
22:13:11 <conmute> just programming in your head. <= thats great and problematic at same time
22:13:24 <glguy> Axman6: I believe someone needs stack, but new users should switch when it has something they no they need. It's not a starting point
22:13:24 <conmute> because I need to debug things for real
22:13:25 <Axman6> but gets easier with time
22:13:31 <dmj`> conmute: well the types keep you from getting your wires crossed
22:13:33 <monochrom> Customers who like stack may also like: iPhone, Macbook, XBox.
22:13:47 <dmj`> conmute: GHC's typechecker programs you to think basically.
22:14:01 <sm[m]> glguy: I disagree, I find it makes getting started easier
22:14:03 <dmj`> monochrom: I have all of those things and I don't use stack
22:14:19 <glguy> sm[m]: it's just extra stuff to learn for beginners
22:14:24 <Axman6> stack/stackage is hardly a walled garden...
22:14:30 <sm[m]> I find the opposite
22:14:41 <conmute> What about line by line execution during debug session?
22:14:47 <monochrom> dmj`: Don't worry, my sister has those things too and doesn't even know Haskell :)
22:15:07 <conmute> If use only cabal, how you manage ghc/ghci different verisons?
22:15:12 <Axman6> conmute: ghci has a debugger, but it's almost never used. we tend to write small,er, easier to test functions
22:15:23 <dmj`> monochrom: I guess she doesn't like stack either then :)
22:15:45 <monochrom> ghcup
22:15:53 <glguy> GHC already supports having multiple GHC versions installed. ghcup makes it easy to install new versions
22:16:05 <dmj`> conmute: you'll never do line by line debugging, you'll resort to the tried and true print debugging or traceShow debugging
22:18:09 <Axman6> luckily debugging haskell code by hand is usually very simple, and can be done by hand - there's no hidden state to have to worry about, usually it's just substitution
22:18:29 <sm[m]> I wouldn’t go that far
22:18:53 <monochrom> I go that far and don't go that far.
22:19:03 <int-e> conmute: one possibility is to modify $PATH to switch between ghc versions
22:19:33 <int-e> cabal-install's --with-ghc is another option... there are ways to cope
22:19:36 <monochrom> A. It can be as simple as substitution.  B. But do you understand how programmers become programmers because they suck at math therefore they're going to suck at substitution?
22:19:37 <sm[m]> you can have some very awkward state and complex contexts that are hard to print and debug
22:19:55 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
22:20:21 <monochrom> There are excellent asm hackers who can't do Haskell substitution
22:20:39 <monochrom> This is why they only know about line-by-line stepping.
22:20:59 <dmj`> conmute: you could use nix too, nix-shell -p haskell.compiler.ghc865 or nix-shell -p haskell.compiler.ghc881
22:24:53 <monochrom> With awkward state and complex contexts, you up the game and work with laws. >:)
22:25:15 <monochrom> (More math!)
22:28:44 <siraben> What's the categorical reading of monad transformers?
22:35:27 <conmute> What open source Haskell projects you would recomend me to reference? With stack? Without stack, only cabal?
22:40:23 <conmute> monochrom, dmj`, glguy, Axman6, int-e thx for the all comments!
22:48:47 <solonarv> siraben: some sort of endofunctor in the category of monads, I guess?
22:49:22 <aviD> What interview questions have you all gotten for Haskell jobs?
22:51:05 <sm[m]> conmute: do you want to make libraries ? Tools for specialists ? End user apps ? Enterprise solutions ? A blockchain ?
22:53:31 <dmj`> aviD: write map in terms of foldr
22:54:22 <conmute> sm[m] I want to start from apps, that could possibly go enterprise - blockchain is in plans
22:54:30 <conmute> … but not yet, later
22:54:45 <conmute> then libraries, then some tools possibly…
22:54:52 <dmj`> conmute: you should checkout miso, people use it for apps, and some blockchain companies use it too
22:54:58 <dmj`> conmute: https://haskell-miso.org
22:55:14 <sm[m]> Some ideas for each: text/vector/conduit/regex; ghcid/shake/ghc; pandoc/hledger;
22:55:43 <conmute> front-end framework, what "front-end" stands for there? What does it means?
22:55:46 <dmj`> aviD: write BFS in Haskell, write a lambda calculus interpreter, write a code generator for some simple IR, implement a game
22:56:02 <dmj`> conmute: the browser
22:56:22 <dmj`> conmute: chrome, safari, IE, etc.
22:56:28 <sm[m]> haskellers.com/southern exposure seed exchange/postgrest; Cardano
22:56:43 <sm[m]> Sorry, that was hard to type on a phone
22:56:48 <conmute> so miso frameworks compiles to javascript?
22:57:14 <sm[m]> and I’m out, night all
22:57:59 <conmute> sm[m], "Some ideas for each: text/vector/conduit/regex; ghcid/shake/ghc; pandoc/hledger;" => this are the projects examples?
22:58:11 <dmj`> conmute: yea, well, GHCJS compiles to JavaScript
22:58:59 <conmute> ok, I dont need GHCJS feature… more sophisticated BL on the daemon and/or service level
23:01:53 <dmj`> conmute: well what is it that you need
23:02:50 <conmute> dmj` and this? "haskellers.com/southern exposure seed exchange/postgrest; Cardano"
23:12:31 <DanCorneanu> Hello everybody
23:14:30 <solonarv> DanCorneanu: hello!
23:18:42 <dmj`> conmute: I don't know what that is
23:20:05 <dmj`> aviD: going through hackerrank.com in Haskell is good too
23:20:07 <dmj`> and fun
23:25:31 <conmute> Thx everybody, and good bye!
