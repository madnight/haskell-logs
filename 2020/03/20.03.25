01:07:20 <whatatiming> nix-build copying path '/nix/store/n1gwpmvmcgsbnr0a8ncflhvc59db775h-myproject-1.0.0' from 'https://all-hies.cachix.org'
01:07:39 <whatatiming> https://all-hies.cachix.org/
01:08:00 <whatatiming> I tried install hie binary with nix, but I got this error
01:08:32 * hackage avro 0.5.0.0 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.5.0.0 (haskellworks)
01:08:40 <whatatiming> nix-build error: getting status of '/home/john/default.nix': No such file or directory
01:09:05 <whatatiming> where I can find this default.nix?
01:35:32 * hackage text 1.2.3.2 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.3.2 (HerbertValerioRiedel)
01:52:29 <leitao> Morning. Quick question about someone that is starting with ghc. Why do I have this issue when running ghci:
01:53:02 <leitao> Prelude> doubleMe x = x + x
01:53:02 <leitao> `<interactive>:2:12: parse error on input ='``
01:54:32 * hackage sr-extra 1.72.1 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.72.1 (DavidFox)
01:57:15 <iqubic> leitao: What version of GHC do you have?
01:57:32 <leitao> iqubic: It is version 7.6.3
01:58:56 <solonarv> wow, that's positively ancient
01:59:03 <iqubic> Ah. Well, in that case I'm going tell you that you that, when defining functions and variables in ghci you need to use let. Try this: "let doubleMe x = x + x"
02:00:38 <leitao> Yea, that works. I am reading the " Learn You a Haskell for Great Good!" book and the examples in the book were not matching.
02:00:59 <solonarv> that's because (as I alluded to above) you are using an old version of GHC
02:01:17 <leitao> right. What version had this behaviour changed?
02:01:22 <solonarv> in newer versions you don't need the 'let'
02:01:28 <solonarv> I don't remember when it changed, actually
02:02:19 <leitao> Cool. I will upgrade it. Thanks solonarv and iqubic!
02:02:22 <iqubic> solonarv: You can still use let, even in 8.8.x. That's for backwards compatibility
02:03:21 <iqubic> In fact, I exclusively use let in the repl.
02:04:23 <solonarv> yeah, I know it still works
02:05:06 <solonarv> leitao: I'd recomment using hvr's PPA or ghcup if you're on *nix, or chocolatey if on windows
02:05:41 <solonarv> your system/distro packages are probably not adequate unless you happen to be running NixOS
02:06:56 <iqubic> solonarv: PPA only works on distros that use apt/dpkg
02:07:19 <solonarv> yes, right
02:09:44 <Uniaika> < iqubic> In fact, I exclusively use let in the repl. // wow, so you don't use it in do-blocks?? :o
02:10:22 <Uniaika> (/s)
02:11:11 <iqubic> Uniaika: What I meant was, when defining new functions and variables in the repl, I always use let. When writing code in *.hs files, I use let where ever it's appropriate.
02:13:01 <Uniaika> (yes I know, that was a joke, hence the /s afterwards :P)
02:13:09 <Uniaika> (sorry for not conveying it better)
02:14:04 <Uniaika> iqubic: please accept these beautiful book covers to pardon me : https://twitter.com/mnstrmnch/status/1242560163355254786
02:14:07 <Uniaika> :)
02:46:02 * hackage futhark 0.15.2 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.15.2 (TroelsHenriksen)
02:59:31 <arianvp> QQ. now with pantry in stack 2.0 is there any difference between putting things in a custom snapshot or  in your stack.yaml?
02:59:36 <arianvp> in terms of caching etc?
05:59:02 * hackage mmsyn7l 0.4.0.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.4.0.0 (OleksandrZhabenko)
06:31:24 <sMuNiX> reading about "eff" (github.com/hasura/eff), I see it required new low-level primitives to be added to the GHC RTS. This is done to support capturing slices of the call stack. I like its design and the APIs, and still wonder what is intended by "capturing slices of the call stack"
06:31:35 <sMuNiX> anyone knows ?
06:36:36 <phadej> sMuNiX: https://github.com/ghc-proposals/ghc-proposals/pull/313
06:43:02 * hackage mmsyn7l 0.4.1.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.4.1.0 (OleksandrZhabenko)
06:49:02 * hackage mmsyn7l 0.4.2.0 - Modifies the amplitudes of the Ukrainian sounds representations created by mmsyn7ukr package.  https://hackage.haskell.org/package/mmsyn7l-0.4.2.0 (OleksandrZhabenko)
06:52:11 <maerwald> Hmm, HsOpenSSL doesn't build with LibreSSL? :///
06:52:36 <maerwald> I was so hoping not to have to use haskell-tls, but these linking/portability problems...
07:05:35 <thyr15t0r> HELLO! How to read data from html page using https?
07:06:23 <thyr15t0r> the page includes text only
07:11:21 <maerwald> thyr15t0r: you want to download a web page which is plain text? like with "curl"?
07:14:15 <thyr15t0r> <maerwald> yes
07:14:32 <maerwald> I use https://hackage.haskell.org/package/http-io-streams-0.1.2.0/docs/Network-Http-Client.html for that, which is a bit low-level, but well
07:15:16 <maerwald> Otherwise https://hackage.haskell.org/package/http-client-0.6.4.1/docs/Network-HTTP-Client.html
07:15:38 <thyr15t0r> is it working with last version of ghc?
07:16:30 <maerwald> or rather https://hackage.haskell.org/package/http-client-tls but then you have to use haskell-tls
07:16:40 <maerwald> http-io-streams uses OpenSSL
07:16:43 <maerwald> sure
07:16:57 <maerwald> 8.10.1 maybe not
07:17:07 <maerwald> depends, it's too new, was just released
07:17:11 <maerwald> No idea
07:17:21 <fendor> maerwald, what is the problem with haskell-lts?
07:17:23 <maerwald> 8.8.3 is fine
07:17:45 <maerwald> fendor: It's written in haskell and has never seen any (binary) audit
07:18:15 <fendor> maerwald, ok, fair. 
07:18:24 <zincy_> Is it a bad idea to turn on strict data globally so that errors are thrown at compile time if a record doesnt have all its values initialised?
07:18:31 <maerwald> There's little research about the impact of using haskell for cryptography (memory issues, etc)
07:18:51 <zincy_> There must be some undesirable consequences of just doing that blindly?
07:19:00 <maerwald> I find it a bit baffling that ppl started to use a tls haskell implementation with that little consideration 
07:19:12 <maerwald> Like, in production
07:20:04 <maerwald> zincy_: parts of the network stack have stict data globally already
07:20:08 <maerwald> To avoid space leaks
07:21:43 <maerwald> zincy_: https://github.com/yesodweb/wai/pull/752#issuecomment-501531386
07:21:52 <maerwald> kazu is very knowledgable in that area
07:22:04 <maerwald> He even proposed to turn on *Strict*, not just StrictData
07:23:24 <maerwald> zincy_: also, uninitialized records already emit compiler warnings
07:23:37 <maerwald> The use case seems odd
07:24:42 <solonarv> zincy_: also also, you can turn any warning into an error with -Werror=name-of-warning (IIRC)
07:35:32 * hackage warp-grpc 0.4.0.1 - A minimal gRPC server on top of Warp.  https://hackage.haskell.org/package/warp-grpc-0.4.0.1 (AlejandroSerrano)
07:39:37 <zincy_> Thanks! 
08:09:32 * hackage th-desugar 1.11 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.11 (ryanglscott)
08:32:30 <jonge[m]> hi. there was once a blog article where the author compared opaleye, beam, esqueleto, squeal, hasql etc. by implementing a DB app with each of them. the app was an example which modeled a market place that brings together serial killers with users who want someone killed. i cannot find it anywhere online any longer but i would like to show it to colleagues because it was super awesome. does anybody have an idea if it is
08:32:30 <jonge[m]> still online somewhere?
08:34:32 * hackage singletons 2.7 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.7 (ryanglscott)
08:36:14 <MarcelineVQ> sounds amazing
08:37:01 <maerwald> Something you'd put on your resume for sure
08:37:43 <solonarv> jonge[m]: hm, I vaguely remember reading that but can't recall where to find it
08:38:00 <solonarv> it was posted to /r/haskell on reddit, so maybe that's a way to find it
08:38:13 <jonge[m]> solonarv: i really really hope the author didn't take it offline.
08:38:19 <jonge[m]> thx i will have a look!
08:41:24 <jonge[m]> solonarv: found it: https://williamyaoh.com/posts/2019-12-14-typesafe-db-libraries.html thank you!
08:42:51 <solonarv> \o/
09:02:32 * hackage singleton-nats 0.4.4 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.4 (ryanglscott)
09:27:02 * hackage eliminators 0.7 - Dependently typed elimination functions using singletons  https://hackage.haskell.org/package/eliminators-0.7 (ryanglscott)
09:39:41 <wz1000> hello metasis
09:40:27 <wz1000> join #ghc and #haskell-ide-engine
09:40:32 * hackage css-easings 0.2.0.0 - Defining and manipulating css easing strings.  https://hackage.haskell.org/package/css-easings-0.2.0.0 (wvanonsem90)
09:44:02 * hackage base-compat-migrate 0.2.0.1 - Helps migrating projects to base-compat(-batteries).  https://hackage.haskell.org/package/base-compat-migrate-0.2.0.1 (AdamBergmark)
09:48:02 * hackage binary-instances 1.0.0.1 - Orphan instances for binary  https://hackage.haskell.org/package/binary-instances-1.0.0.1 (phadej)
09:54:10 <ysangkok> hmmm is ryanglscott on irc?
09:54:38 <phadej> sometimes
09:56:23 <Uniaika> ysangkok: you'll find him on #ghc
09:56:58 <ysangkok> ok thanks!
10:24:32 <Guest36> Hi, suppose I want to create a new kind of list that hold valeus of type a: data MyList a = [a]. And now I want to create a list of lists, data ListOfLists a = [MyList a]. But this definition of ListOfLists, enforces that all MyLists inside it have the same type. But I want something like this: ListOfLists [MyList [1,2,3], MyList ['a','b'] ]. Can
10:24:32 <Guest36> this be done?
10:24:36 <Guest36> *values
10:25:17 <solonarv> Guest36: well, the start is wrong: data Blah .. = [something] isn't valid
10:25:26 <solonarv> you need a constructor
10:26:06 <Guest36> solonarv: how can it be done instead?
10:26:24 <solonarv> to bluntly answer your question: yes it can be done, but it's finicky and annoying and probably not the best way to accomplish whatever actual goal you have
10:26:55 <solonarv> and the method involves a bunch of intermediate-advanced type wizardry, so it wouldn't be very productive to discuss
10:27:16 <Guest36> solonarv:  actual goal is to define a structure like DataFrame in Python. It holds "lists" of different types. 
10:27:23 <Guest36> Python/Pandas
10:27:58 <dsal> You mean you just want a container of lists of different types?  That's a tuple.
10:28:02 <dsal> Or a record.
10:28:21 <Guest36> Yes. But it's length is arbitrary 
10:28:27 <Guest36> Defined in runtime
10:28:45 <ysangkok> but lists do not have their lengths in their type
10:29:15 <Lycurgus> hs don't wanna define stuff in runtime
10:29:31 <Lycurgus> big no no
10:29:44 <dsal> It seems like this could be hard to use.  You either need to tag the values, or you need type magic to do things at compile time (which, I'm told, isn't runtime).
10:30:11 <Guest36> Lycurgus ysangkok  dsal not actually definition. but changing it's length at runtime 
10:30:34 <monochrom> "different types" is always an exaggeration.  Secretly you always only have like 3 possibilities.
10:30:52 <Guest36> monochrom: why? 
10:30:59 <monochrom> Because it's true.
10:31:01 <dsal> ...at which point tagging is pretty straightforward.
10:31:30 <solonarv> it cannot be *literally anything*, because then you could not actually do anything useful with the value
10:31:48 <Lycurgus> toldja
10:32:06 <Guest36> solonarv: yes. it won't be literally anything. 
10:32:23 <Cale> Guest36: Looking at your question, the first question I have is: what do you intend to do with the values when you get them back out of the lists again?
10:33:12 <Cale> Guest36: It's often possible to make the lists more uniformly typed by considering what you'll be doing with the values that are going into the list, and simply applying whatever functions to them beforehand
10:33:12 <Guest36> Cale: you mean how I intend to manipulate them when they're not inside that structure?
10:33:47 <Cale> For example, if all you ever intended to do with the list elements was turn them into strings (simple example), then it would be easier just to turn them into strings first.
10:34:03 <Guest36> Cale: yes. the other way I was trying to do this is defining all possible types that I want to work with. like so: data Series = Sint [Int], Sstring [String]
10:34:05 <Cale> Noting that Haskell is lazy, and the work only gets done when and if you need it
10:34:10 <Guest36> but this leads to too much code repetition...
10:34:39 <Cale> Yeah, it might be hard to know which cases you'll eventually need as well
10:35:03 <Cale> But if you have a handle on what the list is used for, usually you can eliminate the need to put different types of data into it
10:35:04 <Guest36> Cale: this is just a learning project. I intended to implement something like Pandas in Python. which makes manipulating tabular data easy
10:35:13 <dsal> Code repetition is somewhat orthogonal.  When I find too much repetition, I can often do something about it.
10:35:39 <Cale> Another, fancier option, would be to use something like DSum
10:35:47 <Guest36> Cale: I kinda understand
10:36:00 <dsal> I've been doing  ton of dynamic JSON stuff recently.  You can definitely have arbitrarily complex data structures that are defined at runtime.
10:36:11 <nshepperd1> containers of differing types in python are actually containers of one type, which is "python object"
10:36:24 <Rembane> dsal: Did you do it with Aeson? 
10:36:28 <dsal> Yeah.
10:36:50 <Cale> DMap gives you a heterogeneous key/value store where the types of the values depends on the types of the keys
10:36:56 <Cale> depend*
10:37:03 <dsal> I'm working within someone else's data I can only observe like shadows on a cave.
10:37:05 <Cale> DSum is like a single key/value pair of that sort
10:38:31 <nshepperd1> python objects in turn are basically big records containing a method for each thing you can possibly do with them
10:38:49 <Lycurgus> anyway you look at it kid ur random new struct is likely to require a recompile
10:39:13 <dsal> One part of my program takes a SQL query, runs it against my SQLite database, and for each output row, fetches an ID, grabs the ~opaque blob of JSON from their API, iterates each column of my query output and does a type-specific substitution of a corresponding key in the JSON data.  Super dynamic.
10:40:15 <Cale> I wonder if it would be valuable to make a "two dimensional" DMap
10:41:09 <Guest36> dsal: one way I was getting rid of repetition is to define Series as data Series = Sint [Int], Sstring [String]. 
10:41:35 <Cale> Something which would represent a collection of triples of type (f a, g b, h a b) for various choices of a and b
10:41:45 <Guest36> But then I had to treat many cases in the functions, but the code was the same. 
10:43:08 <Cale> Well, what exactly do you mean "the same"? :)
10:43:18 <Guest36> I'm sorry. I will provide an example
10:43:21 <Cale> You mean, you had code which didn't care about the values in those lists?
10:43:39 <Guest36> No no
10:43:55 <Guest36> Cale: https://gist.github.com/gcoimbra/9becc581a3cecabe1f428db8d90f6393
10:44:05 <Guest36> It's ugly. I know
10:44:19 <Cale> Well, hang on, what's the last line going to be? :D
10:44:30 <Guest36> It's an error. It gets even uglier
10:44:50 <Guest36> Ignore the Either, in other functions I had this same pattern.
10:44:54 <Cale> One thing you could do...
10:45:17 <Guest36> In the right hand, was the same thing. I'm not taking advantage of Haskell type system.
10:45:24 <monochrom> I would delete both eScalarSum and the Series type.  The standard library already have this.
10:45:33 <monochrom> It's called sum
10:45:41 <monochrom> > sum ([1,2,3] :: [Int])
10:45:43 <lambdabot>  6
10:45:49 <monochrom> > sum ([1,2,3] :: [Float])
10:45:51 <lambdabot>  6.0
10:46:08 <monochrom> As a bonus, sum is a static error on [ByteString].
10:46:44 <monochrom> Just use [Int]. Just use [Float]. There is no need for a unitype story.
10:47:07 <opqdonut> generic series operations can be represented with polymorphic list functions
10:47:38 <monochrom> As another bonus, sum works for many data structures, not just list.
10:47:40 <Guest36> monochrom: That function indeed not needed. 
10:47:42 <monochrom> @type sum
10:47:43 <lambdabot> (Foldable t, Num a) => t a -> a
10:47:45 <opqdonut> so you have (++) :: [a] -> [a] -> [a], and could define something like frequencies :: Eq a => [a] -> [(Int,a)]
10:48:23 <Guest36> monochrom: it's redundant. But the series type will also hold other information. Like the name of the series
10:48:26 <Cale> Well, I can see there becoming a problem once we get to DataFrames that are heterogeneous
10:48:37 <Guest36> then I won't be able the standard sum type
10:48:59 <Guest36> Cale: I think that's the problem I ran into. DataFrame with different Series types.
10:49:00 <monochrom> Sure.  data BetterSeriesType a = Ctor{name::String, content::[a]}
10:49:02 <Cale> But perhaps there's a good way to capture the dependency of the type of an entry in a DataFrame on the row and column that it lies in
10:49:32 * hackage simple-cmd-args 0.1.6 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.6 (JensPetersen)
10:49:37 <monochrom> betterSeriesSum :: Num a => BetterSeriesType a -> a
10:49:48 <monochrom> betterSeriesSum (Ctor _ xs) = sum xs
10:50:13 <dmj`> Guest36: you could use GHC.Generics
10:50:34 <Guest36> well, that's exactly what I did, monochrom, but then I need heterogeneous DataFrames, And (Series a) become a problem
10:50:43 <monochrom> Another bonus is that from [Int] you sum to Int, from [Float] you sum to Float, there is none of this "Either Int Float" uncertainty.
10:51:02 * hackage dobutokO2 0.17.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.17.0.0 (OleksandrZhabenko)
10:51:17 <monochrom> Define DataFrame.
10:51:37 <opqdonut> Guest36: you can represent heterogeneous stuff compositionally using something like `BetterSeries (Either String Double)`
10:51:39 <Cale> Or I guess DataFrames more typically have differently typed columns, but usually their rows are all the same type? That seems like an easier thing to model.
10:51:59 <Cale> Of course, nothing in Python enforces that
10:51:59 <opqdonut> or perhaps use a custom element type
10:52:01 <Guest36> monochrom:  need a capability to hold an arbitrarily amount of Series,  these Series don't necessarily hold the same type. 
10:52:15 <Guest36> opqdonut: won't that lead to a really messy code?
10:52:38 <dsal> Another thing to consider: do you need to use int and float?
10:52:46 <opqdonut> not necessarily, but you'll need some helpers to e.g. only sum the Doubles or whatever it is you want to do
10:52:53 <monochrom> What are the operations on DataFrames?
10:53:13 <Cale> https://pandas.pydata.org/docs/reference/frame.html
10:53:25 <Guest36> Yes. Inumerous things. It's very bloated
10:54:18 <Guest36> Cale: the rows contains one item from every column. And the columns are indeed different types. I don't see why it's easier to model.
10:54:39 <Cale> Guest36: Well, that means that each row is a record of the same type
10:54:41 <dsal> What are the possible column types?
10:55:02 * hackage universe-dependent-sum 1.2.0.1 - Universe instances for types from dependent-sum  https://hackage.haskell.org/package/universe-dependent-sum-1.2.0.1 (phadej)
10:55:15 <Guest36> In python, to summarize, Int, Object, limited string, float...
10:55:40 <Guest36> dmj`: I'll learn about Generics
10:56:08 <dsal> Hmm...  That's kind of broad. Scientific covers some of that, but whatever "object" is would be a pain.
10:56:09 <Cale> Guest36: So, *normally* all you'd do is to invent some record type, and have some Map from indices to records
10:56:12 <Guest36> I don't pretend to implement the Object right now. 
10:56:27 <Cale> Guest36: But that doesn't let you easily do stuff like drop columns
10:56:54 <solonarv> I guess you could use one of the row-type libraries out there
10:57:03 <monochrom> It looks like to me, for example, DataFrame.abs presupposes your "table of oh-so-arbitrary-heterogenous elements" to be secretly really [[Int]], or [[Float]], or [[Double]].
10:57:08 <Guest36> Cale: yes. And it won't allow "fast" operations on columns, would it? The premise of a columnar operations in Pandas
10:57:08 <monochrom> Change my mind.
10:57:11 <Cale> Another thing you can do is use something like a DMap f [] or DMap f (Map Key)
10:57:42 <Cale> Where f is some GADT whose values explain what your columns are and what their types are
10:57:54 <Guest36> monochrom: No, I could have Ints and also Floats  at the same tabular structure. 
10:58:23 <solonarv> but you will not have a column that contains both ints and floats?
10:58:26 <Cale> data EmployeeCol a where Name :: EmployeeCol Text; Salary :: EmployeeCol Int
10:58:43 <Guest36> solonarv: no the Column will contain only one type
10:58:57 <solonarv> okay, good, that makes things much easier
10:59:09 <Guest36> The Column is the Series here
10:59:30 <monochrom> I say that there is no need for this mixture of Int and Float.  Just make them all Float.  Change my mind.
10:59:32 <Guest36> monochrom: the common way it's used is: load a csv into a DataFrame. generally, all the columns have the same type in the csv, but different columns can contain different types
10:59:43 <Guest36> monochrom: what about strings?
10:59:54 <Guest36> Make everything string?
11:00:01 <Cale> Guest36: Possibly my suggestion doesn't make sense if you're unfamiliar with DMap though
11:00:07 <monochrom> abs is an error on strings.  So make that a static error.
11:00:17 <Cale> also, it does nothing to guarantee that the series have the same length, which sucks a bit
11:00:29 <Cale> But maybe it's a stepping stone
11:00:40 <Cale> to defining a DataFrame type that guarantees this
11:01:00 <monochrom> I also question the need for DataFrame at all.
11:01:13 <Guest36> No. I'll assert the same length with a function or wahtever
11:01:26 <Cale> The idea is that users of the DataFrame would define a GADT whose values explain all the *possible* columns
11:01:28 <Guest36> monochrom: it makes easier to manipulate tabular data. 
11:01:40 <Cale> and then any given DataFrame based on that type will have some subset of them
11:01:47 <solonarv> you could also end up writing types such that usage looks like: blah :: Series [Int, Int, Float, String] -- meaning a series with columns of type Int, Int, Float, String in that order
11:01:49 <Cale> does that sound like the sort of thing you might want?
11:01:54 <Guest36> Yes
11:02:54 <Guest36> solonarv: I don't think that will be necessary. Because the operations that depend on the type will be defined for a column only.
11:03:04 <Cale> You probably want something more like Vector or at least Data.Sequence, rather than lists for the series. Lists are great for one thing: expressing that you intend to iterate over their elements
11:03:16 <Cale> They're not good for random access
11:03:29 <Guest36> Yes. I am planning to use Vector also
11:03:32 <Cale> IntMap would be another reasonable option
11:03:40 <Guest36> I was using lists because It's easier for me as beginner
11:04:02 <Guest36> monochrom: in the dataframe, it automatically index one column for fast row access
11:04:22 <Guest36> Cale: I'm using IntMap to indexing
11:04:35 <Cale> https://hackage.haskell.org/package/dependent-map-0.3/docs/Data-Dependent-Map.html -- have a look at this
11:05:23 <Cale> hah, just realised that Haddock has made all the types really confusing because of kind polymorphism
11:05:26 <Guest36> Cale: I'll also take a look at that.
11:05:38 <Cale> But anyway...
11:05:47 <monochrom> Guest36: I want you to ponder on this question in the long run.
11:05:57 <Guest36> I know somethings will be limited by Haskell, because the way things are done in python
11:06:20 <Cale> data DSum k f = forall a. k a :=> f a
11:06:40 <Guest36> monochrom: yes. I know it's probably not worth doing in the long run. But it got me learning haskell
11:06:52 <dsal> haskell just requires you to do things that make sense.  python just lets you do things that fail at runtime.
11:06:54 <trimannu49> Hi
11:07:12 <trimannu49> I want to work on the topic "Hasktorch library for neural networks and tensor math" for gsoc
11:07:25 <Guest36> dsal: it's true. I just need to come up with a way to do it in Haskell without too much repetition
11:07:27 <Cale> basically, this means that for any type a, we can take any "key", x :: k a, and a "value", y :: f a, and put them together as (x :=> y) :: DSum k f
11:07:30 <monochrom> In Java and Python etc, there is an Array class, and it has methods {sum, product, any, all...}; and then there is a List class, and it has methods {sum, product, any, all, ...}; and then it has a DataFrame class, and it has methods {sum, product, any, all, ...}  you know the drill.
11:07:36 <Cale> Note that the type a gets forgotten here
11:07:42 <trimannu49> Hello
11:08:01 <trimannu49> is anyone here applying for gsoc?
11:08:07 <Guest36> Cale: that's cool, but it won't be bad for linear accessing?
11:08:17 <Guest36> monochrom: yes
11:08:23 <Cale> Guest36: Well, that's just the start.
11:08:44 <leitao> newbie question: Why can't I run "Prelude> surface :: Shape -> Float" on ghci? I got "Variable not in scope: surface :: Shape -> Float"
11:08:44 <monochrom> In Haskell, we put {sum, product, any, all, ...} under the type class Foldable, and it solves the same problem but it is quite a different concept.
11:08:48 <Guest36> Cale: it's more than I have now. does it uses Generics ?
11:08:48 <Cale> Guest36: DMap is an efficient binary search tree holding many such key/value pairs
11:08:55 <Cale> nope
11:08:57 <monochrom> I want you to ponder why.
11:09:36 <monochrom> When I said I question the need for DataFrame, I had Haskell in mind, not Python in mind.
11:10:02 <Cale> Guest36: So, if I have something like a  DMap Foo Vector  and I have some key  k :: Foo ByteString  then I can do a lookup in the DMap, and if it's successful, I get a Vector ByteString
11:10:24 <monochrom> DataFrame is probably idiomatic in Python but not idiomatic in Haskell.  In Haskell, if you want to solve a problem DataFrame solve, you use another solution.
11:11:05 <Guest36> Cale: I think I can define DataFrame as that
11:11:42 <Guest36> monochrom: yes I kinda understand the differente between typeclasses in Haskell and interfaces in OO. And really, the need for a DataFrame is indeed questionable
11:11:56 <Cale> monochrom: I do kind of sympathise though -- I'm aware that there's a lot of painfully structured, and yet highly valuable data out there in shitty CSV files, and people often want to hastily be able to pick it up and analyse it
11:12:16 <dsal> I know dataframe from R.  It makes sense there.
11:12:20 <Guest36> monochrom: but I think there may be an use case when you want a dataset in a single structure
11:12:33 <Guest36> dsal: isn't very similar to Python's dataframe?
11:12:40 <Guest36> I don't know R
11:12:47 <Cale> If there are hundreds of columns of various types, even the thing that I'm suggesting of defining a GADT that specifies them all might be too tedious to consider
11:12:48 <monochrom> For shitty CSV files you go nuclear and fully existential quantification.
11:13:19 <monochrom> Actually not that bad you just go [[MySumType]]
11:13:57 <Cale> Yeah, in a lot of cases, you probably do, or find some way to cut down the data to just what you're interested in earlier on
11:14:16 <monochrom> Or since you're also talking performance, F (G MySumType) where F and G are perfermant sequence data structures.
11:14:43 <dsal> I don't know pandas.  I tend to do this kind of stuff in R.
11:14:48 <solonarv> leitao: because that is an expression (you are asking GHCi to compute that value), not a declaration
11:15:09 <monochrom> Realistically even the shittiest CSV and JSON are just like 5 cases per element.
11:15:43 <solonarv> if you want a declaration with a type signature, you can do it like this: let foo :: SomeType; foo = ...
11:15:46 <solonarv> (all on one line)
11:16:35 <solonarv> but really at the point where you are writing type signatures for your definitions they should probably go in an actual file
11:17:06 <monochrom> Aaawwww once again please don't use ghci as your editor.
11:17:32 * hackage dobutokO2 0.17.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.17.1.0 (OleksandrZhabenko)
11:17:44 <monochrom> Why do people keep doing this.
11:17:53 <leitao> solonarv: what should I do in order to express that this is a "type declaration"? The full declaration will come further
11:18:13 <leitao> is it something I could/should do?
11:18:35 <monochrom> Once again this is one of those things you can but shouldn't do.
11:19:29 <monochrom> If you read carefully the GHC user's guide you will find one way.  If you learn more Haskell you will find another.
11:19:43 <monochrom> For now put your code in a file and use :load
11:20:32 <solonarv> leitao: in ghci it is "could, but shouldn't" territory
11:20:37 <monochrom> Because without exception an hour later you will be asking "I have entered 10 definitions into ghci by hand.  How do I save?"
11:20:39 <solonarv> really, just put it in a file.
11:21:04 <monochrom> XY problems are infinite lists.
11:21:17 <leitao> Nice. let me start putting my code on a file and loading it. Thanks!
11:21:59 <monochrom> Only 2 things are infinite.  The universe, and XY problem chains.  And I am not even sure about the former.
11:22:42 <Cale> leitao: note that whenever you save your file in your text editor, :r will reload it in ghci
11:23:12 <monochrom> Yeah, :load requires filename, :reload doesn't.
11:24:53 <monochrom> Against XY problems the gods themselves contend in vain.
11:27:31 <dsal> Or go wild and use :{   I never regret that.
11:28:14 <monochrom> That's a case of "sow in tears, reap in joy" or something
11:28:37 <monochrom> Because you begin with :{ sadface but you end with :} happyface
11:28:58 <monochrom> Did you know: xpath comments are (: this is a comment :)  very happy
11:29:39 <solonarv> I didn't know xpath even had comments!
11:29:42 <monochrom> But don't use :{
11:30:30 <monochrom> because the joke will be on you.  You will have a typo.  You will not know you have a typo until you finish and :}.  And you will have to enter the whole thing again to fix the typo.
11:30:59 <dsal> And readline is fun there.
11:31:41 <monochrom> If all editors in the world die and you have only sed and ghci left, you still prefer sed to ghci.
11:31:55 <monochrom> I think I mean s/sed/ed/
11:32:12 <phadej> you can open editor from ghci
11:32:14 <phadej> :e !
11:55:04 <iphy> https://github.com/TokTok/hs-msgpack-rpc/blob/master/src/Network/MessagePack/Server/Basic.hs#L117-L129 is there a way to avoid multiple type classes?
12:31:40 <iphy> or is there even a way to make that "IO" not IO but any monad?
12:36:41 <str1ngs> hello, I would like to package https://radicle.xyz/ for guix. but radicle seems to use stack, and there are no instructions to build bootstrap stack from source. how would I go about bootstrapping stack?
12:40:20 <maerwald> anyone knows vshabanov or if he's here under a different nick?
12:40:26 <maerwald> HsOpenSSL maintainer
12:42:02 <dsal> iphy: That's what the first one does.  They don't look like they're doing the same thing, though.
12:42:23 <iphy> dsal: yeah, they are not doing the same
12:42:34 <solonarv> str1ngs: it actually seems to support cabal as well, from a quick look
12:42:53 <solonarv> I know next to nothing about guix, so I don't know if that's easier
12:42:57 <str1ngs> solonarv: radicle does?
12:43:08 <dsal> iphy: I'd expect    type HaskellType (Returns r) = r    -- and then it'd be roughly the same for both.
12:43:08 <solonarv> this is the repo, right? https://github.com/radicle-dev/radicle
12:43:12 <dsal> er, type HaskellType (Returns r) = m r
12:43:23 <str1ngs> solonarv: that is the rep yes.
12:43:29 <iphy> dsal: m r doesn't work
12:43:37 <solonarv> I see both stack.yaml and cabal.project (as well as a handful of related files for both)
12:43:47 <str1ngs> solonarv: I think if I can use cabal that would be more ideal for a system package.
12:44:34 <dsal> iphy: I don't have enough context right now.  But the difference seems to be that one is using m except for in that case, and the other is using IO, also in that csae.
12:44:46 <iphy> https://www.irccloud.com/pastebin/jD7sKhyp/error.txt
12:46:01 <iphy> dsal: https://github.com/TokTok/hs-msgpack-rpc/blob/master/test/Network/MessagePack/ServerSpec.hs#L47
12:46:27 <iphy> I need some way of unwrapping the IO type
12:46:43 <iphy> hm, I'm going to try something
12:47:07 <iphy> I wrote this code 2 years ago, and now I don't remember why I can't put "Returns (IO String)" there
12:48:47 <ChaiTRex> iphy: IO doesn't contain a value, so it can't be unwrapped. It's a recipe for producing a value, not a value itself.
12:49:27 <iphy> ChaiTRex: I know, but I need to unwrap the IO in the type system so I can determine the correct serialisation function for the value that comes out of the IO once evaluated
12:52:56 <ChaiTRex> iphy: To get a value from an IO 'recipe', do it in a `do` block. do { x <- whateverIOThing; ... }
12:53:22 <iphy> ok
12:53:27 <ChaiTRex> iphy: You can do whatever you want with `x` there, including determining the correct serialization function, because `x` will be a String.
12:54:44 <iphy> ChaiTRex: I'm running the whole server in IO anyway (or rather Server, which is a MonadIO)
12:54:57 <iphy> so yes, I'll `do` at some point
12:55:24 <iphy> but at the point of declaring the RPC method, I need to know how to serialise the return value, once `do`ne
12:56:00 <iphy> so I need to unwrap the "IO" monad there, and ideally I'd be unwrapping any MonadIO, but that fails with the error message above
12:59:39 <iphy> ChaiTRex: makes sense?
12:59:51 <iphy> or am I misunderstanding something?
13:00:11 <ChaiTRex> iphy: I don't quite understand. You have an IO String and you want to further process it?
13:00:40 <str1ngs> solonarv: forgive my ignorance, but would I do just do something like cabal build?
13:01:14 <solonarv> str1ngs: that'll build the project's components, yes
13:01:32 <solonarv> it won't install anything and the binaries will end up somewhere in ./dist-newstyle
13:02:04 <solonarv> cabal install will copy/symlink them somewhere (default is ~/.cabal/bin, but can be changed)
13:03:01 <str1ngs> solonarv: seems witch cabal I would need to install dependencies manually?
13:03:16 <solonarv> no, cabal builds those as well
13:03:22 <solonarv> however it doesn't install ghc for you
13:03:38 <solonarv> (stack does, and will squirrel it away somewhere in ~/.stack)
13:03:58 <solonarv> well, to be precise cabal (and stack) will build *haskell* dependencies
13:04:16 <solonarv> if the project depends on some C library or whatever, that has to be installed already
13:04:51 <maerwald> Erm, guix is based on nix. I don't know if any of this will help
13:06:34 <str1ngs> solonarv: okay, seems it can't find yaml which might be a C dependancy?
13:07:02 * hackage front 0.0.0.6 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.6 (swamp_agr)
13:07:23 <str1ngs> solonarv:  unknown package: yaml (dependency of radicle)
13:08:32 <solonarv> hm, it's on hackage
13:08:35 <str1ngs> solonarv: ah cabal new-build is working. forgive my ignornace
13:08:48 <solonarv> oh sorry, I naively assumed you were using cabal 3.0
13:08:53 <solonarv> you should definitely be using that
13:09:10 <str1ngs> it's okay, it warned me and I should have mentioned that.
13:09:11 <solonarv> the new-* commands are the default in 3.0 so the prefix isn't needed anymore
13:09:23 <str1ngs> okay this is good I think I have enough to package this for guix now.
13:09:47 <str1ngs> thanks for the help solonarv it's appreciated. 
13:09:51 <maerwald> Somehow I doubt that
13:10:15 <maerwald> new-build doesn't work with nix-style packaging
13:12:00 <str1ngs> I could only find instruction building radicle with stack. which I don't this is ideal for package manager.
13:13:29 <str1ngs> guix has a haskell build system that uses cabal IIRC. I just need to research that aspect now.
13:13:56 <str1ngs> I'm a complete haskell noob so don't mind me :)
13:14:29 <maerwald> Yes, it doesn't use new-build
13:14:56 <maerwald> both technologies do the same, they conflict
13:15:14 <str1ngs> radicle does not use new-build? I've not used cabal before so I don't know what to expect.
13:15:28 <maerwald> radicle lets you choose what to use
13:15:34 <str1ngs> I guess my question is can I build radicle with cabal, and how would I do that?
13:33:04 <iphy> ChaiTRex: what I want right now is to turn "a -> b -> ReturnsM IO c" into "a -> b -> Client c"
13:33:08 <kleisli__> it's possible to construct an unambiguous grammar that's not parsable by LALR(1), correct?
13:35:39 <iphy> definitely
14:12:02 * hackage dependent-sum 0.7.1.0 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.7.1.0 (3noch)
14:16:30 <hexagoxel> I am gonna do a bit of live coding on brittany in 4 min at twitch.tv/hexagoxel
14:16:56 <koz_> hexagoxel: Woo!
14:17:00 <maerwald> and I don't have wifi :(
14:17:14 <koz_> (also, I've been misreading your name all this time: I thought it was "hexagonel")
14:17:15 <hexagoxel> don't expect a particularly prepared or educational stream, just some mundane features
14:17:57 <hexagoxel> but always open for question around the formatter and suggestions on best layout and such stuff :)
14:18:28 <MarcelineVQ> koz_: fwiw I read it as hexagogel
14:18:50 <koz_> MarcelineVQ: Something something human perception something something seeing what you want to see something something coriander.
14:19:05 <koz_> Is there any package providing an Arbitrary instance for Map from containers?
14:19:11 <MarcelineVQ> 'No no I said they could train dogs to smell tumeric'
14:21:49 <jumper149> How can I derive an instance Generic (Vector a) regarding https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html ?
14:22:26 <koz_> jumper149: That's probably not a great idea, even if you could.
14:22:30 <koz_> Vector is a data family.
14:22:40 <koz_> What do you wanna do exactly?
14:24:07 <jumper149> I'm using purescript-bridge to share types with frontend and I have something like `data A a = A (Vector a) deriving Generic`, but it seems that the Vector part is a problem here.
14:24:48 <koz_> jumper149: Yeah, you're not gonna get anywhere with that.
14:24:54 <jumper149> I do have the ability to change the vector type here and it won't be too much work. Would you recommend that? And what would I use instead with Generic?
14:25:09 <koz_> Basically, Vector is a data family. This severely limits what can be done with it.
14:25:38 <koz_> What exactly does a Generic derive give you here?
14:27:04 <jumper149> Well first of all deriving Generic for A works fine! That's not the problem, but purescript-bridge doesn't translate the Vector.
14:27:44 <koz_> Ah, I see. Then I dunno, lol. Maybe someone else might be able to help.
14:27:47 <jumper149> I am not too familiar with Generic in general though so I am not sure why it even works here.
14:28:48 <jumper149> I'll just try to make it work with a list for now. That will be a future TODO ^^
14:29:02 * hackage hslua 1.1.0 - Bindings to Lua, an embeddable scripting language  https://hackage.haskell.org/package/hslua-1.1.0 (tarleb)
14:54:32 * hackage chimera 0.3.1.0 - Lazy infinite streams with O(1) indexing  https://hackage.haskell.org/package/chimera-0.3.1.0 (Bodigrim)
14:55:32 * hackage hsc2hs 0.68.7 - A preprocessor that helps with writing Haskell bindings to C code  https://hackage.haskell.org/package/hsc2hs-0.68.7 (HerbertValerioRiedel)
14:58:34 <monochrom> Lazy infinite stream with O(1) indexing sounds like too good to be true...
15:00:01 <koz_> monochrom: Who's promising that and what bridge are they also selling?
15:03:44 <monochrom> the chimera package above
15:03:57 * koz_ investigates.
15:10:31 <ChaiTRex> monochrom: "One can argue that this structure is not infinite, because it cannot handle more than 2<sup>64</sup> elements. I believe that it is infinite enough and no one would be able to exhaust its finiteness any time soon."
15:10:47 <koz_> 'Infinite enough' is some serious hedging.
15:12:31 <monochrom> It doesn't occupy 2^64 bytes up front, so it still has some merit.
15:13:05 <monochrom> Actually I don't know that, I haven't studied it.
15:14:16 <koz_> I _hope_ it doesn't occupy 2^64 bytes up front.
15:17:49 <hpc> make your stream's memory occupy exactly a page, then map it everywhere
15:17:59 <hpc> then it's infinite from integer overflow
15:23:02 * hackage bitvec 1.0.3.0 - Space-efficient bit vectors  https://hackage.haskell.org/package/bitvec-1.0.3.0 (Bodigrim)
15:23:42 <nshepperd2> simultaneous claims that 2^64 is "infinite enough" and also that operations are O(1) because they never take more than log(2^64) steps seem challenging
15:24:02 * hackage lukko 0.1.1.2 - File locking  https://hackage.haskell.org/package/lukko-0.1.1.2 (phadej)
15:24:10 <koz_> log(2^64) is a constant, so it's not _technically_ wrong.
15:29:50 <hpc> nshepperd2: it's true, infinity starts at around 640k
15:29:51 <hpc> :D
15:29:59 <Cale> nshepperd: People also regard pointer dereferencing as O(1), but that's also impossible.
16:14:09 <mlugg> Hi, I think I'm going insane :p  I've written a very basic parser combinator system, and I'm experiencing a very weird bug that I can't work out. The source code is at https://gist.github.com/mlugg/e83b560f0dd01211aa4c86498cfbee88 - it's pretty much what you'd expect from a minuscule Parsec-like thing. I tried to parse some basic Polish notation
16:14:10 <mlugg> expressions with it, but came across an issue which seems to be a infinite loop somewhere. Indeed, when I compile with GHC, I get a <<loop>> at runtime. However, when I use a "wrap" function as I do in that code (see lines 81 and 87), the code runs fine. I can't figure out what's going on, and I don't know if I'm being dumb - can anyone shed some
16:14:11 <mlugg> light on this?
16:17:46 <Axman6> @hoogle (a -> Bool) -> [a] -> ([a], [a])
16:17:47 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
16:17:47 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
16:17:47 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
16:18:05 <Axman6> span might be useful for number
16:18:38 <Axman6> > span isDigit "123abc789"
16:18:40 <lambdabot>  ("123","abc789")
16:20:07 <mlugg> Huh, neat
16:21:22 <Cale> but... this is still kind of weird... wrap is morally the identity function
16:21:32 <Axman6> yeah wrap shouldn't be doing anything
16:22:00 <Cale> I've confirmed that it does appear to completely change the behaviour of the parser
16:22:42 <mlugg> I'd want to say it's a GHC bug but I'm not exactly doing anything obscure
16:23:19 <Axman6> it's almost certainly not a GHC bug
16:24:50 <Cale> oh
16:24:54 <Cale> data vs. newtype
16:25:04 <Cale> Change Parser to a newtype and you won't loop
16:25:11 <mlugg> Why's that?
16:25:42 <Cale> Because then pattern matching on Parser p won't actually force the evaluation of the argument
16:26:03 <Cale> What's happening is that <|> and <*> are forcing the evaluation of their arguments
16:26:08 <Cale> and so when expr is evaluated
16:26:22 <mlugg> Ohhhhhhhh
16:26:25 <mlugg> I'm dumb
16:26:28 <mlugg> Thanks
16:26:29 <mlugg> :)
16:26:32 * hackage hurl 1.3.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.3.0.0 (alcinnz)
16:26:34 <Cale> <|> wants to evaluate (Add <$ char '+') <*> expr <*> expr
16:26:40 <Cale> and then <*> wants to evaluate expr
16:26:43 <Cale> yeah
16:26:48 <Cale> it's subtle
16:28:52 <hpc> this reminds me of some of the examples for how irrefutable patterns work
16:32:20 <oats> do y'all prefer using monadic or applicative parser combinators?
16:32:28 <oats> I haven't figured out which side of the fence is greener yet
16:32:34 <mlugg> I prefer applicative in most cases
16:33:15 <Cale> I usually end up wanting to name some intermediate results at some point
16:33:36 <Axman6> both?
16:34:00 <Cale> If you have Monad, you have Applicative too, so meh
16:34:21 <Axman6> depends on if the grammar is context free or not, most are mostly context free, and occasionally seen some context (like parse n things where n comes from the input)
16:40:14 <jumper149> This shit just cost me so much time... big oof (just merge it already) https://github.com/eskimor/purescript-bridge/pull/47/files
16:49:27 <mlugg> Do the <*> and <|> operators have English-ey names? Or are they just "the applicative one" and "the alternative one"?
16:51:33 <monochrom> ap, alternative
16:53:56 <mlugg> Okay, ty
16:55:04 <oats> "person clutching their head in panic" and "stern mother, hands on hips"
16:56:32 * hackage openid-connect 0.1.0.0 - An OpenID Connect library that does all the heavy lifting for you  https://hackage.haskell.org/package/openid-connect-0.1.0.0 (PeterJones)
17:09:21 <koz_> Is this the right way to form a --with-rtsopts saying 'at runtime, use all the processors you can': --with-rtsopts='-N'?
17:10:26 <koz_> Never mind, didn't need the quotes.
17:11:18 <monochrom> the quotes don't hurt either, it's OK
17:18:54 <maerwald> anyone using the new weeder? It's weird, it shows me 5034839 lines of weed, 90% of it is from dependencies I cannot change anyway
17:18:58 <maerwald> what's the point?
17:19:06 <koz_> mlugg: <*> is named 'app' or 'splat'. The other one, unsure.
17:19:25 <koz_> maerwald: 5034839 lines of weed sounds like something else. :P
17:19:41 <monochrom> What is weeder?
17:19:42 <maerwald> *sniff*
17:19:44 <mlugg> "splat" is my new favorite operator name
17:19:51 <maerwald> https://github.com/ocharles/weeder#readme
17:20:18 <monochrom> ah, neat
17:20:24 <maerwald> works without stack
17:20:29 <maerwald> the old one required stack
17:21:12 <maerwald> but if you use source repositories, I think it messes up your results
17:22:50 <maerwald> the dhall configuration was really unnecessary imo 
17:22:56 <maerwald> it's just 2 fields -.-
17:23:53 <maerwald> ok, enough complaining, I should write patches
17:24:09 <monochrom> Join my new "toolchain vegetarian" movement! It means minimalism for toolchains.
17:25:18 <maerwald> imo, this should/could just be a GHC warning!
17:25:47 <maerwald> and while at it, let's turn GHC into a language-server
17:47:10 <dmj`> :t transpose . fmap reverse
17:47:11 <lambdabot> [[a]] -> [[a]]
17:57:07 <dmj`> @def rotMatrix n xs = iterate (transpose . fmap reverse) xs !! n
17:57:09 <lambdabot>  Defined.
17:59:18 <Axman6> that feels like it would be cyclic
18:00:14 <Axman6> > map (\n -> rotMatrix n [[1,2],[3,4]]) [1..10]
18:00:16 <lambdabot>  [[[2,4],[1,3]],[[4,3],[2,1]],[[3,1],[4,2]],[[1,2],[3,4]],[[2,4],[1,3]],[[4,3...
18:00:27 <dmj`> Axman6: yes, exactly
18:01:08 <dmj`> Axman6: so if someone asks you a hypothetical interview question to display a triangle in the console. You can construct the triangle horizontally very easily, and then use this function to rotate it
18:01:23 <dmj`> and then mapM_ putStrLn
18:01:40 <glguy> monochrom: I prefer to kill living things when I build my projects
18:02:32 * hackage cryptoconditions 0.2.5 - Interledger Crypto-Conditions  https://hackage.haskell.org/package/cryptoconditions-0.2.5 (ssadler)
18:02:43 <monochrom> <*>
18:02:46 <monochrom> :)
18:02:56 <Axman6> I got a recruitment email from BAE systems the other day, so you could try them glguy :P
18:20:02 * hackage equational-reasoning 0.6.0.2 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.6.0.2 (HiromiIshii)
18:20:15 <dmj`> ya gotta feed the military industrial complex
19:45:16 <sarahzrf> ew
20:32:04 <alunduil> I'm trying to figure out why I get this error (https://gist.github.com/alunduil/f99d0a27f96803c602d040fd6ba17edf) when running this script (https://gist.github.com/alunduil/7b1805868013358f031d68b74b067367) on this project (https://github.com/alunduil/zfs-replicate/tree/haskell-experiment).  I'm sure it's something obvious but I'm confused as to why cabal is checking for warnings in dependencies that don't pass those 
20:32:04 <alunduil> warnings.
20:41:07 <alunduil> Also, my /etc/os-release: https://gist.github.com/alunduil/40b620caa0a05d883a707ee6b3670f7a
21:11:53 <dmwit> alunduil: I mean, do you have ar installed?
21:12:05 <dmwit> If not, then... install it, I guess.
21:12:34 <dmwit> It's a pretty basic tool. You won't be sad to have it available.
21:12:54 <dmwit> On my machine, the package that provides it is named binutils. YMMV
21:15:12 <alunduil> @dmwit I would hope so if it's part of the toolchain deps but it's possible I don't.  Let me look at that output again.  How did you spot that it was missing ar?
21:15:12 <lambdabot> Unknown command, try @list
21:15:47 <alunduil> dmwit: now I see it.  Thanks for the pointer.
21:17:54 <alunduil> dmwit: that error seems unrelated to the bigger error at the bottom.  After adding ar and ensuring it's in my path I still get the same output (minus the missing ar command).
21:33:39 <dmwit> show transcript
21:42:54 <alunduil> dmwit: https://gist.github.com/alunduil/a0eb76ad40a85e3f4bcba4aef2e69d4d
21:49:42 <dsal> heh.  This isn't the prettiest, but it's useful.  mapConcurrentlyLimited :: (MonadMask m, MonadUnliftIO m, Traversable f, Foldable f) => Int -> (a -> m b) -> f a -> m (f b)
21:50:09 <dsal> Also...   deriving (Applicative, Functor, Monad, MonadIO, MonadUnliftIO, MonadCatch, MonadThrow, MonadMask, MonadReader Env, MonadFail)
21:50:23 <dsal> I'm curious how this would look in polysemy
21:54:24 <dmwit> alunduil: Looks like a GHC version compatibility issue. But at least it should be clear-ish how to fix it.
21:55:47 <dmwit> alunduil: In fact, it looks to already be fixed in the latest unreleased version.
21:55:51 <dmwit> https://github.com/pcapriotti/optparse-applicative/commit/6f4053b35c64c06a7e2bd55218989c0c0815b22a
21:56:29 <dmwit> So I guess either wait for a release or build from master? You could also try using older versions and see if you can find one from before the offending -Werror
21:56:31 <alunduil> dmwit: I'll grab that version then or wait until it's released.  I saw this earlier with the latest aeson as well so I thought it was something with my setup.
21:57:15 <alunduil> dmwit: thanks for the sanity check!
21:59:27 <dkdk> Hello All :)  
22:04:08 <dkdk> I am building a university web app for a client, although I don't had enough web experience but I successfully managed to do frontend and other basic stuffs, Now the client want me to integrate socks5 proxy security, can someone please give me pointers, I found this library `socks` on hackage but still I'm unsure how to use it for my use case, what
22:04:09 <dkdk> we want, is this proxy server should sit between client and actual server and then monitor the traffic additionally do the routing based on some condition too. Can someone please help as I don't have enough networking experience too. Thanks in adv.
22:05:19 <dsal> Socks... that's a name I've not heard in a long time.
22:05:37 <dkdk> http://hackage.haskell.org/package/socks-0.6.1 this library 
22:07:40 <dkdk> with this example https://github.com/vincenthz/hs-socks/blob/master/Example.hs but I'm unsure if I understand the basic, or specifically how I can use this library with my servant server
22:08:20 <dkdk> any help will be highly appreciated ☺️
22:10:07 <phadej> AFAIK `socks` is for implementing clients, not servers
22:12:35 <dkdk> ohh, can you please suggest what I need to do for supporting my requirement ? I'm confused
22:12:54 <dkdk> phadej: ^
22:13:27 <phadej> Unfortunately I don't know anything about socks5 :(
22:13:47 <Axman6> looks like OpenSSH can provide SOCKS5 proxying... though why do you need SOCKS and not the much more common HTTPS plus authentication?
22:14:18 <Axman6> who is making the decision it must be SOCKS? It's a very unusual thing these days
22:14:45 <dkdk> Axman6: my client for whom I'm developing
22:15:21 <Axman6> and why does your client think this is what they need?
22:15:47 <Axman6> Do they have the technical experience to know what SOCKS is, and why it should be used instead of something more common?
22:16:38 <dkdk> they said for securing their content from attacks and monitoring purposes, yeah they are technical.
22:17:00 <Axman6> Have you asked them why using HTTPS wouldn't be appropriate?
22:17:06 <dkdk> I read about OpenSSH 
22:17:43 <Axman6> because if someone asked me to add SOCKS to an app, that wqould be setting off lots of alarm bells for me, because it's how things were done maybe a decade or more ago, but not these days
22:18:08 <dkdk> I asked but they told no we want specifically SOCKS5
22:19:46 <dkdk> secondly I'm also not sure about what they actually want to do, as they say to secure our data, they pretend from China. 
22:20:19 <dkdk> they will allow me to work for them only If I implement this 
22:20:48 <Axman6> Sounds like a great way to get a hacked together system which has the impression of security but is unlikely to actually provide it, particularly if they can't provide a specific reason. If it were me, I would be asking _a lot_ of questions
22:22:20 <iqubic> Same here.
22:23:26 <dkdk> Yeah I am also feeling the same, point is I was looking for a Haskell Job they came and asked to do this 
22:24:02 <Axman6> Like, if they couldn't explain to me what they believe the differences between HTTPS and SOCKS are, and why they need the latter because of deficiencies in the former, then I would be very strongly considering whether I wanted to keep working for them (If I had a choice)
22:26:04 <dkdk> btw, since I'm also developing a web app for me, when I read about sock5 I found that as a way to secure my web resources from general crowd and I thought, If I implement it for them it will also benefit for my project, for security reasons purely.
22:27:19 <dkdk> when I ask too many questions from them they say , if you can't do then we will look for another Haskell Developer 
22:28:29 <dkdk> I read this article and it supports using SOCKS5 for a secured system
22:28:32 <dkdk> https://securityintelligence.com/posts/socks-proxy-primer-what-is-socks5-and-why-should-you-use-it/
22:30:18 <phadej> Aside from traffic forwarding, proxy servers provide security by hiding the actual IP address of a server. -- suggests that you don't want the proxy to be in your application
22:30:46 <phadej> but rather a separate proxy between clients and servers
22:31:21 <N3RGY> How do I set a build flag for a dependency when using stack? e.g. If I want to build cryptonite with -f support_sse
22:31:41 <Axman6> It definitely feels odd to provide a SOCKS proxy which is open to the internet, but it'd been too long since I've even thought about them to remember if that is a bad idea or not
22:32:13 <Axman6> N3RGY: --flag cryptonite:support_sse
22:32:32 <N3RGY> Axman6: What section does that go in?
22:32:34 <dkdk> They said they want this for University Internet
22:32:37 <dmj`> stack build --flag cryptonite:-support_sse
22:33:25 <N3RGY> dmj`: If I don't want to provide that flag every time, where would I put it in a package.yaml or stack.yaml?
22:33:41 <dmj`> stack.yaml
22:33:55 <dmj`> since its for a dep.
22:33:56 <Axman6> https://docs.haskellstack.org/en/stable/yaml_configuration/#flags
22:34:14 <N3RGY> thanks Axman6
22:35:41 <dkdk> so what should I do ? leave this client ? 
22:36:58 <phadej> Or try to understand what problem they are trying to solve
22:37:13 <phadej> strong feeling of XY-problem case
22:37:18 <dkdk> they don't tell much
22:37:26 <dkdk> I asked many times
22:37:57 <Axman6> yeah that's the most important thing. IMO any client who says "We need X" without explaining why they need X or why they can't use alternative Y isn't one I want to work for. It's unprofessional
22:39:55 <dkdk> Yeah, reason is I don't have any other options with me , currently unemployed for long, but working for this type of thing look suspicious too.
22:40:36 <Axman6> To me it's mostly suspicious because this is not how things are done these days, unless there's a good reason
22:42:00 <Axman6> As far as I see it, your options are to figure out how to use something like OpenSSH as a server. I would also find out, if they are using SOCKS for other projects in the university, how they manage those - what do they use for authentication, do they hook into the university Active Directory/LDAP or something? What sortware are they using to provide SOCKS elsewhere?
22:43:04 <dkdk> they told shadowsocks
22:44:10 <dkdk> I think I should leave them, as not working will be better than working for something illegal 
22:48:07 <Axman6> I mean, it' snot illegal, based on anything you've said, it's just technically highly unusual
22:48:28 <Axman6> it's certainly doable, but it's a very strange thing to be asked to do.
22:49:03 <Axman6> If they can get you in touch with whoever manages a shadowsocks deployment somewhere else in the university then you can find out how it should be done
22:49:32 <dkdk> ohh, Isn't this something which could be used in hacking or something illegal, as they have not provided me any source code
22:50:29 <dkdk> University thing is also only in talks 
22:51:46 <Axman6> Based on what you've said I can't see any indication that anything illegal or that could be used for hacking is going on. If it's a web application, I assume you know what the web application is actually doing?
22:52:43 <dkdk> I don't know anything about them, and the linkedIn profile looks like of a service based it company
22:54:06 <dkdk> ```Experienced software programming Professional with a demonstrated history of working in the investment management software projects. Skilled in Website, Server management and project management. Strong software professional with a Master of Management focused in security management from Beijing University of Information Technology.
22:54:07 <dkdk> ✅ Web Frontend Development Skills
22:54:07 <dkdk> ~ AngularJS, React.JS, Redux, ES6, Vue.js, Ember.js, Node.js,
22:54:08 <dkdk> ~ Bootstrap, Foundation by Zurb, Semantic UI, Pure, UIKit
22:54:08 <dkdk> ✅ Web Backend Development Skills
22:54:09 <dkdk> ~ Python : Python 2.x, Python 3.x, Django, Flask, Pyramid, Web2py
22:54:09 <dkdk> ~ PHP : Laravel, CodeIgniter, Yii
22:54:10 <dkdk> ~ Asp.net : C#/C/C++, asp.net mvc, asp.net web form, asp.net web api, .net framework, entity framework
22:54:10 <dkdk> ~ JSP : Spring Boot, Java, Spring Framework, Spring MVC,
22:54:11 <dkdk> ~ Database: MySQL, MSSQL, MongoDB, Postgresql, SQLite, Oracle, SQL Server
22:54:11 <dkdk> ✅ Project Management Tools
22:54:12 <dkdk> ~ Git, Github, BitBucket, Jira
22:54:12 <dkdk> ✅ Cloud Server
22:54:13 <dkdk> ~ Amazon AWS, EC2, Google Cloud, App Engine, Azure, XMPP, Bluehost, Digital Ocean, Firebase...
22:54:54 <Axman6> gosh, what a buzzword soup
23:13:50 <dsal> Oh man, I used StateT and then remembered my app wanted unliftio.  I *almost* don't need state.  So close.
23:16:45 <dmj`> unliftio?
23:20:04 <Axman6> state is just a poor man's ReaderT (IORef State) :P
23:26:46 <iqubic> Ew...
23:27:03 <iqubic> What is unliftio?
23:31:51 <Axman6> nah ReaderT (IORef s) is an awesome pattern
23:44:52 <N3RGY> Does ReaderT . IORef not fall afoul of the write barrier? 
23:45:04 <vaibhavsagar> eww Axman6, are you okay
23:46:08 <tdammers> "required skills: 10+ years experience with all the things"
23:46:25 <N3RGY> I have to imagine that StateT is faster than ReaderT . IORef in a lot of cases, because the state values will probably mostly not live through the first GC and won't cause issues with the write barrier
23:46:47 <N3RGY> Except insofar as it might confuse the optimizer
23:46:56 <N3RGY> Especially with deeply nested MTL stacks
23:46:57 <vaibhavsagar> my problem with ReaderT (IORef s) is that I can't implement an interface that would allow me to treat it exactly the same as State
23:47:03 <vaibhavsagar> the implementation details leak out
23:47:49 <tdammers> you can, however, write a function StateT s IO a -> ReaderT (IORef s) IO a
23:48:02 <vaibhavsagar> or maybe I'm thinking of the version with STRef?
23:48:08 <tdammers> and of course also, trivially, State s a -> ReaderT (IORef s) IO a
23:49:32 <N3RGY> ReaderT . IORef feels like A) a hack and B) giving up, and if we don't have the pressure to make (pure) state monads better, we'll probably never invest enough into figuring out how to do this correctly (though fancy effect monads or whatever)
23:51:22 <vaibhavsagar> if you are already definitely using IO, it's fine
23:51:24 <vaibhavsagar> IMO
23:51:55 <N3RGY> And now that I'm thinking back on it, isn't the only reason that Tweag (succesfully) evangelized ReaderT . IORef that StateT doesn't compose well with EitherT, performance wise? That seems like something we can fix rather than throwing out purity
23:52:25 <N3RGY> Not that I blame them for taking the shortcut
23:54:03 <dsal> I implemented unliftio for my state. That's not exactly the right thing to do, but it almost doesn't matter.  The way I'm actually using it, it's not wrong, but I may reconsider.
23:57:25 <dsal>  Mind is kind of blown that this worked on the first successful compile, though.  I reverse engineered GoPro's upload to cloud mechanism which is... complicated.  My tool is currently uploading a file with ~3 concurrent upload workers (since it does it in chunks).  That it even started means I probably got this right.
23:57:56 <N3RGY> Nice. What are you uploading to their cloud for/what is the purpose of the tool?
23:59:23 <dsal> GoPro Plus is $5/mo for unlimited storage, but their interface is pretty awful.   So I wrote my own stuff.  It syncs all metadata down to a local DB, has a little web UI (learned elm).  I wrote a parser for their metadata format (which is amazing) and worked around a ton of bugs.  :)
