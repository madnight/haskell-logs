00:04:44 <Eduard_Munteanu> kenran, case-of on result?
00:05:16 <Eduard_Munteanu> There was a helper to turn Result into Either if you know you're passing the entire input to the parser.
00:05:36 <Eduard_Munteanu> I think.
00:07:18 <kenran> Eduard_Munteanu: ah, that helper looks useful (parseOnly), thanks :)
00:07:48 <kenran> but yeah, I might need to go the case route if I want to check the "rest" to be correct as well in some cases
01:04:25 <Phyx-> jackdk: that looks like a codepage issue. does your input arguments contain any non-ascii characters?
01:07:20 <furnost> I have a function that return a "ExceptT ErrMsg IO Person" how can I pass the result of that to a function "Person -> ExceptT ErrMsg IO String" ? 
01:07:56 <furnost> * without unwrapping it all
01:08:08 <jackdk> Phyx-: not sure. I'm trying to help a student on win10. He said his locale was set to english (canada) but also failed there
01:08:20 <jackdk> furnost: that's >>=, right?
01:08:59 <Phyx-> jackdk: what are they running it in?
01:09:38 <jackdk> Phyx-: I don't understand your question. This was GHC 8.6.5, installed from chocolatey (if they followed our instructions, which many don't)
01:09:53 <jackdk> and the build of happy was kicked off as a dep by cabal-install 3.0.0.0
01:09:56 <furnost> jackdk: that's what I thought, but I have an Expected Type of ExceptT ErrMsg IO Person" Actual type: "Person"
01:10:14 <jackdk> furnost: you will have to show a pastebin
01:10:43 <Phyx-> jackdk: i mean which terminal
01:12:57 <Phyx-> jackdk: in any case, I believe en_CA is a non-ASCII set, so have them try changing the terminal codepage. i.e. running chcp 863 or chcp 65001 anytime they open a new terminal
01:13:00 <furnost> jackdk: yes, of course: http://dpaste.com/1BMEYVR
01:17:12 <jackdk> furnost: is your error on line 4?
01:17:54 <furnost> yes
01:20:46 <jackdk> furnost: if I desugar  the `do` in `shouldInformNewContact'`I get `getPersonWithToken'' conn token >>= (\res -> res >>= storeNewContactInformation' conn phone)`
01:21:06 <jackdk> furnost: this is why the typechecker is telling you that `res` is already a `Person`
01:21:37 <jackdk> furnost: you probably want `getPersonWithToken'' conn phone >>= storeNewContactInformation' conn phone`
01:22:38 <furnost> jackdk: exactly... thank you!
01:27:10 <jackdk> Phyx-: I have asked but won't expect a response for a while. Thanks for the idea
02:36:32 * hackage th-instance-reification 0.1.5 - Fixed versions of instances reification functions  https://hackage.haskell.org/package/th-instance-reification-0.1.5 (NikitaVolkov)
03:17:21 <Phyx-> jackdk: if all goes according to plan GHC 8.12 should do the right thing on Windows wrt encoding and codepage
03:30:16 <jackdk> Phyx-: I look forward to that glorious day
03:31:18 <tdammers> if that is true, then I bow before those who made it happen
03:35:41 <MarcelineVQ> any particular windows? :o
03:45:18 <merijn> hmm, so are there any alternatives for plotting data other than Chart?
03:47:23 <Uniaika> merijn: output JSON and use D3.js :P
03:47:29 <Uniaika> (/s)
03:50:24 <__monty__> merijn: I think diagrams has some support for plotting.
03:50:42 <__monty__> https://archives.haskell.org/projects.haskell.org/diagrams/gallery/Chart.html
03:51:24 <__monty__> Or is that the Chart you were referring to?
03:51:47 <[exa]> typicky ten chlorovatej chinin funguje proste tim ze otravi cerveny krvinky takze se v nich nejde mnozit moc
03:52:00 <[exa]> oh noes, wrong channel, sorry
03:52:38 <merijn> __monty__: Chart uses diagrams as backend
03:53:06 <merijn> __monty__: But 1) development seems mostly stalled/stopped, and 2) the diagrams backend of that is ugly as sin
03:53:22 <merijn> I'm not sure that's due to Chart or due to diagrams, but either way
03:53:33 <Taneb> merijn: http://hackage.haskell.org/package/plots ?
03:53:42 <merijn> __monty__: Oh wait, you even linked to the Chart page of diagrams >.>
03:55:06 <merijn> Taneb: That looks even more stalled than Chart and with less features
03:56:00 <Taneb> merijn: I can't comment on features but I know and can pester the developer
03:57:25 <merijn> Like, most of them seem to be about 80% of the way there in terms of supported features, but with very...mixed APIs. It seems like providing a nice plotting API in Haskell should be easy... :\
04:26:53 <Phyx-> MarcelineVQ: yes, the new I/O manager is almost done.. we will still be limited by gcc and binutils not supporting wide chars. But I have a workaround for that that I'll look into later
04:28:14 <Phyx-> MarcelineVQ: well, for all supported versions of Windows, This means Windows 7 and up. because the I/O manager uses an interface not available before. and we also changed the locking primitives for faster ones which are also not available before etc
04:46:13 <MarcelineVQ> Phyx-: ah 7 too that's good to know thanks
04:51:36 <magicman> Is there a function :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a that is like "this function if both are Just, otherwise the first that's not Nothing"?
04:52:17 <magicman> I'm drawing a blank. Seems like a thing that should exist, though...
04:53:20 <hpc> liftA2
04:53:24 <Taneb> hpc: has the wrong behaviour
04:53:32 <magicman> That one will Nothing out if we have a Nothing.
04:53:40 <magicman> This is like the liftA2 equivalent of <|>.
04:53:55 <magicman> Instead of <*>
04:54:13 <hpc> hmm, not sure it exists then
04:54:48 <hpc> (f <$> a <*> b) <|> a <|> b -- perhaps this then
04:54:56 <Uniaika> I mean, that's a case expression and a couple of boolean tests? 
04:55:02 <magicman> It's pretty much what instance Monoid Maybe does, but that assumes a Monoid a.
04:56:12 <magicman> Yeah, solving it with explicit cases. Was wondering if there was something pre-built for this.
04:57:30 <MarcelineVQ> hpc's  liftA2 f a b <|> a <|> b  is pretty concise
04:58:12 <MarcelineVQ> aesthetically compliments the type sig
05:27:02 * hackage iproute 1.7.9 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.7.9 (KazuYamamoto)
05:53:13 <chloekek> Is it possible to pass O_CLOEXEC when opening a file? fcntl after opening suffers from race condition in a multi-threaded program.
05:57:39 <opqdonut> chloekek: would https://hackage.haskell.org/package/hpath-posix-0.13.1/docs/System-Posix-FD.html work?
05:58:02 <opqdonut> with https://hackage.haskell.org/package/hpath-posix-0.13.1/docs/System-Posix-Foreign.html#v:oCloexec
06:00:27 <chloekek> opqdonut: thanks! With fdToHandle this should do the trick.
06:00:52 <opqdonut> I basically just hoogled cloexec and followed the trail a bit
06:03:30 <chloekek> Right, hoogle exists. I was looking on duckduckgo and it didn’t find anything relevant.
06:05:04 * merijn sighs
06:05:16 <merijn> I hate classy APIs
06:08:05 <merijn> https://hackage.haskell.org/package/Chart-diagrams-1.9.3/docs/Graphics-Rendering-Chart-Backend-Diagrams.html
06:08:41 <merijn> Ok, so that renders a "BackendProgram a", but absolutely zero points how you get one and where it's from and the type links to some opaque inner module :\
06:09:35 <merijn> Might as well use matplotlib if I'm gonna have to deal with this sorta mess of an API >.>
06:19:36 * [exa] still hoping that ggplot's half-done specialized lenses sometime make it to haskell
06:21:30 <merijn> Honestly, I wish we just had a sensible plotting API that *isn't* a massive jumble of lenses and classes that are barely documented without any detectable form of coherent design. It seems like a nicely composable API for plotting should be fairly simple in Haskell, yet all the things I see are just gross
06:22:00 <[exa]> haskell implementors have the bias of overgeneralizing
06:22:40 <merijn> [exa]: Overgeneralisation isn't the issue there. Lack of coherent API design is
06:23:07 <[exa]> that's the best thing on ggplot, internally it could do much more but it seems that it was just cut down by decision to ~10 types of aesthetics. and done.
06:23:22 <merijn> It's the "throw everything at the wall and see what sticks" API design with too much focus on "nice" pseudo DSLs with lens combinators, over simple datatypes and clear functions
06:23:33 * merijn sigh
06:24:01 <[exa]> merijn: in case of Chart I kindof believe that the API incoherence is there right because of trying to support too much
06:24:02 <merijn> I was just gonna use gnuplot, but then I saw the gnuplot wrapper was by Thielemann, so that's right out >.>
06:24:11 <[exa]> :D
06:25:10 <[exa]> I have ggplot on the porting list, I'll certainly brag about it here when it starts producing pictures
06:25:31 * hackage pantry 0.4.0.1 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.4.0.1 (MichaelSnoyman)
06:27:32 * hackage dobutokO2 0.12.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.12.0.0 (OleksandrZhabenko)
06:29:19 <merijn> I don't even think designing a reasonable API would be that much work, but then I'd need to figure out how to render the result and *that* seems like a lot of work >.>
06:30:10 <srk> then you decide you want layouts, axes, grids..
06:30:20 <srk> and it quickly explodes :D
06:30:41 <merijn> srk: That's the part I actually have ideas about what I want my API to look like
06:30:49 <merijn> It's the drawing of those things that's the hard part
06:31:25 <srk> 2d/3d or both? I'm now doing 2d plots in opengl 
06:31:36 <srk> hm, surface plots would be nice as well..
06:31:40 <zincy_> Is there a generic way of converting between record types which have the same shape?
06:31:44 <merijn> srk: Just 2d, but I want to output files
06:32:06 <srk> you could still use opengl, just not with a window
06:34:37 <merijn> srk: Naively you simply want a datatype for the viewport which is where you specify the x/y of what's rendered and has a set/sets of axes and grids and plotting takes such a viewport + a set of lines and/or sets of points, most of the properties you wanna set on lines/pointsets/axes/grids can easily have nice monoidally composed interfaces
06:35:50 <srk> merijn: I'm doing exactly what you describe atm :)
06:35:53 <merijn> srk: But most of these APIs throw everything on a big heap with tons of lenses to tweak things, rather than just having explicit datatypes for all these things that you compose monoidally
06:36:15 <merijn> srk: What are you using? Or just calling OpenGL directly?
06:36:20 <srk> merijn: have a demo of blendish/nanovg/lambdacube but switching lambdacube part to glpipe so I can better specify viewports
06:36:43 <srk> lambdacube would need hacks, glpipe looks interesting
06:37:09 <srk> goal is 3D vis tooling with 2D UI via nanovg/blendish
06:37:52 <merijn> srk: That sounds like it's not quite usable, even experimentally, though?
06:39:02 <srk> merijn: yep http://48.io/~rmarko/2020-03-17-143726_1920x1080_scrot.png
06:39:54 <infandum> Is it plausible that rebooting a server would change 10% productivity to 70% productivity in profiling a program?
06:40:16 <srk> mostly an experiment at this point, about to start refining it into glpipe, multiple files and a DSL
06:40:26 <srk> also needs layouting and maybe FRP as well
06:41:04 <merijn> srk: I'm just gonna go back to calling good old gnuplot from System.Process, I guess
06:41:37 <srk> I need interactivity
06:52:37 <zincy_> I see there is records-sop
06:52:41 <zincy_> Has anyone used it?
07:24:01 * hackage validation-selective 0.0.0.0 - Lighweight pure data validation based on Applicative and Selective functors  https://hackage.haskell.org/package/validation-selective-0.0.0.0 (shersh)
07:24:54 <zincy_> Are you generally better off prefixing record field names to avoid clashes?
07:25:24 <zincy_> data Person = Person { _personAge :: Int , _personName :: Text }
07:26:04 <srk> depends, personally I don't like the repetition but if your data type has lots of common fields..
07:26:27 <opqdonut> the _ prefix is often for lenses btw
07:28:24 <zincy_> Ok so yes if there are lots of common fields
07:52:52 <merijn> heh
07:53:01 <merijn> You need -XTypeFamilies for equality constraints?
07:53:49 <lyxia> TypeFamilies or GADTs
07:58:46 <merijn> Several atrocities to good taste later: https://gist.github.com/merijn/384451fc947eeb36655d3f8c422699f6
08:01:49 <srk> merijn: you know about this one https://hackage.haskell.org/package/gnuplot right? :)
08:02:02 <merijn> srk: Yes, but it's a Thielemann package
08:02:31 <srk> merijn: what does that mean? :)
08:02:52 <merijn> srk: Ah, you've not been exposed to his...unique..naming style?
08:02:53 <geekosaur> every class is C, every type is T, all must be fuly qualified to use them
08:03:12 <geekosaur> this also makes the haddocks "fun" to read
08:03:15 <srk> merijn: not quite :)
08:03:30 <merijn> srk: What geekosaur said, just browse the docs for some of his packages...
08:03:38 <srk> I see!
09:07:02 * hackage plaid 0.1.0.4 - Plaid.com api integration library  https://hackage.haskell.org/package/plaid-0.1.0.4 (v0d1ch)
09:13:35 <merijn> Any nice way to filter a list with the filter restricted to the first N elements?
09:14:23 <merijn> splitAt and then filtering the first list, I guess?
09:16:26 <MarcelineVQ> seems like it, I've had to do similar with split up filepaths recently
09:18:02 <jle`> if you already have lenses you can do a over (taking 2 traverse) (filter p)
09:18:10 <jle`> s/2/n
09:18:26 <jle`> er
09:18:32 <jle`> over (taking n id) (filter p)
09:18:43 <jle`> i wonder if there's a nicer way of writing taking n id
09:21:28 <Phyx-> `/win 1
09:28:27 <kolu> hey guys
09:28:33 <kolu> can you recommend a good read
09:28:48 <kolu> about types, type classes, type inference and everything type related
09:29:01 <kolu> I'm having a really difficult time grasping these concepts
09:29:53 <kolu> a my programs usually don't run because i've passed the wrong type
09:30:49 <kuribas> kolu: any decent haskell course should explain them
09:31:05 <dmj`> kolu: typing haskell in haskell
09:31:10 <dmj`> @google typing haskell in haskell
09:31:12 <lambdabot> http://www.google.com/url?q=https://web.cecs.pdx.edu/~mpj/thih/thih.pdf
09:31:12 <lambdabot> Title: Уведомление о переадресации
09:32:00 <dmj`> kolu: this is also a good video of implementing Algorithm W from Grabmueller's Algorithm W step-by-step https://www.youtube.com/watch?v=ytPAlhnAKro
09:32:28 <dmj`> kolu: oh, sorry I thought you wanted to implement these things
09:34:39 <kuribas> kolu: otherwise just practice...  If you're stuck, come back here :)
09:41:31 <kolu> thank you for the link and video
09:41:42 <kolu> haskell is not so easy to practice in :)
09:41:49 <kolu> very frustrating at times
09:42:31 <dmj`> kolu: yes, GHC is very unforgiving
09:46:47 <kolu> just to clear things
09:47:03 <fendor> what is the preferred way to have tests for internal library functions? I have seen an approach with internal and public libraries
09:47:06 <tungki> why ghc so slow in windows
09:48:00 <kolu> when I create a function - type inference automatically detects the types - writing them above the function just makes for easier reading
09:48:15 <davean> kolu: mostly, but not entirely true.
09:48:27 <[exa]> kolu: there are some cases of functions where type inference won't be able to find the correct type
09:48:32 <davean> That is true for functions with "normal" types.
09:48:50 <davean> it won't find the wrong type persay, it will find a valid type, or fail.
09:48:52 <[exa]> kolu: but these are in general absent in "introductory" haskell
09:48:59 <tdammers> fendor: 1) not (just test the API surface); 2) put them in .Internal modules; 3) expose them, because why not
09:49:14 <davean> [exa]: you learned haskell somewhere very different than I did :)
09:49:27 <tdammers> frankly, I'm mildly biased towards 1)
09:50:08 <fendor> yeah, good idea, I can actually test it, I think
09:50:52 <[exa]> davean: hm, is there any obvious introductory-level function that fails to type correctly? (e.g. because of recursive types?)
09:51:12 <[exa]> and except for the invalid ones that should have no type, ofc. :]
09:51:55 <kolu> can I write my functions and then check their types in the ghci 
09:52:15 <davean> [exa]: I learned Haskell from two sources, a programming language theory course, once we were done writing our own simply typed programming languages, for "what more there could be", or from Haskellers like edward kmett and the overlap of MANY of them with the old flipcode community on how it allowed more abstraction than template metaprogramming ;)
09:53:11 <davean> Philipa also
09:53:17 <davean> they were very vocal back when they existed
10:01:03 <Phyx-> tungki: because GCC and binutils are slow on Windows since they're designed for a POSIX I/O system
10:01:16 <jared-w> Am I crazy, or is there really no way to have `-fforce-recomp` actually work with cabal new-build?
10:02:10 <tungki> Phyx: yes, the binary file size are huge too, its sad i uninstalled it and switch to F# instead
10:12:00 <[exa]> kolu: yes you can check type of anything in ghci. just type :t  and the expression behind it.
10:12:10 <[exa]> kolu: e.g.   :t \x->x*x
10:13:30 <kolu> can I check the types inside a do block?
10:13:34 <kolu> says out of scope
10:13:53 <Phyx-> tungki: it's statically linked
10:14:50 <Phyx-> so it doesn't need a "runtime" distribution installed. hence the bigger sizes
10:16:43 <ski> davean : "they" being ?
10:18:42 <davean> ski: Philippa Cowderoy
10:19:05 <dmwit> % data Foo a = Done a | More (Foo (a,a))
10:19:06 <yahb> dmwit: 
10:20:11 <ski> davean, Philippa is still around
10:20:24 <dmwit> % sum' = go id where go f (Done a) = f a; go f (More as) = go (\(v1, v2) -> f v1 + f v2) as
10:20:24 <yahb> dmwit: ; <interactive>:51:20: error:; * Occurs check: cannot construct the infinite type: t1 ~ (t1, t1); Expected type: ((t1, t1) -> a) -> Foo (t1, t1) -> a; Actual type: (t1 -> a) -> Foo t1 -> a; * In an equation for sum':; sum'; = go id; where; go f (Done a) = f a; go f (More as) = go (\ (v1, v2) -> f v1 + f v2) as; * Rele
10:20:24 <davean> ski: I mean, tehy're still alive.
10:20:35 <ski> (just not in this channel)
10:20:51 <dmwit> % sum' = go id where go :: Num a => (b -> a) -> Foo b -> a; go f (Done a) = f a; go f (More as) = go (\(v1, v2) -> f v1 + f v2) as
10:20:51 <yahb> dmwit: 
10:21:07 <dmwit> [exa]: ^ an example of a function which typechecks with a signature, but for which inference fails
10:22:36 * ski . o O ( `Num o => Foo a -> Cont o a' )
10:23:01 <dmwit> =)
10:26:16 <[exa]> dmwit: oh nice :]
10:34:34 <ski> % let evalCont :: Cont o o -> o; evalCont = (`runCont` id); reset :: Cont o o -> Cont p o; reset = return . evalCont; shift :: ((a -> o) -> Cont o o) -> Cont o a; shift body = cont (\k -> evalCont (body k))
10:34:34 <yahb> ski: 
10:34:38 <ski> % let sumC = evalCont . go where go :: Num o => Foo a -> Cont o a; go (Done a) = return a; go (More as) = do (v0,v1) <- go as; shift \c -> return (c v0 + c v1)
10:34:38 <yahb> ski: 
10:36:59 <hexagoxel> relatively short question on type synonym family/instance behaviour: https://gist.github.com/lspitzner/d51e4022be957c69f52bdefa12988ca8
10:38:23 <hyperisco> hexagoxel, likely restrictions regarding instance resolution
10:38:30 <hexagoxel> (if it is not clear, I wonder what the reason is that the newtype makes any difference. Or if it has a reason.)
10:39:09 <hyperisco> when you newtype it then the type is always the same
10:40:40 <hexagoxel> I don't understand. The newtype is parameterized exactly as the wrapped value.
10:40:45 <hyperisco> to solve  y = MyFam x  you have to work backwards through the type family, and I am not sure how much sense that makes even if it was injective
10:41:05 <hyperisco> to solve  y = MyWrapper x  you know  y = MyWrapper y'  for some  y'  where  y' = x
10:41:27 <hyperisco> the fact you are using a type family becomes irrelevant
10:43:06 <hyperisco> to put it another way… MyWrapper is a type constructor, MyFam is not (it is a type function)
10:44:23 <ski> (`MyWrapper' is also a type function. but `MyFam' is not a type constructor)
10:48:44 <hexagoxel> I wonder if this was not a problem if the class was expressed with an associated type instead of having a second type arg plus a fundep
10:49:34 <hexagoxel> (although that would not be practical, not gonna redefine MonadReader throughout this codebase.)
10:52:11 <hexagoxel> and it still feels like the reason for this not working is a technicality. Forcing to use a bit more boilerplate without making anything actually safer. Although I can see that in general type family applications could be weird in instance decls.
10:54:35 <hyperisco> hexagoxel, it would change how instance resolution works… if you can figure out how to do it let the GHC team know :)
10:55:04 <hexagoxel> the fundep (and the injectivity or not of the type family) is not a problem, is it? if you have fundep `a -> b`, who cares if `b` contains a family application, as long as the free variables come from `a`.
10:55:45 <hexagoxel> "Do the same thing the newtype solution does, but automatically unpack the newtype again." done :D
10:55:59 <hyperisco> but that isn't the same
10:57:23 <hyperisco> since your type family is closed though maybe you can make the instances separately for each case
11:00:32 * hackage front 0.0.0.5 - A reactive frontend web framework  https://hackage.haskell.org/package/front-0.0.0.5 (swamp_agr)
11:01:21 <hexagoxel> that.. works. Have to manually apply the type family for each closed instance, but it works.
11:03:04 <hexagoxel> (and you _can_ write standalone `deriving newtype instance`, neat)
11:03:34 <hexagoxel> hyperisco: thanks for the hints.
11:03:52 <hyperisco> gl
11:18:28 <topos> has anyone here applied to the Tweag open source fellowship?
11:18:41 <topos> Wondering if any of y'all who did have heard back
11:21:49 <srk> I'm going to I think
11:33:17 <d34df00d> topos: it's within 2 weeks of the deadline (of March 30 that is), isn't it?
11:34:02 <topos> it must be that they're waiting to decide.
11:34:16 <topos> kk. Well, if we have to wait for the date to receive a response, patience is a virtue :)
11:59:53 <aveltras> what would be the best way to enforce a rule for a webserver to only serve on request at a time for a given user ? identifying requests coming from the same user is not a problem as i have a token, i'm just wondering how to setup a locking mechanism with the least performance impact
12:03:48 <Cale> Maybe just share an MVar with a Set of tokens in it?
12:07:47 <aveltras> ye, reading on mvars right now but if the mvar is over the set of tokens, doesn't that make all requests blocked while reading the set for each requests ?
12:13:07 <Cale> aveltras: Only for an extremely short period of time while you're checking/updating the set
12:13:52 <Cale> aveltras: on the other hand, you could probably get by with simply IORef
12:14:16 <aveltras> i've been reading that atomicModify is slower
12:14:19 <Cale> There's atomicModifyIORef'
12:14:30 <Cale> eh, it's pretty fast
12:15:02 * hackage byline 0.4.0.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.4.0.0 (PeterJones)
12:15:31 <aveltras> ok seems i'd have to benchmark this anyway to be sure, thanks for the pointers
12:18:42 <monochrom> Yeah when I have just one single shared mutable variable, I just use atomicModifyIORef'
12:24:24 <aveltras> hmm, not sure how to implement the "locking" feature in fact
12:26:59 <monochrom> OK it sounds like you are only looking for queuing.
12:28:09 <aveltras> the thing is i have some kind of request handler
12:28:28 <aveltras> the first request coming in, would i guess add its token in a set in a globally accessible variable
12:29:48 <aveltras> but then the second request coming while the first is still processed can know that is has to wait but i have to make something with a recursive thread delay or sth, obviously there are better alternatives than what i'm thinking right now :)
12:31:35 <geekosaur> return busy to the remote and make it delay/retry so the user can abort it?
12:32:15 <dsal> Can anyone tell me what instance Alternative (LoggingT IO) would look like?
12:33:08 <dsal> I have a list of actions of increasing cost.  I want the result of the first successful one.   asum/msum seems like the right answer, but I've got a transformer stack and my logger doesn't do the thing.
12:33:28 <aveltras> the use case is for a session handling mechanism, i'd like 2 consecutive requests (the second one being fired browser side before the response of the first one is received) to not create 2 sessions in case the whole thing happens at a time when the session token is supposed to be renewed
12:34:04 <aveltras> basically the session handling mechanism of php by default
12:35:21 <monochrom> dsal: It is possible that LoggingT IO reuses IO's Alternative.
12:35:48 <dsal> I got here because the compiler tells me it doesn't.  :(
12:36:19 <monochrom> If the instance head (e.g., as seen in docs) goes like "instance Alternative m => Alternative (LoggingT m)" then it's highly likely LoggingT preserves m's Alternative semantics.
12:36:31 <monochrom> Oh! Then I don't know.
12:37:26 <dsal> Yeah.  I'm just going to do what IO does, I guess.
12:37:37 <monochrom> I may know. You code up yourself in a way that backtracking doesn't lose logs.
12:38:39 <monochrom> apart from that you reuse IO's Alternative.
12:39:24 <monochrom> Easier said than done because I don't know the details of LoggingT, so meh.
12:40:04 <Cale> It's basically a reader, so it's easy
12:40:12 <lyxia> it has a MonadCatch instance you could use.
12:40:29 <Cale> That said, I kind of think LoggingT is a ridiculous idea to begin with, but meh
12:40:43 <maerwald> MonadLogger is nice
12:40:50 <Cale> MonadLogger is okay
12:41:45 <Cale> I dunno, I guess it's fine
12:42:32 <dsal> Yeah, I'm using MonadCatch and doing my own <|>
12:42:37 <dsal> Let's see if it works...
12:43:10 <dsal> Yeah, this works.  woo
12:43:16 <Cale> It's just that usually you could have just put the logging function into another application-specific Reader, and LoggingT isn't really enough on its own to justify transforming IO...
12:43:29 <Cale> But I guess there are probably some cases where it's reasonable
12:44:26 <Cale> That guy's nick is really memorable
12:45:04 <monochrom> haha
12:52:57 <kolu> is this analogy correct: the IO monad is like that small space where the surveilance cameras of functional police cant see - their blind spot 
12:53:14 <kolu> and you can break all the rules there
12:53:19 <kolu> without consequence
12:53:47 <Ariakenom> ... no
12:53:50 <geekosaur> nope. there are most definitely rules. in fact, one is added: unlike the normal case, IO actions can't be arbitrarily reordered by the compiler
12:54:01 <monochrom> sounds like unsafePerformIO not Haskell 2010 IO.
12:54:29 <monochrom> Also, nothing brings computability rules.
12:54:36 <monochrom> err, s/brings/breaks/
12:54:43 <kolu> okay
12:54:50 <kolu> how about this statement
12:54:57 <maerwald> yeah, this is the common misunderstanding, partly stemming from ppl thinking IO is impure
12:55:17 <kolu> that's good
12:55:21 <kolu> i'm making progress
12:55:26 <kolu> i'm part of the common understanding now :)
12:55:32 <maerwald> IO is pure :)
12:56:02 <kolu> but once a value crosses over
12:56:08 <kolu> its type changes, right
12:56:18 <monochrom> No
12:56:31 <maerwald> check out http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.7800&rep=rep1&type=pdf
12:56:38 <maerwald> Hope that's a legal link lol
12:56:56 <kolu> yes, thank you
12:56:58 <monochrom> But instead of these word mincing, how about making falsifiable statements and designing experiments to falsify them?
12:58:00 <kolu> when I see the :t of a function that takes input from IO
12:58:10 <monochrom> For example, or rather for counterexample, most analogies are unfalsifiable.
12:58:17 <kolu> is says cleanseInput :: String -> IO ()
12:58:35 <kolu> and returns it back to IO
12:59:55 <aveltras> a nice analogy i heard was that you can understand IO a as a recipe to get an a. To prepare your recipe, you have to mix things, including the real world and its side effects. Everything else in haskell is more like a description of something already cooked
13:00:01 <aveltras> (at least for me :) )
13:00:10 <maerwald> I don't like to cooking analogy
13:00:12 <int-e> The only way to run an IO action is from another IO action... everything traces back to the main function. How that is run is outside of the scope of the pure Haskell semantics.
13:00:47 <monochrom> I don't like any analogy. :)
13:01:31 <int-e> analogies are like water; they can be solid but most of the time they are hard to grasp?
13:01:34 * int-e runs
13:01:36 <monochrom> And by the time you have an "analogy" that passes my falsifiability test, people cease calling it "analogy", it's now a semantic mapping.
13:01:40 <maerwald> monochrom: well, I'd rather eat a burrito than deal with cooking recipes :)
13:02:14 <monochrom> or a mathematical model, or a scientific model, or s/model/theory/, etc etc
13:03:01 <aveltras> is this common to have nested concurrency primitives ? like a map of mvars in an ioref map ?
13:03:20 <monochrom> Yes.
13:03:41 <monochrom> Chan has nested MVars.
13:04:14 <aveltras> what happens when you remove an mvar from a map while some other thread is waiting on it ?
13:04:46 <monochrom> does someone else still know about that mvar?
13:05:05 <aveltras> ye, the request locked waiting for it
13:05:17 <aveltras> i guess this would block on putMvar
13:05:18 <monochrom> anyone else?
13:05:26 <aveltras> maybe another request
13:05:30 <aveltras> maybe n requests in fact
13:05:50 <monochrom> then the mvar is not lost
13:06:35 <monochrom> why don't you quickly whip up an experiment to test it?
13:06:42 <aveltras> you mean is not in the map anymore but it s not gced either ?
13:07:16 <monochrom> according to your scenerio it's still live data.
13:08:18 <monochrom> make an mvar, give it to 3 parties: a map, a thread that takeMVar, a thread that waits 10 seconds then putMVar.  During those 10 seconds, remove mvar from map.  See what happens, what works and what doesn't.
13:08:43 <Ariakenom> aveltras: what are you building?
13:08:53 <monochrom> Why are programmers too lazy to code up small controlled experiments to test hypotheses?
13:09:14 <monochrom> Is it like there is a law that says you must not write any non-production code?
13:09:21 <maerwald> too many ppl in this room who know your answers :/ it's tempting
13:09:36 <monochrom> Is it like there is a religion against toy examples?
13:09:40 <Cale> Also, often you'd think that you want finer grained locking for performance, with a Map of MVars rather than an MVar of a Map, but frequently you'd be wrong about it... it's surprising how good a single MVar with a Map in it can be.
13:09:52 <monochrom> That religion would be also against learning, you know?
13:10:16 <aveltras> the problem is not the mvar here, it's that it has to stay locked during a whole web request
13:10:32 <kolu> monochrom - what is a good way to experiment with types
13:10:53 <kolu> something basic
13:10:54 <monochrom> Depends on the hypothesis you plan to make?
13:10:56 <Cale> aveltras: That seems unnecessary
13:11:06 <Cale> aveltras: Why hold the MVar for the entire request?
13:11:06 <monochrom> Give me a hypothesis.
13:11:14 <aveltras> i ll have to implement this anyway but i'd be surprised if there wasn't some concurrent data structure in a form of a set but that just block when trying to put a value thats already inside and not blocking if it aint
13:12:00 <Ariakenom> monochrom: well a minimal reproducible example for bugs is common
13:12:06 <kolu> No hypothesis. Just understanding their behavior.
13:13:01 <Ariakenom> kolu: but hypothesises are great for understanding
13:13:02 * hackage quickcheck-state-machine 0.7.0 - Test monadic programs using state machine based models  https://hackage.haskell.org/package/quickcheck-state-machine-0.7.0 (stevana)
13:13:17 <monochrom> That sounds like an oxymoron to me, sorry.  If you don't have a million hypotheses and find out which one fails flatly and which ones seem to survive tests, you understand nothing.
13:14:16 <Cale> aveltras: If this is still the same scenario as before, at the start of a request, you withMVar, check to see if the user's token is in the Map, if not, you add it and proceed normally. If it is present, the request fails.
13:14:40 <Cale> aveltras: and then you wrap the request handler in a finally which also does a withMVar and removes the user's token from the set
13:14:48 <aveltras> i dont want the request to fail, i want it to wait for the first one to complete
13:15:01 <Cale> ah, okay
13:15:02 <kolu> Okay, I got it now. I'm off to play.
13:15:10 <Ariakenom> I always want to suggest STM in concurrency discussions
13:15:22 <aveltras> but then i guess i should have some kind of exception with infinite retry
13:15:35 <jaqu3> Hi! I have problem with foldl :(  
13:15:39 <aveltras> and a fail fast with concurrency checks in the beginning of my function
13:15:42 <jaqu3> zad6 a l = foldl (\x l -> if elem x l then True else False) 
13:15:55 <jaqu3> and I do not know what I did wrong :(  
13:16:19 <monochrom> But do you know what would count as right?
13:16:31 <monochrom> Or, do you know what "right" should mean?
13:16:36 <Ariakenom> aveltras:do you know the stm module?
13:16:41 <int-e> jaqu3: what happened to the `a` and `l` arguments? what is the function supposed to do?
13:16:56 <jaqu3> Use FOLDL to define functions to determine whether an item belongs to the list
13:17:05 <jaqu3> I'm the begginer with Haskell
13:17:09 <aveltras> read parallel and concurrent book a long time ago yeah, but don't remember much :)
13:17:13 <aveltras> Ariakenom: 
13:17:15 <jaqu3> a is a number and l is the list
13:17:19 <Cale> if e then True else False is always equal to e
13:17:39 <Ariakenom> check for the token. if you want to block until a state change do a `retry`
13:18:02 <Cale> also, note that you're binding l twice, you probably didn't mean to do that
13:18:09 <Cale> What do you want the function to do?
13:18:25 <Cale> Are you trying to check if there are duplicates in the list or something?
13:18:34 <Cale> (also, what's a?)
13:18:46 <int-e> a is the element to be tested, presumably
13:18:59 <int-e> the `elem x l` isn't correct
13:19:01 <Cale> Are we trying to check if a is an element of l?
13:19:13 <Cale> Or an element of any of the elements of l?
13:19:41 <Ariakenom> do {ok <- hasToken; if ok then takeToken else retry}
13:19:43 <geekosaur> I think you're supposed to be reimplementing elem here, not using it
13:19:46 <int-e> Yeah, a lot of things are odd here.
13:19:54 <jaqu3> a is exist in the l ( list l ) 
13:20:01 <int-e> jaqu3: Can you give zad6 a type? That's often a very good place to start.
13:20:08 <Ariakenom> where hasToken and takeToken does things with a STM (Set X)
13:20:30 <jaqu3> zad6 :: a -> [b] => Bool ??
13:20:36 <aveltras> Ariakenom: im going to try this and report
13:20:44 <int-e> But I think from the description that you're supposed to reimplement the `elem` function, so your code should not be using it.
13:20:49 <Ariakenom> aveltras: good luck :)
13:20:55 <aveltras> Ariakenom: thanks
13:21:29 <jaqu3> is it the elem return bool function yeah ?
13:22:00 <int-e> :t (==)
13:22:02 <lambdabot> Eq a => a -> a -> Bool
13:22:33 <int-e> (This might guide a little, perhaps.)
13:23:26 <jaqu3> I use the in foldl argument correlty ?
13:23:47 <Cale> jaqu3: So the first argument to your function doesn't have the same type as the elements of the list?
13:24:09 <Cale> Or did you mean a -> [a] -> Bool?
13:24:20 <jaqu3> I think yeah
13:24:29 <jaqu3> if I read the function good ;)  
13:24:43 <jaqu3> EX: Use FOLDL to define functions to determine whether an item belongs to the list
13:24:54 <Cale> Okay, and so zad6 x xs is supposed to check to see if x occurs somewhere in the list xs?
13:24:59 <Cale> ah, okay
13:25:23 <jaqu3> yeah 
13:25:42 <jaqu3> I know I'm stuipid and I do not understand foldl
13:25:49 <jaqu3> but it it my 3rd lecture :D
13:26:32 <Cale> @src foldl
13:26:32 <lambdabot> foldl f z []     = z
13:26:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:27:20 <jaqu3> zad6 a b = foldl (\x l -> elem x l == True ) a b
13:27:32 <jaqu3> is it correct?
13:27:32 <Cale> So, what foldl does is to walk down the list, applying f to the expression it's accumulated so far (or just the initial value you give) z, and the next element of the list
13:27:55 <Cale> elem is already a solution to the problem you're trying to solve, so you probably don't want that
13:28:51 <Cale> So, if we take the accumulator to mean "Have we found the element we're looking for yet?"
13:29:02 <Cale> It can start off as False
13:29:05 <ski> > foldl f z [a,b,c,d]
13:29:07 <lambdabot>  f (f (f (f z a) b) c) d
13:29:28 <Uniaika> Holy Monad in Heavens, `base` is really a piece of work
13:30:26 <Cale> and then on each step, we find the element if either we already found it, or if the next element of the list is the one we're looking for
13:30:27 <Uniaika> (I'm diving in the sources, took me some time to make sense of Base.hs)
13:31:04 <Cale> So:  foldl (\alreadyFound next -> alreadyFound || next == a) False
13:32:28 <jaqu3> okey it works but ... sory i do not know why :(  
13:32:31 <jaqu3> shit :/  
13:32:37 <jaqu3> I'm so much syupid 
13:32:47 <Ariakenom> \token tvar -> do {set <- readTVar tvar; if member token set then writeTVar tvar (delete token set) else retry;} :: Token -> TVar (Set Token) -> STM ()
13:32:51 <ski> jaqu3 : if you call the function passed to `foldr', `f', then the result of one call to `f' will be passed as first argument to the next call. so, if `f' produces a `Bool'ean, it'll also receive a `Bool'ean as first argument
13:32:58 <Ariakenom> aveltras
13:33:44 <Cale> jaqu3: Let's implement your function using straight recursion, but in a way that will convert to a foldl
13:33:57 <ski> (and the "initial" (innermost) value of that argument, that is for the innermost call to `f' will be the other parameter of `foldl', called `z' in the sample definition given by lambdabot above)
13:34:45 <aveltras> ye i was away, not blocked yet :) thanks for the example here, ill get to it, trying some reorganisation of code to see if mvars are enough first (to prevent bringing in seemingly slower tvars)
13:35:35 <jaqu3> I do not understand `|| b == a)`
13:36:05 <jaqu3> I know this is a lamba solve but why is OR ? 
13:37:48 <Ariakenom> aveltras: I just felt the need to write some stm :)
13:39:21 <Cale> jaqu3: Because we want the thing to be True when either we already found the element before, or if we found it now
13:39:52 <Cale> jaqu3: and we just walk down the list, continuing to apply that function to accumulate a result by checking each additional element
13:40:04 <Cale> We start off with False
13:40:17 <Cale> and then if the list is like [x1,x2,x3] and we're looking for a
13:40:34 <Cale> we apply that function to False and x1
13:40:50 <Cale> and our new accumulator is  False || x1 == a
13:41:00 <Cale> and then we apply the function to that and x2
13:41:10 <Cale> and we get (False || x1 == a) || x2 == a
13:41:19 <Cale> and then we continue with x3...
13:41:26 <Cale> and we get ((False || x1 == a) || x2 == a) || x3 == a
13:41:53 <Cale> and then finally we run out of list elements, and that's the result of the foldl
13:42:52 <Cale> Note that with foldl we always end up walking along the entirety of the list
13:43:18 <Cale> foldr has the advantage here that it can actually stop early if we find the element we're looking for
13:43:34 <jaqu3> ohhh like in the [x <- bla bla ]
13:45:18 <jaqu3> okey thank you <3
13:45:18 <Cale> > foldr (\x r -> x == 5 || r) False [1..]
13:45:20 <lambdabot>  True
13:45:33 <Cale> ^^ this works even though the list [1..] is infinitely long, because it finds the element
13:46:34 <Cale> (note the difference in the argument order to the function passed to foldr -- the intuition here is that in foldr's case, the "r" parameter there is the result of folding over the rest of the list, and x is some initial element
13:47:06 <Cale> while in foldl's case, we're deciding what to do given the result of accumulation so far, and some element toward the end of the list
13:47:06 <ivegotasthma> any idea how I can fix this small function to return IO User? Is that possible ? https://dpaste.org/essa/raw
13:47:30 <Cale> Probably you want return (User ...)
13:47:36 <Cale> Or you can stick a $ in there
13:47:52 <Cale> You don't really want to pass 5 arguments to return ;)
13:48:16 <ivegotasthma> Oh yeah, you're right
13:48:57 <jaqu3> BTW you can rewrite it to foldr 
13:49:08 <monochrom> Actually foldr is better.
13:49:16 <jaqu3> I want to see change :/
13:49:24 <Cale> I just did...
13:49:38 <monochrom> I was a bit baffled at why your teacher wanted you to use foldl for this.  foldl is better for other things but not this.
13:49:57 <Cale> > foldr (\x r -> x == 5 || r) False [1..]
13:49:59 <lambdabot>  True
13:50:53 <Cale> jaqu3: foldr has a nicer interpretation than foldl
13:51:15 <Cale> foldr f z is the function which replaces each (:) in the construction of a list with f and the [] at the end (if any) with z
13:52:13 <Cale> So, here, we're replacing each of the (:)'s with a function that checks if the element we're adding to the list is the one we're looking for, and otherwise proceeds with the result of searching the rest of the list
13:52:33 <Cale> and we replace [] with False, because if the list is empty, we didn't find the thing we're looking for
13:52:41 <ski> @where folds
13:52:41 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
13:53:00 <Cale> :D
13:53:17 <Cale> My diagrams
13:53:25 <ski> yea, i know ;)
13:53:55 <Cale> I had a bigger version of that picture...
13:54:04 <ski> <https://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg>
13:54:23 <Cale> haha, not just physically bigger, but more inclusive as well
13:54:42 <ski> 2006-10-21 .. was it that long ago ?
13:55:30 <Cale> https://cale.l5.ca/share/Folds.svg
13:55:32 <ski> more inclusive, how ?
13:55:46 <ski> mhm
13:56:24 <Cale> I'm still mildly salty about mapAccumR
13:56:39 <ski> @where+ folds <http://en.wikipedia.org/wiki/File:Fold-diagrams.svg>,<https://cale.l5.ca/share/Folds.svg>
13:56:40 <lambdabot> I will never forget.
13:56:46 <ski> what about it ?
13:56:49 <Uniaika> Cale: why so?
13:56:54 <ski> @type mapAccumR
13:56:56 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:56:56 <ski> @type mapAccumL
13:56:58 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:56:58 <Cale> Look at the diagrams
13:57:20 <ski> oh, didn't realize there was even more to the right
13:57:40 <Cale> If you flip the function, the diagram is much more natural, and follows the one for foldr/scanr more closely
13:57:50 <jaqu3> Okey I will look at it tomorrow ;)  I am going to sleep tomorrow i must go to work ;)  See ya and THANK YOU <3
13:58:04 <ski> yea, i see what you mean
14:01:38 <ski> @type foldr
14:01:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:01:40 <ski> @type foldl
14:01:42 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
14:02:21 <ski>   fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
14:02:34 <ski>   fold_left  : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b
14:02:46 <ski> OCaml ^
14:03:24 <ski>   val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
14:03:37 <ski>   val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
14:03:40 <ski> SML ^
14:04:40 <ski> hence
14:05:02 <ski>   fold_right o fold_right : ('a -> 'b -> 'b) -> 'a list list -> 'b -> 'b
14:05:24 <ski>   fold_left  o fold_left  : ('b -> 'a -> 'b) -> 'b -> 'a list list -> 'b
14:06:01 <ski> @type foldl . foldl
14:06:03 <lambdabot> (Foldable t1, Foldable t2) => (b -> a -> b) -> b -> t1 (t2 a) -> b
14:06:14 <ski> @type foldr . flip . foldr
14:06:16 <lambdabot> (Foldable t1, Foldable t2) => (a -> b -> b) -> b -> t1 (t2 a) -> b
14:08:09 <ski> @type mapAccumR . mapAccumR
14:08:10 <lambdabot> (Traversable t1, Traversable t2) => (a -> b -> (a, c)) -> a -> t1 (t2 b) -> (a, t1 (t2 c))
14:08:14 <ski> @type mapAccumL . mapAccumL
14:08:15 <lambdabot> (Traversable t1, Traversable t2) => (a -> b -> (a, c)) -> a -> t1 (t2 b) -> (a, t1 (t2 c))
14:09:27 <ski> so, i guess there's some argument for `foldr' to take parameters in another order than it does (conforming with `mapAccumR')
14:16:59 <Cale> ski: Ah, from that perspective, it's nicer to compose, I guess
14:17:39 <Cale> ski: Though, keeping the elements in the same order as they occur in the list is a really nice design point about Haskell's foldr (and Ocaml's)
14:17:48 <ski> (note how they have the same type in SML, just like `mapAccumR' and `mapAccumL')
14:17:56 <Cale> right, I noticed
14:18:07 <ski> yes, i agree
14:18:23 <ski> so, that would then suggest
14:18:43 <ski>   foldr :: Foldable t => (a -> b -> b) -> t a -> b -> b
14:18:55 <ivegotasthma> is it possible to show type A when it's in an IO action?
14:19:07 <ski> (which is what i meant by "for `foldr' to take parameters in another order")
14:19:17 <ChaiTRex> ivegotasthma: print x
14:19:22 <ski> ivegotasthma : run the action first ?
14:19:45 <Cale> ivegotasthma: IO actions are pretty much inscrutable, you can run them, but there's no way to figure out what one will do at runtime apart from that.
14:19:46 <ski> (you don't want to try to show the action itself)
14:20:36 <ChaiTRex> ivegotasthma: More thoroughly thingOfTypeIOA >>= print or do { x <- thingOfTypeIOA; print x }
14:20:43 <monochrom> ivegotasthma: Actually I don't understand the question.
14:20:48 <ski> @type (appEndo .) . foldMap . (Endo .)
14:20:49 <lambdabot> Foldable t => (a1 -> a2 -> a2) -> t a1 -> a2 -> a2
14:20:53 <monochrom> Is there an example? mock-up?
14:21:08 <Cale> This isn't entirely 100% necessary, in principle you might be able to have an IO type where the *first* bit of IO was possible to inspect ahead of running it, but it's probably important for performance, and there's no way you could see through the lambda on the right side of a (>>=) anyway
14:21:12 <ivegotasthma> I was wondering if there's a way to get to the data, because I'm constructing data inside a function that calls IO. I know I can pass the needed data to the function as a parameter, but I was wondering if it's possible to isolate the IO into single functions so it doesn't contaminate everything else
14:21:46 <Cale> ivegotasthma: You can run the IO action, and pass the result of it to pure functions that needn't know or care where that result came from
14:21:47 <monochrom> Do you absolutely need IO to construct that data?
14:22:13 <Cale> ivegotasthma: and then probably do some further IO with the result of those pure functions, or there wouldn't be a point to applying them
14:22:42 <Cale> ivegotasthma: e.g. if we have a program like
14:22:52 <Cale> do x <- getLine; putStrLn (reverse x)
14:23:08 <Cale> The reverse function is totally oblivious to the fact that x came from doing IO
14:23:20 <ivegotasthma> Cale: monochrom: this is the small program https://dpaste.org/skWC/raw
14:23:57 <ivegotasthma> pasting broke :/ createConsumer is UTCTime -> Consumer
14:24:00 <monochrom> Um, my eyes.  You're at the advanced stage of DataKinds and you can't do basic IO?
14:24:17 <Cale> monochrom: That's just Servant
14:24:21 <monochrom> This is what's wrong with dive-in projects.
14:24:23 <ivegotasthma> I don't know why I have that code there, I was running some snippets from servant
14:24:28 <Cale> Yeah, haha
14:24:37 <ChaiTRex> ivegotasthma: Just so you know, print is a shortcut for putStrLn . show.
14:24:55 <ivegotasthma> ChaiTRex: danke
14:25:57 <monochrom> it looks like for the consumer you can just go "createConsumer t = Consumer "me" 123 "something@com.com" t" and you need no IO for that part.
14:26:20 <ivegotasthma> yeah, that's fine, because I'm passing the time from the main, I understand that
14:26:26 <monochrom> And inside main you can use "createConsumer time".
14:26:40 <Cale> ivegotasthma: It's probably totally fine for the thing which registers a new user in your system to be in IO, since probably when you build your whole application, it's going to immediately write to a database as well. But sure, you can make pure versions which make specific sorts of users with various default values and parameters.
14:26:45 <ski> Cale : `act >>= return = act' ?
14:27:09 <monochrom> I wonder if this section of my article will help you: http://www.vex.net/~trebla/haskell/IO.xhtml#organization
14:27:16 <ski> well, i guess `return () >>= const act = act' is more appropriate
14:29:04 <Cale> ski: Consider the free monad on a functor for FFI
14:30:02 <Cale> Or if we just want terminal IO for simplicity...
14:30:07 <Cale> We could have
14:30:30 <ski> wouldn't that still run afoul of violating that monadic law ?
14:30:36 <ivegotasthma> monochrom: I had the same intuition, thanks for confirming it
14:30:37 <Cale> data IO a = Done a | PutStr String (IO a) | GetLine (String -> IO a)
14:30:57 <ski> hm, ok
14:31:15 <Cale> and we'd define
14:31:19 <ski> yea, i see
14:31:27 <Cale> Done a >>= f = f a
14:31:44 * ski nods
14:32:16 <Cale> So yeah, it ends up satisfying the laws, even though you get to see the start of the action.
14:32:27 <ski> `(>>=)' is basically like `(++)' here, shifting to a right-associated view
14:32:37 <Cale> yeah
14:34:26 <monochrom> Um, you can inspect a whole lot.  Even in the GetLine case, you can mock-test it with various different strings and peek into many possible futures.
14:34:45 <Cale> Indeed
14:35:18 <monochrom> In fact a motivation for using a free monad is that you can do mock testing and dependency injection and all that jazz.
14:35:41 * ski idly wonders whether there's something bar recursion or fan theorem like, here
14:36:23 <Cale> This also makes IO fit into the container-y view of monads
14:36:31 <monochrom> In fact the tautological motivation for free monads is it is free, i.e., anything you can do to other instances, you can do to the free instance.
14:36:39 <Cale> Your IO actions are (sometimes infinitely branching) trees
14:36:57 <Cale> which terminate in values of the given type at the leaves
14:37:45 <ski> hm, i guess `Done x' is like `const x', maybe ?
14:37:55 <Cale> Done x is exactly return x
14:37:56 <monochrom> I learned this the hard way! I inflicted a free monad representing a game on my students. They kept pressing me on the meaning or intuition behind this strange thing. Eventually I realized and said "this is the whole game tree".
14:38:14 <Cale> Or maybe I don't understand what you mean
14:38:46 <monochrom> Done is like return.
14:38:48 <Cale> monochrom: indeed :)
14:43:25 <ski> i mean if you consider `type Cantor = Natural -> Bool', then by bar recursion `p :: Cantor -> Bool' is uniformly continuous, so either `p = const x' where `x :: Bool', or `p = \bs -> if bs 0 then p1 (bs . succ) else p0 (bs . succ)' where `p0,p1 :: Cantor -> Bool', where this process terminates at `const x' leaves
14:44:10 <ski> it was wondering, if you squinted a bit, you could think of the above `IO', or something similar to it, in some terms like this ..
15:07:47 <lecce> ciao a tutti
15:08:05 <lecce> !list
15:08:05 <monochrom> lecce: http://lpaste.net/browse
15:09:01 * hackage matrix-sized 0.0.1 - Haskell matrix library with interface to C++ linear algebra libraries.  https://hackage.haskell.org/package/matrix-sized-0.0.1 (kaizhang)
15:16:19 <ukari> about ExistentialQuantification, is it possible to get the value with escape type variable from the data field? https://plaster.tymoon.eu/view/1706
15:20:51 <dmwit> No, it is not possible.
15:21:00 <zeta_0> could you guys help setup darcs for development when running cabal new-build i am getting this error thrown? https://hastebin.com/pejitekoyo.sql http://darcs.net/Development/GettingStarted
15:21:22 <dmwit> However, you could write `value' :: Foo -> (forall a. a -> b) -> b; value' (Foo x) f = f x`.
15:21:46 <dmwit> This is why existential boxes almost always have typeclass constraints inside the box.
15:21:52 <dmwit> Otherwise you can't do anything interesting with the boxed value.
15:22:02 <zeta_0> all i did was add the new part to the cabal commands, so i don't know why darcs does not want to build?
15:23:15 <zeta_0> i was told that the newest version of cabal produces sandboxes automatically, so i followed the 1st part of the darc instructions
15:23:28 <Cale> ukari: The entire point of an existential type is to forget which type of thing you had, and relinquish any rights that came with knowing that the value had the given type (at least, any that you don't include into the existential container)
15:23:43 <dmwit> zeta_0: Presumably you need to install whatever package is appropriate for your distro to get a copy of ar.
15:24:13 <monochrom> I would start with "The program 'ar' is required but it could not be found."
15:24:53 <dmwit> e.g. on Fedora you would `dnf install binutils`
15:25:07 <Cale> Your value' function says "For any type a, I can convert a value of type Foo to a value of type a", but that's obviously not the case. There simply exists some type a for which the contents of the Bar constructor have type a.
15:26:28 <zeta_0> oh thanks guys, dammit, then i am probably going to need to do this in a nix-shell so i can keep the dependencies isolated in a self contained environment, is there a way to do this with cabal or am i better of sticking with nix?
15:26:51 <ukari> thank you, I am trying to get it
15:27:27 <monochrom> Um I don't understand why you need to containmentize ar. It's a globally useful and used tool.
15:27:34 <Cale> zeta_0: If you're good with nix, and you're not in the middle of trying to ensure the UX for your libraries is good for the average cabal user, I'd say stick with nix
15:28:04 <Cale> But also, yeah, ar is something that ought to exist
15:28:06 <zeta_0> ya, after i clone the darcs repository i'll go into a nix-shell, i think this would be the best approach to avoid dependency hell
15:28:31 <Cale> So you might just figure out why your system isn't providing ar
15:28:31 <monochrom> It's like saying "should I limit make to inside docker?"
15:30:10 <zeta_0> Cale: i could quickly install ar in my home.nix pkgs, but for this case i think that's a bad idea, i'm pretty good with nix, but i could not find any instructions for building darcs in a nix-shell, so i am going to have to figure this out on my own
15:30:15 <zeta_0> hmm
15:30:41 <Cale> ar is part of binutils
15:31:12 <zeta_0> ok, that's good to know
15:31:48 <Cale> It's probably hard to compile anything without that...
15:43:47 <dmwit> I don't think I have *ever* been in a dependency hell which could be blamed on not having the right version of ar (or from a version conflict on ar, either).
15:48:22 <zeta_0> dmwit: apologies, i am just so used to doing things the `nix way`, nix makes you do things completely different
15:49:15 <zeta_0> ok cabal new-build worked, thanks for the help'
15:50:14 <zeta_0> there is no cabal copy or cabal new-copy? http://darcs.net/Development/GettingStarted
15:50:28 <zeta_0> so the newest version of cabal does not have this command?
15:50:54 <zeta_0> cabal-install version 3.0.0.0
15:50:54 <zeta_0> compiled using version 3.0.0.0 of the Cabal library 
15:51:12 <monochrom> "cabal copy" was a sub-step of "cabal install" in the v1 paradigm.
15:52:02 <monochrom> So if anything it's "v1-copy" now and it has no counterpart in the v2 paradigm.
15:52:21 <zeta_0> monochrom: so cabal install is the equivalent command to cabal copy that i need to run in this case?
15:52:50 <monochrom> Depends on whether you're building the package for its exe?
15:53:16 <monochrom> In the v2 paradigm "v2-install" makes sense for exes only.
15:53:43 <zeta_0> monochrom: i want to start contributing to darcs, so i am just following the instructions here: http://darcs.net/Development/GettingStarted
15:54:30 <zeta_0> monochrom: not cabal new-install? this cabal ambiguity confuses the hell out of me
15:54:37 <monochrom> You may need a day or two to fully digest the shock that the instructions were written a decade or two before v2 was thought up.
15:54:58 <monochrom> Hell, even before sandboxing for thought up.
15:55:09 <monochrom> And there was no stack back then either.
15:55:13 <monochrom> And no nix either.
15:55:59 <monochrom> And no one was excited about dependent haskell. Probably no one thought of it either. That was one of the good parts.
15:56:12 <zeta_0> monochrom: dam, dependency hell is what pushed me to find nix
15:56:48 <zeta_0> monochrom: so haskell tooling has improved a lot over the years
15:57:32 <monochrom> I wouldn't be so confident about that.
15:58:49 <zeta_0> monochrom: i had problem getting good ide support for haskell, but now i'm using ghcid/ghcide which is great
15:59:03 <zeta_0> monochrom: why?
16:00:12 <zeta_0> so just to double check, cabal new-install is the equivalent command to cabal copy?
16:00:28 <monochrom> For example we may be better off if stack did not exist and cabal v2 happened earlier in its place.
16:01:13 <monochrom> For example we could use respect for v1 use cases and not scaremonger about it.
16:03:10 <zeta_0> ok i just ran cabal new-install hopefully it works
16:05:37 <dmwit> zeta_0: In v2-land, for development, v2-install is probably not needed.
16:05:55 <dmwit> zeta_0: Just `cabal v2-build all` to get started, and maybe `cabal v2-test`.
16:06:14 <dmwit> zeta_0: You can `cabal v2-run darcs` to build and run whatever changes you've just made.
16:08:54 <zeta_0> dmwit: ok, i ran that those commands, so i do i actually run the built darcs, i already have darcs installed as a user so i'd like to switch to this built darcs to be able to test it
16:10:47 <dmwit> ...
16:10:47 <zeta_0> dmwit: https://hastebin.com/ocuyofasez.rb
16:10:55 <dmwit> "You can `cabal v2-run darcs` to build and run whatever changes you've just made."
16:11:49 <sm[m]> haven’t seen this statedhere recently:
16:12:50 <zeta_0> dmwit: i'm not sure if it's running the correct darcs? https://hastebin.com/diwijicula.rb
16:13:02 <sm[m]> Does v2-install still copy executables to ~/.cabal/bin/ ?
16:13:18 <dmwit> Why are you unsure?
16:14:03 <zeta_0> it shows different versions of darcs, one of them is my user installed version and the other is the one i just built
16:14:50 <dmwit> And?
16:15:16 <dmwit> Or maybe I should ask: what is the "it" in "it's running the correct darcs"?
16:15:41 <sm[m]> Correct zeta_0, presumably you’re wanting to make the new darcs the default in your PATH ?
16:15:57 <dmwit> I strongly recommend against that.
16:16:22 <dmwit> That will make it much too easy to accidentally run one that doesn't have whatever changes you just made during development and testing.
16:16:48 <sm[m]> that does have, you mean ?
16:17:06 <dmwit> I do not. I said what I meant, in this case.
16:17:17 <dmwit> I am speaking in the future tense, though; perhaps that bit was unclear.
16:17:21 <zeta_0> dmwit: ok, i think i get it now, the commands you pasted are just to test the built darcs for error
16:17:31 <sm[m]> I don’t understand then, but that is fine :)
16:17:39 <sm[m]> Situation normal, carry on
16:18:16 <dmwit> If you put darcs in your PATH, then you can accidentally run `darcs foo` instead of `cabal v2-run darcs foo`, and it will "work", but not use the code that you're working on -- instead, it will us the code from the last time you did an installation.
16:18:36 <dmwit> That's a dangerous way to develop. Instead don't have it on PATH, so that you are forced to remember to put `cabal v2-run` at the start.
16:18:46 <dmwit> Then you can be sure that `cabal` has rebuilt, if it needs to.
16:19:04 <sm[m]> Aha
16:21:11 <zeta_0> dmwit: ok, that makes much more sense, thanks for clarifying this
16:21:32 * hackage ipfs 1.0.2 - Access IPFS locally and remotely  https://hackage.haskell.org/package/ipfs-1.0.2 (expede)
16:31:32 * hackage postgres-websockets 0.6.0.0 - Middleware to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgres-websockets-0.6.0.0 (diogob)
16:39:32 * hackage free-categories 0.2.0.0 - free categories  https://hackage.haskell.org/package/free-categories-0.2.0.0 (echatav)
16:50:57 <fog> Hi, I'm confused about this representation of Datatype; https://gist.github.com/fog-hs/e3b0c7154549165635a80449db78b9d3
16:51:15 <fog> I'm not sure about how to express recursive datatypes such as List
16:51:24 <Axman6> you literally wrote it :P
16:51:33 <fog> yeah, but its meanta
16:51:36 <fog> mental*
16:52:03 <Axman6> I was going to ask you about it the other day, I would love to see how you actually use it
16:52:12 <fog> right! me too!
16:52:42 <fog> but recursive datatypes seem to give rise to infinite types as the datatype parameters
16:52:54 <Axman6> Fix?
16:53:03 <fog> it already uses Free'
16:53:17 <fog> which is kind of whats confusing, since I dont need Free to express List
16:53:29 <fog> data Datatype_Layer_T a = Datatype_Layer_T (Sum_T [a])
16:54:10 <fog> where `a' gets replaced by the recusive self reference
16:55:03 <fog> the problem is that with List, you would want List_Layer_T a = Datatype_Layer_T (List_Layer_T a)
16:55:08 <fog> or something like that
16:55:25 <fog> which is an infinitite type
16:55:32 * hackage ghc-lib-parser-ex 8.8.5.8 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.8 (shayne_fletcher)
16:55:46 <fog> because each of the tails is a list, so requires the list layer type params
16:57:30 <fog> but im also not sure about this.... since that seems to be just trying to make List from a single layer
16:57:49 <fog> data Datatype_Layer (xs :: Datatype_Layer_T a) where
16:58:07 <fog>  Datatype_Layer :: FSum HList (xs :: (Sum_T [a])) -> Datatype_Layer ('Datatype_Layer_T xs)
16:59:05 <fog> and
16:59:06 <fog> xs :: Datatype_Layer_T a
16:59:22 <fog> is like restricting the kinds of all the types to be the same
16:59:44 <fog> because they appear in a type level sum of lists
17:00:03 <fog> and instead of like a regular list type, [a], where all the types of the values are a
17:00:13 <fog> here at type level, it is that all the kinds are `a'
17:00:35 <fog> but the head of the list, and the tail, both take parameters of different kinds
17:01:17 <fog> thats when writing cons, and supplying the two types `a' `List a' 
17:02:00 <fog> since `List a' requires more params, that are with the layer kind `Sum [a]'
17:03:06 <fog> and it complains that `a :: *' and `List a' have different kinds, since the list requires params
17:03:42 <fog> so their params (*,listParams) cant appear alongside each other in the list of `Sum [a]'
17:04:19 <fog> the kinds of their params*
17:05:56 <Guest_75> hi :)
17:06:06 <Guest_75> is anybody here?
17:06:28 <fog> but, with HFree', the (a,[a]) types of cons becomes (Datatype,Datatype), where the Pure of HFree' can be used for `a'
17:06:40 <fog> and it should support the call to List for the tail, as a Datatype
17:06:59 <koz_> Guest_75: There are many people here.
17:07:27 <Guest_75> guest_75
17:08:14 <koz_> Nice of the bot to self-kick.
17:08:45 <fog> perfect timing! 
17:10:45 <fog> Axman6: i guess the problem with using Fix or Free for the params, as well as for the datatype construction at value level, is that this is *not* how the params to datatype are stored
17:10:50 <fog> by the definition of Free'
17:11:16 <fog> it kind of takes the Free version, and unwraps all the Free' constructor calls
17:12:34 <fog> like, instead of eg. Tree a = Free [] a, eg. Free [Free [x]]
17:12:39 <fog> it would just be [[x]]
17:13:17 <fog> as it stores the params having un-fmapped the datatype wrapper
17:13:46 <fog> (thats what all the To HContainer FContainer) stuff in the definition of HFree' is doing
17:14:26 <fog> it replaces FContainer Free (which maps Free over the contents), with just the HContainer version
17:14:33 <fog> (h for hetrogenous, f for functor)
17:15:37 <fog> but this leaves some kind of nightmarish polykinded tree as the param, and I cant think how to actually write it for list
17:16:57 <fog> or maybe i'm confused because I was thinking of replacing Sum_T [a] with something hetrogenous, like, with HList instead of []
17:17:23 <fog> but that might be wrong, as that was for trying to make list of a single "layer" 
17:17:41 <fog> where both the head and the tail would have to take the same kinded params
17:17:43 <fog> .
17:50:00 <ovitus> dosetF "0" 89; setF "1" 39; setF "2" 26; setF "3" 93setF "4" 110; setF "5" 70; setF "6" 93; setF "7" 5setF "8" 101; setF "9" 94; setF "10" 116; setF "11" 75setF "12" 112; setF "13" 73; setF "14" 116; setF "15" 75
17:50:14 <ovitus> does somebody know how to map that function, taking two sets of lists?
17:50:40 <Axman6> I have no idea what's going on there
17:52:02 <ovitus> I have a function setF
17:52:15 <ovitus> setF :: String -> Pattern Double -> IO ()
17:52:17 <ovitus> that's the type
17:52:41 <ovitus> I want to apply it to a list of strings and a list of pattern doubles
17:52:54 <ovitus> so that it runs setF "1" 89
17:52:57 <ovitus> setF "2" 39
17:53:03 <ovitus> setF "3" 93
17:53:03 <ovitus> etc
17:53:04 <Axman6> to all pairs of values from each or to corresponding pairs?
17:53:10 <koz_> I'm working in a (newtype-wrapped) stack of 'LogicT Gen a'. I'm trying to define MonadGen for said newtype, but I'm having trouble implementing 'variant', which for me types as effectively 'Integral n => n -> LogicT Gen a -> LogicT Gen a'. I'm not sure how to even write this.
17:53:32 <koz_> ovitus: Just to be clear, your desired input type is [(String, Pattern Double)]?
17:53:33 <ovitus> corresponding
17:53:44 <Axman6> > (\a b -> show a ++ show b) <$> [1,2,3] <*> ['z','y','z']
17:53:46 <lambdabot>  ["1'z'","1'y'","1'z'","2'z'","2'y'","2'z'","3'z'","3'y'","3'z'"]
17:54:03 <Axman6> > zipWith (\a b -> show a ++ show b) [1,2,3] ['z','y','z']
17:54:06 <lambdabot>  ["1'z'","2'y'","3'z'"]
17:54:11 <koz_> Axman6: Was about to say.
17:54:34 <Axman6> your choices are basically zipWith or liftA2
17:54:50 <koz_> Axman6: liftA2 will only give correct semantics if the inputs are ZipLists, not list-lists.
17:54:56 <koz_> I don't think nondeterminism is the goal here.
17:55:04 <Axman6> > liftA2 (\a b -> show a ++ show b) [1,2,3] ['z','y','z'] -- the expression using <$> and <*> above is just the definition of liftA2
17:55:07 <lambdabot>  ["1'z'","1'y'","1'z'","2'z'","2'y'","2'z'","3'z'","3'y'","3'z'"]
17:58:30 <ovitus> thanks let me try this out
18:13:22 <koz_> I'm working in a (newtype-wrapped) stack of 'LogicT Gen a'. I'm trying to define MonadGen for said newtype, but I'm having trouble implementing 'variant', which for me types as effectively 'Integral n => n -> LogicT Gen a -> LogicT Gen a'. I'm not sure how to even write this.
18:13:45 <koz_> 'sized' is even worse: effectively (Int -> LogicT Gen a) -> LogicT Gen a.
18:13:57 <koz_> Am I asking for something impossible?
18:14:42 <hololeap> so, i've been diving into optics (super cool, btw), but there's one problem i haven't figured out. if i have `Lens' a (m b)` and `Lens' b c`, how would i compose them to get `Lens' a (m c)` ?
18:15:35 <koz_> Is m a Functor, Monad, something else?
18:16:59 <hololeap> Functor
18:17:19 <hololeap> it's Monad, too, but i don't need that much power for this
18:17:48 <hololeap> at least i don't think i do...
18:25:48 <Axman6> :t mapped
18:25:50 <lambdabot> (Settable f1, Functor f2) => (a -> f1 b) -> f2 a -> f1 (f2 b)
18:26:04 <koz_> Axman6: Do you know much about continuation shenanigans?
18:26:05 <Axman6> I think that might give you hat you want?
18:26:10 <koz_> I'm not sure how to proceed here.
18:27:14 <koz_> Specifically, I don't know what should go in the type hole here, or whether I'm even writing this sensibly: https://gist.github.com/kozross/48f5347633768795b9bcf6645eb32604#file-logicgen-hs-L18
18:27:25 <koz_> (I'm using the MonadReader definition for LogicT as a guide)
18:27:52 <Axman6> yeah not really something I'm that familliar with
18:28:10 <koz_> Oh well, thanks anyhow.
18:28:14 <Axman6> is LogicT Gen an instance of LogicGen already?
18:28:27 <Axman6> uh, MonadGen
18:28:40 <Axman6> because you should be able to derive it
18:28:40 <koz_> Nope, that's kinda why I'm hand-rolling this.
18:28:45 <Axman6> right
18:29:00 <koz_> MonadGen doesn't lift. It's defined for GenT m, but not anything else.
18:29:06 <koz_> (where m is a Monad naturally)
18:29:11 <Axman6> I'm sure edwardk would know
18:30:49 <koz_> OK, I have something that seems a bit closer: https://gist.github.com/kozross/48f5347633768795b9bcf6645eb32604
18:30:56 <koz_> I've got a type error, which I've included.
18:31:42 <koz_> (I know I can curry the mr there)
18:32:32 * hackage mr-env 0.1.0.0 - A simple way to read environment variables in Haskell  https://hackage.haskell.org/package/mr-env-0.1.0.0 (meowgorithm)
18:33:10 <isovector1> is there some way to typecheck a TH Exp?
18:33:28 <isovector1> or, more specifically, to get the type of an UnboundVarE
18:33:54 <koz_> isovector1: Could you assist me with some continuation-related shenanigans? I'm not sure what's awry here: https://gist.github.com/kozross/48f5347633768795b9bcf6645eb32604
18:34:21 <koz_> (also, hi!)
18:35:15 <isovector1> koz: hi! try using ($) instead of (.) 
18:35:28 <isovector1> not sure what's going on here, but it's a good bet when things that should typecheck aren't when dealing with rank-n types
18:36:01 <koz_> ... you're right on.
18:36:10 <koz_> I guess it's impredicativity biting again.
18:36:59 <isovector1> always is
18:37:33 <koz_> Alrighty, now just to define 'sized', which is even worse, lol.
18:38:22 <isovector1> good luck
18:43:24 <hololeap> Axman6: how would i use that?
18:45:10 <hololeap> nvm, found the docs for it
18:56:13 <iqubic> koz_: What is LogicGen?
18:59:53 <koz_> iqubic: My custom stack of LogicT and Gen.
19:00:14 <iqubic> I don't know what LogicT is, but it sounds fancy.
19:00:32 <koz_> http://hackage.haskell.org/package/logict
19:00:45 <iqubic> Gen is for property testing, right?
19:00:52 <koz_> Yep.
19:01:02 <iqubic> How does one use LogicT?
19:01:31 <koz_> Read the library.
19:01:39 <koz_> It's not something I can explain in one or two lines. :P
19:01:59 <iqubic> logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a
19:02:08 <iqubic> That's a hairy type signature.
19:02:35 <koz_> It's very similar to Cont.
19:02:43 <koz_> (and is, in fact, a special case of it)
19:04:07 <iqubic> Wait... that's just "(forall r. Cont (r -> r) a) -> Logic a"
19:04:17 <crestfallen> hi what am I seeing in the output here? : 
19:04:21 <crestfallen> > (*) <$> (Just 10)
19:04:23 <lambdabot>  Just <Integer -> Integer>
19:04:36 <crestfallen> the < "" > notation?
19:04:59 <iqubic> (*) <$> (Just 10) is the same as Just (*10)
19:05:31 <dmwit> crestfallen: It is hard to `show` a function in a sane way. There's a few popular solutions.
19:05:48 <dmwit> crestfallen: One is to just produce the literal string "<function>" no matter what input you get.
19:05:55 <dmwit> This works for all functions, but isn't very informative.
19:06:19 <dmwit> A very unpopular one is to produce a lookup table that tells all the outputs for every possible input. This works only for functions with finite domain, but is very informative.
19:06:55 <dmwit> The solution you are seeing is a middle ground: it shows the type of the function and nothing more. This works for most functions -- in particular, all `Typeable` functions -- and is more informative than "it's a function" but less informative than the function's graph.
19:07:18 <crestfallen> > (*) <$> (Just 10) <*> Just 4
19:07:20 <lambdabot>  Just 40
19:07:59 <iqubic> > liftA2 (*) (Just 10) (Just 4) -- This does the same thing
19:08:01 <lambdabot>  Just 40
19:08:17 <hololeap> i'm not sure i understand `mapped` ... it requires f to be Settable... this seems to really limit its uses on functors other than Identity
19:08:21 <crestfallen> > (*) <$> (Just 10) -- but in ghci this fails 
19:08:23 <lambdabot>  Just <Integer -> Integer>
19:09:07 <ysangkok> crestfallen: apparently lambdabot has some extra Show instances?
19:09:27 <dmwit> crestfallen: \bot is using this package: http://hackage.haskell.org/package/show-0.6/docs/ShowFun.html
19:10:09 <iqubic> That's a quality hackage documentation page.
19:10:26 <crestfallen> yeah ysangkok thanks dmwit not too worried. just with that <Integer -> Integer> business 
19:10:31 <iqubic> https://imgur.com/a/OjJUSVK
19:10:42 <monochrom> Recall that "forall r. (a -> r -> r) -> r -> r" is equivalent to [a]. As a first stab you can take it as a non-deterministic monad like [] is. Later you will find that Logic is better than [] at breadth-first search.
19:11:10 <iqubic> What how is that equivalent to [a]?
19:11:20 <iqubic> Is it a church encoding or something?
19:11:54 <koz_> monochrom: I too am intrigued as to how this is equivalent to [a].
19:12:26 <monochrom> Long story of studying either System F or Böhm-Berarducci  encoding
19:12:35 <dmwit> from :: that -> [a]; from f = f (:) []
19:12:59 <dmwit> to :: [a] -> that; to [] cons nil = nil; to (a:as) cons nil = cons a (to as cons nil)
19:13:12 <iqubic> :t \f -> f (:) []
19:13:13 <lambdabot> ((a1 -> [a1] -> [a1]) -> [a2] -> t) -> t
19:13:20 <iqubic> Hmmm???
19:13:27 <iqubic> dmwit: You were saying?
19:13:34 <dmwit> I stand by my claim.
19:13:38 <iqubic> How so?
19:13:45 <dmwit> I leave it to you to spell out the contradiction that you find in your mind.
19:13:48 <dmwit> There is none in mine, yet.
19:14:06 <monochrom> Generally suppose you can write down the type of the catamorphism of your initial algebra type, e.g., [a]'s is "(a -> r -> r) -> r -> [a] -> r"
19:14:34 <monochrom> Re-order parameters so you are converting [a] to something: [a] -> (a -> r -> r) -> r -> r
19:14:37 <koz_> monochrom: So wait, the first part is basically cons, and the second is nil?
19:14:44 <dmwit> koz_: right
19:14:53 <koz_> Where 'a' is 'the element at this position' and r is 'whatever remains'?
19:14:54 <iqubic> ((a1 -> [a1] -> [a1]) -> [a2] -> t) -> t doesn't unify with (forall r. (a > r -> r) -> r -> r)
19:15:00 <monochrom> then drop the [a] because you already have the list. Then forall the r.
19:15:25 <dmwit> iqubic: It isn't supposde to. It's supposed to unify with (forall r. (a -> r -> r) -> r -> r) -> [a]
19:15:46 <iqubic> And how does it do that?
19:16:08 <monochrom> It's beautiful isn't it? :)
19:16:09 <dmwit> You try first. Then tell me where you get stuck.
19:16:46 <iqubic> I'm so bloody confused.
19:17:24 <koz_> dmwit: It's really quite clever - it reminds me of the build-destroy fusion thingo.
19:17:25 <dmwit> When confused, I recommend taking a breath, then starting from the beginning and going as slow as necessary.
19:17:33 <dmwit> koz_: It is exactly build-destroy, yes.
19:17:44 <koz_> dmwit: Oh, cool.
19:17:44 <dmwit> :t buildr
19:17:46 <lambdabot> error:
19:17:46 <lambdabot>     • Variable not in scope: buildr
19:17:46 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
19:17:46 <monochrom> "church encoding" is casually right but I listen to Oleg when he says what's wrong: "church encoding" presupposes the untyped lambda calculus, but here the type is important because the "forall r" plays an important role, this one is living in System F, so he prefers to attribute it to Böhm-Berarducci's paper.
19:17:59 <dmwit> ah well. Anyway it is.
19:18:42 <monochrom> If you say "church encoding but System F" I am also OK with that.
19:19:02 <iqubic> What is the build-destroy thing?
19:19:15 <iqubic> s/thing/fusion thing/
19:19:27 <monochrom> I'm not anal at all about "GNU/Linux" but I'm anal about this :)
19:20:22 <iqubic> I'm anal about "GNU/Linux"
19:20:38 <monochrom> I think build-destroy for [a] are highly internal functions of base such that it is not easy to access them with a typical REPL.
19:22:26 <monochrom> An easier one is "data N = Z | S N", catamorphism goes like "(r -> r) -> r -> N -> r", so the System F version is "forall r. (r -> r) -> r -> r", up to parameter order.
19:22:57 <monochrom> Hmm what else can I show off?
19:24:17 <monochrom> Ah here: Let F be a functor. "newtype X = MkX (F X)", catamorphism goes as "forall r. F r -> X -> r", System F version is "forall r. F r -> r".
19:24:45 <monochrom> err no!
19:25:09 <monochrom> catamorphism goes as "forall r. (F r -> r) -> X -> r", System F version "forall r. (F r -> r) -> r"
19:25:32 <monochrom> recall that "F r -> r" is an F-algebra :)
19:26:01 <monochrom> ("X ->r" is an initial F-algebra)
19:26:20 <monochrom> Isn't this beautiful? :)
19:27:14 <monochrom> Phil Wadler also has a text file draft on this, plus F-coalgebra using existental quantification
19:28:53 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free  then look for "recursive types for free!"
19:33:16 <monochrom> Err, no, the initial F-algebra is F X -> X.
19:43:40 <MarcelineVQ> monochrom: wanna start a fight club with me?
19:44:09 <monochrom> err, no
19:44:29 <monochrom> Actually you may like like what Oleg said: http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
19:45:34 <MarcelineVQ> So you're gonna fight me on this...
19:45:51 <koz_> monochrom: Yep, MarcelineVQ will like like it.
19:45:52 <monochrom> haha
19:46:00 <koz_> Like it so much that they'll like it _twice_!
19:46:24 <monochrom> But I don't know the Fight Club story so I don't understand the reference.
19:47:07 <monochrom> except for "there is no fight club" (but you just broke that) and multiple personality.
19:47:29 <monochrom> perhaps you just mean you are me.
19:47:54 <MarcelineVQ> nothing so deep, I just wanted a setup to say that last line
20:00:54 <dsal> Can someone help me with an optics type?  I've got a list of DEVC and I'm doing   "folded . dev_telems . folded . tele_values . _TVGPS"  -- conceptually, this is a "GPS" value, but I'm  not sure what the actual signature of that function is.
20:01:11 <dsal> (it doesn't work to not supply a signature because inference is too specific to one case)
20:01:54 <Axman6> looks like Traversal' [DEVC] GPS?
20:03:06 <MarcelineVQ> monochrom: why is push_neg in that link not structurally recursive? Add (push_neg (Neg e1)) (push_neg (Neg e2)) is it because we're adding Neg to e1/e2 ? it's still strictly decreasing in size so I must not know what structurally recursive means specificaly
20:03:08 <dsal>     • Could not deduce (Contravariant f) arising from a use of ‘folded’
20:07:00 <monochrom> MarcelineVQ: If a recursive call has parameter other than simply e1 or e2 then it is not structural recursion. This is a highly syntactic requirement.
20:07:16 <dsal> If I stick a hole there, I get    `(GPS -> Const (Data.Monoid.First Double) GPS)  -> [DEVC] -> Const (Data.Monoid.First Double) [DEVC]` which isn't super helpful.
20:07:36 <dsal> Actually, that's just one case.
20:08:04 <dsal> I'm going to go with cut-and-paste for the time being, because I still don't know the entire thing I'm doing yet.
20:10:42 <monochrom> Likewise, the whole pain of denotational semantics is only because they insist on structural recursion, therefore they don't allow themselves to write "semantics (fix foo) = (semantics foo) (semantics (fix foo)"
20:16:17 <monochrom> No, that's 30% of the pain. The other 70% is for a similar issue for recursive data types.
20:17:02 * hackage pvar 0.1.0.0 - Mutable variable with primitive values  https://hackage.haskell.org/package/pvar-0.1.0.0 (lehins)
20:19:23 <MarcelineVQ> monochrom: I see thank you, I plugged push_neg into agda and it didn't complain so I was wondering what the distinction was due to that
20:19:50 <MarcelineVQ> Well that and because the page specifically calls out that there is one
20:24:46 <monochrom> I think I can break it into two mutually recursive functions and they are structural recursions.
20:25:17 <koz_> Is there something like 'iterateMN :: Int -> (a -> m a) -> a -> m a'?
20:25:32 * hackage concurrent-resource-map 0.2.0.0 - Concurrent resource map  https://hackage.haskell.org/package/concurrent-resource-map-0.2.0.0 (MateuszKowalczyk)
20:25:48 <Axman6> @hoogle Int -> (a -> m a) -> a -> m a
20:25:49 <lambdabot> Control.Monad.HT nest :: (Monad m) => Int -> (a -> m a) -> a -> m a
20:25:59 <MarcelineVQ> iterateNM
20:26:00 <Axman6> whatever that is...
20:26:26 <MarcelineVQ> not especially elucidating hoogle searches tho
20:26:43 <koz_> Ah, it's Henning's private collection of useful stuffs.
20:27:14 <koz_> It's basically a foldM over [()].
20:27:18 <koz_> (of the appropriate length)
21:32:16 <dmwit> :t \n f -> foldr (>=>) pure (replicate n f)
21:32:18 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
21:33:19 <dmwit> :t stimes
21:33:20 <lambdabot> error: Variable not in scope: stimes
21:33:50 <dmwit> Well. It is also stimes, with appropriate choice of newtype.
21:35:48 <dmwit> ...but the coerce version is syntactically quite a bit longer than just reimplementing it! Yikes.
21:35:59 <dmwit> There oughta be a way to make coerce suck less.
21:42:31 <monochrom> @quote monochrom catmorphism
21:42:31 <lambdabot> No quotes match. The more you drive -- the dumber you get.
21:42:45 <monochrom> @quote monochrom fish
21:42:46 <lambdabot> monochrom says: the selfish program's motive is to fool the programmer
22:44:52 <koz_> dmwit: That fold is a bit fishy.
22:51:17 <koz_> % :t stimes
22:51:18 <yahb> koz_: ; <interactive>:1:1: error: Variable not in scope: stimes
22:51:58 <koz_> Wait, which newtype would you need there?
22:52:11 <koz_> Is Kleisli m a a a semigroup?
22:55:00 <Axman6> maaaaaa, where's my tendies!
22:55:28 <MarcelineVQ> ree
22:55:45 <Axman6> eeeheating
23:00:20 <buckworst> you know it's a good day in #haskell when someone's crying for chicken tendies
23:00:48 <hololeap> lol @ reeeeeheating
23:01:08 <hololeap> data Foo m = { _foo_mBar :: m Bar }
23:01:08 <hololeap> data Bar   = { _barBaz   ::   Baz }
23:01:08 <hololeap> how would i write `Lens' (Foo m) (m Baz)`, given the lenses foo_mBar and barBaz?
23:02:09 <koz_> hololeap: Is m an Applicative?
23:02:29 <hololeap> it's a Monad even
23:02:35 <int-e> should be  m Bar
23:02:39 <Axman6> foo_mBar . mapped . barBaz?
23:02:52 <int-e> oh
23:03:09 <int-e> never mind, I'm not thinking clearly
23:03:18 <hololeap> i tried to figure out mapped earlier... let me try that
23:08:30 <koz_> :t mapped
23:08:32 <lambdabot> (Settable f1, Functor f2) => (a -> f1 b) -> f2 a -> f1 (f2 b)
23:10:02 <hololeap> http://dpaste.com/1TVQRHA
23:12:29 <Axman6> you'll probably need the type to be Functor m => Lens' (Foo m) (m Baz)
23:12:51 <int-e> is this better? foo_mBar . mapped barBaz
23:13:18 <Axman6> hmm, actually no, mapped only gives you access toit he Baz not the m Baz
23:13:42 <Axman6> nah that's un-optic'd it
23:14:20 <Axman6> foo_mBar . coerced might do it =)
23:14:32 <hololeap> neither of those helped
23:14:46 <Axman6> with newtype Bar though
23:17:56 <Axman6> foo_mBar . mapping barBaz?
23:18:19 <Axman6> mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b) https://hackage.haskell.org/package/lens-4.19.1/docs/Control-Lens-Combinators.html#v:mapping
23:25:02 <hololeap> Axman6: does that require it to be something akin to a newtype?
23:27:55 <Axman6> you might have to write the Iso yourself, I thing be default the derived optic will be a Lens, but in this case you do have an isomorphism
23:28:35 <Axman6> but if Bar is more complex then what you want might not be doable, at least not without writing something more complex which doesn't exist in lens
23:30:17 <int-e> Axman6: proper grammar is hard. :)
23:30:39 <int-e> (mapped vs. mapping)
23:31:08 <Axman6> yes
23:41:01 <hololeap> this works although i had to upgrade to `Applicative m`: http://dpaste.com/380YC0S
23:42:15 <hololeap> so the only way is to write a lens like this by hand?
23:44:50 <Axman6> not that I know of, but that looks pretty good
23:58:15 <MarcelineVQ> is there a lens that could replace  splitActJoin f = joinPath . f . splitPath  for filepath? use is  splitActJoin $ over _head ("braked " ++)   I'm trying to modify the root directory of the path
23:58:36 <hololeap> i can probably abstract from this: http://dpaste.com/3HZ9N88
