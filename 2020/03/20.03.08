00:05:13 <jackdk> % :t fmap @((->) _) . fmap
00:05:14 <yahb> jackdk: Functor f => (a -> b) -> (w -> f a) -> w -> f b
00:05:18 <jackdk> idnar: ^
00:19:23 * hackage fb 2.0.1 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-2.0.1 (psibi)
03:03:40 <idnar> jackdk: I want to do, say, `recv connection = liftEither =<< eitherDecode <$> receiveData connection` into `recv = liftEither <=< eitherDecode <.> receiveData`
03:04:46 <jackdk> `recv connection = liftEither <=< (fmap . fmap) eitherDecode receiveData`?
03:04:51 <idnar> not sure the `fmap . fmap` version comes out very legible
03:05:22 <jackdk> `recv connection = liftEither <=< ((<$>) . (<$>)) eitherDecode receiveData`
03:05:36 <jackdk> now it looks like a cartoon character that's seen a big pile of money
03:05:52 <jackdk> (I've often wanted `(<<$>>) = fmap . fmap`
03:07:53 * hackage cgrep 6.6.32 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.32 (NicolaBonelli)
03:11:48 <idnar> jackdk: heh
03:30:30 <subttle> idnar: I've been using:
03:30:32 <subttle> (‥) ∷ (a → b) → (c → d     → a) → (c → d     → b)
03:30:34 <subttle> (‥) = (.)    .    (.)
03:30:46 <subttle> and also
03:30:49 <subttle> (…) ∷ (a → b) → (c → d → e → a) → (c → d → e → b)
03:30:50 <subttle> (…) = (.) . (.) . (.)
03:34:17 <__monty__> :t fmap fmap fmap
03:34:18 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
04:14:39 <tom__> What is the intuition for cofree?
04:21:39 <tom__> Free monads are for building up a nested series of contexts and delaying their evaluation so
04:22:09 <tom__> I guess cofree comonads are for removing nested series of contexts and evaluating them
04:34:53 * hackage typesafe-precure 0.7.7.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.7.7.1 (igrep)
04:41:53 * hackage ghc-tags-plugin 0.1.3.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.3.0 (coot)
04:51:33 <ski> tom__ : yea (although i'm not sure what you mean by "delaying their evaluation" and "evaluating them" parts)
04:52:05 <ski> subttle : i've called them `(.:)',`(.::)',&c., for many years
04:54:29 <ski> also
04:54:36 <ski>   (.) :: Functor f => (a -> b) -> (f a -> f b)  -- iow `fmap'/`(<$>)'
04:54:44 <ski>   flip :: Functor f => f (a -> b) -> (a -> f b)  -- aka `strong'
04:54:49 <ski> used to be in lambdabot
04:55:21 <ski> (but was removed, since it was thought those generalizations were sometimes confusing for newbies)
04:56:13 <ski>   strong :: Functor f => a -> f b -> f (a,b)  -- another (related) thing, that's also sometimed called `strong'
04:56:47 <ski> (hm, maybe it was s/strong/strength/, actually, now that i think about it)
05:02:05 <tom__> ski: cool, yeah I guess delaying evaluation was to do with idea of interpreting effects in different ways
05:02:23 * hackage ghcid 0.8.2 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.8.2 (NeilMitchell)
05:02:37 <tom__> As in you have your data structure which is a list of functors but it is then interpreted separately
05:02:59 <tom__> hence delay in evaluation of effects
05:03:27 <tom__> I guess it isn't a delay
05:06:58 <ski> oh, you mean delaying execution of effects, i suppose ?
05:07:11 * ski idly ponders whether one should call it a delay
05:07:58 <tom__> ski: Yeah!
05:08:20 <tom__> The effects are evaluated they just haven't been run yet
05:09:29 <tom__> Is the running of the effects in Free basically lifting each functor in the list into a monad?
05:09:55 <tom__> So cofree would be lifting functors into comonads
05:15:29 <maerwald> only IO is executed. Do you mean *interpreted*?
05:32:22 <tom__> maerwald: Ah yes thanks
05:46:21 <tom__> Does this make any sense. You have a poker game.
05:46:52 <tom__> Could you model all possible pairings of nextAction and gameStates as points in a cartesian space?
05:47:23 <ski> tom__ : (re free and cofree), iirc, yes
05:47:32 <tom__> Essentially I am trying to solve what is an optimisation problem
05:47:45 <tom__> Where expected value of a hand in the card game is the variable to maximise
05:47:56 <ski> maerwald,tom__ : i have no qualms about talking about executing `Maybe'-actions, or `[]'-actions, &c.
05:49:19 <ski> (and of course, analogously, talk about `Maybe'-effects, `[]'-effects, `Parser'-effects, &c.)
05:50:05 <tom__> ski: Thanks
05:55:32 <freezer003> hi
05:59:57 <ski> hello freezer003
06:10:52 <maerwald> ski: I go with lax use of "effects", but I draw the line on "execution" :P
06:12:26 <maerwald> However, you could convince me with "run" vs "execute" :P
06:12:43 <maerwald> (useful semantical discussions are useful, such semantics)
06:15:50 <ski> maerwald : hm, first i misread you as saying "useful semantical distinctions are useful" (which i'd agree with, heh)
06:16:45 <ski> (would you like to elaborate on any particular reason why you reserve "execute" for `IO' ?)
06:17:14 <maerwald> "execute" always makes me think of the runtime or something low-level. I think that's in general what it's used for in CS. You don't execute a program on paper. That is all evaluation.
06:23:06 <ski> hm, okay, maerwald
06:23:26 <ski> and why couple that with `IO', rather than with the run-time or implementation details ?
06:24:05 <maerwald> IO is the only thing you can execute
06:24:32 <ski> because of `main' being `IO', you mean ?
06:24:41 <maerwald> More interesting question is: what do people mean when they say "run a function"?
06:24:58 <ski> why do you couple `IO' with "the runtime or something low-level" ?
06:25:19 <ski> because `IO' has a "magical" implementation, with special run-time and implementation support ?
06:25:20 <maerwald> Because that is where it's executed and we leave the world of Haskell
06:25:25 <iphy> on travis, which directory should you cache when using stack?
06:25:39 <maerwald> Execution is also not defined in the haskell report anywhere
06:25:42 <maerwald> Afair
06:25:48 * ski nods
06:25:52 <ski> (a fair point)
06:25:55 <iphy> https://docs.haskellstack.org/en/stable/travis_ci/#container-infrastructure this says ~/.stack
06:26:03 <iphy> but heroku's buildpack uses .stack-work
06:26:30 <maerwald> .stack-work is the local one in a project, no?
06:26:43 <maerwald> ~/.stack is the global one with the hashed deps
06:27:26 <ski> maerwald : wouldn't you say that `Integer',`Double',`Array', and some more things, also have "magical" implementation, that we have to leave the world of Haskell for them as well ?
06:28:24 <maerwald> ski: Yes, unfortunately.
06:28:39 <iphy> so I should only cache ~/.stack on travis?
06:28:53 <tom__> Do you execute an Array value?
06:29:05 <maerwald> iphy: I think that's probably a safe bet.
06:29:08 * ski wouldn't say so. maybe maerwald would, tom__
06:29:18 <iphy> ok thanks
06:30:41 <maerwald> We can have it a bit more lax: Everything I can reasonably do on paper (or *approximate* on paper... such das Double), isn't really in the realm of execution.
06:31:03 <maerwald> Reading files I really cannot do on paper, unfortunately
06:31:07 <ski> can't you simulate I/O on paper ?
06:31:12 <ski> why not ?
06:31:18 <maerwald> They are on the hard disk
06:31:21 <maerwald> xD
06:32:01 <maerwald> You only have an IO function, that, when executed, gives you file contents. You don't have any file contents. You can't force the file contents.
06:32:10 <ski> just imagine a small-step semantics, with transitions possibly annotated with primitive input and outut commands, such as opening a file, reading an octet from a handle, &c.
06:32:18 <ski> why can't you do that on paper ?
06:32:26 <maerwald> Because the files are on the hard disk
06:32:33 <ski> (might be tedious, long-winded, of course)
06:32:58 <maerwald> That would mean you excute the IO action and transfer the results onto the paper. Then you still executed it, just in an indirect fashion.
06:33:05 <ski> you can print the files out on paper, as a preparatory step ?
06:33:11 <maerwald> You can't do it without execution
06:33:49 <maerwald> You interacted with hardware
06:34:06 <ski> or, you could just imagine having a file on a hard disk, just as you imagine doing computation with numbers, on paper ?
06:34:54 <maerwald> You mean papers that interact with each other and rewrite their inputs?
06:34:56 <maerwald> lol
06:35:09 <maerwald> I'm having weird images in my brain now
06:35:14 <ski> afair, the report doesn't say that `IO' actions must interact with real files on harddisks, &c. .. just talking about the back-and-forth input-and-output commands being issued
06:35:40 <ski> so, you could swap out the other side of that interface with keeping track of imaginary files, on paper, no ?
06:35:42 <maerwald> Yes, IO could have different interpreters
06:36:24 <maerwald> But then I don't see what kind of useful interpreter that would be. Letters? :>
06:36:31 <ski> so, i'm not really seeing why I/O is that special, here
06:36:46 <maerwald> Here you have my file dear Sir. Please evaluate it in your IO action on line 356
06:36:54 <maerwald> xD
06:37:21 <maerwald> Then you need to attach addresses to your IO actions... hah!
06:37:39 <ski> hm, i'm not following
06:37:41 <maerwald> And in order to execute the action, you have to go to the address and knock on the door
06:37:54 <maerwald> And a dude will open and give you the file contents in a briefcase
06:38:07 <maerwald> Now everything makes sense
06:38:25 <maerwald> But you see, you have to leave the house to do IO now. How tedious
06:38:52 <maerwald> I believe the haskell creators foresaw this
06:39:07 <maerwald> That's where the pun RealWorld comes from...
06:39:32 <ski> hehe :)
06:40:26 <MarcelineVQ> how I envy the guy who gets to stay at home and simply pass out the briefcase
06:40:50 <maerwald> Yes, he is very lazy.... ha-ha
06:41:28 <ski> only does what he's supposed to do, when forced .. typical
06:42:11 <maerwald> Yeah, lazy evaluation is violence
06:42:22 <ski> lazy violence
06:43:11 * ski . o O ( "violence is lazy, violets are grue .." )
06:43:48 <MarcelineVQ> there's sure to be something, you are likely to
06:46:24 <MarcelineVQ> or maybe "violence is lazy. violets are grue. It is pitch black. You are likely to"
06:48:23 <int-e> MarcelineVQ: the suspense is killing me
06:49:12 <MarcelineVQ> int-e: it's something elderly people say to frighten their great grandchildren: It is pitch black. You are likely to be eaten by a grue.
06:49:23 <int-e> MarcelineVQ: I got the reference :P
06:49:32 <MarcelineVQ> I just wanted an age dig
06:50:11 <MarcelineVQ> but if you were really after some antici
06:59:23 <iphy> where does stack write its data on windows?
06:59:29 <iphy> it's not %APPDATA%\stack
07:00:23 * hackage Spintax 0.3.4 - Random text generation based on spintax  https://hackage.haskell.org/package/Spintax-0.3.4 (MichelBoucey)
07:00:33 <doesntcontribute> Is it possible to unzip a list of pairs of IO Ints?
07:01:36 <iphy> doesntcontribute: you mean (IO Int, IO Int)?
07:01:45 <iphy> oh
07:01:47 <iphy> list
07:01:54 <iphy> [(IO Int, IO Int)]?
07:01:59 <doesntcontribute> Yes
07:02:00 <MarcelineVQ> iphy: https://docs.haskellstack.org/en/stable/README/#how-to-contribute if this is accurate it's %LOCALAPPDATA%\Programs\stack
07:02:17 <iphy> MarcelineVQ: thanks, I'll try that
07:02:34 <ski> doesntcontribute : should be straightforward
07:03:16 <ski> doesntcontribute : you'll need `sequence' or something, if you want to run the actions in those lists, of course
07:03:43 <ski> doesntcontribute : is there a reason why you're having those `IO'-actions in (pairs in) a list, rather than plain `Int's there ?
07:03:56 <doesntcontribute> It’s actually [IO (Int,Int)]
07:04:03 <doesntcontribute> Not sure if that’s different
07:04:04 <ski> oh, that's something else
07:04:47 <ski> you'll need to use `sequence' first, to get an `IO [(Int,Int)]'. then if you execute that, getting an `[(Int,Int)]', you can then use `unzip' as usual
07:05:18 <ski> carbolymer : but again, is there a reason why you're having those `IO'-actions in the list, to begin with ? perhaps you could avoid putting them in there, in the first place
07:05:18 <doesntcontribute> Ok thanks. What is the term for what I have?
07:05:21 <ski> er
07:05:23 <ski> doesntcontribute ^
07:05:38 <iphy> a hoogle that can figure out these things would be awesome
07:05:50 <ski> you have a list of actions (producing pairs)
07:06:06 <doesntcontribute> Ok thanks 
07:06:08 <iphy> I guess it would be possible, but quite expensive, to implement it
07:07:31 <ski> doesntcontribute : anyway, putting actions into lists is "more advanced" (not really very advanced, but still a step above simple use of `IO'). it hints to me that, maybe, you're just having the actions in the list, because you're not aware of a better way of doing what you want to do
07:07:32 <iphy> MarcelineVQ: distributive               > Installing library in C:\sr\snapshots\3aa9d686\lib\x86_64-windows-ghc-8.6.5\distributive-0.6.1-H4In096pSIwLfOtDKyX84P
07:07:40 <iphy> these messages are worrying me
07:07:58 <doesntcontribute> Ski: absolutely this is what is happening
07:08:06 <ski> doesntcontribute : there are situations where one wants to do stuff like having actions in lists. but if one doesn't need to, i'd recommend not putting them in lists
07:08:18 <MarcelineVQ> iphy: does that dir exist? C:\sr in particular?
07:08:24 <iphy> no idea :)
07:08:30 <iphy> but.. probably?
07:08:35 <iphy> https://ci.appveyor.com/project/iphydf/hs-toxcore/builds/31323875#L2599
07:08:45 <ski> doesntcontribute : so, where does this list of actions come from ?
07:09:19 <int-e> . o O ( That's too philosophical for me. )
07:09:25 <ski> doesntcontribute : could you change the source of it to instead make an action that will produce a list when run/executed ?
07:09:55 <MarcelineVQ> sounds like your stack root has been set to C:\sr instead of in %localappdata%, hence the sr I would further guess
07:11:53 <Phyx-> iphy: uhm.. you're mixing stack and cabal builds in the same build matrix job
07:12:45 <Phyx-> iphy: when you install cabal via chocolatey it autodetects appveyor and sets a global store-dir. hence the C:\sr to prevent MAX_PATH issues
07:13:42 <Phyx-> it's nothing to worry about though. the path is valid for Cabal, it just sets the temp build folder. just to make sure long packages can build.
07:14:18 <Phyx-> but if you don't want the cross polination, move the stack and cabal builds to a different matrix
07:15:53 <doesntcontribute> does freenode have an app?
07:16:06 <doesntcontribute> I’m on a bus and I’m on my phone and this 
07:16:10 <doesntcontribute> Isn’t working
07:16:35 * ski has no idea, sorry
07:16:48 <doesntcontribute> Ya I don’t there is
07:16:56 <ski> <doesntcontribute> Ski: absolutely this is what is happening  <ski> doesntcontribute : there are situations where one wants to do stuff like having actions in lists. but if one doesn't need to, i'd recommend not putting them in lists
07:17:04 <ski> <ski> doesntcontribute : so, where does this list of actions come from ?  <ski> doesntcontribute : could you change the source of it to instead make an action that will produce a list when run/executed ?
07:17:11 <[exa]> doesntcontribute: andchat / yaairc are pretty good
07:17:14 <MarcelineVQ> it has a webchat but it's not an app it's a webpage and it's awful (as any webchat is), I doubt there's an app since if there was a person could replace the webchat with a webpage version of it pretty easily
07:17:41 <ski> yea, MarcelineVQ, doesntcontribute is already using that, i think
07:17:59 <doesntcontribute> I’m basically trying to go from IO (Int,Int) to
07:18:19 <doesntcontribute> IO [(Int,Int)]
07:18:28 <ski> using a separate stand-alone IRC client on the phone might be a good suggestion, though, if you're willing to try
07:18:41 <doesntcontribute> I tried using zipWith but that got me 
07:18:45 <ski> doesntcontribute : and you're using `map' or a list comprehension, for that ?
07:19:03 <doesntcontribute> [IO (Int,Int)]
07:19:12 <ski> i mean, arriving at `[IO (Int,Int)]', from `IO (Int,Int)'
07:19:14 <ski> yea
07:19:21 <iphy> Phyx-: I'm not...
07:19:25 <iphy> Phyx-: the problem is happy
07:19:45 <iphy> Phyx-: if I use stack without first cabal install happy, I get "can't find happy to build happy" type of errors
07:20:14 * ski . o O ( "Happy, Happy. Joy, Joy." <https://www.youtube.com/watch?v=eVM1nUmDHHc> )
07:20:15 <[exa]> doesntcontribute: perhaps you could tell us what's the bigger perspective on the problem because this sounds theoretical and partially misfired in fact
07:20:23 <[exa]> also
07:20:40 <[exa]> :t fmap (:[]) (readLn :: IO (Int,Int))   -- <== doesntcontribute
07:20:42 <lambdabot> IO [(Int, Int)]
07:20:47 <Phyx-> iphy: you should be able to specify happy as a build depends. I don't know how stack handles tool dependencies, but it surely must have a way
07:20:48 <ski> doesntcontribute : so, are you using `map' or a list comprehension, to get to `[IO (Int,Int)]' ?
07:21:22 <iphy> Phyx-: https://github.com/commercialhaskell/stack/issues/157
07:21:27 <iphy> I get this error
07:21:36 <Phyx-> iphy: as soon as you do `choco install ghc cabal` it assumes you want to build using cabal :) since typically you wouldn't have stack and cabal in the same configuration
07:21:46 <iphy> ok
07:21:51 <iphy> I'll try without it, then
07:21:53 <doesntcontribute> ski: I used zipWith 
07:22:44 <Phyx-> iphy: alternative, after you finish installing happy, run `cabal user-config init -f` which will reset the configuration file to default
07:22:49 <ski> doesntcontribute : so, use `zipWithM' instead ?
07:22:52 <MarcelineVQ> that's an awfully old issue, what verison of stack are you on? is happy required for a dependency or for your own project?
07:23:43 <doesntcontribute> Ok I’ll try that
07:23:59 <ski> doesntcontribute : for `map', i'd suggested using `mapM' instead
07:25:01 <doesntcontribute> ok I’ll try that thanks
07:25:24 <iphy> MarcelineVQ: it's for a dependency, for most of my projects
07:25:31 <iphy> one project also needs happy, itself
07:25:55 <iphy> Phyx-: https://ci.appveyor.com/project/iphydf/hs-schema/builds/31324247
07:26:01 <MarcelineVQ> is happy listed under https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-build-tool-depends for that project?
07:26:08 <iphy> this is the simplest build, without cabal, and it still talks about c:\sr
07:26:35 <iphy> MarcelineVQ: I don't know, but I haven't gotten to that one yet
07:26:44 <iphy> right now I'm trying to build one that doesn't use happy
07:27:50 <Phyx-> iphy: that's because it seems the haskell-stack package also sets C:\sr as the path for the same reason
07:27:53 <Phyx-> iphy: see https://chocolatey.org/packages/haskell-stack#files
07:28:36 <Phyx-> iphy: you can override by passing -params '"/NoStackRoot"' but honestly, I don't think you should
07:28:45 <iphy> I shouldn't
07:28:55 <iphy> all I want to know is what directories I list under "cache"
07:29:04 <iphy> so I don't need to wait 15 minutes for every build
07:29:50 <iphy> so I'm guessing it's c:\sr
07:30:56 <Phyx-> iphy: yes that sounds logical. but again, I don't use stack so not sure of which directories do what. but c:\sr should contain your build cache if it's anything like cabal's usage
07:40:46 <iphy> seems to not be enough
07:41:04 <iphy> maybe C:\Users\appveyor\AppData\Local\Programs\stack does need to be in there
07:41:45 <iphy> "No old cache found, populating cache from scratch" <- I don't know where it stores the cache
07:41:53 <MarcelineVQ> or it's just not caching it, I could never get travis to cache anything at all, but I'm an idiot so ymmv
07:42:12 <iphy> the caching didn't work
07:42:22 <iphy> maybe it's too large
07:42:28 <iphy> appveyor has small limits for the cache
07:43:31 <MarcelineVQ> in my stack cache a single ghc install is already 1.7g
07:47:32 <iphy> circleci has windows builds now.. time to give up on appveyor
07:51:04 <sjhfeke> I am confused by GLUT's display callback http://hackage.haskell.org/package/GLUT-2.7.0.15/docs/Graphics-UI-GLUT-Callbacks-Window.html#t:DisplayCallback
07:51:10 <sjhfeke> It's type is just IO()
07:51:31 <sjhfeke> So how can this function not draw the same each time it is called?
07:51:51 <sjhfeke> The only way that comes to my mind is to save some StateVar in IO, but this seems weird
07:52:07 <sjhfeke> I would expect some StateT monad here, but there is none
07:52:51 <sjhfeke> Am I indeed supposed to use StateVars to communicate DisplayCallback what it is supposed to draw? Or am I missing something?
07:56:42 <[exa]> sjhfeke: you can use IORefs or various other types of refs
07:57:12 <[exa]> sjhfeke: btw why not gloss? :]
07:58:50 <sjhfeke> [exa] I remember about Gloss and intend to check it out :)
07:59:01 <sjhfeke> But since Im trying to learn I thought I'd check out both
08:11:19 <maerwald> is there a lib for signing json or something?
08:12:11 <maerwald> My idea is very specific... not
08:12:19 <[exa]> sjhfeke: Gloss is basically GLUT without having to care about all the tecnical details, I'd recommend going there first
08:12:35 <[exa]> maerwald: signing as in PGP?
08:12:40 <maerwald> Yeah
08:12:55 <[exa]> are there any json-specific signature formatting concerns?
08:13:08 <[exa]> if not, I'd just pipe it through
08:13:28 <maerwald> nah, I just saw there's are some concepts of signature inside json and the payload in a seperate field and then unmangling everything
08:13:37 <maerwald> Dunno
08:13:53 <[exa]> maerwald: my inner cryptographer screams upon seeing such protocols
08:14:08 <maerwald> Yeah, but I wouldn't care if that is all hidden behind a lib
08:14:32 <maerwald> Want to avoid dealing with multiple files
08:14:41 <[exa]> one trouble with json is that the plaintext is not at all unique for fixed "contents"
08:15:00 <[exa]> so you can generate as many different hashes from each valid "content" as you want
08:15:54 <[exa]> which I'd prefer to totally ignore by treating json as a bytestring, getting a detached signature (gpg -s -b) and sending both
08:16:01 <Ariakenom> maerwald: like a json web token, jwt?
08:16:02 <maerwald> Otherwise I would go for something like signify from BSD
08:16:10 <maerwald> And then deal with downloading 3+ files
08:16:53 <maerwald> Ariakenom: just something that signals the content is from me
08:17:14 <maerwald> pgp is annoying enough already
08:18:29 <[exa]> maerwald: if you don't need to share the keys you can just make a HMAC
08:18:52 <[exa]> which should be somewhere in the libs near hashes
08:19:42 <[exa]> (and if not you can construct a pretty good HMAC yourself from almost nothing, just hashes)
08:28:53 * hackage first-class-families 0.8.0.0 - First class type families  https://hackage.haskell.org/package/first-class-families-0.8.0.0 (lyxia)
09:03:56 <kuribas> why does this fail? https://gist.github.com/kuribas/35c318b4f4b835d289acab3b51796a77
09:04:39 <kuribas> I have a (:+:) instance, so it should work
09:06:23 <lyxia> not sure what is wrong, but (a f) and (b f) can be simplified to a and b in that instance
09:07:28 <lyxia> I bet it's because it assumes (f :: Type) without PolyKinds on.
09:07:43 <kuribas> ah right
09:08:04 <kuribas> that works, thanks!
09:08:28 <kuribas> Maybe I should release this as a library
09:08:33 <lyxia> and then it tries to match (a f) with C1 _ U1 but (U1 :: k -> Type) doesn't have kind Type
09:09:16 <kuribas> Type = * ?
09:09:19 <lyxia> yes
09:09:26 <kuribas> ok, I see
09:11:42 <kuribas> What should it do for product types?  Maybe having two separators.
09:12:35 <kuribas> like data SomeData = Field1 Text | Field2 Text Int => "Field1:abc" "Field2:abc,3"
09:35:30 <maerwald> is there a library that shows the continuous output of a file/process in ~5 lines of shell? Basically what the new docker client does
09:35:33 <maerwald> It's pretty cool
09:35:54 <maerwald> E.g. when you have a large build, your terminal doesn't scroll, just a 5 line buffer
09:38:21 <geekosaur> shouldn't be difficult, just set a 5-line scrolling area
09:39:15 <kuribas> Why is haskell tooling so aweful?
09:39:21 <kuribas> I mean editors/IDEs
09:39:47 <maerwald> kuribas: I would say because the compiler isn't simple
09:39:53 <kuribas> I got hie-lsp working for emacs, it's nice when it works, only half of the time or so.
09:39:53 <maerwald> That propagates
09:40:34 <kuribas> It works for lisp/java
09:40:52 <kuribas> I don't have much love for lisp/clojure, but tooling just works in emacs.
09:41:00 <maerwald> clojure tooling never worked for me
09:41:02 <maerwald> All was broken
09:41:35 <maerwald> Go tooling was a bliss, but because the compiler is simplistic
09:41:42 <maerwald> as well as the language
09:41:44 <maerwald> easy to parse
09:42:29 <maerwald> ghc-mod was awesome, back when it worked, no LSP nonsense, but GHC advanced too quickly
09:44:50 <maerwald> As a guy on reddit said recently... when you're coding, your code is broken half of the time and the tooling mostly assumes your code is not broken
09:45:22 <maerwald> And if your code is broken, nothing works
09:46:53 * hackage fb 2.1.0 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-2.1.0 (psibi)
09:49:06 <kuribas> maerwald: indeed
09:49:08 <geekosaur> and mostly has to since it has to ask the compiler for anything interesting
09:49:42 <geekosaur> if ghc haskell had fewer features this would be less true, but even H98 type inference expects a non-broken program
09:49:50 <kuribas> geekosaur: at least it could tell the user what is wrong.
09:49:53 * hackage yesod-fb 0.6.0 - Useful glue functions between the fb library and Yesod.  https://hackage.haskell.org/package/yesod-fb-0.6.0 (psibi)
09:50:13 <maerwald> Lazy compilation, not lazy evaluation
09:50:17 <maerwald> That should be possible!
09:50:18 <kuribas> geekosaur: like, cannot compile because HelperModule.hs has errors.
09:50:31 <kuribas> geekosaur: or, AddedModule.hs is not in cabal file.
09:50:51 <maerwald> It can consider everything with a definition of undefined, unless it needs to look at the definition, no?
09:50:59 <kuribas> geekosaur: also, there are now options to delegate type errors to runtime.
09:53:10 <solonarv> you can defer out-of-scope identifiers too, I think
10:00:24 <kuribas> Now I had to kill the buffer and reload it for flycheck to work :-(
10:02:38 <maerwald> My best story with LSP was when coc.nvim kept respawning infinite hie instances, because it thought one is not enough (until it said hello to the OOM)
10:03:22 <maerwald> Upstream closed the bug report. It did not contain enough information (yes, I didn't try to reproduce it)
10:03:52 <maerwald> LSP is all broken
10:04:52 <kuribas> well in emacs at least
10:04:56 <kuribas> I don't know in other editors
10:05:41 <kuribas> at least flycheck somewhat worked
10:06:04 <kuribas> it would break if another module was broken, but it didn't break all the time like lsp does
10:08:34 <kuribas> There it goes, had to exit emacs another time for flycheck to give me f$@# right error messages.
10:10:46 <kuribas> If there is anything I'd like to see in haskell, it's better editor support, and better error handling in libraries (aeson, servant, cassava, etc...)
10:10:50 <kuribas> Not more type level features.
10:11:41 <zincy__> kuribas: Yes absolutely
10:12:31 <kuribas> Or having flamewars over which is the right effect system to use
10:13:21 <zincy__> Oh I missed those
10:13:40 <kuribas> flamewar may be a bit exagerated though  :-)
10:13:50 <zincy__> Maybe I should read Reddit more
10:14:08 <maerwald> Better error handling will probably never happen
10:14:11 <zincy__> Although a lot of it seems to be very advanced stuff for r/haskell
10:14:19 <zincy__> Kinda over my head
10:14:52 <maerwald> No checked exceptions, open variants suck. Only alternative is MonadThrow or IO and then you have no idea what's going on either.
10:15:11 <kuribas> zincy__: I find the higher kinded approach overrated.
10:17:04 <kuribas> zincy__: same with recursion schemes.
10:18:07 <maerwald> I'm currently using Excepts heavily and I am quite disappointed
10:18:44 <tom__> maerwald: You mean ExceptT?
10:19:00 <maerwald> no
10:19:08 <maerwald> https://hackage.haskell.org/package/haskus-utils-variant-3.0/docs/Haskus-Utils-Variant-Excepts.html
10:19:23 <maerwald> ExceptT is even more useless :)
10:20:09 <tom__> maerwald: What would you recommend?
10:20:16 <maerwald> So it's basically the boring haskell (MonadThrow) vs over-complicated open variant solutions
10:20:25 <maerwald> tom__: I'm dissatisfied with all of the alternatives
10:22:03 <tom__> Im unfamiliar with monadThrow and mtl actually
10:22:17 <maerwald> The Excepts/open-variant thing has a lot of problems: 1. type inference is gone, you have to help the type checker a lot and end up with lots of verbose type signatures
10:22:22 <maerwald> 2. you never know whether you have extraneous error types in your variant, only if some are missing
10:22:27 <maerwald> 3. you have to lift a lot, basically everything
10:22:45 <maerwald> And 4. you still have no idea whether you catched anything from an inner Monad
10:23:01 <tom__> Interesting
10:23:26 <tom__> So what is the benefit of using MonadThrow instead of ExceptT?
10:23:37 <maerwald> So all this does is basically give you a little type-level hint whether your documentation is out of date
10:23:48 <maerwald> So documentation might actually be the way to go
10:23:59 <maerwald> And then write tests for your exceptions
10:24:05 <tom__> maerwald: Yeah quite a nasty trade off
10:24:39 <maerwald> Here is a blog post pro MonadThrow, but I find most of it to be false: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
10:25:02 <dmwit> kuribas: Do you find this conversation as ironic as I do?
10:25:10 <maerwald> The point of ExceptT is not to have no exceptions of an inner Monad. It's a glorified IO (Either a b), that allows you to short-circuit easier
10:25:18 <tom__> dmwit: In what way?
10:25:45 <kuribas> dmwit: haha, yes
10:25:48 <maerwald> EitherT was in fact a better name
10:26:04 <dmwit> tom__: pretty much started from "I'd rather have better editor support than more flamewars over which is the right effect system"
10:26:27 <maerwald> We're not talking abou effects systems yet :)
10:26:39 <tom__> ah haha
10:26:46 <maerwald> And btw... instead of using Excepts/open variants, we could go full POLYSEMY
10:27:03 <dmwit> "we're not talking about effects systems" is true only in the narrowest possible interpretation of kuribas' opener, I think.
10:27:09 <tom__> ExceptT vs MonadThrow - neither are effect systems
10:27:15 <maerwald> mtl kinda is
10:27:34 <maerwald> our most boring version of it
10:27:38 <maerwald> so boring most ppl don't consider it one
10:27:53 <tom__> oh
10:31:31 <maerwald> MonadLogger is a good example of it, where it's reasonable to have different interpreters.
10:32:11 <maerwald> Basically, I want error-chain from rust.
10:32:23 <maerwald> https://docs.rs/error-chain/0.12.2/error_chain/
10:32:45 <maerwald> Everything composes, everything is introspectible, you don't lose any information
10:33:39 <justsomeguy> I'm going though the chapter on algebraic data types in haskell programming from first principles, and they keep on mentioning kinds. Kinds seem like a very simple concept, but why do they matter?
10:33:44 <maerwald> But yeah, you don't particularly see the *type* of error a function may throw. It's probably more like a huge sum type with ExceptT
10:33:58 <maerwald> I'm giving up.
10:34:01 * maerwald goes back to IO
10:34:30 <tom__> justsomeguy: Kinds are types of types
10:34:58 <tom__> So they matter for comparing types
10:36:18 <justsomeguy> Do they do anything beyond comparing the number of unsaturated data constructors a type has?
10:36:51 <solonarv> at a basic level, that's pretty much all you can express with them
10:37:08 <solonarv> with GHC extensions and so on, you can do some fancier things, but that will come later
10:37:46 <maerwald> DataKinds, type families, GADTs, flexible instances, darkness, ...
10:37:50 <maerwald> -XDarkness
10:38:04 <maerwald> You successfully entered the next realm of horror
10:38:11 <justsomeguy> Ok, so it's nothing magical. Because the book I'm reading keeps on mentioning them over and over I thought there may be more to it. GHC extensions are like black magic...
10:38:17 <tom__> kinds dont count data constructors
10:39:04 <solonarv> they're mentioned a lot because they *are* important
10:39:15 <solonarv> lest you find yourself writing: instance Functor (Maybe a)
10:39:31 <solonarv> or trying to write a Functor instance for: data MyThing = MkMyThing Int Int
10:39:58 <tom__> solonarv: haha i have been doing that today
10:40:14 <tom__> I have never really written my own instances so it is high time
10:42:24 * hackage aeson-combinators 0.0.2.0 - Aeson combinators for dead simple JSON decoding  https://hackage.haskell.org/package/aeson-combinators-0.0.2.0 (MarekFajkus)
10:45:54 <hololeap> maerwald: i've read a couple articles by snoyberg on exception handling in haskell and it seemed to make sense
10:46:03 <hololeap> https://tech.fpcomplete.com/blog/2018/04/async-exception-handling-haskell
10:46:32 <maerwald> His points about 'ExcepT e IO a' make no sense to me though
10:46:53 <maerwald> async is a different discussion yeah
10:49:06 <hololeap> well, his points on ExceptT e IO a seem pretty solid. i am interested in hearing your counter-points
10:50:17 <maerwald> I wrote them further up already: ExceptT is not about catching all exceptions of the inner Monad. ExceptT is a glorified IO (Either a b), that allows you to short-circuit and express Failures that must be explicitly handled
10:50:25 <maerwald> If you need functions that never crash, you have to do more work anyway
10:51:00 <maerwald> Using MondaThrow basically hides everything and if you have MonadIO, everything is an Exception anyway
10:51:17 <maerwald> Which is pretty bad API. Now you have no idea about expected failures and unexpected failures
10:51:20 <maerwald> Everything is just failure
10:53:26 <maerwald> I use MonadThrow too, but not for expected failures, but for unexpected ones that I have no idea how to handle. Low-level API is of course again a different discussion. When you're on e.g. filesystem level, you don't know what is expected and what isn't
10:54:10 <maerwald> https://hackage.haskell.org/package/libarchive-2.2.3.0/docs/Codec-Archive.html#t:ArchiveM I consider this a solid use case of ExceptT
10:55:40 <hololeap> oh, yeah that part is a bit iffy. that later blog post is a bit more refined i think, and a lot of it is in UnliftIO.Exception. basically, he just pushes all exceptions into IO and uses throwIO instead of throwError
10:56:55 <hololeap> i also found this one interesting: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
10:57:35 <maerwald> He's repeating again there that ExceptT .. IO .. is bad. And I disagree again :)
10:58:02 <maerwald> And ReaderT I consider a quite useless monad. It is just convenience, it doesn't add anything
10:58:18 <hololeap> wow you read that fast
10:58:20 <koz_> Is this Snoymanisms again?
10:58:26 <koz_> hololeap: Because it's nothing new.
10:58:26 <monochrom> :)
10:58:32 <maerwald> heh
10:58:37 <koz_> Snoyman is highly opinionated, and many people consider his opinions to be wrong.
10:58:40 <koz_> (myself included)
10:59:05 <maerwald> There's one case where I strongly agree with him though
10:59:08 <monochrom> Strong convictions are always wrong. :)
10:59:10 <koz_> (don't even get me started on his stuff regarding 'simple Haskell')
10:59:18 <koz_> (since it's incoherent at best and misleading at worst)
10:59:24 <koz_> maerwald: That being?
10:59:26 <maerwald> https://gitlab.haskell.org/ghc/ghc/wikis/proposal/abstract-file-path
10:59:32 <maerwald> At least he's listed as an author
10:59:52 <koz_> Is that loading real slow for you?
10:59:55 <maerwald> Yeah
10:59:58 <monochrom> Yes
11:00:23 <koz_> :(
11:00:31 <hololeap> i agree that it is highly opinionated, but it seems silly to just dismiss it. he points out a lot of the issues with the exception system in haskell and gives ways to work around it. again i'd have to see counterpoints to say something like "his opinion is wrong"
11:00:44 <koz_> hololeap: I believe maerwald just made some.
11:00:46 <hololeap> *work with it rather
11:00:48 <maerwald> hololeap: oh absolutely, I just cherry-picked on a few points
11:00:54 <maerwald> I use his exceptions-safe lib too
11:00:58 <monochrom> I would use ExceptT m as "m (Either ...) but I don't have to keep writing my own case-of" too.
11:01:06 <maerwald> exactly
11:02:20 <justsomeguy> Ah, I had a bunch of follow up questions about kinds but got distracted by something in the coffee shop here and lost track ...
11:02:30 <koz_> justsomeguy: Coffee shops do that. :P
11:02:33 <maerwald> justsomeguy: what was it?
11:02:39 <koz_> (it's one reason I never quite know how folks can say they work in them)
11:03:11 <maerwald> koz_: It's like a family room full of ppl you don't know
11:03:27 <koz_> maerwald: With caffeine.
11:03:30 <koz_> In large quantities.
11:03:57 <maerwald> Always get the decaf.
11:04:05 <koz_> maerwald: I only get decaf when I must.
11:04:06 <justsomeguy> Sometimes intentionally ignoring background noise makes me focus harder on what I'm trying to do. It's a strange phenomena.
11:04:19 <koz_> Sadly, I know I have a hard limit of 1 cup a day or I go full bananas.
11:04:24 <maerwald> Training your adhd coping mechanisms, hehe
11:04:29 <monochrom> Some people can tune out; I'm one of them though not very strong.
11:04:37 <hololeap> yeah novelty can keep the mind alert. i suppose it depends on one's mood
11:04:41 <koz_> maerwald: I wasn't gonna say it, but you beat me to it. :P
11:04:50 <justsomeguy> Haha, I probably do have adhd, to be honest. Never had that checked.
11:05:13 <maerwald> Digital information age. Everyone has. Some worse, some less.
11:05:14 * justsomeguy has all the typical symptoms
11:05:20 <justsomeguy> Oh, that too.
11:06:01 <koz_> I find any background noise drives me mad, especially if it's conversation in a language I understand.
11:06:04 <hololeap> anyway i don't think that snoyman's point was "never use ExceptT around IO", just that it may not do what you think it does
11:06:15 <maerwald> hololeap: but I know what it does :D
11:06:37 <maerwald> I think it might be a pitfall for beginners, but other than that...
11:06:54 <maerwald> Then again, I'm not convinced heavy use of MonadThrow and IO will make anything easier for a beginner
11:07:11 <hololeap> yeah that doesn't seem like a good solution
11:07:39 <hololeap> his idea of stuffing all exceptions into IO makes the most sense to me
11:07:41 <maerwald> Beginner wants to know what expected failure should be handled, not read documentation and code to figure out when to cach something
11:07:48 <maerwald> MonadThrow doesn't even show you what is thrown...
11:08:23 * hackage aeson-combinators 0.0.2.1 - Aeson combinators for dead simple JSON decoding  https://hackage.haskell.org/package/aeson-combinators-0.0.2.1 (MarekFajkus)
11:08:31 <hololeap> and i'm definitely not saying that there isn't a time/place for ExceptT/Either
11:08:33 <maerwald> And then matching the exception type in catch/handle is clunky
11:09:50 <maerwald> hololeap: well, it's in a way "consistent". But I feel giving up on "expected vs unexpected failure" is too early.
11:10:00 <merijn> Just use explicit Either/Maybe in APIs and optionally do IO exceptions
11:10:31 <maerwald> merijn: absolutely. For external library API I do. But the inner function can use exceptT regardless ;)
11:10:57 <maerwald> No one will ever know...
11:11:10 <hololeap> maerwald: no, i totally agree. i wouldn't give up on Maybe and just do `throwString "Nothing returned"` :)
11:11:49 <hololeap> but the fact that IO can throw an exception at any time is something that should be considered deeply
11:11:59 <maerwald> Yes, it's unsettling
11:12:05 <maerwald> I still lose sleep over it :P
11:12:34 <justsomeguy> I love this quote from Wadlers monad paper ... "Pure functional languages have this advantage: all flow of data is made explicit. And this disadvantage: sometimes it is painfully explicit." :^)
11:13:23 <hololeap> yeah, luckily composition can really help with making sure it's only explicit once
11:13:57 <maerwald> Is data flow really explicit with transformers? *music intensifies*
11:14:33 <hololeap> only if you memorize the source code
11:14:51 <maerwald> Only my own :/
11:22:21 <hololeap> anyone care to comment on the validity of this: "If you have a runtime exception, you will lose your state in WriterT and StateT. Not so with a mutable reference: you can read the last available state before the runtime exception was thrown."
11:24:22 <merijn> hololeap: What do you wanna hear besides "that's 100% correct"
11:24:45 <merijn> I mezn, what else can they do?
11:25:40 <hololeap> i just wanted to know if old man snoyman's off his rocker again
11:25:55 <qmanga> Hi. I tried installing haskell using the instructions at https://www.haskell.org/downloads/linux/ . They don't work as written. I'm guessing I need to replace the 'XXX' and 'YYY' with... something? How should I find out the something?
11:26:05 <qmanga> (the topmost instructions, for Ubuntu)
11:27:11 <justsomeguy> qmanga: Personally I prefer to install Haskell with stack, https://docs.haskellstack.org/en/stable/README/
11:27:21 <hololeap> it's just something i hadn't considered before. it lends credibility to his "pattern" of using something like `ReaderT (IOVar w) IO a` rather than `WriterT w IO a`
11:28:07 <hololeap> *TVar
11:29:06 <solonarv> qmanga: my install method of choice is ghcup
11:29:30 <solonarv> it is basically just a shell script that downloads GHC & cabal and puts them in ~/.ghcup
11:31:02 <justsomeguy> qmanga: If you want to use the instructions for ubuntu you linked to, after you enable the ppa you can do "apt refresh; apt search cabal-install\* ghc-\*" to find full package names similar to those in the example that you can use.
11:31:42 <qmanga> Wow, so many options. I would have assumed haskell.org's method would be the "official" option (in which case, it's a shame the first one they list is broken).
11:32:13 <kosmikus> qmanga: it's not broken
11:32:38 <qmanga> I'm happy to use anything which will get me a working ghc :)  I've previously used ubuntu's built in ghc but I now need something more up to date.
11:33:29 <maerwald> If you are on debianoid distro, use hvrs ppa
11:33:43 <qmanga> @kosmikus : Maybe broken is a bit blunt. I feel it's broken, as it doesn't make clear (at least to me) that XXX and YYY are strings that you need to fill in yourself with the versions you want (people who do a lot of haskell are possibly more used to the idea of tracking the exact version they are installing)
11:33:43 <lambdabot> Unknown command, try @list
11:33:45 <kosmikus> it's a perfectly fine method to install ghc on ubuntu. just choose the versions you want. cabal-install-3.0 and ghc-8.6.5 or ghc-8.8.3 are probably reasonable choices.
11:34:06 <kosmikus> qmanga: you're certainly right that the text isn't ideal.
11:34:27 <kosmikus> qmanga: and your question is very valid.
11:34:31 <qmanga> Thanks all. I will report the confusing text on github, and now have a working ghc.
11:35:36 <justsomeguy> \o/ success!
11:37:13 <justsomeguy> (As a Linux nerd and Haskell noob, I have to admit that after using a bunch of different package managers most programming language toolchains seem pretty awful in comparison. Haskell included.)
11:37:25 <solonarv> it's also bizarre that ghcup isn't linked from that page, tbh
11:37:27 <solonarv> @where ghcup
11:37:27 <lambdabot> https://www.haskell.org/ghcup/
11:37:38 <solonarv> ^ look, it has its own page on haskell.org!
11:37:57 <maerwald> Everything is confusing 
11:38:13 <justsomeguy> Such is life.
11:38:53 * hackage partial-order 0.2.0.0 - Provides typeclass suitable for types admitting a partial order  https://hackage.haskell.org/package/partial-order-0.2.0.0 (mtesseract)
11:41:03 <maerwald> https://github.com/haskell-infra/www.haskell.org/issues/12
11:41:16 <maerwald> I opened that ticket. But no idea
11:41:52 <kuribas> #$@ lsp sucks so much, I think I'll go back to plain flycheck-mode...
11:42:02 <kosmikus> interesting. I somehow remember that I saw a link to ghcup somewhere on haskell.org. I must have imagined it.
11:42:21 <kuribas> it's not detecting changes I make in other buffers
11:42:25 <maerwald> Yes, the only link is on haskell platform 
11:42:29 <kuribas> in the same project!
11:42:31 <koz_> kuribas: Is this with HIE?
11:43:04 <hololeap> justsomeguy: there is gentoo-haskell, which uses gentoo's pacakge management system for dependencies and builds everything from source. it's far from perfect, but if you're familiar with gentoo you might like it
11:43:47 <maerwald> Uh oh
11:44:00 <maerwald> It doesn't handle multiple GHCs properly 
11:44:19 <justsomeguy> hololeap: I spent a few months with gentoo on my main workstation, and really liked it. I'll have to give it a shot! (I also intend to get into NixOS in the near future, but figured I should get a better grasp of the fundamentals first.)
11:44:46 <maerwald> Don't bother with haskell on gentoo, imo
11:45:09 <justsomeguy> Eh, I'll just try all the options. Might as well.
11:45:47 <hololeap> there are some big pitfalls with it... only one version of GHC supported atm, not everything on hackage is available as an ebuild, lots of recompiling when dependencies change
11:45:54 <maerwald> And it overuses subs lots to avoid breaking dep
11:46:00 <justsomeguy> Hmm...
11:46:03 <maerwald> Not really a clean solution 
11:46:27 <maerwald> *subslots 
11:46:34 <hololeap> it works for me but i'm also a big gentoo nerd, contributing to the project and writing ebuilds, etc.
11:46:46 <maerwald> I've been a gentoo dev :p
11:46:52 <kosmikus> even though I originally helped set up Haskell infrastructure on Gentoo, I have to agree with maerwald
11:47:04 <kosmikus> you can use Gentoo to obtain your preferred ghc
11:47:11 <kosmikus> but don't use it to provide Haskell libraries
11:47:26 <kosmikus> there is not Linux distribution except perhaps NixOS that can be used for this
11:47:57 <kosmikus> s/not/no/
11:48:11 <hololeap> one thing i like about it is automatic handling of non-haskell dependencies, and USE flags for haskell packages just like all your other packages
11:48:19 <maerwald> Yes and it uses fake packages for the base packages that are shipped with GHC. This makes it hard to support multiple GHCs
11:48:56 <maerwald> I removed all of that on exherbo and can have multiple GHCs just fine with no haskell libs
11:49:10 <hololeap> and it's easy to compile source from a git repo, although newer cabal does make a lot of this less novel
11:50:28 <maerwald> Basically how you package go and rust too: there are only applications, no libraries 
11:52:12 <hololeap> maerwald: are you an exherbo dev?
11:53:23 <maerwald> Exherbo is distributed, ppl have their own repos that are advertised centrally 
11:53:37 <maerwald> No politics 
11:53:53 <hololeap> i didn't necessarily mean *official* dev
11:54:00 <maerwald> Yes, I have a repo
11:54:30 <maerwald> https://git.exherbo.org/summer/repositories/hasufell/index.html
11:55:50 <hololeap> ok, so you just packaged cabal-install, ghcup, and stack and left it at that
11:55:56 <maerwald> And ghc
11:56:05 <maerwald> Both source and bindist 
11:56:09 <hololeap> oh right, dev-lang/GHC
11:56:27 <maerwald> I'm a little slacking though 
11:57:15 <hololeap> i mean gentoo-haskell is a mess and could use an overhaul, especially considering the newer features of cabal
11:57:35 <kuribas> koz_: yes
11:57:54 <koz_> kuribas: Yeah... my experience with HIE has not been very positive either.
11:58:22 <kuribas> koz_: ok, it kinda works if I change something, then change it back.  
11:58:46 <kuribas> koz_: several times it didn't work, I restarted emacs and then it did work.
11:59:01 <hololeap> but in theory it could be awesome as long as you don't mind the compilation stuff
11:59:53 <hololeap> multiple GHC slots would be a good start, but a deep look at how cabal could mesh with portage seems necessary at this point
12:02:07 <hololeap> maerwald: do you use gentoo anymore or are you purely exherbo at this point?
12:02:41 <maerwald> I don't use it anymore, because of portage. And at work I'm not allowed to use exherbo
12:03:39 <hololeap> i used paludis on gentoo for a while, but it seemed like it was choking on a lot of the poor-quality packages
12:03:50 <maerwald> Yes and now with EAPI=7 it's gone completely
12:03:53 * hackage mmsyn7s 0.6.6.0 - Shows a sorted list of the Ukrainian sounds representations that can be used by mmsyn7 series of programs  https://hackage.haskell.org/package/mmsyn7s-0.6.6.0 (OleksandrZhabenko)
12:04:01 <hololeap> i should honestly give exherbo another chance since i'm doing a lot more dev-ing these days
12:04:13 <maerwald> I used to push for official paludis support on gentoo, but most devs had NIH syndrome.
12:04:49 <hololeap> NIH syndrome?
12:04:52 <maerwald> It also became increasingly annoying with subslots
12:04:55 <maerwald> not invented here
12:05:30 <maerwald> I got kicked from #gentoo IRC (as a gentoo dev), because I gave support for paludis xD
12:05:39 <maerwald> So long...
12:06:20 <maerwald> Imagine ppl here got kicked because they gave stack support
12:06:46 <maerwald> Politics :)
12:07:06 <maerwald> (wonder if I got the grammar right... imagine ppl here would have gotten kicked?)
12:07:09 <[exa]> maerwald: dude, paludis was a forbidden matter
12:07:14 <maerwald> lol
12:07:23 <hololeap> yeah, they're very uptight in that channel. we would probably be scolded right now for being OT. or using "bad words" like crap
12:07:50 <glguy> whoa whoa whoa let's get it under control, people
12:08:58 <maerwald> hololeap: another problem is that paludis is very difficult C++ code. Doesn't see many contributors
12:09:07 <tom__> Are nested Zippers used often and if so when?
12:09:55 <maerwald> hololeap: and in fact... the plaudis exherbo uses is a fork of paludis! haha
12:10:20 <maerwald> The native multiarch patch was never merged upstream
12:10:27 <[exa]> tom__: I've got a feeling that a zipper of zippers is almost by definition a single-level zipper anyway...
12:11:08 <maerwald> hololeap: so if you intend to run steam on linux, forget exherbo
12:11:15 <tom__> [exa]: yeah
12:12:21 <[exa]> tom__: that said, I can't imagine a good use case where this combination would help much
12:12:41 <[exa]> except for totally mechanic ones
12:13:33 <hololeap> maerwald: i'll try running it in a VM then
12:13:59 <maerwald> It used to have musl support, which might be interesting for haskell. But I haven't checked how it is today
12:14:59 <geekosaur> there was a fork of xmonad that played with zippers of zippers for floating window support. it was indeed just a more annoying single level zipper.
12:15:01 <hololeap> i would love to see a gentoo/exherbo package manager written in haskell. i started on that once but the SAT solving and graph theory for dependency calculation was over my head, not to mention all the little bits and pieces that have to be exactly right
12:15:01 <tom__> So is a zipper basically a stream with an Index?
12:15:31 <schlaftier> tom__: I once wrote a zipper to operate on trees, but it was still just one zipper, even though the data structure was nested.
12:15:34 <ski> one can have zippers into trees,&c., too
12:15:52 <maerwald> hololeap: the paludis author is a CS prof in Scotland somewhere :P
12:16:11 * ski idly ponders `MapZipper'
12:16:17 <hololeap> yeah at glasgow if i remember correctly... ?
12:16:43 <maerwald> Even if you manage the SAT solving... one of the hardest parts is actually the atomicity, merging of files and recovery on failures and interrupts.
12:16:49 <maerwald> Portage gets none of that right
12:16:55 <maerwald> Paludis does and very carefully
12:17:26 <sjhfeke> asdfs = [    "asdf",    "asdf"]
12:17:28 <maerwald> That's also why the "database" must be on the same file system (as in: no portable file copy)
12:17:31 <sjhfeke> this works
12:17:39 <sjhfeke> but splitting this into lines doesn't
12:17:41 <tom__> I am wondering if a stream of zippers is a good way of representing possible game states for a game ai
12:17:45 <sjhfeke> asdf = [
12:17:48 <sjhfeke>     "asdf",
12:17:52 <sjhfeke>     "asdf"
12:17:53 <sjhfeke> ]
12:17:54 <maerwald> hololeap: it's just too much work
12:17:57 <sjhfeke> this doesnt work
12:18:06 <sjhfeke> why?
12:18:10 <[exa]> tom__: very naively, zipper is any data structure that you "hold in the middle" instead of the beginning as usual
12:18:16 <maerwald> And the haskell stdlib isn't good enough for that. So you'd have to use unix package all the way
12:18:18 <[exa]> sjhfeke: what's the error?
12:18:31 <sjhfeke> parse error (possibly incorrect indentation or mismatched brackets)
12:18:35 <sjhfeke> on the closing ]
12:18:37 <geekosaur> that should work, with some caveats like indentation being modified by what's around it (notably, do and let use layout)
12:18:53 <tom__> You could have an algorithm that moves the Ixs along a bunch of zippers and then folds over them to select the action?
12:19:04 <geekosaur> right, it probably needs to be indented
12:19:45 <[exa]> sjhfeke: eh, perhaps indent "asdf" more? (into the actual [ block)
12:19:47 <hololeap> maerwald: i think it might be fun (or terrible, depending on one's aptitude) just to do the dependency calculation part and see if you could leverage parallelism to make it faster. that's a big gripe of mine about portage is that it can be real slow during the dependency calculation phase
12:20:19 <sjhfeke> Snippet: https://ideone.com/ieCIzw
12:20:36 <geekosaur> if the ] isn't indented at all, but it's inside a let, the ] has to be indented so it's inside the let bindings
12:20:59 <sjhfeke> Oddly, the uglier version https://ideone.com/jOYmbQ works
12:21:11 <maerwald> hololeap: portage switches the algorithm mid-calculation if the calculation takes too long xxxD
12:21:25 <sjhfeke> ugh so the ] must be indented? ...
12:21:27 <geekosaur> hm, is layout active there too? might well need to indent it at least one space
12:21:41 <tom__> oh no one is complaining, well I will try it and report back
12:21:58 <sjhfeke> OK this works https://ideone.com/W6TkaB but I somehow find it ugly
12:22:05 <hololeap> python just isn't a good language choice for something like that... imo
12:22:07 <[exa]> sjhfeke: many people will recommend this form https://ideone.com/2PXcYO
12:22:09 <maerwald> hololeap: pkgcore was very promising, but brian quit gentoo long ago. And no one has the python skills to pick up his code
12:22:10 <geekosaur> yep
12:22:21 <maerwald> hololeap: oh python is fine, if you have the low-level python skills
12:22:23 <maerwald> brian had
12:22:47 <sjhfeke> exa ty; this looks weird for me though; idk maybe im just too used to indentation habits from other langs
12:23:06 <[exa]> sjhfeke: I don't find it extremely appealing as well but usually I write it in whatever manner and then just run hindent to make it cooler
12:23:13 <hololeap> interesting, yeah i remember seeing pkgcore listed alongside portage and paludis way back
12:23:14 <geekosaur> I think most of us would indent to the [
12:23:32 <maerwald> He actually got paid to work on pkgcore afair, as a multi-format package manager or something
12:23:48 <maerwald> Then he moved to NYC for better work-life balance (LOOOL)
12:24:46 <[exa]> sjhfeke: anyway the thing with indentation is that it's measured from the first indented line, any step back means there's a "block out" or "dedent" or what you call it
12:24:53 * hackage configurator-pg 0.1.0.6 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.6 (vollmert)
12:26:26 <[exa]> maerwald: pkgcore funding is so good that it allows people to move to nyc?!
12:26:33 <maerwald> lolo
12:26:44 <maerwald> I think it was more of an abandonment
12:27:01 <maerwald> Burnout from gentoo politics
12:27:19 <ski> sjhfeke : "ugh so the ] must be indented? ..." -- yes .. unless you want to manually add `;'s
12:27:37 <maerwald> but yeah... writing your own gentoo PM isn't a simple side-project. 
12:27:43 <hololeap> the complexity of dependency hell for gentoo-style dependencies seems like it's way higher than for cabal, apt, etc... with things like `>=app-misc/thingus-4.83[foo?,-bar,baz]`
12:27:56 <maerwald> Doing the same for arch linux is reasonable (and there already exists a haskell implementation)
12:28:02 <maerwald> Yes true
12:28:24 <maerwald> So if you like package managers, have a shot at pacman (pun intended)
12:29:02 <hololeap> there's a haskell implementation of pacman... really?
12:29:43 <maerwald> yes
12:29:46 <hololeap> i'm not sure i like package managers per-se, but if you could find the right tools to make a daunting task like that relatively simple... well that just sounds extremely satisfying...
12:29:59 <maerwald> @hackage aura
12:29:59 <lambdabot> http://hackage.haskell.org/package/aura
12:30:46 <hololeap> i wonder if propagators would be a good fit for dependency resolution
12:32:28 <[exa]> hololeap: you can't solve complex instances of SAT with anything, the only way is to remove the complexity
12:32:49 <[exa]> hololeap: which should have happened to gentoo package specs quite long ago
12:34:17 <maerwald> well, exherbo doesn't have || deps, but I'
12:34:23 <maerwald> I'm not sure that's the biggest problem
12:34:45 <maerwald> and REQUIRED_USE is also not part of dependency calculation (it gets translated into a pkg_pretend phase)
12:35:35 <[exa]> the main problem is that the ebuilds have so many features that require global "support" that I can't even remember
12:36:00 <maerwald> Yeah, over-use of USE flags 
12:36:30 <sjhfeke> exa one more q what's your opinion about wxHaskell? Im asking because if Im trying to make a calculator app it would be convenient to have a button primitivie as well as a textbox primitive instead of having to draw them myself (as both gloss and glut require)
12:37:07 <[exa]> that's useflags, keywords, masks, there's some kind of per-group use flags AFAIK, the commandline and per-package settings, .....
12:37:20 <ddellacosta> so this is a shot in the dark and I won't be surprised if I just get folks laughing at me but: a while back (last few years?) there was some post on the haskell subreddit where edwardkmett posted a lovely short script doing some file opening, munging, writing, etc.--shell scripting kinda stuff. I bookmarked it (I thought) as I thought it was lovely but now I can't find it. Does this ring any bells for
12:37:22 <ddellacosta> anyone?
12:37:24 <hololeap> hm, i'm not sure i would like it if the package specs were simplified too much
12:37:40 <sm[m]> hey all. Any thoughts on how to test the ui of brick/vty apps ? You can capture the output, but only in an interactive terminal, otherwise "getTerminalAttributes: illegal operation (Inappropriate ioctl for device)"
12:38:24 <maerwald> ddellacosta: did he use a library?
12:38:25 <[exa]> ddellacosta: anything specific about what it did?
12:38:33 <maerwald> there's shelly and turtle
12:38:34 <sm[m]> expect, maybe
12:38:36 <MarcelineVQ> ddellacosta: edwardk might have an idea, the dread arrow has been fired at any rate
12:38:52 <ddellacosta> maerwald: I recall it being pretty vanilla, in fact I think he was demonstrating how nice he found writing imperative code in Haskell
12:39:03 <geekosaur> exppect, or there's fakepty in the crawl test suite (not haskell)
12:39:03 <ddellacosta> [exa]: not sure past what I've already noted, sorry
12:39:14 <ddellacosta> MarcelineVQ: lol thanks
12:39:23 <[exa]> sm[m]: I don't think that mocking the whole terminal interface would be a way though
12:39:25 <sm[m]> geekosaur: thanks
12:39:54 <sm[m]> I figure if I can at least capture the output and then grep for strings, it would be something
12:40:10 <[exa]> sm[m]: perhaps you could cut the test/mock at incoming events and the output "brick AST" ?
12:40:30 <geekosaur> that may depend on how clever it is about terminal output optimization (e.g. reusing what's already on screen like curses does)
12:40:48 <geekosaur> but not many libraries are as over the top as (n)curses
12:40:56 <sm[m]> exa that sounds like special support needed in brick (probably a good idea)
12:42:33 <[exa]> sm[m]: guess Widget () cannot be compared easily, right?
12:42:59 <sm[m]> I will guess not
12:43:17 <[exa]> sm[m]: it's basically a function that renders it, I see
12:43:53 <[exa]> so you'd need to mock the whole input for that and just check whether it renders the stuff you're expecting.... which is probably not the solution you want
12:47:06 <sm[m]> ooh, nice use of brick for a cardano dashboard: https://github.com/jtdaugherty/brick/issues/260
12:57:49 <sm[m]> wow, expect is rocket science :)
12:59:56 <[exa]> sm[m]: If I didn't sound preventively discouraging at the first time, please note that voice now.
13:01:42 <[exa]> sjhfeke: wxWidgets and GUIs in generall are not very clean programming; I'd suggest you try GTK which is the least "invasive" of the available choices
13:01:50 <sm[m]> exa: what are you discouraging me from, again ?
13:02:07 <[exa]> sm[m]: from trying to test the thing through a VT layer :D
13:02:09 <sm[m]> using expect ?
13:02:28 <[exa]> anyway it seems there's no other choice now
13:05:02 <[exa]> having a vt100 interpreter with programmatic "front-end" would help a lot I guess
13:06:14 * geekosaur has written such; it's not as helpful as one might think
13:07:06 <geekosaur> (screen and tmux are both kinda gross, especially internally)
13:08:53 <geekosaur> it's one thing to write a terminal emulator; screen/tmux-alikes are kinda all the worst parts of using expect
13:11:23 * hackage incremental-parser 0.4.0.1 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.4.0.1 (MarioBlazevic)
13:16:58 <sm[m]> "empty - run processes under pseudo-terminal sessions" seems to be working, and is quite simple
13:17:25 <sm[m]> ah, here: http://empty.sourceforge.net/
13:17:48 <d34df00d> Is a combination of "trees that grow" and "operational monad" patterns well-known?
13:18:50 <ChaiTRex> -
13:18:53 * hackage construct 0.2.0.1 - Haskell version of the Construct library for easy specification of file formats  https://hackage.haskell.org/package/construct-0.2.0.1 (MarioBlazevic)
13:19:11 <d34df00d> I'm basically thinking of a GADT underlying the monad in question to be extensible in trees-that-grow manner, of course, requiring adding extra interpretations for the extra constructors/fields at extension sites.
13:31:24 <[exa]> sm[m]: oh wow that's nice
13:50:37 <mikadou> I'm struggling to extract values from a website using webdriver-w3c and writing them to a database. I'm new to Haskell and just finished chapter 10 in learnyouahaskell book. Is there someone who could point me in the right direction?
13:54:53 * hackage dobutokO2 0.6.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.6.0.0 (OleksandrZhabenko)
13:57:28 <srk> there's also https://hackage.haskell.org/package/posix-pty
13:58:05 <gentauro> when I `stack build`, I can find the binaries at: `$(stack path --local-install-root)/bin` but when I build with `stack build  --profile` the binaries are placed somewhere else.
13:58:15 <doesntcontribute> are there any libraries with functions that return deriv
13:58:20 <gentauro> does anybody know which `stack path` I need to use?
13:59:05 <doesntcontribute> are there any libraries with functions that return derivatives of functions? This would be useful for calculus
14:02:19 <solonarv> doesntcontribute: I think there is an autodiff library somewhere, is that the sort of thing you're looking for?
14:02:38 <solonarv> can't remember what it's called
14:07:36 <lyxia> the library "ad"
14:08:39 <phadej> it however doesn't return "derivatives of functions", it calculates derivative as you go
14:10:19 <doesntcontribute> phadej: yes this is issue with ad
14:11:56 <doesntcontribute> I would like to be able to compute things like arc-length by being able to plug in (d/dx) straight into a formula.
14:12:12 <phadej> you can it with ad too
14:13:54 <phadej> numerically, it is
14:13:57 <phadej> integration + ad
14:15:19 <doesntcontribute> ok thank you
14:17:54 <maralorn> So: What is actually the difference between people who worry about compile times and people who don‘t? Are the former the ones who actually use Haskell in production?
14:18:19 <maralorn> I read a lot of worrys about e.g. TH, but it hasn‘t bitten me in my projects until know.
14:18:20 <maralorn> until now.
14:21:01 <fendor> is there some nice insight on how to model servant apis for CRUD? In particular, I want to be able to model, that on create, the model must not have an id, and on a GET request, the entity should contain the id
14:21:22 <phadej> fendor: some kind of higher-kinded data approach
14:21:30 <maerwald> maralorn: I worked on a project with 300+ modules in one library component. That makes you care about compile times
14:21:41 <maerwald> And memory
14:21:45 <maerwald> Because ghci -> boom
14:22:11 <fendor> phadej, I had something like `Model Entity`, but then I have to write instances by hand and it does not really work with swagger
14:22:55 <phadej> fendor: There are no free cheese
14:23:25 <fendor> ok :(
14:25:56 <phadej> yet I'm quite sure that if you use tag + type-family approach i.e. data Model tag = M { id :: IdType tag, ... } then you can write instance ToJSON (Model 'CREATE) and instance ToJSON (Model 'READ); and if you write generics for ToJSON yourself, you can actually make it not try to parse `id` field in `'CREATE` case
14:26:06 <frdg> Is the reason I can't do these two things the same?/ Why does this not work?    map (+) [(1,2),(3,4),(5,6)]       map (+) 1 2      
14:26:22 <phadej> but I don't remember seeing anyone putting something like that into a library
14:26:40 <phadej> (I don't write CRUD apps, IMHO it's far from optimal API design)
14:27:05 <solonarv> frdg: it's "the same" in the sense that both of them are type errors, but they're different type errors
14:27:22 <ChaiTRex> frdg: Look at the type of (+).
14:27:22 <maralorn> maerwald: How long did it take to compile everything?
14:27:24 <ChaiTRex> :t (+)
14:27:26 <lambdabot> Num a => a -> a -> a
14:27:42 <ChaiTRex> frdg: It takes two arguments, but you're only providing it one: a tuple.
14:27:50 <maerwald> maralorn: I think with cabal 10 minutes. CI was 30 minutes+ with tests
14:28:04 <maerwald> with -O2 and llvm was 20 minutes just compilation
14:28:29 <fendor> yeah, with type families, it should work. 
14:28:34 <maralorn> Yeah, I see how that would be annoying.
14:28:38 <frdg> I see but in the second example I am giving two arguments
14:28:40 <ChaiTRex> frdg: With uncurry f, you can do things with 2-tuples
14:28:43 <maerwald> 16GB ram wasn't enough
14:28:48 <ChaiTRex> :t uncurry (+)
14:28:48 <maerwald> ghci would blow up often
14:28:49 <lambdabot> Num c => (c, c) -> c
14:29:03 <ChaiTRex> frdg: See how uncurry (+) takes one argument, a tuple.
14:29:22 <ChaiTRex> > map (uncurry (+)) [(1, 2), (3, 4), (5, 6)]
14:29:24 <lambdabot>  [3,7,11]
14:29:26 <frdg> I see
14:29:27 <maerwald> https://hackage.haskell.org/package/http-io-streams-0.1.2.0/docs/Network-Http-Client.html#v:getHeaderMap this function seems to block/hang
14:30:11 <phadej> looks like it takes 45sec to load my current 179 module project; and the residency of GHCi is 4G
14:30:38 <phadej> but we cheat by e.g. disabling pattern matcher in few nasty modules
14:30:47 <phadej> (for GHCi dev)
14:31:02 <frdg> oh now I really see thank you chaiTRex
14:31:21 <ChaiTRex> frdg: For the second you don't have a list and map uses lists.
14:31:24 <ChaiTRex> :t map
14:31:26 <lambdabot> (a -> b) -> [a] -> [b]
14:31:28 <d34df00d> How do I do `bracket` with an intermediate action that lives in MonadIO? So there is a `bracket` from lifted-base, but it's constrained on MonadBaseControl, which I don't know how to combine nicely with MonadIO.
14:32:10 <solonarv> d34df00d: MonadIO isn't powerful enough, that's why MonadBaseControl was created
14:32:19 <ChaiTRex> frdg: One thing to use is zipWith. zipWith (+) [1, 2, 3] [4, 5, 6] will give you [1 + 4, 2 + 5, 3 + 6]. One element from each of the two lists combined with the function you give it.
14:32:21 <solonarv> I'd recommend using unliftio instead, though
14:32:26 <ChaiTRex> :t zipWith (+)
14:32:27 <lambdabot> Num c => [c] -> [c] -> [c]
14:32:39 <ChaiTRex> > zipWith (+) [1, 2, 3] [4, 5, 6]
14:32:42 <lambdabot>  [5,7,9]
14:32:57 <solonarv> MBC has some questionable instances which lead to unintuitive behavior, unliftio has only those instances where it's patently obvious what they do
14:33:37 <frdg> thanks. There are so many ways to deal with lists, tuples,etc its crazy. I can already imagine the power
14:33:37 <ChaiTRex> frdg: If you really don't have lists, just use (+) 1 2, no map.
14:33:54 <ChaiTRex> frdg: No problem.
14:35:13 <d34df00d> solonarv: interesting, thanks! Why is the minimal complete definition for MonadUnliftIO nothing?
14:36:06 <d34df00d> I'm not sure I grokked it enough so that it makes sense to me yet.
14:36:14 <phadej> d34df00d: why you think it's nothing?
14:36:34 <phadej> https://hackage.haskell.org/package/unliftio-core-0.2.0.1/docs/Control-Monad-IO-Unlift.html#t:MonadUnliftIO there is withRunInIO
14:37:05 <d34df00d> The docs say so.
14:37:09 <d34df00d> > Minimal complete definition
14:37:09 <d34df00d> > Nothing
14:37:11 <lambdabot>  error:
14:37:11 <lambdabot>      Data constructor not in scope: Minimal :: t0 -> t1 -> terror: Variable n...
14:37:12 <lambdabot>  Nothing
14:37:44 <phadej> (which is the same liftBaseWith from monad-control, but `StM m a` is always `a`, so it's simpler)
14:37:45 <d34df00d> So it has a default implementation or something, it seems.
14:38:12 <MarcelineVQ> d34df00d: what page are you looking at?
14:38:18 <phadej> I don't see "minimal complete definition" on that haddock page
14:38:41 <d34df00d> https://hackage.haskell.org/package/unliftio-core-0.2.0.0/docs/Control-Monad-IO-Unlift.html#t:MonadUnliftIO
14:39:02 <d34df00d> Huh, that's the difference between 0.2.0.0 and 0.2.0.1.
14:39:03 <d34df00d> Interesting.
14:39:44 <phadej> https://hackage.haskell.org/package/unliftio-core-0.2.0.1/changelog
14:39:50 <phadej> easy answer
14:40:09 <d34df00d> Yeah, just noticed that, sorry!
14:40:22 <d34df00d> I sort of neglected the last component of the version.
14:41:25 <d34df00d> On a more high-level question, suppose we're also interested in the ProgramT transfomer from the operational package: https://hackage.haskell.org/package/operational-0.2.3.5/docs/Control-Monad-Operational.html
14:41:41 <d34df00d> Where should the instance for MonadUnliftIO go, if it's lawful for this one?
14:41:52 <d34df00d> In the operational package or in the unliftio package family?
14:41:54 <phadej> there aren't in cannot be.
14:41:58 <phadej> and cannot be
14:42:06 <d34df00d> Oh.
14:42:14 <d34df00d> Why can't it?
14:42:50 <phadej> short answer: MonadUnliftIO can be only given to monads isomorphic to ReaderT r IO 
14:42:58 <phadej> ProgramT is potentially more powerful
14:43:25 <phadej> (as what program means is given by interpreters)
14:43:50 <d34df00d> I think I've seen a mention of that in the MonadUnliftIO docs. I'll read those more and ask more questions if something's not clear.
14:44:02 <d34df00d> Well, I guess I have an X-Y problem then.
14:44:23 <phadej> bracket for ProgramT is also kind of problematic
14:44:32 <phadej> ... idea to begin with
14:45:07 <phadej> https://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf is something you could read
14:45:12 <d34df00d> Well, it was working (I guess) for ProgramT MyStuff IO
14:45:21 <phadej> Algebraic effect handlers are a powerful means for describing
14:45:21 <phadej> effectful computations. They provide a lightweight and orthogonal
14:45:21 <phadej> technique to define and compose the syntax and semantics of
14:45:23 <phadej> different effects.
14:45:35 <phadej> Unfortunately, the approach does not support syntax for scoping
14:45:35 <phadej> constructs, which arise in a number of scenarios. W
14:45:54 <phadej> if it was working, then by accident
14:46:19 <d34df00d> phadej: looks quite relevant here, thanks!
14:47:13 <phadej> I'm not sure if lexi-lambda's work on eff solves similar problems, but in general; bracket + free monads is "you are most likely doing something too complicated"
14:47:44 <d34df00d> Re my original problem, so I'm trying to capture communication with `idris --ide-mode` in an operational monad, say, with just two operations like sendTypecheckQuery and readReply (so right now I have `type IdrisClientT m = ProgramT IdrisAction m`).
14:48:36 <d34df00d> And right now I have `withIdris :: IdrisClientT IO r -> IO r ` that does the obvious thing (firing up an instance of Idris, interpreting the program and returning the result, and here I need `bracket`).
14:48:56 <frdg> what does uncurry do in this function? map (uncurry (+)) [(1,2),(3,4),(5,6)] 
14:49:12 <phadej> d34df00d: you need bracket in `IO` not `IdrisClientT`, don't you?
14:49:42 <d34df00d> So suppose I'd like to throw up some tests with, say, hspec. Ideally I'd like to do withIdris just once for the whole test set (since starting up Idris is slow), so I'd like to do `spec :: Spec; spec = withIdris $ do all the hspec stuff`.
14:49:46 <d34df00d> And here it breaks.
14:50:13 <d34df00d> phadej: yeah, and right now Control.Exception.bracket works just fine. But it doesn't allow me to express the above idea, cause Spec isn't seemingly IO.
14:50:36 <d34df00d> Although I can do `spec = describe "blah" $ it "works" $ withIdris myProgram`
14:51:18 <d34df00d> But that requires `withIdris` per `it`, which is something I'd like to avoid.
14:53:03 <ski> frdg : turn from `(+) :: Integer -> Integer -> Integer' to `uncurry (+) :: (Integer,Integer) -> Integer', so that it can be applied on the pairs in the list (this is assuming `Integer', it could also be some other numeric type)
14:53:19 <phadej> `describe` returns `SpecM a ()` , you you'd turn that into `IdrisClientT IO` to begin with.
14:54:10 <phadej> I'm not familiar with hspec, so cannot help. Tasty has https://hackage.haskell.org/package/tasty-1.2.3/docs/Test-Tasty.html#v:withResource
14:54:20 <ski> frdg : if you instead had separate lists, `[1,3,6]' and `[2,4,6]', you could use `zipWith' (with no `uncurry'), instead of first using `zip', and then `map' with `uncurry', as above
14:54:23 * hackage dobutokO2 0.6.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.6.1.0 (OleksandrZhabenko)
14:54:49 <phadej> which allows you to share resources (which would require spliting withIdris into `startIdris` and `stopIdris`)
14:55:08 <phadej> I'm quite sure hspec have some similar construct, as it's common in testing
14:55:21 <d34df00d> phadej: withIdris is largely a call to `bracket` anyway (plus reading out the initial message about the version protocol, but that's irrelevant).
14:55:29 <d34df00d> But yeah, that sounds like what I need!
14:55:44 <d34df00d> Anyway, now I'm just curious — suppose there's no withResource. How would you solve this?
14:56:01 <phadej> by adding withResource :)
14:56:21 <phadej> tasty/hspec is in control of execution of test-suite, so it manages resources as well
14:56:43 <d34df00d> That's a good point!
14:56:57 <frdg> ski: I think the terminology of uncurry is what is confusing me. So when we curry we make and argument like Int -> Int -> Int...into a function that takes and Int and returns a functions that takes an Int. I am having trouble putting the backwards version of this into english
14:57:02 <phadej> (which is relevant when you filter which tests you run, maybe you don't neend to reserver resource at all)
14:57:27 <d34df00d> I'm probably trying to overcomplicate things though (although it's always good for recreational programming).
14:57:51 <merijn> frdg: honestly, the terminology of "curry" vs "uncurry" is, essentially irrelevant to writing haskell
14:57:56 <MarcelineVQ> curry is (a, b) -> c  becoming a -> (b -> c)   uncurry is the opposite.   Int -> Int -> Int is already curried
14:58:13 <merijn> frdg: In fact, I think most beginner resource that even talk about currying are wasting the reader's time
14:59:28 <frdg> merijn: so what your saying is I should think of Int -> Int -> Int as a function that takes two Ints and returns an Int but I still don't know how I should think of Uncrry
14:59:44 <merijn> frdg: No
14:59:57 <merijn> frdg: "Int -> Int -> Int" = "Int -> (Int -> Int)"
15:00:11 <merijn> frdg: It takes an Int and returns a function of type "Int -> Int"
15:00:20 <merijn> currying/uncurrying is all irrelevant to this
15:10:25 <koz_> :t foldl
15:10:28 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:11:11 <int-e> Basically the only context where currying really comes up is "I have this two argument function and a pair that contains the arguments; how do I apply the function to the pair?" when the answer is the *un*curry function.
15:11:24 <int-e> Partial application is much more useful to talk about.
15:12:01 <int-e> > uncurry (+) (23, 19)
15:12:03 <lambdabot>  42
15:12:41 <frdg> merijn: You said that currying is not important but to me it seems like you can do very useful things with it. Is the reason why you advised me to stay away from them for while because you can unadvisable things with them if you don't have proper understanding?
15:12:42 <int-e> (I have no recent memory of using "curry" at all.)
15:12:44 <ski> occasionally, the reverse happens, int-e
15:13:27 <ski> frdg : note that Haskell doesn't "have currying" or "have curried functions". currying is something that's in your mind
15:13:29 <int-e> frdg: It just doesn't come up very much in real world Haskell code because we hardly ever pack arguments into tuples in the first place.
15:13:49 <merijn> frdg: No, my point is that currying is mostly a technical term for when you are talking about things across languages and (when we're limiting ourselves to Haskell) talking about it is useless and confuses beginners by making them think about the wrong things and look for some deeper meaning
15:14:06 <int-e> ski: Sure I imagine it must be happening. I'm just lacking the actual experience of doing that :P
15:14:24 <frdg> ok cool
15:14:30 <merijn> frdg: It's much more useful to just skip all that nonsense and comparison with other languages and go straight to the fundamental truth: All Haskell functions take only one argument.
15:14:57 <merijn> frdg: Sometimes those functions return another function and it is, for sloppy human communiation, sometimes convenient to pretend they take multiple
15:15:13 <ski> frdg : "curried style" is about (one way of) representing multiple-arguments functions (which Haskell does not have) in a language which only has single-argument-functions. the other way to represent might be called "tupled style"
15:15:33 <merijn> frdg: i.e. I might say a function "Int -> Int -> Int" "takes two arguments" and everyone will understand what I mean
15:15:50 <ski> frdg : "currying" means converting to the "curried style" (from "tupled style", in the case of Haskell). "uncurrying", is converting in the opposite direction
15:16:22 <merijn> frdg: But if we get down to the nitty-gritty details "Int -> Int -> Int" *is* "Int -> (Int -> Int)" (that is, a function taking one argument and returning a function which takes one argument to produce an Int
15:16:47 <frdg> geez my mind is getting opened up. Ive been thinking about it all wrong. 
15:16:48 <merijn> frdg: This way of thinking is useful, because it also immediately solves the issue of "What is partial application" (another lie)
15:17:22 <ski> int-e : imagine something like `foo :: (Int,Int) -> ...' (taking coordinate pairs as input, perhaps), and then wanting to partially apply on one coordinate
15:17:23 <merijn> frdg: It can be useful to talk about a function as if it has 3 arguments, and then we can call it partial application when I give it 1 or 2.
15:18:00 <merijn> frdg: But once you see the light of "every function takes only one argument" then the whole idea of "partial application" becomes trivial, since you are just calling single argument functions anyway
15:18:10 <int-e> ski: interestingly I'd probably write an explicit lambda for that.
15:18:11 <ski> int-e : but since the convention is to use "curried style", by default, unless there's a specific reason to use tupled style (one can combine both), one doesn't see this case as often, in Haskell
15:18:39 <ski> sometimes i write  foo `curry` blah
15:18:43 <int-e> ski: But yes, that's a case that could easily come up, so thanks for that.
15:19:12 <int-e> ski: And we certainly agree on this not being very common. :)
15:19:24 * ski nods and smiles
15:21:18 <ski> frdg : yea, in fact, i'd call it "partial application", to supply (any) some arguments to a multiple-argument function (whether represented in curried or tupled style, or a mixture of both). however, only when its a "prefix" do you get the very simple expression of it in Haskell (which is probably the main reason why curried style is normally preferred)
15:21:33 <int-e> One important factor here is that despite the curried style, the ghc runtime can actually apply a function to multiple arguments at once, so it doesn't carry a performance cost (which could otherwise drive people towards a tuple based style).
15:21:51 <ski> (and also, why people tend to order parameters so that least-likely-to-change comes first, to encourage such partial application)
15:22:33 <frdg> thanks guys I feel like I just had a major breakthrough 
15:22:58 <merijn> frdg: Good, that's one of the biggest/most fundamental ones ;)
15:27:02 <d34df00d> merijn: oh hey. Mind taking a brief look at the timeit PR?
15:28:46 <merijn> d34df00d: oh, apparently I don't get notified of PRs...that's odd
15:29:19 <merijn> d34df00d: I'll have a look tomorrow
15:32:53 <d34df00d> Thanks!
15:32:57 <d34df00d> I probably should've @mentioned you :)
15:33:19 <merijn> d34df00d: Apparently github defaulted to not watching, so I've changed that for the future
15:43:03 <maerwald> sm[m]: lol, I hit the same dilemma with MonadFail like you yesterday
15:43:21 <maerwald> https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html#v:parseTimeM
15:43:39 <maerwald> if I turn it into Maybe, I lose the message 
15:43:46 <d34df00d> Derp, tasty's withResource is so much more obvious than hspec's before/after/around. I should probably migrate to tasty at this point.
15:44:09 <maerwald> What an annoying class
15:44:29 <merijn> d34df00d: I find hspec's pseudo-english DSL rather inconvenient and confusing compared to tasty, yeah
15:44:54 <merijn> maerwald: The class is fine, I like being able to infer partial patterns in do blocks, but using it for error reporting like that is broken
15:45:08 <maerwald> Yeah, they should use MonadThrow for that kind of API
15:45:43 <merijn> Basically, manually calling "fail" should just not be allowed >.>
15:46:07 <maerwald> However, I'm guilty using it as a shortcut in IO for userError
15:47:17 <fog> ski: re: running/evaluating effects vs execution;
15:47:27 <fog> and "running a function"
15:47:53 <fog> since everything is basically the dereferencing of bound variables, rewritten using equational reasoning
15:48:28 <fog> with the exception of the IO monad, where "effects" seem to make sense, like, they "change the world"
15:48:48 <d34df00d> merijn: dunno, it works nicely for me for most of my tests (which are pretty basic — the most complicated ones are just quickcheck properties), but here I need to do some resource initialization/freeing per the whole test tree, not per test item.
15:48:49 <fog> then everything that is called evaluation is basically just rewriting
15:48:55 <d34df00d> And it turns out to be... nontrivial, it seems.
15:49:22 <fog> also, we have "rewrite rules" for this
15:49:49 <fog> so even, some terms instead of just being expanded during this dereferencing/expansion of terms into their definitions
15:50:03 <fog> can be canceled aswell
15:51:12 <maerwald> fog: fantastic. But can we not "rewrite" the world too?
15:51:32 <maerwald> *philosophical staring intensifies*
15:58:37 <infinity0> what's the status of getting base 4.13 into hackage and can anyone help
16:02:18 <d34df00d> Yeah.
16:02:21 <d34df00d> Strict foldMap when.
16:02:40 <jle`> delayed due to coronavirus
16:03:08 <jle`> sorry, that was a lie. don't want to spread misinformation
16:03:15 <jle`> but afaik it's mostly just a lot of work to be put into the updates
16:03:20 <jle`> upgrading hackage
16:03:45 <jle`> i think pretty much hackage itself has to be upgraded before we can put base docs 4.13 up there
16:03:54 <jle`> i've asked this question a few times in #ghc
16:05:55 <lyxia> https://gitlab.haskell.org/ghc/ghc/issues/17246  and there is a version of haddocks for the core libraries at https://downloads.haskell.org/~ghc/8.8.1/docs/html/libraries/index.html
16:33:22 <lexi-lambda> phadej, d34df00d: The Effect Handlers in Scope paper is indeed the citation most relevant in Haskell-land these days. It’s basically what fused-effects/polysemy do. It has some problems, though, and I don’t personally love it. It’s likely fine if you’re not doing anything very fancy, though.
16:34:06 <lexi-lambda> A more complete treatment of the problems involved when combining resources and effects is given in Algebraic Effect Handlers with Resources and Deep Finalization by Daan Leijen, but it isn’t Haskell. https://www.microsoft.com/en-us/research/publication/algebraic-effect-handlers-resources-deep-finalization/
16:35:00 <lexi-lambda> In eff I intend to implement something a little closer to that, but eff has some implementation advantages because it can cooperate more directly with IO exceptions.
16:39:44 <lexi-lambda> d34df00d: If you’re in mtl-land, and you need to use bracket, you should use MonadMask from the exceptions package. It will handle subtleties that MonadBaseControl will not (like short-circuiting exits using ExceptT rather than an IO exception).
16:41:51 <lexi-lambda> You have to be extremely careful when using MonadBaseControl, as it has a lot of gotchas. Using MonadBaseControl to lift bracket is probably wrong. It’s okay for some other things, but reliable deallocation is absolutely not one of them.
16:42:37 <lexi-lambda> MonadMask will handle all those complications properly (assuming you’re using MonadMask instances that are written correctly).
16:43:40 <suzu> oh hey its lexi-lambda !
16:43:42 <suzu> thank you for eff
16:44:07 <lexi-lambda> Thank me when it’s actually usable. :)
16:44:21 <suzu> it was looking pretty good until the custom RTS stuff
16:44:36 <suzu> maybe that can be added to GHC proper at some point?
16:44:45 <suzu> competing Haskell compilers plz
16:44:51 <lexi-lambda> I have an ongoing GHC proposal: https://github.com/ghc-proposals/ghc-proposals/pull/313
16:44:51 <suzu> haskell 2020 reports plz
16:46:11 <lexi-lambda> The implementation without the primops had some subtle bugs that took a while to understand, and I realized while rewriting it that it wouldn’t be as fast as it ought to be anyway unless I patched GHC. (And that limitation applies to all effect systems—even mtl—not just my approach.)
16:46:29 <lexi-lambda> The proposal explains the limitation.
18:01:55 <koz_> lexi-lambda: Hi! Thanks for the explanation you gave me the other day regarding monads and laziness.
18:02:05 <koz_> (a bit slowpoke I know)
18:04:09 <lexi-lambda> koz_: To be honest, I only vaguely remember having that conversation
18:05:11 <koz_> lexi-lambda: Lol, clearly I'm super-not-memorable.
18:05:25 <koz_> (it was via Twitter DM, probably about two months ago)
18:06:20 <lexi-lambda> Ah! That jogs my memory a bit
18:08:07 <koz_> It actually turned out to be very useful to my understanding of a bunch of things, and would ahve gone into a talk I was going to give (if not for COVID-19 shenanigans).
18:22:13 <frdg> what book would you recommend for learning haskell?
18:28:49 <evelyn> koz_: you can continue learning Haskell while isolating!
18:29:23 <koz_> evelyn: I work from home, so this is 100% a non-issue.
18:29:34 <koz_> (writing Haskell in fact)
18:35:07 <dogcat1> has anyone tried to build ghc on a MacOS today? I'm running into an error with a header file not being found, and figured a might as well cross-post here...
18:35:18 <suzu> why build when you can download the bin
18:35:34 <koz_> suzu: I lolled at the phrasing.
18:35:50 <koz_> 'Why bother constructing anything when trash bins are available online?'.
18:36:23 <dogcat1> yea, we should just stop developing on ghc because the bins are available. I never thought about it, but this will save me a ton of time not having to learn ghc internals!
18:36:55 <koz_> dogcat1: I rofl'd.
18:37:17 <dogcat1> haha, i def laughed when I typed it :)
18:37:27 <koz_> The sarcasm was strong in that one.
18:37:38 <mjrosenb> better yet, we can just throw the computers in the bins, and go outside!
18:37:59 <koz_> mjrosenb: Outside is overrated.
18:38:02 <koz_> Especially in Australia.
18:38:45 <MarcelineVQ> that's where all the things that eat you live
18:38:58 <koz_> Australia is where every JRPG is set.
18:39:16 <d34df00d> Alright, I figured I don't understand the intricacies of MonadCatch/MonadMask/MonadBaseControl/etc. What'd be a good starting point to learn about those?
18:39:17 <mjrosenb> I am still confused about why anyone would go to that place voluntarily.
18:39:36 <MarcelineVQ> well, at first...
18:39:51 <koz_> d34df00d: For MonadBaseControl, I recommend reading Alexis' work here: https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/
18:40:06 <koz_> For the rest, I think Simon's book on parallel and concurrent Haskell covers it quite well.
18:40:11 <koz_> mjrosenb: Ask Axman6 
18:40:24 <koz_> (hint: this is why he has axes for hands)
18:40:40 <MarcelineVQ> and 6 hands
18:40:50 <mjrosenb> as for more haskell related work, I have a rather large structure, data Foo = Foo { a :: A, b :: B, ... z :: Z}
18:41:11 <ddellacosta> d34df00d: for MonadBaseControl at least, I found this post helpful: https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/
18:41:16 <d34df00d> Hmm, I've read Simon's book a couple of years ago, but apparently the details related to this specific stuff were garbage collected.
18:41:22 <d34df00d> Thanks for the link!
18:41:37 <koz_> d34df00d: No worries - I recently re-read those sections and foudn them very helpful.
18:41:43 <ddellacosta> oh whoops sorry I missed your comment koz_ 
18:41:51 <koz_> ddellacosta: Which comment?
18:41:57 <ddellacosta> guess that's just emphasizing how useful that post is :-D
18:42:02 <MarcelineVQ> the one with the dimples
18:42:12 <ddellacosta> oh I just posted the same link you did, didn't see your comment above
18:42:13 <koz_> MarcelineVQ: My posts lack dimples.
18:42:20 <MarcelineVQ> dimple then
18:42:26 <lexi-lambda> d34df00d: My blog post that two people have now linked you is, indeed, what I would recommend reading to understand MonadBaseControl. :) But understanding it isn’t even really necessary to understand why MonadMask is important.
18:42:30 <mjrosenb> and I just realized that I actually want each field to be parameterized, so Foo { a :: A a', b :: B b', ... z :: Z z' }. Is there a more sane way to do this than to have Foo have 26 type parameters?
18:42:34 <koz_> ddellacosta: Ah, lol.
18:42:44 <koz_> lexi-lambda: It's a good post!
18:42:50 <ddellacosta> ^
18:42:50 <d34df00d> Yeah, time for a refresher, now that everything I try to do around a little operational monad of mine somehow converges to it needing to satisfy MBC/MonadMask.
18:43:04 <koz_> mjrosenb: What on earth are you trying to do?
18:43:08 <d34df00d> mjrosenb: trees that grow!
18:43:21 <d34df00d> mjrosenb: https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf
18:43:34 <d34df00d> I feel like that's what you'll come to eventually.
18:43:39 <lexi-lambda> d34df00d: MonadBaseControl allows you to lift operations in the base monad (usually IO) that you can’t lift with liftIO. It has some gotchas wrt state discarding, and that blog post will explain the details. But in the case of bracket, those gotchas aren’t actually the point.
18:44:21 <d34df00d> lexi-lambda: cool, glad you're here! I'll know whom to ask shall I have questions on that post :)
18:45:05 <lexi-lambda> d34df00d: The problem with lifting Control.Exception.bracket is that Control.Exception.bracket deals with IO exceptions, since IO exceptions are the only way to have an early exit from an IO computation. But if you have `ExceptT e IO`, now there are two ways to have an early exit.
18:45:45 <Cale> If you can get away with it, I usually recommend sidestepping MonadBaseControl altogether, and either inventing your own operation-specific class for whatever higher-order operation you're interested in, using a pre-existing one, or if you don't need the polymorphism, just running the monads by hand.
18:46:10 <lexi-lambda> MonadBaseControl, by its very nature, treats all transformers identically. But in the case of bracket and related operations, you really need to worry about each transformer’s behavior on a case-by-case basis. This is what MonadMask does.
18:46:17 <Cale> yeah
18:47:14 <lexi-lambda> MonadMask instances define the meaning of bracket and related operations for each transformer individually. So `MonadMask (ExceptT e)` handles early exits from ExceptT, `MonadMask LogicT` handles early exits from LogicT, etc.
18:47:28 <Cale> That is exactly the reason I recommend it, because it helps you discover when you're about to do something dumb, while MonadBaseControl will just go ahead and make some arbitrary choices for you
18:48:07 <Cale> (and also I think the code is easier to understand in the end anyway)
18:48:21 <d34df00d> TFW writing some stupid tests for my project completely gets me completely derailed for a third day now.
18:49:04 <lexi-lambda> eff takes a totally different approach that recasts all operations in terms of delimited control, so the meaning of entry/exit into a region can be precisely defined. But monad transformers can’t really do that.
18:49:40 <mjrosenb> koz_: I have some program state, but I've come to realize that I actually want the types to change as it moves through various phases of execution, certain fields changing from Bar to Maybe Bar, etc.
18:51:36 <lexi-lambda> d34df00d: By the way, the fact that MonadMask has MonadCatch as a superclass is a red herring. IMO the superclass shouldn’t exist. The functionality they provide is morally orthogonal, and MonadMask could have nothing but mask, uninterruptibleMask, and onError as its only methods and define everything else in terms of that.
18:51:53 <lexi-lambda> But I doubt the design is worth changing now.
18:52:16 <Cale> It probably wouldn't hurt that badly to remove the superclass constraint
18:52:40 <Cale> There would be a handful of places where code would need updating, but certainly not as bad even as the changes to Num that happened
18:52:57 <dogcat1> Often times what I'm looking for, is just the unlift, where I have some inner function like (Conn -> IO a), and I need to run a monad action inside of them, which is why MonadUnliftIO is so nice
18:53:11 <Cale> dogcat1: It's misleadingly nice though
18:53:53 <dogcat1> yea...the last time I ran into that problem at work, we couldn't go with MonadUnliftIO because we had ExceptT in our transformer :)
18:54:23 <dogcat1> alas, we won't run our monadic logger in that contravariant IO function
18:55:23 <mjrosenb> Cale: which changes to Num?
18:55:40 <Cale> superclass constraints being removed
18:56:21 <Cale> (they were good changes)
18:56:24 <int-e> What were they, Show and Eq?
18:56:29 <lexi-lambda> I don’t like MonadUnliftIO, but I’ve already argued why in the blog post that has been linked. :)
18:56:43 <dogcat1> :) scrolling up
18:57:27 <int-e> Aww I broke my ghc-7.6.3 *sniff*
18:57:28 <Cale> int-e: yeah
18:59:09 <int-e> (because of a hard-coded path for gcc: ghc: could not execute: /usr/bin/gcc-5)
19:00:08 <Cale> dogcat1: The most responsible thing to do is usually just to invent your own class for the higher-order operation that you're working with, so that you get to explain how each monad transformer deals with it, and give yourself a chance to think about whether that makes sense.
19:01:53 <Cale> It also leaves the code looking prettier in the end, since your operation just works in whatever monads are relevant to you, without needing explicit fancy lifting machinery
19:02:15 <dogcat1> Cale: that's the only reasonable solution I've seen to my problem of running a monadic logger in an (Conn -> IO a) funtion. 
19:03:03 <Cale> I also feel funny about logging libraries which are monad transformers for not much good reason :)
19:03:24 <dogcat1> However, it leaves me somewhat unsatisfied that we lack a clear and concise unlfit operation. Maybe it's not possible, given the underlying semantics of the transformers, but I am just not sure 
19:03:30 <lexi-lambda> Cale: The troubling thing is that isn’t always good enough. ListT from the list-t package actually has a broken MonadError instance, and although it could be slightly improved, in general it isn’t possible to write it correctly. But AFAICT I am the first person to discover this, so it can be extremely non-obvious.
19:03:32 <lexi-lambda> And the most frustrating thing is that there *is* a semantics that makes sense, you just can’t implement it with MonadError.
19:04:06 <Cale> lexi-lambda: Is that just because there are pre-existing instances which do the wrong thing?
19:04:26 <lexi-lambda> Cale: No, you can’t write a correct MonadError instance for ListT.
19:04:50 <lexi-lambda> This is what made me abandon my original transformer-based approach for eff and switch everything to delimited continuations. The problem is hopeless.
19:04:59 <Cale> Also, I'm not certain if I fully know what a correct MonadError instance would look like :)
19:05:09 <Cale> It's not like that class has laws...
19:05:16 <lexi-lambda> Yeah, I gave it some. :)
19:05:39 <lexi-lambda> And then I found you can’t define an instance for ListT that satisfies the laws.
19:06:25 <lexi-lambda> I have a couple of very small test cases that no existing implementation in Haskell passes except for eff. That includes transformers/mtl/fused-effects/polysemy.
19:06:51 <Cale> Hmm, I wonder how it compares with the ListT from pipes
19:07:19 <lexi-lambda> pipes won’t be any better; the problem is unfortunately fundamental.
19:07:32 <Cale> Well, what is the problem?
19:08:15 <lexi-lambda> :info ListT
19:08:24 <lexi-lambda> alas
19:09:04 <Cale> instance (MonadError e m) => MonadError e (ListT m) where
19:09:04 <Cale>     throwError e = lift (throwError e)
19:09:04 <Cale>     {-# INLINE throwError #-}
19:09:04 <Cale>     catchError l k = Select (catchError (enumerate l) (\e -> enumerate (k e)))
19:09:04 <Cale>     {-# INLINE catchError #-}
19:09:33 <Cale> The instance for pipes looks about as straightforward as one could make an instance.
19:09:51 <Cale> Of course, it might not have the semantics you want, but that looks like a not-entirely-unreasonable semantics
19:10:27 <lexi-lambda> Yeah, let me fire up a local REPL and try it out.
19:10:45 <Cale> (If there is any error when enumerating the original ListT, we abort it entirely, and take the handler's one.)
19:12:07 <lexi-lambda> Cale: The issue is an interaction between <|> and catch.
19:12:21 <lexi-lambda> (Give me a moment, I’m compiling pipes.)
19:12:41 <Cale> Yeah, it's not going to split over <|> with this definition
19:12:49 <Cale> (but that makes sense)
19:13:30 <lexi-lambda> I believe I have a compelling argument that the instance is not just surprising, but incorrect (for any reasonable MonadError laws).
19:13:33 <d34df00d> Crap, I'm an idiot.
19:13:51 <d34df00d> I need none of this MonadMask stuff in my operational monad interpreter cause it's already interpreted to the base monad by then.
19:14:15 <d34df00d> Which I can surely require to be a MonadMask and MonadWhatever in general.
19:14:37 <suzu> koz_: ;)
19:14:39 <d34df00d> But it's still a blind spot in my knowledge that's definitely worth filling in.
19:16:49 <Cale> There are all these effect systems which are kind of cool, but I really wish that someone would make something with the express goal of beating mtl's performance with all the optimisations turned on, specifically for things built out of (modular) reader and state components, and if you can do other stuff, that'd be good, but start with those.
19:17:55 <lexi-lambda> Cale: eff does match or exceed mtl performance for Reader/State if the mtl code is not specialized (and it usually isn’t specialized in real programs).
19:17:59 <Cale> If I ultimately have nothing but a bunch of readers and states over IO, it would be nice if somehow that compiled down to accesses to a single mutable array of pointers
19:18:18 <lexi-lambda> Using Reader/State in eff is basically free.
19:18:26 <Cale> Yeah, but we already force -fexpose-all-unfoldings on for the entire universe
19:18:41 <lexi-lambda> Do you also use -fspecialise-aggressively?
19:18:50 <Cale> I believe so.
19:19:17 <Cale> I'd have to look at our nix code to be sure. There was some combination of flags which is pretty much necessary for our shit to work fast
19:19:35 <lexi-lambda> Then you’re probably getting the fastest possible performance, yes. But I’d bet eff would basically have the same performance in virtually all situations, unless you’re relying on the StateT state being unboxed or something like that.
19:19:38 <Cale> and we just baked it into the nix at a low level so it's obnoxious for anyone to turn off :P
19:20:13 <lexi-lambda> `ask` in eff is a couple pointer dereferences.
19:21:19 <lexi-lambda> `get` is one extra pointer dereference (it looks up a value in an IORef). Sadly, `put` has to allocate one constructor. I’d like to fix that, but it’s hard and probably not worth it.
19:22:25 <lexi-lambda> (Probably not worth it because you’re almost allocating at least once if you call `put`, anyway.)
19:23:12 <lexi-lambda> mtl can beat eff on those workloads if you rely on unboxing of the state and modify it in a tight loop, but very few programs outside of microbenchmarks do that.
19:24:32 <lexi-lambda> eff is also technically a little bit slower if you call runState a lot, as installing an effect handler has a tiny cost, while in transformers installing an effect handler is free.
19:24:58 <lexi-lambda> But if you call runState outside of your tight loop and just call get/put in your loop you aren’t really losing anything.
19:26:08 <Cale> I kind of think it would be nice if I could have stuff that compiles to manipulating a static memory location (or nearly so)
19:26:28 <Cale> Of course, that doesn't work with nondeterminism
19:26:44 <Cale> But there are a lot of cases where you just don't care about that
19:27:23 <dogcat1> Isn't that how thunk evaluation works? You evaluate a closure into a result, then hit the same memory when you need it again
19:28:01 <Cale> dogcat1: Well, you execute the code for the thunk and it rewrites the code pointer to point at a shorter piece of code which returns the result immediately next time
19:29:28 <lexi-lambda> Cale: The problem is that everything is boxed, so you aren’t really saving anything. You have to store the address to the memory location, anyway.
19:29:48 <Cale> hmm, maybe
19:29:52 <lexi-lambda> Also, how do you actually get the results of a ListT computation with pipes?
19:30:09 <lexi-lambda> runListT always returns `m ()`.
19:30:54 <Cale> enumerate will give you a Producer
19:31:21 <lexi-lambda> Ah, I see, thanks.
19:31:53 <lexi-lambda> Cale: eff uses an IORef to implement State, but it only does that because it passes all the current cells of state in a single pointer to a vector of pointers. It’s saving on copying the vector, basically, but it doesn’t really save anything over state passing if you only have one cell of state.
19:33:04 <lexi-lambda> Fundamentally your value is going to be a pointer, so you either pass the pointer to the value around or you pass the pointer to the “static memory location” around. The latter doesn’t save you anything, and you add a useless level of indirection.
19:33:48 <lexi-lambda> If your value is unboxed, you still save nothing, as then you might as well pass the unboxed value around directly, in registers (if there’s space).
19:34:43 <Cale> Well, if the static memory location is actually static, perhaps all the references to it are compiled to immediate mode accesses, and you lose that bit of indirection
19:34:46 <lexi-lambda> If you really, really mean “static memory location” as in “allocated at compile time,” you’re assuming the function isn’t re-entrant, which is a very bold assumption to make! Even C++ compilers won’t do that!
19:35:10 <lexi-lambda> Of course, you can always explicitly write `static` to tell the compiler to trust you.
19:35:40 <lexi-lambda> But if you care about that one pointer, maybe you shouldn’t be writing Haskell. :p
19:35:49 <Cale> Yeah, what I'm asking for is *slightly* unreasonable :)
19:35:55 <dogcat1> or use haskell to write a compiler :)
19:37:08 <Cale> There are a lot of cases where you have an application which runs a particular monad exactly once, and it's comprised of a bunch of readers and states, and it really could amount to just a static bunch of offsets.
19:38:33 <lexi-lambda> I think what you really want in that case is MutableData, so you can have a mutable record of all your states and just pass around a pointer to your record. That’s what essentially every C/C++/Rust program would do, and it’s what the RTS does for TSOs.
19:39:23 <MarcelineVQ> you beans seen https://mutable.jle.im/ ?
19:39:38 <Cale> I have not
19:39:49 <lexi-lambda> Now, admittedly, figuring out how to optimize a bunch of Reader/State effects into a single big record would be a much larger request! Not impossible, but you’d need a clever approach (and a custom core-to-core plugin).
19:40:25 <lexi-lambda> MarcelineVQ: It’s a nice interface but ultimately doesn’t do anything you couldn’t already do, which is to say from a performance POV you still have to pay the pointer chasing tax.
19:40:42 <dogcat1> Even that might not only work for a little while, the internals are definitely a moving target
19:40:56 <MarcelineVQ> it's like that mathew broderick movie where the computer makes that quote
19:41:08 <MarcelineVQ> "go go gadget shoes"
19:41:36 <Cale> Maybe the key is that if you have a *Reader* for an IORef, you know at least that the IORef isn't going to change during the execution of that entire Reader action. So, if the Reader only gets run once, you don't actually need to pass references to it around, you have an extraneous parameterisation, effectively.
19:42:39 <Cale> If the compiler could look out for that kind of thing and opt to compile Readers into static accesses when they're only ever run once, that might do it
19:43:00 <lexi-lambda> The problem is that a “run-once analysis” is fundamentally a whole-program analysis.
19:43:17 <lexi-lambda> Or at least an analysis from the point of the runReader call to the top of the program.
19:43:43 <Cale> Yeah, that's often going to be okay, because the runReader is already pretty close to the top of the program ;)
19:44:29 <Cale> You do some initialisation, and then the runReader happens, and the entire rest of the program happens inside it, for instance.
19:44:44 <Cale> That kind of thing is fairly common
19:45:44 <Cale> But there might be multiple transformers which are defined as newtypes of ReaderT that we want that same optimisation to apply to
19:46:24 <MarcelineVQ> {-# LANG ReaderLike #-}
19:46:30 <lexi-lambda> Okay, sure, but it’s an extremely specific optimization.
19:46:42 <lexi-lambda> That probably won’t save you all that much in practice.
19:46:49 <Cale> mmmm... maybe
19:47:58 <Cale> It might be that after all this -fexpose-all-unfoldings and aggressive specialisation, the resulting code is good enough that we're not going to squeeze too much more blood from that stone.
19:48:08 <dogcat1> the solution would be to integrate something like GRIN into ghc, and allow for a whole class of whole program optimizations
19:48:13 <Cale> But a lot of blood has been squeezed in the past
19:48:46 <Cale> It's easy to underestimate the effects of things that influence the cost of every line of code in the entire program
19:50:33 <Cale> (also, we kind of already are doing some nearly whole-program-ish stuff via this expose-all-unfoldings shenanigans)
19:51:07 <lexi-lambda> Yeah, but that’s just monomorphizing everything and running the normal optimization pipeline on the result.
19:51:13 <Cale> right
19:51:37 <Cale> Inline it all and let the simplifier sort it out
19:52:05 <lexi-lambda> Anyway, I finally bothered to test ListT from pipes. Its instance is less broken than the one from list-t, but still broken, which is what I expected. (The list-t instance could be improved to have the pipes behavior.)
19:53:24 <lexi-lambda> This demonstrates the problem. https://www.irccloud.com/pastebin/32U7iZrI/
19:54:13 <lexi-lambda> The thing that’s so surprising about this is that the output of the program is Right, which indicates the exception was caught, but the second branch of <|> just gets swallowed.
19:54:38 <lexi-lambda> I would not want to have to debug this problem in my code.
19:57:05 <lexi-lambda> I think this behavior is wrong even if you assume MonadError is lawless, fwiw. My argument is that <|> on ListT is supposed to be an algebraic operation, but this program violates the algebraicity property that the continuation distributes over <|>.
19:57:55 <lexi-lambda> If the algebraicity property were to hold, then this program would have to be equivalent to `m = (throwError "bang" `catchError` \_ -> pure 1) <|> (pure 2 `catchError` \_ -> pure 1)`, but it is not.
19:58:50 <lexi-lambda> So this MonadError instance is inconsistent with the meaning of <|>.
20:00:46 <lexi-lambda> Alas, it is not difficult to prove that a correct MonadError instance is impossible to define, even though the above semantics leveraging distributivity is perfectly reasonable.
20:03:21 <dogcat1> "My argument is that <|> on ListT is supposed to be an algebraic operation" -> I'm not this is actually the case in at least one other instance
20:03:29 <dogcat1> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Except.html#line-202
20:03:39 <lexi-lambda> <|> is not algebraic for other monads, but it is algebraic for the list monad.
20:03:42 <dogcat1> <|> on ExceptT
20:03:49 <dogcat1> ahhh, okay
20:08:47 <lexi-lambda> The algebraicity of <|> is also violated by the listen implementation, FWIW.
20:09:05 <lexi-lambda> eff happily handles both catch and listen correctly. :)
20:10:42 <lexi-lambda> These test cases form the acid test I came up with. AFAICT, no other Haskell implementation of anything remotely resembling effects passes them all. https://github.com/hasura/eff/blob/17cc75d35fad4db557c3a08a83cace3f9a800826/eff/test/Control/EffectSpec.hs#L58-L93
21:16:23 * hackage hw-bits 0.7.1.3 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.3 (haskellworks)
21:35:23 * hackage hw-bits 0.7.1.4 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.4 (haskellworks)
23:38:06 <perdent> Anyone?
23:46:53 * hackage concurrent-resource-map 0.1.0.0 - Concurrent resource map  https://hackage.haskell.org/package/concurrent-resource-map-0.1.0.0 (MateuszKowalczyk)
23:50:38 <jackdk> ?
