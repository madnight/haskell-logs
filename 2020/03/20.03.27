00:01:32 * hackage topograph 1.0.0.1 - Directed acyclic graphs.  https://hackage.haskell.org/package/topograph-1.0.0.1 (phadej)
00:04:38 <whatatiming> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket.html#v:isUnixDomainSocketAvailable
00:04:41 <whatatiming> what this is used for?
00:05:04 <whatatiming> this can check that socket is available ?
00:06:51 <whatatiming> :t isUnixDomainSocketAvailable
00:06:53 <lambdabot> error:
00:06:53 <lambdabot>     Variable not in scope: isUnixDomainSocketAvailable
00:10:30 <phadej> whatatiming: there are no unix sockets on Windows
00:10:34 <phadej> there the value is False
00:11:27 <phadej> whatatiming: https://github.com/haskell/network/blob/master/Network/Socket/Unix.hsc#L115-L123
00:12:39 <whatatiming> phadej when socket is not available on unix, what this will return?
00:13:34 <whatatiming> I mean is there a function can check if the socket is available now? of course we can use PING and we will get an exception if the socket is closed by remote
00:14:26 <phadej> it means whether the functionality is available at all
00:14:48 <phadej> there are no unix sockets on windows
00:15:19 <whatatiming> yes, I mean using it on linux, not on windows
00:16:42 <phadej> then on linux that value is most likely to be True always
00:16:54 <whatatiming> ok, I see
00:17:52 <phadej> it's there so one can make cross platform applications, and degrade gracefully if functionality is not available
00:26:30 <jjhoo> whatatiming: what do you mean by 'if the socket is available now'? so that some read / write succeeds?
00:27:45 <whatatiming> jjhoo yes
00:28:27 <whatatiming> jjhoo like the remote disconnected without an exit signal, the local send something will cause an exception
00:29:01 <whatatiming> so I wonder if there a function can detect that if the socket if available instead of sending stuff and get an exception
00:29:16 <whatatiming> so we don't need the Exception to handle that
00:29:19 <jjhoo> select?
00:29:36 <whatatiming> what select?
00:29:37 <jjhoo> or poll
00:30:18 <whatatiming> more specific?
00:31:55 <jackdk> select(2) and poll(2) are classic networking functions for having one process monitor multiple sockets for changes in readability/writeability
00:32:14 <jjhoo> those two are probably too low level, probably used internally anyway?
00:32:31 <whatatiming> no, I don't mean async
00:32:51 <jackdk> http://beej.us/guide/bgnet/ is a great place to start, even though it's in C. A lot of languages provide direct bindings to the classic bsd-style functions
00:33:02 * hackage cabal-toolkit 0.0.7 - Helper functions for writing custom Setup.hs scripts.  https://hackage.haskell.org/package/cabal-toolkit-0.0.7 (sgraf812)
00:47:58 <dmj`> whatatiming: I would check epoll
00:48:15 <dmj`> @package epoll
00:48:15 <lambdabot> http://hackage.haskell.org/package/epoll
00:58:33 <phadej> you don't need epoll unless you have a lot of connections (i.e. server)
01:04:40 <dmj`> sure
01:04:53 <dmj`> can also convert Socket to a handle and call https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#v:hIsOpen
01:05:03 <dmj`> or go by way of Fd
01:05:56 <phadej> it's wrong, you don't know whether the connection is closed from the other side until you try to read or write
01:06:01 <phadej> so if you want to be sure, you need to do that
01:06:15 <phadej> and if you cannot block, than use NON_BLOCKING (or whatever it is in Haskell)
01:06:23 <phadej> it's more of network programming in general, than Haskell specific
01:06:39 <phadej> Haskell doesn't add any magic to that (and that's good thing)
01:15:47 <whatatiming> yes, I guess we can only knowing the connection whith send/read stuff
01:16:33 <whatatiming> select/epoll are used for sync, but I perfer forkIO/async
01:36:01 <phadej> than you can afford to block
01:36:49 <phadej> it won't block whole process thanks to RTS IO manager
01:36:58 <phadej> just the haskell thread
02:07:51 <eskomse> How do I play lens golf for this: https://pastebin.com/8Y2y0zr7
02:08:58 <eskomse> Just wondering if there is a better way.
02:10:41 <phadej> https://hackage.haskell.org/package/lens-4.19.1/docs/Data-Map-Lens.html#v:toMapOf second example
02:13:34 <eskomse> Ah, this one behaves slightly differently: [("ab", 1)] becomes M.fromList [("a", 1), ("b", 1)]
02:13:55 <eskomse> * I mean 'a' and 'b'
02:16:58 <eskomse> Ah, I see the to mapOf will still help
02:21:04 <phadej> % Data.Map.Lens.toMapOf (folded . to (\(xs,y) -> [(x,y) | x <- xs]) . folded . ifolded) [("abcdef", 1), ("xyz", 2)]
02:21:04 <yahb> phadej: fromList [('a',1),('b',1),('c',1),('d',1),('e',1),('f',1),('x',2),('y',2),('z',2)]
02:21:16 <phadej> I wouldn't golf that `to` function too much
02:22:00 <rsoeldner> Hi, I struggle to define `MonadBaseControl IO AppM` with AppM beeing a newtype of `ReaderT Env (ExceptT ServantErr IO) a`. Is there some good post explaining it ?
02:23:30 <akegalj> does anyone know how https://github.com/obsidiansystems/obelisk relates to https://github.com/reflex-frp/reflex-platform ? They both seem to target the same problem as far as I understand
02:23:48 <merijn> Honestly, I would recommend avoiding MonadBaseControl, it's impossibly confusing
02:23:59 <rsoeldner> akegalj, obelisk uses reflex
02:24:16 <akegalj> rsoeldner: reflex-platform also uses reflex-frp
02:25:10 <akegalj> are they just two different architectures to build haskell anywhere, or is there more ?
02:26:22 <rsoeldner> from my understanding obelisk itself uses the reflex-platform to setup the entire environment but offers additional tools like deployment, routing libs, ...
02:30:05 <rsoeldner> merijn, unfortunatly `withResource` from the `resource-pool` package requires this constraint https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html
02:31:09 <merijn> rsoeldner: Someone made a MonadUnliftIO version: https://hackage.haskell.org/package/unliftio-pool
02:31:52 <merijn> MonadUnliftIO is considerably simpler to get/use
02:33:55 <dmj`> whatatiming: you should be able to check if the connection is in FIN_WAIT_1 in the TCP lifecycle, other side will send this bit
02:34:34 <dmj`> when it wants to initiate a close
02:34:35 <rsoeldner> merijn, thank you I will look at it
02:35:27 <akegalj> rsoeldner: hm, that might be the case - will have a closer look
02:38:19 <maerwald> merijn: there's this huge blog post about MonadBaseControl. But I found myself just more confused after reading it
02:38:47 <merijn> maerwald: MonadBaseControl is just super confusing, imo
02:39:15 <maerwald> https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/
02:40:18 <maerwald> There's also MonadTransControl 
02:40:32 <lortabac> a better blog post would be one that shows what the alternatives are
02:42:55 <dmj`> maerwald: In practice most use MonadBaseControl, not MonadTransControl
02:43:50 <dmj`> the big thing MonadBaseControl gives you is the ability to fork threads while retaining the state of the monad you're operating in
02:44:24 <gentauro> I'm adding the pragma `{-# LANGUAGE BangPatterns #-}` to my code as I would like to replace all the: "foo `seq` bar `seq` ..." with "foo !x !y = ..." (easier to read code). But GHC is not all happy about that and tells me that I should increate `-fsimpl-tick-factor` and use `-ddump-simpl-stats` for detailed info
02:44:58 <gentauro> I thought the the bang pattern was just some syntactic sugar on top of `seq` ...
02:46:32 * hackage repline 0.3.0.0 - Haskeline wrapper for GHCi-like REPL interfaces.  https://hackage.haskell.org/package/repline-0.3.0.0 (sdiehl)
02:46:45 <Uniaika> woop woop new Repline!
02:49:38 <srk> \o/
02:50:02 <reactormonk> from recursion-schemes, is there a way to get the `a` of the current layer?
02:50:17 <phadej> reactormonk: if you use cata, change to use para
02:50:59 <reactormonk> Not using anything at the moment, I wrote the pattern match manually, now I'm wondering if I can delete that one
02:51:26 <gentauro> is there anybody here who can (shortly) describe diff/pro/cons between `{-# LANGUAGE BangPatterns #-}` and `seq`?
02:51:30 <gentauro> thx in advance :)
02:51:55 <phadej> let (!x, !y) = foo in .. is tricky to write using `seq`
02:51:57 <phadej> ... try!
02:52:26 <phadej> in other words, BangPatterns are just a lot more convenient
02:52:39 <gentauro> phadej: and easier to read
02:52:45 <gentauro> but is there a relation with seq?
02:53:01 <gentauro> or are there some "magic" going on under the hood
02:53:23 <gentauro> that requieres knowledge to GHC intrinsics?
02:53:24 <phadej> there aren't
02:53:56 <phadej> you should be able to desugar bang patterns to seqs
02:54:06 <phadej> and strictness analyser should pick seqs too
02:55:40 <gentauro> cool
02:56:26 <gentauro> so I just need to do an extra effort when refactoring `seq` to `!foo` and maybe read up on `-fsimpl-tick-factor`. Got it
03:00:37 <merijn> gentauro: seq already requires knowledge of GHC intrinsics :p
03:01:57 <phadej> seq is standard
03:02:20 <phadej> and AFAIK BangPatterns were jsut forgotten from Haskell2010
03:02:24 <gentauro> phadej: nothing in Haskell/GHC is standard :P
03:02:27 <gentauro> it's all complex :P
03:02:46 <phadej> asdasdi.e. could work without LANGUAGE extension even
03:03:34 <gentauro> phadej: can I build (cabal -> default-language: Haskell98) with BangPatterns? Or does it require Haskell2010?
03:03:56 <merijn> phadej: It's standard, but the standard doesn't specify much about what it does
03:04:14 <merijn> phadej: So realistically, reasoning about 'seq' involves reasoning about *GHC*s seq
03:04:16 <phadej> merijn: I don't remember what it says, yes.
03:04:49 <phadej> gentauro: try
03:05:09 <phadej> I'm not sure what default-language actually precisely changes
03:05:10 <gentauro> phadej: it (actually) works 
03:05:19 <gentauro> :)
03:05:35 <phadej> some defaults, but I don't remember which
03:06:15 <merijn> Default language just changes which standard GHC uses
03:06:27 <merijn> I don't think it does more than that, right?
03:06:56 <merijn> gentauro: tbh, why would you even bother with Haskell98 over Haskell2010?
03:07:09 <gentauro> merijn: but if there are additions to GHC that doesn't exist in Haskell98, the build will break right?
03:07:31 <gentauro> merijn: I really like determinism
03:07:42 <merijn> gentauro: What?
03:07:56 <merijn> I don't understand that question, tbh
03:08:38 <gentauro> merijn: https://wiki.haskell.org/Haskell_2010#Changes_since_Haskell_.2798
03:09:32 <gentauro> maybe I misunderstand what Haskell98 / Haskell2010
03:09:34 <gentauro> stands for
03:10:24 <merijn> gentauro: Haskell98 refers to "Haskell as standardised in the 98 report" and Haskell2010 is "Haskell as standardised in the 2010 revision of the report"
03:11:34 <phadej> in GHC speak, Haskell98 and Haskell2010 are different set of default LANGUAGE extensions
03:12:02 <gentauro> merijn: so it's not like C++ with: C++03, C++11, C++14 and C++17?
03:12:12 <merijn> gentauro: I don't really see a convincing argument to stick with the 98 version. 2010 is 10 years old, so all GHC versions anyone cares about support it. Hell, even UHC supports all of Haskell2010, so even if you care about portability there's little argument, since UHC is the only other halfway usable implementation
03:12:22 <merijn> gentauro: I don't understand what you mean by that
03:12:37 <merijn> Define "not like"
03:12:49 <gentauro> og with C: c89, c99?
03:13:24 <merijn> Those are all revisions of language standard too, so I'm honestly not sure what "not like" means
03:13:31 <gentauro> merijn: sometimes when you work on a legacy C/C++ project, they require you to build with c89 or C++03
03:13:55 <phadej> w.g .https://gist.github.com/phadej/c069a79f39e2a5d6c7362418248f742f
03:13:55 <merijn> gentauro: That's because the standard changed in an incompatible way, then
03:14:07 <gentauro> it's not always possible to lift a hole project just to get some new feature
03:14:13 <merijn> gentauro: But Haskell2010 changes *very* little
03:14:24 <merijn> gentauro: And afaik has basically 0 breakage in real code
03:14:25 <phadej> merijn: except that GHC doesn't implement Haskell2010
03:14:26 <gentauro> merijn: this is what I'm aiming at. Is 2010 compatible with all 98 code?
03:14:31 <phadej> neither FTP nor AMP are Haskell2010
03:14:37 <merijn> phadej: GHC doesn't implement Haskell98 either, tbh
03:14:45 <phadej> no, by the same argument
03:14:53 <gentauro> hehhe
03:14:54 <phadej> sadly.
03:14:56 <gentauro> wtf
03:14:58 <merijn> phadej: Even before FTP/AMP it wasn't compatible
03:14:58 <gentauro> :|
03:15:15 <phadej> Only miranda is the same!
03:15:23 <merijn> gentauro: In the report Applicative isn't a superclass of Monad
03:15:35 <gentauro> phadej: YES !!! they just went open source, so now we can use it !!!
03:15:41 <merijn> This is part of the reason people want a new Haskell Report to standardise the new GHC typeclass hierarchy
03:15:51 <gentauro> maybe I should use some effort in learning Miranda then :)
03:16:50 <merijn> gentauro: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#haskell-standards-vs-glasgow-haskell-language-non-compliance
03:18:34 <merijn> gentauro: Anyway, you probably have about 99% chance that code that compiles cleanly with Haskell98 compiles just fine with Haskell2010
03:21:15 <gentauro> merijn: thx for the link. I will read it :)
03:52:55 <maerwald> is it possible to modify some fields of a .cabal file without reformatting all the others?
03:54:11 <phadej> with a carefully crafter regexp, maybe.
03:54:51 <maerwald> I was more thinking using the Cabal library
04:06:49 <svipal> hey
04:06:58 <svipal> is it pssible to build a foreign library using stack ?
04:08:11 <svipal> writing a foreign-library config  in package.yaml mirroring what you would do in cabal seems to be ignored
04:13:49 <zincy_> How do you return custom JSON values as responses in Servant?
04:14:07 <zincy_> I want to return a JSON with a status, message and data field.
04:14:44 <dimsuz> Hi! let count = 1 in putStrLn $ "Token count " <> show count prints an error "Couldn't match type ‘[Char]’ with ‘Text’". I understand that this is expected because of an OverloadedStrings, but I wonder what is a standard way to solve this?
04:15:46 <svipal> I'd just annotate
04:16:14 <Uniaika> I wouldn't use Prelude's 'putStrLn' if you're handling `Text`
04:16:14 <[exa]> dimsuz: .... <> (show count::String)
04:16:29 <Uniaika> +1
04:17:21 <[exa]> OTOH it's weird that this defaulted to Text when it seems impossible to satisfy, right?
04:17:25 <dimsuz> Oh, it it seems I'm using some other putStrLn (learning by writing a Yesod app). Because this helped: putStrLn $ "Token count " <> pack (show count)
04:17:48 <svipal> the problem is actually hpack not stack soz
04:17:49 <dimsuz> So it seems that this is "putStrLn :: Text -> IO ()"
04:18:03 <svipal> So... is there any way to make hpack write a foreign-library thing
04:18:11 <svipal> to the actual .cabal
04:18:17 <[exa]> dimsuz: aaaaah yes, I understood it the other way :]
04:19:35 <Uniaika> svipal: https://github.com/sol/hpack#passing-things-to-cabal-verbatim
04:22:48 <svipal> I love you
04:23:18 <Uniaika> sorry but heart is already taken by multiple people
04:23:28 <Uniaika> however you can help me document `base` :P
04:23:37 <svipal> I give my love freely without expecting anything in return
04:23:48 <svipal> Hahaha where do you need help ?
04:24:13 <Uniaika> svipal: every-fucking-where: https://gitlab.haskell.org/ghc/ghc/issues/17929 
04:30:22 <svipal> So do you need help documenting the new behaviour, or is it that the old documentation was incomplete ? I never felt base was lacking in doc but maybe I was just blind
04:32:20 <maerwald> zincy_: What type are you in? I suspect it's Handler?
04:33:02 <Uniaika> svipal: some parts of base are under-explained, so we're adding examples and sometimes more approachable prose, as well as warnings for partial functions
04:34:02 <Uniaika> the ultimate goal would be to see that effort spread to other prominent haskell projects :)
04:35:15 <maerwald> documented haskell libraries? :>
04:35:23 <maerwald> Don't get me excited
04:35:58 <maerwald> The biggest problem with documentation is often not that lack of it, but the lack of structure of the documentation.
04:35:59 <Uniaika> maerwald: join us~
04:36:06 <maerwald> You need a good way to *navigate* documentation
04:36:11 <Uniaika> we're also contributing to Haddock
04:46:02 * hackage cobot-io 0.1.2.10 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.10 (ozzzzz)
04:48:11 <Uniaika> maerwald: if you wish to help us in our holy quest, you're more than welcome :)
05:02:32 * hackage sr-extra 1.72.3 - Module limbo  https://hackage.haskell.org/package/sr-extra-1.72.3 (DavidFox)
05:03:32 * hackage aws-lambda-haskell-runtime 2.0.4 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-2.0.4 (NickSeagull)
05:03:59 <maerwald> Uniaika: I'm wondering of how to standardize things like "documenting exceptions" and "documenting partiality"
05:06:16 <merijn> Let's just rework exception to have proper checked and inferred exceptions instead :p
05:06:33 <merijn> I have ideas, just need someone to pay me to work on them :p
05:08:04 <maerwald> merijn: you picked the right time for freelancing on research ideas... :/
05:09:41 <maerwald> But extending haddock to have special sections for things like Exceptions shouldn't be too hard
05:11:37 <Uniaika> maerwald: https://github.com/haskell/haddock/issues/1139
05:21:48 <maerwald> Uniaika: oh, I forgot discussions are hard ;P
05:23:30 <maerwald> I'm more pro something like: '@fails @IOException if something goes wrong' where the second argument is optional
05:24:04 <maerwald> so for partial functions you'd just say '@fails for empty lists'
05:25:26 <Uniaika> yup', inter-personal communication is fucking hard
05:26:13 <maerwald> Well, at least asynchronous communication works better for such things. Imagine you'd be in a meeting with 5 people discussing this
05:35:15 <merijn> maerwald: IMO, you want async discussion up front with everyone laying out their arguments and then like one instant get together to make a decision. Because trying to reach consensus asynchronously takes decades >.>
05:35:45 <maerwald> True, but most people join the meetings without any preparation whatsoever and you waste time explaining the problem
05:36:58 <maerwald> Did you know in ancient germany during Caesars time, the leaders would meet for political discussions and get drunk. Then meet up again sober next day to make a decision...
05:37:45 <maerwald> (because how else would you bear such discussions if not drunk?)
05:38:10 <phadej> decisions in hangover?
05:38:15 <maerwald> heh
05:38:18 <phadej> decisions-making.
05:44:51 <whatatiming> import qualified Data.Text as T
05:45:02 <whatatiming> a = "abc" :: T.Text
05:45:35 <whatatiming> but this got error, couldn't match expected type ‘T.Text’ with actual type ‘[Char]’
05:45:50 <whatatiming> why?
05:45:56 <maerwald> :set -XOverloadedStrings
05:47:09 <whatatiming> flags have not been recognized: -XOverLoadedStrings
05:47:53 <maerwald> You mistyped
05:48:20 <whatatiming> loaded
05:48:21 <maerwald> ghci also has autocomplete
05:49:17 <whatatiming> why String is [Char] and Data.List.permutations can work on, but it can't work on Text
05:49:26 <whatatiming> String, Text, ByteString,
05:49:38 <maerwald> Historical mistake
05:49:46 <whatatiming> why Text doesn't have permutations?
05:50:34 <whatatiming> everytime I want to do permutations, I have to converse them, it's really not good
05:51:54 <maerwald> Text is time and space efficient. String is not
05:51:57 <merijn> whatatiming: Because permutations of unicode text (at the code point level) is, honestly, nonsensical
05:53:29 <Uniaika> (I'll be forever jealous of Elixir who has its String type as an array of graphemes…)
05:57:54 <whatatiming> I wonder how python and scheme handle this relation?
05:58:16 <whatatiming> I know python2 has str
05:58:29 <whatatiming> which str is bytestring
05:58:59 <whatatiming> I never care about encoding on scheme
05:59:10 <whatatiming> it just works
06:38:04 <zincy_> Is using TH to derive typeclasses for production code pragmatic?
06:41:51 <Uniaika> zincy_: depends, is that replacing something that would take hours of developer time and would be error-prone?
06:42:04 <Uniaika> will your CI times suffer from the TH addtion?
06:42:32 * hackage jira-wiki-markup 1.1.4 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.1.4 (tarleb)
06:42:35 <Uniaika> is the generated code so utterly complicated that the sacrifice is reasonable?
06:44:15 <phadej> do types change that often that keeping instances up to date will make developers cry for help often enough? :)
06:45:12 <phadej> is TH provided by the library (or companion library) which defines type classes?
06:46:18 <phadej> I wouldn't recommend writing TH yourself, if you are "unsure".
06:47:04 <maerwald> Isn't TH a moving target anyway? I mean, if you learned it today, will that help you in 1 year?
06:48:36 <phadej> it moves as much as the features you use in the generated code
06:51:35 <phadej> e.g. lens (or optics) boilerplate generation is something which TH is the tool. Doing it other ways is most likely too slow.
06:51:45 <phadej> slow as in developer time.
06:52:17 <phadej> generic-lens is otoh good contestant, but its compile time and run time performance are volatile
06:52:44 <lyxia> maerwald: what kind of changes are you referring to? The API gets broken, but haven't the underlying concepts have been the same since forever?
06:53:19 <lyxia> I haven't written TH for years but I'm pretty sure I could get back to it easily.
06:53:21 <maerwald> lyxia: I don't really know. Afair the API breaks all the time. Not sure if the concepts don't
06:53:40 <merijn> maerwald: TH is a "moving target" in the sense that it pretty much directly mimics the GHC AST, so if that changes TH changes
06:53:45 <maerwald> At least that's what I got from a TH talk in Berlin
06:53:54 <maerwald> Yeah
06:54:12 <merijn> maerwald: But if you use a conservative subset and/or avoid writing TH "directly" (as opposed to using quoting)
06:54:16 <merijn> eh
06:54:24 <phadej> yes, but these breakages aren't "rewrite all your code"
06:54:32 <merijn> I mean, "using quoting instead of directly writing TH constructors"
06:55:04 <phadej> I haven't found adaptation to next template-haskell library version a problem
06:55:30 <merijn> maerwald: If you use quasi quoters as much as possible the problem gets reduced already, since the quasi quotes always produces the "right" TH code, regardless of version
06:55:39 <phadej> in GHC-8.8 -> GHC-8.10 e.g. nothing changed.
06:55:47 <phadej> (in libraries I maintain)
06:56:43 <phadej> TH is "bad" not because it breaks, but because it allows arbitrary computation at the compile time
06:56:54 <phadej> and is untyped, so it's hard to get right (the first time)
06:57:09 <phadej> OTOH, both are sometimes exactly what you need
06:57:19 <phadej> compared to e.g. generics
07:04:45 <Cale> I'd say the largest annoyance with TH isn't so much with trying to keep effects out, but with the fact that it doesn't quite give you enough ability to query the type system to make the kinds of things it ends up being used for (filling in instances) especially easy.
07:05:26 <Cale> For most of the TH programs I work with, all the subtlety is in simulating enough of the type system to work out what the constraints on a generated instance ought to be
07:06:01 <Cale> When, if you could simply ask the compiler "what would the inferred type of this function be?" it would be obvious
07:06:36 <phadej> intance MyClass MyType where method = $(deriveMethod ''MyType) -- there are ways around :)
07:06:51 <Cale> Well, but then you have to write the instance head yourself
07:07:05 <Cale> which in some cases, is the entire trick :)
07:09:42 <Cale> I have a bunch of GADT-related TH, where the hard part isn't implementing the methods, but rather, collecting up all the constraints that were generated by handling each of the constructors, and not missing anything or generating redundant/unnecessary constraints
07:11:43 <merijn> phadej: Typed TH doesn't alleviate part of the issue?
07:12:10 <phadej> merijn: it does, but it's not good enough (yet).
07:12:55 <phadej> I mean, some stuff isn't possible to write with TTH.
07:13:12 <phadej> and not even convoluted one. But when it works, it's great.
07:21:32 * hackage bzip-signature 0.2.0.0 - Backpack signature for BZip compression  https://hackage.haskell.org/package/bzip-signature-0.2.0.0 (vmchale)
07:33:07 <jchia__> Is there a standard way to get a traversal of all the occurrences of (a :: *) within a nested structure (s :: *)? I want to traverse it to transform the a values with an (Applicative f => a -> f b).
07:35:30 <jchia__> More specifically, I'll be transforming with an Applicative f -> a -> f a
07:35:46 <jchia__> Applicative f => a -> f a
07:38:33 <merijn> jchia__: Traversable?
07:38:43 <merijn> :t traverse
07:38:45 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:39:27 <jchia__> Let's say I have "data Foo = Foo Text Int Text' and I want to traverse a [Foo], appending "a" to all the Text values.
07:39:57 <jchia__> How can I do it without caring about the specific definition of Foo?
07:40:47 <jchia__> That's some kind of map.
07:40:55 <jchia__> Or, I want to open a file with the Text filename and replace the Text with the Text content of the file. That's some kind of traverse.
07:41:32 <jchia__> Foo is not naturally traversable.
07:42:05 <merijn> jchia__: Honestly, the easiest way is to change Foo to be Traversable ;)
07:42:16 <merijn> jchia__: There's stuff like uniplate too, but that's confusing voodoo
07:42:59 <jchia__> uniplate involves Typeable & Data, probably incurring overhead that I don't want
07:44:41 <Lycurgus> replace the Text with the Text content of the file
07:44:54 <svipal> why does haskell export sooo many symbols by default ? Oo
07:45:14 <dsal> svipal: you mean Prelude?
07:45:15 <Lycurgus> linkages like snausages
07:45:33 <svipal> Idk if it's prelude but all my dlls on windows break
07:45:40 <svipal> cant even build them too many symbols
07:45:43 <svipal> https://stackoverflow.com/questions/46448892/cant-load-a-haskell-dll-on-windows
07:46:00 <svipal> any one knows a way to use the MyDef.def solution shown here
07:46:06 <svipal> with stack ?
08:03:54 <_________more> test
08:03:59 <juri_> no.
08:04:17 <_________more> I have never used IRC before, let me be
08:07:16 <day> is it possible to crosscompile with ghc for windows?
08:13:21 <carbolymer> any ideas how should I write "three": https://repl.it/repls/PurpleEntireDisk ?
08:13:59 <pja> day: I tried to get that to work some years ago, but ran into a number of blockers. Might be worth trying again though.
08:14:02 <carbolymer> unwrap App, run reader and then runExceptT?
08:14:39 <pja> oh wait, you want to cross compile /on/ Windows? I was trying to cross-compiler Windows binaries on Linux. Different problem :)
08:19:34 <_> huh
08:20:39 <day> pja: nono for windows on linux
08:21:06 <dmwit> carbolymer: three (App m) = App (mapReaderT runExceptT)
08:22:18 <carbolymer> dmwit, good idea, although the trick here  is that App constructor is hidden - I've just simplified the example (maybe a bit too much)
08:24:00 <dmwit> three m = do { cfg <- ask; liftIO (runExceptT (runApp m cfg)) }
08:24:14 <dmwit> I guess `three m = ask >>= liftIO . runExceptT . runApp m`
08:27:03 <carbolymer> dmwit, hmm, I was wondering if there is any way without runApp, bit this also will, do, thanks!
08:27:24 <dmwit> No, there is no way without `runApp`.
08:27:37 <dmwit> You may expand your `App` API with a map*-alike.
08:27:55 <dmwit> But if this (minus `App`) is your API, you must `runApp`.
08:28:20 <carbolymer> ok, thanks, I'll consider it
08:29:07 * dmwit . o O ( class Polymorph m where type Wog m; polymorph :: Wog n => m a -> n a )
08:31:24 <dmwit> instance Polymorph IO where type Wog IO m = MonadIO m; instance Polymorph m => Polymorph (ExceptT e m) where type Wog (ExceptT e m) n = (MonadError e n, Wog m n); instance Polymorph m => Polymorph (ReaderT r m) where type Wog (ReaderT r m) n = (MonadReader r n, Wog m n)
08:32:11 <dmwit> Guess that solves a different problem. Never mind.
08:33:38 <carbolymer> :)
08:54:41 <svipal> can you alter the command that stack outputs in an arbitrary way ?
08:58:40 <dmwit> The command that stack outputs?
09:00:16 <svipal> i'm guessing when you do a stack build
09:00:20 <svipal> stack looks inside the .yamls
09:00:53 <svipal> and makes a ghc yadda yadda yadda command
09:06:21 <svipal> I'd rather use stack than make the ghc command myself
09:09:58 <lortabac> svipal: if you run stack --verbose you can see the commands that are executed
09:11:58 <lortabac> I don't understand what you mean by "altering" those commands
09:13:31 <dmwit> Your cabal file(s) give you a lot of control over what flags it passes to GHC.
09:13:32 * hackage dobutokO2 0.19.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.19.0.0 (OleksandrZhabenko)
09:14:09 <day> pja: how did you fix your crosscompiling issue/ what workaround did you come up with in the end?
09:14:25 <dmwit> If you want *arbitrary* control, you'll have to do something gross like moving the GHC executable off to the side and putting something else in its place that munges the command. But this absolutely should not be necessary for 99.999% of modifications people actually want to do.
09:14:50 <svipal> I need to use a .def file
09:15:01 <svipal> to filter the symbols
09:15:02 * hackage vty 5.28.2 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.28.2 (JonathanDaugherty)
09:15:20 <svipal> the foreign library built with cabal ends up with
09:15:54 <frdg> https://pastebin.com/WXXTbKVJ would anyone mind critiquing this code? What would you have done different? How could it improve?
09:15:55 <svipal> it's not a flag per se and looking in the stack doc didn't yield anything
09:16:57 <lortabac> svipal: if there is a GHC option for that, you can set it in the ghc-options field in the .cabal file
09:17:02 * hackage hvega 0.7.0.1 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.7.0.1 (DouglasBurke)
09:18:48 <svipal> i'm not sure there is, according to that post you just need to add the .def at the end of the line
09:18:57 <svipal> but I will verify in ghc's doc
09:19:14 <svipal> (that post: https://stackoverflow.com/questions/46448892/cant-load-a-haskell-dll-on-windows)
09:19:23 <svipal> frdg, what are you responsible of in this code ?
09:20:09 <frdg> svipal: isDbDate, giveUTCTime, filterDbDate
09:20:15 <Phyx-> sclv: that's correct
09:20:21 <Phyx-> err
09:20:24 <Phyx-> damn tab completion
09:20:30 <Phyx-> svipal: yes that's correct
09:21:38 <svipal> Phyx- : so, am I borked ?
09:24:47 <Phyx-> svipal: are you sure stack is passing this on?
09:25:07 <svipal> I'm pretty sure it's not !
09:25:19 <svipal> my question is, how do I get stack to pass it
09:25:29 <svipal> frdg :I think I would have used a function using Maybe and a catMaybes like `filterDbDate x = catMaybes $ map (maybeGetDbDate x)` `maybeGetDbDate (DbDate x) = x`
09:25:48 <svipal> `Just x`*
09:26:04 <svipal> `maybeGetDbDate _ = Nothing`
09:26:22 <monochrom> svipal: https://cabal.readthedocs.io/en/stable/developing-packages.html#foreign-libraries ?
09:26:46 <svipal> monochrom you save my life again
09:27:21 <svipal> that's perfect
09:27:30 <frdg> svipal: Ok ill look into that! I wanted to make sure the code Id written wasn't poor/messy. Thank you
09:28:02 <pja> day: I didn’t. At the time it turned out that the build system got very, very confused about the difference between compiling for a different platform and for a different processor.
09:28:10 <Athas> Is there a simple way to build statically linked Haskell binaries yet?
09:28:17 <pja> & I didn’t have the time to really dig in and fix it.
09:28:29 <pja> It might have got better since - much has changed since then.
09:32:40 <svipal> frdg it's not messy atm according to my standards but I'm pretty sure some people would give you flak for using a partial function even though you use filter
09:49:37 <maerwald> what is a super monad?
09:55:22 <svipal> a monad using hyperfunctions ?..
09:55:54 <svipal> was that an actual or a philosophical question ? :D 
09:56:05 <maerwald> the local-do proposal mentions super monads
09:57:04 <monochrom> I found https://jbracker.de/publications/2016-BrackerNilsson-Supermonads.pdf
09:59:07 <maerwald> Seems like it
09:59:44 <svipal> it finally works
10:00:06 <svipal> building foreign dyn libs on windows is ...interesting
10:00:16 <maerwald> Not surprised the brits came up with a supermonad :D
10:00:32 <svipal> oof
10:01:45 <maerwald> Seems it's 2 classes (Bind and Return) instead of one
10:02:37 <monochrom> and also very flexible type for bind.
10:03:26 <maerwald> Yeah, so you can bind different monads
10:03:30 <maerwald> basically m1 -> m2 -> m3
10:03:55 <maerwald> I want this.
10:06:29 <maerwald> But I wonder what this does to code readability
10:06:43 <maerwald> 'do' will become quite powerful
10:07:05 <MarcelineVQ> "code readability" Who would want that :>
10:07:37 <MarcelineVQ> Could you link this local do proposal?
10:07:57 <yushyin> https://github.com/ghc-proposals/ghc-proposals/pull/216
10:08:11 <yushyin> I'm watching it too
10:08:24 <MarcelineVQ> thank you
10:09:12 <maerwald> MarcelineVQ: I stumbled over local-do when I was ranting about the type inference problems of open unions: https://github.com/haskus/packages/issues/32#issuecomment-596424753
10:09:33 <yushyin> I certainly see the motivation behind that
10:13:08 <MarcelineVQ> oh quite interesting, I wonder if this was inspired by idris :>
10:13:34 <yushyin> by F#
10:13:55 <maerwald> They're in the same office anyway :P
10:13:58 <yushyin> 'The design is inspired by F#'s computational expressions.'
10:15:47 <MarcelineVQ> ah neato. it made me think of idris because idris's do syntax uses >>= but not just Monad's >>=, any >>= in scope, and idris has type-directed overloading so it can often use the right >>= for the job but you can also annotatte your do to tell it which >>= to use iirc
10:17:07 <maerwald> isn't that a bit scary? Feels almost like dynamic types
10:17:45 <MarcelineVQ> that being said idk if one can write  (>>=) :: E e1 a -> (a -> E e2 b) -> E (F e1 e2)  as you wanted to, would have to try it
10:18:04 <MarcelineVQ> er hsyl20 I guess
10:18:32 * hackage Gleam 0.1.0.0 - HTML Canvas graphics, animations and simulations.  https://hackage.haskell.org/package/Gleam-0.1.0.0 (EbinBenny)
10:20:45 <MarcelineVQ> maerwald: not sure about that, usually your type signatures keeps things from going awry. I have done some scary things with it but they needed more than just overloading
10:49:46 <merijn>  /reconnect 
10:53:32 * hackage smarties 1.2.1 - Haskell Behavior Tree Library  https://hackage.haskell.org/package/smarties-1.2.1 (pdlla)
11:07:20 <frdg> what does "const" stand for
11:07:31 <merijn> constant
11:07:53 <merijn> frdg: It's the constant function, because it always returns the same thing, regardless of argument
11:08:05 <frdg> oh ok
11:08:08 <merijn> frdg: i.e. "const True" always returns True
11:27:00 <jle`> @let constantlyTrue _ = True
11:27:02 <lambdabot>  Defined.
11:27:05 <jle`> > constantlyTrue 6
11:27:07 <lambdabot>  True
11:27:11 <jle`> > constantlyTrue "hello"
11:27:13 <lambdabot>  True
11:27:19 <jle`> @let constantlyTrue' = const True
11:27:22 <lambdabot>  Defined.
11:27:25 <jle`> > constantlyTrue' 7
11:27:27 <lambdabot>  True
11:28:02 * hackage attoparsec 0.13.2.4 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.2.4 (BenGamari)
11:35:02 * hackage mpi-hs 0.7.0.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.7.0.0 (eschnett)
11:44:04 <zincy_> Uniaka and phadej: sorry had to run. In response to my TH question
11:44:52 <zincy_> The TH was literally used to save copy pasting deriving instance Foo Blah   ten times over for different classes 
11:45:10 <zincy_> I just had a hunch this was a bad idea
11:45:26 <zincy_> even though I don't have a reason to support my hunch apart from it feels wrong
13:05:02 * hackage libarchive 2.2.5.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.5.0 (vmchale)
13:20:57 <dsp> disclaimer "i have no idea about haskell, just trying to learn". with that out of the way , can someone explain the reasoning of why ghci allows 1/0 to evaluate to infinity but then div 1 0 to throw an exception? is the first one caught by a reader macro? thanks
13:22:17 <merijn> dsp: Answer to the second question is: No. It's a bit intricate
13:22:27 <merijn> dsp: We have to start with "What is 1/0?"
13:22:29 <merijn> :t 1
13:22:31 <lambdabot> Num p => p
13:22:35 <merijn> :t (/)
13:22:37 <lambdabot> Fractional a => a -> a -> a
13:22:43 <merijn> :t (1/0)
13:22:45 <lambdabot> Fractional a => a
13:23:08 <merijn> dsp: Ok, so numerical literals in Haskell are polymorphic. As you can see '1' and '0' can be any type that is an instance of Num
13:23:52 <merijn> dsp: Now, (/) works on any type that is an instance of Fractional (which has Num as a superclass, hence why the Num class disappears when we write "1/0")
13:24:15 <dsp> merijn: i really appreciate taking the type to explain this.
13:24:29 <merijn> dsp: Ok, so "1/0 :: Fractional a => a", it's polymorphic, but you can't evaluate polymorphic code. The compiler *needs* to pick a type to do that
13:25:16 <merijn> dsp: Normally you will get an error, but because polymorphic numeric expressions are so common there are some special defaulting rules for them that default them to Integer (or Int, I forget) and Double
13:25:37 <merijn> dsp: In this case, "Fractional a => a" gets defaulted to Double
13:25:58 <dsal> ghc will give you warnings telling you it defaulted to Integer because you probably didn't want that.
13:26:34 <merijn> dsp: Which lets us answer the initial question "Why is it infinity?" -> because IEEE-754 floating point numbers division results in infinity per the IEEE-754 spec
13:26:56 <merijn> dsp: Incidentally, if you start ghci with "-Wall" you should get a warning that it is defaulting the expression
13:27:44 <dsp> aha! now it makes waaaayyyy more sense
13:27:58 <merijn> > 1/0
13:28:01 <lambdabot>  Infinity
13:28:05 <merijn> > 1/0 :: Rational
13:28:08 <lambdabot>  *Exception: Ratio has zero denominator
13:28:09 <dsp> coming from scheme i was instantly disappointed thinking that this was an arbitrary reader macro, but now i see the type system at work.
13:28:51 <merijn> dsp: Try starting "ghci -Wall" and then running 1/0 again :)
13:31:04 <dsp> ok i aliased my ghci :)
13:31:49 <dsal> There are a few cases where ghci or ghc might be helpful in a way that can mislead you if you don't know what it's actually doing.
13:32:09 <dsal> I don't know that I'd want -Wall in ghci, though.
13:32:40 <dsal> If I'm serious enough to care about most warnings, I'm in the wrong spot.
13:33:33 <merijn> I think -Wall in ghci is a matter of taste, but for GHC/everything else it xhould always be on, imo
13:33:37 <dsp> dsal i'm at lvl 0 right now so i don't see my "code" being hindered by the wall , at least for a couple of weeks
13:34:47 <merijn> dsp: honestly, -Wall is the sensible default and then you selectively disable whatever you don't want (there's one or two warnings I personally don't like, but for the most part they're all sensible)
13:34:53 <dsal> dsp: makes sense. I use ghci kind of like irc.  Just go ask simple questions about what I'm doing.
13:35:16 <dsal> merijn: what don't you like?
13:35:51 <dsal> I end up turning off orphans in individual files.  I kind of know when I'm doing that...
13:36:14 <merijn> dsal: -Wunused-do-binds (i.e. if you use a monadic value in do notation that has a result other than () it nags you to explicitly do "_ <-"
13:36:59 <merijn> I don't find it useful and I find "_ <-" everywhere ugly and distracting
13:37:22 <dsal> Hmm...   Yeah.  I guess I know I'm not using the result already.
13:37:58 <dmwit> You know you're not using the result. But do you know the result is not ()?
13:38:09 <merijn> It's meant to protect against accidentally not using a result, but In my life that's really not something that happens often
13:40:18 <dsal> I guess I don't care what it is if I'm not using it.  Though I ended up using it after all in the last case where I had that warning.
13:49:42 <mekeor> hello. is there a haskell-library i could use to log into a web-page and then crawl around, saving some html-content and some PDF-documents? can webdriver do that?
14:01:17 <frdg> are there any Haskell youtube channels you would recommend?
14:03:53 <alx741> frdg: Haskell at work, Jekor
14:04:34 <frdg> ill check them out!
14:06:27 <frdg> seems like neither channels are active. In general I can't find much. Seems like theres an opportunity for someone to take over Haskell YouTube
14:09:41 <sm[m]> here's a recent one on ghcide: https://www.youtube.com/watch?v=zQtJKJr4hJI
14:11:21 <frdg> sm[m]: May be the start of something special. Maybe Matthew Pickering is gonna be a household name in the Haskell world?
14:11:29 <jackdk> https://www.youtube.com/watch?v=Nv5tf8pvgrY&list=PLeJwWmefGjycvSYaO-l4ExRd1eiO5cGov ed did a few twitch streams
14:12:18 <frdg> jackdk: cool!
14:12:42 <sm[m]> frdg: want to start by surveying existing haskell videos and video lists and consolidating ?
14:13:02 * hackage mpi-hs 0.7.1.0 - MPI bindings for Haskell  https://hackage.haskell.org/package/mpi-hs-0.7.1.0 (eschnett)
14:13:31 <sm[m]> cf https://wiki.haskell.org/Video_presentations, https://www.haskell.org/
14:14:27 <jackdk> hs video content isn't clustered around "channels", it's more around conferences
14:14:52 <frdg> sm[m]: Thats a great idea...but I don't think Im interested unfortunately. 
14:48:32 * hackage resolv 0.1.2.0 - Domain Name Service (DNS) lookup via the libresolv standard library routines  https://hackage.haskell.org/package/resolv-0.1.2.0 (HerbertValerioRiedel)
14:52:56 <mbakke> does it usually take 1+ day for marge to do a batch merge?
14:53:12 <mbakke> errh, GHC repository specific question here
14:54:12 <mbakke> first contribution anxiety, I guess
14:56:23 <MarcelineVQ> if it's about ghc building don't be shy to ask in #ghc
14:58:26 <mbakke> MarcelineVQ: makes sense, thanks
15:33:32 * hackage dobutokO2 0.19.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.19.1.0 (OleksandrZhabenko)
16:02:18 <mekeor> hello. while using co-log, i'm trying to join two loggers in order to log onto stdout as well as into a file. but i can't get it to work: http://sprunge.us/bj5rNu?haskell
16:03:20 <mekeor> oops, there was a mistake in the code i linked. here's the correct version: http://sprunge.us/kYFvPo?haskell
16:04:23 <mekeor> i'm trying to join two loggers with (<>) from Semigroups. `logTextStdout <> logTextStdout` works fine but `logTextStdout <> logTextHandle logFileHandle` doesn't work as expected.
16:05:32 * hackage eventstore 1.4.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.4.1 (YorickLaupa)
16:18:30 <koz_> What's the story with text? 1.2.3.2 works for GHC 8.10, but 1.2.4.0... doesn't?
16:58:32 * hackage linear-tests 0.1.2.0 - Linear Algebra  https://hackage.haskell.org/package/linear-tests-0.1.2.0 (pdlla)
17:00:27 <sm[m]> cabal experts: could you suggest how to adapt this stack script for someone who doesn't have stack ? Eg using cabal's new script-like command, or any other ghc-ish command (doesn't have to be robust). They have cabal-install 3.0.0.0. https://github.com/simonmichael/hledger/blob/master/bin/hledger-check-tag-files.hs
17:04:49 <sm[m]> or even, point me to that new script-like command ? I think it's not in 3.0.0.0
17:08:57 <sm[m]> ah, it's https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-run
17:18:32 * hackage QuickCheck 2.14 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.14 (NickSmallbone)
17:23:56 <sm[m]> answer: https://github.com/simonmichael/hledger/blob/master/bin/hledger-check-tag-files2.hs
19:30:50 <mekeor> which package would you use to download the content of a HTTP(S)-URL to a local file?
19:31:00 <mekeor> @hackage http-download -- ?
19:31:00 <lambdabot> http://hackage.haskell.org/package/http-download -- ?
19:31:42 <koz_> This perhaps? http://hackage.haskell.org/package/curl
19:35:16 <glguy> probably not that one
19:35:30 <mekeor> why not, glguy?
19:36:46 <mekeor> well, glguy was the last person who updated the "curl" package. in january 2018.
19:39:03 <koz_> glguy: Good to know, lol.
19:40:30 <MarcelineVQ> I'd probably go for http-conduit to a bytestring to a file, and will be at some point on my current project and but are also open to other suggestions
20:07:54 <sm[m]> or req
20:08:08 <sm[m]> http://hackage.haskell.org/package/req
20:27:37 <MarcelineVQ> sm[m]: neato
21:14:05 <Guest_56> Hi guys, i'm really new to Haskell and trying to install GHC on my mac at the moment but keep getting this error: ' Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!'
21:14:17 <Guest_56> does anyone know what's up? 
21:24:59 <Welkin> what is the new garbage collector in 8.10?
21:25:16 <Welkin> do threads have their own heaps, and own GC?
21:36:28 <sm[m]> Welkin: it’s in the release announcement on reddit
23:24:02 * hackage gopro-plus 0.1.0.0 - GoPro Plus Client API.  https://hackage.haskell.org/package/gopro-plus-0.1.0.0 (dustin)
