00:32:23 <idnar> Uniaika: `Data.Sequence` stole `(|>)` already!
00:35:34 <idnar> @hoogle Functor f => (a -> b) -> (t -> f a) -> t -> f b
00:35:35 <lambdabot> Control.Applicative.Tools (<.>) :: Functor f => (a -> b) -> (c -> f a) -> c -> f b
00:35:42 <idnar> hmm
00:36:17 <idnar> `lens` already stole `(<.>)`
00:38:24 * hackage hasbolt 0.1.4.2 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.4.2 (zmactep)
00:39:30 <idnar> @hoogle Int64 -> Rational -> Text
00:39:31 <lambdabot> No results found
00:41:30 <idnar> @hoogle MonadFail m => Either String a -> m a
00:41:31 <lambdabot> UnliftIO.Exception fromEither :: (Exception e, MonadIO m) => Either e a -> m a
00:41:31 <lambdabot> Stack.Prelude fromEither :: (Exception e, MonadIO m) => Either e a -> m a
00:41:31 <lambdabot> Dhall.Core throws :: (Exception e, MonadIO io) => Either e a -> io a
01:06:41 <idnar> how do I get `cabal v2-build` to apply some ghc options only for local packages? (`-ddump-simpl-stats` in this case)
01:23:00 <merijn> idnar: Add them to the cabal file for those local packages or specify them in cabal.project for those packages
01:23:22 <Uniaika> idnar: yes I konw, I'm so mad! :(
01:23:24 <Uniaika> *know
01:24:18 <Uniaika> but anyway, the position of the arguments in Haskell functions does not quite suits for function pipelines using (&) (or its alias (|>)). It's better to use (>>=)
01:39:44 <dminuoso> Uniaika: The main problem with |> is that it's not function composition, but a really bizarre unprincipled macro.
01:40:19 <Uniaika> I wouldn't necessarily say its it's main problem :P
01:40:45 <dminuoso> If you just care about the order though, you can use >>> from control arrow, which gives you left-to-right function composition.
01:40:51 <dminuoso> % :t f >>> g
01:40:51 <yahb> dminuoso: ; <interactive>:1:7: error: Variable not in scope: g :: Maybe ([Int], [Char]) -> c
01:41:01 <dminuoso> % :t \f g -> f >>> g
01:41:01 <yahb> dminuoso: forall k (cat :: k -> k -> Type) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
02:05:23 * hackage extra 1.6.21 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.21 (NeilMitchell)
02:09:56 <aveltras> using hasql-th, what would be the "path to less boilerplate" to make the following work ?
02:10:05 <aveltras> https://www.irccloud.com/pastebin/NAd2GjRm/
02:39:24 * hackage zip 1.3.2 - Operations on zip archives  https://hackage.haskell.org/package/zip-1.3.2 (mrkkrp)
02:47:44 <aveltras> what would be the way to flatten tuples of arbitrary sizes ? I've come across https://hackage.haskell.org/package/tuple-morph but it's abandoned
02:48:39 <Rembane> aveltras: Why do you want to flatten tuples of arbitrary sizes? 
02:50:10 <dminuoso> What does "flatten" even mean to you?
02:50:40 <aveltras> Rembane: i'm using hasql-th and, for an update statement, i have as input some tuple (ArticleId, Article) which needs to be flattened down to a simple Tuple (ArticleId, Text, Text, Text) to use it with the library (as far as i can tell). something like the following
02:50:45 <aveltras> https://www.irccloud.com/pastebin/fDVkQtG0/
02:51:09 <aveltras> i can go from Article to (Text, Text, Text) with the tuple package and giving an instance of Curry to Article
02:51:36 <Rembane> aveltras: So something like: (\(aid, a) -> (aid, a, "", "", "")) ? 
02:51:43 <aveltras> there might be better ways to make this works, im all ears :)
02:52:10 <aveltras> without the "a" in second position but yeah that's the goal
02:53:02 <Rembane> aveltras: Why not the a in second position?
02:53:45 <aveltras> Rembane: in my example, there are only 3 components to an Article, so i only need the ArticleId and the parts from Article, that's sum to 4 parts in total
02:59:53 <Rembane> aveltras: What do you do with the rest of the arguments to the query?
03:00:29 <aveltras> Rembane: what do you mean by "the rest of the arguments" ?
03:03:48 <aveltras> seems i might use sth like http://hackage.haskell.org/package/tuple-th-0.2.5/docs/TupleTH.html
03:07:23 <Rembane> aveltras: I don't really know, TBH I'm at a loss on how to help you. 
03:07:53 <aveltras> Rembane: yeah np, thanks for trying anyway :)
03:08:53 <dminuoso> aveltras: I suppose part of the problem is that this is relying on just plain tuples.
03:09:33 <dminuoso> If this was using vinyl this might be a different story I think.
03:20:14 <aveltras> aint the most beautiful but at least it compiles for now
03:20:18 <aveltras> https://www.irccloud.com/pastebin/NpWAXbjp/
03:23:24 * hackage wai-enforce-https 0.0.2 - Enforce HTTPS in Wai server app safely.  https://hackage.haskell.org/package/wai-enforce-https-0.0.2 (MarekFajkus)
03:27:28 <zincy_> Are there DB libraries out there which let you do queries inside of STM?
03:28:00 <zincy_> I guess there wouldn't be an easy way of doing that without interleaving db transactions and STM
03:34:07 <solonarv> you can't exactly "do queries inside of STM" because STM actions can run: not at all, multiple times, halfway through, and see inconsistent state on the way
03:34:27 <solonarv> this is not a good recipe for doing I/O !
03:40:53 <tdammers> in fact, we have a perfectly adequate type for representing "things that may need to do I/O"
03:40:57 <tdammers> it's called "IO"
03:49:24 * hackage dependent-hashmap 0.1.0.0 - Dependent hash maps  https://hackage.haskell.org/package/dependent-hashmap-0.1.0.0 (OlleFredriksson)
03:56:20 <mohit> Hi, is this the channel for haskell-gsoc?
03:57:22 <mohit> #haskell-distributed
04:44:24 * hackage termonad 3.1.0.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-3.1.0.0 (cdepillabout)
05:20:23 * hackage unliftio-core 0.2.0.1 - The MonadUnliftIO typeclass for unlifting monads to IO  https://hackage.haskell.org/package/unliftio-core-0.2.0.1 (MichaelSnoyman)
05:32:35 <gentauro> are these two lines of code equivalent:
05:32:36 <gentauro> data Foo a = F        !Word        !a        !a
05:32:37 <gentauro> data Bar a = B { n :: !Word, i0 :: !a, i1 :: !a }
05:33:04 <merijn> gentauro: Define "equivalent"
05:34:04 <gentauro> merijn: same usage of memory and so. I know the second line adds `function helpers` to retrieve values from the record type
05:34:06 <__monty__> Other than the functions introduced I'd expect them to be.
05:34:28 <merijn> gentauro: "Probably, but it's not specified"
05:34:57 <gentauro> merijn: so which one should I aim for? If I want to go as close to bare metal?
05:34:58 <merijn> I mean, you don't even get the guarantee that there is a single, unique representation of your datatype
05:35:00 <gentauro> the first one?
05:35:13 <merijn> gentauro: Context?
05:35:15 <gentauro> merijn: that sentence always make me sad :(
05:36:07 <gentauro> is the only way to ensure memory is used as I want by doing this -> http://blog.stermon.com/articles/2019/02/04/haskell-usage-of-malloc-free-is-safe.html
05:36:55 <merijn> gentauro: Storable is the only way you can *directly* and *explicitly* control how data is laid out in memory, yes
05:37:21 <merijn> gentauro: You can combine that with Storable Vector in many situations
05:40:00 <gentauro> merijn: thanks
05:40:21 <merijn> gentauro: There might be other/smarter things, but that's hard to say without knowing what you're doing
05:40:46 <merijn> gentauro: Actually, You can do it without Storable too if you directly encode things in primitive ByteArray#
05:41:09 <merijn> But I'd seriously question your need to, before putting in that work
05:42:05 <gentauro> merijn: I'm aiming to write "fast" Haskell code ...
05:42:18 <gentauro> I just want to know my possibilities
05:42:22 <merijn> And what makes you think *this* is the bottleneck? :)
05:43:10 <tdammers> I wouldn't bother with such optimizations until you have very good reasons that the compiler fails at making your code fast
05:43:28 <gentauro> merijn: if I have to work with billion of values of a specific type, it might help using the least amount of memeory to represent them
05:43:54 <merijn> gentauro: What kinda values?
05:44:00 <merijn> Have you done the napkin math?
05:44:55 <merijn> Also, if you have so many, do you really want them all in memory or are there other alternative?
05:45:05 <gentauro> merijn: as I understand with Haskell, napkin math doesn't hold
05:45:29 <tdammers> napkin math still provides bounds in most cases
05:46:04 <__monty__> It's slightly different but broad things like X bytes/data item is abstract enough to not differ.
05:46:33 <__monty__> I call that ^ napkin english...
05:47:35 <gentauro> reasoning about mem in Haskell is quite difficutl
05:47:43 <gentauro> not ASM/C/C++ ...
05:48:18 <__monty__> When memory will be used, sure. But not the size.
05:49:04 <gentauro> I will just go `Foreign.{Marshal.Alloc,Ptr,Storable}` and play it safe
06:02:37 <shafox> Anyone getting this error while installing cabal-install with stack lts for 8.8.2 ? https://gist.github.com/shadow-fox/5f7f66925a2ed6eb618b8896f982da5b 
06:02:58 <prog87> has anyone used AWS s3 storage with haskell?
06:02:59 <prog87> https://hackage.haskell.org/package/amazonka-s3-1.6.1/docs/Network-AWS-S3.html
06:03:47 <prog87> the documentation is fairly opaque 
06:11:13 <prog52> ok, i can find this; https://github.com/brendanhay/amazonka/blob/develop/examples/src/Example/S3.hs
06:11:57 <prog52> it has a "getFile" function
06:14:31 <prog52> hmm, but the "putChunkedFile" is difficult to read...
06:14:43 <prog52> like, what if you want to swap that for not chunked
06:25:51 <boxscape> % head (x:_) = x; safeHead = unsafeCoerce :: [a] -> Maybe a -- which of these would you rather use?
06:25:52 <yahb> boxscape: 
06:25:53 <boxscape> seems a bit like one of those "who would you rather fight" questions
06:26:24 <Rembane> boxscape: listToMaybe is my champion. 
06:26:44 <boxscape> but that's so boring compared to unsafeCoerce `asTypeOf` listToMaybe
06:26:46 <Rembane> boxscape: How can unsafeCoerce go wrong? 
06:27:08 <boxscape> In this context? I don't really know of any way
06:27:41 <Rembane> Me neither. Isn't that operation a natural transformation? 
06:28:04 <boxscape> I think so
06:29:39 <dminuoso> boxscape: The first by far.
06:29:51 <boxscape> though counter-intuitively (and I have no idea if this is actually true) listToMaybe might actually be more efficient than unsafeCoerce because list fusion works better with it
06:29:56 <dminuoso> unsafeCoerce has just ridiculously high "can go wrong" potential
06:30:54 * hackage ghc-tags-plugin 0.1.0.2 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.0.2 (coot)
06:47:54 <iphy> what's the best way to read a UTF-8 encoded file into a String?
06:49:48 <lyxia> iphy: readFile?
06:49:55 <__monty__> iphy: Text's readFile?
06:50:01 <iphy> __monty__: I'll try that
06:50:12 <iphy> lyxia: "invalid byte sequence" because LANG=C or something
06:50:26 <iphy> I want it to read a UTF-8 file regardless of LANG and LC settings
06:52:06 <dminuoso> iphy: Then use the `text` package
06:52:23 <dminuoso> iphy: Or explicitly use hSetEncoding
06:52:30 <dminuoso> http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetEncoding
06:52:40 <__monty__> iphy: Hmm, the docs for text recommend to read as ByteString and then decode: https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-IO.html#v:readFile
06:53:04 <dminuoso> Consider that: readFile name   =  openFile name ReadMode >>= hGetContents
06:53:20 <dminuoso> So write that with an additional hSetEncoding in between
06:53:29 <boxscape> __monty__ they recommend that for the situation where "you must use a non-UTF-8 locale on an older version of GHC"
06:53:55 <boxscape> or maybe you're looking at something else
06:54:05 <boxscape> because what I'm looking at is talking about writing rather than reading
06:54:07 <__monty__> boxscape: No, they recommend it in the Performance section.
06:54:12 <boxscape> ah
06:54:54 <__monty__> But hSetEncoding is probably more ergonomic and I doubt the performance difference is noticeable for most things.
06:58:07 <iphy> contents <- Text.unpack . Text.decodeUtf8 <$> BS.readFile source
06:58:09 <iphy> this works
06:58:20 <iphy> I don't need performance in this code (at least not yet)
07:01:44 <merijn> __monty__: Reading bytestring + explicit decode is better because that means you explicitly control the encoding, which may not be global (i.e., you might want to read a file that's known to be UTF-8 even if your locale is UTF-16)
07:02:26 <merijn> hah, so actually here is the exact case :p
07:03:04 <merijn> iphy: decodeUtf8 is ick, if you wanna be safe you want either decodeUtf8' or decodeUtf8With
07:03:12 <iphy> yeah
07:03:20 <iphy> I'll use decodeUtf8' later
07:05:26 <dminuoso> iphy: Then use decodeUtf8With now.
07:05:42 <iphy> dminuoso: that will hide errors, no?
07:06:00 <iphy> anyway, "now" is right now while I'm working on other code
07:06:11 <dminuoso> iphy: You can use lenient decoding, which might be more suitable to just bottoms lurking around
07:06:12 <iphy> it'll be decodeUtf8' before I commit this code
07:10:40 <merijn> iphy: It will hide errors yes, but at least predictably so ;)
07:16:35 <__monty__> merijn: What's the difference with setting the encoding on the handler though?
07:17:27 <merijn> __monty__: Ah, I missed the hSetEncoding, there's also a global one
07:37:03 <boxscape> calling hSetEncoding is something one could more easily forget, if I'm understanding everything correctly. Decoding from bytestring forces you to do it explicitly.
07:38:54 * hackage language-ats 1.7.9.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.9.0 (vmchale)
07:47:15 <sm[m]> morning all.. any thoughts on how to get around Shake's one-task-at-a-time lock ?
07:47:32 <merijn> sm[m]: That...sounds unlike Shake?
07:48:42 <merijn> sm[m]: Are you sure that's actually what's happening?
07:49:21 <sm[m]> merijn: pretty sure you can't invoke shake twice in the same directory, or at least they won't run concurrently
07:49:33 <merijn> sm[m]: oh, is that what you mean
07:49:43 <merijn> That sounds like a bad idea
07:50:45 <sm[m]> I'd like to use shake for general script management, like I currently do with make, but this seems to block that
07:50:57 <merijn> sm[m]: Unless you can guarantee both invocations won't touch the same things (which doesn't seem general) things are likely to break
07:51:02 <sm[m]> eg I have a long-running script showing a time dashboard
07:51:51 <sm[m]> or I'd like to make a release script that calls existing shake scripts in sequence
07:52:00 <sm[m]> it would be nice to be able to go all in on one scripting environment
07:52:26 <merijn> sm[m]: Wouldn't it be better to figure out a way to make each independent thing a target, then invoke shake with all relevant targets?
07:52:53 <sm[m]> for the release script ? That seems.. hard
07:53:12 <__monty__> For the release script that sounds like exactly what you'd want to do.
07:53:17 <merijn> sm[m]: I mean, either there's no dependencies across invocations or there are and then it won't work anyway
07:53:23 <sm[m]> I'm imagining a lengthy complex manually assisted sequence of steps
07:53:47 <__monty__> All your various build artifacts should already be rules. The release target would just invoke a couple of those and package up the artifacts.
07:54:09 <sm[m]> I think it's not that simple __monty__ , but we'll see
07:54:16 <merijn> sm[m]: I mean, the reason why you normally don't want multiple invocations at the same time is because then they might trigger each other into rebuild loops if th dependencies aren't disjoint
07:54:49 <merijn> sm[m]: And proving the dependencies disjoint "in general" seems hard. But if they are, then you can simply have each of those as independent target and one invocation can run them in parallel
07:55:42 <merijn> sm[m]: And sequences of steps sounds like "can't run in multiple parallel invocations anyway"
07:56:38 <__monty__> sm[m]: Is what you're talking about with the scripts a bit like having a "localdb" target and a "daemonX" target and then running `shake localdb` for projects that need a db and `shake daemonX` for other projects, which may intersect, maybe having a `shake one-off` for todo management or whatever?
07:57:13 <merijn> __monty__: SQLite backed shake :>
07:58:39 <sm[m]> sorry, didn't understand that
07:59:12 <sm[m]> trying to squeeze my release process into a single giant shake task - with pause and continue for manual steps - seems risky and more work than using bash scripts. But I'll explore it some more. I'd still like to be able to use shake without this restriction, as I would make
07:59:56 <merijn> sm[m]: You could also have multiple shake tasks called by an external script in sequence
08:00:05 <__monty__> sm[m]: Do you have examples of manual steps?
08:00:19 <sm[m]> merijn: not in the same directory
08:00:45 <sm[m]> oh in sequence. yes. But I was hoping to use shake for that too.
08:01:09 <sm[m]> if I still need make or bash, then it's the status quo
08:01:10 <__monty__> That was in response to your comment that a bash script would be easier.
08:01:19 <merijn> sm[m]: Right, but since they're steps, there's presumably dependencies, and therefore no sensible way to run in parallel
08:05:34 <sm[m]> __monty__: manual steps: things that aren't cost effective to automate or aren't automated yet. Preparing release notes, uploading to hackage, announcing, updating homebrew, updating platform install instructions, sort of thing
08:08:20 <__monty__> sm[m]: You could have a release target depend on and update a plaintext todo list?
08:08:36 <sm[m]> and human review/approval generally, of things not yet trusted
08:09:06 <__monty__> Each time you evaluate the target it'd check off whatever the next step is. That way you don't have to remember how far you got yesterday.
08:28:54 * hackage prosidy 1.6.0.0 - A simple language for writing documents.  https://hackage.haskell.org/package/prosidy-1.6.0.0 (jafc)
08:40:03 <redon89> i know it is possible with pandoc, but i don't know how
08:41:17 <__monty__> redon89: Seems a bit non sequitur?
08:46:14 <geekosaur> we seem to have lost something somewhere along the way…
08:59:14 <sm[m]> automate my release process with pandoc ? hmmm
08:59:24 * hackage indexed-containers 0.1.0.2 - Simple, no-frills indexed lists.  https://hackage.haskell.org/package/indexed-containers-0.1.0.2 (zliu41)
09:00:53 <sm[m]> I wouldn't put it past pandoc
09:25:32 <dminuoso> xpected type: Getting (First Text) Attribute Text, Actual type: (ByteString -> Const (First Text) ByteString) -> Attribute -> Const (First Text) Attribute
09:26:02 <dminuoso> What kind of lens accident did I get in here?
09:27:25 <Taneb> You passed in a Fold ByteString Attribute, to something that was expecting a Fold Attribute Text, it looks like?
09:28:28 <dminuoso> Oh.. this type synonym expension on just one side threw me completely off.
09:29:23 <dminuoso> Taneb: I think it was rather `Fold Attribute ByteString` when it should have been `Fold Attribute Text`
09:29:45 <Taneb> Yeah, you're right
09:31:08 <dminuoso> Perhaps this is a good moment to plan switching to optics.
09:52:54 * hackage pandora 0.2.2 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.2 (iokasimovmt)
10:03:08 <nisstyre> does ghcup not support aarch64 ?
10:03:24 <nisstyre> it says it cannot figure out the architecture
10:03:32 <nisstyre> my understanding is that ghc supports this architecture
10:04:07 <davean> GHC does support it
10:04:09 <tabaqui1> wow, this line is acceptable "foo :: con1 => con2 => someType"
10:04:25 <davean> tabaqui1: how would it not be?
10:04:28 <nisstyre> davean: yeah so it looks like it's just that ghcup doesn't support it
10:04:35 <nisstyre> so I'll have to compile it myself
10:04:42 <davean> nisstyre: no, you can grab a compiled version
10:04:48 <davean> ghcup is far from the only way to get GHC
10:04:51 <nisstyre> ok cool
10:04:56 <nisstyre> yeah I know
10:04:59 <davean> infact, I've ever even seen ghcup
10:05:17 <nisstyre> davean: I started using it recently because distro versions of GHC kept giving me issues
10:05:29 <tabaqui1> davean: I just get enlightment :)
10:05:38 <davean> tabaqui1: good :)
10:05:40 <tabaqui1> => is just a regular type operator
10:05:46 <davean> tabaqui1: yep
10:05:55 <tabaqui1> it is "con1 => (con2 => someType)"
10:06:31 <nisstyre> davean: I'm trying to get it running on a pinebook pro
10:06:45 <nisstyre> looks like my options are to find a prebuilt binary or build it myself
10:07:05 <davean> nisstyre: https://www.haskell.org/ghc/download_ghc_8_8_3.html ahs the prebuilts
10:07:19 <nisstyre> great, thanks
10:07:24 <sm[m]> nisstyre: how about trying stack ?
10:07:37 <nisstyre> sm[m]: would that work without a ghc to bootstrap it?
10:07:40 <sm[m]> or manually downloading their ghc: https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2
10:08:20 <sm[m]> wait.. that's a stack binary. Well, if they provide that for aarch64 maybe it'll also fetch the ghc
10:08:26 <davean> that will lag behind the actual GHC releases
10:08:46 <davean> sm[m]: why would you do trhat over grabbing the actual releases?
10:09:15 <sm[m]> I thought it might be easier
10:10:11 <nisstyre> looks like I'm gonna have to extract the debian version and then use that
10:10:37 <davean> nisstyre: "debian" version just basicly says what library versions it expects - it has nothing to do with Debian other than being built on Debian.
10:13:25 <davean> nisstyre: you'll have a hell of a time building your own GHC if you don't start with one.
10:15:24 * hackage alarmclock 0.7.0.4 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.7.0.4 (dten)
10:16:31 <sm[m]> (more specifically, I thought there was a chance fpcomplete could be providing builds for more platforms than GHC devs have time to maintain. Seems not the case, so never mind!)
10:17:19 <davean> sm[m]: I wish
10:17:38 <davean> sm[m]: Basicly if GHC isn't maintaining them they don't exist because they won't work
10:17:44 <davean> its why GHC runs so many and so varied builders
10:17:58 <davean> I would like to say that page doesn't have *all* the builds though
10:18:15 <davean> GHC builds for POWER also for example
10:19:13 <davean> YOu'd have to pull those off the nightlys though
10:19:46 <sm[m]> yes and I think I've heard of GHC on some the embedded/hobby systems too
10:20:12 <sm[m]> or maybe those are not different
10:20:24 <nisstyre> davean: yep I'm pulling the prebuilt package down right now
10:20:30 <nisstyre> that should be enough to get me going
10:20:42 <davean> nisstyre: if you need something really weird, https://gitlab.haskell.org/ghc/ghc/-/jobs
10:21:08 <nisstyre> nice
10:23:24 * hackage bank-holidays-england 0.2.0.4 - Calculation of bank holidays in England and Wales  https://hackage.haskell.org/package/bank-holidays-england-0.2.0.4 (dten)
11:00:21 <nisstyre> davean: got it working, had to install a few dependencies (ncurses) but it worked great, thanks
11:01:33 <davean> nisstyre: no problem, we work hard to make sure GHC runs everywhere people care to have it run!
11:01:56 <davean> nisstyre: you can thank packet.net for helping us have as much ARM build power as we do too to shake out the bugs quickly :)
11:02:05 <nisstyre> I will :)
11:40:15 * sm[m] also forgot davean is an actual GHC dev :)
11:41:12 <ChaiTRex> Is there a type system that can give types to all expressions in an untyped lambda calculus?
11:41:54 <merijn> ChaiTRex: Yes
11:42:18 <ChaiTRex> merijn: What are some examples?
11:42:21 <merijn> ChaiTRex: I mean, trivially if you define a type system with one type which is the type of "any expression in the untyped lambda calculus" you're done
11:42:32 <merijn> I mean, it's not particularly *useful*
11:42:46 <ChaiTRex> merijn: Are there any useful examples? :)
11:43:42 <merijn> Probably, but then things quickly become tricky ;)
11:46:38 <mniip> such a type system is necessarily inconsistent
11:47:11 <ChaiTRex> mniip: Why?
11:47:27 <mniip> bottom inhabits everything
11:49:39 <ChaiTRex> mniip: Why does that make such a type system inconsistent?
11:49:52 <mniip> because you can prove P and not P
11:59:21 <Cale> ChaiTRex, mniip: Of course, anything which can do general recursion will be inconsistent, so that's not necessarily a big deal.
11:59:39 <Cale> :t fix
11:59:41 <lambdabot> (a -> a) -> a
11:59:45 <Cale> :t fix id
11:59:47 <lambdabot> a
11:59:53 <Cale> ^^ "proof of anything"
12:00:51 <Cale> If you can typecheck anything in the lambda calculus, then you can handle the Y combinator, which is a means of implementing fix.
12:01:05 <solonarv> here's a bottom in UTLC: (\x. x x) (\x. x x) -- this is basically 'fix id'
12:01:39 <ski> ("inconsistent" in a logical sense. but that doesn't necessarily mean one can pretend a value has a type it actually doesn't have)
12:03:13 <Cale> :t InR
12:03:15 <lambdabot> (Rec a -> a) -> Rec a
12:03:16 <Cale> :t outR
12:03:18 <lambdabot> Rec a -> Rec a -> a
12:04:46 <Cale> @let y f = (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
12:04:49 <lambdabot>  Simplifier ticks exhausted
12:04:49 <lambdabot>    When trying UnfoldingDone x_stln
12:04:49 <lambdabot>    To increase the limit, use -fsimpl-tick-factor=N (default 100).
12:04:54 <Cale> hah
12:05:07 <Cale> Thwarted by the simplifier
12:06:53 <Cale> @let y :: (a -> a) -> a; {-# NOINLINE y #-}; y f = (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
12:06:56 <lambdabot>  Simplifier ticks exhausted
12:06:56 <lambdabot>    When trying UnfoldingDone x_stlr
12:06:56 <lambdabot>    To increase the limit, use -fsimpl-tick-factor=N (default 100).
12:07:04 <Cale> still doesn't like it, haha
12:07:17 <Cale> I guess the thing being inlined isn't y itself of course
12:07:54 * hackage github-rest 1.0.2 - Query the GitHub REST API programmatically  https://hackage.haskell.org/package/github-rest-1.0.2 (leapyear)
12:09:27 <dmwit> Hm. Suppose I have two type formers, X, and if t1 and t2 are types then t1 -> t2 is a type.
12:09:55 <dmwit> I allow myself to "expand" an X into an X -> X any time I like.
12:10:12 <dmwit> Are there any two types which are fundamentally incompatible, that is, for which there is no other type to which they can both be expanded?
12:11:20 <dmwit> I think no. So I suspect it wouldn't be too hard to make an HM-like type inference engine for UTLC whose types were of that form.
12:11:48 <dmwit> The typing judgment wouldn't tell you super much, but then maybe it's hard for any type system which can actually type all terms to tell you super much.
12:12:43 <dmwit> I'd bet you even get to prove a principal types theorem.
12:14:53 * hackage Chart-fltkhs 0.1.0.6 - A backend for the Chart library for FLTKHS  https://hackage.haskell.org/package/Chart-fltkhs-0.1.0.6 (empowerg)
12:14:59 <MarcelineVQ> if you can expand an​ X into X -> X any time you like can you also collapse an X -> X to X any time you like?
12:15:19 <Tuplanolla> Are you secretly wishing to track arities, dmwit?
12:16:54 * hackage minimorph 0.2.2.0 - English spelling functions with an emphasis on simplicity.  https://hackage.haskell.org/package/minimorph-0.2.2.0 (MikolajKonarski)
12:21:45 <oats> anybody have hie working with vim-ale right now with recent ghc versions?
12:21:58 <oats> and I did rebuild hie
12:32:54 * hackage either-list-functions 0.0.4.0 - Functions involving lists of Either  https://hackage.haskell.org/package/either-list-functions-0.0.4.0 (chris_martin)
12:43:24 * hackage miniutter 0.5.1.0 - Simple English clause creation from arbitrary words  https://hackage.haskell.org/package/miniutter-0.5.1.0 (MikolajKonarski)
12:57:24 * hackage either-list-functions 0.0.4.2 - Functions involving lists of Either  https://hackage.haskell.org/package/either-list-functions-0.0.4.2 (chris_martin)
13:04:32 <maerwald> is there any other library than cryptonite (preferably something using ffi) that allows incremental md5 hashing?
13:18:04 <Cale> maerwald: hopenssl?
13:19:36 <maerwald> that could work
13:20:11 <Cale> I think it might just be mildly annoying to use incrementally -- looks like it could use a better interface for that
13:20:20 <maerwald> I was looking at HsOpenSSL and couldn't find it
13:20:33 <maerwald> Cale: afais it can already use lazy bytestring
13:21:08 <maerwald> Digestable class has a LazyByteString instance
13:21:12 <Cale> ah, yes, if that does the trick, good enough :)
13:21:40 <maerwald> All those streaming libraries and in the end lazy BS is enough lol
13:22:02 <Cale> The OG streaming library
13:22:08 <Cale> haha
13:22:10 <MarcelineVQ> why does digestByName exist? :X
13:22:45 <maerwald> It is a little weird
13:22:49 <Cale> I guess because of the point about algorithms offered differing by platform.
13:23:14 <koz_> maerwald: I giggled at 'lazy BS'.
13:23:22 <Cale> It's exposing something from the underlying openssl library
13:23:36 <maerwald> Shouldn't that be CPPed=
13:24:10 <Cale> One would expect so, but maybe it's doing some weird dynamic linking or something
13:26:18 <dminuoso> Does someone have a rough number on how long a full hackage mirror takes? Right now it appears to be taking 72 hours, that seems fairly extreme.
13:26:30 <Cale> ummm
13:27:46 <Cale> dminuoso: I don't, but git cloning this won't take that long (if it's actually good enough for your purposes). https://code.xkrd.net/skete/hackage-packages
13:28:14 <dminuoso> Cale: Mmm, can I regain trust with this?
13:28:51 <Cale> If you're actually maintaining a real hackage mirror, probably ignore me :)
13:29:37 <oats> is ghcide intended to deprecate hie?
13:30:58 <dminuoso> oats: ghcide is hie-core
13:31:07 <dminuoso> It's just a new name
13:32:00 <oats> hmm, so does anyone have a vim/neovim setup that they're satisfied with lol?
13:32:31 <maerwald> oats: no
13:32:36 <oats> heh
13:32:45 <oats> I'm getting tired of juggling coc and ale trying to figure out what parts of which I want to use
13:33:10 <maerwald> I trashed coc when it kept spawning hie instances until memory exhaustion and I couldn't even stop it.
13:33:25 <oats> oof
13:33:55 <oats> I haven't experienced that yet fortunately
13:34:24 <maerwald> Their process handling code is just broken
13:34:56 <oats> I feel like code completion is maybe a bit less useful in haskell
13:35:08 <oats> but having a popup window with type info / errors would be nice
13:35:12 <maerwald> LanguageClient-neovim doesn't do such funky stuff, but it has less features and it's warning signs etc keep appearing and disappearing randomly
13:35:37 <maerwald> I don't understand how anything works at all with LSP.
13:44:58 <koz_> Yeah... my HIE + vim or Neovim experience has been super-mixed.
13:45:01 <koz_> And not in a good way.
14:17:53 <Ethan> has anyone had good expirences with haskell ides?
14:19:35 <Uniaika> I'm using neovim, which prevents me from having bad experiences with haskell IDEs
14:20:24 * hackage math-extras 0.1.0.0 - A variety of mathematical utilities  https://hackage.haskell.org/package/math-extras-0.1.0.0 (zliu41)
14:21:10 <maerwald> Except neovim doesn't have proper GUIs (yet)
14:21:24 * hackage dependent-hashmap 0.1.0.1 - Dependent hash maps  https://hackage.haskell.org/package/dependent-hashmap-0.1.0.1 (OlleFredriksson)
14:21:34 <maerwald> And most of the problems are not due to vim vs neovim.
14:23:42 <ChaiTRex> This might be a Neovim GUI: https://github.com/Kethku/neovide
14:23:54 * hackage lean-peano 1.0.0.0 - A maximally lazy, simple implementation of the Peano numbers with minimal dependencies  https://hackage.haskell.org/package/lean-peano-1.0.0.0 (oisdk)
14:24:19 <maerwald> without a scrollbar
14:25:00 <maerwald> I've been working on scrollbar implementation on neovim-gtk, it isn't easy and there was API missing from neovim to do it
14:27:10 <maerwald> https://github.com/neovim/neovim/pull/11748
14:27:48 <maerwald> Nothing that can compare to gvim.
14:28:07 <maerwald> And smooth scrolling is even harder
14:28:21 <maerwald> Without blocking the ui
14:28:45 <maerwald> the server-client architecture of neovim has drawbacks too
14:31:54 * hackage gitlab-haskell 0.1.6 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.6 (RobStewart)
14:35:54 * hackage dhall-fly 0.3.0 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.3.0 (axeman)
14:58:23 * hackage hnix 0.7.0 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.7.0 (JohnWiegley)
15:05:56 <DigitalKiwi> Uniaika: same but doom-emacs
15:26:37 <Uniaika> DigitalKiwi: is that so?
15:28:28 <DigitalKiwi> i like it
15:42:24 <DigitalKiwi> https://mostlyabsurd.com/files/resistance/src/Main.hs how can I make it so I can reuse the names for color Band? Instead of typing Resistor4 DRed DRed MBlack TSilver etc. I want to type Resistor4 Red Red Black Silver
15:44:46 <jle`> hm, you can make 'red', 'black', 'silver'
15:44:54 <ChaiTRex> DigitalKiwi: Put Red as a constructor for a digit type, same with Black as a constructor for a multiplier type.
15:46:13 <ChaiTRex> DigitalKiwi: Hmm, that wouldn't work.
15:47:15 <wildtrees> newtype wrapping maybe? 
15:48:07 <DigitalKiwi> -- class AsBlack a where _Black :: Prism' a ()
15:48:07 <DigitalKiwi> -- instance AsBlack Color where
15:48:10 <ChaiTRex> DigitalKiwi: Couldn't you just have a Color type and a product type that has the resistance and the tolerance?
15:48:30 <DigitalKiwi> that was suggested by someone but i don't know what goes in the where and they haven't been around
15:48:31 <wildtrees> DigitalKiwi, down in encodeResistor there is a long chain of nested case expressions, I think you might be able to use a f <$> maybe1 <*> maybe2 <*> maybe3 ... pattern in it's place 
15:49:03 <jle`> DigitalKiwi: ah remember also if you have a Prism, you have an instant 'maker'
15:49:09 <jle`> > review _Nothing ()
15:49:12 <lambdabot>  Nothing
15:49:25 <jle`> that's polymorphic for all instances of whatever your typeclass came from
15:49:58 <DigitalKiwi> wildtrees: the commented ones?
15:50:13 <DigitalKiwi> i'm not good at prism :(
15:51:02 <DigitalKiwi> i replaced that with the do
15:54:08 <jle`> i wonder if there's an alias for (`review` ())
15:54:45 <glguy> :t (#())
15:54:46 <lambdabot> error: parse error on input ‘)’
15:54:57 <glguy> :t ( #())
15:54:59 <lambdabot> AReview t () -> t
15:55:08 <glguy> the savings!
15:55:34 <wildtrees> DigitalKiwi, oops yea commented out, sorry 
15:55:40 <glguy> > _Nothing#()
15:55:46 <lambdabot>  mueval-core: Time limit exceeded
15:55:54 <jle`> whoops
15:56:19 <jle`> hm, in any case (pun?), this sort of "prism into ()" is a common pattern I think
15:57:06 <DigitalKiwi> what do i put in the where? what function(s) do i need? idk what _Black means ... i don't get it at all really
15:58:11 <jle`> DigitalKiwi: 'Black' is a constructor in the syntactical sense. it can be used to match and create values
15:58:18 <jle`> _Black is like a value that represents that constructor
15:58:37 <jle`> and you can 'use' it using the various prism combinators
16:01:51 <jle`> using it as a value, `review _Black ()` is the same as `Black`
16:02:20 <jle`> only, it's polymorphic for all instances of AsBlack
16:02:32 <Guest9874> Hey. What's the reation between logic/relational programminh anos the expression problem?
16:02:37 <jle`> so if a value is an instance of AsBlack, then `review _Black ()` will give the 'black' equivalent for that instance
16:03:05 <jle`> DigitalKiwi: regarding the 'pattern' powers of the Black constructor, you have things like has _Black :: AsBlack c => c -> Bool
16:03:17 <jle`> that can test whether or not any AsBlack insance matches with Black
16:03:30 <Guest9874> programming* and* e.g Prolog, minikanren, guanxi
16:04:53 <DigitalKiwi> so do I do instance AsBlack Digit where, instance AsBlack Tolerance where, instance AsBlack Multiplier where, etc.
16:06:29 <jle`> yeah, you can do that. and then do 'black :: AsBlack c => c; black = review _Black ()`
16:06:40 <jle`> then you can use 'black' polymorphically to be any AsBlack instance
16:07:30 <DigitalKiwi> and then instead of Resistor4 DBlack DBlack ... it's Resistor4 black black ?
16:09:20 <jle`> yeah
16:10:12 <DigitalKiwi> and then in the instance AsBlack Digit where i put...isBlack = True or something? and AsSilver Digit would have isSilver = False?
16:13:07 <DigitalKiwi> no that's not right
16:13:07 <jle`> hm, what methods are in AsBlack ?
16:13:13 <jle`> try checking in ghci
16:13:14 <jle`> with :i
16:13:43 <DigitalKiwi> _Black
16:15:33 <jle`> DigitalKiwi: so for Digit, _Black = _DBlack
16:15:53 <jle`> it's the DBlack constructor, so give the prism corresponding to that constructor
16:16:12 <DigitalKiwi> ah, right
16:17:01 <jle`> and if you want is isBlack, you can say `isBlack :: AsBlack c => c -> Bool; isBlack = has _Black`
16:17:07 <jle`> *want an
16:20:43 <DigitalKiwi> oh and I have to makePrisms ''Digit it looks like to get _DBlack
16:20:54 * hackage min-max-pqueue 0.1.0.1 - Double-ended priority queues.  https://hackage.haskell.org/package/min-max-pqueue-0.1.0.1 (zliu41)
16:22:24 <jle`> DigitalKiwi: ah, yeah
16:24:31 <DigitalKiwi> ty btw i think i get it now
16:24:35 <DigitalKiwi> at least a lot better
16:25:15 <jle`> DigitalKiwi: np :) this sort of stuff here demonstrates what the utility of a 'first class' constructor would be
16:25:24 * hackage linear-tests 0.1.1.0 - Linear Algebra  https://hackage.haskell.org/package/linear-tests-0.1.1.0 (pdlla)
16:25:26 <jle`> in haskell constructors are a purely syntactic construct. they aren't truly first-class
16:25:55 <jle`> prisms distill the idea of a constructor into just a normal value, so you can do things like _Black = _DBlack
16:25:59 <jle`> one value is just the same as another value
16:48:08 <DigitalKiwi> this is a lot of typing
16:48:09 <dsal> What's today's "I want to make a quick web server for a few static files and a dynamic handler that spits out JSON" tool?
16:50:33 <MarcelineVQ> dsal: probably scotty and a file serving wai middleware like wai-middleware-static
16:50:48 <dsal> I've not tried scotty.  I've used warp a couple times, but not enough to have much of an opinion.
16:57:09 <MarcelineVQ> depending what all you're doing it's just a few lines, I've got one that serves a partiuclar dir and the meat is just   scotty (port conf) $ do \n middleware $ staticPolicy (noDots >-> addBase path')  \n get "/" $ do <stuff you want to happen at the '/' route>
17:00:29 <MarcelineVQ> where that get serves the html page listing the files
17:04:36 <DigitalKiwi> jle`: nice! it worked the first time i tried it :D
17:05:33 <jle`> :D
17:07:44 <DigitalKiwi> i updated the file
17:07:52 <DigitalKiwi> did i organize it right
17:10:08 <jle`> looks good :) but admittedly it's a little verbose
17:10:15 <jle`> because of having to define all those separate combinators
17:10:38 <jle`> it might be just cleaner to define something like mk = (`review` ()) and `mk _Black`
17:10:52 <jle`> and defining isX might just be clenaer as has X
17:11:03 <jle`> but it's just style stuff at this point :)
17:11:56 <dsal> MarcelineVQ: I want to see if I can get it to hold onto my reader, but once I figure out basics, this seems fine.  Thanks.
17:12:20 <DigitalKiwi> does it even need isX like i don't use it does it add anything heh
17:35:42 <dsal> MarcelineVQ: I don't see index.html as an obvious thing.  Is there a way to get / to do that?
17:37:42 <dsal> I guess I can just make / serve static/index.html
17:38:55 <dsal> That'll do for now.  This isn't remotely the most interesting thing I'm trying to do.  heh
17:39:02 <MarcelineVQ> I ​generated mine so I'm not sure, but I'd probably try to read index.html as a file as give it to  https://hackage.haskell.org/package/scotty-0.11.5/docs/Web-Scotty.html#v:html
17:39:12 <MarcelineVQ> *and give it to
17:39:23 <dsal> I'm using 'file
17:39:24 <dsal> '
17:39:43 <dsal> Doesn't matter much.  You got me to the part where I can do something interesting... Just as my train arrives.  Thanks!
17:39:52 <MarcelineVQ> that's probably fine since it sets the mime to 'text/html'
17:40:05 <MarcelineVQ> oh wait no, it doesn't
17:40:38 <MarcelineVQ> you'll want the content type to be text/html when serving html file
17:41:26 <MarcelineVQ> otherwise some browsersa will try to download index.html instead of displaying it
17:41:44 <MarcelineVQ> will/can
18:02:06 <dsal> MarcelineVQ: thanks. That's dumb. Heh
19:26:47 <dsal> MarcelineVQ: I've got a `ScottyT LT.Text EnvM ()` trying to set up my application?  Is there a way to get access to the environment here?  I can access it from within my handlers, but I want my args to know where static is.
19:28:23 * dsal hard codes and gets on with life
20:10:12 <MarcelineVQ> is EnvM your environment?
20:13:24 * hackage hspec-hedgehog 0.0.1.0 - Integrate Hedgehog and Hspec!  https://hackage.haskell.org/package/hspec-hedgehog-0.0.1.0 (parsonsmatt)
20:20:35 <MarcelineVQ> iiuc if you make a ReaderT over ScottyM you could use  ask  to work with your enviorment anywhere you like. as in ReaderT envtype ScottyM ()
20:31:18 <iqubic> That sounds good.
20:38:24 * hackage bitwise-enum 1.0.0 - Bitwise operations on bounded enumerations  https://hackage.haskell.org/package/bitwise-enum-1.0.0 (jnbooth)
20:46:00 <MarcelineVQ> dsal: e.g. https://gist.github.com/MarcelineVQ/ffa85dca9b972321087f90ff0e243701
20:47:21 <dsal> I'm using ScottyT.  The Reader example has an EnvM type to access Env.
20:48:27 <MarcelineVQ> example?
20:54:19 <MarcelineVQ> I'm not really sure how to invert it to have Reader inside ScottyT, mostly due to how ActionT intertwines with ScottyT
20:58:00 <MarcelineVQ> is this the example you mean? https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs
20:59:03 <MarcelineVQ> it is more ergonomic than lifting everthing due to Reader being on the outside
21:01:06 <MarcelineVQ> not that you don't lift, just that you're not having to lift all scotty stuff
21:36:54 <mjrosenb> I'm having some issues with cabal-install that have me kind of stumped.
21:37:28 <mjrosenb> namely, ghc-pkg list shows that I have dependencies installed, but cabal configure --ghcjs wants to install them.
21:38:05 <mjrosenb> how can I figure out why cabal-install doesn't believe these packages are installed?
21:38:06 <sclv> is this cabal 3?
21:38:39 <sclv> also are they installed as built for normal ghc or for ghcjs?
21:41:50 <mjrosenb> ghcjs, I'd assume
21:42:03 <mjrosenb> oh, they show up in the output of ghcjs-pkg list, not ghc-pkg list
21:42:24 * hackage http-download 0.2.0.0 - Verified downloads with retries  https://hackage.haskell.org/package/http-download-0.2.0.0 (MichaelSnoyman)
21:42:32 <mjrosenb> and I saw the behavior with cabal-install 2 and now again with cabal-install 3
21:43:07 <mjrosenb> (if it helps at all, this is inside of a nix-shell.
21:43:20 <sclv> Maybe you should use v1-configure?
21:44:13 <sclv> also you can run cabal with verbose
21:45:54 * hackage rrule 0.1.0.0 - Recurrence rule parser and formatter  https://hackage.haskell.org/package/rrule-0.1.0.0 (MitchellVitez)
21:47:24 * hackage math-extras 0.1.0.1 - A variety of mathematical utilities  https://hackage.haskell.org/package/math-extras-0.1.0.1 (zliu41)
21:47:49 <mjrosenb> looks like inside of the environment, I'm getting cabal-2.4.1
21:49:13 <mjrosenb> oh, and it also looks like something I tweaked earlier has caused it to give a better error message, even without --verbose
21:58:24 * hackage math-extras 0.1.1.0 - A variety of mathematical utilities  https://hackage.haskell.org/package/math-extras-0.1.1.0 (zliu41)
22:01:03 <mjrosenb> so it looks like the issue is that packages are trying to pull in two different versions of aeson
22:02:15 <mjrosenb> https://gist.github.com/mjrosenb/8f6e2a4419eb75e299be27261c4c55db
22:02:51 <mjrosenb> but as far as I can tell, all of the things that say they depend on 1.4.2 don't actually have an explicit dependence on that version
22:09:04 <mjrosenb> and it pulled in two versions of bifunctors-5.5.4
22:25:54 * hackage ghc-check 0.1.0.2 - detect mismatches between compile-time and run-time versions of the ghc api  https://hackage.haskell.org/package/ghc-check-0.1.0.2 (PepeIborra)
23:50:00 <jlamothe> I'm an idiot.  I spent way too long trying to figure out why my yesod app's tests were failing on one of my bodyContains checks.  Turns out it was because an apostrophe was being sanitized.
