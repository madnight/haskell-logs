00:20:44 <cdan> hello all
00:23:00 <ski> hello cdan
00:25:24 <cdan> what is the best place to get help on Persist/Esquelleto and reading data from an SQL VIEW ?
00:25:54 * hackage configurator-pg 0.1.0.4 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.4 (vollmert)
00:26:04 <cdan> So far I have failed because there is no ID column on a view and Persist entities expect an ID
00:28:58 * ski doesn't know about that, sorry
00:31:39 <sm[m]> cdan: the yesod book ?
00:35:08 <cdan> I've tried yesod book, nothing there
00:35:42 <cdan> I could revert to raw SQL but I would like not to
00:39:03 <sm[m]> https://github.com/yesodweb/yesod-cookbook/blob/master/cookbook/Database-Views-and-Non-Migrated-Entities.md any use ?
00:43:55 <sm[m]> if all else fails.. make another view that adds an id column ?
00:44:33 <cdan> sm[m]: sorry for the confusion. Actually my problem is that I do not have a unique identifier on my view and persist expects all entities to have an identifier
00:46:51 <sm[m]> does it ? I might not be understanding, but.. can the id=dbcolumnname trick help ?
00:47:21 <sm[m]> is there a part of the book which says this ?
00:48:23 <cdan> sm[m]: grat, you have just triggered a second thought. I was actually stupid
00:48:55 <cdan> my view definition looks something like CREATE VIEW .... SELECT ... FROM .... WHERE ...GROUP BY glider, localdate, org;
00:49:15 <cdan> which means I can use a composite key (glider, localdate, org) which will be unique
00:49:26 <cdan> great
00:50:18 <sm[m]> https://www.yesodweb.com/book/persistent#persistent_fetching_by_unique_constraint or https://www.yesodweb.com/book/persistent#persistent_uniqueness sort of thing ? good
00:50:38 <sm[m]> I am trying to get back into persistent myself. It's a tricky beast
00:52:32 <cdan> ha ha ha, it is always good to talk to someone else, you imediatelly realize where you were wrong.
00:53:29 <sm[m]> indeed
01:12:30 <cdan> all works now, thx sm[m] 
01:13:46 * cdan going to sleep as he has to head to the field tomorrow morning. 
01:15:55 <sm[m]> night!
01:57:54 * hackage profunctor-arrows 0.0.1 - Profunctor arrows  https://hackage.haskell.org/package/profunctor-arrows-0.0.1 (cmk)
02:28:54 * hackage hw-balancedparens 0.3.0.5 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.3.0.5 (haskellworks)
02:51:45 <lhurttila> When I have a function snd_3t (a, b, c) = b, I want to use it to get the bs while going through fieldx ::  [(a,b,c)] of Typex, how do I do that with a lens? Something like tx ^.. snd_3t.traverse.fieldx
03:02:11 <jackdk> lhurttila: to turn a function `s -> a` into a `Getter s a`, you can use the function `to`. However, lens already provides `_1`, `_2`, `_3` etc for lenses into the fields of a tuple
03:04:36 <jackdk> lhurttila: I don't quite understand your placeholder names, but I think you want something like `tx ^.. traverse . _2 . whateverElse
03:05:50 <zincy__> I didn't know you were pattern matching on type variables when using type families.
03:05:52 <lhurttila> I've used makeLenses at Typex definition but fieldx of Typex is just [(a,b,c)]. So I thought lenses wouldn't work all the way down to the 3-tuples of fieldx
03:06:29 <jackdk> lhurttila: traverse will get you looking at every element of a list, then _2 will get you the b from the tuple. Do you have a pastebin snippet?
03:07:54 * hackage configurator-pg 0.1.0.5 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.5 (vollmert)
03:08:55 <lhurttila> jackdk no I don't. So you think tx ^.. traverse . _2 . fieldx could work? I'll try that
03:12:36 <zincy__> "Type families are a feature of some type systems that allow partial functions between types to be defined by pattern matching. This is in contrast to data type constructors, which define injective functions from all types of a particular kind to a new set of types, and type synonyms (a.k.a. typedef), which define functions from all types of a particular kind to another existing set of types using a single case."
03:13:21 <zincy__> Are functions comprising type families necessarily partial because they are parameterised  by kinds, not types
03:13:45 <jackdk> lhurtilla: https://www.irccloud.com/pastebin/sS9JmaaS/ComeOnAndSlam.hs
03:16:54 * hackage hakyll 4.13.2.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.2.0 (JasperVanDerJeugt)
03:19:08 <jackdk> zincy__: Type families are not necessarily partial, but they can be if you don't provide complete patterns https://www.irccloud.com/pastebin/46TOtAug/TypeFamily.hs
03:19:31 <lhurttila> jackdk thanks for that example. It works but my code still doesn't so must have something else out of place as well. In any case that gets me forward
03:20:04 <jackdk> which is fine, because it often doesn't make sense to define a type family for every possible type of some kind
03:20:08 <jackdk> lhurttila: you're welcome
03:24:37 <zincy__> jackdk: Thanks
03:25:12 <zincy__> So yeah there isn't anything stopping you supplying every possible type for a given kind and this would be easy for say 'Bool
03:25:42 <zincy__> On that note is DataKinds purely for convenience? 
03:26:11 <zincy__> I guess that hinges on whether you can create your own kinds without the extension?
03:31:40 <jackdk> If you did that your type family would have kind Bool -> SomethingElse
03:31:53 <jackdk> what do you mean "purely for convenience"?
03:40:18 <zincy__> Is there a way of creating a 'Bool kind without DataKinds enabled?
03:40:40 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/efccdf1325e41ca30df72e5c340f264d/pasted.txt
03:40:45 <zincy__> Because if there is, then I would call the extension one that is enabled for convenience not necessity
03:41:09 <jackdk> I don't believe so
03:41:41 <lhurttila> jackdk Would you mind taking a look at that? I modified your example a bit and the point is to sort the list according to distance from coord
03:42:54 <jackdk> lhurttila: parse error on input `where`
03:43:32 <lhurttila> the snd argument of distance is a list though it needs a single tuple so iI'll probably ned to do smoething about it as well
03:44:37 <jackdk> it is not clear to me what you are trying to achieve, and the paste you uploaded is not syntactically valid. Can you please try explaining again?
03:45:49 <lhurttila> I've been having lots of parse errors with where lately but haven't yet figured out what exactly I'm messing up
03:47:20 <lhurttila> point is to sort the 3-tuples in the bar field by distance (from smallest to biggest) by comparing them to coord  
03:47:29 <jackdk> ok
03:49:10 <lhurttila> And since I'll have to do those sorts for lots of Foos with long bars I though sortOn might be what I want
03:51:18 <jackdk> yeah this needs very little advanced lensing
03:51:29 <jackdk> lhurtilla: https://www.irccloud.com/pastebin/Zk5A2yvb/SortedFoo.hs
03:51:49 <jackdk> :t Data.List.sortOn
03:51:50 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
03:52:28 <jackdk> so we partially apply `distance` (with `foo ^. coord`)
03:53:08 <jackdk> and then we need to compose it with a function `(Int, (Int, Int), Bool) -> (Int, Int)` to make the types line up
03:53:15 <jackdk> % :t Control.Lens.view
03:53:15 <yahb> jackdk: MonadReader s m => Getting a s a -> m a
03:53:39 <jackdk> `view` is that function (it is an alias for `(^.)`)
03:53:54 <jackdk> % :t view _2
03:53:54 <yahb> jackdk: (MonadReader s m, Field2 s s b b) => m b
03:54:16 <fog> whats the most accepted way of writing a hetrogenous Sum type?
03:55:56 <lhurttila> jackdk Thanks. I'll have to read that explanation a few times but at least it works :)
04:03:58 <fog> what options do we have for representing hetrogenous Sum types?
04:04:44 <fog> is it something to do with Prism?
04:07:56 <fog> like, if we have _2, can we have _n aswell? and if so, what would it work over?
04:08:33 <fog> or is that just for Product types?
04:11:39 <fog> actually wait, if its a Sum type it will only have one of the possible fields/records containing a value. instead of  Product type where you would have to select which field you want, this would kind of return which n of _n was the lens directing thing used to access the value
04:11:52 <fog> whats that called, do we have something like that?
04:12:11 <kuribas> is there an alternative for (<|>) that works with Either?
04:12:45 <fog> kuribas: you mean like (++) for lists?
04:13:00 <kuribas> no, like <|> for Maybe
04:13:11 <kuribas> > Nothing <|> Just 3
04:13:13 <lambdabot>  Just 3
04:13:46 <fog> it would be polymorphic in a strange way though right? because of the type parameter lists that get (++) together
04:13:54 <kuribas> ah, maybe catchError
04:15:06 <fog> oh right, i thought you were making it into something that was like Either' [a,b] <|> Either' [c,d] = Either' [a,b,c,d]
04:15:22 <kuribas> that looks wrong
04:15:32 <kuribas> > Just [a, b] <|> Just [c, d]
04:15:35 <lambdabot>  Just [a,b]
04:15:38 <kuribas> > Just [a, b] <> Just [c, d]
04:15:40 <lambdabot>  Just [a,b,c,d]
04:15:55 <fog> % :kind Either a
04:15:55 <yahb> fog: ; <interactive>:1:8: error: Not in scope: type variable `a'
04:16:00 <fog> % :kind Either Int
04:16:00 <yahb> fog: Either Int :: Type -> Type
04:16:24 <ski> > Left "1" <|> Right 2
04:16:26 <lambdabot>  Right 2
04:16:59 <fog> :kind \xs -> Either' [a,b,c] <|> Either xs
04:17:28 <ski> ?
04:18:04 <kuribas> fog: you're confusing Alternative <|> with Monoid <> I guess
04:18:06 <fog> kind! \xs -> Either' [a,b,c] <|> Either' xs = Either' (a ': b ': c ': xs)
04:18:35 <fog> % :t \xs -> [1,2,3] <|> xs
04:18:35 <yahb> fog: Num a => [a] -> [a]
04:18:51 <fog> % [1,2,3] <|> [4,5]
04:18:51 <yahb> fog: [1,2,3,4,5]; it :: Num a => [a]
04:18:51 * ski has no idea what fog was after, with kinds there
04:19:25 <fog> the problem is its not really (<|>) because we need something which is polymorphic...
04:19:48 <fog> like, it can take and return different types, instead of it being a -> a -> a
04:20:13 <fog> because the Either' as the first 2nd and return types have different lengthed type list params
04:20:25 <fog> so are different types
04:20:48 <fog> maybe thats not polymorphic... idk
04:20:51 <ski> i duno understand why you want a type-level `(<|>)'
04:21:59 <fog> its not a type level (<|>), the only thing at type level is a type level (++) on the type list params of the 1st & 2nd args of this "polymorphic" (<|>)
04:22:47 <fog> i guess there are not many things other than Either' that this can act over
04:22:54 <ski> then what is this  Either'  thing ?
04:23:14 <fog> some kind of extensible Either?
04:23:17 <ski> and why were you asking about kind of it, if it wasn't supposed to be type-level ?
04:23:38 <ski> sounds like type-level, to me ..
04:23:46 <fog> well, its type requires type level computation, and that was the easiest way to describe what Either' should be like
04:25:12 <fog> i think i wrote it wrong but it was supposed to say something like "when you <|> together 2 Either' values, the type of the returned Either' has a type list param that is the concatination of the first two args type list params
04:25:22 <ski> oh
04:25:41 <ski> yea, that's not what you wrote
04:26:42 <fog> (<|>') :: Either' xs -> Either' ys -> Either' (xs ++ ys) 
04:27:03 <fog> thats what im after
04:28:24 <fog> well, thats a good way to describe how this "extensible Sum type" should work...
04:28:42 <fog> i guess it could have things like;
04:29:02 <jackdk> the thing you want may be called an "open union"
04:29:17 <ski> hm, some sort of "graded algebra" thing, maybe
04:29:32 <fog> :t either
04:29:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
04:31:08 <ski>   var :: Rec (MapRow (-> c) rho) -> Var rho -> c
04:32:07 <fog> either' :: MapList ((-> c) :: (* -> *)) (xs :: [*]) -> Either' xs -> c 
04:32:39 <fog> wow, so similar!
04:33:09 <fog> looks like Rec is the realistion of Either' then
04:33:15 <ski> no
04:33:27 <fog> oh, no, Var is
04:33:59 <ski> `Rec {x :: Int,y :: Bool}' would be a type of records, having one `x' field containing an `Int', and one `y' field containing a `Bool'
04:34:38 <ski> `Var {x :: Int,y :: Bool}' would be a type of variants, being either of the `x' alternative, wrapping an `Int', or the `y' alternative wrapping a `Bool'
04:35:40 <fog> whats with the curly braces? wouldnt it be better to take a list of types and symbols for the names?
04:36:03 <ski> `{x :: Int,y :: Bool}' is a row. basically an association of identifiers to types
04:36:14 <ski> a row is unordered
04:36:31 <fog> oh cool, I guess you could do that with reified constraints
04:36:51 <fog> but still, doesnt GHC fetch the first record faster?
04:37:10 <ski> note how `var' uses the same `row', to connect a record of "`case' branches" to corresponding variant alternative "constructors"
04:38:20 <fog> yeah, thats what i was thinking of for how either' would work above, i think its the same thing
04:38:45 <ski> except you had no record there
04:38:49 <fog> except it looks like you have a way to use these name symbols to make lenses into each field 
04:38:58 <fog> yeah
04:40:24 <fog> im not sure i like it though, i would want to be able to write type families over the type list of the name symbols zipped with the types of the values at each position
04:41:17 <fog> Zip (names :: [Symbol]) (types :: [*]) :: [(symbol,*)]
04:41:43 <fog> i dont know what to do with those curly braces, they are not a list that i can write type families over
04:42:25 <ski> it's pseudo-Haskell
04:42:33 <fog> ah ok
04:42:48 <ski> TREX in Hugs had rows, iirc
04:43:03 <fog> is this row polymorphism?
04:43:38 <fog> and how do i write Var as a datatype?
04:44:24 * hackage ghc-tags-plugin 0.1.2.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.2.0 (coot)
04:44:25 <ski> see <https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.2>
04:46:46 <fog> data (Length names ~ Length values) => Var names values where 
04:46:48 <fog>    SumCons :: Proxy name -> value -> Var names values -> Var (name ': names) (value ': values)
04:47:59 <fog> hmm, that wont work, that takes a value for each position like a HList
04:48:15 <fog> :t Left
04:48:17 <lambdabot> a -> Either a b
04:48:33 <fog> i guess this would need to lookup by symbol
04:50:32 <fog> VarConstructor :: Length names ~ Length types => Proxy (name :: symbol) -> Lookup symbol (Zip names types) -> Var names types
04:51:31 <fog> i dont know if you can use Zip as a type family in the types of a GADT though
04:57:05 <fog> this compiles; https://pastebin.com/raw/id5H5p6H
05:08:04 <fog> this does not; https://pastebin.com/raw/Tkrd33Hk
05:11:04 <fog> is there nothing like this from Vinyl>
05:12:18 <zincy__> So the identity function has a single type variable `a`. This parameter can be inhabited by any type. Is this an example of an existentially quantified type?
05:12:41 <fog> :t id
05:12:43 <lambdabot> a -> a
05:12:54 <fog> id :: forall a. a -> a
05:12:54 <TristahK> its universally quantified
05:12:54 <zincy__> Whereas fn x=>x+1 , x would not be existentially quantified as x cannot be inhabited by any type
05:13:13 <zincy__> Ok so I am confusing universal and existential
05:13:34 <zincy__> Does my set of statements hold for universal quantification?
05:13:47 <fog> its existential when it jumps through some parenthesis so the forall is not at the far left of the type
05:14:25 <zincy__> So universal quantification just means that a given type variable can be parameterised by any type?
05:14:44 <fog> so seems to be something to do with restriction of the scope of the forall
05:15:07 <fog> you just want the scope to be within the parens
05:15:59 <fog> zincy__: it means that the type variable does not need to brought into scope as a param to the type 
05:17:03 <fog> type X a = forall b. (something :: * -> * -> * ) a b 
05:17:14 <fog> see how the b is not where the a is
05:18:09 <fog> the b is brought into scope by the forall
05:19:06 <fog> but if you have like (forall a. (something :: * -> * -> * ) a (forall b. b))
05:19:43 <fog> then the forall that introduces b, does so only in the scope of those parens, so its existential, while the forall a is at the far left, so its universal
05:20:19 <fog> i think...
05:22:23 <fog> "unlike a universally quanitification type, the scope of an existentially quantified type is restricted" should define the notion 
05:22:32 <fog> quantified*
05:22:32 <zincy__> Cheers
05:22:50 <zincy__> I think I follow
05:23:22 <fog> the thing ski tries to explain is about how this relates to "exists", which i never really understand
05:23:36 <zincy__> So essentially you can nest forall. and this nesting gives you existential quantification
05:23:52 <zincy__> Yeah where is ski
05:24:09 <fog> the upside down A that is maths forall gets turned into a backwards E that is the maths exists, when it goes throught the parens to the right
05:24:29 <fog> idk why
05:25:03 <fog> something like the difference between, "any type will do" and "as long as there is a type that will do"
05:25:07 <zincy__> So quantification refers to the kinds of parameterisations which take place within type variables I guess
05:25:16 <ski> zincy__ : "So the identity function has a single type variable `a`. This parameter can be inhabited by any type. Is this an example of an existentially quantified type?" -- no
05:25:37 <ski> <fog> "unlike a universally quantified type, the scope of an existentially quantified type is restricted" should define the notion
05:25:40 <ski> no
05:25:54 <ski> "So essentially you can nest forall. and this nesting gives you existential quantification" -- no
05:26:04 <fog> then whats with the thing where it goes throught the parens if its not simply scope restriction?
05:26:25 * ski feels like denying things
05:26:33 <ski> "the upside down A that is maths forall gets turned into a backwards E that is the maths exists, when it goes throught the parens to the right" -- to the left
05:27:04 <ski> because `->' is contravariant (aka order-reversing, or polarity-negating), on the left
05:27:48 <zincy__> Function application is contravariant?
05:27:55 <ski> no
05:28:07 <ski> the function arrow is contravariant, to the left
05:28:12 <fog> oh, so; forall a. (something :: *  -> * -> * ) a (forall b. b) == forall a, exists b. something a b
05:28:51 <zincy__> When you say function arrow are we talking about a type?
05:28:52 <ski> no
05:28:58 <ski> @kind (->)
05:28:59 <zincy__> :k ->
05:29:00 <lambdabot> * -> * -> *
05:29:00 <lambdabot> error: parse error on input ‘->’
05:29:12 <fog> i thought is was; forall a b. something a b == forall a. something a (exists b. b)
05:29:28 <ski> (also, please don't write `==' when you mean `=')
05:29:39 <ski> @type (==)
05:29:40 <fog> sorry! i really meant ===
05:29:41 <lambdabot> Eq a => a -> a -> Bool
05:29:43 <ski> @type (===)
05:29:45 <lambdabot> (Eq a, Show a) => a -> a -> Test.QuickCheck.Safe.SProperty
05:29:58 <fog> hmm, maybe i meant ~
05:30:04 <maerwald> omg, we're like javascript!
05:30:11 <ski> @type (====)
05:30:12 <lambdabot> error:
05:30:12 <lambdabot>     • Variable not in scope: ====
05:30:12 <lambdabot>     • Perhaps you meant ‘===’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
05:30:16 <ski> phew
05:30:20 <maerwald> lol
05:30:51 <zincy__> So the kind of (->)  is contravariant?
05:30:54 <zincy__> maerwald: :D
05:30:56 <ski> no
05:31:07 <ski> `(->)' itself is contravariant
05:31:11 <fog> still dont get why; forall a. (something :: *  -> * -> * ) a (forall b. b) == forall a, exists b. something a b
05:31:25 <fog> s/==/~
05:31:51 <ski> i have no idea whether you meant `forall a. (... ~ ...)' or `(forall a. ...) ~ ...', there
05:32:18 <ski> and what's `something' ?
05:32:27 <fog> no, the a appears on both sides, its unambiguous since the precedence of ~ is implied
05:32:34 <fog> the forall a.
05:32:46 <fog> something could be for example (,)
05:32:50 <fog> :k (,)
05:32:52 <lambdabot> * -> * -> *
05:33:00 <ski> there is `forall a.' on both sides, so those `a's could easily be distinct variables
05:33:11 <ski> (in fact, they'd be, regardless)
05:33:47 <ski> zincy__ : we have an equivalence between
05:33:47 <fog> (forall a. (,) a (forall b. b)) ~ (forall a, exists b. (,) a b
05:34:10 <zincy__> ski: So when you refer to (->) are you talking about the (->) in id :: a -> a. This -> is a higher kinded type. The order of what is being reversed here?
05:35:04 <ski>   (∃ α. ⋯α⋯) → ⋯
05:35:04 <ski> and
05:35:10 <ski>   ∀ α. (⋯α⋯ → ⋯)
05:35:13 <ski> e.g.
05:35:39 <ski>   length ∷ ∀ α. ([α] → Int)
05:35:42 <ski> means the same as
05:35:56 <ski>   length ∷ (∃ α. [α]) → Int
05:36:12 <fog> right, thats the bit i dont understand
05:36:22 <ski> zincy__ : yes, i'm talking abou that `->'. and no, it's not a higher-order type
05:36:24 <fog> how is it different just because of its restricted scope?
05:37:05 <fog> or is it something to do with it commuting over an (->)
05:37:07 <ski> @type bimap
05:37:08 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
05:37:09 <zincy__> ski: So just a type of kind * which is a contravariant functor?
05:37:17 <ski> specifically, we have
05:38:20 <ski>   bimap ∷ (α₀ → α₁) → (β₀ → β₁) → ((,) α₀ β₀ → (,) α₁ β₁)
05:38:28 <ski> or, if you prefer
05:38:36 <ski>   bimap ∷ (α₀ → α₁) → (β₀ → β₁) → ((α₀,β₀) → (α₁,β₁))
05:38:48 <ski> however, we don't have
05:39:04 <ski>   bimap ∷ (α₀ → α₁) → (β₀ → β₁) → ((→) α₀ β₀ → (→) α₁ β₁)  -- this is wrong
05:39:07 <ski> or
05:39:23 <ski>   bimap ∷ (α₀ → α₁) → (β₀ → β₁) → ((α₀ → β₀) → (α₁ → β₁))  -- this is also wrong
05:39:50 <ski> what we do have is
05:40:08 <ski>   dimap ∷ (α₁ → α₀) → (β₀ → β₁) → ((→) α₀ β₀ → (→) α₁ β₁)
05:40:11 <ski> or
05:40:26 <ski>   dimap ∷ (α₁ → α₀) → (β₀ → β₁) → ((α₀ → β₀) → (α₁ → β₁))
05:40:44 <ski> (exercise : what's the difference ?)
05:40:47 <fog> "it maps backwards over one of the values it "contains""
05:41:09 <ski> zincy__ : `(->)' does not have kind `*', no
05:41:56 <fog> not like  (a->b) -> f a -> f b, more like (a->b) -> f b -> f a, or equivalently (b->a) -> f a -> f b
05:41:59 <ski> (next exercise : how's this specific ⌜dimap⌝ implemented ?)
05:42:19 <ski> yes, fog, that's what contravariance is about
05:42:24 <zincy__> So a profunctor is a bifunctor with contravariant in one of its parameters
05:42:31 <zincy__> *contravariance
05:42:40 * ski calls it a "difunctor", but yes
05:42:59 <fog> ok, seems like we are ok with contravariance, so whats this got to do with exists?
05:43:07 <ski> a bifunctor is covariant in both parameters. a difunctor is contravariant in the first, and covariant in the second
05:43:10 <ski> @type dimap
05:43:11 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
05:43:12 <ski> @type contramap
05:43:14 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
05:43:36 <ski> do you see what i meant about "order-reversing", fog ?
05:44:21 <fog> @type bimap
05:44:22 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
05:44:42 <fog> comparing; p b c -> p a d, with; p a c -> p b d
05:44:44 <fog> yeah
05:44:49 <ski> in order to transform from ⌜α₀ → β₀⌝ to ⌜α₁ → β₁⌝, we have to go "backwards", from ⌜α₁⌝ to ⌜α₀⌝ (and also "forwards" from ⌜β₀⌝ to ⌜β₁⌝)
05:45:30 <ski> so, "moving to" the position left of `->' (moving from the whole function type), reverses the direction we're "mapping"
05:45:35 <fog> so covariant in one ar, contravariant in the other, so (->) is a Profunctor or Difunctor
05:46:00 <ski> it exchanges the roles of consumer/caller/user and producer/callee/implementor/definer
05:46:03 <TristahK> Profunctor
05:46:11 <ski> difunctor
05:49:01 <ski> zincy__ : anyway, to produce/implement/define a value of type ⌜∀ α. ⋯α⋯⌝, you, the callee, have to accept and make do with any choice of ⌜α⌝ the caller/consumer/user picks. you have to treat ⌜α⌝ as an abstract/unknown/opaque/forgotten/hidden type (a "skolem") that can't safely be assumed to be equal to any other type
05:50:11 <ski> otoh, when you consume/use a value of type ⌜∀ α. ⋯α⋯⌝, you, the caller, can pick and choose whichever specific type ⌜τ⌝ you like, and then go on using the value as if it had type ⌜⋯τ⋯⌝
05:51:15 <ski> e.g., when using ⌜length⌝, of type ⌜∀ α. ([α] → Int)⌝, you can pick ⌜α⌝ to be ⌜Bool⌝, and then go on using ⌜length⌝ as having type ⌜[Bool] → Int⌝
05:51:56 <Nolrai> Grrr, IntSet doesn't specify if 'difference' means symmetric or asymmetric difference.
05:52:03 <zincy__> ah so for all says you don't get to make any kinds of assumptions about what `a` actually is? And that is a skolem type variable/
05:53:15 <ski> otoh, to produce/implement/define a value of type ⌜∃ α. ⋯α⋯⌝, you, the caller, can pick and choose whichever specific type ⌜τ⌝ you like, computing a value of type ⌜⋯τ⋯⌝, where ⌜τ⌝ (some occurances of it in ⌜⋯τ⋯⌝, you decide which) will then be abstracted away, hiding being ⌜α⌝, producing a result value of type ⌜∃ α. ⋯α⋯⌝
05:53:57 <ski> er, s/caller/callee/, in that last sentence
05:54:18 <Nolrai> Its asymmetric! Yay!
05:54:37 <ski> while, to consume/use a value of type ⌜∃ α. ⋯α⋯⌝, you, the caller/user, have to accept and make do with any choice of ⌜α⌝ the producer/callee/implementor/definer picked. you have to treat ⌜α⌝ as an abstract/unknown/opaque/forgotten/hidden type (a "skolem") that can't safely be assumed to be equal to any other type
05:54:41 <dminuoso> Nolrai: By "asymmetric difference", do you mean complement?
05:55:02 <dminuoso> (Or relative complement, rather I guess)
05:55:20 <Nolrai> dminuso: relative complement yes.
05:55:24 <ski> zincy__ : "for all says you don't get to make any kinds of assumptions about what `a` actually is?" -- completely depends on whether you're producing a value of type `forall a. ..a..', or consuming it
05:55:38 <Nolrai> Though I don't think I have heard that terminology for it before.
05:56:21 <ski> zincy__ : swapping between `forall' and `exists', swaps between the rôles of who (producer vs. consumer) gets to pick and choose, and who has to be satisfied with whatever choice is made
05:56:57 * ski hasn't heard "symmetric difference" being referred to by only "difference"
05:57:14 <dminuoso> Right. It's either (set) difference or relative complement in any literature I've read.
05:58:04 <ski> zincy__ : so, consider ⌜length ∷ (∃ α. [α]) → Int⌝, this means that ⌜length⌝ will get an input such that, there exists some type ⌜α⌝ such that the input has type ⌜[α]⌝
05:59:19 <zincy__> Ah!
05:59:25 <Nolrai> Hmm. Possibly now you say so I haven't either, though I am used to seeing "symmetric difference" and "asymmetric difference". (The first also being called exclusive or.)
05:59:48 <ski> difference / relative complement of ⌜S⌝ and ⌜T⌝ is ⌜S ∸ T⌝ (or sometimes ⌜S ∖ T⌝, for some strange reason). symmetric difference of them is ⌜S ∆ T⌝
06:00:00 <Nolrai> Yes.
06:00:39 <zincy__> So existential vs universal simple swaps the roles between callee and caller?
06:00:43 <zincy__> *simply
06:01:32 <ski> hm, does ⌜S ∆ T ∆ U⌝ typically mean ⌜(S ∆ T) ∆ U⌝ / ⌜S ∆ (T ∆ U)⌝ (they're equal), or does it mean the set of elements which are in exactly one of ⌜S⌝,⌜T⌝,⌜U⌝ ?
06:02:27 <ski> zincy__ : swaps the rôles of which of callee/consumer/user vs. caller/producer/implementor/definer gets to pick and choose, and which must be prepared to handle any choice
06:02:29 <Nolrai> Arent those also the same thing?
06:02:47 <ski> no, Nolrai. the former will also include the elements which are in all three subsets
06:03:11 <Nolrai> Hmm. I don't think I have ever seen it clarified.
06:03:57 <ski> (similarly note that while exclusive disjunction is associative, iterating it doesn't yield "exactly one of the conditions must be true")
06:05:02 <ski> zincy__ : there is both callee and caller, for both existential and universal
06:05:33 <dminuoso> zincy__: Let me quote ski, nicely condensing it into an analogy:
06:05:35 <zincy__> I am still trying to get my head around this distinction
06:05:39 <dminuoso> 2019-06-19 17:43:13     ski     you could sortof say that skolem vs. metavariable is the xor of `forall'/`exists' and producer/consumer
06:05:54 <Nolrai> snort.
06:07:11 <ski> zincy__ : the caller/consumer/user of a value with universal type, and also the callee/producer/implementor/definer of a value with existential type, gets to instantiate the type variable with any specific type. in type inference, this choice is delayed, introducing a "placeholder variable", a meta-variable, which will (possibly) later be replaced by a specific type, when we look at how the value is being used
06:08:16 <zincy__> So meta-variables are like the thunks of the type-inference world?
06:08:26 <dminuoso> zincy__: metavariable is a role.
06:08:41 <ski> zincy__ : the callee/producer/implementor/definer of a value with universal type, and also the caller/consumer/user of a value with existential type, has to be prepared to handle any particular choice, doesn't get any say in the choice being made, can assume nothing about the chosen type. in type inference, we talk about a "rigid" type variable, or a skolem constant
06:08:43 <dminuoso> It's a sort of behavior.
06:09:08 <ski> zincy__ : are you familiar with any logic programming ? Prolog ?
06:09:22 <zincy__> ski: No not at all, yet
06:09:29 <ski> ok
06:09:56 <ski> dminuoso : hm, i don't remember saying that, but it's what i'm trying to get across, yes
06:10:31 <ski> (hm, i wonder whether that would be nice to `@remember', for easier reference)
06:11:27 <ski> zincy__ : thunks refer to variables which are already bound to an expression, it's just that the evaluation of that has been delayed
06:12:25 <ski> zincy__ : "placeholders" / meta-variables (called "logic variables" in logic programming, or "dataflow variables" in concurrent logic programming (Oz)), otoh, haven't even been bound to an expression, they have no value at all, to begin with
06:12:43 <ski> (in our context, type checking, "value" should be replaced by "type")
06:13:42 <ski> zincy__ : consider a simple function like
06:13:50 <zincy__> So as an example if you define id :: forall a. a -> a , then is a skolem type variable we know nothing about it. 
06:13:54 * hackage stache 2.1.1 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-2.1.1 (mrkkrp)
06:14:02 <zincy__> A metavariable is a variable for a variable?
06:14:13 <ski> no
06:14:19 <dminuoso> zincy__: It depends on the perspective! For the implementor of `id`, a has the skolem behavior. For the consumer of id, it is a meta variable.
06:15:02 <ski> from the POV of the definition of `id', `a' will be a skolem, an unknown type. quite similar to an abstract data type, imported from some module which doesn't export its `data' constructors
06:15:12 <zincy__> So the consumer is some type variable binding where `a` is being inhabited?
06:15:29 <dminuoso> zincy__: The consumer is the caller/user of that term.
06:15:35 <ski> from the POV of the caller of `id', `a' is a placeholder that they can pick to be any type, e.g. `[[Bool]]'
06:15:47 <ski> anyway
06:15:58 <ski>   turnAround :: [[Bool]] -> [[Bool]]
06:16:11 <ski>   turnAround bss = reverse (map reverse bss)
06:16:31 <ski> consider type-checking this definition
06:17:17 <ski> we have the signature of `turnAround'. that tells us the given input type, and the expected output type, of this function
06:17:23 <ski> in particular, it tells us
06:17:33 <ski>   bss :: [[Bool]]
06:17:42 <ski>   turnAround bss :: [[Bool]]
06:17:53 <zincy__> right
06:17:58 <ski> but since `turnAround bss = reverse (map reverse bss)', it also tells us that we should expect
06:18:05 <ski>   reverse (map reverse bss) :: [[Bool]]
06:18:30 <ski> and this is what we have to check, under the assumption of the typing for `bss' (and `turnAround', if it was recursive. but it isn't, in this case)
06:18:54 <ski> so, we have an application of `reverse' to something. we recall the type signature of `reverse'
06:19:05 <ski>   reverse :: forall a. [a] -> [a]
06:19:39 <ski> first thing we do, with an occurance of a polymorphic value/operation, like `reverse', is make a specialized monomorphic instance of it
06:19:58 <ski> iow, we should pick some particular type for `a', removing the `forall a.'
06:20:19 <ski> however, at this point, it's not clear (at least to a mechanical type-checker), what particular type to use
06:20:59 <ski> so, we defer this choice. we "pick" `a' to be `_a', which is a placeholder, a meta variable, standing for the specific (but yet unknown) type that we'll eventually want to use here
06:22:06 <ski> from an abstract syntax POV, `a' is a variable. if we were writing an implementation of a language, we might define a data type to represent types in out language, like
06:22:07 <dminuoso> lens/optics quesion: I find myself writing `do { t <- (gview . pre) (attrs % folded % somePrism); ... }` quite often for different choices of somePrism - is there a more dense/idiomatic solution for this?
06:22:14 <ski>   data Typ = Var Ident
06:22:38 <ski>            | Fun Typ Typ  -- `sigma -> tau'
06:23:02 <ski>            | Tuple [Typ]  -- `(tau_0,...,tau_{n-1})'
06:23:10 <zincy__> So metavariables are for deferring this choice of `a` as type inference needs to check the other expressions before it can pick an `a`?
06:23:19 <ski>            | Forall Ident Typ  -- `forall a. tau'
06:23:30 <ski>            | ...  -- and so on
06:23:52 <ski> so, the type variable `a' would be represented as `Var "a"', perhaps (if `type Ident = String')
06:24:51 <ski> but a meta-variable is not a type variable, it's a variable in the meta language (maybe Haskell, maybe Prolog, maybe some DSL), which is to stand for some object language type, like `a' or `Int' or `[Bool -> a]'
06:24:54 * hackage snap 1.1.3.0 - Top-level package for the Snap Web Framework  https://hackage.haskell.org/package/snap-1.1.3.0 (DougBeardsley)
06:25:04 <ski> zincy__ : yes. let's continue the example
06:25:07 <boxscape> what does the m in mdo stand for
06:25:10 <ski> we had
06:25:10 <boxscape> I'd understand rdo
06:25:17 <boxscape> but mdo makes no sense to me
06:25:21 <ski>   reverse :: forall a. [a] -> [a]
06:25:35 <ski> so, first step is to specialize this polymorphic value, into a monomorphic one
06:25:42 <ski>   reverse :: [_a] -> [_a]
06:25:47 <dminuoso> boxscape: Presumably it's mdo for the same reason it's called mfix?
06:25:59 <ski> where we replaced the type variable `a' with a fresh meta-variable `_a'
06:26:03 <dminuoso> It's not a good reason, but hysterial raisins.
06:26:08 <boxscape> hm I guess so
06:26:22 <dminuoso> (It also begs the question why mfix is called mfix and not fixM)
06:26:34 <boxscape> oh, true
06:27:03 <ski> now, we had the application `reverse (map reverse bss)', which was to have type `[[Bool]]'. so the result type of this occurance of `reverse' is to be equal to `[[Bool]]' :
06:27:11 <ski>   [_a]  =  [[Bool]]
06:27:29 <dminuoso> boxscape: Oh I know why!
06:27:36 <boxscape> oh?
06:27:40 <dminuoso> boxscape: The m is an ASCII approximation of the greek mu.
06:27:45 <boxscape> ooh
06:27:46 <dminuoso> boxscape: http://leventerkok.github.io/papers/recdo.pdf
06:27:51 <boxscape> thank you
06:27:59 <dminuoso> Presumably it's the same justification for mfix.
06:28:06 <ski> and also, the expected type of the actual parameter, `map reverse bss' is to be the argument type of `reverse' :
06:28:10 <dminuoso> No, nvm tha tlast.
06:28:12 <ski>   map reverse bss :: [_a]
06:28:12 <dminuoso> That makes no sense.
06:28:18 <ski> zincy__ : does this make sense ?
06:28:34 <zincy__> ski: Oh sorry I have to walk my dog but lets continue this later. Ill be back in about 40 mins
06:28:41 <ski> ah, no worry, zincy__
06:44:36 <abicz> I am first time in this channell, and would like to say hello 
06:45:29 <[exa]> abicz: Hello!
06:46:55 <ski> hello abicz
06:47:32 <ski> do you have any question(s) ?
06:48:37 <abicz> I would like to ask about Validation data type 
06:48:37 <abicz> why it can not have Monad instance?
06:48:39 <abicz> is it because it design choice to be isomorphic to Either?
06:54:24 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/49e7f784dcd57c4f28ee9ed6a6d6f6a8/pasted.txt
06:55:01 <lhurttila> why does adding that square root to the distance function cause "No instance for (Floating Int) arising from a use of `distance'"
06:56:13 <ski> abicz : the idea is to report all the errors found, in independent parts
06:57:33 <ski> abicz : however, with `(>>=) :: Validation a -> (a -> Validation b) -> Validation b', if you call `va >>= avb' then if there's an error in `va', then you can't also collect any errors in `avb a', since you don't get any normal result `a' from va' in that case (since it errored out)
06:58:03 <Nolrai> lhurttila: because sqrt is defined on members of the "Floating" typeclass which Int isn't.
06:58:32 <ski> abicz : while, if you have something which is both an instance of `Applicative' and `Monad', then `liftM2' is expected to be equal to `liftA2' (or, equivalently, `ap' is expected to be equivalent to `(<*>)')
06:58:36 <ski> @type liftM2
06:58:38 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:58:38 <ski> @type liftA2
06:58:39 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:58:42 <ski> @type ap
06:58:43 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:58:45 <Nolrai> @ty sqrt
06:58:46 <lambdabot> Floating a => a -> a
06:58:48 <ski> @type (<*>)
06:58:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:59:20 <ski> however, `liftM2' is implemented using `(>>=)'
06:59:22 <ski> @src liftM2
06:59:22 <lambdabot> liftM2 f m1 m2 = do
06:59:23 <lambdabot>     x1 <- m1
06:59:23 <lambdabot>     x2 <- m2
06:59:23 <lambdabot>     return (f x1 x2)
06:59:39 <abicz> ski : thank you very much, I have to digest it 
06:59:49 <ski>   liftM2 f ma ma = ma >>= \a -> mb >>= \b -> return (f a b)  -- equivalently
06:59:52 <ski> or
06:59:55 <ski> @src ap
06:59:55 <lambdabot> ap = liftM2 id
07:00:16 <ski>   ap mf ma = mf >>= \f -> ma >>= \a -> return (f a)
07:00:51 <Nolrai> lhurttila: put in a fromIntegral to convert an Int to a Float..though if you are just using it to sort, why take the square root at all? Its monotonic and expensive.
07:00:54 <ski> so, in `liftM2 f ma mb', if `ma' has any errors, we won't get the errors (if any) in `mb'. but with `liftA2' we will
07:01:38 <ski> (and ditto for `ap' vs. `(<*>)')
07:02:21 <abicz> ski : OK, it is caused by this Applicative <-> Monad relation understand
07:02:54 <lhurttila> Then why does let distance (x1, y1) (x2, y2) = sqrt $ (x2-x1)^2 + (y2-y1)^2 and then distance (0,0) (2,2) work just fine in ghci?
07:03:29 <abicz> ski++
07:07:15 <lhurttila> Nolrai Just looked up the formula for euclidean distance and went with it. But the sqrt isn't needed at all?
07:08:32 <[exa]> lhurttila: sqrt works only on floating-point-style numbers; if you forcibly push integers, it will refuse
07:09:00 <[exa]> lhurttila: in your short ghci example, the number literals are Double
07:09:28 <[exa]> in the code example, you force Int everywhere, so the numbers must be Int
07:10:12 <[exa]> possibility to fix 1: add fromInteger before sqrt
07:10:24 <[exa]> better possibility: avoid sqrt altogether because it doesn't change ordering
07:10:29 <lhurttila> Ok got it :)
07:12:53 * ski twitches
07:17:08 <[exa]> s/fromInteger/fromIntegral/
07:28:12 <zincy__> ski: Back now and yes that seems to make sense
07:28:43 <ski> hm, so summarizing so far, we had
07:28:53 <ski>   turnAround :: [[Bool]] -> [[Bool]]
07:28:54 <ski>   turnAround bss = reverse (map reverse bss)
07:28:58 <ski>   bss :: [[Bool]]
07:29:05 <ski>   turnAround bss :: [[Bool]]
07:29:09 <ski>   reverse (map reverse bss) :: [[Bool]]
07:29:13 <ski>   reverse :: forall a. [a] -> [a]
07:29:21 <ski>   reverse :: [_a] -> [_a]
07:29:28 <ski>   [_a]  =  [[Bool]]
07:29:30 <ski>   map reverse bss :: [_a]
07:29:46 <ski> zincy__ : shall we continue ?
07:30:05 <zincy__> yes
07:30:24 <ski> so, we have an occurance of `map', applied to an occurance of `reverse', and then that's applied to `bss'
07:30:36 <ski> so, we recall the signature of `map'
07:30:53 <ski>   map :: forall a b. (a -> b) -> ([a] -> [b])
07:31:22 <zincy__> Right so we need to "unify?" the `a` in reverse and map
07:31:36 <ski> as with `reverse' before, we specialize this, inventing new/fresh meta-variables to delay the choices of what actual types to pick for `a' and `b' in the signature of `map'
07:32:02 <ski> we could "unify" already (solving `[_a]  =  [[Bool]]'), but let's post-pone that, until we've traversed the whole AST
07:32:05 <ski> so
07:32:16 <ski>   map :: (_b -> _c) -> ([_b] -> [_c])
07:32:17 <zincy__> So are metavariables just normal type variables?
07:32:26 <ski> (can't reuse `_a', since we already had that meta-variable)
07:32:27 <ski> no
07:32:36 <zincy__> Ok so distinct
07:33:36 <ski> type variables, like `a',`b', are always bound somewhere, by a binder in the language. like `forall' (which is often elided, not written explicitly), or bound by `type',`newtype',`data',`class',`instance'
07:34:12 <zincy__> ahh so binding isn't a term reserved just for values
07:34:29 <zincy__> It is the general notion of giving something another name
07:34:41 <ski> however, `_a',`_b',`_c' here are not bound in the object language (Haskell). they are not (type) variables in Haskell. they are something that belongs to the meta-language (the language in which the type system is specified in. the language in which the type checker/inferences is written in)
07:34:53 <ski> yes, zincy__
07:35:07 <zincy__> so metavariables are symbols which represent things in the object language
07:35:16 <zincy__> and we want a place holder for type variables
07:35:17 <ski> anyway, `map' is applied to `reverse' in `map reverse bss' (which is really `(map reverse) bss', remember)
07:35:27 <zincy__> or type parameters?
07:35:43 <ski> yes, sine we don't wanna guess the specific type to use, yet
07:36:42 <ski> ideally, when we had `reverse :: forall a. [a] -> [a]', we'd specialize it to something like `reverse :: [(Int,String -> IO Bool)] -> [(Int,String -> IO Bool)]' directly, if that's the specialization we wanted
07:37:10 <ski> but since we (the type checker) doesn't know the desired specialization yet, it postpones the choice
07:38:34 <ski> the meta-variables are an artifact of the search for types (for every subexpression). the result of type checking will be an assignment of types to each subexpression. at that point, we will have no further use of the meta-variables. they're only used during the process of searching for the types, during the process of type checking/inferring
07:38:36 <zincy__> Dumb question but why does it have to make a choice? Is it because it needs to be reduced to an evaluated form in order to be compared?
07:38:45 <ski> if
07:38:49 <ski>   reverse :: forall a. [a] -> [a]
07:39:11 <ski> then `reverse' has type `[a] -> [a]', for all types `a'. that's what it means for `reverse' to be polymorhic
07:39:15 <ski> so, in particular, we have
07:39:26 <ski>   reverse :: [Integer] -> [Integer]
07:39:36 <ski>   reverse :: [(Int,String -> IO Bool)] -> [(Int,String -> IO Bool)]
07:39:39 <zincy__> I think I understand this
07:39:55 <ski>   reverse :: [Parser Char] -> [Parser Char]
07:40:01 <ski>   ...
07:40:16 <zincy__> We need the metavariable so we can put placeholders in so the placeholders can be compared
07:40:23 <zincy__> as part of the unification proces
07:40:27 <ski> and we don't know which of these possible specializations (infinitely many of them), that this particular usage of `reverse' should use
07:40:37 <ski> anyway, we had
07:40:50 <ski>   map :: (_b -> _c) -> ([_b] -> [_c])
07:41:20 <ski> and, in `(map reverse) bss', this `map' is applied to an occurance of the (polymorphic) `reverse'. therefore we need to specialize
07:41:28 <ski>   reverse :: forall a. [a] -> [a]
07:42:15 <ski> again, inventing a fresh/new meta-variable (not reusing the `_a' from last time, the last occurance of `reverse') :
07:42:24 <ski>   reverse :: [_d] -> [_d]
07:42:35 <zincy__> aha
07:42:58 <zincy__> So different expressions have their own metavariables
07:43:34 <ski> so, the (expected) argument type (the type of the formal parameter) of this occurance of `map' should be equal to the type of the actual parameter, `reverse' :
07:43:35 <zincy__> Because otherwise who could we compare the inhabitants of a type variable which can be inhabited by anything
07:43:43 <zincy__> *how
07:43:45 <ski>   _b -> _c  =  [_d] -> [_d]
07:44:09 <ski> and the type of this application `map reverse' should be the result type of this occurance of `map' :
07:44:16 <ski>   map reverse :: [_b] -> [_c]
07:44:16 <zincy__> And a metavariable is a symbol because you cannot replace it with an actual type
07:45:40 <ski> zincy__ : "So different expressions have their own metavariables" -- each different use/occurance of a polymorphic value (like `reverse',`map') will introduce new meta-variables, replacing the type variables (removing the `forall'), specializing the polymorphic value to a monomorphic instance (with a specific type, albeit we still don't know yet which)
07:46:11 <zincy__> :D I think I finally get this
07:46:15 <ski> "you cannot replace it with an actual type" -- we can, eventually. it's just that we don't know, yet, which actual type to use. it's a placeholder, and stand-in, for some specific type
07:46:20 <ski> anyway, continuing
07:46:33 <ski> we already knew from before the expected typing :
07:46:49 <ski>   map reverse bss :: [_a]
07:47:14 <ski> and, we've traversed the `map reverse' part of `(map reverse) bss', already, figuring out
07:47:19 <ski>   map reverse :: [_b] -> [_c]
07:47:32 <ski> now, we need to consider the application of this `map reverse' to `bss'
07:48:13 <ski> again, the argument type `[b]' in the function type, should equal the actual type of the argument, being `[_a]' :
07:48:29 <ski> er
07:48:38 <ski> sorry, let me retry that
07:48:52 <ski> again, the argument type `[b]' in the function type, should equal the actual type of the argument, being `[[Bool]]' :
07:49:06 <ski>   [_b]  =  [[Bool]]
07:49:33 <ski> (recall `bss :: [[Bool]]', from above. also, yes, that `b' should have been a `_b')
07:49:59 <zincy__> yep
07:50:25 <ski> finally, the return type of the function `map reverse', being `[_c]', should equal the type of the whole application `(map reverse) bss', being `[_a]' :
07:50:36 <ski>   [_c]  =  [_a]
07:50:56 <ski> so, let's now collect all the type equalities/equations together, into one big equation system :
07:51:20 <ski>   [_a]  =  [[Bool]]
07:51:23 <ski>   _b -> _c  =  [_d] -> [_d]
07:51:25 <ivegotasthma> can anyone help me build a haskell hello world with nix? I'm having a trouble adding a dependency with nix and cabal picking it up
07:51:30 <ski>   [_b]  =  [[Bool]]
07:51:34 <ski>   [_c]  =  [_a]
07:52:01 <ski> er, sorry, just noticed another mistake
07:52:07 <ski> hm
07:52:26 <ski> ah, no. it's okay
07:52:50 <ski> so, we can simplify `[_a]  =  [[Bool]]' into just
07:52:58 <ski>   _a  =  [Bool]
07:53:36 <ski> (since `[]' is an "injective" type function. all `data' types are. but if you use (the extension) type families, then you can get non-injective type functions)
07:54:12 <ski> now, we can easily solve the equation `_a  =  [Bool]', by choosing `_a' to be the type `[Bool]' !
07:54:23 <zincy__> Oh [] is an injective type function?
07:54:28 <ski> so, now we actualy do the (delayed) choice of picking `_a'
07:55:02 <zincy__> Ah so this is why we delayed our choices ...
07:55:08 <ski> yes, if a list has both type `[T]' and type `[U]', then the type `T' must be equal to the type `U'. you can't have a list that simultaneously has two different element types
07:55:16 <zincy__> So we can pergorm gaussian elimination
07:55:19 <zincy__> *perform
07:55:32 <ski> actually, in general, we should also repeat the type signature of the main operation
07:55:37 <ski>   turnAround :: [[Bool]] -> [[Bool]]
07:55:56 <ski> since, in general (if we're inferring types), it could also include meta-variables
07:57:06 <zincy__> So when you see those compiler messages about "rigid skolem type variables" what it actually means often, is that the system of equations is underspecified
07:57:10 <ski> now, after having picked `_a', we should everywhere (including in this signature) replace `_a' by `[Bool]', so `_a  =  [Bool]' becomes just `[Bool]  =  [Bool]' which is a trivial equation, always true, so i'll just drop it. so, the remaining equations (after substituting `[Bool]' for `_a') is now :
07:57:19 <ski>   _b -> _c  =  [_d] -> [_d]
07:57:19 <ski>   [_b]  =  [[Bool]]
07:57:26 <ski>   [_c]  =  [[Bool]]
07:58:21 <ski> zincy__ : no. underspecification leads to polymorphism. we haven't seen rigids/skolems yet, in the type checking/inference example
07:58:33 <zincy__> ah ok
07:58:45 <ski> anyway, `(->)' is also injective, so we can now replace the first equation by two equations :
07:58:48 <zincy__> following so far anyway.
07:58:55 <ski>   _b  =  _d
07:58:57 <ski>   _c  =  _d
07:59:01 <ski>   [_b]  =  [[Bool]]
07:59:03 <ski>   [_c]  =  [[Bool]]
07:59:17 <zincy__> So injective means essentially a total function?
07:59:34 <zincy__> all elements in domain are mapped
08:00:05 <ski> the first two equations are trivially solvbable. we can replace `_b' by `_d' (or the other way around, replacing `_d' by `_b', if we prefer). and replace `_c' by `_d' (or the other way around). let's replace `_b' and `_c' both by `_d'. we get :
08:00:13 <zincy__> bit confused about the last step
08:00:14 <ski>   [_d]  =  [[Bool]]
08:00:15 <ski>   [_d]  =  [[Bool]]
08:00:39 <ski> `f' being injective means that if `f a = f b', then `a = b'
08:01:01 <zincy__> ah ok
08:01:14 <ski> in our case, if `[] _b  =  [] ([] Bool)', then `_b  =  [] Bool'
08:01:39 <ski> and if `(->) _b _c  =  (->) _d _d', then `_b  =  _d' and `_c  =  _d'
08:02:04 <ski> so, we can simplify the equation `[_d]  =  [[Bool]]', again, using injectivity, getting :
08:02:09 <ski>   _d  =  [Bool]
08:02:12 <ski>   [_d]  =  [[Bool]]
08:02:22 <ski> (not touching the second remaining equation yet)
08:02:40 <ski> now, we pick `_d' to be `[Bool]', replacing in the other equation, getting
08:02:48 <ski>   [[Bool]]  =  [[Bool]]
08:02:56 <ski> which is trivially true, so we can drop it
08:03:33 <zincy__> quick question - is each equation in our a system what is called a "type constraint"? i.e   [_d]  =  [[Bool]]
08:03:41 <ski> so, we have no equations left, and we haven't detected any inconsitency (like `Int  =  Bool' or `Char  =  _a -> [_b]' or similar), which would have meant a type error
08:04:09 <ski> i would call them type equalities/equations, or unifications
08:04:32 <ski> constraints usually refer to what's to the left of `=>', in Haskell
08:04:53 <zincy__> yeah
08:05:05 <ski> however, in the sense of constraints in an equation (or inequation) system, you could call them constraints, yes
08:05:58 <[exa]> hm, since ghc ~8.6 I'm getting a message from ghci that some packages are hidden and I have to expose them before importing. Is there some ground reason for (speculation:) not exposing the packages by default?
08:06:14 <[exa]> not that it would matter, just curious
08:06:20 <ski> (and that same usage of "constraint" is used in Constraint Logic Programming (CLP), which (typically) extends logic programming from only having tree ("constructor") constraints, to also having numeric equality and inequality constraints, sometimes also other kinds of constraints)
08:06:29 <merijn> [exa]: Yes, because doing so would mean your cabal file is wrong
08:06:53 <merijn> [exa]: Are you using cabal repl/stack repl?
08:07:05 <ski> zincy__ : now, what if we hadn't provided any type signature for `turnAround' at the start ?
08:07:16 <ski> i.e., assume we didn't have
08:07:25 <ski>   turnAround :: [[Bool]] -> [[Bool]]
08:07:28 <ski> to begin with
08:07:33 <ski> well, looking at the definition
08:07:39 <ski>   turnAround bss = reverse (map reverse bss)
08:07:40 <[exa]> merijn: no, just plain ghci. I guess that if I run 'cabal repl' in a project that has the dependency declared, it should not happen?
08:07:49 <zincy__> Would there just be a single metavariable?
08:07:54 <ski> we can see that `turnAround' is a function. so the first step would have been to say
08:07:54 <merijn> [exa]: Do you have a case where it happens right now?
08:08:05 <ski>   turnAround :: _a -> _b
08:08:14 <merijn> [exa]: If yes, can you check whether there's a (hidden) .ghc.environment file in that directory?
08:08:22 <[exa]> merijn: I observed it few times, friend has this case with ghcide
08:08:55 <ski> zincy__ : or, yes, you could have started with `turnAround :: _a', and only after that add an equation `_a  =  _b -> _c', to account for seeing `bss' to the left of `=' (so `turnAround' must be a function)
08:09:19 <zincy__> yeah
08:09:24 <ski> zincy__ : anyway, if you go through the same process as we just did above, you'd end up with something like
08:09:29 <[exa]> merijn: and we arrived to decision that we should know what's the reason
08:09:31 <[exa]> :]
08:09:34 <ski>   turnAround :: [[_d]] -> [[_d]]
08:09:36 <ski> in the end
08:10:02 <ski> zincy__ : and so the system was "underconstrained", there's nothing fixing `_d'
08:10:07 <merijn> [exa]: Basically, to make sure that "ghci" inside a cabal package "works" (i.e. you can import that package, etc) cabal causes GHC to write out a .ghc.environment file (well, not anymore by default, I think, but it did for a time)
08:10:19 <ski> zincy__ : and so, as a last step, we'd generalize this into
08:10:20 <merijn> [exa]: This file lets GHC see all installed dependencies your project needs
08:10:27 <ski>   turnAround :: forall a. [[a]] -> [[a]]
08:10:43 <merijn> [exa]: So my guess is that you have a stale/old .ghc.environment file that doesn't match your package and that causes ghci to complain
08:10:55 <ski> zincy__ : replacing the "free"/unconstrained meta-variable `_d' by a proper type variable `a', bound explicitly by a `forall'
08:11:06 <ski> zincy__ : makes sense ?
08:11:29 <[exa]> merijn: that also explains my problems with standalone ghci. Thanks a lot. I'll check the .ghc.environment
08:11:41 <[exa]> uh anyway .ghc.environment is not there
08:11:42 <zincy__> ski: Ah so underspecified constraints for unification is what we call polymorphism?
08:11:54 <[exa]> so I assume we're missing something in cabal dependencies?
08:11:55 <ski> zincy__ : it leads to polymorphism, yes
08:12:10 <zincy__> Makes sense :D
08:12:18 <ski> zincy__ : now, let's say we had actually specified, at the start
08:12:28 <ski>   turnAround :: forall a. [[a]] -> [[a]]
08:12:30 <ski>   turnAround bss = reverse (map reverse bss)
08:12:35 <[exa]> (in fact it's complaining about Web.Scotty but scotty is perfectly there)
08:13:24 <ski> the first step, then, would be to get rid of the `forall', replacing `a' not by a meta-variable (say `_a'), but by a rigid/skolem, let's write it `?a' :
08:13:32 <ski>   turnAround :: [[?a]] -> [[?a]]
08:14:23 <merijn> [exa]: If cabal compiles without errors, but ghci doesn't load stuff that seems right
08:14:29 <merijn> [exa]: Does "cabal repl" work properly?
08:14:42 <ski> zincy__ : for meta-variables, we're allowed to pick them as whatever type we want. we were just deferring the choice in order to (a) "not burn our bridges", by committing to a choice which would lead to a(n uncessary) type error; and (b) be as general, as polymorphic, as possible
08:14:50 <zincy__> ski: Ah so rigid/skolem is not a type variable
08:15:07 <[exa]> merijn: gonna ask (sorry for delays, I'm a proxy now)
08:15:23 <merijn> [exa]: ghci doesn't magically know about dependencies, the "not exposed warning" means "hey, you seem to have a package installed that has the right module, but you haven't told me to use it"
08:15:38 <ski> zincy__ : but here, we're not allowed to pick e.g. `Bool' (as we were before). the type signature `turnAround :: forall a. [[a]] -> [[a]]' requires `turnAround' to be polymorphic. we may not assume anything about the choice of `a'
08:15:46 <zincy__> rigid/skolems are like metavariables but they can't be substituted?
08:15:52 <zincy__> in the unification process?
08:16:03 <merijn> [exa]: And the reason for not "magically exposing everything" is because that increases the likelihood of "well, it works on my machine", better to only use only dependencies you've been explicitly told about
08:16:23 <merijn> [exa]: (You can tell ghci to use a certain package via "ghc -package foo"
08:16:28 <ski> zincy__ : so `?a' stands for some unknown type, that we're now allowed to assume anything about. we only know it's equal to itself, so e.g. `?a  =  ?a' or `[[?a]]  =  [[?a]]' is still trivially solvable
08:16:43 <[exa]> merijn: ok, so I guess his ghcide is basically messing this up by not using the information from .cabal ?
08:16:59 <zincy__> ski: makes sense
08:17:07 <merijn> [exa]: Anyway, the workaround for "I don't want to manually pass the right ghci flags" is to use "cabal repl" (ghcide can use cabal repl, btw)
08:17:07 <ski> zincy__ : yea, rigids/skolems are constants. they're like an abstract data type, imported from some other module, without exposing implementation
08:17:48 <merijn> [exa]: Alternatively, you can change your ~/.cabal/config to enable writing .ghc.environment files, in which case running "ghci" will pick up the right packages that way
08:17:51 <ski> zincy__ : if we have `?a  =  _b', we can solve this, by instantiating `_b' to `?a' (replacing `_b' with `?a'. substituting `?a' for `_b')
08:17:55 <[exa]> merijn: ok great, thanks a lot
08:18:10 <ski> zincy__ : but we're not allowed to do it the other way around. we can't replace `?a' by `_b'
08:18:21 <[exa]> merijn: I guess we can make it work now. Also I see the main reason now :D
08:19:01 <ski> zincy__ : and if we have `?a  =  ?c', comparing two different skolems, then this is unsolvable, a type error. we're not allowed to assume they're equal, since they might be different (depending on what types the caller/user/consumer picks/chooses)
08:19:39 <ski> (but, again, `?a  =  ?a' is solvable, trivial. we can just drop such an equation)
08:20:38 <ski> zincy__ : "rigid/skolems are like metavariables but they can't be substituted?","in the unification process?" -- yes. they're also something that occurs in the type checking/inferring process, not in the end result of it
08:21:16 <zincy__> ah so inference and unification are different stages
08:21:38 <ski> unification is a part of inference/checking
08:22:14 <ski> one can either defer unification til the end of it (like i did above), or do it, as we go (solving each new equation, as soon as we generate it)
08:22:42 <ski> (however, with more advanced type system features, we do actually (in general) need to defer it til the end)
08:22:53 <zincy__> Oh i see the connection now between rigid skolems and for all I think
08:23:12 <ski> they're also related to `exists', but "in the opposite way"
08:24:16 <ski> when checking types of a use of a value of `forall'-type, you'll generate a meta-variable
08:24:38 <ski> when checking types of a definition/construction of a value of `forall'-type, you'll generate a skolem
08:24:48 <ski> when checking types of a use of a value of `exists'-type, you'll generate a skolem
08:24:59 <ski> when checking types of a definition/construction of a value of `exists'-type, you'll generate a meta-variable
08:25:13 <ski> zincy__ : do you see that ?
08:26:19 <ski> s/now allowed/not allowed/
08:26:23 <zincy__> So definition/construction is the original context where a type variable is defined
08:26:49 <ski> consider a signature like
08:26:55 <ski>   reverse :: forall a. [a] -> [a]
08:27:20 <ski> this signature is an interface, between uses of `reverse', and the definition of `reverse'
08:28:04 <ski> from the "outside", from the POV of the uses, `a' will be replaced by a meta-variable, allowing the uses to pick and choose whatever type they like for `a'
08:28:49 <ski> from tthe "inside", from the POV of the definition, `a' will be replaced by a skolem, insisting that the definition assumes nothing about whatever type is going to be picked
08:29:01 <zincy__> Yes that makes sense
08:29:26 <zincy__> That is interesting
08:29:41 <ski> and, for `exists' in place of `forall', this is completely reversed
08:30:01 <ski> there, it's the definition which gets the meta-variable, gets to pick and choose a particular type for `a'
08:30:19 <ski> while, the uses can assume nothing about whatever type was picked
08:30:25 <ski> in fact, if you have something like
08:30:42 <ski>   silly :: Bool -> exists a. (a,a -> a,a -> String)
08:31:04 <ski>   silly False = ( False ,not    ,show)
08:31:19 <ski>   silly True = ("True" ,reverse,id  )
08:31:49 <ski> then which type `a' is picked will (possibly) depend on run-time input to the program, so can't possibly be determined at compile-time
08:32:08 <zincy__> Ooh
08:32:19 <ski> (that is, you may pick and choose different types for `a', in different branches)
08:32:37 <zincy__> That example perfectly illustrates the inversion
08:32:43 <ski> similarly, if you have a rank-two operation like
08:32:48 <zincy__> So cool
08:33:08 <ski>   alsoSilly :: (forall a. [a] -> [a]) -> [String] -> [String]
08:33:24 <ski>   alsoSilly poly ss = poly (map poly ss)
08:33:48 <ski> then first note that `alsoSilly' is not polymorphic !
08:34:09 <ski> it's the argument of `alsoSilly', called `poly' in the definition, which is required to be polymorphic
08:34:43 <ski> and, since the argument is polymorphic, we can specialize it to different types, at the two different use sites, in the definition of `alsoSilly'
08:34:49 <ski> for the first one, we have
08:34:58 <ski>   poly :: [String] -> [String]
08:35:03 <ski> for the second one, we have
08:35:10 <ski>   poly :: [Char] -> [Char]
08:35:37 <ski> and, we could easily imagine run-time input deciding which actual type to specialize a polymorphic input at
08:36:20 <zincy__> sorry two secs
08:36:25 <ski> both `silly' and `alsoSilly' (unlike `reverse', or the polymorphic version of `turnAround) gets to pick and choose `a', in their definition
08:39:21 <ski> (so, in that sense, a rank-two (or more generally, even-rank) operations is similar to an operation computing a result of existential type)
08:48:45 <zincy__> back now
08:49:55 <zincy__> ski: So rank-n types has the same effect as existentials?
08:50:08 <zincy__> Also I just read this "a (rigid, skolem) variable is a type that is existentially quantified"
08:50:18 <zincy__> is that correct?
08:50:38 <ski> rank-`n' types, for even `n', is similar in some ways, yes
08:50:53 <ski> no, zincy__
08:51:49 <ski> existential quantification, and also universal quantification, involves type variables (not meta-variables, nor skolems/rigids)
08:51:56 <zincy__> https://reasonablypolymorphic.com/existentialization/#/step-15
08:52:08 <zincy__> Why is so much writing on the internet about Haskell wrong
08:53:05 <merijn> zincy__: You can achieve the same effect as existentials with rankN, but they're not the same
08:53:36 <zincy__> Okay repeat to self, rigid skolems are opaque placeholders for types we cant assume anything about (like constants) whereas metavariables are symbolic placeholders for other types
08:53:45 <ski> the latter two are something that's used in the process of type checking/inference, and can also be used when thinking about interfaces involving `forall' and `exists, from one or the other side of the interface (use vs. implement/define, caller vs. callee, consumer vs. producer, destruct vs. construct, eliminate vs. introduce)
08:54:26 <ski>   data Any where
08:54:27 <ski>     Any :: a -> Any
08:54:45 <ski> "We say the a is now existential." -- no
08:55:14 <ski> a type variable is not existential, nor is `a' in `take :: forall a. Int -> [a] -> [a]' universal (nor polymorphic)
08:55:22 <ski> in that example, you have
08:55:30 <ski>   Any :: forall a. (a -> Any)
08:55:33 <ski> which is equivalent to
08:55:44 <ski>   Any :: (exists a. a) -> Any
08:55:46 <zincy__> Sorry think my internet just cut and I missed the responses
08:56:07 <ski> meaning that a value of type `Any' wraps/contains a value of type `exists a. a'
08:57:16 <ski> the type `Any' is a `data' type, expressing the existentially quantified type `exists a. a'. one could for short express this by saying that `Any' is an "existential `data' type"
08:57:42 <ski> zincy__ : "rigid skolems are opaque placeholders for types we cant assume anything about (like constants)" -- yes
08:58:18 <ski> zincy__ : "whereas metavariables are symbolic placeholders for other types" -- i dunno what you mean by "symbolic" there (perhaps you just mean it's a name for a type), but it sounds ok, otherwise
08:59:28 <tom__> cheers
09:00:27 <maerwald> Hmm, I'm envisioning an exception system based on open variants, where you rethrow low-level exceptions as high-level exceptions. E.g. '[HTTPStatusError, HTTPRedirectHeaderMissing] turns into '[DownloadFailed], while the underlying exception is still preserved: https://git.io/JvrBg
09:00:53 <tom__> ski: Thanks so much for the explanation
09:00:59 <tom__> Really helpful!
09:01:02 <maerwald> I currently have two problems with that approach: 1) you never know whether you have unnecessary error types in your open variant and 2) you never know when you handled all IO exceptions
09:03:28 <ski> tom__ : see PM for messages you maybe missed
09:03:35 <ski> tom__ : you're welcome
09:03:36 * ski bows
09:10:36 <tom__> ski: so just to help my understanding
09:11:26 <tom__> fix f = f (fix f)
09:11:43 <tom__> if we assign the following type variables
09:11:57 <tom__> -- fix :: tx
09:12:03 <tom__> -- f :: tf
09:12:09 <tom__> -- f (fix f) :: ta
09:12:15 <tom__> -- fix f :: tb
09:12:28 <tom__> Under ML type inference the constraints produced would be
09:12:45 <tom__> ta = tb  --      fix f = f (fix f)
09:13:07 <tom__> tb = tf  --      fix f :: a -> a = f
09:13:56 <tom__> hmm and the last one would be ...
09:16:28 <tom__> tf = ta
09:16:33 <tom__> Is that right?
09:16:53 * hackage org-mode-lucid 1.1.0 -   https://hackage.haskell.org/package/org-mode-lucid-1.1.0 (fosskers)
09:18:48 <maerwald> I rephrased at https://github.com/haskus/packages/issues/32
09:22:53 * hackage opentelemetry 0.2.0 -   https://hackage.haskell.org/package/opentelemetry-0.2.0 (DmitryIvanov)
09:23:54 * hackage opentelemetry-wai 0.2.0, opentelemetry-http-client 0.2.0, opentelemetry-lightstep 0.2.0 (DmitryIvanov)
09:26:22 <ski> tom__ : `tb = tf' is not right
09:26:38 <ski> and neither is `tf = a'
09:27:14 <ski> @where polymorphic-type-inference
09:27:14 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
09:27:23 * hackage skylighting-lucid 1.0.0 - Lucid support for Skylighting  https://hackage.haskell.org/package/skylighting-lucid-1.0.0 (fosskers)
09:27:42 <ski> tom__ : you could try reading that paper ^ for more info/material on this
09:27:51 <tom__> Ok thanks!
09:30:31 <ski> tom__ : how did you arrive at those two equalities ?
09:32:34 <tom__> Just gonna read the paper and eat dinner then I will be happy to explain my thought process :)
10:18:37 <zbz> Anyone knows when I compile using a makefile and got this error message  "Failed to load interface for ‘Math.Combinatorics.Exact.Binomial’"?
10:19:44 <slack1256> zbz: Do you know what library does provide the module `Math.Combinatorics.Exact.Binomial` ?
10:20:09 <slack1256> zbz: It seems it's not installed on the lookup path of library that ghc searches.
10:21:23 * hackage bitcoind-rpc 0.1.0.0 - A streamlined interface to bitcoin core using Haskoin types and Servant  https://hackage.haskell.org/package/bitcoind-rpc-0.1.0.0 (IanShipman)
10:21:26 <slack1256> s/library/libraries/
10:21:48 <int-e> . o O ( why a makefile )
10:22:01 <int-e> The library is most likely https://hackage.haskell.org/package/exact-combinatorics
10:22:06 <geekosaur> well. if it's from a package then something is wrong with the package, because it's there but at least some of its .hi files are missing. if it's not from a package then you've specified source paths incorrectly such that it can't find the module
10:22:16 <zbz> I am new to haskell here, wanna using the code someone wrote to generate some input file for another program
10:22:24 * hackage bitcoind-regtest 0.1.0.0 - A library for working with bitcoin-core regtest networks  https://hackage.haskell.org/package/bitcoind-regtest-0.1.0.0 (IanShipman)
10:22:58 <slack1256> zbz: Run `ghc-pkg list` and see if exact-combinatorics is installed on your system.
10:23:19 <slack1256> zbz: That could explain why ghc didn't find it, that dependency was not installed.
10:37:11 <monochrom> Does anyone actually want to know what's inside said makefile?
10:39:28 <hpc> nobody ever wants to know what's in a makefile :P
10:43:29 <geekosaur> it'd have to be pretty gross to stop it from searching for the package first
10:44:44 <zbz> slack1256: Thanks! 
10:51:36 <tom__> ski: So reading through that paper. I think I comingled the rules that form the type scheme with type constraints when working through that problem.
10:52:13 <tom__> Type schemes are just infinite sets of type variable parameterisations
11:00:05 <ski> yea, tom__
11:00:40 <ski> do you think that paper helps understanding it better ?
11:00:42 <carbolymer`> hi, I cannot wrap my head completely around generics: I have U1 - how can I instantiate this constructor?
11:01:21 <ChaiTRex> carbolymer`: How is the type defined?
11:02:35 <ChaiTRex> carbolymer`: Ahh, never mind. You mean GHC.Generics.
11:03:53 * hackage sqlite-simple 0.4.18.0 - Mid-Level SQLite client library  https://hackage.haskell.org/package/sqlite-simple-0.4.18.0 (sigrlami)
11:05:24 <tom__> ski: Yeah it isn't too hard a read
11:05:40 <tom__> but there are quite a few things I don't understand 
11:05:50 <tom__> mainly the syntax
11:06:20 <slack1256> I've been reading on `space invariants` as presented on a post by apfelmus. It basically stablishes `seq` as an operator that operationally says "if you shoot my friend you have to shoot me`. What I don't understand is how do I determine which expressions to link without profiling?
11:06:24 <tom__> What does A |-  mean?
11:06:55 <ski> tom__ : "entail"/"implies"
11:07:07 <slack1256> Usually profiling takes me a lot of time, rebuilding, reading logs and I have to propose which two expression should be linked.
11:07:19 <ski> tom__ : in this case, "given the typings for variables on the left, the expression on the right has type"
11:07:54 <ski> tom__ : it's used to keep track of the (free) variables (and their types) in an expression
11:09:01 <carbolymer`> in other words how can I use `to` (GHC.Generics) with type with multiple constructors?
11:09:53 * hackage dobutokO2 0.5.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.5.0.0 (OleksandrZhabenko)
11:10:05 <tom__> ski: Thanks
11:10:38 <tom__> ski: So you basically have a set of judgements and then below the _________ you have a single judgement
11:13:08 <ski> tom__ : yes, the horizontal line means "if all things above hold true, then (by this rule), the thing below is also true"
11:18:21 <Tuplanolla> Sometimes there can be several conclusions too, for example in sequent calculus, tom__.
11:23:06 <tom__> Tuplanolla,: interesting, first time I have heard of sequent calculus
11:23:53 * hackage dobutokO2 0.5.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.5.1.0 (OleksandrZhabenko)
11:25:27 <tom__> Oh the mini hindley milner typing rules in that paper aren't actually that scary
11:34:53 * hackage dobutokO2 0.5.2.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.5.2.0 (OleksandrZhabenko)
11:39:32 <eugleo> Hey, I'm having trouble setting up ghcide to work with my project (both on ghc 8.8.3). Specifically, I'm getting a "member of hidden package" error, even though the packages are declared in the .cabal file. Anyone has any experience with this?
11:39:54 <eugleo> Please see this issue for (slightly) more details: https://github.com/digital-asset/ghcide/issues/470
11:42:17 <ski> Tuplanolla : but that's multiple conclusions of an entailment, not of an inference stroke
11:42:37 <Tuplanolla> Ah, indeed.
11:43:15 <ski> (although, it is possible to have multiple conclusions under an inference. there's a book, "Multiple-conclusion logic", that explores that idea, talking about graph structures being proofs. also abstracting over all kinds of inference rules)
11:43:41 <ski> tom__ : yea, that's why i linked to that paper for you, since i think it's not that scary to get into
11:45:28 <ski> tom__ : the notation for those typing rules (which is a common traditional one for them) is based on a logical proof/derivation/deduction system called "Natural Deduction". "Sequent Calculus" is pretty similar, although there's some differences. some type systems are presented in terms of a notation coming from Sequent Calculus, instead
11:45:42 <gentauro> when I import `import Foreign.Storable` in GHCi i can write something like this: `sizeOf (undefined :: Word8)` to see the size of that type used in memory. https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#v:poke
11:46:05 <gentauro> is there a way to see how much memory is used with custom defined data/newtypes?
11:46:35 <gentauro> `data Foo = F !Word` and `newtype Bar = B !Char`
11:48:10 <ChaiTRex> gentauro: Not sure, but you can use {-# UNPACKED #-} to use a little less.
11:48:20 <isovector1> is there a way to propagate fundeps through existential GADTs?
11:49:00 <isovector1> eg i have this: class Model a b | a -> b  and then this: data Temp b where Temp :: Model a b => b -> Temp a
11:49:07 <isovector1> but then this doesn't typecheck!
11:49:08 <isovector1> getTemp :: Model a b => Temp a -> b
11:49:08 <isovector1> getTemp (Temp b) = b
11:49:25 <gentauro> btw, this is a bit (pun intented) strange. `sizeOf (undefined :: Bool)` is 4 while `sizeOf (undefined :: Word8)` is 1. So it should be optimal to use `octets` over booleans?
11:49:43 <isovector1> i would expect getTemp to typecheck, but alas it complains that it can't unify `b ~ b1`
11:50:03 <gentauro> ChaiTRex: yeah, I'm reading https://chrispenner.ca/posts/wc at the moment :)
11:50:15 <gentauro> ChaiTRex: it just looks like the code gets more and more ugly xD
12:05:23 * hackage dobutokO2 0.5.3.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.5.3.0 (OleksandrZhabenko)
12:13:53 * hackage rank2classes 1.4 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.4 (MarioBlazevic)
12:20:50 <sm[m]> g'day all. How do you force haddock to regenerate docs even if they're up to date ?
12:23:05 <tom__> ski: So when I was finding the type constraints for fix, should I have been basing the typing rules on the syntax?
12:25:00 <tom__> I guess constraints for, two variable bindings and one use of function application
12:26:58 <ChaiTRex> sm[m]: Does --fforce-recomp work?
12:31:18 <ski> tom__ : yes, you need to consider each node of the AST
12:42:35 <tom__> ski: so for  fix f = f (fix f)
12:43:59 <sm[m]> ChaiTRex: I can say this: it has no effect when used like "stack build --haddock --fast --haddock-arguments='--optghc=-fforce-recomp'" or "stack build --haddock --fast --ghc-options='-fforce-recomp'
12:44:01 <tom__> My reasoning for there being a  tf = tb constraint -- fix f = f
12:44:19 <tom__> Is since f is essentially the identity function
12:44:44 <tom__> actually no
12:44:52 <sm[m]> but, "stack build --haddock --fast --force-dirty" does force haddock to run again. (And reconfigure, but not rebuild, of the code)
12:45:03 <monochrom> gentauro: Bool is marshalled to C int using C's convention (0 means false, 1 means true), so sizeof Bool is 4.  Word8 is marshalled in the unsurprising way.
12:45:05 <[exa]> eugleo: oh wow we've already hit that issue here once today
12:45:06 <tom__> fix f takes an a -> b 
12:45:25 <sm[m]> so that'll work. I'm trying to get control of haddock's output. I think --no-warnings is broken
12:45:44 <tom__> so fix f and f of course have different types
12:45:57 <monochrom> For reference, study the Haskell 2010 Report, the chapter on FFI very carefully.
12:46:24 <tom__> sorry I meant to say f is an a -> a
12:49:11 <[exa]> tom__: if I got it correctly you're trying to use hindley-milner to find the type of `fix`?
12:50:10 <monochrom> Except for cosmic-ray interference such as sometimes randomly butchering "fix f = f (fix f)" to "fix f = f".
12:51:36 <tom__> [exa]: yeah
12:51:54 <tom__> monochrom: blame the ray
12:51:54 <gentauro> monochrom: "Word8 is marshalled in the unsurprising way" so Word8 is just marshalled to C `char` type?
12:52:19 <monochrom> For maximum paranoia I will say uint_8 instead.
12:52:49 <monochrom> But even without paranoia it's unsigned char, not unknown-signedness char.
12:53:12 <gentauro> monochrom: isn't char always unsigned?
12:53:12 <tom__> fix is kinda confusing
12:53:15 <[exa]> tom__: okay, I'll rewrite it a bit to a form closer to HM: let fix = \f -> f (fix f)
12:53:20 <gentauro> you can't have negative chars ...
12:53:26 <monochrom> Bwhwahahahahahaha
12:53:44 <[exa]> tell him about the third signedness! :D
12:54:19 <monochrom> The irony is that most C compilers for x86 actually make char signed.
12:54:39 <monochrom> If you haven't noticed that you are probably not ready for either FFI or C.
12:54:51 <tom__> Is anyone ready for C
12:54:56 <[exa]> tom__: and we can start just by following what the HM tells us. Let's try deriving a bit of the type of '\f -> f(fix f)', which is an abstraction
12:54:59 <monochrom> I am.
12:55:04 <[exa]> C is easy
12:55:14 <merijn> gentauro: The signedness of char is implementation defined
12:55:20 <merijn> gentauro: Fun times!
12:55:29 <gentauro> oh, good old C :(
12:55:35 <merijn> gentauro: So unlike all the other integral types that default to signed, char does not
12:55:38 <sjhfeke> Hey, my academia starts teaching programming from C
12:55:48 <sjhfeke> so apparently all newbs are ready for C
12:55:56 <tom__> C is hard
12:56:16 <gentauro> C is just assembly with some "syntactic sugar" (cough, cough)
12:56:40 <monochrom> No, C takes away the carry flag, it can't be called assembly.
12:56:46 <gentauro> iirc, that was actually one of the task for OS. Write assembly to C and another task was write C to assembly
12:56:49 <monochrom> Also stack pointer.
12:56:49 <gentauro> :S
12:56:57 <[exa]> tom__: ...so we can apply the rule for lambda abstraction from the HM rules
12:57:01 <sjhfeke> Understanding Haskell is hard (for me)
12:57:16 <gentauro> sjhfeke: tell me about it
12:57:24 <monochrom> I am seriously about the stack pointer part because it is why GHC does not compile Haskell to C.
12:57:35 <gentauro> in order to make something usefull (fast) you aparently need to be a "hardcore guru in C"
12:57:58 <[itchyjunk]> I am a softcore guru in B
12:58:00 * [itchyjunk] hides
12:58:30 <ChaiTRex> [itchyjunk]: B is pretty outdated.
12:58:41 <[itchyjunk]> What about D?
12:58:41 <gentauro> all the "nice syntax" is pretty useless unless you call the right PRAGMAS
12:58:53 <ChaiTRex> [itchyjunk]: it's newer
12:59:02 <gentauro> and re-write the code to something that looks far worse than C/C++ ...
12:59:23 <gentauro> apparently you just need to "add a lot of comments"
12:59:24 <gentauro> :|
12:59:40 <[exa]> actually c++ makes sense as an assembly generator where C starts getting too verbose
12:59:56 <tom__> :fix
12:59:59 <tom__> :t fix
13:00:00 <lambdabot> (a -> a) -> a
13:00:31 <[exa]> tom__: ok sorry, back to the topic. :D  do you have some intuition about why the type should be as such?
13:01:14 <sjhfeke> Well for now I have just one question... To somehow learn how to do basic stuff in Haskell I thought I'd try to make a simple GUI calculator. But apparently there is not one standard GUI library in Haskell, but many. Which one do I start from? I'm thinking about GLUT for the sole reason that I found it here
13:01:14 <sjhfeke> https://www.haskell.org/platform/contents.html so perhaps if it's included by default it's the one I should start from
13:01:28 <ChaiTRex> :t fix fix
13:01:30 <lambdabot> error:
13:01:30 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
13:01:30 <lambdabot>       Expected type: a -> a
13:01:34 <sjhfeke> Does it make sense? Or would you recommend something else?
13:01:39 <tom__> It takes that function (a -> a) and then exploits laziness to apply it to itself repeatdly
13:01:40 <ChaiTRex> can't fix fix
13:01:40 <[exa]> sjhfeke: Try gloss!
13:01:54 <tom__> :t fix id
13:01:55 <lambdabot> a
13:02:13 <[exa]> :t fix ('a':)
13:02:14 <lambdabot> [Char]
13:03:23 <tom__> So the lambda application typing rule is that some applying the function (a -> b) will give you a b
13:03:37 <[exa]> sjhfeke: btw it's the first thing I'm giving to the students -- download gloss and draw some animated flying stuff. See https://hackage.haskell.org/package/gloss-1.13.0.1/docs/Graphics-Gloss.html
13:03:47 <gentauro> tom__: is this still lazy? `fix f = ($!) (($!) f $ ($!) fix f)` :o
13:03:50 <gentauro> :'(
13:03:54 <gentauro> Haskell makes me sad
13:04:01 <[exa]> gentauro: oh please. :D
13:04:18 <tom__> Apply this to  '\f -> f(fix f)' and fix f has to equal the type variable a in f :: a -> a
13:04:18 <sjhfeke> Hmm interesting ty
13:04:31 <gentauro> everytime I have to use `($!)` or `seq` I throw up a bit in my mouth ...
13:04:35 <sjhfeke> but it seems to be made for games
13:04:51 <[exa]> tom__: well there are more ways to put it, the rules are bidirectional -- you can take function typed '(a->b)' and parameter 'b', and will get a result of type 'a'
13:04:59 <tom__> gentauro: yes
13:05:37 <[exa]> tom__: (oh sorry, the other way: (a->b), parameter 'a', result 'b')
13:05:45 <tom__> gentauro: I would have thought that you are nesting strict values inside a lazy one
13:06:16 <tom__> because fix is lazy giving it strict values won't change fix
13:06:22 <[exa]> tom__: but it also works in reverse direction, if someone gives you 'f x :: b', you can guess that 'f::(? -> b)' and 'x :: ?', where the types under ? will be the same
13:06:23 <tom__> Am I right?
13:06:54 <tom__> [exa]: Ah yes
13:06:55 <[exa]> tom__: which is in fact the direction in which HM works
13:07:37 <gentauro> tom__: I have no clue what I did there :D
13:07:46 <[exa]> tom__: anyway, regarding the syntax, they usually write something like 'Γ |- a:x'
13:07:48 <gentauro> I just added ($!) everywhere I could
13:08:05 <tom__> :D
13:08:34 <tom__> gentauro: perfect interview question
13:08:46 <ChaiTRex> :t ($!)
13:08:47 <lambdabot> (a -> b) -> a -> b
13:09:16 <[exa]> tom__: the Γ there is usually a set of assumptions about types of variables present in the expression, e.g. you can easily say that with assumptions '{a:x}' you can prove that 'a' is of type 'x', written '{a:x} |- a::x'
13:09:22 <ChaiTRex> :t ($!) $! ($!)
13:09:24 <lambdabot> (a -> b) -> a -> b
13:10:09 <gentauro> tom__: I matched to reach a 64 space-leak yesterday xD
13:10:17 <gentauro> s/64/64 GB/
13:10:19 <gentauro> :o
13:10:30 <gentauro> there is some `strictness` not kicking in the way I want it
13:10:47 <tom__> :o
13:10:55 <ski> @quote mangler
13:10:56 <lambdabot> Pseudonym says: All hail the Evil Mangler!
13:11:16 <ski> s/::/:/
13:11:17 <tom__> [exa] gotcha
13:11:36 <gentauro> the problem is I can't use bang patterns in type definitions
13:11:53 <gentauro> cos I use `bottom` in a "clever" way (or at least I thougnt)
13:11:55 <[exa]> ski: ok
13:12:25 <ski>   ───────────────
13:12:28 <ski>   Γ,x : τ ⊢ x : τ
13:14:12 <[exa]> tom__: anyway the stuff above the line that ski showed us is "what is needed for assumption" and below is "what can be assumed from that". You can see that you can assume this rule for any Γ.
13:14:35 <sm[m]> how to run haddock from stack 25% faster and 600% quieter: 
13:14:35 <sm[m]> time stack build --fast --haddock --no-haddock-deps --no-haddock-hyperlink-source --haddock-arguments="--no-print-missing-docs"
13:14:35 <tom__> So is  Γ the name of the judgement
13:15:00 <ski> no
13:15:03 <[exa]> tom__: Γ is usually called basis or context sometimes
13:15:13 <ski> or (typing) environment
13:15:13 <tom__> right
13:15:18 <[exa]> judgement is the sentence "something has type X"
13:15:31 <ski>   Γ ⊢ e : τ₀ → τ₁  Γ ⊢ e₀ : τ₀
13:15:34 <ski>   ──────────────────────────── →ℇ
13:15:38 <ski>   Γ ⊢ e e₀ : τ₁
13:16:07 <ski> is "function arrow elimination" (that's the name of the inference rule, written ⌜→ℇ⌝ for short)
13:16:33 <tom__> How does that work
13:16:56 <tom__> Γ ⊢ e : τ₀ → τ₁   is fine
13:16:58 <[exa]> tom__: that's the thing with the function application type I wrote above, only more rigorous
13:18:30 <tom__> [exa]: Sorry can't seem to find it now
13:19:18 <ski> ⌜e⌝ is the function expression, e.g. `(> 2)', and ⌜e₀⌝ is the argument expression, e.g. ⌜3⌝
13:20:22 <tom__> oh I see
13:20:29 <tom__> so function application is a space
13:20:49 <tom__> So now the only bit I dont get is →ℇ
13:20:49 <tom__> <ski>   Γ ⊢ e e₀ : τ₁
13:21:02 <tom__> no sorry
13:21:07 <tom__> meant to just type  →ℇ
13:21:10 <[exa]> tom__: that's just the name of the rule
13:21:43 <tom__> Oh and then we can use ℇ into other rules
13:21:45 <[exa]> usually written next to the deduction rule, so that people don't get lost when browsing the rules
13:22:45 <merijn> Specifically the e (in a fancy font) stands for "elimination", so "→ℇ" is "-> elimination"
13:23:14 <tom__> merijn: thanks!
13:26:00 <ski>   Γ,x₀ : τ₀ ⊢ e₁ : τ₁
13:26:03 <ski>   ─────────────────────── →ℐ
13:26:07 <ski>   Γ ⊢ λ x₀ ↦ e₁ : τ₀ → τ₁
13:26:17 <ski> is "function arrow introduction"
13:26:33 <ski> aka "lambda abstraction"
13:26:52 <phadej> (I have seen just ->I and ->E, fancy font doesn't add much)
13:27:57 <tom__> So that just establishes an equivalence between lambdas and function arrows?
13:28:26 <ski> it tells how to assign types to lambda expressions
13:29:00 <ski> it tells that ⌜x₀⌝ is a locally bound variable, which is in scope in ⌜e₁⌝
13:29:46 <tom__> So are these rules composable in any way?
13:30:02 <ski> locally bound, since ⌜x₀⌝ occurs to the left of the "turnstile" symbol (read "entails", or maybe "implies"), above the inference line (horizontal line), but not below it
13:30:16 <berndl> Can someone explain to me the reasons for ASetter, ALens, APrism, etc. in Lens?
13:30:30 <monochrom> Yes, if you use these rules to get a large expression and its type, you get a tree.
13:30:50 <tom__> monochrom: :)
13:31:01 <ski>   Γ ⊢ e₀ : τ₀  Γ ⊢ e₁ : τ₁
13:31:03 <[exa]> tom__: if you're trying to guess a type of something, you can "unify" it with the expression below and will get a 1] better hint about types 2] list of presumptions needed to verify for getting a more precise type
13:31:04 <ski>   ──────────────────────── ×ℐ
13:31:13 <ski>   Γ ⊢ (e₀,e₁) : τ₀ × τ₁
13:31:23 <monochrom> Build up from subexpressions to parent expressions.  Or break down a big expression into subexpressions.
13:31:31 <ski> is the rule for typing pairs, "pair type introduction"
13:32:58 <tom__> [exa]: What do you mean by unify?
13:33:19 <tom__> Subsituting the expression above the _____ with below
13:37:07 <ski>   ──────────────────────────   ───────────────────────────
13:37:12 <[exa]> tom__: say you want to guess type of 'λa -> a'. You take the deduction rule that results in a lambda, have a look at the lower part ('Γ ⊢ λ x₀ ↦ e₁ : τ₀ → τ₁'), assume that you need to rename it a bit (x₀=a and e₁=a), and get partial information that 'λa.a : τ₀ → τ₁', GIVEN you also satisfy the presumptions
13:37:14 <ski>   b : Bool,i : Int ⊢ i : Int   b : Bool,i : Int ⊢ b : Bool
13:37:19 <ski>   ──────────────────────────────────────────────────────── ×ℐ
13:37:23 <ski>   b : Bool,i : Int ⊢ (i,b) : Int × Bool
13:37:29 <ski>   ───────────────────────────────────────── →ℐ
13:37:33 <ski>   b : Bool ⊢ λ i ↦ (i,b) : Int → Int × Bool
13:38:44 <ski> is a small example of a typing derivation, of the expression ⌜λ i ↦ (i,b)⌝ (`\i -> (i,b)' in Haskell), having type ⌜Int → Int × Bool⌝ (`Int -> (Int,Bool)' in Haskell), depending on the free variable `b', having type `Bool'
13:39:36 <[exa]> tom__: and the assumptions you need to satisfy get from the upper part of the rule ('Γ,x₀ : τ₀ ⊢ e₁ : τ₁'). Which, after getting your variable names in place, reduces to satisfying 'Γ, a:τ₀ ⊢ a : τ₁'
13:39:45 <ski> you should see that this is a tree, and that the typing environment grows, when reading the tree from bottom (the root, the end conclusion of the typing derivation, assigning a type to the whole expression), upwards
13:40:26 <[exa]> tom__: that can be satisfied easily by assuming τ₀ == τ₁  (and from the original "axiom" rule)
13:41:44 <ski> tom__ : oh, and ⌜Γ⌝,⌜x⌝,⌜x₀⌝,⌜e₀⌝,⌜e₁⌝,⌜τ⌝,⌜τ₀⌝,⌜τ₀⌝ are all meta-variables, in these rules
13:42:24 <[exa]> tom__: and with knowing τ₀ == τ₁, you know that the type you derived for the whole expression (τ₀ → τ₁) is the same as 'τ₀ → τ₀', equivalent to haskell 'a->a', which you would naturally expect to be a type of 'λa -> a'
13:42:40 <tom__> So it is like an AST for parameterised typing rules?
13:42:46 <ski> ⌜τ⌝,⌜τ₀⌝,⌜τ₀⌝ standing for types (just like `_a',`_b',&c. from before), while ⌜e₀⌝,⌜e₁⌝ stand for expressions, ⌜x⌝,⌜x₀⌝ for variable identifiers, and ⌜Γ⌝ for variable typing contexts
13:43:58 <tom__> [exa]: makes sense I think :)
13:45:56 <[exa]> tom__: anyway the AST and grammar derivation trees are very similar to this kind of deduction, except here you need some extra "tools" in seeing equivalences (as with τ0 and τ1) and ignoring the order of assumptions (a bit complicated with ASTs)
13:46:40 <ski> tom__ : did my attempts at explanation make any sense ?
13:47:21 <tom__> ski: Yes
13:47:53 <tom__> the bit I am wondering about is ...
13:48:36 <nil> lovely inference rules, ski
13:49:06 <tom__> ah no the bottom bit is the conclusion and assigns a final type to the entire expression?
13:49:16 <tom__> Built up from the tree of sub expressions
13:49:35 <ski> tom__ : in each instance of an inferene rule, as in the tree above for ⌜λ i ↦ (i,b)⌝, the meta-variables in that rule will get instantiated to (replaced by) actual phrases (expressions, types, variable identifiers, perhaps also other things, like patterns, declarations) from the program, also the meta-variables for variable typing environment getting replaced by actual specific ones, like ⌜b : Bool⌝ and ⌜b : Bool,i : Int⌝
13:50:27 <tom__> ski: :D ahh yes
13:51:23 * hackage ghc-tags-plugin 0.1.2.1 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.2.1 (coot)
13:51:30 <ski> tom__ : also, note that despite the variable typing rule (the first rule i gave above, and which i didn't give a name for) saying ⌜Γ,x : τ ⊢ x : τ⌝, ⌜x : τ⌝ doesn't actually have to occur to the right of the other variable typings ⌜Γ⌝. typing environments are (normally) unordered. that's how we could derive ⌜b : Bool,i : Int ⊢ b : Bool⌝ in the example derivation
13:54:47 <tom__> Think I am gonna head off now
13:55:00 <tom__> Thanks so much [exa] and ski
13:55:06 <tom__> I really did learn a lot today
13:55:26 <[exa]> tom__: I guess you could try to mechanically derive the type for 'fix' now
13:56:04 <tom__> [exa]: Yeah I am gonna give it another shot tomorrow :)
13:56:43 <sjhfeke> What does an exclamation mark before a type name mean
13:56:44 <sjhfeke> ?
13:57:20 <[exa]> tom__: one extra trick is needed because there's recursion in that, but that can be surpassed with a bit of thinking and one extra assumption in the basis
13:57:35 <ski> tom__, have fun with typing rules :)
13:57:45 <[exa]> sjhfeke: in what context? in data definition?
13:57:46 <ski> sjhfeke : in a `data' declaration ?
13:57:54 <ski> sjhfeke : it means strict component, there
13:59:28 <sjhfeke> ok ty
14:02:28 <hololeap> is there any kind of QA for what can go up on hackage? it seems like any ol' random thing gets uploaded there
14:02:42 <[exa]> sjhfeke: technically it has some nice properties -- you can e.g. expect that the value is at least as defined as the containing structure, and there's no boxing overhead in the data so the actual data is smaller and various data-relevant tasks get generally faster
14:03:12 <Cale> hololeap: Well, admins can reactively deal with things that are actively harmful
14:03:27 <Cale> hololeap: But there's no particular standard of quality
14:03:59 <[exa]> hololeap: 'cabal check' usually helps
14:04:16 <EvanR> maybe there should be a hackage "greatest hits" album or something
14:05:28 <hololeap> i'm just curious because i have refrained from putting anything up on hackage until it is stable, has good docs, etc. but i see a lot of random stuff on there. i'm not talking about anything harmful, just a lot of clutter
14:06:38 <[exa]> hololeap: 'stable' and 'useful for others' are only partially related concepts :]
14:07:02 <hololeap> i suppose i'm looking for a page on hackage etiquette or something. a checklist for what qualifies as a "good" package
14:07:33 <hololeap> yeah useful for others is a tricky thing to quantify, especially for a new project
14:08:40 <[exa]> if the software solves a problem and the unstable parts are clearly marked, I guess it should be OK
14:08:41 <ski> nil, merci
14:09:53 * hackage macaroon-shop 0.1.0.0 - A toolkit for working with macaroons  https://hackage.haskell.org/package/macaroon-shop-0.1.0.0 (IanShipman)
14:09:58 <hololeap> i notice that ekmett seems to be strict about what he posts on hackage these days, but i suppose that could be in part due to him being something of a brand name
14:09:59 <merijn> hololeap: Useful for others mostly means "don't upload throwaway homework that contributes no value"
14:10:52 <merijn> hololeap: Especially since with v2-build its fairly easy to depend on git repos for "work in progress" stuff, so hackage is mostly for things that are ready enough for other people to start experimenting with it
14:11:29 <hololeap> i mean that package that makes experimental music from mono audio and Ukranian text... is it useful for others? it's hard to say...
14:12:09 <hololeap> merijn: good point
14:12:53 * hackage rose-trees 0.0.4.5 - Various trie implementations in Haskell  https://hackage.haskell.org/package/rose-trees-0.0.4.5 (athanclark)
14:13:18 <merijn> hololeap: tbh I don't believe that has anything to do on hackage
14:13:29 <merijn> If only because half the version releases don't even compile
14:13:55 <hololeap> lol
14:13:59 <merijn> Hackage uploads have a cost (not a very high one, but still)
14:14:15 <merijn> So people should exercise *some* restraint
14:14:38 <merijn> hololeap: Not even joking, check the changelog sometime
14:14:48 <hololeap> ok. that's what i figured. but no official PSAs about it so far?
14:14:58 <merijn> hololeap: About what?
14:15:10 <hololeap> "don't upload your random crap to hackage, plz'
14:15:24 <merijn> It says so right on the page, but people don't read
14:16:21 <monochrom> I testify that my students don't read either. :)
14:16:31 <hololeap> hm... maybe it's not very obvious because i don't remember seeing it
14:18:27 <merijn> hololeap: 2nd paragraph of the upload page...
14:18:31 <hololeap> ah, this has a lot of what i was looking for. must have overlooked it before: https://hackage.haskell.org/upload
14:20:15 <hololeap> ok, cool... just curious :)
14:21:47 <hololeap> so packages are never deleted? they don't prune packages that haven't been updated in 10 years?
14:22:09 <hpc> why would they need to stop existing?
14:22:13 <monochrom> I always supported deleting more code. :)
14:22:23 <monochrom> s/supported/support/
14:22:45 <int-e> hey some code might even still work after 10 years
14:22:55 <hololeap> that _is_ true
14:23:24 <hololeap> and i suppose the hackage search feature is pretty good about putting working packages at the top
14:23:58 <monochrom> I think it doesn't. I think it can't even tell.
14:24:34 <hololeap> well, it seems to sort by dl count or something... i could be wrong but that's what it seemed like
14:25:42 <jle`> i have a lot of projects over 10 years old
14:25:50 <jle`> i would be sad if i tried to build them and then whoops the packages are no longer online
14:26:55 <hololeap> ok, 10 years old wasn't a good choice for being qualified for deletion. unmaintained? uncompilable? i understand there's no simple way to determine which packages live and die
14:27:12 <hololeap> but the downside is that at some point all the cool names will be taken :(
14:27:30 <monochrom> megaparsec39485 :)
14:28:06 <hololeap> :(
14:28:07 <[exa]> gigaparsec teraparsec petaparsec
14:28:10 <int-e> packages that should be deleted. 1) malicious ones. 2) probably if there's a legal claim against them that threatens the hackage operators.
14:29:50 <int-e> Ranking search results is a sane thing to do though, and downloads are not the worst metric for that I suppose.
14:33:16 <jle`> hololeap: there is no 'uncompilable' for reproducable builds. i can always compile my 10 year old projects on a 10 year old ghc
14:33:17 <jle`> well, ideally
14:34:08 <merijn> hololeap: How would you decide what to delete?
14:34:28 <merijn> hololeap: If someone's private project depends on a hackage library and it's arbitrarily purged it breaks
14:35:08 <glguy> merijn: I don't think private use of packages is one of the considered factors
14:35:24 <glguy> things on hackage are intended to be useful to be community
14:35:55 <merijn> Incidentally, I really wish someone with some actual authority on hackage would tell the Ukrainain sound guy to hold back on his 10 million releases a bit, though :\
14:36:38 <merijn> glguy: If there's 20 projects on github, but not on hackage that all depend on hackage package foo, then that seems relevant in the decision that foo cannot be deleted
14:37:11 <merijn> hololeap: Anyway, hackage's data design is "append only", so deleting/purging things is complicated
14:37:32 <int-e> glguy: I think the argument here is that a package may be useful even if it requires an ancient ghc to be built and has not been maintained in the last 10 years.
14:37:53 <hololeap> i don't have a good answer for that. i figured this was something that had been discussed before. in gentoo, packages that no longer compile on the current ecosystem or are unmaintained are deprecated with a warning and then removed after 30 days, but that's a very different kind of ecosystem
14:38:08 <int-e> So there's an archival angle to hackage that should not simply be disregarded.
14:38:53 <hololeap> maybe marking packages as archived... then you would need to explicitly search for them instead of them coming up automatically with `cabal list`
14:39:00 <merijn> hololeap: Hackage functions, as int-e points out, as an archive. Hence, "try to be useful to the community so we don't archive garbage"
14:39:06 <hololeap> cabal list --archive
14:39:24 <merijn> hololeap: The problem is how would that affect the index design?
14:39:50 <hololeap> idk... add an "archived" boolean field?
14:39:57 <int-e> hololeap: I'm all for penalizing outdated packages in the search, but obviously that takes effort.
14:40:14 <merijn> hololeap: That would require rewriting old parts of the index, which would mean overhauling the entire index design
14:40:30 <merijn> hololeap: Right now the index is append only so you can do incremental appends, etc.
14:40:40 <int-e> (It would probably have to be done outside of the main hackage index, unless you want to (ab)use the revision mechanism for this.)
14:40:58 <hololeap> well i admit i'm very ignorant about all this
14:41:51 <Cale> I'm not sure the append-only index will be able to remain append-only forever.
14:42:44 <merijn> Cale: Sure
14:43:05 <merijn> But any time going into "redesigning everything" is time I'd rather see invested in improving cabal-install, etc.
14:45:09 <int-e> Cale: I believe the client does account for the possibility that the index is rebuilt from scratch. It's just expensive to download it all (87MB) compared to updating it incrementally. So it's better for deletions to be extremely rare rather than a routine matter.
14:45:58 <int-e> A different design might cope with deletions better, obviousy.
14:46:02 <int-e> *ly
14:47:23 * hackage tries 0.0.6.1 - Various trie implementations in Haskell  https://hackage.haskell.org/package/tries-0.0.6.1 (athanclark)
14:48:06 <sjhfeke>  Ambiguous type variable `a0' arising from the literal `0' prevents the constraint `(Num a0)' from being solved. 
14:48:15 <sjhfeke> Ugh. Any way to enter a literal integral zero? 
14:48:21 <merijn> sjhfeke: That's fairly innocuous
14:48:22 <sjhfeke> Idk, 0i?
14:48:32 <int-e> :t 0 :: Integer
14:48:34 <lambdabot> Integer
14:48:37 <merijn> sjhfeke: You can simply write "(0 :: Int)"
14:48:40 <int-e> :t 0
14:48:41 <lambdabot> Num p => p
14:48:46 <sjhfeke> ah thanks
14:49:04 <int-e> Ah yes, you'll need parentheses in most contexts.
14:49:28 <merijn> sjhfeke: Basically ambiguous type variable there means "you're using a polymorphic literal in a place with insufficient information for the compiler to deduce which *actual* type you wanted"
14:53:42 <Nolrai> Okay I feel like I am missing something stupid. Why is `data Options where  RunCommand { file :: FilePath, steps :: Int, inputStyle :: FromCell Text, outputStyle :: FromCell Text, exit :: Maybe (IO ())} :: Options` giving me a parse error on the `{`?
14:54:17 <solonarv> you're mixing GADT syntax and record syntax
14:55:19 <solonarv> you can do that, but the syntax isn't what you used; instead it is: data TyCon where DataCon :: { <fields> } -> TyCon
14:56:04 <Nolrai> Oh, I put the :: in the wrong place.
14:56:56 <Nolrai> Did this change at somepoint?
15:00:31 <Nolrai> Yes. Yes it did. Okay. I will endevor to check the version of GHC my docs are refering too.
15:40:29 <suzu> when did it change?
15:47:11 <pavonia> I've never seen the former syntax
15:53:26 <Nolrai> 6.6 has a different syntax. Don't know when the transition was.
15:53:43 <d2ci8xc5> huh?
16:13:37 <int-e> @tell Nolrai The GADT record syntax changed between ghc-7.6.3 and ghc-7.8.1, so 2014.
16:13:37 <lambdabot> Consider it noted.
16:18:06 <d34df00d> Hi!
16:18:36 <d34df00d> What's a good way to read exactly n : Int characters off a System.IO.Handle?
16:18:57 <hpc> hGet
16:19:09 <hpc> if you want up to, hGetSome
16:19:27 <hpc> or hGetNonBlocking
16:20:21 <d34df00d> Awesome, thanks!
16:20:25 <d34df00d> hGet is exactly what I need!
16:20:29 <d34df00d> Forgot this stuff exists in BS.
16:21:29 <d34df00d> Coincidentally my chars are all ascii, so I'm good.
16:31:40 <int-e> (the timing of that syntax change is slightly amazing because the patch that changed the syntax dates back to 2011... but it wasn't merged until much later.)
16:34:33 <shachaf> What syntax change?
16:34:40 <shachaf> Oh, hmm, I remember this.
16:41:53 * hackage network-msgpack-rpc 0.0.6 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/network-msgpack-rpc-0.0.6 (iphydf)
16:52:23 * hackage archive-tar-bytestring 0.1.0.0 - Common interface using the tar-bytestring package  https://hackage.haskell.org/package/archive-tar-bytestring-0.1.0.0 (vmchale)
17:07:07 <jle`> is there a way to pretty-print haskell-src-exts ast including its comments in the right places?
17:07:35 <jle`> ah, i think i found it. ExactPrint
17:08:13 <jle`> hm, but it's a little tricky to use if i am generating the AST by ahnd instead of parsing it
17:08:47 <jle`> i wonder if there's a better haskell AST library i can use
17:12:54 <solonarv> GHC itself, I guess?
17:14:30 <jle`> ah yeah, investigating that one now. it's quite a behemoth
17:16:11 <solonarv> there's a ghc-exactprint library which might be relevant/useful
17:16:54 <jle`> exactprint seems to just be the same issues as ExactPrint from haskell-src-exts
17:17:03 <jle`> hm basically i want to be able to assemble an AST for something like:
17:17:16 <jle`> type MyType = (Int, String {- hi -}, Bool)
17:17:24 <jle`> and have it print like that
17:17:52 <jle`> using ExactPrint i can generate this by hand but only if i like...give an exact line nuber/column number for the comment
17:21:09 <jle`> ah it looks like the ghc  api does support this ... it lets you treat {- blah -} syntactically as a type
17:21:30 <jle`> funky
17:49:19 <jle`> b 3
17:49:46 <jle`> so i had blocked out in my mind how much of a tangle the ghc api is :|
17:50:23 <jle`> i can't even parse a string into AST in ghci, or i can't figure out, heh
17:51:06 <jle`> so ican't even be sure which of the HsType constructors is for a type constructor like 'String' or 'Int'
17:59:57 <pavonia> HsTyVar, I'd say
18:02:53 <jle`> pavonia: heh, thanks :) going with that guess for now, even though it's kind of weird to think of String as a TyVar
18:05:05 <pavonia> Yeah, but an annotation in the source suggests that it can be any of type var, data or type constructor
18:06:37 <jle`> ah, the source code seems to give a lot of information that the documentation does not :O
18:16:42 <slack1256> On sqlite-simple, the execute command accepts a stringlike command. Can this argument be made multiline?
18:30:54 <dan60> Hi - my first time using freenode
18:31:02 <slack1256> dan60: Welcome
18:31:07 <dan60> You can't view previous chat history?
18:31:45 <slack1256> http://tunes.org/~nef/logs/haskell/?C=M;O=D
18:32:15 <slack1256> The info shown when you join the channel says were the logs are. There are another prefered services as a pastebin there.
18:32:32 <iqubic> dan60: In general, no. But some channels do have public logs, like the one slack1256 linked to just there.
18:32:40 <dan60> Gotcha, thanks guys :)
18:36:53 * hackage hspec-snap 1.0.2.0 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-1.0.2.0 (imalsogreg)
18:52:43 <sm[m]> https://matrix.to/#/#freenode_#haskell:matrix.org is another way to see history
19:24:07 <jle`> dan60: think of it like shipping channels in the ocean
19:24:50 <jle`> dan60: you have to catch them in real time, otherwise there's no evidence of the meeting left behind
19:46:17 <slack1256> I got some network event that trigger a DB read every 4-5 min. I was thinking that instead of keeping the conection live I could close it and just open, read the DB and close it each time a new network event happens.
19:46:49 <slack1256> It simplifies my code & logic but feels "wrong". Does anyone also do this?
19:56:53 * hackage servant-snap 0.8.5 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.8.5 (imalsogreg)
22:23:34 <isovector1> is there some way to implement `(Model a b, Model a b') => b :~: b'` if i have a fundep `Model a b | a -> b `?
22:24:47 <isovector1> ripping my hair out over this and considering saying fuck it and going straight to the unsafeCoerce solution
22:51:22 <slack1256> On cryptonite, I got a `Digest SHA1` that I want to put on a DB as Text. How do I cast it?
22:52:27 <slack1256> There is a Show instance...
22:52:30 <slack1256> nvm
22:55:15 <jle`> isovector1: in the past when i've tried this, i have been told that this is not possible by design
22:55:25 <jle`> that if you're using fundeps to prove equality, you'r using them wrong
22:55:36 <jle`> i think it was a policy of one of the simons maybe
22:55:42 <jle`> but i've just heard it passed down as lore
22:55:54 <jle`> i have unsafeCoerce'd this in the past
23:15:53 <glguy> Fundeps worked like that in hugs but are broken in GHC, which was good for a while because due to other bugs in GHC it wasn't true
23:31:23 * hackage pandora 0.2.3 - A box of patterns and paradigms  https://hackage.haskell.org/package/pandora-0.2.3 (iokasimovmt)
23:40:45 <idnar> @hoogle Functor f => (a -> b) -> (t -> f a) -> t -> f b
23:40:46 <lambdabot> Control.Applicative.Tools (<.>) :: Functor f => (a -> b) -> (c -> f a) -> c -> f b
23:40:54 <idnar> oh right-
23:41:48 <idnar> I keep deciding not to use that name because lens took it
