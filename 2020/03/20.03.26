00:00:11 <dsal> Uploading sometimes fails in weird ways from the camera, barely ever works on the phone, and does weird stuff from their web thing.  I can theoretically resume an upload across a reboot, but that's not the bits I was working on tonight.
00:01:22 <dsal> Since I understand all their telemetry, I can do cool stuff like search for video that was taken within a particular date range at a particular place and has a face that's probably smiling and I pressed the little "highlight" button before I uploaded.
00:01:51 <N3RGY> neat
00:02:10 <N3RGY> how much video are you storing? I could see $5/mo for unlimited going poorly for them haha
00:02:13 <dsal> I also figured out how to modify state on their end, so I made a little SQL interface to *their* end so I could fix up the ~300 things they told me came from an "Unknown" camera while their telemetry told me came from a Hero 8 or whatever.
00:02:34 <dsal> 2,078 totaling 852.57 GB
00:03:04 <dsal> Yeah, the first reason I wanted to do this was because I figured they'd shut down at some point...  I can pretty quickly make a tool to extract all data from the service.
00:03:44 <dsal> Their UI takes weeks to scroll through.  I built a crossfilter-like thing in elm that gives me ~instant access to all the things.  This has been a fun project.
00:30:16 <N3RGY> dsal: nice, 850G@$5/mo is quite good. They're definitely taking a loss on that haha
00:31:46 <N3RGY> In the past I interned at a consumer cloud storage company and a popular intern move was to grant oneself like 100PB of storage through the internal interface. Last I checked, they haven't reverted that haha
00:35:48 <kritzefitz> join #debian-ftp
00:35:54 <kritzefitz> Sorry
01:53:02 * hackage th-instance-reification 0.1.5.1 - Fixed versions of instances reification functions  https://hackage.haskell.org/package/th-instance-reification-0.1.5.1 (NikitaVolkov)
03:10:56 <jpcooper> Is there any way to limit the number of times Criterion measures the run-time of something?
03:40:42 <zincy_> Ugh
03:41:19 <zincy_> What is the point in a type class like this 
03:41:21 <zincy_> class Env a where myEnv :: a
03:44:47 <akegalj_> zincy_: I guess it is to provide different defaults, like different configuration - just guessing
03:47:32 * hackage dobutokO2 0.18.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.18.0.0 (OleksandrZhabenko)
04:18:42 <zincy_> akegalj_: Yeah it is definitely an antipattern to define a type class for this when we have Reader
04:19:19 <zincy_> In fact not even reader
04:19:52 <zincy_> You just define different types for different configs data MyConfigOne ... dataMyConfigTwo
04:48:04 <reactormonk> With recursion-schemes, how do I run the function over one layer? I've got the function which adds the annotation from the value itself at hand, and the annotation has already been added to the lower layers
04:49:09 <janulrich> hello
04:49:27 <janulrich> i have a question to the code shown here: http://dev.stephendiehl.com/fun/006_hindley_milner.html
04:49:57 <janulrich> what does the t@(TVar a) mean in this context: instance Substitutable Type where
04:49:57 <janulrich>   apply _ (TCon a)       = TCon a
04:49:57 <janulrich>   apply s t@(TVar a)     = Map.findWithDefault t a s
04:49:57 <janulrich>   apply s (t1 `TArr` t2) = apply s t1 `TArr` apply s t2
04:50:08 <janulrich> thanks in advance
04:51:56 <Ferdirand> it means t is an alias for the expression (TVar a)
04:53:28 <Ferdirand> if you just had (TVar a) as the pattern, you'd then need to write the case as Map.findWithDefault (TVar a) a s, and that's not very nice
04:54:31 <jackdk> janulrich: https://www.haskell.org/tutorial/patterns.html they are called "as-patterns"
04:55:12 <janulrich> thanks alot :D
05:04:40 <akegalj_> zincy_: I agree, Reader or even simple constat as haskell value should be enough 
05:07:32 * hackage cobot 0.1.1.1 - Computational biology toolkit to collaborate with researchers in constructive protein engineering  https://hackage.haskell.org/package/cobot-0.1.1.1 (zmactep)
05:18:28 <zincy_> In a distributed system what is a good way of keeping track of whether a group of async requests have had responses?
05:18:50 <zincy_> New territory for me. The naive way is to store the api request data in the DB
05:19:00 <zincy_> Is there a better way?
05:19:59 <frdg> should I learn about category or type theory first? My motivation for learning these theories is to be able to apply them in Haskell.
05:21:11 <merijn> frdg: Type theory, then
05:21:52 <frdg> merijn: ok. Ive got a book for both!
05:22:08 <merijn> frdg: The direct applicability of category theory to Haskell is overblown. For beginners it offers almost 0 useful insight for programming in Haskell
05:22:45 <frdg> interesting
05:23:43 <merijn> frdg: I would say that even for experts category theory has only marginal usefulness for programming in Haskell
05:24:28 <merijn> Not to say it isn't interesting or you shouldn't learn it, just that, if the goal is "becoming good at Haskell" then category theory should probably somewhere at the bottom of your todo list
05:25:06 <frdg> merijn: glad I asked cause I was planning on category theory being my next book.
05:26:18 <merijn> frdg: Yeah, somehow the "non-Haskell internet" has decided "Haskell is based on category theory", despite the fact that that statement is objectively untrue :)
05:27:53 <merijn> Now, edwardk and some others have leveraged a ton of that stuff while inventing stuff like lenses, so there is *some* useful stuff there, it's just that there's things that are easier and more directly useful (like basics of type theory, lambda calculus, a bit of algebra, etc.)
05:28:16 <akegalj_> frdg: if you dont have functional language experience I would recommended https://github.com/MostlyAdequate/mostly-adequate-guide , which learns concepts that you will find in Haskell and other functional languages through javascript (it also touches on some category stuff in the end). The book is still wip 
05:30:14 <akegalj_> frdg: oh - maybe you do know haskell - sorry if I missunderstood
05:31:21 <frdg> akegalj_: im learning at the moment 
05:32:17 <frdg> I know zero javascript 
05:36:05 <lortabac> frdg: if your goal is learning Haskell I'd say even type theory is a weird way of reaching that goal
05:37:21 <frdg> lortabac: I don't know what my goal is really. Its just to learn in general 
05:42:24 <suppi> I'd like to +1 what merijn is saying
05:45:37 <merijn> The usefulness of type theory depends on both your Haskell skill and interests. I don't think it's particularly useful for writing Haskell. But I think a better understanding of programming languages and their design is always good, so I think every programmer should learn the basics of that anyway ;)
06:09:27 <dignissimus> Do you think I can use Haskell for data science like I would python?
06:09:49 <dignissimus> Is it something worth trying out?
06:10:23 <[exa]> dignissimus: most of the tools are available, yes
06:10:56 <[exa]> dignissimus: except 80% of the data science is in fact reporting and plots, and there aren't any strikingly good haskell plotting libraries yet
06:11:55 <maerwald> dignissimus: probably impossible to compare to the python ecosystem
06:28:32 * hackage mr-env 0.1.0.2 - A simple way to read environment variables in Haskell  https://hackage.haskell.org/package/mr-env-0.1.0.2 (meowgorithm)
06:41:03 <dkdk> ohh, Thank god I am given access again
06:41:44 <dkdk> last time I pasted a long text and then suddenly I was denied to login ðŸ˜Š
06:42:09 <maerwald> dkdk: so you figured out what a pastebin is?
06:43:12 <dkdk> I knew it, but I thought I don't need it , generally I use slack where you can paste code samples :)  
06:47:40 <maerwald> dkdk: I think agreement is that 3 lines are ok, but not more
06:48:26 <dkdk> maerwald: thanks for letting me know!
06:48:43 <MarcelineVQ> ye I'd say 3 too
06:56:22 <frdg> is there a command that lets me look at all types with a certain instance? I am trying to see every type that has an instance of Foldable
06:57:49 <maerwald> you can trigger an ambiguous instance error and ghc will show you a huge dump of possible instances?
06:58:17 <maerwald> These will only be the ones in scope, ofc
06:59:20 <yushyin> ghc8.10's :instances command?
07:00:33 <frdg> maerwald: if its easy would you mind giving me an example of code that would do this?
07:02:59 <lortabac> does anyone have experience with hindent? does it always mess up type family definitions or am I doing something wrong?
07:04:21 <maerwald> frdg: elem 'c' undefined
07:04:32 <frdg> thank you!
07:04:58 <maerwald> frdg: https://gist.github.com/hasufell/8bd920e1d5e6dbf3d58a5fa3475309d1
07:05:28 <maerwald> also need -fprint-potential-instances
07:06:09 <frdg> maerwald: thanks again
07:09:01 <Ariakenom> aveltras: I realized the stm solution from before has quadratic performace scaling. since each update wakes all the threads. using this stm specialized set would solve it https://hackage.haskell.org/package/stm-containers-1.1.0.4/docs/StmContainers-Set.html
07:11:08 <aveltras> Ariakenom: thanks for the info, i'll look into this very soon :)
07:11:54 <Ariakenom> it may not matter, just fyi
07:12:26 <aveltras> haven't written benchmark yet so can't say
07:17:08 <mr_sm1th> Hello. I had a course in Functional Programming with Haskell in university. Haven't used it since. Had a job at a Python shop for 7 months. Feel like picking up Haskell again but I'm a bit overwhelmed with all the different learning resources out there. Can anyone make a recommendation for me?
07:18:19 <mr_sm1th> I'm not a CS or Math major. My motivation for picking up Haskell is to become a software engineer that's able to write more robust software that's safer to refactor.
07:19:22 <mr_sm1th> I really feel like I'm mostly writing brittle throw-away code at my job. And writing Python feels very shaky even compared to Java and C++.
07:19:45 <Cale> mr_sm1th: Graham Hutton's book is a quality place to start
07:19:53 <frdg> mr_sm1th: wow a question I can answer. Ive been loving "Haskell Programming From First Principles"
07:20:50 <jbrock> hi @mr_sm1th, there are a lot of Haskell learning resources. I learned Haskell first from Learn You a Haskell for Great Good. Maybe it's not the best Haskell book, but I like it. I adapted it into a Jupyter notebook so that anyone can read it for free and all the examples are in a live Jupyter code environment, with zero setup. https://mybinder.org/v2/gh/jamesdbrock/learn-you-a-haskell-notebook/master?urlpath=lab/tree/learn_you_a_haskell/
07:20:52 <jbrock> 00-preface.ipynb
07:22:16 <mr_sm1th> Thanks! I'm familiar with all three. I already had an introduction to Haskell but maybe I should go through one of these introductory courses again to re-familiarize myself.
07:23:30 <aveltras> if you're ok with the length of the book, haskell programming for first principles is really nice
07:24:49 <frdg> mr_sm1th: I started with Learn You a Haskell and I think its a good place to start. It doesn't go nearly as in depth as Haskell From First Principles but it was very helpful for me to go into the more in depth teachings with some basic knowledge.
07:25:31 <mr_sm1th> I looked at some chapters and found it to be a little long-winded. Is it worth it to go through it?
07:25:32 * hackage eventlog2html 0.7.0 - Visualise an eventlog  https://hackage.haskell.org/package/eventlog2html-0.7.0 (mpickering)
07:26:02 <aveltras> i think i read some parts of learn you a haskell first but nothing really clicked back then
07:26:49 <justsomeguy> I like Get Programming With Haskell by Will Kurt.
07:26:55 <aveltras> i found http://book.realworldhaskell.org/read/ quite nice for more "real world" situations that you could relate when coming from other mainstream languages
07:27:48 <justsomeguy> Actually, I'd like to start an online study group for HPFFP, I just don't have the people skills for it.
07:28:13 * justsomeguy is about halfway through it at this point, but is just about to restart from the beginning.
07:29:13 <frdg> justsomeguy: Id love to join a study group with someone else reading HPFFP!
07:32:23 <justsomeguy> What would you find useful to have in a study group?
07:34:35 <frdg> justsomeguy: just other people who are haskell beginners. Ive found that it can sometimes be easier to learn by collaborating with other people who are not experts in a given field. For example learning calculus from a professor was often less efficient than study groups with classmates. 
07:34:58 <justsomeguy> That sounds good to me too.
07:35:31 <yushyin> mr_sm1th: Graham Hutton's book is good as an introduction book to haskell if you already know a bit about programming. it is also not so lengthy. I guess. ;)
07:35:31 <justsomeguy> I also had the idea to set up a voice chat on discord, and maybe a template repository with a more detailed TOC.
07:35:44 <[exa]> frdg: depends on a professor, but generally learning is about doing exercises and failing a bit which the professor is probably not going to provide :D
07:36:28 <justsomeguy> I guess that depends on your professor. I was blessed to have a really good CS101 teacher -- doing exercises was 70% of our class time.
07:37:06 <justsomeguy> But it was an intro course, not as much heavy theory involved.
07:37:22 <frdg> justsomeguy, [exa]: right but its tough to fail alone sometimes. When you're failing alongside others you can combine your failures!
07:37:34 <justsomeguy> Right.
07:38:06 <frdg> anyways I would certainly join this discord that you're thinking about
07:38:38 <[exa]> ...but with #haskell you never fail alone!
07:39:36 <merijn> frdg: The Haskell reddit had a study group thread this week
07:40:30 <frdg> merijn: cool! ill check that out right now
07:55:59 <eric_> hi anyone here?
08:01:13 <justsomeguy> Eyyyy!
08:02:25 <eric_> \o/
08:03:15 <eric_> I'm trying to add a dependency to my project but I have no idea what's wrong
08:03:19 <absence> i'm flailing about in a rabbit hole trying to get a better understanding of PolyKinds. can anyone tell me why ghc complains that the "strange" function needs Monad constraints on m, m0, m1 due to the call in "test"? https://pastebin.com/xPnFda79
08:03:46 <eric_> it says "Recommended action: try adding the following to your extra-deps" "- taggy-0.2.1@sha256:7bc55ddba178971dc6052163597f0445a0a2b5b0ca0e84ce651d53d722e3c265,4662" and "- taggy-lens-0.1.2@sha256:091ca81d02bd3d7fb493dce0148e1a38f25eb178a1ebd751043a23239e5e3265,3009"
08:05:28 <navmed> Coronavirus Live Stream - Real-time counter, Maps, and worldwide stats.https://www.youtube.com/watch?v=qTbR2UKTQQc
08:05:32 <eric_> It's better to see the pastebin ... https://pastebin.com/7chssQS4
08:05:38 <absence> eric_: extra-deps in in stack.yaml probably
08:07:36 <eric_> absonce: https://pastebin.com/Vd4UgGJH
08:08:18 <eric_> It should add the dependencies but it doesn't 
08:08:36 <absence> eric_: no, it recommends you to do it
08:09:14 <eric_> Yep, I did but .. did not work
08:09:46 <absence> eric_: it's not in your pastebin
08:10:32 <absence> eric_: by the way, it looks like you pasted package.yaml, not stack.yaml?
08:10:39 <eric_> yml -> https://pastebin.com/Vd4UgGJH   and   shell -> https://pastebin.com/7chssQS4
08:10:45 <MarcelineVQ> is this a paste of a cabal file? extra-deps goes in your stack.yaml
08:11:05 <eric_> ohhh
08:11:22 <eric_> I don't believe that ! Sorry guys
08:11:37 <eric_> I'm going to try on the stack.yaml
08:11:45 <MarcelineVQ> you also need to put the version it says, extra-deps require a specific version
08:12:38 <MarcelineVQ> e.g.  taggy-1.2.3  but whatever version it tells you to put when it tells you that you need extra-deps
08:15:24 <eric_> MarcelineVQ: It's building.  I've just added this line ->  extra-deps: [taggy-0.2.1, taggy-lens-0.1.2]
08:15:33 <eric_> Thank you all!!!
08:15:51 <eric_> @absence and @MacelineVQ
08:15:51 <lambdabot> Unknown command, try @list
08:16:01 <eric_> absence and MacelineVQ
08:30:17 <absence> i'm flailing about in a rabbit hole trying to get a better understanding of PolyKinds. can anyone tell me why ghc complains that the "strange" function needs Monad constraints on m, m0, m1 due to the call in "test"? https://pastebin.com/xPnFda79
08:30:32 * hackage HaTeX 3.22.2.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.22.2.0 (DanielDiaz)
08:31:17 <zincy_> What are acceptable uses of type coercion using phantom types?
08:32:42 <zincy_> Shouldnt this be avoided at all costs?
08:32:48 <zincy_> coerce :: A a b -> A a c
08:33:07 <ClaudiusMaximus> zincy_: you can use roles to say when it is safe
08:33:15 <{abby}> if the role is phantom then there's no harm done, if you want to rule it out give it nominal role
08:33:19 <zincy_> How does that work?
08:33:39 <{abby}> data Foo a b = MkFoo a; type role Foo representational nominal
08:34:21 <{abby}> gets you (Coercible a a', b ~ b') => Coercible (Foo a b) (Foo a' b')
08:34:31 <solonarv> irrelevant style point: most people seem to write role annotations *above* the thing they're for
08:34:53 <solonarv> but also, GHC infers roles already
08:35:10 <{abby}> representational means you can coerce between those arguments with Coercible, nominal means you need a type equality, and phantom means you can do it at will
08:35:30 <solonarv> so you only have to write a role annotation if you want coercions to be *less* liberal than GHC would infer them
08:35:47 <{abby}> for `type role X representational nominal phantom` you have (Coercible a a', b ~ b') => Coercible (X a b c) (X a' b' d)
08:38:48 <sm[m]> deal: the GoPro work sounds cool!
08:39:03 <sm[m]> Will they hassle you if you write about it ?
08:39:06 <solonarv> zincy_: to be absolutely clear: that 'coerce :: A a b -> A a c' thing only works if a value of type 'A a b' can't actually refer to a value of type 'b' in any way
08:39:22 <sm[m]> dsal, I mean ^^
08:40:10 <dsal> sm[m]: Probably.  it's against ToS to access it with tools that they don't provide.  Mine are like, better, though.  heh.  I'm having to recover a partial upload this morning.  I uploaded all the video, but left it in a broken state.  Building tools to fix it.
08:41:57 <sm[m]> :-/  Iâ€™ll be curious to know if you get it 100% reliable
08:45:59 <dsal> Oh, it's quite reliable.  I got the upload bits done, but my authentication credentials timed out before I could mark it as complete.  My upload process doesn't refresh credentials.  I'm trying to figure out the derivative I uploaded and finish it.
08:48:49 <sm[m]> Cool.
08:49:27 * sm[m] likes reliable haskell alternatives to clunky services
08:52:02 * hackage base16 0.1.3.0 - RFC 4648-compliant Base16 encodings/decodings  https://hackage.haskell.org/package/base16-0.1.3.0 (topos)
08:58:33 * hackage aeson 1.4.7.1 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.4.7.1 (AdamBergmark)
09:21:02 * hackage language-avro 0.1.3.0 - Language definition and parser for AVRO files.  https://hackage.haskell.org/package/language-avro-0.1.3.0 (FlavioCorpa)
09:34:02 * hackage base16-lens 0.1.1.0 - Optics for the Base16 library  https://hackage.haskell.org/package/base16-lens-0.1.1.0 (topos)
10:18:41 <maerwald> Hm, is it a feasible thing to ship dynamic libraries with your haskell binary on mac and then have a wrapper script invoke it?
10:23:02 * hackage hlibsass 0.1.9.0 - Low-level bindings to Libsass  https://hackage.haskell.org/package/hlibsass-0.1.9.0 (jakubfijalkowski)
10:32:35 <zincy_> With Servant how do you return a custom JSON response payload with fields for say status, data and message?
10:43:20 <dsal> sm[m]: Do you use the GP stuff at all?  You might be interested in this project.  It's working quite well at this point.  :)
10:46:02 <sm[m]> thanks, we have one but don't use their services at all
10:46:24 <sm[m]> we barely use the camera.. something broke off and it's too fiddly for my wife
10:47:08 <sm[m]> I suppose they're much better than a phone when you're doing anything adventurous
11:05:56 <dsal> You're almost obligated to use it with unlimited free storage.  I implemented a haskell version of this (since every other version -- including this one -- was pretty awful):  https://github.com/gopro/gpmf-parser  -- look at the kind of crap they pack into these videos.
11:06:42 <kleisli__> anyone here know where the ghc parser operator precedences are written down? the happy source file doesn't seem to contain any precedence directives
11:10:32 * hackage quarantimer 1.20200326 - Coronavirus quarantine timer web app for your things  https://hackage.haskell.org/package/quarantimer-1.20200326 (JoeyHess)
11:11:06 <monochrom> GHC flies like an arrow.  8.10.1 already.
11:17:36 <lyxia> kleisli__: operators have user-defined precedences, so they are handled generically during renaming (compiler/GHC/Rename/Types.hs, look for uses of "compareFixity"), otherwise you have to look at where the operator is defined to know its precedence.
11:17:42 <monochrom> \âˆ©/ "GHCâ€™s runtime linker no longer uses global state. This allows programs that use the GHC API to safely use multiple GHC sessions in a single process"
11:18:17 <kleisli__> lyxia: thank you
11:20:16 <monochrom> haha I didn't know that on LInux there is also "lazy free".  I guess dual to "lazy malloc"? :)
11:20:30 <monochrom> or rather "lazy brk/sbrk"
11:22:29 <monochrom> w00t ghcup now recomments 8.8.x
11:28:08 * solonarv is still on 8.8.2 because don't feel like recompiling everything on switching to 8.8.3
11:30:28 <solonarv> admittedly I'm somewhat traumatized by having had to compile pandoc a total of 4 times in the past few days (3 of them on a CI server, but still)
11:36:10 <koz_> solonarv: Now you too know what it's like to run Gentoo. :P
11:40:18 <monochrom> Gentoo Haskell Compiler
11:41:01 <davean> solonarv: Are you on a particularly slow laptop?
11:44:12 <davean> koz_: Admittedly though, last I knew, there were single packages on gentoo that took longer to compile than the entire Haskell universe.
11:50:25 <sm[m]> pandoc does indeed build reeally slowly
11:52:32 * hackage language-ecmascript 0.19.1.0 - JavaScript parser and pretty-printer library  https://hackage.haskell.org/package/language-ecmascript-0.19.1.0 (DavidJohnson)
11:54:51 <solonarv> davean: I am on a fairly slow desktop PC
11:55:08 <solonarv> pandoc took about 40 minutes to build
11:55:33 <solonarv> (it was using ~100% of a CPU core during this time)
11:57:43 <Eduard_Munteanu> davean, I remember compiling for about 2 days at atlas-blas, because the ebuild repeatedly compiles varous variants and benchmarks them to select the best implementation. :)
11:58:13 <davean> Eduard_Munteanu: I've rebuilt everything on hackage that was buildable (and tried the others to find out they weren't) in less time :)
11:58:17 <Eduard_Munteanu> Possibly the longest compile time I've seen on a decent-ish computer.
11:58:50 <davean> Thats pretty brutal
12:11:22 <razrushi1el> a
12:28:12 <koz_> davean: Yeah. LLVM or Firefox anyone?
12:28:39 <davean> koz_: It was the old OpenOffice that really ruined stuff to my memory.
12:29:05 <koz_> LibreOffice isn't much better.
12:29:19 <davean> I recall it getting better slowly over the years, but yah
12:32:02 * hackage persistent-mongoDB 2.10.0.0 - Backend for the persistent library using mongoDB.  https://hackage.haskell.org/package/persistent-mongoDB-2.10.0.0 (parsonsmatt)
12:33:02 * hackage fay 0.24.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.24.1.0 (swamp_agr)
13:04:08 <frdg> https://pastebin.com/sbQRNtqY question about foldr syntax
13:04:59 <koz_> frdg: Because what you wrote is equivalent to 'foldr ((||) False x)'.
13:05:03 <koz_> Which makes zero sense.
13:08:10 <frdg> oh...
13:08:20 <frdg> I see now
13:10:31 <Guest_58> Hey, folks, I just downloaded and started playing with ghci. When I get an error in ghci (for invalid syntax, for example) the error message is empty.
13:11:04 <c_wraith> What version of ghc?
13:11:32 <Guest_58> GHCi, version 8.8.3
13:12:06 <c_wraith> ghci is just some flags to ghc.  But that version number is good enough to assure me it's not a weird issue with the brand-new 8.10 releases.  :)
13:13:09 <Guest_58> Oh yes, version 8.8.3 of GHC as well.
13:13:16 <c_wraith> ok, so what does "error message is empty" mean?
13:15:13 <Guest_58> One second. Trying to reproduce a good example.
13:16:16 <c_wraith> Guest_58: like the first example here?  https://paste.ubuntu.com/p/8K62YQPcZz/
13:17:42 <c_wraith> Guest_58: if that's what you're seeing, it's likely the environment you're running it in is writing stderr to someplace other than the display.  That is awkward for an interactive process
13:18:33 <Guest_58> Yes, that's the error.
13:19:04 <c_wraith> so how are you running ghci?
13:19:32 * hackage dependent-map 0.3.1.0 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.3.1.0 (3noch)
13:20:46 <Guest_58> While trying to copy and paste the error for the first time, I found that the problem is the errors use the same font color as the background.
13:21:16 <c_wraith> hah. well, that must be a terminal config somewhere
13:21:29 <c_wraith> tell it to use a different color for stderr
13:22:03 <Guest_58> Hahah! OK, thanks. I still give you credit for solving the problem by prompting me to highlight the blank space.
13:27:00 <ukari> I read a blog about scala which talks about curry-howard isomorphism, though I don't know how to use scala I still want to know is there a same stuff in haskell? instance seems work without the need of curry-howard, but is there anything works in the type alias way with curry-howard approch? here is the link https://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/ 
13:28:00 <Rembane> ukari: It is. It's everywhere. 
13:29:37 <berndl> ukari: Do you understand the Curry-Howard correspondence?
13:30:19 <c_wraith> there's no such thing as a language that does not exhibit the curry-howard isomorphism. the part that varies is how interesting the logic is.
13:31:32 <berndl> c_wraith: What do you mean by "exhibit"?
13:32:15 <ukari> berndl, no, I guess it is sth which could make stuff like "foo :: Type1 | Type2 -> Bar" works
13:32:37 <c_wraith> the normal thing? exhibit as in demonstrate, display, show
13:32:52 <berndl> ukari: No.
13:33:57 <nshepperd2> some programming languages hide the curry-howard correspondence in a closet
13:34:00 <berndl> c_wraith: OK. But your language needs to have types to exhibit Curry-Howard. You can't exhibit Curry-Howard in e.g. Bash.
13:34:20 <c_wraith> why do you think bash doesn't have types?
13:35:32 <ysangkok> c_wraith: because there is no syntax for specifying them
13:35:36 <berndl> It does have types, but you're limited to strings, numbers and arrays.
13:36:03 <berndl> And you can't even declare types.
13:36:17 <c_wraith> none of that prevents curry-howard from applying.
13:36:19 <hpc> to be fair, up until like 2013 only strings existed
13:36:21 <ysangkok> if every type can be coerced to every other type, that isn't types in the same sense 'statically typed' languages have them
13:36:29 <Rembane> Can't you represent types as strings or something? 
13:36:48 <c_wraith> it just means you need to express the types with a mechanism other than the language 
13:37:10 <c_wraith> but the types still form a logic. the language still implements proofs in the logic 
13:37:33 <c_wraith> it's just that for most "untyped" languages, the logic is incredibly boring 
13:37:44 <berndl> c_wraith: Alright, I see what you're getting at.
13:37:53 <maerwald> berndl: with arrays you can even simulate product types ;)
13:37:58 <berndl> Then it's also boring in Haskell.
13:38:21 <nshepperd2> expressing types with a mechanism other than the language doesn't really seem like the language having types
13:38:22 <c_wraith> it's inconsistent in Haskell, but it's less boring 
13:38:24 <berndl> If you want a proper Curry-Howard correspondence, you need a language with dependent types.
13:38:45 <c_wraith> I don't see why you think that.
13:39:04 <berndl> Well, because I want a proper logic.
13:39:17 <merijn> You don't need dependent types for a proper logic
13:39:26 <merijn> simply typed lambda calculus is also a proper logic
13:39:40 <ysangkok> not sufficiently proper! :D
13:39:42 <merijn> Specifically, intuinistic logic
13:39:52 <merijn> intuitionistic, even
13:39:58 <merijn> Or constructive, if you prefer
13:40:04 <berndl> Actually, I need dependent types + induction + coinduction.
13:40:11 <berndl> Then I have a proper logic.
13:40:34 <berndl> I can write down a type corresponding to mathematical induction on Nat.
13:40:37 <inventednight> what does "proper" mean in this context
13:40:57 <merijn> You seem to have an overly narrow definition of "proper" logic
13:41:11 <berndl> It means that I need to at least be able to write down dependent eliminators.
13:41:26 <c_wraith> I'm pretty sure first-order logic isn't proper either, by this definition
13:41:29 <berndl> And for that I at least need dependent types.
13:41:58 <berndl> c_wraith: I'm more of an HOL guy.
13:42:31 <c_wraith> yet predicate and first-order are definitely logical systems that get studied.
13:42:59 <ysangkok> berndl: but HOL doesn't have dependent types. how is this consistent?
13:43:56 <berndl> ysangkok: I mentioned HOL in contrast to FOL. I know it doesn't have dependent types because it's not evey a type system in the usual sense of the word.
13:44:16 <ysangkok> aah oki
13:44:50 <c_wraith> yet, every logic is a type system. every type system is a logic. the fun is looking for points where both halves are interesting
13:46:03 <berndl> "is a" is the wrong relation. I would say "corresponds to". Curry-Howard is one such correspondence.
13:48:16 <{abby}> equivalence is equivalent to equality
13:48:25 <{abby}> (depending on how spicy you like your equalities, anyway)
13:48:36 <inventednight> noob question: what's an example of a logic that fits your definition of proper, then?
13:48:42 <berndl> To be precise, Curry-Howard is the correspondence regarding intuitionistic propositional logic.
13:50:16 <berndl> inventednight: any HOL, like SOA.
13:52:53 <inventednight> so HOL doesn't have dependent types, but you can still write down dependent eliminators?
13:54:34 <berndl> inventednight: no. If you have HOL, you don't have nor need dependent types nor dependent eliminators.
13:55:03 <inventednight> but a proper logic means you can write own dependent eliminators?
13:55:33 <berndl> I said that in the context of a type theory where I can do "proper" logic.
13:56:42 <ysangkok> i found a good example for HOL here in section 4.4 (cantor's theorem): https://isabelle.in.tum.de/dist/library/HOL/HOL-Isar_Examples/document.pdf
14:02:01 <berndl> ysangkok: Yep, Isabelle uses HOL.
14:12:17 <berndl> Here's my definition of "proper logic": If there's a theorem prover using it, then it's proper.
14:13:07 <monochrom> Do you also have a definition of "theorem prover"? :)
14:15:39 <berndl> Sadly no. I only have examples.
14:59:02 * hackage msgpack-types 0.0.4 - A Haskell implementation of MessagePack.  https://hackage.haskell.org/package/msgpack-types-0.0.4 (iphydf)
15:10:28 <howdoi> When was the last you checked if two lists were equal in your production code? 
15:10:54 <monochrom> Sometimes I do that to strings, but they're short.
15:11:20 <Rembane> I have checked trees many times 
15:15:45 <maerwald> monochrom: real equality? or [Char] equality :>
15:15:59 <monochrom> [Char] equality.
15:22:33 <howdoi> monochrom: Rembane it would useful if you could elaborate the usecase 
15:22:40 <iqubic> Many parser combinators can do string equality.
15:22:46 <iqubic> :t string
15:22:48 <lambdabot> error:
15:22:48 <lambdabot>     â€¢ Variable not in scope: string
15:22:48 <lambdabot>     â€¢ Perhaps you meant one of these:
15:23:51 <Rembane> howdoi: I generate an AST, does some transformations on it and compare the original with the transformed one. 
15:25:38 <howdoi> nice! thanks! 
15:25:59 <Rembane> howdoi: np! 
15:31:26 <maerwald> iqubic: hm, it's more bytestring equality
15:31:32 * hackage discord-haskell 1.5.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.5.0 (Aquarial)
15:31:54 <iqubic> even if the thing you're parsing happens to be a string?
15:32:08 <maerwald> Does it use the ICU package? I doubt it
15:32:30 <maerwald> And it's hard to say that's what you want, even
15:32:40 <iqubic> does the string function from Megaparsec do string equality?
15:35:55 <maerwald> https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU.html#v:compare
15:36:00 <howdoi> does haskell has three way comparison? 
15:36:19 <[exa]> :t compare
15:36:21 <lambdabot> Ord a => a -> a -> Ordering
15:36:26 <[exa]> howdoi: ^
15:36:47 <howdoi> that's 3 way?
15:37:07 <[exa]> yes, Ordering is `LT`, `GT` or `EQ`
15:37:24 <urinal666> help please is component object model good for a newbie?
15:37:27 <[exa]> (hopefully I'm not pointing out some other definition of threeway)
15:37:46 <[exa]> urinal666: not really
15:37:55 <[exa]> urinal666: but your experience may vary
15:38:30 <urinal666> but
15:38:35 <[exa]> (assuming you're speaking about the microsoft's COM right?)
15:39:00 <urinal666> but my windows is running some kind of component object model service (com+) so it has to be important
15:39:06 <urinal666> yes
15:42:29 <[exa]> urinal666: well it's important for some inter-process communication among windows programs, but I wouldn't say understanding it is useful unless you want to really jump into desktop-oriented programming for windows only
15:44:31 <urinal666> hmh seems reasonable
15:46:11 <monochrom> Why the hell is that question in #haskell?
15:46:39 <urinal666> because i am banned from every other programming related channel :(
15:46:53 <dsal> Weird.  How did that happen?
15:47:33 <monochrom> Well I'm going add this channel if you continue with being off-topic.
15:47:35 <urinal666> because i got too drunk and started spamming offensive stuff like nazism and genocide and other religious extermism
15:47:49 <urinal666> ok ok no off topic anymore!
15:47:50 <maerwald> Yeah, that might be a reason
15:49:01 <maerwald> There are offtopic channels, but you'll probably get banned there as well if you talk weird about genocide
15:49:15 <maerwald> #haskell-blah and #haskell-offtopic
15:50:32 * hackage msgpack-binary 0.0.14 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/msgpack-binary-0.0.14 (iphydf)
15:54:19 <jollygood2> hi. i need to display line graph on a web page. not sure what approach I should take? generate image and then just display it? something else? any recommendations for a library?
15:55:02 <jollygood2> I made the page with scotty and plain js 
16:04:35 <[exa]> jollygood2: there are some javascript-only plotting libraries that draw to canvas, say paper.js. You just send data in JSON to the script from scotty, and done
16:05:21 <[exa]> jollygood2: otherwise I'd go with sending a SVG; you can hack a SVG together really easily
16:09:37 <Axman6> I think there's a haskell library for using vega IIRC
16:10:32 * hackage ghc-exactprint 0.6.3 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.3 (AlanZimmerman)
16:11:11 <maerwald> I found the perfect haskell code editor color scheme https://git.io/Jv9HR
16:12:15 <Axman6> no
16:12:19 <jollygood2> exa, Axman6, thanks!
16:13:27 <koz_> maerwald: Jesus wat.
16:13:45 <[exa]> maerwald: why do you think it's suitable only for haskell?
16:13:46 <maerwald> :>
16:13:50 <[exa]> :D
16:14:03 * maerwald switches his weechat colors
16:25:59 <jackdk> maerwald: I was thinking "I hope this is Hot Dog Stand"... was not disappointed
16:33:52 <koz_> @pl \e -> f e && g e
16:33:52 <lambdabot> liftM2 (&&) f g
16:35:02 * hackage msgpack-rpc-conduit 0.0.6 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/msgpack-rpc-conduit-0.0.6 (iphydf)
16:38:47 <jackdk> lambdabot: liftA2 (&&) f g
17:09:10 <dmwit> getAny (coerce (<>) f g)
17:09:30 <dmwit> rer
17:09:34 <dmwit> s/ny/ll/
17:11:15 <dmwit> Eh. It's all kinds of wrong. And once again it's so hard to get the compiler to pick the right type for coerce even after you fix the wrong bits that it hardly seems worth it.
17:32:00 <koz_> jackdk: You mean (&&) <$> f <*> g amirite?
17:46:09 <Axman6> :t \f g -> getAny (coerce (<>) f g) 
17:48:27 <lambdabot> error:
17:48:27 <lambdabot>     â€¢ Variable not in scope:
17:48:27 <lambdabot>         coerce :: (a0 -> a0 -> a0) -> t -> t1 -> Any
17:48:27 <Axman6> % :t \f g -> getAny (coerce (<>) f g) 
17:48:27 <yahb> Axman6: (Coercible a t1, Coercible a t2, Semigroup a, Coercible a Bool) => t2 -> t1 -> Bool
17:48:27 <Axman6> % :t \f g x -> getAny (coerce (<>) f g) x
17:48:27 <yahb> Axman6: ; <interactive>:1:11: error:; * Couldn't match expected type `t2 -> t3' with actual type `Bool'; * The function `getAny' is applied to two arguments,; but its type `Control.Monad.RWS.Any -> Bool' has only one; In the expression: getAny (coerce (<>) f g) x; In the expression: \ f g x -> getAny (coerce (<>) f g) x; * Relevant bindings include x :: t2 (bound at <interactive>:1:
17:48:27 <Axman6> % :t \f g x -> getAny $  (coerce (<>) f g) x
17:48:27 <yahb> Axman6: (Semigroup a, Coercible a (t1 -> Control.Monad.RWS.Any), Coercible a t2, Coercible a t3) => t3 -> t2 -> t1 -> Bool
17:57:03 <TechnoTzar> I was wondering if Haskell is uniquely suited for anything in the security realm. It seems like there are some use cases like parsing security rules but I'm sure there are more.
17:57:32 * hackage toxcore-c 0.2.11 - Haskell bindings to the C reference implementation of Tox  https://hackage.haskell.org/package/toxcore-c-0.2.11 (iphydf)
18:06:32 <koz_> @pl \x y ys -> x : y : ys
18:06:32 <lambdabot> (. (:)) . (.) . (:)
18:06:37 <koz_> Lolwut.
18:16:32 * hackage schema 0.0.2 - Encoding-independent schemas for Haskell data types.  https://hackage.haskell.org/package/schema-0.0.2 (iphydf)
18:20:01 <maerwald> koz_: pointfree is like cocaine. Fun in the beginning, but it easily gets out of hand.
18:20:05 <koz_> Lol.
18:22:43 <Axman6> tdammers: unique? no, but there is definitely a lot of work in high assurance systems which are using Haskell. Some examples inclide seL4, Cryptol, possibly Copilot falls into this
18:23:23 <Axman6> uh, that was meant for TechnoTzar who left
18:25:35 <maerwald> seL4 is using C
18:26:12 <Axman6> bia Haskell
18:26:15 <Axman6> via*
18:26:20 <maerwald> where
18:27:09 <maerwald> afair they use HOL, I've seen nothing of haskell there
18:27:33 <maerwald> https://sel4.systems/Info/FAQ/proof.pml
18:27:49 <maerwald> there is no haskell anywhere
18:28:24 <Axman6> IIRC the process was HOL -> Haskell -> C - thatwhat Michael Norrish said when I had him talking at CanFP a few years ago
18:28:45 <maerwald> Well, I'd like to see a reference
18:29:22 <Axman6> https://en.wikipedia.org/wiki/L4_microkernel_family#High_assurance:_seL4
18:29:42 <Axman6> but, like, Michael actually wrote a lot of )seL4, so I'm inclined to believe him. I used to work with him at NICTA
18:30:41 <maerwald> I can't access the paper
18:30:50 <dibblego> there is Haskell 
18:30:53 <maerwald> https://dl.acm.org/doi/10.1145/1159842.1159850
18:31:27 <maerwald> Regardless. If this is true and there's a non-trivial part of haskell involved in seL4, then it's definitely under-advertised...
18:32:31 <Axman6> I believe the Haskell is mostly auto-generated from HOL
18:32:39 <maerwald> Ah
18:33:16 <Axman6> see also https://github.com/seL4/l4v#overview
18:33:49 <Axman6> and https://github.com/seL4/l4v/tree/master/spec/haskell
18:35:17 <maerwald> It's all lhs!
18:38:24 <maerwald> Marvelous
19:07:02 * hackage dependent-map 0.4.0.0 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.4.0.0 (3noch)
19:21:32 * hackage haddock 2.23.1 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.23.1 (harpocrates)
19:22:32 * hackage haddock-api 2.23.1 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-api-2.23.1 (harpocrates)
19:52:06 <whataname> how to compile haskell code to binary that can run other systems?
19:52:29 <whataname> without depends
19:53:02 <whataname> an executable binary file
20:01:16 <whataname> :t id
20:01:18 <lambdabot> a -> a
20:05:10 <Axman6> whataname: it's not that easy to do that completely, you almost always need libgmp installed (because of licensing reasons it's not statiaclly linked). There's plenty of articles on static compilation of Haskell binaries though
20:07:04 <whataname> what's the right way to port haskell code to other systems?
20:07:17 <whataname> even they don't have ghc
20:07:30 <dsal> Porting and having toolchains are different concepts.
20:08:53 <Cale> whataname: Maybe start by building a cross compilation toolchain in GHC for that platform?
20:08:59 <whataname> if my code is on archlinux, I compiled it, and can I run the executable file on debian? same x86-64
20:09:16 <Cale> Of course
20:09:39 <Cale> They're both x86-64 linux
20:10:09 <Cale> It may help not to switch on dynamic linking, but the default is static
20:10:55 <whataname> but I tried to compile it on debian x86, but won't run on gentoo x86, it prompts missing some libraries
20:11:26 <whataname> glibc stuff
20:11:51 <Cale> hmm
20:12:13 <whataname> that gentoo is an old version
20:13:41 <whataname> that packages depends other packages sometimes is not good
20:14:14 <Cale> Yeah, even if your Haskell dependencies are not dynamically linked, there are a few dynamic dependencies, and a few things from glibc are among them.
20:14:43 <whataname> so I wonder can it be totally native code
20:15:28 <whataname> run it on an old version system even it's compiled on an newer version system
20:15:59 <dsal> I build arm9 binaries from my x86-64 system vi docker+qemu
20:16:29 <Cale> Maybe try -optl-static
20:19:50 <Cale> That should get you a properly static executable if all goes well
20:20:23 <Cale> I get a warning about using dlopen in a statically linked application requiring at runtime the shared libraries from the glibc version used for linking
20:20:42 <Cale> So, it's hard to confirm that it actually works properly :P
20:22:17 <whataname> ok
20:22:34 <Cale> But hopefully your program doesn't cause the RTS to actually dlopen anything ... I straced a simple program and it didn't.
20:22:56 <whataname> what's dlopen?
20:23:35 <Cale> It's the linux API for opening a shared library
20:24:47 <Cale> Even if your program isn't dynamically linked, it's possible to dlopen a shared library and run code out of it that way.
20:32:09 <whataname> I saw that racket have a tool called raco which can pack executable file with it depends libraries, do haskell have that?
20:32:54 <solonarv> haskell is statically linked by default, so other haskell libraries you use will end up in your final executable
20:33:16 <solonarv> but if you want to also package in dynamic libraries then you will need to use some additional tool
20:33:30 <whataname> like?
20:33:54 <solonarv> I don't know of any, sorry
20:34:10 <whataname> I just file an executable file compiled by ghc, and it shows dynamically linked
20:34:45 <solonarv> try running ldd on it to see which dynamic libraries it's actually using? might just be libc or something
20:36:00 <whataname> libgmp.so librt.so libdl.so libc libffi libpthread
20:36:05 <Cale> If you build with -optl-static it will pass the -static parameter to your linker, so it should statically link all the normal dynamic stuff
20:36:38 <whataname> I tried optl-static but it shows no lffi and lgmp found
20:36:51 <whataname> which package contains lffi and lgmp?
20:38:06 <solonarv> on my system (mint) the packages are called libffi6 and libgmp10
20:38:23 <solonarv> they are probably named similarly on yours
20:38:38 <solonarv> you might need the -dev variants, I don't know.
20:38:41 <Cale> I'm not sure if you need the -dev versions of those packages to get the static libraries
20:38:43 <Cale> yeah
20:38:44 <whataname> sadly I'm on archlinux
20:39:08 <Cale> It shouldn't be too different, just search your package manager
20:39:39 <whataname> I've installed libffi and haskell-libffi
20:39:46 <Cale> btw, if you're on archlinux, you probably don't want to rely on any of its GHC-related packages
20:39:55 <whataname> but there's no libgmp
20:40:17 <Cale> There's gmp
20:40:46 <whataname> and I've installed gmp
20:41:25 <whataname> I'll try it on debian
20:41:37 <monochrom> Isn't archlinux like anti-static so it's the wrong platform to do this on?
20:43:46 <solonarv> yes, that's why arch's ghc-related packages are bad
20:43:52 <whataname> aha, you're right, same code compiled on debian with -optl-static, it's static linked
20:44:17 <solonarv> they really want to do dynamic linking, when that's just not what anyone else does (and so it's not well supported), and IIRC they also fuck that up somehow
20:44:45 <whataname> what about gentto?
20:45:13 <solonarv> I know very little about gentoo, sorry
20:45:48 <solonarv> I generally just recommend ghcup: it downloads GHC bindists and stores them in ~/.ghcup
20:46:26 <solonarv> has new versions immediately and is not vulnerable to package maintainers messing up
20:47:24 <Cale> But if you want to statically link stuff, you'll still have to rely on your system's package maintainers to provide the relevant static C libraries
20:47:50 <solonarv> of course, none of the haskell-specific package managers/build tools try to provide C libraries
20:48:48 <solonarv> they (cabal and stack) just look for them via pkg-config
20:49:05 <Axman6> Doing this in Docker, in an apline base image, is definitely a lot easier than trying to make this work on arch linux
20:49:23 <Cale> The closest thing to that is using nix to build your Haskell stuff -- it can provide all your non-Haskell dependencies as well.
20:49:49 <solonarv> yes, I said "haskell-specific " specifically to exclude nix :P
20:49:52 <Cale> yeah
20:51:16 <Cale> If you're concerned with being able to reliably deploy things or making sure that an entire team of developers is actually running the same code, nix is pretty good for that.
20:52:05 <Cale> It's a little heavy for starting out or small personal projects perhaps, though once you get used to it, it gives you some rather nice things to have around.
20:52:32 * hackage monad-choice 0.2.0.0 - Monad, monad transformer, and typeclass representing choices.  https://hackage.haskell.org/package/monad-choice-0.2.0.0 (LouisH)
20:53:23 <Axman6> whataname: https://github.com/jkachmar/alpine-haskell-stack might ve useful to you, if you're happy to go down the docker route - you will just end up with a binary at the end, and you don't have to worry about filling your Arch install with extra libraries just to support static linking
20:53:35 <whataname> I don't know nix yet
20:53:49 <whataname> that nix config is hard?
20:54:08 <Axman6> IMO, yes
20:54:51 <Cale> nix is a whole quirky programming language, used to specify builds
20:54:59 <Axman6> It's a fantastic idea with a really terrible configuration language which I've never been able to understand (but haven't needed to try all that hard to understand it - many people do use it "happily")
20:55:22 <Cale> > cat ~/bin/ghcWithPackages
20:55:22 <Cale> nix-shell -p "(import <nixpkgs> {}).haskell.packages.ghc865.ghcWithPackages (pkgs: with pkgs; [ $* ])"
20:55:25 <lambdabot>  error:
20:55:25 <lambdabot>      â€¢ Variable not in scope: (~/) :: ([Doc] -> Doc) -> Double -> t
20:55:25 <lambdabot>      â€¢ Perhaps you meant one of these:
20:55:36 <Cale> ah, sorry lambdabot, that wasn't for you :)
20:56:05 <Cale> That drops me into a shell with ghc 8.6.5 and any list of packages that I specify on the commandline
20:56:11 <whataname> I heard that gnu has another package based on guile?
20:56:13 <Cale> I can specify different versions of ghc there as well
20:56:20 <whataname> and nobody use it?
20:56:42 <whataname> package manager cross systems
20:57:27 <whataname> gnu guix
20:57:44 <Cale> e.g. I could replace that ghc865 with 8101 for 8.10.1 (I have no idea why they don't at least use underscores there)
20:58:10 <justsomeguy> Axman6: All the configuration management languages I've used are pretty quirky. I think it would be interesting to see a CM system embedded in a proper PL.
20:58:52 <Axman6> I just wish Nix was a) written in Haskell and b) used Haskell as its syntax - at least then it'd be type checked
20:59:10 <Cale> I'd love to be able to use Haskell, but the logistical thing which prevents that is presently that if you have a Haskell program, you have to at least parse it all if you want to run it.
20:59:33 <Cale> Nixpkgs is effectively a giant nix program, most of which is dead code each time you use it
21:00:01 <Cale> The ability to import stuff during evaluation is rather an advantage there
21:00:28 <solonarv> ghci scripts?
21:00:30 <solonarv> (jk jk)
21:00:32 <jackdk> Nix is so strange like that - it thinks some things through really carefully and then wraps in a language that's very hard to type
21:00:41 <jackdk> as much as I love it, that's quirky
21:01:14 <Cale> Then again, nixpkgs probably could and should be far more modular and separated into smaller pieces
21:02:17 <Cale> at the very least, chop all the nix programming library stuff out and separate it from the actual packages
21:03:37 <Cale> (but probably much more than that)
21:11:55 <xe4> why doesn't this work? https://gist.github.com/xe-4/f71a03eea8c69d0752098c1a6a7864db
21:14:43 <dsal> xe4: what does it tell you?
21:15:19 <dsal> It's not clear to me what you want it to do, though.
21:31:55 <xe4> i was hoping it would print "Foo 2 2" to the screen. I don't understand why it expects something of kind * -> * -> * though
21:32:41 <pavonia> Do you know the difference between "type" and "data"?
21:32:48 <xe4> yeah
21:33:44 <pavonia> So "type" takes a type constructor on the right-hand side, but there is none of kind * -> * -> *
21:35:42 <pavonia> xe4: Your definition "data Foo = MkFoo" is similar to the Bool definiton "data Bool = False | True". What would you expect the type-checker to do with something like "True  2 2"?
21:41:11 <xe4> pavonia: your point is taken. thank you ðŸ™
21:41:32 * hackage OneTuple 0.2.2.1 - Singleton Tuple  https://hackage.haskell.org/package/OneTuple-0.2.2.1 (phadej)
21:41:54 <pavonia> :)
23:13:02 * hackage spdx 1.0.0.2 - SPDX license expression language, Extras  https://hackage.haskell.org/package/spdx-1.0.0.2 (phadej)
