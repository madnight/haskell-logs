01:20:02 <mjrosenb_> interesting, is there a reason that filterM takes a list and not a traversable?
01:20:16 <mjrosenb_> is it just because not all traversable things can have elements removed?
01:26:13 <bahamas> hello. I'm trying to build a Miso app on Mac OS and it's building nodejs-slim. is this expected? I setup cachix
01:26:43 <MarcelineVQ> mjrosenb_: https://hackage.haskell.org/package/witherable-0.3.5/docs/Data-Witherable.html is pretty neat
01:37:52 <jle`> mjrosenb_: yes precisely. consider a Traverable like `data V3 a = V3 a a a`
01:38:02 <jle`> it cannot be filtered, it is fixed-lengt
01:38:53 <mjrosenb_> oh, and Set is not Traversable. this was doomed to failure from the begining!
01:44:58 <mjrosenb_> oh, because the Ord
01:45:18 <mjrosenb_> mapping the values might change the order that they need to appear in in the tree
01:46:27 <mjrosenb_> but there's Data.Set.map and Data.Set.filter
01:46:46 <mjrosenb_> are Data.Set.mapM and Data.Set.filterM too much to ask for?
02:14:24 <Lycurgus> Herbrandization is the dual of Skolemization, who knew?
02:14:40 * Lycurgus didn
02:19:13 <bahamas> how can I pretty print aeson Value?
02:20:42 <[exa]> bahamas: convert it to PrettyPrint.Doc?
02:21:36 <bahamas> [exa]: from "pretty"?
02:22:22 <[exa]> yes. the function is IMHO like 10 lines of code, I guess you will be able to find some implementation on the web
02:22:46 <[exa]> aah https://hackage.haskell.org/package/aeson-pretty
02:23:57 <[exa]> that lib uses its own implementation of prettification which may not be as cool as the one from actual `pretty` but I guess it's a good first try
02:23:58 <bahamas> I found that too. ok, I'll look into it
02:24:06 <bahamas> thanks!
02:25:24 <[exa]> if you hit ugly indentation problems later, conversion to 'pretty' shouldn't be complicated
02:35:53 * hackage http-directory 0.1.8 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.8 (JensPetersen)
02:41:13 <i_cant_username> Hi all, I was wondering what more advanced stuff I could learn from writing a relatively simple cli app that interacts with a db and has som minimal logic between the db and cli. done tagless and free monad in scala recently, the data model is not complex enough for lens to be an interesting choice...
02:41:51 <i_cant_username> could be language features / extensions, or just techniques / patterns / libraries, any ideas?
02:45:15 <lortabac> i_cant_username: techniques are solutions to problems, so choose a more advanced problem and you will naturally need a more advanced solution
02:49:22 <i_cant_username> lortabac, fair enough, I'd be open to that. I just really suck at finding stuff to work on. not very interested in highly algorhitmic stuff, i guess what's closest to me is modelling business processes and similar, but coming up with random ones is meh. or maybe im just not even sure what :)
02:49:30 <i_cant_username> got a sugggestion for me?
02:57:26 <lortabac> i_cant_username: the only real use case for lens I had was updating a highly-nested data type in an e-commerce application
02:58:14 <lortabac> but to be honest lens was only used in one specific module
02:58:28 <lortabac> I guess a game with a complex state would be a better fit
03:00:24 <lortabac> i_cant_username: alternatively, you might try to translate your Scala exercises to Haskell
03:01:22 <sshine> i_cant_username, I was toying around with heterocephalus, but I guess it isn't really advanced as much as it's good to have something like at hand. you could toy around with streaming, or barbies, or QuickCheck's Coarbitrary, or do something cool with 'moo' or 'monad-bayes'.
03:01:52 <sshine> i_cant_username, to be honest, I think there are too many interesting paths down haskell libraries to explore that I ever feel like I get around to all of them. it's a first world problem.
03:02:14 <lortabac> what is moo?
03:02:23 <sshine> http://hackage.haskell.org/package/moo
03:02:55 <sshine> it was featured here: https://medium.com/analytics-vidhya/optimizing-a-maze-with-graph-theory-genetic-algorithms-and-haskell-e3702dd6439f
03:03:07 <lhurttila> Is it possible to use nested infinities with map? function x y  = map (take x) [[take y [0..]]..] compiles but using it gives No instance for (Enum [[Integer]]) arising from a use of `it'
03:04:07 <sshine> lhurttila, sure, but 1) you have to create that list using e.g. `iterate`, and 2) you'll have dead thunks.
03:04:37 <sshine> or wait, you could make use of those.
03:05:56 <sshine> > map (take 3) $ take 3 $ tails $ iterate succ 0
03:05:58 <lambdabot>  [[0,1,2],[1,2,3],[2,3,4]]
03:07:00 <i_cant_username> lortabac okay, I could do this bit.ly/2Q9F0I3 a simlulation rather than a game, I think it is very similar, except it's not interactive. Any suggestions wrt. my initial question for this then?
03:08:44 <lhurttila> sshine is it possible to make that start from 0 in each sublist? 
03:09:37 <sshine> lhurttila, yes! what part do you think needs to be replaced with something else?
03:10:17 <sshine> lhurttila, https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:repeat
03:11:33 <sshine> (also, iterate succ 0 == [1..], so that's just me being unnecessarily verbose.)
03:12:23 * hackage dobutokO2 0.8.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.8.0.0 (OleksandrZhabenko)
03:12:24 <lhurttila> So just scrapping iterate succ and replacing it wit repeat should work?
03:12:55 <sshine> try and find out by experimenting in GHCi.
03:13:27 <lhurttila> I'll do just that. Thanks :)
03:14:10 <sshine> try and make a small part work and build on top of that. I guess what makes this difficult is that because you have an infinite amount of elements in two places.
03:15:58 <sshine> s/1\.\./0../
03:17:23 * hackage dobutokO2 0.8.0.1 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.8.0.1 (OleksandrZhabenko)
03:18:51 <lhurttila> Yes, have to start small but I think i'll manage 
03:21:46 <sshine> i_cant_username, I think you can attack this from at least two angles; either make something you find useful, and try to find of ways to apply new techniques, or pick a genre in which certain techniques may be useful, and come up with something that's less close to you personally, but where certain techniques apply very well. e.g., for more type-level features, I'd probably go for something like a 
03:21:52 <sshine> stricter Ethereum VM model comparable to what Morley does to Tezos.
03:22:42 <sshine> i_cant_username, but for compiler techniques and property-based testing practicing, I'll just go for my stupid toy combinator language.
03:23:17 <sshine> i_cant_username, I think whatever it is, the slightest emotional investment goes a long way. :)
03:48:23 * hackage dobutokO2 0.8.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.8.1.0 (OleksandrZhabenko)
03:51:19 <pie_[bnc]> POC Qt binding generation, help wanted; https://bugreports.qt.io/browse/PYSIDE-1240#comment-502045
04:04:04 <mpickering> merijn: Glad you like it
04:04:11 <mpickering> Thanks for helping with the publiciity
04:04:36 <merijn> mpickering: Now I just need to figure out how to make my stuff fast >.>
04:11:06 <mpickering> merijn: You can make your program faster by turning off profiling ;) 
04:11:41 <mpickering> Something else I implemented was a way to profile only a section of the program
04:11:48 <mpickering> by emitting some markers in the eventlog
04:11:56 <mpickering> It's a bit hacky though so I didn't put up the changes
04:12:24 * hackage ghc-lib-parser-ex 8.8.5.5 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.5 (shayne_fletcher)
04:31:34 <ski> @tell Lycurgus hm, hadn't heard the term "Herbrandization" before. however, it seems to be related to Kreisel's "No-Counterexample" interpretation ?
04:31:34 <lambdabot> Consider it noted.
05:17:32 <pdxleif> Why doesn't something like this work?
05:17:35 <pdxleif> nthProxy :: Proxy (Nth n IndexAPI)
05:17:37 <pdxleif> nthProxy = Proxy
05:18:25 <pdxleif> Just gives me: "Expected type: Proxy (Nth n IndexAPI)" "Actual type: Proxy (Nth n0 IndexAPI)" "NB: ‘Nth’ is a non-injective type family" "The type variable ‘n0’ is ambiguous"
05:20:16 <[exa]> pdxleif: can proxy "carry" the `forall n`?
05:21:54 <pdxleif> What do you mean "carry"?
05:22:21 <pdxleif> I can write that type signature as something like forall (n :: Nat). Proxy (Nth n IndexAPI) instead?
05:22:38 <ski> pdxleif : pass in a `Proxy n', or enable `AllowAmbiguousTypes' and `TypeApplications'
05:22:54 <pdxleif> And/or write the value-level Proxy as Proxy @(Nth n IndexAPI). Doesn't seem to change anything.
05:24:00 <ski> the problem is that it can't infer which `n' to use, assuming it knows which specific type `Proxy (Nth n IndexAPI)' is (maybe `Proxy Int' or whatever)
05:24:26 <ski> because `Nth n IndexAPI' isn't (known to be) injective in `n'
05:25:31 <ski> it's similar to if you wrote `class C a b where foo :: [b]', just by knowing `foo :: [Int]' at a use site of `foo', it would have no idea which `a' to pick, when selecting an instance `C a Int'
05:26:27 <ski> pdxleif : makes any sense ?
05:27:56 <pdxleif> I was hoping I could pass in a type-level "n" to use (like how in Idris2 you can reference type params in the type sig in the function definition: https://idris2.readthedocs.io/en/latest/updates/updates.html#scope-of-implicit-arguments)
05:28:23 <pdxleif> But passing in "Proxy n" works - I can then invoke that as "nthProxy (Proxy @1)", I guess?
05:29:32 <ski> "like how in Idris2 you can reference type params in the type sig in the function definition" -- that's `ScopedTypeVariables'
05:29:54 <pdxleif> That's what I thought, but I can't seem to get that to work here.
05:29:58 <ski> but just doing that doesn't help resolve the ambiguity
05:30:57 <pdxleif> I don't know where the ambiguity is - can't I just explicitly pass in "n"? "n" is the only variable afaik.
05:31:14 <ski> you'll need `AllowAmbiguousTypes' to defer the problem to when you use your ambiguous opreation, and then use `TypeApplications' to resolve it, by explicitly passing something for `n' at the use-site
05:31:37 <ski> or else, pass a `Proxy n', which resolves `n'
05:31:43 <pdxleif> I guess it's from Nth not being injectivve?
05:32:00 <ski> "can't I just explicitly pass in \"n\"" -- yes, that's `TypeApplications'
05:32:33 <ski> "I guess it's from Nth not being injectivve?" -- yes, as i've attempted to elaborate on a bit already
05:33:09 <ski> presumaby `IndexAPI' is some list of types. let's say it's  '[Int,Bool,Int]
05:33:49 <ski> now, if you know `Nth n IndexAPI' is equal to `Int', this doesn't determine `n' for you. it could be zero, but could also be two. and so it can't infer which `n' you want to use `nthProxy' at
05:34:18 <pdxleif> Ah, makes sense - thanks.
05:34:19 <ski> so, you need some way of explicitly fixing `n'. so, either passing in a `Proxy n', or else using `TypeApplications'
05:35:40 <ski> (hm, i guess, in case the list was a list of distinct things, one might expect being able to get a unique index. not sure whether that would be easy to code, though)
05:36:20 <pdxleif> Defining it as e.g. "nthProxy :: forall (n :: Nat). Proxy (Nth n IndexAPI; nthProxy = Proxy @(Nth n IndexAPPI)" still says "mismatch between n and n0", though, and suggests AllowAmiguousTypes.
05:37:04 <pdxleif> Someone I expected the "n" that I was passing with @ in the function definition to be literally the "n" from the type signature - didn't know why it's still getting an "n0".
05:37:17 <pdxleif> *Somehow
05:37:19 <ski> yea, i've already mentioned .. that you also need `AllowAmbiguousTypes' to allow this definition (deferring the ambiguity detection to use sites, which can be resolved there with `TypeApplications')
05:41:01 <ski> hm, not quite sure atm why it's talking about `n' vs. `n0', at the definition site, without `AllowAmbiguousTypes'. however, it's quite correct that the type signature, as it stands, is ambiguous
05:45:32 <ski> (maybe it's an artefact of the way it does checking. maybe it would be better not to give these details of the error here. maybe i'm just failing to see why it's relevant)
05:50:57 <yorick> how do I tell cabal configure to add an option in the ghc --make -O linking call?
05:52:00 <pdxleif> The solutions you gave work fine. Guess I'm just curious why it's differant than in Idris. This is using: https://github.com/alpmestan/servant-flatten/blob/master/src/Servant/API/Flatten.hs#L111
05:54:31 <boxscape> Presumably Idris defers ambiguity detection to the use sites by default?
05:54:50 <pdxleif> In Idris I can have e.g. https://gist.github.com/LeifW/579c4eaf4e365b27b3a647890525710c, and while the "n" in e.g. "5 :: nthType" is ambiguous, I can call nthType with "nthType {n = 0}". I guess Haskell is doing the ambiguity check up-front... Guess I don't understand how TypeApplications interacts with ScopedTypeVariables, or something.
05:55:39 <boxscape> ScopedTypeVariables is not super relevant for this, aside from sometimes being useful for TypeApplications
05:56:47 <boxscape> pdxleif basically without being able to supply the implicit arguments like with {n = 0} in idris or with @0 in haskell, ambiguous type vars like this result in useless bindings, so haskell doesn't allow them. And TypeApplications hasn't existed forever, so it's a sensible default
05:56:57 <boxscape> whereas in Idris you could always supply implicit arguments
05:57:11 <boxscape> (in haskell called invisible rather than implicit)
05:58:46 <pdxleif> If I use AllowAbiguousTypes, I don't need any forall or explicitly-passed w/ @ types or anything in the definition of "nthProxy".
05:59:02 <boxscape> but you do at the use site, presumably
05:59:09 <pdxleif> yeah
06:00:40 <lhurttila> is it possible to generate a list with two variables going from 0 to infinity in such a way, that the variables are incremented in turns? So that instead of [[0,0], [0,1], [0,2],...] the list would be [[0,0], [0,1], [1,1],...]
06:01:42 <boxscape> > let xs = [0..] in zip xs $ tail xs
06:01:44 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
06:01:51 <boxscape> hm, not quite
06:03:45 <ski> lhurttila : diagonalization ?
06:03:48 <lhurttila> a simple list comprehension just makes one of the variables go to infinity and I'd need an evenly incrementing infinite list from which to take
06:03:58 <pdxleif> Like if I write "thing :: forall a. a -> a; thing = id @a", that works fine; without the "forall a." it complaints about the "a" in "@a" not being in scope.
06:04:57 <lhurttila> ski If you mean [0,0,[1,1]..] then no. Both need to go from 0 to infinity
06:05:13 <boxscape> pdxleif ScopedTypeVariables only brings tyvars into scope if they're bound by forall
06:05:19 <ski> > [0 ..] >>- \x -> [0 ..] >>- \y -> [(x,y)]
06:05:22 <lambdabot>  [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0,...
06:05:30 <boxscape> % let xs = [0..] >>= \x -> [x, x] in zip xs $ tail xs
06:05:36 <yahb> boxscape: [(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,6),(6,7),(7,7),(7,8),(8,8),(8,9),(9,9),(9,10),(10,10),(10,11),(11,11),(11,12),(12,12),(12,13),(13,13),(13,14),(14,14),(14,15),(15,15),(15,16),(16,16),(16,17),(17,17),(17,18),(18,18),(18,19),(19,19),(19,20),(20,20),(20,21),(21,21),(21,22),(22,22),(22,23),(23,23),(23,24),(24,24),(24,25),(25,25),(25,26),(26,26),(26,27),(27,27
06:05:44 <ski> hm, i guess that doesn't give the order you want
06:06:00 <ski> lhurttila : i assume you still want all combinations of one element from one list, and one element from the other list ?
06:06:14 <ski> (boxscape is on a different idea)
06:06:21 <boxscape> true
06:07:33 <lhurttila> Just a sec while I figure out what you mean :D
06:08:13 <ski> > [(k,n-k) | n <- [0 ..],k <- [0 .. n]]
06:08:16 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
06:08:50 <ski> lhurttila : if you just want all combinations of two natural numbers, in that specific diagonalization order, ^ should suffice
06:09:37 <ski> if you want to be able to take any two infinite lists (not just `[0 ..]'), and select all combinations of one element from one, and one from the other, in the same order, you'll need some more work, i think
06:12:22 <lhurttila> ok now i got that diagonalization but that's not exactly what i need. The idea is to generate a list of coordinates on an infinite plane in order to do some calculations with those and then take a part of those coordinates that form a square
06:13:17 <lhurttila> that diagonal way would work except for taking the squareforming coordinates from the infinite list. at least with a simple take
06:14:42 <lhurttila> but I hae no need for any negative coordinates so both coords from [0..] will work
06:15:04 <ski> oh
06:17:01 <lhurttila> boxscape the example you gave would work but it's missing some coordinates like (1,0) and (3,2) etc
06:17:29 <boxscape> I'm still not quite sure what you want but it looks like ski understood it so I'll leave it to him
06:18:21 <ski> > take 16 [(i,j) | n <- [0 ..],(i,j) <- map (,n) [0 .. n-1] ++ (n,n) : map (n,) [n-1,n-2 .. 0]]
06:18:23 <lambdabot>  [(0,0),(0,1),(1,1),(1,0),(0,2),(1,2),(2,2),(2,1),(2,0),(0,3),(1,3),(2,3),(3,...
06:18:27 <ski> lhurttila : something like that ^ ?
06:20:57 <ski> that adds "L"-shapes, to form larger and larger squares. so, if you pick the first `n^2' elements of that list, you have a square
06:21:44 <lhurttila> ski getting really close at least. I might still need to sort those but i'll only ever take n^2 elements at a time so it might not be a problem
06:22:49 <lhurttila> ski thanks a lot :)
06:23:25 <ski> well, you could vary the order you add the elements in the "L"-shapes, if you prefer
06:23:43 <ski> e.g.
06:24:12 <ski> > take 16 [(i,j) | n <- [0 ..],(i,j) <- map (,n) [0 .. n-1] ++ map (n,) [0 .. n-1] ++ [(n,n)]]
06:24:15 <lambdabot>  [(0,0),(0,1),(1,0),(1,1),(0,2),(1,2),(2,0),(2,1),(2,2),(0,3),(1,3),(2,3),(3,...
06:24:47 <ski> if you want a contiguous zig-zag path, one "L" going one direction, the next the other, you need a little more work, i guess
06:24:59 <ski> one could also alternate
06:25:49 <ski> > take 16 [(i,j) | n <- [0 ..],(i,j) <- concatMap (\k -> [(k,n),(n,k)]) [0 .. n-1] ++ [(n,n)]]
06:25:51 <lambdabot>  [(0,0),(0,1),(1,0),(1,1),(0,2),(2,0),(1,2),(2,1),(2,2),(0,3),(3,0),(1,3),(3,...
06:27:28 <ski> the original diagonalization is primarily ordered on sum of the two coordinates. these latter "square" variants are primarily ordered on the maximum of the two coordinates (and then, secondarily, in different ways)
06:27:42 <lhurttila> great. I'll try these to see if it works.
06:29:22 <ski> i'm still not quite sure whether what i sketched conforms to what you had in mind, but at least you have some variants to play with
06:30:22 * ski idly ponders convolutions
06:32:07 <lhurttila> excactly. I think i'll manage with those once I play with them a bit 
06:38:23 * hackage hnix-store-core 0.2.0.0 - Core effects for interacting with the Nix store.  https://hackage.haskell.org/package/hnix-store-core-0.2.0.0 (imalsogreg)
06:56:35 <ooo_miguel> I have some "computation" which I run via runExceptT and as soon as an error is thrown I get it wrapped inside a Left value. Can I somehow run it easily in an alternative way.. getting all errors skipped and as result: the list of all errors encountered instead as well as the Right value too?
06:57:25 <ooo_miguel> instead (Either Res Error) I want something like (Res,[Error]) 
06:58:49 <Rembane> ooo_miguel: I think you want the Validation type: https://hackage.haskell.org/package/validation
06:59:38 <ooo_miguel> will have a look thanks
07:00:05 <ooo_miguel> but I suppose I have to rewrite the "computation" anyway...
07:04:09 <ski> ooo_miguel : you're not going to get a result directly, in case there's an error. `Validation' allows you to collect multiple (independent) errors, though, not just the first one
07:05:00 <ski> ooo_miguel : of course, you could probably manually catch exceptions, say what to try instead, and incorporate (if you wish) the caught exception into the result
07:05:56 <ski> (iow, i'm not sure "getting all errors skipped" makes much sense. how would you fabricate up a result from thin air, in order to be able to "skip and continue" ?)
07:07:50 <ooo_miguel> yeah just hought of this.. I have a list of independetn calucalations I will just fold over them collecing the failed ones and accumulating the result
07:08:08 <ooo_miguel> passing the result of successfull ones on
07:08:28 <ooo_miguel> and colleting the errors of the failed ones
07:08:49 <ooo_miguel> skipping errors in a arbitrary calculation would not produce any result
08:02:53 * hackage dobutokO2 0.8.2.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.8.2.0 (OleksandrZhabenko)
08:08:23 * hackage tex-join-bib 0.1.0.0 - Compile separate tex files with the same bibliography.  https://hackage.haskell.org/package/tex-join-bib-0.1.0.0 (GregorySchwartz)
08:13:48 <rsoeldner> Hi, after an update to ghcide 0.1.0 (with GHC 8.6.5) running `ghcide` complains about `Could not load module 'Distribution.Simple'`  for the Setup.hs file. Additionally I need it will not be able to "track my changes, I have to restart ghcide.." not sure if this is linked. Someone noticed the same issues ?
09:07:44 <ski> @type sequenceA :: [Validation [e] a] -> Validation [e] [a]
09:07:46 <lambdabot> [Validation [e] a] -> Validation [e] [a]
09:18:42 <maerwald> How do you provide your own CompOption in regex-tdfa. The documentation doesn't show it and the API is weird 
09:24:31 <geekosaur> http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html
09:25:17 <geekosaur> more specifically http://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#t:RegexMaker
09:31:52 <testchan> Should I ask beginner level questions here ? I am new to this forum
09:32:18 <Taneb> testchan: yeah, beginner level questions are OK
09:32:47 <maerwald> geekosaur: I see. Somehow I like the ICU API better, but it introduces C++ deps that make static linking impossible 
09:33:47 <aveltras> is it possible to get a Maybe TypeRep from a String ?
09:35:19 <testchan> Taneb: Thanks. I am try to learn haskell by doing some competitive programming I am stuck on how to process the inputs, basically I will be given inputs number of test cases T via STDIN and need to iterate T lines to get list of inputs cant able to think in terms of functional way to get all the inputs from stdin
09:36:24 <Taneb> testchan: how comfortable are you with basic IO in Haskell?
09:36:39 <testchan> I just read Learn you a haskell for gread good till their IO part
09:37:04 <testchan> Taneb: but without trying anything everything is feeling too abstract
09:37:39 <fryguybob> testchan: Brent Yorgey (byorgey) has some blog posts on how to get started with competitive programming in Haskell: https://byorgey.wordpress.com/2019/04/24/competitive-programming-in-haskell-basic-setup/
09:37:43 <ski> @wiki Introduction to IO
09:37:43 <lambdabot> https://wiki.haskell.org/Introduction_to_IO
09:38:14 <testchan> fryguybob: Thanks, I will read it :) 
09:38:27 <Taneb> testchan: as a little exercise, see if you can write a function replicateIO :: Int -> IO a -> IO [a]; which you pass a number and an IO action and it runs that IO action that number of times and returns all the results in order
09:40:12 <testchan> Taneb: hmm I will try it and get back
09:44:04 <sm[m]> maerwald: there's also http://hackage.haskell.org/package/regex which I think gives you regex-tdfa with a different API 
09:48:19 <sm[m]> https://wiki.haskell.org/Meta-tutorial .. nice
10:00:53 * hackage lz4-hs 0.1.3.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.3.0 (vmchale)
10:13:44 <slack1256Alt> How do I set SCC to monad expressions?
10:14:55 <slack1256Alt> Will ` {-# SCC "myReadFile" #-} readFile "my-data.csv"` report the memory allocation of the execution of `readFile` or the evaluation of `readFile`?
10:28:23 * hackage require 0.4.4 - Scrap your qualified import clutter  https://hackage.haskell.org/package/require-0.4.4 (NickSeagull)
10:37:45 <zzz> ghci says (->) is Defined in ‘GHC.Prim’. is this one of those "truths"?
10:39:13 <merijn> zzz: GHC.Prim is where the names of a bunch of, well, GHC primitives are defined (note, their names, not their meaning)
10:39:27 <geekosaur> everything in GHC.Prim is a "truth" :)  (that is, it's all fake definitions for stuff wired in, for documentation and to create info tables etc.)
10:41:56 <zzz> ok that makes sense
11:01:37 <maerwald> I can't even figure out how to extract a capturing group in a match with regex-foo
11:01:52 <maerwald> There are like 20 RegexLike instances
11:03:12 <maerwald> RegexContext
11:04:22 <geekosaur> it's the one that returns a list of lists, iirc
11:04:40 <geekosaur> first element is the whole matched string, second is first capture group, etc.
11:04:44 <maerwald> Would be good if there was documentation
11:04:58 <geekosaur> the regex api reflects how the author feels about regex :)
11:05:20 <maerwald> Messy
11:06:10 <geekosaur> sorry, single list. I don't recall what list of lists was. I did go throughh it at one point, just t prove I could
11:06:14 <maerwald> (RegexContext regex source [MatchText source], RegexLike regex source, RegexFix regex source) => RegexContext regex source (Matches source)
11:06:18 <maerwald> I mean, really?
11:06:50 <maerwald> sm[m]: that's the alternative API :>
11:07:38 <maerwald> geekosaur: single list of "MatchText"?
11:07:41 <maerwald> There are multiple 
11:08:01 <maerwald> MachText, MatchArray, AllTextMatches
11:08:03 <maerwald> ...
11:08:28 <sm[m]> geekosaur: the regex api.. are you referring to the "regex" package, as I am ? I thought it had a more sane api than regex-base etc.
11:08:48 <maerwald> I'm looking at both
11:08:54 <geekosaur> I was referring to regex-base
11:09:10 <geekosaur> in all its grisly horror
11:09:29 <maerwald> ICU is so much cleaner
11:11:07 <maerwald> Also "get first match" -- returns empty string if no match
11:11:28 <geekosaur> you can just imagine whoever came up with that mess thinking "working wth regex should be its own punishment"
11:11:30 <sm[m]> maerwald, what about regex's "comprehensive documentation, tutorials and copious examples" - any help ?
11:13:20 <maerwald> geekosaur: not sure that was the thought. It was probably more of a "let's see how I can overuse classes" approach :P
11:14:23 * hackage cachix 0.3.7 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.7 (domenkozar)
11:14:49 <sm[m]> here's an easy api for common needs: https://hackage.haskell.org/package/hledger-lib-1.17.0.1/docs/Hledger-Utils-Regex.html
11:23:22 <sm[m]> on another note: the article shared by Philip Wadler is a must read: https://wadler.blogspot.com/2020/03/coronavirus-why-you-must-act-now.html . Early social distancing saves lives.
11:26:39 <maerwald> Now I get all sorts of "Could not deduce" errors lol
11:27:09 <maerwald> makeRegexOpts doesn't seem to work well with regex-tdfa
11:27:31 <maerwald> It sets the last type variable to Regex, but regex-tdfa doesn't have an instance
11:28:39 <maerwald> sm[m]: Starbucks is empty, more space for me.
11:31:23 <maerwald> Could not deduce (RegexMaker Regex CompOption ExecOption Regex) arising from a use of ‘=~’
11:31:40 <maerwald> game over
12:38:53 * hackage hlrdb-core 0.1.6.0 - High-level Redis Database Core API  https://hackage.haskell.org/package/hlrdb-core-0.1.6.0 (identicalsnowflake)
12:43:23 * hackage hlrdb 0.3.1.0 - High-level Redis Database  https://hackage.haskell.org/package/hlrdb-0.3.1.0 (identicalsnowflake)
14:31:06 <zeta_0> hello there, i would like to start contributing to darcs, where do i start? i am using the nix package manager
14:31:43 <koz_> Is there some package with either an Arbitrary instance or a Gen for Text?
14:31:58 <maerwald> zeta_0: there is a dedicated channel for it
14:32:25 <zeta_0> maerwald: oh is it #darcs ? and is the channel usually dead?
14:32:48 <koz_> :t divMod
14:32:50 <lambdabot> Integral a => a -> a -> (a, a)
14:34:57 <zeta_0> maerwald: ok, i messaged #darcs, the channel looks dead, so it may take a while
14:35:28 <maerwald> The lead developers used to be active there. What do you mean with dead?
14:36:54 <zeta_0> maerwald: by dead i mean very few people in the channel, and no activity going on there. so it looks dead
14:37:04 <[exa]> zeta_0: btw there's some 'much improved' version of darcs but I forgot the name of it
14:37:17 <[exa]> which certainly seemed more active the last time I looked
14:37:27 <maerwald> [exa]: That is not coded in haskell
14:37:53 <isBEKaml> [exa]: that's Pijul, written in Rust
14:37:57 <isBEKaml> (not haskell)
14:39:09 <[exa]> oh yes, thanks for reminder (also that explains why I forgot about it)
14:39:11 <maerwald> And "much improved" is only the advertising
14:39:23 <[exa]> yeah see it now :]
14:41:09 <sm[m]> #darcs is usually quiet, but also also usually quite responsive
14:41:25 <maerwald> Yes, just because people don't post OT doesn't mean it's dead :>
14:42:53 <sm[m]> and of course there's the dev mail list, the Darcs for Developers guide on the wiki, the README, etc. :)
14:44:25 <iqubic> Should I switch from Git to Darcs?
14:44:31 <zeta_0> someone responded in #darcs, yay
14:44:41 <zeta_0> iqubic: i was thinking the same thing
14:45:38 <sm[m]> are you pure of heart ? filled with courage ? willing to wear the hair shirt ? content with a simpler kind of life ?
14:48:24 <koz_> :t repeat
14:48:25 <lambdabot> a -> [a]
14:53:48 <iqubic> koz_: reapeat x = x : repeat x
14:54:10 <koz_> iqubic: Thanks, lol. I always get repeat and replicate confused.
14:54:30 <iqubic> replicate is a finite length list.
14:54:47 <iqubic> replicate 0 _ = []
14:55:04 <iqubic> replicate n x = x : replicate (n-1) x
14:55:31 <iqubic> :t replicate
14:55:34 <lambdabot> Int -> a -> [a]
14:55:43 <koz_> Yeah, I just don't recall which one has which name.
14:55:51 <koz_> I know 'one is finite, the other's not', but I forget how they're named.
14:55:59 <iqubic> Do my definitions look right?
14:56:30 <maerwald> Nice, I can't fetch regex-posix from within an alpine docker container: curl: (6) Could not resolve host: objects-us-east-1.dream.io
15:01:32 <phadej> iqubic: no, hint:
15:01:34 <phadej> > replicate (-2) 'x'
15:01:37 <lambdabot>  ""
15:02:10 <maerwald> and there seems to be no option to turn off cabal mirrors
15:03:18 <phadej> the objects-us-east-1.dream.io resolves here just fine
15:07:42 <iqubic> phadej: Yeah. I realized that.
15:08:27 <phadej> functions taking Int are a lie
15:11:27 <ski> should be taking `Word', perhaps ?
15:12:28 <monochrom> What is the lie?
15:12:41 <solonarv> the lie is that negative arguments are sensible.
15:13:13 <monochrom> Oh, so some such functions, not all such functions.
15:13:55 <maerwald> Can you install from a local sdist?
15:13:58 <monochrom> Universally quantified statements are a lie.
15:14:33 * dmwit . o O ( replicate :: Maybe Word -> a -> [a] )
15:14:45 <[exa]> maerwald: I had luck with `cabal install [path to extracted dist]`
15:15:00 <[exa]> maerwald: needs to be a subdirectory of your package though
15:15:12 <[exa]> (not sure about reasons)
15:15:12 <maerwald> Well yeah, can just manually extract
15:15:22 <maerwald> Was wondering if you can give it the file directly
15:15:35 <dmwit> replicate (Just 0) _ = []; replicate n x = x : replicate (pred <$> n) x
15:15:38 <monochrom> I was able to do some form of "cabal install xxx.tar.gz" too.
15:16:38 <ski> why `Maybe', dmwit ?
15:16:49 <dmwit> ski: see implementation ;-)
15:17:07 <ski> oh, for infinite
15:17:15 <nshepperd> random-fu doesn't support 8.8 :S
15:18:24 <ski> > genericReplicate (fix succ :: Natural) '.'
15:18:26 <lambdabot>  "..............................................................................
15:18:51 <maerwald> Hm, #haskell-stack seems dead. Do they have other support channels?
15:19:09 <maerwald> I'm interested on how they build binaries for mac and freebsd
15:19:37 <nshepperd> oh, int-e already fixed it but the maintainer has vanished ;_;
15:23:45 <sm[m]> it's another quiet one, but not dead..
15:24:01 <sm[m]> I think stack's issue tracker would be the next stop. It's active.
15:28:35 <maerwald> I don't really have an "issue"
15:29:27 <maerwald> Just managed to build a fully static haskell binary in alpine docker. No need for complicated nix stuff
15:29:45 <maerwald> Just need to make sure you don't have any C++ dependencies, then everything goes s**t
15:30:08 <maerwald> But no idea about mac and FreeBSD
15:30:16 <koala_man> how did you do it?
15:31:05 <maerwald> koala_man: https://gist.github.com/hasufell/b0c4c204349f7a227b60f8f94defa549
15:32:47 <maerwald> And then pass --ghc-options='-optl-static' to cabal install ofc
15:34:22 <koala_man> neat, I couldn't get cabal to do it last time I tried. I should give it another go
15:50:58 <koz_> Ah, Control.Monad. The heuristic answer to any question of the form 'where does general function X come from?'.
15:51:08 <koz_> You give 'Control.Monad' as an answer, you'll be right about 80% of the time.
16:06:53 * hackage dice 0.1.0.1 - Simplistic D&D style dice-rolling system.  https://hackage.haskell.org/package/dice-0.1.0.1 (BertramFelgenhauer)
16:15:23 * hackage random-fu 0.2.7.4 - Random number generation  https://hackage.haskell.org/package/random-fu-0.2.7.4 (DominicSteinitz)
16:16:59 <d34df00d> How do you call the case construct?
16:17:21 <d34df00d> I'm writing a blog post and I'm trying to say smth like "The function does a case switch over the generated list of alternatives"
16:17:25 <d34df00d> But "switch" sounds alien here.
16:17:41 <Axman6> 3case <expr> of <pat> -> expr; <pat> -> <expr>
16:17:53 <d34df00d> No, I mean for a human.
16:17:53 * hackage random-source 0.3.0.8 - Generic basis for random number generators  https://hackage.haskell.org/package/random-source-0.3.0.8 (DominicSteinitz)
16:17:58 <Axman6> "Uses a case statement"
16:18:01 <d34df00d> Ah!
16:18:02 <ChaiTRex> d34df00d: by cases?
16:18:02 <d34df00d> Statement!
16:18:54 <d34df00d> Axman6: hold on, does "the function does a case statement over the generated list of alternatives" sound ok?
16:19:06 <d34df00d> ChaiTRex: hmm, how would you word that phrase?
16:20:22 <ChaiTRex> d34df00d: the function handles the generated list of alternatives by cases
16:20:32 <Axman6> "Usess a case statement" would be more correct I feel
16:21:15 <d34df00d> I guess Although I might reword that entirely... This doesn't convey the right amount of information I guess.
16:21:16 <d34df00d> Thanks!
16:21:30 <ChaiTRex> d34df00d: Yes, I think Axman6 is correct
16:21:39 <Lears> "statement" has imperative implications. Wouldn't you usually call it a case-of expression?
16:21:52 <d34df00d> Can you say smth like "the function does a `case` analysis of the `stats` argument"?
16:22:34 <ChaiTRex> d34df00d: You can do a case analysis without 'case' by using, say, 'if-then-else'
16:23:01 <d34df00d> Hence it's in backticks (which my hakyll would render with haskell syntax highlighting).
16:47:35 <fog> I think I managed to make a Free Sum type... https://github.com/fog-hs/FreeSum/blob/master/HFFree.hs
16:48:54 <fog> but i think its wrong
17:48:51 <koz_> I wish there was a non-APL-looking version of http://hackage.haskell.org/package/microlens-mtl-0.2.0.1/docs/Lens-Micro-Mtl.html#v:-60--60--37--61-
17:58:10 <d34df00d> L in APL stands for lens.
17:58:12 <d34df00d> So that's expected.
17:59:41 <Axman6> koz_: which operator is that linking to? My browser isn't taking me to a particular definition
17:59:59 <koz_> Axman6: (<<%=)
18:01:23 <hpc> the P is for parsec and A is for arrow
18:01:25 <hpc> maximum confusing
18:02:26 <Axman6> ah, generalised i++
18:02:45 <koz_> Yep.
18:03:10 <hpc> Axman6: the last "-" probably isn't part of the link
18:03:35 <koz_> hpc: It is according to my browser.
18:03:39 <Axman6> yeah that was it
18:04:01 <Axman6> cmd-clicking the link dropped the last -
18:04:19 <opportunity> Im going to get right into it. I have a plan in place that could potentially begin taking place very soon that will involve into the billions of dollars in spending to create a second internet. The basis of this must be programmed in Haskell. It must be open source and built with true freedom in mind. Absolutely pure in and out from the ethics to
18:04:19 <opportunity> Haskell. How possible is this. Do you believe that the community could make this happen? 
18:04:59 <opportunity> I know where we need to be but I don't know how to get there
18:05:21 <opportunity> Don't expect anything fast
18:05:39 <Axman6> I feel like you should be talking to Sir Tim Berners-Lee
18:05:54 <MarcelineVQ> which community?
18:05:56 <opportunity> Who is that?
18:06:32 <Axman6> "Who is Sir Tim Berners-Lee" "second internet"... yeah I'm out, good luck
18:07:12 <opportunity> Ya my bad thanks for the tip
18:08:50 <hpc> huh, TBL is a sir
18:09:13 <Axman6> I mean, he dis invent.. the first internet
18:09:20 <Axman6> did*
18:10:14 <hpc> the "web", anyway
18:10:39 <hpc> but i guess that's splitting hairs for purpose of the last 5 minutes :P
18:12:28 <MarcelineVQ> I guess we don't get to ask more questions
18:19:23 * hackage time 1.10 - A time library  https://hackage.haskell.org/package/time-1.10 (AshleyYakeley)
18:39:24 <quiet_laika[m]> im reading user input which i want to encode as part of a json bytestring and send as a request body with http-client. should i parse that input as text or a bytestring? i initially went with text, but since sending things over the network generally requires encoding from text with a certain locale in mind, i didn't want to cause inadvertent bugs for users with non-UTF8 locales. i am wrapping my program in `withUtf8`
18:39:24 <quiet_laika[m]> from https://hackage.haskell.org/package/with-utf8-1.0.0.0, but it's not obvious to me if that will account for this scenario (parsing text from the console, encoding to utf8 for sending over the network). should i be safe to just use `encodeUtf8` or do i need to take user locale into account?
18:41:08 <quiet_laika[m]> err
18:41:26 <quiet_laika[m]> no wait yes i think thats all right.
18:44:01 <quiet_laika[m]> should i just parse everything as bytestrings if i will need to send it over the wire anyway?
18:48:23 * hackage rattletrap 9.0.9 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.9 (fozworth)
18:48:26 <koz_> So, does (<<%=) have a non-APL name in any lens library? I'm curious if this is a microlens deficiency or it just doesn't get a name.
18:48:48 <iqubic> I don't think it has a name.
18:48:54 <koz_> iqubic: Much disappoint.
18:49:53 <iqubic> > (. sqrt) . (*) 4 4
18:49:55 <lambdabot>  error:
18:49:55 <lambdabot>      • No instance for (Typeable a0)
18:49:55 <lambdabot>          arising from a use of ‘show_M264843549996215982011809’
18:50:09 <iqubic> > ((. sqrt) . (*)) 4 4
18:50:12 <lambdabot>  8.0
18:50:23 <iqubic> I legit just saw that line of code in the wild.
18:50:31 <koz_> ... someone loves @pl a bit much.
18:50:44 <iqubic> I'd prefer to write it as "let f x y = (sqrt x) * y"
18:50:54 <iqubic> "in f 4 4"
18:51:40 <iqubic> Except that the PL version square roots the second argument.
18:52:09 <iqubic> @pl \x y -> x * (sqrt y)
18:52:09 <lambdabot> (. sqrt) . (*)
18:52:29 <iqubic> @pl \x y -> (sqrt y) * x
18:52:29 <lambdabot> (. sqrt) . (*)
18:55:05 <d2ci8xc5> I'm a bit confused with this
18:55:20 <d2ci8xc5> I'm pretending that the (>>) operator in monad does this
18:56:00 <d2ci8xc5> m >> n = m >>= \_ -> n
18:56:16 <d2ci8xc5> so it ignores the value binded to it and returns the second value
18:56:27 <d2ci8xc5> Nothing >> Just 3
18:56:31 <d2ci8xc5> returns Nothing
18:56:37 <koz_> :t (^.)
18:56:40 <lambdabot> s -> Getting a s a -> a
18:56:44 <koz_> I officially name this 'wink'.
18:58:03 <d2ci8xc5> why does it return Nothing? Shouldn't it ignore the Nothing that we are passing in and return the n value (Just 3)
18:58:26 <koz_> d2ci8xc5: That would be incorrect, since that would ignore the effect.
18:58:37 <ChaiTRex> d2ci8xc5: Maybe stops when it receives the first Nothing.
18:58:37 <koz_> Whether we get a 'Nothing' or a 'Just' is the effect, _not_ the value.
18:59:16 <d2ci8xc5> I don't think effect is the right word? Shouldn't it be the context?
18:59:50 <koz_> d2ci8xc5: Why not? 'Failure' is totes an effect.
19:00:05 <jackdk> "effect" is a reasonable term here, if you think of `Maybe a` as a computation whose effect is either "return an `a`" or "fail, returning no result"
19:00:09 <koz_> (in the 'I cannot give you an answer' sense)
19:00:24 <d2ci8xc5> ahh right
19:00:59 <d2ci8xc5> I'm still trying to learn monads. Just taking the initial grok
19:01:10 <jackdk> yeah it's a fun experience
19:01:36 <koz_> d2ci8xc5: Focus on what monads can do for us, rather than what they are. They exist so we can have first-class effects, and abstractions around them.
19:01:40 <koz_> (I find that helps me)
19:02:12 <d2ci8xc5> So this confuses me:
19:02:14 <d2ci8xc5> Nothing >>= \x -> Just 3
19:02:18 <jackdk> koz_: that's pretty close to the most productive advice I've seen: "monads are a software engineering pattern to support a certain type of code reuse"
19:02:25 <d2ci8xc5> returns Nothing
19:02:40 <jackdk> @src (>>=)@Maybe
19:02:40 <lambdabot> Source not found. Do you think like you type?
19:02:45 <koz_> d2ci8xc5: What else can it do?
19:02:45 <jackdk> :(
19:03:00 <koz_> In order for the right-hand side of that >>= to do anything, it needs a value.
19:03:11 <koz_> If 'Nothing' is what you have on the left-hand side, what possible value could it have?
19:03:22 <koz_> So the only thing it could reasonably do is 'forward' said Nothing.
19:03:54 <jackdk> d2ci8xc5: look at the type: `(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b`. If the `Maybe a` argument is `Nothing`, it is not possible to find an `a` to pass to the function argument, so the result _must_ be `Nothing`
19:04:07 <koz_> jackdk basically said what I meant in a clearer way.
19:04:15 <d2ci8xc5> Ohhh right. I'm thinking only of this part (\_ -> Just 3) will only return Just 3. But (>>=) on Nothing value returns Nothing
19:04:47 <d2ci8xc5> thanks all
19:04:51 <MarcelineVQ> @src Maybe (>>=)
19:04:51 <lambdabot> (Just x) >>= k = k x
19:04:51 <lambdabot> Nothing  >>= _ = Nothing
19:05:52 <koz_> Indeed, you have to define >>= this way with Nothing, because you can't generally magic up values from nowhere.
19:06:38 <d2ci8xc5> Yeah that makes sense. You cant bind a a value from Nothing because there is no meaningful value to work on
19:07:18 <iqubic> Is 0 a multiple of 3?
19:07:28 <ChaiTRex> iqubic: Yes.
19:07:35 <iqubic> Why do you say that?
19:07:52 <ChaiTRex> iqubic: Because you can multiply an integer by 3 to get it.
19:09:34 <koz_> 0 is thus a multiple of everything.
19:18:37 <iqubic> I'm arguing with my friends on this very topic. Thanks for the advice.
19:44:45 <suzu> jackdk | koz_: that's pretty close to the most productive advice I've seen: "monads are a software engineering pattern to support a certain type of code reuse"  
19:44:49 <suzu> this is an excellent line
19:44:55 <suzu> im.. gonna steal it
19:45:05 <suzu> to explain haskell to the unwashed masses at work
19:45:08 <koz_> Lines are made to be stolen.
19:46:30 <suzu> lol
19:46:41 <jackdk> raising the waterline, one stolen line at a time
19:48:26 <koz_> Are {-# UNPACK #-}ed tuples transitively {-# UNPACK #-}ed too?
19:48:48 <koz_> So, if I have {-# UNPACK #-} !(Word, Word), would those Words get {-# UNPACK #-}ed too?
19:53:51 <lyxia> I guess so, I can't imagine how else that could work.
19:54:56 <koz_> I guessed so as well, but wouldn't mind being sure.
19:57:37 <koz_> lyxia: This suggests not: https://wiki.haskell.org/Performance/Data_types#Unpacking_strict_fields
19:58:32 <koz_> Since then wouldn't T end up as 'data T = T Int# Float#?
19:58:41 <koz_> s/?/'?
20:05:09 <monochrom> Please don't steal my hairline!
20:23:17 <solonarv> if you don't have a hairline, does that mean you have no hair, or hair everywhere?
20:28:28 <mjrosenb_> with lenses, if I have a predicate and I want to find all of the indexes where that predicate holds on some collection, is there a prettier way to do it than to get the tuples of the index and the value, then discard the values?
20:35:37 <lyxia> koz_: it unpacks the tuple, but the tuple is not unpacked, so you get Int and Float.
20:35:54 <koz_> So the unpacking isn't transitive. Got it.
20:35:59 <lyxia> koz_: Ah I read your first messages too fast
20:36:03 <lyxia> right
20:36:13 <lyxia> you need to unpack an unpacked tuple.
20:36:30 <koz_> 'Yo dawg, we heard you like {-# UNPACK #-}...'
20:37:00 <koz_> So what, would I need something like '{-# UNPACK #-} !({-# UNPACK #-} !Word, {-# UNPACK #-} !Word)'? Is that even legal?
20:51:52 <mjrosenb_> also, is there a way to provide a default value for accessing a prism?
20:54:09 <iqubic> mjrosenb_: What are you trying to do here? That question doesn't make much sense to me.
20:54:24 <dibblego> @type non
20:54:26 <lambdabot> (Eq a, Profunctor p, Functor f) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
20:54:29 <glguy> > Nothing ^. _Just . non 0
20:54:32 <lambdabot>  error:
20:54:32 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M556140798564...
20:54:32 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
20:55:01 <iqubic> But yeah. non seems good.
20:55:52 <glguy> err, no, not quite right
20:58:21 <glguy> > Nothing ^? (_Just `failing` like 0)
20:58:24 <lambdabot>  Just 0
20:58:34 <koz_> 'Just failing like 0'.
20:58:49 <koz_> Lens sounding like natural language. Never figured I'd see that.
20:59:31 <iqubic> What does like do?
20:59:33 <iqubic> :t like
20:59:35 <lambdabot> (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
20:59:40 <iqubic> I see.
21:00:09 <koz_> iqubic: ... I'm actually jelly of your lens parsing skills.
21:00:15 <koz_> Because I can't make heads or tails of that type.
21:00:26 <iqubic> I know what that does.
21:01:06 <iqubic> :t failing
21:01:07 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
21:01:31 <iqubic> Alright. That too makes sense to me.
21:02:13 <koz_> :t failing like 0
21:02:15 <lambdabot> (Conjoined p, Contravariant f1, Num (Over p f2 (Control.Lens.Internal.Bazaar.BazaarT p f2 a (p a (Control.Lens.Internal.Bazaar.BazaarT p f2 a b b)) (f1 (p a (Control.Lens.Internal.Bazaar.BazaarT p
21:02:15 <lambdabot> f2 a b b)))) (f1 b) a b), Profunctor (Control.Lens.Internal.Bazaar.BazaarT p f2 a), Functor f1, Applicative f2) => Over p f2 (Control.Lens.Internal.Bazaar.BazaarT p f2 a (p a (Control.Lens.Internal.
21:02:15 <lambdabot> Bazaar.BazaarT p f2 a b b)) (f1 (p a (Control.Lens.Internal.Bazaar.BazaarT p f2 a b b)))) (f1 b) a b
21:02:48 <koz_> :t _Just `failing` like 0
21:02:50 <lambdabot> (Applicative f, Contravariant f, Num a) => Over (->) f (Maybe a) (Maybe a) a a
21:03:43 <iqubic> koz_: The first one is trying to turn "like" into a traversal, and "0" into a lens.
21:03:57 <iqubic> Which makes no sense, but Haskell does it anyways.
21:04:06 <koz_> Ah.
21:05:39 <iqubic> Actually, the first argument to failing can be any getter.
21:05:53 <iqubic> https://hackage.haskell.org/package/lens-4.19.1/docs/Control-Lens-Combinators.html#t:Traversing
21:05:56 <iqubic> :t failing
21:05:57 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
21:06:10 <iqubic> No. Actually, it's a traversal.
21:06:26 <iqubic> Failing wants a traversal first.
21:06:51 <iqubic> And returns an Over as the result. No clue what an Over is though.
21:06:53 <iqubic> :t like
21:06:55 <lambdabot> (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
21:17:45 <iqubic> > Nothing ^. failing _Just $ like 0
21:17:47 <lambdabot>  error:
21:17:47 <lambdabot>      • Couldn't match type ‘Maybe (Optic' p0 f0 s0 Integer)
21:17:47 <lambdabot>                             -> f (Maybe b)’
21:18:39 <iqubic> > Nothing ^? failing _Just $ like 0
21:18:42 <lambdabot>  error:
21:18:42 <lambdabot>      • Couldn't match expected type ‘Optic' p0 f1 s0 Integer -> t’
21:18:42 <lambdabot>                    with actual type ‘Maybe (a0 -> f0 b0)’
21:18:49 <iqubic> :t (^?)
21:18:51 <lambdabot> s -> Getting (First a) s a -> Maybe a
21:19:07 <Axman6> :t like
21:19:09 <lambdabot> (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
21:22:09 <jle`> > Nothing ^? (failing _Just $ like 0)
21:22:11 <lambdabot>  Just 0
21:23:13 <iqubic> Can you write that without the use of (^?)
21:23:23 <jle`> (^?) is preview
21:23:29 <iqubic> Ah. I see.
21:23:40 <jle`> :t preview (failing _Just (like 0))
21:23:41 <lambdabot> (MonadReader (Maybe a) m, Num a) => m (Maybe a)
21:23:43 <iqubic> But this is going to succeed 100% of the time.
21:23:58 <jle`> yup
21:24:06 <iqubic> > fromJust $ Nothing ^? (failing _Just $ like 0) -- Nothing wrong here
21:24:09 <lambdabot>  0
21:24:22 <jle`> don't use fromJust and ^? heh, if you want the 0 then use ^. instead
21:24:28 <jle`> if you are usre it will pass and you want a non-Maybe
21:24:43 <jle`> if you want to return Maybe use ^?, if you want to return not-the-Maybe, use ^.
21:24:49 <jle`> > (1,2) ^? _1
21:24:51 <lambdabot>  Just 1
21:24:53 <jle`> > (1,2) ^. _1
21:24:56 <lambdabot>  1
21:25:39 <koz_> Thanks to microlens and having to slosh around MonadReader SomeGiantRecord m and MonadState SomeOtherGiantRecord m, lens is slowly growing on me.
21:25:54 <koz_> s/lens is/lenses are/
21:26:44 <iqubic> > (1,2) ^. _3
21:26:46 <lambdabot>  error:
21:26:46 <lambdabot>      • Could not deduce (Num a0)
21:26:46 <lambdabot>        from the context: (Num a, Num b, Field3 (a, b) (a, b) b1 b1)
21:26:52 <iqubic> Hmm?
21:27:13 <jle`> probably a polymorphic literal issue
21:27:18 <jle`> > (True, False) ^. _3
21:27:19 <lambdabot>  error:
21:27:19 <lambdabot>      • No instance for (Field3 (Bool, Bool) (Bool, Bool) () ())
21:27:20 <lambdabot>          arising from a use of ‘e_13’
21:27:31 <iqubic> Or not.
21:27:46 <jle`> that error makes sense, doesn't it?
21:27:49 <iqubic> Yes.
21:27:57 <jle`> you can only _3 instances of Field3
21:29:40 <iqubic> Right.
21:29:58 <iqubic> > [1,2] ^. _3
21:30:00 <lambdabot>  error:
21:30:01 <lambdabot>      • Could not deduce (Num a0)
21:30:01 <lambdabot>        from the context: (Num a, Field3 [a] [a] b b)
21:31:13 <iqubic> Looks like there's no instances of FieldN for list. Regardless of the N.
21:33:27 <jle`> yup because it has to be total
21:33:30 <jle`> they are lenses
21:33:34 <iqubic> Right.
21:33:35 <jle`> and you can't write total instances even for _1
21:55:24 * hackage markov-realization 0.4 - Realizations of Markov chains.  https://hackage.haskell.org/package/markov-realization-0.4 (alexloomis)
21:58:53 * hackage hurl 1.2.0.0 - Haskell URL resolver  https://hackage.haskell.org/package/hurl-1.2.0.0 (alcinnz)
22:24:39 <mjrosenb_> iqubic: I have a prism that I'm composing with a lens to extract a single Int field from a data constructor.  Rather than using ^? to get a Maybe Int, I'd like to provide it with a value to evaluate to when the input is a different constructor
22:36:10 <iqubic> I have no idea how to do that.
23:21:18 <mjrosenb_> iqubic: that makes two of us :-p
