00:01:11 <Io__> What an incredible language this is.
00:02:26 <Io__> I feel I'm learning so much from this one, did you feel this way when you first staarted learning it?
00:25:53 * hackage tagsoup-navigate 0.1.0.5 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.5 (TonyMorris)
00:27:35 <xandru> can I view the versions of packages in my current haskell environment with cabal?
00:30:24 * hackage pantry 0.4.0.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-0.4.0.0 (MichaelSnoyman)
00:59:53 * hackage aeson-value-parser 0.18 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.18 (NikitaVolkov)
01:40:47 <isovector1> is there a reason there's no `instance (Monoid (f (g a))) => Monoid (Compose f g a)` in base?
02:03:54 <carbolymer> can I generify this instance of Maybe a into Functor a ? https://bpaste.net/2CXA
02:07:23 * hackage tagsoup-navigate 0.1.0.6 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.6 (TonyMorris)
02:19:14 <isovector1> carbolymer: no; you have no means of constructing an `f`
02:20:42 <isovector1> but you might be looking for the pair of constraints `(Bounded, Enum)`
02:20:51 <isovector1> enumerate = [minBound, maxBound]
02:20:59 <isovector1> err, [minBound .. maxBound]
03:17:17 <carbolymer> yeah, but enum only works with constructors without arguments, and I'm writing Enumerable class for everything
03:17:58 <merijn> carbolymer: What?
03:18:08 <merijn> Enum works fine with arguments
03:18:32 <merijn> Granted, you probably need bounded for it to make sense
03:19:25 <carbolymer> then hoogle lies
03:19:27 <carbolymer> "Instances of Enum may be derived for any enumeration type (types whose constructors have no fields)."
03:19:39 <merijn> carbolymer: That's only talking about deriving
03:19:49 <merijn> Nothing stops you from writing another instance by hand
03:20:23 <carbolymer> that isn't obvious from this sentence, but thanks for clarification
03:34:23 * hackage tagsoup-navigate 0.1.0.7 - Tagsoup Navigate  https://hackage.haskell.org/package/tagsoup-navigate-0.1.0.7 (TonyMorris)
03:34:25 <zincy_> Should you do logging inside a throwJSONError function which runs in a Servant Handler?
03:34:41 <zincy_> Or should throwing errors and logging be decoupled?
03:34:59 <zincy_> Any pointers appreciated as I haven't really done any logging before
03:56:49 <aviD> Is there an http server library that uses fused-effects?
04:07:53 * hackage hw-bits 0.7.1.5 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.5 (haskellworks)
04:21:22 <zincy_> What is a pretty way of checking a (Maybe a, Maybe a) for (Nothing, Nothing)
04:21:47 <zincy_> Just want a pure () in this case
04:23:05 <zincy_> null . catMaybe
04:24:00 <zincy_> Hmm now what about (Maybe a, Maybe b)
04:30:42 <sid56> Hi, I just started with Haskell and stack. I have few doubts regarding the same, is it alright if I ask them now? 
04:30:55 <hc> sure
04:31:14 <sid56> cool
04:31:37 <sid56> I have a question about stack and how it handles sub dependencies and so on 
04:31:43 <sid56> stack install beam Stack has not been tested with GHC versions above 8.6, and using 8.8.2, this may failStack has not been tested with Cabal versions above 2.4, but version 3.0.1.0 was found, this may failError: While constructing the build plan, the following exceptions were encountered:In the dependencies for beam-0.3.2.0:    HDBC needed, but the
04:31:44 <sid56> stack configuration has no specified version  (latest matching version is 2.4.0.3)    HDBC-sqlite3 needed, but the stack configuration has no specified version  (latest matching version is 2.3.3.1)    base-4.13.0.0 from stack configuration does not match >=4.8 && <4.9  (latest matching version is 4.8.2.0)needed since beam is a build target.Some
04:31:44 <sid56> different approaches to resolving this:  * Build requires unattainable version of base. Since base is a part of GHC, you most likely need to use a different GHC version with the matching base.Plan construction failed.
04:31:49 <sid56> oh 
04:31:58 <sid56> it didn't code format 
04:32:25 <sid56> on doing `stack install beam`
04:32:47 <hc> you can use lpaste.net to paste longer outputs
04:32:48 <sid56> where does it get installed? is there a global dependencies dir? 
04:33:04 <hc> or even a normal pastebin
04:33:06 <sid56> what would be an equivalent of `pip install` 
04:33:20 <hc> stack install. it should install binaries to ~/.local/bin iirc
04:34:03 <sid56> what if I have conflicting dependencies? does stack does  provide something like `pipenv` (python) 
04:34:28 <tdammers> stack doesn't allow conflicting dependencies
04:34:33 <tdammers> it uses "snapshots"
04:35:06 <tdammers> that is, the stackage team publish curated lists of package versions for most of hackage that were tested to have no conflicts between them
04:35:29 <tdammers> and when you build a project with stack, you pick one of those lists, and all your dependencies will be taken from the versions in that list
04:35:43 <tdammers> and because the entire list is conflict-free, so will your dependencie
04:35:46 <tdammers> s
04:36:19 <tdammers> cabal takes a different approach; here we do have a proper dependency resolution mechanism, but since the v2 set of commands, cabal uses what's called "nix-style builds"
04:36:25 <sid56> wow 
04:36:30 <sid56> I didn't know thos 
04:36:33 <sid56> this*
04:37:28 <tdammers> it caches builds for each package version, so you can have different versions of each package around, and use a different one for each project, but unlike virtualenvs, you don't need to recompile a package if you have previously built the exact same version for another project, but you still get the same kind of project isolation
04:38:43 <tdammers> anyway, the answer to your question is that the stackage snapshot you're using doesn't contain an entry for those HDBC libraries depend on
04:39:27 <sid56> I see, I will read more about snapshots and their internal workings of it 
04:39:44 <sid56> https://pastebin.com/BMu4thDY
04:40:03 <sid56> in this what does the errors mean? 
04:41:15 <sid56> what is stack configuration? if there are snapshots, shouldn't `stack install beam` install all the latest dependencies with which it complies with? 
04:46:30 <lyxia> no it looks up which version to install in the snapshot
04:47:03 <sid56> oh okay 
04:47:08 <lyxia> but the snapshot doesn't include HDBC or HDBC-sqlite3 (that's what "the stack configuration has no specified version" means)
04:47:26 <lyxia> and it includes a version of base that's out of bounds
04:47:44 <sm[m]> beam on hackage was released in 2016 and revised once in 2018. The version in git will likely be more stack-installable
04:48:06 <yushyin> try beam-core?
04:48:43 <sid56> yushyin yeah I will resolve that error somehow, I wanted to understand how all of this works since it felts fundamentally different from python 
04:49:48 <sid56> is there a documentation link which explain snapshots? and how to make those if I were to create my own lib? 
04:50:23 <yushyin> https://www.stackage.org/
04:50:45 <sm[m]> The stack manual should help, sid56. It’s not that different I think ? Though, nobody understands python packaging :)
04:51:30 <yushyin> sid56: you might start with the explanation on that page
04:52:38 <sid56> haha it took me a while to understand pip and all the different open source projects trying to solve one problem but it made sense in the end 
04:52:42 <sid56> thanks yushyin 
04:53:24 <sm[m]> Good news, in Haskell there’s only two :)
04:53:54 <sid56> yes 
04:53:55 <yushyin> and to me it seems like the 'LTS Haskell 14.27 (ghc-8.6.5)' does not contain beam but beam-core and if you visit https://hackage.haskell.org/package/beam you will see that it is 'Deprecated. in favor of beam-core'
04:54:06 <sid56> oh 
04:54:39 <sm[m]> Good point yushyin
05:47:02 <CMCDragonkai> what's the proper way of using monad-logger with warp? Especially in terms of doing the logging inside the response handler?
05:47:30 <warbo> hello, I've got a GADT 'Command m a' where all of the constructors create a 'Command m Bool'
05:47:57 <warbo> and I've created a function 'castCommand :: Command m a -> Bool -> a' which casts the given Bool to type 'a' (which is always Bool)
05:48:09 <warbo> is this a known pattern, or am I being stupid?
05:48:33 <warbo> (I'm using polysemy, which needs polymorphic effects and effect-handlers; but all my effects return a Bool for success/failure)
05:49:45 <warbo> when I say "cast", I mean 'castCommand' is pattern-matching the constructors, and returning the given Bool in every case
06:19:12 <lyxia> If all commands return Bool, you can factor out the equality so castCommand only has one case.
06:46:38 <fog> what algebraic operations do datatypes satisfy?
06:47:34 <fog> they seem almost monoidal and monadic...
06:48:33 <fog> but i want to get the right way of expressing this, and any other properties they have in terms of extensibility and corresponding intrinsic structure
06:50:04 <fog> i guess they are also kind of comonoidal and comonadic... like, how you could write isomorphic datatypes from arbitrary decompositions 
06:50:31 <fog> so supporting split and cojoin
06:51:18 <fog> hmm, well maybe not (co)monadic, since you actually have to write seperate datatypes for each layer of nesting...
06:51:41 <fog> any ideas?
06:54:02 <fog> ah right, you actually can kind of squash the layers together by rewriting nested datatypes... but only sometimes? i cant quite see the rules that follows
06:58:38 <fog> maybe there are papers about this? like, im guessing Haskell didnt just randomly choose how to express datatypes...
06:59:39 <pataka> fog: I don't know what you are looking for exactly (and evenso, I've only just started to learn Haskell), but:
07:00:06 <boxscape> fog for what it's worth algebraic datatypes form  a semiring, not sure about (co)monadic structures
07:00:45 <pataka> Sum types correspond to addition, product types to multiplication, function application to exponentiation, recursive datatypes to Taylor series.
07:01:31 <fog> i guess the idea that is confusing me is about how it being a Sum of Product types, as opposed to eg. just a Product type (clearly (co)Monadic), is to do with commuting the opperations throught these 2 layers, like commuting the monadicity of Product types with the Sum type...
07:02:46 <fog> boxscape: how is that not just Semigroup? i guess the only difference is being able to express multiplication in terms of addition...
07:03:07 <fog> like, i dont get how the 2 identities of a ring appear
07:04:03 <boxscape> fog the distributive laws?
07:04:17 <fog> unless its just like, an empty datatype is the additional identity, and that natural number 1 expresses the identity on number of times of repeated concatination with itself in a "multiplication" 
07:04:46 <fog> boxscape: can you elaborate? 
07:04:46 <boxscape> I don't think semirings require multiplication to be repeated addition
07:05:02 <fog> just cant see how else they would apply to datatypes
07:05:04 <boxscape> they require a⋅(b + c) = (a⋅b) + (a⋅c) and (a + b)⋅c = (a⋅c) + (b⋅c)
07:05:29 <fog> ah right, but how are you multiplying there?
07:05:34 <boxscape> or in haskell terms, (a, Either b c) must be isomorphic to `Either (a, b) (a, c)`
07:05:39 <boxscape> (,) is multiplication
07:05:48 <fog> hmm
07:05:50 <fog> ok
07:06:15 <fog> that defiantly looks like the kind of isomporphism being sought 
07:06:18 <fog> is that the only one?
07:06:33 <boxscape> fog, if you have a type with 2 elements, like Bool, and a type with 3 elements, like data Color = R | G | B, (Bool, Color) will have 6 elements, so that's how it relates to mulitplying
07:06:58 <boxscape> fog, I believe that's the only difference between having a (+) monoid and a (*) monoid versus having a (+), (*) semiring
07:07:14 <boxscape> fog, oh, (*) has to be commutative as well
07:07:36 <boxscape> aaand 0 * a has to be 0
07:08:08 <fog> thats like trying to put a type into a 0 tuple by the looks of it
07:08:52 <boxscape> not quite - the type of zero tuples, (), has on element, (). 0 would correspond to an empty datatype, commonly called Void
07:08:57 <boxscape> defined as `data Void`
07:09:13 <boxscape> s/on/one
07:09:14 <boxscape> so 1 = ()
07:09:42 <fog> right yeah, 0 is the additive identity
07:09:51 <fog> we have 1 * a = a
07:09:54 <boxscape> fog one thing I've been trying to find out but haven't been able to so far is if there's a name for a structure that also has exponentiation, which are functions, like pataka said
07:09:59 <boxscape> right
07:10:46 <fog> functions would just appear as values stored in the datatype though right?
07:11:05 <berndl> boxscape: you want a semiring with exponentiation?
07:11:25 <boxscape> berndl yes
07:11:43 <boxscape> fog mh, I think how they "appear" depends on how you implement these concepts, possibly depending on what you mean by appearance
07:11:53 <fog> the thing im wondering about is how Datatype (a datatype expressed as a datatype...) could be written in terms of Free to capture the Monadicity 
07:12:08 <berndl> boxscape: the closest thing that comes to mind is Heyting algebra.
07:12:21 <fog> like, how all the values stored are either datatypes, or something at the leafs, which cant use Sum or Product structure...
07:12:23 <boxscape> berndl I see, thanks
07:13:34 <fog> but then I guess those are just symbolic labels that can be pattern matched on
07:13:40 <fog> like True and False
07:13:49 <berndl> fog: what do you mean by "capture Monadicity"?
07:14:21 <fog> that the values appearing in the Sum of Product types (a haskell datatype) are themselves datatypes
07:14:57 <fog> this recusiveness is like how a tree is a list of trees, where the recursive self reference sets up a natural Monad
07:15:13 <fog> so Tree is Free []
07:16:10 <berndl> fog: Are you alluding to W-types?
07:16:16 <fog> I would then expect to be able to rewrite Datatype using a factor of Free
07:16:58 <fog> berndl: oh cool, i didnt know there was a name for that
07:17:45 <fog> the obvious question is then what is Datatype the Free of?
07:17:56 <fog> Datatype = Free ??
07:19:02 <fog> hmm, https://ncatlab.org/nlab/show/W-type is pretty full on
07:19:13 <fog> "polynomial endofunctors"!
07:21:23 <boxscape> I might be completely off-base here, but - assuming you have an ADT that encodes ADTs - can't you convert it into a functor you can use with Free if you give it an additional parameter a and replace all recursive occurences of a by that parameter? That's vaguely what I remember from reading about recursion schemes
07:21:40 <fog> oof; Wellfounded Trees and Dependent Polynomial Functors (2004)
07:22:02 <boxscape> so like `Tree e = Node (Tree e) (Tree e) | Leaf` would become `TreeF e a = Node a a | Lead`
07:22:30 <berndl> In denotational semantics, data types are typically modeled as free term algebras where the signature is described by a functor.
07:22:37 <boxscape> s/Lead/Leaf
07:22:52 <boxscape> (that type would make more sense if either Node or Leaf had an `e` as argument)
07:23:07 <fog> right
07:23:50 <fog> berndl: that sounds exactly like the point
07:24:35 <fog> and now i try to write that in haskell!
07:26:11 <fog> i guess Datatype is just Sum of Product of (Datatype or Symbol)
07:26:44 <fog> where the (. or .) becomes the Free thing, with the (branches or leafs)
07:26:57 <boxscape> you might want to include exponentiation and instead of symbol I'd probably use 0 and 1 (or Void and Unit or something along those lines)
07:27:33 <fog> but it needs to be able to pattern match on them
07:27:48 <fog> ok, maybe everything is labled with a symbol anyway as its the datatypes name
07:28:14 <boxscape> I admit I'm not 100% sure what exactly you're trying to do so yeah maybe my suggestion doesn't apply
07:28:53 <fog> or, the name of the Product type appearing as each of the Sum options, so 2 names, one of the datatype, one of each of its constructors... but those are at value level...
07:29:30 <fog> boxscape: no your exactly right, its just trying to understand where these Symbols go for the records and type names
07:29:46 <boxscape> ah
07:30:08 <fog> so i guess its ()
07:30:48 <jophish> Could not deduce: Members r (x : r); >:(
07:31:17 <fog> and then as the names of the records appear only in the DatatypeF thing that is the argument to Free, that the only name then is of the whole datatype appearing at the () leaf 
07:32:13 <fog> oh wait no im confused, trying to use Datatype at the leaf
07:32:17 <fog> its the branch...
07:32:56 <fog> it takes a bunch of type params, i guess these are all consumed by the time the leaf is reached so no type annoations to ()
07:33:57 <fog> so yeah, all the symbols are provided to the values appearing at each position in the DatatypeF
07:34:15 <fog> and thats so confusing...
07:34:43 <fog> I have a Sum type here; https://gist.github.com/fog-hs/3258620036741a4549e99115b5b6c397
07:34:47 <fog> and HList is easy
07:35:12 <fog> ill return when I have tried to combine them into Datatype, and then maybe try the Free DatatypeF thing
07:35:35 <fog> plenty of trees of type parameters, nightmare 
07:41:14 <fog> i guess the place to start would be just making nested HLists and Vars, like HTree and SumTree...
07:41:34 <fog> to get the hang of the structure of the type level parameters
07:42:22 <fog> to then combine them, where i guess since the params to both are just lists, it ends up being a tree, but with 2 layers of branches
07:42:28 <fog> like, Free [[]]
07:43:25 <fog> buy maybe its Cofree since there are Symbolic names at each branch node
07:44:26 <fog> though i guess these could be placed as phantom parameters to a varient of list instead
08:09:23 * hackage turtle 1.5.17 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.17 (GabrielGonzalez)
08:30:53 * hackage shake-bindist 0.1.0.0 - Rules for binary distributions  https://hackage.haskell.org/package/shake-bindist-0.1.0.0 (vmchale)
09:35:53 * hackage minilight 0.4.3 - A SDL2-based graphics library, batteries-included.  https://hackage.haskell.org/package/minilight-0.4.3 (myuon)
09:41:07 <svipal> huh, minilight update
09:52:49 <zebrag> I want to say "monads are monotonic", because the "flow control is monotonic", in that when you encounter an IO-state, you won't be able to "backtrack to it in the future". So, either I'm completely mistaken and what I said makes no sens at all. Either there are much better ways to express it (or at least more academic).
09:53:18 <zebrag> sense*
09:55:19 <Taneb> zebrag: have you seen http://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html ;)
09:56:24 <Taneb> But that's a special case
09:57:29 <zebrag> reading
10:02:53 <zebrag> Not really what I'm looking for... I'm trying to say that when you have an IO-state, you can't come back to it later, you are not allowed to stick an identifier on it... because then you would come back to something different, and that would contradict the basic laws of functional programming
10:05:08 <dmwit> I dunno. What you're saying doesn't make a lot of sense to me. I think you will probably be hurting yourself if you cling to it, but I'm not sure, because it sounds like a pretty vague belief to begin with.
10:07:02 <dmwit> I don't know what "basic laws of functional programming" you're referring to. And I don't see a reason you couldn't have an IO action which doesn't change the "IO state". (e.g. `return ()` is such a thing; arguably something like `x <- readIORef ref; writeIORef ref 0; writeIORef ref x` is another in a single-threaded program.)
10:09:01 <geekosaur> isn't the whole point of IO that it's where we hide the stateful stuff?
10:09:11 <zebrag> I think I'm referring to something like stated in second paragraph of wikipedia Monad_(functional_programming): When then use the word "pipeline" (pipeline must be opposed to backtracking?)
10:09:59 <hyperisco> geekosaur, as opposed to State where we just hide the…
10:10:18 <geekosaur> …fact that we're passing extra data around
10:10:19 <dmwit> zebrag: What predictions hinge on this question? (Why do you care whether the interpretation you're proposing is right?)
10:11:02 <hyperisco> seems stateful to me
10:11:33 <geekosaur> but it's not actually state as indicated by it not playing well with forkIO (each thread ends up with its own copy, instead of shared hidden state as with IORef)
10:11:41 <zebrag> dmwit: because of the other question, How can we embed "web browser event model" into functional programming?
10:11:53 <hyperisco> strange criteria for state but alright
10:12:17 <dmwit> zebrag: Oof. I must be missing some context.
10:12:38 <zebrag> like you are not in my head
10:13:24 <zebrag> I'm used to pure functional programming; and I don't know how to conceptualize those web event stuffs
10:14:01 <zebrag> I feel like I'm back to stone age of programming
10:14:07 <dmwit> carbolymer: No, you cannot generalize to arbitrary functors. Also, you might like the universe package.
10:14:10 <dmwit> ?hackage universe
10:14:10 <lambdabot> http://hackage.haskell.org/package/universe
10:14:21 <zebrag> like using goto's and a turing machine
10:17:28 <hyperisco> zebrag, Event -> IO ()
10:20:16 <hyperisco> I think the only "stone age" aspect is concurrency, for which there insufficient syntax accommodations, and what is accommodated is weak
10:20:55 <hyperisco> which seems unfortunate and counterintuitive given the nature of web applications
11:09:27 <monadsssssss> I want to restrict network calls within ghci to `a.com` but allow them to `b.com`. I think I could instruct ghci to use my own user defined monad and my memory seems to remember reading something about this, but googling "ghci user defined monad" doesn't return any useful results though and I'm not sure what else I'd search.
11:09:39 <monadsssssss> disallow to `a.com`*
11:10:45 <geekosaur> only for output, nothing would prevent IO by user code
11:12:30 <geekosaur> I'm reasonably sure you are thinking of http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function
11:13:31 <geekosaur> which is still in IO, so still not what you want. the real problem is a different monad isn't enough; you'd need reimplementations of the network functions
11:15:19 <monadsssssss> geekosaur: I was afraid of that. I guess I could define my own free monad with a whitelist of actions but that's probably not worth it.
11:15:43 <monadsssssss> That is what I was thinking of I believe, so thanks there too.
11:33:39 <Athas> Sooo... anyone who's tried setting up Azure Pipelines with Windows for building Haskell projects?
11:34:40 <Athas> Oh, I can maybe just steal from this one: https://github.com/haskell/haskell-ide-engine/blob/master/.azure/windows-cabal.yml
11:35:25 <sm[m]> Athas: I started too, but GitHub actions is waaaay easier
11:36:59 <Athas> sm[m]: well, I already have Azure Pipelines running for Linux, so I think I will just continue with this bad decision.
11:38:14 <sm[m]> you go! :)
11:38:18 <Athas> sm[m]: do you have an example of what GitHub actions looks like?
11:39:51 <sm[m]> yup, got off the presses: https://github.com/simonmichael/hledger/blob/master/.github/workflows/windows-nightly.yml
11:40:04 <sm[m]> See also recent Reddit post by fosskers
11:40:36 <sm[m]> hot off the presses
11:46:12 <Athas> sm[m]: that looks benign, but pretty similar to Azure Pipelines.
11:46:18 <Athas> I bet it's not as clunky as Azure's web UI, though.
11:47:02 <Athas> sm[m]: speaking of clunky, did you see my message about Homebrew the other day?
11:48:23 * hackage hsyslog-udp 0.2.5 - Log to syslog over a network via UDP  https://hackage.haskell.org/package/hsyslog-udp-0.2.5 (k_bx)
11:49:35 <sm[m]> I did and responded: thanks! Will keep it in mind! (Haven’t had time yet)
11:50:01 <sm[m]> afk
12:16:18 <maerwald> sm[m]: hey
12:32:33 <dsal> Haha.  I confused myself with loggers.  "Why don't I see logs when I hit my scotty handlers!?"  A: because I'm not logging anything.
12:42:41 <quiet_laika[m]> is there a relatively easy way to calculate the total size (on disk) of a project's dependency tree?
12:44:34 <maerwald> sandboxes?
12:46:52 <geekosaur> sandbox and du, I guess
12:47:30 <maerwald> That's the easy way yeah, not the elegant one :P
12:48:25 <maerwald> Also, is this about *installed* dependencies or the tarball size of all dependencies
12:51:08 <zebrag> hyperisco: [was afk] I concur about the "concurrency" aspect. There are answers about concurrency and monads; I'll try to look in that direction
12:51:22 <geekosaur> suppose with stack or cabal one could use a script which pulled library directories from the package db and built a du command
12:57:23 <geekosaur> also both of those would miss any e.g. C library dependencies
12:57:58 <geekosaur> or external data files not contained within the application's own package
13:03:11 <maerwald> It's getting complicated now :P
13:07:23 * hackage fay 0.24.0.5 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.24.0.5 (swamp_agr)
13:08:43 <sm[m]> quiet_laika: the easy way: clear your ghc/cabal/stack state and install fresh
13:08:55 <sm[m]> and compare df -lH before and after
13:09:21 <sm[m]> I tell people it's "1G"
13:09:35 <sm[m]> since a ghc version is 1G and the rest doesn't matter much
13:10:06 <sm[m]> hello maerwald 
13:11:11 <maerwald> Is there no 'find' in conduit?
13:11:26 <maerwald> I only see filter and https://hackage.haskell.org/package/conduit-1.3.1.2/docs/Data-Conduit-Combinators-Stream.html#v:findS
13:11:27 <maerwald> which is odd
13:12:58 <maerwald> find :: (a -> Bool) -> ConduitT a o m (Maybe a) -- I think
13:14:42 <maerwald> https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:find lol
13:15:01 <maerwald> Sometimes...
13:20:33 <remexre> with nix-style-builds, is there a good way to have several independentish projects that depend on each other?
13:21:01 <remexre> e.g. the bins /code/foo and /code/bar both depend on the lib in /code/baz, but they don't depend on each other
13:22:28 <geekosaur> install it as part of both foo and bar, and it should be shared automatically between them?
13:22:40 <phadej> remexre: yes, just add `packages: /code/baz` to the projects in /code/foo and ../bar
13:23:07 <geekosaur> if it's not then you have something different between foo and bar in how you use baz and sharing wouldn't work anyway
13:23:31 <phadej> I occasinally have `packages: ../someotherlib` when I'm testing out how changes in`someotherlib` affect its revdeps
13:23:58 <phadej> that requires collaborators to checkout repositories in the same format, so relative paths resolve the same, but it's ok when you don't have collaborators
13:24:55 <remexre> ok, thanks
13:25:08 <phadej> TL;DR packages can go out of "project root"
13:25:35 <phadej> ... but then code repositories aren't self contained anymore
13:25:42 <phadej> with all pros and cons of that
13:25:56 <remexre> yeah, there's many projects per repo in the organization we use
13:26:03 <remexre> which, yeah, pros and cons
13:26:41 <phadej> if you have many **packages** (foo.cabal, bar.cabal) in a single repository,  then you should have **single project** (cabal.project)
13:27:02 <phadej> Id' say, you should have only single project in a repository, except when you know what you are doing and have good reason
13:27:39 <phadej> notice the difference between "project" and "package", it helps to ask right questions
13:27:50 <phadej> or to ask questions right
13:29:07 <remexre> oh, huh
13:29:13 <remexre> okay, I'm unfamiliar w/ the distinction
13:29:43 <remexre> I'm mostly using (Rust's) cargo as a mental model for how cabal v2-* works, which is different here
13:29:53 <remexre> I guess I'll peep the docs for cabal.project; thx for the ptr
13:30:44 <phadej> afaik cargo doesn't have notion of a project (something which can contain multiple packages)
13:30:52 <phadej> i.e. works on a single package at the time
13:31:33 <phadej> or maybe it does: https://doc.rust-lang.org/edition-guide/rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html
13:32:20 <remexre> yeah, workspaces are what I'm used to
13:33:06 <phadej> so the workspace=cabal.project
13:33:43 <phadej> package is package
13:33:59 <phadej> and crate (if I understand right) is something we call component (library, executable, test-suite)
13:37:20 <maerwald> phadej: have you done static haskell binaries by any chance?
13:37:39 <phadej> no
13:41:08 <phadej> it's even nicher need than supporting Windows
13:41:36 <phadej> so please understand if one doesn't want to dig into that
13:47:42 <maerwald> hehe
13:47:57 <maerwald> I tried, ended up using some complicated nix stuff, which reproducibly failed
13:48:11 <maerwald> So yes, nix is reproducible
13:48:38 <maerwald> If you find a config that works, it always works. But try to find that config first :>
13:55:02 <justsomeguy> How can I make my GHCi prompt bold?
13:56:21 <tabaqui1> justsomeguy: play with prompt field: ":set prompt "\ESC(dunno, bold? 1;34 or smth)> ""
13:56:29 <tabaqui1> add similar line into your ~/.ghci
13:57:00 <tabaqui1> also check out asci command chars to find out which one is bold
13:57:08 <justsomeguy> Seems to be "\ESC[1;20m"... took some experimentation to find the right code.
13:57:10 <tabaqui1> it should look like \ESC[0;0
13:58:00 <justsomeguy> Thanks for entertaining my silly question :^)
14:03:13 <justsomeguy> Aww yeah, that is so much easier to read. Also now I know to look up ANSI escape codes for this stuff in the future.
14:11:23 * hackage configurator-pg 0.2.0 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.2.0 (vollmert)
14:12:57 <Athas> Can anyone think of why cabal might crash here?
14:12:57 <Athas> https://dev.azure.com/futhark/futhark/_build/results?buildId=1242&view=logs&j=7868e7c0-c859-51b7-c3be-08c48f6833d0&t=8fcad7f0-e003-5c13-6f9f-e40f686f1265&l=15
14:13:06 <Athas> Partial output and all.  Quite mysterious.
14:14:18 <sm[m]> I'd guess running out of memory.. but it seems to have just started ?
14:14:45 <sm[m]> reproducible ?
14:14:46 <Athas> Yes.  And a similar job on an Ubuntu image works fine.
14:14:54 <Athas> It happens every time on Windows, yes.
14:15:02 <sm[m]> maybe -j1 makes a different ?
14:15:06 <sm[m]> difference
14:15:31 <Athas> This is before it even starts building, and these VMs have quite generous memory (I think 8GiB).
14:16:24 <sm[m]> there's also the usual windows path-related issues, for which it's worth trying the latest cabal/stack, if you're not already
14:16:29 <sm[m]> maybe -v then
14:16:56 <sm[m]> I must say debugging these CI issues is quite a pain, unless you've set up some kind of remote shell
14:17:33 <Athas> It is a ridiculous pain.
14:18:17 <Athas> Even basic things end up having so much trivial stuff going wrong, like Chocolatey not adding GHC to my PATH (but adding cabal just fine).
14:18:17 <sm[m]> I have about three days worth of ";ci: github: tweaks" commits :)
14:19:18 <sm[m]> I rely on stack to simplify some of that stuff
14:19:30 <sm[m]> anything to remove variables
14:20:18 <Athas> Sure, but I've grown a bit dismayed with stack.  And until today it just wouldn't work on Windows, since today is the first snapshot with 8.8.3.
14:20:44 <maerwald> tool switching isn't the solution. Both cabal and stack are supposed to work on windows
14:21:01 <maerwald> If they don't, it's a bug!
14:21:28 <sm[m]> you can't boil the ocean. Sometimes you need to get a job done
14:22:04 <sm[m]> but yes I agree! I meant it as a workaround, not the right solution
14:22:31 <sm[m]> though, use the right tool for each job
14:22:51 <Athas> I've also had to fight stack bugs in CI, so I'm not ready to blame cabal for this one just yet.
14:23:02 <sm[m]> Athas: I've been using it on windows continuously for years. Maybe you didn't have the right incantation
14:23:35 <Athas> sm[m]: no, the problem is that the last many GHC versions have had serious bugs on Windows to the point where they couldn't compile some of my dependencies.
14:24:10 <sm[m]> no end of fun :)
14:24:26 <sm[m]> do you test on all platforms ?
14:25:01 <Athas> Only Windows, macOS, and Linux.
14:25:23 <Athas> And the Windows test has basically been ignored for a while, because both the CI (AppVeyor) and GHC itself was so flaky.
14:32:23 * hackage plaid 0.1.0.0 - Plaid.com api integration library  https://hackage.haskell.org/package/plaid-0.1.0.0 (v0d1ch)
14:32:44 <sm[m]> I'm trying to see how quickly I can get basic CI tests to run (because, rapid feedback and more importantly carbon emissions). I've got it down to ~3m on github
14:33:09 <sm[m]> about 1.5m is spent restoring the ~1.5G of cached data
14:33:30 <maerwald> Cached data?
14:33:34 <sm[m]> for real speed, I think a self-hosted runner with persistent state is the answer
14:34:06 <sm[m]> ghc, and all haskell deps
14:34:12 <maerwald> how do you cache haskell deps?
14:34:56 <sm[m]> and any other tools not present on the default machine
14:35:12 <maerwald> I thought stack doesn't have a way to cache deps?
14:35:18 <sm[m]> maerwald: I cache ~/.stack, and also all of my .stack-work's
14:35:24 <ystael> Every time we bump the Stackage LTS version we use, we roll a container image for hosting builds that contains everything from Stackage that our monorepo depends on, already built
14:35:32 <maerwald> ah, you mean you just rsync/whatever it
14:36:03 <maerwald> for cabal there is cabal-cache, which uploads the non-local deps of your project depending on the real build plan of the project
14:36:05 <sm[m]> and ~/.local/bin for good measure. Using the CI's caching system (github's is nice)
14:36:33 <maerwald> That's why I prefer cabal for CI especially
14:37:08 <Athas> OMFG
14:37:20 <Athas> I think the issue is that Azure Pipelines aborts the build with an error if there is _any_ output on stderr.
14:37:23 <Athas> What the everloving fuck.
14:37:31 <maerwald> That's interesting
14:37:55 <maerwald> --verbose=0 ?
14:38:05 <MarcelineVQ> hey, makes sense, otherwise you'd call it stdwrn
14:38:22 <maerwald> lol
14:38:24 <gentauro> MarcelineVQ: how do you pipe to stdwrn?
14:38:35 <gentauro> &>2.1?
14:39:06 <maerwald> Fds are now semver?
14:39:10 <MarcelineVQ> yes, with the ? included
14:39:28 <sm[m]> ystael: how long does it take to install that image during a CI run ?
14:39:43 <maerwald> sm[m]: you should have a look at cabal-cache
14:41:11 <ystael> sm[m]: we use CircleCI, it tries to recycle executor environments that have the image already, if not, it takes 20-30 seconds. It's an improvement over not doing it and also an improvement over the time it would take to use CircleCI's native cache save/restore. We haven't tried cabal-cache as maerwald is suggesting.
14:41:33 <maerwald> cabal-cache works nicely
14:41:41 <maerwald> and it syncs only what is necessary to build the project
14:41:49 <maerwald> In as many threads as you want
14:42:03 <maerwald> So pulling 120deps is quick
14:42:44 <ystael> In the CircleCI environment you need to provide a build container image already if it's not one of their built-in ones, so piling our Stackage dependencies on top of the GHC image we already need to provide costs little.
14:43:07 <sm[m]> how quick ?
14:43:14 <maerwald> real quick
14:44:13 <MarcelineVQ> up to 20 quick
14:44:59 <Athas> My CI job takes a bit over an hour to run, which I do feel bad about.  It uses absolutely no caching.
14:45:19 <ystael> ouch
14:45:23 <Athas> I also feel guilty about taking advantage of the weirdly generous amount of VMs that Microsoft makes available for free.
14:45:40 <maerwald> As long as you don't do bitcoin, that's fine
14:47:06 <Athas> Out of my 53m CI job, it looks like 18m are spent installing Haskell-level dependencies.
14:48:01 <Athas> Er, wait, no I screwed up.  Apparently 'cabal install --only-dependencies' also counts my internal library as a "dependency".
14:48:09 <Athas> But the tiny wrapper executable only takes 9s to compile, so there's that!
14:48:57 <maerwald> did --verbose=0 work?
14:49:28 <Athas> I think I found a non-default configuration option that turns standard error into just an output stream, rather than a self-destruct button.
14:53:08 <styledash> milk microsoft for all the free bitcoin mining you can 👌
14:53:47 <styledash> if there's one company i'd never feel bad about stealing from... its m$oft lol
14:56:22 <maerwald> styledash: hey, SPJ works at MS research :>
14:56:24 <maerwald> be careful
15:01:23 * hackage dobutokO2 0.7.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.7.0.0 (OleksandrZhabenko)
15:03:30 <sm[m]> I'm so happy I no longer have to add \n\n[ci skip] to trivial commits to avoid a CI run
15:03:37 <sm[m]> massive time saver
15:05:29 <styledash> good for him... doesnt make me respect their business practices just cause they have to good sense to hire Simon
15:06:09 <maerwald> styledash: that isn't really unique to MS =)
15:07:17 <styledash> theyre a “leader in the field” =)
15:07:32 <maerwald> right next to fb and google, *shrug*
15:07:55 <maerwald> But their research department is nice, lots of interesting stuff coming from there
15:08:14 <styledash> the sins of others don't excuse one's own sins
15:08:23 * hackage dobutokO2 0.7.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.7.1.0 (OleksandrZhabenko)
15:08:27 <styledash> im not here to defend google or fb
15:10:51 <Uniaika> I pretty much never had to use the [ci skip] in environments where I used CI because GitLab CI doesn't wait for the previous cycle to finish to start the next one
15:11:41 <Uniaika> so it's not like one commit is going to burden the infrastructure
15:12:34 * [exa] remembers the good ol'times when microsoft was the only, single and prime evil
15:13:54 * hackage dobutokO2 0.7.1.1 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.7.1.1 (OleksandrZhabenko)
15:13:54 <Uniaika> MS corporate drone or Linux freedom fighter, the moral compass was way simpler back then
15:15:03 <MarcelineVQ> put simply now, things are only simple in hindsight or foresight
15:20:32 <sm[m]> Uniaika: it was a burden on the planet and on my conscience. It created friction, making me feel I should push less often or avoid trivial fixes
15:20:32 <sm[m]> now if I fix a one letter typo it's "only" 7m worth of a vast distributed information system running flat out.. still not ideal :)
15:23:56 <sm[m]> so back to testing brick/vty apps.. I made a thing to test hledger-ui, using that empty tool: https://termbin.com/8ihc
15:24:56 <sm[m]> the reason for using empty was that it provides a fake pty, so brick apps will run, even from a non-interactive script
15:25:50 <sm[m]> this works, but unfortunately, when I run this script itself in a non-interactive context, I get no output at all. Would anyone have an idea why ? Is it someting about FIFOs ?
15:26:17 <sm[m]> I guess it's not a haskell question
15:38:23 * hackage ghcid 0.8.3 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.8.3 (NeilMitchell)
15:41:56 <sm[m]> hmm.. "The FIFO must be opened on both ends (reading and writing) before data can be passed. Normally, opening the FIFO blocks until the other end is opened also."
15:43:17 <sm[m]> HMM.. "If all file descriptors referring to the write end of a pipe have been closed, then an attempt to read(2) from the pipe will see end-of-file (read(2) will return 0)"
15:50:05 <maerwald> Oh man... did anyone know about the 's' hotkey on hackage?
15:50:10 <maerwald> I just found it by accident...
15:50:34 <maerwald> Can't believe it
15:57:44 <glguy> I've been using it for a while now; it would be nice if it was more advertised
16:00:39 <maerwald> I switched to firefox vim bindings and hit it by accident lol
16:00:47 <maerwald> Wasn't sure if it's the plugin or hackage
16:01:53 * hackage extra 1.7.1 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.7.1 (NeilMitchell)
16:06:14 <dashkal> Huh, TIL
16:16:19 <koz_> Is there something of type (a -> Maybe b) -> [a] -> Maybe b, such that it gives back the first non-Nothing result, or Nothing if they're all Nothing?
16:18:40 <hpc> > Just 5 <> Just 10
16:18:42 <lambdabot>  error:
16:18:42 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M729744264488...
16:18:42 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:18:46 <glguy> <|>
16:19:12 <veverak> hi folks o/
16:19:15 <hpc> something with (<>) or (<|>) over the list, then (=<<) for the function
16:19:54 <hpc> maybe not (=<<), thought it was [Maybe a] for a moment
16:20:22 <koz_> I could probably write this using foldr; just wondering if something built-in existed.
16:20:23 * hackage libarchive 2.2.4.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.2.4.0 (vmchale)
16:20:49 <glguy> > ala Alt foldMap (\x -> if even x then Just (x`div`2) else Nothing) [1,3,5,8,9,10]
16:20:52 <lambdabot>  error:
16:20:52 <lambdabot>      • Couldn't match type ‘[Integer] -> b’ with ‘Maybe Integer’
16:20:52 <lambdabot>        Expected type: (Integer -> Maybe Integer) -> [Integer] -> b
16:20:57 <glguy> > alaf Alt foldMap (\x -> if even x then Just (x`div`2) else Nothing) [1,3,5,8,9,10]
16:21:00 <lambdabot>  Just 4
16:21:37 <glguy> You could build it out of fmap and asum
16:22:04 <veverak> I have an [B] and S data, and function f :: S -> B -> IO (S, B)  I want to apply the function to all items in [B] (like map) while passing the S from one fcall to another (like fold), is there a function for that?
16:23:53 <glguy> :t auf (iso StateT runStateT) traverse
16:23:55 <lambdabot> (Traversable t, Monad m) => (a -> s -> m (b, s)) -> t a -> s -> m (t b, s)
16:24:21 <glguy> This might be called mapAccumLM if it exists somewhere
16:24:27 <veverak> hmm
16:25:27 <hexagoxel> koz_: https://hoogle.haskell.org/?hoogle=(a%20-%3E%20Maybe%20b)%20-%3E%20%5Ba%5D%20-%3E%20Maybe%20b&scope=set%3Astackage
16:25:43 <hexagoxel> the implementation is just to base functions: firstJust f = listToMaybe . mapMaybe f
16:25:52 <koz_> hexagoxel: But of course Neil has something in his package for this...
16:25:54 <koz_> Thanks!
16:33:42 <koz_> glguy: There is a mapAccumLM: https://hackage.haskell.org/package/ghc-8.6.5/docs/MonadUtils.html#v:mapAccumLM
16:33:45 <koz_> veverak: ^
16:36:25 <koz_> :t sequenceA_
16:36:26 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f ()
16:36:27 <olligobber> can a type family in a class have a default?
16:36:46 <koz_> > sequenceA_ [Nothing] >> pure "hi!"
16:36:48 <lambdabot>  Nothing
16:36:51 <koz_> Wooo.
16:37:05 <koz_> > sequenceA_ [Just "hello", Nothing] >> pure "hi!"
16:37:08 <lambdabot>  Nothing
16:37:11 <koz_> :D :D :D
16:40:19 <olligobber> for example, class Labelling x where { type family State x :: *; type State x = [x]; {-# MINIMAL State | ... #-}}
16:48:38 <olligobber> https://gist.github.com/olligobber/4a32a0a840f017efe40caf7a4727f0dd
16:51:53 * hackage lz4-hs 0.1.2.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.2.0 (vmchale)
16:57:41 <maralorn> Is there a tool which can make a package wide unused values check? I have explicit export and import lists, but how can I be sure that everything I am exporting is being imported somewhere else. (Of course assuming that the package is not being used as a library.)
16:58:32 <lyxia> olligobber: I guess you don't have to put it in a MINIMAL pragma. It just works.
16:59:27 <olligobber> lyxia, without that, I get other errors
17:00:33 <olligobber> lyxia, just updated it with the pragma missing
17:41:01 <lyxia> olligobber: your default implementations of methods cannot assume that the default definition of State is [x]
17:41:14 <lyxia> you need to use the "default" keyword for this
17:47:17 <lyxia> olligobber: https://gist.github.com/Lysxia/ecfa71404869f84bc4aed2180ecd2f44
17:48:45 <olligobber> thanks lyxia 
17:56:46 <olligobber> lyxia, if you want to see the final version: https://github.com/olligobber/DirectProof/blob/master/ReLabel.hs
18:02:44 <veverak> how to compare that two lists are equal, without considering ordering?
18:02:54 <veverak> hmm, order them before that
18:08:58 <ski> veverak : do you care about repeats ?
18:12:23 * hackage om-fail 0.1.0.1 - Monad transformer providing MonadFail.  https://hackage.haskell.org/package/om-fail-0.1.0.1 (taphu)
18:14:23 * hackage om-fail 0.1.0.2 - Monad transformer providing MonadFail.  https://hackage.haskell.org/package/om-fail-0.1.0.2 (taphu)
19:48:44 <fog> here is HTree
19:48:45 <fog> https://gist.github.com/fog-hs/4ae0d13122a57d4dd472021b6f6c6b05
19:49:40 <iqubic> What's the difference between HList and FList?
19:50:37 <fog> flist applies a function to the type stored in the list of types param 
19:51:08 <fog> HList does not... it just has that type there, so its isomorphic to FList Identity
19:51:39 <fog> its needed for;
19:51:40 <fog> HBranches :: FList HTree xs -> HTree (Branches xs)
19:52:06 <fog> where the call to branches is building up the Tree of types param to HFree
19:52:09 <fog> HTree*
19:55:07 <fog> I want to rewite this using Free
19:55:34 <fog> I have a previous version which uses some awesome mechanism, but is totally overengineered;
19:55:35 <fog> https://github.com/fog-hs/HFree/blob/master/refactored/HFFree.hs
19:56:03 <fog> where it can have the container used for the branches being hetrogenous vertically!
19:56:32 <fog> but I just want a version that uses HLists at each layer
19:56:47 <fog> wich should give less overhead for the reader
19:57:28 <fog> and then a version for Sum!
19:57:48 <fog> maybe it would be easier to do the Sum Tree in the most basic way (not using Free) to start with
20:05:08 <fog> here is the Sum type; https://gist.github.com/fog-hs/b5a4a92dcd8c4a77b4be7dda62b8ecb0
20:06:09 <fog> its slightly different from HFree, since it has names as Symbols to resolve the choice between values
20:06:28 <fog> i cant imagine how to make a Treelike version of this
20:06:48 <fog> i guess its just a tree with sum types at every level...
20:07:20 <fog> so then, to lookup the value, it would need to descend through the records like nested lenses
20:08:10 <fog> basically then it seems like it still just takes one value as an arg, but with a tree of records (name value pairs)
20:09:03 <fog> so instead of giving it a name, and having it lookup from the params to get the type of the arg it expects as an argument to its constructor
20:09:34 <fog> because it has a tree instead of a list for this param
20:09:57 <fog> it needs a nested lens instead of just a record name for the lookup 
20:10:10 <fog> maybe then just a list of names that it uses in turn to descend through the record
20:10:52 <fog> and some wierd Symbol annotated HList (to support different symbols) for the Tree of params
20:10:57 <fog> thats the difficult part
20:11:32 <fog> well, not so difficult until trying to factor this name-Tree thing into using Free...
20:45:24 * hackage serverless-haskell 0.10.2 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.10.2 (AlexeyKotlyarov)
22:01:53 * hackage hledger-flow 0.13.2.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.13.2.0 (apauley)
22:39:53 * hackage conferer 0.3.0.0 - Configuration management library  https://hackage.haskell.org/package/conferer-0.3.0.0 (ludat)
22:40:54 * hackage conferer-provider-json 0.3.0.0, conferer-provider-yaml 0.3.0.0, conferer-provider-dhall 0.3.0.0, conferer-snap 0.3.0.0, conferer-hspec 0.3.0.0, conferer-warp 0.3.0.0, conferer-hedis 0.3.0.0 (ludat)
22:43:56 <acubakari> hi, I am new to haskell and I was wondering whether the 'variables' are just parameterless functions?
22:44:05 <acubakari> is it the right way to think about them?
22:51:25 <jcarpenter2> acubakari: yes
22:51:42 <jackdk> acubakari: I also think that functions are just another sort of variable
22:56:15 <acubakari> okay jcarpenter2, jackdk thanks
23:02:53 <glguy> variables are the lowercased names of expressions. Functions or not is a different dimension altogether
23:03:51 <glguy> map, Just, (traverse pure)     are all three functions
23:04:29 <glguy> Regarding names: map is a variable, Just is a constructor
23:12:29 <jle`> acubakari: i wouldn't think of variables as parameterless functions
23:12:49 <jle`> i don't think that's a good way to think about them
23:13:29 <jle`> mathematically, 'variables' are the 'things that vary': they are the parameters to a function
23:13:53 <jle`> so, in `myFunction x = x + 1`, x is a parameter, also konwn as a variable
23:14:56 <jle`> that is the best way to think about them, i think
23:15:19 <jle`> although the term variable is a bit overloaded.  'variable' is also a term we talk about when talking to parts of Haskell syntax
23:15:40 <jle`> it's a way to classify haskell syntax tokens, if you are thinking about haskell syntax in a piece-by-piece way
23:15:55 <jle`> but this isn't a very common mode of thinking when normally writing haskell
23:17:07 <jle`> for an example of that second definition, the haskell source "1 + x" can be analyzed/broken down into three components: a literal (1), an operator (+), and a variable (x)
23:17:25 <jle`> it's just a way of classifying tokens. it doesn't have anything to do with the actual denotations of what anything really means
23:18:46 <jle`> probably the most useful way of thinking of variables when writing haskell day-to-day is as synonymous with parameters, the first 'x' in `myFunc x = x + 1`
23:19:41 <jle`> but note that variables can also represent functions.  for example, `doTwice f x = f (f x)`
23:19:49 <jle`> in that case we have two parameters, f, and x.  and f is a function.
23:30:45 <acubakari> jle` : Why though?
23:31:00 <jle`> acubakari: 'why' to which part?
23:31:50 <acubakari> ok I understand your pov
23:33:42 <jle`> right. it doesn't make sense to think of variables as parameterless functions
23:34:54 <acubakari> jle`: as you said functions can be parameters to functions, so variables can be parameterless functions that are parameters to another function
23:35:09 <ski> all functions take a (single) parameter
23:35:41 <acubakari> ski: yeah
23:35:55 <jle`> acubakari: yes, sure, if i'm writing you right
23:35:55 <ski> so, there's no such thing as "parameterless functions"
23:36:13 <jle`> acubakari: but that's different than saying they are "just" parameterless functions
23:36:39 <jle`> and yeah, as ski is saying, technically a parameterless *haskell* function does not exist
23:37:03 <jle`> so it might not be useful to give too much thought to that concept in the first place
23:37:03 <acubakari> Ok a function by definition has to take a single parameter
23:37:11 <ski> (in the definition of `doTwice', `f' is not parameterless. it's called once, with `f x' as a parameter, and called another time, with `x' as a parameter)
23:37:26 <ski> yes
23:37:57 <acubakari> ski: you are talking about currying
23:38:04 <ski> no
23:38:40 <acubakari> currying is the reason we can say a function has only one parameter, right?
23:38:44 <ski> no
23:39:44 <acubakari> doTwice takes a function f as parameter which takes another paramter x instead of doTwice taking two paramters f and x
23:40:45 <ski> `doTwice' is a function taking a parameter that's named `f' in the definition, and returns another function that's taking a parameter that's named `x' in the definition
23:41:17 <acubakari> ski: yeah that's what I meant
23:42:05 <ski> that definition does not include a definition of `f' (since it's a parameter). so it does not talk about what the parameter of `f' would be called, in the definition of the function that will be passed for `f'
23:43:25 <ski> (calling `doTwice' multiple times, with different functions as actual parameters corresponding to the formal parameter `f', would likely use different parameter names in the definition of those functions)
23:43:53 * hackage ghc-tags-plugin 0.1.4.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.4.0 (coot)
23:44:36 <acubakari> ski: yeah
23:44:59 <acubakari> It pattern matches?
23:45:58 <ski> "It" being ?
23:46:18 <acubakari> the compiler?
23:47:11 <ski> presumably it does, when manipulating the Abstract Syntax Trees, yes
23:48:12 <acubakari> ski: okay thanks 
23:48:54 <ski> (not sure how that's related to the previous topic, though)
23:49:33 <acubakari> ski: that's how actual parameters are assigned to formal parameters?
23:49:52 <acubakari> we drifted away from the actual topic
23:52:05 <ski> not sure what "that" refers to
23:52:51 <ski> formal and actual parameters has to do with the syntax and semantics of the language. not really to do with a compiler for the language
23:53:17 <ski> although the latter will of course have to preserve the meaning of the language, when translating it into another language
23:53:41 <ski> (well, preserve the meaning of programs written in the language, rather)
