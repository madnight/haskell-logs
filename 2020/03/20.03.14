00:02:40 <N3RGY> I'm trying to write some algorithms using matrix-static. What is a good technique to write a polymorphically recursive function where there has to be a base case based on the type? Let's say I have "foo :: Matrix n n Bar -> Baz = \matrix -> ... foo (submatrix @2 @2 @n @n) ...". The "submatrix" call only works if "2 <= n", but I'm having trouble writing a separate branch of "foo" for the case where "n = 1"
00:04:09 <N3RGY> I tried doing it by having a typeclass for the function, like "class Foo n where foo :: Matrix n n Bar -> Baz", "instance Foo 1 where ...", "instance (KnownNat n, 2 <= n) => Foo n where ...", but this requires UndecidableInstances and GHC seems to ignore the first instance
00:12:23 * hackage netwire-input-glfw 0.0.11 - GLFW instance of netwire-input  https://hackage.haskell.org/package/netwire-input-glfw-0.0.11 (Mokosha)
00:19:37 <N3RGY> I have a super janky thing working with a type family, but honestly I'm not sure why it works and it looks ugly as. 
00:46:24 * hackage sql-words 0.1.6.4 - SQL keywords data constructors into OverloadedString  https://hackage.haskell.org/package/sql-words-0.1.6.4 (KeiHibino)
00:51:03 <dmj`> aviD: with nix you don't need cabal (the binary)
01:03:04 <lhurttila> Is there an operator in lens that allows viewing a field through a function?  The idea is to view a sorted list in groups, apply a function to it and keep the original list structure
01:05:05 <mjrosenb_> to?
01:06:53 <furnost> Hi guys, I'm using Scotty and postgres to build a small test web app. I'm having troubles storing data in the DB. http://dpaste.com/28ATC7H (line 85). I'm not sure why there is a type error...
01:08:20 <mjrosenb_> what is the type error that you're getting?
01:09:03 <furnost> mjrosen: Actual type is IO() and Expected type is Web.Scotty.Internal.Types.ActionT text-1.2.4.0:Data.Text.Internal.Lazy.Text IO ()
01:09:15 <lhurttila> mjrosenb_ I need to apply an index dependent function to a sorted list but the equal values should have the same index while applying the function 
01:11:32 <mjrosenb_> furnost: I'd guess that you need a lift, since IO () is not not the same as ActionT Text IO ()
01:13:30 <furnost> mjrosenb_: Well, yes. Thank you. I thought I had to do the opposite (if it even exists). Like an unlift. What resource would you recommend about lifting and working with monads inside other monads ?
01:23:50 <ski> @where AAM
01:23:51 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
01:23:56 <ski> furnost : maybe ^
01:24:36 <furnost> oh, wow. intense. Thanks !
01:36:35 <dmj`> @google monad transformers step by step
01:36:36 <lambdabot> http://www.google.com/url?q=https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
01:36:36 <lambdabot> Title: Уведомление о переадресации
01:36:46 <dmj`> furnost: ^
01:36:49 <dmj`> also a winner
01:43:49 <ski> hm, have't seen that before, dmj`
01:45:31 <dmj`> ski: I've never "@where AAM" used before
01:45:34 <dmj`> never seen*
01:45:48 <dmj`> Is that how you get lambdabot to speak english instead of russian?
01:46:03 <ski> have seen it a couple of times (not all of which have been me mentioning it)
01:46:23 <ski> @where MTSS
01:46:24 <lambdabot> I know nothing about mtss.
01:46:32 <ski> @where+ MTSS "Monad Transformers Step by Step" by Martin Grabmüller in 2006-10-16 (draft) at <https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf>
01:46:32 <lambdabot> I will remember.
01:46:36 <ski> there
01:47:39 <dmj`> nice
01:48:14 <dmj`> on this topic, I guess http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html is the seminal work
01:48:32 <dmj`> from Mark P. Jones, of typing Haskell in Haskell fame
01:50:36 <ski> introducing monad transformers, you mean ?
02:00:52 <dmj`> ski: yea
02:00:54 <dmj`> basically
02:05:25 <lhurttila> ski: Do you happen to know if there's a way in the lens package for viewing a sorted list as grouped and apply an index dependent function to it through this view?
02:06:22 <ski> i don't
02:08:59 <lhurttila> k. have to keep looking. In case I don't find anything I guess I could group it first, apply the function and then ungroup it again 
02:23:54 * hackage names-th 0.3.0.1 - Manipulate name strings for TH  https://hackage.haskell.org/package/names-th-0.3.0.1 (KeiHibino)
02:24:53 * hackage yesod-auth-fb 1.10.0 - Authentication backend for Yesod using Facebook.  https://hackage.haskell.org/package/yesod-auth-fb-1.10.0 (psibi)
02:51:05 <slack1256> Hello
02:51:20 <slack1256> I am not seeing a Alternative instance for Either, is that correct?
02:51:51 <slack1256> I could swear that existed
02:56:19 <Cale> slack1256: What should that instance look like? In particular, what should empty be?
03:00:59 * ski . o O ( <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/transformers-0.5.6.2/src/Control-Monad-Trans-Except.html#instance%20Alternative%20(ExceptT%20e%20m)> )
03:10:37 <arpl> Cale: (and everyone of course : ) Can I ask a question about old versions of Haskell implementations?
03:11:39 <Cale> sure
03:11:43 <Cale> how old?
03:11:57 <Cale> Of course, you can always ask questions, and asking to ask isn't terribly useful
03:13:45 <slack1256> Cale: Good call
03:14:05 <slack1256> It does have a Semigroup instance that does what I needed :-)
03:17:14 <arpl> We have talked earlier this week. I am new to Haskell but not exactly new to computing. I am in the process of converting some of my old disk-images to virtual machines. I´m talking DOS (with DesqView), OS/2, BeOS, Win3.11, Win9x etc. I would like to add Haskell to them. Haskell has been around for a long time, so I did expect to find older versions of Haskell implementations for those platforms. Found some info and downloads but not 
03:17:14 <arpl> oo much. Do any of you have any tips how to go about that? (I also have Watcom, so things could be compiled from C.)
03:17:41 <arpl> Sorry about the asking to ask. I did not know what was considered off-topic.
03:17:53 <Cale> The GHC downloads page has a bunch of historical versions on it
03:18:17 <kaol> hugs might be an option.
03:18:57 <arpl> Yes, scrolled all the way down and have downloaded the oldest.       Also found the old Hugs pages. Seems to be the only one that ever ran on DOS.
03:57:07 <tdammers> you could start with GHC 1.0 and build each release from there with the previous one
03:57:19 <tdammers> document the whole process, there's a whole blog series in there
04:11:05 <arpl> tdammers: No smiley (of een klein knipoogje ; ) ... but you are right that may be required. For now I think I will have to put it on my ´Retirement ToDo list´. : )
04:17:36 <__monty__> Aka the Bottomless Bucket List.
04:36:41 <tdammers> my dad retired a couple years ago; he said he'd have so much time to do things, but that lasted about 3 months, and he's been just as busy as before since
04:44:38 <loyon[m]> arpl: might have better luck at trying to build older version of Miranda, but that's just a wild thought... here they are: http://miranda.org.uk/downloads
04:49:47 <arpl> And I was only partly joking. It really isn´t that far off. Seems to be a thing to do. I´ve worked with Steve Gibson (GRC) and he plans to program an OS (in asm of course : ) for his PDP-8s.
04:50:54 <arpl> loyon: Talk about going back in time : ) Miranda was already on the list to look at.
05:06:27 <maxsu> hey all, I'm looking for papers on "garbage collection" for browser tabs. This would be a process that destroys tabs for you when it ascertains that a tab no longer needs to exist
05:06:41 <maxsu> can anyone think of any leads?
05:07:40 <maxsu> so far I'm thinking that we can use time series to predict which tabs will never be revisited through some kind of brute force regression
05:09:10 <maxsu> but I also wonder if we need to detect the user's browsing state within a page (scrolling, mouse tracking, gaze tracking, etc)
05:11:32 <arpl> maxsu: Can´t help you with papers, but there are addons like: <https://addons.mozilla.org/en-US/firefox/addon/auto-tab-discard/>. Maybe there are some clues or pointers there?
05:13:00 <maerwald> It's very simple: Time a tab has not been visited + exceptions for things like pinned, access to sound/video devices, filled forms etc
05:13:13 <maerwald> not sure how you would write a paper about that
05:13:46 <maerwald> user facing things like that should be predictable and simple
05:17:13 <tdammers> it's even simpler
05:17:25 <tdammers> when there are more than 3 non-pinned tabs open, close them all
05:17:37 <tdammers> that's what I do
05:18:47 <maerwald> Yeah, I used to have 100+ tabs open. Now I move windows with lots of tabs to some virtual desktop and if I don't remember what's inside, I just close the entire window
05:20:00 <maxsu> maerwald, what does that heuristic do with a tab that I haven't visited in three days, but which I want to finish reading?
05:20:23 <maerwald> The plugin suspends the tab (low memory usage)
05:20:26 <LysergicDreams> maxsu: auto-bookmark and close
05:20:54 <maerwald> What you want to have closed or bookmarked cannot be reasonably automated. That differs from user to user
05:21:23 <maxsu> LysergicDreams, but what if that three day old tab is a dictionary.com lookup that you did and forgot to destroy? Does your heuristic save that in a bookmark?
05:21:41 <maerwald> So a GC doesn't make much sense here, there's no specifically expected behavior
05:22:10 <maxsu> yeah, the GC analogy fails, because GCs all have deterministic rules to trigger finalization
05:22:36 <maerwald> Suspending is non-intrusive and allows the user to bookmark/close. That is easy and has been done already.
05:22:40 <LysergicDreams> maxsu: I dunno, I just use tab groups :P
05:22:43 <maxsu> maerwald, I propose that the system could learn to read cues specific to that user
05:22:52 <maerwald> I wouldn't use such a system
05:23:00 <maxsu> I'm not asking if you would
05:23:04 <maxsu> I would!
05:23:08 <maerwald> Either I want it to do something predictable and simple or I would want to configure the exact behavior
05:23:39 <maxsu> I'm asking if you know algorithms that can do it
05:24:12 <maxsu> maerwald, the algorithm would need to behave predictably enough for you to know when it's gonna collect a tab
05:24:47 <maxsu> and I think that in some latent representation space it actually has to model the structure of the task you are apparently trying to accomplish in a given tab, and in the browser at a given time
05:24:52 <maerwald> If it's an algorithm, it's already unlikely that it's predictable for the average user.
05:25:53 <maxsu> yeah, it needs an extra property, where you trust it to recognize and properly infer the different categories of tasks you do
05:25:59 <maerwald> Algorithms should be hidden from users. Not be exposed in their interaction. Ppl don't know why they get the google/yt results they are getting and they don't need to. But when I search through my emails, I want to know what I'm getting.
05:27:25 <maxsu> for instance, basic time series analysis would very quickly determine that Dictionary.com tabs should be much shorter lived than, say, a research PDF you're reading and marking up
05:28:19 <maxsu> maerwald, when you search for you email, you actually know what algorithm is being used - you can assume that it's a keyword search through the fulltext of your emails, or close enough to pass muster. 
05:29:17 <maxsu> perhaps it's important to distinguish being able to know which precise algorithm you are faced with (won't happen), and knowing the general behavioral contracts of the /kind/ of algorithm you're using
05:29:35 <maerwald> The average user doesn't know the algorithm. But the behavior is predictable enough and needs to be predictable.
05:30:03 <maxsu> but hey, youre entire point this conversation has been that it's either trivial or impossible to do this task, whereas I wanted papers actualy accomplishing some analogous variant
05:30:19 <maerwald> What does it have to do with haskell btw?
05:30:52 <maxsu> I wanna implement it in haskell, and I generally hold you guys to be able to discuss algorithms!
05:31:13 <maerwald> Should use python 
05:31:16 <maxsu> and it's 5:30 am on a weekend and the channel was dead
05:31:33 <maerwald> Python is easier with developing algorithms
05:31:46 <maerwald> At least for the prototype
05:31:53 <maxsu> huh, I can see that
05:32:10 <maerwald> And all the machine learning ecosystem
05:32:13 <maxsu> if the algorithm is not naturally functional
05:33:10 <maerwald> I dunno, I've never seen a paper about that, but I've also never searched for it. The need for such plugins stems from excessive resource usage of firefox etc, imo, not ppl wanting smart behavior of their browsers
05:34:16 <maxsu> well there are tons of this kind of human intention tracking task, and lately AIs are getting better than humans at it. But yeah I am also adrift in the literature, without any particular way to narrow the search
05:35:25 <maxsu> ah well, I'll stop tying up the channel  - if anyone wants to chat about it I'll be in over in #blah
05:37:22 <[exa]> maxsu: instead of 21412412341234 tabs it would be great to make bookmarks great again
05:37:49 <[exa]> b/c most people I know just use tabs as bookmarks for "this might get handy soon, read ASAP"
05:43:13 <maerwald> [exa]: imagine google would by default first search your bookmarks
05:45:45 <maerwald> the problem is having two ways of searching for something
05:46:07 <maerwald> ppl pick the quickest
05:47:11 <maxsu> [exa], they're bookmarks, but they require fewer human-interaction-tasks (HITs - basically mouse clicks, key presses, swipes, etc.)
05:48:29 <maerwald> ppl memorize how they found something, not what they found
05:49:19 <maerwald> so it's more likely you remember your google search phrase than the website that had the information you were looking for
05:52:15 <maxsu> [exa] I'm worse. I constantly forget tabs and end up with a roughly-monotinic increase in the number of tabs and windows over a period of days, untill I have to run Quicktab's  "/merge" to shove  them all into one window, and then I cull 80% of the tabs in 
05:52:23 <maxsu> in one go*
05:53:54 * shapr hops cheerfully
05:53:57 <shapr> Good morning #haskell !
05:54:07 <maxsu> hhapr
05:55:27 <maerwald> you plenked !
05:55:40 <maxsu> I think part of the issue is that I have some OCD, so hooray, whatever system I design has to /help/, rather than worsen the symptoms
05:56:26 <maxsu> by the way, doing a literature search for algorithmic OCD helpers finds that OCD researchers think it would be a very bad idea to try this
05:56:50 <shapr> I had the urge to do epidemic simulations this weekend, is there a recommended/suggested grid/matrix library?
05:57:29 <maxsu> I would poke around here: https://github.com/topics/covid-19
05:57:40 <shapr> thanks!
05:57:44 <maxsu> though there are no haskell results
05:58:06 <maerwald> maxsu: Lol, there's research about Ketamine treatment for OCD in germany/switzerland currently.
05:58:19 <maerwald> I don't think a firefox plugin will help, but
05:58:40 <maxsu> I think python would be a good choice for this, shapr
05:58:50 <maxsu> looking for notebooks that already have it set up
05:58:50 <zincy_> Is there a nice way of doing this: lift $ when (isJust maybeVal) (runMonadicAction (fromJust maybeVal))
05:59:16 <maerwald> zincy_: forM
05:59:27 <maxsu> shapr, THIS looks like a good read: https://towardsdatascience.com/simulating-epidemics-using-go-and-python-101557991b20?gi=18c7cbc64667
05:59:30 <zincy_> maerwald: Thanks!
05:59:34 <maxsu> thanks for bring the topic
05:59:38 <maxsu> bringing*
06:02:04 <maerwald> maxsu: but I can assure you that caffeine worsens the symptoms. Try haskell programming without coffee :D
06:02:10 <maerwald> https://medium.com/@info_49088/the-ocd-series-why-i-quit-caffeine-8359ff7ba79c
06:06:40 <shapr> maxsu: I'm more likely to use Haskell, because that's my fun language. I'm not getting paid to build a beer flu simulation :-)
06:09:06 <tdammers> you can grab my coffee from my cold dead yet still slightly shaky hands
06:09:30 <maerwald> tdammers: it's not that hard to quit even
06:09:41 <maerwald> And sleep is better.
06:10:13 <tdammers> I don't have a coffee problem
06:10:15 <tdammers> I like coffee
06:10:46 <maerwald> Me too, that's why I drink decaf :P
06:11:03 <tdammers> I like the effect that caffeine has on me
06:11:21 <tdammers> and frankly, I don't see any reason to "quit"
06:14:08 <shapr> Any suggested library for doing cellular automata stuff? The SIR model seems close to that.
06:21:23 * hackage dobutokO2 0.10.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.10.0.0 (OleksandrZhabenko)
06:23:23 <LysergicDreams> Coffee heads: try taking some l-theanine 30 minutes before your coffee(~2mg per mg caffeine)
06:23:51 <LysergicDreams> At first it gave me crazy laser-beam focus, now it's more like taking the jittery edge off
06:23:53 <__monty__> Suspicious nick to be suggesting chemical experiments...
06:24:33 <shapr> l-theanine really does help, but last I hung out on #haskell this kind of conversation got pushed to #haskell-blah or other off-topic channels
06:45:26 <furnost> Hey, I'm still on my small webapp thing. I now have custom types that I'd like to store in my DB. I saw that I can convert normal types with toSql. Is it possible for me to implement Convertible and then call toSql on my own types ?
07:06:24 <rsoeldner> I want to run a shell script inside my test-suite, how can I specify that this script is located in the proj. root ?
07:10:23 <nh2> mpickering: your NUR seems to contain up to ghc881, but not ghc882. Do you plan to add it?
07:20:24 * hackage fb 2.1.1 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-2.1.1 (psibi)
07:38:48 <furnost> is there a way to make a type that contains exactly 64 Char ?
07:40:00 <bbaren> furnost: A type where the only valid values are integers between 0 and 63? Or a type that is a string of length 64?
07:40:24 <furnost> A type that is a String of length 64
07:41:22 <geekosaur> not really
07:41:35 <bbaren> The easiest way is probably to newtype String and use smart constructors to enforce the invariant.
07:41:55 <furnost> ok, thanks
07:43:08 <maxsu> maerwald, thanks for that article. I HAVE had trouble with coffee... at first a cup a day helps with my depression, then I have to drink 3 cups for it to help, them I have to drink 5 cups but it just gives me headaches and makes me disorganized, and then come autumn it just stops working altogether
07:43:52 <maxsu> Ooo, what is metaphysical contamination OCD. Sounds like I would have to believe in souls and spirits for that to bother me?
07:46:41 <maxsu> oh wow, it's an actual sensation that things have negative energies because they have been "contaminated" by some association with traumatic past events. .
07:47:48 <maxsu> Sounds like synesthesia, but instead of colors, you pick up bad vibes
07:53:02 <furnost> is there a way to generate 64 Chars randomly ? I don't really understand how the random package works...
08:00:18 <bbaren> furnost: `randomIO` is probably the simplest way.
08:00:34 <bbaren> It generates a random value of whatever type you want.
08:00:58 <bbaren> So you can use it to generate a random Char.
08:01:05 <bbaren> And then, if you call it 64 times, you’ll get 64 random Chars.
08:01:28 <geekosaur> :t replicate
08:01:30 <lambdabot> Int -> a -> [a]
08:02:31 <geekosaur> although for randomIO you want
08:02:35 <geekosaur> :t replicateM
08:02:36 <lambdabot> Applicative m => Int -> m a -> m [a]
08:04:59 <furnost> so that would be something like replicateM 64 $ randomIO ?
08:05:16 <Cale> yeah
08:05:53 * hackage persistable-record 0.6.0.5 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.6.0.5 (KeiHibino)
08:07:35 <furnost> awesome, thanks !
08:13:23 * hackage relational-query 0.12.2.3 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.12.2.3 (KeiHibino)
08:20:51 <Ariakenom> :t for
08:20:52 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
08:40:31 <rsoeldner> Hi, when running `cabal gen-bounds` I receive `error: getting status of '/home/rsoeldner/sila2-ast/dist/nix/shell.drv': No such file or directory` - is this expected ?
08:47:16 <_deepfire> kosmikus, I'm trying to find a mechanism that would constrain arbitrary tails of a type-level list of NP, with say Typeable.  Constraining the list elements is easy with All, but the same for TLL tails seem far harder -- whatever I attempt I face stuck type families.
08:48:11 <_deepfire> kosmikus, I'm starting to think that to constrain tails one needs a variant of NP that is additionally parametrised with a constraint.
08:49:12 <_deepfire> Maybe I'm not asking myself the right questions..
08:51:46 <_deepfire> (Also, to clarify, when I mean tails, I literally mean the "Cstr xs => NP I (x : xs)"..)
08:57:24 <_deepfire> ..I guess I should add that the (k -> Constraint) must be polymorphic, because the real end goal is to have the constraint apply to the entirety of the TLL
08:57:47 <_deepfire> (Well, in my case it's Typeable, so it's poly-kinded already)
09:01:17 <_deepfire> ..and indeed, I just cooked up a Typeable-constrained variant of NP, and it's all a breeze.
09:01:34 <_deepfire> I guess I'm just reluctant to lose all the machinery that's available for NP : -/
09:03:53 * hackage yesod-fb 0.6.1 - Useful glue functions between the fb library and Yesod.  https://hackage.haskell.org/package/yesod-fb-0.6.1 (psibi)
09:14:54 <_deepfire> The gist illustrating the problem: https://gist.github.com/deepfire-pusher/ca9d89975274bfc55d479ff9568871ec
09:32:57 <kosmikus> _deepfire: I don't get the problem at all. What you want is exactly what "All Typeable" does.
09:34:48 <kosmikus> _deepfire: of course, there's also the question why you want things to be Typeable in the first place ... that's always a bit dubious in itself.
10:22:23 * hackage yesod-auth-fb 1.10.1 - Authentication backend for Yesod using Facebook.  https://hackage.haskell.org/package/yesod-auth-fb-1.10.1 (psibi)
10:25:22 <zincy_> In what senses is distributive dual to traversable?
10:46:22 <Zemyla> zincy_: It's sort of dual to it because it can be moved to the outside of any Functor. But there's a much closer dual, which doesn't yet exist in Haskell.
10:47:28 <Zemyla> class Traversable t => Codistributive t where { codistribute :: Functor f => t (f a) -> f (t a); cocollect :: Functor f => (a -> f b) -> t a -> f (t b) }
10:48:48 <Zemyla> It's like Traversable, but works over any Functor.
10:49:20 <Zemyla> Every Codistribute is equivalent to (,) e for some e.
10:49:49 <Zemyla> Note also the resemblance to lenses.
10:50:39 <_deepfire> kosmikus: 'All' constrains the elements of the list, while I need all the tails (the spine) to be constrained as well.
10:53:17 <_deepfire> status quo: instance (c x, All c xs) => All c (x ': xs)
10:53:44 <_deepfire> desired: instance (c x, c xs, c (x ': xs), All c xs) => All c (x ': xs)
10:55:15 <_deepfire> In my case Typeable is due to a semi-dynamic typing involved in what essentially is an RPC mechanism.
11:50:54 * hackage dobutokO2 0.10.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.10.1.0 (OleksandrZhabenko)
11:51:26 <kosmikus> _deepfire: but the elements are the only part that's unknown. the spine is trivially typeable. does the following help: https://gist.github.com/kosmikus/4a88c99cd6c16b537d388e6e958a24a0
12:11:47 <zincy_> Zemyla: Interesting, thanks
12:21:46 * _deepfire tries to wrap his head around cpara_SList
12:39:40 <_deepfire> kosmikus: it does work for my purposes, indeed, but I have to work out how the dictionary is derived.  I completely agree the spine is trivial, given the elements -- conceptually, and so it was frustrating not being able to bridge this in the implementation..
12:39:56 <_deepfire> kosmikus: thank you!
12:44:47 <kosmikus> _deepfire: you're welcome
12:45:46 <_deepfire> So cpara_SList looks like basic induction, building dictionaries covering successively larger TLL's.
12:46:05 <kosmikus> yes, cpara_SList is just induction over a type-level list
12:47:00 <kosmikus> you could write the same thing by explicit recursion over a singleton, i.e. sList.
12:47:14 <Zemyla> Oh, you know how the Functor and Foldable instances for Array don't need an Ix constraint, but the Traversable instance does?
12:48:06 <Zemyla> I figured out a way to avoid that. https://gist.github.com/Zemyla/9272265a3bdb53171b41ecb08342cc1e
12:48:24 <_deepfire> I guess what is counter-intuitive is that in case you have "(c xs, All c xs, xs ~ (x:xs')) => NP I xs", you must resort to indution to re-derive the proof for "c xs'"
12:48:45 <_deepfire> sorry, induction
12:51:56 <_deepfire> On the other hand, when c is arbitrary, that makes some sense -- whatever holds for a particular TLL, doesn't necessarily hold for its prefix.
12:53:04 <_deepfire> I guess the mistake was believing that Typeable is a magic case, where this general logic doesn't apply..
12:54:09 <kosmikus> yes, indeed, for Typeable it makes sense to apply to both lists and their elements
12:54:13 <kosmikus> for normal constraints it doesn't
12:55:12 <_deepfire> thank you, it seriously helps to know I'm not totally unreasonable : -)
12:55:33 <kosmikus> NPs don't have special machinery to propagate constraints on the lists themselves, but fortunately, the info available is sufficient to recover everything that is needed
13:55:23 * hackage archive-libarchive 0.2.2.2 - Common interface using libarchive  https://hackage.haskell.org/package/archive-libarchive-0.2.2.2 (vmchale)
14:07:56 <isovector1> anyone have a good impl of TH's reifyInstances on hand?
14:08:07 <isovector1> looking to not need to chase the instance graph myself
14:14:21 <isovector1> aha: https://hackage.haskell.org/package/th-instance-reification-0.1.4/docs/THInstanceReification.html
14:23:18 <ysangkok> is there a library for cryptographic accumulators in haskell?
14:42:53 * hackage checkers 0.5.5 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.5 (ConalElliott)
14:49:53 * hackage HExcel 0.1.0.1 - Create Excel files with Haskell  https://hackage.haskell.org/package/HExcel-0.1.0.1 (v0d1ch)
14:52:24 * hackage lzlib 1.0.5.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.5.0 (vmchale)
16:12:15 <ysangkok> does anybody know some examples of monadic reflection that was improved using the technique detailed in "reflection without remorse"?
16:15:54 <loyon[m]> ysangkok: I did not study this in details but they seems to use this effectively https://github.com/ekmett/guanxi
16:42:04 <zeta_0> i have cabal installed, but the command: cabal sandbox init , is not working?
16:42:40 <sclv> new cabal has moved away from sandboxes
16:42:48 <sclv> you can still do v1-sandbox, or you can learn the new-build stuff
16:43:40 <zeta_0> sclv: oh, i usually use nix but for the project i am working on now i decided to use a sandbox to avoid dependency hell
16:44:30 <zeta_0> sclv: what is the new-build command to initialize a sandbox?
16:46:31 <sclv> new build doesn't have sandboxes
16:46:38 <sclv> it sort of auto-shared-sandboxes everything automatically
16:46:48 <sclv> so you just `cabal build`
16:47:23 <zeta_0> sclv: oh, sandboxes are generated automatically, that's great
16:47:47 <sclv> so with cabal 3.0 (with new build) then the project workflow is super clean
16:47:59 <sclv> but `cabal install` is weird now, since there's really auto-sandboxing
16:48:13 <sclv> so that's the workflow you need to learn some new approaches for (i.e. simulating global shared packages)
16:48:22 <sclv> if you don't care about global shared packages, then you're golden
16:52:26 <zeta_0> sclv: ok, thanks for the information, i still prefer nix/guix, but i knowing cabal is also very useful
17:00:41 <zeta_0> so cabal copy is gone too?
17:12:15 * int-e wonders how many people are still using the v1 commands exclusively.
17:15:45 <jackdk> int-e: not exclusively, but one uni I help at has student homedirs on nfs with limited quota, so they have a bunch of `v1-install`ed packages in the lab image to prevent v2 commands from rebuilding the same deptree for every student 
17:21:23 <monochrom> Yeah I have found that my students had trouble with "cabal update" because disk quota.
17:23:47 <monochrom> Annoyingly our disk quota was enough if one doesn't have much anything else, so you get this probabilistic phenomenon that some students have trouble, some others don't, and you scratch your head why.  It also <sarcasm>tremendously helps</sarcasm> that cabal doesn't simply honour and pass on the unix no-space-left error.
17:25:16 <monochrom> I'm considering that next time I I pre-download the necessary packages---HUnit and its deps---and just tell students to run Setup.hs
17:25:40 <monochrom> (and point students to my school directory for the package files)
17:26:21 <monochrom> <sarcasm>cabal-install is certainly designed with professionals in mind</sarcasm>
17:26:55 <monochrom> because only professionals have 1000PB disk space and 100TB RAM and 50 cores.
17:28:44 <monochrom> When v1-install is outlawed, only outlaws will use v1-install via Setup.hs
17:29:09 <int-e> that'll be really inconvenient.
17:29:36 <monochrom> Plus the fact that v2 stuff puts docs in purposefully unpredictable directory names.
17:30:02 <int-e> I've already figured out that one can have a cabal.project.local file that specifies a store-dir, so it can work almost like a sandbox, except more cumbersome. Or maybe just different.
17:30:56 <int-e> The thing is, I like sandboxes. They're local, it's clear what breaks if I delete them. There's no cleanup story for the v2 store that I know of, except nuking the world and rebuilding it from scratch
17:32:56 <monochrom> Also who in their right mind thought that v2-install for exes should cause and solve the XY problem of putting exes inside the unpredictable directory names, and then symlinking to your stable bin directory?!
17:33:09 <ysangkok> int-e: but they are inherited from nix, and nix can do garbage collection.
17:33:15 <monochrom> Like, why not just put in your stable bin directory in the first place?
17:34:23 <monochrom> cabal-install 3 finally offers that choice, yes, but why did the inferior way exist in the first place? Like why even write the extra code for it?  v1 already knows how to copy files.
17:34:24 <int-e> ysangkok: so who specifies what the roots are for the GC?
17:35:16 <int-e> I guess it comes down to v2-* fixing something that wasn't broken... if you used a sandbox-oriented workflow.
17:35:32 <ysangkok> int-e: in nix, there is one expression that defines your whole system. so there is a root. with cabal, i guess you can't really know, but it would be possible theoretically to specify the root manually by giving the project directories?
17:36:52 <monochrom> You know what, the irony is that the symlink trick could have been applied to docs instead and would have won my support.
17:37:56 <monochrom> Typical millenial entitled mentality of "docs are on the cloud, what is local doc?"
17:38:22 <int-e> But oh well. I'll reevaluate these things when the v1 commands are removed.
17:42:02 <monochrom> Once upon a time, Haskell Platform was a tarball that contained multiple package tarballs, and a shell script to, in a correct order, unpack and Setup.hs
17:42:23 <monochrom> I am ready to go back to that reliable method again.
17:42:33 <sarahzrf> tarb all
17:43:38 <ysangkok> monochrom: how is haskell platform different today?
17:44:08 <monochrom> It uses shake for the build.
17:45:08 <monochrom> And it offers a binary-only tarball if/because you find it an overkill to first get shake going.
17:49:09 <int-e> <obpun>on shaky ground</obpun>
17:49:20 <monochrom> heh
17:49:56 <ysangkok> shake is used to build the haskell platform itself?
17:50:02 <monochrom> Yes.
17:50:03 <ysangkok> it says on the website that it ships with cabal and stack
17:50:21 <monochrom> For users who just use the binary-only tarball yes.
17:50:30 <ysangkok> aah ok gotcha
17:51:41 <monochrom> Download the source tarball instead and poke around it and try to get it to build for fun. or self-torture.
17:52:23 <ysangkok> i tried to build nhc once :O that felt like torture 
17:52:42 <monochrom> I ceased using the binary-only tarball because intra-doc hyperlinks are hardcoded to the prefix /usr/local.  I want a different prefix.
17:52:43 <ysangkok> i set up even set up red hat 9 in a vm 
17:53:49 <ysangkok> monochrom: do you think you would be able to bootstrap ghc from sources only without a vm?
17:54:18 <int-e> ysangkok: You'll need a binary anyway, unless you're insane.
17:54:24 <monochrom> So I just take their list of package versions, kick out a few I never needed like the X window and/or OpenGL stuff, add a few I like such as aeson, then cabal v1-install the lot of them.
17:54:35 <int-e> ysangkok: Because to build ghc, you need ghc.
17:54:50 <monochrom> I don't know, I have never bootstrapped GHC.
17:54:52 <ysangkok> no, there is an old version that (according to myth) builds with nhc
17:55:09 <int-e> ysangkok: but that's insane. :P
17:55:34 <ysangkok> i know. but seeing red hat 9 was like reliving my childhood. traumatic and healing at once
17:56:54 <int-e> the way I set up ghc has been the same for a while... install the distro ghc and cabal-install packages; use them to build ghc and cabal-install from source. optionally uninstall the distro packages.
17:57:35 <ysangkok> and sleep uneasily because you don't know which step compromised your system :O
17:58:06 <int-e> ysangkok: That's easy, it happened the moment I bought a modern processor.
17:58:15 <monochrom> I sleep easily because I know that only one step compromised my system.  That is, an Intel CPU.
17:58:26 <ysangkok> hah :P yeah. gotta get myself one of those Raptor PowerPC machines for 2000 usd :O
17:58:45 <monochrom> Then again, the CPU is the system, perhaps philosophically it doesn't count as compromised :)
17:59:09 <ysangkok> hahaa :D
18:03:05 <int-e> I'm not sure how I would go about building a system I absolutely had to trust. It would probably be air-gapped, run a minimal amount of software (no clue what that would be, but it would probably not include a haskell compiler).
18:05:36 <ysangkok> the term "absolute trust" is meaningless to me. it is a philosophical question of course. there was a project featuring Andrew Huang a few years ago: https://spectrum.ieee.org/consumer-electronics/portable-devices/novena-a-laptop-with-no-secrets
18:06:10 <sm[m]> I guess space engineers and embedded folks generally know how to do it
18:06:49 <ysangkok> i'd argue that space needs reliability, which is just one kind of trust
18:09:02 <sm[m]> int-e assuming by system you mean a computing system, I guess generally computation should be minimised
18:09:58 <ysangkok> how do you quantify computation in an analog computer? :O
18:10:43 <sm[m]> it sounds like less computation, which’d be good
18:12:49 <int-e> yahb: To my mind, absolute trust is required when the compromise of the system poses an existential threat (e.g., death).
18:13:05 <ysangkok> % Type error
18:13:05 <yahb> ysangkok: ; <interactive>:21:1: error: Data constructor not in scope: Type :: ([Char] -> a0) -> t
18:13:10 <ysangkok> :P
18:13:40 <int-e> ysangkok: ^^ ... I have no clue why I named yahb.
18:13:53 <ysangkok> because we share a prefix, so we must be identical
18:13:54 <int-e> (another tab completion mishap)
18:14:22 <int-e> I must've skipped the 's'.
18:14:25 <ysangkok> life is ill-defined, so that makes your definition of "absolute trust" also ill-defined :P
18:14:40 <sm[m]> Perhaps redundancy is the most important factor
18:15:32 <int-e> Sure, this is philosophical territory.
18:16:23 <int-e> (I won't dwell on it further... it was fairly off topic to begin with.)
18:17:02 <sm[m]> I may be interrupting a longer discussion; your question just got me thinking
18:46:03 <mjrosenb> so, I'm about to replace weakGuard :: Maybe Bool -> Maybe a -> Maybe a; weakGuard p a with p >>= guard >> a
18:46:18 <mjrosenb> what are the chances that I'll remember what this does in a month :-p
18:47:23 <mjrosenb> hrm, although I may have done something bad because weakGuard isn't actually implemented the way I thought it was
18:47:29 <mjrosenb> whoops.
18:48:02 <mjrosenb> yeah, no, those expressions aren't the same.
18:48:37 <monochrom> I would write p >>= guard explicitly rather than create a new function name that I have to first think up a really good name (1 hour) and then have to learn it and re-learn it (5 hours).
18:48:52 <mjrosenb> weakGuard (Just False) = Nothing; weakGuard _ x = x, which is not the same as the monadic expression that I have there.
18:49:42 <mjrosenb> monochrom: have an expr for the actual definition of weakGuard?
18:49:44 <monochrom> It is an unguessable name.
18:49:52 <mjrosenb> also, weakGuard is used exactly once
18:50:00 <mjrosenb> which is why I'm trying to replace it.
18:50:05 <monochrom> You will have to invent a longer better name, or you will have to write doc.
18:51:57 <monochrom> s/better/more precise/
18:52:14 <mjrosenb> this started with me trying to write a doc, then trying to write a type, then wondering if there was already a function that does this, then coming up with p >>= guard, *then* realizing that I hadn't read the definition carefully enough.
18:52:27 <int-e> what is this... (p <|> pure True) >>= guard >> a
18:52:59 <int-e> looks weird.
18:53:46 <mjrosenb> yeah, that looks equivalent, and it does in fact look weird.
18:53:58 <int-e> but it's a weird operation
18:54:21 <mjrosenb> not all that weird.
18:54:33 <mjrosenb> the name 'weakGuard' actually makes some amount of sense
18:54:54 <mjrosenb> it is like guard, but if you don't know that the predicate is false, then don't the the guard-thing
18:55:32 <mjrosenb> so, it is actually really specialized to Maybe Bool, and generalizing the type doesn't make a huuuge amount of sense
18:55:35 <monochrom> Then perhaps it is a strong guard, not a weak guard.
18:55:55 <hololeap> % weakGuard p a = (p <|> pure True) >>= guard >> a
18:55:55 <yahb> hololeap: 
18:56:22 <int-e> I'm not sure how much I like to encode a ternary choice (NO | UNKNOWN | YES) as Maybe Bool.
18:56:27 <hololeap> % weakGuard (Just False) (Just "hi")
18:56:27 <yahb> hololeap: Nothing
18:56:36 <hololeap> % weakGuard (Nothing) (Just "hi")
18:56:36 <yahb> hololeap: Just "hi"
18:57:01 <hololeap> % weakGuard [False] ["hi"]
18:57:02 <yahb> hololeap: ["hi"]
18:57:03 <int-e> But with that idea in mind, why not just  guard (p == Just True) >> a
18:57:35 <int-e> The p really isn't all that monadic.
18:57:48 <int-e> Uhm
18:57:52 <int-e> I mean /= Just False, of course.
18:59:22 <int-e> Whereas the  == Just True  version is, I guess, the strong guard in this nomenclature, which somewhat accidentally can be encoded as p >>= guard.
19:01:20 <hololeap> % weakGuard [True] ["hi"]
19:01:21 <yahb> hololeap: ["hi","hi"]
19:01:45 <hololeap> it doesn't seem to work the way you would want with [], so maybe generalizing to MonadPlus isn't the best idea
19:02:42 <int-e> I may be wrong (I'm influenced by a project I worked on that dealt with such ternary results internally), but it felt like the p really only makes sense with the Maybe type.
19:03:23 <int-e> For example, in the list Monad, if you get [True,False], that would seem rather inconsistent.
19:04:20 <int-e> But maybe your context is different. I don't know.
19:09:09 <remexre> is there a (sound) lensProduct-like for Getters? or would the right approach be to just define my own locally (since it's not particularly complex)
19:10:11 <mjrosenb> int-e: the fact that it is Just True / Just False / Nothing kind of fell out of the fact that I was using traversals and ^?
19:15:40 <mjrosenb> int-e: (continuing through scrollback...) right, this is also why the original function orignially operated on Maybe Bool, and then I made a mistake attempting to generalize both of the Maybes, when in fact only the non-boolean one can be generalized
19:35:17 <dmwit> mjrosenb: traverse_ guard p >> a -- ?
19:35:17 <remexre> if I want to embed a name in a decl w/ TH, is there a better way than $([| name |])?
19:35:39 <remexre> hm, though that doesn't seem to work either
19:36:59 <remexre> than $(pure $ VarE name), I suppose
19:37:55 <dsal> Is there a way to see what's using a library?  I think I want to use http://hackage.haskell.org/package/isobmff but I don't even know where to start.
19:58:39 <glguy> dsal: I don't think anything uses that on hackage.
19:59:20 <dsal> Hmm...  I just saw some downloads, so I figured something used it.
20:02:04 <Clint> dsal: you mean like https://packdeps.haskellers.com/reverse ?
20:04:02 <dsal> Clint: Yeah.  Doesn't show up there.  This is a bit frustrating.  Library seems to do what I want thoroughly, but presents as a giant pile of separate modules.
20:05:25 <davean> .. theres no reason they had to put that description in the README instead of the description
20:05:50 <davean> dsal: The modules seem to be well factored conceptual pieces?
20:06:45 <dsal> Sure, except it's supposed to be parsing mp4 files.  So at some point, I'd expect there to be a place where I can feed it mp4 and start getting useful junk out.
20:12:40 <davean> dsal: it seems to build them quite easily
20:14:51 <remexre> oof, is hoogle down?
20:14:55 <dsal> davean: What do you mean?  I'm just trying to pull out some tags.
20:15:29 <davean> dsal: I mean youv'e got http://hackage.haskell.org/package/isobmff-0.14.0.0/docs/Data-ByteString-IsoBaseFileFormat-MediaFile.html and such
20:15:43 <davean> It all seems to be there?
20:17:33 <dsal> That link doesn't have anything but a type class.  It looks like if there were a thing that had an instance of that, it'd spit out bytes.  That' seems like the opposite of what I want.  It's not an implementation and it doesn't read bytes.
20:19:02 <evelyn> stack's detection of existing installs is somewhat dubious
20:19:33 <evelyn> I have a completely different program called stack in ~/.local/bin but it thinks this is stack stack :/
20:21:29 <evelyn> the install tells one how to forcibly install it though.
21:26:52 <hololeap> i have a couple instances where i need to store both data and a function on that data. i've been using Control.Comonad.Store. any advice on whether or not this is a bad idea?
21:28:42 <iqubic> When was base updated to 4.13.0.0?
21:28:51 <koz__> iqubic: With 8.8 I think?
21:29:01 <koz__> hololeap: What do you mean when you say 'store'?
21:29:06 <koz__> As in 'keep around in some sense'?
21:29:52 <iqubic> What important, and/or new features does 8.8.x introduce?
21:31:52 <hololeap> right, i had a data type that looked like `data T m = (A, (A -> m B))`, and i thought, why not use `newtype T m = Store A (m B)` and get extract and pos for free?
21:32:35 <iqubic> That looks good. The two are isomorphic.
21:33:07 <jsomedon> is there any tools that allow me include image into comment section for code? better if it's language agnostic
21:35:06 <iqubic> So, the release notes for 8.8.1 state that "The final phase of the MonadFail proposal has been implemented." What exactly does this mean?
21:35:58 <iqubic> Wait... scrolling down yeilds this: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/8.8.1-notes.html#base-library
21:42:36 <koz_> Basically now, if you have pattern matches that could fail to the left of an <-, you gotta have a MonadFail constraint.
21:42:39 <koz_> (not just plain Monad)
22:27:21 <mjrosenb> are there any monads in base which don't implement MonadFail?
22:28:50 <koz_> mjrosenb: Identity, State, Reader, Writer.
22:31:41 <iqubic> Is Functor a superclass of Foldable?
22:32:34 <iqubic> IE, if I have a random Foldable t, can I fmap over the contents? Or will that require a Functor t constraint to?
22:35:47 <MarcelineVQ> No, becaue Foldable operations don't have to preserve strucuture. If every Foldable was also a Functor then it would have to.
22:36:27 <MarcelineVQ> Traversable does describe something that is a Foldable and a Functor though
22:36:56 <iqubic> MarcelineVQ: Thanks.
22:37:10 <iqubic> freqs :: (Foldable t, Ord a) => t a -> M.Map a Int
22:37:14 <iqubic> freqs = foldr (\val m -> M.insertWith (+) val 1 m) M.empty
22:37:40 <iqubic> That creates a frequency list, telling me how many times each element appears in a given foldable.
22:37:54 <iqubic> It's quite helpful.
22:38:39 <MarcelineVQ> also called a histogram afaik
22:38:52 <iqubic> Sure. I'd buy that.
22:39:16 <MarcelineVQ> I guess histrogram is what you call it when it's displayed
22:47:07 <jle`> iqubic: see Data.Set.Set as an example of a Foldable that is not Functor
22:47:24 <iqubic> jle`: That is a great example.
22:47:42 <iqubic> Primarily because that's the data structure I'm working with here.
22:48:26 <iqubic> Basically I was trying to take my Set, and convert it into a frequency map. My code for doing that is the freqs function I put just above.
22:48:54 <iqubic> I'm doing Advent of Code puzzles from previous years and finding that sort of function super helpful.
22:50:28 <iqubic> specifically I'm working on this puzzle: https://adventofcode.com/2016/day/6
22:52:42 <iqubic> I did have to update my session token, but other than that, jle` library has continued to work properly and allow me download my input from the AoC servers without issue.
22:52:48 <iqubic> Thank you jle`
22:54:27 <jle`> nice :)
23:08:27 <iqubic> I love using using Down, I can use the same function twice, and get opposite results.
23:09:57 <iqubic> Like I wrote a function to find the most common element in a foldable. I then used that same function to find the least common elemnt by first wrapping the values in Down, before comparing.
23:27:02 * hackage text-replace 0.0.0.6 - Simple text replacements from a list of search/replace pairs  https://hackage.haskell.org/package/text-replace-0.0.0.6 (chris_martin)
23:37:02 * hackage grab 0.0.0.4 - Applicative non-linear consumption  https://hackage.haskell.org/package/grab-0.0.0.4 (chris_martin)
23:38:01 * hackage grab-form 0.0.0.4 - Applicative parsers for form parameter lists  https://hackage.haskell.org/package/grab-form-0.0.0.4 (chris_martin)
