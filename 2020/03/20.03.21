00:25:02 * hackage aeson-value-parser 0.18.1 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.18.1 (NikitaVolkov)
00:35:02 * hackage net-spider 0.4.2.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.2.0 (debugito)
00:36:17 <jusss> hello?
00:36:29 <jusss> how to capture IOError?
00:54:02 * hackage character-cases 0.1.0.1 - Exposes subspecies types of Char. And naming cases.  https://hackage.haskell.org/package/character-cases-0.1.0.1 (aiya000)
01:24:32 * hackage aeson-value-parser 0.19 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.19 (NikitaVolkov)
02:01:01 <lsund> Good morning guys, what setup do you use for haskell development in VIM?
02:04:24 <srk> o/ plain vim pretty much
02:05:09 <srk> only plugin is rainbow_parentheses
02:06:45 <maerwald> lsund: codex
02:06:55 <maerwald> and 'ag'
02:06:59 <maerwald> everything else is broken
02:08:18 <srk> that looks handy
02:25:30 <maerwald> how do you test the bitness? WORD_SIZE_IN_BITS is undefined here
02:27:53 <int-e> maerwald: Didn't test, does it work with #include <Rts.h> ?
02:30:08 <maerwald> That file doesn't exist
02:31:05 <int-e> maerwald: Or maybe, looking at GHC.Num, #include "MachDeps.h" ... though there's a risk that this only works inside base.
02:31:19 <int-e> Sigh. I don't know.
03:40:32 * hackage hedn 0.3.0.1 - EDN parsing and encoding  https://hackage.haskell.org/package/hedn-0.3.0.1 (AlexanderBondarenko)
03:53:43 <Tuplanolla> I only use Vim without plugins, except for `fzf`, lsund.
03:56:01 <Rembane> lsund: I use Brittany and ALE, and then I have a stack build --file-watch in a window so I always see type errors and so on 
03:56:02 * hackage llvm-ffi 9.1.0.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-9.1.0.1 (HenningThielemann)
04:32:13 <ph88> when going from one state to another how can i model the transitions based on some conditions to go to the next state ?
04:37:53 <ph88> there seem to be various solutions i'm not sure what to choose https://bobkonf.de/2018/sketchnotes/wickstroem.jpeg 
05:14:06 <zincy_> Given a list of `a`s how can I check for the presence of two adjacent elements?
05:15:32 <zincy_> Something like ((a,a) -> Bool) -> [a] -> Bool
05:17:53 <ph88> zincy_, you can save the previous element in the accumelator with a fold
05:17:53 <opqdonut> > let xs = [1,2,3,3,4] in zip xs (tail xs)
05:17:55 <lambdabot>  [(1,2),(2,3),(3,3),(3,4)]
05:18:10 <opqdonut> > let xs = [1,2,3,3,4] in any (uncurry (==)) $ zip xs (tail xs)
05:18:12 <lambdabot>  True
05:18:44 <opqdonut> you can skip the tuples too, with something like
05:18:56 <maerwald> yeah, zipWith is your friend
05:18:59 <opqdonut> > let xs = [1,2,3,3,4] in any identity $ zipWith (==) xs (tail xs)
05:19:01 <lambdabot>  error:
05:19:01 <lambdabot>      • Variable not in scope: identity :: Bool -> Bool
05:19:01 <lambdabot>      • Perhaps you meant one of these:
05:19:07 <opqdonut> > let xs = [1,2,3,3,4] in any id $ zipWith (==) xs (tail xs)
05:19:09 <lambdabot>  True
05:19:11 <opqdonut> heh
05:19:27 <ph88> let me have a try at his function :))
05:27:41 <Uniaika> Can anyone confirm that Linuwial is the current haddock theme? the one we're seeing on https://downloads.haskell.org/~ghc/8.10.1-rc1/docs/html/libraries/base-4.14.0.0/Data-Foldable.html ?
05:27:58 <ph88> zincy_, 
05:28:07 <ph88> > let f cmp lst = fst $ foldr (\a (b, c) -> if b == True then (True, Just a) else (case c of; Nothing -> (False, Just a); Just c' -> (cmp a c', Just a))) (False, Nothing) lst in f (\a b -> a == 3 && b == 4) [1..4]
05:28:09 <lambdabot>  True
05:28:46 <ph88> f :: (a -> a -> Bool) -> [a] -> Bool    ok ?
05:48:42 <maerwald> tar is weird. Some archives seem to have hardlinks that point to their own filename
05:52:02 * hackage haskell-lsp-types 0.21.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.21.0.0 (AlanZimmerman)
05:53:02 * hackage haskell-lsp 0.21.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.21.0.0 (AlanZimmerman)
05:53:51 <maerwald> https://bsd.to/oUDb/raw
06:32:01 <frdg> isIsogram :: String -> Bool
06:32:02 <frdg> isIsogram x = length x == length $ fromList x
06:32:10 <frdg> im confused on why this does not work
06:32:42 <hpc> operator precedence
06:32:46 <hpc> what you have is
06:32:56 <hpc> isIsogram x = (length x == length) $ (fromList x)
06:33:13 <frdg> oh ok
06:59:32 * hackage tar-bytestring 0.6.3.1 - Reading, writing and manipulating ".tar" archive files.  https://hackage.haskell.org/package/tar-bytestring-0.6.3.1 (maerwald)
07:11:54 <jusss> https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Exit.html
07:12:01 <jusss> Note: in GHC, exitWith should be called from the main program thread in order to exit the process. When called from another thread, exitWith will throw an ExitException as normal, but the exception will not cause the process itself to exit.
07:12:17 <jusss> how to exit whole process within a thread?
07:12:28 <jusss> whole program
07:13:55 <Tuplanolla> What's wrong with calling `exitWith` from the main thread? You can also send an exception to the main thread, catch it and then call `exitWith`.
07:14:52 <jusss> the question is I set a timer in a thread to catch socket exception, if there's an exception raised, I'd like to exit whole process
07:15:06 <jusss> there's another function work in the main
07:15:38 <jusss> there's a loop function in main
07:15:49 <jusss> after those threads
07:29:09 <jusss> Tuplanolla: how to catch an exception which throw in thread in main thread?
07:59:32 * hackage utility-ht 0.0.15 - Various small helper functions for Lists, Maybes, Tuples, Functions  https://hackage.haskell.org/package/utility-ht-0.0.15 (HenningThielemann)
08:02:21 <jusss> I can't find a good example for that...
08:02:32 <jusss> there's too few people use haskell
08:02:48 <jusss> no global variable, how to communicate with threads?
08:03:18 <jusss> throw an exception in thread, and catch it in main thread, there's no a document tell me how to do it!!!
08:03:57 <jusss> I don't why haskell is so poor on Exception, Thread and Socket
08:04:05 <jusss> and also documents
08:05:32 <dmj`> jusss: have you seen Real World Haskell?
08:05:44 <dmj`> jusss: http://book.realworldhaskell.org/read/error-handling.html
08:05:53 <maerwald> Exception handling is poor yes
08:06:04 <maerwald> But does any language significantly better?
08:06:08 <dmj`> jusss: you can use IORef as global variable
08:06:11 <maerwald> In Java you get those monster traces
08:06:13 <dmj`> jusss: or other concurrency primitives
08:06:16 <jusss> dmj`: I did
08:06:30 <dmj`> jusss: ok first of all, what are you trying to do
08:06:53 <jusss> dmj`: exit whole program in a thread
08:07:01 <jusss> then exitWith can't do that
08:07:15 <MarcelineVQ> there's an entire book on threads and exceptions   https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
08:07:19 <dmj`> jusss: right only the main thread of execution can halt the entire program
08:07:20 <MarcelineVQ> *free book
08:07:29 <dmj`> jusss: once main thread dies, it takes all threads with it
08:08:31 <dmj`> jusss: you want to use the async package, it uses STM to transfer exceptions from spawned threads back to parent threads.
08:08:32 * hackage storable-record 0.0.5 - Elegant definition of Storable instances for records  https://hackage.haskell.org/package/storable-record-0.0.5 (HenningThielemann)
08:08:58 <dmj`> jusss: why fork a thread for this though? why not just run it in the main thread of execution
08:09:16 <jusss> dmj`: because some functions is not async
08:09:25 <jusss> are
08:10:02 * hackage hasql-th 0.4.0.6 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.4.0.6 (NikitaVolkov)
08:10:05 <dmj`> jusss: ok, well you can monitor the forked thread with the main thread and exit if it dies.
08:10:22 <jusss> dmj`: keyword?
08:11:01 <jusss> I need the names
08:11:22 <dmj`> jusss: names of who
08:11:46 <jusss> dmj`: names of those function, monitor thread in main
08:13:02 * hackage fixed-length 0.2.2 - Lists with statically known length based on non-empty package.  https://hackage.haskell.org/package/fixed-length-0.2.2 (HenningThielemann)
08:13:05 <dmj`> jusss: https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:poll
08:13:31 <dmj`> jusss: poll will sample an async action and tell you if its still running, exited successfully, or exited with an error
08:14:28 <jusss> dmj`: how to throw an exception in thread and catch it in main thread?
08:14:41 <jusss> or how to communicate with threads?
08:14:55 <dmj`> jusss: you can just call error and it will found by the poll function
08:15:08 <dmj`> call error in the child thread, and poll in the main thread
08:15:11 <jusss> Control.Concurrent doesn't provide that functions?
08:16:57 <dmj`> jusss: no, async wraps control.concurrent to provide this functionality.
08:19:03 <dmj`> jusss: an Async holds the result of the computation
08:28:02 * hackage shell-utility 0.1 - Utility functions for writing command-line programs  https://hackage.haskell.org/package/shell-utility-0.1 (HenningThielemann)
08:29:24 <mjrosenb> with a traversal, is there a way to mutate some items, and return only the mutated items?
08:29:42 <mjrosenb> or in my case, return only the indices of the mutated items
08:30:34 <mjrosenb> also, when I say traversal, I mean traversal with lens.
08:31:43 <phadej> yes. Make traversal indexed, filter it, and then you reduce your problem to "change items pointed by (indexed)traversal, and return (old or new) ones"
08:31:51 <phadej> for which there is an operator in `lens`
08:33:05 <phadej> important skill for using `lens` is finding the combinators and operators in the docs
08:33:31 <phadej> (I don't remember those, so I'd also need to look into the docs, won't do it for you)
08:36:02 * hackage cabal-flatpak 0.1.0.1 - Generate a FlatPak manifest from a Cabal package description  https://hackage.haskell.org/package/cabal-flatpak-0.1.0.1 (HenningThielemann)
08:45:54 <kritzefitz> When I declare an instance like `instance $(conT someName) SomeType` ghc 8.6.5 accepts the declaration but ghc 8.8.2 complains that is is an “Illegal class instance: ‘$(conT ''C) Char’”. Is that a bug?
08:49:46 <merijn> kritzefitz: "Maybe"
08:50:07 <merijn> kritzefitz: It could also be that it was a bug that it accepted the class initially
08:50:28 <jmcarthur> Reflex seems to be a popular FRP implementation these days, but I can't find any documentation of its semantics. Am I just looking in the wrong places?
08:51:30 <kritzefitz> merijn, even when -XFlexibleInstances is active?
08:53:00 <merijn> kritzefitz: I have no idea what the rest of the code looks like. What happens if you use -ddump-splices to print the generated code?
08:55:17 <kritzefitz> merijn, as for the code: https://gitlab.com/snippets/1955565
08:56:14 <kritzefitz> -ddump_splices says `test.hs:8:12-19: Splicing type conT ''C ======> C` for both versions.
09:21:47 <aveltras> is there a way to see the full callstack when errors happen with hspec ? currently it only shows me the exception but not where it has been thrown
09:23:25 <phadej> most likely no
09:23:53 <phadej> don't expect callstacks in Haskell :)
09:25:05 <{abby}> you might be able to get one by compiling with -prof
09:25:44 <doyougnu> isn't that what GHC.Stack was for?
09:28:42 <aveltras> i see, guess i'll have to find the problem the hard way :)
09:37:02 * hackage llvm-tf 9.2 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-9.2 (HenningThielemann)
09:42:30 <sm[m]> Call stacks should be fairly common with currrent GHCs ? My tasty tests give one I thought
09:42:51 <tommd> aveltras: You can get good callstacks when you compile with `-fprof-auto -fprof-cafs -with-rtsopts=-xc -prof`
09:45:39 <aveltras> tommd: much better indeed ! thanks a lot
10:00:02 * hackage lsp-test 0.10.2.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.10.2.0 (luke_)
10:19:25 <mjrosenb> Is there a version of iToListOf / ^@.. that operates in ST?
10:19:35 <maerwald> wonder if there is a shortcur for a view pattern that evaluates to Bool
10:21:23 <mjrosenb> maerwald: from what I know, only if you make it into a guard
10:42:31 * hackage rebase 1.6.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.6.1 (NikitaVolkov)
10:46:32 * hackage rerebase 1.6.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.6.1 (NikitaVolkov)
10:56:02 * hackage hasql 1.4.2 - An efficient PostgreSQL driver with a flexible mapping API  https://hackage.haskell.org/package/hasql-1.4.2 (NikitaVolkov)
11:08:02 <Guest_84> hi
11:08:46 <Guest_84> I am not abel to install haskell
11:08:47 <Guest_84> "curl --silent https://gitlab.haskell.org/haskell/ghcup/raw/master/ghcup" failed!
11:08:54 <Guest_84> terminal says
11:09:29 <maerwald> Guest_84: https://www.haskell.org/ghcup/
11:09:57 <Guest_84> I followed the same
11:11:31 <maerwald> Hm, hang on.
11:13:50 <maerwald> Guest_84: https://github.com/haskell/ghcup get the script from there
11:14:06 <maerwald> https://raw.githubusercontent.com/haskell/ghcup/master/ghcup
11:18:31 <maerwald> and then temporarily do this: export GHCUP_META_DOWNLOAD_URL=https://raw.githubusercontent.com/haskell/ghcup/master/.download-urls GHCUP_META_VERSION_URL=https://raw.githubusercontent.com/haskell/ghcup/master/.available-versions
11:18:40 <maerwald> gitlab.haskell.org seems down
11:19:04 <tommd> It's being upgraded.
11:19:07 <tommd> It will be back soon.
11:19:12 <maerwald> Bad enough
11:19:23 <maerwald> I'll have to switch to github again for availability.
11:23:12 <zeta_0> i installed curl, but this cabal build error is still being thrown? https://gist.github.com/zeta-00/4d214e62d54f67cc428c752f7e9c7859
11:23:27 <zeta_0> how do i fix the error?
11:23:44 <maerwald> zeta_0: what distro
11:24:00 <dsal> curl makes me sad.
11:25:06 <zeta_0> maerwald: i'm using the nixos distro with the nix pkg manager
11:25:30 <maerwald> Better ask in #nixos how to do that then
11:25:40 <zeta_0> dsal: it's making me sad too
11:25:53 <maerwald> curl is great.
11:26:21 <zeta_0> maerwald: how is this related to nixos?
11:27:15 <maerwald> zeta_0: It seems you don't know how to create an FHS environment where you can build your stuff against global packages. That's nix stuff, not haskell related
11:27:17 <maerwald> Nix is hard
11:27:18 <dsal> The last time I tried to use libcurl I wanted to process headers and they just like, didn't have a way to do that.  That seems like a pretty basic thing.
11:27:38 <dsal> zeta_0: Are you using curl on purpose?
11:28:04 <zeta_0> maerwald: but i'm not using nix for this particular purspose, only cabal
11:28:12 <maerwald> Yes, you are on NixOS
11:28:22 <dsal> I'm using wreq for my gopro thing.  It's pretty good except for the part where I needed to stream video to disk.
11:28:25 <tommd> cabal needs the curl library which on most distributions is available globally.
11:28:26 <maerwald> Did you read the NixOS manual?
11:28:26 <zeta_0> dsal: i am trying to build darcs to contribute to it
11:28:46 <tommd> darcs likely depends on curl too
11:29:01 <jusss> >/quit
11:29:04 <dsal> C libraries are outside of the scope of cabal.  To some degree, you're expected to provide some things.
11:29:20 <maerwald> zeta_0: do you know how nix works?
11:29:52 <zeta_0> maerwald: ya, i think cabal is missing some dependencies that darcs needs, dammit'
11:29:57 <maerwald> zeta_0: https://nixos.org/nix/manual/
11:30:45 <zeta_0> maerwald: yes, i have been using nix for while, i didn't know i'd run into problems building without it
11:30:50 <maerwald> https://github.com/Gabriel439/haskell-nix
11:30:53 <maerwald> Read those
11:31:05 <maerwald> Don't know what workflow you are using, so
11:31:13 <maerwald> And nix support is better in #nixos
11:31:33 <zeta_0> maerwald: i have, but thanks for the information, i have my own nix-shell workflow, but it's going to require some extra steps
11:32:05 <jumper149> Hi, I'm looking for a webserver where can I use a stateful monad-transformer stack as the handler. servant only allows Monads that are run for each request (for example Reader) like here: https://docs.servant.dev/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers
11:32:26 <dsal> jumper149: I'm using Scotty with a reader.
11:32:59 <jumper149> dsal: I'll look into it!
11:34:34 <dsal> jumper149: It's a little weird.  I had to unwrap and rewrap, but I got it going: https://www.irccloud.com/pastebin/yoNp5k2R/scotty
11:37:20 <zeta_0> dsal maerwald : i'm in #darcs now, i'm trying to get all the dependencies that i need before i enter into a nix-shell
11:37:43 <zeta_0> #darcs channel looks dead though
11:40:25 <dsal> darcs is pretty good... I still use it on occasion, but git kind of won.
11:41:03 <exit70> hi, i have been reading "programming in haskell" lately. could someone give me a hint on exercise 5.7?
11:41:24 <dsal> exit70: What's the problem?
11:42:20 <exit70> rewrite [(x,y) | x <- [1,2], y <- [3,4]] using 1 generator and 2 comprehensions
11:44:56 <jumper149> exit70: What typeclass could come in handy here?
11:45:09 <exit70> the best i got is concat [[(x, 3), (x,4)] | x <- [1,2]] as the book hinted on using concat
11:46:24 <exit70> no idea for now :/
11:46:53 <jumper149> Ok, just to be sure what is meant with generator and comprehension?
11:47:36 <jumper149> ah I got it
11:49:34 <doyougnu> zeta_0: if you're doing this on nixos then you should be creating a nix-shell development environment, not using curl. The nix store is read only and so the curl script likely will run into permission issues
11:50:08 <doyougnu> zeta_0: I would recommend trying to create a shell.nix file with the dependencies you need
11:50:30 <doyougnu> then just calling nix-shell shell.nix to enter the environment, the nixos channel can help you out
11:52:02 * hackage llvm-extra 0.10 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.10 (HenningThielemann)
11:55:31 <tommd> exit70: I'd think the book means one generator per comprehension so [ [(x,y) | y <- [3,4]] | x <- [1,2] ]
11:56:18 <exit70> ha
11:56:18 <oats> that feels like a confusing exercise
11:56:25 <aveltras> does anyone have an example of using a nix-shell based environment to run benchmarks of haskell packages ? the benchmark dependencies aren't provided by nix when i enter the shell
11:57:22 <exit70> now i read it again, it says "single generators"
12:00:37 <zeta_0> doyougnu: ok, that's exactly what i'm doing now, i ask in #darcs what are the other dependencies that i'm going to need for the nix-shell to be able to build darcs
12:01:00 <zeta_0> no ones responded yes so i'm just waiting
12:01:23 <jumper149> tommd: That's also the best I could come up with using list comprehension. Not sure about use of concat though ^^
12:02:03 <zeta_0> typo: yet not yes
12:03:28 <exit70> concat [[(x,y) | y <- [3,4]] | x <- [1,2]] would be the answer, i guess the point is understanding how multiple generators work
12:03:57 <Poscat[m]> Hi all. Are there any tools that can plot the dependnecy relationships between dataypes inside a Haskell module? Ideally it should place highly coupled datatypes closer.
12:03:57 <Poscat[m]> I have a large file that has a lot of datatype defined in it which takes ages to compile so I'm considering refactoring it into numerous smaller files. Such plotting tool can simplify the refactoring quite a bit.
12:04:39 <jumper149> exit70: Oh yeah I should've run it once to see the nested lists ^^
12:06:39 <doyougnu> Poscat[m]: you mean like this: https://docs.haskellstack.org/en/stable/dependency_visualization/
12:06:48 <doyougnu> ?
12:08:34 <Poscat[m]> Ah Yes. But for datatypes.
12:10:15 <jumper149> dsal: I don't think Scotty will work for what I have in mind. It's the same as with servant. The monad stack is run for every request ("called at each action").
12:10:49 <doyougnu> aveltras: I do this for my PhD work: https://github.com/doyougnu/VSat/blob/master/haskell/default.nix
12:10:59 <doyougnu> forgot where I got it from though
12:12:06 <doyougnu> Poscat[m]: ah sorry I didn't read carefully enough, I'm not aware of any such tool :/
12:12:45 <aveltras> doyougnu: ye, i didn't want to use intermediary derivations first, i have gone the benchmark -> exe route for now, thanks for the input anyway
12:20:29 <Franciman> Hi, is trifecta still mantained?
12:22:46 <dsal> jumper149: it didn't seem perfect.  In my case, I just need a reader.
12:26:32 * hackage llvm-dsl 0.0 - Support for writing an EDSL with LLVM-JIT as target  https://hackage.haskell.org/package/llvm-dsl-0.0 (HenningThielemann)
12:40:49 <sm[m]> Poscat: I’d just run ghcid and start pulling things out
12:59:31 * hackage knead 0.5 - Repa-like array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.5 (HenningThielemann)
13:04:58 <isovector1> is there a good way to use quickcheck's Fun type to generate (and show) arbitrary functions that are fields of a record?
13:06:36 <koz_> isovector1: This isn't sufficient? https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:Fn
13:07:14 <koz_> Or am I misunderstanding the question?
13:07:47 <isovector1> koz: how do you embed it? let's say i want to generate an arbitrary `data Foo = Foo { bar :: Int -> Bool, baz :: String }`
13:08:32 <koz_> Foo <$> applyFun arbitrary <*> arbitrary or so?
13:08:50 <koz_> Provided Int and Bool are Coarbitrary, which I assume they are?
13:09:15 <koz_> Sorry, only Int is required to be Coarbitrary according to the instance.
13:09:17 <isovector1> koz: as soon as you've done that you lose the Show
13:09:26 <isovector1> which is the only reason to use Fun in the first place
13:10:07 <koz_> You can write the property with forAllShow and provide a function that does rewrapping I guess?
13:10:35 <isovector1> it sounds like you're saying "no, there is no good way"
13:10:42 <koz_> I guess so, yeah.
13:11:06 <isovector1> `instance (Show a, Show b, Function a) => Show (a -> b) where show = show . function` feels like it should work, but it's a bottom
13:18:06 <maerwald> sm[m]: have you ever tried building static haskell exes on your mac?
13:20:14 <pie_[bnc]> anyone want to help with working on a binding generator for Qt
13:20:39 <pie_[bnc]> a lot of the basics seem to be laid down
13:20:45 <maerwald> pie_[bnc]: uhff... not a small project :o
13:20:59 <maerwald> Did you open a reddit thread about it? Might be worth a shot too
13:21:15 <pie_[bnc]> im too lazy(ish) to register for reddit xP
13:21:35 <maerwald> Well, now I'm forcing your thunk.
13:22:01 <pie_[bnc]> currently pyside (python c++ binding) has some infra for dumping type information (of varying usefulness), and Qtah already handles most(?) of the haskell-to-c++ binding side afaict
13:22:10 <pie_[bnc]> i wrote a POC in python that generates haskell code
13:22:15 <pie_[bnc]> it kind of even works
13:42:32 * hackage patch-image 0.3.3.1 - Compose a big image from overlapping parts  https://hackage.haskell.org/package/patch-image-0.3.3.1 (HenningThielemann)
13:52:58 <nyuszika7h> :
13:56:34 * dmj` didn't know UHC had a whole program analysis option
14:27:32 * hackage sak 0.1.0.0 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.0.0 (vmchale)
14:33:32 * hackage set-cover 0.1.1 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.1.1 (HenningThielemann)
14:34:32 * hackage sak 0.1.0.1 - Compression command-line tool  https://hackage.haskell.org/package/sak-0.1.0.1 (vmchale)
15:03:24 <sm[m]> I'm not sure maerwald.. this would be to make a binary that runs on any macos version ? I wouldn't bother now after nh2 's remark, and considering the usual difficulties with catalina etc.
15:04:05 <sm[m]> you could experiment on github's mac runner, though
15:04:56 <sm[m]> I don't mind running a command or two for you, but it seems a lost cause
15:19:15 <stretchp> today I decided to get back into coding so I thought I give haskell a try. Working thru Learn you a haskell for great good. since this virus outbreak has me off work currently :|
15:20:13 <maerwald> stretchp: ditch lyah
15:20:27 <maerwald> https://www.cis.upenn.edu/~cis194/spring13/lectures.html is better
15:22:29 <sm[m]> @where htac !
15:22:29 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
15:27:32 * hackage wide-word 0.1.1.1 - Data types for large but fixed width signed and unsigned integers  https://hackage.haskell.org/package/wide-word-0.1.1.1 (ErikDeCastroLopo)
15:31:15 <stretchp> maerwald:thanks
15:39:06 <koz_> Is stackage.org dead?
15:39:33 <maerwald> works here
15:39:36 <koz_> Weird.
15:40:11 <maerwald> Too many ppl at home trying to learn haskell, maybe ;)
15:40:41 <koz_> I'm trying to use HIE, and I get this error: [LC] [Error] haskell-lsp:no handler for. Object (fromList [("...("method",String "textDocument/codeLens"),("id",Number 3.0)])
15:40:45 <koz_> What am I missing?
15:41:35 <koz_> Wait, I think I know, lol.
15:41:38 <maerwald> koz_: https://github.com/autozimu/LanguageClient-neovim/issues/622
15:41:39 <koz_> HELPS NOT TO SKIP STEPS LOL
15:42:01 <koz_> Ah, OK.
15:42:06 <maerwald> Not all clients have it
15:42:12 <koz_> So... can I get useful output from HIE still?
15:42:23 <Uniaika> from LC, I doubt it
15:42:40 <koz_> :(
15:42:47 <koz_> I mean, in _any_ sense.
15:42:55 <Uniaika> I think right now, the battle-proven ghcid is our best option.
15:43:07 <koz_> Uniaika: I've never gotten it to work in a satisfactory manner.
15:43:12 <maerwald> same here lol
15:43:25 <maerwald> cabal repl...
15:43:33 <maerwald> :r is not hard to type
15:43:44 <Uniaika> ghcide + coc pollutes my Neovim :/
15:43:56 <maerwald> don't get me started on coc
15:43:56 <koz_> I refuse to go anywhere near the garbage fire that is Node.js.
15:43:59 <Uniaika> the LSP client story on vim/neovim still has some progress
15:44:07 <maerwald> coc is the worst, the code is dangerous
15:44:11 <koz_> When I read that I needed Node.js, I noped out so fast you could have seen it from space.
15:44:13 <maerwald> process handling is broken
15:44:27 <koz_> [insert obligatory pun on its name]
15:44:34 <koz_> [which I will not do because I am a classy gentleman]
15:44:40 <maerwald> LC is ok-ish, just slower in feature progression
15:44:55 <koz_> I'll muck about with it a bit, because shaving yaks is what I do.
15:45:06 <maerwald> but when I used it, the warnings etc sometimes would randomly glitch out
15:45:11 <Uniaika> [makes a pun with a famous proof assistant's name]
15:45:27 <koz_> Uniaika: Because you are a classy person?
15:45:56 <Uniaika> koz_: no, because I'm french.
15:46:01 <koz_> Uniaika: LOL
15:46:06 <koz_> Oui oui, baguette?
15:46:21 <koz_> (I apologize profusely in advance)
15:47:05 <maerwald> that wasn't in advance
15:47:10 <koz_> maerwald: True.
15:47:49 <Uniaika> koz_: only a kiwi or an american would make such a joke… :P
15:47:58 <Uniaika> which side of the globe are you on?
15:48:00 <koz_> Uniaika: I am neither of those things.
15:48:08 <Uniaika> damn you then! :<
15:48:08 <koz_> I happen to live in NZ, but I'm certainly no Kiwi.
15:49:17 <koz_> (also, 'classy' in a Haskell context has an interesting difference in meaning)
15:49:22 <maerwald> Uniaika: you guys on curfew too already?
15:50:22 <Uniaika> maerwald: yeah since last week
15:50:38 <Uniaika> well it's not curfew, more like isolation
15:59:07 <koz_> So... does this deficiency mean that hie + LC can't even show me the types of holes?
15:59:14 <koz_> If so, it's basically 100% unusable.
15:59:54 <sm[m]> koz_: did you say you never got ghcid working satisfactorily ?
15:59:58 <koz_> sm[m]: I did.
16:00:06 <koz_> After multiple attempts even!~
16:00:15 <koz_> OH WAIT IT WORKED
16:00:27 <koz_> Took a while but worked.
16:01:07 * sm[m] stands down
16:01:22 <koz_> (hie, not ghcid)
16:01:32 <koz_> Now to adjust to its interface woo.
16:04:02 <koz_> Is there a way I can open a ... way to see the entire error message from hie in Neovim?
16:04:12 <koz_> I used to use :lopen with ALE, but am unsure what to use here.
16:04:19 <koz_> I only get one line of it in the gutter.
16:05:35 <sm[m]> koz_: ack, well, of course hie gives trouble, a totally different animal
16:05:56 <koz_> sm[m]: Yeah, I figured I'd give it a whirl. This is my current biggest issue.
16:06:09 <koz_> I'm not a Neovim expert, so I have no idea what exactly to do with the issue I just described.
16:06:57 <maerwald> hie is a time sink and not worth it imo
16:07:07 <sm[m]> sorry, having spent multiple days twiddling those IDE things I'm not even interested
16:07:18 <koz_> Ehh, fair enough. Figured I'd at least try.
16:07:26 <sm[m]> until the next shiny optimistic release anyhow :)
16:08:10 <sm[m]> don't let my pessisimism stop you, just a kindly warning
16:08:55 <maerwald> I think the general experience here with hie is consistent. It works only occasionally
16:09:15 <maerwald> I would go so far to say only try it if you're using VSCode
16:09:57 <koz_> Lol, figures.
16:10:04 <koz_> Alrighty, so maybe ghcid might be the way to go.
16:10:17 <koz_> All I basically want is 'view the types of typed holes in Neovim'.
16:10:25 <koz_> Also 'have the ability to see error messages in location list'.
16:10:36 <koz_> If ghcid can be made to do those two, I'll be happy enough.
16:10:45 <maerwald> cabal repl :P
16:10:47 <sm[m]> run ghcid in a side window, move on, I say
16:10:58 <maerwald> and then codex for navigating code
16:11:03 <maerwald> everything else doesn't work
16:11:06 <d34df00d> Ah, haskell tooling discussion.
16:11:08 <d34df00d> I joined at the right time.
16:11:20 <maerwald> what tooling?
16:11:25 <d34df00d> hie ghcid etc.
16:11:25 <yushyin> ther is not much to say about it
16:11:29 <yushyin> there*
16:11:38 <koz_> So... basically 'just use ALE because it's the only thing which works reliably, even if it needs horrendous amounts of hackery', got it.
16:11:46 <koz_> I can't say I'm surprised.
16:11:57 <Uniaika> ghcid does show you type holes
16:11:57 <d34df00d> Hie is a waste of ram rather than waste of time. It quite often eats 5-10 gigs on very small-sized projects (less then 1kloc).
16:12:05 <Uniaika> that's like, a basic compiler warning message
16:12:50 <koz_> Uniaika: In a separate window, away from the context of the line. At least with ALE I get the error inline, even if the location list formatting is a bit garbage.
16:13:09 <maerwald> Uniaika: even intero had that problem. It was about pre-loading type info
16:13:09 <koz_> I won't even start on the hilarious amounts of breakage I've had from it trying to run inside vim of any stripe's terminal.
16:13:20 <maerwald> although with a 1k LOC codebase that shouldn't be the case
16:14:01 <d34df00d> I'm ashamed to admit, but idea-community with the haskell plugin runs surprisingly well.
16:14:31 <d34df00d> It doesn't have all the stuff that hie has, but the code navigation is actually working, and it doesn't require rebuilding the tooling itself if the ghc version upgrades.
16:14:49 <d34df00d> And it also supposedly has typed holes info and all that, but I wasn't able to figure out how to get that.
16:15:11 <d34df00d> And it never eats more than 500 megs of ram, so I can do more than 3-4 projects simultaneously on my 64 gig machine!
16:15:33 <koz_> Alrighty, guess I'll stick with ALE then.
16:15:36 <AWizzArd> sounds good
16:15:42 <koz_> It's got some issues too, but at least I know what to expect lol.
16:15:54 <maerwald> koz_: which provider
16:16:01 <koz_> maerwald: stack-build, with a few options.
16:16:02 <d34df00d> But ale is like a client, no? You still have to have a backend that does code analysis and what not.
16:16:06 <d34df00d> Ah, stack build.
16:16:17 <koz_> You can use cabal-build, but you basically have to reimplement it because they do a bad.
16:16:24 <d34df00d> I personally found it to be a bit less interactive-ish in my environment.
16:16:28 <koz_> (cd into directory with file, for reasons that totally escape me)
16:16:44 <maerwald> cabal exec ghci
16:16:46 <maerwald> err
16:16:55 <maerwald> https://github.com/dense-analysis/ale/blob/master/ale_linters/haskell/cabal_ghc.vim#L8
16:17:27 <koz_> maerwald: Don't use this unless you adore constant errors about modules not being found.
16:17:33 <koz_> Including _internal_ ones.
16:17:35 <d34df00d> I wish somebody did a working guide along the lines "haskell + vim in 2020".
16:17:50 <d34df00d> Like sdiehl did a few years ago.
16:17:57 <koz_> d34df00d: Some folks have. They all involve coc and hie, which makes them awful.
16:18:02 <koz_> I've read at least three.
16:19:25 <maerwald> I started to need ghci even less, I noticed.
16:19:27 <d34df00d> I actually switched ale to coc.
16:19:36 <d34df00d> It sort of works.
16:19:48 <koz_> Yeah... Node.js is going nowhere near any machine I use.
16:20:00 <maerwald> This feeling when you've been coding for 15 minutes straight and don't get a compile error afterwards. It's amazing
16:20:10 <maerwald> Kind of its own game
16:20:22 <d34df00d> It was winter, and I run gentoo, so why not spend some electricity compiling nodejs to warm my room.
16:21:24 <maerwald> Makes you more disciplined!
16:21:30 <maerwald> Away with IDE tools!
16:21:42 <koz_> d34df00d: LOL
16:21:49 <koz_> I suppose if those are your priorities...
16:22:32 <d34df00d> More seriously, I cringed too when I figured coc needs nodejs.
16:22:41 <d34df00d> But I was really curious if it's all that better.
16:23:29 <int-e> maerwald: main = do putStrLn "Hello, world!"; putStrLn "Hello, world!"; ... [the programmer's equivalent of "All work and no play makes Jack a dull boy.")
16:24:37 <d34df00d> It's provably equivalent to `forM_ [0..99] $ \_ -> putStrLn "Hello, world!"`, so I'll go with that.
16:26:18 <int-e> d34df00d: that won't take 15 minutes though
16:26:55 <d34df00d> I can type that slowly.
16:26:58 <d34df00d> Or pretend it's compiling.
16:29:57 <koz_> Oh well, it was a fun experiment.
16:34:00 <koz_> If I wanted a wiki implemented in Haskell, what should I use/do?
16:39:52 <Uniaika> koz_: what *could* you use, or what *would you want* to use? 
16:40:27 <koz_> Uniaika: Uhh, the latter, because why would I want to use something I _could_ use, but wouldn't _want_ to?
16:40:54 <Uniaika> well, the "haskell" requirement doesn't leave much choice :P
16:41:00 <Uniaika> I only know of Gitit -> https://github.com/jgm/gitit
16:41:31 <koz_> Uniaika: OK, thanks, I can start there at least.
16:42:52 <Uniaika> :)
16:43:14 <d34df00d> Ugh, a friend of mine recently had a JS interview, and she was asked to print n-th number among all numbers in the ordered set { 2^i 3^j 5^k | i, j, k ∊ N }, for n between 5000 and 10000.
16:43:24 <d34df00d> Out of curiosity, I did that in haskell.
16:43:42 <d34df00d> Took me 5-10 min to arrive at powers = 1 : expand 2 `mergeUniq` expand 3 `mergeUniq` expand 5 where expand factor = (factor *) <$> powers
16:43:57 <d34df00d> With mergeUniq :: Ord a => [a] -> [a] -> [a] being a very obvious function.
16:44:17 <d34df00d> But anyway, I'm also trying to do a C++ version now as a performance baseline, and... meh, I just want to throw up the table.
16:44:27 <d34df00d> I'd fail that interview in C++.
16:44:41 <koz_> d34df00d: I'd wanna throw up _on_ the table. :P
16:45:02 <ziman> you start with "class Thunk {" ;)
16:45:20 <solonarv> surely that should be a template
16:45:24 <{abby}> I'd start with an unregisterised build of GHC
16:45:32 <koz_> d34df00d: This kind of problem sounds like a job for LogicT. :P
16:45:51 <d34df00d> koz_: you suggest implementing that in C++?
16:45:54 <solonarv> hm, there might be a clever number-theoretic trick
16:45:59 <d34df00d> I'd refrain.
16:46:00 <koz_> d34df00d: Not in C++, no. Just in general.
16:46:10 <solonarv> but that really has nothing to do with programming...
16:46:43 <d34df00d> solonarv: my number theory really sucks (finite group theory was the most boring part of algebra for me), but I couldn't think of anything good in a reasonable timeframe.
16:46:55 <koz_> Yeah, I don't think I could either.
16:47:20 <koz_> But to be honest, if they bounce a candidate (for a _JS_ job especially) on that, I don't want to be anywhere near any of their systems anyway.
16:47:35 <koz_> Because they're probably giant, undocumented, messes full of 'clever tricks' which run like garbage and can't be fixed.
16:47:41 <koz_> (and aren't tested, profiled or benchmarked)
16:47:41 <d34df00d> 100% agreed on this.
16:47:42 <koz_> (ever)
16:48:17 <solonarv> d34df00d: oh yeah, I can't think of an actual approach either
16:50:03 <d34df00d> Well, the above computes 10'000'000th number in about 4 seconds on my machine, and since it's a really huge number (so that's lots of gmp under the hood), I'd call it good enough performance-wise.
16:51:15 <solonarv> for the 'n' specified in the task, a fairly naive brute force probably works anyway
16:51:18 <ziman> how much memory do you need to compute n-th number in that sequence?
16:51:37 <solonarv> oh, one thing that's helpful is that the elements are already distinct in that presentation
16:51:39 <d34df00d> ziman: if I use `powers` once, that's O(1).
16:51:43 <d34df00d> Otherwise it gets O(n)
16:51:53 <solonarv> so you don't need to do any extra work to remove duplicates
16:52:27 <ziman> is it?
16:52:45 <d34df00d> ziman: or, specific numbers are about 14 megs as reported by -sstderr.
16:53:08 <d34df00d> ziman: well, you have to keep the whole list in memory if the compiler can't prove it can get rid of the head.
16:53:09 <ziman> to compute (n+1)th number, you need to keep the prefix that starts at 1/5th the size of that number
16:53:12 <d34df00d> (the whole computed list that is)
16:53:34 <d34df00d> Ah! Sure, you can quite likely do better than this!
16:53:47 <d34df00d> But it wouldn't be as nicely expressed perhaps.
16:54:21 <d34df00d> solonarv: that depends on how do you build the elements of that presentation. For instance, 10 can be obtained from 2 by multiplying by 5, or from 5 by multiplying by 2.
16:54:21 <ziman> well, "prefix" is probably a wrong word for what you need to keep :)
16:54:35 <d34df00d> Infix? :)
16:54:41 <sm[m]> koz_: gitit is the only one I think. There are also lots of tools which render static pages, and could be customised to add some wiki features
16:55:04 <koz_> sm[m]: Yeah, I'm familiar with a bunch of static site stuff, but I really want something wiki-like.
16:56:04 <phadej> it's relatively easy to make wiki out of hakyll
16:56:09 <sm[m]> aside from its author, darcs.net uses gitit
16:56:37 <sm[m]> nobody else I think. But it’s probably quite good
17:00:55 <phadej> happstack, wow
17:02:31 <phadej> (that's library flying way below the radar)
17:03:02 * hackage freetype2 0.2.0 - Haskell bindings for FreeType 2 library  https://hackage.haskell.org/package/freetype2-0.2.0 (Mokosha)
17:04:07 <sm[m]> Was once “the” Haskell web framework (HAppS)
17:09:59 <whataday> val :: Maybe (Either SomeException ())
17:10:36 <whataday> why it can't use 'if val == Nothing then ...'?
17:11:05 <whataday> but 'case val of Nothing -> ...' is ok
17:12:14 <d34df00d> Long story short, because == on values of type `Maybe a` requires that the underlying type `a` is also comparable.
17:12:26 <d34df00d> Which is likely not the case for SomeException.
17:12:58 <d34df00d> While when you do pattern-matching, you, to simplify it, check if the shape of the value matches your pattern (and the pattern/shape is really simple in this case, just a Nothing).
17:13:57 <Uniaika> speaking about interview, I remember having read an article that gave you tips and tricks for interviews that made you use prime numbers. Like "if you're asked for the prime numbers between 0 and 1000, just return this list." and other micro-optimisations like that
17:14:19 <{abby}> i don't think many interviewers would appreciate that.
17:14:38 <Uniaika> nah, the article was a bit cheeky about the absurd nature of tech interviews :P
17:15:13 <d34df00d> Luckily I'm not being asked "tricky" or algorithmic questions for quite a while.
17:17:49 <whataday> is there any other way to do that? except case
17:18:27 <d34df00d> Depends on a larger context.
17:18:30 <whataday> I thought that case can implement by if,
17:18:50 <d34df00d> Can you give the code surrounding `val`?
17:21:23 <koz_> If you have a Maybe, you can disassemble it with 'maybe'.
17:21:25 <koz_> :t maybe
17:21:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:21:35 <koz_> fromMaybe also has uses here
17:21:36 <whataday> https://github.com/jusss/code/blob/bla2/Haskell/I2T14.hs
17:21:38 <koz_> :t fromMaybe
17:21:39 <lambdabot> a -> Maybe a -> a
17:22:07 <whataday> 305 line
17:22:33 <koz_> whataday: https://github.com/jusss/code/blob/bla2/Haskell/I2T14.hs#L305 <-- that's a direct line link
17:22:40 <koz_> You can get it by clicking the line number.
17:23:07 <whataday> oh, I see
17:23:08 <koz_> I guess you wanna avoid having to write 8 different pattern matches?
17:23:19 <d34df00d> I'd probably keep it as is, if that's just the two branches you'll have.
17:23:27 <koz_> Also, I think 'case (r1, r2, r3) of ..' makes way more sense here than a list.
17:23:35 <koz_> You will _always_ have _exactly_ three results.
17:23:38 <d34df00d> BTW you can also use [Just _, Just _, Just _] if you don't use the values.
17:23:45 <d34df00d> And yeah, what koz_ mentioned.
17:23:58 <koz_> :t any
17:23:59 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:24:05 <koz_> :t if (any isJust)
17:24:05 <d34df00d> any isNothing?
17:24:06 <lambdabot> error:
17:24:06 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:24:08 <d34df00d> Oh yeah.
17:24:16 <koz_> Or something liek that.
17:24:26 <d34df00d> `all isNothing` sounds better tho!
17:24:33 <d34df00d> Code should be like poetry.
17:24:33 <koz_> ALL IS NOTHING
17:24:36 <koz_> Black Metal Haskell.
17:24:48 <koz_> (the sign of the horns is an upside-down m, hence it's a comonad)
17:25:05 <d34df00d> lol
17:25:44 <whataday> fmap poll [a1, a2, a3] :: [IO Maya (Either SomeException ())]
17:25:45 <koz_> 'Comonad \m/' unfortunately won't work I don't think.
17:25:57 <whataday> how I can get that Maybe value?
17:26:04 <koz_> whataday: Why are you jamming this into a list? Won't yu _always_ have three things?
17:26:10 <koz_> If so, you want a tuple. Stop with the Python logic. :P
17:26:42 <whataday> because fmap work on list is fine
17:26:52 <whataday> fmap work on tuple is weird
17:26:52 <d34df00d> I like the Foldable and Traversable instances for tuples.
17:26:55 <koz_> whataday: That kind of reasoning is liable to explode in your face.
17:27:04 <koz_> Don't just jam fmap into every possible hole.
17:27:24 <d34df00d> And I'm genuinely upset by the fact that there are no Foldable and Traversable instances for n-tuples for n > 2.
17:27:32 <d34df00d> That should be so much fun!
17:27:37 <koz_> d34df00d: What would a Foldable for (a, b, c) even look like?
17:27:55 <d34df00d> The same as for (a, b) — just do the stuff with the last element.
17:27:55 <whataday> fmap work on [Async a] and product [IO a] , how I can get that a from it?
17:28:11 <koz_> You can't 'get' an 'a' out of 'IO a'.
17:28:14 <koz_> That's kind of the entire point.
17:28:24 <whataday> fmap f (a,b) == (a, f b)
17:28:43 <koz_> whataday: Yes, because you shouldn't try and jam fmap into every possible hole.
17:28:55 <whataday> yes, I can, when it's in do notation
17:29:01 <koz_> What you want is to work over _precisely three_ results. This means 'you want a tuple'.
17:29:04 <koz_> Uhh, no, you can't.
17:29:08 <koz_> That's not what do-notation does.
17:29:17 <koz_> It's just syntactic sugar over (>>=) and pure.
17:29:26 <koz_> At no point do you 'get' anything out of IO.
17:30:12 <whataday> so you mean >>= still can't get a from IO a when it's in the >>=?
17:30:23 <koz_> That question makes zero sense.
17:30:33 <koz_> :t (>>=)
17:30:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:30:41 <koz_> At no point do you 'get' anything out of anything else.
17:30:51 <whataday> I don't mean get out a from IO a
17:31:07 <whataday> get a in >>=
17:31:26 <koz_> You can use a value of type 'a' in the function you pass to >>=, yes.
17:31:35 <koz_> However, you're not 'getting' anything out of anything else.
17:31:44 <koz_> THinking like this isn't going to get you very far.
17:31:54 <whataday> and I remember we do have that a function can get a out of IO a
17:32:02 <koz_> Yes, it's called 'unsafePerformIO'.
17:32:05 <koz_> For good reason.
17:32:08 <whataday> yes
17:32:18 <ysangkok> whataday: if you want to swap the outer two monads, you can use sequenceA
17:32:20 <koz_> If you want to ignore the safety guarantees of the type system, all bets are off.
17:32:21 <ysangkok> :t sequenceA
17:32:23 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
17:32:55 <ysangkok> whataday: so if you have an expression of the type menitoned in your first message [IO ...] you can turn it into IO [...]
17:33:19 <ysangkok> whataday: then, you can execute it in your main function (which returns IO, so it is in the IO monad)
17:33:43 <whataday> swap outer monads is related to natural transform?
17:34:03 <koz_> I don't believe so, but I'm not one of the CT-literate people here.
17:34:22 <koz_> :t sequenceA
17:34:23 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
17:34:35 <koz_> So technically 'swap outer monads' is misleading, because that's not generally true.
17:34:43 <ysangkok> whataday: you won't need unsafePerformIO, since you can use <- to get an 'a' from an 'IO a' in your main
17:34:45 <koz_> (it works fine in this case)
17:34:48 <frdg> what is the difference between " . " and " $ " ? Every function from the book im reading works the same regardless of which operator I use
17:34:59 <koz_> frdg: The difference can be read from their types.
17:35:01 <koz_> :t (.)
17:35:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:35:07 <koz_> THis is function composition.
17:35:10 <koz_> :t ($)
17:35:11 <lambdabot> (a -> b) -> a -> b
17:35:15 <koz_> This is function _application_.
17:36:03 <frdg> thank you
17:39:24 <whataday> ok
17:53:02 * hackage lz4-hs 0.1.4.0 - lz4 bindings for Haskell  https://hackage.haskell.org/package/lz4-hs-0.1.4.0 (vmchale)
17:59:07 <dmwit> . v $ is one of the most popular questions in the haskell tag on SO. =P
18:00:40 <koz_> I don't remember who exactly, but someone in this channel gets very upset with $ use for bracket-removal.
18:00:53 <koz_> I get the feeling they might chime in any minute now. :P
18:01:26 <jumper149> koz_: What that's ridiculous! $ is best operator
18:04:37 <jumper149> Isn't the most general natural transformation `m a -> n a`?
18:06:37 <jumper149> Which would make sequence also natural transformation I guess?
18:11:52 <whataday> I like 'f . g . t $ a'
18:23:52 <oats> I tolerate it
18:24:13 <oats> I like it better if it's used for a pointfree function :P
18:24:34 <oats> f = g . h . i
18:24:55 <jumper149> There was a time, when I thought pointfree means without the . operator ;)
18:25:29 <int-e> jumper149: the opposite is true, you can recognize pointfree code by its abundance of dots.
18:25:38 <oats> hehe
18:25:54 <jumper149> int-e: I did learn it somewhere along the way :D 
18:26:15 <int-e> I just like saying that. This seemed a good opportunity :)
18:26:16 <oats> since bind (>>=) is left-to-right, I prefer 'a & b & c' if there must be a "starting" value
18:27:11 <dmwit> (=<<) is the superior operator for exactly this reason
18:27:20 <oats> lol I knew someone would mention that
18:27:24 <oats> or maybe (<=<)
18:27:35 <oats> my brain doesn't care for having to read some things left-to-rigt and others right-to-left
18:27:39 <iqubic> I love (=<<) and (<=<)
18:27:57 <iqubic> I love reading everything right to left.
18:28:40 <int-e> iqubic: that to relate notcan I
18:29:30 <parsnip> gnihtyreve
18:30:14 <dmwit> <3
18:33:48 <solonarv> jumper149: yes, sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a) is a NT from Compose t f to Compose f t
19:13:32 * hackage musicScroll 0.2.1.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.1.0 (RubenAstudillo)
19:21:18 <jumper149> I actually love $ so much that I want to use it on types all the time :D
19:43:51 <yushyin> lol
20:00:21 <newsham> ?bot
20:00:21 <lambdabot> :)
20:02:30 <koz_> :t $ ($)
20:02:32 <lambdabot> error:
20:02:32 <lambdabot>     parse error on input ‘$’
20:02:32 <lambdabot>     Perhaps you intended to use TemplateHaskell
20:02:38 <koz_> :t ($) ($)
20:02:39 <lambdabot> (a -> b) -> a -> b
20:02:53 <koz_> Ell oh ell.
20:05:36 <koz_> Is there a way I can ask Stackage 'what is the most recent LTS for [compiler version X]?'?
20:08:56 <iqubic> :t (&)
20:08:57 <lambdabot> a -> (a -> b) -> b
20:09:05 <koz_> :t flip ($)
20:09:06 <lambdabot> a -> (a -> c) -> c
20:09:08 <iqubic> :t flip (&)
20:09:09 <lambdabot> (a -> c) -> a -> c
20:09:15 <iqubic> :t ($)
20:09:16 <lambdabot> (a -> b) -> a -> b
20:09:25 <iqubic> Wait...
20:09:29 <iqubic> :t ($)
20:09:31 <lambdabot> (a -> b) -> a -> b
20:09:34 <koz_> Yes, it is exactly as you think.
20:09:35 <iqubic> :t ($) ($)
20:09:36 <lambdabot> (a -> b) -> a -> b
20:09:41 <koz_> :t ($) ($) ($)
20:09:43 <lambdabot> (a -> b) -> a -> b
20:09:46 <iqubic> Those have the same type signature.
20:09:50 <koz_> :t fix ($)
20:09:52 <lambdabot> a -> b
20:09:57 <iqubic> Hmm?!?
20:10:34 <iqubic> > (+10) ($) ($) ($) 1
20:10:36 <lambdabot>  error:
20:10:36 <lambdabot>      • No instance for (Typeable a0)
20:10:36 <lambdabot>          arising from a use of ‘show_M922090814255097536616315’
20:10:40 <newsham> apply yourself 
20:10:54 <koz_> newsham: That's... actually quite clever.
20:10:57 <iqubic> > ($) ($) ($) (+10) 1
20:10:59 <lambdabot>  11
20:11:23 <iqubic> > ($) ($) ($) ($) ($) ($) ($) (+10) 1 -- seven $
20:11:24 <newsham> words are fun toys
20:11:25 <lambdabot>  11
20:11:38 <iqubic> What the hell??
20:11:42 <iqubic> :t ($)
20:11:43 <lambdabot> (a -> b) -> a -> b
20:12:16 <newsham> ?pl ($) ($) ($) ($) (+10)
20:12:16 <lambdabot> (10 +)
20:12:42 <iqubic> yeah, that's just about as I thought.
20:12:47 <koz_> @pl (fix ($)) (+ 10)
20:12:47 <lambdabot> fix id (10 +)
20:12:53 <koz_> :D
20:13:09 <iqubic> I'm so bloody confused.
20:15:07 <newsham> ?info ($)
20:15:07 <lambdabot> ($)
20:17:26 <newsham> ?pl ($) ($)
20:17:26 <lambdabot> id
20:17:32 <newsham> ?pl ($) 
20:17:32 <lambdabot> id
20:19:24 <newsham> ?src ($)
20:19:24 <lambdabot> f $ x = f x
20:19:59 <newsham> id f x = f x
21:10:32 * hackage musicScroll 0.2.2.0 - Supply your tunes info without leaving your music player.  https://hackage.haskell.org/package/musicScroll-0.2.2.0 (RubenAstudillo)
21:10:46 <slack1256> yay
21:11:47 <slack1256> Made with lots of applicatives <3
21:16:32 * hackage aop-prelude 0.1.0.0 - prelude for Algebra of Programming  https://hackage.haskell.org/package/aop-prelude-0.1.0.0 (KatsutoshiItoh)
21:16:49 <whataday> is sequenceA related to Control.Natural.~> ?
21:17:07 <whataday> they both can do natural transform
21:17:22 <whataday> :t (~>)
21:17:24 <lambdabot> error:
21:17:24 <lambdabot>     • Variable not in scope: ~>
21:17:24 <lambdabot>     • Perhaps you meant one of these:
21:20:04 <whataday> how to ensure a list only contain same elements?
21:20:48 <whataday> like how to detect a list only contain Nothing?
21:20:57 <whataday> get the Bool result
21:21:26 <sleblanc> :t all
21:21:27 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:22:46 <sleblanc> :t all (== Nothing)
21:22:48 <lambdabot> (Foldable t, Eq a) => t (Maybe a) -> Bool
21:23:07 <sleblanc> ^ whataday 
21:23:32 * hackage replace-attoparsec 1.2.1.0 - Find, replace, and edit text patterns with Attoparsec parsers  https://hackage.haskell.org/package/replace-attoparsec-1.2.1.0 (JamesBrock)
21:23:48 <whataday> 0 + 1 == 1; 1 * 3 == 3; what about Just a and Nothing , sleblanc
21:24:08 <whataday> the unit
21:24:47 <sleblanc> whataday, I don't get it
21:25:49 <whataday> oh, my mistake
21:26:03 <whataday> return is the unit in >>=
21:26:13 <whataday> id is the unit in .
21:49:59 <whataday> what function f can do 'f (Just a) Nothing = Just a; f Nothing Nothing = Nilothing'
21:56:29 <fraktor> I'm working on taking a string of dots and dashes (".--.--.-" for example) and showing possible decodings.  I have it working, but it doesn't feel particularly elegant and is using explicit recursion.  Does anyone have suggestions on how to improve this code? https://0paste.com/59228#hl
21:56:40 <koz_> whataday: What do you want to do for 'f Nothing (Just x)'?
21:56:47 <koz_> And 'f (Just x) (Just y)'.
21:56:51 <koz_> 'Don't care' is a valid answer.
21:57:02 <koz_> fraktor: Define 'possible decodings' here.
21:57:53 <fraktor> ".--" could be "ETT", "AT", "P", or "EM"
21:58:41 <whataday> f Nothing Just a = Just a
21:58:42 <fraktor> Sorry, "W", not "P".
21:59:12 <koz_> > Nothing <|> Just 'a'
21:59:14 <lambdabot>  Just 'a'
21:59:17 <whataday> I just want && work on Just a and Nothing, like && on True and False
21:59:31 <koz_> > Nothing <|> Nothing
21:59:33 <lambdabot>  Nothing
21:59:36 <koz_> Does this suit?
22:00:22 <koz_> fraktor: I don't follow the logic of this, sorry.
22:00:39 <whataday> <|> is from?
22:00:46 <koz_> whataday: Alternative.
22:00:51 <whataday> .hoogle <|>
22:00:52 <koz_> (you can import from Control.Applicative).
22:01:00 <whataday> ok
22:01:15 <koz_> > Nothing `mplus` (Just 'a')
22:01:17 <lambdabot>  Just 'a'
22:01:23 <koz_> > Nothing `mplus` Nothing
22:01:25 <lambdabot>  Nothing
22:01:33 <koz_> ^ also works (is in fact the same thing)
22:01:52 <whataday> can I say Nothing is the unit in <|>?
22:02:06 <koz_> Yep. Alternative names that particular idea as 'empty'.
22:02:12 <koz_> :t empty :: Maybe Int
22:02:13 <lambdabot> Maybe Int
22:02:16 <koz_> Whoops.
22:02:22 <koz_> > empty @(Maybe Int)
22:02:24 <lambdabot>  error:
22:02:24 <lambdabot>      Pattern syntax in expression context: empty@(Maybe Int)
22:02:24 <lambdabot>      Did you mean to enable TypeApplications?
22:02:27 <koz_> Argh.
22:02:38 <koz_> % :set -XTypeApplications
22:02:38 <yahb> koz_: 
22:02:45 <koz_> % empty @(Maybe Int)
22:02:45 <yahb> koz_: ; <interactive>:3:9: error:; * Expected kind `* -> *', but `Maybe Int' has kind `*'; * In the type `(Maybe Int)'; In the expression: empty @(Maybe Int); In an equation for `it': it = empty @(Maybe Int)
22:02:51 <koz_> Ah, right
22:02:54 <koz_> % empty @Maybe
22:02:55 <yahb> koz_: Nothing
22:02:57 <koz_> :D
22:03:15 <koz_> % empty <|> Just 'a'
22:03:15 <yahb> koz_: Just 'a'
22:03:23 <koz_> % Just 'a' <|> empty
22:03:23 <yahb> koz_: Just 'a'
22:03:28 <koz_> % empty <|> empty
22:03:28 <yahb> koz_: *** Exception: user error (mzero)
22:03:31 <koz_> Lol.
22:03:51 <koz_> % empty <|> empty @Maybe
22:03:51 <yahb> koz_: Nothing
22:04:38 <int-e> fraktor: I like the explicit recursion. I'd use more list comprehension... morseDecompose pat = [c:cs | (pre, c) <- morseMap, pre `isPrefixOf` pat, cs <- decode (drop (length pre) pat)]
22:04:56 <koz_> Oh, the context is Morse code. Derp.
22:05:41 <fraktor> koz_: Nah you're good. :P
22:05:48 <fraktor> I should have been more explicit about that
22:06:26 <fraktor> int-e: what is `decode`?
22:06:48 <int-e> fraktor: oops, that was supposed to be the recursive call... morseDecompose
22:09:00 <fraktor> That works just the same, and looks a lot better.  Thanks!
22:54:51 <suzu> anybody here know katip, the logging library?
22:55:20 <suzu> i've got this minimal example here that doesn't log anything
22:55:21 <suzu> https://pastebin.com/LRccJXyE
22:55:26 <suzu> and i'm stumped as to why
23:07:16 <suzu> ok figured it out
23:07:28 <suzu> needs to be flushed with closeScribes if you don't trigger a flush otherwise
23:31:42 <web47> ddd
23:31:43 <web47> ddd
23:31:44 <web47> dd
