00:37:27 <tdammers> myme: a pattern you see often is to generalize the configuration data structure over some * -> * type
00:37:59 <tdammers> myme: data Config f = Config { port :: f Int, dsn :: f String, ... }
00:38:14 <tdammers> myme: and then you can have all your various option parsers produce Config Maybe
00:38:28 <tdammers> and combine them with field-wise <|>
00:39:30 <tdammers> you may want to write a generic combinator: (forall a. f a -> f a -> g a) -> Config f -> Config f -> Config g
00:39:49 <tdammers> and a unary flavor: (forall a. f a -> g a) -> Config f -> Config g
00:50:41 <mjrosenb> every time you add a new config option, you'd need to update that combinator, which seems sub-par.
00:51:31 <tdammers> if it gets out of hand, you can de-boilerplate a little using generics or TH
00:54:36 <mjrosenb> fair.
00:57:09 <tdammers> and, I mean, what are the alternatives?
00:57:32 <merijn> tdammers: Magic ;)
00:57:34 <tdammers> you could just have a plain Configuration type and implement a more specific combinator
00:57:53 <tdammers> you could throw the type-safe configuration idea out the window and just use Map Text Value or sth
00:57:56 <mjrosenb> Map String String :-p clearly
00:58:17 <tdammers> boils down to the same thing, doesn't it
00:58:35 <tdammers> OR you could break out the big guns and pull some advanced type-level stunts
00:59:08 <tdammers> maybe even just something like a Vault would do
00:59:53 <mjrosenb> Vault?
01:01:00 <hololeap> anyone know why Float doesn't have a Bounded instance?
01:02:07 <tdammers> mjrosenb: think of it as a heterogenous dictionary where the type of the value is encoded in the key, so that you can get typesafe lookups without needing to check the type at runtime
01:02:52 <hololeap> how could i get the lowest possible Float excluding -Infinity
01:09:09 <merijn> hololeap: bitmask it yourself? >.>
01:10:09 <merijn> \o/ Heinrich Apfelmus's lazy evaluation guide has been resurrected so we can go back to linking that to beginners instead of manually explaining things over and over :p
01:11:05 <hololeap> yeah i'm starting to realize using something like Word32 would be better for the job
01:13:23 <mjrosenb> tdammers: sounds nice.
01:13:29 <myme> tdammers: Thanks for your input. It's not really a problem, it just quickly becomes repetative, as well as having many similarly named, yet different (module scoped) accessors to different datatypes.
01:14:43 <myme> Having some(limited) experience with Purescript's row polymorphism and e.g. typescripts type-level programming/mutation, you can reuse and modify types based on others.
01:15:09 <myme> Reduces the boilerplate a bit, but arguably adds a lot to the complexity though.
01:15:54 <mjrosenb> https://gist.github.com/mjrosenb/0ef52b93107c6c2745c894932d5a2fd2 -- does anyone know how I can merge those two into one binding?
01:19:34 <merijn> mjrosenb: replace First/Endo with 'f' and add a "Monoid (f ...)" constraint?
01:20:54 * hackage verismith 1.0.0.0 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-1.0.0.0 (ymherklotz)
01:24:19 <mjrosenb> hrm.     • Expected kind ‘* -> *’, but ‘f’ has kind ‘*’ 
01:24:27 <mjrosenb> I appear to have done something wrong.
01:29:29 <mjrosenb> oh, I added a Monoid f constraint
01:29:37 <mjrosenb> not Monoid (f ...)
01:29:43 <mjrosenb> yuuuup that would do it.
01:33:54 * hackage verismith 1.0.0.1 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-1.0.0.1 (ymherklotz)
01:35:59 <dminuoso> merijn: We should lobby for when.
01:36:01 <dminuoso> *mwhen!
01:36:13 <dminuoso> mwhen :: Monoid m => Bool -> m -> m
01:37:35 <dminuoso> Every time I use prettyprinter, Im missing this. ;)
01:37:42 <boxscape> what's the best way to get `Bool -> (a -> a) -> (a -> a)` out of that? Hope for applying via and write `mwhen @(via Endo)`?
01:37:57 <boxscape> hopre for applying via to be accepted, that is
01:39:25 <boxscape> hmm would ala Endo mwhen work? I haven't used ala much
01:39:40 <dminuoso> boxscape: Not for this
01:40:35 <boxscape> ok
01:40:44 <merijn> Just use coerce
01:41:10 <dminuoso> boxscape: ala is essentially for things like foldMap
01:41:18 <dminuoso> % ala Product foldMap [1,2,3,4]
01:41:18 <yahb> dminuoso: 24; it :: Num b => b
01:41:35 <merijn> dminuoso: And munless while we're at it ;)
01:42:01 <dminuoso> merijn: Sure, for consistencies sake.
01:42:21 <dminuoso> (Also, why is mplus not called plusM?)
01:42:35 <merijn> Who knows
01:42:41 <merijn> hysterical raisins
01:42:51 * dminuoso shrugs
01:48:54 * hackage verismith 1.0.0.2 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-1.0.0.2 (ymherklotz)
01:49:32 <boxscape> hm i can't really see a way to use coerce with it where just `if b then f else id` wouldn't be better :/ (Just thinking about this because I've often wanted that function)
02:08:03 <merijn> ugh
02:08:22 <merijn> How do I force cabal-install to forcibly override my index?
02:08:46 <merijn> My index got corrupted and simply nuking it leads it to complain that it can't find the index instead of just redownloading
02:11:19 <merijn> Ah, I need to nuke all the json nonsense too
02:13:24 * hackage x86-64bit 0.4.6 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.6 (PeterDivianszky)
02:49:39 <acubakari> A-2
02:59:34 <kuribas> haskell-auth-client design looks broken
03:00:48 <kuribas> Auth auths Claims :> (a :<|> b) generates Token -> (aclient :<|> bclient)
03:01:06 <kuribas> more useful would be (Token -> aclient) :<|> (Token -> bclient)
03:03:06 <lortabac> kuribas: in some projects I ended up flattening the definitions, like 'Auth auths Claims :> a :<|> Auth auths Claims :> b'
03:03:36 <lortabac> because my colleagues found the nested ones hard to deal with
03:05:34 <kuribas> yeah
03:06:40 <kuribas> IMO it's bad design
03:06:53 <kuribas> it could have made the flattening a default
03:07:01 <acubakari> Hello everyone, I am just starting to learn FP(using Haskell) and I found this(link), what's your opinion? https://blog.usejournal.com/monoids-to-groupoids-492c35105113 
03:12:50 <__monty__> kuribas: Hmm, if Auth auths Claims :> x generates Token -> xclient, what they did seems like the logical extension.
03:22:17 <kuribas> acubakari: sounds very opiniated, and not very useful for a beginner
03:22:43 <kuribas> __monty__: more logical would be to distribute it
03:24:13 <kuribas> acubakari: I don't see FP as a dogma that forces you in one way, but rather like a collection of techniques, which you can use at your discretion.
03:24:30 <kuribas> acubakari: and that IMO is one of the advantages over Object Orientation.
03:25:49 <kuribas> acubakari: because OO forces you into a rigid design, especially if you use inheritance.
03:26:21 <kuribas> acubakari: while FP offers similar techniques, but without being as rigid.
03:27:51 <kuribas> acubakari: I would steer away from such articles, and just try to learn the basics.
03:31:22 <__monty__> kuribas: I think you're confusing convenient for logical.
03:32:36 <kuribas> __monty__: sure
03:34:21 <Cale> kuribas: I think the heart of OO is perfectly expressible in Haskell and has nothing to do with inheritance at all
03:34:37 <kuribas> acubakari: "Yes monads do remind us of OO, but objects... "  Monads have nothing to do with OO.
03:34:56 <kuribas> Cale: I didn't claim anything else
03:35:27 <kuribas> Cale: it's my point basically, you can express OO in FP, but the opposite is much harder.
03:35:43 <Cale> hmm
03:36:15 <Cale> To me the distinction is placing more emphasis on inductive vs. coinductive representations for data.
03:36:44 <Cale> i.e. OO is about defining your data in terms of how it's going to be taken apart
03:37:11 <kuribas> This article reads like someone who wants to sound very smart, by using lots of complicated terms.
03:37:30 <kuribas> But full of false statements like: "FP is based on an interesting (if not controversial) branch of mathematics called Category Theory that sits right on the border between algebra and geometry."
03:37:38 <Cale> Yeah, that article looks a bit word salad-y and I couldn't be bothered to actually read through it to figure out what it was trying to say
03:37:54 <kuribas> Cale: care to explain?
03:39:44 <Cale> So, a fair amount of the time in Haskell, you'll have some sum type with a growing number of cases. If it gets to the point where the number of data constructors of your type is larger than the number of times you ever pattern match on it directly, it may be more efficient to redefine the type as a record of the conclusions of those case expressions.
03:40:00 <tdammers> FP and OO are orthogonal
03:40:34 <tdammers> I do think, though, that "the heart of OO" is very closely related to inheritance
03:41:01 <tdammers> or rather, the "heart of OO" includes "open recursion", and that kind of requires some sort of inheritance or mixin mechanism
03:41:26 <sm[m]> tdammers: heretic! it's message passing!
03:41:50 <Cale> OOP is all about focusing on that means of expression: describing object types X in terms of the methods/messages an object of type X responds to is the same notion as describing X in terms of a bunch of maps out of X
03:41:51 <tdammers> sm[m]: ah, yes, but that's just a different way of looking at the same thing
03:42:07 <sm[m]> is it ? oh alright then
03:42:10 <tdammers> yes
03:42:14 <int-e> was that written by an AI...
03:42:28 <kuribas> message passing implies immutable messages, yet often in OO you pass mutable objects, or hashmaps, etc...
03:43:21 <kuribas> The idea of objects as isolated things, without shared memory is much more interesting that what OO has become now.
03:43:22 <tdammers> open recursion means that when an object passes a message to itself, then the decision determining how to process that message is made at runtime
03:43:24 <int-e> I mean seriously, every sentence in there collects multiple concepts that hang together by a thing thread.
03:43:26 <Cale> There's the whole recursion shenanigans, but I don't think that's actually very important. The important thing which influences how you design your program is this way of allowing for many possible variations on data by fixing the interface through which that data will be accessed.
03:43:42 <int-e> *thin
03:44:09 <jcowan> What would be a good collective term for Maybe and Either specifically?  "Option types", perhaps?
03:44:37 <tdammers> Cale: however, an important aspect of OO design is that you hide object implementations behind interfaces; those interfaces are runtime-polymorphic, and method calls (or message handling) are dispatched based on what the object is at runtime, not based on the interface through which the object was accessed
03:44:45 <tdammers> that is a very important aspect of OOP
03:44:49 <Cale> e.g. If you have a game world, and you're not sure how many different objects you're eventually going to define to go in it, it might be better to start off by figuring out what things you need to do with all the game objects, rather than trying to define an exhaustive list of cases.
03:45:44 <Cale> tdammers: Sure, but that distinction between different objects having the same interface needn't be created through subtyping
03:45:59 <tdammers> Cale: of course not.
03:46:17 <Cale> In particular, if your language has first class functions already, you can just define object types as records of functions
03:46:34 <tdammers> you need one extra ingredient
03:46:53 <tdammers> those functions need to somehow take an extra "this" argument
03:47:18 <Cale> Sometimes, but that can also be accomplished by the functions which build the objects in the first place.
03:47:23 <tdammers> otherwise, the object's "methods" cannot correctly call methods of the object itself
03:47:37 <tdammers> not if you derive objects from other objects
03:48:24 <Cale> Like, you can have a big where clause, where you define the methods of your object, at the same time as describing what objects those methods are going to produce in some cases
03:48:33 <kuribas> int-e: that crossed my mind also
03:48:48 <Cale> and just let the definitions be mutually recursive
03:49:14 <Cale> Sometimes you really need the open recursion shenanigans, but often it's reasonable to avoid doing things like that explicitly.
03:51:01 <Cale> The thing I think which makes the biggest impact on the design of your program is simply the change of perspective between "I know what all the cases are up front, but I don't know all the things I'm going to need to do with them" vs. "I don't know all the cases I'll eventually need to handle, but I know exactly what I need to do with each one."
03:51:28 <Cale> There are appropriate times for both of those perspectives
03:52:46 <tdammers> oh yes, sure; open recursion is very very rarely needed
03:53:07 <tdammers> I'm just not willing to call a paradigm "object-oriented" that doesn't cater for open recursion
03:54:26 <boxscape> Cale: "it may be more efficient to redefine the type as a record of the conclusions of those case expressions." is that the Scott encoding? Or something different?
03:54:28 <tdammers> because just "I don't know all the cases I'll eventually need to handle, but I know exactly what I need to do with each one" is basically an "open universe", and that just requires first-class functions
03:54:36 <tdammers> (or procedures, rather)
03:55:07 <Cale> Yeah, basically just Scott encoding.
03:55:10 <boxscape> okay
03:56:48 <Cale> and yeah, I'm sort of assuming that first-class functions are available in my description of things just because it makes it all easier to think about. As I see it, whole subtyping thing was constructed as a way to sidestep the need for first class functions, and has just been a red herring of sorts ever since.
03:57:56 <tdammers> I think the crucial question is what happens when objects send messages to themselves
03:58:07 <Rembane> Cale: does this mean that you can remove subtyping completely if you have first class functions?
03:58:20 <dminuoso> Rembane: They are urthogonal.
03:58:27 <Cale> Rembane: I think so. I've done a fair amount of what I'd consider to be OO in Haskell
03:59:05 <Rembane> Cale: Cool. Doesn't Haskell have subtyping, or have I misunderstood something important?
03:59:12 <Cale> Haskell has no subtyping
03:59:44 <Cale> Unless you count instantiation of polymorphic types, which people usually don't
04:00:02 <day> isnt int a subtype of numeral/numeric or w/e it was called?
04:00:04 <Rembane> So the System F with subtyping is something else? 
04:00:36 <Cale> https://en.wikipedia.org/wiki/System_F-sub
04:01:04 <Cale> Haskell doesn't have that feature which System F-sub adds to System F
04:01:27 <Rembane> Got it, then I've just misunderstood it all.
04:01:45 <boxscape> is that like row polymorphism?
04:02:02 <Cale> boxscape: kind of, though it's a little different from that again
04:02:07 <boxscape> hm, okay
04:02:18 <Cale> But you probably wouldn't want it very much if you had row polymorphism
04:02:23 <boxscape> I see
04:03:05 <tdammers> noteworthy point: implementing OOP semantics and typechecking OOP semantics are two separate concerns
04:03:10 <Cale> It's like what they call "subclasses" in typical typed OO programming languages.
04:03:24 <boxscape> okay
04:05:51 <Cale> You're able to define types that are subtypes of other ones in the sense that when A <: B you're allowed to use a value of type A as a value of type B.
04:07:53 <boxscape> turns out brian mckenna has a short blog post on this exact topic https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping
04:08:41 <merijn> In fact, row polymorphism is pretty explicitly *not* subtyping, because subtyping has a lot of problems that row polymorphism wanted to avoid :p
04:09:20 <boxscape> how did ML get away with it? Does it just offload those problems onto the user?
04:10:07 <boxscape> though, well, technically the wiki article on F sub doesn't say that ML has subtyping, just that languages in the ML family do
04:13:18 <dminuoso> Can I tell GHC to compute type families in diagnostics?
04:13:41 <dminuoso> Concretely, Im staring at an output from GHC that says:
04:13:43 <dminuoso>         Actual type: Rad 'Access (ViewResult A_Fold Text)
04:13:49 <dminuoso> Where ViewResult is a type family
04:14:53 <boxscape> I don't suppose -fprint-expanded-synonyms does it?
04:14:54 <merijn> boxscape: Structural subtyping in, e.g. ocaml is a problem, so the answer "how do they get away with it?" is "they didn't"
04:15:01 <boxscape> I see
04:15:36 <merijn> boxscape: You run into super annoying co- vs contravariance issues, which row polymorphism is meant to fix (or rather, not introduce)
04:15:41 <boxscape> okay
04:18:18 <boxscape> huh for some reason I could have sworn that you can't use _ wildcards in type family patterns but I was wrong...
04:18:28 <merijn> boxscape: Consider "{A : int} -> {C : bool}" (these being records with typed fields)
04:18:28 <boxscape> time to rewrite all my type families to use it
04:18:57 <merijn> boxscape: With structural subtyping I can easily pass in "{A : int, B : double}" (since it's a subtype of "{A : int}"
04:19:38 <merijn> boxscape: But then, what's the result? "{B : double, C : bool}"? Why? And what if I try to pass in "{A : int, C : bool}"?
04:20:03 <boxscape> hm, yeah, I see
04:20:54 <boxscape> So I guess in implementations there are either sort-of ad-hoc rules for what to do in these cases or errors when they occur?
04:21:01 <dminuoso> Mmm, does optics allow me to "cast" a fold into an affine fold?
04:21:21 <merijn> boxscape: ocaml only ever returns the fields in the type from functions
04:21:31 <merijn> boxscape: So any extra fields get stripped, rather limiting the usefulness
04:21:36 <boxscape> I see
04:21:37 <dminuoso> Oh goodie!
04:21:41 <dminuoso> castOptic :: forall destKind srcKind is s t a b. Is srcKind destKind => Optic srcKind is s t a b -> Optic destKind is s t a b 
04:22:24 <merijn> boxscape: rowtype polymorphism says "well, that's bollocks, we'll just get rid of subtyping and replace it with explicit rowtypes"
04:23:22 <merijn> boxscape: So you get "{ A : int | rho } -> {C : double | rho }" where rho stands for a generic/unknown set of fields (and all the fields before the | must be disjoint from those in rho, to prevent overlap)
04:23:46 <boxscape> so you can't pass in { A : int, C : bool }?
04:23:51 <merijn> boxscape: Right
04:23:53 <boxscape> okay
04:24:09 <boxscape> thank you for the explanation
04:24:14 <merijn> But now things are never ambiguous, because there's no subtyping, just unification
04:24:27 <boxscape> right
04:28:24 * hackage latex-svg-hakyll 0.1 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-svg-hakyll-0.1 (phadej)
04:29:24 * hackage latex-svg-pandoc 0.1, latex-svg-image 0.1 (phadej): https://qbin.io/squad-life-sd45
04:41:41 <kuribas> @hoogle [a] -> Bool
04:41:41 <lambdabot> GHC.List null :: [a] -> Bool
04:41:41 <lambdabot> GHC.OldList null :: [a] -> Bool
04:41:41 <lambdabot> Data.List.Extra notNull :: [a] -> Bool
04:43:04 <acubakari> kuribas: Thanks for your thoughts
05:25:05 <acubakari> :q
05:32:31 <mastarija> when I call a C function through FFI which returns a pointer to a struct (e.g. STRUCT* myfun();) and in Haskell I give the function return value type of "IO HSTRUCT", will Haskell runtime take over that memory management, or do I have to cleanup the thing explicitly?
05:32:58 <mastarija> Once I'm done with the data.
05:33:47 <merijn> mastarija: The ptr you get back needs to be cleaned up manually, *but* you can convert it to a ForeignPtr which is cleaned up on GC
05:34:23 <merijn> mastarija: The Haskell can't automatically take over the memory management, because it doesn't know if/how a random pointer should be cleaned up
05:34:30 <mastarija> Yes, I've seen that. But, my code still works if I do "IO HSTRUCT" instead of "IO (Ptr HSTRUCT)"
05:34:59 <mastarija> So if I do IO HSTRUCT, I still get the data, but no access to the pointer
05:35:12 <mastarija> So I thought It does this automatically.
05:35:18 <merijn> mastarija: I'm confused/surprised that works at all
05:35:24 <mastarija> Yes
05:35:29 <mastarija> me too
05:35:35 <merijn> mastarija: But for details you'd have to check Chapter 8 of the report and the GHC user guide
05:35:39 <merijn> @where report
05:35:39 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:37:04 <mastarija> Also, I'm assuming I can't use "free" from Foreign to do the cleanup, I'd have to export "free" from my C code, right?
05:37:34 <mastarija> merijn, if I'm allocating my memory in C code
05:38:56 <merijn> mastarija: free from Foreign is just "free" from libc, so that should work fine if you're not doing anything weird like using a custom malloc/free
05:39:45 <mastarija> merijn, cool. I thought that free has different memory pointer index or something depending on where it's compiled
06:20:21 <phaazon> I just discovered ghcup
06:20:25 <phaazon> damn guys, congrats
06:20:32 <phaazon> I’ve been waiting for that for years now
06:20:39 <phaazon> and it’s great that it’s based on rustup
06:20:50 <phaazon> which has been one of my favorite aspect of the Rust ecosystem so far
06:20:52 <phaazon> kudos! :)
06:21:23 <ski> merijn : hm, where's that "Heinrich Apfelmus's lazy evaluation guide" ?
06:22:25 <merijn> ski: https://apfelmus.nfshost.com/articles/lazy-eval.html
06:29:25 <ski> ty
06:29:36 <ski> <https://smunix.github.io/hackhands.com/guide-lazy-evaluation-haskell/index.html> is the same thing, it looks like
06:31:34 <merijn> ski: Yes, hackhands went down and the guide disappeared with it
06:32:19 <merijn> ski: The difference is that the other page is by Heinrich and actually renders properly :p
06:32:48 <merijn> ski: Because none of the links on that mirror work for me :p
06:36:58 <ski> ah, i see
06:37:07 <ski> @where lazy
06:37:07 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
06:37:23 <ski> @where+ lazy "Lazy Evaluation of Haskell" by monochrom at <http://www.vex.net/~trebla/haskell/lazy.xhtml>; "The Incomplete Guide to Lazy Evaluation (in Haskell)" by apfelmus in 2015-03-07 at <https://apfelmus.nfshost.com/articles/lazy-eval.html>; "Laziness, strictness, guarded recursion" by bitemyapp at <https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md#user-content-laziness-strictness-guarded-recursion>
06:37:23 <lambdabot> Done.
06:37:38 <ski> does that seem suitable ?
06:43:20 <anoe> Hello, I have a FFI that call a c++ code (with Turtle) and it blocks my GHC threading logic; even if I am using MVar.. Do you have some use case / tutorial to optimize such things please ?
06:45:32 <anoe> (reading it : https://downloads.haskell.org/~ghc/8.4.1/docs/html/users_guide/ffi-chap.html already)
06:49:35 <merijn> anoe: Are you using the threaded runtime?
06:50:56 <anoe> ghc-options used: -threaded -with-rtsopts=-N (started with +RTS -N...)
06:53:31 <anoe> here is the c++ code: https://gitlab.iscpif.fr/gargantext/clustering-louvain/blob/master/src/Data/Graph/Clustering/Louvain/CplusPlus.hs
06:54:33 <anoe> (and I am putting its result in MVar)
07:01:54 * hackage language-ats 1.7.10.0 - Parser and pretty-printer for ATS.  https://hackage.haskell.org/package/language-ats-1.7.10.0 (vmchale)
07:13:54 * hackage Liquorice 0.0.1 - Algorithmic Doom map generation  https://hackage.haskell.org/package/Liquorice-0.0.1 (jmtd)
07:48:20 <fendor> @hoogle a -> Text
07:48:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:48:21 <lambdabot> GHC.Exts unsafeCoerce# :: () => a -> b
07:48:21 <lambdabot> GHC.Prim unsafeCoerce# :: a -> b
07:48:29 <fendor> @hoogle Show a => a -> Text
07:48:30 <lambdabot> Web.HttpApiData showTextData :: Show a => a -> Text
07:48:30 <lambdabot> Web.Internal.HttpApiData showTextData :: Show a => a -> Text
07:48:30 <lambdabot> Web.Internal.HttpApiData showt :: Show a => a -> Text
08:09:54 * hackage prosidyc 0.2.0.0 - A DSL for processing Prosidy documents.  https://hackage.haskell.org/package/prosidyc-0.2.0.0 (jafc)
08:16:18 <aveltras> is there an obvious reason why this doesn't compile ?
08:16:23 <aveltras> https://www.irccloud.com/pastebin/CX2F6URv/
08:18:23 <heatsink> aveltras: It can't infer the type of responseE
08:18:30 <heatsink> Add a type signature
08:19:01 <ski> you'll probably need to enable `ScopedTypeVariables'
08:19:35 <aveltras> adding "responseE :: Event t Response1 <- query $ Request1 "" <$ buildE" doesn't fix it
08:19:46 <aveltras> and ScopedTypeVariables is already on here
08:20:07 <aveltras> the response type should be inferred from the associated type if i understand that thing correctly
08:21:37 <ski> `query' is ambiguous
08:22:21 <ski> from a call to `query' it can't possibly infer what the corresponding `requests' lists is supposed to be
08:22:51 <ski> that's why it's inventing a new type variable `requests0', rather than using  '[Request1, Request2]
08:23:04 <ski> s/lists/list/
08:24:25 <ski> possibly solutions would be (a) add an explicit argument having a type mentioning `requests' (possibly a `Proxy' argument); (b) use `TypeApplications; (c) add an FD (if appropriate) to `HasDataSource'
08:24:37 <heatsink> oh, I see
08:25:11 <ski> (c) is most probably out of the question (that is, not appropriate, since the other parameters (`t',`m') of the type class presumably doesn't functionally determine `requests')
08:25:46 <aveltras> im trying (b) as of now
08:28:06 <ski> you should add explicit `forall' to `query', then
08:28:25 <ski> hm
08:29:17 <aveltras> got i working, im trying to reduce the number of annotations
08:29:19 <aveltras> will report soon
08:29:23 <aveltras> thanks for the help here
08:37:11 <aveltras> seems to be the best i'll get here
08:37:15 <aveltras> https://www.irccloud.com/pastebin/oPt5Cvqi/
08:41:29 <ski> oh, you changed the parameter ordering of `HasDataSource', aveltras
08:41:45 <aveltras> ye, didn't say that sorry
08:42:03 <aveltras> i wasn't understanding why type applications didn't use query type signature as the order of parameters
08:42:15 <aveltras> but seems it uses the typeclass declaration
08:42:58 <ski> yea, i think the tyvars that occur in the `class' heading will be `forall'ed in the order that the parameters occur, in said head
08:43:36 <aveltras> seems so ye
08:43:38 <ski> if you wanted to, you could probably avoid changing the order .. but then you need to refer to `t', and so you need `ScopedTypeVariables'
08:44:15 <aveltras> yes, that's what i did first but i dont want to have to apply two types each time i use this
08:44:53 <aveltras> + forcing forall syntax
08:47:03 <lortabac> aveltras: FYI you can skip type parameters with @_
08:47:27 <ski> (hm, i guess `@_ @AllRequests' would also probably work)
08:47:30 <ski> yea
08:47:38 <aveltras> ye i know this but this adds a lot of noise in the code i think
08:47:47 <lortabac> yes, it's ugly
08:48:02 * ski isn't really fond of `TypeApplications'
08:48:48 <aveltras> what would be the alternative to typeapplications here ? proxys ?
08:48:56 <ski> yea
08:49:31 <aveltras> seems even more noisy to me :)
08:49:33 <ski> or maybe introducing some other part of the type signature that refers to `requests'
08:50:15 <ski> (i'm not sure what the point of `requests', and that `NotInList' equality constraint is)
08:51:39 <aveltras> oh seems you're right
08:51:46 <aveltras> removing it didn't change anything
08:51:57 <ski> what is `t' supposed to be ?
08:51:59 <boxscape> ski given that you don't like them I'm curious what your thoughts are, if any, on the proposed visible dependent quantification, i.e. something like sizeof :: forall a -> Storable a => a (and then callsite: sizeof Int)
08:52:08 <ski> is `t' in fact supposed to determine `requests' ?
08:52:08 <boxscape> s/them/TypeApplications
08:52:38 <ski> that's fine, imho, boxscape
08:52:45 <aveltras> it is some code for reflex frp
08:52:52 <boxscape> ok, I suppose I feel similarly
08:52:52 <aveltras> the t is the timeline
08:53:04 <aveltras> you have it everywhere in the type signatures of reflex code
08:53:34 <aveltras> but seems it isn't needed either here
08:53:46 <ski> the problem with `TypeApplications' is that you're supposed to be able to write type signatures without explicit `forall's, where there is no particular ordering specified for the tyvars .. but now, the ordering that happens to be chosen suddenly matters
08:54:14 <ski> if `TypeApplications' could only be used when the order was explicitly declared, that'd be fine with me
08:54:22 <mastarija> Hey guys, can someone help me understand FFI a bit more?
08:54:31 <mastarija> I have this C and Haskell code: https://pastebin.com/BBS7F09g
08:54:44 <boxscape> right, that makes sense. I think it might be a bit annoying if you couldn't use type applications on anything that doesn't use forall, but it does feel a bit iffy and fragile
08:55:14 <ski> yea, that's what i don't like with it
08:55:39 <mastarija> Problem is, structure that I receive from C in Haskell has wrong pointer address in one of its fields. When I print same function output from C i get "expected" results, but in haskell I always get null pointer.
08:56:15 <ski> also, often i wonder whether it wouldn't be better if the implict parameters were "filled from the right", instead (might even work, considering lack of `ImpredicativeTypes')
08:56:22 <glguy> mastarija: What is a HScreen ?
08:56:32 <geekosaur> mastarija, the screens[1] thing is a C hack
08:56:38 <mastarija> Just a struct with width and height
08:56:42 <mastarija> of a screen
08:56:50 <mastarija> geekosaur, yes
08:56:56 <geekosaur> you do not have a Ptr CHScreen there, you have an inline array of such screens following the struct
08:57:16 <mastarija> does it matter?
08:57:21 <geekosaur> very much, yes
08:57:29 <boxscape> ski yeah that actually does sound useful if you have dependencies in your type variables
08:57:35 <geekosaur> FFI is dereferencing something in the first Screen to get that Ptr for you]
08:57:45 <geekosaur> instead of using the address of the first Screen
08:58:29 <mastarija> I thought that type field[1] is the same as type* field.
08:58:34 <glguy> it's not
08:58:36 <geekosaur> it's not
08:58:38 <glguy> ^
08:58:48 <mastarija> So, how would one deal with this in FFI?
08:58:57 <mastarija> Because it's quite common pattern.
08:59:01 <mastarija> "Hack"
08:59:04 <glguy> mastarija: You're probably thinking of a function parameter of that type where the array decays into a pointer
08:59:10 <glguy> but that's not how the types work anywhere else
09:00:15 <mastarija> glguy: any advice on how to deal with this? Win32 api is full of this approach.
09:00:41 <mastarija> glguy: is using intermediate data structures the only way?
09:01:01 <glguy> mastarija: You can use #ptr struct_type, field  -- to get the pointer to that array
09:01:03 <ski> (hm, is `sizeOf' and `alignment' supposed to ignore their input ?)
09:01:16 <glguy> and then http://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Array.html#v:peekArray
09:01:20 <boxscape> ski yes afaik
09:01:24 <glguy> using the cnt field and that pointer
09:01:33 <glguy> Yes, sizeOf and alignment must ignore their arguments
09:01:40 <glguy> This type isn't eligible to be an instance of Storable
09:02:28 <geekosaur> yes, they're of the "pass undefined, since all that matters is the type" variety which is why Proxy and more recently TypeApplications exist these days
09:02:38 <geekosaur> say hi to haskell98 as you drive by :)
09:02:48 <boxscape> can you not use Proxy in Haskell98?
09:02:53 <glguy> The Proxy pattern worked in old Haskell
09:02:59 <boxscape> okay
09:03:06 <glguy> I just didn't occur to anyone to do it
09:03:08 <geekosaur> hm, guess it did but nobody had come up with it yet
09:03:17 <boxscape> though of course now we have polykinded Proxy
09:03:42 * ski . o O ( s/polykinded/polymorphic/ )
09:04:23 <boxscape> I would have assumed that polymorphic..ity? is more or less a superset of polykindedness
09:04:36 <boxscape> oh
09:04:40 <boxscape> polymorphism
09:04:41 <boxscape> of course
09:05:49 <ski> @kind Proxy
09:05:50 <lambdabot> k -> *
09:05:59 <geekosaur> mm, I think you can Storable this type but you have to do more work in both directions and the Haskell representation will not directly mirror the C one, which some uses of Storable (e.g. Storable vectors) will expect. but for FFI uses it'd work
09:06:36 <ski> mm, you'll have to indirect the array
09:07:17 <glguy> geekosaur: Storable expects fixed sized stuff
09:07:59 <geekosaur> mm, true, sizeof can't look at the value
09:08:03 * ski doesn't know what "polykinded" is supposed to mean
09:08:36 <geekosaur> you need a translation layer to deal with this kind of C ickery
09:09:22 <ski> i thought geekosaur meant converting between `struct { int cnt; HScreen screens[1]; }' and (basically) `struct { int cnt; HScreen *screens; }', on the Haskell side
09:09:37 <geekosaur> more or less, but there's still the sizeof issue
09:09:40 <boxscape> ski hm I suppose maybe I took the -XPolyKinds extension name too literally
09:09:52 <geekosaur> sizeof isn't a constant determined solely by the type
09:09:57 <ski> boxscape : imho, it's a misnomer
09:09:59 <geekosaur> it depends on numScreens
09:10:28 <ski> isn't it just `sizeof int + sizeof (HScreen *)' ?
09:10:32 <geekosaur> btu sizeof can't inspect its parameter to see what numScreens is
09:11:05 <geekosaur> not on the C end, it's sizeof numScreens + numScreens * sizeof HScreen
09:11:32 <geekosaur> (plus any extra alignment…)
09:12:09 <ski> oh right. was confused a bit about which size we were talking about, i suppose
09:12:32 * ski . o O ( `struct { int cnt; HScreen screens[cnt]; }' )
09:14:39 <boxscape> ski for what it's worth, the user's guide does contain the phrase "Polykinded type families" (in this section https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#type-family-declarations )
09:15:12 <ski> i know
09:15:25 <Zemyla> Okay, so how many other instances of how different dictionaries can accomplish the same task can you think of, besides things like nub with Eq, Ord, or Hashable?
09:16:42 <ski> (i just think it's bad, similarly to how refering to `Maybe', or `forall a. a -> a', as "polymorphic types" is bad (confusing, inconsistent))
09:17:05 <nshepperd> the meaning of polykinded seems pretty straightforward to me
09:17:21 <nshepperd> somethihng that can be used at different kinds
09:17:25 <ski> then what would, by analogy, "polytyped" mean ?
09:18:04 <boxscape> ah right so Proxy has a polymorphic type, whereas Maybe is a type with polymorphic data constructors, yea?
09:18:09 <nshepperd> something that can be used at different types
09:18:17 <ski> (why haven't we seen the term "poytyped" being used ?)
09:18:26 <ski> (s/poy/poly/)
09:18:34 <Zemyla> Also, why isn't there a boxed version of Identity? I can think of several uses for it.
09:18:42 <boxscape> or rather
09:18:50 <boxscape> proxy *is* a polymorphic type
09:18:54 <boxscape> s/p/P
09:18:54 <ski> boxscape : "Proxy has a polymorphic type" -- no. `Proxy' is polymorphic itself
09:18:58 <boxscape> right
09:18:59 <mastarija> Ok, now it works. Thanks guys.
09:19:22 <ski> `Maybe' is a parameterized (`data') type, aka a type function
09:19:49 <ski> (not all type functions are parameterized `data' types. e.g. type families)
09:20:32 <boxscape> so parameterized `data' types are matchable (generative + injective) type functions?
09:20:50 <boxscape> s/are/are exactly
09:20:51 <ski> because `data' types in general are matchable, yes
09:20:56 <boxscape> okay
09:21:47 <boxscape> Zemyla https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Tuple.html#t:Unit
09:22:24 * hackage lzlib 1.0.4.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-1.0.4.0 (vmchale)
09:22:30 <ski> well, i guess i probably wouldn't refer to a `data' family itself as a `data' type (a particular use of it, with particular parameters, would be)
09:23:30 <boxscape> Wow Unit has 0 instances that I can find
09:23:42 <pdxleif> Does running cabal new-build with different --ghc-options= flags passed cause a rebuild of the libs in .store/ ?
09:24:25 <pdxleif> When I run "ghcid", it runs "cabal repl" with a bunch of ghc-options, and it seems to rebuild the universe, before failing on /usr/bin/ar: dist/build/Data/Orphans.o: No such file or directory
09:26:08 <ski> > case (# () #) of (# u #) -> u
09:26:11 <lambdabot>  ()
09:26:16 <mastarija> man, I spoke too soon.
09:26:40 <mastarija> Now I get access violation when I attempt to read data form that array pointer
09:27:05 <mastarija> With peekArray
09:27:18 <pdxleif> Yeah, seems like just passing --ghc-options=-fno-code to cabal repl causes it to rebuild all the deps in store/
09:28:35 <mastarija> Can anyone take a look and tell me where I'm wrong? I'm using #ptr on line 76
09:28:39 <mastarija> https://pastebin.com/Zj4nkz9S
09:29:00 <mastarija> And when I call enumScreens I get access violation error
09:29:31 <glguy> mastarija: don't peek that pointer
09:29:55 <mastarija> when I just use #ptr I get type error
09:30:04 <glguy> And don't make a Storable instance for the list type, it won't make sense to poke one and it doesn't have a fixed size
09:30:38 <glguy> That means you shouldn't have used <-, not that you should toss in a peek
09:34:04 <mastarija> glguy, so instead of defining Storable for ScreenList, I should use #peek and #ptr directly in my enumScreens function?
09:36:40 <ski> i suppose you could write your own `peekCHScreenList :: Ptr CHScreenList -> IO CHScreenList'
09:36:47 <welco> is it possible to compare random numbers?
09:36:57 <welco> without monads
09:37:14 <mastarija> if you use unsafeIO
09:37:24 <ski> how do you mean, compare random numbers ?
09:37:28 <ChaiTRex> You can provide a seed and do it without even IO.
09:37:46 <ski> a number isn't random. a number may be drawn from a random source
09:38:07 <welco> I am making a function that decides which dice rolls are larger
09:38:23 <welco> so I need to be able to use ordering operations
09:38:31 <ski> so you need to get at some randomly drawn numbers, then
09:38:43 <ski> just use the ordinary ordering operations on numbers
09:39:08 <welco> right but the numbers I am producing are IO Int's
09:39:20 <welco> which I believe I cannot use ordering operations on
09:39:43 <ChaiTRex> welco: IO Int means a procedure that produces an Int.
09:39:57 <ChaiTRex> welco: It's not an actual number, it's something that can produce a number.
09:40:31 <ChaiTRex> welco: For example, using it twice might produce two different numbers.
09:40:39 <ski> you could (a) pass in the randomly drawn numbers that you need, generating them elsewhere; or (b) you could pass in (and possibly also return) a random bits state generator thing; or (c) you could use `IO' to (e.g.) refer to the global random bits generator that it keeps track of
09:40:43 <pdxleif> Ah, guess it's a cabal issue: https://github.com/haskell/cabal/issues/3883
09:40:55 <ski> welco : values of type `IO Int' are not numbers
09:41:17 <ski> @quote recipe.is.not
09:41:17 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
09:41:48 <welco> https://pastebin.com/jscRCmAA 
09:42:28 <ski> `diceRoll' is not a number. it's an action that, when executed, will produce a randomly drawn number
09:43:11 <ski> welco : are you sure you want to pass in two `IO Int's there, rather than simply `Int's (being the results of executing the former actions) ?
09:43:31 <ski> welco : how is `playGame' supposed to be called ?
09:44:04 <welco> I did not think I would be able to pass in an Int because dice roll produces an IO Int
09:44:15 <ski> if you write
09:44:23 <welco> but I see what your saying now I am just implementing incorrectly
09:44:27 <ski>   main = do m <- diceRoll
09:44:32 <ski>             n <- diceRoll
09:44:46 <ChaiTRex> welco: diceRoll is a bad name for it. rollDice is a better name for it, since it's an action rather than a number.
09:44:49 <mastarija> glguy: thanks for the help, got it finally :D
09:44:57 <ski>             print (playGame t u m n)
09:45:17 <ski> then you're passing two `Int's, `m' and `n', to `playGame'. not passing `IO Int's
09:45:38 <ski> ChaiTRex : matter of perspective, convention, taste
09:45:38 <welco> Ok I see now thank you
09:46:06 <ski> (`diceRoll' could refer to the action of making a dice roll)
09:46:52 <ski> welco : only pass `IO Int's if you want the same `playGame' call to be able to use `s1' and `s2' multiple times, possibly getting a different number from them, each time
09:47:25 <ski> if you only want to pass two numbers (being results of just two die rolls), then just pass two `Int's
09:47:52 <ski> najs, mastarija
09:48:26 <ski> welco : also, fwiw, it's traditional to add a space after the `|' symbol in a guard
09:49:14 <mastarija> :D
09:49:23 <welco> ski: thanks I love syntax tips honestly cause I can be obsessive about my code looking pretty haha
09:49:58 <welco> which makes Haskell a great language for me
09:54:32 <ski> welco : usually, you only use `IO' (or any other idiom, or monad) in the return type. using it in an argument type means that you're doing something like a callback. e.g. `forkIO :: IO () -> IO ThreadId' needs to take an action as input, which is not executed yet, in order to spawn another thread which executes it
09:54:46 <ski> oh, they left
09:55:54 * hackage checkers 0.5.4 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.5.4 (ConalElliott)
10:14:24 * hackage org-mode-lucid 1.0.1 -   https://hackage.haskell.org/package/org-mode-lucid-1.0.1 (fosskers)
10:20:34 <exarkun> do warp timeouts really work as described on https://hackage.haskell.org/package/warp-3.0.9/docs/Network-Wai-Handler-Warp-Timeout.html
10:20:50 <exarkun> I seem to have requests timed out either during application code handling them or while writing out the response
10:21:03 <hololeap> i'm trying to understand when it is usually a good idea to use bang patterns. for instance, i see them in the (:&) constructor here: https://hackage.haskell.org/package/vinyl-0.12.1/docs/Data-Vinyl-Core.html#t:Rec
10:25:49 <jle`> hololeap: btw those aren't actually bang patterns, they are strict fields
10:26:02 <jle`> even though they share syntax
10:26:08 <jle`> kinda
10:26:48 <jle`> but if you're asking about strict fields, then *usually* the general situation for data types is that you want your 'cells' to be strict and your 'spine' to be lazy
10:27:13 <jle`> that's a rule of thumb, but there are exceptions based on how you plan to use those data types
10:28:05 <jle`> in the case of Rec both the cells/data and the spine are strict
10:28:16 <jle`> because they're meant to be used all at once
10:28:46 <jle`> Rec is a bit of an exception because ideally we'd want just one giant flat rec, instead of a clunkly linked list
10:33:11 <hololeap> ok. i'm not that familiar with vinyl or how Rec is actually used.
10:33:48 <jle`> but uuuusually if your data type is used for storing data fields, you'd want those fields to be strict
10:34:29 <jle`> and recursive fields (the spine of a linked chain) are usually lazy, unless you want to disallow infinite chains or want to treat it as a flat structure
10:34:57 <dminuoso> mmm, sad that optics doesnt have gpreview :(
10:35:45 <hololeap> gotcha. so they want Rec to be a flat structure and not something that is consumed lazily
10:46:20 <justsomeguy> How can I install the test runner for QuickCheck? I did "stack install QuickCheck", and then tried "stack exec -- quickCheck $file", but the binary doesn't seem to exist.
10:47:04 <justsomeguy> stack says "Executable named QuickCheck not found on path: .... "
10:47:14 <justsomeguy> or quickCheck, rather.
10:48:24 * hackage headroom 0.1.2.0 - License Header Manager  https://hackage.haskell.org/package/headroom-0.1.2.0 (xwinus)
10:54:11 <jle`> hololeap: yup, exactly
10:54:30 <jle`> hololeap: there's actually a flat version of Rec, ARec, that is better for consumption
10:54:35 <jle`> but Rec itself is easier to build
10:55:11 <jle`> so the common usage pattern is to build a Rec and convert it to an ARec when you want to start actually accessing/reading it a lot
10:56:14 <boxscape> https://hackage.haskell.org/package/vinyl-0.12.1/docs/Data-Vinyl-ARec.html
10:58:42 <jle`> yeah, lists vs. vector is a good analogy :)
10:59:09 <jle`> Rec is even more useless than lists (in a laziness sense) because list is inherently not-so-great for storing data
10:59:14 <jle`> and the main purpose of Rec is to store data
10:59:35 <jle`> hm, so maybe the better analogy is Data.Sequence vs. Data.Vector
11:00:54 <geekosaur> justsomeguy, quickCheck is a library, not a program
11:01:09 <geekosaur> er, QuickCheck
11:15:05 <hololeap> oh, ARec is literally a wrapper around Array
11:16:04 <hololeap> what is this Any type i'm seeing?
11:16:26 <hololeap> it sounds like it is a way to lose type-safety
11:17:34 <hololeap> but i guess ARec stores that type info in its second parameter
11:17:52 <hololeap> that's a cool trick and i've wondered how to do that in the past
11:18:10 <geekosaur> it's used when ghc can't assign a type to something usually because it's polymorphic but ghc needs a type there
11:18:51 <hololeap> yeah that's a problem i've run into before
11:18:55 <boxscape> hololeap you don't really lose type safety I think - they have to use unsafeCoerce to actually construct an ARec
11:19:27 <boxscape> *that's* where the type safety gets lost
11:20:06 <boxscape> (though of course they add it back in from the point of view of a user of vinyl)
11:20:38 <jle`> hololeap: any is like Dynamic without Typeable
11:20:41 <jle`> if you're familiar with Dynamic
11:20:45 <hololeap> right... if they didn't keep that type-level list around then it would just be an Array of who-knows-what
11:21:27 <jle`> > [toDyn True, toDyn "hello", toDyn 6]
11:21:29 <lambdabot>  [<<Bool>>,<<[Char]>>,<<Integer>>]
11:21:33 <jle`> :t [toDyn True, toDyn "hello", toDyn 6]
11:21:34 <lambdabot> [Dynamic]
11:22:49 <hololeap> i'm a bit confused though, the docs say Any is a type constructor but it clearly says `type family Any`
11:23:12 <jle`> tis a lie
11:23:15 <geekosaur> I think its internally implemented as a magic type family?
11:23:38 <hololeap> yeah this is obviously some low-level GHC magic
11:23:44 <jle`> it's basicallt data Any = forall a. Ay a
11:23:47 <jle`> er
11:23:49 <jle`> newtyle Any = forall a. Any a
11:23:52 <jle`> except newtypes aren't allowed
11:24:40 <jle`> er, except existential types aren't allowed in newtypes
11:24:44 <jle`> so it has to be magic, i guess
11:25:06 <boxscape> wasn't the magic taken away
11:25:11 <boxscape> hold on I looked at the issue yesterday
11:25:32 <hololeap> it's still there, if you believe
11:25:52 <jle`> i don't think there is any non-magic way to implement it
11:26:13 <jle`> my naive idea would be data Any = Any, but then you can lose references due to sharing
11:26:15 <jle`> hm
11:26:17 <boxscape> https://gitlab.haskell.org/ghc/ghc/issues/10886
11:26:19 <jle`> maybe i just haven't thought hard enough
11:26:42 <boxscape> with song lyrics written by nomeata
11:27:06 <jle`> ah hm, is that enough to define it? a stuck type family?
11:27:10 <jle`> that's neat
11:27:32 <jle`> simon mentions some magic necessary still
11:28:47 <boxscape> ah, yeah, knownKeyNames
11:29:36 <boxscape> see also Note [Any types] here https://downloads.haskell.org/~ghc/8.8.1/docs/html/libraries/ghc-8.8.1/src/TysWiredIn.html#anyTy
11:30:05 <boxscape> (not wrt knownKeyNames but wrt Any in general)
11:31:00 <boxscape> I'm a bit confused about how it can be a wired-in type and an empty closed type family at the same time
11:31:07 <hololeap> why do these eggheads have to take the magic out of everything?
11:31:26 <int-e> Because magic is bad.
11:32:19 <jle`> stuck type families scare me in general
11:32:32 <jle`> it's like, how
11:32:41 <boxscape> I guess the point behind the constrained type family paper is to make them less scary
11:34:12 <jle`> % type family AKnee :: k where {}
11:34:12 <yahb> jle`: type family AKnee :: k
11:34:37 <jle`> % let x :: AKnee; x = unsafeCoerce True
11:34:37 <yahb> jle`: x :: AKnee
11:34:45 <randomconfuse> https://pastebin.com/TLHMMsNp    I understand that the issue here is that this function is not pure as I can get different results with the same arguments but I just can't wrap my head around how I would be able to implement something similar
11:34:45 <jle`> % unsafeCoerce x :: Bool
11:34:45 <yahb> jle`: True; it :: Bool
11:34:52 <jle`> huh.
11:34:56 <jle`> i guess it works without magic
11:35:23 <jle`> randomconfuse: looks mostly good
11:35:32 <jle`> randomconfuse: except return (.. , ...) instead of (.. , ...)
11:35:43 <jle`> randomconfuse: and you return IO (Team, Team), not (Team, Team)
11:36:05 <randomconfuse> wow thats great news I thought I wasn't even close
11:36:08 <glguy> Also I'd like to add that this game doesn't look very fun
11:36:32 <randomconfuse> glguy: HEY!
11:36:32 <jle`> oh, randscore should probably be something like randomR (1,6) <$> getStdRandom, although i can't remember if getStdRandom updates the generator or not
11:36:40 <jle`> i would say randScore = randomRIO (1,6)
11:36:43 <boxscape> % type family AKnee' :: (k :: TYPE r) where
11:36:43 <yahb> boxscape: ; <interactive>:311:23: error:; * Expected a type, but `(k :: TYPE r)' has kind `TYPE r'; * In the kind `(k :: TYPE r)'
11:36:43 <glguy> No, basically never use getStdGen
11:36:44 <hyperisco> I call team 1
11:36:45 <boxscape> :(
11:37:06 <glguy> For this case just use: randomRIO
11:37:36 <glguy> Oh, and getStdRandom is the OK one (but don't use getStdGen)
11:37:48 <boxscape> can type families in general not return unlifted types or am I miking up my type and kind levels somehow?
11:38:27 <jle`> boxscape: what do you think the kind of an unlifted type is?
11:38:45 <jle`> not a rhetorical question, i'm curious
11:38:46 <glguy> Type families can return unlifted types if you have the appropriate kind on your family
11:38:47 <boxscape> anything other than TYPE LiftedRep?
11:39:09 <glguy> type family T where T = Int# -- T :: TYPE 'IntRep
11:39:11 <boxscape> (s/miking/mixing)
11:39:12 <jle`> boxscape: so it sounds like you want AKnee' :: Type k
11:39:24 <jle`> er AKnee' :: TYPE r
11:39:26 <boxscape> oh, right
11:39:31 <hololeap> randomconfuse: you could keep playGame pure and use liftA2 when you need to get random values
11:39:59 <boxscape> % type family AKnee' = (k :: TYPE r) where
11:39:59 <yahb> boxscape: type family AKnee' :: TYPE r = k
11:40:04 <jle`> randomconfuse: yeah, the 'pure' design of this would be to write a Int -> Int -> (Team, Team) function to encapsulate your logic. the impure part would just be the plumbing
11:40:37 <jle`> randomconfuse: playGamePure s1 s2 = (giveWin t1, giveWin t2)
11:40:48 <jle`> er i did that wrong
11:40:55 <glguy> type family T :: TYPE k where T = Int#
11:40:58 <jle`> Team -> Team -> Int -> Int -> (Team, Team)
11:41:09 <jle`> playGamePure t1 t2 s1 s2 = (.., ..)
11:41:58 <glguy> You can have this: type family T (a :: TYPE j) :: TYPE k where T Int = Int#; T Bool = Char
11:42:10 <glguy> You won't be able to do a lot with it when you don't know what it's applied to, however
11:42:20 <boxscape> I see
11:44:52 <randomconfuse> jle`:ya I just switched to an unpure version because the pure version forces me to have to do stuff in main that I struggled with implementing. 
11:45:11 <aveltras> how can i get from a set of requests types to a set of request handlers at the type level ? with the following
11:45:15 <aveltras> https://www.irccloud.com/pastebin/lvUIBYAK/
11:46:00 <aveltras> i guess it's by using a type family but i dont know how to do it
11:46:20 <boxscape> % 4# :: GHC.Exts.Any
11:46:20 <yahb> boxscape: ; <interactive>:325:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; GHC.Exts.Any :: Type; Int# :: TYPE 'GHC.Exts.IntRep; * In the expression: 4# :: GHC.Exts.Any; In an equation for `it': it = 4# :: GHC.Exts.Any
11:46:26 <boxscape> is it defaulting the kind of Any to Type here?
11:46:45 <boxscape> (I don't expect this to work but I'm confused by the error message)
11:47:57 <boxscape> or wait - I suppose the type of expressions entered in ghci must have kind Type, and that's why
11:48:37 <ystael> bad_trotsky: those bar size jolly ranchers are an excellent way to remove any and all dental work
11:49:03 <boxscape> % undefined (4# :: GHC.Exts.Any) -- except that if that were the only explanation I think this should have a different error message...
11:49:03 <yahb> boxscape: ; <interactive>:331:12: error:; * Couldn't match a lifted type with an unlifted type; When matching types; GHC.Exts.Any :: Type; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `undefined', namely `(4# :: GHC.Exts.Any)'; In the expression: undefined (4# :: GHC.Exts.Any); In an equation for `it': it = undefined (4# :: GHC.Exts.Any)
11:49:32 <boxscape> (since undefined can take arguments of unlifted types)
11:49:43 <ystael> bleh wrong channel, apologies
11:50:29 <glguy> boxscape: The type constructor Any is type to which you can unsafely coerce any lifted type, and back.
11:51:17 <iphy> https://ci.appveyor.com/project/iphydf/hs-msgpack-rpc/builds/31301484#L927 how are you supposed to install happy, if happy needs happy?
11:52:13 <boxscape> glguy okay, but I don't think the safety necessarily plays a role here - after all, Any is polymorphic and can have any kind, but in the error message it's specifically Type
11:52:47 <glguy> Any isn't a type you can just ascribe to an arbitrary value
11:52:49 <boxscape> % :k (GHC.Exts.Any :: TYPE GHC.Exts.IntRep)
11:52:49 <yahb> boxscape: (GHC.Exts.Any :: TYPE GHC.Exts.IntRep) :: TYPE 'GHC.Exts.IntRep
11:52:59 <boxscape> glguy right, and I don't expect to be able to do that
11:53:13 <boxscape> glguy I'm just confused by why I'm getting this particular error message rather than something else
11:54:51 <boxscape> I would expect maybe "Couldn't match type Any with Int#"
11:55:01 <ski> hm, i'm not fond of `Any'
11:55:07 <glguy> boxscape: If you write :t 3# :: (GHC.Exts.Any :: TYPE GHC.Exts.IntRep)
11:55:13 <glguy> you get: Couldn't match expected type ‘Any @(TYPE 'IntRep)’                  with actual type ‘Int#’
11:55:25 <ski> imho, GHC should do either what SML/NJ does, or what OCaml does
11:55:31 <boxscape> glguy ah, I see. So ghc defaults to Type?
11:57:09 <ski> it ought to use a "different version of" `Any', for each different tyvar it has to conjure up
11:58:24 <ski> in SML/NJ, it generates a fresh skolem (looks like an abstract data type, about which nothing is known, defined in an unknown module, written `?' in the interactor) which is only known to be equal to itself
11:58:58 <ski> otoh, in OCaml, it generates a (fresh) free meta variable, which can later be instantiated to some particular type
12:00:59 <ski>   # let mono_id = (fun id -> id) (fun x -> x);;
12:01:06 <ski>   val mono_id : '_weak1 -> '_weak1 = <fun>
12:01:13 <ski>   # mono_id 42;;
12:01:20 <ski>   - : int = 42
12:01:24 * hackage org-mode 1.0.1 -   https://hackage.haskell.org/package/org-mode-1.0.1 (fosskers)
12:01:26 <ski>   # mono_id;;
12:01:33 <ski>   - : int -> int = <fun>
12:02:05 <ski> so, after the fact, the signature of  mono_id  has been "back-patched", by instantiating the meta-variable  '_weak1  to  int
12:04:03 <ski> (the reason it doesn't generalize, making it polymorphic, is something called the "value restriction" (slightly reminicent of DMR). basically, if you don't restrict interaction of polymorphism and some kinds of side-effects, you get an unsound type system (in Haskell, you can do the same, implementing `unsafeCoerce', by means of `unsafePerformIO'))
12:20:54 * hackage dobutokO2 0.3.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.3.0.0 (OleksandrZhabenko)
12:28:50 <aveltras> is it possible to write a type family with a specific typeclass constraint ?
12:30:49 <hololeap> randomconfuse: here's a way to keep it pure until you need the StdGen:  http://dpaste.com/235ECSE
12:31:24 * hackage dobutokO2 0.3.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.3.1.0 (OleksandrZhabenko)
12:32:14 <ski> did you mean to use `newStdGen', rather than `getStdGen', hololeap ?
12:33:02 <hololeap> ski: it wasn't clear to me from the docs which one was appropriate here
12:36:33 <hololeap> ok i guess getStdGen always has the same value, so, it's not very random :)
12:36:48 <hololeap> randomconfuse: use newStdGen instead
12:37:24 * hackage dobutokO2 0.3.1.1 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.3.1.1 (OleksandrZhabenko)
12:39:24 <ski> <jle`> oh, randscore should probably be something like randomR (1,6) <$> getStdRandom, although i can't remember if getStdRandom updates the generator or not
12:39:31 <ski> <glguy> No, basically never use getStdGen
12:39:37 <ski> <glguy> Oh, and getStdRandom is the OK one (but don't use getStdGen)
12:39:42 <ski> hololeap ^
12:55:07 <maerwald> sometimes haskell feels as verbose as C. Instead of doing memory management, you do type management and convert stuff back and forth without actually doing anything
12:57:10 <zincy__> Do you not always have to do type management regardless of the language?
12:57:30 <maerwald> No
12:57:47 <zincy__> You kinda do :P
12:57:58 <maerwald> You do everything in every language
12:58:25 <zincy__> Not sure I follow
12:59:02 <maerwald> You do memory management in haskell too. That doesn't mean it compares to memory management in C. That's besides the point.
12:59:51 <maerwald> In go I don't convert between different URI representations, do lenses on them, pull out parts, put them back together, parse them as bytestring, because some functions need this, some that, and this other library uses Text
13:05:22 <[exa]> maerwald: perhaps it needs a standard? (btw ever tried to handle URLs in c++?)
13:22:10 <random32> https://pastebin.com/vVWB5R1p
13:23:43 <geekosaur> ghci will run an IO action and show its result. but this only works at the top level, i.e. IO <something>, not a list of IO actions
13:24:15 <geekosaur> note that this is not actually showing the IO action, it is *performing* the action in order to get something to show
13:24:53 <ski> there is no `Show' instance for `IO'-actions
13:24:59 <ski> > getLine
13:25:01 <lambdabot>  <IO [Char]>
13:25:18 <random32> is it possible for me to see the entire list?
13:25:20 <geekosaur> you could use sequence to turn the list of IO actions into an IO action over a list of the results of those actions, and probably you want something similar to that instead of a list of IO actions
13:25:23 <ski> (that's just a hacky one that was added to lambdabot ;9
13:25:25 <ski> )
13:25:42 <ski>   sequence :: [IO a] -> IO [a]
13:26:03 <geekosaur> that said, is there an end condition for this or is the list infinite? because the result of that would be a never-ending IO action
13:26:43 <geekosaur> …right, that just continues forever, that's not going to sequence well
13:27:01 <ski>   zipWithM :: (a -> b -> IO c) -> ([a] -> [b] -> IO [c])
13:27:57 <ski>   mapM :: (a -> IO b) -> ([a] -> IO [b])  -- in case you just had one input list
13:28:42 <ski> i see no infinite list, geekosaur ?
13:29:05 <random32> I didn't think to use something like zipWithM that makes a lot more sense than what Im trying to do
13:29:19 <geekosaur> oh, missed it had parameters, sorry. that should reasonably work then
13:29:35 * geekosaur is squeezed for time and trying to do too much :(
13:30:01 <ski> also, if your two lists have the same length, perhaps it's be nicer to pass a single list, of type `[(Team,Team)]', then ?
13:30:06 <ski> (and then you could use `mapM')
13:30:31 <ski> (if they don't have to have the same length, then you're missing cases in `theFunc')
13:30:39 <geekosaur> the rest of my day is about to be taken away from me
13:30:59 <random32> fortunately for what im trying to do I will always have equal length lists
13:30:59 <ski> oh :(
13:31:18 <ski> do you get the two lists from different sources, random32 ?
13:31:31 <ski> otherwise, i would consider having just a single list, of pairs
13:32:50 <random32> well the grand plan here is to make an MLB season simulation and my idea is to have divisions play each other (divisions are all the same length). So I am trying to have the teams play each other over and over until they have played 162 games.
13:34:15 <random32> so I need a function that lets divisions play each other than spit out lists of the divisions again with updated wins and losses
13:37:15 <ski> mhm
13:48:29 <random32> am I even on the right track here or am I attacking the problem inccorrectly?
13:52:51 <ski> well, i don't really understand how such division plays work, random32
13:53:28 <ski> (e.g., why `162' games ? and what does "divisions play each other than spit out lists of the divisions again with updated wins and losses" mean ?)
13:54:38 <ysangkok> 19 games × 4 opponents within same division (76 games), 6 games x 4 opponents and 7 games x 6 opponents interdivision within same league (66 games), 20 interleague games
13:54:44 <ysangkok> according to https://en.wikipedia.org/wiki/Major_League_Baseball_schedule
13:55:10 <zincy__> "You do memory management in haskell too. That doesn't mean it compares to memory management in C. That's besides the point."
13:55:10 <maerwald> brittany does some weird stuff in multiway if and guards: https://git.io/JvwXZ and https://git.io/JvwXW
13:55:24 <zincy__> Is that true?
13:55:53 <ysangkok> depends how you define memory, i'd say :P haskell definitely has scoping :P
13:56:00 <maerwald> the second one might be intentional, the first one definitely not
13:56:07 <zincy__> Or how you define manage
13:56:08 <maerwald> zincy__: yes
13:56:29 <zincy__> maerwald: I guess you influence it in an indirect way
13:56:50 <zincy__> So yeah I guess I agree
13:56:55 <ysangkok> i thought it is really neat how in Haskell's FFI, you pass a function to the allocator, and the allocator calls you back with your piece of memory
13:57:03 <ysangkok> in that way, scoping becomes malloc/free. neat!
13:58:06 <zincy__> Isn't the Haskell runtime written in C
13:58:49 <zincy__> And the runtime manages memory for you.
13:59:50 <tdammers> yes, but the compiler also exposes primitives that allow you to influence or even completely bypass the RTS's normal memory management
14:00:30 <zincy__> Yeah I remember hearing something about pointers in Haskell
14:01:02 <tdammers> but I would say that as long as you write "normal" run-of-the-mill Haskell, memory allocation is sufficiently abstracted over, and saying that you "do memory management in Haskell" is a bit of a stretch
14:01:17 <tdammers> it's technically correct - *something* manages that memory, and you control that "something"
14:01:38 <zincy__> Yeah
14:01:42 <maerwald> Yes, the point was that it's as much of a stretch as saying you do similarly heavy type management in non-haskell languages
14:02:03 <tdammers> except the other way around
14:02:35 <zincy__> How can there be such a thing as "type management"
14:02:44 <zincy__> types just *are* aren't they?
14:02:49 <tdammers> type inference, type checking, I would wager
14:02:49 <maerwald> What?
14:02:58 <maerwald> Also converting between types
14:03:14 <tdammers> which is something you have to do in your head when there's no compiler and language support to automate it
14:03:26 <tdammers> (and people usually do it rather informally, and make lots of mistakes)
14:03:41 <zincy__> tdammers: exactly
14:03:54 <tdammers> I still don't think the comparison holds up very well
14:04:00 <zincy__> Types existed before computers
14:04:29 <maerwald> I've used probably all the uri libraries and in the end I find all of them useless, except for extracting *specific* things from a uri, not using that type anywehre in an API
14:04:34 <tdammers> Haskell abstracts over memory allocations, so you don't have to think about those, you can think in higher-level terms such as equivalencies and expressions and values and such
14:04:44 <maerwald> Which can be served by just functions
14:05:14 <tdammers> but an untyped language doesn't abstract over types so that you can reason about them in higher-level terms
14:07:07 <zincy__> right you are lacking the building blocks structuring your code
14:07:18 <zincy__> in an untyped language
14:08:44 <random32> ski: https://pastebin.com/skirCYZf
14:09:13 <random32> original question https://pastebin.com/vVWB5R1p
14:09:19 <ysangkok> zincy__: when you say types, what do you mean? when you say types, i think martin-löf
14:09:20 <zincy__> The difference between memory management and what you are referring to "type management" is this ...  you cannot outsource the management of your types like you can with memory management. It just doesnt make sense
14:09:58 <maerwald> zincy__: why would you lack building blocks structuring your code?
14:10:12 <zincy__> Sorry I phrased that poorlly
14:10:12 <maerwald> have you used weakly typed languages heavily?
14:10:27 <zincy__> Javascript
14:10:27 <maerwald> Structuring code has little to do with types
14:10:38 <zincy__> Yeah I mispoke :)
14:10:40 <maerwald> It is about making decisions of scope of functions etc
14:11:13 <ysangkok> zincy__: i am waiting for you to explain what you mean by "Types existed before computers" :)
14:11:19 <zincy__> When I said structuring I was really talking about building abstractions from types
14:11:29 <maerwald> That is rarely structure
14:17:24 <ski> random32 : hm, you said "I want to be returned two new lists that contain the same teams in them but with updated wins and losses." but "So in this case we get redTeam vs birdTeam, blueTeam vs catTeam, greenTeam vs gorillaTeam." sounds like just one list ?
14:21:54 * hackage aeson-value-parser 0.17.1 - API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.17.1 (NikitaVolkov)
14:22:58 <random32> ski: I was unclear. When I say, "So in this case we get redTeam vs birdTeam, blueTeam vs catTeam, greenTeam vs gorillaTeam." I meant that when I run the two lists together these are the only "games" being played, I wanted to make it clear I did not need 9 games to be played from a function call (3*3). In the end I want two lists to be returned
14:22:58 <random32> because I always want the lists of division to have the same teams in them but because of immutability I need to produce new lists with updated fields. 
14:23:52 <ski> oh, so you want to produce new versions of the two lists
14:23:57 <random32> exactly
14:24:20 <ski> ah, i see, that's why `playGame' gives back two `Team's, namely the updated versions
14:24:41 <random32> right!
14:26:54 <ski> @type zipWithM
14:26:56 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:27:01 <ski> @type mapAndUnzipM
14:27:02 <lambdabot> Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
14:27:14 <ski> @type curry . (. uncurry zip) . mapAndUnzipM . uncurry
14:27:16 <lambdabot> Applicative m => (a -> b1 -> m (b2, c)) -> [a] -> [b1] -> m ([b2], [c])
14:27:21 <ski> @hoogle (a -> b1 -> m (b2, c)) -> [a] -> [b1] -> m ([b2], [c])
14:27:22 <lambdabot> Data.Deriving.Internal zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])
14:27:22 <lambdabot> MonadUtils zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])
14:28:13 <ski> seems you could do with something like that
14:28:13 <random32> mapAndUnzipM sounds like exactly what I need
14:28:42 <ski> well, with `mapAndUnzipM', you'll still need to `zip' your two input lists yourself
14:29:23 <ski> hm, reminds me i defined something like `zipWithAndUnzip', in Scheme
14:30:00 <ski> (`map' in Scheme does the work of both `map' and `zipWith' (and `zipWith3',&c.))
14:30:29 <random32> are these functions in the prelude? If not how can I import? when I type :t mapAndUnzipM I get variable out of scope error 
14:31:08 <jle`> @hoogle mapAndUnzipM
14:31:08 <lambdabot> Control.Monad mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
14:31:08 <lambdabot> Protolude mapAndUnzipM :: Applicative m => a -> m (b, c) -> [a] -> m ([b], [c])
14:31:08 <lambdabot> Protolude.Monad mapAndUnzipM :: Applicative m => a -> m (b, c) -> [a] -> m ([b], [c])
14:31:13 <jle`> ah it's in base, neat
14:32:05 <TristahK> help echo
14:32:31 <ski> @index mapAndUnzipM
14:32:31 <lambdabot> Control.Monad
14:32:43 <ski> @index zipWithM
14:32:44 <lambdabot> Control.Monad
14:33:01 <random32> got it! Thanks for all the help I gotta run but ill be working on this again later tonight!
14:57:55 <mlugg> In a GADT definition, do the names of type variables have any impact?
14:58:27 <mlugg> If not, what's good practice wrt naming them vs type variables in actual constructors? Should you try to make them correlate?
14:58:43 <glguy> mlugg: No, the names don't matter and I prefer using KindSignatures syntax instead
14:59:21 <mlugg> I haven't used that extension before
14:59:31 <maerwald> It makes your code look cooler
14:59:50 <glguy> and less misleading
15:00:28 <mlugg> I'm vaguely familiar with the basic kind system
15:00:52 <glguy> It'll be good to figure kinds out before venturing into gadts
15:00:56 <mlugg> Any reading recommendations on that extension? Doesn't seem to be a wiki page
15:03:13 <mlugg> Ah okay, so basically instead of `data Foo a b where ...`, I'd write `data Foo :: * -> * -> * where ...`
15:03:23 <jle`> data Maybe :: * -> * where
15:03:26 <jle`>   Nothing :: Maybe a
15:03:30 <jle`>   Just :: a -> Maybe a
15:03:46 <mlugg> Yeah, okay, that makes sense
15:03:48 <mlugg> Thanks
15:03:52 <jle`> mlugg: not necessarily  * -> *
15:04:00 <jle`> but yeah, i think you get the picture
15:04:19 <solonarv> I would actually also recommend using Type instead of *
15:04:43 <mlugg> Oh, is `Type` an alias for `*`? I haven't seen that
15:04:48 <solonarv> for now that's mostly just personal preference, but eventually *-means-Type will phase out
15:04:59 <solonarv> actually it's * that is an alias for Type now, I think
15:05:02 <mlugg> Oh, I didn't know that
15:05:11 <mlugg> That's v good to know
15:05:20 <jle`> just remember to import Type from Data.Kind if you decide to use it
15:05:28 <solonarv> consider: GHC supports type-level numbers now, and obviously we'd like to multiply them...
15:06:07 <solonarv> also, * is normally an operator per Haskell's lexical rules, but in types it has to be treated specially because it's *not* an operator: ugly special-casing hacks!
15:06:39 <mlugg> Oh yeah, that's not nice
15:06:43 <mlugg> Okay, `Type` it is
15:08:52 <solonarv> another convert ;)
15:09:17 <mlugg> Tbh a keyword always seemed like it'd be nicer, I'd just never come across `Type`
15:12:24 * hackage dobutokO2 0.4.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.4.0.0 (OleksandrZhabenko)
15:13:02 <solonarv> it's actually not a keyword at all, just a plain old identifier - this makes it *less* magical than * !
15:15:02 <ski> mlugg : i name them (or a prefix of them), in case they're the same in the result types of all `data' constructors
15:15:22 <ski> e.g. stuff like
15:15:33 <ski>   data Vector a :: Nat -> Type
15:15:34 <ski>     where
15:16:25 <ski>     Nil  ::                              Vector a  Zero
15:16:39 <ski>   Cons :: forall n. a -> Vector a n -> Vector a (Succ n)
15:17:11 <solonarv> but with this order of parameters you can't write Functor (etc) instances!
15:17:21 <ski> yea, i know
15:17:47 <jle`> you can write Monoid instances
15:18:08 <solonarv> no you cannot, not with Vector :: Type -> Nat -> Type
15:18:19 <solonarv> oh oops I misread, don't mind me
15:23:14 <maerwald> Is there a way to stack open variants. Let's say I have a download function that can error with 5 different types. I want another function to download something, but then have that represented at one failure type "DownloadFailed" without losing the lower-level type that caused it
15:23:58 <maerwald> Afais the only way is to convert the lower type level list into a Sum type
15:24:36 <maerwald> Which would be a lot of sum types
15:25:29 <maerwald> Basically a type level stack trace :>
15:28:41 <dmwit> But using the order that allows functor instances doesn't prevent you from writing essentially the same monoid instances, so...
15:31:11 <solonarv> perhaps something like: data DownloadFailed cs = DownloadFailed Message (V vs) ?
15:32:38 <maerwald> Hmmm
15:32:48 <solonarv> then you can end up with: foo :: (Member (DownloadFailed SomeConcreteList) e, MonadError e m, MonadHttp m) => URL -> m SomeData
15:33:07 <solonarv> I suspect you can't make SomeConcreteList polymorphic because then type inference fails
15:42:21 <exarkun> is it accurate that Warp doesn't reset ("tickle") the thread timeout manager while it is writing the response body?  I traced the implementation down to sendRsp and I don't see how it could tickle it from that point down, where the writing happens, because it doesn't even accept the TimeoutManager.Handle.
15:44:05 <maerwald> solonarv: probably with an existential type, because I don't want to give a concrete list, just have the inner type as a debug value
15:44:38 <maerwald> But Show instance is hard
15:49:54 * hackage lingo 0.3.2.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.3.2.0 (tclem)
16:27:27 <maerwald> https://github.com/haskus/packages/issues/32 I wonder if this is even fixable
16:34:57 <maerwald> plucky has the same problem
16:37:07 <maerwald> With classes, GHC does know which constraints are not necessary
16:58:36 <mjrosenb> hrm, I suspect that asking ghc for the type of a lens has backfired on me again
17:00:53 <mjrosenb> I have foo = val ^? lens . expr . lens2 . lens3, and I asked ghc for the type of expr, but it looks like the type ended up getting specialized to include (lens2 . lens3)
17:04:09 <maerwald> how did you ask
17:04:34 <sm[m]> makeRegexOpts at https://hackage.haskell.org/package/regex-base-0.94.0.0/docs/Text-Regex-Base-RegexLike.html#t:RegexMaker calls error; I'd like to switch to makeRegexOptsM and display the error message more nicely. But MonadFail seems to discard that information.. am I right ?
17:05:28 <mjrosenb> I replaced expr with sameType expr _, with sameType :: a -> a -> a
17:05:46 <solonarv> sm[m]: MonadFail's one method (fail) takes a String argument, so you might be able to construct some sort of error message to pass there
17:05:49 <maerwald> foo = val ^? lens . (expr :: _) . lens2 . lens3 -- did not work?
17:06:08 <mjrosenb> I did not try because I did not know you could do that.
17:06:16 <maerwald> Yes can
17:06:21 <mjrosenb> sweet.
17:07:07 <sm[m]> solonarv: I'm looking at https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fail.html#t:MonadFail and but having no idea how to get hold of the message. Am I missing something simple ?
17:07:42 <sm[m]> eg the Maybe and the ST instances seem to discard it
17:08:58 <mjrosenb> maerwald: ok, well, that gave me the same type
17:09:05 <sm[m]> there's probably a lib function that converts error to Either..
17:09:54 <sm[m]> maybe try. I'll.. try
17:10:17 <sm[m]> ah no, that's IO
17:14:14 <maerwald> sm[m]: you're in IO and a function calls fail?
17:14:32 <sm[m]> I'm in pure code and I want to safely call a library function that calls error
17:15:05 <sm[m]> I think that's possible but as usual I'm horribly confused by haskell's errors & exceptions
17:15:34 <mjrosenb> in general, if you want to handle a function calling error, you need to go into IO.
17:15:49 <maerwald> I don't understand what error has to do with MonadFail 
17:16:14 <sm[m]> maerwald: this library provides an alternate api that uses MonadFail instead of calling error
17:16:20 <maerwald> Ah
17:16:22 <sm[m]> but then I can't see how to get the actual error message out
17:16:44 <maerwald> sm[m]: if your monad also has MonadIO, then it's an IOError and you can simply catch and display
17:17:15 <sm[m]> regex-base's makeRegexOpts[M], to be precise
17:17:52 <sm[m]> I think I should be able to construct a regex in pure code without needing IO
17:20:19 <maerwald> So what's your Monad then?
17:20:30 <sm[m]> NO MONAD
17:20:43 <sm[m]> I'm in honest pure code :)
17:20:56 <maerwald> Then how do you use MonadFail without a monad?
17:21:08 <mjrosenb> most Monads are pure; and if they're using MonadFail, then there needs to be a Monad.
17:21:20 <maerwald> All monads are pure.
17:21:33 <sm[m]> I could runST, it seems like. MonadFail has a ST instance. 
17:22:03 <sm[m]> You'd think I could runST, then get the failure message from the state. But wait.. the fail implementation calls errorWithoutStackTrace 
17:22:16 <sm[m]> that seems kind of dumb, no ?
17:23:24 <mjrosenb> not really? ST doesn't have any way of failing, does it?
17:23:31 <maerwald> STE does
17:23:41 <maerwald> But it doesn't have a MonadFail I think
17:23:56 <sm[m]> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fail.html#t:MonadFail
17:24:02 <maerwald> MonadFail is an odd API to begin with
17:24:20 <sm[m]> I think MonadFail basically doesn't let you see any details of the failure, by design
17:24:35 <maerwald> MonadThrow makes more sense if you have no idea how your user wants to interact with your errors
17:24:41 <sm[m]> so it wasn't a great choice for makeRegexOpts to use
17:26:22 <solonarv> sm[m]: you can probably do something like this: unsafePerformIO (fmap pure (evaluate $ force act) `catch` \(ErrorCall msg) -> fail msg)
17:27:07 <sm[m]> brr! thanks
17:27:22 <solonarv> (this is to convert an error call into a fail call, obviously)
17:27:49 <sm[m]> "obvious" you say :)
17:27:50 <mjrosenb> can you implement your own MonadFail instance that is isomorphic to Either String a? (or does Either String a work for you)?
17:29:01 <sm[m]> sorry, I'm not sure
17:29:12 <justawoman> whats the simplest way to randomly shuffle a list?
17:30:02 * sm[m] thinks: could also let it call error and catch the exception higher up
17:30:15 <mjrosenb> justawoman: knuth-fischer-yates? although impelementing it in haskell is not the most efficient.
17:30:47 <solonarv> the main problem is simply that indexing lists is slow, btw
17:31:05 <solonarv> but yes, knuth-fisher-yates is the go-to "shuffle a list" algorithm
17:31:15 <justawoman> ok thanks
17:31:55 <solonarv> what a confident soul! leaving after merely having an algorithm name-dropped
17:32:54 <maerwald> that's all you need
17:33:11 <mjrosenb> blah.  the type of expr in (foo = obj ^. lens1 . expr) and for its type in (obj' = obj & lens1 . expr .~ undefined) give two different types
17:33:14 <mjrosenb> of course it does.
17:34:47 <shachaf> Maybe something like cloneLens does the thing you want. If you even want anything.
17:35:19 <mjrosenb> shachaf: I'm trying to bind expr to a variable that I can use as if it were the full expression
17:35:27 <solonarv> giving 'expr' an explicit (polymorphic) type signature should do the trick
17:35:50 <solonarv> let expr :: Lens S T A B; expr = _ in ...
17:36:17 <maerwald> or use optics :P
17:36:24 * hackage fuzzy-dates 0.1.1.2 - Libary for parsing dates in strings in varied formats.  https://hackage.haskell.org/package/fuzzy-dates-0.1.1.2 (ReedOei)
17:37:21 <mjrosenb> Lens S T A B, or Lens s t a b?
17:37:42 <solonarv> I used capital letters to stand in for some concrete types you surely have
17:37:55 <solonarv> like, idk, Lens' MyBigState MySmallPiece
17:38:03 <mjrosenb> right
17:38:15 <mjrosenb> so I don't actually know what those are
17:38:24 <mjrosenb> and am trying to get the compiler to tell me
17:38:31 <mjrosenb> and it is very much not telling me.
17:38:37 <solonarv> hm, you might not even need the type signature..?
17:38:43 <solonarv> oh! you can use type wildcards
17:38:51 <solonarv> expr :: Lens _ _ _ _
17:39:07 <solonarv> GHC will error out and tell you what type it inferred for those
17:39:11 <solonarv> that should do the trick
17:45:32 <mjrosenb> solonarv: not quite...
17:46:21 <sm[m]> is there a way to alter things in the cabal file based on whether stack or cabal is running ?
17:46:27 <mjrosenb> https://gist.github.com/mjrosenb/27fb531eb9b3db289f068d5b21f95895 -- the suggestion doesn't make any sense to me, since f is not a variable that is mentioned in my type
17:46:32 <sm[m]> a flag or env var ?
17:46:47 <mjrosenb> sm[m]: that sounds dangerous.
17:47:35 <sm[m]> cabal 3 doesn't generate the environment files needed for doctest to run. I'd like to make the doctest suite unbuildable so cabal builds don't fail
17:48:34 <mjrosenb> that sounds less dangerous.
17:48:42 <sclv> it does generate env files if you ask it to I thought?
17:49:26 <mjrosenb> what is an env file?
17:49:31 <sm[m]> sclv yes I saw there's a cabal flag. If I can figure out how to enable that in the cabal file, without breaking stack, that'd work too I think
17:49:45 <sm[m]> details: https://github.com/sol/doctest/issues/245#issuecomment-583171683
17:49:54 <sclv> put cabal opts in the stack file?
17:50:02 <sclv> Erm the cabal.project file
17:50:40 <solonarv> mjrosenb: ah, that 'f' comes from the definition of Lens
17:50:56 <solonarv> type Lens s t a b = forall f. (a -> f b) -> s -> f t
17:51:13 <solonarv> er, sorry, that's wrong
17:51:19 <sm[m]> sclv: hmm, I do have one of those. Does cabal always look in there ?
17:51:19 <solonarv> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
17:51:45 <solonarv> it wants Applicative instead of merely Functor, which means you have a Traversal on your hands
17:51:54 <solonarv> (I naively went ahead and assumed it was a lens, sorry!)
17:52:00 <myquestion> how can I execute a list of IO's
17:52:40 <solonarv> myquestion: sequence (or its less general sibling sequence_) will do the trick
17:53:01 <myquestion> thank you
17:53:11 <mjrosenb> solonarv: yeah, changing the type from Lens to Traversal allowed it to compile (finally)
17:53:14 <sm[m]> sclv: and if you don't mind, since I'm having trouble finding out: what would the syntax be for adding this flag  there ? And do you think it'll still work with older cabal-install ?
17:53:33 <solonarv> sequence :: [IO a] -> IO [a], or sequence_ :: [IO a] -> IO () if you don't care about the rsults
17:54:44 <mjrosenb> heh, I was about to suggest mapM_ id
17:54:51 <sm[m]> just `write-ghc-environment-files: always` I guess
17:55:19 <solonarv> actually I don't think that can go in a .cabal file
17:55:44 <sclv> it goes in the project file, not the cabal file
17:55:52 <solonarv> yes, that's right
17:59:05 <sm[m]> sclv: yes.. interesting, this does work (for cabal 3 at least), but not on first run - you have to run cabal test a second time. Maybe in practice it will be ok because of the preceding cabal build
17:59:37 <macHaskell> anyone have experience with Haskell For Mac? If so how can I view the entirety of a large list after I call it in the playground? For me the list gets cut off after a little over 100 characters even when I have it on full screen. The list stays on one line...
18:02:30 <mjrosenb> macHaskell: I take it this is something other than just running ghci in a terminal?
18:02:47 <mjrosenb> you can try mapM_ print longlist
18:03:32 <shachaf> You're in a mapM_ mood today.
18:03:57 <sm[m]> sclv: yes, cabal 2 says Unrecognized field 'write-ghc-environment-files'. But it seems to be just a warning, so that's ok
18:04:25 <sm[m]> thanks for the idea
18:04:34 <sclv> :-)
18:04:39 <mjrosenb> shachaf: I'm always in a mapM_ mood.
18:06:22 <shachaf> Why not a traverse_ mood?
18:06:29 <shachaf> Other than that function not existing apparently.
18:07:30 <mjrosenb> mapM and mapM_ are basically the only two Monadic functions that I know of that operate on lists
18:08:17 <doesntcontribute> im trying to compile but the compiler can't find module System.Random
18:08:42 <mjrosenb> doesntcontribute: you'll need to specify random as a dependency in your cabal file
18:09:25 <doesntcontribute> ok I have never made a cabal file so ill see if I can figure it out
18:10:07 <solonarv> shachaf: it does exist, but it's not in the Prelude IIRC
18:11:55 <shachaf> Oh, right, it's in Foldable.
18:13:52 <mjrosenb> solonarv: ok, I'm trying the same thing, but with a different expression, this one uses itraversed, but setting the type to IndexedTraversal _ _ _ _ _ doesn't work, since it can't deduce Indexable (Int, Int) p (once again, p is not actually present anywhere else)
18:14:32 <solonarv> once again p comes from the type synonym you're using (namely IndexedTraversal)
18:15:33 <mjrosenb> yes, last time the fact that it complained about it meant that I was using the wrong type synonym. I suspect that I am doing so again
18:15:38 <solonarv> I guess the maximally general type signature with wildcards is: _ => Optic _ _ _ _ _ _
18:15:42 <mjrosenb> but I'm not sure what the right one would be.
18:16:05 <solonarv> maybe a plain old _ works too? or _ => _ ?
18:17:29 <mjrosenb> _ ran into the issue that it produced a type that was specialized to the place that it was being used, and couldn't be used in a slightly different context
18:17:34 <zeta_0> what are the differences between haskell and elm?
18:18:01 <ysangkok> zeta_0: elm doesn't have hkt's does it?
18:20:49 <solonarv> haskell has a much fancier type system, haskell lets you FFI to your heart's content
18:21:08 <solonarv> (AFAIK elm does not have a free-form FFI, you have to go through something called "ports"?)
18:24:32 <solonarv> these are the only differences I feel comfortable mentioning, because I don't know very much about elm
18:25:17 <solonarv> oh! Haskell primarily compiles to native code (although JS and kinda/soon WASM are also possible), whereas AFAIK elm is web-first
18:31:34 <zeta_0> ysangkok: right, i remembered i read that in wikipedia
18:33:01 <zeta_0> i am having a rough time landing a remote haskell position, that's why i am putting a lot more effort into javascript, and giving elm a try because it's a functional language that compiles directly to javascript, so i can easily run it on the browser
18:33:21 <zeta_0> there's much more javascript jobs
18:33:27 <zeta_0> than haskell jobs
18:33:41 <ysangkok> zeta_0: there is PureScript too, that compiles to JavaScript too
18:35:17 <zeta_0> ysangkok: ya, too many options(i shouldn't be complaining)
18:36:22 <ysangkok> zeta_0: apply for all the jobs in all the languages. remember to write that you have 20 years of experience :P
18:38:27 <doesntcontribute> specifying the dependency is going pretty poorly haha...the error im getting is "Could not find module ‘System.Random’ " 
18:38:45 <doesntcontribute> I am confused on how ghci knows about the module but the compiler does not
18:39:11 <zeta_0> ysangkok: lol, right
18:40:28 <Cale> doesntcontribute: That's in the random package. ghci will often try to be helpful and try to guess which package to load automatically, whereas in actual projects, it's expected that you specify all your dependencies in a .cabal file.
18:41:09 <Cale> If you're just running ghc by hand, you can use -package random
18:41:55 <sm[m]> is it reasonable to always use -O0 in CI scripts, so they run faster ?
18:42:12 <sm[m]> assuming you're not producing artifacts
18:42:25 <doesntcontribute> the only thing I have been able to find that somewhat resembles a place to specify a dependency (Haskell For Mac) is in editing the raw cabal file
18:42:29 <Cale> Well, if you're not producing anything, then -fno-code might also be good
18:42:30 <sm[m]> or doing heavy benchmarking 
18:42:42 <sm[m]> oh, interesting
18:42:46 <zeta_0> doesntcontribute: i'd highly recommended using nix/guile pkg managers(to automatically handle the dependencies), they will save you from dependency hell. I'd also recommend using ghcid/ghcide(amazing tools)
18:43:01 <Cale> What we do is have our CI system build the actual stuff and stick it in a binary cache for us
18:43:02 <zeta_0> just thought i'd throw that out there
18:43:02 * sm[m] will try that, thanks
18:43:15 <solonarv> doesntcontribute: yes! you are indeed supposed to edit the blahblah.cabal file
18:43:17 <Cale> So that once the CI gets to things, developers no longer have to build it
18:43:38 <sm[m]> I'm learning github actions, and making rather good progress with caching
18:43:54 <sm[m]> some things don't cache well, I think haddock is one of these
18:44:27 <doesntcontribute> solonarv: seems dangerous here is what the cabal file looks like https://pastebin.com/JSZ6STk1
18:44:34 <doesntcontribute> not sure where or what to write
18:45:14 <Cale> In our case, it's nix that handles caching, and builds are almost always nicely deterministic already.
18:46:41 <zeta_0> Cale: i think you were the one telling me a couple months ago that haskell can be used to write/build android apps right?
18:46:48 <sm[m]> that may be the next level. I'm quite pleased with the relative painlessness of this though
18:47:19 <Cale> zeta_0: Yeah, we build Android and iOS frontends for our web applications using reflex-platform / Obelisk.
18:47:50 <Cale> sm[m]: Yeah, there are a lot of things which can be said about nix, but "painless" isn't a word that I'd use :D
18:48:02 <sm[m]> PSA: on github's windows runners, C:\Users\runneradmin\AppData\Local\Programs\stack\ and C:\Users\runneradmin\AppData\Roaming\stack are the main dirs to cache
18:48:08 <solonarv> doesntcontribute: well, it looks like random is already in there anyway
18:48:24 * hackage unity-testresult-parser 0.1.0.4 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.4 (incertia)
18:48:31 <sm[m]> Cale: good to hear that from an expert!
18:50:25 <zeta_0> Cale: cool, i am currently having a rough time landing a remote haskell job position, so now i have been putting the majority of effort into javascript(there's way more javascript jobs), and agreed nix is useful but can be painful as well, i haven't tried guile yet, i heard that it's great
18:50:33 <ysangkok> doesntcontribute: how are you compiling? pressing a button in your ide?
18:50:35 <mjrosenb> oh, wonderful I have blah = grid . expr, which ghc can't figure out the type of.  I can tell it blah is Optic _ _ _ _ _ _, and it is fine, but if I then tell it expr is Optic _ _ _ _ _ _, it complains that it can't find a type for expr
18:51:00 <Cale> sm[m]: It's almost certainly the best thing at what it does, but the nix language and the culture surrounding it is fairly painful. It's a purely-functional expression language, but then they kind of go out of their way to sidestep most of the benefits of pure functional programming, by having most functions effectively receive entire universes of packages and nix libraries as arguments. This can make it hard to 
18:51:00 <Cale> understand what's going on.
18:51:45 <doesntcontribute> ysangkok: ghc --make MyMain.hs 
18:52:02 <ysangkok> doesntcontribute: ghc doesn't know about your cabal file. use cabal to compile
18:52:13 <Cale> Also, there are a lot of large associative mappings that are being manipulated (attrsets), often in recursive ways spanning many modules, and so finding out where a thing that's in one of those is defined can be really annoying, because its definition could be anywhere or possibly "everywhere" -- spread out between many files.
18:52:14 <ysangkok> doesntcontribute: cabal can invoke ghc
18:52:44 <ysangkok> doesntcontribute: try "cabal run", for example
18:53:24 <zeta_0> i heard idris is coming with a new pkg manager, that seems interesting, but i don't know if it will be exclusively for idris though
18:54:26 <ysangkok> zeta_0: there is no reason to think it would be for anything except idris. but idris is a research project, unless you are interested in playing with dependent types, i don't see the point in using any of their tools
18:55:09 <zeta_0> ysangkok: oh i see, i don't know much about idris, it's just something that i heard
18:56:25 <mjrosenb> Cale: also, every package that has sub-packages that can be installed (haskell, emacs, python, etc.) seem to have a slightly different way of doing things
18:56:28 <solonarv> among the various dependently-typed languages / theorem provers, it's the closest to something you might write actual programs in (AFAIK)
18:56:54 <ysangkok> solonarv: yeah, and the book is great! i read it, it's awesome!
18:57:22 <ysangkok> but if you really wanna prove things i think Software Foundations is more practical
18:57:36 <doesntcontribute> ysangkok: my file appears to have compiled correctly but I can't find the executable. the final line of the compilation sais Building executable 'SeasonSim' for SeasonSimHaskell-1.0..
18:57:57 <solonarv> hm. I am a physics student, so I don't know if I'm supposed to care about proofs or real-world programs :P
18:57:59 <ysangkok> doesntcontribute: if you use "cabal run", it will start your executable automatically
18:58:26 <zeta_0> most of the haskell job positions that i see are only for senior developers, why does no one want to hire junior developers? wouldn't that help more functional programmers to get into industry?
18:58:32 <solonarv> doesntcontribute: it's somewhere in dist-newstyle/, I don't remember where exactly because it usually doesn't matter
18:58:41 <ysangkok> solonarv: since you are already half-way mathematician, why not embrace theorem provers and convert your kind? :P
18:59:02 <ysangkok> solonarv: if you embrace computation instead of types, you'll just be another hacker :P
18:59:41 <ysangkok> zeta_0: most businesses are not in the business of "helping out" :P
19:00:00 <hololeap> doesntcontribute: have you tried searching for it? `find dist-newstyle/ -type f -executable`
19:00:00 <doesntcontribute> ysangkok: I ran "cabal run" and still nothing happened and the final line is once again "Building executable 'SeasonSim' for SeasonSimHaskell-1.0.."
19:00:27 <solonarv> doesntcontribute: does your executable output anything?
19:00:40 <ysangkok> doesntcontribute: look in your process listing (task manager) to see if the ghc process is still running
19:00:49 <zeta_0> ysangkok: ya i guess'
19:01:43 <ysangkok> zeta_0: but i think elm is a great start! there are many functional languages nowadays. even languages like elixir are branding themselves as functional. of course, you won't find much sympathy for dynamic typing in here :P
19:02:00 <zeta_0> sorry about the occasional single quote, rcirc has a bug that sometimes does not let me delete them
19:02:06 <doesntcontribute> It had not output anything but after putting in a putStrLn I got an output thanks guys
19:02:38 <doesntcontribute> though I was expecting my sequence call to do something...
19:03:01 <zeta_0> ysangkok: ok, i'll try elm for now, it's been a pain using it with nix, but i guess i just have to get used to it
19:03:51 <ysangkok> solonarv: i really liked this talk with Tom Hales. he is a mathematician but is embracing Computer Theorem Proving: https://www.youtube.com/watch?v=Dp-mQ3HxgDE
19:05:39 <solonarv> ysangkok: thanks for the link! I'll watch that tomorrow
19:05:49 <sm[m]> Cale: yes, it seems like whatever successor comes along is going to be great
19:06:04 <sm[m]> learning from nix
19:06:35 <ysangkok> it's funny, because he is struggling just to _define_ the proof statements he wants to prove! meanwhile your average hacker is just spewing out truckloads of javascript :P
19:07:33 <Cale> ysangkok: Don't you mean Kevin Buzzard?
19:07:48 <Cale> Or is there another video you meant to link?
19:08:05 <ysangkok> Cale: oh right, sorry. i searched for the name in the video description and didn't realize it is not the guy in the video
19:08:28 <ysangkok> (goes to show what a wannabe mathematician i am, i guess :P)
19:10:05 <zeta_0> is darcs usable now for real world industrial projects or is git still much better? i heard darcs used to have a lot of problems, but i am not sure if that has changed recently?
19:10:49 <sm[m]> no dramatic changes recently AFAIK
19:11:19 <sm[m]> it remains quite usable, but nothing like the tooling and support of git
19:12:45 <zeta_0> sm[m]: ok, i'll stick with git for now, i am learning magit in emacs currently
19:12:59 <sm[m]> everything in darcs is just simpler
19:13:10 <sm[m]> darcsum.el is the "magit" for darcs
19:13:36 <sm[m]> and https://hub.darcs.net is the "github"
19:15:11 <zeta_0> sm[m]: cool, i've never heard of that, i guess i could try out darcs for my personal projects for now, i heard that slows down on massive projects with many lines of code
19:15:26 <sm[m]> it really doesn't, if you're using it right
19:15:31 <sm[m]> all that is overblown
19:16:15 <sm[m]> I mean, if you're facebook, then yes
19:16:57 <zeta_0> sm[m]: does nix have good darcs support? right now it doesn't have any support for the nix home-manager
19:17:00 <sm[m]> but if it helps, ghc used it for many years
19:17:23 <sm[m]> I think you can assume does X have good darcs support is "no" :)
19:17:45 <sm[m]> sorry, a better answer is I don't know
19:18:11 <sm[m]> I might seem a bit conflicted about darcs :)
19:18:45 <glguy> We used to use darcs at work about 12 years ago before switching to git. darcs lack of branch support (you just have to make separate directories which meant you can't use the darcs tooling to find branches) and its propensity for exponential blow up if we make the wrong commits and occasional corruption drove us away
19:19:08 <glguy> since then git has only gotten better and I haven't tracked darcs' development
19:19:22 <zeta_0> sm[m]: oh, well thanks for clarifying things, tools built with haskell seem to be much better
19:19:31 <ysangkok> glguy: what are some major improvements to git that you appreciate?
19:19:39 <Cale> I heard they eventually got a handle on the exponential blowups, but I have no idea really.
19:20:15 <sm[m]> git has had very good leadership for a long time, which is one reason it wins despite not being haskell
19:20:34 <ysangkok> i only noticed the addition of "git switch" and i don't know what to make of it
19:20:34 <zeta_0> glguy: that was 12 years ago, so hopefully darcs has evolved since then
19:21:36 <glguy> zeta_0: Youd need a really good reason to pick darcs over git at this point
19:21:38 <zeta_0> is linus torvalds still in charge of git, or has he retired already?
19:21:48 <ysangkok> retired years ago i think
19:22:01 <doesntcontribute> what is the difference between compiling with "cabal run" vs "gcc --make" again? 
19:22:05 <sm[m]> the exponential blowup was "mostly solved", but "can still happen", but in practice most darcs users never experience it, perhaps because they learn to avoid heavily conflicting commits
19:22:34 <ysangkok> doesntcontribute: "ghc --make" is really minimal, it almost can't do anything. really not useful
19:22:49 <Cale> I rather liked darcs' way of thinking of the repository as a collection of patches, and found it more intuitive than git's model that's kind of halfway in between exact contents and patches.
19:22:58 <sm[m]> the lack of a clear characterisation, demo, workaround-howto for this is one of darcs' big failings
19:23:39 <Cale> But also, I really want something that is neither git nor darcs, and which does a much better job of recording every state that the repository has ever been in, and doesn't encourage people to lose that history
19:23:51 <ysangkok> doesntcontribute: cabal is a package manager, it reads your cabal file which contains all the relevant information about what your package needs. since you want to use that information, stick with cabal
19:24:03 <glguy> zeta_0: if you're looking to adopt some Haskell tools you could try my IRC client :)
19:24:04 <Cale> Why can't my editor's undo history go into the repo?
19:24:30 <solonarv> doesntcontribute: cabal makes sure the dependencies are downloaded, built, and available, and then calls ghc --make (basically)
19:24:40 <Cale> There almost shouldn't be a notion of "committing", I think that's a mistake
19:24:44 <solonarv> Cale: I think some editors / plugins can do that, actually
19:25:07 <ysangkok> Cale: aren't commit messages useful?
19:25:12 <Cale> There should be a giant graph of states, and tools to help you annotate and visualise it
19:25:17 <sm[m]> Cale: just too much data for right now, I guess
19:25:23 <Cale> maybe
19:25:39 <Cale> I wouldn't always want to pull everyone's undo history
19:25:52 <doesntcontribute> ysangkok: one difference I noticed though when I compiled with "ghc --make" is that I had an executable file pop up on my desktop but did not have that happen when I used "cabal run"
19:26:05 <glguy> Cale: I'd prefer to explicitly snapshot specific states, rather than all undo history
19:26:24 <sm[m]> zeta_0: despite all, there is really a lot of development going on with darcs right now. So if you're interested in it, I'm sure they'd like help
19:26:32 <Cale> But it would be nice if, having done a bunch of work for the day, and forgetting to commit things, I could just scroll back through time, find the states which were automatically marked as compiling, and pick out a few to annotate with messages.
19:26:34 <glguy> I make changes, decide they were the right changes, name the changes
19:26:54 <ysangkok> doesntcontribute: read the cabal documentation, it describes where executables are built. or you can search for them like shown above
19:27:10 <doesntcontribute> ok I will
19:27:35 <sm[m]> Cale: it would. I'm reminded of jetbrain's Local History feature, which is great at tracking your changes automatically
19:27:50 <Cale> Or, if I tried a bunch of stuff and it didn't work, of course I would usually not commit that, but it would be useful if later on I needed to explain to someone else what things I'd tried, if I could go back through and put a bunch of low-priority messages on relevant states.
19:28:12 <zeta_0> glguy: what's your haskell irc tool called, i'm using emacs rcirc right currently
19:28:36 <Cale> There should be a bunch of priority levels on messages about states of the repository I think -- which can be filtered on at different levels of granularity
19:29:01 <ysangkok> zeta_0: maybe this one https://hackage.haskell.org/package/glirc
19:29:05 <Cale> The reason that everyone rebases and destroys all the actual history of their repositories is to make it easier for people to come along later and work out what things happened
19:29:24 <Cale> But another way to accomplish that would just be to be able to mark out major vs. smaller milestones
19:30:00 <Cale> (at least I think)
19:30:07 <glguy> zeta_0: You can see what it looks like first if you're interested: https://www.youtube.com/watch?v=taz0-hZwWP4
19:30:09 <zeta_0> sm[m]: i just started contributing to ghc, i was able to build it with nix, but i am way over my head(ghc is intimidating), i think i'd be better off starting off contributing to something like xmonad or darcs
19:30:49 <sm[m]> to be honest, darcs is not a simple codebase either. The types are quite scary.
19:31:04 <Cale> zeta_0: I've been programming in Haskell for nearly two decades now, and I'm in over my head trying to work on GHC :)
19:31:05 <zeta_0> cool, i'll take a look at the glirc now
19:32:09 <Cale> (mostly because the hard part is not understanding Haskell code, it's just understanding how GHC expects things to happen)
19:32:38 <sm[m]> haskell programmers: in over our heads
19:36:37 <zeta_0> Cale: lol, then i'm definitely way over my head with ghc, i've been programming for 5 years(3 with haskell). ghc.nix has builtin support for ghcid, but i wasn't able to get ghcide to work on ghc, one of them main contributors said the next patch would fix it, hopefully
19:37:01 <Cale> I've just been using ghcid
19:37:06 <Cale> and tags
19:38:54 <zeta_0> sometimes i think i am understanding haskell pretty well, then i hit a brick wall and feel lik a beginner all over again
19:42:34 <Cale> zeta_0: Any particular brick walls at the moment?
19:48:56 <sm[m]> IDEs, I bet
19:53:37 <zeta_0> Cale: one of the concepts that i still haven't quite wrapped my head around is monads, i worked through all of bartosz milewskis videos of category theory on youtube, but i still haven't had the monad enlightenment where i realize what a monad 'is', i'm trying to learn things in order like others have said, i am currently on chapter 9 of learn you a haskell, getting there
19:54:26 <sm[m]> I'll just leave this here: github CI with caching working on three platforms: https://github.com/simonmichael/hledger/tree/master/.github/workflows
19:54:33 <zeta_0> sm[m]: no, i have ghcid/ghcide working good in emacs, just haven't got ghcide to work with ghc
19:56:31 <zeta_0> when learning haskell i feel like a zen master trying to meditate on the nature of reality
19:56:33 <zeta_0> lol
19:57:01 <zeta_0> Cale: 
19:57:58 <zeta_0> Cale: sorry about that, i accidentally typed your nickname
20:00:21 <Cale> zeta_0: The best thing to get a handle on what monads are is just to use a bunch of libraries which happen to define examples of monads
20:00:49 <Cale> zeta_0: What's being abstracted will eventually become obvious, once you've seen a bunch of examples
20:04:14 <zeta_0> Cale: ok i see, i was thinking of contributing to xmonad, that should help me improve my haskell skills'
20:04:25 <Cale> Yeah
20:04:50 <Cale> If you'd like, I can give a pretty good example of a monad which I think was the one that made me first get the point
20:05:02 <Cale> That example is a type of parsers
20:06:16 <Cale> We can have a type  Parser a  for parsers which will consume some initial fragment of an input string, possibly in multiple ways (ambiguity is often important while parsing), and if it succeeds, each way in which it succeeds will result in a value of type a, and a depleted string.
20:06:35 <zeta_0> Cale: sure i'll try my best to understand
20:06:54 * hackage unity-testresult-parser 0.1.0.5 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.5 (incertia)
20:07:01 <Cale> So:  newtype Parser a = P (String -> [(a, String)])
20:07:18 <Cale> runParser :: Parser a -> String -> [(a, String)]
20:07:27 <Cale> runParser (P f) s = f s
20:07:54 * hackage dbus 1.2.12 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-1.2.12 (blaze)
20:08:02 <Cale> This is the Dr. Seuss definition of a parser: "A parser for things is a function from strings, to lists of pairs of things and strings"
20:09:15 <Cale> Now, one of the very simplest parsers imaginable is the one which, given a value v of type a, simply succeeds with result v, without consuming any of the input string
20:09:29 <zeta_0> Cale: ok, give me second to digest and break down the code, i hope your not in a rush
20:09:33 <Cale> okay
20:10:46 <Cale> So the idea with the type, if you want me to break that down again, is that you have a function which gets some input String, and it produces a list of possible parses of that String (which will have 0 elements if the parse fails, 1 element if it succeeds unambiguously, and more elements if there's more than one possible way to parse the string)
20:11:17 <Cale> and each parse consists of a result of type a, together with whatever part of the input was left over
20:14:24 * hackage unity-testresult-parser 0.1.0.6 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.6 (incertia)
20:17:24 <zeta_0> Cale: i kind of understand it, normally when trying to understand monads, i look at the functions of the monad typeclass, and try to find where the code is being substituted, like in algebra
20:17:45 <Cale> Yeah, so I haven't said anything much yet about why this thing happens to be a monad
20:18:02 <Cale> But when we work out how that is, it'll perhaps be clearer what the monad operations are getting us
20:18:49 <Cale> and more importantly, why having the Monad abstraction is beneficial (it'll be because we get a whole bunch of useful functions on Parser for free)
20:21:12 <zeta_0> Cale: maybe i could tell you the interpretation of how i understand that piece of code you pasted, so you can see where i'm at, how does that sound?
20:21:21 <Cale> sure
20:21:32 <Cale> (I just typed that code actually ;)
20:22:43 <zeta_0> ok one second
20:25:54 * hackage unity-testresult-parser 0.1.0.7 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.7 (incertia)
20:29:21 <zeta_0> Cale: ok so newtype defines a type 'Parser a' which returns the result of the P value constructor applied to the result of a function that takes a String and returns a list of pairs where the 1st component is the type variable 'a' which is wrapped by the Parser type. the runParser takes a value of type Parser a, takes a String, then returns a list of pairs like previously explained
20:29:47 <zeta_0> Cale: apologies, mind is jumbled up right now
20:30:18 <Cale> Ah, okay, so if you're struggling with this syntax a bit, what this means is that, yes, we're defining a new datatype Parser a
20:30:35 <Cale> and values of type Parser a are obtained by applying the newly defined data constructor P
20:30:48 <Cale> P takes an argument of type String -> [(a, String)]
20:30:54 <Cale> and produces a value of type Parser a
20:31:28 <zeta_0> Cale: ok, i understand so far
20:31:30 <Cale> and we can pattern match with a pattern like (P f) to get back the function String -> [(a, String)]
20:31:40 <Cale> (f will have that type)
20:31:47 <Cale> Okay
20:32:06 <Cale> P :: (String -> [(a, String)]) -> Parser a
20:32:08 <Cale> if it helps
20:32:38 <Cale> Usually the intention is going to be that we define enough primitive parsers and ways of combining parsers that we don't really need to use this P thing directly any more
20:32:58 <Cale> But initially, it's our only way to build parsers
20:33:47 <nitrix> For the interested, SpaceX is launching CRS-20 in the next few 15 minutes. https://www.youtube.com/watch?v=1MkcWK2PnsU
20:34:33 <Cale> zeta_0: Okay, so we could start off in a bunch of ways. I could show how to build some primitive parsers, or we could go directly to the Monad instance on this
20:34:47 <zeta_0> Cale: ok, i understand so far, so we want to abstract(cut away) the P into a form that is easier to understand and compose with other things, right?
20:35:34 <zeta_0> nitrix: what is that?
20:36:07 <sm[m]> nitrix: thx!
20:36:22 <nitrix> Resupply mission to the ISS, nothing "incredible" if you're not a space person :)
20:37:03 <sm[m]> yawn just another spaceship taking off, same as usual :)
20:37:27 <sm[m]> I kid
20:37:39 <zeta_0> Cale: uhh i'm guessing it would be best to start of building simple primitives then when i understand that i can go to monads
20:39:27 <zeta_0> cool, my brother is really into elon musk and his companies
20:39:48 <Cale> zeta_0: Okay, so a really basic one is the parser which just always fails to parse:
20:39:53 <Cale> pzero :: Parser a
20:40:01 <Cale> pzero = P (\s -> [])
20:40:29 <Cale> and we probably want some way to match one character to start off with
20:40:41 <Cale> to that end, let's define
20:40:50 <Cale> satisfy :: (Char -> Bool) -> Parser Char
20:41:17 <Cale> which, given a function that says whether a character is acceptable, gives a parser which either eats a character, or fails
20:41:46 <Cale> e.g.  satisfy isDigit  will be a parser that parses a single digit
20:42:13 <Cale> and  satisfy (== 'c')  will be a parser that parses exactly the letter 'c'
20:42:22 <Cale> make sense?
20:42:33 <Cale> (If so, I'll start to define it)
20:43:21 <zeta_0> Cale: before i work through your code, i have a quick question, to parse means to break down code right? i just want to make sure that i 1st understand what a parser is, wikipedia confused me
20:44:17 <sm[m]> it means to convert a flat stream (eg of text) into more structured data (eg a syntax tree)
20:44:21 <Cale> Parsing for us is the process of turning strings into data structures of some other sort perhaps
20:44:28 <monochrom> parse = read a string and make some sense out of it
20:44:57 <Cale> yeah, exactly
20:45:24 <zeta_0> ok, parse makes much more sense now, thanks'
20:45:49 <Cale> and in the process, we're going to either accept the string (and produce some data which explains what we managed to read), or we reject the string (and produce nothing)
20:46:32 <Cale> and for technical reasons, we're interested in allowing parsers to succeed in multiple ways, because it turns out that often you don't quite know when to stop trying to parse in one way, and start doing something else
20:46:41 <solonarv> well, if we wanted to be really nice and thorough we might also report what was wrong with the string, but let's ignore that for now
20:47:00 <Cale> so having some ambiguity, where you're able to back off and try a different route to parsing the initial part of the string if the second part fails is useful
20:47:15 <Cale> Yeah, there are a lot of potential complications of this I'm not going to deal with
20:47:35 <zeta_0> Cale: ok, give me one second to make sense of the code, sorry i'm real slow, it takes me a while
20:49:24 * hackage unity-testresult-parser 0.1.0.8 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.8 (incertia)
20:53:27 <zeta_0> Cale: ok the only part that is confusing me is when an empty list is returned?'
20:54:24 * hackage unity-testresult-parser 0.1.0.9 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.9 (incertia)
20:54:33 <zeta_0> in the implemention of the pzero function
20:54:48 <Cale> zeta_0: So, the list that is produced is a list of the ways that the string is understood by the parser
20:55:01 <Cale> If it produces the empty list, that means the parse failed
20:55:09 <Cale> pzero is a parser that just always fails
20:55:16 <Cale> regardless of what input it gets
20:55:43 <Cale> (it can be useful as a part of some more complicated parsers later)
20:55:57 <zeta_0> ok understood
20:56:56 <Cale> okay
20:57:09 <Cale> So, let's go about defining satisfy
20:57:14 <Cale> satisfy p = ...
20:57:24 * hackage unity-testresult-parser 0.1.0.10 -   https://hackage.haskell.org/package/unity-testresult-parser-0.1.0.10 (incertia)
20:57:36 <Cale> p :: Char -> Bool is the function for deciding if a character is to be accepted
20:57:52 <Cale> Now the result is a Parser here, so might as well use P
20:57:55 <Cale> satisfy p = P ...
20:58:10 <Cale> and then P takes a function, so might as well be a lambda:
20:58:14 <Cale> satisfy p = P (\s -> ...)
20:58:25 <Cale> and now we have to produce the list of parses
20:58:46 <Cale> we want to look at the first character of the input (if any), so we'll pattern match on s
20:58:52 <Cale> satisfy p = P (\s -> case s of ...)
20:59:08 <Cale> and if it's nonempty, it'll match the pattern (x:xs)
20:59:14 <Cale> satisfy p = P (\s -> case s of (x:xs) ...)
20:59:32 <Cale> and we're especially interested in the case where p x is True, so we'll use a guard
20:59:38 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> ...)
21:00:07 <Cale> and now in this case, the parse succeeds, and produces x as its result, with the remainder of the string being xs
21:00:20 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> [(x,xs)]  ...)
21:00:41 <Cale> In every other case, the parse will fail (either if the input is empty, or p x is False)
21:00:50 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> [(x,xs)]; _ -> [])
21:01:51 <Cale> Make sense?
21:02:42 <zeta_0> Cale: ok, it makes pretty good sense
21:03:12 <Cale> Okay, so in terms of that, we can define things like
21:03:19 <Cale> digit = satisfy isDigit
21:03:25 <Cale> letter = satisfy isAlpha
21:03:39 <Cale> char c = satisfy (== 'c')
21:03:43 <Cale> oops
21:03:45 <Cale> char c = satisfy (== c)
21:03:47 <Cale> of course
21:04:18 <zeta_0> Cale: ok, this makes pretty good sense
21:04:21 <Cale> and maybe we'll do one more combinator before getting on with Monad
21:05:10 <zeta_0> Cale: ok, so explain to me in simple terms, what is a combinator?
21:05:24 <zeta_0> i'm not sure if i understand it correctly
21:05:36 <Cale> In this context, just a way of combining things of interest
21:05:48 <zeta_0> ok
21:06:05 <Cale> It's common to define libraries where we have a bunch of "primitives" that tend to be as simple as possible building blocks
21:06:23 <Cale> and then "combinators" which combine simpler things together to make more interesting ones (in hopefully simple ways)
21:06:49 <Cale> So, if we have two parsers of the same type, p, q :: Parser a
21:07:02 <Cale> maybe we want to have a parser which will succeed if either one of them would
21:07:56 <zeta_0> Cale: so a combinator is the different ways we can compose primitives?
21:07:57 <Cale> More specifically, the list of parses it will produce will be the concatenation of the lists of parses that p and q would have produced
21:08:00 <Cale> yeah
21:08:18 <Cale> each combinator is a way of composing together the things we're building out of primitives and combinators
21:08:59 <Cale> (In this case, parsers, in another case, it might be GUIs, in yet another, it might be animated drawings or something)
21:09:31 <zeta_0> Cale: oh ok, like composing widgets in yesod?
21:09:35 <Cale> yeah
21:09:54 <Cale> So,
21:10:01 <Cale> (+++) :: Parser a -> Parser a -> Parser a
21:10:05 <Cale> p +++ q = ...
21:10:15 <Cale> Well, we'll start off the same way we have been thus far
21:10:20 <Cale> p +++ q = P (\s -> ...)
21:10:37 <Cale> We're making a new parser, and we get hold of the input string s
21:10:50 <Cale> and now we're going to run both p and q and concatenate the lists of results together:
21:11:01 <Cale> p +++ q = P (\s -> runParser p s ++ runParser q s)
21:11:11 <zeta_0> does the (+++) function have a name?
21:11:20 <Cale> alternation
21:11:38 <zeta_0> oh that makes more sense
21:11:40 <Cale> It's like "OR" for parsers in a way
21:12:19 <Cale> So now what if we want to run one parser and then another?
21:12:32 <Cale> Feeding the second parser whatever was left over of the input?
21:12:40 <Cale> We can of course do that as well
21:13:10 <Cale> But we do have to take care of the fact that the first parser might succeed in multiple ways
21:13:19 <Cale> So, list comprehensions will be handy
21:13:25 <zeta_0> so p and q are predicates and s is a string that they are applied to? or am thinking of the other example you showed me?
21:13:52 <Cale> p and q are parsers (which you can think of as predicates on strings, plus information about how to turn those Strings into values of some other type)
21:14:04 <Cale> and yeah, s is the string that the combined parser is applied to
21:14:25 <Cale> and we apply both p and q to s, get the list of possible parses from each
21:14:29 <Cale> and concatenate those together
21:14:42 <Cale> so the resulting parser succeeds in all the ways that either parser could
21:16:12 <zeta_0> Cale: oh wow, that's very interesting, it's making making some more sense, little by little
21:17:08 <Cale> So, maybe let's do return now (which is part of what will make Parser into a monad)
21:17:14 <Cale> return :: a -> Parser a
21:17:44 <Cale> The goal of return in general is to succeed with the given result while "doing nothing", whatever that means in context
21:17:58 <Cale> In this context, it means that we're going to leave the input string untouched
21:18:15 <Cale> return v = P (\s -> ...) -- the usual setup
21:18:36 <Cale> and now we want to succeed, so we're producing a nonempty list
21:18:46 <Cale> return v = P (\s -> [...])
21:19:01 <Cale> and we know what result we want to succeed with, v
21:19:14 <Cale> and we want to leave the input alone
21:19:21 <Cale> return v = P (\s -> [(v,s)])
21:20:34 <zeta_0> Cale: oh, i see
21:21:49 <Cale> So, maybe before we do full (>>=), which is the other part of defining an instance of Monad, let's look at a simpler operation we'll eventually get for free from (>>=)
21:21:58 <Cale> (>>) :: Parser a -> Parser b -> Parser b
21:22:20 <Cale> p >> q  will be the parser which parses the initial part of the string with p
21:22:36 <Cale> and then discards the result of p, but parses the remainder of the string with q
21:23:03 <Cale> and returns the result that q would have returned
21:23:56 <zeta_0> so it basically sequences the 2 parser predicates?'
21:23:58 <Cale> (the difference when we get to (>>=) is that we won't ignore the result of the first parser)
21:24:00 <Cale> yeah
21:24:28 <jle`> sequence is a good word for it
21:24:59 <Cale> A more parser-specific term for it is concatenation of parsers
21:25:22 <jle`> sequence_ [p1,p2,p3] is essentially p1 >> p2 >> p3
21:25:51 <zeta_0> so >>= is sequence with value passing, but does value passing mean composition?
21:26:07 <Cale> Well, (>>=) :: Parser a -> (a -> Parser b) -> Parser b
21:26:22 <Cale> and  p >>= f  is the parser which parses the first part of the input with p
21:26:49 <Cale> and then if it gets some result v and depleted string s', it parses s' with the parser (f v)
21:27:08 <Cale> i.e. the function is applied to the result of the first parser to determine which parser to parse the rest of the string with
21:29:07 <Cale> So this is a bit more akin to function application than function composition, in that we're applying the function f to the result of the first parser in order to determine how to proceed
21:29:23 <Cale> But it's a means of composing parsers regardless.
21:29:25 <zeta_0> Cale: ok, i'm getting me intuition from my understanding of Maybe, this parser feels pretty similar
21:29:44 <Cale> So, shall we write (>>=)?
21:29:57 <Cale> If the description makes sense, maybe we'll just go straight for it
21:30:30 <Cale> p >>= f = P (\s -> ...) -- we'll start off the same way we have been, getting the initial input string s
21:30:42 <zeta_0> Cale: ok why not
21:30:52 <Cale> and now we want to run the parser p on s, and we'll get a list of type [(a,String)]
21:31:11 <Cale> p >>= f = P (\s -> ... runParser p s ...)
21:31:36 <Cale> and now, if you're familiar with list comprehensions, they'll be a good way to write what we want to do, because it amounts to trying all possibilities here
21:31:51 <Cale> p >>= f = P (\s -> [... | (v,s') <- runParser p s ...])
21:32:19 <Cale> we're going to run the parser p on the input s, and for each successful result v, and depleted string s'
21:32:41 <Cale> p >>= f = P (\s -> [... | (v,s') <- runParser p s, (w,s'') <- runParser (f v) s'])
21:32:52 <Cale> we're going to run the parser f v on the depleted input s'
21:33:05 <Cale> getting some result w and further depleted string s''
21:33:17 <Cale> and then those pairs will be the results of our combined parser
21:33:24 <Cale> p >>= f = P (\s -> [(w,s'') | (v,s') <- runParser p s, (w,s'') <- runParser (f v) s'])
21:33:35 <Cale> good?
21:33:41 <zeta_0> ok, there's a lot going on, my mind is boggled
21:33:44 <Cale> It's a bit of a mouthful :)
21:34:26 <Cale> hopefully you're already comfortable with list comprehensions, if not, that might be a tricky introduction
21:35:02 <Cale> The idea is that they let us make multiple choices from lists, in all possible ways
21:35:39 <Cale> > [10 * x + y | x <- [1..9], y <- [1..x]]
21:35:41 <lambdabot>  [11,21,22,31,32,33,41,42,43,44,51,52,53,54,55,61,62,63,64,65,66,71,72,73,74,...
21:35:46 <zeta_0> Cale: i understand list comprehensions , but applied to parsers like this a little confusing'
21:36:32 <Cale> The list comprehension here kind of lets us ignore the details about the fact that the first parser might succeed in multiple ways or fail
21:36:57 <Cale> If the first parser fails, it produces an empty list, and the whole list comprehension becomes the empty list, because it can't choose a (v,s')
21:37:19 <Cale> If it succeeds in multiple ways, each of the (v,s') combinations is going to be tried
21:37:28 <Cale> (in order)
21:37:51 <Cale> and we'll proceed by running (f v) on s', and collecting up all the ways it succeeds (if any)
21:38:55 <Cale> Hopefully most of the time, our parsers will succeed in just one way, but sometimes it's useful to have them succeed in many, as we saw with (+++)
21:39:17 <zeta_0> Cale: ok, i think we should call it a day, i'm too tired/brain-dead now, what time zone are you in?
21:39:23 <Cale> EST
21:39:50 <Cale> It's past midnight here
21:40:41 <Cale> But yeah, what I'd just like to say is that even if this is a little complicated, it will turn out to be worthwhile, because it'll turn out to be a very useful operation for building up parsers
21:40:45 <zeta_0> Cale: i am in us mountain time so i'm falling asleep, it's around 10:30 here
21:42:00 <zeta_0> Cale: what time are you usually on this channel? maybe i could catch you for some help in the mornings when i'm wide awake
21:42:06 <Cale> My sleep schedule is super erratic because I've been somewhat sick lately, I went to bed at 9:30pm yesterday, and then also ended up sleeping a bunch during the day because I was dizzy, so I'm less tired than I ought to be now.
21:42:16 <jle`> stay healthy :)
21:42:28 <Cale> But usually on weekdays, I'm up by 10am because I have standup then
21:43:01 <Cale> (short meeting with coworkers to say what we're working on)
21:43:17 <zeta_0> Cale: i tried changing my sleep schedule to sleep during the day and work during the night but it didn't go to well
21:43:43 <zeta_0> yeah make sure you get enough sleep, our bodies need it
21:43:45 <Cale> Back before I had this job, there were some stats on my hours in #haskell
21:44:16 <Cale> It was a sort of radial graph shaped like a 24 hour clock. Most people, you could tell clearly what times they were sleeping
21:44:22 <Cale> My graph was a slightly offset circle
21:44:24 <Cale> lol
21:44:27 <Gma> hello is there some people who could help me for a beginner problem in haskell ?
21:44:43 <Cale> yep
21:44:57 <Gma> Can I send a reedit link here? 
21:45:05 <Cale> yep
21:45:20 <zeta_0> ok good night guys, time for bedtime, thanks for the help
21:45:25 <Gma> https://www.reddit.com/r/haskellquestions/comments/feqthm/beginner_alike_getopt/ this may be a shit answer but i'm blocked there :/
21:45:34 <Cale> g'night!
21:45:42 <Gma> bye zeta
21:46:34 <Cale> Gma: It's possible to do this, but I would usually highly recommend optparse-applicative
21:47:03 <Gma> It's for a school project and getOpt is forbidden and I dont know if I can use optparse-applicative thing
21:47:27 <Cale> Actually, it's kind of unfortunate that you missed the last hour or so here, where I was describing how to build a combinator parser library :)
21:47:47 <Cale> But this probably doesn't require that much sophistication
21:48:57 <Cale> actually, probably the best way for you to go is to make sure your cases are more exhaustive, and result in each of those functions looking through the entire commandline for the flag they want to match
21:49:33 <Cale> Currently you're matching on lists of length exactly 2
21:49:43 <Cale> So the pattern won't match if the list is longer
21:50:01 <Cale> You might prefer to use ("--rule" : x : _) -> ...
21:50:03 <Gma> I've tried to put ["--rule", x, _]
21:50:06 <Gma> but no success
21:50:12 <Gma> with the () its different ?
21:50:14 <Cale> That would be a list of length exactly three
21:50:21 <Gma> oh shit
21:50:38 <Cale> ["--rule", x, _] means a list of length 3 whose second and third elements are anything, and whose second element is bound to x
21:51:52 <Cale> and then you'll want to have a pattern after it like (_:xs) -> getRule xs
21:52:24 <Cale> which means that if the first pattern didn't match, and the list still isn't empty, we're going to try on the remainder of the list after dropping the first element
21:52:36 <Cale> and then you need to handle the empty case as well
21:52:39 <Cale> [] -> []
21:52:40 <Cale> or something
21:52:58 <ski>   "--rule" : x : _ -> ...
21:53:43 <Cale> Yeah, the parens there aren't required, but for some reason they feel comfortable to me :)
21:53:57 <ski> they feel uncomfortable, to me ;)
21:54:12 <Cale> (actually moreso these days, after the whole shenanigans with the \of proposal...)
21:54:12 <Gma> Well thanks both of you, I feel like I can go further with that
21:54:15 <glguy> unnecessary parens make me think I'm missing something
21:55:05 <Cale> There's a GHC proposal at the moment to add a new syntax like \case but which can define multiparameter functions and which has the full power of function declarations
21:55:27 <ski> hm, i heard a mention of it
21:55:35 <Cale> But it unfortunately can't be simply an upgrade of \case, because it needs you to parenthesise your patterns more
21:55:48 <Cale> Otherwise, it's hard to tell whether  Foo x  is two patterns or one
21:55:58 <ski> @type \case Just x -> x
21:56:00 <lambdabot> Maybe a -> a
21:56:52 <Gma> Seems to work perfectly, ty
21:57:01 <Cale> greay
21:57:03 <Cale> t*
21:58:48 <ski> i guess OCaml has bracket-less tuples
22:01:41 <monochrom> Wait, what?!  We already have \case, next we will have \of too?  Are we turning Haskell into LaTeX?!  Are we going to have \| too?
22:02:42 <ski> oh, `\of', as the `of' keyword ?
22:03:35 * ski idly ponders list comprehensions and eta
22:04:16 <monochrom> Corporate needs you to find the difference between these two files.
22:04:45 <monochrom> foo.hs: \case x \of (a,b) -> \let y=a+b \in y+1
22:04:50 <monochrom> foo.tex: \case x \of (a,b) -> \let y=a+b \in y+1
22:04:56 <monochrom> "They are the same file"
22:12:24 <Gma> bye i add this irc on bookmark, ty for answer gn
22:24:32 <ski>   [<expat> | <expat> <- <exp>]  =  <exp>  -- under some conditions ..
22:24:44 <ski>   [<expat> | ...,<expat> <- <exp>]  =  ?
22:48:45 <mjrosenb> hrm, I can't use internal libraries in nix, can I?
22:51:26 <mjrosenb> oh, wait, maybe I can, the error I got is not what I thought it was
23:01:51 <Athas> Hold up now, 'stack' itself isn't even in the newest LTS?
23:20:03 <Nolrai> @pl \ (a,b) -> (f a, g b)
23:20:03 <lambdabot> f *** g
23:20:18 <Nolrai> @pl \ a -> (f a, g a)
23:20:18 <lambdabot> liftM2 (,) f g
23:22:23 <Nolrai> @pl \ l -> (f a l, f b l)
23:22:23 <lambdabot> ap ((,) . f a) (f b)
23:22:32 <Nolrai> Hmm.
23:24:59 <ski> > (f &&& g) x  :: (Expr,Expr)
23:25:01 <lambdabot>  (f x,g x)
23:27:11 <ski> > (uncurry (&&&) . (f *** g)) (a,b) x  :: (Expr,Expr)
23:27:14 <lambdabot>  (f a x,g b x)
23:27:49 <Nolrai> Thats less awful.
23:31:06 <ski> only slightly
23:34:36 <Nolrai> Indeed.
23:38:22 <Io> is there any performance difference between say someAccesorFunc . fst . fromJust $ myData    and      someAccesorFunc $ fst $ fromJust $ myData ?
23:42:43 <Nolrai> Shouldn't be.
23:43:26 <iqubic> I think those have different type signatures.
23:43:40 <Nolrai> It would be possible to write rules that only fired for one and not the other, but those would be baddly writen rules.
23:54:59 <ski> Io : the former is better, from a maintainability POV
23:55:36 * ski would probably prefer either `(someAccesorFunc . fst . fromJust) myData' or `someAccesorFunc (fst (fromJust myData))', though
