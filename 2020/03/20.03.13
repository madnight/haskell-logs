00:46:10 <ski> jackdk : hm, where's that line from ?
00:50:37 <MarcelineVQ> the girl from jurassic park says it when she gets the doors back online
00:54:21 <jackdk> "monads are a software engineering pattern to support a certain type of code reuse" ? dibblego says something like it when running the fp-course
00:54:33 <jackdk> ski^
00:56:54 <ski> oh, ok
00:59:53 * hackage hanabi-dealer 0.7.1.0 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.7.1.0 (SusumuKatayama)
01:10:24 * hackage rvar 0.2.0.4 - Random Variables  https://hackage.haskell.org/package/rvar-0.2.0.4 (DominicSteinitz)
01:11:53 <mpickering> Is there any systematic way to debug "thread blocked indefinitely on MVar" exceptions? 
01:22:25 <jackdk> If this is using reflex's `TriggerEventT`, it's because you have no running code that could potentially call an event trigger.
01:22:59 <jackdk> (the `a -> IO ()` thing you get from a newTriggerEvent` call
01:25:53 * hackage dobutokO2 0.9.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.9.0.0 (OleksandrZhabenko)
01:31:23 * hackage jira-wiki-markup 1.1.0 - Handle Jira wiki markup  https://hackage.haskell.org/package/jira-wiki-markup-1.1.0 (tarleb)
01:42:53 <ski> d34df00d,Axman6,Lears : "Uses a `case' expression" (not statement, please)
01:49:32 <Ariakenom> ski: what do you, others, consider statements in haskell?
01:58:02 <ski> Ariakenom : declarations can be considered statements
01:59:11 <ski> (otoh, the parts of a `do'-expression, i'd call "commands")
01:59:15 <[exa]> wiki definition says that any 'smallest imperative expression' is a statement, I guess items of 'do' could make it too.
01:59:36 <[exa]> 'command' tells the story much better though.
02:00:05 <[exa]> except perhaps for various declarative do's, like the routing in scotty
02:00:52 <ski> ordering isn't important, there ?
02:03:27 <Ariakenom> Wanted to check what others think. It seems about the same as me.
02:03:29 <[exa]> ofcourse it is, except the whole thing seems to be meant _not_ to look imperatively
02:04:43 <Cale> The Haskell Report calls the lines of a do-block "statements" for whatever it's worth
02:06:11 <ski> hm, i wonder whether "giving an order" is related to "ordering"
02:06:16 <Netsu> Hey! How can I filter `[IO Bool]` type based on Bool result? Any elegant way to do this?
02:06:16 <Cale> We have some unusual monads in Reflex-DOM, where the ordering in the do-block is simply the ordering down the page, and time is a whole separate axis.
02:06:32 <Cale> Netsu: You probably want to start by running all the actions using sequence?
02:06:46 <Cale> Netsu: do you want to keep the actions as actions so that you can run them again?
02:07:29 <ski> Netsu : it's not clear to me what you want the result to be
02:08:25 <Netsu> Cale: Yeah, I started with `sequence`, but have no clue, how to filter it based on result. Actually, I have intermediate `Bool` value in `IO` monad, and calculate result of `a` type to return `[IO a]`
02:08:53 <ski> perhaps you should show some code
02:09:30 <Netsu> But need to `guard` it in case `Bool` is `False`. However, guard related to `IO`, not the list in such case
02:09:34 <ski> are you sure you don't want result of type `IO [a]' ?
02:09:54 <Cale> Netsu: It's not quite clear what your program is attempting to do here... are you actually trying to build a weird higher-order control structure, or do you really want something more normal looking?
02:12:37 <Cale> The shell-scripting equivalent to your question would be something like how you can run a whole directory of programs and partition the executables into two subdirectories based on their exit codes... which might be something you want to do, but it's a little unusual :)
02:13:22 <Netsu> `do {- IO stuff -} { ...; sequence ([list, of, values] <$> \elem -> do {- nested IO -} { ...; intermediateResultOfIO <- ...; {- trying to filter List -} guard intermediateResultOfIO; ...; pure ... }) ; ... }`
02:13:49 <Cale> Maybe you just want forM?
02:14:13 <Netsu> maybe, thank you
02:14:15 <Cale> forM [list, of, values] $ \x -> ...
02:14:36 <Cale> The result of the forM, if you choose to capture it, will be the list of results of each iteration of the loop
02:15:03 <Cale> (If you don't capture it, it's better to use forM_ which is the same, but discards the results rather than constructing a list of them)
02:15:39 <ski> you could compute a `Maybe' in the inner thing, then use `catMaybes' to drop the `Nothing's ?
02:16:22 <Netsu> Cale: however not sure yet how to filter `t` the traversable inside `m` the monad type in example with `forM`
02:16:58 <ski> (or else, you could either give the empty list (drop) or singleton list (keep), for each `elem', depending on `intermediateResultOfIO', then use `concat')
02:17:10 <Cale> Netsu: Well, don't worry about abstractions like Traversable and such yet... what is your program trying to compute?
02:17:39 <Netsu> ski: that's looks like a solution, thanks. Hoped that List's traversable ability could be reused there
02:18:10 <Cale> ah, yeah, I was about to suggest what ski was, after reading "trying to filter list"
02:18:11 <ski> you seem to be wanting something `ListT IO'-like here, i suppose
02:18:36 * ski tries to recall what the "done right" one would do, here
02:18:36 <Netsu> ski: yeah, I considered variant with `>>=` instead of `<$>` but decided it look not elegant enough to mee
02:19:13 <ski> @type catMaybes
02:19:15 <lambdabot> [Maybe a] -> [a]
02:20:22 <Netsu> ski: `ListT IO` -- ha, maybe. Hoped to avoid such overcomplicated effects
02:20:29 <ski> @type \xs f -> liftM catMaybes . forM xs $ \x -> f x
02:20:30 <lambdabot> Monad m => [t] -> (t -> m (Maybe a)) -> m [a]
02:20:47 <ski> something like that should work for your case
02:21:00 <Cale> Yeah, just producing lists that get concatenated is a pretty standard way to have each iteration produce zero or more results
02:21:02 <Netsu> awesome, thanks for all the suggestion
02:21:32 <Cale> (and of course, you can do it with Maybe if you want to ensure each iteration produces no more than one result)
02:22:19 <Netsu> make sense
02:22:45 <ski>   do {...; liftM catMaybes . forM [list,of,values] $ \elem -> do {...; intermediateResultOfIO <- ...; if intermediateResultOfIO then do {...; pure (Just (...))} else pure Nothing}; ... }
02:24:07 <ski> if you want to try with lists, that's `concat' in place of `catMaybes', `[]' in place of Nothing', and `[...]' (single element) in place of `(Just (...))'
02:24:29 <ski> hm, wondering whether it'd be worth using `MaybeT IO' for the inner thing, here
02:25:44 <Netsu> yeah, `msum` and `empty`
02:27:19 <ski>   do {...; liftM catMaybes . forM [list,of,values] $ \elem -> runMaybeT do {...; intermediateResultOfIO <- liftIO (...); guard intermediateResultOfIO; pure (...)}; ... }
02:27:28 <ski> a little bit cleaner, perhaps
02:28:04 <ski> i guess one could use `guard =<< liftIO (...)'
02:28:28 <ski> (to avoid naming `intermediateResultOfIO')
02:33:53 * hackage pkgtreediff 0.4 - Package tree diff tool  https://hackage.haskell.org/package/pkgtreediff-0.4 (JensPetersen)
02:34:25 <Netsu> ski: nice, thanks
02:36:44 <ski> i guess you could even use `MonadComprehensions', if you wanted to. but then you'd have to name `intermediateResultOfIO' (and also the final result of the function passed to `forM')
02:43:43 <Cale> Haha, throw exceptions to skip elements
02:45:03 <hassia> I am currently testing STM. I am using it to count up multiple Int values in parallel. When I run it using the linux program "time" I see that most time is spent in "sys", i.e kernel time. Does anyone have an explanation for this?
02:53:23 * hackage wai-middleware-clacks 0.1.0.0 - GNU Terry Pratchett - Add the X-Clacks-Overhead Header to Wai Responses.  https://hackage.haskell.org/package/wai-middleware-clacks-0.1.0.0 (lysergia)
02:57:17 <riddle00> .
02:59:20 <riddle000> .
02:59:37 <aveltras> having some type data Serializable = forall a. (Serialize a, Typeable a) => MkSerializable a, how would one serialize/deserialize a Map SomeTypeRep Serializable to ByteString ? I'm trying to setup a web session system and don't really know how to recover the TypeRep from the bytestring so that i can decode the Serializable
03:02:54 <ski> riddle00 ?
03:11:25 <riddle00> @ski sorry forgot how to irc
03:11:25 <lambdabot> Maybe you meant: wiki src ask
03:13:38 <ski> yea, it's not IRC custom to adorn nicknames with sigils (like `@'). if you want to refer to, or address, someone, simply mention their nickname
03:15:01 <ski> (e.g. at the start of the message, followed by a comma or colon, in the addressing case. many IR clients highlight/alert the user when their nickname is mentioned first in a message, but not as many when it's mentioned else in it. that's another reason not to prefix with `@')
03:26:39 <Ariakenom> hassia: how long does your program run for?
03:26:52 <riddle00> ski, ok, git it
03:26:56 <riddle00> *got it
03:29:31 <hassia> Ariakenom: around a minute. And I perform around 200,000,000 (with 20 threads) add operations. I think it might be a GC issue. I only evaluate at the end of the program,.
03:36:08 <Ariakenom> hassia: could you gist your program?
03:36:43 <Ariakenom> btw, I'm not saying this shouldnt be happening. I'm no expert. I'm just interested.
03:53:54 * hackage wai-middleware-clacks 0.1.0.1 - GNU Terry Pratchett - Add the X-Clacks-Overhead Header to Wai Responses.  https://hackage.haskell.org/package/wai-middleware-clacks-0.1.0.1 (lysergia)
03:54:53 * hackage deriving-aeson 0.2.1 - Type driven generic aeson instance customisation  https://hackage.haskell.org/package/deriving-aeson-0.2.1 (FumiakiKinoshita)
04:16:26 <riddle00> \q
04:43:23 * hackage hanabi-dealer 0.7.1.1 - Hanabi card game  https://hackage.haskell.org/package/hanabi-dealer-0.7.1.1 (SusumuKatayama)
04:50:37 <isBEKaml> hanabi dealer sounds like a bad job ;-)
04:51:28 <iko_> a
04:52:39 <Uniaika> still a better position than Hanabi Player, isBEKaml :P
04:53:48 <iko_> GHC uses libffi  for FFI calls. Is the library dynamically linked or is it somehow statially embeded in the executable?
05:34:23 * hackage eccrypto 0.2.1 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.2.1 (MarcelFourne)
05:35:23 * hackage eccrypto-ed25519-bindings 0.1.1.0 - provides "ed25519" API using "eccrypto"  https://hackage.haskell.org/package/eccrypto-ed25519-bindings-0.1.1.0 (MarcelFourne)
06:03:31 <aveltras> how would one serialize/deserialize a heterogenous data structure ?
06:05:35 <shapr> aveltras: https://code.xkrd.net/voip/rtp/blob/master/src/Data/RTP.hs ?
06:05:37 <lyxia> like a record?
06:06:36 <shapr> oh, that code I linked is from https://tools.ietf.org/html/rfc3550 so may be overkill for your question
06:07:45 <aveltras> i'd like to be able to serialize/deserialize a session type for a web app which would be a map from typerep to type
06:08:08 <aveltras> the problem i have is i don t see how to serialize TypeRep
06:08:41 <aveltras> all the needed elements seem to be in Data.Typeable.Internal which seems to me like a reason not to use those directly
06:10:37 <aveltras> basically sth like https://gist.github.com/glguy/11a7583b2086de74237a4ebbad736e8a but serializable/deserializable
06:13:07 <merijn> Serialising TypeRep...oof
06:13:35 <merijn> Seems like a good way to leave a security whole the size of an airliner in your code >.>
06:15:31 <aveltras> is there another way to have a kind of heterogenous bag of values to use as a session for a web app ?
06:16:10 * ski . o O ( cryptographic stuff )
06:20:01 <[exa]> ...convenient how airliners and security holes coincide right?
06:21:21 <tdammers> aveltras: as long as the universe of types you need to put in there is closed, it's almost trivial
06:21:37 <tdammers> just make one big sum type and write ser/deser for that
06:22:26 <aveltras> it's not, ideally, i'd like to be able to put anything there, i'm browsing https://hackage.haskell.org/package/dynamic-state now which seems to be what i'd want to achieve
06:23:46 <tdammers> really absolutely anything?
06:23:57 <tdammers> that would be unusual
06:25:53 * hackage rampart 1.0.0.0 - 🏰 Determine how intervals relate to each other.  https://hackage.haskell.org/package/rampart-1.0.0.0 (fozworth)
06:26:21 <aveltras> ye, it's more like a convenience thing for this use case, i'd like to setup a session library for web apps. To use this you'd just have to choose where the session is persisted and then use it without having to define a record of all possible session values
06:29:16 <vent> Hi, I'm trying to set up intero, but it's complaining that my version of GHC is too new, and should be at most 8.6.5. I'm using stack to build. Is there a way of telling stack to use a specific version of GHC?
06:29:28 <tdammers> I think a more practical approach would be to make it polymorphic over the value type, and demand a typeclass instance that allows you to ser/deser that type
06:31:18 <aveltras> by value type you mean here the whole type of the session or the type of a value in the session ?
07:27:22 <tdammers> the latter, but you can also do the former if you prefer
07:30:07 <aveltras> do you have an example of the type of the "bag of values" ?
07:35:09 <Athas> What is the simplest way to write a web service in Haskell?  I want to expose an HTTP access point that corresponds to some stateful function.
07:35:23 * hackage time-compat 1.9.3 - Compatibility package for time  https://hackage.haskell.org/package/time-compat-1.9.3 (phadej)
07:39:01 <aveltras> depends if you need anything like routing or stuff like this
07:39:05 <Athas> I don't.
07:39:12 <aveltras> if your need is really simple, warp should be enough
07:39:25 <Athas> One function one URL, ideally with POST data.
07:39:42 <aveltras> https://hackage.haskell.org/package/wai
07:40:51 <Athas> Looks pretty simple.  It's tagged with yesod, though... anything to worry about there?
07:41:32 <phadej> Dependencies
07:41:32 <phadej> base (>=4.8 && <5), bytestring (>=0.10.4), http-types (>=0.7), network (>=2.2.1.5), text (>=0.7), transformers (>=0.0), vault (==0.3.*) [details]
07:41:42 <aveltras> yesod is based on this but you dont need yesod to use wai & warp
07:42:10 <Athas> Great!
07:42:20 <phadej> I warn you though, `wai` is simple as in "C is simple"
07:42:29 <Athas> That's exactly what I want.
07:42:57 <phadej> (which is not easy)
08:12:18 <sm[m]> vent: yes, by using the --resolver lts-X.Y option, or by installing the package from inside its source dir, where there's usually a stack.yaml file that specifies that and other things
08:18:20 <Athas> When doing 'cabal build' on NixOS, I get a linker error at the end: error: cannot find -lz
08:18:21 <Athas> If I write a shell.nix that makes zlib available and then run 'cabal build' from inside that, it works.
08:18:21 <Athas> If I use 'cabal --enable-nix build', it still fails.
08:18:32 <Athas> How come?  I thought --enable-nix was supposed to use shell.nix if available.
08:19:03 <merijn> Athas: enable-nix is v1 only, I think?
08:19:17 <merijn> I'm not sure, though
08:19:49 <aveltras> if you're on nixos you might already be sold on the nix way of doing thing, are you using the haskell infrastructure described in the manual ?
08:21:39 <Athas> aveltras: no.  I want my code to be accessible to non-Nixers as well.
08:22:51 <merijn> Athas: Crazy talk! Just make them use Nix too! I'm sure that's no effort at all!
08:23:12 <merijn> (Or so all the Nix people keep saying...)
08:23:49 <aveltras> i don t really get the difference here then
08:24:08 <boxscape> it's as easy as doing `nix-shell -p nix` ;)
08:24:18 <aveltras> if you're trying to use the enable-nix stuff to get a zlib aware environment the problem will be the same for your users
08:27:08 <aveltras> meaning you dont lock your users to nix by using the infrastructure mentioned, you just use it to develop and then release it with a cabal file, users are then free to use nix or not to use this
08:27:32 <aveltras> the classic shell.nix / default.nix is "opt-in"
08:30:17 <Athas> aveltras: sure, I just want to not use nix-shell myself, if possible.
08:32:34 <geekosaur> tbh if you're using nix, you're using nix and should do so directly, not rely on other tools to do it behind your back
08:32:36 <merijn> If I GND derive PrimMonad, do I need to explicitly define PrimState?
08:40:23 <merijn> Anyone?
09:31:53 * hackage plaid 0.1.0.1 - Plaid.com api integration library  https://hackage.haskell.org/package/plaid-0.1.0.1 (v0d1ch)
09:33:54 * hackage plaid 0.1.0.2 - Plaid.com api integration library  https://hackage.haskell.org/package/plaid-0.1.0.2 (v0d1ch)
09:51:48 <sm[m]> cool
10:10:24 * hackage plaid 0.1.0.3 - Plaid.com api integration library  https://hackage.haskell.org/package/plaid-0.1.0.3 (v0d1ch)
10:17:53 * hackage ghc-tags-plugin 0.1.5.0 - A compiler plugin which generates tags file from GHC syntax tree.  https://hackage.haskell.org/package/ghc-tags-plugin-0.1.5.0 (coot)
10:17:56 <Netsu> Hello! Is there a way to use `OverloadedLabels` with `lens`?
10:18:53 * hackage rampart 1.0.0.1 - 🏰 Determine how intervals relate to each other.  https://hackage.haskell.org/package/rampart-1.0.0.1 (fozworth)
10:24:53 * hackage ghc-lib-parser-ex 8.8.5.6 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.8.5.6 (shayne_fletcher)
10:28:16 <Netsu> Oh, I needed just `import Data.Generics.Labels ()`
10:37:46 <slack1256> Anyway to speed up the linking of haskell programs?
10:38:10 <geekosaur> gold instead of ld.bfd, otherwise no
10:38:23 <geekosaur> ghc stresses linkers significantly
10:40:53 * hackage prosidy 1.6.0.1 - A simple language for writing documents.  https://hackage.haskell.org/package/prosidy-1.6.0.1 (jafc)
10:42:26 <infandum> Why would a haskell program be stuck on 0% CPU?
10:43:03 <ChaiTRex> infandum: Is it waiting for something like IO?
10:44:10 <solonarv> import Control.Concurrent; main = threadDelay (10^10) -- 0% CPU ;)
10:44:11 <kleisli> anyone know how to parse a grammar like this with an LR parser generator? https://paste.ee/p/IaEmq
10:45:33 <kleisli> i can't seem to figure out a description for happy without sr conflicts
10:45:51 <infandum> ChaiTRex: Yes, that's it. Makes sense.
10:49:26 <[exa]> kleisli: what exact generator are you using now?
10:51:46 <[exa]> kleisli: btw I guess that the use of 'separator' is disambiguated on purpose by the nonterminal 'begin' right?
10:52:02 <kleisli> exa: yes exactly
10:52:51 <kleisli> the actual grammar i'm working with in happy is for something more complicated let me try to write a simple example
10:52:53 <[exa]> how much lookup capability do you have?
10:53:31 <kleisli> i'm not actually sure... I assumed happy is LR(1) but let me double check that
10:54:23 * hackage dir-traverse 0.2.2.3 - Simple directory traversal library  https://hackage.haskell.org/package/dir-traverse-0.2.2.3 (vmchale)
10:54:43 <[exa]> kleisli: because the 'separator' gets disambiguated only by knowing whether it's immediatelly followed by 'begin' or not. I guess there are no terrible ugly corner cases?
10:55:29 <kleisli> yes that's what i thought
10:55:57 <[exa]> oh I see
10:56:13 <kleisli> apparently happy is LALR(1)... tbh i don't know what the difference between LALR(1) and LR(1) is
10:56:34 <[exa]> if it reads 'a', it doesn't know whether the separator after that is separating Block or programs because it would need another lookup for 'begin', so this needs 2 lookups
10:57:15 <[exa]> suggest adding 'end'
10:57:16 <kleisli> ahhh that makes sense
10:57:49 <[exa]> it's a wild guess, let me know if that is the case
10:58:01 <[exa]> btw happy doesn't include some debug output of conflicting states?
10:58:37 <kleisli> it does. you're correct that the sr conflict is on receiving a 'separator'
10:58:57 <kleisli> but i thought that it only needed one lookahead to disambiguate, like you said
10:59:17 <[exa]> it's on 'a' actually
10:59:28 <geekosaur> happy has a GLR mode
10:59:32 <kleisli> oh hmm. well give me a moment to test this
10:59:34 <[exa]> it needs to lookup whether it's "a alone" or "a separator b"
10:59:50 <[exa]> and the separator there needs to get disambiguated by the second lookup
11:01:18 <justsomeguy> What's a GADT? My current understanding of it is that it's just a data declaration that uses one of several relationships for its data constructors (sum, produce, singleton, unit). Is this right? 
11:02:24 <justsomeguy> The book I'm reading explains things by analogy, and is very verbose. So I think I understand it, but I haven't seen a concise direct definition of the term yet.
11:03:31 <[exa]> justsomeguy: you mean GADTs or just ADTs?
11:04:25 <justsomeguy> I'm not sure what the difference is. I think I mean GADTs. I'm reading chapter 11 of haskellbook.com
11:05:26 <[exa]> that chapter is in the larger part "getting serious" before "maybe, either, ..." ?
11:05:46 <[exa]> (just verifying, I don't have the chapter numbers at hand.. :D )
11:06:14 <kleisli> exa: here's a happy parser for the grammar: https://paste.ee/p/PnnZB
11:06:22 <kleisli> and here's the sr conflict that it produces: https://paste.ee/p/xJ662
11:07:04 <kleisli> so it looks like the conflict is on 'separator', right?
11:07:56 <justsomeguy> [exa]: Right, it's the chapter right before "Signaling adversity", which is all about Maybe, Either, and smart constructors.
11:08:10 <[exa]> kleisli: no that's it, it has read 'a' and doesn't know how/if to reduce it.
11:08:22 <kleisli> got it
11:08:26 <[exa]> justsomeguy: then it's just ADTs.
11:08:49 <kleisli> exa: do you think it's possible to disambiguate this without adding some kind of ending marker?
11:09:00 <justsomeguy> [exa]: Yes, thanks for clarifying.
11:09:20 <kleisli> otherwise should i look into this GLR mode?
11:09:32 <geekosaur> kleisli, it's not. but accepting this shift/reduce conflict is common
11:09:52 <geekosaur> default is shift because that's usually what you want in this case
11:09:54 <[exa]> justsomeguy: anyway your definition is v e r y roughly correct. The intuition is that you have 1] a few basic datatypes 2] 2 basic combining operations, and you can construct much reasonable data just with that
11:10:39 <[exa]> justsomeguy: the operations are product (aka. *, &, or `struct` in C) that takes 2 data and pastes them together into a type that contains both
11:11:11 <justsomeguy> ...and sum
11:11:13 <[exa]> justsomeguy: and sum (aka. +, |, or very roughly a tagged `union` from C) that takes 2 data and produces a datatype that contains just one of the data
11:11:23 <kleisli> geekosaur: unfortunately i don't always want to shift in this case. i want to accept the string "begin a , begin a b", for example
11:11:35 <kleisli> and if it shifts in that case, it will give a parse error
11:11:45 <[exa]> justsomeguy: in haskell, the sum "items" are tagged by constructor names so that you always know which one is which
11:12:02 <[exa]> e.g. you can perfectly sum 2 equivalent things and you will still have distinction which one it was
11:12:34 <[exa]> justsomeguy: so for example, Bool type contains either True or False (never both) so you can write it as `True | False`
11:13:07 <[exa]> (that type doesn't actually contain anything except for the marks for the 2 possibilities)
11:13:55 <kleisli> geekosaur: sorry i might have misunderstood
11:14:03 <[exa]> justsomeguy: or say a complex number contains 2 "normal" numbers, which you would write `Complex Number Number` (the product sign is not written out in haskell)
11:14:43 <[exa]> justsomeguy: or you can combine this indefinitely, e.g. for a number that's either a single number, or a pair: `SingleNumber Number | PairOfNumbers Number Number`
11:16:49 <[exa]> kleisli: if/if/else problem from C-like languages is perhaps a best thing to google for resolving conflict by prioritizing one possibility
11:16:54 <justsomeguy> Thank you [exa], that helps a lot.
11:18:25 <[exa]> justsomeguy: anyway the "algebra" is in that you can imagine the above definition exactly as `Num + (Num * Num)` and do various useful algebraic operations with that (e.g. put in variables and differentiate the expressions)
11:22:42 <kderme> Anyone knows what happens in case an async exception is thrown, while another exception is propagated? For example what happens if an async exception comes while masked like this: `mask_ (throwIO MyException)`
11:27:21 <[exa]> kderme: race condition? ( <-- wild guess )
11:29:51 <merijn> kderme: Async exceptions are masked in exception handlers
11:30:51 <merijn> kderme: Docs in Control.Exception mention: "in catch the handler is inside an implicit mask (see "Asynchronous Exceptions") which is important when catching asynchronous exceptions,"
11:31:23 <merijn> kderme: This is necessary for bracket/etc. to work properly (i.e. cleanup resources) in the presence of async exceptions
11:45:00 <kderme> merijn I see. I was wondering if the async exception overwrites the exception thrown inside the body of say `catch`, after the handler is executed.
11:45:58 <merijn> Honestly, no clue
11:47:47 <merijn> Maybe Parallel & Concurrent Haskell discusses that?
11:49:27 <kleisli> exa: do you know how newline sensitive languages (ie python) resolve this problem? for example, in python, when the parser sees a newline inside a function definition, it could be the end of the definition or it could be a continuation
11:50:39 <geekosaur> python cconsiders whitespace a token
11:50:46 <geekosaur> and indentation disambiguates
11:51:07 <kleisli> ah, it's the indentation
12:05:03 <kderme> What I found is that due to Haskell's unspecified evaluation order, it is undeterministic which exception is thrown. For example, in cases like `(error "A") + (1 div 0)`. Not sure if this applies to async exceptions.
12:07:37 <CurryKingInHaske> Haskell is lazy it evaluates with call by value in this case because it is an arithmetic expression
12:07:56 <CurryKingInHaske> i guess (1 div 0) is evaluated first
12:08:16 <solonarv> your guess is not correct, there *is* no specific evaluation order
12:11:55 <merijn> Nondeterministic is insufficient
12:12:37 <merijn> If you read up on the semantics of imprecise exceptions you will find that, not only is the order unspecified, it's not even guaranteed to obey *any* order
12:13:22 <merijn> That is, an expression "foo" that *potentially* throws A, B, or C may throw *any* of those, even if that conflicts with the evaluation order specified by pattern matching
12:14:13 <slack1256> I got a `IO ()` that I want to run concurrently but I don't care if it throws an exception. I don't want to `wait` for it as I know it will terminate correctly of throw an exception but both will be done quickly. Does forkIO does work for me?
12:16:06 <CurryKingInHaske> https://controlc.com/4c46727e  can someone check on that code real quick maybe you can find my error quickly "main.hs:(9,1)-(12,80): Non-exhaustive patterns in function splitWords'   "
12:16:21 <merijn> CurryKingInHaske: Compily with -Wall and ghc will tell you
12:17:23 <geekosaur> slack1256, if I understand you correctly then yes, provided the program continues to run for long enough that the forked thread can either finish or throw
12:18:27 <geekosaur> "wait" isn't only about getting a result, since when the main thread exits all other threads are killed by the OS (i.e. no ThreadKilled exceptions are thrown, they simply terminate)
12:18:29 <slack1256> geekosaur: Yes the program continues indefinetly. But I wonder if that exception thrown by the forked thread could crash the whole program as it's uncaught.
12:19:16 <stevenxl> Hi folks. I am trying to run "stack build" at the root project of this package (https://github.com/NorfairKing/hastory)
12:19:20 <stevenxl> but I get the following error:
12:19:36 <stevenxl> error https://www.irccloud.com/pastebin/1NylfYiX/error
12:19:46 <stevenxl> I'm at a bit of a lose.
12:19:48 <[exa]> kleisli: sorry I was AFK. Parsers are not simple in many cases. Python has preprocessing step that inserts virtual tokens named somehow like 'indent' and 'dedent'
12:19:53 <geekosaur> iirc it just goes away because there's nothing in the thread to catch it. exception for things that actually corrupt runtime state but those should be RTS panics, not exceptions, and shouldn't happen in general
12:22:45 <slack1256> geekosaur: I got that impression too, but then I read the docs for forkIO: "The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and ThreadKilled, and passes all other exceptions to the uncaught exception handler."
12:23:20 <geekosaur> in that thread. so it prints a message and the thread goes away
12:23:34 <geekosaur> also -xc fires in a profiled build (stack trace)
12:23:42 <slack1256> !!!
12:24:23 <slack1256> I thought the uncaught exception handler was a global thing, but it seems it prints the exception when run with -xc .
12:24:44 <slack1256> Thanks geekosaur.
12:42:00 <CurryKingInHaske> https://controlc.com/4c46727e main.hs:(10,1)-(14,80): Non-exhaustive patterns in function splitWords' any ideas what im doing wrong ?
12:42:40 <geekosaur> did you compile it with -Wall ?
12:42:54 <CurryKingInHaske> want to return a list of words an nonwords when i give in an string
12:43:01 <CurryKingInHaske> how can i do it with repl.it
12:43:03 <CurryKingInHaske> ?
12:43:41 <geekosaur> I spot an issue right away, `null (x:xs)' is always False
12:44:34 <CurryKingInHaske> because of pattern matching right ?
12:45:05 <geekosaur> because the thing it tests is the (:) in the (x:xs)
12:45:39 <geekosaur> so you never handle the case where it's invoked with []
12:45:47 <geekosaur> which never matches (x:xs)
12:46:32 <geekosaur> also, all those `== True' s are needless verbiage; it's expecting booleans already
12:48:44 <CurryKingInHaske> ok i fixed it but same error https://controlc.com/fbdb78b4
12:52:36 <geekosaur> null list never fires now since it's always x:xs, null having been handled by the preceding variant. but that's not an error
12:53:04 <geekosaur> the next issue I see is you never handle the case where tempWord is empty, but that's the first thing that happens when you give it a nonempty string
12:54:14 <CurryKingInHaske> geekosaur: ok thanks for the tips i guess i make a break and try to fix it tomorrow
12:54:28 <geekosaur> this is the same issue as last time, (t:ts) is never empty, (:) is as opposed to []
12:54:36 <CurryKingInHaske> geekosaur but you were very helpful thanks
13:03:18 <d2ci8xc5> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))  
13:03:47 <d2ci8xc5> how does that last (a -> m b) function have access to the x value in a previous bind?
13:04:24 <[exa]> the `\x -> ...` binds `x` in the whole content 
13:04:30 <d2ci8xc5> As in what order is this evaluated?
13:04:32 <[exa]> the lambda actually ends with closing parenthesis
13:04:36 <[exa]> not before >>=
13:07:14 <d2ci8xc5> I mean which bind is evaluated first?
13:07:23 <d2ci8xc5> the leftmost or the rightmost?
13:07:52 <[exa]> the outermost one needs to be evaluated first to extract any result
13:07:53 <d2ci8xc5> Oh right this makes sense
13:07:55 <[exa]> i.e. the left one
13:08:22 <d2ci8xc5> thanks
13:08:43 <d2ci8xc5> Would be cool if there was a tool to view intermediate expression steps
13:08:50 <d2ci8xc5> Like a lot of textbooks do
13:08:52 <[exa]> there is, I'm actually just googling it
13:09:31 <geekosaur> ghc-vis? ghood?
13:09:35 <merijn> Note that the order of evaluation of >>= isn't specified
13:09:51 <merijn> The associativity laws guarantee this doesn't matter, though
13:11:15 <jle`> d2ci8xc5: if you have questions about what order something is evaluated in for Maybe in specific, you can step-by-step evaluate this
13:11:20 <jle`> but it does take some work, yeah
13:13:19 <[exa]> d2ci8xc5: you may try Debug.SimpleReflect but I guess geekosaur's suggestion will be better
13:24:45 <boxscape> do y'all supposed zurihac will happen this year?
13:26:01 <boxscape> s/supposed/suppose
13:26:15 <[exa]> when is the usual date for zurihac?
13:26:28 <boxscape> it's currently scheduled for 12th to 14th june 2020
13:26:36 <[exa]> hm, highly dependent
13:27:30 <ysangkok> i don't think governments can afford to restrict gatherings for very long, so it's probably gonna be decided by the event organizers
13:28:04 <[exa]> yesterday I had some meetings with swiss people cancelled and moved to September, but generally everyone seems to agree that all restrictions will continue "roughly until the beginning of May"
13:28:53 <[exa]> (by everyone I mean everyone who is confident to give an estimate)
13:29:48 <d2ci8xc5> what's so great about racket? Never heard of it
13:30:37 <ysangkok> d2ci8xc5: it embraces the dynamic and low amount of syntax lisp has, and therefore makes it easy to make your own DSL's for whatever
13:31:01 <ysangkok> d2ci8xc5: it also ships with an IDE and it is used for in a bunch of universities
13:31:24 <merijn> ysangkok: I'm not so sure, you could just as well ask whether they can afford to *not* keep restricting longer
13:31:48 <ysangkok> d2ci8xc5: but be careful, it is dynamically typed so it might be created by the Devil
13:32:53 * hackage haskell-src-exts-simple 1.23.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.23.0.0 (BertramFelgenhauer)
13:34:13 <ysangkok> merijn: we are getting into a discussion about economy :P it all comes down to what your values are, and what you think the values of governments are. but i think governments will tend to think in timeframes of up to a few months. whatever can keep the economy half-way afloat will do :P
13:36:06 <ysangkok> d2ci8xc5: but one very cool haskell related thing made with racket is the book, "The Little Typer", which is an introduction to dependent typing  in a  conversational format. that is obviously not dynamic, so not affiliated with the devil
13:36:12 <fog> ok! I think i managed to get the Free Sum correct; https://github.com/fog-hs/FreeSum/blob/master/HFFree.hs
13:38:55 <Netsu> Is there a way to avoid such constraint-type duplication? `m :: (Applicative a, Traversable a, Applicative b, Traversable b) => a x -> b x`
13:39:59 <Tuplanolla> You can define constraint synonyms with `ConstraintKinds`, Netsu.
13:40:06 <Netsu> smth like `(Applicative a; b, Traversable a; b)`
13:40:33 <Netsu> Tuplanolla: intresting
13:41:44 <dmwit> % type family All c ts where All c '[] = (); All c (t:ts) = (c t, All c ts)
13:41:44 <yahb> dmwit: 
13:42:22 <dmwit> % foo :: (All Applicative [f, g], All Applicative [f, g]) => f x -> g x; foo = undefined
13:42:22 <yahb> dmwit: ; <interactive>:9:9: error:; * Expected a constraint, but `All Applicative [f, g]' has kind `*'; * In the type signature: foo :: (All Applicative [f, g], All Applicative [f, g]) => f x -> g x; <interactive>:9:13: error:; * Expected kind `(* -> *) -> *', but `Applicative' has kind `(* -> *) -> Constraint'; * In the first argument of `All', namely `Applicative'; In the type signature
13:42:33 <dmwit> haha, whoops
13:42:48 <dmwit> % type family All c ts :: Constraint where All c '[] = (); All c (t:ts) = (c t, All c ts)
13:42:48 <yahb> dmwit: 
13:42:52 <dmwit> % foo :: (All Applicative [f, g], All Applicative [f, g]) => f x -> g x; foo = undefined
13:42:52 <yahb> dmwit: 
13:42:56 <dmwit> Netsu: ^
13:45:49 <ski> d2ci8xc5 : Scheme is nice. learn about macros (and hygiene). also continuations. you might like SICP
13:45:59 <ski> @where SICP
13:45:59 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
13:45:59 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
13:47:53 * ski . o O ( "Dirty Looking Hygiene" by Eli Barzilay in 2008-02-23 at <https://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html> )
13:49:16 <Netsu> dmwit: thanks, `type family All (c :: k -> Constraint) ts :: Constraint where All c '[] = (); All c (t:ts) = (c t, All c ts)` works as `m :: (All Applicative '[a, b], All Traversable '[a, b]) => a x -> b x` like a charm
13:49:52 * ski . o O ( "Interface-passing style" by Fare (François-René Rideau) in 2010-02-17 at <https://fare.livejournal.com/155094.html> )
13:50:31 <ysangkok> if you use TemplateHaskell, will you have to worry about hygiene?
13:51:21 <Tuplanolla> Sometimes you do, ysangkok.
13:53:05 <Netsu> BTW (according to hygiene) is there anything similar to ocaml's ppx?
13:53:55 <Netsu> the way to do an AST marks
13:54:06 <Netsu> *annotations
13:57:07 <justsomeguy> I'd love to read The Little Typer, but don't know any lisps yet. It's definitely on my reading list, after I get through haskellbook.
13:57:28 <justsomeguy> Dependently typed programming languages are so interesting.
14:09:31 <iqubic> I would love dependent Haskell.
14:11:18 <Tuplanolla> Are you sure?
14:12:53 * hackage cabal2nix 2.15.1 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.15.1 (PeterSimons)
14:17:13 <ski> justsomeguy : "The Little Schemer" (previously "The Little LISPer") by Daniel P. Friedman in 1995-12-21 (- ..) at <http://www.ccs.neu.edu/home/matthias/BTLS/>
14:23:37 <justsomeguy> Looks ideal. Another book added to my ever growing reading list.
14:26:32 <ysangkok> justsomeguy: you don't really need to know any lisp to understand the little typer
14:26:58 <ysangkok> justsomeguy: it is a book about typing, lisp is this case just a minimal syntax.
14:27:50 <ysangkok> justsomeguy: i havn't read the little schemer, and it got through it just fine
14:29:19 <justsomeguy> Ah, that's good to know. I suppose they'll explain the syntax as they introduce it to you, since it uses a language made just for that book (through racket). I debated whether I should learn list or not since it was mentioned in the preface.
14:31:55 <ski> justsomeguy : you could try watching at least the first few SICP lectures, they're quite entertaining, methinks
14:33:15 <justsomeguy> I'll probably do all of those things, since it's fun. :^) ... just after I finish the remaining 900 pages in haskellbook.
14:33:27 <justsomeguy> Or maybe along-side it.
14:37:59 * ski . o O ( "Project Scheduling – 80% Done, 80% Remaining" by Scott Sehlhorst in 2007-03-02 at <http://tynerblain.com/blog/2007/03/02/project-scheduling/> )
14:39:13 <justsomeguy> Heh, fair point.
14:40:20 <int-e> ski: I like the beginning of a project when it's more like 10%, 10%.
14:41:07 <int-e> (and you're still blissfully unaware of the majority of the iceberg)
14:43:17 <ski> yea, without Dunning-Kruger, we might never dare to start projects
14:48:12 <gendarme> justsomeguy: what's your reading list?
15:00:10 <justsomeguy> gendarme: Haskell Programming From First Principles (currently reading), An Introduction to Functional Programming Through Lambda Calculus (I'm a few chapters in, recently figured out the pred function in untyped LC, will be skimming a lot), Purely Functional Data Structures by Okasaki, Type-driven development with Idris, The Little Typer, The Little Schemer (probably), A Beginners Guide to Mathematical Logic, Concrete Mathematics by 
15:00:12 <justsomeguy> Knuth, The Algorithm Design Manual by Skiena, ... plus maybe ten others that I don't recall off hand.
15:02:04 <justsomeguy> ... also I'm learning Ansible right now, so reading a book on that. I've become very good about recording my progress so I can stop, come back to a book, and reorient myself quickly.
15:02:53 * hackage org-mode 1.1.0 - Parser for Emacs org-mode files.  https://hackage.haskell.org/package/org-mode-1.1.0 (fosskers)
15:03:00 <justsomeguy> The key for me was to keep a log of questions, and summarize paragraphs close to where I left off with post-its.
15:03:53 * hackage org-mode-lucid 1.1.1 - Lucid integration for org-mode.  https://hackage.haskell.org/package/org-mode-lucid-1.1.1 (fosskers)
15:06:53 <ski> interesting, justsomeguy
15:07:08 <justsomeguy> Still very early days with most of those books ... just scraping the tip of the iceberg. I guess I'm self learning CS?
15:08:33 <justsomeguy> It's a fun hobby ^_^.
15:09:42 <ski> @where book-acronyms
15:09:43 <lambdabot> mbishop's "List of popular programming book acronyms" at <http://web.archive.org/web/20080918051833/http://mbishop.esoteriq.org/stuff/books.txt>
15:10:22 <justsomeguy> Some acronyms would have shortened my list considerably.
15:10:33 <ski> some of those books are quite nice, imho
15:12:35 <ski> (SICP,CTM,HTDP,EOPL,TAPL,AIMA,..)
15:13:28 <[exa]> justsomeguy: I was learning scheme from 'teach yourself scheme in fixnum days'
15:14:18 <boxscape> good to know that LiSP is about Lisp
15:17:45 <justsomeguy> [exa]: That looks nice, too. And it's free. :^)
15:43:17 <lupulo> When should i use haskell?
15:43:44 <lupulo> as semantic expression with elisp...
15:45:24 * hackage dobutokO2 0.9.1.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.9.1.0 (OleksandrZhabenko)
16:13:23 * hackage eventstore 1.4.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.4.0 (YorickLaupa)
16:41:24 * hackage shake-bindist 1.0.0.0 - Rules for binary distributions  https://hackage.haskell.org/package/shake-bindist-1.0.0.0 (vmchale)
17:12:54 <aveltras> is there a typelevel equivalent for $ ?
17:17:37 <solonarv> aveltras: not that I'm aware of, but you can easily define it yourself
17:17:45 <solonarv> type f $ x = f x -- that's it
17:19:04 <aveltras> solonarv: seems that's not exactly the same here
17:20:09 <aveltras> https://www.irccloud.com/pastebin/AWa4Poje/
17:24:42 <mjrosenb_> is it possible to re-use part of a lens when setting? e.g. I have foo & ix i . _Bar . baz .~ 4 & ix i . _Bar . quux .~ False, and want to not repeat ix i . _Bar
17:25:38 <mjrosenb_> I can pull it out into a variable, but it still feels odd accessing ix i . _Bar twice
17:34:31 <lyxia> mjrosenb_: (%~)
17:57:49 <flebron> Hi folks. Say I'm using do-notation in the [] monad. I want to cancel this branch. I could do True <- [False], but that seems horrible. Is there a better way?
18:00:23 <pincel> guard, perhaps?
18:00:32 <glguy> You could write []
18:00:51 <flebron> You mean True <- []? I guess that also works, but still a bit ugly...
18:00:55 <glguy> No
18:01:15 <glguy> Drop the True <-
18:01:58 <flebron> Oh hrm. Why does that work? Seems a bit mysterious to the/this reader
18:02:11 <flebron> (I get a warning about an unused do, telling me to say _ <- [])
18:03:05 <glguy> That's from turning on too many warnings. You could also block that warning with [] :: [()] 
18:03:10 <flebron> I like the guard option, it's a bit clearer in saying what this is doing :) Thanks both!
18:03:37 <glguy> Guard is good if you have a condition to test
18:04:27 <glguy> Using [] is only surprising before you've learned about [] as a Monad and do notation
18:05:31 <whataname> what's the safe way to get the element from [] and avoid empty list?
18:05:38 <flebron> Oh I think I get it. The do-notation will mean that, because this is not a <-, it's a >>, so anything after this gets discarded?
18:05:52 <ysangkok> hmm, so i read that: xs >>= f = concat (map f xs)
18:05:54 <flebron> whataname: safeHead? (a.k.a. headMay)
18:05:59 <ysangkok> so in this case, xs is [] ?
18:06:40 <whataname> it may be
18:07:36 <flebron> ysangkok: >>= is part of the Monad typeclass, which means each type that wants to say it's a Monad must explain how to implement >>=. For lists, yes, the implementation of xs >>= f is, by definition, concat (map f xs).
18:08:03 <flebron> For other types that also want to claim to be Monads, >>= will have a different implementation.
18:08:09 <ysangkok> in that case, you could say that since haskell is lazy, the rest of your do block is the f, obviously mapping that function over the empty list is never going to get evaluated
18:08:16 <glguy> whataname: pattern matching
18:08:49 <glguy> listToMaybe for going from a list to a Maybe
18:09:02 <flebron> ysangkok: Well, I'm not doing any >>= if I just say "[]", I think.
18:09:13 <ysangkok> but if you have do, you have >>=, right?
18:09:27 <ysangkok> i mean, do-notation is just shorthand for >>=, no?
18:09:49 <glguy> Just []; ... in do notation becomes: [] >> ...
18:09:51 <flebron> I think so, so you may be right that there's a >>= even when there's no variable bounding anything.
18:10:41 <flebron> glguy: But really ysangkok and it's >>= that's called, right? (Since >> will just be default-implemented to >>= const () or something.)
18:10:48 <whataname> what if I don't take out the element from list, I just wrap the function into a list then using <*>
18:11:18 <whataname> but if I wrap a IO action into list, then <*> that would work?
18:12:52 <whataname> > print <*> [1,2]
18:12:55 <lambdabot>  error:
18:12:55 <lambdabot>      • Couldn't match expected type ‘[Integer -> b]’
18:12:55 <lambdabot>                    with actual type ‘() -> IO ()’
18:14:18 <glguy> flebron: >> will be called. It might happen to be implemented with >>= or might not, we'd have to look, but that's just an implementation detail
18:21:00 <flebron> I see. So the notation really does have a distinction between lines which have <-, and lines which don't.
18:22:42 <ysangkok> depends on the desugaring you use, i'd say, look at this example: https://wiki.haskell.org/Monad#do-notation
18:23:02 <ysangkok> the only difference is that you don't care about the parameter if you don't have a <-
18:23:43 <mjrosenb_> lyxia: ok, so I'd have to drop out of lensiness, and just write a function to do the updates individually?
18:23:55 <mjrosenb_> oh, no... .~ produces a function
18:24:50 <pacak> Are there any libraries out there that can take a list generated by let's say [1,5..215] and turn it back into something compact? Ideally with ability to handle missing elements?
18:25:10 <mjrosenb_> so I can do foo & ix i . _Bar %~ ((baz .~ 1) . (quux .~ False))
18:25:18 <mjrosenb_> possibly with fewer parens
18:25:44 <ysangkok> pacak: i guess a function definition is more compact than that list. so i guess you could you a library for regression?
18:27:11 <pacak> Hmm... Regression is not quite the same. I guess wrong description. I don't care how much memory it takes but I need to render it in compact way.
18:27:15 <sheepy63> Hello, what would be the better way of handling this? I can't use `MVar()` because the process `exec`s out of Haskell run-time. And still this `threadDelay` looks ugly. https://paste.debian.net/1134866/
18:27:50 <pacak> I want to turn [21000, 21500, 22000, 22500, 23000, 23500, 24000, 24500, 25000, 25500, 26000, 26500, 27000, 27500, 28000, 28500, 29000, 29500, 30000, 30500, 31000, 31500, 32000, 32500, 33000, 33500, 34000, 34500, 35000, 35500, 36000, 36500, 37000, 37500, 38000, 38500, 39000, 39500] into [21000, 21500 .. 39500]
18:28:24 <pacak> But in general case there can be less marks on outer edges
18:29:02 <pacak> I guess it's not a thing and it's time to invent a bicycle :)
18:29:05 <ysangkok> aaah this is a source code transformation?
18:29:56 <pacak> Pretty printing. I have a bunch of those ranges and currently it's too noisy.
18:30:16 <ysangkok> well i guess it is simple then, since haskell syntax only supports the ".." syntax for a few special cases...
18:31:30 <ysangkok> i wonder if there is a regression library that will let you avoid floating point inaccuracies...
18:31:54 <ysangkok> cause hmatrix-gsl-stats is full of Double's...
18:55:55 <pacak> http://dpaste.com/07NQ9NC
19:11:30 <frdg> myFunc d = pi * (r * r)where r = d / 2
19:11:56 <frdg> where should be on next line but I am confused on why this works. To me r and d should not be in each others scope
19:12:58 <pacak> As long as where is "inside" myFunc scope - every argument of d is in scope of where
19:14:21 <frdg> I just don't understand how you can incorporate d into the expression of r when d isn't completely defined
19:14:35 <frdg> d and r both rely on each other
19:14:56 <pacak> Hmm... How d can rely on r?
19:15:24 <pacak> in this case d is a parameter
19:15:40 <frdg> ohhhhh
19:15:46 <frdg> I get it now thanks
19:16:00 <mjrosenb_> you could do something like let x = myfunc (x+1), but that would not terminate
19:17:18 <pacak> > let fibs = 1:1:(zipWith (+) fibs (tail fibs)) in take 10 fibs
19:17:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:20:07 <flebron> Lens beginner question. If I have data Foo = Foo { _foo :: Int }; $(makeLenses ''Foo), and I have a [Foo], how do I get a [Int]?
19:20:20 <flebron> (I can map (^. foo), but that seems ugly-ish.)
19:20:59 <pacak> You can also go with map _foo...
19:21:13 <flebron> That too, yeah. I was wondering if there's a specific lensy way of doing that :)
19:21:26 <flebron> (i.e. some sort of "traverse foo" or whatever)
19:32:18 <dmwit> :t (^..)
19:32:19 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
19:32:53 * hackage extensible 0.8 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.8 (FumiakiKinoshita)
19:33:30 <dmwit> % data Foo = Foo { _foo :: Int }
19:33:30 <yahb> dmwit: 
19:33:35 <dmwit> % $(makeLenses ''Foo)
19:33:35 <yahb> dmwit: ; <interactive>:13:1: error:; parse error on input `$'; Perhaps you intended to use TemplateHaskell
19:33:42 <dmwit> % :set -XTemplateHaskell
19:33:42 <yahb> dmwit: 
19:33:43 <dmwit> % $(makeLenses ''Foo)
19:33:43 <yahb> dmwit: ; <interactive>:15:3: error:; * Couldn't match type `[Language.Haskell.TH.Syntax.Dec]' with `Language.Haskell.TH.Syntax.Exp'; Expected type: Language.Haskell.TH.Lib.Internal.ExpQ; Actual type: Language.Haskell.TH.Lib.Internal.DecsQ; * In the expression: makeLenses ''Foo; In the untyped splice: $(makeLenses ''Foo)
19:34:14 <dmwit> % foo f (Foo n) = Foo <$> f n
19:34:14 <yahb> dmwit: 
19:34:28 <dmwit> % [Foo 3, Foo 4] ^. each.foo
19:34:28 <yahb> dmwit: ; <interactive>:17:19: error:; * No instance for (Monoid Int) arising from a use of `each'; * In the first argument of `(.)', namely `each'; In the second argument of `(^.)', namely `each . foo'; In the expression: [Foo 3, Foo 4] ^. each . foo
19:34:39 <dmwit> Lens expert here, lmao
19:39:27 <dmwit> % [Foo 3, Foo 4] ^.. each.foo
19:39:27 <yahb> dmwit: [3,4]
19:39:34 <dmwit> flebron: ^
19:49:59 <amalloy> i had the idea today of knuckle tattoos labeled "pure" and "bind". (a) is there prior art for this somewhere that i subconsciously stole from? (b) any other cool functional-programming knuckle tattoo ideas?
20:05:53 * hackage incremental 0.2 - incremental update library  https://hackage.haskell.org/package/incremental-0.2 (FumiakiKinoshita)
20:06:53 <mjrosenb_> @hoogle Monad m => a -> m Bool ->[a] -> m (Maybe a)
20:06:54 <lambdabot> No results found
20:07:07 <mjrosenb_> welp, guess I need to write my own.
20:08:31 <pacak> Hmm... What would it do? O_o
20:08:41 <davean> I was wondering that too
20:08:54 <mjrosenb_> it would be called findM
20:08:58 <mjrosenb_> which apparently exists
20:09:01 <mjrosenb_> with that type
20:09:16 <pacak> Not with given constraints.
20:09:34 <mjrosenb_> derp
20:09:37 <davean> no, no findM is not that
20:09:38 <mjrosenb_> I forgot some parens
20:09:48 <mjrosenb_> @hoogle Monad m => (a -> m Bool) ->[a] -> m (Maybe a)
20:09:49 <lambdabot> Control.Monad.Loops firstM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
20:09:49 <lambdabot> Control.Monad.Extra findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
20:09:49 <lambdabot> Extra findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
20:09:57 * mjrosenb_ <- smrt
20:21:06 <mjrosenb_> well, I don't particularly feel like adding any of those packages right now, so I'll write it myself, and hope I remember if I need somethign from one of them again in the future.
20:38:46 <davean> mjrosenb_: curious what you have against adding them
20:51:45 <mjrosenb_> davean: I don't feel like killing the nix shell that I've been working in in order to rebuild the env.
20:59:53 * hackage codex 0.6.0.0 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.6.0.0 (parsonsmatt)
21:54:01 <hexo_> hi, is there a way to get thread count from runtime? please
22:24:31 <dmj`> hexo_: not that I know of
22:24:44 <dmj`> hexo_: why do you need the thread count
22:51:54 <davean> You can get how many capabilities there are, and you can get how deep the RTS work queue is, and I question why you'd want either.
23:19:16 <aviD> What are the major selling points of  cabal+nix over cabal?
