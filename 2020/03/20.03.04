00:03:00 <hololeap> one day i'll look back and laugh at what a n00b i was for using optics instead of lens
00:04:53 <hololeap> 13|\|5
00:08:55 <tdammers> doubt it
00:09:13 <tdammers> optics is pretty damn solid work by some extremely competent people
00:13:24 * hackage hasbolt-extras 0.0.1.3 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.1.3 (ozzzzz)
00:20:06 <edwardk> tdammers: to be fair the "I won't use it but knock yourself out" was during the second _year_ of them asking me about if I'd considered the approach they are using.
00:22:47 <tdammers> edwardk: yes, I know, I was there :)
00:23:16 <edwardk> and it amuses me that it is still a type synonym over a data type that opaquely wraps 2-3 layers worth of type synonyms. This is somehow simpler. =)
00:23:29 <tdammers> matter of mindset
00:23:38 <tdammers> the implementation isn't simpler
00:23:57 <edwardk> i'd also gleefully entertain benchmark comparisons
00:24:05 <edwardk> sure
00:24:15 <tdammers> but if you want to just "use lenses" without having to understand the underlying mechanics, then it can be helpful
00:24:43 <edwardk> i can understand that mentality
00:25:05 <edwardk> it just pretty much ensures that you won't learn any of the thoughts that led to lens through using it
00:25:15 <edwardk> which seems oddly paternalistic
00:25:37 <Io_> Noob question https://pastebin.com/p31ff7C4 How would I specify the Exception type if using a wildcard in the anonymous function?
00:25:50 <tdammers> I don't think it's meant to be patronizing
00:26:03 <tdammers> just catering to more, ahem, "pragmatic" needs
00:26:25 <edwardk> Io_: use a pattern signature handle (\(_ :: MyException) -> return Nothing) $ do
00:26:35 <Io_> amazing thanks!
00:26:50 <edwardk> Io_: you'll need to turn on an extension. it'll yell at you to do so
00:27:18 <tdammers> (it's not Elm, fwiw...)
00:27:23 <Io_> Ill figure it out, thank for pointing the right direction though
00:28:38 <edwardk> tdammers: i realize that by rising to reply i'm basically playing to the stereotype, so i'll stop =P
00:29:26 <hololeap> stereotype?
00:30:48 <tdammers> academic abstraction evangelist
00:30:54 <tdammers> or something like that
00:31:03 <tdammers> personally, I don't care much for stereotypes in general
00:31:22 <hololeap> lol, well someone needs to fill that role
00:31:49 <MarcelineVQ> the stereotype https://www.youtube.com/watch?v=u0iuaxvkXv4
00:31:51 <tdammers> I like to embrace the idea that things are seldom black and white, and also the idea that people tend to have brains capable of autonomous thought
00:33:49 <hololeap> MarcelineVQ: lol
00:35:12 <hololeap> if nobody was an academic abstraction evangelist, their awesome ideas wouldn't trickle down for people to complain about and re-implement :p
00:38:54 * hackage yesod-recaptcha2 1.0.0 - yesod recaptcha2  https://hackage.haskell.org/package/yesod-recaptcha2-1.0.0 (ncaq)
00:47:31 <tdammers> hololeap: it's more about people rejecting ideas for being "too academic"
00:48:56 <hololeap> i think that just comes with the territory
00:53:55 <hololeap> understanding cutting edge research requires a lot of previous knowledge. some people will inevitably feel overwhelmed by the task.
00:54:52 <hololeap> but that in no way subtracts from the usefulness or the need for that research
00:55:08 <juri_> just avoid impure programming, and let the academics tell you when you're being dumb. bang, you're now an OK haskeller. :)
00:59:01 <hololeap> yay!
01:08:48 <tdammers> impure programming is easy to avoid in haskell
01:09:13 <tdammers> just stay away from functions labeled "unsafe" or "accursedUnutterable"
01:25:46 <mjrosenb> haskell supports unicode identifiers, right?
01:26:05 <__monty__> Yes.
01:26:06 <mjrosenb> clearly, all of the unsafe functions should be replaced with zalgo.
02:05:24 * hackage yesod-form-bootstrap4 3.0.0 - renderBootstrap4  https://hackage.haskell.org/package/yesod-form-bootstrap4-3.0.0 (ncaq)
02:08:24 <kuribas> It's satisfying to make a dirty mutable implementation, wrapped by a pure and safe library.
02:09:24 <kuribas> I think that's what makes haskell different from other language, not because we avoid side-effects, but because we try to contain them.
02:22:08 <chloekek> I’m using standalone via deriving and I am getting an obscure error message that does not seem relevant. I get the error four times: https://gist.github.com/rightfold/3f7df13a53b116916e7326ff6bc4f335
02:22:11 <chloekek> Could this be a bug on GHC?
02:22:47 <chloekek> Passing -ddump-splices does not give any additional input (probably because I’m not using Template Haskell anyway).
02:23:34 <chloekek> (In that case, I think the mention of ‘f’ comes from the expansion of Fold.)
02:26:00 <boxscape> no idea what the error is but try enabling -ddump-deriv
02:26:09 <boxscape> ^ chloekek
02:26:21 <boxscape> (or rather, no idea where it comes from)
02:26:45 <chloekek> Thanks. I updated the gist.
02:27:05 <chloekek> I will try expanding Fold manually and see what happens.
02:28:01 <chloekek> Aha! That gives rise to a more sensible error about representations.
02:32:45 <sicklorkin> Is there a way to do expansion in gitconfig
02:32:46 <sicklorkin>         cb = rev-parse --abbrev-ref HEAD
02:32:46 <sicklorkin>         fpcb = git push --force origin/$(bb)
02:32:54 <sicklorkin> s/bb/cb/
02:33:14 <sicklorkin> (sorry a bit off topic)
02:55:23 <merijn> phadej: btw, you said you weren't interested in merging WIP github actions stuff into haskell-ci, but would you be open to refactorings to make haskell-ci support a more library-ish API (I haven't really checked to what extent it does now) so anything WIP can basically be developed independently without needing to maintain a fork of the entire haskell-ci repo to play with this
02:56:17 <merijn> phadej: Ah, actually looks like that's already mostly the case, so that's basically a matter of seeing if the current API fits well, I suppose
03:01:54 <sshine> sicklorkin, https://stackoverflow.com/questions/11262010/shell-variable-expansion-in-git-config -- it seems like you need to escape into shell from gitconfig before you can do that.
03:20:00 <sshine> sicklorkin, fpcb = !bash -c '"git push --force origin/$(bb)"'
03:26:28 <lhurttila> I'm trying to build a project that uses streamly and lens on windows using stack. Apparently the streamly package has a bug that causes an "unknown symbol `clock_gettime'" error and they're workign to fix it. I've commented out the streamly imports for now and the build completes if I don't use {-# LANGUAGE TemplateHaskell   #-} required by lens.
03:26:28 <lhurttila> When I add that language extension, the build fails because of the streamly bug. What's going on here?
03:27:34 <lhurttila> and i'm not using streamly anywhere in my code yet though it's listed in the dependencies
03:43:49 <immae> Hello there, I have the current situation: https://paste.ee/p/Bz2w8 in normal runs, I run stack build from there and it works. In a CI (gitlab-ci), I would like to run stack with --stack-root $(pwd)/.stack (the config.yml contains only nix keys (enable, pure, shell-file)), but I would also like to cache the .stack folder to speed up builds, but without caching the config.yml and shell.nix files of course.
03:43:51 <immae> The problem is that in this confiugration they’re along the built files I want to cache. Do I have a way to use a config file separated from the rest of the built files?
03:48:54 * hackage mmsyn7ukr 0.15.3.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.15.3.0 (OleksandrZhabenko)
03:51:54 * hackage mini-egison 1.0.0 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-1.0.0 (SatoshiEgi)
04:28:24 * hackage HaTeX 3.22.1.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.22.1.0 (DanielDiaz)
05:32:48 <zceejkr> ski, are you here?
05:35:56 <foobar95> @help
05:35:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:50:51 <rsoeldner> when using hspec, how can I just check if my element is a `Right` :: Either ?
05:51:48 <boxscape> @hoogle isRight
05:51:48 <lambdabot> Data.Either isRight :: Either a b -> Bool
05:51:48 <lambdabot> Data.Either.Combinators isRight :: Either a b -> Bool
05:51:48 <lambdabot> Data.Either.Compat isRight :: () => Either a b -> Bool
05:52:10 <Steezle> Ok so I need help with a coursework assignment that is due in today.
05:52:11 <Steezle> could look at it and fix it up that would be grand and I would forever be in your debt '=D 
05:52:20 <Steezle> https://hastebin.com/jopaqivage.shell
05:52:26 <rsoeldner> boxscape, thank you :)
05:52:54 <boxscape> np
06:37:53 <abc325> about parser, is there a good lecture?
07:00:54 * hackage tree-sitter-ql 0.1.0.0 - Tree-sitter grammar/parser for QL  https://hackage.haskell.org/package/tree-sitter-ql-0.1.0.0 (rewinfrey)
07:10:53 <adamCS> I've got a module which compiles in reasonable time using ghcid but when I compile with cabal directly the memory use/time goes way up.  I've got "{-# OPTIONS_GHC -O0 -freduction-depth=0 #-}" up top--the reduction-depth=0 being required by the Frames bit that is causing the memory blowup in the first place.  Any ideas what other ghc flags ghcid might be setting that make this module compile faster?
07:15:22 <dminuoso> adamCS: Code generation perhaps?
07:16:12 <adamCS> You mean "-fno-code"?  Oh.  Yes.  Darn.  I had forgotten I was running without the "--test" on.  I bet that's it.
07:16:22 <adamCS> dminuouso: Thanks!
07:16:42 <adamCS> dminuoso: ^
07:17:57 <dminuoso> adamCS: For test, it'd be -fobject-code
07:18:07 <dminuoso> (Or TH)
07:18:16 <dminuoso> But ghcid by itself runs with -fno-code
07:18:36 <dminuoso> So if you do have TH code, you'll need -fobject-code instead.
07:19:36 <adamCS> right.  I was noticing the mem difference when I wasn't running the test.  So I bet it's no-code.  Which doesn't help much!  I was hoping there was some other flag that might explain the smaller footprint.  
07:20:18 <adamCS> Alas, for now, I'll just have to wait while my machine swaps.  And hope I can make that module not recompile very often.
07:21:15 <dminuoso> adamCS: Try running ghcid with strace perhaps, to get the command line arguments quickly?
07:24:39 <adamCS> I'm on OSX and I'm not sure how to do that...dtruss maybe?  
07:25:05 <merijn> dtruss or dtrace, yeah
07:27:51 <adamCS> Command is new to me.  Roughly, what's the syntax?
07:28:26 <merijn> adamCS: tbh, no idea, it's been ages since I used dtrace
07:29:10 <dminuoso> adamCS: In that case, it's probably easier to just clone the repo and insert some `trace` command.
07:29:13 <dminuoso> And then build it
07:29:25 <dminuoso> It's what I'd do. :)
07:29:59 <merijn> adamCS: SO to the rescue: https://stackoverflow.com/questions/39189347/tracing-system-calls-using-dtrace
07:30:57 <adamCS> So I tried that. I think.  And I didn't get the calls to "ghc".  At least not where I could see them...
07:32:46 <merijn> adamCS: With dtrace you could also get it to report *all* exec calls involving GHC, but that'd involve a bit of time on how to query the right dtrace info
07:34:25 <adamCS> merjin, dminuoso: Yeah.  I don't think that time is worth it right now.  I don't think I can fix with compiler flags.  I'll just deal with the long compile time once in a while or try to figure out how to load a subset of columns in Frames.
07:34:46 <adamCS> merijn, dminuoso: Thanks for all the help!
07:34:52 <dminuoso> adamCS: Like I said. If you just clone the ghcid repository and insert a single trace command, you'll have that information available. :)
07:35:00 <dminuoso> It should take no more than a minute or to
07:36:14 <adamCS> dminuoso: I think your minutes and my minutes might be different lengths!  
07:36:22 <merijn> It's a shame there isn't more easy/quickstart docs for DTrace, I remember loving it last time I dove into it
07:38:54 <dminuoso> adamCS: git clone, insert `print opts` right after opts is prepared in src/Ghcid.hs, `cabal v2-exec ghcid -- <arguments here` 
07:39:00 <dminuoso> Done! :)
07:43:22 <dmesg> Hi there! I have the following code which reads records from a CSV and parses them -- it's really slow and profiling seems to indicate it's my parseTimestamp function, any ideas what I can do to make that more performant/reduce allocations? http://dpaste.com/072THFX
07:46:32 <hyperisco> I am guessing that you'd want to get the specifiers compiled ahead-of-time
07:46:36 <dminuoso> dmesg: Did you compile with optimization enabled?
07:46:58 <hyperisco> but I am not sure if that is possible with that library
07:47:44 <dmesg> dminuoso: I believe so? I did stack run --profile
07:48:20 <dmesg> hyperisco by specifiers are you referring to the format string? Kinda like pre-compiling a regex?
07:48:26 <hyperisco> yes
07:48:50 <dminuoso> dmesg: I dont know stack, so I can't say
07:49:47 <hyperisco> otherwise it is doing this work every time https://hackage.haskell.org/package/time-1.9.3/docs/src/Data.Time.Format.Parse.Class.html#parseSpecifiers
07:51:12 <pie_[bnc]> have you guys seen anything about running multiple processes + communication to get some kind of runtume-reloadable plugin architecture
07:51:38 <pie_[bnc]> (im also interested in any good reading material about plugin systems)
07:51:58 <dminuoso> pie_[bnc]: Facebook is doing it. Simon Marlow held a talk about it on Skillsmatter in 2018.
07:52:13 <hyperisco> just taking a poke around I am not confident that library really has speed in mind
07:52:23 <pie_[bnc]> dminuoso: huh
07:52:26 <dminuoso> They switch out shared objects at runtime
07:52:30 <pie_[bnc]> dminuoso: tbh i cant rememberho i ran across the idea
07:52:45 <pie_[bnc]> dminuoso: actualy didnt facebook do something with their own linker, or did they switch that out
07:52:54 <pie_[bnc]> i remember listening ot something on the haskell cast a while back
07:53:05 <dminuoso> pie_[bnc]: At runtime they just swap out libraries.
07:53:10 <hyperisco> if you really wanted fast you'd precompile a parser
07:53:11 <dminuoso> pie_[bnc]: It's to faciliate live updates
07:53:12 <dmesg> bummer, I picked the `time` package since I figured it was the standard? Is there a better datetime parsing lib I should be using?
07:54:01 <dminuoso> dmesg: Consider `hourglass` maybe?
07:54:39 <pie_[bnc]> dminuoso: makes sense i guess
07:54:47 <dminuoso> dmesg: There appears to be `chronos` as well, which uses attoparsec
07:55:28 <dminuoso> pie_[bnc]: I dont recall the details anymore, but it required some pretty in depth knowledge of how GHC compiles stuff, how the RTS works, etc.
07:55:41 <dminuoso> But I suppose Simon Marlow knows a few things about GHC. :)
07:56:29 <pie_[bnc]> well, thats kind of why i figured multiprocess + interface instead of trying to figure out how does babby GHC :I
07:56:41 <merijn> pie_[bnc]: dons' phd thesis is probably a good starting point too
07:56:58 <pie_[bnc]> which would that be
07:57:07 <pie_[bnc]> sidenote: i am still noob
07:57:22 <merijn> pie_[bnc]: https://pdfs.semanticscholar.org/92f6/f7b25a91eba0fb7ac981a9a3e7f8ac8155aa.pdf
07:57:41 <merijn> pie_[bnc]: His phd thesis was on how to extend typed languages with plugins
07:57:52 <pie_[bnc]> hm
07:58:00 <pie_[bnc]> certainly sounds relevant
07:58:01 <merijn> I think Facebook's stuff is mostly based around essentially dlopen'ing shared libraries
07:58:33 <merijn> pie_[bnc]: There's a corresponding library too, but not sure how well it works: https://hackage.haskell.org/package/plugins
07:59:03 <pie_[bnc]> it worked at some point in time with some version of GHC :P
07:59:05 <pie_[bnc]> sigh
08:02:03 <zceejkr> ski are you online?
08:03:30 <hyperisco> dmesg, not every library has every objective in mind. Sorry that it isn't working for your use case
08:03:37 <dminuoso> pie_[bnc]: https://simonmar.github.io/posts/2017-10-17-hotswapping-haskell.html
08:04:02 <dminuoso> pie_[bnc]: So it was the ghc-hotswap* libraries
08:05:17 <hexagoxel> is there a way to convince stack to print a proper list of local (non-external) dependencies of a local component (in a multiple-package project)
08:06:40 <dmesg> hyperisco, totally reasonable. I'll go try with hourglass or chronos and see if I get better results. The tricky part is the input date includes microseconds which a lot of the parsers don't seem to like
08:06:55 <hexagoxel> I had expected `stack ls dependencies --no-external $MYCOMPONENT` to work, but it prints one line (the package name that contains $MYCOMPONENT)
08:09:08 <devalot> Has anyone seen any articles or implementations of a rose tree using recursion schemes?
08:10:17 <pie_[bnc]> dminuoso: thanks ill look
08:11:02 <dminuoso> hexagoxel: The same way you'd do it with cabal.
08:11:17 <dminuoso> hexagoxel: Just ensure you generate your package.cabal and make it a plain cabal problem. ;)
08:12:26 <devalot> Of course Bartosz Milewski has an article on this!  Just took some deeper digging to find.
08:13:44 <hexagoxel> dminuoso: what?
08:23:51 <hexagoxel> dminuoso: I take it you were making a stupid joke in the cabal-vs-stack realm. Please don't. It is not funny.
08:27:03 <ski> zceejkr : yes
08:28:11 <zceejkr> Hi, how is it going?
08:28:33 <dminuoso> hexagoxel: Ohh, sorry. I misread your question, I'm a bit sick currently. It seemed as you wanted to know about dependencies in general.
08:29:02 <dminuoso> hexagoxel: In principle my argument remains though, not for your problem though. The build-plan is all cabal, stack has no say in this.
08:30:05 <zceejkr>  ski: are you free to continue with type algebra?
08:31:09 <ski> hm, yea, i think so
08:31:25 <ski> trying to recall which day was the last time
08:32:16 <zceejkr> I think it was Thursday. We ended with laws about *, + and -> for types. Also you droped a few interesting links to some papers/
08:33:33 <zceejkr> ski: oh, and I think you were about to explain how exsistentials are actually implemented in haskell.
08:36:55 <ski> hm, yea, i think we'd gotten a bit into the meaning of existentials, touching a little on uses
08:37:49 <ski> did you try as an exercise to understand in particular any of the "type algebra" laws i mentioned ?
08:38:41 <zceejkr> I did. I implemented the transformations both ways in haskell. But I was unable to do it for the 2 laws about Void, can they be done in actualy haskell or not?
08:39:33 <zceejkr> a^0 = 1
08:39:37 <zceejkr> this one for example
08:40:00 <ski> yea, you need some extensions for those
08:41:18 <zceejkr> also I managed to figure out this one: a^(b0 * b1) = (a^b0)^b1, yields curry and uncurry, depending on which way you go
08:43:04 <ski> yes, good
08:45:13 <ski> so, the (canonical) data type corresponding to `0' is usually called `Void' in Haskell
08:45:28 <ski> @let data Void
08:45:31 <lambdabot>  Defined.
08:46:46 <ski> the `EmptyDataDecls' extension allows one to declare a `data' type with zero data constructors, like this
08:47:08 <boxscape> Isn't that enabled by default in Haskell2010?
08:47:17 <ski> yes, i think so
08:47:46 <zceejkr> I see. I tried it in my file and it loads fine in ghci.
08:48:00 <ski> then, to construct an inhabitant of `a^0', we need to make a function that takes a `Void' as input, and has `a' as return type
08:48:10 <ski> let's make a comparision
08:48:14 <ski> @src Either
08:48:14 <lambdabot> Source not found. There are some things that I just don't know.
08:48:22 <ski>   data Either a b = Left  a
08:48:32 <ski>                   | Right b
08:49:06 <ski> there's a standard function to do general case distinction on `Either', called `either'
08:49:39 <ski>   either :: forall a b. (       a   -> o)
08:49:55 <ski>                      -> (         b -> o)
08:50:03 <ski>                      -> (Either a b -> o)
08:50:23 <ski>   either left right (Left  a) = left  a
08:50:32 <ski>   either left right (Right b) = right b
08:51:06 <zceejkr> Is this the law: a^(b0 + b1) = a^b0 * a^b1
08:51:14 <zceejkr> From left to right
08:51:19 <zceejkr> SOrry right to left
08:51:35 <ski> you can think of it as taking a `Left'-handing branch, here called `left', and a `Right'-handling branch, here called `right', selecting the appropriate one to use, depending on whether the input is `Left a' or `Right b'
08:51:40 <ski> yes
08:52:06 <zceejkr> I remembered implementing this one when going over the laws :)
08:52:10 <ski> you can also think of it as combining a function handling `a', and a function handling `b', into a function handling `Either a b'
08:52:25 <zceejkr> I see.
08:52:31 <ski> (which is the reading the formatting of the type signature was intended to high-light)
08:53:27 <ski> so, `a^(b0 + b1) = a^b0 * a^b1' is an exponent law, when the exponent is a binary sum
08:53:57 <ski> similarly, `a^0 = 1' is the corresponding exponentiation law, when the exponent is a nullary sum
08:54:51 <ski> so, what we need, is to pattern-match, having zero, rather than two, alternatives/branches. because `Either a b' has two data constructors, but `Void' has zero
08:55:45 <ski> however, the Haskell syntax doesn't allow one to have zero defining equations for an operation. it would be interpreted as having forgot to give any definition at all
08:56:31 <ski> still, it is possible (with another extension), to have a `case'-`of' with zero branches
08:56:41 <ski> so, just like one could write
08:56:52 <ski>   either left right e = case e of
08:56:58 <ski>     Left  a -> left a
08:57:04 <ski>     Right b -> right b
08:57:39 <ski> we can define (actually just noticed i missed `forall'-ing `o' with `either' above) :
08:57:52 <ski>   void :: forall o. Void -> o
08:58:05 <ski>   void v = case v of {}
08:58:19 <ski> (explicit curly brackets for emphasis)
08:58:38 <ski> this requires the `EmptyCase' extension
08:59:08 <zceejkr> but we can never call this function, right? 
08:59:29 <ski> well, we could fake an input of type `Void', e.g. `undefined :: Void'
08:59:59 <ski> and then the function would force the input, exposing our bluff by triggering that `undefined'
09:00:56 <ski> there are zero legitimate/total values of type `Void', and so we need zero alternatives, when doing `case' distinction. and having zero alternatives is considered exhaustive, in this case
09:01:23 <zceejkr> i see.
09:01:37 <ski> if you think of a function as a table of input|->output mappings, then this table is empty, since there's no legitimate inputs
09:01:47 <ski> in math, it's called an "empty function"
09:02:23 <ski> now, one can of course ask whether there's any utility of having such a `data' type, `Void'
09:02:53 <zceejkr> I would ask that indeed :)
09:03:03 <ski> just as one can ask what the utility of the (empty tuple type) type `()' is (which would correspond to `1' in type algebra)
09:04:06 <ski> (also note that it's the `()' type (pronounced "unit") which corresponds to the type `void', as in C,C++,Java,C#,&c. .. not this `Void' type)
09:04:17 <ski> well, consider e.g.
09:04:21 <ski> @type putStrLn
09:04:22 <lambdabot> String -> IO ()
09:05:05 <ski> the type `()' is here used as a "dummy return type", where a return type, and corresponding value, is required, but we don't actually have any interesting value to return
09:06:50 <ski> note that `a -> ()' is equivalent to `()' (that's `1^a = 1'). if we get no interesting output at all, then we might just as well forget about passing the input, it doesn't make any difference
09:07:33 <ski> but `IO ()' represents doing some `IO'-effects, in addition to "monadically computing a result" of type `()' (so, an uninteresting result, here)
09:09:07 <ski> in a language with eager evaluation, one could also sometimes have a use for a type like `() -> a', delaying the evaluation of the result of type `a' (which might be expensive to compute). but in Haskell, this is equivalent to `a' (that's law `a^1 = a')
09:09:47 <zceejkr> i see.
09:09:56 <boxscape> % undefined `seq` True
09:09:56 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:201:1 in interactive:Ghci78
09:10:06 <boxscape> % (\() -> undefined) `seq` True
09:10:06 <yahb> boxscape: True
09:10:12 <boxscape> doesn't seem like they're the same?
09:10:20 <boxscape> I mean
09:10:25 <boxscape> I admit I forced evaluation
09:10:31 <boxscape> but that's still haskell
09:10:56 <ski> one can also imagine implementing `Set a' (a type of finite subsets, with elements of type `a') as `Map a ()' (a type of finite (partial) maps, mapping (some) "keys" of type `a' to "values" of type `()'. but there is just one of the latter, so only the "keys" present matters)
09:10:58 <tabaqui1> boxscape: because it's a partially applied functions, which is in WHNF
09:11:18 <tabaqui1> (undefined,) `seq` True
09:11:21 <tabaqui1> % (undefined,) `seq` True
09:11:21 <yahb> tabaqui1: True
09:11:28 <tabaqui1> % (+ undefined) `seq` True
09:11:29 <yahb> tabaqui1: True
09:11:33 <boxscape> tabaqui right I didn't really expect them to be the same, I was responding to ski's point about how they're equivalent
09:12:02 <boxscape> in haskell
09:12:11 <zceejkr> :t seq
09:12:12 <lambdabot> a -> b -> b
09:12:13 <tabaqui1> ah, didn't notice the context
09:12:15 <tabaqui1> sure
09:12:40 <ski> yes, there are some subtleties regarding `seq', which muddies the waters. taking those into account, the laws that i mentioned doesn't hold exactly. however, ignoring such partial values, the laws are useful ways of reasoning, which one can use to reason about, and refactor types, and correspondingly change representations used in code
09:13:54 <ski> (`seq', and the related `BangPatterns' extension)
09:14:31 <ski> anyway, asking about the utility of `()' and `Void' is a bit like asking what's the point of having numbers `1' and `0'
09:14:48 <ski> (iirc, ancient greeks didn't even consider `1' to be a number)
09:15:07 <ski> they can be useful as extreme/limiting cases
09:15:33 <ski> e.g., what's the point of `pure'/`return' for idioms/monads ?
09:15:40 <siraben> Anyone know of papers on whitespace-sensitive parsing?
09:15:44 <ski>   return :: forall a. a -> IO a
09:15:56 <ski> to be a bit concrete, taking `IO' as example
09:16:23 <zceejkr> I kinda see the point of Unit. But Is Void ever used when writing haskell code in practice?
09:16:55 <ski> well, in an `if'-`then'-`else', you can decide to do something, in one branch, and "not do anything", in the other branch. the latter means using `return' (or `pure'), to construct a trivial/dummy action
09:17:46 <ski> well, i actually used `Void', in a non-trivial, practical, piece of code
09:18:15 <ski> btw, you know some `C', yes ?
09:18:41 <zceejkr> a little bit, yes
09:19:04 <ski> there is an `exit' "function" there
09:19:11 <ski>   void exit(int status);
09:19:18 <ski> calling it never returns
09:19:46 <ski> one could perhaps have imagined it being declared something like
09:19:52 <ski>   noreturn exit(int status);
09:20:13 <ski> instead, `noreturn' being a type of "non-returning expressions"
09:20:25 <ski> now, `noreturn' corresponds to our `Void' above !
09:20:34 <ski> in Haskell there's
09:20:43 <ski>   exitSuccess :: forall a. IO a
09:21:17 <ski> but it could just as well have been declared as
09:21:25 <ski>   exitSuccess :: IO Void
09:22:05 <solonarv> for another comparison, Rust has a type called "never", written !
09:22:13 <solonarv> it's the type of infinite loops!
09:22:48 <zceejkr> I see.
09:23:00 <boxscape> % System.Exit.exitSuccess >>= \apple -> print apple
09:23:00 <yahb> boxscape: *** Exception: ExitSuccess
09:23:24 <ski> (if you think of `Bool' as requiring `log_2 2 = 1' bit of storage, then `()' requires `log_2 1 = 0' bits of storage (so no return value storage needed). attempting to continue this line of thought for `Void', we get `log_2 0 = -infinity', so it seems this kind of reasoning breaks down here)
09:24:00 <ski>   forever :: forall i a b. Applicative i => i a -> i b
09:24:04 <ski> is another example
09:24:06 <boxscape> I think it's fine? I mean, you can't have a value of type Void, so obviously the space you need for a value of type Void isn't defined
09:24:09 <ski> could have been declared as
09:24:20 <ski>   forever :: forall i. Applicative i => i () -> i Void
09:24:51 <ski> an infinite loop never returns, and so having `Void' as idiomatic or monadic return type makes sense
09:25:35 <solonarv> but when it's in a "return type" position, you often see a forall-bound type variable instead of Void, because it's more convenient that way
09:25:37 <ski> yea, boxscape, i suppose one can interpret it as saying "an expression of this type can't possibly return a value"
09:25:41 <ski> yes
09:25:48 <ski> another example of the same thing is
09:26:35 <ski>   mapM_ :: forall m a b. (a -> m b) -> ([a] -> m ())
09:26:42 <AWizzArd> If I want to use Nix (plus either cabal or stack) for a Haskell project, will I then typically need two .nix files? A default.nix which contains my Haskell+OS dependencies, and one release.nix which will essentially reference the default.nix file, and which will be the input to nix-build?
09:26:43 <ski> this could just as well have been
09:26:49 <ski>   mapM_ :: forall m a. (a -> m ()) -> ([a] -> m ())
09:26:50 <monochrom> The difference between "no information" and "magically whatever information you like" is like heaven vs hell.  I hope you can agree with this.
09:26:55 <boxscape> to be clear you can get the forall a . IO a version very easily by just writing `fmap absurd exitSuccess`, where `absurd :: forall a . Void -> a; absurd x = case x of {}`
09:27:06 <boxscape> monochrom no information would be ()
09:27:12 <monochrom> And () = "no information", Void = "magically whatever information you like".
09:27:14 <monochrom> Yes.
09:27:22 <ski> yea, what i called `void' above is called `absurd', in the library
09:27:28 <monochrom> So "putStrLn :: String -> IO Void" is wrong.
09:27:37 <ski> (i prefer the name `void', though, in analogy with the `either' function for `Either')
09:27:43 <boxscape> monochrom I thought you were disagreeing with Void and forall a . a being the same :)
09:27:49 <monochrom> Despite intuition from C.
09:28:02 <monochrom> Ah OK! We're in violent agreement!
09:28:08 <boxscape> indeed!
09:29:34 <frobnicator> hi, is there such a thing as a class collection in Haskell (defining classes in terms of other classes, e.g. like in Clean: https://cloogle.org/doc/#CleanRep.2.2_8.htm;jump=_Toc311798064)
09:30:41 <solonarv> frobnicator: yes, and there are plenty of examples of this even in the standard library
09:31:06 <berndl> frobnicator: class (Plus a, Minus a) => Arith a where ...
09:31:25 <ski> > (`execStateT` 1) (forever (do n <- get; if (n >= 1000) then throwError n else put (2 * n)) :: StateT Integer (Either Integer) Void)
09:31:28 <lambdabot>  Left 1024
09:31:35 <zceejkr> So this: void :: forall o. Void -> o is basically the "principle of explosion"
09:31:37 <solonarv> for example, 'Eq' (which provides == and /=) is a superclass of 'Ord' (which has all the comparison operators: <, >=, ...)
09:31:50 <ski> zceejkr : ^ that's an example of an "infinite loop", having `Void' as monadic return type
09:32:01 <ski> zceejkr : logically speaking, yes
09:32:44 <frobnicator> berndl: I see, I wasn't aware that a class doesn't have to have members (you can omit the where in your example)
09:32:47 <frobnicator> solonarv: thanks
09:33:13 <ski> zceejkr : note that "infinite loop" does not preclude aborting the computation, bailing out early. neither with a "pure Haskell" loop involving only `StateT' and `Either', nor with `IO' (which isn't defined in Haskell)
09:33:26 <solonarv> frobnicator: the only time I see an empty class like that is when it's used as a better alias
09:33:44 <frobnicator> yes, for example: class (Num a, Eq a) => NumEq a
09:34:00 <solonarv> don't forget the instance: instance (Num a, Eq a) => NumEq a
09:34:04 <zceejkr> ski: I see
09:34:56 <ski> zceejkr : so, i had implemented cooperative coroutining, for playing around with Turtle graphics a bit (spawning off multiple "turtles", which drew concurrently)
09:35:08 <frobnicator> ah okay, that is a difference then with Clean. In Clean, a class collection is just an alias, writing NumEq a => ... would mean the same as writing (Num a, Eq a) => ...
09:35:31 <ski> er, s/cooperative coroutining/cooperative concurrency/
09:35:37 <frobnicator> well, it is not just an alias, I think it does get packed in a new class dictionary, but you don't need to create an empty instance
09:36:32 <zceejkr> ski: like a swarm inteligence?
09:36:42 <ski> zceejkr : i had a `SystemM' monad, for expressing such operations. so, i had `fork :: SystemM () -> SystemM ()',`yield :: SystemM ()',`kill :: SystemM ()', and so on
09:37:32 <ski> however, in my implementation of this (which involved continuation stuff, in order to switch between multiple different "threads of control"), i had a bunch of `undefined's, which i wasn't happy about
09:38:24 <ski> i thought they could never be triggered, but there could easily be some corner case i'd forgotten about, getting it wrong
09:38:46 <ski> so, i realized that the correct type signatures of `fork' and `kill' should really be
09:38:56 <ski>   fork :: SystemM Void -> SystemM ()
09:39:03 <ski>   kill :: SystemM Void
09:39:32 <ski> so, i changed some `()'s to `Void', and managed to get rid of those `undefined's as a result
09:40:22 <zceejkr> I see. 
09:40:34 <ski> so, an action of type `SystemM Void' here was an action that either didn't terminate (normally) because it went off to infinity, never stopping. or because it ultimately used `kill' to terminate itself
09:41:48 <ski> so, i guess my point is that `Void' isn't that commonly needed, but that there can still be cases where it can be useful
09:42:18 <ski> and yes, `forall a. a' is equivalent to `Void', as someone mentioned. just like `exists a. a' is equivalent to `()'
09:43:12 <ski> in the `exists a. a' case, you have a value of type `a', and you have no idea what the type is. so, you can't possibly distinguish between possibly different values of type `a'. so you might just as well have an empty tuple of type `()'
09:45:45 <ski> hm
09:46:10 <ski> i think i wanted to say something about existentials and class constraints
09:46:29 <ski> and also something about existentials and rank-2
09:46:53 <zceejkr> Can it be said that 'exists a. a' is equal to () because it is says something like "How many types can a value have? One."
09:47:07 <ski> before getting to the (two) way(s) of representing existentials
09:47:33 <ski> hm, i'm not sure that makes sense
09:47:52 <zceejkr> Yeah nevermind.
09:48:23 <ski> well, if you consider `forall a. a -> a' (and we forget about infinite loops, `undefined's and other "bottom" values)
09:48:54 <ski> then, whoever constructs such a polymorphic value has no idea what type `a' will be picked by the caller, and has no way to detect it
09:49:11 <ski> so, the only thing it can do is to return the argument of type `a'
09:49:20 <ski> so `forall a. a -> a' is equivalent to `()'
09:49:47 <ski> similarly, in `forall a. a -> a -> a', it can only return one or the other of the two inputs. so this is equivalent to `Bool'
09:50:09 <ski> (`Bool' corresponding to `1 + 1', or `2' for short)
09:52:01 <ski> however, if you have say `forall a. (a -> a) -> a -> a', then one can apply the callback as (finitely) many times as one likes to the other input, before returning the result. so this is equivalent to `Natural', given `data Natural = Zero | Succ Natural', a type of natural numbers where e.g. `3' is represented as `Succ (Succ (Succ Zero))'
09:53:08 <ski> (sometimes this is called "unary numerals", but i think that's improper. this isn't "base one", it's not a representation with any base. one could say it's a "Peano numeral" representation, since it corresponds to the Peano axioms for natural numbers)
09:54:04 <wildtrees> wouldn't "base one" be counting with tick marks? 
09:54:50 <sshine> tick marks don't exactly work like base-N for N > 1.
09:55:17 <ski> (btw, one could write `Natural = 1 + Natural' in "type algebra", this being a recursive equation. now, equations can sometimes have multiple solutions. in this case, we intend the "smallest" solution, only having finite numbers. there is another ("largest") solution, which allows also `infinity :: Natural; infinity = Succ infinity'. because of Haskell being non-strict, it doesn't distinguish these two cases)
09:55:25 <sshine> one difference is that zero is "" and not "0" :)
09:55:36 * ski nods to sshine
09:56:04 <ski> anyway .. let's continue about existentials, ok, zceejkr ?
09:56:11 <zceejkr> ski: sure
09:56:34 <ski> recall
09:56:45 <ski>   take :: forall a. Int -> [a] -> [a]
09:57:31 <ski> we can think of the `forall a.' part in the type as specifying there's to be a type argument, called `a', which is implicit (normally, unless one uses `TypeApplications')
09:57:39 <ski> similarly, with
09:57:49 <ski>   sort :: forall a. Ord a => [a] -> [a]
09:59:00 <ski> there's both an implicit type argument `a', and an implicit "dictionary" (/ "method record" / "vtable") corresponding to the implementation of the methods of `Ord' for the particular type `a', given in some `instance' declaration
10:00:18 <ski> now, consider a type `[exists a. Show a *> a]'. a value of this type is a list, each element of the list is of type `a', for some type `a', which is known to be an instance of `Show' (but nothing else is known about `a')
10:00:32 <ski> this is a "heterogenous" list
10:01:11 <ski> the notation `*>' (which is pseudo-Haskell) is intended to be an analogue to `=>'
10:02:10 <zceejkr> wait so in this list, all elements are the same type? Or is it the case they can be of different type, as long as they have a Show instance?
10:02:20 <ski> yes, the latter
10:02:30 <ski> the former would be `exists a. Show *> [a]'
10:03:02 <ski> each element (possibly) has its own type `a', with `[exists a. Show a *> a]'
10:03:27 <ski> with `exists a. Show *> [a]', there's a single, shared, type `a', such that all elements have the type `a'
10:04:10 <zceejkr> I see. So this is like List of things that implement an interface in Java.
10:04:25 <ski> `[exists a. Eq a *> a]' is rather useless, since you can't compare different elements to each other. `exists a. Eq a *> [a]' isn't (quite as) useless, since now you can at least compare the elements to each other (not just each element to itself)
10:06:17 <ski> yes, if you have a type class `WidgetC', then `exists w. WidgetC w *> w' would be like having an interface `Widget' in Java, using `Widget' in types of parameters, return types, types of local variables, instance variables, &c.
10:06:31 <ski> however, having existentials is more powerful
10:07:16 <ski> because you can have things like `exists w. WidgetC w *> ..w..', where `..w..' isn't just `w'. you can ensure that all `w's in some collection uses the same type `w', this way
10:08:04 <ski> a value of type `Cxt => T' is such that, if you provide evidence for the constraint `Cxt', you may use it has having type `T'. when defining/producing such a value, you may freely assume evidence for `Cxt'
10:08:55 <ski> e.g. when you define `sort', you can simply assume that there's ordering/comparision operations available for the element type `a'. but when calling `sort', you have to make sure that the element type you end up using actually is an instance of `Ord'
10:09:44 <ski> a value of type `Cxt *> T' is such that you may use it has having type `T', but you also get access to evidence for `Cxt'. otoh, when defining/producing such a value, you must provide evidence for `Cxt'
10:10:05 <ski> recall that something like
10:10:14 <ski>   sort :: forall a. Ord a => [a] -> [a]
10:10:28 <ski> is probably implemented by translating to
10:10:36 <ski>   sort :: forall a. OrdDict a -> [a] -> [a]
10:10:37 <ski> where
10:11:06 <ski>   data OrdDict a = MkOrdDicty {compare :: a -> a -> Ordering,(<=) :: a -> a -> Bool,...}
10:11:30 <ski> expresses a record of "methods" implementing the operations of the `Ord' type class
10:13:22 <ski> so, `Cxt => T' is similar to `CxtDict -> T'. the difference is that in the latter, there's explicit passing of the dictionary. also, you have freedom (and pain) of being able to use multiple different implementations of `CxtDict', for the same type. whereas with type classes, there can be at most one instance of a type class, for a particular type (this is important, some libraries rely on this)
10:14:18 <ski> similarly, i claim `Cxt *> T' is similar to `(CxtDict,T)' a type of pairs of "evidence for `Cxt'" (being a record of type `CxtDict') and the "main payload" value of type `T'
10:14:24 <ski> zceejkr : does this make sense ?
10:14:38 <zceejkr> yep
10:15:36 <ski> so, hopefully it should then make sense when i tell you that `Cxt => (T -> U)' is equivalent to `(Cxt *> T) -> U' (this is "just currying/uncurrying")
10:17:14 <zceejkr> It does yes. 
10:17:22 <ski> btw, you should note that when switching between `forall' and `exists', we swap the rôles of producer/callee/implementor/definer and consumer/caller/user
10:18:20 <ski> similarly, for constraint evidence, when switching between `=>' and `*>'. the rôles of who may freely assuming evidence is given/available, and who is to have the burden of providing it, ensuring it is there, is also flipped
10:18:49 <ski> as a rule-of-thumb, `=>' usually goes together with `forall', and `*>' usually goes together with `exists'
10:19:35 <ski> that is, you'll usually see `forall a. C a => ..a..' vs. `exists a. C a *> ..a..'
10:20:01 <ski> but there seems to be no reason to disallow using `*>' directly under `forall', and also using `=>' directly under `exists'
10:20:48 <ski> (hence why i'm being clear about using two different notations for `=>' vs. `*>'. they are not the same thing, one should not write `exists a. C a => ..a..', when one means `exists a. C a *> ..a..'=
10:20:52 <ski> )
10:21:31 <zceejkr> I see.
10:22:35 <ski> of course, there can be more complicated combinations, like `forall a. C a => T a -> exists b. D a b *> U a b'. here the selection of `b' may depend both on the `a' chosen, and of the value of type `T a' that is passed (and the code for computing the result may use evidence for `C a', and must provide evidence for `D a b', the latter expressing some type relation between `a' and `b')
10:23:27 <ski> also, you should keep in mind the difference between `forall a. exists b. ..a..b..' and `exists b. forall a. ..a..b..'. in the former, there can be a different `b' corresponding to different `a's. in the latter, a single `b' must "work" for all `a's
10:23:51 <ski> <ski> so, hopefully it should then make sense when i tell you that `Cxt => (T -> U)' is equivalent to `(Cxt *> T) -> U' (this is "just currying/uncurrying")
10:25:10 <ski> a similar law, which is often useful when dealing with existentials, claim that `(exists a. ..a..) -> ...' is equivalent to `forall a. (..a.. -> ...)' (the latter `...' here does not mention `a'. this is, again, "just currying/uncurrying", but for type arguments, rather than for constraint evidence)
10:25:21 <ski> example
10:25:32 <ski>   length :: forall a. ([a] -> Int)
10:25:37 <ski> i claim that is equivalent to
10:25:46 <ski>   length :: (exists a. [a]) -> Int
10:26:13 <ski> the former says : for all types `a', if you call `length' with a list of `a's, you get back a result of type `Int'
10:26:47 <ski> the latter says : calling `length' you get back a result of type `Int', as long as there exists some type `a' such that the argument is a list of `a's
10:27:09 <phadej> well, yes. (exists . [a]) ~ Nat
10:27:47 <ski> makes sense, zceejkr ?
10:27:52 <zceejkr> it does, yes.
10:29:17 <ski> anyway, combining the two "logical" laws / equivalences i mentioned just above, we also get that `(exists a. C a *> ..a..) -> ...' is equivalent to `forall a. (C a => (..a.. -> ...))' (extra brackets, for emphasize on the grouping)
10:30:40 <phadej> Either a b -> c   <->   (a -> c, b -> c) 
10:30:58 <phadej> is the simpler variant of exists/forall "flip"
10:31:31 <ski> yes, that's the `c^(a + b) = c^a * c^b' law we mentioned a little earlier
10:32:20 <ski> (and yes, in some sense, the law i just mentioned with `exists' and `forall' is some kind of extension of this. something like `c^(Sum_a f(a)) = Product_a c^(f(a))')
10:32:37 <ski> now, consider again `(exists a. ..a..) -> ...', an `exists' occuring to the left of a function arrow. this is "nothing new", in the sense that this is equivalent to the simpler `forall a. (..a.. -> ...)' (`forall' "on top/outside". the type of an ordinary polymorphic operation)
10:33:21 <ski> otoh, `... -> (exists a. ..a..)' is "something new", we can't express this with plain polymorphism
10:34:07 <ski> similarly, `... -> (forall a. ..a..)' is "nothing new", because this is equivalent to `forall a. (... -> ..a..)', "plain polymorphism"
10:34:10 <ski> e.g.
10:34:23 <ski>   take :: forall a. (Int -> ([a] -> [a]))
10:34:25 <ski> is equivalent to
10:34:34 <ski>   take :: Int -> (forall a. ([a] -> [a]))
10:34:58 <ski> (this is "just reordering arguments", type arguments vs. ordinary arguments)
10:35:26 <ski> (and similarly, `Cxt => (T -> U)' is equivalent to `T -> (Cxt => U)')
10:36:07 <ski> otoh, using `forall' on the left of a function arrow, as in `(forall a. ..a..) -> ...' is "something new", is the type of a rank-two operation
10:36:25 <phadej> you can express -> (exists a. ..a..) with plain polymorphism. There is a trick. forall r. ... -> (forall a. ..a.. -> r)
10:36:34 <ski> yea, i'm coming to that in a bit .. :)
10:37:11 <phadej> I'm afraid that everyone else is afraid to ask anything in between (or something else)
10:37:33 <ski> zceejkr : just in case you wonder, a lot of the laws i've been mentioning here does have a bit to do with the concrete representation of existentials .. at least with getting a deeper understanding of it
10:38:22 <zceejkr> ski: I see.
10:39:29 <ski> so, shall we get to the first way of representing existential types, then ?
10:39:45 <zceejkr> sure.
10:39:51 <ski> (i'm more or less done with what i wanted to cover/mention, before that)
10:40:38 <ski> hm, so let's consider the previous example
10:41:01 <ski>   type QueueOps a = exists q. (q,a -> q -> q,q -> Maybe (q,a))
10:42:23 <ski> there is no `exists' keyword in Haskell. and no extension in GHC for it, either. iirc, LHC and UHC (or was it just one of them) included `exists', but you could only use it to the left of `->'s (maybe also in type synonyms, as long as those ended up being used to the left of `->'s ?) .. which is the "trivial case" of using `exists'
10:43:32 <ski> similarly, there is no `*>' notation either. i invented that (i'm not married to the concrete syntax), in order to be able to talk about issues like this, without having to commit to a particular representation (which makes it a bit harder to "see the forest for the trees", as we'll see)
10:44:34 <ski> perhaps, at some point in the future, there will be an `exists' keyword (and hopefully some concrete syntax for `*>' then, as well). in the meantime, i still prefer reasoning at the level of `exists' and `*>', much of the time
10:44:48 <zceejkr> I see.
10:46:12 <ski> the first way to represent existential quantification is an extension called `ExistentialQuantification' .. a misnomer, if you ask me, since i think that name should have been reserved for actual existential quantification like `[exists a. Widget a *> Map String a]'
10:46:53 <ski> one could call this representation "existential `data' types", or, perhaps, "existential `data' constructors"
10:48:05 <ski> as you might guess, it involves creating a new `data' type to use in place of `exists a. ..a..', defined in terms of the particular type expression `..a..'
10:48:33 <ski> let's reason our way to how it should behave
10:48:51 <ski> first step is to change the type synonym i had above
10:48:54 <ski>   type QueueOps a = exists q. (q,a -> q -> q,q -> Maybe (q,a))
10:49:15 <ski> into an actual new `data' type declaration (still using `exists', so still pseudo-Haskell)
10:49:24 <ski>   data QueueOps a = MkQOps (exists q. (q,a -> q -> q,q -> Maybe (q,a)))
10:50:04 <ski> first, you should convince yourself that the type signature of the `data' constructor, `MkQOps', ought to be
10:50:21 <ski>   MkQOps :: forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
10:50:45 <ski> ok, so far ?
10:50:51 <zceejkr> yes.
10:51:31 <ski> now, since `(exists q. ..q..) -> ...' is equivalent to `forall q. ..q.. -> ...', this signature is actually equivalent to
10:51:42 <ski>   MkQOps :: forall a q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
10:51:54 * hackage log-warper 1.9.0 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.9.0 (gromak)
10:52:11 <ski> or, if we allow ourselves to change from the "tupled" (or "uncurried") form, to the corresponding curried form
10:52:24 <ski>   MkQOps :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
10:52:50 <ski> so, we have a polymorphic `data' constructor, this is nothing new. compare with e.g.
10:52:58 <ski>   Left :: forall a b. a -> Either a b
10:53:37 <ski> what is new is that one of the type variables that we're polymorphic in, `q', doesn't appear in the result type, `QueueOps a' !
10:54:13 <zceejkr> I see.
10:54:13 <ski> this means that if we have two calls to `MkQOps', using the same `a' type, but different `q' types, then the result will still have the same type `QueueOps a'
10:55:04 <ski> this allows the "heterogenicity" that we saw with `[exists a. Widget a *> Map String a]' previously, allowing to hide/forget the particular `q' used, so it doesn't appear in the type
10:55:09 <remexre> any way to do an exhaustive match on a Nat type argument in a closed type family?
10:55:36 <ski> and this also means, when deconstructing, pattern-matching, taking apart, we can't assume anything about `q', since it's forgotten
10:57:01 <ski> so, the way that we define `QueueOps a' (as an "existential `data' type" representation of the existentially quantified type `exists q. (q,a -> q -> q,q -> Maybe (q,a))'), using the (misnomer) extension `ExistentialQuantification' is :
10:57:17 <ski>   data QueueOps a = forall q. MkQOps (q,a -> q -> q,q -> Maybe (q,a))
10:57:47 <ski> the `forall q.', before the name of the `data' constructor, means that the `data' constructor is polymorphic in `q' (which it is)
10:58:22 <ski> at first, it may be confusing that in order to represent an existential quantification, we'd (re)use the keyword `forall'
10:58:55 <ski> but since the corresponding `data' constructor is actually polymorphic, it makes some sense
10:59:23 <ski> (so, it's not just "wanting to conserve the number of keywords", although that may also have been a factor for choosing this syntax)
10:59:50 <ski> btw, you should not confuse the above `QueueOps' with something like
11:00:23 <ski>   data SomethingElse a = MkSomethingElse (forall q. (q,a -> q -> q,q -> Maybe (q,a))
11:00:30 <boxscape> remexre from GHC.TypeNats? If i had to guess I would say whatever you're trying to do is easier with a "data Nat = Z | S Nat" type
11:00:35 <ski> with the `forall' after the `data' constructor
11:01:13 <ski> this is something else. this is a `data' constructor that takes an argument that is to be polymorphic. this is a rank-two `data' constructor :
11:01:28 <ski>   MkSomethingElse :: forall a. (forall q. (q,a -> q -> q,q -> Maybe (q,a)) -> SomethingElse a
11:01:37 <ski> is very different from
11:01:59 <ski>   MkQOps :: forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
11:02:18 <ski> zceejkr : is this clear ?
11:03:06 <zceejkr> yes.
11:03:46 <remexre> boxscape: yeah, but I'd like to use it with existing GHC.TypeLits.Nat values :(
11:04:04 <ski> when you match on the "existential `data' constructor", you'll "open up" the existential, bringing (at least implicitly) a type variable `q' in scope
11:04:29 <ski> let's take the
11:04:44 <ski>   data Showable = forall a. Show a => Wrap a
11:05:35 <ski> example, where `Showable' represents the type `exists a. Show a *> a' (note how i also put `Show a =>' in front of the `data' constructor, in order to represent the `Show a *>' part)
11:05:44 <ski> instead of having
11:06:02 <ski>   [False,0,""] :: [exists a. Show a *> a]
11:06:13 <boxscape> remexre to be honest I'm not even really sure what exhaustive means in that context - do you mean in an induction on natural numbers sense or something else?
11:06:16 <ski> we would have to say here
11:06:23 <dminuoso> ski: What is the reason for having a different constraint notation in existentials?
11:06:33 <ski>   [Wrap False,Wrap 0,Wrap ""] :: [Showable]
11:06:46 <remexre> boxscape: uh I'd be doing induction, but I just mean, the type family reduces for all Nats (or at least all KnownNats)
11:06:57 <dminuoso> Is that to emphasize the difference in a similar spirit to `(->)` vs `(,)`?
11:07:21 <dminuoso> (Indicating that it doesn't "demand" Show a, but comes with it rather)
11:07:22 * ski . o O ( "Meaningful distinctions deserve to be preserved." -- Errett Bishop )
11:08:02 <ski> yes, dminuoso. they are different things. also `=>' isn't always used directly after `forall'. similarly, `*>' isn't always (conceptually) used directly after `exists'. so it would not do to write them the same
11:08:08 <boxscape> remexre can't you just do that by making sure your last equation looks something like "Foo n = ..." (i.e. with a variable rather than number)
11:08:38 <remexre> boxscape: uh, I guess I do need induction then
11:09:31 <ski> zceejkr : to sum up, with this representation, instead of directly writing the type we intend, `exists a. ..a..', we have to invent a new `data' type, putting the body `..a..' inside of it, and then proceed to use this new `data' type in place of where we intended to use `exists a. ..a..'. also, we must explicitly convert, by calling, and matching on, the `data' constructor
11:10:05 <zceejkr> I see.
11:10:26 <ski> `(->)' is to `(,)' as `forall' is to `exists' as `=>' is to `*>'
11:10:39 <boxscape> remexre I feel like we're talking past each other. I was thinking you're trying to do something like "type family Foo (n :: Nat) where Foo 0 = ...; Foo n = ... (n - 1) ..."; this reduces for all numbers, and I suppose counts as induction, but it might be difficult to use
11:10:48 <dminuoso> Right
11:10:57 <ski> zceejkr : another example, illustrating another point
11:11:17 <boxscape> remexre ah wait
11:11:18 <remexre> boxscape: I think so, yeah; didn't realize (n - 1) would be able to reduce without explicit "evidence" in the context that n =/= 0
11:11:52 <ski>   data Expr a =           Lit a
11:11:54 <ski>               | forall b. App (Expr (b -> a)) (Expr b)
11:12:26 <ski> `Expr a' is a `data' type of "expressions" which when evaluated will yield a value of type `a'
11:12:30 <boxscape> remexre I'm actually not sure it does now that I think about it
11:12:42 <ski> note that the `data' constructor signatures here will be
11:12:57 <remexre> boxscape: https://p.acm.umn.edu/XCm9qFvAEAI= works, at least
11:13:08 <boxscape> ok, good
11:13:09 <remexre> though, literal index rather than just KnownNat
11:13:21 <ski>   Lit :: forall a  .            a             -> Expr a
11:13:24 <ski>   App :: forall a b. Expr (b -> a) -> (Expr b -> Expr a)
11:13:31 <ski> and you can define e.g.
11:13:36 <ski>   eval :: forall a. Expr a -> a
11:14:03 <ski>   eval (Lit v)    = v
11:14:16 <ski>   eval (App e e0) = (eval e) (eval e0)
11:15:15 <ski> btw, `Expr' is an irregular `data' type (since we have constructor argument types `Expr (b -> a)' and `Expr b', rather than merely `Expr a')
11:16:53 <ski> anyway, note that it's really the `App' `data' constructor which is "existential", rather than `Expr' as a whole (although `Expr' includes `App', and so could be said to be "existential" therefore). hence "existential `data' constructor" may be a more accurate name than just "existential `data' type", for this representation
11:17:06 <idnar> `Redundant constraint: HasCallStack`
11:17:11 <idnar> huh?
11:17:13 <remexre> boxscape: hm, https://p.acm.umn.edu/XCm-oyYO8AE= doesn't, sadly
11:17:41 <zceejkr> ski: I see.
11:17:43 <boxscape> hmm
11:18:09 <remexre> meh, I don't think I need this to work, so /shrug
11:18:22 <idnar> am I being silly or is that warning silly?
11:18:54 <ski> zceejkr : at this point, i should mention something, very briefly, about "GADTs", standing for "Generalized ADTs", in this case meaning "Generalized Algebraic Data Types" (not really a very imaginative or descriptive name ..). sometimes one sees names like "indexed data type" as well
11:19:23 <ski> GADTs are their own topic, but here they touch a little bit on existentials
11:20:35 <ski> full GADTs allow one to do things which one can't really do without them. GADTs are declared using an alternative syntax for `data' types. however, one can also use the same style of syntax, with ordinary ADTs (regular or not), and also, interestingly enough, with "existential" `data' types (which is what i'm coming to)
11:20:54 * hackage aws 0.22 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.22 (AristidBreitkreuz)
11:21:27 <zceejkr> Do you think this is a good point to pause? I have to leave soon. 
11:21:35 <ski> there is a language extension `GADTSyntax' that just enables this alternative syntax, without giving you the extra expressive power of full GADTs. if you also (iirc ?) enable `ExistentialQuantification', you can use this alternative syntax also for "existential `data' types"
11:21:41 <ski> hm
11:22:07 <ski> i think what i intended to say about GADT-syntax isn't that long, so we could stop/pause after that ?
11:22:19 <zceejkr> Sure. 
11:22:23 <ski> or is it better to stop before ?
11:22:24 <ski> ok
11:22:48 <ski> so, the idea is that instead of using a BNF-inspired syntax for declaring `data' types, like
11:22:55 <ski>   data Tree a = Leaf a
11:23:08 <ski>               | Branch (Tree a) (Tree a)
11:23:20 <ski> (i hope you see why this is BNF-inspired)
11:23:28 <zceejkr> I do.
11:23:43 <ski> we, instead, can simply list the intended type signatures of the `data' constructors, like so :
11:23:47 <ski>   data Tree a
11:23:49 <ski>     where
11:24:30 <ski>     Leaf   :: a ->                Tree a
11:24:37 <ski>     Branch :: Tree a -> Tree a -> Tree a
11:24:59 <ski> however, now we have to repeat the result type, `Tree a', for all the `data' constructors
11:25:29 <ski> in particular, we have to repeat it, with the same type parameters (in the same order), as in the "head" `data Tree a'
11:26:06 <zceejkr> So no irregular data-types this way?
11:26:29 <ski> being able to use different types for the parameters in the result type of the `data' constructors, perhaps type variables, perhaps specific types, perhaps more complicated type expressions involving type variables, is what the full power of GADTs is about
11:26:56 <ski> btw, you may note that i omitted `forall a.' in those signature. it's allowed to omit "toplevel" `forall's there, as usual
11:27:05 <ski> well, you can still define
11:27:09 <ski>   data PBBT a
11:27:10 <ski>     where
11:27:47 <ski>     Elems  :: forall a.        a   -> PBBT a
11:27:53 <ski>     Double :: forall a. PBBT (a,a) -> PBBT a
11:27:57 <ski> which is irregular
11:28:21 <zceejkr> I see. But the last one has to have only a as the param?
11:28:24 * hackage bytesmith 0.3.6.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.6.0 (andrewthad)
11:28:39 <ski> btw, the parameters, here only `a', in the "head", `PBBT a', here are actually completely useless. therefore i tend to prefer writing like
11:28:45 <ski>   data PBBT :: * -> *
11:28:47 <ski>     where
11:28:49 <ski>     ...
11:28:58 <ski> enabling `KindSignatures'
11:29:34 <zceejkr>  Double :: forall a. PBBT (a,a) -> PBBT a
11:29:41 <zceejkr> But this would still need an a correct?
11:29:59 <zceejkr> Also Elems I guess. 
11:30:35 <ski> (however, if the same type parameter is actually repeated in all the result types, as in the `Tree' and `PBBT' cases, i still use the `data PBBT a' form. sometimes mixing, like `data Foo a :: * -> *', in case `a' is repeated, but the next parameter differs in different `data' constructors)
11:30:44 <ski> yes, zceejkr
11:31:09 <ski> anyway, to declare `QueueOps' using `GADTSyntax', you "do the obvious" :
11:31:15 <ski>   data QueueOps a
11:31:17 <ski>     where
11:31:47 <ski>     MkQOps :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
11:32:13 <ski> where, if we want to, we can elide writing those `forall's explicitly, as usual, like
11:32:19 <ski>     MkQOps :: q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
11:32:31 <ski> (but, conceptually, they're still there, as usual)
11:32:39 <ski> this being an alternative way to express
11:32:45 <hololeap> zceejkr: data Expr a where
11:32:45 <hololeap>              Lit :: a                         -> Expr a
11:32:45 <hololeap>              App :: (Expr (b -> a)) -> Expr b -> Expr a
11:32:45 <hololeap> that's how you would rewrite ski 's Expr example as a GADT
11:32:59 <ski>   data QueueOps a = forall q. MkQOps q (a -> q -> q) (q -> Maybe (q,a))
11:34:01 <zceejkr> I see. 
11:34:19 <zceejkr> hololeap: I see, thanks.
11:34:54 * hackage opentelemetry 0.1.0 -   https://hackage.haskell.org/package/opentelemetry-0.1.0 (DmitryIvanov)
11:35:00 <zceejkr> so a forall before the data constructor name can be read as exists?
11:35:02 <ski> (i again hasten to add that you can not leave out `forall's just anywhere. e.g. `(forall a. [a] -> [a]) -> Bool' is very different from `([a] -> [a]) -> Bool'. it's only in type signatures, when there's `forall's at the "top", that you can, usually, do it. it's merely a way to not have to type as much, there's nothing deep about it)
11:35:28 <ski> a `forall' before a `data' constructor is used to encode `exists'
11:35:54 * hackage opentelemetry-lightstep 0.1.0 -   https://hackage.haskell.org/package/opentelemetry-lightstep-0.1.0 (DmitryIvanov)
11:35:56 <ski> via the equivalence between `forall a. (..a..) -> ...' and `(exists a. ..a..) -> ...'
11:36:08 <zceejkr> ski: right.
11:36:10 <ski> in the above `QueueOps' case, we have
11:36:25 <fog> I wrote this; https://gist.github.com/fog-hs/785c746a74a9c723db7b154d2499a762
11:36:28 <ski>      forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
11:36:29 <fog> but it does not work!
11:36:40 <ski>   =  forall a q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
11:36:50 <ski>   =  forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
11:36:52 <phadej> ExistentialQuantification is really not "encoding" anything. It's just a syntax, which you could try to justify somehow, but it's just weird. And it's fine :)
11:37:06 <ski> so that a value of type `QueueOps a' contains a value of type `exists q. (q,a -> q -> q,q -> Maybe (q,a))'
11:37:39 <ski> it's one way to represent `exists'. does that wording suit you better, phadej ?
11:38:23 <ski> zceejkr : anyway, i'll stop here. any final questions or comments ?
11:38:31 <phadej> ski: I don't know the proper story, but I suspect it was picked as GHC implementors didn't want to introduce exists as a keyword, so they found a syntax which avoided new keyword
11:38:37 <phadej> and which kind of makes sense
11:38:46 <monochrom> The GHC user's guide says that much.
11:38:52 <ski> that's presumably part of the story, yes
11:39:00 <phadej> recall, it existed long before GADTs
11:39:08 <phadej> otherwise that syntax wouldn't introduced at all
11:39:11 <phadej> and I argue, don't use it
11:39:18 <phadej> use GADTSyntax if you don't want GADTs
11:39:45 <ski> (but, it still makes sense, in the sense that the `data' constructor here are polymorphic in `q', albeit the result type doesn't mention `q')
11:39:47 <phadej> (and don't show old ExistentialQuantification syntax to beginners, it's simply way too confusing)
11:39:53 <monochrom> Encoding existentials means you use this function type: forall r. (forall a. F a) -> r, i.e., disjunction elimination.
11:40:09 <zceejkr> ski: No questions at the moment. I lost some focus towards the end, so I will go over the tail end of this session again before we continue. But many thanks, as always :). Untill next time
11:40:14 <monochrom> Clearly, this is neither ExistentialQuantification nor GADTs.
11:40:17 <ski> missing `-> r'
11:40:40 <monochrom> Eh? I had my ->r right up there.
11:40:46 <ski> but yes, that's the other representation, which i'll presumably get to next time, with zceejkr
11:41:05 <argent0> `func :: (.., Monad z, Monad m) => Proxy z -> ..(no mention of z).. -> m Result; func = do; bar <- (CFoo :: TFoo z ());...` GHC doesn't consider the z inside the definition to be the same as the z in the Constraint. How do I set them as the same?
11:41:13 <phadej> monochrom: forall r. (forall a. F a >>> -> r <<<) -> r
11:41:26 <monochrom> Err OK
11:41:27 <ski> monochrom : `r' is singleton, so what you wrote is `(forall a. F a) -> (forall r. r)' ..
11:41:38 <monochrom> @type either
11:41:40 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:41:52 <monochrom> Yeah OK.
11:42:17 <ski> btw, `ExistentialQuantification' is also in Hugs
11:42:31 <fog> any idea why it does not manage to the handshake correctly? 
11:43:22 <ski> argent0 : add `forall z.' to type signature, or match on `Proxy :: Proxy z'
11:43:36 <ski> argent0 : you'll need to enable `ScopedTypeVariables'
11:44:18 <ski> phadej : confusing, why ?
11:44:37 <phadej> ski: you used few hours explaining that exists <-> forall isomorphism
11:44:56 <phadej> it's confusing :)
11:44:58 <fog> i have a HTML client which can use the echo server as it is written here
11:45:07 <ski> yes, which i'd want people to know about in any case
11:45:11 <fog> would it help to post that?
11:45:37 <argent0> ski: Thanks
11:45:48 <ski> np
11:48:16 <fog> ok, i updated the gist; https://gist.github.com/fog-hs/785c746a74a9c723db7b154d2499a762
11:50:36 <fog> main manages to open a socket connection succesfully
11:50:55 <fog> and, runEchoServer can be used by the html client
11:51:30 <fog> but when main is made to use this local version of the echo server, it crashes
11:53:43 <ghdfdjklk> I'm trying to debug some code. On ghci i set a breakpoint `:break Chords.ChordResolver 78` then call the function and it does not stop at the breakpoint, it just returns the result. What am i missing?
11:54:01 <fog> can you post the code?
11:54:45 <ghdfdjklk> #fog are you refering to me?
11:55:22 <fog> oh its a ghci error
11:55:40 <fog> i thought we would need to understand what was wrong with some code
11:55:55 <fog> i read you message too quickly, sorry
11:57:12 <fog> the others will have to help, as i dont know about breakpoints
11:57:27 <ghdfdjklk> yeah, neither do i 
11:57:51 <ghdfdjklk> does not seem to be a lot of information on the internets also
12:01:07 <ghdfdjklk> ah, ok, it seems that because of laziness, some breakpoints will never be reached
12:03:56 <fog> makes sense
12:06:54 * hackage dobutokO2 0.1.0.0 - A program and a library to create experimental music from a mono audio and a Ukrainian text  https://hackage.haskell.org/package/dobutokO2-0.1.0.0 (OleksandrZhabenko)
12:16:40 <MarcelineVQ> fog: it's very good that you included the html in your example but be sure to mention the package names too if you want people to try/examine it. even better make a git repo and share that so people can just do a clone :>
12:17:23 <lhurttila> This worked just fine earlier but now i'm getting Non-exhaustive patterns in function setNConnections:
12:17:40 <lhurttila> Uploaded file: https://uploads.kiwiirc.com/files/52e8efd79bc8bc8bc13b425240dd9ac4/pasted.txt
12:19:36 <lhurttila> Any idea what am i missing?
12:20:10 <koz_> lhurttila: What's the exact error message?
12:20:28 <MarcelineVQ> setNConnections there matches the list containing a single 3-tuple of (l, (x, y), w)   it's missing the case where the list is larger or empty
12:22:05 <lhurttila> koz_  it just mentions ***Exception file, linenumber and that message
12:22:16 <koz_> Oh wait, a runtime error.
12:22:21 <koz_> I thought you meant a compile error. :P
12:22:39 <koz_> Very good idea to compile with non-exhaustive pattern match warnings.
12:24:16 <lhurttila> MarcelineVQ then why didn't I get this message earlier while trying the same function without those cases? How do i even add those cases to a list comprehension
12:25:02 <ChaiTRex> lhurttila: What are you trying to do with that setNConnections function?
12:25:16 <MarcelineVQ> the comprehension isn't where the issue lies.   [(l, (x, y), w)]  is equivalent to  ​( (l, (x, y), w) : [] )   a list consisting only of a single tuple at the head and an empty list as the tail. if  (superconnections n) does not give this exact thing then it'll be an error
12:27:47 <MarcelineVQ> ChaiTRex is asking a good question :>
12:28:07 <lhurttila> MarcelineVQ hmm. This worked just fine with ghci but now I'm running that code with stack ghci. Could it cause the difference in behaviour?
12:28:34 <lhurttila> This is what I was aiming at: https://stackoverflow.com/questions/60428086/how-to-modify-a-list-value-in-a-nested-custom-datatype
12:29:27 <lhurttila> Had to scrap that idea though and try to learn lenses because I can't seem to find a way to modify the values as I'd like
12:34:14 <MarcelineVQ> lhurttila: generally there shouldn't be a difference, but there's a lot of pential moving parts here so it's hard to say
12:36:14 <MarcelineVQ> why do people keep pinging out when I mention them, do I have a mysteriuous power?
12:36:31 <Rembane> YEs
12:36:36 <Rembane> Use it wisely 
12:36:40 <MarcelineVQ> how mysteriuous
13:40:50 <kberg> hallo
13:53:45 <maerwald> I get weird TH errors in my quasiquoter https://gist.github.com/hasufell/55e5d073db840df0d7038067c7967341
13:54:15 <maerwald> this SO post says it's because TH is broken, but I have no idea how to apply the solution: https://stackoverflow.com/a/38182444
13:57:46 <glguy> maerwald: Have you tried replacing TH.lift on line 26 with dataToExpQ?
13:58:05 <glguy> or rather the function liftDataWithText defined in SO
13:58:31 <glguy> and then put a custom lift function for text there?
14:02:19 <maerwald> Oh yeah, that seems to work. Needed to add Data instance for all the stuff though
14:02:35 <maerwald> The weird part was, it only failed with some expressions
14:02:51 <maerwald> [vers|16.4|] worked but not [vers|16.04|]
14:03:10 <maerwald> I don't want to know what's going on in TH really
14:06:13 <glguy> maerwald: What's the definition of versioning?
14:07:48 <maerwald> https://hackage.haskell.org/package/versions-3.5.3/docs/Data-Versions.html#v:versioning
14:08:00 <maerwald> 16.04 is a "mess"
14:08:05 <maerwald> 16.4 probably semver
14:08:33 <maerwald> mess has text, so I guess there is that
14:08:58 <fendor_> how can I limit ghci memory usage in an interactive session?
14:09:11 <glguy> Right: >>> versioning "16.04" -- Right (Complex (VLeaf ["16","04"]))
14:09:18 <glguy> >>> versioning "16.4" -- Right (General (Version {_vEpoch = Nothing, _vChunks = [[Digits 16],[Digits 4]], _vRel = []}))
14:13:18 <MarcelineVQ> fendor_: seems like   ghci +RTS -M20M  will cause ghci to stop what it's doing with a heap overflow exception, try it with  foldl (+) 0 [1..10000000]
14:13:20 <fendor_> looks like +RTS -K2M -RTS offers me what I want
14:13:31 <fendor_> MarcelineVQ, yes that too, thank you! 
14:13:39 <pragma-> nil: what do you mean by "onk"?
14:13:41 <fendor_> the other is for stack overflow
14:13:44 <MarcelineVQ> -K is stack size
14:15:14 <fendor_> thank you!
14:30:46 <koz_> Can Bools be UNPACKed?
14:32:13 <koz_> Never mind, found my own answer.
14:32:41 <boxscape> koz_ what is the answer?
14:32:56 <koz_> boxscape: Not without -XUnboxedSums.
14:32:59 <boxscape> I see
14:35:34 <koz_> Wait, seems like even _with_ that extension I can't.
14:41:35 <koz_> I think because Bool isn't an unboxed sum.
14:41:45 <koz_> Oh well, just a reminder to me that Haskell isn't C, lol.
14:43:02 <boxscape> I guess you can always use Word# instead :)
14:43:10 <boxscape> then it's more C-like
14:43:33 <boxscape> although I guess C people use Int# for Bools
14:44:24 <koz_> Maybe, but I'll stick to Haskell. C is not such a great language that we should emulate all its misfeatures. :P
14:44:36 <boxscape> true
14:45:29 <davean> Only the good misfeatures.
14:45:38 <boxscape> like braces and semicolons
14:48:38 <d34df00d> koz_: IIRC Bools will be unpacked once some patch lands onto ghc.
14:49:17 <d34df00d> And more sum types too.
14:49:34 <koz_> d34df00d: When is said patch landing? I assume the 8.10 window's already gone.
14:49:54 <d34df00d> https://gitlab.haskell.org/ghc/ghc/wikis/unpacked-sum-types
14:49:58 <boxscape> huh unboxed sums apparently use "distfix", that's a new word for me
14:49:59 <d34df00d> > (NOTE (osa): This part is not yet implemented, the patch is trivial and I'm
14:49:59 <d34df00d> going to submit it soon)
14:50:01 <lambdabot>  <hint>:1:76: error:
14:50:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:50:17 <d34df00d> koz_: no better estimate than that.
14:50:27 <koz_> d34df00d: Yeah, well, I'll await it with baited breath.
14:50:34 <koz_> So I can be all like
14:50:40 <koz_> 'wow, such erase, very efficiency, amaze'
14:50:44 <d34df00d> I used an Int instead of Bool last time I needed it unpacked.
14:50:48 <d34df00d> Gave like 5% perf boost.
14:51:27 <koz_> d34df00d: I might have to profile to see if it matters in my case. My strong suspicion is that it won't, but I'll bear what you've said in mind.
14:51:31 <koz_> ALso, _awesome_ work on inline-asm.
14:51:37 <d34df00d> Suggestion for a package: 'efficient-bool' which is basically `newtype EBool = EBool { repr :: Int } deriving (...)` and all the operations around that.
14:51:52 <koz_> d34df00d: You can just define it as a data-wrapper around an unboxed sum.
14:52:03 <koz_> It'd actually be more efficient than the Ebool you propose above.
14:52:23 <d34df00d> koz_: haha, thanks for the feedback! I figured I spent way more time on it than I wanted to dedicate to a semi-joke-project :)
14:53:24 <d34df00d> Also, re efficiency, you can do some fun branchless things with the Int- (or Word-) based representations.
14:53:27 <koz_> d34df00d: I don't think it's a joke project at all. I really think it could be quite useful for certain perf-intensive stuff, whcih currently involves callouts to C intrinsics and all the fun that involves.
14:53:34 <d34df00d> Not sure the compiler will be smart enough to desugar anything sum-like into that.
14:53:51 <koz_> d34df00d: I don't know enough about GHC's internals, or its code generator, to say anything sensible on that front.
14:54:50 <d34df00d> Me neither. So that 5% I mentioned above is coming both from replacing Bool with Int as well as from replacing a couple of nested ifs with (1 - a) * b or smth like that.
14:55:02 <d34df00d> Not sure which one plays the biggest part, and a bit lazy to get back to that project at that state to figure out.
14:56:32 <koz_> I'm not sure you can meaningfully separate the two, since the former enables the latter.
14:57:06 <d34df00d> You can benchmark just the formet, I guess, and hope the compiler doesn't do the latter itself.
14:57:15 <d34df00d> Which it might do, since I was going through LLVM, and it's pretty smart.
14:58:02 <solonarv> GHC's primops use Int#, btw
14:58:09 <koz_> solonarv: That doesn't surprise me.
14:58:44 <koz_> Although perhaps Word# might be more appropriate.
15:01:11 <d34df00d> Ugh... this reminds me I probably need to hack a bit on GHC primops for SIMD stuff to implement what I've found missing.
15:07:15 <[itchyjunk]> Huh, using capital levver as variable isn't valid?
15:07:25 <[itchyjunk]> lambda2 x1 A y1  = (3*x1^2+A)/(2*y1)
15:07:31 <solonarv> indeed
15:07:32 <glguy> Capital letters are for constructors
15:07:37 <[itchyjunk]> ah
15:07:42 <glguy> lowercase letters are for variables
15:13:35 <[itchyjunk]> lambda2 x1 a y1  = ((3*(x1^2))+a)/(2*y1) for 4 1 2, why is it giving me 12.25?
15:13:40 <[itchyjunk]> oh
15:18:23 <[itchyjunk]> shit, it's mode 5 and what not
15:18:30 <[itchyjunk]> and i never wrote that inverse finding algo
15:19:52 <John_Ivan> 質問あります
15:20:13 <John_Ivan> I'm trying to write "There's no day when John is on TV."
15:20:35 <John_Ivan> but with "there's no day" as the first clause in the sentence.
15:20:38 <Axman6> In Japanese or Haskell?
15:20:46 <John_Ivan> Axman6, oh shit xD
15:20:51 <John_Ivan> my bad. wrong channel.
15:21:00 <Axman6> We can help with the latter!
15:21:17 <John_Ivan> yeah, I'll count on that. but not learning any haskell today :)
15:21:18 <Axman6> % putStrLn  "There's no day when John is on TV."
15:21:18 <yahb> Axman6: There's no day when John is on TV.
15:21:47 <John_Ivan> instead, trying to decipher some hectic grammar principles..
15:22:23 <[itchyjunk]> okay, maybe the inverse isn't as crazy for a computer. to find inverse of x `mod` m, i just takes a list [1..m-1] multiply each element by x and then `mod` m is and see if its 1 or not
15:22:24 <boxscape> % "there's no day" & (\str -> putStrLn $ str <> " when John is on TV.") -- Axman6, "there's no day" is supposed to be the first clause
15:22:24 <yahb> boxscape: there's no day when John is on TV.
15:22:27 <[itchyjunk]> right? okay okay
15:23:44 <Axman6> [itchyjunk]: I mwean, sure, but I'm pretty sure we already have efficient function for finding inverses mod n
15:24:03 <John_Ivan> alright. asked in the right place
15:24:07 * John_Ivan is depressed.
15:24:15 <[itchyjunk]> map wants a function.. how do i "(x * [1..m-1]) `mod` m)" ?
15:24:24 <[itchyjunk]> Axman6, oh really?
15:24:34 <[itchyjunk]> i'm tempted to use preexisting solutions today
15:24:42 <[itchyjunk]> I know i should do these myself to learn better but what the heck
15:25:03 <dmwit> ?hackage arithmoi
15:25:03 <lambdabot> http://hackage.haskell.org/package/arithmoi
15:25:06 <[itchyjunk]> import Inverse.Finding.Stuff?
15:25:08 <[itchyjunk]> ah okay
15:25:35 <Axman6> yeah arithmoi was the first thing I though of, but GHC.Integer or GHC.Natural or something might also have it
15:25:39 <Axman6> thought*
15:25:44 <dmwit> http://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Class.html#v:invertMod
15:27:46 <[itchyjunk]> Hmm right i'm looking at that
15:29:23 <[itchyjunk]> hmmmmmmmmmm
15:30:54 <[itchyjunk]> I .. can't even tell what I am importing here. but invertMod seems like what i want. :s
15:32:59 <John_Ivan> ;/
15:34:24 <[itchyjunk]> Google has 0 examples
15:36:06 <Axman6> there are two steps before you can use that function - first you need to add arithmoi to your cabal file for the project, second you need to add import Math.NumberTheory.Moduli.Class (invertMod) to your file
15:36:53 <[itchyjunk]> Ah i dont have it thats what import  Math.NumberTheory.Moduli.Class is telling me i dont have it. makes sense
15:41:45 <John_Ivan> ;/
15:42:32 <[itchyjunk]> I should have not procrastinated 
15:44:38 <Axman6> Let this be a lessen to you until just before you procrastinate again!
15:45:50 <[itchyjunk]> I thought the code would be easier but it involved mod !
15:46:04 <[itchyjunk]> well i could do this manually like a simpleton
15:47:02 <[itchyjunk]> oh ohh
15:47:04 <[itchyjunk]> Warning: You asked to install executables, but there are no executables in
15:47:04 <[itchyjunk]> target: arithmoi. Perhaps you want to use --lib to install libraries instead.
15:47:11 <[itchyjunk]> I am not sure i am using cabal correctly
15:47:25 <[itchyjunk]> i just `cabal install arithmoi`
15:48:06 <John_Ivan> ;/
15:52:54 * hackage nix-deploy 1.0.5 - Deploy Nix-built software to a NixOS machine  https://hackage.haskell.org/package/nix-deploy-1.0.5 (GabrielGonzalez)
16:54:35 <Girl98> Hi! I'm a camgirl. Watch my FREE chaturbate show! Go to my room: https://chaturbate.com/in/?track=default&tour=JpRf&campaign=3NzDj&next=/female-cams/
16:54:41 <koz_> @where ops
16:54:42 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
16:54:58 --- mode: ChanServ set +o dibblego
16:55:10 --- kick: Girl98 was kicked by dibblego (Girl98)
16:55:13 --- mode: ChanServ set -o dibblego
16:55:20 <koz_> Thanks dibblego!
16:55:25 <dibblego> np
17:33:33 <Axman6> dibblego: what if she was live coding though? that could've been good!
17:33:51 <koz_> Axman6: Lol.
17:34:37 <dibblego> Axman6: can you check for me? I might invite her back
17:35:15 <Axman6> Perhaps not from my work computer
17:39:19 <boxscape> hm I'm increasingly finding that aside from mentioning the types of bound variables, holes should also mention the kinds of bound types
17:39:28 <boxscape> s/types/type variables
17:40:19 <boxscape> (perhaps with a "foo, bar, baz :: Type" at the bottom for all non-weird kinds)
17:40:24 * hackage tree-sitter-ql 0.1.0.1 - Tree-sitter grammar/parser for QL  https://hackage.haskell.org/package/tree-sitter-ql-0.1.0.1 (rewinfrey)
17:44:09 <MarcelineVQ> aren't hole errors verbose enough ;_; they don't even fit in my default height terminals
17:45:15 <boxscape> you can control how many bindings they show with -fmax-relevant-binds. I suppose it'd be quite reasonable to only show kinds if you enable a similar option
17:46:54 <boxscape> it'd so cool if you could REPL into the context of a whole and evaluate expressions or ask for their types in that context
17:47:00 <boxscape> s/whole/hole
17:48:09 <boxscape> (or, for that matter, into the context of a function and get access to where bindings and such-like. Although it's unclear to me how that would work with multiple equations)
17:54:35 <eta-expanse> has anyone written a zipper that acts like a cursor into a haskell term? where your cursor would represent a hole
17:56:46 <eta-expanse> or I guess, as boxscape said, the cursor could act as a REPL environment
17:56:53 <Axman6> If there are lenses, then you could probably do that with the zippers package
17:57:55 <eta-expanse> I think I'm confusing lexical holes with term holes
17:58:57 <dibblego> Axman6: I went to axman6.com and there is a guy there wearing a data61 tshirt, so I think you've been hacked
18:00:15 <Axman6> yeah I should fix that shit
18:08:28 <davean> Data61? Didn't we get rid of them?
18:10:12 <Axman6> Only the good bit
18:10:37 <davean> We're not free of them then?
18:11:32 <davean> Whats its phylactery?
18:13:54 <dibblego> Who is we?
18:14:24 <davean> The world
18:14:44 <davean> whats left? I thought the entire thing shut down
18:15:08 <dibblego> QFPL did
18:15:33 <davean> Oh my mistake
18:18:16 <boxscape> % if|0<-0->case()of{}if|0<-0->case()of
18:18:16 <yahb> boxscape: ; <interactive>:209:20: error: Multi-way if-expressions need MultiWayIf turned on
18:18:28 <boxscape> % if|0<-0->case()of{}if|0<-0->case()of
18:18:28 <yahb> boxscape: ; <interactive>:211:10: error:; Unexpected case expression in function application:; case () of; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
18:18:30 <boxscape> lame
18:19:28 * Axman6 puts boxscape on his list of people to be weary of
18:19:37 <boxscape> hehe
18:20:07 <boxscape> I was very confused a few minutes ago to see that I could write multiple MultiWayIf statements in consecutive lines without error, took me a while to figure out that I was passing one as argument to the other
18:28:47 <dmwit> look how close we are to allowing HTML comments tho
18:29:02 <boxscape> that's going to be my next proposal
18:32:10 <boxscape> % putStrLn <!-- comment text --> "hello world"
18:32:10 <yahb> boxscape: hello world
18:32:12 <boxscape> ^ dmwit
18:32:31 <Axman6> D:
18:32:51 <iqubic> How does that work?
18:32:57 <boxscape> :t (<!--)
18:32:58 <lambdabot> error:
18:32:58 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:33:03 <boxscape> % :t (<!--)
18:33:03 <yahb> boxscape: (t1 -> t2) -> t1 -> t2
18:33:17 <boxscape> to be more precise
18:33:21 <boxscape> (<!--) a b = a b; infixr 4 <!--
18:33:27 <iqubic> Oh.
18:33:27 <boxscape> % (-->) a b = b; infixr 4 -->
18:33:27 <yahb> boxscape: 
18:33:29 <maralorn> How does that work?
18:33:31 <boxscape> comment and text are undefined
18:33:39 <solonarv> silly custom operators, that's all
18:33:54 <nshepperd> smoke and mirrors!
18:34:19 <iqubic> Nice.
18:34:33 <iqubic> :t text
18:34:35 <lambdabot> String -> Doc
18:34:39 <iqubic> :t comment
18:34:40 <lambdabot> error: Variable not in scope: comment
18:34:43 <boxscape> % :t comment
18:34:43 <yahb> boxscape: a
18:34:46 <boxscape> % :t text
18:34:46 <yahb> boxscape: a
18:34:51 <iqubic> Ah. Right.
18:34:53 <maralorn> So you wanna make a proposal to adde them to the prelude?
18:35:12 <iqubic> No. No. I don't want that.
18:35:21 <boxscape> hmm either that or a more general solution to just allow all html syntax in .hs files
18:36:05 <solonarv> it's already allowed instead of [html| |] with the right library ;)
18:36:17 <boxscape> fair
18:36:29 <solonarv> s/instead/inside/
18:36:44 <nshepperd> all libraries converge toward acme-php...
18:36:46 <boxscape> and it's already allowed inside of strings
18:37:04 <boxscape> well, except for things that would close the string
18:47:24 * hackage haiji 0.3.2.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.3.2.0 (NoriyukiOhkawa)
18:54:27 <olligobber> can someone explain why the type system is failing here? https://gist.github.com/olligobber/068d729d394693a700274a98ba83c5c6
18:58:41 <MarcelineVQ> based solely on the error you want ScopedTypeVariables so that both uses of 'op' are the same
18:59:18 <olligobber> MarcelineVQ, that sounds good, ty
18:59:34 <MarcelineVQ> otherwise getop :: op () () is talking about a fresh op, as suggeted by ghci calling it  forall (op1 :: * -> * -> *). op1 () ()
19:02:43 <olligobber> it works :o
19:11:24 * hackage hvega 0.6.0.0 - Create Vega-Lite visualizations (version 4) in Haskell.  https://hackage.haskell.org/package/hvega-0.6.0.0 (DouglasBurke)
19:13:54 * hackage ihaskell-hvega 0.2.3.0 - IHaskell display instance for hvega types.  https://hackage.haskell.org/package/ihaskell-hvega-0.2.3.0 (DouglasBurke)
19:42:16 <HiPanda34> Hello Can you tell me the problem with this code  
19:42:19 <HiPanda34> aaa :: a -> Bool
19:42:50 <dibblego> with just that code?
19:43:13 <ChaiTRex> HiPanda34: if it's more than one line, please use a pastebin
19:43:37 <ChaiTRex> HiPanda34: if it's just one line, you need to define aaa
19:43:38 <HiPanda34> ok.
19:45:29 <HiPanda34>     ? Couldn't match expected type ‘a’ with actual type ‘Char’
19:45:31 <HiPanda34> pattern guard for
19:45:56 <HiPanda34> I used pastebin
19:46:23 <dibblego> link it
19:46:42 <ChaiTRex> HiPanda34: OK, now paste the pastebin URL with the random stuff at the end
19:57:17 <doesntmonad> is it possible to write a program that relies on generating random values without knowledge of monads? Might be too vague a question
19:57:50 <glguy> yes, you don't need monads to generate or use random values
19:57:57 <ski> > randomRs (0,9) (mkStdGen 1234)
19:57:59 <lambdabot>  [7,5,1,6,1,2,1,9,1,5,2,0,3,0,6,5,1,1,2,0,0,1,8,4,2,9,7,5,8,0,3,2,0,9,8,7,9,5...
19:58:27 <doesntmonad> ok cool
19:58:32 <HiPanda34> the code:  https://pastebin.com/Wi3L22Px
19:58:52 <HiPanda34> the problem https://pastebin.com/95hiF9Ni
19:59:11 <ski> type signature of `aaa' is wrong
19:59:22 <ski> given the code, it ought to be
19:59:30 <ski>   aaa :: Char -> Bool
20:00:04 <ChaiTRex> HiPanda34: if you say a, it means you don't know the type when writing the function, so you can't know it's Char.
20:00:05 <HiPanda34> Let me try
20:00:21 <HiPanda34> thanks
20:00:50 <ski> what did you intent your function `aaa' to compute/do, HiPanda34 ?
20:02:17 <HiPanda34> if i imput 's' return True
20:02:25 <HiPanda34> this is test
20:02:52 <ski> you can actually simplify your definition
20:03:07 <ski> note that what you wrote is equivalent to
20:03:27 <ski>   aaa s = if s == 's' then True else False
20:04:26 <ski> so, if the result of your equality check is `True', then you give `True' as result. and if the result of your equality check is `False', then you give `False' as result ..
20:04:40 <ski> do you see how this can be simplified, HiPanda34 ?
20:05:02 <HiPanda34> i see ,thanks
20:05:20 <ski> what would the simplified version be, then ?
20:05:50 <ski> (hint : it's not the line of code i gave above)
20:05:57 <HiPanda34> aaa s = if s == 's' then True else False
20:06:17 <HiPanda34> ..
20:06:21 <HiPanda34> ok 
20:06:31 <ski> sorry, that has the same problem as your current code
20:07:03 <ski> (i merely restated it in another form, so that you heopfully will notice this as a "code smell", also in this form)
20:07:22 <ski> your equality test already computes a `Bool'ean (that is, `True' or `False') for you
20:07:59 <ski> you check that `Bool'ean, only to then let `aaa s' compute to .. the same `Bool'ean !
20:08:31 <ski> it's simpler to directly give the `Bool'ean you get, without checking and then giving the same result anyway
20:08:38 <ski> that is, you can simply just say
20:08:42 <ski>   aaa s = s == 's'
20:08:53 <ski> HiPanda34 : does that make sense, to you ?
20:09:29 <HiPanda34> Benefit a lot
20:10:36 <ski> beware of using `if'-`then'-`else' (or guards, in your case), having the branches yield `Bool'eans as results. often, you can achieve the same thing, in a simpler, and clearer way
20:11:08 <ski> if you have `if someTest then True else False', then this is the same as just `someTest' -- this was your case
20:11:27 <ski> if you have `if someTest then False else True', then this is the same as just `not someTest'
20:12:15 <ski> if you have `if someTest then True else someOtherTest', then this is the same as just `someTest || someOtherTest' (`||' being the logical (inclusive) "or" (one, or the other, or perhaps both))
20:12:58 <ski> if you have `if someTest then someOtherTest else False', then this is the same as just `someTest && someOtherTest' (`&&' being the logical "and")
20:14:23 <ski> for completeness, `if someTest then False else someOtherTest' is `not someTest && someOtherTest'; and `if someTest then someOtherTest else True' is `not someTest || someOtherTest'
20:15:06 <ski> HiPanda34 : you should learn to be on the lookout for these cases, and simplify accordingly
20:15:59 <HiPanda34> Ok
20:16:11 <ski> oh, also `someTest == True' is the same as just `someTest', and `someTest == False' is the same as `not someTest' -- i've also seen newbies sometimes do these
20:17:04 <iqubic> Yeah. True and False are useful to have as values in any language, but please, please don't abuse them in this way.
20:17:17 <MarcelineVQ> abuse? :>
20:17:33 <ChaiTRex> HiPanda34: have you learned sections like (+ 1) yet?
20:17:54 <ski> well, i suppose it's more like unnecessarily convoluted usage of `Bool'eans
20:18:00 <iqubic> > let f = (+ 1) in f 2
20:18:03 <lambdabot>  3
20:18:25 <iqubic> HiPanda34: That's just one way to use sections.
20:18:33 <HiPanda34> have you learned sections like (+ 1) yet?
20:18:42 <haske> would you guys recommend drilling the basics before learning monads? Im wondering if I should complete a couple of projects that don't require monads so im comfortable with syntax, thinking functionally, etc... or should I continue the research faze a bit longer? For reference I've read the first 10 chapters of learn you a haskell and am just
20:18:43 <haske> itching to make things
20:18:45 <HiPanda34> I need some time
20:18:59 <ChaiTRex> HiPanda34: OK
20:19:28 <ChaiTRex> haske: have you done other programming languages?
20:19:29 <ski> haske : "would you guys recommend drilling the basics before learning monads?" -- yes, definitely
20:20:05 <haske> ya id say im a low-intermediate java programmer
20:20:31 <haske> thats the answer I wanted to hear ski!
20:21:09 <ChaiTRex> haske: learn the basics of Haskell decently and then use the IO monad to do some things imperatively like in Java.
20:21:33 <haske> ok sounds good
20:21:41 <ski> haske : you should be comfortable with basic type usage, including polymorphism, and type class constraints, making instances of type classes, defining your own `data' types and `newtype's; and also with higher-order functions (and lets throw in recursion), before attempting to grok monads
20:21:52 <MarcelineVQ> depends on what learning monads means, if you just want to make projects then I wouldn't get too hung up. one can have a gander at http://www.vex.net/~trebla/haskell/IO.xhtml and then go nuts with whatever project they want to do
20:22:04 <ChaiTRex> they left suddenly
20:22:07 <ski> yea
20:23:46 <MarcelineVQ> Rembane: my power activated ahead of time
20:23:58 <MarcelineVQ> This is getting very dangerous.
20:40:48 <jackdk> Try me, MarcelineVQ. I can take it.
20:42:32 <MarcelineVQ> no, please, stop, don't make me kill again
20:42:45 <jackdk> no, it'll be fine, I can take it
20:43:00 <MarcelineVQ> but it was already too late
20:43:12 <MarcelineVQ> what have I become
21:31:31 <nitrix> What changes to Haskell would be required to no longer need a garbage collector? The immutable semantics seems like a large step in that direction. I imagine all sorts of sharing (like ADT tree nodes) would have to become by copy as well, so more expensive.
21:32:01 <nitrix> Are there semantics that actually requires the GC?
21:33:52 <nitrix> Sorry, I know this seems like quite the provocative question. I'm not trying to dismiss the amazing work they're doing on GHC; I'm more trying to understand why every FP language has a GC when they seem like the most likely candidates for NOT having them.
21:35:11 <davean> nitrix: how do you think immutability is related to GC? 
21:39:39 <monochrom> No change to Haskell. Change hardware to unlimited memory. JHC does this. >:)
21:40:00 <monochrom> You have unlimited data plans, why not also have unlimited memory.
21:40:28 <nitrix> davean, Mhhh, you're right, they should be orthogonal -- though I've hit some weird overlaps in my reasoning. Sorry I probably presented this poorly. Let me backtrack.
21:40:38 <MarcelineVQ> haskell being lazy-by-default makes knowing exactly how much space you'll need for a program a little difficult, in particular a program with values like [1..]  if I don't have a garbage collector I would have to make promises about how much of [1..] I'm willing to use which is really quite restrictive for the programmer
21:40:59 <MarcelineVQ> not that gc is the only factor there of course
21:41:05 <MarcelineVQ> So I'm probably also off-track with that comment
21:41:16 <davean> nitrix: GC is about life-cycle
21:41:34 <nitrix> I think at the root of the problem is sharing. If every data-structure has only one owner, the lifetime of every pieces of data would be simple.
21:41:53 <davean> uh
21:41:55 <dansho> nitrix, you just invented Rust
21:42:07 <davean> would it? Escape analysis still needs to occure at least
21:42:12 <nitrix> I'm not inventing anything, please, let me finish :(
21:42:36 <davean> Its at least a bit easier
21:43:40 <nitrix> As davean and dansho noticed, it's got to do with ownership and lifetimes. When the parent dies, it's children dies, whether the value is boxed and on the heap or not is kind of irrelevant.
21:45:47 <nitrix> Wow I'm boring myself. Anyway, Haskell does have a GC when it apparently doesn't need to. Is it only as an optimization for ADTs that ends up sharing common nodes?
21:45:56 <ChaiTRex> nitrix: you can make a program such that data is created based on input and no longer needed based on input
21:45:59 <dansho> nitrix, its probably some form of linear types, rust has them, idris2 has them, haskell probably has some weird compiler pragmas and esoteric library for it https://en.wikipedia.org/wiki/Substructural_type_system#Programming_languages
21:46:03 <davean> Oh it very much needs one
21:46:37 <dansho> or an arxiv paper^ lol
21:49:31 <nitrix> I'm not sure I understand. Suppose you completely ignore performance concerns and go for a copying strategy where nothing gets shared -- isn't ownership solved now?
21:49:54 <nitrix> Like that seems like an implementation detail to me. What features does Haskell has that absolutely requires said GC?
21:50:55 <nitrix> (Is it because of escape hatches like IORef or more fundamental? Lambdas or whatnot)
21:51:53 <davean> nitrix: I can tell you if something will be referenced again if the riemann hypothisis is true, but not otherwise - can you free it?
21:52:08 <glguy> You couldn't have a cyclic list with a copying strategy
21:52:18 <glguy> It would use up too much memory
21:52:41 <nitrix> glguy, thank you, that's a starting point. So impossible to tie knots.
21:52:49 <davean> yes, you can convert O(1) to Inf memory with copying
21:53:34 <nitrix> Guys I'm not going for some "infinite memory" unrealistic machine...
21:53:50 <davean> anyway, even if you could solve it, you'd probably still want to use the GC - and its not a solvable problem in the general case.
21:53:55 <nitrix> I think what I'm asking is perfectly sane question.
21:54:24 <davean> nitrix: Its reasonable but its fundimentally broken as a concept.
21:54:50 <davean> Its problem runs directly into fundimental impossabilities in computability.
21:55:02 <davean> You can do very good partial solutions
21:55:29 <davean> Of course you can't type every valid program either.
21:55:53 <davean> If you restrict your self, you might find a solvable domain for it, but thats not really what you're asking
21:56:04 <nitrix> davean, you lost me.
21:56:09 <davean> nitrix: where?
21:59:54 <nitrix> You start with functions that are referentially transparent. They obviously accept inputs and produces outputs, the usual domain to codomain stuff. You make things immutable (pure if you wish as well), so now the only transformations that happens in your program are through these functions whose results are bound to new identifiers. Large state changes would have to be cascaded up or down this chain of function calls.
22:00:40 <nitrix> This is essentially a stack. It seems to me it's memory usage is completely deterministic.
22:00:57 <davean> a stack is not turring complete.
22:01:19 <davean> You've just created a system dimentally weaker than general computation
22:01:27 <davean> *fundimentally
22:02:28 <davean> So, you know why PDAs are weaker than turing machines, right?
22:02:34 <nitrix> Okay, then you extend this by having heap allocated arrays or strings, whose pointer is on said stack. You then insist that there is only every one copy of this pointer.
22:03:00 <nitrix> (unique type, not so linear, if i rememeber the terminology).
22:03:03 <davean> That doesn't extend it at all unless maybe you can edit those?
22:03:53 <davean> If you can't edit the heap objects, its *identical* in power
22:03:55 <nitrix> Oh sorry, yeah, you can edit any of those. I'm visualizing the lifetimes this way, you can still mutate any of this stuff.
22:04:34 <davean> so basicly you've just invented regions then
22:04:44 <nitrix> Yes!
22:04:46 <nshepperd2> a copying strategy obviously doesn't work for IORefs or any other mutable thing
22:04:54 <davean> ... which are fundimentally weaker than comupation ...
22:06:22 <nitrix> Okay, now I'm all ears, because I'm stuck on regions and can't see why FP languages (especially the immutable ones whose semantics are usually to copy stuff around) don't ACTUALLY go for the most obvious logical implementation with region?
22:08:10 <nshepperd2> and isnt copying basically equivalent to reference counting for immutable things
22:08:21 <davean> nshepperd2: basicly
22:08:33 <davean> though you need multiple references to do a copy :)
22:08:34 <nshepperd2> which has  the usual problem with reference cycles
22:08:59 <nitrix> What makes regions weaker? If I were to strip down Haskell to use regions, what would I have to give up on?
22:09:30 <davean> nitrix: so they're not weaker if the regions can be of infinite size
22:09:40 <davean> I was sloppy there - they're weaker with each region being of finite size
22:11:06 <nitrix> Infinite as in able to grow linearly with a contiguous address space up to the maximum memory on the system, or infinite as in no computer has that kind of memory infinite?
22:11:35 <nitrix> The latter I'm guessing. How come?
22:12:21 <heatsink> Region allocation is effective if you can put a bound on the start and end of object lifetimes.   But you generally don't know when lifetimes end.  Your program might create an object and keep it around for a long time.
22:13:14 <nitrix> heatsink, yes, but for the entire lifetime duration of that object, control flow is also elsewhere doing other things but will eventually comeback where it left of.
22:13:30 <davean> not necissarily true
22:13:32 <heatsink> What is "where it left off"?
22:13:35 <nitrix> Very stack-like. You seeing that as a space-leak of sorts?
22:13:48 <nshepperd2> think of creating an object and the sending it to another thread...
22:14:18 <nitrix> heatsink, well, excuse the C but:  { /*A*/ struct foo f; /*B*/ bar(); /*C*/  }
22:14:22 <davean> nitrix: I'd like to refer back to the difference between the capabilities of PDAs and Turing machines - you've broken it a iltle but its still relivent
22:14:39 <nitrix> nshepperd2, communicating sequential processes, you copy the data.
22:14:46 <davean> You're no longer strictly a PDA but you're structure still is
22:15:29 <davean> nitrix: are you familar with non-recursively comupable functions?
22:15:54 <davean> er, I'm being sloppy again
22:16:17 <nitrix> heatsink, if the program spends a lot of time inside bar(), I could, I suppose, view `f` as a space-leak of sorts, but it's lifetime is intended to be from /*A*/ to /*C*/ and there's not much any surprises there I think. What's the issue?
22:16:48 <nitrix> davean, the term I've never heard.
22:17:11 <nshepperd2> copying the data won't work if the data is an IORef
22:18:04 <nitrix> nshepperd2, Yeah, so IORef is definitely one of the feature that requires a GC of sorts. Are there more?
22:18:26 <davean> nitrix: I should have said primitive recursive functions
22:18:27 <nitrix> nshepperd2, I think IORefs got added way after Haskell has a GC anyway.
22:18:49 <nitrix> I'm getting sloppy on my English too.
22:21:23 <davean> nitrix: so, you can make an write-once system that is turing complete, which is why we have to talk about size.
22:21:26 <heatsink> nitrix: The issue is that a function may return a reference to some of the data that it allocates.  The choice of which data to return can be unpredictable.  So at allocation time, it can't decide what region to allocate in
22:21:48 <davean> once you brought in editing the question is what the bound of the size of your regions is to get it to compute something
22:21:51 <ysangkok> found a related question: https://softwareengineering.stackexchange.com/questions/139134/do-all-functional-languages-use-garbage-collection
22:21:58 <davean> and if the answer is "there is no bound"
22:24:01 <heatsink> Consider a program that returns the most frequently occurring word in a document.  It allocates memory for many words, and eventually returns one of them.
22:24:08 <nitrix> davean, I've seen enough papers by Carl Hewitt to know where this is going, with bounded non-determinism and indeterminacy and stuff.
22:24:34 <nitrix> Okay, I'm getting frustrated. I'm probably not working the question correctly.
22:24:40 <nitrix> wording.
22:24:46 <nitrix> Doesn't help that it's 2am.
22:25:16 <heatsink> You would like to use region allocation to deallocate all the words at once.  But one word will be returned, so it will outlive the scope, so it shouldn't be deallocated.  You can't predict in advance which word that is.
22:25:19 <nitrix> Getting a stack exchange link is even more frustating, so I'm going to leave for now.
22:25:24 <nitrix> Sorry for taking everyone's time.
22:25:36 <davean> nitrix: I'm thinking more halting problem :-p
22:25:49 <nitrix> heatsink, you cannot take reference from the region, it's copied.
22:26:08 <nitrix> Haskell does this too. It's semantics does at least.
22:26:23 <davean> nitrix: not true - back to circular structures
22:26:41 <heatsink> nitrix, that is doable, but it can be inefficient depending on how much data needs to be copied.
22:27:04 <davean> an IORef to an IORef refering to the first can't be copied
22:27:12 <nitrix> Alright. Sorry, I'm done.
22:27:17 <davean> if you moved it, the firect reference would be wrong
22:27:46 <nitrix> The linear lisp paper had better insights.
22:28:21 <ysangkok> nitrix: didn't mean to dismiss you with that link
22:28:47 <davean> nitrix: its ok to limit your world to one where it is solvable BTW - thats what type systems are after all and it doesn't stop us doing the things we want generally.
22:28:57 <nitrix> heatsink, davean glguy nshepperd2 ysangkok ChaiTRex MarcelineVQ monochrom Still appreciated. I'll come back with something more tangible.
22:29:24 <MarcelineVQ> relax
22:29:37 <davean> Semantics aren't gods, we don't have to worship them :)
22:30:12 <ysangkok> it's interesting that all these imperative sounding words are used... makes me wonder if there is no framework for thinking about memory usage with lambda calculus?
22:30:38 <davean> ysangkok: what do you mean? and there are frameworks, and equivilencies
22:31:30 <ysangkok> well, i know the turing machine is theoretically with infinite memory, but it is easy to imagine the tape, and that gives you an idea of how much storage you're using
22:31:56 <ysangkok> but with lambda calculus, while theorically identical, how do you talk about memory consumption?
22:32:24 <ysangkok> i thought it was purely concerned with calculation
22:32:34 <davean> Theres terms
22:33:01 <ysangkok> ah yeah, ok, so you'd just say "less terms = less memory"
22:35:02 <davean> The relation between stacks machines and tape machines is a standard area of study though, so I was hoping nitrix was familiar
22:35:26 <davean> and one could just pull in all the results of why stacks are weak
22:35:43 <davean> there isn't as much of a heirarchy with lambda calculuses for well :)
22:36:03 <davean> They're sort of boring with their jumping to the punchinline afterall
22:50:26 <petersen> http://hdiff.luite.com/cgit/pandoc/ has been updated in a while
22:50:35 <petersen> hasn't
22:52:17 <dminuoso> petersen: The development appears to have moved to https://github.com/jgm/pandoc/issues
22:53:01 <petersen> dminuoso: er maybe you don't use hdiff, jolly useful sometimes
22:53:26 <petersen> Anyway I better ask luite himself
22:54:03 <dminuoso> petersen: Oh hold on, is that a fork of pandoc?
22:54:07 <petersen> nope
22:54:24 <petersen> hdiff provides git based on hackage releases
22:54:33 <petersen> ie you can diff release by release
22:54:56 <dminuoso> Well, if the developers follow convention (release with tags), you can do the same with git.
22:55:04 <petersen> You can
22:55:14 <petersen> It is for all of hackage :)
22:55:22 <dminuoso> That's certainly neat
22:55:27 <petersen> yep
22:55:43 <dminuoso> And that web frontend is hdiff powered?
22:55:45 <petersen> But for some reason the pandoc repo is behind
22:56:10 <dminuoso> It just looks very much as if it was just a web frontend for git *shrugs*
22:56:13 <petersen> hdiff is the web app I think - can't remember if there is also a cli
22:56:20 <petersen> It is
22:56:44 <petersen> I guess hdiff generates and updates the repo
22:57:27 <petersen> s
23:00:52 <mjrosenb> sanity check (pretty sure I'm wrong here), but are these equivalent? x <- ipreuse $ foo . bar and tmp <- get; let x = tmp ^@? foo . bar
23:42:50 <edwardk> :t ipreuse
23:42:51 <lambdabot> MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
23:42:57 <edwardk> looks right to me
23:45:02 <mjrosenb> :t (^@?)
23:45:03 <lambdabot> s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
23:45:53 <mjrosenb> ipreuse is First (i, a), while ^@? is Endo (Maybe (i,a))
23:57:56 <iqubic> I'd trust edwardk to know the answer here, since he made the library
23:58:05 * edwardk tunes in
23:58:23 <edwardk> First (i,a) is basically the same just slightly optimized
23:59:08 <iqubic> edwardk: I'm just saying that, when a question about lens specific operators is posed, I trust you to know the answer.
23:59:09 <edwardk> we ran into this all over lens, the motivations for one over the other are _very_ subtle
