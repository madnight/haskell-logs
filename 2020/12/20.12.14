00:36:30 <kuribas> ski: I found the solution for my problem: https://gist.github.com/kuribas/dc0721c819925a85666c4a313224aabd
00:37:38 <kuribas> ski: I compose the query in parallel for the applicative computations, but the monadic computations are suspended.
00:38:33 <kuribas> ski: I keep reducing the computation (and accumulate the query, fetch the results for each step), until all monadic actions are resolved.
02:08:13 <ADG1089> any idea how to parse a java project to find (indirect top level) usages of a function and then aggregate an annotation parameter from all of such top level callee context methods
02:08:31 <ADG1089> iow, trying to find all spring endpoints which use a function
02:08:46 <merijn> Eh, besides "write a parser"? :p
02:09:29 <ADG1089> i hope there are something like com.github.javaparser which parses java AST
02:15:40 <dminuoso> ADG1089: java-callgraph?
02:20:23 <ph88> hi all
02:20:47 <boxscape> hi
02:21:00 <ADG1089> dminuoso: i used call hierearchy from IDE and extracted leaf nodes, need to get annotation information for them now.
02:21:32 <ph88> I have a selection (a set of things) on which i apply filters (like: all things that are not "A" whatever that is) is there any way i can use the type system to proof that my selection will not be empty when i apply filter ?
02:23:55 <boxscape> ph88 can you make a type similar to what NonEmpty is for List for your set type and have filter return a value of that type?
02:24:59 <aplainzetakind> https://dpaste.com/G2A63PHUM I can't learn to easily identify why such megaparsec complaints arise.
02:25:24 <lortabac> boxscape: how would you guarantee that an arbitrary filter will not return an empty collection?
02:25:48 <ph88> boxscape, i think then it goes wrong at the time i want to construct NonEmpty
02:25:48 <aplainzetakind> I used `string` without complaints in what I think is an identical context in another module.
02:26:43 <boxscape> lortabac I understood the problem statement as that always being the case but I suppose it does seem likely for a filter statement to sometimes return an empty collection
02:27:18 <dminuoso> ph88: Do you have an underlying representation fixed already?
02:27:28 <dminuoso> Or can't you just keep your set of things inside a NonEmpty directly?
02:28:11 <dminuoso> Oh I see what lortabac meant
02:28:18 <lortabac> I don't think there is a simple way to prove that the predicate will be True for at least one element
02:28:29 <dminuoso> Also, this takes you directly into dependent programming.
02:28:42 <lortabac> maybe the simplest way is Liquid Haskell
02:29:02 <lortabac> if you are willing to include it into your toolchain
02:29:23 <ph88> yes could be interesting
02:29:55 <[exa]> aplainzetakind: are OverloadedStrings on/off?
02:30:26 <__monty__> Even in dependently typed languages I think you'd have to pass a proof that your predicate holds for at least one element in the collection.
02:30:54 <lortabac> ph88: a Liquid Haskell tutorial https://youtu.be/zCJV0xNY06o
02:30:54 <dminuoso> __monty__: Well that's what they asked for...
02:31:03 <dminuoso> "i can use the type system to proof ..."
02:31:14 <aplainzetakind> [exa]: On.
02:31:58 <ph88> thanks lortabac 
02:32:14 <kuribas> ph88: easiest is to return a Maybe Set, which is either Nothing, or a non-empty set.
02:32:25 <kuribas> ph88: don't even think about going the dependently typed way.
02:32:56 <ph88> why is that kuribas  ?
02:33:03 <kuribas> I mean, it's good for fun and to learn more about type systems, but it's not very useful for any practical purpose.
02:33:20 <boxscape> (to be clear liquid haskell is separate from the dependently typed way)
02:33:30 <dminuoso> I dont think there's anything wrong to pursue this idea either way. 
02:33:30 <kuribas> yeah liquid haskell is refinement types.
02:33:33 <boxscape> aplainzetakind does it work if you give a type signature to "mem["
02:33:34 <boxscape> ?
02:33:36 <kuribas> which are easier than dependent types.
02:33:42 <dminuoso> Some people tend to have "strong feelings" thinking about what's best for you.. 
02:33:56 <__monty__> That's obviously a false statement, kuribas. You should really specify what you mean by "practical" because theorem proving is very practical indeed imo.
02:34:06 <dminuoso> To say that dependent types are not very useful for any practical purpose is very debatable.
02:34:08 <nolrai> Hey, so `cis pi` from Data.Complex gives me `1.0 :+ 1.222...e-16` Which I mean isn't off by a lot..but seems like I should be able to do better. 
02:34:29 <kuribas> __monty__: I am not saying it's not practical.  I am just saying that it has diminishing returns.
02:34:31 <nolrai> Err.. -1.0
02:34:36 <dminuoso> kuribas: To you, perhaps.
02:34:38 <aplainzetakind> boxscape: No.
02:34:41 <boxscape> hmm
02:35:01 <kuribas> dminuoso: indeed.  I've found the solution most of the time heavier than the problem it's solving.
02:35:03 <dminuoso> Without knowing the constraints of their project, it's very hard to say what's useful and what's not.
02:35:12 <kuribas> true
02:35:54 <lortabac> I think both a solution based on GADTs and one based on Liquid Haskell can be interesting to explore
02:36:15 <lortabac> however at work I would be very hesitant
02:36:19 <[exa]> aplainzetakind: what does the typesystem think if you put a hole into the type of the whole function?
02:36:20 <dminuoso> Superficially, I'd say provably correct software can be quite valuable.
02:36:40 <lortabac> I'd probably just accept that types do not encode 100% of the invariants and move on
02:36:52 <kuribas> I've found most of the time that you can find a satisfactory solution that doesn't use advanced type system features.
02:36:56 <dminuoso> lortabac: Yeah, like I said. It depends on the constraints. :)
02:37:18 <merijn> kuribas: -XKitchenSink is like spice, a little can go a long way :p
02:37:19 <dminuoso> If being provably correct is worth more than the engineering overhead behind it, say because it's a mission critical piece...
02:37:39 <boxscape> nolrai that's IEEE754 floating point numbers for you, I suppose
02:37:47 <aplainzetakind> [exa]: It complains at the caller site.
02:37:51 <lortabac> dminuoso: yes, "depends on the context" is probably the best answer
02:38:16 <aplainzetakind> Because the caller also needs InputStream s => Parser s a
02:38:18 <nolrai> boxscape: I mean its really from storing radians I think..but yeah.
02:38:30 <aplainzetakind> It says f0 is not that sort of thing.
02:38:35 <kuribas> dminuoso: I've read that a lot of "mission critical" software doesn't use formal methods or functional programming, they just have stronger reviews and more guidelines.
02:39:28 <[exa]> aplainzetakind: so what does it say for `string "mem[" :: _` ?
02:39:47 <Kronic> Reviews and guidelines are fairly fragile
02:40:03 <dminuoso> kuribas: Our inhouse SDN solution employs some (albeit simplistic) formal methods to verify correctness of the resulting network.
02:40:08 <kuribas> It's also scary how low the standards are for software in cars, etc...
02:40:20 <nolrai> kuribas: I mean lots of "mission critical" software fails anyway.
02:40:23 <kuribas> dminuoso: cool
02:40:40 <__monty__> If this is for a hobby project I'd actually try dependent types first. Always good to have at least some understanding of people's praises and criticisms.
02:41:14 <Kronic> Nevermind cards, I've worked in finanance and automation (i.e. robotic arms that if you put in the wrong value could rip a person in half), in my experience most of it is just "well this worked before so we'll do that"
02:41:24 <kuribas> I'd learn dependent types because it gives you more insight into type theory, not because it will make everything you write bug-free.
02:41:40 <Kronic> But not in the traditional "follow the same method" kind of way, more like "I'm going to copy paste 20,000 lines of code and that's just how it is"
02:42:03 <srk>  /o\
02:42:12 <Kronic> cars*
02:42:23 * srk trying to haskell robotics and its quite fun
02:42:32 <kuribas> dminuoso: I also made the guess that ph88 having an empty set, would not rip a person in half, statistically speaking :-)
02:42:42 <__monty__> Kronic: If certification is involved that doesn't even seem like a bad strategy. Getting new software certified is probably way too costly.
02:42:50 <aplainzetakind> [exa]: Could not deduce IsString s for Tokens s.
02:43:01 <Kronic> You're absolutely right __monty__ 
02:43:18 <Kronic> Getting new anything is costly, that's why much of it runs on VB 6 and C++ 98
02:43:20 <kuribas> isn't format methods more used in hardware now, like CPUs?
02:43:21 <[exa]> aplainzetakind: and Tokens s is [Char] or something else?
02:44:19 <aplainzetakind> So, if I modify my InputStream synonym to include IsString (Tokens s), I need FlexibleContexts but I think it will work. But other modules who use InputStream start complaining.
02:44:38 <aplainzetakind> I'm trying to make things compatible with both String and Text
02:44:41 <__monty__> Amazon apparently also puts TLA+'s model checker to good use. Probably for distributed systems.
02:44:44 <aplainzetakind> Tokens Text ~ Text
02:44:52 <aplainzetakind> Tokens String ~ String
02:46:03 <aplainzetakind> Strange thing is, I have been able to do this so far.
02:46:41 <aplainzetakind> Oh no I haven't.
02:46:43 <srk> I've started a toy Haskell CAS for optimizing kinematic expressions but quickly hit a brick wall trying to test it using quickcheck due to inf / div by zeroes. sounds like a job for Agda :|
02:46:44 <aplainzetakind> Damn.
02:46:46 <[exa]> aplainzetakind: it looks to me as if it cannot deduce that Tokens s ~ [Char]
02:46:57 <[exa]> from the available Token s ~ Char
02:47:04 <aplainzetakind> I added Tokens s ~ Text to the signature.
02:47:17 <aplainzetakind> (I'm presenly working with Text).
02:47:24 <[exa]> which technically it cannot because there is certainly more than 1 possibility for Tokens
02:48:25 <[exa]> srk: the quickcheck preconditions don't help? (==>, NonZero, ...) ?
02:48:28 <aplainzetakind> So adding IsString (Tokens s) to the constraints of InputStream should solve it.
02:48:44 <aplainzetakind> How harmful is FlexibleContexts considered to be?
02:49:21 <merijn> aplainzetakind: Not at all
02:49:27 <[exa]> AFAIK everyone is using that...
02:49:33 <aplainzetakind> Alright then.
02:49:41 <merijn> aplainzetakind: The report is overly strict in what it allows for typeclasses
02:50:12 <boxscape> aplainzetakind as a further bit of evidence that it's uncontroversial, it's going to be included in GHC2021 by unanimous decision
02:50:29 <boxscape> (at least, it's looking like that'll be the case)
02:50:44 <[exa]> that reminds me, are the "state of haskell" results available already?
02:50:45 <merijn> FlexibleContexts is about as controversial as saying "I like music" :p
02:55:17 <aplainzetakind> My problem remains unsolved.
02:55:54 <aplainzetakind> Now it's not satisfied with having IsString (Tokens s) but demands Tokens s ~ Text.
02:56:39 <aplainzetakind> OK I think I see why.
02:56:42 <aplainzetakind> I hope.
03:01:13 <tomsmeding> boxscape: "by unanimous decision" -- in what venue? The state of haskell survey?
03:01:31 <boxscape> tomsmeding steering committee votes
03:01:37 <boxscape> tomsmeding see bottom of this page https://github.com/ghc-proposals/ghc-proposals/blob/ghc2021/proposals/0000-ghc2021.rst
03:01:44 <tomsmeding> thanks!
03:10:05 <tomsmeding> interested to see some not-entirely-safe extensions like GeneralizedNewtypeDeriving and FlexibleInstances make the cut (probably), though they are indeed very useful
03:10:39 <boxscape> tomsmeding there was some discussion about GND on the mailing list but not much
03:12:16 <boxscape> tomsmeding more generally some people advocate using DerivingVia over GND
03:14:54 <tomsmeding> oh, neat!
03:15:34 <tomsmeding> didn't realise it generalised GND, will try to remember :p
03:15:50 <tomsmeding> (G2ND?)
03:35:43 <aplainzetakind> How can I make the Proxy in the second line behave as I expect? https://dpaste.com/6EYUAT96U
03:36:52 <aplainzetakind> That is Text.Megaparsec.chunkToTokens
03:39:13 <srk> [exa]: iirc part of the problem was that you can get expression such as 0^(-1) due to generated AST (Pow (Lit Zero) (Sub (Lit Zero) (Lit One))
03:40:47 <srk> and problematic things can appear after e.g. simplification or derivation. type system would help .. :D
03:51:34 <ccapndave> I have just written my first ever program in Haskell
03:51:40 <ccapndave> And it actually does something useful
03:51:56 <ccapndave> This language is awesome :)
03:52:01 <boxscape> ccapndave congrats!
03:52:46 <ccapndave> Now I have an uncontrollable urge to refactor it
03:53:05 <boxscape> yeah haskell does that to me, too
03:56:27 <aplainzetakind> Trying to write this function but Proxy doesn't let me: https://dpaste.com/7SU74Y5M7
03:57:29 <boxscape> aplainzetakind in most contexts Proxy has to be used either with a type signature or with (Proxy @SomeType)
03:58:51 <boxscape> hmm although considering the return type of chunkToTokens also contains s I'm not quite sure if that can help here
03:58:53 <aplainzetakind> I want the s free, so how can I give it some type?
03:59:17 <boxscape> aplainzetakind you can say (Proxy @s) if you have ScopedTypeVariables
03:59:42 <boxscape> and write `forall s .` at the beginning of the type signature for chunkToTokens'
03:59:49 <ski> or `Proxy :: Proxy s'
04:00:15 <boxscape> (without the `forall s`ScopedTypeVariables won't actually be engaged)
04:04:19 <aplainzetakind> Great thanks.
04:04:35 <aplainzetakind> Didn't know about ScopedTypeVariables
04:04:51 <aplainzetakind> Though this doesn't feel too safe?
04:05:16 <aplainzetakind> Like Proxy was there to ensure something and I circumvented it.
04:06:05 <merijn> aplainzetakind: ScopedTypeVariables are fine
04:06:31 <ski> no, `Proxy' is there so you can fix / pin down the `s' when calling the operation, despite no other parameter or result type mentioning `s'
04:06:42 <merijn> aplainzetakind: The problem is that (normally) type variable scope is limited to the type signature, so if you use 'a' in a where block or local annotation, that 'a' is *different* from the 'a' in the top level signature
04:07:04 <merijn> aplainzetakind: ScopedTypeVariables extends the scope of variables in top level types to the entire body/where block of a binding
04:08:27 <aplainzetakind> merijn: I understand the effect, but I thought there should be reason for the default.
04:08:39 <aplainzetakind> Not based on any concrete reasoning.
04:08:44 <aplainzetakind> If it's fine it's fine.
04:10:39 <boxscape> aplainzetakind some people aren't happy with the way ScopedTypeVariables works, but safety is not the concern
04:10:44 <merijn> aplainzetakind: The reason is "you often wanna write polymorphic helpers and needing unique type variables is kinda annoying"
04:11:30 <boxscape> Richard had an interesting example of couter-intuitive behavior here https://mail.haskell.org/pipermail/ghc-steering-committee/2020-December/001973.html
04:11:32 <merijn> aplainzetakind: like, I often use 'a' as polymorphic type in both the top level and the where block and having those be forced to be the same can be annoying, in terms of risk/safety there's no problems
04:14:07 <aplainzetakind> I see. Personally ScopedTypeVariables version feels more natural then.
04:14:29 <aplainzetakind> I usually use a to mean 'that a' and find myself realizing that's not how it works.
04:18:17 <dminuoso> aplainzetakind: That's a historical accident, sadly.
04:18:44 <dminuoso> If we were to reinvent Haskell from scratch, we'd probably have the behavior of ScopedTypeVariables on by default without explicit forall.
04:19:14 <ski> an inverted `ScopedTypeVariables' has been discussed here
04:19:54 <boxscape> dminuoso one counter-argument to that is that you can write type declarations far away from functions bodies and its where clauses, though I suppose one could have disallowed that, as well
04:20:30 * ski . o O ( discontiguous/1 )
04:22:03 <Kronic> Huh I never noticed that
04:22:09 <Kronic> Is there a way to disable that ?
04:22:10 <dminuoso> The one part Im not quite happy about, is pattern type signatures.
04:22:20 <boxscape> why not?
04:22:23 <boxscape> Kronic I don't think so
04:22:31 <Kronic> That's unfortunate 
04:22:37 <dminuoso> boxscape: For the same reason I'm excited for `id @a = ...`
04:22:49 <dminuoso> It's a clutch that doesn't fit well
04:22:53 <boxscape> that's fair
04:23:21 <boxscape> Kronic Richard mentioned in the email I linked above that he saw some people write C-style header files, included via CPP, for Haskell programs
04:23:31 <boxscape> with those header files containing the type declarations
04:26:21 <ski> interesting
04:26:49 <superstar64> i have this idea for a state based typeclass system for my language, where `F a => x` corresponds to `F a -> (x, F a)`
04:26:54 <superstar64> has this been thought of before?
04:28:03 <Kronic> huh... I feel like that should be something you have to enable and not something that is on by default
04:29:45 <dminuoso> Kronic: superstar64  Yes.
04:29:57 <dminuoso> superstar64: The concept is captured by MonadState, but it's even more general than that
04:29:57 <superstar64> is there a paper on this?
04:30:30 <superstar64> that requires do notation, my idea doesn't
04:30:37 <dminuoso> No it does not require do notation
04:30:48 <merijn> superstar64: Nothing requires do notation
04:30:52 <superstar64> it forces you to wrap your code in monad
04:31:00 <dminuoso> That's a flawed thinking.
04:31:25 <superstar64> don't typeclasses already correspond to an implicit reader monad?
04:31:34 <superstar64> why not an implicit state monad, or any other monad
04:31:44 <dminuoso> No, that's at best an implementation detail
04:32:08 <dminuoso> And also not "reader monad"
04:32:08 <superstar64> it's what i want in my language, i'm just asking if this exist already
04:32:21 <dminuoso> I think, you have some flawed conception about what "monad" means
04:33:06 <pjb> It's a dyad but with only one element.
04:33:17 <dminuoso> superstar64: Let's explore your `F a -> (x, F a)` idea for a moment. Any sugar you want to build here, *already* is inherently monadic whether you call it that or not.
04:34:03 <superstar64> if `f : F a => x -> y` and `x : F a => x` then `f(x) : F a => y`, typeclasses implicity call `pure` and `<*>` on your code
04:34:07 <superstar64> just only for the reader monad
04:34:23 <pjb> It's a gang if Chinese bandits, but with only one bandit.
04:34:27 <pjb> s/if/of/
04:35:04 <Kronic> what's wrong with it being a monad anyway?
04:35:06 <superstar64> `pure' : x -> (F a => x)`
04:35:41 <superstar64> Kronic, it would be nice if people could write imperative code in my language without jumping though hoops if you wanted to
04:36:17 <Kronic> Why is using a monad a hoop?
04:36:27 <dminuoso> "using a monad"..
04:36:31 <Kronic> Not trying to belittle you I just don't get where you are coming from 
04:36:36 <ski> if `t :: T |- f t :: a -> b' and `t :: T |- x t :: a', then `t :: T |- (f t) (x t) :: b'. function application implicitly calls `(<*>)', yes ?
04:37:18 <dminuoso> superstar64: Anyhow, what you're asking for is precisely captured by MonadState 
04:37:30 <ski> dminuoso, i'm not so sure
04:38:05 <ski> reminds me more of threaded attributes in attribute grammars
04:38:19 <superstar64> ski i think so
04:40:42 <ski> superstar64 : it's backwards. you can explain/understand how free variables are "distributed" to parallel subexpressions (like with application), in terms of input/reader, but that doesn't "make them implicitly call `(<*>)'"
04:41:09 <ski> (ditto for how evidence for constraints are distributed)
04:43:03 <ski> `(<*>)' is an operation defined in Haskell. conceptually, understanding basic application (and also type class overloading), comes before understanding something like `(<*>)', whose usage builds upon the former
04:43:05 <superstar64> `main :: IO => (String, String)``main = (getStr,getStr)`
04:43:24 <kuribas> is there a monoid over kleisli composition?
04:43:45 <ski> (if you were talking about a mathematical version of `(<*>)', that you used to understand or talk about the semantics of a language, then that could be a different discussion)
04:44:00 <Taneb> kuribas: not in base but there's Data.Monoid.Endomorphism in monoid-extras
04:44:04 <superstar64> ski i know that, i'm just saying that typeclass desugaring is effectively a auto reader monad
04:44:10 <Taneb> Which takes a category as a parameter
04:44:27 <ski> superstar64 : did you even check out linear implicit parameters ?
04:44:37 <superstar64> that's a thing?
04:44:43 <ski> it was a thing
04:45:30 <ski> it automatically called a `split' operation, everytime the implicit parameter would be passed on to two (or more) subcomputations
04:45:37 <ski> (there was no state-threading)
04:45:46 <kuribas> Taneb: ok, thanks :)
04:46:30 <boxscape> https://www.reddit.com/r/haskell/comments/6ps8zs/linear_implicit_parameters/
04:46:34 <ski> superstar64 : your `main' example looks like it wants to express side-effect annotations
04:46:37 <boxscape> linear implicit parameter discussion
04:46:57 <superstar64> i think i might have rediscovered that yes
04:48:01 <ski> superstar64 : "Fun with Linear Implicit Parameters" by TheHunter in 2005-05 at <https://wiki.haskell.org/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> might be interesting
04:48:28 <superstar64> i'll have to look into this more i guess
05:10:49 <kuribas> hmm, I have an interesting monad instance: instance Monad (DataSourceT query m) where ds >>= f = f <$> ds
05:10:54 <kuribas> is this a free monad?
05:11:49 <kuribas> wait, that's wrong...
05:14:17 <boxscape> % :t \(ds :: m a) (f :: (a -> m b)) -> f <$> ds
05:14:17 <yahb> boxscape: Functor m => m a -> (a -> m b) -> m (m b)
05:14:20 <boxscape> missing the join there, eh
05:14:35 <kuribas> yeah
05:15:13 <superstar64> wait, you can type annotation on lambda variables?
05:15:33 <boxscape> yeah, though I'm somewhat surprised that it realizes that I want those `a`s to be the same
05:15:45 <geekosaur> part of ScopedTypevariables I think
05:15:51 <superstar64> my world has been changed
05:19:45 <tomsmeding> :t \x f -> join (fmap f x)
05:19:46 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
05:19:59 <tomsmeding> kuribas: I think with join, you've implemented >>= in terms of >>=
05:20:27 <kuribas> tomsmeding: yeah, the correct implementation is a bit more complicated.
05:20:35 <tomsmeding> as in: x >>= f = f <$> x is always valid :)
05:20:44 <tomsmeding> (no, join (f <$> x))
05:20:51 * tomsmeding fell in the same trap
05:21:12 <kuribas> my new instance is to large to paste here...
05:21:15 <int-e> obey the laws!
05:21:28 <tomsmeding> of not falling in the trap?
05:21:30 <kuribas> it's only fmap in one case...
05:21:40 <int-e> tomsmeding: of the monad class, in this case
05:22:54 <kuribas> but it still looks free-monadish...
05:23:41 <kuribas> I guess it's just as inefficient then...
05:23:53 <boxscape> tomsmeding In an ideal world that would be the default implementation of >>= and you could define a Monad instance in terms of join if you wanted
05:24:14 <boxscape> alas, join is not part of the Monad class for some roles-related reason
05:24:53 <boxscape> Though Ryan Scott made a blog post at some point saying QuantifiedConstraints would let us get it in there, so I'm not sure if there's a good reason for why it's still not part of the class
05:25:28 <int-e> ?
05:25:45 <boxscape> I'm not sure what you're asking
05:25:50 <tomsmeding> int-e: https://paste.tomsmeding.com/bcyGojqR I'm satisfying the laws, don't worry :p
05:25:53 <int-e> isn't it historical reasons
05:26:05 <boxscape> int-e https://gitlab.haskell.org/ghc/ghc/-/wikis/roles2
05:26:36 <int-e> ...30 minutes later...
05:28:27 <int-e> So it... breaks GND in some cases... okay I can believe that.
05:30:25 <int-e> But I also suspect that this isn't the reason why join isn't in the Monad class. But it is a good reason why we can't just add it, thanks!
05:31:18 <boxscape> I suppose if this reason didn't exist, if it hadn't been for the Applicative-Monad proposal, join likely also wouldn't be in Monad
05:31:42 <kuribas> how is the transformation called to make free efficient?
05:32:37 <int-e> codensity?
05:32:49 <kuribas> right, thanks!
05:35:05 <int-e> http://comonad.com/reader/2011/free-monads-for-less-3/ (linking the last post because forward links are hard to find)
05:36:57 <dminuoso> 14:14:51      superstar64 | wait, you can type annotation on lambda variables?
05:37:03 <int-e> kuribas: And there's an implementation of it that predates all that theory: https://hackage.haskell.org/package/MonadPrompt
05:37:23 <kuribas> int-e: which one should I take?
05:37:28 <kuribas> or roll my own version?
05:37:33 <int-e> (I'm biased, I was involved in that one)
05:38:33 <int-e> Honestly, between MonadPrompt, free, operational, and probably more... I don't even know what the exact trade-offs are.
05:39:24 <kuribas> I just want something to easily plug into my own type.
05:39:44 <kuribas> kan-extension has to many dependencies...
05:40:23 <int-e> Oh I finally get what you want, hmm.
05:41:05 <kuribas> codensity is like ContT over a monad right?
05:41:48 <kuribas> ah, it's actually a generalization of ContT...
05:41:56 <kuribas> with the return type polymorphic...
05:42:09 <int-e> Yeah isn't it really just ContT except you never mess with the continuations?
05:42:23 <kuribas> haha, right :)
05:49:57 <Kronic> Question: What is one thing you guys like to point to when trying to convince people to give haskell a trial? I've been chatting to a co-worker about it for a while on and off, here and there, and I've mentioned many good things about Haskell but it's hard to think of one thing that is easily demonstrable that is also definitively better than what you might find in a run of the mill language. tl;dr What's that killer feature that I can point to to 
05:49:58 <Kronic> encourage people to give it a shot?
05:51:58 <kuribas> the ability to create expressive and concise code which is also very robust.
05:52:14 <Kronic> I find it hard to locate just one thing to talk about because while I know the concurrency is good and the type system is amazing, for me what drives me to learn haskell is the combination of many things. 
05:53:03 <kuribas> Kronic: indeed, concurrency is easier when you go purely functional, and onlike other languages, haskell can garantee you stay pure.
05:53:36 <kuribas> Kronic: compare that to lock free mutable structures, which are incredibly hard to write.
05:54:06 <kuribas> concurrency is just so easy to add as an afterthought, which isn't true in other language.
05:55:42 <int-e> kuribas: the code really looks like GND should work :-/ https://paste.debian.net/1176860/
05:55:53 <Kronic> I feel like that's a really good point right there
05:56:08 <Kronic> Not specifically concurrency, but adding it after the fact
05:56:11 <kuribas> int-e: ah cool :)
05:56:35 <Kronic> I guess refactoring is probably the main thing that would attract people I know, considering that is a pain point in some of my work codebases 
05:56:41 <kuribas> Kronic: I can imagine in java you have to be careful about tons of things.
05:57:30 <Kronic> No need for me to imagine, you certainly have to be careful. I've plenty of experience in Java
05:59:00 <int-e> kuribas: I wouldn't be surprised if the version in `free` uses `unsafeCoerce` for better performance
05:59:15 <kuribas> coerce to what?
05:59:25 <int-e> kuribas: basically, fmap = unsafeCoerce fmap, and so on, with type signatures to pick the right one
05:59:43 <kuribas> right
05:59:51 <int-e> just like the old GND would do
06:01:17 <superstar64> is there a different between `instance F a a` and `instance (a ~ b) => F a b`?
06:02:14 <kuribas> superstar64: yes
06:02:38 <kuribas> the first instance is not a candidate when a and b are different.
06:02:54 <kuribas> the second one is, but will the fail.
06:03:40 * ski . o O ( `f(A,B) :- !,A = B.' )
06:05:09 <superstar64> ski does does your `!` mean here?
06:05:25 <ski> cut
06:05:40 <ski> it's a Prolog thing
06:06:22 <superstar64> it's fun being in a position of already written a unifier and not knowing anything about prolog
06:06:25 <ski> it basically means "disregard other possibilities of making the f/2 call succeed"
06:07:08 <ski> (which seems similar to the effect that `instance a ~ b => F a b' has)
06:09:17 <ski> (`!' is one of the main non-declarative / impure constructs in Prolog. so this points to perhaps the aforementioned behaviour of instance heads also ought to be considered non-declarative ..)
06:12:29 <tomsmeding> merijn: earlier you convinced me that cabal flags were only for build configurations and not intended to be specified by end-users, but now I read the cabal docs and find "most of the time a flag represents certain feature, that can be switched on or off by the package user", and the relevant `manual` field: https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-flag-manual
06:12:33 <tomsmeding> so what's the deal? :p
06:13:57 <geekosaur> sounds like the cabal devs gave up
06:16:40 <int-e> tomsmeding: It's meant for enabling specific features... say debugging builds.
06:18:36 <tomsmeding> which is exactly what merijn was arguing was _not_ the point of flags, assuming that I understood correctly
06:18:53 <int-e> it's the point of *manual* flags
06:18:57 <tomsmeding> and if that's one possible use of flags, that begs the question why setting them is so terribly cumbersome
06:19:12 <tomsmeding> or does "just setting a flag" "just work" with manual flags?
06:19:24 <tomsmeding> I have to admit that I've probably only tried it with non-manual flags
06:19:54 <int-e> they have limited use, obviously, because you don't have a good way of depending on a package-with-a-particular-flag-set, so basically to keep things sane, the flags can only affect performance, not functionality.
06:19:59 <merijn> tomsmeding: The only other solution is "integrating flags in the constraint solver"
06:20:13 <merijn> tomsmeding: Which exponentially blows up the search space and makes things more complicated
06:20:23 <tomsmeding> makes sense
06:20:32 <int-e> (for libraries. leaf packages like executables are a different matter, perhaps)
06:20:45 <tomsmeding> good point int-e 
06:20:52 <merijn> tomsmeding: And no one wants to deal with that, so dependencies can't specify flags, and therefore you shouldn't use them
06:21:26 <tomsmeding> so that means that for libraries, non-manual flags are for build configuration, and manual flags are available for end-user configuration but due to implementation difficulty hard to use and thus not recommended?
06:21:30 <merijn> tomsmeding: It's not so much that "feature flags are bad" it's "there's no reasonably way to support feature flags without exploding complexity and there's not enough manpower or compute"
06:22:19 <tomsmeding> yes I see
06:22:21 <merijn> People already complain if the constraint solver can't handle build plans
06:22:55 <int-e> for library, 'enable debugging' and maybe a 'enable experimental features' is about the scope I'd be willing to use manual flags for... so things not really targeted at users but at testers and developers.
06:25:46 <kuribas> is there a "free monad" over another monad?
06:26:29 <kuribas> so, forall r. (m a -> r) -> (m f -> r) -> r ?
06:27:21 <ski> `f' ?
06:27:48 <kuribas> newtype F f m a = forall r. (m a -> r) -> (m f -> r) -> r
06:28:05 <int-e> f has a kind problem there
06:28:25 <ski> `f' has kind `Type'
06:28:31 <kuribas> https://hackage.haskell.org/package/free-5.1.4/docs/Control-Monad-Free-Church.html#t:F
06:28:54 <superstar64> kuribas, isn't that equivalent to `newtype F f m a = Left (m a) | Right (m f)`
06:29:10 <kuribas> right newtype F f m a = F forall r. (m a -> r) -> (m f r -> r) -> r
06:29:33 <kuribas> superstar64: yes (and it's wrong)
06:29:46 <ski> so `m's not supposed to have kind `Type -> Type' ?
06:29:56 <manafbtc> hi
06:29:59 <kuribas> ski: yes, m is the monad
06:30:13 <superstar64> kuribas, now there's a kind error with m
06:30:21 <ski> how can both `m a' and `m f r' have kind `Type'. is `m' polymorphic ?
06:30:24 <kuribas> m (f r) then?
06:30:43 <ski> hello manafbtc
06:34:10 <ski> what do you mean by free monad over another monad ?
06:34:45 <kuribas> I am not sure ... :-P
06:35:12 <ski> the free vector space over a vector space would just be that same vector space. so it seems to me that a free monad over a monad would be the same as that monad (but perhaps with some efficiency gains ?). but possibly you don't mean quite that
06:35:37 <superstar64> `Constructor ‘ForallP’ must use the type variable only as the last argument of a data type` what does this mean exactly?
06:35:48 <superstar64> i'm trying to use derive functor
06:36:25 <ski> (hm, i guess the efficiency gains i know about comes from forgetting that it's a monad, only treating it as a functor, and then taking the free monad over that functor ..)
06:36:39 <kuribas> ski: I have a type that looks very freeish...
06:36:50 <superstar64> here's the constructor ` ForallP (TypeSystem.Forall Linearity Stage (Kind p) (Type p)) deriving (Show, Functor)`
06:36:52 <kuribas> better I'll work it out and come back
06:37:01 <ski> mhm
06:37:23 <ski> superstar64 : using GND ?
06:37:30 <superstar64> what's GND?
06:37:40 <ski> `GeneralizedNewtypeDeriving'
06:37:50 <superstar64> i'm using derive functor
06:38:02 <superstar64> `  default-extensions:  MultiParamTypeClasses, FunctionalDependencies, DeriveTraversable, FlexibleInstances, NoMonomorphismRestriction, TypeFamilies, PatternSynonyms`
06:38:05 <ski> i'm assuming the data constructor is for some type `Foo p' ?
06:38:42 <superstar64> https://pastebin.com/raw/z2PATHRu
06:39:52 <superstar64> i guess i could write the map manually, it's only 3 lines
06:40:33 <ski> % data Foo a = Mk [a] (Maybe a) deriving Functor
06:40:33 <yahb> ski: 
06:40:39 <ski> % data Foo a = Mk (Either [a] (Maybe a)) deriving Functor
06:40:39 <yahb> ski: ; <interactive>:30:49: error:; * Can't make a derived instance of `Functor Foo': Constructor `Mk' must use the type variable only as the last argument of a data type; * In the data declaration for `Foo'
06:41:03 <ski> % data Foo a = Mk [a] (Either a String) deriving Functor
06:41:04 <yahb> ski: ; <interactive>:33:48: error:; * Can't make a derived instance of `Functor Foo': Constructor `Mk' must use the type variable only as the last argument of a data type; * In the data declaration for `Foo'
06:41:06 <ski> % data Foo a = Mk [a] (Either String a) deriving Functor
06:41:07 <yahb> ski: 
06:41:42 <superstar64> is it a ghc bug?
06:42:22 <ski> seems each parameter type can only mention the parameter (the last parameter of the declared data type) "at the end"
06:44:43 <boxscape> which makes sense, since `instance Functor (Either a)` exists, but `instance Functor (\b -> Either a b)` does not
06:44:52 <boxscape> er
06:45:01 <boxscape> instance Functor (\b -> Either b a), even
06:45:34 <boxscape> no that's not right either
06:45:53 <dminuoso> boxscape: That's a moot argument.
06:46:03 <dminuoso> I dont think it's the real reason either.
06:46:54 <ski> yes, since it (with two exceptions) will just call `fmap' on components (whose types mention, but is not identical to, the type parameter), according to <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-functor-instances>
06:47:11 <boxscape> well, I'd say it's a manifestation of the real reason, which is, you can only make Functor instances over the rightmost parameter of a type constructor, hence why only the first Either instance exists
06:47:34 <ski> (the two exceptions apparently being tuple types, and function types)
06:48:11 <boxscape> (s/why//)
06:48:23 <ski> .. makes me wonder whether we should have a type class for expressing that a type class is functorial ..
06:48:53 <dminuoso> Uh.. perhaps I just expected this to use generics, rather..
06:49:01 <dminuoso> Mmm
06:49:30 <ski> (e.g. `Eq' is clearly contravariant, while `Bounded' is covariant)
06:50:11 <boxscape> % type F :: (a -> Constraint) -> Constraint; class F a
06:50:11 <yahb> boxscape: 
06:50:15 <boxscape> % instance F Functor
06:50:15 <yahb> boxscape: 
06:50:21 <boxscape> hm I had no idea you could do this
06:52:02 <ski> so perhaps `data Foo a = Bounded a => MkFoo [a] deriving Functor' and `data Bar a = MkBar (Eq a => [a]) deriving Functor' ought to work, with `DeriveFunctor' ?
07:54:09 <dolio> ski: That's actually not correct, though.
07:55:05 <dolio> Treating classes as functorial depending on their methods could introduce non-canonical instances.
07:56:20 <dolio> Because applying a map `f : a -> b` to the instance for `a` doesn't necessarily give you the instance for `b` (or flip it for contravariant things).
08:14:28 <ski> hm, good point. you lose uniqueness, since given many different `a -> b', and a single evidence of a `C a' constraint, you'd get, in general, many different evidence for a `C b' constraint
08:22:12 <ski> % type role DictBounded representational; data DictBounded a = Bounded a => DB
08:22:13 <yahb> ski: ; <interactive>:51:1: error:; * Role mismatch on variable a: Annotation says representational but role nominal is required; * while checking a role annotation for `DictBounded'
09:05:58 <__monty__> I have to say my perception of HN is in line with merijn's. Lobste.rs is supposed to be better in some way but to me it reads pretty same-y.
09:06:14 <__monty__> Sorry, that was meant for -offtopic.
09:33:55 <xerox_> hah I didn't know you could have empty where blocks!
09:34:07 <xerox_> I removed all of the bindings from there and it just compiled
09:34:15 <geekosaur> don't see why not
09:35:55 <xerox_> it just never happened to me before
09:46:43 <mniip> wow I just realized that the docs on Data.Number.CReal are misleading
09:49:02 <mniip> >Note that the comparison operations on CReal may diverge since it is (by necessity) impossible to implementent them correctly and always terminating.
09:49:15 <mniip> this gives the impression that Eq may not terminate
09:49:28 <mniip> but instead what happens is that Eq always terminates but is sometimes incorrect!
09:49:44 <mniip> > 0 == (2^^(-138) :: CReal)
09:49:46 <lambdabot>  True
09:50:28 <Vulfe> yeah that's a little bit surprising
09:54:39 <mniip> in the same bin, there are CReal's that 'show' to the same string but aren't ==
09:54:53 <polyphem> hi , i think i have heard there is  a way to easily find out all the packages that use a specific package on hackage as a dependency . However now it doesnt come to my mind. Suggestions ?
09:54:55 <mouseghost> cereal
09:55:23 <solonarv> polyphem: https://packdeps.haskellers.com/reverse ?
09:56:58 <polyphem> solonarv: nice, thanks
09:58:39 <h1ccup> in parsec, i have a parser that, by succeeding in one of its branches, causes the overall parse to fail. how do i make the parse backtrack to also try its other branches?
09:59:08 <xerox_> what if you stick 'try' before it
09:59:33 <monochrom> change "xxx <|> yyy" to "try xxx <|> yyy"
09:59:39 <h1ccup> xerox_: doesn't work cuz a branch succeeds
10:00:05 <h1ccup> monochrom: if xxx succeeds, how do i get it to try yyy?
10:00:31 <monochrom> No, my xxx is non-atomic, part of it succeeds.
10:00:53 <xerox_> that's what I had gotten from your explanation as well
10:01:19 <geekosaur> that, or you should just attempt yyy before xxx insteadof the other way around
10:01:30 <monochrom> "try xxx <|> yyy", if xxx is partly successful but eventually fails, will come back to do yyy.
10:02:07 <h1ccup> xxx is wholly successful, it's just part of a larger parse where it should not succeed.  in that case i want it to try yyy
10:02:28 <monochrom> This is my xxx, I say that it is not wholly successfully, therefore it is not.
10:02:42 <monochrom> You fit my example into your code properly.
10:03:44 <h1ccup> my actual example that i can't figure out: i want to parse a sequence of digits, but only allowed lengths.  countr ns p = choice $ (try . flip count p) <$> ns
10:04:03 <sclv> write a parser that parses a sequence of digits of any length
10:04:20 <sclv> then write another parser that calls it, then checks the result and fails if its not an allowed length
10:04:31 <sclv> then wrap `try` around that outer parser
10:05:01 <h1ccup> sclv: i agree that would work, but would like to understand why mine doesn't and if there's a way in its vein that would.
10:05:54 <h1ccup> i know i could sort ns descending but feel that's a bit brutish
10:06:17 <sclv> lol if that's the only issue, then yes, sort it descending
10:06:22 <sclv> ffs
10:06:52 <h1ccup> but in general shouldn't there be a way to make it try other branches when a succeeding branch makes the whole parse fail?
10:07:07 <sclv> no
10:07:26 <Kronic> Interesting, we're talking about parsers I was just about to ask a question
10:07:38 <sclv> not without exponential blowup and also without introducing a ridiculously infeasible grammar
10:08:03 <sclv> i mean you can wrap everything in a try everwhere, or use an "inverse" system with `commit` like polyparse
10:08:08 <sclv> but like just write a nice grammar
10:08:08 <Kronic> Originally I wanted to write this: count 7 $ map string ["F", "B"] but obviously this does not work because the types do not match
10:08:20 <Kronic> So I came up with count 7 $ char 'F' <|> char 
10:08:36 <Kronic> oops... 'B' on the end there. Is there a better way to do this ?
10:08:56 <sclv> you could use `oneOf`?
10:08:58 <dolio> I'm not sure `try` can even do this. It sounds like ambiguous sub-grammars.
10:09:26 <Kronic> Let me look into that
10:09:48 <h1ccup> i'm thinking like prolog where it would keep trying every choicepoint until something succeeds overall, why is that bad?
10:11:01 <dolio> Because you need to think like how parsec actually works, or use a different library.
10:11:18 <sclv> `try` is dual to `commit` http://hackage.haskell.org/package/polyparse-1.3/src/docs/index.html
10:11:35 <sclv> but if you're super ambiguous everywhere then your grammar is awful
10:11:41 <dolio> Maybe Earley can do ambiguous sub-grammars like this. Not sure.
10:11:52 <sclv> and having to try every choicepoint everywhere always leads to a huge space and time blowup
10:12:10 <sclv> i.e. its bad for the same reason a lot of code in prolog is slow
10:13:08 <h1ccup> definitely easy to write bad prolog, but not too hard to write good prolog :)   so polyparse is roughly these semantics?  i'll look into it!
10:13:30 <h1ccup> what are the pros/cons compared to parsed?
10:13:33 <h1ccup> *parsec
10:13:52 <monochrom> Yes, parsec kills backtracking by default, you have to opt-in for backtracking by adding "try" at suitable places where you want backtracking.
10:14:24 <h1ccup> just seemed like there would be a place to put try in this example to get what i want
10:14:25 <monochrom> (char '*" >> zzz) <|> yyy = prolog (char '*', cut, zzz) or yyy
10:14:27 <sclv> parsec/megaparsec's main advantage is that its really widely used, well maintained, efficient, and feature complete with a lot of helpers and helper packages
10:14:59 <sclv> polyparse is neat mainly as an example of another way to do things, but without any real world advantage as far as i'm concerned
10:15:05 <monochrom> To get rid of that cut, you go "try (char '*' >> zzz) <|> yyy"
10:15:47 <sclv> the problem is that function you have on its own can succeed in multiple ways and the first way it succeeds doesn't accord with parts of the grammar not in your function
10:15:57 <sclv> so you need to wrap literally _everything_ _all the way up_ in try
10:16:17 <sclv> i.e. try and commit are dual not locally but only on the basis of a whole program transform
10:16:20 <dolio> If polyparse uses commit, I'm not sure it will do this, either.
10:16:36 <sclv> dolio: i mean just never commit!
10:16:49 <dolio> No, I mean, commiting isn't the problem with this example.
10:17:08 <dolio> The problem is like greediness.
10:17:12 <sclv> *insert hack standup comedy joke about boyfriends here*
10:17:50 <sclv> i think the problem is there's multiple "right" results the parser could give (potentially one for every "allowed" length) and you only get one
10:17:54 <monochrom> what, boyfriends never commit and never try?
10:18:06 <dolio> Like, b* parses as many bs as possible, but this example wants it to keep track of the possibility of parsing all possible number of bs, because some of the choices might cause failures down the line.
10:18:29 <monochrom> But yeah, LL(k) grammars are much preferred.
10:18:29 <dolio> *Without* factoring the parser for that.
10:19:37 <sclv> yeah, actually, even if you wrap everything in try it'll always locally give the wrong result without a full refactor
10:20:13 <sclv> but if you have a full "list of successes" parser then it should handle that directly i think, idk?
10:20:15 <dolio> To make that work in parsec you need to do stuff like `(b* >> x) <|> (b* >> y) <|> ...`, and can't factor out the `b*`.
10:20:49 <dolio> I mean, that still won't work, but hopefully my idea is clear.
10:21:10 <monochrom> Text.ParserCombinators.ReadP is the one that anticipates ambiguity resolution and comes with GHC.
10:21:47 <monochrom> (and IIRC uses a method that mitigates expoential blow-up)
10:23:35 <dolio> sclv: Yeah, I guess so. I think parsec doesn't do that, though, even with try. It's assuming the grammar isn't ambiguous.
10:23:49 <dolio> try/commit is a level of optimization beyond that.
10:29:14 <dolio> In prolog/mercury terminology, I think parsec/polyparse is inherently semidet (and any stuff that appears nondet becomes semidet by picking the first solution), while commit is like cut (discard all possible backtracking).
10:30:10 <dolio> I don't know polyparse, though, so that's based on the idea that it's just the dual operation of parsec.
10:31:32 <ezzieyguywuf> lol, just tried to start `ghci` three times in a row and accidentally typed `ghcid`
10:31:40 <ezzieyguywuf> guess which one I use more often 🤣
10:33:36 <monochrom> Text.ParserCombinators.ReadP demo:
10:33:57 <monochrom> % import qualified Text.ParserCombinators.ReadP as ReadP
10:33:58 <yahb> monochrom: 
10:34:07 <esotericn> hello all. I'm very much a haskell noob; mainly trying to build a project I've been given within Nix. I think I'm having an issue with an incompatibility between two package versions and wondered if anyone else might have come across it before
10:34:16 <ski> the committed-choice causes distributivity `( p <|> q ) >> r  =  ( p >> r ) <|> ( q >> r )' (or `( p ; q ),r  <=>  ( p,r ; q,r )' in Prolog terms, where `;' is disjunction, and `,' is (ordered) conjunction) to fail
10:34:20 <monochrom> polymono = ReadP.readP_to_S (liftA2 (,) (many (ReadP.char 'a')) (ReadP.char 'a' <* ReadP.eof)
10:34:23 <monochrom> err
10:34:26 <monochrom> % polymono = ReadP.readP_to_S (liftA2 (,) (many (ReadP.char 'a')) (ReadP.char 'a' <* ReadP.eof)
10:34:27 <yahb> monochrom: ; <interactive>:5:94: error: parse error (possibly incorrect indentation or mismatched brackets)
10:34:27 <Kronic> Thanks for the tip about oneOf sclv !
10:34:37 <monochrom> % polymono = ReadP.readP_to_S (liftA2 (,) (many (ReadP.char 'a')) (ReadP.char 'a' <* ReadP.eof))
10:34:38 <yahb> monochrom: 
10:34:41 <esotericn> scotty-tls 0.4.1 with ghc-8.8.2 and warp-tls-3.3.0
10:34:55 <Kronic> count 7 $ oneOf ['F', 'B'] :: Parser String
10:34:55 <Kronic>  -- that's that I ended up with
10:35:16 <esotericn> getting Module ‘Network.Wai.Handler.WarpTLS’ does not export ‘keyFile’ which I assume is just some API incompatibility
10:35:18 <Kronic> I had to figure out satisfy first though, and I basically ended up rewriting oneOf 
10:35:22 <monochrom> That parser says a* a $
10:35:38 <monochrom> % polymono "aaaaa"
10:35:39 <yahb> monochrom: [(("aaaa",'a'),"")]
10:36:29 <monochrom> It successfully knows that 4 a's are right for the a* because internally it tries all possibilities and then kills the ones that don't work out for the final a$
10:37:00 <ski> also the following fails, because of things like greediness, lookahead, check for end-of-input : if `p' can parse `s', and `q' can parse `t', then `liftA2 (,) p q' can parse `s <> t'
10:38:06 <ezzieyguywuf> how would you go about turning a `123456.67 :: Double` into a `"123,456.67" :: Data.Text`?
10:38:55 <Kronic> I have to say, this the members of this IRC are exceptionally helpful. I'm half kicking myself for not joining sooner.
10:39:19 <esotericn> heh, just checked it out and looked at the logs, 3.3.0 is the breaking change. cool, will just downgrade that
10:39:32 <merijn> ezzieyguywuf: Sadly there's not really a convenient formatting function I like >.>
10:39:34 <ezzieyguywuf> Kronic: +1 (I will also kick you....)
10:39:48 <merijn> @quote psychic.mega
10:39:48 <ezzieyguywuf> merijn: drat. guess I could roll my own pretty easily...
10:39:48 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
10:40:21 <ezzieyguywuf> this may be the one Killer Feature that python has over haskell then, i.e. string formatting
10:40:22 <monochrom> No, I refuse to play psychic, even when I can.
10:40:37 <ezzieyguywuf> 🤡
10:40:41 <h1ccup> ski, are these general arguments that parsec is bad?  monochrom, where does ReadP fit in to the ecosystem?  i'd never looked into it assuming it was a pre-parsec relic, but looks like that's wrong?
10:41:07 <merijn> ezzieyguywuf: I mean, it should be easy enough, split into whole and fractional part (I know there is a function for that), then print that
10:41:17 <dolio> Parsec is good. Ambiguous parses are bad.
10:41:28 <ski> h1ccup : i guess you could call them dissatisfactions ..
10:41:33 <ezzieyguywuf> merijn: adding the commas will be the non-trivial piece I think
10:41:38 <merijn> ezzieyguywuf: Clearly your new mission in life is: Implement a nice formatting function and open an issue to get it added to Numeric in GHC :p
10:41:42 <sclv> most people use megaparsec for serious work or trifecta for really fancy error reporting etc
10:41:50 <monochrom> These are general arguments that parsec is good.  Most people design LL(k) grammars and are against the inefficiency of unconditional pervasive backtracking.
10:41:50 * ezzieyguywuf salutes to merijn 
10:42:02 <sclv> readP is good because its simple and therefore purpose-built for the ghc codebase
10:42:17 <merijn> ReadP is simple in implementation, maybe
10:42:21 <monochrom> ReadP comes with GHC.
10:42:23 <ezzieyguywuf> is Data.Text even in Prelude though....?
10:42:28 <merijn> I found it *incredibly* hard to write sensible parsers with it
10:42:42 <merijn> ezzieyguywuf: Naah, but once you can produce String it's a simple "T.pack" to fix that
10:42:44 <sclv> yeah, i agree its not very intuitive -- its really there for "internal" use imho
10:42:59 <monochrom> But I think I can explain why no one is aware of ReadP precisely because it comes with GHC.
10:43:07 <sclv> i.e. its built to generate `read` instances for and not much else
10:43:08 <ski> h1ccup : the `polyparse' docs page that got linked before briefly mentions `ReadP' at the end. (also, there's `parsek', by Koen Claessen)
10:43:09 <ezzieyguywuf> for what my $0.02 is worth, I found readP helpful for learning some general broad strokes of parsing/parsers in haskell, but then moved on to megaparsec after that.
10:43:17 <ezzieyguywuf> merijn: fair point.
10:43:32 <merijn> ezzieyguywuf: But hey, feel free to add a special optimised case to Text too! ;)
10:43:33 <ezzieyguywuf> merijn: but Data.Text may have some functions that will make it easier to implement...
10:43:44 <monochrom> It is along the same line as: GHC comes with a user guide and library docs installed, right on your hard disk, that's why you never knew they existed.
10:43:45 <Kronic> I started with megaparsec more or less yesterday or the day before, and the megaparsec tutorial is something I've found to be very useful
10:44:01 <merijn> monochrom: Pfft, why would you ever read a user guide?
10:44:19 <merijn> GHC User Guide is the single most undervalued piece of Haskell documentation/writing
10:44:19 <monochrom> In general, people spend lifetimes search on the web and not one single second taking a look at what they've got on their own disks.
10:44:21 <ezzieyguywuf> Kronic: I found the userguide both useful and overwhelming.
10:44:38 <monochrom> This is called anti-introvertism.
10:44:57 <Kronic> it is certainly overwhelming. Haskell resources have a tendency to load a cannon full to absolute brim with knowledge and blast it into your face without much warning 
10:45:11 <Kronic> I don't know how I would explain it better either though, so I'm not one to talk 
10:45:43 <sclv> well the users guide is built also as a reference tome for skilled people
10:45:46 <geekosaur> @remember Kronic Haskell resources have a tendency to load a cannon full to absolute brim with knowledge and blast it into your face without much warning
10:45:47 <lambdabot> Okay.
10:45:47 * ski has the GHC user guide URL memorized since years ..
10:45:52 <h1ccup> as far as i understood, megaparsec wouldn't differ from parsec on this backtracking issue right?
10:46:00 <xerox_> what's a nice way to go about this: (h,w) = let (_,(h1,w1)) = A.bounds area in (h1+1,w1+1)
10:46:03 <sclv> no the semantics are basically the same
10:46:09 <sclv> megaparsec is just really "parsec evolved"
10:46:17 <ezzieyguywuf> Kronic: I know how I would explain it better - (1) provide a short, quick, "here's how it works!" type of deal, (2) add a little more info for "you'll probably need this to really get going", (3) put the rest in a link at the bottom that says "User Guide"
10:46:31 <monochrom> As for purely technical merit, one could critique that ReadP doesn't come with as many helper functions as parsec or megaparsec.  But this is just chicken-and-egg networking effect, no?  megaparsec provides more helpers because more users talked to authors.
10:46:46 <Kronic> be sure to do that when you're finished learning ezzieyguywuf :) 
10:46:48 <merijn> monochrom: Well it's also much slower and harder to reason about :p
10:46:58 <ski> xerox_ : lower bounds are `(0,0)' ?
10:47:02 <xerox_> ski: yup
10:47:17 <ezzieyguywuf> Kronic: lol, merijn already gave me an assignment, and i'm also trying to become a gentoo developer, so dunno if I can add anything to the list :-P
10:48:10 <monochrom> merijn, I think Koen Clasen has a paper that explains how ReadP's cost is already pretty decent for when you need to support ambiguity and things like a*a$
10:48:23 <sclv> ((+1) *** (+1)) . snd $ A.bounds area
10:48:28 <sclv> or similar
10:48:36 <merijn> monochrom: Right, but then I'd argue that supporting ambiguous grammars is a misfeature :p
10:48:38 <monochrom> or rather, what clever tricks they played to keep the cost decent.
10:48:39 <sclv> *** is from control.arrow and its really for tuple golf only
10:48:58 <sclv> the initial definition is just dandy imho for plain readability
10:49:06 * ezzieyguywuf cowers in fear of the word "arrow"...("what is it!?!?!?!?!")
10:49:09 <monochrom> Yes, I still very much agree we should design LL(k) grammars in the first place.
10:49:22 <ski> xerox_ : i guess i'd look for a way to do it for arbitrary bounds .. which seems hard, here
10:49:25 <monochrom> But regex fans will always want a*a$ one in a while.
10:49:27 <merijn> ezzieyguywuf: Good news for you!
10:49:29 <xerox_> ski: yeah
10:50:00 <merijn> ezzieyguywuf: Arrow is an abstraction that never took off and can be relegated to "historical curiosity" since no one is really using it anyway!
10:50:05 <ski> xerox_ : how're you using `h' and `w' ?
10:50:06 <ezzieyguywuf> NICE!!!!
10:50:13 <merijn> And the only functions people do use, they only use the function versions of it
10:50:13 * ezzieyguywuf tips hat to merijn 
10:50:36 <ski> i guess `Kleisli' is occasionally used ?
10:50:55 <merijn> Maybe, but even that's rare
10:51:01 <ski> yes
10:51:03 <merijn> Might as well just use >=>
10:51:08 <xerox_> ski: why? just using them in some calculations later, where they appear as they are; I thought I'd try Array not to shuffle around (Set,Int,Int) say, I think I'll make an helper that gives me the height and width and that's it
10:51:13 <monochrom> Kleisli is as occasionally used as Arrow is occasionally used.
10:51:14 <ezzieyguywuf> I've sen `Kleisli` from time-to-time in documentation.
10:51:30 <ski> @type runKleisli . first . Kleisli
10:51:32 <lambdabot> Monad m => (b -> m c) -> (b, d) -> m (c, d)
10:51:35 <Kronic> So, here's a question - if I am confident in the result of a parse application in megaparsec, is there a way I can get the data back unwrapped or must I always deal with Either/Maybe ?
10:51:36 <monochrom> Because what merijn said, you can use >=> already and it just needs Monad.
10:51:42 <sclv> people talk about kleisli composition even without the wrapper
10:51:43 <sclv> right
10:52:10 <merijn> Kronic: You always gotta deal with Either/Maybe
10:52:10 <monochrom> Therefore, you use the Kleisli wrapper only because someone made you use Arrow.
10:52:21 <Kronic> That's alright, I figured as much
10:52:25 <Kronic> Thanks anyway :) 
10:52:27 <merijn> Kronic: But, otoh, "dealing with" can simply be "error and exit" like I do in my AOC code :p
10:52:41 <Kronic> That's exactly what I'm going to do :)
10:53:09 <ski> xerox_ : i was wondering if they were basically needed for iteration, or to fit some interface that requires them
10:53:22 <ski> (or perhaps some other purpose)
10:53:40 <merijn> Kronic: https://github.com/merijn/AdventOfCode2020/blob/master/Day2.hs#L23-L28 (spoilers for day 2, obviously)
10:53:48 <xerox_> iteration it is, computing a path and want to stop at height/width
10:54:09 <Kronic> Ah, I know how to do it -- I was just wondering if there was a nice shorthand like unsafeParse or something
10:54:30 <merijn> Kronic: There's fromJust, but that's for criminals :p
10:54:53 <ski> @type inRange
10:54:54 <lambdabot> Ix a => (a, a) -> a -> Bool
10:54:58 <ski> @type range
10:55:00 <lambdabot> Ix a => (a, a) -> [a]
10:55:37 <Kronic> a criminal I shall be 
10:56:05 <ezzieyguywuf> lol, I burned out on AOC, too many other bricks in the fire (or w/e the saying is...)
10:56:05 <monochrom> You do have just cause to use fromJust in your context.
10:56:11 <ski> `\(Just x) -> x' gives better error messages, if the impossible happens
10:56:18 <monochrom> And you would be right to use fromRight.
10:56:53 <monochrom> I do think people generally overblow "OMG I have to deal with this other case???!!!"
10:58:05 <monochrom> I gave my students a homework question "merge two sorted lists into one".  I had a student asking "may I assume that the two input lists have the same length?"
10:58:10 <monochrom> WHY WOULD YOU NEED IT
10:58:31 <monochrom> Is it so much more work to have 2 base cases?
10:58:37 <tomjaguarpaw> If you say "yes" you may find out :)
10:59:17 <Kronic> in which language monochrom ?
10:59:21 <monochrom> Haskell
10:59:29 <Kronic> Oh okay. No idea lmao
10:59:37 <monochrom> Even in asm it is not that bad.
10:59:39 <dolio> Yes, they're both infinitely long.
11:05:18 <kuribas> is there a shorter way for (liftA2 (<*>) (pure e1) e2)?
11:05:31 <merijn> kuribas: Compose? :)
11:05:34 <kuribas> or (liftA2 (<*>) e1 (pure e2)?
11:05:40 <monochrom> I would be OK with a 1st-year absolute beginner asking that.  But this is a 3rd-year course.
11:05:46 <kuribas> merijn: ?
11:06:14 <monochrom> You are getting a glimpse of what kind of programmers you will get in the future writing code that means life and death to you.
11:06:17 <merijn> kuribas: Well, not shorter but you can probably jimmy the context to get it helpful: "getCompose $ pure e1 <*> Compose e2"
11:06:22 <kuribas> :t \e1 e2 -> liftA2 (<*>) (pure e1) e2
11:06:24 <lambdabot> (Applicative f1, Applicative f2) => f2 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:06:25 <merijn> :t Data.Functor.Compose.Compose
11:06:27 <lambdabot> forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Data.Functor.Compose.Compose f g a
11:06:41 <kuribas> :t \e1 e2 -> getCompose $ pure e1 <*> Compose e2
11:06:43 <lambdabot> error:
11:06:43 <lambdabot>     Variable not in scope: getCompose :: f0 b -> t1
11:06:43 <lambdabot> error:
11:06:52 <monochrom> If there is one small corner case, taking just one line of trivial code to deal with, such that omitting it means death to you, including it means saving your life.
11:07:00 <kuribas> merijn: that's not shorter :)
11:07:03 <monochrom> You can bet that this programmer would rather you die.
11:07:21 <merijn> kuribas: Like I said, it depends on context. If you need to do it a lot you can pre-wrap with Compose to clean things up
11:07:38 <kuribas> merijn: I was wondering if it would reduce to fmap....
11:07:50 <kuribas> I guess not...
11:08:35 <merijn> oh, wait
11:08:48 <merijn> kuribas: Isn't that just "fmap (fmap e)"
11:09:04 <merijn> or "fmap e1 <$> e2"
11:09:12 <merijn> That's shorter at least! :>
11:10:27 <kuribas> hmm, it might...
11:11:07 <jaykru> starting to play with parsec. i'm trying to parse strings like "0101010101". the parser I have now is `many1 $ oneOf "01"`, but this skips leading zeros for some reason I don't understand. Any tips?
11:11:47 <kuribas> merijn: right, that works :)  And the second?
11:14:12 <kuribas> :t \e1 e2 -> fmap e1 <$> e2
11:14:14 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:14:40 <kuribas> :t \e1 e2 -> liftA2 (<*>) (pure e1) e2
11:14:42 <lambdabot> (Applicative f1, Applicative f2) => f2 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:15:09 <kuribas> no, types are different
11:15:19 <ski> @type \e0 e1 -> (e0 <*>) <$> e1
11:15:21 <lambdabot> (Applicative f1, Functor f2) => f1 (a -> b) -> f2 (f1 a) -> f2 (f1 b)
11:15:27 <ski> @type \e0 e1 -> e0 <&> (<*> e1)
11:15:29 <lambdabot> (Applicative f1, Functor f2) => f2 (f1 (a -> b)) -> f1 a -> f2 (f1 b)
11:15:42 <ski> @type \e0 e1 -> liftA2 (<*>) (pure e0) e1
11:15:44 <lambdabot> (Applicative f1, Applicative f2) => f2 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:15:50 <ski> @type \e0 e1 -> liftA2 (<*>) e0 (pure e1)
11:15:52 <lambdabot> (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f2 a -> f1 (f2 b)
11:16:31 <kuribas> that's shorter but not much cleaner... 
11:16:35 <kuribas> I guess the core is the same?
11:16:45 <ski>   liftA2 f (pure x) i = fmap (f x) i
11:16:59 <ski>   liftA2 f i (pure x) = fmap (flip f x) i
11:17:53 <ski> kuribas : not sure what you're asking about
11:18:08 <kuribas> if the compiled code is the same?
11:18:24 <kuribas> only after inlining I suppose...
11:19:41 <ski> jaykru : i think you don't want `oneOf'
11:23:22 <Kronic> monochrom I know people who graduated with a masters who couldn't solve fizzbuzz in any language if you gave them an hour
11:23:40 <Kronic> It's great that you are teaching people Haskell though, it gives me hope :)
11:24:06 <tomsmeding> monochrom: in that example assuming equal length doesn't even let you leave out a base case
11:24:17 <tomsmeding> probably stemmed from a misunderstanding about what the assignment was
11:24:50 <ezzieyguywuf> hrm, how can i `[Either a b] -> Either a [b]`, or is this non-sensical?
11:25:30 <sclv> nonsensical
11:25:39 <joel135> [Left a1, Left a2] -> ??
11:25:39 <jaykru> ski: I tried replaceing `oneOf "01"` with `satisfy (\x -> x == '0' || x == '1')` and get the same behavior where it skips the first 0
11:25:43 <ski> @type sequence :: [Either a b] -> Either a [b]
11:25:44 <sclv> or wait, actually, you can write it
11:25:45 <lambdabot> [Either a b] -> Either a [b]
11:25:51 <sclv> lol there it is
11:26:00 <ezzieyguywuf> ski: 😮
11:26:06 <geekosaur> you can write it,, I figured it was sequence, but your question is still valid
11:26:18 <sclv> its a good exercise to think through logically what it _must_ do
11:26:34 <ski> @type partitionEithers
11:26:35 <lambdabot> [Either a b] -> ([a], [b])
11:26:36 <ezzieyguywuf> sclv: working through that now...
11:26:44 <ezzieyguywuf> ski: I've used partitionEithers!
11:26:50 <sclv> there's actually a lot of things it can do, you should think about which ones would make the most sense
11:27:15 <sclv> i.e. what sequence does may _not_ be what you want
11:27:41 <merijn> ezzieyguywuf: Even better yet, there is also Validation which aggregates errors, rather than returning the first
11:27:52 <merijn> But Validation is Applicative only
11:28:11 <jle`> yeah, we can have Monoid a => [Either a b] -> Either a [b]
11:28:16 <sclv> all you know is if there's no `a` it can only give you back the `b`s -- but even then it may not give you all of them
11:28:35 <ezzieyguywuf> merijn: first I've heard of Validation, that's nice!
11:28:43 <ezzieyguywuf> for right now I just want to bail out on the first error.
11:28:59 <sclv> yeah, then sequence works -- its just treating Either like an error monad
11:29:04 <ezzieyguywuf> indeed.
11:29:13 <geekosaur> or sequenceA for that matter
11:29:15 <sclv> also a good exercise to write it by hand
11:29:18 <ski> jaykru : it sounds like you don't want to accept either `0' or `1' there, but rather a sequence starting with `0', followed by `1'
11:29:30 <jle`> sequence should also guarantee that the list in the Right is of the same length as the input list
11:29:36 <merijn> @hackage either -- ezzieyguywuf It's in this package
11:29:36 <lambdabot> https://hackage.haskell.org/package/either -- ezzieyguywuf It's in this package
11:29:39 <jle`> which constraints the behavior significantly
11:29:52 <jle`> otherwise you could just use `const (Right [])`
11:29:53 <ski> too bad `Validation' isn't in lambdabot ..
11:30:03 <jle`> it's in 'transformers'
11:30:13 <jle`> under a different name
11:30:27 <jle`> > import Control.Applicative.Lift
11:30:30 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘import’
11:30:36 <ski> @let import Control.Applicative.Lift
11:30:38 <lambdabot>  Defined.
11:31:44 <jle`> > runErrors . traverse eitherToErrors $ [Left "hi", Right 10, Left "ok", Right 12]
11:31:47 <lambdabot>  Left "hiok"
11:31:57 <jle`> > runErrors . traverse eitherToErrors $ [Right 10, Right 12]
11:32:00 <lambdabot>  Right [10,12]
11:34:14 <ski> that's using `Semigroup' ?
11:34:31 <ezzieyguywuf> I always get confused between transformers and mtl...
11:34:45 <jaykru> ski: what I'm looking for is basically (0|1)+ if you're familiar with regexp; i don't see why the parser I came up with doesn't work :P
11:35:06 <jaykru> i don't see why i should need to special-case a leading zero
11:35:13 <monochrom> What is the type of oneOf again?
11:35:38 <monochrom> Ah OK found it.
11:36:05 <jaykru> oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
11:36:30 <jle`> 🎿 i think it requires Monoid
11:36:59 <xerox_> what is that lil drawing
11:37:02 <jle`> based on the Applicative instance for Const
11:37:05 <jle`> xerox_: it's a ski
11:37:09 <jaykru> i tried unfolding oneOf into satisfy and a predicate describing the characters I want to match, but that didn't really help matters. It seems like many1 is the source of the problem
11:37:23 <ski> > (left NE.toList . runErrors . traverse (eitherToErrors . left NE.fromList)) [Left "hi",Right 10,Left "ok",Right 12]
11:37:26 <lambdabot>  error:
11:37:26 <lambdabot>      • Could not deduce (Monoid (NE.NonEmpty Char))
11:37:26 <lambdabot>          arising from a use of ‘traverse’
11:37:30 <xerox_> jle`: xD
11:37:32 <jle`> :'(
11:37:40 <ezzieyguywuf> why does hlint think there's a parse error on line 4? https://dpaste.com/HDLQJVVQD
11:37:42 <jle`> xerox_: yeah my client has an emoji autosubstitution
11:38:27 <ski> jaykru : if you're wanting to express `(0|1)+', then i don't see why you have a problem with it accepting leading zeros
11:38:38 <jle`> 🎿 the instance should be Apply f => Applicative (Lift f)
11:38:44 <tomsmeding> good client
11:38:47 <jaykru> I /want/ it to accept leading zeroes
11:38:51 <jle`> but Apply is not available
11:38:53 <jaykru> currently it doesn't parse the leading 0
11:39:03 <ski> jle` : too bad :(
11:39:27 <jaykru> `parse ... "010101"` gives me "10101"
11:39:41 * merijn presses X to doubt
11:39:54 <merijn> Full code, input and results in a pastebin or I don't believe it :)
11:40:07 <jaykru> ok gimme a sec :)
11:40:20 <merijn> I'm 95% sure you're messing *something* else up if that's what happens
11:40:33 <merijn> Like, converting to a number and printing that
11:40:34 <sm> jaykru: your parser is good, and will work if you test it by itself. Maybe a previous parser is consuming the 0s ?
11:40:46 <merijn> Or, indeed, preceding parsers
11:41:09 <sm> (and if you see me repeat this in a minute, apologies, the matrix bridge is having trouble :()
11:42:09 <jle`> if at first you don't succeed, `try` and `try` again
11:42:14 <ski> jle` : i see. makes sense, making a free `Applicative' from an `Apply'
11:42:38 <jle`> yeah, that's the spirit of it, at least. the same way you have Semigroup m => Monoid (Maybe m)
11:42:45 * ski nods
11:42:56 <jle`> i feel like this is something that should be in functor-combinators
11:43:09 <jle`> i have `MaybeF` which is an identical type but the behavior is different
11:43:26 <jaykru> Yeah, so it seems the bitstring parser does work in isolation, not seeing why this eats the 0 though https://pastebin.com/raw/ztQHwiwP
11:44:00 <geekosaur> read ieats it
11:44:18 <geekosaur> there's nowhere for leading zeros to be stored in the numeric representation of the string
11:44:22 <ski> i was thinking `sequence' on `Validation'/`Errors' ought to be able to give a `Data.List.NonEmpty' in the exceptional case, since there's always at least one
11:44:22 <jaykru> oh wow
11:44:34 <merijn> Called it
11:44:36 <jaykru> thank!
11:44:47 <jaykru> yes, yes, congrats
11:44:48 <merijn> Bow to my psychic powers :p
11:45:03 <jle`> ski : it does for Validation itself
11:45:08 <jle`> from the validation library
11:45:34 * joel135 bows and arrows
11:45:42 * ski again thinks `void' ought to be banished from `Data.Functor',`Control.Monad'
11:45:48 <ski> jle` : hm, i see
11:46:48 <jle`> hm, i wonder why `MaybeF` even exists in functor-combinators
11:46:57 <jle`> it looks like the goal is to get a free Alternative instance
11:47:14 * jaykru asks ski what's a better alternative to using void for throwing away intermediate monadic computations
11:47:16 <jle`> maybe i could kill it and make a proper Lift instead
11:47:29 * jaykru is only visiting Haskell-land from Coq-world
11:48:33 <jle`> 🎿 ah hah, i found it
11:48:34 <jle`> https://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Functor-Apply.html#t:MaybeApply
11:48:41 <jle`> also MaybeF was the wrong type
11:48:55 <tomsmeding> jle`: _ <-
11:49:10 <tomsmeding> sorry, wrong mention! jaykru: _ <-
11:49:22 <tomsmeding> there was a blog post about that a while ago
11:49:22 <jaykru> yeah, but why is this better than void?
11:49:26 <kuribas> :t (() *>)
11:49:28 <lambdabot> error:
11:49:28 <lambdabot>     • Couldn't match expected type ‘f a0’ with actual type ‘()’
11:49:28 <lambdabot>     • In the first argument of ‘(*>)’, namely ‘()’
11:49:34 <kuribas> :t (() <*)
11:49:35 <jaykru> perhaps more clear to people already familiar with do notation
11:49:35 * ski . o O ( <shapr> I'm addicted to arrows.  * shapr begins his own paper "Generalizing Arrows to Spears"  <shapr> Spears can do anything efficiently, but they have sixty thousand laws they must satisfy, and we haven't actually found one yet.  <raphael> maybe "Generalizing Arrows to Nuclear Weapons" would simply be: unsafeInterleaveIO  )
11:49:36 <lambdabot> error:
11:49:36 <lambdabot>     • Couldn't match expected type ‘f a’ with actual type ‘()’
11:49:36 <lambdabot>     • In the first argument of ‘(<*)’, namely ‘()’
11:49:44 <jle`> () <$
11:50:13 <kuribas> :t (() <$)
11:50:13 <ski> jaykru : rename it to `ignore' or something like that, or the other two suggestions
11:50:15 <lambdabot> Functor f => f b -> f ()
11:50:50 <joel135> Isn't void just redundant in a 'do' block?
11:50:57 <monochrom> Yes.
11:51:04 <justsomeguy> Is there a widely agreed on way to handle non-unique record field accessor functions?
11:51:05 <monochrom> But some people are religious about -Wall
11:51:09 <ski> imho `void :: Functor f => f a -> f ()' has no business being in base modules, outside of FFI
11:51:11 <monochrom> YES IT'S A RELIGION
11:51:23 <joel135> ok
11:51:35 <merijn> monochrom: I'm religious about -Wall, but also religious about -Wno-unused-do-binds :p
11:51:45 <tomsmeding> jaykru: https://tech.freckle.com/2020/09/23/void-is-a-smell/
11:51:49 <monochrom> I agree with your religion :)
11:52:13 <ski> jaykru : the name `void' here comes from `void' in C, not a Haskell concept. `void' would, however, be a natural alias for `absurd :: Void -> a'
11:52:17 <kuribas> count me a member too
11:52:31 <jle`> now if only there was an easy to use api for MaybeApply
11:52:35 <adamCS> Huh.  Trying OverloadedLabels for the first time (via Optics) and it's...weird that even when you import a module qualified, the labels are not qualified since they come from class instances.  It makes sense and still seems wrong somehow.  I guess I'll get over it?
11:53:35 <jle`> > (traverse (MaybeApply . left (Const . NE.fromList))) [Left "hi",Right 10,Left "ok",Right 12]
11:53:37 <lambdabot>  error:
11:53:37 <lambdabot>      Data constructor not in scope:
11:53:37 <lambdabot>        MaybeApply :: Either (Const (NE.NonEmpty Char) b0) b1 -> f b
11:53:46 <jle`> @let import Data.Functor.Apply
11:53:48 <lambdabot>  Defined.
11:53:49 <jle`> > (traverse (MaybeApply . left (Const . NE.fromList))) [Left "hi",Right 10,Left "ok",Right 12]
11:53:51 <lambdabot>  error:
11:53:51 <lambdabot>      • No instance for (Show
11:53:51 <lambdabot>                           (MaybeApply (Const (NE.NonEmpty Char)) [Integer]))
11:53:52 <monochrom> qualify the module that gave you the class.
11:54:26 <jle`> > left getConst . runMaybeApply $ (traverse (MaybeApply . left (Const . NE.fromList))) [Left "hi",Right 10,Left "ok",Right 12]
11:54:29 <lambdabot>  Left ('h' :| "iok")
11:54:32 <jle`> ^ ski 
11:54:33 <ski> jaykru : you can note that  val ignore : 'a -> unit  is a standard function in both SML and OCaml
11:55:04 <tomsmeding> jaykru: though that blog post doesn't actually say anything against the use of 'void' specifically; '_ <-' would have the exact same argument
11:55:10 <tomsmeding> I misremembered what the post was about apparently
11:55:15 <dminuoso> adamCS: Right, it's just because of how OverloadedLabels works.
11:55:26 <monochrom> If multiple modules re-export that class and you're importing them all, then qualify them all.
11:55:30 <jaykru> I guess the moral is just do none of this stuff when using do-notation
11:57:46 <ski> jle` : ah, cool :)
11:58:06 <adamCS> dminuoso: Yeah.  It's just disconcerting since they act like field selectors.  monochrom, how?  The class is from the magic of OverloadedLabels, right?  What would I qualify?  
11:58:23 <monochrom> tomsmeding: I think the blog's message is "We’re trained to follow GHC’s guidance somewhat blindly"
11:58:37 <tomsmeding> I think so too
11:58:40 <idnar> -Wunused-do-bind seems pretty useful
11:59:30 <tomsmeding> it is, except in parsers sometimes
11:59:37 * ski idly glances at people somewhat blindly following `hlint's suggestions
12:00:24 <merijn> idnar: How so?
12:00:33 <idnar> but it's not the only use for void, I've sometimes written `if x then void a else void b` or so
12:00:35 <monochrom> adamCS: Ah OK then I am toasted.
12:00:52 <adamCS> dimuouso: I guess I need to embrace more deeply the idea that "#foo" means "get me the labeled-as-foo part of anything with a foo-part that has been correctly instanced." and then the qualification sensibly sits on the thing the label acts on.  
12:01:01 <adamCS> dminuoso: ^
12:01:51 <merijn> idnar: I mean, the number of times "I should've bound something to a variable and used it, but forgot" is vanishingly small
12:01:57 <monochrom> #foo is syntax sugar for fromLabel @"foo"  (I'm just reading it off the GHC user guide)
12:02:16 <monochrom> I think syntax sugar can be helped as much as do-notation can be helped.
12:03:34 <adamCS> monochrom: Yeah.  Just surprising at first.  I'll have to see how it settles in the brain.
12:03:51 <ski> idnar : discounting `void (if x then a else b)' ?
12:03:55 <idnar> merijn: usually the mistake for me is "I forgot to use the result"
12:04:24 * ski . o O ( "It's dead, Jim." )
12:04:37 <idnar> ski: imagine a :: IO a, b :: IO b
12:04:47 <ski> idnar : yes ?
12:05:04 <ski> oh. i see what you mean
12:05:52 <monochrom> This is why I said in haskell-cafe that this issue is personal.
12:06:12 <ski> i suppose if you `mapM'/... with a pattern that introduces a skolem, that would be another use case
12:06:58 <monochrom> There is no absolute objective technical merit for many warnings in -Wall.  There is only personalized technical merit for it, conditioned upon what kind of mistakes you, not me, are likely to make.
12:07:04 <idnar> merijn: possibly I'm doing something else wrong to run into this
12:07:48 <monochrom> I'm OK with the outcome that since GHC has to choose one default, it can choose the way that doesn't benefit me but benefits other people.
12:08:00 <monochrom> But please don't speak like it's objectively absolute.  It's anything but.
12:08:23 <idnar> monochrom: I started turning things on one by one rather than -Wall, heh
12:08:47 <merijn> idnar: Well, usually I don't write thing in do blocks until I need their results, so "forgetting" isn't an issue :p
12:09:46 * ski . o O ( goal-directed action list generation )
12:13:57 <dminuoso> adamCS: So Im writing a library that makes similar use of OverloadedLabels, so perhaps I have a different mind model.
12:14:18 <dminuoso> adamCS: The key thing to realize is that these symbols are literals, not variables.
12:14:44 <dminuoso> You don't qualify `1` either, do you?
12:16:37 <dminuoso> The idea of # is that it's a type-driven lookup for a value. It's sort of like a `lookup` on a globally available map.
12:17:28 * justsomeguy finds -Wall really overwhelming, personally.
12:17:56 <justsomeguy> But I am definitely pretty new to Haskell overall, and prone to information overload.
12:21:33 <sm> justsomeguy: it's tough when you first turn it on with some existing code. The best way is to keep it on and fix each little thing as it appears
12:22:29 <sm> or, just enable some of the individual -W's to start
12:24:34 <justsomeguy> The problem I run into is that I save my file when I'm incrementally writing a function, before I have working code (when I'm still writing all patterns for an equasion, or when rearranging them), and then ghcid throws a ton of errors in my face. This is sometimes useful, but often too distracting. It probably a workflow issue, really. I should figure out a better cadence for saving, or make the terminal drop-down or something.
12:25:10 <justsomeguy> But yeah, I've been enabling -W's one at a time, and that's much less distracting.
12:25:11 <monochrom> Your workflow is fine. It's what a lot of us do.
12:25:55 <sm> justsomeguy: when learning, or just when confused, I get the code compiling, then make Really Small Changes while watching ghcid / hls
12:26:14 <sm> at times this is literally "change one character"
12:26:44 <sm> also, just pick the top error, no need to look at them all
12:27:03 <monochrom> The correct solution is to have an easy way to enable and disable -Wall one-shot.
12:28:03 <monochrom> This is what an IDE should boast.  Not fancy completion.  Not fancy hovering tips.  But two buttons, one says "check without -Wall" and the other says "check with -Wall".
12:28:14 <monochrom> Because only you know when to use which.
12:28:50 <justsomeguy> Right. It just feels like information overload a lot of the time. Between the repl, hlint, and intellisense autosuggesting completions for every word I write. On the other hand, once I have some working code that I'm modifying, rather that incrementally creating, those things become really useful.
12:29:11 <justsomeguy> Ah I must go, my bus is here.
12:29:59 <sm> moral: command your tools
12:32:55 <idnar> with lsp in my editor the warnings and errors show up as annotations (squigglies + hover + etc) to my code and I find it easy to ignore things that are "under construction"
12:47:14 <adamCS> dminuoso: Yes.  I just wasn't thinking about them clearly, just trying to get something new to work, then, after a few tries, realized why the syntax was not what I had expected.  Mental model adjustment occurring as I type...
13:27:18 * tomsmeding sees someone on the haskell-cafe mailing list ask for compilers to assembly written in haskell, that are more fancy than the basic one they've written themselves; also me: has written an absolute mess of a compiler a while ago and wonders whether to post it; also me: realises their compiler is like 5x as fancy as mine
13:27:48 * tomsmeding still wonders whether to post it just to inspire some horror in people
13:33:01 <Rembane> Do it! :D
13:33:05 <Rembane> Horror <3
13:37:13 <tomsmeding> I actually think I'm not going to, I have a reputation at stake :p
13:37:47 <tomsmeding> I can post it here though, that at least sort-of justifies my effort just now to make it buildable with cabal instead of a makefile: https://git.tomsmeding.com/langhs/tree/
13:37:48 <Rembane> tomsmeding: You need a secret identity, like for instance "absolutelynottomsmeding"
13:38:08 <tomsmeding> imreallynot@tomsmeding.com
13:38:45 <tomsmeding> it can compile this: https://git.tomsmeding.com/langhs/tree/l/bf.lang  to x64 assembly
13:39:23 <tomsmeding> though the two lifetime analysis modules I've written apparently disagree on that program, so I'm not sure whether it's actually correct or only accidentally
13:39:55 <tomsmeding> (in case you think "I see three lifetime analysis modules": correct, the "2" one is incomplete)
13:42:39 <Rembane> ^^
13:45:55 <fendor> ah, liveness analysis! The first time I learned that lattices are awesome
13:46:37 <tomsmeding> I postponed learning that until taking an actual compilers course :p
13:49:16 <fendor> Maybe I gotta do that to finally understand them
13:49:21 <fendor> or understand them better
13:51:51 <monochrom> Of the whole compiler course there are basically about only 3 lectures that use lattices: liveness analysis, reachability analysis, and value numbering.
13:52:16 <monochrom> So if you already know them, or even just the first two, you are already finished.
13:53:52 <justsomeguy> What is a lattice? A mathematical structure?
13:53:58 <monochrom> yes
14:06:06 <fendor> guess I am finished with lattices then :(
14:07:16 <monochrom> No, you have finished what a compiler course has to say about lattices.
14:07:23 <monochrom> IOW very little. :)
14:07:49 <Rembane> Compiler course about lattices: They have a top, a bottom and boring stuff in the middle
14:07:52 <tomsmeding> Another compiler-relevant thing with lattices is usage analysis: is this value used never, once, or more times?
14:09:26 <dolio> Are compiler courses taught by classical logicians?
14:10:31 <nshepperd> i would have thought lattices would show up in type checking too
14:12:09 <nshepperd> isn't unification a lattice joining sort of operation?
14:13:24 <monochrom> I think what happens is a compiler course content sticks to classical logic, regardless of who teaches it.
14:13:50 <monochrom> It makes do by, for example, defining "live" to really just mean "not obviously dead".
14:20:15 <monochrom> Type checking does not use unification. Type inference does.
14:21:13 <monochrom> Few compiler courses cover type inference. Those that do, they can still choose to not prove that unification gives you the mgf, in fact not even to state it.
14:21:41 <monochrom> If you don't talk about mgf then there is no lattice theory to bring up.
14:21:47 <monochrom> err, s/mgf/mgu/
14:24:06 <monochrom> For example, Appel's textbook just writes down the 10-line unification algorithm, and says no more.
14:46:21 <sclv> lattice theory is incredibly beautiful and CS uses like four basic definitions and THATS IT
14:46:59 <sclv> there's a lot of connections to various logics and completeness properties etc iirc
14:48:01 <sclv> the whole of varieties, etc
16:23:40 * justsomeguy sometimes wonders why so few languages have full type inference.
16:24:52 <koz_> maerwald: I'm getting something weird with ghcup. If I try to get cabal 3.4.0.0-rc4 via 'ghcup install cabal', cURL vomits saying that it's unable to get a local issuer certificate.
16:25:20 <koz_> I can download fine from the URL it's hitting in my web browser, and I'm fairly confident it's not an issue with cURL or my certificate chain - other sites work fine.
16:25:40 <koz_> justsomeguy: 'Full' type inference can mean a few different things.
16:25:49 <koz_> There's definitely limits to what's possible to automagically infer.
16:37:42 <monochrom> It's because very few languages stay close to rank-1 parameteric polymorphism, where type inference is both do-able and beneficial.
16:38:58 <koz_> monochrom: Rank-1 parametric polymorphism = Hindley-Damas-Milner?
16:39:02 <monochrom> Apart from the ML heritage (SML, Caml, OCaml, maybe F#) and the Haskell heritage (Gopher, Miranda, Haskell), no one seems interested in rank-1 parametric polymorphism.
16:39:05 <monochrom> Yeah.
16:39:29 <koz_> monochrom: And (GHC at least) Haskell has shot well past HDM at this point.
16:39:50 <dolio> Haskell doesn't have full type inference.
16:39:59 <monochrom> Algol, Pascal, C: Not even polymorphic, and their idea of types is mostly to clarify "how many bytes so the code generator knows"
16:40:54 <monochrom> Simula, Smalltalk, shells, Perl, Python, PHP: What are "types"?
16:41:27 <monochrom> C++, Java, C#: Subtyping kills type inference.  Hell, even OCaml has to tell you sometimes it can't infer.
16:42:00 <monochrom> Coq, Agda, Idris: Dependent typing kills type inference.
16:44:08 <monochrom> Yes, GHC has done pretty reasonable heuristic annotation-aided inference in the face of rank-n, and soon we'll also get impredicativity, too.
16:44:39 <monochrom> All this does is to set GHC-Haskell as the only language interested in impredicative rank-n parameteric polymorphism.
16:49:04 <koz_> monochrom: Yeah, I am dreaming of the day I won't have to deal with runST-oriented GHC vom.
16:49:18 <koz_> (which makes me do a double take before I go "oh, it's that damn impredicativity thing")
16:52:39 <monochrom> Actually, the case of Coq, Agda, Idris may be the opposite of what I said.
16:53:05 <monochrom> Coq, Agda, Idris: Why infer types?  You write the type, emacs infers the term.
16:54:30 <monochrom> Right? They are theorem provers. Meaning, you write your conjecture, the computer tries to find a proof.  They are not proof theoremers (you write the proof, the computer tries to find what theorem it proves.)
16:55:52 <monochrom> (Please just laugh, I am joking.)
16:56:38 <dolio> Agda can infer a lot of types, though.
17:06:30 <ezzieyguywuf> do you all know of any tools outside of stack that can produce a visual like this? https://docs.haskellstack.org/en/stable/dependency_visualization/
17:09:13 <ezzieyguywuf> ah, I guess ghc-pkg dot | tred | dot -Tpdf >pkgs.pdf will do the trick
17:10:32 <ezzieyguywuf> hrm, that doesn't look like my project though...
17:16:52 <dsal> I don't know how useful those things are for non-trivial apps.
17:19:03 <ezzieyguywuf> *shrug*
17:22:18 <cnmne[m]> ezzieyguywuf: this reminds me of `guix graph`: https://guix.gnu.org/manual/en/html_node/Invoking-guix-graph.html)
17:31:12 <ezzieyguywuf> cnmne[m]: I'll check it out thank you.
18:51:07 <quarters> hello. I'm not sure if this is more an emacs question or haskell, but I'm getting a number of flymake errors for missing modules after having installed haskell with ghcup
19:03:10 <iqubic> I'd say that's an Emacs question.
19:04:38 <quarters> iqubic: thanks!
19:07:36 <fresheyeball> I am looking to use the compose operator in TH
19:07:40 <fresheyeball> How can I do this?
19:07:45 <fresheyeball> ''Prelude.. does not work
19:07:52 <fresheyeball> ''Prelude.(.) does not work
19:08:20 <fresheyeball> ''. does not work
19:10:41 <jle`> i'd presume (Prelude..)
19:10:50 <jle`> the same way you'd use it in prefix form
19:11:01 <jle`> > foldr (Prelude..) id [(+3),negate] 10
19:11:03 <lambdabot>  -7
19:14:22 <fresheyeball> jle`: I am not getting it to work in TH though
19:14:25 <fresheyeball> I need the ticks
19:16:00 <jle`> yeah, i mean you can use (Prelude..) as the identifier :)
19:16:05 <jle`> so you would tick the identifier
19:16:09 <jle`> % '(Prelude..)
19:16:10 <yahb> jle`: GHC.Base..
19:16:21 <jle`> just like how you'd tick any other identifier
19:16:23 <jle`> % 'Nothing
19:16:24 <yahb> jle`: GHC.Maybe.Nothing
19:18:11 <fresheyeball> jle`: oic
19:18:13 <fresheyeball> yeah that worked
19:18:16 <jle`> :D
19:18:18 <fresheyeball> VarE '(Prelude..)
19:18:21 <fresheyeball> tricky!
19:30:22 <justsomeguy> *ticky
19:32:48 <fresheyeball> jle`: do you know how to input a normal haskell expression and get the TH equivelant?
19:33:34 <fresheyeball> like I input \x -> x
19:33:41 <fresheyeball> and get back FunD and all that non-sense
19:35:10 <MarcelineVQ> that wouldn't be a FunD but you can runQ on a quasiquote to see things like that,  runQ [| \x -> x |]
19:36:41 <MarcelineVQ> for a definition example  runQ [d| { foo :: Int -> Int; foo x = 2 + x } |]
19:36:52 <fresheyeball> MarcelineVQ: what about for a top level function?
19:36:57 <fresheyeball> oh
19:37:56 <MarcelineVQ> [| |]   is equivalent to  [e| |]   expression, there's d for definition and t for type as well
19:52:55 <fresheyeball> ok
19:53:01 <fresheyeball> so I got this mostly working
19:53:12 <fresheyeball> $(foo ''KeyCode) doesn't work though
19:53:26 <fresheyeball> I get "Illegal type variable name: 'KeyCode'"
19:53:31 <fresheyeball> how can I pass this?
19:53:33 <fresheyeball> it is a type
19:54:23 <fresheyeball> oop I got it
19:54:26 <fresheyeball> ConT vs VarT
21:30:47 <orzo> is there a way to reduce the ghci prompt if it got too long after importing?
21:31:35 <Axman6> you can make it smaller using import Foo.Bar.Baz as B, or you can set it (see :help) to anything you eant
21:31:37 <Axman6> want*
21:32:00 <orzo> i found :m on stackoverflow
21:32:14 <orzo> which is good enough
21:32:29 <Axman6> doesn't that remove the modules though?
21:33:16 <justsomeguy> orzo: You can set the prompt with “:set prompt "prompt> "”, for example, and it won't show the module names anymore.
21:33:58 <orzo> thanks
21:34:05 <orzo> axman, i dont know, i imported on accident anyway
21:34:21 <Axman6> you can yse :m -Foo.Bar to remove a single import
21:34:25 <Axman6> use*
21:34:28 <justsomeguy> orzo: To make the change permanent, you can put the string “:set prompt "whatever> "” into the ~/.ghci configuration file.
22:25:09 <aplainzetakind> Why doesn't ScopedTypeVariables help here: https://dpaste.com/D9V7W2RBS
22:25:44 <aplainzetakind> GHC treats the inner s as not necessarily the same as the one in the signature of the function.
22:29:03 <MarcelineVQ> check the docs for Scoped, you have to explicitly activate it with a forall, like  forall s. InputStream s => s -> ParsedInput
22:34:53 <aplainzetakind> MarcelineVQ: Oh right. Thanks.
22:55:38 <guest1214> parseString = do  char '"';  x <- many (noneOf "\"");  char '"';  return $ String x; this can match "abc", what if I want to match "server" in "server=abc"?
23:13:56 <xerox_> guest1214: if it's exactly that string you can match exactly the string I think the parser for that might be called "string"
23:14:29 <guest1214> xerox_: ok
23:15:26 <xerox_> otherwise if it's more general name=val you can do the same you did with many (notChar '=') (I forget the exact names of the combinators but you can find those)
23:28:39 <dminuoso> guest1214: Random side note, you probably should use `takeWhile/takeWhile/takeWhileP/takeWhile1P` instead of many on character parsers. :(
23:29:00 <dminuoso> They perform much faster in the general case if you have more than 1-2 characters to parse
23:30:57 <dminuoso> For example in the implementation of attoparsec, `many someChar` will peek a single character, run the parser, and then branch into success or failure each time. With `takeWhileXX` it will work on entire chunks (which could be as large as 1kB) at a time.
23:48:31 <guest1214> dminuoso: actually I'm tring to re-write this https://paste.ubuntu.com/p/QzwX26Cchf/ with parsec
23:49:09 <guest1214> read a file and get the context to a Map structure
