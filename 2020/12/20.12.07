00:00:04 <zincy__> I have been reflecting on this and don't think it comes down to purity since IO is pure but to do with determinism.
00:00:20 <zincy__> Yes IO is is deterministic on evaluation but not on execution.
00:00:24 <jle`> hm, a lot of my problems have to do with manipulating data
00:00:33 <jle`> so a lot of times the thought of IO doesn't even come up
00:00:50 <jle`> so i usually don't consciously separate my IO code from no IO code, it just happens naturally i guess
00:00:53 <jle`> but maybe this was a learned habit
00:00:54 <zincy__> Yeah this may be a bigger concern for building a web server 
00:01:27 <jle`> for building a web server you're still going to have functions that manipulate data
00:01:46 <jle`> so i don't think i have ever really consciously made a choice in recent memory
00:02:28 <jle`> if i'm writing a function that does IO i do IO
00:02:39 <jle`> if i am writing a function that manipulates data and doesn't involve IO, the thought of IO doesn't really come up
00:02:51 <jle`> to me it's kind of like, "do you separate your Int code from non Int stuff generally?"
00:02:59 <jle`> i mean yeah...my code that involves Int's, i will use Int
00:03:01 <zincy__> Right but if you have a function that does IO do you try and extract the pure logic out of that?
00:03:10 <jle`> but my code that has nothing to do with Int, i would not reach for Int
00:03:32 <zincy__> haha "to me it's kind of like, "do you separate your Int code from non Int stuff generally?""
00:03:49 <jle`> zincy__: hm, on a higher level it's more about separating out functionality into chunks that are manageable to write
00:03:55 <zincy__> But IO is harder to test
00:04:05 <jle`> but if it's manageable to write pure logic within an IO function, i don't consciously try to separate it out
00:04:33 <jle`> yeah, IO is harder to test, and there's no way getting around that for actual IO
00:04:47 <jle`> but if i decide to want to test a specific part of it, i can try to pull it out to something easier to test
00:04:52 <jle`> sometimes that thing happens to be pure, sometimes it doesn't
00:05:05 <zincy__> Yeah
00:05:40 <zincy__> Okay so maybe I have to swallow the pill that without context this is an arbritrary thing to strive for.
00:06:00 <zincy__> jle`: You did a blog post on differentiable programming right?
00:06:04 <zincy__> Very interesting.
00:06:05 <jle`> idk i feel like my point was that i don't consciously strive for it
00:06:10 <zincy__> Yeah
00:06:11 <jle`> i did, a few years back :)
00:06:33 <jle`> but i think a part of it does come down to more experience in coding haskell
00:06:47 <jle`> for example if you feel in your bones that this is oging to be a thing you want to test separately, then you would separate it out
00:06:54 <jle`> but i guess even in that case, whether or not that is IO isn't a part of the picture
00:06:58 <jle`> hm...ignore that point, then heh
00:07:32 <jle`> but maybe over time you will find that more often than not, you will be testing out non-io stuff
00:07:45 <jle`> it's sort of just an evolution of intuition i guess
00:08:12 <jle`> so when people say "you should separate out IO from non-IO", what they are really saying is that in their experience, the things they end up beneffiting from separating out often falls out along IO non-IO lines
00:08:22 <jle`> but i think the benefit isn't from that distinction in and of itself
00:09:10 <zincy__> Ah I see
00:09:37 <zincy__> So you are hearing about the outcome not the rationale
00:11:10 <jle`> i think that's how i would interpret it, yeah
00:11:14 <jle`> but that's just my own experience :)
00:12:03 <zincy__> Thanks!
00:13:01 <hyiltiz> are you guys not talking about whether writing a `yell :: IO () -> IO ()` as `interact . toUpper` is a better idea?
00:13:29 <hyiltiz> a typical case where IO and logic splits "naturally"
00:14:10 <idnar> at the end of the day, "do X instead of Y" is almost always an oversimplification; you need to drill down to what X and Y make easier/harder
00:14:23 <dminuoso> 09:11:51    jle` | [08:07:23] it's sort of just an evolution of intuition i guess
00:14:38 <dminuoso> This is the relevant quote I think.
00:15:43 <dminuoso> In addition to talking about "IO" and "non-IO" we also have this hybrid ST (or MonadPrim polymorphic code)
00:16:18 <dminuoso> It's hard to give an adequate flow chart that uniquely tells you when to do what, if you just experient over time you will build up an intuition.
00:16:41 <dminuoso> Ah heh. It's PrimMonad, not MonadPrim.
00:26:32 <incertia> eventually you will embrace the monad
00:26:36 <incertia> and just write everything in mtl
00:27:27 <incertia> and then delimited continuations gets merged into ghc and everyone starts using eff or something
00:27:52 <suzu_> embrace the monad
00:28:40 <incertia> taste the monad
00:28:53 <suzu_> become the monad
00:28:59 <incertia> touch the monad
00:29:02 <incertia> but do not touch the gonad
00:30:23 * Uniaika wraps themselves in a tortilla
00:30:27 <Uniaika> I HAVE BECOME THE MONAD
00:30:43 <int-e> Uniaika: you know you'll never get out of that, right?
00:30:49 <Uniaika> :P
00:30:55 <Uniaika> hi int-e 
00:31:22 <mbomba> Ah yes, the infamous burrito monad.
00:31:47 <dminuoso> int-e: That's why we have `class (Monad m, Comonad m) => Bimonad m`
00:32:33 <incertia> im just waiting for aoc to release a problem where i can do some weird lens/fp bullshit
00:32:58 <suzu_> meh you can always do that
00:33:08 <incertia> i probably love lens more than i love my girlfriend
00:33:21 <incertia> :thinking:
00:33:22 <suzu_> lens makes my brain melt
00:33:31 <suzu_> i try to avoid anything beyond simple traversals
00:33:35 <suzu_> or foldables
00:33:52 <suzu_> all that moon-abstraction shit is cool but unproductive
00:34:02 <int-e> dminuoso: I never got into comonads.
00:34:04 <dminuoso> suzu_: Give `optics` a try! :)
00:34:17 <suzu_> i dont know much about optiocs
00:34:17 <int-e> (Yay, pun.)
00:34:18 <dminuoso> int-e: Oh it was just a joke..
00:34:24 <dminuoso> Oh
00:34:25 <suzu_> what does it do different from lens?
00:34:25 <dminuoso> haha
00:34:36 <int-e> (But also true.)
00:34:38 <dminuoso> suzu_: It hides the implementation of optics behind newtypes.
00:34:53 <suzu_> ah so no more Getter Setter Better Wetter leaking all over the types?
00:34:55 <dminuoso> And it uses type families and custom type errors to give precise error messages, etc
00:35:05 <dminuoso> Well, you still have those, but in a way that makes perfect sense.
00:35:12 <suzu_> thats sorta neat
00:35:16 <dminuoso> For instance
00:35:55 <dminuoso> % "foobar" ^. each
00:35:55 <yahb> dminuoso: ; <interactive>:71:13: error:; * No instance for (Monoid Char) arising from a use of `each'; * In the second argument of `(^.)', namely `each'; In the expression: "foobar" ^. each; In an equation for `it': it = "foobar" ^. each
00:36:03 <dminuoso> In `optics` you get:
00:36:04 <dminuoso> • A_Traversal cannot be used as A_Getter
00:36:22 <suzu_> that first error is awful
00:36:24 <suzu_> hm nice
00:36:38 <incertia> lens does have some very nasty error messages
00:36:41 <int-e> dminuoso: The thing is, I ask about the usefulness of comonads, somebody mentions an adjoint functor and then I tune out.
00:36:48 <suzu_> i also just dont find lens productive
00:36:55 <suzu_> that extends to a lot of haskell
00:37:04 <suzu_> there's a lot of shiny stuff that's cool but often not directly helpful
00:37:05 <incertia> but it's the price to pay to have transparent representation i guess
00:37:07 <dminuoso> int-e: cellular automatons is a wonderful example of simple comonadic code. say conways game of life
00:37:12 <dminuoso> or image filters
00:38:10 <dminuoso> suzu_: `optics` is also generally safer and doesn't admit some of the "automatically does unexpected things"
00:38:14 <dminuoso> For example..
00:38:24 <dminuoso> % ["foo", "bar", "quux"] ^. each
00:38:25 <yahb> dminuoso: "foobarquux"
00:38:42 <dminuoso> optics would just fail with the above error, because this behavior is likely unexpected
00:38:53 <MarcelineVQ> What was the expected behavior?
00:38:57 <dminuoso> If you don't have a monoid instance, you get the illegible error above, and if you do it hides a potential bug
00:39:46 <dminuoso> MarcelineVQ: view takes a getter, and a getter is a read-only optic that targets a *single* value
00:39:58 <incertia> each is a traversal which can only be viewed if you have monoid
00:39:59 <dminuoso> you can pass it `each` and it works somehow.
00:40:17 <dminuoso> (it works because it mappends all the targets together, and then uses that as the getter target)
00:40:23 <dminuoso> perhaps its what you meant, perhaps its not.
00:40:56 <dminuoso> In optics you'd have to use `foldOf` to make that choice explicit
00:41:35 <incertia> % ([1..5] :: Int) ^. each
00:41:36 <yahb> incertia: ; <interactive>:73:2: error:; * Couldn't match expected type `Int' with actual type `[a0]'; * In the first argument of `(^.)', namely `([1 .. 5] :: Int)'; In the expression: ([1 .. 5] :: Int) ^. each; In an equation for `it': it = ([1 .. 5] :: Int) ^. each
00:41:46 <incertia> oops
00:41:54 <dminuoso> % ([1..5] :: [Product Int]) ^. each
00:41:55 <yahb> dminuoso: ; <interactive>:74:2: error:; * No instance for (Enum (Product Int)) arising from the arithmetic sequence `1 .. 5'; * In the first argument of `(^.)', namely `([1 .. 5] :: [Product Int])'; In the expression: ([1 .. 5] :: [Product Int]) ^. each; In an equation for `it': it = ([1 .. 5] :: [Product Int]) ^. each
00:42:00 <incertia> % ([1..5] :: [Int]) ^. each
00:42:01 <yahb> incertia: ; <interactive>:75:22: error:; * No instance for (Monoid Int) arising from a use of `each'; * In the second argument of `(^.)', namely `each'; In the expression: ([1 .. 5] :: [Int]) ^. each; In an equation for `it': it = ([1 .. 5] :: [Int]) ^. each
00:42:09 <dminuoso> oh
00:42:12 <dminuoso> (Enum (Product Int))
00:42:13 <incertia> that's view requiring Monoid
00:42:15 <dminuoso> That seems like a missing instance
00:42:29 <dminuoso> We should have `Enum a => Enum (Product a)`
00:43:21 <incertia> same for Sum
00:43:36 <dminuoso> MarcelineVQ: The danger here is that through composition it might not be obvious that you "accidentally" build a traversal, so when you then `view` through it and the target has a monoid instance, it just mashes things together. I'd much rather view fails and requires me to fold explicit
00:43:46 <int-e> dminuoso: I guess the fundamental monad fallacy also applies to comonads... the common structure doesn't convey any meaning; the concrete instances are where the real power comes from.
00:44:06 <dminuoso> int-e: In case of comonad actually it's _very_ limited to things having a notion of "neighborhood"
00:44:25 <dminuoso> Beyond Costate/Store you dont have any really interesting comonads for some reason.
00:44:32 <MarcelineVQ> (Monad m, Comonad m) => Interpret m
00:45:07 <dminuoso> (Or say, NonEmpty/Tree which can be thought of as special cases of Costate/Store)
00:46:55 <dminuoso> The largest code base that uses Comonad interface is `lens` I guess
00:48:02 <int-e> . o O ( lens is in a category of its own )
00:48:50 <dminuoso> And that largely dances around various takes of Store and Bazaar
00:49:01 <int-e> bizarre
00:49:13 <int-e> Sorry, I should probably stop.
00:49:23 <dminuoso> (The saying "lenses are coalbgras of the costate comonad" is quite funny and yet true)
00:49:54 <dminuoso> Although I think the word "comonad" was added just for fun and alliteration.
00:50:45 <dminuoso> It all doesnt apply to `optics` though since that's all profunctor based, which is also nice @suzu since it lets you talk about AffineTraversals.
00:50:54 <dminuoso> (Or AffineFolds)
00:54:47 <idnar> :t (^.) :: s -> Getting a s a -> a
00:54:49 <lambdabot> s -> Getting a s a -> a
00:55:03 <idnar> :t (^.) :: s -> Getter s a -> a
00:55:04 <lambdabot> s -> Getter s a -> a
00:56:06 <dminuoso> it will just "do the right thing".
00:56:11 <dminuoso> :>
00:56:46 <idnar> % ((^.) :: s -> Getter s a -> a) ["foo", "bar", "quux"] each
00:56:47 <yahb> idnar: ; <interactive>:80:55: error:; * Could not deduce (Applicative f) arising from a use of `each'; from the context: (Contravariant f, Functor f); bound by a type expected by the context:; Getter [[Char]] [Char]; at <interactive>:80:55-58; Possible fix:; add (Applicative f) to the context of; a type expected by the context:; Gette
00:57:57 <idnar> so that would be similar to the optics version I think
00:58:28 <dminuoso> Yeah
00:58:38 <dminuoso> Well not quite
00:59:03 <dminuoso> In optics it's something in between where the optic can gracefully degrade to a Getter
00:59:32 <dminuoso> Or.. let me think
01:00:55 <dminuoso> % (1,2) ^. indexing (_1)
01:00:56 <yahb> dminuoso: 1
01:01:24 <dminuoso> % ((^.) :: s -> Getter s a -> a) (1,2) (indexing (_1))
01:01:25 <yahb> dminuoso: 1
01:01:31 <dminuoso> Ah interesting, so this works after all
01:02:17 <dminuoso> idnar: I guess my beef remains, it's just very hard to know when something gracefully degrades, or it changes behavior along the way (like with Getting).
01:02:56 <dminuoso> You have to know all the representations of various optics, and how they are elimiated (that is what particular choices of `f` are they called with), and then play constraint resolution in your head
01:03:34 <dminuoso> If you're smart and know the library inside out, that works. If you dont mind being forced to learn how lens works exactly, it's a great choice too
01:04:04 <idnar> dminuoso: yeah, it's harder to understand the types (nevermind the type errors), but you don't need to convert as often
01:04:53 <dminuoso> as often as opposed to what?
01:05:59 <idnar> dminuoso: as opposed to optics
01:06:27 <dminuoso> Mmm. Im not entirely sure what you mean. Where do you feel you need to convert often?
01:07:40 <dminuoso> Unless I wrote polymorphic code (say code that works with any A_Traversal), I haven't needed to convert at all.
01:07:52 <dminuoso> (Because the optic conversions happens in elimiation)
01:08:53 <idnar> I don't think you have to do it all that often, it's just the trade-off; in particular, you can export lens-style optics without depending on lens
01:09:33 <dminuoso> Arguably optics-core is a very light dependency though (and unlike microlens you do get prisms and isos!)
01:11:07 <idnar> from what I can see, optics has done a lot to keep the types from getting in the way, which is great
01:11:52 <idnar> (I haven't used optics myself yet)
01:13:46 <dminuoso> My largest annoyance with optics is that I dont get to use the clean looking (.) for composition anymore. :P
01:14:27 <dminuoso> Perhaps Ill just do a prettify-symbols hack on % whenever my emacs detects an `import Optics` in the buffer. :p
01:15:19 <dminuoso> The glyph ∘ would be a nice choice
01:16:21 <idnar> I'm using the thing that font-locks -> to → and so on
01:18:50 <dminuoso> Ah, I have PragmataPro plus mickeynp/ligature.el so that takes care of -> :)
01:19:10 <dminuoso> So it's a proper ligature that nicely degrades on mouse over
01:19:17 <dminuoso> or cursor over, rather.
01:24:44 <dminuoso> → 
01:24:48 <dminuoso> Mmm, that is properly broken in my terminal
01:25:07 <idnar> I do find it satisfying how things like "you can view a fold if you bring a Monoid" arise "naturally" from the types (`instance Monoid m => Applicative (Const m)` makes that work)
01:25:08 <dminuoso> It doesn't quite know whether it's one or two characters..
01:27:07 <dminuoso> Its rendered with two glyps, selecting either the first or both puts just the single character into the clipboard... and if I select the first box, the second box stops rendering..
01:27:19 <dminuoso> Gah I hate textual stuff.
01:29:48 <[exa]> dminuoso: what's your terminal btw?
01:29:53 <dminuoso> idnar: And I find it satisfying how profunctor optics hierarchy nicely arises from just a tree of constraints.
01:30:40 <dminuoso> With lens you have to give up on that to represent certain optics in this mixed VL/profunctor representation
01:31:48 <idnar> dminuoso: yeah, iirc affine and relevant traversals are much less sticky
01:32:35 <dminuoso> Well, affine is a separate issue, that's just because we dont have some `class (Apply f, Pointed f) => Applicative` type of hierarchy in base.
01:32:47 <dminuoso> If we had, you could have affine optics in lens without an issue
01:33:44 <idnar> part of the reason we don't is that it gets sticky :P
01:35:36 <dminuoso> [exa]: xfce4-terminal
01:40:14 <idnar> dminuoso: anyway, someday I'll probably get bored and port this codebase to optics :D
01:41:31 <[exa]> dminuoso: interesting, → renders there as single glyph for me
01:41:45 <[exa]> single "glyph field" I mean
01:42:29 <dminuoso> [exa]: Which font?
01:43:29 <[exa]> looks like bitstream vera mono
01:43:34 <[exa]> yeah
01:52:12 <joel135> How do I install profunctor-optics in stack?
01:52:58 <joel135> https://pastebin.com/RCxGVHDW
01:54:43 <joel135> https://pastebin.com/8gGMTQFn https://pastebin.com/tBxqAtf1
01:54:50 <Uniaika> joel135: stack is not a package manager like apt-get
01:54:57 <Uniaika> create a stack project with `stack new`
01:55:03 <joel135> ok
01:55:05 <Uniaika> and add profunctor-optics to your cabal file
01:56:45 <__monty__> Do you mean stack.yaml? Cause stack overwrites the cabal file iirc?
01:59:14 <joel135> https://pastebin.com/psWNpsHy
02:01:32 <merijn> __monty__: It does not
02:01:53 <merijn> __monty__: If you use hpack it will automatically call hpack which *will* overwrite the cabal file
02:02:04 <merijn> But you shouldn't use hpack anyway :p
02:02:51 <__monty__> So you can use stack without a stack.yaml?
02:03:15 <merijn> __monty__: You are mixing up stack.yaml and package.yaml (the latter is hpack)
02:03:27 <merijn> __monty__: Using stack via just a stack.yaml and .cabal file works fine
02:03:35 <__monty__> Ah, ok. Thanks for clearing it up.
02:03:54 <__monty__> Does stack simply ignore the bounds you supply?
02:04:46 <merijn> I'm not entirely sure, I expect it does not ignore them (so if the version in your snapshot is out of bounds I would expect it to fail, but I don't use stack so I'm not sure)
02:04:54 <Uniaika> I don't think it does ignore the cabal bounds
02:05:10 <Uniaika> or rather, I've never had any issues with using bounds and stack
02:05:13 <Uniaika> that's more correct :p
02:05:44 <merijn> __monty__: It simply constrains Cabal to the exact version in the resolver, so if those are within the bounds Cabal selects those. If they are not in the bounds Cabal will reject the package
02:08:04 <ski> Axman6 : it doesn't know that `forall msg0 msg1. (Foo msg0 SomeHdr,Foo msg1 ADistinctHdr) => msg0 =/= msg1', and even if it did, iiuc it doesn't take instance contexts into account when checking which instances are relevant
02:11:27 <joel135> "No setup information found for ghc-8.8.4 on your platform. This probably means a GHC bindist has not yet been added for OS key 'linux64-nopie'." --> I saw somewhere I might need to update to "resolver: lts-16.25" in my global stack.yaml but that didn't change anything (my local stack.yaml also points to ...lts/16/25.yaml)
02:41:33 <joel135> Any ideas on my problem?
02:46:16 <merijn> joel135: Which distro is this?
02:46:18 <joel135> I can't even run "stack ghci" or "stack install" if I update "resolver: lts-9.2" to "resolver: lts-16.25"
02:46:20 <joel135> arch
02:46:48 <merijn> heh, how could I ever thought it was anything different :)
02:47:22 <sgibber2018> Arch is wonderful but it does seem to have some Haskell quirks
02:47:38 <merijn> Not sure what the situation with stack is on Arch, but the non-stack situation is irrepairably fucked
02:47:45 <merijn> I recommend consulting the Arch wiki
02:48:24 <merijn> sgibber2018: "some quirks" is a polite way of describing "Arch maintainers intentionally ship a broken configuration" :)
02:48:59 <sgibber2018> Can you explain more? I don't know enough about the situation to form a full opinion.
02:49:15 <sgibber2018> But I did have to do a lot of fiddling to get my haskell environment set up.
02:49:19 <merijn> sgibber2018: GHC's default behaviour has always been to link Haskell libraries statically
02:49:32 <__monty__> Is there a more general version of `Data.Map.unionsWith`? I want to accumulate the values in the maps in lists.
02:49:40 <merijn> sgibber2018: Arch maintainers, for ideological reasons, believe everything should only ever link dynamically
02:50:00 <merijn> sgibber2018: Therefore, Arch's Haskell packages *only* package the dynamic libs, not the static libs.
02:50:10 <merijn> sgibber2018: But they don't bother to patch GHC to a different default
02:50:34 <merijn> sgibber2018: So try to use GHC "as normal" will try and link statically and then crash and burn due to lack of static libs installed
02:51:14 <sgibber2018> merijn: Oh. What's the common workaround for those using Arch? I have only used Haskell for very small-scale programming and some class assignments so far.
02:51:38 <Athas> I think the motivation behind Arch's bizarre decision is that they care more about shipping Haskell *programs* (like Pandoc) than Haskell development tools.  Although it's also a bit fuzzy how Pandoc benefits from this.
02:51:54 <merijn> sgibber2018: The arch wiki has a bunch of suggestions, personally I would just install one of the GHC bindists and avoid the Arch packages entirely
02:51:57 <Athas> sgibber2018: install stack manually (not via pacman) and let stack manage GHC for you.
02:52:13 <sgibber2018> Good to know. Thanks all.
02:52:28 <merijn> Athas: The problem is that now pandoc has a 100+ package dependency footprint that keeps needing to be reinstalled (due to lack of ABI compat) that's pissing off all their users :p
02:52:42 <Athas> merijn: yes, I don't get it either.
02:52:44 <merijn> sgibber2018: https://www.haskell.org/ghc/download_ghc_8_10_2.html
02:53:08 <Athas> I'm a bit fuzzy on why GHC supports dynamic linking at all.  Surely it was nontrivial to get it working, but what's the benefit?
02:53:13 <merijn> sgibber2018: GHC has pre-built binaries that you can install via "./configure --prefix=path/to/install && make install"
02:54:02 <sgibber2018> merijn: Good to know. The next time I need to make something non-trivial with Haskell I was planning to give Stack a try, and now I know to do it directly. 
02:54:09 <merijn> sgibber2018: There's also ghcup which automates all that
02:54:49 <merijn> But I'm a luddite who insists on having his environment exactly the way I want, so I don't really bother with ghcup
02:55:11 <maerwald> merijn: what exactly do you do different?
02:55:28 <sgibber2018> merijn: Nothing luddite about wanting to manage your tech directly, imo
02:55:38 <Athas> merijn: I also used to do that, but is there any benefit to it anymore, or is it just the impossible inertia of habit now?
02:55:57 <sgibber2018> Some things I want to manage directly, some things I don't. That's part of being a computer person, is choosing where to invest your effort.
02:55:59 <merijn> Athas: Probably inertia :)
02:56:39 <merijn> maerwald: The main difference is probably "not having everything in ~/.ghcup" :p
02:57:49 <Athas> Unless you need patched GHCs with nonstandard configuration, then I think ghcup is the most pragmatic choice.
02:57:49 <maerwald> merijn: I support XDG
02:58:00 <merijn> I mean, it's mostly inertia as Athas says. It's always worked for me and I see zero compelling reason to spend the effort to rethink my habits :p
02:58:05 <maerwald> Athas: you can compile patched GHCs with ghcup :p
02:59:30 <merijn> maerwald: Right, but "figuring out how to configure that properly" is more effort than "doing what I've always done" :p
02:59:44 <maerwald> merijn: it's setting one env variable
02:59:51 <merijn> I'll consider it when my current workflow breaks, but considering how minimal that is, it's likely to be never :p
03:00:52 <maerwald> Athas: ghcup compile ghc -j 4 -v 8.4.2 -b 8.2.2 -x armv7-unknown-linux-gnueabihf --config $(pwd)/build.mk --patchdir patches/ -- --enable-unregisterised -- this builds a cross compiler with a custom config and patches
03:01:27 <maerwald> but there's not much difference to doing it manually, creating a bindist and then feeding that bindist to ghcup
03:02:30 <Athas> Right, I'd probably just prefer to use GHC's own build system so I don't have to understand the limitations and toggles of ghcup.
03:02:44 <maerwald> yeah, I only support make
03:05:45 <joel135> so there are 3 ways? i have uninstalled haskell in arch. now i can install (1) https://www.haskell.org/ghc/download_ghc_8_10_2.html, or (2) ghcup, or (3) stack?
03:06:03 <Athas> joel135: yes.
03:06:32 <joel135> ok i'll go with stack and see if that works
03:07:52 <joel135> "Since this installer doesn't support your Linux distribution, there is no guarantee that 'stack' will work at all!" that's reassuring
03:09:30 <Athas> Note that stack is more than just a GHC installer.  It's mostly a way of building your Haskell code (technically not a build system for convoluted reasons).  If you just want the basic compiler and tools, especially if you'd rather use cabal, then ghcup is better.
03:10:33 <joel135> i want to use stack
03:10:58 <joel135> because i tried it with emacs and it worked
03:11:35 <joel135> and cabal feels dangerous ...
03:12:14 <[exa]> joel135: stack can be viewed as cabal orchestration tool, not less dangerous for sure. :]
03:12:57 <maerwald> just use both
03:13:04 <maerwald> there's no commitment issue really
03:13:15 <maerwald> you don't like one, trash it and switch
03:13:58 <Athas> Yeah, they both use .cabal files to structure the program.
03:14:10 <Athas> I use both stack and cabal for different things in my CI.
03:14:18 <qwfplyuh> I'm getting `/run/user/1000/ghc3533_0/ghc_2.h: hClose: resource exhausted (No space left on device)` errors on NixOS when running `ghc -O2 <file>`. What are those folders / files for? Is it OK to just delete them?
03:23:28 <joel135> ok it seems like to install agda i need cabal anyways
03:27:43 <joel135> (unless i manage to use this https://dev.to/sirasolra/installing-agda-in-stack-3b0l)
03:30:50 <mlugg> I'm working on implementing a HM type inference system (approximately Algorithm W) in Haskell and am having trouble finding information on one small aspect of it. Like in Haskell, I have both explicitly and implicitly typed let-bindings. Most of the inference works, but there is one thing left; for explicit binding checking, I need to be able to
03:30:51 <mlugg> see if one type scheme is an instance of another (or rather, if one is at least as general as another), and I cannot find any information on how best to do this. I believe it could be done by finding the mgu of the two types in isolation and checking that the substitution returned obeys certain properties, but this feels quite complicated. Is there
03:30:51 <mlugg> a nicer way?
03:31:36 <arahael> mlugg: What sources did you use, out of interest? (I might be interested to do this myself, one day, though that day is not today, sadly)
03:34:08 <zangi> since cabal-install doesn't have `cabal uninstall`, is it safe to remove `~/.cabal/bin/program` manually?
03:34:48 <mlugg> arahael: For my implementation? I've been looking over a variety of stuff for a while, I can't really pin down one good resource unfortunately - there's a wealth of information on the algorithm for the most part, the only bit which it's a bit harder to find information on is Haskell-like let bindings. To be honest, I'm not certain where I managed
03:34:49 <mlugg> to figure those out, but I believe this https://gist.github.com/chrisdone/0075a16b32bfd4f62b7b was vaguely helpful
03:36:02 <arahael> Thanks for that. :)
03:55:56 <joel135> ok now i have stack, ghc, agda, emacs compatibility
03:56:59 <joel135> how to install profunctor-optics? https://pastebin.com/pXwysezt
03:57:33 <dminuoso> qwfplyuh: Gah, the error message is misleading
03:58:20 <dminuoso> joel135: Mmm, I dont know about stack really, but optics (which is also profunctors based) is in the latest stackage resolvers.
03:58:27 <dminuoso> In case that's an option
03:59:01 <joel135> i am using url: https://raw.githubusercontent.com/commercialhaskell/stackage-snapshots/master/lts/16/25.yaml
03:59:16 <dminuoso> That one has optics in it.
03:59:31 <dminuoso> (or optics-core, depending on what you want)
03:59:35 <joel135> ok i don't really care which package i try
04:00:38 <joel135> i'll try optics then
04:03:38 <joel135> it worked
04:04:53 <dminuoso> qwfplyuh: The error could also be emitted when you run out of file descriptors or inodes I think.
04:25:19 <joel135> oh no now i get Haskell process command errored with: (error "Unexpected response from haskell process.")
04:25:24 <joel135> in emacs
04:26:18 <joel135> even though i am using "(setq haskell-process-type 'stack-ghci))"
04:31:50 <joel135> ok i needed this https://github.com/haskell/haskell-mode/issues/1553#issuecomment-358373643
05:29:11 <operand> Hi, I'm trying to parse some input using Megaparsec and I can't quite figure out if there is any way to parse, e.g. "word1 word2" without having to manually concatenate the results of parsing word1, the space, and word2
05:29:33 <operand> I'm not sure if there /is/ even a way, but if somebody could confirm that that would be quite nice as well :P
05:36:46 <tomsmeding> operand: what about this?
05:36:50 <tomsmeding> :t fmap concat . sequence
05:36:52 <lambdabot> (Traversable t, Monad f) => t (f [a]) -> f [a]
05:37:38 <tomsmeding> as in,  let combine = fmap concat . sequence in combine [parseWord1, string " ", parseWord2]  or suchlike
05:41:18 <dminuoso> Mmm, that looks like we should have a combinator for it
05:42:03 <dminuoso> operand:  What about the naive? (<>) <$> w1 <*> w2
05:42:21 <dminuoso> The space shouldnt even be in your grammar at this point
05:42:32 <dminuoso> Every token should be wrapped in your `lexeme` combinator
05:45:02 <mynameismud> hello
05:45:19 <operand> dminuoso: You're right, I probably should be using the lexeme combinator :/ I just haven't been able to *quite* figure it out yet
05:45:34 <operand> I'm using advent of code challenges to try and learn parser combinators :p
05:45:41 <dminuoso> operand: let lexeme = L.lexeme sc; anyWord = L.lexeme (takeWhileP (Just "any word") (satisfy isAlpha)) in (<>) <$> anyWord <*> anyWord
05:46:02 <dminuoso> Where sc is your favourite space consumer
05:47:09 <dminuoso> Oh, or https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec-Byte.html#v:letterChar perhaps
05:47:38 <dminuoso> Mmm, no I think takeWhileP with a predicate is faster
05:48:15 <merijn> operand: tbh, these AoC puzzles aren't great for learning megaparsec
05:48:36 <operand> merijn: i noticed. but i'm sticking with it anyway v:
05:49:15 <mynameismud> any people around for a noob or you all 3l33t and bots?
05:49:25 <dminuoso> mynameismud: Just ask your question.
05:49:29 <dminuoso> We don't mind beginner questions of any kind.
05:50:14 <dminuoso> If this channel is noisy you can also try #haskell-beginners which tends to be a bit quieter, but we dont mind such questions asked in #haskell at all.
05:50:38 <dminuoso> Mmm, surely lambdabot has a factoid for this
05:50:42 <mynameismud> first of thank you, secondly what linux lightweight is great to use if you can't run Kali
05:51:32 <mynameismud> my workstation had a malfunction cuz of eletricity is in the shit here so i'm using an old laptop now
05:51:38 <Axman6> mynameismud: does that question have anything to do with the Haskell programming language?
05:52:14 <mynameismud> i'd like to learn it 
05:52:47 <operand> dminuoso: It just still confuses me what `lexeme sc parser` actually does. Will it simply run the given parser on every lexeme, delimited by the spaces as taken by spaceconsumer?
05:53:20 <dminuoso> operand: So the idea is roughly this: Rather than wrapping it with lexeme manually, you'd rather have a lexeme partially applied to a consistent space consumer.
05:53:38 <dminuoso> say your grammar allows for haskell style comments, and only spaces (but not tabs!) are considered whitespace
05:54:08 <dminuoso> Then you would write a space consumer, that is just a parser that returns nothing, but it consumes all following comments/spaces until it hits something else
05:54:11 <Axman6> you might find you better answers about linux in ##linux
05:54:30 <dminuoso> The definition of lexeme is just a simple:
05:54:33 <dminuoso> lexeme spc p = p <* spc
05:54:34 <Axman6> if you've got Haskell questions we'll be more than happy to help though
05:55:15 <Axman6> dminuoso: tabs are considered greyspace characters, because they make people sad
05:55:51 <dminuoso> operand: So what you'd write is `lexeme = L.lexeme yourSc`, you can then use your own `lexeme` combinator to build parsers for lexemes.
05:56:14 <dminuoso> Say: instanceKw = lexeme (string "instance")
05:56:16 <operand> That is the part I get. "use your own lexeme combinator to build parsers for lexemes" is the part I dont get :P
05:56:26 <dminuoso> operand: ^- see that example I just wrote
05:56:45 <operand> <* is the applicative functor for "ignore right result but keep effect", right?
05:56:49 <dminuoso> Right.
05:57:39 <operand> So the `lexeme` combinator will not tokenize the input, but rather just automatically strip whitespace for me so I don't have to deal with it?
05:57:47 <dminuoso> Well..
05:57:52 <dminuoso> it depends on your look of things, but yeah
05:58:15 <dminuoso> you *could* build a plain tokenizer with this
05:59:21 <dminuoso> lexeme turns a parser that parses the actual lexeme into one that works on the input stream
05:59:33 <dminuoso> just like your tokenizer would toss away white space
06:00:30 <operand> Right, that makes a lot of sense
06:02:32 <operand> Thanks a lot :D
06:16:06 <jonn> Dear all, I wonder if VSCode users can shed some light on hints not applying with `Haskell` extension in a timely manner. For instance, if I make code with redundant brackets, like `id' x = (x)`, it takes over a minute to remove redundant branches.
06:48:41 <codedmart> How can I link payments/changes to payouts in the api?
06:49:05 <codedmart> Sorry wrong channel
07:36:08 <cheater> hi all
07:36:52 <cheater> i'm trying to compile some haskell libs on windows, but for that i need to compile llvm from source, and hitting some snags with cmake not finding kernel32.lib. has anyone got experience with this sort of stuff who could help me with this?
07:47:44 <merijn> cheater: Wait, why do you need llvm?
07:48:02 <cheater> i need one binary from it that isn't included in the binary distribution
07:48:20 <cheater> https://stackoverflow.com/questions/17096804/where-is-llvm-config-in-windows
07:48:31 <cheater> llvm-config is not included in the binary distributions
07:48:43 <cheater> and that's needed to compile the llvm haskell library
08:04:53 <merijn> Have you heard the joyous news? The gospel that will improve all our lives forevermore?
08:05:32 <merijn> I still remember the news!
08:05:47 <merijn> When Athas notified me "lazy sum is kill" :>
08:06:30 <merijn> https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4355 \o/
08:06:53 <Athas> Also minimum and maximum.
08:07:52 <shapr> chessai: good job
08:08:26 <chessai> shapr on what
08:08:35 <merijn> Whichever GHC this end up being in will probably be the first one in years I will upgrade to immediately
08:08:45 <merijn> chessai: Killing lazy sum :D
08:09:13 <merijn> I guess technically, you didn't kill it, just merged it, but still
08:09:27 <chessai> minimumBy and maximumBy too
08:09:50 <merijn> oh, wait, it was you on those commits
08:09:54 <merijn> anyway
08:10:07 <merijn> chessai: Do you know if it'll be 9.0 or 9.2?
08:10:12 <chessai> I did write it, didn't merge it
08:10:16 <chessai> 9.2 iirc
08:10:21 * merijn sad noises
08:10:49 <Athas> 9.2 will be the year of GHC on the desktop.
08:11:18 <merijn> Man, this is the best news since finding out strict foldMap was finally added :>
08:11:19 <maerwald> which GHC brings the long awaited build time improvements? :)
08:11:44 <Uniaika> < merijn> Have you heard the joyous news? The gospel that will improve all our lives forevermore? // <3
08:11:52 <Uniaika> merijn: 8.12 ! :P
08:12:03 <merijn> 8.12 is a myth
08:12:13 <Uniaika> my poing ;)
08:12:17 <Uniaika> *point
08:21:22 <maerwald> lower build times increase productivity more than any linear typesystem
08:21:44 <merijn> maerwald: Who was talking about linear types, though?
08:21:56 <maerwald> merijn: no one, I am
08:22:23 <maerwald> sharing my excitement for a GHC release that fixes build times :)
08:22:29 <merijn> I mean, both linear Haskell and dependent Haskell are likely to have limited use, imo
08:22:35 <merijn> But that's hardly a niche opinion
08:23:10 <ShalokShalom> hi there :)
08:23:38 <ShalokShalom> No setup information found for ghc-8.8.4 on your platform.
08:23:38 <ShalokShalom> This probably means a GHC bindist has not yet been added for OS key 'linux64-ncurses6'.
08:23:39 <ShalokShalom> Supported versions: ghc-7.10.3, ghc-8.0.1, ghc-8.0.2, ghc-8.2.1, ghc-8.2.2
08:24:04 <ShalokShalom> Does this mean stack does not provide any option for my OS, since its gcc is too new?
08:25:11 <merijn> hmm, that's the 2nd or 3rd time that error comes by
08:25:23 <merijn> Which distro?
08:26:14 <ShalokShalom> KaOS
08:26:32 <ShalokShalom> Independent distro
08:26:51 <merijn> Sounds like it ships a combination of libraries that's unknown to stack
08:26:53 <ShalokShalom> I used the curl command on the homepage
08:27:03 <ShalokShalom> Aha. OK?
08:27:11 <ShalokShalom> And how can I solve this?
08:27:37 <merijn> Well, if you mean "while still using stack", then the answer is probably "open an issue and cross your fingers"
08:27:38 <maerwald> it's pacman based
08:27:47 <ShalokShalom> Yes. 
08:27:55 <maerwald> Do they reuse arch packages?
08:27:59 <ShalokShalom> No. 
08:28:03 <ShalokShalom> Its independent. 
08:28:17 <ShalokShalom> Otherwise, I would just use Arch packages :)
08:28:23 <maerwald> I can't find a KaOS docker image
08:28:36 <merijn> ShalokShalom: ahahaha
08:28:39 <merijn> ShalokShalom: Don't :)
08:28:39 <ShalokShalom> I dont think, there is one. You want to setup and try it yourself?
08:28:52 <merijn> ShalokShalom: Arch's Haskell package are *completely* broken
08:28:53 <ShalokShalom> Yeah I know. It would break my system. 
08:29:11 <ShalokShalom> Ah, nice. And they are countless, so I decided to use Stack. 
08:29:25 <merijn> ShalokShalom: No, I meant that they don't even work right on Arch :)
08:29:27 <ShalokShalom> KaOS has no Haskell packages at all, since its a tiny distro
08:29:34 <ShalokShalom> Yes, I understood. 
08:29:49 <ShalokShalom> I didnt know that, while it would destroy my OS anyway. :)
08:30:45 <merijn> ShalokShalom: stack insists on installing its own GHCs, so if they don't have compatible binaries that just won't work. You could install GHC (and cabal) yourself and work with cabal
08:31:04 <ShalokShalom> I think it mistaken my OS for an Arch:
08:31:14 <merijn> ShalokShalom: I'm sure *one* of the pre-built GHC bindists should work: https://www.haskell.org/ghc/download_ghc_8_10_2.html#linux_x86_64
08:31:33 <ShalokShalom> Uploaded file: https://uploads.kiwiirc.com/files/41c49374e24a9a894eb6a043c518fa96/Screenshot_20201207_173102.png
08:31:50 <ShalokShalom> See line 74 and 76 
08:31:57 <ShalokShalom> Or is this CPU Arch?
08:32:04 <ShalokShalom> Let me read the script. 
08:33:26 <ShalokShalom> CPU
08:33:57 <maerwald> ShalokShalom: I want to test KaOS without spending time :)
08:34:10 <ShalokShalom> I figured
08:39:06 <ShalokShalom> So there is no way?
08:39:26 <ShalokShalom> How does Stack integrate new distros, which binaries are missing and who does maintain or know about it?
08:42:22 <merijn> ShalokShalom: Check their github page?
08:42:29 <ShalokShalom> Thanks.
08:49:49 <jared-w> Does KaOS have docker as a package? You could always just use ghc-in-docker
08:56:49 <cheater> hi. my problems have been solved by rebooting and running cmake inside the Developer PowerShell for VS 2019 command prompt after deleting the source tree and unpacking it again.
09:36:05 <emmanuel_erc> Hello there. What is Haskell support on Windows like these days?
09:36:22 <texasmynsted> I see ghcup does not run on new Apple Silicon, m1, as per https://leo.fm/2020/11/applesilicon/
09:36:28 <xerox_> texasmynsted: it does
09:36:40 <texasmynsted> ?
09:36:43 <texasmynsted> It does?
09:36:58 <xerox_> yep I'm using it
09:37:02 <texasmynsted> Heh okay
09:37:15 <maerwald> maybe they're still testing the shell version of ghcup?
09:37:44 <texasmynsted> I guess I did not know there was more than one version of ghcup
09:38:34 <maerwald> texasmynsted: what version are you using 
09:39:01 <maerwald> xerox_: can you comment on the blog post? (there's a comment section)
09:39:44 <texasmynsted> It lives here /Users/mmynsted/.ghcup/bin/ghcup
09:40:10 <texasmynsted> So I am guessing I must have installed via "curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh "
09:40:20 <maerwald> that's the binary version then
09:40:23 <sm[m]> hello emmanuel_erc , it works well. stack makes it easiest, chocolatey is another option
09:40:44 <sm[m]> emmanuel_erc: certain GHC releases work better than others, generally pick the latest point release
09:40:44 <texasmynsted> Is that the version that works?
09:40:49 <texasmynsted> Oh I suppose it would not
09:41:00 <maerwald> texasmynsted: I'm pretty sure xerox_ is using that version too
09:41:04 <xerox_> yes
09:41:07 <maerwald> just not sure what version the blog poster used
09:41:20 <xerox_> I can't this very moment but I'll make a note for later
09:42:04 <texasmynsted> insteresting 
09:42:13 <texasmynsted> interesting rather
09:42:26 <texasmynsted> I would not think the binary would work. I do not see an m1 binary here https://downloads.haskell.org/~ghcup/
09:42:40 <xerox_> the system can and does run x86_64
09:42:46 <texasmynsted> I guess it runs via rosseta or whatever it is called
09:42:53 <texasmynsted> nod
09:42:55 <texasmynsted> okay
09:43:41 <emmanuel_erc> I was told by another developer (non-Haskel user btw, this particular guy is not malicious) that was Haskell support on Windows is worse than Node.js or Rust.
09:44:13 <emmanuel_erc> sm[m]: I was very skeptical of his claims, especially considering that he doesn't really use Haskell all that much.
09:44:22 <maerwald> Probably, but windows is hard and not much industrial interest in pushing support I guess
09:44:45 <maerwald> and now that there's WSL...
09:45:39 <texasmynsted> what is WSL?
09:46:19 <emmanuel_erc> I guess what I'm asking is if you were trying to move a Haskell app originally developed on Linux/MacOS, and its main non-Haskell dependency was postgres, would it be difficult?
09:47:37 <texasmynsted> iirc you can install postgresql on windows
09:48:00 <emmanuel_erc> sure
09:48:20 <texasmynsted> And there are other DBMS that work on windows
09:48:47 <texasmynsted> also it is a database, why would it need to run locally?
09:49:18 <texasmynsted> Just run postgresql on a "best-fit" system
09:49:26 <maerwald> texasmynsted: it's basically linux on windows
09:49:40 <ezzieyguywuf> so if I have `mA :: Maybe a; mB :: Maybe a`, and I want to do something different based on which combination of Just/Nothing the two are, how might I go about doing that?
09:49:45 <maerwald> on WSL2, a real linux kernel is running there afaik
09:49:52 <ezzieyguywuf> case-statement comes to mind, but I'm wondering what other options there are
09:50:23 <ezzieyguywuf> nvm I'm just going to use case lol
09:51:19 <ski> ezzieyguywuf : do what, specifically ?
09:51:25 <texasmynsted> You could always start with case, then later you may find you can simplify. 
09:51:49 <texasmynsted> It really depends on what your "combination" is.
09:52:06 <texasmynsted> I can not tell what you mean when you simply say combination
09:52:44 <maerwald> meh, I confused usernames here
09:52:53 <maerwald> emmanuel_erc: the above was for you ^^
09:53:02 <maerwald> why are you both yellow colored
09:53:18 <texasmynsted> I am blue as far as I can tell
09:53:26 <maerwald> nah, definitely yellow here
09:53:28 <maerwald> :D
09:53:30 <texasmynsted> you show as yellow to me actually
09:53:52 <emmanuel_erc> maerwald: Yeah I see that.
09:54:17 <texasmynsted> But then most everybody shows as yellow in this limechat theme
09:58:17 <ShalokShalom> How can I connect the GHC from Stack to VSC?
09:58:34 <ShalokShalom> I got it installed and it still complains about not being there. 
09:58:45 <ShalokShalom> I assume I have to set some path or so?
09:58:59 <maerwald> ShalokShalom: ~/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.5/bin on my PC, for example
09:59:06 <ShalokShalom> Thanks a lot
09:59:07 <sm[m]> ShalokShalom: install the Haskell extension, that should be enough. Check their readme
09:59:09 <maerwald> that's where it installs stuff
09:59:31 <maerwald> but probably there should be an  cleaner way yeah
09:59:35 <ShalokShalom> The script mentions it installs a "generic bindist" 
09:59:36 <sm[m]> emmanuel_erc: postgres on windows sounds difficult, but you'd have to check the postgres site
09:59:44 <ShalokShalom> Does anybody know, what that means?
10:00:00 <ShalokShalom> It seems like there is only one binary per platform, so that confuses me. 
10:00:22 <ShalokShalom> Which other than the "generic bindist" could be meant..
10:01:00 <geekosaur> shalokShalom, for your purposes it means "they don't expect you to be using stack"
10:01:17 <ShalokShalom> Aha. Ok. 
10:01:24 <geekosaur> and there is more than one binary per platform because of dependencies
10:01:28 <ShalokShalom> But what is a generic "bindist"
10:01:38 <ShalokShalom> Ah, I mean in the download section.
10:01:48 <ShalokShalom> So there are more options, not hosted there?
10:02:09 <geekosaur> it comes with a configure script that figures out things like what linker you have installed, and configures the compiler appropriately
10:02:23 <ShalokShalom> Ah ok
10:02:30 <ShalokShalom> So its not about a different binary?
10:02:43 <ShalokShalom> The binary for all x86_64 Linux is always the same?
10:03:46 <geekosaur> is not always the same, see for example http://downloads.haskell.org/~ghc/8.10.2/
10:04:31 <ShalokShalom> maerwald: The directory you pointed me to does contain script files
10:04:50 <ShalokShalom> despite the name "bin" for it, why ever *shrug*
10:04:54 <maerwald> ShalokShalom: was that a question?
10:05:36 <ShalokShalom> You pointed me to it, in regards to the path I have to point Visual Studio Code to
10:05:44 <ShalokShalom> And that wants a binary, obviously 
10:05:53 <ShalokShalom> Uploaded file: https://uploads.kiwiirc.com/files/6cb7290cfe4450b4c7cc68d48ea9c389/Screenshot_20201207_190438.png
10:05:57 <maerwald> yes, you can treat script files and binaries interchangably on linux 
10:06:04 <maerwald> for the purpose of execution
10:06:10 <ShalokShalom> Sure?
10:06:15 <maerwald> the script just does some stuff and then invokes the binary
10:06:18 <ShalokShalom> OK, first time that I heard this. 
10:06:21 <maerwald> yes, pretty sure
10:06:24 <ShalokShalom> So this script invokes the binary, or what?
10:06:33 <ShalokShalom> ok, fine
10:06:42 <maerwald> if you check your /usr/bin you'll see tons of wrapper scripts
10:06:43 <monochrom> I am not sure why this digression is productive.
10:07:10 <ShalokShalom> Thanks a lot
10:07:29 <ShalokShalom> monochrom: Cause I like to understand 
10:08:21 <monochrom> OK, here is one meta-level observation that can get you very far.  Don't trust "meaningful" names like "bin" and "filter".
10:09:10 <monochrom> The real meaning is always in how people actually end up using the thing, not what name people have coined for it.
10:10:03 <ShalokShalom> Thats why I was asking 
10:10:48 <maerwald> Type families confused me forever. I'm always thinking of something social, but that's not what they are
10:10:50 <monochrom> In fact I also chose the "filter" example very carefully. Half of the population would look at this code "filter even [1,2,3,4,5]" and guess from the name "filter" that it filters out even numbers, so the result is [1,3,5] the odd numbers.
10:11:07 <merijn> monochrom: I have to check every time >.>
10:11:18 <monochrom> But no, the author of "filter" pulled your legs with "meaningful" names.  That code filters in the even numbers.
10:11:25 <ShalokShalom> Why this digression. 
10:12:24 <monochrom> The digression that will end all digressions.
10:13:39 <sm[m]> ShalokShalom: I think you're learning stuff, but in case you missed it: VS Code's Haskell extension's readme has good advice for your original q: https://marketplace.visualstudio.com/items?itemName=haskell.haskell#requirements
10:13:57 <ShalokShalom> Oh, thanks a lot
10:14:28 <ShalokShalom> On the PATH is in any distro different and almost always also on /usr/bin
10:14:33 <ShalokShalom> If I remember correctly 
10:14:35 <ezzieyguywuf> ski: I was basically wondering if there was a way to do something other than the case statement here: https://dpaste.com/4R6KKB98G
10:15:17 <ezzieyguywuf> althought now I have a new question - that "do" is actually "ApplicativeDo", and the case statement fails b/c it tries to turn it into a monad. So how can I replace the case statement such that it is compatible with Applicitave?
10:16:05 <dolio> Apply `pure` to the case statement.
10:16:42 <solonarv> other than moving 'pure' out I think this is fine to leave as-is
10:17:11 <dolio> It's not fine if it doesn't work.
10:17:35 <solonarv> although you could of course change your EndComponent data type so that instead of these four alternatives, it has a single alternative with two 'Maybe _' fields
10:18:09 <solonarv> dolio: yes, that is why I included the fix that's necessary to make it work
10:18:45 <dolio> Oh, I see what you meant.
10:22:55 <ezzieyguywuf> hrm, I see
10:23:11 <ezzieyguywuf> solonarv: I would guess taht's simply a matter of taste, i.e. leaving the case or changing EndComponent
10:23:45 <ezzieyguywuf> though in either case you're just moving the check from one place to another, though moving it out of the case-statement may make it possible to do pattern matching, which may arguably be more clear
10:24:47 <ShalokShalom> One more question: When I like to point the whole stack installation to my /usr/bin, is it there enough to point the whole .stack folder?
10:24:58 <ShalokShalom> Since I dont see any dedicated stack binary 
10:25:22 <ShalokShalom> And the mentioned link says I should put the whole stack into the PATH
10:25:39 <ezzieyguywuf> dolio: yup, pure fixes it.
10:27:06 <monochrom> Yes, just add stuff to PATH
10:29:06 <ShalokShalom> It failed to load ghc that way, but it works when I point the ghc script from stack directly into the PATH
10:29:27 <merijn> ezzieyguywuf: tbh, I'd just move those do blocks into named where bindings and avoid ApplicativeDo entirely :)
10:29:54 <merijn> Then you don't have to worry about pleasing the fickle ApplicativeDo gods
10:30:31 <koz_> Yep, they are rather fickle.
10:30:31 <maerwald> at least we're not short of GHC extensions
10:30:51 <koz_> maerwald: To quote Edwin: "I'm using Haskell98, which means 'Haskell with 98 extensions enabled'".
10:31:04 <maerwald> imagine a haskell source file that doesn't start with 20 language pragmas... looks n00b
10:31:20 <monochrom> That would be mine.
10:31:34 <ShalokShalom> haha
10:31:58 <fresheyeball> so I am on NixOS have have nixops working just fine
10:32:10 <fresheyeball> A co-worker is on Mac and I am trying to get nixops working for him
10:32:14 <maerwald> fresheyeball: wrong channel? :D
10:32:24 <fresheyeball> maerwald: you are right
10:32:26 <fresheyeball> my bad
10:32:28 * geekosaur has exactly one extension in the file he uses the most, and is considering removing that
10:32:34 <sm[m]> ShalokShalom: did stack's Windows 64 bit installer, linked from that readme, not put it in PATH ?
10:32:56 <geekosaur> the other files don't use any extensions at all…
10:33:49 <solonarv> maerwald: that's mine, because I put all my files in default-extensions! :p
10:34:38 <maerwald> solonarv: that's the best way to confuse contributors why their code behaves weird
10:35:05 <ezzieyguywuf> merijn: but that's not how glguy does it in the documentation! (lol)
10:36:27 * glguy tries to figure out what he did
10:36:39 <monochrom> Although I promote putting extensions in the file that needs it, I doubt that contributor confusion has actually happened or will actually happen.
10:37:04 <monochrom> My ideal is to do both.
10:37:38 <maerwald> monochrom: I'm bold. I put Strict and StrictData in my default extensions and wonder if anyone will ever figure out
10:37:49 <maerwald> until now, no one has
10:38:13 <geekosaur> this sounds kinda xkcd
10:40:44 <aplainzetakind> I vaguely recall being told off for worrying writing recursions in a tail-recursive form, I think to the effect that "ghc transforms such things anyway", but my memory may be wildly inaccurate. Is there any advantage to the less-readable, uglier first version here? https://gist.github.com/aplainzetakind/fb48c59ac152dff3f1dc97bd3374bd6c
10:40:52 <aplainzetakind> worrying about*
10:42:04 <ezzieyguywuf> glguy: lol, nah you didn't do anything. They were suggesting not using applicativedo
10:42:16 <ezzieyguywuf> glguy: for a very particular thingy that I had posted earlier
10:43:08 <maerwald> aplainzetakind: compare foldr and foldl
10:43:41 <maerwald> There's also a semi helpful wiki page https://wiki.haskell.org/Tail_recursion
10:44:30 <joel135> i sometimes wish i could point at a piece of code, and my computer would tell me the type
10:44:43 <joel135> aside from top level
10:44:50 <koz_> joel135: We have typed holes, which is close?
10:44:53 <maerwald> joel135: you mean *expression*?
10:44:54 <joel135> yes
10:45:12 <maerwald> that worked with previous versions of haskell-ide-engine, but not anymore
10:45:12 <joel135> yes on both counts
10:45:28 <maerwald> there's some on-going effort about it I believe
10:45:47 <joel135> ok
10:46:13 <aplainzetakind> maerwald: So, the first one is indeed supposed to use less memory then?
10:47:37 <koz_> Is there any particular reason why we don't have something like 'foldrMWithKey :: (Monad m) => (k -> v -> a -> m a) -> a -> HashMap k v -> m a'?
10:48:32 <maerwald> aplainzetakind: I don't make memory predictions about haskell code :p
10:48:54 <maerwald> foldl is almost never what you want, but foldl', but that's a different story
10:49:39 <maerwald> https://wiki.haskell.org/Foldr_Foldl_Foldl%27
10:50:52 <aplainzetakind> I'll turn on profiling and see if there's a difference.
10:53:39 <monochrom> aplainzetakind: With lazy evaluation sometimes saving the day and some other times getting into the way, I would tell you off for expecting any simple "rule of thumb".
10:53:53 <monochrom> Not even "don't use tail recursion".
10:54:35 <jonn> Any insight on the huge lag whilst applying hints in VSCode? It takes minutes to apply a simple bracket removal.
10:54:45 <maerwald> list fusion would be the next topic you'd want to look at
10:54:47 <maerwald> https://www.stackbuilders.com/tutorials/haskell/ghc-optimization-and-fusion/
10:54:59 <monochrom> "foldr (+) 0 [1..n}" and "foldl (+) 0 [1..n]" both use Θ(n) space. Their own difference is going through different journeys. This is a case when tail recursin doesn't help.
10:55:33 <aplainzetakind> monochrom: Indeed, I think you were the one to tell me off.
10:55:35 <maerwald> also, in haskell it's even hard to predict complexity :p
10:55:47 <monochrom> But foldl' will bring it back to Θ(1) space. In this case combining tail recursion and seq helps.
10:56:32 <aplainzetakind> Anyway, if the answer is "it depends", that's easy to accept.
10:56:41 <monochrom> However, you will want "take" and "map" to use non-tail recursion in "print (take 10 (map f mylist))", especially if mylist is much longer than 10.
10:57:19 <aplainzetakind> I was uneasy about failing to understand a "rule of thumb".
10:57:30 <monochrom> There are beginners who look at "map f (x:xs) = f x : map f xs" and think "this is non-tail recursion, let me improve it by adding an accumulator parameter for the answer".
10:57:56 <monochrom> That "improvement" totally breaks.
10:58:55 <ski> aplainzetakind : do they even give the same result ?
11:00:36 <aplainzetakind> ski: I just noticed the second is off by one.
11:00:48 <ski> yep, that's what i thought
11:00:54 <aplainzetakind> Thanks.
11:03:44 <iqubic> How does one change map to use an accumulator?
11:04:04 <merijn> You switch to fold...
11:04:04 <ski> @type mapAccumL
11:04:06 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:04:12 <ski> @type mapAccumR
11:04:14 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:04:17 <Sonolin> I noticed StdGen doesn't seem to have an Eq instance... is there any issue with implementing that (I was planning to just utilize the show instance)?
11:04:30 <ski> or use `mapM' with `State s'
11:05:17 <ski> > join (==) (mkStdGen 1234)
11:05:20 <lambdabot>  True
11:07:54 <iqubic> I wish Haskell had fully fledged dependent types already.
11:09:11 <merijn> Why?
11:10:45 <geekosaur> Sonolin, I see one documented and ski just demonstrated it a few minutes ago… why do you feel it's missing?
11:11:17 <trepanger> iqubic: there's LiquidHaskell which is close (well, refinement types)
11:11:42 <iqubic> I don't want refinement types though. I want actual dependent types.
11:11:46 <merijn> trepanger: refinement types are rather different, tbh
11:12:25 <merijn> iqubic: tbh, I wouldn't get your hopes up too much. I expect the ergonomics of Dependent Haskell will remain significantly inferior to languages designed from the start to accommodate dependent types...
11:13:21 <Athas> I actually dread the day Haskell gets dependent types!
11:13:36 <merijn> I expect most people who say they want dependent Haskell really just want "a Haskell-like language designed for dependent types" (aka Idris), rather than whatever Dependent Haskell will look like
11:13:38 <iqubic> Athas: Why do you dread that?
11:13:40 <merijn> Athas: Same
11:13:41 <Athas> Not due to any specific problem, more because I cannot think it will actually end up being nice to use.
11:13:57 <iqubic> Yeah, I suppose that's the issue.
11:14:05 <Athas> I like dependent types and I like languages with roughly the ML/Haskell-level of types, but I don't like mixing the two.
11:14:10 <merijn> iqubic: Because hacking dependent types into GHC considerably complicates the compiler, the surface language will probably not be that nice to use
11:14:16 <iqubic> Right. I see.
11:14:40 <Athas> If dependent types would also complicate the GHC core language, then I will _really_ worry, but I don't recall anyone saying that they would.
11:14:50 <merijn> iqubic: Like, do you want "shitty hasochism-like dependent types" or do you just wish Haskell had dependent types elegantly integrated? Because I don't think you will get the latter :)
11:15:03 <monochrom> aplainzetakind: Your n+n' is kept unevaluated, that will take up room, similar to foldl (+).  If you don't mind changing the order of parameters to "go kss n", you can use "go kss' $! n+n' " to kill the laziness on n+n'
11:15:08 <iqubic> I see the issue I have.
11:15:12 <trepanger> Could idris call Haskell functions and vice-versa?
11:15:21 <dolio> It'll probably be better than hasochism. Not sure how much, though.
11:15:45 <merijn> iqubic: And "considerably complicating the compiler for not nice to use Dependent Types" as oppossed to spending more time in getting GHC nicer is a poor trade-off imo :)
11:15:46 <iqubic> What is hasochism?
11:16:01 <Athas> A serious argument can be made that GHC Haskell is already dependently typed (Stephanie Weirich is a proponent of this), which would make GHC Haskell the most shitty dependently typed language in use.
11:16:03 <aplainzetakind> monochrom: Can I just do `go !n kss =` when defining go?
11:16:09 <Athas> I hope Haskell isn't going to end up like C++.
11:16:09 <monochrom> Ah, yes too.
11:16:12 <dolio> It's a paper by Conor McBride about the fake dependent typing you can do in GHC now.
11:16:14 <merijn> iqubic: The original paper on faking dependent types in Haskell was titled "hasochism" (a pun on masochism, because it's so painful to use)
11:16:33 <iqubic> Right. Isn't that just Singletons?
11:16:44 <merijn> Singletons spawned from that, yes
11:16:52 <ski> @where she
11:16:52 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
11:17:40 <merijn> iqubic: Also, a bunch of people working on dependent haskell are getting papers out of it. How will it stay maintained when there's nothing more to publish and all the phd students get jobs? :)
11:17:53 <iqubic> I don't know.
11:18:02 <monochrom> I know.
11:18:06 <Sonolin> geekosaur hmm I got an error for no Eq instance but maybe I'm just out of date or not importing a module 
11:18:18 <monochrom> Even Backpack is on the border of going bitrot now.
11:18:39 <Athas> merijn: that is probably my own worry.  GHC is already the second-most buggy compiler I interact with, and I'm worried about the maintenance resources getting stretched even thinner.
11:19:19 <aplainzetakind> How do I get cabal to v2-style build dependencies with profiling enabled in a unified way, from the .cabal or cabal.project file?
11:19:44 <Athas> aplainzetakind: I would use cabal.project.
11:19:44 <monochrom> cabal.project
11:19:47 <aplainzetakind> I added a profiling: True to the package satnza in cabal.project but that didn't seem to do anything.
11:19:53 <monochrom> or even cabal.project.local
11:20:08 <merijn> aplainzetakind: "cabal build --enable-profiling" or "cabal configure --enable-profiling"
11:20:25 <Athas> Is Backpack used for any popular library yet?  It can't be used as a hidden internal implementation detail, as I understand it.
11:20:51 <merijn> Athas: Probably not, and without ezyang pushing it, I fear it may just die
11:20:55 <monochrom> IIUC hackage doesn't play well with Backpack so you can't even upload a Backpack-using library.
11:21:32 <aplainzetakind> Failed to load interface for ‘GHC.Integer.Type’\nPerhaps you haven't installed the "p_dyn" libraries for package ‘integer-wired-in’?
11:21:34 <dolio> That doesn't sound right.
11:21:36 <Athas> Stack doesn't support Backpack at all.
11:21:44 <dolio> https://hackage.haskell.org/package/unpacked-containers
11:21:47 <monochrom> And oh of course the other feature that died after finishing a PhD is plugins.
11:21:47 <aplainzetakind> I get this with --enable-profiling
11:22:29 <monochrom> Ah OK sorry dolio, thanks.
11:23:07 <Athas> Aren't plugins used for a few things?
11:23:12 <geekosaur> aplainzetakind, you need to install ghc for profiling sd werrl, in partcular the RTS, base, and integer libraries
11:23:16 <geekosaur> *as well
11:23:34 <Athas> Plugins seem less maintenance-intensive, which is a good design principle when building thesisware.
11:23:56 <merijn> aplainzetakind: Are you using dynamic linking? I'm not sure the profiled+dynamic flavour is build by default
11:24:04 <geekosaur> my poor little laptop is linking…
11:25:01 * geekosaur suddenly wonders if that is Arch
11:25:14 <Athas> One of the great unsolved mysteries in computer science is why linking is so goddamn slow.
11:25:37 <monochrom> I think Google's gold solved it.
11:25:44 <aplainzetakind> merijn: I have no idea if I'm using dynamic linking.
11:25:56 <geekosaur> well, in my case it's because tiny 2GB laptop with chrome already running
11:26:03 <aplainzetakind> geekosaur: Do you mean I should rebuild/reinstall ghc itself?
11:26:44 <Sonolin> ah I see the Eq instance is in random 1.2... I just have to update the package
11:26:44 <merijn> aplainzetakind: distro?
11:26:54 <aplainzetakind> gentoo
11:26:56 <aplainzetakind> ghcup
11:26:58 <jonn> I think that people who want DH _do want_ DH. It's kind of like saying that people who use Scala to be productive and apply FP where it matters don't really want a JVM language. A big benefit of DH is that it's still Haskell, and that's it. 
11:27:01 <geekosaur> aplainzetakind, I sincerely doubt "rebuild" but wonder where you got your ghc. And why you are using dynamic linking, which is not the default
11:28:05 <jonn> I personally really don't get all the FUD about DH in the community, especially since work on DH helps make compiler more decoupled and more maintainable.
11:28:36 <Athas> jonn: can you elaborate on the last point?  I'm not sure what you mean by "decoupled" here?
11:28:51 <Athas> Surely DH mostly means a larger source language and a more complex type checker?
11:29:10 <aplainzetakind> (GHC version 8.8.3 for x86_64-unknown-linux) is what it says at the point of panic, for the version.
11:29:30 <aplainzetakind> I don't think the ghcup-downloaded binary would be dynamically linked, would it?
11:29:40 <monochrom> No, it isn't.
11:30:04 <jonn> Athas: there was a big refactoring last year that concerned desugaring, that made architecturally messy code in GHC less messy, I could go through commits and find examples, but you can also trust me on that because I'm too lazy.
11:30:35 <monochrom> For least confusion, if you already use ghcup, it's best to remove gentoo's GHC (or whatever linux distro it is).
11:30:56 <monochrom> If you still want to keep that, at least play with PATH to give ghcup's GHC higher priority.
11:31:04 <aplainzetakind> monochrom: I never installed a distro ghc.
11:31:18 <aplainzetakind> I set haskell stuff up via ghcup
11:31:38 <Athas> jonn: I'm not doubting you, I'm just curious.  But I'm not seeing how that is DH-related.  Is it just that DH is motivating this work?
11:31:47 <jonn> Yes
11:32:20 <aplainzetakind> `which ghc` gives me the one under ~/.ghcup
11:32:51 <jonn> DH is not only adding complexity, but also is checking the engineering of GHC, if you will. It's impossible to add that much complexity without addressing some tech debt. AFAIU, GHC is mostly awesome, to be fair.
11:34:03 <jonn> Where “awesome” means “can be non-trivially extended by people who didn't write it without many refactorings”. Some refactorings are required, but none of those are about “changing GHC s.t. it fits DH”, all of those are “changing GHC s.t. it's better”.
11:37:13 <monochrom> aplainzetakind: Some unknown thing is telling GHC or cabal-install to use dynamic linking, I don't know what, but it is certainly abnormal, on close-to-default settings the error doesn't happen.
11:38:54 <aplainzetakind> Would getting and switching to 8.10 be something meaningful to try?
11:38:59 <monochrom> But $HOME/.cabal/config is one place you want to check.
11:39:03 <monochrom> No.
11:40:54 <aplainzetakind> I searched config for 'dyn', every occurrence is on a commented-out line.
11:41:00 <aplainzetakind> What else to look for?
11:42:19 <merijn> Try "cabal user-config diff" and see if anything is non-default :)
11:43:31 <aplainzetakind> documentation: True; overwrite-policy: always :)
11:44:38 <joel135> what is DH?
11:44:44 <monochrom> dependent haskell
11:44:48 <joel135> ok
11:44:51 <sclv> aplainzetakind: https://github.com/haskell/cabal/issues/2827 ?
11:45:03 <sclv> maybe you're invoking profiling in a weird/wrong way and so hitting a weird ghc issue?
11:47:49 <aplainzetakind> sclv: Indeed. Removed -prof from ghc-options and it worked.
11:47:52 <aplainzetakind> Thanks.
12:08:18 <aplainzetakind> Can flags defined in .cabal be passed to conditionals in cabal.project*? I want to be able to toggle `profiling: True` and `ghc-options: -fprof-auto -rtsopts` with a single flag. What's the proper way to do it?
12:08:37 <incertia> so i have `class Solved (n :: Nat) where solver :: String -> Bool -> String` and i want to do type level wizardry to check if i have a solver instance for a particular problem number. in particular. i want to write dictFor :: forall (n :: Nat). (Solved 1, Solved 2, ..., KnownNat n) => Proxy n -> Maybe (Dict (Solved n))
12:08:42 <incertia> but dictFor appears hard
12:09:24 <incertia> the only way i can get it to typecheck is if i use (Solved n) in the constraint which defeats the purpose
12:10:21 <sclv> you should probably just use two different cabal.project.local files?
12:11:15 <aplainzetakind> sclv: I suppose it doesn't matter if I put ghc-options in cabal.project* or foo.cabal?
12:12:04 <dcoutts> in one case (the foo.cabal file) it is the author role, in the other it is the package builder role
12:13:11 <aplainzetakind> So I can define flags in .project* as well?
12:13:30 <dcoutts> So as the package author you think the flag should always be there, then put it in the .cabal file. If it makes sense to leave it up to the person building the package as part of some other project, let them put it in their cabal.project file.
12:13:55 <aplainzetakind> I see. Thanks.
12:13:55 <dcoutts> aplainzetakind: some things are exclusive to one or the other, some overlap. So it depends on what you're trying to specify.
12:15:25 <dminuoso> aplainzetakind: Think of .cabal configuring the package and .project* configuring your own cabal-install.
12:15:41 <dminuoso> It's a good approximation I'd say.
12:15:48 <exarkun> is there a conduit combinator like `ConduitT a b m r -> ConduitT a b m r -> ConduitT a b m r` such that the result first produces elements from the first arg and then, after it is exhausted, from the second arg?
12:16:47 <aplainzetakind> Ah it seems profiling: True makes ghc-options redundant anyway.
12:17:04 <tomjaguarpaw> exarkun: Isn't it >>?
12:17:47 <dcoutts> aplainzetakind: so profiling is a perfect example of something you want to do as the builder of a package not the author. It's not something you'd want all uses of the package to always use.
12:17:58 <exarkun> Ugh.  As in standard monad sequencing.  Sure sounds like it might be.
12:18:23 <dminuoso>     ConduitT f >>= g = ConduitT $ \h -> f $ \a -> unConduitT (g a) h
12:18:25 <dminuoso> mMM
12:19:13 <tomjaguarpaw> I'm not familiar with conduit, but that's what it is in streaming, and I think pipes.
12:19:47 <merijn> aplainzetakind: "profiling: True" is equivalent to --enable-profiling and cabal automatically append relevant profiling flags if you do that
12:21:08 <merijn> aplainzetakind: I don't quite agree with dminuoso's description, I'd say .cabal is the specification of the package as a whole, but I'd instead describe "cabal.project" as a *specific* build configuration of that package (for, say, development) and cabal.project.local as local overrides even for that
12:22:41 <merijn> aplainzetakind: So if you have a repo with 4 packages that depend on each other you can use cabal.project do have a build configuration that uses the versions from the repo (rather than released ones), with the idea that cabal.project gets committed to the repo for anyone hacking on it. And cabal.project.local lets you locally override that "persisted" build configuration for the sake of debugging, 
12:22:45 <maerwald> well, many packages these days cannot be built without cabal.project, so...
12:22:47 <merijn> profiling, or whatever else ad hoc things you wanna do
12:22:48 <maerwald> the line is blurred
12:23:18 <merijn> maerwald: In what sense?
12:23:27 <maerwald> merijn: packages and git dependencies
12:24:03 <boxscape> % (() `undefined`) `seq` ()
12:24:03 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:85:2 in interactive:Ghci49
12:24:07 <merijn> maerwald: Yes, but those generally aren't on hackage or distributed
12:24:14 <maerwald> correct
12:24:17 <boxscape> how exactly is this section desugared such that this leads to an exception?
12:24:58 <merijn> boxscape: That's just "undefined () `seq` ()"?"
12:25:06 <merijn> How would it not produce an error?
12:25:08 <boxscape> ah
12:25:17 <boxscape> merijn report defines sections as lambdas, doesn't it?
12:25:26 <merijn> boxscape: Yes, and GHC doesn't follow that
12:25:26 <boxscape> but I guess ghc doesn't do that
12:25:28 <boxscape> I see
12:25:39 <solonarv> IIRC this is actually controlled by a language extension
12:25:44 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
12:25:51 <merijn> solonarv: Nope
12:25:54 <boxscape> thanks
12:26:33 <merijn> solonarv: It's hard to find a non-artificial case where this matters, tbh
12:26:45 <geekosaur> solonarv may be thinking of PostfixOperators which further abuses how ghc implements sections
12:26:55 <solonarv> that is the one I was thinking of
12:35:36 <idnar> :t Data.Map.fromListWith (<>) . fmap (fmap Data.Set.singleton)
12:35:38 <lambdabot> (Ord k, Ord a) => [(k, a)] -> M.Map k (S.Set a)
12:51:12 <aplainzetakind> merijn: Just saw those. Thanks for the explanation.
12:57:10 <texasmynsted> merijn: nice link. I had not seen that before.
13:24:28 <monochrom> maerwald: I have found that "cabal install" honours parts of cabal.project.local and omits other parts.
13:24:45 <merijn> monochrom: That sounds like a bug
13:24:54 <monochrom> I have top-level "profiling: True", that is not honoured.
13:25:17 <monochrom> I have top-level "program-options", under it "ghc-options: -rtsopts".  That is honoured.
13:25:55 <monochrom> If I change "program-options" to "package hyde", that is not honoured. (My package name is hyde)
13:26:58 <maerwald> merijn: it isn't, because install makes an sdist and switches to temp dirs before really building
13:27:10 <maerwald> so it honors the part about dependencies
13:27:14 <maerwald> but not so much flags
13:27:36 <maerwald> which proves my point that it's not very well defined as a thing
13:27:59 <monochrom> OK, now let me test again but call it cabal.project
13:28:22 <merijn> flags aren't supposed to affect the public interface anyway (yes, I know people dumbly abuse it for this anyway)
13:30:54 <monochrom> Same result.
13:44:38 <maralorn> Can someone help me with this type error? https://termbin.com/cqxd, this is the function, but ghc does not complain about any of the pattern signatures: https://paste.linuxlounge.net/TT7A
13:46:04 <maralorn> Ah, type Mn n = M n n might be relevant, and I am using import Numeric.LinearAlgebra.Static
13:46:49 <glguy> maralorn: Do you have ScopedTypeVariables enabled?
13:46:58 <maralorn> Yes
13:47:53 <maralorn> Here is the whole file https://paste.linuxlounge.net/OS3A
13:48:24 <maralorn> Most of it typechecks beside tpsi and traceRight.
13:48:47 <maralorn> And do blame me for bad variable names, this is mathematics, we have cultivated bad variable names.
13:52:55 <maralorn> Huh, I got it to work with AllowAmbiguousTypes.
13:53:22 <maralorn> It was my impression this is a bad idea.
13:53:24 <maralorn> But it works. /o\
13:53:51 <incertia> AllowAmbiguousTypes is less bad than it sounds
13:54:41 <koz_> Yeah, it basically means 'you'll have to tell GHC what you want type-wise sometimes'.
13:54:42 <jared-w> It's kinda necessary if you want a "type-appliations driven" API with empty data types. It has other fun uses too, I believe
13:56:30 <incertia> a type is ambiguous if at the call site you cannot concretize every type variable
13:57:02 <incertia> e.g. f :: Show a => (), f = ()
13:57:15 <incertia> to use f, you just write f
13:57:24 <incertia> but GHC has no idea what type a should be
13:57:26 <incertia> hence ambiguous
13:57:46 <merijn> jared-w: TypeApplications driven API is a funny way of say "brittle API prone to breakage due to all sorts of details that most package authors consider out of PVP scope" ;)
13:58:43 <incertia> on that note im sort of hitting a wall
13:59:19 <incertia> i want to represent having solved a particular problem number as a typeclass instance and then look up the particular instance when i run a solver for all problems
13:59:57 <incertia> but i can't seem to get the constraints to work out right
14:00:32 <jared-w> merijn: as if tons of packages weren't breaking due to "out of PVP scope" semi frequently anyway :p
14:01:08 <maerwald> if you rely on PVP *today* you must be either new, or really nuts :p
14:01:09 <jared-w> hmm. Any owners of the Haskell organization on github around?
14:01:30 <incertia> e.g. suppose i have solve :: Int -> IO () whose goal is to check to see if the problem number has a Solved instance and then call that particular instance
14:01:50 <glguy> jared-w: have you checked in #haskell-infrastructure ?
14:01:51 <incertia> class Solved (n :: Nat) where solver :: String -> String
14:02:19 <jared-w> glguy: TIL there's a #haskell-infrastructure. That'd be the place to ask :)
14:02:24 <maerwald> I wouldn't even trust aeson to adhere to PVP, which is why json roundtrip tests aren't enough. Ppl should write unit tests again.
14:03:15 <merijn> maerwald: You can *use* PVP bounds without *relying* on them
14:03:26 <maerwald> that's the only thing you should do :p
14:03:58 <merijn> You can't rely on anything, maybe cosmic rays bitflipped your executable
14:04:13 <merijn> Maybe your GHC got "Reflections on Trusting Trust"-ed
14:04:47 <maralorn> Okay
14:04:54 <monochrom> Simpler: Cosmic ray flipped a version bound on Hackage.
14:05:18 <jared-w> Cosmic ray? You mean hackage revisions? /s
14:05:23 <monochrom> Even simpler: Magnetic error flipped a version bound on Hackage.
14:05:49 <maerwald> merijn: that's what makes a good programmer: being paranoid af, but managed to escape asylum :p
14:06:09 <monochrom> Sounds like Gödel.
14:06:46 <monochrom> Ironically, he might be better off inside an asylum.
14:07:01 <monochrom> because at least someone would force him to eat.
14:07:26 <maerwald> good that you reminded me. I forget that I have a body
14:08:15 <koz_> maerwald is ghost?
14:09:35 <monochrom> incertia: If you do that, you are taking a dynamically determined term-level number to a supposed-to-be-statically-known type-level number.  You will have to compromise with an existential type, which is SomeNat in GHC.TypeNats or TypeLits.
14:12:38 <monochrom> Isn't it so much simpler WLOG to KISS to a fully dynamic dictionary that just happens to be hardcoded.  solved = Map.fromList [(1, solution1), (2, solution2), ...]
14:14:02 <nfd9001> hey, so, i was using containers' Data.Graph for aoc day7, and found it somewhat lacking for that purpose: there were apparently no ways to decorate edges or vertices in a way powerful enough to help much with dealing with numbers of bags. obvs for that i could just use a simpler structure like a basic map (and i did), but i was wondering if y'all knew any richer (and maybe loosely similar) graph libs
14:14:26 <monochrom> fgl is rich
14:14:41 <monochrom> It is also counterintuitive
14:15:14 <monochrom> I don't think anyone has published a different take.
14:15:33 <nfd9001> hehe, say what you will about Data.Graph, it's *very* intuitive
14:15:33 <dminuoso> A coproduct is to choice as product is to ___?
14:15:58 <nfd9001> ~~cochoice~~
14:16:01 <dminuoso> haha
14:16:04 <nfd9001> sorry :D
14:16:13 <monochrom> It is not counterintutive if you stick to its pre-canned graph algorithms eg bfs dfs sp (single-source shortest path).
14:16:14 <dminuoso> That was a good one. :)
14:16:45 <dminuoso> It seems there's a lacking clear term for cochoice. Perhaps "combination"?
14:17:05 <monochrom> But if you try to use its "fold" to write your own algorithms, you have to learn a new concept.
14:17:31 <monochrom> fgl ≠ Data.Graph
14:18:02 <nfd9001> coproduct is a sum type is a choice is a union, a product is a product type is a tuple is a struct 
14:18:17 <dminuoso> I mean this also shows in profunctor terminology
14:18:31 <incertia> monochrom: that's what i currently do but it's so much cooler to just be like "i'll just import an instance and have the code be automatically generated"
14:18:31 <dminuoso> Where you have Choice and Strong (ugh)
14:19:01 <dminuoso> nfd9001: Im just looking for intuitive terms that would explain this to say a non-programmer.
14:19:20 <dminuoso> Say if I was to explain the two dimensions of ADTs, I could explain sum types as encoding a choice
14:19:34 <nfd9001> i mean, cochoice is a little intuitive. what's the opposite of choosing between pie and ice cream? ala mode
14:20:00 <monochrom> dminuoso, I have two joking ideas.  1. hice (= choice - co).  2. prochoice.
14:20:00 <dminuoso> I dont know about "opposite of choosing" - the duality stems from a categorical point of view
14:20:30 <nfd9001> choosing-with-the-arrows-backwards
14:20:45 <monochrom> opposite of choosing is forcing
14:21:06 <dminuoso> monochrom: I guess that gets into the right area.
14:21:12 <dminuoso> You're forced to pick two things.
14:21:19 <dminuoso> As opposed to chosing between them.
14:21:49 <monochrom> I think of a two-person game, and sometimes the opponent forces their choice on you.
14:21:53 <dminuoso> Interesting that neither English nor German seems to have a good verb here
14:22:15 <monochrom> inflict
14:22:27 <monochrom> Is math discovered or inflicted? :)
14:22:31 <nfd9001> zugzwang or whatever that chess term was, huh
14:23:49 <monochrom> Cocartes says: Coproduct ergo sum.
14:23:59 <nfd9001> nice.
14:46:04 <iqubic> :t fmap :: (((a -> b) -> b) -> c -> a)
14:46:06 <lambdabot> error:
14:46:06 <lambdabot>     • Couldn't match type ‘c1’ with ‘f0 (a1 -> b1)’
14:46:06 <lambdabot>       ‘c1’ is a rigid type variable bound by
14:46:41 <iqubic> :t fmap :: (a -> b) -> b
14:46:43 <lambdabot> error:
14:46:43 <lambdabot>     • Occurs check: cannot construct the infinite type:
14:46:43 <lambdabot>         b1 ~ f0 a1 -> f0 b1
15:13:53 <isovector1> is there some way i can make uniplate work with mutually recursive data types?
15:17:08 <Axman6> what issues do you run into?
15:18:42 <isovector1> `rewrite` doesn't go inside the mutual recursion
15:19:55 <isovector1> eg if i write `data Foo = In | Out | Loop Bar` and `data Bar = BackToFoo Foo`, `rewrite $ \case {In -> Just Out: _ -> Nothing}` won't rewrite `Loop (BackToFoo (In))`
15:21:19 <isovector1> at least not using the `generic-deriving` uniplate instances
15:52:29 <Kronic> I have a very small question relating to how to read values that parameterize type declarations, when I read something like the basic definition for the state monad, how intertwined are the two s parameters?
15:52:46 <Kronic> My understanding is that unless I use a RankNType they must be the same type and structure
15:53:50 <sm[m]> I think https://github.com/Homebrew/linuxbrew-core/blob/master/Formula/ghc.rb should depend on gcc-6+. Would anyone have an idea how ?
15:57:58 <monochrom> Kronic: I don't understand "intertwine" but I'm pretty sure it's barking up the wrong tree.  "s -> (a, s)" is just saying you could make it Int -> (String, Int) (s=Int, a=String), or Char -> (Bool, Char) (s=Char, a=Bool), or other choices.
15:58:11 <monochrom> If you understand Int->(String,Int) then you understand s->(a,s).
16:00:15 <Kronic> monochrom: Ah, my bad. Let me be clearer in that case. The definitions are read left to right, so if I at some point on the left side bind a parameter to some type, must it be taken that this parameter is always the same unless I use forall ? 
16:02:15 <monochrom> yes
16:02:47 <monochrom> I wonder if you just haven't thought along the line of http://www.vex.net/~trebla/haskell/prerequisite.xhtml#substitution
16:02:50 <Kronic> Okay perfect, thank you. I just wanted to be sure. I recently returned to Haskell, and sometimes I trip over myself a little when reading documentation 
16:11:40 <Unicorn_Princess> suppose I'm using Data.MultiSet, and I'm not happy how its findMin function doesn't return a Maybe (so it can crash on an empty Set). so I write my own safe version, minSafe. in what module should I put this function, for organization? I can't put it into Data.MultiSet... can I?
16:15:16 <Axman6> Is there a package that provides lenses of a haskell AST, like haskell-src-exts or GHC's?
16:15:32 <Axman6> also, anyone know the status of trees that grow in GHC/TH/HSE?
16:16:32 <koz_> Unicorn_Princess: You can put it in Data.MultiSet.Safe?
16:16:39 <koz_> Since it's like, a local module?
16:17:51 <Unicorn_Princess> i guess that's the standard. like how the extra package puts stuff into Data.List.Extra... 
16:18:42 <Kronic> monochrom, thanks for the link, it was a little bit on the longwinded side but it more than explained my question. Cheers
17:35:17 <pavonia> So functional programming finally made it, eh? ;)  https://techcommunity.microsoft.com/t5/excel-blog/announcing-lambda-turn-excel-formulas-into-custom-functions/ba-p/1925546
17:46:07 <blissful> friendship with haskell ended, microsoFT EXCEL is my new best friend!!!
18:28:54 <dsal> This seems pretty weird:   `import Data.Monoid (<$>)`
18:40:17 <cheater> (ot) does anyone know how to search for stuff with ripgrep, but exclude very long lines? or search for a string, but exclude results that contain a specific other string?
18:41:48 <Axman6> riptreg foo | grep - v bar?
19:22:10 <incertia> @monochrom: ok so i did a cheaty solution by just using TH to examine the instances of a typeclass and then autogenning a HashMap: https://gist.github.com/incertia/9100eec4262fde6373d4c5a13fa1ac04
19:22:10 <lambdabot> Unknown command, try @list
19:23:56 <incertia> the only downside is that i have to import the module every time i solve a new problem
19:41:51 <incertia> i don't suppose you can use TH to import additional modules
20:00:53 <jle`> i learned TH for that purpose actually initially :)
20:10:11 <ezzieyguywuf> of the solutions offered on the SO thread, this last one seems to make the most sense to me. But I'm wondering why it's the least upvoted. any thoughts? https://stackoverflow.com/a/51740646
20:12:29 <jle`> it has a lot of moving parts, maybe
20:13:11 <ezzieyguywuf> I'm not saying I don't like the accepted answer, but it too seems a bit roundabout and convoluted
20:13:47 <ezzieyguywuf> especially considering that in other languages this would be trivial with something like "do while"
20:14:30 <ezzieyguywuf> does the functional programming style not lend itself to these sorts of problems? or rather, should the problem perhaps be reframed into somethnig that is better suited to the functional approach?
20:15:47 <jle`> i think the problem as stated is fine in a functional context
20:16:02 <jle`> the accepted answer is pretty functional, it's "look at the cumulative sums, and find the first or last one that matches"
20:16:15 <jle`> which is essentially what a for while loop does
20:16:43 <jle`> computes cumulative sums and breaks as soon as it reaches a condition
20:17:04 <jle`> in this case, scanl' (+) is the cumulative summer, and takeWhile/dropWhile is the condition checker
20:17:07 <ezzieyguywuf> i guess in either approach, an infinite loop is an inherent possibility
20:17:27 <jle`> sure, it's inherent. and sort of obvious in the list approach
20:17:34 <jle`> maybe the for loop approach obscures that a little more
20:17:56 <ezzieyguywuf> i think the for-loop approach is probably easier to understand and reason about though
20:18:12 <ezzieyguywuf> but maybe that's just my imperitive background kicking in
20:18:34 <ezzieyguywuf> should they have used scanl' rather than scanl?
20:18:42 <ezzieyguywuf> something akin to foldl' vs foldl?
20:18:58 <ezzieyguywuf> oh wait, they used scanl1, whatever that is..
20:19:09 <jle`> hm, idk, the "search the cumulative sums until you find what you are looking for" seems pretty intuitive to me
20:19:31 <jle`> maybe more or as intuitive than "allocate this state and mutate this variable and check it every time and stop mutating"
20:19:45 <jle`> but yeah, it's sort of a matter of experience and background maybe
20:20:35 <jle`> the first one is just "your answer is in the list, just do a simple search with a predicate" and the second is "manipulate the memory of your computer to conjure an answer"
20:20:50 <jle`> admittedly using head and dropWhile isn't the cleanest way to express it i think
20:20:53 <jle`> maybe i'd use 'find'
20:21:58 <jle`> % find (>= 1000) (scanl' (+) 0 [1..])
20:21:58 <yahb> jle`: Just 1035
20:22:13 <jle`> "in the cumulative sums starting from 1, find the first value greater than 1000
20:22:21 <ezzieyguywuf> I think perhaps the part that is most jarring to me is that in the accepted answer, the way I reason or parse it is more or less as you've described it "FIRST make a list, THEN check each value in the list, THEN take the first one", and though I eventually also add "(oh by the way, due to laziness this isn't wasteful)" my initial thought is "but why process the whole list if you don't have to!"
20:22:37 <jle`> or maybe in a more declarative sense, "your answer is the first item in the cumulative sums that is greater than 1000"
20:22:41 <ezzieyguywuf> and in the imperitive approach it is made obvious that the list is only process as far as it needs to be.
20:23:03 <jle`> i think maybe you are thinking of the list as a container of values
20:23:14 <ezzieyguywuf> jle`: that is how I am thinking of the list
20:23:22 <jle`> instead of like as an iterator or streamer/control flow
20:23:39 <jle`> scanl' (+) [1..] isn't a container of values
20:23:48 <ezzieyguywuf> yea, I guess I could stand to improve my mental image of "lists" in haskell
20:23:50 <jle`> it's a stream of cumulative sums from 1
20:24:22 <ezzieyguywuf> I remember something from Learn You a Haskell about permutations or something (related to the monad instance for lists I believe) that started to bring me down that path, but then I went on to something else
20:26:00 <ezzieyguywuf> jle`: I like your description, specifically the word "stream"
20:26:00 <jle`> yeah, when i see scanl' (+) [1..], i don't see an infinite container, i see a stream i can search or iterate through, mathematically, in a way
20:26:14 <jle`> lists in haskell are most closely releated to for loops in other languages
20:26:42 <jle`> it's actually usually almost directly translatable
20:27:02 <koz_> We even have
20:27:06 <koz_> :t forM
20:27:08 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
20:27:13 <koz_> Look at that, a loop!
20:27:13 <jle`> aka, `for` :)
20:27:22 <koz_> :t for
20:27:24 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
20:27:28 <koz_> Look at that, also a loop!
20:27:31 <jle`> % for [1..10] \i -> print i
20:27:31 <yahb> jle`: ; <interactive>:97:13: error:; Unexpected lambda expression in function application:; \ i -> print i; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
20:27:40 <jle`> % :set -XBlockArguments
20:27:40 <yahb> jle`: 
20:27:42 <jle`> % for [1..10] \i -> print i
20:27:43 <yahb> jle`: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; [(),(),(),(),(),(),(),(),(),()]
20:27:51 <jle`> whoops, should have dropped the results. but yeah
20:27:52 <koz_> jle`: for_ maybe?
20:27:58 <jle`> mhm
20:28:06 <koz_> % for_ [1..10] print
20:28:07 <yahb> koz_: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
20:28:31 <koz_> (although I typically spell that 'traverse_ print [1..10]')
20:30:13 <ezzieyguywuf> can someone show me a simple example using that `for`?
20:30:39 <jle`> % for_ [1..10] (\i -> print i)
20:30:39 <yahb> jle`: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
20:30:42 <koz_> ezzieyguywuf: We just did.
20:30:47 <jle`> oh, do you mean for and not for_
20:31:10 <koz_> 'for' usually means you care about the result.
20:31:24 <koz_> (not just the effects)
20:32:02 <ezzieyguywuf> lol whoops, my eyes glazed over when I saw the %
20:32:11 <ezzieyguywuf> and the errors
20:33:00 <Squarism> Scala library had a pretty neat feature where you could strip all text before and including "|" in multiline strings. Is there something similar in Data.Text or Data.ByteString?
20:33:12 <Squarism> (per line that is)
20:33:33 <koz_> Squarism: No, not that I know of. You can do whitespace stripping, but not |-removal, at least not without writing it yourself.
20:33:35 <jle`> no :'( but some heredoc quasiquoters have that i think
20:34:23 <Squarism> ah, ok
20:34:43 <dolio> > "like \             \this?"
20:34:45 <lambdabot>  "like this?"
20:37:12 <ezzieyguywuf> hrm, in ghci, `val = for [1..(10 :: Int)] (+ (1 :: Int))` gives me an error
20:37:25 <ezzieyguywuf> val = for [1..(10 :: Int)] (+ (1 :: Int))
20:37:27 <ezzieyguywuf> I don't understand though
20:37:28 <Squarism> dolio, oh that might work then
20:37:45 <koz_> > for [1 .. (10 :: Int)] (+ (1 :: Int))
20:37:48 <lambdabot>  error:
20:37:48 <lambdabot>      • Couldn't match type ‘Int’ with ‘f b’
20:37:48 <lambdabot>        Expected type: Int -> f b
20:38:00 <koz_> That's because + 1 has the wrong type.
20:38:03 <koz_> :t for
20:38:04 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
20:38:11 <jle`> ezzieyguywuf: check the types, yeah, you probably want 'map' and not 'for'
20:38:14 <koz_> See how the function has to be of type (a -> f b)?
20:38:21 <ezzieyguywuf> so how come without the type annotations I get no error?
20:38:23 <koz_> The whole point of 'for' is that you have some effect.
20:38:31 <seasonal-staff> Lua has an interesting alternative to Haskell's \ \ string gaps. the \z escape eats whitespace up to the first non-whitespace
20:38:36 <koz_> If you don't need any effects, just use map.
20:38:37 <ezzieyguywuf> hm, I see
20:38:40 <koz_> (or fmap really)
20:40:12 <ezzieyguywuf> I have a `[Parsec e s a]` and I want to run this function until one returns a Right, so it sounds like `for` is the tool for the job yea? https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec.html#v:runParser
20:40:29 <ezzieyguywuf> but also, the way the arguments are arranged that's going to be tough...
20:40:43 <koz_> ezzieyguywuf: [Parsec e s a] isn't a 'function'.
20:40:54 <koz_> Like, I assume you wanna try each in order until one of them works?
20:41:17 <ezzieyguywuf> koz_: yea, [Parsec e s a] is akin to the [1..10] above, the functio I want to use is runParser
20:41:34 <koz_> Yeah, that... wouldn't do what you think it does.
20:41:39 <koz_> Imagine you have five parsers.
20:41:45 <koz_> The first one eats half your input then fails.
20:41:46 <koz_> What do then?
20:41:48 <ezzieyguywuf> but I guess I'll have to write my own intermediate `runParser' :: String -> s -> Parsec e s a`
20:41:56 <ezzieyguywuf> koz_: doh!
20:41:57 <Squarism> dolio, hmm somehow that didnt work well. Does OverloadedStrings interfere with it? 
20:42:18 <ezzieyguywuf> ahh you know what, megaparsec has a thing for this
20:42:20 <ezzieyguywuf> `choice`
20:42:33 <koz_> Yeah, 'choice' works, but you have to be careful about the input-eating thing.
20:42:38 <dolio> I doubt it.
20:42:48 <dolio> Can you paste what you entered?
20:43:01 <koz_> Namely, you wanna make sure your parsers are backtracking unless you actually _want_ the 'eat half your input' behaviour.
20:43:05 <ezzieyguywuf> koz_: I think choice takes care of that, but I'll check.
20:43:18 <jle`> choice for megaparsec isn't backtracking
20:43:19 <koz_> ezzieyguywuf: 'choice' in Megaparsec doesn't automagically backtrack AFAIK.
20:43:21 <ezzieyguywuf> this is also why I was asking about "where does `choice` come from" the other day...
20:43:35 <iqubic> I usually do "choice $ map try [parsers]" to force backtracking.
20:43:38 <ezzieyguywuf> oh snap. maybe I'll have to tack a `try` or w/e in front of each parser then
20:43:46 <ezzieyguywuf> yea, what iqubic said
20:43:51 <seasonal-staff> ideally you're refactored your grammar so that you don't need so many try though
20:43:54 <koz_> Yeah, that works, but it's a _very_ brute force approach.
20:44:06 <iqubic> I suppose it is.
20:44:13 <koz_> It's better to consider how much backtracking you really need - it's often less than you think.
20:44:13 <seasonal-staff> with parser combinators you're the parser compiler!
20:44:14 <dsal> is choice just asum?
20:44:20 <seasonal-staff> yeah
20:44:20 <koz_> dsal: Yeah, I think so?
20:44:23 <ezzieyguywuf> seasonal-staff: bleh, it's not like that, the parser is configurable at runtime via a configuration file so....
20:44:57 <seasonal-staff> If you're exposing the parser combinators to your users, then your users are the parser compilers
20:45:14 <koz_> seasonal-staff: In Soviet Russia, you compile parsers, I guess.
20:45:46 <ezzieyguywuf> seasonal-staff: indeed
20:55:28 <nshepperd2> i'm writing a type level parser combinator library
20:56:10 <nshepperd2> it's an adventure
20:56:16 <iqubic> That sounds both super useful, and super hard.
20:56:45 <Axman6> the lack of yupe level uncons for symvols most make that a lot of fun
20:58:09 <jle`> nshepperd2: oh, i wrote one at one point
20:58:39 <jle`> nshepperd2: https://github.com/mstksg/typelits-printf/blob/master/src/GHC/TypeLits/Printf/Internal/Parser.hs
20:59:42 <iqubic> Is there really no better way to get isAlpha to work?
21:00:35 <nshepperd2> oh, nice
21:07:51 <M1CK4L13N5> helo
21:08:16 <M1CK4L13N5> anybody room ?
21:08:27 <Axman6> most of us are human :)
21:08:52 <M1CK4L13N5> helo man
21:09:09 <Axman6> Hello
21:09:36 <M1CK4L13N5> where do you come from ?
21:09:42 <Axman6> The internet
21:09:48 <Axman6> Do you have a question aboutHaskell?
21:09:51 <M1CK4L13N5> same as me h3h3
21:09:52 <Axman6> about Haskell*
21:10:25 <M1CK4L13N5> what is this room ?
21:10:36 <suzu_> this is for discussion about the Haskell programming language
21:10:41 <Axman6> it's about the Haskell programming language. use /topic to find out more
21:10:59 <M1CK4L13N5> ouh okay thanks
21:11:58 <Axman6> jle`: is there a Symbol -> [SChar] in there?
21:12:26 <Axman6> Csongor Kiss did some crazy stuff to do that, I'm sure you've seen it
21:15:41 <jle`> Axman6: yeah, i'm using their library :)
21:17:16 <Axman6> So I wrote a thing, and I don't know what tyo do with it (possibly making it publicly available is a bad idea... but no one would trust the security of any system to randonm code found on GitHub right???) https://github.com/axman6/Curve25519
21:19:09 <iqubic> Do I have to import anything in order to get generic lenses to work for me?
21:20:47 <Axman6> are you getting errors?
21:22:24 <iqubic> I figured it out.
21:46:44 <koz_> Look at Axman6, all about dem curves.
21:53:07 <suzu_> o boi
23:38:54 <incertia> does the order in which i runState and runExcept matter
23:39:01 <incertia> in terms of result
23:40:01 <incertia> i know they end up returning different things but does anything funky happen with the state
23:49:24 <incertia> i *think* StateT s (ExceptT e m) a rolls back errors and that's a side effect of how bind and lift interact?
23:52:22 <opqdonut> @unmtl StateT s (ExceptT e m) a
23:52:23 <lambdabot> s -> ExceptT e m (a, s)
23:52:24 <Ferdirand> i think it's clearer if you expand the types of the transformers
23:52:32 <Ferdirand> ah, voila
23:52:37 <opqdonut> from the unmtl'd type you can clearly see that if there's an error there's no new state
23:52:56 <opqdonut> hmm oh unmtl doesn't support ExceptT...
23:53:09 <opqdonut> well it's basically `s -> Either e (m (a,s))`
23:53:26 <incertia> @unmtl StateT s (ErrorT e m) a
23:53:26 <lambdabot> s -> m (Either e (a, s))
23:53:39 <opqdonut> right, that's better, and I got the place of the m wrong
23:54:09 <opqdonut> @unmtl ErrorT e (StateT s m) a
23:54:09 <lambdabot> s -> m (Either e a, s)
23:54:11 <incertia> makes sense
23:54:23 <opqdonut> that's the monad you want if errors shouldn't roll back state
23:54:24 <koz_> So yeah, it does matter a great deal.
