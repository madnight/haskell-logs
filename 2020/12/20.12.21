00:03:16 <siraben> Can I use view patterns inside of a pattern match?
00:03:21 <siraben> `foo ((ans,[s] -> S.elems), constraints, solset)`
00:03:36 <kuribas> siraben: yes AFAIK
00:03:42 <siraben> Oops, `foo ((ans,S.elems -> [s]), constraints, solset)`
00:14:18 <shad0w_> also. is cabal 3.4 stable now ?
00:14:29 <shad0w_> i can only see binary downloads till 3.2
00:14:37 <shad0w_> which was from april this year
00:21:07 <kuribas> what would be more sensible for my database language, to make query functions like haskell, or like SQL?
00:21:17 <kuribas> for example: sign vs signum_
00:21:29 <kuribas> concat vs .++
00:24:58 <kuribas> hmm, I think I'll go for haskell ...
00:33:03 <kuribas> is it bad style to make a Num class for some applicative?  Like instance Num n => Applicative (MyType n) where (+) = liftA2 (+)
00:36:48 <pavonia> What data type would you use for a function that returns a record (struct), but where the exact number of fields is determined dynamically?
00:37:42 <kuribas> pavonia: HashMap?
00:37:49 <kuribas> pavonia: are the fields known?
00:38:01 <kuribas> then you could use a Record with Maybe fields.
00:38:52 <pavonia> They are known, but they may not have a value even if present
00:39:03 <kuribas> then make those fields Maybe
00:39:56 <pavonia> But with a record how do I distinguish between non-present fields then?
00:40:21 <kuribas> you could make a newtype Present a = Present (Maybe a)
00:40:57 * Uniaika was about to suggest nested Maybes :^)
00:41:15 <pavonia> kuribas: Ah, good idea
00:41:41 <Uniaika> (but an Either AbsenceReason Value works too, with AbsenceReason = AbsentValue | AbsentField)
00:42:39 <kuribas> with the nested maybes you can "traverse" over them
00:44:11 <Uniaika> sure, but then you lose a bit of meaning
00:45:06 <kuribas> hence why I suggested a newtype.
00:46:12 <kuribas> but course you need to look at the usecase to see which pattern fits best.
00:48:52 * hackage massiv 0.5.9.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.5.9.0 (lehins)
00:52:22 * hackage massiv-test 0.1.6 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.6 (lehins)
01:29:22 * hackage rob 0.0.5 - Simple projects generator  https://hackage.haskell.org/package/rob-0.0.5 (gianlucaguarini)
02:30:49 <ADG1089__> does anyone know how to solve this problem - Could not find module ‘Control.Monad’;There are files missing in the ‘base-4.14.1.0’ package,;try running 'ghc-pkg check'.;Use -v (or `:set -v` in ghci) to see a list of the files searched for.typecheck
02:31:35 <ADG1089__> I don't know what (pacman/stack/cabal/ghcuo) to install what (ghc/hlint/xmonad/xmonad-contrib/haskell-language-server)...
02:31:54 <merijn> ADG1089__: Are you on Arch?
02:32:31 <ADG1089__> yes
02:33:06 <merijn> ADG1089__: Arch's package manager (intentionally) installs a broken GHC, that error is the other tools tripping over Arch's broken install
02:33:33 <merijn> See the Arch wiki, although I would personally recommend just not using any of Arch's Haskell packages
02:33:35 <ADG1089__> yeah i don't want 8.10.x, i instead want LTS or 8.8.4 ghc
02:35:12 <merijn> Not sure how to make haskell-language-server play nice with stack, you might wanna ask in haskell-ide-engine
02:35:15 <merijn> eh
02:35:18 <merijn> #haskell-ide-engine
02:35:40 <merijn> ADG1089__: Basically, GHC (by default) links statically, but the Arch package doesn't install the static libraries
02:36:35 <merijn> ADG1089__: The "Could not find module ‘Control.Monad’;There are files missing in the ‘base-4.14.1.0’" is triggered by GHC trying to use it's own library and finding the static versions missing, so whatever you're using is trying to use your system GHC installed via Arch
02:37:12 <ADG1089__> yeah vim uses correct ghc
02:37:15 <ADG1089__> but not vscode
02:37:32 <ADG1089__> i remove all pacman haskell stuff and using ghcup and cabal
02:40:03 <yushyin> ADG1089__: installing/using xmonad with cabal v2- is not that obvious, here is a nice little example by hvr https://github.com/xmonad/xmonad/issues/199#issuecomment-609433196
02:48:24 <ADG1089__> generating package-env is done through cabal-env, right?
02:52:27 <yushyin> no? dunno? You just need cabal install --lib --package-env=NAME|PATH somepackageA somepackageB
02:53:57 <yushyin> from the link above `cabal install -z --lib --package-env=$HOME/.xmonad/ xmonad xmonad-contrib'
02:54:39 <ADG1089__> yeah i though it was next command, stupid me
02:54:49 <ADG1089__> to activate it or something
03:04:56 <ADG1089__> thanks, it works great now
03:06:07 <yushyin> ADG1089__: no problem!
03:09:15 <merijn> Any people with more lens insight that can help me figure out how the hell I get a "Getting" out of "ALens'" here? https://hackage.haskell.org/package/Cabal-3.2.1.0/docs/Distribution-Compat-Lens.html#t:ALens-39-
03:09:55 <merijn> oh, wait, I just need aview >.>
03:25:05 <ville> howdy, what's the overall opinion on https://haskell.mooc.fi/material/ ? reasonable way to start or better look elsewhere?
03:28:33 <merijn> Never heard of it, but at quick glance it seems...a bit minimal? It only talks about IO in the last lecture and then glosses over tons off stuff about it...
03:30:41 <merijn> ville: The "usual suspects" for introductions (in no particular order, since I haven't read any of them :p) are: "Thinking Functionally With Haskell" by Richard Bird, "Programming in Haskell" by Graham Hutton, and "Haskell From First Principles" (http://haskellbook.com/) and the CIS194 course: https://www.seas.upenn.edu/~cis194/spring13/
03:31:11 <Franciman> Hi ville, long time no see, since #c++ days, can I suggest learn you a haskell for great good?
03:31:25 <Franciman> http://learnyouahaskell.com/
03:31:26 <merijn> Franciman: tbh, Learn You a Haskell is...not great
03:31:36 <Franciman> uh really?
03:31:40 <merijn> It's easy reading and shows off some cool things
03:31:40 <Franciman> I loved it, ok then :P
03:31:49 <merijn> Franciman: I'm not saying it's not fun to read
03:32:03 <merijn> It's just not really good at leaving you prepared to *write* code
03:32:39 <tdammers> the problem with LYAH is that it takes a bit too much liberty with facts
03:32:51 <merijn> Franciman: I liked reading it too, because there was nothing else at the time, but I've also seen lots of beginners struggle after finishing it, unable to really write anything
03:33:21 <merijn> tdammers: That, and glossing over some important details, and lacking exercises
03:33:26 <tdammers> it does that with all the best didactic intentions, but experience shows that this liberty often leads to incorrect assumptions on the learner's side, and unlearning those assumptions can make the learning process harder than it needs to be later
03:33:38 <Franciman> I see
03:33:40 <Franciman> how about real world haskell?
03:33:47 <Franciman> maybe it's a bit outdated
03:33:53 <kuribas> real world haskell is great but outdated
03:33:56 <merijn> Franciman: Basically, LYAH is good for getting people an idea about why Haskell is cool and getting them hyped up, not so much for learning :)
03:34:15 <tdammers> frankly, I've never found the lack of exercises a problem in any learning materials
03:34:20 <kuribas> merijn: that's already something :)
03:34:24 <merijn> kuribas: Sure
03:34:29 <Franciman> I still remember the cool explaination of Zipper
03:34:30 <Franciman> :')
03:34:32 <tdammers> in fact, I pretty much always ignore the exercises
03:34:35 <merijn> But it makes me hesitant to recommend it :)
03:34:38 <tdammers> but maybe that's just how I learn
03:34:50 <Franciman> I guess you have a point merijn 
03:35:04 <merijn> tdammers: Same, but experience TAing Ocaml has taught me exercises are crucial for at least a 3rd of students
03:37:43 <sgibber2018> Takes a bit of both for me. 
03:39:21 <tdammers> merijn: that 1/3 is undeserving! HAH!
03:39:35 <Franciman> I think exercises are good for people that are not extremely interested
03:39:47 <Franciman> because reading carefully takes time
03:39:52 <kuribas> I think exercises are good for everyone :)
03:39:55 <tdammers> on a more serious note though, learning because you want to learn and learning because you want to pass an exam are of course two completely different things
03:39:58 <sgibber2018> Haskell is such a nuanced language that it's really easy to read something about it and *think* you understand it until you get some practical experience in
03:40:11 <ville> merijn: ok i'll give those a look
03:40:19 <ville> Franciman: thanks. i'll give that a look as well
03:40:19 <tdammers> sgibber2018: the trick is to proceed to "practical experience" immediately
03:40:38 <sgibber2018> Franciman: That's really not fair. You can be extremely interested in something and a very careful reader and still miss the point unless you do the exercises
03:40:49 <Franciman> sgibber2018, nono, I didn't mean that it's not useful for others
03:40:51 <tdammers> read chapter -> form mental model -> tinker -> revise mental model -> repeat
03:40:56 <Franciman> I said that it's cool for getting people hooked
03:41:53 <sgibber2018> tdammers: That's definitely the way to go
03:42:38 <Franciman> I didn't mean at all that exercises are for stupids or something :P, just that I find they get some people hooked more easily
03:42:48 <sgibber2018> Ah that makes sense
03:45:42 <tdammers> also, one of my favorite Haskell learning "books" is Write Yourself A Scheme, and that one is near 100% exercises in a way
03:46:49 <sgibber2018> tdammers: That sounds pretty tempting
03:47:45 <Franciman> I suggest writing a caml, instead of a Scheme
03:47:47 <Franciman> that's cool
03:47:57 <Franciman> and you can add types
03:48:23 <Franciman> and you have something somewhat similar to haskell, just less advanced
03:49:09 <Franciman> the final exercise is to fork the community with a new language :P
03:49:14 <tdammers> Franciman: that's not the point though. the book doesn't try to teach implementing schemes, it uses implementing a scheme as a vehicle for teaching haskell
03:49:39 <tdammers> and scheme is a better candidate for that exactly *because* you don't need to make a type checker
03:50:34 <Franciman> hm, I thought one would be interested in implementing a language too
03:50:53 <Franciman> I found it cool to implement something similar to haskell
03:51:05 <Franciman> ofc if it's for learning haskell, it's not the point
03:51:49 <Franciman> but you can learn haskell also by implementing an untyped lambda calculus with some sugar, i.e. an ML, and if yo uare interested in implementing more, you can add stuff
03:51:53 <Franciman> or stop
03:52:06 <tdammers> stephen diehl made a start with a "write yourself a haskell" thing
03:52:25 <tdammers> http://dev.stephendiehl.com/fun/
03:52:29 <Franciman> probably you may argue that the whole point of ML is having types
03:52:34 <Franciman> then ok
03:53:00 <kuribas> is having *type inference*
03:53:16 <kuribas> and ADTs
03:53:31 <ephemient> SML has less sugar than Caml so is a bit easier as a first project IMO
03:54:17 <Franciman> agreed
03:55:28 <sgibber2018> I've found the exercises where you do things like re-implement List or other basic language features to be pretty helpful.
03:55:43 <sgibber2018> Gives context to ideas
04:20:37 <gentauro> 12:51 < tdammers> stephen diehl made a start with a "write yourself a haskell" thing
04:20:56 <gentauro> his nano parsec is really helpfull to get a grasp of parser combinators in Haskell
04:23:34 <gentauro> tdammers: btw, didn't Diehl get a bit of heat cos he stated his opinion about BlockChains?
04:23:45 <merijn> Define "heat"
04:24:04 <gentauro> merijn: like people got a mad and stuff
04:24:12 <merijn> Lots of people think cryptocurrencies are just ponzi schemes for tech people
04:24:21 <gentauro> merijn: I'm one :)
04:24:34 <merijn> Well, yes, people at the top of pyramid/ponzi schemes tend to get mad when you point that out...
04:25:30 <gentauro> but since it's those companies that sponsor most of the current Haskell development, I hope they don't have any consecuences for Diehl. He has some really nice stuff :)
04:25:43 <gentauro> they = it
04:26:16 <merijn> tbh, those companies don't sponsor nearly as much Haskell development as your comment implies :p
04:27:42 <gentauro> merijn: arent' they "buying" ressources from FP Complete, Tweag.IO and WellTyped?
04:27:46 <gentauro> that's about it xD
04:28:29 <gentauro> as I understood from Marlow, FB and M$ pay for one (or two) Well-Typed consultants to work on GHC
04:28:46 <gentauro> the rest is the Block Chains companies :D (mostly IOHk0
04:28:51 <gentauro> IOHK)
04:38:00 * Lycurgus .oO( can they say 'ethically challenged'? )
04:39:28 <Lycurgus> a mlm was paying me a decent monthly retainer a couple of years ago but I had to bail because that's actually evil
04:40:29 <tdammers> I'm not going to go into much detail, but well-typed has more customers than GHC and blockchain
04:41:08 <Lycurgus> is that the 'good shop"?
04:41:37 <tdammers> define 'good'
04:41:43 <Lycurgus> i know one of em had some reasonable claim and/or pretense to being a professional assoc
04:42:17 <Lycurgus> not wage slavers or people that do nothing but lie to get money is a good start
04:42:35 <tdammers> speaking as a WT employee/consultant, I can say that business is conducted in an orderly fashion, and it's the best job I've ever had by a fair margin
04:42:58 <tdammers> if working at WT is wage slavery, then everything is
04:43:13 <Lycurgus> the term employee is noted
04:43:41 <Lycurgus> even the dam wallmark has associates
04:43:47 <Lycurgus> *damn
04:48:31 <tdammers> we use the term "employees" loosely
04:48:47 <tdammers> some of us are legally employees, others are not. personal choice.
04:49:39 <tdammers> I went with "employee" solely because I don't want to deal with the bureaucratic nonsense that comes with being self-employed in NL
04:52:13 <Lycurgus> as opposed to where?
04:53:24 <Lycurgus> monaco maybe
04:58:23 <Lycurgus> in the capitalism, whether as an economic system or a social order, ur swimmin' with sharks
05:55:42 <zzz> where's haskell in terms of automatic parallelism?
05:55:57 <merijn> Same place as everything related to auto-parallelism
05:55:59 <merijn> Nowhere
05:56:04 <zzz> :(
05:56:14 <exarkun> merijn: what about AVX
05:56:43 <exarkun> wait that wasn't why I focused this channel
05:56:43 <merijn> exarkun: GHC has some SIMD primitives, but auto-vectorisation isn't in there yet, afaik?
05:57:07 <exarkun> with Network.TLS where does the client certificate go?  in `sharedCredentials`?
05:57:22 * hackage yesod-auth-oauth2 0.6.1.7 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.6.1.7 (PatrickBrisbin)
05:59:10 <exarkun> oh oh, you return it from `onCertificateRequest`, maybe?
06:03:33 <Mac60> Hi! Could somebody pls point me to some example code or explain how to combine different monads? Say I have a chain of maybes but need to return something in an IO? Do I need monad transformation for it? 
06:07:33 <tdammers> Mac60: this isn't very specific to Monads, really. you can use the Maybe monad instance to chain a bunch of Maybes, and then use return from the IO monad instance to convert such a Maybe a into an IO (Maybe a)
06:07:55 <tdammers> Mac60: what *is* monad-specific to an extent is combining the *effects* that various monads represent
06:08:12 <tdammers> Mac60: for that, the classical approach would be monad transformers, e.g. you could use MaybeT over IO
06:08:22 <Mac60> I understand. 
06:09:00 <Mac60> I am just learning how to use monads properly so for now I just wanted some code that does I/O and but also has Maybe (like for instance from find) 
06:09:55 <Mac60> So yes I am probably asking the wrong thing? I meant would I then just return the IO (Maybe a) ? 
06:10:24 <Mac60> Or I guess maybe map the Maybe with pattern matching to a proper IO Msg? 
06:20:38 <zzz> Mac60:
06:20:42 <zzz> > let x = Just "sup" in print $ maybe "?" id x
06:20:44 <lambdabot>  <IO ()>
06:23:59 <geekosaur> % let x = Just "sup" in print $ maybe "?" id x
06:23:59 <yahb> geekosaur: "sup"
06:25:32 <Mac60> thx guys I guess I was missing the maybe function part
06:26:01 <tdammers> the maybe function is one way to do it; pattern matching would also work, it's just a bit more verbose
06:26:04 <Mac60> I am still a bit confused why I need id there, but I guess I will have to check out maybes signature 
06:26:26 <Mac60> thx guys! :)  
06:26:35 <tdammers> % let x = Just "sup" in print (case x of { Just x -> x; Nothing -> "?" })
06:26:36 <yahb> tdammers: "sup"
06:26:43 <tdammers> or you could use fromMaybe:
06:26:59 <tdammers> % let x = Just "sup" in print (fromMaybe "?" x)
06:27:00 <yahb> tdammers: "sup"
06:27:19 <zzz> you can also import fromMaybe from Data.Maybe which has type a -> Maybe a -> a, saving you from having to use id
06:27:31 <zzz> that ^
06:27:52 <tdammers> the reason you need id in that maybe application is because maybe takes 3 arguments: a value to use for the Nothing case, a function to apply in the Just case, and a Maybe value to scrutinize
06:28:20 <tdammers> it's kind of a declarative way of saying "if you have a value, do this, if not, do that"
06:29:15 <Mac60> well sure, but I guess when I need to return something to the main function for outputting then declarative is OK ? 
06:30:07 <zzz> i use to (maybe x id) in place of (fromMaybe x) because it ends up being shorter and usually saves me an import
06:30:52 * ski idly wonders what Mac60 is trying to do, more specifically
06:32:17 <tdammers> "declarative" is just a label that describes how the human brain processes the code, it has very little to do with how a computer deals with it
06:33:09 <Mac60> ski: just some learning stuff, like having some state, taking some input, doing some decisions and then output the result :)  But while doing this I had a case where one function (I think it was find) was returning a Maybe, but I was in in an IO context already and I did not know how to handle this. 
06:33:16 <Mac60> tdammers good point :)  
06:34:30 <Mac60> tbh I find Haskells way actually closer to how a human would think, its farther from the computer 
06:35:02 <Mac60> declarative is closer to how we *think* the computer works... 
06:36:36 <zzz> imperative vs declarative is like imperial vs metric in that the former is more humanistic and kind of a mess and the latter is the right way to do things :)
06:36:43 <ski> Mac60 : if you find yourself mixing `Maybe' with `IO' much (like pattern-matching on the `Maybe', short-circuiting on `Nothing', otherwise continuing), then you may want to look into `MaybeT', as tdammers suggested
06:37:10 <tdammers> zzz: except that computer hardware is kind of imperative, and not usually very declarative.
06:37:23 <tdammers> although arguably that depends which goggles you're wearing
06:37:55 * ski 's not sure what Mac60 means by "declarative" here
06:40:07 <zzz> tdammers: that's because hardware is kind of a mess.
06:41:31 <zzz> the right way to do things is still afternoon naps and pen and paper
06:41:39 <zzz> we all know that deep down
06:43:56 <tdammers> ski: it's probably because I said it
06:44:22 <cnmne[m]> why would you say something so controversial, yet so brave?
06:44:37 <tdammers> ski: and all I meant is that `maybe a b m` is less explicit about operational details than something like `if (x === null) { a(); } else { b(x); }
06:44:39 <tdammers> `
06:46:55 <Mac60> tdammers I see your point 
07:37:28 <ezzieyguywuf> dangit cabal-fmt, I like a space after `^>=`! do better!
07:39:11 <ezzieyguywuf> is there a tool that will scour my cabal file and my code and see if there are some "build-depends" that aren't used or needed?
07:44:57 <srk> ezzieyguywuf: ghc-options: -Wunused-packages :)
07:46:14 <exarkun> The docs for https://hackage.haskell.org/package/tls-1.5.4/docs/src/Network.TLS.Parameters.html#clientServerIdentification say "The extra blob is useful to differentiate services running on the same host" but I can't quite figure out what feature of TLS this maps to
07:46:38 <exarkun> And, more generally, the fact that there's space for two different names is confusing
07:46:41 <exarkun> anyone know what's going on here?
07:56:48 <ephemient> https://en.wikipedia.org/wiki/Server_Name_Indication
07:58:50 <ezzieyguywuf> srk: niccce
08:00:12 <int-e> exarkun: the tls library doesn't use the second field; I think it's for the benefit of validation only, cf. https://hackage.haskell.org/package/x509-validation-1.6.11/docs/Data-X509-Validation.html#t:ServiceID
08:02:38 <exarkun> int-e: Ah... So it passes through TLS and gets passed to ... `validate` later, looks like, which could do whatever it wants with it
08:03:00 <int-e> exarkun: it's not communicated at all
08:03:47 <exarkun> What about the ServiceID parameter to https://hackage.haskell.org/package/x509-validation-1.6.11/docs/Data-X509-Validation.html#v:validate ?
08:04:10 <int-e> exarkun: I mean it's not communicated over the network
08:04:15 <exarkun> Okay, sure
08:05:15 <exarkun> It's a place to squirrel away some extra local state to make a local decision using later on
08:05:54 <int-e> exarkun: Note I'm just following breadcrumbs here (grepping source code), I haven't used any of this.
08:06:16 <exarkun> understood
08:06:24 <int-e> I'd speculate that this having two fields is related somehow: https://hackage.haskell.org/package/x509-1.7.5/docs/Data-X509.html#t:DistinguishedName
08:06:51 <shapr> exarkun: wow, what are you building?
08:07:18 <exarkun> shapr: Pft nothing exciting in the least
08:07:47 <shapr> From the number of rabbit holes you've explored in the past week or so, I don't believe that.
08:07:52 <exarkun> Heh
08:08:03 <exarkun> I just seem to fall into rabbit holes a lot
08:08:10 <merijn> lol
08:08:25 <shapr> does that mean this is a secret project?
08:08:40 <exarkun> I'm writing an IRC bot to announce PRs on GitHub w/ reviews requested on them, as a replacement for another IRC bot that did something similar but queried trac for tickets with "review" in their keywords.
08:09:09 <shapr> I hope you write a blog post about your TLS adventures.
08:09:19 <shapr> Even a notes dump would be interesting.
08:09:23 <int-e> exarkun: are you aware of https://hackage.haskell.org/package/irc-client ? I'd be interested in informed opinions on that one.
08:10:00 <exarkun> int-e: I didn't find that one in my search, but I am also using irc-conduit
08:10:16 * shapr snoops on https://github.com/exarkun
08:10:28 <shapr> hm, only Python
08:10:37 <int-e> exarkun: I'm asking because it already adds TLS support.
08:11:21 <int-e> exarkun: But it's just on the list of things I want to look at (and possibly use in lambdabot)... I have not really started.
08:11:22 <exarkun> Yea, I see it there.  One thing I found annoying about irc-conduit (and many other haskell libs) is how they treat TLS like a special thing
08:11:53 <exarkun> So one reason I'm falling into TLS rabbit holes is I'm adding a uniform layer that can sit on either TCP or TLS
08:12:04 <shapr> will you publish a library?
08:12:04 <exarkun> (or Tor or WebSockets or stdio, etc)
08:12:15 <exarkun> shapr: probably
08:12:27 <exarkun> or rather
08:12:35 <exarkun> I was going to share it here first and have someone tell me why I'm barking up the wrong tree
08:12:40 <shapr> sounds exciting
08:16:13 <exarkun> shapr: I'm also trying out sr.ht - https://todo.sr.ht/~jcalderone/DevBot
08:16:26 <shapr> oh!
08:16:57 <shapr> I got an account on shithub, but I haven't gotten plan9's drawterm figured out yet.
08:17:54 <exarkun> heh that's a new one on me
08:18:14 <shapr> I like the logo of the beam of light falling on the toilet.
08:18:52 <exarkun> yea, nice
08:28:11 <shapr> Aha, you're using haskell.nix maybe I can steal your config files and get it working for my projects.
08:28:54 <exarkun> maybe! I have been using it for a while. It seems like every time I go to interact with it, the way you use it has changed.
08:29:09 <exarkun> Now it seems like you use it by copy/pasting an expression from the docs into default.nix and you're done
08:29:19 <shapr> I couldn't get that to work with an empty project.
08:29:23 <exarkun> which I guess is nice.  it's simpler than it was before.
08:29:28 <exarkun> ah, huh.
08:29:44 <exarkun> it seems to be working for this project, so yea maybe you'll spot something
08:29:47 <shapr> I'm still a nix novice, but this past weekend has helped.
08:29:51 * hackage algebraic-graphs-io 0.1.4.0 - I/O utilities for algebraic-graphs  https://hackage.haskell.org/package/algebraic-graphs-io-0.1.4.0 (ocramz)
09:54:45 <kritzefitz> When using TH, is there a way to splice the name of a function into a function declaration or the corresponding type signature? Doing `$name a =...` or `$name :: ...` both seem to produce syntax errors.
09:55:02 <ezzieyguywuf> srk: I don't see "unused-packages" in `man ghc`...
09:57:49 <glguy> kritzefitz: >>>  [d| $(conP (mkName "Just") [ [p|a|] ]) = Just 42 |] ;
09:57:53 <glguy> >>> a
09:57:54 <glguy> 42
09:57:59 <srk> ezzieyguywuf: since ghc 8.10
09:59:01 <ezzieyguywuf> srk: ah hah, womp womp
09:59:10 <ezzieyguywuf> srk: although I should be getting ghc 8.10 in gentoo any day now :)
09:59:22 <glguy> kritzefitz: but for declaring a variable like: fun x = x + 42, I think you'll need to just use funD
09:59:29 <glguy> no, you can't splice in Name directly
09:59:35 <ezzieyguywuf> btw, the whole gentoo/portage/installing-haskell-thingies-this-way is not that bad at all
10:00:49 <kritzefitz> glguy, Yeah for variables (`ValD`) that works, but I was hoping for something that works for `FunD` too.
10:01:10 <glguy> kritzefitz: You can do it with: [d| $(varP name) = \x y -> x*10+y |]
10:02:17 <kritzefitz> Yes, that would work and would probably be enough for my case. The type signatures still wouldn't work though.
10:05:57 <glguy> >>> (:) <$> sigD (mkName "fun") [t| Int -> Int |] <*> [d|$(varP (mkName "fun")) = \a -> a + 42 |]; >>> fun 5; 47
10:43:52 * hackage tasty-silver 3.2 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.2 (PhilippHausmann)
10:56:58 <Mzg> Hi there :) Are there any Euterpea users here?
11:21:22 * hackage mail-reports 0.2.0.0 - A parser library for DMARC and SMTP TLS reports  https://hackage.haskell.org/package/mail-reports-0.2.0.0 (implementation)
11:37:51 * hackage table-layout 0.9.1.0 - Format tabular data as grid or table.  https://hackage.haskell.org/package/table-layout-0.9.1.0 (muesli4)
12:52:37 <ezzieyguywuf> ok, so I'm trying to run the test-suite for machines (https://hackage.haskell.org/package/machines). if I execute `./setup configure --enable-tests; ./setup build; ./setup haddock; ./setup test`, the tests fail "doctests: <command line>: cannot satisfy -package machines-0.7.1"
12:52:45 <ezzieyguywuf> if I take out the `./setup haddock` step, tests run fine
12:52:49 <ezzieyguywuf> any idea why this might be?
12:59:05 <ezzieyguywuf> hrm, it seems that `./setup haddock` deletes `./dist/package.conf.inplace/machines-0.7.1-<hash>.conf`
12:59:12 <ezzieyguywuf> is this a bug, or do I need to pass a flag to haddock?
13:00:44 <ezzieyguywuf> hrm, it seems that `ghc-pkg init....` (called by ./setup haddock) is to blame...
13:02:26 <ezzieyguywuf> interesting, if I excecute the ghc-pkg init command  manually, it refuses to do anything b/c the dir exists
13:03:29 <ezzieyguywuf> here's a (verbose) log of the offending haddock invokation https://dpaste.com/5877KBKCE
13:31:23 <hseg> Hi. my testcase has some edge cases where it gets stuck, is there some way to have quickcheck report the case before being killed by OOM?
13:41:51 <juri_> oh haskell. how you make the complicated mind-warping.
13:42:12 <tomsmeding> hseg: you might try passing +RTS -M4G to your executable
13:42:29 <tomsmeding> that sets the maximum heap size to 4G (replace with whatever is appropriate for your system)
13:42:41 <hseg> sure, but that just pushes things off
13:42:46 <tomsmeding> not sure if that will crash in a way that quickcheck can still detect though
13:43:20 <tomsmeding> well my suggestion was letting the haskell RTS decide that enough is enough, instead of linux' OOM killer
13:43:38 <tomsmeding> so make that 4G _less_ than your current available memory
13:44:07 <tomsmeding> but, yeah, not sure if that will actually work
13:53:52 * hackage nix-tree 0.1.3.0 - Interactively browse a Nix store paths dependencies  https://hackage.haskell.org/package/nix-tree-0.1.3.0 (utdemir)
13:55:01 <hseg> yeah, quickcheck doesn't crash properly for this
13:56:57 <hseg> aha! docs recommend using 'within'
13:58:16 <tomsmeding> ah, a timeout, yes that could work too
13:59:37 <hseg> ok, found another parameter I should bound by
14:01:35 <hseg> hrmph. ok, will have to write the Arbitrary instance explicitly
14:01:50 <tomsmeding> apparently (I think?) setting resource limits at runtime is not yet supported in ghc: https://gitlab.haskell.org/ghc/ghc/-/issues/7763
14:02:03 <tomsmeding> would've been nice here I guess
14:04:11 <monochrom> Haha, Simon Marlow roasts both ways: "not convinced the changed semantics works" and "not convinced the current semantics works either".
14:04:17 <hseg> nice
14:05:08 <hseg> hrm. given the combinatorial explosion in my test suite, need to test short lists and small ints. any way i can bound the sizes quickcheck uses?
14:08:35 <hseg> resize looks appropriate
14:12:26 <fuzzypixelz> is there a way to join a [String] into one String
14:12:42 <fuzzypixelz> or rather a read-to-use function
14:12:57 <xsperry> concat
14:13:34 <xsperry> > concat (words "1 2 3")
14:13:37 <lambdabot>  "123"
14:14:20 <hseg> ok, bounding works nicely
14:14:38 <fuzzypixelz> > concat lines "Hello\nThese are some lines\nBye!"
14:14:41 <lambdabot>  error:
14:14:41 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
14:14:41 <lambdabot>                    with actual type ‘[String]’
14:14:43 <hseg> btw, any way of getting quickcheck to write a log of known-good cases to a file?
14:15:02 <fuzzypixelz> concat . lines $ "Hello\nThese are some lines\nBye!"
14:15:12 <fuzzypixelz> > concat . lines $ "Hello\nThese are some lines\nBye!"
14:15:15 <lambdabot>  "HelloThese are some linesBye!"
14:15:41 <fuzzypixelz> is that an __acceptable__ way to do this?
14:16:54 <xsperry> sure
14:18:53 <ephemient> how is that different from `filter (/= '\n')`?
14:22:11 <fuzzypixelz> aha
14:22:33 <fuzzypixelz> it's already so hard to do things without my loops
14:23:00 <fuzzypixelz> ephemient: I don't think it's different, I just didn't think of that
14:28:38 <hseg> hrm... label doesn't seem to have any effect
14:33:16 <Feuermagier> how do I elegantly average a list of doubles?
14:40:56 <xsperry> > let xs = [1,2,10] in sum xs / fromIntegral (length xs)
14:40:58 <lambdabot>  4.333333333333333
14:41:05 <Feuermagier> ah, sry. let me rephrase
14:41:10 <Feuermagier> i have a list of lists
14:41:20 <Feuermagier> (assume all same length)
14:41:39 <Feuermagier> and i want the first element in every list to be the average of all first elements
14:42:26 <ski> if input is `[[a],[b,c],[d,e,f]]', what should output be ?
14:42:30 <Feuermagier> the second in every list to be the average of all 2nd elements (and so on)
14:42:58 <ski> oh, sorry. missed that all had same length
14:43:02 <sm[m]> sooo.. all the lists are the same ?
14:43:18 <Feuermagier> yes, well, actually I just fill up with 0 should one be less
14:43:38 <fuzzypixelz> https://bpa.st/AIGA
14:44:01 <fuzzypixelz> can you tell what the syntax error here is? I still don't know how to do correct identation
14:44:04 <monochrom> I don't understand why the output has to be [[Double]], not simply [Double].
14:44:16 <ski> > let average xs = sum xs / fromIntegral (length xs) in (map average . transpose) [[1,4,7],[2,5,8],[3,6,9]]
14:44:18 <lambdabot>  [2.0,5.0,8.0]
14:44:49 <ski> > let average xs = sum xs / fromIntegral (length xs) in (map average . transpose) [[1,4,7],[2,5,8],[3,6,9]]  :: [Expr]
14:44:51 <lambdabot>  [(0 + 1 + 2 + 3) / 3,(0 + 4 + 5 + 6) / 3,(0 + 7 + 8 + 9) / 3]
14:44:58 <monochrom> But I would make the output simply [Double].  Then my algorithm is (map average . transpose), where I code up "average" to be a simple average of one list.
14:45:13 <monochrom> Yeah what ski did.
14:45:51 <ski> fuzzypixelz : indent `if' more than `unique'
14:46:09 <ski> you can also use guards, here
14:46:36 <Feuermagier> ski, big thanks!
14:47:16 <ski> although, `acc ++ answer' is a type error. and you've got the parameter ordering of `foldl' wrong
14:49:42 <monochrom> This is why I (and most others) don't put anything on the same line as "where".
14:50:32 <fuzzypixelz> ski: I though it was with respect with `where`, thank you
14:51:11 <monochrom> And it still doesn't imply that the line after "where" is horrendously indented by 8 spaces.  You can use just 2 for "where", 4 for the line after.
14:52:27 <monochrom> In addition, this also is more honest, less misleading when: before the 2-space-indented "where" you have a 4-space-indented do-block.
14:52:35 <Feuermagier> ski, how do i elegantly append 0 until all lists are of the same length in my previous example?
14:53:20 <Feuermagier> (as i actually want it to work on lists with differentl length, just as if a nonexistant element *were* 0)
14:53:57 <monochrom> > transpose ["abcd", "01"]
14:53:59 <lambdabot>  ["a0","b1","c","d"]
14:54:47 <monochrom> I think you don't need to. You just need the maximum length, use it for your divisor.
14:55:54 <Feuermagier> monochrom, can you show how you mean that on the function of ski :  let average xs = sum xs / fromIntegral (length xs) in (map average . transpose)
14:56:02 <monochrom> average [x,y] = sum [x,y] / 10 if you know 10 is the maximum length coming from outer level.
14:57:08 <monochrom> OK, your input is [[x,y], [a,b,c,d,e,f,g,h,i]]
14:57:35 <monochrom> n = fromIntegral (maximum (map length that)) gives you 10.0
14:57:37 <hseg> any way of getting quickcheck to abort a test if it's too expensive but still keep going?
14:57:44 <hseg> i.e. a non-fatal 'within'
14:58:33 <monochrom> map (\xs -> sum xs / n) (transpose that) is the list of averages.
14:58:47 <monochrom> also the input is [[x,y], [a,b,c,d,e,f,g,h,i,j]]
14:59:12 <Feuermagier> monochrom, i want my example to behave *as if* zeroes were attended to the list
14:59:23 <Feuermagier> so all lists are same length
14:59:26 <monochrom> I did that.
14:59:47 <Feuermagier> monochrom, which formula does that?
15:02:30 <Feuermagier> monochrom, so mix xss = map average . transpose (transpose xss [0..]) ?
15:02:42 <ski> that's a type error
15:03:04 <Feuermagier> ski, mind showing me the correct one?
15:03:29 <ski> i guess they wanted `length that', not `maximum (map length that)' ?
15:03:54 <monochrom> > maximum (map length  [[x,y], [a,b,c,d,e,f,g,h,i,j]])
15:03:56 <lambdabot>  10
15:04:01 <ski> yes
15:04:11 <ski> > transpose [[x,y],[a,b,c,d,e,f,g,h,i,j]]
15:04:13 <lambdabot>  [[x,a],[y,b],[c],[d],[e],[f],[g],[h],[i],[j]]
15:04:16 <ski> seems `n' should be `2', here ?
15:04:20 <Feuermagier> ski, so in our example?
15:04:32 <monochrom> Oh, I see, right, n = length that.
15:04:55 <ski> Feuermagier : do you understand ?
15:05:06 <Feuermagier> no
15:05:15 <Feuermagier> like, i just want to fill with 0
15:05:31 <Feuermagier> so i can use it on varying length
15:06:13 <ski> > (map (\xs -> sum xs / 2) . transpose) [[x,y],[a,b,c,d]] :: [Expr]
15:06:15 <lambdabot>  [(0 + x + a) / 2,(0 + y + b) / 2,(0 + c) / 2,(0 + d) / 2]
15:06:37 <ski> Feuermagier : ^ looks ok ?
15:06:43 <Feuermagier> yes
15:08:52 * hackage brick 0.58 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.58 (JonathanDaugherty)
15:09:37 <ski> > (map (\xs -> foldl1' (+) xs / 3) . transpose) [[x,y],[a,b,c,d],[i,j,k]] :: [Expr]
15:09:39 <lambdabot>  [(x + a + i) / 3,(y + b + j) / 3,(c + k) / 3,d / 3]
15:10:41 <hseg> correct me if i'm wrong, but an expression like length [(t, f * dsOccs m t) | n <- [0 .. m], (t, f) <- terms n (fromFreqs l)] < 35 will only compute the first 35 elements of the list, correct?
15:11:01 <hseg> even if this is buried under several layers of function calls
15:11:21 <glguy> hseg: that would be wrong
15:11:22 <ski> nope
15:11:29 <monochrom> > length [0..] < 3
15:11:35 <lambdabot>  mueval-core: Time limit exceeded
15:11:39 <hseg> :-(
15:11:44 <fuzzypixelz> can I have mutliline function composition?
15:11:45 <glguy> monochrom: there's no space in <3 :nod:
15:11:57 <ski> try `drop 34' ?
15:12:02 <monochrom> Oh! I'll fix it
15:12:05 <monochrom> > length [0..] <3
15:12:11 <lambdabot>  mueval-core: Time limit exceeded
15:12:17 <glguy> length is love
15:12:20 <hseg> > null (drop 34 [0..])
15:12:22 <lambdabot>  False
15:12:49 <hseg> ok, so should replace my "avoid large testcase" code with that
15:12:50 <glguy> hseg: in your caes of being interested in lengths < 35, : length (take 35 xs) < 35
15:13:13 <ski> > genericLength [0 ..] < (35 :: Natural)
15:13:15 <lambdabot>  False
15:13:15 <Feuermagier> thx. i get it now
15:13:21 <monochrom> You should instead code up a non-partial version of (!) and then ask whether xs!34 gives you Just or Nothing.
15:13:24 <glguy> (or the drop thing, etc)
15:13:46 <monochrom> Err nevermind, drop and null are better.
15:13:54 <hseg> hrm. why does genericLength work here?
15:14:14 <ski> because `Natural' has `<' working as you hoped
15:14:17 <monochrom> genericLength uses non-tail recursion, length uses tail recursion.
15:14:22 <glguy> because generic length is written inefficiently specifically to support this one case
15:14:24 <monochrom> Clearly, non-tail recursion is better.
15:15:23 <monochrom> genericLength (x:xs) = 1 + genericLength xs.  And then, (+) for Natural is lazy in its 2nd operand.
15:15:44 <monochrom> (Natural is a lazy ADT that does unary representation.)
15:16:04 <ski> fuzzypixelz : yes
15:16:13 <monochrom> I would call it too-cute-to-be-clear and use drop and null instead.
15:16:13 <ski> Feuermagier : good
15:16:24 <hseg> k
15:17:40 <hseg> hrm. am using this sample size as a way of getting quickcheck to avoid getting bogged down on the heavy cases, but obviously this skews the data
15:18:22 <hseg> would much rather just set a non-fatal timeout and classify inputs by size and proportion that passed/timed out
15:18:47 <hseg> especially since this test is giving me ~50% discard rates
15:21:11 <monochrom> I don't know QuickCheck, but I would maybe surrender and handcode my own probability distribution that gives very low probabilities to large sizes.
15:22:25 <monochrom> Last year I learned random generation of trees the hard and dumb way.
15:22:37 <hseg> oh?
15:22:59 <monochrom> I went "with probability 0.5, have no children; with the other 0.5, have 2 children"
15:23:30 <monochrom> So my program took forever because it's generated a neverending tree.
15:24:03 <monochrom> I talked about it here and someone pointed out the very obvious makes-me-bang-head-at-wall-why-didn't-I-see-it-it's-so-obvious:
15:24:35 <monochrom> So every node has 1 child on average. This is not going to end.
15:24:52 <hseg> oh. oops
15:25:29 <monochrom> The irony is I taught expected values to students, in terms of average case running time.
15:26:31 <hseg> heh
15:26:32 <fuzzypixelz> ski: but how?
15:26:43 <hseg> so how *do* you gen random trees?
15:26:44 <monochrom> Anyway, it motivated me to read a couple of papers on randomly generating trees with a target size, and recalling my knowledge of generating polynomials, combinatorics, etc.
15:28:08 <monochrom> OK, so you can still go: "after generated a node, when deciding whether it is leaf or internal: with probability p, it's a leaf; with probability 1-p, it's internal, has two children" recursively.
15:28:33 <monochrom> But just be careful with p and 1-p. There is even a formula for them if you have a desired global size in mind.
15:28:43 <hseg> and then you pick p so the expected tree size is correct?
15:28:48 <monochrom> Yeah.
15:29:52 <monochrom> I don't have the formula. But I can point you to the paper. Alternatively, don't worry about it, just try some sensible values, check that the expected value is reasonable.
15:30:27 <hseg> hrm... so E[size]=(1-p)E[size]^2 at fixed point, so you'd want 1-p=1/target ?
15:30:58 <monochrom> "Boltzmann samplers for the random generation of combinatorial structures"
15:31:23 <ski> fuzzypixelz : just indent enough. i prefer leading following lines with `.'
15:31:55 <hseg> ty
15:31:59 <monochrom> Yeah I think that's it.
15:32:54 <hseg> back to my quickcheck code, just noticed i can potentially replace a case filter by correct-by-construction generation
15:33:23 <ski> or one can used `sized' to cut-off depth (or number of nodes)
15:33:33 <ski> @type sized
15:33:35 <lambdabot> (Int -> Gen a) -> Gen a
15:33:35 <hseg> except i need to convert a function :: RandomGen g => Int -> g -> (t,g) to Int -> Gen t
15:34:05 <hseg> and these Ints differ (the function accepts target size, I want to accept max size)
15:34:27 <hseg> the latter can be dealt with. how do i do the former?
15:43:02 <hseg> ok, can just explicitly construct it with MkGen and drop the new seed
15:51:39 <__monty__> > case Data.Map.singleton 1 of Data.Map.empty -> True; _ -> False
15:51:42 <lambdabot>  error:
15:51:42 <lambdabot>      Qualified name in binding position: Data.Map.empty
15:51:55 <__monty__> Can't pattern match on an empty Map?
15:55:41 <ski> __monty__ : you could define a pattern synonym ..
15:55:52 <__monty__> internal library
15:56:08 <__monty__> Woops.
15:56:39 <__monty__> ski: I should look into that. In this case I'm fine with | M.null map though.
15:57:05 <ski> what're you doing, in case of non-empty ?
16:02:22 <fuzzypixelz> I I want to map elem on a list of elements and lists, how can I do that?
16:02:38 <fuzzypixelz> elem (1, [1, 2, 3]) doesn't work for example
16:02:51 <fuzzypixelz> so I can't map elem on a list of tuples
16:05:11 <fuzzypixelz> here's what I did: elem' (e, l) = elem e l
16:05:17 <fuzzypixelz> and just used elem1
16:25:07 <hseg> any way to optimize this? http://ix.io/2J4J ds and terms are heavy functions that i don't think i can optimize much
16:25:26 <hseg> (restricted by combinatorial explosion)
16:27:12 <hseg> especially should be able to share one (ds m) call over the entire needle call
16:32:31 <hseg> oh wait. ds m :: [(a,Int)] is injective, so can replace the sum by a lookup
16:33:15 <hseg> still needs a shared ds call though
16:38:19 <monochrom> needle m l = let dsm = ds m in [(t, f * occs t dsm) | ...]
16:38:31 <monochrom> occs t dsm = sum . map snd $ filter ((== t) . fst) dsm
16:41:03 <hseg> sure, though as i realized 5m ago, can replace the sum . filter by just fromMaybe 0 . lookup
16:41:41 <hseg> and am not seeing *that* drastic of an improvement by floating the (ds m) call out, for some reason
16:42:19 <hseg> ... indeed, am doing a poor man's inner join of maps on lists
16:46:16 <hseg> so should rather refactor ds, terms into Map [Int] Int and replace needle by unionsWith (+) ([0..m] <&> intersectionWith (*) (ds m) . (`terms` l))
16:46:25 <dsal> fuzzypixelz: the tuple is possibly confusing you.
16:46:36 <xsperry> fuzzypixelz, what's your input and desired output?
16:46:37 <dsal> It's not clear what you mean by "map elem"
16:47:34 <dsal> > uncurry elem <$> [(1, [1, 2, 3]), (4, [1, 2, 3])]  -- fuzzypixelz do you mean something like this?
16:47:36 <lambdabot>  [True,False]
16:48:31 <dsal> :t uncurry
16:48:33 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:58:45 <delYsid> Given two rose trees a and b where b is a subset of a, is there a simple way to impose the ordering of b onto a?
16:59:40 <delYsid> IOW all the nodes present in b should be put first in a, in the same order they occur in b.
17:03:32 <fuzzypixelz> dsal: yes that's exactly what I need, thank you
17:15:38 <xsperry> <$> is just fmap btw, which is map for lists
17:17:19 <fuzzypixelz> xsperry: oh I see
17:17:45 <fuzzypixelz> my (haskell) solution for AOC day 6: https://bpa.st/4QIA
17:17:59 <fuzzypixelz> Any feedback is (very) appreciated
17:18:01 <fuzzypixelz> :P
17:18:59 <fuzzypixelz> uhh, I mean, please give me feedback/comments/remarks .. anything
17:34:49 <hseg> hrm. is there some way of altering the key of a map for a single query? 
17:37:09 <hseg> otherwise, i'm forced to compute the key-dependent values before alteration, adding unnecessary strictness
17:40:27 <hseg> hrm. and that breaks all of my abstraction boundaries
17:41:12 <hseg> unfortunately, maps are not key-value pairs, so this proposed alteration is too expensive to be reasonable
17:41:25 <ski> > ST.Lazy.runST (do ref <- STRef.Lazy.newSTRef []; let loop n = do loop (n+1); STRef.Lazy.modifySTRef ref (n:) in do loop 0; STRef.Lazy.readSTRef ref)
17:41:32 <lambdabot>  mueval-core: Time limit exceeded
17:41:55 <ski> monochrom : was one of your `ST.Lazy' examples something like that ^ ?
17:44:33 <monochrom> Yes. Head/left recursion works.
17:46:47 <hseg> ok, converting to maps made everything *much* faster
17:46:53 <ski> so i wonder why that wasn't productive
17:58:38 <koz_> ski: It spent too much time procastinating on social media. :P
17:58:49 <fuzzypixelz> just dropping this https://bpa.st/4QIA again (my aoc day 6 solution), if you have anything to say about it please do
18:07:52 * hackage yesod-form-multi 1.7.0 - Multi-input form handling for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-multi-1.7.0 (Burtannia)
18:29:47 <delYsid> pathTree :: Tree a -> Tree (NonEmpty a)
18:29:52 <delYsid> pathTree = foldTree $ \a -> Node (pure a) . (fmap . fmap) (cons a)
18:30:04 <guest1222> is rio a good library to use?
18:30:06 <delYsid> Thats about the most useful function I have ever written/discovered.
18:30:08 <guest1222> https://hackage.haskell.org/package/rio
18:30:49 <glguy> guest1222, it's unmaintained build-depends would make it a mess to rely on
18:30:59 <guest1222> glguy: ...
18:45:50 <guest1222> glguy: what runParser is used to in parsec? 
18:46:06 <guest1222> there's State monad in runParser?
19:08:14 <glguy> guest1222, I don't understand the question
19:08:36 <glguy> You're asking about: runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a ?
19:13:01 <glguy> and parsec provides built-in support for tracking some state, along the path of a successful parse
19:16:05 <dsal> :t map concat
19:16:06 <lambdabot> Foldable t => [t [a]] -> [[a]]
19:16:14 <dsal> :t foldMap
19:16:15 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:28:09 <MarcelineVQ> :t fold . fold
19:28:11 <lambdabot> (Foldable t1, Foldable t2, Monoid c, Monoid (t1 c)) => t2 (t1 c) -> c
20:41:52 * hackage HaskellNet 0.5.3 - Client support for POP3, SMTP, and IMAP  https://hackage.haskell.org/package/HaskellNet-0.5.3 (AlexanderVershilov)
21:22:58 <iqubic> Is there a way to short circuit a Do block? I have a Do block using State GameState Int, for a custom type GameState. I want to first check if GameState has a given property, and if so, I want to do none of the remaining computations and just return of a set value.
21:26:04 <monochrom> Just use a conditional.
21:26:08 <iqubic> How so?
21:26:23 <monochrom> You know if-then-else? You know case-of?
21:26:55 <iqubic> I do.
21:27:07 <pavonia> It depends on the used monad, e.g. Cont can do that, IIRC
21:27:17 <iqubic> I'm using State.
21:28:09 <pavonia> Then use a conditional :)
21:28:42 <iqubic> I se.
22:09:09 <gentauro> tdammers: hey, you still haven't got any scandinavians? https://well-typed.com/who_we_are/
22:09:25 <gentauro> tdammers: is it cos they don't apply, or do you just not hire scandis? :D
22:10:00 <gentauro> tdammers: https://well-typed.com/blog/2020/12/haskell-development-job-with-well-typed/
22:10:13 <MarcelineVQ> the latter for sure
22:19:21 <gentauro> btw, troll spotted? https://yairchu.github.io/posts/silly-haskell-formatting
22:20:00 <gentauro> I tend to write my signtaures like this for readability (and sanity) -> https://gitlab.com/spisemisu/bornhack-demo-2019/-/blob/master/src/Main.hs#L52-59
22:20:13 <gentauro> how is this "silly"?
22:26:00 <pavonia> gentauro: Well, he has a point there. If you want to remove/move the first parameter with "silly" formatting, you have to change two lines
22:27:28 <leifm> The way he prefers works better with proportionally-spaced fonts
22:28:15 <MarcelineVQ> I don't strictly adhere to one parameter to one line
22:28:40 <MarcelineVQ> I might have 2,3,1 even
22:29:33 <MarcelineVQ> Code as an artform should shun strict formatting anyway :>
22:29:46 <MarcelineVQ> Make it beautiful not conformant
22:30:43 <pavonia> Heh
22:31:04 <gentauro> pavonia: so compromise readability for the sake of "lazyness"?
22:32:55 <gentauro> also, I think it's a bit meh to dismiss all of Haskell styling tools -> «I was looking to see what formatting tools exist for Haskell, and discovered that while several tools exist, none fit my taste, and some of these tools were disqualified on the grounds of applying silly formatting.»
22:33:05 <gentauro> maybe he should have stayed in the C++ ecosystem
22:33:09 <nfd> hey folks :) trying to finish up AoC day 19 and i think i have most of a cfg parser generator (to megaparsec) handy, but i've got some hiccup somewhere here that's causing it to not consume all input (like i expected from the backtracking strat)
22:33:40 <nfd> https://nfd.moe/files/tmp/day19.txt think my problem's in mkParser here
22:33:40 <gentauro> nfd: there are `hints` on the /r/haskell ;)
22:33:52 <nfd> heh nice
22:34:17 <nfd> specifically i'm rejecting good inputs on that last `<* eof` check on the top-level
22:34:49 <nfd> i'll check the reddit but i don't know if i want to see how everyone else generally does it before i'm through
22:35:21 <gentauro> btw, I personally use `stylish-haskell`. I somehow agree with the formatting except on imports of constructors and record fields. Instead of beeing multi-line, they are always one-liners …
22:35:41 <gentauro> nfd: good point
22:36:09 <pavonia> gentauro: I wouldn't say, and I also don't like the formatting suggested in the article, but it doesn't seem like trolling to me
22:38:18 <gentauro> pavonia: using the terms "silly" for all others (including Jasper Van der Jeugt tool) compared to "propper" (his) is trolling in my book
22:39:15 <gentauro> nfd: I guess it would help if you posted a "sample" of the data to parse …
22:43:50 <nfd> so i'm going through with megaparsec debug and i'm mostly seeing what i expected
22:45:37 <nfd> aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba is accepted early at aabbbbbaabbbaaaaaabbbbbababa in the trial input
22:45:53 <nfd> (and then caught and errored by the guard at the top-level
22:46:13 <nfd> gentauro: sorry, i was staring at the debug output :D
22:47:17 <nfd> my first instinct was "well, maybe i need more eof checking in the midst of this thing" but clearly that's probably not *quite* it all of the time
22:47:52 <nfd> because parsers may be called in the middle of others, generally
22:49:36 <nfd> this problem kinda smells of Kleene
22:50:11 * xerox_ watches Kleene checking his armpits
22:51:02 <nfd> though the last parser to apparently wrongly succeed was 11, which is by definition in p2. 42, 31 | 42, 11, 31 which isn't very kleeney
22:51:25 <nfd> so maybe i take it back
22:52:48 <nfd> and also not very regular
22:53:07 * nfd has flashbacks of having to do pumping lemma problems in exams
22:53:55 <nfd> uptree 11 fails a whole bunch, though! strange
23:11:38 <Turmiht> Anybody here uses macOS Big Sur to write Haskell?
23:12:12 <Turmiht> I got a linker error yesterday and cannot figure it out
23:25:10 <dminuoso> Turmiht: What error message do you get?
23:26:12 <Turmiht> Resolving dependencies...Build profile: -w ghc-8.8.4 -O1In order, the following will be built (use -v for more details): - distributive-0.6.2 (lib:distributive) (requires build)Starting     distributive-0.6.2 (all, legacy fallback)cabal: Failed to build distributive-0.6.2. The failure occurred during theconfigure step. The exception
23:26:12 <Turmiht> was:dieVerbatim: user error (cabal: '/Users/turmiht/.ghcup/bin/ghc' exited with anerror:ld: warning: ignoring file/Users/turmiht/.cabal/store/ghc-8.8.4/cbl-dctst-1.0.8-9ce5b252/lib/libHScbl-dctst-1.0.8-9ce5b252.a,building for macOS-x86_64 but attempting to link with file built forunknown-unsupported file format ( 0x21 0x3C 0x61 0x72 0x63 0x68 0x3E
23:26:13 <Turmiht> 0x0A 0x2F0x20 0x20 0x20 0x20 0x20 0x20 0x20 )Undefined symbols for architecture x86_64:"_cblzmdctstzm1zi0zi8zm9ce5b252_DistributionziExtraziDoctest_defaultMainWithDoctests_closure",referenced from:_Main_main_info in Main.o_Lu2mR_srt in Main.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v
23:26:13 <Turmiht> to seeinvocation)`gcc' failed in phase `Linker'. (Exit code: 1))
23:27:06 <Turmiht> It seems to me that my ld fail to recognize the ar file (given the magic bytes)
23:29:22 * hackage spdx-license 0.1.0 - SPDX license templates  https://hackage.haskell.org/package/spdx-license-0.1.0 (Poscat)
23:29:32 <Turmiht> lipo -info and object dump show contents of referenced libs is build for macho-x86-64
23:29:48 <dminuoso> @where
23:29:48 <lambdabot>  @where <key>, return element associated with key
23:29:57 <dminuoso> @where paste
23:29:57 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
23:30:21 <dminuoso> Turmiht: Can you use that? It's just easier for me to read when whitespace is nicely preserved
23:30:32 <Turmiht> I'll give it a try
23:30:41 <Turmiht> Wait a minute plz
23:31:45 <Turmiht> https://paste.tomsmeding.com/rdCfhFsm
23:31:50 <Turmiht> Is it ok?
23:31:56 <dminuoso> Yes, cheers
23:32:06 <dminuoso> Mmm, still looks weird, but it's fine
23:32:35 <Turmiht> Well, thx
23:33:47 <dminuoso> Turmiht: Does the error happen with 8.10.3 as well?
23:34:05 <Turmiht> Yes, and 8.6.5
23:34:41 <Turmiht> Wait, no
23:34:52 <Turmiht> I just tried 8.10.2 which appear in ghcup list
23:35:31 <Turmiht> should I build 8.10.3 from source?
23:38:19 <dminuoso> Turmiht: What command did you use to provoke this error?
23:38:57 <Turmiht> `cabal install distributive` could, although I first found it when I try install Agda
23:39:29 <dminuoso> Just to rule some stuff out, do you have any modifications in your ~/.cabal/config ?
23:39:54 <Turmiht>  nop, and it have tried reinstall everthing
23:40:20 <Turmiht> I and everything, typos
23:40:42 <dminuoso> https://gitlab.haskell.org/ghc/ghc/-/issues/18446
23:40:46 <dminuoso> Im wondering whether this is related
23:41:52 <dminuoso> Turmiht: https://downloads.haskell.org/~ghc/8.10.3/ghc-8.10.3-x86_64-apple-darwin.tar.xz
23:41:56 <dminuoso> Try the version manually
23:42:12 <dminuoso> Just unpack it somewhere and install as regular bindist
23:42:21 <tdammers> gentauro: you'd think well-typed, out of all people, would have a "strictly no scandinavians" hiring policy?
23:42:33 <Turmiht> I'm downloading it
23:53:56 <Turmiht> sorry to ask, how can I use a specific ghc version when using cabal?
23:55:21 <sclv>  use the -w flag
23:55:40 <sclv> cabal —help and the manual are your friends
23:56:22 <dminuoso> sclv: — instead of -?
23:56:25 <dminuoso> Does cabal eat that?
23:56:34 <RaderH2O> hMmMm
