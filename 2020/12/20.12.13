00:23:15 <ski> doct0rhu : how did you make `X' a monad ?
00:24:20 <iqubic> ski: The 'X' monad is from the window manager XMonad, it's used in the code for that, and you can also use it in your configuration too.
00:35:33 <ski> then i highly doubt "But with `foo >> bar` only the last one is executed. I have to use `mappend foo bar` or `foo <> bar`"
00:54:51 <doct0rhu> Try yourself
00:56:02 <doct0rhu> `newtype X a = X (ReaderT XConf (StateT XState IO) a)`
00:57:55 <ski> that does not make `X' an instance of `Monad'
00:58:14 <ski> are you omitting some `deriving (...Monad..)' declaration or some `instance Monad X where ...' declaration ?
01:00:07 <ski> % data XConf = FakeXConf
01:00:08 <yahb> ski: 
01:00:14 <ski> % data XState = FakeXState
01:00:15 <yahb> ski: 
01:00:28 <ski> % newtype X a = MkX (ReaderT XConf (StateT XState IO) a)
01:00:29 <yahb> ski: 
01:01:15 <ski> % :t let foo :: X a -> X b -> X b; foo x0 x1 = x0 >> x1 in foo
01:01:16 <yahb> ski: ; <interactive>:1:43: error:; * No instance for (Monad X) arising from a use of `>>'; * In the expression: x0 >> x1; In an equation for `foo': foo x0 x1 = x0 >> x1; In the expression:; let; foo :: X a -> X b -> X b; foo x0 x1 = x0 >> x1; in foo
01:01:31 <ski> doct0rhu : i just tried it for myself, did not work
01:02:27 <doct0rhu> just hoogle
01:04:52 <ski> if you're talking about trying the `X' defined in `xmonad', at <https://hackage.haskell.org/package/xmonad-0.15/docs/src/XMonad.Core.html#X>, rather than the `newtype X a = MkX (ReaderT XConf (StateT XState IO) a)' you suggested above (not including any `deriving' or `instance' clause or declaration), then it does derive `Monad' using `GeneralizedNewtypeDeriving', and therefore `x0 >> x1' will combine the 
01:04:58 <ski> effects of both `x0' and `x1'
01:07:22 <ski> so .. my guess then is that there's most probably some other issue involved. perhaps you could show the code in question ?
01:08:55 <doct0rhu> `newtype X a = X (ReaderT XConf (StateT XState IO) a)` is the definition of X
01:09:20 <ski> the complete definition includes the next line, `deriving (Functor, Monad, MonadFail, MonadIO, MonadState XState, MonadReader XConf, Typeable)'
01:09:29 <doct0rhu> yes so you know that 
01:09:34 <doct0rhu> what's the point of asking me
01:09:53 <ski> i didn't know you were talking about the `X' of `XMonad', initially
01:10:12 <doct0rhu> if you just hoogled it's clear
01:10:28 <doct0rhu> the question is not XMonad specific
01:10:36 <doct0rhu> the question is why >> doesn't work and <> works
01:11:36 <ski> i don't know (a) what you tried; (b) what effect you expected; (c) what effect you observed instead
01:11:54 <doct0rhu> I described
01:12:38 <ski> (so i don't know what you mean by "doesn't work" and "work", apart from the rather general/vague "though the result of previous action is not retained, it would still be executed" (and similar statements))
01:12:53 <ski> it's hard to guess at what might be wrong, without more specific code to look at
01:12:59 <doct0rhu> I described exactly
01:13:23 <doct0rhu> > But I recently come across the case where I tried using >> to chain several `X ()` actions in XMonad. But it turned out only the last one is executed
01:13:27 <lambdabot>  <hint>:1:37: error:
01:13:27 <lambdabot>      <hint>:1:37: error: parse error on input ‘where’
01:13:27 <ski> which actions, exactly, did you pass to `>>' respectively to `<>' ?
01:13:45 <ski> "I tried using >> to chain several `X ()` actions in XMonad" -- which actions, specifically ?
01:13:50 <doct0rhu> does that really matter which action
01:13:54 <doct0rhu> only the type matter
01:14:18 <doct0rhu> if some x of X works but not the other
01:14:25 <doct0rhu> that's a serious bug in type system
01:15:28 <doct0rhu> If I want to ask about XMonad question I've already asked in that way
01:15:38 <doct0rhu> the question is not XMonad specific
01:17:00 <ski> the `XMonad'-non-specific answer is that both `x0' and `x1' are executed, when `x0 >> x1' are executed (assuming `x0' doesn't abort execution (e.g. via an exception), or that some other thread terminates the thread executing `x0 >> x1', or something like that)
01:17:49 <ski> since that's not what you're observing, i don't know what else to do, than dig deeper into more details of what you tried, what you expected, and what you observed
01:18:10 <doct0rhu> I don't think that's what I'm asking
01:19:56 <whataday> (sort . <>) [1..5] [3..7] how to fix it?
01:20:44 <xerox_> > ((sort .) . (<>)) [1..5] [3..7]
01:20:45 <boxscape> @pl \xs ys -> sort (xs <> ys)
01:20:46 <lambdabot> (sort .) . (<>)
01:20:48 <lambdabot>  [1,2,3,3,4,4,5,5,6,7]
01:20:54 <ski> something is clearly mismatched between what you expected/wanted, and what you observed. i can only attempt to debug the issue in the same way i would do it, if it occured to me : by digging deeper into details and expectations
01:22:19 <doct0rhu> I'm not trying to debug anything
01:22:54 <doct0rhu> my question is purely about the theory not about the specific behaviour of a library
01:23:42 <ski> you're not attempting to resolve your question regarding the difference you observed regarding `<>' and `>>' ?
01:24:17 <doct0rhu> holy
01:24:19 <ski> in the case of `X', the relevant type signatures are `(>>) :: X a -> X b -> X b' vs. `(<>) :: Monoid a => X a -> X a -> X a'
01:24:42 <whataday> what is (sort .)?
01:25:26 <xerox_> (f . g) = \x -> f (g x)  so  (sort .) is that with 'f' filled  (sort .) = \g x -> sort (g x)
01:25:31 <hyiltiz> I am programmatically creating hundreds of latex files from a template, and calling builder on them. Currently, it sequentially runs pdflatex, slowly building and then writing the PDFs on disk. Should I just create a hundred thread each of which tries to grab CPU cycles and build it, or just concurrently submit one per CPU worker so it essentially builds 4 at a time? Not sure which one would be more efficient/fast.
01:26:02 <ski> both `x0 >> x1' and `x0 <> x1', when executed, will execute `x0' and `x1' (in the absence of any abortion of execution as mentioned above). `x0 >> x1' will ignore the result (but not the effect) of `x0', giving back the result of `x1'. `x0 <> x1' will combine the result of `x0' with that of `x1' (using `<>' on those individual results)
01:26:25 <hyiltiz> tex -> pdf is a bit CPU intensive but writing PDF into disk is also IO intensive, so not sure what would be the best strategy to parallelize/make it concurrent
01:26:53 <hyiltiz> all of the tex -> pdf computation is fully independent with no sharing
01:27:06 <ski> doct0rhu : the theory answer is that `x0 >> x1' ought to execute both `x0' and `x1'. if that's not happening in your experience, then something is amiss between the theory, and the practical application of it
01:28:13 <doct0rhu> `X a <> X b` == `X (a <> b)`
01:28:36 <ski> yes
01:30:32 <doct0rhu> `X a >> X b` ?= `X (a >> b)`
01:31:37 <ski> almost. (yes, to what i think you meant to express)
01:32:04 <doct0rhu> In the definition, `newtype X a = X (ReaderT XConf (StateT XState IO) a)`, `StateT XState IO` is a monad, `ReaderT XConf (StateT XState IO)` is also a monad
01:33:11 <ski>   X a >> X b  =  X (liftM2 (liftM2 (>>)) a b)
01:33:17 <doct0rhu> `ReaderT`'s `(>>)` is same as `(*>)`, `u *> v = ReaderT $ \ r -> runReaderT u r *> runReaderT v r`
01:34:53 <doct0rhu> `newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }`
01:35:53 <ski>               =  X (ReaderT (\xConf -> StateT (\xState0 -> do xState1 <- execStateT (runReaderT a xConf) xState0; runStateT (runReaderT b xConf) xState1)))
01:36:20 <ski> doct0rhu : yes
01:36:25 <whataday> but <> apply on two lists, sort aply on one, (sort .) . (<>) is ok?
01:37:47 <whataday> does (sort .) expect an unary function and an parameter?
01:38:11 <ski> @type (sort .)
01:38:13 <lambdabot> Ord a1 => (a2 -> [a1]) -> a2 -> [a1]
01:38:30 <ski> @type \f -> (sort .) . f
01:38:33 <lambdabot> Ord a1 => (a2 -> a3 -> [a1]) -> a2 -> a3 -> [a1]
01:38:41 <ski> @type (sort .) . (<>)
01:38:43 <lambdabot> Ord a => [a] -> [a] -> [a]
01:38:57 <ski> @type (null .) . (<>)
01:39:00 <lambdabot> (Foldable t, Semigroup (t a)) => t a -> t a -> Bool
01:39:27 <ski> @type (map isSpace .) . (<>)
01:39:31 <lambdabot> [Char] -> [Char] -> [Bool]
01:40:06 <ski> `(sort .) . (<>)' will, curriedly, accept two lists, combine them using `(<>)', then `sort' the result
01:40:52 <ski> `h = (f .) . g' is the same as `h x y = f (g x y)'. so `h = (sort .) . (<>)' is the same as `h xs ys = sort (xs <> ys)'
01:42:13 <ski> (if you care about it, i could show how to systematically derive `h = (f .) . g'/`h = (sort .) . (<>)', from `h x y = f (g x y)'/`h xs ys = sort (xs <> ys)' ..)
01:54:08 <superstar64> what's causing my syntax error here? https://gist.github.com/Superstar64/1913d4f016d878d2893f0fbdd1313812
01:54:21 <superstar64> ghc's message isn't that helpful source/Main.hs:27:25: error: Unexpected do block in function application:
01:59:33 <int-e> superstar64: does the code that ghc prints match the code you pasted? a self-contained example would help, or at least the full error message
01:59:54 <int-e> but 25 is in the middle of the 'do'
02:00:14 <superstar64> ok i updated it with the error message
02:00:16 <int-e> So something seems off. Maybe tabs?
02:00:45 <superstar64> i'm not using tabs
02:01:01 <int-e> oh I'm miscounting, my bad
02:01:51 <superstar64> wait, nvm i fixed it
02:02:04 <superstar64> i forgot to wrap the second type annotation in parens
02:03:07 <ski>   let (Right (κ,_)) = runCore (typeCheck σ :: Core Kind) (CoreState Map.empty Map.empty)
02:03:15 <boxscape> looking forward to visible type application so we can replace inline type annotations with a function, like Idris has
02:04:34 <ski> like `(:: T) (...)' or `id @T (...)' ?
02:04:48 <boxscape> Idris has `the Int 5`
02:05:14 <boxscape> (or at least it did when I last used it 5 years ago)
02:05:54 <superstar64> `Map.!: given key is not an element in the map` any way to debug this?
02:05:58 <boxscape> you could do it with a visibility override like your id example already, of course
02:06:06 <boxscape> it's just a bit nicer without the @
02:07:17 <int-e> superstar64: as ski said, you need parentheses for the :: Core Kind
02:07:25 <int-e> And the resulting error is awful.
02:07:31 <superstar64> i already mentioned i fixed it
02:07:51 <boxscape> superstar64 surround any calls of Map.! with trace that prints the Map and the key you're trying to get?
02:08:06 <superstar64> when will ghc support stacktraces?
02:08:39 <boxscape> um I think it does but I'm not very well versed in them
02:09:20 <boxscape> you might have to compile with a specific flag or something to get them to show up
02:30:24 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#hascallstack>,<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#stack-traces-in-ghci>,<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger>,<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debug-info.html#requesting-a-stack-trace-from-haskell-code>
02:32:02 <kuribas> Let's say If I have a type SomeApp which is an applicative, but which makes a Monad when I add a function 
02:32:22 <kuribas> pressed enter to soon...
02:33:07 <kuribas> Let's say I have a type SomeApp which is an applicative, and makes a Monad when I add another function.  So data SomeMonad = SomeMonad SomeApp SomeFun.
02:33:46 <kuribas> Is there a way to make a monad instance without including SomeFun for every value of SomeMonad?
02:33:59 <kuribas> SomeFun is always the same function
02:34:16 <ski> does `SomeFun' depend on the result type ?
02:34:50 <kuribas> it doesn't
02:35:35 <kuribas> for example: data PartialData m a = PartialData (Query -> Query) (ResultSet -> a)
02:35:41 <ski> could you just do `newtype SomeMonad a = MkSomeMonad (SomeApp a)', and reference your function of type `SomeFun' directly in the `instance Monad SomeMonad where ...' ?
02:35:41 <kuribas> which formas an applicative
02:36:25 <ski> (where did `m' go ?)
02:36:40 <kuribas> ah right, I don't need m here
02:37:00 <kuribas> and type QueryRunner m = Query -> m ResultSet
02:37:41 <kuribas> ski: I could, but I want it to be generic
02:38:51 <ski>   runPartialData :: Monad m => QueryRunner m -> PartialData a -> Query -> m a  -- ?
02:39:04 <ski> generic, in which sense ?
02:40:04 <kuribas> for example making Query and ResultSet a type variable
02:41:50 <kuribas> (the context is that I am trying to make a dataloader for graphql)
02:41:57 <ski> i don't see why you feel like you have to "including SomeFun for every value of SomeMonad" in the first place
02:44:24 <kuribas> how can I define the monad instance otherwise?
02:45:21 <ski> if you have a global `mySpecificSomeFun :: Query -> Query', then just refer to it in the `instance Monad PartialData where ...' declaration, if that's what you want ?
02:45:51 <ski> (assuming the monad laws will be upheld still)
02:46:09 <kuribas> ski: ah no, it's not global
02:46:21 <ski> then where does it come from ?
02:46:32 <kuribas> ski: it should be defined by the user
02:46:45 <ski> so it's not always the same function ?
02:46:57 <kuribas> no
02:47:20 <kuribas> maybe Class QueryRunner query resultSet m | query -> resultSet
02:47:37 <ski> then i misunderstood what you meant, when you said "SomeFun is always the same function". perhaps you meant, for the extent of a single invocation of `runPartialData'
02:47:49 <kuribas> right, that's what I meant
02:48:14 <kuribas> well, it should be the same function for the same query and resultSet type (see my class above)
02:48:29 <ski> could you use `newtype PartialData a = MkPartialData ((Query -> Query) -> ResultSet -> a)' ?
02:49:10 <kuribas> no, that's different
02:49:53 <kuribas> the cps transform would be MkPartialData ((query -> query) -> (resultSet -> a) -> k)
02:50:26 <ski> (the FD above would make sure the type `resultSet' is determined uniquely by the type `query'. not that the value of type `query -> query' is determined uniquely by the type `resultSet' (and the type `query', if you want to))
02:50:49 <kuribas> indeed
02:51:05 <kuribas> the resultSet is determined by the query type
02:51:21 <kuribas> (query -> query) is different for each value.
02:51:48 <ski> perhaps you want `class QueryFun query where queryFun :: query -> query' and `class QueryFun query => QueryRunner query resultSet m | ... where ...', or something like that
02:52:09 <ski> (i was not thinking of CPS)
02:52:53 <ski> "(query -> query) is different for each value" -- each value of which type ? what value are we talking about ?
02:53:41 <ski> (i was thinking of `ReaderT (Query -> Query) (..) (..)')
02:55:44 <kuribas> hmm, this may actually work: https://gist.github.com/kuribas/dc0721c819925a85666c4a313224aabd
02:57:09 <ski> how are you accumulating/summarizing `queryState' ?
02:57:19 <kuribas> queryState?
02:57:23 <kuribas> you mean query?
02:57:38 <kuribas> that's just (.) 
02:57:45 <ski> i mean the field `queryState :: query -> query' of `PartialData query resultSet m a'
02:57:48 <ski> ok
02:58:18 <ski> could have been either `\f g -> f . g' or `\f g x -> f x <> g x'
02:58:42 <ski> (latter requiring `Monoid query' ..)
02:59:04 <kuribas> more like Endo query
02:59:08 <ski> yep
02:59:46 <kuribas> like this: https://gist.github.com/kuribas/dc0721c819925a85666c4a313224aabd
03:00:22 <kuribas> ski: ah right, queryState is a bad name.  Maybe queryTransformer
03:00:35 <kuribas> or queryAdder
03:01:54 <kuribas> ah, it looks so easy now...
03:02:11 <kuribas> took me a good effort to make it like this...
03:03:13 <kuribas> ski: the idea is to implement a graphql server (using https://hackage.haskell.org/package/graphql), but with a dataloader, which composes the query in parallel.
03:03:27 <kuribas> rather than doing a single SQL query for each object
03:04:28 <ski> mhm
03:04:36 <ski> (that tells me very little)
03:05:33 <kuribas> the library does a traversal over each field
03:06:01 <kuribas> that's the "applicative action".
03:06:08 <kuribas> but the subfields are monadic
03:17:23 <kuribas> hmm, that may not work with this library...
03:17:50 <kuribas> The monad will force a query for every field...
03:19:03 <kuribas> or maybe I can change the extractor to work in parallel
03:30:52 <kuribas> hmm, so in the extractors which recurse on objects, I need to suspend each continuation, collected the results in paralell, then call the continuations...
03:31:18 <kuribas> that looks stricky...
03:52:05 <opposite1996> hi
03:54:55 <opposite1996> hi
03:57:10 <juri_> meep.
04:14:59 <lambda> is there any good reason why there isn't a generic list split function in base (like words, but for any type and delimiter)? is this really such a rare use case I keep running into for some reason?
04:15:42 <kuribas> lambda: https://hackage.haskell.org/package/split-0.2.3.4
04:16:50 <lambda> kuribas: ah, bikeshedding, I see :) thanks
04:45:19 <merijn> lambda: I mean, we don't have arrays or maps in base either :p
04:45:40 <merijn> (And some would argue base is still much too big)
04:52:19 <kuribas> It's small compared to other languages.
04:52:30 <kuribas> Big compared to common lisp though
04:58:25 <carbolymer> any ideas why my popQueue loops infinitely? https://bpa.st/HNOA
04:59:15 <carbolymer> F.alter should in the end return Nothing - and remove queue from map
04:59:46 <carbolymer> I mean - it's not popQueue that loops, but drainQ
05:00:40 <dminuoso> carbolymer: Insert debugging statements?
05:00:53 <dminuoso> unsafeIOtoSTM is useful here
05:01:21 <dminuoso> (Just be aware that STM transactions can be restarted multiple times for various reasons when judging the output)
05:01:32 <carbolymer> hmm
05:01:58 <dminuoso> Or rather, read all the notes relating to unsafeIOtoSTM
05:07:28 <dminuoso> carbolymer: Also, is it a proper evaluation loop, or does the transaction appear to be stuck?
05:08:03 <carbolymer> it just prints "foo" again and again
05:08:10 <carbolymer> so it seems that tx isn't stuck
05:21:53 <carbolymer> when function passed to alter returns Nothing, the element should be removed from the collection, right? https://hackage.haskell.org/package/focus-1.0.1.4/docs/Focus.html#v:alter
05:22:14 <carbolymer> I don't know if I don't understand the docs, or stm-containers immplementation of Focus is faulty
05:22:43 <dminuoso> assuming the implementation is correct, yes
05:23:13 <dminuoso> Using pseudo syntax, `Nothing -> Just ...` is an insertion, `Just ... -> Nothing` is a deletion and `Just ... -> Just ...` is an update
05:23:54 <carbolymer> well damn,  `F.update (NES.nonEmptySeq . NES.tail)` doesn't remove the element if `NES.nonEmptySeq . NES.tail)` returns Nothing
05:24:09 <carbolymer> neither alter do
05:32:18 <halbGefressen> Hi, I am trying to create an AUR package for a Haskell program (https://github.com/lukasstevens/cyp). When installing my program, it complains about the missing library that is required to run the program, which is also built in the repository by running stack build.
05:32:34 <halbGefressen> or rather it complains when trying to run it
05:33:00 <halbGefressen> Because I need ibHScyp-0.2.0.0-263wPg8EQSF297H60K9S4t-ghc8.8.4.so which gets built in the build section
05:36:09 <maerwald> halbGefressen: don't try
05:36:24 <halbGefressen> How do I build into a single binary then?
05:37:05 <maerwald> yes, you can do fully static linking with musl
05:37:09 <maerwald> e.g. on alpine
05:39:25 <halbGefressen> I just want to package that program so that somebody can run it. What is the best method to achieve that?
05:39:43 <maerwald> ask upstream to do releases with static binaries
05:42:04 <maerwald> then can use github workflows for that
05:42:32 <maerwald> here's an example https://github.com/hasufell/stack2cabal/blob/e6fae40d913ed67363671fb7238e74afedd78ffc/.github/workflows/release.yaml
05:42:53 <halbGefressen> Do I even need a static binary? My package depends on glibc already, just this one library doesn't get copied
06:04:31 <carbolymer> damn, delete in stm-containers (or rather focus) is broken :/
07:19:16 <HorseGirl> hello
07:20:58 <wz1000> Where do I find a function to randomly choose (without replacement) n elements from a list?
07:27:49 <adamCS> wz100: How about shuffling the list and taking the first n? http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
07:27:58 <adamCS> wz1000: ^
07:29:14 <merijn> Also, the magical words "Partial Fisher-Yates shuffle"! ;)
07:30:12 <ski> HorseGirl : hello
08:26:55 <gentauro> why does phadej write on /r/haskell that Safe-Haskell should be removed from GHC?
08:26:58 <gentauro> :(
08:29:03 <hpc> he likes to live dangerously - https://www.smbc-comics.com/comic/dangerous
08:30:37 <gentauro> hpc: but it's not gonna happen right? It's just his preferences?
08:30:57 <gentauro> Isn't it like the linear types, if you don't want to use them, you don't?
08:31:27 <merijn> gentauro: There's almost no reasonable use for it, though
08:31:33 <merijn> gentauro: like, what would you use it for?
08:31:34 <int-e> if you have a library you might have people like me approach you with patches that mark modules Trustworthy
08:31:38 <int-e> so there is a cost
08:32:09 <merijn> gentauro: Have you ever actually used SafeHaskell? If so, for what?
08:32:16 <int-e> (in my case because lambdabot relies on SafeHaskell)
08:34:06 <int-e> If this is part of a larger effort to cut down unpopular extensions from ghc I'd not even be opposed... but slashing only SafeHaskell seems unfair.
08:35:09 <gentauro> merijn: yeah pretty much -> uniprocess.org (noticed GitLab hasn't actualized my cert …)
08:35:15 <merijn> int-e: I think phadej was just underlining how useless it basically is
08:36:01 <merijn> gentauro: Oh, if you rely on SafeHaskell for safety in the presence of untrusted code, you're already doomed
08:36:05 <gentauro> merijn: I use it for `sanity` and to exclude `stuff` GHC don't really trust
08:36:16 <gentauro> merijn: how come?
08:36:36 <gentauro> safe haskell tells me that Data.Text isn't "good" and therefore can't be trusted. I like that
08:36:38 <merijn> gentauro: It's fairly trivial to bypass and escape
08:36:50 <gentauro> merijn: could you elaborate?
08:37:06 <int-e> gentauro: so how do you decide what to trust?
08:37:07 <merijn> gentauro: "enabling -XGeneralizedNewtypeDeriving" is sufficient to implement unsafeCoerce and therefore completely bypass SafeHaskell
08:37:26 <int-e> also you're bound to have to trust base and that's a can of worms right there
08:37:46 <gentauro> int-e: I noticed that
08:38:02 <int-e> merijn: is it? I thought it was supposed to use `coerce` now and thereby by type-safe.
08:38:04 <merijn> gentauro: Basically, there's almost no work in defining how SafeHaskell should interact with any of the extensions introduced after it (or even before it)
08:38:12 <gentauro> merijn: so you are telling me that `-XXGeneralizedNewtypeDeriving` should be removed instead? xD
08:38:23 <merijn> int-e: It's not about the code generated by GeneralizedNewtypeDeriving
08:38:37 <merijn> gentauro: I'm not saying that
08:38:42 <int-e> merijn: but?
08:38:45 <gentauro> I am :)
08:39:14 <merijn> int-e: Lemme lookup the blogpost
08:39:31 <int-e> merijn: I mean I know of an old technique that does exactly what you said, and I was under the impression that when `coerce` was implemented that particular hole got plugged.
08:40:13 <int-e> and that, in fact, this was a key motivation for tackling safe coercions.
08:40:28 <gentauro> but merijn it's possible to remove PRAGMAS with GHC flags right? So it wouldn't really be a problem on SafeHaskell project
08:40:57 <merijn> gentauro: Sure, it just means "not allowing people to use a number of widely used extensions", so that rules out tons of code you might wanna use
08:41:02 <merijn> int-e: hmm, maybe
08:41:29 <merijn> int-e: It's pretty likely a number of other extensions bypass SafeHaskell anyway, so my point stands even without GND ;)
08:41:39 <gentauro> 17:40 < merijn> gentauro: Sure, it just means "not allowing people to use a number of widely used extensions"
08:41:42 <gentauro> yes please :)
08:41:51 <gentauro> I'm scared of the one that turns on 200 extensions :o
08:42:04 <gentauro> those codebases will not be maintanable
08:42:06 <gentauro> :(
08:42:53 <int-e> merijn: let me know if you find something concrete
08:43:01 <int-e> :)
08:43:20 <int-e> I do share the uneasy feeling.
08:43:33 <gentauro> merijn: yeah, I would like to read that blogpoast as well :)
08:43:37 <merijn> int-e: TypeFamilies and GADTs are known unsafe, afaik
08:44:27 <merijn> gentauro: Of course, even without bypassing SafeHaskell running untrusted Haskell is still unsafe. DOS attacks are fairly trivial
08:44:38 <int-e> merijn: well not according to ghc itself
08:45:24 <int-e> (There's no complaint with {-# LANGUAGE Safe, GADTs, TypeFamilies #-})
08:46:13 <gentauro> merijn: I use this for many of my `cli` projects -> https://hackage.haskell.org/package/echo-0.1.3/docs/System-IO-Echo.html I like that something that I type in my passwords with, is actually Safe !!!
08:46:31 <merijn> gentauro: What do you think "Safe" means?
08:46:56 <merijn> Because I fail to see how "typing passwords" is relevant for that
08:46:58 <gentauro> I have read the paper from the 2xDavids and 2xSimons
08:47:13 <int-e> "Safe" means you can't subvert the type system. Basically, the promise is that you can't implement unsafeCoerce unless you trust a broken library that allows it.
08:47:16 <gentauro> merijn: it means that nothing `suspect` happens `under the hood`
08:47:32 <int-e> (That's my understanding.)
08:47:34 <merijn> gentauro: It does not
08:47:37 <gentauro> int-e: explained it way better
08:47:43 <merijn> Right
08:48:02 <merijn> But you can still forward someone's password to a webserver without violating the type system...
08:48:19 <int-e> So GND (before `coerce`) is decidably unsafe.
08:48:34 <merijn> A package like echo could literally send everything you type to a webserver and still be SafeHaskell
08:48:54 <merijn> So I'm not sure what peace of mind you get from "Safe"
08:48:55 <int-e> So is Typeable if anybody every puts the required effort into a hash collision (it's MD5 but the data isn't binary so the cheap attacks don't seem to apply)
08:49:21 <gentauro> 17:47 < merijn> But you can still forward someone's password to a webserver without violating the type system...
08:49:37 <gentauro> yes, if you allow global IO, but I tend to restrict my IO (granualary)
08:49:40 <int-e> It's a very modest notion of safety.
08:49:54 <gentauro> so as long as GHC type-system is trustable, I think I got that solved
08:50:59 <gentauro> solved = covered
08:51:01 <merijn> gentauro: But echo is in IO, so it being Safe does nothing
08:51:22 <int-e> merijn: The thing about GADTs and TypeFamilies is that any unsafety in the SafeHaskell sense would really mean that the underlying type system is unsound. And that's something SPJ and goldfire and co really care about quite strongly.
08:52:54 <int-e> merijn: if you allow IO you're screwed
08:53:03 <gentauro> merijn: you can even use Foreign ptr and stuff like that and make the module Safe to Haskell -> http://blog.stermon.com/articles/2019/02/04/haskell-usage-of-malloc-free-is-safe.html
08:53:11 <gentauro> but you MUST expose that you are doing IO
08:53:31 <gentauro> so you know `stuff` happens under the hood
08:53:35 <int-e> merijn: "screwed" if your notion of safety requires no arbitrary effects
08:54:02 <merijn> int-e: Sure, but if your notion of safety doesn't require that, then Safe Haskell is redundant :p
08:54:03 <gentauro> but if you try to hide `IO` away with `unsafePerformIO`, you will get an error
08:54:19 <merijn> int-e: Hence, my original quesiton
08:54:23 <merijn> Safe *from what*
08:54:27 <int-e> merijn: so you have to do something that never runs untrusted IO values
08:54:30 <merijn> And why does it warrant worrying
08:54:51 <int-e> (which is why lambdabot doesn't allow IO)
08:55:13 <merijn> int-e: But that still means auditing all the IO in your transitive dependencies
08:55:21 <int-e> merijn: no
08:55:22 <merijn> int-e: Which I'm pretty sure no one ever does :p
08:55:26 <int-e> merijn: because you can't run them
08:55:34 <int-e> > print ""
08:55:39 <lambdabot>  <IO ()>
08:55:42 <merijn> int-e: I wasn't refering to lambdabot
08:55:46 <gentauro> int-e: this is how I handle IO (ask described in the Safe Haskell paper) -> https://uniprocess.org/effects.html
08:55:53 <gentauro> (updated the GitLab certificate)
08:56:10 <merijn> int-e: I was referring to "never run untrusted IO values" <- you have to audit the IO in all your transitive dependencies to do that
08:56:37 <int-e> merijn: *if* you allow your untrusted code to run IO actions then yes, you have to audit them transitively. and you'l end up in base where obviously many things in IO are too risky to expose
08:57:01 <int-e> The solution is to not allow your untrusted code to run IO at all.
08:57:16 <merijn> int-e: No I'm literally talking about "code you write yourself that uses dependencies"
08:57:36 <int-e> We're obviously arguing with different goals in mind.
08:57:45 <merijn> int-e: My point is: You can't trust dependencies to not do bad things without auditing them, because Safe Haskell doesn't prevent that
08:58:16 <merijn> int-e: I cannot trust my use of the "echo" package to be safe, even if I myself write the code that does that
08:58:17 <gentauro> merijn: that's the hole point of trust ;)
08:58:24 <int-e> I'm protecting against random IRC users that want to abuse lambdabot. The libraries that lambdabot relies on are, by and large, and for better or worse, part of the trusted code base.
08:59:13 <int-e> I have actually made an effort to audit modules marked Trustworthy... outside of base.
08:59:29 <merijn> int-e: And redone so every upstream version? ;)
08:59:52 <int-e> merijn: take a guess. (somewhat, but not nearly as diligently)
09:00:39 <int-e> I have a namespace based sandbox as well, because...
09:00:49 <Logio> merijn: are you saying that as it stands now, I cannot get any guarantees of purity about packages marked as Safe?
09:00:53 <int-e> (linux namespaces)
09:01:46 <merijn> Logio: Define "guarantee" and "purity" :)
09:02:10 <int-e> Logio: you get the guarantee that any not-Safe module gets imported through (or is) a Trustworthy module in a trusted package.
09:02:16 <gentauro> merijn: the sentence from SPJ about launching the missiles :P
09:02:23 <merijn> int-e: Right, but most of the reddit proponents of SafeHaskell don't consider any of these things :)
09:02:45 <merijn> int-e: And once you have the sandbox the only real issue with lambdabot is it spamming the channel
09:02:48 <int-e> Logio: on top of that you get all the guarantees that the type system provides... assuming it is sound (which is up to ghc)
09:02:55 <merijn> And most of SafeHaskell becomes irrelevant :)
09:03:31 <int-e> merijn: Well I feel better about the sandbox not being the first line of defense.
09:03:32 <merijn> Logio: Anyway, what I'm really saying is that the guarantees Safe gives you are mostly worthless
09:03:35 <Logio> merijn: I mean, running IO actions and having side effects
09:03:41 <int-e> And I also like SafeHaskell on an intellectual level.
09:03:58 <merijn> SafeHaskell is conceptually neat, but practically worthless
09:04:20 <Logio> merijn: I'm mostly conserned with things touching the filesystem without me knowing about it
09:04:24 <merijn> In that they don't protect against threat models people actually have
09:04:58 <gentauro> so this is useless? https://gitlab.com/uniprocess/haskell-template/-/blob/master/pkg/granulated/package.core.yaml#L4-12
09:05:00 <merijn> Logio: Well, a completely Safe package could still ruin your filesystem at compile time :p
09:05:09 <int-e> Well, obviously I think it has some practical value.
09:05:16 <merijn> (Or does SafeHaskell disallow TemplateHaskell?)
09:05:23 <Logio> I've been bitten by Python packages that did stupid stuff like running executables on import (for non-nefarious, but stupid reasons)
09:05:30 <gentauro> merijn: yes it does ;)
09:05:35 <merijn> gentauro: What's your threat model?
09:05:39 <int-e> merijn: Of course it does :)
09:06:03 <gentauro> merijn: I don't trust anybody, specially myself ;)
09:06:17 <merijn> Question #1 of any safety/security issue is always: What's your threat model?
09:06:25 <int-e> Which is why I'm mostly worried about *subtle* holes in SafeHaskell... and those that are there by design (trusting a broken or subverted library)
09:07:19 <gentauro> I mean, aren't all these arguments on why to use a `pure` programming language?
09:07:21 <int-e> merijn: SafeHaskell has a big marketing problem... it's probably oversold, lifting expectations in it to a level that it can't meet.
09:07:35 <int-e> But that doesn't make it useless.
09:07:49 * int-e shrugs.
09:08:00 <Logio> merijn: my threats are not about running untrusted code (in the nefarious sense), they're about statically determining that the code does no IO that might interfere with parallel execution, etc.
09:08:44 <merijn> Logio: I mean, you don't really need SafeHaskell for that, tbh. Unsafe is generally so unsafe that it breaks rather quickly, so most people avoid it anyway
09:09:14 <merijn> Logio: Like, I doubt you'll find many packages that actually end up using unsafePerformIO
09:09:17 <Logio> merijn: yes, but I'm not guarding myself from the bad decisions of most people, but the stupid ones
09:09:30 <merijn> And the ones that do are generally things like bytestring
09:09:45 <int-e> merijn: foreign import unsafe ...
09:09:46 <merijn> Logio: Stupid people can't use unsafeX in any remotely reliable way, it's too hard :p
09:09:56 <int-e> actually just foreign import
09:10:07 <merijn> int-e: The unsafe there doesn't refer to IO at all :p
09:10:12 <Logio> merijn: but they might at least realize that they are doing something stupid if their compile fails
09:10:17 <int-e> merijn: I was going to say that that's a misnomer
09:10:25 <gentauro> int-e: SafeHaskell (and rio) without this -> https://gitlab.com/uniprocess/haskell-template/-/blob/master/pkg/isolatedio/src/Uniprocess/Effects/Restricted/Instances.hs#L44-55 isnt' very usefull (combined with the trust of packages of well ofc)
09:10:25 <merijn> int-e: Sure, but not many people foreign importing without IO
09:10:39 <int-e> merijn: but they could.
09:10:47 <merijn> Logio: I never check safe Haskell and I haven't hit issues like that in practice
09:10:49 <Logio> and the stupid person might also be me, writing debug code somewhere that it shouldn't be
09:11:07 <int-e> and when they do, they basically have unsafePerformIO in their code without realizing it.
09:12:05 <gentauro> SafeHaskell and Debug.trace don't play well together
09:12:26 <int-e> gentauro: duh :)
09:12:26 <gentauro> btw, you can't even start GHCi if your project is marked as -XSafe
09:12:30 <Logio> merijn: so what will you do when you do hit an issue like that? 
09:12:52 <int-e> gentauro: and you can bypass it using your own trustworthy reexport of Debug.Trace... if that's what you want
09:12:53 <gentauro> I find that annoying when developing (I turn it off) but when I'm done, I turn it on again ;)
09:13:15 <int-e> the ghci thing *is* annoying though
09:13:21 <gentauro> int-e: as long as you comply with exposing the IO so it complies with the type-system
09:13:31 <gentauro> but if you try do `hide` something, you get a DENY from GHC
09:13:33 <gentauro> ;)
09:13:40 <gentauro> I spent so much time with this xD
09:13:52 <int-e> or rather was... I think this is fixed in ghc 8.8?
09:14:19 <merijn> Logio: I mean, it hasn't happened in about 10+ years of Haskell, so it's not something I worry about
09:15:13 <gentauro> merijn: my only point is that I would be really sad if they just remove it from GHC cos some NSA agents, I mean some people find it annoying xD
09:16:32 <Logio> merijn: sure, I'm probably just a bit paranoid having seen what Python packages are willing to do to mess with you
09:16:50 <gentauro> anybody know if the peeps from Galois is using SafeHaskell for some of their projects?
09:17:19 <gentauro> I guess they have some high-level-sec reqs from their Government contracts right?
09:17:34 <Logio> the thing is though, I would rather have some mechanism of guarding (or at least alerting) me from stupidity, and not just hope that people know what they are doing
09:17:38 <gentauro> (does anybody know any of Galois Haskell projects?)
09:18:10 <merijn> Logio: Well, a key difference compared to python is that modules can't run any code unless you call it :p
09:18:52 <Logio> merijn: and I would like that to be true for any function not typed IO
09:21:43 <Logio> I don't want to find out later that your supposedly pure algorithm goes and phones wolframalpha.com for answers (which is not far off from things I've seen Python people do)
09:23:09 <gentauro> Logio: slide number 10 -> http://blog.stermon.com/assets/talks/2019-04-08_foss-north-limiting-side-effects-of-applications-at-compile-time.pdf ssh-decorator was sending your private keys to the author …
09:23:32 <gentauro> that's stuff I would like to remove from my codebase … and that's the reason I "really, really" try to use SafeHaskell
09:24:59 <gentauro> and you get to think on a another level when you try to solve problems. This is a good summary on using SafeHaskell -> http://blog.stermon.com/articles/2019/02/21/the-main-reason-i-use-safe-haskell-is-restriction.html
09:25:03 <gentauro> ;) 
09:25:48 <gentauro> in my book, forcing yourself to use SafeHaskell, will make you a better Haskell dev
09:26:09 <gentauro> (in some obscure and unhealty way xD)
09:26:48 <Logio> that's a bit beside my point, since that package would'be always been about having side effects
09:27:36 <Logio> If I run anything typed IO from anyone elses package, I expect missiles to be launched 
09:28:26 <gentauro> Logio: unless you avoid it :P
09:28:27 <Logio> if it's not, I want my compiler to assure me that that's not happening
09:28:45 <Athas> I don't think Safe Haskell will be removed, even if I also think it is not very useful.  I recall that it was described as easy to implement and maintain.
09:29:15 <Logio> the latter case is something that should not require trust
09:29:21 <gentauro> Logio: slides 17-21 -> http://blog.stermon.com/assets/talks/2019-04-08_foss-north-limiting-side-effects-of-applications-at-compile-time.pdf
09:29:32 <gentauro> you can't actually design your way out of it ;)
09:30:04 <gentauro> and for me that's a really powerfull thing when it comes to security
09:30:28 <Kronic> It took a long time but I finally understand how use megaparsec to solve some of the AOC problems. Embarassingly what confused me the most was where the combinators were coming from 
09:30:53 <gentauro> btw, Kris Jenkins (at Tweag.io who does a lot of Elm and PureScript) said that Global IO in Haskell is as bad as Global variables in imperative/OO languages. And I somehow tend to agree
09:31:42 <gentauro> 18:28 < Athas> I don't think Safe Haskell will be removed, even if I also think it is not very useful.  I recall that it was described as easy to implement and maintain.
09:31:53 <gentauro> Athas: if it happens, I guess it would be time to move to Futhark ;)
09:34:11 <dsal> Kronic: that's pretty normal, afaict
09:34:47 <sm[m]> Agreed, you and all of us Kronic
09:35:31 <dminuoso> Kronic: Overall, I dont think AOC is a good way to learn megaparsec.
09:36:25 <dminuoso> In my opinion, the ideal way to write parsers with parser combinators like megaparsec, is by trying to formulate production rules in BNF, and then match your code with the BNF as much as possible.
09:36:37 <sm[m]> it sure has caused a wave of new megaparsec learners..
09:36:53 <gentauro> dminuoso: you have to start small …
09:36:53 <dminuoso> Rather than trying to make an ad-hoc thing
09:37:02 <dminuoso> gentauro: Then start with a simple grammar!
09:37:23 <dminuoso> monochrom has a lot to say about folks trying to skip the theory and just "get practical first"
09:37:25 <gentauro> dminuoso: most people (no academic background) don't know what a grammar is ;)
09:37:36 <dminuoso> So learn about grammars then?
09:37:41 <dsal> I tend to read manuals later.
09:38:04 <gentauro> dminuoso: to drive a car, you don't need to know how the engine works right?
09:38:05 <sm[m]> I agree with dminuoso, these days I always write a grammar as a comment before writing any non trivial parser
09:38:24 <gentauro> to compile your application, you don't need to know how the compiler works right?
09:38:24 <dminuoso> gentauro: The analogy is deeply flawed.
09:38:31 <dsal> If you want to make crushed ice, you have to have a strong physics background.
09:39:07 <gentauro> dminuoso: might be, but it still delivers the point ;)
09:39:17 <sm[m]> Iwrite a spec to know what correct parser behaviour is
09:39:36 <Kronic> A fair few people told me that AOC is not a good way to learn it but I wansn't using megaparsec to solve AOC, it's the other way around
09:39:42 <dsal> For real projects, I often just write a config file in the format I want, then write a parser for that, then use my software.
09:40:05 <dsal> Kronic: AoC isn't a good way to learn megaparsec because the parsing you get to do is typically pretty limited.
09:40:23 <sm[m]> surely that's good when starting ?
09:40:29 <glguy> aoc seems like a fine way to learn megaparsec
09:40:32 <dsal> But it's a good way to learn megaparsec because you at least can use it some, and I learn nice little things.
09:40:36 <gentauro> glguy: I agree
09:40:43 <glguy> you get some easy stuff to learn on, and if something really complicated you shouldn't be using parser combinators anyway
09:40:54 <gentauro> basic examples that get you `hooked` on the power of `parser combinators`
09:41:01 <ephemient> there were some more interesting inputs to parse in past years
09:41:08 <ephemient> not much this year so far though
09:41:10 <gentauro> for that point, if you are more interesed, then learn more about parsing and
09:41:12 <dminuoso> My main beef with parser combinators here, is that they have way too much adhoc power.
09:41:31 <gentauro> 18:40 < ephemient> not much this year so far though
09:41:35 <gentauro> ephemient: I agree :)
09:41:39 <dsal> ephemient: Yeah, I can't remember whether input was harder to parse, or I'm just better at parsing because I've written a lot of parsers since then.
09:42:09 <glguy> I can only think of a couple AoC problems that were close to hard to parse over the years
09:43:29 <glguy> 2018 day 24 was more annoying
09:43:30 <Kronic> Generally I tune out anything like that, megaparsec is clearly very robust but I would not want to have to try to learn it in the context of something much more complicated because I find when that is the case, stuff inside my head is fighting for room. AOC let me just ignore the problem and focus on the solution. 
09:43:51 <Kronic> I mean, there is a reason that during a driving test they make you go around the car park at first 
09:44:08 <glguy> megaparsec is particularly good for aoc because its error messages can help with debugging your parser as you write it
09:44:27 <thunderseethe> Is there a way to construct a type level function that behaves like `(\i -> a i -> b i)`?
09:45:47 <ephemient> <off-topic> eh, my driving lessons and driving test went out onto public roads right away
09:45:49 <solonarv> sure: type AB i = A i -> B i -- for example
09:46:08 <solonarv> although this isn't quite a "type-level function" since you must fully apply it
09:46:11 <thunderseethe> Or I guess like, a type alias `type Fn a b i = a i -> b i` except `Fn a b` is valid as a type
09:46:23 <thunderseethe> Ah yeah, I need the partial application specifically
09:46:32 <ski> s/is/isn't/
09:46:56 <glguy> Parsing AoC 2017 Day 25 was rather annoying, too
09:47:00 <ski> where do you need it ?
09:47:24 <sm[m]> #haskell driving instruction: throw you out in a F1 car on day 1 :)
09:47:28 <glguy> but maybe not so much hard as tedious
09:48:06 <thunderseethe> or perhaps I'm misguided in general. I'm trying to put together an indexed applicative class with sig `class IxFunctor f => IxApplicative (f :: (Type -> Type) -> Type -> Type) where` and struggling with sig for `<*>`
09:48:53 <thunderseethe> I assume I need something like `f (\i a i -> b i) i -> f a i -> f b i` but I would not be surprised if my approach if fundamentally flawed
09:50:38 <solonarv> I've mostly seen "IxApplicative" defined like so: class IxApplicative (f :: k -> k -> Type -> Tyoe) where ipure :: a -> f i i a; (<*@>) :: f i j (a -> b) -> f j k a -> f i k b
09:50:38 <ski> thunderseethe : that doesn't kind-check
09:50:46 <solonarv> note that there are *two* indices!
09:51:20 <ski> (perhaps not use `k' for two different things)
09:51:29 <solonarv> oh, oops ;)
09:52:55 <ski> thunderseethe : i guess you actually meant `\i -> a i -> b i', when you said `\i a i -> b i' there ?
09:53:06 <thunderseethe> yes
09:54:09 <thunderseethe> with the `k -> k -> Type -> Type` is the idea that by foregoing `(Type -> Type)` we avoid needing (->) specifically and sidestep the type level partial application?
09:56:19 <ski> the usual thing people want, when they do "indexed monad" is to express a kind of "binary relations" on these indices. so `return' ends up expressing reflexivity on the indices, and `(>>=)' (or `join', if you prefer) ends up expressing transitivity
09:57:50 <ski> while it looks like you're wanting to express functors, not on `Type', but on `ki -> Type', where `ki' is whatever the kind of your indices you want to have
09:59:31 <ski> (still endofunctors, just like `Functor' expresses endofunctors on concrete Haskell types. only difference is that you want to express endofunctors on types parameterized on input type of kind `ki', and then want to have an applicative version of these functors)
09:59:50 <ski> thunderseethe : anyway, try `newtype'
10:00:23 <thunderseethe> That may be the case but I'm not following your throughline, if I swap to `f :: (ki -> Type) -> Type -> Type` For a given concrete `ki` I'm in the same spot right wrt to my `<*>` def?
10:01:06 <ski> the situation i was describing would be `f :: (ki -> Type) -> (ki -> Type)' (only you had `ki = Type' above)
10:01:49 <thunderseethe> by newtype do you mean somthing like `newtype Fn a b i = Fn (a i -> b i)`?
10:01:58 <ski> yes
10:02:22 <ski> (i'm not too sure it makes sense in your situation, but you can try it and see ?)
10:03:09 <thunderseethe> Is there a way I can do that without it influencing the remainder of my api? My reservation with a newtype is that anyone consuming `<*>` would require wrapping their base (->) in my `Fn` wrapper
10:03:23 <thunderseethe> not the end of the world, but I'd like to avoid it if possible
10:04:51 <ski> (the question would be : if `C' and `KI' are categories, and `C' is cartesian closed, is `C^KI' also cartesian closed, and is the exponential `F -> G' in it the functor that maps `I' (in `KI') to the exponential object `F I -> G I' ?)
10:05:34 <dolio> "Yes" and "no".
10:06:42 <thunderseethe> I don't think that's the question, but maybe
10:07:28 <ski> is the latter salvagable by some "reasonable" extra assumptions ? or is there some other "interesting" modification that would hold ?
10:07:30 <dolio> Actually, that might require qualifiers. C needs to have tensors by homs of KI, I think.
10:09:11 <dolio> Maybe if KI is discrete it would reduce to that.
10:09:45 <thunderseethe> KI is `Type` so I'd guess that implies it's hask?
10:09:50 <ski> thunderseethe : i was thinking perhaps you could yoneda or coyoneda it (by which i mean, being able to "lift" `\i -> a i -> b i' out into a context, where you could hopefully saturate the application), but then i recalled that you're exactly trying to express that `f' is a functor, so i don't think that'd work ..
10:10:10 <thunderseethe> Ah yeah
10:11:35 <dolio> ski: The reason what you said doesn't work is that it's not functorial, so it needs to be fixed up by doing `forall r. (i -> r) -> F r -> G r` instead.
10:11:41 <ezzieyguywuf> lol, search results for "haskell cassava" https://i.imgur.com/Xcb8zY1.png
10:11:45 <ski> (if `F' is a functor, then `F T' is (yoneda) equivalent to `forall a. (T -> a) -> F a', and (coyoneda) to `exists a. (F a,a -> T)'. so, using either of those, you can "lift" `T' out of `F')
10:11:51 <dolio> Like Kripke semantics.
10:12:37 <ski> dolio : oh, right. of course
10:12:53 <ski> (you just yonedaed it)
10:13:10 <ski> (how's it like Kripke semantics ?)
10:13:36 <dolio> Implication works the same way. Quantify over all worlds in one direction.
10:13:58 <ski> hm, i see
10:13:58 <monochrom> haha ezzieyguywuf
10:14:04 <ski> interesting observation
10:14:29 <dolio> Because otherwise it wouldn't be appropriately monotone.
10:14:44 <ski> (reminds me of some modal logic whose Kripke semantics used a ternary relation, for interpreting implication)
10:15:01 <ski> yea
10:15:58 <ski> (something like `forall v,w. R u v w -> F v -> G w'. might misremember the quantifiers)
10:20:29 <dolio> So basically, presheaves become a generalization of the stuff used in Kripke semantics, and when you use presheaves as to interpret logic people call it Kripke-Joyal semantics, I think.
10:20:54 <ski> mhm
10:21:04 <dolio> Or maybe sheaves as well.
10:21:54 <ski> have presheaves been used for modal stuff ?
10:23:01 <dolio> Probably.
10:25:48 <ski> hmm. so `forall r. (i -> r) -> F r -> G r' is actually like `[] (F -> G)' (interpreting `F -> G' here plain pointwise, as thunderseethe wanted), since `[] F T' is `forall a. (T -> a) -> F a' (and `<> F T' is `exists a. (F a,a -> T)')
10:27:19 <dolio> `[](F -> G)` would be `λ j -> forall i r. (i -> r) -> F r -> G r` I believe.
10:27:46 <ski> yea, forgot to abstract over `i'
10:28:17 <ski> hm, oh. you quantified `i'. what's `j' for then ?
10:28:39 <dolio> Every proposition in modal logic is interpreted as a functor from the worlds.
10:29:00 <ski> yes, i should have said `\i -> forall r. (i -> r) -> F r -> G r' is actually like `[] (F -> G)'
10:29:16 <dolio> It's not, though. That is just `F -> G`.
10:30:57 <dolio> Well, I guess if you're talking about classical modal logic, it might be.
10:31:23 <dolio> What I'm talking about is the semantics for intuitionistic logic, I guess.
10:32:03 <ski> well, i'm interpreting `[] F' (interior of `F') by `\u -> forall v. (u -> v) -> F v', and taking `F -> G' in `[] (F -> G)' to mean exactly `\i -> F i -> G i' (which is not monotone / upper / a functor)
10:33:12 <ski> yea, i was first thinking about Kripke for intuitionistic logic, and then thinking about the usual Kripke for modal logic, interpreting `[]' and `<>' as switching worlds (and then thinking of `[]' and `<>' as yoneda and coyoneda in this functor setting)
10:34:49 <ski> so yoneda / necessity is used to make the interpretation of implication monotone, because it wouldn't otherwise be, because of the contravariance
10:35:07 <dolio> Yeah.
10:35:56 <ski> (and i hadn't noticed before that that could be seen as a reason for the modal interpretation of intuitionistic logic wrapping implication in necessity)
10:38:14 <operand> How do I "cast" an Int to an Integer?
10:38:28 <operand> It's quite difficult to find on Hoogle
10:38:35 <hpc> @hoogle Int -> Integer
10:38:36 <lambdabot> Test.DejaFu.SCT.Internal toId :: Coercible Id a => Int -> a
10:38:36 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
10:38:36 <lambdabot> GHC.Real toInteger :: Integral a => a -> Integer
10:38:48 <hpc> toInteger :P
10:38:53 <operand> Thanks! :P
10:38:57 <hpc> what were you searching for?
10:39:07 <operand> I somehow didnt think of searching for a type signature... I've mostly used hoogle to look up the signatures of names rather than the other way around
10:39:16 <hpc> ah yep, that'll do it
10:39:21 <teddyc> wow hoogle bot. really cool
10:39:23 <hpc> i always start with type signatures
10:39:28 <ski> @type fromInteger
10:39:30 <lambdabot> Num a => Integer -> a
10:39:31 <ski> @type fromIntegral
10:39:33 <lambdabot> (Integral a, Num b) => a -> b
10:39:53 <ski> @src fromIntegral
10:39:54 <lambdabot> fromIntegral = fromInteger . toInteger
10:40:22 <ski> @type realToFrac
10:40:26 <lambdabot> (Real a, Fractional b) => a -> b
10:40:27 <ski> @src realToFrac
10:40:27 <lambdabot> realToFrac = fromRational . toRational
11:08:18 <dminuoso> operand: As an additional primitive to be aware of: toIntegralSized for converting into a smaller numeric type without loss by including a runtime check
11:08:31 <dminuoso> (That is, between any two Integral types)
11:36:39 <justsomeguy> Out of curiosity, is there a way to persist type information to runtime (so for example, a function can query the type of new input values)? Or is the type system completely static?
11:37:25 <solonarv> you can do that, yes, that's what Typeable and the related machinery do
11:38:01 <merijn> justsomeguy: It's completely static, but that doesn't mean you can't do fascinating dynamic looking hacks :p
11:38:07 <merijn> :t cast
11:38:09 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
11:38:22 <mniip> a TypeRep is a complete runtime description of a concrete type
11:38:25 <merijn> > cast True :: Maybe Int
11:38:28 <lambdabot>  Nothing
11:38:32 <merijn> > cast True :: Maybe Bool
11:38:35 <lambdabot>  Just True
11:38:51 <mniip> Typeable is the (compiler-managed) typeclass that associates a type with its TypeRep
11:39:01 <merijn> justsomeguy: There's also the Dynamic type, which is basically built on top of Typeable and cast
11:39:04 <mniip> Dynamic is a pair of a value and its TypeRep
11:39:16 <merijn> @hoogle Dynamic
11:39:17 <lambdabot> module Data.Dynamic
11:39:17 <lambdabot> Data.Dynamic data Dynamic
11:39:17 <lambdabot> Data.Dynamic Dynamic :: forall a . TypeRep a -> a -> Dynamic
11:40:06 <mniip> I wonder what happens if you codensity dynamic
11:40:37 <mniip> data Dynamic where Dynamic :: (forall b. Typeable b => Maybe b) -> Dynamic
11:41:20 <solonarv> looks to me like a DMap TypeRep Identity
11:41:59 <Kronic> with the haskell plugin in vscode is there a way to see what the type of something under the cursor is instead of on mouse hover ?
11:44:46 <mniip> solonarv, hmm I haven't thought about that
11:44:51 <mniip> you could store multiple types
11:45:22 <mniip> I guess the correct codensity would be
11:45:32 <mniip> ((forall a. Typeable a => a -> r) -> r)
11:45:42 <solonarv> eh, not quite the same becaose you can't go write fwd :: Dynamic -> DMap TypeRep Identity
11:46:01 <solonarv> (since there's no way to get "all the typereps for which this is Just")
11:46:25 <mniip> it is to DMap as function is to Map
11:47:36 <solonarv> yeah
11:49:19 <justsomeguy> It's interesting how Haaskell has these facilities for introspection, even though its type system starts from a completely different place than the other languages I've used (Python, JS). ...I'm going to have to read through Data.Typeable and the paper for Type.Reflection.
12:01:09 <quarters> hello. while I'm able to run stack just fine on arch linux, the ~/.stack directory is at least 2x that of ~/.cabal . I was hoping to use cabal for this reason, but it sounds like arch package maintainers abandoned haskell.  that said, I was considering using the haskell docker image to develop with, but wasn't quite sure how to go about doing this. I'm using vs code for development and was considering using the dev container feature for this
12:02:31 <merijn> quarters: cabal/ghc work fine, just don't use the Arch packages to install them. You can either use ghcup or consult the Arch wiki (which I think has a lot of info on how to fix/work around their broken Haskell environment)
12:07:52 <quarters> merijn: thanks. I'll look into using ghcup right now. the issue I was having (in case a solution's been found for this) is the one described here: https://bbs.archlinux.org/viewtopic.php?id=230166
12:11:21 <merijn> quarters: The problem is that Arch maintainers *intentionally* ship a broken GHC configuration
12:12:18 <merijn> quarters: Specifically, they *only* ship the dynamic library versions of packages, but by default GHC uses static linking. Which leads it to complain about missing static libraries when used normally, since those are intentionally not installed
12:12:39 <merijn> quarters: So the fix is (as I said initially) to not use any of the Arch Haskell packages
12:13:29 <merijn> I think you can get a non-broken GHC via ghc-static, but consult the Arch wiki for details
12:14:48 <geekosaur> that gets you the missing part of ghc itself but not of any other haskell libs installed via arch
12:18:55 <merijn> Sure
12:24:04 <quarters> merijn: gotcha. thanks. is running "cabal run" in the project directory doing it wrong? that is, do I need to specify the project name as an argument?
12:25:07 <quarters> running cabal run sets off a long list of what looks like libraries/packages and it's been running for the past 10 minutes
12:27:53 <merijn> quarters: It's installing all the dependencies needed to build your project so it can be run
12:28:12 <merijn> Which, depending on the project and the number of dependencies can take a while, yes
12:30:18 <quarters> merijn: ah. ok. I've only included base and scotty for this project. I'm guessing that the dependencies that are downloaded are globally installed rather than on a project by project basis?
12:31:03 <merijn> They are globally installed and shared "as possible", yes
12:36:52 <quarters> awesome. thanks!
12:38:28 <aplainzetakind> My ~/.cabal is getting pretty huge from all the v2-installs of various projects and ghc versions. I can't break anything by manually removing things from ~/.cabal/packages/hackage.haskell.org/ right?
12:38:32 <aplainzetakind> Like, everything.
12:38:44 <aplainzetakind> They'd be rebuilt as needed?
12:39:02 <sclv> the store holds the installs
12:39:08 <sclv> that dir just caches downloaded tarballs
12:39:22 <sclv> but if you delete from the store selectively it invalidates the index and _everything_ breaks
12:39:29 <sclv> so you have to delete the store all at once or not at all
12:39:51 <monochrom> ~/.cabal/packages/hackage.haskell.org holds downloaded tarball and the result of "cabal update" only.
12:40:25 <monochrom> If you no longer use GHC 8.6.3, for example, you can erase ~/.cabal/store/ghc-8.6.3
12:41:09 <monochrom> If you're OK with scorched earth and rebuilding every lib you actually use today for the actual GHC version you use today, it's also OK to erase all of ~/.cabal/store
12:41:51 <aplainzetakind> Alright, there are quite a few ghc folders there. Most can go probably.
12:45:36 <monochrom> Actually you can also do precision surgical delete if you know how to use "ghc-pkg --package-db=$HOME/.cabal/store/ghc-<version> unregister" first.
12:46:44 <monochrom> err, $HOME/.cabal/store/ghc-<version>/package.db
12:47:53 <aplainzetakind> Well I didn't even know ghc-pkg was a thing.
12:48:28 <merijn> aplainzetakind: ~/.cabal/store/ghc-X.Y can be safely nuked
12:49:00 <merijn> aplainzetakind: Of course your first few compiles after that will be *super* slow, but it's fine
12:49:36 <merijn> There's also some experimental tools for cleaning up the store, but tbh they're more bother than they're worth
12:58:45 <alestane> Greetings; I am fairly new to Haskell and am taking my first crack at producing code that generates some output, asks the user if they want to continue, generates some more if they say yes, asks them again, and so on. I've looked at several examples and explanations so far. One solution appears to be to use a recursive function; however, I also had the notion to generate a lazily evaluated list of user inputs and feed it to a 
12:58:46 <alestane> takeWhile.
12:59:22 <alestane> However, this approach seems to run into an issue where the linked exectuable seems to wait for me to type in all the input and hit CTRL-D before it processes anything.
13:00:34 <alestane> Currently my user input funciton is returning a IO [Char]; I've wondered if maybe it should be returning [IO Char] instead.
13:00:49 <lortabac> alestane: the problem is that IO is not lazy
13:01:06 <monochrom> output is line-buffered if terminal
13:01:21 <alestane> I am expecting to process it line-by-line.
13:01:21 <monochrom> as in, held up until the next newline
13:01:32 <alestane> Each input is one line, that's fine.
13:01:40 <monochrom> output
13:01:42 <lortabac> there are functions that do lazy IO, but it's kind of a hack
13:02:43 <monochrom> Well, actually, the correct thing to do is post your code.  But I'm going away in a minute.
13:02:52 <merijn> I think what both monochrom and lortabac are trying to say is "please put your code on a pastebin so we don't all have to guess what's going on" ;)
13:03:13 <lortabac> :)
13:03:14 <merijn> monochrom: Dammit, man...couldn't have waited 2 more seconds to write that? ;)
13:03:56 <monochrom> relativity, there is no "before and after", etc
13:04:28 <alestane> I've used enough command-line environments to understand line buffers.
13:04:33 * monochrom sees much red shift when observing merijn!
13:07:05 <alestane> https://pastebin.com/c8Z2bQ7U is what compiled at the proof-of-concept stage.
13:07:33 <alestane> It's supposed to get the first character of each line, echo it back with a Q after it, then get the next line.
13:08:05 <merijn> alestane: Question: What do you think the stopping condition for the recursion in 'choices' is?
13:08:28 <alestane> Well, I was intending to feed it to a takeWhile.
13:08:39 <merijn> alestane: That won't work, though
13:09:15 <alestane> I was trying to build an "evaluate as needed" list akin to the "ones = 1 : ones" example
13:09:19 <merijn> Because if you do, like "fmap (takeWhile foo)" the takeWhile won't run until *all* IO inside choices is done
13:09:29 <alestane> Well, clearly it doesn't work, no.
13:09:37 <merijn> alestane: Right, but you can't evaluate IO "as needed" (at least not safely)
13:10:00 <alestane> Can I lazily build a [IO Char]?
13:10:01 <merijn> alestane: So the "mapM" on line 13 won't run until "choices" finishes, but that never finishes
13:10:19 <alestane> Or is my entire approach just incorrect?
13:10:44 <merijn> Can you? Yes. Does it do what you want? probably not
13:11:12 <merijn> alestane: I would simply move the "putStrLn" into the recursion of choices (or something along those lines
13:11:46 <merijn> Although it depends a bit on what you wanna actually do with said inpu
13:12:00 <alestane> I'll see how it works as an experiment and keep in mind that it may not be ideal/
13:12:33 <merijn> alestane: unrelatedly: let/in looks atrocious in 'choices' consider just using a where block instead :)
13:12:47 <merijn> (In fact, let in almost always looks atrocious :p)
13:13:23 <alestane> I tried writing it with where because that was the example I was working from, and it wouldn't compile. So clearly I was missing something.
13:14:18 <merijn> alestane: This should work: https://paste.tomsmeding.com/LP1lbfZ4
13:15:24 <alestane> I may also have made a hash of the Haskell whitespace rules (I know that ws is significant in certain constructs, but am still grokking the actual rules).
13:15:49 <merijn> alestane: https://en.wikibooks.org/wiki/Haskell/Indentation
13:16:21 <alestane> I know it's basically a syntactic sugar for a braces syntax that isn't used much.
13:17:09 <alestane> In any case, I appreciate the guidance.
13:17:16 <merijn> alestane: also
13:17:30 <merijn> alestane: I would personally probably write choices as something like: https://paste.tomsmeding.com/kdaTWbVH
13:17:39 <merijn> alestane: (using an empty line as stop condition)
13:17:49 <alestane> I haven't really used functional programming since my first undergrad CS class in Scheme lo these many years ago.
13:17:58 <merijn> And getting rid of the potential crash that your use of "head" on an empty line potentially has :)
13:18:53 <alestane> I tried building the stop condition into the data collection in one of my first attempts. A lot of this has been exploring a curiosity.
13:26:37 <alestane> merijn, what does the <$> in that example accomplish?
13:27:15 <alestane> Just better management of expression grouping?
13:29:30 <dsal> :t (<$>)
13:29:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:29:56 <solonarv> (<$>) = fmap -- it's the same thing, just as an infix operator
13:40:10 <monochrom> getLine is not lazy. [IO Char] would be an XY problem. KISS and implement a loop body that reads one line and prints one line right away.
13:40:57 <monochrom> The current code stands as looping over reading more lines and never does anything else.
13:44:52 <ski> alestane : if you want to `mapM' with a procedure like `putStrLn' that's not producing any interesting output / result value when invoked, it's better to use `mapM_' (since then you don't collect a list of useless `()' values)
13:46:37 <z0> hmm... is the uppercase pi classified as a symbol? ghc is trying to treat it as an operator
13:46:53 <alestane> Well, that was test code, but that might be the desirable case in the end.
13:47:10 <merijn> z0: Depends which one :p
13:47:24 <merijn> > generalCategory 'Π'
13:47:29 <lambdabot>  UppercaseLetter
13:47:56 <merijn> > generalCategory '∏'
13:47:58 <monochrom> Yes depends on which one, there are two or more.
13:48:00 <lambdabot>  MathSymbol
13:48:07 <ski> > map isUpper "Π∏"
13:48:10 <lambdabot>  [True,False]
13:48:54 <merijn> z0: Are you sure you have "uppercase pi" (my first example) or "N-ary product" (the second one) :p
13:49:23 <z0> ah that might be it
13:49:54 <z0> vim digraphs disappointing me again
13:54:06 <dsal> I've seen a lot of people use ß for the letter B because they think they look cool and nobody understand how stupid they are.
13:55:19 <z0> my bad. turns out i was using *P instead of P*
13:55:30 <z0> vim is cool after all
13:57:01 <merijn> dsal: THe number of Greek restaurants I've seen in the US/UK that use capital sigma as E is frustrating >.>
13:57:16 <dsal> Oh.  Yeah, that is actually worse.
13:57:35 <ski> merijn : was just about to say ..
13:58:02 <merijn> I'm like...the capital E in greek is just E >.<
13:58:08 <ski> (well, not restaurants, but the common practice)
13:58:56 <z0> i have this convention i use for naming things in personal projects where i use greek letters for some accessors  and very rarely for constructors. i cringe everytime i use Α instead of A
13:58:58 <dsal> People just universally don't understand the family of s
13:59:58 <pjb> merijn: And what about dayak?  "DAЯK"
14:00:19 <pjb> I can't stand it.
14:00:39 <ski> or using an upper case lambda, in place of a `D'
14:01:09 <z0> in my country grocery shop fridges are filled with GRΣΣK YOGURT
14:01:21 <monochrom> And the move "My Big Fat Greek Wedding" spells "GRΣΣK".
14:01:34 * ski shudders
14:01:39 <pjb> unbearable.
14:02:11 <z0> and those ridiculous programming langages that use backslash for a lambda. ugh
14:02:16 <z0> wait...
14:02:22 <ski> haha :)
14:02:44 <monochrom> I gave up cringing because I came from getting used to people doing the following:
14:03:12 <monochrom> In math channels a beginner would write "x*x -> x^2 = 2x".
14:03:45 <monochrom> It means "x*x rewrites to x^2, the derivative equals 2x"
14:04:09 <monochrom> In C, = means assignment, == means equal.
14:04:29 <monochrom> It's human nature. They know the right way, and they must blow it.
14:05:14 * ski . o O ( "Equality" by Maria Kovalyova,Roman Cheplyaka in 2012-11-15 at <https://ro-che.info/ccc/18> )
14:13:27 <dminuoso>     • Found type wildcard ‘_’ standing for ‘_’
14:13:29 * dminuoso sighs
14:34:42 <z0> maybe it's the cuneiform t and not the undersore symbol
15:09:15 <quarters> hello. I'm trying to follow this tutorial https://adit.io/posts/2013-04-15-making-a-website-with-haskell.html while stripping out some of the "magical"/unexplained parts like a number of the import statements and seeing it break and learning by identifying the missing parts that made it break. While doing this, I get an error: https://dpaste.org/zyus error: parse error on input ‘deriving’ and was wondering what the bare minimum 
15:09:15 <quarters> for addressing this could be
15:09:57 <Rembane> quarters: Add the words after the word deriving. :)
15:17:07 <quarters> Rembane: sorry. I don't understand. I tried looking up deriving to see its usage and found this which is also confusinghttps://stackoverflow.com/questions/6082090/haskell-deriving-show-for-custom-type
15:17:23 <Axman6> quarters: as far as I understand, the syntax of the quasiquote used by persistent is not the same as the syntax for defining haskell data types
15:17:51 <Axman6> I would be surprised if deriving is supported in the quasiquote at all
15:18:07 <quarters> Axman6: thank you! quasiquote was it!
15:18:12 <Axman6> hmm, I'm wrong, sorry
15:18:36 <quarters> I now found the reason why {-# LANGUAGE QuasiQuotes          #-}
15:18:36 <quarters>  was included :)
15:18:41 <quarters> from here https://gist.githubusercontent.com/egonSchiele/5400694/raw/ed1a15dc0d768ce603ab788ecd149862457533ad/Main.hs
15:18:51 <Axman6> yes, that's what [persist| ... |] is
15:18:52 <quarters> which I removed intentionally since there was no explanation of its purpose
15:19:17 <quarters> I'm trying to lazily learn haskell concepts, if that makes sense
15:19:31 <Axman6> this does not seem like a good approach to me
15:21:29 <Axman6> and trying to learn haskell by starting with yesod seems like a particularly difficult path, there is _a lot_ magic in yesod
15:21:30 <merijn> Axman6: persistent uses deriving in its quasi quoter for, well, adding deriving :p
15:21:38 <Axman6> yeah I was wrong
15:22:46 <Axman6> without having the whole code I assumed that the quasiquote was working because the extension would have been enabled
15:23:46 <merijn> but yeah, randomly copying code and commenting out bits isn't going to be very educational
15:24:26 <quarters> ok. I will rethink my approach then :)
15:25:01 <Axman6> asking questions in here when you get stuck on something will be much more fruitful
15:25:20 <quarters> my concern is that I'll frontload all the learning while losing a lot of it due to disuse
15:25:22 <monochrom> This is a good approach if you comment out everything web-related.
15:25:55 <monochrom> In fact, s/comment out/delete/
15:26:37 <Axman6> the web was a mistake
15:28:06 <monochrom> You aspire "one day I'll join NASA and build rockets" so you apply for engineering school and you get admitted.
15:28:37 <monochrom> First year courses are basic physics, basic engineering drawing, basic calculus, basic toy examples, basic everything.
15:28:53 <Axman6> man, reading that post is just reminding me how painful yesod is
15:28:56 <monochrom> That's how you build a rocket. By not starting with "project-based learning".
15:29:38 <monochrom> If you don't take Haskell types seriously, there is no way you will understand any of the web frameworks on Hackage.
15:29:48 <Axman6> oh it's not even yesod, it's just persistent which is painful
15:29:56 <monochrom> It is not enough to "know" them. You have to take them seriously.
15:30:50 <Axman6> yeah trying to use a Haskell web framework, except the most stringly typed ones, without having a good grasp of haskell types and some patterns is going to be very painful
15:30:53 <quarters> will the hls also be able to suggest pragmas that can fix issues?
15:32:47 <Axman6> sometimes... but if hls isn't going to help you if you don't know the language to begin with
15:42:21 <nineonine> hello everyone. I have 2 packages that I develop locally - `foo` and `bar`. How do I tell Cabal that `bar` should use locally built library from `foo` ?
15:46:04 <merijn> nineonine: You want a cabal.project file
15:46:54 <merijn> nineonine: Just add a line "packages: " with paths to the cabal files
15:47:02 <merijn> https://github.com/merijn/broadcast-chan/blob/master/cabal.project#L1
15:47:18 <merijn> (the other lines are pretty much unnecessary/optional)
15:47:27 <nineonine> merijn, many thanks!
15:50:24 <quarters> I had thought that the code here https://gist.githubusercontent.com/egonSchiele/5400694/raw/ed1a15dc0d768ce603ab788ecd149862457533ad/Main.hs would run just fine, but I'm seeing this error: "Not in scope: ‘persist’"
17:29:33 <ezzieyguywuf> do y'all use any code formatters? if so which? (i.e. ormolu, brittany)
17:30:35 <monochrom> I don't use one. But fourmolu has a better attitude than ormolu. :)
17:31:02 <ezzieyguywuf> lol, do you care to ellaborate?
17:31:43 <monochrom> ormula dictates an inconfigurable amount of space.
17:32:08 <ezzieyguywuf> ah, yikes
17:32:15 <ezzieyguywuf> lol, nvm maybe I'll just keep formatting it myself
17:32:41 <monochrom> fourmolu hasn't got around to make it configurable, but at least the readme is a funny roast.
17:34:15 <monochrom> and promises making it configurable
18:23:07 <ezzieyguywuf> `undefined` is so handy, let's me really build up my functions piece by piece with ghcid's help
18:39:09 <glguy> ezzieyguywuf, you know about using _, too?
18:41:15 <koz_> I, on the other hand, adore ormolu.
18:41:17 <koz_> cabal-fmt too.
18:51:06 <ezzieyguywuf> glguy: yea I use _ as well thank
18:51:34 <ezzieyguywuf> *thanks, though I'll use _ in "production" stuff when I just don't need something, whereas `undefined` is strictly for "in development"
18:52:57 <glguy> no, _ is for in development to get type information
18:53:16 <ezzieyguywuf> glguy: hrm, I used () for that, can you explain how I might use _ as you've described?
18:56:30 <glguy> put _ somewhere where you might have put undefined next time
18:57:17 <ezzieyguywuf> glguy: I'll try it out thanks
18:59:49 <DigitalKiwi> glguy: i tried putting the znc-playback arguments in flipped and i don't know if it worked because i might not have had a buffer to play but it didn't error
19:01:22 <glguy> I pushed a fix for that, too
19:02:26 <DigitalKiwi> oh no am i going to have to update nixpkgs again :D
19:03:58 <justsomeguy> Huh, type holes are new to me. I just found this article. It has a lot of examples, maybe it will be helpful for ezzieyguywuf, too. https://reasonablypolymorphic.com/blog/typeholes/index.html
19:03:59 <quarters> hello. is there a way to generate a gitignore with cabal? if not, may I ask what's typically included in a gitignore for a cabal project?
19:06:16 <DigitalKiwi> https://gist.github.com/Kiwi/70b6385e90822d3a9c849d8d261ba4d0 this is one i have
19:07:04 <quarters> DigitalKiwi: thanks!
19:07:05 <DigitalKiwi> another has this instead .ghc.environment.x86_64-linux*
19:07:07 <ezzieyguywuf> justsomeguy: thanks.
19:07:10 <justsomeguy> quarters: Here's a link to a repo of language-specific gitignores: https://github.com/github/gitignore/blob/master/Haskell.gitignore ; Hopefully someone else can chime in about how to generate it with cabal.
19:07:30 <quarters> justsomeguy: excellent!
19:07:38 <DigitalKiwi> if you don't use nix you don't need to ignore result
19:08:24 <koz_> % let (|) = (<>)
19:08:25 <yahb> koz_: ; <interactive>:7:7: error: parse error on input `)'
19:08:32 <koz_> Oh damn.
19:14:33 <iqubic> $ let (|) = <>
19:14:46 <koz_> iqubic: (||) works
19:14:56 <iqubic> % let (|) = <>
19:14:56 <yahb> iqubic: ; <interactive>:8:7: error: parse error on input `)'
19:15:02 <iqubic> Why?
19:15:11 <iqubic> % let | = <>
19:15:11 <yahb> iqubic: ; <interactive>:9:5: error: parse error on input `|'
19:15:18 <iqubic> Why doesn't that work?
19:33:02 <justsomeguy> The haskell report says that these operators are reserved, and can't be used as identifiers for user-defined namebindings (variables or function names). “reservedop -> .. | : | :: | = | \ | | | <- | -> | @ |  ̃ | =>”.
19:33:17 <justsomeguy> (From ch2, lexical structure, page 10.
19:33:21 <justsomeguy> )
19:41:45 <iqubic> Weird. You learn something new every day.
19:58:06 <quarters> I'm using blazehtml and was looking to add a click handler but found that this doesn't seem to be an option. is there a popular alternative to blazehtml if that's the case?
20:21:17 <sm[m]> would you expect toList on a map to give you items sorted by key ?
20:21:44 <monochrom> Yes.
20:22:39 <sm[m]> I don't see guaranteed in the haddocks.  On most machines, eg my mac, after running toList on a HashMap, they are are sorted by key. But on this one linux machine, they are not. All the libraries involved are the same version AFAICT
20:23:04 <sm[m]> peculiar
20:24:25 <monochrom> I thought you meant map = Data.Map
20:27:54 <sm[m]> well, I wondered first if it's a normal expectation for maps generally, but then specifically for HashMap.
20:28:10 <sm[m]> It seems I had better sort to be sure. Weird. Thanks monochrom 
20:30:15 <int-e> sm[m]: I'd expect toList to be linear time in the number of elements... so sorting is out. I'd also expect it to only depend on the represented set for purity reasons.
20:32:33 <int-e> Looking at Data.Hashmap, it returns elements sorted by their hash.
20:32:36 <sm[m]> int-e: so, you'd expect the order after toList to be indeterminate ? makes sense, I guess I have just been lucky for a long time
20:33:51 <sm[m]> ok.. still a mystery it seems
20:35:01 <int-e> And looking more closely, it sorts elements by their hash, then their key (as a lexicographic product)
20:35:04 <sm[m]> int-e: I got as far as the Foldable instance at https://hackage.haskell.org/package/unordered-containers-0.2.13.0/docs/Data-HashMap-Internal.html#t:HashMap .. where did you see that it sorts ?
20:35:09 <int-e> sm[m]: maybe all your maps have size 0 and 1
20:35:18 <sm[m]> ohh.. hash, not key
20:35:19 <int-e> sm[m]: I looked inside
20:36:32 <int-e> Oh, how many hashmaps are there.
20:37:01 <int-e> I was in the hashmap package somehow, sorry.
20:38:02 <sm[m]> ok, no problem. I don't see any sort  in https://hackage.haskell.org/package/unordered-containers-0.2.13.0/docs/Data-HashMap-Internal.html which I'm using, but it might be there
20:39:39 <sm[m]> correction, I'm using https://hackage.haskell.org/package/unordered-containers-0.2.10.0/docs/Data-HashMap-Strict.html
20:40:04 <int-e> Hrm I don't think unordered-containers meets my expectations there.
20:40:42 <sm[m]> I believe it does https://hackage.haskell.org/package/unordered-containers-0.2.10.0/docs/src/Data.HashMap.Base.html#foldrWithKey
20:41:00 <int-e> yes
20:41:17 <int-e> well, yes, if it hasn't changed between 0.2.13 and 0.2.10.
20:44:09 <int-e> sm[m]: So it sorts by hash, but in case of a hash collision it produces the elements in something like insertion order, probably messed up further by deletions.
20:44:30 <sm[m]> hmm.. and maybe hashing is different on this macine
20:48:25 <int-e> so, essentially, the order has to be treated as random.
20:50:10 <sm[m]> these are very small and simple maps.. the keys are ["a:k", "b:i","b:j", "c"]
20:54:34 <int-e> % import Data.Hashable
20:54:35 <yahb> int-e: 
20:54:40 <int-e> % import qualified Data.HashMap.Strict as H
20:54:40 <yahb> int-e: 
20:54:46 <int-e> % newtype X = X Int deriving (Eq, Ord, Show); instance Hashable X where hashWithSalt _ _ = 42
20:54:46 <yahb> int-e: 
20:54:49 <int-e> % let { h1 = H.fromList [(X 1, 1),(X 2, 2)]; h2 = H.fromList [(X 2, 2),(X 1, 1)] } in (h1 == h2, H.toList h1, H.toList h2)
20:54:50 <yahb> int-e: (True,[(X 1,1),(X 2,2)],[(X 2,2),(X 1,1)])
20:55:29 <int-e> (ah, 8 lines instead of the 5 I wanted... I didn't account for yahb acknowledging every single line)
21:25:22 <int-e> Now who wanted a readBin in Numeric :)
21:53:53 <justsomeguy> Is there a way to suppress GHCi's greeting banner “GHCi, version 8.8.3: https://www.haskell.org/ghc/  :? for help ...”? I don't see any options for it in “ghci --help” or the ghc user guide.
21:54:15 <justsomeguy> I'm hoping I just overlooked it, though.
21:56:56 <adder> hello, how can i get the Int from X Int?
21:58:26 <jle`> adder: what is the definition of X?
21:58:42 <adder> X :: * -> *
21:58:42 <adder> Defined in ‘XMonad.Core’
21:59:20 <jle`> ah. since X has a Monad instance, you can bind the Int in do notation
21:59:35 <jle`> or use myX >>= (\myInt -> ...)
22:00:16 <jle`> or in a do block, do myInt <- myX; ..., etc.; the myInt will be in scope for the rest of the do block
22:00:26 <jle`> in this method though your final result value will still be X (something)
22:01:16 <int-e> justsomeguy: it's linked to verbosity... ghci -v0
22:02:16 <int-e> and I don't know whether that suppresses anything useful
22:02:49 <int-e> (I've never asked the question -- I don't mind the banner.)
22:15:12 <justsomeguy> Nice. I don't really mind the banner, either, but I don't want it in the terminal recordings I'm making right now, either.
22:15:49 <justsomeguy> I said either twice. I tend to repeat words when I'm tired. This is probably a good sign that I should go to sleep.
22:19:07 <justsomeguy> I didn't think to try -v0 since the user guide says it's the default.
22:51:54 <ccapndave> Hey everyone - I'm pretty new to Haskell and am trying to write something involving a parser (using Megaparsec)
22:52:21 <ccapndave> I'm a bit confused about the documentation - I'm using megaaparsec-8.0.0, which has documentation here: https://hackage.haskell.org/package/megaparsec-8.0.0
22:52:47 <ccapndave> However, there is definitely a function called manyTill (I know because I can use it), but it doesn't appear anywhere in the documentation that I can see.  Isn't the documentation auto-generated from the source?
22:53:32 <ccapndave> Or is it actually there somewhere and I'm just missing it
22:53:58 <MarcelineVQ> it comes in because Text.Megaparsec re-exports https://hackage.haskell.org/package/parser-combinators-1.2.0/docs/Control-Monad-Combinators.html
22:54:14 <MarcelineVQ> you'll find it at  https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#g:1
22:54:44 <boxscape> I'm trying to write a pattern synonym that I can use like (Prefix "test" rest) to check if a String starts with "test". `pattern Prefix prefix rest <- (splitAt 4 -> (prefix, rest))` works, but I'd like to use the length of the prefix instead of 4. `pattern Prefix prefix rest <- (splitAt (length prefix) -> (prefix, rest))` doesn't work, it says that
22:54:44 <boxscape> prefix is not in scope. Is there a way to make this work?
22:55:54 <ccapndave> MarcelineVQ: Aha
22:56:00 <ccapndave> Thanks very much!
22:56:01 <koz_> boxscape: Try writing a helper function returning a Maybe, then go 'that function with args -> Just'
22:56:18 <boxscape> koz_ ah, I'll try that, thanks
22:56:31 <koz_> I find that easier to do in many cases.
22:58:24 <boxscape> hm but won't I still have to give that function prefix as an argument, and since it's on the left side of the view pattern it'll still say that it's not in scope?
23:00:04 <boxscape> koz_
23:00:06 <boxscape> oh
23:00:14 <boxscape> you meant without writing a pattern synonym, right?
23:00:22 <boxscape> I guess that should work
23:00:29 <koz_> Yeah - basically, wrap your logic in a function, then use that function in the synonym.
23:06:13 <boxscape> koz_ I still don't fully understand how I'm supposed to use the function in the synonym but I can do (prefix "test" -> Just rest) now, which pretty much does what I want
23:27:27 <ccapndave> I am failing badly with this parser :(  I'm trying to parse a CSV file, but I can't get it to work.  Is there some kind of JSFiddle thing for Haskell so I can share code online with people?
23:29:20 <boxscape> ccapndave https://paste.tomsmeding.com/
23:30:32 <ccapndave> https://paste.tomsmeding.com/TtQkWPvo
23:30:56 <ccapndave> Its sort of half in GHCI so I can't paste a complete program, but I can't understand why this doesn't parse my single line of CSV
23:43:47 <ccapndave> It seems to be the `newline` (or my use of it) that is causing the problem - https://paste.tomsmeding.com/3FdRgzUA
23:45:55 <jchia> ccapndave: the newline is matched as part of the "many ..." You didn't say that newline shouldn't match
23:45:59 <ccapndave> Argh
23:46:03 <ccapndave> (facepalm)
23:46:37 <ccapndave> Is this the right way to write this, even?
23:46:52 <jchia> i normally just use the cassava package
23:47:09 <ccapndave> I started off with that, but I'm a Haskell noob and there were too many other things to learn to get that going
23:47:19 <ccapndave> And anyway, I'd like to write the parser
23:47:28 <ccapndave> And anyway anyway I have a weird CSV file that isn't quite legal
23:47:47 <jchia> idk what the "normal way" is. as long  as it works properly for many different cases, including corner cases and the code is not too 'weird' or inefficient, i think it's fine
23:48:33 <jchia> what you have looks fine to me other than the treatment of newline
23:48:36 <ccapndave> `sepEndBy (many $ noneOf [';', '\n']) ";" <* newline` - that seems to work
23:52:30 <boxscape> ccapndave fwiw you can write [';', '\n'] as ";\n", though I suppose whether that's clearer is up for debate
23:53:00 <ccapndave> Ah, because a string is a list of characters
23:53:27 <boxscape> yeah, although I suppose if you have OverloadedStrings enabled it might not quite work like that, not sure
23:54:05 <boxscape> No I think it should
23:54:36 <ccapndave> It does :+1:
23:55:49 <ccapndave> For bonus points, is there anything I can do in `sepEndBy (many $ noneOf [';', '\n']) ";" <* newline` so that it skips any `\r` characters (i.e. they just get removed from the input)?
23:56:14 <ccapndave> I seem to end up with a trailing `\r` on the last element
23:58:12 <ccapndave> Ah, got it - `sepEndBy (many $ noneOf [';', '\n', '\r']) ";" <* string "\r\n"`
