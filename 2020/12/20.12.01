00:10:37 <siraben> Is it possible to make this any faster? http://ix.io/2G7O
00:10:46 <siraben> Not sure what to do after bang patterns
00:11:04 <siraben> It should take constant space
00:14:34 <maerwald> siraben: top-level recursion doesn't optimize well, but I'm not sure about the details
00:15:01 <maerwald> so ppl usually do where go  =... f go : foo
00:15:29 <jle`> seems to be a clean tail recursion to me
00:15:49 <jle`> no obvious opportunities for sharing
00:16:26 <siraben> Using godbolt to see the assembly, looks pretty optimal
00:16:44 <siraben> also putting f in a where clause doesn't seem to affect output
00:18:27 <siraben> What about the use of Int?
00:19:00 <siraben> Heh I haven't even QuickChecked my code to see if it's a solution to a problem
00:19:37 <maerwald> try -XStrict and -XStrictData and see if it changes anything
00:19:43 <jle`> hm, you could switch to Int# maybe, but i'm not sure if that would make a major difference
00:20:20 <siraben> https://godbolt.org/z/nos54M
00:20:53 <jle`> if you switched it Int# and strict tuples then you wouldn't even need the bang patterns
00:21:15 <jle`> but looking at the assembly it's likely that ghc already made that optimization for you
00:21:24 <siraben> How can you tell?
00:21:49 <jle`> oh i was kind of taking your word for it heh
00:22:11 <jle`> the downside if you turn it into a strict tuple is that you won't be able to take advantage of sharing like you are doing now
00:22:15 <jle`> with the s@(..)
00:22:22 <jle`> because everyhting will be call by value
00:23:12 <siraben> Without bang patterns: 864 lines of asm, with bang patterns: 680
00:23:23 <siraben> Oops
00:23:27 <siraben> 684 vs 680
00:23:37 <jle`> oh by strict tuple i meant unboxed tuples
00:23:50 <siraben> Should I not use tuples altogether?
00:24:17 <jle`> right now your tuples give you the 'advantage' of sharing
00:24:23 <jle`> i'm not sure if it makes a big difference though
00:24:52 <siraben> How could I dump the C-- code?
00:24:54 <siraben> To check for allocations and so on
00:25:27 <boxscape> siraben -ddump-cmm
00:25:51 <boxscape> siraben if you check here there's a whole bunch of -ddump-cmm-* flags https://downloads.haskell.org/ghc/latest/docs/html/users_guide/flags.html
00:26:37 <dminuoso> I have a data record with some `S, T, ..` and plenty of `Maybe Q`, `Maybe V`, etc. Ideally Id like a way to build a value from just the "required" (fields that are not Maybe) values.
00:26:41 <dminuoso> optics is at my disposal
00:26:42 <siraben> Uh oh it's quite unreadable
00:26:51 <dminuoso> Writing a Monoid instance is unfeasible
00:27:05 <dminuoso> (Since that wouldn't guarantee I produce sensible value of types S, T, ...)
00:27:09 <dminuoso> What options do I have?
00:37:02 <boxscape> this example Richard wrote is kind of interesting, I wouldn't have guessed the infinite output https://mail.haskell.org/pipermail/ghc-steering-committee/2020-November/001933.html
00:38:22 <boxscape> oh though I just reali0
00:38:36 <boxscape> realized* the reason I was confused is because I overlooked the default definition that ppr has 
00:39:05 <boxscape> a lot less interesting now :)
01:03:16 <idnar> @type \f x -> f x $> x
01:03:18 <lambdabot> error:
01:03:18 <lambdabot>     ‚Ä¢ Variable not in scope: ($>) :: t1 -> t -> t2
01:03:18 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
01:04:12 <idnar> huh isn't $> in Prelude?
01:04:40 <merijn> Pretty sure <$ and $> are in Control.Applicative, so no
01:05:03 <dminuoso>     ‚ÄòCryptokey‚Äô is exported by ‚ÄòCryptokey(..)‚Äô and ‚ÄòCryptokey(..)‚Äô
01:05:10 <dminuoso> Not bad. Modifying files while GHC is running is a funny buiness
01:05:28 <dminuoso> The diagnostics become quite strange
01:05:37 <idnar> merijn: Data.Functor
01:05:43 <idnar> @type \f x -> x <$ f x
01:05:44 <lambdabot> Functor f => (t -> f b) -> t -> f t
01:06:11 <idnar> oic, <$ is the class method
01:06:51 <dminuoso> Oh hold on, nvm me
01:07:09 <idnar> @hoogle Functor f => (t -> f b) -> t -> f t
01:07:10 <lambdabot> No results found
01:41:20 <merijn> Hey
01:41:30 <merijn> Why don't we have a #haskell AoC leaderboard yet?
01:42:03 <merijn> Ah, looks like the old one is still active, but not in th topic
02:20:29 <dminuoso> Mmm, is there a reason not to provide a Data instance when you already have a Generic instance for ADTs exposed in libraries?
02:20:46 <dminuoso> It seems like you might as well provide anything you can for the odd user who wants it.
02:21:17 <dminuoso> Assuming you're exporting data constructors/field accessor anyway
02:23:21 <bulters> merijn: care to share your solution to day 1? ;-)
02:23:50 <bulters> I'm curious to see what a more proficient Haskeller would have written
02:29:42 <dminuoso> bulters: Do you have your solution submitted already?
02:31:20 <bulters> dminuoso: yes, and on GH
02:31:52 <bulters> to put my bluntness, stupidity and ignorance on display... and for others to comment on so I can actually learn this stuff for once.
02:32:40 <dminuoso> No worries, I just dont to spoonfeed solutions. Hence my asking.
02:32:59 <bulters> I know... 
02:33:58 <bulters> but wanted to extend the invite to have a look at my solution (https://github.com/bulters/aoc20)... although for today, well, doesn't matter too much.
02:34:43 <bulters> could've done optimization, but it runs in 0.04s when ran via `cabal new-run`.
02:38:44 <Sose> I'm new to Haskell myself but I did pretty much the exact same solution except I separated the actual problems into separate pure functions ([Int] -> Int)
02:40:17 <dminuoso> bulters: Depending on how further AoC excercises run, you might have to do this more efficiently
02:40:22 <dminuoso> You're generating unnecessary work
02:40:56 <dminuoso> Keep in mind that both addition and multiplication are commutative
02:41:30 <dminuoso> Also, readMaybe tends to be a better choice, read is always a wart.
02:41:52 <bulters> dminuoso: I agree. This is not the smartest thing to do. Will probably try and improve a bit this afternoon. 
02:42:15 <bulters> dminuoso: but now we're talking software engineering, not solving AoC challenges ;-) 
02:42:33 * bulters still adds changing `read` to `readMaybe` to todo list for this afternoon.
02:42:43 <dminuoso> Surely christmas is important enough to warrent stable code.
02:43:04 <bulters> But I thought we were going on vacation this year? 
02:43:06 <dminuoso> Also, it's helpful if you develop a habit of using safe primitives regardless of the task..
02:43:21 <dminuoso> `traverse readMaybe` is not more work than `map maybe`, but it saves you from endless headaches down the road
02:43:32 <dminuoso> err *map read
02:45:24 <bulters> I really have to explore package documentation more...
02:45:28 <Sose> my first time hearing about readMaybe ;o
02:45:47 <suzu_> traverse readMaybe will break if any of the values can't be read
02:45:58 <suzu_> is there a form for if you wanted to read up to the first error?
02:47:32 <bulters> is there a cabal new-repl incantation that loads a specific source file right away?
02:48:14 <bulters> and q2: did the "haskell community at large" already decide on a default code formatter? :')
02:48:21 <dminuoso> suzu_: Good question. I mean if you want to *skip* invalid rows, mapMaybe/catMaybes has you covered.
02:48:49 <suzu_> there must be some newtype wrapper for Maybe that has the applicative I want
02:48:59 <boxscape> I suppose you can (sequence . takeWhile isJust . map readMaybe)?
02:49:13 <suzu_> oh thats a good idea
02:49:32 <suzu_> is there one that uses just an applicative instance though
02:49:51 <dminuoso> sequenceA? :>
02:50:02 <suzu_> right, but that's not the right sequence
02:50:11 <dminuoso> What do you mean by "right sequence"
02:50:17 <dminuoso> sequenceA = sequence
02:50:22 <suzu_> err to be specific
02:50:31 <suzu_> can it be written as a `traverse f` for some f
02:50:37 <dminuoso> The reasons we have both are... well... there was discussion to unify them into sequence, and people forgot about it
02:50:59 <dminuoso> suzu_: Im thinking you should be able to with ListT
02:51:14 <suzu_> and i think traverse uses a sequenceA in it, which will use the applicative of Maybe
02:51:16 <merijn> bulters: Eh, I just read and downloaded it, so it is as of yet, non-existent :p
02:51:36 <merijn> I already have some *entirely* overkill solution in mind, though
02:51:44 <bulters> nice, looking forward to it :')
02:52:07 <merijn> but lunch first :p
02:52:26 <bulters> priorities!!!
02:52:35 <dminuoso> suzu_: My feeling says if you run it through `MaybeT (ListT Identity)` it should do the expected
02:52:43 <dminuoso> Let's see
02:54:50 <bulters> dminuoso: What would be the "value add" of using a mt for this be? (c.l. I don't understand monads, let alone mt's, so just trying to figure out the why here)
02:57:02 <dminuoso> bulters: Oh, with monad transformers we just get a succint way of specifying effects, nothing more.
02:58:04 <bulters> dminuoso: "clear", I'll dive into that somewhere this month :')
02:58:36 <bulters> dminuoso: so if I change read into readMaybe, I suddenly have to define by Nothing case as well right...
03:02:00 <dminuoso> Right.
03:02:27 <dminuoso> Alternatively, you can use readEither, and then do the entirety of your code in `Either String`
03:02:41 <dminuoso> Or maybe `readMaybe` with `note` and you stuck it all into IO
03:03:01 <boxscape> % readEither "" :: Either String Int
03:03:02 <yahb> boxscape: Left "Prelude.read: no parse"
03:03:03 <boxscape> hm
03:13:54 <bulters> dminuoso: thanks... actually moving from just read to readMaybe, and doing the type matching dance made my solution "faster" (by 25%, 0.01s)
03:14:44 <bulters> sorry, I was mistaking... it made it one order of magnitude slower :')
03:14:48 <bulters> need more coffee
03:15:53 <dminuoso> bulters: Can you share your code?
03:16:00 <bulters> yeah
03:16:02 <bulters> pushing now
03:16:09 <dminuoso> It shouldn't be noticeable slower.
03:16:57 <bulters> from 0.04s to 0.35s is, imo an order of magnitude slower... not dramatic though ;-)
03:17:17 <dminuoso> Ah yes, I see.
03:17:48 <dminuoso> It's quite possible this fmap breaks fusion.
03:18:01 <dminuoso> So I'd rather
03:18:11 <bulters> It's because I use product and sum instead of (*) and (+) right?
03:18:12 <dminuoso> Write the code in terms of `[Int] -> ...`
03:18:26 <dminuoso> so roughly you'd do
03:19:06 <dminuoso> case traverse readMaybe (lines buf) of Just xs -> print =<< solution xs; Nothing -> die "Parse error"
03:20:09 <dminuoso> There's a million ways to make this better or different, but I think this is a good starter.
03:20:34 <dminuoso> or well, maybe `print (solution xs)` rather
03:20:39 <dminuoso> Assuming solution is pure code
03:21:38 <dminuoso> `traverse readMaybe` conceptually reads every string, and if any fails the whole thing short circuits with a conceptual exception
03:21:46 <dminuoso> the surrouding case-of acts as a conceptual catch
03:22:32 <dminuoso> The benefit of this is that you can control what happens if read fails. With `read` you're placing a mine inside a thunk, that gets triggered somewhere else
03:27:30 <boxscape> the second part of the aoc task seems kind of weird. It almost feels like they make the problem bigger so you have to come up with a more efficient algorithm, but the problem isn't actually large enough to necessitate it (I'm also not sure if there is a better algorithm atm)
03:27:58 <boxscape> more efficient algorithm than the naive one, that is
03:31:14 <boxscape> (the answer is yes)
03:31:48 <boxscape> Oh actually never mind lazy evaluation already gave me the optimization I had in mind
03:52:29 <maerwald> Do TupleSections translate to a lambda expression or is there some other black magic involved?
03:52:53 <merijn> maerwald: What kinda black magic would be involved?
03:53:09 <maerwald> If I knew, I probably would know how to figure out the answer.
03:53:44 <merijn> I'd say they turn into something equivalent to a lambda expression
03:53:51 <dminuoso> boxscape: What I dislike, is that the task doesnt make it clear whether an entry can be added with itself or not.
03:54:01 <dminuoso> I mean, for this task it doesnt matter. But it might
03:55:35 <boxscape> dminuoso Hm, they do say "the two numbers that add together to 2020", which to me implies that they're different numbers, but it is somewhat ambiguous
03:55:55 <boxscape> s/numbers/entries
03:56:08 <dminuoso> "two entries" does not imply they're different entries
03:56:19 <LKoen> they didn't say "the two distinct numbers" or "the two different numbers"
03:56:30 <boxscape> I feel like in non-math speech it does
03:57:03 <LKoen> I read it as "the two numbers, which are not particularly expected to be equal, but who knows"
03:57:32 <merijn> This all seems irrelevant to solving the problem, tbh
03:57:53 <dminuoso> Sure, that was just complaining about the problem description
03:58:36 <boxscape> it's kind of interesting because "the two numbers that are greater than 1000" I think would obviously be two distinct numbers, but when they interact it's not as clear
04:00:19 <boxscape> I'm almost inclined to argue that there's a difference between "a pair of numbers that add to 2020" and "two numbers that add to 2020", but interpreting these is probably pretty subjective, so I won't
04:01:14 <dminuoso> My point is, it shouldnt require interpretation
04:01:30 <boxscape> that is a fair point
04:02:34 <merijn> And once again I find myself wanting foldMapM or foldTraverse :p
04:03:29 <siraben> Is there an elegant way to check if a list is ascending? I have `and . (zipWith (<) <*> tail)` but it's not very amenable to equational reasoning
04:05:10 <merijn> @quote aztec.god
04:05:10 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
04:05:35 <merijn> (not an answer, but sprang to mind)
04:07:36 <siraben> Here's what I have https://gist.github.com/siraben/6b1f57ff1a3fbb76432eb79f0f91f507
04:07:47 <siraben> I have a naive solution and the efficient one that looks like a state machine
04:07:57 <siraben> I want to derive the efficient solution from the naive one
04:08:11 <siraben> Trying to invoke Horner's rule (from Algebra of Programming) somehow
04:09:08 <siraben> Horner's rule states if `f c = c and f (g (a,b)) = g (f a, f b)` then `foldr g c . iterate f = foldr (\a b -> g (a, f b)) c`
04:09:17 <siraben> (specialized to the list base bifunctor)
04:11:13 <siraben> Somehow the predicate `isMountain` is blocking progress
04:11:42 <siraben> Here's an example of Horner's rule used to solve the maximum subsegment problem, https://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism#/media/File:Max_seg_sums_svg.svg
04:12:52 <merijn> siraben: oof...that's some complex list abuse with most likely *terrible* performance
04:13:06 <siraben> merijn: Yes, I'm aware. That's why it's the naive solution
04:13:17 <siraben> `solve` runs in linear time and constant space OTOH
04:14:16 <merijn> siraben: It's awfully complex for a naive solution, though? >.>
04:14:23 <siraben> Maybe my calculus of choice is wrong, I should be using a relational calculus, hm.
04:14:40 <siraben> merijn: did you see the naive pointfree version?
04:15:03 <merijn> siraben: Yes. And my brain nopes out of there 2 expressions in ;)
04:15:23 <siraben> Heh, it's quite simple, really!
04:15:37 <merijn> siraben: My immediate response to isMountain on line 93 is "wow...I can't be bothered to understand this enough to help" :p
04:16:03 <siraben> I derived that expression from the monadic one
04:16:12 <siraben> So it's basically the same
04:18:39 <siraben> @pl any (\(l, r) -> isAscending l && isDescending r) . (\l -> (\i -> (take (i + 1) l, drop i l)) <$> [1..length l - 2])
04:18:40 <lambdabot> any (uncurry ((. isDescending) . (&&) . isAscending)) . ap ((<$>) . ap (ap . ((,) .) . flip (take . (1 +))) (flip drop)) (enumFromTo 1 . subtract 2 . length)
04:19:12 <siraben> Ooh
04:31:17 <merijn> bulters: Well, here's part 1 in terms of overengineered solutions: https://github.com/merijn/AdventOfCode2020/blob/master/Day1.hs ;)
04:37:56 <tomsmeding> maerwald: wasn't there a difference in laziness between (,x) and (\a -> (a, x)) ?
04:39:04 <merijn> tomsmeding: That applies to all operators, is technically a bug (or incompatibility with the report) in GHC, and it's hard to think of non-contrived situations where it matters
04:39:17 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
04:40:17 <tomsmeding> ah right that was it. I agree that if this matters in your code you're doing something wrong, but maerwald was asking if there was magic involved :p
04:41:02 <merijn> tomsmeding: Well, like I said, it depends how you define magic. What GHC generates is *roughly* equivalent of the lambda
04:41:20 <tomsmeding> ... on the other hand, that operator case you linked is for when the operator is undefined, but with tuple sections the operator is the tuple section -- which apparently isn't undefined, since you just wrote it
04:41:34 <merijn> Except, GHC internally has a notion of "function arity" (i.e. when something is fully applied) for optimisation purposes
04:41:49 <tomsmeding> so am I correct in saying that this distinction is present for operator sections, but not for tuplesections?
04:42:09 <merijn> tomsmeding: Who knows? :p
04:42:38 <tomsmeding> > fst ((,undefined) 42)
04:42:40 <lambdabot>  42
04:43:01 <tomsmeding> I claim no observable difference
04:43:08 <tomsmeding> s/observable/semantic/
04:46:59 <siraben> merijn: put it like this, what's a good way to check if a list is a mountain? i.e.
04:47:41 <siraben> There is some i, 0 < i < length arr such that arr[0] < arr[1] ... < arr[i] and arr[i] > arr[i + 1] ... > arr[length arr - 1]
04:47:43 * tomsmeding hates it how accidentally pressing 'e' on a github page immediately forks the repo
04:47:59 <maerwald> tomsmeding: lol, does it?
04:48:03 <siraben> My derivation hinges on that
04:48:05 <tomsmeding> it does
04:51:10 <merijn> siraben: I don't think the logic is necessarily bad, I think the logic *applied to lists* is bad :)
04:51:36 <merijn> siraben: (and the overuse of point-free/zip`ap`tail)
04:52:10 <siraben> merijn: Right, so my hope is to eliminate the intermediate list altogether via calculation
04:52:11 <merijn> siraben: Because indexing lists is O(n), if you use Array or Vector so your indexing is O(1) it'd already be a lot more sensible
04:53:04 <maerwald> merijn: wait, so (,) is like an infix operator?
04:53:29 <merijn> maerwald: (,) is analogous to making operators prefix, yes, that's the idea
04:54:26 <merijn> maerwald: Also, note that (,) isn't TupleSections
04:55:08 <maerwald> Can we make a contrived example that demonstrates a difference?
04:55:45 <merijn> maerwald: Between TupleSections and not or of the strictness?
04:55:54 <maerwald> yeah
04:56:03 <merijn> ENOPARSE
04:56:17 <maerwald> lol
04:56:33 <merijn> that was an either/or clarification, yes is not acceptable answer :p
04:57:53 <maerwald> I want to see a demonstration of different strictness properties between (\x -> (undefined, x)) and (undefined,) for example
04:58:02 <maerwald> Can't come up with one
04:58:40 <merijn> I'm not there is one, the example in quchen's post relies on the operator being undefined (which it isn't for tuples)
04:58:57 <boxscape> do tuples work with RebindableSyntax?
04:59:13 <merijn> bulters: Don't think so
04:59:55 <boxscape> yeah user guide doesn't mention it
05:10:16 <bulters> merijn: it looks over engineered alright ;-)
05:11:48 <merijn> bulters: I have the same rules as last year. "Must correctly handle *any* possible error"
05:12:11 <boxscape> how do you know you haven't missed one?
05:13:03 <merijn> bulters: Because I like to refer to them as examples of how you can write clean, readable, but still relatively short code
05:13:36 <merijn> boxscape: I just mean "don't use 'read' and assume the conversions work out', 'don't skip cases because "they can't happen"', etc.
05:13:43 <boxscape> I see
05:14:16 <merijn> So, "no hacky shortcuts"
05:15:18 <merijn> bulters: Last year it paid of, because doing it properly made it fairly easy to reuse in later puzzles :p
05:17:33 <ph88^> hey guys, maybe strange question but if i want to have a functional language and then instead of CPU instructions to come out my own steps, where do i even start? and could i leverage ghc optimizations for this ?
05:18:12 <boxscape> what kind of step do you have in mind when you say "your own steps"?
05:18:43 <merijn> That just sounds like "how do I wrote my own compiler?" :p
05:19:11 <ph88^> yes a small functional language that compiles into steps send to another system
05:19:21 <merijn> (which is a perfectly reasonable thing to want and will probably get you more useful answers :p)
05:19:23 <Boomerang> That sounds a bit like what Clash does. It uses GHC for the frontend and optimization and then generates HDL from the Core language
05:19:39 <Boomerang> (or maybe I missunderstood and you want the opposite? ^^)
05:19:49 <ph88^> no you got it Boomerang 
05:19:58 <Boomerang> https://clash-lang.org/ Then :)
05:20:00 <merijn> Working from Core is super tedious, though
05:20:01 <bulters> merijn: that's my next step, include this into a lib ;-)
05:20:04 <Boomerang> And maybe #clash-lang 
05:20:14 <ph88^> merijn, clash works on core ?
05:20:39 <merijn> ph88^: Clash is a semi-fork of GHC that reuses it's front end (so input is Haskell), but generates different code
05:21:00 <merijn> But if your input language *isn't* "Haskell", then writing your own compiler is probably much easier
05:21:14 <ph88^> ye i mean the "handover point" from ghc front-end is the core language ?
05:21:32 <Boomerang> There are several "handover points"
05:21:49 <Boomerang> Core is the minimal Haskell like language I think
05:22:07 <Boomerang> But that can include many optimisations
05:22:14 <ph88^> i also heard that i could use a free monad to write some interpreter .. maybe this is more suitable to get started ?
05:22:27 <Boomerang> Yeah definitely! :D
05:23:40 <merijn> ph88^: tbh, "writing a compiler" really isn't so hard if you don't really need much optimisation
05:24:21 <ph88^> merijn, ye this optimization is not really a requirement now. I'm just trying to determine if it's already worth looking at ghc stuff at some point to take that into account or not
05:24:57 <merijn> ph88^: tbh, "writing a new compiler from scratch" is most likely *much* less work than reusing GHC
05:25:11 <ph88^> is there any stuff that can be reused ? i mean after the parser there should come symbol tables and type inference and so on ..
05:25:14 <merijn> And the more your language differs from Haskell, the bigger the amount of work saved :p
05:25:25 <ph88^> ok sounds like good advice
05:26:13 <ph88^> do you know of any components (not necessarily ghc stuff) that can be used to save work though ? or do we have to implement hindley milner & friends from scratch ?
05:27:19 <merijn> ph88^: My main recommendations would be: 1) Types and Programming Languages by Benjamin Pierce (on how to do typechecking) and "Modern Compiler Implementation in ML" by Andrew Appel
05:27:37 <ph88^> ye already reading that first book
05:27:48 <Boomerang> What is your language for? Could you use an existing one? :)
05:27:54 <ph88^> any recommendations on components and libraries perhaps ? 
05:28:25 <ph88^> Boomerang, we want our own custom language for a product like a DSL ..
05:29:36 <Ariakenom_> for a DSL example I like this blog post on an assembly DSL in haskell https://www.stephendiehl.com/posts/monads_machine_code.html
05:29:43 <Ariakenom_> sry wrong link
05:29:43 <Boomerang> I think as soon as you need typechecking it becomes a fairly big undertaking. Would an embedded DSL be enough?
05:29:45 <Ariakenom_> http://wall.org/~lewis/2013/10/15/asm-monad.html
05:31:23 <Boomerang> How about using Dhall with custom builtins (if the standard language isn't enough)? https://dhall-lang.org/
05:31:39 <Ariakenom_> requires understanding of monads but nothing more I think
05:31:44 <Boomerang> dhall-haskell is fairly easily extensible
05:33:30 <ph88^> Boomerang, i like your creativity :) :)
05:34:35 <maerwald> this is cooler: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/coqasm.pdf
05:34:38 <dminuoso> ph88^: Regarding "writing a compiler". There's the following difficulties: Type system, suitable diagnostics and optimizations. If you dont care about any three, then often you can get away with less than a thousand lines of Haskell for most languages, often 100 could suffice.
05:35:23 <ph88^> dminuoso, hum i tried implementing just a parser once (not counting other components) in megaparsec which already was 3000 lines
05:35:33 <dminuoso> Well it depends on the grammar, of course.
05:36:07 <dminuoso> I've seen an implementation of an early Haskell-like that was about 200 lines total I think?
05:36:49 <dminuoso> The diagnostics in GHC for example leads to a lot of difficulties. GHC's type system operates on the original source language (in fact it operates on something even *richer*, since it operates on elaborated haskell), allowing GHC to report errors accurately on what code you have written, not how its desugared.
05:37:28 <ph88^> ye i agree that error reporting is very important
05:37:35 <Boomerang> Well my Dhall recommendation is biased since I contribute to that project. But the extensibility is very good, since you can serialise functions between Haskell and Dhall: https://hackage.haskell.org/package/dhall-1.36.0/docs/Dhall-Tutorial.html#g:23
05:38:13 <dminuoso> ph88^: Does your language have a notion of variables/binders?
05:38:25 <ph88^> Boomerang, the notion of "a sequence of steps" and putting constraints what step can before another step (and not) is quite important, i would have to think a bit to see how that could work in dhall
05:38:42 <ph88^> dminuoso, yes like some immutable variables
05:39:17 <dminuoso> ph88^: Then you might be interested in unbound.
05:39:24 <dminuoso> Dealing with names and binders is something you don't want to do yourself.
05:39:28 <ph88^> whats that ?
05:39:40 <dminuoso> https://hackage.haskell.org/package/unbound
05:39:40 <ph88^> this https://hackage.haskell.org/package/unbound ?
05:39:46 <ph88^> aah great !
05:39:46 <dminuoso> Yes
05:39:57 <ph88^> do you have any other recommendations too ? i love this kind of stuff
05:40:25 <ph88^> i found this before, but not sure yet if i can use it  https://hackage.haskell.org/package/hoopl 
05:41:13 <siraben> Anyone remember the scan lemma?
05:41:29 <siraben> I have `foldr f 0 . tails`
05:42:01 <siraben> hlint doesn't seem to have it
05:44:11 <siraben> Ooh, https://gist.github.com/regiskuckaertz/63c60151ef85670312d1d1f92490de2e#scan-lemma
05:46:44 <siraben> This turns a quadratic time expression into a linear one
05:48:31 <Boomerang> Is this advent of code related? ^^
05:49:08 <siraben> Boomerang: no, leetcode related
06:13:47 <lotuseater> siraben: thx for this gist to widen my knowledge. but damn, no Haskell (or this other awesome language) supported on leetcode. are you guys doing it in Rust?
06:14:31 <siraben> I haven't been running my solutions on leetcode, but I think I'll use Rust when I do
06:16:01 <z0> is there a language extension that allows for naming collisions of functions with different types?
06:16:30 <lotuseater> yeah that comes to Haskell closest in default. I recently also got into APL
06:16:53 <z0> that would allow for unqualified imports for instance, and let the compiler disambiguate by tyoe inference
06:17:07 <boxscape> z0 only if those functions are record fields, afaik
06:17:21 <boxscape> Idris has overloading like that
06:17:24 <geekosaur> z0, that's called type-directed name resolution and there's a long discussion on the wiki of why it's a bad idea
06:17:27 <solonarv> or if you write a typeclass for them, I suppose
06:17:36 <solonarv> but I don't reommend that
06:17:53 <z0> thanks, i'll look into it
06:18:30 <boxscape> hmm now I want to write a type class that makes it so I can replace every identifier in my program by the single method of that class
06:19:04 <z0> is it less bad of an idea for record accessors?
06:19:30 <siraben> I can't seem to define `tails` in terms of `foldl`, anyone up to the challenge?
06:19:34 <geekosaur> not really, it's just more wanted and easier to avoid it giving the compiler way too much rope
06:19:44 <siraben> `tails = foldr (\ a (x:xs) -> (a:x):x:xs) [[]]`
06:19:52 <siraben> As `foldr` it's easy but not sure about `foldl`
06:21:54 <boxscape> siraben you can't make something that's exactly the same, semantically, right? Since with foldl it wouldn't work for infinite lists?
06:21:55 <solonarv> step 1. write foldr in terms of foldl, step 2. substitute that into the above definition of tails
06:21:58 <solonarv> ;)
06:22:06 <solonarv> but ye,s boxscape is right
06:22:09 <siraben> boxscape: assume lists are finite
06:22:12 <siraben> solonarv: foldr cannot be written in terms of foldl
06:22:38 <siraben> Oh, for infinite lists
06:22:57 <siraben> it's not possible, for finite lists it is
06:23:19 <dminuoso> Is there a channel to discuss AoC solutions at?
06:23:50 <solonarv> dminuoso: ##adventofcode, it seems
06:23:53 <dminuoso> Haskell too?
06:24:35 <solonarv> I see a bunch of nicks in there that I recognize from #haskell, so I'd assume as much
06:25:00 <solonarv> I've certainly never heard anything to the tone of "take your Haskell elsewhere" from there in previous years
06:27:11 <dminuoso> Alright cheers :)
06:28:50 <tomsmeding> (in fact, yesterevening there was some discussion about haskell in that channel)
06:29:10 <dminuoso> Oh I think I might have jumped the gun... 
06:29:15 <dminuoso> Today is not over. :<
06:29:29 <tomsmeding> forgot part 2?
06:29:37 <dminuoso> huh? nah
06:29:52 <solonarv> I didn't solve today's task yet because I spent an hour waiting for pandoc to compile :p
06:30:25 <dminuoso> Well no worries
06:30:34 <dminuoso> apparently today wont make it to the leader board because of an outage
06:30:53 <dminuoso> so I guess spoilers in ##adventofcode-spoilers are fair game already
06:31:45 <solonarv> I don't care about the leaderboard anyawy, the puzzles come out at 06:00 in my timezone
06:38:04 <nf> solonarv: that should be motivation to get up early!
06:40:06 <solonarv> it is, but not strong enough motivation to outweigh all the reasons to *not* get up that early ;)
06:41:29 <dminuoso> Or just dont go to bed.
06:41:30 <merijn> solonarv: Start a personal leaderobard with people in your code? :p
06:41:58 <merijn> solonarv: Pandoc compilation time sounds like an excellent excuse to work on advent of code :p
06:42:29 <dminuoso> The ‚ÄúCopyright‚Äù, ‚ÄúLicense‚Äù, ‚ÄúMaintainer‚Äù and ‚ÄúStability‚Äù fields should be obvious. An alternative spelling for the ‚ÄúLicense‚Äù field is accepted as ‚ÄúLicence‚Äù but the output will always prefer ‚ÄúLicense‚Äù.
06:42:37 <dminuoso> Okay.. what does "obvious" mean exactly?
06:42:48 <dminuoso> Put it whatever you think goes in there?
06:43:02 <dminuoso> (This is for module level haddock)
06:44:37 <dminuoso> It seems like it's just wild west.
06:46:24 <solonarv> merijn: I decided to steal jle's framework this year and it has pandoc as a dependency!
06:49:18 <z0> 4 am in my timezone. normal waking hour here is around 8
06:51:47 <merijn> solonarv: That'll teach you!
06:53:51 <solonarv> meh, at least I was able to spend that hour doing other things, instead of spending it futzing around with my half-baked framework
06:54:42 <ph88_> I found this list of different types online https://en.wikipedia.org/wiki/Substructural_type_system#Different_substructural_type_systems does anyone know what the difference is between the types mentioned there and session types ?
07:03:14 <whataday> why haskell use so many constructs in type and value?
07:03:51 <whataday> like how you define a json type to parse jason data
07:04:41 <ph88_> whataday, isn't like this with any static type programming language ??
07:05:42 <whataday> I don't know other static languages
07:05:46 <ph88_> i think even with dynamic type language you define structures for serializing into json
07:05:57 <dminuoso> 16:03:29       whataday | like how you define a json type to parse jason data
07:06:17 <dminuoso> This is an idiosyncrasie of aeson you're probably referring to
07:06:20 <hseg> code golf, round n: http://ix.io/2G9X. realized i could combine my set and map by just kicking out unneeded (k,v) pairs. still looks like it could be improved
07:06:42 <dminuoso> There's no inherent need to have a separate type just to parse JSON with aeson.
07:06:54 <dminuoso> Some library authors just fancy using typeclasses much.
07:07:12 <ph88_> dmnwhat idiosyncrasie ?
07:07:17 <whataday> I don't know aeson lib
07:07:46 <tdammers> having an intermediate Value type, so that the parsing process is two stage: JSON source -> Value -> user type
07:07:48 <whataday> I just saw someone use parsec to handle json data
07:08:21 <ph88_> and what were the constructs you saw in type and value ?
07:08:46 <merijn> hseg: eh, your combination of "head" + "IM.elems" is weird
07:09:05 <dminuoso> whataday: But yes, in Haskell we rarely use dynamic structures. It's usually better to explictly conjure data types to model your problem domain.
07:09:09 <merijn> hseg: Like, why not "lookupMin :: IntMap a -> Maybe (Key, a)"?
07:09:17 <tdammers> an alternative design would be to have something like class FromJSON a where { fromNull :: Maybe a, fromNumber :: Scientific -> Maybe a, ... }
07:09:18 <dminuoso> That means you often create lots of data types, and I think it's a good thing
07:09:24 <dminuoso> It keeps your code robust and documented.
07:09:52 <dminuoso> tdammers: I fancy the waargonaut implementation.
07:09:52 <hseg> ... as usual, my line of sight is sticky
07:10:01 <hseg> missed its existence
07:10:03 <tomjaguarpaw> I just got the dreaded <<loop>>.  Luckily it only took my 5 mins to see that I'd done  let x = ... x ...  in an invalid way. How do people normally track those down?
07:10:31 <Uniaika> tomjaguarpaw: git show on the last commit :P
07:10:32 <dminuoso> tomjaguarpaw: +RTS -xc -RTS
07:10:37 <merijn> hseg: pop could be made more efficient via alterF (but might not be worth it)
07:10:53 <whataday> data JSON = Null| Number Number'| String String| Bool Bool| Undefined| Object [(String ,JSON)]| List [JSON] deriving (Show)
07:11:28 <merijn> hseg: Also, are you *actually* code golfing or cleaning up? :p
07:11:49 <hseg> :p
07:11:54 <hseg> cleaning up
07:12:12 <tdammers> whataday: Undefined?
07:12:14 <merijn> hseg: Personally I'd move the 'go' helper into a where, because I dislike let
07:12:41 <hseg> but have been doing so several times in pursuit of the Most Elegant Form(TM) over the past couple of weeks, as new insights strike me
07:12:56 <dminuoso> tdammers: Probably Null
07:13:02 <dminuoso> Since this is JSON
07:13:06 <tdammers> dminuoso: there's a Null constructor too
07:13:09 <whataday> I don't know it yet, copy from someone
07:13:09 <dminuoso> Oh
07:13:13 <hseg> yeah, but then you get increased vertical size. matter of taste
07:13:30 <tdammers> JS distinguishes null and undefined, but JSON cannot represent the latter
07:13:30 <merijn> hseg: More scannable :p
07:13:39 <hseg> :)
07:13:55 <whataday> what is String String in there?
07:14:02 <merijn> hseg: I like empty lines around bindings too for the same reason
07:14:25 <tdammers> whataday: it's a term constructor named String that takes one argument of type String
07:14:27 <hpc> the first String is value-level, the name of the data constructor
07:14:28 <whataday> first String is a data constructor and second is a defined type?
07:14:34 <hpc> the second String is type-level, the parameter it takes
07:14:38 <hpc> String :: String -> JSON
07:14:53 <whataday> ok
07:15:08 <tdammers> it's important to remember that term-level and type-level have separate namespaces, so we can have a type named String and a term-level constructor named String, and the two won't clash
07:15:15 <whataday> reminder me Just Int
07:15:24 <hpc> (that mixing of levels always bothers me about ADT syntax)
07:15:32 <tdammers> GADT syntax is a bit clearer that way
07:15:46 <Vulfe> that does produce some code that seems needlessly hard to read
07:16:01 <boxscape> and 270 will warn about punning if people enable it
07:16:06 <dminuoso> whataday: The confusing part might be the dense syntax haskell has. We could imagine the data type be instead declared as: https://gist.github.com/dminuoso/cbe72c1dee8712d0472cfcdd91b87b02
07:16:08 <boxscape> ghc-proposal 279
07:16:10 <boxscape> uh
07:16:11 <boxscape> 270
07:16:24 <dminuoso> whataday: Does this fictional syntax make more sense, perhaps?
07:16:30 <boxscape> (String being both a type and a value constructor being an example of punning)
07:16:40 <dminuoso> On the left hand of each :: you see a data constructor being declared, and on the right hand side you see its type
07:16:45 <whataday> yeah
07:16:48 * tdammers giggles a bit at "fictional"
07:16:58 <dminuoso> ;)
07:17:14 <maerwald> is there a trick to create a unit test via an existing property test function, without touching the generator? E.g.: supply the inputs manually and then set withMaxSuccess to 1?
07:17:37 <whataday> Just Int is not a value neither a type, what we should call it?
07:17:45 <dminuoso> Nonsense! :p
07:17:56 <dminuoso> Just 1 :: Maybe Int
07:18:08 <dminuoso> Just is a data constructor, Int is a type constructor
07:18:17 <tdammers> @let data Foo = Int -- now Int is a data constructor too
07:18:21 <lambdabot>  Defined.
07:18:26 <tdammers> Just Int
07:18:27 <whataday> but you see String String
07:18:27 <dminuoso> yeah.. not helpful..
07:18:33 <dminuoso> whataday: Look at my gist!
07:18:36 <dminuoso> whataday: Does my gist make sense? :)
07:18:39 <merijn> tdammers: That's not very helpful, though >.>
07:18:47 <tdammers> merijn: yeah, I just realized that myself XD
07:19:03 <dminuoso> whataday: The data declaration is just very sense. The first "String" is the equivalent of MkString. I just renamed it to MkString for your sanity.
07:19:11 <dminuoso> The second String refers to an existing type constructor
07:20:23 <whataday> so Just Int, Just could be a new value constructor, and Int could be a defined type just like the second String jn String String
07:20:29 <merijn> Ugh...I should probably migrate my CI to Github Actions, but I don't wanna >.>
07:20:50 <dminuoso> whataday: So "Just Int" on its own is misleading
07:21:13 <dminuoso> If you wrote `data F = Just Int` then that declares a single type constructor named Just that takes a single parameter of type Int.
07:21:47 <dminuoso> It admittedly is confusing that we juxtapose a value-level thing right next to a type-level thing
07:23:00 <hseg> ok, so with the recommended changes now have http://ix.io/2Ga6
07:23:08 <byorgey> this is one reason why GADT syntax is far superior
07:23:45 <gagbo> Hello, I'm currently trying to put my xmonad config in modules to toy with cabal/stack. Trying to move the layoutHook out of xmonad.hs, I had to put a type annotation on it. Is it possible to write a partial type constraint and get the compiler to wait for call site before resolving it ? I have to put the concrete type to get it to compile instead of a simpler pattern, see
07:23:47 <gagbo> https://paste.centos.org/view/1e10bea1
07:24:07 <boxscape> Did they write value constructors and type constructors both uppercase in the language that first introduced non-GADT syntax?
07:24:24 <dminuoso> gagbo: You can use _
07:24:29 <boxscape> I imagine if you don't do that (and don't do both lowercase) it's at least slightly less confusing
07:24:50 <tomjaguarpaw> dminuoso: -xc sounds good, thanks
07:24:51 <dminuoso> Though that might not behave as nicely here
07:25:18 <byorgey> gagbo: the problem is, that type with 'l' promises that your definition will work for ANY layout, which is not true.
07:25:37 <gagbo> dminuoso: thanks
07:26:12 <gagbo> byorgey: yeah, I understood that and I did not want to promise more than necessary but I was getting a little stuck :(
07:26:16 <dminuoso> Also, I have observed that GHC will not infer the same type with _ as it would without a type signature
07:26:17 <byorgey> gagbo: you should be able to do what dminuoso suggests.  Add {-# LANGUAGE PartialTypeSignatures #-} to the top of Layouts.hs and then write  myLayouts :: _
07:26:18 <dminuoso> Strangely
07:26:27 <dminuoso> Which might be a GHC bug
07:26:38 <gagbo> I really just wanted to provide a single implementation for the type
07:26:44 <byorgey> gagbo: actually you should be able to just omit the type signature altogether --- does that work?
07:27:40 <byorgey> gagbo: you said "I had to put a type annotation on it" --- why?  What went wrong without one?
07:27:46 <gagbo> it doesn't, the error becomes about the `Window` type at the end of the signature : it gets inferred as simply `a0` and ghc can't find the correct Eq instance
07:28:08 <gagbo> I'll recompile and paste again to show
07:28:17 <dminuoso> gagbo: Enable NoMonomorphismRestriction temporarily
07:28:45 <byorgey> Oh, I see.  So yes, it might work to say  myLayouts :: ModifiedLayout AvoidStruts _ Window   (with PartialTypeSignatures enabled)
07:28:45 <dminuoso> I found that extension to be a blessing when dealing with XMonad
07:29:00 <dminuoso> byorgey: Mmm that could cause constraint errors
07:29:06 <dminuoso> Which is wwhy I said "that might not behave as nicely"
07:29:10 <gagbo> https://paste.centos.org/view/b690d3ed
07:29:12 <dminuoso> It's probably better to.. uh move it into a nested binding
07:29:48 <byorgey> I've definitely gotten stuff like this to work, but I agree it can be a bit fiddly.
07:30:10 <dminuoso> wish you could do something like
07:30:18 <dminuoso> Or maybe you can!
07:30:30 <gagbo> dminuoso: it's definitely the easier thing, I'm also toying with XMonad to discover hs, so I was trying to understand what's wrong
07:30:33 <byorgey> gagbo: can you try my suggestion with  ModifiedLayout AvoidStruts _ Window  and let us know what that does?
07:30:59 <dminuoso> % g :: (_ ~ f) => f Int; g = [1]
07:30:59 <yahb> dminuoso: ; <interactive>:113:7: error:; Wildcard `_' not allowed in a constraint; except as the last top-level constraint of a type signature; e.g f :: (Eq a, _) => blah; in the type signature for `g'
07:31:04 <dminuoso> Ahh what a shame
07:31:15 <dminuoso> That would have been cool. :>
07:32:06 <gagbo> byorgey: it compiles as well. "_", "_ Window", and "ModifiedLayout AvoidStruts _ Window" all compile
07:32:26 <byorgey> wait, just _ by itself compiles!?  weird
07:32:54 <byorgey> I am surprised that myLayouts :: _  compiles when leaving off the type signature does not
07:32:56 <boxscape> % g :: _ :~: f -> f Int; g Refl = [1]
07:32:57 <yahb> boxscape: ; <interactive>:114:6: error:; * Found type wildcard `_' standing for `_ :: * -> *'; Where: `_' is a rigid type variable bound by; the inferred type of g :: (_ :~: f) -> f Int; at <interactive>:114:24-35; To use the inferred type, enable PartialTypeSignatures; * In the first argument of `(:~:)', namely `_'; In the type `_ :~: f -> f Int'; In the
07:33:07 <boxscape> % :set -XPartialTypeSignatures
07:33:07 <yahb> boxscape: 
07:33:09 <boxscape> % g :: _ :~: f -> f Int; g Refl = [1]
07:33:09 <yahb> boxscape: ; <interactive>:116:33: error:; * Couldn't match type `_' with `[]'; `_' is untouchable inside the constraints: f ~ _ bound by a pattern with constructor: Refl :: forall k (a :: k). a :~: a, in an equation for `g' at <interactive>:116:26-29; `_' is a rigid type variable bound by; the inferred type of g :: (_ :~: f) -> f Int; at <interactive>:116:24-35; Possible fix
07:33:13 <dminuoso> byorgey: I've had the opposite happen recently, where GHC inferred more monomorphized with _ for inexplicable reasons leading to compilation errors
07:33:24 <dminuoso> So `f :: _; f = ...` didnt type check
07:33:27 <dminuoso> but `f = ...` did
07:33:38 <byorgey> yeah, I don't quite understand the semantics of wildcards especially when constraints are involved.
07:33:50 <merijn> byorgey: Does anyone? :p
07:33:50 <dminuoso> interesting, perhaps wildcards were the same reason
07:34:20 <byorgey> merijn: possibly Richard Eisenberg does, but no one else
07:35:40 <dminuoso> I have the biotech connections, so if anyone wants to participate in closing him..
07:35:42 <gagbo> byorgey: I'm really puzzled as well
07:35:46 <dminuoso> *cloning!
07:37:26 <gagbo> Thanks for the help in any case :D
07:37:56 <byorgey> sure, glad it works =)
07:38:31 <boxscape> % g :: [] :~: f -> f Int; g Refl = [1] -- at least this works
07:38:32 <yahb> boxscape: 
07:38:43 <dminuoso> gagbo: Ill file a possibly related bug report in a few minutes if you'll stick around
07:43:54 <gagbo> I'll check, but I'm 99% sure I won't understand
07:47:11 <dminuoso> gagbo: https://gitlab.haskell.org/ghc/ghc/-/issues/19013
07:48:44 <dminuoso> ^- Also byorgey in case you're curious
07:50:30 <boxscape> dminuoso fwiw it seems like that ticket would be easier to read if you just copied the content of Main.hs into the ticket body
07:50:44 <dminuoso> Mmm. I guess.
07:52:04 <dminuoso> boxscape: Does it look better now?
07:52:09 <boxscape> yes
07:53:04 <boxscape> dminuoso you also wrote tails instead of fails :)
08:06:20 <gagbo> I see an encoded ' in the issue instead of ' (g :: Lens&#39; String Char)
08:30:15 <glguy> We had a good first day turn-out for AoC on the leaderboard I advertise here. 71 people have started. If you're the 72nd person solving the problems in Haskell you might join 43100-84040706
08:30:33 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Survey 2020: https://haskellweekly.news/survey/2020.html | AoC 43100-84040706' by ChanServ
08:33:11 <boxscape> is the leaderboard unsorted at the moment?
08:33:30 <boxscape> I would've expected the color of the star to line up with the rank
08:33:52 <glguy> boxscape, pick a different ordering like "stars"
08:34:02 <boxscape> ohh, thanks
08:34:08 <merijn> boxscape: It's unranked, because first puzzle stars don't count
08:34:14 <boxscape> I see
08:34:18 <merijn> Due to an outage
08:34:48 <merijn> glguy: 72nd? Did you make a new one?
08:35:17 <merijn> Or did you mean the other people didn't solve them yet
08:35:37 <glguy> 71 people had a star in 2020 on the board when I wrote that
08:35:50 <Sose> 74 with atleast 1 star now
08:36:24 <merijn> Yeah, I just realised you weren't talking about 72 people on the board, just 71 who completed things
08:38:07 <tomsmeding> maerwald: someone on haskell-cafe complained that the ghcup installation script (not the ghcup binary itself) tries to install lots of things on the user, even if they want just e.g. HLS. https://mail.haskell.org/pipermail/haskell-cafe/2020-December/133052.html
08:39:03 <tomsmeding> just a heads-up though you probably already saw that; in my opinion the installation script shouldn't assume the user wants to install any particular thing always, but maybe that was copied from rustup?
08:39:21 <maerwald> should be an easy fix to make everything interactive
08:39:40 <maerwald> not surewhy they use the mailing list to request features
08:40:59 <tomsmeding> heh, it wasn't a feature request; that thread was about "imagine you could dream up a haskell ide, what would you want" and people started talking about the existing stuff
08:41:24 <tomsmeding> Sven responded to another email saying that you can "just use ghcup", which is true except for the installation script, apparently
08:42:28 <maerwald> should be easy enough for them to provide a PR I guess
08:42:32 <solonarv> I finally gave up on using jle's framework for AOC and just patched up mine from last year :/
08:53:09 <tomsmeding> dminuoso: there's a "&#39;" instead of a ' in the issue you just posted (#19013), just FYI :p
08:53:54 <dminuoso> tomsmeding: I hate terminals.
08:53:56 <dminuoso> THanks
08:54:16 * tomsmeding isn't sure how a html escape appearing in a code block is due to terminals somehow
08:54:18 <dminuoso> Dunno why my terminal emulator even copies these escape sequences..
08:54:32 * tomsmeding gets increasingly confused and scared
08:54:34 <dminuoso> Or actually, it was copy/paste from emacs
08:54:41 <dminuoso> Damn I have no clue.
08:54:44 <dminuoso> Or maybe it was gitlab?
08:54:51 <tomsmeding> ah emacs, that explains things
08:54:55 <dminuoso> shush
08:54:59 <tomsmeding> /s :p
08:55:16 <dminuoso> You're just jealous I can run my window manager *inside* my editor
08:55:23 <monochrom> haha
08:56:23 <tomsmeding> (the error log below the code snippet has the same html escape issue btw dminuoso)
08:57:13 <tomsmeding> even the non-ascii characters correctly, just ' was problematic it seems?
08:57:46 <dminuoso> No these are ansi escape sequences for colors
08:57:58 <dminuoso> Clearly the solution is to add a terminal emulator ontop of the gitlab issue viewer.
08:58:32 <tomsmeding> &#39; is not an ansi escape sequence
08:58:47 <tomsmeding> \e[39m could've been
08:59:10 <dminuoso> Well, remember I pasted this into the quirky mess of a gitlab editor.
08:59:23 <tomsmeding> we shall blame gitlab
09:00:51 <dminuoso> Mmm
09:00:52 <dminuoso>       This makes type inference for inner bindings fragile;
09:01:35 <dminuoso> Am I tripping into this? https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf
09:02:12 <dminuoso> Mmm no MonoLocalBinds makes no difference
09:02:21 <dminuoso> "fragile" is a strange term here
09:28:20 <shinobi_> So, I'm reading "Learn you a Haskell" online and find it really good at filling in some FP conceptual gaps coming from Scala. I just read the quicksort implementation and while I think it's awesome, it made me wonder about algorithm complexity. Imperative languages make big O easy to see, do functional programs hide complexity and performance issues? Or must you just read the code more closely do determine order of complexity? I'm 
09:28:20 <shinobi_> thinking specifically of comprehensions, they seem to pack a lot into a very little amount of code. 
09:29:28 <byorgey> glguy: I definitely won't be staying up until 11pm to do them as soon as they come out this year, but I do hope to solve all of them =)
09:30:11 <byorgey> if only I lived in the Pacific time zone.
09:30:29 <glguy> byorgey: it's the best time zone :nod:
09:31:06 <glguy> It's probably healthier to live in a time zone that discourages racing the problems
09:35:32 <dolio> What about imperative algorithms makes it easy to figure out complexity?
09:36:56 <ezzieyguywuf> why is `cabal run exe:MyExe` rebuilding everything if ghcid already built it?
09:37:11 <byorgey> dolio, interesting question.  I can't think of a reasonable answer off the top of my head.
09:37:16 <merijn> dolio: What makes you say complexity is easy in imperative algorithms?
09:37:25 <dolio> Someone above said it.
09:37:38 <merijn> ah, must've missed that
09:37:58 <dolio> Is it easy to figure out that imperative union-find has complexity proportional to the inverse of the Ackermann function?
09:38:18 <byorgey> shinobi_: generally, yes, I think you just have to read more closely.
09:39:59 <byorgey> I guess I would say that often (though not necessarily), imperative programs make control flow explicit in the code.  So you can see *syntactically* where the loops are etc.  Whereas functional programs tend to bury control flow a bit more, because you can just have e.g. higher-order operations over data structures instead of writing explicit loops
09:42:19 <glguy> I think it's probably easiest to reason in an execution model you understand.
09:43:14 <bulters> byorgey: imperative languages usually have a higher code locality
09:43:58 <shinobi_> dolio, Perhaps I shouldn't say easy, maybe easier for the reasons byorgey mentioned
09:44:05 <merijn> bulters: How so?
09:44:19 <dolio> That seems unrelated to whether or not things are imperative, and instead related to whether or not the language can usefully abstract over common control flow usages.
09:45:17 <bulters> Merijn: unless you‚Äôre using some dynamic scripting language (I‚Äôm pointing at you Ruby), you can sort of assume that the code you have to keep in memory (mental) to reason about what you‚Äôre doing is in the same unit of code
09:45:31 <merijn> bulters: eh...
09:45:38 <merijn> bulters: Hard disagree :)
09:45:55 <shinobi_> Dolio, agreed. In my mind they seemed correlated. 
09:46:02 <merijn> bulters: I've worked on big C++ applications and the stuff I needed to reason about was almost never in the same file
09:46:47 <ezzieyguywuf> also, why if `cabal repl --build time` builds the time package, does it get re-built when I add it to my `my-package.cabal` file?
09:46:49 <bulters> but if you read a function. you can reason about that function right?
09:46:52 <merijn> Hell, due to overloading and inheritance it can be unclear which different file behaviour is actually coming from :p
09:46:58 <ezzieyguywuf> am I accidentally compiling/installing things in multiple places?
09:47:02 <merijn> bulters: "Maybe"
09:47:32 <ezzieyguywuf> s/--build/--build-depends/
09:47:39 <merijn> ezzieyguywuf: Which version of time did you build via repl and which dependency did you add?
09:47:42 <bulters> Merijn: I didn‚Äôt do enough c++ to know if this is true. but usually some other function is not meddling with the way your current function is executed right ?
09:47:50 <merijn> ezzieyguywuf: Also, does your project specify any other GHC flags?
09:48:21 <merijn> bulters: If you write concurrent/threaded code then *everything* is meddling with *everything* :)
09:49:31 <bulters> fair enough. but the same applies to concurrent functional code.
09:49:33 <merijn> ezzieyguywuf: Basically, cabal computes a build plan that consists of ALL your transitive dependencies, flags, etc. every package is installed with a hash derives from transitive dependencies, version, and flags. Different configuration = different hash = seperate installation
09:49:35 <ezzieyguywuf> merijn: I didn't add a specific version to the `cabal run` command nor to my cabal file.
09:49:48 <bulters> and let‚Äôs not get started on concurrent declarative stuff ;)
09:49:52 <merijn> bulters: Less so in a pure language like Haskell, since mutability is "opt in"
09:50:06 <ezzieyguywuf> merijn: I don't have any flags specified in my cabal file (I think maybe I should...)
09:50:09 <merijn> bulters: So code only affects other code that "opts in" to being affected
09:50:38 <merijn> ezzieyguywuf: Yes, say one of you dependencies has an upperbound on time (like "< 1.8") and you installed 1.9 in the repl
09:50:42 <ezzieyguywuf> merijn: so really, cabal is going to "Just Work‚Ñ¢" and take care of everything and I shouldn't worry about it?
09:50:58 <ezzieyguywuf> merijn: that makes sense.
09:51:32 <merijn> ezzieyguywuf: With cabal-install 3.0 and later you can have infinitely many different versions (including same version, but different flags or same version, but different transitive dependencies) without them conflicting
09:51:45 <bulters> merijn: sure. but that‚Äôs state. that‚Äôs sort-of related to code locality.
09:51:58 <ezzieyguywuf> merijn: that's dope af.
09:52:14 <ezzieyguywuf> in on v3.2.0.0 so I should be good
09:52:21 <ezzieyguywuf> s/in on/I'm on/
09:52:23 <merijn> ezzieyguywuf: When you build it solves the buildplan and if that exact version is already installed, then it uses that. If that exact version isn't installed, it gets installed. End result, different projects on the same machine can never get your dependencies to conflict/stuck/wahtever
09:52:53 <bulters> merijn: didn‚Äôt know THAT.
09:52:56 <ezzieyguywuf> merijn: the main tradeoff being I could end up with gigabytes worth or packages, many of them the same but with slightly different flags or something
09:52:59 <ezzieyguywuf> which honestly I'm ok with.
09:53:05 <ezzieyguywuf> it's a fair tradeoff
09:53:23 <merijn> ezzieyguywuf: Only downside is that if you update very frequently your global store (in ~/.cabal/store/ghc-*) can get bloated, but usually I just nuke it when I upgrade GHC or once a year if it gets too big
09:53:42 <bulters> should‚Äôve been fixed 10 years ago. then I wouldn‚Äôt be doing (well paid, sure) Ruby on Rails updates where every dependency on the planet goes haywire.
09:54:00 <merijn> ezzieyguywuf: Since, after nuking it, it will just happily reinstall anything missing
09:54:14 <Boarders> is there a good way in criterion to benchmark something that prints to the screen without it printing constantly during the benchmark
09:54:27 <ezzieyguywuf> merijn: after nuking, you may be in for a long wait though, right, if you have many deps that need to be built?
09:54:28 <merijn> Boarders: Redirect stdout? :)
09:54:33 <merijn> ezzieyguywuf: Sure
09:54:46 <merijn> So, uh, don't do it have you have a deadline within 2 hours :p
09:55:02 <ezzieyguywuf> do I need to do `cabal update` with any frequency? or just wait until something doesn't work or isn't new enough?
09:55:44 <merijn> ezzieyguywuf: Naah, I update once every few months or when I need the latest version of something
09:56:25 * ezzieyguywuf nods
09:56:37 <sm[m]> I would do it semi often, especially if you care about getting the latest of something
09:56:56 <ezzieyguywuf> I'm not too interested in "the latest", I'm most interested in things just working
09:57:13 <ezzieyguywuf> man, it's really pretty sweet working with cabal
09:57:35 <ezzieyguywuf> I've only ever been exposed to c/c++ and python, and their systems (or lack thereof in the case of c/c++)
09:57:40 <geekosaur> it'll remind you every so often
09:58:03 <merijn> Yeah, I think after ~20 days it prints a reminder "hey, you last updated N days ago" when you build
09:58:33 <monochrom> Yeah just wait for it to remind you.
09:58:36 <solonarv> yeah I just update when cabal complains at me
09:58:53 <merijn> ezzieyguywuf: cabal-install has it quirks and some learning curve, but it's so much better* then anything python related I ever used
09:58:59 <dolio> Mine is complaining that I'm 60+ days out of date.
09:59:14 <merijn> * - my definition of being better being "stable", "predictable", "reliable"
10:00:30 <ezzieyguywuf> merijn: I agree with your statement and definitien of "better"
10:00:31 <solonarv> I started doing AoC today and it complained about being 55 days behind
10:00:53 <ezzieyguywuf> I can't say I can compare to some of the other newer languages though, like go and rust, though I've heard some horror stories and nodejs..
10:01:08 <ezzieyguywuf> what is AoC this is like the 3rd time I've heard it mentioned
10:01:21 <merijn> ezzieyguywuf: Advent of Code: https://adventofcode.com/
10:01:39 <merijn> ezzieyguywuf: Advent calendar of programming puzzles, 2 each day
10:02:02 <merijn> Bug glguy for the code to the #haskell leaderboard :p
10:02:26 <ezzieyguywuf> OH NEAT! I thought it was like "the beggining of Code Time!" lol
10:02:29 <ezzieyguywuf> it's like an Advent calendar!
10:03:45 <glguy> merijn: code in /topic!
10:03:58 <merijn> Guys, guys!
10:04:09 <jle`> :D
10:04:22 <geekosaur> maybe time to replace the survey link with the AoC leaderboard (or code thereto)?
10:04:22 <merijn> I managed to build a test with a (so far, after 8 runs) 100% reproduction rate of my race condition!
10:04:36 * geekosaur wonders‚Ä¶
10:04:38 <merijn> I'm a god of concurrent programming!
10:05:10 --- mode: ChanServ set +o geekosaur
10:05:13 <merijn> Considering my original test suite caught it once every 50 runs...
10:06:25 <bulters> :‚Äô)
10:06:36 <geekosaur> looks like I no longer have ops. that's probably good as it's been a couple years sce I hd any business having them
10:07:16 <bulters> it‚Äôs nice to be on the bottom of the board. no expectations whatsoever :)
10:07:22 <geekosaur> huh
10:07:49 <merijn> bulters: There's currently no ranking yet
10:07:51 <geekosaur> just slow here
10:08:02 <merijn> The 1st day puzzles aren't giving any score due to an outage
10:08:07 <bulters> not even for private ones?
10:08:28 <merijn> bulters: They're just in "join order" of the leaderboard :p
10:08:37 --- mode: geekosaur set -o geekosaur
10:09:33 <Franciman> because many used prolog, which is perfect for this task
10:09:36 <Franciman> as opposed to haskell
10:11:17 <merijn> Now I just gotta actually *fix* said race condition >.>
10:13:07 <ezzieyguywuf> neaaaat I wanna do AoC now, lol.
10:13:29 <ezzieyguywuf> but I'm hyper-focused on my hledger stuffies, b/c my wife keeps hassling me to stay up-to-date on our accounting ü§£
10:14:09 <sm[m]> stay on target ezzieyguywuf!
10:15:36 <sm[m]> We can speed you up on #hledger to free up time for AoC
10:19:29 <monochrom> Oh! The survey link. I forgot.
10:19:32 --- mode: ChanServ set +o monochrom
10:19:35 <bulters> ezzieyguywuf: or outsource your accounting. so you have time for AOC
10:19:41 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | AoC 43100-84040706' by monochrom
10:19:57 <jle`> alternatively outsouce your AOC so you have time for accounting
10:20:07 <monochrom> And what AoC link would you like to be there?
10:20:15 <bulters> :/ not sure about priorities
10:20:38 <merijn> monochrom: It's already there at the end, no?
10:21:06 <bulters> merijn: for me that‚Äôs not a link. but a number my phone tries to dial.
10:21:18 <merijn> bulters: It's the code for the leaderboard
10:21:19 <monochrom> That's a credit card number, not a URL :)
10:21:54 <bulters> yeah. I just joined. hence the on the bottom stuff.
10:22:07 <geekosaur> yeh, I went to add it and foudit there already
10:22:28 <geekosaur> apparenty I still have ops for some reason
10:23:23 <monochrom> Bah OK, there are enough ops here, I don't have to worry about it.
10:23:27 --- mode: monochrom set -o monochrom
10:24:19 <ezzieyguywuf> sm[m]: üòÇ lol thanks.
10:24:30 <sm[m]> ezzieyguywuf: and clearly you should budget and account for your AoC & accounting time
10:24:40 <ezzieyguywuf> bulters: I've thought about it, but then I'd have to use quicken or something, I doubt I can  find a plaintextaccountant
10:25:34 <monochrom> accounting for accounting time sounds like the rocket fuel equation.
10:25:48 <sm[m]> I bet you could, on #plaintextaccounting. (For some value of "accountant")
10:27:06 <ezzieyguywuf> I mean, my accountant is going to have access to all my personal finances, so it has to be somebody I trust, with accredidations or w/e
10:27:17 <sm[m]> yup
10:27:59 <sm[m]> read only access, at least
10:39:29 <merijn> ah...rats
10:39:53 <merijn> Now I need to migrate to GitHub Actions before releasing, because I ran out of credits >.>
10:43:45 <merijn> Clearly this is a sign from the universe to call it quits for today
10:44:56 <bulters> merijn: 9 hours of refueling left ;)
10:47:00 <merijn> bulters: Do they even refill?
10:47:29 <bulters> no until the next challenge.
10:48:10 <bulters> gha minutes refuel in the next billing cycle ;)
10:54:01 <siraben> What's the optimal solution running time for AoC day 1 part 2?
10:54:50 <siraben> Ah https://en.wikipedia.org/wiki/3SUM not linear? Hm.
11:52:47 <ocamler> ```
11:52:51 <ocamler> `mapOddEven :: (a -> b) -> (a -> b) -> [a] -> bmapOddEven fEven fOdd xs =  let f (i, x) = if even i then fOdd x else fEven x   in map f $ zip [1 ..] xs`
11:53:07 <ocamler> sorry let me just look up how to format on here
11:53:18 <monochrom> @where paste
11:53:18 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
11:54:11 <ocamler> thanks! https://paste.tomsmeding.com/8d1KppnN
11:54:42 <ocamler> I was wondering why this code doesn't compile with this error: https://paste.tomsmeding.com/z0OPbVsR
11:55:19 <ocamler> thanks!
11:55:37 <solonarv> ocamler: well, you wrote that your function's return type is   b  , surely you meant   [b]  ?
11:55:44 <monochrom> That.
11:56:20 <ocamler> lol
11:56:25 <ocamler> thank you sorry about the dumb question
11:56:33 <solonarv> the error message is basically GHC telling you "hey, I'm trying to figure out how   b   and   [b]   could be the same thing, but that's not possible"
11:56:47 <solonarv> happens to all of us ;)
11:59:37 <jollygood2> @hoogle readMay
11:59:37 <lambdabot> Safe readMay :: Read a => String -> Maybe a
11:59:37 <lambdabot> ClassyPrelude readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
11:59:37 <lambdabot> BasicPrelude readMay :: Read a => Text -> Maybe a
11:59:45 <jollygood2> there's something like this in base, isn't there?
11:59:49 <merijn> :t Text.Read.readMaybe
11:59:51 <lambdabot> Read a => String -> Maybe a
11:59:55 <jollygood2> thanks
12:00:07 <jollygood2> @hoogle Read a => String -> Maybe a
12:00:08 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
12:00:08 <lambdabot> Test.Tasty.Options safeRead :: Read a => String -> Maybe a
12:00:08 <lambdabot> Distribution.Compat.Prelude.Internal readMaybe :: Read a => String -> Maybe a
12:00:19 <merijn> Text.Read is in base :p
12:00:20 <tomsmeding> that ClassyPrelude is certainly Class-y
12:00:23 <jollygood2> hmm, could swear I tried that the other day
12:00:42 <monochrom> It's why they called it Classy!
12:00:53 <monochrom> I don't use hoogle anyway.
12:24:28 <ocamler> is there a data structure in haskell similar to a linked list in other languages, where I can iterate through in one direction, but also supports delete :: LList a -> Int -> LList a
12:24:43 <koz_> ocamler: List can do that.
12:25:22 <ocamler> oh I forgot to say that would be relatively fast (log n maybe?) isnt the list version O(n)
12:25:41 <solonarv> it can't be faster than O(n) with a straightforward linked list
12:26:19 <koz_> If you want log(n) deletions at an index, you want some kind of tree.
12:26:28 <koz_> (a self-balancing one at that)
12:26:34 <jle`> ocamler: do you mean like deleting at atn arbitrary location, or like deleting while you iterate?
12:26:39 <koz_> But that's more constrained than a list.
12:26:50 <koz_> If you want delete-while-iterating, a list zipper would work?
12:27:00 <jle`> Seq is a nice ordered collection with arbitrary index delete and fast iteration
12:27:19 <ocamler> deleting arbitrary location
12:27:26 <ocamler> cool I'll check it out
12:27:28 <koz_> Yeah, then Seq is probably the thing you want.
12:27:30 <jle`> from 'containers'
12:27:56 <koz_> Is Seq based on a finger tree or something?
12:28:07 <geekosaur> yes
12:28:21 <koz_> Oh, cool.
12:36:52 <ocamler> I also found this: https://hackage.haskell.org/package/stm-linkedlist-0.1.0.0/docs/Data-STM-LinkedList.html
12:37:30 <koz_> That's just a mutable linked list I think?
12:37:36 <ocamler> yeah I think so
12:38:15 <koz_> It won't give you log(n) at-index deletions.
12:38:18 <koz_> Seq will.
12:40:07 <monochrom> stm-linkedlist is a mutable thread-safe doubly-linked list if you study the source code
12:40:37 <merijn> monochrom: What is it if I don't study the source code?
12:40:41 <monochrom> Therefore it comes with all the pros and cons of doubly linked lists.
12:40:53 <monochrom> Then you pay someone to study for you.
12:40:53 <koz_> merijn: A mystery wrapped in an enigma.
12:43:13 <monochrom> Including for example if you don't have a list-wide pointer to the last node, then it takes linear time to reach the last node. For example stm-linkedlist has this problem.
12:44:18 <monochrom> Err maybe not.
12:45:09 <tomsmeding> that would be either a beginner's mistake, or a minor performance optimisation for very specific purposes
12:45:49 <monochrom> This one pulls a strange trick. I can only say it optimizes for defining fewer types/wrappers.
12:46:43 <monochrom> Its node type is this record: ptr1, ptr2, Maybe a.  Not ptr1, ptr2, a.
12:47:18 <tomsmeding> lol it's circular
12:47:22 <tomsmeding> that's indeed a strange trick
12:47:32 <monochrom> It uses a sentinel node to store: ptr1 = pointer to first real node, ptr2 = pointer to last real node, Nothing
12:48:33 <monochrom> If you conceptually have n items, then you have n+1 nodes, 1 node stores Nothing, n nodes store Just.
12:48:49 <monochrom> This is going to be royally confusing to branch predictors.
12:48:59 <tomsmeding> yeah that's a strange API, and also a pessimisation I think
12:49:13 <tomsmeding> because now you've wrapped everything in a Maybe indirection that will never be Nothing
12:49:45 <tomsmeding> ('never' meaning 'only if there is a bug')
12:50:04 <tomsmeding> s/branch predictors/users/ too
12:50:41 <monochrom> Even 1st-year Java textbooks don't do this.
13:07:07 <texasmynsted> I get an error "could not deduce (MonadFail m)" . . . on some code in a where clause. The code and the full error are here https://gist.github.com/mmynsted/2df78282ccd2ec4ac026b85e390d2d73
13:07:31 <jle`> you probably need a MonadFail constraint on m
13:07:48 <texasmynsted> Yes but can I do that in a where clause?
13:08:00 <texasmynsted> Or rather, how do I do that?
13:08:07 <jle`> (MonadFail m, MonadMetadata m) => ...
13:08:31 <monochrom> getUpdatedUTC :: (MonadFail m, MonadMetadata m) => TimeLocale -> Identifier -> m Clock.UTCTime
13:09:04 <texasmynsted> I can't add a signature to a where clause can I?
13:09:10 <texasmynsted> OOOOH
13:09:12 <texasmynsted> snap
13:09:13 <merijn> sure you can
13:09:14 <texasmynsted> okay
13:09:15 <jle`> you can, but you want to constrain the m
13:09:21 <jle`> that getUpdatedUTC uses
13:09:23 <monochrom> You can, but irrelevant for this problem.
13:09:48 <jle`> basically your original type signature was a lie
13:09:53 <texasmynsted> I can not in a "let"?
13:09:57 <texasmynsted> Hah
13:10:03 <merijn> texasmynsted: You can have type signatures in let too
13:10:05 <texasmynsted> that sound right 
13:10:05 <jle`> you claimed that getUpdatedUTC was supposed to work for all 'm', as long as m is an instance of MonadMetdata
13:10:06 <monochrom> You can, but still irrelevant for this problem.
13:10:16 <jle`> but as you implemented it, this is a broken promise
13:10:21 <merijn> texasmynsted: In GHC 8.8 "fail" was moved out of the Monad class and into MonadFail
13:10:32 <jle`> so you need to fix the promise that getUpdatedUTC is claiming, with its type signature
13:10:33 <merijn> jle`: To be fair, if this is old code it wasn't a lie in the past :p
13:10:53 <jle`> i'm not claiming any moral judgment :)
13:10:57 <jle`> only cool people lie
13:11:02 <texasmynsted> okay 
13:11:07 <mang0[m]> henlo
13:11:08 <texasmynsted> thank you both
13:11:28 <texasmynsted> I am not sure what I am thinking today
13:11:35 <merijn> texasmynsted: fail is used for failing patterns in do notation (like "do { [] <- foo; stuff }" when foo returns a non-empty list)
13:11:46 <ezzieyguywuf_sys> does cabal "clean up after itself" i.e. delete stuff it no longer needs?
13:11:54 <jle`> yeah, there miiight be a deeper issue here
13:11:55 <sclv> no
13:11:59 <geekosaur> not yet
13:12:00 <jle`> but we'll see when it gets integrated
13:12:07 <sclv> it doesn't know what you might need in the future
13:12:30 <merijn> texasmynsted: Which is bad, since not all monads have "reasonable fail mode", so as of 8.8 partial patterns in do notation (and uses of "fail") infer a MonadFail constraint, in stead of just Monad
13:12:34 <sclv> work on adding functionality to cabal would only be to let you _explicitly_ denote what you "still need" and don't
13:12:46 <sclv> with some convenient ui for this
13:12:53 <sclv> (and the "convenient" thing is what makes it hard)
13:13:16 <ezzieyguywuf_sys> so over time, my ~/.cabal directory is just going to grow and grow and grow?
13:13:21 <monochrom> 8.6 too. My students ran into this by writing "do  Just x <- ..."
13:13:30 <sclv> well sure, but you can always delete the store whenever you want
13:13:35 <sclv> and it'll recreate it as necessary
13:13:37 <merijn> ezzieyguywuf_sys: Practically, yes, for now
13:13:57 <texasmynsted> hmm
13:13:57 <ezzieyguywuf_sys> merijn: that's why you nuke it from time to time?
13:13:58 <sclv> this only doesn't work if you've cabal installed executables which keep data files there, and you can explicitly try to avoid them
13:14:20 <merijn> ezzieyguywuf_sys: I usually nuke it when I upgrade GHC (note that ~/.cabal/store has separate subdirs for each GHC you use)
13:14:29 <merijn> ezzieyguywuf_sys: Or when it gets excessively big
13:14:36 <ezzieyguywuf_sys> sclv: what is "the store"? also, how is ~/.cabal different from ~/.ghcup, both seem to contain a lot of stuff
13:15:12 <merijn> ezzieyguywuf_sys: The store is the directory/database with *all* (potentially conflicting) versions that cabal uses subsets off, hence the ~/.cabal/store directory
13:16:01 <sclv> ./ghcup contains the actual executables and data for ghc, cabal, etc
13:16:09 <sclv> ~/.cabal/store contains libraries cabal has built
13:16:19 <Younder> SPJ developes Haskell on ubuntu. Going to a rpm manager might be a problem, Any experiences with that?
13:16:38 <merijn> Younder: SPJ on Ubuntu? That seems unlikely
13:16:46 <merijn> Pretty sure he still uses Windows :p
13:16:56 <Younder> merijn, He does not
13:17:06 <sclv> if you want rpms for ghc use https://launchpad.net/~hvr/+archive/ubuntu/ghc
13:17:23 <ezzieyguywuf_sys> and ~/.cabal/bin contains...well just ghcid for me. but why is it in there and not ~/.ghcup/bin?
13:17:38 <sclv> because ghcup just manages installing ghc and cabal
13:17:46 <ezzieyguywuf_sys> hm, I see
13:17:49 <sclv> ~/.cabal/bin will contain executables you've installed _with_ cabal
13:17:59 <ezzieyguywuf_sys> does ghcup install hoogle, b/c I have that but don't see it in ~/.cabal/bin
13:18:13 <monochrom> could also be .local/bin
13:18:37 <ezzieyguywuf_sys> woah yea it is
13:18:52 <ezzieyguywuf_sys> as is hledger and ghcid (again?!?) and hlint
13:18:58 <ezzieyguywuf_sys> why is ghcid in both places?
13:19:10 <Younder> merijn, I know he workes for Microsoft Research in Cambridge. I also know he does his development in ubuntu and that his editor is emacs.
13:19:30 <monochrom> v1 commands default to .cabal/bin, v2 commands default to .local/bin.  Even this may be only an approximate short story.
13:19:36 <ezzieyguywuf_sys> the ~/.cabal/bin/ghcid is a link to somewhere in ~/.cabal/store
13:20:01 <ezzieyguywuf_sys> ok, so mostly I just won't worry about it, but it's good to know these things thank you all for your time
13:20:24 <monochrom> I am not sure why SPJ is brought up in the first place.
13:20:58 <monochrom> Ben Gamari is the one who does the releasing. Why not talk about him instead?
13:21:37 <monochrom> And even then, the whole premise of singling out one single GHC dev for what they use seems royally irrelevant.
13:22:36 <geekosaur> and the release packages come from CI, not from a personal dev build
13:22:49 <monochrom> irrelevant for the purpose of how to use rpm to install GHC, since furthermore anyone who has followed either the haskell mailing list or the GHC download webpage for the past 2 years see that Fedora packages exist.
13:23:19 <monochrom> up to date Fedora packages, at that
13:23:40 <monochrom> The question is full of non-sequitors and XY problems.
13:23:40 <geekosaur> on multiple platforms.
13:24:23 <dolio> Nobody uses rpm/deb for active work on a project anyway.
13:24:38 <dolio> In any language.
13:26:48 <hekkaidekapus_> ezzieyguywuf_sys: The symlinks in $PATH might become dangling if you delete stuff willy-nilly from the store. For that reason, I‚Äôd recommend installing binaries this way: `cabal install foo --install-method=copy --overwrite-policy=always`.
13:27:50 <bulters> dolio: I have some clients that would beg to differ ;)
13:28:11 <sclv> your clients beg? very polite clients
13:28:37 <dolio> Well, okay, maybe 'nobody uses' was overly broad. People who do should probably stop, though.
13:28:39 <sclv> "please sir, may i have some work"
13:28:47 <sclv> what if they beg you
13:29:44 <hekkaidekapus> sclv: By the way, HVR‚Äôs PPA offers .deb not .rpm, doesn‚Äôt it?
13:30:25 <dolio> PPA is an Ubuntu thing, so it would be unlikely to have rpms.
13:30:34 <bulters> sclv: don‚Äôt know what would happen actually... probably the same as usual :/
13:30:48 <sclv> fair enough they asked about ubuntu so that's why i replied, i guess i was confused
13:30:53 <sclv> anyway there's rpms around too
13:31:18 <hekkaidekapus> Ah, I didn‚Äôt know that.
13:31:25 <geekosaur> no, they claimed SPJ used Ubuntu therefore there were no up to date RPMs
13:31:31 <sclv> oh *eyeroll*
13:31:40 <sclv> anyway i haven't worried about any of this since i switched to ghcup :-)
13:31:53 <merijn> Also, he at least (also) uses WSL as of this summer :p
13:32:20 <geekosaur> which is Ubuntu-ish, at least
13:32:23 <merijn> And I'm pretty sure I've seen emails by him about people breaking his windows build before then, so I wonder where that "fact" comes from :p
13:32:39 <geekosaur> on a somewhat regular basis
13:32:48 <geekosaur> (breaking windows builds)
13:33:59 <hekkaidekapus> Younder: We might seem piling on, but the gist is: ask a question about what you want to do, leave SPJ‚Äôs setup alone.
13:34:41 <Younder> hekkaidekapus, lol never thought that would stir up such a can of worms.
13:35:17 <hekkaidekapus> Wrong statements and assumptions tend to have that effect ;)
13:35:44 <merijn> hekkaidekapus: Some right ones do too :p
13:35:52 <hekkaidekapus> lol
13:35:58 <Younder> hekkaidekapus, what was wrong exactly?
13:36:07 <merijn> hekkaidekapus: https://i.imgur.com/oBkRDB0.jpg
13:36:22 <hekkaidekapus> Younder: Let‚Äôs not there. What do you want to do?
13:36:34 <hekkaidekapus> *not go there
13:38:58 <hekkaidekapus> merijn: The pictures seem oblique, might need a fix.
13:39:45 <Younder> hekkaidekapus, decipher the type inference algorithm Haskell uses.
13:40:11 <hekkaidekapus> Through RPM?
13:40:38 <Younder> hekkaidekapus, Though the only one who truly understands it SPJ..
13:40:52 <geekosaur> uh
13:40:56 <hekkaidekapus> heh
13:41:16 <Younder> Simon Petre Jones
13:41:17 <merijn> If only someone had written a book about this...
13:41:23 <merijn> @where tapl
13:41:23 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
13:41:26 <Younder> He did
13:42:22 <sclv> TAPL's explanation of hindley milner is pretty nonrigorous and handwavy imh
13:42:24 <sclv> imho
13:42:35 <sclv> it was enough for me to sort of figure it out back in the day but its not the best book for it
13:42:49 <sclv> also ghc does a _ton_ more than that now
13:42:54 <Younder> That's not the one. SPJ wrote several books on development of the Haskell language. But the type inference part is a mess.
13:43:03 <sclv> the "typing haskell in haskell" paper gives a decent example
13:43:12 <geekosaur> ben gamari's probably the best person to ask about ghc, but in some cases he'll point you to e.g. richard eisenberg
13:43:15 <sclv> also spj's books are ancient and don't at all describe what ghc currently does
13:43:23 <sclv> ben doesn't work on the type inference part
13:43:29 <merijn> sclv: "Hindley-Milner" and "what Haskell does" are separate things
13:43:32 <geekosaur> there are far more people than just SPJ involved with ghc
13:43:46 <sclv> reading richard and spj's most recent papers and following references back gets you closest to the truth
13:43:53 <geekosaur> right, but he knows who does mostly
13:44:18 <sclv> also i know what HM and what haskell does are different, that's what i said! i only mentioned HM because that's all that's described in TAPL which you mentioned (and sketchily at best)
13:44:21 <iqubic> So (<|>) for Maybe will return the first argument if the first argument is "Just x" and the second argmuent if the first argument is "Nothing". Right?
13:44:46 <merijn> iqubic: Yes
13:44:46 <sclv> also if you know nothing about type inference, HM is the right place to _start_
13:44:48 <dminuoso> iqubic: try it out?
13:44:54 <iqubic> I did.
13:45:02 <sclv> > Just "hi" <|> Nothing
13:45:03 <dminuoso> Well what answer do you expect from us then?
13:45:04 <lambdabot>  Just "hi"
13:45:14 <sclv> > Nothing <|> Just "hi"
13:45:17 <lambdabot>  Just "hi"
13:45:18 <Younder> Just saying for maintenance purposes a petre net with forward chaining inference would provide a better basis for maintenance.
13:45:25 <sclv> lmao
13:45:42 <mang0[m]> hi
13:47:32 <geekosaur> hi
13:54:48 <monochrom> For GHC's type inference algorithm, the OutsideIn paper and the "practical type inference for arbitrary-rank types" paper will get you started
13:56:27 <monochrom> For Haskell Report's type inference algorithm, there is almost none, unless you count Mark Jone's "typing haskell in haskell"
13:58:46 <iqubic> is emacs + haskell LSP ready for use?
13:59:01 <iqubic> And does it work well with Nix + Cabal?
14:18:44 <koz_> @hoogle ($>)
14:18:45 <lambdabot> Data.Functor ($>) :: Functor f => f a -> b -> f b
14:18:45 <lambdabot> Data.Functor.Compat ($>) :: Functor f => f a -> b -> f b
14:18:45 <lambdabot> Data.Functor.Apply ($>) :: Functor f => f a -> b -> f b
14:24:00 <koz_> Does takeTill (from Attoparsec) consume everything to end-of-input if its predicate is never satisfied?
14:24:12 <newsham> off topic math question -- is there a name for constructing a matrix from two vectors as Cij = Ai * Bj?
14:25:04 <monochrom> Is that kronecker outer product?
14:25:30 <monochrom> maybe simpler outer product
14:25:38 <monochrom> err, s/simpler/simply/
14:25:41 <newsham> ty.
15:55:09 <mivael> hello! I'm in doubt, please can someone help?  Is it a right thing to say that Prelude.interact function IS NOT for (i.e. can not be used for) interactive input/output?
15:56:45 <glguy> no
16:05:09 <justsomeguy> interact is pretty useful for text filter utilities.
16:05:23 <justsomeguy> I think that's the main intended use case.
16:09:33 <glguy> It can be used interactively, but it's not a great idea or easy to do
16:10:54 <glguy> mivael: https://paste.tomsmeding.com/M4WoY6OQ
16:35:42 <monochrom> I wonder what motivates the question. Is it an online exam question? I can only think of low-quality exams to ask such na√Øve black-and-white questions.
16:39:49 <mivael> monochrom: no, that was mine.   I was stuck, forgot to use (unlines), used (show) instead.  I was not used (interact) for really interactive things, so started to question my knowledge :)
16:40:29 <monochrom> Then you did not question yourself enough.
16:40:31 <mivael> glguy: thank you!  sorry for the delay as well
16:41:25 <monochrom> Your program mentioned "show", "interact", and I'm sure a dozen other functions.
16:41:41 <monochrom> Why pick on interact? Why not pick on every one of them?
16:42:14 <monochrom> "Is show suitable for output?" is as legit a question as "is interact suitable for I/O?"
16:42:47 <monochrom> I respect questioning, I just can't respect biases.
16:42:52 <mivael> monochrom: yes, I did not question myself enough, sorry for that
16:43:56 <superstar64> is there any way to derive the free monoid from the monoid laws, and if so can someone link me to some resources that do that? 
16:46:28 <mivael> monochrom: it was not a bias, it was a statement on which I hoped to get a "no" answer.  But, indeed, I was too fast to ask without checking harder.
16:50:36 <mivael> monochrom: but I really checked the docs (and a couple of web search attempts) before asking -- and I could not find a clear statement about usage of (interact) except for non-interactive text filters
16:51:14 <monochrom> If there were one, I wouldn't trust it. As always, the correct answer is "it depends". All other answers are wrong.
16:51:34 <mivael> well, okay  :)
16:53:07 <mivael> (unlines) is a key point for simple interactive use cases, as I understood it now
17:54:36 <iqubic> Anyone know the time complexity of IntSet.fromList on an unsorted list?
18:00:28 <koz_> O(n*min(n,W))
18:00:37 <koz_> Where W is the word size of the platform in bits.
18:01:14 <iqubic> Weird.
18:01:20 <iqubic> That's so bizarre.
18:01:34 <koz_> Why?
18:01:39 <nshepperd> which doesn't really make sense as an asymptotic bound
18:02:20 <nshepperd> i bet if you benchmark it on realistic values of n you get something else
18:02:47 <ephemient> nah, I think it makes sense
18:03:32 <iqubic> Well, I have a solution to part 1 of yesterday's Advent of Code that's O(n), if you already have an IntSet of the input, and something else if you don't.
18:03:36 <ephemient> the patricia tree is somewhat fancier, but just imagine if you built a binary tree from each bit, MSB to LSB
18:04:00 <koz_> It makes sense. Insert bound is min(n,W), and you've got n-many inserts.
18:04:11 <koz_> It's maybe not as tight as it could be, but it's O, not Theta.
18:08:34 <int-e> . o O ( W is constant )
18:09:55 <ephemient> I mean, in some sense everything that terminates is O(number of states your physical hardware can be in), which is a finite number
18:10:20 <ephemient> not super useful though
18:10:50 <int-e> O(n*min(n,W)) looks like an abuse of big O to me, trying to convey more information than it rightfully can.
18:12:38 <nshepperd2> nobody uses computers with asymptotically large values of W
18:12:38 <koz_> int-e: Abuse of big-O is pretty much standard practice among algorithm analysis folks. :P
18:13:04 <koz_> (they're even kind enough to admit it sometimes)
18:13:08 <koz_> (thanks Fredkin trie)
18:13:31 <iqubic> Wish me luck, as I'm going to be trying out the Haskell LSP.
18:14:07 <int-e> koz_: I know. The sad thing is that I'm trying to convince myself that O(n*min(n,W)) should be replaced by O(n) and I can't. :P
18:14:37 <koz_> int-e: I mean, I don't think it's _that_ bad, honestly. Taking W as a parameter that _isn't_ a constant is somewhat justifiable.
18:15:01 <koz_> Yeah, it's not gonna grow without bound, fair.
18:15:28 <int-e> Yeah it kind of is, and it conveys some information about the internal behavior.
18:16:13 <int-e> anyway... maybe I can find another bikeshed to choose a color for.
18:16:26 <koz_> What bothers me more is that we have IntSet and not EnumSet. Although I guess _that_ would require Enum to not be a tyre fire.
18:16:38 <koz_> (see also IntMap versus EnumMap)
18:16:43 <int-e> koz_: I give you... Floats.
18:17:03 <koz_> int-e: What of them? The fact they have instances that lie to your face isn't unique to Enum.
18:17:08 <koz_> (assuming they have one)
18:17:37 <ephemient> > 0/0 == 0/0
18:17:40 <lambdabot>  False
18:17:55 <int-e> koz_: Somehow, Ix is perhaps the better class for this purpose.
18:18:12 <int-e> (The Data.Array one)
18:18:41 <koz_> int-e: Except Ix is no saint either.
18:18:52 <koz_> (look at 'index')
18:18:53 <int-e> better != perfect
18:19:39 <koz_> I honestly dislike them both intensely.
18:19:48 <koz_> They could both be better both in design and in implementation.
18:19:56 * koz_ looks at Enum instance for Word and sighs.
18:20:04 <int-e> Wat about index? Oh you're one of those people who dislike partial functions.
18:20:10 * koz_ then also notes the Ix instance for Word has the same problem.
18:20:24 <koz_> Uhh, yeah, I don't think disliking partiality is _that_ controversial.
18:20:34 <Vulfe> partial functions aren't even functions at all >:~(
18:20:43 <koz_> Vulfe: Abuse of nomenclature, yes. :P
18:21:29 <int-e> koz_: Doesn't change the fact that I had to sit back and think for a moment to figure out what the issue is.
18:21:51 <koz_> int-e: Sorry if I wasn't specific - it practically leaps at my face and tries to eat it.
18:22:55 <int-e> koz_: And I do think it is controversial... the controversy is not about whether partial functions can be dangerous, but about the amount of inconvenience people are willing to accept in order to avoid it.
18:23:28 <int-e> I also hardly ever use Ix methods directly.
18:24:36 <koz_> If you don't give me a total alternative, inconvenience or none, I'm calling shenanigans.
18:25:10 <koz_> If you want to have unsafeCanExplodeInYourFaceDoWhatever, you can - just give us the option to use something which won't.
18:33:49 <justsomeguy> How do you avoid partial functions? Do you just know which ones in Prelude are partial by heart, or use an alternate Prelude, or...?
18:34:17 <int-e> justsomeguy: You just work in the Maybe applicative at all times
18:34:44 <int-e> Or you define dozens of new types to capture various properties of the values.
18:34:53 <koz_> justsomeguy: More seriously, you can have alternatives to the partials, depending on the partial.
18:35:04 <koz_> It's not a one-size-fits-all solution.
18:36:13 <koz_> There are cases where partiality is hard, inefficient or awkward to avoid though.
18:37:25 <int-e> koz_: fwiw, I do agree that there should be a Maybe version of index in Data.Array, probably in the Ix class itself.
18:37:48 <int-e> (even though you can implement it using inRange and index)
18:38:01 <koz_> int-e: And FWIW, I don't think paranoid evasion of all partiality under all circumstances is a worthwhile thing.
18:38:08 <koz_> It seems nuance _does_ exist, lol. :P
18:39:06 <int-e> I suspect Ix was designed for efficiency in a context where people felt that Bool can get special treatment to be cheap... while pattern matching a Maybe result was awkward.
18:39:31 <koz_> Does Bool get special treatment to be cheap in that setting though?
18:39:34 <int-e> (That's speculation, of course. But it seems plausible to me.)
18:39:46 <koz_> I mean, yeah, it _could_ I guess, but I don't think that ever happened.
18:40:08 <int-e> For ghc, pattern matchin a Maybe or a Bool shouldn't make much of a difference.
18:40:52 <int-e> No clue what the story was for hugs, which was still relevant when Ix was designed.
18:41:12 <int-e> (And probably nhc as well.)
18:41:18 <koz_> Also, is there any particular reason why indexes are Int everywhere in Haskell?
18:41:47 <int-e> Well when you index an Array...
18:42:15 <int-e> It's efficiency again; the overhead for big integers is real.
18:42:24 <ephemient> if you're indexing in-memory data structures, you're not going to be able to use indices larger than it anyway‚Ä¶ so might as well use Int, I guess
18:42:29 <int-e> And yes, that means we have overflows.
18:42:54 <koz_> The thing is, negative indexes don't make much sense - why not Word?
18:43:09 <int-e> Did we have Word?
18:43:19 <iqubic> In the beginning there was the Word.
18:43:25 <ephemient> Word doesn't exist in Haskell 98
18:43:34 <koz_> ephemient: What about 2010?
18:44:03 <ephemient> 2010, yes
18:44:28 <int-e> 1998: Numeric types: Int, Integer, Float, Double. The semantics of these instances is given next.
18:44:55 <koz_> So, hysterical raisins. Got it. :D
18:44:56 <int-e> Ix is a Haskell 98 class and nobody changed it in the meantime.
18:44:59 <monochrom> Indexes also participate in subtractions in which sometimes an intemediate negative number makes sense.
18:45:28 <monochrom> I mean in the rest of a program.
18:45:34 <int-e> (Possibly even older?)
18:45:54 <koz_> monochrom: Is this like size_t versus ptrdiff_t in C?
18:45:58 <monochrom> This I learned from geekosaur or glguy, I forgot which.
18:45:59 <int-e> Yeah, I'd agree that subtracting indices is common.
18:46:15 <int-e> And we don't have implicit conversions to make that bearable. :P
18:47:15 <int-e> But the fact that we didn't have Word in Haskell 98 is quite interesting :)
18:48:35 <monochrom> and that after we have Word, it took another decade before the symmetry  Int : Word :: Integer : Natural was completed.
18:49:14 <monochrom> It's like someone really needed a larger collider to finally nail the Higgs boson.
18:49:34 <dminuoso> What does `Int : Word :: Integer : Natural` denote?
18:49:35 <monochrom> and so late that when it was done, no one cared any more.
18:49:51 <monochrom> analogical symmetry
18:50:04 <dminuoso> As in "Int is to Word as Integer is to Natural"?
18:50:04 <ephemient> nat is unbounded non-negative, word is bounded non-negative
18:50:10 <monochrom> yes
18:50:28 <int-e> ...so Integer has half the positive range of Natural...
18:50:46 <monochrom> I think you worded that wrong :)
18:51:00 <dminuoso> Speaking of that.. I see very little use of Word or Natural around..
18:51:04 <monochrom> Also Hilbert's Hotel taught us that it's tricky to say "half"...
18:51:32 <int-e> monochrom: no, it's really easy :)
18:51:33 <monochrom> I am dirty-minded, I use Hilbert's Brothel instead.
18:51:40 <int-e> monochrom: it just doesn't affect the cardinality
18:52:17 <monochrom> Oh haha I now get your joke.
18:52:19 <int-e> . o O ( actually it's super easy, barely an inconvenience )
18:52:34 <koz_> What Hilbert's Hospitality Establishment taught us is 'infinity is one hell of a drug'.
18:56:06 <BlackCapCoder> Is Unfoldable related to Traversable? https://gist.github.com/BlackCapCoder/4e33bd44bd01b5c99535712bfdaeb4d4
18:56:56 <koz_> Only in the way Foldable is.
18:57:08 <dminuoso> BlackCapCoder: Yes.
18:57:32 <BlackCapCoder> How? Is it weaker or stronger?
18:57:39 <dminuoso> Different.
18:58:08 <koz_> dminuoso: I wonder what an Untraversable (or some better name) would look like.
18:59:05 <BlackCapCoder> Foldr has a traversable instance (basically just []), so Foldable + Unfoldable => Traversable
19:00:06 <koz_> BlackCapCoder: Can you implement a lawful traverse method given Foldable and Unfoldable only? What would it look like?
19:00:13 <dminuoso> BlackCapCoder: It's hard to reason about Unfoldable, it doesn't seem to come with any laws. At least none are listed.
19:02:13 <BlackCapCoder> hold on, let me try to extract that from my spagetti
19:03:13 <dminuoso> BlackCapCoder: The thing is, there's this notion how Traversable lets you fill an existing structure from a list. 
19:03:55 <dminuoso> (This thinking brings you into lens-land)
19:05:01 <BlackCapCoder> koz_: http://termbin.com/0p4k
19:06:01 <BlackCapCoder> (the traversable instance is copy/paste from [] in base)
19:06:48 <koz_> BlackCapCoder: That's not quite what I meant. As I read your claim, you say that for any 'f', Foldable f and Unfoldable f imply Traversable f.
19:06:53 <koz_> Did I misunderstand?
19:07:41 <dminuoso> Id say that holds true
19:07:43 <dminuoso> given what I just said
19:08:05 <BlackCapCoder> right, but we can freely convert from/to Foldr
19:08:14 <BlackCapCoder> tail = unfold . foldrTail . unfold
19:08:25 <BlackCapCoder> This is going through Foldr
19:09:02 <dminuoso> So in lens the idea is that a `Traversal s t a b` is handwavingly equivalent to a pair of functions `contents :: S -> A^n` and `fill :: S*B^n -> T`
19:09:18 <dminuoso> With some constraints on the n, namely that it must match the length of the container
19:09:54 <dminuoso> That justified van Laarhovens representation of `data FunList a b t = Done t | More a (FunList a b (b -> t))`
19:10:11 <dminuoso> BlackCapCoder: Does that make any sense?
19:11:28 <BlackCapCoder> It makes some sence
19:11:37 <BlackCapCoder> I never got into lens
19:11:55 <dminuoso> % :i Traversal
19:11:56 <yahb> dminuoso: type role ReifiedTraversal representational nominal representational nominal; type ReifiedTraversal :: * -> * -> * -> * -> *; newtype ReifiedTraversal s t a b = Traversal {...}; -- Defined in `Control.Lens.Reified'; type Traversal :: * -> * -> * -> * -> *; type Traversal s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t; -- Defined in `Control.Lens.Type'
19:12:14 <dminuoso> So the term Traversal really is the same as a given traverse
19:12:18 <dminuoso> % :t traverse
19:12:18 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:12:29 <dminuoso> Almost
19:12:49 <dminuoso> Well not quite the same, but traverse is a valid Traversal
19:13:56 <dminuoso> So to say a structure is Traversable means there exists a canonical Traversal for it. IOWs we can pack it to a list, modify it it and fill it back
19:14:18 <dminuoso> And indeed, we can do
19:16:23 <dminuoso> % traverse %~ (+1) $ [1,2,3]
19:16:23 <yahb> dminuoso: [2,3,4]
19:16:26 <dminuoso> Doing just that
19:16:57 <dminuoso> % traverse.traverse %~ (+1) $ [[1,2,3],[10,20,30]]
19:16:57 <yahb> dminuoso: [[2,3,4],[11,21,31]]
19:17:09 <dminuoso> BlackCapCoder: Does that example help?
19:20:28 <BlackCapCoder> There's a functional perl that implements a zipper for any traversable. I think lens is like that
19:23:31 <BlackCapCoder> and that is indeed very similar to what I am doing with my Unfoldable
19:25:23 <dminuoso> BlackCapCoder: Mmm the relationship between zippers and traversals is not immediately obvious to me.
19:25:27 <dminuoso> What did you have in mind exactly?
19:26:36 <BlackCapCoder> http://okmij.org/ftp/continuations/zipper.html
19:26:45 <dminuoso> I understand what a zipper is
19:27:25 <dminuoso> I guess it makes sense when you think of a zipper as a suspended traversal
19:27:37 <BlackCapCoder> data FunList a b t = Done t | More a (FunList a b (b -> t))
19:27:41 <BlackCapCoder> data Zipper t a = ZDone (t a) | Z a (Maybe a -> Zipper t a)
19:28:13 <dminuoso> BlackCapCoder: These types are subtly different here.
19:28:21 <dminuoso> Note that FunList is an irregular type?
19:29:13 <dminuoso> Although there is a striking resemblence.
19:30:05 <BlackCapCoder> What do you mean by irregular?
19:30:21 <dminuoso> data FunList a b t = Done t | More a (FunList a b (b -> t))
19:30:30 <dminuoso> See how the third parameter changes at each depth?
19:33:39 <siraben> Is there a foldr/scanl fusion law?
19:33:40 <siraben> `bar l = foldr (\a b -> max (process a) b) 0 (scanl go (0, 0, head l, 0, Flat) (tail l))`
19:34:14 <BlackCapCoder> so we are building up a list by consing functions essentially
19:34:55 <dminuoso> BlackCapCoder: the length of the list defines the final function
19:35:03 <BlackCapCoder> got it
19:35:47 <dminuoso> let x1 = Done 'c'; x2 = More 'c' (Done toUpper); etc..
19:43:19 <sshine> siraben, as in, if it can exist or if it's embedded in base?
19:44:18 <siraben> Found it, it's in "Algebra Identities for Program Calculation"
19:44:25 <siraben> sshine: I just forgot the law and hlint doesn't appear to suggest it
19:44:32 <siraben> Very useful law
19:48:55 <siraben> HECK YES, after a long calculation, managed to derive the efficient linear time solution from the naive one
19:52:18 <jle`> heck yeaaa
20:06:07 <siraben> note to self, useful theorems for program calculation: foldr/map fusion, Horner's rule, scanl/foldl fusion, scan lemmas, foldr -> foldl if binop is associative, and of course the usual list functor laws
20:07:25 <siraben> Some of these are in hlint but only in one direction (e.g. map f . map g ‚Üí map (f . g))
20:15:09 <iqubic> What's Horner's rule?
20:15:48 <iqubic> I know what a Horner form is for a polynomial, but I fail to see how that's useful here.
20:16:14 <koz_> siraben: In the case of that _particular_ rule, it's not commonly useful to 'un-fuse' versus 'fuse'.
20:17:50 <iqubic> Yeah, going from "map (f . g)" to "map f . map g" isn't too useful.
20:18:04 <iqubic> Does this rule hold for all functors, if you switch to fmap?
20:18:24 <iqubic> Yes. This is a basic functor law.
20:18:47 <koz_> It's actually implied by parametricity from 'fmap id = id'.
20:19:21 <iqubic> Oh, is this one of the theorems for free type things?
21:06:46 <siraben> iqubic: indeed
21:07:00 <siraben> theorems for free is a great paper, I read it recently
21:28:13 <glguy> If you're doing AoC this year in Haskell, jump on the leaderboard in the topic, and join us in ##adentofcode to compare notes
21:28:31 <glguy> (of course haskell aoc questions are still welcome here)
21:45:50 <siraben> Ooh
21:46:01 <siraben> glguy: adentofcode or adventofcode?
21:46:24 <aoei> probably adventofcode lol
21:46:29 <glguy> Advent
21:48:02 <koz_> Yep, it's full on AoC fever round here.
21:48:15 <aoei> well its #haskell on freenode
21:48:18 <aoei> what do you expect :D
21:48:21 <koz_> Sometimes, I think I'm the only one _not_ participating. :P
21:48:46 <aoei> i haven't commited anything to code yet but ive been participating by trying to work out a solution to day 1 part 1 that isn't O(n^2)
21:48:49 <dsal> Thank you for being an exception to the rule.
21:48:56 <aoei> plus i did also sign up
21:48:58 <aoei> so
21:49:00 <aoei> there's that
21:49:02 <glguy> Yes, the only one. We just need you to join for 100% participation
21:49:07 <aoei> glguy: XD
21:49:08 <koz_> glguy: Not gonna happen, sorry.
21:49:28 <glguy> Ok, then I guess we change the denominator
21:49:44 <glguy> :nod: time to misuse my op powers
21:49:50 <koz_> Lol.
21:50:06 <dsal> I always spend too much time trying to write a parser or something to do the puzzles.  I'll eventually get better at megaparsec.
21:50:58 <koz_> dsal: Megaparsec parsers (and parser combinators in general) in my experience go something like this: 5 minutes to write, 5 hours to debug.
21:51:20 <dminuoso> *parsers
21:51:21 <dsal> heh.  There are always edge cases I don't quite get.
21:51:42 <dminuoso> Ever tried debugging a bison parser?
21:51:44 <koz_> dminuoso: ... I spelled it correctly?
21:51:51 <dminuoso> koz_: No that was not the joke.
21:51:53 <koz_> dminuoso: No, because I value braincells and don't use C.
21:52:01 <dminuoso> The problem is not C.
21:52:16 <dminuoso> Im not quite sure why, but it seems debugging parsers in general is complicated.
21:52:20 <koz_> dminuoso: I still value braincells, and if you're _not_ using C, why use bison?
21:52:32 <koz_> Like, 100% there are better options in other languages, surely.
21:52:44 <dminuoso> Im sure happy has similar problems
21:53:12 <koz_> dminuoso: I've never tried happy or alex, mostly because I don't think it's easier than using {mega,atto,whatever}parsec.
21:53:16 <koz_> (or faster for that matter)
21:53:40 <glguy> Happy and Alex are worth learning
21:53:56 <koz_> Also, I just realized the 'mega-' and 'atto-' prefix both indicate multiples, but one's really big, and the other really small.
21:54:05 <koz_> glguy: Why do you reckon?
21:54:14 <int-e> koz_: maybe if you spent more time writing them you wouldn't spend so much time debugging them? :)
21:54:25 <koz_> int-e: Yeah, but I can only type so slow. :P
21:54:30 <glguy> You do get a faster parser, and you get a much more recognizable grammar
21:54:38 <dminuoso> koz_: LALR parser generators tend to perform rather well, and they give you static analyzability like shift/reduce conflicts
21:54:38 <koz_> Maybe if I was like Axman6?
21:54:43 <dminuoso> But that comes at the cost of diagnostics
21:54:56 <glguy> Parser combinators make it too easy to make a mess of things
21:55:00 <dminuoso> Happy generates blazing fast parsers. GHC is a prominent example why
21:55:08 <koz_> dminuoso: Diagnostics means 'errors'?
21:55:08 <int-e> AoC is starting out with really easy problems this year
21:55:12 <dminuoso> koz_: Yeah
21:55:22 <glguy> And you still have to rearrange your grammar to fit in them
21:55:23 <koz_> Are *parsec parsers better in this regard?
21:55:24 <dminuoso> If the parser chokes on grammar, LALR parsers tend to give horrible errors
21:55:36 <dminuoso> *choke on input
21:56:10 <dminuoso> glguy: Indeed. With parser combinators you (should) end up writing something that loosely resembles BNF anyway
21:56:10 <glguy> You can add error productions to help
22:00:19 <dminuoso> Btw, when I write `f "foo"` where f is an external library and has type `f :: ByteString -> T`, then with OverloadedStrings this compiles even if bytestring is not in my build-depends
22:00:36 <dminuoso> That seems strange, I keep expecting this should fail. Why doesn't it?
22:02:31 <dolio> Because IsString is from base, and the instance is in scope from any module that transitively depends on the one that defines the ByteString instance.
22:02:42 <koz_> I guess it's because it treats "foo" as having type IsString s => s, and given that f's type forces it to ByteString, and that fits.... dolio ninja'd me.
22:03:49 <remby> is there a book for haskell like sicp?
22:05:08 <koz_> remby: There are several, but I don't think any of them are specifically aiming at the same space SICP is.
22:05:31 <koz_> . o O (Structure and Interpretation of Haskell Programs - SIHP?)
22:05:50 <koz_> (SIFP maybe?)
22:06:02 <jle`> Structure and Interpretation of Matlab Programs = ?
22:06:24 <jle`> or i guess i should have used Miranda since this is a Haskell channel
22:06:40 <koz_> jle`: ROFLLLLLL
22:06:47 <koz_> That's topos-level humour.
22:08:18 <topos> i approve
22:08:50 <int-e> Structure and Interpretation of Low-Level Yak
22:09:14 <koz_> :D
22:09:14 <dminuoso> dolio: Ah. That is somewhat unfortunate.
22:09:41 <koz_> topos: If your first book doesn't have a similar initialism, I will be disappoint.
22:09:55 <doct0rhu> Hi I have a question about `haddock`. Is it possible to document private items?
22:14:03 <int-e> doct0rhu: does the `ignore-exports` attribute do what you want? https://www.haskell.org/haddock/doc/html/module-attributes.html
22:15:00 <doct0rhu> I've found this attribute. But is it possible to use this as a CLI flag?
22:15:41 <int-e> there's --ignore-all-exports
22:15:47 <doct0rhu> `cabal new-haddock --haddock-all` only build public items. `--haddock-internal` crashes..
22:16:51 <int-e> (that's a haddock option, should be  --haddock-option=--ignore-all-exports  for cabal)
22:17:17 <doct0rhu> let me see
22:18:04 <doct0rhu> > cabal: renderBuildTargetProblem: unexpected status (TargetDisabledByUser,Nothing)
22:18:04 <doct0rhu> CallStack (from HasCallStack):
22:18:04 <doct0rhu>   error, called at ./Distribution/Client/CmdErrorMessages.hs:331:14 in main:Distribution.Client.CmdErrorMessages
22:18:06 <lambdabot>  error: Variable not in scope: cabalerror:
22:18:06 <lambdabot>      Variable not in scope: renderBuildTargetProblemerror:
22:18:06 <lambdabot>      Variable not in scope: unexpected :: t0 -> (a1, Maybe a0) -> [a]error:
22:19:01 <int-e> @where paste
22:19:02 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
22:19:13 <doct0rhu> That's the same error I saw when I `cabal new-haddock --haddock-internal`
22:20:19 <doct0rhu> https://paste.tomsmeding.com/uKGkFjPc
22:23:33 <int-e> Ah I missed --haddock-internal. That error though...
22:23:52 <doct0rhu> I've also tried `stack build <my package> --haddock --haddock-arguments=--ignore-all-exports --open`
22:24:04 <int-e> does new-haddock by itself work?
22:24:04 <doct0rhu> that doesn't build any doc..
22:25:00 <doct0rhu> well.. new-haddock alone also panics with same error
22:25:10 <doct0rhu> only new-haddock --haddock-all works
22:25:34 <int-e> let me guess, it's an executable... so you need --haddock-executables ?
22:25:56 <int-e> And then --haddock-internal as well to get the internal symbols
22:26:18 <doct0rhu> FYI, I've 2 executables. So --haddock-executables and --haddock-all both work
22:26:32 <int-e> (--haddock-all implies --haddock-executables)
22:27:20 <int-e> But the "all" refers to targets (executables, benchmarks, testsuites), not to symbols; it doesn't imply --haddock-internal.
22:28:28 <doct0rhu> you're right, but `--haddock-all --haddock-internal` crashes too
22:28:40 <doct0rhu> `--haddock-executables --haddock-internal` worked just now, but no internal items
22:28:54 <doct0rhu> now i'm trying to add that ignore-all-exports too
22:28:59 <doct0rhu> it's building now
22:30:18 <doct0rhu> oh finally that worked..
22:30:37 <int-e> The crashes are bugs, of course (maybe fixed in a newer version of cabal-install?)
22:30:53 <doct0rhu> I actually have global ghc-options `--haddock` set in my stack config but it never worked.. now I figured out why
22:32:16 <doct0rhu> is it possible to have stack build it then..
22:33:03 <doct0rhu> what `stack haddock` did is building docs for all my dependencies except my own package..
23:37:42 <carbolymer> well, realworldhaskell domain expired and the book is gone: https://book.realworldhaskell.org/ :/
23:45:30 <int-e> carbolymer: nah, the domain is fine. http://book.realworldhaskell.org/ works. the SSL certificate is broken though
23:46:27 <carbolymer> int-e, it wasn't a 10 mins ago
23:46:59 <carbolymer> int-e, oh, someone has borked http server configuration
23:47:05 <carbolymer> int-e, click on link I've posted
23:49:25 <boxscape> but the book is still gone?
23:50:03 <int-e> http works.
23:50:27 <boxscape> yeah but http://book.realworldhaskell.org/read 404s
23:51:08 <int-e> no
23:51:18 <boxscape> huh
23:51:19 <int-e> are you sure the browser isn't automatically switching to https
23:51:24 <boxscape> ohh it is
23:51:44 <boxscape> why does it direct me to red bean software
23:51:49 <int-e> (which I agree is broken)
23:51:53 <int-e> because they host that contents
23:51:58 <boxscape> I see
23:52:27 <int-e> book.realworldhaskell.org. 86400 IN     CNAME   www.red-bean.com.
23:53:30 <int-e> all the links I've found are http, so presumably https never worked.
23:54:07 <int-e> Which is a bit of a pity these days, of course.
