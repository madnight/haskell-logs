00:17:20 <guest1218> what does it mean to put <*> and <$> in parser?
00:17:37 <dsal> guest1218: same thing it means anywhere else
00:17:39 <guest1218> now I know *> and <|>
00:18:04 <dsal> :t (<$>)
00:18:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:18:17 <guest1218> what this mean? parse ((,) <$> char 'a' <*> char 'b') "ab"
00:18:22 <dsal> :t (<*>)
00:18:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:19:25 <dsal> > (,) <$> pure 'a' <*> pure 'b'
00:19:27 <lambdabot>  error:
00:19:27 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M613650078549...
00:19:27 <lambdabot>        prevents the constraint ‘(Show
00:19:41 <dsal> Yeah, that's a bit too ambiguous
00:19:45 <guest1218> (,) is a function, char 'a' is a parser
00:20:21 <guest1218> and also $>
00:20:43 <dsal> It just means run the two parsers and if they both succeed, give them to (,)
00:21:04 <dsal> $> is just half of <$>
00:21:18 <dsal> :t ($>)
00:21:19 <lambdabot> Functor f => f a -> b -> f b
00:21:53 <guest1218> wait a minute, I saw that <$> and <*> before, it's liftA2?
00:22:14 <dsal> :t liftA2
00:22:15 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:23:40 <guest1218> parse (char 'a', char 'b') "ab"?
00:23:41 <dsal> > liftA2 (,) "a" "b"
00:23:43 <lambdabot>  [('a','b')]
00:24:13 <dsal> I don't think a tuple is a parser
00:24:43 <guest1218> (,) <$> char 'a' = ?
00:25:18 <dsal> :t (,) <$> "a"
00:25:19 <lambdabot> [b -> (Char, b)]
00:25:59 <guest1218> > (+) <$> (Just 3) <*> (Just 7)
00:26:02 <lambdabot>  Just 10
00:26:05 <dsal> That's possibly confusing using list instead of parser, but it's easier if you understand the fundamentals first
00:26:07 <guest1218> this one I understand
00:26:30 <guest1218> (+) <$> (Just 3) == Just (+3)
00:26:42 <guest1218> Just (+3) <*> Just 7 = Just 10
00:26:47 <dsal> :t (+) <$> Just 1
00:26:48 <lambdabot> Num a => Maybe (a -> a)
00:27:33 <guest1218> (,) <$> "a" == \x -> (a,x)
00:27:47 <dsal> > (+) <$> Just 3 :: Expr
00:27:50 <lambdabot>  error:
00:27:50 <lambdabot>      • Couldn't match expected type ‘Expr’
00:27:50 <lambdabot>                    with actual type ‘Maybe (a0 -> a0)’
00:27:50 <guest1218> no
00:28:00 <dsal> Bah, nope
00:28:41 <guest1218> "a" == ['a']
00:28:44 <dsal> > ((+) <$> Just 3) :: Expr
00:28:46 <lambdabot>  error:
00:28:46 <lambdabot>      • Couldn't match expected type ‘Expr’
00:28:46 <lambdabot>                    with actual type ‘Maybe (a0 -> a0)’
00:29:03 <guest1218> (,) <$> "a" == [(,) 'a']
00:29:40 <dsal> > (,) 'a' 'b'
00:29:42 <lambdabot>  ('a','b')
00:29:57 <dsal> Not sure where you got that list
00:30:16 <guest1218> dsal: what list?
00:30:56 <dsal> Oh, because you fmapped into a list. It's late. Heh
00:31:42 <dsal> <$> is just fmap
00:31:52 <guest1218> (,) <$> "a" == [(,) 'a'],    (,) <$> "a" <*> "b" == [(,) 'a' 'b'] = [('a','b')]
00:32:05 <dsal> Yeah.
00:32:32 <guest1218> dsal: but I don't understand what it mean when put this on parser
00:32:49 <dsal> Which part?
00:32:59 <guest1218> (,) <$> char 'a'
00:33:02 <dsal> A parser is a lot like Maybe
00:33:28 <dsal> > succ <$> Just 'a'
00:33:30 <lambdabot>  Just 'b'
00:33:57 <dsal> You can transform values within the parser the same way you do with Maybe
00:34:02 <guest1218> dsal: (,) <$> char 'a' == char (,) 'a'?
00:34:41 <guest1218> dsal: char 'a' , is not a value constructor
00:34:58 <dsal> No, char is a function
00:35:00 <guest1218> Just is a value constructor, [] is
00:35:50 <dsal> > let char = Just in succ <$> char 'a'
00:35:52 <lambdabot>  Just 'b'
00:36:36 <guest1218> (,) <$> char 'a'  means   (,) (char 'a')'s result?
00:37:19 <guest1218> dsal: this char is same? 
00:37:32 <dsal> It means the same thing it means anywhere else. Parser might as well be Maybe. There's no conceptual difference.
00:40:09 <guest1218> dsal: what about $>
00:44:50 <merijn> guest1218: You seem to be confused by even very basic concepts these past days. I recommend grabbing a decent book and starting from the basics instead of trying to figure out definitions by asking if 10 random interpretations are correct and waiting for people to correct you
00:44:55 <guest1218> dsal: <$> <*> can work on different parsers's result, what $> is used to parser?
00:45:46 <guest1218> merijn: I finished learn yourself a haskell for good
00:46:24 <guest1218> and there's no lots of concepts in it
00:46:50 <guest1218> a decent book you mean realworld haskell?
00:48:31 <dsal> :t ($>)
00:48:32 <lambdabot> Functor f => f a -> b -> f b
00:49:02 <dsal> > Just 4 $> 'x'
00:49:04 <lambdabot>  Just 'x'
00:49:42 <guest1218> parse (char 'a' $> 'b') "" "ac" == Right 'b', it's like if-else
00:50:12 <guest1218> if char 'a' consumed, then return with 'b'
00:50:45 <dsal> What's else?
00:50:50 <pavonia> When converting a signed Integer to a Word (to store it as byte sequence), fromInteger seem to do the correct conversion. How do you go the opposite way?
00:51:33 <guest1218> dsal: consturct 'b' with char 'a''s context?
00:51:57 <guest1218> I'd like to environement, I don't know if it's proper
00:52:18 <idnar> :t fromIntegral -- @pavonia 
00:52:20 <lambdabot> (Integral a, Num b) => a -> b
00:53:37 <pavonia> idnar: No, that doesn't work, it always gives an unsigned Integer
00:54:30 <dsal> pavonia: there's a binary package that does all the conversions, including endianness
00:55:52 <idnar> pavonia: oh I see what you mean
00:56:01 <dsal> @hackage binary
00:56:01 <lambdabot> https://hackage.haskell.org/package/binary
00:56:41 <idnar> pavonia: I think you want Int* instead of Word*
00:58:08 <pavonia> How would you do it if you've got a Word* from a foreign library?
00:58:56 <idnar> > fromInteger (-1) :: Word8
00:58:58 <lambdabot>  255
00:59:55 <idnar> > let x = fromInteger (-1) :: Word8 in toInteger (fromIntegral x :: Int8)
00:59:57 <lambdabot>  -1
01:01:01 <idnar> from the Data.Int docs: "Coercing word types (see Data.Word) to and from integer types preserves representation, not sign."
01:02:05 <pavonia> Ah, thanks
01:02:17 <idnar> just make sure you go via the same-sized Int* type
01:06:42 <pavonia> I have to memorize that fromIntegral = fromInteger . toInteger
01:09:34 <dminuoso> Does aeson have an interface to deal with objects that have duplicate keys?
01:09:42 <idnar> note that there are some rewrite rules and specializations that make it perform better than its expansion
01:10:49 <dminuoso> type Object = HashMap Text Value 
01:10:51 <dminuoso> Haha nevermind I guess
01:10:58 <dminuoso> So you cant parse all valid JSON with aeson. That sucks
01:12:00 <idnar> dminuoso: https://hackage.haskell.org/package/aeson-1.5.4.1/docs/Data-Aeson-Parser.html#v:jsonWith
01:12:02 <merijn> guest1218: I mean Bird's "Thinking Functionally With Haskell", Hutton's "Programming in Haskell", or "Haskell From First Principles", LYAH is not a particularly good book, tbh
01:12:31 <merijn> pavonia: fromIntegral is the more generic version of fromInteger
01:12:47 <merijn> Oh, wait, someone already said that :p
01:12:50 <dminuoso> idnar: Mmm, strange. Alright
01:12:52 <dminuoso> Thanks!
01:13:12 <int-e> @src fromIntegral
01:13:13 <lambdabot> fromIntegral = fromInteger . toInteger
01:24:47 <gentauro> lambdabot: :|
01:24:56 <gentauro> was happening !!!
01:48:01 <ph88> does anyone know how to use this function ?  https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Lens.html#v:rlensC   i get one field from the row this works. But then how do i get the value of that field ?  when i traceShow i see something like:  MyColumn -> "myData"   but i only need "myData" 
01:50:17 <dminuoso> ph88: Presumably with `view` or (^.) from say lens/microlens?
01:52:36 <ph88> i could try that ye, not sure yet how to ... but that's a bit surprising because rgetC has as describtion: For Vinyl users who are not using the lens package, we provide a getter.
01:53:21 <kuribas> merijn: it's a shame Real World haskell never got updated, because I liked that approach.
01:55:49 <merijn> kuribas: There is a (partially?) updated RWH
01:56:37 <merijn> kuribas: https://github.com/tssm/up-to-date-real-world-haskell
01:57:48 <idnar> ph88: the getter is rgetC
02:14:09 <kuribas> can you coerce functions?
02:18:22 <kuribas> ah seems I can :-)
02:18:38 <lortabac> kuribas: what do you mean?
02:19:01 <kuribas> "f a b" where a and b are newtypes
02:19:08 <lortabac> coerce between functions whose arguments are coercible?
02:19:11 <kuribas> yes
02:19:12 <lortabac> ok
02:20:35 <lortabac> I guess it works because (->) is considered as a type constructor
02:21:55 <nshepperd2> i think (->) is considered representational
02:22:18 <nshepperd2> in its type parameters
02:24:05 <lortabac> from the GHC manual: "(->) has two representational parameters"
02:44:32 <dminuoso> Let's say I have two `IntMap T` and I want to act on all values that are on the left side, values on the right side, and values that are on both sides separately.
02:45:28 <dminuoso> Options I see include turning both into ascending lists and running Diff ontop of them
02:51:45 <opqdonut> dminuoso: why not union / difference for IntMaps?
02:52:10 <dminuoso> opqdonut: I feel like Im doing unnecessary work that way
02:53:01 <opqdonut> something like unionWith would help you classify values into these three buckets
02:53:18 <opqdonut> so you'd need only one intmap operation
02:53:45 <tomsmeding> diffing the ascending lists is probably the most efficient choice, but possibly not the most ergonomic
02:54:01 <opqdonut> mmh, yeah
02:54:12 <tomsmeding> also dminuoso, T = Int?
02:54:41 <tomsmeding> though I guess it doesn't really matter as long as you can define your "values that are on both sides" suitably
02:54:41 <opqdonut> hmm right operate on all values, not all keys
02:55:22 <dminuoso> Yeah, what I have right now is `comparingRR :: RR -> RR -> a -> a -> a -> a` as a continuation based equality with handrolled equality checking
02:55:33 <dminuoso> The thing is, the notion of equality I have is based on just some fields of RR.
02:56:09 <dminuoso> tomsmeding: The representation is not fixed really. Right now it's a pair of Text.
02:56:38 <tomsmeding> so, when you say "values that are on both sides", do you mean values that occur both as key and as value in the IntMap?
02:56:49 <tomsmeding> because that's what I understood, but that makes no sense if T ~= (Text, Text)
02:56:57 <dminuoso> Ah! Let me rephrase
02:58:43 <dminuoso> tomsmeding: Assume that I have two lists of type [(Text, RR)]
02:58:57 <dminuoso> With a notion of equality on the first element of the tuple
02:59:33 <dminuoso> but I guess my original function
02:59:50 <dminuoso> `comparingRR :: (Text, RR) -> (Text, RR) -> a -> a -> a -> a` gives me everything I want in the spot Im at
03:01:09 <tomsmeding> unsure how the a -> a -> a -> a helps here (the free theorem on comparingRR tells that it can't do anything useful with those a's), but I think what you're asking is "how do I diff these lists with a custom equality function" -- well, diff them :p
03:01:22 <tomsmeding> though to be able to diff them, you do need an ordering compatible with your equality relation
03:01:54 <tomsmeding> either that or a compatible hashing, in which a hash map can work
03:02:12 <dminuoso> the hashing would have to be perfect, Id have to dig deep into RFCs to know whether that could be done
03:02:16 <tomsmeding> having neither basically forces you to an n^2 algorithm
03:02:30 <tomsmeding> the hashing only has to be sufficient, in that a = b => H(a) = H(b)
03:02:38 <tomsmeding> though the better it is, the more efficient :p
03:04:11 <dminuoso> no, it has to be perfect, otherwise it could conflate things into being equal that are not equal
03:04:27 <dminuoso> (forcing me to test for equality again)
03:05:33 <tomsmeding> a hashmap requires both Hash and Eq :p
03:06:03 <tomsmeding> so you'll need the equality anyway
03:06:04 <dminuoso> Ah.
03:06:30 <tomsmeding> no hashmap ever relies on the fact that the hash is perfect (because usually it can't be), and double-checks with the real equality check
03:06:41 * dminuoso needs vacation
03:06:58 <tomsmeding> which is fortunately coming up
03:07:08 <tomsmeding> at least for the non-students among us
03:08:52 <tomsmeding> if you have a compatible ordering, the algorithm would be: sort both [(Text, RR)] lists by (yourOrdering . fst), then do a single-pass linear diff (a la merge phase in merge sort) to construct your partitioning
03:09:38 <tomsmeding> if you have a compatible hashing, the algorithm would be: make a HashSet of both lists, and loop over both lists individually, checking for each item whether it's contained in the other set
03:10:17 <tomsmeding> I think you need at least one of those, except if you know of a different kind of data structure that I've never seen
03:11:57 * tomsmeding explained something to a regular, is proud
03:15:50 <dminuoso> tomsmeding: there is a third alternative, which is a bit crazier
03:16:01 <dminuoso> Im really itching for this one
03:16:11 <dminuoso> https://hackage.haskell.org/package/discrimination-0.4/docs/Data-Discrimination.html#v:joining
03:16:16 <dminuoso> I *think* this one would work
03:16:59 <dminuoso> because if I sort first, and then compare again I throw away knowledge 
03:18:24 <dminuoso> In constant time :D
03:18:38 <dminuoso> Err. linear hah
03:19:27 <tomsmeding> I have no idea what 1. Decidable is, and 2. how to read the definition of joining
03:19:35 <tomsmeding> but that looks cool
03:20:12 <dminuoso> tomsmeding: The rough idea is that you can sort many data in linear time.
03:20:29 <tomsmeding> like, I think I understand what the function _should_ be doing
03:20:40 <tomsmeding> but I can't see through the spanEither &&& <$> in that definition :p
03:22:08 <boxscape> If I derive Show and Read, am I right in thinking that "read . show" should always be id and never result in a parse error?
03:22:42 <tomsmeding> no upon reflection I don't understand what 'joining' is supposed to be doing with just its arguments and the 'disc' function
03:22:54 <dminuoso> boxscape: Yes.
03:22:56 <tomsmeding> boxscape: I believe that's a guarantee that ghc gives you
03:23:04 <boxscape> hmm I'm getting a parse error :(
03:23:04 <dminuoso> That's mandated by Haskell2010
03:23:14 <boxscape> let me post the type
03:23:16 <dminuoso> boxscape: you probably have some transitive type that *does* not follow it
03:23:28 <dminuoso> boxscape: it only holds if the entire tree of data types uses deriving generated show/read instances
03:23:31 <boxscape> the only transitive type is Int
03:24:27 <boxscape> % infixl 6 :+; data Test = Int :+ Int deriving (Show, Read)
03:24:28 <yahb> boxscape: 
03:24:43 <boxscape> wait let me make sure this is what I'm thinking of
03:25:41 <dminuoso> % read (show (1 :+ 2)) :: Test
03:25:42 <yahb> dminuoso: 1 :+ 2
03:25:51 <tomsmeding> % read (show (1 :+ ((2 :+ 3) :+ 4))) :: Test
03:25:51 <yahb> tomsmeding: ; <interactive>:39:19: error:; * Couldn't match expected type `Int' with actual type `Test'; * In the second argument of `(:+)', namely `((2 :+ 3) :+ 4)'; In the first argument of `show', namely `(1 :+ ((2 :+ 3) :+ 4))'; In the first argument of `read', namely `(show (1 :+ ((2 :+ 3) :+ 4)))'; <interactive>:39:20: error:; * Couldn't match expected type `Int' with actual type `Test
03:26:01 <dminuoso> boxscape: Note, that GHC will *not* preserve the exact shape of the AST.
03:26:03 <tomsmeding> oh it's just Int
03:26:06 <dminuoso> So you could write:
03:26:11 <dminuoso> % read (show ((:+) 1 2)) :: Test
03:26:12 <yahb> dminuoso: 1 :+ 2
03:26:36 <tomsmeding> you can't observe the way the literal is written in the source code anyway
03:26:49 <dminuoso> huh?
03:26:51 <dminuoso> of course it could
03:27:01 <dminuoso> it's not source code, its just a string
03:27:06 <dminuoso> oh
03:27:08 <dminuoso> for show you mean
03:27:10 <dminuoso> mmm, yeah
03:27:11 <tomsmeding> yes
03:27:21 <tomsmeding> and the question was read . show :p
03:27:45 <tomsmeding> for all you know it was head (zipWith (:+) [1..] [2..])
03:27:54 <boxscape> hmm it works if I try it in a fresh ghci, might be some extension
03:28:17 <tomsmeding> wat
03:28:18 <dminuoso> boxscape: Im betting it's MMR!
03:28:20 <dminuoso> :p
03:28:24 <dminuoso> The usual culprit
03:28:33 <tomsmeding> oh!
03:28:44 <dminuoso> (A mixture of MMR and type defaulting)
03:28:51 <tomsmeding> yes indeed, boxscape the parse error that you get, could that be because the inferred type of the read call is wrong
03:28:56 <boxscape> hmm or wait maybe I was just being stupid because it seems to work now
03:29:16 <tomsmeding> schrödinger errors
03:29:32 <dminuoso> Heisenbug
03:29:52 <dminuoso> That term even has a wikipedia article :)
03:31:55 <boxscape> Okay it was a combination of being surprised that Read doesn't work if you don't put in parentheses and forgetting the type annotation when trying `read . show`
03:40:06 <tomsmeding> boxscape: yeah the Read instance doesn't take into account associativity, so you have the use explicit parentheses
03:40:13 <boxscape> okay
03:40:16 <boxscape> unfortunate
03:40:20 <tomsmeding> or, well, the auto-generated instance doesn't
03:40:24 <boxscape> right
03:45:43 <kuribas> Is using a lifted DataKind considered "not boring haskell"?
03:46:15 <kuribas> "data Nullable; data NotNull" vs "data Nullable = Nullable | NotNull"
03:46:42 <kuribas> IMO the lifted datakind would *improve* on error messages.
03:46:52 <kuribas> as you can never use the wrong kind.
03:51:03 <tomsmeding> now that I understand how DataKinds work, I would consider that fairly "boring haskell", as long as the lifted type is just a simple numeration, as in your example
03:51:10 <tomsmeding> but this is heavily opinion-based :p
03:51:18 <tomsmeding> also experience-dependent
03:51:24 <kuribas> true
03:52:58 <merijn> tomsmeding: DataKinds is fairly simple, the big problem is everyone "wanting to make it do too much" :p
03:53:32 <tomsmeding> see also perhaps the discussion here about the L and R types: https://github.com/haskell/containers/pull/340#pullrequestreview-43164
03:53:41 <tomsmeding> (search for "apropos of" on the page)
03:54:24 <merijn> tomsmeding: Well, the thing is that DataKinds isn't Haskell2010 and containers as-is works fine with UHC and something GHC specific like DataKinds would break that
03:54:53 <tomsmeding> ah good point
03:55:48 <merijn> So it basically means "do we literally abandon any and all hope any Haskell code can ever use anything other than GHC"
03:56:29 <lortabac> forall A. now that I understand how A works, I consider A easy :)
03:56:47 <merijn> lortabac: No
03:57:16 <tomsmeding> "If quantum mechanics hasn't profoundly shocked you, you haven't understood it yet." -- Niels Bohr
03:57:29 <merijn> lortabac: I understand how impredicative types work and I still don't "get it" :p
03:57:43 <lortabac> fair point :)
03:57:55 <merijn> tomsmeding: to be fair, Bohr was ancient and this view is largely incorrect nowadays
03:58:13 <tomsmeding> quote was mostly in jest, but thought it was sort-of relevant :)
03:58:23 <merijn> By now all the phycisists who consider QM shocking are all dead :p
04:00:25 <__monty__> That's news to me.
04:00:40 <merijn> __monty__: How so?
04:00:49 <__monty__> It's about it being shocking when you first learn about it not after spending a couple years in physics education.
04:01:35 <merijn> __monty__: I doubt Bohr's quote was about that, rather than being about the large number of "anti-" quantum mechanics phycisists at the time Bohr was alive
04:01:58 <merijn> Also, why is QM *shocking* when you first learn it? Confusing? Sure. But shocking and controversial? No.
04:02:50 <__monty__> You don't think it's shocking to find out energy is quantized?
04:03:21 <dminuoso> tomsmeding: Boring haskell is what drives this, right? https://lh3.googleusercontent.com/proxy/RlGRUeGa4FgaOzeuZPp6j1iNNbQugc8ZKi2o2RcLEyUpTyEFjbLDskWLbbt33Uu6PiJEB_d5mtMyYAxXbrJsT5MuqS1kbFF9_E2m4R-IKGRWBiodX61q1nFEOnJx
04:03:33 <merijn> __monty__: Not moreso than the original Bohr-ian notion of fixed orbits for electrons
04:04:01 <kuribas> merijn: spooky action at a distance is rather weird though
04:04:10 <dminuoso> kuribas: No it's not.
04:04:20 <kuribas> merijn: also the ability for information to go backwards in time.
04:04:23 <merijn> Anyway, this is drifting off topic
04:04:49 <dminuoso> The term "weird" tends to suggest there's something off about it, when in fact it's you who has a wrong and incorrect intuition/view of the world.
04:06:58 <lortabac> tomsmeding: DataKinds is simple until your boss suddenly introduces the new requirement that your items of type 'data Label (a :: Color)' have to be deserialized from a JSON file
04:07:22 <tomsmeding> fair point
04:07:23 <lortabac> then you have to bring down the whole singletons machinery :)
04:07:43 <tomsmeding> for some definition of "have to"
04:08:22 <tomsmeding> a GADT modelling reflecting a single value on the type level is easily written, and needs no singetons baggage
04:08:35 <tomsmeding> if your whole application does this >20 times, then sure, use singletons
04:08:58 <tomsmeding> but yes you suddenly arrive in the territory of existential types and GADTs
04:09:16 <lortabac> by "singletons" I meant the technique, not the library
04:09:18 <tomsmeding> which is not really "boring haskell" anymore
04:09:32 <tomsmeding> fair
04:10:00 <tomsmeding> on a related note, do "singletons" and "reified types" refer to the same kind of thing?
04:10:43 <lortabac> I don't know what "reified types" means
04:11:52 <tomsmeding> these are referred to as reified types: https://github.com/AccelerateHS/accelerate/blob/master/src/Data/Array/Accelerate/Type.hs#L109-L151
04:12:38 <tomsmeding> perhaps ignore the VectorType, it's weird
04:14:54 <lortabac> yes, I'd say these are singletons
04:15:05 <lortabac> it's a sort of hand-made TypeRep
04:16:02 <tomsmeding> this particular library dates from slightly before the singletons library, so some overlapping terminology is to be expected, I suppose
04:16:07 <merijn> tomsmeding: "reified" is just the opposite of abstraction
04:16:19 <merijn> Well, of "abstracted" I suppose
04:17:21 <tomsmeding> thing is I understand this trick but I don't know the details about singletons, so knowing it's, on a high level, the same trick is reassuring :p
04:17:27 <merijn> The singletons library relies on singleton (i.e. globally unique) values to be able to reify types
04:17:47 <merijn> (and values, I suppose?)
04:18:06 <tomsmeding> not sure if "reifying values" makes sense, but sure
04:18:23 <tomsmeding> but thanks :)
04:18:33 <merijn> tomsmeding: Sure it does
04:18:56 <lortabac> tomsmeding: the 'singletons' library is a generalization of this technique + a bunch of useful tools for working with these "reified" types
04:19:10 <merijn> tomsmeding: Suppose you have "Proxy :: Proxy (5 :: Nat)" you often want to reify the type 5 as value 5
04:19:18 <tomsmeding> lortabac: I see, makes sense
04:19:45 <tomsmeding> merijn: then you're still reifying a type though, not a value
04:20:27 <nshepperd2> you reify a type by turning it into a value. you reify a value by sending it to the printer :)
04:21:34 <dminuoso> nshepperd2: Trick question. How does one reify ()?
04:22:00 <merijn> tomsmeding: What? No
04:22:05 <nshepperd2> by realizing that you're standing in it
04:22:06 <merijn> tomsmeding: You're materialising a *value*
04:22:32 <merijn> tomsmeding: When I make soup, I'm not making the ingredients
04:22:46 <merijn> tomsmeding: When I reify, I reify the *result* not the inputs
04:23:11 <merijn> If I create a value 5 out of "Proxy :: Proxy 5" I'm reifying a value
04:23:26 <merijn> If I'm turning value 5 into the type 5, then I reify a type
04:23:43 <nshepperd2> that doesn't sound right
04:24:24 <merijn> nshepperd2: Well, I guess it's more like "if I turn unknown value 'x' into a type corresponding to 'x'"
04:25:12 <nshepperd2> you yourself said "reify the type 5 as value 5" where the direct object was the type
04:25:34 <merijn> "Proxy (n :: Nat) -> Integer" and "Integer -> SomeNat"
04:27:23 <merijn> nshepperd2: I stand by my earlier comparison "want to make tomato puree into soup" "want to reify the type 5 into value 5" :p
04:28:07 <nshepperd2> the verb 'make' has a lot of senses
04:28:22 <merijn> So does reify :p
04:28:52 <lortabac> "reify" is second only to "lift" :D
04:28:53 <merijn> In fact, I'd argue they are very similar :p
04:29:16 <nshepperd2> you would say 'reify the value 5 from the type 5' if it was as you describe
04:29:30 <nshepperd2> not 'reify the type 5 into the value 5'
04:29:56 <merijn> reify, verb: to convert into or regard as a concrete thing
04:31:15 <lortabac> the documentation of Data.Reflection.reify says "Reify a value at the type level", the object is "value" but the result is a type
04:31:48 <lortabac> in my experience this is the most common way of using this term
04:33:23 <lortabac> but merijn's definition seems more accurate as far as natural language is concerned
04:35:07 <nshepperd2> when you "make tomato puree into soup" you're not "making tomato puree"
04:37:01 <nshepperd2> but most other english words don't work that way
04:41:41 <nshepperd2> (that's a special syntactic form, like "making your kid go to school". but you can also say "making soup from tomato puree" which is less grammatically special)
04:43:39 <maybefbi> I tried writing a nested while loop inside a state monad: https://pastebin.com/7ipnWCFu It is ugly. Any tips on making it pretty?
04:47:13 <dminuoso> maybefbi: looks fine to me
04:47:34 <tomsmeding> merijn: so it comes down to terminology :)
04:47:51 <tomsmeding> but I guess we've agreed that the concepts, if not the precise terminology, are quite related
04:47:54 <tomsmeding> which was my question :)
04:48:32 <maybefbi> dminuoso: instead of storing local variables in the state monad using a tuple, is there a better datastructure?
04:48:34 <dminuoso> maybefbi: Oh you mean the code below?
04:48:56 <maybefbi> dminuoso: i meant this: https://pastebin.com/7ipnWCFu
04:49:12 <maybefbi> yeah the main function below
04:49:26 <maybefbi> it has a nested while loop with i and j
04:49:41 <maybefbi> it prints 1 to 100
04:49:48 <dminuoso> maybefbi: Looks fine in principle. You could perhaps try floating it into separate bindings.
04:50:15 <maybefbi> ok
04:50:18 <tomsmeding> maybefbi: is it important that the loops start at the current state, even if j is reset to 1 after each inner loop?
04:50:21 <dminuoso> There's some tweaks one could do with monad-loops and lens perhaps, but that might be overkill
04:50:58 <tomsmeding> if they always start at (1,1) anyway, you can do something like: forM_ [(i, j) | i <- [1..m-1], j <- [1..m]] $ \(i,j) -> do put (i,j) ; ...
04:51:13 <dminuoso> The main problem here is the usage of State in the first place.
04:51:20 <dminuoso> But, I dont know the context of your problem
04:51:38 <maybefbi> tomsmeding: i was aiming for an imperative style. just to get used to use monad transformer stacks
04:51:46 <tomsmeding> (yes, if you don't need State for another reason, do away with that 'put' and don't use State at all :)
04:51:48 <tomsmeding> )
04:52:00 <maybefbi> tomsmeding: besides i can implement competitive programming problems in imperative style
04:52:25 <tomsmeding> using haskell imperatively using State to solve CP problems is perhaps not the most efficient way :p
04:52:29 <tomsmeding> rather use C++ directly
04:52:30 <maybefbi> dminuoso: the context of the problem is just to create an imperative environment
04:53:07 <dminuoso> maybefbi: So you want to drag a State throughout some large program?
04:53:14 * dminuoso has had plenty of bad experiences with that approach
04:54:17 <tomsmeding> maybefbi: notice we're pushing back on the basic idea of using State like this; however, if your whole point is to play around with State, by all means go ahead :p
04:55:13 <maybefbi> yeah i know it sucks. i was thinking of netsting ReaderT (ExceptT (WriterT (StateT IO... until i can write everything like an imperative program. the state variable should be some data structure that simulates a stack i think so we can really have local variables.
04:55:45 <merijn> You can just use only IO and write everything like an imperative program
04:55:52 <merijn> Why bother with all the rest? :p
04:56:03 <maybefbi> tomsmeding: i am just playing around for now. hope to learn something from it
04:56:33 <maybefbi> merijn: better type signatures, Java like exception throwing type signatures
04:57:13 <dminuoso> maybefbi: We have mutable references with IORef.
04:57:35 <maybefbi> dminuoso: hmm yeah you are right
04:57:36 <maybefbi> what transformer stack to production programmers use?
04:57:44 <dminuoso> Whatever you need/want
04:57:45 <maybefbi> s/to/do/
04:57:49 <dminuoso> You don't need any.
04:58:14 <maybefbi> surely there is some transformer stack which is like Spring framework for Java
04:58:23 <maybefbi> which covers almost all cases
04:58:25 <dminuoso> No, transformer stacks are about something else. :)
04:58:40 <dminuoso> If you want a safe default, use IO.
04:58:41 <boxscape> is there a function like delete in base that removes every element, not just the first one?
04:58:53 <maybefbi> dminuoso: hmm ok
04:59:04 <hpc> boxscape: in a list? use filter
04:59:06 <dminuoso> boxscape: deleteBy
04:59:21 <dminuoso> or filter, yeah
04:59:26 <merijn> maybefbi: There is not universal stack, in fact, if you have a single stack used in your entire application, that's probably a code smell :p
04:59:29 <boxscape> ah, thanks
04:59:35 <hpc> if you want to be literal about "removes every element", const []
04:59:36 <hpc> :D
04:59:44 <dminuoso> merijn: Arguably. I know there's some strong proponents for application wide stacks.
04:59:48 <maybefbi> merijn: i see
04:59:53 <dminuoso> Cale likes them I think
04:59:56 <merijn> dminuoso: These people are wrong :p
05:00:02 <dminuoso> yeah well.
05:00:07 <merijn> dminuoso: No he doesn't?
05:00:13 <maybefbi> merijn: dminuoso: George Wilson and Ben Kolera likes it in Australia
05:00:20 <maybefbi> likes application wide stacks
05:00:26 <boxscape> hpc wow that's so performant!
05:00:36 <merijn> dminuoso: He likes class based DSLs, iirc
05:00:45 <dminuoso> merijn: Mmm. Maybe I misremember. Anyway
05:00:51 <boxscape> hm that might not be an English word
05:01:02 <merijn> dminuoso: Like my MonadSql thing, as in tagless stuff
05:01:29 <merijn> dminuoso: He also likes "a single newtype, rather than (visible) transformer stacks", which I also agree with :p
05:01:51 <dminuoso> maybefbi: The point of monad transformers is usually not that they "give you something you couldn't do otherwise", it's rather that sometimes they give you an expressive way to talk about a problem.
05:03:14 <hpc> or depending on how you think about such things, they take one thing and put it everywhere in an action
05:03:39 <maybefbi> merijn: single newtype App derives all possible monad typeclasses. use lenses and prisms to create Has* and As* instances for error types, configuration data structure. then use typeclass constraints on every method to compose it all into one big program
05:03:39 <hpc> like MaybeT adding "this can exit early"
05:03:54 <tzlil> hello, im trying to learn haskell and i wrote a function, but im getting syntax errors, http://0x0.st/iF52.txt can anyone tell me whats wrong with this code?
05:04:11 <dminuoso> tzlil: drop the `= element list` at the beginning
05:04:14 <merijn> tzlil: You have that in a .hs file?
05:04:22 <dminuoso> tzlil: you may not have a definition before a guard.
05:04:25 <tzlil> im getting `parse error on line 3`
05:04:27 <tzlil> oh!
05:04:30 <dminuoso> Its funny because I regularly do this mistake too! :)
05:04:33 <merijn> tzlil: Because that final line is also not allowed :p
05:04:33 <hpc> elem element list = ...
05:04:38 <hpc> and no comma on the last line
05:05:16 <boxscape> tzlil you also don't need the parentheses in `head(list)`, you can write `head list`
05:05:24 <merijn> Also, probably avoid the parenthesis in "head(list)", that's bad style and the quicker you get used to no parentheses for functions, the better
05:05:38 <merijn> And even more better: Don't use null and/or head, but use pattern matching :p
05:05:43 <boxscape> though I suspect this function will loop infinitely
05:05:54 <tzlil> thanks everyone, merijn i will look into that
05:06:38 <dminuoso> It's quite interesting how many mistakes one can write in so little code.
05:06:47 <dminuoso> tzlil: You did well, it's a record! :)
05:07:11 <tzlil> getting another error, `Parse error: module header, import declaration, or top-level declaration expected` on line 7 (aka the function call)
05:07:25 <merijn> tzlil: You can't have code at the top level
05:07:33 <merijn> tzlil: You can't just write expressions and code in files
05:07:34 <tzlil> should i do `main =` ?
05:07:53 <merijn> tzlil: Probably you wanna do something like "main = print (elem 5 [1,5])"
05:08:09 <merijn> tzlil: Or simply load the file into ghci and use functions interactively
05:08:27 * dminuoso wishes JSON was abolished
05:08:30 <tzlil> im using repl.it right now
05:08:32 <dminuoso> Is there any JSON parser that has useful diagnostics?
05:09:07 <merijn> No clue what the repl.it interface looks like
05:09:08 <tomsmeding> the syntax highlighter in your editor?
05:09:13 <tomsmeding> dminuoso: ^
05:09:20 <merijn> tzlil: "main = print (elem 5 [1,5])" will work, though :)
05:09:31 <boxscape> tzlil I believe repl.it is also based on ghci, which, if true, means you should be able to enter "elem5 [1,5]" on the right-hand side window
05:09:49 <boxscape> haven't used repl.it since they started requiring a login though
05:10:05 <tzlil> they dont? im using it without a login right now
05:10:09 <boxscape> hmm
05:10:24 <boxscape> then I must just be misunderstanding how to use the site
05:10:44 <tzlil> oh, i made an endless loop, i forgot to cut the list when i recurse
05:10:59 <dminuoso> tomsmeding: heh
05:11:09 <dminuoso> tomsmeding: I cant even get access to the raw JSON.
05:11:18 <dminuoso> Well. I have to hack around servant now
05:14:33 <tzlil> okay, my code works now, thanks everyone
05:18:43 <fuzzypixelz> I have a question
05:19:01 <fuzzypixelz> > twice f x = f . f $ x
05:19:04 <lambdabot>  <hint>:1:11: error: <hint>:1:11: error: parse error on input ‘=’
05:19:18 <fuzzypixelz> wait what
05:19:28 <geekosaur> lambdabot is not ghci
05:19:45 <geekosaur> it evaluates expressions, not definitions
05:20:46 <geekosaur> % twice f x = f . f $ x
05:20:47 <yahb> geekosaur: 
05:20:51 <geekosaur> yahb is ghci
05:21:06 <fuzzypixelz> % :t twice
05:21:07 <yahb> fuzzypixelz: (b -> b) -> b -> b
05:21:08 <geekosaur> (with limitations)
05:21:30 <fuzzypixelz> here, b can be any type, including aother functions right?
05:21:44 <dminuoso> Yes.
05:21:55 <tomsmeding> % :t twice (.)
05:21:55 <yahb> tomsmeding: ; <interactive>:1:7: error:; * Occurs check: cannot construct the infinite type: c ~ a -> c; Expected type: ((a -> b) -> a -> c) -> (a -> b) -> a -> c; Actual type: (b -> c) -> (a -> b) -> a -> c; * In the first argument of `twice', namely `(.)'; In the expression: twice (.)
05:22:02 <tomsmeding> oh right
05:22:17 <fuzzypixelz> what if we typed,
05:22:27 <fuzzypixelz> % twice' f = f . f
05:22:28 <yahb> fuzzypixelz: 
05:22:37 <fuzzypixelz> % :t twice'
05:22:37 <yahb> fuzzypixelz: (b -> b) -> b -> b
05:22:44 <fuzzypixelz> oh yeah same thing
05:22:57 <fuzzypixelz> this confused me a lot
05:22:59 <tomsmeding> % :t twice (\f -> succ . f)
05:22:59 <yahb> tomsmeding: Enum c => (a -> c) -> a -> c
05:23:12 <tomsmeding> % :t twice (\f -> succ . f) succ
05:23:13 <yahb> tomsmeding: Enum c => c -> c
05:23:18 <tomsmeding> % twice (\f -> succ . f) succ 3
05:23:19 <yahb> tomsmeding: 6
05:23:48 <tomsmeding> that's (succ . succ . succ) 3
05:24:02 <boxscape> % :t f f
05:24:02 <yahb> boxscape: ; <interactive>:1:1: error: Variable not in scope: f :: t0 -> t; <interactive>:1:3: error: Variable not in scope: f
05:24:07 <boxscape> % :t twice twice
05:24:07 <yahb> boxscape: (b -> b) -> b -> b
05:24:52 <tomsmeding> % twice twice succ 3
05:24:52 <yahb> tomsmeding: 7
05:29:05 <bitmapper> i now have a copy of hugs haskell 1.3... that implements AMP
05:29:23 <gentauro> 14:08  * dminuoso wishes JSON was abolished
05:29:34 <gentauro> dminuoso: I'm guessing you are a fan of IBMS JSONx righ?
05:29:35 <gentauro> :P
05:29:45 <geekosaur> someone's maintaining hugs?
05:29:48 <bitmapper> nope!
05:29:53 <bitmapper> i'm just messing with old hugs
05:29:54 <gentauro> https://www.ibm.com/support/knowledgecenter/SS9H2Y_10.0/com.ibm.dp.doc/json_jsonx.html
05:30:15 <gentauro> mye eyes, they are bleeding !!! https://www.ibm.com/support/knowledgecenter/SS9H2Y_10.0/com.ibm.dp.doc/json_jsonxconversionexample.html
05:30:18 <gentauro> :|
05:30:53 <tomsmeding> beautiful dynamic loading of a completely non-dynamic webpage
06:07:15 <boxscape> Is there a downside to marking functions as INLINEABLE? Longer compile times, maybe?
06:08:03 <geekosaur> yes, longer compile times
06:08:15 <boxscape> I see
06:08:19 <geekosaur> bigger .hi files which slows things down a bit
06:08:23 <boxscape> okay
06:49:27 <jollygood2> hi. I am using stack, all of my projects use very old snapshot and ghc version. I want to upgrade, but keep my old code compilable without upgrading. my question is, what am I supposed to do with my library code, on local computer, that is used by most of my projects? if I update it, it won't work with old ghc. I could just copy everything to a new directory, change name to mylibcode2, but it seems like there should be a better way
06:52:40 <merijn> jollygood2: Specify a specific git commit to depend on (pretty sure stack can handle that?)
06:55:09 <jollygood2> is it possible to do it locally? I'm not currently using git
06:57:13 <merijn> Eh, use #ifdefs so that the same code works on both versions
06:57:44 <jollygood2> can't I have multiple versions of same library locally? I guess I could just include version in the name
06:57:52 <merijn> Also, for your sake, I hope "not using git" means "because I'm using a more pleasant version control" >.>
07:17:30 <texasmynsted> okay, you got me. What is a more pleasant version control than git?
07:18:00 <merijn> texasmynsted: Mercurial, Fossil, darcs, pijul...
07:18:15 <merijn> texasmynsted: tbh, it's shorter to ask "what's worse than git?" because git is just freaking terrible
07:18:50 <merijn> (RCS, CVS, and subversion are probably worse, but in their defense they predate git by a few decades...)
07:18:54 <texasmynsted> Hm. I like git
07:19:00 <ephemient> git has a pretty good data model, it's just the ui that's all sorts of inconsistent
07:19:26 <ephemient> so I've got a good amount of tools that just just git's low-level plumbing to do what I want it to
07:19:30 <merijn> ephemient: It's data model is basically the same as the other non-patch based VCS (i.e. Mercurial and Fossil), so that's pretty unimportant
07:19:43 <merijn> texasmynsted: How many other version control systems have you used, though?
07:20:01 <merijn> The only reason git is popular is GitHub + the mythical aura of "the linux kernel uses it!"
07:20:09 <texasmynsted> The first one I used was RCS.
07:20:15 <merijn> texasmynsted: oof
07:20:43 <ephemient> sure, but mercurial doesn't expose its internals to me unless I write a proper extension while git is happy to spill its guts out
07:20:44 <texasmynsted> I have used many. 
07:20:54 <ephemient> (I suppose that could be taken as both good and bad)
07:20:57 <maerwald> merijn: nah, git performance is very good and it's one of the most feature complete ones
07:21:04 <merijn> ephemient: I've never needed that, tbh
07:21:21 <texasmynsted> i have not used mecurial, but it sounds good 
07:21:49 <merijn> maerwald: Git's performance is irrelevant for 90% of codebases, since 90% of codebases aren't linux kernel sized
07:21:59 <texasmynsted> I have an old version of pijul. It looks promising 
07:22:40 <ephemient> I did use darcs as my primary vcs, many years ago. I recall it wasn't hard to start running into performance walls with it…
07:22:45 <merijn> maerwald: And I'd rather see more work go into the Rust core for Mercurial to speed that up then git :p
07:23:10 <merijn> ephemient: I haven't used darcs much, but in practice Mercurial's performance is fine for most projects
07:24:11 <ephemient> yeah, it's usually within a constant factor of what  git could do
07:25:04 <kuribas> merijn: git is not "basically the same model".  In git I can amend my working patches to get a clean history, but still go back to the history if I want.
07:25:21 <merijn> Mercurial's "slowness" is mostly an issue for use in tooling, which is something they're aware off and working on solving, but in practice the "slowness" has never annoyed me more than git's UI
07:25:29 <kuribas> merijn: in mercurial amending would be irreversable.
07:25:37 <merijn> kuribas: Not anymore
07:25:52 <merijn> kuribas: That hasn't been the case for close to a decade with Changeset Evolution
07:26:14 <merijn> Which is clearly a superior way to handle history mutation then the clusterfuck that git has >.>
07:26:23 <merijn> Anyway, that's fairly off topic
07:27:18 <kuribas> I agree with ephemient, the UI for git sucks, but the model is pretty ok.
07:44:04 <Kronic> does anyone know what this user meant here? https://github.com/haskell/haskell-language-server/issues/590#issuecomment-725935928
07:44:27 <Kronic> I read the context and I do not understand what the workaround to solve this issue is
07:46:18 <Kronic> ah I guess pragma for lambdacase at the top of the file
07:46:27 <boxscape> yeah
07:46:51 <Kronic> Doesn't solve my issue unfortunately, this apply hints bug is really very annoying
07:48:42 <merijn> Kronic: What's the problem?
07:49:32 <Kronic> Using neovim or vscode with the haskell extension will provide hints to improve your code from hlint, I'm new so of course I want to take advantage of these to get better but automatic application of hints is broken 
07:49:57 <merijn> "improve"
07:49:57 <Kronic> Upgrading to 8.10.2 did not fix it, nor did the suggested work around so I'm just going to install the package and use it via the command line for now
07:50:49 <merijn> Kronic: Not really a solution for your problem, but note that hlint's suggestions are far from universally accepted :)
07:51:36 <Kronic> I'd imagine that's true but from what I can see they're usually better than my code
07:52:03 <merijn> Sure, just approach with healthy skepticism :)
08:23:27 <fresheyeball> so I want to add a nice expando-collapsing thing to my chrome extension, for showing Haskell data structures
08:23:38 <fresheyeball> And started looking into prior art
08:24:05 <fresheyeball> what in the heck is going on in pretty printing land in Haskell? There a tons of them, and nothing looks particularly good.
08:24:20 <merijn> Define "pretty printing"
08:24:45 <merijn> Or did you mean, like, the 100 prettyprinter packages?
08:24:51 <fresheyeball> layout of code in a manner to enhance readablity and understanding
08:24:54 <fresheyeball> yes, there are tons
08:25:04 <fresheyeball> I did a quick experiment with prettyprinter
08:25:17 <fresheyeball> and it's totally unacceptable for developer tooling
08:25:26 <fresheyeball> it prints `Nothing` as "" for example
08:25:51 <fresheyeball> I also don't see a clear way to derive the `Pretty` type class, which is a real problem if this is for developer tooling
08:26:24 <fresheyeball> I took a look at pretty-simple, but it relys on Show, which is sketchy
08:26:35 <merijn> fresheyeball: Deriving "pretty printing" is kind of a weird requirement
08:26:51 <dolio> It makes very little sense to derive.
08:27:03 <fresheyeball> if I am developing an application
08:27:13 <merijn> fresheyeball: Pretty printed data is always context dependent, thus custom
08:27:13 <fresheyeball> and just want to see the type in a readable way
08:27:37 <merijn> fresheyeball: oh, you don't want pretty printing then, lemme look up the library you want
08:27:41 <fresheyeball> I don't want to hand write instances for every single type in my system before it's useful for debugging
08:27:46 <nshepperd> you want Show but with nice layout?
08:27:54 <merijn> fresheyeball: You want https://hackage.haskell.org/package/pretty-show
08:28:03 <merijn> fresheyeball: That's "Show, but with prettier formatting"
08:28:17 <merijn> fresheyeball: The pretty printing libraries are for formatting user output
08:28:56 <sm[m]> or pretty-simple, which works with things which don't have readable show output
08:28:57 <merijn> fresheyeball: Lemme also plug: https://hackage.haskell.org/package/tree-diff
08:29:20 <merijn> fresheyeball: Which lets you print diffs of arbitrary values
08:29:29 <dolio> Have you used groom? Is pretty-show better?
08:29:52 <merijn> I haven't used groom, pretty-show was the first thing I found and I've been happy enough with it
08:30:13 <fresheyeball> pretty-show looks like it might be it
08:30:14 <dolio> Oh, pretty-show has a little more going on.
08:30:24 <fresheyeball> but now I am confused about what prettyprinter is even for
08:30:28 <dolio> groom just tweaks strings.
08:30:49 <merijn> fresheyeball: prettyprinter is for "I wanna output complicated/structured text to, say, a terminal and get sensible linewrapping"
08:31:07 <sm[m]> I was happy with it too but not being able to format anything containing a Day was a hassle
08:31:11 <merijn> fresheyeball: Stuff like the commandline help that optparse generates
08:31:22 <sm[m]> that's where pretty-simple is better
08:31:55 <merijn> fresheyeball: Or stuff like "printing out indented and aligned text", etc.
08:32:23 <fresheyeball> hmm I would have called that "formatting"
08:32:53 <fresheyeball> for some reason, pretty printing, in my mind is an alternative to ugly printing, which we would just call the `print` functino
08:33:20 <sm[m]> fresheyeball: it's a bit confusing.. historical terminology
08:33:33 <fresheyeball> well that explains why I was so confused
08:33:42 <merijn> fresheyeball: All those 100 prettyprinter libraries are dealing with that kinda formatting :p
08:34:07 <fresheyeball> the only issue I see with pretty-show
08:34:10 <fresheyeball> is the Doc type
08:34:21 <fresheyeball> appears to be opaque, and I would want to use it to generate HTML
08:35:04 <fresheyeball> oh it actually has it's own html renderer
08:38:06 <fresheyeball> I guess the question with this lib is to use the `PrettyVal` type class with Generic deriving
08:38:16 <fresheyeball> or to use the reify function which only needs `Show`
08:42:16 <fresheyeball> the output is identical, woah
08:42:27 <boxscape> kind of interesting that there isn't a single library on hackage AFAICT that defines (<<) either as flip (>>) or as (<*)
08:42:50 <merijn> :t (<<)
08:42:52 <lambdabot> error:
08:42:52 <lambdabot>     • Variable not in scope: <<
08:42:52 <lambdabot>     • Perhaps you meant one of these:
08:43:07 <merijn> heh, could've sworn that was just in Prelude
08:43:22 <sm[m]> me too
08:43:51 <dolio> It's been talked about, but I think there was some controversy about which of those two things it should be.
08:44:07 <dolio> Even though `flip (>>)` matches (=<<) better.
08:44:35 <boxscape> yeah personally I'd expect flip (>>)
08:44:45 <dolio> Which is probably the only reason I'd want it.
08:45:26 <merijn> :t getDual . (mappend `on` Dual) -- >.>
08:45:28 <lambdabot> error:
08:45:28 <lambdabot>     • Couldn't match type ‘a -> Dual a’ with ‘Dual c’
08:45:28 <lambdabot>       Expected type: a -> Dual c
08:45:40 <merijn> Oh, no, that only works for, like, 'IO ()'
08:46:52 <nshepperd> i think the fact that (<<) could be read as either of those is a good reason for it not to exist
08:47:18 <boxscape> tbh I've never actually missed it
08:47:47 <dolio> I don't use (>>) much anymore, really.
08:49:59 <boxscape> dolio because you use do, *>, or some other reason?
08:50:02 <dolio> I guess you could write confusing code if you wanted to. All the applicative operators are designed to work together, and the monad ones work together, but monad is lower precedence than applicative.
08:50:25 <dolio> Yeah, I'd probably use *> now that it exists.
08:50:31 <boxscape> I see
08:50:50 <dolio> Also, like I said above. (>>) is too low precedence to mix with applicative operators.
08:50:59 <dolio> At least reliably.
08:52:50 <Kronic> what do you use instead? Just do notation ?
08:53:04 <boxscape> Kronic *>
08:53:30 <Kronic> ah fair enough
08:53:55 <dolio> If I'm using monad operators directly, it often wouldn't matter whether I use *> or >>, because if it did, I'd probably switch to do to be clearer.
08:55:36 <dolio> I guess the only time it actually matters is if you write: expr1 >>= expr2 >> expr3
08:55:44 <dolio> Which is kind of unusual.
08:56:40 <lambda> is there a nice package for fixed-length lists/vectors? I'm implementing a custom class on n*Int tuples right now, but that of course needs a separate instance per tuple arity. Something that just takes a type parameter for the size would be great
08:56:56 <dolio> vector?
08:57:08 <dolio> Oh, type parameter.
08:57:23 <merijn> vector-sized
08:57:24 <dminuoso> lambda: vector-sized
08:57:48 <dolio> Does it need to act like a list? Inductively defined?
08:59:46 <dolio> I guess if it's replacing tuples, then probably not.
08:59:59 <lambda> dolio: maybe not necessarily, there's only a few operations I need to be able to do on them
09:00:19 <Taneb> lambda: depending on what you're after, vector-sized or linear
09:00:54 <lambda> thanks, I'll check both of those out :)
09:01:13 <Taneb> (in linear, especially Linear.V)
09:47:31 <shapr> byorgey: I once saw a web based interactive diagrams editor, does that still exist?
10:03:56 <nf> trying to run lambdabot on NixOS, i'm getting  mueval-core: NotAllowed "These modules are not interpreted:\nL\n"
10:04:05 <nf> (ping int-e)
10:26:44 <shapr> nf: oh wow, I had no idea lambdabot had a nixos package!
10:27:29 <nf> it even has a module!
10:28:07 <shapr> so I can import it into my next Haskell program?
11:19:52 <prinned> WHAT THE FUCK IS A MONAD
11:20:52 <Logio> just a monoid in the category of endofunctors
11:21:13 <prinned> oh thank you, it all makes sense now
11:21:17 <merijn> prinned: A useful abstract interface
11:21:48 <merijn> With absolutely no point in asking what it is without first learning the basics of types and type classes
11:22:34 <merijn> See also: "what the fuck is a group?", "what the fuck is a lattice?", "what the fuck is a ring?", and countless other abstract defintitions
11:22:38 <Logio> or alternatively, algebra, group theory and categories
11:23:45 <[exa]> prinned: overloaded semicolon&assignment interface for programs
11:24:58 <merijn> [exa]: tbh, I think that in general that description is more harmful than helpful
11:25:37 <monochrom> Yes but not in this case.
11:25:48 <monochrom> Nothing is harmful in this case.
11:28:02 <shapr> prinned: It's a 'magic semicolon' where you can insert a piece of code between calls
11:28:53 <shapr> for example, instead of a bunch of nested if-then-else calls, you could use the Maybe monad to bail out as soon as you get a failing result.
11:29:27 <shapr> yeah, what [exa] said
11:31:47 <monochrom> I think if you improve "assignment" to "static single assignment", then Moggi would approve, because that's what he did.
11:32:28 <monochrom> Our "do { x <- xxx; y <- yyy; zzz }" becomes his "let x = xxx; y = yyy in zzz".
11:40:48 <emmanuel_erc> Has anyone here experienced any issues with groundhog in GHC8.6?
11:51:40 <exarkun> What is the correct answer for SSL/TLS in Haskell?
11:52:28 <glguy> exarkun: I like HsOpenSSL for my own projects
11:53:20 <glguy> which is how I'm talking to you now
11:54:15 <exarkun> Should I worry that https://hackage.haskell.org/package/HsOpenSSL-0.11.5.1/docs/OpenSSL.html says "Features that aren't (yet) supported: SSL network connection"?  If you're using it right now that seems to suggest a very subtle reading of this claim required.
11:55:33 <ephemient> if it does what you need, good; if it doesn't, dig in and add some bindings
11:55:35 <glguy> exarkun: It's covered enough
11:55:49 <glguy> I've had to add a couple bindings for more esoteric things I wanted
11:56:13 <glguy> but none of the alternatives comes close to coverage
11:56:18 <exarkun> Okay, cool
11:56:19 <glguy> to its*
11:57:12 <shapr> I wish we had an index for questions like this "What's the best library for X purpose?"
11:57:27 <merijn> Best is a highly subjective definition
11:57:30 <glguy> shapr: I think in general it would be hard to get agreement
11:57:42 <merijn> A lot of people claim "beam" is the best Haskell database library
11:57:43 <shapr> perhaps a feature matrix specific to each purpose?
11:58:02 <merijn> *I* say it's an atrocious mess of unreadable types I wouldn't inflict on my worst enemy >.>
11:58:40 <exarkun> And then ... is there some trick that people use to deal with the fact that `Socket` and `SSL` are not the same type?
11:58:48 <monochrom> Don't worry, your worse enemies would inflict it on themselves. :)
11:58:52 <merijn> shapr: That implies amount of features is more important than robustness, performance, pleasantness of abstraction, ease of extension, etc.
11:59:08 <exarkun> If I'm using a library that works on `Socket` then I'm probably just out of luck when it comes to TLS?
11:59:19 <merijn> shapr: Working out how Hackage's voting/vetting mechanism should work is probably best :p
12:00:08 <merijn> exarkun: You're not, but you're gonna have to get your hands dirty and possibly give up on Windows support :p
12:00:16 <merijn> Oh, wait, no
12:00:42 <merijn> exarkun: Or did you mean the library you use wants to directly talk to the socket?
12:00:55 <glguy> If the library wants a literal 'Socket' you're SOL
12:01:01 <exarkun> Okay let me dig out the actual types that are involved here
12:01:05 <glguy> In that case you can do something externally with socat
12:02:01 <exarkun> oh, I assumed it worked on `Socket` itself because I saw `Socket` in one place but I was looking in the wrong place, I guess it has a layer of indirection between the Socket and all the rest of the app code
12:02:16 <exarkun> So I guess it's actually fine
12:07:44 <exarkun> the indirection is Data.Streaming.Network.AppData but there is no public AppData constructor?
12:09:53 <merijn> It usually helps to clue people in which package a module is from ;)
12:10:47 <exarkun> sorry, streaming-commons
12:11:07 <exarkun> https://hackage.haskell.org/package/streaming-commons-0.2.2.1/docs/Data-Streaming-Network.html#t:AppData
12:13:14 <exarkun> Okay I accidentally stumbled across https://hackage.haskell.org/package/network-conduit-tls-1.3.2/docs/Data-Conduit-Network-TLS.html
12:13:27 <exarkun> But that just means network-conduit-tls uses the internal AppData constructor right?
12:14:05 <exarkun> which I guess is possible because snoyman is maintainer on both of them
12:14:35 <exarkun> but surely I'm not supposed to reach into Data.Streaming.Network.Internet to get that constructor
13:04:19 <dminuoso> exarkun: If you have security relevant software, you should ffi into openssl.
13:05:18 <dminuoso> Oh shoot, I was scrolled up again
13:07:18 <dontworry> can i talk here
13:07:21 <dminuoso> Yes.
13:07:45 <aev_software> Yes
13:07:49 <dontworry> kl half the other ircs didnt let me talk 
13:10:25 <lambda> what's the prettiest way to get `[[a]] -> [((Int, Int), a)]`, i.e. flattening a 2d list while keeping the indices?
13:11:02 <glguy> lambda: I liked parse input = [(x,y) | (y,line) <- zip [0..] input, (x,'#') <- zip [0..] line]
13:11:26 <lambda> glguy: hm, yeah, that works well
13:11:32 <lambda> I keep forgetting about list comprehensions
13:12:33 <glguy> > itoListOf (folded Control.Lens.<.> folded) ["one","two"]
13:12:35 <lambdabot>  [((0,0),'o'),((0,1),'n'),((0,2),'e'),((1,0),'t'),((1,1),'w'),((1,2),'o')]
13:13:04 <lambda> I think the first one might be more readable ;)
13:13:18 <dminuoso> Well, if you drop the qualifier, it's just
13:13:28 <dminuoso> itoListOf (folded <.> folded)
13:13:38 <dminuoso> If you're versed in lens, it's quite readable :)
13:13:48 <lambda> I'm not, so that might be why
13:40:16 <glguy> lambda: is that for adventofcode?
13:43:27 <ph88> Does anyone know how i can get the value after using this lens getter ?  https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Lens.html#v:rgetC 
13:47:48 <dsal> ph88: didn't you ask that a few hours ago?  Did none of the suggestions work?
13:48:15 <ph88> dsal, yes i did .. don't remmember suggestions, maybe i missed them. let me see
13:49:20 <ph88> <dminuoso> ph88: Presumably with `view` or (^.) from say lens/microlens?
13:49:33 <ph88> i tried this suggestion with view, i get a type error. Let me pastebin that
13:51:03 <ph88> dsal, https://bpa.st/6IGQ 
13:54:47 <dsal> You told it it was something else.
13:55:52 <dsal> rgetC appears to not be a lens.  "For Vinyl users who are not using the lens package, we provide a getter."
13:57:28 <ph88> dsal, sorry i understood it as being a lens but not needing lens package
13:57:31 <dsal> rlensC is a lens, but you're doing a bunch of stuff at once and it's conflicting.   I don't know this library, but I think breaking it down into more parts would be easier.  It doesn't look like that is going to give you an r.
13:58:16 <dsal> `  rgetC = getConst . rlensC Const`
13:58:30 <dsal> It's a convenient way to unlens a lens for this purpose.
13:58:48 <ph88> dsal, when i remove "view"  it compiles and i can show/print it ... but it's not the raw value ... it's the value with the name of the field pointing towards it 
13:59:29 <ph88> prints as:   PLN :-> "myValue"
13:59:46 <ph88> i just need   "myValue" really
14:00:07 <ph88> maybe if i put it inside just a Text it will just become a Text ?
14:01:26 <ph88> hmm nope .. that thing is of type   ElField '("PLN", Text)   i would like to get out just the Text part ...
14:01:55 <ph88> https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Functor.html#t:ElField
14:03:17 <ph88> data ElField (field :: (Symbol, Type)) where    Field :: KnownSymbol s => !t -> ElField '(s,t)     i don't understand this type, how to get out   t  
14:05:51 <dsal> It looks like the same way you get x out of x + 1
14:06:36 <ph88> o_O
14:06:47 <ph88> - 1   ??
14:10:10 <monochrom> That one looks like very intimidating-on-surface but at its heart is just another GADT.
14:10:51 <ph88> i'm intimidated alright
14:17:25 <tomsmeding> ph88: let Field value = yourThing in value
14:17:42 <tomsmeding> well, probably: case yourThing of Field value -> value
14:18:14 <tomsmeding> doing it with a let-binding has chances of not working due to monomorphism restriction-related things
14:19:12 <tomsmeding> ph88: for some brief info about GADTs, see e.g. https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#gadt
14:20:13 <ph88> oh i have to do case matching
14:23:53 <ph88> with this function it works   getVal :: ElField '(s, t) -> t   getVal (Field field) = field     thank you tomsmeding 
14:26:24 <tomsmeding> ph88: or, indeed, with a function binding :)
14:26:25 <tomsmeding> nice
16:06:46 <sshine> if I've got a playing card data type, its Eq instance should be easy. but I am conflicted about its Ord instance: on the one hand, Card Spades Ace is not less than Card Hearts Ace, but on the other hand, if they're not greater than each other, and they're not equal, Eq and Ord disagree.
16:07:22 <glguy> if you have some semantically interesting comparison function you can make that separate from Ord
16:07:25 <sshine> so for the purpose of making an arbitrary but consistent Ord class for inserting cards into containers, anything goes. and for the purpose of making it logically meaningful, meh.
16:07:37 <glguy> Ord is good for being an arbitrary total order that can be handed off to Map and friends
16:07:38 <Rembane> On the third hand, EQ and (==) are not the same thing, so eh... 
16:07:46 <hpc> in some games, there is an ordering of suits
16:08:05 <sshine> glguy, ah, so you're saying: name the comparison function and accept that Ord is a little funky.
16:08:15 <glguy> I'd suggest if you have a semantically important comparison, name and document it
16:08:24 <glguy> and then use that with things like sortBy or whatever as needed
16:08:36 <sshine> hpc, right. so it'd make sense to not narrow Ord down to express a whole lot other than something consistent.
16:08:49 <sshine> glguy, makes perfect sense.
16:08:52 <sshine> thanks guys.
16:09:39 <sshine> and yes, different games have completely different card orders. :)
16:09:57 <sshine> sometimes even determined by some arbitrary state of the game.
16:15:11 <sshine> here's another thing; I recently interviewed for a job where the code test had to do with randomly generated passwords. I thought the shortest path was through QuickCheck generators. it was fine for demonstration purposes. but would you depend on QuickCheck outside of your test suite for that? what's the alternative? I only know of monad-bayes, but I can't say that it's as easy to use as 
16:15:17 <sshine> Test.QuickCheck.Gen.
16:16:02 <sm[m]> off topic: does anyone know a better news (NNTP) reader than Thunderbird ?
16:19:33 <sm[m]> on topic: I recently subscribed it to the haskell stack overflow feed (news.gmane.io > gwene.com.stackoverflow.feeds.tag.haskell) and wow, there's a lot more SO activity than I thought (10-20 questions/day)
16:22:32 <sshine> sm[m], I didn't know you could get StackOverflow updates via NNTP.
16:23:08 <sshine> yeah, the [haskell] tag is pretty active. I sometimes look at it because the [sml] tag is a dried up pond. :-D
16:23:17 <sm[m]> yup, gmane (gmane.io)'s "gwene" newsgroups are RSS feeds
16:23:34 <sshine> but you can't reply, can you?
16:23:50 <sm[m]> I haven't tried!
16:27:51 <Kronic> What is the recommended way to maintain an ubuntu install of haskell? I installed it simply through aptitude previously, however when installing ghcup to get hls it installed another version of ghc. I since removed the old version (Haskell-platform) but now none of my builds work in stack
16:29:08 <glguy> Kronic: generally you'd just use ghcup and not anything from aptitude
16:29:25 <glguy> stack is a separate thing that manages its own ghc
16:29:31 <Kronic> can that manage my stack install as well?
16:29:38 <glguy> no, stack's it's own world
16:29:44 <glguy> its*
16:30:21 <sshine> yeah, either install stack and let stack handle ghcs. or use ghcup :)
16:35:35 <ezzieyguywuf> hrm, after `./setup build` isn't there a way to use the setup executable to run the program?
16:35:37 <Kronic> https://dpaste.org/N4TB This is the error I am getting 
16:35:44 <ezzieyguywuf> rather than `./dist/build/mybin/mybin`?
16:35:45 <Kronic> When I attempt stack build
16:36:02 <ezzieyguywuf> I checked `./setup --help` but didn't see anything about that
16:49:37 <sm[m]> Kronic: that's normal, and it's telling you what to do
16:50:19 <sm[m]> making sense ?
16:50:33 <Kronic> I can solve it it just doesn't make sense why it needs that
16:51:40 <sm[m]> stack by default will install only packages from the resolver specified in your stack.yaml. This is for reproducability. It can install extra stuff from Hackage, but then you have to tell it which version, again for reproducibility
16:53:14 <sm[m]> with cabal (by default), you don't have to tell it that, but then cabal is free to pick any version of calamity and may not always pick the one you intended
16:53:40 <sm[m]> does that help ?
16:56:06 <Kronic> It makes sense but most other reproducible build tools I've seen solve this just through version specification
16:56:14 <Kronic> Why do I need to specify some hash-like thing?
16:57:03 <sm[m]> oh, that part is optional and I usually omit it. It was added to work around hackage's revisions, which defeated version numbering 
16:58:22 <sm[m]> so just - calamity-0.1.22.1  is what you'd usually put unless you want it really really reproducible
16:59:06 <sm[m]> or perhaps it's more than a workaround, and actually provides an additional check. We'd have to check the docs
16:59:35 <Kronic> So, I did that and it spewed out about 8 other libraries that now need to be specified there
16:59:52 <sm[m]> yup, that's normal. They too are not in your stackage resolver
17:00:24 <Kronic> It's good to hear that it's normal so now I know my environment is not broken, but I really have to say that is some really poor usability
17:00:33 <sm[m]> sometimes it means you're building an old or non-stackage-friendly project, and/or you would have an easier time with a different/older resolver
17:01:47 <sm[m]> if it's your project, it might be a sign that you've picked some old/niche libraries to depend on
17:02:06 <sm[m]> stack used to have a flag to automatically add these extra-dep lines, I think
17:02:42 <sm[m]> sometimes these things get removed for want of maintainers
17:03:55 <sm[m]> usually, you want to try and keep the extra-deps list short
17:04:46 <Kronic> I'm just using a library for discord, there's nothing in the readme about adding this to the stack.yml, similarly this stuff only started happening after I installed ghcup. I must test to see what happens if I install megaparsec
17:04:57 <Kronic> Because before I could just add that to my cabal file and it would leave me alone
17:05:49 <sm[m]> are the 8 extra deps required by calamity ? calamity depends on a lot of stuff
17:06:24 <sm[m]> megaparsec is a popular lib so it should be easier
17:09:28 * sm[m] tries stack install calamity --dry-run .. yes, it just depends on a bunch of libs not in stackage, so the extra-deps are to be expected until those get added
17:11:27 <sm[m]> re the readme.. you're right, but that is nothing new :) https://github.com/nitros12/calamity/blob/master/stack.yaml shows the extra deps
17:12:15 <Kronic> If I like the library I'm going to fix that, that was really annoying. I'm just very used to having the build tool be extremely out of my vision in other spaces is all.
17:12:34 <sm[m]> oh, you won't be having that experience with haskell (sorry :)
17:12:57 <Kronic> kind of a shame. Is Nix any different or is it equally annoying?
17:13:12 <sm[m]> but it's actually better than it sounds. GHC is also more in your face than other language's compilers, right ? But it turns out to be a good thing
17:13:31 <sm[m]> more strict error checking, more correct result
17:14:17 <Kronic> I like what I have been using with Haskell the last few days, I burned out on AOC so I wanted to try my hand at a real project. I just find the build-tool experience to be so far removed from anything I am used to
17:14:28 <sm[m]> nix adds another world of complexity, but the results are apparently very good if you pay the cost. Others here can say more about nix
17:15:17 <sm[m]> Kronic: have you read the user guide for stack or cabal yet ? It should not be avoided
17:15:54 <Kronic> I read through a decent amount of the stack one, there's just a lot of stuff to read when learning this language so I probably have a lot of gaps
17:16:01 <sm[m]> yeah
17:16:26 <sm[m]> sure, lots of the tooling UX could be nicer, it's a big wish in the community, but it's the current state of things
17:17:16 <sm[m]> I think in a little bit you'll find it pretty efficient
17:17:43 <Kronic> here's to hoping :) 
17:18:07 <sm[m]> stack build --dry-run --file-watch is good to run while you tweak your stack.yaml
17:18:22 <Kronic> what's the purpose of dry-run ?
17:18:43 <sm[m]> no real need for it, if you omit it the thing will start building when you fix the last error
17:19:02 <Kronic> I use file-watch at the moment, so I was just wondering
17:19:07 <sm[m]> I often use it to estimate how much I'll have to build to try out some project
17:19:39 <sm[m]> with --dry-run it doesn't build but does attempt to calculate the install plan
17:20:52 <Kronic> I see
17:21:18 <sm[m]> it helps me decide which resolver would minimise the building
17:21:39 <sm[m]> stuff like that
17:38:17 <sshine> In the dependencies for tasty-hedgehog-1.0.0.2: hedgehog-1.0.4 from stack configuration does not match >=1.0.2 && <1.0.4  (latest matching version is 1.0.3)
17:38:55 <sshine> but when I go to https://hackage.haskell.org/package/tasty-hedgehog it says that tasty-hedgehog-1.0.0.2 has a hedgehog >=1.0.2 && <1.0.5 constraint!
17:39:25 <sshine> I'm using stack. does it somehow not see that the Hackage constraints were bumped?
17:40:43 <sm[m]> sshine: it doesn't recheck hackage every time, stack update should fix it
17:41:33 <sm[m]> revisions were made
17:51:41 <sshine> sm[m], thanks.
17:51:44 <sshine> yeah.
17:54:20 <fuzzypixelz> can anyone please link me the paper that first introduced monads in Haskell? 
17:54:50 <sshine> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
18:41:24 <siraben> Is there a Nix overlay for GHC 8.12?
18:46:09 <koz_> siraben: I assume you mean GHC 9?
18:46:36 <siraben> Didn't 8.12 add linear types?
18:47:25 <koz_> siraben: 8.12 got renamed to 9, and isn't technically out yet.
18:47:51 <yushyin> https://gitlab.haskell.org/ghc/ghc/-/wikis/status/ghc-9.0.1 status page fyi
18:48:20 <siraben> koz_: ah, ok.
18:48:36 <siraben> Did the compilation process change? I could just override the version attribute of the Nixpkgs expression
18:48:46 <koz_> yushyin: Is it just me or is that link taking forever to load>
18:48:51 <koz_> ?*
18:48:51 <lambdabot> Maybe you meant: v @ ? .
18:49:28 <yushyin> koz_: sometimes the haskell gitlab is slow as f*ck :/
18:49:47 <koz_> yushyin: Clearly my superior luck ensured that now is one of those times.
19:04:46 <fuzzypixelz> I just spent a long time staring at ghci because I forgot to use `let` when defining my function for sperate patterns
19:05:08 <fuzzypixelz> it would yell everytime, Non-Exhaustive patterns!
19:05:16 <fuzzypixelz> oh my lorf
19:07:13 <fuzzypixelz> wait, it still doesn't work
19:07:49 <fuzzypixelz> maybe I can't do it in ghci
19:08:39 <dsal> Doing stuff in ghci can be frustrating.  Try to minimize that.  :)
19:11:37 <fuzzypixelz> dsal: the order in which I define my function for different patterns matters right?
19:12:00 <dsal> Yeah.
19:12:14 <dsal> Otherwise ambiguous matches would cause confusion.
19:12:42 <dsal> > let f _ = 0; f True = 1    in    f True
19:12:45 <lambdabot>  0
19:13:29 <sshine> siraben, btw, we've added support for expressing stakeholding in a smart contract as owning ERC1155 tokens, by implementing ERC1155 in pure EVM. :-D that was fun.
19:13:51 <siraben> sshine: wait, no language, just pure EVM? nice!
19:13:56 <dsal> I made my expression from last night's AoC Foldable, and now I don't know what that means.
19:13:57 <siraben> which assembler are you using?
19:13:57 <sshine> siraben, now, naturally, code generation has a thousand holes that cryptobugs could  crawl in.
19:14:05 <sshine> siraben, well, the compiler is still Haskell, but yeah, just opcodes.
19:14:09 <siraben> Of course
19:14:18 <siraben> Ooh, do you have a link to it?
19:14:27 <sshine> siraben, we're building weak abstractions on top, like subroutines being [Opcode] ;)
19:14:47 <sshine> we're releasing it on December 28th. my friend is kinda weird about coding in the open, I think.
19:15:37 <siraben> sshine: Ok, looking forward to it!
19:16:36 <siraben> Would be interesting if you could achieve this with a tagless final encoding as well for type safety
19:16:37 <sshine> I think writing EVM inside Haskell is a nice way to build minimal language features to realize what's truly useful. costs only as much as you're willing to invest in various language features. so what I really wanna look into is having an abstraction on top of Opcode that encodes its "stack signature".
19:16:42 <siraben> GADTs would work too I guess
19:16:49 <siraben> Right
19:16:53 <sshine> yes!
19:17:28 <siraben> And Conal's work on Compiling to Categories may be useful
19:17:48 <siraben> Yeah, Haskell as a typed metalanguage is very powerful and one doesn't need to roll their own type system
19:17:52 <sshine> so I'm basically doing some of this type-related stuff on the side. so in one repository we're just trampling forward, trying to reach "it runs on the blockchain!" and separately I'm trying to clean up and do things right.
19:18:14 <sshine> we're hardly as efficient as Victor Maia. :-D
19:18:33 <siraben> Who is Victor Maia?
19:18:37 <sshine> Formality author
19:19:16 <siraben> https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md
19:19:18 <sshine> he was in Haskell Weekly #242. but I think I mentioned him to you a while ago because he achieved beta reductions in EVM at 200 gas.
19:19:29 <siraben> oh that's cool
19:19:40 <sshine> (for comparison, safeMul is, I think, 78 gas.)
19:19:56 <siraben> "That gives us approximately 267 gas per beta-reduction, which is really low: only 33x more than a native MULMOD, and the same as one SLOAD. "
19:19:58 <sshine> (that is, a MUL that doesn't randomly overflow without warning.)
19:19:59 <siraben> https://medium.com/@maiavictor/compiling-formality-to-the-evm-99aec75677dd
19:20:02 <sshine> ah, 267.
19:20:11 <sshine> yes.
19:20:16 <siraben> still an achievement, my encoding of lambda calculus takes up much more
19:20:26 <siraben> I forget what but it's based on a combinatory logic VM
19:20:31 <sshine> you encoded lambdas in EVM?
19:20:50 <fuzzypixelz> can I format strings without using show and ++?
19:20:56 <siraben> https://gist.github.com/siraben/cbf698c0455f55d41c01c14177e8d90a
19:21:09 <fuzzypixelz> something like ${VAR} in bash?
19:21:14 <siraben> Unfortunately I think I have a subtle bug somewhere
19:21:19 <sshine> I think the efficiency was related to some research on interaction nets, so that's a little out of my reach right now.
19:21:24 <siraben> But the basic conditional compilation I tried worked
19:21:32 <sshine> fuzzypixelz, quasi quoters.
19:21:43 <sshine> fuzzypixelz, some template systems for web use this.
19:22:01 <siraben> sshine: (SII)(SII) loops as expected :D
19:22:24 <siraben> and arithmetic expressions like (+) (#3) (#6)
19:22:56 <sshine> siraben, is that EVM? :-D there's a bunch of stuff I don't recognize.
19:23:06 <siraben> Yeah EVM but in my assembler syntax
19:23:08 <sshine> fuzzypixelz, one sec.
19:23:46 <sshine> fuzzypixelz, here's an example of a typesafe template library: https://hackage.haskell.org/package/heterocephalus-1.0.5.4/docs/Text-Heterocephalus.html
19:24:05 <siraben> I have a call stack of depth 16 in EVM for addresses in up to 2^16-1
19:24:17 <siraben> Which is sufficient
19:24:27 <sshine> fuzzypixelz, I like it because you can put template variable syntax in text files, and then you can load it into a Haskell file, and then it will create errors if the right variables aren't in scope.
19:25:19 <sshine> fuzzypixelz, you could also just use strings inside the Haskell file, but I think this is a little overkill because the template system adds up to a few hundred milliseconds of compile time just for neater syntax...
19:25:29 <siraben> sshine: I gave a presentation this year on it https://github.com/ActorForth/evm-assembler/blob/master/docs/evm-assembler-talk.pdf
19:25:35 <fuzzypixelz> sshine: sorry for the confusion I'm trying to do something like "hello ${name}" where name is in the scope of my file? I think I wasn't so clear :P
19:26:40 <sshine> fuzzypixelz, tl;dr: [compileText|hello #{name}]
19:27:16 <sshine> fuzzypixelz, I think there are several other libraries that do this. this was just the one I could remember having liked. :)
19:27:37 <sshine> its main purpose is allowing you to take huge strings and put them inside text files instead.
19:27:56 <sshine> but it also has a basic string quasi quoter.
19:31:05 <sshine> fuzzypixelz, another purpose one might have is a bunch of special characters that normally need escaping. then https://hackage.haskell.org/package/raw-strings-qq is useful, e.g. [r|\n|] == "\\n". so I wonder if there's a library that specifically only does what you want.
19:32:29 <sshine> siraben, I saw your slides.
19:35:34 <siraben> sshine: nice
19:35:43 <koz_> I'm seeing this here: https://hackage.haskell.org/package/selective-0.4.1.1/docs/Control-Selective.html#t:Validation, where they claim that it's _not_ a monad. Is there some definitional reason it can't be? As far as I can tell it can, they just didn't define the instance.
19:35:49 <sshine> siraben, but re-reading them having written a bunch of EVM, I find them more informative now.
19:36:46 <siraben> I also put an example in "standard" EVM and my own syntax
19:36:50 <sshine> koz_, don't you specifically want for it to not be a Monad so that you can parallellize it?
19:37:17 <koz_> sshine: Sure, but I was checking if this is a conscious choice, rather than an inherent limitation based on its Applicative instance or something.
19:37:52 <sshine> https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf
19:38:24 <sshine> I'm pretty sure it is.
19:39:37 <sshine> yeah, they talk about speculative execution and parallelism.
19:40:22 <sshine> siraben, what's your assessment of the "one-word256-as-stack" idea?
19:40:53 <siraben> sshine: i haven't built large enough contracts yet, it's a hack and would be pretty difficult to enforce above assembly
19:41:37 <siraben> if one prohibits general recursion but allows tail recursion, I see no problem with it
19:42:01 <siraben> koz_: I though the whole idea for selective applicative functors is an abstraction between applicatives and monads
19:42:05 <koz_> sshine: Actually, upon further thought, it _can't_ be a monad. It's because ap /= <*> for it.
19:42:12 <siraben> So all monads are SAFs, but not all SAFs are monads
19:42:21 <siraben> s/though/thought
19:42:21 <jophish> Anyone here using nix on osx and would be willing to help me test something (single command)
19:42:24 <sshine> I tried writing Solidity earlier this year where I ran into the "stack too deep" problem where the compiler can't reach the full scope because DUP16 is not enough.
19:42:27 <siraben> jophish: sure
19:42:28 <jophish> nix-build https://github.com/expipiplus1/nixpkgs/archive/82196fabb65d5e3824ed57f3db78563797edff74.tar.gz -A directx-shader-compiler
19:42:40 <koz_> Since the >>= would be defined the same way as for Either, which would mean that ap would end up different to <*>.
19:42:47 <siraben> wait jk i'm on NixOS right now lol
19:42:53 <siraben> I'll reboot to try it out, why unot
19:42:58 <siraben> s/unot/not
19:43:00 <jophish> that's very kind, thank you!
19:46:14 <siraben> sshine: you had too many live variables?
19:47:08 <siraben> oh man, I could not trust Solidity to compile smart contracts 100% correctly
19:51:20 <sshine> sigh.
19:51:38 <sshine> I'm sure it has bugs, but at least it's extensively used, so they get caught approximately as frequently as they get made, I think.
19:52:12 <siraben> that's true, i've only worked with vyper and it was alright, had to fix the compiler's codegen twice though
19:52:29 <siraben> they encoded LLL as nested python lists >.<
19:52:35 <koz_> @pl \f -> fmap (f $)
19:52:35 <lambdabot> fmap
19:52:42 <koz_> Lol rly?
19:52:48 <koz_> K.
19:52:50 <siraben> koz_: checkmate
19:53:19 <sshine> I learned that 'addr(0)', which is what you write instead of simply 0 to help the linter catch if you're doing funky non-address-related stuff to an address, is not a zero-cost abstraction. it actually does 0 & 0xFFFFFF...FF.
19:53:33 <siraben> reasoning; \f → fmap (f $) = \f → fmap f = fmap
19:53:42 <sshine> you wanna make sure those 0s are properly zeroed.
19:53:56 <siraben> i wonder how hlint can integrate with pointfree
19:54:07 <siraben> sshine: wow
19:54:16 <sshine> so that the upper 96 zero bits are being zeroed for safety.
19:54:36 <sshine> while the bottom 160 zero bits can remain zeroed.
19:54:45 <siraben> solidity generated asm is quite difficult to decode, I wrote a small contract to see how they did procedure calls and wasn't very enlightened
19:54:58 <sshine> surely addr() is supposed to do this for variable input, not constant input that is obviously a valid address. :-D
19:55:00 <siraben> right, that makes sense
19:55:17 <sshine> the compiler is littered with these kinds of things because they design for usability, not efficiency.
19:55:30 <siraben> jophish: it's still compiling, 20% now
19:55:49 <sshine> ah, yeah... we kinda gave up deciphering its output, too.
19:56:49 <sshine> I think we mainly used solc's output to double-check that we understood signature hashing + the memory layout when passing arrays to external contract calls.
19:57:25 <koz_> :t (>>= (<$>))
19:57:27 <lambdabot> Functor f => (f a -> a -> b) -> f a -> f b
19:57:35 <koz_> Whoops, not quite.
19:57:48 <sshine> Ó_ò
19:58:46 <siraben> sshine: ah yes, i was pondering to write an ABI encoder
19:58:54 <siraben> Wouldn't be a bad exercise in Haskell with the appropriate ADT
19:59:01 <siraben> perhaps even Generic instance? :P
19:59:05 <sshine> siraben, this is on my list, too. :)
19:59:12 <koz_> :t (. (<$>)) . (>>=)
19:59:13 <lambdabot> Monad f => f (f a) -> (a -> b) -> f b
19:59:16 <koz_> There we go!
19:59:27 <siraben> koz_: what on earth are you trying to do
19:59:40 <siraben> :t (>>=) . (>>= (<$>))
19:59:40 <koz_> siraben: Checking whether I understand how ap is defined in terms of bind properly.
19:59:42 <lambdabot> Functor f => (f a -> a -> b1) -> (f b1 -> f a -> b2) -> f a -> b2
20:00:05 <siraben> i wonder how much of a magma I can get by composing bind, fmap, and ap
20:00:12 <siraben> as in, will any combination typecheck
20:00:33 <sshine> siraben, it is on my to-do list to rip off https://github.com/dapphub/dapptools/blob/master/src/hevm/src/EVM/ABI.hs and export it to a stand-alone library.
20:00:57 <siraben> sshine: that would be great
20:01:06 <siraben> more Haskell tooling for EVM!
20:02:14 <siraben> Especially if certain things like language design are to be made more accessible, we ought to utilize the ecosystem's libraries (recursion-schemes, bound, fresh monads, etc.)
20:02:30 <sshine> I'd like an opcode representation that lets me say [MUL] :: Stack 2 1
20:03:01 <siraben> Why not, `MUL :: Stack (Int:-Int:-a) (Int:-a)`?
20:03:02 <sshine> I don't know if this is one of things that are really un-ergonomic and I haven't learned yet... I've tried a few techniques that I regretted and reverted.
20:03:24 <sshine> siraben, definitely possible.
20:03:33 <siraben> i have a tagless final encoding somewhere on my drive
20:05:56 <fuzzypixelz> % data SomeData = Either Int String
20:05:57 <yahb> fuzzypixelz: 
20:06:22 <siraben> sshine: https://gist.github.com/siraben/03510d1bf4d73b6958655887bee69bfe
20:06:25 <sshine> fuzzypixelz, don't you mean 'type'?
20:06:54 <fuzzypixelz> yes, sorry
20:07:02 <jophish> siraben: thanks, I think it's basically llvm so might take a short while
20:07:06 <fuzzypixelz> % type SomeData = Either Int String
20:07:06 <yahb> fuzzypixelz: 
20:07:24 <fuzzypixelz> % type SomeOtherData = Either Int String
20:07:25 <yahb> fuzzypixelz: 
20:07:45 <siraben> jophish: haha, if I'm not able to finish I think SuperSandro2000 on the NixOS channel would be happy to build
20:07:46 <fuzzypixelz> my problem is, how would I distinguish Left's from either type
20:07:51 <siraben> they have a macOS machine
20:08:03 <siraben> fuzzypixelz: pattern matching, or isLeft
20:08:04 <fuzzypixelz> % isLeft (Left 0)
20:08:04 <yahb> fuzzypixelz: True
20:08:41 <sshine> siraben, now we just need to magically be able to transfer the compute you already did to their machine.
20:08:45 <fuzzypixelz> siraben: but it doesn't tell me if it's a SomeData Left, or SomeOtherData Left
20:09:05 <sshine> fuzzypixelz, they're just aliases.
20:09:25 <sshine> fuzzypixelz, there is no difference between type aliases.
20:09:41 <fuzzypixelz> sshine: what if I use newtype?
20:09:41 <sshine> fuzzypixelz, if you feel the need to differentiate, you use 'newtype'. then they can't be used in place of one another.
20:10:09 <sshine> % newtype Foo = Foo (Either Int String)
20:10:09 <yahb> sshine: 
20:10:42 <fuzzypixelz> % newtype Bar = Bar (Either Int String)
20:10:42 <yahb> fuzzypixelz: 
20:10:48 <fuzzypixelz> % newtype Foo = Foo (Either Int String)
20:10:48 <sshine> % (Foo (Left 42) :: Foo) == (Left 42 :: SomeData)
20:10:49 <yahb> fuzzypixelz: 
20:10:49 <yahb> sshine: ; <interactive>:18:28: error:; * Couldn't match type `Either Int String' with `Foo'; Expected type: Foo; Actual type: SomeData; * In the second argument of `(==)', namely `(Left 42 :: SomeData)'; In the expression: (Foo (Left 42) :: Foo) == (Left 42 :: SomeData); In an equation for `it': it = (Foo (Left 42) :: Foo) == (Left 42 :: SomeData)
20:11:02 <sshine> % (Foo (Left 42) :: Foo) == (Bar (Left 42) :: Bar)
20:11:03 <yahb> sshine: ; <interactive>:19:28: error:; * Couldn't match expected type `Foo' with actual type `Bar'; * In the second argument of `(==)', namely `(Bar (Left 42) :: Bar)'; In the expression: (Foo (Left 42) :: Foo) == (Bar (Left 42) :: Bar); In an equation for `it': it = (Foo (Left 42) :: Foo) == (Bar (Left 42) :: Bar)
20:11:03 <siraben> fuzzypixelz: importantly, newtypes don't introduce overhead at runtime as well
20:11:38 <sshine> fuzzypixelz, yeah, the 'Foo' and 'Bar' that go in front of 'Left 42' only cost your sweat, they get removed during compilation.
20:12:23 <sshine> this is the kind of masochism Haskellers like. making it impossible to compare two otherwise perfectly similar values.
20:13:43 <sshine> siraben, thanks for your example!
20:14:34 <sshine> siraben, what I'm looking for is a way to ensure that EVM subroutines expressed using ADTs in Haskell are consistent about their use of EVM's stack. this encoding provides some safety. but there's still jumps.
20:14:41 <siraben> sshine: ooh I also exploited tagless final to make an assembler for FRACTRAN, the programming language that only uses fractions https://siraben.github.io/2020/02/26/translating_cl.html
20:14:49 <siraben> Yes, there's still jumps, which is the main issue
20:14:59 <siraben> I think you could encode control combinators though
20:15:07 <sshine> I was dreaming about dependent types last night because of this.
20:16:19 <sshine> hmmm, maybe. but I don't like to invent control structures for the many kinds of loops I'm making. e.g. I made one loop that did 'for (i = 0; i < N; i++) { M[a+i] = x; M[b+i] = y; M[c+i] = z; }'
20:16:43 <sshine> maybe I should really be doing something like a memoryZip3 :-D
20:17:15 <siraben> I think the bound library had an example of a language with jumps
20:17:45 <sshine> what I'm thinking is actually just to write some test automation that does call-graph analysis and makes sure that the stack looks the same in both jump branches... and work with that as a limitation in my labelled jumps.
20:17:51 <sshine> oh
20:18:28 <fuzzypixelz> https://www.youtube.com/watch?v=RqvCNb7fKsg
20:18:33 <fuzzypixelz> ^ best video ever
20:18:54 <sshine> fuzzypixelz, yes. pity he stopped making videos.
20:18:55 <fuzzypixelz> typical Haskeller 
20:19:00 <siraben> sshine: sorry for link spam heh, I've also been thinking/collecting resources for this for some time
20:19:05 <siraben> see http://wall.org/~lewis/2013/10/15/asm-monad.html and https://www.stephendiehl.com/posts/monads_machine_code.html
20:19:05 <fuzzypixelz> sshine: he only made one!
20:19:21 <siraben> they have labelled jumps
20:20:05 <sshine> fuzzypixelz, he also made a bunch of other videos among which this one is the most impressive: https://www.youtube.com/watch?v=cs9aUt4x-CI
20:21:37 <sshine> siraben, haha, they're all very appreciated, since I'm kinda stuck on which direction to go.
20:23:19 <siraben> sshine: I haven't been working on crypto stuff in recent months but bootstrapping a dialect of Haskell from a 357 byte binary instead
20:23:38 <siraben> I looked into bootstrapping GHC but unfortunately it's very large without a clear path since it's done rarely
20:23:48 <sshine> siraben, cool. I restarted doing crypto this december. had to take a break after quitting my blockchain job.
20:24:30 <sshine> firing management and bringing it back to being a hobby project has made it more fun. ;)
20:24:42 <siraben> Yeah!
20:25:42 <sshine> siraben, what's very large?
20:27:58 <siraben> sshine: GHC itself
20:28:48 <tzlil> is there a smallest haskell compiler? ghc is massive
20:28:54 <tzlil> smaller*
20:29:08 <sshine> tzlil, there are other Haskell compilers, yes.
20:29:53 <sshine> tzlil, do you mean something that is Haskell98 or Haskell2010-compliant?
20:30:15 <tzlil> i dont know the difference
20:30:39 <sshine> tzlil, I don't mean to say that it matters which one of those it is, but just that it's "Haskell as it was written in some specification"
20:30:46 <sshine> https://github.com/Lemmih/lhc
20:32:08 <sshine> https://github.com/UU-ComputerScience/uhc
20:32:49 <sshine> I don't think they aim to be minimalist, but simply spec-compliant, even though they're probably smaller.
20:32:57 <sshine> also, they're all seemingly stale projects.
20:33:14 <siraben> https://github.com/oriansj/blynn-compiler
20:33:18 <siraben> this one isn't!
20:33:26 <sshine> cool!
20:34:02 <siraben> runs even better than miranda
20:34:36 <siraben> The author is very descriptive and thorough: https://crypto.stanford.edu/~blynn/compiler/
20:34:50 <siraben> s/better/faster
20:38:41 <siraben> iophish: build finished with log http://ix.io/2IDN
20:39:27 <siraben> but fails to run dyld: Library not loaded: @rpath/libdxcompiler.3.7.dylib
20:43:24 <sshine> siraben, I'm convinced now that writing assembler in do-blocks is awesome.
20:44:31 <siraben> sshine: nice, what convinced you?
20:45:41 <sshine> siraben, the syntactic simplicity. the 'label <- here' is pretty cool, too.
20:46:15 <sshine> we've had some pretty unserious bugs caused by copy-pasting strings around. it will be good to have this type of labelling instead.
20:48:13 <siraben> sshine: indeed
20:49:35 <sshine> siraben, when you say tagless final and opcodes, do you mean something like the Stack (Int :- Int :- a) encoding?
20:50:49 <sshine> siraben, never mind, I get it. :)
20:50:58 <siraben> sshine: yes, but let Stack is polymorphic higher kinded
20:51:05 <siraben> be*
21:04:00 <tzlil> how can i do a wildcard for lists with a single element?
21:06:37 <sshine> tzlil, foo (x : _) = ...?
21:06:54 <sshine> tzlil, sorry, foo [_] = ...?
21:07:11 <sshine> tzlil, what's the goal?
21:07:22 <tzlil> trying to replicate isAsc
21:07:39 <tzlil> which i just finished doing
21:09:29 <sshine> tzlil, what does isAsc do?
21:09:43 <sshine> is that isAscii or isAscending or isAscetic? :-P
21:11:14 <tzlil> isAscending
21:11:27 <tzlil> http://0x0.st/iCzT.txt
21:11:31 <tzlil> heres my code if you are interested
21:12:10 <sshine> I'd splurge and spend the extra bucks on 'ending'.
21:12:55 <sshine> tzlil, nice. can you do this with pattern matching two elements deep instead? then you avoid 'head' which is a partial function.
21:13:27 <sshine> isAscending (x : y : xs) = ...
21:13:41 <tzlil> ah, i didnt know you could do that
21:18:25 <tzlil> what are partial functions sshine ?
21:18:33 <sshine> > head []
21:18:35 <lambdabot>  *Exception: Prelude.head: empty list
21:18:52 <sshine> functions that throw up or continue forever.
21:19:27 <tzlil> uhuh
21:20:47 <sshine> you can often avoid them and find something altogether better instead.
21:27:48 <gentauro> I don't know why `head` and `tail` exists when the correct way to handle list is with pattern matching (`x:xs`)
21:29:23 <dolio> Because sometimes they're handy.
21:38:12 <EvanR> sometimes theyre even correct. i.e. when the list is not empty
21:38:44 <EvanR> in which case there may not be a sane thing to do with pattern matching
21:43:24 <ADG1089> Hi do you know guys why would hls be stuck at "Applying hint"?
22:00:06 <gentauro> I would understand if they were part of the NonEmpty list module
22:00:16 <gentauro> cos you know you will always have a non-empty list
22:00:27 <gentauro> but for list? Nah, just do pattern-matching
22:07:51 <sshine> gentauro, pattern matching marries you to the AST.
22:09:01 <jophish> siraben: did dxc finish compiling btw?
22:09:13 <jophish> If it failed, then it would have been right at the end lol
22:09:22 <siraben> jophish: yeah i posted the build log above
22:09:24 <siraben> check haskell logs
22:09:29 <siraben> also it fails at runtime
22:09:34 <sshine> 05:38:19 <siraben> iophish: build finished with log http://ix.io/2IDN
22:09:43 <siraben> thanks sshine
22:09:58 <jophish> Ah thanks
22:10:12 <siraben> jophish: just curl that URL and pipe into less to see with colors
22:10:24 <jophish> annoying that it fails to run
22:10:38 <sshine> siraben, it was very helpful to converse with you earlier. I have a much better idea about where to go.
22:11:09 <jophish> ah, it's because osx does libname.version.dylib
22:11:16 <jophish> and linux does libname.so.version
22:11:22 <sshine> siraben, another thing I want to do is be able to say how much something costs (approximately when necessary) without simulating.
22:12:01 <siraben> sshine: no problem, I enjoyed the discussion.
22:16:26 <jophish> siraben: I've pushed a fix, so nix-build https://github.com/expipiplus1/nixpkgs/archive/a9ec238f685c4c0e36c45b0f79da5836d8c2e799.tar.gz -A directx-shader-compiler please please feel free to decide you're not my build farm and I'll understand :D
22:17:22 <siraben> jophish: I'm on the go right now so I won't be able to, let me know if you still need it later
22:17:34 <siraben> no worries :)
22:18:00 <jophish> sure thing. I think what I'll do is limit the PR to Linux only and make another one adding darwin support, pending someone testing
22:18:07 <siraben> sshine: sounds like a good candidate for abstract interpretation
22:19:51 <sshine> siraben, for example, an 'SSTORE' operation either costs one thing or one other thing, depending on whether the storage address is set to/from zero/non-zero, and in some cases it gives you a refund, but you only get that after the code has executed. it is completely non-trivial to know what one chunk of EVM code does without knowing the complete state of the blockchain. :-D
22:20:17 <siraben> So at least you can have an upper bound, right?
22:20:17 <sshine> s/does/costs/
22:20:58 <siraben> Assume the contract does not revert and always takes the "most expensive" path
22:21:54 <sshine> yeah so in a lot of cases, if you build some control structure on top, you'd be able to say exactly what something costs. and in some cases, e.g. when external contract calls have variable-length input, you can only really spit out an equation and a suggested upper bound.
22:22:48 <sshine> sorry. and in a lot of cases you can only say something about a bound. but that's still fine, since I want to calculate the upper bound for minimizing how much I have to feed a call.
22:23:08 <siraben> Right
22:23:15 <sshine> right now our unit tests just call with 3 million gas every time.
22:23:26 <siraben> Yoikes, a lot of gas
22:23:52 <sshine> no thought was put into cost calculation.
22:23:55 <siraben> On regtest not a problem but on the mainnet yes
22:23:59 <sshine> haha yes.
22:24:35 <siraben> I'm not sure how doing this in Haskell would work? Supposedly just folding over the ADT
22:24:59 <siraben> or the dual equivalent in the tagless final encoding
22:25:49 <sshine> yes.
22:26:25 <sshine> preferrably a high-level ADT and not [Opcode] ;-) since that leaves for a whole lot of uncertainty.
22:26:34 <siraben> right
22:43:57 <jle`> can anyone see why my nested sepBy doesn't parse? :|  for "1 2 3 | 9 2" i'd want to get [[1,2,3],[9,2]], but (decimal `sepBy` " ") `sepBy` " | " seems to error at the |
22:45:57 <MarcelineVQ> is it the spaces around | ?
22:46:20 <MarcelineVQ> like, maybe the first is eating all of "1 2 3 "
22:46:49 <MarcelineVQ> *around " | "
22:47:05 <jle`> hm, should i make it try " | " ?
22:47:16 <sshine> jle`, no
22:47:30 <iqubic> jle`:  sepBy doesn't do any backtracking. So if the sepBy matches the space after the number, but not another number, it will fail.
22:48:00 <iqubic> I think. I'm not sure if that's actually true.
22:48:13 <sshine> jle`, you want to make 'decimal' eat whitespace after it, and you want something like 'symbol "|"' to assume that there's no whitespace before it and eat the whitespace after it.
22:49:00 <iqubic> I solve this by just using: `many (number <* optional " ") `sepBy` "| "`
22:49:27 <sshine> e.g. many (lexeme decimal) `sepBy` symbol "|"
22:50:02 <jle`> sshine: doesn't quite work for me i think i'd like it to stop eating after a \n
22:50:16 <jle`> so "1 2 3 | 9 2\n5 2 | 3 1 2 | 3\n" i think
22:50:22 <jle`> ah, maybe i can just have it eat sapce space
22:50:22 <sshine> jle`, you could adjust your whitespace eater for that.
22:50:25 <jle`> :O
22:50:46 <jle`> ◕‿◕ 
22:51:23 <iqubic> jle`: My thing stops at a \n
22:53:50 <jle`> thanks all :)
22:53:53 <sshine> jle`, Parsec's .Token / Megaparsec's .Lexer have some over-engineered machinery for dealing with the many kinds of whitepsace. I normally go with a poor-man's version: lexeme = (<* space), symbol = lexeme . void . string
22:57:40 <sshine> https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec-Char-Lexer.html#g:1
23:04:55 <siraben> jle`: are you generalizing to n arms?
23:05:10 <jle`> heh, not quite
23:05:24 <iqubic> What's an arm here?
23:07:21 <sshine> sounds christmas-related.
23:07:25 <siraben> iqubic: a list of numbers
23:07:51 <siraben> data RuleD = Seq [Int] | Alt [Int] [Int] | Lit String
23:08:16 <siraben> in general one could have Alt [[Int]] I suppose
23:37:56 <int-e> siraben: that looks vaguely familiar
23:39:42 * int-e once again abused `words` for parsing though
23:40:57 <xerox_> :)
23:41:11 <xerox_> words . map replaceOffendingChars -- is an AoC tradition
