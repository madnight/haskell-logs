00:12:05 <koz_> gedda: Yeah, there's a lot of Haskell in finance stuff.
00:12:20 <koz_> However, there's a range - there's some folks in the Netherlands doing _hardware design_ in Haskell.
00:12:32 <koz_> (I even applied for them, but I got bounced cause I didn't wanna relocate)
00:17:27 <maerwald> oh no, snoyman just wrote a blog post about transformers in rust? It's not like I was missing them there...
00:18:08 <koz_> maerwald: Yeah, while saying 'it's not like I actually _like_ transformers, baka!'.
00:18:16 <koz_> (because Snoyman will Snoyman in _any_ language)
00:24:21 <maerwald> I'll have to go back to Go, because it's unlikely that crap will make it into the language :p
00:24:48 <maerwald> (but then the language is crap...)
00:25:30 <koz_> maerwald: Lol.
01:02:27 <boxscape> is there a type that you can use to derive an Applicative instance if you have a Monad instance like `data MyFunctor = ... deriving Applicative via (DefaultApplicative MyFunctor)`?
01:06:36 <lortabac> boxscape: Control.Applicative.WrappedMonad
01:06:42 <boxscape> ah, thank you
01:08:06 <hyiltiz> I found a few days ago that Python is learning more (pattern matching and guards) from haskell except its list comprehension https://www.python.org/dev/peps/pep-0622/#exhaustiveness-checks though some folks doesn't seem to appreciate it https://news.ycombinator.com/item?id=23713795
01:09:01 <hyiltiz> Let's see if a case-of expression comes back after all these years https://www.python.org/dev/peps/pep-3103/
01:11:51 <boxscape> java is going a similar route
01:12:10 <boxscape> https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html
01:16:16 <maerwald> yeah, sum types are arguably the most valuable thing in haskell, the rest is just sweet options
01:16:25 <hyiltiz> i thought i was reading nerd docs, not fasion mag :p
01:17:02 <boxscape> At least you've been able to use Church/Scott encodings in the other languages for quite a while :)
01:17:04 <hyiltiz> does java python or ruby has sum types (bolted on, that is)
02:08:20 <boxscape> hm seems strange that Data.Lens has |> and a pattern synonym for Empty like Seq but no pattern synonym for :|>
02:09:28 <boxscape> er, Control.Lens rather
02:17:07 <maerwald> hyiltiz: not really
02:17:10 <maerwald> but there's https://coconut.readthedocs.io/en/master/DOCS.html#match
03:43:22 <the-smug-one> Do you guys think it would be nice to have a journal which finds and summarizes current papers?
03:43:34 <the-smug-one> Also does that exist?
03:48:33 <maerwald> merijn: defining vim plugins in yaml, just what you wanted: https://github.com/itchyny/miv (and written in haskell)
03:48:51 <merijn> maerwald: Why you gotta ruin my day like that
03:48:55 <maerwald> lol
03:59:21 <merijn> maerwald: If it's any consolation, I'm not just a ghcup luddite, I'm also still using pathogen :p
04:03:00 <aplainzetakind> https://hackage.haskell.org/package/bench produces significantly smaller times than the `time` command. What's the overhead with `time`?
04:03:29 <aplainzetakind> Like I'm getting 0.05s with time and 0.02 with bench.
04:04:31 <merijn> "time" does a single run, which is noisey, bench uses criterion which repeats experiments and does statistical analysis to eliminate measurement noise from the equation
04:04:50 <ph88> does anyone know the reason behind the historical decision to make a char in single quotes and string in double quotes ? why not type infer a string with only 1 char to be of type char ?
04:05:25 <boxscape> how would you write a string literal of length 1 if that were the case?
04:05:42 <aplainzetakind> merijn: So it's not cheating to go by the bench number I suppose.
04:06:02 <merijn> ph88: Because many languages prior to Python had that distinction
04:06:17 <merijn> ph88: C, C++, Java (iirc?) all distinguish characters and strings
04:06:39 <merijn> The lack of specific character type and allowing both types of quotes is a fairly new thing
04:06:41 <boxscape> yeah Java works like C in that regard
04:06:44 <ph88> boxscape, the same but it would be infered to be a string depending on how you would use it
04:07:04 <merijn> ph88: Your question is inverted, and thus unanswerable
04:07:05 <yushyin> aplainzetakind: you could also compare it to perf stat -r 1000 $cmd
04:07:13 <boxscape> So like `'c' :: FromChar a => a`
04:07:19 <ph88> merijn, do you have an advice which style to use for a new language ?
04:07:27 <merijn> ph88: There was no "historical decision" to do that. It just copied what literally every other language at the time did
04:07:50 <merijn> Having separate syntax for characters and strings is the right way, imo
04:07:57 <ph88> why ?
04:08:16 <boxscape> what do you gain by having a single syntax for both?
04:08:46 <ph88> that single quotes can be used for strings
04:09:00 <merijn> And that's useful because?
04:09:16 <ph88> people are used to that from other languages
04:09:18 <merijn> What does it let you write that you couldn't write before?
04:09:43 <ph88> it's not about ability, rather about style and familiarity
04:09:46 <merijn> Well, if you wanna be the same as other languages because people are used to them, why bother making a new one at all? :p
04:10:13 <merijn> ph88: As I said, C, C++, and Java, (possibly C# and F# too?) all use the same distinction
04:10:26 <ph88> we need a language for a specific domain and strings is one of the first things we need
04:10:28 <merijn> I forget what Ocaml does, but I think it does the same
04:11:14 <boxscape> to me it seems a bit weird to have two almost identical ways to write the same literal
04:11:18 <ph88> i'm considering just not having a char type and allow single quotes for strings
04:11:32 <boxscape> though arguably the same could be said about 5.0 and 5.00
04:11:38 <ph88> :P
04:12:22 <ph88> in php you also have something funny where ' '  is a string literal, and "  "  is a string which is interpolated first with variables you drop in there
04:12:31 <ph88> not that i plan on doing that :P
04:13:20 <[exa]> ph88: you can have an instance for IsString Char
04:13:51 <lortabac> instead of a redundant syntax for strings, I would rather use single quotes for identifiers composed of arbitrary characters, as in Prolog
04:13:59 <[exa]> (related: scheme character literals)
04:14:14 <lortabac> so you can have for ex. uppercase record fields
04:14:49 <[exa]> lortabac: that might easily turn to lowercase and uppercase '
04:15:39 <lortabac> [exa]: sorry I don't understand
04:18:25 <[exa]> lortabac: like, if you have uppercase record fields in 'Field', what if I wanted a typename called 'typename' ?
04:18:53 <lortabac> you can't
04:19:31 <lortabac> in Prolog, single-quoted identifiers are equivalent to lowercase ones without quotes
04:20:53 <[exa]> yeah well, people will start solving the "you can't" :]
04:21:41 <lortabac> there is nothing to solve, 'Foo' belongs to the same namespace as foo
04:21:59 <lortabac> Foo belongs to the uppercase namespace
04:23:05 <lortabac> unless by "solving" you mean proposing new extensions
04:23:10 <[exa]> yeah
04:23:23 <lortabac> oh I see :)
04:31:09 <Martinsos> ph88, merijn: Javascript might be a good example of what ph88 is talking about. I wouldn't be so bold to say there is a right way, since both approaches are obviously in use. It makes sense to have separate char and string in languages that are lower level, where that distinction is important. I also personally like having that distinction, since then we can reason about String as an array of Chars, and we can use array methods on it,
04:31:09 <Martinsos> but on the other hands, I never had any problems with strings in JS or felt that something is missing. Personally, I would probably go with just string, if language is not much about string manipulation on the low level. If it is, I would consider introducing character. Maybe the easiest way is to start with just string and see how that goes. At least you are keeping things simpler for the user of the language if you have just string
04:31:09 <Martinsos> and not string and char. However, I wouldn't allow usage of both single quote and double quote, I feel it just causes confusion and differences in style. If I am coming from Java to your language, I might think that 'a' is different type than "a", while it is not. I would use just double quotes, since those are standard way to describe string literal. That also leave space for introducing character down the line if you figure out you
04:31:09 <Martinsos> need it.
04:33:33 <maerwald> but then you gotta answer the question what a char is :p
04:34:00 <merijn> maerwald: How hard could that be? :D
04:34:05 <maerwald> haha...
04:35:09 <boxscape> if you've figured out what strings are and have a substring function you're probably most of the way there, no?
04:35:27 <merijn> boxscape: lol
04:35:43 <boxscape> it just seems like figuring out what strings are is just as difficuly
04:35:46 <boxscape> s/y/t
04:35:47 <merijn> You could spend a decade and not figure out how to properly define "substring"
04:35:57 <boxscape> right I suppose that's fair
04:36:15 <merijn> boxscape: Figuring out strings is easy "unknown unicode blob that I'm *definitely* not going to touch"
04:36:27 <maerwald> there are 3 popular choices already: 1. word8, 2. unicode char point, 3. grapheme
04:53:36 <boxscape> I like Word7, to be fully ASCII-compliant
04:53:54 <merijn> UTF-7 :p
04:54:20 <boxscape> that sounds terrible
04:54:27 <merijn> It exists :p
04:55:38 <tomsmeding> TIL about UTF-7 and I already hate it
04:55:51 <tomsmeding> is that +base64- encoding really the best they could come up with
04:56:09 <merijn> Ok, given a '[Foo]' and 'Foo -> Either Bar Quux' what's the most convenient way to stop at the first Right?
04:57:10 <tomsmeding> :t msum
04:57:12 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
04:57:28 <tomsmeding> well, msum . map f
04:57:48 <xerox_> or asum
04:57:50 <merijn> Well, no
04:58:03 <merijn> Because Either isn't an instance of Alternative (and thus not MonadPlus)
04:58:07 <merijn> Else I wouldn't be asking :p
04:58:24 <xerox_> how sad
04:58:49 <tomsmeding> my technique of always testing this stuff with Maybe has failed me here
04:58:58 <tomsmeding> what do you want on [] though
04:59:23 <tomsmeding> or all-Left
04:59:34 <tomsmeding> which is of course the reason it's not Alternative :p
05:00:26 <xerox_> :t rights
05:00:30 <lambdabot> [Either a b] -> [b]
05:00:34 <xerox_> I guess?
05:00:34 <merijn> Guess I'll just turn Either into Maybe
05:00:40 <merijn> xerox_: Doesn't stop at first Right
05:00:48 <tomsmeding> safeHead . rights
05:00:50 <merijn> xerox_: Still evaluates the whole list
05:00:57 <xerox_> :t listToMaybe . rights
05:00:58 <lambdabot> [Either a1 a2] -> Maybe a2
05:01:12 <merijn> Ah, that might work
05:01:41 <xerox_> \o/
05:02:03 <scasc> Re UTF-7: that has an absolute valid rationale: "It was originally intended to provide a means of encoding Unicode text for use in Internet E-mail messages that was more efficient than the combination of UTF-8 with quoted-printable."
05:02:07 <scasc> Nothing to hate here
05:02:59 <scasc> Of course, it has no practical place in Unicode compliance ever since we have transgressed the range of the BMP.
05:03:04 <tomsmeding> fair, though I imagine it could have been even more efficient
05:05:36 <scasc> However, UTF-7 was introduced 1997, and the BMP was first transgressed, I think, in 2003 with Unicode 4.0
05:06:39 <tom__> Should you generally strive to avoid partial functions in Haskell? Does this apply to other languages too?
05:07:36 <scasc> (Ah, no, Old Italic was already added in Unicode 3.1, 2001). Still, I think Old Italic or Linear B had little practical relevance in 7-bit transported e-mail even in 2003 :-)
05:09:31 <merijn> tom__: Yes and yes :p
05:10:17 <hpc> such as it's even possible, in some languages
05:10:35 <tom__> I was explaining this to someone and they said oh well the tests will fail and we will know if its a problem
05:10:45 <tom__> So I second guessed myself 
05:10:45 <wz1000> how do I get a callstack for "No match in record selector"
05:10:59 <merijn> wz1000: Profiling and +RTS -xc ?
05:11:01 <tom__> Whats that quote testing shows the presence not absence of bugs
05:11:48 <hpc> i prefer the one about obviously not wrong vs not obviously wrong
05:12:03 <tom__> haha great
05:15:33 <scasc> tomsmeding: but I will concede, that an encoding scheme which would have preserved (encoded directly) the range 32-126  (similarly how UTF-8 encodes 0-127 directly) and used only the byte values 0-31 and 127 for the encoding of higher code points would seem nicer. And they did have UTF-8 as prior art, which stems from 1992. So I'll give you that
05:18:33 <scasc> I stand corrected, while it was around since 1992 in proprietary systems, UTF-8's RFC is from 1998, that's one year after UTF-7, so no prior art here.
05:25:26 <tomsmeding> tom__: Dijkstra, supposedly https://www.goodreads.com/quotes/506689-program-testing-can-be-used-to-show-the-presence-of
05:25:58 <scasc> {- ok, it's a mess, UTF-8 appeared already in 1996 in the appendix of Unicode 2.0 -}
05:26:17 <tomsmeding> it's all a mess anyway
05:28:45 <tom__> tommeding: Ah cheers
05:29:10 <tom__> Formally verifying software shows an absence of bugs right provided the proof is correct.
05:29:25 <tomsmeding> and provided you're proving what you think you're proving
05:29:46 <tomsmeding> you might be proving correctness assuming the user doesn't pull the power cord
05:29:54 <tomsmeding> ... until they actually do
05:30:03 <boxscape> Or a cosmic ray hits your RAM cell
05:31:11 <tomsmeding> also often people prove correctness of a _model_ of the program, not of the program itself; that introduces even more points where you're not proving what you're testing
05:31:26 <tom__> Ah yes
06:31:19 <[exa]> hm, what's the correct alternative for `cabal haddock --hyperlink-source` now?
06:31:42 <merijn> [exa]: For Hackage? or?
06:35:13 <AWizzArd> Anyone here who tried the IHP web framework, editing code with support of HLS?
06:36:12 <[exa]> merijn: well for anything.. I'm getting errors unless I use `cabal v1-haddock --hyperlink-source`..
06:37:42 <[exa]> uh noes, it's --haddock-hyperlink-source
06:37:59 <[exa]> apologies for rubberducking. :]
06:38:13 <merijn> [exa]: I was about to say that it's a haddock option you're using, not cabal ;) And for Hackage you probably want --haddock-for-hackage
06:38:29 <merijn> You can also set "hyperlink: True" in the haddock section of ~/.cabal/config
06:52:14 <tomsmeding> not hyperlink-source ?
06:57:01 <merijn> oh, yeah, maybe
06:57:10 <merijn> Checking things is for losers :p
07:00:11 <tomsmeding> (That's what my config file contains, commented-out, at least)
07:00:29 <aplainzetakind> If I write something like `let f i = xs !! i; go k l = somethingInvolvingLookinUpInxsViaf in go 0 0`, the list lookups are memoized right?
07:00:58 <tomsmeding> no you have to explicitly make a shared Data.Map or array or something
07:01:14 <tomsmeding> values are memoised, function invocations aren't
07:03:22 <aplainzetakind> How about functions-as-values? i.e., let f = (xs !!) in ...
07:06:01 <aplainzetakind> OK, I'm reading the answer here (unless it's obsolete somehow) https://stackoverflow.com/questions/11466284/how-is-this-fibonacci-function-memoized
07:44:26 <AWizzArd> I am looking at a code example from the IHP web framework:  buildPost post = post |> fill @["title","body"]
07:44:39 <AWizzArd> What is that @ doing there?
07:45:06 <AWizzArd> On the left-hand side it can be used for pattern matching. But in front of a list?
07:48:17 <merijn> > let x @ y = x + y in 2 @ 3 -- ?
07:48:20 <lambdabot>  <hint>:1:24: error: <hint>:1:24: error: parse error on input ‘@’
07:48:28 <merijn> hmm, that's not allowed?
07:48:35 <merijn> No clue, then :p
07:50:54 <lortabac> TypeApplications?
07:51:10 <merijn> oh, maybe
07:51:21 <lortabac> I have no idea, I'm just guessing
07:53:50 <AWizzArd> The extensions that are activated by default are: OverloadedStrings, NoImplicitPrelude, ImplicitParams, Rank2Types, NamedFieldPuns, TypeSynonymInstances, FlexibleInstances, DisambiguateRecordFields, DuplicateRecordFields, OverloadedLabels, FlexibleContexts, DataKinds
07:54:02 <AWizzArd> Could one of those have introduced the @ syntax?
07:56:58 <tomsmeding> aplainzetakind: that answer seems to be a nice explanation
07:57:15 <tomsmeding> the compiler doesn't memoise, it lazily evaluates global constants
07:57:30 <solonarv> AWizzArd: this is a type application
07:57:40 <tomsmeding> and local constants that don't depend on anything local can get lifted to global constants, which results in something that looks like memoisation
07:58:52 <tomsmeding> AWizzArd: TypeApplications is not in there, but the thing you posted looks very much like type applications
07:59:04 <tomsmeding> where the type in this case is a DataKinds lifted type ["title","body"]
08:00:01 <tomsmeding> (well, "lifted type" is inaccurate terminology; it's a value lifted _to_ a type)
08:02:23 <AWizzArd> Okay, so that `fill` is a method and via @ we can tell GHC which instance we want to call here.
08:05:50 <tomsmeding> well, it's a value, not necessarily a method
08:06:02 <dminuoso> AWizzArd: Without seing the code, Im guessing you're supplying a type level list with type level symbols
08:06:08 <dminuoso> So I suspect this means
08:06:15 <tomsmeding> % mempty @String
08:06:16 <yahb> tomsmeding: ""
08:07:18 <dminuoso> % fill :: forall (s :: [Symbol]). Int; fill = undefined
08:07:18 <yahb> dminuoso: 
08:07:32 <dminuoso> % fill @["foo", "bar"]
08:07:32 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:145:45 in interactive:Ghci76
08:07:37 <dminuoso> So we could do something like
08:08:08 <dminuoso> oh well, you get the idea. You can use GHC.TypeLits and type families to work on the list, and eventually pull the symbols back into value world
08:08:19 <dminuoso> (or alternatively MPTC+fundeps instead of tyfams)
08:10:08 <dminuoso> % type family TyLen (s :: [a]) where TyLen (x ': xs) = 1 + TyLen xs; TyLen '[] = 0
08:10:09 <yahb> dminuoso: 
08:10:50 <dminuoso> % :set -XScopedTypeVariables
08:10:51 <yahb> dminuoso: 
08:11:06 <srk> > (pure Nothing) <|> (pure $ Just "fine")
08:11:09 <lambdabot>  error:
08:11:09 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M201537395400...
08:11:09 <lambdabot>        prevents the constraint ‘(Show
08:11:31 <srk>  /o\ is there something like asum for [IO (Maybe a)]?
08:11:47 <dminuoso> srk: asum with MaybeT?
08:11:58 <merijn> srk: "asum . map MaybeT"? :p
08:12:13 <srk> thanks :)
08:17:06 <dminuoso> % fill :: Proxy '[Symbol] -> Integer; fill (Proxy :: Proxy l) = natVal (Proxy @(TyLen l))
08:17:06 <yahb> dminuoso: 
08:17:21 <dminuoso> % fill (Proxy @["foo", "bar"]) -- AWizzArd 
08:17:21 <yahb> dminuoso: ; <interactive>:170:7: error:; * Couldn't match type '["bar"] with '[]; Expected type: Proxy '[Symbol]; Actual type: Proxy '["foo", "bar"]; * In the first argument of `fill', namely `(Proxy @["foo", "bar"])'; In the expression: fill (Proxy @["foo", "bar"]); In an equation for `it': it = fill (Proxy @["foo", "bar"])
08:17:29 <dminuoso> Uhh
08:20:54 <dminuoso> Ah here we go
08:20:55 <dminuoso> % fill :: forall (s :: [Symbol]) (n :: Nat). (KnownNat n, n ~ TyLen s) => Integer; fill = natVal (Proxy @n)
08:20:55 <yahb> dminuoso: 
08:21:04 <dminuoso> % fill @["foo", "bar"] -- AWizzArd 
08:21:04 <yahb> dminuoso: 2
08:21:47 <dminuoso> So this is a type leve list, with type level strings, and it's very likely consumed with type families (or fundeps) like in my examples.
08:22:09 <dminuoso> This is how much of servant works for example
08:22:25 <dminuoso> (They dont use type applications but a Proxy instead, but that's just different ergonomics)
08:56:16 <dmj`> hot take, GHC’s RTS settings are optimized for a compiler, not a long-running networked service
08:57:16 <merijn> How so?
08:59:30 <dmj`> merijn: the idle time GC runs every 0.3s, the assumption is that productive work is constantly happening
08:59:47 <dmj`> merijn: which would be true in a compiler
09:00:01 <dmj`> merijn: but not necessarily true in a no traffic web server
09:00:11 <merijn> dmj`: Well, is that actually negatively impacting the performance, though?
09:00:19 <merijn> I'm not sure how it would
09:00:28 <dmj`> merijn: major GCs pause program execution
09:00:38 <dolio> But your premise is that no work is happening.
09:00:42 <dmj`> it's just it could be every 10s, why busy wait
09:00:51 <dolio> So it's pausing something that isn't doing anything.
09:01:01 <merijn> ^^^ that
09:01:20 <dmj`> dolio: true, but why keep checking every 0.3s if you're doing nothing for hours potentially
09:01:38 <c_wraith> my experience is that 0.3s is pretty good for an http server
09:01:48 <merijn> dmj`: Because engineering not too is 1) extra work and 2) negatively impacts all other code
09:01:52 <dmj`> It's important to run the GC to so finalizers get called, so I think -I0 could be be bad actually
09:01:58 <dmj`> so*
09:02:07 <merijn> dmj`: Why invest work in doing something with no actual benefit?
09:02:40 <merijn> Like, concretely, what is improved by not running it every 0.3s?
09:02:41 <c_wraith> It's long enough that it's unlikely to be idle for a whole 0.3s when it's getting traffic, but short enough that it doesn't need a long break to trigger
09:03:30 <c_wraith> The settings that really make a difference for web servers are the various generation sizes - especially the nursery size
09:03:48 <dmj`> merijn: why run anything every 0.3s if you don't have to, 0.3s is an implicit assumption
09:05:11 <merijn> dmj`: Why? "because not having complex heuristics simplifies engineering"
09:05:31 <c_wraith> the dream is that you get your nursery size up to a point where most requests/responses fit entirely inside the nursery.
09:05:58 <merijn> You can justify investing effort and/or having a more complex solution IF there is a benefit
09:06:20 <merijn> If there is no benefit, then why bother investing either time or complexity budget into changing the status quo
09:10:56 <merijn> It's good to have a quantifiable reason for spending time/effort besides "it offends my sensibilities"
09:11:23 <dolio> Yeah, the argument seems entirely aesthetic so far.
09:12:29 <dolio> Also, what about the situations where the web server actually is doing something? Is 10s going to be good enough during those periods?
09:12:43 <merijn> Like, I doubt the actual GC on an idle server (especially if it's apparently idle for hours at a time) is going to have a significant cost in CPU time
09:12:56 <dolio> Also, why optimize for this hypothetical web server instead of all the things that 0.3s is good for?
09:27:13 <dmj`> I'm not advocating for optimizing for a networked service, but I'm making a point that not all workloads are created equal and 0.3s has an implicit assumption about a particular workload
09:35:09 <merijn> dmj`: Does it though? Because it sounds like it works fine for your workload
09:35:46 <dmj`> merijn: If every workload was the same why allow any customization of GC settings?
09:36:16 <merijn> dmj`: I'm not saying everything's the same. I'm just not seeing how this setting isn't working for your workload?
09:36:42 <dmj`> merijn: it's too frequent
09:36:58 <merijn> Why?
09:37:07 <merijn> What negative impact does frequency have?
09:37:16 <dmj`> It's not negative, its just not necessary
09:37:24 <dmj`> why busy wait?
09:37:25 <merijn> Beyond offending your aesthetic
09:37:34 <dmj`> this isn't an aesthetic issue
09:37:35 <merijn> dmj`: I already gave arguments for that
09:37:39 <dmj`> as did I
09:37:47 <merijn> Anyway, dinner
09:37:51 <dmj`> ciao
09:40:11 <Uniaika> 9
09:40:14 <Uniaika> eh
09:45:18 <koz_> Uniaika: 9?
09:45:37 <Uniaika> irssi fail, koz_ 
09:45:48 <koz_> Ah.
09:58:47 <scasc> Is there a function in some standard (or widespread) library which is essentially a more efficient version of \c x -> (takeWhile c x, dropWhile c x), not traversing the list twice?
09:59:07 <dolio> span
10:04:29 <scasc> Thanks! And I don't know why I put "[a] -> ([a],[a])" into Hoogle, rather than "(a -> Bool) -> [a] -> ([a],[a])"
10:06:33 <fresheyeball> So I have some code using GHCJS.DOM
10:06:39 <fresheyeball> and it compiles with GHC
10:06:43 <fresheyeball> but in GHCJS it does not
10:07:10 <fresheyeball> the culprit is `addListener` which takes a "SaferEventListener" on the GHC side, and an "EventListener" on the GHCJS side
10:30:23 <fresheyeball> I resorted to CPP
10:30:25 <fresheyeball> Grrrr
10:30:39 * Uniaika offers fresheyeball a mug of hot chocolate and a blanket
10:55:32 <justsomeguy> I want to write a test that checks if something is a type constructor or data constructor. Is there any way to do that without using GHCi?
10:55:59 <Uniaika> hmm, probably with multiline mode? :set +m ?
10:57:43 <justsomeguy> The thing is that I want to automate the test, so I'd like to avoid ghci, or possibly script the ghci session.
11:00:07 <tomsmeding> justsomeguy: https://hackage.haskell.org/package/hint exists, but also, why exactly do you want to test that? Is it generated code?
11:02:11 <Uniaika> yes, could you please tell us a bit more about your usecase?
11:02:41 <justsomeguy> tomsmeding: I'm trying to write test cases for the homework I'm doing in Haskell Programming from First Principles. It has a lot of exercises that require querying things in GHCi.
11:03:05 <justsomeguy> I just found this SO post about using expect to automate ghci, so I think I'm going to give that a shot. https://stackoverflow.com/questions/47735327/is-there-a-way-to-script-a-ghci-session
11:03:46 <tomsmeding> If you want a low-tech solution, then yes that's probably a fine option
11:04:29 <tomsmeding> especially if it's just for yourself
11:04:40 <tomsmeding> using something like the 'hint' library I linked would be for a more production-like setting
11:05:14 <justsomeguy> Is there also a way to run a .hs file as if it were a script? ... Using hlint is an interesting idea.
11:05:47 <tomsmeding> not hlint, hint ;)
11:05:58 <Rembane> justsomeguy: ghci < Bla.hs
11:06:02 <Rembane> ...I think. :D
11:06:25 <geekosaur> runghc
11:06:52 <geekosaur> although that's not so much "script"
11:07:03 <scasc> Now this: I use the hexadecimal literal in ghci all right:
11:07:08 <scasc> > 0xFFFF
11:07:11 <lambdabot>  65535
11:07:20 <scasc> why doesn't
11:07:24 <scasc> > read "0xFFFF"
11:07:26 <scasc> work?
11:07:27 <lambdabot>  *Exception: Prelude.read: no parse
11:07:52 <xerox_> > read "0xFFFF" :: Int
11:07:55 <lambdabot>  65535
11:08:53 <tomsmeding> related to the scripting question from just now, cabal apparently has shebang support: https://github.com/haskell/cabal/pull/5483
11:08:56 <tomsmeding> but where are the docs? :p
11:09:16 <justsomeguy> Can I insert ghci commands like :type <expression> or get exceptions like "error: Data constructor not in scope:" if I use runghc?
11:09:24 <justsomeguy> (I'm guessing not..)
11:09:37 <tomsmeding> no, runghc just transparently compiles and runs your file
11:09:55 <justsomeguy> Ok. Still good to know.
11:10:17 <scasc> xerox: thanks. At the same time, in the actual code I did have the annotation, still returning with "no parse" -- but that will be something else, writing a compliant readsPrec seems hard :-)
11:10:54 <xerox_> scasc: I'm guessing it wasn't exactly that then if it couldn't parse it
11:12:28 <scasc> Yeah, I'm pretty sure I messed up something in my readsPrec definition: it reads a simple value no problems `read "myrepr" :: MyType`, but I get 'no parse' with `read "[myrep1, myrep2]" :: [MyType]`.
11:12:46 <scasc> I think I messed up the readsPrec somehow.
11:15:55 * tomsmeding always uses Debug.Trace.trace liberally when debugging haskell code
11:16:46 * Rembane too
11:22:57 <topos> @jackdk 
11:22:58 <lambdabot> Unknown command, try @list
11:23:05 <topos> hopefully that answers your question
11:24:56 <solonarv> tomsmeding: they are in the cabal manual, look under 'cabal run' IIRC
11:26:39 <tomsmeding> solonarv: ah! I saw the link in a comment on a PR, but that link was apparently outdated and I neglected to see where it should have pointed
11:26:45 <tomsmeding> indeed under cabal v2-run :)
11:33:09 <solonarv> oh yeah, printf debugging (of which Debug.Trace is a subset) is really quite good
11:39:38 <sm[m]> I'll pimp my https://hackage.haskell.org/package/hledger-lib-1.20/docs/Hledger-Utils-Debug.html helpers, quite handy
11:51:23 <geekosaur> `xmobar` is just `statusBar` with xmobar as the bar and a wired-in default PP. if you want to change colors, you provide your own PP or override an exiting one using record update syntax
11:52:17 <geekosaur> and "everyone does it their own freakin way" is the downside of being extremely customizable :)
11:53:40 <monochrom>   I inflicted type inference on my students!  http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/type-inference.html
11:54:14 <koz_> monochrom: You are either the very best of instructors, or the very worst.
11:54:24 <geekosaur> whoops, I think I sent that to the wrong channel
11:57:29 <monochrom> I think I'm the best kind, because I looked hard for a presentation suitable for undergrads.
11:58:41 <monochrom> So for example first of all, none of the sequent notation, because it takes much training to eyeball how the sequent rules translates to an algorithm.
12:00:00 <monochrom> Instead, for each sequent rule, I write down the corresponding few lines of imperative, recursive code, and just show the code to the students.
12:01:22 <monochrom> As well, I made the difficult decision to keep it imperative, i.e., unification has a mutable table and updates it. Because the pure-functional alternative is more distracting.
12:01:30 <nolrai> So I get an UArray and I want an immutable Vector, is there an easy way to convert?
12:01:47 <tomsmeding> monochrom++
12:01:58 <tomsmeding> having an intuition for how type inference works is _so_ helpful
12:03:20 <nolrai> It always throws me that there's a person named "So" in this channel.
12:04:16 <monochrom> I think my most important invention is the opening "heuristically" section that shows how a human would infer types by hand, which motivates why an algorithm will need creating unknowns and solve them by unification.
12:04:27 <tomsmeding> nolrai: probably the easiest version is via []; with some luck it doesn't actually materialise the list an just compiles down to a loop
12:04:36 <tomsmeding> if you need something more performant, dunno
12:04:45 <nolrai> I guess I don't for now.
12:06:16 <merijn> Vector has generate "Int -> (Int -> a) -> Vector a"
12:06:41 <merijn> You can basically pass in the lookup of the UArray and it's size in and build the vector in place without the list at all
12:07:18 <merijn> Then you're sure it's just a single loop
12:12:25 <monochrom> No, that's only my second most important invention. :)
12:14:12 <monochrom> My most important invention is unacademic but precise (therefore more informative than academic) terminology. This one I really thought hard over a long time (on and off of course), and finally came to a perfect solution.
12:14:45 <monochrom> You know how you see the academic literature says "skolem variables", "rigid variables", "meta variables".  I'll have none of that.
12:16:18 <monochrom> In Hindley-Milner (rank 1) and without programmer-supplied type sigs, you only have to worry about "meta variables".  Well, their sole purpose is to stand for unknowns that may or may not be solved later.  So, I call them, candidly, "unknowns".
12:17:42 <monochrom> (I have also figured out what to rename "skolem variables" to: "givens". But I don't need them for now. Until one day if I cover type sigs and/or rank-n.)
12:21:32 <geekosaur> now all you need are wanteds and you can confuse anyone who work with ghc's typechecker plugins
12:22:25 <monochrom> haha yikes
12:36:51 <dsal> Is there any kind of fold that terminates while still being able to look at arguments?
12:37:06 <dsal> I've written my own recursion + a toList and feel that better should be doable.
12:37:08 <merijn> eh, foldr? :p
12:37:34 <monochrom> foldr can terminate and look at arguments
12:37:49 * glguy doesn't understand the question
12:37:59 * geekosaur neither
12:38:08 <dsal> Hmm...  OK, how does that work?  I thought if I did something with the accumulator, it'd keep consuming.
12:38:24 <glguy> dsal: What's an example of what you want to do?
12:38:32 <glguy> foldr doesn't have an accumulator
12:39:40 <dsal> foldr (\x (m,o) -> if (f x m) then Just x else (g m, o)) -- something like that
12:40:21 <dsal> I guess my understanding of early termination in foldr is a little fuzzy.
12:40:52 <monochrom> OK, I have an example of early-stopping foldr.
12:41:36 <monochrom> and = foldr (\x r -> if x then r else False) False
12:41:56 <glguy> > let unique = foldr (\x rest -> x : dropWhile (x==) rest) [] in take 3 (unique "exxxam" ++ undefined)
12:41:57 <monochrom> If you conditionally don't use r, you conditionally stop early.
12:41:59 <dsal> Right.  The problem is that I need to look at r on both sides.
12:41:59 <lambdabot>  "exa"
12:42:33 <monochrom> Does "f x m" sometimes not need m?
12:42:42 <dsal> m is always needed.
12:44:23 <glguy> > foldr (\x rec m -> if even x then m else rec (2*m)) (\m -> m) [1,3,5,7] 1
12:44:26 <lambdabot>  16
12:44:30 <glguy> > foldr (\x rec m -> if even x then m else rec (2*m)) (\m -> m) (1:2:undefined) 1
12:44:33 <lambdabot>  2
12:45:46 <glguy> > foldr (\x rec m -> if even x then m else rec (2*m)) (\m -> m) (1:3:10:undefined) 1
12:45:48 <lambdabot>  4
12:46:21 <glguy> there m is the accumulator and it exists early on even numbers
12:48:12 <dsal> that's interesting.  That 4 is confusing me, though.
12:49:02 <glguy> it's not returning x, it's returning the "accumulator" which gets doubled each step
12:50:28 <monochrom> = foldl (\a _ -> 2*a) 1 . takeWhile (not . even)
12:51:30 <dsal> Ah, OK.  That's an interesting idea, though.  It's probably better for me to stop thinking about this for a while since I don't have a *real* problem.  I just tend to treat explicit recursion as a bit of a smell.
12:51:36 <monochrom> There is a proof by rewriting foldl as foldr and then use foldr fusion. Omitted. (Handwaved.)
12:52:28 <monochrom> Code that your audience don't understand is the only code smell.
12:52:50 <glguy> I made this years ago for foldl/foldr https://old.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b/?context=3
12:52:55 <monochrom> And paradoxically it sometimes means your own recursion, some other times means not your own recursion.
12:53:34 <glguy> code smell is a code smell :nod:
12:53:35 <dsal> Oh, I know.  I don't think it's wrong per se.  Just makes me wonder if there's a way I can do it better.  In particular, toList feels a little like giving up.
12:54:02 * tomsmeding . o O ( [] is a control flow mechanism, not a data structure )
12:54:20 <dsal> That's how I'm using it.  :(
12:54:22 <glguy> import Control.List
12:54:41 <tomsmeding> Could not find module ‘Control.List’
12:54:46 <tomsmeding> was disappointed
12:54:56 <monochrom> Data.Lens and Control.Machine IMO.  The two module names that ekmett got wrong. :)
12:55:24 <dsal> I feel a little like I'm lying with this function I wrote that works with any Foldable!  (by converting it to a list and doing the recursion)
12:55:32 <dsal> I'm my only user, so I'm lying to myself.
12:55:42 <geekosaur> or put otherwise even ekmett gets confused by the module name mess
12:55:58 <monochrom> Well, it is true that if you can do it with toList, you can do it with Foldable or MonoFoldable methods.
12:57:26 <glguy> If the first thing you do is call toList, then it's probably better to just take a list as an argument
12:57:34 <dsal> I did implement this with foldr, I just don't know that it's not θ(N)
12:57:49 <glguy> unless you're trying to be clever and shave some seconds off your AoC common library :nod:
12:58:19 <dsal> Yeah, it was originally taking a list and then I changed a data structure and thought it'd be convenient to work with more data structures.
12:58:59 <dsal> AoC each year is a combination of learning that there are lots of things I don't know and learning a few of them.
12:59:52 <dsal> The löb thing was great.  That one was frustrating in that I understood the concept fairly quickly, but my brain couldn't hold both that and my code in my head at the same time for a while.  Holes are nice for that.
13:15:32 <koz_> :t (<&>)
13:15:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:16:17 <dsal> It's & for functors.
13:47:54 <dsal> This "bad parts" series is getting sillier.
14:02:03 <nfd> oh yeah shoutouts to glguy: i decided to pick up megaparsec starting at day4, and seeing the patterns you use after i'm finished with those levels has been helpful :)
14:04:23 <dolio> Seems like it's been silly.
14:34:31 <pja> dsal: Some good points though.
14:35:21 <glguy> nfd: cool; are you solutions online?
14:37:25 <pja> I always seem to spend more time than I should staring at Megaparsec type errors. Probably entirely my own fault though.
14:38:06 <glguy> I use the megaparsec parse errors to get useful feedback while I'm writing my parser in the first place (for AoC)
14:38:44 <pja> I’m probably just not /quite/ experienced enough with it to be able to spot what’s wrong quickly.
14:38:49 <nfd> glguy: yeah; https://github.com/nfd9001/advent-of-code-2020. mine are a bit more verbose/defensive/etc. and some of these involved bouncing questions off another friend who was already pretty familiar with it
14:39:58 <nfd> for day4, i ended up using the parseerrors to troubleshoot/build confidence that my stuff made sense
14:40:21 <nfd> it was really satisfying when i started seeing big waves of parse errors that were correctly rejecting bad passports
14:40:52 <dsal> My day 4 is pretty sad.  I've not done anything to make that one better.
14:41:43 <dsal> I went too hard on a specific datatype too soon.
14:41:56 <dsal> Of course, the nice part is that `part1 = length`
14:44:09 <glguy> nfd: Are you on my #haskell-themed leaderboard?
14:46:58 <dsal> I'm not very fast this year, but I'm also not panicking about it.  Just enjoying the learning.
14:47:25 <sgibber2018> dsal: Sounds like a good attitude to me. :)
14:47:38 <glguy> the leaderboard is more about links to solutions and seeing who's keeping up than having to race
14:47:52 <dsal> Oh, is it supposed to link to answers?
14:48:08 <glguy> It can link to your github; many people put their answrs on their githubs
14:48:41 <dsal> I've been pushing mine into a keybase repo.  I don't really have any reason to keep anything secret since smarter folks than I have good answers.
14:49:55 <nfd> glguy: no! happy to join though
14:50:20 <glguy> nfd: code in /topic
14:50:41 <crestfallen> hi would someone kindly point out possible indent errors beginning line 152 in 'factor'  ? the program compiles but only returns "Invalid input". thanks   https://gist.github.com/varreli/b32fa33506737c3b3fa0ff236dbe1c2c
14:51:38 <crestfallen> I have another version that works but it's far different from this one from the textbook
14:51:39 <AwesomeRigg> hey whats the best stuff App Language  to learn that will get a job fast during covid 2021
14:52:36 <crestfallen> The book doesn't cover nested do statements so far, and the kindle version has all the indentation wrong
14:54:27 <crestfallen> a version I got online is here, using Data Expr ...    https://termbin.com/amea
14:54:48 <nfd> crestfallen: https://en.wikibooks.org/wiki/Haskell/Indentation may help in general
14:55:01 <nfd> especially noting its Golden Rule
14:57:44 <crestfallen> nfd I had it that way last night - with the standard indentation - but it compiles and still returns the error 
14:57:48 <crestfallen> thanks btw
14:58:24 <dsal> crestfallen: The <|> looks pretty confusing to me.  I'd put it on a new line and not have it indented in the do.  Or better, name the do block and just have `parens <|> natural`
14:59:20 <crestfallen> 'parens <|> natural' ? I don't understand dsal
14:59:26 <dsal> or `factor = between "(" ")" expr <|> natural`
15:00:33 <crestfallen> this is the hutton book verbatim (but unsure of correct indent due to format of kindle pub). why can't I get it to return a value?
15:00:36 <crestfallen> dsal
15:01:01 <dsal> crestfallen: something like this:   https://www.irccloud.com/pastebin/KyTlRwBb/factor.hs
15:01:35 <dsal> I don't know the book, but the alternative looks like it's in the wrong place to me.
15:02:03 <dsal> i.e., it's not even conceptually what you'd want, assuming you want (expr) or whatever natural is.
15:02:36 <crestfallen> It's odd, other solution sets on github have alternative in different spots, they compile and get same Invalid input error
15:03:29 <dsal> I don't exactly understand what you're experiencing, but it doesn't make sense to me for it to be there.  I also wouldn't stick it after the do block (probably) because it's harder to read.
15:03:34 <dsal> (but I also wouldn't use a do block there)
15:05:19 <crestfallen> thanks, I'd assume the book uses standard practices; its presented very matter of factly; immensely terse.  dsal
15:06:11 <crestfallen> dsal where would you put alternative?
15:06:24 <dsal> Well, where I did in the paste above ^
15:06:43 <crestfallen> ok I thought you meant the definition... sorry
15:07:07 <dsal> Or `factor = ("(" *> expr <* ")") <|> natural` if you don't have between (though between is easy enough to write.
15:08:02 <dsal> Adding <|> after a do block seems too easy to get wrong.  You've also noticed that.  :)
15:08:21 <dsal> But at the very least, doing it on the last line can't mean what you want.
15:08:58 <crestfallen> dsal sorry your version with the where statement compiles but does not return a value!
15:09:10 <dsal> What does it mean to not return a value?
15:10:05 <crestfallen> for example with > eval "3+(4*5)"   I get the Invalid input error
15:10:51 <crestfallen> or with > parse expr "3+(4*5)"  ==> []
15:11:13 <dsal> Ah.  Your parser doesn't give super great diagnostics. heh
15:11:56 <crestfallen> sorry the quip is over my head. I'm hoping the thing will return 23 :)
15:13:00 <crestfallen> leads me to think the issue is elsewhere
15:13:13 <sm[m]> Hope is Not a Strategy! :-)
15:13:26 <dsal> Oh, expr is also broken.
15:14:26 <dsal> λ> parse expr "3+(4+5)"
15:14:26 <dsal> [(12,"")]
15:14:54 <dsal> All your alternatives are hard to get right with all the do blocks.  You can `do` it, but it's just a confusing way to do things.
15:15:20 <nfd> i sometimes use <|> inside do blocks in parsers, but i think you need to be kinda disciplined about it for it to be really clear
15:15:21 <crestfallen> its for illustrative purposes in the book I guess
15:15:46 <nfd> like https://github.com/nfd9001/advent-of-code-2020/blob/8703b659299c111b0e56296b1c0fe90a4e51eafc/day7.hs#L47 (obviously day7 aoc spoilers if you care)
15:16:34 <crestfallen> nfd I'm just following a book. the section is remarkably brief. there are no uses of nested do blocks, very sparse explanations
15:17:25 <crestfallen> dsal how to fix expr, it's precisely as written except for possible indent issues
15:17:36 <nfd> oh, yeah, i'm just saying that using alternatives in a do isn't something you're Never Allowed to do if you're careful about it
15:17:39 <dsal> crestfallen: BTW, I think this makes it a lot easier to read as well.  :) https://www.irccloud.com/pastebin/nETZ5hIg/between.hs
15:18:05 <dsal> You have to fix all of them such that the alternative is an alternative for the whole do block and not a thing within the do block.
15:18:34 <crestfallen> dsal I tried with brackets and parens. please illustrate
15:18:51 <dsal> For example: https://www.irccloud.com/pastebin/3Fzxhu6s/ex.hs
15:19:14 <z0> how lazy is Set.fromList? i mean if we do (elem y $ Set.fromList [x,y,z]) are we traversing the full list or just until we find z?
15:19:34 <z0> and what would be the best approach for me to find a source for questions like this?
15:19:50 <dsal> My emacs indenter won't even do the right thing here.
15:20:02 <dsal> I just wouldn't write that.  That you're having trouble with it is why.
15:20:03 <dolio> Creating the set consumes the entire list.
15:20:47 <crestfallen> one less space indented on line 7?
15:22:21 <dsal> I changed indentation until it expressed what you actually mean here and compiled.  That seemed to be the spot.  It looks silly, though.  I'd reject anything that looked like this in code review.
15:24:04 <z0> dolio: that makes sense, thanks. sometimes haskell surprises me so im looking for a good resource on lazyness and performance that can help me know things like this
15:25:42 <crestfallen> I really don't understand why the well-regarded book would teach it this way dsal there seems to be so many angles to this, with so little explanation. I think the more important point, also seemingly glossed over, is the logic behind how the recursion works between the parsers. I can only vaguely grasp it at this point
15:27:40 <dsal> Yeah, so just name the do blocks and combine the names with <|> and you'll be less confused.
15:29:36 <dolio> z0: Well, in this case, the structure of the Set and its elements (keys in the case of Map) is fully evaluated. I imagine it says that somewhere in the docs. And you can't really create the structure without consuming the entire list.
15:30:22 <dolio> So to evaluate the set at all, the entire list must be evaluated.
15:31:35 <nfd> it might help to think about what a Set is as a data structure when you're thinking about if the whole list needs to be consumed
15:32:59 <dolio> Also the `fromList` docs mention that it checks if the list is sorted to use a linear algorithm, which can't be done without inspecting the entire list.
15:33:38 <nfd> that Ord constraint in the elem type is there because you're constructing a tree of elems, which means your Set lookups involve traversing some sort of balanced search tree. what would it mean to traverse a partially-constructed search tree? i don't think i have a great answer for that, because during that construction it may need to be rebalanced
15:35:22 <nfd> so the simpler implementation on their end is to consume the whole structure before passing a value back
15:37:01 <crestfallen> dsal thanks kindly, not sure I'm clear on all this but thanks!
15:37:09 <crestfallen> thanks nsd
15:37:20 <crestfallen> thanks nfd
15:45:26 <z0> i see how that's obvious. thanks
16:02:58 <Axman6> so combing back to the question I had yesterday, I'm running into problems with multi param type classes; class Foo a b c | a -> b; class Foo a b c => Bar a b | a -> b - I get errors about a being not in scope (I think, waiting for a recompile after a rebase). Sadly this is DAML, so the usual fix of using type families instead of class params isn't available to me. There doesn't seem to be a way to ignore those type params in Foo
16:03:49 <Axman6> other things I have tried are adding those type params to Bar but that causes other issues with overlapping instances (seems GHC is pretty dumb about its use of fundeps, or I don't understand them well enough)
16:06:45 <Axman6> ultimatly I then want to make instances like: instance Foo a BazV1 c => Bar a BazV1 ... instance Foo a BazV2 c => Bar a BazV2 ... but I get overlapping instances for those, even though the fundeps ensure they are distinct
16:09:43 <Axman6> one "fix" I did come up with is adding default instances, so class Foo a b c | a -> b, a -> c; class Foo a b c => Bar a b | a -> b where doThing :: a -> Bool; default doThing :: Foo a BarV1 c => a -> Bool; doThing = ...; instance Foo a BazV2 c => Bar a BazV2 where ..., which works, but means we can only have two instances of this class, we can't later add BarV3 without getting overlapping instances
16:17:33 <iqubic> What is a Bazaar? Should I learn more about these exotic comonands?
16:17:44 <Axman6> no
16:18:06 <iqubic> Why not?
16:18:24 <koz_> iqubic: Are you planning on contributing to lens?
16:18:27 <Axman6> why do you think you need to?
16:18:41 <iqubic> koz_:  I'm not going to do that.
16:18:51 <koz_> iqubic: Then I can safely say you don't need to know them.
16:18:57 <Axman6> @hoogle Bazaar
16:18:58 <lambdabot> Control.Lens.Combinators newtype Bazaar p a b t
16:18:58 <lambdabot> Control.Lens.Combinators Bazaar :: (forall f . Applicative f => p a (f b) -> f t) -> Bazaar p a b t
16:18:58 <lambdabot> module Control.Lens.Internal.Bazaar
16:19:02 <koz_> A Bazaar is just 'multiple Stores'.
16:19:02 <iqubic> Axman6: I think I might be able to write more efficient code,
16:19:05 <jle`> it probably won't help you in any sort of every day haskell capacity
16:19:28 <jle`> it might be funsies though
16:19:40 <jle`> so it depends on what you mean by "should"
16:19:49 <koz_> I think it was jle` who clued me onto the whole 'multiple Stores' thing.
16:20:07 <Axman6> my "no" was in response to the should in the original question
16:20:11 <jle`> from a practical perspective? probably not.  from an ethical/moral perspective? probably no reason either way. from a curiosity perspective? maybe
16:20:13 <iqubic> jle`: you used holesOf in a cool way.
16:20:42 <Axman6> typical jle`, using things in cool ways
16:21:02 <koz_> *insert some kind of 'into every possible hole' joke I am too non-strict to make*
16:21:22 <iqubic> I love the perterbationsOf function, and I love it, and I love that I can understand it.
16:22:04 <Axman6> koz_: you just need to apply yourself
16:22:20 <koz_> Axman6: Nah, too lazy. :P
16:22:25 <iqubic> <*> ???
16:22:40 <koz_> iqubic: fix ($)
16:22:49 <iqubic> What does that do?
16:22:56 <koz_> :t fix ($)
16:22:56 <Axman6> yeah, fuck the banking system
16:22:58 <lambdabot> a -> b
16:25:29 <solonarv> it's bottom
16:25:41 <solonarv> fix ($) = fix id = <<loops forever>>
16:26:16 <jle`> > let myfunc = fix ($) in myfunc `seq` "hello"
16:26:19 <lambdabot>  "hello"
16:26:32 <jle`> not quite bottom, but one step away :)
16:26:39 <hpc> it's const bottom
16:28:43 <hpc> one could argue that bottom and const bottom are the same because it's sometimes useful to assume seq doesn't exist
16:28:53 <hpc> i don't know if it ever got settled if that perspective was useful or not
16:29:05 <nshepperd> impending bottom
16:30:11 <jle`> i'm sorry D:
16:30:42 <Axman6> one step away from bottom sounds like an imminent sexual harrassment suit
16:30:54 <koz_> Racy Haskell.
16:31:03 <koz_> (with 100% less MVar)
16:31:25 <Axman6> M'Var 
16:31:32 <koz_> LOOOOOOL
16:31:38 <jle`> heh
16:32:07 <koz_> How does that saying go? "Haskellers make it a point not to inspect other people's bottoms?".
16:32:34 <Axman6> I am of the opinion that we don't use enough apostrophies in the middle of identifier names
16:32:36 <jle`> hpc: maybe in practice it'd be useful to distinguish the two so bang patterns don't blow up inadvertenly.  but yeah, without seq i'm not sure how to distinguish
16:33:57 <nshepperd> i invoked zip`ap`tail in aoc the other day, that's a start
16:34:11 <Axman6> praise be
16:38:10 <hpc> if you combine zip`ap`tail with https://wiki.haskell.org/Tying_the_Knot you get a pretzelcoatl
16:38:16 <koz_> Lol.
16:38:24 <nshepperd> hahaha
16:38:24 <monochrom> haha
16:39:16 <Axman6> I'm struggling to parse that - pretzel-coatl? pretzel-co-atl?
16:39:33 <koz_> Axman6: So what is an 'atl' then?
16:39:47 <Axman6> what's a coatl
16:40:02 <koz_> The categorical dual to an atl, naturally.
16:44:19 <monochrom> I just took it for a combination of "pretzel" and some Aztec word.
16:50:10 * Axman6 needs to learn more Aztec
16:50:40 <Clint> you mean Nahuatl
16:51:14 <iqubic> Any time I see someone talk about coaxial cables, I always wonder if there are axial cables, and if there are the dual of the coaxial cables.
16:51:37 <monochrom> Oh, don't worry, all I know about Aztec names I learned from AOE2 and AOE3. Namely, have "tl" somewhere. :)
16:57:13 <slack1256> https://imgur.com/a/Eb2yVgn does anyone know what the * means as a type descriptor?
16:58:10 <iqubic> Yeah, It means that the given value can have any type at all.
16:58:32 <iqubic> Although, I'm not sure how that relates your plot.
16:58:41 <iqubic> I don't even know what your plot is showing.
16:59:15 <Axman6> then why answer so authoritatively
16:59:36 <iqubic> No clue.
16:59:39 <slack1256> don't worry, I just wanted to know about the * .
18:02:12 <jle`> what's the language that lets me do 1e6 :: Int again?
18:03:42 <Axman6> > 1e6 :: Int
18:03:45 <lambdabot>  error:
18:03:46 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘1e6’
18:03:46 <lambdabot>      • In the expression: 1e6 :: Int
18:03:52 <jle`> er, the language extension
18:03:54 <jle`> sorry
18:04:03 <Axman6> damn, thought that might include the extension in the error
18:05:26 <monochrom> NumDecimals
18:06:23 <monochrom> and looking into the GHC user's guide for that led me to HexFloatLiterals
18:06:42 <monochrom> Yikes, the exponent is still in base ten
18:06:49 <jle`> thanks :)
18:07:21 <Axman6> 0xa.bc07e0x2a
18:07:37 <Axman6> I see a small problem with this syntax...
18:07:39 <monochrom> err, I misread, it's more complicated
18:19:27 <iqubic> jle`: What are you planning on doing with 1e6 as an integer literal?
18:24:23 <monochrom> Ah OK, the exponent is written in base 10, and it is a power of two. So 1p14 means one * two^fourteen
18:24:59 <monochrom> So the mantissa is base 16, but the exponent is two^(base ten notation)
18:25:23 <monochrom> You see why I avoid "base 10"? :)
18:25:48 <Axman6> I'm surprised it's using ^
18:26:26 <c_wraith> iqubic: 1e6 is a very common thing to pass to threadSleep
18:26:34 <monochrom> Well, ^ is my notation
18:26:50 <iqubic> c_wraith: How long does that make it sleep for?
18:26:54 <c_wraith> 1 second
18:27:50 <glguy> % :set -XNumDecimals
18:27:51 <yahb> glguy: 
18:27:53 <monochrom> This is why Lt. Cmdr. Data says, "believe me, to an android, 4.5 seconds feels like eternity"
18:27:59 <glguy> % 1e6 :: Int
18:27:59 <yahb> glguy: 1000000
18:28:17 <Axman6> That's what she said?
18:30:02 <glguy> % :set -XNumericUnderscores -XHexFloatLiterals -XBinaryLiterals
18:30:02 <yahb> glguy: 
18:30:20 <glguy> Full-power number literals
18:30:56 <c_wraith> fully armed and operational numeric parser
18:31:02 <monochrom> over-powered :)
18:31:40 <glguy> Technically we could turn on NegativeLiterals, but I'm not so sure that's an improvement
18:32:34 <monochrom> {-# LANGUAGE OverloadedString, OverpoweredNumLiterals #-}
18:32:49 <monochrom> Oh even better:
18:32:57 <monochrom> {-# LANGUAGE OverloadedString, OverpoweredNumLiterals, OverflowableInt #-}
18:33:22 <glguy> % 0x_1_p2
18:33:23 <yahb> glguy: 4
18:33:25 <monochrom> "it's all over the place" >:)
18:37:11 <dsal> OverblownExtensions
18:37:57 <monochrom> :)
18:54:11 <z0_> in the context of queues what direction would right be (as in foldr)? 
18:57:10 <koz_> z0_: How is the queue implemented?
18:57:24 <z0_> in other words, is the head of a queue the last element in or the next out?
18:57:27 <Axman6> generally I thnk of queues having elements added on the right and removed on the left
18:57:37 <z0_> koz_: two lists, inbos and outbox
18:57:43 <z0_> *inbox
18:57:44 <steven2> hello, how can I time the execution of a program that I'm running with stack? Stack run seems to take extra time compared to just running the exe
18:58:04 <Axman6> stack exec -- time foo-exe?
18:58:08 <koz_> z0_: Then foldr would be the same as for its equivalent list. At least that'd be the easiest.
18:58:38 <Axman6> with the two list implementation one list would usually be reversed
18:58:42 <z0_> well my doubt stems from the fact that one of the lists is reversed
18:58:53 <z0_> right
18:59:02 <z0_> is there a convention?
18:59:06 <koz_> Yeah, but there is a canonical list conversion - you reverse the 'tail' list and then append them to each other.
18:59:13 <koz_> So you just do that, then foldr the result.
18:59:18 <koz_> Ditto foldl'.
18:59:30 <Axman6> foldr f z (out,in) = foldr f (foldr f z (reverse in) out
18:59:30 <steven2> Axman6: that kind of works, but the output is a little mangled
18:59:32 <steven2> no newlines
19:00:06 <steven2> is there a stack command to get the path to the exe? otherwise I guess I can look for it when I need it
19:00:18 <Axman6> stack exec which foo-exe works
19:00:20 <koz_> stack exec -- which foo-exe
19:00:24 <koz_> Dammit ninja'd.
19:00:42 <Axman6> you're two hours ahead and I still beat you!
19:00:50 <koz_> Axman6: I know, I am terrible.
19:09:03 <doct0rhu> @where paste
19:09:03 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
19:10:40 <doct0rhu> https://paste.tomsmeding.com/n0lYCn6L
19:10:55 <doct0rhu> needs some help on stack.yaml syntax..
19:16:15 <koz_> doct0rhu: https://paste.tomsmeding.com/BhqsXPiX
19:16:36 <koz_> Mashing deps into the packages section is inadvisable.
19:18:55 <doct0rhu> oh yes... that's the legacy behaviour..
19:18:57 <doct0rhu> thanks
19:19:12 <doct0rhu> they haven't updated this stack.yaml file for a long time
21:45:24 <olligobber> :exf (a -> a -> b) -> a -> b
21:45:28 <olligobber> no?
21:45:49 <olligobber> :help
21:45:59 <olligobber> :?
21:46:02 <olligobber> k
22:00:58 <olligobber> wait, is it just join?
22:03:39 <keltono> olligobber: what are you looking for?
22:04:13 <olligobber> join :: (a->a->b)->a->b
22:04:20 <olligobber> I found it
22:06:19 <olligobber> turns out I didn't actually need it though
22:09:27 <iqubic> What does liftA2 (+) do?
22:09:34 <iqubic> :t liftA2 (+)
22:09:35 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
22:10:11 <iqubic> I see.
23:50:07 <siraben> @unmtl ReaderT u (StateT s (ContT r m)) a
23:50:07 <lambdabot> u -> s -> (a -> s -> m r) -> m r
23:50:26 <siraben> I like me a good `a -> s -> m r` video
