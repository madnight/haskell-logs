00:01:48 <boxscape> I guess the real problem then is that the server accepts https connections at all?
00:02:03 <boxscape> otherwise firefox wouldn't redirect to https
00:03:35 <int-e> boxscape: why wouldn't it accept https connections? on that level it can't distinguish whether it's for its main website, www.red-bean.com, or for the second class citizen that is book.realworldhaskell.org
00:04:18 <boxscape> ah, I didn't know you can't control that on a domain level
00:04:49 <opqdonut> well the https port is open on that IP
00:04:58 <int-e> Yeah the DNS only resolves names to IP addresses, it doesn't care about ports.
00:05:00 <opqdonut> there's no domains or urls when the TCP SYN gets done
00:05:14 <boxscape> that makes sense
00:10:48 <plakband> I have a library with two modules (both exposed), but cabal new-repl only imports 1 at startup for some reason. I can manually import it, but I need it to load both at startup for ghcid. Anybody here know how to make it load all modules?
00:14:01 <iqubic> May I just say that the Haskell LSP is the best thing ever.
00:17:15 <int-e> boxscape: FWIW I'm not sure about whether the book is intended to be "second class" like this... it may just be an oversight by the admins.
00:17:55 <boxscape> to be fair any website that doesn't support https deserves to be second class ;)
00:18:08 <boxscape> unless
00:18:12 <boxscape> is that also the admins' fault?
00:28:16 <int-e> boxscape: Well it's up to the web server and the management of the server certificate... so all in the admin's power. But somebody has to tweak the right knobs and test the result. And looking at red-bean this looks like a small community hobby project.
00:30:15 <boxscape> hm, yeah
00:31:45 <tomsmeding> plakband: 'cabal new-repl' without further arguments does that? that is very strange, is there a reproducing example you can share?
00:35:14 <int-e> confusingly, www.realworldhaskell.org (which was hosted elsewhere by one of the authors) *is* gone.
00:43:10 <plakband> tomsmeding: https://github.com/jonascarpay/cabal-new-repl-example
00:45:21 <tomsmeding> oh, right, only _imports_ one module. Why do you need both for ghcid? ghcid works for me even if not all modules get imported, because all _do_ get compiled
00:45:26 <tomsmeding> plakband: ^
00:47:13 <tomsmeding> plakband: in particular, if I run ghcid in a clone of your repo, warnings in both modules show up in ghcid
00:47:34 <plakband> tomsmeding: because --test=expr only works with imported modules
00:48:18 <plakband> it's not a huge deal, but it feels kinda dumb
00:48:35 <plakband> I need to reorder my modules based on what test I want to run
00:50:53 <tomsmeding> plakband: and passing the wanted module name to ghcid doesn't work?
00:51:08 <tomsmeding> also I can't seem to make --test work at all, but that's probably just my unfamiliarity with ghcid
00:52:42 <tomsmeding> oh I see, I indeed get the behaviour you describe
00:53:19 <plakband> tomsmeding: afaict not, it only seems to accept actual components..
00:55:05 <tomsmeding> plakband: what seems to work for me is pass the names of all modules as command-line parameters, with the one you want imported (containing your test function) listed first
00:56:00 <plakband> tomsmeding: oh hey, how did I miss that.. thanks, that'll do!
00:56:26 <tomsmeding> awesome :)
00:56:49 <tomsmeding> (listing all modules seems to be necessary to load them all)
01:02:33 <plakband> tomsmeding: hmmm looks like I celebrated too early, it does still get picked up in the order specified in the cabal file on my end. Does swapping them change the imported module for you?
01:03:09 <tomsmeding> it did for me, but I tried it on an executable; perhaps it's different for a library, let's see
01:05:10 <tomsmeding> plakband: yes I put 'a :: Int; a = 1' in Module1.hs and 'b :: Int; b = 2' in Module2.hs, and 'ghcid --test a' works, 'ghcid --test b' does not, but 'ghcid Module2 Module1 --test b' does work for me
01:06:49 <tomsmeding> plakband: try 'ghcid --test yourthing --setup ":l YourModule"'
01:07:05 <tomsmeding> that seems like the correct way to do this, lesson: RTFM :)
01:07:33 <tomsmeding> (penultimate faq item on https://github.com/ndmitchell/ghcid)
01:12:37 <plakband> tomsmeding: Even better, Module.test works fine. Definitely should've R'd the FM. Thanks again!
02:22:20 <merijn> Man...megaparsec haddocks are a mess
02:30:09 <atralheaven> Hi, I watched this talk recently (https://www.youtube.com/watch?v=03mUs5NlT6U) it's about "correct by construction" software, I couldn't thought of something like this even in my dreams, I really liked the idea.
02:31:56 <atralheaven> The thing is, I'm not familiar with the technical stuff, I know nothing about them, but it looked like something that haskell might be able to do, although I also know nothing about haskell
02:35:31 <tdammers> atralheaven: "correct by construction" is always going to be a relative/partial effort, but for reasonable degrees of it, Haskell is an excellent tool
02:35:32 <atralheaven> so I wanted to ask, does haskell support something like this? that thing is so good that if I can have that in haskell, I will learn haskell with all the category theory and monads and monoids for it
02:36:26 <tdammers> also, you absolutely do not need to learn any category theory for haskell
02:36:59 <atralheaven> that's really good
02:37:09 <tdammers> an informal grasp of set theory may be helpful for reasoning about types, but even that isn't strictly required
02:37:40 <atralheaven> can I know specifically which parts of my code can be CbC and which parts can go wrong?
02:37:58 <tdammers> generally mostly yes, though there are a few subtleties
02:38:20 <__monty__> Is there a hackage url I can browse to that will either land me on a package page or search results? Currently I can either search then click or try a package url then click "search instead" if it doesn't exist.
02:39:22 <tdammers> a big caveat (though it doesn't actually matter a lot in practice) is that there are "backdoors" for bypassing type safety and purity, and that there's this thing called "bottom"
02:39:39 <__monty__> merijn: What makes them hard to read for me is many of the useful combinators come from other more general libraries. Nice conceptually but makes discovery hard if you don't know about them yet.
02:39:47 <atralheaven> tdammers: great, should I use a tool or library with haskell for it or it's just how haskell is?
02:39:58 <merijn> __monty__: The organisation is a mess
02:40:01 <tdammers> it's a way of writing code more than anything
02:40:04 <merijn> __monty__: No logical grouping
02:40:48 <tdammers> the most important feature to help you with "correct by construction" in Haskell is the type system, which allows you to narrow down the things a function can accept and produce
02:42:05 <tdammers> e.g., if you write a function that is typed as Int -> String, then the compiler will make sure that this function 1) will only ever be fed integers as inputs, 2) can only ever produce strings as its output, and 3) cannot have any side effects, such as touching the file system, making network requests, manipulating mutable variables, or introducing randomness
02:43:18 <tdammers> trying to call such a function with an argument that isn't an Int is a compiler error. implementing its body such that it tries to do things with the argument that cannot be done on integers is a compiler error. trying to make it return something that isn't a String (including Nothing, a rough equivalent of NULL in other languages) is a compiler error. etc.
02:43:38 <merijn> ffs
02:43:42 <tdammers> so the "correct by construction" approach in Haskell boils down to designing your functions and data structures such that they can only represent "valid" or "desirable" states
02:44:12 * merijn resets the "It has been N days since I was screwed over by Map having the wrong Monoid instance"-counter back to 0
02:44:22 <atralheaven> I do prefer compiler errors to runtime errors
02:44:23 <merijn> A pox upon the house of whoever decided on the current monoid
02:45:48 <atralheaven> do you know a good video course for haskell? right now I'm familiar with python and elixir
02:45:50 <tdammers> atralheaven: preaching to the choir :D
02:47:55 <AWizzArd> Emacs users: is there a code formatter that will format a marked region vs the whole file?
02:57:31 <tomsmeding> merijn: what did you want <> to do? unionWith (<>) ?
02:57:48 <merijn> tomsmeding: Obviously >.>
02:58:03 <merijn> That's so *infinitely* more useful then this nonsense
02:58:20 <tomsmeding> isn't the current behaviour unionWith (flip const)?
02:58:40 <merijn> It keeps the left most one, so it's just "unionWith const"
02:58:46 <tomsmeding> ah
02:59:23 <tomsmeding> I believe I've actually used the current monoid instance correctly in the past where, but then I would have been perfectly okay with writing 'unionWith const'
02:59:37 <tomsmeding> also my mistake just now probably indicates why unionWith (<>) is better
02:59:59 <merijn> "Map key (Sum Int)" is such a useful pattern
03:00:05 <merijn> And completely ruined by this >.>
03:00:13 * tomsmeding should use the monoid wrappers more
03:00:26 <merijn> I've literally never wanted the left-biased union :\
03:00:56 <__monty__> Haskell doesn't have comparison operator chaining, does it? I.e., `a < b < c` being shorthand for `a < b && b < c`.
03:01:11 <merijn> Which, incidentally is just "Map key (First val)"
03:01:14 <merijn> __monty__: no
03:02:29 <tdammers> unionWith (<>) would require an additional Monoid constraint on the values
03:02:40 <merijn> tdammers: only Semigroup
03:02:49 <tdammers> right, yes, ofc
03:03:03 <tdammers> still, it would need an additional constraint, and so not all Maps would have a Monoid instance
03:03:09 <merijn> tdammers: which can be trivially recovered via First
03:03:29 <merijn> tdammers: THere's always just union/unions
03:03:37 <tdammers> fwiw, I've found the existing one useful more often than not
03:03:58 <tdammers> we can of course argue whether left or right biasing would be better
03:04:01 <merijn> tdammers: Accumulating by key is so useful it's a shame to sacrifice with 0 gained power
03:04:15 <tdammers> you can still do it, just not via the monoid instance
03:04:17 <tdammers> vOv
03:04:23 <merijn> tdammers: My proposal is strictly more powerful
03:04:31 <merijn> tdammers: It is *incredibly* inconvenient, though
03:04:45 <merijn> tdammers: Can't use foldMap to easily aggregate
03:05:02 <tdammers> idk, newtype it then?
03:05:04 <merijn> tdammers: Gotta do a separate map, followed by "fromListWith
03:05:22 <merijn> tdammers: Assuming you have a list, else you first have to convert to a list
03:06:07 <merijn> tdammers: newtype means none of the functions work, so you'd have to re-export the entire containers API to get anything useful (which I might just do if I get annoyed/bit by this again with actual spare time)
03:06:38 <tdammers> hmhm
03:08:39 <tomsmeding> -package containers-but-then-with-useful-monoids
03:09:24 <tdammers> again, I've found the existing instance useful more than once
03:10:10 <tdammers> e.g., a pattern I use quite a bit is building multiple maps of configuration options, one map per source (e.g., environment, config file, arguments), and then merge them with mconcat
03:10:33 <idnar> merijn: https://hackage.haskell.org/package/appendmap
03:10:37 <merijn> tdammers: "s/mconcat/unions/" patched your code ;)
03:11:03 <tdammers> sure
03:11:26 <tdammers> oh, but yeah, I can see what the unionsWith (<>) implementation buys you when you start nesting maps
03:11:37 <merijn> idnar: That exports none of the API of containers
03:11:51 <merijn> idnar: So you can actually write anything useful without continuously wrapping/unwrapping
03:12:09 <idnar> merijn: yeah :/
03:12:46 <merijn> tdammers: For nested maps it's less bad, then the overhead of writing some wrappers disappears
03:14:10 <merijn> tdammers: Especially for the simple case of, like "foldMap (\k -> M.singleton k (Sum 1))" it's annoyting that it breaks and you have to awkwardly "M.fromListWith mappend . map (\k -> (k,Sum 1)) . F.toList" 
03:15:26 <tdammers> can't you just fmap succ?
03:15:50 <merijn> ?
03:16:35 <idnar> AWizzArd: ormolu.el has ormolu-format-region, lsp has lsp-format-region
03:20:16 <AWizzArd> idnar: okay thanks, will have a look at this!
04:12:05 <tomsmeding> tdammers: intent was a histogram of a foldable, I think
04:20:50 <tomsmeding> I'd have written that with M.fromListWith (+) . map (,1) . F.toList, but same
04:21:29 <merijn> tomsmeding: The monoid generalises better, though
04:46:29 <lortabac> is there a function that flips the keys and the values of a Map?
04:50:09 <tensegrist> is there a way i can get hie to use -O0
04:50:14 <tensegrist> or, well, hls now
04:50:21 <merijn> tensegrist: Pretty sure it already does by default?
04:51:51 <tensegrist> merijn: i have a simple hie.yaml that just names the components of the project
04:52:02 <tensegrist> and it seems to be calling ghc with -O1
04:52:55 <tensegrist> https://i.imgur.com/adixDXb.png
04:52:57 <solonarv> does it also pass -fno-code? there's little reason to generate code at all in hie/hls, so it seems like that should be the default
04:53:06 <hseg> what are the restricted analogues of Functor/Applicative/Monad used for containers? e.g. am encoding multisets as Map k Int, these should really have all three instances except for an Ord k constraint
04:53:42 <tensegrist> i don't think it does?
04:53:54 <tensegrist> but is there a way to tell hie to pass -O0 explicitly
04:54:05 <tensegrist> this is a huge project by my standards and it would help a lot
04:54:08 <hseg> i ended up monomorphising, but it's annoying and general enough i suppose it's come up before
04:54:16 <merijn> hseg: eh, you can really sensibly traverse keys without basically serialising the Map into a list and going back
04:54:22 <tensegrist> idk if the direct cradle is the right idea
04:54:37 <hseg> you mean "can't"?
04:54:39 <merijn> tensegrist: It's weird that you notice, tbh
04:54:58 <merijn> tensegrist: I have a huge project that takes ages to build, but HIE is pretty snappy
04:55:25 <tensegrist> it's about the first run
04:55:41 <tensegrist> it's been running for ages and this is an 8-core machine with what seems like enough memory
04:56:02 <hseg> and yeah, this isn't a savings, but the semantics are better fit than quotienting [] by order
04:56:45 <hseg> (though it unnecessarily forces me to distinguish bw empty and fromList [(k,0)], but i can live with that)
04:58:49 <tensegrist> i don't think 50 kloc across 300ish files is that much either 
04:59:10 <tensegrist> but since the way i test my code is always with -O0 this is taking a while
04:59:21 <tensegrist> finally got done building deps
05:03:39 <hseg> so am i to understand that rmonad, supermonad, free-functors, and the like are all theoretical solutions only at the moment?
05:29:09 <__monty__> Hmm, running into this "TODO: add support for multiple packages in a directory" with ghcid. What's the easiest way around this?
05:35:41 <tomsmeding> lortabac: `M.fromList . map (\(x,y) -> (y,x)) . M.toList` :p
05:36:27 <lortabac> tomsmeding: thanks
05:36:32 <tomsmeding> tensegrist: in my experience building the project first makes ghcide load the thing faster, but that's perhaps dependent on the project
05:36:47 <tomsmeding> lortabac: no library function AFAIK
05:37:08 <lortabac> tomsmeding: I was wondering if it was already defined somewhere, but in fact it's so simple it doesn't matter
05:37:33 <tomsmeding> mind that you probably want fromListWith with a suitable combination function
05:37:58 <lortabac> there was a bidirectional map library somewhere on Hackage, it's probably better in these cases
05:38:00 <tomsmeding> because this just throws away values if you have duplicates
05:41:45 <danza> tomsmeding, the function (a, b) -> (b, a) is Data.Tuple.swap
05:43:21 <tomsmeding> lortabac: ^; danza: right, I knew it was somewhere but was too lazy to try to recall where exactly. In this case, although "map swap" rhymes nicely, I'm not sure whether the import is worth it, but YMMV
05:45:33 <danza> lortabac, tomsmeding this seems a bit ill-defined though. Values can be duplicated thus when turning them to key you might want to use Map.fromListWith
05:46:00 <tomsmeding> hence my remark about fromListWith above :p
05:46:14 <danza> sorry i lost it :)
05:46:29 <tomsmeding> also "map swap" doesn't actually rhyme in english I realise, only with a bad Dutch accent in which both 'a's become the 'a' from "bar"
05:46:46 <danza> :D
05:47:11 <lortabac> haha don't worry it rhymes in my accent too :P
05:49:00 <tensegrist> tomsmeding: yeah like i said i build with -O0 but i've never used ghcide on it
05:49:24 <tensegrist> and i have no idea how to make ghcide use -O0 and not -O1
06:16:11 <eedgit> Is there a good place to search for basic examples
06:16:34 <eedgit> I'm having trouble storing / passing data - so the ghci examples aren't much use
06:25:57 <[exa]> eedgit: docs on hackage usually contain tiny microexamples, but just asking here is pretty useful too :]
06:26:07 <[exa]> (where do you store the data?)
06:26:50 <merijn> eedgit: Basic examples of what?
06:29:56 <eedgit> [exa] yeah that's the ghci example tho :( 
06:30:23 <eedgit> merijn Just in general, at the moment I'm struggling with returning/printing IsInfixOf
06:31:12 <eedgit> https://dpaste.org/ui1o returning `Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòChar‚Äô`
06:32:02 <eedgit> Also confused about the difference between isInfixOf and `isInfixOf` - which isn't the easiest thing to google :(
06:33:01 <[exa]> eedgit: backticks` are used for making operators out of normal functions
06:33:15 <eedgit> ah, ty
06:33:16 <[exa]> eedgit: mod 5 1 is the same as 5 `mod` 1
06:33:28 <[exa]> reverse way:   5 + 1   is the same as   (+) 5 1
06:34:19 <eedgit> Ahhh right, yeh I did learn that actually. I thought it was something specific to isInfixOf
06:35:17 <[exa]> anyway your error might be that you are confusing letters (Char) with strings ([Char]) somewhere
06:46:30 <kuribas> `view` does a right based mappend, no?
06:47:00 <kuribas> isn't there a foldOf' which does left based mappend?
06:56:03 <kuribas> is there a Monoid newtype that turns a right fold into a left fold?
07:04:08 <kuribas> Endo maybe...
07:04:51 <kuribas> and why do we have foldMap', but not fold'?
07:04:55 <kuribas> :t foldMap'
07:04:56 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:04:59 <kuribas> :t fold'
07:05:01 <lambdabot> error:
07:05:01 <lambdabot>     ‚Ä¢ Variable not in scope: fold'
07:05:01 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
07:07:08 <kuribas> :t foldOf
07:07:10 <lambdabot> Getting a s a -> s -> a
07:07:12 <kuribas> :t foldOf'
07:07:15 <lambdabot> error:
07:07:15 <lambdabot>     ‚Ä¢ Variable not in scope: foldOf'
07:07:15 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
07:09:05 <lyxia> kuribas: Data.Monoid.Dual ?
07:09:22 <Taneb> lyxia: I thought foldMap was strictness rather than symmetry
07:10:39 <kuribas> foldMap f == foldMap' f
07:10:47 <kuribas> for a lawful Monoid
07:24:29 <kuribas> maybe (Endo (<>))?
07:25:08 <kuribas> flip appEndo f $ foldMap (Endo (<>)) [a, b, c, d, e]
07:25:13 <kuribas> > flip appEndo f $ foldMap (Endo (<>)) [a, b, c, d, e]
07:25:16 <lambdabot>  error:
07:25:16 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòExpr -> Endo c‚Äô
07:25:16 <lambdabot>                    with actual type ‚ÄòEndo (a0 -> a0)‚Äô
07:25:31 <kuribas> > ($f) $ appEndo $ foldMap (Endo (<>)) [a, b, c, d, e]
07:25:35 <lambdabot>  error:
07:25:35 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòExpr -> Endo b‚Äô
07:25:35 <lambdabot>                    with actual type ‚ÄòEndo (a0 -> a0)‚Äô
07:28:22 <kuribas> flip appEndo z $ foldMap (Endo . flip (<>)) [a, b, c, d, e]
07:28:25 <kuribas> > flip appEndo z $ foldMap (Endo . flip (<>)) [a, b, c, d, e]
07:28:27 <lambdabot>  ((((z <> e) <> d) <> c) <> b) <> a
07:30:58 <kuribas> > flip (appEndo . getDual) z $ foldMap (Dual . Endo . flip (<>)) [a, b, c, d, e]
07:31:01 <lambdabot>  ((((z <> a) <> b) <> c) <> d) <> e
07:31:15 <kuribas> that's it :)
07:36:21 <Vulfe_> I can't not read 'appEndo' as 'appendo'
07:36:30 <Vulfe_> like it's some kind of incantation for putting lists together
07:46:09 <merijn> Vulfe_: Same :p
07:50:10 <exarkun> is there a better maintained GitHub client library than https://github.com/phadej/github ?  The docs are incomplete and most of the examples are broken.
08:04:21 <Axman6> I'm genuinely surprised there is no function with this type in ByteString: fromFunction :: Int -> (Int -> Word8) -> ByteString. had to hack together some nonsense using unfoldrN
08:06:48 <merijn> Axman6: That seems awfully specific, though?
08:07:19 <kuribas> Axman6: Int is an index in the bytestring?
08:07:43 <Axman6> well unlike packing a list, the bytestring can be allocated immediately at the correct size
08:07:51 <merijn> Axman6: Also, isn't that simply "BS.pack (map f (take n [0..]))"
08:08:03 <Axman6> yes, but more efficient
08:08:21 <merijn> Axman6: Sure, but my point was more "that seems like a rather unusual usecase"
08:08:41 <merijn> Axman6: I can't really think of many cases where I'd want a bytestring with contents based on an index?
08:08:48 <merijn> (or really, any case)
08:08:51 <Axman6> it's exactly the same as generate in vector
08:09:25 <Axman6> I'm creating a bytestring from the contents of a vector of (notionally) Word16
08:10:16 <Axman6> where elem i of the bytestring is elem i/2 or elem i/1 >> 1 (roughly)
08:10:46 <Axman6> i/2*
08:11:33 <merijn> Axman6: If you care about efficiency, just rip the bytestring out of the vector directly?
08:11:42 <merijn> Axman6: That's much more efficient :p
08:12:06 <Axman6> well it's a unboxed Vector Int64 (representing a vector of Word16)
08:12:13 <merijn> Axman6: Make sure you've got a Storable vector and done :p
08:12:52 <merijn> Axman6: Use vector's convert to convert to Storable vector, that's linear and copies data of fixed size once, and *then* rip the ByteString out :p
08:13:13 <merijn> Probably more efficient then your suggestion to begin with :p
08:13:36 <merijn> Axman6: I've even got the code figured out for you: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Utils/Vector.hs :p
08:13:57 <halbGefressen> Is there any way, without using other libraries, but with using language extensions, to evaluate Haskell Code from a String?
08:14:15 <Axman6> everyone loves debugging endianess problems right? :)
08:14:28 <geekosaur> halbGefressen, no
08:14:35 <merijn> halbGefressen: Eh, yes, but I'm guessing "by writing an interpreter in Haskell" doesn't count :p
08:14:38 <geekosaur> haskell is like C, not like Python
08:14:42 <merijn> geekosaur: Pfft, that's a blatant lie ;)
08:14:56 <merijn> geekosaur: All you have to do is reimplement GHC using just base :)
08:15:07 <halbGefressen> I found https://hackage.haskell.org/package/plugins-1.5.3.0/docs/System-Eval-Haskell.html
08:15:10 <Axman6> bs[0] = fromIntegral v[0]; bs[1] = fromIntegral (v[0] `unsafeShiftR` 8) etc.
08:15:25 <merijn> Axman6: Oh, I have an easy solution for that
08:15:52 <geekosaur> note also that, n matter what, you aren't able to access your current program, only a new unrelated evaluation context
08:15:55 <merijn> Axman6: It's called "everyone on a different architecture can go f themselves, because I don't get paid enough to deal with that" :D
08:15:55 <Axman6> where v :: Vector Int64, not Vector Word16
08:16:14 <Axman6> halbGefressen: call ghci? :)
08:16:46 <merijn> halbGefressen: More generally, it's impossible to give you a useful answer without knowing what you're trying to do
08:16:51 <Axman6> system "ghci" ["-e", myArbitraryHaskellCodeNothingCouldGoWrongHereRight]
08:17:05 <Axman6> probably ghc -e actualy
08:18:00 <halbGefressen> It will be fine if it is something like a macro that just expands my string to the haskell code and then compiles it
08:18:43 <merijn> halbGefressen: See, *that* sounds much more like you want Quasiquoters and/or Template Haskell :)
08:19:15 <halbGefressen> My uni has a competition where we have to write some form of watered down XML parser and I wondered if I could just cheese my way through with having like 5 tokens 
08:19:54 <merijn> halbGefressen: See here: https://www.schoolofhaskell.com/user/marcin/quasiquotation-101 (although note you probably need the preceding Template Haskell article to full get what's going on)
08:20:13 <opFez> Is there any good resources for learning how to make parsers in Haskell?
08:20:52 <merijn> opFez: The Real World Haskell chapter is pretty good. The examples are somewhat bitrotted, but the high level approach shown applies to all the various parser combinator libraries
08:21:53 <merijn> opFez: https://github.com/tssm/up-to-date-real-world-haskell/blob/master/14-using-parsec.org
08:22:20 <merijn> I think megaparsec also had a semi in-depth tutorial?
08:22:33 <merijn> https://markkarpov.com/tutorial/megaparsec.html
08:22:33 <opFez> thanks! on book.realworldhaskell.org/read it's chapter 16, is your link a more up to date version?
08:23:07 <opFez> thanks, gtg
08:23:58 <merijn> opFez: The link is an updated version, but the original should be fine (as long as you don't assume the examples to compile as-is)
09:05:06 <ezzieyguywuf> I want to change my package name. I renamed the project directory, renamed the cabal file, and tried 'cabal build', but now it's failing
09:05:41 <dminuoso> ezzieyguywuf: Nuke your dist-newstyle/ directory for good measure
09:06:17 <tomsmeding> ezzieyguywuf: also changed the name _in_ the cabal file?
09:06:27 <ezzieyguywuf> dminuoso: I did, but this could be an unrelated issue actually, I recently moved my system off an hdd onto an ssd, including my home directory and all the ~/.cabal etc.
09:06:39 <ezzieyguywuf> is it enough to just copy it over, or is there anything else that I need to do?
09:06:49 <ezzieyguywuf> tomsmeding: yes changed in there as well
09:06:56 <tomsmeding> are the paths the same, just different disk?
09:07:02 <ezzieyguywuf> tomsmeding: yes
09:07:02 <tomsmeding> or is .cabal really in a different location
09:07:35 <tomsmeding> if the paths are the same it should work, assuming that cabal isn't using hard links, which would be exceedingly strange
09:07:53 <tomsmeding> also you can delete (well, backup first) ~/.cabal if you want :p
09:08:17 <tomsmeding> also, "it's failing" -- what is failing?
09:08:46 <ezzieyguywuf> https://dpaste.com/CGTEBFYBE
09:09:43 <tomsmeding> your package's setup script somehow produces a constraint Cabal < 1.25, wtf
09:10:23 <ezzieyguywuf> here's my cabal file https://dpaste.com/E5374CYJL
09:10:55 <tomsmeding> is there a Setup.hs?
09:11:33 <ezzieyguywuf> https://dpaste.com/6SXEWMXNB
09:11:42 <ezzieyguywuf> setup.hs, autogenerated by cabal init i believe
09:11:50 <tomsmeding> I always remove that file :p
09:11:55 <tomsmeding> has never not worked yet
09:12:38 <tomsmeding> but yeah try 'mv ~/.cabal ~/.cabal-backup; rm -rf dist-newstyle/; cabal build' :p
09:14:20 <ezzieyguywuf> tomsmeding: I don't even know why it's there, I just assume cabal needs it
09:14:33 <tomsmeding> it doesn't
09:15:37 <ezzieyguywuf> dang, still fail after nuking ~/.cabal
09:15:39 <ezzieyguywuf> https://dpaste.com/BVCTVKH44
09:15:47 <ezzieyguywuf> I know the nuke worked b/c it asked me to "cabal update"
09:17:11 <tomsmeding> no dist/ folder or .ghc* file?
09:17:21 <tomsmeding> also in ~
09:17:28 <ezzieyguywuf> hmm, I'll check
09:17:40 <ezzieyguywuf> ~/.distcc, but that's different
09:17:46 <tomsmeding> also wtf, reproducing example please :p
09:17:52 <ezzieyguywuf> yes ~/.ghc
09:17:58 <tomsmeding> file?
09:18:09 <tomsmeding> I'm talking about a file like .ghc-environment-* or something
09:18:19 <tomsmeding> directory is fine
09:20:35 <ezzieyguywuf> tomsmeding: to reproduce, `git clone https://gitlab.com/ezzieyguywuf/csv_processor/ jali; cd jali; cabal build`
09:20:54 <ezzieyguywuf> tomsmeding: no I don't see any of those folders
09:21:22 <tomsmeding> hah I get the same error, so it's really something in the project, not in your configuration
09:22:13 <ezzieyguywuf> lol all I did was change the name, and add a licence and description and stuff
09:22:52 <tomsmeding> ezzieyguywuf: I think those are the problem
09:23:00 <sm[m]> something in the cabal file syntax that puts cabal into "old cabal" mode ?
09:23:27 <tomsmeding> if I remove the description: field, which overruns! (how does that even parse), then cabal starts complaining about the license (it doesn't understand MPL2.0 apparently)
09:23:33 <tomsmeding> sm[m]: probably the parse error then?
09:23:38 <merijn> sm[m]: That still makes no sense
09:23:43 <tomsmeding> if I remove also the license: field, then it makes a build plan
09:23:53 <merijn> sm[m]: Because that wouldn't incur a "Cabal < 1.25" constraint
09:24:09 <merijn> sm[m]: Cabal is backwards compatible across all previous versions
09:24:17 <merijn> (modulo bug, obviously)
09:24:47 <sm[m]> just a direction to explore.. easy enough to test (does minimizing the cabal file changes change things)
09:24:54 <tomsmeding> https://tomsmeding.com/vang/Zt6i75 with this diff it builds ezzieyguywuf 
09:25:10 <tomsmeding> or, well, it _start_ building; I didn't let it finish
09:25:12 <ezzieyguywuf> sm[m]: yea, like tomsmeding points out there's some syntax errors in my cabal file
09:25:23 <ezzieyguywuf> tomsmeding: I'll let you know if it finishes.
09:25:35 <ezzieyguywuf> but shouldn't cabal have told me "dude, parse error on description. and licence."
09:25:41 <sm[m]> There we go
09:26:00 <merijn> ezzieyguywuf: oh
09:26:03 <tomsmeding> well license it does, but somehow because of those second and third line of the description, cabal goes haywire
09:26:09 <merijn> You have MPL2.0, not MPL-2.0
09:26:29 <merijn> (although even that is legacy, I think)
09:26:45 <merijn> https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-license
09:27:23 <tomsmeding> ah it seems cabal just stops reading the file on that description line
09:27:33 <tomsmeding> if you remove everything after the description: field, the same error occurs
09:28:03 <tomsmeding> this feels like it's the classic "forgot the 'eof' after my parsec parser", but it's probably not that simple
09:28:04 <merijn> oh
09:28:07 <merijn> No
09:28:13 <merijn> The description field is a syntax error
09:28:24 <merijn> Albeit poorly detected
09:28:26 <tomsmeding> yes but why does not not report that!
09:28:32 <tomsmeding> it just stops parsing and goes with what it has
09:28:39 <ezzieyguywuf> +1 tomsmeding 
09:28:45 <ezzieyguywuf> also, merijn thank you for the link
09:28:52 <tomsmeding> ezzieyguywuf: name++ please, ircbrowse picks that up
09:28:54 <ezzieyguywuf> spdx, great another standard to know about :-P
09:28:55 <tomsmeding> for questionable benefit
09:29:01 <ezzieyguywuf> tomsmeding++
09:29:05 * tomsmeding bows
09:29:06 <ezzieyguywuf> lol
09:29:15 <ezzieyguywuf> !karma tomsmeding 
09:29:18 <merijn> it should be indented
09:29:20 <merijn> https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan/broadcast-chan.cabal#L26-L71
09:29:21 <ezzieyguywuf> is that the thing? hrm *shrug*
09:29:30 <ezzieyguywuf> something something tomsmeding++
09:29:50 <ezzieyguywuf> oh, "it should be indented" meaning the description
09:29:58 <tomsmeding> now see? I already have a karma of 2 https://ircbrowse.tomsmeding.com/nick/tomsmeding
09:30:23 <geekosaur> doesn't lambdabot also track karma?
09:30:26 <ezzieyguywuf> tomsmeding: ü§£
09:30:36 <merijn> tomsmeding: Because the old cabal format wasn't very specified and tried to be forwards compatible
09:30:46 <merijn> ezzieyguywuf: Can you try something for me?
09:30:55 <ezzieyguywuf> merijn: sure, anything for you pal.
09:31:00 <geekosaur> @list karma
09:31:00 <lambdabot> karma provides: karma karma+ karma- karma-all
09:31:02 <merijn> ezzieyguywuf: Take the broken .cabal file, change "cabal-version" and set it to 2.0
09:31:13 <merijn> ezzieyguywuf: Do you get a similar bad non-error or a more useful one?
09:31:14 <ezzieyguywuf> merijn: ok just a sec.
09:31:45 <tomsmeding> @karma-all
09:31:46 <lambdabot>  blah                 31337
09:31:46 <lambdabot>  egrep                31337
09:31:46 <lambdabot>  zgrep                31337
09:31:46 <lambdabot>  c/c                  2171
09:31:46 <lambdabot>  nobody               2000
09:31:48 <lambdabot> [6768 @more lines]
09:31:49 <merijn> At this point there's *really* no reason to write new cabal files with cabal-version prior to 2.0 (or even 3.0, really)
09:31:57 * ski would prefer seeing `karma' removed
09:32:05 <tomsmeding> that 31337 looks suspicious
09:32:30 <ezzieyguywuf> merijn: seems the same https://cabal.readthedocs.io/en/latest/cabal-package.html#pkg-field-license
09:32:40 <ezzieyguywuf> merijn: although I did ">=2.0", should I try with plain "2.0"?
09:32:56 <merijn> ezzieyguywuf: >=2.0 is a syntax error
09:33:04 <merijn> Or should be, anyway :p
09:33:12 <merijn> Did it not complain about that?
09:33:16 <ezzieyguywuf> really? it said >=1.10 before
09:33:21 <ezzieyguywuf> no it did not, I pasted the output
09:33:23 <merijn> ezzieyguywuf: Yes, for legacy reasons
09:33:37 <sm[m]> Yes, see https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-cabal-version
09:33:40 <ezzieyguywuf> changed to 2.0, same error
09:34:09 <merijn> hmm, unfortunate
09:34:50 <merijn> oh, hah ">= 2.0" is the last that still allows that
09:35:06 <ezzieyguywuf> "it is strongly recommended to avoid the legacy syntax", and yet this is what cabal init produces...
09:35:44 <tomsmeding> strongly recommended _with newer versions_ I'd assume
09:36:05 <merijn> ezzieyguywuf: Only old versions of cabal-install :p
09:36:08 <ezzieyguywuf> my cabal version is 3.2
09:36:11 <merijn> really?
09:36:18 <merijn> I'm pretty sure it defaults to 2.4 now
09:36:19 <ezzieyguywuf> yea I just checked
09:37:04 <ezzieyguywuf> just ran it again, it produced >=1.10
09:37:19 <merijn> ah, need --cabal-version to change that version, I think phadej recently fixed it to produce a more reasonable default
09:37:46 <ezzieyguywuf> lol, I came to cabal (from stack) b/c I was ttold it works!
09:38:17 <merijn> ezzieyguywuf: Well, it does work :p
09:38:26 <ezzieyguywuf> lol, yea yea, I'm just being facetious
09:38:32 <merijn> ezzieyguywuf: It's just defaulting to a stupid old default
09:38:39 <ezzieyguywuf> indeed.
09:39:06 <ezzieyguywuf> but the main issue here is the parsing issue, which remained regardless of the cabal-version number
09:39:10 <ezzieyguywuf> heck let me try 3.2
09:39:11 <sm[m]> stack is the one more likely to just work ezzieyguywuf, despite what you may hear in here
09:39:17 <merijn> I mean, 2.0 was released 3 years ago. There's really no reason to bother supporting cabal-install 1.10 :p
09:40:00 <merijn> sm[m]: That's disingenous. "Both stack and cabal-install may be more likely to work depending on an incredibly complex and nuanced set of circumstances that are nearly impossible to judge"
09:40:28 <merijn> There's plenty of workflows and things where stack sucks balls. And there's a bunch of place where cabal-install still has warts.
09:40:35 <merijn> This just in, no silver bullets for packaging
09:40:52 <sm[m]> "More likely"
09:41:35 <sm[m]> it's just my observation over many years of supporting both. I know you won't agree, that's fine :)
09:41:41 <ezzieyguywuf> hrm, so 'cabal-version 3.0' actually builds
09:41:48 <ezzieyguywuf> it identifies the error, and just skips past it
09:42:02 <ezzieyguywuf> and produces a nice warning
09:42:04 <merijn> Progress \o/
09:42:37 <merijn> So when 3.4 releases and actually defaults to 3.0 (or 3.2 or 3.4, whatever) we'll be in business :p
09:42:55 <ezzieyguywuf> now, it does not re-display the warning when I rebuild, unless I `cabal clean` first, but I suppose that's ok?
09:43:21 <merijn> ezzieyguywuf: That's because it won't rebuild unless something changed :p
09:43:29 <ezzieyguywuf> key takeaway: I'll be using `cabal-version 3.0` from here on out.
09:43:41 <ezzieyguywuf> merijn: but it should still re-parse the cabal file shouldn't it?
09:43:59 <merijn> ezzieyguywuf: It only bothers reparsing if the cabal file changed since the last run
09:44:14 <ezzieyguywuf> I mean, I get it, "why re-parse if the file hasn't changed", but here we see a good reason to do so - to make sure the user still knows there's something to be warned about
09:44:20 <ezzieyguywuf> lol jynx
09:44:47 <merijn> ezzieyguywuf: You can always run "cabal check" :)
09:44:57 <ezzieyguywuf> merijn: woah didn't know that one
09:45:31 <merijn> Which is, effectively "cabal file linting/hackage requirement check" :p
09:45:53 <merijn> Pretty sure "cabal sdist" will also rewarn
09:46:17 <ezzieyguywuf> what does sdist do?
09:46:50 <merijn> ezzieyguywuf: Creates a standalone .tar.gz of all sources and files for distribution s(ource)dist(tribution)
09:46:59 <ezzieyguywuf> oh neat
09:47:01 <merijn> for upload to, say, hackage or whatever
09:49:33 <ezzieyguywuf> should I even use "cabal init"? or is there a newer/better way to set up a new project dir?
09:50:11 <merijn> ezzieyguywuf: "cabal init --interactive --cabal-version=3.0" (those flags should be default in 3.4 iirc) is fine. Personally I just copy one of my existing ones and edit it :p
09:50:29 <koz_> I have a cookiecutter template.
09:50:38 <ezzieyguywuf> yum, cookies
09:50:39 <koz_> (which also sets up everything else)
09:51:12 <ezzieyguywuf> merijn: maybe I have something over-riding the defaults? where would I check?
09:51:40 <merijn> ezzieyguywuf: You don't have 3.4, because it's not released yet ;)
09:51:56 <merijn> It's in alpha until GHC 9.0 comes out
09:52:08 <ezzieyguywuf> lol ok
09:52:22 <ezzieyguywuf> I can edit my ~/.cabal/config it looks like
09:52:32 <maerwald> 3.4 works great though
09:52:35 <merijn> ezzieyguywuf: yeah
09:52:46 <merijn> ezzieyguywuf: Also, wanna get your mind blown further wrt cabal? :p
09:53:13 <ezzieyguywuf> merijn: lol, sure shoot
09:53:13 <maerwald> merijn: that's easy... run `cabal build --help` -> mind blown :D
09:53:23 <ezzieyguywuf> maerwald: nice.
09:53:26 <merijn> ezzieyguywuf: Try "cabal user-config diff" and "cabal user-config update" for updating to the latest version while keeping your local edits to the default :p
09:54:12 <merijn> Pretty sure, like, 5 people are aware of "user-config diff" :p
09:54:38 <ezzieyguywuf> what did the diff even do?
09:54:53 <merijn> It just reports which settings you have set to something *other* than the default
09:55:04 <ezzieyguywuf> hrm interesting, so it pulled down from the cloud the latest defaults, but kept anything that I had hand-changed?
09:55:19 <ezzieyguywuf> merijn: it was blank, does that mean I just have defaults?
09:55:28 <ezzieyguywuf> b/c I totally like 2 seconds ago changed the init defaults, lol.
09:55:44 <merijn> Pretty much (except I think the config format is embedded in cabal executable)
09:55:45 <ezzieyguywuf> yea and now it changed it back
09:55:56 <ezzieyguywuf> mind blown: "Hey this didn't work"
09:55:56 <merijn> ezzieyguywuf: Which setting was that?
09:56:07 <ezzieyguywuf> merijn: -- interactive.....
09:56:08 <ezzieyguywuf> oh wait
09:56:10 <ezzieyguywuf> -- = comment
09:56:13 <merijn> :)
09:56:19 <ezzieyguywuf> I can't keep track of all these different config formats
09:57:17 <ezzieyguywuf> neat! where does it store the diff?
09:57:20 <ezzieyguywuf> somewhere in ~/.cabal?
09:57:59 <merijn> It just output the diff to stdout
09:58:32 <ezzieyguywuf> ah, so I don't really need to run diff
09:58:39 <ezzieyguywuf> I could just run update and it will "do its thing'
09:58:39 <monochrom> Hell, cabal-install has a whole lot of FOSS licenses embedded. :)
09:58:50 <ezzieyguywuf> monochrom: ?
09:58:59 <merijn> ezzieyguywuf: Correct, but usually you prefer not blindly crush your existing files ;)
10:02:15 <monochrom> I think usually "cabal user-config update" is harmless.
10:02:56 <merijn> monochrom: Sure
10:03:15 <merijn> monochrom: Compiling with GHC is also usually harmless. Except when it deletes files with type errors ;)
10:03:39 <jle`> yours is only deleting the ones *with* type errors? :O
10:04:07 <merijn> Well, guys, wish me luck
10:04:28 <merijn> I'm diving into the hell that is "poorly documented YAML for CI configuration"
10:04:35 <Sonolin> is there a function of `(Monad m, k) => m (k a) -> k (m a)` ?
10:04:37 <jle`> thoughts and prayers
10:04:39 <merijn> Tell my family I loved them
10:04:44 * ezzieyguywuf prays for merijn 
10:04:51 <merijn> :t sequence -- Sonolin
10:04:51 <ezzieyguywuf> merijn: which CI?
10:04:52 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:04:53 <jle`> Sonolin: i think that's a kind error?
10:05:07 <ezzieyguywuf> lol, as opposed to a mean error
10:05:17 <merijn> ezzieyguywuf: GitHub Actions
10:05:19 <jle`> errors can be rough
10:05:36 <jle`> is k a constraint?
10:05:38 <Sonolin> perfect thanks merijn
10:05:44 <Sonolin> jle` yea not exactly my type signature
10:05:54 <monochrom> Oh here is how harmless it is: "Renaming /home/trebla/.cabal/config to /home/trebla/.cabal/config.backup"
10:05:55 <Sonolin> but I was looking for something that spec. works for maybe
10:06:00 <ezzieyguywuf> dang, didn't know github had built-in ci, I thought everyone just used travis
10:06:03 <merijn> ezzieyguywuf: I ran out of Travis minutes for the months in like half a day. But GitHub Actions' YAML is equally poorly specified as Travis
10:06:15 <jle`> Sonolin: ah, so like m (Maybe a) -> Maybe (m a) ?
10:06:21 <monochrom> So you won't lose your old config file in case "update" isn't what you want.
10:06:33 <merijn> ezzieyguywuf: Travis has been going down the drain for ~2 years and now limits the free minutes to something unreasonably short
10:06:52 <Sonolin> jle` other way around but yea
10:07:04 <Sonolin> sequence works since maybe is traversable
10:07:10 <jle`> ah, Maybe (m a) -> m (Maybe a)
10:07:43 <Sonolin> yea I should really make a custom type/exceptions or something for this instead of maybe but it works for now
10:07:50 <merijn> Sonolin: Other people who looked at "sequence" were also interested in:
10:07:53 <merijn> :t traverse
10:07:55 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:08:06 <merijn> </Amazon recommendation"
10:08:12 <merijn> s/"/>/
10:08:21 <jle`> does that come with haskell prime?
10:08:22 <monochrom> Oh w00t there is an "init" section that has the defaults for "cabal init".  If you hate the default "cabal-version: 1.10", you can change it there.
10:08:44 <merijn> monochrom: "iz fixd in head"
10:08:55 <ezzieyguywuf> if I have `n :: Int`, how can I produce a stringe of n spaces?
10:09:05 <jle`> > replicate 10 ' '
10:09:07 <lambdabot>  "          "
10:09:11 <ezzieyguywuf> jle`: dope thanks
10:09:20 <merijn> monochrom: https://lambdacats.github.io/fixed-in-head/
10:10:04 <monochrom> Oh hey I have been looking for lambdacats since the last lambdacats was gone!
10:13:23 <Sonolin> merijn that works even better! One less fmap, thanks :)
10:15:50 <merijn> monochrom: Fear not, I already updated my lambdacats.org forward to the right place :p
10:16:48 <monochrom> aliased lambdacats
10:17:47 <merijn> lambdacats iz robust modulo teh alpha-renaming!
10:18:00 <monochrom> haha
10:18:41 <merijn> And I just noticed all my domains were still registered to my mom's house, 3 addresses ago >.>
10:18:48 <xerox_> which version of ghc corresponds to base-4.9.0.0 ?
10:19:11 <koz_> 8.0 I think?
10:19:32 <monochrom> "ghcup list" reports 8.0.2 -> 4.9.1.0
10:19:38 <xerox_> appreciate it
10:19:42 <merijn> @where ghc-base
10:19:42 <lambdabot> I know nothing about ghc-base.
10:19:48 <merijn> @where+ ghc-base https://wiki.haskell.org/Base_package
10:19:48 <lambdabot> It is stored.
10:20:21 <merijn> Hot take: GHC 9.0 should switch to "base-9.0" so we can forget about this nonsense
10:20:22 <maerwald> merijn: there's a better page on gitlab
10:20:46 <koz_> merijn: That's a rather lukewarm take. Sensible even!
10:20:47 <maerwald> https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history
10:20:47 <merijn> I mean, nobody else is using base right now and if someone wants to start using it a version bump is hardly going to kill that
10:20:50 <xerox_> nice even got a date, my buddy got a 2016 ghc from his distribution, yikes!
10:21:05 <koz_> xerox_: Use ghcup, not your distro.
10:21:08 <monochrom> Hotter take: stack LTS version numbers should be GHC version numbers too.
10:21:16 <koz_> This counts double on Debian and Arch.
10:21:16 <xerox_> koz_: I'm steering him into that direction yes
10:21:29 <koz_> monochrom: That's also tepid at best.
10:21:39 <koz_> It's not like consistency is a good thing or anything...
10:21:54 <koz_> It's only hot because Snoyman would want your head on a pike for daring to suggest such a sensible thing.
10:22:00 <maerwald> haha
10:23:31 <xerox_> how is this possible: https://www.stackage.org/haddock/lts-16.24/base-4.13.0.0/Prelude.html says (<>) was introduced in 4.9.0.0 and the Base_package page says "8.0.1 (May 2016) 4.9.0.0", buddy has got 8.0.2 and there is no (<>)
10:24:05 <jle`> maybe -XNoImplicitPrelude ?
10:24:21 <koz_> xerox_: Yeah, some context.
10:24:27 <jle`> er also (<>) was only "recently"-ish added into Prelude
10:24:30 <monochrom> Perhaps (<>) was not in Prelude back then?
10:24:51 <xerox_> then what does it mean when the Prelude haddock page there says it was introduced in that version
10:24:51 <geekosaur> right it used to be Data.Monoid
10:25:03 <jle`> xerox_: that annotation is with the Semigroup typeclass
10:25:24 <monochrom> "in base" could mean "in Data.Monoid.Not.In.Prelude.Utilities.Hairsplit"
10:25:40 <jle`> but also that just says when the semigroup typeclass was defined at all, not necessarily where it was exported from
10:25:43 <xerox_> that's my favorite module
10:25:44 <jle`> it's actually a manual annotation
10:25:49 <jle`> which may be kind of un-ideal
10:26:11 <jle`> you can basically think of it as words someone manually added to the documentation of the SEmigroup typeclass, which was originally not in Prelude
10:26:24 <jle`> but once you export something from a module, it displays the documentation body as-is
10:26:42 <jle`> the "The class of semigroups ..." text, that is
10:26:45 <monochrom> Hottest take: Demolish the institution of modules.
10:27:19 <koz_> monochrom: Now we're getting warmer. :P
10:27:23 <jle`> though it looks special, it's basically text someone manually added to that body. so haddock doesn't know enough about it to realize that it actually means something
10:27:34 <merijn> monochrom: I like information hiding!
10:27:39 <merijn> monochrom: Except when I don't
10:27:52 <unclechu> hey. i‚Äôm trying to convert Nat to Symbol, defined this type family instance:
10:27:52 <unclechu> type instance TShow (x ‚à∑ Nat) = If (CmpNat x 10 ‚â° 'LT) (TShowNat x) (TShow (Div x 10) ‚ãÑ TShowNat (Mod x 10))
10:27:58 <unclechu> for some reason recursive call of TShow gives an infinite recursion. i used separate type family to overcome this:
10:27:58 <unclechu> type family TShowNat' (Œ± ‚à∑ Nat) (Œ≤ ‚à∑ Ordering) ‚à∑ Symbol
10:28:04 <merijn> unclechu: oof...
10:28:05 <unclechu> and just calling it like this: TShowNat' x (CmpNat x 10)
10:28:15 <merijn> RIP your sanity :p
10:28:18 <unclechu> does anyone know why is it happening?
10:28:54 <unclechu> merijn: did i do something wrong? is there any simpler way to convert Nat to Symbol?
10:29:10 <jle`> unclechu: what are you calling it with?
10:29:13 <unclechu> i just wrote TShowNat that has patterns from 0 to 9
10:29:16 <merijn> unclechu: Well, what you appear to be doing wrong is attempting to write Idris in Haskell :p
10:29:41 <jle`> oh i just saw
10:29:50 <monochrom> I wanted to say that too, but I guess it is unwelcome.
10:30:10 <monochrom> The "helpfulness" police gives me trauma.
10:31:30 <merijn> monochrom: https://i.imgur.com/2VaBYJ1.png
10:31:54 <unclechu> merijn: about ‚Äúwriting Idris in Haskell‚Äù, may i tell you a secret that idris was originally written in haskell? 
10:32:08 <merijn> unclechu: I am well aware of this
10:32:10 <monochrom> and Hugs, C
10:32:33 <merijn> unclechu: But the Idris compiler was written in Haskell without Idris style type level programming
10:32:48 <merijn> monochrom: Sometimes helpfulness is telling people to stop jamming a fork in their eye :)
10:33:15 <unclechu> merijn: okay then, buy is it illegal to have some fun?
10:33:24 <geekosaur> you call this fun?
10:33:31 <merijn> unclechu: Depends, are you having fun debugging this? :)
10:33:37 <monochrom> I know right?  That's why I don't call them helpfulness police, I call them "helpfulness" police, they use the wrong definition.
10:33:38 <merijn> If yes, by all means go ahead
10:33:56 <merijn> But there's probably like 5 people who understand the behaviour of what you're doing :)
10:34:12 <unclechu> merijn: i just wrote another type family in a next minute i found out this ‚Äúbug‚Äù and solved it for me
10:34:12 <merijn> So not many people can help you figure out why it's going wrong
10:34:22 <unclechu> just asking whether i‚Äôm missing something
10:36:07 <monochrom> I just want to point out that "the Idris compiler was written in Haskell" is irrelevant.
10:36:26 <dolio> Lean is written in C++.
10:36:42 <monochrom> In principle an Idris compiler could have been written in Javascript.
10:36:43 <merijn> Haskell is written in Lazy ML!
10:36:44 <geekosaur> that's misparsing what merijn said
10:36:51 <merijn> Oh wait, it's no longer 1989
10:37:03 <unclechu> monochrom: it was a joke anyway, don‚Äôt take this argument serious
10:37:09 <monochrom> The type system of Javascript would have nothing to do with the type system of Idris, even when using this compiler.
10:37:19 <monochrom> Ah then sorry! Hahahaha
10:39:20 <monochrom> ObOnTopicButOffTopic I read that someone wrote a virtual machine in javascript and ran Windows 95 in a web browser.
10:40:46 <Rembane> monochrom: How many times can you do that recursively before the computer grinds to a halt? 
10:41:12 <merijn> monochrom: pfft, who cares about Windows 95 when C&C runs in the browser?
10:41:38 <monochrom> haha
10:42:58 <monochrom> I think more likely the first bottleneck is which web browser compatible with Windows 95 understands the version of javascript used in writing that virtual machine.
10:44:19 <kupi> if both a and b and c is >0 then a `div` (b * c) == a `div` b `div` c is always true?
10:44:51 <monochrom> Perhaps you could ask Quickcheck to try?
10:52:50 <jle`> @check \x y z -> (a > 0 && b > 0 && c > 0) ==> (a `div` (b * c) == a `div` b `div` c)
10:52:53 <lambdabot>  *** Failed! Falsifiable (after 1 test):
10:52:53 <lambdabot>  () () ()
10:53:00 <jle`> heh
10:53:02 <jle`> wait what
10:53:05 <jle`> oh
10:53:14 <jle`> @check \a b c -> (a > 0 && b > 0 && c > 0) ==> (a `div` (b * c) == a `div` b `div` c)
10:53:17 <lambdabot>  +++ OK, passed 100 tests.
10:53:25 <jle`> i say ship it
10:57:37 <monochrom> Now why would that be true?
11:05:37 <monochrom> Ah I see now. "It is obvious."
11:05:58 <monochrom> If you're interested, let me know.
11:07:44 <idnar> monochrom: I'm interested
11:08:40 <kupi> me too
11:09:50 <Vulfe> Is there a particularly idiomatic way of writing FromJSON instances for Aeson where you're just matching a handful of strings? this feels like a very common use case, so I suspect I'm missing something
11:10:23 <Vulfe> e.g. I write something like parseJSON = withText "MyType" $ \t -> case t of "a" -> pure A ...
11:11:02 <idnar> > 5 `div` 2
11:11:05 <lambdabot>  2
11:17:07 <monochrom> idnar, kupi: https://paste.tomsmeding.com/YABx7oIp
11:22:40 <idnar> monochrom: aha!
11:23:21 <monochrom> It is not obvious. But it works out pleasantly.
11:23:43 <monochrom> The remainders fit together so nicely. Who would have thought of that.
11:25:55 <Vulfe> didn't expect to learn something new about the Euclidean algorithm today, but here we are
11:27:40 <kupi> thanks a lot
11:31:07 <tomsmeding> alternative way to see the same thing: if 'a' is a mixed-base number in base [infty, b, c], then "clearly" the result holds
11:31:14 <tomsmeding> but that's dependent on knowing that mixed-base numbers work :p
11:33:08 <jle`> a/(b*c) = a * 1/b * 1/c = (a/b) * 1/c = (a/b)/c
11:33:53 <jle`> my joke landed flat because i forgot to pseudo-justify a/(b*c) = a * 1/(b*c)
12:03:10 * ski . o O ( <https://haskell-channel-logs.blogspot.com/> )
12:03:51 <monochrom> haha IRC->blogosphere gateway
12:04:29 <monochrom> Will someone also attach a speech synthesizer and make a podcast? >:)
12:05:22 <monochrom> Hottest take: Twitch.
12:06:10 <koz_> 'some' is 'one or more' right?
12:06:16 <monochrom> yes
12:06:34 <dminuoso> I cant seem to remember every time.
12:06:39 <monochrom> many (char 'x') = x* , some (char 'x') = x+
12:06:42 <dminuoso> It's hoogle every time I want to use some/many.
12:07:15 <monochrom> Applicative is awesome, Alternative is manysome.
12:07:26 <dminuoso> I have an idea
12:07:30 <dminuoso> "some" sounds a bit like "one"
12:07:45 <monochrom> "for some x" is at least one x
12:07:53 <dminuoso> and "for many x"?
12:08:15 <monochrom> I don't have a nice story for many.
12:08:16 <jle`> many sounds like more than some
12:08:38 <xerox_> s/m//
12:08:45 <monochrom> Except that I rote-memorize "there are two of them, many and some, I know what some means, so the other possibility must be many"
12:08:46 <dminuoso> jle`: but that "more" is rather on the upper bound of things, right?
12:08:55 <jle`> yeah
12:09:07 <jle`> i was sort of making an argument about why the names don't fit for me :|
12:09:23 <koz_> Honestly, those names confuse me constantly.
12:09:35 <monochrom> If I had my say I would call it "Kleene star" or "star".
12:09:42 <dminuoso> I'll just try to remember "someone"
12:09:56 <xerox_> kleene 'x'
12:09:59 <monochrom> As usual, intuitive names are meaningless, mathematical terminology is meaningful.
12:10:32 <dminuoso> Is there a corresponding name for +?
12:10:54 <koz_> dminuoso: kleene+
12:11:06 <jle`> xerox_: kleenex
12:11:12 <koz_> LOL
12:11:13 <monochrom> hahaha
12:11:16 <xerox_> exactly (:
12:11:20 <koz_> So much wordplay.
12:11:23 <koz_> Very Edward.
12:11:25 <jle`> oh that was your joke
12:11:30 <jle`> nice heh heh
12:11:38 <monochrom> I haven't heard of a mathematical name. But "some" is a pretty good name in this case.
12:11:40 <dminuoso> koz_: I found it confusing.
12:11:45 <dminuoso> :>
12:12:15 <monochrom> "plus" is not bad either.
12:12:15 <xerox_> ah right 'any' is taken, another way to go to get the meaning of 'many'
12:12:45 <monochrom> And guess what, "any" means some.
12:12:47 <dminuoso> monochrom: plus 'a' `mplus` x
12:12:53 <jle`> kleenet = one or more kleenex
12:13:25 <monochrom> To Hell with English.
12:13:31 <dminuoso> What about the common idiom of just suffixing with 1.. it's common enough in parser combinators
12:13:35 <dminuoso> with things like sepBy and sepBy1
12:14:00 <dminuoso> Could have some and some1, giving us a nice pun as well
12:14:03 <monochrom> +1
12:14:14 <mivael> hello all!  Is there a web resource for pasting code/errors to #haskell which would not require registration? (please correct me if I'm wrong, it seems that gist.github.com mentioned in topic does require registration to create a new gist)
12:14:21 <dminuoso> @where paste -- mivael 
12:14:21 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
12:14:38 <mivael> thans
12:15:58 <dminuoso> I guess the only unreasonable thing about my proposition is that it would break code left and right. So `many` and `many1` would be more reasonable
12:16:08 <dminuoso> But that has no pun. :(
12:16:19 <dminuoso> any and any1 would have been nice
12:16:48 <dminuoso> In unrelated news, would you oppose to Data.Traversable re-exporting traverse_?
12:17:06 <dminuoso> I feel annoyed every time. :(
12:17:42 <jle`> but is it not a lie
12:17:52 <lortabac> honestly I think they are both common enough to deserve a place in Prelude
12:18:13 <dminuoso> jle`: Is it? Traversable is a superclass of Foldable, I dont mind it re-exporting it a few Foldable primitives.
12:18:21 <dminuoso> Or. Subclass I guess.
12:18:40 <monochrom> See also: <monochrom> Hottest take: Demolish the institution of modules.
12:18:51 <dminuoso> Put everything into Prelude?
12:19:59 <monochrom> More seriously and feasibly, I am OK with Data.Traversable re-exporting traverse_ and generally Foldable stuff.
12:20:17 <monochrom> But I use mapM_ anyway, which is in Prelude.
12:20:26 <koz_> jle`: Does your all-singing, all-dancing non-empty container library have some equivalent of '(findMin nes, deleteMin s)'?
12:20:47 <dminuoso> Oh wait. mapM_ is in prelude? Strange that traverse_ is not then
12:20:55 <merijn> dminuoso: Historical artifact
12:21:01 <koz_> dminuoso: Yeah, it's my biggest Data.Foldable import.
12:21:10 <monochrom> I support traverse_ going into Prelude too.
12:21:11 <merijn> koz_: You mean just containers?
12:21:59 <koz_> merijn: I meant specifically jle's library for non-empty containers.
12:22:19 <jle`> i think it's the same as for containers
12:22:36 <jle`> but it depends on what you want the relationship between nes and s to be
12:22:44 <koz_> jle`: Spelling.
12:22:49 <koz_> I meant something of type
12:22:57 <koz_> NESet a -> (a, Set a)
12:23:08 <jle`> deleteFindMin i think
12:23:16 <koz_> Oh, nice, thank you!
12:23:20 <koz_> That's perfect.
12:23:46 <jle`> np! yeah when i can i try to keep the same name as containers has
12:24:54 <monochrom> The Haskell Library Committee is a bicarmeral, multiple-party, pertually minority-government governing body that takes hairsplitting to the next level. It will take another 30 years before it reaches a consensus to add traverse_ to Prelude. This is not strange. >:)
12:26:03 <dminuoso> monochrom: So what you mean by that is, if the automotive industry has some vast interest in that happening, it will happen silently
12:26:15 <monochrom> haha
12:26:46 <maerwald> Add traverse_ to 26262
12:27:31 <maerwald> Only if the government forces them, it will eventually land in Prelude
12:28:19 <pie_> are there possibly more obscure alternative designs to REST APIs that I should look at?
12:28:40 <maerwald> gRPC
12:28:43 <monochrom> CGI
12:28:48 <doct0rhu> Greetings, I asked about how to make docs of private items last night/(earlier this morning?)
12:28:49 <dminuoso> lol
12:29:11 <doct0rhu> I later found a solution to make this a bit easier
12:29:11 <doct0rhu> https://paste.tomsmeding.com/siEaStgC
12:29:56 <doct0rhu> I'm new to haskell and it's my first project. (configuring xmonad)
12:30:04 <dminuoso> pie_: You want more obscure, you could just go plain RPC.
12:30:41 <doct0rhu> I want to contribute to `xmoand-contrib` but sadly it doesn't work with my version of `haskell-language-server`.
12:32:16 <doct0rhu> It complained that `ghcide` was compiled with a different `ghc` version...
12:32:35 <koz_> pie_: Also XMPRPC is a thing.
12:32:41 <doct0rhu> >  ghcide compiled against GHC 8.8.2 but currently using 8.8.4
12:32:41 <doct0rhu>   This is unsupported, ghcide must be compiled with the same GHC version as the project.
12:32:44 <koz_> s/XMP/XML/
12:32:44 <lambdabot>  error:
12:32:44 <lambdabot>      Variable not in scope: ghcide :: t0 -> t1 -> t2 -> t3 -> b0 -> cerror: V...
12:32:44 <lambdabot>      ‚Ä¢ Variable not in scope: against
12:33:10 <dminuoso> doct0rhu: Yes, you must use the same GHC version.
12:33:22 <doct0rhu> I actually have installed GHC 8.8.2
12:33:26 <pie_> dminuoso: not obscure is also fine :p
12:33:51 <dminuoso> pie_: It depends on what you do, really.
12:34:02 <dminuoso> You could write a wireprotocol directly ontop of TCP
12:34:33 <dminuoso> The main benefit of going through HTTP (say via JSON in HTTP or gRPC) is that session/authentication is mostly done for you already.
12:34:34 <pie_> that doest give me any design principles though
12:34:43 <dminuoso> At the cost of shoving your protocol through a different semantic protocol
12:34:52 <pie_> (well im not sure REST does eitherm, i just started looking around)
12:34:54 <mivael> Could anyone give me 'some' (not 'many') hints in troubleshooting this?  https://paste.tomsmeding.com/KQAIlolF    Why it fails with 'lines' but works with 'const'?   (I'm not in control of the managing program, I submit this code to them, get my stderr and their replies to my output. I'm pretty sure that their inputs do not change from run to run.)
12:35:05 <doct0rhu> I probably didn't configure something right because when I run `haskell-language-server-8.8.2` I saw things like `> Build profile: -w ghc-8.8.4 -O1
12:35:05 <doct0rhu> `
12:36:22 <dminuoso> pie_: design principles.. not sure what you are looking for example
12:36:49 <dminuoso> But if you want cool and sleek ideas, check out typed-protocols.
12:37:12 <koz_> dminuoso: Link?
12:37:18 <koz_> mivael: Is this, perchance, homework?
12:37:18 <dminuoso> https://input-output-hk.github.io/ouroboros-network/typed-protocols/Network-TypedProtocol.html
12:39:03 <mivael> koz_: not a homework, just a hobby thing (thhis one, if you are interested: https://www.codingame.com/multiplayer/optimization/search-race)
12:39:09 <doct0rhu> well you know what.. I solved this with `ghcup set 8.8.2`....
12:39:20 <koz_> mivael: OK, thanks. Had to ask.
12:40:09 <dminuoso> mivael: I cant quite decipher what the comments denote exactly.
12:43:13 <mivael> dminuoso: in short, my code works fine but it gets a timeout with f1...  in f2 I just const-ed the input I get from the managing program
12:43:34 <mivael> * works fine with f2
12:45:04 <geekosaur> I'm going to guess the problem is buffering
12:45:14 <geekosaur> look up hSetBuffering
12:46:21 <mivael> geekosaur, thanks!
12:46:42 <pie_> dminuoso: a'ight
12:56:08 <doct0rhu> well.. having "ghcup set 8.8.2" is not good enough for me. I tried to use `cabal.project.local` to set project ghc to 8.8.2 instead but haskell-language-server doesn't respect that setting
12:59:39 <monochrom> <Vent> Gosh, one bug report attempt leads to another, with non-tail recursion, no?
13:00:17 <monochrom> I found out that "ghcup install cabal" makes the cabal-install exe world-writable, so I want to report that.
13:00:36 <merijn> doct0rhu: haskell-langague-server is tied to a specific GHC it's compiled with
13:00:40 <monochrom> gitlab.haskell.org offers "sign in with github", so I try that.
13:01:00 <monochrom> It results in "500". So now I also have a bug report for gitlab.haskell.org...
13:01:08 <monochrom> </Vent>
13:01:49 <doct0rhu> @merijn, thanks I know that. I installed hls via ghcup and it's supposed to install hls for various ghc versions
13:01:49 <lambdabot> Unknown command, try @list
13:02:18 <maerwald> monochrom: yeah, that's software...
13:02:34 <doct0rhu> merijn, thanks I know that. I installed hls via ghcup and it's supposed to install hls for various ghc versions
13:03:18 <maerwald> with cabal, hls fails to pick the correct ghc version. I haven't seen this problem with stack
13:03:48 <doct0rhu> but actually `xmonad-contrib` supports stack too
13:04:04 <monochrom> I guess I'll fall back to registering on gitlab.haskell.org independent of my github.com account. It makes more sense in the long term anyway.  But after afternoon tea.
13:04:11 <maerwald> I use (if ever) hls via stack cradle and use cabal for my normal workflow
13:05:02 <doct0rhu> the .gitignore has cabal.project.local and cable.config so I think they are the only two files I can specify a ghc version
13:06:15 <maerwald> monochrom: what happens with oauth, when github locks your account?
13:06:15 <doct0rhu> and I've both of them specified ghc-8.8.2 but hls still cannot get the right ghc version..
13:06:15 <monochrom> Someone once asked me "why don't you install hls" like I committed a crime. I now know why I didn't install hls.
13:06:39 <doct0rhu> even after I use haskell-language-server-8.8.2 instead of haskell-language-server-wrapper
13:09:03 <maerwald> monochrom: and before you ask "why"... that's the reason ghcup is now on gitlab and not github 
13:09:06 <maerwald> :D
13:09:28 <monochrom> Don't worry, I don't mind where it's hosted.
13:09:51 <monochrom> It's just one of those rare murphy-law days.
13:09:58 <maerwald> (they have a spam detection that sometimes triggers and will get your account locked and ALL your repos and comments hidden everywhere)
13:11:29 <monochrom> I hate humanity.
13:11:58 <monochrom> https://www.smbc-comics.com/comic/like-2
13:22:43 <tomsmeding> "it's obvious"
13:22:56 <hekkaidekapus> doct0rhu: Take a look at #haskell-ide-engine
13:24:16 <doct0rhu> hekkaidekapus, thanks!!
13:24:32 <hekkaidekapus> np
13:25:58 <mivael> geekosaur, it works!  Thanks again!  As monochrom suggested yesterday, I was so concerned with laziness that missed the obvious buffering things...   https://paste.tomsmeding.com/jaZxQWNb
13:38:22 <monochrom> I think you can safely use LineBuffering, which is a good middle ground between efficiency and responsiveness.
13:39:53 <geekosaur> given use of lines/unlines, yes, I figured LineBuffering was appropriate
13:46:38 <monochrom> OK, registering on gitlab the manual way is a 500 too.
13:46:49 <monochrom> s/gitlab/gitlab.haskell.org/
13:46:54 <merijn> monochrom: Sign from the gods :p
13:47:03 <monochrom> Does #haskell-infrastructure exist?
13:47:25 <monochrom> Bah I'll just try.
13:49:32 <zgrep> <tomsmeding> that 31337 looks suspicious <-- Yes, I am suspicious.
13:50:12 <monochrom> 31337 is a prime number.
13:51:48 <tomsmeding> aeson requiring more than 2GB to build wasn't a bug, right? no it wasn't
13:52:07 <monochrom> Not a bug.
14:06:42 <llagi1234> Hi
14:08:54 <cptwunderlich> Hi everyone! I'm in a bit of a pickle, maybe someone can help:
14:09:24 <llagi1234> Bye
14:09:26 <cptwunderlich> I have a function `Something -> [Foo a]` that is used with other, similar functions. I would like to add a concrete element for a
14:09:43 <cptwunderlich> e.g., [Foo Bar]
14:10:06 <cptwunderlich> And I get an error bc. "rigit type variable" etc
14:10:25 <c_wraith> that sounds like you're trying to make them concrete in a context where they are required to be polymorphic
14:10:31 <cptwunderlich> Does anyone know any way to remedy this? (shady is ok, it's for debugging)
14:10:31 <monochrom> Perhaps your function type should be Something -> [Foo Bar]
14:11:05 <cptwunderlich> It is a polymorphic function, a bunch of them, operating on a list. I Know the concrete type and I would like to inject a few elements for debugging only
14:11:23 <cptwunderlich> so maybe something with "coerce" would do, but I have never touched that stuff 
14:11:24 <ski> cptwunderlich : `foo :: Something -> [Foo a]' promises to the caller to work for all types `a'. not just `Bar'. so if caller picks `a' to be `Bool', then your `Foo Bar' elements doesn't have type `Foo Bool', doesn't work
14:12:01 <cptwunderlich> Yes, I realized that. 
14:12:08 <ski> perhaps you can pass in the debug element, or a list of them, as separate parameter(s) ?
14:12:11 <cptwunderlich> I'm asking for an emergency loop-hole ^^ For one time debugging only
14:12:13 <monochrom> I don't understand "debug by injecting elements" if the production version would never inject similar elements.
14:12:44 <cptwunderlich> It's a code generator, that can emit code for different platforms - but I know It's x86_64 bc. that's what I'm using and working on
14:12:45 <c_wraith> cptwunderlich: unsafeCoerce is the only emergency loophole
14:12:57 <cptwunderlich> great, I will check it out. thanks
14:12:58 <monochrom> I can understand debugging messages. I don't understand fictional debugging data that has no chance of happening in reality. 
14:13:13 <cptwunderlich> I want to emit ASM COMMENT instructions
14:13:17 <cptwunderlich> But they are platform specific
14:13:20 <c_wraith> cptwunderlich: it *will* break your program.  you can be assured of that.
14:13:32 <monochrom> I am not telepathic.
14:13:32 <cptwunderlich> It will not be commitet or make it into production
14:13:35 <cptwunderlich> Promised ;)
14:14:07 <cptwunderlich> monochrom Didn't assume that, tried to ask a question with minimal context. You asked, I gave more details. 
14:14:10 <c_wraith> It's the bad kind of unsafe, where things seem to work, right up until you get corrupted data at runtime in seemingly-unrelated places
14:14:20 <merijn> See, the problem is that there is no emergency "loophole"
14:15:00 <merijn> There's unsafeCoerce, but that's not so much "opening an emergency loophole" and more "opening an emergency wormhole the size of the galaxy and letting Lovecraftian eldritch horrors into your address space"
14:15:46 <monochrom> The type Something->[Foo a] is problematic in the first place. Unless Foo a has some data constructors that are independent of a.
14:15:55 <c_wraith> a crash is the *good* case when using unsafeCoerce
14:17:09 <monochrom> For example if I promise "xxx :: [Maybe a]" then you can be pretty sure that here are the only non-trolling possibilities: [], [Nothing], [Nothing, Nothing], [Nothing, Nothing, Nothing], ..., [Nothing, Nothing, ... infinite list]
14:17:37 <monochrom> It cannot possibly be [Just 1].  It cannot possibly be [Just True].
14:18:16 <monochrom> Since in production code it cannot be [Just 1], what good is "testing" with [Just 1]? What would you learn that would be relevant to reality?
14:18:22 <cptwunderlich> Thanks, it works (well compiles). I realize that this is a big no-no, that's why I have never touched the unsafe stuff so far, but in this case it's justified, promise ;)
14:18:48 <merijn> RIP your sanity
14:18:50 <c_wraith> unsafeCoerce tends to always compile.  that's the problem with it. :)
14:19:16 <monochrom> And if you're open to trolling, here are some trolling possibilities: [Just undefined], [Just undefined, Just undefined], ...
14:20:08 <merijn> cptwunderlich: Well...at least the rest of your evening will be...interesting :)
14:20:31 <monochrom> This is why I'm against "Haskell needs more evangelism and adoption".
14:20:51 <cptwunderlich> merijn I've been trying to debug this for 3 days, so it can only get better ;)
14:21:03 <monochrom> No, I don't what the hacky-clutchy people to adopt Haskell. They would ruin everything.
14:21:20 <merijn> cptwunderlich: hah
14:21:23 <cptwunderlich> If I can have some COMMENT pseudo-instructions instead of staring at a see of assembly, that might clarify some things
14:21:23 <monochrom> I want people who respect parametric polymorphism to adopt Haskell.
14:21:30 <merijn> cptwunderlich: You're about to get a bad awakening I fear :)
14:27:11 <Unicorn_Princess> are https://github.com/timbod7/haskell-chart/wiki and https://diagrams.github.io/ still the recommended ways to do basic graphics/plotting in haskell, or should i be using something else? and if you happen to know of something comparable for c++ or rust, i'd also be interested. no specific application in mind however.
14:28:36 <ski> cptwunderlich : perhaps your `Something' type actually involved `a' as well ..
14:28:51 <monochrom> or the Foo type should not.
14:29:08 <ski> (or perhaps `Foo a' involved `a' contravariantly, or perhaps involving a GADT where the index involved `a')
14:29:14 <monochrom> What is polymorphism doing here for code generation anyway.
14:29:16 <cptwunderlich> Well, something is not working bc. I can't see it in my output. Gah
14:29:38 <cptwunderlich> > What is polymorphism doing here for code generation anyway.
14:29:40 <lambdabot>  <hint>:1:60: error:
14:29:40 <lambdabot>      <hint>:1:60: error:
14:29:40 <lambdabot>          parse error (possibly incorrect indentation or mismatched brackets)
14:29:45 <cptwunderlich> To reuse parts of the backend
14:30:24 <monochrom> That was a rhetorical quesiton.
14:32:44 <merijn> Unicorn_Princess: I wish I did
14:33:15 <merijn> Unicorn_Princess: I have two projects doing plotting, one calls gnuplot as external process, the other matplotlib >.>
14:39:21 <shapr> Has anyone used haskell LDAP libraries to talk to Red Hat IDM?
15:23:56 <koz_> @hoogle cmp
15:23:56 <lambdabot> Data.Vector.Fusion.Bundle cmp :: Ord a => Bundle v a -> Bundle v a -> Ordering
15:23:56 <lambdabot> Data.Vector.Generic cmp :: (Vector v a, Ord a) => v a -> v a -> Ordering
15:23:56 <lambdabot> RIO.Vector cmp :: (Vector v a, Ord a) => v a -> v a -> Ordering
15:24:07 <koz_> I guess I want 'compare'.
15:24:10 <koz_> :t compare
15:24:12 <lambdabot> Ord a => a -> a -> Ordering
15:25:50 <koz_> > EQ <> EQ
15:25:52 <lambdabot>  EQ
15:25:57 <koz_> > EQ <> LT
15:26:00 <lambdabot>  LT
15:26:04 <koz_> > EQ <> GT
15:26:06 <lambdabot>  GT
15:26:12 <koz_> Hmm, interesting.
15:26:42 <koz_> Is there a more concise way to spell something like (x `compare` x') <> (y `compare` y')?
15:28:12 <koz_> :t comparing
15:28:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:29:14 <ski> `EQ' is neutral element
15:29:36 <koz_> ski: So EQ <> anything == anything <> EQ == EQ ?
15:29:46 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")
15:29:50 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
15:30:14 <ski> (primarily sorts by length, then for words of the same length, sorts them normally/lexicographically)
15:31:03 <ski> @where monoids
15:31:04 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
15:31:04 <lambdabot> instance Monoid a => Monoid (rho -> a)'
15:34:04 <iqubic> How does that work?
15:34:10 <iqubic> :t comparing length
15:34:12 <lambdabot> Foldable t => t a -> t a -> Ordering
15:34:26 <iqubic> :t comparing length <> compare
15:34:28 <lambdabot> (Foldable t, Ord (t a)) => t a -> t a -> Ordering
15:34:40 <iqubic> I'm so confused by that.
15:35:24 <merijn> iqubic: "instance Monoid r => Monoid (a -> r) where mempty = \_ -> mempty; mappend f g = \x -> mappend (f x) (g x)"
15:35:41 <merijn> iqubic: Except that instance applies recursively, so works for any number of arguments
15:35:56 <ski> @type comparing (length :: [a] -> Int) <> compare
15:35:58 <lambdabot> Ord a => [a] -> [a] -> Ordering
15:36:17 <merijn> :t comparing length
15:36:19 <lambdabot> Foldable t => t a -> t a -> Ordering
15:36:23 <merijn> :t compare
15:36:25 <lambdabot> Ord a => a -> a -> Ordering
15:36:29 <iqubic> mempty = const mempty and f <> g = \x -> (f x) <> (g x).
15:36:52 <ski> so, it's using the `Monoid Ordering' on the `Ordering' result of `comparing length' and `compare', combining them with a preferential merging. only if the first is `EQ', does it check the latter
15:37:32 <iqubic> Wait. Is "comparing length <> compare" the same as "comparing (length <> compare)"?
15:37:38 <merijn> iqubic: no
15:37:43 <merijn> the latter is a type error
15:37:51 <iqubic> :t comparing
15:37:52 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:38:05 <iqubic> :t comparing length
15:38:07 <lambdabot> Foldable t => t a -> t a -> Ordering
15:38:57 <merijn> iqubic: "comparing f" simply applies 'f' to both sides and compares the result
15:39:01 <iqubic> I know.
15:39:14 <koz_> Galaxy brain question: are all type errors equal?
15:39:39 <merijn> koz_: Define "all", "type", "error", and "equal" :)
15:39:44 <koz_> merijn: Darn.
15:39:57 <monochrom> Type Error Farm.  "Some type errors are more equal than others."
15:40:07 <merijn> koz_: Especially equal is hard
15:40:31 <monochrom> Equal is easy if you use uni-valued univalence.
15:40:33 <koz_> merijn: I too have read Girard's book, wherein he opines on this point in a very French way in Chapter 1.
15:40:41 <merijn> Spend 5 minutes looking into dependent types and homotopy type theories and discover there's about infinitely many ways for things to be equal ;)
15:40:50 <ski> which book's that, koz_ ?
15:41:02 <ski> ("Proofs and Types" ?)
15:41:11 <koz_> ski: That one.
15:41:27 <ski> he's often interesting
15:41:33 <monochrom> Ah, the French have first-hand experience in this because "the King of France" is the prototypical example in the topic of referential transparency.
15:41:43 * ski watched half of a talk of his .. in french
15:41:53 <ski> (only trouble is that i don't understand french)
15:42:12 <iqubic> Alright. I know understand how "sortBy (comparing length <> compare)" works.
15:42:37 <monochrom> If you understand "the King of France is bold" you understand referential transparency, equality, pure functional programming, and effect systems. >:)
15:43:15 <koz_> monochrom: Is that an example of reduction? :P
15:43:25 <monochrom> ha I don't know
15:43:59 <monochrom> I should have added "quantum-gravity unification" there for good measure.
15:45:14 <iqubic> :t comparing
15:45:16 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:45:57 <ski> @hoogle Eq b => (a -> b) -> (a -> a -> Bool)
15:45:58 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
15:45:58 <lambdabot> Distribution.Utils.Generic equating :: Eq a => (b -> a) -> b -> b -> Bool
15:45:58 <lambdabot> CorePrelude equating :: Eq a => (b -> a) -> b -> b -> Bool
15:47:00 <hekkaidekapus> monochrom: There is also: ¬´¬†L'√âtat, c‚Äôest moi.¬†¬ª for full referential transparency. (‚ÄùThe state and I are uno.‚Äù :p)
15:47:17 <koz_> hekkaidekapus: I call a category error.
15:47:34 <iqubic> "comparing length <> compare" works like this: https://dpaste.com/H8X5SENPN
15:47:44 <hekkaidekapus> koz_: <<loop>>
15:48:04 <ski> @quote change.the.state
15:48:04 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
15:48:24 <koz_> hekkaidekapus: Lol...
15:48:49 <hekkaidekapus> ski: But we just found the state‚Ä¶
15:49:04 <koz_> > False <> False
15:49:04 <hekkaidekapus> iqubic: Did you read the URL ski posted above?
15:49:06 <lambdabot>  error:
15:49:06 <lambdabot>      ‚Ä¢ No instance for (Semigroup Bool) arising from a use of ‚Äò<>‚Äô
15:49:06 <lambdabot>      ‚Ä¢ In the expression: False <> False
15:49:19 <koz_> Are there wrappers for Bool for this purpose?
15:49:34 <ski> > Any False <> Any True
15:49:34 <solonarv> sure, a bunch of them
15:49:36 <lambdabot>  Any {getAny = True}
15:49:39 <ski> > All False <> All True
15:49:42 <lambdabot>  All {getAll = False}
15:49:45 <koz_> Yay, thanks!
15:49:53 <iqubic> koz_: I have looked at the reddit post.
15:49:54 <solonarv> Min and Max also work, if you want to be cryptic
15:50:02 <solonarv> (Min = All, Max = Any)
15:50:12 <koz_> solonarv: Being cryptic is not my goal (today).
15:50:43 <iqubic> koz_: Any == (Bool, Or, True), All == (Bool, And, False)
15:51:09 <monochrom> For boolean algebra, min and max are better analogies than * and +
15:51:16 <iqubic> First is the M, second is <>, third is Mempty
15:51:28 <monochrom> In fact, scratch analogies, min and max are the real deal.
15:52:03 <monochrom> a*a = a makes no sense, min a a = a does.
15:52:17 <monochrom> a*(a+b) = a makes no sense, min a (max a b) = a does.
15:52:19 <solonarv> a*a=a does make sense when the domain is {0,1}
15:52:29 <solonarv> it's 1+1=1 that makes no sense
15:52:35 <monochrom> OK right.
15:55:42 <ski> let the domain be ‚åú{0,1,2,‚ãØ ,‚àû}‚åù, ‚åú0‚åù standing for "true", and ‚åú‚àû‚åù for "false"
15:55:47 * hackage kempe 0.1.0.0 - Kempe compiler  https://hackage.haskell.org/package/kempe-0.1.0.0 (vmchale)
15:56:34 <ski> (more specifically, "forever true" and "forever false". ‚åú1‚åù is "false now, but (forever) true, in one time step". ‚åú2‚åù is "false now, and in the next instant, but (forever) true, in two time steps")
15:56:56 <ski> (what then is "and","or","not" ?)
15:58:57 <pjb> ski: the domain is not closed for not  Only not ‚åú0‚åù = ‚åú‚àû‚åù and not ‚åú‚àû‚åù = ‚åú0‚åù can be defined.
15:59:33 <pjb> ski: and ‚åúa‚åù ‚åúb‚åù = ‚åúmax a b‚åù  or ‚åúa‚åù ‚åúb‚åù = ‚åúmin a b‚åù
16:01:08 <ski> "not" will be "approximative" (won't be an involution)
16:01:25 <ski> but yes, that's conjunction and disjunction
16:05:38 <ski> negation of ‚åú‚àû‚åù is ‚åú0‚åù, of course, and negation of ‚åú0‚åù is ‚åú‚àû‚åù. negation of positive integers will also be mapped to ‚åú‚àû‚åù
16:08:17 <hekkaidekapus_> Is this about irredundant subsets?
16:10:55 <ski> it's about (discrete) dynamical systems
16:13:18 <ski> you have a type ‚åúA‚åù, and an endofunction ‚åúŒ± : A ‚ü∂ A‚åù. given a point in ‚åúA‚åù, to "advance time one step", you apply ‚åúŒ±‚åù. for each point, you'll get an "orbit", if you repeat this
16:13:22 <hekkaidekapus> Hmm, ok. I thought you were about to build up free sub-algebras and somehow land back to, from my guessing, what started it all (monoids, the Haskell way).
16:13:58 <ski> an orbit can eventually get stuck in a loop/cycle. or it might continue on to new points, eternally (in case the carrier ‚åúA‚åù is infinite)
16:14:24 <ski> a cycle, or an infinite strand, can have many "hairs" on it, that can branch back like trees
16:16:24 <ski> a subdynamical system of ‚åú‚ü®A,Œ±‚ü©‚åù is a subset ‚åúS‚åù of ‚åúA‚åù, such that ‚åúŒ±‚åù is closed under ‚åúS‚åù -- it's restriction to ‚åúS‚åù has an image that fits inside ‚åúS‚åù : ‚åúŒ±|S : S ‚ü∂ S‚åù
16:18:08 <ski> now, if we have a point ‚åúx‚åù of ‚åúA‚åù, we can ask whether it's included in the subobject ‚åúS‚åù. can ask ‚åúx ‚àà S‚åù. the result of this question, the truth-value, is a point in the dynamical system of truth-values, ‚åúŒ©‚åù (the "subobject classifier")
16:21:50 <ski> a map between dynamical systems, ‚åúf : ‚ü®A,Œ±‚ü© ‚ü∂ ‚ü®B,Œ≤‚ü©‚åù consists of a function between the carriers, ‚åúf : A ‚ü∂ B‚åù, satisfuying the property that if we "advance time" (using ‚åúŒ±‚åù) a step in ‚åúA‚åù, then use ‚åúf‚åù to map to ‚åúB‚åù, then we get the same result as if we use ‚åúf‚åù directly to map over to ‚åúB‚åù, and then "advance time" (using ‚åúŒ≤‚åù) over there : ‚åúf ‚àò Œ± = Œ≤ 
16:21:56 <ski> ‚àò f‚åù (or, if you prefer, ‚åú‚àÄ x : A. f(Œ±(x)) = Œ≤(f(x))‚åù)
16:24:07 <hekkaidekapus> The properties you are describing are better served with visual representations.
16:24:09 <ski> (so ‚åúf‚åù will map any "image of points, connected by \"advance time\"", inside ‚åúA‚åù, to a corresponding image, inside ‚åúB‚åù, still connected in the same way, although possibly "smushed" a bit (blurring things together, so we can't see as much detail))
16:24:14 <ski> yes
16:24:55 <hekkaidekapus> Are you into graphics? (specifically, the fractal kind)
16:26:49 <ski> anyway, to describe "being an element of ‚åúS‚åù", we want to have a map ‚åúœá_S : ‚ü®A,Œ±‚ü© ‚ü∂ ‚ü®Œ©,œâ‚ü©‚åù. it should map ‚åúx‚åù to ‚åú0‚åù, just in case ‚åúx‚åù was a member of ‚åúS‚åù
16:27:39 <ski> if ‚åúx‚åù was not a member of ‚åúS‚åù, but ‚åúŒ±(x)‚åù is, then ‚åúx‚åù should be mapped to ‚åú1‚åù. if not, but ‚åúŒ±(Œ±(x))‚åù is, then ‚åúx‚åù should be mapped to ‚åú2‚åù. and so on
16:28:06 <ski> if no "descendant" of ‚åúx‚åù is a member of ‚åúS‚åù, then ‚åúx‚åù is mapped to ‚åú‚àû‚åù
16:29:20 <ski> (once you get inside a sub-dynamical-system, like ‚åú‚ü®S,Œ±|S‚ü©‚åù, you can never escape. because ‚åúŒ±|S : S ‚ü∂ S‚åù never maps from inside to outside)
16:30:18 <ski> hm, well. i find fractals interesting, sure
16:31:46 <hekkaidekapus> What if there are ‚Äúmultiple-descendants‚Äù? (multiple variables to the process)
16:33:23 <hekkaidekapus> Immediate descendants, if that makes sense (not in the setting you began with, in some other system).
16:35:12 <ski> (another example is to take, not dynamical systems, but (directed, multi-)graphs. there's an obvious notion of "subgraph", that similarly gives rise to a "truth-value" graph. having two nodes (‚åú‚ä•‚åù,‚åú‚ä§‚åù, "false" and "true"), and five edges (‚åú‚ä• : ‚ä• ‚ü∂ ‚ä•‚åù,‚åúsource : ‚ä§ ‚ü∂ ‚ä•‚åù,‚åútarget : ‚ä§ ‚ü∂ ‚ä•‚åù,‚åúends : ‚ä§ ‚ü∂ ‚ä§‚åù,‚åú‚ä§ : ‚ä§ ‚ü∂ ‚ä§‚åù)
16:35:33 <ski> well, you can take two endofunctions, rather than one, e.g.
16:35:55 <ski> so, at each turn, you can go either left or right
16:36:49 <ski> (er .. sorry, should have been ‚åútarget : ‚ä• ‚ü∂ ‚ä§‚åù ..)
16:38:05 <hekkaidekapus> Nice. Thank you for sharing, I‚Äôll call it a night.
16:39:00 * ski nods
16:40:10 <ski> ("Conceptual Mathematics: A First Introduction to Categories" by F. William "Bill" Lawvere,Stephen H. Schanuel in 2009, does go into those examples, a bit)
16:47:19 <koz_> :t mapMaybe
16:47:21 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:47:33 <koz_> @hoogle mapMaybe
16:47:34 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
16:47:34 <lambdabot> Data.IntMap.Internal mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
16:47:34 <lambdabot> Data.IntMap.Lazy mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
16:48:42 <ski> @type (=<<) . (maybe mzero return .)
16:48:44 <lambdabot> MonadPlus m => (a -> Maybe b) -> m a -> m b
16:50:40 <MarcelineVQ> not quite as cool as mapPossibly
18:19:33 * hackage servant-swagger-ui 0.3.4.3.37.2 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.3.4.3.37.2 (DavidJohnson)
18:27:03 * hackage servant-swagger-ui-core 0.3.4 - Servant swagger ui core components  https://hackage.haskell.org/package/servant-swagger-ui-core-0.3.4 (DavidJohnson)
18:28:55 <iqubic> :t many
18:28:57 <lambdabot> Alternative f => f a -> f [a]
18:29:03 <iqubic> What does this even do?
18:29:26 <Axman6> runs the f a until it fails and returns all results
18:29:43 <Axman6> @src many
18:29:43 <lambdabot> Source not found. Sorry.
18:30:48 <iqubic> But how would the f a action have multiple results?
18:31:05 <Axman6> f ~ Parser
18:31:35 <iqubic> huh? What do you mean?
18:31:35 <Axman6> char :: Char -> Parser Char, many (char 'a') runnagainst "aaabbb" would return "aaa"
18:31:43 <iqubic> Ah I see. That makes sense.
18:33:40 <iqubic> How does many work?
18:34:38 <Axman6> many f = ((:) <$> f a <*> many f) <|> pure []
18:35:08 <Axman6> one of those recursive calls to many f will eventually return [] because the f failed
18:35:22 <Axman6> uh, should be (:) <$> f <*> ...
18:36:22 <iqubic> So it will run `f a` again and again and again until it fails?
18:36:46 <iqubic> That's very powerful.
18:37:14 <Axman6> it'll run f again (which has type f a, sorry)
18:37:34 <Axman6> it is powerful, but can be prone to doing too much
18:37:43 <Axman6> which is why things like manyTill exist
18:37:47 <Axman6> :t manyTill
18:37:48 <lambdabot> error: Variable not in scope: manyTill
18:37:54 <Axman6> @hoogle manyTill
18:37:54 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
18:37:55 <lambdabot> Text.Parsec manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
18:37:55 <lambdabot> Text.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
18:38:49 <iqubic> What does manyTill do again?
18:39:16 <Axman6> which is something like manyTill fa fend = (fend $> []) <|> ((:) <$> fa <*> manyTill fa fend), i.e., parse as many a's as you can until fend succeeds
18:39:36 <iqubic> Ah.
18:40:39 <iqubic> manyTill letterChar (char ",") "abcdefghi, 12345"
18:40:49 <iqubic> Something like that might return just the letters.
18:41:36 <Axman6> so parsing some numbers in the format [1,2,3,4] might look like: char '[' *> ((:) <$> int <*> manyTill (char ',' *> int) (char ']')
18:42:13 <Axman6>  uh, though that won't work for empty lists
18:42:26 <iqubic> Right, except that parser combinators give us something better:
18:43:13 <iqubic> https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Applicative-Combinators.html#v:sepEndBy
18:43:39 <iqubic> Actually, you'd just want sepBy.
18:44:07 <iqubic> This is going to useful for remembering how Megaparsec works when doing Advent Of Code tonight.
18:47:25 <Axman6> yeah I was going to say there's definitely preexisting combinators for exactly this sort of parsing, since these patternsd are so common
18:49:39 <iqubic> Yeah.
18:50:14 <iqubic> I just wrote this for myself: http://dpaste.com/3JUVJ2QXS
18:50:25 <iqubic> I think that should do what I want.
18:55:10 <koala_man> how can I get the path to a cabal built executable?
18:57:01 <dibblego> you can use the --installdir flag to cabal install to know where it is, at least
19:01:38 <ezzieyguywuf> so, I'm using config-value (and I really like it!) but I could use some advice, or maybe just bounce some ideas, regarding my config file structure. here is an example of what I currently have, but I'm wondering if there is some better way to have the user provide a list of (match-strings, new-description) pairs. https://dpaste.com/6A6Z4K7LL
19:09:14 <monochrom> koala_man: There are two defaults, depending on v1 commands vs v2 commands.  $HOME/.cabal/bin and $HOME/.local/bin
19:09:52 <glguy> ezzieyguywuf, I would say just don't use key-value pairs, instead use a list
19:10:05 <monochrom> I highly recommend customizing $HOME/.cabal/config to set them to what works best for you.
19:10:43 <glguy> ezzieyguywuf, like what I have in the example config file here: https://github.com/glguy/irc-core a list of servers
19:13:31 <ezzieyguywuf> glguy: now, is servers strictly a list, or can it contain a section that would apply to all servers listed?
19:13:54 <ezzieyguywuf> similar to how in the example I posted, any of the matches get the same DebitAccount and CreditAccount
19:19:21 <glguy> I have a separate "default" entry
19:20:36 <texasmynsted> Before I go all crazy... This should be possible right? I want to use parseTimeM and parse a String that may be in one of a dozen formats. 
19:21:46 <ezzieyguywuf> glguy: hrm, yes I see, however in my case I would have the equivalent of "servers1", "servers2", "servers3" etc... each needing their own "default1", "default2", "default3", etc, in which case mimicking the approach in irc-core makes a bit less sense I think
19:21:56 <ezzieyguywuf> texasmynsted: yes.
19:22:30 <ezzieyguywuf> texasmynsted: though you'll have to, of course, write a format string for each of the dozens that you wish to match
19:22:44 <texasmynsted> I have that part.
19:23:16 <ezzieyguywuf> texasmynsted: i think there's one that returns a Maybe or something...h/o let me check the doc
19:23:37 <texasmynsted> I am trying to think of the correct way to keep trying until I get a Just or run out of options 
19:23:55 <texasmynsted> parseTimeM returns a Maybe
19:24:39 <texasmynsted> I have it working find for a known, single format. It either parses it correctly or leaves it alone.
19:25:40 <texasmynsted> Now I want to it to parse it correctly or keep trying until it works, or runs out of formats and thus leaves the value alone
19:25:41 <ezzieyguywuf> ah, yes well there you go.
19:26:09 <ezzieyguywuf> so you could do an fmap over all your formatstrings, and then check if you get any Just's 
19:26:21 <ezzieyguywuf> or there may be a better way to do that, like "until" or something
19:26:24 <texasmynsted> I guess I could just keep working recursively over a list formats
19:28:05 <ezzieyguywuf> texasmynsted: if I were to take a stab at it, I guess I'd start with `fmap (flip (parseTimeM True defaulteTimeLocale) inputString) listOfFormats` and go from there
19:28:31 <ezzieyguywuf> though again, there may be a more efficient way to do this, i.e. stop at the first match rather than checking each format
19:28:48 <texasmynsted> okay
19:28:59 <texasmynsted> I was thinking something like asum might be of use
19:29:40 <sm[m]> Me too
19:30:55 <texasmynsted> :-)
19:31:02 <texasmynsted> Okay this sounds worth a try then
19:31:08 <texasmynsted> Thank you
19:31:33 * hackage implicit-hie-cradle 0.3.0.1 - Auto generate hie-bios cradles  https://hackage.haskell.org/package/implicit-hie-cradle-0.3.0.1 (Avi_Dessauer)
19:32:21 <ezzieyguywuf> texasmynsted: maybe something like this? https://dpaste.com/3KGZMHFPX
19:36:10 <texasmyn_> nice thank you.
19:36:53 <ezzieyguywuf> texasmyn_: üëçÔ∏è
19:36:59 <ezzieyguywuf> texasmyn_: good luck!
19:38:29 <ezzieyguywuf> texasmyn_: I think fromMaybe can help you clean that up a hair
19:45:08 <glguy> ezzieyguywuf, I don't understand your use-case yet, then
19:45:23 <glguy> ezzieyguywuf, do you know how you'd write it if you didn't have to conform to my existing ideas?
19:46:39 <iqubic> I wish I had a function foo that acts exactly like id if the input is a String, but runs Show on the input otherwise.
19:47:01 <iqubic> Does something like that exist?
19:47:28 <iqubic> Mainly I want to avoid having "\"foobarbaz\"" as the output of this function
19:47:55 <iqubic> I'd probably have to write a typeclass, and then use flexible instances or something.
19:51:18 <glguy> ezzieyguywuf, what about this? https://paste.tomsmeding.com/iuhpMcF1
19:55:08 <ezzieyguywuf> glguy: that's perfect!
19:55:27 <ezzieyguywuf> I knew it was doable, I think I was just too deep in it to get there
19:56:47 <glguy> I generally don't like user-defined keys in key-value maps
19:56:53 <glguy> (for config)
19:58:45 <ezzieyguywuf> glguy: i.e. the way I originally had it?
19:58:56 <ezzieyguywuf> b/c yea, that was rubbing me the wrong way
19:58:57 <glguy> yeah, and for the very reason you complained about
19:59:03 * hackage implicit-hie-cradle 0.3.0.2 - Auto generate hie-bios cradles  https://hackage.haskell.org/package/implicit-hie-cradle-0.3.0.2 (Avi_Dessauer)
19:59:22 <glguy> I don't want the section naming lexical syntax to impose contraints on semantically important configuration stuff
20:00:12 <glguy> I know a lot of other languages like this just let you use arbitrary values as keys
20:14:35 <texasmyn_> This is what I have so far... https://gist.github.com/mmynsted/e5ef944c65959fee414ce4a56bb8451c
20:15:48 <texasmyn_> My initial test it has not found the format from those I provided, though it should. It is times like this I wish I knew a quick way to throw in some debug logging. 
20:23:53 <iqubic> Does ghcid work with cabal repl?
20:28:43 <dsal> texasmyn_: Debug.Trace
20:29:27 <texasmyn_> dsal: Okay I will check that out.
20:29:37 <texasmyn_> At least is works in my Tasty tests. 
20:29:50 <texasmyn_> I mean At least it works in my Tasty tests.
20:29:52 <MarcelineVQ> iqubic: ghcid -c 'cabal repl'
20:30:03 <iqubic> I've got it. Thanks.
20:32:35 <texasmyn_> ooh :-) Yes, looks like Debug.Trace is exactly what I am looking for
20:32:39 <texasmyn_> Thank you dsal
20:41:44 <monochrom> texasmyn_: My Debug.Trace tutorial: http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/tracing.html
20:42:08 <monochrom> As it happens, my students were also asking how to print debugging messages.
20:42:43 <monochrom> To their discredit, I already gave them the link on the course website long before they asked.
20:43:03 <dibblego> never tell students about Debug.Trace
20:43:49 <monochrom> Denied.
20:44:06 <dibblego> let putStrLn = trace
20:44:06 <monochrom> I have a student who was trying: case putStrLn "hi" of _ -> ...
20:44:32 <dibblego> it's also to give you deniability for when they discover it themselves
20:44:49 <monochrom> Down that road is "how do I extract a from IO a" and discovering unsafePerformIO from googling
20:44:55 <dibblego> fun ey?
20:45:03 <monochrom> No, Debug.Trace is infinitely better in comparison.
20:45:05 <dibblego> I cover that question in lecture 1
20:45:23 <dibblego> if you ever ask yourself, "how do I get the a out (f a), the answer is bind, write this in your notes"
21:03:00 <ezzieyguywuf> glguy: I created some more vim stuf for config-value if you're interested, it builds on the syntax file you made but also adds (1) filetype detection, (2) proper handling of comments. https://gitlab.com/ezzieyguywuf/vim-config-value
21:09:46 <texasmyn_> wow hello dibblego
21:09:52 <texasmyn_> I never see you here
21:10:06 <texasmynsted> How are things?
21:10:19 <dibblego> hey mate, pretty good
21:11:25 <texasmynsted> :-)
21:27:18 <texasmynsted> Any new training, or flying or anything?
21:30:26 <dibblego> yes, I fly about 20 hours per week, doing written exams lately; did formation and RG endorsement recently
21:32:58 <texasmynsted> oh nice
21:33:07 <texasmynsted> 20 hours is a lot of flying
21:33:45 <dibblego> from first to last civil twilight, each weekend
21:34:19 <dibblego> also did a night rating, so sometimes then too
21:35:04 <texasmynsted> :-)
21:35:06 <texasmynsted> Wow fun
21:35:50 <dibblego> day flight is all flight instruction, I fly at night for fun occasionally
21:36:58 <texasmynsted> I love the idea of flying but might panic a bit for the landing 
21:37:14 <dibblego> just close ya eyes and hope
21:38:09 <texasmynsted> LOL
21:38:35 <dibblego> that's what most of my students do anyway
21:38:36 <texasmynsted> Catch you later. 
21:38:41 <dibblego> scratchya
21:53:00 <glguy> ezzieyguywuf: pull requests encouraged :)
23:04:28 <jasperr> hello everybody
23:05:27 <jasperr> maybe I am missing something very trivial... I would like to use XsdToHaskell and DtdToHaskell on debian buster distribution
23:07:42 <jasperr> as far as I see I have all the related ghc-* packages installed from the debian apt repositories, however I cannot find a way to get these utilities... including the -dev packages as well
23:23:57 <jasperr> digging a bit I found /usr/bin/DtdToHaskell coming from debian package haxml, XsdToHaskell is simply not provided, I do not understand why
23:32:04 <glguy> jasperr: in that case you might just have to build it outside of the package system
23:36:48 <jasperr> I see... I do not like this idea that much
23:49:03 * hackage nothunks 0.1.2 - Examine values for unexpected thunks  https://hackage.haskell.org/package/nothunks-0.1.2 (EdskoDeVries)
23:57:50 <jasperr> maybe the best is then to contact the Debian Haskell Group
