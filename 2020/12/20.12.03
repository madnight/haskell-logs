00:03:21 <Orbstheorem> Hello, I'm trying to write an inductive type instance over Nat but I can't manage to convince GHC that by base-case and inductive step are disjoint: https://paste.gnugen.ch/raw/fsvt
00:05:39 <Orbstheorem> I'm not even sure, this is an inductive type instance, so I may aswell describe what I want: Given a type-level "depth" and a tree, I want to make another tree that is complete and has nodes of type `Maybe a` and contain the information of the original tree if such tree contained that node.
00:05:47 <Orbstheorem> s/sure,/sure
00:32:16 <sleblanc> > let p = isDigit &&& isAlpha
00:32:18 <lambdabot>  <no location info>: error:
00:32:18 <lambdabot>      not an expression: ‘let p = isDigit &&& isAlpha’
00:32:51 <sleblanc> > (isAlpha &&& isDigit) 'a'
00:32:54 <lambdabot>  (True,False)
00:33:01 <sleblanc> > (isAlpha &&& isDigit) '9'
00:33:04 <lambdabot>  (False,True)
00:33:29 <sleblanc> > or $ (isAlpha && isDigit) '9'
00:33:32 <lambdabot>  error:
00:33:32 <lambdabot>      • Couldn't match expected type ‘Char -> t0 Bool’
00:33:32 <lambdabot>                    with actual type ‘Bool’
00:33:40 <sleblanc> > or $ (isAlpha &&& isDigit) '9'
00:33:42 <lambdabot>  True
00:33:52 <sleblanc> > or $ (isAlpha &&& isDigit) 'a'
00:33:55 <lambdabot>  False
00:33:59 <sleblanc> why?
00:34:11 <sleblanc> > or (True, False)
00:34:14 <lambdabot>  False
00:35:33 * hackage clickhouse-haskell 0.1.1.0 - A Haskell library as database client for Clickhouse  https://hackage.haskell.org/package/clickhouse-haskell-0.1.1.0 (MaboroshiChan)
00:36:26 <idnar> :t or
00:36:28 <lambdabot> Foldable t => t Bool -> Bool
00:37:31 <idnar> sleblanc: the Foldable instance on tuples doesn't do what you want:
00:37:56 <sleblanc> yeah. what is the meaning behind this behaviour?
00:38:02 <idnar> > toList (1, 2)
00:38:05 <lambdabot>  error:
00:38:05 <lambdabot>      Ambiguous occurrence ‘toList’
00:38:05 <lambdabot>      It could refer to
00:38:09 <sleblanc> what use is there for that?
00:39:00 <sleblanc> > Data.Foldable.toList (1,2)
00:39:02 <lambdabot>  [2]
00:39:44 <Sose> I'm not sure but I think conceptually a 2-tuple in Haskell is not "a thing with 2 elements" but rather "a thing with 1 element and some context (the first element)"
00:39:59 <Sose> it's a little weird imho
00:40:33 <idnar> well, Foldable (,) is a kind error, so it has to be Foldable ((,) a)
00:40:33 <Sose> atleast when it comes to some instances like Functor and Foldable
00:40:44 <sleblanc> it would also give an excuse for not having Foldable (,,) et al.
00:41:04 <sleblanc> idnar, right…
00:42:03 <sleblanc> are there any concrete uses of the foldable instance for ((,) a) ?
00:42:22 <idnar> https://mail.haskell.org/pipermail/haskell-cafe/2020-November/132978.html
00:43:04 <idnar> this is frequently debated
00:43:50 <jle`> i think there are nice usages of Traversable ((,) w)
00:44:00 <idnar> one use is assoc-listish things
00:44:02 <jle`> but that would require Foldable as a superclass
00:44:06 <jle`> so idk
00:44:20 <jle`> i'm not happy with the Foldable instance existing either, it has caused me a lot of headache in the past
00:44:30 <jle`> it sort of directly compromises the ideals of type safety in haskell
00:45:12 <idnar> > sum [("foo", 1), ("bar", 2)]
00:45:14 <lambdabot>  error:
00:45:14 <lambdabot>      • No instance for (Num ([Char], Integer))
00:45:14 <lambdabot>          arising from a use of ‘e_112’
00:45:22 <idnar> ugh
00:45:27 <sleblanc> owch
00:45:55 <idnar> > foldr (+) 0 [("foo", 1), ("bar", 2)]
00:45:57 <lambdabot>  error:
00:45:57 <lambdabot>      • No instance for (Num ([Char], Integer))
00:45:57 <lambdabot>          arising from a use of ‘e_1012’
00:46:26 <idnar> > foldMap Sum [("foo", 1), ("bar", 2)]
00:46:28 <lambdabot>  error:
00:46:29 <lambdabot>      • No instance for (Num ([Char], Integer))
00:46:29 <lambdabot>          arising from a use of ‘e_112’
00:46:55 <idnar> oh I'm dumb
00:46:56 <sleblanc> something something expecting different results
00:47:55 <idnar> > foldMap (foldMap Sum) [("foo", 1), ("bar", 2)]
00:47:57 <lambdabot>  Sum {getSum = 3}
00:48:10 <idnar> a bit silly
00:51:12 <sleblanc> sum $ map snd [("foo", 1), ("bar", 2)]
00:51:14 <sleblanc> > sum $ map snd [("foo", 1), ("bar", 2)]
00:51:16 <lambdabot>  3
00:55:02 <Orbstheorem> > fmap (bimap sum sum) [("foo", 1), ("bar", 2)]
00:55:05 <lambdabot>  error:
00:55:05 <lambdabot>      • Could not deduce (Num Char) arising from a use of ‘sum’
00:55:05 <lambdabot>        from the context: (Foldable t, Num d, Num (t d))
01:17:33 * hackage mail-pool 2.2.1 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.2.1 (Jappie)
01:28:43 <Digit> hi.  i'm wondering if there's an established/illustrated/expressed relationship between feynman diagrams, and monads, either directly or indirectly (like a shared simplification or augment of understanding or processing or something).   or has my brain just started barking up the wrong tree?
01:29:45 <[exa]> Digit: CT has commutative diagrams
01:30:30 <Digit> category theory.  *nods*
01:30:54 <boxscape> monads can also be expressed in string diagrams which look kind of similar to FDs https://ncatlab.org/nlab/show/string+diagram but not sure there's an actual connection there
01:31:38 <boxscape> (the string diagrams for monads are on this page https://ncatlab.org/nlab/show/monad )
01:31:53 <[exa]> the feynman diagrams kindof describe a single process with inputs and outputs right?
01:33:49 <boxscape> the string diagram page contains a link to https://ncatlab.org/nlab/show/%27t+Hooft+double+line+notation which mentions feynman diagrams in the opening paragraph
01:43:36 <ski> Digit : "The Catsters" <https://www.youtube.com/playlist?list=PLlGXNwjYhXYxKVa67r0pKuYufECy713bv> mentions string diagrams (and also talks about monads in different videos)
01:45:28 <ski> it would be nice to be able to reexport an operation, with a restricted type signature (so that e.g. `Data.Foldable' exports `length :: Foldable t => t a -> Int', while `Prelude' reexports it as `length :: [a] -> Int'
01:47:54 <ski> Orbstheorem : it seems `n + 1' (nor `1 + n') is not considered to be disjoint from `0' (i tried `instance (0 <= n,PadTree n) => PadTree (n + 1) where ...', since obviously `instance (depth ~ n + 1,...) => PadTree depth where ...' will obviously overlap with `instance PadTree 0 where ...', can't possibly work ..)
01:49:15 <boxscape> ski can't you do that simply by defining a new length method in Prelude and say "length :: [a] -> Int; length = length"?
01:49:28 <boxscape> uh
01:49:34 <boxscape> imagine I qualified that length on the rhs
01:53:18 <ski> boxscape : the point would be to not have an identifier clash, if you import both (but rather get the most general version (if any. or else, have to disaambiguate))
01:53:41 <boxscape> Ah, I see
01:55:26 <ski> Orbstheorem : btw, why "Square" ? .. also, on this line, `data PerfectlyBalancedBinaryTree a = Elems a | Double (PerfectlyBalancedBinaryTree (a,a))' might be interesting to consider. you could also make a GADT one of kind `Nat -> * -> *' (rather than the phantom type `SquareTree' that you have)
02:05:55 <boxscape> Digit there's also a paragraph here on feynman diagrams as string diagrams https://ncatlab.org/nlab/show/Feynman+diagram#AsStringDiagrams
02:33:33 * hackage clickhouse-haskell 0.1.2.0 - A Haskell library as database client for Clickhouse  https://hackage.haskell.org/package/clickhouse-haskell-0.1.2.0 (MaboroshiChan)
03:12:33 * hackage hw-kafka-client 4.0.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-4.0.0 (alexeyraga)
03:15:34 * hackage friendly 0.1.0.2 - Attempt to pretty-print any input  https://hackage.haskell.org/package/friendly-0.1.0.2 (EdskoDeVries)
03:19:10 <mastarija> About the "cross compiling". I have a 64 bit Windows machine, and I have a 64 bit linux / CloudLinux / cPanel server. Since it's cPanel, I don't have a great control over it, however I can upload and execute custom scripts / executables.
03:19:45 <mastarija> Can I just use a VM / WSL to compile locally and then execute on server?
03:20:21 <mastarija> If my program is fairly simple and doesn't depend on dll's and stuff?
03:20:42 <mastarija> I'm guessing it needs to be statically linked?
03:26:40 <maerwald> static linking on linux and then execute in WSL ubuntu?
03:27:56 <mastarija> maerwald, no, basically I want to compile on windows in WSL or some VM and then execute on my cPanel / CloudLinux server.
03:28:35 <mastarija> But since this is WSL or VM Linux, then windows part doesn't really matter I guess :/
03:29:05 <mastarija> I mean, in theory it should work, right?
03:29:29 <maerwald> I don't understand why you would want to use WSL to create a linux executable
03:29:48 <maerwald> path of maximum resistance?
03:31:16 <mastarija> Yes
03:31:30 <mastarija> I have Windows and I'm too lazy to switch to Linux
03:31:37 <ezzieyguywuf> glguy: I considered a pull request, but having it in a separate repository allows for easy integration with the various vim plugin managers
03:31:40 <mastarija> And I can't compile on my server for "reasons"
03:31:43 <Libertinus> New to irc and Haskell. Where and how should I ask about installation on MacOS Catalina. Watched and "copied" actions on a video but did not succeed. Some old partial installation might interfere 
03:32:21 <maerwald> Libertinus: https://www.haskell.org/ghcup/
03:32:30 <Libertinus> Ta!
03:33:25 <mastarija> maerwald, anyway, scratch the Windows part. If I compile Haskell program on linux distro X and try to run it on linux distro Y, will it work?
03:33:32 <Libertinus> That is the procedure I tried. Did not install and I don't have a clue what the error msg means.
03:33:50 <maerwald> mastarija: you can use alpine linux docker image to create a sttic executable
03:33:56 <maerwald> *static
03:34:22 <maerwald> here's an example https://gist.github.com/hasufell/f0893abfbba63ac4ea40feb0520946ee
03:39:03 <mastarija> maerwald, I'm assuming the resulting product doesn't require Docker on the target system?
03:40:17 <maerwald> that's just an example on how to create static executables: 1. use alpine, 2. install static versions of system libraries, 3. run stack/cabal with --ghc-options='-optl-static -split-sections'
03:40:49 <ski> Libertinus : mentioning the error message might help
03:41:28 <maerwald> mastarija: or try nix and spend a few weeks figuring out how it works: https://github.com/nh2/static-haskell-nix
03:41:53 <mastarija> XD
03:42:14 <mastarija> Thanks
03:50:02 <Libertinus> Here's the error msgI got from trying to install HAskell: 
03:50:08 <Libertinus> Last login: Thu Dec  3 00:22:46 on consoleanokhi@MacBook-Pro ~ % curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | shWelcome to Haskell!This script will download and install the following binaries:  * ghcup - The Haskell toolchain installer            (for managing GHC/cabal versions)  * ghc   - The Glasgow Haskell Compiler  *
03:50:09 <Libertinus> cabal - The Cabal build toolghcup installs only into the following directory,which can be removed anytime:  /Users/anokhi/.ghcupPress ENTER to proceed or ctrl-c to abort.Note that this script can be re-run at any given time.  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload
03:50:09 <Libertinus> Total   Spent    Left  Speed100 8796k  100 8796k    0     0  4903k      0  0:00:01  0:00:01 --:--:-- 4900k[ Info  ] Upgrading GHCup...[ Warn  ] No GHCup update availableSystem requirements   Note: On OS X, in the course of running ghcup you will be given a dialog box to install the command line tools. Accept and the requirements will be installed
03:50:10 <Libertinus> for you. You will then need to run the command again.Press ENTER to proceed or ctrl-c to abort.Installation may take a while.[ Info  ] verifying digest of: ghc-8.8.4-x86_64-apple-darwin.tar.xz[ Info  ] Unpacking: ghc-8.8.4-x86_64-apple-darwin.tar.xz to /var/folders/3f/fjxj71mn6hj5bzz665k_566r0000gn/T/ghcup-Bl7w0V[ Info  ] Installing GHC (this may
03:50:10 <Libertinus> take a while)[ ghc-configure ] not found (too old?)[ ghc-configure ] checking for gcc... gcc[ ghc-configure ] checking whether the C compiler works... no[ ghc-configure ] configure: error: in `/private/var/folders/3f/fjxj71mn6hj5...[ ghc-configure ] configure: error: C compiler cannot create executables[ ghc-configure ] See `config.log' for more
03:50:11 <Libertinus> details[ Error ] Build failed with NonZeroExit 77 "./configure" ["--prefix=/Users/anokhi/.ghcup/ghc/8.8.4"]    Check the logs at "/Users/anokhi/.ghcup/logs" and the build directory "/var/folders/3f/fjxj71mn6hj5bzz665k_566r0000gn/T/ghcup-Bl7w0V" for more clues.    Make sure to clean up "/var/folders/3f/fjxj71mn6hj5bzz665k_566r0000gn/T/ghcup-Bl7w0V"
03:50:11 <Libertinus> afterwards."_eghcup --cache install ghc recommended" failed!anokhi@MacBook-Pro ~ % curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | shWelcome to Haskell!This script will download and install the following binaries:  * ghcup - The Haskell toolchain installer            (for managing GHC/cabal versions)  * ghc   - The Glasgow
03:50:56 <int-e> :/
03:50:56 <maerwald> ...
03:51:32 <maerwald> seems xcode not installed 
03:54:40 --- mode: ChanServ set +o ski
03:54:59 --- mode: ChanServ set -o ski
03:59:05 <boxscape> why do value constructors have to begin with an uppercase letter? Distinguishing between a function and a constructor doesn't seem like something that a haskell compiler has to be able to do during parsing
03:59:54 <merijn> boxscape: Eh, because asking yourself "is this maybe a constructor?" every 5 minutes while coding sucks
04:00:28 <boxscape> hm, I guess. I suppose I'm just used to that being a coding convention thing rather than something that's enforced
04:00:58 <boxscape> i.e. readability being a reason for uppercase vs lowercase
04:02:08 <boxscape> I guess it helps with DataKinds since otherwise you couldn't use constructors without ' without it looking like a type variable to the constructor
04:02:51 <ski> in the MLs, data constructors can begin with both lower and upper case. and so, for constant patterns, you could mistake them for a variable pattern, if you don't recall their being constructors. also, with a typo, they'd become variables
04:03:14 <ski> Libertinus : please don't paste large amounts of text into the channel. use e.g. a paste service/site
04:03:28 <boxscape> hm yeah that's  fair point
04:04:08 <ski> perhaps one could argue for type families starting with lower case ?
04:04:26 <Libertinus> I tried to paste the error texts i got from trying to install Haskell (platform?) but the window froze. Will try again in a moment. An early perhaps partial installation might interfere. Any attempts at help are appreciated.
04:04:33 * hackage haskoin-core 0.17.4 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.17.4 (jprupp)
04:04:36 <boxscape> Well, right now lowercase in type *always* means type variable, you'd have to give that up
04:04:49 <boxscape> but that'll likely be given up eventually anyway with Dependent haskell
04:05:24 <ski> @where paste
04:05:24 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
04:05:31 <merijn> boxscape: I hope not
04:05:33 <ski> Libertinus : try pasting at that site, e.g. ^
04:05:54 <merijn> tbh, I wouldn't consider Dependent Haskell such an inevitability
04:06:09 <Libertinus> At lambdadots site?
04:06:11 <ski> boxscape : yes. the point being that you can't match on type families
04:06:21 <ski> Libertinus : at <https://paste.tomsmeding.com>
04:06:25 <tdammers> frankly, I kind of suspect that the usefulness of fully dependent haskell is being exaggerated a fair bit
04:06:27 <boxscape> merijn following the proposal discussions at the moment it's not looking inevitable but looks like it has good chances
04:06:32 <boxscape> ski yeah that makes sense
04:06:39 <Libertinus> ski: thank you!
04:06:54 <ski> Libertinus : .. and then, paste the resulting psate link, in here
04:07:03 <boxscape> maybe that paste site should replace gist in the #haskell topic?
04:07:10 <merijn> tdammers: Right. I'd rather not see Dependent Haskell, tbh
04:08:04 * hackage phonetic-languages-simplified-lists-examples 0.3.0.0 - Simplified and somewhat optimized version of the phonetic-languages-examples.  https://hackage.haskell.org/package/phonetic-languages-simplified-lists-examples-0.3.0.0 (OleksandrZhabenko)
04:08:33 <Libertinus> ski: ok - but where do I get such psate link
04:09:24 <Libertinus> ski: on the tomsmeding window i only see my long error msgs now
04:09:26 <ski> copy the link of the paste site into your browser. then create a new paste there, which should appear on a new address, which you can paste in here
04:09:35 <ski> check the location bar
04:10:01 <Libertinus> ski: ok, will try. am an old geezer and this is new to me..
04:10:33 <Libertinus> ski: https://paste.tomsmeding.com/SDIcYQr4
04:11:25 <merijn> Is there a convenient "keep every Nth element of a list" in libraries?
04:13:26 <ski> @type \n -> map head . chunksOf n
04:13:28 <lambdabot> Int -> [b] -> [b]
04:15:59 <ski> <maerwald> seems xcode not installed
04:17:01 <ski> Libertinus : hm, anyway, now your best bet is someone who knows about MacOS to possibly have any clue about what to .. (i don't really)
04:17:56 <tomsmeding> Libertinus: any clue what ghc-configure said right above that line "not found (too old?)"?
04:18:18 <tomsmeding> but yeah I think you're missing the command-line tools
04:18:24 <Libertinus> ski: thank you! I followed a youtube video step by step - they got thirs installed ok, I did not. Will try asking later, have to leave the chat now.
04:18:52 <tomsmeding> Libertinus: e.g. https://medium.com/flawless-app-stories/install-command-line-tools-on-macos-catalina-anansewaa-com-6f8c63120fd8
04:19:01 <Libertinus> tomsmeding: a moment
04:20:11 <Libertinus> Tomsmeding: I pasted everything from the terminal window. I do not have ore information than that
04:20:34 <Libertinus> * more than that
04:20:36 <tomsmeding> try doing the `xcode-select --install` from the article I linked; that has a reasonable chance of working and fixing the issue
04:21:08 <Libertinus> was the xcode msg meant to me?
04:21:28 <ski> (possibly)
04:22:13 <dminuoso> % data A = A { fooA :: String } | B { fooB :: String }
04:22:14 <yahb> dminuoso: 
04:22:17 <dminuoso> % fooA (B "foo")
04:22:17 <yahb> dminuoso: "*** Exception: No match in record selector fooA
04:22:29 <dminuoso> % data A = A { fooA :: String } | B { fooA :: String }
04:22:30 <yahb> dminuoso: 
04:22:34 <dminuoso> % fooA (B "foo")
04:22:35 <yahb> dminuoso: "foo"
04:22:52 <tomsmeding> Libertinus: yes sorry
04:23:32 <Aleksejs> Hi, why there's no such thing as Divisable that would unite Integral and Fractional? Then (/) could be of type Divisable a => a -> a -> a 
04:23:34 <Libertinus> tomsmeding: my bad I did not spot the article link at first. Wll try to do that. Thanks!
04:23:53 <dminuoso> So Im pondering whether or not to write something like `data A = A { aText :: Text, aInt :: Int } | B { bText :: Text, bInt :: Int } | C { cText :: Text, cInt :: Int, cInt2 :: Int }` or whether to write these as separate data types, and then some `data AnyThing = AnyA A | AnyB B | AnyC C`
04:24:00 <dminuoso> Would you be annoyed about the ergonomics of the latter?
04:24:16 <Orbstheorem> ski: Thanks for you answer, I'll come back to it later today ^^
04:24:30 <dminuoso> This seems like a trade off between introducial partial field selectors and an an annoying additional union type around it
04:26:39 <Libertinus> Tomsmeding: Trying to install xcode results i this error msg: Can't install the software because it is not currently available from the Software Update server"  Am runing Catalina 10.15.3
04:27:53 <tomsmeding> wat?
04:27:59 <tomsmeding> apple having an outage?
04:28:39 <tomsmeding> Libertinus: perhaps this https://stackoverflow.com/questions/56452358/install-command-line-developer-tools-cant-install-the-software-because-it-is-n 🤷
04:28:41 <hc> oh, is their ocsp responder for "trustd" broken again? =)
04:28:49 <Libertinus> tomsmeding: That's the error msg I get.
04:29:00 <tomsmeding> hc: not even, different server this time :D
04:29:02 <dminuoso> Libertinus: Yeah that happens frequently
04:29:08 <dminuoso> Libertinus: You need to download it directly from their website sometimes.
04:29:10 <tomsmeding> Libertinus: see the first answer for a workaround
04:29:16 <tomsmeding> i.e. what dminuoso says
04:29:30 <Libertinus> ok...
04:29:38 <dminuoso> Just to clarify, that's an Apple bug.
04:29:50 <tomsmeding> sorry for the mess, but then this is not our fault in this specific case :p
04:31:47 <ski> Aleksejs : what would the expected laws for it be ?
04:33:14 <Libertinus> Tomsmeding: I am now downloading command line tools for xcode 12.2.
04:33:21 <tomsmeding> nice!
04:33:30 <Libertinus> :)
04:33:53 <Libertinus> Spooky face, dat one..
04:34:14 <dminuoso> Aleksejs: What exactly are you looking to unite here? Both give you a notion of dividing (one gives real division, the other gives integral division).
04:35:07 <dminuoso> In fact, the Real superclass lets you do integral division on Real numbers too.
04:36:50 <Libertinus> Tomsmeding: I'd need MAcOS 10.15.4. to bo able to install the xxcode tools I have 10.15.3.
04:37:20 <Libertinus> tomsmeding: the installer says that. I guess I must upgrade my OS
04:37:41 <tomsmeding> that's dumb
04:38:03 <tomsmeding> they don't provide an installer for the previous version or something?
04:38:08 <tomsmeding> (been a while since I used a maC)
04:38:10 <tomsmeding> *mac
04:38:26 <merijn> tomsmeding: They do, but they're on the website not in the appstore, I think
04:38:37 <Libertinus> tomsmeding: I picked to latest non-beta version of the command line tools. Should I see if there is an older version available?
04:38:42 <tomsmeding> the CLT aren't in the app store anyway merijn 
04:38:48 <dminuoso> Libertinus: Did you go through the apple website or the app store?
04:38:51 <tomsmeding> Libertinus: I guess so?
04:38:52 <merijn> tomsmeding: Xcode is and you install CLI via xcode
04:39:08 <dminuoso> https://developer.apple.com/download/more/?=command%20line%20tools
04:39:18 <tomsmeding> merijn: as far as I remember you install CLI using xcode-select, which doesn't require an xcode installation
04:39:19 <dminuoso> Is where you should go
04:39:22 <Libertinus> domingo: Apple web site . got the linnk from here
04:39:26 <tomsmeding> though one way to do it is certainly to install xcode
04:39:35 <tomsmeding> but that's... heavy
04:39:45 <dminuoso> merijn: Go make your case again about what a lovely OS macOS is..
04:39:49 <merijn> tomsmeding: Eh, you do need xcode *anyway*
04:39:59 <merijn> tomsmeding: Else you don't have a C compiler or linker
04:40:01 <Libertinus> merijn: do I?
04:40:09 <tomsmeding> don't the CLT give gcc?
04:40:22 <dminuoso> well they give you clang
04:40:31 <tomsmeding> (yes fair)
04:40:46 <tomsmeding> merijn: if you need xcode anyway, then why does ghcup just install the CLT? ;)
04:41:33 <dminuoso> Im confident xcode clt will give you clang+linker
04:41:36 <Libertinus> merijn: I am a non-entity in programing, so if installing xcode makes life simpler for me, I'd like to do that
04:41:39 <dminuoso> and other stuff
04:41:42 <dminuoso> Libertinus: You dont nede xcode.
04:42:29 <tomsmeding> o/
04:46:26 <Libertinus> dminuoso: then I need to update my os to be able to install the xcode  CLT
04:48:28 <Libertinus> dminuoso: is it possible to update to 10.15.4 and avoid updating to Big sur?
04:48:33 * hackage ukrainian-phonetics-basic 0.3.2.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.3.2.0 (OleksandrZhabenko)
04:53:17 <tomsmeding> Libertinus: I think the non-haskell internet can help you better with that than we can
04:54:28 <Libertinus> tomsmeding: you have been most helpful! Will search the net, and return with haskell stuff, eventually. Have a good 'un! :)
04:54:40 <tomsmeding> Cheers!
04:55:07 <Libertinus> dminuoso: thank you, too!!
04:55:51 <Libertinus> :)
05:05:03 * hackage haskoin-core 0.17.5 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.17.5 (jprupp)
05:28:29 <AWizzArd> stylish-haskell suggests to Emacs users to read the “Using external formatters” section of the haskell-mode manual: http://haskell.github.io/haskell-mode/manual/latest/Autoformating.html#Autoformating
05:28:59 <AWizzArd> How will Emacs know about stylish-haskell? Is this backed into haskell-mode itself, the support for this specific formatter?
05:29:40 <dminuoso> AWizzArd: haskell-mode will invoke it as an external command
05:29:48 <dminuoso> So its necessary to be on PATH
05:30:22 <dminuoso> (custom-set-variables '(haskell-stylish-on-save t))
05:30:58 <AWizzArd> dminuoso: does stylish also support formatting a (marked) region?
05:32:38 <dminuoso> AWizzArd: Id guess no.
05:33:01 <dminuoso> At best it could only work for a region that is also valid as a top level binding
05:33:19 <dminuoso> Such that you could put the region into a temporary file, treat it as a module, run stylish-haskell on it, and splice it back in
05:33:48 <dminuoso> Such a thing is certainly implementable in emacs
05:34:26 <dminuoso> AWizzArd: Concretely
05:35:03 <dminuoso> AWizzArd: (defcustom haskell-mode-stylish-haskell-path "stylish-haskell" "Path to `stylish-haskell' executable." :group 'haskell :type 'string)
05:35:28 <AWizzArd> dminuoso: Aah okay, that makes sense!
05:35:52 <dminuoso> So you can override that if you want to
05:36:17 <dminuoso> e.g. through M-x customize-group RET haskell RET
05:43:16 <dminuoso> Does aeson have primitives to parse a string as numeric types?
05:45:21 <nshepperd2> any regex-tdfa experts here? is there a way to execute a regex in this library 'incrementally'?
05:46:06 <nshepperd2> that is, I want to feed characters in one at a time, and be able to determine after each step whether it is in an accepting, failing, or unfinished state
05:47:00 <nshepperd2> (the true purpose of this is that I want to execute a regex within / convert a regex into a parsec-style parser)
05:58:09 <nshepperd2> hmm, pcre supports partial matching
06:31:32 <siraben> Is there a more efficient structure than a vector of bytestirngs?
06:31:43 <siraben> vector of unboxed vectors of chars?
06:34:11 <merijn> siraben: for what?
06:34:38 <siraben> merijn: https://github.com/siraben/hoac-2020/blob/master/day3.hs
06:34:53 <siraben> I switched from list of bytestrings to vector of bytestrings but didn't seem to improve the benchmarks
06:38:28 <dolio> Seems like a better improvement would be only folding once.
06:39:58 <siraben> In part 2?
06:40:19 <siraben> Ah, right.
06:41:18 <dolio> Sure, althought part 1 is just using a subset of the information of part 2, so you could fold once for both.
06:42:15 <merijn> Any specific reason for optimising this? Or just for shits & giggles? :p
06:42:36 <siraben> shits and giggles
06:42:45 <siraben> also benchmarking is fun :P
06:43:32 * hackage phonetic-languages-simplified-properties-lists 0.3.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-0.3.0.0 (OleksandrZhabenko)
06:45:38 <Taneb> Does GHC have any limits on the number of fields in a record?
06:45:48 <merijn> "probably"
06:46:55 <dolio> It starts having problems with tuples around 64 elements, so it's possible there's a similar problem with other constructors.
06:48:34 <merijn> 62
06:48:58 <merijn> Tuple size 63 and up are commented out with a comment about GHC segfaulting when the higher ones are added
06:49:23 <dolio> I saw some recent discussion where something larger than 62 was mentioned as working.
06:49:46 <oats> it always tickled me that the tuples were manually defined :P
06:50:00 <dolio> I think it was 64 for some SIMD thing.
06:50:13 <merijn> > 2 * 26 + 10
06:50:15 <lambdabot>  62
06:50:20 <merijn> Nope, 62
06:50:30 <merijn> dolio: https://hackage.haskell.org/package/ghc-prim-0.6.1/docs/src/GHC.Tuple.html :p
06:50:55 <dolio> I didn't say there were tuples bigger than 62 defined in that file.
06:51:04 <oats> the greatest haskell file of all time
06:51:11 <z0> is there a significant difference resource wise between cycling a list vs calculating the index mod length? 
06:51:33 <merijn> z0: If you intend to index said list, yes
06:51:45 <dolio> Anyhow, I'm not sure anyone knows what was failing with tuples that big anyway. It could be unrelated to the constructors.
06:51:50 <oats> indexing lists booooo
06:51:50 <merijn> z0: at least, when you start from the beginning each time
06:52:16 <merijn> oats: How can it be the best Haskell file? It has none of the best functions
06:52:55 <oats> merijn: truly you have not reached tuple enlightenment
06:53:10 <merijn> oats: reallyUnsafePtrEquality# is clearly better
06:53:18 <merijn> as is accursedUnutterablePerformIO
06:53:50 <oats> do you like sharing an address space with a malevolent bringer of chaos?
06:54:52 <tomsmeding> yeah some time recently on the mailing list it came up that there was a primop somewhere that returned a 64-tuple, that you couldn't even use because when pattern matching on that tuple ghc said "I don't support tuples longer than 62"
06:56:09 <tomsmeding> this and descendants https://mail.haskell.org/pipermail/ghc-devs/2020-September/019273.html
06:57:53 * int-e just made a single constructor type with 1024 Int fields and ghc didn't complain... it's getting slow to compile though.
07:00:33 * hackage prolude 0.0.0.12 - ITProTV's custom prelude  https://hackage.haskell.org/package/prolude-0.0.0.12 (saramuse)
07:03:19 <exarkun> Anyone know of a nice IRC client library?
07:05:45 <solonarv> z0:   cycle xs !! n   has to follow   n   cons-cells,   xs !! (n `mod` length xs)   only has to follow   length xs + n `mod` length xs   cons cells
07:06:06 <solonarv> (and if you're indexing multiple times, you only have to calculate the length once, of course)
07:19:41 <exarkun> in a `consumer :: MonadIO m => MVar () -> ConduitT (Either ByteString IrcEvent) o m ()` when I try to get some events with `events <- takeC 2` I get a type error - Couldn't match type ‘o’ with ‘Either ByteString IrcEvent’
07:19:51 <exarkun> What does using `takeC` have to do with the output type?
07:20:13 <merijn> exarkun: within a do block all lines must have the same output
07:20:40 <merijn> exarkun: "instance Monad m => Monad (ConduitT i o m)"
07:20:50 <merijn> note that both i and o are fixed there
07:23:49 <exarkun> I think I understand the first part.  I'm not sure if I understand "both i and o are fixed there".
07:24:19 <merijn> exarkun: "ConduitT i o m" (with specific types 'i', 'o', and 'm') forms a monad
07:24:26 <exarkun> Ah ok
07:24:44 <merijn> exarkun: Within a do block all "statements" must have the same type (which has to have a Monad instance)
07:25:17 <merijn> exarkun: Remember that "do { x <- foo; bar x }" translate to "foo >>= \x -> bar x"
07:25:20 <merijn> :t (>>=)
07:25:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:25:36 <exarkun> So with that type declaration, the type of `o` will be inferred from what's in the definition of the function, and since `i` is that `Either ...`, using `takeC` like this tells the type checker that `o` must be the same `Either ...`?
07:25:44 <merijn> the 'm' there is "ConduitT i o m" and it must be the same on each side
07:26:36 <merijn> exarkun: The problem is that "takeC :: ConduitT a a m ()", yeah
07:26:59 <merijn> exarkun: Eh, also note that "events <- takeC 2" probably doesn't do what you expect...
07:27:14 <exarkun> Oh? :/
07:27:23 <merijn> exarkun: That will simply forward 2 inputs downstream and 'events' will be () :p
07:27:29 <exarkun> Oof.
07:27:33 * hackage phonetic-languages-simplified-lists-examples 0.4.0.0 - Simplified and somewhat optimized version of the phonetic-languages-examples.  https://hackage.haskell.org/package/phonetic-languages-simplified-lists-examples-0.4.0.0 (OleksandrZhabenko)
07:27:38 <exarkun> Yea.  That is not what I expected.
07:27:59 <exarkun> Guess I should read the conduit docs harder.
07:28:48 <merijn> exarkun: Since "takeC :: Int -> ConduitT a a m ()" note that the Monad here is "ConduitT a a m" so the "result" in "(>>=) :: Monad m => m a -> (a -> m b) -> m b" the 'a' of >>= is just ()
07:29:11 <z0> solonarv: thanks. i guess i always imagine the possibility of some compiler optimization surprising me
07:29:13 <merijn> exarkun: You need to process 2 events at a time?
07:30:11 <exarkun> merijn: Probably not.  This is my first conduit-using program ever.  I'm actually just trying to throw 4 events in the trash (but also wait for them to happen before moving on).
07:30:40 <merijn> exarkun: that'd be more like "dropC 4" :p
07:31:15 <merijn> exarkun: What do you mean by "wait for them"?
07:31:38 <exarkun> merijn: It's an irc client.  I want to send a message after they've been received.
07:32:20 <exarkun> I see `dropC` has a more favorable type for this... `dropC :: Monad m => Int -> ConduitT a o m ()` so the result is still () but the output type is not fixed as the same as the input type.
07:32:59 <exarkun> Also I see that the conduit docs I was looking at are using `foldC` and I guess that's why they work and my code doesn't ... because foldC also doesn't fix the output and has a useful result type instead of ().
07:34:53 <exarkun> I think I understand `ConduitT` a little better now, at least, thanks
07:37:26 <harwiltz> Hello all. I tried recompiling my XMonad config today, and suddenly the build fails because it can't load XMonad.Actions.Volume.It says that the package xmonad-extras-<hash> is unusable due to missing dependencies, which are all packages with hashes.
07:37:37 <merijn> exarkun: ConduitT is best thought of as a stream/conveyor built "ConduitT i o m r" 'i's go in, 'o's come out, processing might trigger effects 'm' and when done processing input, return 'r'
07:37:49 <harwiltz> When I search for these packages on my system, I find their corresponding libraries but with different hash suffiexs.
07:37:53 <harwiltz> suffixes
07:38:26 <merijn> exarkun: So, "dropC 4" consumes the first 4 'i's coming in (and not sending anything out), then all further 'i's get forwarded to whatever you compose dropC with
07:38:30 <exarkun> merijn: makes sense!  I had only gotten as far as considering i and o before, m and r were off my radar :)
07:40:07 <merijn> exarkun: So you'd do something like 'do { result <- takeC 4 .| yourFold; stuffWith result }" here the first 4 inputs go into yourFold, after which takeC stops giving data (causing the fold to finish and return a result) the remaining inputs go into "stuffWith result"
07:40:48 <harwiltz> Nvm sorry, just rebuilt xmonad-extras and that solved it
07:44:27 <exarkun> merijn: I thiiink I get it.  I'll have practice a bit, probably.
07:45:22 <exarkun> I think I keep confusing the `do`-block monad type with the ConduitT result type
07:45:44 <exarkun> That is, mixing them up when thinking about how the pieces fit together.
07:46:02 <merijn> exarkun: For conduit do notation is for "first process inputs with this conduit, then when it finishes, continue with this one, etc."
07:46:21 <merijn> Whereas you want .| for sequencing things into a stream
07:51:28 <exarkun> Hm I don't think I understand the distinction.  Is it about where processing "continues" from?
07:53:21 <merijn> exarkun: if you have "foo .| bar" inputs go into foo which then yields results to 'bar' for further processing
07:54:18 <exarkun> That part seems pretty straightforward at least :)
07:54:19 <merijn> exarkun: But, suppose you want "foo" to, say, first compute something from the first 4 inputs and then use that to transform the rest, then you get code like above "foo = do { result <- takeC 4 .| yourFold; stuffWith result }'
07:55:11 <exarkun> Maybe since I haven't implemented a fold (nor tried to learn how I would do that), only seen `foldC`, that part is harder to follow.
07:55:27 <merijn> So now all inputs go into 'foo', still. But the first 4 inputs to foo get fed into yourFold (due to takeC 4), which returns a result. Then all other inputs to 'foo' (beyond the first 4) get fed into "stuffWith result" (and the output of that goes to bar)
07:58:16 <exarkun> Apart from how exactly folds are implemented, I think I follow that part.
07:58:55 <exarkun> And it seems like it means that the reason I started using do here - to implement some messy, not-very-well-thought-out-yet logic on message inputs and outputs in an imperative style - might not have been wrong
07:59:50 <merijn> exarkun: Yeah, for Conduit you wanna think in pipeline (stages)
08:00:22 <merijn> "my input is IRC events and I wanna turn that into output X" and then worry about what that means
08:01:59 * exarkun nods
08:02:23 <exarkun> gotta set this aside for now, alas.  thanks very much for the hand holding.
08:06:48 <nshepperd2> muahaha. i now have a parsing library which embeds both PCRE and Read within scanf, within trifecta
08:07:12 <merijn> nshepperd2: I'm pretty sure there are laws against this...
08:07:13 <nshepperd2> unlimited power~
08:07:23 <merijn> Like the Geneva convention >.>
08:07:44 <nshepperd2> all my typeclasses are lawless
08:08:49 <mouseghost> hammurabi codex 
08:11:35 <nshepperd2> an example: parse (scanf "%/[a-z]+/s = %r") "foo = True" :: (Text, Bool)
08:11:43 <nshepperd2> ("foo",True)
08:12:28 <nshepperd2> scanf "%/[a-z]+/s = %r" :: Trifecta.Parser (Text, Bool)
08:12:57 <merijn> I'm not sure whether to be impressed or disgusted
08:13:06 <Clint> why not both
08:13:11 <merijn> How do you know the return type? God awful typeclassery?
08:13:55 <AWizzArd> dminuoso: do you know if Stylish-Haskell now also uses the GHC parser? I think in the past it had its own, but it could break after syntax changes.
08:14:07 <nshepperd2> relatively tame typeclassery
08:14:24 <merijn> Is it time for me to dig up my "auto-formatting is bad and you should feel bad" link again? >.>
08:15:20 <nshepperd2> I have typeclass instances (Scanf a, Scanf b) => Scanf (a, b) which just combine monadic parsers applicatively
08:18:11 <nshepperd2> (you do have to specify put a type signature if the return type is ambiguous. there's no fancy format string typechecker magic)
08:21:07 <AWizzArd> merijn: find that link pls (:
08:26:19 <merijn> AWizzArd: https://twitter.com/comerijn/status/1257804634833420292
08:29:36 <monochrom> You should keep bookmarks of your own tweets.
08:31:02 <merijn> monochrom: I have it bookmarked, actually :p
08:31:21 <merijn> After I had to look it up for the 3rd time :p
08:31:41 <monochrom> I guess in the long term the question "how to search through my bookmarks" and it's the same question all over again.
08:33:25 <boxscape> that's obvious, use meta-bookmarks
08:34:06 <merijn> SQLite database, tags and full-text search, duh
08:34:10 <AWizzArd> hr hr hr
08:36:29 <merijn> Facts: Everything is better with SQLite
08:47:11 <Chousuke> I think Firefox stores bookmarks in a SQLite database? :P
08:47:39 <merijn> It does
08:47:45 <solonarv> however it stores them, it definitely has tags (that I don't use :p)
08:47:54 <merijn> Also, literally every browser uses SQLite
08:48:03 <Chousuke> as they should
08:48:04 <merijn> thunderbird and Apple's Mail.app use it for email too
08:48:12 <Chousuke> SQLite is good software.
08:48:16 <Chousuke> which is rare.
08:49:55 <[exa]> postgresql is cool too
08:50:25 <merijn> [exa]: Different usecase(s) :p
08:50:28 <[exa]> but that pretty much finishes the list of good relational databases. :]
08:50:32 <[exa]> yes, certainly
08:54:33 <Chousuke> both have a focus on being good at what they do and slowly expanding their capabilities rather than first trying to do everything and figuring out how to do it well only afterwards :P
09:05:27 <dsal> sqlite is the sane way to put data into a file.
09:05:38 <dsal> postgres is a pretty good database
09:07:01 <sm[m]> Chousuke++
09:55:31 <justsomeguy> What is your opinion of fossil (the version control software that uses sqlite as a back-end)?
09:58:56 <koz_> Mine is primarily 'whatever its merits, git has network effects and thus it's what'll get used nine times out of ten, merits be damned'.
10:01:55 <Chousuke> My opinion is that git's good enough :P
10:02:22 <monochrom> :)
10:02:46 <Chousuke> the UI is terrible, but the software itself is solid, so the good reasons to use alternatives just often aren't good enough
10:03:35 <justsomeguy> To be honest I've been using various vcs' and still haven't incorporated any of them into my workflow in a productive way. They mostly serve as extended undo rather than a useful microblog of changes with narrative structure.
10:04:57 <koz_> My experience with git is roughly this comic: https://xkcd.com/1597/
10:05:31 <Chousuke> I think git was successful because it was such a huge improvement over the status quo in terms of what it enabled you to do, and it arrived at the right time.
10:05:39 <Sonolin> yup
10:06:10 <Sonolin> being created by Linus Torvalds is a lot of free promo as well
10:06:12 <monochrom> haha koz_.  Although, I haven't run into that kind of problems. (I'm a casual user.)
10:07:17 <Chousuke> I'm pretty comfortable with git nowadays, so people nuking their projects unnecessarily bothers me somewhat :P
10:08:27 <Chousuke> the UI is bad, but its internal workings are so straightforward that I can always just look up whatever magic incantation I need for the operation I want to do if I can't remember it
10:08:44 <Sonolin> yea once you grok it it is really powerful
10:08:58 <Sonolin> SourceTree is nice for those unwilling to learn
10:10:56 <koz_> I'm semi-casual. Like, I've learned worse, but git is far from 'good enough' in my opinion. I just tolerate it because if you wanna contribute to basically anything nowadays you _have_ to know it.
10:11:35 <Chousuke> I mean "good enough" in terms of what you can do with it
10:12:03 <Chousuke> The problem with eg. subversion was that if you wanted to use it to untangle a tricky merge, you just couldn't
10:12:04 * hackage geos 0.4.0 - Bindings for GEOS.  https://hackage.haskell.org/package/geos-0.4.0 (petefrance)
10:12:26 <koz_> I actually used subversion in a professional setting.
10:12:29 <koz_> Never again.
10:12:41 <Chousuke> with git you can make temporary commits and add things piecemeal and rewrite things all you want, and that helps you deal with tricky situations
10:12:41 <koz_> Like, if you can't do the equivalent of .gitignore, you are pretty badly designed IMHO.
10:13:07 <Chousuke> with Subversion you just have a mess in your worktree and no help from the tool :P
10:13:33 * geekosaur remembers when svn was a step *up*, though
10:13:40 <geekosaur> everything is relative
10:13:55 <Chousuke> oh yeah, the first source control I used was RCS :)
10:14:04 <Chousuke> svn is definitely somewhat better than that.
10:14:07 <geekosaur> I started out on SCCS
10:14:30 * monochrom came from the time of .cvsignore
10:15:16 <dminuoso> Is there a typeclass that gives us sort of equality of Maybe a or say Nothing ~= Just ""
10:15:24 <dminuoso> Or Nothing ~= Just []
10:15:24 <monochrom> So if you also mean that subversion can't do the equivalent of .cvsignore, that's disappointing. subversion was supposed to be one level up above cvs.
10:15:38 <koz_> monochrom: AFAICT, no.
10:15:52 <Chousuke> and Subversion is still decent for completely linear things like configuration, or for storing versions of binary artifacts.
10:15:54 <jle`> dminuoso: compare on fold, maybe
10:16:15 <Sonolin> SVN always took *forever* to do anything too
10:16:28 <dminuoso> jle`: Mmm, that would only work on foldables. The "" was supposed to talk about Text actually
10:16:43 <dminuoso> Sorry about that, my brain is currently locked into OverloadedStrings
10:16:46 <Chousuke> that's because if you deploy it the "standard" way, it does a gajillion HTTP requests to the server for pretty much anything
10:17:16 <dminuoso> Also, I might need `Nothing ~= Just 0` as well..
10:17:48 <Chousuke> at one point at work we had a graph showing audit failures against AD
10:18:03 <dminuoso> For context, Im dealing with a particularly bad API that for some "unset" fields it gives me `{ "foo": "" }`, other times it gives me {"foo": null} or it just leaves the attribute away
10:18:05 <Chousuke> and also audit successes
10:18:22 <Chousuke> and there were noticeable spikes in those numbers when someone checked out a large svn repo :P
10:18:28 <dminuoso> And I want to write tests that verify that the thing Im putting in is the thing Im getting out..
10:18:47 <geekosaur> nothing built in, because it's kinda poorly specified. depending on approach I could see Data.Default or Monoid
10:20:10 <geekosaur> but combining either one with Maybe is a problem
10:21:24 <geekosaur> some custom wrapped Maybe whose comparison function "promotes" Nothing to mempty (and unwraps a Just)?
10:21:58 <dminuoso> % lower x | x == empty = Nothing; lower x = Just x
10:21:59 <yahb> dminuoso: 
10:22:15 <dminuoso> % l =&= r == (lower =<< l) == (lower =<< r)
10:22:15 <yahb> dminuoso: ; <interactive>:30:1: error: Precedence parsing error cannot mix `==' [infix 4] and `==' [infix 4] in the same infix expression
10:22:24 <dminuoso> % l =&= r = (lower =<< l) == (lower =<< r)
10:22:24 <yahb> dminuoso: 
10:22:36 <dminuoso> % Just "" =&= Nothing
10:22:36 <yahb> dminuoso: True
10:22:44 <dminuoso> Mmm.
10:23:19 <dminuoso> geekosaur: ah yeah, promoting the other way seems saner.
10:23:32 <monochrom> dminuoso: I wonder if instead of coding up a special equality, code up a normalization, Just a -> a, Nothing -> mempty or default.
10:23:50 <geekosaur> that was basically what I proposed
10:25:00 <dminuoso> Cheers, I think Ill go that road. I was on the tree of going the other direction, and it felt like unnecessary extra work
10:25:03 <dminuoso> And the bind was weird
10:25:30 <monochrom> @type fold
10:25:32 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:25:53 <monochrom> Yeah the normalization looks like fold if the wrapped type is a Foldable.
10:26:14 <monochrom> Although, to get "Nothing -> 0" you have to jump through the hoop of Sum...
10:26:37 <geekosaur> yeh, the problem there being Text is MonoFoldable…
10:27:21 <monochrom> fromMaybe is a pretty low-tech one-liner solution for all cases.
10:27:52 <monochrom> Don't bring in Day convolution if a simple fromMaybe does the job :)
10:29:29 <zyklotomic> is it a bad idea to have a dependency on something like microlens?
10:30:04 <zyklotomic> I want to use https://hackage.haskell.org/package/microlens for only a very small component just for slightly cleaner code
10:30:13 <zyklotomic> are dependencies usually a bad idea
10:31:45 <geekosaur> actually practically everything in the haskell world has dependencies
10:32:19 <geekosaur> this is not a "everything but the kitchen sink is in base" ecosystem
10:34:27 <monochrom> Pulling in a huge library just to use one single thing from it, and it is a one-liner "foo f g x y z = f x (g y z)", that's a bad idea.
10:34:46 <monochrom> Pulling in a huge library because you actually use, say, 60% of it, that's a good idea.
10:34:56 <monochrom> In other words, as always, it depends.
10:37:00 <koz_> Also, not everythign that looks like a dependency truly is. vector or containers, for example, come with GHC.
10:37:21 <monochrom> vector still doesn't. containers does.
10:37:33 * hackage circular 0.2.0 - Circular fixed-sized mutable vectors  https://hackage.haskell.org/package/circular-0.2.0 (dschrempf)
10:37:37 <monochrom> text did not, but does now, since 8.6 or something
10:38:00 <koz_> monochrom: Wait really? Vector _isn't_ a boot library?
10:38:05 <monochrom> No.
10:38:07 <koz_> TIL.
10:38:16 <koz_> Ah, because it's _array_, right?
10:38:26 <geekosaur> Array's the bootlib, yes
10:38:33 * hackage geos 0.4.1 - Bindings for GEOS.  https://hackage.haskell.org/package/geos-0.4.1 (petefrance)
10:38:35 <monochrom> containers isn't a boot library in the strictest sense either. But someone decided it's good to include.
10:39:12 <monochrom> And I am grateful that I don't have to take 20 minutes to rebuild text for every new version of GHC.
10:40:26 <geekosaur> wasn't it that it used to be and was never really removed after TH or ghc-lib was reworked to not expose containers?
10:41:24 <monochrom> I don't know. But interesting.
10:41:38 <zyklotomic> that makes sense, it just feels uncomfortable having dependencies for small things, even somehing like vector
10:41:44 <monochrom> I can believe it's more like someone forgot to exclude it, heh.
10:42:34 <geekosaur> ot sure it's "forgot" or "too many people just blindly assume it's there now"
10:43:21 <monochrom> mtl went through several toggles
10:44:21 <monochrom> to give you a sense that these things can be observatinally equivalent to politics.
10:44:52 <monochrom> Don't look for a technical-merit explanation when a political explanation suffices.
10:51:02 * hackage mmsyn7h 0.8.1.0 - Produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.8.1.0 (OleksandrZhabenko)
11:01:53 <hyperisco> is there a way to run processes (like createProcess) but work with handles with Text instead of String?
11:02:24 <merijn> zyklotomic: Why though? Isn't great that something as incredibly wired in and unchangeable as "arrays" in other languages can simply be implemented as a library?
11:03:21 <monochrom> That goes to what I sometimes explain to students.
11:03:58 <monochrom> It is a triumph of language design that, for example, cons list can be user-defined in Haskell, and even made as efficient as any "built-in primitive" story.
11:04:22 <tomjaguarpaw> hyperisco: What do you mean? Do you want functions like  hGetLine :: Handle -> IO Text ?
11:04:30 <hyperisco> yeah
11:04:57 <monochrom> But if everyone did define their own cons lists, inter-operability of two libraries would go out of the Window. It is still a good idea that the standard library provides one version so everyone is on the same page.
11:05:00 <tomjaguarpaw> hyperisco: https://www.stackage.org/lts-13.21/hoogle?q=Handle%20-%3E%20IO%20Text
11:05:05 <tomjaguarpaw> Those?
11:05:20 <hyperisco> duuno, it isn't loaded
11:05:32 <tomjaguarpaw> Stackage can be pretty slow ...
11:05:40 <hyperisco> there it goes, yes, thanks
11:06:00 <tomjaguarpaw> You're welcome
11:07:15 <monochrom> Actually cons list is not even the most convincing example.
11:07:24 <monochrom> Here is the most convincing example: Booleans.
11:08:45 <monochrom> Booleans can be user-defined in Haskell. Hackage could be full of user-defined third-party boolean libraries.
11:09:03 * hackage haskoin-store 0.38.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.38.4 (jprupp)
11:09:53 <monochrom> This is a triumph of core language design. But if we really allowed proliferation of third-party booleans on hackage just because "isn't it cool that GHC is decoupled from booleans?", well that actually is far from cool.
11:10:03 * hackage r-glpk-phonetic-languages-ukrainian-durations 0.2.2.0 - Can be used to calculate the durations of the approximations of the Ukrainian phonemes.  https://hackage.haskell.org/package/r-glpk-phonetic-languages-ukrainian-durations-0.2.2.0 (OleksandrZhabenko)
11:12:51 <hyperisco> hm I guess there is this too which is a little annoying https://hackage.haskell.org/package/process-1.6.10.0/docs/System-Process.html#v:proc
11:15:39 <tomjaguarpaw> hyperisco: You mean that it takes Strings rather than Texts?
11:15:45 <hyperisco> yes
11:16:06 <tomjaguarpaw> Yeah, I don't know any API that uses Text for createProcess. Perhaps one exists.
11:38:04 * hackage mail-pool 2.2.2 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.2.2 (Jappie)
11:59:33 <hyperisco> any reason you can think stack is suddenly taking over a minute to link a small program
12:01:51 <monochrom> bad sector
12:02:56 <hyperisco> man I have enough spurious problems don't be saying that
12:08:03 * hackage chessIO 0.5.0.0 - Basic chess library  https://hackage.haskell.org/package/chessIO-0.5.0.0 (mlang)
12:16:04 * hackage mail-pool 2.2.3 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.2.3 (Jappie)
12:24:47 <dminuoso>  19:27:29     monochrom | Don't bring in Day convolution if a simple fromMaybe does the job :)
12:24:53 <dminuoso> Hold on, I can use Day convolution here?
12:25:09 <geekosaur> heh
12:25:27 <monochrom> No, I'm just tossing out Day convolution blindly as a stereotypical example of advanced math.
12:25:49 <monochrom> Like, "adjunction" is no longer intimidating.
12:38:23 <dolio> You mean, basic math that people are scared of. Not advanced math.
12:49:18 <monochrom> Yeah OK!
12:57:38 <sclv> if i want the first Just from a list of Maybes (or Nothing) then `listToMaybe . catMaybes` does the trick
12:57:56 <sclv> I don't recall if there's something slicker, codegolfwise
12:58:01 <sclv> using the First monoid is more verbose
12:58:16 <sclv> maybe like an alternative concat or something?
12:58:37 <jle`> > asum [Nothing, Just 3, Just 4, Nothing, Just 5]
12:58:39 <lambdabot>  Just 3
12:58:50 <jle`> not that it's any more readable
12:59:20 <geekosaur> they're doing code golf, readable isn't a constraint
12:59:59 <ephemient> :t join . find isJust -- was my first thought, but `asum` probably can't be beat
13:00:01 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
13:00:23 <dminuoso> Maybe monochrom knows how to use Day here? ..
13:00:27 * dminuoso smiles
13:00:34 * geekosaur was poking asum but jle` beat him to it
13:00:46 <oats> stupid idea of the day: rename 'Just' to 'A'
13:00:50 <dsal> asum is a good thing to know.  I've also used it for more effectful stuff like "which of these works?"
13:00:55 <oats> [Nothing, A 3, A 4, Nothing, A 5]
13:01:14 <pjb> s/Nothing/A_Nothing/g
13:01:17 <jle`> Nothing = NotA
13:01:34 <dminuoso> If you're going to break hackage, at least break it properly and just flip Nothing and Just.
13:01:35 <jle`> or maybe Nada
13:01:47 <dminuoso> [Just, Nothing 3, Nothing 4, Just, Nothing 5]
13:01:52 <dsal> Just and Unjust
13:01:54 <oats> lol
13:02:04 <monochrom> Since an infinite list is involved, I would take a co-limit in an O-category... >:)
13:02:34 <dminuoso> jle`: Think we should revive the idea we floated around 2-3 years ago, or what Haskell would be if Germany had won the war.
13:02:50 <monochrom> Yikes.
13:03:04 <jle`> i literally have no recollection of this conversation D:
13:03:13 <monochrom> Iron Sky Haskell?
13:03:14 <lambda> hi, looking for a point-free version of `[0,x..]`, something like `multiplesOf`, but I can't find anything - does a function for this exist in base?
13:03:37 <merijn> lambda: enumFromThen ? :p
13:03:41 <merijn> :t enumFromThen
13:03:42 <lambdabot> Enum a => a -> a -> [a]
13:03:48 <dminuoso> The language would be called Schönfinkel (I know it's not German, but it it sounds Germany so its too good to pass up on)
13:03:48 <oats> [Nichts, Ein 3, Ein 4, Nichts...]
13:03:49 <merijn> > enumFromThen 0 3
13:03:52 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
13:04:05 <dminuoso> And currying would be schönfinkeln...
13:04:13 <oats> well, s/Ein/Nur
13:04:13 <merijn> lambda: the [..] syntax is just syntactic sugar for various Enum operations
13:04:24 <dminuoso> oats: Dont translate literallz
13:04:29 <dminuoso> Nichts and Ein sound perfect.
13:04:30 <lambda> merijn: oh, yep, totally missed that - I only saw enumFrom
13:04:31 <oats> yassss
13:05:37 <dminuoso> instanz Anwendbar Vielleicht wobei abbilden f Nichts = Nichts; abbilden f (Nur x) = Nur (f x)
13:05:39 <dminuoso> It's perfect
13:06:18 <sclv> thanks for asum, hoogle took me there too
13:06:18 <oats> lololol
13:06:55 <oats> what would monads be called?
13:07:04 <oats> monad, rather
13:08:13 <dminuoso> Well, Monade or Monas have greek stems
13:08:43 <oats> how about "Abflachungzeug" :P
13:08:44 <dminuoso> Depending on how Hitler would have designed the Münchener Schönfinkel Kompilierer, that might have been permissable
13:09:29 <oats> MSK lol, I love it
13:10:06 <zyklotomic> is it possible to have the update record syntax refer to its respective parameter?
13:10:23 <dminuoso> zyklotomic: Not currently
13:10:34 <dminuoso> IIRC there is a proposal in progress to address this.
13:10:57 <zyklotomic> like data Pog = Pog { a :: Int, b :: Int } --> p = Pog 5 7; p = Pog { a = a + 1 } right?
13:11:15 <zyklotomic> just in case I didn't describe it clearly enough
13:11:28 <jle`> yeah, there's no syntax at the moment
13:11:48 <jle`> but there are some lightweight lensy solutions for it
13:11:55 <zyklotomic> % right
13:11:56 <yahb> zyklotomic: ; <interactive>:33:1: error:; * No instance for (Show (a0 b0 c0 -> a0 (Either d0 b0) (Either d0 c0))) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
13:11:58 <merijn> RecordWildCards can do it
13:12:08 <jle`> oh yea, but only one at a time
13:12:12 <dminuoso> Mmm, no. RecordDotSyntax doesnt quite do it.
13:12:19 <dminuoso> zyklotomic: The best we have currently is what lens/optics offers us.
13:12:29 <merijn> "f p@Pog{..} = p{ a = a + 1}"
13:12:41 <merijn> jle`: What? No, that should work for any number of fields
13:12:41 <dminuoso> Yeah. RecordWildCards at its worst.
13:12:56 <dminuoso> It's unhygeniec.
13:13:33 <zyklotomic> so a naive question at that, hope you don't mind, but would it make sense to make this standard/official syntax, the lensy behavior
13:13:39 <merijn> dminuoso: I wasn't asked for a *good* solution, just *a* solutions
13:13:56 <dminuoso> zyklotomic: So roughly if you had a field _foo with an appropriate lens foo
13:14:03 <merijn> zyklotomic: Theoretically? Maybe
13:14:11 <jle`> merijn: ah, like, myFunc Pog{..} Pog{..} = ...
13:14:18 <geekosaur> zyklotomic, if you hadn't noticed, there's still a fair amount of argument over what the right approach is
13:14:21 <merijn> zyklotomic: Realistically: It's not happening anytime soon :p
13:14:28 <dminuoso> zyklotomic: oh hold on. No, because its not just syntax.
13:14:43 <ephemient> `{-# LANGUAGE NamedFieldPuns #-} f p@Pog {a} = p {a = a + 1}` less unhygenic?
13:14:54 <merijn> zyklotomic: Basically: "Would it make sense for new languages to be designed with lenses for the fields?" 'definitely'
13:14:54 <zyklotomic> because they are technically functions?
13:15:13 <merijn> zyklotomic: "Is it a good idea to *retroactively* change this?" 'probably not'
13:15:16 <dminuoso> zyklotomic: The novelty of optics/lenses is that we get to have a non-syntactical but first-class way of splitting data into whats in focus and whats not.
13:15:17 <zyklotomic> i'm a beginner so a lot of this context is lost on me
13:15:28 <geekosaur> meanwhile many people use lens to do it, but lens is large and you have to derive lenses for your records
13:15:40 <dminuoso> zyklotomic: Note the *non-syntactical* part here.
13:16:00 <zyklotomic> dminuoso: yes or maybe I should rephrase it, making it more "standard"?
13:16:18 <dminuoso> zyklotomic: Well the rough interface of lens has become de-facto standard in Haskell. 
13:16:21 <zyklotomic> like you have to use the very large lenses library
13:16:26 <zyklotomic> ah I see
13:16:27 <dminuoso> Even the newer library `optics` matches it closely
13:16:44 <dminuoso> zyklotomic: You can use microlenses or optics-core if you want a more lightweight approach
13:17:08 <zyklotomic> i think a struggle i have had is that "de facto" is very obscure
13:17:13 <zyklotomic> *or finding out what is de facto
13:17:19 <jle`> with library support you could do something like `over #a (+ 3) p`. not quite syntax, just library built on top of the language (if you derive a Generic instance for Pog)
13:17:55 <zyklotomic> dminuoso: yup, I asked a question earlier about microlenses but it felt wrong pulling in a dependecy just to modify a data type
13:18:15 <dminuoso> Right. For a single use site I wouldn't consider it.
13:18:47 <zyklotomic> jle`: yeah, I realize it isn't necessarily syntax per se, I meant like part of the "core"? I really don't know what to call it
13:18:59 <zyklotomic> kinda lke how Monads aren't part of the language, they're defined in terms of the language right?
13:19:12 <dminuoso> Well, its both
13:19:21 <sclv> well Monads are part of the language, because "do notation" is baked into the spec
13:19:32 <jle`> yeah heh, it's a little bit of both, but i see the point you're trying to make
13:19:38 <dminuoso> The typeclass Monad is defined in the Haskell report, but the typeclass is just a plain haskell typeclass you could have written yourself
13:19:42 <sclv> you could define the language without Monads and define them independently and you'd have everything but the donation
13:19:44 <sclv> er the notation
13:19:56 <jle`> you're getting a donation?
13:20:14 <zyklotomic> yeah, I think the issue I have is like decoupling which part is which? what is GHC, what is Prelude, what is a seperate package, etc.
13:20:14 <dminuoso> or denotion?
13:20:23 <sclv> wow there's dyslexia and there's swapping in a whole word lol
13:20:32 <dminuoso> zyklotomic: Oh yeah, that GHC part is brought up regularly in various places
13:20:39 <dminuoso> Some argue that GHC shouldnt come in base..
13:20:48 <sclv> Haskell the language is the Report. Then GHC has a bunch of stuff on top
13:20:54 <sclv> Prelude is in the report
13:21:00 <dminuoso> (By GHC I mean the module hierarchy of GHC.xxx)
13:21:15 <sclv> but even in the report there's the "heart" of haskell and then there's the defined libs and functions
13:21:24 <sclv> layers of onion
13:21:56 <dminuoso> zyklotomic: I guess this "field update notation" isn't as important in the realm of Haskell, perhaps because of how Haskellers tend to write code it might not see as much use.
13:21:57 <jle`> zyklotomic: there's the base "package" (i use package interchangeably with 'library' here) that's included with ghc, and there is are a few libraries that are used in ghc's source code ('boot packages') which are somewhat considered to be standard/reliable to depend on
13:22:05 <jle`> but there's a bit of a nebulous cloud outside of that
13:22:22 <dminuoso> There's the odd case where I might want it, but I dont think it'd justify a modification to syntax.
13:22:36 <jle`> there is some movement for "built-in lenses" to be built within the language, with a special magic typeclass, i think
13:22:50 <dminuoso> jle`: you mean OverloadedLabels?
13:22:57 <zyklotomic> dminuoso: could you elaborate on the how Haskellers tend to write code part, curious
13:22:58 <dminuoso> Or even more magical?
13:23:09 <jle`> OverloadedLabels is already here, it supports `over #a (+ 3) p` above
13:23:28 <jle`> dminuoso: i'm tlaking about like HasField
13:23:31 <dminuoso> zyklotomic: I cant put my finger quite on it, but in the past 3 years I can count the occurences of "relative field updates" on a single hand.
13:23:40 <dminuoso> For my own code.
13:23:54 <dminuoso> All were done with optics because the library was already in the code anyway
13:24:28 <koz_> I don't quite understand how this note applies to StateT for MonadLogic: http://hackage.haskell.org/package/logict-0.7.0.3/docs/src/Control.Monad.Logic.Class.html#line-121
13:24:41 <jle`> dminuoso: we're one step away from it, for https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Records.html
13:24:52 <koz_> Does that mean that even though you stack StateT s Logic a, the state won't split when the computation does?
13:24:54 <dminuoso> jle`: ah
13:25:12 <zyklotomic> dminuoso: maybe this whole thing is a code smell, I'm doing something with a buffer inside State, and i'm basically pushing on and popping off that buffer
13:25:16 <jle`> but still i think without deeper support for lens within the language, just "having the lens" isn't really good enough
13:25:26 <koz_> I would assume the state _would_ split, as StateT s Logic a ~ s -> Logic (a, s)
13:25:31 <zyklotomic> hence why this idea/want came to my mind
13:25:43 <dminuoso> zyklotomic: Im not saying it never happens. If you want you can show your code, but it's not unreasonable to ask for it.
13:26:06 <dminuoso> More specifically, Im not saying it's a code smell, just that it doesn't happen too often in idiomatic haskell.
13:26:08 <koz_> More precisely - I _want_ each 'solution' to have its own pet state.
13:26:11 <jle`> and yeah, i am not even claiming that deeper support for lens within the language is a good idea
13:26:20 <zyklotomic> dminuoso: ah thanks for the offer I see
13:26:47 <jle`> but i do think optics is the nicest user-friendly lens interface i've seen so far
13:26:52 <dminuoso> Indeed. :)
13:27:09 <dminuoso> It wasnt until optics was released, and I had a long talk with Adam, that I started using it.
13:27:13 <dminuoso> Haven't looked back ever since
13:27:29 <dminuoso> lens was too intimidating with illegible errors
13:28:04 <jle`> lens has an important role in exploring the concepts loose and fast, maybe. i don't think one could have jumped straight to an optics interface
13:28:15 <jle`> but maybe the same thing could be said of haskell and the rest of the PL ecosystem
13:28:18 <dminuoso> Also what's nice about optics-core is that it has a light dependency footprint and *still* gives you Prism and Iso.
13:29:18 <zyklotomic> dminuoso: in fact, uhh it's python https://github.com/fxsjy/jieba/blob/67fa2e36e72f69d9134b8a1037b83fbb070b9775/jieba/__init__.py#L249
13:30:04 <zyklotomic> so i'm basically trying to recreate this algorithm in haskell
13:30:07 <dminuoso> I see.
13:30:13 <zyklotomic> the __cut_DAG function was where I employed State and a buffer, or am I going about it the wrong way
13:30:31 <zyklotomic> and as you can see, there's that pushing and popping off the buffer behavior
13:31:18 <dminuoso> It's hard to say on the spot. Generally, mapping algorithms directly into Haskell is ont ideal
13:32:10 <dolio> I think the main thing would be that I wouldn't springle direct record munging all over my code, generally.
13:32:40 <dolio> There might be some key manipulations to factor out and then refer to elsewhere.
13:32:41 <zyklotomic> yeah, but for this one specifically, I guess I struggled to find any easier way to have this kind of logic i guess
13:33:51 <koz_> As a random aside, I am disappointed that it's not called 'These1s'. :P
13:35:27 <dminuoso> zyklotomic: Can you roughly describe what this does?
13:38:12 <zyklotomic> dminuoso: yeah sure, it is a word segmentation algorithm, algorith wise, it has a split string such as "abcdefg" -> ["a", "bc", "def", "g"], and the part that I shared is checking if the list
13:38:21 <zyklotomic> ["a", "bc", "def", "g"] can be split any further
13:38:43 <zyklotomic> the imperative python code you see loops through each of these split segments, if the segment is of length 1, it pushes it onto buffer
13:38:54 <dminuoso> Presumably this has to do with Chinese linguistics?
13:38:56 <zyklotomic> if it is not length 1, check if the buffer is empty, if not, split
13:38:58 <zyklotomic> yup lol
13:39:27 <zyklotomic> and so on, if that makes sense
13:39:44 <dminuoso> So that sounds like a very simple task for Conduit
13:40:25 <dminuoso> Or I guess you could do this directly on a list
13:40:41 <dminuoso> in which case such a "buffer" would just be a function argument, wouldnt even bother with StateT here
13:40:43 <zyklotomic> I've no experience with Conduit lol
13:41:31 <zyklotomic> I think it was because it felt a lot more complex to make it completely functional when I first started trying to write it
13:41:48 <zyklotomic> could you give a dumb downed reason how Conduit would work
13:42:07 <dminuoso> Let me make up a similar problem and show you how it could be solved
13:57:48 <zyklotomic> dminuoso: i really appreciate it, but i gotta go, i'll most certainly pop back in if you do create that example
14:23:10 <ezzieyguywuf> I tried to reproduce this on a smaller program but was unable to do so. Currently, the output shown in the comment above `main` is what I get, but I can't understand why the prompt is being printed AFTER I hit enter. https://dpaste.com/2QFM9VS94
14:23:18 <ezzieyguywuf> the relevant function in `promptMatch`
14:25:43 <ezzieyguywuf> hrm, turns out that changing to TextIO.putStrLn fixes it, but again I was unable to reproduce this on a smaller scale
14:25:46 <ezzieyguywuf> weird
14:25:52 <iqubic> jle`: How does OverloadedLabels work with Lens again? Like how do you set that up?
14:26:10 <isovector1> jle`: just read your post on shuffling groups and it was the most clarifying thing i've ever seen on groups. thanks!!
14:26:12 <iqubic> I can I get that to automatically generate lenses for my custom data?
14:26:22 <ezzieyguywuf> this was my attempt to reproduce https://dpaste.com/CHPNWYGL4
14:26:45 <exarkun> irc-conduit wants a ConduitT with (Either ... IrcMessage) as its output type.  What if I have an input to my pipeline for which I want to generate more than one IrcMessage?
14:26:54 <isovector1> jle`: how come you're not on planet haskell?
14:27:58 <isovector1> jle`: oh it looks like your rss feed is broken. most recent post i'm seeing is from 2013
14:28:06 <exarkun> is this what unfoldC is for?
14:28:55 <iqubic> exarkun: It's like unfoldr, but puts outputs into a conduit, instead of a list.
14:31:35 <monochrom> ezzieyguywuf: I can reproduce. Expect different behaviour between {build exe and run} and {runghc or ghci}.  This is general line-buffering issue.  If you use putStr without newline, and you want it to "happen right now", hFlush.
14:32:07 <ezzieyguywuf> monochrom: ah hah, thank you for the tip.
14:38:06 <dminuoso> monochrom: https://gist.github.com/dminuoso/78b9e52de12306ce5511d367200dbebe
14:38:10 <dminuoso> Works like a charm, cheers!
14:40:47 <dminuoso> iqubic: So OverloadedLabels essentially gives you variables identifiable by type level symbols
14:41:07 <dminuoso> OverloadedLabels is just syntax sugar for `fromLabel @"Foobar"`
14:41:11 <iqubic> How can I use that with Generic Lenes?
14:42:13 <iqubic> *lenses
14:42:15 <dminuoso> See https://hackage.haskell.org/package/generic-lens-2.0.0.0/docs/Data-Generics-Labels.html
14:44:38 <iqubic> That's a bit confusing.
14:46:34 <dminuoso> instance ( capital ~ BeginsWithCapital name, IsLabelHelper capital name p f s t a b, pafb ~ p a (f b), psft ~ p s (f t)) => IsLabel name (pafb -> psft) where
14:47:26 <dminuoso> So say you wrote `#_Foo` in your code somehow, this would get desugared into `fromLabel @"_Foo"`
14:47:39 <dminuoso> Then set `name` to "_Foo"
14:48:22 <iqubic> And just importing Data.Generic.Lens does this for me?
14:48:26 <dminuoso> Based on type inference of the resulting type it knows p, f, s, t, a and b
14:48:40 <dminuoso> And some tyfams/fundeps + generics
14:48:45 <dminuoso> And voila, you have a prism
14:50:38 <iqubic> Do I need to invoke any fancy template haskell stuff?
14:51:27 <dminuoso> No.
14:51:50 <iqubic> I'm not sure I understand.
14:51:59 <iqubic> It's fine though.
14:53:33 <dminuoso> Very handwavingly, you can imagine the implementation of the above instance to be `instance ... => IsLabel name (pafb -> psft) where fromLabel = to . genericThing`
14:53:59 <dminuoso> The rest from there is just simple plain generics
14:54:18 <dminuoso> The type level symbols is passed into the generics code so it can find the correct field
14:55:13 <iqubic> I understand how that works.
14:55:34 <iqubic> It's the part about using these lenses in real code.
14:55:58 <dminuoso> What do you mean? They are like any other lens
14:56:28 <dminuoso> Potentially not as efficient in degenerate cases, but other than that it's the same
14:58:04 <iqubic> Let's say I have "data Foo a = Foo {Bar :: (Int, a), Baz :: Int}" How would I go about changing the int in the Bar tuple?
14:59:03 <dminuoso> Assuming you meant to write bar and baz (lowercase), then that'd be:
14:59:15 <iqubic> I did mean for it to be lowercase.
14:59:21 <dminuoso> f & #bar . _1 %~ f
14:59:28 <dminuoso> err
14:59:30 <dminuoso> x & #bar . _1 %~ f
14:59:37 <iqubic> Oh, is that all?
14:59:41 <dminuoso> Yes.
15:01:30 <iqubic> I see. Is it possible to use this for other things like as the argument to typed? https://hackage.haskell.org/package/generic-lens-2.0.0.0/docs/Data-Generics-Product-Typed.html#t:HasType
15:02:30 <iqubic> Or would I still need to use type applications?
15:04:50 <dminuoso> That doesn't make much sense..
15:08:30 <sondr3> I have a weird problem doing lookups in a Map: https://gist.github.com/sondr3/c76dd36778cef870daff78b32051e228. It's a `Map Text Bool` and looking up "*" fails but "/" and any other texts work
15:12:16 <dminuoso> % m = M.fromAscList [("+", True),("-",False),("/",True),("*",True)]; m :: M.Map String Boo
15:12:16 <yahb> dminuoso: ; <interactive>:49:86: error:; Not in scope: type constructor or class `Boo'; Perhaps you meant `Bool' (imported from Prelude)
15:12:18 <dminuoso> % m = M.fromAscList [("+", True),("-",False),("/",True),("*",True)]; m :: M.Map String Bool
15:12:19 <yahb> dminuoso: 
15:12:26 <dminuoso> % M.lookup "*" m
15:12:27 <yahb> dminuoso: Nothing
15:12:46 <dminuoso> % print m
15:12:46 <yahb> dminuoso: fromList [("+",True),("-",False),("/",True),("*",True)]
15:12:56 <dminuoso> % lookup "*" (M.toList m)
15:12:56 <yahb> dminuoso: Just True
15:12:59 <dminuoso> huh
15:15:46 <sondr3> At least it's not just me
15:15:47 <dminuoso> Oh
15:15:50 <dminuoso> M.fromAscList
15:16:05 <dminuoso> You're probably violating the precondition that the keys are ascending
15:16:17 <dminuoso> % "*" > "/"
15:16:18 <yahb> dminuoso: False
15:16:21 <dminuoso> There you go.
15:16:31 <dminuoso> (It will not check)
15:16:38 <sondr3> Oh, I had no idea that was a thing
15:16:42 <dminuoso> "O(n). Build a map from an ascending list in linear time. The precondition (input list is ascending) is not checked."
15:17:27 <sondr3> Oh lord, yeah, I have no idea why I chose that over just M.fromList
15:17:42 <sondr3> That's a brainfart
15:17:53 <sondr3> Thanks dminuoso 
15:33:41 <koz_> :t intercalate
15:33:44 <lambdabot> [a] -> [[a]] -> [a]
15:33:49 <koz_> :t intersperse
15:33:51 <lambdabot> a -> [a] -> [a]
15:37:45 <koz_> @hoogle intersperse
15:37:45 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:37:45 <lambdabot> Data.List.NonEmpty intersperse :: a -> NonEmpty a -> NonEmpty a
15:37:46 <lambdabot> GHC.OldList intersperse :: a -> [a] -> [a]
16:08:33 * hackage language-dickinson 1.4.1.2 - A language for generative literature  https://hackage.haskell.org/package/language-dickinson-1.4.1.2 (vmchale)
16:19:42 <texasmynsted> is there a way to derive a Show instance for a type from an included module? Example: https://jaspervdj.be/hakyll/reference/src/Hakyll-Web-Template-Context.html
16:19:50 <texasmynsted> I want to show Context
16:20:42 <hpc> turn on orphan instances, and you need its data constructors in scope
16:21:30 <hpc> you won't be able to show Context values though, there's no Show instance for functions
16:21:57 <hpc> if you did write one, the best you could get is show = const "Context <function>" or something along those lines
16:23:31 <texasmynsted> Isn't Context just a newtype wrapper to provide a monoid?
16:24:06 <texasmynsted> hmm. I just want to see all the fields in the Context. 
16:24:44 <hpc> newtype Context a = Context {unContext :: String -> [String] -> Item a -> Compiler ContextField}
16:25:02 <hpc> it has one field, unContext
16:25:08 <hpc> which is a function that takes etc etc
16:25:21 <hpc> you can't show what parameters the function takes because it hasn't been given any yet
16:25:44 <texasmynsted> right okay
17:59:35 <Feuermagier> is there a function like "init" but for the first element of a list?
18:00:03 <Feuermagier> oh, wait
18:00:05 <jle`> Feuermagier: what would it return for [1,2,3] ?
18:00:06 <Feuermagier> thats just tail
18:00:13 <Feuermagier> lol
18:00:46 <jle`> iqubic: just import https://hackage.haskell.org/package/generic-lens-2.0.0.0/docs/Data-Generics-Labels.html
18:07:15 <iqubic> jle`: And then all the lenses I need will be automatically created when I
18:07:36 <iqubic> When I use "#foo" as the lens name?
18:09:03 * hackage kempe 0.1.0.1 - Kempe compiler  https://hackage.haskell.org/package/kempe-0.1.0.1 (vmchale)
18:10:19 <siraben> Has anyone got https://github.com/mathandley/AutoBench to build via Nix?
18:11:22 <jle`> iqubic: you'd need a Generic instance for your data type
18:11:37 <iqubic> Oh. But can't I derive that for free?
18:11:56 <jle`> yeah, you can derive it with GHC
18:12:51 <iqubic> Yeah. I was thinking I could derive that for free like I can with Eq and Show and Ord and such.
18:14:30 <exarkun> I never noticed stack.yaml.lock files before.  What do I do with these?  Check them into vcs?  Ignore them?
18:18:03 <int-e> $SEARCHENGINE suggests https://docs.haskellstack.org/en/stable/lock_files/
18:20:04 <exarkun> How prosaic.
18:20:07 <exarkun> Thanks.
18:20:58 <int-e> (not sure what the best practice is. my gut feeling would be to ignore them unless build plans are actually fragile)
18:22:06 * int-e is not a stack user though
18:58:34 * hackage taffybar 3.2.3 - A desktop bar similar to xmobar, but with more GUI  https://hackage.haskell.org/package/taffybar-3.2.3 (eyevanmalicesun)
19:35:56 <nolrai> So I want to get the file and line number like what an assert gets you but in my own error handler..is there an easier then throwing an assert then catching it?
19:36:54 <nolrai> I could swear I've read an article on how to do this, but it was a while ago.
19:40:23 <nolrai> Man its quiet in here, I used to there being some weird conversation here at all times. Or is my memory playing tricks on me?
19:48:13 <Vulfe> hey, anyone seen any good deals on left kan extensions recently?
19:53:17 <jle`> fresh outta left, only got rights now
19:53:39 <Axman6> bloody typical
19:53:48 <Axman6> no one needs rights
19:54:15 <int-e> with that attitude, you have no leg to stand on
19:54:45 <int-e> (anything to get away from c**egory the**y)
21:00:31 <crestfallen> hi how do I write something like this is a parser do block? :   guard $ notElem (x:xs) keywords    ( I saw this in a question on SO re: parsing variable names, but I'm not sure if it's riddled with errors or deprecated ) thanks
21:03:11 <crestfallen> (I've never used the 'guard' keyword? or if it even exists .. and the OP was just guessing at a solution)
21:03:37 <crestfallen> correction "or whether the OP was just guessing..."
21:12:40 <crestfallen> i.e. is there a keyword called "keywords". I cannot find that in the docs
21:13:01 <arahael> How do I install sqlite-simple using cabal? I'm trying `cabal install sqlite-simple`, but it doesn't work. (apparently it doesn't contain any executables)
21:14:06 <arahael> Adding it to the cabal file of the current project and building *that*, however, does bring it in, but I'm a bit confused because the documentation for sqlite-simple says I can install it with that command...
21:14:11 <arahael> https://github.com/nurpax/sqlite-simple
21:15:50 <crestfallen> this is what I was trying to do on the 3rd line of the do block: http://ix.io/2Grk
21:20:49 <MarcelineVQ> keywords is the name of some list defined elsewhere in the code, I assume it's a list of the keywords of the language you're parsing
21:21:46 <MarcelineVQ> you can tell it's a list because it's the second argument to notElem
21:26:45 <crestfallen> MarcelineVQ: excellent *thanks* I see. I'll give it a shot.
22:31:43 <boxscape> Hm, am I seeing it correctly that "digit" exists in Parsec but not Megaparsec?
22:32:11 <boxscape> ah, nevermind
22:32:14 <boxscape> digitChar exists
23:13:38 <boxscape> is there a way to make a megaparsec parser for a sum type like `data A = A | B | C` automatically? I.e. basically what deriving Read does? 
23:16:36 <pavonia> With Template Haskell it should be quite straight-forward
23:16:51 <boxscape> hm, yeah I suppose you're right
23:19:31 <pavonia> Maybe even the Data.Data functions are enough for this
23:20:32 <boxscape> I'll take a look, thanks
23:21:19 <dminuoso> boxscape: Or.. just Generic?
23:21:31 <boxscape> Oh, yeah, I suppose that exists, too
23:21:36 <dminuoso> Seems really like a straight forward few lines of code
23:21:54 <boxscape> haven't used Generics much but yeah it seems like it shouldn't be hard
23:21:57 <dminuoso> Out of all the options Generics has probably least effort, and will optimize nicely
23:22:02 <boxscape> okay, thanks
23:22:33 <dminuoso> In my case I tend to write a `thruRead` combinator though
23:22:50 <dminuoso> Which is a few lines of code that I then copy and paste whenever I want to go through Read.
23:23:04 <boxscape> I see
23:23:08 <boxscape> that sounds reasonable
23:23:28 <dminuoso> Both are an option, with Generics you can address non-trivial variants of it
23:23:37 <boxscape> right, makes sense
23:25:10 <dminuoso> boxscape: Is this strictly a nullary data type?
23:25:16 <boxscape> yess
23:25:17 <dminuoso> Or do you have non-nullary constructors?
23:25:19 <boxscape> nope
23:25:19 <dminuoso> Mkay
23:25:34 * hackage http-conduit 2.3.7.4 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.7.4 (MichaelSnoyman)
23:26:30 <dminuoso> boxscape: Also consider generics-sop if you want to explore the generics route
23:26:39 <boxscape> ok, I will
23:56:43 <carbolymer> I'm writing parsec combinator for today's aoc, and how can I parse fields without enforcing order in my parser?
23:59:48 <hc> carbolymer: use a many . any [ ... ] combinator?
