02:11:06 <boxscape> % [True, False] ^?! (to . map) (intToDigit . fromEnum) . binary
02:11:06 <yahb> boxscape: 2
02:11:17 <boxscape> is there a more lensy function to use here than `to . map`?
02:27:56 <boxscape> % ([True, False] & each %~ intToDigit . fromEnum) ^?! binary
02:27:57 <yahb> boxscape: 2
02:28:01 <boxscape> I suppose you can do that
02:55:32 <iqubic> This is really screwing with me.
02:58:27 <boxscape> iqubic are you talking about what I wrote or something else?
02:59:09 <iqubic> I don't like how you are doing [Bool] -> Int via Binary and lenses. It irks me.
03:00:01 <boxscape> Yeah it'd probably make more sense to use `foldl' (\acc x -> acc * 2 + fromEnum x) 0`
03:00:30 <iqubic> as day 5 of this year's Advent of Code tells me, that's also much faster.
03:00:37 <boxscape> interesting
03:00:49 <iqubic> The binary prism really takes a large chunk of time to run.
03:00:51 <int-e> > foldl' (\a d -> a*2 + fromIntegral (fromEnum d)) 0 [True, False]
03:00:57 <lambdabot>  2
03:02:04 <int-e> Oh, it's converting to a string and then reading as a binary number? eww.
03:02:14 <iqubic> int-e: Yes it is.
03:02:33 <int-e> I wrote no code for day 5.
03:02:36 <iqubic> :t intToDigit
03:02:37 <lambdabot> Int -> Char
03:03:21 <boxscape> actually kind of strange that binary doesn't work for text and such
03:03:25 <boxscape> s/text/Text
03:03:31 <int-e> (And I'm not convinced I would have been faster if I had.)
03:03:57 <int-e> :t binary
03:03:59 <lambdabot> (Integral a, Choice p, Applicative f) => p a (f a) -> p String (f String)
03:05:03 <iqubic> For each Bool in the list, turn it into a Int with fromEnum and then turn each Int into a Char with intToDigit. Then run the slow (comparatively) binary prism.
03:31:44 <iqubic> composeAll :: [a -> a] -> a -> a
03:31:47 <iqubic> composeAll fs x = foldl' (\x f -> f x) x fs
03:32:02 <iqubic> This is my favorite function that I've written in a long while.
03:33:41 <iqubic> I can't simply do "appEndo . foldMap Endo" because that does a foldr and gets the order of the composition all wrong. I'd have to reverse my list first to get that to work.
03:34:42 <boxscape> I was about to suggest `ala Endo foldMap` but I suppose that's the same thing
03:37:22 <iqubic> boxscape: but that will turn "[f, g, h]" into "f . g . h", which is the wrong way around. I need "h . g . f"
03:37:57 <boxscape> iqubic right, I meant it's the same as what you said wouldn't work
03:38:01 <boxscape> % :t \fs x -> foldl' (&) x fs
03:38:02 <yahb> boxscape: Foldable t => t (a -> a) -> a -> a
03:38:03 <boxscape> this would work though
03:39:30 <iqubic> It might.
03:40:05 <iqubic> What does (&) do?
03:40:24 <iqubic> :t (&)
03:40:28 <lambdabot> a -> (a -> b) -> b
03:40:34 <iqubic> Ah. I see.
03:40:34 <boxscape> it's just `flip ($)`
03:42:32 <iqubic> \fs x -> foldl' (&) x fs works.
03:43:46 <iqubic> This is similar to traversing over a container full of state actions, except that I don't care about any intermediate results.
03:46:21 <iqubic> I have used Haskell for so long that just making a container full of functions, and then composing them all to get one final function was just the first thing I thought of when seeing today's Advent Of Code puzzle.
03:51:25 <aplainzetakind> Can I define typeclass constraint synonyms?
03:52:31 <boxscape> % type MyConstraint a = (Show a, Eq a) -- like this aplainzetakind?
03:52:31 <yahb> boxscape: 
03:53:06 <aplainzetakind> If that works, exactly.
03:53:08 <aplainzetakind> Thanks.
03:53:19 <int-e> iqubic: I saw that the state had four scalars and refrained from that kind of foolishness :P
03:53:38 <iqubic> what kind of foolishness?
03:53:54 <int-e> composing a ton of functions
03:55:30 <iqubic> Right. That kind of foolishness isn't too slow though. In fact, it's quite fast.
03:56:13 <int-e> I'm not worried about speed of the resulting code here. I'm worried about overloading my puny brain :P
03:58:21 <iqubic> Ah. I see. To me, this is just the simplest way to deal with tons of stateful actions in a row in haskell
04:01:28 <pja> Q: Is foldl strict in current ghc? I vaguely remember some discussion about switching it over.
04:02:33 <iqubic> pja: foldl is not strict. foldl' (note the appostrophe) is strict. Note that you might have to import it from Data.Foldable.
04:02:46 <enikar> R: Use foldl' instead.
04:06:23 <boxscape> hm apparently the definition of foldl in base is `foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z`, interesting
04:06:45 <iqubic> That is? Why!?!
04:07:04 <iqubic> Why not just use the more standard recursive apporoach of:
04:07:07 <int-e> :t appEndo . foldMap Endo
04:07:09 <lambdabot> Foldable t => t (a -> a) -> a -> a
04:07:16 <iqubic> foldl _ [] = []
04:07:37 <iqubic> foldl f (x:xs) = f x : foldl f xs
04:07:46 <boxscape> because that's only for lists
04:07:51 <iqubic> Right. I see.
04:08:44 <boxscape> that also looks like foldr to me?
04:08:46 <boxscape> @src foldr
04:08:46 <lambdabot> foldr f z []     = z
04:08:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:09:07 <iqubic> boxscape: No. What I wrote was actual map.
04:09:08 <int-e> it looks like map
04:09:15 <boxscape> oh, right
04:09:31 <int-e> @src foldl
04:09:32 <lambdabot> foldl f z []     = z
04:09:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:10:18 <pja> iqubic: Why did foldl' get moved out of the Prelude? Given that you almost never want the non-strict version this seems a little ... perverse.
04:10:31 <int-e> pja: it was never in Prelude
04:10:45 <iqubic> pja: I'm the wrong person to ask about that, you'll need to ask someone else.
04:11:07 <olligobber> is there any advantage to using f . g $ x over f $ g $ x?
04:11:17 <pja> Wasn’t it? Maybe I’m mis-remembering
04:11:20 <boxscape> you have one fewer ugly dollar sign
04:11:38 <olligobber> I like $ signs, they make up for how little haskell programming pays
04:11:43 <int-e> olligobber: you can factor out the f . g part directly. that's the strongest argument I know off
04:11:50 <int-e> olligobber: largely it just doesn't matter
04:11:55 <olligobber> ok
04:12:12 <iqubic> boxscape: dollar signs are the only way we can keep haskell from looking like lisp with a million parens.
04:12:23 <boxscape> Oh I agree, they're better than parentheses
04:12:26 <boxscape> just not better than dots
04:12:28 <int-e> I've done things like  return $ f . g $ x  with no regrets.
04:12:48 <olligobber> ew
04:12:57 <int-e> it's punctuation
04:12:59 <iqubic> int-e: That's some cursed haskell there.
04:13:05 <boxscape> ew, return
04:13:14 <int-e> iqubic: "return $" is a single entity to me
04:13:26 <int-e> boxscape: I'm approaching 20 years of Haskell.
04:13:36 <iqubic> Yeah, me too. I just don't like that statement.
04:13:36 <boxscape> heh, fair enough
04:14:27 <olligobber> apparently I've used return 4 times in advent of code 2020 so far
04:14:35 <int-e> boxscape: I'm slowly switching to "pure" but it's a process.
04:14:59 <int-e> The fingers aren't there yet.
04:15:01 <olligobber> you'd think I would have switched to pure with all the purescript I've been writing, but apparently not
04:15:01 <iqubic> Yeah. Switching to "pure" is certainly a process. I know what you mean.
04:15:22 <boxscape> hm "returnscript"
04:15:27 <olligobber> lol
04:15:56 <iqubic> It's just that when I see "pure" at the end of a do block, it feels all sorts of wwrong.
04:16:19 <boxscape> if you see pure at the end of a do block you can replace it with a MonadComprehension and get rid of the pure :)
04:16:51 <iqubic> yeah, but that's a whole different can of worms.
04:17:00 <boxscape> that's true
04:18:39 <drmdst> I was told to email hackage-trustees@haskell.org to request permission to upload, but my email is rejected with SPF failure. Which tells me to see details at openspf.net, which doesn't even resolve. But I have valid SPF records, and have no problems sending and receiving mail for the last 10 years. Sooo whoever is running hackage may want to fix
04:18:39 <drmdst> their email.
04:18:46 <[exa]> `pure` looks weird in a do-notation DSL that's aiming to simulate impurity
04:19:19 <int-e> drmdst: #haskell-infrastructure  may be a better place for this
04:19:55 <drmdst> int-e: thanks.
04:19:56 <int-e> at the very least it's less likely to scroll off before anybody sees it there
04:20:04 <iqubic> [exa]: that's exactly my take on this "return" vs "pure" dilemma
04:20:26 <int-e> (anybody with the power to fix it)
04:20:39 <boxscape> I could get on board with using `return` only in the context of the imperative DSL and pure everywhere else, I suppose
04:20:57 <iqubic> boxscape: I already do that.
04:22:58 <boxscape> I think it's still confusing though because if you want a do-block to evaluate to to the result of `someAction :: IO String`, you don't end the do block with `return someAction` like you would in an imperative language, you end it with `someAction`
04:23:23 <boxscape> confusing from the point of view of someone who's trying to learn this and has imperative experience, I mean
04:23:32 <[exa]> the only technical problem is that `return` is in Monad and we're likely not removing it anytime soon b/c a lot of code depends on it
04:23:49 <iqubic> [ex]
04:24:07 <boxscape> [exa] and a lot of educational material uses it
04:24:24 <[exa]> that's the other, slightly lesser problem
04:24:34 <iqubic> [exa]: isn't pulling return out of the Monad typeclass part of the Monad Applicatic proposal?
04:24:58 <[exa]> not sure, but there's been a lot of discussion about that afaik
04:25:32 <boxscape> I'm hoping we can put `join` *into* Monad at some point but apparently roles have to be fixed first...
04:26:43 <[exa]> a tiny bit of extra syntax would help I'd say
04:27:10 <boxscape> extra syntax for what?
04:27:28 <iqubic> I don't know the current state of the Monad Applicative proposal is. God, GHC is like a patchwork system that's being held together by duct tape, and any tiny change to any one part of it could affect a completely different part of GHC.
04:27:43 <[exa]> instead of `return` and `pure` in do-notation. Like `-> result` instead of `return result`
04:27:56 <boxscape> hm I see
04:28:08 <iqubic> GHC is the perl of the haskell world.
04:28:19 <[exa]> both `pure` and `return` mean something else, and people apparently want to make the `do` syntax more applicative-ish too
04:28:25 <[exa]> iqubic: +1
04:29:14 <[exa]> or well, something less over-used than ->... like `= result`. Would also avoid a lot of unnecessary $'s
04:29:19 <iqubic> I mean, GHC has a laundry list of language pragmas you can enable. It doesn't strictly adhere to the 10 year old haskell2010 standard.
04:29:49 <[exa]> I'm saving this as a procrastination project #549234645
04:37:58 <jpcooper> Hello. Are there any examples of people trying to create a custom syntax, maybe with TH, which recreates the functionality seen in J's trains of verbs? https://www.jsoftware.com/help/learning/09.htm
04:41:09 <jpcooper> If not, bagsy
04:43:44 <boxscape> %  :t ala Endo foldMap' . Reverse -- this isn't any better than your foldl' solution iqubic, but I figured out how to do it with ala without actually reversing the list
04:43:44 <yahb> boxscape: Foldable f => f (b -> b) -> b -> b
04:44:04 <boxscape> (Reverse just changes how foldMap operates rather than reversing the list)
05:17:23 <boxscape> hm I don't really understand why ala uses all the Wrapping stuff rather than Coercible
05:19:35 <lortabac> maybe ala is older than Coercible?
05:20:10 <boxscape> lortabac oh, yeah, that could be
05:21:16 <geekosaur> it definitely is, but one would thik by this point it would have been rewritten; Coercible has been around for a while
05:22:15 <geekosaur> unless they have a need to support pre-Coercible versions of ghc
05:23:18 <boxscape> hmm
05:39:03 <boxscape> % ala' :: forall a f g . (Functor f, Coercible a (g a), Coercible (g a) a) => (a -> g a) -> ((a -> g a) -> f (g a)) -> f a; ala' _ = au (iso coerce coerce)
05:39:03 <yahb> boxscape: 
05:39:04 <boxscape> % ala' Sum foldMap [1..5]
05:39:05 <yahb> boxscape: 15
05:39:08 <boxscape> it seems possible at least
05:39:45 <boxscape> edwardk do you know why ala uses Unwrapped rather than Coercible? Is it because no one has bothered to change the implementation since Coercible was introduced, or to support older ghc versions, or some deeper reason?
05:42:03 <siraben> How can I get infix pattern synonyms?
05:42:28 <siraben> I'm defining `(.:) :: a -> b -> a.:b` such that `a.:s = (a,s)` and would like to be able to pattern match on it
05:42:42 <siraben> so `dup (a.:s) = a.:a.:s` would work
05:43:20 <boxscape> siraben it looks like operator patterns have to start with :
05:43:31 <boxscape> operator meaning... infix
05:44:58 <boxscape> % pattern a :. s = (a,s) -- siraben
05:44:58 <yahb> boxscape: 
05:46:21 <siraben> boxscape: thanks
05:48:19 <tomjaguarpaw> Does anyone know why cabal v2-exec doesn't rebuild if the source has changed (but v2-run does)? Is it just because the exact dependenties for a v2-exec can't be determined?
05:50:07 <ephemient> siraben: types, constructors (pattern synonyms use this namespace too): name starts with uppercase or :  \\  type variables, values: name starts with non-uppercase letter or non-: punctuation
05:50:13 <[exa]> tomjaguarpaw: cabal exec is meant to run build-tools (ie. not the "current project" or program), cabal run is for running the program
05:50:50 <boxscape> ( ephemient well, type operators don't have to start with : if you use -XTypeOperators )
05:51:39 <siraben> maybe we need PatternOperators too
05:52:28 <boxscape> yeah I can't think of a good reason why patterns should have to start with :
05:53:26 <geekosaur> same reason constructors start with uppercase. constructor (including pattern) vs. variable is how pattern matching knows what to match on vs. what's a inding
05:53:27 <ephemient> I think it's just because they act like (de)constructors, so they follow the same rules that constructors do
05:53:31 <geekosaur> *binding
05:54:08 <boxscape> ephemient right, sorry, I meant I can't think of a good reason why infix constructors or patterns should have to start with :
05:54:16 <boxscape> but bindings make sense
05:54:23 <boxscape> I was only thinking of type level bindings, which can't be operators
05:54:28 <boxscape> but I suppose value level bindings can be
05:55:06 <boxscape> % let foo (!) a b = a ! b in foo (+) 1 2
05:55:06 <yahb> boxscape: 3
05:55:07 <boxscape> yeah
05:55:38 <boxscape> hmm how does agda handle thiss
05:57:58 <boxscape> looks like it treats it as a binding iff there is no constructor with that name in scope
06:10:28 <boxscape> % ala Endo foldMap [(+1), (*2)] 4
06:10:29 <yahb> boxscape: 9
06:10:30 <boxscape> % ala' Endo foldMap [(+1), (*2)] 4
06:10:31 <yahb> boxscape: ; <interactive>:70:6: error:; * Occurs check: cannot construct the infinite type: a ~ a -> a; Expected type: (a -> a) -> Endo (a -> a); Actual type: ((a -> a) -> a -> a) -> Endo (a -> a); * In the first argument of ala', namely `Endo'; In the expression: ala' Endo foldMap [(+ 1), (* 2)] 4; In an equation for `it': it = ala' Endo foldMap [(+ 1), (* 2)] 4; * Relevant bi
06:10:45 <boxscape> looks like i didn't quite manage to replicate it actually
06:21:36 <nshepperd2> my dependently typed scanf is coming along well... https://github.com/nshepperd/advent-of-code/blob/master/2020/TScanf.hs
06:23:36 <boxscape> nice
06:26:03 <merijn> iqubic: I'm a bit late with this comment, but non-strict foldl is being slain in GHC 9.2 \o/
06:26:24 <nshepperd2> slain how?
06:26:52 <merijn> nshepperd2: foldl is changed to be strict
06:27:03 <merijn> As are sum and product
06:27:30 <boxscape> huh, vmchale wrote a blog post recently saying that foldl is sometimes better than foldl', unfortunately I'm getting HTTP 500 atm http://blog.vmchale.com/article/fold-haskell
06:27:40 <xerox_> merijn: pretty cool
06:28:13 <merijn> nshepperd2: Cooler heads prevailed and those 2 guys that argued "something might hypothetically break!" were ignored and that 1.5 package on haskell that relies on lazy foldl (I can't imagine how that'd happen) can just deal with it
06:28:37 <merijn> boxscape: She's to busy shitposting on twitter to maintain her server ;)
06:28:43 <boxscape> I guess so :D
06:29:00 <nshepperd2> fair enough
06:29:05 <merijn> I'll check archive.org, because I find ithard to imagine a case where lazy foldl is better
06:29:35 <boxscape> https://web.archive.org/web/20201203003910/http://blog.vmchale.com/article/fold-haskell
06:29:36 <merijn> So far the 5 times it's been brought up on the mailing list people only brought up *hypothetical* breakage, no one has ever provided an example where lazy foldl is preferable
06:29:52 <nshepperd2> this only affects the instance for lists, right?
06:30:33 <boxscape> wait
06:30:42 <boxscape> merijn looks like she just said that foldr is better in that case actually
06:31:08 <merijn> nshepperd2: The Foldable default implementations are changed to strict by default, but instances of Foldable can override that, of course
06:31:29 <merijn> boxscape: That sounds more reasonable
06:31:59 <merijn> No one says foldl' is the best fold, people are just saying foldl' is always better than foldl, making the existence of foldl a dumb curiosity and a useless trap for newbies
06:32:04 <merijn> Same goes for sum and fold
06:32:18 <merijn> The number of times I've ever wanted lazy sum and fold in my life: 0
06:32:55 <merijn> The number of times I forgot that "sum" and "fold" in Prelude where dangerous traps and I should reimplement them using foldl' in my own code: tons of times
06:33:48 <ephemient> lazy sum might make sense with peano numbers, but… that can't matter enough to affect the default
06:34:03 <aplainzetakind> What's wrong with this?
06:34:17 <aplainzetakind> Solver a b c is a -> (b, c)
06:34:17 <merijn> nshepperd2: https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4355/diffs
06:34:30 <merijn> nshepperd2: maximum, minimum, etc. are all changed too
06:34:45 <solonarv> ephemient: but then foldr is better than foldl(') anyway!
06:35:21 <ephemient> that is true
06:35:22 <solonarv> foldl and foldl' will not produce anything before traversing the entire list, foldr will (so with foldr (+) 0, you can get the head of your lazy peano natural immediately)
06:35:28 <aplainzetakind> "this" being: https://dpaste.com/3SVPETL2F
06:36:31 <aplainzetakind> I'm getting ambiguous type variable complaints, but don't know where to put what.
06:38:22 <dminuoso> can you include the full error message?
06:39:49 <aplainzetakind> dminuoso: https://dpaste.com/C8NCK3MFT
06:40:34 <dminuoso> Ah yes, the typical `show . read` problem
06:40:48 <aplainzetakind> Not particular to RankNTypes?
06:43:39 <dminuoso> Ah, not even that. It's quite simple
06:43:55 <dminuoso> aplainzetakind: At what type should `read` be instantiated at?
06:44:34 <dminuoso> % And equivalently, show?
06:44:35 <yahb> dminuoso: ; <interactive>:77:17: error: parse error on input `,'
06:45:13 <aplainzetakind> dminuoso: Well, the 'a' in the type signature, but thats
06:45:29 <aplainzetakind> that's not how the scopes of type variables work I suppose.
06:45:43 <boxscape> mkSol :: (forall a b . (Read a, Show b) => a -> b) -> String -> String -- here's a simpler type signature with the same problem
06:45:44 <dminuoso> it looks like you're confused about who gets to pick the types
06:46:10 <boxscape> (and corresponding definition: mkSol f = show . f . read)
06:46:15 <dminuoso> aplainzetakind: You as the implementor of mkSol have to/get to instantiate `f` at one or multiple types.
06:46:39 <dminuoso> Not the caller/consumer of mkSol.
06:46:48 <aplainzetakind> Hmm.
06:47:05 <dminuoso> Equivalently you, the implementor of mkSol, as the *consumer/caller* of read *must* decide what to instantiate `read` at.
06:47:20 <boxscape> aplainzetakind if you look at (Read a, Show a), they're constaints for f, not for mkSol, so you can't use read and show of those instances inside mkSol
06:49:00 <boxscape> aplainzetakind I don't suppose you could just use `mkSol :: forall a b c. (Read a, Show b, Show c) => Solver a b c -> Solver String String String` instead?
06:49:53 <aplainzetakind> boxscape: I have Solve a b c's from every day with different a b c's.
06:50:06 <boxscape> I see
06:50:26 <aplainzetakind> I want to pool them into a function which takes the day number as a parameter and gives me String -> (String, String)
06:50:27 * dminuoso smells an AoC library
06:50:35 <aplainzetakind> dminuoso: Obviously.
06:50:37 <dminuoso> :)
06:51:02 <aplainzetakind> Is this sort of RankNTypes stuff not the right way to go about it?
06:51:15 <dminuoso> aplainzetakind: If you write `f :: (forall s. ... s ...) -> T` then you demand that the argument to `f` *must* be polymorphic.
06:51:29 <dminuoso> aplainzetakind: this gives the implementor of f the chance to instantiate its argument at multiple arguments
06:51:30 <dminuoso> for instance
06:52:26 <dminuoso> % f :: (forall s. Num s => s) -> (String, String); f n = (show @Float n, show @Int n)
06:52:27 <yahb> dminuoso: 
06:52:30 <aplainzetakind> This is the whole file: https://dpaste.com/E34G4S5RE
06:52:30 <dminuoso> % f 2
06:52:31 <yahb> dminuoso: ("2.0","2")
06:52:58 <dminuoso> aplainzetakind: ^- this demands, that you call `f` with a polymorphic Num value. You may not pass Int to it, the argument itself has to be polymorphic
06:53:06 <dminuoso> Then f can instantiate its arguments at multiple types as it sees fit
06:53:13 <__monty__> I'm running a criterion benchmark, something along the lines of `nfIO (readFile "myFile.txt" >>= process)` and I'm getting an error "openFile: resource exhausted (Too many open files)" Am I wrong in expecting criterion to fore the value of "process", which would force the value of readFile and close the fd?
06:53:22 * dminuoso smells another AoC library
06:53:56 <aplainzetakind> dminuoso: I kind of understand.
06:53:57 <merijn> __monty__: You need to fully evaluate the String you read via readFile
06:54:08 <merijn> __monty__: Or better, don't use the String version of readFile...
06:54:22 <__monty__> Not a library, just my solution benchmark. This has worked fine so far, I'm not sure why it doesn't today.
06:54:41 <aplainzetakind> dminuoso: What I understand indicates that this is not going to solve my problem.
06:54:44 <merijn> __monty__: Actually, better yet even is not separate reading the input from the benchmark
06:54:53 <merijn> s/not//
06:54:56 <dminuoso> aplainzetakind: Right, you just need a regular polymorphic binding. :)
06:55:10 <__monty__> merijn: But I want that included.
06:55:13 <merijn> __monty__: Reading the input shouldn't be part of what your benchmarking, so I'm confused why you have it there
06:55:32 <merijn> __monty__: Why?
06:55:56 <merijn> It's completely arbitrary and dependent on disk contention, filesystem overhead, etc. super noisy and all that
06:56:06 <__monty__> Because it's closer to "Time it takes to run the program to solve for input X."
06:56:22 <dminuoso> aplainzetakind: for `f :: forall a. ... a ...` it is the caller/consumer of `f` that can instantiate `f` at multiple/different choices for the type a. To the implementor of `f` the type is unknown, it has to write code that works over any choice of it.
06:56:29 <dminuoso> aplainzetakind: With rank 2 types it's reversed
06:56:30 <merijn> Well, then you need to do it properly and fully evaluate the input each time
06:56:36 <__monty__> These benchmarks are just for me, not to compete or publish : )
06:56:48 <boxscape> aplainzetakind how about this? https://i.imgur.com/helP7mx.png
06:57:13 <merijn> __monty__: Whether they're "just for you" is rather irrelevant when it comes to making them do something sensible :p
06:57:17 <__monty__>  Megaparsec's sepEndBy doesn't consume the entire input?
06:57:30 <aplainzetakind> boxscape: Yeah, that works.
06:57:49 <aplainzetakind> I was confused as to where to make things polymorphic.
06:57:56 <merijn> __monty__: I fail to see how "sepEndBy" and "consuming entire input" are at all related?
06:58:52 <merijn> I mean, if you use sepEndBy and fuck up your parser implementation so it doesn't read anything, that seem unrelated to sepEndBy
06:59:13 <__monty__> Imo a realistic result includes the variation that comes with disk IO. Maybe I'd have to up the number of runs to get more reliable values but not measuring it makes the numbers useless to me.
07:00:39 <boxscape> aplainzetakind FWIW, this way, the Constraints are locked up inside the Solver, rather than having to be provided by mkSol, which is why it works
07:00:42 <merijn> Then my use readFile from strict text still applies :p
07:02:53 <merijn> __monty__: As for why it suddenly doesn't work, criterion keeps running test until it the statistical noise in timings is below a certain threshold
07:03:13 <merijn> __monty__: So if your machine's disk is noisier today, then it will cause more reruns which will run you out of file descriptors
07:03:18 <__monty__> Yeah but why would a file from a previous test stay open?
07:03:50 <merijn> __monty__: Because you're using lazy IO and apparently not consuming it strictly enough to trigger cleanup during GC
07:06:03 <__monty__> Lesson learned I guess, include eof in your parser if you want to be sure you've read the entire file.
07:06:50 <Kronic> For megaparsec, is there like a list of common examples I can look at -- taking all of the library functions and just trying to glue them together is proving to be quite hard 
07:07:06 <__monty__> I was under the impression that eol consumed an eof too. I've always had to use `sepEndBy p eol` instead of `sepBy p eol <* eof`.
07:07:26 <ephemient> if you provide input through Criterion.Main.env, it's deepseq'ed it so that should not have issues either
07:07:32 * sm[m] has a eolof
07:07:50 <merijn> ephemient: Yes, but that lifts the input out of the benchmark (as I said he should), but he doesn't want that
07:08:21 <ephemient> whoops, I missed reading wherever that was. why not though
07:09:37 <__monty__> Because reading the input seems to be most of the work timing-wise. Makes comparing to others' results useless. I think by using criterion I'm already not measuring loading up the GHC runtime?
07:11:21 <__monty__> Kronic: You'll probably want to use some of the combinators from the parser-combinators package. I'm not sure there's any simple reference to look at other than the megaparsec tutorial, maybe the parsec documentation? Or AoC repos if you don't mind spoilers : )
07:11:26 <merijn> "comparing to others' results" and looking at more than order of magnitude  is already useless
07:11:42 <boxscape> aplainzetakind also, basically, what you would want in your original type signature is exists instead of forall. Which doesn't exist, so I used an existential type as one of at least two possible encodings (Though apparently Richard Eisenberg is working on adding native existential quantification)
07:11:43 <merijn> This just in: Benchmarking properly is hard and trusting *anyone* else's benchmarks is folly
07:11:57 <__monty__> That's what I'm doing. But disk IO can easily make an order of magnitude of difference.
07:12:08 <merijn> __monty__: And if you don't care to the level of precision of doing it properly, then there's little to no gain from benchmarking file IO
07:12:26 <Kronic> Trying to avoid spoilers! I'm using AOC as a way to teach myself things like parsers and lenses. I guess I will re-read their tutorial and see what I can find
07:12:28 <merijn> __monty__: If you're already benchmarking everything yourself you can just factor out the cost of disk access
07:13:00 <ephemient> IO speeds also vary greatly on depending on OS, hardware, other IO, and caching. assuming it's in hot cache, reading a few kB from page cache isn't going to outweigh the computation time.
07:13:17 <merijn> Kronic: tbh, the AoC problems aren't very well suited to parser combinators (you can use them, naturally, but the problems are small and simple enough that parser combinators have a lot of mental overhead compared to the simple problem)
07:14:07 <Kronic> That's true, but I'm not solving AOC to solve AOC, I'm solving AOC to learn Haskell bits of Haskell in a fun way
07:14:10 <__monty__> It's been easy going since day 7 imo : )
07:14:14 <merijn> If there's anything I've learned from my HPC it's this. There's two kinds of benchmarks: obviously wrong ones and subtly wrong ones ;)
07:14:58 <__monty__> I just want something that's a little more reliable than "time dayXY".
07:15:02 <siraben> How do I properly use Kleisli? `runKleisli (P.getChar >>> ord >>> return ())` doesn't seem to work but I'm confused as to why
07:15:08 <siraben> I thought >>> would take the place of `>=>` here?
07:15:38 <merijn> Kronic: Sure, I'm just saying that parser combinators can feel less practical than they are due to the lightweight problems
07:16:50 <Kronic> That's fair, I definitely see the value in learning them, I just figured being able to build a simple one would teach me a few things 
07:18:33 <merijn> Kronic: tbh, a slightly more complex input with a well-defined grammar is probably easier (something like SMTP or HTTP), iirc attoparsec's benchmarks had a full HTTP parser in less than 100 lines
07:18:58 <boxscape> aplainzetakind here's a version using another encoding of existential quantification, without an existential type https://i.imgur.com/yEgviU4.png
07:19:04 <merijn> I guess a slightly more modern version would be something like JSON
07:19:14 <siraben> `runKleisli (Kleisli P.putStrLn . Kleisli P.readFile)` ooh
07:21:27 <merijn> Kronic: oh, 65 lines even, 18 of which are imports/exports :p
07:22:57 <xerox_> siraben: I remember using such a construction once but I can't remember why
07:26:16 <siraben> xerox_: i'm trying to generalize https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md
07:26:25 <siraben> generalize `>=>` to any Kleisli category
07:26:44 <xerox_> siraben: which '.' was that?
07:27:22 <merijn> Control.Category.. presumably
07:27:51 <xerox_> aah
07:28:02 <xerox_> ok that matches
07:28:13 <siraben> xerox_: yeah control.category
07:32:17 <siraben> Has anyone used the time traveling/backwards State monad and for what purpose?
07:32:18 <siraben> Single pass assembler seems cool
07:38:02 <boxscape> is there a way to make ex2 here work? And why doesn't it work? https://dpaste.com/EWFBYEE4Z
07:39:43 <boxscape> Oh you need impredicative types for this don't you
07:39:53 <c_wraith> yes
07:40:04 <c_wraith> for it to work you need to instantiate map polymorphically
07:41:03 <c_wraith> And the list literal, for that matter
07:41:48 <c_wraith> Is the Quick Look stuff due in the next version of GHC?
07:41:53 <boxscape> c_wraith ah, yeah, if I use map @Ex it works
07:42:19 <boxscape> (with pre-quick-look impredicativity)
07:44:14 <boxscape> c_wraith also, yes, quick look is merged into master
07:45:04 <c_wraith> cool.  I can't wait to play with that.  Hopefully there will be some places it works well enough to be a real ergonomic improvement
07:45:14 <boxscape> yeah
07:47:50 <Boarders> Does anyone know a fast way to compare mutable unboxed vectors?
08:14:03 <exarkun> What do I read to learn more about the execution model of Conduits?  The implementation?
08:15:41 <sm[m]> exarkun: michael snoyman's blog posts about it, maybe
08:16:47 <c_wraith> if you go to his blog, be aware the implementation has changed several times - make sure you find posts describing the implementation you're using
08:18:41 <sm[m]> yes
08:19:45 <exarkun> is there a trick to find all the conduit posts or do I just have to manual scan the whole archive :/
08:21:05 <exarkun> (kind of a rhetorical question)
08:21:11 <merijn> Tekmo also did a bunch of posts on pipes and contrasting them with conduit
08:22:45 <merijn> exarkun: https://kseo.github.io/posts/2017-01-25-write-your-own-stream-processing-library-part1.html ?
08:27:23 <exarkun> Hmm maybe that will help, I dunno.  Thanks though.  I'm kind of unsure what my question really is.  I just want to understand better :/
08:31:18 <sm[m]> scanning a blog archive isn't that hard :)
08:33:04 <monochrom> In an ideal world, this would be right in the doc, not need to google or find blogs...
08:38:04 <merijn> monochrom: And then the link dies because MS redoes the MSR website and giving a shit about durable URLs is so passe and Web1.0 ;)
08:41:16 <monochrom> This happened to cabal[-install] too when v2 first came out. Instead of putting the new information in the user guide where it belongs, "I'm so excited I'll blog it"
08:42:02 <monochrom> The irony being if you blog it and then just copying the blog post into the user guide, that's already infinitely better and at no extra cost.
08:43:48 <monochrom> This happened to backpack too. The necessary information, even merely user-facing one, was not entered into the GHC user guide or the cabal user guide.  Instead, it's a bunch of blog posts.
08:43:49 <Kronic> What is a decent web framework to start out with as a beginner that has an easy to follow tutorial?
08:45:06 <monochrom> In that case it was fortunate that the author also had a PhD thesis due, so what I did was I went straight for the thesis. An author has much more incentive in making a PhD thesis complete and coherent than making a blog so.
08:46:46 <merijn> monochrom: Man...trigger warnings >.>
08:47:07 <sm[m]> are we sure it's not in the doc ? 
08:47:52 <merijn> monochrom: I come here to peacefully procrastinate from writing and you gotta throw that stuff out there in plain sight >.>
08:48:09 <sm[m]> (exarkun?)
08:48:37 <sm[m]> Kronic: scotty is simplest, yesod is most mature and fully documented, IHP is newest and funnest
08:48:56 <Kronic> Are they all actively maintained ?
08:49:07 <sm[m]> the last two are at least
08:50:19 <Kronic> Seems Scotty is maintained, I'll give it a shot I guess
08:54:24 <geekosaur> the FadeHooks could probably use some work, I was basically cribbing from other code without knowing what I was doing at the time
08:55:12 <geekosaur> so there may be a more fundamental bug to fix under this, since I didn't intend just throwing away actions
08:55:13 <monochrom> FadeHooks is an interesting name...
08:55:19 <geekosaur> whoops
08:55:27 <geekosaur> I keep forgetting what channel I'm in
09:04:12 <maerwald> is there a way to reasonably figure out the highest base constraint of a package without running a full resolution?
09:04:41 <exarkun> sm[m]: It doesn't seem to be in the README which is a large part of the "official" docs, and I can't deduce it from the API docs, though maybe a more expert Haskeller could
09:05:12 <sm[m]> exarkun: just curious what's missing exactly ? I had a quick look and the conduit docs seem excellent
09:05:31 <merijn> sm[m]: They don't talk about how they're implemented, though
09:05:40 <merijn> sm[m]: Which is what he was asking :)
09:05:45 <sm[m]> what about the presentation ?
09:06:36 <sm[m]> if not there, then I agree it would be great to link some of that history to the readme. The posts (his, Gabriel's, maybe others) were very informative
09:10:27 <sm[m]> presentation seems rather detailed. Maybe that LambdaConf 2017 talk was published ?
09:11:09 <sm[m]> yes indeed, https://www.google.com/search?client=safari&rls=en&q=LambdaConf+2017+michael+snoyman&ie=UTF-8&oe=UTF-8
09:17:50 <exarkun> sm[m]: I am trying to implement a first-ready composition function
09:18:19 <exarkun> sm[m]: I don't know if this is even a coherent thing to want from Conduit
09:18:29 <exarkun> sm[m]: It seems like a basic thing to want so maybe there's a good reason it's missing
09:18:39 <exarkun> sm[m]: Or maybe it's not even missing but I can't recognize it in the docs
09:19:34 <sm[m]> Maybe.. here I defer to others
09:19:49 <exarkun> If it is coherent and doesn't exist then I'm not sure what tools I should reach for to implement it
09:20:14 <exarkun> Threads to run each component separately from each other?
09:20:28 <exarkun> Or is there something in the Conduit implementation that would make some other strategy better?
09:22:40 <exarkun> I guess Conduit is probably all single threaded and it just calls functions to get a value from the first component and then calls some functions to pass it to the second, and so on ... but it seems like I have to guess or read the implementation to find out
09:23:01 <dminuoso> exarkun: Have you tried looking at the implementation?
09:23:28 <merijn> exarkun: Conduit is (mostly) intended for single threaded processing, yes
09:23:49 <merijn> exarkun: I think there are other libraries that couple conduits running in separte threads together
09:24:07 <merijn> exarkun: And, of course, I wrote my own library for parallelising a specific conduit stage
09:24:35 <merijn> exarkun: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.1.1/docs/BroadcastChan-Conduit.html#v:parMapM
09:24:50 <exarkun> dminuoso: I've tried a bit but I'm sufficiently inexperienced that it's slow going
09:25:05 <merijn> That works nicely if one of your conduit stages does some slow IO
09:25:07 <dminuoso> exarkun: Which parts in particular were holding you back?
09:25:49 <merijn> One of my pipelines has to do slow IO requests (they take a few seconds to complete) and parMapM means I can have multiple requests "in flight" at a time (you'll lose ordering, though)
09:26:53 <exarkun> merijn: That looks like it might be a good source of hints for implementing what I want (which is kind of like a fan-out / fan-in component)
09:28:15 <merijn> exarkun: Eh...word of warning
09:28:31 <exarkun> dminuoso: It's not necessarily any single thing, more to do with the fact that much of the implementation relies on features or libraries that I'm not familiar with
09:28:35 <merijn> exarkun: The implementation is a horrific nightmare of low-level threading and async exception details :)
09:28:52 <merijn> exarkun: fan out/fan in can be accomplished much easier, tbh!
09:29:30 <merijn> exarkun: fan in is simply "conduit repeatedly reads from a single channel with multiple writers"
09:29:45 <merijn> exarkun: fan out is simply "conduit repeatedly writes into a single channel with multiple readers"
09:30:18 <merijn> exarkun: And if you need a channel that can be closed when the upstream is done writing, I've got you covered too ;) https://hackage.haskell.org/package/broadcast-chan
09:31:25 <exarkun> Well, I guess that's kind of what I figured.  I posted that MVar-based code yesterday or the day before (which just used MVar as the simplest proof of concept while I figured out how to glue it into Conduit)
09:31:46 <exarkun> but I got stuck actually gluing it into Conduit
09:33:23 <exarkun> My Haskell skill is at the level that even "conduit repeatedly reads from a single channel with multiple writers" is probably an hour to figure out (which is fine, part of my goal here is to learn more)
09:33:51 <merijn> exarkun: "awaitForever $ \x -> liftIO (putMVar m x)" :p
09:34:45 <merijn> exarkun: "forever $ readMVar m >>= yield"
09:35:05 <merijn> oh, wait, that's gotta be "liftIO (takeMVar m) >>= yield"
09:35:24 <merijn> (readMVar would read the same element each time and without liftIO it doesn't type check)
09:36:29 <merijn> % forever $ print True
09:36:35 <yahb> merijn: True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True; True;
09:36:41 <merijn> (I was smart enough to try that in PM first :p)
09:37:21 <dminuoso> Why is cabal failing to find a build plan here? https://gist.github.com/dminuoso/4dc113de1a22ab5db5b6a8880e18e58a
09:37:23 <dminuoso> Im a bit stunned
09:37:30 <merijn> exarkun: You need slightly more complex logic to handle "when will nothing ever be written to this MVar again"
09:37:51 <dminuoso> Where could the constraint `haskell-generate:setup.Cabal>=1.10 && <1.25` possibly come from?
09:37:57 <dminuoso> Im not finding these bounds anywhere
09:38:15 <merijn> dminuoso: I think that can happen if something is installed in the global database?
09:38:42 <merijn> Dinner time, though
09:40:47 <dminuoso> Well.. uh
09:41:26 <dminuoso> So the only special thing here, is that it has a custom Setup.hs
09:48:53 <sm[m]> dminuoso: we had a case like this recently where a typo in the cabal file (cabal-version: >=N) activated a complicated legacy mode in cabal
09:49:46 <hth313> what is the best way to build on Windows? using mingw, DOS prompt or Powershell?
09:50:19 <sm[m]> hth313: stack, in any of those
09:54:11 <adamCS> exarkun: slightly OT, but streamly (https://hackage.haskell.org/package/streamly) is more...up-front about how to handle concurrency, etc.  Maybe that would be a help?
09:55:10 <exarkun> adamCS: maybe!  thanks for the tip, I'll check it out
09:55:34 <hth313> I have a complex UNIX setup, using GHC, cabal, cmake (for a library), controlled by a custom Python script(does a lot more than just building), I try mingw, endless problems with paths, terminfo not there. I tried with mingw
09:56:14 <hth313> I am wondering if it works without mingw, if I can go for native Windows scripting instead?
09:56:38 <sm[m]> hth313: haha, that on windows will be a whole nother kettle of fish. Maybe WSL2 is best
09:56:44 <hth313> mingw cannot even run cmake properly :(
09:57:09 <hth313> and that is from the mingw shell command line
09:57:25 <sm[m]> s/Maybe //
09:58:47 <hth313> I want to build native Windows command line apps for end users, no UNIX for them
09:59:13 <hth313> I thought mingw would be good for building native apps, but that seems not to be the case
09:59:50 <hth313> good when you come from a UNIX setting, to port it and have native Windows binaries that work like Windows command line programs in the end
10:00:29 <hth313> WSL2 means the end user would need to use WSL2 also?
10:02:23 <Guest81293> if i have e (iterate f x) that produces a list of xs that eventually stabilize - example: ([9,6,4,3,2,1,2,1,1,1,1...]) - what is the canonical way of getting the first repeated element? (in this case the 1)
10:02:55 <Guest81293> *a
10:03:07 <c_wraith> There isn't any great solution, though there are clever answers
10:04:11 <monochrom> The "why functional programming matters" paper by John Hughes shows one way.
10:04:33 <sm[m]> hth313: generally a pure haskell app built with cabal or (more easily) stack will just work for any windows user, and they won't need any haskell tools installed. Yours is more complicated though
10:04:43 <Guest81293> now im curious
10:04:48 <monochrom> I also show it in my class.  http://www.cs.utoronto.ca/~trebla/CSCC24-2020-Summer/03-haskell-evaluation.html#lazygood
10:07:27 <c_wraith> > (\xs -> dropWhile (uncurry (/=)) . zip xs . tail $ xs) [4, 3, 7, 2, 9, 3, 5, 5, 23] -- too clever by half.  Also incomplete for the sake of illustration
10:07:30 <lambdabot>  [(5,5),(5,23)]
10:07:55 <Guest81293> ha
10:20:56 <xerox_> > let dup (x:y:_) | x == y = x; dup (_:xs) = dup xs in dup $ iterate (\x -> x/2 + 1/x) 1.0
10:20:59 <lambdabot>  1.414213562373095
10:25:38 <Kronic> WSL2 would mean that, yes hth313, also as an aside, WSL is an incredibly frustrating experience imo. I tried it for a long time until I eventually swapped to vmware player and I've had no problems since. Would recommend.
10:27:21 <hth313> Kronic: all these UNIX-like environments on Windows are just various degrees of pain and should be avoided whenever possible
10:30:41 <__monty__> I thought WSL2 basically *was* linux running in a VM with some nice integrations on top?
10:31:48 <hth313> So if Python/GHC works in Windows, it sounds as it would be better to use a native Windows shell. I basically wonder if GHC and cabal (with many libraries to install) require mingw or similar to work properly
10:35:28 <Kronic> __monty__ be that as it may, it's filled with gotchas and all of the things that people didn't think about it. Every time I tried it it was a disappointment. 
10:35:40 <sm[m]> I think they do, eg stack and maybe GHC include it (or msys2 or some such)
10:38:53 <D3R43> Hello! I am approaching haskell, I was trying to configure the terminal in order to have a working environment within ubuntu. I was trying to install haskell-language-server, to do that I installed stack (v. 2.5.1) but it keeps telling me "Cabal file info not found for aeson-1.5.2.0". This error doesn't tell me anything at all, cabal didn't even
10:38:54 <D3R43> try to install it (the guide I'm following, https://github.com/haskell/haskell-language-serve, says I could either choose stack or cabal and completely randomly I chosen the first). The error message doesn't say anything to me, can someone help me find my way?
10:40:35 <glguy> The easiest way I know how to install hls is via ghcup
10:40:46 <glguy> But maybe a stack user has gotten it working with stack
10:43:40 <merijn> D3R43: Not directly related to your problem, but: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
10:44:03 <merijn> D3R43: I am guessing you are using stack in combination with hpack?
10:45:18 <sm[m]> D3R43: the easiest easiest way is to use VS Code's Haskell extension which sets it up for you
10:47:04 <merijn> sm[m]: I'm not sure that "switching entire editors" is in fact the easiest way :)
10:47:22 <glguy> It's certainly the easiest way if your goal is HLS support
10:47:32 <glguy> but not if your goal is to use a specific editor
10:47:44 <maerwald> merijn: depends, heh... ever tried getting proper typescript support in vim?
10:48:09 <merijn> maerwald: No, because I live in a blissful world where Javascript (and by extension typescript) are a problem for "other people"
10:48:23 <merijn> The magic of the "Someone Else's Problem-field!"
10:49:28 <sm[m]> I say offer the easiest solution first, it's often what a new poster wants
10:49:52 <sm[m]> we can swiftly get more complicated as needed 
10:50:43 <sm[m]> but, I did somehow assume D3R43 was on windows, I don't know why I did that
10:52:50 <merijn> sm[m]: Because the previous discussion was by someone else about windows and your brain short-circuited? ;)
10:53:10 <sm[m]> no doubt. Sorry :)
11:12:26 <D3R43> Great feedback guys. @sm[m] I'd rather not change to VS code, even though I know it is very lightweight and handy. Unfortunately I have to stick to the terminal only. I will look into ghcup thanks @glguy . @merijn I love not having to bother with javascript too!
11:12:54 <D3R43> So basically I'm just looking for something that will optimize my vim-experience with haskell ^^
11:13:45 <merijn> D3R43: ghcide (which is what haskell-lang-server is built on top of) + ALE seems to work well for me
11:14:15 <merijn> D3R43: Might need this too: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/autoload/ale_linters/haskell/ghcide.vim
11:14:48 <glguy> My favorite vim GHC experience is having a ghcid window open adjacent to my editor
11:16:27 <Kronic> you could try onivim, it's basically vim and vscode glued together 
11:16:33 <D3R43> Yup, i'm planning on having two tmux sessions, one with ghci and one with vim, I was just looking for vim plugins providing syntax highlighting and mybe lyinting
11:16:42 <D3R43> *linting
11:16:44 <glguy> D3R43: not ghci, but ghcid
11:16:56 <glguy> well, I like having both, but ghcid tends to be more important
11:17:27 <D3R43> OK, I was about to ask about whether ghcid was a typo or not, I'm looking that up, don't know what that is
11:17:52 <glguy> It automatically reloads a ghci session that it wraps when files change
11:18:00 <sm[m]> ghc/ghci/ghcid/ghcide all different :)
11:18:00 <MarcelineVQ> ghcid is the bee's knees
11:18:02 <glguy> so you get feedback as soon as you save
11:18:07 <merijn> Well
11:18:18 <glguy> You can put _ holes in your file to get type information at a location
11:18:19 <merijn> You get feedback as soon as "cabal build" gets to the file you changed >.>
11:18:28 <glguy> no, it doesn't cabal build
11:18:31 <glguy> it ghci reloads
11:18:37 <merijn> Like, ghcid is at best "ok" the feedback cycle is entirely too long
11:18:40 <glguy> and with -fno-code or whatever it is, that's pretty fast
11:18:52 <merijn> glguy: By default, if you use ghci, but that doesn't work for multi package projects
11:19:01 <merijn> Then you need to use cabal build
11:19:03 <Kronic> I use stack build with file-watch and vs code, it has been working for me fairly well so far
11:19:03 <glguy> merijn: It doesn't work when you're editing multiple projects
11:19:04 <sm[m]> sure it does (can)
11:19:20 <glguy> merijn: but it works on multi-component projects when you're working on one component
11:19:28 <sm[m]> ghcid -c 'stack repl all', or ghcid ...-idir1 -idir2 
11:19:53 <glguy> merijn: and what you're describing is unlikely to be the case for a new user learning Haskell
11:20:00 <MarcelineVQ> merijn: You must have some pretty big projects, the feedback has always been very fast for me. Regardless for someone starting out it's gonna be plenty fast
11:20:59 <merijn> MarcelineVQ: Yes, some of the bigger project can easily take a few minutes to build if you change one of the files that is transitively included everywhere
11:21:05 <merijn> ghcide is orders of magnitude faster for that
11:21:11 <Kronic> perhaps the fact that you guys have different computers is playing a role here 
11:21:28 <merijn> Kronic: Considering this is on a machine with 30+ cores and 192GB RAM I doubt it ;)
11:21:50 <glguy> merijn: considering that then yes, different computers
11:21:54 <Kronic> What's the single core speed on that?
11:21:54 <merijn> MarcelineVQ: Sure, ghcid is pretty good
11:22:12 <D3R43> Wow, ok, a lot of feedback, thanks everyone
11:22:27 <merijn> MarcelineVQ: My point is that everyone doesn't say "ghcid is pretty good for just starting out", everyone always says "I don't understand why anyone would ever want something other than ghcid"
11:22:45 <glguy> everyone certainly doesn't always say that
11:22:45 <merijn> If people would say "ghcid is pretty good for starting out", sure, no complaints
11:23:04 <merijn> glguy: Well, there;s always at least one person saying that whenever someone talks editor tools :)
11:23:19 <sm[m]> correcting myself.. I heard stack repl has an "all" target but I don't know what it is. You certainly can use ghcid for multi-package projects though, and it's fast. I've been doing it for years
11:23:22 <MarcelineVQ> hehe, well I've never needing anything but ghcid, but no that doesn't extend to others
11:23:26 <monochrom> I don't understand why anyone would ever want IDE.  There!  :)
11:23:33 <merijn> sm[m]: Stack repl fakes it
11:23:36 <glguy> /nick everyone
11:23:45 <merijn> sm[m]: It just dumps everything into a single component and hopes it works
11:23:56 <sm[m]> fine
11:24:08 <merijn> Which, admittedly, it often will
11:24:18 <sm[m]> I'll paste an actual command I use, so I don't screw up:
11:24:18 <sm[m]> stack exec -- ghci  -rtsopts -Wall -fno-warn-unused-do-bind -fno-warn-name-shadowing -fno-warn-missing-signatures -fno-warn-orphans -fno-warn-type-defaults  -ihledger-lib -ihledger-lib/other/ledger-parse -ihledger -ihledger-ui -ihledger-web -ihledger-web/app    -DPATCHLEVEL=32 -DDEVELOPMENT -DVERSION="\"1.20\""  hledger/Hledger/Cli/Main.hs
11:24:19 <monochrom> In fact, I have a Kevlin Henney talk to back me up: https://www.youtube.com/watch?v=FyCYva9DhsI&feature=youtu.be&t=1858
11:24:21 <merijn> But! iirc the work on multi-component ghci is getting merged soon!
11:24:47 <sm[m]> -iPKGDIR is the thing
11:24:52 <merijn> monochrom: I just want warnings highlighted in my editor and the ability to query "type under cursor" :p
11:25:17 <monochrom> I already have those.
11:25:41 <merijn> So do I with ghcide ;)
11:26:49 <monochrom> OK, good for you. I have those from emacs and haskell-mode or dante. For 1/10 of the installation hassle.
11:27:21 <Kronic> I don't understand, would people not want a good standalone IDE for haskell to exist?
11:27:36 <blissful> i wouldn't want to need a new IDE just for haskell
11:27:45 <merijn> Kronic: tbh, if it'd require me to use anything other than vim I personally wouldn't care
11:28:04 <merijn> Kronic: but then, I'm the kinda person who also works on 100k SLOC C++ applications in vim, rather than an IDE, so...
11:28:06 <monochrom> Kronic: I think https://ro-che.info/ccc/26 sums up human nature.
11:28:18 <geekosaur> different people are different. I never developed the habit of using an IDE for any language
11:28:29 <Kronic> I think it's evident considering how much code there is already written in Haskell that you don't need one. My question is what is wrong with one existing?
11:28:51 <sm[m]> Kronic: in haskell land, many of us are conditioned to hair shirts, bread and dry water :)
11:29:11 <maerwald> merijn: vim was written for and by C/C++ programmers, where source files are 10k lines and you need a way to navigate without losing your sanity
11:29:24 <maerwald> for many "modern" languages, this doesn't apply anymore
11:29:25 <merijn> Kronic: Nothing
11:29:40 <blissful> hmm, so on this topic, is anyone else using hls with coc in vim?
11:29:48 <merijn> Kronic: But, selection bias has obviously led to "most established Haskellers not caring about/needing IDEs"
11:30:04 <merijn> Kronic: And the people who want/need an IDE are obviously not versed enough in Haskell to write one
11:30:20 <Kronic> Seems like an unfortunate situation 
11:30:39 <merijn> Kronic: So, the *practical* reason why people react antagonistically to "Haskell needs an IDE" is the silent part "and you guys who don't like IDEs should write it for me, for free"
11:31:17 <monochrom> I don't oppose other people using IDEs.
11:31:18 <merijn> I don't think anyone reasonable objects to the idea of "a Haskell IDE existing", but plenty object to getting blamed for the lack of one existing
11:31:21 <Kronic> To be fair, I don't think anyone is looking for it to be free. If there was an extremely clean well put together haskell IDE I'd happily pay whatever price that comes at 
11:31:53 <Kronic> If not to support haskell development, but also to potentially give myself a new experience in working with this language
11:31:56 <merijn> Kronic: Yeah, but the market for that is too small for someone to create one and become the next IntelliJ
11:32:07 <monochrom> My angle is it's the IDE users that inflict on me "why are you not using an IDE? you're a criminal" and/or "I won't start learning Haskell until an IDE is up and running".
11:33:44 <sm[m]> Kronic: also for years we had attempts at a nice IDE, which would always consume much sweat and end in tears.  But just lately the situation has changed, VS Code + Haskell now works easily and well for many
11:33:53 <monochrom> Kronic: Empirical data has shown that the paid IDE for Mac, and the free IDE from FPComplete (see that comic again), have flopped.
11:35:00 <monochrom> Let me also tell you a piece of history of IRC math channels.
11:35:27 <maerwald> free IDE from FPComplete?
11:35:34 <monochrom> For like 20 years people in IRC math channels kept wishing for an "IRC LaTeX plugin".
11:36:01 <monochrom> Said plugin actually happened. Pidgin had one.
11:36:03 <geekosaur> intero?
11:36:27 <sm[m]> maerwald: they had a web-based one years ago
11:36:30 <monochrom> Said people went on to wish for an "IRC LaTeX plugin" ignoring the IRC LaTeX plugin in Pidgin.
11:36:53 <monochrom> This is why I say that that comic is so piercing in exposing human nature.
11:37:01 <monochrom> It is not just you people.
11:37:28 <Kronic> I think there are too many black marks around the word IDE. My point simply put is that anything you can download which gives you an easy to use out of the box haskell experience is a good thing. Paid, free or some other model. I don't want an IDE personally because I'm pretty happy with my workflow but I wouldn't object to one existing, and I would in fact support it.
11:37:49 <monochrom> Also I wish everyone respected that "data" is plural and I would write "Empirical data have shown..."
11:38:11 <MarcelineVQ> but if you have two androids you have datas
11:38:14 <merijn> monochrom: Hard disagree
11:38:22 <merijn> monochrom: Data is clearly an uncountable mass noun
11:38:47 <D3R43> Wow, thanks for the great feedback everyone! I'm a bit overwalmed with the answers you provided ... So basically which benefits does hls offer over plain ghcid? I hope this doesn't start a flame war ...
11:39:00 <geekosaur> "codes"
11:39:00 <monochrom> No, please use "information" for the uncountable.
11:39:09 <merijn> geekosaur: I hate HPC people so much
11:39:12 <sm[m]> Kronic: certainly, no argument there. It's always one of the community's biggest wishes in surveys
11:39:20 <merijn> Gets under my skin at every conference
11:39:32 <hpc> merijn: hey!
11:39:58 <sm[m]> D3R43: basically instead of showing you the errors in a separate terminal window, it can (when integrated with an editor like VS Code) show them inline in your code
11:40:00 <[exa]> merijn: h p c people are somehow specific in saying data wrong?
11:40:12 <merijn> [exa]: No, they say "codes" instead of "code"
11:40:21 <[exa]> what the
11:40:22 <merijn> It's never "this HPC code" it's always "these HPC codes" >.<
11:40:27 <D3R43> @sm[m] does it apply to vim too?
11:40:27 <lambdabot> Unknown command, try @list
11:40:50 <monochrom> I want to say "codes" too.
11:40:51 <MarcelineVQ> what about people like me who never know when to say datum
11:40:55 <sm[m]> D3R43: any editor with supports Language Server Protocol. I'm sure vim does, but only in VS Code is it easy to set up 
11:40:59 <[exa]> merijn: are they like really the people who do programming or just the supercomputer owners?
11:41:10 <[exa]> because the latter category _is_ saying a lot of bs
11:41:19 <hpc> are they speaking in their first language?
11:41:20 <[exa]> s/owners/managers/ etc
11:41:25 <monochrom> I am tired of "these two pieces of code" please allow me to just write "these two codes" and be done with it.
11:41:39 <monochrom> English is such a piece of work.
11:41:40 <hpc> i have only ever heard that before from people who aren't perfectly fluent
11:41:43 <MarcelineVQ> monochrom: programming isn't about generalizing to solve problems :O
11:41:53 <[exa]> monochrom: prograaaaaaaaams  *trumpet meme*
11:41:53 <sm[m]> D3R43: ie yes, it can apply to vim too, if you can figure out how
11:42:26 <monochrom> Yeah OK I'll use "programs" and "code fragments/snippets".
11:42:39 <[exa]> snippets, great!
11:43:00 <[exa]> `code' collides with coding theory, that gets quite irritating sometimes
11:43:39 <[exa]> the worst part is mceliece-style cryptography where certain people talk about code that codes information using codes (respectively: programs, encrypt, codes)
11:43:45 <monochrom> Yeah, I recognize that "codes" is already taken: "two codes" = two encodings, esp. in coding theory.
11:46:52 <monochrom> Hey I found a way to 1-up that game!
11:47:04 <monochrom> code that codes the Napolean code using codes
12:03:18 <Guest81293> when ghci tells me a module is a member of a hidden package, what does it mean and how do i unhide it? google is confusing me
12:03:33 <merijn> Guest81293: It means you didn't specify it as a build dependency
12:04:03 <merijn> "Hey, I see you're importing this module that happens to be in this package, but you didn't tell me that was a dependency you were using"
12:05:13 <Guest81293> im not using a cabal file nor do i want to if i dont have to. are there any disadvantages to unhiding a package?
12:06:05 <Guest81293> the package is unordered-containers and im just solving aoc
12:06:06 <merijn> You can't unhide packages so much, as well tell ghc which packages it's allowed to use
12:06:29 <merijn> I forget the flag for specifying packages to GHC, though
12:06:39 <merijn> I just made a single cabal file for all AOC exercises, tbh
12:06:56 <Guest81293> :set -package maybe?
12:08:15 <geekosaur> -package, yes
12:09:07 <aev> join ##java
12:09:13 <aev> whoops
12:09:21 <Guest81293> someone tells me i can also do sudo ghc-pkg expose unordered-containers. any reason not to?
12:13:05 <Guest81293> this is confusing
12:13:35 <sm[m]> Guest81293 (IRC): perhaps ignore that someone, that's not something anyone needs to do normally
12:13:40 <aev> If you know what you're doing I don't see why you wouldn't want to expse hidden packages.
12:14:04 <merijn> tbh, figuring out how to get that to work without a cabal file is probably more work than adding a simple cabal file will ever be
12:14:05 <aev> Usually packages are hidden to protect us.
12:15:40 <sm[m]> ghci -package unordered-containers aoc.hs  # fine
12:18:51 <Guest81293> tbh when it comes to cabal i usually don't know what i'm doing
12:19:26 <Guest81293> thanks
12:20:49 <aev> I'm having problems with ghcid after installing it using cabal install ghcid. When I start it, it tells me it isn't trying to start ghcid, but instead it starts cabal repl with a whole bunch of options that it then complains about that it doesn't recognize them, and refuses to start. I reinstalled ghcid but it does the same thing. I'm on a fresh debian instance under WSL. Suggestions on how to fix that?
12:21:26 <merijn> aev: Which version of "cabal"?
12:22:03 <merijn> Guest81293: A super minimal example (other files in the repo are spoilers for previous days, obviously): https://github.com/merijn/AdventOfCode2020/blob/master/advent.cabal
12:22:11 <sm[m]> Guest81293 (IRC): when you want to save the list of packages required for your program, next step up is a cabal or stack "script", where you list them at the top of the file. When it gets more complicated still, a package
12:22:47 <aev> merijn: it says "cabal-install version 2.2.0.0"
12:24:10 <merijn> aev: Which options does it not recognise? (also 2.2 is kinda old, you should probably upgrade to 3.0 or 3.2)
12:24:49 <aev> Odd: I installed it yesterday. Why wouldn't it give me the latest version?
12:25:18 <aev> I'm going to try upgrading first and see what happens.
12:25:56 <hyperisco> I have a  Digest SHA1  and I want a binary string, how do I get that?
12:26:10 <hyperisco> like a ByteString where the characters are bytes
12:26:37 <merijn> aev: "cabal install cabal-install" should work (or at least, put the newest version wherever cabal normally puts executables)
12:26:43 <merijn> aev: Where did you install it from?
12:26:45 <sm[m]> aev: it's easy to install a not-latest thing, depending how you do it
12:27:00 <hyperisco> the docs say to look here but this doesn't seem to give any clues https://hackage.haskell.org/package/memory-0.15.0/docs/Data-ByteArray.html
12:27:02 <merijn> hyperisco: I think there's a "convert" function somewhere
12:27:12 <merijn> hyperisco: I've got the code using it somewhere
12:27:58 <merijn> hyperisco: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/Types.hs#L45
12:28:14 <merijn> oh, wait, that's reversed
12:28:55 <merijn> hyperisco: https://github.com/merijn/Belewitte/blob/d15a4a128925ca4e8f9ee14d85940085e88e6a1c/benchmark-analysis/ingest-src/Jobs.hs#L47
12:28:59 <merijn> That's the one
12:29:05 <aplainzetakind> How can I match a given Text with Megaparsec?
12:29:05 <hyperisco> I think convert works, type checks at least, lets see
12:29:19 <aplainzetakind> Text.Megaparsec.Char.string basically.
12:29:36 <aplainzetakind> Can't use that because Tokens Text ~ Text apparently.
12:30:19 <aev> merijn: doing that now. I installed it from the packages available in the Debian apt list. There were 2 versions and I chose the newest. I'm quite sure the first thing I did after that was upgrading. Maybe I missed it.
12:30:37 <hyperisco> great thanks merijn 
12:30:47 <geekosaur> hash -r?
12:31:03 <hyperisco> so, I could be crazy, but I am appending the hash of a file to the file for the purposes of verifying the integrity of the file
12:31:12 <sm[m]> string (also named chunk) is the way, aplainzetakind 
12:31:30 <sm[m]> aev: if installing with cabal, you must say cabal install cabal-install-3.2.0.0 to be sure
12:32:59 <merijn> aev: Oh, yeah, debian just installs stupidly old stuff
12:33:28 <merijn> aplainzetakind: Oh, do you have OverloadedStrings enabled?
12:34:01 <merijn> aplainzetakind: Char.string works, but you need to pass it Text, not String
12:34:21 <merijn> hyperisco: You are right, that is crazy ;)
12:34:32 <hyperisco> what would you do
12:34:34 <merijn> Well, depending on what you're verifying against
12:35:02 <merijn> hyperisco: Well, step 1 is identifying the goal. Corrupted downloads? Read errors? Active tampering? Unique identification of a file?
12:35:29 <hyperisco> you seemed more sure at the start there
12:36:36 <aplainzetakind> sm[m]: For some reason I keep getting can't match [Char] with Text things.
12:36:38 <merijn> hyperisco: Well, "append checksum + signing" is a usual approach to authenticate files, but the exact order and operations are rather subtle to get right
12:36:50 <merijn> aplainzetakind: Because you don't have OverloadedStrings enabled :)
12:37:04 <merijn> aplainzetakind: If you write: Char.string "foo"
12:37:17 <merijn> Then "foo" is a String, and for Text input Char.string wants Text
12:37:31 <merijn> So you need to either do: Char.string (T.pack "foo")
12:37:37 <merijn> Or enable OverloadedStrings
12:37:38 <aplainzetakind> merijn: But I do.
12:37:46 <merijn> aplainzetakind: GHC disagrees :)
12:38:28 <sm[m]> @where paste perhaps, aplainzetakind 
12:38:28 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
12:40:00 <aplainzetakind> The problem is, I'm trying to change all my AoC stuff from String to Text.
12:40:15 <aplainzetakind> So there are many modules that are complaining.
12:40:36 <aplainzetakind> I first defined a global synonym type Input = String
12:40:54 <aplainzetakind> Changed all the parsing stuff's signatures to that Input.
12:41:43 <aplainzetakind> Then made parsing functions polymorphic, (Token s ~ Char, Stream s) => s -> ParseResult sort of.
12:42:02 <aplainzetakind> Then finally switched that Input = String to Input = Text.
12:42:13 <aplainzetakind> So the situation is pretty horrible :)
12:42:25 <aplainzetakind> Let me try to localize it.
12:42:54 <sm[m]> yeah, often the best thing is to back out your change and try again in much smaller steps
12:47:02 <ezzieyguywuf> How do I use =~ with a Data.Text? https://hackage.haskell.org/package/regex-tdfa-1.3.1.0/docs/Text-Regex-TDFA.html#v:-61--126-
12:47:24 <ezzieyguywuf> I've tried `"string" =~ "pattern" :: (Text, Text, Text, [Text])` but this does not work I get a kind error
12:47:40 <ezzieyguywuf> (with :set -XOverloadedStrings of course)
12:50:07 <aplainzetakind> OK, it seems it's not a fundamental issue.
12:50:26 <aplainzetakind> Just some incompatible functions here and there.
12:51:01 <aplainzetakind> For instance, I have `many lowerChar` somewhere, which is of course [Char].
12:51:19 <merijn> aplainzetakind: "fmap T.pack" ;)
12:51:25 <aplainzetakind> Should I just pack it in such cases?
12:51:26 <aplainzetakind> OK
12:51:36 <aplainzetakind> Not inefficient?
12:51:47 <merijn> aplainzetakind: Well, it'd be "better" (in terms of efficiency) to use, like, takeWhileP
12:51:51 <merijn> But for AOC it won't matter
12:52:29 <aplainzetakind> Even megaparsec doesn't matter in that respect.
12:52:57 <aplainzetakind> Just for the sake of exercise.
12:53:38 <aev> So, building cabal-install failed because it couldn't locate zlib... gotta love fresh linux distros that lack everything.
12:53:51 <merijn> aplainzetakind: I mean, realistically it won't matter for any parser on still you start wanting to parse, like gigabytes of data
12:53:51 <hyperisco> are there archive types that include hashes so that they self-verify their contents?
12:54:06 <dminuoso> sm[m], merijn; Hah it's not a bug, it's a feature: https://github.com/haskell/cabal/issues/5278
12:54:16 <geekosaur> just need zlib-dev, I suspect
12:54:20 <dminuoso> Guess I should make it a habit to run `cabal check` when running into unexpected issues
12:54:30 <merijn> dminuoso: oh, that was actually in the back of my mind
12:55:46 <dminuoso> Think Im gonna satisfy the feature request and rig in a diagnostic that tells the user why it introduced a non-obvious constraint.
12:56:01 <sm[m]> dminuoso: that's the one. A "feature".
12:57:12 <hyperisco> well what specifically about zlib?
12:57:45 <sm[m]> (I take it back, that's not the one from the other day. This is another one.)
13:00:04 <sm[m]> hyperisco: I think geekosaur was replying to aev
13:00:37 <geekosaur> I thought hyperisco was as well…
13:01:31 <dminuoso> aev: "[...] distros that lack everything" - are you suggesting a linux distribution should install everything by default?
13:02:07 <geekosaur> one might be used to e.g.arch where there's no difference between runtime and devel packages
13:02:31 <geekosaur> (granting that that is part of why they botched their haskell ecosystem)
13:03:31 <sm[m]> poor old arch.. they need a spokesperson in here :)
13:07:46 <aev> dminuoso: on the contrary. I would like an installer package to identify which dependencies it requires before it starts building stuff. It's implicit dependencies like zlib in this case that consume a lot of time when they're missing. The package maintainer assumes that that lib is available. And on a fresh system it isn't. So it's their fault and they need to fix it. I'll see if I can send them a pull 
13:07:52 <aev> request for that.
13:08:57 <merijn> aev: The Haskell package? How would you expect it to install zlib?
13:10:42 <sm[m]> aev is suggesting that apt install cabal-install should also install some very common requirements like zlib-dev, I'm guessing
13:11:18 <aev> No. I'm suggesting it alerts us of missing libs before it starts a minutes-long building effort, only to break after half an hour.
13:11:31 <sm[m]> aev, which "it" ?
13:11:34 <sm[m]> cabal ?
13:11:47 <aev> The cabal-install package.
13:11:50 <geekosaur> that much it ought to be doing already, I think
13:11:54 <sm[m]> I agree that would be nice
13:12:03 <merijn> It depends if it's using pkg-config depends
13:12:11 <merijn> Or just blindly assuming zlib is there
13:12:16 <sm[m]> libtinfo-dev libtinfo5 are two other libs often needed on debian
13:12:29 <geekosaur> but theres a bootstrapping problem with cabal-install since the normal checks are part of cabal-install…
13:12:42 <merijn> Ah
13:12:45 <merijn> It's not cabal-install
13:12:58 <merijn> cabal-install depends on the zlib package and that doesn't check whether zlib is present
13:13:14 <aev> Right now it looks like it blindly assumes it's there. Rust packages have the same problem: the package devs have those dependencies themselves so they forget to include a check.
13:13:16 <merijn> Because (by default) pkg-config is disabled in the zlib package
13:13:52 <merijn> aev: The is no generic way to check whether a package is installed, though
13:14:02 <merijn> Nor is there a generic way to check if a C library is available
13:15:01 <aev> Cabal-install gets installed by the cabal executable. There does not need to be anything generic. It can be completely custom.
13:15:35 <merijn> aev: It's not cabal-install package that is wrong, it's the zlib package
13:15:44 <merijn> aev: And how do you propose this custom thing would work?
13:16:03 <sm[m]> I think it would be reasonable and convenient for debian's ghc package to depend on debian's zlib-dev, libtinfo-dev, libtinfo5 packages
13:16:18 <aev> I don't know yet. At this point I'm at the stage of complaining because I have a fresh environment.
13:16:25 <sm[m]> a pity Clint is not here
13:17:14 <aev> Maybe the cabal package could depend on zlib-dev. That would fix the problem for cabal-install.
13:17:17 <merijn> aev: The problem is, as it usually is, that "why doesn't the package just check for X?" is that sensibly doing anything like that is generally impossible unless you assume very specific systems
13:17:43 <sm[m]> aev, I think ghc would be better, because you might be using stack or just ghc itself 
13:17:47 <merijn> aev: Right, but that only works if we're talking actual linux distro packages
13:18:08 <aev> sm: agreed
13:18:10 <merijn> aev: The actual haskell package can't depend on "zlib-dev", because there's no notion of what "zlib-dev" even is
13:18:24 <aev> merijn: now that's a problem.
13:18:42 <merijn> aev: It's an unfixable problem
13:19:09 <merijn> aev: zlib-dev is a specific package on a specific distro. How could you possibly specify a dependency on a C library that works on all distros, macOS, and windows?
13:19:26 <merijn> aev: Answer: You can't, since there's no shared package manager that exists on all 3
13:19:34 <aev> How does the builder figure out it needs zlib and then fail, if it doesn't know what zlib is? It doesn't even say it needs zlib-dev. It complains about zlib. Of course the distro has zlib by default, but not zlib-dev.
13:20:01 <merijn> (not to mention macOS having multiple package managers, windows not really having one at all, and all linux distro using different ones with names that might be zlib, zlib-dev, or really anything
13:20:30 <merijn> aev: It just passed "-lzlib" to the system linker and the system linker checks if a library by that name exists and then uses it
13:21:03 <aev> So... can't the installer do that in the beginning of its process?
13:21:13 <merijn> aev: zlib-dev isn't the name of a library, it's the name of the package that has a library named zlib. But some distros tag libraries with -dev fixers
13:21:46 <merijn> aev: Not really, because there is no portable way to ask a linker of a library exists
13:22:17 <merijn> You'd need to ship some kind of dummy object file (which aren't portable either!) and try and link that with the linker and see if it fails
13:22:42 <merijn> aev: The rabbit hole just keeps going and going and getting less portable and more system specific as you go
13:23:25 <merijn> aev: The end result is something like ghcup/rustup which basically are just a long list of distro/OS specific instructions to get everything installed
13:23:32 <geekosaur> and then there's what happens if its there but has its own dependency for some reason
13:24:12 <aplainzetakind> Does Text have any disadvantages compared to String?
13:24:25 <merijn> aev: And that's the only real thing that works "write a script per possible distro/OS that fetches dependencies", which is not really something you wanna somehow embed inside, say, cabal-install. Which is why non have the build tools in any language do that
13:24:41 <merijn> aplainzetakind: Eh, it's harder to pattern match and list functions don't work? That's about it
13:25:04 <aplainzetakind> That's what I thought.
13:25:07 <dolio> Text uses slightly more memory for very small strings, I think.
13:25:11 <c_wraith> Text literals aren't as efficient
13:25:16 <merijn> dolio: tbh, I doubt it
13:25:27 <sm[m]> all that said.. there's two or three C libs that are typically missing and we've been helping new haskellers figure this out for years. There must be some things that can be done to reduce the hassle
13:25:36 <dolio> But that's not really worth worrying about.
13:25:42 <merijn> dolio: String has like 24 bytes per character, I dunno how big the overhead of Text is, but it's probably close unless you have like 1 character strings :p
13:25:46 <aev> Gah, my network connection broke again
13:26:03 <c_wraith> merijn: that overhead doesn't always exist.
13:26:04 <aplainzetakind> Can't one create an interface like the list one for strings using PatternSynonyms?
13:26:17 <Clint> sm[m]: if someone files a wishlist bug those dev packages could be added as some kind of weak dependencies
13:26:42 <merijn> aplainzetakind: Well, Text already has Text versions of most list functions, so...someone already did? :p
13:26:53 <merijn> aplainzetakind: And you can probably use PatternSynonyms, yes
13:27:13 <sm[m]> ah hi Clint. So that idea of making debian's ghc depend on say zlib-dev, libtinfo-dev, libtinfo5 might fly ?
13:27:34 <c_wraith> Text has bad ergonomics for anything you expect to be a code literal
13:27:57 <geekosaur> I think the intended fix for Text vs. String is backpack? but it's taking a while to actuallly happen because of missing build tool support
13:28:16 <aev> Debian keeps breaking the installs. Going to use ghcup instead.
13:28:34 <merijn> geekosaur: With ezyang doing pytorch I don't see it happening any time soon :p
13:29:08 <c_wraith> I'd use Text for input on anything I care about text input handling.  But if you are writing functions that accept values you expect to be literals in code, String is a lot less likely to be a hassle and performance will usually be a wash.
13:32:10 <sm[m]> c_wraith++
13:34:54 <c_wraith> Haskell doesn't have a "string problem".  It has options for a lot of different cases, because it turns out that strings are *not* actually one representation fits all.
13:35:27 <sm[m]> Haskell has a "batteries" and "imports" problem :)
13:35:58 <c_wraith> yeah, those are fair.  lots of options, surprisingly verbose to combine them
13:36:22 <Kronic> meh, I think it's not unreasonable to say that people coming from somewhere else expect it to simple when Haskell has made it harder than what they think it should be. Speaking as one of those people right now
13:37:00 <c_wraith> Though if you're writing an application rather than a library, you can do a lot to reduce the import overhead by creating a custom set of default imports.
13:37:28 <c_wraith> Unfortunately, you can't do that with qualified imports, so it has its limits
13:38:49 <sm[m]> Kronic: it's not unreasonable. The main problem is how to get from here to a clean modern complete standard library and language defaults that makes all the easy/right things easy
13:39:00 <Clint> sm[m]: cabal-install sounded more reasonable, i think.. if you're using debian-packaged libraries with debian-packaged ghc, all those will be pulled in for you automatically and you won't have to worry about it
13:40:26 <sm[m]> Clint: ie the cabal-install and stack packages could depend on those common C libs, maybe  ?
13:40:35 <Kronic> Sure. I mean, if the biggest problem a language has is "working with text is a little bit annoying for someone new" then that's a good problem to have in comparison to what could be the case. I don't have any idea how to make it any easier, because much of Haskell is still very new to me. My only point was it's definitely not obvious why all of the various options exist at first
13:41:30 <Clint> sm[m]: yeah, but it would have to be a weak dependency because those things aren't actual dependencies
13:41:49 <Clint> so like a Recommends or a Suggests
13:41:50 <sm[m]> cool. aev was ready to submit requests.. come back aev..
13:42:26 <sm[m]> Clint: when does apt install those ? automatically, or does it just mention them in the output ?
13:45:41 <sm[m]> Kronic: yes, it's similar for time, dates, maps, vectors, ... I believe
13:47:49 <Sose> I made a new servant stack project with `stack new todo servant` but I can't get it to build... I don't really understand these error messages. https://gist.github.com/Sose/d955fd1d1149abf4070eb6a9cd2216a7
13:49:16 <merijn> sm[m]: tbh, I'd like to know which languages do have a clean complete standard library and are easy to install :p
13:49:35 <merijn> sm[m]: I guess maybe Go? But their standard library is "just pull HEAD from github", afaict
13:50:12 <MarcelineVQ> complete for who >:<
13:50:44 <merijn> Kronic: On the one hand it can be tricky, but otoh, when was the last time a language you used was powerful enough for vectors to be something that could be implemented well in a 3rd party library? ;)
13:50:52 <merijn> (or Text or...)
13:50:53 <sm[m]> merijn: it's all relative of course, but people usually say python's or ruby's stdlib are more complete and easy to work with
13:50:56 <merijn> MarcelineVQ: Well, that too
13:51:13 <merijn> sm[m]: Python's standard lib is also filled with deprecated junk people keep having to tell people not to use :)
13:51:36 <dolio> Is this the same python where people are ranting about all the string types?
13:51:46 <merijn> dolio: Probably, but they are wrong
13:51:47 <sm[m]> I know you like to argue, but can you please just.. see my point  ? :)
13:51:58 <merijn> If anything, we don't have enough string types :)
13:52:04 <dolio> Yeah, the 'string problem' is that programmers don't understand strings. :)
13:52:09 <merijn> sm[m]: I'm not disagreeing that haskell is a bit messy
13:52:26 <merijn> sm[m]: It's just that, imho, people have a romanticised view of how well it's "solved" in other languages
13:52:49 <merijn> Usually the solution in other languages is "we threw man-decades at things until it was manually fixed in all cases"
13:52:53 <sm[m]> thanks. Let's not let that be an excuse not to look at ways to improve
13:52:57 <merijn> Which, fine, that's good for users
13:53:05 <merijn> But not something we can easily replicate
13:53:17 <merijn> And in the grand scheme of things Haskell really isn't that bad
13:54:09 <Kronic> Haskellers have such a stranger vocabulary, otoh/machinery are phrases used constantly, I'll catch myself saying it eventually I guess 
13:54:14 <merijn> You should try installing LLVM and libstdc++ without relying on a package manager...it's a disaster that no mortal can decipher, but LLVM is big enough to be packaged by "other people" so no one has to notice :)
13:54:18 <Kronic> or words, I mean
13:54:53 <Sose> merijn: oh no :D
13:55:48 <merijn> Sose: "GHC is so big, it's 1.5 GB!" *looks at LLVM with it's 40 GB build dir and 3.5 GB final install size* 'heh...yeah, you're right...'
13:58:41 <merijn> Like, I get it, we all want everything to be a single button labelled "DWIM", but things are complicated and lots of the bad things with cabal and Haskell in general aren't bad because we design bad solutions, but because cross-platform and portable things are hard, especially when not designed into the architecture from the start
13:59:13 <Clint> sm[m]: it installs Recommends automatically unless you specifically opt out of that
14:00:39 <Sose> I was recommended servant for making web APIs but honestly I'd rather try something else than try to get llvm working myself :|
14:01:02 <sm[m]> cool
14:02:43 <Kronic> is there a vscode plugin for keeping equals signs in line in haskell? 
14:05:27 <quarters> hello. I was wondering if anyone can recommend a framework for building a trivial rest api with haskell
14:06:15 <aplainzetakind> Is there a brand new extension or something which lets one write nullary "operators" "infix"?
14:06:22 <aplainzetakind> I mean without parentheses.
14:06:34 <aplainzetakind> I mean for this empty Text synonym: https://dpaste.com/B7YCVRXYZ
14:06:47 <Rembane> quarters: Scotty! 
14:06:58 <Rembane> quarters: https://hackage.haskell.org/package/scotty
14:07:09 <quarters> Rembane: thank you :)
14:07:15 <Sose> I guess I'll try scotty aswell :D
14:08:16 <Sose> I see that needs warp aswell! :D
14:08:32 <Rembane> quarters: np! 
14:13:38 <Kronic> Question: if you have a pattern that repeats a lot with slightly longer function names, like this (f2 . f1) $ f0 v1 v2, is it a bad idea to just bundle that up into a local function and slap the name "f/g" on it?
14:13:51 <Kronic> Or do you guys go out of your way to give a better name to things like that 
14:14:42 <Rembane> Kronic: I try to not name things. It saves so much time. 
14:15:12 <Rembane> Kronic: That does look like the dot operator: ((.) . (.))
14:15:23 <Rembane> :t ((.) . (.))
14:15:28 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
14:15:52 <Kronic> you try to not name things?
14:16:03 <quarters> I noticed that when building a project with stack, it uses a lot of space. I was wondering if it's different for cabal
14:17:16 <sclv> cabal doesn’t install its own ghc so that might save some space
14:17:25 <Rembane> Kronic: Yeah, I do pointfree style as much as I can. This means that nobody can read the code, but I don't have to name things. 
14:18:06 <quarters> sclv: great. thank you
14:18:23 <Kronic> You could just not write code at all, then even you wouldn't have to read it as you write it 
14:19:17 <Rembane> That's where I'm heading, not gotten there yet thoug.
14:22:26 <sm[m]> quarters: also you can make stack use a single ghc with: stack --no-install-ghc --system-ghc ...
14:22:47 <quarters> sm[m]: ah nice. thanks!
14:22:50 <sm[m]> to clean up the ghcs you already have, ncdu ~/.stack is good
14:27:23 <dminuoso> Kronic: Over the years I've become convinced that the better style is to have where clauses and lots of bindings.
14:28:07 <dminuoso> Trying to get smart with point-free might be fun as a golfing excercise, but when you re-visit your code a year later, you'll thank yourself for a) moving portions into separate bindings, b) giving them sensible names and c) attaching a type signature to them.
14:28:47 <dminuoso> And perhaps d) attaching a comment to it
14:29:06 <monochrom> There is no mutual exclusion between naming and pointfree (wherever pointfree makes sense).
14:29:19 <dminuoso> Right. But then I try to keep the point-free code relatively small
14:30:03 <Kronic> Ah, maybe I was not clear. The point about the where clause is good to hear, I've been doing that already, I find it very useful. My point was say I have some small expression I repeat a bunch to get a value, my example was listed above, does it make sense to spend some time naming what exactly that is, or is there some kind of practice for having a placeholder name here for some small internal where function that doesn't matter much e.g. f or g 
14:31:05 <dminuoso> Kronic: Well, if you have to even repeat it, it's worth putting into a binding for that reason alone. :)
14:31:06 <sm[m]> it's pretty subjective Kronic, whatever makes you/your team most comfortable in that part of the code I'd say
14:31:08 <monochrom> In that case I go meta for a while. Does it make sense to spend a few minutes to decide whether it makes sense to spend a few minutes to...
14:31:48 <dminuoso> Kronic: Whenever I even think about "should I maybe put this into a binding" - that thought alone is reason enough to put it on a separate binding.
14:32:14 <monochrom> And then I short-circuit all that. If within 5 minutes I can think up a good name, I go with it. If not, move on.
14:32:36 <dminuoso> One name to bind them all, one name to find them, one name to bring them all, and in Haskell bind them.
14:32:46 <Kronic> The binding part I definitely agree about, it's just the name I'm concerned about. For example in kotlin, if you have a lambda that just one parameter that is always called "it" unless you specify otherwise 
14:32:50 <dminuoso> Oh that doesn't quite flow
14:33:36 <monochrom> I think the first sentence can be better as "one name to name them all".
14:34:08 <dminuoso> Oh I know!
14:34:28 <Rembane> Maybe if you change the words to operators.
14:34:33 <dminuoso> One where to name them all, one where to find them, one where to bring them all, and in Haskell bind them.
14:34:37 <dminuoso> monochrom: How about this? :)
14:34:48 <monochrom> Yes that works nicely.
14:35:13 <sm[m]> I think one where to sould be extracted to a where clause
14:35:42 <monochrom> You look at mathematics and you see that extremely useful theorems, extremely repeatedly used theorems, cannot have "meaningful" names unless you allow the names to be as lengthy as the theorems themsevles.
14:36:07 <monochrom> For example the Yoneda lemma.  For example Löb.
14:36:38 <dolio> I'm not sure mathematicians even try.
14:37:06 <monochrom> But you can try. Yoneda's lemma.  What would be a better name?
14:37:34 <dolio> Presheaf induction principle.
14:37:49 <fresheyeball> is there a way I can handle a MonadError locally so the constraint is not needed?
14:37:49 <Rembane> As long as they have a name that's fairly unique that you can use to chunk the concept I'm cool with it. 
14:37:53 <monochrom> Eventually you accept that many helper functions have to stay as being called "my_helper" unless you accept a name that's longer than the implementation.
14:38:06 <dminuoso> fresheyeball: Can you elaborate?
14:38:17 <fresheyeball> Basically I have some functions that don't compose
14:38:24 <dminuoso> Well, in Haskell we tend to name helper functions `go` though.
14:38:31 <fresheyeball> the `e` in their MonadError constraints are in conflict
14:38:38 <fresheyeball> and I can handle the error case locally in a nice way
14:38:57 <fresheyeball> by in conflict, I mean "do not unify"
14:39:39 <monochrom> Nice, I like presheaf induction principle.  Kan extension?
14:41:17 <dolio> Not sure. "Extension" is already an actual technical term.
14:42:00 <dolio> The "Kan" part is mostly superfluous.
14:42:20 <monochrom> Ah OK, I agree.
14:42:21 <dolio> But people need to get credit.
14:42:35 <dolio> Or else they don't get paid.
14:43:14 <dminuoso> Mathematicians get paid?
14:43:19 <dolio> A little bit.
15:11:06 <shalokshalom> https://github.com/commercialhaskell/stack/issues/5452
15:11:20 <shalokshalom> Where in the source code to add this, so I can raise a PR?
15:13:47 <dminuoso> shalokshalom: https://github.com/commercialhaskell/stack/blob/master/src/Stack/Setup.hs
15:14:16 <dminuoso> shalokshalom: The exit point for the error you're getting is the UnknownCompilerVersion exception
15:14:22 <dminuoso> Beyond that I cant help
15:19:00 <sm[m]> huh, I was thinking https://github.com/commercialhaskell/stack/blob/master/etc/scripts/get-stack.sh
15:20:20 <dminuoso>  oh
15:21:01 <dminuoso> sm[m]: The error diagnostic definitely comes from the above Setup.hs
15:21:29 <dminuoso> ahh, I see
15:21:40 <sm[m]> I see. That's the stack setup command I guess
15:22:09 <dminuoso> No your pointer is definitely right
15:22:34 <dminuoso> @pl \f -> (\(ann, n) -> (f ann n, n)))
15:22:34 <lambdabot> (line 1, column 34):
15:22:34 <lambdabot> unexpected ')'
15:22:34 <lambdabot> expecting variable, "(", operator or end of input
15:23:01 <dminuoso> @pl (\(ann, n) -> (f ann n, n))
15:23:02 <lambdabot> uncurry (join . ((,) .) . f)
15:23:21 <dminuoso> Mmm. Is there a profunctor thing for this?
15:25:54 <quarters> when trying to run scotty using the code here: https://hackage.haskell.org/package/scotty, I get an error saying that where "/:word" is, a RoutePattern was expected and I was wondering what i'm doing wrong
15:26:20 <glguy> quarters, did you add this to the top of the file? {-# LANGUAGE OverloadedStrings #-}
15:26:33 <quarters> oooh no i didn't
15:26:46 <quarters> I suppose I didn't do it verbatim after all
15:26:54 <quarters> thanks! let me try that
15:29:33 <quarters> that worked :)
15:49:59 <Sose> btw regarding my issue with installing `warp` earlier.. I deleted ~/.stack and suddenly it works 
16:51:40 <cnmne[m]> having trouble seeing where a miscount is coming up when i try https://paste.tomsmeding.com/DIzLGJv8 for AoC 2015 Day 8. all my tests come up correct, and i've hand-counted a few nasty-looking ones -- all correct
17:04:58 <MarcelineVQ> idk but looking at line 1 of the input, read turns "\xd2"   into "\210"  which means it's become 4 chars instead of 1
17:06:31 <MarcelineVQ> Instructions given have "\x plus two hexadecimal characters (which represents a single character with that ASCII code"  which is violated if read gives 4 chars instead of 1
17:18:50 <cnmne[m]> i think it's ok
17:18:57 <cnmne[m]> when i check length it shows 1
17:19:07 <pavonia> Which input line fails?
17:20:27 <cnmne[m]> neither; i get an answer, but apparently the wrong answer
17:21:16 <pavonia> Ah, e.g. this one gives wrong results "hc\"lg\x6bcpupsewzklai\"l"
17:21:44 <pavonia> Because the Haskell parser keeps reading hex chars until it can't find any more
17:22:15 <pavonia> > "\x6bcp"
17:22:17 <lambdabot>  "\1724p"
17:22:30 <cnmne[m]> ah!
17:23:08 <cnmne[m]> that makes sense, thanks. I guess there's no short cut and I'll have to pattern match a little more ...
19:22:07 <siraben> Anyone writing time-traveling code in Haskell?
19:23:34 <ephemient> we are all time travellers, moving at 1 second per second
19:29:03 <dsal> siraben: depends on what you mean.  I used something you could call that for traversing a maze-like problem in last year's AoC.  I just kept all the states as I proceeded and could move back to any prior point in time to make different decisions.
19:30:50 <siraben> Something like https://kcsongor.github.io/time-travel-in-haskell-for-dummies/
19:49:20 <dsal> I didn't just tardis for that particular problem.  Just a map of the past.
20:01:15 <iqubic> "If you love it so much, why don't you marry it." Turns out that Haskell makes it really easy to tye the knot.
20:07:06 <dsal> Ha
20:13:56 <ezzieyguywuf> hrm, how do I use optparse-applicative to parse an optional argument? i.e. `myProg -f some.file` versus `myProg`
20:22:16 <monochrom> Use "option". In the "Mod OptionFields a" parameter, include "value ..." for the default value to make it optional.
20:37:46 <ezzieyguywuf> monochrom: but if I provide any default value, then essentially that default value can never be provided by the user as valid input, right?
20:38:46 <ezzieyguywuf> i.e. "value -1", because sure maybe nobody would even name their file "-1", but the one time someone does and they can't because I have an `if filename == "-1" then doSomethingElse..." somewhere
20:46:32 <iqubic> Don't just parse into "-1". Parse into Maybe a. Then you can set the default to Nothing, and use "Just a" for when the user provides a value.
20:46:47 <iqubic> This is literally why Maybe exists.
20:47:33 <ezzieyguywuf> iqubic: yea, I was trying to do it into Maybe, but I guess I must have borked it up
20:47:38 <ezzieyguywuf> :) time to try again
20:54:42 <doct0rhu> Hi, I've a question regarding <> and >>. In some context, for example IO, I can chain several IO actions with >> if I don't care about the result of the previous action
20:55:33 <doct0rhu> though the result of previous action is not retained, it would still be executed.
20:56:15 <dsal> <> and >> don't have much to do with each other.
20:56:21 <doct0rhu> But I recently come across the case where I tried using >> to chain several `X ()` actions in XMonad. But it turned out only the last one is executed
20:56:25 <doct0rhu> I have to use <>
20:57:02 <dsal> :t (<>)
20:57:04 <lambdabot> Semigroup a => a -> a -> a
20:57:05 <dsal> :t (>>)
20:57:07 <lambdabot> Monad m => m a -> m b -> m b
20:57:35 <doct0rhu> Yes, purely from type theory point of view <> and >> are entirely different. But I've seen in several sources saying that >> is used to chain monadic actions together
20:57:58 <dsal> Well, sort of.
20:58:15 <dsal> It's >>= discarding the result of the left.
20:58:45 <doct0rhu> But clearly in some cases, such as the one I had, <> is the correct one but >> doesn't work
20:59:01 <dsal> <> is entirely unrelated to monads.
20:59:30 <dsal> Without knowing the types you're talking about, it's difficult to even guess what you mean.
20:59:56 <doct0rhu> sorry I should say `mappend`
21:00:05 <dsal> :t mappend
21:00:06 <doct0rhu> I should use `mappend` instead of `>>`
21:00:07 <lambdabot> Monoid a => a -> a -> a
21:00:12 <dsal> Still not related to monads
21:00:22 <doct0rhu> `mappend` is the same as `<>` though
21:00:29 <isd> Is there a good way to get the runtime to tell you how often STM transactions are being restarted due to conflicts? I'm having performance problems, and I have a hunch that it may be an issue with contenton between transactions, but I don't know how to measure.
21:01:06 <doct0rhu> :t X
21:01:08 <lambdabot> error: Data constructor not in scope: X
21:01:26 <doct0rhu> or does the bot only works with Base?
21:04:22 <doct0rhu> newtype X a = X (ReaderT XConf (StateT XState IO) a)
21:04:53 <doct0rhu> newtype StateT s m a
21:05:04 <doct0rhu>  Monad m => Monad (StateT s m)
21:05:39 <doct0rhu> so second argument to ReaderT implments Monad
21:05:43 <doct0rhu>  Monad m => Monad (ReaderT r m)
21:06:02 <doct0rhu> so ReaderT XConf (StateT XState IO) implements Monad
21:06:35 <doct0rhu> Can I deduce that, when I use >>, it's chaining `ReaderT XConf (StateT XState IO)` but not `a`
21:06:44 <doct0rhu> where `a` is actually what I want to chain
21:11:32 <ezzieyguywuf> hah, whoot I got it.
21:11:34 <ezzieyguywuf> i'm such a clutz
21:40:32 <ski> doct0rhu : do you have several actions of type `X a', and you want to combine all the `a' results of them, not just the one from the last action ?
21:40:33 <iqubic> Is there an easy way to convert a list of [(a, Maybe b)] -> [(a, b)] by throwing away all the elements where the snd is Nothing?
21:43:52 <ski> @type \l -> [(x,y) | (x,Just y) <- l]
21:43:54 <lambdabot> [(a, Maybe b)] -> [(a, b)]
21:46:55 <ski> @type catMaybes . map (uncurry (fmap . (,))) :: [(a,Maybe b)] -> [(a,b)]
21:46:58 <lambdabot> [(a, Maybe b)] -> [(a, b)]
21:46:58 <ski> @type mapMaybe (uncurry (fmap . (,))) :: [(a,Maybe b)] -> [(a,b)]
21:47:01 <lambdabot> [(a, Maybe b)] -> [(a, b)]
21:47:42 <int-e> :t catMaybes . map sequenceA
21:47:44 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
21:47:44 <ski> (unfortunately there's no `Traversable (w,)', otherwise one could use `mapMaybe sequence')
21:48:08 <int-e> instance Traversable ((,) a) -- Defined in ‘Data.Traversable’
21:48:36 <ski> oh, nice :)
21:49:37 <int-e> :t mapMaybe traverse
21:49:40 <lambdabot> error:
21:49:40 <lambdabot>     • Couldn't match type ‘t0 a -> f (t0 b)’ with ‘Maybe b1’
21:49:40 <lambdabot>       Expected type: (a -> f b) -> Maybe b1
21:49:43 <int-e> err
21:49:43 <ski> (for some reason, i thought it was missing, due to `WriterT' having the wrong ordering)
21:49:47 <int-e> :t mapMaybe sequenceA
21:49:49 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
21:50:08 <int-e> Somehow I didn't know about mapMaybe.
21:50:27 <ski> @type mapMaybe sequenceA :: [(a,Maybe b)] -> [(a,b)]
21:50:29 <lambdabot> [(a, Maybe b)] -> [(a, b)]
21:53:15 <heatsink> Is there a way to make shake use fewer parallel processes?  It's not my shake program
21:55:04 <heatsink> I was looking in the wrong place.  It was stack installing prerequisites
23:17:56 <doct0rhu> @ski I've multiple `X a`, and I want them to be executed consecutively. I don't need any of their results because I only want their side effects.
23:17:56 <lambdabot> Maybe you meant: wiki src ask
23:18:25 <doct0rhu> ski, I've multiple `X a`, and I want them to be executed consecutively. I don't need any of their results because I only want their side effects.
23:19:30 <doct0rhu> But with `foo >> bar` only the last one is executed. I have to use `mappend foo bar` or `foo <> bar`
23:20:15 <xerox_> :t mapMaybe
23:20:17 <lambdabot> (a -> Maybe b) -> [a] -> [b]
23:20:22 <xerox_> @index mapMaybe
23:20:23 <lambdabot> Data.Maybe, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.Map.Strict, Data.Map.Lazy, Data.Map
23:20:26 <xerox_> oh neat
