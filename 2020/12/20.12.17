00:10:03 <dsal> guest1216: You are probably looking for `satisfy`
00:11:53 <guest1216> dsal: I saw that letter = satisfy isAlpha, digit = satisfy isDigit, how to match a string without space
00:12:18 <dsal> :t satisfy
00:12:20 <lambdabot> error: Variable not in scope: satisfy
00:12:37 <dsal> satisfy is just (Char -> Bool)
00:12:51 <dsal> Make a function that returns true for chars you like.
00:13:06 <dsal> `satisfy (/= ' ')`
00:13:15 <dibblego> :type isSpace
00:14:03 <dsal> :t isSpace
00:14:05 <lambdabot> Char -> Bool
00:20:25 <guest1216> dsal: that's right!
00:26:53 <guest1216> dsal: sometimes the parser's return values may not be the same type, how to use <|> work on them? like `parse (x :: Parser (String,String) <|> y :: Parser (String, Int)) "" "..."`
00:27:15 <guest1216> <|> :: f a -> f a -> f a
00:27:50 <guest1216> I should use *> here... 
00:28:14 <guest1216> never mind
00:48:47 <guest1216> try to turn "server = abc.net\nport=6667\nname =nick\n" to fromList[("server", "abc.net"), ("port","6667"), ("name","nick")]
00:50:16 <guest1216> p9 :: Parser (String,String); p9 = {do; spaces; x <- many letter; spaces; char '='; spaces; y <- many (satisfy (/= ' ')); spaces; return (x,y)}
00:51:28 <guest1216> parse p9 "" "on that repeatly string" won't work
00:54:21 <idnar> shouldn't that be satisfy (/= '\n')?
00:54:59 <iqubic> Even better is "satify (not isSpace)"
00:55:10 <iqubic> Using "isSpace" from Data.Char
00:56:54 <guest1216> but that only get Right ("server","abc.net")
00:57:13 <guest1216> there're three repeat blocks in that string
00:57:25 <merijn> guest1216: Well, p9 doesn't magically get repeated
00:57:27 <guest1216> I don't know how to math that
00:57:41 <merijn> guest1216: If you write "parse p9" it will parse 'p9' *once*
00:57:45 <guest1216> merijn: how to let p9 repeat?
00:57:50 <guest1216> forever p9:
00:58:07 <merijn> Well, looking at your example input, you probably want "sepBy p9 eol"
00:58:11 <merijn> @hoogle sepBy
00:58:12 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
00:58:12 <lambdabot> Text.Parsec sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
00:58:12 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
00:58:15 <merijn> hmm
00:58:33 <merijn> Probably want the version from parser-combinators if you're using megaparsec
00:58:49 <solonarv> yes, and it's re-exported by megaparsec
00:58:55 <guest1216> I don't know speBy's usage, spe is short for?
00:59:00 <merijn> separator
00:59:15 <solonarv> *sep*, not *spe*
00:59:17 <merijn> "sepBy x y" is "parse 0 or more 'x' separated by 'y'"
00:59:33 <solonarv> "sepBy" is short for "separated by", it's meant to be used infix
00:59:36 <merijn> So "sepBy p9 eol" would be "parse 0 or more p9, separated by newlines"
00:59:58 <solonarv> for example, "p9 `sepBy` eol" reads "p9 separated by newline(s)"
01:00:18 <guest1216> ok, I will try it
01:02:00 <guest1216> there's no eol in Text.Parsec...
01:02:37 <dminuoso> merijn: From what I gathered over the past few days, they're using parsec?
01:07:31 <int-e> guest1216: there's https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec-Char.html#v:endOfLine
01:09:50 <superstar64> is there a sort of semi flexible instances, where you can only match `T a b c` or raw type variables `a`?
01:09:58 <superstar64> i find i'm doing this pattern a lot in my code
01:10:06 <guest1216> parse (sepBy p9 endOfLine) "" "server = abc.net\n port= 6667\n" == Right ("server", "abc.net\n")
01:15:13 <dminuoso> superstar64: What do you mean by "only match `T a b c`" exactly?
01:15:30 <superstar64> that's the normal requirement for instances right?
01:16:13 <superstar64> i just want instances with that and the option to match with only a type variable
01:16:17 <dminuoso> superstar64: Standard Haskell demands the shape of the instance head to be `T a_0 a_2 .. a_n` where a_0 through a_n is an arbitrary amount of type variables
01:16:30 <superstar64> yes i know that
01:16:37 <dminuoso> So what is your question exactly?
01:17:14 <superstar64> i'm just noticing i'm doing something slightly looser and i'm wonder if there's a limited version of flexible instances?
01:17:22 <dminuoso> What do you mean by "limited" exactly?
01:17:34 <dminuoso> Do you have an example of an instance you'd like to write?
01:17:39 <superstar64> the normal `T a b c` and the ability to match `a`
01:17:46 <dminuoso> You mean like `T Int b c` ?
01:17:51 <superstar64> no
01:18:05 <dminuoso> Then I do not understand.
01:18:51 <superstar64> `instance (a ~ a') => F a (MyObject a')`
01:19:18 <superstar64> i only want the ability to match `T a b c` and `a`
01:20:44 <superstar64> " (Arguably it should be okay if just one has this form and the others are type variables, but that’s the rules at the moment)." from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances
01:20:52 <superstar64> is there more info on this?
01:28:07 <lortabac> superstar64: do you mean you want to forbid the head of the instance declaration from mentioning concrete types in type-constructor arguments?
01:28:24 <superstar64> yes
01:28:45 <superstar64> i just want normal rules in addition to matching type variables
01:29:40 <guest1216> where it's wrong? https://paste.ubuntu.com/p/QSCc59fsFR/
01:29:51 <lortabac> superstar64: isn't it just Haskell 98?
01:30:17 <superstar64> lortabac, no you can't do `instance F a where`
01:31:37 <lortabac> is there a use case for 'instance F a'?
01:31:40 <merijn> superstar64: You can, but that overlaps everything, so that's not what you want :p
01:31:43 <merijn> lortabac: No
01:31:44 <dminuoso> superstar64: https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf should be a worthwhile read.
01:32:12 <superstar64> there's a uses with multiple param typeclasses
01:32:44 <merijn> superstar64: multi param typeclasses aren't standard anyway, so Haskell2010 says nothing about it :p
01:32:45 <int-e> guest1216: satisfy (/= ' ') matches newlines
01:33:04 <superstar64> well i want multi param typeclasses with semi flexible instances
01:33:14 <merijn> That's not a thing
01:33:25 <int-e> guest1216: not sure what to use instead, maybe try  satisfy (not . isSpace)  (isSpace is from Data.Char)
01:33:27 <merijn> Just enable FlexibleInstances
01:33:37 <lortabac> superstar64: even with multi param typeclasses, matching on 'a' is generally a bad idea
01:34:11 <int-e> guest1216: the other thing that's wrong is that you don't terminate the parse using `eof`, so it can stop in the middle and discard the remaining input.
01:34:58 <dminuoso> superstar64: So you roughly want something like `instance {-# OVERLAPPING #-} C (T a b c); instance C a` ?
01:34:58 <lortabac> superstar64: there might be situations in which it is necessary, but those are certainly not common
01:35:21 <superstar64> what's `{-# OVERLAPPING #-}`?
01:35:32 <int-e> guest1216: try parse (endEndBy parseAll endOfLine *> eof)
01:35:43 <int-e> guest1216: err, sepEndBy
01:36:05 <dminuoso> superstar64: Overlapping instances, keep in mind that `instance C a`, were it allowed, would match *all* types, including `T a b c`
01:37:36 <dminuoso> Unlike case-of in the value world, where the pattern matching has a tractable order, such that `case t of T ... -> ...; _ -> ...` makes sense, it doesn't work like that typeclasses. If `instance C a` was allowed, the above would be the sort of equivalent
01:38:06 <dminuoso> Oh. it seems allowed inf act with FlexibleInstances
01:38:10 <dminuoso> % instance Functor f
01:38:10 <yahb> dminuoso: ; <interactive>:5:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor f'
01:38:17 <dminuoso> Well. I guess there you go, then.
01:38:48 * dminuoso regrets overlapping instances every time
01:39:08 <superstar64> maybe i can avoid flexible instances with functional dependencies, i'll try to refactor my code
01:39:20 <dminuoso> superstar64: fundeps does not replace flexible instances.
01:39:32 <merijn> https://twitter.com/Symbo1ics/status/1339328851365814272 >.>
01:39:33 <superstar64> does it replace my specific usecase?
01:39:47 <dminuoso> in fact, for fundeps to be useful you usually have to enable MPTC, and flexible instances/contexts anyway
01:40:26 <int-e> merijn: why does that sound like XML
01:41:31 <lortabac> superstar64: you didn't say what you use case is :)
01:41:34 <lortabac> *your
01:41:42 <int-e> (What I mean is, in this context, JSON looks like an XML-shaped hole for people to fall into.)
01:41:58 <dminuoso> int-e: Unlike programming code, JSON is human readable!
01:42:05 <superstar64> i'm writing a compiler and i find this neat way of having composible typesystems
01:42:06 <merijn> @quote the.essence.of
01:42:06 <lambdabot> dibblego says: if only all/most programmers understood the essence of compositional programming... _peter:  Stupid question, is there any nice way to do a ::= with a list?
01:42:09 <merijn> aww
01:42:11 <merijn> wrong quote
01:42:28 <superstar64> it's a lot of `instance (a ~ a') => F a (G a')`
01:42:32 <merijn> @quote Wadler essence.of
01:42:33 <lambdabot> Wadler says: So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
01:43:38 <kuribas> the tools around it suck, but then it's made for languages that suck
01:43:50 <kuribas> so it cancels out
01:45:53 <lortabac> superstar64: it's hard to tell without knowing the details, but at first sight it looks like a good use case for singleton-bool
01:47:02 <superstar64> i have things like `data Application e = Application e e` ... `instance TypeCheck e (Application e')` ...
01:50:00 <lortabac> superstar64: so the purpose of the instance is only to ensure that the types are equal?
01:50:22 <lortabac> is there are instance for when the types are NOT equal?
01:50:36 <superstar64> i don't think so
01:50:58 <lortabac> then can't you just write a function?
01:51:33 <superstar64> i have a giant either chain, and the an instance for `TypeCheck` for either
01:51:41 <superstar64> and a project from my ast to the either chain
01:52:43 <lortabac> superstar64: are you sure you need the TypeCheck class at all?
01:52:57 <superstar64> well, i don't need them, but it makes this code way more composble
01:53:43 <lortabac> the purpose of type classes is overloading, if you don't do any overloading I don't see the point
01:54:04 <lortabac> but I don't know your code, so I might have misunderstood
01:54:06 <superstar64> if i have 2 different asts, i can share a lot of code between them this way
01:54:26 <superstar64> i just need to project them both into an either chain
01:54:58 <lortabac> then it looks like you need 'instance TypeCheck AST1' and 'instance TypeCheck AST2'
01:55:25 <superstar64> no, i have each constructor as it's own type
01:59:02 <solonarv> superstar64: what are the methods of this TypeCheck class?
02:00:19 <superstar64> i just have 1 method per typeclass
02:01:07 <solonarv> that is an extremely weird way of splitting things up
02:02:04 <solonarv> but what, *exactly*, is the (apparently only) method of TypeCheck?
02:04:10 <superstar64> `class TypeCheck m e σ where { typeCheck :: e -> m σ }`
02:05:49 <solonarv> uhhh... then how are you writing 'data Application e = Application e e; instance TypeCheck e (Application e') where ...' ? that doesn't kind-check
02:06:43 <superstar64> give me a second, i'll post a paste after i'm done refactoring
02:09:08 <merijn> I'm now morbidly curious
02:11:31 <superstar64> https://gist.github.com/Superstar64/5eb07d95e538f8a320d611471471d3dd
02:18:09 <superstar64> this is called the tagless final style right?
02:18:28 <superstar64> i read oleg's paper on tihs
02:18:55 <superstar64> or wait, i might be misremebering
02:22:17 <merijn> Well...that looks like a nightmare to actually use :)
02:22:45 <solonarv> I agree. I can't fathom why you would design your compiler like this.
02:23:00 <superstar64> so i can share code between 2 different asts?
02:23:21 <merijn> superstar64: In reality you can't share code between different ASTs
02:23:27 <solonarv> do you actually *have* two different ASTs? I don't even see one AST in there
02:23:28 <superstar64> if i have a hindley milner version and an explicited typed version, i can share these typing rules
02:23:42 <superstar64> that's only the typing rules solonarv
02:24:01 <merijn> Prediction: The overhead and confusion of this whole approach will cost you 5x more time than simply writing the code twice
02:24:30 <solonarv> merijn: seconded
02:24:37 <superstar64> https://gist.github.com/Superstar64/dfd430fcf10f3cb6363b5377116a96d1
02:24:49 <superstar64> here's a snippet from my core language
02:25:15 <superstar64> it's been working pretty well for me so far
02:27:31 <fuzzypixelz> can I write multiline list comprehensions?
02:27:53 <superstar64> fuzzypixelz, can't you use do notation for that?
02:27:57 <guest1216> int-e: https://paste.ubuntu.com/p/SVc9hPqn3t/
02:28:41 <solonarv> fuzzypixelz: of course, you can generally spread any expression out over multiple lines; list comprehensions are no exception to that
02:29:26 <fuzzypixelz> yes, but I don't know how to use do notation...
02:29:27 <guest1216> int-e: https://paste.ubuntu.com/p/Ssn6PbxJVK/
02:30:23 <solonarv> fuzzypixelz: here's an example of a multiline list comprehension: https://github.com/Solonarv/adventofcode-2020/blob/main/haskell/solutions/Day03.hs#L46-L53
03:34:23 <pja> solonarv: I usually turn those into do .. pure blocks.
03:35:01 <pja> Not sure why, but I prefer it that way.
03:38:17 <int-e> pja: they lay out more nicely and the result is at the end... so when reading code linearly you know what the variables in there are. all this for the small price of having to use `guard` for filtering by boolean constraints
04:08:33 <[exa]> is there any good reading material about the logic of migrations in Database.Selda ? (tutorial is missing so far)
04:34:18 <cheater> has anyone been able to compile the llvm lib for llvm 9.0.1 on windows?
04:35:34 <fuzzypixelz> hello
04:35:38 <fuzzypixelz> I write
04:35:40 <fuzzypixelz> lambda byr: byr >= 1920 and byr <= 2002
04:36:10 <[exa]> fuzzypixelz: that's some snakeish variant of haskell?
04:36:12 <int-e> That doesn't look like Haskell, what is it? Python?
04:36:15 <fuzzypixelz> but pylint says: simplify chained expression between operands
04:36:23 <int-e> [exa] said it better
04:36:24 <fuzzypixelz> oh my lord! wrong channel!
04:36:34 <[exa]> p a r s e l t o n g u e
04:36:58 <superstar64> https://pyos.github.io/dg/
04:36:59 <[exa]> oh worry not though. :]
04:37:15 <fuzzypixelz> Please forgive my blasphemy
04:37:44 <superstar64> fuzzypixelz, you might be interested in dogelang
04:37:48 <idnar> fuzzypixelz: lambda byr: 1920 <= byr <= 2002 # a freebie
04:38:17 <fuzzypixelz> I will definitely check it out superstar64, as in right now
04:38:38 <[exa]> cheater: still the same problem with linking btw? (you might want to ask in #llvm, there will likely be more windowsy people)
04:38:39 <superstar64> "With Haskell's syntax but none of its type system, dg is the best way to make fans of static typing shut up already"
04:38:49 <cheater> [exa]: yes
04:38:50 <int-e> fuzzypixelz: good luck with the AoC :P
04:38:52 <fuzzypixelz> thanks idnar
04:39:07 <cheater> the llvm channel was completely useless no one even uses windows there
04:39:19 <int-e> or maybe :--< (split tongue)?
04:39:50 <[exa]> cheater: why you want it to work on windows anyway? windows simply doesn't support a lot of stuff, done.
04:39:58 <fuzzypixelz> int-e: I tried to do it with Haskell, but my tricks ran our on day 2, I just said what the heck I'll rewrite it later when I learn how to split a freaking string
04:40:45 <int-e> :t words
04:40:47 <lambdabot> String -> [String]
04:40:56 <fuzzypixelz> huh
04:41:07 <[exa]> cheater: anyway if you can't apply various "linux subsystem for W" tricks, I'd suggest to write a nicely formatted error report to LLVM mailing list or something, so that the issue stays for more potential people to see
04:41:13 <int-e> I've been abusing `words` a lot this year, including mapping commas to spaces and then using `words`.
04:41:33 <[exa]> (or to the authors of the respective haskell wraps)
04:41:50 <fuzzypixelz> int-e: but what if you need to split against specific chars?
04:41:54 <[exa]> int-e: I'm still missing some variant of strtok()
04:41:58 <idnar> :t splitOn
04:41:59 <lambdabot> Eq a => [a] -> [a] -> [[a]]
04:42:08 <cheater> int-e: are you the person who implemented that bug in cabal i was struggling with
04:42:16 <int-e> splitOn is in the split package
04:42:23 <int-e> cheater: I was talking AoC, not production code
04:42:37 <int-e> cheater: so, no
04:43:22 <fuzzypixelz> int-e: does it come with haskell platform?
04:43:44 <idnar> > splitOn "," "foo,bar"
04:43:46 <lambdabot>  ["foo","bar"]
04:43:56 <int-e> I don't really know what's included in the Haskell platform
04:44:15 <int-e> it has cabal-install so to my mind it practically includes all of hackage
04:45:03 <int-e> > words $ map (\c -> if c == ',' then ' ' else c) "foo,bar"
04:45:05 <lambdabot>  ["foo","bar"]
04:45:14 <int-e> nasty, effective
04:45:22 <superstar64> how do i make ghc warn me if a `data` could be a `newtype`?
04:45:28 <int-e> , good enough for AoC
04:45:32 <ski> > words (map (\c -> if c == ',' then ' ' else c) "foo,bar bar")
04:45:35 <lambdabot>  ["foo","bar","bar"]
04:45:43 <int-e> ski: I know!
04:46:04 <int-e> ski: include ,, for good measure
04:46:55 <ski> escaping ?
04:47:09 <int-e> > words " a  b "
04:47:12 <lambdabot>  ["a","b"]
04:47:30 <int-e> coalescing
04:47:54 <int-e> > splitOn " " " a  b "
04:47:56 <lambdabot>  ["","a","","b",""]
04:48:09 <ski> @type Data.List.NonEmpty.words
04:48:10 <lambdabot> error:
04:48:10 <lambdabot>     Not in scope: ‘Data.List.NonEmpty.words’
04:48:10 <lambdabot>     No module named ‘Data.List.NonEmpty’ is imported.
04:49:46 <idnar> superstar64: use hlint I think
04:50:29 <ephemient> if you're working on Text, that has splitOn built-in
04:50:58 <superstar64> alright, i'll look into it
04:52:24 <ski> @type mapMaybe NE.nonEmpty . splitOn " "
04:52:26 <lambdabot> [Char] -> [NE.NonEmpty Char]
04:53:00 <ski> > (mapMaybe NE.nonEmpty . splitOn ",") "foo,bar baz,,quux"
04:53:02 <lambdabot>  ['f' :| "oo",'b' :| "ar baz",'q' :| "uux"]
04:53:25 <int-e> ew
04:53:59 <int-e> . o O ( filter (not . null) )
04:54:47 <ski> but then i have to use `NE.fromList' (which is partial)
04:55:33 <int-e> I don't like NonEmpty, so why would I use that.
04:56:14 <ski> well, the goal here was to look for a way to implement `Data.List.NonEmpty.words' ..
04:56:52 <ski> (since the output elements of `words' are always non-empty)
04:56:57 <int-e> yeah I should've stayed out of it, but couldn't help myself
05:02:30 <ph88> when i want to make a tree structure is there some pattern to flatten the tree ? I was looking at monoid with mconcat which uses fold ... but im not sure if this is related
05:04:06 <solonarv> ph88: it is indeed related. there's a reason that 'toList' is a method of the 'Foldable' class.
05:07:37 <dminuoso> In fact, arguably, toList could be a minimal method of Foldable
05:07:57 <solonarv> it certainly could, it just wouldn't be a very good design (IMO)
05:08:22 <lortabac> I think it's more a question of performance
05:08:29 <dminuoso> Indeed.
05:08:37 <dminuoso> If you have an elegant recursive way to build a list, you might as well just implement foldr directly.
05:08:38 <solonarv> yes, performance is part of why it wouldn't be a good design
05:09:36 <solonarv> I suppose build/foldr fusion would take care of it, if you write toList in terms of build
05:10:24 <dminuoso> Well. if you write toList in terms of build...
05:10:32 <ph88> i want to make my own data type .. what should i do to flatten the tree structure ? implement Foldabable ?
05:10:35 <dminuoso> That's just a very very odd way of writing foldr..
05:10:39 <solonarv> then you might as well just write foldr instead, yes :p
05:10:54 <solonarv> ph88: yes, most likely. What does the data type look like?
05:11:17 <ph88> solonarv, i don't have it yet, but should be a simple type with branches and leaves
05:11:35 <solonarv> note that "implement Foldable" answers "where do I put my flattening function?", not "how do I write a flattening function in the first place"
05:11:40 <ph88> data myTree = MyLeave | MyBranch (MyTree)    something like this ?
05:11:44 <dminuoso> Well thats not foldable
05:11:50 <dminuoso> Foldable must be * -> * kinded.
05:12:01 <ph88> oh
05:12:08 <dminuoso> Also, that data type does not encode a list..
05:12:12 <dminuoso> That just encodes peano naturals
05:12:17 <dminuoso> *does not encode a tree.
05:12:29 <ph88> what should i do then ?
05:12:32 <dminuoso> At the very least you'd want `data MyTree = MyLeaf | MyBranch MyTree MyTree`
05:12:38 <dminuoso> And then perhaps you want to attach values?
05:12:49 <ph88> ye, i want some values
05:12:53 <dminuoso> So `data MyTree a = MyLeaf a | MyBranch MyTree MyTree` for a leaf-valued binary tree
05:13:14 <ph88> it's not a binary tree, should be rose tree ??
05:13:19 <dminuoso> You tell us?
05:13:38 <ephemient> *MyBranch (MyTree a) (MyTree a)
05:13:42 <ephemient> (but the intent is clear)
05:13:56 <ph88> ye there are more branches, and actually when you have one node with variable amount of branches, the order of those branches matter
05:14:22 <ph88> MyBranch [MyTree]  what about this ?
05:15:01 <ephemient> ... no values, but sure
05:15:04 <dminuoso> ph88: Do you want only the leafs to carry data, or each node?
05:16:27 <ph88> each node carries data .. but for the flatten tree i only need the information in the leaves. But i need data in nodes later for other purposes
05:21:36 <ph88> i found this package https://hackage.haskell.org/package/rose-trees what's this hash tree ?
05:24:24 <ph88> i'll come back later, i don't know what to do about this tree
05:31:17 <superstar64> how do i get the path of the binary cabal generates when i run cabal build?
05:32:54 <solonarv> superstar64: cabal exec where name-of-my-binary
05:33:03 <solonarv> that'll give you the path
05:33:14 <solonarv> if you want to copy it somewhere 'cabal install' can do that for you
05:36:50 <boxscape> Is there a function like forM_ that allows me to stop the loop once a condition is met?
05:37:00 <boxscape> If not I suppose writing it myself is fairly straightforward...
05:40:18 <ephemient> boxscape: https://hackage.haskell.org/package/monad-loops ?
05:40:54 <boxscape> hm yeah looks like there could be something in there, thanks
05:42:35 <solonarv> boxscape: MaybeT could also do it, since "early exit" is exactly what that transformer does
05:42:47 <boxscape> ah, I see
05:43:25 <solonarv> :t \f xs -> runMaybeT (for_ xs (guard <=< lift . f))
05:43:26 <lambdabot> error:
05:43:26 <lambdabot>     Variable not in scope: runMaybeT :: t0 m () -> t1
05:43:42 <solonarv> @let import Control.Monad.Maybe.Trans
05:43:42 <lambdabot>  .L.hs:61:1: error:
05:43:43 <lambdabot>      Could not find module ‘Control.Monad.Maybe.Trans’
05:43:43 <lambdabot>      Perhaps you meant Control.Monad.Trans (from mtl-2.2.2)
05:43:46 <solonarv> gah
05:43:53 <solonarv> % :t \f xs -> runMaybeT (for_ xs (guard <=< lift . f))
05:43:53 <yahb> solonarv: ; <interactive>:1:40: error:; Ambiguous occurrence `lift'; It could refer to; either `Language.Haskell.TH.Syntax.lift', imported from `Language.Haskell.TH.Syntax'; or `Control.Monad.Cont.lift', imported from `Control.Monad.Cont' (and originally defined in `Control.Monad.Trans.Class')
05:45:05 <solonarv> % :t \f xs -> runMaybeT (for_ xs (guard <=< MonadTrans.lift . f))
05:45:06 <yahb> solonarv: ; <interactive>:1:10: error: Variable not in scope: runMaybeT :: t0 m () -> t1
05:45:23 <boxscape> % :t \f xs -> Control.Monad.Trans.Maybe.runMaybeT (for_ xs (guard <=< Control.Monad.Cont.lift . f))
05:45:23 <yahb> boxscape: (Foldable t, Monad m) => (a -> m Bool) -> t a -> m (Maybe ())
05:46:37 <boxscape> % :t \f xs -> Control.Monad.Trans.Maybe.runMaybeT (for xs (Control.Monad.Cont.lift . f))
05:46:37 <yahb> boxscape: (Traversable t, Monad m) => (a -> m b) -> t a -> m (Maybe (t b))
05:46:41 <boxscape> this looks like what I want actually
05:46:42 <boxscape> thanks
05:47:09 <solonarv> if you want "early exit with a value" that's ExceptT, of course
05:47:10 <boxscape> or not quite
05:47:14 <boxscape> I'll figure it out though
05:47:24 <boxscape> I only need a value if it doesn't exit early
05:47:57 <solonarv> ah, I see
05:48:16 <ski> > (runIdentity . runExceptT . (`runStateT` 1) . forever) (do n <- get; put (2 * n); when (n > 1000) (throwError n))
05:48:18 <lambdabot>  Left 1024
05:49:36 <ski> `Cont' sounds like overkill, unless you'd like to resume
05:50:03 <int-e> @unmtl StateT s (ExceptT e Identity) a
05:50:03 <lambdabot> s -> Either e (a, s)
05:50:04 <ski> (i guess you could `Codensity')
05:50:35 <ski> oh, `unmtl' groks `ExceptT' now ?
05:53:41 <int-e> apparently ;)
06:20:57 <zclod> hi I was trying to use recursion-schemes to solve some advent of code problems, my issue is that cata is a foldr while many of the challenges require left associative operations so i need to reverse the list first. is there a way to do a foldl with recursion scheme?
06:27:03 <boxscape> zclod this seems like it should  https://stackoverflow.com/questions/57776420/top-down-recursion-schemes
06:27:24 <boxscape> help
06:27:25 <guest1217> parseString = {do; spaces; x <- many letter; spaces; char '='; spaces; y <- many (satisfy (/= ' ')); spaces; return (x,y)}
06:28:12 <boxscape> is there a fancy general lensy way to go over all the Ints in a pairs like (1,2,(3,4)) and (1,2(3,(4,5)))?
06:28:14 <guest1217> parse (sepBy parseString spaces) "" "server=irc.freenode.net port=3 nick=john" == Right [("server","irc.freenode.net"),("port","3"),("nick","john")]
06:29:05 <guest1217> parse (sepBy parseString newline) "" "server=irc.freenode.net\nport=3\nnick=john\n" == Right [("server","irc.freenode.net\nport=3\nnick=john\n")]
06:29:22 <guest1217> why the second is not like the first?
06:29:30 <guest1217> where it's wrong?
06:29:50 <tomsmeding> guest1217: perhaps parseString accepts '\n' as part of a string?
06:30:13 <tomsmeding> and so by the time the first parseString returns, the whole string has already been consumed
06:30:40 <guest1217> tomsmeding: parse (anyChar *> newline *> anyChar) "" "a\nc" == Right 'c'
06:31:03 <guest1217> oh
06:31:32 <guest1217> tomsmeding: how I can change it?
06:31:48 <tomsmeding> what's the source of parseString? or does it come from a library?
06:32:15 <inkbottle> Is there something like the STM monad for the dummies? (with nice pictures/diagrams)
06:32:16 <guest1217> tomsmeding: parseString = {do; spaces; x <- many letter; spaces; char '='; spaces; y <- many (satisfy (/= ' ')); spaces; return (x,y)}
06:32:49 <tomsmeding> that `satisfy (/= ' ')` accepts anything that's not a space, including, for example, newlines
06:32:54 <Mugisha> Hi guys i'm new here and on irc
06:33:12 <tomsmeding> guest1217: I suggest changing that (/= ' ') to (not . isSpace), where isSpace is from Data.Char
06:33:13 <ski> hello Mugisha
06:33:55 <guest1217> tomsmeding: satisfy (noneOf "\n ")?
06:34:02 <tomsmeding> guest1217: or, of course, (/= '\n') if you only want to do newlines
06:34:03 <tomsmeding> or that
06:34:11 <tomsmeding> depending on what you need :)
06:34:22 <guest1217> tomsmeding: space and newline
06:34:39 <guest1217> tomsmeding: how I can do it?
06:34:46 <tomsmeding> well, like you just said
06:35:33 <tomsmeding> also, the `spaces` at the end of `parseString` already swallows all spaces after the key=value pair, so the `spaces` in your `sepBy` will never consume anything
06:36:00 <tomsmeding> so I think you can replace `sepBy parseString spaces` and `sepBy parseString newline` with `many parseString`
06:36:08 <boxscape> loosk like tinplate works
06:37:02 <boxscape> and template does as well
06:37:19 <guest1217> tomsmeding: I tried `many (satisfy (noneOf "\n "))` noneOf applied too many arguments...
06:37:32 <tomsmeding> ah right
06:37:36 <tomsmeding> many (noneOf "\n ")
06:37:46 <tomsmeding> noneOf is already a parser, no need to wrap it in 'satisfy'
06:39:50 <guest1217> tomsmeding: parse (many parseString) "" "server=irc.freenode.net\nport=3\nnick=john\n" == Right [("server","irc.freenode.net"),("port","3"),("nick","john")]
06:40:40 <boxscape> hm is there a way to combine lenses, i.e. specifically to make a lens that operates on both _1 and _2?
06:43:06 <guest1217> tomsmeding: but why parse (sepBy parseString newline) "" "server = irc.freenode.net\nport = 3\nnick = john\n" == Right [("server","irc.freenode.net")], even I use `many (noneOf "\n ")`
06:44:20 <tomsmeding> guest1217: I think because the `spaces` at the end of parseString already consumes the \n following "irc.freenode.net". By the time the `newline` in `sepBy parseString newline` is executed, the input is already at "port", meaning the `newline` doesn't match
06:45:22 <tomsmeding> do you really need to support arbitrary newlines within your key=value lines? If not, perhaps it's a good idea to replace your uses of `spaces` within `parseString` with `many (satisfy (== ' '))`
06:45:42 <tomsmeding> then the \n won't be consumed by parseString, and the sepBy gets to read it
06:46:50 <hololeap> boxscape: so what, the getter/setter would return/take a tuple?
06:46:54 <guest1217> tomsmeding: I remove the last spaces in parseString, then run it again, there's an error, it expecting white space, letter or "="
06:47:11 <ski> > (1,2,(3,4)) ^.. (_1 <> _2 <> _3 . (_1 <> _2))  -- boxscape ?
06:47:13 <lambdabot>  [1,2,3,4]
06:47:32 <tomsmeding> guest1217: oh right, that's the final \n at the end of your input
06:47:54 <tomsmeding> perhaps not use `many parseString` but instead `many parseString <* spaces <* eof`
06:52:03 <boxscape> hololeap ski basically I want to be able to say something like `(1,2,3) & _1 `combine` _2 %~ (+3)' and end up with (5,6,3)
06:52:57 <boxscape> uh
06:53:02 <iqubic> Where does the 5 come from?
06:53:04 <boxscape> s/(+3)/(+4)
06:53:15 <boxscape> yeah I can't do basic arithmetic apparently
06:53:19 <guest1217> tomsmeding: if I want `sepBy parseString newline` work, how I should change parseString?
06:53:20 <iqubic> Oh. I see.
06:53:50 <iqubic> boxscape: That looks hard to do.
06:54:01 <tomsmeding> guest1217: read carefully what I said before :)
06:54:09 <tomsmeding> I suggested what I think is the right change
06:54:34 <ski> Mugisha : if you have any (Haskell-related) question, feel free to ask
06:54:56 <guest1217> tomsmeding: final "\n" in the input?
06:55:12 <iqubic> boxscape: Essentially you want a function that takes two lenses and makes a traversal over both things.
06:55:28 <boxscape> that sounds right
06:56:06 <iqubic> > (1,2,3) & each %~ (+4)
06:56:08 <lambdabot>  (5,6,7)
06:56:12 <tomsmeding> guest1217: https://ircbrowse.tomsmeding.com/selection/haskell?title=Conversation&events=203120,203122,203124
06:56:36 <guest1217> tomsmeding: I tried to instead spaces with many (satisfy (== ' ')), sepBy won't work
06:56:38 <iqubic> The issue with `each` is that it will traverse *all* elements in the structure.
06:56:42 <boxscape> right
06:58:14 <iqubic> boxscape: I found this with a quick search: https://stackoverflow.com/questions/17528119/combining-lenses
06:58:38 <boxscape> iqubic hm, thanks
06:58:43 <iqubic> Also this: https://github.com/ekmett/lens/issues/109
06:59:16 <boxscape> hm some interesting discussion there
07:00:02 <guest1217> tomsmeding: you're right, I remove the last sapces and replace spaces with many (satisfy (== ' ')), now sepBy work
07:00:12 <guest1217> tomsmeding: thank you
07:00:36 <tomsmeding> guest1217: cool! Note that if you do that, you won't accept ' ' characters at the end of a line
07:00:49 <iqubic> boxscape: I'm sorry you can't really do what you want to do.
07:00:58 <boxscape> oh well
07:01:10 <dminuoso> Id love to have monthly download statistics.
07:01:22 <dminuoso> Bet you'd always see *parsec jumping up in december every year. :>
07:01:40 <merijn> :p
07:01:42 <iqubic> Oh totally.
07:01:44 <tomsmeding> where * matches a non-zero length string, I guess?
07:01:49 <dminuoso> tomsmeding: Yes.
07:01:55 <dminuoso> Err. Not necessarily
07:02:10 <tomsmeding> because parsec itself is bundled with ghc, you're unlikely to download that often :p
07:02:19 <dminuoso> That depends on the version, though.
07:02:32 <iqubic> What?! Parsec is bundled with GHC? I didn't know that.
07:03:03 <iqubic> I just use Megaparsec, because 1. I love the error messages I get, and 2. I love that unit of measurement.
07:03:13 <boxscape> iqubic turns out `template` is actually even better for what I had intended than a combination of _1 and _2
07:03:23 <iqubic> What is template?
07:03:30 <iqubic> :t template
07:03:32 <lambdabot> (Data s, Applicative f, Typeable a) => (a -> f a) -> s -> f s
07:03:38 <iqubic> Ah. Yes. I see.
07:03:41 <tomsmeding> iqubic: I think this is a source of that information: https://gitlab.haskell.org/ghc/ghc/-/blob/master/packages
07:03:41 <ephemient> http://hackage.haskell.org/package/parsec old parsec, not megaparsec, is bundled. I prefer using the latter
07:03:46 <boxscape> % (1,2,(2,(3,4))) & template %~ (+1)
07:03:46 <yahb> boxscape: (2,3,(3,(4,5)))
07:04:46 <tomsmeding> iqubic: according to this wiki page ( https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries ), a '-' in the tag column indicates a ghc boot library
07:05:11 <tomsmeding> also before I knew what cabal even was, properly, I've been using parsec without problems :p
07:05:16 <ephemient> GHC also comes with ReadP
07:05:18 <dminuoso> iqubic: I find the tuple (megaparsec, attoparsec, binary) to be a suitable set of tools for most purposes. :)
07:05:26 <iqubic> boxscape: template will create a traversal that targets all elements of a given type, regardless of where they appear in the structure.
07:05:31 <boxscape> yes
07:05:34 <dminuoso> Neither is enough to cover all needs.
07:06:01 <iqubic> boxscape:  What are you doing with this?
07:06:18 <boxscape> iqubic making the bounds of my array for AOC today smaller
07:06:23 <iqubic> How?
07:08:01 <boxscape> iqubic well, not the actual bounds, but the bounds of the cells I check. I first take the bounds of the entire array and then say let bounds' = bounds & bounds & _1 . template +~ s - 1 & _2 . template -~ s - 1, where s is the number of steps left to perform, so as that number goes down, the number of cells I check gets higher
07:08:02 <guest1217> how I can turn Right [("a","b")] to fromList [("a","b")]? transparent transform?
07:08:34 <guest1217> or Right (fromList [("a","b")])?
07:08:43 <dminuoso> guest1217: fmap fromList
07:08:43 <ski> guest1217 : what should happen on `Left' ?
07:08:44 <boxscape> iqubic whoops one of those `bounds &` shouldn't be there
07:09:19 <guest1217> ski: I don't know...
07:09:25 <iqubic> ski: I assume that Right [("a","b")] is the result from calling parse.
07:09:41 <guest1217> iqubic: yes
07:09:51 <guest1217> I need to get the value by the key
07:09:51 <iqubic> In that case, I recommend applying fmap *before* running the parser.
07:09:56 <ski> if `Right (fromList [("a","b")])' is ok as result, then what dminuoso said (if `Left', then it'll not be changed)
07:10:11 <iqubic> :t parse
07:10:13 <lambdabot> error: Variable not in scope: parse
07:11:35 <guest1217> dminuoso: yes, fmap fromList (Right ...) is ok
07:11:53 <boxscape> iqubic btw each wouldn't work because my index is either (x,y,z) or (x,y,(z,w)) depending on dimension, but template works nicely with that. I thought at first I could only apply this optimization to the first two dimensions, hence trying to combine _1 and _2
07:12:01 <guest1217> what about Right [...] to fromList [...]?
07:12:11 <guest1217> fromRight?
07:12:29 <iqubic> No. Just use fmap there.
07:13:11 <guest1217> iqubic: why fromRight and (~>) is not ok?
07:14:14 <iqubic> fromRight will give you an error if the argument is Left.
07:14:34 <merijn> s/give you an error/crash your program
07:15:23 <guest1217> and (~>)?
07:15:40 <iqubic> I don't know what that is.
07:15:51 <guest1217> natural transform?
07:16:07 <iqubic> Yeah, you don't want a natural transformation here.
07:16:20 <dminuoso> You seem to be conflating terminology here. :)
07:17:01 <dminuoso> A natural transformation `S ~> T` is any function `S a -> T a`, assuming both S and T are both functors.
07:17:09 <iqubic> I assume they are talking about this: https://hackage.haskell.org/package/natural-transformation-0.4/docs/Control-Natural.html#t:-126--62-
07:17:51 <guest1217> Right is a functor, fromList is not a functor?
07:17:57 <dminuoso> guest1217: Right is not a functor.
07:18:11 <merijn> Types are functors. Neither Right no "fromList" are types
07:18:17 <guest1217> Either a is a functor
07:18:21 <dminuoso> Correct.
07:18:23 <dminuoso> Or `Maybe`
07:18:36 <dminuoso> So a function `Either a ~> Maybe` would be a natural transformation.
07:18:44 <dminuoso> Or: Maybe ~> []
07:18:58 <dminuoso> That is, `Either a b -> Maybe b` or `Maybe b -> [b]`
07:19:07 <iqubic> Here's the main issue he's trying to solve. He has a Parser [(a, b)] and wants a Parser (Map a b)
07:19:07 <guest1217> what is Map?
07:19:26 <guest1217> Map a is a functor?
07:19:27 <dminuoso> No
07:19:38 <dminuoso> Or.. mm. `Map a` is actually I think
07:19:42 <dminuoso> I was thinking Set. :)
07:19:50 <merijn> dminuoso: Map k is a functor, yes
07:19:59 <merijn> dminuoso: Also Foldable and Traversable!
07:19:59 <dminuoso> merijn: Yeah, my head is so wired to Set at the moment
07:20:03 <iqubic> Map k is a functor, but that's not going to help you here.
07:20:13 <dminuoso> merijn: being Foldable is easy, Traversable not so much. :p
07:20:48 <iqubic> All he needs is a function of the type "Parser [(k,v)] -> Parse (Map k v)"
07:20:49 <guest1217> so Either a and Map k both are functors here, and it still can't turn Right a to fromList a?
07:21:03 <iqubic> guest1217:  ~> is not a function.
07:21:25 <guest1217> iqubic: ok...
07:22:36 <dminuoso> guest1217: The point here is, think of it in terms of functions. Let's say you have a function that can turn a `Right a` into `fromList a`, what would that function's type be?
07:23:01 <guest1217> Either a b -> Map a b?
07:23:18 <dminuoso> Somewhat close, but not quite. 
07:23:43 <merijn> eh, this seems to just be a random walk through all possible formulations...[
07:23:52 <dminuoso> Yeah..
07:24:14 <ephemient> `uncurry Map.singleton :: (a, b) -> Map a b` does exist
07:24:17 <guest1217> then I don't know
07:24:29 <ephemient> but `Either a b` and `(a, b)` are pretty different
07:24:43 <Vulfe_> they are about as different as two things can be using the same letters
07:27:03 <iqubic> guest1217: What are you trying to do?
07:27:48 <guest1217> iqubic: like you said, turn Right a to fromList a
07:28:14 <tomsmeding> are you sure you're not wanting to turn 'Right a' into 'Right (fromList a)'?
07:28:18 <iqubic> Why are you trying to do that? How did you get a `Right a` value?
07:29:08 <guest1217> get Right a by parser...
07:29:16 <ephemient> what do you expect to happen with a Left _?
07:29:48 <guest1217> tomsmeding: I think I should use Right (fromList a) now
07:29:49 <dminuoso> Im thinking you have piled up too many tools and bits that confuse you.
07:30:31 <guest1217> yes, there're too many things I don't understand now
07:30:44 <iqubic> Look, what he wants to do is take the result of his parser and turn it into a Map. I think he should use (fmap fromList) *before* parsing the string into a "Right a"
07:30:50 <dminuoso> Good. So perhaps it's helpful to backtrack to the last spot where you felt comfortable and understood bits.
07:30:53 <guest1217> ephemient: I don't know
07:37:50 <dminuoso> Is there a way to detect unused package dependencies?
07:38:41 <merijn> dminuoso: Comment them out *duck*
07:40:39 <Orbstheorem> Hi, is there any way to have stack compile a small c++ program with my haskell project?
07:40:49 <merijn> Orbstheorem: Flee now
07:40:51 * tomsmeding wonders what an optimal algorithm to figure out unused dependencies would be, if all you could do is commenting them out and trying the build
07:41:03 <merijn> Orbstheorem: In short: No
07:41:06 <Orbstheorem> xDD
07:41:16 <Orbstheorem> Alright, what's the longer answer? x)
07:41:17 <tomsmeding> well, yes, that's possible
07:41:23 <tomsmeding> whether you want it is another question
07:41:25 <merijn> Orbstheorem: In long: This is a cursed question I tried to get working for a week and gave up
07:41:28 <merijn> tomsmeding: It's not
07:41:43 <tomsmeding> depends on your definition of "working"
07:41:49 <merijn> tomsmeding: Or rather, it may work if your C compiler is *also* a C++ compiler and doesn't throw a fit
07:42:09 <Orbstheorem> I'm stuck between adding a makefile and adding it to stack, but I find adding a makefile to essentially call stack dirty...
07:42:10 <tomsmeding> okay I was naively assuming C++ wouldn't be harder than C
07:42:21 <Orbstheorem> For the records, my C++ file is standalone.
07:42:43 <merijn> tomsmeding: GHC knows about C compilers, it only half knows about C++ compilers, I have a few GHC issues about this
07:42:58 <tomsmeding> TIL
07:43:25 <merijn> Orbstheorem: I have a much larger C++ codebase, but I just use my own gmake build system for that and call cabal-install from there
07:43:36 <Orbstheorem> :(
07:43:52 <Orbstheorem> Ideally I'd package it in different packages, but it's for a course.
07:44:05 <merijn> Orbstheorem: Unless you are willing to make a few (most likely relatively simple) patches to GHC there's no really good way
07:44:11 <Orbstheorem> Aaaaand, well... I'm not doing a package for one-file executable.
07:44:36 <Orbstheorem> merijn: I'm curious xD
07:44:38 <tomsmeding> define "package"
07:44:44 <tomsmeding> if we're mixing C++ and haskell
07:44:48 <Orbstheorem> `dpkg -i foo`
07:44:54 <tomsmeding> I see
07:45:05 <Orbstheorem> C++ generates an executable my haskell code will call from PATH.
07:45:33 <Orbstheorem> (It could be rewritten, but I'm not allowed to :/)
07:45:35 <merijn> Not sure how well stack plays with Makefile, but cabal-install's v2-build  has intentionally been designed to be super fast on noop builds so you can unconditionally call it in make
07:46:34 <Orbstheorem> stack run takes 6 seconds on my system (NixOS 20.09) on a no-op.
07:46:44 <Orbstheorem> stack ghci is much faster though.
07:50:17 <merijn> Orbstheorem: Anyway, I'd just make a make file that builds the C++ exe and calls stack
07:52:51 <boxscape> huh indexing my STUArray with (x, (y, (z, (w, ())))) instead of (x, y, (z, (w, ()))) *doubles* the runtime of my program, interesting
07:53:09 <Orbstheorem> Is the really scary way of doing it using Setup.hs and calling g++ from haskell code? x)
07:53:29 <merijn> Orbstheorem: Why use Setup.hs at all
07:53:40 <merijn> Orbstheorem: Can just have your main program compile with g++ on demand
07:53:49 <merijn> (in fact, I literally do that in some code :p)
07:53:57 <Orbstheorem> Nah, that sounds horrible x)
07:54:19 <Orbstheorem> I'm not saying I won't
07:54:32 <Orbstheorem> I just wanna see what's available and make my pick later x)
07:54:39 <Orbstheorem> (Yes, I'm lazy)
07:56:40 <ephemient> https://hackage.haskell.org/package/inline-c-cpp :P
08:02:00 <ph88> how can i go from this function https://hackage.haskell.org/package/Frames-streamly-0.1.0.2/docs/Frames-Streamly-CSV.html#v:readTable to a Vector of my own datatype representing that row ?
08:11:48 <dminuoso> Mmm, if I write `f == g && x == y` can I reasonably expect the first equality to be tested first?
08:12:40 <dminuoso> % True && undefined
08:12:41 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:22:9 in interactive:Ghci7
08:12:49 <ephemient> yes
08:13:04 <ephemient> http://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:-38--38-  "lazy in the second argument"
08:13:07 <dminuoso> yeah but..
08:13:12 <dminuoso> what does "lazy in the second argument" even mean here?
08:13:26 <dminuoso> Oh
08:13:32 <dminuoso> % False && undefined
08:13:32 <yahb> dminuoso: False
08:13:35 <dminuoso> I see.
08:13:46 <dminuoso> I forgot (&&) is a function.
08:13:50 <merijn> dminuoso: lol
08:14:01 <merijn> dminuoso: Sounds like time for a break :p
08:14:42 <dminuoso> Yeah tell me about it.
08:14:58 <Orbstheorem> ephemient: That's sounds like I can be even lazier :D
08:19:59 <dsal> inkbottle: STM is quite easy. Is there a particular problem you're having?  The O'Reily book covers it somewhat, but there's not much to it.
09:13:30 <ph88> i'm trying to build a project with stack with dependency Frames-streamly  stack can't find it, normally it would recommend a line for extra-deps but it doesn't do that this time, how can i add this dependency ?
09:14:13 <koz_> Just add 'Frames-streamly-whatever.version'.
09:14:18 <koz_> The SHA hash is optional.
09:14:30 <koz_> (add it to the extra-deps section, I mean)
09:42:57 <tomsmeding> boxscape: that's interesting, it looks like those have Ix instances that traverse the index space in the same order
09:48:39 <Kronic> koz_ so I stumbled upon a similar problem with another lib and I arrived at that solution through trial and error. Is there any particular reason that it does that for some libraries and not others ?
09:49:02 <koz_> Kronic: Stack keeps its own index of Hackage I believe.
09:49:17 <koz_> If it's in the index, it'll suggest; if it's not, it can't, because it has nothing to go by.
09:49:22 <koz_> However, that's just my best guess.
09:50:01 <Kronic> I see, thank you 
09:52:05 <ph88> thanks koz_ 
09:59:48 <Kronic> So, I've included a question about function application on this paste: https://dpaste.org/Ammy 
10:00:28 <Kronic> Basically, the list I want out of my function returns out of order but I don't understand why, and it appears that changing it up doesn't impact the result in a desirable way either. Anyone able to explain to me what is happening on the line I highlighted ?
10:01:41 <hyperisco> Kronic, I don't think this is a question narrowly about function application. If you evaluate your function by hand for a list of, say, 3 elements, do you get what you expect?
10:02:25 <Kronic> I included that information because that is what my understanding of the problem is, but my understanding is wrong, so
10:02:40 <hyperisco> I mean take it step by step by hand
10:02:52 <hyperisco> if you want to really understand what is happening that is what you should do
10:03:20 <gentauro> anybody using XMonad on nixos?
10:03:26 <Kronic> I see the problem
10:03:32 <Kronic> It's the last line 
10:03:48 <Kronic> I fixed it, thank you :)
10:03:49 <gentauro> I have an issue when I try to build `building package X11-1.9.2`
10:04:45 <gentauro> I noticed that only `libX11-1.6.12` is available :(
10:04:58 <Kronic> not meaning to discard your advice to trace it hyperisco, I already know function application fairly well I think I was just tunnel visioned on the line I commented on a little too much
10:05:09 <ph88> in which monad can i run this function ?  https://hackage.haskell.org/package/Frames-streamly-0.1.0.2/docs/Frames-Streamly-CSV.html#v:readTable 
10:05:52 <sm[m]> adding to koz_'s stack answer: I expect doing stack update would help there
10:06:08 <koz_> sm[m]: Yeah, that's a good point.
10:06:17 <ph88> are you talking to me ?
10:06:33 <koz_> ph88: The 'm' part requires MonadIO and MonadCatch.
10:06:43 <koz_> Basically, that translates to 'IO, or a stack with IO in its heart'.
10:08:41 <hyperisco> > let { changeOne p f xs = let (a, a') = span (not . p) xs; (b, b') = splitAt 1 a' in a ++ map f b ++ b' } in changeOne (>3) (*2) [1..10]
10:08:43 <ph88> koz_, i am trying to run this in IO but i get a type error  https://bpa.st/A2JQ  
10:08:43 <lambdabot>  [1,2,3,8,5,6,7,8,9,10]
10:09:16 <koz_> ph88: Pastebin the code?
10:09:21 <ph88> ok
10:09:46 <ph88> koz_, the code is not much more than what is in line 12 to 15
10:09:59 <koz_> ph88: Pastebin it anyway.
10:10:01 <koz_> Context helps.
10:10:04 <ph88> ok just a moment
10:10:10 <koz_> (for explanation if nothing else0
10:10:15 <koz_> )*
10:11:01 <ph88> koz_, https://bpa.st/GOVA
10:11:27 <koz_> readTable doesn't return something in IO.
10:11:38 <koz_> It gives back t m (Record rs), where t is a stream type.
10:11:39 <boxscape> tomsmeding I'm now using a custom length-indexed vector as the index with the same Ix order as the tuples, and it also has the 2x runtime, but yeah, not really sure what's going on with that
10:11:47 <koz_> So you have to use the streamly stuff to actually pull records out of it.
10:12:01 <ph88> so it's a pure value from IO monad perspective ?
10:12:04 <xerox_> > let change p f = traverse (\x -> x : [ f x | p x ]) in change (>3) (*2) [1..5]
10:12:04 <koz_> That's what your type error is saying.
10:12:06 <lambdabot>  [[1,2,3,4,5],[1,2,3,4,10],[1,2,3,8,5],[1,2,3,8,10]]
10:12:14 <xerox_> hyperisco: was hoping head was that one but no
10:12:18 <koz_> ph88: It's not in IO, if that's what you're asking.
10:12:38 <tomsmeding> boxscape: strange things
10:12:52 <koz_> Basically, the whole point of streamly is that the streams themselves are not in IO - the values you pull out of them _are_, but then you only have to be in IO for those values, not the whole thing.
10:13:00 <koz_> (which could be infinite, and thus could pose some hilarious problems)
10:13:52 <xerox_> ah [f x|p x]++[x] gives the first one as head, right
10:14:34 <ph88> koz_, do you know which type i could give it ??  https://bpa.st/IT3A 
10:15:08 <koz_> As far as I can tell, this is a vinyl problem. I dunno vinyl, so I can't help much.
10:15:27 <ph88> oki
10:15:36 <ph88> thank you koz_ 
10:15:40 <koz_> No worries.
10:16:40 <Kronic> very interesting hyperisco thank you for that!
10:16:53 <hyperisco> is it a histomorphism that could do it too
10:19:55 <hyperisco> > let changeOne p f = fst . foldr (\x (xs',xs) -> (if p x then f x : xs else x : xs', x:xs)) ([],[]) in changeOne (>3) (*2) [1..10]
10:19:58 <lambdabot>  [1,2,3,8,5,6,7,8,9,10]
11:11:43 <yitz> Any recommendations for a dead-tree book that's good for learning Haskell?
11:34:32 <ph88> Is anyone familiar with vinyl ?? I would like to supply Record  https://hackage.haskell.org/package/Frames-0.7.0/docs/Frames-Rec.html#t:Record  with an "empty" type just for test. Maybe i can use a type similar to that of RNil ?? https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Core.html#v:RNil 
11:35:22 <ph88> Type ElField is part of Record which needs the actual parameter   https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Functor.html#t:ElField 
11:35:55 <suzu_> ah god this is melting my brain
11:36:04 <exarkun> How do I narrow down the cause of a fatal exception?  eg, my program exits when "DevBot-exe: user error (Upstream source closed.)".  How do I map that onto a function that needs additional exception handling?
11:36:44 <geekosaur> +RTS -xc ?
11:36:57 <geekosaur> may require rebuilding with profiling
11:37:15 <suzu_> is there a way to get MonadIO for a Foo -> m a where `m` is an instance of MonadIO
11:38:31 <ph88> suzu_, what do you mean ?
11:38:52 <suzu_> i've got a monad: Widget HTML
11:39:02 <suzu_> making values of Widget HTML a
11:39:09 <koz_> suzu_: Sure, via ReaderT Foo m 
11:39:16 <suzu_> i want to do some RIO stuff in it
11:39:27 <ph88> suzu_, maybe you can use function  liftIO
11:39:50 <suzu_> RIO a is a wrapper on ReaderT env IO a
11:39:57 <suzu_> i want to lift RIO a's inside Widget
11:40:34 <suzu_> i want to go from RIO a -> Widget HTML a pretty much
11:40:57 <suzu_> i can almost do this
11:40:58 <suzu_> liftRIO :: (MonadIO m, MonadReader env m) => RIO env a -> m a 
11:41:00 <koz_> suzu_: Do you want an instance of MonadIO for Widget HTML I guess?
11:41:09 <suzu_> Widget HTML has a MonadIO
11:41:13 <suzu_> but no MonadReader
11:41:20 <suzu_> so im just sorta stuck
11:41:31 <koz_> I guess Widget isn't a thing you wrote?
11:41:34 <suzu_> right
11:43:09 <ph88> wish i could help :|
11:43:42 <koz_> My best bet is 'newtype-wrap Widget and give it the right instance, then unwrap again once you're done lifting'.
11:45:10 <suzu_> hmmm
11:45:32 <suzu_> newtype-wrap it and give it an 'env' addon perhaps
11:45:38 <suzu_> and then add monadreader to it
11:45:44 <koz_> The whole idea is you write like.
11:46:07 <koz_> newtype SnoymanStopMessingWithMe a = SSMWM (Widget HTML a)
11:46:09 <koz_> Then go
11:46:21 <suzu_> newtype WidgetedEnv env v a = { unwrap :: env -> Widget v a }
11:46:31 <koz_> instance MonadReader HTML SnoymanStopMessingWithMe where
11:46:36 <suzu_> lmao snoyman stop messing wit hme
11:46:46 <koz_> Since I _assume_ the environment in question is HTML?
11:46:57 <suzu_> good guess but not quite
11:47:02 <suzu_> Widget is rather strange
11:47:15 <suzu_> but i think what you're describing might work
11:47:53 <ph88> that's an interesting name for a type koz_  xD
11:47:58 <koz_> ph88: :D
11:48:17 <ph88> does someone know this type level programming data kinds stuff ??  https://bpa.st/HQYA 
11:48:19 <suzu_> oh i found an idea!
11:48:29 <suzu_> instead of writing code in :: Widget HTML a
11:48:37 <suzu_> i'll write it in :: env -> Widget HTML a
11:48:57 <suzu_> then i can rioToWidget :: RIO env a -> env -> widget HTML a
11:49:00 <koz_> suzu_: So Kleisli (Widget HTML) env a ?
11:49:02 <ph88> i had DataKinds enabled btw
11:49:07 <suzu_> rioToWidget rr e = runRIO e rr
11:49:17 <suzu_> sure idk what Kleisli is
11:49:28 <suzu_> thats probably what i ended up at by accident
11:49:29 <suzu_> lol
11:49:33 <koz_> suzu_: Kleisli m a b ~ a -> m b
11:49:40 <ph88> some kind of primitive in category theory right
11:49:47 <suzu_> looks like monad bind
11:49:50 <suzu_> so
11:49:50 <koz_> Also known as the fish arrow.
11:49:52 <suzu_> yep
11:49:54 <suzu_> >=>
11:49:55 <koz_> It's not bind - it's fish.
11:49:56 <suzu_> this thing?
11:50:01 <koz_> Yep, fish.
11:50:07 <suzu_> what's the type of fish
11:50:11 <ph88> getting hungry now
11:50:13 <koz_> :t (>=>)
11:50:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:50:20 <koz_> Oh wait, not fish.
11:50:21 <suzu_> that is
11:50:22 <suzu_> melting my brain
11:50:30 <suzu_> oh i see
11:50:32 <ephemient> also (<=<), of course
11:50:35 <koz_> Basically, fish composes two Kleislis.
11:50:43 <dsal> yitz: I read haskellbook.com on my kindle.  It'd be a lot to print.
11:50:43 <suzu_> take the a at the end and push it through two almost-bind-like things
11:50:52 <suzu_> making one bind-like-thing
11:50:57 <koz_> suzu_: They're more like 'functions which add on an effect'.
11:51:03 <koz_> Compare a -> b to a -> m b
11:51:16 <koz_> The former is pure, the latter (possibly) has effects.
11:51:30 <ph88> geekosaur, could you help me with question about DataKinds ?
11:51:33 <koz_> So fish is to Kleisli like (.) is to pure functions.
11:51:34 <yitz> dsal: Thanks. I'm thinking of taking advantage of company policy to order a book. If they got a print version, I'll look into that one. Thanks!
11:52:04 <suzu_> hmm
11:52:07 <merijn> suzu_: >=> is just "\f g x -> f x >>= g"
11:52:11 <ph88> yitz, i think there was another pretty good book released after the haskellbook, and that book looked better to me
11:52:14 <suzu_> whats the nice way to write what i ended up with then?
11:52:14 <merijn> :t (>>=)
11:52:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:52:46 <suzu_> i'm now working in ((->) Env) Widget HTML a
11:52:55 <suzu_> so the ((->) Env) monad instance
11:53:03 <yitz> ph88: got a title?
11:53:04 <suzu_> and having to `pure` a lot of stuff
11:53:14 <ph88> yitz, i will look just a moment
11:53:32 <dsal> yitz: There are print version of books that are not the first book you should read.  :)  I'd say there are three levels.   haskellbook.com is good material, though not perfect.  People have also been recommending:  https://www.cs.nott.ac.uk/~pszgmh/pih.html
11:53:55 <dsal> This is a really good second book:  https://simonmar.github.io/pages/pcph.html
11:54:42 <dsal> From there, https://thinkingwithtypes.com/ will take you quite deep.
11:55:03 <dsal> This one is really great for getting a basic understanding of lens:  https://leanpub.com/optics-by-example
11:55:21 <dsal> Caveat, though.  You'll be really angry with all your other tools once you start having better things to compare them to.
11:55:47 <dsal> (not that there's nothing to complain about in Haskell, but many of the parts that aren't perfect are just nonexistent in stuff I have to do at work)
11:56:03 <yitz> lol. Thank you
11:56:08 <suzu_> ok this doesnt work
11:56:15 <suzu_> im going to newtype widget as you suggested koz_ 
11:56:17 <suzu_> i think that's it
11:56:38 <koz_> suzu_: Any problem can be solved by adding enough newtypes. :P
11:56:53 <suzu_> why cant it derive monad for me wtf
11:57:07 <koz_> suzu_: How are you asking it to derive?
11:57:17 <suzu_> probably by doing it wrong
11:57:19 <suzu_> newtype RIOWidget env v a = RIOWidget {unRIOWidget :: env -> Widget v a} deriving (Functor)
11:57:43 <suzu_> adding Monad / Applicative to that list says it can't do eta-reduce it enough to get it to work?
11:57:45 <koz_> deriving (Functor, Applicative, Monad) via (Kleisli (Widget v) env) should work?
11:57:46 <ph88> yitz, i was also thinking of this book  https://www.cs.nott.ac.uk/~pszgmh/pih.html 
11:57:52 <suzu_> oh
11:57:54 <koz_> (you need DerivingVia on)
11:58:00 <yitz> Two recommendations for the same book! That's promising
11:58:03 <yitz> Thanks, ph88 
11:59:07 <suzu_> thath worked
11:59:09 <suzu_> .. why did that work
11:59:12 <suzu_> what did i just do
11:59:14 <suzu_> lol
11:59:20 <koz_> suzu_: There's two steps here.
11:59:22 <suzu_> @i Kleisli
11:59:22 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
11:59:38 <koz_> First, GHC sees that your type is coercible to env -> Widget v a
11:59:55 <koz_> Then it sees that env -> Widget v a is coercible to Kleisli (Widget v) env a
12:00:00 <suzu_> ^ ok what
12:00:09 <koz_> Then it sees that Kleisli (Widget v) env a has the instances you asked for.
12:00:19 <koz_> So it then basically scribbles in all the methods with a bunch of coerces.
12:00:40 <ph88> that's a lot of scribbling
12:00:49 <koz_> ph88: Saves _you_ doing it, though!
12:00:50 <suzu_> Kleisli m a b, is a -> m b
12:01:08 <ph88> well i'm still stuck on DataKinds, but ok Kleisli lol :p
12:01:38 <suzu_> so Kleisli (Widget v) env a is env -> (Widget v) a
12:01:43 <suzu_> ok
12:02:10 <suzu_> and then all these nistances under Klesli in Control.arrow are on (Kleisli m) for any m
12:02:12 <suzu_> okay
12:02:14 <suzu_> i get it
12:02:16 <suzu_> wow
12:02:23 <suzu_> that is an excellent tool
12:02:27 <koz_> DerivingVia is pretty handy for exactly these kinds of scenarios.
12:02:29 <suzu_> i am keeping that in my pocket
12:03:08 <koz_> Note: Traverse is annoyingly resistant to being derived this way.
12:03:18 <koz_> So don't be surprised if you see coercion gore from GHC if you try it.
12:10:58 <ph88> anyone else experience that haskell programs in powershell are very slow ?
12:12:52 <koz_> ph88: What do said programs do?
12:13:02 <koz_> (like, in your experience of slowness?)
12:13:10 <ph88> well ghc itself is very slow
12:13:30 <ph88> when i run a virtualmachine on the same machine with linux it's faster
12:14:10 <Kronic> I prefer coding in a VM personally, haskell using haskell on windows was a huge pain 
12:14:20 <Kronic> I brainfarted hard there... 
12:14:40 <Kronic> s/haskell using haskell/using haskell
12:23:34 <xsperry> ph88, "when i run a virtualmachine on the same machine with linux it's faster" <- how much faster?
12:24:45 <dsal> yitz: I don't exactly count as a recommendation for the Hutton book.  I've not read it.  The thing I liked about haskellbook.com (and a lot of people *didn't* like) was that it goes very slow with no assumed knowledge.  Forgetting things you know about programming will make it easier.
12:25:31 <monochrom> Generally linux is more efficient than windows. Even linux in virtualbox on windows is more efficient than native windows, heh.
12:25:46 <yitz> I'm good at forgetting things. But I'm not very good at deciding _which_ things to forget...
12:26:27 <monochrom> Kronic: It's alright, when one builds GHC from source, it counts as haskell using haskell, and it's known to take a while :)
12:27:57 <monochrom> I like haskellbook.com being slow. I no longer recommend it because it has technical inaccuracy that are unnecessary.
12:28:28 <merijn> monochrom: Which inaccuracies?
12:28:33 <monochrom> I forgot.
12:28:51 <monochrom> (Conveniently, eh?)
12:29:12 <Kronic> what do you recommend instead?
12:29:13 <merijn> monochrom: I like that it includes megaparsec and transformers instead of just Haskell, because parser combinators and transformers are kinda mandatory :p
12:29:42 <monochrom> Yeah it has a lot of good things.
12:29:46 <merijn> Kronic: fwiw it worked well for my girlfriend
12:29:57 <Kronic> I own the book already
12:30:21 <Kronic> I was just curious because I'm not having many problems making progress, I'm just curious in case I want to recommend a friend or work mate 
12:30:52 <merijn> I heard Bird's "Thinking Functionally with Haskell" and Hutton's "Programming in Haskell" were good, but I haven't read either
12:31:05 <ezzieyguywuf> when a package has a dependency of ">=QuickCheck-2.13.2 && <QuickCheck-2.14", how can I find out the reason for the upper limit?
12:31:10 <merijn> Admittedly, I haven't read more than a few half chapters of HFFP either :p
12:31:21 <ezzieyguywuf> there's a few that have this same callout for quickcheck
12:31:25 <merijn> ezzieyguywuf: Disabling it and seeing if it works ;)
12:31:36 <ezzieyguywuf> lol
12:31:44 <ezzieyguywuf> is it generally safe to try that?
12:31:49 <ph88> xsperry, significantly ... but i would have to measure. bit busy right now to do those measurements
12:31:58 <monochrom> I recommend starting with the wikibook, so you don't have to sink money yet, and maybe it is already enough. If it is not enough, then Hutton's, but take it very slowly, it is not long but you should not use speed reading.
12:32:02 <merijn> ezzieyguywuf: There is syntax to distinguish "know to not work" and "not known if it works" in newer cabal versions, but not yet
12:32:05 <ezzieyguywuf> i.e. do folks usually put the upper limit "just in case"?
12:32:20 <merijn> ezzieyguywuf: A lot of people do and the ones who don't *should*
12:32:24 <ezzieyguywuf> merijn: awww man can't wait, lol
12:32:48 <monochrom> I suspect that the 1000-page length of haskellbook.com works on the simple ground that even if you try speed reading the 1000 pages will slow you down back to the correct pace.
12:32:51 <ezzieyguywuf> merijn: hrm, can you elaborote on why one should set an upper limit? should the upper limit always be the next minor rev?
12:32:51 <merijn> ezzieyguywuf: "newer" == cabal-install 2.4 :p
12:33:07 <merijn> ezzieyguywuf: https://pvp.haskell.org/
12:33:39 <ezzieyguywuf> cabal-install 2.4? isn't that super old?
12:33:49 <ezzieyguywuf> I'm trying to package 3.2 right now for gentoo
12:34:06 <merijn> ezzieyguywuf: In cabal-version 2.4 and later you have "QuickCheck ^>= 2.13" which means "PVP compatible with the API" of 2.13 (which basically means "untested with anything later")
12:34:11 <merijn> ezzieyguywuf: Hence "newer" in quotes :p
12:34:20 <monochrom> IOW people these days don't stop after every two sentences and close the book and reflect "does it really mean what I think it means? how do I test my understanding?".
12:34:36 <merijn> ezzieyguywuf: As opposed to "QuickCheck < 2.14" which then becomes "*known* to not work"
12:35:25 <merijn> ezzieyguywuf: cabal-install also has a flag to allow newer bounds for all upperbounds from ^>= without automatically including all the < bounds
12:35:30 <ezzieyguywuf> merijn: hrm, so in my head that is translating to "If I don't see a ^, probs ok to poke it"
12:35:31 <davean> monochrom: Two sentances seems like a sentance and a half too much given how I read research papers
12:36:06 <monochrom> Well, for a mere Haskell textbook, it's OK.
12:36:07 <merijn> ezzieyguywuf: A lot of cabal files in the wild use an older version of the format for many different reasons, so it's not very wildspread, but yes
12:36:11 <ezzieyguywuf> merijn: is that feature specific to cabal-install, or available in the underlying cabal library?
12:36:15 <merijn> ezzieyguywuf: Actually, more the opposite
12:36:22 <merijn> ezzieyguywuf: Which part
12:36:33 <ezzieyguywuf> merijn: "allow newer even if it says don't"
12:36:38 <merijn> ezzieyguywuf: It's more like "if you see ^ then it probably ok to relax" not the other way
12:36:42 <davean> ezzieyguywuf: Cabal.
12:37:02 <davean> ezzieyguywuf: cabal-install is just a thing that uses Cabal. Everything really to do with the .cabal file is Cabal.
12:37:15 <ezzieyguywuf> right right
12:37:17 <merijn> ezzieyguywuf: Since "foo ^>= 3.14" says *known* to work with 3.14 (and PVP compatible releases) which says nothing about whether newer versions work or not
12:37:30 <ezzieyguywuf> hrm, I see
12:37:49 <ezzieyguywuf> maybe I look at quicheck changelog
12:37:55 <merijn> The distinctio between "know to not work" and "not known to work" is why ^>= was introduced
12:38:00 <ezzieyguywuf> I mean, from 2.13 to 2.14 what could have changed...
12:39:46 <ezzieyguywuf> yea, changelog seems to indicate a bunch of speed improvements behind the scenes, but doesn't explicitly say that the api changed
12:39:55 <ezzieyguywuf> (I don't even really understand ABI and PVP...)
12:40:12 <davean> There are, not well maintained, tools to diff Haskell APIs
12:40:21 <davean> but version changes can also relate to semantics
12:45:12 <ezzieyguywuf> ahh, see random (the package) changelog "breaking change that...."
12:45:21 * ezzieyguywuf sees and nods "ah yes, very good to know"
12:46:05 <davean> ight
12:48:36 <ph88> anyone know how i add instance of Parseable to read a csv file ?  https://bpa.st/BG4A  
13:15:40 <ph88> oh found it i think
13:31:05 <ph88> hurray, after 4 hours i was able to read a line from the csv :D
13:34:25 <dsal> Frames?  Are you doing R in Haskell?
13:36:34 <ph88> https://hackage.haskell.org/package/Frames-0.7.0
13:46:32 <koz_> . o O ('R in Haskell' = 'Raskell'? )
13:48:23 <Rembane> Rascal! 
13:48:53 <koz_> Data-oriented Scheme dialect gogo?
13:49:16 <geekosaur> waskelly wabbit?
13:50:20 <Rembane> ...for the enterprise
14:13:35 <koz_> Is there some newtype Foo over Maybe a, such that we have a Semigroup instance where 'Foo Nothing' is an absorbing element?
14:13:48 <koz_> (assuming a has a Semigroup instance of its own)
14:17:23 <dolio> Ap Maybe?
14:17:52 <koz_> dolio: Perfect, thank you!
14:18:07 <koz_> I assume its Monoid instance just does 'Just mempty'?
14:18:19 <dolio> Presumably.
14:18:49 <koz_> Appears like it does, awesome.
14:19:53 <koz_> Time for sick deriving shenanigans.
14:29:55 <koz_> "The pat_lhs for explicitly bidirectional construction cannot use Record syntax. (Because the rhs expr might be constructing different data constructors.) It can use guards with multiple equations."
14:30:13 <koz_> Is the intent of the sentence that 'guards with multiple equations' can substitute for Record syntax?
14:30:17 <koz_> Or are they just unrelated?
14:33:57 <monochrom> Unrelated.
14:34:07 <koz_> Figured as much, sads.
15:03:35 <koz_> I need naming advice. I keep running into this type: data Foo a = None | ExactlyOne a | TooMany.
15:03:40 <koz_> What's a good name for this?
15:06:03 <EvanR> Maybe (Maybe a) ? :P
15:07:02 <koz_> EvanR: Isomorphism is not naming. :P
15:07:18 <EvanR> or Maybe on top of the zero or one type of your choice
15:07:37 <EvanR> the TooMany seems like an add-on
15:07:52 <justsomeguy> koz_: I saw a video where edwin brady mentions a particular name for this from whatever fancy type system he's basing his language on.
15:07:58 <dolio> It's the flat lattice on `a`.
15:08:01 * justsomeguy tries to remember the name he used...
15:08:28 <koz_> dolio: What's a flat lattice?
15:09:14 <dolio> It's got a bottom and a top and a single layer of 'totally defined values' in the middle, which are all incomparable.
15:09:26 <koz_> dolio: TIL, thanks.
15:09:53 <dolio> Like the integers as a lattice.
15:11:14 <dolio> People describe the Haskell integers as a "flat domain", because there's no top.
15:11:29 * justsomeguy would probably just call it Quantity
15:14:04 <EvanR> data Goldilocks a = TooFew | JustRight a | TooMany
15:20:23 <koz_> EvanR: Good enough for me!
15:24:34 <koz_> justsomeguy: If you find out what Edwin named it, I'd be curious to hear.
15:25:08 <justsomeguy> koz_: In this paper he calls it multiplicity https://dl.acm.org/doi/10.1145/3209108.3209189
15:25:18 <koz_> Yeah, that works too.
15:26:22 <EvanR> ThisMany Int a
15:26:38 <EvanR> -> Multiplicity a
15:26:46 <justsomeguy> "Briefly, in QTT a variable has a multiplicity: 0, 1 or unrestricted (ω)."
15:26:48 <EvanR> or some such
15:27:05 <koz_> So 0, 1 and too many. :P
15:28:52 <hpc> "there are 3 numbers in programming: 0, 1, and infinity" :D
15:33:14 <justsomeguy> I really hope that Idris becomes a useable language for practical things in my lifetime. (Maybe it already is?)
15:33:38 <koz_> justsomeguy: Libraries and tooling, yo.
15:33:56 <justsomeguy> Yeah, also better performance.
15:34:24 <hpc> just do what python programmers do and write C instead :D
15:34:48 <hpc> (or haskell) and then ffi it
15:37:04 * justsomeguy is super interested, but will probably never get around to it. He's already putting a bunch of time in to figure out Haskell, which is already pretty far removed from the mindshare of people who do simple sysadmin things.
15:37:32 <justsomeguy> I almost picked go or rust, but haskell was just too interesting.
15:37:45 <koz_> justsomeguy: I'll pick 'can do this at all' before 'can do this fast'.
15:38:00 <koz_> Having to roll your own... everything is the biggest impediment to Idris' success IMHO.
15:38:22 <EvanR> success at being an interesting research project, check
15:38:47 <EvanR> success at being promoted to de facto next big thing by fans, check
15:39:14 <EvanR> it's failed to avoid success already!
15:39:36 <koz_> EvanR: 'Avoid success at any cost' is not the Idris motto last I checked. :P
15:39:45 <hpc> justsomeguy: there's a surprising amount of overlap between haskell and puppet, i have found
15:39:50 <EvanR> exactly
15:44:05 <justsomeguy> hpc: I thought Haskell would be great for writing small cli utilities that are easy to test and easier to distribute than Python, which is what I'm using now. (Well, sort of, I'm a terrible programmer, so I don't write too much to begin with.)
15:49:23 <Boarders> what is the idiomatic way with a bytestring to drop the first line (everything up to and including the first \n)
15:51:45 <Rembane> Boarders: I use drop 1 . dropWhile (/= '\n'), but I'm not sure it's the best way. 
15:52:18 <Boarders> I reach for something similar but with Bytestring.break (== '/n')
15:52:28 <Boarders> but unclear if there is something more appropriate
15:53:38 <Rembane> Boarders: break lets you keep the first line, you can throw it away immediately by using dropWhile instead
15:55:56 <Boarders> fair point
15:58:51 <justsomeguy> Does “{-# LANGUAGE FlexibleInstances #-}” just allow you to write concrete compound types in instance declarations? Am I understanding this correctly?
15:59:49 <justsomeguy> So I can do something like “instance Something [Char] { ... }” rather than “instance Something [a] { ... }”?
16:00:47 <justsomeguy> Ok, testing it out, that seems to be correct.
16:01:11 <sm[m]> justsomeguy: distribution is a bit harder than python in some ways, isn't it ?
16:01:20 <ddellacosta> I think it also allows more arbitrary levels of nesting
16:03:26 <justsomeguy> sm[m]: I get the impression that setting up CI could be complicated. My use case is basically "ship a single static binary of a simple utility to other similar linux VMs", though.
16:04:05 <sm[m]> Ah, that's easy enough then
16:04:41 <hpc> sm[m]: even if you package it in a deb or something, you don't need to give it any dependencies
16:04:45 <hpc> just plop it in /usr/bin
16:04:47 <justsomeguy> Probably any compiled language could boast the same benefit, but I only know Python (and a smidgen of JS/ruby/shell) at this point.
16:05:09 <hpc> any compiled and static linked language
16:05:55 <hpc> dynamic linked, and you get stuff like most C++ software, where you're pulling in dozens of libfoo packages for any given tool
16:06:20 <dolio> The Haskell report says that all instances must be like `T x y z ...` where `T` is a concrete thing, and the variables `x, y, z, ...` are all distinct. So anything that isn't like that requires flexible instances.
16:06:59 <sm[m]> hpc: I'm thinking about the difficulty of sharing not-entirely-static binaries on machines of different vintage, distro or architecture, and the effort required to build if you ship source instead. Compared to a python  script
16:08:56 <koz_> Hoogle appears down?
16:09:16 <justsomeguy> Thanks dolio
16:12:42 <hpc> ah, fair
16:20:42 <dminuoso> justsomeguy: Setting up the CI can be quite simple. Here, we have a gitlab-ci runner that does nothing but just run a simple shell command `cabal build` and that's it!
16:21:44 <dminuoso> One of our main projects just does a simple `cabal v2-build -j4 odin && cp $(cabal-plan list-bin odin) bin/odin` - that's it! :)
16:24:35 <dminuoso> So distributing it as simple as just giving you the elf binary, with the added understanding that the target system must provide for glibc/libgmp, and whatever other shared libraries you may need.
16:24:44 <dminuoso> But that's no different than any other binary distribution.
16:28:35 <justsomeguy> Sounds relatively simple!
16:32:10 <dminuoso> Static builds are possible too, https://www.tweag.io/blog/2020-09-30-bazel-static-haskell/ has some useful information on this.
16:32:25 <dminuoso> Though they do it with nix, you can do it with musl inside say a docker container too
16:32:58 <justsomeguy> I've heard that one way to do it is by building in an alpine linux container (which uses musl). Haven't tried it yet, though.
16:33:32 <justsomeguy> Tweag does some interesting things with its build system.
16:42:50 <koz_> justsomeguy: I have tried the Alpine container method. It actually works pretty well.
16:56:56 <towel> Haskell wiki is down for me: https://wiki.haskell.org/
16:56:58 <towel> Anyone else?
16:57:17 <yushyin> for me too
16:57:18 <monochrom> Yeah 503 backend unavailable
16:57:36 <Boarders> does anyone know how to benchmark something that consumes stdin (with getContents). Currently I get: " Data.ByteString.hGetLine: illegal operation (handle is closed)"
16:58:47 <ezzieyguywuf> where can I read up more about how cabal and ghc-pkg (they're related, right?!) figure out dependencies and handle conflicts?
16:59:27 <ezzieyguywuf> i.e. if one package depends on <QuickCheck2.14 and another on >=QuickCheck2.14, I'm interested how they can both peacefully coexist, and even depend on each other
16:59:38 <MarcelineVQ> "<justsomeguy> I really hope that Idris becomes a useable language for practical things in my lifetime. (Maybe it already is?)" give it a try
17:05:06 <monochrom> ezzieyguywuf: I don't have a page to refer you to.  If they never seen each other, they coexist fine.  If you want them to depend on each other, or a 3rd package that depends on them both, that is disallowed.
17:05:51 <ezzieyguywuf> monochrom: ah hah.
17:06:33 <ezzieyguywuf> monochrom: I feel like I saw an instance where a packages main executable depended on a recent version of some dependency, but the test executable depended on an older version
17:06:48 <ezzieyguywuf> is that common/allowed, or did I perhaps just misread something?
17:07:30 <monochrom> Perhaps the author forgot to update.
17:07:49 <ezzieyguywuf> ah, i see.
17:07:56 <monochrom> But I guess my granularity was too coarse.
17:08:43 <monochrom> An exe component can be independent of a test component. They are built separately anyway.
17:29:28 <aev_software> Hey folks: anyone familiar with running haskell compiled on Windows? I'm creating a text-adventure dungeon game. It requires an i/o loop. After each putStrLn I have it print a 2nd newline. But sometimes it duplicates the last couple of letters.
17:30:09 <aev_software> Is there anything I can do to fix that?
17:31:05 <xsperry> are you calling putStrLn from multiple threads?
17:31:28 <aev_software> xsperry: not on purpose. I have programmed no threads.
17:32:48 <Seiryn> Hmm, I don't know how it's implemented, but maybe because Windows use CRLF instead of LF ?
17:33:38 <aev_software> Seiryn: yes, that's a good possibility. Does haskell have a cross-platform newline?
17:33:48 <xsperry> I've used haskell on windows and I never experienced that before. CRLF vs LF shouldn't be causing it
17:34:38 <aev_software> For context: I'm in a command prompt with codepage 65001 for unicode.
17:35:24 <ezzieyguywuf> aev_software: I've ran into issues with printing to the cli (on linux mind you) in a weird order. something about having to call hflush
17:35:35 <jollygood2> aev_software do you have a tests case?
17:35:36 <Seiryn> Sometimes CRLF vs LF mess around, depending of your configuration
17:35:47 <jollygood2> test case*
17:40:23 <aev_software> hflush to flush the output buffer? I could do that. I'll also look for a cross-platform newline. Otherwise I might have to program an OS-dependent function, and I'm not looking forwardto that.
17:41:09 <aev_software> jollygood2: Not really. You can download my program and run it yourself to duplicate the problem, I guess.
17:41:40 <aev_software> I have it up on SourceHut: https://sr.ht/~aev/maskies
17:41:50 <fuzzypixelz> if only there were a python-to-haskell translator
17:42:24 <jollygood2> iirc \n is converted to system dependent sequence of characters on streams opened in text mode
17:44:10 <aev_software> jollygood: there is at least 1 person on StackOverflow who says that, too. Looking for a reference.
17:44:14 <exarkun> fuzzypixelz: I'm working on it
17:46:02 <aev_software> Yes: Newline conversion is documented. https://downloads.haskell.org/~ghc/8.8.1/docs/html/libraries/base-4.13.0.0/System-IO.html#g:25
17:50:01 <guest1216> why spaces consume newline in parser?
17:50:15 <aev_software> The base recognizes the Windows OS by looking at whether or not the constant mingw32_HOST_OS got defined? I hope it can have varying values?
17:50:28 <guest1216> parse (spaces >> anyChar) "" "\na" == Right 'a'
17:54:21 <xsperry> spaces is short for white-spaces
17:54:51 <guest1216> xsperry: newline is white-spaces?
17:55:02 <xsperry> yes
17:55:20 <jle`> > isSpace '\n'
17:55:23 <lambdabot>  True
17:55:30 <guest1216> wt...
17:55:34 <jle`> > filter isSpace [minBound..]
17:55:36 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
17:56:00 <guest1216> why people think newline is space...
17:56:13 <exarkun> It has been considered space basically forever
17:56:49 <jle`> it's considered a space in the Unicode standard
17:56:56 <guest1216> exceput ' ' and newline are white-sapces, any others?
17:57:07 <exarkun> lambdabot just gave you a partial list above
17:57:07 <jle`> i was listening them above
17:57:09 <guest1216> > isSpace '\r'
17:57:11 <lambdabot>  True
17:57:13 <jle`> *listing
17:57:26 <exarkun> There are quite a lot of them in unicode.
17:57:33 <jle`> > filter isSpace [minBound..]  -- gives the list of all char's considered spaces according to haskell's impl of the unicode standard
17:57:36 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
17:57:40 <guest1216> ok
17:57:42 <jle`> > length (filter isSpace [minBound..])
17:57:44 <lambdabot>  22
17:57:46 <aev_software> Nope, it's mingw32_HOST_OS no matter the Windows edition. There's other constants that hint at the architecture.
17:57:49 <jle`> just 22 apparently
17:57:59 <exarkun> You'd think 21 would be enough for anyone
17:58:00 <guest1216> isSpace '\22'
17:58:08 <guest1216> > isSpace '\22'
17:58:11 <lambdabot>  False
17:58:13 <jle`> i meant, there are 22 characters that are considered spaces
17:58:25 <guest1216> > isSpaces '\8196'
17:58:25 <jollygood2> aev_software, can you try reproducing your issue with no more than dozen or two lines of code?
17:58:27 <lambdabot>  error:
17:58:27 <lambdabot>      • Variable not in scope: isSpaces :: Char -> t
17:58:27 <lambdabot>      • Perhaps you meant ‘isSpace’ (imported from Data.Char)
17:58:48 <guest1216> ok
18:00:38 <aev_software> jollygood2: yes, I could. It'll take a bit of time.
18:01:25 <guest1216> I think I should use ' ' to match empty spaces, spaces is too many
18:11:01 <fuzzypixelz> exarkun: reall? can I take a look?
18:13:17 <dsal> Guest62909: space comes in both horizontal and vertical varieties.
18:13:24 <dsal> wrong guest.
18:14:05 <aev_software> Huh. I'm using the wrong version of my own executable, aren't I?
18:14:28 <dsal> I do that sometimes.  Takes forever to fix bugs.
18:29:48 <aev_software> xsperry: I'm compiling it multi-threaded. I'll omit that and see what happens.
18:30:22 <prion> i just discovered Data.Set.mapMonotonic and i can't figure out where it would be useful
18:32:38 <MarcelineVQ> it's big-O complexity is lower than non-monotonic
18:33:17 <MarcelineVQ> iow it's potentially faster to use than regular map for Set but requires you to be careful about its use
18:35:03 <MarcelineVQ> have never used it myself fwiw
18:52:59 <aev_software> Hmm... my program also duplicates the last bytes of output when not compiled with threading.
18:53:21 <aev_software> But not all the time.
18:58:43 <ezzieyguywuf> is there a way to tell `cabal test` to skip one particular test suite?
19:12:14 <monochrom> I think no.
19:16:01 <ezzieyguywuf> monochrom: yea doesn't seem like
19:16:07 <ezzieyguywuf> I looked through the cabal documentation
19:16:22 <ezzieyguywuf> seems like it'd be handy
19:16:40 <ezzieyguywuf> the best alternative I could think of is explicitly listing each test to run, but this seems error prone
19:17:11 <dsal> Just always run all the tests.
19:17:21 <dsal> Though I do limit it to just one when I'm trying to be fast.
19:28:30 <ezzieyguywuf> dsal: I'm working on packaging some haskell stuff in gentoo. sometimes, for example, a test requires access to the network which our build system doesn't allow
19:28:38 <ezzieyguywuf> these tests make sense during development but not during packaging
19:29:34 <dsal> Yeah, that's kind of a bad test.
19:30:34 <dsal> Well, I was going to say I did something more clever in my mqttd, but apparently I'm just using a free port on localhost.  I *can* do better.
19:49:08 * ezzieyguywuf nods
19:49:29 <ezzieyguywuf> hoogle was the one I was dealing with yesterday, needing network access
19:49:56 <ezzieyguywuf> even Cabal has a hackage-tests suite, which while it doesn't require network (I think? didn't get that far...) it assumes that ~/.cabal/config exists
19:58:42 <guest1218> parse (sepBy (many (noneOf "\n")) newline) "" "server = abc.net\nport = 6667\n" == Right ["server = abc.net", "port = 6667", ""]
19:58:49 <guest1218> how to remove the last ""?
19:59:13 <guest1218> why sepBy would do this? 
20:00:00 <jle`> try using some instead of many
20:00:09 <jle`> since "" matches `many (noneOf "\n")`
20:00:44 <jle`> many = 0 or more
20:00:49 <jle`> so it's like * in regexps
20:03:11 <guest1218> jle`: how
20:03:35 <jle`> instead of `many`, use `some`
20:03:39 <jle`> many is 0 or more
20:03:41 <jle`> some is 1 or more
20:04:05 <guest1218> jle`: some == many1?
20:09:11 <jle`> yeah, many1 should work too :)
20:09:17 <guest1218> jle`: I use Control.Applicative.some, that would be unexpected end of input
20:12:38 <guest1218> jle`: some and many1 would be error
20:18:22 <guest1218> jle`: I change sepBy to endBy, it works
20:18:42 <guest1218> this is same problem with splitOn
20:19:05 <guest1218> > splitOn "\n" "a\nb\n"
20:19:08 <lambdabot>  ["a","b",""]
20:19:35 <guest1218> sepBy and splitOn have the same issue
20:56:56 <glguy> guest1218, you just don't use splitOn or sepBy for line *terminators*
20:57:09 <glguy> guest1218, for parser combinators you'd use endBy instead
20:57:19 <glguy> > lines "a\nb\n"
20:57:21 <lambdabot>  ["a","b"]
21:27:03 <pavonia> When you Data.Binary.encode (1 :: Double), the result has a length of 25 bytes. Shouldn't that be 8 bytes at most?
21:44:34 <guest1218> glguy: ok
22:48:21 <glguy> pavonia: it works via encodeFloat
22:49:10 <glguy> Binary is for when you don't care how your data is encoded
22:53:59 <glguy> > encodeFloat pi
22:54:01 <lambdabot>  error:
22:54:01 <lambdabot>      • Could not deduce (Floating Integer) arising from a use of ‘pi’
22:54:02 <lambdabot>        from the context: RealFloat a
22:54:23 <glguy> > decodeFloat pi
22:54:26 <lambdabot>  (7074237752028440,-51)
22:55:13 <pavonia> > decodeFloat 0
22:55:15 <lambdabot>  (0,0)
22:55:22 <pavonia> > decodeFloat 1
22:55:25 <lambdabot>  (4503599627370496,-52)
22:55:30 <pavonia> O.o
22:56:11 <pavonia> So the Integer is what bloats the encode result apparently
23:01:18 <glguy> cereal uses the ieee format by default
23:01:33 <glguy> There's another package for that for binary
23:01:58 <glguy> I think cborg does it compactly by default
