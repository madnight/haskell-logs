02:59:30 <mastarija> Is there any vim plugin for haskell that only uses GHCi for error checking, completion, type and docs? Something like this VSCode extension: https://marketplace.visualstudio.com/items?itemName=dramforever.vscode-ghc-simple
03:31:15 <jollygood2> hi. is there already a function like this? https://pastebin.com/Hw0M7rEc
03:32:25 <jollygood2> also, I'm not sure how to, without making a complete mess of the function, pick first element in the original list if count of elements is the same, instead of always picking the one that is first after sorting
03:39:09 <jollygood2> compilable example: https://pastebin.com/6nTUuHAh
03:53:53 * hackage uniqueness-periods-vector-stats 0.2.0.0 - A very basic descriptive statistics.  https://hackage.haskell.org/package/uniqueness-periods-vector-stats-0.2.0.0 (OleksandrZhabenko)
04:04:53 * hackage uniqueness-periods-vector-stats 0.2.1.0 - A very basic descriptive statistics.  https://hackage.haskell.org/package/uniqueness-periods-vector-stats-0.2.1.0 (OleksandrZhabenko)
04:06:07 <xerox_> mastarija: https://github.com/neoclide/coc.nvim
04:06:25 <xerox_> together with https://github.com/haskell/haskell-language-server
04:06:53 <mastarija> Yes, but I don't want language server, I want something that works with just my stock GHCi
04:07:12 <mastarija> Like that vscode extension :D
04:07:20 <xerox_> I use this but it doesn't integrate with vim https://github.com/ndmitchell/ghcid
04:07:30 <xerox_> well, maybe it can, but in my setup it doesn't (:
04:07:31 <mastarija> yes, me too
04:07:45 <mastarija> Right now I just have it in separate terminal window
04:09:04 <xerox_> I use tmux and split the terminal in three, vim, ghcid, repl
04:15:27 <merijn> mastarija: Which VS Code extension? afaik *everything* in VS Code use language server
04:15:40 <merijn> mastarija: Considering VS Code is the project that invented LSP
04:15:50 <xerox_> linked up there called vscode-ghc-simple
04:15:59 <mastarija>  https://marketplace.visualstudio.com/items?itemName=dramforever.vscode-ghc-simple
04:16:35 <merijn> xerox_: ghcide (not ghcid) works pretty will vim's LSP plugins like ALE
04:17:08 <xerox_> I'm happy with ghcid really
04:17:26 <merijn> ghcid is ok, but it's slow as hell
04:17:32 <merijn> Since it just runs "cabal build"
04:17:33 <xerox_> maybe would like it to restart if I change the cabal file, but that's it
04:17:47 <xerox_> I don't work on very big programs anyway :)
04:18:10 <merijn> That's fine if your full build is fast, but for my bigger code bases even rebuilding half can sometimes take a few minutes. ghcide is much more responsive there
04:18:14 <mastarija> xerox_, me too. I usually setup a makefile which tells ghcid to restart on certain file changes.
04:18:27 <xerox_> mastarija: that's not a make feature tho is it?
04:18:34 <mastarija> xerox_, nope
04:18:52 <mastarija> xerox_, I just create a command which basically calls ghcid with some flags
04:18:54 <xerox_> I guess there are a bunch of inotify/whatever tools one can use for that
04:19:19 <mastarija> sure, but ghcid is capable of that anyway
04:19:29 <xerox_> it is?!
04:19:47 <mastarija> yes, it has basic file watching capabilities
04:20:00 <xerox_> aah I thought I missed the addition of restart-when-cabal-changes
04:20:22 <mastarija> we are talking about the cabal file, no?
04:20:25 <xerox_> yes
04:20:44 <mastarija> yes, you can tell him to watch for changes in .cabal and then restart
04:21:17 <merijn> xerox_: Eh, the filewatching stuff in ghcid has been around for a few years :p
04:21:37 <xerox_> I had no idea! --restart=foo.cabal
04:21:43 <xerox_> I'm set for another decade then
04:21:50 <mastarija> hehe
04:22:00 <xerox_> thank you ^_^
04:22:09 <mastarija> you can add multiple files of course, I think it's comma separated
05:03:10 <cads> hey all, having some problems with ghcup - anything I could do to get these gears unstuck? https://gist.github.com/maxsu/8870e338c6b8f48ec8740776acd3ee1f
05:03:38 * cads considers sticking their hand in there
05:20:43 <cads> I feel like ghcup should do these things:   1. install ghc and cabal to ~/.ghcup    2. put ~/.ghcup on the path  3. Configure cabal to install to the .ghcup directory.  4. Fade away into the background
05:21:36 <merijn> I feel like it definitely shouldn't do 2 >.>
05:21:42 <merijn> Not convinced about 3 either, tbh
05:21:50 <cads> #3 & 4 beg the question of whether it should be the .ghcup folder, and how much of this does cabal already do
05:23:33 <cads> merijn, I'm comparing with go and rust. Its curl-installers create .go and .cargo directories in the home directories, and puts the bin directories on the path
05:23:59 <merijn> Tools should never change the user's environment without explicit instruction. If other tools do that, those tools are wrong
05:24:23 <merijn> For one, there's literally no way for tools to robustly change your path
05:25:56 <merijn> I'm sure there's plenty of *bad* tools that do stuff like "edit the user's profile", which is 1) bad, 2) depends on you reliably identifying what the user's profile is, 3) still isn't sure to work and may in fact mess up the user's profile/environmeent
05:26:20 <cads> I wouldn't imply it should do so without user approval - what I've seen is that some installers will offer to modify .bashrc (works in 99% of cases)
05:27:52 <merijn> afaik ghcup already tells you what to do to setup your path
05:31:17 <cads> hmm, I have been downloading manually and putting it where I wanted it to be
05:32:35 <cads> hmm, for that matter, it looks like curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh      is not working at the moment
05:36:19 <cads> not really similar to my earlier error, but maybe the ghcup server is acting up
05:39:24 <geekosaur> you might pop over to #haskell-infrastructure and ask about it
05:39:24 * hackage phonetic-languages-plus 0.1.1.0 - Some common shared between different packages functions.  https://hackage.haskell.org/package/phonetic-languages-plus-0.1.1.0 (OleksandrZhabenko)
05:39:53 <geekosaur> sadly neither status.haskell.org nor webmon currently monitors the ghcup service
05:43:33 <merijn> Doesn't it just grab stuff from gitlab?
05:44:04 <cads> prolly
05:44:19 <geekosaur> gitlab shows as up. but I think the metadata's separate from gitlab. the taralls come from gitab but nothing else I suspect
05:44:53 <geekosaur> and the metadtaa's what's failing. (well, that and reportedly the curl|sh ick)
05:45:03 <dminuoso> geekosaur: gitlab showing as up is arguably just a blatant lie.
05:45:15 <dminuoso> gitlab can easily show as up on any given metric and be completely broken 
05:45:28 <geekosaur> there is that
05:46:01 <cads> is there some other script that I can run in a generic unix environment with a hope and a prayer that I'll end up with working ghc and cabal on my path?
05:46:36 <dminuoso> tar
05:46:38 <dminuoso> :)
05:47:08 <dminuoso> We have bindists you can just untar and install.
05:47:28 <cads> for ghc, which one should I use?
05:48:02 <dminuoso> Which system are you on?
05:48:29 <dminuoso> At any rate
05:48:31 <dminuoso> https://www.haskell.org/ghc/download_ghc_8_10_2.html#binaries
05:48:33 <cads> at https://www.haskell.org/ghc/download_ghc_8_10_2.html#linux_x86_64 we have bin dists for 12 linux distributions (if we include windows)
05:48:41 <cads> but no generic package
05:49:23 <dminuoso> Well ghcup is that generic thing.
05:49:43 <dminuoso> It genreally works, what error are you getting?
05:51:53 <merijn> cads: What does "generic package" mean?
05:52:12 <merijn> cads: GHC depends on several libraries, those distro names just indicate which library versions they use
05:52:18 <merijn> (and thus are compatible with)
05:52:43 <merijn> It's impossible to make a "generic" bindist, because there is no universally installed version of things like libffi and libgmp
05:53:05 <dminuoso> Well, there sort of is if you just have a tarballed nix closure...
05:53:15 <dminuoso> Just needs a linux kernel :>
05:53:29 <merijn> dminuoso: Even then you depend on glibc, unless you're using musl in your nix closure
05:53:47 <dminuoso> merijn: Not an external glibc.
05:53:52 <nshepperd2> just include your own glibc :)
05:53:54 <dminuoso> glibc would be included in the nix closure
05:53:55 <cads> merijn, if someone was offering to pay you, and the goal was to cover 95% of business relevant use cases, I think the word impossible would leave the conversation
05:54:07 <cads> but I'm not gonna offer to pay you
05:54:14 <merijn> cads: Right, which is why it doesn't exist
05:54:19 <dminuoso> merijn: its sort of the point for nix closures to have anything they need
05:54:26 <dminuoso> aside from the linux kernel
05:54:58 <merijn> cads: Actually, even then it is
05:55:17 <merijn> cads: Because it depends on the exact requirements people have of a "generic" version
05:55:46 <srk> can you statically link ghc?
05:55:50 <merijn> Sure, you can do what dminuoso says and ship a Nix closure or something, but most people expect their compiler to work with *their* C compiler and to be able to use the C libraries *they* install
05:56:12 <merijn> srk: Statically linking GHC isn't the problem
05:56:26 <merijn> srk: The problem is that the RTS system depends on GMP and glibc (on linux, anyway)
05:56:44 <srk> hmm, I see
05:56:46 <merijn> srk: So if you're gonna ship your own glibc (as dminuoso mentioned) then the RTS will be linked against that
05:57:22 <merijn> srk: So now you build your own libraries locally with your own C compiler and you gotta just cross your fingers the glibc *they* use is compatible with the glibc the RTS uses, else GHC will just generate broken executables
05:57:22 <srk> looks like it is a thing .. https://github.com/redneb/ghc-alt-libc/releases 
05:57:35 <srk> makes sense
05:58:01 <merijn> srk: Sure, but that means you gotta build all your *other* stuff also with musl. Which is not what the average user/developer expects/wants to deal with
05:58:26 <srk> yup :)
05:59:12 <merijn> and certainly not what people would expect of a "generic release"
06:02:22 <dminuoso> And if its supposed to produce static builds, that will cause other issues
06:02:28 <cads> node js has an installer, and no longer recommends users to use their distribution packages
06:02:52 <merijn> JS packages also can't link against native code
06:03:03 <dminuoso> merijn: thats not entirely true
06:03:05 <cads> not an excuse
06:03:08 <merijn> Which basically eliminates all these problems by simply not letting you do that
06:03:10 <cads> python.. just checked.. is so ubiquitous that it doesn't even have installation packages for linux
06:03:28 <merijn> Like, what exactly, is this discussion trying to accomplish?
06:04:15 <cads> get you to admit that ghc install is needlessly hard and brainstorm ways to improve it?
06:04:23 <dminuoso> Its not a GHC problem.
06:04:39 <merijn> "Languages with several million, possibly billions, of dollars of manpower invested in them by multinational and thousands of volunteers have managed to solve some problems by throwing endless manpower at manually fixing all the corner cases"
06:04:44 <merijn> ok, sure, that's true
06:04:46 <dminuoso> Haskell produces native binaries, that's for *your* convenience
06:04:48 <merijn> But that's not very helpful
06:05:00 <merijn> cads: You can't install a generic GCC either
06:05:00 <dminuoso> But because it produces native binaries, that means we need a compiler, a linker, and libraries
06:06:06 <dminuoso> Well actually we dont even need a compiler if the -fasm backend is chosen, which is evne by default
06:06:08 <cads> merijn, if we're admitting that the difference in outcomes is due to the huge difference in installed base and sheer economic dependency on the systems, I'll admit that makes me feel less frustrated and confused
06:06:11 <dminuoso> but a linker we're not gonna build.
06:06:14 <merijn> cads: Solving this packaging problem in GHC is easy. Just eliminate the dependency on libc and libgmp in the RTS
06:07:03 <merijn> cads: So "all" you need to do is implement all libc functionality in the RTS by implementing it directly using syscalls on all supported platforms
06:07:36 <merijn> cads: Which, btw, is exactly how Go handles this. They use syscalls directly, which means they had to reimplement everything in the RTS for each OS
06:07:47 <geekosaur> we only need a compiler for FFI stubs. -fllvm needs LLVM utils. -fvia-C vanished a decade ago
06:07:49 <merijn> cads: Can that be done? Sure, just look at go.
06:07:52 <cads> I was gonna ask how rust and go do it
06:08:22 <merijn> cads: But we're talking hundreds, if not thousands, of man hours to do so and at the end the only benefit is "improved installation process by 0.5%" (if that much)
06:08:26 <cads> merijn, you saying we could take what go/rust do and port it over to get a similar experience? because I've installed rust and go about 2 dozen times and each time it was smooth as butter
06:08:44 <dminuoso> cads: Have you even figured out what your problem is?
06:08:50 <dminuoso> In my experience ghcup works like butter too
06:09:00 <cads> but I've /tried/ to install ghc perhaps a dozen times over the last decade and each time I bonk on something dumb
06:09:04 <merijn> cads: Rust and Go were, from the beginning, designed with this in mind, which meant they could gradually invest the engineering
06:09:13 <dminuoso> You know. Apart from "Corporate firewall hijacked the TLS traffic", "Apple is broken again, refusing to install xcode"
06:09:45 <merijn> cads: The point is that the engineering effort required to improve from the status quo is enormous and is much better spend on other things.
06:09:49 <cads> dminuoso, I'm gonna wait a day and hope ghcup works - it looks for all the world like the remote server is hung
06:10:02 <dminuoso> cads: did you get any error message?
06:10:15 <merijn> cads: Also, is there no GHC and cabal package for your distro (unless it's Arch, then definitely don't use those...)
06:10:30 <cads> dminuoso, see here https://gist.github.com/maxsu/8870e338c6b8f48ec8740776acd3ee1f
06:11:20 <__monty__> Hmm, can I prevent IO actions from outputting anything when using criterion's nfIO?
06:11:31 <sm[m]> not to derail this interesting chat but as a practical tip cads: an easy generic way to get Haskell tools on a unix system is to download and run the stack installer (a bash script)
06:11:34 <cads> dminuoso, when I tried to pull the yaml file from a browser I got nothing- I'll try it again. Before this ghcup has 'just worked'
06:11:39 <dminuoso> __monty__: dup2 stdout?
06:12:00 <dminuoso> __monty__: Im not sure whether that'd work right in Haskell tho
06:12:56 <merijn> dminuoso: It does
06:13:02 <merijn> I actually have example code somewhere
06:13:56 <merijn> ah, wait, did I get rid of it?
06:14:09 <cads> merijn, there's a fun situation in alpine:  i) there's an alpine package on the GHC page but it's for alpine 2.10 (2 minor versions old)    ii) alpine's package repo has ghc 8.8.2 (also 2 minor versions old)
06:14:56 <merijn> cads: 8.8 is one minor version old and also "so?"
06:15:09 <dminuoso> cads: Mmm, shouldnt you have to install a ghc first?
06:15:27 <dminuoso> The error is strnage tho
06:15:28 <merijn> Odds of needing the very latest GHC are roughly 0 unless you're trying to use some bleeding edge feature in the newest GHC
06:17:45 <cads> merijn, wait, you think it's safe to run 2 minor versions behind (current is 8.10)? okay, I'll try it! In the past I was used to debian stable ghc being so far behind that most packages wouldn't compile
06:17:56 <merijn> cads: Odd minor versions are development only
06:18:03 <merijn> 8.10 is the first release after 8.8
06:18:10 <cads> ah
06:18:30 <merijn> Also, I frequently run 3-4 releases behind if I get too lazy about updating
06:18:32 <dminuoso> 8.6.5 is still a fine compiler.
06:18:52 <merijn> I only updated from 8.6 to 8.10 because I needed a new feature in 8.10
06:19:36 <dminuoso> Only reason I update GHC is because.. well I use the nixos "stable" GHC, so whenver that gets updated I get it too...
06:19:42 <merijn> cads: It's a compiler, not a network facing service. Unless you're actively hitting some bug or needing a new feature there's no real reason too avoid older versions (well, at some point they become so old it's impractical because libraries don't support them)
06:20:07 <dminuoso> From experience, things rarely go noticeably faster in newer releases. :>
06:20:17 <merijn> But honestly anything >8.0 will probably be sufficiently supported
06:20:56 <dminuoso> cads: But yeah, Ive looked at the code path and its a real wart that it doesn't report what exception is being thrown
06:21:14 <cads> merijn, the issue I always found was that ordinary packages would use some ghc feature that would break debian stable's GHC, and I'd have to go off on a tangent buolding new ghc
06:21:40 <cads> ghcup for me means an end in sight to this
06:21:45 <cads> for instance, debian buster is running ghc 8.4.4, which I wouldn't trust
06:22:11 <dminuoso> cads: Can you run `curl  https://www.haskell.org/ghcup/data/ghcup-0.0.4.yaml`?
06:22:20 <cads> dminuoso, no, that fails
06:22:23 <cads> you?
06:22:24 <dminuoso> cads: Whats the error?
06:22:30 <dminuoso> cads: works for me
06:22:30 <cads> it just hangs
06:22:39 <dminuoso> cads: Do you have a vpn enabled?
06:22:46 <dminuoso> Or sit behind a company firewall?
06:22:59 <dminuoso> Can you run a traceroute towards the IP behind that domain?
06:23:17 <cads> gimme a line, I'll run it
06:23:35 <srk> apt-get -y install nix
06:23:46 * srk runs
06:23:58 <cads> srk, lol
06:24:26 <dminuoso> cads: Can you reach this website? https://gitlab.haskell.org/haskell/ghcup-hs/-/blob/master/ghcup-0.0.4.yaml
06:25:29 <cads> hmm, strange, I can  curl https://downloads.haskell.org/~ghcup/x86_64-linux-ghcup
06:25:34 <cads> dminuoso, yep
06:26:03 <dminuoso> cads: Can you reach www.haskell.org at all?
06:26:37 <cads> dminuoso, yes, as I just mentioned, I can download the ghcup binary. I can also navigate the main site.
06:26:43 <dminuoso> that's really strange
06:27:40 <cads> I'm thinking of resetting my network stack and rebooting to see if that unsticks it - I really want this to be a problem on my side and not ghcup's side
06:27:47 <dminuoso> I dont think it will
06:27:57 <dminuoso> so its possible this is behind a cdn
06:28:11 <dminuoso> Im not familiar with the setup here
06:28:19 <dminuoso> but its definitely a network bug
06:28:31 <cads> almost certainly I'm hitting some kind of stale cdn, and you're probably hitting a live one
06:28:37 <dminuoso> yeah
06:28:57 <dminuoso> #haskell-infrastructure is the right place like geekosaur suggested earlier
06:29:30 <cads> yeah, I'll mosey on by and raise the issue and see if I can pledge some kind of support to improve the infrastructure here
06:33:24 * hackage ukrainian-phonetics-basic 0.4.0.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.4.0.0 (OleksandrZhabenko)
06:36:31 <tomsmeding> I've made this ( https://ircbrowse.tomsmeding.com/perfstats ) two days ago; it seems clear what the slow pages are :)
06:39:26 <sm[m]> tomsmeding++
06:39:40 <tomsmeding> also first time working with blaze, seems a fine DSL
06:41:03 <cads> dminuoso, and wouldn't you know it, the service started working just as soon as I started drafting my outage report!
06:41:30 <tomsmeding> cads: service optimises for maximum annoyance
06:49:11 <cads> merijn, I lucked out with the fact that the alpine ghc package is very fresh - so I could have installed that rather than wait for ghcup to get working. What ghcup does is it detects alpine linux then downloads hasufell's ghc-8.8.4-x86_64-alpine-linux.tar.xz and haskell.org's cabal-install-3.2.0.0-x86_64-alpine-linux-musl.tar.xz
06:53:53 * hackage ukrainian-phonetics-basic 0.4.1.0 - A library to work with the basic Ukrainian phonetics and syllable segmentation.  https://hackage.haskell.org/package/ukrainian-phonetics-basic-0.4.1.0 (OleksandrZhabenko)
07:24:44 <cads> is there a haskell editor that achieves any level of code folding?
07:25:12 <cads> lol, it is hard to search for code folding in context of haskell because you get a million articles on foldr
07:25:22 <texasmynsted> like the folding in vim?
07:25:28 <texasmynsted> or something else?
07:26:29 <texasmynsted> full disclosure: I do not use the code folding in vim or other editors. I find it annoying 
07:26:42 <cads> I've also seen it referred to as outlining or collapsing or nesting code
07:27:24 <texasmynsted> I think both common editors have it, vim and emacs.
07:27:26 <cads> where you hide the lines inside methods, leaving only declarations - I use it when reading new code
07:27:57 <cads> it looks like the intelli-J plugin has it, and so does emacs haskell mode. but vs code haskell plugins seem to be missing it
07:28:36 <texasmynsted> but vs code can use neovim as its "editor"
07:28:57 <texasmynsted> Much of the power of neovim, inside vs code
07:29:30 <cads> texasmynsted, I'm not sure we're talking about the same thing - in vs code, folding means that blocks of code get decorated with vs-code buttons that let you collapse them
07:29:31 <texasmynsted> Also there is vscodium, if you want to use vs code but turn off the telemetery and other spying 
07:29:43 <texasmynsted> cads, yes
07:29:46 <texasmynsted> same thing
07:30:27 <cads> so the neovim plugin takes the code folding points that neovim computes for a given file, and sends them vscode?
07:30:35 <texasmynsted> I have not tried it for haskell, but I _think_ you can fold away the body of a code block
07:31:02 <cads> lemme try it. Do I have to do anything special to get haskell mode for neovim?
07:31:24 <texasmynsted> cads: No. The neovim plugin makes vscode work like neovim. You can use many of the neovim features and plugins, directly
07:31:43 <texasmynsted> I think that code folding is built-in if I recall correctly.
07:32:03 <texasmynsted> cads, yes.
07:32:18 <jollygood2> is there a function like this already available? https://pastebin.com/Jt2Wfj3N
07:32:22 <texasmynsted> I have a bunch of haskell plugins in neovim
07:34:54 <texasmynsted> cads I would look at this --> https://github.com/twinside/vim-haskellfold
07:35:32 <texasmynsted> Here are screen-shots http://twinside.github.io/vim-haskellFold/
07:36:55 <texasmynsted> maybe somebody that uses folding will help you better
07:36:57 <cads> that's defintiely what I want visually, and I'm understanding that it should, for example, integrate with the vscode code folding shortcut
07:37:30 <texasmynsted> I am actually sorry that I suggested the neovim plugin. 
07:38:15 <texasmynsted> I suggested it because I use it when in vscode. You will likely be better served trying to solve this without that. 
07:38:35 <texasmynsted> likely one or more of the vscode haskell plugins has folding. I have no idea
07:39:15 <cads> my current understanding is that I can  drop vim-hasellfold in the .vim/plugin directory of the neovim plugin. Then vscode will display code folding widgets in hsakell files. Lol, I am also not that gullible, so I actually expect this will be fraught with peril and misery 
07:40:28 <cads> texasmynsted, I have installed 3 of the plugins and reviewed the feature lists of all the plugins, there were none to indicate the term folding. So apart from manually installing all of the plugins and checking to see if I get magic folding widgets...
07:40:47 <texasmynsted> hmm. 
07:41:02 <cads> ... well, probably you're right and the best idea is to find someone who uses folding (or use the intellij lugin in pycharm)
07:45:20 <justinthong> hi there
07:45:57 <sm[m]> cads: I see folding buttons in vs code + haskell extension.. are they not hooked up to standard keybindings ?
07:46:30 <sm[m]> (only when I mouse over the gutter)
07:46:38 <cads> https://plugins.jetbrains.com/plugin/8268-haskell-conceal   ooo this nice. Haskell concealer. With a sheer, matte finish.
07:47:42 <sm[m]> also, is there any sign of haskell-language-server support in jetbrains IDEs yet ?
07:49:54 <cads> I feel like there was a haskell contributor death event in 2016. Like half of  of the haskell projects I encounter were last committed to in 2016 or there abouts. To wit: https://plugins.jetbrains.com/search?search=haskell
07:50:43 <cads> that might be unfair, since one of those is just an announcement (also 4 aren't really about haskell)
07:51:15 <Rembane> Too much oxygen in the Haskell sea killed off the Cambric explosion 
07:56:15 <cads> sm[m], current intelli-J plugin doesn't appear to be  https://github.com/rikvdkleij/intellij-haskell
07:57:52 <cads> the next most popular haskell plugin has half as many downloads (50k). It builds a server abstraction, but it's not the language server protocol / it doesn't seem to pull in haskell language server
07:58:29 <cads> sm[m], if a project were using haskell language server, what is a string that would have to show up?
07:58:42 <cads> (somewhere in the project's code)
08:00:50 <cads> sm[m], I have found the code folding feature in the vscode plugin! thanks for confirming it existed!
08:02:13 <texasmynsted> cads: so how does it work? Does it do what you want?
08:02:34 <texasmynsted> Would be cool to see a couple of screen-shots
08:02:41 <cads> it doesn't fold what I wanted it to fold, but it folds enough that it's helpful
08:03:05 <cads> I was hoping it would fold long import lists, but it folds everything else I wanted it to
08:03:53 * hackage wai-extra 3.1.4 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.1.4 (MichaelSnoyman)
08:04:03 <sm[m]> cads, np. haskell-language-server, hls would be some likely strings but it's too new/too much in flux to find that way. I asked rikvdkleij about his plan re hls but he didn't seem to have any
08:05:20 <texasmynsted> cads maybe that plugin has some way to define manual fold points? So you can fold down your imports, etc. http://vimdoc.sourceforge.net/htmldoc/options.html#'foldmarker'
08:06:55 <cads> texasmynsted, regarding what I wanted to do, basically without naming names, many haskell projects seems to it's okay to have files with  40 to 60 lines of imports and compiler directives, followed by 500 lines of function after function
08:07:51 <texasmynsted> Heh. Sounds like the code I am working on at the moment and completely my fault.
08:08:03 <cads> to work in this kind of file without losing my slippery grasp on sanity, I like to fold anything whose implementation I don't currently care about 
08:08:41 <texasmynsted> One of my files has more than 70 lines of imports
08:09:23 * hackage phonetic-languages-simplified-common 0.4.0.0 - A simplified version of the phonetic-languages-functionality  https://hackage.haskell.org/package/phonetic-languages-simplified-common-0.4.0.0 (OleksandrZhabenko)
08:09:46 <texasmynsted> Was looking yesterday for something to "fix" my imports. I think actually a better fix for now is splitting out to many more modules.
08:09:58 * cads grabs texasmynsted's lapels and insists the madness must end
08:10:20 <cads> a memo must be drafted. A standard drawn. I am convinced that these kinds of imports make code that nobody wants to maintain
08:10:21 <texasmynsted> lol
08:10:50 <texasmynsted> I agree with you
08:11:08 <cads> but in the meantime, I think I could extend the folding code for the haskell plugin
08:11:25 <texasmynsted> I think normally you can manually fold
08:11:39 <texasmynsted> Like make a selection and fold it away.
08:18:08 * tomsmeding . o O ( 'zf' in vim )
08:24:21 <cads> texasmynsted, in sublime text, yes. In vs-code, users been mewling incessantly for this feature for over two and a half years. https://github.com/Microsoft/vscode/issues/18805
08:24:27 <cads> poor babies :(
08:25:01 <cads> I could be their messiah.
08:34:53 * hackage icepeak 0.7.4.0 - A fast JSON document store with push notification support.  https://hackage.haskell.org/package/icepeak-0.7.4.0 (rkrzr)
08:38:02 <sm[m]> cads: I'd like to see UX improvements there too, but do you have a huge monitor or something ? In practice I am usually scrolled elsewhere, focussed on a small section of code and have to jump/search to even see imports
08:42:31 <cads> no, I just expect my files to be about 60 lines, so when I open a file and I see 60 lines of imports, I gotta make that go away or I'll like kill someone
08:43:50 <cads> like I'll grab the knife, and find the first unpaid intern, say "GUAHAHAHAAH" and then slit their throat from ear to ear. And that will be very unfortunate. Because in my oranization I am the unpaid intern (also psychopathic ceo)
08:44:14 <jollygood2> is there a Data.Set and Data.Map equivalent that keeps track of inserting order?
08:44:16 <cads> so I really need to make those imports go away
08:45:23 * hackage phonetic-languages-simplified-properties-lists-double 0.1.0.0 - A generalization of the uniqueness-periods-vector-properties package.  https://hackage.haskell.org/package/phonetic-languages-simplified-properties-lists-double-0.1.0.0 (OleksandrZhabenko)
08:47:57 <sm[m]> that's.. pretty violent
08:49:08 <cads> in my organization, code readability is a life and death matter
08:52:13 <pja> jollygood2: Data.Map.Ordered
08:52:29 <pja> From ordered-containers
08:55:01 <jollygood2> thanks.
08:56:21 <cads> this is one example of the input bloat I mention: https://gist.github.com/maxsu/fc0ada60f478bc89e3b71b8e54cc389d
08:56:51 <cads> this lives at the top of a 1500 line haskell file that does... a lot
08:59:12 <cads> I think the haskellish way to to deal with this is that every file has a similarly long imports list because factoring it away into a custom prelude for your project is not scalable as the project structure evolves
08:59:23 <cads> but is that strictly true?
09:00:43 <srk> lazily true ;)
09:00:53 <cads> hehe
09:01:31 <srk> you don't need to commit to full custom prelude, you can have parts of the program import modules that reexport common things
09:02:05 <cads> any example of a project that does this to good effect in your opinion?
09:02:43 <cads> I feel reluctant to name examples of projects that I feel make this mistake (but oh boy, they're out there)
09:03:13 <srk> not sure tbh
09:08:53 * hackage phonetic-languages-simplified-lists-examples 0.5.0.0 - Simplified and somewhat optimized version of the phonetic-languages-examples.  https://hackage.haskell.org/package/phonetic-languages-simplified-lists-examples-0.5.0.0 (OleksandrZhabenko)
09:32:16 <tomsmeding> cads: ircbrowse does this (e.g. https://github.com/tomsmeding/ircbrowse/blob/master/src/Ircbrowse/View.hs ), but I'm not sure whether I can call it "to good effect"
09:33:23 <tomsmeding> but then, I prefer it when I can manually trace where stuff comes from most of the time (while I like my editor to tell me that, I'd like to not need it), so I'm personally biased against this batched import thing :p
09:35:23 <cads> yeah, I dont like it either tbh, just thinking of how to shorten this list: https://gist.github.com/maxsu/c43447994735e61f5a5b52a49ecd1d56
09:36:01 <tomsmeding> that indentation is messed up though around the CPP macros
09:36:22 <tomsmeding> but I guess my answer would be "don't", but that doesn't help you :p
09:37:07 <tomsmeding> to me, having lots of imports just signifies that it might be helpful to split up the file into distinct bits of functionality, and nothing else; also, with emphasis on "might"
09:37:41 <tomsmeding> custom prelude / batched imports just allow you to act like the problem isn't there :p
09:41:22 <cads> for lines 34-44 I think I would like to be able to import multiple submodules of a parent module, like  from Data import Bifunctor, Char, Either, Functor, List (intercalate, sort)  -- and so on. Multiple invocations would be fine, but we're reducing the number of import declarations by 4 or 5 while arguably maintaining or enhancing readability
09:42:08 <geekosaur> there is no module named Data, though
09:42:23 <geekosaur> it's just namespace.
09:43:26 <geekosaur> (and I think ghc still has an oddity where it sometimes accepts filenames with dots in them in place of slashes? but only for modules within your program, not from external packages)
10:06:19 <monochrom> In fact "submodule" is a wrong model.
10:07:14 <monochrom> The correct model is fancy naming convention that pretends to be hierarchical.
10:11:48 <ezzieyguywuf> dang, so Data.Functior.Alt ((<|>)) is different from Control.Applicative?!
10:12:09 <ezzieyguywuf> nvm, it's a ! I think
10:12:16 <ezzieyguywuf> lol, I get it, "semi"
10:12:47 <monochrom> Where does Data.Functor.Alt come from?
10:13:50 <ezzieyguywuf> monochrom: semigroupoids package
10:14:29 <ezzieyguywuf> I imagine it's something that's some sub-set of an Alternative or w/e, but this type of stuff is mostly over my head
10:15:23 <monochrom> me too
10:18:59 <ezzieyguywuf> i love that with haskell I've never had to worry about a linker error
10:20:01 <tomsmeding> ezzieyguywuf: wait until you use external libraries
10:20:07 <geekosaur> you haven't, at least
10:22:01 <tomsmeding> whois oleks
10:22:07 <tomsmeding> ............. sorry
10:22:53 <sm[m]> ezzieyguywuf: you must be new here :)
10:23:13 <ezzieyguywuf> lol, and now I did something silly and it used up all my ram when I ran it
10:23:25 <tomsmeding> welcome to haskell
10:23:25 <ezzieyguywuf> tomsmeding: I've used some a tad, for like opengl i think
10:24:16 <sm[m]> quite a lot of haskell apps & libs involve some C
10:24:41 <sm[m]> hackage should have a Pure Haskell badge
10:25:08 <ezzieyguywuf> glad I caught it before I ran out of ram, lol
10:25:23 * hackage witch 0.0.0.4 - Convert values from one type into another.  https://hackage.haskell.org/package/witch-0.0.0.4 (fozworth)
10:25:38 <zincy__> Is the only way to get impurity in Haskell to use performUnsafeIO ?
10:25:39 <ezzieyguywuf> at first I was like "ghcid, why aren't you saying anything?" then I was like "shrug, maybe a glitch" <ctrl-c> cabal run jali
10:25:44 <ezzieyguywuf> then like 30 secs later I thought to check ram, lol
10:26:56 <geekosaur> zincy__, that and its relatives
10:27:17 <zincy__> Cheers
10:27:39 <geekosaur> (inlinePerformIO comes to mind: "sharing an address space with a malevolent agent of chaos")
10:27:52 <sm[m]> ezzieyguywuf: on Mac, I keep activity monitor open and a memory usage meter in menubar :/
10:28:13 <ezzieyguywuf> lol, wise
10:29:36 <sm[m]> since with Firefox and Haskell you can easily freeze a 8G laptop
10:30:00 <tomjaguarpaw> Oh man, tell me about it.  I have a 4GB laptop ...
10:30:14 <sm[m]> ouch
10:30:50 <tomjaguarpaw> I quite like "ionice -c idle nice -n 20", and "MEM=$[1000 * 1000]; ulimit -d $MEM; ulimit -m $MEM; ulimit -v $MEM" when I want to be drastic.
10:31:14 * ezzieyguywuf hugs 16 gigs
10:32:06 * sm[m] takes notes
10:33:58 * tomjaguarpaw hugs script for spinning up Linode when he wants to do anything serious
10:34:00 <ezzieyguywuf> and ff doesn't really use that much memory anymore honestly...
10:34:02 <ezzieyguywuf> at least not for me.
10:34:10 * ezzieyguywuf wonders what linode is
10:34:13 * ezzieyguywuf doesn't do anything serious.
10:34:40 <ezzieyguywuf> lol, I had a runaway ghc from vim's coc that I missed
10:34:51 <ezzieyguywuf> I got up to 1.9G swap!
10:34:52 <tomjaguarpaw> Currently using 12% of main memory, but can easily be up to 25%, and I have different FF instances for different purposes, to minimise tracking, risk of malware ...
10:35:12 <ezzieyguywuf> but now mem usage is back at a very reasonable 692M
10:35:24 * hackage group-theory 0.1.0.0 - The theory of groups  https://hackage.haskell.org/package/group-theory-0.1.0.0 (topos)
10:35:30 <ezzieyguywuf> ah, I have two tabs open, both hackage.
10:35:35 <ezzieyguywuf> though I can have as much as 10-20
10:36:19 <ezzieyguywuf> ah, ignore that mem number, ofc I hav the 1.9GB swapped right now I think that's mostly ff
10:40:58 <ezzieyguywuf> does NonEmpty List have a way to specify at least 2 elements?
10:41:12 <ezzieyguywuf> or would I have to wrap it in a datatype that had two non-empty's?
10:41:20 <ezzieyguywuf> or I gues a singleton and a non-empty..
10:41:36 <ezzieyguywuf> nvm, guess I'll just do that
10:42:57 <dminuoso> ezzieyguywuf: You can use OverloadedLists, if you fancy that.
10:43:00 <zyklotomic> dminuoso: this is what I ended up "translating" that python too https://github.com/Jyutt/jieba-hs/blob/32b808fe92860b1eee0451b8bec9fdb67f8f04e5/src/Jieba/Cut.hs#L20
10:43:15 <ezzieyguywuf> dminuoso: I'll take a look.
10:43:21 <zyklotomic> *to, you were right, State was completely unecessary and that was satisfying
10:45:07 <jle`> ezzieyguywuf: there's some package out there that lets you tack one item onto any container
10:45:13 <dminuoso> zyklotomic: The amount of list concatenation looks a little worrying.. 
10:45:32 <jle`> it might be http://hackage.haskell.org/package/nonempty-lift-0.1/docs/NonEmpty.html maybe
10:45:36 <dminuoso> zyklotomic: Also, cutAll is written strangely. You should just zip with [0..] instead
10:45:38 <jle`> in which case you could use NonEmpty (NonEmpty [] a)
10:46:01 <zyklotomic> dminuoso: thank you, i will look into the cutAll, the cutAll was written by 3 months ago me
10:46:05 <jle`> or maybe it's http://hackage.haskell.org/package/nonempty-alternative-0.4.0/docs/Data-NonEmpty.html ...
10:46:20 <dminuoso> zyklotomic: Furthermore, your clauses on matching length are non idiomatic. Just pattern match on the list :)
10:46:41 <dminuoso> zyklotomic: Let me give you a hint
10:46:41 <zyklotomic> huh, wdym by matching length on the list
10:47:28 <dminuoso> zyklotomic: so your entire where clause could just be:
10:48:00 <dminuoso> (b:bs) = span ((==1) . length) rem
10:48:06 <dminuoso> And then you have b for the head, and bs for the tail
10:48:08 <dminuoso> Done!
10:48:11 <zyklotomic> woah
10:48:20 <zyklotomic> i appreciate it, tysm for the pointer
10:48:20 <dminuoso> oh wait
10:48:28 <zyklotomic> ah
10:48:37 <dminuoso> not quite, but you get the idea
10:48:47 <zyklotomic> should I resort to vectors then?
10:48:56 <zyklotomic> if i'm going to be pushing back like that?
10:52:02 <dolio> You mean appending?
10:52:17 <dolio> Vectors will just guarantee the worst performance.
10:52:31 <zyklotomic> yes, appending
10:52:44 <zyklotomic> i've never used vectors, I thought they were going to be like C++ ones
10:52:46 <dminuoso> zyklotomic: If you want to append a lot, look at DList
10:53:00 <zyklotomic> but I think I guessed wrong
10:53:03 <dminuoso> I gotta run, Ill be around next week if you want
10:53:16 <zyklotomic> dminuoso: thank you, appreciate you a lot see you around then
10:54:16 <jle`> C++ vectors would be pretty bad at appends too fwiw
10:54:55 <zyklotomic> i think my understandin is it depends on the backing array, if your backing array is large enough
10:55:03 <zyklotomic> there would be no need to realloc
10:55:41 <jle`> ah yeah, there's some work being done by the abstraction there :o
10:55:46 <jle`> i guess it'd be closer to C arrays then
10:59:15 <zyklotomic> ye, there are C++ arrays too i think, where size is fixed at compile time
11:00:39 <jle`> ah :O then i guess haskell vectors they are somewhere in between?  size can be determined at runtime, they are contiguous-memory, but every append requires a full copy
11:01:06 <jle`> oh, i guess we run into the mutability vs immutability distinction then.
11:01:15 <monochrom> C++ vectors enjoy using a mutable array at the back, so appending is amortized O(1).
11:01:44 <monochrom> but it is still only amortized O(1), not real-time O(1).
11:02:11 <monochrom> How to do that is in every standard 2nd year CS curriculum.
11:02:21 <koz_> jle`: 'contiguous-memory' is a bit of a skunk statement vis-a-vis Haskell vectors, since boxed ones aren't _really_.
11:02:30 <koz_> Storable or Unboxed ones, sure.
11:02:55 <koz_> (Prim too I guess?)
11:04:00 <jle`> i suppose, but it'd be similar in C++ if you had a vector of pointers
11:04:12 <monochrom> Also the way it's done has consequences in heap fragmentation and reserving a lot of space that goes unused for a long time.
11:04:41 <koz_> jle`: Yeah, that is also true.
11:04:52 <zyklotomic> so haskell vectors don't work the way I think they do in short?
11:05:02 <koz_> zyklotomic: How did you think they worked?
11:05:18 <zyklotomic> the c++ way in the background
11:05:26 <koz_> If you mean std::vector, then no.
11:05:27 <zyklotomic> with a contiguous memory and a smart pointer
11:05:29 <dolio> Immutable vectors aren't mutable vectors, no.
11:05:36 <koz_> std::vector is a dynamic array which is mutable.
11:05:38 <jle`> i thiiink your intuition is mostly correct, if you factor in that there is no backing array underneath what you can directly access
11:05:43 <jle`> and yeah, they're immutable
11:06:16 <dolio> Haskell has both, but you can't just drop mutable vectors into an algorithm using immutable lists.
11:06:16 <jle`> but i think the consequences of immutability are mostly intuitive here, like how you can't edit an item in an immutable vector without a full copy
11:06:20 <koz_> Vector is more like a C array, of pointers in the case of boxed ones, or directly otherwise, which is immutable (though mutables exist), and has a fusion framework to hide some of the copying.
11:06:37 <koz_> s/hide/avoid/
11:06:50 <koz_> Key word here is 'some' - there are things where it can't help doing copies.
11:06:54 <zyklotomic> yes, or in the same way the backing array part is abstracted away from you in c++ too
11:07:11 <zyklotomic> that makes sense, my guess was originally that something like
11:07:25 <zyklotomic> append ++ would during run time determine what to do, whether to realloc or just move the "pointer"
11:07:39 <zyklotomic> so that sounds like mutable vector?
11:07:52 <koz_> zyklotomic: Nope. A Haskell mutable vector is more like a mutable C array.
11:08:03 <koz_> So if you want to do appends, you're likely copying and reallocating.
11:08:06 <koz_> A lot, potentially.
11:08:14 <monochrom> yeah fixed size. You write your own code to grow.
11:08:17 <koz_> So if you have an append-heavy workload, I would suggest another data structure.
11:08:25 <koz_> (DList or Seq)
11:09:29 <zyklotomic> that makes sense, thank you
11:09:43 <zyklotomic> do people usually try to rethink how an algorithm should function to work with Lists if possible
11:09:48 <koz_> zyklotomic: No.
11:09:52 <zyklotomic> or is it normal to just reach for these diff data structures
11:10:01 <zyklotomic> the latter?
11:10:02 <koz_> Lists _can_ be useful, but they're absolutely _not_ the data structure I'd reach for in most instances.
11:10:16 <koz_> Basically, think what operations you care about.
11:10:16 <monochrom> I don't always use list. But I always think.
11:10:28 <koz_> Then select the data structure that makes these operations as cheap as possible.
11:10:51 <jle`> i think lists are not really the best 'container data structure' in most cases. their main strength in haskell is in streaming data or control flow
11:11:09 <jle`> so lists in haskell kind of fill a similar role to for loops in imperative languages
11:11:12 <zyklotomic> they all seem obscure and require an external dependcy which is why I usually feel more hesitant about reaching out to another DS
11:11:18 <monochrom> And I always use my CS education.
11:11:20 <koz_> zyklotomic: They aren't obscure at all.
11:11:30 <koz_> containers isn't really an external dependency either.
11:11:37 <koz_> (because it's a boot library I think?)
11:11:48 <jle`> yeah, you should be safe if you stay in the 'boot libraries', or the libraries that GHC itself uses in its source code
11:11:50 <monochrom> Dependency on Hackage is the norm around here.
11:11:53 <koz_> And that gives you Seq, Set, Map, which already gets you surprisingly far.
11:12:01 <zyklotomic> maybe I should get more comfortable with that then
11:12:03 <jle`> at least for starting out
11:12:12 <koz_> zyklotomic: Basically, learn about data structures.
11:12:14 <zyklotomic> it's not like kitchensink languages i guess?
11:12:20 <koz_> Haskell is _reasonably_ well-equipped with them.
11:12:22 <monochrom> No.
11:13:05 <monochrom> Especially if "kitchen sink" means to the millenials IoT, e.g., you expect the kitchen sink to have an http server.
11:13:12 <zyklotomic> koz_: i guess more so haskell data structures?
11:13:21 <koz_> zyklotomic: Data structures are data structures.
11:13:27 <koz_> How you implement them is another story.
11:13:32 <koz_> A HAMT is a HAMT is a HAMT.
11:13:39 <koz_> (to give a favourite example)
11:13:52 <jle`> this is the list i reference https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/libraries/version-history -- the boot libraries are all very tried true, optimized, wlel documented, mostly beginner friendly, etc., since they're an integral part of ghc building itself
11:14:01 <koz_> You can implement a HAMT in Haskell, C++ or Brainfuck. It'll still be a HAMT.
11:14:10 <zyklotomic> koz_: but you can't as easily implement them
11:14:12 <monochrom> Well, immutable data structures are much less taught in standard CS curricula.
11:14:15 <zyklotomic> so its' not as intuitive?
11:14:15 <jle`> well, different data structures are more important in idiomatic (immutable, lazy) haskell than in other languages
11:14:28 <koz_> zyklotomic: Unless you're planning to write data structures yourself? Understanding how they work is enough.
11:14:38 <jle`> i'd say some of them are pretty intuitive, but it's a different sort of intuition than the one you learn in normal CS
11:14:42 <monochrom> Still, "a CS education" does not just mean a ton of rote memorization.
11:14:44 <koz_> Basically a core education in this area is 'what are data structures, what are they good at'.
11:14:45 <zyklotomic> yeah that's what I'm trying to say
11:15:10 <zyklotomic> there is some kind of imperative-ness tied to data structures courses in college
11:15:16 <koz_> zyklotomic: Unfortunately yes.
11:15:28 <koz_> But you can always ask here.
11:15:38 <koz_> We're more than happy to explain the why.
11:15:40 <zyklotomic> yup true :D
11:15:42 <jle`> also most of the data structures you'll normally use here have good documentation with runtime complexities in them
11:16:00 <jle`> so if you're uncertain about vector append, you can just look at the vector docs for (++) and see that it's O(n+m) :)
11:16:21 <jle`> https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html#v:-43--43-
11:16:21 <koz_> AKA 'this isn't something  you want to do often with vectors'.
11:16:24 <monochrom> I have issues with "intuitive", too.  Look, mutable binary search trees are just as unintuitive.
11:16:40 <koz_> monochrom: As someone who actually had to present on red-black trees, this is a mood.
11:16:56 <koz_> Deletions especially, oof.
11:17:20 <monochrom> I know because on the exam I gave students "show the steps of BST insert for this small example tree", and the exam is open book, and the students can still blow it.
11:17:44 <koz_> monochrom: Yeah, even on _non_-self-balancing (self-unbalancing?) BSTs, this stuff's full of tricky corners.
11:18:03 <koz_> I taught this for several years, so definitely hear you on that.
11:18:14 <jle`> not that the answers are always in a book, but reading Okazaki's pure data structures book was a good way for me to gain some intuition about common patterns and things to think about when implementing or using immutable data structures
11:18:36 <koz_> Yeah, Chris Okasaki is like, a hero.
11:18:56 <pjb> zyklotomic: it's true that a lot of data structures are designed for mutation.
11:18:57 <jle`> enough that i can now reason through things like "oh yeah, of course splitAt n for lists is O(n)", without having to look it up
11:19:14 <pjb> zyklotomic: hence their imperative yang.
11:19:32 <koz_> Thing is, in Haskell, we _can_ have mutable data structures if we want.
11:19:35 <koz_> (thanks, ST!)
11:19:47 <koz_> We just rarely bother because surprisingly, it's not necessarily faster.
11:20:07 <pjb> zyklotomic: but you can also approach them in a more functionnal ie. immutable way, notably with the RAII pattenr.
11:21:17 <pjb> zyklotomic: that said, purely functional (immutable) data structures are often less efficient.  But that's because the universe is not functional, it's full of mutable state.  By default, entropy, enthalpy, etcâ€¦
11:21:40 <pjb> This is why I think a purely functional programming language is an error.
11:21:45 <jle`> i mean, they can be more efficient for specific operations :)
11:22:06 <jle`> a lot of times the immutable structure will be a more efficient choice than the mutable one
11:22:31 <monochrom> No, the pursuit of maximum run-time efficency is the error.
11:22:38 <jle`> i guess you said 'often', so you aren't speaking in absolutes. but i think the picture is more even-split than suggested
11:22:50 <monochrom> Programmer inefficiency is more expensive than run-time inefficiency.
11:23:05 <koz_> Also, there is no good, there is only good enough, when it comes to run-time.
11:23:19 <koz_> If your bounds aren't your structure, immutability offers many benefits.
11:23:40 <monochrom> The world has so far recognized "run time" and "compile time". Few have reached the enlightenment of recognizing "programming time".
11:23:56 <koz_> And the difference between immutable and mutable structures serving similar roles can be _really damned thin_.
11:24:05 <MarcelineVQ> I'm on break time
11:25:24 <zyklotomic> what exactly is immutability then?
11:25:33 <zyklotomic> couldn't you have runtime immutability
11:25:33 <monochrom> Mathematics.
11:25:33 <koz_> zyklotomic: The ability to retain any past state.
11:25:53 <zyklotomic> what is "retain"
11:25:55 <koz_> So like, an insert into an immutable structure gives you a new structure.
11:26:00 <monochrom> If you say "define x to be 4" then x stays as 4.
11:26:00 <koz_> Rather than changing an existing one.
11:26:22 <zyklotomic> yes, but that is just a social construct
11:26:30 <monochrom> If x satisfies "x+2 = 6 because x=4" then x+2=6 stays true.
11:26:35 <zyklotomic> I could mutate it and say this is in fact a new data structure
11:26:46 <zyklotomic> the old one is just gone into the void
11:26:47 <monochrom> There is no "change 4 to 5, so now 5+2=6 is true".
11:27:12 <koz_> zyklotomic: Except in the immutable world, I could still use 'structure' after that insert in its pre-insert form.
11:27:19 <monochrom> See also: http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
11:27:22 <koz_> Good luck doing this with a mutable structure without copying it first.
11:27:29 <jle`> one way you could think of immutable data structure is 'persistent', as opposed to 'ephemeral' (immutable). meaning all updates are non-destructuve, and you can always refer to all instance sof it you have ever had
11:27:35 <zyklotomic> koz_: then don't?
11:27:39 <koz_> Also what jle` said.
11:27:46 <koz_> zyklotomic: Yes, you can pretend mutable structures are immutable.
11:27:52 <koz_> However, then it's on _you_ to track this.
11:27:56 <zyklotomic> yeah, that is my question
11:27:57 <koz_> Whereas here, the language does it for you.
11:28:02 <zyklotomic> couldn't you prove it yourself
11:28:06 <jle`> zyklotomic: if i say x = 3, and then let y = x + 4, then x is still 3, right?  how would x ever be anything other than 3?
11:28:07 <zyklotomic> kind of like reference counting in Rust
11:28:12 <koz_> zyklotomic: Sure you could. Don't you have better things to do though?
11:28:19 <koz_> I'd rather _not_ do work my computer can do for me.
11:28:39 <monochrom> See? Programming time is more expensive.
11:28:42 <zyklotomic> in the name of performance i suppose
11:28:42 <jle`> zyklotomic: yeah, if your point is 'immutability is in how you use the structure', than yeah, you could think of persistence as a property of an API
11:28:52 <koz_> zyklotomic: Yeah, but if it doesn't matter?
11:28:56 <koz_> (and it often doesn't)
11:29:01 <monochrom> Programmer performance is more important.
11:29:06 <koz_> There's a reason we don't write everything in x86 asm.
11:29:14 <jle`> the API's property is: "all references will reliably always return the same result whenever accessed"
11:29:15 <koz_> (well, several)
11:29:42 <jle`> so if you reference x once, then reference x again, an 'immutable interface'/'persistent interface' is a contract that both references will always return the same value
11:29:51 <zyklotomic> thats a tougher pill to swallow but i can see your argument
11:29:53 <monochrom> Eventually I'll have to take the extremist stance "if you haven't learned how to prove programs correct, you don't have the license to talk about performance".
11:29:54 <cads> Hmm, so "chunking" the imports lets me reduce the number of "import" words in this document from 46 to 18, trims the imports section by 18 lines (31%), and in my opinion makes the imports section much easier to reason about in mental chunks
11:30:22 <cads>  Before: https://gist.github.com/maxsu/9a622c735045ab95d938b2a3e20f3ad9         after:   https://gist.github.com/maxsu/db9b0182b1d95225965a00b29684fce8
11:30:25 <koz_> monochrom: Arguably you're more than halfway there already.
11:30:48 <monochrom> Because people talk about performance like really high-performance code is so really trivial to understand and even invent.
11:31:25 <zyklotomic> so we shouldn't worry about complexity either?
11:31:33 <koz_> zyklotomic: Complexity in what sense?
11:31:40 <zyklotomic> like using a list ++
11:31:43 <zyklotomic> multiple times
11:31:56 <zyklotomic> if like it makes things easier to write / programmer productivity
11:32:03 <zyklotomic> sometimes these tradeoffs are worth?
11:32:11 <monochrom> worry about complexity under the context of what other priorities?
11:32:18 <koz_> zyklotomic: Yes, they are, sometimes. It depends on a _lot_ of other things.
11:32:36 <monochrom> I certainly don't worry about complexity (or anything, even correctness) out of context.
11:33:02 <monochrom> Tell me all of your priorities and their relative importance. Then we can talk.
11:33:03 <zyklotomic> wdym by context
11:33:23 <koz_> zyklotomic: What are you working on? What kind of requirements are placed on your performance? How soon do you need it? etc etc etc
11:33:29 <zyklotomic> it is not so much a priority but the gut feeling like
11:33:54 <zyklotomic> why write inefficient code when you know how to do it less, but again, that is what the CS curriculum you mention teaches you
11:34:01 <cads> context is hard... it's basically the datatype for the whole world around you, and it is much, much more complicated than anything you can possibly understand
11:34:06 <zyklotomic> s/less/more efficiently
11:34:24 <jle`> zyklotomic: that's a good question to ask: ("why write ..."). and it's a valid question with different answers in different situations
11:34:31 <cads> so you limit it to specific scopes, and ask what's important
11:34:33 <jle`> sometimes there are good reasons depending on your ultimate goal
11:34:36 <monochrom> I have a collection of tuples, (student name, student number).  I have another collection of tuples, (student number, tutorial section).  I want to do the inner join of them.
11:35:37 <monochrom> I chose the stupid quadratic-time algorithm because it's a one-liner in Haskell and I merely have 200 students, what do you mean worry about complexity, I have better things to do such as thinking really hard how to explain type inference to undergrads.
11:36:07 <koz_> monochrom: And I suspect the IO needed to load said data is gonna take longer than the quadratic inner join.
11:36:14 <monochrom> If I ever get a class of 100000 students, maybe I'll consider spending time on an n lg n algorithm.
11:36:17 <koz_> (by like, a lot)
11:36:23 <jle`> complexity analysis is also very limited even if you're thinking about performance...it ignores constant factors important for actual decisions in specific situations
11:36:24 <monochrom> yeah
11:36:27 <monochrom> PRIORITIES
11:36:33 <zyklotomic> yes, but something like that can be very easily done in imperative
11:36:35 <koz_> What jle` says is absolutely true.
11:36:40 <zyklotomic> but I get your point too
11:36:41 <monochrom> What do you mean you don't know what priorities and contexts mean.
11:36:46 <koz_> zyklotomic: What do you mean by 'easily' and 'done'?
11:36:56 <cads> to get from a complexity analysis to an actionable business intelligence takes a very important thing: spreadsheets
11:36:58 <koz_> I can speak from personal experience here - my own Master's thesis is a perfect example.
11:37:18 <monochrom> In imperative I would still use the same stupid quadratic-time algorithm. It's just two for-loops.
11:37:33 <cads> if you are doing a complexity analysis and there's no graphs and spreadsheets of REAL experiments, you're not doing much
11:37:37 <monochrom> And I am not alone.
11:37:37 <koz_> I show that, in theory, my algorithm for dynamic partial sorting has better asymptotics than the naive approach. In practice, the constants are so gigantic that your input would have to exceed the number of atoms in the universe for it to matter any.
11:37:51 <zyklotomic> i think I have the wrong mindset then
11:38:08 <zyklotomic> in school and interviewing, all you ever tihnk about is complexity and not coming up with something stupid
11:38:14 <jle`> zyklotomic: there are reasons to pick the 'lower asymptotic complexity' operation in imperative programming too
11:38:17 <koz_> zyklotomic: You understand context fine.
11:38:21 <jle`> often times it will be the best choice in your situation
11:38:24 <koz_> As well as 'it depends'. :P
11:38:31 <zyklotomic> so you naturally have an aversion, (at least I, I'll speak for myself) to 
11:38:48 <monochrom> I have looked at the code library of world-class programming contest contestants. I am talking about bloody U of Waterloo which wins the world champion of ACM ICPC every once in a while.  The code library they bring on paper to the contests.
11:39:05 <koz_> Is that the one with the brute-force heap code?
11:39:09 <monochrom> You heard that DIjkstra's algorithm uses a priority queue, in theory, right?
11:39:28 <monochrom> Well their code uses a flat array and linear search for every priority queue operations.
11:39:37 <cads> koz_, you really invented one of those algorithms with great asymptotics but ludicrous constants? did you have to go out of your way to do it, or did it get revealed gradually in a hilarious and/or disappointing way?
11:39:45 <koz_> cads: Yep!
11:39:54 <monochrom> Apparently "fast enough" is very much enough.
11:40:03 <koz_> The idea was basically hitting it with a divide-and-conquer hammer.
11:40:16 <koz_> But said divide and conquer hammering meant constant factors everywhere.
11:40:20 <zyklotomic> "stupid" solutions
11:40:39 <koz_> So while it manages the impressive feat of having a time complexity dependendent on log^*(n), it's totally useless.
11:40:47 <jle`> solutions can be bad or good, but what makes them bad or good is more than just their asymptotic complexity...
11:40:55 <koz_> jle`: Fredkin trie anyone? :P
11:41:00 <koz_> (Fibonacci heap too I think)
11:41:33 <cads> imo the dumber I can make a solution and it's still robust and meets the spec, the more favor I give to anyone (including myself) who will have to touch the code later
11:41:45 <koz_> Yeah, readability is a big thing too.
11:42:12 <koz_> I think it was Sussman who famously said 'Code is written primarily for people to read and only incidentally for a machine to execute'?
11:42:34 <zyklotomic> then i honestly think these points aren't really hammered into your usual DSA classes then
11:42:44 <koz_> zyklotomic: You're telling me!
11:42:47 <geekosaur> this is true
11:42:50 <et09> i have xmonad which (iirc) is building via stack
11:42:59 <koz_> I cannot _count_ the number of arguments I had with the folks I was TAing in those classes for.
11:43:01 <et09> https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-GridSelect.html#t:GSConfig curiously this gs_bordercolor can't be found 
11:43:05 <koz_> On exactly this kind of issue.
11:43:11 <zyklotomic> but i definitely am shifting towards agreeing with you all now
11:43:16 <jle`> yeah all i hear about in my DSA classes is overthrowing the bourgeoisie
11:43:18 <et09> i'm trying to find my local definition of GSConfig 
11:43:21 <koz_> jle`: ROFL
11:43:32 <monochrom> You need to understand that most interview questions are not representative of work environments.
11:43:42 <koz_> Very much this.
11:43:52 <zyklotomic> yup, it's just kinda disjarring sometimes
11:43:56 <koz_> Speaking as someone who had a very nice interview for my current Real Haskell Job For Real Money.
11:44:05 <koz_> (I was prepared for the kind of horror shows I've seen and heard about)
11:44:08 <koz_> (luckily did not get one)
11:44:17 <koz_> (_still_ isn't in any way representative of what I am working on now)
11:44:30 <monochrom> You also need to understand that a CS exam question only asks "assuming I force you to optimize for big-O, what is the best you can do". But it doesn't ask under what circumstance you should optimize for that.
11:44:35 <boxscape> % type Void' :: TYPE (SumRep '[]); newtype Void' = Void' Void' -- is this the only way to have a genuinely uninhabited type?
11:44:35 <yahb> boxscape: 
11:45:06 <koz_> boxscape: I think EmptyDataDeclarations (or something like it) lets you do it more directly?
11:45:17 <boxscape> koz_ but then it's a lifted type, so it contains bottom
11:45:18 <jle`> i think they're talking about even prohibiting bottom
11:45:38 <cads> wait, there are comrades in software engineering classes and they want to overthrow the bourgeousie and also they lack practical software engineering knowledge?!
11:45:48 <cads> my comrades! I MUST LEAD!
11:45:58 <koz_> boxscape: I see you don't agree with Sir Mix-A-Lot.
11:46:20 <koz_> (sorry)
11:46:21 <boxscape> koz_ not today
11:46:23 <koz_> :P
11:46:37 <boxscape> % type Void' :: TYPE (SumRep '[]); newtype Void' = Void' (forall a . a) -- actually it looks like this works, too
11:46:37 <yahb> boxscape: 
11:47:05 <zyklotomic> monochrom: i know i tell myself all that, but you're right, i'm only telling myself, but not actually believing it
11:47:22 <monochrom> You need to understand that most interview questions are screening questions to filter out the dumbest 99% of the candidates so the interview can save time.
11:48:04 <cads> monochrom, also I want to see who has the guts to implement monadic fizzbuzz in a way that fully respects DRY
11:48:10 <monochrom> So for example first they ask "write code for fizzbuzz". That immediate filters out the bottom 80%.  But this does not mean you write fizzbuzz in production code. Duh.
11:48:17 <koz_> It's also worth mentioning that most interviews are incredibly bad at what they claim to be doing.
11:48:42 <monochrom> Then the 2nd question is "write code for BST insert" and that filters out another 19%.
11:49:12 <monochrom> And if you're applying for Microsoft, I heard that the 3rd question would be "write an editor from scratch" and that will filter out the remaining 1%.
11:49:24 <zyklotomic> lol
11:49:29 <monochrom> Does this mean at Microsoft people write editors by hand all the time?
11:49:30 <hyiltiz> LMFAO
11:49:48 <monochrom> Does that mean they even care?
11:50:01 <monochrom> No, it's just a test.
11:50:09 * cads would be filtered at phase II, because they think BST stands for "bull shit tree", as in "what is this bullshit tree insert you think I'm gonna write for you?"
11:51:28 <zyklotomic> true
11:51:36 <cads> for writing the editor i would start by forking the vs-code source code, which would actually impress the microsofties
11:51:57 <zyklotomic> the harder part to accept which I have slowly started to as a result of this convo though is that sometimes it's not worth the time to over-complify
11:52:04 <zyklotomic> if I understood the message correctly
11:52:19 <zyklotomic> *in pursuit of performance
11:52:54 <zyklotomic> I know "pre-mature optimization is the root of all evil" and all, but maybe this extends to optimization at the cost of clarity / programming efficiency
11:54:06 <monochrom> OOOHHHH I now understand why Microsoft is happy with releasing vs-code source code for free.
11:54:16 <monochrom> They simply stole it from interviewees.
11:54:16 <cads> you could try to think in terms of how much you're gonna pay someone for a given line of code. If it's some very optimized code, you'll pay a lot - if that's you maintaining it you'll pay from your own limited time here on this earth. it better be worth it, and unless something is paying you to make the improvement, you're literally marching towards death for no reason, wasting time
11:54:49 <monochrom> Well, maybe it's a fair exchange, they pay for interviewee airplane tickets and food and hotel room.
11:55:08 <zyklotomic> well none of that this year lol
11:55:11 <monochrom> But at least, not quite employee salary.
11:55:29 <zyklotomic> but yeah cads thats kinda depressingly real but....
11:55:41 <zyklotomic> cads: i'll start thinking about that more often
11:55:55 <hyiltiz> cads imma remember that quote for life...
11:56:02 <zyklotomic> typing into an irc channel on haskell, perfect use of time though!
11:57:29 <cads> lol, only listen to my words on their own merit, for I am a huge hypocrite. I spent 3 hours yesterday rewriting a mouse gesture filtering algorithm because "the math wasn't elegant enough" in the original implementation
11:58:27 <zyklotomic> i guess unless you genuinely enjoyed the process
11:58:47 <zyklotomic> time wasnt wasted if you enjoyed it
11:59:29 <cads> I mean, yes, I turned 40 lines of hell code into 12 lines that (in my opinion) read like poetry.. but did I /really/ enjoy the process... for example, my hand was going numb because I'm suffering from bad carpal tunnel rn. I could not feel my right hand. Should I /really/ have done that to myself?
12:00:17 <cads> lol, who am I kidding, that is what makes my life worth living
12:03:07 <monochrom> Awww. Yeah, hurting your hand might not be worth it.
12:03:35 <monochrom> If not for that, the learning experience is very valuable.
12:04:04 <zyklotomic> that sounds interesting though, how does it work
12:04:08 <boxscape> % type Product :: forall r q (a :: TYPE r) (b :: TYPE q) . a -> b -> *; type Product a b = Product a b
12:04:09 <yahb> boxscape: ; <interactive>:23:58: error:; * Expected a type, but `a' has kind `TYPE r'; * In a standalone kind signature for `Product': forall r q (a :: TYPE r) (b :: TYPE q). a -> b -> *; <interactive>:23:63: error:; * Expected a type, but `b' has kind `TYPE q'; * In a standalone kind signature for `Product': forall r q (a :: TYPE r) (b :: TYPE q). a -> b -> *
12:04:20 <boxscape> why does that not work? It seems like (->) is levity polymorphic
12:04:22 <boxscape> judging by :k
12:12:49 <hyiltiz> How would you fellas deal with teams? I often find myself find pointing out a problem, then leading a discussion about alternative solutions and who does what, then keep reminding people to do their part, and then explicitly stated the application algorithm in more detail or even in psidocode, and even that didn't get them to implement the damn thing just go do it myself... If I'd just had done it myself, i'd probably have done it five times over 
12:12:50 <hyiltiz> in that time frame...
12:13:41 <hyiltiz> Find it very hard to motivate or appreciate a team member when they are passive like a dead meat
12:13:44 <koz_> hyiltiz: It depends heavily on who you work with. Having to prod colleagues is a thing I've experienced as both 'extremely necessary' and 'extremely unnecessary' (and everything in-between) depending on the folks involved.
12:14:01 <koz_> So I'd say 'repeated prodding' may be exactly the right idea.
12:14:27 <koz_> For the passive case, definitely prod.
12:14:37 <koz_> Since passive folks in my experience _like_ being directed.
12:14:43 <hyiltiz> I think dear meat can only be motivated via punishment (I'm take away your salary or something)
12:14:44 <koz_> (or at least that's what I've witnessed)
12:15:18 <koz_> hyiltiz: I don't think I've ever worked with anyone who needed that kind of motivation.
12:15:20 <koz_> Maybe I am lucky.
12:15:21 <Rembane> Create a prod-bot! 
12:15:38 <koz_> Rembane: Basically write 90% of current phone apps.
12:15:39 <cads> I don't understand having a subordinate without also having the power to discipline or, if I decide, fire the subordinate
12:15:43 <koz_> They're basically prod-bots with UIs.
12:15:44 <hyiltiz> But I'd much rather ring inspiration and genuine motivation in them so they actively contribute
12:16:14 <cads> like I get it happens, and I get it happens a lot, and that it's frustrating when it happens. but WHY would anyone accept a subordinate they cannot fire is beyond me
12:16:29 <Rembane> koz_: :D
12:16:43 <Rembane> hyiltiz: You need a sword 
12:16:47 <hyiltiz> cads situation demands...
12:17:57 <hyiltiz> Massive sword that programs on each swing?
12:18:04 <hyiltiz> magic
12:19:07 <Rembane> The best kind of hacker sword 
12:19:28 <koz_> Rembane: Swording-as-a-service?
12:19:31 <koz_> Internet-of-blades?
12:19:35 <monochrom> "hack away with your sword" literally
12:19:41 <koz_> Smartblade?
12:19:56 <hyiltiz> I'd totally sub to saas
12:20:42 * koz_ renames Game of Thrones to 'Hackers'. :P
12:21:45 <hyiltiz> So no good solution without a sharp sword? 
12:22:53 <cads> hyiltiz, if the situation demands, I like to make counter demands, and be willing to massively screw things up for the team that won't help me (ie, by walking to a competing team that will give me better resources). Usually just being ready and willing is enough to turn the negotiation and give me what I want. In this case you could leverage to get the meat fired. But probably you just want an understanding between you and the meat, and the 
12:22:53 <cads> boss can give you that by leaning on them.
12:22:55 <Rembane> koz_: Yes! :D
12:27:52 <hyiltiz> Gotcha thx
12:34:09 <LiceoProva> ciao
12:34:13 <LiceoProva> !list
12:34:13 <monochrom> LiceoProva: http://okmij.org/ftp
14:15:34 <cads> https://gist.github.com/maxsu/db9b0182b1d95225965a00b29684fce8
14:15:59 <cads> I have turned my import syntax into a proposal draft!
14:16:53 <cads> the section on prior work needs /special/ attention, since I'm almost surely reinventing a wheel here
14:17:27 <tomsmeding> cads: "import list (intercalate, sort)" -- typo, List not list
14:17:36 <cads> thanks!
14:17:38 <tomsmeding> well, Data.List
14:19:02 <tomsmeding> in general you may want make explicit that you're using lowercase module names as placeholders
14:19:04 <dminuoso> cads: My two cents on the draft: I. does not really help much, you save a few mentions of `imports` at the cost of not clearly seeing what module you import identifiers from.
14:20:22 <dminuoso> Say you have `import A.B.C, E.F.G, H.I.J, K.L.K (foo, bar), (quux), (baz doodle) ...` it becomes very hard to know where to modify import lists. Which import refers to what module? I dont know.
14:20:38 <dminuoso> If the point is to save `import` that suggests its only valuable if you actually use it multiple itmes.
14:20:46 <dminuoso> But that greatly decreases readability
14:21:14 <cads> yeah, there's a cart before the horse problem there - the real innovation as I see it is part II, and the concept of import lists is something I introduced to support the concept of an import list that is prefixed by some module or namespace
14:22:38 <dminuoso> As for part II, I can see the potential merit. I'd *much* prefer you dont put the `from Data` at the end, but at the beginning instead.
14:22:57 <dminuoso> So you might write `from Data import ...`
14:23:45 <cads> nice
14:23:48 <dminuoso> That seems far more reasonable, since it visually still respects the hierarchy (the referenced module comes first, and then the relative imports), and it makes it painstakingly immediately obvious what the following bulk is for
14:24:01 <boxscape> hm how about import Data.(List, Functor, Bifunctor)
14:24:37 <boxscape> ...I guess that might make import Lists hard to look at
14:25:16 <dminuoso> cads: One important thing here: If you make this an actual proposal, the syntax must be acceptable or it'll be shot down for poor ergonomics. I think its even an official rule that syntax is not for debate in a proposal.
14:25:34 <dminuoso> (Because it'd just lead to bike shedding)
14:25:58 <boxscape> if that is a rule it's broken quite a bit
14:26:33 <tomsmeding> re:"from" at the beginning: see python import syntax
14:26:44 <tomsmeding> about prior art: both python and rust have similar things
14:26:47 <cads> lol, I don't understand what you mean - as in I'd have to write a grammar for my extensions? that seems pretty fair and obvious - I wouldn't write a proposal unless I had a EBNF and a working implementation
14:27:06 <cads> do you mean something more stringent/
14:27:40 <dolio> It means it actually has to be a good grammar, I think.
14:27:59 <cads> as in the grammar also has to flow with haskell ergonomics? I think i can hit that target too, for all that I generally think haskell doesn't /have/ ergonomics (and I'm trying to introduce them)
14:28:49 <dolio> And for instance, putting 'from' at the start of the line is going to complicate the parser even more.
14:29:18 <dminuoso> cads: Roughly the haskell committee has a rule that the syntax of a proposal is _automatically accepted_ and not up for debate.
14:30:00 <boxscape> dminuoso I don't think that's right
14:30:52 <boxscape> syntax gets debated a lot in the proposal discussion as well as in the steering comittee mailing list, and I haven't been able to find such a rule
14:31:03 <dminuoso> Mmm, that's what I heard actually
14:31:08 <cads> automatically based on what criterion? also I don't understand who this committee is or why I would care - the proposal is for a standalone extension that someone can run if they wanna. It's not like I'd want the committee to maintain it or include it with ghc
14:31:11 * dminuoso thinks monochrom might have said this?
14:31:40 <dminuoso> Anyway
14:32:00 <cads> if it's useful to me I'll go ahead and write my internal code against it regardless of what the committee thinks, I mean, doesn't that make sense?
14:32:10 <dminuoso> cads: The part II has merit, but the current syntax does not seem to make things any better. I'd say they make it much worse.
14:34:13 <boxscape> cads if what you're looking to do doesn't involve adding it to the official ghc implementation, you don't have to worry about the proposal process or the committee. Typically, when people say they're writing a proposal, they mean they write a pull request in https://github.com/ghc-proposals/ghc-proposals/pulls outlining the changes they wish to
14:34:14 <boxscape> see/implement in the official ghc repo
14:35:59 <monochrom> Note that Haskell committee discussion â‰  GHC proposal discussion
14:36:18 <cads> I see this becoming a proposal if I end up using it in production and I love it, so in the meantime maybe I shouldn't call it a proposal
14:36:25 <boxscape> (I probably should've linked to https://github.com/ghc-proposals/ghc-proposals actually)
14:36:26 <dminuoso> Ah
14:52:18 <cads> dminuoso, Check out section V https://gist.github.com/maxsu/db9b0182b1d95225965a00b29684fce8
14:53:02 <cads> now it's so readable I dare say it's /too readable/ ;)      Of course I kid (there's no such think as TOO readable)
14:55:25 <cads> dminuoso, what I like about your form is that it forced me to add whitespace before and after, and I think the result looks great
15:01:46 <dminuoso> cads: The major issue either way is introducing a new keyword, something that will be met with much opposition.
15:04:18 <cads> do you know whether template haskell can let us build something like this, without rewriting the core syntax?
15:06:53 <arahael> dminuoso: syntax in a proposal is automatically accepted? What if the syntax is utterly wacky? :D
15:08:11 <cads> I think dminuoso meant that the committe will automatically apply its totally subjective and techical debt derived preferences to it, is what will automatically happen
15:10:14 <cads> but I'm not really bothered by that, since I would be amazed if I'm even still touching haskell in 3 months, let alone if I have authored a standards compliant language proposal.
15:11:09 <cads> What you're seeing now is me desperately trying to make haskell into a language I can look at on a daily basis without wanting physically to leave this planet
15:21:07 <dminuoso> cads: No, TH does not. 
15:21:27 <dminuoso> It lets you add top level declaration, you cant modify the module declaration itself.
15:22:05 <dminuoso> In my eyes, the relatively verbose import lists are a nuissance at best.
15:23:50 <dolio> The * thing seems like it's going to be confusing, too.
15:23:59 <cads> yeah I hate the * thing
15:24:45 <cads> alternative is to force a separate line for the module itself, which I'm honestly fine with being that it's an intermediary step that I'd have to implement anyways
15:25:29 <cads> I really just want to relieve my poor eyes from that god awful import import import   Data.  Data.   Data.    
15:25:58 <cads> some folks skim past that kind of line noise, but for me it causes me to become blind to the content of that code
15:26:26 <dminuoso> Luckily the import statements are at the top.
15:26:36 <dminuoso> So they are separate from the actual code that we tend to care about.
15:27:59 <cads> still doesn't help. If I'm auditing 10 files, that's 10 mangled imports I have to parse with my poor dyslexic brain and I've just reached a point where I'd rather just change the compiler
15:28:49 <texasmynsted> cads are you still fighting the imports?
15:28:50 <sm[m]> cads: in a little while this feeling will weaken :)
15:29:02 <sm[m]> just hang in there
15:29:26 <cads> sm[m], nah, it won't go away, I'll just make a patch and run it in my org, because I am the boss.
15:29:48 <texasmynsted> just put all the imports at the top and set a marker at the end of them. Then rather than start at the top, start at the marker.
15:29:53 <cads> and if you wanna help you can, but I invite you to stop discouraging me ;)
15:30:23 <texasmynsted> cads, I would appreciate it if you would write an import consolidator. 
15:30:37 <texasmynsted> or something that would automatically split code out into modules
15:30:58 <texasmynsted> That would be really helpful. I would use it straight away.
15:31:22 <sm[m]> I'm encouraging you. By all means continue, I support your making things better. cads++
15:32:31 * texasmynsted reading scrollback
15:33:19 <dminuoso> cads: I dont care either way, really. Assuming you proposed it, it got accepted, and somebody implemented it, I likely wouldn't turn it on anyway.
15:33:24 <dminuoso> Nothing forces me to. :)
15:33:42 <boxscape> cads are you envisioning writing a preprocessor, ghc plugin, or to work ghc?
15:33:45 <boxscape> s/work/fork
15:34:06 <texasmynsted> please update fourmolu to parse it also
15:34:37 <texasmynsted> because if fourmolu will not parse it, I will not use it.
15:35:26 <texasmynsted> need to go but cads I am curious what languages you normally use.
15:35:30 <cads> the cheapest, hackiest implementation I can learn about - preprocessor is probably able to let me do it with 2 regexes buuuuut. That's too cheap I think.  I think I need to work with the lexer and parser, so maybe a plugin is the cheapest (lowest cost of ownership) option
15:36:26 <boxscape> cads looking at https://hackage.haskell.org/package/ghc-8.10.1/docs/Plugins.html#g:7 it looks like the earliest point that plugins can change something is *after* the parser is run, but I haven't tried writing one so that might be wrong
15:36:35 <dminuoso> I found that grouping by inserting newlines between groups and having emacs execute a specially configured stylish-haskell to only sort import groups makes most of import list stuff quite bearable.
15:36:36 <cads> texasmynsted, I normally model stuff in pure category theory and then tell folks what to implement, but in the last year I've been building a cad geometry processing system in python, and running my company on it
15:36:53 <texasmynsted> nice
15:37:22 <texasmynsted> I hope you are here later so I can find more about this. Talk with you later.
15:37:52 <cads> boxscape, thanks, that kind of intelligence is hard for me to gather since there's so much to learn
15:38:36 <cads> you know, for code that I can personally babysit, a preprocessor regex is not THAT hard  
15:41:47 <cads> basically I want a lexer that rejects anything but my special import statement language. That queues up some importdecl tokens, and I re-emit those as well formed standard import statements.
15:42:05 <dminuoso> cads: You can define a custom preprocessor in GHC
15:42:15 <cads> lol
15:42:32 <cads> these kinds of tips save me literally hours, I thank you
15:42:38 <dminuoso> See -F and -optF in the GHC manual respectively
15:43:44 <cads> I don't think I even have to write it as a lexer -> parser -> transformer. I could /probably/ write it all as a single sed command if I was being sadistic
15:44:48 <cads> I will look at some sample preprocessors instead, because I'm gonna regret it down the line (such as when I share the code for collaborator assistance) if I use regex
15:46:18 <cads> https://github.com/ghc-proposals/ghc-proposals/blob/3dfec03b11e8829d7febbb7290c3183f752466d7/proposals/0190-module-qualified-syntax.rst
15:46:34 <cads> This looks like a great reference proposal
15:47:43 <cads> discusses the kind of considerations that the community considers, is very clear and short, and it was accepted
15:50:09 <cads> I am thinking that I will follow this report format for my internal process, even if the goal is to create a private artefact that only my org will use
15:55:54 <cads> dolio, in context of qualified imports, and foreign and unsafe imports (which I don't even want to know the grammar for)... suddenly I sense why you might feel reluctant to load that syntax even more heavily
15:56:21 <monochrom> Nice, cabal-install can hint me when I have a typo in a package name.
15:56:44 <monochrom> I entered "cabal install --lib quickcheck" and it reminds me "do you mean QuickCheck"
15:57:05 <monochrom> Perhaps next version if I enter "cabal install emacs" it will also ask me "do you mean vi"
15:57:44 <monochrom> You know what, I should put that as a wished feature for the next April 1st version of cabal-install :)
16:23:15 <cads> monochrom, I hate to say that I have recently declared for VI in that conflict
16:25:00 <cads> I don't understand why the ghc proposal process doesn't require an implementation along with the proposal https://github.com/ghc-proposals/ghc-proposals#how-to-start-a-new-proposal
16:26:18 <cads> saying "you need to have a correct implementation" would do a lot to prove performance charachteristics and utility - to wit, the community would be free to /try/ proposed changes
16:26:22 <cads> by default
16:27:06 <cads> is the implementation cost of some propose features so large that it depends on the committee to implement/attract implementers?
16:28:39 <cads> 1. It has a spec. 2. It has code that implements the spec. 3. The code and spec don't totally stink (subjective review criterion)  =>  this is a standalone proposal, and it warrants inclusion in the repo
16:29:51 <cads> not saying "machine checked correctness proofs" here, but 80% unit test coverage for unit tests that can run under 10 seconds, sounds like  a good idea
16:30:18 <cads> ie, that's what I will demand for any hask code within my own org 
16:33:42 <ephemient> nfd9001: I Ieft a message while you were disconnected yesterday
17:18:53 * hackage c2hs 0.28.7 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.28.7 (deech)
17:24:24 * hackage grow-vector 0.1.0.0 - Mutable vector with efficient appends  https://hackage.haskell.org/package/grow-vector-0.1.0.0 (NCrashed)
18:02:54 * hackage hledger-lib 1.20 - A reusable library providing the core functionality of hledger  https://hackage.haskell.org/package/hledger-lib-1.20 (SimonMichael)
18:45:49 <ezzieyguywuf> does cabal update update any packages?
18:45:54 <ezzieyguywuf> or just the database?
18:47:39 <MarcelineVQ> just the hackage index
18:48:34 <ezzieyguywuf> how do I tell it to update any packages that have never versions?
18:48:51 <ezzieyguywuf> or do I just have to do that manually?
18:49:01 <ezzieyguywuf> specifically I'm just thinking about the things I've installed with cabal install
18:50:05 <MarcelineVQ> manually. you'd type  cabal install thething  after a  cabal update
18:50:50 <sclv> with v2 whenever you cabal-build it'll calculate a plan with the latest avail pkgs
18:51:03 <ezzieyguywuf> MarcelineVQ: gotcha.
18:51:49 <ezzieyguywuf> so I have to know "ah, hledger v1.20 dropped, time to manually update!"
18:51:52 <ezzieyguywuf> seems a bit tedious
18:52:01 <ezzieyguywuf> sclv: lol, that wasn't the case before?
18:55:09 <sclv> in v1 it uses the already installed versions if they satisfy the deps
18:55:30 <sclv> i mean for an executable though of course its not going to magically keep them up to date in the background
18:55:33 <ezzieyguywuf> interesting
18:55:37 <sclv> its not like a system package manager
18:55:41 <sclv> its a build tool that can fetch deps
18:55:44 <ezzieyguywuf> indeed it is not.
18:55:58 <ezzieyguywuf> so I wonder if I should avoid using `cabal install` and instead prefer my package manager
18:56:18 <sclv> for executables, if you're ok with the release schedule of your package manager, yes
18:56:22 <sclv> if you want to be more bleeding edge, no
18:56:36 <monochrom> Your package manager lags way back behind.
18:56:57 <sclv> i mean for 90% of the executables on any given linux box i'm okay with that tho
18:57:17 <sclv> just.. i won't expect to be on the latest and greatest by a longshot
18:57:36 <monochrom> But to be honest, I just use ubuntu's version of pandoc, yes. :)
18:57:53 <monochrom> But totally not ubuntu's version of GHC, random, QuickCheck.
18:57:57 <ezzieyguywuf> lol, my package manager doesn't have hledger anyway
18:58:21 <ezzieyguywuf> monochrom: but QuickCheck, for example, I just use while coding, i.e. not as an executable in my path
19:05:55 <sm[m]> ezzieyguywuf: in hledger's case, there's a curl command you could run with cron :)
19:19:23 <ezzieyguywuf> sm[m]: lol, I'm hesitant enough as it is running these variosu curl stuffies, without putting it on a cron
19:19:36 <ezzieyguywuf> and cron is not the type of package management I'm interesting in, lol.
19:29:18 <sm[m]> quite right :) though it's kind of like Debians  unattended-upgrades..
20:21:10 <ezzieyguywuf> hrm, hledger-web seems to hang if I change the journal file using my text editor
20:22:22 <ezzieyguywuf> also, I tried `hledger-web MyAccount` but it still listed everything
20:22:32 <sm[m]> ezzieyguywuf: strange, can you reproduce with a minimal file ?
20:22:45 <ezzieyguywuf> sm[m]: let me try h/o
20:25:10 <ezzieyguywuf> sm[m]: this reproduces both
20:25:12 <ezzieyguywuf>  https://dpaste.com/89G2NYZ9H
20:25:20 <ezzieyguywuf> `hledger-web -f Test.journal Checking`
20:28:23 <sm[m]> thanks! not for me..  
20:28:28 <sm[m]> shall we take it to #hledger ?
20:28:38 <ezzieyguywuf> lol thought I was in there already whoop
20:33:19 <ario> hi
20:37:13 <rurt91> hi
21:05:46 <koala_man> I'm trying to load a file in ghci but it says "Could not find module â€˜Test.QuickCheck.Allâ€™". Can I point it to my cabal installed version? My ~/.cabal dir has a Test/QuickCheck/All.hi deep down but no .hs/.lhs/.hsig/.lhsig that ghci looks for
21:06:38 <ezzieyguywuf> if I cabal install some-package-0.5, but alreaddy have some-package-0.6 installed, how can I make cabal update the symlink in ~/.local/bin?
21:08:01 <ezzieyguywuf> hrm, ok just delete symlink and re-install
21:40:31 <rif> Hello friends. Can anyone offer some package management help?
21:41:55 <arahael> rif: You might want to be a little bit more specific if you want genuine help.
21:42:53 <rif> Sorry, new here, I was trying to figure out if this was a reasonable place to ask a detailed question. I can certainly be a lot more specific.
21:45:42 <rif> High-level: I installed Haskell platform on ubuntu. Things seemed to be working fine, but tonight I tried to import Data.List.Unique in a program and it didn't work. I ended up trying `cabal install --lib Unique`. After that, I could import Data.List.Unique, but I can no longer import Data.List.Split --- I get errors about the split package being hidden. Additionally, neither cabal nor ghc seem to think the unique package is actually 
21:45:43 <rif> installed (e.g, `ghc-package -list` doesn't show it as either local or global). So I'm not sure how to proceed. Any advice is welcome.
21:46:16 <rif> Sorry, "ghc-pkg list" doesn't show unique as installed.
21:49:13 <arahael> rif: I have to go, but it's probably hidden because it's not listed in your project's cabal file.
21:50:36 <rif> I don't know that I *have* a cabal file? All I did was start creating a file with a name like foo.hs, and then saying `ghc --make foo.hs` to get a binary. But your comment gives me ideas for things to look at --- I guess I edited some default cabal config.
21:51:52 <arahael> I think you'll want to try a `cabal init` or something
21:52:11 <arahael> Which should give you a file.  Anyway, I'm gone.
21:52:18 <rif> Thank you!
23:16:34 <jle`> koz_: hey, did you ever make any libraries involving fintary with Word-backed Sets?
23:16:45 <koz_> jle`: Nope.
23:16:59 <koz_> I worked on the idea a bit but never published it.
23:19:04 <jle`> ah, interesting. was talking about a similiar idea RE: AoC stuff and thought such a thing might be useful
23:19:10 <jle`> are you looking for PRs? :)
23:20:47 <jle`> it'd be in finitary-derive, right?
23:39:48 <topos> Finitary + word-backed sets and Alexandra Ocasio-Cortez.
23:39:51 <topos> what a night
23:50:34 <koz_> It'd be a different package most likely.
23:50:50 <koz_> Since you're going for a set based on a bitvector right?
23:51:06 <koz_> (it could actually be a newtype)
23:51:44 <koz_> (newtype FinitarySet a = FinitarySet (Vector (Cardinality a) Bit))
23:54:21 <jle`> mhm
23:54:32 <jle`> ah yeah, that would work i think :)
23:54:39 <jle`> or maybe just a WordN
23:54:43 <koz_> WordN?
23:54:59 <koz_> The main reason to use Vector (Cardinality a) Bit is just to borrow all the functions.
23:55:09 <koz_> (and you could borrow like, 90% of the things you'd want)
23:55:19 <jle`> Word8, Word64, etc :)
23:55:24 <koz_> Ah.
23:55:41 <koz_> Well, Vector (Cardinality a) Bit is secretly a Vector Word64 underneath.
23:55:45 <jle`> with the constraint that Cardinality a has to be less than 8, 64, etc.
23:56:01 <jle`> hm, for unboxed vector?
23:56:04 <koz_> Yep.
23:56:11 <koz_> Let me link.
23:56:18 <jle`> oh neat. i had that suspicion but thought there might be paging issues or something
23:56:38 <koz_> http://hackage.haskell.org/package/bitvec
23:57:03 <jle`> ooooh
23:57:05 <koz_> This defines a newtype around Bool (called Bit) which has the relevant instances, including Unbox.
23:57:12 <koz_> So it's packed super-tight.
23:57:15 <jle`> noice
23:57:22 <jle`> clever that they can just abuse the Unbox instance
23:57:26 <koz_> Yep.
23:57:33 <koz_> So you can just transitively abuse vector-sized.
23:58:03 <koz_> There's also some specialized ops that you could use.
23:58:27 <koz_> (zipBits for example)
23:58:44 <koz_> You can use that to implement blindingly fast intersection and union.
23:59:29 <koz_> You can also implement 'choose :: FinitarySet a -> Maybe a' using 'bitIndex'.
23:59:35 <koz_> Also very fast.
23:59:42 <jle`> i was looking at zipBits ... at first i thought it was inefficient, but then i noticed the type
23:59:44 <jle`> very clever
