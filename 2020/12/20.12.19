00:22:48 <kuribas> anyone know a good name for a database library?  I wanted to call my library hasqly, as it is a bit similar to the clojure library honeysql, but that may confuse with the hasql library.
00:27:23 <ADG1089> how can i remove this warning from xmonad.hs ?
00:27:29 <ADG1089> Could not find module ‘XMonad’
00:27:31 <ADG1089> There are files missing in the ‘xmonad-0.15’ package,
00:27:33 <ADG1089> try running 'ghc-pkg check'.
00:27:34 <ADG1089> Use -v (or `:set -v` in ghci) to see a list of the files searched for.
00:27:41 <ADG1089> hlint is giving this
00:37:39 <suzu_> how did you install xmonad?
00:37:54 <suzu_> did you try running 'ghc-pkg check'.
00:37:55 <suzu_> ?
00:47:00 <ADG1089> suzu_: it's fine except for some haddock warnings
00:47:15 <ADG1089> xmonad & xmobar are working fine
00:47:42 <ADG1089> i was trying to find a way to specify these depencies to haskell language server using hlint
00:56:18 <suzu_> i think there's some messages produced by hls on startup
00:56:33 <suzu_> that should show the ghc it's using to resolve packages
00:56:42 <suzu_> can you confirm it's the system one?
01:01:13 <ADG1089> I am using the one installed by stack in /usr/lib/ghc-8.10.2/
01:12:21 <suzu_> that's probably the problem
01:12:29 <suzu_> xmonad is installed in your system and so the system ghc knows about it
01:12:39 <suzu_> the stack ghc there doesn't know about the system xmonad
01:12:50 <suzu_> get hls to use the system ghc and that should fix it
01:16:01 <suzu_> i think that's done by making a hie.yaml file?
01:16:03 <suzu_> https://github.com/mpickering/hie-bios
01:29:01 <ADG1089> i have installed packages using stack cabal pacman , going to fix that first and then i think it might work @suzu_
01:30:06 <xerox_> I have a conundrum… in my mind the first and second defitions of 'go' should behave the same, in practice they don't: the bottom one gets the cake in 0.2s the top one takes almost 4 seconds! I can't see where the difference might be coming from, ideas? https://pastebin.com/raw/ytMYCkuQ
01:31:46 <idnar> mmm, hlint doesn't like case on bool
01:32:00 <suzu_> recommends 'if'
01:33:29 <suzu_> xerox_: fyi you can use catMaybes :: [Maybe a] -> [a] instead of the pat match
01:33:36 <idnar> I'm not sure I like how this looks with if: 
01:33:44 <idnar> https://www.irccloud.com/pastebin/VGrDKrIm/
01:35:17 <suzu_> xerox_: what happens if you add strictless to l and r arguments on the bottom go?
01:35:39 <xerox_> suzu_: the bottom one doesn't need tricks because it's the fast one, if I add them to the top one it makes no difference
01:36:25 <suzu_> err what i mean is
01:36:36 <suzu_> if you add it to the bottom one, does it get slower?
01:36:41 <xerox_> wow
01:36:52 <xerox_> that's a perspective I haven't considered! let's try
01:37:23 <xerox_> nope.
01:37:42 <xerox_> my best guess is it has something to do with either inlining or the rules for <- in guards?
01:38:04 <xerox_> my best guess is it has something to do with either inlining or the rules for <- in guards?
01:38:07 <xerox_> oops 
01:38:30 <xerox_> oh yeah {-# INLINE isPrefix #-} fixes it
01:39:41 <suzu_> w..hy
01:39:50 <suzu_> why would calling it be so expensive
01:40:06 <xerox_> beats me
01:40:37 <suzu_> if you don't inline it, but you compile with -O2, is it still slow?
01:40:44 <xerox_> yeah
01:41:11 <suzu_> if you inline it and don't use any opt flags, is it slow?
01:41:44 <xerox_> no
01:41:55 <suzu_> hmm
01:42:15 <suzu_> i would've guessed that the inline doesnt do it, but instead allows other optimizations to fire which speeds the program up
01:42:18 <suzu_> i guess that's not true
01:43:01 <xerox_> related but different I wish the regex library return type wasn't that mess of list of arrays of tuples of tuples
01:43:59 <suzu_> you might be able to do what you want with a parser combinator instead of a regex
01:44:17 <xerox_> hehe that's also a whole different can of worms
01:44:32 <suzu_> parser combinators can parse more than traditional regexes
01:44:47 <suzu_> except for where regex start doing things that are not in a regular language
01:44:49 <suzu_> lol
01:45:35 <xerox_> oh it's just me not knowing how to use =~ it has some nice types as well
01:49:02 <avdb> https://dpaste.com/6NE4YVP2Z
01:49:12 <avdb> I don't know if I already pasted this here, I got problems installing hlint
01:49:27 <avdb> When I run "cabal install happy" it says that it's installed
01:51:04 <avdb> versions >=1.19.4 are available as well
02:02:10 <nrdmn01> It seems like you cannot declare variadic functions as such with `foreign`. Some packages assume that the ABI for variadic and non-variadic functions is the same and just declare the parameters they need. Is this always a safe assumption?
02:03:58 <c_wraith> To be really properly safe, you'd need a wrapper function in C with a fixed parameter count
02:06:22 <suzu_> the abi on the C-side of things i believe is the same if you're calling cdecls
02:07:13 <nf> int-e: regarding yesterday's ping, i fixed my issue by removing the LANGUAGE UnboxedTuples pragma from L.hs. i have no idea why that works, i'll probably open an issue at mueval
02:12:54 <nrdmn01> I've noticed that lukko and network rely on this assumption. I'm not sure if this is considered to be a bug
02:17:44 <int-e> nf: Oh I missed it. I should change the default Pristine.hs to account for this.
02:19:36 <int-e> nf: if you look here, you can see it's disabled too: https://silicon.int-e.eu/lambdabot/State/Pristine.hs
02:19:56 <nf> ah, doesn't just break @type for me
02:20:07 <nf> mueval refuses to load the module if it has UnboxedTuples
02:23:11 <int-e> I thought it was a restriction of the bytecode compiler, namely it doesn't support returning unboxed tuples
02:23:43 <int-e> But something changed in this area to make the check more eager, and I forgot what.
02:24:08 <nf> ok
02:24:33 <nf> while i'm at it, how do i tell lambdabot to set its user mode before joining channels?
02:29:00 <nf> that doesn't seem possible
02:35:21 <int-e> Yeah I don't think there's any command for that, nor for sending raw IRC messages.
02:42:38 <int-e> nf: You could mimic the `codepage` command for a `usermode` command, https://github.com/lambdabot/lambdabot/blob/master/lambdabot-core/src/Lambdabot/Plugin/Core/System.hs#L93 ... but so far nobody has done so :)
02:50:45 <nf> i think a raw command would be nice too, would you be ok with that?
02:52:08 <nf> int-e ^
02:58:25 <int-e> nf: I would be very reluctant to take it because lambdabot's authentication of privileged users is rather weak
02:58:43 <nf> fai
02:58:45 <nf> r
02:59:13 <int-e> maybe it it was restricted to rc files... which should be possible, but I don't know whether there's any precedent for that in the codebase.
02:59:17 <int-e> it -> if
02:59:48 <nf> a better option would be to make authentication stronger, maybe with hostmasks
02:59:58 <nf> i'm just gonna make "usermode" :)
03:01:03 <int-e> nf: As for unboxed tuples, the problem I've encountered revolves around automatically enabling -fobject-code. See https://gitlab.haskell.org/ghc/ghc/-/issues/16876 ... mueval/hint don't cope well with that. And it affects ghci's :t (which is used by @type) because only interpreted modules get the benefit of having *all* their ids visible in ghci when loaded.
03:02:01 <nf> ah, that might be the root cause
03:02:22 <int-e> so another case of magic being bad, but only when you notice it. or maybe that's swapping cause and effect.
03:02:26 <nf> and something like https://stackoverflow.com/a/7139107/4198687 might be the solution (second part)
03:03:21 <nf> i filed an issue here https://github.com/gwern/mueval/issues/20
03:03:40 <nf> i added your link
03:12:46 <int-e> nf: Good luck with that! (I suspect mueval is basically unmaintained at this point. The only reason it still works is that it offloads almost all of its work to `hint`)
03:13:24 <int-e> But maybe I'll be proven wrong.
03:21:58 <int-e> Oh, haskell-ci is growing github actions support, yay.
03:23:07 <int-e> phadej++
03:24:39 <nf> int-e: seems like the bot doesn't store its own nickname in the LB monad, this might be trickier than i thought
03:29:36 <int-e> nf: Hmm. There's `lambdabotName` which extracts it from an IrcMessage. Interesting, and iffy.
03:30:45 <int-e> nf: Haha, the last two lines of lambdabot-core/src/Lambdabot/Message.hs
03:30:56 <nf> heh
03:32:10 <tzlil> is it possible to bootstrap this https://github.com/Lemmih/lhc without GHC? ghc is a little big for me 
03:32:31 <int-e> nf: But it should still solve your immediate problem, I think? I'm not 100% sure since the command will usually be in an rc context.
03:34:39 <int-e> nf: But I think I see the problem it's trying to solve there... lambdabot was intended to be able to connect to several networks, and it may have different nicks on each.
03:43:25 <nf> yeah it probably solves my problem
03:43:37 <nf> int-e: "nickserv identify" (in passwd.rc.sample) isn't a thing anymore, right?
03:44:34 <nf> oh i guess that could be  msg server:nickserv identify
03:45:23 <int-e> yeah it's  msg freenode:nickserv identify ...
03:48:39 <int-e> (the example is freenode specific anyway)
03:49:39 <demiurge> fwiw it's potentially, theoretically, very slightly safer to send `nickserv identify ...` rather than `privmsg nickserv identify ...` here
03:50:21 <nf> demiurge: how so?
03:50:40 <nf> oh, right, in case someone pretends to be nickserv
03:50:41 <int-e> services are sometimes momentarily offline and can be impersonated
03:50:53 <demiurge> the rule preventing normal people from using *serv nicks is an optional extra restricting something people can normally do; it can get lost
03:50:59 <demiurge> it doesn't normally, but it could
03:51:29 <demiurge> whereas if the config for the server-side alias somehow got lost, it just wouldn't do anything
03:51:40 <__monty__> SASL+TLS ftw, : )
03:55:12 <int-e> That first S...
03:56:00 <int-e> I mean I read "Simple" and then this list, https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer#SASL_mechanisms ... and then I'm questioning my sanity.
04:06:20 <nf> the IRC side of it is rather simple https://ircv3.net/specs/extensions/sasl-3.1.html
04:17:36 <demiurge> SASL itself is quite simple, it's just a carrier for arbitrary things
04:18:40 <Chousuke> There seems to be a pattern of "simple" things being anything but. SNMP is another example.
04:19:37 <demiurge> i mean, naming a thing "simple ..." is usually silly
04:20:58 <demiurge> SASL included, but even so its simpleness is relevant and useful sometimes; the idea is that you can carry SASL between the thing being authenticated and the thing doing the authenticating without having to understand any of those mechanisms
04:21:13 <demiurge> and an implementation that carries without understanding is indeed quite simple
04:25:34 <idnar> Chousuke: SOAP!
04:39:57 <tzlil> is it possible to do something like ((x : y) : xs) to get elements inside tuples if i have a list of tuples as an argument?
04:48:53 <tomsmeding> tzlil: you can nest patterns, so if your argument has type, say, [(a, b, c)], then you can pattern-match that using ((x, y, z) : xs)
04:49:21 <tomsmeding> you can't match a tuple (a, b, c) using a pattern (x : y) if that's what you intended
05:19:55 <gentauro> is there a way to share a constructo for sum types to the result when using show is: `FooBar (Foo 42))` and `FooBar (Bar 'a'))`? FooBar, Foo and Bar are constructors
05:20:38 <gentauro> what I end up with is something like this `Foo (Foo 42))` and `Bar (Bar 'a'))` where both are of the type FooBar
05:20:41 <gentauro> :|
05:20:49 <gentauro> I just think it looks redundant
05:21:36 <gentauro> Remark: Combining sum and product types is not an option as Foo and Bar have different types and therefore a function that works for FooBar Foo would also work for Bar (runtime error and not compile error)
05:22:40 <gentauro> `data FooBar = Foo Int | Bar Char` <- not an option
05:23:58 <gentauro> `data FooBar = Foo { foo :: Int } | Bar { bar :: Char} ` <- this is the one that it's not an option
05:24:01 <gentauro> :)
05:24:51 <joel135> You mean you want to "flatten" the type?
05:27:04 <gentauro> joel135: I think I found a solution. I just have to my `logic` to another file (module)
05:27:11 <gentauro> then it's possible :)
05:27:31 <joel135> ok
05:29:17 <gentauro> `I just have to my` -> I just have to move my`
06:43:01 <inkbottle> dsal: Thanks for the pointer about STM. I have a hard time conciliate functional programming with inter-process communication and the rest of it. It will take time.
06:44:25 <merijn> inkbottle: Most inter-process communication is simply "the same stuff you do in other languages, except now you have IO in the type", tbh
07:08:59 <ezzieyguywuf> can I make cabal make a man-page for me?
07:09:48 <merijn> ezzieyguywuf: Define "can" ;)
07:10:01 <merijn> You can modify cabal to do anything, in theory :p
07:10:25 <merijn> Practically speaking: No.
07:10:50 <merijn> You could, theoretically, build code for that into a custom Setup.hs, but Custom build type is a PITA
07:24:08 <ezzieyguywuf> lol, like is it built in
07:24:28 <merijn> ezzieyguywuf: As I said: "Practically speaking: No"
07:24:40 <ezzieyguywuf> hrm, different question - if I'm packaging something from hackage, where would I look to see if there's a man pag eto install
07:24:47 <merijn> It doesn't really make sense anyway, since there's a gazillion different doc formats and way to convert things
07:24:59 <tzlil> http://0x0.st/iC-R.txt how come the first main works, but the second one gives me a type mismatch?
07:25:23 <merijn> ezzieyguywuf: The repository and/or check if there's something in the sdist
07:25:37 <ezzieyguywuf> merijn: yea the sdist is what I'm using
07:25:42 <ezzieyguywuf> so it's just a matter of searching
07:25:52 <ezzieyguywuf> i.e. there's not a predefined place they would put it
07:25:53 <merijn> tzlil: You're calling "hasPath" with a tuple, but it doesn't take a tuple
07:26:09 <merijn> tzlil: You'll wanna unlearn the habit of using parentheses for function calls asap, tbh
07:26:36 <tzlil> is `[(Int, Int)]` not a list  of tuples?
07:26:37 <merijn> ezzieyguywuf: Well, it'd have to be listed as extra-data-file or extra-source-file in the cabal file to be included in the tarball
07:26:57 <merijn> tzlil: Yes, but hasPath takes 3 arguments, a list, and 2 ints
07:27:05 <lambda> tzlil: `([(1, 2)], 1, 2)` is a `([(Int, Int)], Int, Int)` 3-tuple
07:27:08 <merijn> tzlil: You are calling it with 1 argument, a tuple
07:27:16 <tzlil> ohh
07:27:23 <ezzieyguywuf> merijn: ok. thank you for yoru help.
07:27:48 <merijn> tzlil: probably wanna put a space between print and ( to help remind you of the difference :)
07:28:07 <lambda> tzlil: you want something like `main = print $ hasPath [(1, 2)] 1 2`
07:28:09 <merijn> The correct way would be: print (hasPath [(1, 2)] 1 2)
07:28:20 <tzlil> thank you
07:29:20 <merijn> Same with the other one, which would be better formatted as: print (isAsc [1, 2, 3])
07:29:57 <merijn> tzlil: Also "True && isAsc(xs)" is just "isAsc xs" ;)
07:34:42 <thunderseethe> if I have a GADT constructor in the style `IntLit :: Int -> Expr Int` does that preclude me from writing a functor instance for my GADT `Expr`?
07:36:52 <solonarv> thunderseethe: yes, it does
07:37:06 <merijn> Not necessarily
07:37:22 <solonarv> hm. true
07:37:32 <thunderseethe> Fair enough, is there a common tactic for handling/working around that? Avoid having leaf constructors in my GADT?
07:37:35 <solonarv> however you can't write a functor instance that applies the function to tht Int
07:37:57 <thunderseethe> That is okay, I just want to return the int unmodified
07:38:17 <solonarv> merijn: actually, how? what's the RHS of   fmap f (IntLit n)  ?
07:38:52 <merijn> solonarv: actually, maybe you're right, thinking is hard :p
07:39:03 <solonarv> it can't be   IntLit n   or   IntLit (f n)   (doesn't typecheck), and if it's anything else, you break the 'fmap id = id' law
07:39:06 <thunderseethe> Lol it is, I've been scratching my head
07:40:06 <thunderseethe> Okay it sounds like I'll need a more fundamental redesign. Thanks for your help!
07:40:52 <ep1ctetus> I am trying add this delay (https://hackage.haskell.org/package/delay-0) package into my stack setup, but it won't compile. I get an error message "Could not find module `GHC.Event'"
07:41:56 <merijn> Sound's like your GHC is too old and/or broken?
07:42:36 <ep1ctetus> hm, I am using 8.8.4
07:42:45 <merijn> hmm, docs say it's GHC internal that module
07:43:32 <ep1ctetus> I looked into using 8.10 but learned that it is not working on Windows
07:44:27 <merijn> oh, you're on windows?
07:44:37 <ep1ctetus> yeah, maybe that's my problem
07:44:53 <merijn> GHC.Event is low level API stuff for interacting with the event manager
07:45:18 <merijn> Given that it's marked as GHC internal and Windows probably has a separate event manager I wouldn't be surprised if that's it
07:46:02 <ep1ctetus> ok that makes sense, I think I can work around it. Thanks for your help!
07:47:22 <ephemient> ep1ctetus: its upstream repository has a unreleased commit titled "Updates for 8.8": https://code.xkrd.net/davean/delay/-/commit/321946082b4252fa7e28e28219299148ec2a5b1b
07:58:49 <Darwin226> Hey guys. Anyone with experience with hip/JuicyPixels? I have a greyscale image (Y color space) and what I want to do is just sum up all the values. When I do writeImage I can see that it indeed is a greyscale photo, but when I use the sum function I get really small numbers
07:59:09 <Darwin226> in fact negative values, like -5e-13
08:14:39 <Ferdirand> is there a reason why attoparsec's Parser does not implement MonadFix ?
08:15:42 <[exa]> Ferdirand: kinda thinking if `fix` even makes sense for parsing
08:16:38 <hpc> it makes sense wherever recursion does
08:16:48 <ephemient> original parsec doesn't implement MonadFix either, but Megaparsec does
08:16:52 <Ferdirand> megaparsec has it
08:17:44 <Ferdirand> i'm trying a crazy solution to today's advent of code
08:17:52 <[exa]> hm... isn't attoparsec parsing method too "strict" for that approach?
08:17:55 <ephemient> it makes sense when the structure is sufficiently lazy, maybe attoparsec isn't?
08:18:03 <ephemient> yeah that
08:18:09 <Ferdirand> where i'm building an intmap of parsers
08:18:26 <Ferdirand> by parsing rule specifications
08:18:38 <Ferdirand> the rules do not come in order, so my intmap is lazy
08:19:50 <Ferdirand> btw the reason i'm giving attoparsec a try is that i couldn't wrap my head around a backtracking bug in the megaparsec version
08:20:08 <Ferdirand> after unsuccessfully inserting "try" in every place i could think of
08:20:22 <[exa]> hell yeah, spray try!
08:20:27 <merijn> eh, no
08:20:30 <[exa]> I love that part of megaparsec :]
08:20:41 <merijn> Spraying try is a *great* of making your parser a billion times harder to figure out
08:22:51 <Ferdirand> which is why i wanted to give attoparsec a try
08:23:25 <Ferdirand> it's a shame because it would have been a great showcase for how awesome it is to have first-class parsers
08:23:26 <[exa]> o man, looking at the puzzle input I'd just sed it to prolog and let it solve itself.. :d
08:23:41 <[exa]> Ferdirand: why you need a fix though?
08:24:53 <Ferdirand> my rules parser is a Parser (IntMap (Parser ())
08:26:12 <Ferdirand> which would be mfix (\rules -> fromList <$> many (ruleParser rules))
08:26:26 <[exa]> What about Parser (Intmap (Intmap -> Parser() ) ) ?
08:26:52 <sm[m]> Ferdirand: to figure out those, use megaparsec's dbg to trace its progress
08:27:12 <Ferdirand> [exa]: i'm not sure, i wanted all map lookups to happen only once if possible
08:27:55 <Ferdirand> so that after the first invocation, every rule parser would retain references to its sub-rules
08:28:32 <Ferdirand> sm[m]: oh that's a great idea, didn't know that existed
08:29:02 <sm[m]> sometimes it's essential
08:30:00 <sm[m]> also, writing clear grammars first (eg as a comment) we'll help you write more robust parsers
08:30:09 <sm[m]> will
08:31:23 <glguy> Ferdirand, In megaparsec (a<|>b) never tries b when a succeeds
08:31:29 <Ferdirand> i was pretty happy about the clarity of my code
08:31:39 <Ferdirand> glguy: what about (try a) <|> b ?
08:31:47 <glguy> that's an instance of what I wrote
08:31:55 <glguy> where a = try youra
08:32:04 <glguy> try is about failure, not success
08:32:09 <Ferdirand> ah
08:32:10 <Ferdirand> okay
08:32:13 <Ferdirand> yes i got it now
08:32:14 <[exa]> Ferdirand: like, for a prototype I'd just do a cleanly separated `return $ \rules -> do ...aaabbbParser...`
08:32:55 <Ferdirand> so i actually wrote another version where i parse and backtrack by hand
08:33:22 <Ferdirand> and you are right that the failures are exactly the cases where the rule matches a prefix of the string before matching the complete string
08:33:42 <Ferdirand> so if i have (a <|> b) >> c
08:33:45 <glguy> Ferdirand, I have a fixpoint for building the parser table like your'e describing, but I do it after parsing instead of directly inside of megaparsec with an mfix https://github.com/glguy/advent2020/blob/master/execs/Day19.hs
08:34:31 <glguy> Ferdirand, nshepperd and I were just talking about this in ##adventofcode-spoilers. You can use Codensity to distribute the >> c under the <|> and make this work with megaparsec
08:34:47 <Ferdirand> Codensity
08:34:59 <Ferdirand> this is probably above my level
08:35:25 <glguy> Codensity is a unhelpful name for a continuation passing transformation
08:35:59 <solonarv> glguy: in fact, with megaparsec and (a <|> b), not only is b never tried if a succeeds (this isn't too surprising); b will also not be tried if a fails after consuming input!
08:36:18 <glguy> solonarv, yeah, that's where try comes back in
08:36:30 <glguy> The practical affect of which is that >>= become right associated and >>= distributes under <|>
08:38:10 <sm[m]> solonarv: right, this trips up everyone
08:38:35 <Ferdirand> but just to clarify
08:38:45 <sm[m]> it could be made much more prominent in parser libs' tutorials I think
08:39:09 <Ferdirand> here the problem is that we have (a <|> b) >> c, where (a >> c) fails, (b >> c) succeeds, but (a) succeeds
08:39:43 <glguy> b >> c would have succeeded but is never tried because a succeeded
08:39:51 <Ferdirand> right
08:39:58 <Ferdirand> and this is not fixable with a "try" somewhere
08:40:08 <glguy> that sums it up
08:40:28 <Ferdirand> i'll have learned something today. Codensity here I come.
08:40:54 <Ferdirand> Codensity f is the Monad generated by taking the right Kan extension of any Functor f along itself (Ran f f).
08:41:27 <glguy> That might be true and also doesn't matter
08:41:41 <sm[m]> Ferdirand: for that case couldn't you simply switch the order of a and b
08:42:01 <glguy> sm[m], not if you ever wanted a >> c to work when b succeds but b >> c fails
08:42:15 <sm[m]> Ok, gotcha
08:42:26 <glguy> sm[m], also this is for an advent of code problem where the grammer is given as an input
08:42:40 <glguy> sm[m], so ideally you aren't having to do too much inspection of what that grammar is
08:43:07 <glguy> and we're fotunate that it's a particularly gentle case of a grammar to handle
08:43:19 <sm[m]> (a>>c)<|>(b>>c)... ok
08:44:23 <glguy> the easier solution is to just use not-megaparsec and to pick a library that doesn't have this commitment optimization
08:45:18 <glguy> (but if you learn about codensity along the way then it'll be worth it; that turns out to be useful in a variety of contexts)
08:46:06 <Ferdirand> so what is easier, learning about codensity or implementing MonadFix for attoparsec's Parser ? :)
08:47:38 <nshepperd> Codensity f a = forall r. (a -> m r) -> m r
08:47:45 <[exa]> oh my, the sed+prolog approach works
08:47:51 <nshepperd> err
08:48:09 <nshepperd> Codensity m a = forall r. (a -> m r) -> m r
08:49:02 <glguy> Ferdirand, Codensity is easier
08:49:08 <glguy> and mfix for megaparsec would just be kind of a hack
08:49:33 <Ferdirand> why kind of a hack ? 
08:49:50 <glguy> because it's an unnecessary layer violation
08:49:55 <Ferdirand> I think it's really nice to abstract the rule IDs away
08:49:58 <glguy> you'd just be doing it out of convenience
08:50:26 <glguy> finish your parsing, then resolve your references; there's no reason to merge them
08:50:53 <glguy> Ferdirand, I think it's probably worth trying to follow the types and implement: Functor, Applicative, Monad, Alternative on Codensity. Doing those instances would give you a sense of what it does and why ti fixes the megaparsec issue you're having
08:51:03 <Ferdirand> i thought it was really beautiful to completely eliminate the indirection
08:51:38 <Ferdirand> it does make debugging a tad more difficult :°
08:51:49 <glguy> The reason to justify that complexity would be if parsing the rules themselves was directed by the rules parsed so far and somehow the strictness worked out that you could return the intmap lazily enough
08:52:05 <Ferdirand> but that works
08:52:09 <Ferdirand> that's not the problem
08:52:36 <Ferdirand> megaparsec + mfix works perfectly fine together when the grammar is regular
08:53:10 <glguy> I mean, you could also parse the inputs while you were parsing the rules in the top half all in one lump of code
08:53:17 <glguy> but making that kind of mess of thigns is why we have compilers in the first place
08:53:21 <Ferdirand> yeah that's what i do :)
08:54:28 <Ferdirand> i considered wrapping Parser with a newtype to introduce a clear separation
08:55:23 <Ferdirand> I already have a solution with separated rule parsing and rule matching, and a hand-written matcher, with the same rule type as yours
08:55:31 <Ferdirand> IntMap (Either Char [[Int]])
08:56:06 <glguy> If you want to do the all-in-one solution, you can just do the fixed point outside of megaparsec
08:56:25 <glguy> pass the intmap you got after a successful parse back in as a parameter
08:57:19 <Ferdirand> yeah, i guess that would work
08:57:33 <Ferdirand> it's not as pretty as mfix, though
09:02:36 <glguy> Ferdirand, why were you looking at attoparsec?
09:03:01 <glguy> Ferdirand, it has this same backtracking behavior as megaparsec
09:06:32 <Ferdirand> glguy: does it ?
09:07:54 <glguy> The only (well-known to me) parser combinator library that doesn't do that is ReadP
09:08:23 <Ferdirand> ah yes
09:08:26 <Ferdirand> of course
09:08:39 <Ferdirand> i was still in the mindset that my problem was caused by a lack of `try`
09:08:44 <Ferdirand> which we established is not
09:09:06 <[exa]> attoparsec docs: "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure."
09:09:23 <glguy> Right
09:09:24 <Ferdirand> yes this is a terminology problem
09:09:41 <glguy> The important words are "on failure"
09:10:00 <Ferdirand> but ReadP is actually a nice idea
09:10:28 <glguy> In attoparsec:   pure x <|> y === pure x
09:12:36 <Ferdirand> so, Codensity
09:13:02 <Ferdirand> i can write an instance Functor (Codensity f) without a Functor f constraint on f
09:13:17 <Ferdirand> that's somewhat surprising
09:13:19 <glguy> pretty cool :nod:
09:15:04 <Ferdirand> try :: Parser i a -> Parser i a
09:15:08 <Ferdirand> oops sorry
09:15:18 <Ferdirand> pure a = Codensity ($ a)
09:16:23 <Ferdirand> i'm following the types but this is still baffling
09:16:29 <xerox_> @info Codensity
09:16:29 <lambdabot> Codensity
09:16:44 <geekosaur> no @info
09:18:47 <nf> all that is making me wonder whether there are grammars that ReadP *can't* parse
09:19:09 <glguy> There are
09:20:16 <monochrom> Left recursion will always pose a problem.
09:20:17 <nf> note that i mean grammars, not languages
09:20:24 <xerox_> what is ReadP
09:20:29 <nf> monochrom: doesn't it handle that by running parsers in parallel?
09:20:53 <nf> xerox_: https://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html
09:21:06 <glguy> nf: it doesn't
09:21:38 <glguy> It would need a parallel case operation
09:22:14 <nf> It parses all alternatives in parallel [...]
09:22:23 <nf> you even said <glguy> So we might have to keep track of fuel or do them in parallel like readp
09:22:29 <xerox_> so <|> and +++ are very different?
09:23:03 <xerox_> R f1 +++ R f2 = R (\k -> f1 k <|> f2 k)  -- lol
09:23:03 <dminuoso> Yes. No. Perhaps.
09:23:05 <glguy> nf: that was me being wrong
09:23:25 <nf> impossible
09:23:46 <dminuoso> xerox_: <|> has no intrinsic meaning, so its behavior depends on the specific instance.
09:23:55 <dminuoso> xerox_: In case of ReadP it happens that <|> = +++
09:24:05 <nf> guess i'll actually try it
09:26:26 <nf> hm
09:26:50 <nf> let p = (p >> char 'a') +++ char 'b' in readP_to_S p "baaaa"
09:26:53 <nf> loops forever
09:27:27 <nf> disappointing
09:31:56 <dolio> There isn't really much that can be done with that kind of representation.
09:32:15 <dolio> `p` is not like a non-terminal. It is a recursively defined value.
09:37:37 <nf> you could probably break down the evaluation by layering constructors
09:37:42 <nf> something like the delay monad?
09:41:36 <Ferdirand> try :: Parser i a -> Parser i a
09:41:41 <Ferdirand> argh sorry
09:42:04 <dolio> You could do something where (>>=) added its own delays, but then it wouldn't be a monad, technically.
09:42:11 <Ferdirand> Codensity fab <*> Codensity fb = Codensity $ fab . (fb .) . (.)
09:43:05 <Ferdirand> that's not extremely clear
09:43:26 <Ferdirand> Codensity is essentially wrapping a into ($ a) ?
09:43:38 <Ferdirand> with a restricted type ?
09:48:25 <dolio> You don't need to write everything point free.
09:49:55 <glguy> especially if the goal is to understand the result of what you're doing :)
09:50:10 <Ferdirand> all right
09:50:28 <Ferdirand> i can extract the value from the codensity by applying it a lambda
09:51:19 <Ferdirand> but it's still incredible that Applicative doesn't require any constraints
09:51:30 <Ferdirand> let's try Monad
09:55:22 * shapr hops cheerfully
10:04:06 <Kronic> Wow I'm dumb, I solved part 2 of day 8 a few days ago, got the wrong answer and left it. So I came back to it today... I was using the sample input :| 
10:04:34 <Ferdirand> Codensity ma >>= f = Codensity $ \fb -> ma (\a -> let Codensity fb' = f a in fb' (\b -> fb b))
10:05:07 <Ferdirand> i kinda start getting a vague intuition about it
10:06:05 <Ferdirand> so far the f doesn't seem very useful
10:06:20 <glguy> You'll need a way to go:    f a -> Codensity f a
10:06:26 <glguy> and back:   Codensity f a -> f a
10:06:35 <Ferdirand> might have replaced "f r" by "r" in the types, and these three instances would still be valid, right ?
10:06:38 <Ferdirand> wait
10:06:48 <Ferdirand> you had me reimplement Cont !
10:07:03 <glguy> Ferdirand, but how is it different from Cont?
10:07:07 <Ferdirand> ah no
10:07:09 <Ferdirand> Cont is easier
10:07:34 <Ferdirand> because when i'm unpacking a Cont, I can choose any r
10:10:09 <Ferdirand> ok, so: Alternative
10:10:24 <sm[m]> Kronic: hehe, a fresh mind helps!
10:11:17 <Ferdirand> that must require some constraint, surely
10:12:23 <Ferdirand> empty = Codensity (const empty)
10:19:09 <Ferdirand> Codensity fx <|> Codensity fy = Codensity $ \m -> fx m <|> fy m
10:19:14 <Ferdirand> this one is strange
10:20:41 <Ferdirand> oh
10:20:44 <Ferdirand> i think i get it
10:21:12 <Ferdirand> Codensity f is an applicative even if f is not
10:21:31 <Ferdirand> likewise for monad
10:21:37 <Ferdirand> so
10:21:56 <Ferdirand> distributivity between <|> and <*> can also hold independently of the behaviour of the underlying <*>
10:22:40 <nf> weird, my guess would have been  empty = Codensity (=<< empty)
10:22:58 <nf> i wonder what that instance would do
10:24:32 <Kronic> sm[m], very true. I came back to it several times for a few mins and read the solution and was like "there's no reason for this not to work". So today I came back, rewrote it, got the same answer as only then did I look at my input lol 
10:26:05 <nf> well, i guess they are the same if  empty >>= f === empty
10:26:08 <nf> is that a law somewhere?
10:27:07 <nf> aha, it is a law of mzero
10:27:34 <dsal> inkbottle: if you can do io, you can do STM
10:30:16 <nf> ok, there's something i don't understand
10:30:58 <nf> the type of (<|>) for Codensity f should be isomorphic to  forall b c d. ((a -> f b) -> f b) -> ((a -> f c) -> f c) -> (a -> f d) -> f d   , right?
10:31:06 <nf> what forces b ~ c ~ d ?
10:32:57 <nf> ooooh wait i got confused by the notation for existential types
10:33:23 <nf> it's actually (forall b. (a -> f b) -> f b) -> (forall b. (a -> f b) -> f b) -> (forall b. (a -> f b) -> f b)
10:34:24 <nf> that last forall is pushed to the top level and then the inner b's are set to that rigid top-level b
10:34:33 <aplainzetakind> Can -Wincomplete-patterns be confused by ViewPatterns?
10:36:50 <ephemient> no more than guards do, but that can be difficult for the compiler too
10:37:57 <maralorn> Is there some way to capture all recoverable IOExceptions but not the other ones.
10:38:03 <maralorn> E.g. all but sigterm, sigkill or async exceptions?
10:41:52 <aplainzetakind> ephemient: How can I locally suppress it?
10:42:16 <aplainzetakind> Except by putting a redundant pattern at the end.
10:52:06 <wz1000> Is there anything that lets me do a parallel map over a Vector?
10:52:40 <shapr> parMap ?
10:52:50 <shapr> @hoogle parMap
10:52:50 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
10:52:50 <lambdabot> Control.Monad.Par.Combinator parMap :: (Traversable t, NFData b, ParFuture iv p) => (a -> b) -> t a -> p (t b)
10:52:51 <lambdabot> BroadcastChan parMapM_ :: (Foldable f, MonadUnliftIO m) => Handler m a -> Int -> (a -> m ()) -> f a -> m ()
10:53:22 <leifm> @hoogle parTraversable
10:53:23 <lambdabot> Control.Parallel.Strategies parTraversable :: Traversable t => Strategy a -> Strategy (t a)
10:53:25 <Ferdirand> glguy: thanks for all these precious hints
10:53:27 <shapr> wz1000: though my first try at using parMap instantly ate 64 GB of RAM and then dug into my swapfile. I've been using parBuffer since then.
10:53:47 <Ferdirand> not yet fully grokking Codensity. I'll be back with more questions, probably.
10:54:12 <wz1000> shapr: but then I have to convert to and from a list 
10:54:36 <shapr> in that case, what about parTraversable suggested by leifm?
10:54:52 <wz1000> I guess this might work: https://hackage.haskell.org/package/vector-strategies-0.4/docs/Data-Vector-Strategies.html
10:57:15 <leifm> Isn't converting to and from a list basically free? `fromList [1 .. 100]` shouldn't construct the list `[1.. 100]` in memory, and neither should `toList vec`, so `fromList . parMap f . toList` might not construct anything.
11:13:07 <glguy> Ferdirand, if you look inside the implementation of ReadP's instances you just wrote you might find them familiar
11:40:11 <ADG1089> i have containers-0.6.2.1 & containers 0.6.4.1 how can i remove the latter
11:40:28 <ADG1089> i can't find it in ghc-pkg list
11:41:06 <c_wraith> that means it probably was installed by new-style cabal?
11:42:45 <c_wraith> look in ~/.ghc/<version>/environments/default 
11:43:00 <c_wraith> If there's a line in there that mentions containers 0.6.4.1, remove it
11:43:25 <c_wraith> and beware of using cabal install --lib
11:44:40 <glguy> ADG1089, Did you see c_wraith's 4-message response?
11:49:13 <the-smug-one> Hot take: Tagless final style is far more useful in lazily evaluated languages than in eagerly evaluated ones.
11:50:34 <ADG1089> c_wraith: that fixed it
11:50:49 <ADG1089> thanks, what should i use instead of cabal install --lib, pacman?
11:51:27 <sclv> just use newstyle with projects
11:51:32 <sclv> don't install libs at all
11:52:00 <grepcake> Hi, could someone please explain why `instance (MonadState S m) => LangL (HasS m) where` is an undecidable instance? And what should I do to help it
11:52:16 <ADG1089> sclv: v2-install?
11:52:36 <sclv> no don't install libs at all directly
11:52:44 <sclv> just add them as deps to your project and v2-build
11:52:49 <sclv> only v2-install executables
11:53:11 <c_wraith> use mkdir and cabal init a lot
11:53:32 <glguy> for one-off experimentation I'll run: cabal repl --build-dep somelib
12:01:34 <superstar64> any way i have type inference for instance constraints? 
12:01:44 <superstar64> where the stuff before ``=>`` is inferred
12:05:23 <ddellacosta> superstar64: I'm not sure exactly what you mean--ghc will certainly complain if constraints are not satisfied and suggest a solution, and on the other side of the equation it's possible to derive a lot of instances for data types
12:05:55 <superstar64> yea, instead of ghc complaining, i want it to fill in the constraints for me
12:06:20 <superstar64> i have like 100 instances and it's kinda annoying to have each one declare it's requirements
12:06:45 <superstar64> i have a 1 function per type class thing going on
12:07:04 <ddellacosta> I would suggest first seeing if you can cut down on the number of instances. That doesn't seem like a very satisfactory design
12:07:32 <ddellacosta> and I don't know how Haskell would make this easier on you, other than maybe template haskell?
12:08:00 <ddellacosta> I mean, you can try to derive what you need
12:08:13 <ephemient> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-constraint-kind already allows for aliases if you've got some unfortunate design that makes you type the same context over and over again
12:09:07 <superstar64> nope each instance has unique requirements https://github.com/Superstar64/aith/tree/rewrite/source/TypeSystem
12:40:12 <gentauro> anybody know how to pretty-encode with Aeson? https://hackage.haskell.org/package/aeson-1.5.4.1/docs/Data-Aeson.html#g:1
12:40:29 <gentauro> pretty-encode = multi-line + 2 space indentation
12:40:30 <gentauro> :)
12:40:50 <koz_> There's an 'aeson-pretty' package that might do what you need?
12:41:41 <gentauro> koz_: and we have a winner :) https://hackage.haskell.org/package/aeson-pretty-0.8.8/docs/Data-Aeson-Encode-Pretty.html#v:encodePretty
12:41:49 <gentauro> https://hackage.haskell.org/package/aeson-pretty-0.8.8/docs/Data-Aeson-Encode-Pretty.html#v:defConfig
12:41:52 <gentauro> :)
12:41:53 <koz_> Glad I could help.
12:41:55 <gentauro> koz_: thx
12:48:35 <boxscape> Are there sensible implementations of MonadPlus that are different from the Alternative instance?
12:49:18 <koz_> boxscape: That would by definition make them insensible, surely?
12:49:33 <boxscape> Possibly, I don't know much about MonadPlus
12:50:27 <boxscape> Does it only exist because Applicative and Alternative weren't around at the time?
12:50:34 <koz_> Pretty much.
12:50:41 <boxscape> I see
12:52:19 <tzlil> are there namespaces in haskell? ive challenged myself to implement some functions that haskell provides (zip, length, elem, etc.) but i have to change the name in order to not conflict with the actual function
12:52:46 <koz_> tzlil: There are modules, which act as namespaces.
12:53:12 <koz_> If by 'Haskell' you mean 'Prelude', the solution is 'import Prelude hiding (zip, length, elem, whateverTheHellElse, ...)'
12:53:35 <tzlil> and can i do `import Prelude hiding *`?
12:53:40 <tzlil> yeah, i mean prelude
12:53:52 <boxscape> you can write `import qualified Prelude`
12:54:01 <koz_> tzlil: No because that's not valid syntax. Is your goal to have nothing in the Prelude available at all?
12:54:04 <tzlil> it looks like i can compile with -XNoImplicitPrelude
12:54:07 <boxscape> that means anything from Prelude has to be accessed by writing "Prelude.x`
12:54:10 <koz_> If so, the solution is {-# NoImplicitPrelude #-}.
12:54:11 <boxscape> that works, too
12:54:15 <koz_> I meant.
12:54:21 <tzlil> thanks 
12:54:22 <koz_> {-# LANGUAGE NoImplicitPrelude #-}
12:54:24 <koz_> At the top of the file.
12:54:26 <dolio> You can also `import Prelude()`
12:54:32 <boxscape> oh, yeah
12:54:38 <koz_> boxscape's and dolio's suggestions are also good.
12:54:50 <tzlil> ah wait, now `Int` and `Bool` are not in scope
12:55:29 <boxscape> if you only want to import specific things you can also do `import Prelude (Int, Bool)`
12:56:01 <tzlil> thanks
12:57:47 <gentauro> B21:54 < koz_> {-# LANGUAGE NoImplicitPrelude #-}
12:57:54 <gentauro> koz_: so no IO right?
12:58:12 <koz_> gentauro: Well, I was offering a solution to the stated problem.
12:58:12 <tzlil> now its complaining about some operators not being in scope, which is to be expected, but i dont know what name i need to import them by
12:58:21 <koz_> tzlil: Which operators?
12:58:28 <tzlil> +, $, ==
12:58:32 <tzlil> etc. etc.
12:58:33 <koz_> gentauro: I have no idea what our questioner is trying to achieve.
12:58:44 <gentauro> koz_: me neither
12:58:47 <koz_> tzlil: import Prelude ((+), ($), (==), ...)
12:58:53 <gentauro> I guess no IO but also nothing else
12:58:53 <gentauro> :|
12:58:55 <tzlil> > ive challenged myself to implement some functions that haskell provides (zip, length, elem, etc.)
12:58:58 <lambdabot>  error:
12:58:58 <lambdabot>      A section must be enclosed in parentheses thus: (etc .)
12:59:12 <geekosaur> I would import hiding just those, then
12:59:13 <gentauro> tzlil: fair enough
12:59:44 <tzlil> yes i should probably just hide the ones i implement
12:59:44 <gentauro> i have seen blog post where people do the same and implement the `IO` type :)
13:00:00 <gentauro> so it's all good
13:00:12 <aplainzetakind> tzlil: Start with NoImplicitPrelude, then import Prelude, then whenever you get a clash, add it to the hiding () list.
13:03:40 <boxscape> aplainzetakind I don't think NoImplicitPrelude even makes a difference when you do that
13:03:51 <boxscape> % import Prelude ()
13:03:51 <yahb> boxscape: 
13:03:54 <boxscape> % :t False
13:03:55 <yahb> boxscape: Bool
13:03:59 <boxscape> hmm
13:04:04 <boxscape> maybe in ghci it does :)
13:04:34 <lyxia> in a file it does, at least
13:05:34 <dolio> I'm not sure there's any point of NoImplicitPrelude unless you're turning it on project-wide and using some other prelude-like module.
13:05:52 <dolio> If you're still putting an `import Prelude ...` line in every file, it isn't doing anything.
13:06:27 <dolio> And if you're putting the pragma in every file, you're not saving typing.
13:07:28 <dolio> I guess the other use is modules in base and such that Prelude depends on, but that's not a normal use case.
13:11:55 <tzlil> whats wrong with this function signature? `zipWith :: (a -> a -> a) [a] [a]`
13:12:14 <tzlil> im getting `Expected kind ‘* -> * -> *’, but ‘a -> a -> a’ has kind ‘*’`
13:12:42 <hpc> you're missing the rest of the arrows
13:12:46 <koz_> tzlil: Because you wanted (a -> a -> a) -> [a] -> [a]
13:12:54 <tzlil> oh, oops
13:12:59 <koz_> Also, this isn't the signature zipWith should have even _if_ you put those arrows in.
13:13:12 <koz_> Because zipWith needs _two_ lists, and gives back one, but you need one list.
13:13:21 <hpc> as for why you are getting the error you are, it's trying to apply (a -> a -> a) to two parameters, the way you might write Either [a] [a]
13:29:45 <gentauro> is it correctly assumed that `LBS.writeFile` is strict? I don't seem to be able to find a strict implemenation of writeFile -> https://hackage.haskell.org/package/strict-0.4.0.1/docs/System-IO-Strict.html#v:readFile
13:30:32 <c_wraith> You should assume every writeFile consumes the entire input when executed.
13:30:38 <c_wraith> If it didn't, it would be buggy
13:31:10 <Kronic> Question here to any of you vimmers out there... when I use w/b to navigate forward and backwards a word it works basically normally but when I attempt to do it inside this lambda: (\a -> read a :: Integer) it seems to just jump all over the place, is there anyway to change this or is this behavior expected?
13:31:16 <gentauro> c_wraith: Roger that
13:31:57 <gentauro> I just recall when I used putStr/puStrLn I had to re-write them so they `flushed`
13:32:27 <c_wraith> Oh, that's a separate idea.  that's about IO buffering
13:32:34 <geekosaur> that's related to buffering, not whole file ops
13:33:02 <c_wraith> When you close a file, as writeFile does, it had better flush the entire buffer.  Or else the IO library is buggy. :)
13:33:15 <gentauro> https://gitlab.com/spisemisu/cleanse-facebook/-/blob/master/src/CleanseFacebook/Eff.hs#L132-137
13:33:47 <gentauro> c_wraith: I'm using https://hackage.haskell.org/package/bytestring so :)
13:33:49 <leifm> Kronic: Works like normal for me
13:34:15 <Kronic> Must be some of my configuration, I just loaded it up without my .vimrc and it seems to be normal, so I'll have to locate the problem
13:34:15 <c_wraith> The difference with putStr is that it doesn't close the stream it's writing to.  So if the terminal is line-buffering and nothing flushes the buffer, the terminal just sits there waiting for more characters.
13:35:21 <gentauro> c_wraith: so it's the same with `interact`?
13:35:49 <c_wraith> it certainly can be.
13:36:06 <Kronic> thanks for testing though leifm ! :) 
13:36:14 <c_wraith> interact is messy to think about here because its use of lazy IO is a weird form of concurrency, and interact makes it especially obvious
13:55:03 <gentauro> c_wraith: I think I'm using `getContents` somewhere in the code in a lazy manner
14:00:56 <gentauro> c_wraith: I guess `getContents >>= \cs -> length cs `seq` pure cs` should do it :)
14:28:58 <gentauro> c_wraith: do you have any experience when using `writeLine` with many files?
14:30:48 <gentauro> I noticed that `readLine` reached easily the too many files open on a Linux (therefore I needed a strict `readFile`). http://woshub.com/too-many-open-files-error-linux/
14:31:34 <gentauro> but I'm afraid if I rely on `async` to handle the many `writeFile` it's going to be the same …
14:31:42 <xsperry> alternatively, you can force evaluation with evaluate (force text)
15:13:23 <ggVGc> great... wondered why my application was using 11gb of memory... LazyBS.writeFile
15:13:25 <ggVGc> :(
15:13:43 <ggVGc> why does lazy IO even exist
15:13:57 <c_wraith> that isn't lazy IO
15:14:16 <c_wraith> when it completes execution, arguments will have been fully evaluated
15:14:30 <c_wraith> (and the return value, for that matter)
15:14:57 <hpc> more precisely, execution of writeFile isn't dependent on another expression being evaluated
15:15:32 <c_wraith> it's possible lazy bytestrings with lots of thunks in them are your problem
15:15:45 <c_wraith> Bute it's not writeFile causing it.
15:16:07 <c_wraith> It's writeFile forcing their evaluation.  Which causes some profiling modes to report it as the primary cost center
15:16:24 <gentauro> 00:13 < ggVGc> great... wondered why my application was using 11gb of memory... LazyBS.writeFile
15:16:43 <gentauro> ggVGc: you are still far away from the 23 GB mem leak of `taffybar` on my laptop :P
15:16:55 <gentauro> (I guess having 64 GB helps with running Haskell stuff)
15:17:14 <gentauro> I even let the mem leak stay there for a few weeks just because I could xD
15:20:45 <gentauro> c_wraith: so the best way to handle ByteString should be doing a `LBS.ByteString` -> `BS.ByteString` and then call `writeFile`?
15:20:56 <c_wraith> that's not going to fix anything
15:21:15 <c_wraith> It's just going to change where the massive thunk buildup is evaluated
15:21:22 <c_wraith> The fix is to not build up thunks
15:21:28 <dolio> It's a good thing lazy IO exists, or all the people who use it as a scapegoat for their real problems might have to figure out what's actuall wrong.
15:25:14 <ggVGc> c_wraith: hm, yeah, I thought it was weird... And it's possible changing it also had some other effect. But I did get my memory usage down to a stable level
15:25:20 <ggVGc> hence I have now stopped investigating
15:26:07 <ggVGc> I guess I did move some other things around that might have affected laziness when changing things to try to pinpoint what was happening
15:26:11 <Welkin> user count dropped since I was last on here 6-9 months ago
16:00:32 <boxscape> :t \f -> fmap join . traverse f
16:00:37 <lambdabot> (Monad m, Traversable m, Applicative f) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
16:00:43 <boxscape> is there a better function for this?
16:01:40 <hpc> :t (fmap join .)
16:01:41 <lambdabot> (Monad m, Functor f) => (a1 -> f (m (m a2))) -> a1 -> f (m a2)
16:02:53 <hpc> if you're looking for something predefined, probably not?
16:02:59 <boxscape> hm, okay
16:06:49 <nowhere_man> Hi everyone
16:07:25 <nowhere_man> I'm writing a bot for a Codingame challenge, and I want to write a function whose type should be recursive IIUC
16:07:44 <nowhere_man> I'm having a hard time understanding how to use Fix for that
16:08:38 <nowhere_man> I want a function with type akin to: type Strategy = State -> (Order, Strategy)
16:09:30 <hpc> so, at the value level, imagine you have something like
16:09:35 <hpc> ones = 1 : ones
16:09:49 <hpc> to turn that into something using fix, you turn it into a function
16:09:54 <hpc> ones x = 1 : x
16:09:59 <hpc> or just (1 :)
16:10:01 <hpc> and then fix that
16:10:04 <hpc> > fix (1 :)
16:10:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:10:12 <boxscape> does it have to be Fix as opposed to something like newtype Strategy = Strategy (State -> (Order, Strategy))?
16:10:17 <hpc> do the same thing at the type level with your type, and then Fix it
16:11:01 <hpc> you might not necessarily need Fix for this though, yeah
16:13:28 <nowhere_man> I tried this :
16:13:29 <nowhere_man> data Fix f = Fix (f (Fix f))
16:13:34 <nowhere_man> type Strategy a = Int -> (Bool, a)
16:13:38 <nowhere_man> type ActualStrategy = Fix Strategy
16:13:42 <nowhere_man> but I get:
16:13:51 <nowhere_man> The type synonym ‘Strategy’ should have 1 argument, but has been given none
16:16:27 <hpc> type synonyms need to be fully applied
16:16:31 <hpc> use a newtype instead
16:18:05 <nowhere_man> newtype Strategy a = Int -> (Bool, a) gets me error: parse error on input ‘->’
16:18:35 <nowhere_man> and newtype ActualStrategy = Fix Strategy gets me Expecting one more argument to ‘Strategy’
16:18:54 <hpc> needs a constructor - newtype Strategy a = Strategy (Int -> (Bool, a))
16:19:04 <hpc> ActualStrategy i think can stay as a type alias here
16:19:26 <hpc> personally, i would avoid using type aliases to learn this stuff
16:19:33 <hpc> it just makes it harder to see what the real types are
16:26:05 <solonarv> you don't need a type alias, and you don't need to explicitly use Fix either
16:26:26 <solonarv> newtype Strategy = Strategy (State -> (Order, Strategy)) -- this works just fine
16:26:31 <nowhere_man> but then, what should be the type of my function?
16:28:20 <nowhere_man> because if I use ActualStrategy with the following definition: strategy num = (odd num, strategy)
16:28:43 <nowhere_man> Couldn't match expected type ‘Fix FixStrategy'’
16:28:44 <nowhere_man>                   with actual type ‘p0 -> p1 -> (MyOrder, FixStrategy)’
16:28:50 <nowhere_man> ha, shit
16:29:44 <nowhere_man> Couldn't match expected type ‘Fix ActualStrategy' with actual type 'p0 -> (Bool, ActualStrategy)'
16:35:40 <solonarv> I would recommend avoiding Fix, it doesn't do anything useful here
16:36:42 <nowhere_man> is there a way to type that function?
16:40:07 <nowhere_man> I have zero emotional attachment to Fix ;-)
16:41:29 <solonarv> I already suggested the right type above
16:41:41 <solonarv> newtype Strategy = Strategy (State -> (Order, Strategy))
16:42:26 <boxscape> to be clear the type of the function in that case is simply `Strategy`
16:42:35 <solonarv> yes
16:54:39 <nowhere_man> okayyyyyy
16:54:45 <nowhere_man> thx solonarv
17:11:03 <boxscape> @src fix
17:11:04 <lambdabot> fix f = let x = f x in x
17:11:27 <boxscape> why is it usually defined in this way rather than fix f = f (fix f)? something about sharing maybe?
17:12:12 <solonarv> boxscape: precisely
17:12:28 <boxscape> how exactly does sharing play into this?
17:13:04 <solonarv> the first form allocates a single thunk, 'x', that refers to itself
17:13:52 <solonarv> the second form first has to be translated into ANF: fix f = let y = fix f in f y
17:15:37 <boxscape> Ah, Isee
17:16:04 <boxscape> thanks
17:16:40 <boxscape> This ANF (administrative normal form?) is something that's required for STG?
17:17:14 <solonarv> STG is always in ANF, so basically yes
17:17:19 <boxscape> okay
18:33:47 <retr0_> hi
19:39:10 <quantumvatican> hello, I just finished today's advent of code using the ReadP parser lib after spending hours initially trying to do the same thing using Parsec. The ReadP parser I generate produces the expected results while its parsec counterpart doesn't.
19:39:39 <quantumvatican> Here is the relevant code snippet: https://framabin.org/p/?1ec64b9a6d97553f#rSZa4gjvzdRyZyWdpy8gFiyttdTsFk/BQol/TPmx8CE=
19:40:20 <quantumvatican> Could you help me understand what is wrong in my parsec alternative?
19:40:35 <glguy> quantumvatican, In parsec, attoparsec, megaparsec   in (a<|>b), if a succeeds then b is discarded
19:42:42 <quantumvatican> Oh ok. I thought backtracking using "try" would do the trick...
19:43:19 <solonarv> nope. Suppose you have a parser that looks like this: (a <|> b) *> c
19:43:42 <solonarv> the input matches b *> c, and a prefix of the input matches a
19:43:55 <solonarv> (but the rest of the input then doesn't match c)
19:44:12 <solonarv> so a is tried, succeeds, and then c is tried, fails; the parse fails
19:44:31 <solonarv> because a succeeded, b is never tried, so "b followed by c" is also never tried
19:47:27 <glguy> quantumvatican, in parsec with (a <|> b) as soon as a consumes some input b is discarded. If a succeeds (consuming input or not) b is discarded. if a fails without consuming any input then b is used
19:47:56 <glguy> try a   hides any input consumed in a in the case that a fails
19:49:05 <c_wraith> breaking distributive rules makes me sad :(
19:49:39 <solonarv> ReadP on the other hand tries *both* sides when you use <|>
19:49:41 <quantumvatican> Ok I see. This is funny because I was initially using ReadP to parse the first aoc inputs and found its symetric choice operator inconvenient because it would generate a list of all possible alternatives. Now I get to see that is has its uses.
19:50:27 <quantumvatican> Thank you very much for the explanation.
19:52:04 <solonarv> iqubic: ping
19:52:17 <iqubic> Hello there.
19:52:33 <solonarv> see messages above :)
19:52:51 <iqubic> So megaparsec won't work for Day 19 part 2?
19:53:19 <boxscape> maybe if you write an algorithm to adjust the rules so they don't need unbiased choice...
19:53:33 <glguy> You can use parsec, attoparsec, megaparsec in Day19, yes, but you have to account for how <|> works
19:53:59 <iqubic> How does <|> work for megaparsec?
19:54:36 <iqubic> Because I tried that for my input and got an answer that was about 50 lower than the correct answer given by ReadP.
19:54:38 <boxscape> <glguy> in parsec with (a <|> b) as soon as a consumes some input b is discarded. If a succeeds (consuming input or not) b is discarded. if a fails without consuming any input then b is used
19:55:34 <iqubic> Right. Is there a way to make that unbiased with try or something?
19:55:42 <solonarv> try doesn't help
19:55:47 <iqubic> Why not?
19:55:59 <solonarv> try makes a parser not consume input if it fails
19:56:14 <solonarv> but if the parser succeeds, try doesn't do anything
19:56:29 <iqubic> And how is that bad?
19:56:30 <glguy> I mean... it wastes some memory in that case :)
19:56:35 <solonarv> so in both (a <|> b) and (try a <|> b), if a succeeds, b is never tried
19:56:58 <solonarv> which means if you have (a <|> b) *> c, and a succeeds, only a *> c is tried; b *> c isn't tried
19:57:56 <glguy> So to solve #19 with megaparsec, you just make sure never to generate: (a <|> b) *> c
19:58:11 <glguy> you generate: (a *> c) <|> (b *> c)
19:58:18 <glguy> (+ try)
19:58:22 <iqubic> Right. And that means solving Day 19 with megaparsec is hard.
19:58:45 <glguy> Codensity makes it easy to rewrite your parser like that
19:59:05 <iqubic> I don't know what codensity is.
19:59:31 <solonarv> newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
19:59:43 <solonarv> it's a better-behaved cousin of ContT
20:00:06 <iqubic> Right.
20:00:08 <solonarv> @hackage kan-extensions/docs/Control-Monad-Codensity.html
20:00:08 <lambdabot> https://hackage.haskell.org/package/kan-extensions/docs/Control-Monad-Codensity.html
20:02:25 <iqubic> glguy: Why did you use ReadP over parsec?
20:03:35 <solonarv> the same reason I did, presumably: it doesn't have the above issue
20:03:54 <glguy> Yeah, it tries all parses in parallel which seemed good for a grammar that I had no control over
20:04:12 <glguy> using parsec/megaparsec/attoparsec requires you to put in a lot of thought in how you structure your parser
20:04:17 <solonarv> in ReadP, (a <|> b) *> c *equals* (a *> c) <|> (b *> c) -- up to performance and internal-representation quibbles, perhaps
20:04:43 <solonarv> so you don't need to worry about making sure you generate the second one
20:08:33 <iqubic> glguy: What kind of structure does your solution produce?
20:08:54 <glguy> What do you mean?
20:10:52 <iqubic> I mean, if you were to convert your solution from ReadP to Parsec by changing the type signatures, and changing "R.String s" to the parsec version, would it work properly?
20:11:32 <glguy> I'd have to do the thing we were just talking about to make it work with megaparsec
20:12:21 <iqubic> How hard would that be?
20:14:13 <glguy> easy if you know what change to make I suppose
20:15:42 <iqubic> I don't know what change to make.
20:18:21 <zzz> is there any way to have lookups in constant time with a purely functional data structure?
20:19:15 <iqubic> I think HashMaps have constant time lookup.
20:19:20 <dsal> solonarv, glguy: thanks for the explanation.  I just got out of the shower and it the shower didn't answer this question.
20:20:21 <koz_> dsal: The All-Mighty Shower Oracle.
20:20:31 <koz_> Soak for 10 years, solve P vs NP. 
20:20:45 <solonarv> iqubic: no, it's just log-time with a big base
20:20:53 <iqubic> Right.
20:21:17 <solonarv> which is close enough to constant-time in practrice
20:21:53 <koz_> It's like, base-size-of-word-on-machine I believe>
20:21:54 <jle`> 💤 constant-time lookups, we have vector
20:21:57 <koz_> So like, 64.
20:21:58 <jle`> * zzz
20:22:15 <koz_> Since HashMap is based on a HAMT IIRC.
20:23:14 <zzz> vector is log n according to hackage
20:23:35 <jle`>  zzz: https://hackage.haskell.org/package/vector-0.12.1.2/docs/Data-Vector.html#v:-33-
20:23:37 <jle`> O(1) it says
20:23:46 <solonarv> in some sense log-n lookups are the best you can get because of how hardware works
20:23:59 <dsal> In some OSes, you can just allocate a single array and just let the OS deal with it.
20:24:11 <zzz> wait
20:24:26 <solonarv> (or even worse, O(n^1/3))
20:24:51 <jle`> log(n) isn't too bad either in many cases since it caps out at log(word size)
20:25:05 <boxscape> Vector can only have O(1) lookup because array is built into ghc, right?
20:25:20 <solonarv> yes
20:25:33 <jle`> doesn't have to necessarily be built-in
20:25:40 <jle`> it could be implemented with FFI
20:25:43 <solonarv> true, C FFI would also do it
20:25:44 <boxscape> okay, fair
20:26:00 <solonarv> constant factors might be a bit big though
21:00:22 * hackage language-c 0.9.0.1 - Analysis and generation of C code  https://hackage.haskell.org/package/language-c-0.9.0.1 (jophish)
21:00:58 <jophish> every time that notification happens I get all excited thinking that someone is messaging me, but it's just the bot :(
21:03:51 <warperwarpwarp> can anyone recommend a solid http request-parsing response-writing library? I'll have byte streams to read from and write to.
21:04:15 <warperwarpwarp> my needs are extraordinarily few
21:04:54 <jophish> I tend to reach to servant for that kind of thing
21:09:22 <warperwarpwarp> Ok, I'll look into that. What else I was considering was just parsing myself since I only need CONNECT and no bodies, and also somehow taking the Socket back from Warp when I recognize the right method.
21:09:52 <warperwarpwarp> Though Warp it's not obvious to me how I'd correlate requests to client, and client to socket, except doing it myself around Warp, at which point why use warp.
21:37:18 <ADG1089> how do we solve this "warning: haddock-html" problem on ghc-pkg check? I tried cabal update after removing .cabal directory
21:55:40 * Lycurgus generally ignores warnings
22:10:56 <ADG1089_> pointfree does not install with ghc-8.10.2
22:11:03 <ADG1089_> should i switch to lts release?
22:11:06 <ADG1089_> (cabal)
22:18:53 <koz_> ADG1089_: What does cabal have to do with this?
22:19:04 <koz_> If pointfree doesn't build with 8.10.2, try building with 8.8.4.
22:22:23 <ADG1089> koz_: something like `cabal install pointfree --resolver ghc-8.8.4`?
22:22:33 <koz_> --resolver is a stack thing.
22:22:36 <koz_> Are you using stack?
22:22:59 <ADG1089> no i thought if cabal has some similar option
22:23:12 <ADG1089> i think i will have to switch ghc from ghcup
22:23:24 <koz_> ADG1089: If you have GHC installed from ghcup, you can do
22:23:34 <koz_> cabal install -w ghc-8.8.4 pointfree
22:23:50 <koz_> Assuming you have ghc-8.8.4 installed and your path is set up properly for ghcup.
22:25:00 <ADG1089> wait i installed ghc from pacman for xmonad, will that interfere
22:25:27 <koz_> If you use -w like I did, it shouldn't.
22:25:37 <koz_> I am unsure how Arch names its GHC, because I don't use it.
22:25:39 <ADG1089> koz_: thanks
22:25:41 <koz_> (Arch's GHC that is)
22:33:32 <ADG1089> is there a traverse operation for this: `\x -> f y1 x >> f y2 x >> f y3 x >> ... >> f yn x` maybe traverse_ or mapM_
22:41:56 <iqubic> traverse_ (flip f) xs is what you want.
22:43:00 <iqubic> Well, actually you want "traverse_ (flip f x) xs"
22:43:16 <ADG1089> @t traverse_ (flip f)
22:43:17 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:43:43 <Rembane> ADG1089: Try :t instead. 
22:43:51 <Rembane> :t traverse_ (flip f)
22:43:52 <ADG1089> :t traverse_ (flip f x)
22:43:52 <lambdabot> error:
22:43:52 <lambdabot>     • Could not deduce (FromExpr b0) arising from a use of ‘f’
22:43:52 <lambdabot>       from the context: (Foldable t, Show a, Show b)
22:43:53 <lambdabot> (Foldable t, Applicative f, Show a, FromExpr (f b)) => t a -> f ()
22:43:56 <Rembane> :D
22:44:05 <ADG1089> :t let f :: a -> b -> m c in traverse_ (flip f x)
22:44:06 <lambdabot> error:
22:44:06 <lambdabot>     The type signature for ‘f’ lacks an accompanying binding
22:44:23 <ADG1089> :t traverse_ (flip hPutStrLn x)
22:44:25 <lambdabot> error:
22:44:25 <lambdabot>     • Variable not in scope: hPutStrLn :: a -> Expr -> f b0
22:44:25 <lambdabot>     • Perhaps you meant one of these:
22:44:30 <ADG1089> zzz
22:45:34 <Rembane> :t \f -> traverse_ (flip f) -- ADG1089 
22:45:36 <lambdabot> Foldable t => (a -> b1 -> b2) -> t b1 -> a -> ()
22:48:10 <ADG1089> :t \x -> \ys -> \f -> traverse_ f ys x
22:48:12 <lambdabot> Foldable t1 => t2 -> t1 a -> (a -> t2 -> b) -> ()
22:48:33 <ADG1089> Rembane: thanks!
22:48:52 <Rembane> ADG1089: np! 
23:06:18 <whataday> parse "let x = 1; let y=2; print (x+y)" , how to store x and y? IORef?
23:09:18 <Rembane> whataday: give us more context. What do you want to do? 
23:09:43 <whataday> a very simple dsl
23:11:11 <sshine> could you be more specific?
23:11:43 <Rembane> I'm gonna do some guessing... having a map between variable names and values sounds like what you need, you can send that around as an argument to your functions or put everything in a State monad. 
23:12:16 <sshine> whataday, are you building a parser and evaluator of a DSL like the one above?
23:13:06 <whataday> parse "let a=b" to Value a b, parse "a b " to Function a b, data DSL = Value a b| Function a b
23:13:16 <whataday> sshine yes
23:14:49 <sshine> I'd go with a State monad, too. or if you like something simpler, something like:    eval :: YourAST -> Map VarName Value -> IO ()
23:18:06 <sshine> that way 'eval' can call itself and every time it sees a "let x = 1;" it can update its variable table, and every time it sees an "x", it kan look it up.
23:19:07 <zzz> i remember watching a talk on youtube about probably monads with an elegant example of parenthesis matching. does anyone has an idea of which one it could be? this was years ago
23:20:13 <Rembane> zzz: Do you have any more information about the talk? :)
23:23:24 <zzz> unfortunately no. aside from the fact that it was a male presenter and that the solution to checking for balanced parens used a class and some type level trick... i think i remember seeing <>
23:23:59 <zzz> this was years ago when i was still trying to understand what a monad was
23:24:17 <sshine> zzz, was it a tutorial? a tech talk?
23:24:27 <zzz> tech talk i think
23:24:58 <zzz> white slides, actually i think it had some live coding
23:25:00 <zzz> not sure...
23:25:27 <sshine> > "Stardate " <> show (12 * 365) <> ".6: I'm still trying to find out what a Monad is."
23:25:30 <lambdabot>  "Stardate 4380.6: I'm still trying to find out what a Monad is."
23:26:31 <zzz> :p
23:26:42 <sshine> zzz, good luck finding it. :)
23:26:56 <zzz> thanks
23:26:58 <sshine> if I see a guy with parentheses on some white slides, I'll let you know. ;-D
23:27:18 <zzz> sshine: a monad is just a monoid in the category of endofunctors
23:27:24 <zzz> what's the problem?
23:28:11 <Rembane> ^^
23:28:16 <sshine> (this isn't it, but I thought it was funny to mention it here: Perry Metzger - Emacs: The Editor for the Next Forty Years - https://www.youtube.com/watch?v=KYcY7CcS7nc -- it qualifies for all your criteria, and considering the subject of elisp, I'd say *very* parentheses-related!)
23:41:07 <int-e> @quote endofunctors.*bad
23:41:07 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
23:43:00 <koz_> Something something burritos, something something monads, something something turtles, something something all the way down.
23:45:30 <Rembane> And they all leak! 
23:45:40 <Rembane> Especially burritos if stuffed with good stuff
23:46:45 <koz_> The law of leaky burritos.
