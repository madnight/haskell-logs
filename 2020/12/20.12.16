00:10:10 <guest1216> how you pronounce "<>"?
00:10:32 <guest1216> there're so many symbols, I don't know their name by English
00:10:53 <opqdonut> I think it tries to be "diamond" (from math notation), but I pronounce it mappend (since that's the old name for it :)
00:10:59 <guest1216> like <*>, someone call it ap, or apply
00:11:22 <opqdonut> yeah because that's the old name for it :)
00:11:30 <opqdonut> :t ap
00:11:32 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:11:33 <opqdonut> :t <*>
00:11:35 <lambdabot> error: parse error on input ‘<*>’
00:11:40 <opqdonut> :t (<*>)
00:11:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:11:44 <opqdonut> (from before Applicative)
00:12:11 <guest1216> but that ap is on monad...
00:12:20 <guest1216> type restri...
00:12:42 <guest1216> restricted
00:17:59 <guest1216> https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#%3C%2A%2A%3E
00:18:11 <guest1216> (<**>) = liftA2 (\a f -> f a)
00:18:34 <guest1216> > :t (<**>)
00:18:38 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input ‘:’
00:18:55 <iqubic> That's not what <**> does.
00:19:06 <iqubic> @src (<**>)
00:19:06 <lambdabot> (<**>) = liftA2 (flip ($))
00:19:34 <guest1216> but I saw flip (<*>) has the same type signature with <**>
00:19:51 <guest1216> why not define <**> = flip <*>
00:20:01 <iqubic> Not sure, but that's not what it does.
00:20:38 <guest1216> (<**>) :: Applicative f => f a -> f (a -> b) -> f b
00:20:50 <guest1216> flip (<*>) :: Applicative f => f a -> f (a -> b) -> f b
00:22:01 <guest1216> in this link https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#%3C%2A%2A%3E ,  (<**>) = liftA2 (\a f -> f a),   -- Don't use $ here, see the note at the top of the page
00:22:47 <guest1216> iqubic: so where this (<**>) = liftA2 (flip ($)) come from?
00:22:53 <iqubic> IDK.
00:23:00 <guest1216> ...
00:23:20 <c_wraith> Interestingly, that note will no longer be accurate in the future.
00:23:34 <c_wraith> GHC is adding support for making ($)'s type non-magical
00:24:04 <guest1216> c_wraith: what is non-magical?
00:24:18 <guest1216> or what is $'s magical
00:24:36 <c_wraith> $ has a typing hack to allow impredicative instantiation of its tyvars
00:25:16 <c_wraith> But the ImpredicativeTypes extension is getting reworked to actually allow GHC to express and use that type without having special hacks
00:26:14 <guest1216> c_wraith: does <**> == flip <*>?
00:26:22 <c_wraith> no
00:26:34 <guest1216> ok
00:27:28 <idnar> guest1216: the "side effects" are sequenced differently to flip (<*>)
00:28:29 <idnar> guest1216: https://pb.codehash.net/e56814fbe97b42fa98190172239435b2
00:31:21 <c_wraith> > let f = reverse <$ modify (+1) ; a = "hello" <$ modify (*2) in runState (f <*> a) 3
00:31:23 <lambdabot>  ("olleh",8)
00:31:31 <c_wraith> > let f = reverse <$ modify (+1) ; a = "hello" <$ modify (*2) in runState (a <**> f) 3
00:31:34 <lambdabot>  ("olleh",7)
00:34:00 <idnar> x <*>  y = do f <- x; a <- y; pure (f x)
00:34:00 <idnar> x <**> y = do a <- x; f <- y; pure (f x)
00:34:53 <guest1216> idnar: <$ or $> will run the action?
00:36:04 <guest1216> id <$ print "foo" will print foo and get IO (a -> a)?
00:36:46 <idnar> yeah
00:36:48 <idnar> :t id <$ print "foo"
00:36:51 <lambdabot> IO (a -> a)
00:37:33 <guest1216> I'd like to say put an id function into an IO context... but I don't know if it's properly
00:37:45 <idnar> x <$ a = const x <$> a
00:37:52 <guest1216> because IO id is not existed...
00:38:01 <c_wraith> :t pure id 
00:38:03 <lambdabot> Applicative f => f (a -> a)
00:38:33 <guest1216> :t return id
00:38:34 <lambdabot> Monad m => m (a -> a)
00:43:56 <guest1216> idnar: https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#%3C%24
00:44:29 <guest1216> <$ = fmap . const
00:45:18 <guest1216> x <$ a = const x <$> a
00:45:59 <guest1216> I don't understand how this transformed
00:46:45 <guest1216> <$ x = (fmap . const) x
00:47:04 <guest1216> x <$ a = (fmap . const) x a
00:48:16 <joel135> x <$ a
00:48:19 <idnar> \x a -> const x <$> a = \x a -> fmap (const x) a = \x -> fmap (const x) = fmap . const
00:48:20 <joel135> = (fmap . const) x a
00:48:31 <guest1216> (fmap . const) x a == fmap (const x) a?
00:48:48 <joel135> yes
00:49:40 <joel135> x <$ a  =  (fmap . const) x a  =  fmap (const x) a  =  (const x) <$> a
00:52:09 <srk> ezzieyguywuf: how's your cad? :) yesterday I've stumbled on https://wiki.haskell.org/SceneGraph
00:53:28 <guest1216> it's weird to composte on binary functions
00:54:01 <guest1216> I thought there's a function work on binary, like >=> ?
00:54:44 <guest1216> and (sort .) . (<>) 
00:54:53 <guest1216> weired (.) usage
00:56:05 <joel135> :t (.).(.).(.)
00:56:06 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
00:56:38 <guest1216> wait a sec, is . fmap?
00:56:56 <guest1216> fmap f g == f . g
00:56:59 <guest1216> ?
00:57:04 <joel135> not really
00:57:49 <joel135> but it is related to the hom functor, so yes
00:58:33 <idnar> :t fmap @((->) r)
00:58:35 <lambdabot> error: parse error on input ‘->’
00:58:51 <idnar> % :t fmap @((->) r)
00:58:52 <yahb> idnar: ; <interactive>:1:13: error: Not in scope: type variable `r'
00:59:18 <idnar> % :t fmap @((->) Int)
00:59:18 <yahb> idnar: (a -> b) -> (Int -> a) -> Int -> b
00:59:38 <joel135> :t fmap :: (b -> c) -> (a -> b) -> (a -> c)
00:59:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:00:38 <guest1216> "<joel135> :t (.).(.).(.)" Total Recall 1990?
01:00:58 <joel135> > ((\x -> x^2) <$> (\x -> x + 1)) 5
01:01:02 <lambdabot>  36
01:01:22 <joel135> i just entered something random and observed what happened
01:04:07 <zzz> where can i learn the differences between the various hashmap implementations? i'm kind of getting lost on hackage
01:05:16 <joel135> :t pure :: a -> b -> a
01:05:18 <lambdabot> a -> b -> a
01:10:03 <idnar> zzz: unordered-containers is almost certainly what you want; as for Lazy vs Strict, it depends on how you consume it
01:10:50 <idnar> but probably Strict when in doubt
01:13:13 <guest1216> this pure looks like const!
01:13:23 <guest1216> :t const
01:13:25 <lambdabot> a -> b -> a
01:14:31 <dminuoso> guest1216: Indeed it is.
01:14:53 <dminuoso> guest1216: The rationale is, under the reader effect a "pure value" is one that doesn't depend on the environmnet. :p
01:16:29 <z0_> :t pure const
01:16:31 <lambdabot> Applicative f => f (a -> b -> a)
01:17:05 <dminuoso> Similar to how under the state environment a pure value is one that neither depends on state nor modifies it.
01:17:11 <dminuoso> *under the state effect
01:18:13 <z0_> :t arr pure
01:18:15 <lambdabot> (Arrow a1, Applicative f) => a1 a2 (f a2)
01:21:17 <guest1216> pe :: Parser String
01:21:38 <guest1216> pe = {do; string "server="; x <- many1 $ noneOf ""; return x}
01:21:59 <guest1216> I don't understand why it's many1 $ noneOf?
01:22:21 <guest1216> why there's a simple id function that can return the rest matched ?
01:22:43 <guest1216> parse pe "" "server=abc" == Right "abc"
01:23:26 <guest1216> like pe = { do; string "server="; x <- id; return x}
01:23:53 <guest1216> this pattern matching in do-notation, is really weird to make sence
01:24:51 <dminuoso> 10:21:16      guest1216 | pe = {do; string "server="; x <- many1 $ noneOf ""; return x}
01:24:53 <dminuoso> This is better written as
01:25:47 <dminuoso> string "server=" >> anyChar
01:26:05 <dminuoso> First, the do-notation is not useful. Second, `x <- foo; return x` is the same as `foo`
01:26:22 <dminuoso> Or, `string "server=" >> many1 anyChar
01:26:36 <dminuoso> `noneOf ""` is a really quicky way of saying anyChar
01:28:05 <guest1216> dminuoso: many1 is same to many here?
01:28:31 <guest1216> many in Applicative, and parser is an instance of it
01:30:35 <guest1216> dminuoso: string "server=" >>= anyChar compilation failed...
01:32:02 <guest1216> it missing something in the do-notation of Parser String, like Reader
01:32:47 <guest1216> you don't need to point the parameter to the function in the do notation
01:34:47 <joel135> what do you import to get Parser?
01:36:38 <guest1216> import Text.Parsec Text.Parsec.String Text.Parsec.Char Text.Parsec.Combinator
01:36:46 <joel135> ok
01:36:52 <guest1216> I don't know why they're not in one module...
01:38:37 <guest1216> :i Parser
01:40:50 <guest1216> joel135: it seems Parser is defined in Text.Parsec.String
01:41:09 <joel135> import Text.ParserCombinators.Parsec works too
01:41:14 <guest1216> I didn't find it in Text.Parsec neither Text.Parsec.Combinator
01:42:17 <joel135> string "server=" >> anyChar works
01:42:50 <guest1216> joel135: https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-ParserCombinators-Parsec.html
01:43:14 <guest1216> there's no type constructor Parser defined there
01:43:37 <guest1216> Parser is defined with ParserT IIRC
01:44:13 <guest1216> oh, my fault
01:44:35 <guest1216> I thougt it was string "server=" >>= anyChar...
01:48:51 <guest1216> parse (string "server=" >> (many1 $ anyChar)) "" "server=abc"  ==  Right "abc"
01:51:15 <joel135> yes
01:52:11 <guest1216> joel135: is there any other way to do this?
01:52:26 <guest1216> with parser function
01:52:35 <joel135> no idea, i don't know any practical haskell
01:58:01 <guest1216> https://hackage.haskell.org/package/parsec-3.1.14.0/docs/src/Text.Parsec.Prim.html#ParsecT
01:58:54 <guest1216> the ParsecT definition is really complex
02:01:54 <dminuoso> guest1216: It's just a continuation implementation, nothing fancy.
02:02:29 <dminuoso> You can read this as "A parser can be successful and consume stuff (it then uses the first continuation)"
02:02:44 <dminuoso> Or it "can be unsuccessful and have consumed stuff (it then uses the next continuation)"
02:02:46 <guest1216> dminuoso: continuation itself is complex
02:03:01 <dminuoso> It can be hairy to write, but there's not much about them.
02:03:01 <guest1216> and that a bunch of stuff on continuation
02:03:13 <dminuoso> It shouldnt matter to you, as its just an implemnetation detail
02:03:22 <dminuoso> You will never interact with that
02:04:23 <guest1216> continuation passing style, double CPS, callCC, ContT, yoneda lemma, Pierce's law, blablablah
02:04:35 <guest1216> they're all connected
02:39:42 <siraben> Is there a small implementation Parsec for learning how it works?
02:41:07 <siraben> The Parsec paper doesn't have the same s u m a implementation
02:41:24 <srk> siraben: http://dev.stephendiehl.com/fun/002_parsers.html can be helpful
02:41:41 <siraben> srk: thanks
02:45:22 <siraben> I wish he completed that tutorial, would have been enlightening, the best from scratch implementation of a mini Haskell I've seen is https://crypto.stanford.edu/~blynn/compiler/
02:49:55 <xerox_> is there a way to pattern match a singleton Data.Set.Set directly?
02:50:18 <siraben> xerox_: you could use ViewPatterns
02:50:35 <siraben> foo (S.elems -> [x]) = x
02:50:37 <xerox_> but I'd need the author to have given me one right? I couldn't find one in the docs
02:50:44 <xerox_> ah no you mean something else
02:51:19 <xerox_> right, I mean I wonder if they defined one of those things that you can pattern match on and it does the right thing using the internal structure
02:51:23 * siraben sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/odsnDYgqSkCJutHETFHHASyK/message.txt >
02:51:28 <siraben> this example compiles
02:51:43 <siraben> ah using the internal structure, I'm not aware
02:51:50 <xerox_> I think Sequence does it?
02:52:06 <xerox_> maybe it doesn't
02:52:22 <siraben> Yeah I was thinking about how sequence does it, checking the docs
02:52:41 <xerox_> I'm thinking of these https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=pattern#extension-PatternSynonyms
02:52:47 <siraben> xerox_: they use pattern synonyms + viewpatterns
02:52:51 <siraben> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers-0.6.2.1/src/Data-Sequence-Internal.html#%7C%3E
02:52:55 <siraben> pattern (:<|) :: a -> Seq a -> Seq a
02:53:10 <merijn> xerox_: You can just have a guard on "S.size == 1"? :p
02:53:34 <xerox_> oh now I remember, there's something like overloaded strings but for [] ?
02:54:11 <xerox_> there we go https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=overloaded%20lists#extension-OverloadedLists
02:54:53 <merijn> xerox_: That doesn't help you
02:54:59 <xerox_> drats!
02:55:26 <xerox_> I thought it did since it desugars with toList and I want to match [x]
02:55:42 <siraben> xerox_: you have to use viewpatterns at least or pattern synonyms if you want to make it prettier
02:56:22 <siraben> reminds me of code I wrote for today's AoC problem
02:56:23 <siraben> (head $ IS.elems $ sols IS.\ solset, (l', sols))
02:56:24 <siraben> lol
02:56:52 <merijn> siraben: IS.minView is both shorter and safer then "head $ IS.elems" :p
02:57:02 <xerox_> yeah it works!
02:57:20 <siraben> merijn: nice!
02:57:29 <xerox_> I had: sieve ((val,[name]):rest) = (val,name) : sieve [ (v,delete name names) | (v,names) <- rest ]
02:57:49 <xerox_> now I can change to S.delete and with OverloadedLists [name] matches the singleton set!
03:06:02 <unclechu> hey, can i see a list of dependency versions that `cabal` uses to build a package?
03:06:40 <tomsmeding> unclechu: `cabal freeze`, then look in cabal.project.freeze ?
03:06:47 <unclechu> it seems `cabal exec -- ghc-pkg list` does show the versions it’s going to use for a build
03:06:54 <unclechu> tomsmeding: i’ll try, thanks
03:07:30 <tomsmeding> (though note that that freeze file will prevent cabal from choosing a different build plan in the future, so remove it if you don't want that)
03:08:08 <__monty__> This also sounds like something cabal-plan might help with.
03:10:09 <unclechu> tomsmeding: yeah, i realize it. it worked for me, thanks!
03:10:31 <unclechu> __monty__: is it a separate application?
03:41:15 <merijn> unclechu: cabal will store the full plan in plan.json, cabal-plan is a separate application to pretty print/format the data in plan.json, yeah
03:41:29 <merijn> unclechu: Also lets you generate graphs, etc.
03:42:20 <unclechu> merijn: interesting, maybe i’ll try it later
04:10:08 <Kronic> When you see a ~ in a type signature, e.g (Token s ~ Char) - what is that and how can I read it ? 
04:10:58 <int-e> it's a contraint that asserts type equality
04:11:47 <Kronic> As in real equality, e.g. some instance of a value which is of type (Token s) is equivalent to an instance of a Char? 
04:12:34 <Kronic> Also, what is the name of it and where can I read more about it ?
04:12:36 <int-e> Token is a type family, presumably.
04:13:03 <int-e> Producing a Token type for a... hmm... stream maybe? And the assertion is that the token type is Char.
04:14:18 <int-e> Look for "equality constraints"
04:15:36 <[exa]> Kronic: one (not-totally-correct but practical) view at that is to look at Token as on a type function. It says "The token type of stream type `s` unifies with Char"
04:16:57 <[exa]> notably, specifying/inferring this constraint in a "reverse" direction may be problematic for the function-ish reasons
04:18:24 <Kronic> Seems like I need to read up on 2 sections of type family related stuff before I can read that, thanks.
04:18:42 <boxscape> Kronic equality constraints themselves don't rely on type families (GADTs use them as well, for example), but yeah, type families are one instance where they're necessary and useful
04:19:33 <boxscape> you could even use them to just write a type in a shorter way, e.g. `f :: t ~ Maybe (Set String) => t -> t` instead of `f :: Maybe (Set String) -> Maybe (Set String)`
04:19:37 <merijn> Well, technically it's a unification constraint, no? :p
04:20:35 <merijn> Kronic: When you see "type family" just read "type level function" :p
04:21:01 <merijn> Kronic: So 'Token' is a type level function that turns 's' (the stream of your parser) into some type
04:21:04 <boxscape> merijn ghc calls them equality constraints
04:21:08 <hpc> merijn: it's a constraint describing equal types, compared to say (Num a) which is a constraint describing class membership
04:21:48 <merijn> boxscape: If there's one thing I learned from dependent types its that the word "equal" is a massive can of worms :p
04:21:56 <boxscape> that is true
04:22:29 <boxscape> actually I misread, ghc calls them "equational constraint"
04:22:30 <merijn> hpc: I know what it *means*, my point was that *equality* and *unification* are subtly different and that, afaik, what it does is checking unification
04:22:36 <boxscape> at least in the context I was looking at
04:23:35 <merijn> Kronic: So basically, what the "(Token s ~ Char) =>" is doing is saying that this parser only works for steams whose tokens are Char (consider something like ByteString where the tokens are bytes, not characters)
04:24:10 <merijn> Kronic: With megaparsec "Token String" and "Token Text" both produce Char as a result
04:25:01 <merijn> [exa]: I would argue that seeing Token as a type function is, in fact, totally correct
04:25:10 <Kronic> it half sounds like to me something in the order of dependent typing but I was under the impression nothing like that was in haskell quite yet
04:25:21 <merijn> Kronic: It's not quite dependent typing
04:25:45 <merijn> Kronic: Type families are "types depending on types" (the result of "Token" depends on its input type)
04:26:19 <merijn> Kronic: Dependent types refers to "types depending on values" (i.e. values whose type is dependent on the actualy value, consider vectors with lengths at the type level)
04:26:32 <boxscape> Kronic also worth noting that you can emulate dependent types in Haskell with something like the singletons library, it's just a pain to use compared to native dependent types
04:29:03 <Kronic> So, the example given on the doc I found was something like this: sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2
04:29:03 <Kronic>  which states that Elem c1 and Elem c2 must be the same
04:31:35 <merijn> Kronic: Right
04:31:38 <Kronic> I'm not quite sure I understand why it is done in that particular way - I would have imagined it to bel ike sumCollects :: (... Elem c2, c1 ~ c2)
04:32:00 <merijn> Kronic: Because what if two *different* Collects types have the same element?
04:32:34 <merijn> Kronic: Consider Strict.Text and Lazy.Tex, these are different types so they are not equal, but the Elem of both is Char
04:33:53 <merijn> Kronic: So we write "Elem c1 ~ Elem c2" because we care about c1 and c2 "containing the same thing", not them being the same
04:35:07 <boxscape> Kronic the Elem c2 in your `sumCollects :: (... Elem c2, c1 ~ c2)` would likely result in a kind error, because `Elem c2` is not a constraint, but a type
04:37:08 <Kronic> Are Collects and Elem made up purely for this example or is there something that I can look at to see what they are ?
04:38:42 <boxscape> I'm not sure what example you're looking at but I can't seem to find a Collects class anywhere
04:38:56 <Kronic> Hm, I guess I'll try to explain my confusion
04:39:23 <Kronic> I can't imagine a container that contains something of type A, where I would need to further specify that the elements are the same 
04:39:47 <Kronic> are of the same type*
04:41:19 <merijn> Kronic: Well, what if I have "Map Int Char" and "Set Char"
04:41:41 <Kronic> Like for example I would read Num a => ... as "anywhere in this signature I see an A it can be treated as a Num" -- I feel like this reading of constraints is tripping me up a little here 
04:41:48 <merijn> Kronic: Both can have "Elem (Map Int Char) = Char" and "Elem (Set Char) = Char"
04:42:13 <boxscape> Kronic to be clear (not sure if this is a point of consfusion)  `Collects c1` doesn't state that something is a collection *of* c1, it states that c1 is a collection of something
04:42:39 <merijn> Kronic: Well, consider Text
04:43:07 <merijn> Kronic: Text "obviously" contains Char values for some sense of contain, but you have no way to talk about that
04:43:40 <merijn> Kronic: With "Set Char" you can argue just write "sumCollects :: c1 a -> c2 a -> c2 a"
04:44:22 <merijn> Kronic: The example with Elem addresses the fact that "Text" isn't a type that matches "c1 a" so it can't be used with "sumCollects :: c1 a -> c2 a -> c2 a"
04:46:44 <ski> dminuoso : "sshine: If we demanded the functions inside Set to be injective, it should satisfy laws, no?" -- how do you mean ?
04:46:46 <Kronic> So I get the idea that the containers are potentially different, and that the elements are always the same, I'm just not sure how to apply that to the signature that is given. Stating that c1 must be a collection and then also stating that it must be an Element doesn't make much sense to me 
04:47:09 <merijn> Kronic: It doesn't stat that it is an element
04:47:27 <ski> yes, `Monad m => Monad (ListT m)' is bad. it should be `CommutativeMonad m => Monad (ListT m)'
04:47:27 <merijn> Kronic: Elem is a type level function, it takes a type and returns a (possibly new) type
04:47:58 <merijn> Kronic: The constraint is saying "the result type for "Elem c1" must be equal to the result type for "Elem c2""
04:48:08 <Kronic> ahh
04:48:24 <Kronic> That makes so much more sense. I find that fairly hard to read
04:48:49 <Kronic> How were you able to discern that Elem is a type level function? Purely because of the ~ ?
04:49:16 <merijn> Kronic: Well, lets rewind to some (slightly more basic) things. Are you familiar with the term "kind"?
04:49:22 <Kronic> Yes
04:49:33 <ski> `Maybe' is also a type-level function
04:49:59 <merijn> ski: iff you consider "Just" a function/constructors a subset of all functions ;)
04:50:04 <ski> yes
04:50:16 <merijn> Kronic: Right, so you know that all values have a type with kind *, right?
04:50:23 <Kronic> Yea
04:50:36 <merijn> Int :: *, Maybe :: * -> *, Maybe Int :: *, etc.
04:50:55 <Kronic> Ah wait I get 
04:51:00 <merijn> Kronic: So (in GHC specifically) constraints (i.e. the thing in front of =>) are considered a special kind
04:51:07 <merijn> Kronic: Called "Constraint"
04:51:14 <merijn> % :k Num
04:51:14 <yahb> merijn: * -> Constraint
04:51:17 <merijn> % :k Functor
04:51:18 <yahb> merijn: (* -> *) -> Constraint
04:51:51 <merijn> Kronic: So typeclass are just type functions that take types and turn them into type with kind Constraint
04:52:17 <merijn> Kronic: ~ is a binary operator that takes two types and returns a Constraint that only hold if both sides are equal
04:52:23 <dminuoso> 13:47:04            ski | yes, `Monad m => Monad (ListT m)' is bad. it should be `CommutativeMonad m => Monad (ListT m)'
04:52:41 <dminuoso> That depends on how you look at things. The ListT implementation is just naive and incorrect for that purpose
04:52:55 <ski> `Maybe' "doesn't compute" in the sense that `Maybe Int' will just be `Maybe Int', "nothing more happens". but `Elem' is a "type family", `Elem MyCollection' could "compute" to e.g. `Int'. `Maybe a' is defined the same way, acts the same, regardless of which type `a' actually is. it's "parametric", in a sense. not so with `Elem a', it can pattern-match on what type `a' it's given, and compute to different 
04:53:01 <ski> type results, depending
04:53:02 <merijn> Kronic: So we know that "Elem c1" is some type (which arguably could be a constraint too...)
04:53:45 <merijn> Kronic: So there's no real indication that "Elem" is a type level function, but practically that also doesn't matter
04:54:22 <Kronic> What you're saying makes a good deal of sense
04:54:28 <merijn> Kronic: We know that if "Elem c1" and "Elem c2" are the same type, then constraint from ~ holds. The fact that Elem is a type function that maps containers to what they hold isn't clear, but also not relevant to what it means
04:54:51 <merijn> Kronic: My assumption that Elem is a type function is simply based on "that's the classical example" ;)
04:54:56 <ski> dminuoso : yea, `m [a]' is not that fine-grained. but even with a more incremental variant, you'd still get different results, depending on association, unless `m' is commutative, right ?
04:55:20 <boxscape> I don't think I've ever seen ~ used on constraints either, but I suppose it is technically possible
04:55:39 <boxscape> % () :: Eq Int ~ Eq Int => ()
04:55:39 <yahb> boxscape: ()
04:55:41 <merijn> Kronic: And you can do funky abusive things like writing a type function that requires a type *not* be something: https://gist.github.com/merijn/6130082
04:55:50 <hpc> :k (~)
04:55:52 <lambdabot> k -> k -> Constraint
04:56:19 <hpc> % () :: Eq Int ~ Num Int => ()
04:56:19 <yahb> hpc: ; <interactive>:22:1: error:; * Couldn't match type `Eq Int' with `Num Int' arising from an expression type signature; * In the expression: () :: Eq Int ~ Num Int => (); In an equation for `it': it = () :: Eq Int ~ Num Int => ()
04:56:29 <hpc> neat
04:56:45 <Kronic> I never really paid much attention to types until now
04:56:51 <Kronic> sorry, kinds, not types
04:57:36 <merijn> Kronic: In reality ~ is a bit messier since it's polykinded (i.e. it works for types of *any* kind, not just *, which is why it also works on types of kind Constraint)
04:57:49 <merijn> % () :: Maybe ~ Maybe => ()
04:57:50 <yahb> merijn: ()
04:57:51 <Kronic> But it does explain a lot, I feel like it'll take a while before I really understand everything here. Going back to sum collects, is it also fair to say that Collect is a type level function, meaning there is a class definition for it for :k * -> * ? 
04:57:55 <merijn> % () :: Maybe ~ Maybe Int => ()
04:57:55 <yahb> merijn: ; <interactive>:24:15: error:; * Expected kind `* -> *', but `Maybe Int' has kind `*'; * In the second argument of `(~)', namely `Maybe Int'; In an expression type signature: Maybe ~ Maybe Int => (); In the expression: () :: Maybe ~ Maybe Int => ()
04:58:17 <merijn> Kronic: Well, logically "Collects :: * -> Constraint"
04:58:25 <Kronic> Ah, yes, that
04:58:30 <hpc> % () :: True ~ True => ()
04:58:30 <yahb> hpc: ()
04:58:32 <merijn> Kronic: Since everything in front of => must be a constraint, but yes
04:58:47 <boxscape> to be clear, Collect is a class, not a type family
04:59:02 <boxscape> s/Collect/Collects
04:59:03 <merijn> boxscape: "it depends"
04:59:14 <merijn> Just is a constructor, but also a function
04:59:39 <merijn> See ski's remark. If you accept "type function" type constructors are just "type functions that happen to also be type constructors"
04:59:48 <Kronic> This all makes sense, thanks guys :) 
04:59:59 <merijn> The same way value constructors can be both constructors and functions
05:00:01 <boxscape> I can see it being argued that "Collects" is a type function but I would say "type family" is specifically things declared with the "type family" syntax
05:00:17 <Kronic> I wasn't even really looking at this I just seen that tilde every time I was using Megaparsec and I wanted to understand it a little
05:00:47 * ski would agree with boxscape here ..
05:00:50 <merijn> Kronic: A lot of this stuff is surprisingly sensible and predictable of you look just 1 level deeper :)
05:01:36 <merijn> Kronic: And you can effectively create "custom constraints" using type functions: https://gist.github.com/merijn/39dc86e345e87276c523
05:01:42 <ski> (.. unless perhaps if someone could show how to simulate classes using type families. how would one get access to the methods (and get uniqueness of instance), without type classes themselves ?)
05:02:25 <merijn> boxscape: There is insufficient context to conclude that Collects *isn't* defined as a type family, though :p
05:02:28 <merijn> boxscape: Checkmate!
05:02:33 <boxscape> that is technically correct
05:02:41 <merijn> The best kind of correct!
05:03:01 <ski> touché :)
05:03:10 <[exa]> ski: save the function as a term to the associated type? :]
05:03:29 <ski> [exa] : but then you lose uniqueness, no ?
05:03:48 <[exa]> anyway, what's the etymology of type _families_? I find type functions and "associated" types quite understandable, and "families" sounds too much container-ish
05:04:34 <merijn> [exa]: Not sure, tbh. The original paper on type families is even called "Fun With Type Functions"
05:05:03 <[exa]> interesting
05:05:33 <ski> i'd guess it comes from the math term "family", where you have an "indexed collection", a bunch of individual things, pointed at by some "names" in an index set/type. as opposed to having a uniform/parametric construction, like power set, that "works the same way", regardless of what the parameter is
05:05:37 <boxscape> https://en.wikipedia.org/wiki/Indexed_family
05:05:48 <[exa]> ski: well, quite likely, and I also see not way to do the inference right
05:05:52 <[exa]> aah this
05:05:58 <[exa]> thanks!
05:06:35 <dminuoso> ski: I think LogicT is correct without a commutative monad?
05:07:18 <ski> hm, i haven't looked in detail at the internals of `LogicT', how it handles the ordering
05:07:45 <dminuoso> newtype LogicT m a = LogicT { unLogicT :: forall r. (a -> m r -> m r) -> m r -> m r }
05:08:17 <ski> (iirc, it has some facility for interleaving)
05:08:24 <dminuoso> Indeed
05:08:42 <ski> @unmtl ContT () (ContT o m) a
05:08:43 <lambdabot> (a -> (() -> m o) -> m o) -> (() -> m o) -> m o
05:10:40 <ski> so, that looks like the usual success and failure, two-storey, continuation story. (btw, note the similarity with naturals / free monoids)
05:16:33 <cnmne[m]> I want to use `Text.ParserCombinators.ReadP` to separate by double newlines and then single newlines. when I use `sepBy any $ string "\n\n"`, `any` has to include a newline, but then I only get one contiguous block of text. how do I `sepBy` double newlines but not single newlines (at first)?
05:32:43 <Kronic> Thanks for the earlier explanation there merijn boxscape and anyone else who chipped in, I feel like that helped in a big way :) 
05:37:19 <ezzieyguywuf> srk: CAD progress has been slow, I've side-tracked to other projects, but it's still in the front of my mind
05:37:32 <ezzieyguywuf> srk: I will check out SceneGraph, I think I may have sen that bfore.
05:39:39 <[exa]> cnmne[m]: if you don't anything much more complicated, why not something like `groupBy (oneIsNull) . lines` ?
05:54:49 <kupi> is this a good name for that function?
05:54:50 <kupi> joinWith f = (>>= (\a -> f a <&> (a,)))
05:57:27 <kuribas> :t \f -> (>>= (\a -> f a <&> (a,)))
05:57:28 <lambdabot> Monad m => (t1 -> m t2) -> m t1 -> m (t1, t2)
05:57:47 <kuribas> liftA2 (,) ?
05:57:56 <kuribas> :t liftA2 (,)
05:57:58 <lambdabot> Applicative f => f a -> f b -> f (a, b)
05:58:39 <zclod> i'm trying to compose a list of list of functions with the applicative instance of the list to have all the combination something like this https://gist.github.com/zclod/cfde3e6e11e15368665ca71bfe9c8de5 but i get a strange instance error
06:00:25 <geekosaur> why do you think a Num (b -> b) instance should exist?
06:01:04 <geekosaur> and it's telling you the reason, you have failed to apply (+) to enough parameters so it's trying to use it as a number
06:02:17 <zclod> yes but i don't understand how to make it work
06:04:17 <kuribas> kupi: looks arrowish...
06:05:16 <kupi> kuribas: I got used to >>> and <<< from arrow
06:05:42 <kuribas> kupi: I never use them, and I find arrow notation confusing.
06:06:11 <kupi> what do you recommend as an alternative to >>>?
06:06:25 <kuribas> I just use lambdas
06:06:29 <solonarv> I also find arrow notation confusing, but I do occasionally use a few combinators from Control.Arrow (mainly &&& and ***, specialized to the usual function arrow)
06:06:30 <kupi> i use that a lot because I find right to left composition confusing most times
06:07:03 <kuribas> or name things in do notation.
06:07:35 <kuribas> sometimes it looks like haskell programmers don't like naming stuff, and arrows are that premise taken to far...
06:07:38 <geekosaur> zclod, I get something saner if I replace [id] with [0]
06:08:09 <kuribas> I use pointfree as long as it's still readable, lambdas and do notation otherwise.
06:08:42 <geekosaur> and lose everything outside the first set of parens. I'm not sure what you're trying to accomplish there, but your types are very wrong for it
06:09:32 <geekosaur> > foldr (<*>) [0] ([[(+1),(+2)], [(+3)], [(+4)]])
06:09:34 <lambdabot>  [8,9]
06:10:43 <xerox_> neat
06:10:47 <zclod> thanks
06:11:11 <geekosaur> using id asserts that the literals 1,2,3,4 must actually have function types, which is wrong (normallly)
06:11:35 <kupi> more general version, but still couldn't came up with a good name
06:11:36 <kupi> joinWith' joiner f = (>>= (\a -> f a <&> joiner a))
06:12:12 <kuribas> :t \joiner f -> (>>= (\a -> f a <&> joiner a))
06:12:13 <lambdabot> Monad m => (t -> a -> b) -> (t -> m a) -> m t -> m b
06:16:03 <zzz> should i use Data.HashTable.ST if I want a fast lookup/insertion map?
06:17:09 <merijn> zzz: Have you already tried and benchmarked regular Map and found it too slow?
06:17:10 <kuribas> zzz: no
06:17:37 <kuribas> Map or HashMap
06:18:35 <merijn> solonarv: Hot take: The operators from Control.Arrow should be specialised to (->) and be put into Data.Tuple so we can all pretend Arrow doesn't exist
06:18:54 <merijn> As a general rule Map is much faster than most people seem to think it is
06:18:59 <kupi> having a name for this would be enough too: \f getB a -> getB a <&> f a
06:19:10 <zzz> merijn: i'm finding vector too slow
06:19:30 <merijn> There's this weird idea that hashmaps are faster than trees
06:20:00 <merijn> zzz: Vectors aren't maps, so I'm confused why Vector and HashMap are candidates for the same operations?
06:21:12 <solonarv> zzz: immutable vectors are very slow if you want to repeatedly update a single entry, because you have to copy the entire vector each time
06:21:32 <zzz> you're right. i used them "the wrong way" just to see if there would be an improvement in performance
06:24:57 <zzz> i'm trying Vector.Unboxed.Mutable
06:34:12 <merijn> zzz: Yeah, but for what?
06:34:50 <merijn> You have asked "which data structure is faster?" but haven't specified what should be fast or what you plan to do with them
06:37:35 <solonarv> the fastest data structure is (): every operation on it it O(1) and maximally lazy!
06:37:37 <solonarv> :p
06:40:33 <kuribas> solonarv: Void is faster
06:41:09 <kuribas> every operation on it is fast, since it has no operations on it :)
06:41:29 <solonarv> heh, even better
06:41:58 <zzz> oh you guys...
06:42:14 <zzz> (i'm doing aoc)
06:43:11 <solonarv> which task?
06:43:58 <boxscape> % id @Void undefined
06:43:58 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err; undefined, called at <interactive>:38:10 in interactive:Ghci12
06:44:06 <boxscape> wonder how fast that was
06:44:12 <zzz> 15p2. i've already done it but i'm using the opportunity to optimize as much as i can, since i'm doing this to learn haskell
06:44:22 <merijn> zzz: I find it hard to believe that data structure is the issue for AOC, most of the problems are super small. But that still doesn't tell me the actual operations it's doing :p
06:44:36 <kuribas> % id @Void (let x = x in x)
06:44:41 <yahb> kuribas: [Timed out]
06:44:51 <boxscape> merijn in day15 the challenge is that the problem is big
06:44:52 <merijn> Ah, I'm not at 15p2 yet anyway, stupid work getting in the way :p
06:45:30 <merijn> boxscape: I haven't done any since day 11 due to work >.>
06:47:54 <solonarv> oh yeah, day 15 does make good use of a fast data structure
06:48:17 <solonarv> I got ~1.5 second time on part 2 using unboxed mutable vector
06:50:34 <merijn> ok, so that at least means that any speed trouble zzz has aren't related to the data structure, but messing something else up :)
06:51:00 <merijn> zzz: It'll probably help to paste your code at https://paste.tomsmeding.com/
06:51:13 <geekosaur> make sure its up
06:51:37 <merijn> zzz: also, just to be sure: You are 1) compiling (not using ghci) and 2) using -O or -O2, yes?
06:54:28 <boxscape> :t liftA2 fmap
06:54:29 <lambdabot> (Applicative f1, Functor f2) => f1 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
06:54:37 <zzz> yes to both
06:54:39 <boxscape> ^ kupi this is the same as \f getB a -> getB a <&> f a
06:54:43 <boxscape> I think
06:54:44 <zzz> sorry for the delay
06:55:57 <zzz> this is my solution using IntMap which I find way too slow https://pastebin.com/zhPnNGFJ
07:00:09 <zzz> the goal is calculating the nth term of a variant of https://oeis.org/A181391 given an arbitrary seed
07:01:36 <merijn> hmm, "(M.fromList &&& last)" seems like it'd be slow since it has to traverse the list twice and keep it alive all that time
07:02:08 <merijn> It's also unnecessary since IntMap has a direct operation for looking up the key with the maximum value
07:02:50 <solonarv> :t \f getB a -> getB a <&> f a
07:02:51 <lambdabot> Functor f => (t -> a -> b) -> (t -> f a) -> t -> f b
07:02:59 <kupi> boxscape: I think not
07:02:59 <solonarv> boxscape: clearly not!
07:03:06 <merijn> zzz: There's a bunch of things that come to mind you can try, but rather than listing 20 tiny things to try, let me "lead a horse to water" instead ;)
07:03:08 <boxscape> hmm
07:03:09 <merijn> @where user-guide
07:03:10 <lambdabot> I know nothing about user-guide.
07:03:11 <zzz> merijn: that list has length 4
07:03:12 <merijn> aww
07:03:21 <kupi> a better signature imho: Functor f => (a -> b -> c) -> (a -> f b) -> a -> f c
07:03:28 <merijn> zzz: Oh
07:03:40 <merijn> zzz: Is this strict or lazy IntMap?
07:03:40 <boxscape> they look the same to me, if you treat (a ->) as a functor
07:03:43 <merijn> Try that first
07:03:49 <merijn> @where userguide
07:03:49 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
07:03:55 <zzz> strict
07:04:13 <merijn> zzz: Otherwise the user guide is pretty great and (among other things) has pretty good intro on how to profile Haskell code
07:04:22 <boxscape> :t liftA2 fmap :: Functor f => (a -> b -> c) -> (a -> f b) -> a -> f c -- kupi
07:04:23 <lambdabot> Functor f => (a -> b -> c) -> (a -> f b) -> a -> f c
07:04:25 <boxscape> works just fine
07:04:31 <merijn> zzz: See also: https://mpickering.github.io/posts/2019-11-07-hs-speedscope.html
07:04:37 <ephemient> oh this problem
07:04:55 <merijn> zzz: Step one to making things fast is: Find out what's actually slow :)
07:05:24 <kupi> boxscape: thanks, I still need to practice with the function functor
07:05:27 <ephemient> I have 5 implementations and it easily gets limited by memory bandwidth. it's just a lot of operations to run
07:06:17 <merijn> ephemient: I'm optimising blind here, because I don't know the actual AOC problem :p
07:07:02 <zzz> should we avoid spoilers?
07:07:57 <boxscape> zzz you can always go to ##adventofcode-spoilers
07:08:04 <boxscape> lots of haskell people there, too
07:08:20 <zzz> hey thanks
07:08:24 <merijn> I mean, you can just post links with spoiler warnings :p
07:08:36 <merijn> If people don't wanna see spoilers, don't click links with spoiler warnings :p
07:08:59 <zzz> sorry about that
07:09:43 <merijn> zzz: I don't worry about spoilers, tbh, but I didn't bother looking up the problem so my comments are just based on looking whatever you wrote now
07:10:04 <merijn> So if what you wrote is flawed in some fundamental way I can't see that :p
07:10:37 <merijn> Anyway, I highly recommend the profiling section of the user guide (or actually, I highly recommend the entire GHC user guide it's fantastic and most people are barely aware it exists)
07:11:55 <whataday> how to filter all spaces with Parsec functions? parse spaces "" "a b c" == Right (), but I was expected Right "abc"
07:13:45 <merijn> whataday: *Why* where you expecting that?
07:14:40 <merijn> whataday: That expressions parses 0 spaces at the start of "a b c" and returns () with "a b c" as unparsed input
07:15:20 <merijn> It is unclear to me why you would expect "spaces" to randomly remove spaces from the middle of a piece of text
07:15:33 <whataday> what's the right way to get what I want?
07:15:37 <ephemient> whataday: (spaces <* eof) will fail if it doesn't consume all input
07:15:43 <whataday> filter all spaces
07:15:59 <ephemient> ... what do you mean by filter
07:16:02 <ephemient> spaces returns ()
07:16:10 <whataday> yes, remove
07:16:22 <whataday> sorry, my English is not good
07:16:24 <ephemient> that's not what parsec does?
07:16:46 <xerox_> concat <$> anyChar `sepBy` spaces ?
07:17:10 <xerox_> probably completely wrong
07:17:16 <ephemient> filter (not . isSpace)
07:17:18 <merijn> xerox_: Correct, but probably not helpful when someone seems to have rather big misunderstandings about what parsec *does* :)
07:19:08 <Kronic> So you can have something like (char 'a') <|> (char 
07:19:22 <Kronic> 'b') to get a parser for the chars a or b
07:19:39 <Kronic> Is there a way to undo this later? 
07:19:55 <merijn> Kronic: Define "undo"?
07:20:21 <Kronic> So my goal is I want anySingle, but I want to subtract say, spaceChar from the set which anySingle matches against 
07:20:49 <ephemient> anySingleBut ' ' ?
07:21:26 <Kronic> Ah, I figured there would be a nice convenience function like that, to be clear though there is no operator that is the inverse of <|> right?
07:22:44 <sm[m]> satisfy (not.isSpace)
07:23:07 <ephemient> still not sure  what you mean by inverse of <|> though
07:23:24 <merijn> Kronic: "inverse of <|>" makes no real sense?
07:23:43 <merijn> oh!
07:23:46 <Kronic> What I meant was what sm[m] said
07:23:46 <merijn> I see what you mean
07:23:49 <Kronic> I explained it very poorly though 
07:24:15 <merijn> Kronic: A more general version would be "p >>= \v -> guard (predicate v)"
07:24:16 <merijn> :t guard
07:24:18 <lambdabot> Alternative f => Bool -> f ()
07:24:27 <merijn> > guard True :: Maybe ()
07:24:29 <lambdabot>  Just ()
07:24:33 <merijn> > guard False :: Maybe ()
07:24:36 <lambdabot>  Nothing
07:25:03 <merijn> Kronic: Basically "guard False" is equivalent to empty (which is the right and left identity for <|>)
07:25:56 <merijn> (since your *real* question appears to be, "how can I make a parser fail after it succesfully parses some input?")
07:26:37 <merijn> Which would be guard/empty (or, better, one of the special combinators in megaparsec that let you specify an actual error message :p)
07:27:26 <Kronic> My question is more: If I have a parser in hand which matches against any character in the string "abc", how can create a new parser that matches against just the members of "bc"
07:27:57 <ephemient> oh, with that understanding. I think `notFollowedBy` might be what you're looking for
07:28:23 <ephemient> notFollowedBy (char 'a') *> oneOf "abc"
07:28:30 <ephemient> seems like a backwards way of doing it though...
07:31:16 <whataday> parse (anyChar sepBy spaces) "" " a = b" == Right "a=b"
07:31:25 <whataday> it removes all spaces
07:32:09 <merijn> Kronic: In general "you don't"
07:33:00 <Kronic> Seems like it would be a useful thing if you had a possible set of things to parse against but then you had an optional list to filter out, that's at least my thinking 
07:33:14 <merijn> Kronic: That's not how parser combinators work. Effectively parser combinators are just a convenience library for writing recursive descent parsers.
07:33:29 <ephemient> whataday: as written, the space is included
07:33:46 <merijn> Kronic: tbh, I find it difficult to think of a situation where that'd be easier than just "writing the parser you *actually* want"
07:34:14 <whataday> sorry, I don't understand what you mean, please rephrase it
07:35:29 <merijn> Kronic: I mean, you rarely ever deal with parser that return strings, so the entire notion of "optionally filtering something out" becomes entirely weird
07:35:59 <merijn> Kronic: Like, if I have "Parser Expr" which parses an expression, what would it even mean to "optional filter out a list of expressions"?
07:36:17 <ephemient> parse (anyChar sepBy spaces) "" " " == Right " "
07:47:57 <whataday> parse ((many $ char ' ') *> (anyChar 'sepBy' spaces)) "" " a= b" ?
07:50:13 <ephemient> you might as well use (space *> many (anyChar <* space))
07:56:32 <whataday> but that would not handle " a = b "
07:57:42 <ephemient> why wouldn't it, space matches any number of space characters
07:57:45 <merijn> I recommend you figure out what exactly the grammar of what you're parsing is
07:58:03 <whataday> spaces matches
07:58:59 <merijn> This seems to be parser writing by writing out random permutations of parsec combinators, that's not going to go anywhere
08:00:02 <whataday> I'm trying to read from a config file, and turn its context to a record syntax
08:00:42 <whataday> it's simple like "name=john, age=29..."
08:01:18 <whataday> data Config = Config {runName :: String, runAge :: Int}
08:01:53 <whataday> but in the config file, it may be " name= john"
08:02:26 <merijn> The AOC format is rather tricky to parse properly, while also being simple enough that parsing it properly isn't really worth it, tbh
08:02:42 <whataday> "name = john" or "name=john " whatever, so first I need to remove spaces
08:03:07 <ephemient> that seems like the wrong solution, it isn't clear that you want to remove spaces inside of the names as well
08:03:15 <whataday> what is AOC format
08:03:51 <whataday> AOC monitor? congresswoman AOC?
08:04:25 <ephemient> Text.Megaparsec.Char.Lexer follows the convention that each lexeme consumes the space following it
08:04:32 <pja> whataday: Use the Lexer from Text.MegaParsec ? 
08:05:02 <pja> AOC == Advent Of Code?
08:05:25 <whataday> but MegaParsec is available on codewars? sometimes I may do exercises on codewars
08:05:44 <Uniaika> pja: yes
08:06:18 <ephemient> whataday: https://github.com/Codewars/codewars-runner-cli/issues/682 yes
08:06:50 <merijn> ah, I don't know codewars, looks similar to the advent of code format
08:07:21 <merijn> Basically, that has you parse in record that can be arbitrarily permutated which is a massive hassle
08:07:58 <merijn> So much that it's much easier to just parse it first as "Map String String" and then later try and build a datatype from there
08:08:03 <whataday> but some questions on codewars are still using haskell 7...
08:09:47 <whataday> what do you mean "parse it first as "Map String String""?
08:09:49 <ephemient> IIRC somebody was in here last week asking for help with Control.Applicative.Permutations which builds up permutable parsers
08:10:53 <whataday> and also why there's no <<
08:11:07 <boxscape> haskell 7? I didn't know there were people not even caught up to version 98
08:11:10 <merijn> ephemient: That may have been me (although that was probably 2 weeks ago)
08:11:22 <merijn> ephemient: In the end I didn't bother :p
08:11:50 <whataday> codewars using it
08:12:26 <whataday> you even can't use <> to concat String in it
08:13:01 <whataday> have to import Data.semigroup first
08:15:28 <boxscape> ah I guess they mean ghc 7.x
08:16:36 <whataday> yes, my fault
08:16:57 <boxscape> eh you know they call it Haskell 7 in the ticket as well so it's understandable
08:24:20 <dolio> All the revisions before 98 were 1.x, so that'd be a big jump.
08:28:06 <boxscape> 98 to 2010 was also a big jump
08:29:00 <dolio> Realistically, I don't think any revisions have been significant enough to take it beyond 1.x in actual version numbers, given the previous numbering.
08:29:15 <boxscape> mhm
08:35:36 <whataday> I wonder how it handle IO before monad enter
08:37:02 <ephemient> very awkwardly
08:39:00 <whataday> there's typeclass in that time?
08:39:34 <whataday> higher kind stuff?
08:39:53 <dolio> It had two systems. One was `main :: [Response] -> [Request]`. The other was some wrappers around that using continuation passing, which were essentially the same as monadic IO, but not recognized as a common pattern.
08:40:55 <dolio> Using the lists directly was rather error prone, so I guess most people used the CPS wrapper.
08:41:55 <ephemient> https://www.haskell.org/definition/haskell-report-1.2.ps.gz section 7 goes through the request/response list pattern, 7.5 the continuation-based
08:43:20 <whataday> aha, CPS is everywhere
08:44:04 <ephemient> and https://www.microsoft.com/en-us/research/publication/tackling-awkward-squad-monadic-inputoutput-concurrency-exceptions-foreign-language-calls-haskell/ is the paper on how IO monad makes our life better
08:44:37 <whataday> but no IO a, what type CPS used?
08:45:24 <whataday> and also we can get value from it right? like get a from IO a
08:48:08 <int-e> type IO a = Cont ([Response] -> [Request]) a  ~=  (a -> [Response] -> [Request]) -> ([Response] -> [Request])
08:53:00 <whataday> but type IO a = Word -> (a, Word) is ok now?
08:53:20 <whataday> IO a is an action, and that is a function
08:54:03 <whataday> that IO a is not an action
08:57:45 <int-e> whataday: I was just writing something that would make a monad out of the [Response] -> [Request] model for I/O.
08:58:27 <int-e> In such a way that you can actually implement an IO action that creates a single request, awaits the response, and passes a result on to the remaining computation.
08:59:33 <whataday> m1 >>= (x.m2 >>= ( y.m3)) = (m1 >>= ( x.m2)) >>= ( y.m3)
08:59:36 <int-e> In practice I recommend treating IO as opaque unless you're writing really low-level code. type IO a = Word -> (a, Word) strikes me as having a really small world, which furthermore can easily be duplicated...
08:59:43 <whataday> from that article
09:00:00 <int-e> Word -> (a, Word) ~= State Word a  is just a state monad
09:00:05 <whataday> that's not equivalent
09:00:07 <int-e> @unmtl State Word a
09:00:07 <lambdabot> Word -> (a, Word)
09:00:38 <boxscape> The paper mentions World -> (a, World) so I wonder if there's some confusion between Word and World here
09:01:23 <int-e> boxscape: That thought became part of the "small world" idea.
09:01:35 <whataday> f >>= (g >>= h) /= (f >>= g) >>= h
09:01:57 <int-e> whataday: well, that's not the right law
09:02:19 <int-e> f >=> (g >=> h) = (f >=> g) >=> h
09:02:43 <koz_> Yep, fish is associative.
09:02:53 <whataday> but in that paper it used >>= to describe the third law
09:03:13 <koz_> whataday: Monad laws are usually spelled in terms of bind and return.
09:03:21 <koz_> But they are more easily spelled in terms of fish and return.
09:03:36 <int-e> Unpacking a bit... f x >>= (\y -> g y >= h) = (f x >>= g) >>= h
09:03:49 <int-e> err, that >= should be >>=
09:04:14 <int-e> The Kleisli version is just so much easier to get right.
09:05:03 <boxscape> I like join and pure
09:05:19 <int-e> oh and you can replace my `f x` by just `f` if you prefer that.
09:05:58 <int-e> sure there is  join . join = join . fmap join
09:06:28 <int-e> But that's hard to make sense of :P
09:06:59 <boxscape> it's not quite as nice to look at but it's easier for me to think about what join does than what >>= or >=> do
09:07:04 <int-e> (if you think in terms of >>= and pure)
09:07:39 <koz_> boxscape: I think it depends heavily on the Monad instance in question. For some, >>= and >=> can actually be easier.
09:07:52 <boxscape> hm, fair, that makes sense
09:07:53 <koz_> (and of course, YMMV)
09:08:17 <koz_> Like, for example, list definitely is easier in terms of join, I agree.
09:09:14 <whataday> when bind and >=> work on function, it's always weird
09:09:21 <whataday> I mean Reader
09:09:50 <ezzieyguywuf> how often do you `hoogle generate`?
09:09:59 <boxscape> @hoogle generate
09:10:00 <lambdabot> Test.QuickCheck generate :: Gen a -> IO a
09:10:00 <lambdabot> Test.QuickCheck.Gen generate :: Gen a -> IO a
09:10:00 <lambdabot> Data.Vector generate :: Int -> (Int -> a) -> Vector a
09:10:24 <int-e> hmm, not regularly
09:10:45 <ezzieyguywuf> I'm working on a revbump for the hoogle package and wondering if I should install a cronjob or something
09:10:51 <int-e> for lambdabot, usually when I update the thing, which is once or twice a year
09:11:00 <ezzieyguywuf> or even where to tell it to put the db that the system-wide instance would read from...
09:11:48 <ezzieyguywuf> gosh darnit neil, another package without all the test stuff bundled in, lol.
09:12:28 <hseg> why is it that unions are privileged in containers? they get the monoid instance, they get their mconcat version, etc etc
09:13:10 <koz_> hseg: Taking set as an example - how do you make a Monoid under intersection?
09:13:21 <koz_> s/set/Set/
09:13:25 <int-e> intersections don't have a law-abiding monoid instance
09:13:27 <hseg> Definitely a semigroup
09:13:35 <koz_> hseg: That's why they're privileged.
09:13:37 <int-e> and symmetric differences are uncommon
09:14:04 <hseg> hrm. and lifted operations?
09:14:15 <koz_> Lifted operations?
09:14:24 <hseg> i guess that's what monoidal-containers is for
09:14:40 <hseg> (<>) = liftA2 (<>)
09:14:43 <int-e> You mean f as bs = [a <> b | a <- as, b <- bs]?
09:14:56 <hseg> yeah
09:15:08 <int-e> too expensive to be the default, I think
09:16:10 <int-e> that said I don't recall actively using the monoid instance(s) of the containers at all.
09:16:15 <hseg> why? they're both just a merge invocation, albeit with union having guarantees on its combinator's runtime
09:17:07 <hseg> i do. basically am using monoidal-containers to simulate monoid-valued functions w/ finite support
09:17:11 <int-e> I'd rather reach for S.union and S.unions
09:17:20 <hseg> in particular, monomials
09:17:41 <int-e> (I'm talking about the default instance)
09:17:42 <merijn> hseg: It's more "why do the monoids suck so bad" :p
09:17:49 <hseg> ?
09:18:23 <merijn> hseg: "instance (Ord k, Semigroup v) => Monoid (Map k v)" is clearly superior to the current nonsense
09:18:27 <int-e> in the end, choices have been made that cannot easily be undone.
09:18:38 <hseg> fair
09:19:05 <merijn> There are vague plans on the containers github to possiblye eventually do this
09:19:16 <hseg> nice
09:19:19 <int-e> scary
09:19:52 <hseg> why didn't we do what we did for numeric types and have monoid instances discharged by newtypes?
09:21:03 <int-e> well, scary... maybe the right thing is to remove the existing monoid instance, keep it that way for a year and then add the new one?
09:21:26 <int-e> because changing it directly is a recipe for obscure bugs
09:21:30 <hseg> also, this dive into the containers api has made me hungry for a) a backpackified version to clarify the common parts and b) use th to generate all these precomposed specialisations
09:22:02 <hseg> int-e: of course. would expect this to be a multi-year migration like ftp and bbp
09:23:19 <merijn> int-e: That's one of the proposed paths
09:23:21 <solonarv> hseg: there actually is such a backpackified containers library, I believe, but I don't know how usable it is
09:23:48 <merijn> int-e: One suggestion was adding Data.Map.Semigroup with the right instance, delete the current one and later migrate Data.Map to be Data.Map.Semigroup
09:24:04 <hseg> yeah, picnic. it's demo-level, still needs a lot of work
09:26:17 <hseg> hrm. am patching monoidal-containers a bit, am having some coercion issues http://ix.io/2IjP
09:26:22 <int-e> merijn: sounds reasonable
09:26:30 <hseg> basically GHC doesn't know that it can coerce under f
09:26:41 <steve-chavez> Hi there. Has anyone compiled cabal on ARM? Wonder if you could help me with instructions.. (I already have GHC)
09:27:14 <hseg> but it should be possible by fmap'ing coerce in that parameter
09:27:29 <hseg> but that becomes ugly. any alternatives?
09:27:43 <SomeOtherUser> Hello, if I have: newtype Foo a = Foo a, is there a way to make it an instance of Foldable if, and only if a is Foldable?
09:27:59 <jle`> hm, 'a' can't be Foldable as you have written it
09:28:11 <jle`> since Foldables are always parameterized types (kind * -> *)
09:28:18 <jle`> and 'a' seems to be a kind-* type
09:28:36 <Kronic> I was confused for ages as to why my parser was working when I ran it once, but then broke when I mapped it over a list of inputs. Turns out the residual input was kept around from the previous parse
09:29:06 <SomeOtherUser> eg if i have Foo [Int] i want to fold over one of those Foos without extracting it
09:29:43 <jle`> you mean fold over the Int's in a Foo [Int] ?
09:29:47 <int-e> hseg: ghc can't do that. in the Kmettiverse there's some ugly hacks around this like https://hackage.haskell.org/package/profunctors-5.6/docs/Data-Profunctor-Unsafe.html#v:-35-. ... maybe there's a unary version of that somewhere too?
09:30:20 <SomeOtherUser> yes, jle`
09:30:47 <jle`> hm, there isn't any way of getting around extracting it eventually somewhere
09:30:56 <jle`> but there are some library functions that can automate the extraction
09:31:08 <jle`> probably the cleanest thing to do is to just add a record accessor
09:31:15 <jle`> newtype Foo a = Foo { getFoo :: a }
09:31:24 <jle`> then you can (blah . getFoo)
09:31:40 <hseg> oh well. any performance impacts if i eta-expand so i can explicitly coerce in the right place?
09:31:44 <int-e> hseg: basically you want  fmap coerce = coerce, but that may be highly unsound (imagine doing that with a Data.Set and types that have the same representation but different Ord instances)
09:32:29 <koz_> int-e: Set isn't a Functor.
09:32:48 <koz_> The 'fmap coerce = coerce' really _ought_ to be real, but sadly can't be for hysterical raisins.
09:33:08 <koz_> I think Iceland Jack did a writeup on this topic somewhere...
09:33:10 <SomeOtherUser> I see, I suppose I'll do it that way. Thanks fo rthe help
09:33:16 <SomeOtherUser> jle`
09:33:30 <hseg> ah... so there is no getting around explicitly unwrapping the newtype?
09:33:33 <jle`> SomeOtherUser: hm, another trick you could do is maybe use Data.Functor.Compose
09:34:00 <jle`> SomeOtherUser: if you wrap your Foo [Int] in Compose, you get `Compose Foo [] Int`
09:34:07 <jle`> and *that* has a Foldable instance
09:34:10 <jle`> that gets all the Ints
09:34:26 <jle`> hseg: unsafeCoerce
09:34:51 <hseg> yeah, no, i'm not pushing that for my very first patch
09:34:53 <jle`> SomeOtherUser: so if you wrap all your Foo's in Compose then you get a Foldable (Compose Foo f) for any Foldable f
09:35:32 <jle`> hseg: oh yeah actually in this case f only needs to be Foldable
09:35:39 <jle`> so unsafeCoerce would definitely break
09:35:47 <jle`> for something like Set, under int-e's example
09:35:51 <merijn> int-e, koz: coerce through functors isn't unsafe
09:36:03 <merijn> That why GHC added roles
09:36:18 <merijn> Of course it's unfortunate that GHC defaults to unsafe defaults for roles, but still
09:36:50 <merijn> And you can definitely coerce stuff like "Map Int Int" to "Map Int (Sum Int)" directly
09:37:04 <hseg> yeah, but you can't blithely coerce at a polymorphic type constructor without knowing the role
09:37:06 <merijn> Hell, being able to do that is exactly why Coercible got invented
09:37:33 <int-e> it's too subtle that type families basically can't be functors
09:37:51 <koz_> Yeah, type families require some care around a whole bunch of things.
09:39:36 <int-e> And, of course, you can insist on a nominal role for a type parameter of something that also has a Functor instance.
09:40:22 <int-e> In which case  fmap coerce  will be allowed but replacing it by  coerce  should be rejected.
09:41:12 <SomeOtherUser> jle` Interesting, I think I"ll go with the other approach for now, as I've not yet worked with Compose and I don't know what else it would affect. But it's worth trying out. Let's see what works best.
09:42:03 <jle`> SomeOtherUser: no problem :) the COmpose approach is something you can do if you literally need "a Foldable instance", ie., if you are using a function that works for all Foldable so you need to massage the type into something you can give that function
09:42:18 <jle`> SomeOtherUser: if you just want to fold over it, then yeah, explicitly extracting is probably the cleanest
09:47:43 <boxscape61> hm in the paper about IO linked earlier SPJ says " I have to say that I think the GHC approach [of using World -> (a, World)] is a bit of a hack [...]  it relies for its correctness on the fact that the compiler never duplicates a redex" Seems like this could now be made non-hacky by using a linear arrow in that type
09:48:49 <dolio> That's not the only problem with it.
09:49:25 <boxscape> What are the other problems?
09:49:31 <int-e> hseg: Anyway rather than wrecking your brain on how to tame `coerce`, you can just unfold the definition of unionsWith: unionsWith f ts = Foldable.foldl' (unionWith f) empty ts
09:49:48 <jle`> boxscape: how would that model make sense in the context of concurrency/parallelism?
09:49:50 <dolio> It's okay as an implementation detail, but from a semantic perspective, it doesn't really accomplish the goals of having IO.
09:50:09 <koz_> I think Edward spelled out some issues with this approach.
09:50:16 <koz_> Let me see if I can find relevant citation.
09:50:28 <boxscape> jle` hm fair point
09:51:00 <koz_> http://comonad.com/reader/2011/free-monads-for-less-3/
09:51:11 <koz_> Section "Who Needs the RealWorld?"
09:51:16 <koz_> First couple of paragraphs.
09:51:29 <boxscape> thanks
09:51:34 <int-e> Hmm... IO isn't free?
09:51:51 <pjb> free monads for less???  You mean you give me money if I use your free monads?
09:51:55 <dolio> For instance, you can't really make sense of infinite loops that do IO without making the actual function arrow have effects. And arguably the point of IO is to avoid that.
09:52:00 <koz_> int-e: Read the article lol?
09:52:05 <koz_> (just one section)
09:52:13 <int-e> koz_: it just sounded funny :)
09:52:25 <koz_> pjb: Rofl.
09:52:39 <boxscape> dolio hm I see
09:52:43 <int-e> koz_: because of the many meanings of 'free'.
09:52:56 <koz_> int-e: Yeah, gotta love overloading!
09:53:57 <hseg> hrm. sure, but when most of the codebase is coerce-copying a type's api to that of the newtype that wraps it, it leaves a bad taste
09:56:09 <koz_> hseg: You can DerivingVia the type class parts of that, at least.
09:56:32 <int-e> koz_: but yeah this is compatible with my way of thinking which is that the realworld token is just a clever hack of injecting data dependencies that ensure that IO actions cannot be evaluated out of order; no semantic meaning is attached to the token.
09:56:52 <koz_> int-e: Yeah, which is fine. However, Edward's criticisms of the semantics are valid.
09:57:01 <hseg> mostly see gnd in this codebase (monoidal-containers)
09:57:36 <koz_> hseg: GND just enables 'deriving newtype', which is just a more restricted 'deriving ... via ...'.
09:57:41 <hseg> i know
09:58:07 <koz_> I've really fallen in love with DerivingVia. Help, I'm turning into Iceland Jack.
09:58:21 <hseg> same
09:58:24 <koz_> (like, I'm fairly sure he has a mandatory DerivingVia use quota at this point)
09:58:50 <hseg> hm. why is ghc complaining v in sig differs from under coerce? http://ix.io/2Ik1
09:59:47 <int-e> GND is basically just `coerce`-ing all the class methods.
09:59:56 <int-e> hseg: you need ScopedTypeVariables and a forall v.
10:00:05 <int-e> (k too)
10:00:09 <hseg> :facepalm:
10:00:11 <koz_> Ah yes, it's _that_ issue.
10:00:36 <hseg> was wondering why i was seeing explicit foralls with no typeapplications
10:18:12 <hseg> and the bloat of 'containers' continues... why have map if you can define a Functor instance?
10:23:18 <runningatnight> I simply can't get my head around a few things about type definitions. 
10:26:53 <runningatnight> In particular, when a variable type denotes some recursive call. Is "recursion" its own type, like Integer? - would sound strange or silly, but I can't think of anything else right now.
10:28:07 <geekosaur> I don't understand what you're asking. Recursion is not a specific type, but types can be recursive
10:28:35 <runningatnight> For example:
10:28:38 <runningatnight> foldr :: (a -> b -> b) -> b -> [a] -> bfoldr f v [] = vfoldr f v (x:xs) = f x (foldr f v xs)
10:29:16 <runningatnight> I don't get what b means here when it is in place of a recursion.
10:29:37 <koala_man> do you mean higher order functions in general?
10:29:41 <geekosaur> that was multiple lines before your client mangled it, I assume?
10:30:03 <runningatnight> foldr :: (a -> b -> b) -> b -> [a] -> b
10:30:09 <runningatnight> foldr f v [] = v
10:30:10 <runningatnight> foldr f v (x:xs) = f x (foldr f v xs)
10:30:30 <geekosaur> right. b is just some type which can be distinct from a
10:31:26 <ephemient> b is unrelated to the recursion. you could define a (very boring) non-recursive function with the same signature
10:31:30 <koala_man> the type would have been the same whether the function was implemented recursively or not
10:33:53 <runningatnight> Will the type of "b" depend on the result of the recursion, if it is an integer or some other type? - sorry, if this make no sense.
10:34:28 <jle`> it depends on the type of the second argument
10:34:41 <jle`> myFunc :: (a -> b -> b) -> b -> a -> b
10:34:47 <jle`> myFunc f x y = f y x x
10:34:52 <jle`> do you understand that type signature?
10:35:28 <jle`> runningatnight: ah hm, do you understand that a function :: X -> Y -> Z can be interpretd as a function that takes an X and a Y and returns a Z ?
10:35:30 <ralu> ford "iterates over list of type a" to produce type b by applying function of type a->b->b
10:35:40 <jle`> in that case yes, 'b' is type type of the return value of the foldr
10:35:43 <jle`> *type of
10:36:02 <jle`> so if `foldr blah blah blah` returns an Int, then b is Int in that case
10:36:11 <jle`> but it doesn't have anything to do with recursion, that's true for all function types.
10:37:05 <jle`> recurisve or not
10:37:09 <hseg> hrm... would be nice to be able to convert typeclasses and instances to module signatures and implementations and back
10:37:45 <hseg> eg thinking of making mono-traversable:IsMap into a module signature to avoid instantiation costs
10:44:03 <dminuoso> 19:17:49           hseg | and the bloat of 'containers' continues... why have map if you can define a Functor instance?
10:44:11 <dminuoso> Because you can't define a Functor instance for say Set.
10:44:33 <hseg> sure, but why does that need to infect the other types?
10:44:48 <dminuoso> What do you mean by "infect"?
10:45:13 <hseg> the fact that Set needs a monomorphic map doesn't justify monomorphising map for say Map
10:45:45 <hseg> unless you're arguing for internal consistency over consistency with standard practice
10:46:07 <dminuoso> What generic interface do you propose, that would fit all data types in containers?
10:46:51 <hseg> none. but a patchwork of interfaces, like we're used to from elsewhere, should work.
10:47:22 <dminuoso> Seq and (Map k) have Functor
10:47:35 <dminuoso> IntSet is MonoFunctor at best
10:47:41 <hseg> off the top of my head, some combination of Functor/Foldable/Traversable, their keyed variants from Lens, the Align hierchy etc
10:47:41 <dminuoso> Set would require a special OrdFunctor
10:48:09 <dminuoso> There's just no obvious pattern here to abstract over, that would bring you any benefits.
10:48:15 <glguy> Since the .Lazy and .Strict types use the same types you can't really drive the interface with typeclasses
10:48:37 <glguy> modules use the*
10:48:40 <hseg> yet more reason to distinguish between lazy and strict data
10:48:44 <nshepperd> what's so bad about having fmap as well as the monomorphic map
10:48:53 <glguy> I don't want the types to be different; I want to get to pick
10:49:37 <hseg> nshepperd: on its own, nothing. as an example of the wheel being monomorphically reinvented across containers, it's a good scapegoat
10:49:53 <hseg> glguy: ? what do you lose if we split the types?
10:50:18 <dminuoso> Arguably Data.Map.Strict.map/Data.Map.Lazy.map has no reason to exist, but its existence is not a good enough reason to "try and force a generic interface over them all"
10:50:21 <hseg> dminuoso: sure. so you monomorphise what needs to be monomorphised, and keep the others generic
10:50:23 <glguy> the ability to use strict/lazy variants as needed on the same Map
10:50:33 <dminuoso> hseg: thats what containers does.
10:50:38 <glguy> and trying to wedge everything into typeclasses to save on names doesn't get me much
10:50:43 <dminuoso> We have Functor for IntMap and (Map k)
10:51:43 <hseg> sure. but i'm arguing that our choice of what gets a monomorphic name and what doesn't is weird
10:52:20 <dminuoso> What's so bad about being monomorphic?
10:52:43 <glguy> some monomorphic names get added when people miss them enough, but it's just hard to be completely consistent
10:52:55 <hseg> i find it distasteful, especially when generic interfaces exist
10:53:07 <dminuoso> hseg: Do you have any particular example here?
10:53:19 <merijn> hseg: IntMap is asymptotically better than Map, that's why it exists
10:53:49 <int-e> bold claim
10:53:54 <merijn> Map is binary search tree, IntMap is not (same applies to IntSet)
10:54:09 <minimario> ohhh
10:54:13 <minimario> cool!
10:54:22 <hseg> sure. not arguing against specialization. but it doesn't mean it shouldn't try to harmonize its api with common practice
10:54:23 <merijn> int-e: Why?
10:54:25 <hseg> as it does
10:54:37 <int-e> IntMap is still a binary tree in the middle, despite the bitmaps at the leafs that help if you have adjacent keys.
10:54:42 <int-e> s/Map/Set
10:54:50 <int-e> And IntMap is a binary tree.
10:55:07 <merijn> int-e: Asymptotically better does not require a different complexity class, though :p
10:55:11 <hseg> dminuoso: just the general vibe from comparing the various maplike containers over the past day
10:55:40 <koz_> merijn: IntMap _is_ of a different complexity class - lookups are bounded by max key bitlength, which is a constant, since the key is an Int.
10:55:57 <int-e> merijn: Your asymptotic improvement is an illusion. On that level of abstraction an IntMap can only hold 2^w different values where w is the word width, while a Map can hold as many as you like.
10:56:07 <merijn> koz_: "Map Int" is also bounded  by max key bit length, though
10:56:30 <merijn> int-e: Why is it an illusion
10:56:30 <hseg> in any case, i'll put my money where my mouth is and (eventually) try to harmonize the containers types
10:56:30 <int-e> You'll never fit it into the available address space, of course, because that's (usually) also limited by the word size.
10:56:36 <koz_> merijn: OK, yeah, in that case, sure.
10:56:42 <monochrom> I just received my new 16GB-RAM computer today. My Map cannot exceed that. :)
10:56:47 <koz_> I thought it was 'Map whatever' to 'IntMap'.
10:57:06 <merijn> monochrom: That's why I used a 256GB RAM machine for Haskell!
10:57:14 <monochrom> Haha
10:57:14 <int-e> merijn: Basically "asymptotic" is meaningless here because we cannot make the numbers large enough for there to be a difference.
10:57:22 <koz_> merijn: GHC 10 will have Death Star support. :P
10:57:36 <koz_> GHC 11 will add Dyson Sphere support to that.
10:57:42 <monochrom> Um, how does Death Star help?
10:57:45 <merijn> int-e: If you have a constant factor improvement you are still asymptotically better :)
10:57:51 <int-e> merijn: no
10:57:59 <koz_> monochrom: I corrected my joke.
10:58:07 <monochrom> Oh haha OK
10:58:12 <koz_> I got Death Stars and Dyson spheres confused.
10:58:15 <koz_> Mea culpa.
10:59:03 <monochrom> On that note, I wonder why the Empire settled for merely a death star, the First Order merely a death planet.  Neither aimed high for a death dyson sphere.
10:59:04 <merijn> int-e: 'f' is asymptotically better than 'g' IFF there is an value 'x' such that for all values y > x, f(y) > g(y)
10:59:23 <koz_> monochrom: Death Matrioshka Brain.
10:59:26 <merijn> int-e: If f is a constant factor better than g then that trivially holds for all input sizes
10:59:56 <merijn> I think I got in this argument before here :p
11:00:05 <monochrom> But seriously, "asymptotic" means big-Theta, you drop the constant factor.
11:00:17 <int-e> I bet I can make IntMap slower than Map by a carefully constructed example.
11:00:24 <merijn> monochrom: big Theta is all lies anyway
11:00:56 <monochrom> That is still not license to mistake asymptotic for something else.
11:00:57 <int-e> Because you only need w+1 element to force it to use its maximal depth.
11:01:10 <merijn> monochrom: But I'm not
11:01:40 <chibi_> Halloah.
11:01:54 <merijn> int-e: I'd like to see that and the corresponding "Map Int" input, tbh :>
11:02:45 <int-e> > M.fromList [(2^i :: Int, i) | i <- [0..64]] -- including 64 is deliberate
11:02:48 <lambdabot>  fromList [(-9223372036854775808,63),(0,64),(1,0),(2,1),(4,2),(8,3),(16,4),(3...
11:03:08 <int-e> the path to 0 has siblings on every level.
11:03:31 <int-e> (if you make that into an IntMap)
11:03:58 <merijn> Right, but is that sufficient to prove that it's less efficient in terms of performance
11:05:06 <jle`> > M.showTree $ M.fromList [(2^i :: Int, i) | i <- [0..64]]
11:05:08 <lambdabot>  error:
11:05:09 <lambdabot>      • showTree has moved to Data.Map.Internal.Debug.showTree.
11:05:09 <lambdabot>      • In the expression:
11:05:31 <jle`> > M.splitRoot $ M.fromList [(2^i :: Int, i) | i <- [0..64]]
11:05:33 <lambdabot>  [fromList [(-9223372036854775808,63),(0,64),(1,0),(2,1),(4,2),(8,3),(16,4),(...
11:05:40 <jle`> oh dear
11:05:55 <int-e> jle`: The Data.Map tree is flatter of course
11:06:16 <jle`> > IM.splitRoot $ IM.fromList [(2^i :: Int, i) | i <- [0..64]]
11:06:18 <lambdabot>  [fromList [(-9223372036854775808,63)],fromList [(0,64),(1,0),(2,1),(4,2),(8,...
11:06:41 <jle`> oof
11:06:46 <jle`> > map IM.splitRoont . IM.splitRoot $ IM.fromList [(2^i :: Int, i) | i <- [0..64]]
11:06:49 <lambdabot>  error:
11:06:49 <lambdabot>      Not in scope: ‘IM.splitRoont’
11:06:49 <lambdabot>      Perhaps you meant one of these:
11:06:56 <jle`> > map IM.splitRoot . IM.splitRoot $ IM.fromList [(2^i :: Int, i) | i <- [0..64]]
11:06:58 <lambdabot>  [[fromList [(-9223372036854775808,63)]],[fromList [(0,64),(1,0),(2,1),(4,2),...
11:07:08 <int-e> merijn: well, lucky me
11:07:11 <jle`> i guess the directions alternate
11:09:58 <int-e> merijn: The example is good enough: https://paste.debian.net/1177166/
11:12:09 <int-e> But you can certainly make this more interesting by adding more nodes at depth w.
11:12:45 <int-e> (say, replace 2^i by x `xor` 2^i, where x is the node you want to have at that depth)
11:18:59 <int-e> merijn: well let's make it a little more convincing: https://paste.debian.net/1177169/
11:19:55 <int-e> (ignore the comment on the first line, I actually edited the second line between recompiling)
11:21:00 <int-e> Also Strict/Lazy makes no real difference (and it shouldn't when basically all you have are lookups).
11:21:39 <fuzzypixelz> is there really no way for me to learn haskell "by doing"
11:21:59 <fuzzypixelz> a very simple mini-project to get my hands dirty?
11:22:14 <int-e> is there any other way?
11:22:18 <sm[m]> fuzzypixelz: project Euler is good
11:22:44 <merijn> fuzzypixelz: AOC :P
11:22:51 <merijn> sm[m]: tbh, I gotta disagree there
11:22:57 <int-e> yeah something that focusses on algorithms may be more pleasant to start with than something that requires IO and parsing.
11:23:00 <int-e> so not AoC
11:23:11 <justsomeguy> Why do I get 0 rather than 128 when I run “abs (minBound :: Int8)”?
11:23:29 <merijn> sm[m]: Project Euler is mostly numerical trickery, not programming. It also forces you to spend most of your time dealing with the least pleasant bits of Haskell (fromIntegral hell, etc.)
11:23:33 <merijn> @where exercises
11:23:33 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
11:23:37 <int-e> > abs (minBound :: Int8)
11:23:39 <lambdabot>  -128
11:23:51 <xerox_> that's not very abs
11:23:55 <justsomeguy> Right...
11:24:03 <int-e> but expected
11:24:12 <merijn> xerox_: That's because it overflows and overflow wraps
11:24:14 <xerox_> because a->a
11:24:14 <int-e> 128 can't be represented, it overflows to -128
11:24:32 <sm[m]> It's a source of mini projects, and it worked well when I was starting out
11:24:57 <justsomeguy> int-e: Ohh, damn, now it makes sense.
11:25:06 <merijn> sm[m]: That's why I made the @where exercises thing :p
11:25:33 <sm[m]> nice
11:25:34 <merijn> Those have more programming oriented exercises/projects, rather than numerical ones
11:25:58 <ephemient> hmm, I don't think I've needed any fromIntegral tricks with AoC
11:26:19 <justsomeguy> int-e: “abs $ toInteger (minBound :: Int8)” does indeed work. Also I wonder why does the negative range have 128 numbers, while the positive range has only 127?
11:26:39 <merijn> ephemient: I meant for Project Euler
11:26:52 <sm[m]> But there's nothing wrong with some simple number tasks is there ? The domain was simple enough to not distract from learning haskell
11:27:01 <ephemient> oh. yeah, that is all mathematical, programming being secondary
11:27:03 <int-e> justsomeguy: 2s complenment, working modulo 256... note that you have 256 total bit patterns in total
11:27:37 * justsomeguy looks up twos complement on wikipedia ...
11:27:41 <ephemient> I did use Haskell + arithmoi for some of PE, but it's not always a great fit
11:27:52 <int-e> justsomeguy: so you either have ambiguity (say both a positive and a negative zero) or one of the signs gets more values than the other.
11:28:27 <ephemient> for comparison, floating point picks the first option, and has both a positive and negative zero
11:28:34 <int-e> justsomeguy: the reason why the negative range wins out is mostly convenience (treating the most significant bit as a sign bit while working modulo 256)
11:29:36 <int-e> oh a third option would be to have invalid bit patterns that do not represent a number (which floating point also has, for different reasons)
11:30:23 <merijn> sm[m]: I mean, it's not bad, but it does often force people to have tons of fromIntegral/realToFrac hacks in their code and the focus on numerical trickery over programming things means it's "not great" in terms of getting better at Haskell programming patterns (not that it can't be fun or anything, but I feel that practicing haskell programming is usually better suited by more programmy problems)
11:31:39 <ephemient> none of these challenges give you experience with actual engineering in haskell, which I think is harder to pick up
11:32:15 <sm[m]> Not everyone is the same, we know nothing about what fuzzypixel, probably a beginner, really needs. I stand by project Euler as one valid suggestion
11:32:19 <ephemient> although I suppose that's not unique; it's true of any other language you'd be trying to apply too
11:32:24 <merijn> If you want an engineering challenge I can give you one :p
11:33:29 <ephemient> I do agree with merijn that Project Euler isn't a good introduction to Haskell, or any language (aside from CAS packages)
11:51:43 <geekosaur> the evalprompt is less interesting than it might be, because it can't access xmonad running state
11:52:00 <geekosaur> it's just a mini-ghci built into xmonad
11:53:56 <geekosaur> blah, wrong channel again
12:04:23 <justsomeguy> Out of curiosity, how do you like xmonad? I've been using i3 for a few years, and mostly like it, and was thinking that xmonad would be similar enough but also give my an excuse to practice my Haskell.
12:06:57 <geekosaur> I've been using it since 2007ish (0.3 release)
12:07:13 <monochrom> @where exercises
12:07:13 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
12:07:38 <geekosaur> I'm also a maintainer, so just a bit biased :)
12:31:19 <Kronic> I'll go ahead and say based on the previous suggestions that I have found AOC to be extremely helpful for me in learning Haskell. Most of the time AOC problems have one data structure or trick that can make them a lot easier
12:31:58 <Kronic> E.g a map, a parser that's a little more than ifs and elses, so for me as a hobbyist who long since forgot most of my haskell knowledge, it has been a great vessel for picking it back up again
12:32:30 <Kronic> If your goal is to do AOC fast as well as learn Haskell then it's a terrible idea, but if you wanna spend an extra couple of days learning the right way to do something then that's a good idea I think, it has worked for me anyway.
13:18:49 <tomsmeding> It's fun, I'm working through some of the AoC problems for this year and suddenly I understand where the most arbitrary questions in this channel come from
13:19:09 <tomsmeding> like: is there a vector library that automatically extends when I index past its length
13:19:23 <tomsmeding> reading that yesterday I was like, why on earth would you want that
13:19:35 * tomsmeding does AoC day 15: "aaaaah that's why"
13:19:40 <sondr3> When I want to ensure that whatever file I'm reading/writing is UTF8, what should I use? I'm currently using Data.Text and haven't found UTF-8 validation that doesn't involve ByteString -> Text
13:20:55 <iqubic> tomsmeding: LOL.
13:22:31 * justsomeguy also asks many strangely specific questions (like how to query types at compile time) as he follows along haskellbook.com, but he usually tries to provide some context.
13:23:54 <troll_> haskell is shit.
13:24:07 <iqubic> troll_: You are wrong.
13:24:15 <ski> do you have any more specific criticism ?
13:24:27 <troll_> haskell is bloated too.
13:24:39 <justsomeguy> Or, what specifically are you having trouble with that makes you feel that way?
13:24:58 <troll_> haskell is nasty as well.
13:25:11 --- mode: ChanServ set +o dolio
13:25:11 --- mode: dolio set +b troll_!*@*
13:25:24 --- mode: dolio set -o dolio
13:25:28 <ski> perhaps you mean GHC, or applications or libraries produced by it. or are you talking about the actual parts of the language itself ?
13:25:32 <justsomeguy> He must have been really bored.
13:26:17 <Kronic> Maybe he was talking about that annoying rugby player that is forever in my google search results... 
13:26:30 <ski> @where Haskel
13:26:31 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
13:27:30 <merijn> sondr3: Well, how would you possibly do validation without going "ByteString -> Text"?
13:28:12 <sondr3> merijn: close my eyes and wish Haskell used UTF-8 by default? :P
13:28:25 <merijn> sondr3: That's a nonsensical statement
13:28:42 <merijn> The contents of files cannot be dictated by a programming language
13:28:54 <merijn> The data in a file is whatever it is
13:29:41 <merijn> And the only way to check is "Read bytes, try to parse them as Text using an encoding"
13:30:26 <sondr3> I know, hyperbole, I just wish working with text in Haskell was a bit more like Rust
13:30:29 <merijn> sondr3: Once it is Text it's already unicode data, there's no need to do validation on Text
13:30:56 <merijn> sondr3: I don't know what Rust does, but GHC does the only thing that can sensibly *be* done
13:31:41 * justsomeguy sometimes wishes that someone would create a "distribution" of haskell that has performant array-based utf-8 strings by default, first-class syntax for maps and sets, and more container types in Prelude.
13:32:04 <merijn> "utf8 strings" is, honestly, just a confusion
13:32:29 <monochrom> :)
13:32:31 <merijn> Once it's parsed as Text or String you operate on *unicode*. UTF-8 is just a way to serialise unicode into data
13:32:41 <merijn> There is no such thing as "utf8 strings"
13:32:58 <merijn> Sure, in languages like C where "string" is just "sequence of bytes" people conflate the two
13:33:07 <justsomeguy> My understanding is that utf-8 uses one byte per codepoint, as opposed to two. Is that right?
13:33:13 <merijn> justsomeguy: No
13:33:13 <monochrom> I have heard worse blasphemy than "utf8 strings".  "high ascii", for starters.
13:33:56 <merijn> justsomeguy: UTF-8 is a variable length encoding that uses anywhere from 1 to 3 (or is it 4?) bytes per unicode codepoint (note: codepoint *not* character)
13:34:02 <dolio> I'm trying to imagine what that means. Is that like high Valyrian?
13:34:21 <monochrom> utf8 uses 1-4 (even 5? I forgot) bytes per codepoint. The whole point of utf8.
13:34:21 <merijn> monochrom: Wanna know something to gross people out and/or confuse them?
13:34:28 <monochrom> Yes!
13:34:34 <merijn> monochrom: UTF-7 is a thing that exists
13:34:46 <monochrom> haha darn
13:35:10 <merijn> monochrom: Like base64 it's designed to not get corrupted by legacy mail systems that don't allow high bits to be sit
13:35:14 <merijn> s/sit/set
13:35:16 <sondr3> I meant that it used UTF8 as its internal representation, but fair
13:35:38 <merijn> sondr3: The value of that is, honestly, rather marginal
13:35:45 <justsomeguy> merijn: lol, I shouldn't have trusted that reddit comment about strings. I'm going to have to look up a summary of unicode in the near future.
13:36:10 <merijn> It might make for some *slightly* faster parser implementation...maybe, but that assumes you're not being bottle-necked by IO anyway
13:36:27 * ski . o O ( sum : summary :: product : ? )
13:37:03 <merijn> sondr3: There was an experiment with UTF-8 based text, but it made interoperation with text-icu more cumbersome and less efficient and text-icu is the closest to thing to exist for properly handling complex unicode operations
13:37:17 <monochrom> dolio: it's called "high" because each number used is >= 128.
13:37:33 <dolio> Oh.
13:38:11 <dolio> Is it intended to mean what you get by subtracting 128 from the number?
13:38:13 <monochrom> So basically recall any DOS codepage that is a strict superset of ASCII
13:38:23 <monochrom> Naw.
13:38:34 <merijn> The number of cases where the copy/conversion to Text's internal representation is a bottleneck is pretty small and only occurs when your IO is somehow fast enough to outpace your ability to process data. Which can certainly happen, but at that point you'll have bigger engineering challenges than I can't zero-copy utf-8 bytes into Text
13:39:47 <monochrom> It's any encoding+charset (they weren't separated back then) that uses the range 128-255 for non-English characters, picture characters, and other special characters not in ASCII.
13:44:18 <dolio> Oh, okay.
13:51:04 <noctux> Hmm, what do I want to use if I want a dead simple, constant-time string comparison for String or Text? Somehow, google was not all that helpful, and stuff like https://security.stackexchange.com/a/83671 that it did turn up, well, look dangerous given a sufficiently smart compiler
13:51:37 <monochrom> ==
13:52:41 <ephemient> at some point we may have to worry about sufficiently smart processors as well
13:53:03 <ephemient> it's hard to ensure constant-time without actual primitives to support it
13:55:17 <noctux> Sure :) tell me something new :p In my dayjob, I'm doing wcet analysis for hard realtime stuff, so I know the problem. But there probably should be some best practices or libraries that people do use for passwords validation in haskell that make a credible effort at preventing timing sidechannels
13:55:46 <monochrom> Is "constant-time" now hijacked to mean "uniform, best case time = worst case time so it is less vulnerable to timing attack", instead of the already standard "O(1)"?
13:56:27 <noctux> No, I was probably just not specific enough :p
13:57:04 <ephemient> the term is sort of hijiacked though
13:57:49 <ephemient> e.g. https://en.wikipedia.org/wiki/Timing_attack uses the term "constant-time" all over
13:58:04 <monochrom> I will resist it.
13:58:26 <noctux> And actually: bestcase == worstcase makes your algorithm O(1)
13:58:26 <monochrom> "uniform-time" is a much more accurate and honest wording.
13:58:35 <monochrom> No.
13:58:47 <noctux> Well yes?
13:58:54 <ephemient> no
13:59:19 <noctux> If your worstcase timing is your bestcase timing, your algorithm is input independent
13:59:24 <monochrom> I have an array of length n. I want to look for an occurrence of the number 4 in it. So I loop over the array and do linear-time search.
13:59:28 <boxscape> these algorithms still have different runtime depending on the lengths of the strings to compare it seems, no?
13:59:42 <noctux> (And you got an deterministic execution environment as a bonus)
13:59:43 <ephemient> yes
14:00:07 <noctux> Well global bestcase/wostcasr obvs.
14:00:27 <ephemient> security-related "constant time" (or "uniform time", I hadn't heard that before but it's sane) doesn't generally refer to changing the size of inputs
14:00:29 <noctux> Or is that "worst worstcase" to you?
14:00:34 <ephemient> while O(...) time does
14:00:40 <monochrom> Normally my loop exits as soon as the first occurrence is found. Best case is 4 occurs at the first spot I check, O(1) time. Worst case is 4 doesn't occur, O(n) time.
14:00:58 <monochrom> So, not O(1) and best case < worst case.
14:01:16 <monochrom> But the whole array is still length n.
14:01:49 <ephemient> e.g. for password comparisons, the goal is that it always runs in o(40)=O(40) or however long your hash is
14:01:58 <monochrom> The security people have a proven history of wrong wording and inventing unnecessary concepts.
14:02:31 <ephemient> they're not concerned about changing hash size, but they are concerned about different inputs at that size
14:02:37 <noctux> well, we are leaving the point of my question, but for what it is worth: "global best case timing (for all possible inputs) == global wort case timing (for all possible inputs)" implies (in the logical implication sense) algorithm is in O(1)
14:02:52 <noctux> I've never claimed anything else
14:03:25 <ephemient> an algorithm that takes O(1) time on arbitrary-sized input can only process O(1) of it, so... it's basically taking bounded-sized input?
14:03:41 <monochrom> But no one implied "for all inputs". Only "for all inputs of the same size".
14:04:41 <noctux> monochrom: well I implied it with "global"
14:04:47 <dolio> If the algorithms assume fixed input size, why are the ones on that page testing the input lengths?
14:04:58 <monochrom> The flawed logic of taking "worst case time" to mean "worst case time for all inputs, therefore for all input sizes" implies that worst case time is infinity.
14:05:34 <dolio> The stack overflow page, that is.
14:05:42 <noctux> monochrom: well, please, never write real-time critical software I'm forced to use than :P
14:05:55 <noctux> but yeah, probably im "blind" to my domain :P
14:06:01 <noctux> and its terminology
14:06:18 <noctux> but that is not really my problem anyways
14:06:48 <noctux> in that case, it's about doing password comparision in some webservice I've written in my spare time
14:06:52 <dolio> Several of the algorithms on the stack exchange page appear to leak whether or not the two inputs differ in length, too.
14:07:19 <monochrom> I think you would never compare two passwords in plain text in the first place?
14:07:24 <noctux> dolio: well: you could only provide guarantees up to a fixed length of input anyways
14:07:50 <noctux> monochrom: I'm leaking pbk2df2 hashes
14:07:55 <noctux> via the sidechannel
14:08:03 <noctux> not a real problem
14:08:29 <noctux> but not best practice either, as breaking them via hashcat is probably faster than against the webapi of theserver(tm)
14:08:32 <monochrom> OK, then use the byte-wise xor shown there.
14:10:20 <ephemient> going back to the original point... it seems like it could be defeated by a sufficiently clever compiler, and to get around that, we'd need proper primitives :-/
14:10:33 <noctux> well, and my question was: "that cannot really be best practice, can it?"
14:13:08 <monochrom> I don't pay attention to "best practice", so I can't answer that.  But I can remind you what to watch out for.
14:13:33 <monochrom> && and || are short-circuiting.  If you use foldr (&&) you're toasted.
14:13:59 <monochrom> "any", "all", "and", "or" do that, so they're toasted too.
14:14:31 <ephemient> as far as I'm aware, best practice is not to use a high-level language (even C counts, to some extent)
14:14:34 <monochrom> (==) for most list and array types also exit early at the first sight of a difference.
14:14:48 <solonarv> '(==1) . length . filter p' will do, I think
14:14:55 <monochrom> (But you should benchmark to find out for sure.)
14:14:57 <solonarv> but really if you need performance guarantees, don't write Haskell
14:15:25 <noctux> ephemient: well yeah, C cannot do it either, even when trying to be clever with volatile...
14:16:09 <monochrom> I haven't checked whether hash comparison in cryptonite is time-safe. But you should check.
14:17:25 <monochrom> If it comes down to coding up your own comparison, be aware of lazy evaluation, and check generated Core code, Cmm code, and asm code. (Look at all three, they help explain each other.)
14:18:06 <monochrom> Lazy evaluation is required knowledge for this because the reason foldr (&&) is toasted is because of lazy evaluation.
14:18:51 <monochrom> But to a large extent, if you understand why foldr (&&) quits early, you already understand the main issue.
14:19:04 <noctux> yeah, I know, that's why I've asked. ASM code is a tricky one, because that makes my application non-portable
14:19:09 <dolio> If C can't do it, then my guess would be that cryptonite isn't time safe.
14:19:25 <noctux> but crypto-libs is a good idea
14:19:30 <Rembane> If it isn't built in many different kinds of ASM
14:19:55 <noctux> unfortunately saltine for instance seems to lack nacls crypto_verify 
14:20:50 <noctux> (and if nacls broken, probably a lot more is on fire then some online helpdesk software for remote coputer exercises :P)
14:21:42 <dolio> I would say you probably should just not be using Haskell to write such algorithms, unless it something in Haskell that generates the right code.
14:22:45 <noctux> well, haskell is nice for all the other parts. but yeah, the "use nacl" part can be generalized to "use a native C/Asm cryptolib that exposes a convenient function" 
14:22:50 <merijn> monochrom: Man, I don't think I could correctly write a time-attacking safe comparison in C, let alone haskell :p
14:23:19 <merijn> noctux: FWIW, wrapping missing C functions via the FFI is fairly trivial
14:23:41 <monochrom> I would check the generated asm code. But I wouldn't worry about it beyond that.
14:24:05 <merijn> noctux: So if it binds NaCl, but is just lacking the binding you can just quickly implement the binding yourself
14:24:10 <ephemient> marshalling is the worst part of FFI, and that's not *too* bad unless you have complex structures with pointers and function pointers and stuff
14:24:23 <merijn> ephemient: Function pointers is still pretty easy
14:24:31 <monochrom> Marshalling is uniform-time. Perhaps that helps.
14:24:38 <ephemient> it's not hard, you just have to think about the lifetime
14:24:48 <merijn> Writing Storable instances sucks, therefore avoid mutating structs from haskell :p
14:24:56 <merijn> ephemient: Sure, but that's the same as in C :p
14:25:05 <merijn> ephemient: Also, you're aware of ForeignPtr? ;)
14:25:09 <noctux> well, in that case, yes. I mean, its two strings -> char *
14:25:36 <noctux> but still, I'm a bit surprised that I seem to be the first one having that issue?
14:26:00 <ephemient> merijn: I was thinking FunPtr...
14:26:11 <ephemient> you can't stick that in a ForeignPtr, can you?
14:26:30 <merijn> ephemient: hmm, not sure
14:26:41 <merijn> But allocated FunPtr are rare
14:26:52 <merijn> In fact, can those exist at all in C? I don't think so?
14:27:27 <ephemient> I've done it before with libffi - can generate "closures" in C
14:27:39 <monochrom> No. I used Haskell for allocate function pointers.
14:27:55 <ephemient> (not in conjunction with Haskell… that seems like a poor use of the power of each language)
14:28:03 <monochrom> heh
14:28:55 <merijn> ephemient: You can generate closures, sure, but those aren't function pointers, just data. I don't think you can generate a function pointer at runtime in C anyway
14:29:10 <merijn> Unless you count dlopen, and even that doesn't "create" them in the sense of needing GC
14:29:20 <ephemient> merijn: libffi generates an executable stub at runtime
14:29:35 <ephemient> and you do have to remember to free them...
14:30:49 <noctux> merijn: well, there are jitting libraries
14:31:31 <noctux> but yeah, the language itself does not provide any way to "create" new code at runtime
14:32:13 <ephemient> it's definitely platform-specific at a minimum
14:35:03 <monochrom> w00t https://www.manpagez.com/info/libffi/libffi-3.0.13/libffi_10.php#The-Closure-API
14:42:44 <noctux> hmm, neither cryptonite nor hsopenssl provide anything in A -> A -> Bool either :/
14:42:49 <noctux> pity
14:44:37 <noctux> oh: https://hackage.haskell.org/package/libsodium-1.0.18.1/docs/Libsodium.html#v:crypto_verify_16
14:44:39 <noctux> nice
14:45:23 <noctux> or even better: sodium_compare
14:46:42 <noctux> well, ok, not sodium_compare. but anyways, locating the correct function to call can be done using libsodiums documentation
14:46:50 <noctux> thanks to you all for the input ;)
14:47:14 <monochrom> noctux: constEq in http://hackage.haskell.org/package/memory-0.15.0/docs/Data-ByteArray.html#v:constEq
14:47:40 <monochrom> Example: the Eq instance for HMAC uses constEq
14:48:51 <monochrom> (HMAC of cryptonite)
14:49:57 <noctux> and that one seems to boil down to http://hackage.haskell.org/package/memory-0.15.0/docs/src/Data.Memory.PtrMethods.html#memConstEqual which does the xor + loop trick again. but yeah, probably good enough
15:21:46 <fuzzypixelz> how would I "split" a string into a list based on a seperating char?
15:22:03 <hpc> @hoogle split
15:22:04 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
15:22:04 <lambdabot> Data.ByteString.Char8 split :: Char -> ByteString -> [ByteString]
15:22:04 <lambdabot> Data.ByteString.Lazy split :: Word8 -> ByteString -> [ByteString]
15:22:10 <koz_> fuzzypixelz: What do you want done when two separating chars are adjacent?
15:22:23 <hpc> too many splits
15:22:53 <fuzzypixelz> koz_: I'm just trying to parse a file where each line has a number into a list
15:23:28 <koz_> What do your lines look like?
15:24:43 <fuzzypixelz> koz_: each line a 4-6 digit intger
15:24:46 <fuzzypixelz> nothing more
15:24:59 <koz_> :t lines
15:25:00 <lambdabot> String -> [String]
15:25:36 <fuzzypixelz> aha
15:36:26 <koz_> :t catMaybes
15:36:28 <lambdabot> [Maybe a] -> [a]
15:36:31 <koz_> Nyaa.
15:38:02 <RENNNN> Hi, I'm trying to find all the nodes such that there exists a path from $ to all those nodes in graph, but i'm having difficulty choosing a datatype. is there an easy, O(n) way to do this?
15:38:10 <RENNNN> i'm having trouble dealing with loops
15:38:36 <koz_> $ is what in this case?
15:38:48 <koz_> How is your graph represented?
15:39:08 <RENNNN> that's the thing, i haven't even started
15:39:08 <fuzzypixelz> I would often want to loop over two list "at the same time"
15:39:30 <monochrom> fuzzypixelz: You can consider zip and zipWith
15:39:31 <fuzzypixelz> as in for i in list1 ... for j in list2 ... do something with i, j
15:39:36 <koz_> RENNNN: A lot depends on your choice of representation.
15:39:49 <koz_> fuzzypixelz: Yep, zipWith or zip are your best friends here.
15:39:53 <fuzzypixelz> monochrom: no like a cartesian product
15:40:04 <fuzzypixelz> all possible pairs
15:40:10 <koz_> fuzzypixelz: (,) <$> list1 <*> list2
15:40:29 <RENNNN> koz_, i have it as an adjacency list
15:40:33 <koz_> There ya go, all possible pairs.
15:40:39 <monochrom> RENNNN: Data.Graph comes with GHC. It has the "reachable" function.
15:40:43 <fuzzypixelz> how does that even work!
15:40:48 <fuzzypixelz> :)
15:40:54 <koz_> fuzzypixelz: The Applicative instance for list?
15:41:21 <fuzzypixelz> koz_: uhh, yes? if that's what it's called
15:41:23 <monochrom> > (,) <$> [1,2,3] <*> "abc"
15:41:26 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
15:41:50 <koz_> fuzzypixelz: Just by the way it defines 'pure' and '<*>'.
15:41:54 <monochrom> tl;dr []'s <*> does cartesian product
15:41:56 <koz_> (and the laws)
15:42:16 <monochrom> List comprehension does, too. [(a,b) | a<-[1,2,3], b<-"abc"]
15:42:49 <RENNNN> monochrom, it doesn't support edge weights
15:43:01 <monochrom> []'s monadness does too.  [1,2,3] >>= \a -> "abc" >>= \b -> return (a,b)
15:58:25 <fuzzypixelz> can I sort of map read :: Int on a list? I hope I'm making sense
15:58:46 <fuzzypixelz> oh wait I'm silly
15:59:13 <monochrom> map read ["123", "456"] :: [Int]
15:59:14 <fuzzypixelz> >map (\x -> read x :: Int) ["13", "42", "2020"]
15:59:21 <monochrom> That too.
16:00:02 <fuzzypixelz> how can you put the :: [Int] at the end?
16:00:07 <monochrom> Or you don't even need to worry about it. If you give that [Int] to some function that requires [Int], type inference will know.
16:00:20 <fuzzypixelz> it is supposed to be at the end of any expression?
16:00:41 <monochrom> yes up to parenthesizing
16:01:06 <monochrom> Perhaps think of :: as very low priority.
16:01:11 <monochrom> err, low precedence
16:05:46 <monochrom> > (((((\x -> x) :: a -> a) :: [a] -> [a]) :: [[a]] -> [[a]]) :: [[Int] -> [[Int]]) []
16:05:48 <lambdabot>  <hint>:1:80: error: <hint>:1:80: error: parse error on input ‘)’
16:05:53 <monochrom> Darn
16:07:03 <monochrom> > (((((\x -> x) :: a -> a) :: [a] -> [a]) :: [[a]] -> [[a]]) :: [[Int]] -> [[Int]]) []
16:07:05 <lambdabot>  []
16:07:07 <monochrom> :)
16:08:44 <monochrom> Ah, I had [[Int] lacking one ]
16:09:50 <fuzzypixelz> uhh, suppose I have functions f1, f2, and f3
16:10:17 <fuzzypixelz> and I want to say f is the function that applies f3 then f2 then f1
16:10:36 <monochrom> f = f1 . f2 . f3 ?
16:10:51 <monochrom> becuase then f x = f1 (f2 (f3 x))
16:10:52 <fuzzypixelz> okay... the dot operator is new to me
16:11:12 <monochrom> You can also just write f x = f1 (f2 (f3 x)) and KISS
16:11:44 <monochrom> Haskell's f . g is math's f ∘ g
16:11:54 <fuzzypixelz> oh yes, I just wanted to define a function and not apply it
16:12:16 <fuzzypixelz> I took up programming because I was tired of doing maths :|
16:12:22 <fuzzypixelz> something like that
16:14:22 <hpc> you may find that you're tired of doing calculation, and math (via programming) is a breath of fresh air ;)
16:22:45 <dolio> Not designing with automatic calculation in mind is one of the fundamental problems with most math.
16:23:52 <boxscape> understandable considering a lot of it was invented before there were practical automata
16:24:47 <dolio> For instance, some of the HoTT people proved "homotopy canonicity" of one of the theories. Canonicity is the thing that computer folks care about, because it says that when you define `M : Nat`, the computer will actually calculate a numeral for you. Homotopy canonicity says that every term is path-equivalent to a numeral, which only tells you that if you already know the answer you want, whatever the computer calculates will be provably equal to the
16:24:47 <dolio>  answer.
16:28:29 <boxscape> so then someone had to invent cubical type theory?
16:28:42 <dolio> Yes, that was invented by people who actually cared about computation.
16:30:21 <dolio> Being prior to automata isn't a very good excuse, really, because it generally seems that it's only been a problem since around the late 1800s or early 1900s, which is roughly the same time people started really getting into automata.
16:30:33 <boxscape> hm, interesting
16:30:54 <boxscape> is the problem you're referring to basically having non-constructive proofs?
16:30:59 <dolio> Yeah.
16:31:44 <fuzzypixelz> why can't I use foldl on a tuple?
16:31:58 <monochrom> You can. At least I can.
16:32:07 <chibi_> Say, what's the best way to program haskell on vim?
16:32:12 <monochrom> So your problem is probably elsewhere.
16:32:13 <fuzzypixelz> >foldl (*) 1 (2, 4, 6)
16:32:27 <boxscape> > foldl (*) 1 (2, 4, 6)
16:32:29 <lambdabot>  error:
16:32:29 <lambdabot>      • Could not deduce (Foldable ((,,) Integer Integer))
16:32:29 <monochrom> Oh, that. Tuple != List
16:32:29 <lambdabot>          arising from a use of ‘foldl’
16:32:36 <monochrom> Use [2, 4, 6]
16:32:43 <fuzzypixelz> uhh
16:32:49 <chibi_> All the guides I see online, even those published this same year are already outdated and don't with the latest version of ghc.
16:32:59 <fuzzypixelz> that's the only way to get a product of the elements?
16:33:29 <boxscape> fuzzypixelz basically, foldl is for containers that contain elements of a single type, but tuples can contain elements of different types
16:33:31 <monochrom> No, 2*4*6 too
16:34:10 <boxscape> fuzzypixelz so you can do it with any such container, e.g. Data.Set and Data.Vector
16:34:14 <monochrom> I trust that you don't have a 10000-tuple, you merely have say a 4-tuple, so don't perfection-OCD it, just write "f (a,b,c,d) = a*b*c*d" and be done.
16:34:32 <fuzzypixelz> I though the type system can infer that my tuple has elements of the same type
16:34:50 <koz_> chibi_: I use ALE.
16:34:53 <koz_> (and Neoformat)
16:34:55 <monochrom> The type system can. But no function uses that information.
16:34:59 <koz_> It does basically everything I care about.
16:35:17 <koz_> It requires some config adjustment but it works pretty well.
16:35:38 <c_wraith> fuzzypixelz: that's the opposite of how it works.  The type system sees that a tuple is allowed to have different types for each element, therefore things that process a tuple aren't allowed to assume they are the same.
16:35:58 <boxscape> fuzzypixelz I think you could technically make a foldable instance for (a,a,a,a) (i.e. for a 4-tuple where every element has the same type), but I suppose it doesn't exist in the base library because it's not a typical use case
16:36:06 <boxscape> or wait
16:36:13 <boxscape> you could only with a newtype around it
16:36:26 <dolio> No, Foldable's argument is * -> *.
16:36:47 <boxscape> write but like `newtype Tuple4 a = Tuple4 (a,a,a,a)` should work
16:36:48 <c_wraith> of course...  libraries can do wacky things
16:36:49 <c_wraith> > productOf each (2, 4, 7)
16:36:51 <boxscape> s/write/right
16:36:52 <lambdabot>  56
16:36:53 <boxscape> -.-
16:37:22 * koz_ . o O ( Tuple4 = Fourple? )
16:37:23 <monochrom> Oh, so you just need lens.
16:37:32 <boxscape> koz_ quadruple
16:37:39 <c_wraith> lens's Each class, in particular.
16:37:41 <koz_> boxscape: I know, let me have my fun. :P
16:37:45 <c_wraith> Which has instances for tuples of all the same type
16:38:06 <boxscape> koz_ we had this discussion in ##adventofcode-spoilers the other day about thruple and triple
16:38:40 <monochrom> Is thruple a Thursday tuple? :)
16:38:40 <koz_> boxscape: Colour me unsurprised.
16:38:51 <koz_> monochrom: Maybe in some households.
16:40:59 <chibi_> koz_: I'll try those two out, thanks
16:41:09 <chibi_> Anything else you'd reccomend?
16:41:37 <koz_> chibi_: I don't really need anything else. I use cabal-fmt and ormolu (cabal-fmt also needs some config twiddling, but not much) with Neoformat.
16:42:39 <chibi_> koz_: Gotcha, thankye.
16:42:51 <dolio> I use hasktags. I think that's the only thing that isn't default vim.
16:42:55 <koz_> You're welcome. If you want my config, I'm happy to share.
16:43:14 <koz_> (I make use of local configs, but if you want all the same settings everywhere it'd work too)
16:50:09 <fuzzypixelz> Anyone want to give feedback/comments/criticism/remarks on my AOC day 1 solution? https://bpa.st/U74Q
16:50:44 <fuzzypixelz> First time writing something in Haskell that isn't a "oh look at this fancy trick" example
16:51:02 <fuzzypixelz> thanks in advance
16:51:08 <fuzzypixelz> :)
16:55:16 <ChaiTRex> fuzzypixelz: It seems like you might be able to reuse a number, like if you had 2 and 1009, you would find 2 + 1009 + 1009 == 2020.
16:55:32 <ChaiTRex> I think `Num a` implies `Eq a`.
16:56:01 <koala_man> fuzzypixelz: did you consider doing it in a single list comprehension, a la [ x*y*z | x <- list, y <- list, z <- list, x+y+z == 2020]?
16:56:34 <ChaiTRex> No, I was wrong, `Num a` doesn't imply `Eq a`.
16:57:10 <fuzzypixelz> koala_man: I wanted to get the entries too, didn't realize I had no use for them until the end
16:57:37 <fuzzypixelz> ChaiTRex: ghc genrated the type signatures
16:58:04 <koala_man> could obviously have been (x,y,z) if you wanted them individually as well, and it would save an explicit filter
16:58:52 <fuzzypixelz> well yeah, there is no need for the filering part as I can see
16:58:53 <ChaiTRex> Oh, OK.
17:00:06 <ridcully> i'd extract the read part (separate it from generating the combinations).  also can you do it agnostic of generating combinations for 2 and 3 elements?
17:02:27 <fuzzypixelz> ridcully: I struggled to get the cartesian product part independent of the number of elements
17:02:42 <fuzzypixelz> ridcully: but the rest should be okay
17:03:12 <ChaiTRex> fuzzypixelz: One way to eliminate a bunch of nested parentheses like `putStr (solution (lines contents))` is to use `.`s between each function and `$` in front of the argument, like `putStr . solution . lines $ content`.
17:03:33 <ChaiTRex> Then it's sort of like an assembly line, where `content` goes through `lines`, then `solution`, then `putStr`.
17:03:43 <glguy> fuzzypixelz, I didn't generate the triples ahead of time so that I could prune some of them out as I went. Doing the read :: String -> Int ahead of time will keep you from duplicating that work once for each triple
17:04:12 <chibi_> You can even not include the argument if you write the function out pointfree and just have a composition.
17:04:16 <glguy> fuzzypixelz, your solution returns triples that can reuse the same element from the list multiple times
17:04:21 <chibi_> Though that depends on what exactly you're doing.
17:05:37 <glguy> https://github.com/glguy/advent2020/blob/master/execs/Day01.hs -- this solution doesn't bother generating the triples at all
18:39:35 <hNoob> I just installed stack for the first time (and did a 'stack update' and 'stack upgrade' just for good measure). When I attempt to install ghc-mod (stack install ghc-mod) it fails because ghc-mod (it decided to get ghc-mod-5.8.0.0) has dependency issues with a bunch of things including Cabal, base, etc. Any insights would be appreciated.
18:46:20 <chibi_> hNoob: ghc-mod is deprecated 
18:46:55 <hNoob> Thank you chibi_
19:19:16 <guest1216> if there're two parser, how to concat them? I mean let the second parser work on the result of the first one
19:20:00 <guest1216> removeSpace = spaces *> many (anyChar <* spaces)
19:20:07 <guest1216> p8 :: Parser [String]
19:20:41 <guest1216> p8 = {do; x <- many letter; char '='; y <- many letter; return [x,y]}
19:21:20 <dsal> You can push the result back into the parser state with megaparsec, but it's a bit weird.  Why not just do the right thing the first time?
19:21:30 <guest1216> parse (removeSpace *> p8) "" "ab = cd"  /= Right ["ab","cd"]
19:22:17 <guest1216> (Right (parse p8 "")) <*> (parse removeSpaces "" " a = b") ==  Right (Right ["a","b"])
19:22:24 <guest1216> but this is ugly...
19:22:44 <guest1216> dsal: more specific?
19:23:43 <dsal> If you want space consumed lexemes, that's lexeme here:  https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec-Char-Lexer.html
19:23:58 <jle`> looks like you're talking about mutli-stage parsing
19:24:27 <guest1216> jle`: remove spaces first, then split by '=' into a list
19:24:27 <jle`> but working with parser combinators, it is sort of designed to not require it if you are able to phrase your main problem in a parser combinatory way
19:24:41 <jle`> yes, that's what i mean. that's multi-pass/multi-stage parsing
19:25:07 <jle`> but that's not really how you're "supposed" to use parser combinators, in the general wisdom
19:25:14 <jle`> these days it's considered unidiomatic
19:25:14 <dsal> for that exact expression, a list seems weird.  I'd just do something like  `liftA2 (,) (lexeme word <* lexeme "=") (lexeme word)`
19:32:29 <guest1216> p8 = {do;    spaces;    x <- many letter;    spaces;    char '=';    spaces;    y <- many letter;    spaces;    return [x,y]} 
19:32:29 <guest1216>  
19:32:41 <guest1216> this one can do that
19:33:05 <jle`> right, there is usualyl a way you can rephrase your program to not require multi stage parsing
19:33:28 <dsal> A list feels pretty wrong there, still.  Why would you use a list of two items vs. a tuple?
19:34:13 <RENNNN> what's the easiest to use implementation of dikstra?
19:34:14 <dsal> `lexeme` is basically `spaces *> x <* spaces` so you can just drop it in places where spaces are optional.
19:34:17 <RENNNN> on cyclic graph
19:35:18 <guest1216> dsal: ok, I will change it to a tuple
19:36:26 <dsal> guest1216: tuple also means you can do the liftA2 thing there if you want.  e.g., `p8 = liftA2 (,) (lexeme word <* lexeme "=") (lexeme word) where word = many letter`
19:38:59 <guest1216> dsal: what's x in `spaces *> x <* spaces`?
19:39:07 <dsal> x is the parser you want between the spaces.
19:39:48 <guest1216> parse (spaces *> many letter <* spaces) "" "a = b" == Right 'a'
19:40:25 <guest1216> dsal: should I use many anyChar?
19:40:36 <dsal> Yes, but you can name `spaces *> x <* spaces`  `lexeme x = spaces *> x <* spaces` and then just type  `lexeme (many letter)`  (or use the one in Text.Megaparsec.Char.Lexer
19:40:37 <dsal> )
19:41:13 <dsal> `many anychar ` might not do what you want.  There are combinators like `manyTill`, but `many anyChar` will basically eat the rest of your input.
19:41:18 <guest1216> dsal: I'd like to try Text.ParserCombinators.Parsec first
19:41:28 <dsal> I usually use something like `satisfy` 
19:43:05 <dsal> Oh, I just looked at the source.  lexeme is actually: `lexeme spc p = p <* spc`
19:43:08 <MarcelineVQ> idk if it's typical to consume the following spaces when lexing
19:43:19 <MarcelineVQ> oh huh :>
19:43:51 <dsal> It makes more sense to me to consume from the left.  I guess that's worth knowing.
19:44:17 <dsal> I remember in the past getting confused and just shotgunning lexeme all over my code.
19:48:54 <dsal> I still find Haskell easier to read than English.  If I'd've read that code a long time ago, I'd've been less confused.  The *parameter* doc says it's for the whitespace after the lexeme, but function doc doesn't make that obvious.
19:49:53 <guest1216> dsal: that lexeme is only in megaparsec? not in pasec?
19:50:24 <dsal> I don't know that anyone's used parsec in a long time, but that's the actual code for it there, so you can make your own.  :)
19:51:10 <guest1216> haha, but parsec comes with ghc, so I like to try the old one first then others
19:53:06 <monochrom> MarcelineVQ: There is a convention that each parser holds the invariant "consume spaces after the stuff I need", therefore "when I start I can assume no space before the stuff I need".  There is a global do-once "slurp beginning spaces" to kickstart the invariant.
19:53:42 <monochrom> Basically parsec's Token module started that convention.
19:55:36 <monochrom> I guess ReadS started that convention actually.
19:56:59 <monochrom> Err no, ReadS didn't. (Or, Prelude.lex didn't.)
19:58:19 <monochrom> > lex "   abc   "
19:58:21 <lambdabot>  [("abc","   ")]
19:59:08 <glguy> consuming spaces after lexing a token is particularly useful for parsec where consuming any input has an effect on backtracking
19:59:22 * Maxdamantus always thought it made more sense to read at the start rather than at the end.
19:59:22 <monochrom> Yeah.
19:59:44 <glguy> so you don't want your lexeme parsers eating whitespace only to fail at parsing a lexeme
20:00:13 <glguy> nor do you want every alternative to have to reprocess the same whitespac
20:01:23 <Maxdamantus> since nothing comes before the first thing to consume any leading whitespace, and trailing whitespace gets consumed by the EOF parser.
20:02:17 <glguy> all the other factors end up being much more important than that
20:03:05 <glguy> ideally you're just using an actual lexing pass, anyway
20:03:50 <dsal> It's not lexec
20:25:10 <steve-chavez> Hello. While trying to upgrade cabal with `cabal install cabal-install`, I get a `unknown package: lukko` error. Does anyone know how to solve that?
20:26:06 <steve-chavez> cabal install lukko tells me there's no package lukko..
20:28:41 <glguy> steve-chavez, You can upgrade your cabal-install with ghcup
20:29:02 <glguy> steve-chavez, you might have to run 'cabal update' for it to see that package
20:29:55 <steve-chavez> Yes, I've done cabal update before. Will ghcup work on aarch64?
20:31:15 <steve-chavez> Just got ghc 8.8.3 working on ubuntu aarch64. If possible I'd like to compile cabal from source..
20:33:11 <glguy> I have no idea
20:33:38 <MarcelineVQ> dsal, monochrom: It does make sense, I wasn't thinking
20:34:00 <dsal> The backtracking thing made sense.
20:43:53 <remexre> is there something like Functor+Foldable for containers with a fixed element?
20:44:30 <jle`> fixed element?
20:44:39 <MarcelineVQ> like monofunctor or something?
20:44:40 <remexre> uh like, specialized containers, e.g. IntVector
20:44:55 <remexre> ah yep that looks like it
20:44:55 <jle`> maybe mono-traversable
20:44:57 <remexre> thanks!
20:44:59 <jle`> mono-foldable
21:48:32 <guest1216> why there's no splitOn and splitWith in Data.List?
21:49:01 <guest1216> I know there's Data.List.Split, but why it doesn't come with ghc?
21:49:48 <guest1216> and yeah, they're in Data.Text, but if we want to operate on String, we have to unpack String to Text?
21:56:58 <maerwald> steve-chavez: not yet (wrt aarch64), but should be possible, since there are already debian aarch bindists and cabal ones as well
21:58:40 <maerwald> https://oleg.fi/cabal-install-3.4.0.0-rc4/cabal-install-3.4.0.0-aarch64-ubuntu-18.04.tar.xz
21:58:47 <maerwald> https://downloads.haskell.org/~ghc/9.0.1-alpha1/ghc-9.0.0.20200925-aarch64-deb9-linux.tar.xz
22:02:46 <steve-chavez> maerwald: Whoa.. thanks! Hope that cabal-install 3.4 works with ghc 8.8.2.. 3.2 didn't ..
22:02:59 <steve-chavez> Because of https://github.com/haskell/cabal/issues/6327
22:08:16 <steve-chavez> 3.4 contained a cabal binary! Hope I can compile my project now.. (crossing fingers)..
22:32:58 <koz_> maerwald: The oleg.fi download of cabal-install-3.4.0.0 blows up when ghcup tries to cURL it down.
22:38:58 <maerwald> koz_: how is that
22:39:31 <koz_> Where's tomsmeding's pastebin link gone...
22:39:56 <int-e> @where paste
22:39:56 <lambdabot> Help us help you: please paste full code, input and/or output at eg https://paste.tomsmeding.com
22:40:18 <int-e> . o O ( I
22:40:23 <koz_> maerwald: https://paste.tomsmeding.com/Ky4SpOIX
22:40:26 <koz_> Like that.
22:40:49 <int-e> . o O ( I'd update @paste but we seem to be changing pastebins more frequently than I'm updating lambdabot :-/ )
22:41:14 <koz_> This is not specific to my machine (I've reproed it in at least two places), my cURL works fine on every other site, and every other version of cabal (when installing via ghcup).
22:41:38 <koz_> int-e: Are you in charge of lambdabot?
22:41:48 <koz_> If so, could you update @unmtl with more transformers?
22:41:51 <maerwald> internet is broken then I guess
22:42:17 <koz_> maerwald: I think it's an issue with oleg.fi honestly.
22:42:24 <koz_> Figured I'd run it by you first.
22:42:44 <int-e> koz_: maybe?
22:42:52 <maerwald> the certificate has no issuer name it seems
22:44:13 <koz_> int-e: Maybe you're in charge, or maybe you could update @unmtl with more transformers?
22:46:11 <int-e> I'm in charge. I may get around to adding something to @unmtl
22:46:46 <koz_> int-e: OK, thanks!
22:46:56 <koz_> Main one is ExceptT.
22:47:55 <int-e> that one is actually in the repo version, just never got around to rebuilding the thing, it seems
22:52:34 <int-e> koz_: so since you brought it up, what are the others?
22:53:03 <koz_> int-e: That was basically the only one I need.
22:53:22 <koz_> I recall other folks mentioning some more, but that's the main one for me.
23:05:07 <guest1216> how to match a continuum string? letter can't match abc.cdef
23:06:15 <koz_> "Continuum string" sounds like a physics term. :P
23:07:06 <guest1216> I don't know how to describe it, a string without spaces
23:07:36 <guest1216> a continuum non-space char?
23:16:13 <MarcelineVQ> you're​mad​completely​mad​and​I​won't​have​it
23:16:32 <steve-chavez> maerwald: It worked! Thank you so much man.. you saved me!
