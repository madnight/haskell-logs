00:00:02 <koz_> Yeah, it's a clever hack.
00:00:06 <jle`> also... `instance Bits (Vector Bit)`
00:00:08 <jle`> dang
00:00:14 <koz_> Yup.
00:00:19 <koz_> Bodigrim did the work.
00:00:34 <jle`> <3
00:00:43 <koz_> So basically if you want FinitarySet, that's how I'd go about it.
00:01:04 <koz_> Amusingly, if you want to galaxy brain it up, you can do FinitaryMultiMap a b.
00:01:09 <koz_> (by using a bitmatrix)
00:02:00 <koz_> Also makes me wonder if a MutableFinitarySet m a is a worthwhile idea.
00:02:14 <koz_> (and if so, it needs a better name)
00:06:54 <jle`> the possibilities are endless
00:07:40 <koz_> The multimap is the one I question the most.
00:07:48 <koz_> It's cute, but it doesn't seem terribly useful.
00:08:02 <koz_> (and it's not likely very efficiently packed either, because that matrix is likely sparse AF)
00:08:36 <koz_> You can probably use some kind of sparse matrix representation I guess?
00:10:24 <jle`> hm...
00:10:33 <jle`> i'll start with maybe implementing the finitary set for this specific application
00:10:38 <jle`> and then see if it would be helpful to generalize :O
00:10:47 <iqubic> Which application is it? Letters?
00:11:04 <koz_> Also, do we even have Haskell librar{y,ies} for sparse matrices?
00:11:21 <jle`> koz_: i use Map (a,a) heh
00:11:27 <iqubic> Erm... I mean, is this a Letters Set thing?
00:11:29 <jle`> but hmatrix might expose one
00:13:42 <koz_> jle`: Not as far as I can tell.
00:15:08 <jle`> koz_: https://hackage.haskell.org/package/hmatrix-0.20.1/docs/Numeric-LinearAlgebra-Data.html#v:mkSparse
00:15:34 <koz_> Ah, never mind then, guess it does exist.
00:16:14 <jle`> but it's not really usable i think...it's mostly internal/for testing
00:16:22 <jle`> :(
00:17:38 <koz_> There's also a range of representations possible for sparse matrices.
00:17:44 <koz_> It depends on what you wanna be able to do.
00:18:08 <iqubic> jle`: What is this for? Is it Advent Of Code related?
00:40:54 <jle`> iqubic: yeah it's a byte-backed set
00:42:51 <iqubic> Are you going to be releasing this onto hackage?
00:44:18 <jle`> unsure at the moment
00:55:02 <Guest40272> hi
01:26:50 <hyiltiz> anyone with any experience/comment on the roundtrip (-string or -aeson) library? It seems like it is rarely used by any other packages, and mostly remains as an academic exercise, no?
01:30:31 <maerwald> what library?
02:05:06 <tomjaguarpaw>  https://hackage.haskell.org/package/roundtrip https://hackage.haskell.org/package/roundtrip-aeson and https://hackage.haskell.org/package/roundtrip-string, presumably
02:37:21 <justinthong> hi @tintinthong
04:07:52 <nf> cross-post from #haskell-lens: if i have a getter and a setter for Set (  folded  and  sets Set.map  respectively), can i turn them into a single "thing" that i can use (^..) and (%~) on? (preferably using microlens)
04:11:25 <kuribas> nf: you want to traverse the Set?
04:12:03 <nf> i don't know
04:12:13 <nf> i want to combine these two actions into one "thing"
04:12:22 <nf> is that a traversal? is there something intermediate?
04:13:24 <kuribas> not sure that satisfies the lens laws...
04:15:08 <kuribas> https://hackage.haskell.org/package/lens-4.16/docs/Data-Set-Lens.html
04:16:21 <kuribas> it looks like setmapped is what you want
04:16:47 <nf> that's only the setter part, not the getter
04:16:54 <nf> "Sadly, you can't create a valid Traversal for a Set"
04:17:05 <kuribas> indeed
04:17:22 * nf checks the Traversal laws
04:18:22 <nf> i guess the issue is the lack of an Ord constraint
04:18:36 <nf> but i'm working with a single known type so maybe i can circumvent that
04:18:48 <kuribas> no, the issue is that the set can shrink when mapping it.
04:19:09 <kuribas> you can make an unlawful traversal though...
04:20:26 <nf> ooh and that violates the second law because some effects could be executed less times than required? i think i get it
04:29:19 <kuribas> "The laws for a Traversal t follow from the laws for Traversable as stated in "The Essence of the Iterator Pattern"."
04:29:26 <kuribas> fmap (t f) . t g â‰¡ getCompose . t (Compose . fmap f . g)
04:29:35 <kuribas> "One consequence of this requirement is that a Traversal needs to leave the same number of elements as a candidate for subsequent Traversal that it started with. Another testament to the strength of these laws is that the caveat expressed in section 5.5 of the "Essence of the Iterator Pattern" about exotic Traversable instances that traverse the same entry multiple times was actually already ruled out by the second law 
04:29:35 <kuribas> paper!"
04:30:01 <kuribas> http://hackage.haskell.org/package/lens-4.19.2/docs/Control-Lens-Traversal.html
04:31:58 <nf> i just read https://artyom.me/lens-over-tea-2#traversal-laws, i'll read that now
04:44:10 <nf> is this proved somewhere? that the 5.5 caveat was already excluded by the second law?
04:47:39 <nf> i guess if i don't care about being lawful i can always do  fmap Set.fromList . traverse f . Set.toList
04:52:48 <kuribas> yes
05:49:16 <dminuoso> Mmm. Bidrectional pattern synonyms or prisms...
05:49:44 <dminuoso> Seems like prisms are just more potent since you parametrize your code over arbitrary prisms.
05:50:01 <dminuoso> You *can
05:52:00 <[exa]> prisms!
05:52:04 <__monty__> Is there another name for `concatWith :: (a -> a -> a) -> t a -> a` as a generalisation of mconcat?
05:53:08 <__monty__> Oh, that's just foldr1, isn't it?
05:54:14 <dminuoso> Not quite
05:54:26 <dminuoso> foldr is the generalization
05:54:39 <dminuoso> With mconcat you have the implicit argument of foldr already
05:55:03 <dminuoso> So a true generalizatoin of mconcat would be `concatWith :: (a -> a -> a) -> a -> t a -> a`
05:55:05 <dminuoso> % :t foldr
05:55:05 <yahb> dminuoso: Foldable t => (a -> b -> b) -> b -> t a -> b
05:55:27 <dminuoso> (because what does mconcat do on an empty list?)
05:55:29 <zangi> > map (+1) [1..10]
05:55:31 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:55:39 <zangi> @
05:55:49 <zangi> @help
05:55:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:55:55 <dminuoso> [exa]: Yeah Im thinking prisms too.
05:55:58 <zangi> @list
05:55:58 <lambdabot> What module?  Try @listmodules for some ideas.
05:56:08 <zangi> @help list
05:56:09 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
05:56:09 <__monty__> dminuoso: Yep, you're right, I did realize that when writing it. Partiality is why I usually pretend foldr1 doesn't exist.
05:56:18 <zangi> list
05:56:31 <dminuoso> zangi: You can chat with lambdabot in a private message/query
05:56:39 <dminuoso> For experimentation 
05:57:02 <zangi> dminuoso: how? I'm new to irc
05:57:14 <dminuoso> zangi: Which IRC client do you use?
05:57:21 <zangi> weechat
05:57:23 <xsperry> try /query lambdabot
05:58:19 <__monty__> dminuoso: In this case though I need a different base case for an empty list than a full list, `[] -> S.empty; as -> foldr1 S.intersect as`
05:59:26 <dminuoso> __monty__: That's no longer mconcat then.
06:01:24 <__monty__> Yeah, my mistaken reasoning was "Hmm, I want to mconcat this list of Sets with intersection."
06:03:55 <toast52> Hey I'm a long time stack user but in my new setup I'm trying out ghcup + cabal 
06:04:00 <ephemient> https://mail.haskell.org/pipermail/libraries/2020-December/030951.html
06:04:30 <toast52> I'm not sure how to do things with the cabal new commands
06:04:46 <merijn> toast52: Can you be more specific? :)
06:05:10 <toast52> with stack you specify src directory where all your modules go, and to add dependencies just edit the package.yaml right?
06:05:17 <toast52> Whats the equivalent in cabal
06:05:34 <toast52> and should I use the v2 commands, the new commands or just the bare commands?
06:05:48 <merijn> toast52: Do you have cabal-install 3.0 or later?
06:06:00 <__monty__> toast52: For cabal 3.0+ those are all the same commands.
06:06:00 <toast52> Yeah I believe I am on 3.2.0.0
06:06:04 <merijn> (probably yes, but best to check)
06:06:16 <merijn> toast52: From 3.0 on the commands *are* the v2 versions
06:06:33 <ephemient> if you're using ghc 8.10+, you don't have any choice but cabal 3.2+ anyhow :D
06:06:34 <merijn> toast52: v2 is just around for scripts that need to be compatible across multiple cabal versions
06:06:47 <merijn> toast52: Anyway, lemme first point you here: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
06:06:56 <__monty__> new-* is only around for hysterical raisins, v2-* is an immutable reference so to speak, the others are shorter for interactive use.
06:07:56 <__monty__> ephemient: Some important distros don't update GHC all that fast, debian for example.
06:08:28 <ephemient> __monty__: toast52  mentioned ghcup so presumably they're not relying on the distro ghc anyhow
06:09:11 <toast52> so with cabal-install do we modify the cabal file directly?
06:09:16 <merijn> toast52: Yeah
06:09:35 <ephemient> you could still use hpack if you want, you just have to run it manually
06:09:36 <merijn> You can use "cabal init --interactive --cabal-version=3.2" to create a new one from scratch
06:09:40 <__monty__> ephemient: Though since they're migrating from stack they might want to stick to the latest LTS compiler.
06:10:33 <merijn> ephemient: But you shouldn't, because hpack is bad :D
06:13:16 <toast52> hmmm. cabal install is used to install libraries or executables globally right
06:13:31 <merijn> toast52: tbh, only executables
06:13:41 <toast52> do nix style builds share libs?
06:13:53 <merijn> toast52: Yes, when possible
06:15:04 <merijn> toast52: Basically, there's a single global store (in ~/.cabal/store/ghc-version) and every library that gets installed gets tagged with a hash of its version, flags, config and transitive dependencies and installed there. If two packages/projects/whatever use the exact same configuration they will reuse the existing install.
06:15:31 <merijn> toast52: So you can have, essentially, infinitely many different versions/configurations of any package without conflicts
06:17:18 <toast52> Ok I think I more or less get it. Last question: In stack we just declare the src directory and have as many modules inside as we want. But it appears in a cabal file each module must be declared in other-modules?
06:18:04 <ephemient> https://github.com/haskell/cabal/issues/5343
06:18:37 <merijn> toast52: For libraries You've got "exposed-modules" these are what other packages can access and "other-modules" (these are internal). For executable you have Main and "other-modules"
06:18:52 <merijn> ephemient: It's not happening
06:19:10 <ephemient> right, I think there's decent justification in the linked issue
06:20:27 <merijn> Like, I get why people find it annoying to manually list modules. But sometimes you gotta trade off immediate convenience for future sanity. But that's apparently a hard thing to accept for many people :p
06:21:37 <ephemient> well, pretty much the only haskell code I work on these days is for advent of code, and I only need to keep it running for a month. so I have sympathy for that too
06:23:24 <merijn> ephemient: tbh, I also feel people *massively* overstate how annoying it actually is
06:25:39 <merijn> ephemient: My biggest project is about 110 files/modules big, but it's not like you're writing those out every day. You start with a handful and incrementally add a few every few days or something. And if you important existing code you can just quickly sed it in once. In practice it's just not that big a deal
06:26:24 <ephemient> it might also be a matter of what other systems people came from
06:27:05 <ephemient> build systems for C/C++ tend to require being explicit, and Rust's modules are also completely explicit, but Java and JS are typically always automatic discovery
06:27:19 <merijn> ephemient: A lot of systems do, in fact, go for immediate convenience over long term sanity, which is why Python is on their, like, 15th package manager and it's *still* a pain :p
06:38:00 <toast52> But specifying the src directory is still pretty explicit no?
06:38:49 <toast52> In fact Haskell's unqualified imports by default are a pretty good example why implicit is bad imo
06:40:04 <merijn> toast52: There's actually a better explanation why not to do that here: https://github.com/haskell/cabal/issues/7016#issuecomment-678609993
06:40:48 <toast52> ahhh. That's true. I guess thats the point of something like hpack
06:41:08 <toast52> so the reference cabal file is still there
06:41:23 <toast52> while its painless to add modules
06:41:52 <toast52> not that adding a line to the cabal file is a pain really. I guess I'm just unused
06:43:31 <toast52> its just my prior experience telling me that these config files are usually not manually edited but handled by the CLI tool
06:43:44 <merijn> toast52: As phadej points out in the issues, he's not opposed to a "cabal update-modules" command which dynamically updates the list in the cabal file explicitly (which is sorta what "cabal init" already does)
06:44:18 <merijn> But the cabal codebase is...kinda legacy, so such command isn't trivial to implement :)
06:46:00 <merijn> The basic tension point is that for *developers* it's easy to have everything automatic and never have to do everything. But for *packaging*, especially long term archiving and distribution on many systems having everything *explicit* (locations, modules, flags, options, etc.) makes live much easier
06:46:55 <merijn> If you look at for example Python, Ruby, JS, etc. developing is easy, but packaging is such a nightmare that the "normal" default way to do it now is "ship an entire docker container, because we have no clue which files need to be packaged"
06:47:25 <dcoutts> merijn: btw, I was looking at the Cabal lib codebase last night. It's surprisingly clean. Oleg, Mikhail and others have done a great job there.
06:47:34 <toast52> Yeah I get that
06:47:58 <merijn> dcoutts: It's getting better, for sure. But it has quite a road to go :p
06:48:29 <toast52> Maybe I'm clueless here but my impression was that that's what lock files are for
06:48:41 <merijn> The problem is we only have one Oleg and one hvr to help people get up to speed :)
06:48:49 <dcoutts> I think one of the hard things is going to be ditching legacy features, like migrating away from build-type Custom.
06:48:55 <hpc> arguably, for developers it's easier to be explicit too - i am constantly running into issues where i am unable to build working git-cloned code
06:48:57 <merijn> Which bottlenecks the influx of people helping :)
06:49:03 <merijn> hpc: Sure
06:49:16 <merijn> hpc: But it's hard getting that through their skulls ;)
06:49:17 <dcoutts> And people kicked up quite a stink when Oleg wanted to remove the cabal sandbox feature (that's subsumed by the v2 features)
06:50:15 <merijn> dcoutts: Well, the problem is that until the environment stuff is finished and gives people a nice way to install libs into a semi-global environment there's some workflows underserved and cabal sandbox + v1 could be used to deal with that
06:50:52 <merijn> dcoutts: Lots of beginners want to "just install quickcheck and play in ghci" and that is currently, unfortunately, rather cumbersome
06:51:13 <dcoutts> fair enough, but that's what we have to push on to be able to reduce complexity
06:51:19 <merijn> But yeah, I think for "real" work v2 completely obsoletes sandboxes
06:51:47 <merijn> dcoutts: Sure, I'm not disagreeing with the choice nor disparage the minor miracles Oleg is achieving :)
06:52:19 <merijn> dcoutts: It's just unfortunate to not have a good story for beginners wanting to play in ghci
06:52:41 <hpc> sudo apt install libghc-quickcheck2-dev # :D
06:52:50 <dcoutts> indeed, and the v2 design is intended to be able to cover those use cases too
06:53:36 <merijn> dcoutts: I mean, you're preaching to the choir with me, I dropped sandboxes and all my hdevtools based editor tooling back in 2016 just so I could use v2-build :p
06:53:54 <merijn> And only this year with ghcide has my editor started recovering :p
06:54:08 <dcoutts> :-)
06:54:41 <toast52> Honestly I had no problems in the past simply installing ghc to use ghci, nor simply "upgrading" to stack and using stack repl
06:54:49 <toast52> I would say it is pretty easy to get started
06:55:32 <merijn> toast52: Yeah, but with v2 there isn't a super good story for "globally install this library to play with" the easiest (implemented) workflow is "just define a cabal package and use that"
06:56:25 <merijn> Which isn't too bad, almost anything with more than 2 modules or any dependencies should have a cabal file anyway, but it's not great for beginners who know feel like they first need to learn cabal-install before they can get to the fun coding
07:03:59 <adamCS> Related: Even as a somewhat experienced coder, the overhead of new cabal-file, etc. often leads me to jam vaguely-related-things into an existing library until it's obviously silly and then split it out, rather than start it on its own.  Which is my problem, I know, but I would love an easier path for that too.  Also not complaining!  Cabal has come so far!  
07:04:23 <merijn> adamCS: to be fair, that doesn't sound necessarily as a bad thing
07:07:17 <adamCS> merjin: Sometimes.  But it's often sub-optimal, especially since by the time I realize I need/ought to split it out, I'm often no longer as immersed in it and it also makes one less disciplined about keeping dependencies down, etc.  I guess if I had good practice about a couple more things it might all make me less grumpy.
07:07:24 <adamCS> merijn: ^
07:07:26 <adamCS> sorry
07:08:32 <merijn> adamCS: Well, if you're no longer as immersed in it nor planning to reuse it, is there really any point in cleaning it up/splitting it off?
07:09:50 <merijn> Like, that just sounds like "in retrospect I am not quite happy with my final choice of architecture", but if the code is abandonned then that's just "I have progressed and learned" rather than something that actually needs to be cleaned up? :)
07:11:00 <merijn> In the past decade I've only split off and packaged, like, 4 packages. 3 of which are only a single module.
07:11:25 <merijn> No point in packaging things unless you actually plan to reuse them :p
07:11:26 <adamCS> merijn: Right.  But the case I run across is not-immersed but often-using.  So I maybe want to put on hackage or just keep cleaner boundaries and think harder about abstractions.  But now it's sort of lazily intertwined.  So the energy required to get it right is higher than it would've been if I'd kept it clean from the jump.  But you may be right, that the cost is recouped over all the times that code ends up abandoned.
07:13:09 <adamCS> merijn:  Yeah.  Perhaps what I am saying is that I wish the new-library route was just easy enough to inspire me to be a more disciplined coder in the first place.  Which I stand by!  But am also slightly ashamed of.  Sigh.  
07:13:37 <merijn> adamCS: I mean, you can now split off into a separate library in the same package as a sort of intermediate step!
07:14:16 <adamCS> merijn: Yes!  I haven't tried that yet but it might be the ticket.
07:14:35 <merijn> adamCS: You can have multiple (internal) libraries in a package in more recent cabal-install's, so you can "split it off, while still keeping it in", which makes splitting it off into a proper package easier
07:16:14 <adamCS> merijn: Yeah.  I have a good test case for that which is approaching the, gosh why is this in the same place as everything else, stage.  Maybe I will try an in-package split to learn how. Thanks!
07:57:23 <zincy__> What are the main advantages of separating pure from impure code? In Haskell this really means monadic vs non-monadic right as opposed to pure/impure? Pure code is easier to reason about and easier to test, is there anything else? 
07:57:47 <dminuoso> That's it, pretty much.
07:57:56 <merijn> zincy__: Nitpick: There is no impure code in Haskell (ignoring unsafe*), that's the entire point of having IO in the first place
07:58:27 <merijn> People like to say "impure" when they mean "IO based", but IO *isn't* impure, that's the entire point
07:58:41 <dminuoso> zincy__: Equational reasoning is priceless, it happens in all of our heads constantly.
07:58:52 <dminuoso> Even in yours.
07:58:58 <dminuoso> It might be as simple as
07:59:17 <merijn> Equational reasoning is great, and the entire benefit of having IO as type is that it doesn't break purity and just allows you to keep equational reasoning
07:59:52 <dminuoso> "transforming `f x y (g a b) (g a b)` into `let g' = g a b in f x y g' g'` is legitimate because of the properties of haskell
08:00:14 <dminuoso> Its little things of refactoring you probably do every day already
08:01:59 <zincy__> merijn: Yeah I am aware of this nitpick :)
08:02:09 <merijn> zincy__: It's an important one, though :)
08:02:23 <riko> What did the "makers of Haskell" think of allowing such mutually recursive definitions?
08:02:27 <riko> f = g
08:02:29 <zincy__> I was wondering do people mean IO or monadic code in general when they say "impure"?
08:02:32 <riko> g = f
08:02:38 <zincy__> In fact screw what people say
08:02:44 <merijn> riko: I mean you can even skip a step there
08:02:46 <dminuoso> riko: it's things like `repeat`
08:02:52 <merijn> > let f = f in f
08:02:55 <lambdabot>  *Exception: <<loop>>
08:03:12 <merijn> riko: The reason to allow that is because you can do incredibly useful things like:
08:03:13 <dminuoso> riko: f = g; g = f is allowed just because it wouldnt make sense to forbid it, and detecting when to forbid is is impossible in the general case
08:03:16 <dminuoso> (because halting problem)
08:03:17 <merijn> > let ones = 1 : ones in ones
08:03:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:03:30 <zincy__> We should strive to separate effectful (monadic) code from non-effectful (non monadic) code right?
08:03:35 <riko> when I query the type, I get f :: t
08:03:36 <riko> and in GHCi the call does not terminate. very strange: D
08:03:51 <merijn> zincy__: meh
08:04:01 <merijn> zincy__: Not really, imo
08:04:13 <zincy__> Ok what if you specialise that argument to IO
08:04:18 <merijn> zincy__: https://twitter.com/k0001/status/1295846402648682496 :)
08:04:20 <zincy__> Separate IO from non IO
08:04:54 <merijn> zincy__: Separating IO from non-IO is generally good. But I feel many beginners over value it, to the point where it harms their productivity
08:05:30 <merijn> Writing Haskell with IO everywhere >> getting stuck unable to anything using Haskell :)
08:05:36 <zincy__> This begins to become a tricky nuanced rule the "pure core/imperative shell" mindset. Since everything is pure
08:05:39 <zincy__> I am confused
08:06:21 <merijn> zincy__: I write lots of concurrent/network-y/file-y/spawning other process-y code. It has IO everywhere and it's perfectly pleasant to work with
08:06:54 <zincy__> So there is no cast iron rule saying thou shalt split IO code from non-io code where possible
08:06:55 <merijn> zincy__: My point was simply that "writing code" >> "worrying about how you should be writing code" in terms of both productivity and learning :)
08:07:09 <zincy__> hehe :D
08:07:43 <merijn> zincy__: Is overuse of IO "not great"? Sure. But the best way to figure out why/when it sucks is to just write it and find out the hard way
08:07:54 <zincy__> Isn't there a big argument for this separation because then you can rely less on mocking?
08:08:01 <merijn> Does it help to stop and think if you can split the IO and logic? Sure it does!
08:08:14 <ephemient> even when mutability is required, plenty of stuff works fine in ST
08:08:30 <merijn> But you know, sometimes you wanna have a feeling of actually *doing* something and doing *something* with IO everywhere is better than *not* doing it :)
08:08:32 <ephemient> free tries to get you the best of both worlds, being pure and providing access to IO equivalents
08:08:37 <merijn> ephemient: Sure
08:09:31 <merijn> ephemient: But so many beginners get paralysed by this idea of "avoiding IO at all costs", I think it's much more helpful in "unstucking" people to help them realise there's a time and place for everything and there's nothing wrong with "imperative Haskell" :)
08:10:31 <ephemient> I think it depends on the code
08:10:48 <ephemient> if IO is the only monad you're working with, then yeah it's not so bad
08:10:52 <zincy__> Code with IO is harder to test
08:11:15 <merijn> Same thing I keep saying about converting C people, maybe instead of focussing on "how safe" haskell is, we should be telling them how unsafe you can be if needed! unsafeCoerce, unsafePerformIO, accursedUnutterablePerformIO! So many escape hatches and unlifted types for your high performance needs!
08:11:18 <zincy__> So minimising the surface area of IO does make your program easier to test
08:11:38 <zincy__> merijn: I like that argument
08:11:39 <merijn> zincy__: Sure, but you find that out quick enough when writing IO heavy code and you will have learned something :)
08:12:22 <zincy__> Right so when it comes to learning just take action is the general motto
08:12:23 <merijn> zincy__: Once you "give up" on being pure all the time and start writing code you will quickly find that actually a lot of your code is *still* pure and get a better sense of managing where/when of IO
08:12:24 <ephemient> if it's performance you're after, though... haskell IO isn't great
08:12:33 <merijn> ephemient: pfft
08:12:35 <merijn> ephemient: It's fine
08:12:38 <ephemient> it forces sequencing where equivalent code in C would allow for reordering
08:12:51 <dolio> How do you know?
08:13:11 <merijn> ephemient: You can almost never reorder C and the place where you can the same can easily happen with IO
08:13:32 <ephemient> IORef can not be reordered
08:13:46 <ephemient> memory reads/writes, up to memory barriers, can
08:13:56 <merijn> ephemient: Neither can accesses in C within a single thread
08:14:06 <merijn> And if you're writing threaded C you're already fucked :p
08:15:00 <ephemient> C compiler is allowed to move, repeat, and elide memory access as it wants, as long as single-threaded observed behavior is equivalent
08:15:12 <ephemient> e.g. it may reload, or it may lift stores and loads
08:15:46 <ephemient> IORef is forced by IO's sequencing to be... well, sequential
08:15:59 <merijn> "kinda"
08:16:25 <merijn> Because then you get in the murky waters of CPU guaranteed consistency models :p
08:16:33 <dolio> ephemient: This is false.
08:16:58 <dolio> It's like saying that C can't reorder things because you typed it into the file in a certain order.
08:17:51 <adamCS> When I started writing Haskell, a lot was in IO.  Understanding how to move much of it out was the first time I had an assortment of "aha!" moments about functor and monad.  There were more to follow, to be sure. Since IO is comparatively opaque, you really want to get things out of it sometimes so you figure out how when it wasn't necessary in the first place.  And that is educational.  Or it was for me, anyway.
08:19:38 <ephemient> c <- newIORef 0; forM_ [0..9] $ \i -> readIORef c >>= print
08:19:42 <ephemient> vs static int c; for (int i = 0; i < 10; i++) printf("%d\n", c);
08:33:07 <lightwave> Stack newbie question: I tried to 'stack install cabal-install' but got the following error.  What do I do to resolve the version conflict/requirement?
08:33:17 <lightwave> Error: While constructing the build plan, the following exceptions were encountered:
08:33:18 <lightwave>  
08:33:18 <lightwave> In the dependencies for cabal-install-3.2.0.0:
08:33:18 <lightwave>     Cabal-3.0.1.0 from stack configuration does not match ==3.2.*  (latest matching version is 3.2.1.0)
08:33:19 <lightwave> needed since cabal-install is a build target.
08:33:47 <maerwald> lightwave: don't install cabal that way
08:33:58 <maerwald> download the binary or use ghcup
08:34:45 <lightwave> I'm following the "Haskell Tutorial and Cookbook" book...
08:35:05 <merijn> lightwave: Well, the book is wrong on how to install things then :)
08:35:39 <lightwave> What's the relation between ghcup & stack & cabal?
08:35:42 <merijn> lightwave: Basically, Cabal-3.0 is the latest on stackage, afaict, but cabal-install isn't on there. So it blindly tries to build the latest versions (3.2) using stackage's dependencies (3.0)
08:35:54 <merijn> lightwave: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
08:36:18 <merijn> I should make an "hours of typing I saved myself" counter on that link :>
08:37:02 <lightwave> LOL
08:41:35 <fuzzypixelz> how do I auto-add signatures in haskell-mode, I'm using (doom) emacs
08:42:02 <lightwave> Is ghcup the first thing to install for haskell beginner? Then stack?
08:42:30 <merijn> lightwave: ghcup is a tool for easily installing GHC and cabal-install
08:42:48 <lightwave> I thought stack also install ghc?
08:42:50 <merijn> lightwave: stack manages GHC directly and will install it as needed
08:43:27 <merijn> If you play to use stack you don't need ghcup or cabal-install. If you plan to use cabal-install, the easiest way to install GHC & cabal-install is probably ghcup
08:43:32 <merijn> s/play/plan
08:43:33 <lightwave> merijn: So ghcup install ghc & cabal-install globally while stack manage ghc locally at the project level?
08:43:44 <merijn> lightwave: Pretty much
08:43:57 <lightwave> Can I have both?
08:44:03 <merijn> Sure
08:44:15 <lightwave> Will my head explode if they are both install on my laptop?
08:44:25 <maerwald> no
08:44:29 <ephemient> stack will cache the ghc etc. it downloads, so if you have multiple stack projects using the same versions it should reuse it
08:44:37 <maerwald> they're completely independent
08:45:02 <lightwave> Thank you guys  for saving my head
08:45:04 <ephemient> stack and system ghc won't interact at all, unless you use --system-ghc
08:55:24 <fuzzypixelz> https://stackoverflow.com/questions/8963488/automatically-add-type-signatures-to-top-level-functions suggests I do C-c C-t but that just shows the type signature in the bottom of my buffer
08:56:43 <fuzzypixelz> I want it to be automagically added
08:56:50 <lightwave> Good lord... my ~/.ghcup directory is 4.5G That's much bigger than I expected.
08:58:32 <merijn> lightwave: GHC is about 1-1.5 GB so if you got 2 or 3 GHCs installed that sounds about right
08:59:01 <lightwave> Only has 8.8.4 installed.
08:59:44 <merijn> hmm, "du -d 1 -h" inside that directory to see where all the space is going ;)
09:03:00 <lightwave> I think majority of the space were taken up by various verions of haskell-language-server
09:03:30 <merijn> ah, possibly
09:04:19 <lightwave> Kind of weird how it install all the versions even though I only have ghc v8.8.4 installed.
09:12:15 <maerwald> if you're concerned about disk space, haskell will not be for you :p
09:12:34 <maerwald> wait until you actually build a project
09:12:39 <merijn> maerwald: It's really not that bad, tbh
09:13:20 <maerwald> merijn: it is. I installed one project with stack and my .stack is 4.4 GB :)
09:13:24 <merijn> "ooh...GHC is so massive...it's one whole GB!", meanwhile my stripped minimal clang++ install is freaking 1.9 GB. The one I had to build from source is 5 GB
09:13:35 <maerwald> I installed *several* projects with cargo and .cargo is 418mb
09:13:49 <merijn> But people install clang/LLVM via their package manager and don't see it's size
09:15:14 <lightwave> I told my wife that I need a bigger Macbook under the christmas tree... She's pretending she didn't hear me. LOL
09:15:48 <maerwald> yeah, I just got a thinkpad X1 extreme, so I can do haskell stuff on my laptopt without crying
09:16:07 <maerwald> 32gb is minimum IMO
09:16:26 <merijn> It's 2020, what are you doing without a 1 TB SSD in your laptop? >.>
09:16:28 <maerwald> unfortunately, you can't upgrade macbooks
09:16:31 <lightwave> I suspect I'd still cry.  I'm never satisify with my new toy.
09:16:37 <maerwald> merijn: lol, I have that one too
09:16:59 <lightwave> I have 1TB on my MBP... but it's a nice excuse to buy a new one. LOL
09:17:05 <maerwald> X1 extreme is in the same price range as macbook, but I can upgrade the ram... so why would I
09:17:51 <lightwave> TBH, I never find myself needing to upgrade RAM in my dev machines.
09:19:19 <maerwald> ok, start haskell-language-server
09:20:02 <maerwald> also, firefox decided to run an entire OS per tab, so
09:20:12 <lightwave> It can't be worse than the LSP for typescript... loller_ 
09:20:23 <lightwave> s/loller_/LOL
09:21:23 <maerwald> and then run a few electron apps
09:21:53 <maerwald> your gtk theme leaks memory and `rg` blows up the rest
09:22:12 <maerwald> (yeah, rg isn't linear in memory)
09:23:23 <maerwald> oh, I forgot... make sure to use coc.nvim, because you want to run a few million lines of javascript inside your editor
09:23:26 <lightwave> Chrome (any chromium browsers) & node are the worst on my bx.
09:23:35 <dminuoso> 18:19:45      maerwald | [17:16:06] unfortunately, you can't upgrade macbooks
09:23:53 <dminuoso> It's a well known fact that SSDs are non-upgradeable. It's physics
09:23:55 <dminuoso> Physics of money.
09:23:59 <loller_> lightwave: lol
09:24:01 <loller_> XD
09:24:06 <maerwald> dminuoso: loller_ 
09:24:36 <lightwave> dminuoso: LOL
09:26:18 <lightwave> The Apple M1 chip is onto something. No longer is my lap getting BBQ by the Intel chip. I'm playing with one on loan to me from my wife's company.
09:31:07 <Kronic> Hey there, IÂ´m a little bit confused when it comes to parsers. I understand the concept, and I think it is something that given enough time, I could understand well, but what I really donÂ´t get outright is which library to start with. I seemed to be spoiled for choice. Is it okay to just come to terms with parsec at first? 
09:31:25 <dminuoso> Kronic: Megaparsec is a safe default.
09:31:31 <dminuoso> Parsec is dated and not a good starting place IMO.
09:31:44 <dminuoso> (There's also attparsec to consider if you're dealing with binary data rather)
09:32:06 <dminuoso> But if you just want a "give me a single library damnit", then look no further than megaparsec.
09:32:34 <koz_> Megaparsec also has an extensive tutorial.
09:32:40 <Kronic> Ah thank you, that makes sense, I noticed the documentation for that one seemed a little better (I only took a glance really, so I could be wrong!). I will get working on that 
09:34:04 <dminuoso> Kronic: Another library to keep in mind that augments megaparsec nicely is parser-combinators.
09:34:59 <dminuoso> (Im not actually sure how much overlap there is with megaparsec)
09:44:18 <cads> hey all, anyone here use haskell to make python libraries before? What did you use? would you say it was pretty hellish, or that it was significantly (and surprisingly) less than hellish?
09:45:24 <cads> I see missingpy exists, but that nobody has touched it in 8 years. So I don't think that's the current path for embedding haskell into python
09:47:04 <cads> probably haskell can publish to some standard FFI technology, and python can import those libraries  -  my issue seems to be that I don't know what those techs are called, and so few people are writing about it that I can't easily google search it
09:47:50 <cads> https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages just found
09:50:50 <jackhill> cads: I've seen some good posts on crating a c shared library/calling haskell form c in the past, but I can't really find those now. I turned this up: https://wiki.haskell.org/Calling_Haskell_from_C
09:52:00 <jackhill> I had to give up on my project because I didn't really knwo C well enough :/ I now even less about how Python integrates with C libraries or if there is a better way of integrating Haskell and Python. Maybe that's enough to get you started though.
09:52:11 <cads> looks like one path (still terrifyingly complex) is to generate a C interface with c2hs, and then use python's CTYPES to reconstitute any facilities that might be "lost in translation"
09:54:12 <cads> jackhill, thanks, I think doing C hax might be the best shortcut at this time
09:55:44 <cads> Here is the story for writing a python module backed by rust: https://mycognosist.github.io/tutorial-rust-python-lib.html
09:58:14 <jackhill> cool
09:58:20 <cads> that depends on a rust crate called cpython. This appears to wrap python objects in a rustic interface, so that rust code can receive and return them  http://dgrunwald.github.io/rust-cpython/doc/cpython/
10:00:02 <cads> perhaps I need a haskell value that represents a python objects. I am rather vague about the machinery that rust.cpython uses to actually produce python modules out of that code, but I'll keep reading.
10:18:43 <merijn> cads: Ok, so, pragmatic solution
10:19:01 <merijn> cads: Do what I did and just spawn a python subprocess using whatever library you need
10:19:53 <merijn> cads: Directly calling python means basically exporting your python interface to C first and then calling the C interface from Haskell's FFI, as C is the only well defined ABI and all other languages pretty much only support FFI to C
10:20:25 <merijn> Which, honestly, all sounds like much more work than "write a minimal Python script and call that"
10:22:36 <koz_> merijn: Oof, yeah, that sounds... not fun.
10:22:53 <koz_> Definitely not the sort of thing you wanna do by hand.
10:23:00 <koz_> . o O (inline-python?)
10:23:53 <jollygood2> wasn't there something like this already?
10:24:19 <jollygood2> (1, 2) -> (2, 1)
10:24:42 <koz_> :t swap
10:24:44 <lambdabot> (a, b) -> (b, a)
10:24:55 <jollygood2> of course :). thanks
10:41:21 <cads> merijn, I want the opposite - build some heavy number crunching code in haskell, give python users an easy to use interface
10:41:43 <merijn> cads: That's about as hard as calling C from python
10:42:00 <cads> know anyone who wants to make it easier?
10:42:03 <merijn> cads: Basically, exposing Haskell functions to C is fairly trivial
10:42:23 <merijn> So the most annoying/hard part is getting python to call those "C" functions
10:42:33 <xerox_> @index swap
10:42:34 <lambdabot> Data.Tuple
10:43:07 <xerox_> not a huge package
10:43:54 <cads> merijn, right - in the C part of python, there is a special way of handling python objects - so the python part of the code can call those C functions as if they're python methods, in the sense that they return python objects 
10:44:59 <cads> but it still requires some pretty subtle magic to take those c functions and wrap the pythonobject C-type into an actual, live, python object 
10:45:34 <cads> real "breathing life into clay" kinda stuff, and I bet that the rust cpython crate does the same thing
10:45:35 <Rembane> cads: Can you create an interface using cython?
10:45:51 <merijn> cads: Right, my point was that Haskell functions exported via the FFI are "indistinguishable" from C code from the python side :)
10:46:47 <merijn> cads: So if you wanna call Haskell from Python there's not that much to do, unless you wanna be able to "call back" into python and, tbh, even that is fairly straightforward if you can expose the callbacks as C code
10:47:15 <merijn> cads: so this is more of a "python problem" than a "haskell problem" :)
10:47:59 <merijn> cads: On the Haskell side the only thing you need (besides foreign exporting the Haskell functions) is to make sure you call some wrappers to setup the Haskell RTS before calling code
10:48:00 <cads> well, hold on, because what I want is my python to call the haskell C interface and get python objects back. I think I need a python object "boxed type" in haskell land.
10:48:14 <cads> oh, I think we just said the same thing
10:48:28 <merijn> I made a minimal-ish example of calling Haskell from C here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
10:48:51 <cads> http://dgrunwald.github.io/rust-cpython/doc/cpython/py_class/index.html
10:48:52 <Guest_82> I just tried installing ghcup via the command on the website and get an error on MacOS: https://pastebin.com/f3pWYu71 basically, it hardcodes $HOME as /home/johannd, which doesn't exist and isn't writeable on MacOS. I can't seem to find any bug reports about this. Is it a known problem?
10:49:29 <cads> there's the ref for the rust equivalent of what I'd probably need to make this thing a usable tool rather than an unsustainable one time hack
10:49:31 <merijn> cads: Right, but wrapping Haskell into python objects should happen on the python/C side of things, not on the Haskell side
10:49:48 <maerwald> Guest_82: no, it doesn't hardcode anything, your environment variable HOME points to a non-existing directory
10:50:02 <maerwald> or...
10:50:08 <merijn> cads: I mean, I guess you could theoretically do it on the Haskell side, but that'll be a pain
10:50:16 <cads> merijn, I have two implementations (CPython and Rust.cpython) that do it the other way, so why?
10:50:16 <maerwald> "Operation not supported" sounds like some other problem
10:50:33 <cads> I don't think it's because these communities intentionally want pain
10:51:06 <merijn> cads: CPython *does* do it on the C side...their entire implementation is "C side"
10:51:22 <maerwald> Guest_82: fix your environment variable
10:51:31 <cads> maybe I get more control and the python part is much easier to write if I make the haskell code responsible for producing a coherent python object
10:51:44 <Guest_82> maerwald `echo $HOME` -> `/Users/johannd`
10:51:57 <merijn> cads: A "python object" is just a C data structure with some stuff in it
10:52:37 <merijn> cads: Generally manipulating C data structures is much less painful in *C*. It *can* be done in Haskell, but it's miserable, and there's almost no point if you're going to hand it over to C/Python afterwards
10:52:47 <cads> merijn, I'm saying they do it on the C side as in they have built in the hosting language (c), an abstraction of python objects. And I'm saying that doing so in haskell should also be a thing.
10:53:02 <Guest_82> maerwald even when I exec `sh`, which is piped to after curl, `echo $HOME` -> `/Users/johannd`
10:53:04 <merijn> cads: So you write some C code that turns the Haskell "C" functions into an object and hand that to python
10:53:07 <geekosaur> wondering if /etc/passwd (which is legacy on OS X, but tools like git won't know that) has /home/jdahm in it
10:53:20 <maerwald> Guest_82: well, it definitely is not hardcoded
10:53:34 <merijn> cads: You *can* do it Haskell, but I'm saying you shouldn't, because there is no reason to
10:53:37 <geekosaur> the user database probably has the right value in it
10:53:49 <merijn> cads: But if you like pain, whatever floats your boat
10:53:54 <cads> merijn, I want ppl in haskell land to be explicitly working with a python return type. That way we know when interfaces are expected to touch python, and when they are "pure"
10:54:12 <merijn> cads: Well, that's just going to straight up suck
10:54:13 <cads> does that sound like a benefit?
10:54:21 <cads> why?
10:54:24 <merijn> cads: No, it sounds like massive amounts of pain :)
10:54:29 <cads> okay, but why?
10:54:44 <merijn> cads: Because it involves lots of operating on C structs from Haskell, which is the most painful part of FFI
10:54:47 <cads> why don't you want your types to reflect when a function needs to worry about python, vs when it can just be pure?
10:54:54 <cads> I feel that is important documentation
10:55:30 <cads> ie, suppose I can have 5 python touching functions (the interfaces), and 20 pure ones (the kernel)
10:55:47 <cads> what if I /want/ to enforce that and document that?
10:55:50 <merijn> cads: I'd say your Haskell numerical code shouldn't reflect python *at all* it should just operate on integers, arrays and matrices and then wrap that into a high level interface in C that gets passed to python
10:56:46 <merijn> like, why would it matter that those 20 pure functions eventually get called from C/Python? That's irrelevant for what they do
10:56:54 <cads> how then will my python code can never inspect an object that the user gives it? I have to break down the types into primitive matrices and tensors, and lose my user's object semantics
10:57:03 <cads> I need these things to be python objects
10:57:07 <merijn> cads: Oh
10:57:14 <merijn> cads: Well...then RIP your sanity
10:57:19 <cads> not something that I've temporarily forgotten is a python object
10:57:22 <cads> lol
10:57:31 <cads> merijn, I don't think it's that bad, because after all, cpython does it
10:57:43 <merijn> cads: Because then you've gotta interact with those C structs from python and call functions on them and it will be a big hassle
10:57:52 <cads> and cpython code is actually pretty clean to read, for all that it's C and abstracting python objects
10:57:56 <merijn> cads: CPython does it from C and all of CPython is C
10:58:06 <cads> I think haskell code that abstracts python objects will be if anything nicer than the cpython code
10:58:14 <merijn> lol
10:58:15 <merijn> no
10:58:16 <cads> thought the kernel may have some mind bending insanity in it
10:58:23 <cads> merijn, why?
10:58:32 <merijn> Clearly you haven't seen the insanity that C++ objects wrapped in Haskell looks like
10:58:49 <cads> why would C be able to wrap python more elegantly than haskell can wrap python?
10:58:56 <cads> we're talking about C
10:59:30 <merijn> Because it's not wrapping python
10:59:31 <cads> I find this highly ironic that C, the anti-abstraction, would be better at providing an abstraction layer than haskell, the language OF abstraction
10:59:46 <cads> but hey, I would love that as a joke, so tell me the punchline
10:59:59 <merijn> cads: CPython is a python interpreter written in C. It's not "wrapping" python, it just calling directly into interpreter implementation details
11:00:22 <merijn> The reason it's "more elegant" is because there's no pretension at wrapping at all
11:00:46 <merijn> You don't "wrap" python objects, you just directly call your (C) interpreter implementation details on objects that exist
11:00:46 <cads> merijn, I'm not talking about the interpreter, I'm talking about the common library code that is written in C
11:01:03 <merijn> cads: Right, but that library code does the same thing
11:01:21 <cads> functions absolutely do wrap python objects inside the functions they work on native c types, and then when the function returns, it wraps it in a pythonobject struct
11:01:29 <merijn> cads: Your Haskell code will not be wrapping Python either. It will be wrapping the C interpreter bits
11:01:48 <cads> Look at the rust library
11:02:31 <merijn> I mean, you don't have to take my word for it. God knows most people on the world don't listen to me :)
11:02:35 <cads> it wraps the c interpreter bits too (because that's all it is really emitting), but it also wraps a python object type, so that users can actually extend functionality for python objects, like any real library must
11:03:15 <cads> merijn, it's just that you're telling me that I don't get to have something I get to take for granted in other languages like rust, because I'd have to work too hard to get it. And the argument is falling flat, yes.
11:03:39 <cads> you see how you're trying to discourage me for no real reason, right?
11:03:47 <merijn> Anyway, either 1) you're misunderstanding what I'm saying, 2) I'm misunderstanding your description what you wanna do
11:04:01 <cads> okay, look at the rust code, and lets discuss it later
11:18:24 <dminuoso> 10:41:21 <cads> merijn, I want the opposite - build some heavy number crunching code in haskell, give python users an easy to use interface
11:18:44 <dminuoso> If you want that, perhaps expose your Haskell code as a service to consumer, say over a unix domain socket?
11:18:56 <cads> huh, or microservice
11:19:07 <dminuoso> Then you can have a well defined API to program against, without all the idiosyncracies of having to deal with crossing FFI.
11:19:26 <jollygood2> I'm writing json using aeson, someone remind me, how can I control the order of fields in the json file?
11:19:45 <merijn> Man...
11:19:51 <cads> it kind of collapses the richness of the datypes of each repsective language, and I have to reason across a set of json interfaces. That's not so bad at all, acutally
11:20:02 <cads> gets rid of a LOT of pain
11:20:06 <merijn> You ever read a question and go "well...this sounds like a rabbithole of depressing tech issues.."? :p
11:20:16 <cads> merijn, yes
11:20:18 <cads> lol
11:20:34 <dminuoso> I mean Haskell and cpython interacting with each other is *not* fun.
11:20:35 <merijn> If you need to control order of fields in your JSON file you're already boned
11:21:14 <Chousuke> I can see reasons to do it that aren't altogether insane
11:21:33 <merijn> cads: "it collapses the richness of datatypes of each respective language" <- well, yes, this is a fundamental limitation of FFI
11:21:44 <Chousuke> you might want to programmatically modify a JSON file without causing too large a diff for example.
11:22:03 <merijn> Chousuke: I'm vaguely aware of some...insert adjective here...IBM code that relied on something like that for XML or JSON, so...
11:22:09 <cads> so I have to give up the idea that I'll be able to get a python object, and interrogate it in haskell land
11:22:47 <cads> that changes how I write my python, because I'm used to passing python objects, and methods doing a number of queries and commands on them via that object's methods
11:22:58 <merijn> cads: It's *theoretically* possible, but how would you even expose/use that information without reimplementing the entire python OO interface in Haskell?
11:23:29 <dminuoso> cads: By the way, consider CBOR over JSON if you can still decide on things
11:24:00 <dminuoso> Especially if you want to deal with numbers.
11:25:15 <yushyin> cbor++ ;)
11:27:09 <cads> I convert things to toml any time a human has to see them, but I have been looking for a versatile binary wire format, thanks
11:28:18 <cads> Looks like remarhsal can do the Toml <-> Cbor <-> Yaml <-> Json interop  (lol @ how we no longer include XML in that list)
11:29:14 * cads started encountering Yaml in microservices land, hates it, and is generally much happier /w toml substitutes for confs
11:30:02 <cads> you know, the idea that a haskell entity should be big and bad enough to warrant its own microservice? I don't think I'll have trouble finding applications to fill those shoes
11:31:01 <Rembane> cads: If you really want to fall down the configuration language rabbit hole: https://dhall-lang.org/
11:32:19 <cads> as a haskell <-> python interop layer it doesn't do what I originally wanted it. But it is so much cheaper that I could have my first application /today/. That makes me like it. And that even makes me feel like it saves me from overengineering something that /even I/ could see was going to be miserable
11:32:23 <michaelh> I have a list of fields which I want to use to populate a record. The list is obtained from parsing a file, so if some fields are missing, I won't create he record. This is a shortened example of how I solved it: https://pastebin.com/ud39S66b As you can see I pattern match on instances of the `Field` type i a list, which causes a lot of boiler plate. Is there a way to avoid that boiler plate? Is there a better way to do this overall?
11:32:23 <michaelh> I'm a Haskell beginner :-)
11:33:10 <michaelh> The fields that I parse can be in any order btw
11:33:18 <Rembane> michaelh: Hi! What's the format of the file? 
11:33:34 <merijn> > (,) <$> Just 2 <*> Just True
11:33:37 <lambdabot>  Just (2,True)
11:33:40 <merijn> > (,) <$> Just 2 <*> Nothing
11:33:42 <lambdabot>  Nothing
11:33:57 <merijn> michaelh: You probably wanna have a look at Applicative and <$> and <*> :)
11:34:23 <michaelh> Rembane: Custom format. Looking like this: "abc:123 def:Hello"
11:34:26 <merijn> michaelh: Also, oof :)
11:34:32 <michaelh> Actually, Advent of code, day 4
11:34:37 <merijn> michaelh: ReadP is notoriously tricking and confusing :)
11:35:07 <merijn> michaelh: I'd probably try using parsec/attoparsec/megaparsec instead :)
11:35:40 <michaelh> merijn: Sure, I use applicative a bit too, not in this example here though. Will that help me remove all those get... functions?
11:36:42 <merijn> oh, wait, I think I misparsed the bottom function
11:36:42 <cads> micheal, it feels like each of those functions should be a pattern matching clause of a larger function
11:37:04 <merijn> michaelh: Aren't you missing an fs on each function there?
11:37:20 <cads> that might conceptually unify the four get_functions into a getField function, for instance
11:37:21 <Rembane> michaelh: I primarily used this combination of functions, but my code has more of a hm... Perl feeling to it: concatMap (map (second tail . span (/= ':')) . words)
11:37:28 <merijn> michaelh: You could basically write "Record <$> getAbc fs <*> getDef fs <*> getGhi fs" was my point :)
11:37:34 <michaelh> merijn: oh, I totally do. `fs` should go after each one. Sorry about that.
11:37:35 <cads> err, three
11:40:01 <michaelh> merijn: Sure! That's neater. But I'll still have all those similar get-functions, that's the one thats making me think perhaps I'm doing this wrong.
11:40:15 <cads> oh, the individual functions have meanings, but currently you have them named after the alphabet (AbcDefGhi). How about:  getAbc => getInt,    getDef  => getString,   getGhi => getBool
11:41:00 <michaelh> cads: But they all return different types, so how would I combine them into one?
11:41:06 <cads> then merijn's code becomes: Record <$> getInt fs <*> getString fs <*> getBool fs  --  highly readable
11:41:28 <merijn> michaelh: you could derive Ord for Field and instead of having a list like you have now, use a "Map Field Value" and do lookups, but I suppose that doesn't work with different field types
11:41:57 <merijn> michaelh: tbh, the AoC exercise is on the awkward cusp of almost, but not quite, allowing a nice Haskell solution but not being worth the boilerplate
11:42:12 <michaelh> cads: Yeah, that was just some bogus names I picked for now.
11:42:14 <merijn> michaelh: I just used "Map Field String" and then did validation on the strings directly :p
11:42:36 * Rembane agrees with merijn 
11:43:11 <cads> michaelh, oh, right, the composite function would have to return some strange maybe type, then you'd have to handle it. Maybe not the best. I now prefer the  "merijn pipe" architecture 
11:44:53 <cads> michaelh, after debogonizing + applicative chaining, that is code I would be proud of in my own production
11:45:03 <michaelh> Yeah. My starting point was, "I want to pracitice Haskell and at the same time learn to use Text.ParserCombinators.ReadP", while doing AoC. I realize this might give quite a bit of resistance :-) I was also thinking about using, for instance, Map String String, and work with that. But I wanted to try to parse as much as possible. Perhaps not such a great idea
11:45:34 <merijn> michaelh: tbh, ReadP is terrible and the problem isn't supper suitable for it, so you're fighting 2 problems at once :p
11:46:54 <cads> merijn, which are lighter parser combinators to use for a problem like this? also interested for my own use
11:47:07 <merijn> Light in which sense?
11:47:14 <cads> conceptually
11:47:32 <michaelh> Okay. Thanks for helping me realize that! :)
11:47:32 <cads> and simple easy to write
11:47:40 <merijn> attoparsec is probably the smallest/cleanest parser combinator library for simple formats
11:48:06 <merijn> michaelh: I can link you my megaparsec solution, but that's of course a massive spoiler :p
11:48:55 <michaelh> merijn: Sure, I'd be happy to see that. I've already solved the problem, so I don't need to worry about that.
11:49:14 * cads wants to see too, also has no qualms /w spoilers 
11:49:21 <merijn> michaelh: https://github.com/merijn/AdventOfCode2020/blob/master/Day4.hs
11:51:04 <michaelh> merijn: Thanks! I'll take closer look in a bit. By the way, now that I understand that fighting ReadP wasn't all my fault, can you recommend any of the Parsec-libraries for a newbie? I just want to get some more general parser combinator experience.
11:52:53 <trepanger> What does "debogonize" mean?
11:53:21 <glguy> ReadP would be fine for parsing AoC. All of the AoC formats are simple enough that any choice of parser combinator library is going to be fine.
11:53:39 <glguy> Where ReadP falls down is that it doesn't give good error messages, which can be helpful to debug your parser when you write it incorrectly
11:53:42 <merijn> michaelh: tbh, the high level design is pretty much identical for all of them, it's the gritty details that differ. Parsec is a bit dated, having symbols conflicting with Prelude (due to predating Applicative/Alternative) and generally not being worked on anymore. Megaparsec is probably the most "industrial" library with the most features, but it's docs are a bit of a mess currently (they do have a bunch 
11:53:48 <merijn> of tutorial linked from the repo), attoparsec is rather minimalist, but very clear
11:54:12 <merijn> michaelh: The design is so identical, in fact, that the parser-combinators library abstracts tons of functionality for all of them :p
11:56:17 <cads> Rembane, now I'm craving Dhall's semantic hashing. That's pretty fucking snazzy.
11:57:16 <Rembane> cads: Muaha! They are indeed. And the types and the grumpy type checker and the syntax and the... it's a lovely language. ^^
11:57:51 <Rembane> cads: And also, it isn't Turing complete by mistake. 
11:58:44 <cads> any way to banish the curly brackets? That is the main reason I ditched json in favor of toml
11:59:06 <Rembane> You can always write a preprocessor.
11:59:34 <cads> or I can write a semantic hashing function for toml
11:59:39 <Rembane> Yes. :D
12:00:08 <cads> that's a realy killer feature, lol, I could leave the fact that it's executable (which actually scares me shitless)
12:00:31 <michaelh> Alright, thanks again, all of you :)
12:00:48 <monochrom> Do so much hate against curly braces.
12:00:58 <monochrom> Pascal bannished curly braces.
12:01:09 <monochrom> made you write "begin" and "end" instead.
12:01:16 <aldum> pascal did a lot of unsavory things
12:01:49 <aldum> to this day I occasionally muck up equality checking in C-style languages
12:01:51 <trepanger> curly brace syntax is a hell of a lot easier to parse than whitespace, though
12:01:59 <cads> technically toml does you dirty in order to give you a brace free experience. But I won't say how.
12:03:03 <trepanger> (easier to write a parser for, I mean)
12:03:03 <monochrom> And why so much hate against parentheses too.
12:03:17 * cads thinks the trend of ppl putting the wellbeing of parsers ahead of humans should end
12:03:33 <trepanger> cads: yeah, you have a point
12:03:36 <monochrom> COBOL bannishes curly braces, parentheses, and "begin" and "end". In fact, it bannishes all line noises.
12:03:47 <aldum> cads: I think I read someone argue this
12:03:58 <trepanger> but JSON is mostly for machines
12:03:59 <monochrom> You write "multiply x by y into z" instead. It's pure English. No symbols allowed.
12:04:02 <Rembane> monochrom: Doesn't COBOL banish almost everything? 
12:04:15 <aldum> we have two povs here, and we can't ditch human-readability
12:04:23 <MarcelineVQ> humans probably aren't as good at reading as they think they are
12:04:29 <cads> trepanger, I think it was xml that was mostly for machines - json took over because it was /partially/ for humans ;)
12:04:52 <cads> rip xml *touchies fingers to lips, then to sky*
12:05:13 <trepanger> haha, xml was a pain to parse for a machine also
12:06:00 <cads> also there is no fun canonical way to turn xml into json :(
12:06:11 <aldum> human processing takes shortcuts
12:06:17 <Rembane> There's no canonical way to turn xml into anything.
12:07:03 <cads> well there is, it's just creates lots of extra nodes that you don't want
12:07:25 <cads> so then you filter the nodes. Boom, you lost the ability to convert back
12:07:34 <aldum> https://eev.ee/blog/2016/12/01/lets-stop-copying-c/#braces-and-semicolons
12:07:54 <Rembane> cads: That's quite fun in a derpy way. :)
12:08:06 <monochrom> I have much doubt that xml was for machines. A binary format would be for machines. xml is everything but binary.
12:08:25 <cads> i think xml was for schemas
12:08:27 <aldum> xml was for the enterprise :D
12:08:43 <cads> and that, or the same thing honestly
12:09:25 <monochrom> Every time you see a syntax design supporting, even optimizing for, "meaningful" identifiers, you know it's designed for humans.
12:09:28 <trepanger> I'm not convinced that whitespace *is* more readable in general. Particularly for deeply nested data structures.
12:09:51 <aldum> I used to like XML, before I saw better designs, and before I had to do an XSLT/Xpath assignment for a class
12:10:04 <Chousuke> I feel like YAML is popular only because JSON doesn't support comments and doesn't support trailing commas in maps and lists.
12:10:09 <cads> I think we had a need for a really extensible, self referential, self documenting, and discoverable data format , and I think binary formats weren pretty terrible for that
12:10:21 <Rembane> I think LISP would've been a better choice 
12:10:48 <aldum> Chousuke: then why not json5 or HOCON?
12:10:59 <Chousuke> because YAML exists.
12:11:07 <Chousuke> json5 is too late :)
12:11:25 <aldum> well, I like HOCON :)
12:11:39 <cads> Chousuke, and toml is popular (or hopefully getting so) basically because it also has comments and trailing commas, but doesn't have self Yaml's brand of referential madness
12:11:42 * MarcelineVQ lights the candle at the altar of .ini
12:11:51 <cads> self-referential madness* even
12:12:58 <aldum> what's the take on dhall around here?
12:14:11 <monochrom> Haskell shows that you can allow both curly braces and space layout.
12:14:14 <dminuoso> This channel is frequently used for dhall related questions, because apparently it's mostly haskellers that use Dhall?
12:14:21 <cads> Chousuke, fwiw, I'm going around my infrastructure religiously converting my yaml into toml and loving every second of it, so imho yaml's days in the sun are also numbered
12:14:24 <merijn> monochrom: And absolutely no one will use the braces ;)
12:14:31 <aldum> that's why I ask
12:14:39 <monochrom> Aww, you forgot SPJ.
12:14:50 <dminuoso> cads: cant beat ini for configuration files!
12:15:02 <monochrom> Also, I sometimes use them when the space layout rules are against my code structure.
12:15:35 <dminuoso> Though lately I've started preferring just environment variables.
12:15:42 <monochrom> or rather, s/code/conceptual/
12:15:58 <cads> dminuoso, toml manages to, because it lets you create entries into deeply nested lists, where ini would have nothing for you
12:16:14 <aldum> I did some (rudimentary) toml today, it was just like ini
12:16:16 <dminuoso> cads: Sure, by that I meant to include toml since I consider it an ini-style language
12:16:16 <monochrom> dminuoso: Wait, how much information do you pack into those poor environment variables? :)
12:16:21 <dminuoso> monochrom: A lot.
12:16:27 <Chousuke> cads: I'm not convinced about toml either. It seems weird in its own way, too
12:16:54 <Chousuke> I prefer software that doesn't need configuration, or if it does, as little of it as possible :P
12:16:57 <monochrom> OK I guess if TERMCAP can do it then you can do it too.
12:17:14 <cads> Chousuke, I have some reservations, yes - but fewer than with yaml, json and xml - I can say I am "happy" with my metadata format today, insofar as it's humanly possible to be happy with such
12:17:14 <monochrom> Do you need to use an IDE to edit the stuff you put in your env variables? :)
12:17:28 <dminuoso> monochrom: Much of our haskell software is deployed in docker, so environment variables fit well into the tooling.
12:17:51 <dminuoso> And honestly I had all configuration file formats with a passion. Some just less than others like ini-styles (including toml)
12:17:57 <cads> Chousuke, I prefer software that I can bill customers for, and those usually have configurations ;)
12:18:03 <Chousuke> environment variables are kind of so-so because they're difficult to discover
12:18:06 <dminuoso> I'd love to actually bake configuration into the software (which is ideal)..
12:18:26 <monochrom> OK I guess you can create many, many env vars.
12:18:30 <dminuoso> Yes.
12:18:48 <dminuoso> We configure our software with .env files that are essentially just lines of `FOO=bar`
12:18:55 <Chousuke> cads: most software requires configuration, but there's tons of software that requires you to configure things that you just shouldn't need to ever touch.
12:19:09 <Chousuke> because they have either no defaults, or insane ones.
12:19:09 <monochrom> I was nerdily thinking "use just one env var but you take a 1000-line Haskell source code and compress it and that's the value of the env var"
12:19:14 <dminuoso> It's far from ideal, but at the very least we dont drag a pile of dependency nonsense just to parse a damn config file
12:19:22 <dminuoso> oh haha
12:20:31 <Chousuke> so then you try to get the software running but you're missing some frobnicateWidgets = 16 from the configuration that must be exactly 16 because it defaults to 8 but that doesn't actually work
12:21:40 <cads> dminuoso, I like to have one config file that parses into a conf object that I can work with like  conf.client.id   and conf.server.ip and so on
12:22:01 <Chousuke> or you have software that has 700 optional modules and enables 300 of them by default but the defaults are insane and you really just need 5 modules
12:22:05 <cads> but that's basically what ini does
12:22:34 <dminuoso> Chousuke: We've really played with the idea of putting *all* configuration into source code.
12:22:44 <dminuoso> Except for secrets.
12:23:16 <Chousuke> dminuoso: Have you ever used Clear Linux? They basically made a goal to make /etc empty by default.
12:23:32 <dminuoso> yeah
12:23:39 <dminuoso> well, not used but heard of it
12:23:42 <MarcelineVQ> ~/etc/...
12:24:15 <Chousuke> it's not really wrong to have configuration files since of course you need to configure things like what IPs a service will listen on etc, but a lot of the defaults can be compiled in
12:24:22 <cads> Chousuke, I've recently run into a similar phenomenon auditing my /etc in alpine linux. I got to the etc/-groups and etc/groups files and lost it, because I had groups for software systems from the 80s that will NEVER run on my system
12:24:29 <Chousuke> or should at least be read from static files somewhere that don't change.
12:25:08 <cads> I get that the dead configuration isn't causing any pain in production, but it sure does make it hard to audit the configuration for correctness
12:25:11 <Chousuke> cads: lots of those groups are probably standardized in POSIX or something :Ã–P
12:25:17 <cads> yeah, they were
12:25:41 <dminuoso> Chousuke: Well, the question is what belongs into a configuration file and what does not.
12:25:46 <monochrom> oooohhhh an oxygen atom that wants to donate 4 electrons....
12:26:05 <Chousuke> :P
12:26:14 <cads> dminuoso, as in, is the behavior easier to audit when you now have to audit code instead of confs
12:26:57 <dminuoso> cads: With code we have traceable artifacts. 
12:27:19 <Chousuke> dminuoso: you can have 2 kinds of configuration files: user-modifiable ones and the kind you ship with the software that the user should not touch, ever. Just don't put them in the same place :)
12:27:25 <cads> deployed configuration needs to come from a traceable place too
12:27:30 <dminuoso> Say, if I tell you what's the sum in this `\x -> x + 4` you'd have to tell me "it depends on what x is"
12:27:39 <cads> ie, keep it in source countrol as well
12:27:42 <dminuoso> that is, it depends on how you resolve the dependency on x
12:28:07 <dminuoso> Chousuke: If its not user modifiable, it belongs into the software for sure.
12:28:19 <dminuoso> The entire point of a configuratoin file is so you can modify it.
12:28:42 <dminuoso> Im a proponent of packing everything into the binary for most casual applications.
12:28:43 <cads> it should be in a configuration file that only exists in production
12:28:47 <Chousuke> yeah, but often there's configuration that really is not meant to be modified by the end user
12:29:05 <Chousuke> I'm thinking of something like tomcat's XML files.
12:29:28 <monochrom> and plain.tex :)
12:29:33 <Chousuke> those are configuration for *developers*, not end users
12:30:39 <cads> say you have an app, and part of the build is that you create a windows .msi package. for that you have to name the package and tell the install generator where the package should keep its registry keys, and what script should run to uninstall the package. 
12:31:00 <cads> This is part of the project's build time configuration... why not keep that in configuration files? why put that in code? 
12:31:41 <Chousuke> you usually don't ship that with the software though.
12:32:23 <cads> I'm trying to give an example of a configuration file that the end user never even sees, but which developers might occasionally wish to adjust
12:33:16 <hpc> just imagine source code as a set of configuration files for the compiler
12:33:21 <Chousuke> I'm just thinking about interfaces here. Lots of software exposes settings where if you actually change any of them from whatever the developers have set, the software will break.
12:33:30 <hpc> also configuration files are just a domain-specific declarative language
12:33:35 <cads> hpc, yep
12:34:19 <cads> it's a language for the configuration domain of an app, designed to convey absolutely zero logic
12:34:30 <cads> or as little logic as possible
12:34:50 <Chousuke> cads: Tomcat / Wildfly XML files are things I wish I could avoid seeing, but the developers obviously need to work with to get their software deployed on the platform :P
12:35:37 <cads> that way the configuration domain can stay far away from the logic domain, and you can cleanly interface between the two domains instead of smearing configuration through your logic like a turd in your pants
12:35:41 <Chousuke> in the admin role I don't think I should have to worry about what classes and modules wildfly loads to run whatever software I'm configuring.
12:36:17 <Chousuke> but often that configuration is mixed with things I actually *do* have to modify, like database settings
12:36:40 <monochrom> Imagine runghc reading your Haskell code from an env var / It is not hard if you try / No more border between program and data / Down that road is Lisp ...
12:36:57 <cads> Chousuke, I think that if I were coming from those platforms my crusade for readable conf files would still exist, but be of an opposite polarity
12:36:59 <hpc> down that road is PAM, where the configuration files are a list of .so files to load :D
12:37:11 <monochrom> haha you win
12:38:06 <cads> hpc, I've recently stopped maintaining a single shell profile, and now I just add shell profile modules to my /etc/profile.d/ directory. I feel I have matoored
12:38:09 <Chousuke> hpc: or things like Jenkins, which is basically useless by itself, but you can make it into a CI system by loading just the right plugins.
12:39:37 <hpc> the funny thing is i actually like jenkins, just not as a CI system
12:39:39 <cads> Chousuke, in those systems does it help to have a base configuration that has been winnowed down to have the absolute minimum BS boilerplate, plus a live configuration of all the parameters that you actually /want/ to see when you open the conf file?
12:40:05 <cads> Chousuke, that kind of hides the technical debt in a place you won't think about... and where it'll fester
12:40:24 <cads> but it gives you a better day to day experience
12:40:58 * cads is afraid their own configurations are going to baloon like this, now that they are moving to micoservices and kubernetes
12:42:00 <cads> I'm going to be working hard to deduplicate configuration, and to not have any configurations that I can't clearly explain what value they provide and why we want to have them
12:42:16 <Chousuke> cads: one way to do it sanely is to have the "default" config in /usr/share or something, load it, and then just override things from /etc
12:43:06 <Chousuke> and if there's no way to provide a sane default configuration for something, just... don't.
12:43:20 <Chousuke> abort startup and complain if the user hasn't configured it :)
12:44:20 <cads> Chousuke, I am okay with that solution from a security perspective with the proviso that security auditors /must/ inspect computed configurations so as to include the portions inherited from default (they cannot audit the conf file alone)
12:45:21 <Chousuke> some software can dump the full configuration they would use. That's pretty nice.
12:45:41 <cads> Chousuke, I dare say that the "complain and bail" or just "complain and keep running if possible" should be the default even in many cases you or I might be tempted to provide a "canonical" default behavior
12:45:51 <cads> ie, yagi principle
12:45:57 <Chousuke> eg. "doveconf -n"
12:46:43 <Chousuke> yeah. It's always a tradeoff
12:47:21 <cads> Chousuke, if you have a config module that unifies config from multiple places, I would say it makes sense to log the computed config on your debug level
12:47:30 <Chousuke> it's convenient not having to configure something but there are things you just have to, because it's so heavily environment-dependent.
12:48:28 <Chousuke> bad defaults are worse than no defaults :P
12:48:42 <cads> then sec auditor audits that. If the config is simply loaded from a single conf file, then I don't think you need to log the config. If you have a commit hash for that instance's config, the auditor can audit that config file directly.
12:49:15 <cads> so there's a little less security compliance tooling involved, which is nice, because how often will people invest in compliance tooling
12:49:20 <gentauro> is it "safe" to delete snapshots in the `~/.stack/snapshots` folder? I think 119 snapshots using 15 GB of my hardrive is a bit to much â€¦
12:50:02 <Chousuke> cads: on the other hand if you have all kinds of "irrelevant" configuration in your configuration file it's hard for an auditor to tell what's actually been modified from the defaults.
12:51:56 <cads> Chousuke, one thing that has helped me (when working with my own configurations) is to split the configuration into clean and nonintersecting subdomains (typically related to the subdomains that make up your app's concerns). But I don't have any legacy systems whos configurations have grown out of control. I think that tends to happen though, and I don't know if refactoring can hold it off forever.
12:54:56 <sm[m]> gentauro: yes, stack will just reinstall them if needed
12:55:04 <gentauro> sm[m]: cool
12:55:14 <sm[m]> ncdu is good for browsing & deleting
12:58:07 <cads> ncdu++, also take a look at bootandy's 'dust': https://github.com/bootandy/dust
13:00:19 <cads> (for when you want a deep usage graph, but don't need to delete things)
13:09:47 <cads> dminuoso, are you and the team specifically implementing configuration as code practice? Ie, according to Paul Hammant that is " the formal migration of config between environments, backed by a version control system." https://rollout.io/blog/configuration-as-code-everything-need-know/
13:14:51 <cads> by keeping conf tomls in vcs (except my secrets), it seems I already do that. I thought config as code meant writing all your config into constants sprinkled throughout the code, as if we're all learning to code for the first time and we're back to making rookie mistakes..
13:20:22 <cads> oh, in this approach we keep a separate repo for configs, so that our dev doesn't have to be affected by the churn of production's current "flavor of the week" configuration
13:21:17 <cads> his could be an issue, if the config your code encounters in dev and testing does not reflect the real world config
13:21:33 <fuzzypixelz> sorry to be asking this again, but how do I get automatic type signature added in emacs?
13:21:37 <fuzzypixelz> I'm using haskell-mode
13:30:20 <cads> fuzzypixelz, hmm, I could use that functionality too - are you sure haskell-mode is supposed to provide it?
13:33:44 <cads> fuzzypixelz, The issue you're having is that when you do C-u C-c C-t, you get the type annotation (of the current function) in the bottom of the buffer. But what you want is for every nondecorated function in the file to become fully and permanently annotated. Is that correct?
13:37:17 <koz_> :kind! 'Just 'True
13:37:26 <koz_> > :kind! 'Just 'True
13:37:30 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input â€˜:â€™
13:37:39 <koz_> > :k 'Just 'True
13:37:42 <lambdabot>  <hint>:1:1: error: <hint>:1:1: error: parse error on input â€˜:â€™
13:38:17 <cads> https://github.com/jaspervdj/stylish-haskell
13:39:05 <cads> fuzzypixelz, I'm thinking that if we have to implement this ourselves, the most maintable way might be to write a stylish-haskell plugin
13:42:28 <cads> hmm... would it be unusual or at all a bad idea to repurpose a code beautifier into a code preprocessor for an experimental haskell syntax extension?
13:42:51 <cads> I should say, to repurpose stylish-haskell
13:55:42 <fuzzypixelz> cads: yes! exactly!
13:58:43 <fuzzypixelz> cads: I wouldn't say reusing stylish-haskell is a bad idea
13:58:48 <dminuoso> cads: Yes because it cant do what you want it to do. Assmuing you're still chasing this import business, then it's not sufficient.
13:59:09 <dminuoso> stylish-haskell uses ghc-lib-parser, so it can only parse what GHC can parse (under all possible extensions)
13:59:13 <dsal> Is there not a thing in Ix to go the other way?  i.e., can  (drop n . range)   but can I just ask what n would be?  It seems no from the docs, but I might be missing something.
13:59:25 <sm[m]> cads: thanks for the dust tip. It's.. interesting! Going to stare at it a bit
13:59:45 <dminuoso> dsal: What do you mean by "other way"?
14:00:06 <dminuoso> Oh, different Ix sorry.
14:00:11 <dminuoso> dsal: Use DOwn
14:00:40 <dminuoso> % range (Down (1, 10))
14:00:40 <yahb> dminuoso: ; <interactive>:57:8: error:; * Couldn't match expected type `(a, a)' with actual type `Down (a0, b0)'; * In the first argument of `range', namely `(Down (1, 10))'; In the expression: range (Down (1, 10)); In an equation for `it': it = range (Down (1, 10)); * Relevant bindings include it :: [a] (bound at <interactive>:57:1)
14:00:40 <dsal> I mean it maps from the range a value.  I want to know where a value would exist within that range.
14:01:11 <dsal> I can do this by asking for the range as a list and dropping n elements from it.  But that seems silly.
14:01:48 <dminuoso> Oh wait, Down doesnt do what I want
14:02:17 <dminuoso> dsal: Do you need this polymorphic over any Ix, or can you monomorphize?
14:02:56 <dsal> Yeah, this is a bit abstract.  In *practice*, it's Char and pretty obvious what to do.  By definition, that's not a requirement.
14:04:00 <dminuoso> dsal: So this is an odd question but...
14:04:03 <dminuoso> What's wrong with..
14:04:06 <dminuoso> % :t index
14:04:07 <yahb> dminuoso: Ix a => (a, a) -> a -> Int
14:04:26 <dsal> I want Int -<> a
14:04:29 <dsal> er, Int -> a
14:04:59 <dminuoso> That doesnt work on Ix
14:05:08 <dminuoso> Ix does not even guarantee its bounded
14:05:28 <dminuoso> Or it could perhaps me a cyclic structure
14:05:47 <iqubic> Ix a does require that there's an Ord instance for a, right?
14:06:09 <dminuoso> Right
14:08:23 <dminuoso> dsal: A sort of "half way there" is Enum.
14:09:12 <dminuoso> Overall I dislike Enum because it admits partiality, and people use it as a poor mans "C enum" which it's not meant to be.
14:09:31 <cads> sm[m], I was out on my desert balcony and I wiped my finger and noticed "hmm, dusti". So I invented an idea for interactive dust (dust plus a ncurses cursor that lets you pick files, delete them, expand directories that dust has collapsed, and so on.). Could be a fun first rust project, but I digress.
14:09:38 <dsal> Yeah, I was hoping there was Enum here.  Ix is even more magic to me now.
14:10:13 <cads> sm[m], if dust were dusti, it would replace ncdu for me I think
14:10:19 <dsal> Oh, I see.  range is defined by the instance, so it gets to use Enum, but I don't.
14:10:28 <sm[m]> cads: I like it, but unfortunately find the display too unintuitive. Perhaps with more docs it'll stick
14:11:23 <dminuoso> dsal: Right, there's no coherence laws with Enum, and Enum itself is sort of lawless
14:11:59 <dsal> I'm also a bit of an anarchist.
14:13:04 <cads> sm[m], I feel confident I could improve dust's display while i'm making it interactive, but since ncdu's code is in C I want it to rot in obscurity without my even reading it
14:14:11 <cads> but yeah, it's currently ugly, and I think what I see when I look at it is more its potential
14:15:40 <cads> and the fact that it's rust is huge, because I can work with rust. And the visual mapping gives me new information about files underneath a given directory level - that's novel, and makes me  want to explore and improve the visual presentation.
14:17:53 <sm[m]> it is definitely informative, even without understanding the output in full. Will keep!
14:18:21 <sm[m]> who will make duhst :)
14:22:59 <cads> sm[m], are you familiar with the output of the tree -L 2 command? This uses ascii pipe, elbow and tee characters to visualizes the top two levels. That is the current directory plus the  immediate descendants of files in that directory. If you can visualize such a truncated file tree, note that each item is on its own row by convention
14:24:29 <cads> Each row contains a file or a directory. We can annotate that row with an indicator of that item's size. We use either the file size or the composite size of a directory's descendants.
14:26:15 <cads> dust can group directories by level or by the size of the directory contents. That means for instance that if a directory is very large, we do not display its contents, but display the size indicator for that entire directory
14:31:00 <cads> dminuoso no, I want to help fuzzypixelz do his type encrichment tool using something better than manual cut past automation of .hs files via perl, which is the current suggested solution according to stack exchange (only don't use it on qualified imports because it's broken)
14:36:10 <cads> fuzzypixelz's issue is that there are some functions - those whose types come from qualified imports - that the current perl based solution bonks on, because parsing qualified names is not implemented
14:38:02 <cads> what should we call this? automatic type documentation? 
14:53:55 <hyiltiz> maerwald tomjaguarpaw: yeah, https://hackage.haskell.org/package/roundtrip https://hackage.haskell.org/package/roundtrip-aeson and https://hackage.haskell.org/package/roundtrip-string were the libs I were referring to
14:55:02 <hyiltiz> Anyone with any experience using 'em? The glaringly sparse documentation is a bit prohibitive, and seems like the libs were a result of an academic excercise
16:19:07 <texasmynsted> hello
16:50:38 <sm[m]> wow.. almost four hours to track down a cyclic reference hang added to a rare code path months ago
16:51:40 <sm[m]> if you're interested: https://github.com/simonmichael/hledger/commit/260283e2f123f687be8eb3a0fa710f99550517a8?branch=260283e2f123f687be8eb3a0fa710f99550517a8&diff=split#diff-4e35d3e929fe0b313f5d79a0d5f57d72da73863eed4f31c1e3a0d0e5958cec07R211 
16:52:56 <sm[m]> the Can-we-build-reliable-software-with-haskell-department would like to know, how do you prevent these ?
17:30:15 * ezzieyguywuf pops in "Don't use circular references."
17:30:18 * ezzieyguywuf ducks
17:31:12 <cheater> if i'm in powershell and run cabal install and select some text will it actually stop compiling? because i think that just happened
17:32:39 <iqubic> I honestly doubt that's what happened.
17:34:45 <cheater> thanks
17:34:58 <cheater> any clue on why accelerate would fail to build on windows 10 with this error? https://hastebin.com/exulidahow.apache
17:40:57 <ezzieyguywuf> the megaparsec tutorial talks about the "choice" combinator: where does tihs come from?
17:43:20 <cheater> i googled "megaparsec choice combinator" and the first result was this: https://hackage.haskell.org/package/megaparsec-4.4.0/docs/Text-Megaparsec-Combinator.html
17:46:33 <ezzieyguywuf> doh
17:46:44 <ezzieyguywuf> you totally should've "lmgtfy"d me
17:54:25 <ephemient> in later versions it is split out to https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Applicative-Combinators.html#v:choice
17:54:58 <ephemient> as it works with in any Alternative, nut just parsec
17:57:22 <cheater> ezzieyguywuf: nah i'm trying to be friendly :)
17:58:20 <ezzieyguywuf> cheater: cheers mate!
17:58:37 <ezzieyguywuf> ephemient: I saw it in paser-combinators, and then wasn't sure if that was different or not
17:59:47 <ephemient> ezzieyguywuf: megaparsec re-exports Control.Monad.Combinators: http://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec.html#g:1
18:01:54 <ephemient> which, if you look at its source, just re-exports Control.Applicative.Combinators.choice
18:02:12 <ephemient> so it is the same one :)
18:02:53 <ezzieyguywuf> lol, ephemient thanks, this is mostly what I was asking/looknig for
18:02:58 <ezzieyguywuf> cheater: also thanks to you!
18:03:05 <cheater> yw
18:03:14 <cheater> wish i could figure out my build issue :'(
18:04:05 <koz_> cheater: What are you building and how?
18:04:12 <ezzieyguywuf> cheater: rm -rf /, usually fixes my problems
18:04:15 <ezzieyguywuf> jk jk
18:04:19 <cheater> koz_: i'm building accelerate using cabal
18:04:21 <koz_> You said 'accelerate' - is this standalone, as part of something else, some other thing?
18:04:47 <cheater> it's used as an include, but all i'm doing is import it into an empty "cabal init" project
18:04:55 <ephemient> __p__argv sounds like an issue with windows CRT
18:05:03 <cheater> cabal is version 3.2.0.0
18:05:13 <cheater> ephemient: what's windows CRT?
18:05:23 <koz_> cheater: The C runtime on Windows.
18:05:29 <cheater> i think __p means posix and __argv is the argv.
18:05:29 <koz_> ephemient: I'd sooner blame that getopt symbol.
18:05:31 <ephemient> https://docs.microsoft.com/en-us/cpp/c-runtime-library/internal-crt-globals-and-functions
18:05:41 <cheater> and i believe these should be supplied by mingw.
18:05:47 <cheater> which i understand cabal is installing with
18:06:11 <ephemient> maybe you're linking together objects using different C runtimes
18:06:25 <cheater> not that i know of
18:06:35 <cheater> i created an empty cabal project and added this package, that's all
18:06:54 <cheater> and added an import from the accelerate package into a hello world
18:08:03 <koz_> How did you set up GHC and cabal?
18:08:37 <cheater> like this https://www.haskell.org/platform/windows.html
18:08:40 <cheater> with choco
18:09:17 <koz_> Pastebin your cabal file?
18:11:17 <cheater> one sec. i'm making an even simpler project (like without the 2-3 lines that i added that aren't related to this issue)
18:11:40 <cheater> and i'm trying to build it on C: instead of on D: in case that might be an issue (i read somewhere things might get confused sometimes)
18:12:14 <cheater> but essentially i did cabal init with cabal 3.2.0.0 and then added accelerate to the build-depends for Main.hs
18:12:20 <cheater> that's all
18:12:30 <cheater> yup
18:12:31 <cheater> that's it
18:12:35 <cheater> still breaking
18:13:01 <cheater> https://hastebin.com/inigayacum.yaml
18:13:17 <cheater> er... i didn't choose that url.
18:13:24 <koz_> Lol, it's fine.
18:13:40 <koz_> I guess you ran 'cabal new-build'?
18:13:40 <cheater> Main.hs is just this: https://hastebin.com/ojepocavep.rb
18:13:50 <cheater> i ran cabal build. it should default to v2-build.
18:13:55 <koz_> Could you pastebin the entire build log?
18:14:04 <koz_> (like, everything that came out of 'cabal build')
18:14:18 <cheater> sure, one sec
18:15:00 <cheater> https://hastebin.com/ovofafokib.php
18:16:05 <koz_> Hmm, you might actually wanna report this to the accelerate folks. This isn't _your_ code blowing up.
18:16:27 <koz_> I'm unsure if the accelerate folks even test on Windows to be honest.
18:16:51 <cheater> :(
18:18:21 <cheater> hmm
18:18:34 <cheater> let me look at the accelerate package, maybe cabal is resolving to an old version
18:21:38 <cheater> https://matrix.hackage.haskell.org/#/package/accelerate
18:21:51 <cheater> says 1.3.0.0 doesn't build on ghc 8.10.1
18:21:57 <cheater> but 1.2.0.1 does :)
18:22:02 <cheater> let me try that :)
18:24:07 <cheater> hmmmmmmmmmmmmmmmmmm.... it's complaining about base version......
18:25:13 <cheater> oh hackage matrix says "ok" when there's no install plan found :|
18:25:23 <cheater> that's stupid
18:26:07 <sm[m]> I agree
18:26:23 <cheater> ok, so looks like using chocolatey i need to install an older version of ghc.
18:26:26 <cheater> how would i do this?
18:26:52 <cheater> can i have multiple versions :|
18:26:55 <cheater> please tell me yes
18:26:57 <cheater> oh god
18:27:16 <sm[m]> you can, easily, with stack. Don't know chocolatey, sorry
18:27:36 <cheater> on windows?
18:27:41 <sm[m]> yes
18:28:18 <sm[m]> though, keep in mind many ghc versions have bothersome issues on windows. You have to pick and choose. The latest point releases may be ok right now
18:29:19 <cheater> i need one of the ones that say "OK" here:
18:29:26 <cheater> https://matrix.hackage.haskell.org/#/package/accelerate
18:29:37 <cheater> i think 8.6.5
18:29:43 <cheater> does that have a bothersome issue?
18:30:31 <sm[m]> well.. there are always windows issues, but I expect that one will be fine
18:31:02 <sm[m]> with stack, you look at https://www.stackage.org for which resolver has the ghc you want, and build/install using that
18:32:25 <sm[m]> eg: stack --resolver lts-14.27 install --dry-run accelerate-VERSION [extra packages it may ask for ...]
18:35:14 <hyiltiz> sm[m]: that commit diff, superficially, seems like a complexity explosion to take into account a design deficiency (original data structure not rich enough to represent the problem) to me
18:35:38 <cheater> how do i find the latest resolver that includes accelerate?
18:35:53 <cheater> when i google for "stackage accelerate" i get this https://www.stackage.org/lts-9.3/package/accelerate-1.0.0.0
18:35:57 <cheater> which looks like garbage
18:35:58 <koz_> cheater: stackage.org lists them.
18:36:21 <cheater> koz_: no it doesn't
18:36:25 <hyiltiz> i couldn't quite spot the cyclic reference but "well-written" tests should be able to catch cyclic references, no?
18:36:28 <koz_> It seems it's not on there, not for recent ones at least.
18:36:42 <koz_> You can have chocolatey install multiple GHC versions.
18:36:58 <cheater> oh i can?
18:37:00 <koz_> You can also specify GHC version when doing 'cabal new-configure' with the -w flag.
18:37:01 <cheater> how would i do that?
18:37:03 <koz_> Yep.
18:37:07 <koz_> Just... request another version?
18:37:15 <cheater> i've never used chocolatey tbh
18:37:17 <koz_> When you use choco install, you can specify which version you want.
18:37:23 <koz_> (there's a flag I think)
18:37:29 <cheater> oh
18:37:35 <koz_> It's been a while since I used it.
18:38:17 <Axman6> PI'm running into a problem with conflicts between functional dependencies. I have a classs Foo msg hdr | msg -> hdr where ... and another Bar msg hdr | msg -> hdr where ...; Trying to use instance (Foo msg SomeHdr) => Bar msg SomeHdr where and instance (Foo msg ADistinctHdr) => Bar msg ADistinctHdr results in a fundep conflict between the two instances
18:39:21 <sm[m]> hyiltiz: thanks for your comment. I'm glad you couldn't spot it either, it was between lines 211 and 212. Because of laziness and the length of time it was undetected, it was pretty hard to track down! https://github.com/simonmichael/hledger/commit/69edf9003edd59a9f2556bd00969314a32635191 is the fix, simplifying a bit. 
18:40:01 <cheater> thanks koz_ that helps a lot
18:40:19 <cheater> for ghc 8.6.5 which cabal version should i install? still 3.2.0.0 ?
18:40:45 <sm[m]> hyiltiz: and you're right, I can add a functional test which would detect this in future, and I probably will, but of course that won't help prevent more of these
18:40:45 <koz_> You can use any version that's more recent than... something way less than that.
18:40:54 <cheater> thanks
18:41:30 <cheater> koz_: hmm do i force choco to install multiple ghc versions?
18:41:48 <koz_> cheater: I don't remember, sorry. I know that it _is_ possible, but I don't remember how.
18:41:55 <koz_> (it's been like, nearly a year since I last touched it)
18:43:02 <koz_> What happens when you do 'choco install ghc -version 8.6.5'?
18:43:33 <cheater> i was just pasting. it errors out
18:43:43 <cheater> https://hastebin.com/ujofipulum.properties
18:44:01 <cheater> this url.... https://hub.zhox.com/posts/introducing-haskell-dev/ says "Since this functionality is provided by the cabal 3.0+ package, you can use any GHC version (or even multiple by using the choco flag -m when installing GHC) and it will just work."
18:45:03 <koz_> cheater: try 'choco install ghc -version 8.6.5 --side-by-side'
18:45:11 <cheater> yeah that's what i did. that's what -m is
18:45:17 <cheater> trying it now. thank you
18:45:37 <koz_> "PS C:\projects\cluster\cluster> choco install ghc --version 8.6.5" <-- no -m here
18:46:08 <cheater> koz_: yeah, but see what i just said
18:46:19 <cheater> right before you told me to use --side-by-side
18:46:41 <sm[m]> cheater, sounds like you may not need stack but re your question: from that stackage package page, you can click "See all snapshots accelerate appears in" -> https://www.stackage.org/package/accelerate/snapshots 
18:47:09 <koz_> If you run that command I just gave, what happens?
18:47:32 <cheater> it installed ghc 8.6.5
18:47:44 <koz_> OK, cool.
18:47:45 <cheater> but after this if i run ghc --version it still says 8.10.1
18:47:54 <koz_> Yeah, because you have it default to this.
18:48:07 <koz_> If you do 'get-command ghc-8.6.5' what do you see?
18:48:07 <cheater> and if i type ghc- and press tab, it doesn't find 8.6.5, only 8.10.1.
18:48:11 <cheater> 1 sec
18:48:24 <cheater> not recognized.
18:48:28 <koz_> OK, one moment.
18:48:40 <cheater> resterting ps helped
18:48:43 <cheater> even though i did refreshenv
18:48:56 <cheater> it's now being recognized
18:49:05 <cheater> so you said i could select the ghc version when using cabal?
18:49:50 <koz_> Yep.
18:49:57 <cheater> sorry, how would i do that?
18:50:05 <cheater> google doesn't tell me
18:50:06 <koz_> 'cabal configure -w ghc-8.6.5'
18:50:12 <cheater> thank you!
18:50:16 <koz_> Then 'cabal build' should use that one.
18:50:18 <cheater> sm[m]: thanks a lot, i looked there
18:51:36 <cheater> alright, this should work for accelerate 1.2.0.1 which should build... crossing my fingers
18:51:38 <cheater> thanks a lot
18:51:45 <sm[m]> (it shows that accelerate was last in stackage in lts-11.22, which was a couple of years ago.. not necessarily a problem, stack can still pull newer versions from hackage)
18:53:49 <koz_> cheater: Let us know if it works.
18:54:27 <cheater> it didn't!
18:54:30 <cheater> one sec.
18:55:03 <cheater> https://hastebin.com/joduvatiwa.yaml
18:55:28 <koz_> Your base version is too high for 8.6.
18:55:42 <koz_> Base version and GHC version have to align closely.
18:55:49 <cheater> shouldn't it install the correct base version?
18:56:03 <koz_> cheater: No, because it doesn't 'install' base.
18:56:06 <koz_> Base comes with GHC.
18:56:10 <cheater> the base version for 8.6.5 is 4.12.
18:56:16 <koz_> But if your Cabal file spells an impossible version, it'll barf.
18:56:31 <cheater> the base version for 8.6.5 is 4.12 and my cabal allows 4.12.
18:56:33 <koz_> Did you do 'cabal new-configure'?
18:56:51 <cheater> i deleted the full cabal project and started a new one using cabal init -w 8.6.5
18:57:21 <cheater> sorry cabal init -w ghc-8.6.5
18:57:38 <koz_> OK, is there a cabal.project.local file in there?
18:57:41 <koz_> If so, what's in it?
18:57:56 <cheater> no
18:58:06 <koz_> Then it means that 'cabal init' doesn't set this up correctly.
18:58:14 <koz_> This is why you gotta do 'cabal new-configure -w ghc-8.6.5'.
18:58:27 <koz_> Because 'cabal init' will set the right bounds, but won't staple the right compiler.
18:58:29 <cheater> why would it be wrong? the cabal file is correct. it selects the right version of base.
18:58:39 <cheater> oh, how does the compiler get "stapled"?
18:58:46 <cheater> using cabal.project.local ?
18:58:51 <koz_> In the 'cabal.project.local' file you would have if you did what I said.
18:59:15 <cheater> ok, now there's a cabal.project.local.
18:59:16 <cheater> thanks
18:59:19 <cheater> let me try again!
19:00:14 <cheater> ok, it's building. let's see if accelerate builds this time!
19:00:59 <cheater> also here's a weird thing i noticed... i created c:\projects\cluster\hello, went inside it, and did cabal init -w ghc-8.6.5 and it said "package name not specified" and then it created a full skeleton cabal project except for the .cabal file.
19:01:07 <cheater> is "hello" some sort of magical name? that's so weir.d
19:01:10 <cheater> weird.
19:01:42 <koz_> I dunno about cabal init, I never use it.
19:02:07 <cheater> i've never had this happen and i've made so many cabal packages in the past
19:02:12 <cheater> this has to be a bug
19:05:03 <koz_> So, did it build?
19:05:59 <cheater> i'll know in a while!
19:06:18 <cheater> even if it builds, it'll probably still have some issues because i think i need to install cuda and other stuff to get /that/ to work
19:06:42 <koz_> Yeah, but that's a future issue.
19:06:49 <cheater> just preparing
19:07:05 <cheater> as for now accelerate is still building, and it would have failed already on 8.10.1
19:07:20 <cheater> seems like it might actually be working, yay!
19:12:40 <cheater> ok, it compiled!
19:13:48 <cheater> thanks a lot koz_ and sm[m] !
19:13:55 <koz_> No worries.
19:13:59 <koz_> Best of luck.
19:14:11 <cheater> so now i need to figure out cuda.
19:16:27 <cheater> hmm... so...
19:16:42 <cheater> this thing says "See the Haddock documentation for additional information related to using this backend." https://hackage.haskell.org/package/accelerate-cuda
19:16:50 <cheater> but there's no haddock documentation? :|
19:17:25 <koz_> accelerate-cuda is deprecated anyhow.
19:17:38 <koz_> http://hackage.haskell.org/package/accelerate-llvm-ptx
19:17:41 <koz_> This is what you want.
19:18:07 <cheater> ohh ok thanks
19:18:15 <cheater> i wouldn't have known :D
19:18:33 <cheater> wait, does llvm work on windows?
19:18:39 <koz_> Yeah, why not?
19:19:00 <koz_> Microsoft's C++ compiler basically stole the entire Clang front-end to be C++-11 (and later) compliant.
19:19:58 <koz_> https://chocolatey.org/packages/llvm
19:21:12 <cheater> hmm ok right
19:25:22 <Squarism> I have a Traversal that i want to use with "over". over :: ASetter s t a b -> (a -> b) -> s -> t . Turns out my "(a -> b)" is actually over :: (a -> m b) . Lets call that "f" So I wonder if using the same Traversal I could somehow get a function looking like this over :: ASetter s t a b -> (a -> m b) -> s -> m t?
19:25:51 <Squarism> correction
19:25:58 <Squarism> Turns out my "(a -> b)" is actually (a -> m b)
19:26:37 <koz_> traverseOf?
19:27:35 <iqubic> traverseOf will work here.
19:28:18 <Squarism> thanks. ill try
19:32:10 <Squarism> so just replace "over" with traverseOf?   
19:35:43 <Axman6> % :t traverseOf
19:35:44 <yahb> Axman6: LensLike f s t a b -> (a -> f b) -> s -> f t
19:36:02 <iqubic> Yeah, I think that's all you need to do.
19:36:14 <Axman6> % :t traverseOf `asAppliedTo` (undefined :: a -> IO b)
19:36:14 <yahb> Axman6: ; <interactive>:1:12: error: Variable not in scope: asAppliedTo :: (LensLike f0 s0 t0 a0 b0 -> (a0 -> f0 b0) -> s0 -> f0 t0) -> (a1 -> IO b1) -> t
19:36:39 <iqubic> :t asAppliedTo
19:36:40 <lambdabot> (a -> b) -> a -> a -> b
19:36:42 <Axman6> % let asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo = const
19:36:42 <yahb> Axman6: 
19:36:44 <Axman6> % :t traverseOf `asAppliedTo` (undefined :: a -> IO b)
19:36:45 <yahb> Axman6: ; <interactive>:1:27: error:; * Couldn't match type `IO b0' with `s -> f t'; Expected type: LensLike f s t a b; Actual type: (a -> f b) -> IO b0; * In the second argument of `asAppliedTo', namely `(undefined :: a -> IO b)'; In the expression: traverseOf `asAppliedTo` (undefined :: a -> IO b)
19:36:53 <Axman6> % :t traverseOf each `asAppliedTo` (undefined :: a -> IO b)
19:36:53 <yahb> Axman6: Each s t a b => (a -> IO b) -> s -> IO t
19:37:03 <iqubic> Yeah, that will work.
19:37:12 <Axman6> who runs yahb?
19:37:22 <iqubic> Not sure.
19:37:31 <iqubic> yahb: % ls
19:37:50 <iqubic> yahb: % :q
19:38:05 <iqubic> Oh, you can't kill yahb that way.
19:45:06 <Squarism> Great, that worked out well
19:52:14 <Squarism> can you turn a value of a type into Proxy of the same type? 
19:54:23 <int-e> proxy :: a -> Proxy a; proxy _ = Proxy
19:55:24 <int-e> (or use type signatures, which may well be the standard approach)
19:58:18 <Squarism> int-e, thanks
19:59:45 <c_wraith> :t pure :: a -> Proxy a
19:59:47 <lambdabot> a -> Proxy a
20:00:28 <int-e> oh
20:00:32 <int-e> c_wraith: thanks
20:00:39 <c_wraith> it's sneaky
20:02:59 <int-e> I like sneaky things, but sometimes they come as a surprise :)
20:22:18 <cheater> koz_: hey, still around?
20:22:59 <cheater> so accelerate-llvm-ptx requires accelerate 1.3.*, but accelerate 1.3.0.0 does not build on any ghc according to matrix? so how do i get accelerate-llvm-ptx?
20:23:27 <cheater> ohhh wait i was looking at the wrong version. too tired.
20:23:52 <cheater> hi int-e 
20:24:01 <cheater> have you ever used accelerate on cuda?
20:29:39 <hyiltiz> sm[m]: if you can specify all the end points (of a acyclic graph) with tests, calling them should be able to point out cyclic dependency, no? Ideally, static code analysis should be able to catch this, once you tell it the end points.
20:37:43 <sm[m]> hyiltiz: not sure how that works in practice, I feel it's hard to ensure full test coverage of all code paths, all usage patterns etc. or even to know how much you have covered. Though, most of the time testing most of it is good enough.
21:43:33 <Athas> cheater: I have!  Although I hope you don't mean the obsolete accelerate-cuda backend?
21:43:56 <cheater> Athas: i'm trying to get accelerate-llvm-ptx to work right now
21:45:38 <Athas> My experience is that the biggest trouble by far is getting the right version of LLVM installed.
21:48:50 <cheater> that's not exactly the problem, my problem right now is to get llvm compiled
21:49:13 <cheater> currently i'm stuck on getting cl.exe 
21:49:17 <cheater> i don't know how to get it
21:49:30 <Athas> Oh, I have no idea how to do this on Windows.
21:50:20 <Athas> The Windows instructions for Accelerate start with "Oh no!".  Always a good sign.
21:52:10 <cheater> huh?
21:52:13 <cheater> where have you seen that?
21:52:18 <Athas> https://www.acceleratehs.org/get-started/windows
21:53:29 <int-e> "we've sent ahead scouts, but so far, nobody has returned"
21:53:58 <cheater> "We currently do not have any Windows machines available to test Accelerate on" man what sort of bs is that.
21:54:04 <cheater> windows is like $10.
21:54:30 <int-e> but windows is a huge moral concession
21:55:25 <int-e> but it's probably more about justifying the time spent figuring things out when you don't have a use for it yourself
21:56:33 <int-e> https://www.acceleratehs.org/get-started/windows
21:56:36 <int-e> uhm.
21:56:50 <int-e> I wanted this link: https://docs.microsoft.com/en-us/windows/win32/direct3d12/gpu-cuda-in-wsl
22:03:40 <cheater> a bsd licensed project isn't going to guilt me over moral concessions.
22:04:44 <int-e> good non sequitur
22:05:07 <cheater> not really, you can't ride the high horse if all you have is a donkey
22:22:11 <Axman6> (Asking again becaus eI didn't seem to het any answers earlier) I'm running into a problem with conflicts between functional dependencies. I have a classs Foo msg hdr | msg -> hdr where ... and another Bar msg hdr | msg -> hdr where ...; Trying to use instance (Foo msg SomeHdr) => Bar msg SomeHdr where and instance (Foo msg ADistinctHdr) => Bar msg ADistinctHdr results in a fundep conflict between the two instances
23:05:42 <koz_> cheater: I sympathise, but cannot assist. I can work (kinda sorta) Haskell stuff on Windows, but nothing beyond that.
23:06:16 <cheater> gotcha
23:06:20 <koz_> cheater: What is cl.exe?
23:58:48 <zincy__> Evening koz_
23:58:56 <koz_> zincy__: Yo.
23:59:13 <zincy__> How are things
23:59:43 <zincy__> Question, Do you separate your IO code from your non IO stuff generally?
