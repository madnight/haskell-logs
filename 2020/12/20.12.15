00:47:14 <kuribas> What are the unique features of servant?
00:47:48 <kuribas> IMO you could have a formal specified API without actually doing type level computations.
00:48:10 <kuribas> I guess the only unique feature of servant is that it can generate both a client and server from the same API.
00:48:21 <kuribas> Which would be hard to do with value level computations.
00:48:51 <kuribas> Also generating documentation wouldn't require a type level API.
00:48:57 <lortabac> kuribas: "a formal specified API without actually doing type level computations" -> yes, but you would need code generation
00:48:59 <dminuoso> It provides a type checked way to ensure your client/server handler specification line up.
00:49:10 <kuribas> lortabac: how so?
00:49:12 <dminuoso> Under the hood I'd rather think of servant as generics than the other way around.
00:49:21 <lortabac> kuribas: how not so? :)
00:49:36 <kuribas> lortabac: combinators?
00:50:07 <dminuoso> kuribas: You can get away without it, see scotty.
00:50:25 <dminuoso> But you get absolutely no compile time guarantees, and you have assert routing dynamically, assert parameters dynamically, etc
00:50:27 <kuribas> dminuoso: does scotty allow you to generate a swagger spec?
00:50:31 <kuribas> right
00:50:31 <lortabac> the other libraries to basically Value -> Value
00:50:39 <dminuoso> And you get no static analyzability to build documentation, generate swagger
00:50:40 <dminuoso> etc
00:50:42 <dminuoso> kuribas: No
00:50:57 <kuribas> I mean, my point is that it should be *possible*.
00:51:05 <dminuoso> With a selective- framework, yes.
00:51:07 <lortabac> kuribas: you would have to start from the specs (Swagger or other) and generate code
00:51:18 <dminuoso> If there was some selective-scotty, you could generate swagger from it
00:51:23 <kuribas> right 
00:52:19 <kuribas> hmm, selective functors may be the thing for a graphql API...
00:52:36 <lortabac> dminuoso: interesting, I had never thought about that
00:53:33 <isovector1_> is there a way to set the history size for :trace when debugging in ghci?
00:53:39 <isovector1_> it seems to only keep 50
00:53:41 <lortabac> dminuoso: do you have an example of how this would work?
00:53:52 <isovector1_> which isn't helpful if you're in a deep list comprehension
00:54:30 <dminuoso> lortabac: The same as optparse-applicative, really.
00:58:31 <dminuoso> Perhaps applicative is enough in fact
01:00:19 <lortabac> strange that nobody has come up with the idea until now
01:00:57 <dminuoso> I mean with selective we could do dynamic route dispatching based on content
01:00:59 <dminuoso> something like
01:05:09 <dminuoso> router = ((get "/users/" *> intParam "userId") <&> getUserAction) <> (get "/users/" *> getUsersAction)
01:05:12 <dminuoso> vs
01:06:03 <dminuoso> router = (branch (get "/users/" *> intOrStr "userId") userByIdAction userByNameAction) <> (get "/users/" *> getUsersAction)
01:07:09 <dminuoso> The idea seems cool, and would address some of the issues scotty has
01:07:57 <dminuoso> Statically verify the routes dont overlap, have the type checker assist in correct action types, generate documentation/swagger/router
01:18:20 <Kronic> is there a way to execute stack ghci such that I don't need to reboot it when I install a new dependency?
01:22:56 <kuribas> dminuoso: what's selective there?
01:23:01 <kuribas> it looks just applicative
01:24:14 <dminuoso> kuribas: the `branch` is selective
01:24:53 <dminuoso> Ah, the code is a bit weird
01:24:55 <dminuoso> Let me fix that
01:27:42 <kuribas> dminuoso: how is that different from alternative?
01:27:53 <kuribas> I would separate branches with alternative
01:28:38 <dminuoso> kuribas: you dont get dynamic choice with alternative.
01:40:22 * kuribas needs to read the paper...
01:45:30 <guest1214> parseServer :: Parser String; parseServer = string "server="; parse parseServer "not matched" "server=abc";  -- this can detect if the input string contain "server=" or not, how to get the value abc?
01:46:27 <guest1214> parseServer = {do;  string "server="; return}?
01:48:24 <guest1214> parseString :: Parser LispVal; parseString = do  char '"';  x <- many (noneOf "\"");  char '"';  return $ String x -- I saw an example like this, but I don't understand what it means?
01:48:25 <guest1214>  
01:48:56 <guest1214> what "many (noneOf "\"")" is working on?
01:54:45 <kuribas> guest1214: that parses all characters upto (not including), a literal double quote.
01:55:24 <kuribas> noneOf fails when it sees the given characters, otherwise it succeeds.
01:55:39 <kuribas> sees *one of* the given characters I mean
01:56:01 <kuribas> remmber thatt "\"" is the same as ['"']
01:56:12 <kuribas> a list with a single character.
01:57:04 <guest1214> kuribas: but what `many (noneOf "\"")` apply on?
01:57:45 <kuribas> guest1214: the input stream I suppose?
01:57:50 <kuribas> it's a parser after all
01:58:05 <guest1214> kuribas: but there's no a parameter name
01:58:40 <kuribas> your question is not clear
01:59:03 <kuribas> you mean the input stream as a parameter?
01:59:19 <guest1214> kuribas: this first `char '"'` and the last `char '"'` will match double quote symbol in "abc", right?
01:59:25 <kuribas> yes
02:00:08 <guest1214> then `many (noneOf "\"")` will apply on abc from "abc", right?
02:01:02 <kuribas> yes
02:01:48 <guest1214> wait a sec, but "abc" :: String, and `parse parseString "not matched" "abcde"`   "abc" is not Parser String, that's ok?
02:04:36 <kuribas> can you rephrase that?
02:05:58 <guest1214> parse parseString "not matched" "abc=def"
02:06:10 <guest1214> this input stream "abc=def" is String
02:06:19 <guest1214> parseString :: Parser String
02:07:02 <guest1214> parse function make parseString apply on "abc=def" ?
02:30:05 <johnnyboy[m]> anybody here has experience with regex-tdfa?
02:31:41 <johnnyboy[m]> I wonder what I'm doing wrong
02:32:41 <johnnyboy[m]> I have a regex made of this string: https://privatebin.net/?8f55cd084f15cd74#6H8ddBJ38nLkxQYTHRmw8F7aNkejTf4EvNHJ4rB9fQr9
02:33:06 <johnnyboy[m]> but it fails to match "0:05.66"
02:33:24 <johnnyboy[m]> the documentation fails to specify the supported syntax
02:33:45 <johnnyboy[m]> so I wrote the expression down in a rather primitive way
02:34:59 <johnnyboy[m]> wait, I should try grep first
02:35:08 <johnnyboy[m]> to see if I made a stupid mistake somewhere
02:36:54 <johnnyboy[m]> ok, my regex might be messed up
02:37:24 <johnnyboy[m]> still, I'd appreciate more comprehensive documentation on supported syntax
02:38:46 <int-e> johnnyboy[m]: is it the \\ ?
02:38:56 <johnnyboy[m]> seems to be
02:39:12 <int-e> Because the syntax is \. but when writing it as a Haskell string you need to quote the \ again.
02:39:45 <johnnyboy[m]> no, wait
02:39:51 <johnnyboy[m]> it was the '?'
02:40:01 <johnnyboy[m]> the "[0-5]?"
02:40:32 <johnnyboy[m]> "[0-9]:[0-5][0-9]\\.[0-9][0-9]" matches fine
02:41:01 <int-e> ah
02:41:13 <tomsmeding> johnnyboy[m]: the docs state "This regex-tdfa package implements, correctly, POSIX extended regular expressions." -- the relevant posix standard is here: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
02:41:18 <tomsmeding> in case you're feeling adventurous :p
02:41:39 <tomsmeding> but "posix extended regular expressions" is a search term that will also give you simpler explanations
02:41:48 <johnnyboy[m]> ah, sorry
02:41:52 <johnnyboy[m]> blindness strikes again
02:42:02 <tomsmeding> indeed you might need to do \?
02:42:32 <tomsmeding> ... or not, that's only BRE. ERE seems to treat ? specially even without a \
02:43:05 <tomsmeding> so test it with grep -E
02:43:31 <int-e> "0:00.00" =~ "([0-9]+:[0-5][0-9]:[0-5][0-9]|[0-5]?[0-9]:[0-5][0-9]\\.[0-9][0-9])" :: Bool -- returns True for me.
02:43:34 * int-e is confused.
02:43:59 <johnnyboy[m]> grep understands "[0-5]\?[0-9]:[0-5][0-9]\\.[0-9][0-9]"
02:44:01 <int-e> (module: Text.Regex.TDFA, package: regex-tdfa-1.3.1.0)
02:44:09 <johnnyboy[m]> whoops
02:44:26 <johnnyboy[m]> I'm using Revolt, which seems to remove some backslashes
02:46:15 <int-e> Yeah I still think that quoting (number of backslashes) is the most likely thing to go wrong here.
02:46:31 <johnnyboy[m]> okay, thanks
02:46:40 <tomsmeding> try simpler expressions first that test each of your individual special characters
02:46:40 <johnnyboy[m]> I need to check the backslashes then
02:47:12 <tomsmeding> 99.9% of the time, when your regex doesn't work and it's not using zero-width lookahead or lookbehind, the problem is backslashes :p
02:47:48 <johnnyboy[m]> int-e: Thanks, your expression works for me, too!
02:48:57 <johnnyboy[m]> I wonder what it means that the documentation of regex-tdfa says that 'This package does not provide "basic" regular expressions'
02:50:14 <kuribas> guest1214: you're not trying to match against an unquoted string?
02:52:01 <tomsmeding> johnnyboy[m]: posix defines "extended regular expressions" (ERE) and "basic regular expressions" (BRE)
02:52:04 <tomsmeding> I assume they refer to that
02:52:20 <tomsmeding> grep implements BRE, 'grep -E' or egrep implements ERE
02:52:36 <johnnyboy[m]> ah
02:52:46 <johnnyboy[m]> so does regex-tdfa support ERE, then?
02:52:54 <tomsmeding> that's what the docs claim 🤷
02:53:24 <johnnyboy[m]> I see
02:54:36 <tomsmeding> they additionally claim that most system libraries do _not_ implement ERE even if they claim they do, because they apparently often have bugs that regex-tdfa doesn't
02:56:21 <johnnyboy[m]> weird
02:56:25 <johnnyboy[m]> it still doesn't seem to work
02:56:57 <johnnyboy[m]> by, the way, I'm using matchOnceText
02:58:45 <tomsmeding> also not for simpler expressions?
02:59:12 <tomsmeding> like, "\\.", and "a?", and "a|b", and "a+" :p
02:59:13 <johnnyboy[m]> for simpler expressions, it seems to work
02:59:24 <tomsmeding> then incrementally grow until you find the part that doesn't work
02:59:31 <johnnyboy[m]> I haven't tested extensively, though
02:59:34 <tomsmeding> and then shrink on that part again :)
02:59:43 <johnnyboy[m]> by simpler expressions, I meant my other expressions
02:59:49 <johnnyboy[m]> they seem to work just fine
03:00:19 <johnnyboy[m]> incremental approach sounds like the smart thing to do
03:05:13 <johnnyboy[m]> okay, actually it does seem to work now
03:05:25 <johnnyboy[m]> so I have something wrong elsewhere in my code
03:05:29 <johnnyboy[m]> thanks for the help!
03:12:21 <tomsmeding> good luck!
03:26:56 <johnnyboy[m]> actually, it does seem to be a regex issue after all
03:27:43 <johnnyboy[m]> it seems that my regexes are haunted
03:27:50 <johnnyboy[m]> they fail to match even "(.)+"
03:29:21 <johnnyboy[m]> now I found the error
03:29:46 <johnnyboy[m]> I had unescaped parentheses where I wanted to match the characters '(' and ')'
03:29:47 <johnnyboy[m]> :D
03:29:51 <johnnyboy[m]> such a rookie mistake
03:36:39 <johnnyboy[m]> I learned to always check my backslashes in the future
03:36:56 <Kronic> Can be helpful to split it up into a few lines rather than having one monster regex 
03:37:47 <johnnyboy[m]> yes
03:39:30 <johnnyboy[m]> it's funny how the line breaks are "\\\\\n" in my latex output
03:39:51 <johnnyboy[m]> hm. it looks to me that my client removed two backslashes again
03:39:57 <johnnyboy[m]> there should be five of them
03:46:12 <arahael> There _are_ five of them.
03:46:40 <arahael> Or rather, only two of them, and a newline. ;)
03:56:14 <tomsmeding> johnnyboy[m]: I think in your matrix client you see the markdown-parsed version, which has backslashes removed; we on irc see the "fallback" plain-text version that has no markdown parsing, and thus no backslash dropping, applied
03:56:43 <johnnyboy[m]> ok
03:57:15 <tomsmeding> (try a code block with backticks ` to also display the characters as-is in your matrix client ;) )
03:57:32 <johnnyboy[m]> `\\\\\n`
03:57:37 <johnnyboy[m]> oh, cool!
03:57:55 <tomsmeding> the more you know :)
04:00:02 <johnnyboy[m]> LaTeX support would be awesome :D
04:00:38 <johnnyboy[m]> it's always so hard to communicate math formulas through electoric messaging
04:00:54 <johnnyboy[m]> but that's off-topic, sorry
04:02:07 <[exa]> there are katex and similar plugins for all possible chat systems, usually working with the latex math parens like \(\frac{\pi}{2}\)
04:04:41 <johnnyboy[m]> guess I should google katex
04:05:16 <cnmne[m]> this might be relevant
04:05:17 <cnmne[m]> https://github.com/matrix-org/matrix-react-sdk/pull/5244
04:11:07 <johnnyboy[m]> ok, thanks!
04:45:24 <hseg> Am getting stack overflows from a bit of quickcheck. Recommendations?
04:46:11 <hseg> Add HasCallStack constraints to all top-level functions in my codebase?
04:46:40 <hseg> also, how can i add callstacks to instance functions?
04:48:44 <dminuoso> hseg: Compile with profiling, generage cost centres to all top level functions?
04:49:28 <dminuoso> And then do a heap profile?
04:49:40 <hseg> remind me how i do that last bit?
04:50:28 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-for-profiling
04:51:06 <dminuoso> (Also -p is of interest)
04:51:23 <dminuoso> See also related https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-heap-prof
04:51:38 <hseg> ty
04:53:32 <hseg> hrm. ok, seems i'll need to package up my test case as an executable to do that
04:53:37 <hseg> no problem
05:00:49 <hseg> hrm. for some reason i get an empty profile
05:01:51 <hseg> i mean, i have profiling: True and profiling-detail: all-functions in my cabal.project, so cabal run sandbox-algebra -- +RTS -p -RTS should give me a profile, right?
05:02:48 <geekosaur> --RTS or cabal itself will eat the profiling option (and probably do nothing since it wasn't built for profiling)
05:03:03 <geekosaur> in place of the -- that is
05:04:27 <dminuoso> hseg: It should, yes.
05:05:02 <hseg> ok, -h gives me a heap profile, so at least that's something
05:07:23 <hseg> ok, it's the usual culprit. have too little laziness in my multiplication function, which causes the entire combinatorial structure to be forced
05:08:06 <hseg> i suppose profiling makes things heavier in heap, right?
05:08:30 <xerox_> why is there a big difference between IOUArray and STUArray?
05:08:45 <hseg> which is why my stack overflow is overshadowed by the testcase eating all the memory
05:08:45 <xerox_> the same exact algorithm takes 10 times the time with the first one, I had no idea
05:09:45 <merijn> xerox_: The U in STU is for *unboxed*
05:10:00 <merijn> Oh, wait, the IO one too
05:10:09 <xerox_> yeah!
05:10:23 <merijn> xerox_: Time to dive into the Core :p
05:10:28 <xerox_> oh boy
05:10:31 <int-e> xerox_: I don't think there *should* be a difference
05:10:47 <xerox_> int-e: I expected the same really
05:10:50 <int-e> so it's interesting if you see one
05:11:06 <xerox_> I'll share some code let me tidy it up
05:12:27 <merijn> xerox_: Oh, this is compiled and with -O2, yes?
05:13:02 <xerox_> yes
05:13:03 <hseg> hrm. any ideas on how to improve http://ix.io/2I9Q's behaviour?
05:13:04 <int-e> there's the state hack thing, is that specific for the real world token?
05:13:55 <int-e> I don't know, compiling with -fno-state-hack may rule out this idea
05:14:40 <hseg> basically am trying to count up all the different ways two [m] can be joined together
05:15:08 <hseg> where i care about which element gets matched up with which, but not about order
05:16:17 <Kronic> in megaparsec, what is the correct pattern to use to parse a string up until a particular String?
05:16:22 <Kronic> I guess takeWhileP ?
05:17:12 <hseg> (this means i have O(sum_k choose(|n|,k)*choose(|m|,k)) different terms)
05:17:43 <merijn> Kronic: manyTill ?
05:17:56 <merijn> Kronic: takeWhileP is until a specific character
05:18:13 <merijn> Kronic: Note that most relevant combinators are re-exported from parser-combinators
05:18:20 <Kronic> ah thank you
05:18:33 <xerox_> you know I might have forgotten an 'U' in the IO case, I need to make sure I did use IO*U*Array
05:18:37 <xerox_> that would explain it
05:18:42 <merijn> xerox_: lol
05:18:58 <xerox_> no compassion ):
05:19:21 <merijn> so my comment was right, despite being wrong ;)
05:22:16 * xerox_ slaps forehead
05:22:25 <xerox_> that was exactly it, my bad
05:29:58 <hseg> actually, that simplifies to O(binom(n+m,n`min`m))
05:31:01 <int-e> to err is human...
05:31:45 <xerox_> given that my implementations of play and playIO are identical except for the return type it should be possible to write a more general type and the function just once right? https://pastebin.com/raw/vcdkyHSG
05:32:48 <xerox_> something like MagicalClass m, MagicalArray a => [Int] -> m (a Int Int)
05:33:33 <merijn> xerox_: Or...just define a datatype, rather than a class ;)
05:33:57 <Kronic> Does megaparsec have an equivalent of anyChar ?
05:33:58 <xerox_> that's not a bad idea, so I'd have the 'arr' inside, and the two versions
05:35:34 <merijn> I do that to compare "channel types", see: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan/benchmarks/Channels.hs#L46-L60
05:35:58 <xerox_> I guess Monad m => should be enough tho
05:36:13 <xerox_> maybe Monad m and MArray a Int Int works
05:36:33 <merijn> xerox_: You can capture the Array type existentially
05:37:14 <int-e> :t Control.Monad.ST.stToIO
05:37:16 <lambdabot> ST RealWorld a -> IO a
05:37:44 <int-e> which gets you most of the way, hmm
05:38:14 <int-e> :t GHC.IOArray.IOArray
05:38:15 <lambdabot> GHC.Arr.STArray RealWorld i e -> GHC.IOArray.IOArray i e
05:38:45 <int-e> I guess this part isn't exposed through official means.
05:38:48 <xerox_> neat
05:41:48 <int-e> :t Control.Monad.ST.Unsafe.unsafeIOToST -- this one exists as well, and is as powerful as unsafePerformIO
05:41:50 <lambdabot> IO a -> ST s a
05:42:27 <xerox_> makes sense, since you can runSt
05:47:30 <Kronic> ah it is anySingle
05:50:23 <Kronic> Weird tbh, is there any reason for this pattern of renaming things? if anySingle has the same functionality as anyChar why not just have anySingle available as the default then have anyChar as an alias in  the Char package? That's what I was expecting but I guess there is a good reason for it...
05:52:23 <geekosaur> because there are multiple types for which a Stream is composed of Char-s, but also multiple where it isn't?
05:53:03 <geekosaur> multiple Stream types
06:18:45 <Kronic> I understand, I just thought the name should have been persisted as an alias. I'm new to megaparsec so finding out what anyChar was, where I can find it and so on is a bit of a pain if you use an out of date tutorial
06:38:16 <sondr3> I've written a simple Scheme interpreter over the last few weeks and occasionally GADTs have come up and after reading myself up on them I'm curious of the benefits of using them over regular ADTs when you might want to compile the language? From what I've read GADTs are useful to leverage Haskells type system for usage in e.g. interpreters
06:39:37 <sondr3> I've been wanting to try to "compile" it to WebAssembly for example
06:43:49 <lortabac> sondr3: a typical example is a GADT that represents the terms of a simply-typed lambda calculus in such a way that only well-typed terms can be constructed
06:44:32 <merijn> Of course that only works if you have dependent types or write your AST directly using GADTs
06:44:40 <merijn> Because *parsing* GADTs is a PITA :p
06:45:07 <lortabac> yes, you need singletons, which is not the most ergonomic thing in the world :)
06:47:45 <lortabac> merijn: you can also parse the language and write the GADT source code to a file :P
06:47:57 <merijn> Also, note that the ability to represent ill-typed ASTs can be a feature too :)
06:48:23 <lortabac> sondr3: in the case of Scheme, I don't think this technique makes much sense
06:50:03 <sondr3> Yeah, I'll just stick with what I have, thanks :)
07:00:15 <__monty__> Is there a way to have a vector grow upon insert if the index would go out of bounds?
07:02:38 <dolio> There might be a package that implements that on top of vector, but I don't know of one, and it isn't how the popular vector packages work.
07:10:39 <ephemient> I did build something like that on top of Array (not Vector) a while back. not too hard, probably easier for Vector where you can only grow in one direction
07:11:41 <dolio> Maybe just primitive is a better base, because you don't need quite a lot of stuff in vector.
07:53:22 <fuzzypixelz> hello. I was told that in Haskell function application is prioritized, for this reason I don't know why `square addOne 0 + 2` fails and I have to do `square (addOne 0) + 2`.
07:53:53 <fuzzypixelz> oops, I see it, whitin a split second of sending that haha
07:54:40 <fuzzypixelz> I think the compiler wouldn't know if it should pass addOne as an argument or pass it the value 0
07:54:46 <fuzzypixelz> anyway, silly me
07:56:19 <lortabac> fuzzypixelz: 'square addOne 0' means "apply the function 'square' to the arguments 'addOne' and '0'"
07:58:39 <slack1256> On `cabal v2-repl` can I pass values to be replaces CPP phase? if so, how?
07:59:19 <slack1256> *on the CPP 
08:03:15 <fuzzypixelz> Are Non-exhaustive function patterns run-time exceptions?
08:05:18 <gehmehgeh> fuzzypixelz: why don't you try yourself? ;)
08:09:30 <fuzzypixelz> gehmehgeh: yes I tried and couldn't believe it, something so silly as forgeting a catch-all condition could crash my program! haha
08:11:32 <merijn> fuzzypixelz: Enable -Wall ;)
08:11:41 <merijn> Then the compiler will yell at you :p
08:12:17 <fuzzypixelz> oh that's nice
08:13:52 <merijn> fuzzypixelz: I recommend defaulting to -Wall on and selectively disabling warnings if/when you decide they aren't useful
08:13:56 <fuzzypixelz> I sincerely apologize to the Glorious Haskell Compiler for being so blasphemous
08:16:18 <fuzzypixelz> merijn: I'll keep that in mind
08:17:54 <fuzzypixelz> Since IO is so complicated and my reading speed can't carry me to the respective chapter yet, I shall allow myself to use the `error` function to get the output a the end of my programs, for now.
08:26:08 <__monty__> Don't be afraid of IO.
08:27:39 <justsomeguy>  Which book are you reading, fuzzypixelz?
08:29:55 <fuzzypixelz> justsomeguy: learn you a haskell for good
08:32:50 <tomsmeding> fuzzypixelz: if you want some quick-and-dirty way to add some input and output to your program, you can use 'interact': https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:interact
08:33:08 <tomsmeding> it's mostly only useful if you first read a bunch, then write a bunch, and then are done
08:33:25 <sm[m]> @where HTAC is another good one; IO doesn't have to be too complicated
08:33:25 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
08:33:51 <tomsmeding> but it allows you to write 'main :: IO () ; main = interact myPureFunction', where myPureFunction has type 'String -> String' and does not involve any IO at all
08:48:08 <merijn> fuzzypixelz: Note that LYAH is widely considered "not great" in terms of education
08:50:10 <justsomeguy> Why is that, merijn?
08:50:54 <merijn> justsomeguy: The order in which it introduces things is a bit random, it doesn't explain everything in sufficient details, has no exercises, and generally leaves people unprepared to actually write code
08:51:38 <justsomeguy> Hmm... I've only skimmed through it. In contrast to HPFP, I find the brevity attractive, though.
08:51:48 <merijn> LYAH has a good representation because when it came out it was one of the only free and accessible texts on Haskell, but history has mostly obsoleted it as teaching tool
08:52:00 <merijn> justsomeguy: HPFP is on the other side of brevity, yes :p
08:52:21 <justsomeguy> Having tons of examples seems to be essential, I think.
08:52:53 * justsomeguy has only partly read through a few books on haskell, but he thinks he likes Get Programming With Haskell by Will Kurt the most.
08:52:53 <merijn> But there are other books which are widely regarded better than LYAH, such a Richard Bird's "Thinking Functionally With Haskell" or Graham Hutton's "Programming in Haskell"
08:54:13 <justsomeguy> I'm going to have to read Huttons book sometime, it looks really well articulated.
08:54:35 * justsomeguy appreciates good editing and narrative structure, a lot.
08:54:55 <sm[m]> justsomeguy++
08:55:10 <merijn> justsomeguy: LYAH is great as an appetizer of "look at these neat things!", but not for actually *understanding* those neat things :p
08:55:18 <sm[m]> I think HTAC has that too. Here's HTAC's IO intro: https://leanpub.com/haskell-cookbook/read#leanpub-auto-hello-io--monad
08:55:55 <sm[m]> (in which I just learned why they are called Monads)
09:00:34 <justsomeguy> “Every IO () action returns exactly one value. Think of the word “mono” (or “one”) when you think of Monads because they always return one value.”
09:00:38 <justsomeguy> Neat :^)
09:01:42 <quantumvatican> Hello, I would like help with advent of code #15. My program crashes (killed by the shell) on part 2 and don't understand why. I am iterating a function f : Foo -> Foo where Foo contains a strict IntMap from numbers to their last position (so not storing the whole list). Foo also contains the current turn and my main call is "until (current turn is the target) f input".
09:01:54 <quantumvatican> Am I missing something?
09:02:09 <dolio> That explanation sounds wrong.
09:02:16 <justsomeguy> Can you link to your source code?
09:02:17 <koz_> quantumvatican: Could you please pastebin your code?
09:02:21 <koz_> Ninjas...
09:02:49 <quantumvatican> Could you tell me what you think is wrong?
09:02:49 <dolio> The 'mon' in monad coms from monoid, and has nothing to do with 'returning one value'.
09:04:12 <boxscape> where does the -ad come from?
09:04:59 <geekosaur> @quote triad
09:05:00 <lambdabot> geekosaur says: so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be
09:05:00 <lambdabot> understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
09:05:02 <dolio> Triad.
09:05:15 <boxscape> hm, I see
09:05:37 <boxscape> I suppose the word Monad also already existed in other fields when he started using it
09:05:38 <boxscape> 
09:05:42 <dolio> One of the names before monad was "(Kleisli) triple".
09:05:46 <quantumvatican> @koz_ here is my code, thank you for your help https://framabin.org/p/?28fc06ad9cd05caf#n2HvY17DG4mRGbd4Zio9UoT169hX5P2wCoXuauBz9KY=
09:05:46 <lambdabot> Unknown command, try @list
09:06:07 <geekosaur> there's an overview of the existing terminology on the referenced page, iirc
09:06:19 <dolio> Yeah, it might also be a pun, since apparently some category folks liked that.
09:06:54 <dolio> Kind of a nonsense pun, since it has nothing to do with Leibniz's monads.
09:09:39 <dolio> I've heard that one of the big names in categoy theory liked to repurpose philosophy terms into math terms, I guess regardless of whether there's even a tenuous connection between them. :)
09:09:48 <koz_> quantumvatican: What exactly is the message that you get when your program crashes?
09:10:06 <geekosaur> proably "Killed" given what they said earlier
09:10:16 <geekosaur> i.e. the OOM catcher got it
09:11:06 <boxscape> quantumvatican can you try making your datatype strict, i.e. adding ! in front of (IntMap Position), Int, and Turn?
09:11:37 <koz_> Also, did you import the strict IntMap?
09:17:14 <dminuoso> Mmm, so we can do bang annotations in the definition of a function, but why not at the call site?
09:17:36 <boxscape> instead of seq?
09:17:42 <dminuoso> Well, in terms of seq.
09:17:53 <boxscape> right
09:18:17 <dminuoso> seq is ergonomically a wart, BangPatterns feel much more natural :)
09:18:29 <geekosaur> there's $!
09:18:55 <glguy> dminuoso: I think it just feels different
09:19:36 <dminuoso> geekosaur: Ohh nice, yeah I guess we dont need syntax if we can just supply it via a haskell world operator.
09:21:22 <mjrosenb> I did today's AoC problem in haskell and python, I suppose I shouldn't be surprised that the solution in python is 3x the speed of the haskell one.
09:21:36 <glguy> what speeds did you get?
09:21:53 <boxscape> python is interpreted and haskell is compiled, so some surprise is warranted
09:21:57 <mjrosenb> ~18 seconds in python, ~45 seconds in haskell
09:22:10 <glguy> mjrosenb: the haskell solution should run in under a second
09:22:17 <mjrosenb> the problem is more or less 30,000,000 hash lookups and insertions.
09:22:31 <dolio> Seems like whether you should be surprised depends on how good you are at writing things in each language. :)
09:22:38 <boxscape> I have 40 seconds in haskell and 650ms in C, but it's because I used a mutable array in C and an immutable IntMap in haskell
09:22:59 <glguy> the C time is reflective of a Haskell solution using a mutable array
09:23:06 <boxscape> makes sense
09:23:51 <mjrosenb> I'm /way/ more comfortable with haskell than python, but I haven't spent that much time attempting to optimize beyond overall complexity.
09:27:06 <Kronic> Perhaps post both solutions 
09:27:49 <mjrosenb> one min...
09:28:29 <mjrosenb> haskell: https://gist.github.com/mjrosenb/11552f705f504ed772187b90462c0ebd
09:29:56 <mjrosenb> python: https://gist.github.com/mjrosenb/f8dc6d29162dca25e59d2a0226cc7767
09:32:42 <mjrosenb> the haskell one is the one that I actually used, ergo, it takes the problem input from stdin, the python one was just me seeing if python was faster due to constant time lookups, and therefore has the input hardcoded.
09:33:35 <Kronic> I'll be the first to say that I am an expert in neither language, I'm pretty new to Haskell, but to me it looks like they are two completely different approaches 
09:35:11 <geekosaur> well, yes, it's not uncommon that you want a different approach in Haskell
09:35:51 <Kronic> Sure, but these aren't even trying to be roughly equivalent so how could they be comparable?
09:36:11 <mjrosenb> I think they're pretty similar, have a map from each value to the last index that that value was seen at.
09:36:46 <mjrosenb> at each step, check what the index that the previous number was last seen at
09:36:59 <mjrosenb> generate a new number, and insert the previous one into the map.
09:38:16 <mjrosenb> in the haskell version, I added some extra functions and wrapped the state into a datatype, but those should be superficial differences.
09:42:36 <hseg> hrmph. replacing quickCheck with verboseCheck forced my thunks and solved my space leak
09:43:44 <hseg> should replace my maps with strict maps instead. i think it might solve some of my memory problems
09:45:35 <hseg> indeed, should use containers' advice and replace with hashmaps considering i don't really need the ordering
09:45:47 <dminuoso> hseg: did the profiling help?
09:46:47 <hseg> profiling found the main source of errors, which was the usual suspect. changed algorithms, no help. trying to get more data, used verboseCheck. it forced thunks and solved the memory leak
09:47:05 <hseg> so i'm converting to strict maps to see if that doesn't solve it
09:52:34 <dsal> mjrosenb: this is 900 ms on my macbook: https://www.irccloud.com/pastebin/RtaAP8sh/st.hs
09:55:14 <hseg> hrmph. monoidal-containers has several annoying inconsistencies
09:56:04 <hseg> eg hashmap expects you to cast using newtype for some functions, map.strict.mapkeys is accumulating vs map.mapkeys being nonaccumulating, etc etc
09:58:13 <z0> what's the canonical way to filter [(a,b)] on b ?
09:58:33 <koz_> z0: filter (predicate . snd) ?
09:59:03 <mjrosenb> dsal: what module do I need to get for MV and runST?
09:59:18 <koz_> mjrosenb: MV is probably Data.Vector.Mutable.
09:59:25 <koz_> runST is Control.Monad.ST
09:59:40 <z0> i do it so often, im writing a helper function. just checking, thanks
10:00:45 <mjrosenb> danke.
10:01:28 <dsal> mjrosenb: I'm using unboxed vectors.
10:01:32 <dsal> unboxed mutable.
10:02:59 <mjrosenb>     Could not find module ‘Data.Vector.Mutable’
10:03:08 <mjrosenb> I'll figure that out later.
10:04:07 <dsal> @where Data.Vector.Mutable
10:04:07 <lambdabot> I know nothing about data.vector.mutable.
10:04:30 <dsal> https://hackage.haskell.org/package/vector/docs/Data-Vector-Unboxed-Mutable.html
10:04:39 <xerox_> z0: it's also good to know about list comprehensions [ .. | (_,b) <- xs, predicate b ] sometimes it reads well and lets you do other stuff at the same time
10:04:53 <dmj`> :t \x -> scanl (foldl x)
10:04:55 <lambdabot> Foldable t => (b -> a -> b) -> b -> [t a] -> [b]
10:12:51 <z0> oh man thats beatiful
10:15:10 <boxscape> > (\x -> scanl (foldl x)) (-) 0 [[1,2],[2,3]]
10:15:12 <lambdabot>  [0,-3,-8]
10:17:44 <z0> > (scanl . foldl) (-) 0 [[1,2],[2,3]]
10:17:47 <lambdabot>  [0,-3,-8]
10:24:31 <hseg> The Map type is shared between the lazy and strict modules, meaning that the same Map value can be passed to functions in both modules. This means that the Functor, Traversable and Data instances are the same as for the Data.Map.Lazy module, so if they are used the resulting maps may contain suspended values (thunks).
10:24:34 <hseg> WTF?
10:25:01 <koz_> hseg: Map (and HashMap) have strict _functions_, not strict _data_ as such.
10:26:33 <hseg> hrm. any reason for preferring the former over the latter?
10:26:34 <merijn> hseg: What's so weird about that?
10:27:20 <hseg> i understood strict maps were strict over their values and spines, whereas lazy maps were only lazy in spines
10:27:32 <merijn> hseg: Lazy is good if the values are mutually recursive (i.e. computing them does lookups in the same Map, such as dynamic programming style tricks) or when computing the value is slow and you don't need all of them
10:27:36 <merijn> hseg: eh, no
10:27:42 <merijn> hseg: Both strict and lazy map have a strict spine
10:27:54 <merijn> A lazy spine would have *terrible* performance
10:28:05 <hseg> oops, mistyped. meant lazy is only strict in spine
10:28:09 <hseg> but lazy in values
10:28:12 <merijn> hseg: Right
10:28:29 <merijn> hseg: But that doesn't contradict the docs you quoted
10:28:47 <merijn> hseg: The docs are just saying that the strictness is enforced by the functions, not by the datatype
10:29:22 <hseg> sure... but class instances cannot enforce strictness because of this
10:29:46 <merijn> "class instances" ?
10:30:00 <hseg> Functor, Traversable, Data
10:30:31 <hseg> any reason for this choice over cloning the datatype mod strictness annotations?
10:30:41 <koz_> hseg: Are you concerned that, say, fmap, will stuff a should-be-strict map full of lazy values?
10:30:49 <hseg> yup
10:30:51 <merijn> hseg: The fact that you don't have to repeatedly do "toStrict" when interacting with different APIs? :p
10:31:50 <hseg> arguably, you should. we don't see Int and Int# as similar enough to be convertible, after all
10:32:00 <hseg> why is this any different?
10:32:23 <hseg> (otoh, polymorphism in both of these *would* be nice)
10:32:37 <hseg> (for the latter, this exists as levity polymorphism)
10:33:36 <dsal> hseg: I made great use of that lazy/strict map thing a few days ago.
10:33:49 <koz_> I'm actually curious about the question hseg raises too.
10:34:04 <koz_> _Can_ fmap potentially stuff a should-be-strict map full of lazy values?
10:34:18 <merijn> Define "should be strict" :p
10:34:31 <koz_> merijn: One made entirely using functions from Data.Map.Strict.
10:34:33 <geekosaur> there's only one Map type, it;s the operations that are strict/lazy
10:34:34 <merijn> See, that's the confusion
10:34:36 <hseg> sniped
10:34:39 <merijn> There is no strict Map
10:34:42 <merijn> There is just Map
10:34:54 <merijn> And you can build Maps strictly or lazily
10:35:19 <koz_> merijn: So suppose I used only strict operations to make a Map. Then I call fmap on it. Will that invalidate my efforts in the use of strict operations?
10:35:27 <koz_> (in the sense that the result won't be strict in its values)
10:35:32 <merijn> koz_: Define "invalidate"
10:35:47 <dsal> One of my day 7 solutions.  Gets a map made from Data.Map.Strict, fmaps it with lazy ! so I can ask for stuff before I finish populating it:  https://www.irccloud.com/pastebin/8KJNYCTs/day7.hs
10:35:49 <hseg> that the map will contain non-whnf values
10:35:54 <koz_> merijn: In the sense that after the fmap, the result won't be strict in its values.
10:36:09 <koz_> Or what hseg said.
10:36:12 <dsal> koz_: I think the above is the exact use case you're describing.
10:36:18 <merijn> Yes
10:36:29 <koz_> Interesting. TIL, thank you!
10:36:37 <dsal> Map == Data.Map.Strict and LMap = Data.Map
10:37:23 <hseg> dsal: sure, but i don't believe that is necessarily impossible with a split Map situation as i'm advocating
10:38:15 <merijn> koz_, hseg: Anyway, that's all trivially solved anyway
10:38:37 <hseg> newtype with specially-defined forcing instances?
10:38:38 <merijn> @hoogle <$!>
10:38:39 <lambdabot> Control.Monad (<$!>) :: Monad m => (a -> b) -> m a -> m b
10:38:39 <lambdabot> Control.Monad.Compat (<$!>) :: Monad m => (a -> b) -> m a -> m b
10:38:39 <lambdabot> Protolude.Monad (<$!>) :: Monad m => (a -> b) -> m a -> m b
10:38:49 <merijn> hseg: Eh, just use <$!> instead of <$> :p
10:39:12 <boxscape> huh it needs a Monad instance instead of functor?
10:39:28 <koz_> merijn: Or I'll just keep doing what I've been, which is using Map-specific functions.
10:39:30 <hseg> sure, but that requires me to remember to take this into consideration, instead of being caught by the compiler
10:39:56 <koz_> But it's definitely good to know.
10:39:57 <merijn> boxscape: No other way to enforce the sequencing of seq
10:40:17 <merijn> boxscape: Although I guess that doesn't work on Map then :p
10:40:24 <boxscape> hm yeah
10:41:24 <hseg> yup...
10:43:05 <dmj`> z0: I used that function today at work, `\f -> scanl' (foldl' f))`
10:43:27 <dmj`> z0: almost fell out of my chair when it just worked
10:44:01 <dmj`> :t scanl' . foldl'
10:44:03 <lambdabot> Foldable t => (b -> a -> b) -> b -> [t a] -> [b]
10:52:09 <z0> is there a better way of writing [ let y = read x in (y,f y) | x <- ... ] ?
10:53:31 <monochrom> [ (y, f y) | x <- ... , let y = read x ]
10:53:41 <z0> i mean assuming i can't do `x <- read <$> xs`
10:53:45 <kuribas> or better don't use read
10:54:05 <z0> monochrom: thanks! i knew this looked strange
10:54:07 <nf> z0: you can do that
10:54:13 <kuribas> :t (***)
10:54:14 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:54:26 <z0> kuribas: why not?
10:54:33 <kuribas> z0: because it's partial
10:54:39 <ephemient> :t (&&&)
10:54:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:54:56 <SrPx> https://github.com/moonad/Formality/blob/master/blog/0-goodbye-javascript.md
10:54:58 <SrPx> ( :
10:55:04 <monochrom> I'm pretty sure it's just anotheer AoC day so input validation goes out of window.
10:55:15 <kuribas> :t (id &&&)
10:55:17 <lambdabot> (b -> c') -> b -> (b, c')
10:55:46 <ephemient> > [id &&& reverse $ show y | y <- [49..51]]
10:55:48 <lambdabot>  [("49","94"),("50","05"),("51","15")]
10:56:07 <z0> of course it's aoc :)
10:56:40 <kuribas> :t \f xs -> ((id &&& f) . read) <$> xs
10:56:42 <lambdabot> (Functor f, Read b) => (b -> c') -> f String -> f (b, c')
11:07:21 <jle`> z0: y <- mapMaybe readMaybe ...
11:07:30 <jle`> z0: or traverse readMaybe
11:14:01 <tomsmeding> SrPx: 🎉
11:33:19 <boxscape> z0 [ (y, f y) | x <- ... , let y = read x ] should also be the same as [ (y, f y) | (read -> y) <- ... ] with ViewPatterns
11:33:37 <boxscape> I believe
11:39:12 <solonarv> yup
11:44:07 <SrPx> tomsmeding: 🎉
11:44:28 <SrPx> also there is a (IMO) really good introduction to theorem proving, made for haskellers, in our repo now:
11:44:45 <SrPx> https://github.com/moonad/Formality/blob/master/THEOREMS.md
11:45:16 <SrPx> please check it and let me know if it is as pedagogical as I expect it to be (:
11:45:54 <tomsmeding> SrPx: after I finish my thesis :p
11:46:09 <SrPx> just for the channel (: 
11:57:00 <koz_> tomsmeding: Are you here to spit a thesis against both of our asses? :P
11:57:08 <koz_> (sorry for obscure reference)
11:57:22 * tomsmeding doesn't get the reference unfortunately
11:57:28 <tomsmeding> but no it's completely unrelated :p
11:59:05 <koz_> It's OK, it's rather obscure.
12:02:20 * tomsmeding found the reference, and indeed had no chance of knowing that one
12:02:35 <koz_> It's OK, I have a fondness for obscurica in my humour.
12:02:45 <tomsmeding> :D
12:02:45 <koz_> As a result, I tend to make jokes about 3 people will get.
12:51:29 <z0> so those 3 people walk into a bar...
12:51:49 <z0> sorry
12:52:02 <koz_> z0: I dunno whether to shoot myself or go bowling at that joke. :P
12:53:09 <z0> my jokes are exclusively for the common folk
13:10:45 <ezzieyguywuf> yikes, ghc-lib-parser-ex cabal file has my eyes spinning
13:10:50 <ezzieyguywuf> all the conditional flags etc.
13:15:40 <sirslapuson> exit
13:38:46 <ezzieyguywuf> what does this mean in a cabal file?  if !flag(ghc-lib) && impl(ghc >= 8.10.0) && impl(ghc < 8.11.0). Specifically, if I specify `--flags=-ghc-lib` and my ghc is v8.8.4
13:38:55 <ezzieyguywuf> does that mean the next block does not get read?
13:39:30 <c_wraith> that is what it means
13:42:14 <ezzieyguywuf> ok thank you
13:52:41 <merijn> What's the inverse of commutative? non-commutative?
13:53:14 <koz_> merijn: Yeah, I guess?
14:00:27 <monochrom> Yes non-commutative.
14:01:03 <monochrom> Unless you also want x*y = - (y*x)  which has a name too.
14:06:19 <iqubic> Is there a structure like a group where "x*y = invert (y*x)"?
14:08:04 <solonarv> iqubic: that's a commutative group where every element is self-inverse; those do have a name, but I forget what it is
14:08:24 <solonarv> proof: invert x = invert (1*x) = x*1 = x
14:08:43 <solonarv> (so every element is its own inverse)
14:09:01 <solonarv> and: x*y = invert (y*x) = y*x -- so it's commutative
14:09:07 <iqubic> Right. I see.
14:09:25 <iqubic> It's like an abelian group, except that every element is a self inverse.
14:37:45 <c_wraith> is there a way to pass rts arguments to the program being run by cabal run? 
14:38:44 <solonarv> c_wraith: cabal run my-program -- +RTS --some --rts=args -RTS --more arguments
14:38:46 <dolio> c_wraith: Did you try --?
14:39:02 <c_wraith> yes, it told me there's no program named --
14:39:26 <monochrom> I fear that the -- is to be as in "run -- my-program"
14:39:39 <monochrom> even "run -- my-package:my-program"
14:39:52 <dolio> Was it just `cabal run -- ...`? You might need to explicitly give the executable name.
14:40:06 <dolio> Even though you probably shouldn't need to.
14:40:17 <c_wraith> ugh. there's only one executable. fix your argument parsing, cabal
14:40:26 <monochrom> IKR?
14:56:50 <ezzieyguywuf> do ghc-boot and ghc-boot-th versions have to match? and does ghc-lib-parser-ex depend on a particular version of these?
14:57:22 <ezzieyguywuf> reading through the cabal file of ghc-lib-parser-ex it doesn't specify a particular version, but I know for sure that ghc-boot-8.8 and ghc-boot-th-8.10 will cause ghc-lib-parser-ex to fail
15:03:36 <justsomeguy> Can you do something like “stack exec -- bash” with cabal? That would at least simplify providing arguments to your executable.
15:04:32 * justsomeguy has only learned stack so far, though he intends to learn cabal and nix soon.
15:04:39 <sclv> cabal also has exec
15:04:54 <sclv> but its less important because your ghc isnt hidden
15:11:48 <solonarv> one thing I've used it for is crude timing: cabal exec -- time myprogram <further args>
15:12:19 <solonarv> that way I'm only measuring the time taken by my program and not also cabal run's extra overhead
15:14:59 <solonarv> cabal does not hide your GHC but it does hide your executable(s)
15:58:40 <uraniumz> clear
16:50:53 <isovector1> is there a newtype anywhere that i can derive via to get an applicative num instance?
16:51:28 <isovector1> Data.Monoid.Ap!
16:52:26 <ezzieyguywuf> "Force dependency on ghc-lib-parser even if GHC API in the ghc package is supported" what is the "GHC API", how can I check if my ghc has it?
17:29:47 <hseg> is it possible to use type families to drop a parameter from a function?
17:31:04 <hseg> i.e. have type family V t, type instance V S = (), f :: V t -> t -> ..., want to be able to not pass the trivial V S parameter when monomorphised
17:31:49 <hseg> this *is* possible if f is uncurried: type family FParam t, type instance FParam S = S, type instance FParam t = (V t, t)
17:37:44 <hseg> nm, was a stupid bit of hammer-induced tunnel vision
17:38:10 <koz_> hseg: I dread to imagine how one induces tunnel vision with a _hammer_.
17:38:46 <hseg> :)
17:39:21 <hseg> well, the resulting pinprick vision made everything appear like a nail, so...
17:40:21 <koz_> Ah, so you meant 'hammer-induced' as in 'caused by _having_ a hammer', as opposed to 'caused by _use_ of a hammer'.
17:41:20 <hseg> oops. yes
17:41:31 <hseg> any pithy way of expressing that?
17:41:38 <koz_> It's OK, English isn't case-marked.
17:41:53 <koz_> (for once, I think I see the appeal of languages with like, over four grammatical cases)
17:42:01 <koz_> (since they make this kind of confusion impossible)
17:42:42 <hseg> yeah. though i wonder how you'd mark it? instrumental vs accusative?
17:44:52 <ezzieyguywuf> 😍 wow the same guy that made hlint made ghcid
17:44:59 <ezzieyguywuf> or, at least is listed as the maintainer on hackage
17:45:07 <koz_> hseg: Depends on what cases you have available, but yes?
17:45:23 <koz_> There are some languages which make even finer distinctions, but instrumental case is needed here.
17:45:31 <koz_> ezzieyguywuf: Yes, Neil is a hero.
17:45:47 <ezzieyguywuf> oh yea! and hoogle!
17:46:06 <ezzieyguywuf> is he around here? I want to know why the test directory isn't packaged in the release tarballs
17:46:15 <ezzieyguywuf> I'm packaging hlint for gentoo but can't run tests :(
17:46:44 <koz_> ezzieyguywuf: You should just leave an issue on the Github for hlint.
17:48:33 <ezzieyguywuf> koz_: seems like we have a workaround in our packaging system, i.e. just pull from git
17:48:43 <ezzieyguywuf> I dunno if it's really an issue, probably a personal choice
17:48:51 <ezzieyguywuf> "why would you need the test suite after release?!"
17:48:55 <sm[m]> ezzieyguywuf: and shake!
17:49:00 <koz_> ezzieyguywuf: I'd say if you can't run tests from the tarball, they're not very useful tests.
17:49:05 <sm[m]> and cmdargs!
17:49:08 <koz_> (or very useful tarballs, one or the other)
17:49:12 <koz_> sm[m]: And extra. :P
17:49:19 <ezzieyguywuf> sm[m]: !!!!!
17:49:30 <sm[m]> that guy is pretty great 👍🏻
17:49:30 <ezzieyguywuf> never heard of shake
17:49:32 <ezzieyguywuf> yes cmdargs
17:49:44 <ezzieyguywuf> I'll leave an issue, but I'm sort of nervous...lol
17:49:50 <koz_> ezzieyguywuf: Why?
17:49:55 <koz_> Neil's usually great at responding.
17:50:01 <ezzieyguywuf> hah I shouldn't be, I already posted a silly issue a few days ago
17:50:03 <koz_> (I've left a few issues, and they got resolved pretty fast)
17:50:14 <ezzieyguywuf> which is clearly answered in the readme. https://github.com/ndmitchell/hlint/issues/1184
18:30:43 <p0a> Can I please receive some tips for this code? https://paste.tomsmeding.com/c3Ohgvuf 
18:31:10 <p0a> In particular 'createStuff'. It's awkward to use fmap, guard and >> in this manner
18:44:59 <dsal> p0a: there's a lot you can do here.
18:45:04 <dsal> Let's see if I can make that compile.
18:45:53 <dsal> Eh, maybe not, but a few things:
18:47:26 <dsal> p0a: I'd start by realizing it can be easier to use. https://www.irccloud.com/pastebin/RxuTND9L/f.hs
18:48:18 <dsal> Or something like this (I can't compile this because I'm missing a piece, so just guessing) https://www.irccloud.com/pastebin/KfZMf1Tg/traverse.hs
18:50:49 <dsal> p0a: does this work? https://www.irccloud.com/pastebin/GCB7AnJv/rbind.hs
18:51:52 <dsal> Regarding that fmap guard thing, I think it'd be clearer to express by enclosing the pointer in a Maybe type such that nullPtr is Nothing and then you could just use fmap to create the dealloc wrapper.  It'd be a lot easier to read and understand.
18:53:24 <p0a> all the pieces are here: https://paste.tomsmeding.com/zdPVexbe
18:53:47 <p0a> I am going to take a look 
18:54:23 <dsal> Again, can't compile, but maybe something like this:  https://www.irccloud.com/pastebin/BU5Mp0WE/maybe.hs
18:54:44 <p0a> Why can't you compile?
18:55:00 <dsal> Didn't have all the parts.  Let's try with all the parts!
18:55:08 <p0a> ooh got it, sorry 
18:57:25 <p0a> the f comment is on point, lol I should've noticed that myself
18:57:38 <p0a> I'm now reading the traverse comment, trying to understand traverse
19:00:25 <p0a> ah yeah traverse is quite nice
19:00:43 <dsal> Can't link it...
19:01:26 <p0a> well, if you can't do it, I doubt I can help you :P
19:01:44 <p0a> but I'm willing to try if you care
19:03:02 <p0a> As for your suggestion for createStuff, you're saying I should have a `Stuff' type right?
19:03:25 <dsal> This doesn't link for me, but it compiles.  heh https://www.irccloud.com/pastebin/uckM5m9r/close.hs
19:04:19 <dsal> I just simplified the things I found confusing without changing any of the types.
19:04:48 <p0a> very nice, did wonders in main
19:05:01 <p0a> createStuff seems to be in need of some abstraction
19:05:20 <dsal> The idea of createStuff here is that it calls the underlying c junk and then wraps that in a `Maybe (Ptr CChar)` such that `nullPtr` becomes `Nothing`.  Then it just uses `traverse` to create the newForeignPtr.
19:06:40 <p0a> makes sense
19:06:41 <p0a> nice
19:06:46 <p0a> I'll give it a go
19:07:16 <p0a> I also like the trickery with `n'
19:07:22 <dsal> Argh, I don't know how to use these fancy type tools in the bots, but `traverse` here is basically `Monad m => (a -> m ()) -> Maybe a -> m ()`
19:07:40 <p0a> Yeah I figured traverse out
19:07:48 <p0a> I'm thinking of it as an fmap that switches the two functors
19:07:52 <p0a> in the end
19:08:03 <dsal> Oh yeah, that's a nice way to think about it.
19:08:37 <dsal> I didn't do trickery, just tend to fmap lower-level IO like that if I'm going to do a conversion anyway, and you don't need to specify the type if it can be inferred.
19:08:44 <dsal> (er, didn't mean to do trickery, that is)
19:09:26 <p0a> no it's nice
19:12:07 <dsal> @hoogle ForeignPtr a -> Maybe (ForeignPtr a)
19:12:09 <lambdabot> Bound closed :: Traversable f => f a -> Maybe (f b)
19:12:09 <lambdabot> Bound.Term closed :: Traversable f => f a -> Maybe (f b)
19:12:09 <lambdabot> Data.Typeable gcast :: forall a b c . (Typeable a, Typeable b) => c a -> Maybe (c b)
19:12:48 <dsal> Eh, I don't think those results do what they should be doing.  I'm surprised that function didn't exist there, but it's easy to write and handy.
19:14:01 <p0a> I'm not sure how ForeignPtr works, but can it be nullPtr?
19:14:10 <dsal> heh, apparently.
19:14:14 <p0a> @hoogle Ptr a -> Maybe (ForeignPtr a)
19:14:15 <lambdabot> UnliftIO.Foreign newForeignPtr_ :: MonadIO m => Ptr a -> m (ForeignPtr a)
19:14:23 <p0a> Do you think that's better? I don't know
19:14:27 <dsal> I can't link that code, but it compiles, so its' clearly correct.
19:14:43 <dsal> That's just UnliftIO -- it's got a version of all the things.
19:15:05 <dsal> In particular, Maybe is not MonadIO
19:15:16 <p0a> hmm I see
19:16:28 <p0a> what would the type for Maybe (ForeignPtr a) be? Stuff a?
19:16:47 <p0a> where Stuff a = Nothing | Just (ForeignPtr a)?
19:17:09 <p0a> and then I have to make instances of Stuff a for monad?
19:18:15 <dminuoso> 04:07:26            p0a | I'm thinking of it as an fmap that switches the two functors
19:18:24 <dminuoso> That's an incorrect way to think about it for several reasons.
19:18:44 <p0a> why dminuoso ?
19:19:30 <dminuoso> % :t traverse
19:19:30 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:19:45 <guest1216> hello, how I can use Text.Parsec.Combinator functions to split input stream? like get "abc" from "server=abc"?
19:19:52 <dminuoso> Note that `t` is a Traversable, which is not Functor.
19:20:12 <dminuoso> Traversable is a subclsas of Foldable.
19:20:35 <p0a> dminuoso: that's fair
19:20:49 <p0a> dminuoso: but juggling the code in my head, I think that IO goes inside, outside, beep bop
19:21:24 <p0a> just a superficial way of understanding it
19:21:27 <guest1216> and also why those type constructor and functions defined in diffrent modules like many1 in Text.Parsec.Combinator, but Parser is in Text.Parsec.String, string in Text.Parsec.Char?
19:21:42 <guest1216> why not just define them all in one module?
19:21:57 <dminuoso> p0a: One possible way to think of Traversable is being able to do the following: Turn the structure into a list, map each element to an action, run each effect, and then fill the list back into the structure.
19:24:27 <p0a> ah I see
19:25:43 <dminuoso> Now, because you're running the effects, you have this visual "swapping around" because after the structure is re-filled from the (possibly modified) list, it happens under the effect.
19:26:27 <p0a> the effect being the applicative
19:26:32 <dminuoso> Right.
19:26:50 <p0a> so in general you can't have a function f (m a) -> m (f a) ?
19:26:55 <p0a> of that type, that is
19:27:04 <dminuoso> Given what constraints, exactly?
19:27:06 <dminuoso> :)
19:27:11 <p0a> let's say, both applicative?
19:27:15 <p0a> f and m
19:27:31 <iqubic> No, in general, you can't do that.
19:27:36 <iqubic> Closest you can do this:
19:27:37 <p0a> Why not?
19:27:46 <iqubic> :t seqenceA
19:27:47 <p0a> sorry, go ahead
19:27:48 <lambdabot> error:
19:27:48 <lambdabot>     • Variable not in scope: seqenceA
19:27:48 <lambdabot>     • Perhaps you meant one of these:
19:27:57 <iqubic> :t sequenceA
19:27:58 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
19:28:07 <dminuoso> Note, that this is just `traverse id`
19:28:35 <p0a> so what prevents you from switching two applicatives?
19:29:25 <dminuoso> p0a: It doesnt work in the general case
19:29:29 <p0a> isn't it just a matter of 'doit F (M x) = pure (pure x)' ?
19:29:51 <dminuoso> p0a: Being able to pattern match is not part of the description of Applicative
19:30:00 <dminuoso> That is, there's no general way to "unwrap it". Its just not part of its interface
19:30:13 <iqubic> Imagine one of the applicatives was "IO a" How do you get the value from inside of that?
19:30:14 <p0a> there's no IO constructor?
19:30:33 <dminuoso> p0a: Treat IO as opaque.
19:30:47 <dminuoso> p0a: For what its worth, there *is* a subset of things you are looking for in monad.
19:30:55 <dminuoso> some choices of monad let you do this
19:30:56 <iqubic> Now, imagine one of the Applicatives was ((->) a). You can't pattern match on that.
19:31:29 <p0a> dminuoso: right, like Maybe. But you can't do it with IO, right?
19:31:47 <iqubic> Nope.
19:31:54 <p0a> Hm, I just realized that! wow 
19:32:07 <p0a> but that makes a lot of sense. It's a nice "closed" system, or opaque, as you put it
19:32:08 <dminuoso> p0a: There's some subtle implications, by the way.
19:32:17 <dminuoso> p0a: Because it doesnt exist in the general case, monads dont freely compose!
19:32:43 <p0a> what do you mean by that?
19:33:11 <iqubic> Nothing in the Applicative typeclass forces you to create a way to retrieve the value.
19:34:00 <p0a> what does that have to do with free compose?
19:34:04 <dminuoso> p0a: If you compose two monads, you dont get a monad back
19:34:10 <dminuoso> Or rather, not always.
19:34:27 <p0a> what!
19:34:29 <dminuoso> And it's because we lack a general `swap :: n (m t) -> m (n t)`
19:34:43 <dminuoso> It's the entire reason we have monad transformers in the first place.
19:34:56 <winny> Hello.  Is there a standard function that combines foldl with map?
19:35:19 <dminuoso> Or rather the type should be `swap :: (Monad m, Monad n) => n (m t) -> m (n t)`. It doesnt exist
19:35:57 <dminuoso> Interestingly, Applicative however are closed under composition
19:36:20 <p0a> You're making me venture into faraway places dminuoso 
19:36:43 <p0a> and I have the good sense of being leery of such things
19:36:54 <dminuoso> Anyway
19:37:21 <dminuoso> p0a: My point is: traverse/sequence is _not_ about "swapping functor layers" 
19:37:37 <p0a> that's a good point, I'm glad you clarified, thank you 
19:38:17 <dminuoso> It's rather about "collapse structure into list, map each element to an effect, sequence these effects, and under the new effect fill the (modified) list back into the structure"
19:38:54 <p0a> I don't mind lying to myself 
19:38:55 <dminuoso> In fact, if we had some concept of Unfoldable, then anything that is both Foldable and Unfoldable should automatically be traversable I think
19:38:59 <p0a> when it comes to remembering things
19:39:32 <p0a> I'd rather think of it still as 'switching' the two "functors" (for lack of a better word; "kinds" maybe?)
19:39:48 <p0a> and remembering that it is not a full & accurate description
19:40:33 <dminuoso> p0a: that's the `sequence` viewpoint. but if you look at `traverse`...
19:40:35 <dminuoso> % :t traverse
19:40:36 <yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:40:47 <p0a> yeah right
19:40:48 <monochrom> Unfoldable is an interesting thought.  (Down that road is fog, haha.)
19:40:56 <dminuoso> "Give me a function that maps an element to an effect, give me a structure, and Ill give you a new structure back under the effect"
19:41:20 <p0a> right, that sounds good dminuoso
19:41:38 <p0a> winny: can you give an example?
19:42:26 <dminuoso> monochrom: When you say fog.. do you mean the person or the foggy fog? :>
19:42:36 <dminuoso> Because I cant say
19:45:11 <winny> p0a; something like this, i'm contemplating how to solve a programming challenge:   foldWithIntermediate (+) [1] [2..]  -> [1,3,6,10,15,..]
19:45:47 <winny> i'm thinking i could use an infinite list and take the nth value I want form the sequence
19:45:50 <p0a> what are the values 1,3,6,10,15?
19:46:00 <p0a> are they 1, 1+2, 1+2+3, etc?
19:46:09 <winny> ah I see your question now
19:47:29 <dsal> :t foldMap -- winny 
19:47:30 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:47:58 <winny> in this case yes, though in my use it won't be with a associative function
19:50:06 <iqubic> winny: I think you want a scanl'
19:51:37 <winny> i did a quick try with foldMap, I don't think I'm understanding how to use it:
19:51:51 <winny> % take 10 $ foldMap (+) [1..]
19:51:51 <yahb> winny: ; <interactive>:11:11: error:; * Couldn't match expected type `[a]' with actual type `a0 -> a0'; * Probable cause: `foldMap' is applied to too few arguments; In the second argument of `($)', namely `foldMap (+) [1 .. ]'; In the expression: take 10 $ foldMap (+) [1 .. ]; In an equation for `it': it = take 10 $ foldMap (+) [1 .. ]; * Relevant bindings include it :: [a] (bound 
19:51:57 <sshine> I'm using 'actions/setup-haskell@v1.1.4' on GitHub and I experience a warning that says 'cabal 3.2.0.0 was not found in the cache. It will be downloaded.' -- right now I'm only caching '~/.cabal/store' and 'dist-newstyle' using 'actions/cache@v2', has anyone experienced that they need to add some path to preserve the cabal 3.2.0.0 binary across builds?
19:52:22 <dsal> winny: foldMap is fold and map.  You need a monoid.  The thing you're doing is a bit different.
19:52:34 <winny> ah, thanks
19:52:43 <sshine> :t foldMap
19:52:44 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:53:04 <iqubic> dsal: They wanta scanl'
19:53:07 <dsal> scanl is "fold with intermediate"
19:53:18 <ski> p0a : <https://en.wikipedia.org/wiki/Triangular_number>
19:53:29 <winny> oh yes, scanl is exactly what I want, I believe
19:53:32 <sshine> > foldMap Sum [1..10]
19:53:34 <winny> scanl', rather
19:53:35 <lambdabot>  Sum {getSum = 55}
19:53:48 <iqubic> > take 10 $ scanl1 [1..]
19:53:50 <lambdabot>  error:
19:53:50 <lambdabot>      • Couldn't match expected type ‘[a]’
19:53:50 <lambdabot>                    with actual type ‘[a0] -> [a0]’
19:54:04 <iqubic> > take 10 $ scanl1 (+) [1..]
19:54:06 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
19:54:20 <dsal> The two list thing threw me off.
19:54:33 <iqubic> That's [1,1+2,1+2+3,1+2+3+4,...]
19:54:49 <winny> that's so cool, missed this in plain sight! (the fibonacci wiki page suggested it, but didn't put 2+2 together)
19:55:04 <ski> > scanl1 (+) [0 ..] :: [Expr]
19:55:09 <lambdabot>  [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 +...
19:55:24 <iqubic> Yeah, that's what it's doing.
19:55:34 <sshine> ski, that's a cool feature. what is Expr made of?
19:55:47 <winny> you can literally typecast to [Expr] to get a sort of weird ast, that's also very amazing
19:56:06 <ski> @hackage simple-reflect
19:56:07 <lambdabot> https://hackage.haskell.org/package/simple-reflect
19:56:11 <sshine> reminds me of C#'s Expr<> :)
19:56:28 <winny> beautiful, thanks for the hackage link
19:57:14 <ski> > foldr f z [a,b,c,d]
19:57:16 <lambdabot>  f a (f b (f c (f d z)))
19:57:19 <ski> > foldl f z [a,b,c,d]
19:57:21 <lambdabot>  f (f (f (f z a) b) c) d
19:57:25 <sshine> :o
19:57:36 <ski> @type a
19:57:38 <lambdabot> Expr
19:57:51 <ski> @type f :: Expr -> Expr -> Expr
19:57:53 <lambdabot> Expr -> Expr -> Expr
19:57:54 <ski> @type f :: Expr -> Expr
19:57:55 <lambdabot> Expr -> Expr
19:57:56 <sshine> Wolfram Alpha can retire now.
19:57:56 <ski> @type f
19:57:58 <lambdabot> FromExpr a => a
19:58:39 <p0a> Expr reminds me of an exercise I did once 
19:58:46 <ski> it only applies to numeric expressions
19:59:03 <p0a> you basically reimplement them and change how they are printed right?
19:59:56 <ski> yes, it's just `instance Num Expr where ...' and so on
20:00:07 <ski> @where stepeval
20:00:07 <lambdabot> <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
20:00:45 <ski> e.g. <http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=take+3+%28map+%28%5E2%29+%5B0%2C1%2C2%2C3%2C4%5D%29>
20:03:34 <ski> oh. also see <https://web.archive.org/web/20201021071139/https://twanvl.nl/blog/haskell/simple-reflection-of-expressions> for `Expr'
20:04:00 <p0a> how does ForeignPtr set up a finalizer?
20:04:19 <p0a> How do "finalizers" work in Haskell? is it somehow in the type/interface or is it provided by GHC?
20:07:53 <justsomeguy> Does using the “type” keyword incur a runtime cost?
20:08:52 <ski> p0a : <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.14.1.0/Foreign-ForeignPtr.html> ?
20:08:55 <ski> justsomeguy : no
20:09:00 <justsomeguy> (I'm confused as to why books keep on mentioning that “newtype” doesn't incur a runtime cost. Why would it? There wasn't any mention of cost when discussing type classes.)
20:09:25 <ski> `type' synonyms are just abbreviations for more complicated type expressions
20:09:50 <dminuoso> justsomeguy: data does incur a runtime cost, even if you write `data Foo = Foo Int`
20:09:59 <ski> the point with `newtype' is that `data New = Mk Old' does incur a run-time cost, while `newtype New = Mk Old' doesn't
20:10:35 <p0a> ski: should I read the source code of it?
20:10:48 <dminuoso> In case of `newtype F = F T`, the runtime representation of `F` is the runtime representation of `T`.
20:11:31 <justsomeguy> Then, why didn't the language designers optimize “data” for that case, instead of inventing a new keyword?
20:11:31 <p0a> how can I make `newtype F = F T' have an instance for all the things T has?
20:11:45 <dminuoso> justsomeguy: Because `data` allows its content to be lazy, for example.
20:11:55 <dminuoso> And data allows to have multiple fields.
20:12:17 <dminuoso> p0a: GeneralizedNewtypeDeriving
20:12:28 <ski> the difference between `newtype New = Mk Old' and `type New = Old' is that in the latter case, `New' and `Old' are synonyms, are the same type (also `New' can't be recursive, `Old' can't refer to / be defined in terms of `New'), while in the former case (just like with `data') `New' is a distinct type from `Old', and you have to explicitly use `Mk' (wrapping with a call to it, or unwrapping with 
20:12:33 <dminuoso> You still have to list out the instances, but it will automatically derive their implementation via coerce
20:12:34 <ski> pattern-matching), to convert between `New' and `Old'. (also, with `newtype', `New' can be recursive)
20:13:20 <ski> p0a : i dunno what you're wanting to understand better about it. just how to use it ?
20:13:34 <p0a> ski: I'm curious about setting up my own finalizers
20:13:41 <p0a> ski: is it something the language supports or is it a GHC feature 
20:14:17 <justsomeguy> dminuoso: Oh, true, “data” is more general. “type” communicates some intent that you want the constructor to be unary.
20:14:23 <justsomeguy> (I guess that's kind of like asking "why have “const” when you can just not mutate variables?".)
20:18:40 <justsomeguy> If I define a type using “data”, but don't use it in my program at the term-level, does it still incur a cost?
20:19:37 <ski> p0a : <https://www.haskell.org/onlinereport/haskell2010/haskellch29.html#x37-28000029>
20:21:04 <justsomeguy> ski: Thanks, that's helpful. I wasn't sure if you could use the aliased type in place of the new name you defined with “type”, but it seems you can. ``newtype`` is different.
20:21:05 <ski> justsomeguy : "Then, why didn't the language designers optimize “data” for that case, instead of inventing a new keyword?" -- replacing `data New = Mk Old' by `newtype New = Mk Old' can change program behaviour, so it can't be a mere optimization
20:21:50 <p0a> ski: thank you
20:22:31 <ski> they could have specified that using `data' with a single data constructor (with a single component / field / argument / parameter) behaved exactly like `newtype' now works .. but then this case would not fit into the same pattern as how all the other cases work
20:25:05 <ski> (the reason for the difference is that `data' constructors can be non-strict. if that wasn't the case, then there wouldn't be a difference in behaviour)
20:25:23 <justsomeguy> Ahh
20:25:53 <ski> @let data MyInt = MkMI Int deriving Show
20:25:55 <lambdabot>  Defined.
20:26:20 <ski> @let newtype MyInt' = MkMI' Int deriving Show
20:26:22 <lambdabot>  Defined.
20:27:01 <ski> > case undefined of MkMI _ -> ()
20:27:04 <lambdabot>  *Exception: Prelude.undefined
20:27:05 <ski> > case undefined of MkMI' _ -> ()
20:27:07 <lambdabot>  ()
20:28:18 <ski> wrapping or unwrapping a `newtype' data constructor is a no-op, does nothing at run-time. but matching on the `data' data constructor forces the value
20:29:46 <ski> @let data MyInt'' = MkMI'' !Int deriving Show  -- this is a `data' type with a strict data constructor (field). forcing a call to it forces the field/component
20:29:48 <lambdabot>  Defined.
20:30:28 <ski> > case undefined of MkMI'' _ -> ()  -- matching on behaves the same, as with the non-strict `data' constructor
20:30:32 <lambdabot>  *Exception: Prelude.undefined
20:31:51 <ski> however, while the data constructor of the first (`data') type is non-strict, the data constructor of the `newtype' is also strict (meaning that if you call it with a bottom value, you'll get a bottom result. so calling it with `undefined', and forcing the result, forces that `undefined' argument)
20:32:51 <ski> > let !_ = MkMI undefined in ()  -- the usual (non-strict) `data' data constructor is .. non-strict. forcing the result doesn't force the argument
20:32:53 <lambdabot>  ()
20:34:09 <ski> > let !_ = MkMI' undefined in ()  -- in the `newtype' case, the data constructor is strict, so forcing the result does force the argument. this is because the representation is the same, there is no actual wrapping. so forcing the result forces the argument, since they're effectively the same thing, at run-time
20:34:12 <lambdabot>  *Exception: Prelude.undefined
20:35:46 <ski> > let !_ = MkMI'' undefined in ()  -- in the strict `data' case, the data constructor is also strict, so forcing the result does also force the argument. the representation is *not* the same, but the data constructor is defined to explicitly force its argument (to be "non-lazy"), unlike the usual (non-strict / "lazy") `data' case
20:35:48 <lambdabot>  *Exception: Prelude.undefined
20:39:07 <justsomeguy> That was very helpful; Thank you ski :^). (Also, it was a good intro to how to use strictness annotations, which I haven't seen before, except as eBNF.)
20:39:10 <ski> attempt at summary : `newtype' data constructor is strict, like in the strict `data' case (with `!' annotation on component type), but unlike the usual (non-strict) `data' case, so forcing result does force the argument. however, *matching* on `newtype' data constructor (unlike strict `data' case) does not force argument, since the representation is the same, so that calling and matching on `newtype' data 
20:39:16 <ski> constructor is a no-op
20:40:29 <ski> (this is somewhat subtle, yes, hence my attempt at highlighting the differences)
20:40:50 <justsomeguy> The subject was way deeper than I expected!
20:42:24 <sshine> justsomeguy, this is implied here.
20:42:45 <justsomeguy> I guess I just described the entirety of Haskell, lol.
20:44:20 <ski> one could have assumed that, a `newtype' data constructor being strict (like in the strict `data' case), means that matching on it, would force the argument. but that is *not* the case ! (due to calling and matching on `newtype' data constructor being no-op). that's the main subtle thing here, that can be easy to trip over / miss, i guess
20:45:10 <dolio> It's not really that matching on it doesn't force the argument. Matching on it doesn't force the value of the newtype.
20:45:35 <dolio> Your examples showed that.
20:46:39 <ski> yes, that amounts to the same thing. of course, matching on `x' or `_' (as in `case undefined of x -> ()') doesn't force anything. but the subtlety here is that, matching on a `newtype' data constructor *also* doesn't force anything (unlike matching on other data constructors)
20:47:49 <ski> > case undefined of x -> ()
20:47:52 <lambdabot>  ()
20:48:06 <dolio> Like, matching on strict data doesn't require forcing the argument, except that it forces the data value as well, which requires forcing the argument.
20:48:26 * ski nods
20:48:48 <z0_> is there a more elegant way we can write `uncurry (++) $ (map f &&& map g) [x,y..]` ?
20:49:43 <z0_> other than `join [ [a,b] | a <- f <$> ls , b <- g <$> ls ]`
20:49:43 <dsal> :t (&&&)
20:49:45 <dminuoso> % :t \f g x y -> uncurry (++) $ (map f &&& map g) [x,y..]
20:49:45 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:49:45 <yahb> dminuoso: Enum a1 => (a1 -> a2) -> (a1 -> a2) -> a1 -> a1 -> [a2]
20:50:35 <ski> z0_ : `[h x | h <- [f,g],x <- xs]' ?
20:51:24 <glguy> let z = [x,y..] in map f z ++ map g z
20:51:25 <dminuoso> [f,g] <*> xs
20:51:47 <ski> that's nice
20:51:51 <sshine> it is
20:51:56 <dolio> Does the order not matter or something?
20:52:15 <glguy> > [('a':),('b':)] <*> ["one","two"]
20:52:17 <lambdabot>  ["aone","atwo","bone","btwo"]
20:52:24 <z0_> nope
20:52:45 <ski> > ["one","two"] <**> [('a':),('b':)]
20:52:46 <glguy> z0_, day 14?
20:52:48 <lambdabot>  ["aone","bone","atwo","btwo"]
20:53:04 <iqubic> :t <**>
20:53:05 <lambdabot> error: parse error on input ‘<**>’
20:53:16 <iqubic> :t (<**>)
20:53:18 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
20:53:24 <ski>   (<**>) = liftA2 (flip ($))
20:54:16 <iqubic> <**> = flip (<*>)
20:54:19 <ski> no
20:54:28 <ski> only if the idiom is commutative
20:54:28 <iqubic> No? It's not the same?
20:54:38 <ski> the ordering of the effects is different
20:54:43 <iqubic> Ah. I see.
20:54:47 <sshine> I would also go with glguy's 'map f xs ++ map g xs' :-D
20:54:56 <ski> (see glguy's and my example above. different results)
20:54:57 <iqubic> Yeah, so would I.
20:55:25 <dolio> I'm saving `[f,g] <*> xs`, though.
20:55:29 <ski> depends on whether `xs' is a larger expression ?
20:55:50 <sshine> dolio, yes, List's Applicative is nice.
20:56:33 <glguy> I like that, but I expect my reader will have to ponder to know what order the results will come in
20:56:49 <dminuoso> glguy: the reader has to ponder either way.
20:57:07 <glguy> Either which way?
20:57:36 <dminuoso> glguy: Regardless of whether you wrote `let z = [x,y..] in map f z ++ map g z` or `[f,g] <*> [x,y..]`
20:57:46 <glguy> No, I don't believe those would result in equal confusion
20:58:04 <sshine> as Kierkegaard said: Use <*>, and you will regret it; don't use <*>, you will also regret it; use <*> or don't use <*>, you will regret it either way.
20:58:05 <glguy> but the <*> one is still handy
20:58:46 <z0_> glguy: day 14 :)
20:58:58 <dminuoso> It would be nice if we had Applicative on Set so you could be explicit that ordering didn't matter.
20:59:27 <MarcelineVQ> now solve cleverly for  (a -> a2) -> (b -> a2) -> a -> b -> [a2]
21:00:16 * ski . o O ( `class Applicative i => CommutativeIdiom i' )
21:00:30 <ski> (`AbelianIdiom' ?)
21:02:45 <sshine> dminuoso, wouldn't that be lawless?
21:08:25 <sshine> dminuoso, as in it'd have to be a Functor then.
21:24:04 <dminuoso> sshine: If we demanded the functions inside Set to be injective, it should satisfy laws, no?
21:25:22 <sshine> dminuoso, how do we demand that?
21:25:40 <dminuoso> If we take any inspiration from lens... via haddock? :)
21:26:22 <dminuoso> At the end, there's no guarantee any instance is lawful anyway.
21:27:05 <dminuoso> It's how we ended with https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-List.html#t:ListT
22:25:38 <guest1216> what is *>  <*   <$
22:26:01 <guest1216> related to >> <|>?
22:26:28 <opqdonut> they're for Applicative, related to <$> and <*>
22:26:39 <opqdonut> which are also known as fmap and ap
22:26:52 <opqdonut> :t (<*>)
22:26:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:26:57 <opqdonut> :t (<*)
22:26:59 <lambdabot> Applicative f => f a -> f b -> f a
22:27:20 <opqdonut> > Just succ <*> Just 1
22:27:22 <lambdabot>  Just 2
22:27:31 <opqdonut> > Just succ <*> Nothing
22:27:34 <lambdabot>  Nothing
22:27:44 <opqdonut> > Just 7 <* Just 3
22:27:46 <lambdabot>  Just 7
22:27:49 <opqdonut> > Just 7 <* Nothing
22:27:52 <lambdabot>  Nothing
22:28:42 <opqdonut> I guess *> is the same as >> when both are defined, hadn't thought of it that way
22:34:35 <guest1216> I saw those in Parsec articles
22:35:12 <guest1216> <$>, <*>, <$, <*, *>, <|>, many, >>
22:55:50 <sshine> guest1216, combinatory parsers are often written using applicative style.
22:58:01 <guest1216> sshine: (*>) :: f a -> f b -> f b, why Nothing *> Just 1 == Nothing?
22:58:08 <guest1216> should it be Just 1?
22:59:31 <guest1216> > Nothing (*>) Just 1
22:59:33 <lambdabot>  error:
22:59:33 <lambdabot>      • Couldn't match expected type ‘(f0 a1 -> f0 b0 -> f0 b0)
22:59:33 <lambdabot>                                      -> (a2 -> Maybe a2) -> t0 -> t’
22:59:40 <sshine> > Nothing *> Just 1
22:59:42 <lambdabot>  Nothing
23:00:01 <guest1216> > Just 1 *> Just 2
23:00:03 <lambdabot>  Just 2
23:01:24 <sshine> guest1216, you can see how the 'instance Applicative Maybe' is defined here: https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#line-992
23:04:08 <sshine> > Nothing <|> Just 1
23:04:11 <lambdabot>  Just 1
23:04:59 <xerox_> > (+) <$> Just (-1) <*> Just 1
23:05:01 <lambdabot>  Just 0
23:05:17 <guest1216> why it doesn't use "and" "or" "nor"?
23:05:33 <guest1216> that should be more plain?
23:05:58 <guest1216> "not"
23:06:51 <sshine> guest1216, one of the uses of Maybe is to end computation once a Nothing occurs. so if you chain computations, you don't compute beyond the first failure.
23:11:05 <guest1216> sshine: what's the defferent? >> and *>
23:11:46 <sshine> guest1216, >> is defined for Monad, *> is defined for Applicative. they probably do the same.
23:12:03 <sshine> :t (>>)
23:12:05 <lambdabot> Monad m => m a -> m b -> m b
23:12:07 <sshine> :t (*>)
23:12:08 <lambdabot> Applicative f => f a -> f b -> f b
23:12:47 <guest1216> monad has the same kind with applicative?
23:12:53 <ChaiTRex> @src (>>)
23:12:53 <lambdabot> m >> k = m >>= \_ -> k
23:12:57 <ChaiTRex> @src (*>)
23:12:58 <lambdabot> (*>) = liftA2 (const id)
23:13:15 <guest1216> *> is look like const
23:13:35 <iqubic> guest1216: It's not const, because it runs both effects.
23:14:22 <xerox_> 'cept you get the applicative effect
23:14:31 <iqubic> const would A) throw away the second effect, and B) not run any effects.
23:15:52 <iqubic> (*>) runs both effects it's given, but only returns the result of the first effect.
23:17:42 <guest1216> iqubic: *> return the second effect?
23:17:47 <iqubic> Yes.
23:17:50 <guest1216> (*>) :: f a -> f b -> f b
23:18:08 <iqubic> That's returning the second effect, but running both of the effects.
23:22:27 <guest1216> <**> == flip <*>?
23:23:23 <sshine> guest1216, you can find out by hoogling: https://hoogle.haskell.org/?hoogle=(%3C**%3E) -- https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-60--42--42--62-
23:26:43 <guest1216> I saw https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#%3C%7C%3E    will <|> run both actions?
23:27:11 <guest1216> or just run the first action and return?
23:27:55 <sshine> > Just 1 <|> error "we can try"
23:27:59 <lambdabot>  Just 1
23:28:01 <iqubic> Ah see, that one's a bit more tricky.
23:28:55 <guest1216> how we describe it? run the first successful computation and return?
23:29:13 <sshine> guest1216, we describe it like this: https://hackage.haskell.org/package/base-4.14.1.0/docs/src/GHC.Base.html#line-1046
23:29:21 <guest1216> > Nothing <|> Just 1
23:29:25 <lambdabot>  Just 1
23:30:00 <iqubic> <|> requires an Alternative instance. Those are Monads that can fail, for some definition of fail. If the first action succeeds, then that action will be returned and the second action will never be run. If the first action fails, then the second action's result will be returned, regardless of if the second action succeeded or faild.
23:30:08 <guest1216> I mean with words...
23:30:21 <iqubic> I did just describe it with words
23:30:47 <guest1216> sorry, I mean sshine 's link...
23:31:05 <sshine> guest1216, "pick the first one. if it fails, pick the second one"
23:31:12 <guest1216> sshine: right
23:31:32 <iqubic> sshine, that's a good way to phrase it.
23:32:42 <iqubic> guest1216: Because Alternative is a typeclass, what it means to fail and to succeed can and will be different for each Applicative.
23:33:17 <iqubic> For example, Maybe fails when a Nothing value is given. Either fails when a Left value is given.
23:33:31 <guest1216> right
23:34:08 <iqubic> IO fails when an exception is thrown.
23:34:44 <iqubic> But in general, <|> is will pick the first one. If that fails, pick the second one instead.
23:34:57 <guest1216> "<sshine> guest1216, combinatory parsers are often written using applicative style."  should Parsec inhence Applicative?
23:35:14 <guest1216> inherit
23:36:54 <iqubic> https://hackage.haskell.org/package/parsec-3.1.14.0/docs/Text-Parsec.html#t:ParsecT
23:37:19 <guest1216> getLine <|> (print "failed to input"), if the input is interupt, will it print this?
23:37:39 <iqubic> If you look at the list of instances you'll see "Applicative (ParsecT s u m)" This shows that a parser is an applicative.
23:37:42 <guest1216> IO action getLine failed by C-c
23:37:55 <iqubic> Yes. That's correct.
23:38:14 <iqubic> If you use C-c, then the getLine will fail, causing the other effect to be used.
23:39:29 <guest1216> but I don't see some functions defined in Application are implemented in Parsec, like many, I saw there's many1
23:41:31 <iqubic> many is defined in Control.Applicative, and will work for all Alternatives. Since a Parsec Parser is an Alternative, it can just use the definition of many as given in Control.Applicative.
23:41:32 <iqubic> https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:many
23:42:13 <guest1216> iqubic: main = getLine <|> (print "interrupt")         Expected type: IO String   Actual type: IO ()
23:42:35 <iqubic> Right. The issue there is with the type of <|>
23:42:43 <iqubic> :t (<|>)
23:42:45 <lambdabot> Alternative f => f a -> f a -> f a
23:43:40 <guest1216> getLine :: IO String, print "..." :: IO ()
23:43:44 <iqubic> Right.
23:43:50 <guest1216> so how we can fix it?
23:43:54 <iqubic> And those two have different types.
23:44:02 <iqubic> I'm not sure how to fix it.
23:44:06 <guest1216> ...
23:45:22 <guest1216> what about main = (getLine >>= print) <|> (print "failed")
23:46:11 <iqubic> That won't work, because you need to give print an argument.
23:46:24 <iqubic> Other than that, it should work.
23:47:05 <guest1216> iqubic: it worked
23:47:11 <iqubic> :t print
23:47:12 <lambdabot> Show a => a -> IO ()
23:48:18 <guest1216> iqubic: I input ok, and it print ok, I use C-c in terminal, it print "failed"
23:48:29 <iqubic> That's what it should do.
23:48:39 <iqubic> Ah. I see. That's right.
23:48:57 <guest1216> (getLine >>= print) :: IO ()
23:49:05 <guest1216> print "failed" :: IO ()
23:49:07 <iqubic> Right, that's correct.
23:49:21 <Kronic> failed successfully
23:49:52 <guest1216> <|> is wonderful, it can handle IO Exception
23:50:14 <guest1216> what about other Exception like read/write file?
23:50:48 <iqubic> <|> will handle any IO exception.
23:50:49 <guest1216> Exception in other language like python and kotlin, they use try/except to handle
23:51:11 <guest1216> but all runtime exceptions are IO exception?
23:51:15 <iqubic> There are functions that work like try/except in Haskell too.
23:51:36 <iqubic> guest1216: Yes. All runtime exceptions are IO exceptions.
23:52:13 <guest1216> iqubic: wait a sec, must <|> be implement for every application or monad?
23:52:22 <iqubic> No. That's not true.
23:52:55 <guest1216> iqubic: that's sad, so we can't use <|> to handle those exceptions if they don't implement it...
23:53:47 <idnar> many Applicatives are Alternative, but not all
23:54:12 <guest1216> what is Alternative? related to Monad?
23:54:25 <guest1216> Arrow?
23:54:58 <iqubic> Alternative is the type class that provides the (<|>) operator.
23:55:08 <guest1216> ok
23:55:09 <idnar> :t getLine <|> (print "interrupt") 
23:55:11 <lambdabot> error:
23:55:11 <lambdabot>     • Couldn't match type ‘()’ with ‘[Char]’
23:55:11 <lambdabot>       Expected type: IO String
23:55:11 <iqubic> :t (<|>)
23:55:13 <lambdabot> Alternative f => f a -> f a -> f a
23:55:24 <iqubic> Note the Alternative constraint.
23:55:25 <idnar> :t void getLine <|> print "interrupt"
23:55:29 <lambdabot> IO ()
23:56:43 <idnar> ^ void discards the result making the types match up; not sure if that's what you wanted
23:58:20 <idnar> :t void -- basically `fmap (const ())`
23:58:21 <lambdabot> Functor f => f a -> f ()
