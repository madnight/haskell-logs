00:05:01 <sshine> wasn't there also one about endofunctors between analogies?
00:06:14 <sshine> https://mathoverflow.net/questions/13832/analogies-between-analogies
00:06:18 <siraben> When reading Criterion reports, which numbers matter?
00:06:27 <sshine> siraben, the low ones!
00:06:28 <siraben> The time or the mean field?
00:06:38 <siraben> mean and std dev right?
00:07:08 <zzz> sshine: found it (kind of)
00:07:58 <zzz> it's a section on various Edward Kmett talks
00:08:14 <sshine> zzz, cool.
00:08:19 <zzz> on monoidal parsing
00:08:34 <sshine> hm.
00:10:50 <sshine> siraben, I shouldn't be answering, because I only benchmarked toy code for getting to know primitives, and not production code. but I just went with 'mean estimate', assuming the stddev was low. I haven't tried to benchmark something with a high stddev unless I was accidentally abusing the CPU for other purposes simultaneously.
00:12:10 <sshine> siraben, so basically just what's decipherable in the graphs: compare means between two solutions, unless the stddev appears to be too high.
00:14:02 <siraben> sshine: I see, thanks!
00:15:35 <sshine> I gave feedback on Exercism and it ocurred to me I didn't really know how performant the different solutions were. I learned that often high-level solutions in Haskell are actually faster. Haskell is still the only language I know where abstractions often have a negative cost footprint. :-D
00:17:21 <siraben> sshine: i've been benchmarking all my advent of code solutions this year: https://github.com/siraben/haoc-2020
00:17:29 <sshine> ha, cool.
00:18:44 <sshine> I don't know if I'd be able to use a Criterion report for anything useful if I didn't either have two functions to compare against each other, or some idea of a performance bottleneck...
00:18:47 <siraben> i have some notes on performance in the readme, it was quite eye opening to learn what is fast and what is not
00:18:59 <sshine> yes!
00:19:03 <siraben> maybe later I'll look into memory usage as well
00:19:13 <sshine> yeah, memory use is probably where I learned the most.
00:19:56 <siraben> But as a rough guide; foldl' is great, Int over Integer, bang patterns and tail recursion, lists are very slow for indexing/as a poor map, specialized structures (IntMap, IntSet) are fast
00:19:57 <sshine> I had a short phase of trying to add !s everywhere. ;-D
00:20:07 <siraben> and also, bit-level hacking words :)
00:20:14 <siraben> to avoid conditionals
00:20:28 <sshine> Data.Bits is pretty nice, yes.
00:20:45 <siraben> oh and String is very slow, haha
00:22:35 <sshine> when I tried to tweak my Exercism solutions I found that I could often avoid explicit bangs in favor of strict library combinators and simply not use lists. ;-)
00:22:58 <sshine> it seems they get GC'ed very late.
00:29:26 <superstar64> how do i decided the type application order for my class methods?
00:30:41 <sshine> superstar64, what does that mean?
00:31:48 <superstar64> for my typeclass's method, i want to pick the order that type variables are specified with `@`
00:32:47 <superstar64> putting an explicit forall doesn't seem to work with methods
00:34:11 <sshine> superstar64, I thought the order was bound to be the order that the type variables appear in the signature.
00:34:25 <superstar64> yea, but i don't want that order
00:34:43 <superstar64> and i can't put an explicit forall
00:36:02 <suzu_> could you paste some code?
00:36:13 <suzu_> not in the channel directly but on pastebin or github/etc and link it
00:38:35 <superstar64> `class CheckType m p Îº l s where { checkType :: p -> Îº -> m (Type l s Îº) }` how do i specify l and s first?
00:41:10 <idnar> superstar64: I don't think you can, but you can do `checkType' :: â€¦; checkType' = checkType`
00:41:18 <superstar64> eww
00:42:27 <zzz> sshine: well I just spent the last hour lost in mathoveflow reading analogies between analogies and famous mathematicians' quotes
00:43:27 <superstar64> well, i guess my code base is going to need more `'` functions i gues
00:46:59 <ADG1089__> :t Window -> String
00:47:01 <lambdabot> error: parse error on input â€˜->â€™
00:47:12 <ADG1089__> @h Window -> String
00:47:12 <lambdabot> Maybe you meant: hackage haskellers help hitchcock hoogle hoogle+ v @ ? .
00:47:41 <koz_> @hoogle Window -> String
00:47:42 <lambdabot> Debian.Pretty ppShow :: Pretty (PP a) => a -> String
00:47:42 <lambdabot> Prelude show :: Show a => a -> String
00:47:42 <lambdabot> Text.Show show :: Show a => a -> String
00:48:58 <ADG1089__> :t \windows -> gets $ fmap getName . winnows
00:49:00 <lambdabot> error:
00:49:00 <lambdabot>     Variable not in scope: getName :: a0 -> b
00:49:00 <lambdabot> error:
01:05:27 <sshine> zzz :o
01:24:46 <aplainzetakind> Is there a sort of "for all n, here's an unsigned n bit type" library?
01:31:48 <superstar64> how do i enable type application in ormolu?
01:32:34 <superstar64> `-o TypeApplications`  doesn't seem to work
01:33:16 <superstar64> wait nvm, i got it, it's `-o -XTypeApplications`
01:41:22 * hackage simple-cmd 0.2.3 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.2.3 (JensPetersen)
02:41:41 <joel135> aplainzetakind: https://hackage.haskell.org/package/accelerate-bignum-0.3.0.0/docs/Data-Array-Accelerate-Data-BigWord.html
03:04:53 <Janni> Hello there! This is a great day. After multiple years of abstinence I'm getting back to using Haskell. As the ecosystem has changed quite a bit, however, I'm having trouble getting off the ground.
03:05:52 <Janni> So, I'll be asking a few stack-related question here, if that's not off-topic.
03:08:07 <Janni> One of my problem's is the co-existence of my system GHC and the stack GHC installation. If I run for instance ghcide, its telling me that "ghcide compiled against GHC 8.10.2 but currently using 8.4.4".
03:08:30 <Janni> I was able to resolve that problem by setting up a script ~/bin/ghc with the content "stack ghc -- $@".
03:08:56 <tomsmeding> joel135: that's kind of specific to Accelerate, though, and not for general usage :p
03:09:20 <tomsmeding> note that it depends on the accelerate package, which is quite large
03:10:05 <tomsmeding> Janni: for the ghcide issue it may help to make an explicit hie.yaml file
03:14:43 <Janni> (If anyone replied I missed it. My computer crashed.)
03:15:25 <tomsmeding> Janni: https://ircbrowse.tomsmeding.com/browse/haskell?id=208660&timestamp=1608462582#t1608462582
03:15:39 <Janni> Isn't there a way to have stack install a version of ghc as part of its "global-project" and have it create a binary/symlink in ~/.local/bin?
03:15:56 <Janni> tomsmeding: Thanks.
03:16:19 <tomsmeding> I believe that's not the way stack is intended to work; it's intended to download a local ghc per project, and the sharing of ghc's over projects that use the same version is just a "caching" thing
03:17:35 <Janni> Right. I got the impression that I could "switch" from cabal to stack, maybe that's my problem.
03:18:33 <tomsmeding> well you can, but stack wants you to make a project for whatever you do
03:18:39 <tomsmeding> (cabal really also wants you though)
03:18:50 <tomsmeding> and once you're in a project, stack manages your stuff for you
03:20:43 <tomsmeding> by the way, in case you happen to be under that impression: stack is not necessarily a "modern replacement" of cabal, it's just an alternative that some people prefer, some people don't
03:20:50 <Janni> OK. Then my current problem is this. When I run "vim src/Main.hs" everything works fine as the haskell-language-server and ghcide etc from the "project's stack" are used.
03:21:18 <Janni> However if I do "cd src; vim Main.hs" everything breaks down.
03:21:47 <tomsmeding> I'd say that is your vim language client plugin not properly recognising the project's root folder
03:21:58 <tomsmeding> what plugin do you use, languageclient-neovim? ALE?
03:22:17 <Janni> vim-lsp
03:22:34 <Janni> I'm open to switching to anything else.
03:22:50 <Janni> Anything that works. ;)
03:23:02 <tomsmeding> I've used the two that I mentioned, both have their own distinct issues :p
03:23:53 <tomsmeding> with ALE the only issue I have is this one https://github.com/haskell/ghcide/issues/949 , which is at least a known and reported issue
03:24:34 <Janni> Alright, I'll try out ALE then. Thanks!
03:25:00 <tomsmeding> I'm currently looking whether this is relevant: https://github.com/prabirshrestha/vim-lsp/issues/941
03:25:58 <tomsmeding> hm, no
03:26:26 <Janni> Cool, so far ALE seems to work out of the box.
03:27:10 <tomsmeding> nice!
03:27:34 <tomsmeding> for the record, for vim-lsp you may want to look at this issue: https://github.com/prabirshrestha/vim-lsp/issues/274
03:27:36 <Janni> Except that :ALEHover (and similar commands) don't seem to do anything...
03:28:53 <tomsmeding> ALEHover seems to work for me
03:29:36 <tomsmeding> oh! ALE doesn't have ghcide or hls by default I believe, but that's easily fixable
03:31:09 <tomsmeding> Janni: https://paste.tomsmeding.com/DIdhcRGB
03:32:37 <tomsmeding> include that in your .vimrc, or wherever you want it that's loaded
03:34:30 <Janni> Thanks! I tried that out but I'm getting "ghcide compiled against GHC 8.10.2 but currently using 8.4.4".
03:34:54 <Janni> Ah wait. I need an hie.yaml
03:35:17 <tomsmeding> sorry for the mess, but yes, I find you usually need a hie.yaml :p
03:36:47 <tomsmeding> vim isn't a great editor to use with LSP servers (though I try) and the architecture of the current LSP server implementations for haskell binds them tightly to the compiler being used to compile your project, which makes setting up somewhat more difficult than for other languages
03:37:43 <Janni> Yeah, next thing on my TODO list: implement a good editor.
03:38:18 <Janni> afk
03:39:06 <__monty__> Is there even a way to avoid that? Except for linking HIE against the most common GHC versions?
03:39:12 <tomsmeding> when I retire I will
03:39:30 <tomsmeding> __monty__: not using the compilation artifacts from the user?
03:39:44 <tomsmeding> then you can use any compiler version you like as long as it accepts your code
03:40:01 <__monty__> But the user expects his tooling to check it for *their* compiler.
03:40:02 <tomsmeding> some other languages don't even integrate with the actual compiler, they have a separate implementation of the language just for the IDE
03:40:21 <tomsmeding> so they do, but if it's close enough it doesn't matter usually
03:40:25 <__monty__> That sounds like a way to introduce really hard to spot errors.
03:40:35 <tomsmeding> java (tm)
03:40:49 <tomsmeding> it does buy ergonomics for the simple cases though
03:40:58 <tomsmeding> and thus an easier start for beginning users
03:41:38 <tomsmeding> also I guess a part of the problem is that for haskell, people are more likely to actually use different compiler versions
03:41:41 <__monty__> Delayed frustration is not a great experience though.
03:41:49 <tomsmeding> I believe few people actually have different versions of rustc on their system
03:42:10 <__monty__> Stable and nightly doesn't seem too out there.
03:42:26 <tomsmeding> fair point
03:43:26 <tomsmeding> I guess the LSP server should come via the same place as the compiler you install
03:43:35 <tomsmeding> for rust that's rustup, which can then match up the versions
03:44:01 <tomsmeding> for haskell we have ghcup, which works too, but then stack comes along, and often people also have a ghc from the system packages floating around
03:44:41 <tomsmeding> ignoring the problems some people have with using cabal, if everyone would use a ghc from ghcup and not from anywhere else, and use cabal instead of stack, would we have problems?
03:44:49 <tomsmeding> (or alternatively, stack with system-ghc: True)
03:45:27 <seiryn> I use ghc from ghcup and cabal from ghcup and i (maybe) have problem
03:45:58 <__monty__> tomsmeding: Clearly the right answer is nix : )
03:46:00 <tomsmeding> though that doesn't serve the people that specifically want ghcide instead of HLS (like me), because ghcup doesn't give you ghcide; but I want that because HLS crashes for me on a particular project, which is a bug and not a permanent problem I hope :p
03:46:17 <tomsmeding> __monty__: I'm scared of nix
03:46:33 <tomsmeding> seiryn: a problem with HLS version mismatches?
03:48:12 <seiryn> tomsmeding: Nah, i installed Cabal and now ghci say parsec is hidden but it's not
03:49:04 <tomsmeding> is it not?
03:49:12 <__monty__> seiryn: Correct constraints on base?
03:49:15 <tomsmeding> for me it is, outside of a project
03:49:33 <__monty__> Oh, thought Parsec was part of base?
03:50:14 <tomsmeding> it's in the 'parsec' library, which is part of the standard set of libraries that come with ghc, but it's not in 'base'
03:52:30 <seiryn> Well, i'm a beginner so maybe i've done an obvious mistake, but basically, the first times i wanted to use parsec i did nothing expect the import, then i wanted to use a package so i installed cabal, and now ghci say parsec is hidden
03:52:47 <seiryn> But ghc-pck say parsec is exposed
03:52:52 <seiryn> ghc-pkg*
03:53:05 <tomsmeding> yes the cabal store overrides some of the visibilities
03:53:21 <tomsmeding> cabal wants you to always work in a project, which means with a something.cabal file
03:53:38 <tomsmeding> in that file you specify the dependencies, among other things; apparently one of the dependencies you want is parsec
03:53:44 <seiryn> Oooh
03:54:01 <seiryn> I didn't know that, thanks
03:54:19 <tomsmeding> if you're used to node, it's like requiring a package.json; for rust, it's like requiring a Cargo.toml
03:54:34 <tomsmeding> the C/C++ world doesn't have anything like that
03:55:27 <tomsmeding> granted it might be annoying if you're starting out (I resisted for a long time), but it's a different problem than the IDE version matchup thing we were talking about :)
03:56:13 <seiryn> I'm used to C sooo
03:56:32 <seiryn> Oh sorry, i interrupted your conversation
03:56:35 <tomsmeding> I came from there too
03:56:55 <tomsmeding> don't worry, there are currently 1029 people in this room, interrupting conversations is the norm and not a problem :p
05:12:22 * hackage keylayouts 0.1.0.0 - Tools for macOS .keylayout files  https://hackage.haskell.org/package/keylayouts-0.1.0.0 (dailectic)
05:14:52 * hackage keylayouts 0.1.0.1 - Tools for macOS .keylayout files  https://hackage.haskell.org/package/keylayouts-0.1.0.1 (dailectic)
06:12:22 * hackage gloss-export 0.1.0.3 - Export Gloss pictures to png, bmp, tga, tiff, gif and juicy-pixels-image  https://hackage.haskell.org/package/gloss-export-0.1.0.3 (timoa)
06:22:06 <siraben> Is Text.ParserCombinators.ReadP actually paralle?
06:22:07 <siraben> parallel*
06:24:58 <hpc> it means "parallel" in a different way than something like par/pseq, if that's what you're asking
06:25:46 <ski> > [(x,y) | x <- "ab" | y <- [0,1]]
06:25:49 <lambdabot>  [('a',0),('b',1)]
06:27:24 <siraben> ski: hm what is that double list comprehension?
06:27:52 <siraben> Ah, ParallelListComp language extension
06:35:15 <siraben> How many language extensions can be implemented in Template Haskell, or is it done by modifying the GHC source?
06:35:48 <joel135> > [(x,y) | x <- "abcde", x /= 'b' | y <- [0,1,2,3,4], y /= 3]
06:35:50 <lambdabot>  [('a',0),('c',1),('d',2),('e',4)]
06:37:33 <hpc> template haskell doesn't implement language extensions
06:37:58 <hpc> it provides a way to execute haskell code that generates haskell code at compile time
06:38:28 <hpc> but within delineated sections
06:39:12 <hpc> in theory you could "extend" the language by wrapping all your code in it, but it wouldn't be {-# LANGUAGE YourExtension #-}, it would be something else
06:45:04 <the-smug-one> I'm reading Oleg's stuff on tagless final. Often the idea of a program or term being "closed" respectively "open" is expressed. Does anyone know what that means? Googling hasn't given me much
06:59:08 <__monty__> the-smug-one: Is it whether it does not, respectively does have free variables?
07:00:00 <__monty__> The other interpretation I could see is like open and closed type families. The former can be added to in other files, like type classes, the latter cannot, like types.
07:00:50 <the-smug-one> __monty__: It's probably regarding free variables. So a closed term has no free variables
07:01:55 <nshepperd2> in the context of tagless final he's probably talking about whether you can add to it later
07:03:40 <the-smug-one> nshepperd2: Probably the free variables interpretation is correct, considering this quote: "After all, the typeexprepresents object terms both well-typed and ill-typed, both open andclosed"
07:05:22 * hackage pandoc-crossref 0.3.9.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.9.0 (lierdakil)
07:06:05 <joel135> yes in that context it seems largely unambiguous
07:10:38 <Janni> Is it still possible to generate HTML docs for all the installed packages. It used to work with "documentation: True" in .cabal/config but it doesnt't seem to anymore.
07:10:40 <Janni> ?
07:21:52 * hackage table-layout 0.9.0.2 - Format tabular data as grid or table.  https://hackage.haskell.org/package/table-layout-0.9.0.2 (muesli4)
07:30:51 * hackage keylayouts 0.1.0.2 - Tools for macOS .keylayout files  https://hackage.haskell.org/package/keylayouts-0.1.0.2 (dailectic)
07:59:12 <tzlil>  what optimizations does GHC do? i wrote a function (http://0x0.st/iCNO.txt
07:59:21 <tzlil> but this seems like it would be slow
07:59:39 <tzlil> or would crash if the array is too long
08:00:06 <tzlil> but i dont think it does
08:00:56 <geekosaur> it does lots of optimizations
08:01:52 <tzlil> like what?
08:03:05 <geekosaur> unboxxing, streaming, worker/wrapper, let floating, strictness analysis, among many others
08:03:19 <geekosaur> in this case I would expect it to compile down to a loop
08:03:40 <geekosaur> *unboxing
08:06:52 <merijn> tzlil: You don't have an array there
08:07:07 <whataday> which function can do 'f Nothing Just 1 = Just 1' ?
08:07:17 <merijn> whataday: You want <|>
08:07:18 <xerox_> > Nothing <|> Just 1
08:07:21 <lambdabot>  Just 1
08:07:23 <merijn> :t (<|>)
08:07:24 <lambdabot> Alternative f => f a -> f a -> f a
08:07:36 <merijn> whataday: or "asum"
08:07:38 <merijn> :t asum
08:07:39 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
08:07:50 <merijn> whataday: Which will give you the "left most non-Nothing"
08:09:06 <whataday> ok
08:13:02 <whataday> parse (spaces <|> (string "abc")) "" " ww1984" couldn't match type [Char] with ()
08:13:10 <whataday> what's wrong?
08:13:23 <ezzieyguywuf> what is "custom-setup" in a cabal file?
08:13:35 <whataday> shouldn't it be Right ()?
08:13:58 <merijn> ezzieyguywuf: Something to be avoided :p
08:14:06 <whataday> spaces would consume the first space in " ww1984"
08:14:25 <ezzieyguywuf> merijn: lol, idris uses it
08:14:35 <ezzieyguywuf> trying to figure out what it is and how to deal with it in gentoo's package
08:14:54 <merijn> ezzieyguywuf: Basically, Cabal has a interface for building/configuring packages, which has 3 variants: "Simple" uses only Cabal code, Configure which is Simple + autoconf, and Custom, which incluces arbitrary custom code
08:15:11 <merijn> ezzieyguywuf: It basically means that Setup.hs has custom code doing...something
08:15:34 <ezzieyguywuf> ah hah
08:15:36 <ezzieyguywuf> yikes
08:15:40 <ezzieyguywuf> ok this helps, tank you merijn !
08:15:43 <merijn> ezzieyguywuf: custom-setup just defines the dependencies/etc. of the custom Setup.hs
08:35:54 <nf> whataday: look at the type of (<|>), then look at the types of space and string "abc"
08:37:04 <nf> er, spaces
09:35:13 <Kronic> So... I wrote a program to do some potentially very big, slow calculations and it has been running for ages now -- is there anyway for me to know if it has just outright locked up, or if it is simply slowly chugging along?
09:36:20 <sm[m]> Kronic: a quick thing, run top or whatever and see if it's using cpu
09:36:38 <sm[m]> what kind of machine are you ?
09:36:43 <sm[m]> are you on
09:41:01 <tomsmeding> whataday: 'spaces' is a parser for (), 'string' is a parser for String = [Char]
09:41:21 <tomsmeding> oh you already got a response, sorry :p
09:42:26 <Kronic> I'm on a bit of a monster, it's at the top of htop alright
09:48:22 <pjb> Kronic: On the other hand, what you would want to know is whether it's lost in an infinite loop, or if it's really progressing on the calculation.  For this, you could write some log at critical points in your computations (eg. if you are processing a big lists, write a log each 1000 or 10000 elements processed).
09:48:35 <sm[m]> right, you could add some progress output, eg with Debug.Trace, and restart
09:48:39 <pjb> It's always good to get news from one's little program, cf. Tron.
09:48:43 <Kronic> It's progressing the calculation I'm pretty sure, it's just a really slow one
09:49:06 <sm[m]> you probably want some kind of estimate of how long it will take
09:49:29 <sm[m]> in case it's longer than the lifetime of the universe :)
09:49:33 <Kronic> it's just an Advent of Code thing, I need to write something that isn't so slow I think
09:50:09 <boxscape> which day?
09:50:27 <Kronic> day 9 part 2 
09:51:28 <pjb> In the worst cases (it takes days or weeks), let your program give you news thru IRC!
09:51:36 <pjb> or by email.
09:52:17 <pjb> In Tron, they didn't have email.  They needed a direct, interactive communication channel between a program and its programmerâ€¦
09:52:38 <pjb> Exercise for the student: rewrite Tron taking into account email.
09:52:40 <Kronic> Lol, well here's the slow part: https://dpaste.org/XBD9#L4
09:52:47 <sm[m]> yeah it's 2020, why can't things be more like Tron
09:54:03 <sm[m]> https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List.html#v:subsequences doesn't say, but I would guess that is O(n^2) ?
09:55:06 <Kronic> I mean, I figured the lazy nature would save me somewhat
09:56:11 <tomsmeding> sm[m]: subsequences produces 2^n results, so O(2^n)
09:56:30 <sm[m]> thanks toms	meding
09:56:55 <tomsmeding> so, 'filter (`isInfixOf` xs) (subsequences xs)' takes the 2^n subsequences and selects the n^2 contiguous ones?
09:57:09 <tomsmeding> so, like, concatMap inits (tails xs) ?
09:57:55 <tomsmeding> more correctly, concatMap (tail . inits) (tails xs)
09:58:03 <tomsmeding> um, [] : concatMap (tail . inits) (tails xs)
09:58:57 <tomsmeding> Kronic: laziness doesn't save you here, 'subsequences' is still going to generate them all, even if the full list is not instantiated in memory at once
09:59:20 <Kronic> Ah I see... is there anyway to make it not do that?
09:59:52 <tomsmeding> ... not generate bloody exponentially many items? :p
10:00:01 <Kronic> Yea I figured, alright thanks anyway
10:00:23 <tomsmeding> e.g. substitute '[] : concatMap (tail . inits) (tails xs)' for your 'filter (`isInfixOf` xs) (subsequences xs)'
10:00:33 <tomsmeding> the ordering might be different though, not sure if that matters for you
10:02:14 <tomsmeding> FWIW, my solution to day 9 part 2 is not even O(n^2), it's O(n log n) ;)
10:02:24 <koz_> tomsmeding: I guess some sorting was involved?
10:02:40 <tomsmeding> nope, unless you count putting stuff in a Map, sortinf
10:02:42 <tomsmeding> *sorting
10:02:42 <Kronic> I find it to be incredibly hard to understand how fast things are in Haskell, so, I'll just see what other way I can come up with
10:02:46 <koz_> That does count.
10:02:53 <koz_> Since a Map is a red-black tree.
10:03:03 <tomsmeding> Kronic: this is complexity analysis, and orthogonal to haskell or c++ or whatever :)
10:03:03 <koz_> Whose bounds actually come from the comparison sort Big-Omega.
10:03:31 <tomsmeding> koz_: okay fair, if you make "sorting" generic like that, then yes most log-containing complexities are because of sorting
10:03:50 <tomsmeding> though still "most", not all; I've seen some wild stuff
10:03:58 <koz_> Yeah, when you see n log (n), it's either an explicit sort or a sorted structure in pretty much all cases.
10:04:14 <koz_> Unless you're like, doing some kind of FFT stuff maybe?
10:04:20 <sm[m]> Kronic: to build intuition, at least stick in a trace "." in loops, it can be very informative
10:04:22 <koz_> (and that's only theoretically n log (n) actually)
10:04:47 * sm[m] wishes for audio tracing
10:05:03 <tomsmeding> koz_: https://link.springer.com/article/10.1007/s00453-005-1199-1
10:05:15 <tomsmeding> (abstract is sufficient for my point)
10:05:58 <koz_> n^3 * sqrt(log(log(n)) / log(n) ... is not n log (n). :P
10:06:30 <Kronic> I mean, I've been a software engineer for about 5 years now, I know what complexity analysis is. My point was that I find it very hard to work out the complexity in Haskell, not that I don't understand the concept at all
10:07:00 <koz_> Kronic: What specifically in Haskell throws you in this regard?
10:07:01 <tomsmeding> koz_: very good point, does n log n log log n for schÃ¶nhage-strassen count?
10:07:09 <tomsmeding> okay that's fft, I give up
10:07:14 <koz_> Lol.
10:07:40 <koz_> I believe theoretically we could do FFT in n log(n), just that we haven't figured out how yet. :P
10:07:46 <Kronic> I think it's a combination of many things
10:08:04 <koz_> But I'm far from an expert on this, since my brain dribbles out of my ears whenever I'm not dealing with discrete anything.
10:09:14 <tomsmeding> Kronic: I think in haskell, to judge the complexity of something, basically it's the same as what the naive imperative translation of the haskell program would be
10:09:23 <tomsmeding> until you start partially evaluating things
10:09:31 <koz_> I think of it in terms of how much data you have to process usually.
10:09:42 <tomsmeding> the space usage might not be the same due to laziness, both ways, but the time _complexity_ won't be very different
10:09:43 <koz_> Bird and Gibbons (I think) new book says to count reduction steps.
10:10:08 <tomsmeding> at least, if you use normal combinators like map, filter, or plain recursion, that works fine for me
10:10:18 <tomsmeding> if you partially evaluate something, then count only the part that you really evaluate
10:10:33 <koz_> (it was Bird and Gibbons!)
10:10:44 <tomsmeding> in your case, here, you evaluate everything, so you have an exponential loop, then a quadratic loop, etc
10:11:08 <tomsmeding> the fact that you don't actually store those 2^n elements all at once due to laziness isn't relevant for the time complexity
10:11:09 <Kronic> I think I don't see how I evaluated everything
10:11:24 <koz_> The exponential in your case comes from the fact that a list of n items have 2^n subsequences.
10:11:34 <tomsmeding> which of those 2^n items do you not evaluate?
10:11:35 <koz_> That's pure combinatorics - you don't even need complexity.
10:12:08 <tomsmeding> koz_: counting reduction steps makes sense, but that's perhaps not a good way to do it intuitively
10:12:20 <koz_> More precisely: how can you guarantee, to total certainty, in all cases, that you don't need to evaluate everything in the worst case.
10:12:25 <tomsmeding> with which I mean: it's correct, sure, but it's hard to do offhand :p
10:12:27 <koz_> tomsmeding: They state it's a crude measure.
10:12:32 <koz_> But agreed.
10:12:44 <koz_> I do recommend the book though, it's excellent.
10:12:57 <koz_> One of the first treatments of algorithms and data structures which isn't uber-imperative.
10:13:03 * tomsmeding seldomly reads non-fiction books
10:15:36 <tomsmeding> oh! koz_: https://www.youtube.com/watch?v=FKGRc867j10
10:15:44 <Kronic> I used find, so I only wanted one match
10:16:00 <tomsmeding> I haven't actually watched that talk yet, but I mean to; I believe they do something vastly different than an fft
10:16:09 <koz_> Kronic: And what if the thing you want is at the very end?
10:16:27 <koz_> Any sort of linear search is worst-case linear, because it might have to check everything (for instance, if it fails).
10:16:38 <koz_> tomsmeding: That's quite intriguing.
10:16:57 <tomsmeding> even if it isn't at the very end, on average it's going to be in the middle, and evaluating half of a list is the same complexity as evaluating the whole list, if all elements are similarly expensive
10:16:58 <koz_> Because multiplication-via-FFT is potentially n log(n) if the FFT-in-n-log-n thing actually holds.
10:17:14 <koz_> tomsmeding: 'On average it's going to be in the middle' is a hell of a claim in general.
10:17:28 <tomsmeding> which is why I think they aren't doing an fft, because if so, the title would have been "FFT in n log n" :p
10:17:43 <tomsmeding> koz_: okay fair, that's a bold claim :p
10:17:44 <koz_> tomsmeding: Indeed - I just think that this is an interesting data point in that regard.
10:17:59 <tomsmeding> in this case my claim holds though :p
10:18:12 <koz_> I'll definitely look at that - thank you!
10:18:39 <Kronic> So, I reversed the list and it died immediately
10:18:53 <Kronic> Good to know it's just a stupid solution and like I said I should write something different
10:18:56 <koz_> Kronic: OOMed?
10:19:18 <Kronic> it just said the word "killed"
10:19:20 <tomsmeding> reversing the list is going to load it into memory as a whole before even starting to consume it, so yes that'll be OOM :p
10:19:27 <koz_> Yeah...
10:19:47 <tomsmeding> I generally notice it when stuff goes OOM because my system grinds to a halt
10:19:51 <Kronic> why does it say killed and not out of memory?
10:20:14 <tomsmeding> because the linux out-of-memory killer (OOM killer) kills a program that uses more memory than the OOM killer thinks it should
10:20:27 <koz_> And your OOM killer appears quite aggressive.
10:20:29 <tomsmeding> and what the shell prints (and you see) is how the program exited, which is via a kill
10:20:55 <tomsmeding> I agree that the user experience of linux (perhaps bsd or mac in your case?) could be better here, but oh well :p
10:21:06 <Kronic> linux
10:21:22 <Kronic> I was just asking, in Java usually it'll figure this out early and tell you it's an oom
10:21:32 <koz_> Because Java runs in a VM.
10:21:42 <koz_> It reserves a bunch of memory, and if you burn through it, it'll blow up.
10:21:49 <koz_> Haskell compiles to native code.
10:21:52 <koz_> There ain't no VM there.
10:22:04 <sm[m]> there's a RTS though...
10:22:08 <tomsmeding> in particular, the java VM will decide it's out of memory based on its -Xmx setting; here linux is the one that decides the game is over
10:22:16 <koz_> What tomsmeding said.
10:22:18 <sm[m]> can't you tell it to limit the total memory in use ?
10:22:38 <koz_> sm[m]: You can tell the process, sure.
10:22:47 <koz_> (the one that spins up when you run your executable)
10:22:51 <koz_> But it doesn't happen by default.
10:22:58 <sm[m]> I meant the GHC RTS.. but if not, then yes, ulimit would do
10:23:13 <koz_> I dunno if the RTS can be told to limit memory use actually.
10:23:28 <koz_> Would be curious to find out.
10:23:32 <tomsmeding> I have no idea, but apparently +RTS -M4G or something
10:23:39 <Kronic> I just used Java as an example, I'm sure I've seen other languages that directly tell me what the problem is in some way. Idk, I just find a lot of this stuff a little alien, sorry for all of the questions
10:24:08 <koz_> Kronic: Have you worked in unmanaged languages before? So like, C, C++, etc?
10:24:16 <tomsmeding> or rust
10:24:19 <koz_> tomsmeding: Nice to know.
10:24:28 <sm[m]> somehow I do find it much more common to allocate way too much space in haskell than in other languages. Maybe because I mix and match data structures and operations on them at a greater rate ?
10:24:30 <Kronic> C++ a little here and there when I needed to 
10:24:34 * tomsmeding just looked at +RTS --help from a random haskell executable
10:25:01 <koz_> Kronic: Basically, this is the kind of behaviour you'd see from C++ if you tried to make an exponentially-sized thing.
10:25:09 <koz_> And it noms all your memory.
10:25:47 <koz_> sm[m]: You could probably make it tighter if you really wanted to.
10:25:55 <Kronic> I'm pretty sure you can still catch an exception for it in C++ or something to that order
10:26:00 <sm[m]> +1 for +RTS -M, that's the way to get a better error Kronic
10:26:07 <tomsmeding> Kronic: in practice, on linux, no
10:26:14 <tomsmeding> because linux over-allocates
10:26:25 <koz_> Yep, that's right.
10:26:38 <tomsmeding> on windows you might be able to actually get std::bad_alloc, but I believe on newer windows versions it over-allocates similarly to linux
10:26:51 <koz_> When you work in unmanaged languages, you have to accept that situations like this one are _very_ platform-dependent.
10:27:21 <Kronic> That's fair enough, I'm still annoyed about it though
10:27:24 <Yuu-chan> Is there a lens to `ix` multiple keys in a map?
10:27:29 <koz_> Kronic: Not a lot you can do about it.
10:27:35 <tomsmeding> ha, overcommittment is the term I was looking for, not over-allocation
10:27:39 <koz_> ('you' here meaning 'anyone really')
10:27:48 <koz_> tomsmeding: The Linux kernel is Rick Astley.
10:27:58 <koz_> ("A full commitment's what I'm thinking of...")
10:28:13 <koz_> Although the fact it'll never let you down is debatable. :P
10:28:22 * hackage algebraic-graphs-io 0.1.1.0 - I/O utilities for algebraic-graphs  https://hackage.haskell.org/package/algebraic-graphs-io-0.1.1.0 (ocramz)
10:28:45 <tomsmeding> someone saying "I'll never let you down" is going to ring the doubt bells anyway
10:28:57 <koz_> tomsmeding: Lol.
10:29:09 <sm[m]> it's like "Don't be evil"
10:29:19 <koz_> And we know that by overcommitment, the Linux kernel already tells lies.
10:29:23 <koz_> (and possibly hurts you)
10:30:02 <koz_> (ok, I'll stop dragging this tired joke)
10:30:05 <tomsmeding> koz_: you should do better, more than 3 people are going to get these jokes
10:30:23 <koz_> tomsmeding: I'm sorry, I'll fulfil my quota of obscurica some other way today.
10:32:51 * hackage ghc-lib-parser 8.10.3.20201220 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.10.3.20201220 (shayne_fletcher)
10:33:51 * hackage algebraic-graphs-io 0.1.2.0 - I/O utilities for algebraic-graphs  https://hackage.haskell.org/package/algebraic-graphs-io-0.1.2.0 (ocramz)
10:33:52 * hackage ghc-lib 8.10.3.20201220 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.10.3.20201220 (shayne_fletcher)
10:35:28 <koz_> Yuu-chan: Lens as in from 'lens'? Or 'optics'?
10:37:10 <dolio> Whatever it would be, it wouldn't be a named concept, I think.
10:37:35 <koz_> Yeah, wouldn't you just have like, a list of indexes and fmap?
10:40:02 <boxscape> why can the result type of a function not be unlifted?
10:40:17 <dolio> It can.
10:40:28 <boxscape> oh I must be misremembering
10:41:13 <boxscape> hmm
10:41:30 <boxscape> but the kind of (->) is TYPE q -> TYPE r -> *
10:41:57 <boxscape> oh wait
10:42:08 <koz_> % :kind (->)
10:42:09 <yahb> koz_: * -> * -> *
10:42:11 <boxscape> I just forgot how kind signatures work, carry on
10:42:15 <koz_> Wait what.
10:42:31 <boxscape> % :set -fprint-explicit-runtime-reps
10:42:31 <yahb> boxscape: 
10:42:37 <boxscape> % :k (->)
10:42:38 <yahb> boxscape: TYPE q -> TYPE r -> *
10:43:01 <koz_> OK yeah, that's better.
10:43:20 <koz_> Technically, isn't * shorthand for TYPE SomethingOrOther?
10:43:34 <boxscape> TYPE LiftedRep
10:43:46 <koz_> Yeah that one.
10:44:09 <koz_> So properly it's actually 'TYPE q -> TYPE r -> TYPE LiftedRep'.
10:44:18 <koz_> Again, all we ever do is lift in Haskell.
10:44:25 <koz_> Now even our function arrows lift!
10:47:16 <Yuu-chan> koz_: Lens from `lens`. I managed to get multiple values with `foldMap ix`, but setting doesn't work properly.
10:52:22 * hackage ghc-lib-parser-ex 8.10.0.17 - Algorithms on GHC parse trees  https://hackage.haskell.org/package/ghc-lib-parser-ex-8.10.0.17 (shayne_fletcher)
10:52:43 <shapr> Anyone using haskell-language-server in NixOS and can tell me the magic incantation?
10:56:17 <koz_> Also, tomsmeding - the algorithm you linked seems to rely on FFTs, just in a different form.
10:56:35 <koz_> (well, DFTs I should say, but ehh)
10:57:03 <tomsmeding> ah! interesting they managed to work away that log log n factor then
10:57:26 <tomsmeding> perhaps I'll watch it over christmas
10:57:52 <koz_> Well, the work-away was done in 2006 by some German dude.
10:57:52 * hackage algebraic-graphs-io 0.1.3.0 - I/O utilities for algebraic-graphs  https://hackage.haskell.org/package/algebraic-graphs-io-0.1.3.0 (ocramz)
10:58:03 <koz_> Who bashed it down to k ^ (log*(n))
10:58:28 <koz_> Then this guy and some collaborators pinned the k to 8, then brought it down to 4, and then killed it completely.
10:59:24 <shapr> what algorithm?
10:59:40 <koz_> shapr: Shonhage-Strassen.
10:59:52 <koz_> Oh, you mean, the one where the k is dead?
10:59:57 <shapr> sure
10:59:58 <koz_> tomsmeding had a link earlier.
11:00:22 <tomsmeding> I see, cool!
11:00:34 <shapr> wikipedia says Fuerer's algorithm is the successor
11:00:36 <koz_> https://www.youtube.com/watch?v=FKGRc867j10
11:01:05 <koz_> Fuerer was the guy who got n log(n) k^(log*(n)) without giving a value for k, other that the fact it was a constant.
11:01:29 <koz_> The guy in the vid I linked, and some collaborators, published a bunch of stuff in the late 2010s pinning k to 8, then slowly bringing it down to 4.
11:01:49 <koz_> The talk I linked is about their (at the time not peer reviewed) paper showing that you could eliminate that part completely to get O(n log(n)).
11:01:57 <koz_> (lower bound wasn't discussed AFAICT)
11:03:12 <Kronic> I ended up writing just the standard 2 pointer solution https://dpaste.org/bWAL 
11:03:27 <Kronic> It could probably be better, but it worked, thanks for the help earlier all
11:03:33 <koz_> I was kinda amused to see iterated log again - that function played a key role in my Master's thesis!
11:04:14 <[exa]> koz_: wow, what precise topic?
11:04:20 <koz_> [exa]: Dynamic partial sorting.
11:04:32 <koz_> To _completely_ close the loop tomsmeding inadvertently started me on. :P
11:05:25 <[exa]> o wow
11:06:59 <tomsmeding> I started you on what?
11:07:36 <koz_> tomsmeding: The n log(n) thing?
11:07:43 <tomsmeding> oh right that, yes
11:08:13 <tomsmeding> I was somehow reading your message as saying that I inadvertently influenced your thesis topic, which sounded outrageously unlikely
11:09:33 <monochrom> This whole channel influenced my thesis topic alright.
11:09:48 <[exa]> #metoo
11:10:08 <koz_> monochrom: Is your topic 'Pedagogy, humour, functional programming: #haskell as a cultural expression of learning Haskell."?
11:10:18 <tomsmeding> koz_++
11:10:18 <monochrom> Everyone here said "very hard to figure out time complexity under lazy evaluation" so I decided my thesis would be how easy it is.
11:10:28 <__monty__> Hmm, are library modules always looked for in the hs-source-dirs of an executable? Does that mean I have to include the source directory of the library in every executable stanza? How does that work with unrelated projects that need to depend on a library in a local project?
11:10:28 <[exa]> koz_: oh please can I read that essay?
11:10:39 <koz_> [exa]: Ask monochrom for that, not me.
11:10:48 <koz_> If it were _me_, it'd be more like
11:10:56 <[exa]> can it please have nice pictures? :D
11:11:04 <tomsmeding> Kronic: some unsolicited feedback on that version: the 'p2 + 1 /= length xs' can be changed to 'p1 + p2 < length xs' I think
11:11:14 <koz_> 'Pedagogy, humour, functional programming: Cultural learnings of #haskell to make benefit glorious nation of pedagogues."
11:11:30 <koz_> (I am not sorry at all)
11:11:58 <koz_> (and the acknowledgements section would end with 'And finally, thank you Sasha Baron Cohen: you know why.'.
11:12:07 <tomsmeding> Kronic: also, your code is n^3 if I'm not mistaken; if you felt like it there is a little more to gain :)
11:12:42 <koz_> (that joke could have been taken a bit further - only a first draft)
11:12:51 <tomsmeding> (why n^3? well, n^2 times you're inspecting a sublist, and you're inspecting that sublist in O(n))
11:15:26 <Kronic> It finished in a a second or two so I'm not worried about that, but thank you for the earlier comment
11:22:29 <monochrom> __monty__: hs-source-dirs is for those listed in main-is, other-modules, exposed-modules. It is not for those listed in build-depends.
11:24:14 <merijn> __monty__: Your question is flawed
11:24:39 <geekosaur> the question sounded like it assumed an old cabal
11:24:45 <merijn> __monty__: Library modules aren't looked up by source location at all
11:25:20 <merijn> geekosaur: tbh, I'm betting on the classic mistake of "having library and exe modules in the same directory"
11:26:41 <geekosaur> but then why ask about finding those modules via hs-source-dirs? sounds like wanting to make that mistake instead of using cabal properly, possibly with multiple libraries
11:30:37 <monochrom> It would take forever to articulate and discuss the flaw. Also, although I would love to have everyone does everyone properly, most people never had a chance to learn the proper way, ever.
11:31:18 <__monty__> I was misled by this example: https://cabal.readthedocs.io/en/3.4/cabal-package.html#example-a-package-containing-a-library-and-executable-programs
11:31:23 <monochrom> After thinking it through, I decided it's most efficient to just state one simple and accurate rule for what hs-source-dirs is for.
11:31:36 <__monty__> It gets the library modules via other-modules, rathen than build-depends.
11:32:38 <monochrom> Taking advantage of the fact that even people who haven't learned the proper way, they already have correct intuition for what belongs to build-depends, what belongs to other-modules, etc. (Or at least, that one is very easy to pick up.)
11:34:16 <monochrom> Yeah that example needs fixing.
11:34:45 <monochrom> Err no nevermind, it is just another design decision.
11:34:47 <__monty__> I think that example would cause the same error, right? Because it'd look for A and B, respectively A and C in prog1, respectively prog2?
11:34:52 <merijn> __monty__: That example isn't using the library as library and, tbh, it's a weird ass example
11:35:07 <monochrom> No, it's one of two legit ways.
11:35:13 * __monty__ jots down a note to fix the example
11:35:25 <merijn> __monty__: There are 3 modules named A in that example
11:35:30 <geekosaur> that was what I meant by old cabal, tbh
11:35:32 <merijn> __monty__: 3 different ones, that is
11:35:42 <geekosaur> I didn't know they still had an example dating from the bad old days
11:37:01 <merijn> __monty__: If your executables intends to use a library in the same package as library, it shouldn't list modules from that library at all in the executable section
11:37:24 <monochrom> Hrm, on third though, merijn is right.  ./A.hs has nothing to do with prog1/A.hs, one would think.
11:38:01 <__monty__> merijn: Yep, I figured that out. A bell rang in my head saying "Why shouldn't this be in build-depends ðŸ’­"
11:38:02 <merijn> It may have meant something different in the past, but as it is, there is 0 module reuse in that example wrt current Cabal
11:38:40 <__monty__> Yep, still think those names either need changing or comments to make all of this clearer.
11:39:26 <monochrom> This example does a legit thing but is doing it confusingly.
11:39:43 <merijn> monochrom: Arguably also something dumb
11:40:51 * hackage lumberjack 1.0.0.0 - Trek through your code forest and make logs  https://hackage.haskell.org/package/lumberjack-1.0.0.0 (KevinQuick)
11:41:22 <__monty__> Yes, but imo examples shouldn't be brainteasers : )
11:41:31 <monochrom> IKR
11:41:42 <__monty__> Hmm, reexporting qualified isn't a thing, is it?
11:41:55 <geekosaur> no, it's not
11:43:09 <merijn> Sadly
11:45:22 * hackage fei-base 1.0.0 - FFI to MXNet  https://hackage.haskell.org/package/fei-base-1.0.0 (JiasenWu)
11:49:55 <__monty__> There goes my brilliant idea of grouping all these pesky imports in a helper module.
12:12:44 <shapr> When my attoparsec parsers are failing, I wish I could magically produce legal values that the parser would accept
12:25:52 * hackage fei-nn 1.0.0 - Train a neural network with MXNet in Haskell.  https://hackage.haskell.org/package/fei-nn-1.0.0 (JiasenWu)
12:26:38 <ezzieyguywuf> is there a tool that automatically creates dependency lower/upper bounds for your project based on what's currently available?
12:26:55 <ezzieyguywuf> I've seen enough 'pretty' .cabal files to think some folks are using this to creating a starting point...
12:27:29 <merijn> ezzieyguywuf: "cabal init" inserts them by default and then there's cabal-fmt
12:27:48 <merijn> ezzieyguywuf: Also, what do you mean by "currently available"?
12:27:59 <kupi> in quickcheck "not (null xs) ==> not (null ys) ==> ..." is the same as "not (null xs) && not (null ys)"?
12:28:02 <dolio> What is it expected to do? Just assume that your stuff will work with any possible version that exists?
12:28:37 <merijn> ezzieyguywuf: The only *sensible* way to do things is to start all your dependencies with ^>= current latest version
12:28:42 <ezzieyguywuf> merijn: hrm, i.e. if I have `somePackage >= 0.1 && < 0.2' that I created last year, and since then `somePackage` has updated to v1.5, it would just bump tho upper-bound
12:28:44 <merijn> So if the latest version of foo is 1.2.1
12:29:00 <merijn> You start with "foo ^>= 1.2.1" (i.e. everything PVP compatible with 1.2.1
12:29:01 <ezzieyguywuf> in the background (b/c I don't pay attention to cabal output), I've been using newer versions as they release without knowing it, without issue
12:29:09 <merijn> And then you relax as new versions of foo are released
12:29:29 <merijn> ezzieyguywuf: Are your packages on Hackage or just local?
12:29:34 <dolio> I think the real answer is that updating these bounds is an insignificant amount of work for most people, despite all the complaining that gets done.
12:29:36 <ezzieyguywuf> merijn: just local for now.
12:30:02 <merijn> ezzieyguywuf: Then I'd just use ^>= with whatever version you are using *now* and then only update/relax them when needed, tbh
12:30:14 <ezzieyguywuf> dolio: I agree, insignificant amount of work, but keeping up with it seems error-prone
12:30:23 <ezzieyguywuf> merijn: thanks for your thoughts!
12:30:27 <ezzieyguywuf> I think I want to check out cabal-fmt too
12:30:34 <ezzieyguywuf> is that bundled with cabal or separate?
12:30:55 <merijn> For hackage released packages packdeps provides an RSS feed when your dependencies release a newer version
12:30:57 <ski> kupi : should be, if you mean ` ==> ...' at the end of the latter
12:31:00 <merijn> ezzieyguywuf: It's a separate tool
12:31:09 <ezzieyguywuf> gotcha, I'll check it out thank you
12:31:22 <kupi> ski: thanks, I meant that 
12:31:49 <ski> kupi : may be better to generate non-empty lists, rather than filter, though
12:32:31 <kupi> ski: what guide do you recommend? i got that code from "real world haskell"
12:35:52 * hackage fei-cocoapi 1.0.0 - Cocodataset with cocoapi  https://hackage.haskell.org/package/fei-cocoapi-1.0.0 (JiasenWu)
12:37:03 <ski> @check \(NonEmpty xs) -> length xs > 0
12:37:06 <lambdabot>  +++ OK, passed 100 tests.
12:37:44 <ski> kupi : instead of `propFoo xs ys = not (null xs) && not (null ys) ==> ..xs..ys..', try `propFoo (NonEmpty xs) (NonEmpty ys) = ..xs..ys..'
12:44:22 * hackage fei-datasets 1.0.0 - Some datasets  https://hackage.haskell.org/package/fei-datasets-1.0.0 (JiasenWu)
12:51:51 * hackage fei-modelzoo 1.0.0 - A collection of standard models  https://hackage.haskell.org/package/fei-modelzoo-1.0.0 (JiasenWu)
13:14:22 * hackage fei-examples 1.0.0 - fei examples  https://hackage.haskell.org/package/fei-examples-1.0.0 (JiasenWu)
13:22:52 * hackage intricacy 0.8.0.1 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.8.0.1 (mbays)
13:23:19 <hpc> ^ is a pretty cool package
13:26:44 <Uniaika> kewl
13:27:22 <lyxia> sounds amazing
14:46:05 <__monty__> Did I imagine you can "stack" guard syntax? `| condition1 | sndCondition1 = foo\n<indentation>| sndCondition2 = bar\n| condition2 = baz`?
14:46:34 <dminuoso> __monty__: use commas
14:47:23 <__monty__> dminuoso: But then I have to repeat condition1.
14:48:13 <lyxia> right you can't do that
14:49:36 <__monty__> Not even with an extension? Can someone please turn my dreams into an extension? Thank you kindly.
14:52:18 <dminuoso> __monty__: The closest trick you can do is use a helper let binding.
14:52:20 <dminuoso> f | c1 = let g | s1 = ...; | s2 = ...; in g
14:52:26 <dminuoso> Or equivalently with case-of
14:52:49 <dminuoso> e.g. f | x1 = case () of _ | s1 = ...; | s2 = ...;
14:53:35 <dminuoso> Or, with MultiWayIf I suppose
14:53:45 <__monty__> Ok, thanks.
15:48:09 <cnmne[m]> __monty__: there is something like that in agda https://agda.readthedocs.io/en/latest/language/with-abstraction.html#simultaneous-abstraction
15:49:50 <__monty__> It's possible that's where I was exposed to it.
16:57:52 * hackage ki 0.2.0 - A lightweight, structured-concurrency library  https://hackage.haskell.org/package/ki-0.2.0 (mitchellwrosen)
17:27:52 * hackage ki 0.2.0.1 - A lightweight, structured-concurrency library  https://hackage.haskell.org/package/ki-0.2.0.1 (mitchellwrosen)
17:43:56 <Feuermagier> what'S the correct operator to divide doubles with?
17:44:02 <Feuermagier> div?
17:45:22 <MarcelineVQ> /
17:46:03 <Feuermagier> oh, didn't even notice that that was an operator. thx!
17:46:34 <Feuermagier> in most languages / is for whole number division
17:47:38 <MarcelineVQ> :>
17:48:23 <Feuermagier> I'm doing high order functions atm and have not come across it once :D
17:49:13 <hololeap> doesn't / work on doubles in C?
17:49:55 <siraben> Feuermagier: I've used / for floats and doubles in C just fine before
17:50:30 <Feuermagier> well, in most languages it is also overloaded ^^
17:50:55 <Feuermagier> i was just confused because i had used div all the time
17:51:04 <Feuermagier> and suddenly I got a type error
17:54:23 <iqubic> :t div
17:54:24 <lambdabot> Integral a => a -> a -> a
17:54:33 <hololeap> Feuermagier: note that `quot` also works on integrals and is the preferred choice if you know you're going to work with positive numbers
17:54:47 <iqubic> Integral types are whole numbers, I guess.
17:55:03 <Feuermagier> :t quot
17:55:04 <lambdabot> Integral a => a -> a -> a
17:55:25 <Feuermagier> is it identical to div?
17:56:13 <hololeap> IIRC, quot doesn't "know" negative numbers and generally uses less CPU ticks to compute
17:59:08 <hololeap> > (-10) `div` 3
17:59:10 <lambdabot>  -4
17:59:14 <hololeap> > (-10) `quot` 3
17:59:16 <lambdabot>  -3
18:00:57 <hololeap> Feuermagier: https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div
18:02:38 <Feuermagier> ah, so a good old magic number multiply on division by constant?
18:02:45 <hololeap> also note that `divMod x y === (div x y, mod x y)` and `quotRem x y === (quot x y, rem x y)`
18:09:09 <Feuermagier> how do I check high order functions for equality with quickcheck?
18:11:29 <Feuermagier> well, i guess i can just let quickCheck supply the arguments and resolve the functions...
18:22:47 <iqubic> Yeah. two functions f and g are equal if, and only if, for all values x, f x equals g x.
18:30:58 <guest1221> parse (string "abc" <|> spaces) "" "abc" won't work, because string "abc" and spaces don't have the same type?
18:31:36 <guest1221> <|> asks same type, is there a function doesn't ask same type and do same work like <|>?
18:44:10 <guest1221> Left "a" <|> Right "a" won't work, because Left "a" :: Either String _, Right "a" :: Either _ String?
18:46:58 <iqubic> Actually, Left "a" <|> Right "a" will work, and the result will have type "Either String String"
18:49:09 <siraben> indeed
18:50:37 <guest1221> no
18:50:37 <siraben> guest1221: sure Left "a" has type Either String a for any a, and likewise for Right "a", but the type of (<|>) is Alternative f => f a -> f a -> f a
18:50:52 <siraben> Oops the alternative is failing, iqubic 
18:50:59 <siraben> no instance for Alternative (Either String)
18:51:04 <guest1221> (Left "b" :: Either String String) <|> (Right "a" :: Either String      String)  No instance for (Alternative (Either String)) arising from a use        of â€˜<|>â€™
18:51:11 <iqubic> Right. I see.
18:51:19 <siraben> I was thinking of Maybe, heh
18:51:33 <iqubic> Why is there no Alternative instance for (Either a)? Like, why is that not a thing?
18:51:53 <pavonia> (Left <$> string "abc") <|> (Right <$> spaces)
18:52:05 <siraben> Weird, Either a is a monad just like Maybe
18:52:05 <koz_> iqubic: What would 'empty' be?
18:52:11 <iqubic> That doesn't work, for the reasons outlined.
18:52:14 <siraben> In fact Maybe a ~ Either () a
18:52:18 <iqubic> koz_: IDK.
18:52:26 <koz_> That's why. :P
18:52:55 <siraben> koz_: ah, right
18:53:07 <MarcelineVQ> alternatively   void (string "abc") <|> spaces   so the question could be, what does it mean for <|> to do 'the same work' for these two parsers?
18:53:08 <koz_> It _can_ be an instance of Alt, in several different ways.
18:53:14 <Turmiht> I'm not very sure should ask build question here, sorry if it's not appropriate. I get unsupported file format found when link a static library from cabal-doctest-1.0.8 from MacOS 11.0.1, which by wiki is a linux deb file. anybody has ideas about it?
18:53:22 <koz_> (the semigroupoids Alt)
18:54:18 <guest1221> machinedgod: parse string "abc" on input will get Right "abc" or Left, parse spaces would get Right ()
18:54:26 <koz_> Alternatively (heh) you could define (Monoid a) => Alternative (Either a)
18:54:30 <guest1221> Right () <|> Right "abc" is ok?
18:54:45 <Turmiht> The error occurred in building of package distributive, I'll post more info if necessary
18:55:39 <guest1221> machinedgod: sorry, 
18:55:48 <guest1221> MarcelineVQ: 
18:56:15 <pavonia> guest1221: Is that for a Parsec parser?
18:56:21 <guest1221> pavonia: yes
18:56:49 <pavonia> Then you cannot use Either diractly, you have to use something like (Left <$> string "abc") <|> (Right <$> spaces)
18:57:36 <Vulfe> yeah you just want to lift the Either constructors to Parser
18:57:39 <guest1221> Prelude RIO>  (Left "b" :: Either String String) <|> (Right "a" :: Either String String) ==  Right "a"
18:58:21 <guest1221> https://hackage.haskell.org/package/rio
19:00:07 <guest1221> pavonia: you mean parse (Left <$> string "abc" <|> (Right <$> spaces) "" "abc"?
19:00:40 <guest1221> I thought parse (string "abc") "" "abc" will get Right a
19:00:53 <guest1221> and parse spaces "" "abc" will get Left a
19:00:56 <pavonia> Ther are ( ) missing, but yes
19:01:09 <guest1221> parse spaces "" " abc" will get Right ()
19:02:11 <pavonia> What I pasted should give Right (Left "abc") and Right (Right ()). respectively
19:04:04 <guest1221> pavonia: why it can't be Right <$> string "abc"?
19:05:56 <pavonia> It can, but then spaces has to be Left
19:06:40 <guest1221> pavonia: why?
19:06:58 <pavonia> (<|>) expects two parsers of the same type, but string "abc" and spaces apparently doesn't have the same type
19:07:17 <pavonia> so you have to wrape some datatype around to make them equal
19:08:01 <pavonia> With Left/Right then both have type Parser (Either String ()) or whatever parser type it is exactly
19:08:07 <guest1221> pavonia: right, string "ab" would be Either _ String, spaces would be Either _ ()
19:08:26 <pavonia> No
19:08:58 <pavonia> In Either a b, Left has type a, Right has type b
19:09:34 <guest1221> (parse (string "ab") "" "ab") :: Either ParseError String
19:09:54 <guest1221> (parse space "" " s") :: Either ParseError Char
19:10:13 <Vulfe> right, which you want to change to Either ParseError (Either String ())
19:10:15 <guest1221> (parse spaces "" " s") :: Either ParseError ()
19:10:43 <pavonia> Note that parse adds an extra layer of Either
19:11:02 <Vulfe> so you want to construct two parsers of type Parser (Either String ()) or whatever the library uses
19:11:24 <Vulfe> so the return type of parse will be Either ParseError (Either String ())
19:12:01 <Vulfe> Left for instance has type a -> Either a b, so fmapping it on Parser gives you something of type Parser a -> Parser (Either a b)
19:12:08 <guest1221> you lift the result on Either ParseError?
19:12:23 <Vulfe> so if you do this on both sides with the two constructors like pavonia was describing you get two parsers of the same type
19:12:59 <Vulfe> you're not doing anything with the result per se, you're just using functoriality of Parser
19:13:54 <guest1221> the actual question https://paste.ubuntu.com/p/cYMKqdVQtT/
19:14:45 <guest1221> parser a can parse on input1, parser b can parse input2, then parse (a <|> b) "" input1 would work, but parse (a <|>b) "" input2 won't
19:15:04 <guest1221> it's because parser a and b don't have the same type?
19:15:31 <pavonia> There both alternatives do have the same type Parser (Stirng, String)
19:15:55 <pavonia> Do you actually get a compiler error?
19:16:42 <guest1221> pavonia: Left (line 1, column 3):unexpected "l" expecting space or "print"
19:18:33 <pavonia> Both parsers start parsing spaces, so alway parsePrint is chosen which then fails at "let"
19:18:40 <guest1221> pavonia: when a.bc is 10 print "ok", it would be Right ("print","ok")
19:19:45 <guest1221> work on "10 let a = 1" it will be Left (line 1, column 4):unexpected "l"expecting space or "print"
19:19:49 <pavonia> You need backtracking here (or to rewrite your parsers completely). Have a look at the "try" function of Parsec
19:20:06 <pavonia> Also read http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
19:37:11 <guest1221> pavonia: very very weird, I just add `try` on that parserLet and parserPrint, it both works now, no other code changed
19:37:19 <guest1221> I don't understand
19:38:21 <guest1221> https://paste.ubuntu.com/p/cYMKqdVQtT/
19:38:32 <guest1221> https://paste.ubuntu.com/p/cYMKqdVQtT/
19:39:24 <guest1221> those parser are same, only the after ones have `try` before `do`, and the second parse successfully, what's the magic???
19:40:32 <glguy> You shouldn't start your parsers with 'spaces', you should be ending your parsers with that
19:41:32 <glguy> and then parsePrint and parseLet overlap at the start with their lineNum stuff
19:41:32 <dmj`> peak haskell is scanl' on the job
19:44:21 <glguy> guest1221, ideally you'd factor factor that common prefix out of the two parsers
19:45:26 <pavonia> guest1221: This is how Parsec works. Once a path looks correct (the first part matches), Parsec will never give up on this path. So either the rest also parses successfully or it will fail. With "try" you can tell it to give up this path, even if some character already have been parsed successfully, and try another alternative if there is one
19:46:36 <pavonia> guest1221: e.g. parse (string "ab" <|> string "ac") "" "ac" will fail, because the "a" of "ab" already matches but then "b" fails
19:47:17 <pavonia> parse (try (string "ab") <|> string "ac") "" "ac" will work, though
19:49:05 <guest1221> pavonia: wow, but should people expect that parse (string "ab" <|> string "ac") "" "ac" == Right "ac"?
19:49:49 <glguy> no, not in parsec
19:49:54 <glguy> yes in megaparsec
19:50:29 <guest1221> pavonia: when it fails, I expect it would be Left a, then parse the right one, get Right a, then Left a <|> Right a, get Right a
19:50:33 <glguy> yes in attoparsec (for a different reason)
19:50:56 <glguy> guest1221, you can't use parsec based on assumptions, it intends for you to refactor your grammar in a particular way
19:50:57 <guest1221> glguy: I should try megaparsec I think
19:51:14 <glguy> megaparsec will still require you to understand it, it just happens that string *in particular* matches all or nothing
19:51:47 <guest1221> glguy: attoparsec come with ghc?
19:52:03 <glguy> attoparsec doesn't have the optimization that consuming input aborts alternatives
19:52:20 <glguy> only parsec does
19:52:50 <glguy> there are plenty of good reasons to switch from parsec to megaparsec, but you'll need to learn it just the same
19:55:52 * hackage rattletrap 9.3.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.3.1 (fozworth)
19:55:58 <guest1221> ok
19:59:45 <iqubic> If you approach learning how to use a libriary with the mindset of "It makes the most sense for it to work in this way, so I'll just assume it works in this fashion." You're only setting yourself up for failure when you find out that it doesn't actually work in the way you find most sensible.
20:00:05 <ezzieyguywuf> can I make cabal show me all the versions of my libraries that it is currently using to build my project?
20:01:04 <glguy> ezzieyguywuf, do you have a ./dist-newstyle/cache/plan.json ?
20:01:47 <ezzieyguywuf> glguy: hey!
20:02:17 <glguy> I don't know if there's a better way, but what I do is 'cabal install cabal-plan' and then run 'cabal topo'
20:02:18 <ezzieyguywuf> yes I do have that file
20:02:20 <ezzieyguywuf> I'll take a look
20:02:26 <glguy> which turns that file into something sensible
20:02:33 <glguy> err
20:02:37 <glguy> 'cabal-plan topo'
20:02:51 <ezzieyguywuf> glguy: question for you - how come you remove the `data` dir from your release tarballs, or other things needed to execute the test suite?
20:03:15 <glguy> which one?
20:03:29 <glguy> I probably don't do that on purpose
20:04:12 <ezzieyguywuf> glguy: hrm I saw a few, I filed a github issue on one but held off on doing the others until I heard your reasoning
20:04:17 <ezzieyguywuf> let me find the issue I posted just a sec.
20:04:34 <glguy> I probably just forgot to include something in the .cabal file
20:04:43 <glguy> I don't modify the release tarballs in any way after 'cabal sdist'
20:05:20 <ezzieyguywuf> ah hah.
20:06:02 <ezzieyguywuf> glguy: oh *embarassed* it may not have been you lol sorry
20:06:13 <ezzieyguywuf> but you gave me a hint I can probably file a PR now with whoever it was
20:09:27 <ezzieyguywuf> yup, it was def ndmitchel, the hoogle guy, https://github.com/ndmitchell/hlint/issues/1185
20:10:03 <ezzieyguywuf> sorry glguy, I just consider hoogle so dang handy and great that I assumed it was you, especially b/c hlint comes from the same guy ^_^
20:10:54 <MarcelineVQ> That happened one time when I saw sliced bread, I was like "Is this glguy?"
20:10:56 <ezzieyguywuf> but you're right, he's just missing the stuff in his cabal config, I'll file a PR with him tomorrow - https://github.com/ndmitchell/hlint/blob/master/hlint.cabal#L17-L26
20:11:04 <ezzieyguywuf> MarcelineVQ: lol, glad it's not just me.
20:20:59 <glguy> MarcelineVQ: it's true; I am bread
20:25:54 <nshepperd2> string doesn't match all or nothing in parsec? how unfortunate
20:29:26 <glguy> nshepperd2, I think since it's often not enough to try just the string part that it's not that bad that parsec is like that
20:29:43 <glguy> it's too easy for string "abc" to match the prefix of "abcd"
20:29:51 <glguy> and have that not be what you wanted
20:30:02 <glguy> the try would usually go further outside than a single string
20:31:27 <glguy> I think parsec is just convenient enough that it gives the illusion that it's simple to use :)
20:33:13 <nshepperd2> i suppose so
20:34:07 <nshepperd2> try (string "keyword" *> wordBoundary) <?> "keyword" 
20:35:50 <glguy> for keywords I think it's more likely that you'd do something like: identifier <- parseId; and then test which one you got
20:36:54 <glguy> using parsec for anything serious is work
20:46:51 * hackage ratelimiter 0.1.0 - In-memory rate limiter  https://hackage.haskell.org/package/ratelimiter-0.1.0 (AlexanderThiemann)
21:02:00 <shah> hey so
21:02:17 <shah> can someone explain what irs is what free node is what irc client is and how this stuff works
21:02:23 <shah> it all looks like alien technology
21:02:29 <shah> i have no idea wtf any thing means
21:06:22 * hackage HSmarty 0.4.0 - Small template engine  https://hackage.haskell.org/package/HSmarty-0.4.0 (AlexanderThiemann)
22:57:51 * hackage numhask 0.7.1.0 - A numeric class hierarchy.  https://hackage.haskell.org/package/numhask-0.7.1.0 (tonyday567)
23:07:51 * hackage numhask-space 0.7.1.0 - Numerical spaces.  https://hackage.haskell.org/package/numhask-space-0.7.1.0 (tonyday567)
23:28:51 <shad0w_> hi all.
23:29:01 <shad0w_> i manually installed ghc on windows
23:29:14 <shad0w_> then cabal
23:29:21 <shad0w_> by downloading executables from the site
23:29:38 <shad0w_> and added them to path variables and set CABAL_DIR
23:29:59 <shad0w_> now i can install cabal stuff in a custom location but. it says symlink not supported on windows
23:30:32 <shad0w_> manually searching and symlinking files from store will sure get tiresome : /
23:30:43 <shad0w_> where do i go from there?
23:30:47 <shad0w_> here*
23:47:38 <shad0w_> anyone ?
23:49:33 <ski> probably many people are sleeping
23:50:40 <shad0w_> timezones lol
23:51:03 <shad0w_> anyway to work around symlinks not working on cabal windows ?
23:51:14 <shad0w_> symlinks do work on windows tho : /
