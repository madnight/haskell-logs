00:00:33 * hackage replace-megaparsec 1.4.4.0 - Find, replace, and split string patterns with Megaparsec parsers (instead of regex)  https://hackage.haskell.org/package/replace-megaparsec-1.4.4.0 (JamesBrock)
00:02:40 <carbolymer> hc, which any?
00:07:23 <dminuoso> carbolymer: https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Applicative-Permutations.html
00:07:32 <dminuoso> https://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Permutation.html
00:07:47 <dminuoso> Either will work. Chances are you will have one of them in your dependencies when writing non-trivial parsers anyway
00:08:40 <carbolymer> dminuoso, thx
00:09:03 <idnar> @hoogle (a -> b) -> (a -> c) -> (a -> d) -> a -> (b, c, d)
00:09:04 <lambdabot> No results found
00:12:31 <dminuoso> idnar: (&&&) or Strong profunctors give yo uthat
00:13:33 <idnar> (&&&) only does (,), but tell me more about the profunctors
00:14:21 <dminuoso> idnar: well, ((a,b),c) ~~~ (a,(b,c))
00:14:33 <dminuoso> so if you (&&&) twice that's just it
00:14:48 <idnar> I guess
00:14:49 <int-e> :t liftA3 (,,)
00:14:51 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
00:15:19 <int-e> liftA3 (,,) succ show (:[]) 1
00:15:22 <int-e> > liftA3 (,,) succ show (:[]) 1
00:15:26 <lambdabot>  (2,"1",[1])
00:15:42 <dminuoso> cunning
00:15:52 <int-e> literate
00:16:15 <int-e> (accomplished Reader)
00:16:18 <idnar> hmm, I tried (,,) <$> f <*> g <*> h
00:16:49 <dminuoso> % ((,,) <$> map toUpper <*> map toLower <*> tail) "fooBar"
00:16:50 <yahb> dminuoso: ("FOOBAR","foobar","ooBar")
00:16:51 <int-e> idnar: that's the same as  liftA3 (,,) f g h
00:16:59 <idnar> oh damnit
00:17:25 <idnar> (-1) is not a section :D
00:17:34 <int-e> > (-1+) 2
00:17:36 <lambdabot>  1
00:17:38 <int-e> > subtract 1 2
00:17:41 <lambdabot>  1
00:18:00 <dminuoso> Negating numbers is just odd in Haskell. :(
00:18:01 <int-e> the former is nasty.
00:18:16 <dminuoso> % :t (+1-)
00:18:17 <yahb> dminuoso: ; <interactive>:1:5: error: parse error on input `)'
00:18:20 <dminuoso> % :t (-1+)
00:18:20 <yahb> dminuoso: Num a => a -> a
00:18:26 <dminuoso> What lovely symmetry.
00:18:38 <int-e> :t (+ -1) -- wait till you see this
00:18:39 <lambdabot> error:
00:18:39 <lambdabot>     The operator ‚Äò+‚Äô [infixl 6] of a section
00:18:40 <lambdabot>         must have lower precedence than that of the operand,
00:19:12 <dminuoso> Mmm, and what's the precedence of the operand?
00:19:18 <dminuoso> :t ($ -1)
00:19:20 <lambdabot> Num a => (a -> b) -> b
00:19:20 <dminuoso> % :t ($ -1)
00:19:21 <yahb> dminuoso: Num a => (a -> b) -> b
00:19:27 <dminuoso> So between 1 and 6 I guess
00:20:50 <dsal> > Just (odd (-1))
00:20:52 <lambdabot>  Just True
00:21:18 <dsal> > let numbers = [1..10] in   negate <$> numbers
00:21:21 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
00:21:53 <dsal> I think there's a language extension that lets naked negative numbers work.
00:33:16 <hekkaidekapus> % :set -XNegativeLiterals
00:33:17 <yahb> hekkaidekapus: 
00:33:35 <hekkaidekapus> % map (0 -) [-10 .. -1]
00:33:36 <yahb> hekkaidekapus: [10,9,8,7,6,5,4,3,2,1]
00:33:41 <boxscape> % 3 * -10
00:33:42 <yahb> boxscape: -30
00:33:44 <hekkaidekapus> % :q
00:33:44 <yahb> hekkaidekapus: 
00:35:06 <boxscape> kind of unfortunate that (- 10) is still not a section with -XNegativeLiterals
00:35:31 <hekkaidekapus> It will be, soon.
00:35:39 <boxscape> oh, nice
00:36:12 <hekkaidekapus> I don‚Äôt remember the exact proposal but it is already accepted, IIRC.
00:36:19 <boxscape> goodd
00:36:23 <boxscape> s/dd/d
00:37:07 <hekkaidekapus> And Vladimir, its author, tend to swiftly implement parser-related proposals.
00:37:16 <hekkaidekapus> *tends
00:37:18 <boxscape> I suppose https://github.com/ghc-proposals/ghc-proposals/pull/344
00:37:48 <boxscape> yeah it already has a closed merge request
00:38:02 <boxscape> but not a merged merge request I think
00:38:02 <hekkaidekapus> o/
00:38:22 <boxscape> never mind
00:38:30 <boxscape> gitlab merge requests are just confusing is all
00:45:05 <hekkaidekapus> boxscape: <https://paste.tomsmeding.com/tW4JoIo9>
00:45:19 <boxscape> very cool
01:00:08 <merijn> meh, just use subtract instead of relying on an extension >.>
01:01:11 <boxscape> no >:(
01:01:27 <merijn> This whole "lets pile on 30 syntactical extensions to fix minor warts" thing is a terrible idea
01:01:53 <dminuoso> If you think of a syntactical extension as just a candidate for a future Haskell report, I dont think extensions are that bad.
01:02:04 <merijn> We end up with 2^n distinct lexical grammar that need to be supported in all tools
01:02:17 <merijn> dminuoso: ha
01:02:21 <dminuoso> merijn: That's why you use ghc-lib-parser.
01:02:23 <dminuoso> ;)
01:02:26 <merijn> Like a future Haskell Report will ever happen
01:02:35 <dminuoso> It might, nothings off the board
01:02:49 <merijn> Sure!
01:03:05 <merijn> And I might someday become a millionaire!
01:03:12 <merijn> But I wouldn't count on it...
01:03:30 <dminuoso> My point is just, I dont think extensions are necessarily bad.
01:03:36 <boxscape> we'll get -XGHC20XX flags at least
01:03:45 <merijn> I don't think extensions are necessarily bad either
01:03:53 <merijn> I think *trivial syntactic extensions* are bad
01:04:18 <dminuoso> I think trivial syntactic extensions are much better than wide ranging syntactic extensions.
01:04:25 <merijn> ok
01:04:29 <merijn> lemme rephrase
01:04:39 <merijn> *all* syntactic extensions are trivial *and* bad
01:04:56 <carbolymer> is there any function in parsec (or related libraries) to parse input with parser of a to get [Either Parser a]?
01:05:07 <merijn> And the handful that aren't trivial (I'm looking at you, ArrowNotation) are double bad
01:05:08 <carbolymer> [Either ParserError a]
01:05:58 <dminuoso> carbolymer: What should that list represent?
01:06:48 <carbolymer> dminuoso, a result of multiple parsings; I want to extract from input multiple 'a's separated by separator; but I want to retain all parserrors
01:07:35 <[exa]> carbolymer: you will have to reliably extract the parts as strings and run the parser normally on the contents (e.g. runParser).
01:08:04 <[exa]> carbolymer: the "direct" method involves the (problematic) error recovery
01:08:25 <carbolymer> [exa], yeah, I wanted to avoid splitting strings and use big parser for the list of 'a's
01:09:21 <[exa]> I'm gonna double check megaparsec docs, I remember there was some error recovery but not sure where (or if in megaparsec)
01:09:23 <boxscape> huh, is the LANGUAGE pragma redundant and replaceable by OPTIONS_GHC?
01:09:56 <merijn> boxscape: If you pretend there is only GHC, sure
01:10:02 <boxscape> ah, fair
01:10:24 <merijn> Especially considering UHC implements a number of GHC extensions too
01:10:54 <eedgit> I'm having trouble getting Haskell-chart to work, I'm getting a PATH error - but I've ensured my path is on both basic and zshrc -> https://dpaste.org/0JCw
01:12:58 <[exa]> eedgit: and there's even more than one! :] Are you sure stack isn't changing the $PATH ?
01:13:48 <[exa]> anyway, it looks just like a warning so it could work
01:15:31 <[exa]> carbolymer: actually they have this https://hackage.haskell.org/package/megaparsec-9.0.1/docs/Text-Megaparsec.html#v:withRecovery
01:16:35 <[exa]> carbolymer: for you it should work with something simple like `manytill ','`
01:17:31 <carbolymer> [exa], hmm, thanks, will look into that!
01:29:00 <dminuoso> Note that withRecovery requires care wrt to backtracking
01:30:42 <dminuoso> carbolymer: Can you perhaps elaborate on your larger goal?
01:33:31 <[exa]> I guess that megaparsec in general requires care wrt backtracking.. :]
01:33:48 <[exa]> but yeah this can be ugly, esp. the error message masking
01:35:39 <dminuoso> It's moments like this where maybe parser combinators are just too powerful for your own good.
01:35:44 <dminuoso> :p
01:39:45 <eedgit> [exa] Not sure about stack changing the path, is there anyway to check? Doesn't want to build without fixing it, it seems `gtk2hs-buildtools needed, but the stack configuration has no specified version  (latest matching version is 0.13.8.0)`
01:41:44 --- mode: ChanServ set +o Sigyn
01:41:53 <eedgit> Oh, `export PATH=~/.local/bin:$PATH echo $PATH` before running the stack install command worked
01:56:07 <typetetris> How can I get the gc stop the world pause times? Which stat in ekg would that be? Or here https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-Stats.html ?
01:56:44 <typetetris> Is it the elapsed_ns
01:57:33 * hackage circular 0.3.0 - Circular fixed-sized mutable vectors  https://hackage.haskell.org/package/circular-0.3.0 (dschrempf)
01:58:21 --- mode: ChanServ set +o Sigyn
02:00:30 <eedgit> Still no joy though, should I have both a `stack.yaml` and a `package.yaml` ? https://gist.github.com/glasgowm148/0b5d7834c322100692317d6b6be0c898
02:03:19 <merijn> eedgit: Define "should" :)
02:04:07 <merijn> stack.yaml specifies your stack configuration. package.yaml is an hpack thing (stack just happens to automatically call hpack), and I would generally define hpack as *bad* :p
02:04:17 <merijn> See also: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07
02:05:31 <eedgit> oh ok thanks, thought maybe it was mixing them up somehow
02:06:23 <eedgit> Adding it to the stack.yaml appears to make it look in the current directory for a folder with that name, but the package doesn't install a folder with that name anywhere as far as I can see
02:08:41 <merijn> (I don't actually use stack, so I can't help with the details :p)
02:16:55 <eedgit> no worries, got a bit further 'From lts-13.11 and above gtk2hs-buildtools is not available in stackage, so you need to add it as an extra-dep.' > https://stackoverflow.com/questions/58690982/getting-error-while-using-gtk2hs-buildtool-library-in-haskell-project-using-stac
02:35:57 <zyklotomic> dminuoso: i'm back if you're still here and happen to have that  example
02:36:29 <zyklotomic> I did read up on Conduit too, but I have another slightly tangential question, then when is it "acceptable" tm, to use State?
02:37:51 <zyklotomic> my original rationale was it may be easier to write the slightly complex control block of if-else-then for-loop in terms of State, I knew you could probably do it with a fold, but it still seemed a lot harder to write / bad readability
02:49:43 <dminuoso> zyklotomic: Hiya. https://gist.github.com/dminuoso/1dae6372dc8df57e780899759f9156ed
02:50:54 <dminuoso> So this with a single "mutable" buffer encoded as a function argument to go
02:51:34 <dminuoso> This is a bit more constrained than State. Also this streams
02:51:44 <dminuoso> So it works on an infinite input list
02:54:34 <dminuoso> What Conduit buys you, is being able to talk about streaming together with IO in constant space and in a composable fashion
02:54:56 <dminuoso> I suggested conduit based on some quick skimming of your code
02:55:20 <dminuoso> The code seemed to call into ffi for linguistic things
02:58:10 <dminuoso> And with conduit you can write this streaming in a semi-imperative style, since you can "await" for input and "yield" 
02:58:25 <dminuoso> (It doesnt have to be conduit, there's a large wealth of libraries in this design space)
03:00:57 <merijn> bleh, containers really needs a better story for "constructing a map while checking for duplicate keys"
03:03:18 <zyklotomic> i see, that makes sense
03:05:19 <kuribas> conduit seems the easiest to us...
03:07:03 * hackage circular 0.3.1 - Circular fixed-sized mutable vectors  https://hackage.haskell.org/package/circular-0.3.1 (dschrempf)
03:08:51 <Taneb> merijn: if something like "insertOrFail :: k -> a -> Map k a -> Maybe (Map k a)" that failed on duplicate keys existed it'd carry a lot of weight there...
03:09:15 <merijn> Taneb: tbh, I was thinking more some general Applicative
03:09:52 <merijn> "fromListWithKey :: (Ord k, Applicative f) => (k -> a -> a -> f a) -> f (Map k a)"
03:09:55 <merijn> eh
03:10:01 <merijn> Add a missing [(k, v)] there
03:10:23 <merijn> Taneb: That way you could even easily do fancy things like "report all duplicates via Validation"
03:11:23 <maerwald> kuribas: what? :D
03:11:42 <kuribas> to use I mean
03:12:03 * hackage hriemann 0.3.3.4 - A Riemann Client for Haskell  https://hackage.haskell.org/package/hriemann-0.3.3.4 (shmish111)
03:12:06 <kuribas> it's most like unix pipes
03:16:18 <maerwald> I think it's not really idiomatic, because you're not really using standard operators (like monadic bind)
03:17:17 <hekkaidekapus> merijn: There is a Set version of your apllicative in the repo and D.F. would very probably merge a Map version of it. See <https://github.com/haskell/containers/issues/680>
03:19:12 <dminuoso> Taneb: Well you can quickly cook it up with alterF
03:19:28 <merijn> dminuoso: I'm talking about fromListWith
03:20:06 <dminuoso> Ah, I guess a fold over alterF would be rather expensive
03:20:11 <dminuoso> In comparison
03:20:39 <merijn> dminuoso: The fact that the default, most convenient construction mechanism is unsafe (i.e. clobbers keys) and there is no sensible way to detect that is a farce
03:21:55 <merijn> you can roll your own via fromListWith and sequence, but it's tedious
03:22:01 <hekkaidekapus> From that discussion, it more of something waiting for a proposed patch than a farce.
03:22:50 * hekkaidekapus gets that merijn is mostly venting‚Ä¶
04:06:10 <dminuoso> cosmos :: Plated a => Fold a a
04:06:12 <dminuoso> The word plays.
04:06:28 <Taneb> :t universe
04:06:30 <lambdabot> Plated a => a -> [a]
04:07:39 <dminuoso> Taneb: Is there any meaning inside those, or are they just to denote the "all of it"?
04:18:24 <Taneb> dminuoso: I think the terminology predates lens here, universe comes from at least universe and cosmos is just a near-synonym of that
04:18:37 <Taneb> So I think it's just "all of it"
04:27:15 <merijn> hekkaidekapus: "Me needing to write a patch decades after something should've been added" is a farce >.>
04:36:13 <hekkaidekapus> merijn: Gotcha! In all honesty, even a seemingly non-contentious patch could later be stalled due to performance tuning knobs in containers. PR!340 is an emblematic example: a ~7kLOC+ & ~5kLOC- patch ending in a ‚Äúcute but not fast‚Äù state gives pause.
05:19:52 <carbolymer> https://bpa.st/TISA - what's wrong with my parser?
05:22:50 <carbolymer> choice is supposed to test everything and fail when nothing matches
05:24:27 <carbolymer> or w8, is string consuming input letter by letter thus preventing next case to be evaulated?
05:24:41 <lambda> I have a `data T = A Int | B String | C` and a `[T]` and want to check if it contains of one of each `A`, `B` and `C` (without having to write them down again separately). Am I just overthinking this or does this need some special magic?
05:25:32 <carbolymer> oh fuck, right, that's exactly what's happening, I should use `try . string`
05:25:52 <Rembane> carbolymer: Exactly! More about that here: https://stackoverflow.com/questions/33057481/why-does-it-seem-that-the-parsec-choice-operator-depends-on-order-of-the-parsers
05:26:22 <carbolymer> Rembane, thx
05:27:23 <merijn> heh
05:27:35 <Rembane> carbolymer: np! 
05:27:35 <merijn> Did I just get lucky with my AoC input? :p
05:27:45 <xerox_> how?
05:27:46 <merijn> because I just use asum without problems :p
05:28:07 <cheater> xerox_: what is the (ri -> n) syntax in your code in pattern matches?
05:28:28 <xerox_> asum is nice
05:28:49 <merijn> Well, I didn't bother with try around string and my parser still works :p
05:29:27 <xerox_> some people did it all in the parser!
05:29:33 <hekkaidekapus> carbolymer: I get that some people prefer parsec because of its boot lib status, but you could also use almost the same code with megaparsec and you wouldn‚Äôt have to worry about backtracking for chunk (string) parsers.
05:29:53 <geekosaur> cheater, looks like a view pattern to me
05:29:58 <cheater> thanks
05:30:06 <merijn> hekkaidekapus: tbh, I'm starting to prefer parsec (again) because the megaparsec haddocks are a mess
05:30:50 <hekkaidekapus> merijn: Some of the haddocks were copied verbatim from parsec and don‚Äôt match the lib‚Äôs implementation.
05:30:54 <merijn> I dunno when they started degrading, but the haddocks are borderline useless to me (an experienced user of like 6 different parser combinators) as there seems to be almost no care in how combinators and modules are grouped
05:31:04 <merijn> hekkaidekapus: My problem isn't even the description
05:31:34 <merijn> hekkaidekapus: It's that it's impossible to find things I *know* exist. How can beginners possibly find something when they don't even have years of parser combinator experience
05:31:58 <hekkaidekapus> Ah, that.
05:32:12 <merijn> The fact that it, for example, re-exports "Control.Monad.Combinators" without the docs for the re-export is *terrible* for example
05:33:14 <hekkaidekapus> But the split to parser-combinators was a good decision, IMO.
05:33:17 <merijn> Now, I know it's unfortunate that haddock doesn't (yet) support nice re-exports for whole module, but that can be solved by explicitly naming each re-export. Yes, explicitly listing all of Control.Monad.Combinators is an awkward tedious job, but for something as polished as megaparsec it's a shame it doesn't
05:33:42 <merijn> hekkaidekapus: Irrelevanat, they could still list the re-exports and thereby get inline haddocks for them in the Text.Megaparsec module
05:33:52 <merijn> Instantly improving the usability for both beginners *and* experts
05:34:42 <hekkaidekapus> No argument there, docs improvements are always welcome.
05:37:24 <hekkaidekapus> carbolymer: More to the point, `let eclP = choice (chunk <$> yourList); runParser eclP "" "brn"` will work like a charm with megaparsec.
05:39:57 <hekkaidekapus> merijn: Guess what? ‚ÄúControl.Monad.Combinators documentation should be reexported.‚Äù <https://github.com/mrkkrp/megaparsec/issues/417>
05:42:04 <hekkaidekapus> Paging lyxia‚Ä¶
05:42:11 <hekkaidekapus> lyxia: Are you there?
05:48:31 <cheater> geekosaur: thanks. are implicit view functions implemented in ghc?
05:48:43 <cheater> the foo (-> 4) stuff
05:49:01 <hekkaidekapus> {-# language ViewPatterns #-}
05:49:44 <merijn> hekkaidekapus: tbh, I'd argue that implicit re-exports of modules from another package are a misfeature anyway, as there's no way to do that and stay PVP compliant unless you maintain strict upperbounds
05:51:04 <hekkaidekapus> It could be configurable as lyxia proposed.
05:51:18 <maerwald> someone said "upper bounds"? :p
05:51:40 <hekkaidekapus> haha‚Ä¶
05:52:22 <merijn> maerwald: hmm?
05:52:24 <hekkaidekapus> maerwald says: ‚ÄúCI and tooling are better.‚Äù :p
05:52:53 <merijn> maerwald: https://i.kym-cdn.com/entries/icons/facebook/000/006/759/both.jpg
05:53:29 <merijn> CI is nice for detecting breakage, but doesn't help you get non-broken buildplans
05:54:02 <maerwald> If I'd have time I'd make a study about why software is so crappy these days. I think there are two main reasons: git and semver. It allows to move fast and break stuff as much as you like.
05:54:48 <maerwald> And I'm not saying I blame git or semver, but I think those are observable effects.
05:54:58 <maerwald> But we can argue about causality
05:56:21 <hekkaidekapus> We could also adopt a solution available right now: follow the PVP and write down those bounds.
05:58:26 <maerwald> hekkaidekapus: did anyone think of the security implications of that approach? :) I think it's a safe bet that bugfixes are never backporeted to major previous versions
05:58:52 <merijn> maerwald: That's an entirely different issue
05:58:56 <maerwald> doing semver properly is really hight maintenance load
05:58:59 <maerwald> and ppl are lazy af
05:59:14 <merijn> "Should you develop against the latest version as much as possible?" 'yes'
05:59:21 <hekkaidekapus> Devops is also high maintenance.
05:59:36 <merijn> Should you *package* versions so that they have less chance of breaking retro-actively (i.e. add upperbounds)? Also yes
06:00:04 <merijn> maerwald: I work a lot with scientific code. Security is a non-issue, but the ability to reasonably reive 10 year old code is a big deal
06:00:46 <merijn> Do upperbounds help you avoid security issues and what not? No. Do they help ensure that a package that builds correctly *now* has a non-zero chance of building as-is ten years from now? Yes.
06:00:52 <maerwald> I don't mind semver if 1. I get build time warnings saying "this major version is going EOL in 1 year", so I can prepare and assign tickets to interns, 2. major versions are maintained for at least a couple of years
06:01:13 <merijn> maerwald: That's an entirely separate concern, though
06:01:41 <merijn> maerwald: You care about "how long/well will this be supported?" which is a valid concern, but no one is pretending upperbounds address that at all
06:02:33 <exarkun> I see a lot of socket types on hoogle.   is Network.Socket the correct answer?
06:02:39 <merijn> Upperbounds address a single (trivial from a distribution/operations perspective, but important nonetheless) issue of "if it builds now, it should build 10 years from now using the compiler from 10 years ago"
06:02:58 <maerwald> merijn: they don't even address that well
06:03:16 <maerwald> freeze files, stack and nix address that
06:03:16 <merijn> maerwald: Sure, but do you have a *better* solution?
06:03:27 <hekkaidekapus> What amazes me is a subset of people rallying against upper-bounds, but happily writing down Nix expressions to lock down deps up to exact commits (not maerwald, obviously. :p)
06:03:47 <maerwald> if I want to build something in 10 years, an upper bound isn't enough for me, I want to reproduce the environment
06:03:57 <merijn> hekkaidekapus: "oh, but I don't wanna write upperbounds, because it's tedious :((("
06:04:04 <maerwald> hekkaidekapus: yeah, nix is a nightmare if you care about security
06:04:21 <merijn> hekkaidekapus: 5 minutes later "why am I stuck in cabal hell and nothing's building when I try to use this 6 year old package?!?!?"
06:04:32 <hekkaidekapus> lol
06:04:45 <merijn> Man...fuck those people >.>
06:05:13 <hekkaidekapus> That escalated quickly. >.>
06:05:19 <maerwald> lolo
06:05:39 <maerwald> merijn: take a sip of Laphroaig
06:05:46 <maerwald> good for your blood pressure
06:05:46 <merijn> maerwald: It's only 3 PM >.>
06:06:00 <hekkaidekapus> Friday PM is ok.
06:06:18 <maerwald> No one will mind
06:06:23 <merijn> hekkaidekapus: See, the great thing of hypothetical strawmen is that you can rage against them without anyone getting upset!
06:06:38 <merijn> (Well, if you keep your rage to a somehwat acceptable level)
06:07:22 <hekkaidekapus> In before maerwald talks about blood pressure and insurance costs induced by upper bounds‚Ä¶
06:07:27 <merijn> maerwald: I'm writing C++ right now, my bloodpressure can't be saved
06:09:09 <maerwald> C++ is like weed... if you're already paranoid, it will CRACK you
06:09:26 <kuribas> merijn: I cannot imagine what clojure would do to you :)
06:09:37 <maerwald> ok, yes, clojure is worse
06:10:17 <maerwald> You can randomly delete lines and it still compiles, but instead of showing a web page with account information, will start to compute mandelbrots and send them over a blockchain
06:11:19 <kuribas> clojure is way to lenient
06:11:26 <kuribas> even more than common lisp.
06:11:38 <kuribas> Anyway, that's offtopic...
06:11:41 <geekosaur> @remember maerwald ok, yes, clojure is worse. You can randomly delete lines and it still compiles, but instead of showing a web page with account information, will start to compute mandelbrots and send them over a blockchain
06:11:41 <lambdabot> Good to know.
06:35:04 <lyxia> hekkaidekapus: did you ping me
06:43:54 <tdammers> maerwald: well, duh, just don't delete those lines then XD
06:44:38 <maerwald> :D
06:53:12 <typetetris> Sorry for asking again: Which metric in ekg indicates gc pause times? Which metric in `GHC.Stats`?
06:53:21 <typetetris> Or can they only be seen with an eventlog?
06:59:03 * hackage rhbzquery 0.1.1 - Bugzilla query tool  https://hackage.haskell.org/package/rhbzquery-0.1.1 (JensPetersen)
07:05:54 <merijn> hmm
07:06:27 <merijn> Is there a convenient way to run a number of megaparsec parsers in non-deterministic order?
07:08:32 <sm[m]> choice $ map try $ randomizeList [p1,p2,p3]  ?
07:08:55 <merijn> sm[m]: That still only parses one
07:09:06 <merijn> I mean "I need to parse N things in an unknown order"
07:09:07 <Mrbuck> hi some I think haskell a good choice for distributed systems? Any serious known project related to that domain
07:09:39 <merijn> sm[m]: So "try to parse p1-p3, check which succeeds, then continue with the remaining two"
07:09:53 <sm[m]> merijn: oh.. yes there is something in megaparsec for that. "permute" ?
07:10:16 <merijn> Not permute at least :p
07:10:53 <merijn> sm[m]: Text.Megaparsec.Perm used to exist, but got nuked, apparently
07:11:45 <merijn> ah, it's in parser-combinators now
07:13:33 <sm[m]> yup runPermutation
07:17:07 <exarkun> Okay, nobody gonna warn me away from Network.Socket?
07:19:01 <Philonous> exarkun, If you need to work with sockets, then network's Network.Socket is the way to go. 
07:19:58 * shapr hugs exarkun
07:20:54 <exarkun> Heya shapr 
07:23:31 <Philonous> I have a series of requests and each requests carries a nonce and a time stamp, so I want to check if I have seen that nonce before. To limit the amount of space I need I want to only store a sliding window of them, and now I'm wondering which data structure to use. If I use a ¬ªMap UTCTime Nonce¬´ I can drop old entries using dropWhileAntitone or split on O(log(n)) , but looking for the nonce is O(n). If I use a ¬ªMap Nonce UTCTime¬´ I 
07:23:31 <Philonous> can find the nonce in O(log(n)), but dropping old entries is O(n) 
07:23:53 <Philonous> Is there a clever data structure that has insert, drop-old and lookup, all in log(n) ? 
07:27:57 <__monty__> Is there a workaround to use ghcid in a multi-package project? Running it for a single project at a time would be fine but `ghcid -c 'cabal repl Project:exe:Myexe'` doesn't work, it doesn't report any syntax errors I introduce in my sources.
07:28:04 * hackage proteaaudio 0.9.0 - Simple audio library for Windows, Linux, OSX.  https://hackage.haskell.org/package/proteaaudio-0.9.0 (CsabaHruska)
07:29:34 * hackage stack-all 0.1.1 - CLI tool for building across Stackage major versions  https://hackage.haskell.org/package/stack-all-0.1.1 (JensPetersen)
07:30:08 <sm[m]> monty: yes, pass additional -iDIR arguments
07:31:04 * hackage proteaaudio-sdl 0.9.0 - Simple audio library for SDL.  https://hackage.haskell.org/package/proteaaudio-sdl-0.9.0 (CsabaHruska)
07:31:58 <lightwave> I'm hitting a wall on my Haskell journey when I'm reading the "Haskell Programing from first principal" book.
07:32:35 <sm[m]> "make ghcid" in hledger's Makefile is an example. Also I think one of the tools, probably stack, allows "stack ghci all" or some such
07:33:43 <lightwave> While reading about Maybe and Either in chapter 12, I ran into this paragraph about Lifted and Unlifted types. '''Lifted and unlifted types To be precise, kind * is the kind of all standard lifted types, while types that have the kind # are unlifted. A lifted type, which includes any datatype you could define yourself, is any that can be inhabited by bottom. Lifted types are represented by a pointer and include 
07:33:43 <lightwave> we‚Äôve seen and most that you‚Äôre likely to encounter and use. Unlifted types are any types that cannot be inhabited by bottom. Types of kind # are often native machine types and raw pointers. Newtypes are a special case in that they are kind *, but they are unlifted, because their representation is identical to that of the type they contain, so a newtype itself is not creating any new pointer beyond that of t
07:33:43 <lightwave> fact means that the newtype itself cannot be inhabited by bottom‚Äîonly the thing it contains can be‚Äîso newtypes are unlifted. The default kind of concrete, fully-applied datatypes in GHC is kind *.'''
07:34:18 <sm[m]> lightwave: phew
07:35:12 <lightwave> What is a lifted/unlifted type? I am thoroughly confused. My apology for pasting the paragraph.... didn't look that big ono the PDF. LOL
07:35:18 <sm[m]> and this is the book we send beginners to :)
07:35:56 <merijn> sm[m]: Pretty sure that's an aside :)
07:36:22 <merijn> lightwave: it's not really that important right now, just a mental note for "later"
07:36:38 <merijn> lightwave: Incidentally, do you happen to know Java or C#?
07:37:01 <lightwave> I used to write Java. :-)
07:37:07 <xerox_> this is just a proposal or is it implemented somewhere? https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns#implicit-view-functions
07:37:14 <boxscape> hmmm I wish I could use `compare `on` fst` to compare (String, String) with (String, String -> Bool)
07:39:16 <lightwave> merijn: It's not shown as an aside in the book. In this book, I'm hitting a lot of these "aside" things in the middle of learning the basics. hahaha
07:39:41 <merijn> lightwave: Right, so do you have a sense of the difference between "int" and "Integer"?
07:39:45 <xerox_> boxscape: maybe there's a way passing through Arg
07:39:48 <boxscape> Seems like that section from a book is a little outdated as well, since kinds of Unlifted types now have different names
07:40:13 <xerox_> boxscape: scratch that, the types wouldn't match anyway
07:40:29 <lightwave> merijn: Yes, int is a primitive while Integer is a boxed int.
07:40:45 <lightwave> merijn: kind of like the newtype thingy in haskell?
07:41:06 <merijn> lightwave: "lifted" = boxed (roughly) "unlifted" = unboxed/primitive (roughly)
07:42:33 <merijn> lightwave: GHC actually has a slightly more nuanced distinction of types, but that's close enough
07:43:05 <merijn> lightwave: Boxing exists for the same reason too, to accommodate parametric polymorphism (aka Java's generics)
07:43:15 <lightwave> merijn: What does "A lifted type is any that can be inhabited by bottom." mean? Bottom (in the british sense) vs. a?? in the american sense? LOL
07:43:47 <merijn> lightwave: Bottom in type theory terms is "non-terminating computation"
07:45:14 <merijn> lightwave: Since Haskell is turing complete it's possible to write infinite computations for any possible type. "bottom" is the term used to describe any "non-terminating computation" and any "normal type" can (via laziness) harbor such a non-terminating computation inside
07:45:53 <merijn> lightwave: otoh, a machine integer isn't lazy. It's just a machine integer, and thus cannot secretly be infinite
07:46:16 <merijn> lightwave: It's a bit weird that it's going into that, because this is some fairly nuanced GHC implementation details stuff :p
07:47:11 <lightwave> merijn: I see... so if bottom is in the set for the type, the type is a lifted type?
07:47:20 <__monty__> sm[m]: Hmm, I think this might not work for me because I'm making use of cabal's generated data-files modules and ghci can't find those. So I think I need cabal repl. I also don't think -i solves my problem, I don't have deps in other directories.
07:47:33 <merijn> lightwave: If you have "x :: Int" then (due to laziness) you can't tell whether you have 1) an actual number or 2) a lazy computation returning a number
07:48:01 <merijn> lightwave: Whereas with "x :: Int#" (the unlifted integer type, thinkg Java's "int") you *know* you have a number
07:48:01 <lightwave> What's the best intuitive way to wrap my head around "lift" or "lifted" type...? English is not my language....
07:48:39 <merijn> lightwave: tbh, mentally replacing "lifted"/"unlifted" with Java's "boxed"/"unboxed" (or primitive) is cloe enough
07:49:21 <merijn> It's not 100% accurate, but it's, say, ~95% accurate which is more than good enough for beginners :p
07:49:53 <lightwave> Knowing less is more in my Haskell journey... LOL
07:50:44 <merijn> lightwave: tbh, for a long time "boxed" was also used in GHC/papers talking about GHC, so it's not that weird to use
07:51:16 <lightwave> I'm 466 pages into this book and I'm still no where near writing any "fun" program to sratch my itch.
07:51:48 <merijn> It's...not a "quickly start hacking book", no. There are other, shorter books, though :)
07:51:49 <lightwave> Still 800 pages to go. LOL
07:53:13 <Franciman> Hi, what is stackage made of?
07:53:18 <lightwave> I told my wife I'm not going to buy a Nintendo Switch until I finish this book by end of year. Bad decision...
07:53:32 <Franciman> is there any file representing a stackage snapshot?
07:53:59 <sm[m]> big mistake ! :)
07:54:37 <hyperisco> https://hackage.haskell.org/package/foldl-1.4.10/docs/Control-Foldl.html#t:EndoM is there another formulation or source of this?
07:54:40 <merijn> lightwave: That said, you don't have to stop yourself from writing stuff until you finish the book :p
07:54:43 <hyperisco> particularly for folding
07:54:51 <hyperisco> Foldable f => f (a -> m a) -> a -> m a
07:56:27 <sm[m]> Franciman: build-constraints.yaml in the stackage repo
07:57:10 <lightwave> merijn: My brain is constantly distracting me with ideas on how to "rewrite" an existing system with Haskell. Kind of like day-dreaming about the utopia of 100% Haskell & PureScript code base. :-)
07:57:34 <Franciman> sm[m], thank shon
07:57:40 <lightwave> I'm sure that happens to lots of beginners...
07:58:15 <sm[m]> yup
07:58:31 <monochrom> IMO it is the fault of HFFP to bring up unlifted types this early. (Yes, 400 pages into is still too early.)
07:58:38 <merijn> monochrom: I agree
07:58:47 <merijn> I don't recall them being in there, let alone that early
07:58:59 <merijn> I'm sure my girlfriend would've been confused and asked me...
07:59:00 <monochrom> In fact for most practical purposes you don't even need to know for your entire life.
07:59:12 <merijn> lightwave: ^^^ that
07:59:23 <lightwave> I'm beginning to see why Haskell is harder to learn for seasoned programmer.
07:59:36 <jollygood2> hi. I need to compare images of different size for similarity. what haskell package or packages do you recommend?
07:59:46 <sm[m]> HFFFP is the book #haskell would write given unlimited time :)
07:59:50 <merijn> lightwave: Naah, this is just poor pedagogical timing
08:00:00 <merijn> lightwave: (of the book)
08:00:11 <monochrom> When do you need to know: you read asm code generated by GHC, or you want to write the next generation vector library, or you contribute to GHC... low-level stuff.
08:00:28 <sm[m]> lightwave: there are other books that move along faster
08:00:40 <merijn> lightwave: unlifted types are interesting if you wanna, say, write super high performance code/etc. not for "I wanna write a simple application"
08:00:49 <Taneb> I've been writing Haskell for like a decade now and I don't think I've ever really needed to know about unlifted types
08:01:09 <Taneb> Except for when I was trying to a write a program that would go faster than the one my friend wrote in C++ or something
08:01:30 <monochrom> Well, I avoided the magic trigger word "performance" because everyone goes overboard with "performance".
08:01:43 <lightwave> sm[m]: I was reading PureScript by Example and then found it to be too sparse in details.
08:01:47 <merijn> monochrom: Also true
08:02:32 <merijn> monochrom: That's because most programmers don't understand shit about performance :)
08:02:33 <lightwave> monochrom: hear hear
08:02:36 <sm[m]> lightwave: it's good to have a place to turn when you want more details, maybe LHFFP is that
08:03:10 <lightwave> sm[m]: What's LHFFP?
08:03:26 <Franciman> sm[m], wait, but in the build-constraints I see no constraints :)
08:03:46 <sm[m]> I'm trying to remember the acronym for the book you're talking about, and probably failing. Even that is too long for me :)
08:04:11 <Franciman> Learning Haskell for Future Proof
08:04:13 <Franciman> ?
08:04:38 <sm[m]> Franciman: they're implied somehow, I forget the details but read me should say
08:04:45 <Franciman> oh great, thanks
08:05:05 <lightwave> Oh the book I'm reading is "Haskell Programming from first principal"
08:05:26 <sm[m]> HPFFP. Thank you
08:06:06 <sm[m]> very unmemorable alas
08:07:11 <lightwave> The book "Real World Haskell" is more appealing but perhaps a bit dated?
08:07:20 <boxscape> sm[m] I just think of it as haskellbook
08:07:24 <boxscape> @where haskellbook
08:07:24 <lambdabot> http://haskellbook.com
08:07:49 <sm[m]> lightwave: yes. One I like is 
08:07:49 <sm[m]> @where HTAC
08:07:49 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
08:07:50 <boxscape> lightwave definitely dated
08:07:55 <ski> @where HPFFP
08:07:55 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
08:08:22 * ski isn't really fond of the name "haskellbook"
08:08:50 <sm[m]> yup, we have more than one
08:09:50 <int-e> ski: quick, register thehaskellbook.com
08:11:40 <int-e> https://haskellbooks.com/ haha
08:11:48 <int-e> (fair enough)
08:12:44 <int-e> (and in fact the existence of that domain makes haskellbook.com slightly more questionable to my mind)
08:13:01 <maerwald> boxscape: have the lawsuits around that book settled? >:)
08:13:07 <boxscape> no clue
08:13:20 <merijn> I thought they were settled out of court?
08:13:23 <Franciman> oh I found out about jenga, such a great project
08:13:35 <Franciman> soon stack will be useless, except for being hipster
08:14:14 <maerwald> there's also stack2cabal 
08:14:31 <maerwald> and jenga is deprecated
08:14:36 <Franciman> oh :<
08:14:37 <Franciman> why
08:14:41 <sm[m]> ha I'd take that bet
08:14:44 <maerwald> because it says so on hackage
08:14:46 <sm[m]> damn too late
08:15:24 <merijn> Readme of that still mentions sandboxes :p
08:15:24 <Franciman> why don't we create our own version of stackage that doesn't rely on amazon?
08:15:34 <Franciman> ah, because we are poor
08:15:38 <merijn> Franciman: So..."hackage"? :p
08:15:47 <Franciman> merijn, does hackage provide snapshots?
08:15:56 <Franciman> of working together packages?
08:15:58 <Franciman> like a distro 
08:16:09 <maerwald> Franciman: yes, it's called stackages snapshots :D
08:16:15 <Franciman> lolz
08:16:15 <maerwald> those are just version infos
08:16:21 <maerwald> so you just use that
08:16:23 <merijn> Franciman: Sure, just make a freeze file :p
08:16:31 <lightwave> What? Stackage will be gone? Why?
08:16:38 <Franciman> no it won't
08:16:48 <merijn> lightwave: That was wishful thinking by some people :)
08:16:53 <Franciman> merijn, if I can translate stackage files fo cabal freezes
08:17:00 <Franciman> it'd be great
08:17:11 <maerwald> well, stack has a saner file format than Cabal, that you can actually use and parse yourself
08:17:25 <sm[m]> Franciman: I think stackage provides that somewhere
08:17:49 <maerwald> so I wouldn't want it to die, just so I can still abuse stack2cabal to generate my cabal.project files for me
08:17:59 <lightwave> Any haskeller here using PureScript to build the front-end?
08:18:31 <Franciman> sm[m], it's a bit obscure where
08:18:32 <Franciman> yeah
08:18:38 <merijn> maerwald: Hard disagree on any implication that YAML is sane >.>
08:19:01 <maerwald> merijn: don't tell me cabal file format is sane :o
08:19:15 <Franciman> what would be a cool format?
08:19:20 <maerwald> and there are zero tools that can deal with it other than a huge 300module monolith
08:19:22 <merijn> maerwald: I didn't say so, but at least that one is improving, unlike YAML
08:19:25 <Franciman> let's write a compiler
08:19:38 <Franciman> I like TOML
08:19:39 <Franciman> topkek
08:19:51 <maerwald> yes, toml, yaml, anything is better than cabal format
08:20:06 <merijn> maerwald: Tools can only "deal" with yaml in the sense that it can turn your file into a nested dictionary
08:20:15 <maerwald> yes, that's already a huge win
08:20:20 <merijn> maerwald: If you wanna actually parse it you still gotta write a parser on top of that
08:20:43 <maerwald> so tools like stack2cabal don't really need to interface or depend on stack, they can just easily parse the yaml themselves
08:20:47 <Franciman> I agree with maerwald about cabal being an arcane format only supported by a huge lib
08:20:57 <maerwald> with cabal, you have to depend on Cabal the library and that's no fun :)
08:21:00 <merijn> maerwald: The latest CABAL spec is already more parseable. Splitting of a seperate parser lib is feasible, but someone would have to actually do it
08:22:16 <maerwald> custom file formats are always a bad idea for things that will be used by a large number of ppl
08:22:29 <Franciman> agree
08:23:10 <operand> Hi, I'm trying to use Megaparsec's Lexer components, but I feel like I'm misunderstanding something.
08:23:27 <merijn> YAML doesn't eliminate any of the customness. It just means parsing dictionaries instead of text
08:24:04 <operand> Is the 'lexeme' function (when supplied with a space consumer) not supposed to strip trailing whitespace and then run the parser on the result?
08:24:10 <operand> Is it the other way around, perhaps?
08:24:16 <dcoutts_> yaml was not a popular format when the original Cabal spec was written
08:24:40 <merijn> XML was popular when Cabal was written :p
08:24:47 <dcoutts> yeah, exactly
08:24:51 <Franciman> still better than cabal, imho
08:24:54 <merijn> So be happy you don't have Maven's insanity
08:25:08 <merijn> Franciman: What, specifically, is so bad about the format?
08:25:13 <maerwald> I have PTSD from XML, no thanks
08:25:23 <Franciman> the fact that you don't have a simple library for parsing it
08:25:24 <merijn> Sure, the fact that *currently* the only parser is embedded in Cabal itself is unfortunate
08:25:30 <Franciman> is a huge downside
08:25:32 <lightwave> maerwald: I still have to suffer from XML torture...
08:25:36 <merijn> Franciman: *that* is not a complaint about the format
08:25:48 <Franciman> well it is a complain about the choices made
08:25:52 <maerwald> merijn: it is, because common formats already have all the tools
08:25:58 <merijn> Franciman: That's a complaint about the lack of an external parser. Which is valid, but different
08:26:02 <merijn> maerwald: Which tools?
08:26:10 <maerwald> parsers, formatters, anything
08:26:15 <dcoutts> but you don't just want a parser, but all the types for representing the contents
08:26:19 <merijn> Franciman: There was no "choice made" to not have an external parser
08:26:23 <int-e> merijn: the real complaint I have is about the awkwardness of multi-line text fields (synopsis)
08:26:34 <merijn> Franciman: No one has implemented one, therefore there is none
08:26:34 <maerwald> schemas, validators
08:26:49 <merijn> maerwald: There is a schema and validator it's just in Cabal.
08:27:06 <Franciman> fair point, but still
08:27:12 <merijn> I'll be the first to say that splitting up Cabal is probably a wise decisions
08:27:43 <Franciman> also using a non custom format, implies more support
08:27:45 <merijn> But given that all of Cabal and cabal-install is maintained by like 1.5 people, I suggest that if you want things to be better, you start coding this better world
08:28:18 <int-e> And I'm really glad that it's not XML.
08:28:30 <merijn> tbh, phadej is already performing minor miracles as it is
08:28:47 <merijn> Complaining is easy
08:29:06 <Franciman> merijn, I'm not complaining, though, I'm discussing
08:29:10 <Franciman> not saying cabal sucks
08:29:14 <Franciman> or else
08:29:26 <Franciman> I said that not using a custom format, could have been easier
08:29:33 <maerwald> merijn: cabal development is pretty closed doors afais, for some historical reasons. I'd say that may be one of the reasons it doesn't attract many contributors (apart from the complexity)
08:29:45 <merijn> Franciman: Easy to say, 16 (?) years later
08:29:58 <Franciman> yes, that's why I'm saying it :P
08:30:09 <merijn> maerwald: How so? You get contributor access by simply opening a PR, pretty much >.>
08:30:33 <Franciman> I think maerwald means that it is hard to get started at understanding what is going on both now and in the future directions
08:30:37 <Franciman> at least that's what I felt
08:31:08 <int-e> Franciman: IIRC the state of the art at the time were 1) key=value config files with [sections] and no nesting and 2) XML.
08:31:11 <maerwald> merijn: Well, there are some plans about upcoming cabal features, which I was told about *in private* :)
08:31:24 <maerwald> And I did not leak them
08:31:29 <merijn> Franciman: Development is pretty "I need this driven"
08:31:44 <int-e> XML is godawful for writing by hand, and lack of nesting ruled out config files
08:31:51 <maerwald> so it seems sharing visions and directions is done behind closed doors in private meetings and conversations
08:31:56 <lightwave> More like "I need this yesterday"
08:32:30 <merijn> maerwald: Most of the discussions is on IRC in #hackage and/or github issues, tbh
08:32:40 <maerwald> merijn: and I think the historical reason is that nix-style builds was in fact *planned* prior to stack, but stack then implemented it first
08:32:59 <maerwald> (announced even)
08:33:04 <merijn> maerwald: v2 implementation started prior to stack
08:33:10 <merijn> (not just planning)
08:33:13 <maerwald> yeah
08:33:18 <Franciman> int-e, ok right
08:33:26 <Franciman> then it seems a forced decision
08:33:40 <merijn> maerwald: There's no real "behind closed doors", tbh
08:34:15 <merijn> maerwald: It's more "there's no real venue for design discussions at all, and most of the vision is spread by osmosis", I think :p
08:34:51 <maerwald> sure, I'm just speculating... hard to verify either theory 
08:35:02 <sm[m]> Franciman: later hpack came along and made it easy to write cabal files in yaml. Stack integrated this as an option but cabal-install didn't  (yet!)
08:35:23 <merijn> maerwald: Well, I like to think I'm keep a close track of cabal development and the occasional patch and *I* don't know of any such venue :p
08:35:26 <maerwald> hpack was a good idea, but ppl used it wrong 
08:35:34 <merijn> sm[m]: It's not happening
08:35:47 <dolio> YAML only helps get you a concrete parse tree, so the hypothetical wider 'support' would probably be a bunch of buggy tools that each implement their own incorrect version of the actual cabal file format.
08:36:07 <maerwald> dolio: that's web scale
08:36:13 <merijn> dolio: Sure, but no one wants to admit that harsh truth
08:36:23 <sm[m]> Re closed doors, it takes extra time and energy to lead things in an open transparent manner, stack has had a bit more of that kind of leadership
08:36:25 <merijn> dolio: Everything's just strings!
08:36:42 <int-e> merijn: let's hack something in perl with regular expressions
08:36:52 <int-e> (is that redundant?)
08:37:24 <merijn> sm[m]: hpack is basically an anti-feature and one of these days I'll get around to writing a bunch of blogs on why >.>
08:37:32 <dcoutts> maerwald: what makes you think it's closed world. It's all there on github. Same as everything else. We'd really like more contributors. The problem is the lack of contributors.
08:38:08 <merijn> dcoutts: Well, one problem is that there is, afaik, no high level overview of what is roughly where in the codebase
08:38:15 <maerwald> dcoutts: open source alone doesn't imply "open development". I make a distinction of those
08:38:26 <maerwald> And this is without any judgement
08:38:28 <merijn> dcoutts: So every time I do something I spend ages delving through code and bugging phadej if he knows
08:38:54 <maerwald> open development can also crash a project (the SVN devs talked about that once)
08:39:12 <merijn> dcoutts: Especially the inversion of cabal-install calling into Cabal messes me up every single time
08:40:43 <maerwald> (e.g. I consider NixOS too much of open development)
08:42:45 <dcoutts> merijn: would something like this be useful, if it were more comprehensive? https://github.com/haskell/cabal/wiki/Source-Guide
08:43:47 <dcoutts> merijn: what do you mean by inversion? Confusing that cabal calls into the Cabal lib, or that is runs the Setup.hs exe, or both or?
08:44:35 <maerwald> dcoutts: well, one other way I could think of is that big companies allow employees to spend some time on e.g. cabal and get paid for that as well. It happens with GHC, why is cabal a 2nd class citizen here?
08:45:58 <dcoutts> maerwald: do you realise that IOHK does pay for 0.5 FTE on cabal?
08:46:07 <maerwald> :o
08:48:20 <sm[m]> I did not. Thanks IOHK!
08:48:41 <maerwald> Yeah, where's the banner in the README :)
08:48:55 <sm[m]> where is that time being spent I wonder. The ghc work has some great monthly reporting
08:50:43 <maerwald> sm[m]: you just look up the commit history of phadej :p
08:50:49 <maerwald> there's no other metric
08:52:20 <sm[m]> phadej seemed a bit conflicted about working on cabal last time we chatted
08:52:44 <merijn> dcoutts: cabal-install parsing everything, then serialising back into strings to pass to Cabal
08:52:54 <sm[m]> maybe 1.0 FTE would make a big difference, dunno
08:53:21 <Uniaika> merijn: sweet hell
08:53:22 <merijn> dcoutts: Ah, I think that was missing when I last hacked on it
08:53:23 <sm[m]> Like (I assume) bgamari is a FTE for ghc
08:53:31 <merijn> Uniaika: hmm?
08:54:02 <merijn> dcoutts: tbh, mostly it's Cabal's option parser that is confusing as fuck
08:54:25 <Uniaika> merijn: the string serialisation between the cli tool and the lib
08:54:25 <dcoutts> merijn: cli parser you mean?
08:54:29 <merijn> dcoutts: Yeah
08:54:41 * sm[m] thinks what real world cli parser isn't
08:54:45 <merijn> dcoutts: Like, it took me 5+ days to add an option to a command
08:54:54 <merijn> sm[m]: Clearly you have not looked at Cabal's
08:55:59 <dcoutts> merijn: to get rid of the serialsing back to strings, we'd have to eliminate the build-type Custom, and stop invoking Setup.hs scripts as external processes.
08:56:20 <merijn> I can't even explain why it's so confusing because my understanding is insufficient to describe it well enough to point it out
08:56:30 <merijn> dcoutts: I know *why* it exists
08:56:42 <merijn> dcoutts: But tht doesn't make it any easier to work on :p
08:56:58 <dcoutts> eliminating build-type custom would make a lot of things easier, but also break a lot of packages
08:57:02 <dcoutts> it's quite awkward
08:57:22 <merijn> dcoutts: And really, the serialising to strings wouldn't be so bad if Cabal's CLI was understandable by mere mortals without losing their mind like a Lovecraft protagonist ;)
09:10:33 * hackage time-compat 1.9.5 - Compatibility package for time  https://hackage.haskell.org/package/time-compat-1.9.5 (phadej)
09:33:00 <koz_> :t (*>)
09:33:01 <lambdabot> Applicative f => f a -> f b -> f b
09:37:41 <koz_> :t (>>)
09:37:43 <lambdabot> Monad m => m a -> m b -> m b
09:37:47 <koz_> Today I realized.
09:39:25 <merijn> :p
09:43:54 <dsal> I think >> is in monad of no return
10:07:14 <ezzieyguywuf> glguy: why is the arguement order in Config.Schema.Spec.reqSection' as it is, rather than "reqSection' :: Text -> Text -> ValueSpec a -> SectionSpec a"? it'd seem that flipping the last two would make it easier to describe nested specs in-line
10:08:06 <glguy> ezzieyguywuf: because I expected the documentation string to be long and probably on a separate line
10:08:34 <ezzieyguywuf> hrm, I see
10:09:03 <glguy> ezzieyguywuf: and I try to name the nested things, I haven't built very complicated things to use locally with reqSection
10:10:06 <ezzieyguywuf> glguy: yea, I was just thinking that naming them probably makes the most sense anyway
10:11:28 <Franciman> Hi, do you prefer github or gitlab for contributing to haskell and/or ghc?
10:11:43 <Franciman> haskell projects*
10:13:30 <sm[m]> ghc uses gitlab, most others use github
10:18:19 <Franciman> yes I mean what would be your personal preference?
10:20:37 <jle`> it will probably depend on what haskell project you want to contribute to
10:20:49 <jle`> unless you are asking, if you could decide for other people
10:23:13 <maerwald> Franciman: I self-host and use github as an availability mirror
10:23:49 <Franciman> jle`, if you could decide, yes
10:24:53 <merijn> Ideally neither, since those both involve using git ;)
10:25:04 <Franciman> :')
10:25:11 <Franciman> are you a pijul user?
10:25:24 <merijn> It's on my list to play with Soon (TM)
10:25:24 <Franciman> or you like exponential merge problems?
10:25:34 <merijn> But I wanted to wait until it's out of alpha
10:25:44 <merijn> Franciman: I mostly use Mercurial :p
10:25:49 <Franciman> i learnt there is some project for darcs 3, can't wait
10:25:55 <Franciman> merijn, rly? I found it really hard
10:26:04 <maerwald> branches are weird in mercurial
10:26:12 <merijn> Franciman: What? It's soo much simpler than git
10:26:22 <maerwald> you can't force push your development branch
10:26:25 <Franciman> ehe I don't know, I couldn't learn it, but maybe I'll give it another go
10:26:34 <merijn> maerwald: no they're not, you just gotta realised that "named branched" /= "git branches"
10:27:00 <merijn> maerwald: Also, you can force push if you're pushing to a "non-publishing" repo
10:27:19 <merijn> In fact, the phase distinction and evolve are major reasons why I think mercurial is better than git
10:27:23 <maerwald> yeah, I created a PR and wanted to update it... but I couldn't
10:27:26 <maerwald> great
10:27:45 <merijn> (although I'm currently using Mercurial as user-friendly UI for git)
10:28:13 <maerwald> git rebases are awful, but the concept of everything is state is probably easier for most ppl
10:28:28 <merijn> Easier than what?
10:28:35 <maerwald> everything is a patch
10:28:35 <Franciman> i rly like darcs, honestly, but too scared of the exponential merge problem
10:28:56 <dolio> Saying something about exponential merges is how you know someone's knowledge about darcs is like 10 years old.
10:29:09 <Franciman> dolio, PLZ EXPLAIN SAR
10:29:11 <Franciman> are they solved?
10:29:15 <Franciman> I mean always
10:29:21 <Franciman> can't they happen anymore?
10:30:10 <Franciman> I'd read with darcs 2, it got harder to get into exp merges, but they still can happen
10:30:13 <Franciman> I'm scared AF
10:30:34 <dolio> Did you know Hindley-Milner is double-exponential?
10:30:41 <Franciman> I do
10:30:43 <Franciman> so what
10:30:52 <Franciman> pijul doesn't have exp merges
10:31:19 <dolio> Because what matters is whether cases where it happens actually come up.
10:31:29 <Franciman> not from the theoretical standpoint
10:31:40 <Franciman> it's interesting if you can solve it
10:32:22 <tomsmeding> I thought I'd heard that HM is only exponential if the inferred type is also exponentially-sized, but perhaps that's a misunderstanding on my side?
10:32:52 <dolio> I think it is unknown whether the only cases are 'large types', but those are the obvious ones.
10:33:32 <tomsmeding> because for type checking I think having reasonable complexity in inputsize+outputsize is fine, even if that means it's exponential in just inputsize
10:33:58 <dolio> Anyhow, the original statement wasn't that it is 'theoretically interesting' to fix all possible merge problems. It was that you are "scared" of using a tool for practical purposes.
10:34:16 <tomsmeding> but ah, if it's unknown then TIL :)
10:34:29 <Franciman> dolio, no, I don't use darcs
10:34:32 <Franciman> I'm scared of it
10:34:56 <Franciman> because its theory still contemplates the possibility of exp merges
10:35:18 <tomsmeding> hence dolio's point, do you also not use HM because you're scared of it?
10:35:20 <Franciman> I meant from the theoretical point of view
10:35:58 <Franciman> if there were a better solution, yes I would be scared of it
10:36:22 <geekosaur> you're not making a whole lot of sense right now
10:36:29 <Franciman> why?
10:37:21 <merijn> Because, presumably, you *are* using Haskell, despite the type checking being (theoretically) exponential
10:38:12 <Franciman> now that I know, I won't anymore
10:38:14 <Franciman> eaz
10:38:30 <Franciman> but the question is, is there a better typechecking algorithm?
10:38:45 <Franciman> if yes, I shall use it, if not, I shall use Haskell
10:38:51 <Franciman> eaz
10:39:02 <Franciman> that's the whole point. I see no problem
10:39:07 <Franciman> where am I being blind to you?
10:41:54 <merijn> The fact that no real Haskell program hits the exponential case
10:42:14 <merijn> And similarly, the darcs exponential case only mattters if it occurs during real use, rather than merely hypothetically
10:42:23 <Franciman> wait
10:42:42 <Franciman> are you saying I should use haskell's typechecker even if there was a better solution?
10:42:48 <Franciman> in this case, pijul
10:42:57 <Franciman> having a better solution than darcs
10:43:45 <geekosaur> also ghc doesn't use H-M, it uses System Fc‚Ä¶ which if you take one limit off of it is Turing-complete and therefore can be worse than exponential. is this something to be scared of, and if so how do you ever use any programming language?
10:44:24 <Franciman> geekosaur, so, if you have a polynomial algorithm for SAT, you'd still use the combinatorial approach
10:44:31 <Franciman> because for your problems in practice, it's good enough?
10:45:16 <merijn> If it's easier, yes
10:45:52 <Franciman> I find this cringeworthy
10:46:01 <Franciman> I want to always use the fastest solution
10:46:40 <Franciman> but ok I can understand
10:46:44 <Franciman> it's engineering after all
10:46:57 <Franciman> bridges aren't the best solution, but they work
10:47:05 <Franciman> capitalism is not the best, but it works
10:47:07 <sm[m]> I think your reaction to darcs exponential merge is reasonable since it is always brought up and darcs hasn't really laid the issue to rest.. but just FYI, darcs users don't experience it / have learned usage patterns that avoid it
10:49:24 <sm[m]> what's better than a bridge btw ? :)
10:51:04 <tomsmeding> 19:45:38     Franciman | I want to always use the fastest solution
10:51:13 <tomsmeding> the fastest solution in practice is not always the one with the lowest complexity
10:51:30 <tomsmeding> see simplex vs interior point method for linear programming
10:52:04 <tomsmeding> also naive/strassen vs the insane theoretical algorithms with n^2.4 complexity or so for matrix multiplication
10:52:19 <Franciman> sm[m], I don't know :P
10:52:23 <Franciman> I'm not making much sense tonight
10:52:37 <tomsmeding> you're battling against pragmatists at the moment :p
10:52:41 <tomsmeding> well "battling"
10:52:46 <tomsmeding> speaking
10:52:52 <sm[m]> transporter beams, isn't it :)
10:54:56 <monochrom> The fallacy is in assuming there is one single "fastest" for all cases.
10:55:08 <monochrom> Well, actually, there is, but it is not what you think.
10:55:13 <Franciman> eheheheheheheheheheh
10:55:24 <typetetris> Why does persistent needs the types in a database schema to be PathPieces, ToHttpApiData, and {From,To}JSON ?
10:55:35 <tomsmeding> (correction: ellipsoid method, not interior point method)
10:55:41 <monochrom> For example, sorting. Oh let's even confine to comparison-based sorting, none of those radix sort tricks.
10:55:47 <Franciman> monochrom, the fallacy is that you don't know what your users are gonna do
10:55:53 * geekosaur was also going to raise the question of e.g. access vs. modify complexity/time
10:56:06 <monochrom> For input sizes below 10 or so, use a handcoded decision tree.
10:56:10 <Franciman> perfect solutions don't exist
10:56:11 <Franciman> ok
10:56:14 <geekosaur> re "always want the fastest" ‚Äî so, fastest for what?
10:56:15 <Franciman> I'll acknowledge
10:56:22 <Franciman> I was answering to SAT problems
10:56:25 <Franciman> it was a particular case
10:56:44 <Franciman> but heh, I unerstand you like Unix more than plan9 because it works fine
10:56:56 <Franciman> am I right? Are you pursuing that case?
10:57:05 <merijn> no
10:57:17 <monochrom> For input sizes between 10 and 1000 or something, use mergesort. For input sizes above 1000 or something, use some variant of quicksort.  Or something.
10:57:26 <merijn> He's pursuing the case that all live is a complicated multi-objective optimisation with no single "best" solution
10:57:44 <monochrom> Generally, do a case analaysis on the input size, then switch to an algorithm optimized for that size range.
10:57:52 <merijn> It's trade-offs all the way down, one of which is "how much of my life do I waste on researching this?"
10:57:57 <Franciman> not sure I buy it, it just that we are stupid as humankind
10:58:25 <monochrom> So, it is not true that "one single algorithm" is the fastest. But it is true that if you switch algorithms based on input size, you can do it.
10:58:35 <sm[m]> Franciman: getting back to your q, I think you know but: if contributing to a project I'll use their vcs. If starting a project and I want contributors I'll pick a vcs and hub they'll use. In the past that was darcs for haskell projects but for now it's git and github. If starting a project and only concerned about my convenience it's still git because tools integrate best with it
10:58:35 <Franciman> I mean people thought there didn't exist continuous function that are not differentiable, but they exist, in abundance even :P
10:58:38 <merijn> Franciman: Here you go: https://homepages.uc.edu/~martinj/Philosophy%20and%20Religion/Arguments%20for%20the%20Existence%20of%20God/Teleology%20&%20Intelligent%20Design/Intelligent%20Design/Wolpert%20No%20Free%20Lunch.pdf
10:58:46 <monochrom> But this is never in the minds of people who claim "I want the fastest".
10:58:57 <merijn> monochrom: No, even that doesn't work in general
10:59:08 <Franciman> I see sm[m], thanks
10:59:10 <merijn> monochrom: There are algorithms where implementation choice depends on things other than size
10:59:21 <monochrom> Yeah see, that too.
10:59:27 <Franciman> lol frameworks
10:59:37 <Franciman> merijn, is it from analytic philosophers?
10:59:38 <monochrom> IIRC GMP actually does this for multiplication.
11:00:10 <tomsmeding> it does, it has limits for switching between algorithms that you can tune for your machine if you compile it yourself
11:00:13 <monochrom> Below a certain threshold, it doesn't use the FFT algorithm. Because doesn't win there.
11:00:37 <Franciman> ok I think I get your point
11:00:52 <Franciman> you are right
11:01:08 <Franciman> but still, can I say I'd prefer a theory which avoid exponential merges?
11:01:21 <Franciman> it's not a problem of darcs or what else
11:01:26 <Franciman> but I'd find it neater
11:01:33 <merijn> Franciman: Depends, what if the theory that avoid exponential merges is 10x slower for "normal" operations?
11:01:34 <Franciman> ok I'm gonna use darcs from now on
11:01:50 <merijn> Franciman: Are you willing to accept 10x slowdown on all operations if it guarantees no exponential case?
11:01:52 <monochrom> And all this time we have been leaving out: What about programmer's time? Isn't it much more expensive than computer time?
11:02:05 <Franciman> merijn, I'd say it dependes, as you have taught me
11:02:10 <Franciman> but let me be more precise
11:02:16 <Franciman> I prefer pijul's theory to darcs, now
11:02:25 <Franciman> since it's at least as fast, and avoid exponential merges
11:06:55 <sm[m]> Franciman: we're a bit off topic here, but have you used pijul much ? I wonder which operations are still slow with it
11:09:01 <Xnuk> :t (>>>) >>> (>>>) fmap
11:09:02 <lambdabot> Functor f => (a1 -> f a2) -> (a2 -> b) -> a1 -> f b
11:09:13 <Xnuk> :t let f = (>>>) >>> (>>>) in f fmap
11:09:15 <lambdabot> Functor f => (((a -> b) -> c1) -> c2) -> ((f a -> f b) -> c1) -> c2
11:10:59 <Franciman> sm[m], i tried it
11:11:02 <Franciman> it looked ok
11:11:13 <Franciman> but i'm mostly basing my judgement on the docs
11:15:38 <sm[m]> #darcs is a good place to discuss deeper, if you didn't know
11:21:23 <typetetris> Shouldn't ` [mkPersist (sqlSettings {mpsEntityJSON = Nothing})]` prevent persistent from trying to generate `FromJSON` und `ToJSON` instances? Doesn't seem to work for me.
11:28:04 * hackage kubernetes-client 0.3.2.0 - Client library for Kubernetes  https://hackage.haskell.org/package/kubernetes-client-0.3.2.0 (axeman)
11:43:08 <ezzieyguywuf> neat, coc is pretty nice.
11:43:16 <ezzieyguywuf> but so far all the diagnostics it's giving me I also already get from ghcid
11:43:27 <ezzieyguywuf> ghcid = life
13:15:33 * hackage derive-storable-plugin 0.2.3.2 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.2.3.2 (mkloczko)
13:27:48 <shinobi_> How is the List.Sort method only defined for ordinal members?  If I have a list of Foos and Foo is not part of the Ord typeclass is the method hidden?
13:28:27 <geekosaur> it won't typecheck
13:28:40 <geekosaur> if you apply it to a list of Foos
13:28:59 <glguy> % data Foos = Foos
13:29:00 <yahb> glguy: 
13:29:09 <glguy> % :t sort ([] :: [Foos])
13:29:10 <yahb> glguy: ; <interactive>:1:1: error:; * No instance for (Ord Foos) arising from a use of `sort'; * In the expression: sort ([] :: [Foos])
13:30:18 <shinobi_> geekosaur, Understood but the implementation of the List object must state that the sort method can only be used on Ords
13:30:28 <geekosaur> :t sort
13:30:31 <lambdabot> Ord a => [a] -> [a]
13:30:41 <solonarv> the terms you're using indicate some confusion
13:30:45 <dolio> What's a list object?
13:30:46 <geekosaur> and you sound like you're thinking in terms of OO. stop now, this can only get you in trouble
13:31:16 <shinobi_> geekosaur: I'm trying :)
13:31:39 <geekosaur> anyway Ord is not intrinsic to lists, as I showed above with the type of "sort".
13:31:48 <solonarv> there is no great big complicated "implementation of the List object", there is simply   data List a = Empty | Cons a (List a)   (syntax sugar aside)
13:31:50 <merijn> shinobi_: "sort" isn't part of "the List object"
13:32:15 <merijn> shinobi_: There's no list object, just a list type and the sort function happens to accept inputs that are lists
13:32:25 <shinobi_> ok. 1st. If it's not a class then what would you call it in Haskell? 
13:32:28 <dsal> :t sort
13:32:30 <lambdabot> Ord a => [a] -> [a]
13:32:34 <shinobi_> ok
13:32:35 <dsal> It's just a function.
13:32:38 <merijn> shinobi_: A type or datatype
13:32:52 <merijn> And sort is just a function, it's not part of anything
13:33:05 <geekosaur> sort is a function that happens to make use of the Ord typeclass. lists are just a data type
13:34:01 <geekosaur> Ord is the typeclass for things that can be compared; it requires the Eq typeclass, and provides `compare` and the usual comparison operators aside from `==` and `/=` which come from Eq
13:34:23 <shinobi_> ok, so I'm still a little unclear. The list datatype defines a sort function and the typeclass defintion for that function enforces that it is only for Ords? 
13:34:45 <jle`> hm, i wouldn't say that the list datatype defines a sort function
13:34:46 <iqubic> No. The list datatype does not define a sort function.
13:34:52 <merijn> shinobi_: "the list datatype defines a sort function" <- no
13:35:02 <jle`> functions are just there...they have no owner
13:35:08 <jle`> they are 'top-level' things
13:35:09 <merijn> Functions aren't tied to types
13:35:55 <jle`> sort is a polymorphic function, meaning that you can pick what type you want to use for the 'a'
13:35:59 <jle`> kind of like head :: [a] -> a
13:36:09 <jle`> so if you pick a for Int, you get head :: [Int] -> Int
13:36:19 <jle`> if you pick Bool, you get head :: [Bool] -> Bool, etc.
13:36:31 <jle`> a typeclass constraint restricts the types you are allowed to pick for 'a'
13:36:44 <jle`> so sort :: Ord a => [a] -> [a], you could pick a is Int and get sort :: [Int] -> [Int]
13:37:03 <jle`> but you can't pick a as Foo and get sort :: [Foo] -> [Foo], if Foo doesn't have an Ord instance
13:37:47 <shinobi_> I see
13:38:15 <jle`> and you can write a function to do something similar, not attached to any data type
13:38:29 <jle`> % let myFunc x y = x * y + 3
13:38:30 <yahb> jle`: 
13:38:32 <jle`> % :t myFunc
13:38:32 <yahb> jle`: Num a => a -> a -> a
13:38:46 <jle`> myFunc is a polymorphic function so you can pick which 'a' you want to use it with
13:38:54 <jle`> i could set a to Int and get myFunc :: Int -> Int -> Int
13:39:13 <jle`> but Num a restricts the allowed 'a'; i can't, for instance, use Bool, since Bool has no Num instance
13:39:16 <jle`> % myFunc True False
13:39:17 <yahb> jle`: ; <interactive>:6:1: error:; * No instance for (Num Bool) arising from a use of `myFunc'; * In the expression: myFunc True False; In an equation for `it': it = myFunc True False
13:39:42 <jle`> maybe i used a poor choice of words in saying "for instance", heh
13:40:11 <jle`> note that it isn't true that "the num datatype defines a myFunc function"
13:40:20 <jle`> Num didn't do anything... (it's not even a datatype). i did it :)
13:44:13 <shinobi_> So would the methods that get imported with import Data.List are "top level" i.e. independent of the List datatype? 
13:45:06 <jle`> yup
13:45:43 <jle`> well, methods has a slightly different meaning in haskell that actually sort of has an interesting twist in this discussion
13:45:56 <jle`> sort is not a method, it's just a normal function here
13:46:19 <jle`> and Data.List exports functions, but no methods
13:46:49 <jle`> one of those functions being 'sort'
13:48:08 <shinobi_> Yes, I used the wrong term here. I should have said function. I've not learned about Haskell methods yet. 
13:48:20 <shinobi_> Thanks
13:48:21 <merijn> Because they don't exist :)
13:48:38 <shinobi_> scratch that off my list. :)
13:48:39 <jle`> haskell has methods, but they mean a little bit different than they do in OOP languages D:
13:48:50 <jle`> at least, the word means something different
13:48:53 <merijn> jle`: Eh, how so?
13:48:55 <jle`> definitions are weird
13:49:11 <merijn> You mean typeclasses? I've not heard those described as methods before
13:49:14 <jle`> methods things like (==), compare, show
13:49:27 <monochrom> (==) is a method of Eq. This is the wording in the Haskell Report.
13:50:03 <jle`> so there is sort of a wonky analogy between the OOP usage of method and the haskell usage
13:50:07 <monochrom> And BTW you also never saw the spelling "type class" because it is in the Haskell Report.
13:50:34 <jle`> "typeclasses" contain "methods" which have "instances" (types)
13:50:35 <merijn> monochrom: That assumes all of us have *only* read the report :p
13:50:37 <monochrom> Basically everything the Haskell Report says, no one has ever seen.
13:50:50 <merijn> oh, the reverse
13:50:55 <merijn> Reading is hard
13:50:55 <jle`> in java, "classes" contain "methods" which have "instances" ('values')
13:51:13 <jle`> but i don't think the connection is particularly useful heh
13:51:41 <monochrom> I really have no idea where "typeclass" came from, apart from one day accidentally a German made that typo and everyone thought it was official.
13:51:45 <jle`> er, the typeclasses have instances, not the methods
13:52:06 <jle`> saves invisible ink :)
13:53:06 <dsal> typoclass
13:53:52 <monochrom> Here is another one for you. The Haskell Report has wordings like "the Maybe type", "the IO type".
13:54:06 <glguy> why is that surprising?
13:54:26 <monochrom> In my mind that settles the question "since Maybe :: * -> *, not *, is it still a type?"
13:54:28 <jle`> slightly confusing because there is a distinction between 'type' and 'Type'
13:54:58 <jle`> yeah, i feel like it shooouuld be a unanimous thing in haskell that Maybe is considered a type, in the way that True is a value
13:55:01 <jle`> er, Just is a value
13:55:13 <jle`> but people still argue with me so idk
13:55:15 <monochrom> glguy, I don't know about surprising, but I swear to you a lot of people swear that it's wrong.
13:55:20 <merijn> monochrom: Was anyone disagreeing with that? Besides people who are wrong >.<
13:55:21 <jle`> ^
13:56:58 <jle`> back in the day i feel like i got in an argument about this every few weeks
14:00:02 <monochrom> Well, I guess ever since DataKinds and dependent Haskell, the liberal people have won, i.e., if something has a kind, then it is a type, oh the kind is a little funny, that's OK.
14:01:23 <monochrom> But really, before that, in the old days, the conservative people were very vocal and influential in "Maybe is a type constructor, not a type" or "a type function, not a type".
14:01:31 <merijn> monochrom: I will acknowledge the existence of TypeInType over my dead body >.<
14:01:39 <merijn> Madness, madness, I say!
14:01:55 <monochrom> Fortunately the "type constructor" camp and the "type function" camp also had much in-fighting.  That's good for the rest of us.
14:02:31 <merijn> monochrom: Well it is a type constructor, however that doesn't mean it isn't also a type. That's like saying "id" is a function, sure, but it's also a value
14:04:29 <monochrom> I have a cunning plan!  I never liked the name "Type".  What do you think of "Valuable"?  Integer :: Valuable.
14:04:55 <jle`> M.lookup monochomArgument
14:05:02 <jle`> => "What about Void?"
14:05:19 <jle`> * M.lookup monochromArgument pedanticNonsense
14:05:59 <monochrom> We accept bottom as a value. That covers Void. The thing is non-Type types don't even have bottom.
14:06:08 <jle`> to be clear the idea is that "What about Void" is the pedantic nonsense in response to your valid idea :)
14:06:33 <jle`> ah yeah, haskell's bottom
14:07:09 <jle`> how about type * = FullySaturatedTypeConstructor
14:07:18 <dolio> How about: who gives a shit?
14:07:45 <jle`> clearly it is our favorite thing to be talking about on a friday night :)
14:27:55 <texasmynsted> I am sure I used an online repl for haskell where I could turn on vim key bindings. Can't find it.
14:28:50 <texasmynsted> anybody recall this?
14:28:55 <monochrom> repl.it
14:29:14 <monochrom> I don't know about vim key bindings.
14:30:10 <Guest41303> what's the syntax for binary literals? ghci is giving me an error on 0b10
14:32:00 <monochrom> You need to turn on the relevant extension.
14:32:09 <monochrom> It's all in the GHC user's guide. What does it say?
14:33:03 <timCF> Hello guys! Can anybody help me with small example of Haskell code? https://gist.github.com/tim2CF/221616992d89d9ef458df8080bfa4a28
14:35:44 <monochrom> timCF, my advice is don't bother constraining b, at least for now.
14:35:56 <monochrom> Premature design constraint or something.
14:36:37 <monochrom> After you have fleshed out some actual operations on Money, then maybe it will become clear how much you need to constrain b, and by what mechanism.
14:37:28 <monochrom> If you only have a type, no operations, basically the type is meaningless.  The real meaning is always in the functions that operate on that type.  Programmers keep forgetting this.
14:38:38 <timCF> monochrom: Well, it's just simple example :) In real life these types are implementing a bunch of classes
14:40:01 <timCF> I just simplified it to understand is it possible in principle to do such type constraints - not just `b` but only some of given types
14:42:18 <monochrom> I'll tell you a story. In this story, I was on the receiving end of the advice I give you today.
14:43:04 <monochrom> I had a function, I only intended to allow the user to use it on Integer, it's f :: Integer -> [Integer], f x = [x, x, x].  Or something like that.
14:43:30 <monochrom> An expert saw that and pointed out why not a -> [a].
14:43:52 <monochrom> I replied I wanted to restrict its use case, the user should only use it on Integer.
14:44:03 <monochrom> The expert pointed out a greater lesson.
14:44:47 <monochrom> The type a->[a] gives the user a much stronger assurance than the type Integer->[Integer].  Equivalently and flipsidely, it gives me much fewer room for bugs.
14:45:21 <monochrom> If my intention is "I turn one number ot a list of numbers, but all those numbers are the same, in fact the same as the input number"
14:45:45 <monochrom> a->[a] assures that. Integer->[Integer] doesn't.
14:46:08 <monochrom> By leaving b unconstrained, you may actually be doing yourself and your users a great service.
14:47:08 <hpc> for optimally bug-free code, use the type signature a -> b
14:47:16 <monochrom> haha
14:47:34 <monochrom> that probably is also liveness-free
14:47:52 <timCF> input -> output
14:48:14 <timCF> but thanks for advice
14:48:30 <texasmynsted> hmm maybe not repl.it unless I get different results if I create an account
14:49:31 <monochrom> ah, maybe code world?
14:49:51 <monochrom> nah, code world uses its own language, not exactly Haskell
14:49:54 <texasmynsted> Is there a nice tutorial for converting String based code to Text? Example: https://gist.github.com/mmynsted/7831dbd552c1f874143c0e0d5807a4c8
14:50:47 <monochrom> No. It's just conceptually easy, time consuming chore. E.g., change "take" to "T.take"
14:51:04 <texasmynsted> I did and ... splode with errors
14:51:24 <hpc> easy, just fix the errors :D
14:51:51 <sm[m]> texasmynsted: change one small piece at a time
14:52:28 <sm[m]> sprinkle T.[un]pack as needed
14:52:33 <hpc> usuallly that means you've just missed some places
14:53:03 * hackage postgresql-tx 0.2.0.0 - A safe transaction monad for use with various PostgreSQL Haskell libraries.  https://hackage.haskell.org/package/postgresql-tx-0.2.0.0 (carymrobbins)
14:54:08 <monochrom> OK, I misread, you have [Text], you're doing take on that, that's still []'s take.
14:54:30 <monochrom> This one you're just missing Data.Text.IO.putStrLn
14:54:34 * hackage postgresql-tx-monad-logger 0.2.0.0 - postgresql-tx interfacing for use with monad-logger.  https://hackage.haskell.org/package/postgresql-tx-monad-logger-0.2.0.0 (carymrobbins)
14:55:20 <monochrom> Oh, and f::Int->Text
14:57:22 <monochrom> left my comment (really code) on that.
14:58:23 <monochrom> Doesn't my avatar look monochrome? :)
14:58:29 <texasmynsted> okay
14:59:05 <texasmynsted> I really did miss a bunch of stuff by not just fixing one thing at a time
14:59:40 <texasmynsted> I did not see the fact that I should be using the take from list. I think that will help
15:00:34 <texasmynsted> Pulling the x and y from the where makes it easier for me to see the actual types because I can have a full type sig
15:07:57 <texasmynsted> oh treblacy, sorry I did not see your comment in there
15:11:00 <texasmynsted> :-) Okay thank you all. 
15:13:58 <texasmynsted> oh yeah monochrom, I did not know that was you
15:14:11 <texasmynsted> yes, nice avatar
15:19:32 <texasmynsted> snap, now here are more books I need/want to read http://www.vex.net/~trebla/weblog/fpbooks.xhtml
15:19:46 <monochrom> haha
15:21:52 <texasmynsted> Oooh. The Algebra of Programming. That one is near unobtainable 
15:23:57 <Rembane> Is that Knuth's?
15:24:17 <monochrom> Richard Bird and Oege de Moor
15:25:25 <Rembane> Thank you 
15:33:12 <dsal> I found last night that Text is not Foldable and that made me a little sad.
15:35:40 <texasmynsted> it is not? Is it because of unicode or something?
15:36:32 <texasmynsted> The Algebra of Programming needs to be re-printed so I can get a copy. Heh
15:37:47 <texasmynsted> I could try ILL (Inter-library-loan) but most often when I do that I find that I really really want the book. Hehe
15:42:03 <Guest41303> is there any reason why elem is conventionally used as infix?
15:42:45 <Guest41303> to the point of hlint even suggesting it
15:45:41 <dolio> x ‚àà X
15:47:01 <Guest41303> fair
15:53:26 <glguy> > 0 `elem` 1 : 2 : 3 : []
15:53:29 <lambdabot>  False
15:54:34 <monochrom> texasmynsted: Text is not Foldable because it is not a polymorphic type like [] and Vector. But there is a monofoldable library for these cases.
15:56:05 <texasmynsted> oh that makes sense
15:56:49 <shinobi_> If you are creating submodules and are using common helper functions that are not going to be exported, where do you put them? In a separate "common" submodule? A parent module? 
15:57:32 <dsal> If they're not exported, you put them where you need them.
15:57:40 <sm[m]> I tend to make a Common module in the same directory
16:32:00 <texasmynsted> I see this --> https://hackage.haskell.org/package/fix-imports 
16:33:05 <texasmynsted> Is this the best way to fix my imports?
16:33:40 <texasmynsted> second best ... best being manually
16:56:21 <MarcelineVQ> what's broken about them?
16:57:01 <ezzieyguywuf> glguy: is there a way to change the order that specs show up in `generateDocs`?
16:57:55 <glguy> Umm...
16:59:08 <glguy> Looks like it's just alphabetical now. Better ideas?
16:59:32 <ezzieyguywuf> I think it'd make better sense to go in hierarchical order
16:59:33 <glguy> alphabetical for named things, order of appearance for individual things 
16:59:59 <ezzieyguywuf> ah, yea I think order of appearance across-the-board makes more sense, b/c otherwise the documention is a bit confusing
17:00:03 <ezzieyguywuf> here let me share one h/o.
17:01:05 <ephemient> what's the current "alphabetical"? I convinced hspec to sort by "natural" instead of "lexicographic" a while back https://github.com/hspec/hspec/pull/337
17:01:43 <ezzieyguywuf> glguy: https://dpaste.com/2BW5GXBSX so here, since there's no preamble to the docs or anything, I start reading at "Top-Level" and get to "REQUIRED Input-File-Columns" and I'm left wondering "what is that?!", and then I get to "Amount-Column" and start to get lost
17:01:55 <ezzieyguywuf> I know it's a little thing, but for a less tech-savvy user this could be quite confusing.
17:02:26 <glguy> I'm quite open to improvements here; I just didn't know what to do
17:03:40 <ezzieyguywuf> ephemient: hey I use hspec! it's always sorted in the order I define specs, you're saying this change is recent?
17:04:04 <ezzieyguywuf> glguy: üëçÔ∏è, I'll take a look at the code, see if I can muster up a pr
17:04:29 <ephemient> no, my change just affects hspec-discover order... if you define your specs yourself, then it's in that order
17:04:51 <glguy> ezzieyguywuf: PRs are fantastic, but even sketches of what you think would look nicer are useful
17:05:07 <ezzieyguywuf> ah hah. wait I think I use hspec-discover too, but it's only ever had to discover a single file lol.
17:05:58 <ezzieyguywuf> i wonder why they didn't want the dependency on `text`. `parsec` I kind of get..
17:06:52 <ezzieyguywuf> wow what a great pr, and code review, and eventual merge!
17:08:19 <glguy> ezzieyguywuf: Also there doesn't have to be the one-true-documentation-generator. It could make sense for a module to generate Markdown or HTML or something else entirely
17:08:52 <glguy> And the data types are exposed if you want to experiment with consuming the specs in different ways
17:17:20 <doct0rhu> `ghci` loads `./.ghci` before` `$HOME/.ghci`, which seems strange to me
17:18:22 <doct0rhu> usually per-directory/project configs overrides per-user configs
17:20:07 <doct0rhu> specifically, users may want to `:def` some variations of commands that uses a per-directory arguments
17:20:52 <doct0rhu> but they have to use a different name or otherwise that'd be overridden by the same named one in `$HOME/.ghci`
17:34:12 <Sayless> What's everyone working on?
17:38:30 <dsal> adventofcode, though I kind of need to build a thing that lets me upload to S3 the same way my GoPro thing does.
17:41:28 <solonarv> I've also been doing AoC, besides uni stuff (which isn't haskell but does involve some programming)
17:44:30 <Sayless> that's interesting! I've been doing some stuff on leetcode. This could be a nice change
17:46:30 <dsal> I've written a lot of Haskell I rely on this year.  But it's puzzle season.
17:48:33 <Sayless> I never heard about AoC before! Looks cool. I've been torn between scala and haskell this year as my hobby language
17:49:31 <dsal> Well, there's likely bias here, but I use haskell for everything except when I can't.
17:50:58 <Sayless> I love reading about Haskell and reading its code. It was my first preference. The one thing i've found as a barrier of entry is libraries and documentation surrounding them as a newcomer
17:54:12 <Sayless> I definitely prefer it between the two. I have found it easier to port something out of Java and use it in Scala however. Maybe I'll just become more fluent with libs and packages in Haskell over time
17:59:22 <dsal> Yeah, to be fair, I find documentation for new languages hard to read in general.  Part of haskell's problem there is so much is common.
18:00:03 <dsal> So if I give you a data structure and tell you it's foldable, applicative, traversable, etc... you know a *lot* about what you can do with it without me having to say what all those things are.
18:03:07 <nfd9001> Hey, I'm trying to learn megaparsec for AoC day 4 and don't want to look at y'alls full spoilers yet; I'm trying to use Control.Applicative.Permutations and I think it looks nice to try to use a do-style for name binding (despite that all I really need is Alternative power)
18:03:48 <dsal> You can use do if you want, but there's no do in my day4.
18:04:39 <nfd9001> So I have something like passportParser = runPermutation $ do byc <- toPermutationWithDefault Nothing (...); ...; pure (P byc...)
18:04:44 <c_wraith> I used do a lot in my validation code without even touching parsers
18:05:15 <nfd9001> i mean, i know i can do this without fancy parser combinators, but it seemed like a nice opportunity to learn them
18:05:47 <dsal> Sure, half the reason for solving the puzzles is learning new things.  :)
18:07:19 <iqubic> I learned about refinement types today. Why bother validating stuff when you can have the types/another library do it for you.
18:07:58 <nfd9001> anybody familiar with a way i can use those tools with that kind of idiom? there's not a ton of tutorials on using just parser-combinators/megaparsec's Control.Applicative.Permutations or anything
18:09:29 <nfd9001> i clearly have some simple type confusion going on here that I can brain out/share but I figured somebody might've written something on this I hadn't seen
18:12:36 <nfd9001> it seems like this do block inferred that it was supposed to be in the Maybe monad, so i assume flipping on ApplicativeDo is probably part of this
18:17:48 <ephemient> I've done some crazy things with megaparsec - looking back at aoc2019d25, I fed input back into the parser while it is running. I don't know what I was thinking :)
18:20:02 <nfd9001> hey, it's not "crazy" if it's "art"
18:20:30 <ephemient> in any case, hart to tell from your description, but it does sound like you've just mixed up some types somewhere. have any code to share?
18:27:03 <nfd9001> yeah, i just mixed up where i was trying to inject a (\x -> Just x) into my equation
18:27:20 <nfd9001> foolishly joined IRC on a different box than the one i'm typing this on so sec
18:29:38 <nfd9001> with ``let tPDN = toPermutationWithDefault Nothing`` i was doing stuff with the pattern ``val <- tPDN $ (\x -> Just x) <$> lexeme $ string "val:" *> someParser``
18:30:22 <nfd9001> i wanted ``val <- tPDN $ lexeme $ string "val:" *> pure (\x -> Just x) <*> someParser``
18:33:24 <ephemient> pure Just <*> someParser === Just <$> someParser
18:33:25 <nfd9001> my errors were a little confusing at first because these Permutations are only Alternative m => Applicative (Permutation m)
18:33:48 <solonarv> also, (\x -> Just x) = Just
18:33:48 <nfd9001> and i had ApplicativeDo off
18:34:18 <crestfallen> hi real quick is isSpace :: Char -> BoolSource#
18:34:24 <nfd9001> tyty, i'd tried using the constructor without that once and ran into some issue, but i was probably just doing something wrong elsewhere
18:34:40 <crestfallen> Returns True for any Unicode space character
18:34:44 <crestfallen> sorry ..
18:35:14 <crestfallen> is any unicode space char also alphaNumeric?
18:35:25 <solonarv> no, alphanumeric means "letter or digit"
18:35:28 <nfd9001> crestfallen: in what library? but I'd expect it's Char -> Bool for most libs
18:35:29 <nfd9001> or similar
18:35:41 <solonarv> (it's in base, Data.Char to be specific)
18:35:48 <monochrom> The "Source#" is an artifact of copy-paste error
18:36:02 <nfd9001> Data.Char.isSpace is Char -> Bool yes
18:36:16 <ephemient> crestfallen: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt has a list of all characters for each unicode property
18:36:30 <monochrom> Since there is also isAlphaNum, you could have done a few little tests yourself.
18:36:32 <crestfallen> I have a function alphanum :: Parser Char                                                               69 alphanum = satisfy isAlphaNum
18:36:38 <crestfallen> shit
18:37:27 <crestfallen> I have a function alphanum = satisfy isAlphaNum and to my surprise it accepts spaces in the middle of a string
18:37:55 <ephemient> there's Text.Megaparsec.Char.alphaNumChar :: Parsec e Char (more or less)
18:38:11 <monochrom> You can easily test your hypothesis with  isAlphaNum ' '
18:38:15 <solonarv> yes, which parser library are you using?
18:38:37 <monochrom> In fact, s/test/refute/
18:38:46 <crestfallen> thanks monochrom et al. let me paste: http://ix.io/2GFv
18:38:57 <solonarv> also, that. don't be afraid to jump into ghci and test things by hand!
18:39:08 <monochrom> Well there goes the Socratic method.
18:39:44 <crestfallen> in question in the function "identifier"
18:44:20 <crestfallen> . Œª> parse alphanum " "
18:44:23 <crestfallen> []
18:45:34 <ephemient> > [c | c <- ['\0'..'\xffff'], isAlphaNum c && isSpace c]
18:45:37 <lambdabot>  ""
18:45:39 <monochrom> And you think that's a bug because...?
18:46:01 <crestfallen> Œª> parse alphanum "ll mm"
18:46:28 <crestfallen> [('l',"l mm")]
18:46:46 <solonarv> I still don't see a bug here, that seems correct
18:46:51 <crestfallen> thanks just sorting it out. not saying its a bug
18:47:30 <ephemient> "I have a function alphanum = satisfy isAlphaNum and to my surprise it accepts spaces in the middle of a string" what is an example of that
18:48:36 <MarcelineVQ> crestfallen: only 'l' was parsed there, "l mm" is the unparsed remainder
18:49:06 <ephemient> ... yes, because satisfy is defined to take only one token
18:49:11 <crestfallen> MarcelineVQ: thanks that's what I overlooked
18:49:38 <crestfallen> so the remainder never makes it to the predicate
18:51:42 <MarcelineVQ> satisfy parses at most a single Char as ephemient is suggesting
18:53:25 <crestfallen> yeah understood thanks MarcelineVQ ephemient solonarv et al
18:57:51 <ezzieyguywuf> I don't understand this error: https://dpaste.com/4VUP2WU2A
18:58:09 <ezzieyguywuf> The "expected" and "got" seem to match
18:59:54 <MarcelineVQ> probably  Text.Megaparsec.Stream.Token Text   is an associated type that resolves to Char
18:59:59 <ephemient> Text and (Text.Megaparsec.Stream.Token Text) don't seem to match
19:00:42 <ezzieyguywuf> ahhh
19:00:56 <ezzieyguywuf> so `Text.singleton <$> letterChar` fixes it
19:01:18 <crestfallen> so my book prefers do blocks while dealing with parsers. is that the norm generally?
19:01:26 <ephemient> if you're expecting nLetter :: Text, then yes
19:01:29 <ezzieyguywuf> but since the type of `letterChar` is `m (Token s)`, I didn't think I'd have to explicitly make it a Text
19:01:51 <ezzieyguywuf> yea, nLetter :: Text is expected
19:02:18 <crestfallen> since members have suggested I work with (>>=) if I can..
19:03:52 <ephemient> it's equivalent (except under extensions like ApplicativeDo)
19:04:01 <MarcelineVQ> They suggested that just because you didn't understand >>= or do, not because it's generally preferred
19:04:42 <ephemient> if you're still figuring things out, I would suggest >>= until you understand
19:07:54 <crestfallen> I roughly understand the State Monad, so MarcelineVQ and everyone thanks a lot, it took my months but I'm comfortable generally
19:08:04 <crestfallen> me*
19:08:27 <crestfallen> thanks yeah ephemient I prefer it somehow
19:13:48 <nfd9001> alright i'm still missing something probably really silly here; i'd appreciate if someone would give this a quick spotcheck: https://hastebin.com/homawuhele.hs
19:14:05 <nfd9001> compile errors and source incl. there
19:15:33 <nfd9001> (yeah, i shouldn't do so much prepro before megaparsec probably, but one thing at a time here)
19:16:47 <solonarv> nfd9001: can you link where this   permutations   thing is from?
19:17:26 <nfd9001> parser-combinators, Control.Applicative.Permutations
19:17:36 <nfd9001> apparently used to be part of megaparsec prior to megaparsec 7
19:24:18 <boxscape> I said earlier today that I wanted to use `compare `on` fst` to compare (String, Int) with (String, String) - turns out with ImpredicativeTypes you can actually define a function `on :: (b -> b -> c) -> (forall z . f a z -> b) -> f a d -> f a e -> c` which can do this, so that's nice
19:28:42 <boxscape> (though of course there are situations where Data.Function.on works and this wouldn't, at least not without unsaturated tyfams
19:28:44 <boxscape> )
19:33:14 <MarcelineVQ> RankNTypes is enough for that
19:33:54 <boxscape> hm GHC told me it doesn't support impredicative types when I didn't enable it MarcelineVQ
19:34:18 <boxscape> actually wait
19:34:51 <nfd9001> impredicative sometimes causes weirder annotation requirements, yeah?
19:34:57 <boxscape> MarcelineVQ fair enough, it was because the function body was `undefined`
19:38:43 <nfd9001> love undefined. it's so polymorphic
19:38:55 <boxscape> it sure is
19:39:36 <boxscape> % :t +v undefined
19:39:36 <yahb> boxscape: forall (r :: RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
19:40:38 <solonarv> oh, it's representation-polymorphic? I was unaware of this!
19:42:11 <boxscape> % const () $ I# undefined
19:42:11 <yahb> boxscape: ()
19:42:15 <boxscape> yeah
19:45:37 <boxscape> perhaps somewhat confusingly, that also means that something like `undefined @Int` doesn't work
19:45:50 <crestfallen> sorry I said something in error earlier: the first space would reach the predicate and fail, and would end up in the unused section of the string. 
19:58:05 <ezzieyguywuf> hooray, I finished days 1 and 2 of AoC today!
19:58:13 <jle`> ezzieyguywuf: congrats :D
19:58:22 <jle`> just in time for the puzzle today :)
20:01:36 <ezzieyguywuf> jle`: lol thanks.
20:01:48 <ezzieyguywuf> nah, I still need to do days 3 and 4 lol
20:01:53 <ezzieyguywuf> I want to do them in order *shrug*
20:02:25 <boxscape> yeah the plot would be pretty confusing otherwise
20:13:26 <dsal> I only do AoC for the articles.
20:13:52 <ezzieyguywuf> a lot of recurssion in this AoC thingy
20:13:57 <ezzieyguywuf> well suited to haskell lol
20:14:03 <dsal> Which one?
20:21:03 <dsal> I've not done anything I'd call recursive in AoC so far this year.  I guess you could call `fold` recursive, but that's more of an implementation detail.
20:22:06 <ezzieyguywuf> guess I'm not so fancy
20:22:30 <ezzieyguywuf> but I'm not trying to be elegant about it at all
20:22:34 <ezzieyguywuf> just hitting it with a huge hammer
20:24:41 <dsal> Heh, I do some of that.  My day 1 was just a list comprehension.
20:25:44 <dsal> My day 2 is basically `count . filter`
20:29:06 <ezzieyguywuf> :b4
20:29:09 <ezzieyguywuf> lol whoops
20:30:07 <MarcelineVQ> yussa beshep
20:50:30 <ephemient> @tell nfd9001 your problem appears to be operator precedence, *> and <$> are both infixl 4. try instead: string "byr:" *> (Just <$> L.decimal) etc.
20:50:30 <lambdabot> Consider it noted.
21:10:40 <ezzieyguywuf> dang, couldn't get that 3rd one done today
21:12:03 <MarcelineVQ> there's still time, if you keep flying left then today never ends
21:17:23 <ezzieyguywuf> lol
21:17:23 <monochrom> Indeed, consider the first Christopher Reeve Superman movie. :)
21:18:18 <dolio> You need to be really fast to do that.
21:18:29 <dolio> Like, on the Concorde.
21:18:40 <MarcelineVQ> no you just need to yell loud enough
21:19:16 <MarcelineVQ> the speed thing is a, red, herring
21:19:56 <monochrom> Aww, none of you young ones know that Superman movie.
21:20:34 <MarcelineVQ> The one where he doesn't yell while turning back time
21:20:43 <monochrom> heh OK
21:21:09 <MarcelineVQ> Well I guess he has a chance to calm down first, in my mind he's screaming the whole time
21:21:36 <Lycurgus> unubermenschlich
21:21:53 <Lycurgus> (i.e. shouting)
21:22:09 <Lycurgus> also funny there's a galactic year but no galactic day
21:23:26 <monochrom> OK, Dune is the one that weaponizes screaming. :)
21:23:43 <Lycurgus> ah,  the voice aint screamin
21:23:48 <Lycurgus> the opposite in fact
21:24:25 <dolio> I think they meant the movie.
21:24:26 <MarcelineVQ> moad'ib's a hellova dug
21:24:32 <dolio> Where you kill people by yelling into a megaphone.
21:24:44 <Lycurgus> more like bucks dog whistles
21:24:46 <dolio> Yelling gun.
21:25:10 <Lycurgus> from which the libral press make so many hard inferences
21:25:41 <MarcelineVQ> dune weaponizes patrick stewart in a rubber suit
21:25:51 <monochrom> :)
21:26:34 <dolio> Because David Lynch thought yelling guns were less dumb than martial arts.
21:26:55 <Lycurgus> also the wierding modules used sound but it wasn't a or the voice
21:27:14 <Lycurgus> using them the fremen did sorta shout
21:30:32 <Lycurgus> also lynch, the drehbuch only used herberts elements
21:31:59 <boxscape> @pl \map -> bimap (map (== 'B')) (map (== 'R'))
21:31:59 <lambdabot> liftM2 bimap ($ ('B' ==)) ($ ('R' ==))
21:32:05 <boxscape> hm maybe not
21:33:06 <MarcelineVQ> where did map go
21:33:36 <boxscape> into the pointless aether
21:36:27 <MarcelineVQ> Oh, it does check out, I put on strong glasses and lost my marbles in neverland for a moment
21:36:58 <MarcelineVQ> I wonnder how obscure that reference is
22:23:07 <boxscape> is there a class for contravariant bifunctors?
22:23:36 <boxscape> I suppose optics-core hass Bicontravariant
22:28:31 <koz_> How can one be contravariant in _both_ parameters?
22:28:38 <koz_> Are there any natural examples?
22:34:56 <boxscape> koz_ (a -> b -> c) is contravariant an a and b
22:35:52 <koz_> So that'd be equivalent to like 'newtype Op2 c a b = Op2 (a -> b -> c)' by the same logic as contravariant's Op I guess.
22:35:52 <boxscape> I suppose so is (Either a b -> c), for example
22:36:03 <boxscape> yeah
22:36:09 <koz_> Either a b -> c is an interesting example as well.
22:38:06 <koz_> a -> b -> c is actually isomorphic to (a, b) -> c.
22:38:13 <boxscape> right
22:38:22 <koz_> So you have 'function with sum argument' and 'function with product argument' as the two natural examples.
22:39:47 <boxscape> more generally if p is a Bifunctor, p a b -> c will be contravariant in a and b
22:39:49 <boxscape> I think
22:40:31 <koz_> I'm not sure that works - how would you derive bicontramap?
22:40:41 <boxscape> hm let me try
22:44:43 <boxscape> koz_ https://paste.tomsmeding.com/l1ydTX0M
22:45:26 <koz_> Oh, clever.
22:45:37 <boxscape> no, just following the typed holes :)
22:45:47 <koz_> That alone gets you surprisingly far in Haskell.
22:45:51 <boxscape> yeah
22:47:44 <koz_> Is there a Bidivisible and Bidecidable too?
22:48:16 <boxscape> hm good question
22:54:15 <koz_> Also, what does optics-core use Bicontravariant to define?
22:56:54 <koz_> Ah, Forget and IxForget.
