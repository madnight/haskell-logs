00:23:36 <boxscape> hm It seems strange to me that an ifThenElse function wasn't added to Prelude when RebindableSyntax was introduced
00:29:45 <dminuoso> Is something like boolean blindness addressable in Haskell at all, or is most of that just a hint at "Agda is better for guaranteesing correctness"?
00:30:11 <dminuoso> Because it seems to be constructive proofs for everything, say equality between two things, seems rather difficult on the value level.
00:32:20 <int-e> well, use a different one
00:35:46 <dminuoso> Such as?
00:38:32 <int-e> sorry, that was meant for another channel
00:39:18 <idnar> dminuoso: you can replace the boolean with a sum type
00:40:22 <idnar> (that witnesses whatever the condition is)
00:48:57 <dminuoso> idnar: But doesn't that bring you back to the original problem that you don't even know what the sum type witnesses because you dont know how it was constructed?
00:49:06 <dminuoso> I mean that is precisely the problem behind Bool in the first place.
00:49:57 <cheater> hi. building llvm-hs 9.0.1 fails on windows because you can't have LLVM-9.dll on windows (too many exports for the windows dll format) and during building llvm-hs 9.0.1, it calls llvm-config with --link-shared which tries to link things against LLVM-9.dll which does not exist. how can i prevent llvm-hs from doing --link-shared?
00:50:14 <dminuoso> Let's take the case of equality between two nodes in a tree. How could you encode their equality constructively in a sum type?
00:50:35 <dminuoso> It almost seems as if you need a different meta language to even talk about it (like how the value level supplies proof for type level programming)
00:51:36 <idnar> dminuoso: maybe `data Pair a = Same a | Different a a` ?
00:51:47 <[exa]> cheater: this is not constructive but the easiest solution seems to omit windows from the pipeline, if you can
00:51:57 <cheater> it is not
00:52:14 <dminuoso> idnar: For representational equality that works I guess.
00:52:30 <dminuoso> Though, here again, `Different a a` is not proof they are different.
00:52:42 <[exa]> cheater: otherwise try to build everything with -static and grep the llvm-hs code for any place where the --link-shared originates
00:53:09 <dminuoso> But to be fair, I asked for proof of equality not proof of inequality.
00:53:57 <cheater> hmm yeah
00:54:37 <idnar> dminuoso: yeah, I guess a "100%" solution is tricky
00:54:45 <[exa]> cheater: you might want to undo this default https://github.com/llvm-hs/llvm-hs/pull/39
00:55:19 <cheater> linkFlag = case lookupFlagAssignment (mkFlagName "shared-llvm") flags of                       Nothing     -> "--link-shared"                       Just shared -> if shared then "--link-shared" else "--link-static"
00:55:32 <cheater> how would i set this flag? that's from Setup.hs
00:55:54 <[exa]> cheater: please consider pastebin for larger pieces of code :]
00:56:31 <[exa]> anyway you should be able to set the -f flags with cabal
00:58:16 <boxscape> dminuoso it might be annoying with the current state of dependent types in Haskell but it's certainly *possible* to have `data Dec a = Yes a | No (a -> Void)` and then use `Dec (a :~: b)` in your types
00:58:45 <cheater> yes, not sure how. cabal configure -fshared-llvm=False doesn't work, cabal errors out with "invalid flag assignment: shared-llvm=False"
01:00:23 <[exa]> can the flags be negated this way?
01:00:49 <cheater> i think the correct syntax is  cabal <command> --constraint='llvm-hs -shared-llvm'
01:00:58 <cheater> where - means disabling as opposed to +
01:01:51 <[exa]> o here https://cabal.readthedocs.io/en/3.4/cabal-project.html#cfg-field-flags
01:02:04 <dminuoso> boxscape: Sure, but again that's on the wrong level. Nothing prevents me from building `Yes (Refl 1 2)`
01:02:13 <boxscape> dminuoso yes, the typechecker does
01:02:18 <boxscape> or do you mean
01:02:24 <boxscape> well no
01:02:28 <boxscape> the typechecker does
01:02:47 <dminuoso> % data Dec a = Yes a | No (a -> Void)
01:02:47 <yahb> dminuoso: 
01:02:50 <[exa]> cheater: so perhaps -f-shared-llvm  (or -fno-shared-llvm)
01:03:01 <dminuoso> % :t Yes (Refl 'a' 'b')
01:03:02 <yahb> dminuoso: ; <interactive>:1:6: error:; * Couldn't match expected type `Char -> Char -> a' with actual type `a0 :~: a0'; * The function `Refl' is applied to two arguments,; but its type `a0 :~: a0' has none; In the first argument of `Yes', namely `(Refl 'a' 'b')'; In the expression: Yes (Refl 'a' 'b')
01:03:08 <dminuoso> Oh wait
01:03:10 <boxscape> dminuoso it has to be (Refl :: 1 :~: 2)
01:03:32 <cheater> [exa]: oh, i'll try that
01:03:35 <dminuoso> boxscape: Ah yeah my brain was on a pause for a second.
01:03:49 <dminuoso> boxscape: So to have a constructive proof, I need to lift the values to the type level.
01:03:55 <cheater> thanks!
01:03:56 <boxscape> right
01:04:17 <[exa]> cheater: so in llvm-hs, you'd do `cabal install -f-shared-llvm`, in a reverse dependency you'd use the --constraint= syntax
01:04:37 <[exa]> so your first version was right it seems, cool
01:05:28 <cheater> ok, well, llvm-hs's Setup.hs fails with fromJust: Nothing
01:05:43 <cheater> i have no idea why, the code doesn't look like it should be getting a Nothing??
01:05:56 <cheater>       let getLibs = liftM (map (fromJust . stripPrefix "-l") . words) . llvmConfig
01:06:54 <[exa]> can you get the value of llvmConfig?
01:08:05 <cheater> i think that's not it
01:08:13 <cheater> i think they're looking for libs in the form of -lfoo -lbar
01:08:27 <cheater> and then they encounter -f-shared-llvm
01:08:54 <cheater> so the code is just plain wrong, because it expects every flag to start with -l
01:09:02 <cheater> let me try to see what's inside llvmConfig though, you're right
01:10:44 <cheater> wait, what was the way to make cabal load a package from my own dir on my disk, rather than from hackage? i forgot
01:11:16 <cheater> ah, found it
01:11:38 <dminuoso> Is there a way to detect whether or not a pragma is disabled in TH?
01:12:46 <dminuoso> A language pragma, I mean
01:13:39 <Taneb> dminuoso: there's "isExtEnabled :: Extension -> Q Bool"
01:14:34 <cheater> looks like it's just packages: ../llvm-hs-9.0.1 inside cabal.project.local, right?
01:15:26 <[exa]> cheater: I'm usually just moving the package to a subdirectory (not sure if that's needed) and add just cabal install the subpath
01:15:33 <[exa]> cabal.project helps too
01:15:36 <dminuoso> Taneb: That's perfect, cheers! I kept searching for "pragma" and "language" to no avail, that helped.
01:15:49 <cheater> [exa]: hmm, that wasn't how i usually did that. i'm kinda lost.
01:16:13 <[exa]> cheater: not even sure if these 2 do the same thing or one is deprecated, hopefully some cabal guru will show up... :D )
01:17:07 <[exa]> cheater: in one project's cabal.project I have: `packages:  \n  ./somepackage/*.cabal`
01:17:15 <cheater> right
01:17:33 <[exa]> also ./*.cabal in your case, for consistency
01:20:42 <Taneb> dminuoso: I guess "pragma" would be incorrect because you can set them as GHC flags or cabal options too
01:21:38 <cheater> yeah i think that's correct exa
01:23:29 <boxscape> "LANGUAGE pragma" is the name of the {-# LANGUAGE a, b, c #-} construct that allows you to enable extensions a, b, c
01:28:16 <cheater> anyone on linux here? what sort of output do you get from llvm-config --libs --link-shared ?
01:28:40 <cheater> [exa] you're on linux, right? :)
01:29:40 <[exa]> yeah
01:29:57 <[exa]> anyway I get: -lLLVM-9
01:30:30 <cheater> that's all?
01:30:35 <[exa]> yeah. from --link--static there's a list of like ~150 libraries
01:30:53 <cheater> what do the first few look like?
01:31:39 <[exa]> https://pastebin.com/B7Ji2rUs
01:31:59 <cheater> thanks
01:38:01 <boxscape> hmm which would you prefer, `catMaybes . fmap join` or catMaybes . catMaybes`
01:39:15 <Taneb> boxscape: slight preference for the first one
01:39:22 <boxscape> okay
01:40:50 <merijn> Courtesy of Facebook just reminding me of stumbling on this quote years ago:
01:40:53 <merijn> @quote farpotshket
01:40:53 <lambdabot> andr00 says: Today's software engineering word is "farpotshket." This is a Yiddish word meaning, "broken, because someone tried to fix it."
01:50:17 <tdammers> yiddish has a knack for having words for concepts that don't exist in other languages
01:50:46 <boxscape> hm I can't find the etymology on farpotshket
01:54:08 <boxscape> ah patchken is from Russian
01:54:35 <merijn> tdammers: I didn't realise how much lasting legacy Yiddish and Bargoens had in Amsterdam until I went to university and ran into a bunch of people unfamiliar with words I considered "basic Dutch" :p
02:01:39 <lortabac> I'm getting a weird error: No instance for (Functor ((,,) Int Text))
02:01:53 <lortabac> does anybody know what might be happening?
02:02:14 <opqdonut> you're trying to fmap over a triple?
02:02:18 <lortabac> yes
02:02:25 <opqdonut> well there is no such functor instance :)
02:02:38 <opqdonut> only for tuples
02:02:47 <opqdonut> I mean 2-tuples, pairs
02:03:03 <opqdonut> > fmap succ ("foo",2)
02:03:05 <lambdabot>  ("foo",3)
02:03:06 <boxscape> you could do Functor ((,) (Int, Text)) maybe
02:03:15 <opqdonut> > fmap succ (4,"foo",2)
02:03:17 <lambdabot>  (4,"foo",3)
02:03:21 <boxscape> hmm
02:03:22 <lortabac> I see it in Haddock
02:03:23 <opqdonut> oh wow that instance is on lambdabot
02:03:23 <tdammers> merijn: de mazzel he
02:04:00 <boxscape> yeah the instance does appear to be in Prelude
02:04:01 <Taneb> lortabac: which version of GHC are you using?
02:04:01 <opqdonut> the triple instance is only "Since: 4.14.0.0
02:04:06 <opqdonut> so very new
02:04:23 <opqdonut> 8.10
02:04:27 <opqdonut> GHC 8.10 that is
02:04:55 <lortabac> oh ok that explains the mystery
02:05:00 <boxscape> I wonder how they decided to stop at (,,,)
02:07:03 <maerwald> flipped a coin
02:07:20 <opqdonut> or a d6?
02:07:32 <maerwald> d20
02:07:32 <lambdabot> maerwald: 3
02:07:39 <maerwald> wat
02:07:45 <boxscape> 4d20
02:07:45 <lambdabot> boxscape: 60
02:07:46 <opqdonut> ha
02:08:15 <boxscape> strange to have a command that's not prefixed by > or @ or :
02:08:24 <Uniaika> fmap succ ("foo", "bar", "barf", 2)
02:08:30 <Uniaika> > fmap succ ("foo", "bar", "barf", 2)
02:08:32 <lambdabot>  ("foo","bar","barf",3)
02:09:05 <Uniaika> < boxscape> I wonder how they decided to stop at (,,,) // Nobody went to the maintainers to ask for a larger instance :)
02:09:14 <boxscape> I suppose so
02:10:08 <maerwald> should  run some TH code that infers the maximum instance based on the number of build jobs
02:10:48 <boxscape> or based on the number of mailing list requests that are asking for it
02:13:25 <merijn> tdammers: mazzel is pretty universal, is was thinking more like achenebbisj
02:15:52 <ski> @dice 4d20-2
02:15:52 <lambdabot> ski: 36 - 2 => 34
02:17:20 <boxscape> 200000000000000000000d2000000000000000000000000
02:17:20 <lambdabot> boxscape: 200000000011101321490973505089978167756587008
02:17:22 <boxscape> not bad
02:17:42 <boxscape> would have taken me quite a while to throw those myslef
02:27:21 <__monty__> merijn: I think we spell that achenebbig.
02:37:14 <merijn> __monty__: I had to google how to spell it, I only use it in speech :p
02:41:40 <__monty__> Just never heard it with an s.
02:54:22 <tdammers> how does one google phonetically?
02:55:54 <boxscape> "Ok google, how do I spell ..."
03:03:37 <tdammers> hmm...
03:34:01 <aletheia2> I've got a quck question, is it possible in haskell to pass a record as function parameter both in the destructured version Foo{x= y} etc.. and with a variable name at the same time?
03:34:52 <tomsmeding> aletheia2: what do you mean exactly when you say "with a variable name"?
03:35:42 <aletheia2> the full record, just like bar record = ...
03:36:45 <tomsmeding> do you perhaps mean an "as-binding": myfunction r@Foo{x=y} = {- something with r and y -}
03:37:02 <aletheia2> yes that's exactly what i was looking for, thanks
03:37:14 <tomsmeding> that notation also works for other things, like tup@(x,y)
03:58:28 <dminuoso> aletheia2: Note, if you have lens you you get to write it as : ` let x = ...; y = x & someField %~ (+1); in ... f x ..`
03:58:31 <dminuoso> (Or optics)
04:13:47 <wz1000> are there any libraries that implement efficient maps keyed over small enums (<= Word8) ?
04:14:08 <merijn> wz1000: Vector? :p
04:15:05 <merijn> Or, perhaps Array if you wanna use Ix on your key  type
04:15:55 <wz1000> But then growing it would be inefficient
04:16:21 <wz1000> I want to keep a lot of these maps, and want to keep growing/shrinking them
04:16:49 <wz1000> Or are you suggesting I use Vector (Maybe a)?
04:17:23 <wz1000> where the size is the size of the enum - but that still seems wasteful because many/most of these maps will barely be populated
04:17:26 <__monty__> Does it need to be faster than IntMap?
04:19:01 <wz1000> I'm using IntMap now, but it seems wasteful since I'm wasting 7 bytes per int
04:19:17 <fendor> Interesting, limiting the ghci HEAP leads to tasty not terminating on an endless looping test
04:20:28 <wz1000> what I'm looking for is essentially Word8Map
04:21:43 <fendor> increasing the heap to 3GB or something like that works, though.
04:23:43 <merijn> wz1000: Use backpack to generalise IntMap to any bounded Int! :D
04:23:56 <__monty__> wz1000: Does it really matter if your indices are boxed?
04:24:50 <merijn> wz1000: If your maps are sparse, just use "Vector (Key, Value)" and binary search any key you need
04:25:09 <merijn> wz1000: And if they're sparse the copy upon insert isn't an issue either
04:26:15 <wz1000> __monty__: IntMap doesn't have boxed indices though? (Or at least it shouldn't)
04:26:34 <__monty__> Your word8 indices would be boxed though?
04:26:37 <merijn> wz1000: eh...I think so
04:26:42 <merijn> Also
04:26:51 <merijn> Word8 is the exact same size as Int
04:27:24 <__monty__> No taking advantage of any leftover space in the pointer, merijn?
04:27:40 <wz1000> But you can combine the prefix and the mask into a Word16 though
04:27:44 <wz1000> https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.IntMap.Internal.html#IntMap
04:27:50 <merijn> https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Word.html#Word8
04:28:25 <merijn> Word8 is just Word# which is the same size as Int#
04:29:12 <merijn> wz1000: Ok, so realistically, how many keys are you expecting to have? Millions? Billions? Trillions?
04:29:28 <merijn> Because for anything less than trillions this seems utterly irrelevant
04:30:26 <merijn> Ok, maybe for billions to on desktop-y machines
04:31:41 <wz1000> I mean, I'm trying to benchmark Haskell implementations of common lossless compression algorithms and compare them to "reference" C implementations, so I need all the help I can get
04:32:26 <tomsmeding> what kind of map do the C implementations use in this case?
04:32:49 <merijn> wz1000: Well, the unboxed tuple vector seems the best in terms of pure speed for lookup
04:33:59 <merijn> Custom storable vector also does well if memory usage is a concern, since you can pack as tightly as you need
04:37:46 <sjha> hey
04:40:37 <tomsmeding> sjha: hi :)
04:46:25 <sjha> tomsmeding hi :)  this is the first time I've joined Haskell irc or freenode for that matter . I hope to learn a lot from you all. 
04:47:23 <tomsmeding> I hope you do! message frequency varies; note there are some logs at https://ircbrowse.tomsmeding.com/browse/haskell
04:48:32 <boxscape> oh huh had no idea I'm in the top 10 frequently messaging users this month
04:48:39 <boxscape> s/10/10 most/
04:48:50 <boxscape> tomsmeding do you have a search function for the logs in there?
04:48:58 <tomsmeding> lol no I believe not
04:49:10 <boxscape> hm okay
04:49:24 <tomsmeding> I guess creating a page for that shouldn't be too hard
04:49:29 <tomsmeding> also open source so hack away ;)
04:49:38 <boxscape> I'll take a look
04:49:53 <tomsmeding> (most/all of the code is not written by me though)
04:50:06 <boxscape> right okay
04:56:07 <siraben> Wjat
04:56:19 <siraben> What's the recommended way to throw errors in the continuation monad?
04:56:31 <siraben> Cont over Except doesn't work, but there's Except over Cont
04:58:48 <merijn> The *recommended* way to throw errors in Cont is too buy some heavy booze and spent an evening drunk and crying trying to figure it out :D
04:59:04 <siraben> heh
04:59:15 <siraben> well, i'm currently using MonadFail inside Cont, hehe
04:59:30 <siraben> Specifically MaybeT, but can't get ny messages out of it
04:59:32 <siraben> any
05:00:57 <ski> shekhar : feel free to ask questions
05:01:26 <maerwald> ContT is where haskell is indistinguishable from Java.
05:02:26 * tomsmeding gets out popcorn
05:02:31 <ski> @unmtl ContT o (MaybeT m) a
05:02:31 <lambdabot> (a -> m (Maybe o)) -> m (Maybe o)
05:02:33 <ski> @unmtl MaybeT (ContT o m) a
05:02:33 <lambdabot> (Maybe a -> m o) -> m o
05:02:41 <siraben> I'm really close to converting the scheme interpreter to monad transformers; https://github.com/siraben/r5rs-denot/blob/e1e46ecd63ed4b5d8b287a00da6e1184bbc2534b/src/SchemeEval.hs#L20
05:02:53 <siraben> @unmtl ReaderT u (ContT k (MaybeT (State s))) a
05:02:53 <lambdabot> u -> (a -> s -> (Maybe k, s)) -> s -> (Maybe k, s)
05:03:09 <siraben> But I need `Either err k` instead of `Maybe k`
05:03:33 <ski> @unmtl ReaderT u (ContT k (ErrorT err (State s))) a
05:03:33 <lambdabot> u -> (a -> s -> (Either err k, s)) -> s -> (Either err k, s)
05:03:38 <siraben> Also, any way to reduce the boilerplatey functions `reflect` and `reify`?
05:04:48 <siraben> ski: No instance for (MonadError err (ContT k (ErrorT err (State s))))
05:05:07 <siraben> then there's a message about using standalone deriving
05:05:10 <ski> `unmtl' doesn't know `ExceptT', use that instead of `ErrorT'
05:05:25 <siraben> Yeah it doesn't work with ExceptT either
05:05:50 <siraben>     • No instance for (MonadError err (ContT k (ExceptT err (State s))))
05:05:52 <maerwald> Just use IO, TVars and exceptions
05:06:05 <maerwald> all this stuff doesn't buy you anything real
05:06:06 <siraben> Hm, but I lose the translation from the denotational semantics
05:06:29 <maerwald> You don't have that with transformers anyway
05:06:55 <siraben> Right, but is it not possible to do a custom MonadFail instance for a custom newtype to get this to work?
05:07:40 <siraben> Also I have `reflect act = Scheme (ReaderT (\u -> ContT (\k -> MaybeT (state (act u (runState . (runMaybeT . k)))))))` and `reify f r k s = f & unScheme & (`runReaderT` r) & (`runContT` (MaybeT . state . k)) & runMaybeT & (`runState` s)` to go back and forth between the repr without transformers and the repr with
05:07:49 <siraben> such that `reify . reflect = reflect . reify = id`
05:07:58 <tomsmeding> beautiful
05:08:20 <siraben> tried looking around to see if it was possible to use Data.Coercible so I don't have to write this boilerplate, didn't find an answer
05:10:00 <maerwald> tomsmeding: I think java jobs pay better and cause less headach than this :D
05:10:01 <ski> siraben : where did you get `A = Maybe [E] * S' from ?
05:10:13 <siraben> ski: https://schemers.org/Documents/Standards/R5RS/r5rs.pdf
05:10:21 <siraben> pdf page 41
05:10:34 <siraben> it's not specified so I guessed
05:10:40 * ski 's looking at <https://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2>, right now
05:10:41 <tomsmeding> maerwald: but they're also java jobs
05:11:06 <siraben> oof heh that page has blurry images
05:11:19 <maerwald> tomsmeding: well, you feel productive by writing boilerplate like getters and setters. It's a language feature, so to speak
05:11:22 <siraben> ski: the master branch of that repo contains the direct translation, I'm monadifying it
05:11:45 <tomsmeding> and the feeling of accomplishment and joy after solving a problem can be worth 1. less pay and 2. being able to solve the problem in the first place
05:12:03 <tomsmeding> "feeling productive" as a language feature is the most java thing I've heard in a while
05:12:26 <maerwald> note tat "feeling productive" /= "being productive"
05:12:39 <maerwald> feelings matter most
05:12:47 <siraben> twoarg ζ [ε1, ε2] κ = ζ ε1 ε2 κ
05:12:49 <siraben> oops wrong window
05:12:55 <tomsmeding> such greek
05:13:02 <ski> (it's abusing `Show', i see ..)
05:13:33 <siraben> ski: yeah i started the repo when I was more noob, heh. I'll use a proper pretty printer later
05:14:22 <siraben> argh if only i could find a nice concise reference implementation of a hygienic macro expander
05:15:11 <maerwald> tomsmeding: it's also only important your boss feels that you are productive, not that you actually are. And if your PRs are huge and frequent, you it conveys that feeling. Java is a win-win for everyone
05:15:44 <ski> siraben : my hunch is that interpreting as `State' (and `MaybeT') inside `ContT' is a mistake, that you really want `StateT' outside `ContT'
05:16:05 <siraben> ski: doesn't that lead to a notion of "transactional state" wherein the state reverts?
05:16:23 <ski> reverts, when ?
05:16:32 <maerwald> tomsmeding: in haskell, ppl don't want to feel productive, but smart. So they do all sorts of stuff for that :p
05:16:46 <tomsmeding> maerwald: true enough :p
05:16:56 <siraben> ski: when callCC is invoked for instane
05:16:56 <siraben> instance
05:17:14 <ski> i don't think so
05:17:23 <ski> i think you should not analyze `A' here
05:17:24 <siraben> ski: see https://github.com/siraben/r5rs-denot/blob/fc1703473dc7af1b13c970edc553b62f6aa70656/src/SchemeEval.hs#L24-L30 for my reasoning
05:17:36 <ski> yes, i'm looking at that right now
05:18:51 <siraben> I guess any monad transformer stack works as long as I can reflect and reify back and forth
05:18:55 <siraben> at least helps development
05:19:29 <ski> @unmtl ReaderT U (StateT S (ContT A IO)) [E]
05:19:29 <lambdabot> U -> S -> ([E] -> S -> IO A) -> IO A
05:20:58 <siraben> gasp io
05:21:04 <siraben> makes sense
05:21:18 <siraben> Then throw errors in IO?
05:21:27 <ski> (assuming you want stuff like `read',`display',&c.)
05:21:49 <siraben> Yeah definitely I needed IO somewhere but didn't know whether to put it up top or at the bottom
05:22:37 <boxscape> hm is it normal that stack is stuck a long time at "Downloading index" when first run?
05:23:02 <siraben> ski: why state over exception?
05:23:10 <maerwald> boxscape: a bit
05:23:25 <siraben> looks different than from the spec's semantics
05:23:28 <boxscape> I think it's been 30 minutes or so which seems a bit long
05:23:51 <maerwald> boxscape: is it downloading just the index or git repos?
05:24:05 <merijn> maerwald: tbh, in hindsight I'm usually the most productive when I feel unproductive
05:24:27 <maerwald> I think it's anger
05:24:32 <siraben> :t foo m u k s = m & unM & (`runReaderT` u) & (`runStateT` s) & (`runContT` k)
05:24:33 <boxscape> um, I'm running "stack build" inside a git repo, but the last message I got is "Downloading index"
05:24:33 <lambdabot> error: parse error on input ‘=’
05:24:47 <siraben> :t (\m u k s -> m & unM & (`runReaderT` u) & (`runStateT` s) & (`runContT` k))
05:24:48 <lambdabot> error:
05:24:48 <lambdabot>     • Variable not in scope:
05:24:48 <lambdabot>         unM :: a -> ReaderT r (StateT s (ContT r1 m)) a1
05:24:51 <ski> @type let foo m u k s = m & unM & (`runReaderT` u) & (`runStateT` s) & (`runContT` k) in foo
05:24:52 <lambdabot> error:
05:24:52 <lambdabot>     • Variable not in scope:
05:24:52 <lambdabot>         unM :: a2 -> ReaderT r2 (StateT s1 (ContT r3 m1)) a3
05:25:10 <merijn> maerwald: Spend 3 days dicking around with a complex problem for spawning processes and only get anything resembling working on day 5, but in the next 3 years I've been able to use it without issue 10 different times not having to worry about getting it all right again :p
05:25:17 <siraben> @type let foo m u k s = m & (`runReaderT` u) & (`runStateT` s) & (`runContT` k) in foo
05:25:19 <lambdabot> forall k r1 s (r2 :: k) (m :: k -> *) a. ReaderT r1 (StateT s (ContT r2 m)) a -> r1 -> ((a, s) -> m r2) -> s -> m r2
05:25:22 <siraben> there we go
05:25:29 <merijn> maerwald: But it's hard to account for those future 3 years when not producing anything for a week :p
05:25:37 <siraben> well m ~ IO here
05:26:28 <maerwald> merijn: reminds me of a colleague who fixed our entire platform over the weekend, because he was bored or excited or both about debugging memory issues.
05:27:28 <maerwald> without a jira ticket, without design phase, without sprint estimation :p
05:28:11 <tomsmeding> how did he introduce that on monday
05:28:20 <tomsmeding> "people I fixed your shit, please go to work as usual"
05:28:34 <merijn> tomsmeding: That's how I would introduce it :p
05:28:52 <maerwald> he made bold claims and we initially thought he's just a bit overreacting, but he wasn't
05:29:54 <maerwald> (we also spent lots of money on a prior consultant who tried to fix that problem with complicated solutions)
05:30:03 <maerwald> so much for productivity
05:30:55 <maerwald> but that's what they do: the don't fix problems, they sell solutions :p
05:32:18 <nshepperd2> the true purpose of jira tickets, design phases and sprints is to not use them and thereby become productive
05:33:17 <maerwald> there's the other extreme, when ppl create huge PRs that overhaul the entire codebase with lots of opinionated decisions, rendering the team unproductive for weeks, due to bikeshedding etc
05:33:24 <nshepperd2> like doing ninja training with weights on or something
05:34:16 <maerwald> when devops rewrites your entire CI in nix over Christmas, without telling anyone, for example
05:34:27 <maerwald> (yes, that happened)
05:35:13 <maerwald> since then I have anxiety during Christmas
05:38:14 <siraben> nixify all the things
05:38:24 <merijn> Please don't >.>
05:38:33 <siraben> hehe
05:40:26 * ski . o O ( "-2000 Lines of Code" by Andy Hertzfeld at <https://www.folklore.org/StoryView.py?story=Negative_2000_Lines_Of_Code.txt> )
05:42:49 <ski> siraben : i think the `wrong' stuff isn't exactly exceptions, anyway (it's not caught)
05:46:41 <int-e> Yay, Dijkstra. '[...] we should always refer to "the number of lines of code spent".'
05:49:26 <int-e> That one is false as well, though. LoC is just a terrible metric for measuring progress.
05:54:43 <maerwald> What does LOC even mean. Does it include the dependencies? :)
05:54:56 <maerwald> Because then the metric is suddenly very different.
05:59:01 <zincy__> I am beginning to think that when someone says code is hard to read it means *they* find it hard to read.
05:59:18 <merijn> zincy__: Well, duh
05:59:24 <zincy__> :D
05:59:56 <zincy__> But their opinion comes from their favourite language X even when talking about Y
06:00:01 <merijn> zincy__: "Haskell is hard to read" - every single programmer who never actually learned Haskell's syntax
06:00:37 <merijn> zincy__: When people say "X is hard to read" in a language they don't use what they *mean* is "This is different, therefore I hate it"
06:00:44 <zincy__> haha
06:00:48 <zincy__> ^ this
06:01:04 <merijn> Although, to be fair, I see some pretty atrocious styles in Haskell libraries
06:01:35 <zincy__> Haskell doesn't prevent you from writing bad code it just smacks you on the hand
06:02:00 <merijn> My personal style is increasingly moving towards "type signatures on *every* binding, judiciously name things in where blocks, grouping via empty lines == good"
06:02:13 <zincy__> Nice
06:02:22 <merijn> Particularly a lot of haskell in the wild seems weirdly scared of empty lines
06:03:07 <zincy__> Like paragraphs in an essay
06:03:17 <zincy__> Or rests in music
06:03:42 <merijn> zincy__: I used to not write type signatures in my where blocks like most people, but then I had to work on code like this: https://github.com/yesodweb/persistent/blob/master/persistent-sqlite/Database/Persist/Sqlite.hs#L501-L517
06:03:52 <merijn> And you're like "wtf is any of this?!"
06:04:00 <zincy__> Yeah Beam did that for me
06:04:39 <dminuoso> merijn: I'd say it's... well. Run it it and run sqlite in trace mode?
06:04:42 <dminuoso> :p
06:05:02 <siraben> merijn: oh god
06:05:03 <merijn> zincy__: beam makes me go "wtf is any of this?!" even with the types
06:05:18 <zincy__> merijn: I have no idea how that works. It is crazy.
06:05:28 <zincy__> postgres-simple for the win
06:05:30 <siraben> what's beam?
06:05:37 <siraben> the erlang platform?
06:05:39 <dminuoso> beam is when you dont want readable sql
06:05:59 <int-e> merijn: not using empty lines to separate entities is a waste of the visual cortex
06:06:01 <dminuoso> It's trading readability and maintainability for type safety..
06:06:12 <ephemient> you need {-# LANGUAGE ScopedTypeVariables #-} in order to put signatures inside some where blocks
06:06:18 <ephemient> (but it's a good extension to have anyway)
06:06:20 <merijn> int-e: Word
06:06:24 <zincy__> All the naive queries seem to be really slow
06:06:42 <dminuoso> ephemient: You only need ScopedTypeVariables to access type variables introduced in an outer binding, but not for type signatures in a nested binding.
06:06:45 <merijn> My personal style is more like this: https://github.com/merijn/Belewitte/blob/master/benchmark-analysis/src/StepAggregate.hs#L82-L121
06:06:55 <dminuoso> (And even then you *also* must introduce the type variable via an explicit forall)
06:07:07 <merijn> Heavy where nesting == good, type annotations on all of them == better
06:07:23 <dminuoso> Indeed.
06:07:39 <dminuoso> If it has a name, it has to have a type annotation.
06:07:41 <dminuoso> That's my rule
06:08:03 <dminuoso> Well okay, it doesnt work for function argument binders.. mmm. I need to rephrase that rule
06:08:21 <merijn> dminuoso: There's still the occasional exception, but they're becoming rarer and rare
06:08:22 <zincy__> I wish my Clojure colleagues adopted that motto "If it has a name, it has to have a type annotation."
06:08:32 <merijn> dminuoso: Those have a type annotation in the function signature :p
06:08:39 <dminuoso> merijn: not necessarily
06:08:44 <siraben> merijn: what's quite readable
06:08:53 <dminuoso> merijn: if you call something that takes a lambda, it might not be
06:09:04 <merijn> dminuoso: Ah, true
06:09:18 <merijn> "but we have type inference..." sod that
06:09:40 <merijn> 5 months from now I'll have to redo the inference in my head to understand it, just write it out
06:09:43 <dminuoso> Indeed, it took 3 years for me to realize that type inference really isn't that valuable..
06:09:58 <dminuoso> I mean, its useful to be able to ask GHC what it thinks a binding has...
06:10:04 <int-e> adding type signatures results in better type errors
06:10:18 <merijn> siraben: I've been really happy with my ability to dive into code I haven't touched in more than a year and easily see what's going on and alter it
06:10:21 * ski . o O ( type error slicing )
06:10:23 <dminuoso> int-e: type error slices would go a long way helping with that tho
06:10:25 <int-e> that said, I still don't always add type signatures inside `where` binders
06:10:28 <dminuoso> ski: Oh you were first!
06:10:37 <zincy__> Slicing?
06:10:40 <int-e> what are type error slices, hmm, will google
06:11:10 <int-e> 'A Slicing-Based Approach for Locating Type Errors'?
06:11:17 <ski> <https://www.macs.hw.ac.uk/ultra/skalpel/index.html>
06:12:05 <int-e> Which is a 1997 paper, fun.
06:12:07 <siraben> whoa is there one for haskell and a mode in emacs for that?
06:12:13 <siraben> well LSP underlines the errors
06:12:17 <siraben> haskell-lsp
06:13:01 <dminuoso> siraben: Not that I know of.
06:13:10 <dminuoso> Type error slicing would need support in GHC
06:14:36 <dminuoso> It would have to identify all locations that contribute to the error, GHC as a very naive and simplistic heuristic of showing 'related bindings' instead that more often than not are unrelated to your problem.
06:14:47 <int-e> "[...] has been implemented for a signicant subset of Pascal."
06:15:47 <int-e> So maybe not that relevant to Hindley-Milner type inference :)
06:17:10 <siraben> hm, -fdefer-type-errors, wonder if that will help me with AoC, hehe
06:17:34 <merijn> siraben: You probably want its superior brother -fdefer-typed-holes and judicious use of typed holes
06:17:36 <xerox_> can you defer them to after the 25th
06:18:24 <siraben> merijn: how's that compare to -Wno-partial-type-signatures ?
06:18:29 <siraben> oops I mean PartialTypeSignatures
06:18:36 <merijn> siraben: Not at all?
06:19:01 <merijn> > map _ ['a'..'z'] :: [Bool]
06:19:06 <lambdabot>  error:
06:19:06 <lambdabot>      • Found hole: _ :: Char -> Bool
06:19:06 <lambdabot>      • In the first argument of ‘map’, namely ‘_’
06:19:50 <merijn> Typed holes tell you the type of value that needs to fill the hole. -fdefer-typed-holes turns that error into a warning (which throws a runtime exception when you evaluate it)
06:20:02 <siraben> ah, i see
06:21:00 <merijn> So with "-fdefer-typed-holes" "map _ ['a'..'z'] :: [Bool]" is the same as "map undefined ['a'..'z'] :: [Bool]" except infinitely better because you get a more useful exception when it crashes and when you remove -fdefer-typed-holes they become errors, so you can't forget and leave one like you can with undefined :p
06:21:44 <int-e> dminuoso: I'm not convinced that slicing is the answer... the type signatures would still dramatically narrow down the field of locations to check for errors.
06:22:05 <siraben> Sounds useful especially when exploring a problem
06:22:35 <boxscape> Is there a convenient way to do something like `[1..5] & ix 3 <%~ succ` where the contents of the collection do not form a Monoid and instead it returns `Just` the new value if it's inbounds and Nothing if it's out of bounds?
06:22:51 <int-e> dminuoso: Without type signatures, slicing just moves the problem from "the type error is in reported in totally corrct code" to "I have 100s of locations to check, one of which is incorrect"
06:22:55 <siraben> currently I just comment out blocks of code with M-S-c before reloading, heh
06:23:22 <merijn> siraben: This is very useful for stubbing functions you know you need but can't/don't wanna implement yet
06:23:28 <int-e> dminuoso: And the solution remains the same: add type signatures to narrow things down to the real error.
06:23:37 <merijn> siraben: "mkFoo :: String -> Foo; mkFoo = _"
06:23:50 <merijn> Write the rest of your code using mkFoo, figure out how to implement it later
06:24:06 <int-e> dminuoso: That said, slicing looks like a more honest approach to this problem :)
06:25:17 <dminuoso> int-e: Sure, consider type signatures as "narrowing the pond" and type error slices as "showing you the pond"
06:25:42 <int-e> Right.
06:26:36 <merijn> siraben: The best thing with -fdefer-typed-holes is that you can start using/testing your code before you finish implementing all stubs :)
06:26:58 * siraben adds it to template.hs
06:27:27 <merijn> It saddens me so few people know about/use -fdefer-typed-holes
06:31:26 <boxscape> I suppose the part where it's indexed is really secondary to my question, it would apply to any Prism
07:13:10 <idnar> boxscape: `[1..5] & at 3 <%~ fmap succ` I think
07:13:38 <idnar> oh no
07:13:54 <idnar> meh
08:16:02 <mananamenos> hi, why doesn't `$` parse in this example? `prop_removeNotEmpty xs x = xs /= empty ==> remove (add x xs) == add x $ remove xs
08:16:03 <mananamenos> `
08:16:27 <mananamenos> i must put parens on (remove xs)
08:16:46 <merijn> $ is not "magic parens removal"
08:16:54 <merijn> :t ($)
08:16:55 <lambdabot> (a -> b) -> a -> b
08:17:15 <merijn> mananamenos: *everything* on the left of $ is treated as function and applied to the thing on the right
08:17:36 <merijn> While you're intending to only apply "add x"
08:18:00 <ephemient> ==> is infixr 0, $ is infixr 0
08:18:20 <merijn> That still leaves "remove (add x xs) == add x"
08:18:47 <ephemient> therefore it parses like `prop_removeNotEmpty xs x = ((xs /= empty) ==> remove (add x xs) == add x) $ remove xs`
08:18:51 <merijn> That's a boolean, not a function (well, it's a type error, but if it wasn't, it'd be a type error
08:19:08 <dolio> That would be infixl.
08:19:42 <ephemient> oh you're right, I got left and right backwards
08:19:47 <dolio> :)
08:20:05 <mananamenos> thank you
08:53:41 <texasmynsted> WAT?! https://github.com/quchen/articles/blob/master/2018-11-22_zipWith_const.md  
08:53:50 <texasmynsted> That is great! :-)
08:54:16 <Squarism> Im trying to understand the utility of "traverse" together with "Const"
08:55:08 <Squarism> Some wrote it becomes powerful in this form : (getConst . traverse Const :: (Monoid a, Traversable f) => f a -> a) 
08:55:14 <Squarism> But I still dont get it
08:55:41 <c_wraith> have you used lens at all?
08:56:04 <Squarism> I have, but mostly wo understanding what happens underneath.
08:56:13 <Squarism> I get the concept of Traversable / 
08:56:25 <dolio> You know foldable, right?
08:56:27 <c_wraith> it turns out Const is a significant part of how lens works
08:56:49 <dolio> Because that is Foldable, basically.
08:56:53 <Squarism> Foldable .. and how they can achieve the end result in broad terms. But not much more.
08:57:44 <jle`> try it out with some sample traversables you might know
08:57:47 <Squarism> I feel I need to se an example of how Const + traverse does something useful. Looking at the code of lens library feels to much at once.
08:58:00 <c_wraith> so the thing with a lens, and let's pick a concrete-ish type here, is that you have something that doesn't look like it's especially helpful all the time.  Like...  (a -> f b) -> (a, c) -> f (b, c)
08:58:02 <jle`> > traverse Const ["hello","world","goodbye"]
08:58:04 <lambdabot>  Const "helloworldgoodbye"
08:58:21 <jle`> it lets you collect the items of a Traversable into a monoid
08:58:22 <dolio> It does what Foldable does for every Traversable.
08:59:06 <c_wraith> But if you want to use a lens as a getter, that final type doesn't look very useful.  f (b, c)  doesn't look much like a
09:00:18 <c_wraith> but that type f is very flexible.  You specialize the type of the lens to (a -> Const a b) -> (a, c) -> Const a (b, c)
09:00:40 <Squarism> I would prefer not talk about the other types of Lens but for example see how I could extract "2" out of (Just 2,"asdf")
09:00:56 <c_wraith> that's exactly what I'm doing
09:01:47 <c_wraith> except for the Maybe part.  that gets into Traversals, so I'm removing it
09:02:25 <Squarism> (sorry for that unappreciative answer, just meaning long signatures and things that are natural to you havent clicked yet for me =D)
09:03:30 <jle`> Squarism: 'traverse' only touches the "asdf" part, so you could use it to extract the "asdf"
09:03:36 <jle`> > traverse Const (Just 2, "asdf")
09:03:38 <lambdabot>  Const "asdf"
09:05:27 <c_wraith> The thing about Const is that it's a trivial functor that you use when you want to *reduce* what's going on in a function that's polymorphic in the functor type
09:05:50 <c_wraith> there's no way to show it doing something useful that doesn't start as something complex and then reduce the complexity
09:06:05 <Squarism> jle`, I was hoping there was a trick to extract the "2" out of it. Like quick and dirty "Getter" ?
09:06:21 <jle`> there is a trick, but you can't get it with 'traverse'
09:06:31 <jle`> since 'traverse' is only given the "asdf"
09:06:33 <c_wraith> and it's not going to be simple, either
09:06:52 <jle`> you can use bitraverse maybe
09:07:00 <c_wraith> because you're starting in two places at once, instead of just one
09:07:13 <jle`> > bitraverse Const pure (Just [2], "asdf")
09:07:16 <lambdabot>  error:
09:07:16 <lambdabot>      • Variable not in scope:
09:07:16 <lambdabot>          bitraverse
09:07:27 <c_wraith> start with a far simpler task: extract the 2 from (2, ())
09:07:53 <Squarism> ok
09:09:38 <c_wraith> now, let's give you a lens for that, but let's make it super-specialized:  _1 :: Functor f => (Int -> f Int) -> (Int, ()) -> f (Int, ())
09:10:05 <Squarism> Ok
09:11:19 <c_wraith> If you know you're going to be using _1 in your solution, you see that the final thing it gives you is an f (Int, ()).  But you want to be writing some sort of getter that just returns Int.  So there's a lot of junk there that's not necessary
09:12:21 <c_wraith> The trick is that in _1, f is polymorphic.  So you get to choose the Functor instance you want.  And it turns out Const is a good functor for throwing out a lot of junk
09:13:26 <c_wraith> So   _1 (Const) :: (Int, ()) -> Const Int (Int, ())
09:13:50 <c_wraith> But that result type is just a newtype wrapper away from Int
09:15:07 <c_wraith> and for reference, Const :: a -> Const a b
09:16:18 <c_wraith> you can sort of think of Const as letting you smuggle out a value, ignoring the bigger context.
09:16:55 <c_wraith> sure, yeah, there's a bigger value in the type, but it's phantom. It's not actually kept around
09:17:54 * tomsmeding realises Const is essentially just a beautiful functional hack
09:18:56 <c_wraith> And here's the big stumbling point:  Const is "useless", in exactly the same way const is "useless"
09:19:23 <c_wraith> Neither one is something you're going to just decide to use in your code
09:19:49 <c_wraith> They come up when you're working with higher-order things and you need to fit a simpler idea into a more complex one
09:20:05 <c_wraith> They're adapters, essentially.
09:20:18 <Squarism> c_wraith, so how would the actual application of this example look. "extract the 2 from (2, ())"
09:20:36 <c_wraith> getConst (_1 Const)
09:20:42 <c_wraith> err
09:20:48 <c_wraith> getConst (_1 Const (2, ()))
09:23:02 <c_wraith> In fact...
09:23:03 <c_wraith> > getConst (_1 Const (2, ()))
09:23:06 <lambdabot>  2
09:23:25 <c_wraith> the value _1 that lambdabot has is more polymorphic, but it can be instantiated at exactly those types
09:24:14 <jle`> > _1 Const (2, ())   -- hm..
09:24:17 <lambdabot>  Const 2
09:25:05 <c_wraith> :t M.alterF
09:25:07 <lambdabot> (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> M.Map k a -> f (M.Map k a)
09:25:37 <c_wraith> that's basically a lens that existed before the lens library
09:26:39 <c_wraith> > getConst (M.alterF Const 4 (M.fromList [(3, "hello"), (4, "world)]))
09:26:41 <lambdabot>  <hint>:1:69: error:
09:26:42 <lambdabot>      <hint>:1:69: error:
09:26:42 <lambdabot>          lexical error in string/character literal at end of input
09:27:33 <c_wraith> apparently lexical rules are hard for me these days
09:27:37 <c_wraith> > getConst (M.alterF Const 4 (M.fromList [(3, "hello"), (4, "world")]))
09:27:40 <lambdabot>  Just "world"
09:27:49 <c_wraith> > getConst (M.alterF Const 5 (M.fromList [(3, "hello"), (4, "world")]))
09:27:52 <lambdabot>  Nothing
09:28:50 <tomsmeding> so M.lookup = getConst . M.alterF Const
09:29:10 <c_wraith> I think that's got a type error, but mostly correct
09:30:01 <tomsmeding> ah right
09:30:03 <c_wraith> M.lookup k = getConst . M.alterF Const k
09:30:11 <tomsmeding> :t (getConst .) . M.alterF Const
09:30:13 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
09:30:27 <c_wraith> :t M.lookup
09:30:29 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
09:30:33 <c_wraith> there you go!
09:31:07 <c_wraith> :t M.alterF
09:31:09 <lambdabot> (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> M.Map k a -> f (M.Map k a)
09:31:20 <c_wraith> once more - that returns an f (M.Map k a)
09:31:48 * tomsmeding thanks c_wraith for the nice intro into Const, TIL
09:31:52 <c_wraith> Const is an adapter that lets you get a Maybe a out instead, by sneaking it into the f
09:32:47 <c_wraith> I really do find it impressive that alterF predates the lens library
09:32:58 <c_wraith> Someone stumbled onto something far more general than they realized
09:34:48 <Squarism> c
09:36:08 <tomsmeding> alterF for Data.Map looks to be after lens, though: https://github.com/haskell/containers/commit/7d03d76b7647dc731da2e75dcdd45f6c2e667682
09:36:16 <Squarism> c_wraith, ok. That was an interesting example. Trying to extend it to get the 2 out of (True,(2,()). 
09:36:42 <Squarism> ...and thanks!
09:36:52 <c_wraith> huh, did I get that relative timing wrong? that's unfortunate
09:37:35 <tomsmeding> well I don't know if that's the first occurrence of such an alterF, but it seems to be the origin of Data.Map.Strict.alterF
09:40:53 <c_wraith> Squarism: it turns out that's going to not be much more enlightening. the use of Const will be identical. the only difference will be replacing _1 with a function that digs deeper.
09:45:17 <ezzieyguywuf> if I have an `Either e a` and a `(a -> b)`, how can I make an `Either e b`?
09:45:25 <dminuoso> % :t fmap
09:45:25 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
09:45:33 <Squarism> c_wraith, alright. That was great. Now I have a small expression that I can dig into. Thanks a bunch.
09:45:35 <ezzieyguywuf> duh!!
09:45:46 <ezzieyguywuf> forgot that fmap for Either will return Left as-is
09:45:50 <ezzieyguywuf> dminuoso: thank you.
09:46:04 <solonarv> ezzieyguywuf: or Data.Bifunctor.second
09:46:09 <c_wraith> Squarism: you're welcome. keep playing with it and you'll get a good feel for it.
09:46:28 <Squarism> c_wraith, this is it right ? ((_2 . _1) Const (True,(2 :: Int, ())))
09:46:30 <solonarv> (you might want to use 'second' because of its symmetry with 'first', which works on the Left side)
09:46:47 <c_wraith> yes it is
09:47:29 <c_wraith> well, you might want to throw a getConst in, but that's just the tribal unwrapping 
09:47:41 <c_wraith> *trivial
09:49:32 <ezzieyguywuf> solonarv: thanks.
09:57:04 <cheater> this cabal source code has "i'm feeling lucky" as a comment ...
10:00:52 <[exa]> cheater: judging from the fact you're still reading cabal source code, I guess you weren't that lucky with the llvm?
10:01:37 <cheater> yeah, that's the state i'm in
10:01:52 <cheater> apparently it has no idea how to handle static llvm library lists under windows
10:01:56 <cheater> so i'll have to figure it out
10:02:00 <cheater> i'm eating lunch now though
10:02:36 <cheater> but essentially ifBuildsWith fails in Configure.hs with "Missing (or bad) C libraries"
10:03:03 <[exa]> perhaps you're hitting some of the famous commandline length limits?
10:04:27 <merijn> "missing (or bad) C libraries" sounds like pkg-config-depends failing
10:13:33 <jle`> is there a "tagged nil" list type anywhere commonly?
10:13:43 <jle`> data TaggedNil w a = Nil w | Cons a (TaggedNil w a)
10:14:15 <geekosaur> not commonly
10:14:54 <jle`> I thiiink it should be equivalent to Conduit () a m w
10:15:28 <solonarv> for finite lists it's equivalent to (w, [a]), right?
10:15:29 <jle`> forall m
10:15:59 <jle`> solonarv: oh yeah, true. but i'd want to be taking advantage of laziness here and using it with recursion-schemes
10:16:10 <jle`> i guessi could do (w, [a]) and do a custom recursin-scheme instance set
10:18:13 <solonarv> it's certainly equivalent to Conduit () a Identity w
10:20:40 <[exa]> :t \a b c ->  (,) <$> a <*> b >>= uncurry c   -- is there some name/shortcut for this? except for double binding with `do`.
10:20:42 <lambdabot> Monad m => m a -> m b1 -> (a -> b1 -> m b2) -> m b2
10:22:39 <solonarv> [exa]: I don't think so; you could also write it as   join (c <$> a <*> b)
10:23:42 <[exa]> yeah that is nicer
10:24:11 <jle`> i'd probably use do notation
10:24:34 <jle`> over tuple munging
10:25:37 <sm[m]> g'day all
10:26:15 <sm[m]> stack repl --help says: --package PACKAGE(S)     Additional package(s) that must be installed, suggesting you can put multiple package names with a single --package. Would anyone know the right syntax ?
10:26:50 <koz_> sm[m]: Tried comma separating?
10:27:30 <ski> [exa] : `infixl 4 <*>>; (<*>>) :: Monad m => m (a -> m b) -> (m a -> m b); mamb <*>> ma = join (mamb <*> ma)', then use `f <$> ma <*> mb <*> mc <*>> md'
10:29:02 <[exa]> wow cool
10:29:30 <[exa]> is the <*>> name used somewhere?
10:29:41 <ski> i've mentioned it before, in here ..
10:29:49 <[exa]> :]
10:29:56 <[exa]> ok, thanks everyone. :]
10:31:56 <ski> @type let mmab <<*> ma = join mmab <*> ma in (<<*>)
10:31:58 <lambdabot> Monad f => f (f (a -> b)) -> f a -> f b
10:34:20 <sm[m]> koz_: yup
10:34:23 <sm[m]> and space
10:35:11 <koz_> sm[m]: Yeah, that's obscure-AF.
10:35:16 <koz_> Three cheers for stack docs rofl.
10:35:42 <sm[m]> huh, https://docs.haskellstack.org/en/stable/GUIDE/#using-multiple-packages is there but says both comma and space work
10:36:25 <[exa]> ski: kindof finding out that just prefixing the whole construction with 'join $' will be likely the most digestible way
10:36:32 <sm[m]> seems like a bug/regression then, I'll report
10:36:54 <sm[m]> oh, but that doc was for the script command
10:36:55 <geekosaur> shell quoting required for spaces?
10:37:06 <geekosaur> (but not for commas, so.)
10:38:11 <geekosaur> I also note the "this is probably out of date" at the very start of the GUIDE
10:38:14 <ski> [exa] : fair enough :)
10:46:05 <sm[m]> https://github.com/commercialhaskell/stack/issues/5455
10:46:31 <sm[m]> too obscure to get fixed without a PR, but for the record..
10:47:34 <notzmv> fw
10:53:23 <kritzefitz> Can anyone recommend an up-to-date FRP library? I was just coming back to a project using reactive-banana and quite shocked to find out, that it doesn't seem to be actively maintained anymore.
10:53:58 <koz_> kritzefitz: Rhine is pretty good.
10:54:06 <koz_> (it also solves a fairly important problem)
10:57:14 <kritzefitz> koz, Thanks! I'm gonna take a look at that.
11:05:11 <ezzieyguywuf> how can I turn an Integer into an Int?
11:05:18 <ezzieyguywuf> Or vice-versa if that is "safer"?
11:05:41 <geekosaur> :t fromIntegral
11:05:43 <lambdabot> (Integral a, Num b) => a -> b
11:06:07 <geekosaur> vice versa would be safer since it can't overflow; same conversion function
11:06:17 <ezzieyguywuf> geekosaur: perfect thank you.
11:53:45 <dminuoso> ezzieyguywuf: What does "safety" even mean for you?
11:59:35 <koz_> dminuoso: I'm guessing the concern is overflow?
11:59:53 <koz_> There's like, cast-int or something like that for this?
12:00:01 <geekosaur> that was my guess as well
12:00:53 <dminuoso> Well, cast-int wouldnt allow you to go from Integer to Int
12:01:09 <dminuoso> Or does it?
12:01:28 <dminuoso> Ohh, it has dynamically checked variants, I did not know this
12:01:36 <dminuoso> I only ever used it for the static conversions
12:02:00 <koz_> The dynamically checked thing is actually in Data.Bits now I think.
12:02:03 <ezzieyguywuf> dminuoso: "safety" = "avoiding things like overflow"
12:02:23 <ezzieyguywuf> I'm not savvy enough to recognize these potential pitfalls
12:02:29 <ezzieyguywuf> (yet)
12:02:34 <dminuoso> Then int-cast is the only solution I know if..
12:02:55 <dminuoso> The lack of comprehensive conversion functions in Haskell is a major annoyance of mine
12:03:10 <ezzieyguywuf> so the (fromInteger :: (Integer -> Int)) is no good?
12:03:34 <dminuoso> It's like we train you to encode all kinds of properties into the type system, to ensure you don't have surprise errors - just to to hand you nothing but conversion functions that likely dont do what you want.
12:04:18 <dminuoso> % fromIntegral (122180591620717411303424 :: Integer) :: Int
12:04:18 <yahb> dminuoso: 7805620539050950656
12:04:20 <dminuoso> You tell me
12:05:19 <dminuoso> % fromIntegral (1180591620717411303424 :: Integer) :: Int
12:05:19 <yahb> dminuoso: 0
12:08:01 <ezzieyguywuf> yikes
12:08:51 <ezzieyguywuf> I'm not that worried about it. If my user wants to parse that many characters out of a "Description" column in a csv file downloaded from their bank...they have other problems
12:10:51 <dminuoso> Oh look at that
12:10:54 <dminuoso> https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Bits.html#v:toIntegralSized
12:11:00 <dminuoso> koz_ ^- you might also be interested
12:11:04 <koz_> dminuoso: I was aware. :P
12:11:09 <koz_> (I even mentioned this earlier)
12:11:30 <koz_> I had to deal with this when I was rewriting Real Job For Real Money's database wrapper layer.
12:11:43 <dminuoso> Oh sorry, I missed it then
12:12:02 <dminuoso> The documentation is a bit fuzzy on toIntegralSized
12:12:54 <dminuoso> The code example looks odd too, unless Im misreading something
12:13:45 <dminuoso> `| toInteger x == y = ...` this is the same as `| toInteger x == toInteger x = ...` 
12:14:19 <dminuoso> Im guessing the snippet is wrong and it should read `y = fromIntegral x`
12:15:37 <geekosaur> this came up a few weeks ago, it's wrong
12:16:09 <geekosaur> someone then tried to submit a PR and ran into a gitlab outage of some kind (503 error I think)
12:32:12 <iqubic> Is there an infix version of views from Lens?
12:32:28 <iqubic> Like an operator version.
12:32:34 <merijn> `views` ? :P
12:33:01 <Uniaika> iqubic: `views`
12:33:06 <Uniaika> ;)
12:33:51 <iqubic> I just mean "view is to (^.) as views is to ...?"
12:36:11 <dolio> There probably isn't one, because views has 3 arguments.
12:36:35 <iqubic> Right.
12:39:54 <maerwald> is (^.^) taken?
12:41:18 <dminuoso> https://hackage.haskell.org/package/cubicbezier-0.6.0.6/docs/Geom2D.html#v:-94-.-94-
12:41:37 <dminuoso> Wow how has that library 11k downloads :o
12:43:17 <iqubic> How is that number computed?
12:44:04 <merijn> mostly bots :p
12:45:04 <maerwald> iqubic: (+1) I think
12:45:27 <iqubic> What is (+1)? How does that help me?
12:46:40 <merijn> Incremented one at a time :p
13:01:26 <koz_> Can someone help me understand what this says vis-a-vis the stack StateT s Logic? http://hackage.haskell.org/package/logict-0.7.0.3/docs/src/Control.Monad.Logic.Class.html#line-121
13:01:52 <koz_> I don't get what the note above the ReaderT e m (which the docs say applies to StateT as well) actually means.
13:19:17 <merijn> koz_: That all alternatives get the same input state, I think?
13:19:37 <koz_> merijn: So basically, you can't actually change out the state mid-computation?
13:19:49 <koz_> AKA the state you provide for 'runStateT' will be the one everywhere?
13:19:54 <merijn> not sure
14:52:31 <iqubic> Why does this library exist? It's just so pointless: https://hackage.haskell.org/package/plumbers-0.0.4/docs/Control-Plumbers.html
14:55:28 <texasmynsted> ha
14:56:21 <merijn> iqubic: Clearly you haven't yet browsed Hackage's ACME category
14:56:32 <iqubic> I should do that.
14:57:08 <merijn> https://hackage.haskell.org/packages/tag/acme
14:58:14 <hpc> everyone has their favorite
14:58:26 <hpc> mine is schoenfinkel
14:58:40 <merijn> acme-dont and acme-LookOfDisapproval are nice too :p
14:59:59 <hpc> acme-dont is also a perl module
15:00:55 <iqubic> This is great: https://hackage.haskell.org/package/ACME-0.0.0.1/docs/Acme-Pirates.html
15:02:36 <iqubic> What's the point of this? https://hackage.haskell.org/package/acme-all-monad-0.1.0.0/docs/Control-Monad-All-Trans.html#t:AllT
15:03:22 <merijn> Nothing :p
15:03:38 <merijn> Next you'll ask what the point of acme-dont is :p
15:04:57 <hpc> it's all for fun
15:09:25 <iqubic> This is just too funny
15:11:56 <texasmynsted> LOL https://hackage.haskell.org/package/acme-stringly-typed-1.0.0.0/docs/Acme-StringlyTyped.html
15:12:10 <merijn> acme-php
15:16:08 <texasmynsted> https://hackage.haskell.org/package/acme-timemachine
15:16:19 <texasmynsted> oooh the acme tag is really fun
15:16:59 <dsal> tardis is the real time machine
15:17:02 <merijn> texasmynsted: You should check out the (non-joke) Tardis monad :p
15:17:49 <ezzieyguywuf> lol, megaparsec makes my eyes spin 😵
15:19:04 <texasmynsted> Hahh
15:19:42 <hpc> acme-microwave is a good one too - when i show it to people they are surprised that microwaves even work that way
15:21:19 <texasmynsted> Wow that tag makes me so happy.
15:21:24 <dsal> ezzieyguywuf: megaparsec is great.
15:21:27 <texasmynsted>  ಠ_ಠ
15:21:32 <merijn> dsal: The docs are not >.>
15:21:46 <dsal> Hmm...  Yeah, getting the initial mental model can be a challenge.
15:21:54 <dsal> I guess the other problem is figuring out where all the parts are.
15:21:55 <merijn> dsal: No, not that
15:21:59 <merijn> Just finding anything
15:22:30 <koz_> What does the Applicative instance of Writer do with the ... writ? ... on <*>?
15:22:32 <merijn> Like, I've used 5 different parser combinator packages before, megaparsec docs are *severely* lacking in logical structure for finding anything
15:23:08 <dsal> I was lost going from attoparsec to megaparsec for sure.  It does more of the things I want once I find them.  :)
15:24:30 <koz_> Ah, <>.
15:24:32 <koz_> As I thought.
15:25:08 <iqubic> With the use of ACME-Don't we get this: "safePerformIO = Just . don't"
15:28:05 <ezzieyguywuf> dsal: it is great
15:28:29 <ezzieyguywuf> the documentation gets the job done
15:28:37 <ezzieyguywuf> just every time I need to do somethin new I'm like blehhhhhhh
15:28:45 <merijn> :p
15:29:31 <ezzieyguywuf> but then after a while I'm like "Dang, is there really any other way to do this?"
15:40:02 <texasmynsted> If you start thinking regular expressions you need to step away from the keyboard
15:41:29 <shapr> I think in monads sometimes
15:42:21 <Majiir> Hey, folks. I've solved a performance problem I was having, but I'm wondering if there's a more general solution for what I've done. Code is here: http://pastie.org/p/68B6xmKFGSrL2sBFeVtzva
15:43:01 <Majiir> I want to change some fields (there are more on that record) if the condition 'null (moves g)' is true. The problem I was having is that 'moves g' is very expensive.
15:43:34 <Majiir> I changed to pass2 so that the other fields on the record (not shown) could be evaluated without forcing 'null (moves g)'
15:43:55 <Majiir> But all the 'if mustPass then .. else ..' feels repetitious.
15:47:51 <dminuoso> Majiir: Yeah that does not look idiomatic. Can you perhaps share the entire module?
15:49:21 <dminuoso> Im in particular curious what function `moves` is (is that a field of GameState), and where/how is it reduced.
15:49:48 <Majiir> Um.. well, it's my god-module that I'm in the process of reorganizing, so maybe some specific tidbits would be more helpful than the whole thing :D
15:49:58 <dminuoso> Feel free to share it anyway.
15:50:05 <dminuoso> Ill try and keep my focus on this region if you like.
15:50:23 <dminuoso> My instinct says the solution to your if-then-else requires some larger rethinking
15:52:40 <Majiir> Here's some more: http://pastie.org/p/3Nm0Gwj69o6BUpAmVSlhFr
15:53:25 <Majiir> 'board' and 'nextTurn' are the real state - the rest are my sorry attempt to memoize evaluation of other functions
15:53:49 <Majiir> moves and moveableTiles' are relatively expensive to evaluate
15:54:59 <dminuoso> Question, you seem to throw away the result of `moves`
15:55:14 <dminuoso> Do you just want to know whether there's any element in the resulting list, and nothing more?
15:57:05 <Majiir> In the specific case of 'pass', yes, but the full result of 'moves' would be useful elsewhere
15:57:57 <Majiir> The intuition here is: If the next player (GameState::nextTurn) has no moves, it forces a pass, so flip back to the first player.
15:58:13 <dminuoso> There's some minor improvements to be made, but nothing that would really be revolutionary. 
15:58:18 <dminuoso> Without seeing more, it's hard to say
15:59:00 <dminuoso> But roughly, I'd try to aim for this:
15:59:38 <dminuoso> case moves x of [] -> forcePass; xs -> resume
16:00:19 <dminuoso> rather than testing for null and then throwing that result away, I'd try and immediately use this knowledge and resume
16:00:43 <Majiir> Makes sense. I think I can get it there with some other refactors I have in mind.
16:00:45 <dminuoso> if-then-else in general is a smell
16:00:59 <Majiir> Fully aware I'm XY-problem'ing this :) 
16:01:17 <dminuoso> Like I said, Im willing to keep my focus to this region if you shared the rest of the code.
16:01:27 <dminuoso> I dont mind people exploring XY problems. ;)
16:02:08 <Majiir> I was curious if there's some handy-dandy tool (lens?!??) that would help me conditionally project a single record field without forcing the condition to evaluate when looking at any *other* field.
16:02:32 <dminuoso> what do you mean by "project"?
16:02:51 <Majiir> Erm... modify?
16:03:22 <dminuoso> lens addresses a different set of problems
16:03:38 <dminuoso> You could, perhaps, use the State monad to make it look a bit more imperative
16:03:54 <dminuoso> Then the code would something along the lines of
16:04:10 <dminuoso> (perhaps, together with lens)
16:04:32 <Majiir> The general pattern I am seeing is something like: if condition then x { foo = "bar", bar = "baz" } else x
16:04:57 <dminuoso> Well with State it would just be `when f (modify g)`
16:05:50 <Majiir> Yep, but if I access any other field on the record, I'm forcing evaluation of that condition. I was hoping to only evaluate the condition if I'm evaluating the fields that are (potentially) modified.
16:06:30 <dminuoso> I dont understand.
16:06:41 <Majiir> Yeah, I dug myself into a dumb hole I guess
16:07:18 <Majiir> Maybe I misunderstand what happened here, but my understanding led me to a 30x speedup, so I feel like I'm not too far off base.
16:08:23 <Majiir> When I used the form (if condition then x { foo = "bar" } else x), where that record has several fields, my program ran slowly because there were cases where I would evaluate one of those other fields (but never 'foo') and it would force evaluation of the condition (expensive)
16:09:01 <Majiir> That happened because to evaluate any part of the record, we had to evaluate the if block first.
16:09:28 <Majiir> By switching to the form `x { foo = if condition then "bar" else foo x }`, that condition is only evaluated if I evaluate 'foo'. ...right?
16:10:15 <dminuoso> That depends on how GHC floats it.
16:10:25 <dminuoso> It's free to turn one into the other
16:11:46 <dminuoso> But I'd say yeah
16:34:12 <texasmynsted> Majiir: It is difficult for me to see what is happening from the types. If it were me I would pull the code apart into individual functions, with their sigs. 
16:37:23 <texasmynsted> Right now you have two functions each GameState -> GameState. I do no know what a GameState is. Why are the function names doing work? pass1 vs. pass2 with the same signature.
16:42:27 <texasmynsted> It might be useful to separate the "what" from the "how". Once you can _see_ your solution from just the function type signatures you can golf the code down then try out different implementations. 
16:44:03 <texasmynsted> You might have done that already and I just can not see from the code you posted. Here is an example of what I mean. https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell.html
16:50:53 <ski> koz_ : i think so (re `MonadLogic')
16:51:49 <koz_> ski: Seems like I was right, then. Good to know, though it's not terribly clearly explained IMHO.
16:58:02 <monochrom> https://youtu.be/z43bmaMwagI explains why "if cond then x{...} else x" is more conducive to your sanity.
17:02:22 <ezzieyguywuf> so if I have a `Parser (Text, Text)` and I want to signal an error (this is megaparsec), how do I do that?
17:06:14 <dsal> ezzieyguywuf: What kind of error?  You could probably just use fail
17:06:44 <ezzieyguywuf> dsal: I tried fail, but it said "No instance for (MonadFail ((,) Text)) arising from use of fail"
17:06:58 <ezzieyguywuf> "what kind of error", just "couldn't parse that sorry"
17:07:20 <dsal> There's a bit of xy here.  Why do you have something you can't parse?
17:08:14 <dsal> There's `parseError :: ParseError s e -> m a` -- but you may not need that.
17:08:20 <ezzieyguywuf> hm...part of my configurable parser is "match something at the end of the string". In order to do that, I use takeRest and then use Data.Text functions to check the back-end of the string
17:08:34 <ezzieyguywuf> if it doesn't match, I want the parse to fail. If it does match, I want to return a (Text, Text)
17:09:14 <dsal> Yeah, so having the parser do the actual work of that match would be ideal.  Then it'll do the work for you and give you a good error for free.
17:09:37 <ezzieyguywuf> dsal: sure, but my understanding is megaparsec isn't too good at matching things at the end of the string
17:10:29 <ezzieyguywuf> I could, I guess, do a "lookahead" or something to see how many characters are left, THEN consume `remainingChars - Text.length targetStringAtEnd', THEN use a regular parser to check
17:10:39 <ezzieyguywuf> but then I also have a version where they can provide a list of potential matches
17:10:45 <dsal> You could just use something like manyTill
17:10:49 <ezzieyguywuf> which I guess I could fmap over the first
17:11:27 <dsal> manyTill_ p end applies parser p zero or more times until parser end succeeds. Returns the list of values returned by p and the end result. Use manyTill if you have no need in the result of the end.
17:11:48 <ezzieyguywuf> 😍
17:12:07 <ezzieyguywuf> dsal: I owe you a beer, let me know where I can send funds
17:12:26 <dsal> haha.  Everything I know I know from here, so you'll have to send it to the channel.
17:12:51 <dsal> There's a bunch of neat stuff ini https://hackage.haskell.org/package/parser-combinators-1.2.1/docs/Control-Monad-Combinators.html
17:12:57 <MarcelineVQ> I accept bitcoin (I don't accept bitcoin)
17:13:52 <dsal> I'll take MarcelineVQ's bitcoin.
17:14:04 <dsal> heh, I was asking if choice is asum the other day:
17:14:09 <dsal> choice :: (Foldable f, Alternative m) => f (m a) -> m a
17:14:09 <dsal> choice = asum
17:14:28 <dsal> The documentation actually says `choice = asum`
17:14:49 <ezzieyguywuf> dsal: lol, yea someone said "yes" two seconds later, you may have missed it. I saw it in the docs about 5 seconds after that, I chuckled
17:15:47 <dsal> Yeah, I saw that.  I just happened to notice it specifically says that in the docs.
17:15:52 <dsal> :t choice
17:15:54 <lambdabot> error:
17:15:54 <lambdabot>     • Variable not in scope: choice
17:15:54 <lambdabot>     • Perhaps you meant ‘choose’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:16:02 <dsal> hmm...  choice looks a lot like replicateM to me.
17:16:04 <dsal> :t replicateM
17:16:06 <lambdabot> Applicative m => Int -> m a -> m [a]
17:16:19 <dsal> Er, I mean count
17:16:19 <dsal> count :: Monad m => Int -> m a -> m [a]
17:16:44 <dsal> I like hoiw replicateM is applicative and count is Monad.
17:16:55 <dsal> I also like how my keyboard randomly puts the letter i in things where I didn't type it.
17:18:05 <MarcelineVQ> Moinad
17:20:47 <dsal> Monaids
17:22:43 <MarcelineVQ> Monadis
17:27:00 * ski . o O ( IMonad )
17:28:11 <koz_> ski: iMonad is what'll get added to Swift in around the year 3000.
17:33:20 <Axman6> if I have a class Foo a b c | a -> b, a -> c, and another class Foo a b c => Bar a b | a -> b, how can I ghc to stop complaining about the type variable c not being in scope?
17:35:34 <MarcelineVQ> class (forall c. Foo a b c) => Bar a b | a -> b  do anything?
17:41:33 <ski> i don't think that would express the intended semantics
17:42:09 <Axman6> yeah that leads to other issues (sorry, details to come soon)
17:42:11 <ski> `class Foo a where type B a; type C a' and `class Foo a => Bar a' seems to work ..
17:45:47 <Axman6> safly we can;t use type families, this is really DAML, not Haskell
17:46:00 <Axman6> type families would be the solution
17:46:04 <ezzieyguywuf> does hledger have a feature where it will "prettify" the input, i.e. specifically  I want to right-adjust all my amounts such that `Assets  10 USD` turns into `Assets  <enough spaces to make the D on column 80> 10 USD`
17:48:11 <sm[m]> ezzieyguywuf: you know you're in #haskell ? Just checking :)
17:48:36 <ezzieyguywuf> sm[m]: lol I didn't sory!
17:48:40 <ezzieyguywuf> dang I always do that...
17:49:43 <MarcelineVQ> I doubt anyone minds
17:50:36 <sm[m]> me neither,  but wouldn't want to spam y'all with too much #hledger chat
19:38:27 <boxscape> Is there a name for a Functor that's both co- and contravariant (So the opposite of Invariant)?
19:38:46 <boxscape> Though I suppose it's not super useful since the only instances I can think of are (Const a) and Proxy
19:42:12 <boxscape> I've provisionally called it Omnivariant
19:44:27 <boxscape> I suppose
19:44:32 <jle`> boxscape: i think it's a 'fact' that variations of Const are the only such things
19:44:43 <jle`> that's actualyl how the lens library constraints things to work for only Const a, or Proxy
19:44:44 <boxscape> I think Coerce is exactly this class?
19:44:57 <jle`> require both (Functor f, Contravariant f) => ...
19:44:58 <boxscape> I see
19:45:07 <jle`> essentially the same as requiring f to be some form of Const
19:50:01 <boxscape> (Okay it's not Coerce, that class is called Coercible and has a different kind, but I think omnimap can always be implemented with coerce)
19:50:59 <jle`> * -> * coerce maybe?
19:51:30 <koz_> Both co and contravariance in the same parameter implies it is phantom-roled.
19:51:38 <koz_> (or at least I'm pretty sure it does)
19:51:51 <boxscape> that sounds reasonable
19:51:52 <jle`> ooh yeah, phantom
19:52:29 <koz_> I'm pretty confident parametricity would require this.
19:54:22 <boxscape> Coercible (f a) (f b) would also require that the parameter to f is phantom, right?
19:54:37 <boxscape> hm
19:54:40 <boxscape> if it's forall a and b that is?
19:55:56 <boxscape> alas GHC can't infer the phantom role
19:56:43 <boxscape> I was trying to write `instance forall f a b . Coercible (f a) (f b) => Invariant f`
19:57:50 <koz_> Coercible (f a) (f b) could potentially work if it's representational and Coercible a b holds.
19:58:00 <boxscape> ah
19:58:02 <boxscape> right
19:58:25 <koz_> Now if we have (Coercible (f a) (f b), Coercible (f b) (f a)) on the other hand...
19:58:34 <boxscape> hm but then you should still be able to make an Invariant instance, since you have coerce :: a -> b and coerce :: b -> a
19:58:38 <koz_> But I guess Coercible is symmetric?
19:58:47 <koz_> Yeah, I think you could.
19:59:06 <koz_> You just ignore the functions completely.
19:59:13 <jle`> boxscape: i'm not sure that instance makes sense
19:59:14 <koz_> So invmap _ _ = coerce :P
19:59:23 <jle`> because you're quantifying over the f, which appears in the instance itself
19:59:34 <jle`> so maybe it's shadowing the f in the instance
19:59:36 <koz_> jle`: Yeah, good point.
19:59:47 <boxscape> oh
19:59:51 <jle`> instance (forall a b. Coercible (f a) (f b) => Inveriant f where .. might work
19:59:52 <koz_> Since it's the 'f' that has an Invariant instance.
19:59:56 <jle`> since the f isn't being shadowed
20:00:15 <jle`> but also this is a bad instance of course since it overlaps with every Invariant instance...but it should at least be definable
20:00:41 <jle`> instance (forall a b. Coercible (F a) (F b)) => Invariant F works, i think, for specific F
20:00:50 <koz_> Yeah, Coercible causes the problem of 'overlaps with everything ever'.
20:00:58 <koz_> Just in general.
20:01:14 <jle`> the overlapping problem is mostly that `Invariant f`, heh
20:03:49 <koz_> On a semi-related note, it's a pity that 'fmap coerce' is not the same as 'coerce'.
20:04:28 <jle`> because it depends on the type's implementation of fmap probably, right?
20:04:40 <jle`> instance Functor Maybe where fmap _ _ = Nothing
20:04:45 <boxscape> jle` fwiw `instance forall f . Functor => Invariant f` works fine so I don't think the forall is a problem
20:04:54 <boxscape> s/Functor/Functor f
20:05:04 <jle`> that sounds like a kind error
20:05:08 <jle`> oh i see
20:05:25 <koz_> jle`: Yeah, if you write law-breaking instances, it'd fail.
20:05:39 <koz_> But to be honest, Functor is so strong under parametricity it should _really_ be a compiler built-in.
20:25:07 <fresheyeball> Is there any way to mapT :: (a -> b) -> IO (TVar a) -> IO (TVar b) without allocating a new TVar?
20:25:52 <fresheyeball> (note: state needs to stay synced between the `TVar a` and `TVar b`
20:25:59 <fresheyeball> )
20:26:07 <dmj`> :t fmap . fmap
20:26:09 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
20:26:23 <fresheyeball> dmj`: TVar is not a Functor
20:26:52 <dmj`> fresheyeball: that blows
20:28:46 <dmj`> fresheyeball: then no
20:31:44 <c_wraith> well...  sort of
20:31:59 <c_wraith> Have you heard of our friend Coyoneda?
20:32:31 <fresheyeball> *raises hand, while shaking head*
20:32:51 <c_wraith> though...  "synchronized"?  Like, you want to keep both around and to have changes to one reflected in the other?
20:33:03 <c_wraith> Because that causes problems
20:33:12 <fresheyeball> yes, that is what I mean
20:33:14 <jle`> fresheyeball: yeah, you can only have it be write-only
20:33:14 <c_wraith> In particular, (a->b) isn't strong enough
20:33:29 <jle`> er, read-only
20:33:36 <jle`> Coyoneda TVar a is a read-only tvar
20:35:08 <jle`> Data.Functor.Contravariant.Coyoneda's Coyoneda TVar a is a write-only tvar
20:35:27 <iqubic> I don't understand Coyoneda at all.
20:35:42 <jle`> oh, there's an invariant Coyoneda too
20:36:18 <jle`> but i can't find it in any libraries
20:36:18 <koz_> And a profunctor one.
20:36:38 <iqubic> Coyoneda is werid. I wish I understood it, but I just don't.
20:36:40 <jle`> Invariant Coyoneda will give you a fully mappable TVar, but you need both (a -> b) and (b -> c), so that's not necessarily what you want
20:37:22 <koz_> iqubic: AFAICT, Coyoneda is like a free functor - it doesn't actually _do_ anything, but just tracks all the mappings.
20:37:37 <iqubic> I see. That's bizarre.
20:37:44 <koz_> iqubic: How is that bizarre?
20:37:50 <iqubic> I don't know.
20:37:51 <koz_> It's the same as the free Applicative, free Monad etc.
20:38:28 <c_wraith> It's a pretty natural idea when you discover some types can't be a Functor instance.  "Why don't I just pair it with a conversion function?"
20:38:30 <iqubic> What does the Coyoneda data type look like?
20:38:42 <jle`> https://hackage.haskell.org/package/kan-extensions-5.2.1/docs/Data-Functor-Coyoneda.html
20:38:42 <koz_> iqubic: Depends on which functor type you're trying to fake being.
20:39:15 <iqubic> Oh, there's no one single Coyoneda? It's different for each Functor?
20:39:38 <koz_> Yep.
20:39:53 <c_wraith> well.  There's a different Coyoneda for each type of functor
20:40:06 <c_wraith> But there's only one for covariant functors.
20:40:09 <iqubic> Weird. jle gave me this: Coyoneda :: (b -> a) -> f b -> Coyoneda f a.
20:40:28 <jle`> that's for covariant functors yeah, it gives you a free Data.Functor.Functor instance
20:40:31 <iqubic> Is that the covariant version of coyoneda?
20:40:31 <c_wraith> note: that's a constructor for a GADT, used to encode an existential
20:40:33 <jle`> for funsies, try writing it :)
20:40:41 <jle`> the Functor instance
20:41:11 <iqubic> I would do that, but it's 20 minutes to AoC, and I don't want to fry my brain to much before then.
20:41:45 <boxscape> Hm I can't quite see the difference between Yoneda and Coyoneda
20:41:48 <jle`> at least you know the next step in your path to understanding :)
20:42:08 <iqubic> boxscape: I assume you take the arrows of one and flip them to get the other.
20:42:33 <iqubic> That's what a categorical dual is, and the co- prefix implies categorical dual
20:42:49 <boxscape> `data Coyoneda f a where Coyoneda :: (b -> a) -> f b -> Coyoneda f a` versus `newtype Yoneda f a = Yoneda {    runYoneda :: forall r. (r -> a) -> f r  }` seems like the same thing
20:42:52 <boxscape> modulo strictness
20:43:22 <iqubic> I assume the forall r. changes things.
20:43:32 <boxscape> but there's an implicit forall b in the other one
20:43:38 <boxscape> no?
20:43:47 <fresheyeball> hmmm
20:44:17 <iqubic> Look at the types. Yoneda f a = ... makes no mention of r on the LHS. That means the r is a rank2 type.
20:45:00 <iqubic> Whereas Coyoneda is doesn't require Rank2 Types.
20:45:21 <boxscape> ah, that's true
20:45:24 <fresheyeball> ok I see
20:45:33 <iqubic> Now, how does that make them different? I have no bloody clue.
20:46:24 <boxscape> oh
20:46:30 <boxscape> the bracketing is different
20:46:39 <boxscape> Yoneda :: (forall r. (r -> a) -> f r) -> Yoneda f a
20:46:47 <boxscape> Coyoneda :: (b -> a) -> f b -> Coyoneda f a
20:46:59 <iqubic> Yes. That's right.
20:47:36 <iqubic> How does that make them different.
20:48:29 <fresheyeball> iqubic: Yoneda :: (a <- b) -> f b -> Yoneda f a
20:48:39 <fresheyeball> the first arrow is flipped
20:48:50 <iqubic> Not that I can see.
20:49:35 <boxscape> oh no
20:49:44 <boxscape> I accidentally copied the contrvariant yoneda
20:49:50 <boxscape> instead of the covariant one
20:50:24 <boxscape> flip the (r -> a) to (a -> r) to get the covariant one
20:51:02 <iqubic> Right. I see.
21:06:51 <MarcelineVQ> boxscape: you monster
21:07:01 <boxscape> what did I do
21:07:14 <MarcelineVQ> mixing variants
21:07:16 <boxscape> oh no
21:07:28 <boxscape> I apologize deeply
21:07:52 <MarcelineVQ> A note will be made on your permanent record.
21:08:20 <boxscape> :(
21:17:00 <crestfallen> hi I'm getting the error "Invalid input" from running > eval "2+(3*4)" . I've checked over the code thoroughly, and others online who've done the same exercise, their code also returns Invalid input. thanks for looking    https://gist.github.com/varreli/b32fa33506737c3b3fa0ff236dbe1c2c
21:20:11 <pavonia> crestfallen: It goes expr -> term -> factor -> symbol "(" and fails there
21:21:25 <crestfallen> pavonia: huh? thanks checking .. it compiles fine..
21:23:02 <pavonia> Well, I didn't check if it compiles, that's there the eval call fails
21:25:40 <crestfallen> pavonia: sorry please elaborate
21:28:55 <pavonia> crestfallen: Have you tried evaluating that expression by hand? It should be pretty obvious then that it tried to parse a "(" at the beginning of each expression
21:29:53 <monochrom> And more importantly, if that fails, there is no alternative to try.
21:36:22 <crestfallen> pavonia: sorry do I have an error in the factor function? I have it precisely how the book has it.
21:38:36 <pavonia> crestfallen: I guess the "<|> natural" part is supposed to refer to the do block, but it refers to the "return e"
21:39:14 <pavonia> So it the parsing of a parenthesized expression fails, the whole parser fails
21:40:37 <crestfallen> working thanks pavonia  ...
21:44:43 <crestfallen> no matter how I do the identation pavonia , it fails. can't get it..
21:46:08 <pavonia> You need parentheses. (do ...) <|> natural
21:48:25 <pavonia> or use applicative style: symbol "(" *> expr <* symbol ")" <|> natural
21:56:16 <crestfallen> pavonia: brutal no go; thanks for your help
21:59:44 <crestfallen> pavonia: I got it to compile with the applicative version, but the same error is returned
22:00:24 <pavonia> Could you paste the new code?
22:00:42 <crestfallen> sure
22:02:29 <ephemient>  rewrote part 2 to use a Sequence. I shoulda benchmarked before though, I don't know if it actually improved performance lol
22:02:55 <jle`> ephemient: wrong channel? :)
22:03:28 <ephemient> wrong yep, wrong channel.
22:04:20 <crestfallen> https://gist.github.com/varreli/0896128aa3fb2e7bc1c5f3e1ff420f11    sorry working on getting the whole thing pasted pavonia 
22:05:20 <crestfallen> http://ix.io/2Hg8   for now pls use this pavonia 
22:06:12 <pavonia> crestfallen: The other parsers have the same problem
22:09:36 <crestfallen> pavonia: I'm sort of lost. I'm not sure how it chooses the parenthesized expressions first
22:10:27 <crestfallen> aside from why it won't evaluate any expression
22:11:21 <boxscape15> is maximum faster on a list than on a Seq?
22:13:26 <pavonia> crestfallen: When you have something like `do foo; return blah <|> natual`, it's parsed as `do foo; (return blah <|> natual)`. But this is not what you want. You want to try the do-block first, and if it fails use the other alternative after <|>. To accomplish that you make the parser aware that the alternative is not part of the do-block by using parentheses
22:17:09 <pavonia> crestfallen: Not the best style, but it should work to just wrap each whole do-block before <|> in parentheses
22:18:12 <crestfallen> pavonia: I got this to compile and evaluate: http://ix.io/2Hg9
22:18:48 <crestfallen> but the book and others online have it as I've pasted it. maddening!
22:20:50 <pavonia> Are you sure they have exactly the same thing, not a slightly different indentation for example?
22:23:21 <crestfallen> no not sure, at least in the book, since it is a kindle cloud reader book, and the indentation is way off. but I tried a few solution sets on github and every version returns [] or error Invalid input pavonia 
22:23:50 <crestfallen> they all compile fine
22:25:26 <crestfallen> but the logic is what I'm more curious about. Like how those expr -> term -> factor -> natural act recursively. It is dawning on me a bit...
22:25:29 <crestfallen> pavonia: 
22:25:45 <pavonia> Yeah, all your parsers are of type Parser Int which can make incorrectly indented code still compile fine. Yo usually have many different return types such that indentation errors pop up more often
22:37:42 <Axman6> boxscape15: benchmark it and find out, possibly?
22:37:51 <boxscape15> I suppose I should
23:07:20 <gedda> sometimes, just sometimes, containers are really frustrating
23:07:39 <gedda> Why doesn't Data.Set implement construction from a Traversable?
23:08:21 <gedda> am I forced to use an intermediate list when going from Vector -> Set?
23:17:40 <koz_> gedda: foldr Set.insert Set.empty myVector works?
23:17:49 <koz_> No intermediate lists there.
23:21:29 <koz_> % import qualified Data.Set as Set
23:21:30 <yahb> koz_: 
23:21:38 <koz_> % :t foldr Set.insert Set.empty
23:21:38 <yahb> koz_: (Foldable t, Ord a) => t a -> S.Set a
23:21:46 <koz_> gedda: ^
23:22:02 <jle`> gedda: it's not a Traversable because then it'd need to be a Functor
23:22:14 <koz_> jle`: _From_ a Traversable.
23:22:27 <jle`> ah, i did read too fast :)
23:22:30 <koz_> (I had to re-read it a few times too)
23:22:48 <jle`> gedda: i feel like you'd create no intermediate list if you did S.fromList . V.toList
23:23:00 <jle`> that full list will never be allocated
23:23:31 <koz_> jle`: Yeah, but using the method above, you can be _sure_.
23:24:04 <jle`> fair enough :)
23:25:35 <gedda> koz_, thanks! Very clever, was looking at foldr in Set and not in Vector for the answer
23:25:47 <koz_> gedda: foldr is more general.
23:25:49 <koz_> :t foldr
23:25:56 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:26:11 <koz_> It'll fold basically anything even remotely container-shaped.
23:26:16 <koz_> (along with some things which aren't)
23:26:29 <koz_> % :t foldr @Maybe
23:26:29 <yahb> koz_: (a -> b -> b) -> b -> Maybe a -> b
23:26:52 <koz_> % :t foldr @Proxy
23:26:52 <yahb> koz_: (a -> b -> b) -> b -> Proxy a -> b
23:26:53 <gedda> man I must have missed that foldr in Prelude was on Foldable and not a List
23:27:14 <koz_> % :t foldr @Identity
23:27:14 <yahb> koz_: (a -> b -> b) -> b -> Identity a -> b
23:28:16 <koz_> There's a cuter way to do Vector -> Set.
23:28:23 <koz_> % :t foldMap Set.singleton
23:28:23 <yahb> koz_: (Foldable t, Ord a) => t a -> S.Set a
23:29:41 <gedda> thats actually pretty neat, I'll go with that one, thanks!
23:30:58 <koz_> jle` can probably come up with an even cuter one.
23:31:49 <gedda> :t maybe id
23:31:52 <lambdabot> (a1 -> a2 -> a2) -> Maybe a1 -> a2 -> a2
23:32:00 <koz_> :t fromMaybe
23:32:02 <lambdabot> a -> Maybe a -> a
23:32:10 <gedda> which would be the same as foldr @Maybe?
23:32:29 <koz_> % foldr (+) 0 (Maybe 10)
23:32:29 <yahb> koz_: ; <interactive>:133:14: error:; * Data constructor not in scope: Maybe :: t1 -> t0 b; * Perhaps you meant variable `maybe' (imported from Prelude)
23:32:34 <koz_> % foldr (+) 0 (Just 10)
23:32:34 <yahb> koz_: 10
23:32:39 <koz_> % foldr (+) 0 Nothing
23:32:39 <yahb> koz_: 0
23:33:09 <jle`> foldr f z = maybe z (`f` z)
23:33:48 <gedda> seems like I've severly underestimated foldr
23:34:01 <koz_> gedda: foldr is an all-purpose wonder-weapon for smashing containers.
23:34:10 <koz_> (so's foldMap, and it's usually cuter while doing it)
23:34:25 <koz_> For example, here's a definition of 'toList':
23:34:30 <koz_> % :t foldMap pure
23:34:30 <yahb> koz_: (Foldable t, Monoid (f a), Applicative f) => t a -> f a
23:34:45 <koz_> (it'll do a bunch more than that, but toList is one possible use)
23:35:41 <koz_> And here's one of 'length':
23:36:13 <koz_> % :t getSum . foldMap (\_ -> Sum 1)
23:36:13 <yahb> koz_: (Foldable t, Num c) => t a -> c
23:36:49 <koz_> % :t getSum . foldMap (Sum . const 1) -- for maximum pointless
23:36:50 <yahb> koz_: (Foldable t, Num c) => t b -> c
23:38:14 <gedda> I need to find more reasons to use haskell 
23:38:27 <gedda> outside of advent of code 
23:38:44 <koz_> gedda: Get a job Haskelling.
23:38:52 <koz_> That's a pretty good reason. :P
23:39:12 <int-e> koz_: that one has a bootstrapping problem though :P
23:39:28 <koz_> int-e: Yeah, I admit I was a Haskeller for fun long before I was one for profit.
23:39:44 <iqubic> @quote jle` sleep
23:39:44 <lambdabot> jle` says: let sleep = pure "zzz" in getSum sleep
23:42:06 <gedda> Yeah would love to, but the offerings are slim to none in the areas I work with
23:42:32 <gedda> From what I've seen, finance seems to use Haskell the most?
