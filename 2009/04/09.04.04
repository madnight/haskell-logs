00:02:04 <Gracenotes> > let replace str from to = step x where y = length from - 1; x = tails str; step [[]] = []; step (x:xs) = if from `isPrefixOf` x then to ++ step (drop y xs) else head x : step xs in replace "I think there is something fishy with this whole affair, dear sir!" "e" "!!"
00:02:06 <lambdabot>   "I think th!!r!! is som!!thing fishy with this whol!! affair, d!!ar sir!"
00:02:14 <Gracenotes> ^ loupgaroublond
00:03:02 <Gracenotes> should be somewhat fast; the only efficiency I can spot is that it is checks isPrefixOf and drops the length separately, going through the same characters twice
00:03:45 <Gracenotes> it might be good to have a second recursive helper function that checks if something is a prefix and also yields the new xs to pass to step again, if that's the case
00:03:51 <Gracenotes> @src isInfixOf
00:03:52 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
00:04:02 <Gracenotes> hm.
00:04:27 <Gracenotes> and the same functions exist with bytestrings
00:04:44 <Gracenotes> anyway, just one way of doing it
00:07:39 <Gracenotes> a more straightforward way would be to get a split function (perhaps from Data.Split), split at the occurrences of 'from', and then intercalate with 'to'
00:07:56 <loupgaroublond> i was thinking that, bytestring has a split function
00:09:07 <Gracenotes> I'm not sure if any of the split functions would be useful though
00:09:59 <loupgaroublond> split
00:10:00 <loupgaroublond> a
00:10:03 <loupgaroublond> splitAt
00:10:09 <loupgaroublond> it takes an index
00:10:38 <loupgaroublond> there's also a find that returns a list of indexes for each occurence of some string
00:10:39 <Gracenotes> yes, but to get the index of the list you have to go through it once
00:10:55 <Gracenotes> oh, here's a useful one: breakSubstring!
00:11:01 <Gracenotes> yeah
00:11:36 <Gracenotes> just keep on applying breakSubstring until it can't break it up anymore
00:12:02 <Gracenotes> (recursively)
00:12:05 <jml> @src words
00:12:06 <lambdabot> words s = case dropWhile isSpace s of
00:12:06 <lambdabot>     "" -> []
00:12:06 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:14:28 <Gracenotes> replace functions really should be in the general library...
00:15:18 <NameAlreadyInUse> what is the "expression problem" that i sometimes read about in regards to functional languages?
00:16:17 <dolio> It's a problem in general.
00:16:31 <BMeph> Gracenotes: Congratulations! I've got something I was keeping on my computer monitor, but I think you need it more... ;p
00:16:45 <NameAlreadyInUse> dolio: what is the problem in general then?
00:17:01 <Gracenotes> BMeph:  :o
00:17:01 * BMeph puts his "UR DOIN IT RONG!" sign around Gracenotes' neck.
00:17:02 <dolio> With regard to functional languages, it's the difficulty of extending types with new constructors.
00:17:29 <wli> dolio: Hmm?
00:17:38 <dolio> You can define new functions over a type easily, but if you add a constructor, you need to add cases to every existing function.
00:17:39 * Gracenotes staple-guns "NO U" onto BMeph
00:17:47 <wli> <interactive>:1:0: Not in scope: `breakSubString'
00:18:06 <Gracenotes> lowercase s
00:18:13 <dolio> Or at the very least, every function where the new constructor matters.
00:18:52 <NameAlreadyInUse> dolio: is there an example of this in Haskell? i am having trouble visualizing what you mean
00:19:24 <jedai> NameAlreadyInUse: Imagine you have a type : data Machin = One Int | Two Int Char
00:19:45 <jedai> You have a lot of functions working on it
00:20:23 <jedai> You then need to change this type by adding a constructor : data Machin = One Int | Two Int Char | Three Int Char String
00:21:02 <jedai> Almost every function that worked on this type now need to be changed
00:21:27 <beelsebo_> jedai: yep, this is the dichotomy of functional and OO programs
00:21:36 <beelsebo_> in functional, changing the data makes you change your functions
00:21:44 <beelsebo_> in OO changing a function makes you change almost all data
00:21:49 <dolio> By contrast, object oriented language typically make it easy to define what would be similar to new construtors for a type (though inheritance and subtyping) that work with existing functions, but it's more difficult to define new arbitrary functions over them.
00:21:49 <jedai> The expression problem is that you can't make this "upgrade" from outside your source module for exemple
00:22:06 <dolio> The expression problem is to do both well.
00:22:24 <jedai> dolio say it better
00:22:30 <NameAlreadyInUse> are there possible solutions to this?
00:22:41 <wli> The thing extensible variants do is that you can handle more cases and get static checking that the cases in the actual type are a subset of what you handle.
00:22:46 <jedai> There are propositions, none perfect
00:22:49 <beelsebo_> NameAlreadyInUse: there are workarounds in a lot of cases
00:23:11 <beelsebo_> often using accessors for your data types means you only need to change the accessors
00:23:13 <beelsebo_> not all functions
00:23:46 <wli> Extensible record uses establish lower bounds, and extensible variant uses establish upper bounds.
00:24:49 <dolio> I think there's a Design Pattern (TM) that illustrates the difficulty in the OO case, but I forget which it is.
00:25:00 <dolio> That is, the fact that you need a design pattern is evidence of the weakness.
00:25:45 <jedai> dolio: I think that in general the idea of design patterns show a lack of abstraction power
00:25:55 <ivanm> this function here takes up about 100% of the runtime of my app: removeIsomorphisms = map fst . nubBy ((==) `on` snd) . map (ap (,) (canonicGraph . toGraph))
00:26:01 <wli> gtk2hs itself is failng to build
00:26:21 <NameAlreadyInUse> there is an obsession with design patterns in the OO community as far as i can tell
00:26:38 <ivanm> can anyone think of a more efficient way of doing it?
00:26:53 <ivanm> or is my best bet to reduce the size of the list I'm passing to it?
00:27:03 <ivanm> NameAlreadyInUse: you've just noticed? ;-)
00:27:23 <jedai> ivanm: nubBy is pretty inneficient, most of the time there's a better solution
00:27:35 <dolio> If you want an example of alleviating the Haskell end of the problem, I think Datatypes a la Carte is an example of how to build your datatypes such that you can extend both types and functions nicely.
00:27:47 <dolio> But it isn't how you'd typically structure a Haskell program.
00:27:52 <ivanm> jedai: there wouldn't be that many unique elements (I think) involved
00:27:53 <jedai> ivanm: Like passing by a Map or something like that
00:28:14 <ivanm> jedai: I thought using a Map or a Set would remove the laziness...
00:28:14 <jedai> ivanm: nubBy is O(nÂ²)
00:28:19 <ivanm> jedai: no it isn't
00:28:35 <jedai> ivanm: ok it's O(nm)
00:28:36 <ivanm> it's O(n*m), where n is the length and m is the number of unique elements
00:29:44 <jedai> ivanm: I would still try to avoid it I think, even if m is small
00:30:08 <ivanm> well, I still need the laziness which nubBy provides
00:30:38 <wli> I'm not sure you can get away with laziness.
00:31:17 <BMeph> Lazyness is kind of useless to you, ivanm, since you're looking at all of your graphs. :)
00:31:19 <dolio> If you allowed Ord, you could get it down to O(n log m)
00:31:35 <ivanm> BMeph: there's a whole heap of graphs... which I'm doing more stuff till afterwards
00:31:56 <ivanm> (well, they're not actually graphs...)
00:32:54 <ivanm> dolio: using the whole group . sort thing?
00:33:05 <BMeph> ivanm: I'd be tempted to throw them in a Set, before using nubby nubBy that way. :)
00:33:23 <dolio> No, I think that would be n log n. I was thinking of using a Set to track seen elements.
00:33:31 <wli> Keep a seen set or Set.toList . Set.fromList
00:33:34 <ivanm> BMeph: I'm potentially dealing with a _lot_ of elements, which I'm then filtering through afterwards...
00:33:37 <dolio> Building such a set is m log m, and looking things up is log m.
00:33:44 <ivanm> dolio: ahhh...
00:33:51 <dolio> So you get O(n log m + m log m), but m <= n.
00:34:14 <wli> O((n+m)*lg(m))
00:34:33 <ivanm> dolio: how would that be more efficient than nubBy? because using Ord, you're not looking at all values, just log of them?
00:35:09 <dolio> Yeah. You have a balanced search tree of seen elements instead of a list.
00:35:47 <ivanm> *nod*
00:36:04 <ivanm> I'm not even sure where the choking point of that function is though...
00:36:22 <ivanm> I'm more tempted to think canonicGraph is it, if only to blame some-one else for the slowness ;-)
00:37:56 <wli> You're just trying to do nubBy?
00:38:30 <ivanm> removeIsomorphisms = map fst . nubBy ((==) `on` snd) . map (ap (,) (canonicGraph . toGraph)) <-- this is the function I'm talking about
00:39:04 <ivanm> dolio: so just do a foldr over the list, keeping an element if it's in the set?
00:39:11 <ivanm> *Set
00:39:25 <dolio> If it's not in the set.
00:39:42 <ivanm> ummm, yeah
00:39:47 <ivanm> I meant that ;-)
00:39:51 <dolio> But I'm not sure foldr works.
00:40:01 <Gracenotes> O:
00:40:06 <dolio> Because you have to pass along the set from the front of the list.
00:40:44 <ivanm> I thought foldr was used when you're traversing a list and keeping the elements...
00:40:48 <dolio> It's more of an unfoldr.
00:40:53 <ivanm> hmmm....
00:40:59 <ivanm> @type unfoldr
00:41:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:41:15 <jklk> show adds the \" to a string, what's the inverse called?
00:41:29 <Eridius> read?
00:41:51 <ivanm> well, that doesn't really match it...
00:42:04 <ivanm> @type foldr
00:42:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:42:24 <Eridius> ivanm: maybe filter?
00:42:29 <ivanm> I was thinking mapAccum...
00:42:38 <ivanm> Eridius: except the condition is changing as you go along ;-)
00:42:41 <Eridius> ah
00:42:42 <ivanm> hence filter fails :s
00:42:59 <ivanm> @src filter
00:43:01 <lambdabot> filter _ []     = []
00:43:01 <lambdabot> filter p (x:xs)
00:43:01 <lambdabot>     | p x       = x : filter p xs
00:43:01 <lambdabot>     | otherwise = filter p xs
00:43:05 <ivanm> ^^ is this how it's really defined?
00:43:08 <wli> @type catMaybes . snd . mapAccumL (\s x -> if x `Data.Set.member` s then (s, Nothing) else (Data.Set.insert x s, Just x)) Data.Set.empty
00:43:09 <lambdabot> forall x. (Ord x) => [x] -> [x]
00:43:34 <ivanm> I thought it would have been written as a foldr...
00:43:59 <ivanm> wli: yeah, I was thinking of something like that, but something that would let me remove elements directly would probably be better...
00:44:03 <ivanm> maybe I need a manual loop...
00:46:01 <wli> @type let uniq xs = unfoldr (\(s, ys) -> case dropWhile (`Data.Set.member` s) ys of { z : zs -> Just (z, (Data.Set.insert z s, zs)) ; [] -> Nothing }) (Data.Set.empty, xs) in uniq
00:46:03 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:46:08 <jklk> eridi, read converts to value, i guess i am looking for a strip that takes away " instead of whitespaces
00:47:00 <Lesco> jklk: You could use dropWhile and takeWhile
00:47:01 <Gracenotes> ivanm: that's how filter is really defined
00:47:05 <wli> ivanm: unfoldr rules
00:47:29 <Lesco> jklk: At least if you only want to remove at the beginning/end.
00:47:30 <Gracenotes> ivanm: however, it's automatically rewritten as a foldr for efficiency reasons if composed with any other list functions
00:47:49 <ivanm> wli: gah! you and your code golfing!
00:47:54 <ivanm> Gracenotes: due to fusing?
00:48:00 <Gracenotes> yep
00:48:02 <wli> ivanm: What golfing?
00:48:13 <jklk> lesco, i may run into a Maybe, as some strings do and some do not have "
00:48:23 <ivanm> wli: coming up with more and more complicated versions ;-)
00:48:48 * jklk is cleaning up an ugly export
00:49:02 <wli> It's not complicated. It's just more accurately reflecting/abstracting the recursion pattern.
00:49:22 <Gracenotes> ivanm: also, according to the source there are rules for fusing two filters together
00:49:29 <Gracenotes> with &&
00:49:33 <ivanm> *nod*
00:49:59 <ivanm> wli: no offence, but I'm thinking a manual loop might be nicer/easier ;-)
00:51:54 <wli> @type let uniq = let uniq' _ [] = [] ; uniq' s (x : xs) | x `Data.Set.member` s = uniq' s xs | otherwise = x : uniq' (Data.Set.insert x s) xs in uniq' Data.Set.empty in uniq
00:51:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:53:27 <Gracenotes> hm. How are C libraries that have special delete-struct-pointer functions handled with FFI?
00:54:06 <ivanm> wli: which is basically what I'm using
00:54:09 <Gracenotes> putting it all in a monad and allocating/freeing the resources when it's actually run?
00:54:46 <Gracenotes> in the C source, the call would be delete_blah(&my_blah)
00:55:00 <wli> Gracenotes: no clue
00:55:02 <ivanm> Gracenotes: with manual fiddling?
00:55:07 <ivanm> *shrug*
00:55:59 <Gracenotes> hm. I'll have to look into it; I know the Cairo library does this with the Render monad though. *checks out the source*
00:57:17 * edwardk has been trying to make reverse mode ad work with an indexed state monad for hours to no avail. it seems like it should work but i keep coming up short.
00:57:56 * edwardk contemplates 'indexed arrows' ;)
00:58:24 <edwardk> er wait i guess those are just gadt arrows
01:03:10 <dolio> Did you ever figure out that product category?
01:03:41 <edwardk> dolio: no, i'm not sure what i did
01:03:56 <edwardk> dolio: i had to hedge on a similar thing for the monoid category too
01:04:25 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Categorical.html isn't quite right
01:05:35 <edwardk> it cheats by hiding the constructors so you can't abuse them, but you have access to id for any haskell type, even if you only have the ability to construct arrows for values in your monoid due to hiding
01:06:39 <dolio> Which part is wrong?
01:08:04 <dolio> Should M :: Monoid m => m -> CMonoid m m m or some such?
01:08:09 <edwardk> yeah
01:09:30 <edwardk> i've been tempted to take a page from heffalump's book, and make an RCategory which uses a 'Suitable' class like he has
01:09:47 <edwardk> er like he has for RMonad, etc.
01:10:07 <dolio> We need our class families.
01:12:16 <wli> I wish I understood the issues with typeclasses vs. ML-style modules.
01:12:45 <edwardk> wli: oh hrmm didn't chakravarty and some folks have a paper on the distinction or lack there of? or maybe i have the people wrong
01:13:29 <edwardk> dolio: i'm trying to figure out how to use the general approach from http://www-sop.inria.fr/tropics/papers/HascoetArayaRR06.pdf inside an indexed state monad, ideas?
01:13:35 <wli> I saw a paper by Chakravarty on some sort of interaction between the two.
01:13:37 <dolio> Type classes are modules where you're only allowed one module for each type, and they're passed around automatically for you.
01:13:42 <wli> I did not understand t.
01:13:58 <edwardk> http://www.cse.unsw.edu.au/~chak/papers/WC08.html
01:14:52 <edwardk> right above section 2.4 it provides a nice little table of what in ml maps onto what in haskell
01:16:46 <dolio> edwardk: There are type classes in here somewhere?
01:17:00 <wli> If I wanted to hand-write the output of what should be a machine translation I wouldn't be so interested...
01:17:09 <Gracenotes> are there any very good FFI-based libraries I could peruse the source of?
01:17:19 <edwardk> dolio: which one? the one for wli? or the link i sent you seeking insight? =)
01:17:27 <Gracenotes> finding best practice and so on
01:17:32 <dolio> The automatic differentiation one.
01:18:07 <edwardk> dolio: nope. just what seems to me to be an indexed monad or indexed applicative or something
01:18:46 <edwardk> pages 5 and 6 are what jump out at me
01:19:29 <wli> What are you trying to do with automatic differentation?
01:19:45 <edwardk> for suitable definitions of push :: s -> State i (s,i) () -- and pop :: State (s,i) i s -- or something like that
01:20:02 <edwardk> wli: the forward ad case is kind of important for my tokenizer
01:20:44 <wli> edwardk: This must be a different affair from the zero testing of expressions affair.
01:20:46 <edwardk> wli: the reverse ad stuff is because i started a conversation with pearlmutter on the topic and was trying to figure out either why you can't do reverse mode ad in haskell or come up with a clunky derivation that everyone would run screaming from
01:21:56 <edwardk> wli: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers2/ gives an example of using forward ad in the kind of limited setting i've been talking about
01:22:06 <edwardk> heya Beelsebob
01:22:14 <Beelsebob> hey edwardk
01:23:30 <edwardk> i was greatly amused when i saw you make a comment to the effect that "itâs entirely possible that tomorrow someone will come up with a parsing technique that works backwards/forwards/in some random other order." in your how you shouldn't use monads post =)
01:23:43 <wli> edwardk: I presume you're not dealing with integral bases of algebraic extension rings of Q(x) nor elementary nor monomial extensions thereof.
01:24:53 <dolio> edwardk: Well, I see what you're saying about indexed state with a stack of values.
01:24:55 <edwardk> wli: alas not. i have some differential seminearrings, differential rings and some modules over seminearrings that i can use AD on in interesting ways
01:25:46 <edwardk> dolio: i've gotten to where i have several thing that almost make sense, but are embarrassingly wrong which is a frustrating point to be at
01:29:55 <edwardk> dolio: i've even go so far as to try to model it in an arrow assuming i can drop down to the monad later. with something crazy like:
01:29:59 <edwardk> Step :: (a `Module` a', b `Module` b') => (a -> b) -> (a -> b' -> a') -> D s a a' :~> D s b b'
01:30:06 <ezero> wow so many haskell programmers :D
01:30:14 <edwardk> ezero: there are a lot of us =)
01:30:24 <ezero> heh didn't realise it untill now!
01:30:25 <ezero> lol
01:30:31 <ezero> thats great :)
01:31:02 <ezero> i jusit started hacking haskell
01:31:05 <dolio> edwardk: You know, actually...
01:31:15 <BMeph> edwardk: Do you remember seeing the implementation of "backwardsw State", where it (the state) gets threaded in backwards in relation to the "value"?
01:31:21 <edwardk> BMeph: yeah
01:31:32 <Gracenotes> unsafePerformIO is pretty common with FFI, I'm guessing..
01:31:34 <dolio> It reminds me of Oleg's dynamically scoped variables built with delimited continuations.
01:31:37 <edwardk> BMeph: i've been toying with a backwards indexed state implementation
01:32:07 <BMeph> edwardk: Oh, so it's actually relevant to what you're doing? Great! :)
01:32:16 <sioraiocht> ezero: There are dozens of us!
01:32:32 <sioraiocht> ...arrested development reference, anyone?
01:32:42 <ezero> I have a simple question if someone can answer .. sum( map (^2) [1..10]) .. i just want to replace the [a..b] where a = Enum andb = Integer how can i use variables to replace them
01:33:00 <ezero> like sum( map (^2) [a..b])
01:33:16 <edwardk> dolio: yeah. one thing to note is that i think with a suitable arrow it can probably not have to be indexed. since the intermediate push/pops are for destructive updates and we aren't destructive, so the push and pops can vanish from the system thanks to the power of lambda
01:33:16 <dolio> edwardk: Used like an ST equivalent of Reader. Where they're replacing the destructive assigment with the mutable reference equivalent of local.
01:33:21 <BMeph> Say, does any one recall if there's a package that has provision for continued fractions, and exposes them for use?
01:33:27 <Gracenotes> ezero: some spacing
01:33:30 <mauke> ezero: what do you mean by "a = Enum"?
01:33:59 <mauke> > let a = 1; b = 10 in sum (map (^2) [a..b])
01:34:00 <sioraiocht> ezero: a and b must be the same time
01:34:00 <lambdabot>   385
01:34:07 <sioraiocht> *type
01:34:19 <ezero> really
01:34:26 <edwardk> BMeph: haven't seen one
01:34:42 <sioraiocht> [x..y] is just syntactic sugar for enumFromto
01:34:44 <wli> I've seen several, NFI where they went though.
01:34:44 <sioraiocht> :t enumFromTo
01:34:46 <lambdabot> forall a. (Enum a) => a -> a -> [a]
01:35:12 <ezero> I see. let me try
01:35:14 <sioraiocht> it's polymorphic in the Enum type class, but in [x..y] x and y and have to be SAME type in the enum class
01:35:34 <mauke> > [' ' .. '~']
01:35:35 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
01:36:46 <ezero> so this is my method definition
01:36:47 <ezero> summation :: Enum(x) -> x -> (x -> x -> x) -> Integer
01:36:50 <ezero> sorry thats wrong
01:37:00 <ezero> summation :: x -> x -> (x -> x -> x) -> Integer
01:37:00 <dolio> edwardk: Where 'I_n ...' which contains "set foo e" is replaced by 'dlet foo e (...) >> I_n-reverse'.
01:37:02 <edwardk> dolio: what i'm kind of half seeing is that i want a forward state monad for the ring, and a backward state monad for propagating back the value in the module over the ring that i'm differentiating with
01:37:10 <edwardk> hrmm
01:37:24 <ezero> summation 0 10 (^2)
01:37:32 <ezero> i want it to return the same result as my earlier expression
01:37:33 <edwardk> i recall the dlet stuff, and its powerful enough to encode anything so you're probably right, but i'm not sure i understand its application here
01:37:42 <mauke> ezero: impossible with that type
01:37:52 <ezero> ah no wonder i was stuck
01:37:52 <Berengal1> ezero: You need that to be summation :: x -> x -> (x -> x -> Integer) -> Integer
01:37:52 <ezero> lol
01:37:56 <mauke> also, summation 0 10 (^2) doesn't even compile
01:38:27 <edwardk> @type (^)
01:38:28 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:38:32 <ezero> no - thats how i am going to call the method
01:38:36 <mauke> > :t let summation a b f = sum (map f [a .. b]) in summation
01:38:37 <lambdabot>   <no location info>: parse error on input `:'
01:38:40 <mauke> :t let summation a b f = sum (map f [a .. b]) in summation
01:38:41 <lambdabot> forall a a1. (Num a1, Enum a) => a -> a -> (a -> a1) -> a1
01:38:58 <ezero> thats exaclty what i had mauke
01:39:00 <dolio> edwardk: Thinking about it now, it's probably not a very profound realization. Just that their transform is replacing destructive assignment with nested local scopes.
01:39:24 <ezero> summation a b c = sum (map c [a..b])
01:39:35 <mauke> ok, so where's the problem?
01:39:48 <edwardk> dolio: yeah, whats interesting me is that we never destructively modify anything with a lambda so the PUSH/POP nonsense should be able to vanish
01:39:52 <dolio> Because they need to post-process using the original value.
01:40:22 <ezero> mauke let me see after making some fixes suggested by Berengal1
01:40:30 <edwardk> just need a sufficiently tricky way to tie off the loop
01:41:31 <dolio> But it's still not a simple transform, because you need to turn "put x >> rest" into "local (const x) rest".
01:41:36 <ezero>     Couldn't match expected type `Integer'
01:41:36 <ezero>            against inferred type `x -> Integer'
01:41:44 <Berengal1> ezero: I was thinking of a slightly different implementation than what you have in mind
01:41:55 <ezero> ah right
01:42:03 <dolio> Which is non-local.
01:42:18 <Berengal1> You want :: x -> x -> (x -> Integer) -> Integer
01:42:24 <edwardk> i can see the fact that i want a 'region variable' to keep you from accessing the result from the backwards half of the state monad while you're computing forward. so we can get separation of forward/backward runs by using an operator like d :: (a `Module` a', b `Module` b' (forall s. D s a a' -> RAD (D s b b')) -> a -> RAD (b,b') -- or something like that
01:42:31 <edwardk> er
01:42:48 <ezero> yup thats what i have Berengal1
01:43:02 <edwardk> d :: (a `Module` a', b `Module` b') =>  (forall s. D s a a' -> RAD (D s b b')) -> a -> RAD (b,b')
01:43:08 <ezero> Could not deduce (Enum x) from the context ()
01:43:15 <ezero> that was my initial problem
01:43:45 <edwardk> which would create a local scope and pass a distinct infinitesimal into the supplied function
01:43:46 <mauke> (Enum x) => x -> x -> (x -> Integer) -> Integer
01:43:49 <ezero> map (^2) [1..10] :: (Num a, Enum a) => [a]
01:43:51 <Berengal1> ezero: Oh, right. Put "(Enum x) => " in front of the type
01:44:04 <ezero> so in the constraints
01:44:45 <ezero> yay thanks :D
01:44:59 <ezero> so i was just missing that constraint
01:45:01 <edwardk> but it may be that instead of d :: (a `Module` a', b `Module` b') =>  (forall s. D s a a' -> RAD (D s b b')) -> a -> RAD (b,b') -- that has to look more like d :: (a `Module` a', b `Module` b') => (forall s. D s a a' :~> D s b b') -> a :~> (b,b') in an arrow
01:45:33 <edwardk> heya lennart
01:45:50 <edwardk> beating our heads on reverse mode ad, ideas? =)
01:45:56 <Berengal1> ezero: Yes. The compiler should be able to infer the type, so you could've asked it for it :)
01:46:23 <ezero> heh .. awsome now i won't be loosing any sleep over it
01:47:27 <ahamay42> what's wrong with http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2040#a2040?
01:48:12 <edwardk> ahamay42: compile doesn't know which 'x' to use in its type signature
01:48:29 <edwardk> for that matter Executable doesn't know which a and b to use in its type signature
01:48:44 <edwardk> because 'comp' doesn't include a reference to a and b in the type
01:48:49 <ahamay42> so I can't have the x only in the LHS?
01:48:59 <ahamay42> or what's the fix?
01:49:33 <edwardk> without understanding your purpose you could change class Executable x a b => Compilable x a b | x -> a b where comp :: x -- that would type check. but then to get compile to typecheck you'd have to have the other fundep as well that a b -> x.
01:49:57 <edwardk> so class Executable x a b => Compilable x a b | x -> a b, a b -> x where comp :: x
01:50:10 <edwardk> but i have no idea at all if that is useful
01:50:45 <ahamay42> I think x should depend on a and b, but not the other way
01:50:54 <ahamay42> I mean for my modelling
01:51:15 <edwardk> ahamay42: if you can't get from x to a and b then you can't define 'comp' the way you have it
01:51:46 <ahamay42> well, the idea is to have different sorts of "computation" that all can be translated to IOArrow
01:52:00 <ahamay42> though they are not necessarily arrows themselves
01:52:30 <ahamay42> and they may not have a type signature with a and b in that order
01:52:44 <edwardk> ahamay42: not sure if its useful, but you might look at my implementation of representable functors: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Representable.html
01:53:18 <mitsosmitsaras> Hi a program i need to check uses a library called ParseLib. Is it well-known. If so where i can find it? (note: i am completely newcomer)
01:53:38 <edwardk> which is concerned with a similar concept of going back and forth between in my case a morphism and the image of a value under a functor
01:53:39 <ahamay42> for example, i want
01:53:39 <ahamay42> instance Executable (Parser s () a) s a
01:53:51 <ahamay42> I'll check it out, thx
02:05:15 <ahamay42> edwardk: maybe your way with both dependencies a b -> x, x -> a b is the solution for my purpose - thx
02:05:28 <edwardk> ahamay42: no problem
02:17:20 <NameAlreadyInUse> i am attempting to learn template haskell, but i am having a bit of trouble understanding why "test :: Maybe $(tupleT 4)" doesn't work
02:17:57 <NameAlreadyInUse> tupleT is Int -> TypeQ, so shouldn't i be able to splice that to get "Maybe (a,a,a,a)"?
02:19:18 <Gracenotes> NameAlreadyInUse: I don't think you can be expressions in types, can you? Is that allowed with TH?
02:19:29 <edwardk> Gracenotes: its definitely allowed
02:19:39 <edwardk> NameAlreadyInUse: is the type fully applied that it yields?
02:19:48 <Gracenotes> *have
02:20:02 <edwardk> NameAlreadyInUse: or does it need to have an appT or whatever applied to tie it to 'a'
02:20:50 <NameAlreadyInUse> edwardk: i am not sure, maybe it does. is there any way of knowing?
02:21:11 <edwardk> test :: Maybe ($tupleT 4 `appT` ''Int `appT` ''Int `appT` ''Int `appT` ''Int)
02:22:02 <edwardk> tupleT n should yield a type expression that expects to be 'appT'd n times to different types to yield a tuple of those n types.
02:22:48 <NameAlreadyInUse> i get a parse error on "$"
02:22:56 <edwardk> er sorry move the $ outside of the (
02:23:03 <edwardk> Maybe $(tupleT 4 ...)
02:23:43 <NameAlreadyInUse> now a parse error on "$(", but i have the TemplateHaskell extension enabled
02:24:12 <Gracenotes> are you allowed to foldr on appT?
02:24:49 <edwardk> yeah you can do crazy list comprehensiony things
02:25:13 <Gracenotes> replicate 5 ''Int
02:25:23 <Gracenotes> or 4
02:25:40 <edwardk> hah use foldl instead ;)
02:25:49 <edwardk> clearer for once
02:26:28 <Gracenotes> huh. seems so.
02:26:54 <edwardk> @typle foldl
02:26:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:27:05 <NameAlreadyInUse> i can use the splice syntax elsewhere, but it doesn't seem to work in the type signature
02:27:31 <Gracenotes> foldl appT <$> tupleT <*> flip replicate ''Int
02:27:33 <edwardk> i have used it in there for years
02:27:51 <Gracenotes> a pretty little expression it is! :X
02:28:20 <edwardk> @type  foldl appT <$> tupleT <*> flip replicate ''Int
02:28:22 <lambdabot> lexical error in string/character literal at character '\''
02:28:32 <edwardk> bah, bad lambdabot
02:30:20 <edwardk> @type foldl appT <$> tupleT <*> flip replicate (conT (mkName ("Int"))
02:30:21 <lambdabot> parse error (possibly incorrect indentation)
02:30:29 <edwardk> bah
02:30:58 <edwardk> @type appT
02:31:00 <lambdabot> Not in scope: `appT'
02:31:03 <Gracenotes> hm, yeah, I can't figure how to make ''Int into a [TypeQ]
02:31:05 <edwardk> ok, TH just isn't in scope
02:31:17 <Gracenotes> *TypeQ
02:31:27 <Gracenotes> but it works in theory >_>
02:31:33 <Saizan_> , [$ty|appT]
02:31:35 <lunabot>  luna: lexical error in string/character literal at end of input
02:31:40 <Saizan_> , [$ty|appT|]
02:31:45 <lunabot>  TypeQ -> TypeQ -> TypeQ
02:32:00 <Saizan_> , [$ty|[t\|Int\|]|]
02:32:02 <lunabot>  TypeQ
02:32:40 <edwardk> that is disturbing on so many levels
02:33:12 <edwardk> , ''Int
02:33:14 <lunabot>  GHC.Types.Int
02:33:31 <Saizan_> ''Foo :: Name
02:33:51 <edwardk> , conT ''Int
02:33:53 <lunabot>  ConT Int
02:47:40 <ivanm> is the quote by von Neumann in the last comment on this post real? http://briancarper.net/blog/real-confusing-haskell
02:51:09 <arjanb> ivanm: only with mathematics replaced by haskell
02:51:21 <romildo> How do I enable multiparameter type classes in GHC?
02:51:31 <ivanm> arjanb: ahhh
02:51:43 <ivanm> romildo: when compiling, or in the file?
02:51:52 <romildo> ivanm, in the file
02:51:56 <ivanm> {-# LANGUAGE  MultiParamTypeClasses #-} <-- put that up the top
02:52:17 <romildo> ivanm, after the module declaration, right?
02:52:25 <ivanm> no
02:52:29 <ivanm> right up the top ;-)
02:52:45 <romildo> ivanm, ok. thanks.
03:02:13 <wli> In non-literate files it's got to be the first line of the file.
03:02:39 <wli> In literate files it's got to be the first line in the first \begin{code} environment.
03:04:33 <b_jonas> is that the {-# magical comments?
03:04:45 <wli> yeah
03:05:08 <McManiaC> @pl \h % m = h + m / 60
03:05:09 <lambdabot> (line 1, column 4):
03:05:09 <lambdabot> unexpected "%"
03:05:09 <lambdabot> expecting operator, pattern or "->"
03:05:29 <McManiaC> @pl \h m -> h + m / 60
03:05:29 <lambdabot> (. (/ 60)) . (+)
03:05:38 <wli> Odd thought there.
03:05:44 <McManiaC> :D
03:05:50 <Saterus> i think i've been spoiled by ghci. is there an equivalent in the ruby irb to ghci's "it"?
03:05:54 <wli> % s usually for rationals.
03:05:59 <McManiaC> yeh
03:05:59 <wli> @type (%)
03:06:00 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
03:06:05 <Eridius> Saterus: it's _
03:06:48 <Saterus> Eridius: thanks. wish i was working in haskell...
03:06:58 <McManiaC> hehe
03:07:29 <McManiaC> who doesnt
03:07:30 <McManiaC> :)
03:08:15 <tomh> if so many want to work with haskell, why are there not more haskell companies :)
03:08:45 <BSK> maybe because there are not enough customers for that?
03:09:21 <tomh> nah i doubt that
03:09:31 <wli> In systems code it's not tough to understand why languages stay low-level.
03:09:50 <Gracenotes> McManiaC: % is not a constructor, so you can't pattern match on it :\ numerator and denominator work though
03:10:14 <arjanb> because it takes quite a few haskellers before a company finds switching not a too big risk anymore
03:10:16 <McManiaC> yup, ive been stupid there Gracenotes :)
03:10:29 <b_jonas> Saterus: yes, the _ variable
03:10:33 <wli> High-level userspace app code OTOH seems different.
03:10:35 <Gracenotes> yeah. well it is somewhat deceptive :X
03:10:39 <b_jonas> oh, Eridius already told you that
03:10:44 <tomh> but one haskeller can do the work of 10 grunt programmers of accenture :>
03:10:54 <tomh> if not more
03:11:12 <Eridius> heh
03:11:25 <wli> McManiac: The constructor is (:%) but hidden.
03:11:28 <Gracenotes> the problem is bigger in reverse, though: making pattern-matching available means that you have to make the constructor available -- to construct possibly invalid things
03:11:51 <Gracenotes> Haskell hides :%, doesn't allow this
03:12:05 <Eridius> import GHC.Real
03:12:07 <Gracenotes> although you could probably import it from GHC.Real
03:12:18 <wli> Data.Ratio hides :% not Haskell
03:12:30 <McManiaC> its not a big deal, just a quick thought on a little function :S
03:12:30 <Gracenotes> wli: nooo! It's Haskell!!
03:12:52 <McManiaC> but good to know
03:12:52 <McManiaC> ;)
03:13:03 * Gracenotes lights the torches and gets the pitchforks
03:13:46 <b_jonas> but there are functions to get the numerator and denominator, so it's not much of a problem
03:13:51 <wli> Rational functions and algebraic functions are more interesting.
03:14:27 <McManiaC> how could i import that hidden constructor? "import Data.Ratio (:%)" ?
03:14:45 <wli> import GHC.Real
03:14:53 <Gracenotes> well. better practice to just use numerator and denominator if you don't have to use (:%)
03:15:07 <Gracenotes> and to import infix constructors, import GHC.Real ((:%))
03:15:10 <McManiaC> :)
03:15:17 <McManiaC> ah ok
03:15:19 <Gracenotes> portability is better anyway >_>
03:15:25 <McManiaC> yep
03:16:47 <jethr0> you mean there are compilers other than ghc?   ;)
03:17:32 <Gracenotes> well, of course, FreeBSD has always had a problem with operators like :%... <_<
03:18:09 <Gracenotes> NetBSD got it right though.
03:31:46 <boegel> hiya all!
03:32:05 <boegel> I've implemented a small Haskell tool for k-means clustering
03:32:27 <ivanm> boegel: cool
03:32:33 <ivanm> using what type of graph data structure?
03:32:33 <boegel> in which the bottleneck is the dist function, implementing Euclidean distance
03:32:49 <boegel> i.e. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3282#a3282
03:32:54 <boegel> ivanm: none :)
03:33:32 <boegel> I'm wondering if there is any opportunity to significantly speedup the dist function I've implemented
03:33:53 <ivanm> boegel: what are you clustering?
03:33:56 <boegel> I'm already using an improved version of sum, which using foldl'
03:33:59 <ivanm> oh... that what you meant :(
03:34:10 * ivanm thought it was something fancy :(
03:34:11 <boegel> ivanm: points in a high-dimensional space
03:34:16 <boegel> ivanm: no, it's not :)
03:34:19 <ivanm> boegel: yeah, I get that now
03:34:37 <ivanm> I just did a whole bunch of graph clustering stuff last yeah, and thought this was another one :s
03:35:00 <boegel> the dist function takes something like 85% of the total runtime
03:35:04 <ivanm> boegel: one thing I would do is replace the lambda with a where function, and don't use ^2
03:35:13 <boegel> and this is just for a small number of clusters, e.g. 10
03:35:31 <boegel> ivanm: don't use ^2? just use x*x ?
03:35:48 <ivanm> yeah
03:35:55 <luap> how do you use qualified operators, like:  import qualified Data.Sequence as Seq;   and then:  a Seq.<| b       ; is giving me parse errors
03:35:56 <ivanm> because it can't tell which Integral type 2 is :s
03:36:06 <ivanm> boegel: also, why not use standard sum?
03:36:13 <ivanm> @src sum
03:36:15 <lambdabot> sum = foldl (+) 0
03:36:23 <ivanm> oh, you're trying to be strict...
03:36:45 <Gracenotes> ivanm: there might be possible speedup if you make the type signature for sum specific to Doubles?
03:37:01 <Gracenotes> in this case you're only adding, so probably not much at all
03:37:15 <ivanm> boegel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3282#a3283
03:37:53 <ivanm> you can probably use a let in there instead of where for euclidian... I just think where > let, that's all ;-)
03:38:57 <Gracenotes> SPECIALIZE must exist for a reason, after all...
03:38:59 <GeDaMo> ivanm: do you need two wheres there? Can't you put both under one?
03:39:22 <ivanm> GeDaMo: no... the second where is specific to euclidian
03:39:31 <ivanm> Gracenotes: *shrug*
03:42:55 <boegel> ivanm: how about just doing euclidean x y = (x-y)*(x-y) ?
03:43:06 <ivanm> boegel: then it calculates the different _twice_! :o
03:43:10 <boegel> the second where seems overkill, unless it'll buy me speedup
03:43:18 <boegel> ivanm: won't the compiler figure that out?
03:43:19 <Gracenotes> o:
03:43:21 <ivanm> it _might_
03:43:31 <boegel> :o:
03:43:32 <ivanm> @pl \ x y - (x-y) * (x-y)
03:43:33 <lambdabot> (line 1, column 7):
03:43:33 <lambdabot> unexpected " "
03:43:33 <lambdabot> expecting "->"
03:43:38 <ivanm> @pl \ x y -> (x-y) * (x-y)
03:43:40 <lambdabot> ap (ap . ((*) .) . (-)) (-)
03:43:43 <ivanm> heh
03:43:44 <boegel> heh
03:43:59 <ivanm> boegel: no, we had a big discussion yesterday about why CSE is bad...
03:44:04 <Gracenotes> also known as: (join (*) .) . (subtract)
03:44:41 <ivanm> @pl \ x y -> (f x y) * (f x y)
03:44:42 <lambdabot> ap (ap . ((*) .) . f) f
03:44:43 <Gracenotes> or maybe it's (. join (*)). Doesn't really matter in this case.
03:44:56 <ivanm> why doesn't @pl do join? :s
03:45:03 * boegel tries ivanm's suggestions in practice
03:45:28 <ivanm> boegel: main problem with using ^2 is it defaults to Integer, which _could_ be slower than using Int
03:46:32 <boegel> ivanm: hmmk
03:46:44 <boegel> ivanm: specializing sum' to Double also seems like it might help
03:46:56 <Gracenotes> indeed, sir. an excellent suggestion X.X
03:47:03 <ivanm> Gracenotes: heh
03:47:21 <boegel> Gracenotes: yeah, thanks for that suggestion :P
03:47:36 <Gracenotes> quite so. pats on the back for all involved! :D
03:47:37 <boegel> is there any way to tell GHC to use SSE instructions for the dist function?
03:47:44 <ivanm> boegel: don't think so...
03:49:07 <Gracenotes> @pl \ x -> (f x) * (f x)
03:49:08 <lambdabot> liftM2 (*) f f
03:49:39 <Gracenotes> @pl \x y -> m (f x y) (g x y)
03:49:40 <lambdabot> ap (ap . (m .) . f) g
03:50:46 <boegel> hmm, I'm also using sum' to sum Int's, so specializing to Double won't help much
03:50:55 <Gracenotes> hm. I don't think there's an easy way to liftA2 that, is there?
03:51:17 * boegel uses foldl' directly in dist instead
03:51:30 <boegel> is there a faster alternative to sqrt?
03:52:12 <Gracenotes> boegel: do you know where in the method everything is slow?
03:52:17 <ivanm> boegel: no ;-)
03:52:19 <dancor> is there a simpler version of   maybe (const $ Nothing)
03:52:27 <boegel> Gracenotes: where in dist?
03:52:31 <dancor> it's >>= isn't it..
03:52:37 <ivanm> dancor: maybe id ?
03:52:38 <Gracenotes> dancor: fromMaybe...?
03:52:43 <Gracenotes> fromMaybe == maybe id
03:52:44 <ivanm> @type maybe (const $ Nothing)
03:52:46 <lambdabot> forall b a a1. (a1 -> b -> Maybe a) -> Maybe a1 -> b -> Maybe a
03:52:48 <Gracenotes> wait
03:52:52 <ivanm> @type fromMaybe
03:52:54 <lambdabot> forall a. a -> Maybe a -> a
03:53:02 <ivanm> @type maybe id
03:53:04 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
03:53:07 <Gracenotes> no... never mind, this is confusing. You're returning a function
03:53:18 <Gracenotes> maybe Nothing == fromMaybe then. yeah.
03:54:30 <Gracenotes> well.
03:55:00 <Gracenotes> no, that's flip maybe id
03:55:06 <dancor> i want "onJust"
03:55:35 <wli> liftM2 ?
03:56:02 <dancor> maybe (const $ Nothing) (+ 1) (Just 4)
03:56:06 <dancor> > maybe (const $ Nothing) (+ 1) (Just 4)
03:56:08 <lambdabot>       No instance for (Num (b -> Maybe a))
03:56:08 <lambdabot>        arising from the literal `1...
03:56:21 <Gracenotes> are you sure you don't mean maybe Nothing?
03:56:27 <Gracenotes> if so that's >>=
03:56:33 <wli> liftM (+1) $ Just 4
03:56:37 <dancor> > maybe Nothing (+ 1) (Just 4)
03:56:39 <lambdabot>       No instance for (Num (Maybe a))
03:56:39 <lambdabot>        arising from the literal `1' at ...
03:56:44 <wli> > liftM (+1) $ Just 4
03:56:45 <lambdabot>   Just 5
03:57:05 <Gracenotes> no
03:57:14 <Gracenotes> > maybe Nothing (return . (+1)) (Just 4)
03:57:16 <lambdabot>   Just 5
03:57:24 <Gracenotes> which is.. yeah, liftM in this case
03:57:38 <boegel> hmm, seems like this is a lot faster
03:57:54 <wli> > liftM2 (+) (Just 2) (Just 3)
03:57:55 <lambdabot>   Just 5
03:58:15 <boegel> as in about 2x faster
03:58:16 <boegel> w00t
03:58:27 <Gracenotes> making 'maybe' use a function is... very weird. This is all so weird O:
03:58:38 <Gracenotes> boegel: congrats! paste the new one? :)
03:58:39 <boegel> holy fuck, this makes a huge difference
03:58:55 <wli> boegel: What's that?
04:01:42 <boegel> Gracenotes, wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3282#a3285
04:02:16 <boegel> wli: the last revision of the dist function makes my code about 2x faster, and dist was being used for 80% of the runtime
04:02:35 <boegel> so, say it took 10s at first, where 8s were due to dist
04:02:53 <boegel> now I just have 5s, which makes 8s/3s speedup
04:02:59 <boegel> > 8/3
04:03:01 <lambdabot>   2.6666666666666665
04:03:04 <boegel> w00!
04:04:05 <wli> boegel: Were you using -O2?
04:04:09 <boegel> wli: O3
04:04:49 <b_jonas> heh
04:04:52 <wli> boegel: I'm not sure but I think -O3 might get ignored.
04:05:03 <b_jonas> I've installed ghc-6.10.2, and now
04:05:31 <b_jonas> when I try to generate haddock docs for the encoding-0.5.1 module, I get a different error than from ghc-6.10.1:
04:05:35 <b_jonas> "
04:05:40 <b_jonas> stack overflow: use -g +RTS -K<size> to increase it"
04:06:25 <ivanm> b_jonas: :o
04:08:30 <wli> boegel: Try -O2 instead of -O3
04:09:25 <Baughn> boegel: -O3 clearly shouldn't be ignored, but I'm pretty sure -O2 is the highest that makes any actual difference
04:09:53 <b_jonas> doesn't -On in ghc work the same way as in gcc?
04:09:56 <ivanm> boegel: -O3 often causes errors...
04:10:00 <wli> Baughn: -O2 should've gotten rid of sum'
04:10:01 <ivanm> even in gcc
04:10:19 <Baughn> -O3 in gcc turns on unsafe optimizations
04:10:24 <Baughn> In ghc.. not so much
04:10:25 <wli> Baughn: So I'm suspicious of whatever -O3 s doing.
04:11:10 <b_jonas> because as I see in gcc -O0 is for no optimization which you use for debugging, -O1 (same as -O) enables the optimizations that don't slow down the compiling much, -O2 does the recommended optimizations, and while -O3 does not enable unsafe optimizations, it does enable ones that sometimes actually make worse code than -O2 would
04:11:29 <ivanm> b_jonas: no, -O0 does _some_ optimisations IIRC...
04:12:07 <Baughn> -O0 does optimizations that don't interfere with debugging
04:12:10 <b_jonas> ivanm: it might do some, the point is that if you compile your code with -O0 then the debugger won't lie to you (more than it would if there were no optimizations done)
04:12:16 <ivanm> why do you need an -On value to do nothing? :s
04:12:30 <Baughn> ivanm: Well, to override an earlier -Om value
04:13:00 <ivanm> Baughn: hmmm.... true
04:13:05 <b_jonas> what I said is for gcc only though, ghc might work differently
04:13:17 <b_jonas> the ghc docs doesn't say much about -On last I've seen
04:14:51 <wli> -O2 should've inlined sum' away
04:15:01 <wli> So something is wrong with -O3
04:15:06 <b_jonas> let me see, it says -O0 and -O1 are like in gcc, -O2 means Apply every non-dangerous optimisation, even if it means significantly longer compile times. The avoided âdangerousâ optimisations are those that can make runtime or space worse if you're unlucky.
04:15:09 * boegel tries -O2
04:15:20 <boegel> wli: are there any other, non-standard flags which might help speedup dist?
04:15:38 <b_jonas> so this agrees with gcc it seems
04:15:48 <Baughn> boegel: GCC? There are various flags that may produce actual incorrect code
04:15:50 <wli> boegel: excess precision
04:15:59 <Baughn> Like that one
04:16:25 <jedai> unbox-strict-fields
04:16:30 <wli> Maybe some unboxed float stuff
04:16:58 <jedai> can make things worse but can also help a lot in some cases
04:17:11 <boegel> I don't think I want incorrect code, I want correct _fast_ code ;-)
04:17:29 <Baughn> Well, excess precision is normally pretty safe. :P
04:17:32 <Baughn> If it isn't, you know
04:17:48 <wli> -fexcess-precision is safe unless you know it isn't
04:17:52 <boegel> wli: I'm also compiling a seperate binary with -fvia-C -optc-march=pentium4 -optc-mfpmath=sse, but it doesn't seem to make a lot of difference
04:18:11 <Baughn> boegel: Try adding -optc-O3
04:18:12 <jedai> boegel: unbox-strict-field won't make incorrect cod
04:18:35 <Baughn> I've been wondering. What the downside to unbox-strict-fields?
04:18:39 <boegel> so, I should also try adding -optc-O3 -funbox-strict-field -fexcess-precision
04:19:00 <Baughn> -fexcess-precision is also a gcc flag
04:19:05 <jedai> Baughn: sometimes you have to rebox those unboxed value to pass them to some functions
04:19:20 <ivanm> boegel: ummm... IIRC, -optc-O3 will only do stuff if you also have -fvia-C
04:19:33 <jedai> Baughn: it can be slower than using boxed value directly
04:20:35 * Baughn is still waiting for that glorious day when -fvia-c is a bad idea in all circumstances
04:20:56 <boegel> ivanm: I do have -fvia-C, for one version at least
04:21:15 <b_jonas> OH NO
04:21:32 <b_jonas> I think I'm not the only one who can't build the docs of that package, because hackage doesn't have the online docs
04:21:42 <Baughn> boegel: -optc-foo does absolutely nothing if you don't have -fvia-c
04:21:49 <b_jonas> shit
04:21:52 <ivanm> b_jonas: which package is this?
04:21:57 <boegel> (lunch)
04:21:58 <ivanm> Baughn: I already said that!
04:22:05 <b_jonas> encoding-5.1 (also encoding-5.0)
04:22:10 <b_jonas> -> ivanm
04:22:17 * ivanm hasn't tried that one
04:22:25 <Baughn> ivanm: Technically, no you didn't. It's probably obvious, but..
04:22:44 <ivanm> heh
04:22:46 <b_jonas> (note: it takes quite some time to build)
04:22:56 <ivanm> true, I just mentioned -optc-O3
04:23:04 <ivanm> since that was the one b_jonas specified
04:24:33 <Gracenotes> hm. not that it'll be useful, but lemme see if I can make a libquantum FFI binding for Hackage...
04:24:57 <ivanm> Gracenotes: what's libquantum?
04:25:22 <Gracenotes> simulates a quantum register, with qubits
04:25:24 <ivanm> has anyone apart from igel and myself have problems with "ghc-pkg check" for 6.10.2 ?
04:25:28 <ivanm> it doesn't seem to like rts :s
04:25:34 <Gracenotes> it's slow, of course
04:25:49 <ivanm> Gracenotes: heh
04:26:12 <Gracenotes> shor's algorithm for, say, 120.. takes a few seconds
04:26:50 <Gracenotes> and you need a few iterations of it. Possibly dozens, for larger values
04:28:07 <b_jonas> I wonder what to do. I'd like to have the docs for this module. :-(
04:29:12 <ivanm> b_jonas: ask the dev?
04:30:06 <b_jonas> ivanm: maybe. I wrote one mail to him, and he updated the module to use the new Control.Exception so now it builds in ghc-6.10 unchanged,
04:30:11 <ivanm> b_jonas: that haddock problem should be fixed with the haddock in 6.10.2
04:30:21 <ivanm> AFAIK, anyway
04:30:34 <b_jonas> ivanm: I've upgraded to 6.10.2 and I get a different error now
04:30:37 <b_jonas> a stack overflow namely
04:30:45 <ivanm> ahhh
04:31:28 <b_jonas> anyway in that mail I also wrote about the haddock problem
04:31:51 <ivanm> b_jonas: maybe it's due to too many modules (the stack overflow)...
04:33:32 <wli> A few iterations of what?
04:34:52 <wli> Not sure how many modules lead to stack overflows.
04:35:11 <ivanm> 5*pi+10, IIRC
04:35:12 <ivanm> ;-)
04:36:35 <boegel> Baughn: -fexcess-precision is also a GCC flag, but I want to use the GHC flag though, right?
04:37:15 <b_jonas> anyway, if any of you could build the docs successfully, do tell me next time
04:37:19 <b_jonas> I have to leave now
04:39:34 <Baughn> boegel: Probably
04:39:37 <eu-prleu-peupeu> hi
04:39:58 <eu-prleu-peupeu> i have this data type that i need to be initialized in order to be used, how is the best way to do this ?
04:40:21 <boegel> eu-prleu-peupeu: I don't think that makes sense in Haskell
04:40:35 <eu-prleu-peupeu> :/
04:40:37 <boegel> eu-prleu-peupeu: which data type exactly?
04:40:45 <Baughn> boegel: Certainly, storing floats back into memory after /every single operation/ is a mite expensive
04:40:45 <eu-prleu-peupeu> im using arrays in it
04:41:05 <Baughn> boegel: But using SSE/SSE2 math ought to remove that requirement
04:41:06 <Saizan_> mutable ones?
04:41:06 <eu-prleu-peupeu> i wanted the arrays to be created when the datatype is created, so i dont have to create them :/
04:41:14 <eu-prleu-peupeu> yes mutable
04:41:30 <EvilTerran> mutable how?
04:41:44 <eu-prleu-peupeu> its STArrays
04:41:59 <eu-prleu-peupeu> STArray (Int, Int) (Double->Double) :P
04:41:59 <Saizan_> then just provide a function (new :: ST s (YourDataType s))
04:42:23 <boegel> using -fvia-C -optc-O3 -fexcess-precision -funbox-strict-fields -optc-march=pentium4 -optc-mfpmath=sse seems to get me 7% speedup
04:42:27 <boegel> which is nice, I ugess :)
04:42:43 <boegel> 7% overall, so the dist function is getting a lot faster
04:43:01 <eu-prleu-peupeu> hmm, i have lots of arrays inside my datatype, its like data MyType = MyType (STArray ...) (STArray ..)  ....
04:43:11 <Baughn> If you have -optc-mfpmath=sse you ought not to /need/ -fexcess-precision. :P
04:43:22 <Baughn> boegel: At any rate, try removing it, see if that makes any difference
04:43:38 <boegel> Baughn: removing sse?
04:43:55 <Baughn> boegel: No, -fexcess-precision
04:44:32 <boegel> k
04:45:12 <trofi> can i legally use IO in TH (w/o unsafe* friends?) ?
04:45:54 <ivanm> trofi: no, it's against the Geneva Conventions
04:45:58 <ivanm> *Convention
04:45:59 <ivanm> ;-)
04:45:59 <boegel> ivanm: :D
04:46:03 * ivanm actually has no idea
04:46:06 <Baughn> trofi: Er, yeah. runIO :: IO a -> Q a
04:46:22 <eu-prleu-peupeu> brb
04:46:51 <boegel> what a nick! eu-prleu-peupeu :)
04:47:39 <trofi> Baughn: thanks!
04:48:14 <lizrail> greetings. Does anybodhy know, is there a library or a binding which allows to get glyph outlines from ttf fonts?
04:48:23 <boegel> Baughn: removing -fexcess-precision clearly slows things down
04:48:24 <boegel> gotta run!
04:52:28 <trofi> , help
04:52:30 <lunabot>  type of an expression:      , [$ty| \x -> x |]
04:52:30 <lunabot>  get info for a type/class:  , src ''Monad
04:52:30 <lunabot>  get info for a var/con:     , src 'fix
04:52:51 <trofi> , [$ty| [| 1 |] |]
04:52:52 <lunabot>  luna: parse error on input `|]'
04:53:02 <trofi> , [$ty| runIO act |]
04:53:05 <lunabot>  luna: Exception when trying to run compile-time code:
04:59:22 <ivanm> @quote )
04:59:24 <lambdabot> pl says: const (((it hurts :) .) . flip flip [] . ((:) .))
04:59:43 <ivanm> oh... when I did that before, I get a "the impossible happened" message :s
04:59:52 <ivanm> oh, wait, that was an actual quote :s
05:03:33 <trofi> , [| 1 |]
05:03:34 <lunabot>  LitE (IntegerL 1)
05:03:35 <J-roen> Hi. I want to ship some data files with my Cabal package so I use the function getDataFileName. But this function isn't available when developing, so I created a Paths_pkgname module myself. But now this module is also used when installing the Cabal package. What can I do about this?
05:04:04 <ivanm> J-roen: get rid of that package?
05:04:16 <ivanm> not include it in .cabal file so sdist doesn't include it?
05:04:58 <J-roen> ivanm: Thanks. I didn't include it in the .cabal file but it still includes it. Actually I don't include any modules in the .cabal file. Maybe this is the problem?
05:05:13 <bavardage> can I make something a module yet still compile it with a main?
05:05:25 <bavardage> I get /usr/lib/ghc-6.10.1/libHSrts.a(Main.o): In function `real_main':
05:05:26 <bavardage> (.text+0x2c): undefined reference to `ZCMain_main_closure'
05:05:27 <J-roen> bavardage: Use Main-Is
05:05:27 <bavardage> errors
05:05:28 <ivanm> bavardage: there's a --main-is flag to ghc IIRC...
05:05:34 <bavardage> kk
05:07:39 <J-roen> ivanm: Should I include all module names in the .cabal file? Because at the moment I don't do that and everything works fine.
05:08:07 <bavardage> ivanm, J-roen: ty, works :D
05:08:12 <ivanm> J-roen: ummm.... if you don't, then it won't work ;-)
05:08:43 <trofi> , [$ty| 1 |]
05:08:46 <lunabot>  forall a . Num a => a
05:08:53 <trofi> , [$ty| [| x |] |]
05:08:54 <lunabot>  luna: parse error on input `|]'
05:09:09 <trofi> , [$ty| ([| x |]) |]
05:09:10 <Saizan_> J-roen: that module is created under dist/build/autogen
05:09:10 <lunabot>  luna: parse error on input `|]'
05:09:37 <Saizan_> J-roen: and yes, for sdist to work properly you've to list all the user-written modules in the .cabal file
05:10:00 <J-roen> ivanm, Saizan_: Sorry, it really does :). I only use it to create a binary. The modules are not for the end user.
05:10:23 <ivanm> J-roen: you need to include them as well, under a different flag
05:10:31 <ivanm> can't remember what though
05:10:37 <ivanm> s/flag/option/
05:10:40 <Saizan_> other-modules
05:10:45 <ivanm> that's the one
05:11:41 <J-roen> ivanm, Saizan_: Is that really necessary when I have only one main program to compile? Because it really works at the moment without having the modules specified in the .cabal file.
05:11:54 <ivanm> J-roen: do you use those other modules?
05:12:06 <ivanm> J-roen: note that it works because you're building it in your dir...
05:12:15 <Saizan_> J-roen: it's necessary if you want to use sdist to create a tarball to e.g. upload it to hackage, otherwise it's not
05:12:25 <ivanm> whereas if you package it and try to get someone else to build, it'll probably fail
05:12:40 <ivanm> Saizan_: oh, if you tarball it manually it'll still work?
05:13:07 <Saizan_> ivanm: Cabal uses ghc --make, so the modules will be found
05:13:16 <ivanm> *nod*
05:13:27 <J-roen> ivanm, Saizan_: Okay, clear. So that might be also the reason why my custom Paths_pkgname is included, because I run Cabal in the same dir. But that seems really bad to me. What if someone who wants to install it also does that...
05:13:45 <ivanm> J-roen: how are you trying to build it?
05:14:07 <Saizan_> J-roen: you shouldn't write your own Paths_pkgname
05:14:34 <ivanm> Saizan_: so how does one then test it works without building it via cabal for each small change?
05:14:48 <Saizan_> ivanm: -idist/build/autogen
05:14:51 <J-roen> ivanm: Yes, that's my question.
05:15:13 <ivanm> Saizan_: so cabal configure, then ghci -idist/build/autogen ?
05:15:15 <J-roen> ivanm, Saizan_: I read at http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html that it would be possible: "When doing a Cabal build, Cabal will choose its custom generated Paths module over ours, and we get the benefits of Cabal managing our data."
05:15:38 <Saizan_> ivanm: also cabal build first
05:15:46 <ivanm> J-roen: I really wouldn't know... I chose a hard-coded version over using the Cabal version for my code ;-)
05:15:58 <ivanm> Saizan_: but if you change something, will it still work?
05:16:10 <ivanm> what happens if you then run ghci within emacs or something?
05:16:51 <Saizan_> "something"?
05:17:07 <ivanm> well, another editor/IDE/whatever
05:17:12 <ivanm> i.e. you don't manually start ghci
05:17:25 <Saizan_> :set -idist/build/autogen
05:17:32 <ivanm> ahhh
05:17:56 <ivanm> Saizan_: still seems like a rather convuloted method...
05:18:53 <Saizan_> if you really want to use a custom Paths_pkgname while developing you should make sure it's not in the searchpath that Cabal uses while building the program
05:19:27 <Saizan_> on the other hand Cabal might put dist/build/autogen before the normal hs-source-dirs, so that it takes precedence..
05:19:52 <J-roen> Saizan_: That's what I expected. That is also mentioned at the URL I posted. But it doesn't do that...
05:20:03 <ivanm> Saizan_: where would one place it?
05:20:52 <Saizan_> ivanm: e.g Paths_pkgname under . and the sources under src/
05:21:27 <ivanm> Saizan_: then manually add . to the path ghci looks in?
05:21:29 <Saizan_> J-roen: yeah, it's probably a sensible choice, you should open a ticket
05:22:14 <Saizan_> ivanm: yeah, so it's kind of the same solution, except you can use a module that uses your own paths while developing
05:22:22 <trofi> , $( [| 1 |] :: Q Int )
05:22:23 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
05:22:30 <J-roen> ivanm, Saizan_: Thanks for your help!
05:22:34 <trofi> , $( [| 1 |] :: ExpQ Int )
05:22:35 <lunabot>  luna: Kind error: `Language.Haskell.TH.Lib.ExpQ' is applied to too many t...
05:22:40 <Gracenotes> :O
05:22:52 <trofi> i don't get it :[
05:23:22 <Saizan_> J-roen: http://hackage.haskell.org/trac/hackage/
05:23:32 <ivanm> Saizan_: *nod*
05:23:43 <Saizan_> , $( [| 1 |] :: ExpQ) :: Iint
05:23:44 <lunabot>  luna: Not in scope: type constructor or class `Iint'
05:23:44 <Saizan_> , $( [| 1 |] :: ExpQ) :: Int
05:23:46 <lunabot>  1
05:24:03 <Botje> how useful :p
05:24:21 <Saizan_> trofi: the TH AST is not parametrized over the type of the expression
05:25:02 <trofi> what is (Q a) at all ?
05:26:11 <Saizan_> Q is the quotation monad, it gives you access to reify and unique names
05:26:18 <Saizan_> ExpQ = Q Exp
05:27:05 <trofi> @hoogle runQ
05:27:06 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
05:27:06 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
05:28:18 <trofi> can i ask lunabot to show types for TH expressions?
05:28:32 <trofi> like :t ([| 1 |])
05:29:18 <trofi> :t ([| 1 |])
05:29:19 <lambdabot> parse error on input `|'
05:29:21 <Saizan_> , [$ty| [| 1 \|] |]
05:29:24 <lunabot>  ExpQ
05:29:33 <trofi> oh, thanks
05:29:52 <trofi> , [$ty| runIO |]
05:29:54 <lunabot>  luna: Exception when trying to run compile-time code:
05:30:44 <trofi> , [$ty| (undefined :: IO Int) |]
05:30:47 <lunabot>  IO Int
05:30:57 <trofi> , [$ty| (runIO $ undefined :: IO Int) |]
05:31:00 <lunabot>  luna: Exception when trying to run compile-time code:
05:32:15 <trofi> to use runIO in $(), IO should return Exp ?
05:33:53 <Saizan_> trofi: runIO is disabled/not in scope in lunabot for obvious reasons
05:34:36 <trofi> i see
05:34:45 <ivanm> Saizan_: because it was too hard to implement? :p
05:36:12 <Saizan_> ivanm: no, because i copy/pasted lunabot's machine /etc/passwd to mmorrow and he didn't like that :)
05:36:29 <Eelis> it doesn't run in a chroot?
05:37:35 <Saizan_> no, the type system suffices, assuming you take care of unsafe operations like those
05:37:42 * Eelis shudders
05:37:52 <ivanm> Saizan_: heh
05:38:03 <ivanm> Saizan_: is that why he isn't online? :P
05:38:11 <trofi> @hoogle IO a -> ExpQ
05:38:11 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
05:38:11 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
05:38:11 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
05:38:20 <ivanm> Saizan_: so how did he manage to log in?
05:38:44 <Saizan_> ivanm: what?
05:38:50 <trofi> @hoogle Q a -> ExpQ
05:38:50 <lambdabot> Language.Haskell.TH fromE :: ExpQ -> ExpQ
05:38:50 <lambdabot> Language.Haskell.TH.Lib fromE :: ExpQ -> ExpQ
05:38:50 <lambdabot> Language.Haskell.TH arithSeqE :: RangeQ -> ExpQ
05:39:26 <trofi> @src fromE
05:39:26 <lambdabot> Source not found. Maybe you made a typo?
05:39:33 <ivanm> Saizan_: how did mmorrow manage to log in if you replaced his password?
05:39:46 <trofi> not replaced
05:39:54 <trofi> who will run bots as root? :]
05:40:09 <Saizan_> yeah, exactly :)
05:40:27 <ivanm> Saizan_: oh, you were lying? :(
05:40:36 <ivanm> that sounded like a cool story/reason ;-)
05:40:48 <Saizan_> i only said i read the contents
05:40:53 <Saizan_> not that i modified it
05:40:59 <Saizan_> and i wasn't lying :)
05:41:19 <trofi> ivanm: disregard to passwd name it does not store passwords :]
05:41:44 <ivanm> Saizan_: oh, I thought you meant by "copy/pasted ... to mmorrow" that you replaced mmorrow's password with lunabot's or something :s
05:42:07 <ivanm> trofi: oh, I thought it stored the hashes...
05:42:26 <trofi>  /etc/shadow does it usually
05:42:42 <ivanm> *nod*
05:43:50 <wjt> @ty ap
05:43:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:44:26 <trofi> , [
05:44:27 <lunabot>  luna: parse error on input `)'
05:44:36 <ivanm> wtf?
05:44:59 <bavardage> is there any way to take advantage of multi cores, without explicitly coding for this?
05:45:06 <bavardage> since surely, due to lazyness
05:45:07 <wjt> I have f :: a -> m b; x :: Maybe a. I'd like to get y :: m (Maybe b), but can't think what the right combinator is. fmap f x :: Maybe (m b)
05:45:20 <bavardage> somefun thing1 thing2
05:45:29 <bavardage> thing1 and thing2 could be worked out in seperate cores?
05:45:36 <wjt> @ty maybe
05:45:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:45:40 <ivanm> bavardage: no
05:45:45 <bavardage> :(
05:45:47 <Saizan_> bavardage: with Control.Parallel you need very few annotations
05:45:50 <ivanm> but there's the `par` stuff
05:46:09 <ivanm> bavardage: after all, maybe you don't _want_ it to take over all your cores...
05:46:17 <bavardage> yeah I do :D
05:46:19 <ivanm> "All your core are belong to us!"
05:46:22 <bavardage> hehe
05:46:28 <Saizan_> bavardage: the problem with doing it completely automatic is that it's hard for the compiler to tell when it's a win to run something in parallel
05:46:32 <bavardage> thought there may just be a ghc option or something
05:46:33 <wjt> @pl \f x -> maybe (return Nothing) f x
05:46:34 <lambdabot> maybe (return Nothing)
05:46:44 <wjt> @ty fromMaybe
05:46:46 <lambdabot> forall a. a -> Maybe a -> a
05:46:48 * trofi searches Int -> ExpQ
05:46:51 <bavardage> ghc -O -do-fancy-things-with-lots-of-cores program.hs
05:47:21 <trofi> , [| (LitE 1) |]
05:47:22 <lunabot>  AppE (ConE LitE) (LitE (IntegerL 1))
05:47:36 <trofi> , [| (IntegerL 1) |]
05:47:37 <lunabot>  AppE (ConE IntegerL) (LitE (IntegerL 1))
05:48:06 <Saizan_> bavardage: small example: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29
05:48:50 <trofi> , [$ty| (IntegerL 1) |]
05:48:53 <lunabot>  Lit
05:48:57 <trofi> , [$ty| (IntegerE 1) |]
05:49:00 <lunabot>  luna: Exception when trying to run compile-time code:
05:49:20 <trofi> @hoogle Lit -> ExpQ
05:49:21 <lambdabot> Language.Haskell.TH litE :: Lit -> ExpQ
05:49:21 <lambdabot> Language.Haskell.TH.Lib litE :: Lit -> ExpQ
05:49:21 <lambdabot> Language.Haskell.TH LitE :: Lit -> Exp
05:49:37 <trofi> , $( (litE (IntegerL 1)) )
05:49:38 <lunabot>  1
05:49:47 <Saizan_> trofi: btw, you should take this to privmsg or ghci
05:50:02 <trofi> ok
05:50:47 <bavardage> Saizan_: ty
05:56:13 <ivanm> is Control.Arrow shipped with 6.10.2 ?
05:56:25 <ivanm> because ghci suddenly can't find my code :s
05:56:35 <ManateeLazyCat> How to make one child add into *two* parent container? I use gtk2hs
05:56:40 <kiris> ivanm: what's the error?
05:56:54 <ivanm> "    Could not find module `Control.Arrow':"
05:57:31 <ivanm> weird, a fresh ghci session can find it :s
05:57:34 <Saizan_> weird, it's in base
05:57:44 * ivanm wonders if he's using a ghci session from before he upgraded ghc :s
05:57:56 <ivanm> ahhh, looks like that was it :s
05:58:09 <ManateeLazyCat> Have a IRC channel discuss gtk2hs?
05:58:22 <wjt> aha! It's 'traverse'
05:58:36 <wjt> @ty (maybe (return Nothing)) `asTypeOf` traverse
05:58:38 <lambdabot> Not in scope: `traverse'
05:58:40 <wjt> bah.
06:00:59 <vixey> I've got to design some nice fixed point combinators
06:04:11 <ManateeLazyCat> I'm now develop a Haskell editor, i want make one buffer add in two container (split two windows), and synchronous buffers' data in two windows. So i don't know how to add one child (My Buffer type) in two container. Any idea? Thanks
06:04:44 <ivanm> ManateeLazyCat: any particular reason you don't just help out with yi?
06:05:39 <ManateeLazyCat> ivanm: I'm not just for editor, editor just sub-project in my project.
06:06:01 <ManateeLazyCat> ivanm: My target not just for editor.
06:06:30 <ManateeLazyCat> My aim is develop a Haskell dynamic environment, i can do everything in it.
06:06:39 <vixey> what is Haskell dynamic environment
06:07:05 <vixey> you should get together with the other people that want to write an editor for haskell
06:07:46 <ManateeLazyCat> A dynamic core make me code can update in runtime, and don't need restart this environment.
06:08:13 <ManateeLazyCat> Simple, it's a programming self environment, like Emacs, but more powerful, not just for editor.
06:08:55 <ivanm> what else would it do?
06:09:00 <ivanm> hi mmorrow
06:09:12 <ivanm> wli was having problems getting vacuum compiling before...
06:09:16 <ivanm> does it work with 6.10?
06:10:13 <mmorrow> ivanm: hiya
06:10:27 <mmorrow> ivanm: it only works with 6.10.{1,2}
06:10:28 <ManateeLazyCat> vixey: I have enough knowledge to design editor, and now i just want develop it self. Of course, i will release it if it powerful enough.
06:10:42 <ivanm> mmorrow: well, that's what he was using it with...
06:10:47 <mmorrow> ivanm, wli: what was the error?
06:10:47 * ivanm tries to find the build output
06:10:57 <mmorrow> (it builds fine for me on both)
06:11:14 <ivanm> http://wli.pastebin.com/m5349aebf
06:11:26 <mmorrow> i build via Setup.lhs though, dunno if that's related
06:11:27 <ivanm> Cabal issue
06:11:28 * mmorrow looks
06:12:58 <mmorrow> ah, yeah that's the same weird cabal error that happens on hackage that prevents the docs from building there
06:13:06 <mmorrow> i dunno what it's deal is
06:13:10 <ivanm> hmmm....
06:13:14 * mmorrow checks his cabal version(s)
06:13:17 <wli> http://wli.pastebin.com/m7416d9aa
06:13:30 <ivanm> mmorrow: that reminds me... I think I've asked you this before, but why do you have your own haskell-src library?
06:13:32 <ivanm> for TH?
06:13:33 <mmorrow> [m@monire ~]$ ghc-pkg list Cabal
06:13:33 <mmorrow> /usr/local/ghc/ghc-6.10.1/lib/ghc-6.10.1/./package.conf:
06:13:33 <mmorrow>     Cabal-1.6.0.1
06:13:56 <mmorrow> ivanm: it translates the haskell-src-exts AST to the TH ast
06:14:03 <ivanm> *nod*
06:14:09 <ivanm> so you can manipulate it via TH?
06:14:17 <mmorrow> and it has a bunch of utils that make working with TH more bearable
06:14:24 <mmorrow> , parseExp "42"
06:14:25 <lunabot>  Right (LitE (IntegerL 42))
06:14:28 <ivanm> mmorrow: have you tried building it just from the tarball?
06:14:30 <mmorrow> , [|42|]
06:14:32 <lunabot>  LitE (IntegerL 42)
06:14:32 <ivanm> i.e. not in your hacking dir
06:14:39 <mmorrow> ivanm: yes
06:15:01 <ivanm> hmmm... to all those people that told me I should use a Set-based replacement for nubBy... it seems to be a bit slower to use Set if anything :s
06:15:18 <mmorrow> ivanm: i'm gonna ask dcoutts what he thinks is going on with that..
06:15:32 <ivanm> mmorrow: OK, just checking because Saizan_ and I just went over why you should be careful about that kind of thing with J-roen
06:15:34 <ivanm> ;-)
06:15:36 <ivanm> mmorrow: *nod*
06:15:48 <mmorrow> heh
06:15:49 <wli> ivanm: Constant factors; if the list is tiny it'll be slower. If the list is huge Set wll win.
06:16:06 <ivanm> that is of course if our beloved Cabal hacker (who strenously denies the existence of any Haskell Cabal) actually turns up at some point whilst pretending not to be here...
06:16:16 <ivanm> wli: well, I don't think the list is tiny...
06:16:47 <ivanm> but I'll try profiling it with the Set method
06:17:22 <mmorrow> wli: hmm, so you have Cabal-1.6.0.2 then?
06:17:39 <mmorrow> i wonder if PackageName has changed..
06:17:52 <wjt> what's an orphan instance?
06:17:54 <wli> yeah
06:18:47 <ivanm> wjt: when you define an instance in a different module from where either the class or the data structure are defined
06:18:50 <mmorrow> i don't know how it possibly could have, this seems like a bug to me (since i'm only using PackageName to talk to ghc)
06:19:09 <wli> no clue
06:19:12 <mmorrow> and as such, since we're both on ghc-6.10.{1,2} how could it be diff?
06:19:14 <mmorrow> weird
06:19:17 <ivanm> mmorrow: I don't think it would have changed, since dcoutts normally leaves data structure setup the same in the same major version...
06:19:27 <wjt> ivanm: ah yes
06:19:37 <wjt> grrr why is State not Applicative
06:19:39 * mmorrow is tempted to just use unsafeCoerce ;)
06:19:52 <ivanm> wjt: just to annoy you?
06:20:11 <wjt> yeah
06:20:32 <wjt> this means i have to use my hand-rolled specialization of traverse, or have orphan instances, or litter my code with newtype
06:20:35 <wjt> grumble grumble
06:20:45 <ivanm> wjt: orphan instances mean nothing
06:20:55 <ivanm> just a kind of possible "bad code smell"
06:21:17 <mmorrow> ok, since it just needs PackageName to init ghc's global vars in an extremely roundabout way, maybe i can just cut that out altogether and init ghc slightly differently..
06:21:31 * mmorrow tries
06:21:42 <wjt> i could just -fno-warn-orphans
06:21:47 <wjt> but i hate disabling warnings
06:22:45 <Berengal1> Ugh, coding for 16 hours straight isn't healthy for the mind
06:23:34 <Berengal1> I'm probably going to have to refactor all the work done in the last five away anyway..
06:25:43 <Saizan_> ivanm: what do you mean by Set method? S.toList . S.fromList or using a Set as accumulator for seen values?
06:25:59 <vixey> Berengall: Or the body
06:26:12 <ivanm> Saizan_: Set as a lookup table for which values have already been seen
06:26:18 <vixey> Berengall: You should be very careful to not get stressed and pain (RSI)
06:26:24 * ivanm didn't think it would be any better than nubBy
06:27:29 <mmorrow> ivanm, wli: hmm, the best i can tell is that ghc is expecting Cabal-1.6.0.1:Distribution.Package.PackageName, but is getting Cabal-1.6.0.2:Distribution.Package.PackageName
06:27:41 <mmorrow> i'm not sure if they're identical yet
06:28:00 <Berengal1> vixey: I'm more worried about the fact that each function I've written seems to be two lines longer than the last
06:28:04 <wli> hmm
06:28:06 <Saizan_> same types from different package versions are considered distinct by ghc.
06:28:40 <vixey> Berengall: that is less important
06:28:44 <Saizan_> cabal in fact will refuse to build a package if it needs to use two versions of the same package in the dependency graph
06:28:57 <Saizan_> "cabal-install" i mean
06:28:58 <mmorrow> yeah, they're identical
06:29:06 <Saizan_> Cabal the library gives only a warning
06:29:17 <ivanm> anyone here familiar with prof2dot?
06:29:26 <Berengal1> And that the last 50 lines have all wrapped around on a 190 char wide display...
06:29:43 <mmorrow> Saizan_: does ghc 6.10.1/2 expect to be have exactly Cabal-1.6.1?
06:29:46 <Berengal1> No, my mental health is probably in more danger...
06:30:28 <ivanm> mmorrow: you meant 1.6.0.1 ?
06:30:38 <mmorrow> Saizan_: because it seems that ghc wants Cabal-1.6.0.1:Distribution.Package.PackageName exactly
06:30:40 <ivanm> 6.10.1 does, or some bad things happen
06:30:42 <mmorrow> ivanm: yes
06:31:08 <ivanm> 6.10.2 uses 1.6.0.3 IIRC
06:31:23 <Saizan_> mmorrow: ghc-6.10.1 (the package) is built against Cabal-1.6.0.1
06:31:36 <Saizan_> mmorrow: so you need to use that version of Cabal to deal with it
06:31:45 <mmorrow> hmm, it looks like yeah 6.10.2 want 1.6.0.3
06:32:08 <Saizan_> in fact there's the warning i was mentioning earlier in wli's log
06:32:20 <Saizan_> Warning: This package indirectly depends on multiple versions of the same
06:32:20 <Saizan_> package. This is highly likely to cause a compile failure.
06:32:27 <mmorrow> Saizan_: the thing is though that i'm not specifying a particular cabal version, and the types are the same
06:32:53 <Saizan_> wli: i think "cabal install vacuum" should just work
06:32:59 <mmorrow> so do i
06:33:13 <mmorrow> but apparently this error is also occurring on hackage
06:33:30 <Saizan_> mmorrow: emerge uses Setup.hs configure, which doesn't do the smart dependency resolution, like cabal-install does
06:33:44 <mmorrow> Saizan_: but i use Setup configure too
06:33:45 <Saizan_> mmorrow: so it pick the latest Cabal available
06:33:50 <Saizan_> *pocks
06:33:52 <Saizan_> Picks
06:33:56 <Saizan_> whatever.
06:34:08 <ivanm> mmorrow: do you have both Cabal versions installed?
06:34:17 <ivanm> i.e. 1.6.0.{1,2} ?
06:34:32 <mmorrow> ivanm: i have the Cabal that came with 6.10.1 for 6.10.1, and the cabal that came with 6.10.2 for 6.10.2
06:34:37 <Saizan_> if you only have one version of Cabal installed there's no problem
06:34:46 <ivanm> OK, so that looks like the issue
06:34:49 <Saizan_> there isn't a wrong one to choose
06:34:54 <ivanm> you can't use an updated cabal
06:35:38 <mmorrow> ok, so i think the solution is to require (ghc==6.10.1 && Cabal == 1.6.0.1) || (ghc==6.10.2 && Cabal==1.6.0.3)
06:35:42 <mmorrow> in the build-depends
06:36:07 * mmorrow goes with that
06:36:12 <ivanm> OK, looks like for me to fix my nubBy problems I've got to do as much pre-filtering as possible
06:36:41 <Saizan_> mmorrow: that's a non-solution though, we should really let cabal-install deal with that.
06:37:00 <ivanm> mmorrow: which is ugly and hackish
06:37:07 <mmorrow> Saizan_: yes indeed, but at least this would make it build on hackage and for wli
06:37:19 <Saizan_> but if you want to make it easier for Setup.hs configure users..
06:37:22 <gwern> 'So the Twitter team turned to Scala, a programming language with its origins in work by Martin Odersky, professor at EPFL in Lausanne, Switzerland, around 2003. During his presentation, Payne, who's also writing a book on the language, explained that Scala has many of the benefits of other languages but without the drawbacks. Some of the characteristics that make Scala so appealing to Twitter is that it's able to efficiently handle ...
06:37:28 <gwern> ... concurrent processing--that is, separate instructions that need to use the system's resources at the same time. This is useful when messages from millions of people need to be sent out instantly to different devices all over the world. '
06:37:32 * Saizan_ wonders why hackage doesn't use cabal-install
06:37:33 <gwern> http://www.technologyreview.com/blog/editors/23282/?nlid=1908
06:37:56 <ivanm> Saizan_: because dcoutts has too many things on his plate as it is?
06:38:04 <gwern> 'The user interface runs on Ruby on Rails, which is "fine for people clicking around Web pages," he says. But by the end of the year, Twitter hopes to have a set of services in the back end that are written entirely in Scala. And it's the company's plan to make sure that all the third-party services that connect to Twitter via the application programming interface (API) go through Scala code, bypassing Ruby on Rails completely.'
06:38:34 <gwern> good news for haskell, I suppose. another datapoint suggesting that FP and parallel programming are two great flavors that go great together
06:38:37 <Saizan_> maybe cabal-install wasn't enough stable when they started with logs :)
06:38:51 <ivanm> Saizan_: yeah
06:39:17 <ivanm> even still, the logs often fail because they don't have gtk2hs installed (as it isn't cabalized)
06:39:28 <ivanm> Saizan_: actually, so how _do_ they do it then if they don't use cabal-install?
06:39:46 <ivanm> since they must somehow go and build all dependencies first (at least the cabalised ones...)
06:40:05 <Saizan_> i don't know
06:40:31 <Saizan_> however the solution is to complete the hackage-server so we can have bots that send build-reports using cabal-install
06:40:55 <mmorrow> bots doing our bidding!
06:41:09 <ivanm> and then they form skynet?
06:41:15 * mmorrow wonders how long before the bots turn on us
06:41:25 <Saizan_> well, regular users too :)
06:41:33 <mmorrow> cabal install foo
06:41:36 <Saizan_> did you see CADIE?
06:41:40 <mmorrow> *** i'm sorry dave, i can't do that.
06:41:46 <ivanm> Saizan_: yeah...
06:41:50 <ivanm> didn't really get that...
06:42:08 <ivanm> (I know it was an april fools... but I think they outsmarted themselves with the gobbledygook)
06:42:13 <ivanm> the INTERCAL style manual was better
06:42:22 <ivanm> and the Fortran 77 bindings for their services
06:49:19 <adimit> A question about data types: data Type = Type (Maybe Subtype); data Subtype = Subtype; class Class where ...; instance Class Type ...; instance Class Subtype ...; I want a function f :: (Class a) => Maybe a -> a; f = Type. This doesn't work, because it tries to match both Subtype and Type to a.
06:50:03 <adimit> I have a huge hierarchy of this kind (XmlContent with HaXml) and I want a function that takes on type of the class and maybe another type to produce a full type. Is there a way to do this?
06:50:15 <vixey> admit: you shoudl define f :: Maybe Type -> Type
06:51:25 <mmorrow> Saizan_: how do you say this in valid build-depends sytax:
06:51:29 <adimit> vixey: I don't understand... I wanted the function to take a maybe Subtype and produce a Type, so I thought the signature should be f :: Maybe Subtype -> Type
06:51:37 <mmorrow> ...,(ghc == 6.10.1 && Cabal == 1.6.0.1) || (ghc == 6.10.2 && Cabal == 1.6.0.3), ...
06:51:40 <mmorrow> ?
06:51:52 <adimit> but I have a huge hierarchy and I'd like that to be generic, not apply to only one pair of types.
06:52:04 <ivanm> mmorrow: or should you use base versions?
06:52:07 <mmorrow> do i have to duplicate the entire build-depends for each ||?
06:52:19 <mmorrow> ivanm: this is only on account of ghc though
06:52:28 <ivanm> oh, yeah...
06:52:29 <mmorrow> (i'm requiring base==4
06:52:30 <mmorrow> )
06:52:36 <Saizan_> mmorrow: you need to use a flag and an if
06:52:44 <ivanm> what do the brackets around ghc-* mean in ghc-pkg list?
06:52:49 <Saizan_> mmorrow: and put those on different build-depends lines
06:53:09 <mmorrow> Saizan_: hmm, how does the flag get triggered depending on the ghc version?
06:53:13 <mmorrow> or whatever
06:53:15 <ivanm> Saizan_: couldn't he just have the || statement on its onw build-depends line?
06:53:23 <vixey> adimit: then write f :: Maybe Subtype -> Type
06:53:29 <Saizan_> mmorrow: and then have a different build-depends with the other deps
06:53:38 <Dunearhp> I'm trying to compile one of the demos in gtk2hs. I am getting an ambiguous type variable error.
06:53:40 <Dunearhp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2041#a2041
06:53:51 <Saizan_> mmorrow: the flags backtrack until a working configuration is found
06:53:59 <Saizan_> mmorrow: unless the user sets one explicit
06:54:04 <mmorrow> Saizan_: hmm, ok
06:54:05 <Dunearhp> I can't work out how to rectify it
06:54:06 <Saizan_> *explicitly
06:54:37 <Dunearhp> or exactly how it is ambiguous in this case
06:55:45 <tomh> how can i get the time difference in seconds from a nominaltimediff?
06:56:22 <adimit> vixey: thanks, but this wouldn't work in my case. I need that to be a type signature of another data type, which represents a tree structure. The tree nodes hold these functions as payloads. Basically, I should be able to fold the trees up from the leaves to yield a complete data type. But since I have Subsubsubtypes even, it won't work by specifying the types explicitly.
06:57:09 <vixey> sound like OO or something
06:59:34 <adimit> vixey: well, I'm sure one could model that using OO, but I think that the idea of having a bunch of partial functions as a data structure and then combining them together to yield a result is also deeply functional :-)
07:00:34 * vixey doesn't
07:00:34 <vixey> but you can probably do it in Haskell anyway
07:00:47 <mmorrow> grr, numbers aren't allowed in flags..
07:00:53 <mmorrow> flag ghc-six-ten-one
07:00:55 <mmorrow> ;)
07:01:42 <adimit> well, it's a question of taste and definition, too. But I don't *know* how to do it in Haskell right now :-(
07:02:16 <wli> uh-oh
07:04:04 <sioraiocht> does the category of sets and binary relations have binary products?
07:04:23 * sioraiocht thinks not, but isn't sure why
07:05:07 <byorgey> sioraiocht: yes, it does
07:05:39 <sioraiocht> byorgey: damn, i suppose it has a terminal object too, doesn't it?
07:05:50 <byorgey> sioraiocht: binary product and coproducts are the same in Rel, namely, disjoint union
07:06:26 <sioraiocht> byorgey: that makes sense
07:06:40 <byorgey> since Rel and Rel^op are isomorphic
07:07:08 <mmorrow> wli, Saizan_, ivanm: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.8
07:07:54 <byorgey> and the empty set would be the terminal/initial object, yes?
07:08:34 <sioraiocht> byorgey: so for f1: A -> B and f2:A -> C, <f1,f2> A -> disjount union(B,C)?
07:08:45 <ivanm> mmorrow: hmmm.... seems hackport turns that into only 6.10.1 support...
07:08:46 <mmorrow> (terminal==initial)<==>(product==coprod)
07:09:00 <mmorrow> ivanm: what is hackport?
07:09:38 <ivanm> cabal -> ebuild (for gentoo)
07:09:48 <mmorrow> (wget+ghc+Setup.lhs or cabal-install)==ftw :)
07:10:27 <RayNbow> byorgey: I read your typeclassopedia recently, it was awesome :)
07:10:37 <byorgey> thanks RayNbow =)
07:10:41 <RayNbow> (ok, except for 1 typo :p)
07:10:46 <trofi> :]
07:10:50 <byorgey> oh noes!
07:10:54 <byorgey> what was the typo?
07:10:54 <mmorrow> ivanm: it looks like the author of hackports needs to fix his cabal parsing/etc logic to handle flags
07:11:03 * ivanm points to kolmodin 
07:11:05 <ivanm> ;-)
07:11:09 <mmorrow> :)
07:11:11 <kadaver> so what's the name of that freanch gameing-company that makes gameworlds using Haskell Pyton and C?
07:11:23 <RayNbow> byorgey: somewhere, there's an "a" missing in Monad
07:12:19 <RayNbow> byorgey: pg. 43, "MondZero"
07:12:53 <kadaver> String -> M.Map String (M.Map String Int)
07:13:56 <kadaver> thts what i ahve, ic ant figure out how to properly insert into theinner map. it is a map over words and the counts of the words following them. fromList [("hello", fromList [("there", 12),("sir",5)])]
07:14:11 <sioraiocht> A x B + A x C = A x (B + C), right?
07:14:48 <sioraiocht> (for product and coproduct)
07:14:56 <kadaver> si
07:15:10 <kadaver> copdroduct i dont know what is
07:16:46 <vixey> ?djinn Either (A , B) (A , C) = (A , (Either B C))
07:16:47 <lambdabot> Cannot parse command
07:16:50 <vixey> ?djinn Either (A , B) (A , C) -> (A , (Either B C))
07:16:51 <lambdabot> Error: Undefined type A
07:17:01 <vixey> ?djinn Either (a , b) (a , c) -> (a , (Either b c))
07:17:02 <lambdabot> f a =
07:17:02 <lambdabot>     case a of
07:17:02 <lambdabot>     Left (b, c) -> (b, Left c)
07:17:02 <lambdabot>     Right (d, e) -> (d, Right e)
07:17:08 <vixey> ?djinn (a , (Either b c)) -> Either (a , b) (a , c)
07:17:08 <lambdabot> f (a, b) =
07:17:09 <lambdabot>     case b of
07:17:09 <lambdabot>     Left c -> Left (a, c)
07:17:09 <lambdabot>     Right d -> Right (a, d)
07:17:29 <vixey> you can tell it's an isomophism by counting occurences
07:17:38 <vixey> (or trying to linear typecheck it, I guess)
07:21:24 <kadaver> did Dijkstra have any kids?
07:22:32 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3294#a3294 <- thats kind of what I want but I want to unionWith or something.like if hello is followed by there at 2 places it should say fromList[(hello,fromList [(there,2)])]
07:25:03 <roderyk> http://pithyless.com/blog/2009/04/04/haskell-stats-project-euler/   I was bored, maybe someone will be amused ;]
07:27:20 <kadaver> gotit!
07:27:51 <sioraiocht> so byorgey, <f1, f2> = f1 + f2?
07:28:16 <byorgey__> sioraiocht: yes, I think so
07:28:33 <sioraiocht> byorgey__: okay, thanks, now that i understand the problem i can probably do it, heh
07:28:39 <byorgey__> =)
07:29:01 <kpreid> I'm trying to follow the instructions at the bottom of http://trac.macports.org/ticket/14757 . I don't know anything about Cabal. I've installed the GL packages, but ghc doesn't automatically find them -- what do I do?
07:32:00 <Saizan_>    --extra-include-dirs=PATH      A list of directories to search for header
07:32:00 <Saizan_>     --extra-lib-dirs=PATH          A list of directories to search for external
07:32:41 <Saizan_> kpreid: you can pass those flags to cabal install to point it to the right directory
07:32:55 <kpreid> hm
07:33:00 <mmorrow> roderyk: that would look pretty cool if you graphed it somehow
07:33:02 <kpreid> not automatic?
07:33:21 <kpreid> how do I find out what the appropriate paths are?
07:33:35 <kpreid> or are they just $prefix/lib /include?
07:33:40 <Saizan_> kpreid: ah, wait
07:33:46 <Saizan_> kpreid: maybe i misunderstood you
07:33:49 <roderyk> mmorrow: I plan to play with that, just I should be getting around to some work today :-)
07:34:09 <mmorrow> roderyk: heh, story of my life :)
07:34:11 <Saizan_> kpreid: you've already installed the haskell OpenGL and GLUT?
07:34:40 <kpreid> $ cabal install OpenGL GLUT
07:34:59 <kpreid> I did that, after installing cabal and $ cabal update
07:35:02 <Saizan_> and that worked with no errors?
07:35:18 <kpreid> no errors
07:35:32 <Saizan_> ok, so what are you doing now and which error are you getting?
07:35:35 <Dunearhp> can someone tell me how to get cabal to upgrade its packages after a ghc upgrade?
07:35:53 <kpreid> ghc <my program> => Failed to load interface for `Graphics.Rendering.OpenGL':
07:36:47 <Saizan_> that looks like the files are gone from the installation
07:38:00 <Saizan_> "ghc-pkg field OpenGL import-dirs" should give you a path, can you check if the .hi files are there?
07:38:14 <kpreid> my ghc and cabal are installed under an oddball prefix, btw, and thru macports
07:38:33 <kpreid> aah
07:38:40 <kpreid> $ ghc-pkg field OpenGL import-dirs
07:38:41 <kpreid> import-dirs: /Users/pkgacct/.cabal/lib/OpenGL-2.2.1.1/ghc-6.10.1
07:39:09 <kpreid> something's screwy. why is a systemwide package db pointing into one account's files?
07:39:20 <kpreid> that dir *is* readable though
07:39:29 <p_l> pkgacct?
07:39:39 <Saizan_> "cabal install" installs in the user packagedb by default
07:39:54 <Saizan_> you need --global if you want a global install
07:39:57 <kpreid> Saizan_: er...then why is a different user seeing it?
07:40:46 <Baughn> Saizan_: Well, --global and --root-cmd, unless the "global" install is in your homedir
07:41:18 <Saizan_> kpreid: not sure, the user db is under ~/.ghc/
07:41:43 <kadaver> When I am barred from creating new syntactic constructs, I feel like a "human compiler" (in fact, exactly that which the job title "programmer" actually meant in practice before the invention of actual compilers.)
07:41:51 <kadaver> ^^quote
07:42:03 <Saizan_> however it must also contain the necessary .hi files, like Graphics/Rendering/OpenGL.hi
07:42:04 <kadaver> i feel like a plumber in java and c++
07:42:14 <kadaver> is haskell a new dawn?
07:42:34 <kpreid> Saizan_: Oops.
07:42:36 <kadaver> programmer meant human compiler, then it was degraded to plumber
07:42:41 <kadaver> not it means dsl writer
07:42:46 <kadaver> not->now
07:42:50 <kpreid> Saizan_: Got my accts confused.
07:44:51 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3295#a3295 <- can anyoen simplify that one?
07:44:56 <Saizan_> kpreid: ah ok, so you were installing and using ghc-pkg from an account and trying to compile your program with another?
07:45:04 <kpreid> yes
07:45:17 <Saizan_> ok, that makes sense now :)
07:45:38 <kpreid> hm, cabal install --global does not use the prefix it itself was installed under
07:45:57 <kpreid> it tried to access /usr/local/share
07:46:13 <kadaver> is Data.Map as redblack tree?
07:46:19 <mmorrow> kadaver: no
07:46:38 <mmorrow> kadaver: there's a link to the paper describing the structure on the Data.Map haddocks
07:47:00 <mmorrow> kadaver: also, IntMap is a different structure than Map
07:47:14 <mmorrow> kadaver: (it too has a link to a paper on its haddocks)
07:47:42 <kadaver> more like an AVL tree?
07:47:43 <Saizan_> kpreid: there's --prefix= for that, you can also set it in the ~/.cabal/config file
07:47:52 <mmorrow> kadaver: not an AVL tree wither
07:47:54 <mmorrow> *either
07:48:05 <mmorrow> kadaver: read the paper :)
07:48:32 <bremner> RTFP
07:48:48 <kpreid> Saizan_: sure, I'm just thinking it should have been automatic
07:48:52 <mmorrow> heh, haskell is totally s/RTFM/STFP/
07:49:04 <mmorrow> gah
07:49:08 <mmorrow> s/RTFM/RTFP/
07:49:43 <bremner> s/STFP/STFU/ ?
07:49:55 <mmorrow> yes that too.
07:50:33 <Saizan_> kpreid: uhm, it makes sense, you should open a ticket on the Cabal trac
07:51:04 <kpreid> Saizan_: Thanks for the help so far.
07:51:23 <Saizan_> kpreid: np.
07:51:24 <mmorrow> kpreid: if you were to work out an (at least pseudocode) algo to do it automatically, i bet that would get implem pretty quickly
07:52:36 <kadaver> is there a hash function in haskell?
07:52:56 <voker57__> Crypto?
07:54:00 <bremner> kadaver: isn't such a thing about 1 line of haskell?
07:56:33 <Saizan_> thinking more about it, i usually install cabal-install as an "user" program
07:56:50 <Saizan_> so --global using the same prefix won't do the right thing
07:57:43 <Saizan_> and it's more obvious how it works if the default is fixed
07:58:34 <lilac> bremner: yes, but you need the /right/ line ;-)
08:00:13 <kadaver> Yeah I see how Data.HashTable doesn't fit into haskell at all really.
08:00:45 <kadaver> bremner: well a correct hash function is the hard part, not just a hash function
08:00:59 <bremner> kadaver: see Knuth
08:01:09 <kadaver> knuth is a noob
08:01:23 <EvilTerran> ?hackage bloomfilter
08:01:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bloomfilter
08:01:28 <bremner> kadaver: if you are smarter than Knuth, you should have no problems
08:01:29 <lilac> > let djb2 = foldl' (\h x -> h * 33 + fromEnum x) 5381 in djb2 "Hello world"
08:01:31 <lambdabot>   -4618968068742504287
08:01:33 <EvilTerran> has Data.BloomFilter.Hash
08:01:56 <mmorrow> lol
08:02:06 <mmorrow> @remember kadaver knuth is a noob
08:02:06 <lambdabot> It is stored.
08:02:34 <bremner> Nietche is dead. God.
08:02:43 <bremner> err, spelling?
08:02:48 <athos> nietzsche
08:02:54 <bremner> danke
08:03:08 <athos> hehe
08:03:34 <lilac> @pl \h x -> h * 33 + fromEnum x
08:03:35 <lambdabot> (. fromEnum) . (+) . (33 *)
08:06:18 <gwern> @quote dead
08:06:28 <lambdabot> jml says: A wise man once said, "the program isn't debugged until the last user is dead".
08:09:05 <lilac> @quote horrible
08:09:05 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
08:09:14 <lilac> @quote horrible
08:09:15 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
08:09:32 <Baughn> The main purpose of.. what? State, I suppose.
08:09:40 <Baughn> Or ST>
08:10:03 <lilac> @quote formatting
08:10:04 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
08:10:20 <ski> @ghc
08:10:20 <lambdabot> ghc says: Unexpected type splice
08:10:29 <Baughn> @quote st
08:10:29 <lambdabot> ghc says: Exotic Stmt in meta brackets
08:10:59 <lowmagnet> So I'm looking at a C# program (work related) and I have the hardest time following it because of the ease of haskell
08:11:09 <lowmagnet> C# is like }{}{}{}{}}}{{{}}}{}}}{ everywhere
08:11:20 <lilac> lowmagnet: have you seen 'learning haskell makes you a worse programmer'?
08:11:43 <lowmagnet> lilac: is that the article that mentions the ways haskell spoils you?
08:11:43 <mstr> haskell is like  f'gg'fggf'fg'g'fg'foldliftM2 f g ''f' :)
08:11:58 <lilac> yeah
08:12:05 <lowmagnet> lilac: yeah i love that
08:12:05 <mstr> lilac: link pls
08:12:45 <lilac> mstr: http://lukeplant.me.uk/blog.php?id=1107301645
08:12:54 <mstr> ty
08:13:02 <skorpan> if i have "type TT = Tok Token", why can't i do "instance Strokable TT where"?
08:13:08 <vixey> @remember  <mstr> haskell is like  f'gg'fggf'fg'g'fg'foldliftM2 f g ''f' :)
08:13:09 <lambdabot> Done.
08:13:32 <trofi> , [t| 1 |]
08:13:33 <lunabot>  luna: Number types (for generics) not (yet) handled by Template Haskell 1
08:19:01 <RayNbow> lilac, are you referring to this blog post? http://lukeplant.me.uk/blog.php?id=1107301645
08:20:49 * lilac sends answer back in time 8 minutes... now if only i could do that with the lottery numbers
08:21:54 <RayNbow> :p
08:22:15 <kadaver> did Data.Map actually beat the F square code in Harrop's benchmark?
08:22:15 <b_jonas> lilac: that wouldn't help: I think there's more than 8 minutes delay between the last time you can post a lottery ticket and the drawing the numbers
08:23:32 <lilac> b_jonas: i'm sure i could find a bookmaker who'd take a bet on lottery results :)
08:25:57 <b_jonas> anyway, channel, do you have an opinion in general on such abstractions where I just restrict a type with a newtype to a smaller interface, so in code I could use the original type but this one documents my intention that I only need parts of the capabilities?
08:26:30 <vixey> b_jonas: do you have an example of this?
08:26:46 <gwern> vixey: well, instead of just State, he could break it down into Writer and Reader
08:28:15 <b_jonas> vixey: sure, for example I could define a newtype on Mvar that only has such a variant of putMVar that it's an error to put an already full box, so this is used for locking a resource to be used only by a single thread at once
08:28:34 <vixey> oh yeah that's fine
08:28:36 <vixey> stuff like that is cool
08:28:49 <vixey> you got to be careful hiding away the implementation of the newtypes is all
08:29:35 <b_jonas> or I could wrap a Seq so it behaives like a dequeue, though I think EdisonCore has a real dequeue which might be more efficent
08:29:54 <kpreid> @hoogle [a] -> [[a]]
08:29:54 <lambdabot> Data.List inits :: [a] -> [[a]]
08:29:54 <lambdabot> Data.List tails :: [a] -> [[a]]
08:29:54 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
08:29:58 <b_jonas> (or just a queue. general dequeue is rarely useful)
08:31:32 <kpreid> @hoogle [a] -> a -> [a]
08:31:33 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:31:33 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:31:33 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:32:02 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3296#a3296 <- I improved the strip functiona  little bit. pumpkins excellent function doesnt extend to stripping several chrs though. but the one I did stripAll feels a bit ugly and ilvolves reversing the string twice which feels ugly to say the last.
08:32:14 <b_jonas> hmm, shouldn't that list (:) as well?
08:32:22 <trofi> can i parse String directly into ExpQ in TH?
08:32:59 <trofi> smth like $( dark_magic_eval "2*3" )
08:33:48 <kadaver> boegel: did you finish your netflix experiemtn?
08:35:02 <boegel> kadaver: I needed to finish up on an important paper, and got married, so I haven't found time
08:35:14 <boegel> kadaver: but I'm still planning to continue with it
08:35:33 <boegel> kadaver: I'm focusing on something different (in Haskell) right now, but I'll return to the Netflix thing asap
08:36:22 <kadaver> ok cool. and congrats
08:39:44 <chessguy> congrats, by the way, boegel . great pictures
08:39:56 <boegel> chessguy: thanks :)
08:40:56 <boegel> kadaver: thanks also... glad to see someone is reading my blog ;-)
08:41:34 <b_jonas> reading? they're just watching the pics
08:41:59 <boegel> b_jonas: they'd have to read to realize there are pics, unles they're randomly following links ;-?
08:42:11 <boegel> s/?/)/
08:46:48 <michaelcdever> allo, is there a function for copying a directory in the System library? im looking but i cant see it
08:52:50 <bakesz> hi guys!could somebody help me?is there a function which converts string to number?
08:54:12 <boegel> @hoogle String -> Int
08:54:13 <lambdabot> Prelude read :: Read a => String -> a
08:54:13 <lambdabot> Text.Read read :: Read a => String -> a
08:54:13 <lambdabot> Prelude error :: String -> a
08:54:20 <boegel> bakesz: does that help? :)
08:54:25 <b_jonas> ok, so here are some stupid questions about ghc concurrency. is there an easy way to print the number of threads currently existing in the program for debugging or do I have to maintain a counter by hand?
08:54:47 * boegel stopped doing things by hand since he got married
08:54:48 <b_jonas> secondly, what's the proper way to exit the whole program on an error? killing the main thread?
08:55:11 <b_jonas> I'm not planning getting married yet.
08:55:37 <boegel> b_jonas: killing the main thread should cause the OS to kill the children
08:56:44 <Baughn> b_jonas: I prefer calling exit
08:57:03 <Baughn> ..well, exitFailure
08:57:41 <b_jonas> I see
08:58:09 <vixey> if  A -> A'  and B' -> B  ... what's (A',B) -> (A,B') called
08:58:20 <vixey> some kind of natural contrafunctorvariant homthingy..
08:58:35 <Baughn> b_jonas: If you like, use forkIOE act = forkIO act `onException` exitFailure
08:58:51 <b_jonas> Baughn: okay
08:59:36 <Baughn> Hmm. forkIOE = flip onException exitFailure . forkIO?
08:59:43 <Baughn> @pl forkIOE act = forkIO act `onException` exitFailure
08:59:43 <lambdabot> forkIOE = (`onException` exitFailure) . forkIO
09:00:26 <b_jonas> so I shoulnd't be using this undocumented setUncaughtExceptionHandler which the docs of Control.Concurrent.forkIO alludes to, right?
09:00:46 <Baughn> b_jonas: Nope, onException is the safe, stable API to that.
09:00:52 <Baughn> b_jonas: ..well, or finally
09:01:00 <Baughn> b_jonas: Or just try.
09:01:04 <Baughn> With SomeException.
09:01:33 <Baughn> At any rate, using undocumented functions when there are documented, /nicer/ functions available seems a bit odd. :P
09:02:11 <Baughn> @src SomeException
09:02:12 <lambdabot> Source not found. Where did you learn to type?
09:02:49 <Baughn> ..well, that source was useless
09:03:22 <tomh> lol is SomeException an actual type ?
09:03:35 <Baughn> Yes, it's the base.. type for exceptions
09:03:38 * Baughn wanted to say "class"
09:03:39 <vixey> wait it's more like
09:03:47 <Baughn> More like wrapper type, really
09:03:52 <Baughn> "data SomeException = forall e . Exception e => SomeException e"
09:04:02 <vixey> (P' -> P) & (Q -> Q') ==> f P Q -> f P' Q'
09:04:02 <tomh> im very curious what some of the core haskell lib designers smoked when they come up with names
09:04:11 <vixey> is there a name for this?
09:04:14 <Baughn> tomh: It's a perfectly descriptive name
09:04:33 <Baughn> vixey: Umh. I'm not sure, but.. on?
09:04:35 <vixey> it's like slipping on ice skates
09:04:35 <Baughn> @type on
09:04:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:04:38 <tomh> why not just call it Exception
09:04:45 <tomh> or BaseException
09:04:47 <Baughn> Okay, not quite
09:04:47 <b_jonas> I like it too. You know how the standard ml name for Just is SOME
09:04:48 <vixey> it's a category theory thing, I'm sure
09:05:00 <vixey> I read it somewhere but I dont' remember it
09:05:15 <Baughn> tomh: Exception is the class. SomeException is a /particular/, /concrete/ value in the Exception class.
09:05:34 <tomh> i would call it BaseException then or something
09:06:03 <kadaver> how do i bitshift in haskell?
09:06:17 <|jedai|> kadaver: Data.Bit
09:06:29 <b_jonas> Data.Bits actually
09:06:29 <|jedai|> @lookup shiftl
09:06:30 <lambdabot> Unknown command, try @list
09:06:39 <|jedai|> @hoogle shiftl
09:06:40 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
09:06:43 <b_jonas> > shiftL 5 2
09:06:45 <lambdabot>   Add a type signature
09:06:51 <b_jonas> > shiftL 5 2 :: Int
09:06:52 <lambdabot>   20
09:07:21 <|jedai|> usually used as infix :
09:07:34 <|jedai|> > 5 `shiftL` 2 :: Word8
09:07:37 <lambdabot>   20
09:07:38 <kadaver> and how do I get the int-value of a char?
09:07:47 <vixey> > let (<<) = shiftL in   2 << 4
09:07:48 <lambdabot>   Add a type signature
09:07:52 <jedai> kadaver: ord
09:07:55 <vixey> > let (<<) = shiftL in   2 << 4 :: Int
09:07:57 <jedai> from Data.Char
09:07:57 <lambdabot>   32
09:07:57 <b_jonas> > fromEnum '6'
09:07:58 <lambdabot>   54
09:08:05 <jedai> @hoogle Char -> Int
09:08:07 <lambdabot> Data.Char digitToInt :: Char -> Int
09:08:07 <lambdabot> Data.Char ord :: Char -> Int
09:08:07 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
09:08:08 <b_jonas> 32? wtf
09:08:11 <vixey> :P
09:08:20 <b_jonas> oh, that was for the previous one
09:08:22 <b_jonas> it's fromEnum, really
09:08:41 * Baughn /finally/ figured out how to find the type of arbitrary exceptions. Huh. Simple, really.
09:09:01 <Baughn> ..I should have realized the existential value in SomeException is an existential value
09:09:18 <Saizan_> existential value is existential?
09:09:37 <Baughn> Don't make me hit you.
09:10:51 <jedai> b_jonas: It is fromEnum, but ord is shorter and used in plenty other languages, so eventually more familiar... ^^
09:11:07 <jedai> > ord '6'
09:11:09 <lambdabot>   54
09:11:42 <jedai> @src ord
09:11:43 <lambdabot> Source not found. Just try something else.
09:11:45 <b_jonas> jedai: but actually ord in pascal is the equivalent of fromEnum, it works for any ordinal type (which are integral types, char, and user-defined C-like enums)
09:12:21 <b_jonas> and as for shorter, that's exactly the problem: haskell standard library functions should only be short if they're very general
09:12:40 <b_jonas> a specific function that converts a Char to Int should have a very long name if they followed the usual conventions
09:13:09 <b_jonas> three character names are for functions you don't understand unless you read abstract category theory articles for days
09:13:24 <Baughn> > do Left e <- try $ return $! 1 `div` 0;  case e of SomeException e' -> return $ typeOf e
09:13:25 <lambdabot>   Not in scope: `try'Not in scope: data constructor `SomeException'
09:14:54 <jedai> Baughn: Well e type is obviously SomeException, I guess you wanted e' type ?
09:15:16 <Baughn> jedai: True. I also forgot the \bot doesn't do IO.
09:15:35 <jedai> Baughn: That you can't get, you only know it's an instance of some typeclass (Show and Exception, maybe some others ?)
09:16:22 <bakesz> thanks,now my application works
09:16:31 <jedai> Baughn: You could use it's Exception instance and try to cast it into some specific type though
09:17:02 <jedai> And if all this has already been said forgive me for I just joined the channel
09:17:05 <Baughn> jedai: I also know it's an instance of Typeable. ;)
09:17:12 <Baughn> jedai: So it works fine. I just tried it locally.
09:17:28 <jedai> Baughn: I forgot that :)
09:18:45 <jedai> Baughn: I really like the new exception system, even though it means old code needs to be adapted : it's just much more powerful and flexible ^^
09:19:03 <Baughn> Oh yes. Now we just need to rewrite the base libs to use it.
09:19:06 <Baughn> Such as network...
09:20:27 <agcorona> what new exception system? has it changed?
09:21:21 <Baughn> agcorona: Oh yes. You can now throw any value that's an instance of Exception, catch them based on type, etc. :)
09:21:33 <Baughn> It's all very.. dynamically typed.
09:21:34 <b_jonas> agcorona: in 6.10 as compared to 6.8
09:33:30 <Cale> Heh, I dreamed that I accidentally rm -rf ~'d my machine but actually the power had gone out.
09:33:57 <b_jonas> Cale: heh
09:33:58 <mmorrow> teh horror!
09:34:14 <Cale> :]
09:34:23 * Baughn wonders why DRAM doesn't come with an erase command
09:35:02 <mmorrow> (set cook|30 sec|start) ?
09:35:13 <Baughn> ..that'd do
09:35:22 <mmorrow> have you ever done that with a cdr?
09:35:38 <pumpkin> I have
09:35:39 * mmorrow recommends it
09:35:43 <pumpkin> it's fun
09:35:55 <gwern> @quote cdr
09:35:56 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
09:36:06 <gwern> @remember Anonymous My other car is a cdr.
09:36:07 <lambdabot> Done.
09:36:39 <Baughn> It's also more than a bit dangerous. Burnt CDs produce carcinogenic gases and other nice stuff..
09:37:37 * mmorrow sighs
09:37:40 <mmorrow> :)
09:37:46 <gwern> oh. so we weren't discussing lisp
09:38:27 * mmorrow suddenly gets the quote gwern @remembered
09:38:41 <Baughn> No, this is haskell. My other value is a thunk.
09:39:04 <mmorrow> (or so you think)
09:39:07 <mmorrow> thanks!
09:39:25 <mmorrow> i dunno
09:39:43 <Baughn> I've got a thunk. I think.
09:39:50 <mmorrow> mmkthx
09:40:00 <gwern> Baughn: why don't you look and find out?
09:40:13 <Baughn> gwern: I don't want to collapse its quantum wave-function
09:40:19 <Baughn> If I look, it stops being a thunk
09:40:29 * mmorrow deletes his jokes about a cat and a box
09:40:37 <mmorrow> -s
09:41:08 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/schroedinger.png
09:43:17 <mmorrow> hehe
09:43:37 <mmorrow> the hair makes it
09:44:01 * Baughn notes that, yep, vacuum-cairo works fine on 6.10.2
09:44:13 <mmorrow> Baughn: nice :)
09:44:47 <Baughn> mmorrow: But it needs zooming and stuff. Hmm..
09:45:06 <Baughn> Oh, and I keep getting "syntax error near line 6"
09:45:10 <vixey> does anyone have a syntax for monadic programs which can include pre/post conditions?
09:45:12 <vixey> something like
09:45:12 <mmorrow> Baughn: someone needs to suck it up and write an opengl png viewer
09:45:19 <vixey> do {P} foo {Q}
09:45:28 <vixey>    a {P'} <- bar {Q}
09:45:44 <vixey> I don't know... is there something like that?
09:45:45 <mmorrow> Baughn: that's because it's using non-standard (but accepted) syntax for .dot
09:46:21 <vixey> I am trying to find a monadic syntax
09:46:27 <Baughn> mmorrow: So what version of dot do I need to use?
09:46:52 <Baughn> mmorrow: Oh, and I might write an opengl viewer. I've got some experience with that; it'd be fun. :P
09:46:54 <mmorrow> Baughn: i think it'll whine regardless the version, but it accepts it
09:47:01 <vixey> even just a way to annotate >>= would be good
09:47:03 <Baughn> It says "Error".
09:47:52 <mmorrow> Baughn: i have a quicky hacked one i wrote the other day to learn haskell's opengl interface
09:48:17 <Baughn> mmorrow: Anyway, this is /really/ nice. :D
09:48:22 <Baughn> Good work
09:48:35 <mmorrow> Baughn: thanks!
09:48:43 <Baughn> Now update the .cabal to accept 10.2
09:48:53 <mmorrow> Baughn: i did :)
09:49:10 <mmorrow> Baughn: where are you installing from?
09:49:11 <QuietPurple> hello, can I ask a quick question? I'm having a problem with Int and Integer.
09:49:50 <mmorrow> (the hackports/? prog seems to not be flag-aware, if that's what you're using)
09:50:01 <mmorrow> (or something like this)
09:50:12 <Baughn> mmorrow: cabal-install, but yesterday
09:50:14 <Baughn> Let's see..
09:50:26 <mmorrow> ah, i fixed it twice since
09:50:40 <Baughn> Yess.
09:50:53 * Baughn notes that enabling split-objs balloons ~/.cabal quite a bit
09:51:03 <Baughn> So.. nifty...
09:51:08 <mmorrow> weeee
09:51:13 <Baughn> I need time-lapse support, I think. hmm..
09:51:21 <mmorrow> get your opengl on
09:51:26 * Baughn dons his opengl hat
09:52:20 <QuietPurple> can anyone help, please---I'm sure it's a very simple mistake I am making!
09:52:33 <Baughn> Ooh. So /that's/ a finger-tree.
09:52:47 <vixey> QuietPurple: .. you didn't say what the problem was ...
09:52:54 <QuietPurple> I've got one function that takes Integer, say f::Integer -> Int
09:53:14 <QuietPurple> another one takes Ints, but uses the first function
09:53:28 <QuietPurple> say g n p = f (n ^ p)
09:53:33 <QuietPurple> something like that
09:53:38 <Saizan> QuietPurple: use fromIntegral
09:53:45 <QuietPurple> at the moment i'm using fromIntegral
09:54:02 <QuietPurple> so g n p = f (fromIntegral (n^p))
09:54:06 <Baughn> mmorrow: DOesn't show thunks, though. Is that just vacuum-cairo?
09:54:15 <QuietPurple> but it still doesn't seem to work
09:54:16 <niemeyer> Hey there
09:54:39 <boegel> hmm, when GHC is linking, I'm running into this: /usr/bin/ld: cannot find -lgmp
09:54:59 <Saizan> QuietPurple: it's better if you paste the code snippet and the type error on hpaste.org
09:55:09 <boegel> I see gmp libraries in /usr/lib, but no libgmp.so, so I made a symlink to libgmp.so.3.3.3.3 which is in my LD_LIBRARY_PATH
09:55:11 <QuietPurple> in ghci i can run f (97^7) say, no problem
09:55:16 <boegel> but still, no avail... anyone?
09:55:16 <niemeyer> I have a small tool which has some utf-8 in the source itself, and it's sending iso-8859-1 to the terminal rather than utf-8.  Would anyone have a hint or an url about this behavior?
09:55:28 <QuietPurple> but not g 97 7
09:55:55 <QuietPurple> i'll paste it if you want, but i think the complexity of the function will just be confusing
09:56:08 <Baughn> mmorrow: ..doesn't seem to be. "vacuum fibs" is trouble?
09:56:10 <QuietPurple> the problem is basically as i've shown with g and f
09:56:14 <QuietPurple> i think....
09:56:17 <mauke> QuietPurple: how about you simplify it first
09:56:30 <QuietPurple> simplify?
09:57:06 <Baughn> niemeyer: The current base output layer doesn't do utf-8. That's going to be fixed, but for the time being you'll want to use the utf8-string hackage package.
09:57:10 <QuietPurple> the error type is: f (97^7) and g 97 7 evaluate as different!
09:57:22 <mauke> QuietPurple: what
09:57:25 <Baughn> niemeyer: And System.IO.UTF8
09:57:43 <QuietPurple> but only when the value of p^n is too large for Int
09:57:48 <niemeyer> Baughn: Cool, I'll have a look at these, thanks.  I was just a bit surprised that there was any conversion going on at all.
09:58:09 <Baughn> niemeyer: It's not so much "conversion" as "chop off all but the lower eight bits"
09:58:39 <Baughn> niemeyer: That's iso8859-1 more or less by.. okay, it's not chance, it's by unicode's design
09:58:47 <Saizan> QuietPurple: well, if you can reproduce the same problem with just some dummy f and g you can paste that
09:59:07 <QuietPurple> I'll be back in a mo...
09:59:13 <Saizan> ah well
09:59:29 <Saizan> it's not really surprising that they evaluate differently if you mix Int in the middle
10:00:09 <mmorrow> Baughn: there's a `vacuumTo' function
10:00:12 <niemeyer> Baughn: Ahh, that's interesting
10:00:20 <niemeyer> Baughn: Let me see if that matches the chopping
10:00:25 <mmorrow> Baughn: that quits after a given number of nodes
10:00:57 <mmorrow> Baughn: (without forcing everything, you mysteriously segfault)
10:01:03 <mmorrow> Baughn: i'm not sure why yet
10:01:07 <Baughn> mmorrow: Okay. Why don't I need that for (fix (0:)), though?
10:01:21 <mmorrow> Baughn: because the graph for that is finite
10:01:30 <mmorrow> , vacuum (fix (0:))
10:01:33 <lunabot>  [(0,[1,0]),(1,[])]
10:01:45 <Baughn> mmorrow: ...reference equality?
10:01:50 <mmorrow> (lunabot's vacuum is really (toAdjList . vacuum))
10:01:52 <Baughn> _Pointer_ equality?
10:02:00 <mmorrow> realluUnsafePtrEquality# ftw!
10:02:04 <pumpkin> nice :)
10:02:05 <Baughn> Oh dear
10:02:15 <Baughn> OKay, got it. :P
10:02:24 <mmorrow> that's the only way you could do it though, really
10:02:29 <niemeyer> Baughn: Hmm.. there seems to be something else in addition to this
10:02:44 <pumpkin> mmorrow: you stopped showing boxes?
10:02:51 <mmorrow> pumpkin: boxes?
10:02:55 <niemeyer> Baughn: An example: "servi\xc3\xa7os" vs. "servi\xe7os"
10:02:59 <lilac> mmorrow: can't you just use StableName?
10:03:15 <pumpkin> mmorrow: in the earlier versions I remember your graphs had I# boxes in them a lot
10:03:19 <niemeyer> Baughn: The first is the raw content of the file.. the latter is what goes to the terminal
10:03:21 <pumpkin> but in dons' videos there are none
10:03:35 <mmorrow> pumpkin: ah, dons wrote vacuum-cairo
10:03:42 <pumpkin> yeah
10:03:47 <QuietPurple> ok I've pasted a simple example
10:03:51 <mmorrow> pumpkin: the those are still there in the vacuum-generated dot files
10:03:52 <pumpkin> so I guess he did more than just add a graphical layer on top of it?
10:03:57 <pumpkin> ah
10:04:26 <mauke> preflex: seen voker57__
10:04:27 <preflex>  voker57__ was last seen on #haskell 2 hours, 11 minutes and 31 seconds ago, saying: Crypto?
10:04:27 <mmorrow> lilac: probably not, because vacuum is testing equality of the actual closures as HValues
10:04:33 <QuietPurple> when I run g 97 6 i get a different answer to f (97^6)
10:04:39 <wli> I'd use something like IntMap (IntSet, IntSet) {- vertices -}, IntMap (Int, Int) {- edges -}
10:04:46 <lilac> QuietPurple: obviously; you're running fromIntegral /after/ the exponentiation
10:04:47 <pumpkin> QuietPurple: what are the answers?
10:04:58 <kadaver> this confuses me.the earths perimeter is 40000km,= 40,000,000 meters. 40000000=2*pi*r->r = 40,000,000 / (2*pi) = 6366197.7236758135 ~= 6.4million meters, that cant be correct?
10:05:00 <QuietPurple> oh, i see
10:05:25 <QuietPurple> so (romIntegral n)^(fromIntegral p)?
10:05:28 <lilac> @type (^)
10:05:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
10:05:48 <pumpkin> ksandstr: 6.4 million meters = 6400 km
10:05:55 <lilac> QuietPurple: yes. note that (^) returns the same type as its LHS, so it's returning an Int even if you do fromIntegral afterwards
10:06:04 <pumpkin> ksandstr: whoops, sorry, I meant kadaver
10:06:16 <QuietPurple> i understand now! many thanks
10:06:42 <QuietPurple> so i then just need n^(fromIntegral p) to get an Integer back?
10:07:19 <wli> kadaver: Well, I'd start with ellipsoidality and call it a semimajor axis, assuming it's equatorial perimeter/circumference.
10:08:54 <niemeyer> So System.IO.UTF indeed solves the problem.. I'm still curious about the automatic conversion to iso-8859-1, though
10:09:34 <mauke> <Baughn> niemeyer: It's not so much "conversion" as "chop off all but the lower eight bits"
10:09:55 <wli> kadaver: The numbers are okay. cf. http://en.wikpedia.org/wiki/Earth
10:09:56 <niemeyer> mauke:
10:09:56 <niemeyer> <niemeyer> Baughn: An example: "servi\xc3\xa7os" vs. "servi\xe7os"
10:10:03 <niemeyer> <niemeyer> Baughn: The first is the raw content of the file.. the latter is what goes to the terminal
10:10:12 <pumpkin> niemeyer: have you looked at Data.Text?
10:10:25 <mauke> niemeyer: sounds like your compiler understands utf-8
10:10:34 <niemeyer> pumpkin: I haven't..
10:10:37 * niemeyer checks
10:10:37 <wli> kadaver: I guess geodeters use the term "equatorial radius."
10:11:04 <mauke> because C3 A7 is the UTF-8 representation of c with cedilla
10:11:04 <niemeyer> mauke: It's GHC 6.8.2
10:11:20 <mauke> so everything's ok
10:11:42 <niemeyer> mauke: Well, this is the raw content that my editor has put into the source file
10:11:49 <mauke> I know
10:11:54 <mauke> what do you want?
10:12:10 <niemeyer> mauke: I'm surprised that it's converting to "\xe7", which is *also* correct, but for iso-8859-1.. and it's not just chopping to convert between the two
10:12:33 <mauke> ghc decodes UTF-8 to get the proper internal unicode representation
10:12:53 <mauke> the IO libraries are broken in that they simply truncate every codepoint to 8 bits on output
10:13:03 <mauke> which is effectively ISO 8859-1
10:13:54 <niemeyer> mauke: Ahhh, ok, so it's not chopping the UTF-8.. there's conversion going on indeed.  That's interesting.
10:14:30 <mauke> conversion happens in the compiler when reading source
10:15:39 <niemeyer> mauke: Makes perfect sense.. so it already expects utf-8, and since the unicode code point for cedilla is 00E7, it's just chopping indeed..
10:15:41 <niemeyer> mauke: Thanks
10:15:57 <mauke> you're welcome
10:16:15 <lilac> QuietPurple: you need fromIntegral n ^ p
10:16:44 <mauke> wÌ§È©lÌ§Ã§oÌ§mÌ§È©
10:17:08 <QuietPurple> yes, that works.
10:18:02 <QuietPurple> lilac, mauke, Saizan: thanks guys
10:19:42 <mmorrow> lilac: (re: StableName: also, that wouldn't work because "vacuum 888888333333377777744444" is J# -> {Int#, ByteArray#}, not just a single node)
10:20:14 <mmorrow> and vacuum (foo::IntMap) is a massive graph
10:21:11 <lilac> i guess the real problem (tm) is that it doesn't work on unboxed values
10:21:38 <lilac> (since i think it's forall a :: *. a -> IO (StableName a)
10:21:41 <mmorrow> that too
10:22:56 <mmorrow> hmm, actually that's not a problem, because reallyUnsafePtrEquality# only works on boxed values as well
10:23:50 <mmorrow> so i suppose "the real problem" is that StableName doesn't give 100% guarantee, there's the possibility of false negatives
10:24:11 <lilac> it's not like you're dependent on GHC internals already or anything ;-)
10:24:41 <mmorrow> yeah exactly. even if StableName were possible, it'd just add unneeded complexity
10:25:30 <mmorrow> (.==.) :: HValue -> HValue -> Bool
10:25:31 <mmorrow> a .==. b = a `seq` b `seq` (0 /= I# (reallyUnsafePtrEquality# a b))
10:25:36 <mmorrow> is what it's using
10:26:33 <mmorrow> the unforunate thing though is that you have to do linear search through a list for "seen" HValues, since you can't get at the actual pointers (and they may move) to put them in an IntMap or something
10:27:05 <mmorrow> so possibly there something like StableName could be a win
10:27:13 <boegel> aargh
10:27:22 <boegel> why is GHC unable to find libgmp??
10:27:23 <mmorrow> the possibility of false-negatives though makes me hesitant
10:27:37 <dbbddbdb> Hi!  Is there a list splitting function like D.L.S.oneOf or D.L.S.sepBy, only (Eq a) â [[a]] â [a] â [[a]]?
10:27:49 <dbbddbdb> I want to split a string with mixed DOS and UNIX newlines
10:31:37 <lilac> "A delimiter can either be a predicate on elements, or a list of
10:31:39 <lilac> --   elements to be matched as a subsequence."
10:31:46 <lilac> dbbddbdb: i guess that's a "no".
10:35:04 <lilac> @type foldM (flip ?splitOn) "foo,bar?!baz" [",","?!"]
10:35:05 <lambdabot> forall (m :: * -> *). (Monad m, ?splitOn::[Char] -> [Char] -> m [Char]) => m [Char]
10:35:09 <jedai> dbbddbdb: investigate Data.Split from Hackage (or Date.List.Split, I don't remember exactly), I do believe it has what you want (if the type you ask for is really correct)
10:35:15 <lilac> something like that could work
10:38:11 <jedai> dbbddbdb: Yes, Data.List.Split from the split package should have everything you need
10:38:25 <lilac> jedai: it doesn't
10:39:06 <jedai> lilac: Really ? I don't see why ?
10:39:11 <lilac> jedai: according to the source, it supports a single list delimiter or an element predicate, but not a delimiter of multiple lists
10:39:48 <jedai> lilac: That's easily corrected by subdividing the results from the first split, no ?
10:40:01 <lilac> jedai: that's what my foldM solution does
10:40:10 <lilac> but this is hardly Data.List.Split doing everything you need
10:40:43 <jedai> Ok :) But the "hard" (or rather tedious) part is still in Data.List.Split
10:41:29 <jedai> lilac: besides for his specific needs (split on DOS or UNIX newlines) he can use Data.List.Split directly
10:41:29 <kadaver> what is the function : f :: Int -> [a] -> [[a]] ?
10:41:37 <kadaver> split at interval
10:42:06 <lilac> jedai: you thinking of something like 'split on \n, then remove trailing \rs?
10:42:06 <kerlo> Hmm.
10:42:19 <MyCatVerbs> > let { lsplits "" = []; lsplits ('\r':'\n':more) = [] : lsplits more; lsplits ('\n':'\r':more) = [] : lsplits more; lsplits ('\n':more) = [] : lsplits more; lsplits (c:more) = let (as:amore) = lsplits more in ((c:as):more) } in lsplits "foo\nbar\r\nbuz\nquux\n\rfaz"
10:42:21 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
10:42:37 <MyCatVerbs> > let { lsplits "" = []; lsplits ('\r':'\n':more) = [] : lsplits more; lsplits ('\n':'\r':more) = [] : lsplits more; lsplits ('\n':more) = [] : lsplits more; lsplits (c:more) = let (as:amore) = lsplits more in ((c:as):more) } in lsplits "foo\nbar\r\nbuz\nquux\n\rfaz"
10:42:38 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
10:42:41 <MyCatVerbs> Gah, sorry.
10:42:57 <MyCatVerbs> Forgot how to set margins in screen, hit the wrong key by mistake.
10:43:45 <kerlo> kadaver: write one, I guess.
10:43:47 <kadaver> there is such a function im sure
10:44:24 <kerlo> @hoogle Int -> [a] -> [[a]]
10:44:26 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
10:44:26 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:44:26 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:44:38 <kadaver> uh did you know there is permutations in Data.List, si that new?
10:44:40 <lilac> kadaver: Data.List.Split.splitEvery?
10:44:45 <kadaver> also subsequences
10:45:03 <kerlo> @type Data.List.Split.splitEvery
10:45:05 <lambdabot> Couldn't find qualified module.
10:45:23 <lilac> splitEvery :: Int -> [e] -> [[e]]
10:45:41 <kerlo> @index splitEvery
10:45:41 <lambdabot> bzzt
10:45:53 <lilac> Data.List.Split
10:46:15 <MyCatVerbs> > let { lsplits "" = []; lsplits ('\r':'\n':more) = [] : lsplits more; lsplits ('\n':'\r':more) = [] : lsplits more; lsplits ('\n':more) = [] : lsplits more; lsplits (c:more) = case lsplits more of { (as:amore) -> ((c:as):amore); [] -> [[c]]; } } in lsplits "foo\nbar\r\nbuz\nquux\n\rfaz"
10:46:17 <lambdabot>   ["foo","bar","buz","quux","faz"]
10:46:20 <lilac> in the package 'split' on hackage
10:46:37 <MyCatVerbs> When in doubt, make like a badger and recurse.
10:46:57 <dbbddbdb> lilac: jedai: thanks!  That works perfectly.
10:47:58 <dbbddbdb> Somehow I forgot about foldM.  Also, separators can be extracted by using foldrM from Foldable.
10:53:07 <|jedai|> Did dbbddbdb find his solution ? My connexion went away rather abruptly.
10:53:40 <MyCatVerbs> "18:46:57 < dbbddbdb> lilac: jedai: thanks!  That works perfectly." "18:47:58 < dbbddbdb> Somehow I forgot about foldM.  Also, separators can be extracted by using foldrM from Foldable."
10:54:50 <|jedai|> Thanks :)
10:57:10 <performance> @seen dcoutts
10:57:10 <lambdabot> I saw dcoutts leaving #happs, #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs 1d 11h 14m 35s ago, and .
10:58:55 <performance> cabal install --prefix=c:\ths  happstack  seems to ignore the --prefix  and tries to install on Program Files on Vista
11:01:26 <Gracenotes> whoa.. 10^10 atoms is required to store one bit of information?
11:02:09 <performance> on Vista s/atoms/Bytes :D
11:02:21 <Gracenotes> o:
11:03:29 <mmorrow> Gracenotes: um
11:03:56 <Gracenotes> mmorrow: well, from http://alumni.imsa.edu/~matth/quant/299/paper/node10.html
11:04:10 <Gracenotes> I'd assume some hardware implementations are more efficient though
11:04:26 <mmorrow> oh, yeah with silicon
11:04:53 <mmorrow> "The smallest conceivable storage for a bit involves a single elementary particle of some sort."
11:05:35 <mmorrow> so we're currently like 10^10
11:05:43 <mmorrow> ^10 times less efficient than we could be
11:05:45 <mmorrow> :)
11:05:57 <Gracenotes> heh.
11:06:31 <wli> Maybe we're not as close to the physical limits as I thought? Or maybe the physical limits are more restrictive than that...
11:07:00 <mmorrow> i think we're close to the physical limits given the current materials we're using
11:07:12 <chessguy> mmorrow:  i don't think we can be that efficient though, right? i mean, because of the Heisenberg uncertainty principle?
11:07:25 <mmorrow> chessguy: i don't know
11:07:30 <chessguy> we don't want to change our storage by looking at it :)
11:07:56 <BMeph> How much would it be for trits? (I'm on a ternary rep kick...)
11:08:03 <Gracenotes> well, with the uncertainty principle we can make computers even more powerful. Although if it coheres unexpectedly, it seems, it won't be too useful :\
11:09:16 <chessguy> well you're over my head now
11:09:19 * BMeph puts in his order for a pion-based quantum computer...
11:09:25 <mmorrow> i seem to recall reading about certain quantum crypto schemes with photons as bits where it's impossible to eavesdrop without giving away that you are
11:09:47 <mmorrow> (and they were/are actually implemented to some limited degree or something)
11:10:35 <Gracenotes> quantum cryptography, says Bruce Schneier, is excellent in theory but will probably be lacking in practice
11:10:39 <mmorrow> with LAZERS!!
11:10:58 <Gracenotes> http://www.wired.com/politics/security/commentary/securitymatters/2008/10/securitymatters_1016
11:11:02 <mmorrow> Gracenotes: he's just trying to protect his job :)
11:11:03 <BMeph> mmorrow: Forgot your air quotes. :)
11:11:05 <chessguy> what's it gonna take to get some sharks with frickin' LAZERS n their heads??
11:11:08 * mmorrow ducks
11:11:16 <p_l> mmorrow: It's about certain transmission modes using laser light, used for key generation
11:11:17 <mmorrow> BMeph: crap
11:11:21 <Gracenotes> mmorrow: well. I wouldn't entirely doubt that.
11:11:45 <Gracenotes> oh, heh. "It's not that quantum cryptography might be insecure; it's that cryptography is already sufficiently secure."
11:11:53 <Gracenotes> I see what you mean.
11:12:03 <p_l> mmorrow: You generate & transmit keys using it and then use normal symmetric crypto with those keys
11:12:32 <mmorrow> p_l: interesting
11:13:15 <p_l> mmorrow: since symmetric crypto depends only on the keys, having secure handshaking removes the problem faced  by assymetric crypto
11:13:27 <gwern> I hate quantum computers, personally. they give us search - which we can do fine - and integer factorization, which is a hideous net negative
11:13:36 <gwern> I don't understand why people get the warm fuzzies about them
11:13:54 <kadaver> is there some function that can wordify a string? I mean a words as in just letters, and perhaps apostrof. so I have my own beautify that strips off characters but i dont know all non characters
11:14:03 <Gracenotes> gwern: never fear, I'm writing a simulation of quantum integer factorization, and it's taking *forever*!
11:14:11 <pumpkin> that's why we need to use lamport signatures just in case
11:14:16 <gwern> Gracenotes: you just need better hardware
11:14:35 <gwern> kadaver: examples?
11:14:37 <performance> gracenotes, well, whats the use of your expertise if it can be disturbed in unknown ways every time some one needs to know some thing from you :D
11:14:42 <p_l> gwern: because depending on the "size" of quantum processor we can have O(1) search?
11:15:17 <gwern> p_l: uh huh. and do we need constant-time searches so badly we're willing to trash half our security infrastructure for't?
11:15:39 <inimino> irrelevant
11:15:39 <pumpkin> if we don't, the terrists will!
11:15:50 <Gracenotes> pumpkin++
11:15:59 <pumpkin> disregarding new technology because it proves some of our assumptions wrong doesn't seem like a good line of reasoning though
11:16:00 <kadaver> gwern: "hello," -> "hello"; "hello!" -> "hello";
11:16:02 <gwern> the terrorists can't build a dirty bomb, I don't think we need to worry about them building a quantum computer :)
11:16:16 <performance> vista is so retarded, it doesnt allow me to change the permissions on one folder, and then if i change the permissions for C drive, it is applying those to each file one at a time!!
11:16:21 <gwern> kadaver: ah
11:16:39 <kadaver> performance: yeah I recognize that
11:16:58 <p_l> gwern: security is always a tradeoff. assymetric crypto depending on current CPU deficiencies (slow division) is bad idea
11:17:03 <Gracenotes> gwern: still, though, if it's gonna happen, we should at least be prepared. Chinese seem like a greater threat than them terrists in what regard, but who knows. Who knows if NSA, even, has made any progress (sorta doubt the latter though)
11:17:03 <gwern> pumpkin: eh? many of our crypto schemes are based on integer factorization being hard. why should we go out of our way specifically to develop technologies which break that assumption?
11:17:17 <pumpkin> because the assumption is obviously flawed :P
11:17:29 <inimino> gwern: are you seriously suggesting that cryptographic protocols can be protected by a gentleman's agreement to just not build the technology that defeats them?
11:17:32 <pumpkin> if we build a skyscraper on toothpicks
11:17:39 <p_l> gwern: also, for really important data we don't use assymeetric crypto
11:17:51 * boegel slaps his head for unpacking a 32-bit GHC on a 64-bit system and wondering why he's running into problems
11:18:11 <gwern> I view 'let's go develop quantum computers!' as akin to saying 'well, our social contract depends on people being nice to each other and not being dicks. that's why we should go research pharmaceuticals that turn people into sociopaths'
11:18:27 <pumpkin> o.O
11:18:50 <gwern> 'because there's this one tiny subset of tasks where sociopaths would be awfully useful, y'know'
11:18:58 <Gracenotes> there already are people who already ignore social contracts
11:19:20 <p_l> gwern: quantum computing also allows us to get much higher FLOPs, especially due to fast division. And we have a lot of stuff that would very much like faster computers
11:19:21 <Gracenotes> whoa, redundancy :\
11:19:43 <pumpkin> gwern: I don't think new technology should be hindered by flawed assumptions of the past
11:19:47 <pumpkin> go lamport signatures ;)
11:20:13 <BMeph> gwern: Thank you for summing up the US educational system, that was brilliant! ;)
11:20:33 <gwern> 'we can build hydrogen bombs that could crack the earth's crust; why should we be hindred by flawed assumptions of the past that we couldn't scale to that point?'
11:20:48 <p_l> gwern: what you should be really scared of is nanofactories. Quantum computing, phi!
11:20:51 <gwern> BMeph: yeah, the industrial system of teaching is kind of outdated. for bright students anyway
11:21:20 * inimino sighs
11:21:21 <kadaver> but are quantum computer generating probable results? and one problem is deciding probable enough? like: 5 * 6 = Probably 30; and well be all like: fromQuantum Probably v = v
11:21:23 <kadaver> ?
11:21:30 <gwern> p_l: well, the difference is that quantum computing is, AFAIC, entirely based in academia. if the government choked off funding, that could set it back decades
11:21:52 <inimino> gwern: which government is that?
11:21:55 <gwern> which is not true of nanotech, which would go on in commercial settings
11:21:55 <Gracenotes> kadaver: quantum computing will be able to handle NP problems well.
11:22:03 <p_l> gwern: there is more than one government
11:22:05 <mmorrow> nanoFactoryFactory.replicateAndLayWaste()
11:22:12 <gwern> US. at least, I haven't seen any significant QC results from non-us places
11:22:16 <Gracenotes> kadaver: so if you get a result with high probability, you can check it easily
11:22:18 <Gracenotes> see Grover's algorithm
11:22:21 <gwern> although I'll admit I don't obssessively follow the field
11:22:34 <Gracenotes> and more specific ones, of course, like Shor's
11:22:43 <kadaver> inimino: then one hiding on Mars
11:22:43 <BMeph> gwern: Silly rabbit, schooling has *never* been about information transfer, but about (anti-)social adjustment. By those standards, it's working just fine.
11:22:54 <gwern> Gracenotes: eh? I could've sworn I read scott aaronson vituperating quite a bit against the belief that QC handled NP problems in P time
11:22:57 <BMeph> Bah, I'll save it for -blah. :)
11:23:06 <p_l> gwern: the moment US chokes funding, you'll find everyone else getting on it figuring it will give them edge
11:23:33 <BMeph> Anyway, I'd better go feed my wife before she starts pouring BBQ sauce on ME! ;)
11:23:37 <pumpkin> !
11:23:47 <p_l> priority interrupt, eh?
11:23:49 <gwern> p_l: that didn't significanlty happen even with something as obviously useful and near-term as stem cell therapy. why would it happen with an esoteric tech of dubious feasibility & utility like QC?
11:23:51 <Gracenotes> gwern: well, whereas it previously takes exponential, it reduces the exponent by 1/2. Which is enough in some cases I think
11:24:20 <inimino> gwern: you're the one arguing that it breaks crypto
11:24:28 <p_l> gwern: cause QC doesn't have this "playing with Nature" part that makes certain people mad
11:25:21 <Gracenotes> perhaps, let's outlaw quantum computers, so only outlaws will have quantum computers. problem fixed, me supposes.
11:25:35 <pumpkin> lol
11:25:37 * mmorrow puts in a pre-order
11:25:46 <pumpkin> it only breaks certain kinds of crypto
11:25:56 <bavardage> like public key...
11:26:01 <pumpkin> of course, they're the foundation of online shopping
11:26:02 <pumpkin> :P
11:26:03 <p_l> the ones that are assumed insecure nowadays :D
11:26:09 <bavardage> so back to one time pads via carrier pidgeon
11:26:14 <pumpkin> lol
11:26:33 <tomh> is it possible to test monads (like state computations) with quickcheck?
11:26:41 <mmorrow> obviously given the new capabilities, new crypto schemes would need to be developed
11:26:41 <Gracenotes> mmorrow: would you like a binary operation with that?
11:26:44 <p_l> bavardage: we can do one time pads over wireless easily... you think how RoE codes get transmitted
11:26:48 <pumpkin> tomh: sure, although IO is harder
11:26:49 <mmorrow> Gracenotes: yespls
11:26:49 <Gracenotes> and, uh, fries?
11:26:55 <mmorrow> curly
11:26:57 <pumpkin> mmm
11:26:59 <bavardage> p_l: yeah but then how do you encrypt the wireless
11:27:02 <pumpkin> I want curly fries now, dammit
11:27:02 <tomh> pumpkin: how would a property look like?
11:27:09 <bavardage> p_l: via another one-time pad perchance?
11:27:19 <gwern> but - but
11:27:20 <pumpkin> tomh: which monad are you talking about?
11:27:24 <tomh> i tried some thing like (\x->do return True) but not really working
11:27:28 <gwern> wouldn't you transfer as much as you used up?
11:27:33 <tomh> just in general
11:27:34 <p_l> bavardage: pre-shared onetime pad key. RoE data is too important for key handshake over air :D
11:27:35 <gwern> what would be the point?
11:27:40 <pumpkin> tomh: "not working" how?
11:27:53 <tomh> it throws an no instance of Testable (m Bool)
11:27:56 <pumpkin> oh, yeah
11:28:02 <pumpkin> you need to reduce it to a boolean somehow :P
11:28:03 <Gracenotes> specify the m
11:28:15 <pumpkin> what does it mean for [Bool] to pass a test?
11:28:18 <pumpkin> all? any?
11:28:23 <pumpkin> the third one from the last?
11:28:32 <Gracenotes> a generic monad doesn't have a Testable instance
11:28:32 <p_l> (by RoE I mean Rules of Engagement, aka nuke launch codes)
11:28:40 <bavardage> hah
11:28:40 <tomh> so i have to make a Bool from an m Bool?
11:28:42 <gwern> onetime data is incompressible, so you need to transfer each bit as a bit; to one-time-encrypt a single bit uses up one bit of the onetime pad; so if you have a shared onetime pad of 1 meg and you transfer 1 meg of a new onetime pad, you're right back where you started...
11:28:49 <Gracenotes> tomh: any testable Bool
11:28:54 <bavardage> gwern: unless you do the naughty
11:28:56 <pumpkin> tomh: yeah, you presumably have some notion of correctness?
11:29:03 <bavardage> and use 1mb of one-time-pad for 2mb of data
11:29:04 <Gracenotes> [Bool], Maybe, etc.
11:29:08 <tomh> yeah
11:29:11 <tomh> ok
11:29:14 <p_l> bavardage: which makes it easy to decrypt
11:29:15 <EvilTerran> bavardage, but then it's a two-time pad
11:29:20 <bavardage> which would still be a better situation than using public-key when there are quantum computers about
11:29:23 <tomh> i will try with a more concrete example thanks
11:29:25 <gwern> EvilTerran: how immoral
11:29:27 <bavardage> p_l: well no, not *easy*
11:29:28 <bavardage> just easier
11:29:41 <p_l> usually you send very short things like _keys_ with one time pad
11:29:59 <pumpkin> :o
11:30:02 <bavardage> I guess you could transmit a 'public key' via one-time pad
11:30:09 <p_l> symmetric crypto at its bets :)
11:30:13 <p_l> *best
11:30:28 <bavardage> OR
11:30:30 <pumpkin> you mean by picking a random symmetric key, encrypting that with public key, and sending obth?
11:30:32 <bavardage> *has the best solution*
11:30:33 <Gracenotes> XOR!
11:30:38 <bavardage> you do the whole actual physical boxes with padlocks
11:30:40 <pumpkin> that's not exactly OTP
11:30:45 <bavardage> on really fast aeroplanes
11:30:52 <monochrom> Under the secrecy of one-time pad you can exchange private keys just fine.
11:30:57 <bavardage> yeah
11:31:01 <Gracenotes> bavardage: with sharks with lasers?
11:31:04 <pumpkin> well yeah, but then you need to get the pads across too
11:31:05 <performance> pigeons
11:31:12 <p_l> bavardage: that's how one time pads are distributed
11:31:15 <bavardage> Gracenotes: ofc... you don't want these aeroplanes to be intercepted
11:31:24 <gwern> the wp article on lamport says you could also transmit a seed for a PRNG, and then xor against the output
11:31:46 <mmorrow> pumpkin: just put them on a usb stick and stick that on the nuclear sub before it leaves
11:31:50 <pumpkin> lol
11:31:50 <bavardage> also, couldn't you just use quantum encryption?
11:32:22 <pumpkin> http://lambda-the-ultimate.org/node/3259 o.O
11:32:30 <tomh> :t execState
11:32:32 <lambdabot> forall s a. State s a -> s -> s
11:32:36 <gwern> bavardage: well sure. if you had the special setup and can reach your peer
11:32:42 <tomh> :t evalState
11:32:43 <lambdabot> forall s a. State s a -> s -> a
11:32:44 <pumpkin> april 2nd :o
11:32:45 <pumpkin> :P
11:32:50 <bavardage> gwern: yeah would be a pain
11:32:57 <bavardage> they can do it what, over a whole 3km so far?
11:33:10 <monochrom> Someone can come up with a type system modelling the properties of public-key cryptography, private-key cryptography, one-time pad... Then compose some functions (to model a particular protocol) and type-check them, and the types show properties of the composition.
11:33:28 <Gracenotes> pumpkin: heh. with the subset sum problem
11:33:44 <pumpkin> I'm guessing it was a late post from april 1st
11:34:10 <kadaver> is rotating a bit == flipping it, ie 1 -> 0, 0 -> 1?
11:34:13 <Gracenotes> 'yesterday' 2 days ago
11:34:33 <Gracenotes> kadaver: well, it's the only thing you can do with a single bit, other than leave it the same >_>
11:34:37 <Gracenotes> however, you can rotate a bitstring
11:34:38 <pumpkin> from the paper: "second, print out these two plots. Third, using scissors, for each [...]"
11:34:39 <monochrom> You can "just" use quantum cryptography. You can "just" assume you can buy the equipment cheaply. Last I heard it's $10,000.
11:34:42 <Gracenotes> which is different
11:34:44 <pumpkin> I'm guessing it's not serious
11:34:46 <pumpkin> :P
11:35:00 <monochrom> I last heard just one week ago.
11:35:44 <Gracenotes> tomh: by the way, if a do block only has one statement, you can omit the 'do' entirely
11:36:04 <Gracenotes> well, in that case the 'statement' would be an expression
11:36:17 <tomh> ah yeah, i forget that sometimes :)
11:41:33 * EvilTerran is rooting for a non-constructive proof that P = NP
11:41:57 <eric_> hello
11:42:36 <inimino> EvilTerran: because it would shake up CS? ;)
11:43:10 <EvilTerran> because it'd amuse me
11:43:38 <EvilTerran> "we've proven you can solve NP-hard problems in Ptime!" "really? how?" "er... well, the proof doesn't say..."
11:43:45 <p_l> lol
11:43:58 <p_l> I love "N=1 thus NP = P" :)
11:44:30 <p_l> (found in Concrete Math)
11:44:45 <mauke> NP = P for P=0
11:45:46 <kadaver> so haskell will be useless for quantum computers then? we might as well just pack up and leave?
11:46:38 <pumpkin> @hackage quantum-arrow
11:46:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/quantum-arrow
11:47:21 <Gracenotes> oh, hm.
11:47:28 <Gracenotes> that's just simulation though
11:47:31 <pumpkin> yup
11:47:35 <monochrom> Every language has a reversible subset.
11:47:38 <pumpkin> but maybe it could be hooked up to the real thing :P
11:47:43 <pumpkin> when the time came
11:47:57 <Gracenotes> we shall be... prepared.
11:48:25 <monochrom> In quantum computing, at the last stage you make an observation and it is irreversible. You can use Haskell's IO monad for that part.
11:48:59 <Gracenotes> pumpkin: still, it doesn't have things like quantum fourier transform, some gates, etc.
11:49:09 <mauke> http://search.cpan.org/~lembark/Quantum-Superpositions-2.02/lib/Quantum/Superpositions.pm
11:49:11 <Baughn> Gracenotes: Yet. :P
11:49:27 <Baughn> If we had actual quantum (or paraquantum) computers, you bet it'd get completed in a hurry
11:49:45 <Baughn> p_l: Oh yes, have you had a look at vacuum?
11:50:54 <p_l> Baughn: vacuum?
11:51:18 <Baughn> p_l: vacuum, vacuum-cairo. Cabal-install, now. :D
11:51:29 <p_l> lol
11:51:30 <Baughn> It's amazing.. and amazingly useful
11:51:43 <ddarius> "useful" ?
11:51:59 <Baughn> For visualizing data structures, of course
11:52:28 <pumpkin> I think that until cabal/hackage comes up with a good way of representing it, package descriptions should include changelogs :P
11:52:39 <p_l> brb
11:52:56 <pumpkin> it's frustrating to see new versions of packages you're interested and to not know what changed (not all package uploads are accompanies by announcements on cafe)
11:53:21 <ddarius> darcs changes
11:53:45 <monochrom> People say you should access their darcs repository and ask for the diff and read it yourself.
11:54:02 <sm> hackage should include darcsweb(|-a-like) !
11:54:02 <monochrom> In fact the hard core people say you should always darcs get, not even cabal-install.
11:54:22 <ddarius> monochrom: Just do a binary diff on the final executables/object files.
11:54:44 <pumpkin> okay, I'll do the  binary diff
11:54:46 <p_l> Baughn: interesting :)
11:54:51 <pumpkin> ;)
11:54:53 <monochrom> It is the same as TRWBW in #math saying you should always trace everything back to the ZFC axioms.
11:54:56 <pumpkin> I wonder how bindiff handles haskell code
11:55:07 <sm> what's happening the uber-hackage that dcoutts & co were working on ?
11:55:14 <sm> tsk, slackers
11:55:19 <Gracenotes> monochrom: for.. all proofs?
11:55:36 <monochrom> Something like that, yeah. I'm exaggerating a bit.
11:55:38 <ddarius> monochrom: What if I don't accept ZFC?
11:55:58 <monochrom> If you don't accept ZFC, he tells you "I don't care".
11:56:47 <Baughn> "Accept"? I thought ZFC were a set of axioms?
11:56:47 <monochrom> In fact I once told him I prefer the lambda calculus and he didn't care either.
11:57:13 <Gracenotes> how do you encode numbers in ZFC?
11:57:14 <ddarius> Baughn: Which means you either accept them or not.
11:57:51 <Baughn> ddarius: No, which means you neither accept them nor not, but develop math for both cases and pick whichever has axioms that fits the reality you're trying to model at the time
11:58:16 <monochrom> In fact I exaggerated TRWBW above in one aspect and understated in another aspect. Here is the exact thing. He insists that all proofs are string processing using a suitable Turing machine.
11:58:29 <ddarius> Baughn: There are tons of alternative sets of axioms, why should we bothe exploring all of them?
11:58:54 <Baughn> ddarius: We shouldn't. The reason we explore /any/ of them is that math is useful, so let's explore only the useful ones that have axioms that correspond well to reality.
11:59:14 <ddarius> Baughn: So why then should I explore ZFC?
11:59:25 <Baughn> ddarius: Beats me. Possibly it's useful?
11:59:27 <Baughn> If it isn't...
11:59:31 <Gracenotes> monochrom: you mean a suitable unstricted grammar, of course? >_>
11:59:57 <monochrom> His exact wording is Turing machine.
11:59:57 <inimino> monochrom: that's a somewhat popular position
12:00:17 <Gracenotes> surely he means enumerator.
12:00:26 <Baughn> inimino: It helps that any proof we can test for correctness in this universe (apparently) necessarily has to be turing-compatible
12:00:30 <Gracenotes> er, lambda calculus, I mean
12:00:48 <pumpkin> dons: have you considered putting the stream fusion guts into a common package so that uvector, Data.Text, (and maybe ByteString) could all use the same internals? or are there subtle variations between the various packages?
12:00:57 <monochrom> Just last night he said to me "you stick to your lambda calculus, I stick to my Turing machine".
12:01:21 <Gracenotes> cool story
12:01:36 <monochrom> He said this because I first said "no, please don't use strings, please use parse trees".
12:01:50 * inimino pictures the armies of Turing and Lambda arrayed on the field agaisnt each other
12:02:06 <b_jonas> by Lambda do you mean Church?
12:02:08 <ddarius> Then realizes it's just one army looking at a mirror.
12:02:25 <dons> pumpkin: yeah, i've considered it
12:02:26 <monochrom> It's the Church's army vs the State's army. XD
12:02:33 <Gracenotes> inimino: and then the peace treaty is presented. You can probably guess what it's called ;)
12:02:44 <inimino> Gracenotes: haha
12:03:38 <monochrom> Anyway, "octopi has 3.14159... legs" was very funny. :)
12:04:04 <pumpkin> dons: any technical issues with doing that, or is it just that you have another million things you need to do?
12:04:23 <Beelsebob> monochrom: :)
12:04:23 <Gracenotes> arms! :(
12:05:12 <Petrosian> Evening.
12:05:16 <bavardage> monochrom: "octopi has 3.14159 legs"?
12:05:18 <bavardage> what's that
12:05:19 <Petrosian> What's the big-O of `mod'?
12:05:23 <monochrom> octo-pi
12:05:34 <mauke> 8Ï
12:05:44 <Baughn> 0xg
12:05:46 <dmhouse> > pi `mod` 8
12:05:48 <lambdabot>   Add a type signature
12:05:51 <mauke> > 8*pi
12:05:52 <lambdabot>   25.132741228718345
12:06:03 <Spark> > 8*Ï
12:06:04 <lambdabot>   Not in scope: `Ï'
12:06:06 <Cale> Baughn: I disagree that a relationship with reality has anything to do with the usefulness of mathematical axioms like ZFC. The usefulness of mathematics, I think, comes from the fact that it has structures which correspond to ways which we percieve things and break them down into parts.
12:06:10 <Gracenotes> dmhouse: if you can find something that's both integral and realfloat
12:06:15 <Gracenotes> *floating*
12:06:20 <Spark> > let Ï=pi in 8*Ï
12:06:22 <lambdabot>   25.132741228718345
12:06:25 <kadaver> TRBW :: IO PissingContest
12:06:38 <Cale> I mean, I don't think that physical observations are going to help us pick a set of axioms.
12:06:54 <vixey> Cale: what about geometry
12:06:56 <dons> pumpkin: there's some tension between how streams are represented in the strict and lazy case, and whether size hints should be used
12:06:59 <Baughn> Cale: "Ways in which we perceive things" are also part of reality, because we are.
12:07:01 <dons> that's about it.
12:07:09 <Cale> Baughn: Right, I mean, beyond that.
12:07:19 <Spark> what we know about physics has changed drastically as we have developed better technology for examining things
12:07:28 <Cale> Of course, mathematics itself is just something which we've put together.
12:07:39 <Baughn> Spark: Sure, and then we've often had to spend some time building new math that fits better
12:07:42 <Spark> axioms that model reality will thus change over time
12:07:48 <Cale> The reason why ZFC is worth exploring is that so many people use it that it is a worthwhile common language.
12:07:48 <Baughn> Right
12:08:00 <Cale> We can get farther if we all play the same game.
12:08:04 <bavardage> I read some thing where some researchers encoded axioms in quantum states
12:08:05 <Baughn> Cale: Sounds to me like it describes part of our minds, then
12:08:08 <Baughn> Cale: Which are parts of reality
12:08:11 <bavardage> and then could use that to check if the axioms were true..
12:08:13 <Cale> Maybe.
12:08:21 <Spark> in as far as anything that can be imagined is real
12:08:27 <Spark> because it was imagined by someone who was real
12:08:30 <Baughn> bavardage: Well, true in quantum physics at least
12:08:43 <Baughn> Or rather, "describes quantum physics well". Axioms don't /have/ truth value
12:08:46 <Cale> Spark: yeah! :)
12:09:02 <pumpkin> ah
12:09:04 <Baughn> Spark: Nah
12:09:07 <bavardage> Baughn: well I think it wasn't true, but something like if they were actually axioms
12:09:13 <bavardage> or whether some could be derived from others
12:09:14 <bavardage> dunno
12:09:15 <Baughn> Spark: The imagination is real. What's being imagined need not be.
12:09:22 <bavardage> I don't understand quantum physics so didn't read it
12:09:23 <Cale> In fact, I think as far as physics is concerned, it's quite possible that ZFC is less than ideal.
12:09:39 <Cale> But it's a lovely system nonetheless, and is well-studied.
12:09:50 <Baughn> bavardage: http://www.overcomingbias.com/2008/06/the-quantum-phy.html <-- Here, fix that
12:10:18 <bavardage> Baughn: how much maths does that require :P?
12:10:25 <Baughn> bavardage: None
12:10:31 <bavardage> oh hmm
12:10:44 <Cale> Mathematics probably shouldn't be judged as "real" in any sense beyond the imagination and the symbols made of chalk on a blackboard.
12:10:51 <Baughn> bavardage: Well. High-school level, I suppose. Square roots, complex numbers, etc.
12:10:57 <bavardage> oh kk
12:11:04 <bavardage> Baughn: I am at 'high-school' level I guess
12:11:05 <Baughn> Cale: Sounds good to me. ;)
12:11:12 <bavardage> not totally sure about US education system
12:11:25 <b_jonas> strange the haddock docs say haddock does not like mutually recursive modules. why?
12:11:41 <Baughn> Cale: Though I do believe /some/ mathematical system is real, as in being our physics. But since we don't know which, well..
12:11:43 <Cale> Mathematics also isn't a science, because it doesn't rely upon the scientific method.
12:12:01 <Cale> All mathematical systems are equally real :)
12:12:09 <b_jonas> I thought haddock doesn't want to understand as much of the haskell language that that would be too much of a problem.
12:12:17 <wli> Physics would at the very least require temporal logic if not something furthermore augmented with statistical inference.
12:12:35 <b_jonas> Cale: that's only becuase physicists define "science" that way
12:12:37 <Baughn> wli: Temporal? There's nothing in the laws of physics about time..
12:12:39 <Spark> i think mathematics is basically a way of mechanising thought
12:12:52 <Spark> it's industrial-strength thinking
12:12:55 <Cale> b_jonas: Well, I define science that way too :)
12:12:57 <wli> Baughn: Try the second law of thermodynamics.
12:13:03 <b_jonas> whereas mathematicians only count mathematics and physics sciences, nothing else, even if they do use the scientific method
12:13:06 <pumpkin> does Max Rabkin hang out in here?
12:13:12 <Cale> I also don't like to assume that there's a mathematical description of the universe which perfectly describes its behaviour.
12:13:14 <Baughn> wli: That's just an approximation, a description of our lack of knowledge about systems
12:13:17 <Baughn> wli: It's not a /law/
12:13:34 <pumpkin> aha, it's taejo I think?
12:13:37 <Cale> That's a silly thing to assume, because there's very little which can be concluded from it.
12:13:45 <Baughn> wli: ..pretty close, but not quite a law.
12:14:18 <Cale> Baughn: You seem to like this idea that nature follows some set of unknown laws?
12:14:25 <kadaver> why does BloomFilter use names like elemB etc? why not force the user to import qualified instead?
12:14:50 <pumpkin> kadaver: different people have different opinions on things like that :P
12:14:55 <b_jonas> Cale: quite the converse, you can conclude very little if you _don't_ assume it, which is why we assume it
12:15:07 <Cale> b_jonas: I don't see how it's the least bit useful.
12:15:24 <wli> Baughn: Regardless, express it without the notion of time and without some statistical machinery built in to the logic.
12:15:27 <kadaver> ok gödels doesnt say that ZFC is wrong right? just says it cant be proven complete in itself?
12:15:29 <b_jonas> well, it's also implicit that we assume those rules are simple
12:15:37 <Cale> b_jonas: We can develop models of our observations and test them, and if they're useful, they're useful.
12:15:41 <Baughn> Cale: That it embodies some set of laws, yes. I can't wrap my head around the notion that it's literally undescribable, even in principle or on hyperturing computers, and it doesn't seem to match reality well
12:15:53 <Baughn> wli: Why would I do that? It /describes/ time.
12:16:05 <Cale> b_jonas: But I don't see what assuming that some unknown set of laws govern the universe buys you.
12:16:20 <Baughn> wli: Even if it isn't a fundamental law, it does a good job of describing the one-way information flow caused by the nifty boundary condition at the near end of the fourth dimension
12:16:26 <inimino> Cale: isn't the model of the universe as one which follows laws demonstrably rather useful?
12:16:45 <kadaver> Cale: a proof might be deductive but surely amthematicians use some induction to evolve towarda aproof?
12:16:55 <b_jonas> heh, should we add that to the quotes?
12:17:06 <Cale> Well, *models* of the universe which follow laws are useful.
12:17:10 <b_jonas> "Baughn: wli: Even if it isn't a fundamental law, it does a good job of describing the one-way information flow caused by the nifty boundary condition at the near end of the fourth dimension"
12:17:22 <Baughn> @remember Cale I don't see what assuming that some unknown set of laws govern the universe buys you.
12:17:22 <lambdabot> Done.
12:17:32 <Cale> But suppose I handed you a set of laws, and told you that they perfectly described the universe.
12:17:40 <Cale> How could you know if I was right?
12:17:44 <Baughn> Cale: I also don"t see a difference between a perfect description and the real thing
12:17:46 <Cale> You couldn't.
12:17:52 <Cale> (as far as I can tell)
12:17:53 <kadaver> Cale: statistics will be the foundation of mathematics
12:17:58 <Cale> You could only try to falsify them.
12:17:58 <b_jonas> well of course you couldn'y
12:18:05 <Baughn> Cale: And I'd use bayesian statistics. ;)
12:18:07 <sioraiocht> what would the exponential object on in a poset viewed as a category be?
12:18:09 <Cale> So why assume that there should be such a set of laws?
12:18:22 * sm suspects 6.10.2 links faster than 6.10.1 did
12:18:22 <inimino> Cale: you could gather supporting evidence just as well as for any other theory
12:18:24 <Baughn> Cale: As your laws failed to.. fail, I could update my belief in them increasingly close to 1
12:18:26 <Cale> If we can't even tell when we've found them :)
12:18:28 <b_jonas> Cale: "assume" doesn't mean you take it for sure, just that you use it as a working hyphthesis
12:18:35 <Baughn> Cale: "0" and "1" aren't real probabilities anyway
12:18:47 <b_jonas> Baughn: bayes doesn't work here
12:18:53 <b_jonas> you have no starting point
12:18:56 * sioraiocht is thinking the join...
12:19:02 <dmhouse> Baughn: in what sense?
12:19:02 <Cale> inimino: Right, but they operationally look just like any other theory.
12:19:13 <Cale> I see no need to assume that there's a perfect theory out there.
12:19:21 <lament> Cale: once the universe is over, we can create a model which fits it exactly, and derive laws from this model. This is cheating but the universe will of course conform to those laws. This would be a perfect theory.
12:19:24 <Cale> Why can there not just be an ever improving infinite sequence of them?
12:19:33 <Baughn> b_jonas: I use the inverse of the length of the kolmogorov complexity of the laws as my initial probability
12:19:45 <Cale> Why should the space of descriptions of the universe be compact? :)
12:19:46 <Baughn> dmhouse: They're the statistical equivalent of +/- infinity
12:19:48 <b_jonas> Cale: yes, some people say there can
12:19:53 <MyCatVerbs> Baughn: you mean the prior, right?
12:19:58 <Cale> I don't see a need to use this fact.
12:19:59 <Baughn> dmhouse: It's handy to have them, but not so handy to forget they're different
12:20:04 <Baughn> MyCatVerbs: ...yes
12:20:07 <b_jonas> Cale: but even if there's no perfect description (or it can't be found), I think it's a useful assumption that there is
12:20:10 <dmhouse> Baughn: they are? Because last time I checked, P(get a head or tail from a toss of a coin) = 1
12:20:13 <b_jonas> oh well
12:20:16 <Cale> b_jonas: How do you make use of it?
12:20:23 <Baughn> b_jonas: Which is basically a formalization of occam's razor, which seems to work well enough
12:20:23 <inimino> Cale: sure, there could be an endlessly closer approximation
12:20:23 <Cale> b_jonas: What can be concluded?
12:20:36 <Cale> inimino: Right, and no perfect finite description of the laws.
12:20:40 <MyCatVerbs> Baughn: "assume the prior probability of a given law to be inversely proportional to its Kolmogorov complexity" is the nicest phrasing of Occam's Razor that I've heard yet. =)
12:20:51 <b_jonas> Cale: you check all the possible simple rules and choose whichever seems to be confirmed by the most evidence, and then use that as a model
12:20:54 <lament> don't most people assume the universe is finite?
12:21:07 <b_jonas> to predict the future and act according to it.
12:21:15 <Baughn> MyCatVerbs: It also handily agrees with the observations you'd expect from living inside a dove-tailer
12:21:23 <Cale> b_jonas: Right, but it needn't be perfect.
12:21:24 <MyCatVerbs> Baughn: don't know if it counts as a perfect formalism, though. You never actually go to the trouble of calculating the Kolmorogov complexity of your physics textbooks, no?
12:21:28 <b_jonas> Even if that model is not perfect, this will likely help you choose the good decisions.
12:21:31 <Baughn> MyCatVerbs: (Which rather explains why /these/ laws, by assuming all of them are right)
12:21:44 <Cale> It might be that there's no finite set of laws which govern the universe exactly.
12:21:45 <Baughn> MyCatVerbs: Well, I never said it was easy. :P
12:22:01 <MyCatVerbs> Baughn: how do you mean living in a dove-tailer? You mean the universe being a simulation inside a TM dove-tailing over all possible TMs?
12:22:04 <b_jonas> MyCatVerbs: it sounds good but I don't thikn it actually work.
12:22:05 <Cale> b_jonas: You can do this without assuming there's a perfect model.
12:22:20 <Baughn> Cale: I'll assume that"s not the case until proven otherwise
12:22:20 <inimino> you really can't calculate Kolmogorov complexity, but it's a useful stand in for some kind of vague idea
12:22:25 <Baughn> Cale: ..by occam's razor
12:22:30 <Cale> b_jonas: Science doesn't need to assume that there's a perfect model which it is approaching.
12:22:32 <Baughn> MyCatVerbs: Yes
12:22:35 <b_jonas> Cale: yes, I guess you're right, you could assume there's only an approximate model.
12:22:40 <inimino> (which then gets confused with intuition and leads to a whole class of errors)
12:22:53 <Baughn> inimino: A very /concrete/ idea, really
12:23:08 <Baughn> You /can/ calculate kolmogorov complexity, you just need an infinitely powerful computer
12:23:16 <MyCatVerbs> Cale: why on Earth would there not be a perfect model
12:23:22 <b_jonas> shouldn't we discuss this on #haskell-blah by the way?
12:23:27 <Cale> MyCatVerbs: Why would there be?
12:23:29 <inimino> Baughn: we seem to have different definitions of "can" ;)
12:23:31 <MyCatVerbs> Cale: ...even if it might only be probabilistic?
12:24:01 <Cale> MyCatVerbs: Even so.
12:24:05 <vixey> it wouldn't be a model anymore it would be the real thing
12:24:13 <Baughn> inimino: You could do it on a finite one too, if you include the size of the en/decoder in the complexity
12:24:19 <Baughn> A mite doubtful, admittedly
12:24:46 <Baughn> Try every combination, and eventually you'd end up with a description smaller than the size of every en/decoder you've yet to try
12:25:02 <Baughn> All you need is a solution to the halting problem
12:25:20 <inimino> hehe
12:25:20 <Cale> It might also be that the universe, despite all of our expectations to the contrary, completely changes how things work tomorrow. Assuming we're still recognisably around, science would probably still serve us well. We'd just have to start over :)
12:25:38 <Baughn> Cale: But it won't. :P
12:26:52 <Baughn> @remember Cale The universe, despite all of our expectations to the contrary, completely changes how things work tomorrow.
12:26:52 <lambdabot> Done.
12:27:05 <Cale> heh
12:27:08 <b_jonas> Cale: in that case I'd finally stop despairing that I didn't buy that physics book two years ago when it was available for cheap
12:27:13 <Cale> But, well, my point is we don't have to assume that it's possible to be perfect about predicting it in order to have useful science.
12:27:27 <Baughn> Oh, I never assumed /that/
12:27:35 <Baughn> Bayesian updates never get you to 1 anyway
12:27:52 <Baughn> (See? It's not a real probability)
12:28:11 * dmhouse still disagrees
12:28:20 <inimino> actually if there a one true finite model, then it is possible to find it and I think that's what Cale means
12:28:26 * Baughn also thinks Infinity isn't a real number
12:28:35 * Baughn is, admittedly, misusing "real"
12:28:40 <dmhouse> Baughn: well, that's obviously true.
12:28:42 <Cale> So I don't like assuming that the universe follows a fixed set of laws that we just don't know. I only accept that we seem capable of constructing models which do a good enough job of predicting it to be useful.
12:28:52 <b_jonas> but of course if it just changes how it works only once but it did follow a rule up to today and will follow a different rule from tomorrow, then there's still a rule describing it all the time
12:28:57 <inimino> it's not possible to know with p=1 you've found it, so there's no real difference I can see between these positions
12:28:58 <Cale> Baughn: It's not a real number ;)
12:29:11 <Baughn> Cale: And yet the universe might be infinitely large
12:29:17 <dmhouse> Baughn: or at lest widely conventional. However, it's also conventional to describe events with probability 0 or 1, e.g. getting a head or a tail from a coin toss.
12:29:30 <Cale> Baughn: What do you think about the number 1? Is it real?
12:29:38 <Baughn> dmhouse: Yeah. Reality disagrees.
12:29:40 <Cale> Of course it is, it's an element of R :)
12:29:43 <Baughn> dmhouse: The coin sometimes lands on edge
12:29:45 <b_jonas> wow, now we're going meta
12:29:45 <bavardage> Cale: hur hur hur
12:30:10 <Cale> The real numbers, the hyperreal numbers, the integers, the natural numbers, are all equally realistic.
12:30:19 <Cale> They're all abstractions.
12:30:25 <Cale> They're all human constructions.
12:30:33 <Baughn> dmhouse: Even if the coin lands heads a million times in a row, bayesian updates still wouldn't put the probability at "1" - it might land tails next time
12:30:36 <dmhouse> Baughn: fine, the probability of picking either an odd or even number from the naturals.
12:30:43 <kerlo> The hyperreals are actually a pipe dream, in my opinion. :-P
12:30:51 <Baughn> dmhouse: Mm. Your brain might malfunction.
12:30:52 <dmhouse> Baughn: of course.
12:30:55 <Baughn> dmhouse: Or if that doesn't work..
12:31:05 <Cale> dmhouse: What measure are you putting on them?
12:31:07 <dmhouse> I think we have different ideas of what a probability is.
12:31:19 <Baughn> dmhouse: Your brain may have been malfunctioning all along, suddenly start working properly, and it turns out there were always integers that were neither odd nor even
12:31:50 <ddarius> Indeed.  The naturals don't exist.
12:31:51 <b_jonas> so does anyone know how to build the haddock docs for encoding?
12:31:57 <Baughn> In an idealized, mathematical way I'd agree the probability of picking odd or even is 1
12:32:14 <Baughn> I'd still not agree that 1 is a /real/ probability, since in /reality/ you can't get it
12:32:18 <kadaver> the BloomFilter diesnt seem to be working, it responds yes for any key whatsoever
12:32:28 <dmhouse> Definitions: a "sample space" is any countable set (stay simple for now). An "event" is a subset of the sample space. A "probability distribution on a sample space Omega" is a function P : Omega -> [0,1], s.t. P(A u B) = P(A) + P(B) for disjoint A, B, and P({}) = 0.
12:32:38 <Cale> Baughn: Can you get 1/2? :)
12:32:41 <pumpkin> kadaver: if you make a sufficiently small bloom filter, that will happen... what are its parameters?
12:32:47 <dmhouse> The "probability" of an event is its value under the probability distribution.
12:32:49 <Baughn> Cale: Sure
12:32:53 <vixey> the probably of everything is 1 or 0
12:32:55 <dmhouse> Then P(Omega) = 1. See, it's a probability.
12:32:55 <Cale> Baughn: exactly 1/2?
12:32:57 <Cale> hehe
12:32:58 <vixey> just wait until it happens
12:33:01 <dmhouse> Baughn: time for your definitions.
12:33:15 <Baughn> Cale: Nah. I'd need error bars, same as for everything else.
12:33:30 <Cale> Then what's wrong with error bars around 1?
12:33:35 <Cale> hehe
12:33:36 <inimino> Math does'nt need error bars
12:33:43 <kerlo> There are Bayesian probabilities and there are frequentist probabilities. If I have two coins, one being fair and the other being double-headed, and I pick one randomly, the frequentist probability of getting heads is either 1 or 1/2, while the Bayesian probability is 3/4.
12:33:50 <inimino> that's only the messy real world
12:34:00 <Cale> inimino: Right, from a mathematical perspective, Baughn's concern is meaningless.
12:34:13 <Baughn> dmhouse: A "sample space" is any consistent state of the universe. An "event" is a subset of the sample space. A "probability".. actually, it's just my definition of "sample space" that differs.
12:34:23 <Cale> Also, what's this about randomly picking natural numbers? What distribution are you using?
12:34:49 <dmhouse> Cale: fine, simplify by picking a number from {0,1} using the uniform distribution.
12:35:07 <dmhouse> Cale: but an distribution would have done (e.g. P(pick n) = 2^{-n}), we only wanted P(Omega).
12:35:13 <dmhouse> *any
12:35:32 <Cale> Oh, you're talking about the probability of the whole space?
12:35:43 <Cale> Well, that's obviously 1 :)
12:35:44 <dmhouse> I was, to show that 1 was in fact a valid probability.
12:35:55 <Baughn> inimino: Yeah, I'm just not looking at this from a mathematical perspective. It'd be nice to be able to, but I run on physical hardware. :P
12:36:09 <dmhouse> (That above assumes the naturals exclude 0, otherwise P(pick n) = 2^{-n+1}.)
12:36:17 <Cale> Baughn: But that's the nice thing, even though you run on physical hardware, you can still do abstract mathematics.
12:36:18 <Baughn> dmhouse: Mm. I don't think we disagree, then; it's valid, just not real.
12:36:26 <Baughn> Cale: Not with perfect certainty
12:36:46 <Cale> Baughn: Well, only with the same certainty that you're actually talking on IRC right now.
12:37:27 <Baughn> Cale: If you calculate a 1/4 trillion probability that the LHC will destroy the world, but one in five hundred such calculations have mistakes in them, then the actual (from our POV, not reality's) probability of the LHC being safe is much, much smaller than what you calculated
12:37:31 <inimino> within the system you can have perfect certainty
12:37:32 <Cale> Mathematics is a game, as a whole it can be no more true or false than my coffee cup :)
12:37:52 <Baughn> It can't be very much larger than 499/500, in fact
12:38:13 <dmhouse> Baughn: if your sample space is the set of consist states of the universe, then the probability of getting a consistent state of the universe after tossing a coin is 1
12:38:14 <Baughn> (Depending on how often calculations are wrong but the conclusion is right anyway)
12:38:33 <dmhouse> Baughn: if you are in fact sticking to your aforementioned definitions.
12:38:34 <vixey> I don't know what you mean - Anyway I don't really believe in truth values
12:38:35 <Baughn> dmhouse: ..yes, by definition
12:38:49 <Cale> and of course, statements within mathematics are only given truth values according to the rules we decide upon
12:38:50 <dmhouse> Baughn: right, so it's a real probability, according to your definitions.
12:39:04 <Cale> which we do in an entirely arbitrary fashion according to our whims :)
12:39:07 <Baughn> dmhouse: Can we forget I said "real", then?
12:39:08 <dmhouse> Likewise the probability of getting an inconsistent state of the universe after a coin toss is 0.
12:39:26 <Baughn> What I meant was "Probability you will run into for anything you can actually observe"
12:39:40 <dmhouse> Baughn: I'm not sure why "real" is a problem. You seemed to be stating that no event could have probability 0 or 1, which I think is false using either of our definitions.
12:39:46 <gnuvince_> Is there a pronounciation difference between "trie" and "tree"?
12:40:13 <Cale> gnuvince_: Some people pronounce "trie" as "try"
12:40:30 <maxote> is there any method like Laguerre to solve multivariable polynomial equation extracting either real roots or some random complex roots of the collection to guide to the possible real root?
12:40:38 <dmhouse> gnuvince_: I think "tree" is more common though.
12:40:38 <Baughn> gnuvince_: I don't, but that's a nice approximation. "trai"?
12:41:03 <gnuvince_> The homophony can sometimes be confusing
12:41:05 <dmhouse> (I mean, pronouncing "trie" as "tree" is more common than pronouncing it as "try".)
12:41:28 <wli> maxote: No, the methods are vastly more complex.
12:42:00 <b_jonas> I thought it was pronounced try
12:42:12 <mauke> re{trie}ve
12:42:17 <maxote> the idea is prove if 2 opposed hiperbolas in 3D are crossed or not.
12:42:24 <b_jonas> but don't trust me about english pron
12:42:34 <kadaver> pumpkin: thanks i mad with just 3 elems, for 100 elems it works finee
12:43:10 <pumpkin> kadaver: http://www.cc.gatech.edu/~manolios/bloom-filters/calculator.html might be handy
12:43:16 <pumpkin> if you want to use them a lot
12:43:26 <kadaver> kerlo: how can it either be 1 or 1/2?
12:43:44 <Baughn> dmhouse: How about this, then: I don't believe we can ever hold knowledge that something will happen with probability one or zero, and that if we think we /do/ then we're either discounting the possibility of mental error, looking at a tautology, or both
12:44:18 <Baughn> dmhouse: The "universe will be in a consistent state" thing would be a tautology
12:44:35 <p_l> Baughn: or escaped this simulation and got control of it?
12:45:02 <Baughn> p_l: Then the error is in assuming that it's the universe when, in fact, it's just a small part of it
12:45:20 <inimino> Baughn: I think that's a useful idea
12:45:21 <dmhouse> Baughn: right, so if you explicitly exclude tautologies, then you obviously can't get an event with probability 1, because you just excluded all the events with probability 1 :)
12:45:49 <Baughn> dmhouse: Well, it's still possible that I'm /wrong/ about it being a tautology. ;P
12:45:58 <agcorona> there is a deep relation between computability, probability, entropy increase and time: living beings need to make computations to make use  the world. this impose strong restrinctions on how probabilty and entrophy change with time
12:46:47 <Baughn> agcorona: So it appears, but we could be wrong about that; not all possible laws of physics require that, and our could be embedded as a computer in a set of physics that don't. Or we could just be systematically mistaken.
12:47:35 <agcorona> I think that this is the reason why macroscopical laws are lineal an derivabe.
12:47:40 <monochrom> Computer science clarifies. Computer science is a better math than math, a better philosophy than philosophy.
12:47:43 <agcorona> and continuous
12:48:08 <Baughn> monochrom: ..considering the state of philosophy, that doesn't take much
12:48:17 <maxote> monochrom, compsci = math + machine
12:48:23 <agcorona> laws that produce chaotic environments ever are not suitable for life
12:48:35 <maxote> math = math    (without machine)
12:48:53 <ddarius> > let math = math in math
12:48:54 <lambdabot>   * Exception: stack overflow
12:49:31 <agcorona> living beings can not live also wher entropy decreases, beceuse such environments are uncomputable.
12:50:34 <kadaver> are all physical laws really computable?
12:50:43 <kerlo> kadaver: 1 if it's the double-headed coin, 1/2 if it's the fair coin.
12:50:46 <Baughn> kadaver: All the ones we've seen so far are
12:50:53 <inimino> kadaver: as far as we know
12:51:08 <agcorona> so this is the reason why our local universe is as such. I think also that the absence of contradiction is necessary for life. as is locality (local evens have no strong influence far away)
12:51:09 <Baughn> kerlo: And if it lands on edge?
12:51:15 <maxote> ddarius, GHC is not detecting that math of the right handside has not value
12:51:47 <kadaver> kerlo: sure but if you repeat that exeriment a lot fo times what will you get?
12:51:50 <kadaver> ...
12:52:00 <p_l> kadaver: all of our current assumptions about world require that it is all about information and computability in the end (minus religious stuff)
12:52:29 <agcorona> Kadaver: no all the events are lineal, but the important thing is that the laws permit SOME lineal phenomena . such phenomena are not chsotic, and , as such are suitable for life
12:52:30 <mm_freak> are you talking about IO?
12:52:33 <mm_freak> i mean the worldâ¦
12:52:40 <inimino> Baughn: then you exclude that result
12:52:46 <monochrom> Hehe
12:53:02 <harovali> how can i install a new module, f.i. Text.Parsec , in GHCi ?
12:53:03 <Baughn> inimino: What if it lands on edge nine out of every ten tosses?
12:53:12 <mm_freak> (actually IO isn't the worldâ¦  it's just its type)
12:53:17 <Baughn> harovali: "Install"?
12:53:20 <inimino> Baughn: then you try a different coin :)
12:53:28 <Baughn> harovali: If you mean import.. "import Text.Parsec"
12:53:33 <agcorona> in contrast, if all the macroscopic laws of nature were non lineal, then all phenomena would be chaotic.
12:53:33 <p_l> Baughn: then you check if you didn't end in that weird rational part of space.
12:53:50 <Baughn> agcorona: s/lineal/linear/
12:54:00 <agcorona> yes, linear sorry
12:54:27 <harovali> Baughn: I did "import Text.Parsec" but not found error appears
12:54:34 <kerlo> Baughn: fair coins never land on the edge. :-P
12:54:47 <harovali> Baughn: So , I think I have to install
12:55:13 <Baughn> harovali: THen you use cabal-install.
12:55:28 <kerlo> kadaver: but you don't repeat the experiment a lot of times. Once you've chosen the coin, which coin it is is not random, just unknown.
12:55:28 <Baughn> "cabal install parsec" on the command-line... after installing cabal-install
12:55:30 <harovali> Baughn: thanks
12:55:38 <ddarius> kerlo: The could almost never land on the edge.
13:00:21 <agcorona> I mean it is much much more easy to calculate how or where the fragments of a glass of water fall thant to calculate if a set of fragments of glass will create in a bottle. That is why the arrow of time goes in the direction of entropy increase: it is much more easy t calculate, and life choose the easy path
13:01:22 <kadaver> kerlo: ok i see that corresponds to some of my worldview actually
13:01:22 <kadaver> or not in that case
13:01:22 <kadaver> which coin it is is not random, just unknown.
13:01:22 <kadaver> this part ring true in some ways
13:03:48 <defun> :t join
13:03:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:03:52 <dons> ?users
13:03:53 <lambdabot> Maximum users seen in #haskell: 658, currently: 622 (94.5%), active: 28 (4.5%)
13:04:26 <kadaver> but i mean dont i make 2 chocies, one which coin and one which side?
13:06:00 <monochrom> dons: How will we celebrate when we reach 700? :)
13:07:03 <kadaver>  > let group f = group (group f) in group 10
13:07:12 <kadaver> > let group f = group (group f) in group 10
13:08:16 <Beelsebob> > let group f = let g = group f; h = group g in g `parSeq` h
13:08:17 <Beelsebob> :P
13:08:24 <EvilTerran> group = join (.) = _|_
13:08:26 <lambdabot>   <no location info>: parse error on input `;'
13:08:30 <Beelsebob> if you're gonna write a forkbomb, at least fork bomb properly
13:08:31 <Beelsebob> :P
13:08:47 <idnar> heh
13:08:56 <Nafai> Yay another troll blog post from jdh
13:09:04 <kerlo> What's parSeq?
13:09:06 <EvilTerran> (or rather, = const _|_)
13:09:13 <lpsmith> Nafai:  fun :-P
13:09:23 <Beelsebob> kerlo: it's seq, only it evaluates its left and right arguments in parallel and then returns its right
13:09:38 <Beelsebob> @seq parSeq
13:09:39 <idnar> isn't that just par?
13:09:43 <Beelsebob> @src parSeq
13:09:46 <lambdabot> Maybe you meant: faq let seen src
13:09:52 <lambdabot> Source not found. You speak an infinite deal of nothing
13:10:03 <idnar> @type par
13:10:04 <EvilTerran> idnar, ISTR (x `par` y) isn't strict in x
13:10:10 <lambdabot> forall a b. a -> b -> b
13:10:11 <idnar> EvilTerran: oh, right
13:10:42 <EvilTerran> any exceptions thrown while evaluating the x spark will be held into until another thread uses x, iirc
13:10:42 <idnar> so... x `parSeq` y = x `par` y `seq` x `seq` y or something?
13:10:49 <kerlo> > let group f = let {g = group f; h = group g} in g `parSeq` h
13:10:56 <lambdabot>   <no location info>: parse error on input `;'
13:11:26 <EvilTerran> x `parSeq` y = x `par` (y `seq` x `seq` y) -- or something. maybe.
13:11:42 <Beelsebob> > [Nothing,Nothing..]
13:11:43 * kerlo frowns
13:11:44 <lambdabot>   <no location info>: parse error on input `]'
13:11:49 <Beelsebob> :(
13:12:01 <Beelsebob> > repeat Nothing
13:12:03 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,No...
13:12:05 <EvilTerran> (spark a thread for x, evaluate y, wait to make sure x isn't _|_, evaluate to y)
13:12:09 <Saizan> > [Nothing,Nothing ..]
13:12:10 <lambdabot>       No instance for (Enum (Maybe a))
13:12:10 <lambdabot>        arising from the arithmetic seq...
13:12:11 <Beelsebob> better, got an infinite deal of Nothing now
13:12:15 <dons> Nafai: where did you see that?
13:12:42 <Nafai> dons: It's the FFI one you already commented on :)
13:12:50 <EvilTerran> > [Nothing ..] :: [Maybe Char]
13:12:52 <lambdabot>       No instance for (Enum (Maybe Char))
13:12:52 <lambdabot>        arising from the arithmetic ...
13:12:56 <EvilTerran> o
13:13:09 <dons> Nafai: ah. yeah, the bug that was fixed and in stable releases before it was reported.
13:13:22 <dons> non-issue. but hey, that's what he likes to do. waste time chasing us
13:13:31 <Nafai> dons: http://feedproxy.google.com/planet_lang <- I'm subscribed to this so I get jdh's posts along with all the other stuff :)
13:13:46 <dons> oh, where does he post? planet ocaml?
13:14:07 <Nafai> ML etc
13:14:43 <dons> he's a strange individual
13:14:51 <Nafai> Or maybe that is just how it is classified in this feed
13:14:52 <vixey> Parser combinator propaganda:
13:14:53 <Nafai> Indeed
13:14:58 <vixey> * Parser combinator libraries are great!
13:15:09 <vixey> just read this in some slides :p
13:15:22 <dons> let's build some more containers libraries :)
13:15:57 <vixey> are there some libs basically like parsec but that do some tricks to be more efficient?
13:16:21 <glguy> there was an Arrow based parser combinator library tht was able to do some optimizations
13:16:36 <glguy> due to being able to look under the arrows
13:16:47 <Saizan> but any non-deterministic parser comb. library besides ReadP?
13:16:54 <Saizan> s/but/btw/
13:17:22 <vixey> would you count Parsec as nondet, if you used  <|>`on`try  rather than plain  <|>  ?
13:17:26 <bakesz> hi guys!Could you help me with this error message:Variable not in scope: `pseq'.?and i imported Control.Parallel
13:17:37 <glguy> bakesz, use two `
13:17:39 <wli> X-SAIGA?
13:17:55 <mauke> @index pseq
13:17:55 <lambdabot> GHC.Conc
13:18:00 <mauke> what
13:18:01 <Saizan> vixey: i actually want multiple results when there's ambiguity
13:18:04 <pumpkin> Control.Parallel.Strategies
13:18:19 <glguy> Oh, I thought it was writing (`pseq') :)
13:20:06 <jeffersonheard> dons:  do you keep individual package download stats for hackage?
13:21:12 <mstr> when /= operator was chosen instead of != was it just to annoy C coders? ;P
13:21:41 <mauke> mstr: != doesn't make sense if you don't have ! for 'not'
13:21:56 <Alpounet> it could have been <> also
13:21:57 <Twey> In Haskell ! is mostly used for 'lookup'
13:22:10 <Twey> Alpounet: Yeah, but that kind of relates it to < and >
13:22:12 <bakesz> glguy,how do you mean use two?
13:22:23 <Twey> And an Eq isn't necessarily an Ord
13:22:56 <Gracenotes> !
13:23:00 <Alpounet> Twey, heh
13:23:03 <mriou> hi, is there a way to provide more than one file to runghc?
13:23:03 <mstr> Alpounet: reminds me of c64 basic :D
13:23:10 <Twey> <> derives its meaning from âeither greater or smallerâ, in the vein of <= and >=
13:23:18 <Twey> mstr: Or, more modernly, SQL?  :-P
13:23:25 <mstr> or even pascal?
13:23:32 <Twey> Or VB
13:23:36 <Twey> Or Python
13:23:40 <Twey> &c.
13:23:48 <mstr> <> seems to be popular then :)
13:23:50 <mauke> â¶
13:24:09 <Twey> Why is it that getLine doesn't behave like input in C, automatically flushing output?
13:24:17 <dons> jeffersonheard: yeah, they're not up to date (2 weeks old now)
13:24:27 <mauke> Twey: input in C doesn't automatically flush output
13:24:32 <Twey> Er, C++ sorry
13:24:42 <Twey> I find it very annoying to have to import System.IO (stdout, hSetBuffering) just so I can do a basic input prompt
13:24:44 <jeffersonheard> dons: okay.  not a problem.  just curious if they were actually kept
13:25:14 <dons> jeffersonheard: http://galois.com/~dons/hackage/popularity.csv and http://galois.com/~dons/hackage/hackage.csv
13:25:16 <Eridius> Twey: well, you could use hFlush instead of hSetBuffering
13:25:17 <Twey> Oh, and BufferMode (NoBuffering) of course
13:25:18 <mauke> Twey: ITYM hFlush
13:25:25 <mauke> Twey: no, you don't want NoBuffering
13:25:27 <Twey> Ah, that is a better solution
13:25:33 <Twey> (but still annoying)
13:25:47 <mauke> welcome to C :-)
13:25:48 <wli> Has anyone done CPO-STV yet?
13:26:07 <wli> (Speaking of voting.)
13:26:19 <dons> jeffersonheard: had you seen the data from the post a couple of weeks ago?
13:26:37 <jeffersonheard> yeah, and I was trying to recall if it was what I thought it was
13:26:42 <jeffersonheard> this looks like it
13:26:55 <jeffersonheard> wondered if it was broken down daily was the idea
13:27:05 <jeffersonheard> daily or monthly
13:27:07 <jeffersonheard> or some such
13:27:15 <dons> monthly, yes.
13:27:30 <dons> see http://galois.com/~dons/hackage/hackage.csv
13:27:41 <mstr> if there are shorter way to type: filter (\x -> (x `mod` npr) /= 0
13:27:43 <dons> i intend to have them updated weekly or nightly
13:27:44 <jeffersonheard> reading it right now actually
13:28:38 <Twey> Anyway, it would be handy to have getLine = hFlush stdout >> oldGetLine
13:28:53 <wli> So define it!
13:29:00 <mauke> filter ((/= 0) . (`mod` npr))
13:29:17 <mstr> what was that word for it, section?
13:29:25 <wli> I mostly want/need liftIO on everything in System.IOI
13:29:46 <mstr> why doesn't (`mod` npr) /= 0 work?
13:30:04 <mstr> like map (*3) [24,36]
13:30:06 <mstr> work
13:30:07 <mstr> s
13:30:49 <eu-prleu-peupeu1> hi
13:30:59 <mmorrow> @type \n -> (/=0) . (`mod`n)
13:31:01 <lambdabot> forall a. (Integral a) => a -> a -> Bool
13:31:57 <Twey> wli: Having to define it defeats the purpose... it's just not handy any more :)
13:32:57 <kadaver> is the reno conveient random fucntion in haskell? it is amazing i never get random nbrs in haskell.
13:33:06 <kadaver> i jsut want a function that returns a new random nrb each time-
13:33:12 <kadaver> r <- random
13:33:12 <Twey> kadaver: random is pretty convenient
13:33:32 <Twey> Well, r <- random <<= getStdGen
13:33:38 <Twey> Er, =<<
13:33:43 <mauke> mstr: because ((*3) + 1) doesn't work either
13:33:48 <dons> kadaver: the System.Random package
13:34:04 <mauke> mstr: (`mod` npr) /= 0 tries to compare a function to the number 0
13:34:06 <Twey> Yeah, import System.Random (random, getStdGen) for both of those
13:34:38 <mauke> mstr: you have to create a function "pipeline"; first send the value through mod npr, then compare the result of that to 0
13:34:54 <kadaver> ouldn't match expected type `(a1, a)'
13:34:54 <kadaver>            against inferred type `IO StdGen'
13:35:09 <kadaver> yeah thats the module im talking about
13:35:24 <kadaver> maybe im retarded but i can enevr remember how to just generate a random nrb without any bullshit
13:35:59 <Saizan> ?type randomIO
13:36:00 <lambdabot> forall a. (Random a) => IO a
13:36:56 <bavardage> think the 'IO' comes under his definition of bullshit :P
13:36:59 <Twey> kadaver: Oh, sorry
13:37:19 <Twey> kadaver: r <- return . random =<< getStdGen
13:37:36 <Twey> But yeah, there's randomIO too
13:38:13 <Twey> (oh, mine gives you a value/seed pair anyway: you'd need to say (r, _) <- ... to just get the value.  But yeah, randomIO is probably what you want)
13:44:21 <sioraiocht> @src curry
13:44:21 <lambdabot> curry f x y = f (x, y)
13:45:13 <pumpkin> why are some of the shootout tests not performed anymore?
13:46:17 <bavardage> what is the best library to use for xml in haskell?
13:48:14 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3301#a3301 <- kerlo so how is that not liek the situation you presented? bayes vs freqs
13:48:24 <pumpkin> @pl foldl (>>=)
13:48:24 <lambdabot> foldl (>>=)
13:48:45 <pumpkin> doesn't that have a name?
13:49:07 <kadaver> foldRocket
13:49:40 <Beelsebob> penisFold
13:49:46 <Beelsebob> sounds painful
13:49:57 <pumpkin> lol
13:50:07 <mauke> :t foldl (>>=)
13:50:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
13:50:08 <pumpkin> are there any plans on improving the rewrite rule system in GHC?
13:50:15 <kerlo> kadaver: that selects a new coin every time.
13:50:36 <kadaver> well
13:50:48 <Beelsebob> pumpkin: at a guess any decent name for it is longer than foldl (>>=)
13:51:06 <kadaver> so frequanetists dont believe an experiemnt is repeatable?
13:51:16 <pumpkin> Beelsebob: it wasn't a golfing attempt, I was just curious as it seemed like it should be named
13:51:52 <Beelsebob> pumpkin: I'm not too sure it's that useful
13:52:00 <Beelsebob> because all the values along the chain have to be the same type
13:52:01 <pumpkin> true :)
13:52:14 <kerlo> After you select a coin randomly, the frequentist probability of the coin being what it is is 1, and the probability of the coin being what it isn't is 0, because which coin it is is no longer random.
13:52:14 <pumpkin> it's a distant relative of sequence
13:52:15 <Beelsebob> would be nice if it were a hetrogenious list
13:52:29 <Beelsebob> similarly foldl (.) then
13:52:44 <pumpkin> :t foldl (.)
13:52:45 <lambdabot> forall c a. (a -> c) -> [a -> a] -> a -> c
13:52:49 <pumpkin> :)
13:53:11 <ddarius> pumpkin: Yes, (re rules)
13:54:28 <pumpkin> ddarius: any tickets or writings you know of that discuss it?
13:57:44 <ddarius> pumpkin: There was an entire GSoC project about it.
14:04:15 <FunctorSalad> pumpkin_: "do statement"? ;o
14:04:23 <FunctorSalad> (a special case of it anyway)
14:04:42 <kadaver> kerlo: ok but that is a pretty pointless view froma pratical standpoint isn't it? if you repeat the experiment you get 0.75,thats interestin
14:04:44 <kadaver> g
14:04:50 <FunctorSalad>  /do expression
14:05:43 <kerlo> kadaver: well, in the real world, things don't always happen over and over again. :-)
14:06:14 <kerlo> But I find frequentist probabilities relatively non-useful.
14:07:14 <bavardage> @src Network.HTTP
14:07:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:11:54 <mmorrow> umm, i can't figure out for the life of me how:
14:11:57 <mmorrow> 1 .10010010000111111011011
14:11:58 <mmorrow> ==
14:12:05 <mmorrow> 1.5707964
14:13:39 <vixey> @google digit
14:13:40 <lambdabot> http://en.wikipedia.org/wiki/Digits
14:13:40 <lambdabot> Title: Digit - Wikipedia, the free encyclopedia
14:13:43 <mmorrow> , let fromBits bs = let n = 32 in foldl' (\a (n,b) -> a.|.b`shiftL`n) 0 . reverse . zip [0..n-1] . reverse $ bs in fromBits [1,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,1,1] :: Int
14:13:46 <lunabot>  luna: Not in scope: `foldl''
14:13:52 <mmorrow> , let fromBits bs = let n = 32 in foldl (\a (n,b) -> a.|.b`shiftL`n) 0 . reverse . zip [0..n-1] . reverse $ bs in fromBits [1,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,1,1] :: Int
14:13:53 <lunabot>  4788187
14:14:00 <mmorrow> ????!!
14:14:08 <Saizan> > sum $ zipWith (*) (map digitToInt "10010010000111111011011") (map (2**) [-1,-2..])
14:14:09 <lambdabot>       No instance for (Floating Int)
14:14:09 <lambdabot>        arising from a use of `**' at <in...
14:14:15 <vixey> > let dig '1' = 1 ; dig '2' = 2 in map dig "10010010000111111011011"
14:14:16 <lambdabot>   [1,* Exception: /tmp/1062450016820859004:71:144-168: Non-exhaustive pattern...
14:14:25 <Saizan> > sum $ zipWith (*) (map (fromIntegral . digitToInt) "10010010000111111011011") (map (2**) [-1,-2..])
14:14:26 <lambdabot>   0.5707963705062866
14:14:30 <mmorrow> ohhh. i'm retarded :)
14:14:31 <vixey> :((
14:14:33 <mmorrow> thanks!
14:14:34 * vixey was getting there
14:14:59 <harovali> "return" is a function?
14:15:07 <vixey> yes
14:15:16 <vixey> :t return
14:15:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:15:23 <vixey> :t (\x -> return x x)
14:15:24 <lambdabot> forall a. a -> a
14:15:37 <harovali> vixey: and a use case?
14:15:38 <mauke> :t \x -> return x return
14:15:40 <lambdabot>     Ambiguous type variable `m' in the constraint:
14:15:40 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:15-20
14:15:40 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:15:45 <mauke> oh, right
14:15:55 <mauke> harovali: it's a virtual constructor
14:16:10 <harovali> mauke: what does it mean?
14:16:21 <mauke> depends on what you're constructing
14:16:34 <harovali> mauke: i see
14:16:42 <mauke> > return 42 :: [Int]
14:16:43 <lambdabot>   [42]
14:16:48 <mauke> > return 42 :: Maybe Int
14:16:49 <lambdabot>   Just 42
14:16:58 <mauke> > return 42 :: Either String Int
14:16:59 <lambdabot>   Right 42
14:17:01 <harovali> mauke: interesting
14:17:15 <monochrom> virtual constructor is a special case of virtual method
14:17:35 <vixey> :t return return return
14:17:36 <lambdabot>     Ambiguous type variable `m' in the constraint:
14:17:36 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:14-19
14:17:36 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:17:39 <vixey> :t return return
14:17:40 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 (a -> m a)
14:17:53 <vixey> :t join (return return)
14:17:55 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:18:06 <vixey> > join (return return) 42 :: Maybe Int
14:18:07 <lambdabot>   Just 42
14:18:21 <harovali> "::" in "return 42 :: [Int]" , is exactly what?
14:18:25 <vixey> > join ((join (return (join (return return)))) (join (return (join (return return))))) 42 :: Maybe Int
14:18:27 <lambdabot>   Just 42
14:18:29 <mauke> a type annotation
14:18:33 <gnuvince_> Is it possible in GHCi to view the source of a function?
14:18:39 <mauke> well, the token telling the compiler that a type annotation follows
14:18:43 <monochrom> A delimiter between an expression and its type.
14:18:44 <mauke> gnuvince_: no
14:19:00 <harovali> mauke: is that "part" of return, or it is part of haskell?
14:19:08 <mauke> haskell
14:19:11 <harovali> fine
14:19:12 <mauke> > 42 :: Double
14:19:13 <lambdabot>   42.0
14:19:16 <gnuvince_> mauke: thanks
14:19:17 <FunctorSalad> @type return 42 -- harovali: that's the type if you don't tell haskell which type you  mean
14:19:18 <lambdabot> forall t (m :: * -> *). (Monad m, Num t) => m t
14:19:33 <FunctorSalad> (it's polymorphic over the monad)
14:19:33 <dons> gnuvince_: the haddocks have links to source now
14:19:44 <dons> so you could imagine displaying source via :info looking up the haddock db
14:19:45 <harovali> FunctorSalad: i see
14:19:46 <monochrom> Of course, no one wants a type that takes 40 characters to type.
14:19:47 <dons> that would be really cool
14:20:02 <bavardage> @src proc
14:20:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:20:06 <bavardage> what's 'proc'?
14:20:15 <bavardage> proc x -> do loc     <- textAtTag "location"          -< x ...
14:20:20 <monochrom> proc is a keyword in the arrow syntax.
14:20:24 <mauke> oh, looks like arrows
14:20:29 <bavardage> oh kk
14:20:38 <bavardage> what are arrows in a nutshell?
14:20:44 <bavardage> (I'm trying to do some XML stuff)
14:20:48 <monochrom> A generalizaiton of functions.
14:21:12 <harovali> "return 42 :: [Int]" is like "(return 42) :: Int" ?
14:21:20 <mauke> no
14:21:22 <harovali> sorry [Int]
14:21:34 <FunctorSalad> bavardage: or SomeArrow a b can be thought of as a generalization of a -> SomeMonad b
14:21:38 <mauke> well, yes. (x) is the same as x
14:21:43 <dons> "arrows in a nutshell"
14:21:46 <dons> would be a good book :)
14:21:47 <FunctorSalad> (these arrows are called kleisli arrows)
14:21:50 <bavardage> right
14:21:56 <bavardage> do I need to understand them to use them :P?
14:22:03 <bavardage> cos that makes only minimal sense
14:22:04 <harovali> mauke: so, :: annotates te result of return, right?
14:22:08 <monochrom> arrows through the hearts of two lovers
14:22:14 <FunctorSalad> bavardage: I think in XML the arrows are essentially kleisli arrows
14:22:17 <FunctorSalad> eh in HXT
14:22:24 <bavardage> FunctorSalad: yeah that makes no sense either :D
14:22:32 <mauke> harovali: oh, yes. :: has very low precedence
14:22:45 <monochrom> arrows are as easy to understand as monads
14:23:12 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml may help. It's mine.
14:23:57 <harovali> mauke: why "return 42 :: [Int]" does work, and "42 :: [Int]" does not ?
14:24:00 <FunctorSalad> bavardage: let's take the list monad... you can chain "a -> [b]" and "b -> [c]" together with (>=>); (>>>) is similar but it's a primitive of the arrow class
14:24:12 <Gracenotes> monochrom: you get into proc and -<?
14:24:21 <bavardage> riight
14:24:30 <mauke> harovali: because 42 is not a list of Ints
14:24:53 <mauke> harovali: and because 'return' can construct a list
14:24:56 <FunctorSalad> (btw that thing really ought to be called the "right fish operator")
14:25:01 <harovali> so ":: [Int]" operates on the lazy calculation of return 42 ?
14:25:17 <bavardage> monochrom: thanks
14:25:17 <monochrom> Gracenotes: Unfortunately I haven't.
14:25:25 <FunctorSalad> harovali: no, (::) is used only at compile time
14:25:26 <mauke> harovali: I don't see what laziness has to do with this
14:26:26 <harovali> mauke: return wouldn't "know" what to do with 42 if an "external" annotation didn't tell it .... ??
14:26:40 <mauke> basically, yes
14:26:50 <FunctorSalad> harovali: often it can be infered from the context
14:26:51 <harovali> mauke: i see
14:26:57 <FunctorSalad> > (return 42) !! 0
14:26:59 <lambdabot>   42
14:27:02 <mauke> in a real program you usually wouldn't find an explicit type because other operations constrain the type
14:27:16 <mauke> > length (return 42)
14:27:16 <harovali> mauke: thanks
14:27:17 <FunctorSalad> ( !! is list accessing by index)
14:27:17 <lambdabot>   1
14:27:22 <bavardage> monochrom: oooh tat's really nice
14:27:41 <harovali> that's nice !
14:27:43 <bavardage> monochrom: it's the first haskell thing I've read that made me go 'oooh I think I get something' on the first reading
14:28:49 <harovali> type coercion is the consequence of type annotation, say ?
14:29:08 <mauke> haskell doesn't really have coercion
14:29:15 <Gracenotes> types are not coerced in Haskell (at least not implicitly) :)
14:29:20 <monochrom> It is specialization rather than coercion. There is no coercion.
14:29:26 <harovali> i see
14:29:43 <monochrom> by specialization I mean removing polymorphism
14:29:55 <harovali> monochrom: thanks
14:30:40 <bavardage> btw, where is proc defined?
14:30:41 <wli> Everything could be specialized in the end anyway.
14:30:50 <bavardage> since in ghci :t proc still gives nothing
14:31:19 <dolio> proc is part of arrow syntax, isn't it?
14:31:20 <mauke> bavardage: it's syntax
14:31:21 <Gracenotes> proc is a keyword, like do or let, except a Haskell extension is required to use it
14:31:25 <bavardage> oh kk
14:31:31 <bavardage> extension?
14:31:38 <bavardage> do I have to load that explicitly?
14:31:39 <Gracenotes> *GHC
14:31:47 <bavardage> right
14:31:53 <dolio> proc x -> <arrow-stuff> or something.
14:32:10 <glguy> LANGUAGE Arrows
14:32:21 <harovali> many times reading the docs, i find the signature of a function I want to know, but no human description. Am I looking in  the correct docs (in haskell.org)
14:32:22 <glguy> so you can have proc x -> do a <- example -< that
14:32:23 <harovali> ?
14:32:23 <bavardage> http://pastebin.com/m6f64568a any idea why this goes NO U
14:32:38 <FunctorSalad> does anyone really find that proc makes things clearer rather than even more confusing?
14:32:41 <bavardage> "TV.hs:32:9: parse error on input `->'"
14:32:44 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
14:32:48 <FunctorSalad> admittedly I only tried it briefly
14:32:54 <mauke> harovali: do you have an example?
14:33:04 <Lemmih> bavardage: returnA.
14:33:07 <harovali> mauke: let's find one
14:33:14 <bavardage> right
14:33:29 <bavardage> Lemmih: makes no difference
14:33:45 <Lemmih> bavardage: Compiling with -XArrows?
14:33:52 <bavardage> Lemmih: not compiling at all
14:33:57 <bavardage> trying to load in ghci
14:34:03 <bavardage> can I not use proc?
14:34:07 <bavardage> what is proc equivalent to
14:34:17 <Lemmih> bavardage: GHCi compiles to bytecode. You still need -XArrows.
14:34:49 <ddarius> "proc" is like "do"
14:34:49 <bavardage> Lemmih: so I need to launch GHCi with -XArrows?
14:35:08 <bavardage> ddarius: so it's just pretty-syntax
14:35:11 <bavardage> I can do with out it?
14:35:19 <Lemmih> bavardage: Yes, or use :set -XArrows.
14:35:32 <dolio> bavardage: You use arrows by composing them together. proc introduces a first pseudo-variable that you can use with arrow syntax to write with arrows similarly to lambda calculus.
14:35:56 <harovali> mauke: here f.i. http://haskell.org/hoogle/?hoogle=foldr   most functions do have a descriptions. But some of them dont'n , and for sure there is a good reason that I can't see
14:35:58 <bavardage> right
14:36:41 <dolio> So proc x -> f -< x = f, which is similar to \x -> f x = f.
14:37:19 <dolio> Although technically that latter law doesn't hold in Haskell, because of seq.
14:37:56 <mauke> harovali: did you click on the links?
14:38:42 <harovali> mauke: maybe not :-p
14:38:50 <dolio> Along with do you can build bigger stuff, "proc x -> do y <- f -< x ; z <- g -< y ; h -< z" which is similar to "\x -> let y = f x ; z = g y in h z".
14:39:10 <kadaver> wher eis on?
14:39:21 <kadaver> @type on
14:39:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:39:23 <FunctorSalad> ddarius: not really... it has special "features" according to whether you have ArrowApply, ArrowAlternative (or what was it called?) etc.
14:39:23 <dolio> Data.Function
14:39:24 <kadaver> @src on
14:39:24 <lambdabot> (*) `on` f = \x y -> f x * f y
14:39:28 <dons> valid data constructor: Can'tInsert
14:39:36 <harovali> mauke: let's say http://haskell.org/hoogle/?hoogle=return . There, I see that return eithe is in Prelude or in control.Monad , right? but why is it that twice, and what does it mean ?
14:39:52 <FunctorSalad> ddarius: by that I'm saying it's way more confusing :)
14:39:55 <kadaver> I want to sort: [(String, [(String, Int)])]  in the Int, how?
14:40:18 <ddarius> FunctorSalad: It's like "do" insofar as it is a keyword that starts some special syntax and has no meaning itself.
14:40:19 <mauke> harovali: in this case it means that the Prelude re-exports return from Control.Monad
14:40:34 <mauke> it's the same function, just accessible from different modules
14:40:39 <harovali> mauke: is that fact indicated somehow ?
14:40:47 <mauke> apparently not
14:40:53 <bremner_> kadaver: Write an Ord instance
14:41:02 <harovali> mauke: do I have to care ?
14:41:05 <FunctorSalad> I think (-<<) was for using ArrowApply?
14:41:13 <mauke> harovali: not really
14:41:18 <harovali> mauke: thanks
14:41:24 <mauke> harovali: when there's a name conflict, the compiler will tell you
14:41:33 <harovali> mauke: interesting
14:41:49 <dolio> I thought ArrowApply just gave you "... ; f <- g -< x ; z <- f -< y ; ...".
14:42:26 <harovali> mauke: maybe the doubt could assault me, and make me wonder if I have to import Control.Monad to use return, instead of just using the Prelude
14:42:57 <Raevel> kadaver: you can use sortBy, as well
14:43:15 <mauke> harovali: you can always try it :-)
14:43:25 <harovali> mauke: true
14:43:33 <dolio> FunctorSalad: Ah, you're right. It says f is out of scope unless you use -<<.
14:43:52 <harovali> sorry for the naiveness of my questions , pals
14:45:03 <bremner_> Raevel: Good point.
14:45:14 <kadaver> so how do I sort a list of tuples ont he second argument?
14:46:01 <mauke> :t sortBy (comparing snd)
14:46:02 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
14:46:30 <Raevel> @hoogle comparing
14:46:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:46:31 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:47:38 <Raevel> i tried to use some liftM2 magic -.-
14:47:44 <kadaver> and how can I tell it to sort in reversed order?
14:47:55 <kadaver> directly rather than me reversing on the end?
14:48:13 <ddarius> kadaver: Why don't you think about it for a second.
14:48:14 <Raevel> negate the Ordering
14:48:23 <Raevel> oh i'm a spoiler!
14:48:53 <mauke> flip
14:48:56 <kadaver> well ic ant pas it a function like (>) or (<)
14:49:56 <monochrom> Lately I also found out that I don't know how to "negate the Ordering" either. I mean with minimal code.
14:50:43 <FunctorSalad> > (fmap . fmap) not (<) 2 1
14:50:44 <lambdabot>   True
14:50:47 <FunctorSalad> ;)
14:50:53 <vixey> > (>) 2 1
14:50:55 <lambdabot>   True
14:51:10 <Cale> > sortBy (flip compare) [1,45,2,5,6,8,2,7]
14:51:11 <lambdabot>   [45,8,7,6,5,2,2,1]
14:51:16 <FunctorSalad> > (not .) . (<) 2 1
14:51:17 <lambdabot>   Couldn't match expected type `a -> a1 -> Bool'
14:51:27 <monochrom> Oh darn, I'm stupid. Thanks Cale.
14:51:35 <FunctorSalad> > let foo = (not .) . (<) in 1 `foo` 2
14:51:36 <lambdabot>   False
14:51:45 <FunctorSalad> I guess that's one of the shortest
14:52:16 <Cale> also...
14:52:28 <Cale> > map (compare EQ) [LT, EQ, GT]
14:52:29 <lambdabot>   [GT,EQ,LT]
14:52:31 <FunctorSalad> it's confusing unless you take "deep postcomposition by a sequence of '. )'" as an idiom, I guess
14:52:39 <powerofPI> hi. anyone knows how to install glade with gtk2hs in macosx?
14:53:12 <dons> powerofPI: i think you have to get it from macports
14:53:20 <dons> make sure gtk is all installed, then build gtk2hs, and it will find the parts
14:53:48 <powerofPI> yeah, i found the package in macports, but the last time i installed ghc through macports, o broke it.
14:54:24 <powerofPI> isn't there an alterntive?
14:54:40 <gcollins> FunctorSalad: pointfree spits out that stuff all the time, I don't understand it
14:54:49 <Raevel> fwiw, i haven't had any problems with macports
14:55:28 <FunctorSalad> gcollins: it's if you have a function a1 -> a2 -> ... -> a27 -> b and want to "compose" it with b -> b2
14:56:15 <powerofPI> when installing gtk2hs through mac ports, mac ports tries to install ghc all over again.
14:56:15 <FunctorSalad> (you'd need to do ((((f.).).).). with 27 dots)
14:56:53 <gcollins> is there a simple rule there? i find i can understand specific instances if i crank through the type derivation
14:56:59 <powerofPI> do you know if it is possible not to do so?
14:57:17 <FunctorSalad> gcollins: just write down the intermediate types for n=3 or so :)
14:57:24 <FunctorSalad> (to make sense of it, I mean)
14:57:37 <FunctorSalad> oh sorry, you just said that you did that
14:57:54 <gcollins> i probably just need to study it more carefully
14:58:43 <FunctorSalad> I find general higher-order-.-salad cryptic too, but that special case is not so bad imho
14:59:21 <gcollins> I find I can work point-free up to a certain level but put it together with more than one level of partial application and i start to get a headache
14:59:34 <FunctorSalad> yep
14:59:52 <FunctorSalad> maybe tuple/&&&-style is clearer there
14:59:59 <FunctorSalad> (if it really has to be pointless)
15:00:05 <gcollins> I like that, it's a little more intuitive
15:00:47 <gcollins> Often I'll be lazy and just write with the points in
15:01:10 <gcollins> then if I look at it and say "is there a more legible way to write that?"
15:01:13 <powerofPI> i get this error when building glib2, a dependency of gtk2hs
15:01:13 <powerofPI> configure: error: in `/opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_devel_glib2/work/glib-2.18.3':
15:01:14 <powerofPI> configure: error: C compiler cannot create executables
15:01:14 <powerofPI> See `config.log' for more details.
15:01:25 <gcollins> i pass it through pointfree and see if it comes up with something simple
15:01:45 <FunctorSalad> gcollins: I think the aim of pointlessness should be to make things *easier* to read by omitting variables...
15:01:50 <gcollins> right
15:01:52 <powerofPI> seems to be a problem with gcc, but my gcc is working: at least i am able to comple C programs
15:02:11 <gcollins> "flip compare" is better than "\x y -> y `compare` x"
15:03:34 <FunctorSalad> gcollins: currently things are biased against the tuple style because one needs to littery 'uncurry' everywhere, though ;)
15:04:00 <FunctorSalad> maybe a lib containing all the common functions uncurried with a "u" suffix or so would help
15:04:34 <gcollins> that's true
15:04:45 <FunctorSalad> s/littery/litter
15:05:18 <wli> Argument permuting combinators might help, too.
15:05:47 <FunctorSalad> yeah
15:06:04 <harovali> i can't really understand flip . I think what confuses me is that it takes three arguments
15:06:21 <Raevel> :t flip
15:06:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:06:36 <FunctorSalad> @let cycleR f x y z = f z x y -- like that, wli?
15:06:37 <Cale> Or, it takes one ;)
15:06:37 <lambdabot>  Defined.
15:07:04 <Raevel> harovali: the type can also be written as (a -> b -> c) -> (b -> a -> c)
15:07:09 <Cale> It takes a function of two parameters, and gives a function of two parameters.
15:07:10 <FunctorSalad> harovali: it only really takes the function to flip; the other args are than fed into the flipped function
15:07:16 <wli> Sure.
15:07:47 <harovali> FunctorSalad: Raevel:   interesting
15:08:58 <harovali> is "takes its (first) two arguments in the reverse order of f. "  somewhat convoluted ?
15:09:14 <FunctorSalad> wli: while we're add it lets support the whole machinery of symmetric groups ;)
15:09:32 <Raevel> harovali: i didn't understand that :-)
15:09:35 <Baughn> , let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in vacuum fibs
15:09:43 <lunabot>  luna: internal error: ARR_WORDS object entered!
15:09:49 <harovali> Raevel: so I'm not that crazy  ..?
15:10:22 <Raevel> oh, now i get it
15:10:35 <wli> FunctorSalad: I guess we can pass polynomials as arguments and have it hand back Galois groups as results.
15:10:40 <harovali> Raevel: like f has an 'order' ?
15:10:41 <Raevel> (flip f) is a function with argument order reversed, compared to f
15:10:52 <pumpkin> *binary
15:11:06 <harovali> Raevel: that's it
15:11:36 <harovali> Raevel: that's definitely convoluted :-)
15:11:45 <Raevel> yeah...
15:11:58 <FunctorSalad> that permutation stuff is where diagrams would help
15:12:12 <harovali> FunctorSalad: yes
15:12:24 <vixey> types
15:12:39 <FunctorSalad> yes vixey?
15:13:02 <harovali> should   flip (+)    or something alike be fine ?  why not ?
15:13:05 <vixey> (a -> b -> c -> r) ->
15:13:06 <vixey> (b -> a -> c -> r)
15:13:27 <Raevel> harovali: sure
15:13:51 <FunctorSalad> isn't that (+) even in floating point land? ;)
15:14:15 <Baughn> @type flip (+1)
15:14:16 <lambdabot> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
15:14:44 <harovali> FunctorSalad: mmmh
15:14:46 <wli> harovali: That's not convoluted http://wli.pastebin.com/m2480ed5f is
15:15:09 <FunctorSalad> Baughn: that's tricky...
15:15:20 <Baughn> FunctorSalad: THat's a type error, really
15:15:25 <Baughn> Check out that num instance
15:15:35 <bavardage> what do I replace proc with
15:15:52 <harovali> wli: OMG
15:16:00 <FunctorSalad> I wouldn't call that an error Baughn ... spaces of functions into a structure often have that structure too
15:16:26 <FunctorSalad> (linear maps having pointwise addition etc)
15:16:53 <Baughn> Perhaps, but using flip like that still seems.. odd. :P
15:17:06 <gcollins> OMG is right, that's almost line noise!
15:17:12 <Raevel> time to write a function to check regex equivalence (should be fairly simple, i guess?)
15:17:30 <Baughn> @type flip succ
15:17:31 <lambdabot> forall b c. (Enum (b -> c)) => b -> (b -> c) -> c
15:18:10 <Baughn> ..of course. Never mind that such a thing could never have a reasonable enum.. hmm, perhaps it could
15:18:29 <monochrom> regex equivalence is very hard to program.
15:18:33 <pumpkin> ddarius: sorry, my connection died earlier... do you have a link to information on the ghc rewrite GSOC? I've found a few mailing list posts but nothing solid
15:18:35 <kadaver> i really wish haskell dropepd intendation syntax
15:18:46 <harovali> every time one uses  'do' , one is sort of invoking a monad ?
15:18:59 <Baughn> > do 2 :: Int
15:19:00 <lambdabot>   Couldn't match expected type `t t1' against inferred type `Int'
15:19:02 <Raevel> monochrom: is it? :-O i'm thinking, convert to dfa, minimize, check for isomorphism
15:19:21 <gcollins> harovali: invoking isn't the right word necessarily
15:19:23 * pumpkin invokes the Great Monad of IO
15:19:24 <Baughn> harovali: That would be a yes. Certainly non-trivial do invocations are rewritten to monad invocations, but as you can see..
15:19:39 <FunctorSalad> pumpkin: that was my interpretation as well
15:19:41 <harovali> hmmm
15:19:48 <pumpkin> :)
15:19:50 <Baughn> "do foo" = "foo, with an additional Monad constraint"
15:20:02 <harovali> Baughn: foo being ?
15:20:07 <Baughn> harovali: Anything.
15:20:09 <FunctorSalad> harovali: you're invoking the monad syntactic sugar, to be specific
15:20:09 <gcollins> well if foo weren't a monadic value you couldn't "do" it
15:20:12 <monochrom> I have not learned minimization of dfa. Do you know for a fact that every dfa has a unique minimization up to isomorphism?
15:20:14 <harovali> Baughn: a function ?
15:20:20 <Raevel> monochrom: yes
15:20:22 <mauke> > do sqrt
15:20:23 <lambdabot>       Overlapping instances for Show (a -> a)
15:20:24 <lambdabot>        arising from a use of `s...
15:20:24 <Baughn> harovali: Whatever. Any monadic value.
15:20:25 <harovali> FunctorSalad: ah
15:20:30 <mauke> > (do sqrt) 2
15:20:31 <lambdabot>   1.4142135623730951
15:20:39 <harovali> gcollins: i see
15:20:48 <FunctorSalad> harovali: but you were right that every do block is for a particular monad
15:20:57 <monochrom> What is minimization? I mean how is it defined? Smallest number of states?
15:20:59 <Baughn> > sqrt =<< [1..5]
15:21:00 <lambdabot>       No instance for (Floating [b])
15:21:00 <lambdabot>        arising from a use of `sqrt' at <...
15:21:11 <harovali> Baughn: what makes a value monadic , is something in the value or something in the monad ?
15:21:25 <harovali> FunctorSalad: nice
15:21:28 <gcollins> harovali: a value is monadic if its type has a Monad instance
15:21:33 <pumpkin> > return . sqrt =<< [1..5]
15:21:34 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979]
15:21:39 <Raevel> monochrom: i think so... but i'll check
15:21:44 <SubStack> :o
15:21:46 <dmhouse> A value with the type of the form M a is monadic if m is a member of the Monad class.
15:21:50 <dmhouse> *if M
15:21:54 * SubStack hasn't fully internalized the list monad yet
15:22:04 <harovali> gcollins: i get confused at the precise meaning of instance here
15:22:06 <pumpkin> > fmap sqrt [1..5]
15:22:08 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979]
15:22:14 <FunctorSalad> SubStack: it's like nondeterministic computation
15:22:33 <ddarius> pumpkin: http://blog.omega-prime.co.uk/?cat=20
15:22:35 <Baughn> harovali: A typeclass instance. An "instance Monad m where ..." statement in a .hs file somewhere..
15:22:36 <Raevel> monochrom: yes, smallest number of states :-)
15:22:47 <monochrom> If I have two finite state machines, they both have 10 states, and we can prove that 10 is the minimum, then there is proof that the two machines are isomorphic?
15:22:48 <gcollins> notice that "do [1,2,3]" is ok
15:22:56 <SubStack> it's still surprising to see a foldM generate the powerset
15:22:58 <pumpkin> ddarius: oh, the GHC plugins work! I see :) thanks
15:22:59 <harovali> Baughn: thanks
15:23:03 <SubStack> and awesome
15:23:04 <monochrom> Oops, I also mean: if the two machines do the same thing.
15:23:25 <Baughn> monochrom: No. There might be multiple machines that do the same thing that have 10 states..
15:23:25 <harovali> gcollins: me ?
15:23:29 <Raevel> monochrom: ah, then: yes
15:23:34 <gcollins> harovali: yeah
15:23:49 <harovali> gcollins: thanks
15:24:02 <vixey> > do [1,2,3]
15:24:03 <lambdabot>   [1,2,3]
15:24:10 <FunctorSalad> Baughn: a priori? my impression was that you can prove that they must be isomorphic
15:24:23 <harovali> gcollins: that implies [Int] has a monadic instance ?
15:24:31 <Baughn> FunctorSalad: Depends on how you define "do the same thing", I suppose
15:24:42 <FunctorSalad> Baughn: recognize the same language:)
15:24:43 <Raevel> monochrom: there is a proof using myhill-nerode relations in http://www.amazon.com/Automata-Computability-Undergraduate-Computer-Science/dp/0387949070/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1238883841&sr=8-1
15:24:47 <wli> The NFA/DFA minimization affair is called the "subset construction", because it essentially builds up from the powerset of NFA states.
15:24:52 <vixey> > don't [1,2,3]
15:24:54 <lambdabot>   []
15:25:16 <harovali> > :t don't
15:25:17 <lambdabot>   <no location info>: parse error on input `:'
15:25:17 <Baughn> FunctorSalad: Isn't that exactly the definition of isomorphism for FSMs, then?
15:25:24 <gcollins> harovali: no, in order for a type to have a Monad instance it needs to take a type parameter
15:25:42 <monochrom> "do the same thing" means recognize and accept exactly the same language.
15:25:44 <gcollins> harovali: think of writing [Int] as [] Int
15:25:52 <harovali> gcollins: so, how [1,2,3] gets a type parameter?
15:26:03 <harovali> gcollins: i see
15:26:03 <gcollins> "List" has a type constructor
15:26:09 <monochrom> For every string s, M0 accepts s iff M1 accepts s.
15:26:14 <FunctorSalad> Baughn: I guess you get another notion of isomorphism by the structural approach "map states to states, rules to rules, such that..."
15:26:17 <vixey> > don't (Just 3)
15:26:18 <lambdabot>   Nothing
15:26:20 <vixey> > do (Just 3)
15:26:21 <dmhouse> [1,2,3] has a monadic type [Int] (or [] Int). The monad is [].
15:26:21 <lambdabot>   Just 3
15:26:25 <gcollins> > :t >>=
15:26:26 <lambdabot>   <no location info>: parse error on input `:'
15:26:37 <harovali> dmhouse: thanks
15:26:37 <gcollins> > :t (>>=)
15:26:38 <lambdabot>   <no location info>: parse error on input `:'
15:26:42 <vixey> you guys are doing it wrong
15:26:44 <vixey> btw
15:26:46 <vixey> :t don't
15:26:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a
15:26:48 <Raevel> dfas accepting the same language, are unique up to isomorphism after minimization, would summarize i suppose :-)
15:26:54 <Baughn> FunctorSalad: Same thing. If there were two machines such that you couldn't do such a mapping, then they'd necessarily accept different languages
15:26:54 <wli> Oh, yeah, there are some state merging criteria.
15:27:14 <FunctorSalad> Baughn: *nod*
15:27:16 <Tsion> I am just learning and I was practicing creating instances by making this very weird Num Char instance (:P). http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2047#a2047 - I am wondering if there is a way to shorten the three lines where I use charMath
15:27:24 <harovali> 'forall' is some sort of what here ? (besides a logic universal)
15:28:04 <Baughn> harovali: Basically, it introduces a type variable with a limited scope, and may optionally specify its kind (the type of the type)
15:28:10 <gcollins> vixey: sorry, I've never used that thing
15:28:14 <gcollins> @type flip
15:28:15 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:28:15 <wli> It's kind of like the LR(1) vs. LALR(1) merging of states with identical cores.
15:28:25 <Baughn> harovali: Though in this case the "limited" scope is the whole type declaration, it does specify the kind of m
15:28:31 <FunctorSalad> harovali: it's redundant unless you do advanced type system stuff
15:28:32 <Raevel> Tsion: charMath = (chr . f) `on` ord -- i think
15:28:44 <harovali> i see, thanks
15:28:46 <FunctorSalad> (since variables are implicitly universally quantified)
15:28:54 <harovali> i se
15:28:58 <Baughn> harovali: m :: * -> * means m is a type constructor of one parameter
15:29:04 <Raevel> Tsion: perhaps that wasn't what you asked for!
15:29:06 <Tsion> Raevel: Oh cool
15:29:07 <wli> The transitions out of the states have to be consistent, and the transitions into them have to satisfy some criteria, too.
15:29:13 <harovali> Baughn: that one was hard for me, thanks
15:29:14 <Baughn> harovali: * is a concrete type, -> is, well, the same as in function type declarations
15:29:24 <Tsion> Raevel: But I was wondering about the three repetitive lines where I use the function
15:29:31 <bavardage> how do I split a string about a certain character
15:29:37 <bavardage> is there a builtin function?
15:29:47 <harovali> Baughn: being the parameter a type , right?
15:29:58 <FunctorSalad> bavardage: scan or its negation break
15:30:04 <FunctorSalad> @typ break
15:30:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:30:07 <Baughn> harovali: So Maybe has the kind * -> * (Maybe Int has *), Either has * -> * -> * (Either String Int), Either String has * -> * (partial application works), all Monad instances have * -> *, etc.
15:30:11 <bavardage> oh ty :D
15:30:14 <FunctorSalad> > break (=='a') foobaar
15:30:15 <lambdabot>   Not in scope: `foobaar'
15:30:19 <FunctorSalad> > break (=='a') "foobaar"
15:30:20 <lambdabot>   ("foob","aar")
15:30:40 <harovali> Baughn: i'll get into that
15:31:56 <Raevel> Tsion: i think that's as good as it gets since you can't define functions dynamically
15:32:00 <harovali> how can I write "return 2 :: Maybe" but right ?
15:32:04 <Tsion> Raevel: Okay
15:32:07 <Tsion> Raevel: Thanks
15:32:39 <glguy> return 2 :: Maybe Integer
15:32:47 <harovali> glguy: thanks
15:33:22 <wli> I can't remember how the state minimization goes.
15:34:11 <harovali> would () a good way of expressing the Nothing in Maybe ? why not ?
15:34:12 <Raevel> i have an implementation
15:34:24 <kadaver> C:\ghc\ghc-6.10.1\progs\Translation>ghc --make -O2 -main-is Translation.main Tra
15:34:24 <kadaver> nslation.hs
15:34:27 <harovali> like in    return () :: Maybe ....
15:34:28 <kadaver> isnt that correct?
15:34:28 <vixey> harovali: () doesn't have type Maybe a ...
15:34:33 <kadaver> becaus ei get undefined ref to main
15:34:36 <vixey> harovali: use mzero for that
15:34:44 <harovali> vixey: thanks
15:35:28 <Raevel> wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3308 :-)
15:38:16 <wli> Raevel: Looks like you're trying to merge all pairs.
15:39:14 <Raevel> wli: only if the MinimizationCell isn't checked for those states
15:39:34 <kadaver> meh im starting to swing bacl sometimes lately. some things are jsut so much easier expressed with some state
15:40:16 <harovali> > mzero
15:40:17 <lambdabot>       No instance for (Show (m a))
15:40:17 <lambdabot>        arising from a use of `show' at <in...
15:40:53 <Raevel> wli: but i haven't tested it very thoroughly! so you may be right
15:44:52 <disgrntld> I'm trying to emulate a finite state machine that accepts any binary string with "010" as a substring
15:45:02 <disgrntld> This is what I have so far: http://pastebin.com/m47ef1280
15:45:40 <disgrntld> Can anyone kindly help?
15:46:05 <bavardage> http://paste.pocoo.org/show/111066/ why does this not work as soon as I uncomment line 51
15:46:13 <bavardage> yet works if I uncomment 51 and comment 50
15:48:45 <Zao> Give getField a type?
15:49:13 <bavardage> kk
15:49:42 <Raevel> mergeStates was broken, it removed states it shouldn't have
15:49:51 <Raevel> s/states/transitions/
15:49:56 <bavardage> bleh how
15:50:00 <bavardage> Zao: you sure that'll help?
15:50:11 <Zao> No.
15:50:28 <pumpkin>     Could not deduce (Fractional a1) from the context ()
15:50:50 <Zao> What error do you get?
15:51:08 <mstr> how do I define a list with 2 and then 3,5,7... ?
15:51:11 <Raevel> now: let haskell do my homework for me
15:51:26 <mstr> I can't seem to find the correct google word right now
15:51:27 <bavardage> right I have done
15:51:28 <bavardage> Zao: no error
15:51:31 <bavardage> nothing changes
15:51:35 <Zao> mstr: By consing 2 onto the list [3,5,7...]
15:51:48 <Zao> @type (:)
15:51:49 <lambdabot> forall a. a -> [a] -> [a]
15:51:53 <mstr> 2 : [3,5..] ?
15:52:04 <vixey> > do 2 : [3,5..]
15:52:05 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:52:06 <vixey> > do'nt 2 : [3,5..]
15:52:07 <lambdabot>   Not in scope: `do'nt'
15:52:08 <bavardage> mstr: or just like [2,3,5..]
15:52:10 <pumpkin> ack, this type isn't being friendly to me
15:52:20 <bavardage> > take 100  [2,3,5..]
15:52:21 <lambdabot>   <no location info>: parse error on input `..'
15:52:31 <bavardage> > take 100  [,3,5..]
15:52:32 <lambdabot>   <no location info>: parse error on input `,'
15:52:33 <bavardage> > take 100  [1,3,5..]
15:52:34 <lambdabot>   <no location info>: parse error on input `..'
15:52:40 <Zao> bavardage: You can't do that.
15:52:41 <bavardage> :s
15:52:41 <kerlo> @type let don't x = do x in don't
15:52:43 <lambdabot> forall (t :: * -> *) t1. t t1 -> t t1
15:52:49 <bavardage> Zao: evidently
15:52:49 <kerlo> Really?
15:52:50 <bavardage> sooo
15:52:53 <Zao> It's "beginning, next, ..."
15:52:54 <bavardage> why does it break :(
15:53:14 <pumpkin> I believe I have encountered something insurmountable!
15:53:38 <Zao> bavardage: So what does it do if you have both visible?
15:53:40 <kerlo> > do ('a',3)
15:53:42 <lambdabot>   ('a',3)
15:53:49 <kerlo> > do ('a',3); ('b',4)
15:53:51 <lambdabot>       No instance for (Monad ((,) Char))
15:53:51 <lambdabot>        arising from a do statement a...
15:53:56 <bavardage> Zao: I just get an empty list returned
15:54:03 <Raevel> pumpkin: does it involve spelling "insurmountable"?
15:54:15 <kerlo> > do '6'
15:54:16 <lambdabot>   Couldn't match expected type `t t1' against inferred type `Char'
15:54:21 <kerlo> Wacky.
15:54:25 <mstr> ah, excellent
15:54:30 <pumpkin> Raevel: not quite :/
15:54:37 <pumpkin> Raevel: existential types though :/
15:54:54 <Raevel> ah those
15:54:59 <monochrom> bavardage: Suppose x is a <title> node. Then getField "title" will succeed on it, and getField "description" will fail on it. Altogether it is fail, so the node is ignored.
15:55:20 <bavardage> so how do I get multiple fields properly?
15:55:21 <Raevel> i struggle with them, also
15:56:39 <bavardage> monochrom: I was trying to just adapt an example
15:56:44 <bavardage> http://www.haskell.org/haskellwiki/HXT/Practical/Weather1
15:58:37 <disgrntld> Can anyone help me with http://pastebin.com/m47ef1280 ?
15:58:37 <disgrntld> f corresponds to the initial state, f0 corresponds to having seen "0", and f1 corresponds to having seen "1".. I'm almost positive the logic is correct, I think I have a syntax error
15:59:12 <disgrntld> ..I'm trying to return true if my argument has the substring "010"
15:59:16 <disgrntld> True*
16:00:08 <disgrntld> Can I nest "where" clauses?
16:00:15 <Raevel> disgrntld: the where clause only applies to the last definition of f
16:00:47 <disgrntld> ok.. should I just define f0 and f1 on their own?
16:01:07 <Zao> That or permute the order of line 2 and 3
16:01:20 <disgrntld> ohhhhh
16:01:28 <disgrntld> ok, let me try that
16:01:33 <Zao> Or move the where below line 2, of course.
16:01:44 <Raevel> Zao: so many options!
16:02:01 <disgrntld> ha, it works, thanks Raevel and Zao!
16:02:05 <Zao> All ways are good, except for the bad ones.
16:02:14 <Raevel> my mom always says that
16:02:20 <disgrntld> noted..   *walks away scratching head*
16:02:47 <Shurique> > "010" `isInfixOf` "100101"
16:02:48 <lambdabot>   True
16:03:21 <monochrom> bavardage: http://paste.pocoo.org/show/111068/
16:03:35 <disgrntld> thanks Shurique, I'm just studying for a test though, this isn't real life :)
16:03:53 <Shurique> hehe
16:03:58 <bavardage> monochrom: oh thankyou :D
16:04:04 <bavardage> so I just remove a line
16:04:11 <Shurique> it'd still be nicer to write a more general function :)
16:04:22 <disgrntld> touche
16:04:40 <monochrom> Move one level up (in the xml tree) and look for both title and description as children of that node.
16:05:32 <bavardage> oh kk :D
16:05:53 <bavardage> that actually makes sense :D
16:07:44 <dons> wli: so i'm leaning towards the hash trie mechanism
16:08:50 <kadaver> when you need some extra paraeter to track state do you switch to explicit recursion then or can you foldWithExtraUpdatableParameter? I tried to write such a function but it was hard to generalize it.
16:11:02 <kadaver> is there a simpe but complete(in the sense that it serves html and handles POST and GET requests) example of a HappStack app?
16:11:21 <pumpkin> I'm playing with http://squing.blogspot.com/2008/11/beautiful-folding.html and am trying to write a before function, but it seems hard given the "hidden" element type. I have before :: (forall a. a -> a) -> FoldU b c -> FoldU b c and before d (F f x c) = F (f . d) x c which compiles, but prevents me from doing anything typeclass-related with it
16:11:23 <kadaver> Im moving on to more complicated webapps and my own server is fine but lacks in features.
16:11:56 <disgrntld> ok, one more question: why do both http://pastebin.com/m52970f08 and http://pastebin.com/m635d11b3 work?
16:12:10 <mmorrow> gah, newer lua versions have a handwritten-in-C parser
16:12:46 <pumpkin> :o
16:12:53 <andun> disgrntld: yes, they are equivalent
16:13:16 <disgrntld> ok, the double-where is just more verbose?
16:13:44 <mmorrow> lua ditched yacc because "the handwritten parser is faster, and gives better error messages"
16:13:49 <pumpkin> anyone have any ideas about that?
16:14:42 <pumpkin> maybe using Heffalump's Suitable might help me
16:15:30 <mmorrow> pumpkin: what are you looking to do that "typeclass related"?
16:15:35 <mmorrow> *that's
16:15:39 <harovali> :t $$
16:15:40 <lambdabot> parse error on input `$$'
16:15:42 <andun> disgrntld: yes, but if you nest them you will be able to use variables defined at the "last level". like this: http://pastebin.com/m9a738cd
16:15:49 <harovali> :t $
16:15:50 <lambdabot> parse error on input `$'
16:15:55 <mmorrow> @type ($)
16:15:56 <lambdabot> forall a b. (a -> b) -> a -> b
16:16:04 <pumpkin> mmorrow: something like recip `before` sumF (as defined in that blog post)
16:16:14 <mmorrow> @type [id, ($)]
16:16:15 <lambdabot> forall a b. [(a -> b) -> a -> b]
16:16:16 <pumpkin> mmorrow: for "give me the sum of the reciprocals"
16:16:18 <andun> disgrntld: s/last/previous/
16:16:21 <harovali> @type ($$)
16:16:22 <lambdabot> Doc -> Doc -> Doc
16:16:30 <disgrntld> andun: awesome, thanks!
16:16:35 * mmorrow looks
16:17:06 <hsuh> mmorrow: 5.0 not exactly new :)
16:17:20 <andun> disgrntld: glad to help ;)
16:17:21 <pumpkin> mmorrow: the problem is that the element type is hidden by an existential
16:17:48 <mmorrow> ohh, wait. so the type of recip isn't (forall a. a -> a)
16:17:55 <mmorrow> @type recip
16:17:56 <lambdabot> forall a. (Fractional a) => a -> a
16:18:16 <pumpkin> yeah
16:18:18 <Gracenotes> > recip (Sum "banana")
16:18:19 <lambdabot>       No instance for (Fractional (Sum [Char]))
16:18:19 <lambdabot>        arising from a use of ...
16:18:21 <mmorrow> hsuh: heh
16:18:22 <pumpkin> that's what's breaking it :/
16:18:34 <pumpkin> mmorrow: do you think Suitable might help?
16:18:41 <mmorrow> what's Suitable?
16:19:30 <pumpkin> @hackage rmonad
16:19:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
16:19:58 <pumpkin> mmorrow: a neat strategy to get monads that allow typeclass constraints
16:20:26 <mmorrow> pumpkin: it seems like recip `before` sumF wouldn't even typecheck if if were (forall a. a -> a)
16:20:35 <mmorrow> before d (F f x c) = F (f . d) x c
16:20:45 <pumpkin> mmorrow: hmm
16:20:48 <mmorrow> f :: (a -> b -> a)
16:20:57 <mmorrow> d :: (foo -> foo)
16:21:23 <mmorrow> @type (undefined :: a -> b -> a) . (undefined :: a -> a)
16:21:24 <pumpkin> I want F ((+) . recip) x c coming out of it
16:21:24 <lambdabot> forall b a. a -> b -> a
16:21:30 <mmorrow> oh, n/m
16:21:35 <mmorrow> :)
16:22:22 <Gracenotes> hm.. *tries to implement polynomial multiplication with discrete Fourier transform*
16:22:28 <mmorrow> i dunno, it seems to me like that Fold datatype is just incompatible with typeclass constraints
16:22:44 <mmorrow> (wrt doing what you want to do)
16:23:09 <pumpkin> mmorrow: I'm gonna try to adapt Suitable to it, like RMonad did :P
16:23:12 <pumpkin> mmorrow: wish me luck :P
16:23:42 <mmorrow> pumpkin: gl!
16:25:20 <mmorrow> pumpkin: (it seems to me like you'd want to change that datatype altogether rather than do convoluted things to make stuff work with it)
16:25:27 <pumpkin> mmorrow: how so?
16:25:45 <mmorrow> like, what's the point of even having the a forall
16:25:47 <mmorrow> 'ed
16:25:48 <mmorrow> ?
16:26:16 <pumpkin> hmm
16:26:39 <mmorrow> and also, why bother putting that 'c' in there
16:26:41 <pumpkin> it's saying that the accumulator type is irrelevant I think?
16:26:59 <mmorrow> but that's your result..
16:27:16 <pumpkin> hmm, true
16:27:30 <mmorrow> modulo that (a -> c)
16:27:32 <ddarius> Gracenotes: Just implement convolution and then you're done.
16:27:42 <pumpkin> so I wonder why he chose to add that little post-processing step there
16:27:58 <mmorrow> pumpkin: i guess what he's trying to go for is completely hidden internal type that's used to arrive at your answer.
16:28:04 <pumpkin> "Now that we have the post-processor, we don't need to look at the accumulator directly, so we make it existential."
16:28:14 <mmorrow> in which case what you're trying to do with recip goes against the whole idea
16:28:22 <pumpkin> yeah
16:28:26 <pumpkin> I could add a preprocessor too ;)
16:28:29 <Gracenotes> ddarius: well, I'd like to use a FFT for that
16:28:40 <mmorrow> so i guess if you want recip, change the datatype, but if you want the datatype, don't use recip :)
16:28:49 <pumpkin> hmm
16:28:50 <ddarius> Gracenotes: Yes, use the FFT to implement the convolution.
16:28:53 <pumpkin> well I want the general idea
16:28:56 <Gracenotes> *nods*
16:28:57 <pumpkin> I don't care about the specific datatype
16:29:05 <ddarius> Gracenotes: If you already have an FFT and an inverse FFT then you are pretty much done.
16:29:05 <mmorrow> pumpkin: which idea?
16:29:11 <pumpkin> mmorrow: combinable folds
16:29:16 <mmorrow> ahh
16:29:32 <Gracenotes> mm.
16:30:01 <tomh> quickcheck cant test IO Bool ? :(
16:30:05 <pumpkin> mmorrow: so if I wanted to compute 5 different accumulated measures over a single list
16:30:18 <pumpkin> mmorrow: I could either write a (,,,,)-accumulating function
16:30:28 <pumpkin> mmorrow: or use this to combine 5 separate folds
16:30:31 <pumpkin> so they iterate the list once
16:30:35 <ddarius> convolve xs ys = inverseFFT (zipWith (*) (fft xs) (fft ys))
16:30:47 <mmorrow> Gracenotes: there's a pretty compact fft in pure-fft if you want to peek at some code for a start
16:30:50 <kadaver> is there a simpe but complete(in the sense that it serves html and handles POST and GET requests) example of a HappStack app?
16:31:03 <mmorrow> Gracenotes: it you were to use STUArrays, it could scream
16:31:09 <Gracenotes> oh, nice. I'll take a look at least at the type signatures
16:31:14 <Gracenotes> @hackage pure-fft
16:31:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pure-fft
16:31:21 <Gracenotes> mmorrow: from pleasure or from pain?
16:31:23 <mmorrow> [Complex Double] -> [Complex Double]
16:31:29 <Nafai> Is there a web page for Scion?
16:31:31 <mmorrow> Gracenotes: from speed baby!!
16:31:34 <Gracenotes> mmorrow: yeah. That makes sense.
16:31:35 <mmorrow> :)
16:32:08 <mmorrow> pumpkin: hmm. i usually go with the (,,..,,) myself
16:32:14 <MyCatVerbs> Bah, unboxed arrays. Can't use lazy dynamic programming that way.
16:32:31 <mmorrow> MyCatVerbs: stick them in a list then :)
16:32:39 <mmorrow> a la ByteString.Lazy
16:32:46 <Gracenotes> indeed. You can do strict dynamic programming with them though... uh...
16:33:08 <pumpkin> mmorrow: well, the idea is that you should be able to write elegant but fast code :P in his example, he shows what a "fast mean" looks like, and what the naive mean looks like. It'd be nice to use this technique to write a mean that looks intuitive but is fast too
16:33:31 <MyCatVerbs> mmorrow: I like being able to define e.g. Levenshtein distance just in terms of the lookup and min operations.
16:33:46 <mmorrow> pumpkin: have you seen the mean with `par`? compile with -threaded and it blows any other mean (over lists) away
16:33:48 <Gracenotes> oh nice. YouTube has a 'lights down' feature now. uh. :x
16:34:51 <pumpkin> mmorrow: I don't trust it to say fold1 `par` fold2 `par` fold3 `par` fold4 and to traverse the list once... it not only affects the speed but the memory usage, so I doubt it's simply a case of RTS change?
16:35:43 <mmorrow> pumpkin: the `par` is used to get the length and the sum in parallel
16:35:45 <mmorrow> brb
16:36:11 <kiris> I finally got my indentation-based parsec parser to work for simple expressions!!
16:36:13 <pumpkin> mmorrow: well yeah, parallel in the parallel processing sense, but nothing there says it'll only traverse the list once does it?
16:36:13 * kiris does the mash
16:36:23 <kiris> I'm doing the monster mash
16:36:57 <pumpkin> mmorrow: if it does, it feels like magic, and I'd still like to do it myself :P because I'm not sure how general their technique is
16:37:01 <kiris> \o\
16:38:40 <FunctorSalad> mmorrow: mean with par?
16:38:59 <FunctorSalad> avoiding the custom fold?
16:39:18 <pumpkin> it feels like voodoo to me if it fuses the folds
16:40:04 <pumpkin> my understanding was that it just sparked it off
16:40:09 <mmorrow> check out the different times in README http://code.haskell.org/~morrow/mean/
16:40:14 <FunctorSalad> (btw how about just keeping n from whereever you got the data? ;))
16:40:26 <kiris>   /o/
16:40:28 <mmorrow> mean xs = let x = foldl' (+) 0 xs
16:40:28 <mmorrow>               y = length xs
16:40:28 <mmorrow>           in x `par` y `pseq` x / fromIntegral y
16:40:28 <pumpkin> FunctorSalad: mean is a toy example :P
16:40:38 <FunctorSalad> pumpkin: yeah
16:40:41 <FunctorSalad> I realise ;)
16:41:00 <mmorrow> code w/out `par`:
16:41:03 <mmorrow> real    0m7.336s
16:41:05 <mmorrow> w/ par:
16:41:09 <mmorrow> real    0m1.297s
16:41:10 <pumpkin> it's like the comments on the blog post I linked to :P the dudes saying ZOMG mean [1..1000] === 1001 / 2
16:41:15 <pumpkin> mmorrow: -N1?
16:41:19 <mmorrow> -N2
16:41:35 <pumpkin> if it's significantly faster on -N1, I'll be sold
16:41:37 <FunctorSalad> pumpkin: ZOMG!
16:41:43 <mmorrow> (the w/out par is compiled w/out -threaded, because it's actually slower with -threaded and no `par`)
16:42:04 <mmorrow> pumpkin: it can't be faster with -N1 though :)
16:42:11 <pumpkin> mmorrow: it could if it's doing what I said
16:42:19 <pumpkin> mmorrow: fusing the folds
16:42:37 <FunctorSalad> mmorrow: that looks like it just does two passes in parallel
16:42:48 <pumpkin> mmorrow: it means that it would have to keep the entire list around
16:42:56 <FunctorSalad> so it'd be faster in clock time but use both cores
16:42:58 <mmorrow> FunctorSalad: exactly
16:43:08 <mmorrow> that's the whole point
16:43:10 <FunctorSalad> wouldn't call that "more efficient" :)
16:43:11 <pumpkin> mmorrow: fusing the folds would allow you to traverse the list once, so you can dump the old stuff
16:43:32 <pumpkin> and it would be faster in cpu time too
16:43:35 <mmorrow> FunctorSalad: ok, call it whatever. the punchline is 7 seconds to 1 second :)
16:43:39 <kiris> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3309#a3309 <- ^___ ^"
16:43:57 <EvilTerran> surely traversing the list in parallel allows it to be GCd (if necessary) as you go along?
16:44:03 <FunctorSalad> pumpkin: why does it need to keep the lists around?
16:44:05 <mmorrow> pumpkin: that'd be cool to fuse folds
16:44:13 <dons> EvilTerran: that's true.
16:44:14 <pumpkin> mmorrow: that's what the point of that post is :P
16:44:27 <pumpkin> EvilTerran: you're right, but fusing folds is still handy :P
16:44:46 <EvilTerran> and, if either one got ahead, it'd have to do the evaluation, so the other would catch up
16:45:06 <EvilTerran> so both threads would probably stay roughly together in the list
16:47:56 <mmorrow> pumpkin: also, you could "fuse" folds like :: [a -> b -> a] -> a -> [b] -> [a]
16:49:45 <pumpkin> mmorrow: hmm
16:49:48 <mmorrow> \fs a bs -> foldl' (\as b -> zipWith (\f a -> f a b) fs as) (repeat a) bs)
16:49:59 <mmorrow> s/\)$//
16:50:39 <pumpkin> the idea is that these could all be written succinctly as combinations of folds that go over a single stream/array, but that's slow so you get the scarier functions: http://hackage.haskell.org/packages/archive/statistics-fusion/0.2/doc/html/src/Math-Statistics-Fusion.html
16:54:05 <mmorrow> pumpkin: this seems like the kinda thing that making a GADT algebra would be good for
16:54:13 <pumpkin> how so?
16:54:36 <mmorrow> because your can give each constructor the type it will eventually get turned into, rather than the type of its contents
16:54:43 <pumpkin> hmm
16:55:01 <mmorrow> so you can put off combining stuff until you "eval" :: GADT a -> a
16:55:39 <mmorrow> this worked nicely for doing something somewhat analogous with threads
16:55:55 <pumpkin> hmm interesting, I'll look into it
16:56:07 <pumpkin> I'd really like to be able to make the rewrite rule that blog post says won't work, working
16:56:25 <pumpkin> then I could just write sum xs / length xs and have it traverse the list once :P
16:56:29 <pumpkin> well, sort of
16:56:51 <pumpkin> it seems like something more suited to in-compiler optimization
16:56:54 <mmorrow> oh yeah, you'd need something like rewrite rules too i think
16:57:01 <mmorrow> yeah, exactly
16:57:23 <pumpkin> but given that I can't modify GHC easily
16:57:25 <mmorrow> that's why i'm not sure how far you can get at the language level (rewrite rules aside)
16:57:37 <pumpkin> yeah :/
16:57:43 <pumpkin> but nice combinators would be a good start
16:57:59 <pumpkin> and that blog post goes a decent way
16:58:39 <mmorrow> this is the GADT thingy whose general strategy i think might be useful for the folds http://moonpatio.com/repos/proc/src/Control/Concurrent/Proc.hs
16:59:03 <mmorrow> like  List :: [Proc a b] -> Proc [a] [b]
16:59:06 <Gracenotes> mmorrow: hm. How'd you get a Complex Double into an STUArray?
16:59:08 <mmorrow> s/Proc/Fold/
16:59:24 <pumpkin> mmorrow: hmm
16:59:54 <mmorrow> Gracenotes: i guess you'd have to store (a + bi) as [...,a,b,....] or something
17:00:23 <ddarius> It'd probably be better to use two separate arrays.
17:00:27 <Gracenotes> hm. you do have to exp that though
17:00:45 <dons> Gracenotes: you define a UArray instance for pairs, and then store them
17:00:47 <mmorrow> yeah, two separates might be nice too
17:00:50 <dons> uvector might be a better solution here
17:01:02 <dons> since it is an STUArray deep down already with Complex instances
17:01:14 <mmorrow> Gracenotes: you should look at the various C fft implems floating around online for an ideas on rep
17:01:46 <pumpkin> yeah, the UArr Complex is nice
17:02:01 <Gracenotes> well actually, exp'ing a complex number should be quite easy with Euler's formula
17:02:16 <ddarius> It is quite easy.
17:02:33 <bremner> but not with a slide-rule, I learned yesterday
17:03:02 <ddarius> bremner: Attach a protractor to your slide-rule.
17:03:08 <harovali> what can be wrong here?
17:03:09 <harovali> interact (\x ->  return "b" :: IO String)
17:03:21 <Gracenotes> interact is String -> String
17:03:34 <pumpkin> mmorrow: it seems like the post-processing step in that blog allows the combination
17:03:36 <Gracenotes> there you have returned IO String
17:03:45 <pumpkin> mmorrow: oh actually, I think I see how a GADT works now
17:04:06 <pumpkin> I mean in this case :P
17:04:33 <ddarius> @hoogle cis
17:04:33 <lambdabot> Data.Complex cis :: RealFloat a => a -> Complex a
17:04:33 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
17:04:33 <lambdabot> Control.Exception LossOfPrecision :: ArithException
17:06:08 <mmorrow> pumpkin: you get to give it the type it'll *eventually become* rather than the type it *is*, and then your "eval" function makes it that eventuality
17:06:11 <harovali> can  anyone point to a haskell tutorial that combines a story and cartoons with haskell teaching? (i can't remember which it was, and can't find it now)
17:06:17 <pumpkin> mmorrow: I'll play with it
17:06:23 <pumpkin> and see if I can get anything nice out of it :P
17:07:03 <Gracenotes> @where lyah
17:07:03 <lambdabot> www.learnyouahaskell.com
17:07:25 <Gracenotes> ^ harovali: is this it? there there are pretty pictures, although not much of a plot
17:07:34 <Gracenotes> other than you learning Haskell
17:07:56 <harovali> yes ! thanks
17:08:28 <vininim> uh, what's wrong with BSD3 licensing? (I mean, beside it not being GPL ;) )
17:08:48 <vininim> context: grapefruit hackaton
17:08:49 <Axman6> GPL--
17:09:14 <MyCatVerbs> vininim: there's one tiny issue, in that the third clause is kind of redundant and doesn't make much sense, so you might as well use BSD2 rather than BSD3.
17:10:39 <MyCatVerbs> vininim: apparently, anyway. I don't know either way. Still, the genuine issue people have with an author using a more permissive license than they would is that any patches that they submit will end up under the too-permissive license too (or otherwise not be able to be integrated with mainline releases).
17:15:16 <pumpkin> mmorrow: actually, I'm not sure a GADT is good here
17:17:38 <pumpkin> mmorrow: it seems like matching the various constructors would have a runtime cost
17:22:40 <pumpkin> ah well, I'll keep going down this route and see where it takes me
17:28:17 <kornai> newbie question: is there a formatted read in Haskell? Let's say I have a file with two lines that go "a b\n" and "c d\n" and I want a matrix whode (1,1) element is a, (1,2) is b, (2,1) is c (2,2) is d. How do I go about this?
17:31:22 <mmorrow> pumpkin: hmm. i think any cost in matching the cons would be pretty small compared to the cost of the fold(s)
17:31:46 <pumpkin> mmorrow: I'm running through it and we can see :)
17:31:54 <mmorrow> pumpkin: cool :)
17:32:03 <mmorrow> i'm curious how this'll turn out
17:33:09 <kadaver> why is there no: safeReadFile :: FilePath -> Maybe String ?
17:33:42 <pumpkin> kadaver: IO? :P
17:33:49 <pumpkin> sounds very unsafe otherwise
17:34:27 <kadaver> why is there no: safeReadFile :: FilePath -> IO Maybe String ?
17:34:48 <dons> it's easy to build from other pieces?
17:34:58 <kadaver> but annoying to ahve to do each time?
17:35:01 <EvilTerran> ?kind IO Maybe String
17:35:01 <lambdabot>     Kind error: `IO' is applied to too many type arguments
17:35:04 <dons> well, upload a safe-io lib
17:35:09 <dons> that would be quite useful
17:35:20 <kadaver> maybeIO :: IO a -> IO (Maybe a)
17:35:20 <kadaver> maybeIO action = do
17:35:20 <kadaver>   a <- E.catch (action >>= \s -> return $ Just s)
17:35:20 <kadaver>        (\exc -> case E.fromException exc of Just (exc :: E.IOException) -> return Nothing)
17:35:20 <kadaver>   return a
17:36:37 <dons> yeah
17:36:49 <kadaver> dons: ok what else would be good except for safe ReadFile?
17:38:45 <ddarius> :t try . readFile
17:38:46 <lambdabot> Not in scope: `try'
17:38:54 <ddarius> :t Control.Exception.try . readFile
17:38:54 <lambdabot> FilePath -> IO (Either GHC.IOBase.Exception String)
17:39:01 <pumpkin> lol
17:39:12 <skorpan> i've dealt with haskell for five years and i have yet to bother about unsafe stuff
17:39:51 <mmorrow> :t (fmap (either (const Nothing) Just)) . Control.Exception.try . readFile
17:39:52 <lambdabot> FilePath -> IO (Maybe String)
17:40:15 <ddarius> The only problem being that readFile is lazy and doesn't really throw all exceptions.
17:40:31 <dons> kadaver: anything in System.IO that throws an exception, that you want to strictify
17:40:34 <kornai> newbie question (I'm not sure it went out last time):  is there a formatted read in Haskell? Let's say I have a file with two lines that go "a b\n" and "c d\n" and I want a matrix whose (1,1) element is a, (1,2) is b, (2,1) is c, (2,2) is d. How do I go about this?
17:45:04 <jml> I'm looking at Text.Html -- what's the deal with all the uppercase tags?
17:45:47 <Gracenotes> in the HTML standard, isn't it?
17:45:50 * Gracenotes forgets
17:46:00 <BMeph|breakfast> jml: My guess is that they're data constructors. :)
17:46:39 <jml> what I mean is, can I get it to generate html 4 or xhtml or something similar?
17:46:52 <xoclipse> kadaver: f <- readFile "abc.txt" `catch` (\e -> return $ "Error: " ++ (show (e :: IOException)))
17:47:06 <jeffwheeler> Where is the := operator defined? Hoogle doesn't seem to find it, and Graphics.UI.Gtk doesn't seem to export it.
17:47:07 <xoclipse> kadaver: is that wha you needed?
17:52:24 <jml> apparently not!
17:54:13 <jeffwheeler> Hmm, odd. Doing `import Graphics.UI.Gtk ((:=))` failed, telling me that it didn't export that, but just `import Graphics.UI.Gtk` worked fine.
17:54:57 <dolio> Are you sure it's := and not =:? := is a constructor.
17:55:23 <jeffwheeler> I'm definitely using :=, although I assumed it was an infix operator.
17:55:29 <skorpan> jml: it seems to have been last updated in 2001, so don't count on it
17:55:35 <jeffwheeler> I suppose it isn't?
17:55:36 <jml> yeah.
17:55:55 <dolio> Importing := might require giving the type name it belongs to.
17:56:09 <jml> it's a bit of a shame though, my hunch is the web will really take off.
17:56:10 <dolio> import Foo (Foo((:=)))
17:56:16 <jeffwheeler> Oh, I see; I suppose just importing unqualified works.
17:56:27 <skorpan> jml: there are lots of web stuff for haskell, just look for it on hackage
18:00:12 <jml> maybe haxml is what I want
18:07:54 <mmorrow> jml: um, have you seen the xhtml package?
18:08:13 <mmorrow> import Text.XHtml...
18:08:52 <jml> mmorrow: no I hadn't
18:09:17 <mmorrow> it comes with ghc
18:09:24 <jml> mmorrow: *that's* what I want, thanks.
18:09:30 <mmorrow> :)
18:10:13 <jml> (although for this app, 'wrapInTag tag text = concat ["<", tag, ">", text, "</", tag, ">\n"]' is 80% of what I need)
18:10:16 <mmorrow> (well, maybe it's in the "ghc-extralibs", but i always install that..)
18:12:59 <kadaver> xoclipse: yeah it works thanks
18:13:27 <xoclipse> kadaver: i find that returning a string might not be as useful though
18:13:53 <xoclipse> returning an Either might be better
18:14:34 <Gollum> Are there many black Haskell developers?
18:14:55 <xoclipse> did he really say that?
18:14:56 <xoclipse> lol
18:15:28 <inimino> wtf
18:15:59 <jml> I've got some code that almost does what I want -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3311#a3311
18:16:13 <jml> I would like to make it nicer.
18:16:49 <pumpkin> ok, I do not like these GADTs in this situation
18:17:40 <mmorrow> pumpkin: where is the fail?
18:18:00 <pumpkin> maybe I'm doing it wrong
18:18:43 <pumpkin> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3312#a3312 does that look reasonable?
18:18:57 <BMeph> jml: I would suggest, that as long as you're making it nicer, you not use the names of already-declared functions, such as "join" and "lines". Otherwise, you risk being misunderstood. And laughed at. :)
18:19:20 <jml> oh yes, quite.
18:20:02 <mmorrow> pumpkin: hmm, lemme think
18:20:35 <mmorrow> pumpkin: what was that url again?
18:20:46 <mmorrow> err, actually i can just scroll up
18:20:47 <pumpkin> the original post?
18:20:49 <mmorrow> xchat++
18:20:51 <pumpkin> http://squing.blogspot.com/2008/11/beautiful-folding.html
18:20:59 <mmorrow> you beat me :)
18:21:01 <pumpkin> :)
18:23:49 <jml> maybe I should just use splitRegex
18:24:17 <pumpkin> mmorrow: the problem is that with those types, the pattern combinations for Both are really painful
18:24:44 <pumpkin> and I'm not convinced that the GADT is buying me anything over the combinator functions
18:25:16 <chessguy> any blog entry that starts with this has got to be awesome: "If you're not a Haskeller, and were thus hoping to learn how to fold a shirt beautifully, I'm afraid you're out of luck. I don't know either."
18:25:40 <pumpkin> that blog post makes me excited
18:25:47 <pumpkin> but no one else seems to find it particularly exciting :P
18:25:58 <pumpkin> if only taejo were here
18:31:31 <dons> chessguy: hehe
18:31:53 <BMeph> > const succ () 4
18:31:54 <lambdabot>   5
18:35:43 <pumpkin> mmorrow: any ideas? I'm tempted to move back to a regular data type with more explicit type parameters
18:36:29 <chessguy> > (const succ) () 4
18:36:30 <lambdabot>   5
18:37:47 <BMeph> pumpkin: So, is 'after f (Fold mix n proc)' just supposed to apply f to the folded result, but before 'proc' gets done?
18:38:24 <pumpkin> BMeph: no, after is incorporated into the proc (in the blog version)
18:39:01 <pumpkin> the datatype described in the blog uses the third argument to the constructor as the post-processor
18:39:20 <Gollum> Tired of N*I*G*G*E*R*S and their general monkeyshines?  Join the alliance of Asians, Native Americans, Jews, Whites, and non-Negroid hispanics in the epic battle of Human vs Negro!  Join Chimp Out!  http://www.chimpout.com/forum   Please help us turn the tide against the shitskin menace.  Civilization depends on you!
18:39:24 <pumpkin> @where ops
18:39:25 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
18:39:32 <BMeph> Er, s/after/Before/
18:39:46 --- mode: ChanServ set +o mauke
18:39:47 <pumpkin> BMeph: it should be equivalent to fold . map
18:39:57 <pumpkin> BMeph: so the before should be applied to each element
18:41:38 <BMeph> pumpkin: but each element is an 'a', not an 'e'. You don't get types of 'e' until after they get folded.
18:41:47 --- mode: mauke set -o mauke
18:42:09 <pumpkin> BMeph: oh yeah, the Before in my GADT sucks
18:42:14 <pumpkin> BMeph: but in general
18:42:49 <BMeph> pumpkin: I figured out why folks aren't that excited about it - except for the "do this function after you process it", it's just encoding an algebra.
18:43:04 <pumpkin> BMeph: yeah, but a useful one
18:43:10 <pumpkin> BMeph: a potentially useful one, at least
18:43:16 <pumpkin> ugly folds are ugly
18:43:25 <pumpkin> fold combinators = good
18:43:52 <BMeph> mmorrow: Do you have a TH function yet that builds an algebra from your data description? :)
18:44:24 * BMeph shrugs
18:44:35 <pumpkin> http://hackage.haskell.org/packages/archive/statistics-fusion/0.2/doc/html/src/Math-Statistics-Fusion.html#mean for example
18:45:06 <pumpkin> it seems like one of the objectives is to write fast but elegant code
18:45:40 <pumpkin> elegant: mean xs = sum xs / genericLength xs
18:46:12 <pumpkin> not elegant: mean xs = foldl bigassFoldFunction fancyAccum xs
18:47:41 <pumpkin> we shouldn't have to merge accumulators by hand, basically :P
18:48:50 <Gracenotes> aww. :( would you like a cookie for your troubles?
18:48:55 <Gracenotes> *gives cookie*
18:48:57 * edwardk finishes mangling data.bitset into a form even its mother wouldn't recognize
18:49:43 <pumpkin> Gracenotes: merging fold accumulators is a pattern... if we have the facilities to abstract it away, I don't see why we shouldn't
18:50:40 <edwardk> pumpkin: thanks for reminding me that i don't have statistical reducers ;)
18:50:43 <Gracenotes> well, you do have to have the accumulators to begin with
18:50:57 <Gracenotes> sum/length aren't an accumulators
18:51:01 <Gracenotes> -an
18:51:55 <kornai> privmsg mauke Is there a better place to ask newbie questions?
18:52:10 <Gracenotes> newtype Accum a b = Accum {runAccum :: a -> b -> a}, maybe :\
18:53:11 <pumpkin> Gracenotes: no, but they use accumulators
18:53:53 <pumpkin> I don't really need an accumulator type
18:54:05 <pumpkin> but we can break the fold itself up
18:54:15 <pumpkin> so we can pull the accumulator out
18:54:30 <Gracenotes> maybe if the compiler sees it, yes
18:54:55 <pumpkin> http://squing.blogspot.com/2008/11/beautiful-folding.html
18:54:57 <Gracenotes> f (foldl g z1 xs) (foldl h z2 xs)
18:55:21 <BMeph> pumpkin: I'm confused....
18:55:26 <pumpkin> BMeph: ?
18:55:28 <pumpkin> about what?
18:56:30 <BMeph> pumpkin: Specifically, though, how does After work?
18:56:42 <pumpkin> BMeph: you should ignore my GADT crap :P
18:57:00 <pumpkin> I don't like it
18:57:59 <BMeph> pumpkin: Oh, wait, you've changed your version of 'Fold" from Max's. Okay, that explains things.
18:58:20 <pumpkin> BMeph: yeah, but I'm probably going to move back... that GADT was just an experiment that isn't working
18:58:20 <kornai> ls
19:00:25 <pumpkin> BMeph: I'm just trying to figure out how to make it easier to work with
19:00:35 <pumpkin> given that the crazy rewrite rule doesn't work
19:14:12 <blip> splitInterval n [] = []
19:14:12 <blip> splitInterval n xs = let (a,b) = splitAt n xs in a : splitInterval n b
19:14:22 <blip> that cant be turned into a listcomprehsnion right?
19:15:01 <Axman6> don't think so
19:18:46 <Axman6> > [x| xs <- [[1],[2],[3,4,5]], x <- xs]
19:18:47 <lambdabot>   [1,2,3,4,5]
19:20:16 <jeffwheeler> > concat [[1],[2],[3,4,5]] -- Yes, I missed the relevant discussion
19:20:18 <lambdabot>   [1,2,3,4,5]
19:20:48 <Axman6> there was none, just wasn't sure it'd do what i thought it would :)
19:21:24 <monochrom> concat is related to list comprehension, you have just discovered.
19:21:45 <Axman6> indeed
19:28:08 <mmorrow> pumpkin: i now realize why he went for the forall'ed accumulator
19:28:16 <mmorrow> this is what i have:
19:28:19 <pumpkin> it's a pain to deal with if you don't have it
19:28:19 * mmorrow pastes
19:28:37 <pumpkin> I removed the forall and I can do before easily now, but it's getting ugly
19:28:38 <mmorrow> yeah, the GADTs puke with
19:28:39 <mmorrow> Couldn't match expected type `b' against inferred type `b1'
19:28:45 <mmorrow> stuffery
19:28:50 <pumpkin> yeah
19:29:32 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2048#a2048
19:29:57 <pumpkin> ooh, your forall is for both :o
19:30:03 <mmorrow> pumpkin: so it needs to be split, so you can build your fold without caring what you're gonna be folding over
19:30:34 <mmorrow> pumpkin: ah, yeah i need an additional forall over the accumulator in the "Itee" i'm starting to think
19:31:01 <mmorrow> or something along those lines
19:31:01 <pumpkin> I don't get how you'd use your Fold type
19:31:20 <pumpkin> it seems to only abstract over the type you're folding over
19:31:45 <mmorrow> ghci> :t fold list (Itee (+)) 0
19:31:45 <mmorrow> fold list (Itee (+)) 0 :: forall b. (Num b) => [b] -> b
19:31:54 <mmorrow> pumpkin: exactly, that's what i'm going for
19:33:09 <mmorrow> and
19:33:12 <mmorrow> ghci> :t fold intmap (Itee (+)) 0
19:33:12 <mmorrow> fold intmap (Itee (+)) 0 :: forall b. (Num b) => IntMap b -> b
19:33:18 <mmorrow> where
19:33:19 <mmorrow> intmap = Fold (IM.fold . flip)
19:33:21 <mmorrow> etc
19:33:44 <pumpkin> ah, you're using the Fold datatype to abstract over the actual folders, not the folds
19:33:50 <mmorrow> doing the case in fold for (:>>>) is giving me hell though
19:34:21 <pumpkin> yeah, all the cases for the GADT is what made me give up
19:34:27 <BMeph> What we need is a rewrite rule that says: "foldl f z xs <#> foldl g w xs ==> uncurry (<#>) (foldl <f, g> (z, w) xs)"
19:34:33 <mmorrow> pumpkin: yeah, so "Fold" gives you the type-specific fold, and "Itee" gives the actual folding function
19:34:48 <mmorrow> a la oleg Iteratee
19:34:48 <pumpkin> BMeph: yeah, exactly
19:35:15 <pumpkin> BMeph: but you can't write a rule like that
19:35:17 <mmorrow> BMeph: that's what i hope to achieve with the GADT
19:35:27 <mmorrow> you can just add that to your "eval" function
19:35:38 <BMeph> Basically, an expansion of CSE
19:35:52 <pumpkin> common iteration elimination
19:36:24 <pumpkin> common traversal elimination?
19:36:30 <BMeph> CTE - common traversal elimination. :)
19:36:38 <BMeph> Jinx!
19:36:54 <monochrom> "fusion" is a short name for common traversal elimination.
19:37:12 <pumpkin> that's what I was calling it earlier
19:37:15 <pumpkin> but people started putting it in quotes
19:37:21 <pumpkin> so I got intimidated and stopped
19:37:22 <pumpkin> :P
19:37:35 <monochrom> > text "fusion"
19:37:36 <lambdabot>   fusion
19:37:43 <monochrom> lambdabot supports you!
19:37:47 <pumpkin> :)
19:38:01 <pumpkin> mmorrow: I'm not convinced you really need the Fold type
19:38:20 <jeffwheeler> @type text
19:38:21 <lambdabot> String -> Doc
19:38:29 <jeffwheeler> @info Doc
19:38:29 <lambdabot> Doc
19:38:32 <jeffwheeler> :(
19:39:01 <pumpkin> mmorrow: you just need a single function to run a given fold over a structure, so a simple typeclass (Foldable would be nice, but is taken) could work
19:39:03 <jeffwheeler> > text "lambda!"
19:39:05 <lambdabot>   lambda!
19:39:18 <BMeph> What we need is a rewrite using 'on'! :)
19:39:23 <pumpkin> but you can just use Foldable actually
19:40:28 <mmorrow> pumpkin: shits. i've got to eval the Itee separately, and turn a big built up GADT Itee into a single (a -> b -> a)
19:40:39 <BMeph> Or of liftM2 Reader-style, I think I called it "flOn" in my utility module. :)
19:40:58 <pumpkin> mmorrow: yeah, it wasn't very pretty
19:41:06 <pumpkin> (when I tried it)
19:41:16 <mmorrow> i think it can be
19:41:44 <Gracenotes> we could probably exploit the fact that Foldable comes with a folding function
19:42:01 <Gracenotes> ...if using that route. for stuffs.
19:42:13 <pumpkin> yeah, that's what I meant
19:42:37 <pumpkin> although Foldable allows foldr too
19:43:15 <Gracenotes> oh, you mentioned Foldable above
19:43:43 <Gracenotes> aww. I was going to mention it a while ago. But now that you were talking about it again, ya know.
19:43:51 <BMeph> There's got to be a way to simplify: mean = liftM2 (/) (foldl (+) 0) (foldl (const succ) 0)
19:44:21 <BMeph> It has so much repeated structure, it's silly!
19:44:23 <pumpkin> bothWith (/) sumF (fromIntegral `after` lengthF)
19:44:24 <pumpkin> :P
19:44:30 <pumpkin> that's what taejo did :P
19:44:44 <Gracenotes> what's what I said earlier too, about the rewrite rule
19:44:45 <pumpkin> harmonicF = bothWith (/) (fromIntegral `after` lengthF) (recip `before` sumF) is mine, for harmonic mean
19:45:13 <Gracenotes> no u, pumpkin pie :o
19:45:20 <pumpkin> ?
19:45:32 <sbahra> Hi pumpkin
19:45:37 <pumpkin> hi sbahra :)
19:45:55 <pumpkin> I'm bad, still haven't started thinking about your project :(
19:46:43 <Gracenotes> :o
19:49:29 <Gracenotes> oh great, I have class 9:00 AM monad next semester
19:49:35 <Gracenotes> *monday
19:49:45 <pumpkin> I made that same typo this morning
19:49:51 <pumpkin> too much haskell
19:49:53 * pumpkin slaps himself
19:50:02 <Nafai> I was trying to figure out what a 9:00 AM monad was
19:50:18 <jeffwheeler> Gracenotes: where?
19:50:55 <Gracenotes> at the other end of campus, if I choose to stay in the same place
19:51:01 <wli> @type uncurry (/) . foldr (flip (***) succ . (+)) (0, 0)
19:51:03 <lambdabot> forall b'. (Enum b', Fractional b') => [b'] -> b'
19:51:19 <pumpkin> wli: yeah, that's precisely what I'm arguing against doing :P
19:51:36 <pumpkin> Gracenotes: planning on transferring elsewhere?
19:51:38 <Cale> @remember Gracenotes oh great, I have class 9:00 AM monad next semester
19:51:39 <lambdabot> I will remember.
19:52:10 <Gracenotes> pumpkin: I mean, different quad.
19:52:15 <pumpkin> oh
19:52:27 <Gracenotes> my quad is the 2nd farthest away from the computer science building
19:52:45 <Axman6> got a bike?
19:52:50 * jeffwheeler has been applying for housing, but I don't know what buildings are nicest for Eng. students
19:52:52 <Gracenotes> I plan on getting one
19:53:00 <Gracenotes> next semester
19:53:04 <Gracenotes> hopefully
19:54:32 <wli> pumpkin: If he wants to golf, he wants to golf.
19:54:33 <Gracenotes> Axman6: do you have a bike, by chance?
19:54:34 <Axman6> i ride to my uni on occasion. good half hour ride
19:54:40 <Axman6> yep
19:54:47 <pumpkin> wli: my point is that the compiler should be doing that transformation for you
19:54:59 <pumpkin> wli: you did a "fold merge" transform on your code
19:55:00 <Gracenotes> good exercise too. main problem is locking it up, and carrying around the 6-pound laptop without killing myself
19:55:01 <Axman6> tried riding to uni without one. that hurt
19:55:30 <Axman6> pfft, i carry around a 10-15KG backpck every day. don't even otice it
19:55:31 <Gracenotes> if all else fails I can just use my light mininote and a USB drive
19:55:34 <Axman6> notice either
19:55:43 <Gracenotes> Axman6: yeah, but carrying it on a bike :x
19:55:59 <Axman6> never had any problems here.
19:56:06 <Gracenotes> okay then :)
19:56:09 <Axman6> just get a nice STM backpack or something
19:56:18 <bstamour> my laptop is also pretty heavy
19:56:23 <bstamour> but I've gotten used to it
19:56:23 <bstamour> :)
19:56:29 <Gracenotes> Axman6: hm? But backpacks haven't implement STM yet!
19:56:35 <Gracenotes> +ed
19:56:35 * pumpkin uses a macbook air most of the time
19:56:36 <Axman6> heh
19:56:43 <Axman6> pumpkin: girl
19:56:44 <Axman6> :P
19:56:51 <pumpkin> Axman6: sexist
19:56:52 <pumpkin> :P
19:57:10 <Axman6> only when it's funny and not meant :P
19:57:17 <Axman6> Gracenotes: http://www.stmbags.com.au/backpacks/backpacks.php
19:57:34 <pumpkin> I have an australian backpack
19:57:36 <Axman6> i have the mediam 15" evolution.
19:57:37 <Gracenotes> hm, so it seems that the machine code/computer organization class has two recitations, but one joined lecture
19:57:42 <Axman6> medium*
19:57:50 <mmorrow> pumpkin: wooo, i got what i was going for http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2048#a2049
19:58:03 <Axman6> pumpkin: brand?
19:58:05 <Gracenotes> Axman6: mm, yeah. I had those backpacks in high school, always carried around too much in them
19:58:26 <jeffwheeler> Axman6: those look nice
19:58:31 <pumpkin> Axman6: crumpler
19:58:38 <Axman6> i carry way too much shit in mine (many people can't lift my bag with one hand), but it's holding up great
19:59:10 <Axman6> jeffwheeler: they're excellent quality
19:59:32 <Gracenotes> also, hm, last class ends at 5:10. It's getting later and later, I'll tell ya
19:59:41 <jeffwheeler> Axman6: I've looked at Amazon before for laptop bags, with essentially no choices other than SwissGear
19:59:53 <Axman6> mine's coming apart in a few places, but nowhere structural (just the sewing on the lose ends of the straps)
20:00:14 <pumpkin> mmorrow: so wait, how does one use the Itee, and where do you fuse multiple folds? the Par? I'd be tempted to make it strict pair-based like the original... folding a list over something feels icky :P
20:01:01 <Gracenotes> Google Calender really is incredibly convenient for planning my potential schedule for next semester!
20:01:03 <mmorrow> pumpkin: the `itee' function is the "eval" that evaluates an Itee into a fused (a, a -> b -> a)
20:01:05 <Gracenotes> </ad>
20:01:12 <Axman6> the rain cover on that evolution is a fantastic addition too
20:01:24 <jeffwheeler> Yeah, I had never even thought about that. I'm glad I have, now.
20:01:32 <Axman6> Gracenotes: iCal is awesome for that too
20:01:57 <Gracenotes> ah, for mac
20:02:55 <Gracenotes> okay, no conflicts so far.
20:03:00 <pumpkin> mmorrow: hmm
20:03:07 <Gracenotes> hopefully Google Calendar can schedule overlapping events
20:03:34 <pumpkin> mmorrow: so how would I write harmonic mean using your structure?
20:03:56 <Axman6> figuring out my timetable was a nightmare this semester -_-
20:04:54 <wli> Probably a better way to write this:
20:05:01 <wli> @type let f zs = let { mu = sumElems / fromInteger nrElems ; (nrElems, sumElems, highMoments) = foldr (\x (k, s, xs) -> let t = x - mu in (k + 1, s + x, zipWith (+) xs . iterate (*t) $ t * t)) (0, 0, repeat 0) zs } in (nrElems, mu, take 10 highMoments) in f
20:05:02 <lambdabot> forall a. (Fractional a) => [a] -> (Integer, a, [a])
20:06:02 <BMeph> mmorrow: Just curious, but why flip the arguments in Itee vs. itee? :)
20:06:42 <mmorrow> BMeph: no reason, i added the tuple result halfway through and didn't really think about it
20:06:44 <pumpkin> wli: the general idea is to represent naive combinations of folds in such a way that the compiler can merge them automatically, or to provide combinators of folds that will make it easier to do so. Ideally you could write mean xs = sum xs / genericLength xs and it would make that into a single fold with a division post-processing
20:06:55 <mmorrow> pumpkin: hmm
20:07:01 * mmorrow looks up harmonic mean
20:08:08 <pumpkin> harmonic xs = genericLength xs / (sum $ map recip xs)
20:08:17 <wli> @type let f xs = genericLength xs / sum (map recip xs) in f
20:08:18 <lambdabot> forall b. (Fractional b) => [b] -> b
20:08:18 <pumpkin> is the naive one
20:08:46 <glguy> the only compelling reason for merging them that comes to mind is to enable to GC to get to work earlier
20:09:34 <pumpkin> glguy: you mean over just `par` ing them together?
20:10:16 <glguy> I mean that on the second pass the constructors at each step will already be known and marked in the pointers
20:10:27 <glguy> I haven't seen the benchmarks that make a compelling case yet
20:10:43 <glguy> I've seen this example come up before
20:10:49 <glguy> but it always seems like premature optimization
20:13:40 <wli> It's not a big enough chunk of code to rearrange to matter wrt. premature optimization doing damage.
20:13:58 <glguy> maybe not in this case
20:14:13 <glguy> but I've seen blog posts where people go to great lengths to avoid the double pass
20:14:42 <pumpkin> glguy: I'm throwing something together
20:16:17 <bstamour> > 1+1
20:16:18 <lambdabot>   2
20:16:24 <bstamour> :)
20:17:24 <Axman6> @botsnack
20:17:24 <lambdabot> :)
20:17:24 <lunabot>  :)
20:17:46 <bstamour> Lambdabot seems pretty cool.
20:18:14 <Gracenotes> yeah
20:18:28 <Gracenotes> i think lambdabot is a pretty cool gal.
20:18:34 <bstamour> mhm.
20:18:37 <Gracenotes> eh evaluates haskell and doesnt afraid of anything
20:18:53 <bstamour> question though, if I tell her something to evaluate...
20:18:58 <bstamour> does everyone see it too?
20:19:00 <Axman6> she's hot stoff alright
20:19:09 * bstamour doesn't wanna flood the channel
20:19:12 <mmorrow> pumpkin: hmean: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2048#a2050
20:19:15 <Axman6> not if you do it in a pm
20:19:22 <Gracenotes> /query lambdabot
20:19:24 <Gracenotes> in most IRC clients
20:19:26 <pumpkin> glguy: not sure if I did it right: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3314#a3314
20:19:34 <bstamour> awesome. Thanks :)
20:19:39 <jeffwheeler> lambdabot responds to PMs?
20:19:46 <Axman6> yes
20:19:46 <pumpkin> jeffwheeler: yup
20:19:47 <jeffwheeler> I thought I remembered it ignoring me.
20:19:54 <pumpkin> jeffwheeler: it won't recognize :t
20:19:58 <pumpkin> jeffwheeler: but @type
20:20:00 <pumpkin> will work
20:20:07 <Gracenotes> if you don't type any commands, it will ignore it
20:20:11 <jeffwheeler> Indeed. Neat.
20:20:12 <Gracenotes> /msg lambdabot 1+1 .. no
20:20:22 <Gracenotes> but /msg lambdabot > 1+1 .. will work
20:21:10 <Gracenotes> hm. I suppose I'll take 'linear algebra' before 'applied algebra'
20:21:41 <pumpkin> glguy: the former one takes loads more memory, but I get a feeling I did it wrong :)
20:21:50 <pumpkin> and takes 4 times longer
20:21:58 <pumpkin> well, 3ish
20:23:08 <Axman6> bstamour: noone really minds you doing stuff with lambdabot in here though, just as long as it's not too long (or if it is, it better be iteresting :P)
20:23:10 <bstamour> Gracenotes: linear algebra is pretty cool
20:23:16 <bstamour> I enjoyed it
20:23:44 <pumpkin> take an honors version if you can find it
20:23:50 <mmorrow> pumpkin: i need to add bangs to the tuples in the `itee' function i just realized
20:23:52 <pumpkin> plain linear algebra is boring
20:23:52 <Gracenotes> not just Introduction to Linear Algebra I took last semester
20:23:57 <Gracenotes> which was just 'playing with matrices'
20:24:10 <bstamour> no eigen stuff?
20:24:42 <bstamour> my intro to lin'alg was mostly playing with matricies, then it picked up fairly quickly :/
20:24:44 <Gracenotes> this one has finite dimensional vector spaces, linear maps, dual spaces, bilinear functions, inner products, to mention some stuff mentioned in the catalog
20:25:26 <bstamour> hrm, honestly it's been so long, I may or may not have done everything on that list
20:25:29 <Gracenotes> bstamour: yeah, we did eigenvectors/values, bases (basises?), psuedoinverses, etc.
20:25:43 <Gracenotes> in the matrix one I mean
20:25:47 <bstamour> mhm
20:26:12 <bstamour> for my CS degree they only require us to take linear algebra 1. So thats all I've got
20:26:21 <bstamour> just a first year intro course
20:26:27 <pumpkin> gotta go above and beyond :P
20:26:32 <bstamour> yup
20:26:38 <pumpkin> mmorrow: hmm
20:26:40 <Gracenotes> oh damn it, it overlaps with the machine code course
20:26:46 <mmorrow> pumpkin: heh, doing
20:26:49 <bstamour> I've taken some graph theory stuff, trying to get into as much math as I can
20:27:03 <mmorrow> let hmean0 xs = fromIntegral (length xs) / (foldl' (+) 0 (fmap (1/) xs))
20:27:07 <mmorrow> is wayyyy faster
20:27:11 <Gracenotes> wait, no itself
20:27:15 <Gracenotes> *it doesn't
20:27:22 <mmorrow> but that might be because i loaded the Fold code in ghci
20:27:26 <pumpkin> mmorrow: see, I still feel that your itee feels too introspective
20:27:39 <pumpkin> you do have nice combinators for accumulators
20:27:44 <mmorrow> pumpkin: what do you mean by introspective?
20:27:50 <pumpkin> you're looking into the fold
20:27:51 <bstamour> Gracenotes: what machine architecture does your course use?
20:28:07 <Gracenotes> MIPS, iirc
20:28:10 <mmorrow> pumpkin: by "fold", what do you mean?
20:28:14 <bstamour> cool
20:28:14 <pumpkin> mmorrow: it feels like I should be able to just take the length function and the sum function
20:28:24 <Gracenotes> I'm trying to pick up some x86 right now though
20:28:26 <bstamour> we learned x86, but all the servers ran sparc at our school
20:28:31 <bstamour> had to do all the work at home
20:28:51 <Gracenotes> mmm.
20:29:08 <wli> bstamour: Learn SPARC, too.
20:29:11 <pumpkin> mmorrow: oh, I see what it's doing, ok
20:29:14 <mmorrow> pumpkin: you need to be able to manipulate the code generated to do that i think (so it'd really be not using them as they're defined)
20:29:22 <pumpkin> no, I misunderstood
20:29:28 <bstamour> wli: If I have time, someday ;)
20:29:29 <gwern> Gracenotes: have any projects over the break?
20:29:50 <Gracenotes> I'm trying to implement rainbow tables and Shor's algorithm in Haskell
20:30:06 <Gracenotes> and, hopefully, find some way to visualize them
20:30:09 <gwern> sounds worthwhile
20:30:14 <mmorrow> pumpkin: i added bangs in those tuples to get foldl'ness back http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2048#a2052
20:30:17 <pumpkin> mmorrow: do you have uvector installed?
20:30:19 <gwern> are you using any of the existing quantum haskell code?
20:30:34 <wli> bstamour: you'll see what good cpus look like and have x86 to compare it to
20:30:35 <mmorrow> pumpkin: yes
20:31:05 <Gracenotes> gwern: no. I might end up binding to libquantum if I figure that out; otherwise, I'll implement it myself
20:31:26 <pumpkin> mmorrow: actually, I can test it myself :)
20:31:29 <Gracenotes> there is a quantum package based on Perl's.. it seems pretty basic
20:31:44 <pumpkin> mmorrow: isn't your list / intmap reimplementing Foldable though?
20:31:49 <Gracenotes> well, a quantum register is all I need.
20:32:23 <mmorrow> pumpkin: i don't know. i don't really like foldable :)
20:32:29 <pumpkin> ah :)
20:33:11 <Gracenotes> darn. looks like my monday is going to be very busy next semester
20:34:23 <pumpkin> mmorrow: onoes, uvector isn't good enough for your Fold type ;)
20:34:29 <pumpkin> return of the Suitable ;)
20:34:35 <mmorrow> oh noes
20:35:26 <Gracenotes> hm. I suppose both linear algebra and applied algebra won't be available :/
20:35:27 <mmorrow> pumpkin: was it noticeably slower than a non-manually-fused version?
20:35:37 <pumpkin> mmorrow: I've only been testing it on uvector :P
20:35:41 <pumpkin> so I can't tell yet
20:35:53 <pumpkin> mmorrow: I still don't see the benefit of the Fold type, really
20:35:57 * mmorrow is starting to think that manually fusing like this is a loss at this level
20:36:25 <pumpkin> mmorrow: in the paste I gave glguy earlier, it was about 3-4 times faster, but I may have done the naive one wrong
20:36:27 <mmorrow> pumpkin: yeah, you could ditch the Fold type easy, it doesn't really add much to the "Itee"
20:36:37 <pumpkin> okay, I'll do that :P
20:37:14 <mmorrow> i may be wrong that it's a loss though (which i would be happy to be wrong about)
20:38:00 <mmorrow> well, it definitely adds convenience
20:38:24 <mmorrow> so even if it decreased performance you'd have that. but i don't see how it couldn't at least have the same performance
20:38:32 <mmorrow> in which case, win!
20:39:38 <dolio> So, I just tried making a nested array type to simulate card marking IOArrays...
20:39:53 <dolio> It was quite a bit faster, but still did a lot of garbage collection work.
20:40:05 <mmorrow> dolio: interresting
20:40:09 <pumpkin> mmorrow: your harmonic mean seems to be causing me to allocate a crapload of memory, maybe it isn't fusing :P
20:40:17 <dolio> (With 1000-element sub-arrays.)
20:40:34 <mmorrow> pumpkin: yeah, it probably play extremely poorly with any other optims/rewrite rules etc
20:41:03 <dolio> Which, here, that's around 8k, I think, since I have 64-bit pointers.
20:41:13 <mmorrow> pumpkin: i think that's the crux actually. getting all your different optims to compose into super optimizations and not interfere with each other
20:41:29 <mmorrow> which is hard when you don't have control over the codegen
20:41:30 <pumpkin> mmorrow: the original one I had wasn't doing that, hmm
20:41:52 <mmorrow> (and by "you" i mean in general)
20:42:07 <pumpkin> mmorrow: what exactly is the GADT doing for us above the original Fold datatype provided in the blog post?
20:42:28 <mmorrow> pumpkin: i'm not sure, i haven't read the other one through yet :)
20:42:35 <pumpkin> lol
20:44:16 <mmorrow> looking, i don't think it gives anything above or below that, just uses a slightly different design
20:44:54 <pumpkin> hmm
20:44:59 <mmorrow> one possible plus of the GADT version is that you can have class constraints on your accum
20:45:02 <pumpkin> well it definitely fuses more nicely
20:45:04 <pumpkin> :P
20:45:08 <pumpkin> my version of the original
20:45:43 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3315#a3315 is what I've been playing with
20:45:49 <mmorrow> hmmmm, i think actually doing the identical thing that 'itee' is doing, but with TH could be a massive win
20:46:04 <pumpkin> mmorrow: I thought about that originally
20:46:09 <mmorrow> because all the info is there a compile-time
20:46:15 <pumpkin> yeah
20:46:30 <pumpkin> except for folds in functions you're calling :(
20:46:38 <mmorrow> and that way all the abstraction and sugar would disappear before ghc  sees it
20:47:09 <mmorrow> but you would just built the iteratee part, then splice it as a function
20:47:58 <Gracenotes> hm. looks like I can take a linguistics formal grammar course without any prerequisites :)
20:48:24 <mmorrow> pumpkin: this is good http://www.haskell.org/th/papers/th-pan.ps
20:48:42 <mmorrow> and this too (although the TH syn is outdated) http://www.haskell.org/th/papers/Unrolling_and_Simplifying_Expressions_with_Template_Haskell.ps
20:50:21 <Gracenotes> well... maybe not this semester. CSE 260 lab is so huge :\
20:58:06 <mmorrow> pumpkin: i just realized that the GADT version _can't_ be faster, because the "itee" function needs to be called _before_ the final form of the function is known, whereas if you're just constructing it straight with combinators, ghc'll be able to optimize it. so the GADT version is in the same situation as Parsec/ReadP vs. Happy
20:58:51 <mmorrow> (but with TH (a TH version of) the GADT version could be optimized down to better code than the combinator version)
21:01:29 <mmorrow> well, the analogy would actually be: (GADT version===ReadP, combinator version===hand-coded (in haskell) parser, TH GADT-equivalent===Happy)
21:12:01 <kniu> Sometimes, I want to interpret a source file so that I can examine the types of expressions,
21:12:08 <kniu> but those files don't typecheck.
21:14:52 <BMeph> Haskell Rule #1 - If it doesn't type-check, "UR DOIN IT RONG!" :)
21:16:28 <int-e> BMeph: it might be the dreaded monomorphism restriction at work ;)
21:17:53 <travisbrady> i've read the stack overflow and performance stuff, but i can't figure out why this never comes back, can anyone lend a hand? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2053#a2053
21:18:00 <harovali1> why it is an error to type "let fact =1" in hugs, and is legal in ghci ?
21:23:44 <int-e> harovali1: it's not a legal expression. ghci emulates a do block on its prompt; hugs doesn't.
21:24:03 <travisbrady> oh, oops, my code was wrong, it's not a performance issue
21:24:58 <harovali1> int-e: thanks
21:25:30 <harovali1> int-e: what makes it not  legal?
21:26:05 <Cale> harovali1: hugs wants an expression
21:26:24 <Cale> harovali1: "let fact = 1" isn't a complete expression
21:26:28 <int-e> harovali1: the expression syntax is  let fact = 1 in <some other expression>
21:26:51 <harovali1> thanks
21:27:16 <Cale> harovali1: In any case, it's usually a good idea to keep a couple of terminal windows open: one with your text editor, and one with ghci (or hugs)
21:27:29 <Cale> Then, when you save your definitions, :r will reload the file.
21:28:02 <Cale> (Just in case you don't know this :)
21:29:45 <harovali1> Cale: it is not in excess to mention it , thank you
21:33:33 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=3316#a3316 if anyone wants to try their luck.
21:33:55 <dolio> nestSize = 10000 seems to be near the optimal value for that benchmark.
21:34:52 <dolio> It starts doing a lot of copying with smaller nestSizes which slows it back down. I'm not sure if that's something I can stop or not.
21:37:00 <dolio> Anyhow, for 10000, nestTest takes around 6.5 seconds here, with 66% GC time, and rawTest takes 50 seconds with 99.7% GC time.
21:43:44 <kniu> @pl (\ss -> sequence_ $ zipWith ($) (concat $ map (flip map ss) (map (msg "PRIVMSG") (fst (unzip ts)))) hs)
21:43:44 <lambdabot> sequence_ . flip (zipWith id . join . flip map (map (msg "PRIVMSG") (fst (unzip ts))) . flip map) hs
21:44:22 <kniu> :t id
21:44:23 <lambdabot> forall a. a -> a
21:44:26 <harovali1> Cale, I did :r having created a new function in the file. When then I tried to call the new function, ghci tells me not in scope ...
21:44:27 <kniu> :t zipWith
21:44:28 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:44:40 <Cale> harovali1: huh.
21:44:46 <Cale> harovali1: Try saving again?
21:44:58 <Cale> harovali1: Make sure that there are no .o files hanging about too.
21:45:07 <kniu> :t zipWith id
21:45:08 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
21:45:12 <harovali1> Cale: I think I tried, anyway, I already quit and entered ghci
21:45:44 <harovali1> Cale: do you think sometimes I might have to delete object files?
21:45:53 <kniu> @hoogle forall b c. [b -> c] -> [b] -> [c]
21:45:54 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:45:54 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:45:54 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:46:08 <Cale> harovali1: If there are .o files present, ghci will load them.
21:46:14 <Cale> harovali1: Rather than the source code.
21:46:19 <kniu> hurm.
21:46:31 <Cale> harovali1: Which is useful for performance when you need it, but gets in the way if you're editing.
21:46:38 <harovali1> Cale: so, I tell you again if the same happens
21:46:50 <harovali1> Cale: thanks
21:47:06 <Cale> You should be able to tell because it will say Compiled or Interpreted when it loads the file.
21:47:24 <harovali1> Cale: nice detail, thanks
21:47:46 <kniu> :t join
21:47:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:48:32 <kniu> :t ap . join
21:48:33 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (m (a -> b)) -> m a -> m b
21:48:43 <kniu> @hoogle forall a b (m :: * -> *). (Monad m) => m (m (a -> b)) -> m a -> m b
21:48:43 <lambdabot> Parse error:
21:48:43 <lambdabot>   --count=20 "forall a b (m :: * -> *). (Monad m) => m (m (a -> b)) -> m a -> m b"
21:48:43 <lambdabot>                         ^
21:48:56 <kniu> @hoogle (Monad m) => m (m (a -> b)) -> m a -> m b
21:48:56 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:48:56 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:48:56 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:49:42 <ddarius> :t ap . join
21:49:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (m (a -> b)) -> m a -> m b
21:53:31 <kniu> ~announce
21:59:06 <harovali1> why this doesn't work                 interact (\c -> "a")           ?
21:59:30 <Axman6> :t interact
21:59:31 <lambdabot> (String -> String) -> IO ()
21:59:51 <Axman6> :t  (\c -> "a")
21:59:52 <lambdabot> forall t. t -> [Char]
22:00:07 <Axman6> harovali1: what's the error?
22:00:15 <harovali1> isn't [Char] a String ?
22:00:18 <Axman6> yes
22:00:37 <harovali1> Axman6: ok, the error is  Exception: <stdin>: hGetContents: illegal operation (handle is closed)
22:01:00 <Axman6> you on windows perhaps?
22:01:10 <harovali1> Axman6: no, Linux
22:01:18 <harovali1> gnome
22:01:18 <Axman6> no idea then
22:01:30 <inimino> in ghci?
22:01:33 <harovali1> a gnome terminal might be the problem?
22:01:36 <harovali1> inimino: yes
22:01:45 <Axman6> yeah, that was going to be my next question inimino
22:01:55 <Axman6> harovali1: might try compiling it and tryig i
22:01:57 <Axman6> t8
22:02:07 <harovali1> Axman6: i'll do
22:03:56 <harovali1> now it doesn't error, but it "quits" the interact without really interacting
22:04:21 <harovali1> the lambda is the culprit
22:04:31 <Axman6> ~hmm, yet another reason APL is retarded... 1+2*3 = 7, 2*3+1 = 8
22:04:52 <harovali1> Axman6: what is APL?
22:05:20 <Axman6> a very strange programming language (which does very well on the language shootout for some reason)
22:05:32 <inimino> http://en.wikipedia.org/wiki/APL_%28programming_language%29
22:05:33 <harovali1> Axman6: the old APL ?
22:06:07 <Axman6> oh my bad, i was thinking about AST
22:06:18 <Axman6> that's the one hat does well i the shootout
22:06:35 <Axman6> still, the aforementioned examples makes my dislike APL too
22:06:43 <harovali1> :)
22:11:22 <ddarius> APL has right-to-left precedence.  Smalltalk does something similar.
22:12:02 <ddarius> In Smalltalk it's because there's nothing special about binary operators, in APL it's due to the shear number of operators.
22:12:44 <Axman6> heh, i see
22:20:45 <Saterus> hmm...is there a situation where you would ever want to export only some of a type's value constructors?
22:33:05 <oshyshko> How do I catch exceptions for function of type "ReaderT a IO b" ? E.g.: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3317
22:41:25 <altmattr> quick quiz - what do you write your haskell code in and what plug-ins/inits/bundles do you use?
22:42:35 <dkcl> altmattr: Emacs, haskell-mode.
22:43:19 <oshyshko> IntelliJ IDEA + syntax highlighter + ghci
22:43:29 <BMeph> Axman6: ATS? :)
22:43:44 <Axman6> that one too probably :P
22:43:51 <Axman6> damn acronym names
22:44:11 <dkcl> Oh, yes, GHCi too of course.
22:44:14 <BMeph> :)
22:44:26 <altmattr> emacs I expected, but IntelliJ is a little out of left field
22:44:56 <BMeph> altmattr: I use Notepad++, when the butterfly method is too slow... ;)
22:44:58 <altmattr> I am just considering improving the TextMate Bundle or jumping ship to an alternative
22:45:25 <altmattr> emacs is out since I have vi-brain (and a weak ctrl-finger :))
22:45:38 <pumpkin> altmattr: I'd encourage you strongly to improve the textmate bundle
22:45:42 <altmattr> but intelliJ has me very curious
22:45:47 <pumpkin> it'd get you lots of karma :)
22:45:53 <Nafai> emacs + haskell-mode + autocomplete mode
22:46:16 <altmattr> pumpkin: and I oculd do with some
22:46:21 <pumpkin> altmattr++
22:46:23 <pumpkin> as a start
22:46:25 <pumpkin> :P
22:46:25 <altmattr> I feel something of a leech hanging out here
22:46:28 <altmattr> :)
22:47:06 <altmattr> you have convinced me!
22:47:22 <altmattr> and since no-one popped up with vi modes, I will stick with textmate
22:47:27 <altmattr> (for now)
22:47:54 <pumpkin> @src maximum
22:47:55 <lambdabot> maximum [] = undefined
22:47:55 <lambdabot> maximum xs = foldl1 max xs
22:48:30 <pumpkin> mmorrow: oh no, I ran into a block with the non-GADT method
22:48:40 <Gracenotes> oh nos :(
22:48:54 <pumpkin> oh, no I didn't
22:51:44 <BMeph> Yay! Go, pumpkin! Go, pumpkin! Go! Go! Go! :)
22:51:48 <Axman6> > undefined == undefined
22:51:49 <lambdabot>   * Exception: Prelude.undefined
22:52:12 <Gracenotes> > (undefined :: ()) == undefined
22:52:13 <lambdabot>   * Exception: Prelude.undefined
22:52:20 <BMeph> Does anyone recognize which package would have this definition:
22:52:23 <BMeph> sum :: (Num a) => a -> [a] -> a         -- Defined at <interactive>:1:4-6
22:52:28 <zakwilson> Relative newb type system question here. I have a list of Maybe values that I want to write to different files (depending on what's in them), or do nothing with for Nothing. How do I handle the no-op side of that?
22:52:41 <Gracenotes> @type catMaybes
22:52:42 <Axman6> BMeph: :info sum?
22:52:43 <lambdabot> forall a. [Maybe a] -> [a]
22:52:59 <BMeph> Axxman6: Yes, that's what it says. :\
22:53:01 <Gracenotes> catMaybes gives you a list from Maybes, taking out the Nothings
22:53:15 <zakwilson> Thanks, Gracenotes.
22:53:35 <Gracenotes> sure. it's in Data.Maybe btw
22:54:29 <zakwilson> I had thought of using filter before, and then forgot about it until you answered my question. Maybe I need sleep.
22:55:01 * BMeph idly imagines a "who's on first" scenario with an OCaml user asking what the Haskell version of 'option' is...
22:55:14 <pumpkin> :o
22:55:25 <Axman6> BMeph: :(
22:56:06 <pumpkin> how do I merge a foldl and foldl1 :o
22:56:13 <Gracenotes> with gusto
22:56:17 <wli> BMeph: I thought SQUFOF would be a decent algo until I found the docs lacking. I wasn't interested in other algorithms. SQUFOF was because it was "clean."
22:57:12 <pumpkin> @src foldl1
22:57:13 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:57:13 <lambdabot> foldl1 _ []     = undefined
23:01:11 <dons> anyone ever tried, say, Data.Map, but with associated data  types to specialise the constructors... ?
23:01:39 <dons> the only lib actually using associated data types for per-key/elem representation choices is the ndp/uvector array suite, afaik
23:01:45 <BMeph> wli: I'd do it, except that I'm still dithering on whether I want to implement a generalized module for all of the a+bY types of numbers. And whether I should accommodate all the various forays into replacing the Prelude's hash of numerics while I'm at it.
23:02:18 <dons> but hmm, associated data types give us polymorphic container specialization, i think...
23:02:21 <BMeph> wli: It's bad enough that I faced some of the same questions just from trying to doGaussians.
23:02:33 <pumpkin> that sounds like an interesting idea
23:03:14 <dons> you could even imagine specializing lists this way
23:03:36 <dons> [] Int  ->  Empty | Cons !Int ...
23:03:50 <dons> so atomic types would self-specialize their container
23:04:07 * dons dreams of fast containers with small footprints
23:04:12 <oshyshko> Another newb question: if I have function "dangerousHello :: ReaderT Int IO String", how to catch exceptions raising from it?
23:04:22 <dolio> dons: This might interest you: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=3316#a3316
23:04:33 <pumpkin> mmm
23:05:07 <dons> dolio: what am i looking at?
23:05:36 <dolio> It uses an array of arrays to reduce GC overhead.
23:05:43 <dons> ah, does that help?
23:05:50 <dons> oh i guess it does!
23:06:07 <dons> i'll show you what i've been doing
23:06:15 <dolio> Yeah. nestSize = 10000 seems to be the optimal value for that benchmark, which is a bit confusing to me.
23:06:40 <dolio> I get a lot more copying the smaller I get which kicks the GC time back up.
23:06:41 <dons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3316#a3318
23:06:59 <BMeph> wli: Then there's the issue of representing roots as continued fractions, namely, do I use a special encoding for the cycles, and how do I distinguish them? Especially if the repeating part of the fraction doesn't start with the first denominator.
23:07:05 <dons> i'm doing an IntMap top level, with IOArray nodes
23:07:13 <dons> dolio: i was wondering if freezing would help as well
23:07:26 <dons> as doesn't that basically prevent the GC wandering in too...
23:07:55 <dons> take the first bits of the hash to index the trie, the full n bits to index the hash once identified
23:08:03 <dolio> I looked at the HashTable source, and it actually has provisions for freezing the array in between mutations.
23:08:05 <int-e> oshyshko: mapReaderT seems to do what you want.  mapReaderT (`catch` \exception -> ...)
23:08:06 <dons> currently about the same as an IntMap , but i think it'll scale better
23:08:09 <dons> dolio: yes
23:08:21 <dolio> But they're currently disabled, with 'freeze = return'.
23:08:22 <dons> unused though. and naively introducing freezing for a lot of inserts is bad
23:08:40 <dons> so it makes thiings about 3x slower if you do 10M inserts each of which freeze/unfreeze
23:09:16 <dons> dolio: how big should the sub arrays be?
23:09:23 <dons> i've just been guessing at 4k - overhead
23:09:51 <Axman6> dons: what's this all for?
23:10:11 <dolio> Well, with that benchmark I did, it optimal time seems to be for 10,000 element sub-arrays. But that seems wrong to me.
23:10:14 <dons> well fundamentally, our container types are slow on large numbers of elements
23:10:23 <dons> dolio: hmm.
23:10:38 <dolio> As I said, the more I decrease the size, the more copying the GC does for some reason, which is why the time goes back up, I think.
23:10:44 <dons> hmm
23:10:54 <dolio> But I haven't investigated as to what it's copying.
23:11:05 <dons> so maybe it is fragmenting
23:11:15 <dons> you could try increasing the heap size
23:11:27 <dons> still, we need something that does < 50% GC :)
23:11:40 <dolio> Yeah. I never got below 65%.
23:11:51 <dons> i got some speedups filling from a fused loop
23:12:11 <int-e> does anybody else's ghci (6.10.2 or head) crash on ^C under linux?
23:12:21 <dons> but i've not implemented the dynamic resizing yet, so i can only really test on small hashes
23:12:27 <dons> btw, i'm using the bloomfilter hash suite
23:12:38 <dons> which has a nice hashable class
23:19:23 <hipertracker> I am just learning Haskell and I am a bit confused with pattern matching. How to create in Haskell the following Python function? def my_fun(num): return "Yes" if 10 <= num <= 19 else "No"
23:20:55 <McMartin> You probably want guards for that, not pattern matching.
23:21:08 <pumpkin> mmorrow: foldl1 has made my life a lot harder :P I was trying to add a fold for maximum and minimum
23:21:11 <McMartin> Or you can just do an if-then-else
23:21:14 <enolan> > let myFun x = if (10 <= x) && (x <=19) then "Yes" else "No"
23:21:15 <lambdabot>   <no location info>: parse error on input `;'
23:21:30 <dons> myfun n | 10 <= n && n <= 19 = Yes | otherwise = No
23:21:44 <enolan> > let myFun x = if (10 <= x) && (x <=19 ) then "Yes" else "No"
23:21:45 <lambdabot>   <no location info>: parse error on input `;'
23:21:52 * pumpkin is struggling with infinite types :(
23:23:39 <solidsnack> pumpkin: How has that come up for you?
23:23:59 <pumpkin> fusing paralell foldl1s :/
23:24:09 <ivanm> solidsnack: he's still trying to get to the bottom of the first infinite type! ;-)
23:24:16 <ivanm> "this is the type that doesn't end..."
23:24:20 <pumpkin> lol
23:24:43 <ivanm> it goes on and on my friend...
23:24:59 <pumpkin> I don't remember the words :(
23:25:02 <ivanm> some people started showing it, not knowing what it was
23:25:12 <pumpkin> aha
23:25:28 <ivanm> and ghci's still printing it, and all just because <repeat>
23:27:43 <dons> dolio: i'd be interested in any further developments. sorting out a bunch of good hashtable designs would be nice on hackage.. :)
23:28:39 <pumpkin> can I use {-# UNPACK #-} on any strict type?
23:29:27 <pumpkin> or only primitive types with one constructor?
23:29:33 <Tsion> Is {-#  #-} for the pre-processor?
23:29:46 <pumpkin> you can stick hints to the compiler in there
23:29:54 <pumpkin> well, more than just hints sometimes
23:30:17 <ivanm> Tsion: well, it's for ghc[i] to read
23:30:24 <ivanm> special pragma's, commands, etc.
23:31:00 <dolio> dons: Well, that benchmark is evidence that card marking in the garbage collector would be helpful, at least. I don't know if it'd totally solve the problem or not.
23:35:50 <pumpkin> :t maximum
23:35:51 <lambdabot> forall a. (Ord a) => [a] -> a
23:36:39 <pumpkin> :t maximumBy
23:36:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
23:38:20 <Axman6> :t sortBy
23:38:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:38:30 <ivanm> :t byBy
23:38:31 <lambdabot> Not in scope: `byBy'
23:38:34 <ivanm> :(
23:38:43 <ivanm> surely it's possible to do something by using something? :p
23:39:10 <int-e> :t on
23:39:11 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:39:44 <pumpkin> bah, the rigid type variables are killing me
23:39:51 <Axman6> > sortBy (\(x,y) (a,b) -> compare y a) [(a,b)| a <- [1..10], b<-[4..14]]
23:39:52 <lambdabot>   [(4,4),(5,4),(5,5),(6,4),(6,5),(6,6),(7,4),(7,5),(7,6),(7,7),(8,4),(8,5),(8...
23:40:07 <Axman6> > sortBy (\(x,y) (a,b) -> compare y a) [(a,b)| a <- [1..10], b<-[1..10]]
23:40:08 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(3,4),(4,1),(4,2),(4,3),(4,4),(5,1),(5...
23:40:08 <ivanm> pumpkin: in which case you're using the wrong language...
23:40:13 <pumpkin> :P
23:40:21 <Axman6> how interesting
23:40:40 <Axman6> orders on fst, then on reverse orders o snd
23:40:42 <Axman6> n*
23:41:14 <ivanm> Axman6: it ignores x and b ...
23:42:10 <Axman6> > compare (1,2) (3,4)
23:42:12 <lambdabot>   LT
23:42:22 <Axman6> > compare (3,4) (1,2)
23:42:24 <lambdabot>   GT
23:42:36 <Axman6> hmm, not even sure why i did that
23:43:07 <Axman6> > (\(x,y) (a,b) -> compare y a) (2,4) (1,3)
23:43:09 <lambdabot>   GT
23:43:15 <Axman6> > (\(x,y) (a,b) -> compare y a) (2,1) (1,3)
23:43:16 <lambdabot>   EQ
23:43:33 <Axman6> > (\(x,y) (a,b) -> compare y a) (1,3) (2,1)
23:43:34 <lambdabot>   GT
23:43:55 * Axman6 breaks some ordering law for funsies
23:47:02 <pumpkin> this is complicated, hmm
23:47:23 <ivanm> pumpkin: what Axman6 is doing? you should probably ignore him...
23:47:29 <pumpkin> no, what I'm doing
23:47:40 <ivanm> heh
23:47:47 * Axman6 agrees with ivanm 
23:48:02 <ivanm> hmmm.... did someone call me?
23:48:03 <ivanm> ;-)
23:48:06 <int-e> @check let f (x,y) (a,b) = compare (y :: Int) a in \xs -> null xs || minimumBy f xs == head (sortBy f xs)
23:48:07 <lambdabot>   "Falsifiable, after 10 tests:\n[(1,0),(6,-6),(3,-5),(-4,1)]\n"
23:59:06 <zakwilson> Regarding my earlier question about writing a list of values to (possibly) different files, I'm now left with the problem of having [IO ()] when main is expected to be IO ().
23:59:14 <pumpkin> sequence_
23:59:25 <pumpkin> or use mapM_ instead of map
