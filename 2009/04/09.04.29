00:00:36 * SubStack will still write the graphical part in haskell anyways
00:01:10 <Jebdm> haskellnoob: You could always look at a grammar, and I'm sure somebody explains it, but the general idea is just to line up definitions that are in the same scope, to indent when you're attaching a clause, and dedent to end one
00:01:25 <Jebdm> oh, and line up do statements
00:02:10 <Jebdm> i think if you look at some code, you'll figure it out and won't even have to think about it
00:02:50 <Cale> haskellnoob: Essentially, the rule is that things at the same level should start in the same column, and if something is inside something else, it starts at a deeper column
00:03:11 <haskellnoob> jebdm: I am planning to write a haskell indent file for vim -- the existing one has a lot of annoying glitches -- and wanted to start with a definitive  (and hopefully small) list of rules to go by.
00:03:59 <Gracenotes> "Exception: System.Random.Mersenne: Only one mersenne twister generator can be created per process" ... this is going to get really annoying ...
00:04:22 <Cale> Oh, well, if you want to be technical about it, the Report has a description of the actual rule. But basically, the first non-whitespace character after 'do', 'of', 'where', or 'let' sets the indentation level for the block.
00:04:24 <haskellnoob> a rule would, for example, look like "If you find a "where" at the beginning of a line, then indent that line more compared to the previous line of code" or some such
00:04:30 <Gracenotes> if I find out that this was motivated by some idiotic singleton design pattern I am going to ... argh... X_X
00:05:09 <ehamberg> haskellnoob: i recently made a indenting script for the kate editor. i based it on the vim script, but made som improvements. you could take a look if you want. it's pretty straight-foreward to translate.
00:05:17 <Cale> haskellnoob: The first non-whitespace character after 'where' sets the level of indentation for subsequent lines.
00:05:21 <haskellnoob> ehamberg: thanks
00:05:24 <Gracenotes> well, maybe not idiotic after all. But at least have a way to kill the twister...
00:05:34 <Cale> haskellnoob: Normally, I like to indent like:
00:05:38 <Cale> foo = ...
00:05:48 <Cale>   where bar = quux + baz
00:05:59 <Cale>         quux = ...
00:06:04 <ehamberg> haskellnoob: http://websvn.kde.org/trunk/KDE/kdelibs/kate/script/data/haskell.js?view=markup
00:06:08 <Cale>         baz = ...
00:06:20 <Cale> haskellnoob: See how that works?
00:06:35 * ski usually prefers indenting like
00:06:36 <ehamberg> function indent is the central part.
00:06:37 <Cale> haskellnoob: The definitions of bar, quux, and baz line up.
00:06:37 <ski>   foo = ...
00:06:40 <ski>     where
00:06:45 <ski>     bar = quux + baz
00:06:51 <ski>     quux = ...
00:06:55 <ski>     baz = ...
00:07:11 <cjs> haskellnoob: I find the existing vim one pretty good; I just had to fix some issues with comments.
00:07:16 <Cale> ski: That disobeys my rule that if something is inside something else then it should always be indented further.
00:07:30 <ski> Cale : i don't see that :)
00:07:30 <Cale> (but it is valid of course)
00:07:32 <haskellnoob> Cale, others: is it just that you would "like" to indent the where a little more, or is that required? I had some trouble because the existing vim script does not add  more indentation to the line that has a new "where".
00:07:48 <haskellnoob> cjs: have you tried indenting code that has guards?
00:07:49 <Cale> haskellnoob: It's not required.
00:08:13 <cjs> haskellnoob: I use guards fairly frequently, and I hadn't noticed any issues.
00:08:31 <Cale> haskellnoob: The first non-whitespace character after a layout keyword sets the indentation level for a block.
00:08:47 <Cale> haskellnoob: Subsequent lines must start on that column if they are to be part of the block.
00:09:29 <cjs> I do have to hit ^T after hitting enter after writing a function header without an = sign at the end, yeah. I didn't actually notice that, it's so instinctive. :-)
00:09:48 <Cale> This column of course should also be deeper than the column for any containing block.
00:10:00 <Cale> (strictly deeper)
00:11:08 <Cale> haskellnoob: Another thing about Haskell layout is that despite the fact that it's not strictly required, Haskell programmers tend to like 'then' and 'else' to line up in an 'if' expression if they do not occur on the same line.
00:11:34 <Jebdm> I don't think it has to be deeper.
00:11:35 <haskellnoob> Ok, here is an example that seems to suggest that we need to indent "where" more:
00:11:36 <haskellnoob> module Main
00:11:38 <haskellnoob> where
00:11:39 <haskellnoob> main = printOutput
00:11:41 <haskellnoob> printOutput = putStrLn banner
00:11:42 <haskellnoob> where banner = "Hi, there"
00:11:57 <haskellnoob> this code has ghc complaining about parse error on input "where"
00:12:08 <Cale> Even if that were valid, it's ugly as sin :)
00:12:16 <haskellnoob> sure, just an example
00:12:30 <Jebdm> test2 = 1 + y
00:12:30 <Jebdm>    where
00:12:30 <Jebdm>  y = 2
00:12:32 <Jebdm> compiles
00:12:43 <haskellnoob> because the where is indented a bit to the right?
00:12:45 <QtPlaty[HireMe]> module Main where
00:12:58 <Cale> Jebdm: but...
00:13:00 <haskellnoob> no, this complaint is about the "where banner .." line
00:13:00 <Cale> test2 = 1 + y
00:13:01 <Cale>   where
00:13:03 <Cale> y = 2
00:13:05 <Cale> should not
00:13:12 <Jedai> haskellnoob: if where is in the first column, it's a definition, where being a keyword, you can't redefine it
00:13:25 <Jebdm> i don't like it, but it definitely compiles under ghc
00:13:36 <Cale> because the y = 2 matches the indentation level of the containing block (which in this case is the top level)
00:13:42 <haskellnoob> Jedai: I am afraid I don't get that.. what am i redefining?
00:13:48 <Cale> which is not appropriate, it must be strictly deeper
00:13:56 <Jebdm> oh, there's one space in front of the y = 2
00:13:59 <Jedai> haskellnoob: You're trying to redefine "where"
00:14:12 <haskellnoob> ah! got it :)
00:14:13 <Jebdm> actually, it compiles even without the space
00:14:22 <Jebdm> strange
00:14:33 <Jedai> Jebdm: but in this case y is global and the where is empty
00:14:56 <Cale> Jedai: oh, of course, but y = 2 isn't in the where anymore.
00:15:06 <Cale> er, Jebdm rather
00:15:13 <Cale> you can have an empty where
00:15:15 <Jebdm> ah, ja
00:15:16 <galdor_> hi; is there a simple native haskell library for SNMP ? I can't find one
00:15:32 <galdor_> there's a net-snmp binding but it seems an alpha version
00:16:14 <galdor_> and honestly I'd prefer a native implementation
00:16:16 <Jedai> galdor_: Well... Better than nothing
00:16:33 <Jedai> I don't think we have something else
00:16:41 <galdor_> that's a pity
00:16:44 <Cale> galdor_: does the NetSNMP package on Hackage not work?
00:16:50 <Jebdm> hmm.. what's the point of allowing an empty where block?  seems like it would only cause errors
00:17:04 <galdor_> Cale: it's annotated as not compiling with ghc 6.10
00:17:15 <galdor_> and it's really minimal
00:17:41 <Jedai> galdor_: the annotation isn't really signifactive
00:17:55 <Cale> That's just because they didn't have the library it's binding to.
00:18:13 <Jedai> galdor_: it's just that the building bot server doesn't have NetSNMP
00:18:17 <galdor_> problem is, I'm testing an agentx C implementation, I'd need a full suport
00:18:19 <galdor_> ah ok
00:18:30 <galdor_> I might test it (have to install cabal-install on debian before)
00:18:52 <galdor_> I understand nobody writes a mib/snmp lib, it's really hairy, but I'm at work and need this :(
00:19:04 <galdor_> thank you anyway
00:19:18 <cjs> Uh oh, this is not looking good: "we always have a 1-character read buffer for unbuffered  handles: it's needed to support hLookAhead."
00:19:54 <Cale> galdor_: I'm not even completely sure what it's for :]
00:21:15 <galdor_> Cale: lucky man, believe me
00:21:50 <haskellnoob> thank you all. let me try to hack up something now based on what you suggested.
00:23:03 <Cale> "Simple Network Management Protocol (SNMP) is used in network management systems to monitor network-attached devices for conditions that warrant administrative attention."   "Dude... I think your printer is on fire."
00:23:33 * Cale sees if he can cabal-install the library.
00:23:46 <Cale> yep, it builds okay with libsnmp-dev installed
00:23:57 <Cale> (on ghc-6.10.1)
00:24:00 <galdor_> ah that's good!
00:27:02 <Jedai> I confirm, the haddock build okay too... (and I confirm that the interface is pretty minimalist)
00:29:07 <galdor_> Cale: I'll have to try another day, don't have the time to setup cabal-install on debian
00:29:16 <galdor_> can't believe there's no package for it
00:29:22 <Jedai> But it should be able to do everything needed (and it says it's thread-safe, which means you'll be able to use threads to connects to multiple devices simultaneously)
00:29:41 <Jedai> galdor_: cabal-install is really easy to install on Linux
00:29:42 <Cale> http://cale.yi.org/NetSNMP/ -- here's the documentation
00:30:04 <Cale> (seeing as it didn't build on the hackage server)
00:30:12 <Jedai> galdor_: There's a bootstrap script in the archive that do everything for you
00:30:14 <galdor_> oh thank you a lot!
00:30:24 <galdor_> Jedai: ok gonna try
00:30:27 <mop_> Hey, I just installed haskell-mode, and when I open the interpreter and try to use it via emacs, whatever I typed just gets printed back to me with ^J3842 or some other numbers after it
00:30:41 <Gracenotes> hm... still a bit slow, my more-optimized chain generator. 2.5 - 3 times slower than C++
00:30:57 <Gracenotes> *examines out profiling data*
00:31:20 <Jedai> galdor_: nothing to setup (warning : by default the installs are by user and the binary installed in ~/.cabal/bin, look into the config file for more options)
00:32:01 <Cale> galdor_: you get http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz and then run the bootstrap.sh script from it. If you're using debian's package of ghc, you might need to install a few extra libraries it doesn't expect you not to have.
00:32:20 <Cale> (but they'll be in the apt repository as libghc6-*-dev
00:32:22 <Cale> )
00:33:09 <Cale> (the reason being that ghc comes bundled with a small set of libraries, and the debian people separated them further)
00:34:00 <Gracenotes> wow... what the hell did -O2 do to make my program speed up 3 times O_O
00:34:13 <Cale> Gracenotes: heh, over -O ?
00:34:18 <Gracenotes> it .. just .. wow
00:34:27 <Cale> Gracenotes: or over un-optimised code?
00:34:36 <Gracenotes> Cale: unoptimized code. added -funbox-strict-fields too
00:34:40 <Cale> Oh, heh
00:34:50 <Gracenotes> amazing. it's as fast as the C++, I think
00:34:54 <Apocalisp> not surprising
00:34:55 <Cale> Yeah, if you don't turn on optimisations, things will be slow :)
00:34:59 <galdor_> Cale: it worked perfectly, thank you!
00:35:36 <Gracenotes> now, to do some minor optimizations on functions called millions of times...
00:36:06 <Gracenotes> Apocalisp: still. I knew -OX was effective, but... goodness.
00:36:18 * Gracenotes is possibly overreacting
00:36:28 <Cale> I believe -O2 can alter the asymptotic performance of your code, even.
00:36:39 <Cale> But that's kind of rare
00:36:59 <Axman6> Gracenotes: -O2 often makes a very substancial difference in speed
00:37:13 <jmzz> Gracenotes: nice
00:37:16 <Cale> Well, certainly relative to no optimisations, the asymptotic performance can change, because rewrite rules don't happen without at least -O
00:37:26 <Cale> and some libraries depend on rewrite rules for performance
00:38:41 <galdor_> Cale: library works perfectly
00:38:45 <Cale> galdor_: cool
00:38:47 <Gracenotes> of course, I'm not even half-way done -- still have to sort GBs of files 16 bytes at a time and actually write the cracking utility. but it's a start
00:39:02 <galdor_> just a pity it's not as simple as apt-get install haskell-netsnmp, can't share that kind of script at work
00:39:11 <galdor_> (we've got a C only policy :/)
00:39:15 <Cale> galdor_: But you can share the binary
00:39:26 <galdor_> oh right
00:42:05 <Gracenotes> and in 100 lines of code, compared to 500+25+75 = 600 lines of C++
00:43:25 <cjs> Hm. S.hGetNonBlocking willl happily buffer 1.4 MB of data file more; if I truncate the file, rewind, and read again, I still get the original 1.4 MB of data.
00:43:34 <cjs> s/S/Data.ByteString/
00:43:44 <cjs> Anybody have any thoughts on that?
00:44:32 <Gracenotes> high-performance code seem pretty addictive to write...
00:50:33 <Gracenotes> > logBase 2 $ 1024*1024*1024
00:50:35 <lambdabot>   30.0
00:50:41 <Gracenotes> oh
00:55:49 <sjanssen> Gracenotes: compiling without at least -O should basically only be used for the initial testing phase
00:56:12 <quicksilver> cjs: how did you truncate it?
00:56:18 <sjanssen> for the speedier compile times and whatnot.  If you ever want to run the program you're writing, turn on -O
00:56:31 <cjs> quicksilver: Wrote an empty file using vim.
00:56:34 <Gracenotes> good to know. Most of the time I don't 'run' programs, only in ghci
00:56:41 <quicksilver> cjs: that writes a new file.
00:56:55 <quicksilver> cjs: the old one, still open, still exists, it just no longer has a directory entry.
00:57:03 <quicksilver> cjs: this is unix semantics.
00:57:14 <quicksilver> (nothing to do with haskell or bytestring or nonblocking)
00:57:25 <Gracenotes> rather speed-critical here, though, so this is good
00:57:46 <cjs> Really? To be more precise, I opened the full file using vim, then ran my program, then deleted all the lines and wrote again. I thought that did not remove and rewrite, especially given that I don't use tempfiles.
00:58:22 <cjs> If that's been my problem all afternoon, I'm going to smack myself.
00:58:22 <quicksilver> cjs: You'd need to strace to be sure, but that's what I'd expect vim to do.
00:58:23 <sjanssen> cjs: if you want to be sure, compare with 'echo > file'
00:59:04 <quicksilver> random access - that is, changing a file "in place" is the exception in unix land.
00:59:11 <quicksilver> that's only used when you really want it - e.g. large DB files.
00:59:23 <quicksilver> which obviously need their own locking protocol to maek it make sense.
00:59:32 <quicksilver> the standard unix way of using files is always to write a fresh one.
00:59:40 <quicksilver> it causes fewer surprises for concurrent access.
01:00:12 <wli> Um, UNIX has file locking stuff all over the place.
01:00:18 <quicksilver> I didn't say it din't.
01:00:20 <wli> Mandatory locks and more.
01:00:25 <quicksilver> I'm talking about the conventional way to use it.
01:01:05 <wli> man 3 lockf
01:01:12 <quicksilver> I know.
01:01:24 <quicksilver> I'm not an idiot, and I've been programming unix systems for 15 years.
01:01:29 <cjs> Zoiks! You're right!
01:01:33 <quicksilver> If you're not contributing, please shut up, wli.
01:01:38 <cjs> (Verified with ls -i.)
01:02:01 <cjs> I've been programming Unix for like 25 years; I *really* should have thought of that.
01:02:59 <wli> Basically you seek to the position you want the beginning of the lock to start at, lockf() the length of the range, etc.
01:03:49 <cjs> Crud, this all works fine now. Ok, thanks again, quicksilver.
01:03:55 <quicksilver> cjs: not at all :)
01:13:10 <quicksilver> dcoutts_: woo, hopengl is back in the platform?
01:13:13 * quicksilver celebrates.
01:17:36 <cjs> Ah, you have to *keep* calling unsafeInterlaveIO in your loop, over and over again, to make it work. Makes sense.
01:17:59 <cjs> Gah, ok. Three hours to write essentially "tail -f" in Haskell.
01:18:33 <jbapple> I'm having trouble with ghc -main-is. I have three modules, A, B, and C. A depends on B and C. ghc --make -main-is A does not make an executable. Do I need another incantation?
01:18:50 <cjs> -o?
01:19:45 <jbapple> Ah! That helped me find the typo which was the source of the problem!
01:19:48 <jbapple> Thanks, cjs.
01:36:11 <xrfang> instance of a typeclass is a type or a typeclass?
01:36:44 <quicksilver> a type.
01:36:49 <quicksilver> types belong to classes
01:36:53 <quicksilver> or, "types are instances of classes"
01:38:06 <DrSyzygyFR> Whoa!
01:38:07 <DrSyzygyFR> 200M of profiling data!
01:38:32 <wli> DrSyzygyFR: From Grobner basis code?
01:39:24 <DrSyzygyFR> Yup!
01:39:37 <DrSyzygyFR> Ran one computation overnight, and now I've updated the code, and would need to restart it.
01:39:51 <DrSyzygyFR> So before I restart it, I figured I could run hp2ps on the profiling output...
01:39:54 <DrSyzygyFR> And ... well ...
01:40:26 <younder> Is there any good style guide in Haskell?
01:41:09 <wli> DrSyzygyFR: Are you doing something intelligent like Faugere F4?
01:41:26 <younder> I take that as a no.
01:41:51 <wli> younder: I wish. Something to follow would be nice.
01:43:47 <quicksilver> younder: there is a style guide. I don't know if it's any good.
01:44:53 <younder> In Common Lisp Peter Norwig (now technical director of Google) wrote a series of slides called the luv-slides which described good Lisp style.
01:45:52 <quicksilver> http://www.haskell.org/haskellwiki/Programming_guidelines
01:45:56 <Axman6> i think that the syntax rules determine the style quite a lot
01:45:57 <quicksilver> http://haskell.org/haskellwiki/Category:Style
01:46:11 <quicksilver> and also http://urchin.earth.li/~ian/style/haskell.html
01:46:27 <younder> Thanks.
01:48:34 <xrfang> can I do parameterized instance? i.e.
01:48:54 <DrSyzygyFR> wli: Faugere F4?
01:49:04 <xrfang> instance YesNo a
01:49:06 <xrfang>   case
01:49:08 <xrfang>     a :: Int
01:49:09 <xrfang>      
01:49:12 <xrfang> a :: Float
01:49:15 <xrfang> ...
01:49:15 <wli> DrSyzygyFR: A Grobner basis computation algorithm.
01:49:15 <DrSyzygyFR> Ah.
01:49:17 <DrSyzygyFR> Not yet.
01:49:22 <xrfang> that sort of definition
01:49:25 <DrSyzygyFR> This is so far a proof-of-concept implementation.
01:49:55 <wli> DrSyzygyFR: Basic Buchberger?
01:50:01 <quicksilver> xrfang: well, I think you can do what you're trying to do.
01:50:07 <DrSyzygyFR> wli: Thing is .. I'm not "just" doing multivariate Grobner bases. I'm not even "just" doing noncommutative Grobner bases.
01:50:08 <quicksilver> xrfang: but what you wrote appears to be nonsence.
01:50:14 <DrSyzygyFR> I'm doing Grobner bases on trees, essentially.
01:50:17 <quicksilver> instance YesNo Int where a = "yes"
01:50:22 <xrfang> quicksilver: this is sort of fake code
01:50:23 <quicksilver> instance YesNo Float where a = "No"
01:50:26 <DrSyzygyFR> So yeah, so far I'm doing basic Buchberger.
01:50:29 <quicksilver> is that what you mean?
01:50:41 <quicksilver> actually those 'a's should have parameters.
01:50:43 <xrfang> I just want to know if I can define a class for many types at once
01:51:14 <quicksilver> No.
01:51:21 <quicksilver> unless they are parametric types.
01:51:23 <xrfang> quicksilver: in your example, I tried to write ... instance YesNo a where a :: Int ...
01:51:32 <xrfang> ok, thanks quick silver
01:51:36 <quicksilver> instance YesNo (Foo x) => ...
01:51:48 <quicksilver> defines YesNo for all Foo, irrespective of x
01:51:57 <quicksilver> xrfang: it might help to understand why you would want to do that
01:52:29 <DrSyzygyFR> Dang, hp2ps gets slow with lots of data!
01:52:34 * DrSyzygyFR is growing impatient!
01:52:45 <xrfang> quicksilver: no no, I have no purpose, just study haskell syntax, what can I do what can't. and if I can, what is the right syntax to do so. In this example, I try to save some typing only, or make the code shorter...
01:53:32 <DrSyzygyFR> Skimming through the prog.prof though I don't think the graph will tell me anything I don't already know...
01:54:46 <dcoutts> quicksilver: opengl was always in the platform
01:55:04 <wli> DrSyzygyFR: What do you already know?
01:55:27 <quicksilver> dcoutts: I'm sure I remember whining and shouting that it wasn't intended to be in the first version.
01:55:37 <quicksilver> dcoutts: I wouldn't have been so unreasonable and childish for no reason, would I?
01:55:40 <quicksilver> ;)
01:55:43 <xrfang> in class definition, I consider this is complete:
01:55:45 <xrfang> instance YesNo Int where
01:55:46 <xrfang>   yesno 0 = False
01:55:48 <xrfang>   yesno _ = True
01:55:49 <xrfang> but, what if I write:
01:55:51 <xrfang>   yesno 0 = False
01:55:52 <dcoutts> quicksilver: heh. You're right, there was talk of that many months ago.
01:55:52 <xrfang>   yesno 1 = True
01:55:54 <xrfang> this way, it is not defined for 2.., is it considered a compile time error or runtime error?
01:56:02 <quicksilver> xrfang: runtime.
01:56:10 <quicksilver> xrfang: although you can ask for a warning if you want
01:56:11 <xrfang> thanks quicksilver :)
01:56:12 <dcoutts> quicksilver: OpenAL and ALUT are probably out though, at least for the first release.
01:56:34 <quicksilver> dcoutts: *nod* I saw that. Much less widely used, I believe.
02:03:57 <DrSyzygyFR> WHOA!
02:04:13 <DrSyzygyFR> It used to be my program spent over 50% of its time just walking up and down trees to generate the things it compares stuff by.
02:04:16 <DrSyzygyFR> No more!
02:05:09 <quicksilver> now it pays a monkey to walk up and down trees and it chills out with a cool beer?
02:05:17 <quicksilver> that's economic evolution in action.
02:05:28 <mnislaih> ping kosmikus
02:06:03 <xrfang> 2 questions about ghci:
02:06:05 <xrfang> 1)
02:06:06 <xrfang> let a = 3
02:06:08 <xrfang> :t a
02:06:09 <lambdabot> Expr
02:06:09 <xrfang> gives Integer why not Int? what is the rule for this inference here?
02:06:11 <xrfang> 2)
02:06:12 <xrfang> let a = 3
02:06:14 <xrfang> let a = 4
02:06:15 <xrfang> does not give an error, but in FP, variable should be immutable, a=3 why it can be reassigned to 4?
02:06:17 <xrfang> tks!
02:06:48 <wjt> xrfang: the second 'a' shadows the first
02:06:59 <wjt> > let a = 3 in let a = 4 in a
02:07:00 <lambdabot>   4
02:07:12 <Axman6> not in ghci, it replaces the definition of a (afaik)
02:07:12 <wjt> > let a = 3 in (let a = 4 in a) + a
02:07:14 <lambdabot>   7
02:07:29 <xrfang> this makes sense, so it only works with the "let" syntax, right?
02:07:45 <quicksilver> every let introduces a fresh variable
02:07:50 <Ferdirand> the point is that re-letting a variable will not affect code previously entered
02:07:54 <quicksilver> it merely happens to have the same name as an old one.
02:08:15 <xrfang> but after that I can never reference the "old version" of a, correct?
02:08:19 <quicksilver> xrfang: and to answer your first question, haskell has defaulting rules for numbers.
02:08:24 <quicksilver> xrfang: unless you saved a reference before
02:08:28 <quicksilver> directly or indirectly.
02:08:41 <xrfang> quicksilver, "numbers" you mean literal digits, right?
02:08:54 <quicksilver> the standard defaulting rules default fractionals to Double and non-fractionals to Integer.
02:09:00 <quicksilver> No, not really.
02:09:08 <quicksilver> I mean any polymorphic Num a => a
02:09:16 <quicksilver> (including, but not only, literal digits)
02:09:16 <xrfang> ok
02:09:31 <quicksilver> you can change defaults
02:09:38 <quicksilver> although that's a seldom-used corner of haskell syntax.
02:10:06 <xrfang> quicksilver, you mean change defaults by ghc(i) command line switch  or by some haskell expression?
02:12:18 <doserj> by a declaration like: default (Int, Float)
02:13:59 <xrfang> I did this and load into ghci:
02:14:01 <xrfang> class YesNo a where
02:14:03 <xrfang>   yesno :: a -> Bool
02:14:04 <xrfang>   
02:14:07 <xrfang> instance YesNo Integer where
02:14:07 <xrfang>   yesno 0 = False
02:14:09 <xrfang>   yesno _ = True
02:14:11 <xrfang> but it says yesno is not in scope while I try to do yesno 3
02:15:22 <xrfang> why is this?
02:15:45 <Axman6> > 5404319552844595/(2^53)
02:15:47 <lambdabot>   0.6
02:16:02 <Axman6> > 5404319552844595/(2^53) :: CReal
02:16:03 <lambdabot>   0.5999999999999999777955395074968691915274
02:16:12 <quicksilver> xrfang: you did somethiing wrong. That should work.
02:16:12 <SubStack> fancy
02:17:47 <Axman6> xrfang: it's all in one file i assume?
02:18:14 <xrfang> quicksilver: it always works except this time... I noticed something strange, in my hs file I have
02:18:16 <xrfang> module Main where...
02:18:17 <xrfang> but after loaded (it says ok) the prompt is still Prelude, but not Main?
02:18:21 <Asztal> is there a way to get ghci to import *everything* in the file you give it?
02:18:34 <ibid> xrfang: how did you load it?
02:18:45 <xrfang> :l t
02:18:47 <xrfang> while my file is t.hs
02:18:48 <quicksilver> did you compile it at some point
02:19:01 <quicksilver> ghci will load the compiled version by default, which is faster, but you don't get all the symbols
02:19:17 <xrfang> oops.  got some error. I try to fix...
02:20:00 <xrfang> sorry I got it wrong. I used :r just now
02:20:02 <xrfang> but it seems that this is not the last file I loaded
02:20:38 <quicksilver> ;)
02:20:53 <quicksilver> Asztal: yes, remove the compiled version
02:21:02 <quicksilver> Asztal: interpretaton makes everything available
02:21:09 <quicksilver> i.e. it ignores the export list.
02:25:36 <paolino> is "return x = lift (return x)" for a monad transformer  ?
02:26:23 <paolino> *the method definition
02:27:38 <paolino> I mean, once the MonadTrans instance is filed
02:27:58 <paolino> is that always true ?
02:28:13 <quicksilver> I believe so.
02:32:19 <paolino> thanks, then return is a specialization of lift in the transformers space
02:35:26 <xrfang> @src Functor Maybe
02:35:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:35:38 <xrfang> @src instance Functor Maybe
02:35:38 <lambdabot> Source not found. Just try something else.
02:36:29 <xrfang> hey... how can I view the source of a type class instance?
02:37:28 <ray> i'm not sure how to get the source of an instance either
02:37:39 <ray> but maybe's fmap makes it into a function on Just x
02:37:49 <ray> > fmap (+1) (Just 1)
02:37:50 <lambdabot>   Just 2
02:37:59 <Asztal> @src Maybe fmap
02:38:00 <lambdabot> fmap _ Nothing       = Nothing
02:38:00 <lambdabot> fmap f (Just a)      = Just (f a)
02:38:12 <ray> thanks
02:39:07 <quicksilver> paolino: not quite sure specialisation is the word I'd use.
02:39:20 <quicksilver> paolino: but return === lift . return is I suppose a "transformer law"
02:43:21 <xrfang> Asztal: the problem is, now do I know there is a fmap in the instance Functor? (of course unless I read it somewhere or someone told me)
02:43:51 <doserj> @src Functor
02:43:52 <lambdabot> class  Functor f  where
02:43:52 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
02:43:56 <xrfang> I expect @src or something, as a reseach or study aid to tell me the src of instance Functor a, as it tell me src of a function
02:44:16 <xrfang> doserj: thanks :p
02:44:29 <xrfang> also tks Asztal,
02:44:32 <doserj> :i in ghci is also very helpful
02:44:45 <xrfang> I should do @src Maybe fmap, not @src Functor Maybe :)
02:45:08 <xrfang> but ghci does not have @src equivalence, does it?
02:45:55 <quicksilver> xrfang: No. However the online library docs contain not only extensive documentation but full, colourful, HTML source.
02:46:10 <xrfang> thanks.
02:46:18 <quicksilver> xrfang: "@src" is a totally arbitrary lambdabot command which contains some things and not others entirely at random.
02:46:36 <quicksilver> and in many cases it is not the actual source.
02:46:46 <xrfang> ok
02:47:02 <xrfang> btw,.... is there library functions defined in C not in haskell? :)
02:47:06 <xrfang> (for speed ...)
02:48:17 <quicksilver> yes.
02:48:24 <quicksilver> well, not generally in C.
02:48:39 <quicksilver> defined in C-- or directly as primops for the code generator.
02:48:48 <quicksilver> for example (+)
02:59:34 <quicksilver> mitrofanov++ # "However, my goals are more limited -- I'd like to be able to take an elephant and turn it into a grown-up hippo"
02:59:37 <quicksilver> genius.
03:02:05 <ivanm> quicksilver: do I dare ask the context of that?
03:03:06 <quicksilver> ivanm: someone said "I don't want a haskell DSL for javascript, I just want to compile the full haskell language to javascript"
03:03:25 <ivanm> >_>
03:03:41 <BONUS> good luck with that
03:04:02 <quicksilver> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/57618/focus=57619
03:04:15 * wli is thinking something to do with modules.
03:05:10 <wli> Maybe a CPO-STV CGI thing.
03:05:43 <wli> Or something having to do with taking the n-th roots of numbers in radical extensions of Q.
03:14:00 <bremner> quicksilver: I should be possible. Javascript is turing complete afaik. It might be more fun to compile Haskell to vi macros, which I heard are also turing complete
03:14:45 <quicksilver> bremner: I'm not suggesting it's impossible; I'm just suggesting it's considerably harder than a DSL for javascript generation.
03:14:59 <quicksilver> writing a haskell compiler - or attaching a new backend to an existing compiler - is hard work.
03:15:33 <bremner> quicksilver: sorry my troll was not obvious enough and you wasted good brain cells responding :-)
03:16:08 <Asztal> try compiling to brainfuck!
03:16:39 <ivanm> or not
03:16:57 <Asztal> there's a gcc-bf project :D
03:17:20 <ivanm> Asztal: so just because they're stupid, we should be as well?
03:17:53 <wli> Try more interesting source language semantics.
03:17:59 <wli> Like logic languages.
03:19:26 <kosmikus> mnislaih: pong
03:19:58 <quicksilver> the trick is to compile to piet, but impose aesthetic requirements.
03:20:17 <quicksilver> e.g. a compile flag which mandates 'likely to be accepted by new york's MOMO'
03:20:22 <quicksilver> MoMA
03:20:24 <quicksilver> whatever it's called.
03:21:24 <mnislaih> kosmikus: two students from our research group will be joining the Utrecht summer school. Is the number of places limited ?
03:21:56 <kosmikus> mnislaih: yes, it is
03:22:17 <mnislaih> kosmikus: how many? is it very tight?
03:23:03 <kosmikus> mnislaih: are they paying, or will they apply for a scholarship?
03:23:18 <mnislaih> the first probably
03:23:29 <kosmikus> mnislaih: then their chances are rather good
03:23:38 <mnislaih> kosmikus: thanks
03:23:51 <ivanm> kosmikus: because paying customers > freeloaders? :p
03:25:08 <kosmikus> well, yeah, we have a large number of applications, but many of them seem to be conditional on getting a scholarship, and we can't give too many scholarships. so most of the selection will probably happen among those.
03:33:39 <paolino> anyone can help with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4397#a4397, please ?
03:35:01 <paolino> code compiles, but test1is broken
03:35:02 <quicksilver> paolino: what's the problem?
03:35:21 <paolino> *Signal> :t test1
03:35:21 <paolino> test1 :: (Num b, Num s, MonadState s (SignalT (State b))) =>
03:35:21 <paolino>          t -> (((), Bool), b)
03:35:59 <paolino> the MonadState constraint is not showing up in test2
03:36:01 <quicksilver> yes, you need a MonadState instance for SignalT
03:36:14 <quicksilver> there already is a MonadState insce for WriterT
03:37:39 <paolino> does it means really I cannot stack a transfomer on an unknown monad ?
03:38:21 <paolino> :t modify
03:38:22 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:39:57 <quicksilver> you have to write the lifting instances for all the MonadFoo classes.
03:40:05 <quicksilver> they're boring and mechanical.
03:40:10 <quicksilver> This is considered one of the problems with the MTL.
03:40:36 <paolino> they are not derivable
03:42:19 <paolino> mhh, so it's not possible to even write "core" monads without a class containing all their functions
03:42:34 <quicksilver> yes it is.
03:42:38 <quicksilver> you don't have to use the classes.
03:42:53 <quicksilver> you can use lift . lift . happy . happy . joy . lift . lift . lift
03:42:58 <quicksilver> however, the classes do make it less painful :P
03:43:09 <paolino> right
03:44:41 <paolino> the problem is really making "outer" transformer polymorphic on the cores without exporting constructors
03:46:08 * osfameron sees a haskell job on jobserve.com, falls over
03:46:45 <osfameron> ok, it's for London, but still, don't think I saw a job when I searched there either ;-)
03:50:21 <osfameron> http://jobserve.com/WCBFB06BB0ADE57FD.jsjob if anyone's interested.  45K+ for London seems more like "Senior Dev" than "Niche consultancy" level... though I guess the "can has Haskell" bonus is nice.
03:51:12 * ski hands quicksilver the missing `joy'
03:52:37 <ski> another irritation is e.g. in `StateT s0 (StateT s1 m)' you must use `lift' to access `s1'
03:53:47 <quicksilver> that's a more substantial problem.
03:54:09 <quicksilver> btu IMO it's best handled by "newtype SkiT m= StateT s0 (StateT s1 m)
03:54:21 <quicksilver> and defining new names for get and lift . get, at the SkiT level.
03:54:32 <da-x> what's the meaning of an empty data declaration, e.g. just 'data X' ?
03:54:43 <quicksilver> I think complex monad stacks probably deserve their own names for combinators
03:54:48 <quicksilver> rather than just using 'get' et al.
03:54:48 <mun> hi
03:54:53 <mun> is cmd a builtin function?
03:56:05 <quicksilver> da-x: it's a type with no proper members, used e.g. for a tag in a GADT or similar.
03:56:11 <ski> quicksilver : i would like a way of defining labels for the different states, and use those when using `get',`put' ..
03:56:34 <ski> (or at least being able to use them, when it would otherwise be ambiguous)
03:57:06 <quicksilver> that sounds quite easy using phantom types.
03:57:12 <ski>   StateT (foo :: s1) (ContT o (ListT (StateT (bar :: s1) m)))
03:57:19 <quicksilver> MonadState m s l | l -> s
03:57:30 <quicksilver> note that l determins s, but m does not.
03:57:37 <quicksilver> use type-labels for l.
03:57:41 <ski> then being able to use `foo',`bar' as labels for "pieces of the whole monadic effect" (in this case states)
03:59:31 <ski> ok .. that's not lightweight, though :/
04:00:41 * ski . o O (  (foo :: StateT s1) (ContT o (ListT ((bar :: StateT s1) m))) .. ? )
04:04:56 <quicksilver> ski: why not?
04:05:16 <ski> you have to define the type labels explicitly
04:06:00 <quicksilver> well if you want the type system to be able to see it
04:06:06 <quicksilver> so the compiler can choose the right instance at compile time
04:06:08 <quicksilver> then, yes.
04:07:00 <paolino> :t lift  . local
04:07:02 <lambdabot> forall (t :: (* -> *) -> * -> *) r (m :: * -> *) a. (MonadReader r m, MonadTrans t) => (r -> r) -> t ((->) (m a)) (m a)
04:07:04 <ski> yes, if you represent the label with a concrete type, obviously you have to define that type somewhere
04:07:41 <paolino> mh, I cannot lift local, it seems
04:07:43 <ski> paolino : i don't think you can do that generically (at least with the current abstractions)
04:08:08 <ski> paolino : because `local' takes an monadic action (that we'd like to lift as well), as *input*
04:08:37 <paolino> :t lift  . listen
04:08:38 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a w. (MonadWriter w m, MonadTrans t) => m a -> t m (a, w)
04:08:48 <ski> (quicksilver : i was wondering if there might be a better solution, allowing a type system extension)
04:08:55 <ski> @type listen
04:08:56 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
04:09:04 <ski> same thing
04:09:06 <paolino> :t local
04:09:07 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
04:09:13 <Deewiant> ?ty (lift .) . local
04:09:14 <lambdabot> forall (t :: (* -> *) -> * -> *) r (m :: * -> *) a. (MonadReader r m, MonadTrans t) => (r -> r) -> m a -> t m a
04:10:01 <paolino> lift . listen seems ok to me
04:10:24 <paolino> not really
04:10:34 <ski> i was thinking you were after an operation of type
04:10:53 <ski>   (MonadTrans t,MonadReader r m) => (r -> r) -> t m a -> t m a
04:10:58 <paolino> right
04:11:38 <paolino> so I must implement MonadReader and MonadWriter  for a transformer
04:11:52 <ski> e.g. it would be nice if we could do an `instance (MonadTransf t,MonadReader r m) => MonadReader r (t m)'
04:12:14 <ski> instead, we have to special case this, for every (appropriate) `t'
04:12:27 <ski> (s/Transf/Trans/)
04:12:46 <EvilTerran> ski, that'd overlap the instance Monad m => MonadReader r (ReaderT r m), wouldn't it?
04:12:59 <ski> obviously, yes
04:13:26 * EvilTerran considers "ReaderT r (Reader r')"
04:13:37 <ski> (which was related to me wanting to use some kind of labels to distinguish different instances of the same monadic effect in a transformer stack)
04:14:30 <EvilTerran> ski, well, you can do that with RWS-like effects with a newtype...
04:14:36 <da-x> quicksilver: okay, so 'data X' is the same as 'data X = X', right?
04:15:14 <ski> EvilTerran : yes .. but that's not what i wanted here
04:15:18 <ski> da-x : no
04:15:26 <EvilTerran> newtype Foo = Foo Int; ... StateT Foo (MaybeT (State Int)) ... -- kinda thing
04:15:39 <quicksilver> da-x: data X = X gives the data type one canonical member
04:15:45 <quicksilver> da-x: data X gives it no proper members
04:15:50 <quicksilver> just the boring _|_
04:15:56 <SamB> yeah, I think the general consensus is that you create a newtyped monad or transformer that wraps up the Reader/Writer/State-ness and exposes what you actually want from the monad/monadT
04:15:58 <ski> da-x : there is a GHC extension that allows `data X' to define `X' with no constructors at all
04:16:24 <ski> da-x : also, iirc, in documentation, if `X' is exported abstractly, that might be indicated with `data X'
04:16:29 <ski> (a bit confusing, imo)
04:17:33 <da-x> ski,quicksilver: okay, so if it has no canonical members it means that it cannot be constructed and therefore it can only be used in type checking, as in GADT?
04:18:05 <quicksilver> yes.
04:18:10 <ski> da-x : well, it has no proper values, right
04:18:13 <quicksilver> it's a tag for doing tricks with the type checker.
04:18:21 <quicksilver> an example is 'E6' used in Data.Fixed
04:18:23 <ski> you can still say `error "foo !" :: X' and pass that around
04:18:23 <SamB> if not for the _|_, you could use it in negation proofs
04:18:37 <quicksilver> which indicates a fixed point with a divisor of 1000000
04:19:37 <SamB> (you can do that in strict languages -- of course, it works best with ... darn it, I forgot the word for that kind of types ...)
04:20:08 * SamB wonders if this is related to his concussion
04:20:29 <EvilTerran> quicksilver, eek, different meaning of fixed point to what we usually have in here :P
04:21:38 <ski> SamB : let's say i want to make such an abstract monad. then i want to be able to implement my primitive operations on it using `get',`put', et.c. .. the trouble is if the internal type looks like `ReaderT r0 (ContT o (ListT (ReaderT r1 m)))' .. then i can't use `local' to access `r1' .. and i can't directly use `lift' either
04:22:35 <ski> (the stuff between the two `ReaderT ..'s is supposed to be anything that ensures that we can't just merge the two `ReaderT ..' into a single one)
04:25:20 * da-x tries to read and understand the entire code of hpaste, which is considered a good example for a real-world haskell usage.
04:29:46 <haoyu> hi, when I parsing Haskell source code by calling GHC API, I got "Parse: noRebindableInfo". Any ideas? Thanks!
04:45:05 <paolino> anyone can review my MonadFoo instances http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4397#a4399, please
04:45:23 <paolino> the pass method looks very wrong
04:51:45 <paolino> not that I use censor function so often :)
04:52:23 <quicksilver> :t pass
04:52:25 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
04:53:26 <quicksilver> I think your definition of pass is indeed wrong.
04:54:03 <quicksilver> I'm not sure what's right though.
04:55:43 <paolino> listen is ok
04:55:47 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/mtl/src/Control-Monad-State-Lazy.html
04:55:52 <quicksilver> have a look at the definiton of 'pass' there
04:55:54 <quicksilver> that looks better.
04:57:47 <paolino> oh, the pass goes outside, isn't the same ?
04:59:26 <quicksilver> yes, it looks more like I'd expect.
05:00:41 <paolino> from estethic point of view ?
05:01:00 <paolino> I'm confused
05:02:13 <quicksilver> no, from a logical point of view.
05:02:35 <quicksilver> your version was doing pass $ return ...
05:02:43 <quicksilver> hmm
05:02:46 <quicksilver> maybe it doesn't matter actualy
05:03:42 <ski> if it doesn't matter, one can wonder why `pass' takes a monadic argument at all
05:04:10 <ski> hm ..
05:04:15 <ski> actually
05:04:18 <ski> @type pass
05:04:19 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
05:04:43 <ski> isn't the `w -> w' function supposed to apply *only* the the portion of the output produced by the argument action ?
05:05:00 <quicksilver> that is what I have always assumed.
05:05:15 <quicksilver> I never really understood what the point was of an action which produced its own rewrite
05:05:28 <ski> so `m >>= \((x,f),b) -> pass (return ((x,b),f))' will then always pass `mempty' to `f'
05:05:28 <sioraiocht> @src foldr
05:05:29 <quicksilver> if it's producing its own rewrite why can't it rewrite itself?
05:05:29 <lambdabot> foldr f z []     = z
05:05:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:05:30 <quicksilver> so to speak.
05:05:33 <paolino> how could it be different ?
05:05:45 <quicksilver> pass :: (w -> w) -> m a -> m a
05:05:51 <quicksilver> is the type I would personally expect.
05:05:58 <ski> @type censor
05:05:59 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
05:06:20 <quicksilver> good point.
05:06:30 <paolino> i meant how could it be different from "﻿isn't the `w -> w' function supposed to apply *only* the the portion of the output produced by the argument action"
05:06:47 <ski> there might be some use case / argumentation for this greater(?) generality in some paper, i suppose
05:07:48 <ski> hm .. could you implement `pass' in terms of 'censor' ?
05:07:55 <ski> (and `listen' if needed)
05:08:08 <EvilTerran> you could implement censor in terms of pass, i think
05:08:20 <ski> yes, that's almost obvious
05:09:01 <quicksilver> :t listen
05:09:02 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
05:09:18 <ski> @type \f -> pass (liftM (flip (,) f) ma)
05:09:20 <lambdabot> Not in scope: `ma'
05:09:24 <ski> @type \f ma -> pass (liftM (flip (,) f) ma)
05:09:26 <lambdabot> forall a1 w (m :: * -> *). (MonadWriter w m) => (w -> w) -> m a1 -> m a1
05:10:47 <ski> @type \maf -> liftM (\((a,f),w) -> (a,f w)) (listen maf)
05:10:48 <lambdabot> forall t t1 t2 (m :: * -> *). (MonadWriter t1 m) => m (t, t1 -> t2) -> m (t, t2)
05:10:58 <ski> not quite
05:11:01 <paolino> the point is when (w -> w) is *only* monadically computable
05:11:09 <ski> yes
05:12:03 <quicksilver> e.g. WriterT IO (a, w -> w)
05:12:10 <quicksilver> this action does some logging
05:12:20 <quicksilver> and also asks the user for a description of which function to use
05:12:24 <quicksilver> to 'censor' the log.
05:13:14 <quicksilver> ski: I think the answer is you can do it with MonadFix.
05:13:30 <quicksilver> ski: with Monad Fix you can 'listen' to the action, and then censor it based on its own return value
05:13:35 <quicksilver> this requires knot-tying though?
05:13:42 <ski> @instances MonadFix
05:13:43 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:13:54 <quicksilver> does that sound plausible?
05:13:57 <ski> note that there's no instance for `Cont o'
05:14:30 <ski> (i think Magnus Carlsson has some paper that argued that it wasn't possible for `Cont o')
05:15:13 <ski> quicksilver : maybe .. i'm not sure
05:17:05 <quicksilver> I've changed my mind.
05:17:19 <quicksilver> censor requires a function which exists before the action is run.
05:19:58 <ivanm> why are you censoring functions?
05:20:11 <ivanm> have people been using impolite language for function names or something?
05:20:11 <ivanm> :p
05:23:22 <xrfang> sorry, what stands for ADT?
05:23:46 <ivanm> xrfang: you mean "what does ADT stand for"?
05:23:52 <ivanm> if so, it's Abstract Data Type
05:24:03 <quicksilver> or Algebraic Data Type
05:24:14 <quicksilver> in a learning haskell context, more likely the second.
05:24:22 <ivanm> true
05:24:31 <ivanm> I'm just used to the first from my pre-haskell days :s
05:24:56 <ivanm> quicksilver: algebraic DT is Foo | Bar, etc.? (i.e. multiple constructors)
05:24:59 <xrfang> sorry ivanm :p
05:25:01 <xrfang> I mean that
05:25:02 <paolino> quicksilver: pass is obscure .
05:26:01 <quicksilver> ivanm: yes.
05:26:33 <paolino> if the instance you point me to is right, then pass is fake, I suppose that instance (like mine) break the point of having pass
05:26:47 <quicksilver> algebraic data type - mixture of sum an product.
05:27:00 <ivanm> so in haskell terminology, do we still call things like [a], Map k a, etc. as abstract data types?
05:27:19 <quicksilver> paolino: the instance in control.monad.state at least calls 'pass' on the whole thing not just a return
05:27:23 <ski> `Map' is an abstract data type (constructor)
05:27:24 <quicksilver> ivanm: [a] is not abstract.
05:27:27 <quicksilver> ivanm: Map is abstract.
05:27:32 <ski> `[]' is not (since we know the constructors)
05:27:35 <ivanm> *nod*
05:27:40 <ivanm> ahhh, duh
05:27:52 <ivanm> I was remembering abstract DT as being a container kind of thing
05:27:57 <ivanm> it's a specification
05:28:12 <paolino> quicksilver: good point
05:28:27 <ivanm> so could we say that classes like Foldable are "meta-abstract" data types?
05:29:31 <ski> paolino : "fake" how ?
05:29:40 <paolino> quicksilver: can you sort out pass code ?
05:29:50 <quicksilver> ivanm: well you can say Foldable is an abstraction.
05:29:53 <paolino> fake as censor is enough
05:30:20 <ski> paolino : please show how to define `pass' in terms of `censor', then
05:30:35 <GoldyOrNugget> > 5 + (6+7)
05:30:36 <lambdabot>   18
05:30:42 <GoldyOrNugget> > 5 + $ 6+7
05:30:44 <lambdabot>   <no location info>: parse error on input `$'
05:30:47 <GoldyOrNugget> why doesn't that work?
05:30:50 <paolino> ski : well, I cannot imagine the semantic of pass
05:31:01 <ski> GoldyOrNugget : because `5 +' is not a valid expression
05:31:23 <ski> GoldyOrNugget : using `$' as an infix operator requires valid expressions on both sides
05:31:36 <GoldyOrNugget> ok, so (5+)
05:31:45 <ski> that works
05:31:47 <GoldyOrNugget> thanks
05:33:46 <paolino> ski: and really now , I'd like to get that semantic :)
05:34:57 <ski> running `pass maf' first runs `maf', returning `(a,f)' and also having various effects, whereof the output effect is `w'. the result value of the whole action is `a', and the result output effect is `f w', all other effects are the same
05:34:58 <quicksilver> the semantic of pass is 'take an action which runs, produces a result, some Writer output, *and* its own censor-style function, and use that to censor itself'
05:35:21 <ski> paolino : that's a rough "intuitive" description of what we want `pass' to do
05:35:24 <quicksilver> it sounds like a natural combination of listen and censor but it appears not to be.
05:35:36 <ski> possibly one can formalize this better, using some laws of `pass'
05:39:25 <paolino> ski: it seems to me that *and* is doable with a sequence of actions
05:40:22 <ski> you're free to show how ;)
05:40:32 <paolino> use that to censor itself is not clear
05:41:12 <paolino> and from the instances I see around seems not true
05:41:27 <ski> @type pas
05:41:29 <lambdabot> Not in scope: `pas'
05:41:32 <ski> <ski> @type \maf -> liftM (\((a,f),w) -> (a,f w)) (listen maf)
05:41:34 <ski> <lambdabot> forall t t1 t2 (m :: * -> *). (MonadWriter t1 m) => m (t, t1 -> t2) -> m (t, t2)
05:41:39 <ski> <ski> not quite
05:41:43 <ski> @type pass
05:41:45 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
05:43:39 <paolino> the only thing I can think of is that ﻿m (a, w -> w) is using pass/listen internally to compute (w -> w) ...
05:44:26 <paolino> *can use
05:46:05 <ali_clark>  I've read that Haskell has a logical type system, this means that in theory everything could be burned away in compilation right down to specific types like Int right?
05:47:27 <ski> > runWriter . pass $ do tell ["hello"]; return (42,reverse) `before` tell ["there"]
05:47:28 <lambdabot>   (42,["there","hello"])
05:47:29 <xrfang> @src putStrLn
05:47:29 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
05:47:39 <xrfang> @src putStr
05:47:40 <lambdabot> putStr s  = hPutStr stdout s
05:47:55 <blackdog> ali_clark: what do you mean, exactly? It all gets translated down to ints... hell, ones and zeroes, really. Do you mean no run-time overhead from types?
05:48:02 <ski> ali_clark : what is "specific types" .. is function types, lists, tuple types "specific" ?
05:48:20 <quicksilver> ski: did you want map reverse, perhaps ?
05:48:23 <blackdog> you can specialise typeclasses away if you have whole-program compilation
05:48:31 <ali_clark> As opposed to having any class constraints i mean
05:48:41 <ski> quicksilver : nah, `reverse' was fine
05:48:52 <xrfang> @src hPutStr
05:48:53 <lambdabot> Source not found.
05:49:00 <blackdog> ... constraints?
05:49:02 <ski> though i suppose i could have done
05:49:13 <ski> > runWriter . pass $ do tell "hello "; return (42,reverse) `before` tell "there"
05:49:14 <xrfang> :t hPutStr
05:49:15 <lambdabot>   (42,"ereht olleh")
05:49:16 <lambdabot> Not in scope: `hPutStr'
05:49:24 <blackdog> are you talking about the model you program in, or what it gets translated to?
05:49:50 <paolino> :t before
05:49:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m a
05:50:05 <ski> <ski> @let before :: Monad m => m a -> m b -> m a; ma `before` mb = do a <- ma; mb; return a
05:50:16 <ski> (i'm not sure if that's in the library)
05:50:28 <ali_clark> blackdog: as I understand it, in theory Haskell could in theory take all "Num a"'s in your program and know whether they should be Int or Double or whatever at compile time
05:50:36 <ali_clark> thats right isn't it?
05:50:44 <ski> (`(<<)' is not it, .e.g)
05:51:01 <paolino> ski, still you don't need to be inside there to build reverse
05:51:20 <blackdog> ali_clark: in the compiled form? Yes, _if_ you have whole program compilation
05:51:26 <ski> ali_clark : yes .. apart from extensions like existentially quantified data types
05:51:50 <blackdog> but if you compile something module by module, for instance, you never get to see how it's used as a whole
05:52:00 * ski wonders whether that holds for non-regular data types as well ..
05:52:13 <blackdog> i think that's why the new crop of compilers like jhc are focusing on whole-program compilation
05:52:18 <ski> (yes, probably)
05:52:28 <paolino> ski, I'm getting the point though, shouldn't listen be enough for that ?
05:52:39 <quicksilver> ski: it's <* in Contorl.Applicative
05:52:46 <ski> ok
05:52:58 <ali_clark> because as i also understand it, the monomorphism restriction wouldn't be necessary if we didn't have class constraints left over...
05:53:17 <ski> paolino : in that simple case, yes .. i was imagining it was more complicated
05:53:30 <paolino> censor reverse . listen
05:53:40 <ski> ali_clark : i think non-regular datatypes will make a problem
05:53:55 <paolino> :t censor reverse . listen
05:53:56 <lambdabot> forall a (m :: * -> *) a1. (MonadWriter [a] m) => m a1 -> m (a1, [a])
05:54:05 <ski>   data Bunch a = Node a (Bunch [a])
05:54:16 <ski>   instance Show a => Show (Bunch a)
05:55:03 <quicksilver> well anywya, the MR *isn't* necessary.
05:55:10 <quicksilver> its about expectations of sharing.
05:55:11 <ski> ali_clark : one value `b' of type `Bunch Int' may contain values of type `Bunch [Int]',`Bunch [[Int]]', et.c. .. you get no finite bound on the number of specific instance you'd need
05:55:23 <quicksilver> it's got nothing to with whether or not you have class constraints lying around after compilation.
05:56:09 <ali_clark> okay i see
05:56:29 <ski> (of course, this is assuming we can implement that instance above ..)
05:57:05 <ski> (which i think we can, since we can infer `Show [a]' from `Show a')
05:58:39 <Toxaris> ali_clark: I guess that you cannot statically resolve all class constraints because of polymorphic recursion
05:59:23 <Toxaris> ali_clark: e.g.   foo (x:xs) = show x ++ show (map NT xs)
05:59:36 <ski> right, forgot about that
05:59:50 <ski> hm
06:00:05 <Toxaris> ali_clark: where NT is a newtype with a show instance of the form   instance Show a => Show (NT a) where show = ... show ...
06:00:12 <ski> what is an example of polymorphic recursion not using a non-regular datatype ?
06:00:34 <ski> s/example/non-trivial example/
06:00:43 <Toxaris> ali_clark: so you have to create the show to use at runtime, because it depends on the length of xs
06:00:55 <ski> (every monmorphic recursion could trivially be considered polymorphic)
06:01:22 <Toxaris> ski: I would consider my foo above non-trivial
06:01:31 <Toxaris> ski: of course, it's not, well, interesting
06:01:33 <quicksilver> foo (x:xs) = show x ++ show (map ((,) x) xs)
06:01:39 <quicksilver> is fairly interesting I think
06:02:03 <ski> which is the recursive function, here ?
06:02:10 <quicksilver> sorry. s/foo/show/
06:02:20 <Toxaris> yeah same for mine of course :)
06:02:53 <ski> ok, ty
06:03:59 <quicksilver> > let foo :: Show a => [a] -> String; foo[] = []; foo (x:xs) = show x ++ foo (map ((,) x) xs) in foo [1,2,3,4]
06:04:01 <lambdabot>   "1(1,2)((1,2),(1,3))(((1,2),(1,3)),((1,2),(1,4)))"
06:04:06 <quicksilver> note that ghci can't infer this type.
06:04:11 <quicksilver> although it is, in principle, inferrable.
06:04:59 <ali_clark> this is all reasonable and thanks for explaining it, but tbf haskellers shouldn't write things like "type signatures are optional" and "the type system is logical and could be compiled away" - its true, some of the time but definitely not all the time
06:05:20 <quicksilver> ali_clark: the sense in thich the type system is compiled away is that types are not there at runtime.
06:05:34 <quicksilver> ali_clark: at runtime there is no information about which values have which type.
06:05:45 <quicksilver> although there is plenty of information which, in one sense or another "came from" the type system.
06:05:48 <Botje> type signatures are optional _most of the time_
06:05:59 <Botje> there are cases where you _HAVE_ to supply a type
06:06:12 <quicksilver> that's what type erasure means, and it's quite a commonly used meaning of 'types compiled away'
06:07:03 <Toxaris> of course, type classes can be implemented by dictionary passing, which is a variant of first class function passing, which can be compiled into data structure passing by defunctionalization, so you havn't that much left of your type classes
06:07:27 <Toxaris> in this context: http://community.haskell.org/~ndm/firstify/
06:08:07 <chr1s> dcoutts_: you should open up the comments for the "Hello world" entry.
06:10:43 <jeffersonheard> @seen dons
06:10:43 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 12h 54m 19s ago.
06:11:21 <earthy> hmm...
06:11:34 <mib_qxr4ul> hi
06:11:35 * earthy is baffled by 3 lines of Haskell..
06:11:47 <mib_qxr4ul> does anybody knows how to do lambdabot here?
06:11:50 <jeffersonheard> earthy, that's not often hard
06:12:27 <earthy> roughly they read   Debug.Trace.trace "Foo" $ do { modify $ modifier;  trace "Bar" $ return $ baz }
06:12:39 <earthy> now upon running the code I do get to see Foo but not Bar
06:13:01 <vixey> what does running the code mean
06:13:10 <earthy> apply the function to input
06:13:18 <vixey> that's not a function
06:13:23 <jeffersonheard> earthy, you should see it if you force the value baz that's returned
06:13:56 <earthy> jeffersonheard: but doesn't the trace around the do getting forced imply the return being forced as well?
06:14:22 <jeffersonheard> that is, in the calling fn, do { baz <- functionThatReturnsBaz; print baz }
06:14:31 <earthy> or is it even lazier?
06:14:36 <jeffersonheard> the trace is supposed to have no effect on the running program at all
06:14:46 * earthy nods
06:14:51 <earthy> that I understand :)
06:15:05 <ski> > "mib_qxr4ul"
06:15:07 <lambdabot>   "mib_qxr4ul"
06:15:29 <jeffersonheard> however, no...  the trace around it getting forced only implies the IO BazType, not the execution of it
06:15:37 <ski> > reverse "mib_qxr4ul"
06:15:39 <lambdabot>   "lu4rxq_bim"
06:15:58 <earthy> hm. it's not in IO though, it's in State
06:16:13 <jeffersonheard> well, then m BazType
06:16:19 * earthy nods
06:16:19 <jeffersonheard> shouldn't matter
06:16:32 * earthy ponders
06:16:41 <earthy> I do an evalState around it...
06:16:51 <earthy> that's lazy then as well
06:16:53 <earthy> hm...
06:17:10 <jeffersonheard> I think there's a strict State monad lying around somewheres
06:17:20 <earthy> that might help yeah.
06:17:46 <ski> Control.Monad.State.Strict
06:17:54 <earthy> oh, great. now I get even less trace output :)
06:19:52 <jeffersonheard> hrm.  not sure why.
06:20:37 <earthy> well... the BazType I'm building is a graph. displaying the graph does not necessarily force everything in the input in the same order
06:22:51 <paolino> > :t \m f t -> listen m >>= \x -> (censor (f x)) t
06:22:52 <lambdabot>   <no location info>: parse error on input `:'
06:23:01 <paolino> :t \m f t -> listen m >>= \x -> (censor (f x)) t
06:23:02 <lambdabot> forall a w (m :: * -> *) a1. (MonadWriter w m) => m a -> ((a, w) -> w -> w) -> m a1 -> m a1
06:23:36 <paolino> ski: this is what we have tried till now , right ?
06:29:16 <Botje> screen -Ux
06:30:08 <burp_> ?src cosh
06:30:09 <lambdabot> Source not found. There are some things that I just don't know.
06:30:12 <burp_> :|
06:30:24 <dolio> cosh is a method in a type class.
06:30:49 <dolio> Not that it'll have the individual definitions, either.
06:30:54 <dolio> @src Float cosh
06:30:55 <lambdabot> Source not found. Where did you learn to type?
06:31:00 <burp_> ok
06:31:08 <dolio> They wouldn't be useful anyway.
06:31:16 <burp_> I just wondered if that was implemented with exp or in some other way
06:31:31 <dolio> They're like "cosh = coshFloat" and then "coshFloat (F# f#) = coshFloat# f#".
06:31:54 <dolio> I think, at least. It's possible the hyperbolic ones are exp implemented.
06:32:33 <burp_> maybe even the cpu has build in hyperbolic functions
06:32:59 <burp_> well, not important
06:32:59 <dolio> Nope, they're primitive.
06:33:24 <dolio> acosh is implemented in terms of log, sqrt and arithmetic, though, interestingly enough.
06:35:03 <dolio> I guess the inverse hyperbolic functions aren't important enough to deserve their own primops.
06:35:59 <Axman6> :t cosh
06:36:00 <lambdabot> forall a. (Floating a) => a -> a
06:36:08 <Axman6> @src Floating
06:36:08 <lambdabot> class  (Fractional a) => Floating a  where
06:36:08 <lambdabot>     pi                                                      :: a
06:36:08 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
06:36:08 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
06:36:08 <lambdabot>     (**), logBase                                           :: a -> a -> a
06:36:53 <blackh> Does anyone know how to get cabal to do a parallel build?
06:37:10 <Axman6> @check \x -> cosh x == (recip . cos) x
06:37:11 <lambdabot>   "Falsifiable, after 0 tests:\n-2.0\n"
06:37:35 <Axman6> that's acos isn't it, my bad
06:37:49 <Axman6> blackh: don't think you can :\]
06:37:52 <Axman6> -]
06:38:18 <blackh> Axman6: Bottom!  Thanks.
06:39:40 <dolio> 1/(cos x) = sec x
06:41:01 <dolio> acos is the inverse of cos, that is: cos (acos x) = x, as long as you stay within the domain of acos.
06:41:46 <dolio> acos (cos x) = x, too, as long as you stay within the range of acos.
06:42:02 <dolio> Of course, all up to possible floating point error.
06:42:15 <da-x> does 'msum $ map ..'  with [Maybe] stops evaluation when reaching a Just value?
06:42:34 <dolio> It should.
07:06:34 <conal> da-x: i think the First monoid works that way, not Maybe
07:07:01 <conal> oh -- msum.  nm.
07:07:14 <conal> @type msum
07:07:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:07:19 <conal> @type mappend
07:07:20 <lambdabot> forall a. (Monoid a) => a -> a -> a
07:13:02 <xrfang> @src null
07:13:02 <lambdabot> null []     = True
07:13:02 <lambdabot> null (_:_)  = False
07:13:33 <xrfang> @src words
07:13:33 <lambdabot> words s = case dropWhile isSpace s of
07:13:33 <lambdabot>     "" -> []
07:13:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
07:15:01 <vixey> @quote
07:15:02 <lambdabot> newsham says: C programmers know the cost of everything and the value of nothing.
07:16:06 <vixey> @quote
07:16:07 <lambdabot> SimonRC says: if performance was that important, people would be using perl, python, or the JVM
07:16:18 <vixey> @quote
07:16:18 <lambdabot> scodil says: you say sledgehammer like it's a bad thing
07:21:40 <lizrail> greetings. Does anybody know, what error 'cabal: user error (openTCPConnection: host lookup failure for ""' while running cabal update might mean?
07:22:26 <xrfang> @src isSpace
07:22:26 <lambdabot> Source not found. There are some things that I just don't know.
07:23:47 <xrfang> @src break
07:23:47 <lambdabot> break p =  span (not . p)
07:24:34 <xrfang> @src span
07:24:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:34:04 <vixey> @quote
07:34:05 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
07:34:10 <vixey> @quote
07:34:10 <lambdabot> #perl says: <tech> who needs saneness
07:34:22 <vixey> @quote
07:34:22 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
07:39:58 <vixey> hi
07:40:35 <vixey> I hasked yesterday but anyway, how.. do you implement call-by-name shift/reset?
07:41:24 <byorgey> hasked?  is that like asking a haskell question?
07:41:41 <vixey> YES
07:41:43 <vixey> :D
07:42:11 <byorgey> (I don't know the answer to the question you hasked, though)
07:42:26 <jeffersonheard> is there a way to put my hackage username and password into my cabal config?
07:42:37 <dcoutts> jeffersonheard: yep
07:43:22 <dcoutts> jeffersonheard: if you don't see the fields there already then you've got a config generated by an old version. You can move your existing config out of the way, let it be recreated and merge back your changes.
07:43:24 <ManateeLazyCat> In expression "find bufferIsFocus bufferList", function `bufferIsFocus` is "IO Boo", how to changed above expression to make is pass?
07:43:32 <ManateeLazyCat> IO Bool
07:43:32 <dcoutts> jeffersonheard: the new format is more self-documenting
07:43:57 <vixey> byorgey they were talking about CBN ad CBV versions of CPS transform yesterday
07:44:43 <EvilTerran> ManateeLazyCat, what type is find?
07:44:51 <jeffersonheard> ah ha, that worked
07:44:52 <jeffersonheard> thanks
07:45:07 <ManateeLazyCat> EvilTerran: "bufferString :: Buffer -> IO String"
07:45:21 <ManateeLazyCat> EvilTerran: Find "Buffer"
07:45:44 <ManateeLazyCat> EvilTerran: bufferIsFocus :: Buffer -> IO Bool
07:46:10 * EvilTerran waits for ManateeLazyCat to actually answer the question he asked
07:46:26 <ski> (vixey : and a little today, as well ..)
07:46:48 <hydo> fkey :: Map String Value -> String -> Maybe (Map String Value)  -- If I want to chain multiple calls of this with >>=, how do I handle the arguments?  ie: fkey x y >>= \v -> fkey v "something"  is ugly.  Surely there's a better way that's also the accepted "right" way...
07:46:48 <Saizan_> ?type find
07:46:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:46:52 <EvilTerran> ManateeLazyCat, is this the "find" from Data.List?
07:47:01 <ManateeLazyCat> EvilTerran: Yes.
07:47:24 <ManateeLazyCat> EvilTerran: "find bufferIsFocus bufferList", bufferList is [Buffer]
07:47:33 <EvilTerran> i see
07:47:51 <EvilTerran> ?type mapM
07:47:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:47:54 <ski> vixey : i'd try adding `shift' and `reset' to a CBN nqCPS translation
07:47:57 <ManateeLazyCat> EvilTerran: Have any tips make above expression pass and don't change type of `bufferIsFocus`?
07:47:59 <EvilTerran> could be useful
07:48:43 <Saizan_> hydo: if you've to do that a lot you might consider to use the MaybeT (State (Map String Value)) monad
07:49:35 <hydo> Saizan_: well, maybe I will now.  I can't stand to see fkey x y >>= \s -> fkey s g in my code...
07:49:39 <EvilTerran> ManateeLazyCat, you could use "mapM bufferIsFocus bufferList" (of type IO [Bool]), run that to get a [Bool], and zip that with bufferList
07:50:28 <ManateeLazyCat> EvilTerran: Thanks, i try.
07:51:03 <pk> Has anyone ever got an "freeglut font not found" error when trying to render strings with GLUT ?
07:51:14 <ali_clark> @src putStrLn
07:51:15 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
07:52:33 <pk> Because I have it on 2 differents linux computers, on one I made the installation 1 year ago
07:52:45 <tux-foo> How should I see the typesignature of   \n -> n a ?
07:53:03 <tux-foo> where this is a lambda function.
07:53:11 <pk> and I used only the standard install methods
07:53:14 <Zao> Function of one parameter n, which likely is a unary function.
07:53:21 <tux-foo> with the argument n which somehow returns both n and some a (which is in scope).
07:53:27 <ski> :t \n -> n a   where  a = "false"
07:53:28 <lambdabot> parse error on input `where'
07:53:39 <ski> :t let a = "false" in  \n -> n a
07:53:41 <lambdabot> forall t. ([Char] -> t) -> t
07:53:41 <ManateeLazyCat> EvilTerran: "zip that with bufferList"?
07:54:09 <Saizan_> hydo: if you flip the arguments you can also write fkey y >=> fkey g
07:54:10 <EvilTerran> ?type zip
07:54:10 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
07:54:13 <pk> I tried to re install a few times
07:54:32 <tux-foo> I.e. this:   (\x y-> x*y) 5 6    returns 30
07:54:35 <Saizan_> ?type \fkey y g -> fkey y >=> fkey g
07:54:37 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a -> m a) -> t -> t -> a -> m a
07:54:43 <tux-foo> but how should      (\x y-> x y) 5 6           work?
07:54:46 <tux-foo> it errors
07:54:53 <EvilTerran> ManateeLazyCat, if you zip the [Bool] with bufferList, you'll get a [(Bool,Buffer)], where each Bool corresponds to bufferIsFocus for the buffer in its pair
07:55:05 <tux-foo> are there types for x an y for this to work?
07:55:12 <hydo> Saizan_:  oooo that would work.  Thanks!  I figured that there was something like that somewhere...
07:56:05 <Saizan_> tux-foo: it works only if you make a Num instance for functions
07:56:11 <doserj> > (\x y-> x y) (*2) 6
07:56:12 <lambdabot>   12
07:56:31 <EvilTerran> tux-foo, (\x y -> x y) 5 6 = 5 6
07:56:37 <EvilTerran> so one will work only if the other will
07:57:19 <EvilTerran> and "5 6" doesn't work in haskell, unless you've been getting creative with the type system
07:58:22 <suchsuch> does haskell have fixed point numbers?
07:58:22 <ali_clark> @src putStr
07:58:23 <lambdabot> putStr s  = hPutStr stdout s
07:58:47 <tux-foo> EvilTerran, ah, so I cannot make a function wich expencts two ints and give it (\x y -> y x) 5 6 .
07:58:50 <tux-foo> for example:
07:58:52 <tux-foo> (\x y -> (x,y)) ((\x y -> y x) 5 6)
07:59:02 <tux-foo> which would switch x and y and then tuple it.
07:59:38 <ski> tux-foo : no, because `foo a b' is not the same as `foo (a b)' .. it's the same as `(foo a) b'
08:00:29 <tux-foo> ski kk
08:00:37 <ski> if we could evaluate your expression above, it would evaluate as
08:00:41 <ski>     (\x y -> (x,y)) ((\x y -> y x) 5 6)
08:00:41 <byorgey> suchsuch: what do you mean?
08:00:53 <ski>   = (\x y -> (x,y)) (6 5)
08:01:01 <ManateeLazyCat> EvilTerran: why i need pair?
08:01:02 <ski> but that is not the same as
08:01:10 <ski>     (\x y -> (x,y)) 6 5
08:01:13 <suchsuch> byprgey: fixed point means fixed number of digits after the decimal
08:01:14 <ski> since that is
08:01:21 <ski>   = ((\x y -> (x,y)) 6) 5
08:01:43 <byorgey> suchsuch: ah, yes, check out Data.Fixed
08:01:55 <pk> On 2 differents computers, one year apart, I installed GLUT using ubuntu packages and cabal, and got the same font error. Seems this error is so uncommon google never heard of it
08:02:02 <pk> What's wrong with me ?
08:02:03 <ManateeLazyCat> EvilTerran: Pair is unnecessary for me.
08:02:45 <ManateeLazyCat> EvilTerran: I think best way is modify function `bufferIsFocus` to make it return `Bool` instead `IO Bool`. Thanks!
08:03:25 <byorgey> pk: no idea, but maybe there is some other package(s) you need to install?
08:04:42 <EvilTerran> ManateeLazyCat, if you can do that, then, yes, that'd make most sense
08:04:45 <BlackM> tux-foo: "Cont b a" (i.e., (a -> b) -> b)? :)
08:04:48 <wh1t3> pk whats the error?
08:05:01 <pk> freeglut ; font not found
08:05:46 <pk> (GLUT and Opengl works fine for other graphics, it's just text)
08:06:21 <jeffersonheard> pk, use FTGL, or you could render cairo fonts into a buffer and load as a texture
08:06:43 <Saizan_> maybe you've to specify which font you want in your code?
08:06:56 <tux-foo> ski, ''= ((\x y -> (x,y)) 6) 5''  would continue like:
08:07:11 <tux-foo>  = \y -> (6,y)
08:07:15 <tux-foo>  = (6,5)
08:07:16 <tux-foo> right?
08:07:22 <tux-foo> why does this not happen.
08:07:22 <ski> yes
08:07:37 <tux-foo> I get an instance error of ghci if I fo this.
08:07:48 <ski> because `(\x y -> (x,y)) (6 5)' is different from `((\x y -> (x,y)) 6) 5'
08:07:57 <edwardk> @hpaste
08:07:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:08:11 <ski> generally, `f (a b)' is different from `(f a) b'
08:08:19 <CyberGarp> How do I get the Graphics.Rendering.Cairo library installed on a Mac? I have the cairo libraries installed?
08:08:20 <CyberGarp> .
08:08:20 <ski> (the latter can be shortened to `f a b')
08:08:33 <tux-foo> I know, 'spaces' bind right.
08:08:34 <pk> jeffersonheard: that's what I'm gonna do. Yet I can't believe I made 2 times the same error
08:08:38 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4401#a4401 -- I finally had a use for the "PCofree" noise in category-extras
08:08:50 <ski> tux-foo : no, application ("space") associates to the left
08:09:01 <ski> `f a b' means `(f a) b'
08:09:14 <tux-foo> ski, sorry, my mistabe
08:09:17 <segher> currying is fab!
08:09:50 <ski> segher : and shoenfinkeling ?
08:10:08 <segher> uh wot?
08:10:11 <edwardk> segher: shoenfinkling is fun.
08:10:39 <edwardk> @let shoenfinkel = curry
08:10:40 <lambdabot>  Defined.
08:10:50 <edwardk> @type shoenfinkel id
08:10:51 <lambdabot> forall a b. a -> b -> (a, b)
08:11:06 <edwardk> @let unshoenfinkel = uncurry
08:11:07 <lambdabot>  Defined.
08:11:36 <BlackM> suchsuch: You mean, as in "Data.Fixed" fixed-point? ;)
08:11:36 <edwardk> historical correctness for the win
08:11:49 <segher> heh i see
08:12:01 <BlackM> Bah, dumb time-warp... ;)
08:18:34 <tux-foo> So how can I interprete this function:  \p -> 1 p * 2 p
08:18:37 <tux-foo> it is from:
08:18:41 <tux-foo> http://www.haskell.org/happy/doc/html/sec-using.html#sec-other-datatypes
08:19:07 <tux-foo> I parse it as: given an environment (call stack with variables) calculate 1 * 2
08:19:19 <tux-foo> where 2 for example could also be "34"
08:19:23 <tux-foo> or something like that
08:19:53 <Saizan_> tux-foo: that's not haskell syntax
08:20:02 <tux-foo> I mean: 2 could also be a varible like 'abc'
08:20:11 <tux-foo> Saizan_, Do you understand what it is?
08:20:27 <Saizan_> tux-foo: that's an example of a language for numerical expressions + functions
08:20:57 <tux-foo> Saizan_, yes, I know. But the code between curly braces (more or less) is haskell.
08:22:04 <tux-foo> Saizan_, So for example, what is the returntype of    \p -> $1 p * $3 p   ?
08:22:27 <tux-foo> i.e. it is afunction which goes from a p (and environment) to ...
08:22:41 <tux-foo> *and env...=an env...
08:22:43 <Ferdirand> that looks like a flipped Reader monad
08:22:54 <Saizan_> 'p' is the environment, yes
08:23:17 <Saizan_> and the result type is probably something like Integer
08:23:35 <Saizan_> $1 has the same type there Env -> Integer
08:23:42 <Saizan_> that's why you can apply it to p
08:23:56 <tux-foo> Saizan_, Ah, I see.
08:24:30 <tux-foo> Saizan_, Indeed, makes sense. I could not parse the $1 right. I read them as just an int, but of course, they are \p -> int
08:24:37 <tux-foo> Saizan_, thanx
08:25:08 <Saizan_> np
08:30:11 <edwardk> gah, i just realized henning thieleman pissed all over Data.Accessor as well. -- there goes another library i had thoughts of using
08:30:28 <mun_> is runParser a builtin function? if not, what is a way to find out where it is defined?
08:30:39 <byorgey> edwardk: elaborate, please.
08:30:47 <byorgey> @hoogle runParser
08:30:47 <lambdabot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
08:30:47 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
08:30:47 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
08:31:17 <edwardk> byorgey: he defines all his types as T and classes as C, leading to generally completely illegible haddock for his modules, and worse if you use them, it infects your haddock as well
08:31:28 <byorgey> edwardk: oh, boo =(
08:32:05 <edwardk> http://hackage.haskell.org/packages/archive/data-accessor/0.1.1/doc/html/Data-Accessor-BinaryRead.html http://hackage.haskell.org/packages/archive/data-accessor/0.1.1/doc/html/Data-Accessor-Basic.html
08:32:06 <byorgey> mun_: haskell.org/hoogle is very useful for this sort of thing
08:32:19 <mun_> byorgey, thanks
08:32:40 <edwardk> then modules that use them, even when he goes and defines a 'nice' unqualified import version get stuck with haddock like: http://hackage.haskell.org/packages/archive/data-accessor/0.1.1/doc/html/Data-Accessor-MonadState.html
08:33:11 <byorgey> that's horrendous.
08:33:16 <byorgey> why would anyone do that?
08:33:35 <edwardk> because he hates the haskell module system and tries to treat it like ML
08:33:50 <quicksilver> because they expect you to import everything qualified.
08:34:09 <quicksilver> however, expectations of qualification are not a well abstracted concept/
08:34:20 <ali_clark> @src hPutStr
08:34:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:34:25 <edwardk> quicksilver: i'm willing to deal with that strange quirk, but the second order consequences on usability just make it a non-starter
08:34:52 <edwardk> byorgey: if you want to see it taken to complete absurdity: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude
08:34:58 <Saizan_> oh, i'm going to call all my functions "f" from now on
08:35:09 <ali_clark> @src hGetLine
08:35:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:35:17 <Deewiant> class C a => C a where
08:35:17 <Deewiant> Nice
08:35:23 <centrinia> Why is lambdabot so offensive when someone requests source code that it can't find? :(
08:35:49 <edwardk> centrinia: old behavior that i'm guessing no one has seen fit to root out
08:36:08 <quicksilver> edwardk: second order consequences being what haddock displays? Or you have something else in mind?
08:36:09 <byorgey> centrinia: it's just silly, don't take it personally =)
08:36:56 <segher> @bad bot, no cookie
08:36:57 <lambdabot> Can't find 'bot,'
08:37:03 <byorgey> oh, I see.  In the actual source everything is imported qualified so you have things like  VectorSpace.C, Divisible.C, and so on
08:37:06 <edwardk> quicksilver: the haddock is a pretty big issue to me. personally i find having to import everything qualified rather than recycle the Map trick over and over a lot more burdensome than the alternative
08:37:10 <byorgey> still, that's rather odd.
08:37:31 <byorgey> @slap lambdabot
08:37:31 * lambdabot slaps lambdabot with a slab of concrete
08:37:45 <byorgey> centrinia: you can always do that =)
08:37:53 <edwardk> import Data.Foldable (Foldable); import qualified Data.Foldable as Foldable -- gets the 'T' or 'C' effect pretty well
08:37:55 <centrinia> Okay. =)
08:38:02 <doserj> edwardk: depending on your browser, you can mouse-over the T or C to find out where it links to :)
08:38:16 <quicksilver> edwardk: I think it would be less painful if there was a way for the module author to specify a collection of qualified re-exports.
08:38:18 <edwardk> doserj: yeah, coz thats what i want to do all day ;)
08:38:36 <quicksilver> edwardk: anyhow, I wasn't saying haddock is unimportant. I was wanting to check what you did mean.
08:38:52 <edwardk> quicksilver: there is another pretty glaring problem. i can only define an instance of one of those classes per file, because they commonly use the same names for their methods.
08:39:13 * quicksilver nods
08:39:13 <edwardk> quicksilver: so i'm often forced to use orphan instances if i try to use those modules
08:39:20 <quicksilver> that's very nasty.
08:39:24 <edwardk> the cure is worse than the disease
08:40:57 <edwardk> quicksilver: qualified re-exports would be nice, but thats treading dangerously close to ML ;)
08:41:18 <pumpkin> zomg
08:42:33 <edwardk> pumpkin: started packaging up that origami stuff from the other day, but ran out of time last night
08:42:41 <pumpkin> awesome
08:43:02 <edwardk> http://comonad.com/haskell/Origami.hs -- has what i got through -- i need to flesh out some other methods still
08:43:50 <pumpkin> nice
08:44:07 <edwardk> but it at least has the explicit Mealy and Moore machines, Foldr and Foldr1 and the Arrow and Comonad definitions
08:44:20 <pumpkin> yeah :)
08:44:42 <titusg> what's this function called -- foo f g x = (f x, g x) ?
08:44:44 <edwardk> i also showed that i don't need the Density comonad to make the duplication/extend efficient, but it is needed to make a nice general purpose Fold that works for an arbitrary functor
08:44:53 <pumpkin> &&&
08:45:14 <pumpkin> edwardk: cool, I'm still reading it
08:45:24 <edwardk> > (head &&& tail) [1,2,3]
08:45:26 <lambdabot>   (1,[2,3])
08:46:07 <roconnor> there is a density comonad?
08:46:08 <edwardk> i swapped some args around from the format we talked about the other day just to make it more explicit and to make the type tighter for Foldr1
08:46:15 * roconnor tries to invert the codensity monad
08:46:17 <edwardk> roconnor: sure.
08:46:21 <pumpkin> edwardk: what is the (a -> c) for in -- contravaraiant Yoneda lemma applied to a non-"Functor" functor F a where F a c = F (a -> c -> c) (a -> c)
08:46:21 <pumpkin> data Foldr1 a b = forall c. Foldr1 (c -> b) (a -> c -> c) (a -> c) ?
08:46:22 <roconnor> oh my head
08:46:31 <pumpkin> whoops, pasted too much
08:46:33 <edwardk> roconnor: left kan extension of a functor along itself.
08:46:38 <titusg> pumpkin: edwardk: thx
08:46:50 <edwardk> pumpkin: basically it enforces that you feed it a first element
08:47:07 <edwardk> pumpkin: to keep you from accessing the undefined values in our earlier discussion
08:47:14 <pumpkin> ah, ok
08:47:18 <quicksilver> I love the way edwardk can say things like "left kan extension of a functor along itself." as if that's a simple natural answer without a hint of irony.
08:47:49 <pumpkin> @remember edwardk left kan extension of a functor along itself
08:47:49 <lambdabot> I will remember.
08:48:28 <edwardk> data Lan g h a = forall b . Lan (g b -> a) (h b)
08:48:32 <pumpkin> edwardk: how about
08:48:33 <pumpkin> arr f = f' where f' = Foldr1 f const id
08:48:38 <pumpkin> is that a strictness thing?
08:48:56 <edwardk> thats a typo thing =)
08:49:00 <pumpkin> oh ok :P
08:49:05 <edwardk> i copied it down from arr f = f' where f' = Mealy $ \a -> (f', f a)
08:49:12 <edwardk> and forgot to strip the f' where f' =
08:49:22 <pumpkin> I wonder if hlint would catch that :P
08:49:25 <pumpkin> probably not
08:51:02 <edwardk> the nice thing about Density f is that its a comonad regardless of if f is even a haskell Functor, so I can take the Density comonad of an f-Algebra.
08:51:33 <edwardk> and get a comonad, even though I can't define f-Algebra homomorphisms, etc. safely in haskell.
08:52:27 <edwardk> which yields a comonadic algebra-like construct: data FoldF f b = forall c. FoldF (Algebra f c -> b) (Algebra f c)
08:53:07 <pumpkin> where Algebra a b = a b -> b ?
08:53:14 <edwardk> yeah
08:54:44 <roconnor> @pl (\k -> c (\a ->  (f a) k))
08:54:44 <lambdabot> c . flip f
08:54:51 <edwardk> which clearly can't be made a Haskell Functor, because you need an isomorphism to change 'b' to something else. It can be made an 'ExpFunctor', but really you should use f-algebra homomorphisms to move between f-algebras
08:55:17 * pumpkin watches all the heads explode around the channel
08:55:24 <pumpkin> just before my own head explodes
08:55:43 <edwardk> exploding pumpkin... i wonder if there will still be enough left for pie.
08:55:58 <pumpkin> I'm rotten inside
08:56:15 <roconnor> the codensity monad has the same nice property
08:56:15 <edwardk> anyways if you look at DFoldr i figure i'd use it as a launching off point for the definition of FoldF
08:56:21 <edwardk> roconnor: yep
08:57:09 <edwardk> roconnor: i've been using the density comonad of a comonad to change asymptotics of naive traversals just like you can with the codensity monad.
08:57:36 <pumpkin> I wonder if conal is nal's dual
08:57:54 <roconnor> edwardk: blog post plz
08:57:59 <edwardk> roconnor: to that effect the definitions of futu and histo in Control.Morphism.* are generalized so they can use Density and Codensity transformed (co)free comonads.
08:58:03 <pumpkin> edwardk: blog post plz
08:58:17 <edwardk> roconnor: i was planning on writing a paper on it, but everyone i talked to about it was busy ;)
08:58:51 <roconnor> hmm, but can you apply this to zygohistomorphic prepromorphisms?
08:58:56 <edwardk> roconnor: and i already mentioned it obliquely in my old kan extension posts
08:59:01 <edwardk> roconnor: actually, yes. =)
08:59:09 <pumpkin> awesome
08:59:17 <roconnor> well, you definitely need a blog post in that case :P
08:59:23 <edwardk> roconnor: if you let the signature for a zygohistomorphic prepromorphism float you'll get the more general definition.
08:59:33 <zygohistomorphic> boo, it truncated the rest
08:59:48 <prepromorphism> there
08:59:52 <zygohistomorphic> lol
09:00:36 <roconnor> we have our own Punchchard  and Qwerty comedy team for #haskell
09:00:45 <roconnor> Punchcard
09:01:49 <edwardk> so basically all i'm doing for the FoldF stuff is showing that you can use the codensity comonad to avoid stating silly things like f has to be an instance of 'FunctorZero' or something
09:01:56 <edwardk> er density comonad
09:02:20 <edwardk> can, it should be cosparsity comonad and sparsity monad, silly mathematicians discovering things backwards.
09:02:21 <pumpkin> what would a codensity comonad be?
09:02:32 <roconnor> what a really want is a nice example of making a common problem more efficient using a density comonad transform
09:02:38 <edwardk> well, funny you should mention that
09:02:40 <mun_> when debugging a haskell program, what is the best way to print msgs out?
09:02:50 <pumpkin> mun_: Debug.Trace.trace maybe
09:02:51 <roconnor> since I already have used the codensity monad before
09:03:39 <mun_> ah ok
09:03:52 <edwardk> hrmm, i'm missing the prod-type monad.
09:03:54 * roconnor thinks maybe the density comonad turns efficent code into inefficent code.
09:04:20 <edwardk> roconnor: nah, i thought so too at first
09:04:20 <pumpkin> zomg, so all I have to do to optimize my code is to apply the codensity monad?
09:04:50 <edwardk> pumpkin: actually, it goes a long way if you are optimizing a monad or a near-monad that fails to be associative, it fixes the associativity problem
09:05:34 <roconnor> edwardk: I guess your right.  The key will be that the density comonad will define cobind without reference to the underlying cobind of the comonad (esp given the underlying thing may not even be a functor)
09:06:09 <edwardk> roconnor: exactly. so you can map and duplicate and extend without touching the comonad unless you use the comonadic action
09:06:24 <edwardk> so if you use those operations over an expensive comonad, it can change your asymptotics
09:06:39 <roconnor> ya.  Still, I need examples :)
09:07:37 <roconnor> the funny thing is, is that I think of codensity monad as a CPS transform.
09:07:44 <edwardk> roconnor: actually, iirc i don't know that i've ever seen it change my asymptotics.
09:07:48 <roconnor> but obviously the density comonad will *not* be CPS
09:08:05 <roconnor> aww
09:08:06 <edwardk> but it does fuse redecorations
09:08:46 <edwardk> the reason the substitution is a win is because as you 'grow' the monad it becomes harder to walk out to the leaves of a free monad, but a redecorated comonad remains the same size
09:09:55 <roconnor> hmm
09:10:10 <edwardk> otoh, redecoration may be very expensive if you have an expensive extend, so there might be some way that in certain usage patterns it saves you, i just never got the math to work out
09:11:30 <edwardk> but most redecorations are designed to make lots of small changes rather than rebuild the whole structure from scratch as many times as there are elements, so there is rarely an O(n^2) extend
09:12:26 <edwardk> hrmm, perhaps for comonadic attribute grammars or something, where you may have to iterate a comonadic action to a fixed point
09:12:37 <edwardk> then you'd have the right asymptotics
09:12:42 <gigamonkey> If a data type and its value constructor have the same name, there's no way to export one but not the other from a module, right?
09:12:57 <cooldude127> anyone in here use opengl/GLUT?
09:13:07 <edwardk> gigamonkey: then exporting Foo will export the type, exporting Foo(Foo) will export both
09:13:16 <edwardk> but i don't think you can export the data constructor but not the type
09:13:21 <cooldude127> i just tried running a simple program from a tutorial, and i get an error "undefined symbol 'glutGet'"
09:14:31 <gigamonkey> Ah.
09:14:36 <edwardk> heh, i was talking to a guy a few weeks back about doing some consulting work and he was all depressed that I didn't use Haskell in my day job. Dismissed me as an amateur. I laughed and walked away from the gig.
09:15:54 <roconnor> edwardk: huh?
09:16:04 <roconnor> oh
09:16:19 <roconnor> he was looking for a haskell consultant?
09:16:59 <edwardk> roconnor: sort of, he also bugged conal apparently
09:17:36 <EvilTerran> gigamonkey, it's also worth noting that exporting Foo(..) will export the datatype and all of its constructors
09:17:36 <edwardk> roconnor: bit of FRP, bit of category theory, bit of pie-in-the-sky and ridiculous deadlines
09:17:45 <roconnor> oh damn
09:18:05 <gigamonkey> EvilTerran: yup. I just got to that bit in "Learn you a Haskell for Great Good"
09:18:08 <roconnor> good haskell jobs are hard to come by
09:18:16 <gigamonkey> Somehow I missed the explanation of that in RWH.
09:19:04 <quicksilver> maybe BONUS should write "Get you a Haskell Job for Great Reward"
09:19:07 <rolly1975> *any* haskell jobs are hard to come by
09:19:20 <roconnor> quicksilver: I'd pay for that.
09:19:54 <edwardk> anyways, the density comonad stuff can do some nice things for cache coherence and grouping of binds, so on a real machine i've seen some pretty big constant factor wins
09:20:00 <edwardk> er grouping of cobinds
09:20:12 <roconnor> that's good enough for me!
09:20:21 <kynky> if i had created a program with haskell that was bsd3 licensed, then created a module that was dual licensed gpl and bsd3, and used that module with gpl libs (i.e. gtk2hs) then i could distribute my program seperately to the module and gpl lobs, that would be ok, and if i gave my program the capability to download stuff with the explicit intervention of the user using my app, for instance the gpl module, would that be ok too ?
09:20:52 <roconnor> kynky: are you the author of everything?
09:20:58 <kynky> yes
09:21:04 <dcoutts> kynky: gtk is lgpl, not gpl
09:21:07 <roconnor> kynky: you can do whatever you want
09:21:09 <edwardk> kynky: the FSF will sound the alarms and dispatch bruce perens to your door with a cease and desist letter. ;)
09:21:13 <quicksilver> kynky: there is no problem combining gpl code and bsd3 code.
09:21:15 <Baughn> kynky: For your modules, what you say goes
09:21:17 <kynky> except the gpl libs, ie. gtk2hs
09:21:17 <roconnor> kynky: so long as you don't sue yourself.
09:21:24 <quicksilver> kynky: as long as you don't try to remove the gpl from the gpl parts.
09:21:29 <quicksilver> (even if it wasn't written by you)
09:21:38 <kynky> gtk2hs is lgpl without the linking exception
09:22:16 <edwardk> you can distribute all of that anyways, because gpl can subsume the bsd, and you don't violate the terms of the gpl in any of that
09:22:21 <edwardk> unless i missed a step
09:22:38 <eek> edwardk: it's debatable whether the GPL can subsume the BSD license.
09:22:55 <kynky> i thought if you put gpl code directly into your code, your code would be gpl3 not bsd when distributed
09:23:05 <eek> edwardk: the BSD license requires specific reproduction of the BSD license, which is an extra restriction
09:23:29 <wjt> eek: kynky explicitly specified BSD3
09:23:35 <edwardk> bsd3
09:24:06 <eek> wjt: doesn't matter.
09:24:13 <kynky> thought it did
09:24:57 <kynky> the advertisig clause being the incompatible thing?
09:25:19 <eek> kynky: it's very, very clear and generally acknowledged that the 4 clause BSD license is in conflict with the GPL license.  the problem is that the requirement of actually reproducing the BSD license is also an additional restriction
09:25:49 <edwardk> http://www.gnu.org/licenses/gpl-faq.html#WhatIsCompatible
09:26:46 <eek> kynky: in arguing that the 3BSD license is GPL compatible, there is an attempt at using a specific requirement to distribute a list of changes/attributions to make the BSD license "OK to integrate", but it is not clear that it is
09:26:48 <dcoutts> eek: oh come on, then everyone combining gpl with bsd would be violating the bsd
09:27:00 <eek> edwardk: that doesn't supercede the actual license text
09:27:08 <eek> dcoutts: yes, and?
09:27:18 <dcoutts> eek: and everyone one does it and nobody complains
09:27:45 <dcoutts> not the authors of the bsd bit and nor the authors of the gpl bit
09:27:52 <roconnor> stallman should be up in arms!
09:27:56 <eek> dcoutts: that doesn't make it follow the license.  "everybody" also copies a bunch of works that nobody complains about
09:28:21 <dcoutts> eek: I'm not talking about torrents etc
09:28:32 <kynky> lgpl plays nice with c++ but not so nice with haskell, except with static linking exception, because of the way when linking your objects get populated with lgpl code, so was trying to get round that
09:28:40 <eek> dcoutts: the authors of the BSD bits (me, for instance) sometimes mind and sometimes doesn't, but it's not their license that is being violated - it is the GPL
09:28:58 <dcoutts> eek: right, and they think it's not violating gpl, so all is ok
09:29:04 <roconnor> eek says it isn't legal, dcoutts says everyone does it.  These two claims are not in conflict with each other
09:29:35 <quicksilver> it is not a substantiative point. It would not interest a court of law.
09:29:57 <dcoutts> quicksilver: that's a good way of putting it
09:30:01 <kynky> just didnt seejm so clear cut to me
09:30:05 <dcoutts> the linking issue is slightly more interesting
09:30:12 <eek> quicksilver: I assume you've never tried to deal with a product based on something that includes 100+ different BSD style licenses?
09:30:17 * roconnor thinks we have strayed from kynky's question
09:30:26 <eek> anyway, I have a meeting
09:30:47 <dcoutts> kynky: so your only concern is the lgpl and the (lack of) linking exception in gtk2hs right?
09:31:00 <kynky> basically yes
09:31:30 <Baughn> If it's lgpl without a linking exception, how does it even differ from gpl?
09:31:48 <dcoutts> Baughn: the intention is completely different
09:32:03 <edwardk> eek: one could argue that the inclusion of the text of the bsd license is included in the gpl requirement of distribution of the source code
09:32:14 <dcoutts> Baughn: the authors of gtk2hs were not even aware of the problem with the linking exception when we chose it.
09:32:27 <Baughn> edwardk: Only if you find some way to make the license part of the source code
09:32:42 <Baughn> Like using a preprocessor to convert it into something shown by an about box
09:32:44 <edwardk> Baughn: its often included right in the top of the file
09:32:50 * roconnor normally includes his BSD license as a comment in his files.
09:32:50 <dcoutts> Baughn: I speak as one of the people who helped to transition gtk2hs to the lgpl many years ago.
09:33:00 <edwardk> comments are code too =)
09:33:26 <Baughn> dcoutts: Hang on. Linking exception.. Does this mean gtk2hs /can/ be linked directly, or that you're not even allowed to use dynamic linking? Which exception?
09:33:40 <kynky> wxhaskell has the exception , but i want to use cairo aswell, and that comes under the gtk2hs umbrella
09:34:03 <quicksilver> ttp://www.xfree86.org/3.3.6/COPYRIGHT2.html
09:34:16 <dcoutts> Baughn: the linking exception is about allowing static linking without requiring that such apps provide a way to relink against a different version of the lgpl lib
09:34:16 <ehird> Is there a way to make the strictness analyzer really aggressive?
09:34:18 <quicksilver> ^^ with an extra 'h', is an example of a project listing all the copyrights in its supporting documentation.
09:34:22 <ehird> I'm getting stack overflows from gigantic thunks
09:34:29 <quicksilver> I don't think that's a particularly arduous thing to do.
09:34:30 <edwardk> its all academic to me anyways as i avoid releasing anything under the GPL on principle
09:34:35 <vixey>  As a litmus test, it is possible to write a MPEG decoder or SHA-1 hash algorithm in BitC that is fully safe, but performs competatively with the C implementation. Today, that can't be done in SML, O'Caml, or Haskell.
09:34:46 <dcoutts> Baughn: if we built gtk2hs using dynamic libs then there would be no problem.
09:34:52 <edwardk> ehird: yeah using lots of $!'s and !'s ;)
09:34:55 <Baughn> dcoutts: Ah. Yes, now it makes sense. :)
09:35:09 <dcoutts> kynky: personally I'd ignore it. I don't think anyone cares.
09:35:14 <ehird> vixey: you sure?
09:35:25 <Baughn> dcoutts: Though it seems to me that inlined haskell code is somewhat akin to C headers
09:35:34 <ehird> edwardk: I'm trying, man... The thunks are in Data.Map; I don't control that code
09:35:35 <dcoutts> Baughn: that's not the issue
09:35:56 <dcoutts> Baughn: the lgpl requires that apps using lgpl code can be made to use updated versions of the lgpl code
09:36:03 <edwardk> ehird: ah, see if poucet has released the Data.Adaptive.Map stuff into adaptive-containers yet
09:36:15 <dcoutts> Baughn: since the user has access to the source of the lgpl big, they want to make source changes and relink.
09:36:27 <ehird> edwardk: nope
09:36:31 <dcoutts> Baughn: it only has to be technically possible, it doesn't need to be easy.
09:36:36 <edwardk> ehird: but Data.Map is strict except for he value
09:36:48 <ehird> edwardk: that's not what i've heard
09:36:49 <kynky> dcoutts, nicely explained, exactly what i had found out so far
09:36:54 <edwardk> ehird: so you should be able to force on insert and no other thunks should dangle
09:37:00 <ehird> I already do strict insert
09:37:01 <ehird> Same issue
09:37:04 <ehird> Maybe it's not data.map
09:37:25 <dcoutts> kynky: if you're really concerned then all you need to do is provide the .o files for your app and then anyone can link them with the gtk2hs libs to re-create your app.
09:37:34 <Baughn> dcoutts: So the tools to do it don't actually have to exist?
09:38:02 <kynky> will that mea i have to redistribute the ghc i compiled it with too ?
09:38:11 <quicksilver> ehird: sounds like you need to found out what the issue is.
09:38:11 <dcoutts> kynky: nope
09:38:15 <quicksilver> ehird: heap profiling for the win!
09:38:31 <ali_clark> I've been procrastinating quite hard, so if anyone wants a basic IO monad in Scheme, here it is: http://scheme.pastebin.com/m549d5bd1
09:38:36 <ehird> quicksilver: It's only 40 lines of code, i'll rewrite it
09:38:43 <edwardk> data Map k a  = Tip | | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)  -- riht out of Data.Map
09:38:49 <edwardk> the only thing that can avoid being forced is the value
09:38:59 <quicksilver> ehird: heap profiling is easy + fun.
09:38:59 <kynky> best thing about ghc is that you can redistribute :)
09:39:03 <vixey> ali_clark: are there some point in it?
09:39:03 <quicksilver> ehird: it's good to know how to do it.
09:39:10 <edwardk> kynky: compilers are excluded from redist requirements
09:39:17 <ali_clark> vixey: nope.
09:39:22 <dcoutts> Baughn: linking isn't that hard
09:39:29 <edwardk> kynky: they are considered part of the platform by the gpl
09:40:07 <roconnor> edwardk: in that case, we need to put more libs into GHC :)
09:40:07 <kynky> dcoutts, edwardk thx
09:40:29 <roconnor> ideally all of hackage
09:40:42 <roconnor> :P
09:40:53 <edwardk> afk a bit
09:41:00 <kynky> or just cabal-install ?
09:41:02 <dcoutts> edwardk: no, it's that compilers are not linked to, your code is not a derived work of the compiler
09:41:05 <Baughn> dcoutts: No, but I expect replacing inlined code would be. Oh well; I don't do lgpl anyway.
09:41:32 <dcoutts> Baughn: the lgpl3 made this clearer
09:43:18 <Berengal> In parsec, is there a way to get the remainder of the string?
09:43:31 <Berengal> After a successfull parse, that is
09:43:52 <Baughn> Berengal: Stick a "many char" at the end of the parser
09:43:53 <vixey> make a parser that does it
09:44:32 <Berengal> so (,) <$> myParser <*> many anyChar ?
09:44:39 <Baughn> Sure
09:45:06 * ski . o O ( manyChar = many anyChar )
09:45:15 <kynky> i think some ppl choose lgpl license without realising the implications with haskell, although their intention isnt exactly the same as the consequence, but you still have to follow licensing requirements, except for when the author puts in exceptions, which may be harder todo once a program has started if a lot of code contributions came from lots of diff authors
09:47:28 <leimy> kynky: the problem is people don't know what GPL/LGPL are :-)
09:47:35 <leimy> so they just default.
09:48:55 <roconnor> is the problem that LGPL has special consequences for Haskell because of the way it is linked?
09:49:13 <poucet> edwardk: ping
09:49:14 <roconnor> or is it just the usual problems?
09:49:33 <roconnor> poucet: afk
09:49:43 <Baughn> roconnor: Inlining's a problem, as is the lack of dynamic linking
09:49:55 <Baughn> Although ~/.cabal/config seems to have acquired an option for shared libraries now.. I should try it...
09:50:11 <younder> the froggies
09:50:15 <younder> ...
09:50:18 <kynky> from what ive read, yes, but a lot of respected haskell developers distribute with bsd3 for a few reasons
09:50:23 <burp_> @let coshapprox x = 1 + x^^2/2 + x^^4/24 + x^^6/720 -- + O(x^^8)
09:50:25 <lambdabot>  Defined.
09:50:32 <burp_> > coshapprox 10^^(-3) - cosh 10^^(-3)
09:50:33 <lambdabot>   1.5552158414981348e-10
09:50:44 <burp_> why is this O(10^^-10)
09:50:50 <roconnor> I always thought that the LGPL was a ridiculous licence
09:50:54 <burp_> and not 10^(-24)?
09:50:57 <poucet> > 2**(-50)
09:51:02 <lambdabot>   8.881784197001252e-16
09:51:06 <younder> try some of scotich magic...
09:51:17 <roconnor> > coshapprox 10^^(-3) - cosh 10^^(-3) :: CReal
09:51:18 <lambdabot>   0.0000000001555215841498135084314847745137
09:51:25 <poucet> > 2**(-27) :: CReal
09:51:25 <burp_> coshapprox is taylor approximation until O(x^8)
09:51:27 <lambdabot>   0.000000007450580596923828125
09:51:29 <kynky> even the fsf thnk it is too, iirc
09:51:34 <poucet> > 2**(-50) :: CReal
09:51:35 <lambdabot>   0.0000000000000008881784197001252323389053
09:51:43 <pumpkin> sho
09:51:43 <poucet> :i CReal
09:51:53 <pumpkin> > showCReal 100 $ 2**(-50)
09:51:54 <lambdabot>   "0.00000000000000088817841970012523233890533447265625"
09:52:39 <poucet> CReal == arbitrary precision?
09:52:48 <roconnor> burp_: O notation is the order of the error and has nothing to do with the absolute error at any particular input value
09:52:49 <pumpkin> computable reals
09:52:58 <poucet> heh
09:52:59 <pumpkin> you can ask for any precision you want
09:53:04 <poucet> I once wrote code close to that :|
09:53:15 <pumpkin> the nice thing is that you don't have to specify precision beforehand
09:53:17 <burp_> roconnor, hm, ok
09:53:26 <poucet> pumpkin: nice
09:53:28 <younder> all you need for reals is a computable epsion to carry trought your computations
09:53:43 <younder> through
09:53:58 <roconnor> burp_: the O(x^8) it only tells you the asymptotic error as x goes to infinity.
09:54:06 <burp_> I need a cosh approximation with error lower than 10^^(-14) for x in (0,10^^(-3))
09:54:25 <poucet> > showCReal 1000 $ 2**(-1000)
09:54:27 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
09:54:42 <younder> in this case it is uncomputable the delta is too hogh
09:54:49 <younder> high
09:54:55 <burp_> I guess I need to try this value
09:55:02 <roconnor> burp_: what are the maximum values of the first several deriviatives of cosh?
09:55:04 <younder> the gradient of the curve
09:55:05 <haskellnoob> I need to paste a few (five) lines of code to ask a question, is there a pastebin available?
09:55:27 <haskellnoob> sorry, read the topic only now
09:55:39 <roconnor> burp_: taylor's theorem may be able to give you the bound you seek, but you need to read the theorem carefully.
09:55:53 <roconnor> burp_: ... and then there is floating point error ...
09:55:54 <burp_> maybe I need to use the exact error formula
09:55:57 <burp_> yeah, right
09:56:22 <younder> well froggies read my formula-1 definition and wheep ;)
09:56:30 <roconnor> burp_: or you can use CReal :)
09:56:51 <poucet> pumpkin: very nice approach
09:56:56 <poucet> pumpkin: I took a completely different approach
09:57:19 <pumpkin> poucet: which one? (I didn't write CReal btw)
09:57:27 <pumpkin> in case I sounded possessive in my talk of it :)
09:57:28 <poucet> let me find the post
09:57:33 <poucet> Not at all :)
09:57:36 <poucet> And I saw the authoer :)
09:57:46 <pumpkin> ok, cool :D
09:58:02 <poucet> grr
09:58:04 <poucet> let me fix the markup
09:58:12 <poucet> migration from blogspot to wordpress--
09:58:37 <roconnor> I suppose technically you can get around floating point error by converting to Rationall, apply an appropriate taylor polynomial, and then covert back to floating point. :P
09:58:47 <poucet> roconnor: there's better ways
09:58:59 <burp_> roconnor, hm, good idea
09:59:11 <haskellnoob> what would be the cause of the error described in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2278#a2278 ?
09:59:13 <roconnor> poucet: I don't have a floating point licence. :(
10:00:03 <younder> lol
10:00:21 <poucet> roconnor: I don't use flotaing points
10:00:25 <younder> It's called numerical analysis
10:00:28 <danderson> poucet: o/
10:00:40 <pumpkin> :)
10:00:44 <roconnor> poucet: oh, then what are the better ways?
10:00:51 <poucet> <- fixing post
10:01:03 <roconnor> haskellnoob: you can't put where in that block
10:01:24 <younder> need any help..
10:01:30 <roconnor> haskellnoob: if you pull the where clause all the way out so that it is indented by 2 spaces
10:01:49 <roconnor> that should work
10:02:35 <haskellnoob> roconnor: could you give me the idea behind this as well? is it illegal to have a where clause inside a do block?
10:02:40 <younder> As I said you need to carry the epsilon trough
10:02:41 <roconnor> burp_: wait what?  You think what I said is a good idea?
10:02:56 <roconnor> haskellnoob: basically
10:03:22 <roconnor> haskellnoob: where clauses are attached to definitions
10:03:26 <haskellnoob> and by pulling it way forward, i would be putting it outside this do block, is it? but then will the code inside the do block be able to see it?
10:03:31 <roconnor> such as "main = "
10:03:47 <haskellnoob> hmm.. not to actions?
10:04:06 <haskellnoob> (or whatever these thingies inside do blocks are)
10:04:12 <roconnor> haskellnoob: all of the where declairations will be accessible in the function being defined.
10:04:28 <roconnor> and hence, inside your do block
10:04:45 <younder> I have been working latley with computabillity of expression and verifiabillity of 'floating pint' arithmetic
10:04:47 <haskellnoob> roconnor: thank you, that cleared it up.
10:04:50 <younder> point
10:05:22 <blsecres> does ghc have a .rc file or environment variable for persistent options?
10:05:59 <younder> Mostly as part of the ACL2 program
10:06:00 <roconnor> younder: burp_ wants to approximate cosh within 10^14 on the interval (0,10^(-3))
10:06:06 <haskellnoob> roconnor: pulling it almost all the way to the left still gives the same compilation error, except for the position of the character where the error happens
10:06:53 <burp_> roconnor, I'll  work with the exact taylor error rest term formula now
10:07:12 <doserj> haskellnoob: your interact process_input is also wrongly indented
10:07:16 <younder> roconnor: simple... A double can do that
10:07:29 <doserj> haskellnoob: that should probably be aligned to the let
10:07:54 <roconnor> younder: if you say so
10:08:46 <younder> The roundoff error is way less than the 20 digits in a double
10:08:47 <roconnor> > diff cosh $ x
10:08:49 <lambdabot>   Not in scope: `diff'
10:08:56 <roconnor> > df cosh $ x
10:08:57 <lambdabot>   Couldn't match expected type `Dif a'
10:09:07 <roconnor> > deriv cosh $ x
10:09:09 <lambdabot>   (1 * exp x + negate 1 * exp (negate x)) * recip 2
10:09:22 <vixey> > iterate deriv sin $ x
10:09:23 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
10:09:23 <lambdabot>        Expe...
10:09:24 <roconnor> > deriv (deriv cosh) $ x
10:09:26 <lambdabot>   (1 * (1 * exp x) + negate 1 * (negate 1 * exp (negate x))) * recip 2
10:09:33 <vixey> > iterate deriv sin id
10:09:34 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
10:09:34 <lambdabot>        Expe...
10:09:54 <vixey> > iterate deriv (sin x)
10:09:55 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
10:09:55 <lambdabot>        Expe...
10:10:02 <roconnor> vixey: each time I add deriv, the type of cosh changes
10:10:11 <roconnor> and I'm using a different instance
10:10:18 <vixey> > sequence (iterate deriv sin) x
10:10:19 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
10:10:19 <lambdabot>        Expe...
10:10:40 <roconnor> vixey: it won't work cause haskell has a stupid type system. :P
10:10:47 <haskellnoob> doserj: i wanted n and k to be visible to the function passed in to interact -- n and k are two numbers that appear in the very first line of the input, that have a bearing on how the rest of the lines are processed. is there a way to let this happen?
10:11:19 <burp_> cosh' = sinh, sinh' = cosh
10:11:21 <roconnor> haskellnoob: in that case the best thing to do is use another let clause
10:11:25 <eek> edwardk: the BSD license has to be distributed with the binaries, which is an extra requirement compared to the GPL that only require it to be included in the source code
10:12:02 <vixey> :t deriv
10:12:03 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
10:12:17 <vixey> @src Dif
10:12:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:12:38 <haskellnoob> roconnor: i'm afraid i can't see how to do that...
10:12:39 <vixey> is there (a -> b) -> (Dif a -> Dif b)?
10:12:39 <ski> (possibly `data Dif a = D a a' ..)
10:12:44 <younder> brocca contrations
10:12:55 <vixey> :t derive (fmap ?x ?g)
10:12:57 <lambdabot> Not in scope: `derive'
10:12:58 <younder> not broccoly brains
10:13:00 <vixey> :t deriv (fmap ?x ?g)
10:13:00 <eek> edwardk: WRT the BSD license inclusion requirement being satisfied by source code distribution requirement in the GPL
10:13:01 <lambdabot> forall a b a1. (Num b, Num a1, ?g::Dif a1 -> a, ?x::a -> Dif b) => a1 -> b
10:13:07 <doserj> haskellnoob: let [n,k] = ... ; process_input = ... ; interact process_input
10:13:08 <younder> lol
10:13:26 <roconnor> haskellnoob: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2278#a2279
10:13:30 <vixey> :t deriv (fmap ?x . ?g)
10:13:31 <lambdabot>     No instance for (Functor Dif)
10:13:31 <lambdabot>       arising from a use of `fmap' at <interactive>:1:7-13
10:13:31 <lambdabot>     Possible fix: add an instance declaration for (Functor Dif)
10:13:35 <doserj> haskellnoob: where the process_input = is aligned with [n,k], and interact is aligned with let
10:13:38 <vixey> this is impossible
10:14:09 <wjt> @info Dif
10:14:09 <lambdabot> Dif
10:14:13 <wjt> lambdabot: thanks!
10:14:14 <haskellnoob> roconnor, doserj: thanks, let me try these
10:14:29 <roconnor> vixey: there isn't a (a -> b) -> (Dif a -> Dif b) that would do what you want
10:14:56 <vixey> :k Mu Dif
10:14:57 <lambdabot> *
10:14:57 <roconnor> vixey: maybe try using Mu Diff a
10:15:13 <younder> you are thanking the lambdabot..
10:15:14 <roconnor> I see you are already ahead of me
10:15:14 * poucet thinks he fixed all the markup issues
10:15:14 <vixey> > fmap deriv (In . id)
10:15:15 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
10:15:15 <poucet> no newlines :(
10:15:26 <younder> sigh
10:15:36 <vixey> :t (deriv . out)
10:15:37 <lambdabot>     Couldn't match expected type `Dif b'
10:15:37 <lambdabot>            against inferred type `Mu ((->) (Dif a))'
10:15:37 <lambdabot>       Expected type: Mu ((->) (Dif a)) -> Dif a -> Dif b
10:16:06 <vixey> > fmap deriv (In id)
10:16:07 <lambdabot>       Occurs check: cannot construct the infinite type: a = Mu ((->) a)
10:16:07 <lambdabot>      ...
10:16:09 <roconnor> younder: wjt is thanking the bot for nothing
10:16:11 <vixey> It's not possible
10:16:27 <ski> @index Dif
10:16:28 <lambdabot> bzzt
10:16:32 <roconnor> what are the constructors and projections for Mu?
10:16:40 <younder> roconnor: exactly
10:16:40 <vixey> Mu and out
10:16:41 <roconnor> @type out
10:16:42 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
10:16:45 <vixey> In and out
10:16:47 <vixey> sorry
10:16:47 <ski>   newtype Mu f = In {out :: f (Mu f)}
10:17:20 <younder> want some human help?
10:17:26 <roconnor> vixey: I guess we need a Floating instance for Mu Dif Double as well. :/
10:18:44 <ski> roconnor : `Mu :: (* -> *) -> *', not `Mu :: (* -> *) -> (* -> *)'
10:19:07 <roconnor> younder: wjt wants info on Dif
10:19:33 <mdmkolbe> Is there some way in GHC to specify a LANGUAGE pragma only applies to a portion of a file?
10:19:37 <roconnor> presumably he wants to know which modules defines it
10:19:39 <younder> It is simple you need to carry the epsilon trough all your computations
10:20:00 <younder> Don't trust the boxed shit
10:20:04 <ski> `Dif' is dual numbers, iirc
10:20:29 <ski> (implementing automatic differentiation)
10:20:44 <younder> You need a assert at the start of each function
10:21:02 <poucet> grr
10:21:55 * roconnor goes to buy cheese
10:23:11 <younder> sorry, but you really can't trust the built in FP
10:23:12 <Lemmih> mdmkolbe: No.
10:23:26 <younder> functions
10:23:44 <roconnor> younder: what are you talking about?
10:23:59 <younder> Treat them like they are unverified
10:24:48 <younder> roconnor: The reasoning about floating-point accuracy
10:25:21 <mdmkolbe> Thanks, Lemmih
10:26:23 <younder> As usual verifiabillity has been constrained to integers
10:26:41 <younder> Clearly that is not good enough
10:26:42 <roconnor> younder: wait, your way of dealing with floating point numbers is to use asserts at the beginning of functions?
10:27:07 <younder> nop
10:27:19 <younder> unfotunately
10:27:20 <roconnor> thank goodness
10:27:51 <younder> I am saying it needs work!
10:30:23 <younder> You need to carry the epsilon at compile time, so you don't carry the computational overhead.
10:31:03 <ski> (partial evaluation ?)
10:31:33 <roconnor> presumably carry the epsilon in a type annotation on the floating point type
10:31:52 <younder> nop
10:31:52 <poucet> whew
10:31:53 <poucet> roconnor: sorry
10:32:00 <poucet> that was a bitch to do :(
10:32:11 * poucet lost all his newlines in his code
10:32:35 <poucet> http://cpoucet.wordpress.com/2008/02/08/continued-fractions-in-haskell/
10:32:37 <younder> sorry, but the compiler writers hav a bit to do here
10:33:12 <younder> As usual they have more or less ignored floating point
10:33:45 <younder> and as usual it is the most important to actual users
10:34:33 <leimy> @users
10:34:34 <lambdabot> Maximum users seen in #haskell: 658, currently: 631 (95.9%), active: 20 (3.2%)
10:34:42 <poucet> roconnor: the explanation is a bit lacking
10:34:43 <lambdabot> poucet: You have 1 new message. '/msg lambdabot @messages' to read it.
10:34:58 <younder> So I guess I have to fix it!
10:36:43 <hoopy> fancy fibonacci gogogogo
10:36:57 <hoopy> people were doing really nice ones in here a while ago
10:37:52 <younder> fibonacci is determined by a formulae you know
10:38:07 <younder> You don't need to compute each step
10:38:33 <mmorrow> > (0.8+pi)-(pi::Double)
10:38:34 <lambdabot>   0.7999999999999998
10:38:43 <mmorrow> gcc says: 0.8
10:38:55 <mmorrow> hrm, actually it's probably precomputing that..
10:39:01 <younder> math entered the building :)
10:39:17 <hoopy> it needs to enter my head :\
10:39:29 <poucet> roconnor: opinions welcome
10:39:33 <poucet> roconnor: the code is a mess, but ok
10:39:48 <jatqceer> Can somebody tell me why unsafeIOToST is unsafe?  or point me to some url?
10:41:52 <mmorrow> yeah, gcc says 0.8
10:42:33 <mmorrow> (it was precomputing it, but it says 0.8 also when gcc-generated code computes it)
10:46:42 <younder> Forget about the 'compied code'. Can you show us the source?
10:47:28 <younder> compiled
10:50:40 <younder> mmorrow: please..
10:50:51 <jeffersonheard> @seen dons
10:50:52 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 52m 2s ago.
10:51:04 <dons> jeffersonheard: yo
10:51:04 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:52:29 <edwardk> dons: bouncing ideas off of poucet for the adaptive containers thing, will update you in a bit ;)
10:52:52 <younder> hi dons/ jeffersonhear
10:53:04 <younder> head
10:53:14 <dons> edwardk: excellent.
10:53:59 <younder> I never was much for south dacota..
10:57:12 <Gracenotes> can getCPUTime be trusted for timing programs?
10:57:26 <younder> yes
10:57:39 <Gracenotes> great
10:57:47 <zachk> what library is getCPUTime in
10:57:50 <centrinia> Gracenotes: You have to be aware of the error bars.
10:58:34 <Gracenotes> well, I just need it rounded to the nearest second, or second and tenth
10:59:38 <Gracenotes> although... it says the number of picoseconds :\ subtracting two of them generated a few seconds apart.. http://www.google.com/search?q=(1512094000000+-+1448090000000)+picoseconds+in+seconds
10:59:47 <Gracenotes> a bit confusing
10:59:53 <younder> indeed
11:00:37 <younder> But if you are not concerned with pico seconds it will do ;)
11:00:39 <Gracenotes> however, dividing cpuTimePrecision works
11:00:49 <Gracenotes> yeah, I want it in seconds
11:01:19 <younder> use the modulo operator
11:02:20 <Gracenotes> in.. what way
11:02:24 <leimy> http://www.google.com/search?q=teaspoons+in+a+cubic+lightyear&ie=UTF-8&oe=UTF-8
11:02:24 <leimy> thats a lot of teaspoons!
11:03:05 <agag> http://www.marie-wird-entjungfert.net/?uid=59575
11:05:25 <mopped> Why does foldl not work on infinite lists, but foldr does? foldr needs the end item to begin, so how does that work?
11:06:44 <Gracenotes> heh. I think this might be even better performing than the C++ version
11:06:58 <tromp> thinkg of foldr as replacing : and [] with other operators
11:07:26 <Gracenotes> > foldr f z [a, b, c]
11:07:27 <lambdabot>   f a (f b (f c z))
11:07:37 <younder> it reaches from the back
11:07:48 <centrinia> > foldl f z [a,b,c]
11:07:49 <Gracenotes> note: every time, f is passed two arguments: the item of the list, and the accumulator
11:07:50 <mauke> mopped: no, foldr doesn't need the end to begin
11:07:50 <lambdabot>   f (f (f z a) b) c
11:07:52 <bremner> so in an infinite list, c= ?
11:07:54 <younder> rather than the front
11:08:05 <mauke> mopped: however, foldl needs to reach the end to stop
11:08:25 <Gracenotes> *f* is the important part. If f always requires both arguments (is strict), chances are it won't work on infinite lists. for example, +
11:08:28 <tromp> foldr (:) [] [0..]
11:08:33 <tromp> > foldr (:) [] [0..]
11:08:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:08:40 <younder> so no go for that infinate list
11:08:44 <tromp> that didnt need the end
11:08:54 <Gracenotes> if f doesn't require the second argument, then it simply won't be calculated
11:09:00 <Trafalgard> Looks infinite to me
11:09:08 <Gracenotes> and so the accumulation will stop
11:09:34 <centrinia> Does foldl f z xs = f (foldl f z (init xs)) (last xs), for nonempty xs?
11:09:40 <mopped> aha, thanks
11:09:41 <Gracenotes> using (:) as the function is a somewhat unusual case in that it uses a constructor, the results of which are available immediately, due the lazy natural of lists
11:09:52 <Gracenotes> nature
11:11:03 <centrinia> @src foldl
11:11:03 <lambdabot> foldl f z []     = z
11:11:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:11:35 <younder> @src foldr
11:11:35 <lambdabot> foldr f z []     = z
11:11:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:12:03 <Gracenotes> so for example, with the function for lookup (\acc (k, v) -> if myKey == k then v else acc), when the key is found, the accumulator will not be required and the list won't be traversed further
11:12:25 <Gracenotes> er, switch argument order for foldr
11:12:46 <roconnor> @type \c f -> c . flip f
11:12:47 <lambdabot> forall c a a1 c1. ((a -> c1) -> c) -> (a -> a1 -> c1) -> a1 -> c
11:13:42 <roconnor> @pl (\k -> c (\a ->  (f a) k))
11:13:43 <lambdabot> c . flip f
11:14:49 <roconnor> I see. The condensity doesn't care at all about the functor
11:15:24 <roconnor> The more I learn about CPS the more i dislike algebraic types
11:15:28 <roconnor> :)
11:15:29 <burp_> > coshapprox 10^^(-3) - cosh 10^^(-3) :: CReal
11:15:31 <lambdabot>   0.0000000001555215841498135084314847745137
11:15:43 <vixey> roconnor: what sorts of things about CPS happened?
11:16:05 <burp_> hm, my latest calculations say this should be less than 10^-23 :>
11:16:30 <maltem> @tell dcoutts Yay for dynamic linking for GHC! :)
11:16:31 <lambdabot> Consider it noted.
11:16:31 <roconnor> vixey: The [Coq-Club] Question about guardedness in CoFixpoint
11:16:50 <monochrom> heh
11:18:22 <roconnor> vixey: with algebraic data types you are constently deconstructing the whole value and reassembling it just to change a little bit
11:19:12 <kadaver> can I break out of a fold+
11:19:13 <kadaver> ?
11:19:26 <roconnor> what is a fold+
11:19:44 <Twey> It's a Dvorakish typo for a fold?
11:20:03 <Twey> And no, kadaver, not really
11:20:20 <roconnor> kadaver: use a foldM and throw an exception
11:20:24 <Twey> (but you can ignore everything from that point on by using an appropriate combinator)
11:20:38 * roconnor wonders if what I said really works
11:20:46 * Twey laughs.
11:20:54 <Twey> Might be a bit convoluted
11:21:04 <roconnor> @type foldM
11:21:06 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:21:45 <roconnor> > foldM (\a b -> return (a + b)) 0 [1..10]
11:21:47 <lambdabot>       No instance for (Show (m b))
11:21:47 <lambdabot>        arising from a use of `show' at <in...
11:21:55 <roconnor> > runIdentity $ foldM (\a b -> return (a + b)) 0 [1..10]
11:21:57 <lambdabot>   55
11:22:39 <roconnor> > foldM (\a b -> return (a + b)) 0 [1..]
11:22:42 <Twey> > foldr (\t x -> if t < 5 then t + x else t) [1..10]
11:22:54 <kadaver> (\x -> toLower x == x), can thta be unlambdad? like (toLower . ==) ?
11:22:56 <lambdabot>       No instance for (Show (m b))
11:22:56 <lambdabot>        arising from a use of `show' at <in...
11:22:57 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
11:22:57 <lambdabot>        arising from a use...
11:23:10 <roconnor> > runIdentity $ foldM (\a b -> return (a + b)) 0 [1..]
11:23:21 <roconnor> > foldM (\a b -> if b=10 then Left "HALT!" else return (a + b)) 0 [1..]
11:23:34 <roconnor> oops
11:23:43 <lambdabot>   mueval: Prelude.read: no parse
11:23:43 <lambdabot>   thread killed
11:23:47 <roconnor> > foldM (\a b -> if b==10 then Left "HALT!" else return (a + b)) 0 [1..]
11:23:49 <lambdabot>   Left "HALT!"
11:23:54 <burp_> http://mathbin.net/10954
11:23:59 <Twey> @pl \x -> toLower x == x
11:23:59 <roconnor> that was faster than taking forever
11:23:59 <lambdabot> (==) =<< toLower
11:24:24 <roconnor> @src foldM
11:24:24 <lambdabot> foldM _ a []     = return a
11:24:25 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:24:59 <roconnor> @src foldr
11:25:00 <lambdabot> foldr f z []     = z
11:25:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:25:25 <roconnor> @src foldl
11:25:26 <lambdabot> foldl f z []     = z
11:25:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:25:26 <haskellnoob> when I say Data.ByteString.split ' ' line, ghc complains that ' ' is not a Word8, but is a Char. How do I convert ' ' to a Word8 instance?
11:25:54 <mauke> haskellnoob: use Data.ByteString.Char8.split instead
11:27:03 * roconnor tries to think if bailing out of foldr even makes sense.
11:27:58 <roconnor> probably not
11:28:07 <vixey> @src foldM
11:28:07 <lambdabot> foldM _ a []     = return a
11:28:08 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:28:13 <roconnor> > foldM (\a b -> if a>100 then Left "HALT!" else return (a + b)) 0 [1..]
11:28:14 <lambdabot>   Left "HALT!"
11:28:25 <haskellnoob> mauke: thanks
11:28:31 <roconnor> probably not in any reasonable sense of bailing out.
11:29:09 <haskellnoob> mauke: I can use Data.ByteString.Char8.words instead :)
11:29:28 <roconnor> > foldl (+) 0 [1..10000]
11:29:30 <lambdabot>   50005000
11:29:40 <roconnor> right strictness analysis
11:29:52 <Berengal> > foldl (+) 0 [1..1000000]
11:29:54 <lambdabot>   * Exception: stack overflow
11:29:59 <roconnor> oh good
11:30:02 <Berengal> > foldl' (+) 0 [1..1000000]
11:30:04 <lambdabot>   500000500000
11:30:27 <roconnor> > foldl (\a b -> if a==a then a+b else a+b) 0 [1..1000000]
11:30:29 <lambdabot>   * Exception: stack overflow
11:31:21 <Berengal> > foldl (\a b -> if a==a then a+b else 0) 0 [1..1000000]
11:31:24 <lambdabot>   * Exception: stack overflow
11:32:11 <mmorrow> > flip runCont id (callCC (\k -> foldM (\a b -> forever (k b) >> return a) 0 [99..]))
11:32:11 <Berengal> > foldl (\a b -> if b==b then a+b else 0) 0 [1..1000000]
11:32:12 <roconnor> > foldM (\a b -> if a==a then return (a+b) else return (a + b)) 0 [1..1000000]
11:32:12 <lambdabot>   99
11:32:14 <lambdabot>       No instance for (Show (m b))
11:32:14 <lambdabot>        arising from a use of `show' at <in...
11:32:15 <lambdabot>   * Exception: stack overflow
11:32:23 <roconnor> > runIdentity $ foldM (\a b -> if a==a then return (a+b) else return (a + b)) 0 [1..1000000]
11:32:25 <lambdabot>   * Exception: stack overflow
11:33:13 <haskellnoob> how do I get an Integer from a Data.ByteString.Char8.ByteString ? "read" seems to expect a plain String
11:33:17 <mmorrow> > flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return (a*b)) 1 ([1..10]++[0]++[10000..10000000])))
11:33:19 <lambdabot>   0
11:33:40 <mauke> unpack first
11:33:56 <haskellnoob> mauke:thanks
11:34:04 <mmorrow> @let prod xs = flip runCont id (callCC (\k -> foldM (\ !a b -> if b==0 then k 0 else return $! (a*b)) 1 xs)
11:34:05 <lambdabot>   Parse error
11:34:09 <mmorrow> @let prod xs = flip runCont id (callCC (\k -> foldM (\ !a b -> if b==0 then k 0 else return $! (a*b)) 1 xs))
11:34:10 <lambdabot>   Parse error
11:34:25 <haskellnoob> Also, are Data.ByteString and Data.ByteString.Char8.ByteString two different types?
11:34:31 <mauke> preflex: 6st 123 45
11:34:31 <preflex>  123th 45th
11:34:38 <mauke> haskellnoob: no
11:34:44 <mmorrow> @let prod xs = flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return $! (a*b)) 1 xs)))
11:34:45 <lambdabot>   Parse error
11:34:48 <mmorrow> gah!
11:35:28 <haskellnoob> ok
11:35:28 <roconnor> mmorrow: isn't callCC a bit overkill
11:35:36 <roconnor> mmorrow: I'd use Either
11:35:42 <mmorrow> @let prod xs = flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return $! (a*b)) 1 xs)) in prod
11:35:42 <lambdabot>   Parse error
11:35:46 <mmorrow> no way
11:35:58 <mmorrow> @type let prod xs = flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return $! (a*b)) 1 xs))) in prod
11:36:00 <lambdabot> parse error on input `)'
11:36:38 * mmorrow tries once more
11:36:40 <mmorrow> @let prod xs = flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return $! (a*b)) 1 xs))
11:36:42 <lambdabot>  Defined.
11:36:47 <roconnor> \o/
11:36:50 <mmorrow> woohoo
11:36:53 <roconnor> > prod [1..1000000]
11:37:09 <lambdabot>   thread killed
11:37:13 <kiris> @vixen you've got so many machines richad!
11:37:13 <lambdabot> Hmmm
11:37:14 <mmorrow> > prod ([1..100]++[0]++[1..])
11:37:16 <lambdabot>   0
11:38:36 <Yoric[DT]> Is there anybody from Italy around here?
11:38:44 <Yoric[DT]> Preferably someone with knowledge of the Italian academic system.
11:39:03 <edwardk> Yoric[DT]: Saizan is IIRC and he's usually around
11:39:34 <Yoric[DT]> Thanks.
11:39:37 <Yoric[DT]> Saizan: ping
11:39:44 <mmorrow> @let withAbort f = flip runCont id (callCC (\k -> return $! (f k)))
11:39:44 <c_wraith> Is Saizan the one whose school was mostly destroyed in that quake?
11:39:45 <lambdabot>  Defined.
11:39:51 <edwardk> not sure
11:39:58 <edwardk> heya mmorrow
11:40:01 <c_wraith> I remember someone here mentioned that.
11:40:13 <edwardk> still playing with your transactions?
11:41:02 <mmorrow> edwardk: hiya
11:41:20 <mmorrow> edwardk: i haven't been lately. i've been working on my interp a bunch
11:41:26 <edwardk> ah
11:41:54 <Saizan> Yoric[DT]: pong
11:41:57 <Yoric[DT]> Hi
11:42:05 <Saizan> hi
11:42:30 <haskellnoob> how do I convert an Integer to a ByteString, similar to what "show" does?
11:42:40 <mauke> pack . show
11:42:53 <haskellnoob> mauke:thanks
11:46:11 <dolio> Don't do that.
11:46:18 <dolio> Download my bytestring-show package.
11:46:28 <dolio> And report any bugs you find. :)
11:47:18 <dolio> I assume you want lazy byte strings, that is. It's based on binary, so it's limited to those.
11:47:20 <Gracenotes> hm. so, any ideas on the best way to sort a file with a few hundred megabytes? If the file is too long I plan on splitting it up and merging it, but for the base algorithm... I suppose loading the megabytes into memory and quicksort-ing will be fastest?
11:47:33 <mauke> no, I do not want lazy bytestrings
11:47:53 <dolio> You weren't the one asking.
11:48:07 <Gracenotes> I don't have much experience with mmap, but.. would it be useful here?
11:50:04 <dolio> What are these megabytes of?
11:51:18 <Gracenotes> binary data in 16-byte chunks, sorted by the last 8 bytes (a Word64)
11:53:52 <roconnor> Gracenotes: isn't there some external-sort package on hackage?
11:54:31 <Gracenotes> oh, really. Well, I won't need an external sort immediately, only for larger files, but... *checks this out*
11:56:03 <Gracenotes> interesting, although has a dependency on two data structure libraries (Edison)
11:56:20 <roconnor> Edison is a good thing IIRC
11:56:26 <roconnor> granted I have never used it
11:56:28 <dolio> Well, if you're serious about loading everything into memory, I just sorted 50 million Ints (64 bit, so 380 megabytes) with my introsort in 15 seconds.
11:57:08 <Gracenotes> oh, nice. using an array or a list?
11:57:18 <dolio> Using uvector-algorithms.
11:57:26 <dolio> MUArr
11:57:45 <Gracenotes> ah.
11:58:05 <dolio> I don't know how easy it is to load those from a file.
11:58:09 <Gracenotes> hm.... uvector is a good idea here
11:58:24 <dolio> I think pumpkin would know more about that than I do.
11:58:31 <roconnor> what is a uvector?
11:58:35 <Gracenotes> hopefully it interfaces well with Data.Binary
11:59:17 <dolio> uvector is dons' library for stream fusion couched in terms of unboxed immutable arrays.
11:59:33 <dolio> But it also has unboxed mutable arrays, so I wrote a bunch of sorting stuff for them.
12:00:05 <dolio> They generally optimize better than STUarray, because there's no fancy parameterized index types and stuff.
12:00:20 <Gracenotes> and in this case, I can't use STUArray, since I'm sorting (,)s
12:02:11 <dolio> Radix sort sorts 50 million elements in 10 seconds, but I don't have a way to just sort on the second part of a pair with that yet.
12:02:33 <dolio> I've been meaning to add a sortBy/On for that.
12:04:19 <BrokenClockwork> hey
12:05:05 <leimy> @users
12:05:05 <lambdabot> Maximum users seen in #haskell: 658, currently: 652 (99.1%), active: 19 (2.9%)
12:06:41 <SubStack> o_O
12:07:22 <SubStack> @users
12:07:22 <lambdabot> Maximum users seen in #haskell: 658, currently: 655 (99.5%), active: 19 (2.9%)
12:07:26 <SubStack> :D
12:07:54 <BrokenClockwork> oh we could break records? :D
12:08:00 <bremner> quick, somebody get a few spammers
12:08:04 <SubStack> it's possible!
12:08:17 <ozy`> sup guise. would you all say the haskell community is maybe a little more receptive to feminist concerns than the rails community?
12:08:45 <burp_> > quickCheck 1>0
12:08:46 <SubStack> only if there's a branch of category theory that addresses that
12:08:47 <lambdabot>       No instance for (Ord (IO ()))
12:08:47 <lambdabot>        arising from a use of `>' at <inte...
12:09:43 <dolio> @check 1 > 0
12:09:44 <lambdabot>   "OK, passed 500 tests."
12:10:02 <burp_> ah ok
12:10:04 <mauke> instance Num ()
12:10:13 <monadic_kid> ozy`: what would those concerns be?
12:10:14 <segher> that's good enough for a statistician maybe, but not for a mathematician!
12:10:50 <ozy`> monadic_kid: I dunno... like, not encouraging people to make porn-themed presentations at conferences
12:11:04 <Jedai> ozy`: I'm not sure I see what feminism has to do with programming languages
12:11:12 <therp> porn-themed presentations?
12:11:19 <athos> @check sqrt x = x
12:11:19 <lambdabot>   Parse error at "=" (column 8)
12:11:22 <kadaver> it was pretty retarded imo
12:11:24 <athos> eh
12:11:29 <athos> what the hell :)
12:11:29 <kadaver> size matters; are you a pornstar? etc
12:11:30 <burp_> @check \x -> sqrt x = x
12:11:30 <lambdabot>   Parse error at "=" (column 14)
12:11:37 <kadaver> some ruby conference right?
12:11:38 <burp_> @check \x -> sqrt x == x
12:11:39 <lambdabot>   "Falsifiable, after 2 tests:\n-1.0\n"
12:11:43 <Jedai> ozy`: That doesn't seem to be what I would call "feminism", just decence, no ?
12:11:49 <athos> @check sqrt x^2 == x
12:11:50 <lambdabot>   "Falsifiable, after 0 tests:\n"
12:11:58 <athos> :)
12:12:01 <SubStack> monads, let me show you them
12:12:02 <vixey> @check sqrt (x^2) == x
12:12:04 <lambdabot>   "Falsifiable, after 0 tests:\n"
12:12:25 <BrokenClockwork> > permutate "abc"
12:12:26 <lambdabot>   Not in scope: `permutate'
12:12:28 <monadic_kid> awesome new version of virtual box and fedora 11 out in about months time
12:12:34 <athos> , permutate "abc"
12:12:36 <ozy`> Jedai: I say "feminism" because it's up there in the proverbial tag cloud, but decency is also pretty high, yes
12:12:37 <lunabot>  luna: Not in scope: `permutate'
12:12:43 <athos> , permutations "abc"
12:12:45 <lunabot>  ["abc","bac","cba","bca","cab","acb"]
12:12:51 <athos> there you go
12:12:59 <BrokenClockwork> this is no haskell98 is it?
12:13:03 <BrokenClockwork> > permutations "abc"
12:13:05 <lambdabot>   Not in scope: `permutations'
12:13:15 <athos> no, AFAIK it isn't
12:13:16 <ozy`> kadaver: yeah. the real brouhaha started not because of the presentation itself, but because rails folks defended and encouraged it
12:13:47 <monadic_kid^> ozy`: well i'll doubt you will ever see anything like that in a haskell conference
12:13:47 <athos> the fact that lambdabot does not know what permutations is gives evidence for that ;)
12:14:21 <bremner> ozy`: I know nothing about this situation, but those fights usually result from people prioritizing different principles differently, i.e. "free speech" vs. "common decency
12:14:28 <Jedai> ozy`: I don't think Haskell community would encourage that, but I don't think it would out of feminist concerns... Just that the academics graviting towards Haskell would be really annoyed and embarassed by such a strange and vulgar presentation
12:15:02 <Gracenotes> @vixen what do you think of the recent rails controversy?
12:15:03 <lambdabot> i dunno...
12:15:11 <athos> BrokenClockwork: it may be some nice exercise for yourself to examine a solution
12:15:11 <ozy`> Jedai: the academics would probably tip the scale, yeah
12:15:13 <Gracenotes> hm. good answer, I suppose
12:15:15 <athos> , src ''examine
12:15:16 <lunabot>  luna: Not in scope: type variable `examine'
12:15:21 <athos> eh
12:15:21 <athos> :_
12:15:26 <athos> , src ''permutations
12:15:27 <lunabot>  luna: Not in scope: type variable `permutations'
12:15:29 <dolio> Might females feel ostracized from the Haskell community due to their refusal to wear bow ties?
12:16:00 <idnar> the Haskell community's refusal, or the females' refusal?
12:16:05 <Cadynum> hello. is it possible to construct a pure array when you dont know how long the list building the array is?
12:16:08 <athos> , [$ty|permutations|]
12:16:11 <lunabot>  forall a . [] a -> [] ([] a)
12:16:12 <dolio> Females'.
12:16:29 <athos> woah, [] a
12:16:34 <athos> looks like prettify = False
12:16:34 <athos> :)
12:16:54 <Jedai> Cadynum: No, you have to know the size of the array at constructing time, if only by calling length on the list
12:17:08 <ozy`> @pl (== False)
12:17:09 <lambdabot> (False ==)
12:17:40 <Cadynum> Jedai, i want to create an array from a big file, having the entire file in memory before doing it would mean a big overhead :/
12:17:45 <Jedai> Cadynum: Of course I'm only speaking about the standard Data.Array library
12:18:15 <monadic_kid_top_> ozy`: are you Awesome Princess by anychance?
12:18:27 <ozy`> monadic_kid_top_: uh, not that I know of
12:18:27 <Jedai> Cadynum: You could have a mix of lists and arrays, like lazy ByteString
12:18:49 <Jedai> Cadynum: what's the size of the array ?
12:18:50 <monadic_kid_top_> ozy`: i thought maybe you're are her: http://en.wikibooks.org/wiki/User:Awesome_Princess
12:18:57 <Gracenotes> Cadynum: in other languages, that might be solved by a dynamically allocated array
12:19:20 <Gracenotes> but, Haskell's base array libraries have no analogue for this, afaik
12:19:27 <Cadynum> Jedai, isnt the bytestring just for Chars? i need to allocate a Word array
12:19:33 <Gracenotes> besides copying the entire array
12:19:33 <apeiron> your syntax is weird, also I'm here because SubStack told me to be here.
12:19:34 <ozy`> monadic_kid_top_: nope, I have no idea why that impression would occur to you
12:19:42 <Botje> Cadynum: can you guesstimate how big the array will be?
12:19:53 <Gracenotes> apeiron: :D
12:20:06 <michaelcdever> hey all, so im wondering if anyones used my file manager, and if so what are yer thoughts on it? :D
12:20:12 <Cadynum> Botje, indeed i can, but that would be a big ugly :)
12:20:44 <Gracenotes> Cadynum: so, yeah, speaking of uvector, if all your elements can be unboxed (fixed size), try http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html
12:21:18 <Jedai> Cadynum: Yes, bytestring are for Word8, but the principle of having chunks in a linked list is universal
12:21:21 <monadic_kid_top_> ozy`: well i'm making an assumption that you're female and there aren't female programmers who are interested in functional languages like haskell but she and she wants to learn haskell at some point so i thought maybe you was her
12:21:42 <monadic_kid_top_> ozy`: i mean there aren't many female programmers
12:21:53 <monadic_kid_top_> ozy`: i mean there aren't many female programmers interested in functional programming
12:22:06 <Cadynum> Gracenotes, looks interesting, especially since i use UArrays :)
12:22:24 <Jedai> monadic_kid_top_: You have Audrey Tang (author of Pugs)
12:22:36 <vixey> Jedai: that makes one
12:22:40 <edwardk> @hpaste
12:22:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:22:42 <vixey> I think the statement is true
12:23:00 <ozy`> monadic_kid_top_: I'm a dude... though I guess you might make that assumption because I mentioned feminism.
12:23:01 <Jedai> vixey: @vixen doesn't count, does she ? ^^
12:23:20 <Vq^> the question is if the ratio is lower in the FP world
12:23:22 <Gracenotes> Cadynum: yeah. I'm trying to get my own problem solved with it... it's probably more flexible than UArray, since it is mutable, has Handle functions for encoding to/from file, etc.
12:23:26 <michaelcdever> i know two wimmin who tried haskell, but gave it up quite fast :D
12:23:29 <Vq^> i actually don't think so
12:23:37 <ozy`> monadic_kid_top_: actually, the reason I asked about it in the first place was because I'm also aware that there are few to no women programming haskell
12:23:42 <Jedai> I fear that the ratio is low all around in the CS world...
12:23:45 <earthy> vq^: exactly
12:24:13 <monadic_kid_top_> Jedai: that just came out wrong i meant not many
12:24:15 <earthy> jedai: that's not the issue at hand. (plus, it's regionally fluctuating)
12:24:16 <Vq^> Jedai: i got the feeling that it is slightly higher
12:24:16 <michaelcdever> Jedai: you're quite right from what i can see/tell
12:24:39 <ray> haskell draws from the programming crowd and the stuffy academic crowd, so it could be different
12:24:44 <Vq^> Jedai: (compared to the "software engineering" world)
12:25:17 <Botje> stuffy academic crowd? with the simons and phil wadler?
12:25:25 * earthy grins
12:25:59 <earthy> any graphviz experts 'round?
12:26:07 <ray> phil wadler's lambda bowtie
12:26:33 <Cadynum> Gracenotes, what i basically want to do is have an ip-to-countries tables loaded. i need random access to the elements for quick lookup. it uses more memory than it theoretically should however.
12:27:19 <poucet> roconnor: ping?
12:27:30 <roconnor> ack
12:27:46 <Gracenotes> IPv4? well, maybe a trie might be useful... perhaps
12:27:48 <poucet> roconnor: did you see the article?
12:27:49 <Cadynum> ..and im pretty sure its because of the massive list it must create
12:28:02 <earthy> must create?
12:28:03 <Cadynum> Gracenotes, yep ipv4
12:28:25 <earthy> even ipv6 would do well with a trie for the first 64 bits
12:28:26 <roconnor> poucet: what article?
12:28:28 <Cadynum> earthy, i need to know the length of the list before i can turn it into an array
12:28:47 <Gracenotes> stored as ranges?
12:28:47 <earthy> cadynum: why do you turn the list into an array?
12:28:49 <poucet>  http://cpoucet.wordpress.com/2008/02/08/continued-fractions-in-haskell/
12:29:02 <earthy> why not put things in a Data.IntMap
12:29:03 <poucet> roconnor: that one
12:29:06 <earthy> for IPv4 that'd work
12:29:23 <earthy> and be pretty efficient
12:30:15 <Cadynum> earthy, to look up the ips (they are in ordered) i first go to the element in the middle of the array. then i go either 1/4 "up" or "down" in the array depending if it was greater or lower. then 1/8 etc.. im sorry if i fail at explaining :P
12:30:31 <Gracenotes> ugh. Segmentation fault? uvector, how you disappoint so soon.
12:30:41 <Cadynum> yeah, i dont even understand what i wrote myself :)
12:30:41 <Botje> Cadynum: so you're essentially emulating a tree :p
12:30:44 <earthy> codynum: yes. that is exactly what Data.IntMap does
12:30:52 <Cadynum> Botje, yeah :)
12:30:55 <luite> Gracenotes: you may want to recompile with range checks
12:31:04 <earthy> but Data.IntMap is debugged and ready to go :)
12:31:13 <earthy> oh, and quick. :)
12:31:22 <Gracenotes> 1000 elements isn't too much to write to a file, is it? :\
12:31:22 <luite> Gracenotes: and dons told me to use the darcs version a while ago, because it fixes some bugs, you can try that as well
12:31:26 <roconnor> poucet: neat.  I have pretty much given up on continued fractions myself.  The algorithms for them are too mindboogling for me. :)
12:31:27 <earthy> (of course, not *exactly*, but close enough)
12:31:39 <poucet> roconnor: It was nearly impossible to find any decent papers on the subject.
12:31:49 <Cadynum> earthy, isnt intmap just a normal Map Int *
12:31:49 <roconnor> I believe you
12:31:54 <Cadynum> at least to the programmer
12:32:06 <earthy> cadynum: to the programmer yes, under the hood, no
12:32:18 <earthy> but an IPv4 address *is* an Int
12:32:18 <Cadynum> because the ips are in ranges, one ip can be between two entries
12:32:32 <Gracenotes> http://en.wikipedia.org/wiki/Trie -- good structure
12:33:08 <kadaver> obv they should have the right to do a presentation like that. but that doesnt mean i have to like it.
12:33:08 <earthy> christophe: do you have any idea as to the limits of the ubigraph system? e.g. max node counts?
12:33:16 <Gracenotes> if ranges cover entire subnets, if should be fine
12:33:38 <poucet> afaict, you want to have white-black trees
12:33:43 <poucet> or whatever you call those
12:33:51 <earthy> red-black trees?
12:33:56 <earthy> not for IP->country maps
12:33:56 <poucet> no, the ones that blacklist certain stuff
12:34:01 <poucet> not just inclusionary, but also exclusionary
12:34:07 <earthy> ah
12:34:10 <Cadynum> Gracenotes, i dont think thats the case
12:34:28 <poucet> so you can say foo.* yes but foo.bar.* no
12:34:29 <earthy> hm. yah. no. basically you want to cover the entire address space with as much sharing as possible
12:34:32 <earthy> a trie
12:34:46 <Gracenotes> luite: do you know what the range flag is?
12:34:55 <earthy> (note: this was what the IP geolocation people did back in '99 on then-current machines)
12:35:30 <poucet> you get more sharing if you can get exclusions in there :)
12:35:33 <luite> Gracenotes: I think it's -fsafe
12:35:41 <Gracenotes> okay, trying..
12:35:52 <zmyrgel> I just started to do project euler assignments with haskell and I need little help with my first function
12:35:53 <earthy> poucet: you don't want to exclude much... IPv4 is not a sparse address space ;)
12:35:56 <Gracenotes> well, it seems to accept the option
12:36:01 <poucet> Trie Ip (Maybe $ Either Black White)
12:36:14 <zmyrgel> It doesn't return int as I expected. http://pastebin.com/d690891b6
12:36:15 <Cadynum> earthy, is there some nice convenient example where a trie is in use in haskell?
12:36:23 <earthy> Data.IntMap :)
12:36:42 <earthy> you should even have source links in the haddock if you have a recent GHC install
12:37:01 <Cadynum> earthy, ah, thats what youve been saying all along :P
12:37:25 <poucet> IntMap, *cough*, IntMap?
12:37:32 <poucet> earthy: have an IntMap in your throat?
12:37:43 <Gracenotes> zmyrgel: hm... it compiles for me
12:37:45 <Cadynum> i have to go afk for a while. i will try to implement it using an intmap later. thanks for the help :)
12:37:52 <earthy> ;)
12:38:00 <earthy> something like that ;)
12:38:12 <earthy> ofcourse, I've been playing with Tries a bit lately
12:38:16 <zmyrgel> Gracenotes: yeah, it compiles but instead of nice sum of 33 that I expected I got "sum' 10 0^J33"
12:38:50 <Berengal> zmyrgel: You on emacs by any chance?
12:38:57 <poucet> earthy: were you at hac?
12:39:02 <zmyrgel> Berengal: yeah
12:39:11 <Berengal> That explains it...
12:39:19 <Berengal> Hang on...
12:39:30 <earthy> poucet: nope
12:39:48 <earthy> had to hack some visual basic for work
12:39:55 <Berengal> zmyrgel: You need to "echo 'cat | ghci' >> ghci-no-tty.sh"
12:40:01 <earthy> so I didn't want to torture myself
12:40:09 <zmyrgel> Berengal: ok, It works outside emacs eshell
12:40:14 <Twey> Ew
12:40:14 <earthy> ofcourse, I've switched jobs, so now I can do Haskell again
12:40:41 <Gracenotes> zmyrgel: also, regarding Haskell idioms: Haskell is lazy, so using lists it might seem like something does entire list transformations at a time, but really it transforms individual elements at a time, making it efficient. try checking out "filter" and "sum"... but getting it working first should be fine :)
12:40:52 <Berengal> zmyrgel: Then in your .emacs file, you need to add '(haskell-program-name "$HOME/ghci-no-tty.sh") in the custom-set-variables
12:41:02 <earthy> hm. 31001 nodes in this graph
12:41:06 <earthy> how to visualize this
12:41:06 <zmyrgel> Berengal: ok, thanks
12:41:20 <c_wraith> earthy: a very large sheet of paper
12:41:23 <zmyrgel> Gracenotes: Yeah, as long as it works. Getting to the heavier stuff later :)
12:41:28 <p_l> btw, been today to a bookshop just opposite University of Edinburgh Old College... since UoE uses Haskell in part of the CS course, I decided to check the academic section...
12:41:44 <earthy> c_wraith: dot seems to want to draw empty pngs
12:41:55 <Gracenotes> zmyrgel: yeah. Haskell's combinators are often much more elegant than explicit recursion, and more efficient
12:42:09 <c_wraith> earthy: Oh, I've run into that.  It's unfortunate.  I never really solved it.
12:42:16 <p_l> I found a double-package of Java book and "The Craft of functional programming" second edition on first shelf in CS part :D
12:42:19 <Gracenotes> > filter (\x -> x `mod` 2 == 0) [1..100]
12:42:20 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
12:42:59 <Gracenotes> luite: argh, still get segfault
12:43:10 <zmyrgel> Its my first function... lemme try to get the feel of the simple stuff first
12:43:15 <Gracenotes> sure :)
12:43:18 <thoughtpolice> zmyrgel: really because lists are lazy you can reify them as a 'control structure' of sorts, for example, doing "mapM_ f [1..10]" - this acts similarly to a loop
12:43:28 * p_l will later post the quite hilarious bookshelf photos on the net
12:43:34 <earthy> poucet: have you ever pushed the ubigraph code with thousands of nodes?
12:43:40 <c_wraith> earthy, my only suggestion is to reduce the complexity somehow.  If there are multiple disconnected subgraphs, draw them independently.  If there are complete subgraphs, collapse them.  I think your graph is too big for that to help significantly
12:44:03 <earthy> c_wraith: this is a 'smallish' testset.
12:44:13 <Gracenotes> luite: if you know about uvector, I'm doing.. do { q <- replicateM swrite (generateRandomPair chainwalker 16 g); hPutU file (toU q) }. Does there seem to be a problem inherent in that?
12:44:21 <earthy> the real test will have ten times as much data
12:44:24 <zmyrgel> ... like hearing about design patterns on a basics of programming course
12:44:32 <thoughtpolice> Gracenotes: also, the purity of haskell means that there doesn't need to be any sort of preference given to combinators *or* explicit recursion, because you can merely unfold definitions by replacing instances of the left hand side with their definition on the right hand side, yielding the same thing
12:44:40 <earthy> the fgl lib has no problems with it...
12:45:08 <kadaver> summa from = sum $ filter (\n -> (mod n 3 == 0) && (mod n 5 == 0))
12:45:08 <kadaver>              [from,from-1..0]
12:45:17 <Gracenotes> thoughtpolice: yeah :) the former is a bit more idiomatic+clear once you're comfortable, though
12:45:19 <thoughtpolice> Gracenotes: equational reasoning is awesome, in other words :)
12:45:32 <Berengal> thoughtpolice: Explicit recursion can be confusing. Using combinators it's usually clearer what you're doing
12:45:53 <Gracenotes> kadaver: posting answers, in bad taste :\
12:46:03 <kadaver> sorry
12:46:22 <Gracenotes> :o
12:46:30 <Berengal> Seems he already had the answer though
12:46:34 <ehird> Are immutable arrays optimized to be mutable when appropriate?
12:46:46 <Gracenotes> well. one answer ;)
12:46:50 <burp_> ?src sum
12:46:51 <lambdabot> sum = foldl (+) 0
12:47:17 <Berengal> I don't think it's too bad taste to, when given a solution, suggest improvements?
12:47:18 <thoughtpolice> Berengal: sure, I'm just saying that because of equational reasoning, you can get one or the other
12:47:23 <Matzen> Hi i have problems defining an instance Eq... WinHUgs is complaining about ambiguous variable occurence: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2280#a2280 Any ideas (googled a lot)
12:47:27 <thoughtpolice> Berengal: i prefer combinators, fwiw :)
12:47:42 <Berengal> thoughtpolice: Of course, we all do ;)
12:47:45 <thoughtpolice> ehird: some array libs are based on mutable arrays, yes
12:48:13 <ehird> thoughtpolice: No, I mean, if I use an immutable array, and throw away the old one when changing it, will GHC turn it into a mutable operation or it it not THAT sufficiently smart?
12:48:33 <thoughtpolice> probably not
12:49:11 <ehird> Darn
12:49:21 <Berengal> ehird: The old one will be GCed, obivously, but since the updates themselves might rely on the old array you need to copy it to be safe
12:49:53 <Gracenotes> ugh. the lack of uvector documentation doesn't help either :(
12:49:54 <thoughtpolice> ehird: but that's basically what e.g. the uvector and dph code do. they simply newtype the underlying 'mutable' structure, and your functions are simply views over this type. rewrite rules remove the existence of the constructors, and under the hood of every function you have code with mutable data structures etc.
12:49:54 <ehird> Berengal: GHC can optimize it for, e.g. records though IIRC
12:50:13 <Gracenotes> segfault this, segfault that
12:50:19 <ehird> If I can't get this I'll go for an io array
12:50:32 <Matzen> Any ideas on ambiguous variable occurence? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2280#a2280
12:50:35 <Berengal> ehird: Records may be simpler...
12:51:02 <thoughtpolice> ehird: so, if you do a quicksort, under the hood it's doing an in-place sort on the array, but it's exposed with a pure interface, letting GHC's brain take care of any sort of construction/destruction overhead.
12:51:18 <ehird> thoughtpolice: so, uvector's good then?
12:51:34 <ehird> I'm going to be using this to represent a stack.
12:51:36 <ehird> Well, a stack of stacks.
12:51:39 <ehird> With arbitrary indexing
12:51:41 <thoughtpolice> ehird: you may like this paper - http://www.cse.unsw.edu.au/~rl/publications/recycling.html
12:51:49 <ehird> thanks
12:52:09 <thoughtpolice> ehird: that's part of the technology going into dph
12:52:14 <ehird> (For best results, compile with your user programs with -O2 -fvia-C -optc-O2. ← is this still true? via-C makes me sad :-( )
12:52:36 <thoughtpolice> ehird: it can make a difference on the order of .2s or so
12:52:40 <thoughtpolice> sometimes
12:52:51 <ehird> thoughtpolice: i'll go for -optc-O3
12:52:53 <ehird> then
12:52:59 <Baughn> ehird: GHC still doesn't do loop unrolling. ;_;
12:53:03 <ehird> if you were around yesterday you'd know about my insanely fast competitor ;-)
12:53:14 <ehird> (Something like 20ms to run the program that takes me 25 to parse)
12:53:30 <thoughtpolice> Baughn: when the new backend is operational hopefully it will be easy to write cmm transformations. this is one of the goals, i believe
12:53:36 <ehird> Ah damn... are uvector's not resizable purely?
12:53:54 <Baughn> thoughtpolice: Does that include SSE transformations?
12:53:56 <ehird> ;-(
12:54:13 <dolio> -fvia-C -optc-O3 isn't that much better on most platforms.
12:54:18 <Botje> ehird: if you think about it for a second, the other way wouldn't make sense
12:54:20 <Berengal> ehird: Pure resize = copying it, no?
12:54:20 <thoughtpolice> Baughn: the compiler already does some sse stuff (only on x86_64.)
12:54:31 <dolio> It does better floating point on x86-32, I think.
12:54:37 <ehird> Berengal: Sure, but uvector does other stuff in place...
12:54:50 <ehird> I'd prefer something that automatically resized tbh
12:55:00 <thoughtpolice> dolio: from the look of trac though the sse/mmx code generation is only in the x86_64 backend
12:55:08 <Berengal> Automatic resizing would mess with the parallellism
12:55:11 <danderson> l/win 31
12:55:14 <thoughtpolice> i believe jaffacake is going to change that to x86 as well sometime
12:55:14 <danderson> fail.
12:55:33 <ehird> Berengal: Well foo, I don't do anything parallel :-)
12:56:09 <thoughtpolice> Baughn: but, hopefully the new backend could provide the infrastructure for something like a loop unroller.
12:56:31 <thoughtpolice> Baughn: the transformation engine is pretty complicated, but you only have to write it once and all your transformations benefit
12:57:12 <dolio> Maybe floating point is bad on everything besides x86_64, then. I've only heard people talk about 32 in the past, though.
12:57:13 <andresSR> Matzen: The four equations are part of the instance, so they must be indented
12:59:57 <Gracenotes> uh... what the hell... weirdest uvector bug ever >_<
13:00:15 <dolio> Unfortunately, via-C doesn't get you loop unrolling, either, because it can't tell that the loops are loops.
13:00:24 <Gracenotes> (hPutU file $ singletonU q) immediately segfaults
13:00:33 <Gracenotes> (hPutU file $ rnf q `seq` singletonU q) doesn't
13:00:37 <dolio> Heh.
13:00:56 <Gracenotes> q is just a strict pair... so fully evaluating it shouldn't mean anything?
13:00:58 <thoughtpolice> woot
13:01:05 <thoughtpolice> ghc HEAD is now using haskeline :)
13:01:11 <Gracenotes> I had to define my own instance, instance (NFData a, NFData b) => NFData (a :*: b) where rnf (a :*: b) = rnf a `seq` rnf b
13:02:02 <Gracenotes> q is taken from an IO (Word64 :*: Word64) function... maybe the IO has something to do with it?
13:04:30 <Gracenotes> or maybe it's something that hPutU does with the Handle
13:05:49 <roconnor> ack
13:05:53 <roconnor> lambd-abot
13:05:57 <roconnor> hyphenation fail!
13:07:42 <Gracenotes> WTF
13:07:58 <Gracenotes> O_o .. *backs away slowly from uvector*
13:08:45 <Gracenotes> such a small library, so mindbogglingly unpredictable...
13:14:41 <michaelcdever> if i use the system.gnome.vfs libraries from gtk2hs? will it work on all users machines?
13:14:56 <kowey> dcoutts: after installing that Haskell Platform tarball, I got weird errors on my Mac trying to cabal install darcs - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4407#a4407
13:15:18 <kowey> dcoutts: and after re-installing GHC from the .pkg installer, everything was fine again
13:15:28 <kowey> hope that's at least a little bit useful
13:16:51 <Gracenotes> :\ is there anyone I could talk to about why uvector is segfaulting so?
13:17:14 <Gracenotes> *pokes dons*
13:19:21 <glguy> Gracenotes: uvectors don't necessarily check indexes
13:19:47 <glguy> so it can be easy to run off the end of the pointer
13:19:54 <glguy> array*
13:20:32 <Gracenotes> glguy: okay. although.. I'm using toU, and sending it to hPutU
13:20:43 <Gracenotes> there are no options to add a length
13:21:10 <Gracenotes> the odd part is -- though it may be a red herring -- printing the list before using toU/hPutU makes it not segfault
13:22:59 <Gracenotes> actually, no, it seems that printing individual elements and then using singletonU on them will cause it not to segfault. With an entire list it still does
13:23:52 <Gracenotes> it seems to do all the calculations for that chunk and then promptly segfault
13:25:46 <Gracenotes> well, it is in alpha I suppose :) *uses Data.Binary*
13:25:53 <groaner> should i learn lisp or haskell?
13:26:03 <bremner> yes
13:26:43 <kowey> you could write yourself a Scheme in 48 Hours (in Haskell)
13:28:11 <groaner> i've heard of scheme
13:30:09 <tomh> anyone here uses uulib?
13:31:13 <kowey> groaner: I'm not sure if you're in the target audience - http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:31:41 <kowey> my sort of greedy suggestion was to familiarise yourself with both simultaneously, but that end up just being confusing :-)
13:32:24 <yitz> groaner: what programming languages do you know already?
13:33:01 * wli guesses Java.
13:33:23 <yitz> thanks wli. groaner?
13:37:16 <groaner> i know some C and python and 86 asm
13:37:45 <yitz> wli: ye of little faith
13:37:54 <Zao> groaner: Prepare for a massive paradigm shift then.
13:38:14 <bremner> python to scheme is probably easier (he says ignorantly)
13:38:19 <groaner> what's that mean
13:39:13 <yitz> Zao: if groaner is familiar with Python generators, it's a bit less.
13:40:04 <groaner> i dont know why they call it a generator but i can replace return with yield and use object.next()
13:40:32 <centrinia> Besides the functional programming languages, which programming languages have algebraic data types?
13:40:32 <blackh> groaner: Normal code in Haskell works like a Python generator.
13:41:16 <blackh> groaner: This is not always true, but co-routines are very natural in Haskell.
13:41:24 <Berengal1> groaner: If you want to learn functional programming, learn haskell. If you simply want to learn a new language, any of common-lisp, scheme or haskell will do
13:41:36 <wli> centrinia: Mercury does, and it's a logic language.
13:42:07 <centrinia> Okay, besides the functional and logic programming languages, which programming languages have algebraic data types? :p
13:42:20 <Berengal1> centrinia: Does a union of structs count?
13:42:22 <groaner> i want to the real deal man
13:42:54 <groaner> what's an algebraic data type
13:43:03 <centrinia> Berengal1: If the structs can have members of a type that has not been declared yet, sure. :)
13:43:35 <groaner> so algebra means theres something missing you have to solve?
13:43:39 <Berengal1> centrinia: Well there you go (modulo the little details ;))
13:43:55 <Berengal1> groaner: Algebraic data types are sum types of product types
13:45:09 <groaner> im not asking anymore about tht
13:45:17 <yitz> @where lyah
13:45:17 <lambdabot> www.learnyouahaskell.com
13:45:25 <yitz> @where rwh
13:45:26 <lambdabot> is http://www.realworldhaskell.org/blog/
13:45:37 <yitz> groaner: look at those two ^^
13:45:48 <centrinia> groaner: Just think of them as unions of structs, modulo the little details. :p
13:46:39 <yitz> groaner: don't worry, they're simple and beautiful. look at those links. :)
13:46:52 <centrinia> @src List
13:46:53 <lambdabot> Source not found. :(
13:46:57 <groaner> i saw that one link the other day
13:46:57 <centrinia>  :(
13:47:02 <centrinia> @src []
13:47:03 <lambdabot> data [] a = [] | a : [a]
13:47:04 <groaner> with the cartoons
13:47:34 <Gracenotes> oh, great, another segfault.
13:47:35 <centrinia> groaner: [] is an algebraic data type. It is the sum of an empty constructor with a cons constructor.
13:47:37 <yitz> heh, yeah, that's "lyahfgg"
13:47:44 <Cadynum> earthy, still there? im not really sure how i can make the intmap you proposed do what i want.
13:47:45 <Gracenotes> doing something entirely different
13:48:04 <yitz> Gracenotes: you mean programming in C?
13:48:10 <Gracenotes> using uvector
13:48:15 <yitz> oh
13:48:26 <kadaver> it would be pretty damn cool to ahve a whole OS written in haskell o at least the Desktop env
13:48:29 <groaner> cons?
13:48:35 <kadaver> so you script and stuff always from haskell
13:48:44 <Berengal1> kadaver: xmonad (and House)
13:48:47 <Gracenotes> first I tried to write everything to a file, a segfault. Then I tried to read everything, a segfault. Now I'm trying to unfold a bytestring, segfault
13:48:58 <kadaver> guess I see the point of Smalltalks whatever its caleld runtime system
13:49:54 <centrinia> groaner: They are cons cells. They contain an element of a list paired with a list.
13:50:00 <akamaus> Is there some library for escaping Strings in URIs?
13:50:01 <Berengal1> kadaver: Also, see emacs for an OS/DE with integrated lisp support
13:50:11 <Gracenotes> and, changing my approach.. another segfault
13:50:39 <groaner> [] a cons cell?
13:50:43 <Gracenotes> I think I'm getting more segfaults with this than I ever got programming C :)  (which is not too extensive, but, still)
13:50:48 <centrinia> No, [] is the empty constructor.
13:50:59 <centrinia> It is the empty list. :)
13:51:02 <yitz> Berengal1: hey there's an idea. how about a netbook that boots straight into emacs.
13:51:14 <Berengal1> yitz: It'd never be able to run it ;)
13:51:19 <groaner> i guess i need to scroll up
13:51:22 <peti> Hi. Haskell support in ArchLinux rocks. :-)
13:51:40 <Berengal1> groaner: A list is EITHER a cons cell OR the empty list
13:51:56 <Berengal1> groaner: And a cons cell contains BOTH an element AND the rest of the list
13:52:23 <Berengal1> groaner: And the empty list (also known as 'nil') doesn't contain anything
13:53:06 <groaner> a list with someting bound to it is called a cons cell?
13:53:34 <centrinia> Are all sums of product types isomorphic to some product of sums type?
13:53:41 <Berengal1> groaner: A list in haskell is a linked list. Are you familiar with those?
13:53:54 <groaner> yeah i know what that is
13:54:28 <yitz> groaner: a "cons cell" is the usual memory model of a linked list in lisp-like languages. it is usually implemented as two pointers, one to a data item and the other to the next item in the list.
13:54:54 <Berengal1> groaner: Okay, so a cons cell contains one element of the list and a pointer to the tail. The empty list is simply the guard node at the end, not containing anything
13:55:10 <tensh> I'm having a quite annoying problem, should be something really basic: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2282#a2282
13:55:19 <tensh> it concerns StateT
13:55:59 <groaner> how do you describe a pointer
13:56:05 <tensh> I've been stuck on it for a while now so it'd be nice if someone could explain what's wrong to me
13:57:53 <tensh> anyone?
13:58:53 <yitz> tensh: you can't print a StateT object directly. what should it look like?
14:00:23 <yitz> groaner: what do you mean describe one?
14:00:41 <ali_clark> hey, boring question, if I have -XNoMonomorphismRestriction, is foo :: TypeExpression; foo = value;  exactly equivalent to  foo = value :: TypeExpression;    ? I'm having trouble with the latter.
14:00:57 <zoheb> :T StateT CurState IO a
14:01:02 <zoheb> :t StateT CurState IO a
14:01:03 <blackh> groaner: I come from a similar background to you so I can describe the transition to Haskell. I find Haskell totally brilliant and would never use a "normal" language again.
14:01:03 <lambdabot> Not in scope: data constructor `CurState'
14:01:03 <lambdabot> Not in scope: data constructor `IO'
14:01:25 <Gracenotes> mak no sanse.
14:01:31 <yitz> blackh: you're very lucky if you don't have to
14:01:58 <tensh> yitz: I'm just trying to get anything to work.   test = liftIO $ putStrLn "test"   didn't cut it either
14:02:09 <blackh> yitz: I am working hard to make my own luck.
14:02:14 <tensh> same error
14:02:27 * Berengal1 currently works hard to sneak Haskell into his workplace
14:02:45 <tensh> zoheb: CurState is a data-type defined in my module
14:03:07 <zoheb> :t StateT Int IO a
14:03:08 <lambdabot> Not in scope: data constructor `Int'
14:03:09 <lambdabot> Not in scope: data constructor `IO'
14:03:28 <yitz> @type StateT
14:03:29 <zoheb> :import Control.Monad.State
14:03:30 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
14:03:43 <groaner> wait a minute im gonna read some of this real world haskell since it's free
14:03:53 <Berengal> zoheb: This isn't ghci, in case you were wondering :)
14:04:02 <ali_clark> anyone?
14:04:05 <groaner> ill jaw with ya's in a lil bit
14:04:05 <blackh> Berengal1: I'm considering re-writing a central component at work because it would be far better to write it in Haskell. Not sure whether it's worth the effort to impress them, since I'm not a shareholder. :)
14:04:14 <zoheb> :)
14:04:32 <Gracenotes> ali_clark: well, regular type signatures allow more, unless you have certain language extensions
14:04:59 <Gracenotes> well, 'regular' meaning the former, as opposed to the kind where you just type an expression
14:05:02 <ali_clark> damn I was hoping they were equivalent
14:05:32 <jatqceer> hi, I don't understand why unsafeSTToIO is unsafe.  can someone help me out?
14:05:33 <zoheb> blackh are you a haskell beginner
14:05:36 <yitz> @type runStateT
14:05:37 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:05:41 <blackh> groaner: Also take a look at http://www.learnyouahaskell.com/
14:05:42 <Gracenotes> ali_clark: see http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
14:05:44 <ali_clark> Gracenotes:  its actually a fairly mundane sig thats failing tho
14:05:56 <yitz> @type evalState
14:05:57 <Berengal> blackh: Since going straight to the IT department won't work (I've tried with python, which was immediately rejected. No need to even try Haskell), I'm now trying to go the route through the clerks
14:05:57 <lambdabot> forall s a. State s a -> s -> a
14:05:58 <Gracenotes> oh... is it? Hm. like, just Int?
14:06:04 <yitz> @type execState
14:06:06 <lambdabot> forall s a. State s a -> s -> s
14:06:07 <blackh> zoheb: I've been doing Haskell every day for 8 months so I'm past the beginner stage - I am at the Haskell epiphany stage. :)
14:06:20 <ali_clark> Gracenotes:  [(Bool, t)] -> t -> t;
14:06:26 <zoheb> blach I tried writing my own stuff, make sure you know Monad transformers otherwise writing anything non-trivial gets really hairy
14:06:54 <Botje> Berengal: get them to tell you it's impossible, then conveniently attach your working program :)
14:06:58 <jatqceer> @type unsafeSTToIO
14:06:59 <lambdabot> Not in scope: `unsafeSTToIO'
14:07:02 <blackh> Berengal: I work for a start-up, so saving money can be very convincing. At the moment all they can see is the fact that if they went with Haskell, they would only have one developer instead of 3 that could work on the code.
14:07:12 <yitz> tensh: you would use one of runStateT, evalStateT, execStateT
14:07:18 <dolio> stToIO isn't unsafe.
14:07:24 <ali_clark> thx for the link too
14:07:30 <jatqceer> @type Control.Monad.ST.unsafeSTToIO
14:07:31 <lambdabot> forall s a. ST s a -> IO a
14:07:42 <jatqceer> @type Control.Monad.ST.stToIO
14:07:44 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
14:08:44 <Gracenotes> ali_clark: ah... so it's polymorphic. Maybe scoped type variables if you're using them elsewhere? dunno
14:08:58 <kiris> will I go to hell for writing the state monad in php?
14:09:20 <Berengal> Botje: I've got one better: They've already told us (the clerks, I work as both a clerk and developer) we have to write lots of XML, which probably means most everyone needs a developer to hand-hold them through the process. I've just finished a sexpr2xml converter...
14:09:41 <Botje> grin
14:09:44 <Botje> yay for sexprs :)
14:10:06 <Gracenotes> argh. Is there a particular reason why toU hates me?
14:10:07 <Berengal> Hopefully they'll go for either lisp or haskell (either is fine by me, since it means less java)
14:10:09 <ali_clark> Gracenotes: hmm I guess I'll just stick to the normal way then, am just a bit surprised that they're at all different, maybe the link'll shed some light on it
14:10:28 <Gracenotes> it should just convert a list to a UArr. No segfaults. No pain and misery.
14:10:29 <Botje> Berengal: yay! less java is always a good thing
14:10:33 <jberryman> can anyone figure out this error?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4409#a4409  ... functions from the Data.Digest.Pure.MD5 package apparently want different ByteStrings than what are returned by Data.ByteString.readFile ???
14:10:53 <Botje> correct
14:10:54 <kiris> jberryman: that wlil be the difference between lazy and strict, I suspect
14:11:10 <Botje> it's compiled against a different version of bytestring, too
14:11:50 <Berengal> Botje: The best part about this is that the xml already looks much like code (describing "workflows" and "process unit" and whatever have you enterprisey stuff)
14:11:57 <Botje> :)
14:14:47 <tensh> yitz: okay. I'm trying to get the hang of it :) Might return in a while.
14:14:48 <jberryman> kiris: i'm importing readFile from Data.ByteString.Lazy
14:15:25 <jberryman> Botje: what does that mean, I have the wrong version of the ByteString package?
14:15:58 <Botje> it means Data.Digest is compiled against a different version of ByteString, i think
14:16:41 <yitz> tensh: ok, enjoy.
14:18:39 <tensh> yitz: I think I got it. Thanks for the help.
14:22:01 <da-x> in a haskell module - what's better: have declarations (of any type) depend on later declarations in the same module, or the other way around?
14:22:26 <byorgey> da-x: it depends.
14:22:44 <byorgey> da-x: whichever would be more understandable to someone reading the code is better.
14:23:32 <da-x> I think most people like to read from top to bottom
14:23:48 <c_wraith> da-x: Generally I feel like it's best to have the exported things at the top, and what they depend on below them
14:24:15 <byorgey> right.  but sometimes it is better to start small and then have the more general things at the end; sometimes it's better to have high-level things first and icky details at the end.
14:24:38 <kiris> I tend to think of the file as one big set of where statements
14:24:58 <da-x> take for example Utils/RequestDispatch.hs in hpaste
14:24:59 <kiris> main = foo
14:24:59 <kiris> [where] foo = ... etc
14:25:58 <pcc1> is it possible to tell whether a value is an instance of a particular class from the ghc command line?
14:26:01 <da-x> if I knew that the top depends on the bottom, I'd start reading this file from the bottom to the top, otherwise it's quite hard to follow, I think.
14:26:02 <pcc1> *ghci
14:26:07 <byorgey> da-x: I'm not sure where that is, you'll have to give a link
14:26:54 <da-x> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4410#a4410
14:27:42 <Berengal> pcc1: ":info"
14:28:08 <byorgey> da-x: I agree with you in this case.
14:29:04 <yitz> @info Maybe
14:29:05 <lambdabot> Maybe
14:29:10 * sw17ch wonders if any one here is using atom-0.0.2 ...
14:30:10 <yitz> hmm, ghci does much better than lambdabot here
14:30:33 <mux> @instances Maybe
14:30:33 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
14:30:39 <mux> err
14:30:43 <mux> @src Maybe
14:30:43 <lambdabot> data Maybe a = Nothing | Just a
14:30:49 <mux> @instances Eq
14:30:50 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:31:00 <mux> lambdabot is a bit different
14:31:18 <yitz> @instance-importing Maybe
14:31:18 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
14:31:25 <Saizan_> yitz: there's no @info commnad
14:31:25 <yitz> @instances-importing Maybe
14:31:26 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
14:31:27 <mux> Maybe is not a class
14:31:38 <Saizan_> @info do x <- m; f x
14:31:38 <lambdabot> m >>= \ x -> f x
14:31:58 <pcc1> Berengal: hmm, not always.  e.g. if you have "type LInt = [Int]", :info Int doesn't always show all instances.  this is what I did: "(const 1 :: (Show a) => a -> Int) (undefined :: [Int])"
14:32:07 <pcc1> *:info LInt
14:34:02 * wli ponders numbers representible as a sum of n k-th powers in more than one way.
14:34:47 <wli> The smallest nonnegative numbers representible as a sum of n k-th powers of nonnegative numbers in more than one way even.
14:39:27 <centrinia> wli: Just compute the sum_{j=0}^{n-1} j^k
14:41:00 <sergeym> bye
14:41:01 <wli> centrinia: Well, I've the notion of checking numbers starting from 1. Something like [(i, j, k, l) | i <- [1 .. nthRoot 3 (n `div` 4)], j <- [i .. nthRoot 3 ((n - i^3) `div` 3)], k <- [j .. nthRoot 3 ((n - i^3 - j^3) `div` 2)], let l = nthRoot 3 (n - i^3 - j^3 - k^3), l >= k, i^3 + j^3 + k^3 + l^3 == n]
14:41:50 <sergeym> BYE
14:42:07 <alexbobp> does haskell have a way to do function composition but with the last function taking no arguments?  like, for a g::(Int -> String) and i2::(String -> String -> Int), g .. i2 :: "foo1" "foo2"?
14:42:27 <kadaver> what would it do then?
14:42:42 <alexbobp> g (i2 "foo1" "foo2")
14:42:50 <kadaver> is mutable hashtables and concurreny hard?
14:43:17 <vixey> alexbobp: I think it's ((g .) . i2) "foo1" "foo2"
14:43:26 <vixey> you can define a new '.' like thing instead though
14:43:38 <alexbobp> vixey: oh, so would "g . . i2" with no parens work?
14:43:46 <vixey> no
14:43:47 <Baughn> kadaver: Mutable /anything/ and concurrency is hard
14:44:00 <alexbobp> aww, that would have just made it perfectly convenient :/
14:44:11 <vixey> you could define ... so that  g ... i2  works
14:44:18 <alexbobp> cool
14:44:25 <alexbobp> I'll have to figure out how to do that, thanks
14:44:31 <byorgey> (...) = (.).(.)
14:44:33 <byorgey> I believe
14:44:35 <vixey> (f ... g) x y = f (g x y)
14:44:49 <byorgey> or you could just do that, much more readable =)
14:45:35 <yitz> @pl \f g x y -> f (g x y)
14:45:36 <lambdabot> (.) . (.)
14:45:55 <Baughn> Ah yes. The owl transform.
14:46:04 <beelsebob> fmap fmap fmap
14:46:18 <vixey> @pl \f g -> (f .) . g
14:46:18 <lambdabot> (.) . (.)
14:46:21 <Baughn> beelsebob: That's your solution to everything
14:46:31 <beelsebob> yep
14:46:32 <beelsebob> :D
14:46:38 <Baughn> @type fmap fmap fmap
14:46:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:46:47 <blackh> When you only have fmap, every problem looks like a functor
14:46:55 <beelsebob> :D
14:47:07 <beelsebob> I'd apply that more to monads than functors tbh
14:47:18 <beelsebob> most people ignore functor and applicative, because all problems look like monads
14:47:23 <centrinia> @type fmap fmap fmap fmap
14:47:24 <Baughn> > fmap fmap fmap (+3) [[1,2],[3,4]]
14:47:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:47:25 <lambdabot>   [[4,5],[6,7]]
14:47:55 <beelsebob> > fmap fmap fmap (+3) (+) 1 2
14:47:56 <lambdabot>   6
14:48:22 <Baughn> beelsebob: I believe there is a special circle in hell reserved for this sort of code.
14:48:43 <beelsebob> > fmap fmap fmap sequence fmap return [1,2,3]
14:48:44 <lambdabot>       No instance for (Show (m [a]))
14:48:45 <lambdabot>        arising from a use of `show' at <...
14:48:48 <beelsebob> awwww :(
14:49:17 <Baughn> > fmap fmap fmap sequence fmap return [1,2,3] :: [[Int]]
14:49:19 <lambdabot>   [[1,2,3]]
14:49:25 <beelsebob> that's better :)
14:49:42 <beelsebob> > fmap fmap fmap sequence fmap id [1,2,3]
14:49:43 <lambdabot>       No instance for (Show (m [a]))
14:49:43 <lambdabot>        arising from a use of `show' at <...
14:49:47 <Baughn> > (:[]) [1,2,3]
14:49:48 <beelsebob> oh, duh
14:49:48 <lambdabot>   [[1,2,3]]
14:49:50 <Baughn> Just because.
14:50:01 <beelsebob> yeh, but fmap fmap fmap sequence fmap is actually useful
14:50:06 <beelsebob> it's mapA
14:50:07 <Baughn> For WHAT
14:50:09 <Baughn> ..
14:50:22 <Baughn> Fine. But I think I'd rather use mapA.
14:50:31 <beelsebob> yeh, but that's not in the prelude
14:50:42 <beelsebob> having said that, sequence in the prelude is the wrong type too
14:50:42 <beelsebob> :(
14:50:53 <Baughn> ..return is the wrong type
14:51:00 <beelsebob> indeed
14:55:20 <sinelaw>  /join ##lmms
14:55:28 <Elly> you have not done it right
14:55:37 <sinelaw> of course :)
14:55:47 <sinelaw> just checking your attention
14:55:52 <sinelaw> :P
14:56:51 <CyberGarp>  I asked a question earlier, then got called away. I'm going to rephrase it now, because I think I'm more likely to get an answer. I want to write simple images (jpeg or equiv), that are essentially just plotting dots in positions. Ideally I'd like to have mpeg movies of these over time, but I'll settle for jpegs (ImageJ can make movies quickly). What library in Haskell will allow me to make simple animations like this? I was looking at Ca
14:57:08 <yitz> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
14:57:09 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:57:54 <aragats> i'm trying to build xmonad-contrib from darcs, but getting the following error:
14:57:57 <aragats> XMonad/Util/Run.hs:134:8: Not in scope: `uninstallSignalHandlers'
14:58:15 <blackh> CyberGarp: gtk2hs provides cairo which does this - not sure whether it's the best or not.
14:58:31 <CyberGarp> that'll work, does gtk2hs work on a Mac?
14:58:47 <beelsebob> yep
14:58:49 <alexbobp> Well it looks like somebody likes saying "fmap fmap fmap"
14:58:50 <blackh> CyberGarp: It's the most complete library binding for this kind of that I know of for Haskell, but "that I know of" doesn't necessarily include all that much.
14:58:58 <beelsebob> but not with the native binding – only with the X11 one
14:59:07 <CyberGarp> Okay, how do I get it?
14:59:28 <yitz> alexbobp: we're just making fun of beelsebob
14:59:48 <blackh> CyberGarp: http://haskell.org/gtk2hs/ The install is makefile based (not cabal).
14:59:57 <CyberGarp> ah
15:00:04 <beelsebob> centrinia: sudo port install gtk cairo cairomm gtksrcview, and then run gtk2hs's ./configure; make
15:00:05 <beelsebob> etc
15:00:36 <CyberGarp> beelsebob, thx
15:00:56 <alexbobp> oh I see now
15:00:57 <blackh> CyberGarp: gtk2hs seems quite complete and stable - I haven't done anything directly with cairo though, but it must be good because Chart uses it, and it does good stuff.
15:01:06 <CyberGarp> gtk not found...
15:01:10 <yitz> beelsebob: macport's ghc is 6.10.1 does gtk2hs work there yet?
15:01:23 <blackh> CyberGarp: What OS are you using?
15:01:26 <CyberGarp> mac
15:01:35 <beelsebob> yitz: it's 6.10.2 it has problems with, and I've had no problems on my mac
15:01:46 <beelsebob> only on windows boxen
15:02:17 <blackh> CyberGarp: Then I don't know the answer. The Ubuntu package name is libgtk2.0-dev
15:02:25 <yitz> beelsebob: i haven't gotten macports to build gtk2hs on my tiger box for a long time
15:02:45 <Berengal> Does foo ++ bar ++ baz really display quadric behaviour?
15:02:56 <CyberGarp> yitz, ouch
15:03:05 <beelsebob> yitz: that's why I didn't say to use mac ports to build gtk2hs
15:03:06 <beelsebob> only gtk
15:03:06 <blackh> CyberGarp: If you have trouble, you may be able to configure gtk2hs to build only the cairo part.
15:03:16 <yitz> ah
15:04:14 <gio123> lambda x. F   F is a second order formula, can x be second order?
15:04:39 <CyberGarp> blackh, looks like that's what I'll try
15:06:40 <Baughn> gio123: lambda x. x
15:06:59 <Baughn> gio123: Unless that doesn't count as a "second-order formula"
15:08:02 <Saizan_> Berengal: a ++ (b ++ c) is linear, (a ++ b) ++ c is quadratic
15:09:33 <mdmkolbe1> Saizan_: well technically they are both linear
15:09:41 <Berengal> Saizan_: Seems like it shouldn't be too hard to optimize away the last one though
15:10:07 <Berengal> Since it's basically just building two constructors and discarding the first...
15:11:02 <CyberGarp> Won't build
15:11:03 <CyberGarp> ugh.
15:12:59 <mdmkolbe1> Saizan_: it is only when you go to foldr or foldl of (++) that you get the quadratic behaviour
15:13:16 <blackh> CyberGarp: A few months ago I looked for graphics library bindings, and the only other one that was more than an empty shell was hsmagick.
15:13:27 <CyberGarp> blackh
15:14:09 <Saizan_> mdmkolbe1: well yeah, i used 3 elements but really meant an arbitrary sequence of those
15:14:11 <blackh> CyberGarp: I don't think it amounts to much even now but it might be worth adding to it.
15:16:41 <centrinia> > foldl (\xs y -> xs ++ [y]) [] [1..100000]
15:16:56 <lambdabot>   thread killed
15:17:07 <centrinia> > id [1..100000]
15:17:07 <CyberGarp> blackh, looks like the hsmagick can manipulate/stretch an image, but I want a black image and dots filled in.
15:17:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:17:48 <CyberGarp> I had a GLUT program that was working, but want to turn it into static movies (28 frames/sec), and I couldn't figure out how to do that.
15:18:48 <centrinia> > foldr (\y xs  -> y:xs ) [] [1..100000]
15:18:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:18:55 <centrinia> That was faster.
15:19:35 <jbapple> Can anybody here get hsc2hs via cabal install? I get: Building hsc2hs-0.67.20061107...
15:19:35 <jbapple> Main.hs:32:7:
15:19:35 <jbapple>     Could not find module `System.Process':
15:19:35 <jbapple>       it is a member of package process-1.0.1.0, which is hidden
15:20:14 <Saizan_> jbapple: the right version of hsc2hs comes with ghc usually
15:21:05 <jbapple> That's funny, I do have it installed
15:21:12 <jbapple> HSQL tried to find it and failed
15:21:18 <kadaver> bah why is scala and clojure getting more recognition than haskell?
15:21:19 <jbapple> I mean, cabal install HSQL
15:21:51 <jbapple> Preprocessing library hsql-1.7.1...
15:21:51 <jbapple> /usr/local/bin/hsc2hs: line 14: /usr/local/lib/ghc-6.10.1/hsc2hs: No such file or directory
15:21:58 <kadaver> haskell is so much btter than they are. they stole everything good about them from haskell. scala ia a kitchensink with some good ideas from haskell and clojure is haskell light.
15:22:36 <jbapple> oh, that' just an old bad copy
15:22:45 <jbapple> GHC should really come with an uninstall script
15:23:16 <jbapple> This is like the fourth time the "remove everything that looks suspicious from /usr/local and pray" strategy bit me
15:23:25 <scottkidder> jbapple: lol
15:28:26 <CyberGarp> blackh, what about graphics-gd? That looks about like what will do the job.
15:28:46 <floyd> can i use a function with more than one argument with map?
15:29:18 <vixey> no
15:29:52 <blackh> CyberGarp: That's a good find - I'll remember that.
15:30:14 <CyberGarp> Looks good, but I can't find the dependency...
15:30:21 <CyberGarp> I'll work on this tomorrow...
15:31:07 <byorgey> floyd: you can, but it might not do what you want.
15:31:16 <byorgey> floyd: can you give an example of what you are trying to do?
15:31:21 <byorgey> perhaps you want zipWith?
15:32:49 <floyd> i have a function that takes 4 arguments, i want to map a list to its first argument
15:32:58 <floyd> should i just use a list comprehension?
15:33:04 <byorgey> floyd: and what do you want to get out?
15:33:17 <floyd> a list
15:33:22 <byorgey> a list of what?
15:33:29 <floyd> ints
15:33:32 <Gracenotes> map (\arg -> f arg x y) myList
15:33:43 <Gracenotes> well, plus a z
15:33:47 <byorgey> floyd: but where do the ints come from?
15:33:56 <centrinia> The function?
15:33:56 <Gracenotes> assuming that's what you mean...
15:33:58 <byorgey> floyd: where does f get its other arguments?
15:34:34 <floyd> they're passed in
15:34:50 <byorgey> ah, I see.  then you indeed want what Gracenotes typed above.
15:34:58 <floyd> ok thanks
15:35:01 <Gracenotes> @pl \arg -> f arg x y z
15:35:01 <lambdabot> flip (flip (flip f x) y) z
15:35:15 <ray> flippity floppity floo
15:35:17 <byorgey> \arg -> f arg x y  is a function which takes one argument and passes it to f, along with x and y
15:35:23 <Gracenotes> flip just feels sorta dirty >->
15:35:36 <byorgey> do not use flip, do not pass Go, do not collect $200.
15:35:36 <ray> one flip is fine but 3 is ugly
15:35:59 <Gracenotes> it does in fact show that pointfree code is very applicative in style, particularly as stack-oriented languages have flip keywords they use a lot
15:36:05 <Gracenotes> informally anyway
15:36:12 <mauke> :t ?x `flip` ?y `flip` ?z
15:36:13 <lambdabot> forall a b b1 c. (?z::b1, ?y::b, ?x::a -> b -> b1 -> c) => a -> c
15:36:33 <mauke> f `flip` x `flip` y `flip` z
15:37:02 <Gracenotes> hm..... what do you all tend to use for slide show presentations?
15:37:30 <centrinia> @type flip ((.) . (.))
15:37:32 <lambdabot> forall a b c a1. (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
15:37:36 <ray> is projecting soothing julia sets not an option?
15:37:38 <Cadynum> hello again. i cant get the intmap to work as i would like, im pretty sure it cant do this: http://pastebin.com/m72c8518e or have i missed something?
15:37:38 <centrinia> That flips a bird. :)
15:37:50 <Gracenotes> ray: no :(
15:37:55 <ray> :(
15:38:38 <Gracenotes> well, OpenOffice should work
15:38:52 <centrinia> latex-beamer :)
15:39:09 <Gracenotes> ooh
15:39:09 <mauke> yeah, I've used latex
15:39:32 <mauke> I've also seen a presentation given with vim
15:39:44 <Gracenotes> heh.
15:39:48 <mauke> plain text, ascii art, mappings for navigation
15:40:38 <ray> you'd think emacs would make a better presentation program
15:40:48 * centrinia wonders if anyone has done a slide show with a first person shooter engine.
15:41:25 <Gracenotes> ray: would be nice fit, since you don't need a text editor to give a presentation
15:42:04 <centrinia> You don't need a computer to give a presentation. :)
15:42:09 <ray> if you're going to be using elisp, though, then the obvious question is "why not upgrade to scheme"
15:42:31 <Gracenotes> I remember a presentation that the designer of a game with a level editor gave
15:42:37 <ray> and from there you're on the slippery slope to writing your own presentation program
15:42:58 <Gracenotes> it was a room-based, top-down, step-based dungeon-esque game
15:43:04 <Gracenotes> he basically traveled from room to room, showing off the game's features
15:43:09 <ray> a roguelike?
15:43:30 <Gracenotes> in spirit, but entirely different game dynamics. http://forum.caravelgames.com
15:43:39 <kynky> sounds like something i played on my acorn electron
15:43:55 <mauke> http://vigor.sourceforge.net/screenshots/
15:43:57 <Gracenotes> http://forum.caravelgames.com/viewsitepage.php?id=89468
15:44:02 <Gracenotes> screenshots
15:44:45 <Gracenotes> mauke: adorable! :3
15:47:51 <Gracenotes> okay, let me see if I can do this properly or if I'll kludge it with OpenOffice instead
15:59:07 <floyd> what does "or" do if its in front of a list comprehension?
15:59:41 <centrinia> It returns True if any element in the list is True.
15:59:42 <centrinia> > or []
15:59:44 <lambdabot>   False
16:00:02 <floyd> ok thanks
16:00:02 <centrinia> If the list is empty, then it returns False. :p
16:18:30 <leimy> @users
16:18:30 <lambdabot> Maximum users seen in #haskell: 658, currently: 601 (91.3%), active: 11 (1.8%)
16:20:57 <leimy> > (/x -> 3) 1466754344
16:20:58 <lambdabot>   <no location info>: parse error on input `->'
16:21:08 <leimy> Oops
16:21:47 <leimy> (\x -> 3) 67546643
16:21:49 <ray> how does / look like a lambda
16:22:18 <vixey> it doesn't
16:22:20 <leimy> > (\x -> 3) 47765455654
16:22:21 <lambdabot>   3
16:22:32 <ray> you're right, IT DOESN'T
16:22:58 <leimy> Right. Iphone keyboard makes life "fun"
16:24:10 <ray> > (\x -> 3) undefined
16:24:11 <lambdabot>   3
16:24:19 <ray> that's real ultimate power
16:24:47 <tiglionabbit> out of curiousity, could you use the original zipWith to define another version of zipWith that works on functions with 3 parameters?
16:25:13 <vixey> yes
16:25:22 <vixey> tiglionabbit you can do it
16:26:09 <tiglionabbit> how would you?
16:26:12 <leimy> :t (\x -> 3)
16:26:13 <lambdabot> forall t t1. (Num t1) => t -> t1
16:26:36 <leimy> :t const 3
16:26:38 <lambdabot> forall t b. (Num t) => b -> t
16:26:59 <dolio> Is this a homework question?
16:27:08 <leimy> I wonder how it decides b from t1
16:27:17 <leimy> Er b from t
16:27:34 <dolio> b comes from the type of const.
16:27:34 <Cale> leimy: you mean how it names the variables?
16:27:42 <leimy> Yes
16:27:47 <dolio> tN comes from it generating fresh variables.
16:28:18 <leimy> Lol i wish i still had homrwork
16:28:21 <Cale> leimy: If there's an explicit type signature somewhere, it tries to use the variable names from that, otherwise, it picks unused ones from a sequence
16:28:28 <tiglionabbit> dolio: no, just curious
16:28:39 <leimy> Cale: Makes sense
16:28:44 <ray> :t zipWith
16:28:45 <Cale> :t (\x y z -> 1)
16:28:46 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:28:46 <dolio> Or, I should say, ts come from making up variable names for lambda expressions like (\x -> 3).
16:28:47 <lambdabot> forall t t1 t2 t3. (Num t3) => t -> t1 -> t2 -> t3
16:29:17 <Cale> :t const
16:29:18 <lambdabot> forall a b. a -> b -> a
16:29:34 <leimy> Ah. Neat
16:29:47 <Cale> Here, 'a' gets unified with the fresh type variable which was generated for 3
16:29:50 <leimy> :t flip const
16:29:51 <lambdabot> forall a b. b -> a -> a
16:30:23 <dolio> @type \f l1 l2 l3 -> zipWith ($) (zipWith f l1 l2) l3
16:30:25 <lambdabot> forall a b a1 b1. (a1 -> b1 -> a -> b) -> [a1] -> [b1] -> [a] -> [b]
16:30:29 <leimy> > (flip const) 5
16:30:30 <lambdabot>       Overlapping instances for Show (a -> a)
16:30:30 <lambdabot>        arising from a use of `s...
16:31:06 <leimy> > id
16:31:07 <lambdabot>       Overlapping instances for Show (a -> a)
16:31:07 <lambdabot>        arising from a use of `s...
16:32:13 <leimy> :t flip id
16:32:14 <lambdabot> forall b c. b -> (b -> c) -> c
16:33:20 <leimy> :t id
16:33:21 <lambdabot> forall a. a -> a
16:33:52 <leimy> Flip is pretty neat.
16:34:22 <vixey> > (flip const) 5 ()
16:34:23 <lambdabot>   ()
16:36:06 <Lemmih> > flip const 5 ()
16:36:07 <lambdabot>   ()
16:36:58 <centrinia> @type fix const
16:37:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
16:37:00 <lambdabot>     Probable cause: `const' is applied to too few arguments
16:37:00 <lambdabot>     In the first argument of `fix', namely `const'
16:37:37 <vixey> :t fix . const
16:37:38 <lambdabot> forall a. a -> a
16:37:52 <centrinia> @type fix (flip const $ 2)
16:37:54 <lambdabot> forall a. a
16:38:01 <centrinia> > fix (flip const $ 2)
16:38:02 <lambdabot>   * Exception: stack overflow
16:38:49 <c_wraith> Hmm.  const should be non-strict
16:39:04 <c_wraith> > fix (const 5)
16:39:06 <lambdabot>   5
16:39:10 <c_wraith> that's what I thought
16:39:48 <centrinia> Well, I think (flip const $ 2) is id.
16:40:02 <centrinia> > (flip const $ 2) [1..10]
16:40:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:40:06 <c_wraith> yes, it is.  And that is definitely strict.
16:40:26 <c_wraith> fix's argument needs to be non-strict to have a result other than an infinite loop. :)
16:44:16 <Cale> hackageDB needs a "Packages by author" listing :)
16:46:45 <c_wraith> @help
16:46:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:46:49 <c_wraith> @list
16:46:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:48:24 <c_wraith> I know I'm going to screw up the syntax here...
16:48:38 <c_wraith> @check fix . const == id
16:48:39 <lambdabot>       No instance for (Eq (a -> a))
16:48:39 <lambdabot>        arising from a use of `==' at <int...
16:48:48 <c_wraith> is it ===?
16:49:18 <centrinia> IT is difficult to determine the equality of functions. ;)
16:49:24 <vixey> @let (===) = liftA2 (==)
16:49:26 <lambdabot>  Defined.
16:49:26 <BONUS> > fix (&& True)
16:49:30 <BONUS> my ghci dies if i try to run this
16:49:33 <vixey> try it c_wraith
16:49:42 <lambdabot>   thread killed
16:49:42 <BONUS> can anyone try this?
16:49:47 <BONUS> yeowch
16:49:50 <c_wraith> @check fix . const === id
16:49:51 <lambdabot>       precedence parsing error
16:49:51 <lambdabot>          cannot mix `(.)' [infixr 9] and `(===...
16:49:55 <vixey> :(
16:50:09 <centrinia> @check (fix . const) === id
16:50:10 <lambdabot>   Not in scope: `==='
16:50:56 <centrinia> @let (===) = liftA2 (==)
16:50:57 <lambdabot>  <local>:14:0:
16:50:57 <lambdabot>      Multiple declarations of `L.==='
16:50:57 <lambdabot>      Declared at: <local...
16:51:09 <centrinia> That does not make sense.
16:51:11 <BONUS> does anyone know why ghci dies at fix (&& True)
16:51:27 <centrinia> > fix (True &&)
16:51:29 <lambdabot>   * Exception: stack overflow
16:51:35 <centrinia> > fix (True ||)
16:51:36 <lambdabot>   True
16:51:41 <centrinia> > fix (|| False)
16:51:49 <BONUS> > fix (&& False)
16:51:57 <lambdabot>   thread killed
16:51:58 <centrinia> > fix (False &&)
16:52:00 <lambdabot>   False
16:52:04 <lambdabot>   thread killed
16:52:07 <c_wraith> @src &&
16:52:07 <lambdabot> True  && x = x
16:52:08 <lambdabot> False && _ = False
16:52:31 <BONUS> hmm
16:54:30 <dibblego> has anyone put lambdabot on a vmware image yet?
16:54:52 <dibblego> I need to get it to newcomers on other networks and channels
16:55:27 <ray> missionary work?
16:55:46 <kadaver_> > zipWith (+) [1..10] [11..20]
16:55:47 <lambdabot>   [12,14,16,18,20,22,24,26,28,30]
16:56:23 <kadaver_> > let zipW3 f xs ys zs = zipWith f (zipWith f xs ys) zs
16:56:24 <lambdabot>   <no location info>: parse error on input `;'
16:56:40 <kadaver_> > let zipW3 f xs ys zs = zipWith f (zipWith f xs ys) zs in zipW3 (+) [1..3] [4..6] [7..9]
16:56:42 <lambdabot>   [12,15,18]
16:57:13 <gwern> dibblego: why not just have lb join?
16:57:20 <gwern> (it's not like we care about other networks)
16:57:26 <ray> :t zipWith3
16:57:28 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:57:37 <kadaver_> too bad couchdb wasnt written in haskell
16:57:42 <kadaver_> seems like a good fit
16:57:42 <dibblego> gwern, I don't have @join privileges and I care about other networks
16:58:18 <kadaver_> > map flip [(+) 1 3, (-) 4 5]
16:58:20 <lambdabot>       Overlapping instances for Show (b -> a -> c)
16:58:20 <lambdabot>        arising from a use ...
16:58:29 <kadaver_> > map flip [(+) 1 3, subtract 4 5]
16:58:31 <lambdabot>       Overlapping instances for Show (b -> a -> c)
16:58:31 <lambdabot>        arising from a use ...
16:58:52 <Axman6> kadaver_: well, the distribution of erlang probably makes ita better choice than haskell
16:59:06 <kadaver_> > map flip [\ -> (+) 1 3, \ -> subtract 4 5]
16:59:07 <lambdabot>   <no location info>: parse error on input `->'
16:59:13 <kadaver_> > map flip [\a b -> (+) a b, \a b -> subtract a b]
16:59:14 <lambdabot>       Overlapping instances for Show (b -> b -> b)
16:59:14 <lambdabot>        arising from a use ...
16:59:17 <centrinia> Erlang distribution?
16:59:24 <kadaver_> OTP
16:59:32 <Pseudonym> I would have agreed with that once, but I'm not so sure now.
16:59:37 <Pseudonym> STM is _nice_.
17:00:13 <Pseudonym> People have written highly concurrent persistent hash tables and B-trees with STM.
17:00:45 <Pseudonym> (It may not be obvious how to make them persistent.  Essentially, you abort the transaction and issue a read if the memory cache doesn't have what you want.)
17:02:24 <kadaver_> > map flip [\a b -> (+) a b, \a b -> subtract a b]
17:02:25 <lambdabot>       Overlapping instances for Show (b -> b -> b)
17:02:25 <lambdabot>        arising from a use ...
17:02:29 <kadaver_> why isnttha working?
17:02:44 <kadaver_> > map flip [(\a b -> (+) a b), (\a b -> subtract a b)]
17:02:45 <lambdabot>       Overlapping instances for Show (b -> b -> b)
17:02:46 <lambdabot>        arising from a use ...
17:03:13 <kadaver_> > flip (\f a b -> f a b)
17:03:14 <lambdabot>       Overlapping instances for Show (b -> (b -> t -> t1) -> t -> t1)
17:03:14 <lambdabot>        ...
17:03:23 <Saizan_> kadaver_: tou can'y show funcyions..
17:03:29 <kadaver_> > flip ((\f a b -> f a b) (+) 10 20)
17:03:31 <lambdabot>       Overlapping instances for Show (b -> a -> c)
17:03:31 <lambdabot>        arising from a use ...
17:03:33 <kadaver_> > flip ((\f a b -> f a b) (+) 10 20))
17:03:34 <lambdabot>   <no location info>: parse error on input `)'
17:03:46 <kadaver_> > flip ((\f a b -> f a b) (+) 10 20)
17:03:48 <lambdabot>       Overlapping instances for Show (b -> a -> c)
17:03:48 <lambdabot>        arising from a use ...
17:03:52 <kadaver_> shouldnt thayt eval?
17:04:02 <kadaver_> > (\f a b -> f a b) (+) 10 20
17:04:03 <lambdabot>   30
17:04:11 <kadaver_> > flip (\f a b -> f a b) ((+) 10 20)
17:04:12 <lambdabot>       Overlapping instances for Show ((b -> t -> t1) -> t -> t1)
17:04:12 <lambdabot>        arisi...
17:04:17 <kadaver_> > flip ((\f a b -> f a b) ((+) 10 20))
17:04:18 <lambdabot>       Overlapping instances for Show (b -> a -> c)
17:04:19 <lambdabot>        arising from a use ...
17:04:47 <Axman6> > flip . (\f a b -> f a b) (+) 2 $ 3
17:04:48 <lambdabot>       Overlapping instances for Show (b -> a -> c)
17:04:48 <lambdabot>        arising from a use ...
17:04:53 <Axman6> :\
17:05:14 <EvilTerran> Axman6, er, (\f a b -> f a b) = id
17:05:31 <glguy> kadaver_: maybe experiment in /msg first
17:06:37 <floyd> i have a list of tuples, i want to return the tuple with the maximum second value from the list.. how would i do that?
17:06:48 <zrf> :hoogle Bool -> (a -> a) -> (a -> a)
17:07:08 <dolio> @type maximumBy (\(_, v, _) -> v)
17:07:10 <lambdabot>     Occurs check: cannot construct the infinite type:
17:07:10 <lambdabot>       t = (t1, t, t2) -> Ordering
17:07:10 <lambdabot>     Probable cause: `v' is applied to too many arguments
17:07:22 <floyd> awesome thanks
17:07:22 <dolio> @type maximumBy (comparing $ \(_, v, _) -> v)
17:07:24 <lambdabot> forall a t t1. (Ord a) => [(t, a, t1)] -> (t, a, t1)
17:07:35 <zrf> (is there something like a fst3/snd3, btw?)
17:07:43 <zrf> @hoogle Bool -> (a -> a) -> (a -> a)
17:07:44 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
17:07:44 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
17:07:44 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:08:08 <dolio> Nope. I'd thought they were putting one in, but apparently not.
17:08:26 <EvilTerran> @type maximumBy (comparing $ \(_, v, _) -> v)
17:08:27 <lambdabot> forall a t t1. (Ord a) => [(t, a, t1)] -> (t, a, t1)
17:08:34 <EvilTerran> ?index comparing
17:08:34 <lambdabot> bzzt
17:08:41 <EvilTerran> ?hoogle comparing
17:08:41 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
17:08:41 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
17:26:42 <kadaver> name an application where dynamic typing is just better
17:28:21 <kadaver> name an application where dynamic typing is just better
17:32:39 <ManateeLazyCat> Have a way make me *break* `mapM`? Example, i scan list and search match item then stop scan. Thanks!
17:32:40 <skorpan> kadaver: web
17:34:24 <kadaver> skorpan: web?
17:34:27 <kadaver> as in webapps?
17:34:41 <skorpan> web frameworks
17:34:43 <kadaver> i wrote a simple webserver in haskell, had no trouble with that
17:35:05 <skorpan> reflection is an extremely nice thing to have in web frameworks i've learned
17:35:07 <zakwilson> I'm not sure about web apps being ideal choices for dynamic typing. I can think of several situations where static typing would simplify development and keep out the bugs.
17:35:39 <kadaver> why?
17:36:36 <zakwilson> It seems to me that it's more a matter of development style; if you know what you're making in advance, static typing helps express it at a high level. If you don't, dynamic typing can make it easier to change.
17:36:36 <floyd> i'm still having trouble returning a tuple from a list of tuples based on the maximum second value =(
17:37:57 <skorpan> :t max
17:37:59 <lambdabot> forall a. (Ord a) => a -> a -> a
17:38:25 <skorpan> > max [ x | (y, x) <- [(3,8), (8,7)] ]
17:38:26 <lambdabot>       Overlapping instances for Show ([t] -> [t])
17:38:26 <lambdabot>        arising from a use o...
17:38:29 <skorpan> darn it
17:39:10 <skorpan> > max $ map snd [(3,8), (8,7)]
17:39:12 <BlackM> > maximum [ x | (y, x) <- [(3,8), (8,7)] ]
17:39:12 <lambdabot>       Overlapping instances for Show ([b] -> [b])
17:39:12 <lambdabot>        arising from a use o...
17:39:14 <lambdabot>   8
17:39:18 <skorpan> :|
17:39:21 <skorpan> :t maximum
17:39:22 <lambdabot> forall a. (Ord a) => [a] -> a
17:39:23 <BlackM> :)
17:39:26 <skorpan> oh
17:39:31 <skorpan> i was so close though
17:39:40 <kadaver> > last $ sortBy (comparing snd) [(1,22),(3,4)]
17:39:41 <lambdabot>   (1,22)
17:39:59 <skorpan> kadaver: there's no reason to sort anything
17:41:21 <BlackM> skorpan: " return[ing] a tuple from a list of tuples based on the maximum second value "
17:41:29 <dibblego> @type maximum . fmap snd
17:41:30 <lambdabot> forall a b. (Ord b) => [(a, b)] -> b
17:41:37 <skorpan> oh
17:42:03 <ManateeLazyCat> Have a way transform "IO Bool" to "Bool"?
17:42:18 <skorpan> ManateeLazyCat: unsafePerformIO!! use it whenever you can, it's the best
17:42:25 <BlackM> ManateeLazyCat: UR DOIN IT RONG! :\
17:42:31 <ManateeLazyCat> skorpan: I don't use it.
17:42:31 <skorpan> :t unsafePerformIO
17:42:32 <lambdabot> Not in scope: `unsafePerformIO'
17:42:34 <ManateeLazyCat> skorpan: Never
17:42:38 <Lemmih> ManateeLazyCat: And when unsafePerformIO doesn't work, try unsafeCoerce#.
17:42:51 <skorpan> ManateeLazyCat: no, but there is no way to transform it
17:43:02 <dibblego> @type maximumBy $ comparing snd
17:43:03 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
17:44:29 <ManateeLazyCat> skorpan: unsafePerformIO just hacking way, but not a pretty way to solution problem.
17:44:44 <skorpan> ManateeLazyCat: i know, i was kidding
17:45:12 <skorpan> but there really is no other way
17:45:18 <skorpan> this is actually being discussed on the mailing list
17:46:09 <ManateeLazyCat> skorpan: I use expression "find bufferIsFocus bufferList" to find *match* item from `bufferList`, but function `bufferIsFocus` is "IO Bool", maybe i need find other way to solution my problem.
17:46:32 <dolio> @free unsafeCoerce :: a -> b
17:46:33 <lambdabot> g . unsafeCoerce = unsafeCoerce . f
17:46:52 <skorpan> ManateeLazyCat: do you know about do-blocks and >>= and stuff?
17:47:03 <ManateeLazyCat> skorpan: Yep.
17:47:29 <skorpan> then i'm confused
17:48:11 <ManateeLazyCat> skorpan: do-blocks is syntax sugar to wrap *multi-lines" code, like `progn` in elisp. :)
17:48:35 <skorpan> well, not really like progn :P but almost
17:48:46 <ManateeLazyCat> skorpan: similar.
17:49:23 <skorpan> so anyways, there is no way to convert it. but using do-blocks and >>= you should be able to figure out how to get the result from your IO Bool
17:49:46 <skorpan> just know that there is no way (except for unsafe stuff) to go from IO a to a
17:50:25 <skorpan> do { res <- find bufferIsFocus bufferList; print res; return res }
17:50:36 <skorpan> that puts the Bool in "res", prints it and returns it
17:50:43 <skorpan> but that entire do-block is now IO Bool as well!
17:53:44 <ManateeLazyCat> skorpan: No, problem is function `bufferIsFocus` is "IO Bool", so GHC will faild if first argument of `find` is not "Bool".
17:57:16 <Saizan> ManateeLazyCat: define your own findM
17:57:17 <ManateeLazyCat> skorpan: Have a way *loop* bufferList, and jump out when match condition? Then i can use "Bool" in loop.
17:57:52 <Saizan> ManateeLazyCat: whit the type findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
17:58:30 <skorpan> :t find
17:58:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:58:39 <skorpan> heh, didn't even know that was a function
17:58:42 <Saizan> ManateeLazyCat: you can do that as a simple recursive function
17:58:46 <skorpan> now i see what the hell you're talking about :P
17:59:28 <ManateeLazyCat> Saizan: Thank, i try.... :)
17:59:33 <ManateeLazyCat> thanks
18:00:18 <Saizan> ManateeLazyCat: come back with your code if you get stuck :)
18:00:38 <ManateeLazyCat> Saizan: I will, thanks. :)
18:06:43 <ManateeLazyCat> Saizan: findM is really nice. Thank you very much! :)
18:07:11 * ManateeLazyCat pasted "findM" at http://paste2.org/get/194823
18:07:17 <ManateeLazyCat> Above is my implement of findM
18:07:21 <hydo> I think I missed something in my reading about monads in general... In the ghc docs for the State and StateT monads, they define "plusOne :: Int -> Int" that uses execState to call a function defined as "tick :: State Int Int" .  What is the purpose of the second Int?  code: http://tinyurl.com/dfajdy
18:07:39 <ManateeLazyCat> Now i use expression "findM bufferIsFocus bufferList" to solution my problem.
18:07:44 <Pseudonym> @hoogle State
18:07:44 <lambdabot> module Control.Monad.State
18:07:45 <lambdabot> Test.HUnit.Base data State
18:07:45 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
18:07:49 <Pseudonym> Hmm.
18:08:02 <Pseudonym> @kind State
18:08:04 <lambdabot> * -> * -> *
18:08:07 <Pseudonym> Right.
18:08:11 <Pseudonym> State takes two types.
18:08:17 <Pseudonym> A monad has a "return value", right?
18:08:18 <hatds> One Int is the type of the internal state, the other is the return type
18:08:22 <Pseudonym> Yeah.
18:08:24 <Pseudonym> Basically.
18:08:32 <hydo> oh!  ok, that makes sense.
18:08:45 <Pseudonym> @type Control.Monad.State.read
18:08:47 <lambdabot> Not in scope: `Control.Monad.State.read'
18:08:50 <Pseudonym> @type reads
18:08:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:08:58 <Pseudonym> @type gets
18:08:59 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
18:09:02 <Pseudonym> There.
18:09:16 <Pseudonym> You can see both s and a used there.
18:09:24 <Pseudonym> s is the internal state type, and a is the return type.
18:09:35 <hydo> hence "-> m a"
18:09:39 <Pseudonym> Yeah.
18:10:01 <hydo> Thanks a lot, Pseudonym and hatds
18:11:51 <ManateeLazyCat> Saizan: Why GHC haven't include `findM`? It really nice sometimes, such as "IO Bool" problem with function `find`.
18:15:31 <kadaver> > foldl1 (\mx t -> if snd mx > snd t then mx else t) [(22,33),(88,77),(34,12)]
18:15:32 <lambdabot>   (88,77)
18:16:47 <kadaver> > let swap (a,b) = (b,a); kadavers = [(12,3),("dons","aisling")] in map swap kadavers
18:16:48 <lambdabot>       No instance for (Num [Char])
18:16:48 <lambdabot>        arising from the literal `3' at <in...
18:16:56 <kadaver> > let swap (a,b) = (b,a); kadavers = [("dons","aisling")] in map swap kadavers
18:16:58 <lambdabot>   [("aisling","dons")]
18:17:04 <dibblego> > (maximumBy $ comparing snd) [(22,33),(88,77),(34,12)]
18:17:06 <lambdabot>   (88,77)
18:17:07 <[00]> hey lol
18:17:25 <[00]> just for kicks, has anybody tried to explain concurrency with a picture??
18:17:30 <kadaver> neat dibblefgo
18:17:54 <[00]> i think this would be very suiting as a representation of how concurrency should be used with a non functional language
18:17:56 <[00]> http://blueballfixed.ytmnd.com/
18:18:07 <kadaver> <[00]> dont know but your question got me thinking about a game whreree you controlled time and a robot
18:19:15 <[00]> i also thought a movie made entirely from the "monsters" perspective would be cool but tthat blue ball machine thing woul dbe good to say, this is how u have to think of threads in C
18:20:15 <[00]> if you dont know the volitile keyword, you cant come close to how awesome haskell
18:20:48 <[00]> hey....
18:20:49 <ManateeLazyCat> Use `fromJust` is bad behaviour? Example i define function that return "fromJust a" (a is Maybe A).
18:20:58 <[00]> kadaver you got a gud thing
18:21:06 <[00]> instead of a throttle, you control how fast you move through time
18:21:23 <hatds> Sometimes a Nothing value indicates an error
18:21:46 <hatds> so you really aren't protecting yourself by doing all the cases then
18:22:17 <ManateeLazyCat> hatds: Yep, beginning i use fromJust for save time that write "case ... of Nothing -> ... Just x ....".
18:22:41 <ManateeLazyCat> hatds: But i found if `a` is Nothing, function will indicate an error.
18:22:58 <dibblego> ManateeLazyCat, you might want to use fromMaybe
18:23:21 <ManateeLazyCat> :t fromMaybe
18:23:22 <lambdabot> forall a. a -> Maybe a -> a
18:23:27 <dibblego> ManateeLazyCat, fromJust is unsafe -- it assumes you, the programmer, know that it is a Just constructor
18:23:40 <dibblego> > fromMaybe 7 (Just 8)
18:23:41 <lambdabot>   8
18:23:43 <dibblego> > fromMaybe 7 Nothing
18:23:44 <lambdabot>   7
18:23:48 <gwern> dibblego: pshaw, fromJust is no more dangerous than a run of the mill function like 'head'
18:24:04 <dibblego> gwern, sure
18:24:30 <dibblego> gwern, ManateeLazyCat> hatds: But i found if `a` is Nothing, function will indicate an error.
18:24:48 <gwern> @quote head
18:24:49 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
18:25:06 <c_wraith> I'm slightly bothered by the fact that there are things that can result in an error that don't require MonadError.  It seems like that could have been handled better.
18:25:08 <gwern> @quote head.*safe
18:25:09 <lambdabot> Binkley says: in response to [Philippa] plus who wants to get unsafeHead? [Binkley] Philippa: not if you're doing it in literate Haskell. because, you know, the LaTeX makes it safe
18:25:45 <ManateeLazyCat> :t fromJust
18:25:46 <lambdabot> forall a. Maybe a -> a
18:25:48 <hatds> ever hear the subscript operator (!!) joke?
18:26:26 <gwern> @quote \!\!
18:26:26 <lambdabot> EvilRanter says: I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
18:26:32 <gwern> @quote \!\!
18:26:33 <lambdabot> kealyow says: haskell always your SNOOPY POSTER!!
18:26:36 <gwern> @quote \!\!
18:26:36 <lambdabot> kealyow says: haskell always your SNOOPY POSTER!!
18:26:41 <gwern> hatds: apparently not
18:26:54 <hatds> "never bang a list you wouldn't head"
18:26:56 <paulo> Algum brasileiro aí ?
18:27:23 * gwern ponders whether to @remember that
18:27:33 <dibblego> I can't make head or tail of it
18:27:51 <paulo> Tem algum brasileiro aí?
18:28:19 <hatds> :P
18:29:05 <hatds> the equations within a single let binding can be completely reordered, even in the case of shadowing an outer let binding, right?
18:29:30 <paulo> ghc6 teste.hs
18:29:38 <paulo> teste.hs:1:0: The function `main' is not defined in module `Main'
18:29:48 <paulo> What is wrong?
18:30:07 <paulo> type Par = (Int, Int)
18:30:08 <paulo> somaAmbos :: Par -> Int
18:30:08 <paulo> somaAmbos (primeiro, segundo) = primeiro + segundo
18:31:01 <kadaver> if u know it cant be wrong you use mp Map.! k
18:31:31 <hatds> what's mp?
18:31:40 <QtPlaty[HireMe]> paulo: You need a function called main in your module Main.
18:32:20 <kadaver> the Map
18:32:42 <kadaver> > Map.fromList [(1,2),(3,4)] Map.! 3
18:32:43 <lambdabot>   4
18:32:46 <kadaver> > Map.fromList [(1,2),(3,4)] Map.! 22
18:32:47 <lambdabot>   * Exception: Map.find: element not in the map
18:33:06 <kadaver> > Map.lookup 3 $ Map.fromList [(1,2),(3,4)]
18:33:06 <lambdabot>       No instance for (Show (m a))
18:33:07 <lambdabot>        arising from a use of `show' at <in...
18:33:28 <kadaver> > fromJust $ Map.lookup 3 $ Map.fromList [(1,2),(3,4)]
18:33:29 <lambdabot>   4
18:33:38 <kadaver> > fromJust $ Map.lookup 33 $ Map.fromList [(1,2),(3,4)]
18:33:39 <lambdabot>   * Exception: Maybe.fromJust: Nothing
18:33:51 <kadaver> > fromMaybe 0 $ Map.lookup 33 $ Map.fromList [(1,2),(3,4)]
18:33:52 <lambdabot>   0
18:33:56 <kadaver> > fromMaybe 0 $ Map.lookup 1 $ Map.fromList [(1,2),(3,4)]
18:33:58 <lambdabot>   2
18:35:46 <ManateeLazyCat> dibblego: But use `fromMaybe` i need give it a *alternative* value, right?
18:35:48 <paulo> QtPlaty[HireMe], can you give me one code is working?
18:35:56 <dibblego> ManateeLazyCat, correct
18:36:12 <paulo> QtPlaty[HireMe], an example...
18:36:14 <psygnisfive> haskellonians!
18:36:41 <psygnisfive> i bring you greetings, and at least one question!
18:37:11 <ManateeLazyCat> dibblego: But i don't know this value, it generate in run-time.
18:37:36 <dibblego> ManateeLazyCat, a Maybe t is not a t -- I cannot help that fact
18:37:40 <dibblego> @djinn Maybe t -> t
18:37:40 <lambdabot> -- f cannot be realized.
18:37:50 <ventonegro> paulo: http://book.realworldhaskell.org/read/getting-started.html
18:38:03 <psygnisfive> how do you load from ghci
18:38:20 <ManateeLazyCat> psygnisfive: :l
18:38:22 <byorgey> Greetings psygnisfive!
18:38:32 <psygnisfive> hey byorgs.
18:38:35 <psygnisfive> :l?
18:38:38 <psygnisfive> oh.
18:38:38 <byorgey> psygnisfive: it depends what you would like to load.
18:38:49 <psygnisfive> a haskell file
18:38:54 <ManateeLazyCat> psygnisfive: :l is short of `:load`.
18:38:54 <byorgey> that you wrote?
18:38:59 <psygnisfive> yah.
18:39:09 <psygnisfive> :l is an interpreter command i take it
18:39:15 <byorgey> right
18:39:19 <psygnisfive> ok.
18:39:31 <byorgey> and :m +Foo is for loading modules that are installed
18:39:35 <psygnisfive> im used to scheme and ruby which have load commands that look like normal commands ;P
18:40:06 <psygnisfive> i take it :l is scoped to the dir you were in when you launch ghci?
18:40:09 <kadaver> :l "blah.hs" looks pretty normal to me
18:40:17 <kadaver> and ruby:
18:40:20 * kadaver pukes
18:40:26 <psygnisfive> aww stop that :|
18:40:28 <psygnisfive> i like ruby
18:40:38 <boyscared> cabal question: i want to install base-4.1.0.0, and currently have 3.0.2.0 registered. if i run `cabal install base --reinstall' i get the message `cabal: There is no available version of base that satisfies -any'. any clues how to proceed?
18:40:38 <psygnisfive> ruby is beautiful for functional programming, i have to say.
18:40:44 <psygnisfive> OO functional programming is sexy.
18:40:51 <ManateeLazyCat> dibblego: I think best way is make function return `Maybe a`, then i write "case ... of Nothing -> ... Just x ...." every place, even write it is painful.
18:41:02 <gwern> boyscared: I would say you are totally doing the wrong thing
18:41:17 <ManateeLazyCat> dibblego: fromJust is not safe way to fix problem even it save my finger.
18:41:22 <hatds> fromJust is basically only useful when the alternative is fromMaybe (error "uh oh") x, but you can't always avoid such situations
18:41:27 <psygnisfive> OO in general is oddly close to Forth-esque coding, i realized
18:41:29 <dibblego> ManateeLazyCat, what are you going to use where case Nothing -> ?
18:41:41 <boyscared> gwern: i figured as much. i've read the docs but am apparently missing something important
18:41:45 <abuiles> boyscared: I think base is part of ghc
18:41:56 <ManateeLazyCat> dibblego: Nothing -> Nothing or Nothing -> return False
18:42:20 <dibblego> ManateeLazyCat, in the former case use (>>=) and in the latter case use Data.Foldable.all
18:42:30 <boyscared> well, a higher version of base is required for me to upgrade xmonad
18:42:39 <abuiles> boyscared : which version of ghc have you got ?
18:42:40 <byorgey> boyscared: base-4 comes with ghc 6.10.
18:42:55 <kadaver> yeah funcall is sexy...
18:43:00 <psygnisfive> kadaver, why do you dislike ruby?
18:43:00 <byorgey> boyscared: that shouldn't be true.
18:43:03 <boyscared> i'm using 6.8.3, which is the current version for freebsd
18:43:30 <byorgey> boyscared: I am running the most current version of xmonad on ghc 6.8.3 with base 3.0.2.0.
18:43:43 <kadaver> i dont really, just messing with you, it is ok. but from that group of langs i much prefer python
18:43:50 <boyscared> ok, i misspoke, cabal install xmonad seems to be running ok now
18:44:22 <byorgey> boyscared: cool, if you have more trouble, just give me a holler in #xmonad
18:44:47 <psygnisfive> aww guys this sucks :(
18:44:49 <boyscared> thanks :)
18:44:57 <psygnisfive> my code is giving me nasty type errors that it shouldnt be giving me
18:45:04 <ManateeLazyCat> hatds: fromMaybe (error "uh oh") x still will indicate error, but we can custom error string. :)
18:45:15 <dibblego> psygnisfive, yes it should :)
18:45:20 <psygnisfive> lies!
18:45:22 <dibblego> ManateeLazyCat, right
18:45:36 <psygnisfive> dibblego: its a very simple little piece of code
18:45:41 <psygnisfive> but the part that its choking on is
18:45:49 <dibblego> psygnisfive, let's see it and we'll find the lie
18:45:52 <psygnisfive> s f x = s (\y -> y + f x)
18:46:10 <kadaver> xmonad only works on *nix?
18:46:39 <byorgey> kadaver: right
18:46:53 <byorgey> well, I guess you could maybe get it to work on OS X  (?)
18:47:07 <psygnisfive> OS X is *nix
18:47:07 <byorgey> psygnisfive: what type does s have?
18:47:08 <psygnisfive> :P
18:47:08 <dibblego> psygnisfive, you cannot declare that s accepts two arguments then apply it to only one argument in its body -- it is you that is telling lies!
18:47:14 <ManateeLazyCat> dibblego: I think i need use "fromMaybe (error "bla, bla, bla") x" instead "fromJust x", at least i can find where the problem fast, `fromJust` just give me error that `Nothing`.
18:47:27 <psygnisfive> s should be (Int -> Int) -> Int -> Int
18:47:29 <dibblego> ManateeLazyCat, right, you might like to define fromMaybe . error
18:47:41 <dibblego> psygnisfive, then why are you only applying it to one argument in the body?
18:47:49 <psygnisfive> its a partial application
18:47:51 <byorgey> psygnisfive: right, so the right-hand side of the definition should have type Int, right?
18:48:13 <psygnisfive> i guess the type system wont allow it
18:48:14 * byorgey just said 'right' a few times too many
18:48:16 <ManateeLazyCat> dibblego: I really hate write "case ... of Nothing -> error Just x -> ..."
18:48:17 <psygnisfive> but
18:48:28 <dibblego> psygnisfive, but it's in the body declaration -- it is inherently contradictory
18:48:30 <psygnisfive> yeah ok
18:48:32 <psygnisfive> i see :p
18:48:40 <psygnisfive> i was thinking in untyped LC! :|
18:48:42 <dibblego> psygnisfive, type checking ftw
18:49:21 <dibblego> ManateeLazyCat, just define fromMaybe . error
18:49:42 <dibblego> @type let maybeErr = fromMaybe . error in maybeError
18:49:43 <lambdabot> Not in scope: `maybeError'
18:49:44 <ManateeLazyCat> dibblego: Ok, thanks for your help! :)
18:49:46 <dibblego> @type let maybeErr = fromMaybe . error in maybeErr
18:49:48 <lambdabot> forall b. [Char] -> Maybe b -> b
18:50:03 <dibblego> > let maybeErr = fromMaybe . error in maybeErr "boo!" (Just 7)
18:50:04 <lambdabot>   7
18:50:09 <dibblego> > let maybeErr = fromMaybe . error in maybeErr "boo!" Nothing
18:50:11 <lambdabot>   * Exception: boo!
18:50:39 <hatds> is there any way to automatically embed the source line number into a error like with asserts?
18:52:24 <psygnisfive> hrmph
18:52:46 <byorgey> hatds: not really.  But 'error' in Haskell should be an absolute last resort.
18:52:57 <psygnisfive> i guess i cant do what i wanted to do in haskell
18:52:59 <psygnisfive> shame :(
18:53:10 <byorgey> psygnisfive: I doubt that.  What did you want to do?
18:53:22 <dibblego> so do I
18:53:40 <psygnisfive> find a way to have an arbitrary # arguments
18:53:40 <byorgey> @faq can Haskell do what psygnisfive wanted to do?
18:53:40 <hatds> byorgey: but it would help tracking down errors during testing
18:53:40 <lambdabot> The answer is: Yes! Haskell can do that.
18:53:55 <dibblego> psygnisfive, all haskell functions accept 0 or 1 argument
18:54:02 <psygnisfive> i know, dibblego
18:54:06 <psygnisfive> but i was experimenting!
18:54:11 <psygnisfive> the types are what kills it, see
18:54:18 <dibblego> no that is not what kills it
18:54:23 <psygnisfive> yes it is
18:54:25 <byorgey> hatds: my point is, if you have so many calls to 'error' that you need line numbers to find them, something is wrong. =)
18:54:27 <Lemmih> psygnisfive: Familiar with printf?
18:54:38 <psygnisfive> dibblego: ignore types and consider:
18:54:41 <dibblego> psygnisfive, no it isn't -- define what you want and it can almost certainly be done
18:54:54 <psygnisfive> s f 0 = f 0; s f x = s (\y -> y + f x)
18:55:29 <psygnisfive> the types kill this, because s f x produces a function, but s f 0 should just produce a number
18:55:32 <hatds> byorgey: I have just one error, but I'd rather not have to create a string to either remember or ctrl+F  It's worse in multi module programs
18:55:39 <dibblego> that's inherently contradictory'
18:55:44 <psygnisfive> no its not dibblego
18:55:57 <dibblego> yes it is
18:55:59 <psygnisfive> no.
18:55:59 <byorgey> I see what psygnisfive is trying to do.
18:56:00 <psygnisfive> its not.
18:56:07 <dibblego> byorgey, great, care to help?
18:56:30 <byorgey> s f 0 = f 0;  s f 1 0 = s (\y -> y + f 1) 0 = 0 + f 1, and so on
18:56:38 <psygnisfive> exactly.
18:56:52 <psygnisfive> so if you start with, say... s id 5 4 3 2 1 0
18:56:56 <psygnisfive> you should get back 15
18:57:46 <byorgey> hatds: well, I see what you mean, but unfortunately, I don't know of a way to do what you want.
18:58:23 <dibblego> @type (<*>)
18:58:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:59:07 <byorgey> psygnisfive: well, this CAN be done in Haskell, but it requires a bit of type gymnastics.
18:59:16 <psygnisfive> yeah, i figure.
19:00:34 <byorgey> psygnisfive: in practice, of course, you can use one list argument instead of a variable number of arguments.
19:00:37 <ManateeLazyCat> dibblego: Have builtin function in GHC like `maybeErr`?
19:00:43 <psygnisfive> well yes byorgey
19:00:54 <dibblego> ManateeLazyCat, not that I am aware of
19:00:57 <psygnisfive> im actually in favor of lists for arbitrary numbers of arguments
19:01:08 <ManateeLazyCat> dibblego: Ok, i write my self one: "maybeError :: String -> Maybe a -> a"
19:01:15 <dibblego> ManateeLazyCat, sure
19:01:15 <psygnisfive> i think the tradition of doing stuff like sum(1,2,3,4,5,6,...) is bad form
19:01:40 <psygnisfive> however, i wanted to see if, even in a language with strict monadic functions, you could still achieve something effectively identical
19:01:52 <psygnisfive> and it seems you can.
19:01:56 <psygnisfive> which is unfortunate
19:02:03 <byorgey> well, the monads have nothing to do with it =)
19:02:07 <dibblego> strict monadic functions?
19:02:09 <psygnisfive> no no..
19:02:15 <psygnisfive> monadic, as in single-argument
19:02:18 <dibblego> you could do it with a type-class I imagine
19:02:18 <psygnisfive> as opposed to dyadic
19:02:30 <psygnisfive> or triadic or tetradic or ...
19:02:31 <hatds> it seems to me that in your way above you would have to allow '15' to be applied as a function
19:02:35 <psygnisfive> unary/binary/ternarcy/...
19:02:48 <psygnisfive> maybe 15 should be a function! :p
19:02:57 <psygnisfive> in LC it surely is
19:02:58 <hatds> instane Num (a->b) or something? :)
19:03:01 <hatds> *instance
19:03:18 <psygnisfive> i dont remember what it is in LC tho
19:03:21 <ManateeLazyCat> Have any tips that will return "current function name"?
19:03:39 <hatds> to be honest I've used typeclasses like that to lift values where one normally wrap values
19:03:48 <psygnisfive> ::shrug::
19:03:53 <psygnisfive> i was just curious to see if it was possible
19:03:59 <psygnisfive> and i defaulted to haskell just because.
19:04:25 <ManateeLazyCat> Then i can generate function name in my *error* function
19:04:56 <hatds> return the function name without returning an error?
19:05:39 <hatds> because you can use assert to find the source line number which is just as good, but only as an error output
19:05:47 <byorgey> ManateeLazyCat: no, you can't get at the "current function name"
19:05:52 <ManateeLazyCat> hatds: I wonder have a tips that return current function name, then i can return error with "FunctionName: bla, bla..."
19:06:05 <byorgey> the current function name is not at all well-defined at runtime.
19:06:59 <ManateeLazyCat> byorgey: Thanks. I see.
19:08:26 <kadaver> haskell is teh elegant!
19:10:55 <c_wraith> template haskell can get access to the current function name, I believe.  You might be able to use it to do what you want.
19:11:08 <c_wraith> well..  current lexically
19:11:29 <ManateeLazyCat> c_wraith: template haskell?
19:12:01 <c_wraith> It's a compile-time template system, somewhat like lisp macros.
19:12:52 <ManateeLazyCat> c_wraith: So you have demo code that can get "current function name"?
19:13:17 <c_wraith> ManateeLazyCat: sorry, I don't.  I'm aware of what it can do, but I have no experience using it.
19:13:34 <ManateeLazyCat> c_wraith: I wonder have a way can get "current module name", then i can't binding "current module name" with some function.
19:14:40 <psygnisfive> ok im out guys. <3
19:14:54 <ManateeLazyCat> c_wraith: So looks need some hacking tips to do that. But thanks for information, i will look it in the future.
19:14:55 <ManateeLazyCat> :)
19:15:36 <ManateeLazyCat> Now, it's not big problem to me, just like study some secret tips. :)
19:18:01 <dmead> any of you guys know prolog?
19:18:26 <wli> Yes.
19:20:45 <komap> some
19:50:26 * byorgey bakes focaccia sprinkled with sun-dried lambdas
19:53:34 * dolio disbelieves byorgey.
19:54:18 * roconnor cobelieves byorgey
19:59:29 * idnar rebelieves byorgey 
20:02:07 * BlackM doesn't care; he just wants some focaccia!
20:03:22 * wli tries to think of something he can actually accomplish.
20:05:49 <QtPlaty[HireMe]> Is there any TLS libaries other then hsgnutls?
20:06:02 * roconnor tries to imagine:
20:06:02 <adu> wow
20:06:06 <roconnor> instance Comonad (Density f) where
20:06:07 <roconnor> 	duplicate (Density f ws) = Density (Density f) ws
20:06:10 <adu> I just learned something terrible!
20:06:43 <wli> adu: What?
20:07:24 <adu> wli: that influenza (flu) was first observed in Haskell County, Kansas
20:07:42 <idnar> haha
20:10:36 <dolio> We need to start a disinformation campaign. I'll post a story saying it was OCaml County on reddit.
20:10:47 <adu> lololol
20:14:44 <Pseudonym> Says here it was San Diego County and Imperial County, California.
20:14:51 <Pseudonym> Where did you get your information?
20:14:57 <adu> Wikipedia
20:15:08 <adu> http://en.wikipedia.org/wiki/1918_flu_pandemic
20:15:24 <Pseudonym> Oh, influenza.
20:15:27 <Pseudonym> Not the current outbreak.
20:15:28 <Pseudonym> Gotcha.
20:15:40 <adu> oh you were talking about swine flu
20:15:47 <adu> I think thats about Spanish flu
20:15:57 <Pseudonym> Right.
20:16:11 <Cale> I'll tell you one thing, all this talk about swine is making me hungry for bacon.
20:16:16 <Cale> Mmmm... bacon.
20:16:25 <Pseudonym> We could still say that the current outbreak started on the island of Java.
20:16:39 <Pseudonym> Except that Java is majority Muslim, and they don't herd pigs there.
20:17:29 <adu> lol yes, lets do that
20:20:04 <adu> so what is everyone's favorite list notation? (1) [Type], (2) Type[], or (3) Type list
20:22:20 * mmorrow imagines with horror what Ptr [Ptr [Ptr (a -> [Ptr b])] -> Ptr [c]] would be in C
20:22:21 <Pseudonym> adu: List Type
20:22:28 <Pseudonym> But I can live with [Type].
20:23:03 * adu shudders at mmorrow
20:23:24 <Cale> mmorrow: void *
20:23:28 <monochrom> Ty[]pe
20:23:35 <adu> Cale: lol
20:23:36 <mmorrow> Cale: heh
20:24:02 <Pseudonym> std::list<boost::shared_ptr<type_t> >
20:25:08 <adu> Pseudonym: why shared pointer?
20:25:24 <dolio> Everyone knows lists are slow. You should use arrays.
20:25:31 <Pseudonym> Just in case type_t doesn't have copy semantics.
20:27:31 <adu> dolio: aren't their optimizations for that?
20:27:33 <mmorrow> preflex: cdecl void*(*f[])(void*)
20:27:48 <mmorrow> gah, i can never figure out how to cdecl to work
20:27:53 <mmorrow> preflex: list
20:27:54 <preflex>  8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
20:28:01 <adu> like how GHC replaces [Char] with CString?
20:28:22 <mmorrow> type CString = Ptr CChar
20:28:56 <dolio> preflex: 6st 1 2 3 6 7 11
20:28:57 <preflex>  1st 2rd 3th 6st 7rd 11st
20:29:02 <mmorrow> is cdecl gone?
20:29:13 <mmorrow> preflex: help cdecl
20:29:13 <preflex>  unknown command: cdecl
20:29:17 <mmorrow> :o
20:30:04 <kadaver> anyone made an array/list structure for haskell? ala python
20:30:39 <Cale> There's Data.Array.*
20:30:48 <dolio> An automatically resizing mutable array, you mean?
20:31:01 <dolio> I don't think there's anything strictly like that.
20:31:14 <dolio> Haskell folk would likely use a map instead.
20:31:18 <Cale> or Data.Sequence
20:31:58 <dolio> Yeah, I always forget about that.
20:33:42 <mmorrow> preflex: tell mauke cdecl is gone?!
20:33:42 <preflex>  Consider it noted.
20:33:57 <SamB> but whatever you do, *don't* go through [1..] or [0..] looking for unused Map/IntMap keys ;-P
20:36:58 * wli tries to come up with something he can actually do to do.
20:37:33 <SamB> you could write an OS entirely in Haskell
20:37:48 <wli> Beyond my power. :(
20:38:07 * SamB thought he was going to say it sounded too much like his day job :-)
20:38:10 <wli> I can't even write a faster fib at this point.
20:38:17 <soultaker> can anyone help me with this code i wrote?
20:38:30 <dolio> Write it in agda, that way you can prove it works right.
20:38:33 <SamB> wli: are you tired ?
20:38:37 <Cale> soultaker: probably :)
20:38:40 <wli> No.
20:38:42 <SamB> dolio: but can you prove that it is faster ?
20:38:50 <SamB> wli: faster than what ?
20:39:19 <wli> SamB: The ones that one guy and I already have out there.
20:39:45 * SamB isn't familiar with anyone by that name
20:39:46 <dolio> SamB: I thought I saw something about algorithmic complexity proving in some language lately, but I can't remember where.
20:40:10 <Cale> soultaker: What did you write?
20:41:10 <soultaker>  gets (stock.price);
20:41:15 <soultaker> getting an error there
20:41:21 <soultaker> the only error is there
20:41:26 <SamB> oh, that's because you're supposed to write this
20:41:32 <Cale> What are the types of price and stock?
20:41:41 <SamB> GET NUMBER FROM FILE STORING STOCK.PRICE
20:41:46 <soultaker> stock is a struct
20:41:47 <Cale> pff
20:41:52 <soultaker> and price is an integer
20:41:57 <Cale> soultaker: uh, oh
20:42:06 <dolio> What is that? Cobol?
20:42:18 <SamB> dolio: intended to evoke the idea of cobol
20:42:29 <SamB> I don't actually know cobol, though
20:42:35 <Stinger> its the caps that does it
20:42:37 <byorgey> maybe it ought to be (price . stock) ?
20:42:41 <SamB> so it's probably giberish
20:42:42 <Cale> soultaker: can I see the definition? You're presumably using the State monad yeah? Is it State Stock ?
20:42:51 <byorgey> function composition and all that
20:42:54 <soultaker> price is in the struct
20:43:00 <byorgey> soultaker: you know . is function composition, right?
20:43:03 <Cale> gets price ?
20:43:11 <SamB> what language are we talking about here ?
20:43:19 <byorgey> SamB: good question =)
20:43:20 <soultaker> yer, wish i could send you the code to see
20:43:20 <Cale> I assumed it was Haskell...
20:43:22 <Cale> :t gets
20:43:23 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:43:48 <Cale> gets wants a function from the state type
20:43:53 * SamB somehow assumed it as C
20:44:05 <SamB> it looked like C to my parsers ;-P
20:44:10 <Cale> hehe
20:44:14 <soultaker> yea
20:44:25 <Cale> soultaker: So, you're composing the functions stock and price
20:44:34 <soultaker> yer
20:44:43 <Cale> soultaker: what does ghci report as their types?
20:44:51 <Stinger> did you ask someone in #c if they did c therer and they said no we do perl, ask in Haskell or something? :)
20:44:56 <soultaker> char
20:44:59 <Cale> (comment out the line with gets so your file will load :)
20:45:02 <Cale> char?
20:45:11 <SamB> Stinger: it's ##c, actually, and no
20:45:15 <Cale> Do you mean Char ?
20:45:21 <SamB> he didn't ask anything there just now
20:45:21 <soultaker> yer
20:45:23 <Cale> Can I have a complete type signature?
20:45:31 <Cale> That doesn't sound right.
20:45:34 <Cale> Do:
20:45:38 <Cale> :t stock
20:45:40 <lambdabot> Not in scope: `stock'
20:45:42 <Cale> :t price
20:45:43 <lambdabot> Not in scope: `price'
20:45:47 <Cale> in ghci
20:45:53 <Cale> and tell me what it says :)
20:46:23 <Cale> Oh, maybe it's a parameter to your function though :P
20:46:45 <soultaker> the error says
20:47:25 <SamB> does it?
20:47:29 * byorgey waits with bated breath
20:47:52 <soultaker> cannot convert int* to char* for argument '1' to char* gets (char*)
20:48:06 <Cale> soultaker: That looks like a C compiler error
20:48:14 * SamB lols
20:48:15 <Stinger> haha
20:48:17 * byorgey thinks some legs are being pulled.
20:48:23 <soultaker> lol
20:48:26 <soultaker> dawm
20:48:28 <SamB> byorgey: why do you think that?
20:48:35 <Cale> soultaker: This is #haskell -- of course we're going to assume you're programming in Haskell.
20:48:40 <byorgey> just a hunch
20:48:47 <soultaker> i'm using code blocks
20:48:54 <SamB> Cale: the "struct" thing maybe should have been a give away
20:49:24 * Apocalisp has asked Java questions here before
20:49:27 <SamB> as well as the distinctly C-like appearance of the code
20:49:28 <Cale> SamB: Somewhat, though sometimes beginner Haskell programmers who came from C might call it that :)
20:49:38 <byorgey> aha, THAT 'gets'
20:49:38 <Cale> SamB: It looked like state monad code to me.
20:49:42 <Cale> :t gets
20:49:43 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
20:49:58 <Cale> I figured that stock and price were record field names.
20:50:01 <SamB> most people use spaces in their Haskell code
20:50:13 <soultaker> yea
20:50:19 <soultaker>  printf ("Please enter price of car.\n");
20:50:26 <soultaker> fflush(stdin);
20:50:36 <soultaker>               gets (stock.price);
20:50:38 <SamB> soultaker: what? that's C...
20:50:45 <soultaker> yer C
20:51:01 <soultaker> fwrite (&stock,sizeof(stock),1,stockfile);
20:51:02 <SamB> so off to ##c with you!
20:51:10 <soultaker> printf ("Please enter name or q to quit.\n");
20:51:14 <byorgey> q
20:51:27 <SamB> lol
20:51:31 * SamB is a bit punchy
20:51:32 <Stinger> what if your name is q, then you're boned
20:51:45 <SamB> Stinger: well, he's an asshole anyway
20:51:47 <SamB> so who cares?
20:52:01 <SamB> (Q is, I mean)
20:52:02 <Stinger> but he makes all those cool gadgets :(
20:52:13 <SamB> makes gadgets?
20:52:15 <QtPlaty[HireMe]> Stinger: Thanks alot.
20:52:15 <Cale> Haha, I think you're thinking of different Q's :)
20:52:29 <SamB> I thought he just threatened earth with all sorts of nasty judgements and so forth
20:52:38 <Cale> yep
20:52:48 <SamB> and generally defied space/time as we know it
20:52:57 <Stinger> Einstein?
20:52:58 <dev31212> Hello
20:52:58 <Cale> SamB: Q is also the name of the guy who makes James Bond's gadgets
20:53:02 <Cale> iirc
20:53:13 <Cale> dev31212: hi
20:53:22 <dev31212> Hi Cale :)
20:53:31 <SamB> Stinger: the Star Trek: TNG character
20:53:39 <dolio> If Q wants to use his program, he can use his complete control over time and space to change it to accept his name.
20:53:40 <Stinger> ah, was just about to ask
20:53:41 <dev31212> Anyone here ever work on a mmporpg?
20:53:48 <dev31212> Not like WoW or Eve..but a simple web based one
20:54:08 <SamB> dolio: Q would probably prefer to simply prevent it from having been written in the first place
20:54:38 <dev31212> Coincedentally I want it to have a Star Trek motif..
20:54:40 <dev31212> what timing.
20:54:45 <dev31212> Well Faux Star Trek..
20:57:30 <roconnor> @type foldr
20:57:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:58:30 <roconnor> > foldr (\a b -> if a == 0 then 0 else a*b) 1 ([1..100]++[0]++[1..])
20:58:32 <lambdabot>   0
20:59:00 <dev31212> foldr (+5) 0 [1,3,4]
20:59:08 <dev31212> oops
20:59:12 <dev31212> brb
21:12:18 <roconnor> > foldr (\a b -> if a == 0 then 0 else a*b) 1 ([1..100]++[0]++[1..]) -- you don't even need continuations or anything to bail out early for products
21:12:20 <lambdabot>   0
21:12:38 <soultaker> http://codepad.org/rXIbrKQA
21:12:42 <roconnor> > foldr (\a b -> if b == 0 then 0 else a*b) 1 ([1..100]++[0]++[1..])
21:12:44 <lambdabot>   * Exception: stack overflow
21:12:46 <soultaker> there it is
21:13:34 <cooldude127> anyone here using opengl with haskell?
21:14:41 <dolio> > foldr (\a b -> if a == 0 then 0 else a*b) 1 ([1..300000] ++ [0] ++ [1..])
21:14:44 <lambdabot>   * Exception: stack overflow
21:15:25 <MyCatVerbs> dolio: bit the dust evaluating the product [1..300000], by the look of it.
21:16:10 <dolio> Right. 300,000 is better than I expected, though.
21:16:38 <roconnor> hmm
21:16:53 <roconnor> I guess you need continuations or something to bail out of a foldl'
21:17:17 <roconnor> > foldl' (\a b -> if a == 0 then 0 else a*b) 1 ([1..300000] ++ [0] ++ [1..])
21:17:33 <lambdabot>   thread killed
21:17:54 <MyCatVerbs> > let { foldr' f a [] = a; foldr' f a (e:es) = let fa = f a in fa `seq` foldr' f fa es; } in foldr' (\a b -> a `seq` if b == 0 then 0 else a*b) 1 ([1..300000]++[0]++[1..])
21:17:56 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> t
21:17:56 <lambdabot>      Proba...
21:17:58 <roconnor> > foldM (\a b -> if a == 0 then Left "Zero" else return a*b) 1 ([1..300000] ++ [0] ++ [1..])
21:18:00 <lambdabot>       No instance for (Num (Either [Char] a))
21:18:00 <lambdabot>        arising from a use of `*...
21:18:14 <roconnor> > foldM (\a b -> if b == 0 then Left "Zero" else return a*b) 1 ([1..300000] ++ [0] ++ [1..])
21:18:17 <lambdabot>       No instance for (Num (Either [Char] a))
21:18:17 <lambdabot>        arising from the literal...
21:18:21 <MyCatVerbs> > let { foldr' f a [] = a; foldr' f a (e:es) = let fa = f a e in fa `seq` foldr' f fa es; } in foldr' (\a b -> a `seq` if b == 0 then 0 else a*b) 1 ([1..300000]++[0]++[1..])
21:18:36 <lambdabot>   thread killed
21:18:41 <roconnor> @type foldM
21:18:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:19:02 <roconnor> > foldM (\a b -> if b == 0 then Left "Zero" else return (a*b)) 1 ([1..300000] ++ [0] ++ [1..])
21:19:02 <monochrom> @type foldl'
21:19:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:19:08 <lambdabot>   Left "Zero"
21:19:19 <roconnor> > foldM (\a b -> if a == 0 then Left "Zero" else return (a*b)) 1 ([1..300000] ++ [0] ++ [1..])
21:19:34 <lambdabot>   thread killed
21:19:44 <roconnor> oh?
21:19:49 <monochrom> I see. foldl' and foldl behave the same way in this regard. They are strict on the list spine.
21:20:18 <soultaker> http://codepad.org/rXIbrKQA
21:20:21 <kadaver> > maximumBy (comparing snd) [(1,2)]
21:20:27 <kadaver> @src maximumBy
21:20:32 <roconnor> (1,2)
21:21:03 <kadaver> @src maximumBy
21:21:20 <kadaver> @djinn a+b
21:21:31 <monochrom> You killed Kenny again.
21:22:19 <monochrom> Wow, C code makes me hot.
21:23:26 <soultaker> http://codepad.org/rXIbrKQA
21:23:28 <monochrom> Why does C code look so elegant when you just look at the parentheses and the comment formatting. :)
21:23:33 <kadaver> how hard would it be to make a C++ FFI?
21:23:40 <monochrom> Very hard.
21:23:58 <wli> monochrom: Even struct buffer_head_struct_redundancy_head_struct *bh?
21:24:11 <monochrom> when you just look at the parentheses and the comment formatting!
21:24:25 <MyCatVerbs> Oh wait, I wrote a left fold by mistake. Stupid.
21:24:53 <monochrom> I should add indentation, too.
21:27:49 <MyCatVerbs> @src foldr
21:31:41 * MyCatVerbs pouts at lambdabot.
21:32:10 <dmead> ?src foldr
21:33:01 <soultaker> my code has an error, can't fix it , help, http://codepad.org/rXIbrKQA#output
21:33:29 <dmead> wrong channel
21:34:14 <soultaker> kk
21:36:16 <MyCatVerbs> soultaker: wow, you have been assigned the most boring C homework ever.
21:36:40 <MyCatVerbs> Oh, they already left.
21:43:38 <wli> soultaker: I could probably do it but it's too horrendous of drudgery to stomach.
21:43:59 <MyCatVerbs> wli: already left. And please don't.
21:44:09 <MyCatVerbs> Wouldn't do your soul much good, wli. :)
21:46:46 * wli is too incompetent, addled, etc. to do anything anymore anyway. I'd be sure to fail if I tried.
21:47:18 <MyCatVerbs> Oh, bullshit. Now get some sleep and have a cookie when you wake up. It is an uncivilised hour to be awake right now.
21:48:08 <wli> I slept too much during the day to sleep yet because I was feeling unwell.
21:48:31 <MyCatVerbs> Then have a cookie, fire up a game of solitaire and enjoy the sugar rush.
21:48:43 <wli> Not a good idea.
21:48:53 <MyCatVerbs> That's why I suggested it.
21:49:00 <monochrom> sugar rush leads to sugar recession.
21:49:18 <MyCatVerbs> Which leads to eh fall over go sleepy byes.
21:51:21 <wli> It would clash with my severe dietary restrictions.
21:52:53 <monochrom> Actually, when I have a sugar recession, I can't sleep.
21:53:19 <wli> I've been trying to come up with something I'd be capable of doing to do to keep me busy until I can sleep. I've failed.
21:53:31 <monochrom> If your dietary restriction is low-carb, go have a steak instead of a cookie :)
21:54:38 <CESSMASTER> monochrom: in the western world, those are pretty easy to bail out
21:55:22 <wli> Also strict and precise calorie control. Nothing can be taken in off-schedule.
21:58:16 <Nafai> nominolo: How's Scion going?
22:02:43 <wli> What's Scion?
22:05:24 <Nafai> wli: http://code.google.com/p/scion-lib/ A library for IDE like functionality
22:11:32 <mmorrow> roconnor: the only way out of a foldl' is with exceptions and unsafePerformIO
22:11:42 <mmorrow> (or by not using foldl')
22:12:01 <mmorrow> (or likewise foldl)
22:12:49 <mmorrow> @let foldC f z [] = z; foldC f z (x:xs) = f z x (\z -> foldC f z xs)
22:12:50 <lambdabot>  Defined.
22:13:32 <mmorrow> > foldC (\a b k -> if b==0 then 0 else k (a*b)) 1 ([1..10]++[0]++[1..])
22:13:35 <lambdabot>   0
22:14:00 <mmorrow> @let foldC' f !z [] = z; foldC' f !z (x:xs) = f z x (\z -> foldC f z xs)
22:14:01 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "foldC'"))
22:15:06 <imxsd> @let a = 5
22:15:07 <lambdabot>  Defined.
22:15:31 <imxsd> @let b = a
22:15:32 <lambdabot>  <local>:5:4:
22:15:32 <lambdabot>      Ambiguous occurrence `a'
22:15:32 <lambdabot>      It could refer to either `L....
22:17:17 <mmorrow> and foldr is a gross space leak for (*)/(+)/Map.insertWith/etc
22:19:23 <twb> Is there a channel for camp (the dVCS)?
22:19:58 <mmorrow> maybe ask in #darcs
22:20:02 <dolio_> foldr shouldn't leak space with (*) and (+), it should overflow the stack.
22:20:15 <mmorrow> dolio_: i call that a space leak :)
22:20:29 <twb> Righto.
22:22:31 <wli> Isn't that what insertWith' is for or some such?
22:22:45 <kristofer> how do I cabal install base >=4.1?
22:22:55 <mmorrow> wli: yeah, fold' insertWith' is golden
22:23:13 <mmorrow> * foldl' insertWith'
22:23:18 <Cale> kristofer: I wouldn't expect that to be possible. The base library is attached to the ghc version you're using.
22:23:53 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:23:56 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:23:56 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:23:57 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:00 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:01 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
22:24:02 --- mode: ChanServ set +o Cale
22:24:04 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:04 <imxsd> oops
22:24:06 <imxsd> sorry
22:24:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:08 <imxsd> mistake
22:24:10 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:13 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:19 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
22:24:21 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
22:24:24 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:27 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:30 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:24:33 <lambdabot> Plugin `system' failed with: thread killed
22:24:35 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
22:24:36 <wli> Brilliant.
22:24:38 <lambdabot> Plugin `system' failed with: thread killed
22:25:10 * Reiver laughs.
22:25:21 <Cale> imxsd: Did you have to do it 5 times?
22:25:30 <imxsd> Sorry
22:25:47 <mmorrow> clearly the fifth time's a charm
22:26:11 --- mode: Cale set -o Cale
22:26:13 <Gracenotes> wat
22:26:22 <Cale> Oh well, be more careful in the future
22:26:55 <Gracenotes> that is intense
22:27:53 <thoughtpolice> awesome
22:32:41 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops Help I'm being attacked!
22:32:42 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
22:32:42 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops Help I'm being attacked!"]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!
22:32:42 <lambdabot> ops Help I'm being attacked!"
22:32:58 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\.!ops Help I'm being attacked!
22:32:59 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
22:32:59 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\.!ops Help I'm being attacked!"]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
22:32:59 <lambdabot> .!ops Help I'm being attacked!"
22:33:02 <imxsd> Bah nvm
22:33:11 <Cale> imxsd: Okay. That's enough.
22:33:15 <imxsd> ok ok
22:38:01 <Gracenotes> very close though :)
22:38:48 <adu> @echo working?
22:38:48 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "adu!n=ajr@pool-72-83-254-159.washdc.fios.verizon.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo
22:38:48 <lambdabot> working?"]} rest:"working?"
22:39:11 <adu> oh, so it didn't crash
22:39:22 <Cale> Nah, it just did what it was supposed to do.
22:39:28 <adu> ok
22:39:37 <monochrom> To surprise humans?
22:40:03 <Cale> Though it does make a decent point. The echo plugin isn't using the irc output command that prefixes with a space
22:40:44 <badtruffle> @echo moo
22:40:44 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "badtruffle!n=pumpkin@Aeropuerto.Kiewit.Dartmouth.EDU", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo moo"
22:40:45 <lambdabot> ]} rest:"moo"
22:40:47 <lunabot>  luna: parse error on input `}'
22:40:54 <badtruffle> o.O
22:40:55 <monochrom> hehe
22:41:01 <Cale> exactly.
22:41:14 <badtruffle> that's pretty complete :)
22:41:46 <wli> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
22:41:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
22:41:56 <wli> That much at least still works.
22:42:11 <wli> Bad truffle, eh?
22:42:22 <copumpkin> only when I'm evil
22:42:36 <monochrom> Provisional measure: you have to prove your programs terminate before telling lambdabot to run them!
22:42:49 <Gracenotes> aeropuerto?
22:42:56 <Gracenotes> copumpkin lives in an airport? :o
22:42:59 <copumpkin> it's my airport base station :P
22:43:02 <Gracenotes> .. in Dartmouth?
22:43:04 <copumpkin> (apple)
22:43:26 <adu> > showIntAtBase 10 (" ehiorsuwy"!!) 82906406153476 ""
22:43:28 <monochrom> If your apple catches a flu, will your airport be closed?
22:43:32 <lambdabot>   "why so serious"
22:43:55 <adu> @echo > showIntAtBase 10 (" ehiorsuwy"!!) 82906406153476 ""
22:44:14 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "adu!n=ajr@pool-72-83-254-159.washdc.fios.verizon.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo >
22:44:47 <Gracenotes> adu: o_O must be black magic
22:44:56 <adu> uh oh
22:44:59 <adu> sorry
22:45:08 <monochrom> You killed Kenny again!
22:45:14 <copumpkin> you slammed his face into a pencil
22:45:18 <copumpkin> *her
22:45:30 <monochrom> eww, face-pencil
22:45:46 <copumpkin> :)
22:45:52 <Gracenotes> @go pencil face
22:45:59 <lambdabot> http://www.youtube.com/watch?v=4MjTb5A68VA
22:46:07 <lambdabot> Title: YouTube - SCADshorts: Pencil Face
22:46:12 <Gracenotes> a wtf experience.
22:47:06 <adu> showIntAtBase 3 ("ftw"!!) 21 ""
22:47:09 <adu> > showIntAtBase 3 ("ftw"!!) 21 ""
22:47:18 <lambdabot>   "wtf"
22:51:09 <adu> > showIntAtBase 24 (" ,.abdefghiklmnopqrstuwy"!!) 68517862788968308144925649661659292634923122019332261651164944433770708585984451396496737636495360241791062269565210158363284934944068698296055960600020545093005147678110112435891357788400433229956158294011619443412828305980245038147389076514901004473994879476859903095994 ""
22:51:17 <lambdabot>   "to be or not to be, that is the question, whether tis nobler in the mind t...
22:52:00 <Gracenotes> :o
22:52:03 <Gracenotes> hm. Do you generally discover algorithms or invent them?
22:52:28 <adu> Gracenotes: both
22:52:32 <Gracenotes> in terms of the process of formulating them in your head, transcribing it and sharing it
22:52:54 <copumpkin> I invent them, others just discover them
22:53:02 <copumpkin> mine are so awesome not even god thought of them
22:53:35 <Gracenotes> adu: true, you happen to find a particular string encoding a Turing machine for the algorithm, that exists already. Yeah, I'm just wondering what to put in a presentation about RSA and similar algorithms :)
22:53:43 <adu> Gracenotes: the way I see it is like the path of least resistance... You start with a problem and walk towards your solution
22:53:43 <monochrom> Perhaps "invent" means intelligent design and "discover" means random-mutation evolution.
22:54:03 <monochrom> I think humans don't have intelligence. They can only discover algorithms.
22:54:19 <Gracenotes> but my mother said I was intelligent ;_;
22:54:33 <copumpkin> members of the cucurbita family, on the other hand...
22:54:55 <adu> Gracenotes: that theme has come up repeatedly
22:54:59 <leepike> newbie question: I updated ghc from 6.8.2 to 6.10.1, but ghc-pkg is still 6.8.2.  How do I update that?
22:55:01 <Gracenotes> </joke ... ... ...> so yeah, it also sounds weird to say that Rabin "discovered the Rabin cryptosystem"
22:55:09 <Gracenotes> when it has his name attached to it
22:55:30 <monochrom> Platonists believe in discovering.
22:55:44 <monochrom> I believe in Platonists having no intelligence.
22:56:00 <monochrom> <duck>
22:56:07 <adu> for example in the Myst books (Riven, Exile, etc.) there were wars fought over whether the worlds they made linking books to were "created" or "discovered", which was of great political interest
22:56:47 <adu> becase the "discovered" camp wanted to make peace with them and invite them for tea, whereas the "created" camp wanted to enslave all the inhabitants of those worlds
22:56:51 <imxsd> It's wierd, if you spam lambdabot it gets really slow
22:56:55 <imxsd> How do I stop lambdabot from spamming me?
22:57:13 <Cale> Stop sending it messages.
22:57:17 <imxsd> ok
22:57:20 <monochrom> By switching off the computer and getting out more.
22:57:30 <Gracenotes> limit the length of your evaluations
22:57:51 <monochrom> I wish I could just kline you.
22:57:52 <Gracenotes> take 20 from a list, in a PM. or something. dunno the problem.
22:58:01 <Cale> imxsd: It has a rate limiter so it doesn't flood itself off the network.
22:58:12 <imxsd> Is it possible to ask lambdabot to import something, and then run a command?
22:58:17 <Cale> no.
22:58:20 <cjs> Gracenotes: I think that this may have some ideas for the technique you want for your fixed-length queue: http://www.boyet.com/Articles/LockfreeQueue.html
22:58:30 <ski> (Cale : but it just did that. three times)
22:58:45 <Gracenotes> cjs: that is exactly the algorithm I mentioned yesterday in the PM :)
22:58:54 <imxsd> I think it's done.
22:58:59 <cjs> ha! There you go.
22:58:59 <Gracenotes> however, it's not fixed-length
22:59:01 <Cale> ski: That's a good point, perhaps the rate needs to be decreased.
22:59:12 <Gracenotes> it uses linked nodes
22:59:18 <Cale> ski: But it does automatically restart at least.
22:59:25 <ski> yea
22:59:30 <monochrom> Make the rate exponentially increasing so it sounds like dropping into a black hole.
22:59:31 <cjs> No, but you could probably adapt it, by having an array of slots that are either empty or full, and head and tail indices.
22:59:43 <adu> Gracenotes: so really the safest terminology in the long run is "discovered" because any minute now, an angel could come down and tell you that algorithm was invented in 12000 B.C. by a scientist in Atlantis
22:59:54 <cjs> Then you use the same technique of letting the tail index lag the real tail.
23:00:15 <cjs> Does that make sense?
23:00:16 <monochrom> re-invention is still invention. No one says "don't discover the wheel".
23:00:32 <Gracenotes> adu: I don't like the fact that the dichotomy exists, really. one wholeheartedly affirms the creativity of the creator; the other entirely ignores it
23:01:19 <Gracenotes> "independently invent" is at least a compromise, but it has the connotation that someone else invented it too, if not the denotation
23:01:29 <imxsd> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me..
23:01:30 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "imxsd!n=a98sd@cpe-066-026-072-117.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\
23:01:30 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me.."]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me.."
23:01:39 --- mode: ChanServ set +o monochrom
23:01:40 --- mode: ChanServ set +o Cale
23:01:42 <Gracenotes> ... :\
23:01:46 --- mode: Cale set +b imxsd!*@*
23:01:52 <Gracenotes> :/ ...
23:01:53 --- mode: monochrom set -o monochrom
23:02:07 <Cale> Maybe that needs to be better...
23:02:10 <monochrom> (It will not stop pm's either direction, though.)
23:02:14 <adu> dichotomies are all in the eye of the beholder
23:02:49 --- mode: Cale set -o Cale
23:02:52 <ski> (adu : Xanathar ?)
23:02:52 <Gracenotes> adu: a bit of a red herring, isn't it? Others behold them too.
23:03:36 <Gracenotes> I mean the dichotomy between the words 'invent' and 'discover'. Clearly there are two words here, not three :)
23:03:47 <Gracenotes> anywah.
23:03:48 <adu> ski: what's that?
23:04:00 <Cale> invent and discover mean the same thing when applied to mathematics and algorithms
23:04:04 <Gracenotes> cjs: I think so. Seems redundant though.
23:04:26 <adu> Gracenotes: it all boils down to perception
23:04:47 <adu> Gracenotes: if you have one room with a wall in the middle, is it 1 room or 2?
23:04:47 <Gracenotes> yada yada lazy existentialist argument :\
23:04:50 <cjs> Gracenotes: tail is redundant; it's just an optimization to let you find the tail faster.
23:05:23 <smorg> a mathematical truth would only be invented if it wasn't true before it was discovered. :)
23:05:30 <Cale> Though, "discovering" an algorithm sounds a bit like you found it in a book.
23:05:48 <monochrom> You found it on a beach.
23:05:56 <Gracenotes> smorg: heh. Well maybe you can invent theories.
23:06:03 <Gracenotes> by that definition
23:06:11 <CESSMASTER> i think the real difference is in connotation, not denotation
23:06:23 <adu> Cale: my teacher had this rant about how the 118th element wasn't "discovered" because it took eleventeen gigawatts or something
23:06:56 <Gracenotes> although, I suppose within the not-yet-formulated rules of theory, the axioms and theorems were already true
23:06:56 <Gracenotes> or false
23:06:56 <Gracenotes> or unprovable :o
23:06:56 <monochrom> Then you reason that it can't be evolved randomly. It must have been invented by some inventor.
23:07:00 <Gracenotes> CESSMASTER: exactly
23:07:06 <ski> (adu : <http://en.wikipedia.org/wiki/Eye_of_the_Beholder_(video_game)> (see under "Story"))
23:07:34 <monochrom> Why would anyone leave an algorithm on a beach is a mystery.
23:07:35 <Cale> smorg: There's plenty of invention involved in the proof of a theorem though.
23:07:41 <CESSMASTER> well, then you have weird examples like "columbus invented america"
23:07:49 <Cale> Though we usually just use the word "proved"
23:07:51 <Gracenotes> yeah. lol
23:08:07 <smorg> True, though for any theorem, there are infinitely many proofs
23:08:28 <Cale> Perhaps none of them easy to construct.
23:08:51 <smorg> Plus those unprovable Godel ones
23:09:18 <Gracenotes> an algorithm's input and output behave in certain ways even before they are formally described by a human. But physics does seem to solve certain problems by itself, simplified versions of which are Turing-recognizable.
23:09:19 <adu> i want to prove holomorphic tetration exists
23:09:19 <Cale> Well, those statements (we hope) are not theorems :)
23:09:50 <Gracenotes> /tangent... I think I'll use 'invented' and add a little disclaimer on the first use
23:10:20 <monochrom> Haskell98 already existed before some human described it.
23:10:20 <Cale> Gracenotes: But, the algorithm does not exist until someone writes it down.
23:10:25 <adu> Lespuciland
23:10:32 <smorg> Speaking strictly of a posteriori truths then.
23:10:34 <CESSMASTER> i should also point out that "invenio" means "to discover" in latin
23:10:37 <Gracenotes> Cale: true. In the Turing sense of the algorithms
23:10:40 <monochrom> (Someone found it on a beach?)
23:10:46 <ski> (smorg : .. but there's often just a finite number of canonical proofs)
23:10:48 <CESSMASTER> perhaps more accurately "to come upon"
23:10:50 <adu> I'm going to discover my bed...
23:10:51 <Gracenotes> something that can be described with symbols
23:10:52 <adu> zzz
23:10:55 <Gracenotes> gnight
23:10:55 <CESSMASTER> but "truth in etymology" is bs
23:11:00 <ski> @djinn ()
23:11:00 <lambdabot> f = ()
23:11:32 <Gracenotes> if proofs are isomorphic to programs, the number of proofs must be countable
23:11:39 <monochrom> Yes.
23:12:02 <Cale> Yeah, normally that's the case, unless you're using some weird non standard kind of logic :)
23:12:05 <monochrom> Even if you use English for proofs, the number is still countable.
23:12:28 <monochrom> And even if you use the full Unicode alphabet.
23:12:31 <ski> how is "countable" defined exactly, here ?
23:12:49 <Gracenotes> heh. well, on an even more basic level, the kleene of any finite alphabet is countable, I guess
23:12:50 <CESSMASTER> ski: in bijection with N
23:13:12 <Cale> As long as proofs are finite and written with a finite set of characters, there will be at most countably many of them.
23:13:13 <smorg> There are infinitly many equivilant constructs though. For instance you can do something stupid like a == --(a) == ----(a) ...
23:13:15 <Gracenotes> or in surjection
23:13:17 <monochrom> Someone may say "wait, Unicode is defined to be infinitely extensible"...
23:13:31 <Cale> There are some strange logics which allow for infinite proofs, but nobody really uses those :)
23:13:33 <ski> (e.g., remember that the constructive reals are not "countable" in the sense of bijection with `|N')
23:13:48 <Cale> ski: But they are.
23:14:13 <Cale> ski: They're just not constructably in bijection with N.
23:14:37 <CESSMASTER> what are the constructive reals?
23:14:39 <ski> Cale : given any function `|N -> |R' (constructive reals), i can construct a (constructive) real not in the image of that function
23:15:12 <monochrom> ...
23:15:18 <Cale> Uh, I doubt that.
23:15:32 <ski> (diagonalization)
23:15:32 <Gracenotes> @go constructive reals
23:15:33 <lambdabot> http://www.hpl.hp.com/personal/Hans_Boehm/crcalc/
23:15:33 <lambdabot> Title: Constructive Reals Calculator
23:15:40 <Gracenotes> :o
23:15:43 <Cale> Unless you mean something strange by 'function'
23:15:55 <monochrom> HP calculators can do constructive reals? I've got to tell glk.
23:15:56 <Gracenotes> are those computable reals?
23:16:11 <monochrom> <glk> HP calculators can construct reals
23:16:23 <ski> Gracenotes : yes
23:16:48 <Cale> ski: What's wrong with simply enumerating Turing machines?
23:17:03 <ski> we don't know which of those terminate
23:17:08 <Cale> It doesn't matter.
23:17:13 <Cale> Pick the ones which do.
23:17:18 <ski> how ?
23:17:22 <ski> it's not decidable
23:17:29 <Cale> Not computable.
23:17:44 <Cale> But every Turing machine terminates or it doesn't.
23:17:53 <ski> i don't believe that :)
23:18:05 <Cale> LEM.
23:18:15 <smorg> So I started with haskell at noon yesterday. Lets see how long before I fall asleep at my computer.
23:19:08 <monochrom> yo dawg we heard you love excluded middle so we put an excluded middle in the middle of your excluded middle.
23:19:26 <Cale> (Basically, it's always possible to assume that I'm going to treat every statement that you make as if it's a statement encoded in ZFC somehow, unless you say otherwise)
23:19:45 <ski> (or rather, i only believe (generally) in LEM in the sense that if one dijunct is refuted, the other holds .. not in the sense that one can "pick" the values satisfying one of the sides)
23:20:07 <Cale> ski: So you don't even want to use classical logic?
23:20:09 <smorg> Is there a concept of a Turing machine in quantum logics? If you have an undecidable value, The halt state could itself be undecidable I suppose.
23:20:28 <Cale> ski: Why not just use regular logic to study which things are computable or not?
23:20:41 <ski> Cale : i would like to use something like linear logic, which contains classical logic
23:21:25 <Cale> (where by "regular", I just mean the ordinary classical logic which almost everyone uses)
23:21:47 <ski> so `A (+) not A' is ok if `(+)' is the multiplicative disjunction .. but `A + not A' where `+' is the additive disjunction is not ok
23:23:46 <ski> Cale : i'm not to say that has no merit. but i haven't seen an attractive way of doing that
23:24:48 <Cale> ski: Well, in this case, it just involves adding one more 'computable' to your statement.
23:25:14 <Cale> s/Given any function/Given any computable function/
23:27:31 <Cale> (and then people will understand what you're talking about ;)
23:28:42 <ski> (i think computation ought to be more basic .. i suspect one can view "non-computable functions" as a kind of "ideal elements")
23:28:49 <raxas> http://knowledgerush.com/kr/encyclopedia/Water_integrator/
23:29:09 <mmorrow> monochrom: wait, Unicode is defined to be infinitely extensible
23:29:15 <Gracenotes> raxas: hm? what's the link?
23:29:37 <Gracenotes> *eyes it suspiciously :o*
23:30:02 <raxas> not all "computations" must be digital
23:30:22 <Cale> ski: Most of the time, I don't really care if functions are computable or not, and having to construct things so that they are, even when possible, is often much more annoying.
23:30:27 <ski> (raxas : agreed)
23:30:54 <Gracenotes> although, you can sometimes encode analog digitally
23:31:10 <Vq^> raxas: that gives a new meaning to floating point processor :o)
23:31:18 <Cale> raxas: Haha, the title of that web page is awesome.
23:31:23 <Gracenotes> so long as the number of ways you can read analog values is countable
23:31:43 <Gracenotes> ('countable' again. er, able to be enumerated)
23:31:46 <ski> (Cale : if part of an "there exists" statement of a theorem, i don't see much point of the theorem, if the thing to exists is not constructed)
23:31:59 <Cale> Water integrator. Who is Water integrator? What is Water integrator? Where is Water integrator? Definition of Water integrator. Meaning of Water integrator.
23:32:14 <Cale> It's like some stark new form of dadaist poetry.
23:32:25 <ski> (note that "not much point" is not the same as "no point", though)
23:32:35 <mmorrow> ski: i think the root of it is that you choose a different definition of "exists"
23:32:46 <Cale> ski: That's only because you're so interested in computing things
23:33:54 <Cale> Whereas I'm only interested in playing the game called mathematics, and I like the normal rules. :)
23:34:59 <ski> mmorrow : yes .. i usuallu don't understand what "there exists" should mean otherwise. (assuming one is not a pure formalist that thinks that what formal system / game we work in is arbitrary (detached from any intended meaning) and consistency is the only definite guidance)
23:35:15 <ski> Cale : why are the "normal rules" as they are ?
23:35:15 * Cale raises his hand
23:35:44 <Cale> Oh, because that's where everyone's spent so much time developing things.
23:36:15 <ski> so you don't claim there is any deep reason to prefer those rules, then ?
23:36:18 <mmorrow> i don't view "exists" as necessarily having any connection with the common use of the word
23:36:30 <Cale> Why would there be any deep reason to prefer any rules at all?
23:37:04 * Cale also doesn't believe in absolute notions of truth.
23:37:17 <Hunner> > True
23:37:19 <lambdabot>   True
23:37:29 <ski> Cale : then why do you prefer to use the "normal rules", that people have spent much time developing (as opposed to other sets of rules) ?
23:37:56 <Cale> Well, because it's what I'm most familiar and comfortable with, for the most part.
23:38:01 <ski> only because you want to tap into and communicate with as large as possible community of other theorems ?
23:38:23 <CESSMASTER> subjectively, they agree more with our intuition and yield interesting mathematics
23:38:32 <Cale> and that
23:38:55 <Cale> The existing rules are fun.
23:38:55 <ski> CESSMASTER : well, they don't seem to subjectively agree more with *my* intuition :)
23:39:15 <ski> (Cale : that's a valid point, yes)
23:39:15 <monochrom> I prefer the axioms I know because they work.
23:39:41 <Cale> and while it certainly can be interesting to try to constructively reach a result, I don't like being forced to do it all the time.
23:40:45 <Cale> Somehow even though classical logic embeds into most of these constructive systems, they still feel much more restraining.
23:41:03 <monochrom> Wait, theorems have formed a community? Is it a friendly community? Does it love newbies?
23:41:14 <ski> (well, even if there's embeddings both directions, that doesn't mean the embeddings are inverses)
23:41:23 <Cale> right
23:41:41 <Cale> and it doesn't make them particularly convenient to use
23:42:07 <ski> thus both sides can think the other side is more restraining :)
23:42:21 <Cale> I think I prefer dealing with constructive things as separate new types of objects inside a system which is not normally concerned with that.
23:42:23 * mmorrow wonders that the limits of (f . g . f . g . f ...) is wrt these embeddings
23:42:28 <mmorrow> *limit
23:42:45 * mmorrow guesses 42
23:43:25 <ski> mmorrow : interesting question
23:44:45 <mmorrow> well, i guess you would have to consider the relationship of (f . g . f ...) to (g . f . g ....) too
23:44:49 * Cale bets that it doesn't converge.
23:46:27 <haskellnoob> As preparation for programming competition, I have written a small program. This is a "sample" question, not part of the real competition. The program does some trivial computation, but it is required to run very fast -- it is tested against a huge input, on a not-so-fast computer. My current program is here:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2283#a2283 . It runs correctly on...
23:46:29 <haskellnoob> ...the small inputs that I have tested it against, but times out when I submit it to the "judge" for the sample. Are there obvious ways to speed up this program? What all should I look for when trying to speed up a Haskell program?
23:46:31 <haskellnoob> The competition has all sorts of languages allowed, including C and C++. Also, as far as I know, they don't use the -OX flags in compiling Haskell. I could try to ask them to do this, if it will make a significant difference in the running time. What do you suggest?
23:47:07 <ski> Cale : anyway. i can't say i believe that constructive methods are the "true system" to use. i can see the appeal of using classical methods at times. it's just to me the constructive ones appear to feel more natural, in most circumstances
23:47:19 <Baughn> haskellnoob: It's a very /large/ input? On a single line?
23:47:25 <Baughn> haskellnoob: Use a lazy bytestring, not s strict one.
23:47:36 <Baughn> Oh, wai..
23:47:47 <haskellnoob> Baughn: It is a very large input, on a huge number of lines.
23:47:54 <haskellnoob> one number on each line
23:47:55 <ziman> in my opinion -O2 is crucial to good performance
23:47:59 <Baughn> haskellnoob: Well, Bytestring.interact is still strict
23:48:06 <Baughn> haskellnoob: So yeah, use the lazy variant
23:48:18 * mmorrow doesn't think he's ever even tried anything other than -O2
23:48:30 <haskellnoob> would it help to use -OX where X >2 (is there such a thing?)
23:48:36 <mmorrow> -O11
23:48:40 <Cale> haskellnoob: Yeah, without -O2 or at least -O things can run many many times slower
23:48:56 <Cale> -O3 and above are clipped to -O2.
23:49:05 <Cale> (They used to be ignored)
23:49:09 <mmorrow> haha
23:49:27 <ziman> ghc has -O3, which is not recommended as it may make the program run slower according to the docs
23:49:42 <ziman> s/slower/slower,/
23:49:50 <Baughn> haskellnoob: Right now, your program is trying to read all the input into memory before doing anything with it
23:49:52 <mmorrow> ziman: ?! -O3 does an entire extra optim pass
23:49:55 <Baughn> This is not necessarily a good idea
23:50:08 <Cale> Wait, there is -O3 now?
23:50:16 <mmorrow> Cale: (gcc)
23:50:28 <haskellnoob> using the lazy variant will only increase the number of times the input is read, is it not?
23:50:46 <haskellnoob> won't that increase the running time rather than the other way?
23:50:52 * ziman searhes for the doc
23:51:19 <haskellnoob> i can understand why it may reduce the memory usage, though.. but that is not a concern here
23:51:27 <Baughn> haskellnoob: You definitely can't read input more than once, so not /that/. What it can do is reduce the memory usage
23:51:37 <Baughn> haskellnoob: And are you /sure/ memory usage isn't a problem?
23:51:50 <haskellnoob> Baughn: yes
23:52:38 <mmorrow> in particular, -O3 adds to -O2: -fgse-after-reload, -finline-functions, -funswitch-loops
23:53:39 <Baughn> haskellnoob: Also, is the output large? strict interact will buffer all of that before printing any, too..
23:53:53 <haskellnoob> I could ask the organizers to add -OX for some X to the compilation command, but I would need some good reference to back this up. Where could I find this?
23:53:53 * mmorrow randomly has "the definitive guide to gcc" sitting around in front of him
23:53:58 <haskellnoob> the output is just one number
23:54:14 <Baughn> haskellnoob: The GHC manual. Haskell is horribly slow without -O2. You /want/ -O2.
23:54:18 <Baughn> Though -O isn't /too/ bad, really
23:54:37 <Baughn> But unoptimized haskell.. *shudder*
23:54:39 <haskellnoob> ok, I will quote the manual then.
23:55:07 <mmorrow> Baughn: i don't see the point in using -O when you can just add a '2' ;)
23:55:10 <haskellnoob> Is there a way I can quote this conversation as well?
23:55:15 <ziman> Do NOT use -O3, it actually gives less optimization than -O2  -- http://haskell.org/haskellwiki/Performance/GHC
23:55:20 <mmorrow> (but seriously, i'm 99% serious)
23:55:41 <mmorrow> ziman: ghc translates it to "-O2" i believe
23:55:48 <mmorrow> ziman: that info might be old
23:56:03 <haskellnoob> But that page also says "At present, -O2 is nearly indistinguishable from -O. "
23:56:09 <ziman> mmorrow, i see, thanks
23:56:14 <mmorrow> ziman: :)
23:57:03 <mmorrow> haskellnoob: would you rather have $100 or $101?
23:57:04 <ziman> i've read it in several independent places so i did not doubt much about "don't use -O3"
23:57:26 <cjs> Is there a difference between adding the guard 'f x y | x `seq` y `seq` False = undefined' and just using 'f !x !y'?
23:57:59 <mmorrow> ziman: the only of those three optims that -O3 adds that i can see as possibly affecting performance in border cases is -finline-functions (?)
23:58:27 <mmorrow> -fgse-after-reload  -funswitch-loops  seem like they could only ever increase perf
23:58:38 <tiglionabbit> oh flip.  It amuses me so, to the point of writing superflip 0 f = f; superflip n f = superflip (n-1) (flip f)
23:58:49 <haskellnoob> If memory usage is not a problem, then is it better to use the strict ByteString rather than the lazy one?
23:59:06 <Baughn> haskellnoob: Marginally. Sometimes.
23:59:13 <beelsebob> haskellnoob: no
23:59:17 <mmorrow> haskellnoob: depends if you want streaming behavior of all-at-once behavior
23:59:20 <Baughn> The chunk size on the lazy one is sufficiently large that you won't notice
23:59:23 <beelsebob> it's better to keep your lazyness
