00:00:11 <pumpkin> is that just illegal because I messed up, or because it doesn't support it?
00:00:19 <pumpkin> I'd expect it to barf more nastily if it didn't support families in general
00:00:33 <mmorrow> it looks valid to me
00:00:55 <pumpkin> , [d|class Moo a where data MooData a; cow :: MooData a -> a|]
00:00:56 <lunabot>  luna: Illegal family instance for `MooData'
00:00:59 <pumpkin> :(
00:01:48 <mmorrow> pumpkin: in ghc it parses the stuff in the [||] with the regular parser (and succeeds on full ghc haskell syntax), but in the desugaring stage it just errors out (gracefully) when it sees something TH doesn't support
00:01:53 <pumpkin> oh
00:01:59 <pumpkin> I see
00:02:39 <mmorrow> which is nice in a way, because the only barrier to TH supporting everything is the TH lib itself
00:03:00 <jrx> Hi, how to get the Ptr Mat4 from Mat4 when I want to send it to HOpenGL?
00:03:10 <pumpkin> so suporting something in TH amounts to defining type constructors for all the various things the parser spits out
00:03:10 <pumpkin> ?
00:03:21 <augustss_> jrx: with or new
00:03:40 <mmorrow> yeah. that and whatever it would take in ghc to then handle that (whatever that might mean)
00:04:01 <jrx> augustss_: thanks, I'll try
00:04:14 <augustss_> jrx: if Mat4 is Storable
00:04:27 <mmorrow> pumpkin: (actually, that's probably slightly more than "nontrivial" for some stuff probably ;)
00:04:27 <augustss_> jrx: if not, you should make it so
00:04:35 <jrx> augustss_: yes, it is
00:04:48 <pumpkin> ah
00:04:51 <jrx> augustss_: I just have never played with that FFI stuff
00:05:46 <augustss_> jrx: with allocates it on the "stack", so it is deallocated when you leave the 'with', new uses malloc so someone has to free it later
00:07:17 <jrx> augustss_: I guess that when I send it to OpenGL I can free it just afterwards
00:07:59 <mmorrow> pumpkin: um, by "slightly more than \"nontrivial\"" i meant hard (i'm not sure if that was ambiguous) :)
00:08:04 <pumpkin> yeah :)
00:08:10 <augustss_> jrx: sounds like you should consider 'with'
00:08:32 <mmorrow> yes it was ambiguous or yeah i new that fool? ( :) )
00:09:50 <mmorrow> , vacuum undefined
00:09:52 <lunabot>  luna: Prelude.undefined
00:10:29 <pumpkin> I wonder if DPH could be merged with GPU implementations somehow
00:12:06 <mmorrow> what's it like programming on a gpu? do you just use some compiler that targets it just write in C or something?
00:12:26 <pumpkin> there's CUDA for nvidia GPUs
00:12:31 <augustss_> mmorrow: yes and no
00:12:46 <pumpkin> it looks like c, but doesn't feel like it
00:13:16 <mmorrow> hmm, so it's through some hardware-specific api?
00:13:21 <augustss_> mmorrow: you can write in (a suset of) c.  But for good performance you need to know the architecture very well
00:13:34 <Gracenotes> sususet
00:14:09 <augustss_> mmorrow: there's no cache, so you need to move between various types of memory yourself
00:14:38 <mmorrow> augustss_: hmm, what do you mean by "types" of memory?
00:15:12 <augustss_> mmorrow: basically: slow main memory, fast local memory, registers
00:15:20 <mmorrow> ahhh, ok.
00:16:01 <augustss_> mmorrow: and you want to move things in contiguous chunks, etc, etc
00:16:47 <mmorrow> i think i'll google around, sounds like it could be interesting
00:16:57 <mmorrow> (or painful :)
00:17:01 <augustss_> mmorrow: and you need to be aware of the SIMD character of the processor "warps"
00:17:25 <augustss_> mmorrow: very painful, but it can be very fast
00:18:27 <mmorrow> "warps" as in time? (like as in number of instructions something something)
00:20:13 <mmorrow> "threads are executed in groups of _, called warps"..
00:20:16 <augustss_> mmorrow: it's just what they call a group of CPUs
00:20:50 <augustss_> group of threads, I guess :)
00:21:19 <augustss_> mmorrow: you should have a look.  it's interesting
00:22:56 <mmorrow> yeah, from the half-page i've read so far on some random website i think i will
00:23:20 <nvoorhies> threads in a fabric are warp and woof threads, and warp sounds cooler than other words for things that group threads
00:33:26 <twb> I thought that I could make a section in haddock using -- * foo.
00:33:38 <twb> I can't find any documentation about this in the haddock manual anymore, how do I do it?
00:36:29 <twb> Oh, found it.
00:36:46 <twb> The haddock manual's page splitting algorithm wasn't what I'm used to
00:38:52 <haro> what's the difference between return and pure ?
00:39:11 <twb> @type pure
00:39:12 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:39:17 <twb> @type return
00:39:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:39:43 <twb> I guess they apply to different things (monads vs. applicatives, whatever the latter are...)
00:39:49 <c_wraith> pure is defined by Applicative, return is defined by Monad.  They do the same thing.
00:40:04 <haro> thanks
00:40:41 <ski> (they do the same thing for monads, which are always applicatives. applicatives are not necessarily monads, though)
00:41:54 <mmorrow> twb: yeah, i just noticed that -- * stopped working!
00:42:14 <twb> mmorrow: it turns out you are supposed to put sections in the module part
00:42:32 <mmorrow> twb: you mean the export list?
00:42:34 <twb> ...which is theoretically a good thing (assuming this means that code is rearranged according to the export order)
00:42:41 <twb> mmorrow: in the module declaration
00:42:46 <twb> http://www.haskell.org/haddock/haddock-html-0.8/ch03s04.html
00:42:47 <mmorrow> yeah, i actually like that more
00:42:53 <mmorrow> nice, thx
00:43:03 <twb> The problem is that this module is such a fucking mess, that the _prop functions aren't actually exported
00:43:15 <twb> Or rather, SOME are
00:43:27 <mmorrow> yay!
00:43:36 <mmorrow> :)
00:43:43 <twb> Oh, mea culpa
00:43:59 <twb> It's identity_commutes and iNVERSE_doesnt_commute
00:45:02 <haro> ski thanks
00:45:04 <edwardk> ok, a couple of hours of regexing and manual tweaking and i have Data.Set rewritten to use a data family so it can exist unboxed
00:45:14 <edwardk> now i get to play with benchmarks
00:45:37 <edwardk> and add a bunch more instances to the family
00:46:56 <twb> How can I express â†’ (&rarr;) in Haddock?
00:47:03 <twb> That, and subscripts.
00:47:17 <twb> droundy wrote: $AB \commutes B'A'$ if and only if $B'A' \commutes AB$
00:47:48 <twb> Where \newcommand{\commutes}{\longleftrightarrow}
00:49:13 <edwardk> mmorrow: http://comonad.com/haskell/graphs/USet.gif woot
00:50:44 <edwardk> and the devil's advocate from Data.Set http://comonad.com/haskell/graphs/Set.gif
00:52:44 * twb prints out the haddock documentation from /usr/share/doc, since the one on haddock's website is actually for wildly obsolete version 0.8
00:53:28 <jklk> is WASH still being maintained?
00:54:00 <haro> how would be called a function that boxes its argument only if it isn't already boxed ?
00:54:58 <sjanssen> haro: such a function is not possible in GHC, I think
00:55:55 <edwardk> http://comonad.com/haskell/graphs/USetChar.gif -- woot they all work
00:56:44 <edwardk> cost of about 6-7 lines for each of the unboxable instances
00:57:13 <edwardk> and the ability to reuse the machinery for the boxed ones by using a 'Boxed' newtype wrapper. USet Int, USet (Boxed (Int,Char)) -- etc.
00:57:33 <edwardk> er unboxed
00:57:54 <haro> sjanssen: isn't it decidable ?
00:58:13 <edwardk> @tell dons http://comonad.com/haskell/graphs/USetChar.gif
00:58:14 <lambdabot> Consider it noted.
00:58:28 <sjanssen> haro: GHC doesn't support polymorphism across kinds
00:58:48 <sjanssen> edwardk: benchmarks!
00:59:44 <edwardk> sjanssen: working towards it, but i may have to sleep and go to work between now and then =/
00:59:54 <edwardk> sjanssen: but the trees are tiny =)
01:00:15 <edwardk> sjanssen: anyone have a benchmark framework handy for these?
01:00:32 <sjanssen> edwardk: not that I'm aware of
01:02:18 <kia0gh> Entreu aquí el text...
01:02:21 <kia0gh> hi all
01:02:31 <kia0gh> can someone help me with a question about java
01:02:36 <mmorrow> edwardk: nice!
01:02:52 <kia0gh> in java : i have to call a methood() a setter and set a value to less than 0,1 and i dont know what to use since i cant use <
01:03:29 <sjanssen> kia0gh: this channel is for Haskell, join #java or something
01:03:48 <kia0gh> oh ok i see where can i search for java
01:04:21 <twb> WTF?  Why would someone join #haskell to ask about Java?
01:04:37 <twb> kia0gh: what goes on in that twisted little cranium of yours?
01:04:42 <mmorrow> edwardk: what is USet?
01:04:59 <koala_man> some would say that haskell coders are better at java than java coders
01:05:27 <mmorrow> pumpkin: http://www.siliconmechanics.com/i20995
01:05:51 <mmorrow> 240 cores!@
01:05:52 <osfameron> though only really if they wanted help on program haskell-style in java
01:06:41 <edwardk> mmorrow: unboxed version of Set using view patterns and type families
01:06:54 <mmorrow> edwardk: ooh, fancy
01:07:17 <edwardk> i'll post it up in a sec and benchmark the bejeezus out of it shortly thereafter =)
01:07:38 <mmorrow> edwardk: ahhhh, i just realized why there're "no values in there" :)
01:08:37 <kadaver> anybody want octave bindings for haskell?
01:08:50 <kadaver> is whoever made leksah ehre?
01:09:15 <kadaver> maybe we could have gnuplot and octave as an add-on for leksah?
01:09:24 <kadaver> to mame it simple to use together
01:10:03 <kadaver> even if haskell is expressive and nooby me wrote a matrix lib in haskell veyr fast it is nothing compared to a real one obv.
01:10:13 <kadaver> or everyone here jsut use hmatrix?
01:10:24 <mmorrow> hmatrix is pretty nice
01:10:40 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Set-Unboxed.html
01:10:41 <mmorrow> but otoh there's tons of code written for octave
01:10:56 <edwardk> i just threw it into the monoids package because thats where i'll be using it but i can move it into its own
01:11:09 <mmorrow> edwardk: innnteresting
01:11:46 <edwardk> anyone have ideas how to benchmark my shiny new toy?
01:12:14 <sjanssen> edwardk: fromList [0 .. n]
01:13:49 <ezero> this is funny but which code do you guys think is more efficient? http://pastebin.com/d782879c OR http://pastebin.com/d4ac559ae
01:13:56 <ezero> they both do the same thing
01:14:20 <edwardk> it feels a lot more sluggish =/
01:14:28 <ezero> in terms of execution time
01:15:03 <sjanssen> edwardk: I get an error when 'darcs getting' your repository
01:15:12 <edwardk> sjanssen: let me update it
01:15:18 <edwardk> i push to that one
01:15:22 <edwardk> i work locally
01:15:24 <sjanssen> "* migrated generator, darcs crash recovery"
01:16:19 <edwardk> sjanssen: lovely. that was around when it acted up on my local machine too
01:16:36 <edwardk> i'll add an sdist to the folder
01:16:56 <sjanssen> ezero: "x == []" and the like will be slower
01:17:04 <sjanssen> though GHC might optimize the slowness out
01:17:09 <ezero> its not actually its quicker
01:17:17 <edwardk> http://comonad.com/haskell/monoids/dist/ 0.1.33
01:17:40 <ezero> thats what i was told yesterday that x == [] will make it slower so i used pattern matching but the pattern matching code is 1 second slower
01:17:55 <ezero> nearly 2 second
01:18:06 <sjanssen> edwardk: try darcs check/repair?
01:18:41 <edwardk> sjanssen: i did. they advised me to plant ivy as it were. ;) i tried to repair with 1.x and the latest 2.x, etc.
01:18:52 <edwardk> i can nuke the folder thats up there and overwrite it completely from the local system
01:18:59 <edwardk> but that will take a while
01:18:59 <sjanssen> ezero: but there are other differences between the two
01:19:24 <ezero> yes so what others might be slowing it down?
01:19:40 <edwardk> basically i hopped on the darcs channel and they pointed to a nice open bug and shrugged
01:19:53 <ezero> the mix function is completely rewritten to use pattern matching
01:19:57 <edwardk> i had thought it was fixed
01:20:37 <ezero> I think ui should use filter for doing p < (head c) business
01:21:24 <edwardk> just going to push the package to hackage and we can go from there
01:23:56 <edwardk> sjanssen: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monoids-0.1.33 has it now
01:24:10 <edwardk> sjanssen: try pulliing it from cabal
01:24:24 <sjanssen> edwardk: I just grabbed your sdist
01:24:28 <edwardk> k
01:24:56 <edwardk> i think its being pretty dumb about the view
01:25:02 <sjanssen> edwardk: in the long term, it might be nice to take this out of the monoids mega-package :)
01:25:17 <sjanssen> edwardk: it's possible that explicitly matching tip makes it slower
01:25:22 <edwardk> sjanssen: it will be, i was just getting ready to use it locally
01:25:26 <sjanssen> (when tip is the second pattern)
01:25:27 <edwardk> sjanssen: yeah
01:25:41 <edwardk> thought about that part, but hadn't gotten out of mechanical translation mode
01:25:57 <edwardk> the other thing is i wonder if the view pattern when applied non-consecutively gets completely recomputed
01:26:13 <edwardk> also i wonder if ghc deals with multi-constructor returns well
01:27:30 <edwardk> pruning a ton of Tip cases
01:30:05 <edwardk> i wonder if it'd be faster to provide isTip or something?
01:30:43 <edwardk> then in the other case it wouldn't bother to box up everything and send it over just to have it discarded
01:31:16 <sjanssen> edwardk: Data.Set has lots of recursive functions, this is a problem
01:31:52 <edwardk> sjanssen: yeah
01:32:11 <Feuerbach> any ideas on why proc-bounded variable can fall out of scope? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3406
01:32:34 <Feuerbach> er, bound
01:43:15 <sjanssen> edwardk: converting member to the worker/wrapper form is a big win here
01:44:19 <edwardk> sjanssen: ?
01:44:34 <wli> Set.member?
01:44:36 <edwardk> throw in hpaste?
01:44:46 <wli> What's worker/wrapper form?
01:45:13 <sjanssen> member x = go where go = the actual defn.
01:45:27 <sjanssen> a trick to inline recursive functinos
01:45:40 <edwardk> yeah
01:45:58 <wli> So that's where the "go" stuff comes from.
01:46:00 <edwardk> sjanssen: ripped out all the spurious tips
01:46:17 <wli> I usually do function x = function' where function' = ...
01:46:32 <edwardk> still stalls but nowhere near as badly
01:47:28 <edwardk> sjanssen: http://comonad.com/haskell/Unboxed.hs
01:48:02 <sjanssen> wli: I picked up "go" from ByteString
01:48:07 <sjanssen> it might be older than that
01:49:13 <osfameron> have you got a nice neat example of that worker/wrapper?
01:50:22 <sjanssen> edwardk: the generators import is unused
01:50:24 <edwardk> i flipped back to member x y = case view y of ...
01:50:43 <sjanssen> edwardk: removing the Tips doesn't seem to help much in my test
01:50:46 <edwardk> sjanssen: i stripped it out of the code below, i was using it to replace the no longer valid Foldable
01:51:21 <sjanssen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3407#a3407
01:51:54 <edwardk> updated and pushed to same location
01:52:47 <edwardk> System.TimeIt?
01:52:55 <sjanssen> edwardk: cabal install timeit
01:53:15 <sjanssen> {-# SPECIALIZE member :: Int -> USet Int -> Bool #-} -- big win, but probably cheating?
01:53:30 <edwardk> compiling with it (.text+0x90): undefined reference to `timeitzm0zi9zi0zi0_SystemziTimeIt_timeIt_closure' blows up with that
01:53:34 <edwardk> hah yeah i thought about those
01:53:43 <edwardk> but we'd wind up with one for every member for every unboxing
01:54:07 <edwardk> so i'd prefer to avoid them, but i'm not too proud, if need be i'll autogenerate them with a little perl script
01:54:08 <edwardk> ;)
01:54:08 <sjanssen> right, and they have to be specified with the actual source to the function
01:54:12 <sjanssen> so a non-starter
01:54:35 <sjanssen> edwardk: forgot --make?
01:55:20 <edwardk> somewhat embarassingly yes
01:55:31 <edwardk> you can tell how many actual apps i write can't you? =)
01:56:03 <wli> I don't get much done anymore.
01:56:05 <edwardk> ok, so we're still 4x slower on construction
01:56:15 <edwardk> er 3x or so
01:56:32 <edwardk> playing with things for a bit now that i have a benchmark
01:59:19 <mmorrow> edwardk: i have a nice benchmark for you.. i just pulled this "kinda sql-ish db thing" that uses IntSets heavily and made a big Data.Binary-encoded bench.dat (currently gzipped) to run it on
01:59:22 <mmorrow> http://moonpatio.com/repos/set-bench
02:00:01 <edwardk> oh whoa, with -O3 we're competitive construction 1.35x as slow but faster member test
02:00:05 <mmorrow> that particular dataset and query will run for i-don't-even-know how long, but you get to see progress printed out in the form if the forest
02:00:21 <mmorrow> that does heavy unions/isects
02:00:26 <edwardk> mmorrow: nice
02:00:47 <sjanssen> edwardk: I suppose we're probably creating twice as much garbage on construction: both a real node and a view node
02:00:52 <edwardk> yeah
02:00:54 <wli> Anyone tried the AVL trees for Data.Set?
02:01:03 <edwardk> how can we make the view node vanish?
02:01:13 <sjanssen> edwardk: I bet Data.Set would be faster with the worker/wrapper change too
02:01:22 <sjanssen> edwardk: CPS?
02:01:25 <edwardk> the member they had was actually written that way
02:01:39 <edwardk> well, it was almost, it used an explicit case
02:01:47 <edwardk> sjanssen: possibility
02:02:16 <edwardk> sjanssen: i'll hack up a cps view
02:02:48 <wli> Or, actually, maybe I should start by asking what you guys are doing to the implementationof Data.Set?
02:02:50 <dolio> I think there's some AVL stuff on hackage somewhere.
02:03:05 <sjanssen>     
02:03:22 <wli> dolio: I think they're tweaking the Data.Set implementation or something.
02:03:33 <sjanssen> wli: using type families to specialize the data representation
02:03:41 <dolio> Yeah, they're specializing it to every unboxable type.
02:03:59 <sjanssen> wli: a Set Int, for example, will have an indirection to the Int in each node
02:04:19 <sjanssen> we want to unpack that Int directly into the node's constructor
02:04:25 <wli> i.e. trying to obviate the need for IntSet/IntMap?
02:04:32 <sjanssen> wli: yeah
02:04:44 <kadaver> did Gödel program?
02:05:07 <jedai> In other words you're trying to do gset (how did gmap fare by the way ?)
02:05:34 <sjanssen> jedai: not quite the same approach
02:05:42 <wli> There's probably a fair amount of mileage to be gotten from using rbtrees or some such.
02:05:49 <dolio> I think summer of code ended before the guy finished everything.
02:05:53 <sjanssen> gmap specialized both the data and the functions -- we want different data with the same functions
02:06:08 <jedai> closer to data-adaptive that dons put on hackage yesterday/today ?
02:06:49 <sjanssen> wli: Data.Set uses goofy size balanced trees.  I bet there's a reason those aren't covered very much in the literature
02:07:00 <sjanssen> jedai: exactly like that
02:07:30 <wli> sjanssen: Probably because they're suboptimal...
02:07:59 <dolio> Man, STUArray must generate some really bad code.
02:08:04 <mc___> I dont get whats wrong with: length "foo"  / 2
02:08:17 <wli> mc___: length "foo" `div` 2
02:08:23 <kadaver> Gödel was at summer of code? i thought he died in the 70s?
02:08:40 <jedai> mc___: or (fromIntegral $ length "foo") / 2
02:08:41 <mc___> wli: why do I need 'div'?
02:08:55 <jedai> mc___: because length returns an Int
02:09:00 <dolio> (/) is division of fractional things. div is integral division.
02:09:14 <wli> mc___: Integer division is div; they're backticks, too, not single quotes.
02:09:24 <edwardk> cps made the member test slower
02:10:06 <mc___> wli: ah, thank you
02:10:12 <edwardk> viewk :: b -> (Size -> a -> USet a -> USet a -> b) -> USet a -> b
02:10:35 <edwardk> member x = viewk False (\_ y l r -> case compare x y of ...)
02:11:56 <ppavelV6> @src peekArray
02:11:56 <lambdabot> Source not found. It can only be attributed to human error.
02:12:29 <sjanssen> does "member x = fix $ \go -> ..." help? (ie. make it non-recursive)
02:13:06 <sjanssen> edwardk: GHC won't optimize much if 'member x l' is on the RHS
02:13:25 <ppavelV6> hmmm.... hoogle at http://haskell.org/hoogle happily gives a source for Foreign.Marshall.Array.peekArray
02:13:34 <edwardk> sjanssen: member x = go where go = viewk ... ?
02:13:45 <ppavelV6> @src Foreign.Marshall.Array.peekArray
02:13:46 <lambdabot> Source not found. Sorry.
02:13:46 <sjanssen> edwardk: or that
02:14:35 <edwardk> no change
02:15:21 * ppavelV6 wonders why peekArray is not a good producer
02:15:39 <edwardk> ok, switched to full application and it started going faster
02:17:03 <sjanssen> ppavelV6: because it has to read the entire array at once
02:17:19 <sjanssen> otherwise someone else might write to it or free it in the mean time
02:17:22 <ppavelV6> sjanssen: but why?
02:17:29 <ppavelV6> oh... i see
02:17:55 <ppavelV6> thank you. Probably the version using ForeignPtr can read an array lazily
02:19:12 <sjanssen> ppavelV6: not safely, there is still the problem of updates to the array
02:20:30 * ppavelV6 fails to see the problem here. The array can be updated just before you got a pointer or just after this. 
02:20:54 <edwardk> ok, cut it in half
02:21:33 <sjanssen> ppavelV6: imagine there is one thread reading and another thread writing
02:21:51 <mmorrow> edwardk: heh, i made `query0' a little long (or query.dat, but that's more of a pain to rebuild)... commenting out a little over half or `query0' and Data.IntSet finishes in around a minute, but using all of query0 and it's been running for 5+..
02:22:03 <sjanssen> in that case it matters exactly when the reads happen, they'll return different answers
02:22:04 <ppavelV6> sjanssen: there're no sync primitives inside peekArray as well
02:22:39 <edwardk> mmorrow: yeah that will proabbly do wonders for this once i get off of work today ;)
02:22:41 <sjanssen> if peekArray could lazily return the results, we'd have a pure value with a non-deterministic value!
02:23:01 <edwardk> mmorrow: next step making building the uset faster than building a set
02:23:21 <mmorrow> edwardk: i'm really interested to see how this turns out..
02:23:42 <mmorrow> i use Data.(Int)Map/(Int)Set a a lot
02:23:43 <ppavelV6> sjanssen: I have to think about it, but peekArray does not (and can not) return a pure value
02:24:17 <ppavelV6> sjanssen: peek itself and peekElemOff do not
02:24:27 <sjanssen> ppavelV6: but you want peekArray to be a good producer?
02:24:45 <sjanssen> this means elements would have to be produced lazily
02:24:50 <edwardk> insert is a little less amenable to the same optimization that member took up so nicely
02:25:10 <ppavelV6> sjanssen: I have to think about it :)
02:25:24 <sjanssen> ppavelV6: see unsafeInterleaveIO
02:26:09 <edwardk> sjanssen: http://comonad.com/haskell/Unboxed.hs has the approach i'm using right now for member and insert, ideas?
02:27:22 <edwardk> i suppose i should fix balance
02:28:13 <edwardk> ah that would be probably where all the speed is going
02:29:36 <ppavelV6> sjanssen: yeah! exactly. Thanks a lot
02:33:03 <sjanssen> edwardk: you might want to add size to the US class
02:33:11 * ppavelV6 works with large data sets mapped read-only into the address space
02:33:13 <sjanssen> or at least define it via CPS
02:35:27 <edwardk> sjanssen: yeah
02:35:33 <ppavelV6> sjanssen: thanks again, i have to think about the relationship between laziness and IO
02:35:37 <edwardk> i did the cps transform it didn't help, moving it to the class
02:37:21 <edwardk> moving it into the class helped ~5%
02:42:23 <edwardk> sjanssen: http://comonad.com/haskell/Unboxed.hs is the current version not much changed but some minor questions of do i {-INLINE #-} or not etc. but its faster now. catching up to Set
02:42:52 <edwardk> IntSet is still 40% faster on insert, but we're 25% faster than it on membership testing
02:44:33 <edwardk> i think i can thread the continuation through rotateL/R singleL/R doubleL/R and save a lot of time
02:44:46 <cjs> Hm. How do I do a type class where the instances are parameterized types? E.g., a Chanell class that has read/write/etc functions, of which Chan would be an instance?
02:47:34 <cjs> Is it just a multi-parameter type class?
02:50:26 <cjs> Is there any way to do this?
02:51:35 <cjs> Basically, I want something like this, but I can't figure out the syntax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3408#a3408
02:51:41 <sioraiocht> @djinn (a,(b->c)) -> ((a->b),(b->c))
02:51:41 <lambdabot> -- f cannot be realized.
02:52:29 <cjs> If I take out the parens, it works, but I can't figure out how to declare the instance.
02:52:33 <sioraiocht> @djinn (a,(b->c)) -> ((a->b),(a->c))
02:52:33 <lambdabot> -- f cannot be realized.
02:52:39 <sioraiocht> that's disappointing
02:53:00 <doserj> cjs: class Channel c where ... should just work
02:53:16 <bavardage> how can I join a list together with a certain character?
02:53:18 <doserj> then instance Channel Chan where ...
02:53:21 <bavardage> (a showable list)
02:53:26 <bavardage> or a list of strings
02:53:32 <Feuerbach> sioraiocht: read about Curry-Howard isomorphism
02:53:39 <bavardage> is there a builtin or should i roll my own?
02:53:39 <Feuerbach> bavardage: intersperse
02:53:41 <sioraiocht> Feuerbach: i know about it =p
02:53:44 <Feuerbach> :t intersperse
02:53:46 <lambdabot> forall a. a -> [a] -> [a]
02:53:47 <bavardage> Feuerbach: ty
02:54:02 <Feuerbach> sioraiocht: why is it disappointing then? :)
02:54:09 <sioraiocht> lol don't ask
02:54:10 <bavardage> @src intersperse
02:54:10 <lambdabot> intersperse _   []     = []
02:54:10 <lambdabot> intersperse _   [x]    = [x]
02:54:10 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
02:54:18 <bavardage> where is it defined :P?
02:54:25 <Feuerbach> in Data.List
02:54:29 <bavardage> kk
02:54:41 <cjs> doserj: But when I try to declare the instance, "instance Channel (Chan a) where writeChannel = writeChan", I get a "Couldn't match expected type `a' against inferred type `a1'"
02:55:15 <doserj> cjs: instance Channel Chan where ...
02:55:44 <cjs> doserj: "`Chan' is not applied to enough type arguments"
02:56:45 <doserj> cjs: what's the definition of Chan?
02:56:57 <jrx> where is the documentation of Control.Arrow.Transformer modules?
02:57:00 <cjs> It's the one from Control.Concurrent.Chan.
02:57:07 <int-e> cjs: class Channel (c a) where
02:57:22 <Gracenotes> @src intercalate
02:57:22 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
02:57:27 <int-e> cjs: try Channel c where  instead?
02:57:36 <cjs> int-e, yes, I tried to give that a go as well.
02:57:55 <cjs> I mean the Channel (c a) one. Doesn't like that declaration.
02:59:03 <int-e> good, it should not, because knowing (c a) doesn't give you a -- c might be a type synonym.
02:59:26 <cjs> When I do that, it gives me "Type found where type variable expected", on the open paren.
03:00:00 <doserj> cjs: class Channel c where ... instance Channel Chan where ... works for me
03:00:30 <cjs> doserj: Can you put your code up on hpaste.org? I must be doing something silly.
03:01:13 <doserj> done
03:01:19 <cjs> I'm on ghc 6.10.1, BTW. And I've been trying this with and without extensions turned on.
03:01:30 <doserj> no extensions needed.
03:02:49 <int-e> cjs: here are three versions that work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3408#a3410
03:03:29 <int-e> (and the second one of these is Haskell98)
03:04:54 <int-e> and identical to doserj's code.
03:04:58 <cjs> Hm. So I did need FlexibleInstances. But I must have had some sort of typo in what I was doing at some point. The paste works fine.
03:05:33 <doserj> you don't need FlexibleInstances for int-e's second version
03:06:02 <doserj> that's as standard haskell98 as it can get
03:06:38 <doserj> compare with instance declarations of [], or Maybe
03:06:57 <edwardk> ok, moving to cps inside balance so far has been a loss, but i haven't threaded the continuation down into the various rotations, which keep regenerating it
03:13:02 <zong_sharo> ghc-pkg check : There are problems in package rts-1.0: include-dirs: PAPI_INCLUDE_DIR doesn't exist or isn't a directory
03:13:36 <zong_sharo> http://dpaste.com/24791/ <- full ghc-pkg check log
03:13:49 <zong_sharo> what the heck and how can i fix that?
03:14:20 <cjs> doserj: Yes, though I prefer the first version; it seems more clear to me.
03:15:46 <jedai> zong_sharo: macOSX ?
03:16:51 <int-e> no, that's a universal problem, Simon sent a mail about it a few days ago. If only I could find it ...
03:17:35 <zong_sharo> jedai: gentoo
03:18:12 <doserj> cjs: the first version will give some issues with type-inference, probably. That's why functional dependencies (the third version) were invented.
03:18:20 <int-e> zong_sharo: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-April/017012.html
03:18:57 <zong_sharo> nick hack
03:19:01 <zong_sharo> *nice hack
03:19:13 <bavardage> supposedly HTTP supports bytestrings.. how do I parse a url given as a bytestring?
03:19:18 <cjs> doserj: Doesn't the third version say that for any given a, there can be only one c?
03:20:21 <doserj> cjs: actually no. It says for every given c, there can be only one a.
03:21:08 <zong_sharo> int-e: thx
03:21:34 <cjs> doserj: I'm still not quite clear on that: can you give me an example of something that would break that constraint?
03:21:37 <doserj> but I may be wrong with my worries about the first version. the methods already say that c must be parametric in a, so that should be ok
03:24:22 <doserj> cjs: not a really sensible example. the functional dependency just says that a channel type c already knows what type a it contains.
03:24:32 <monadzilla> hello, is it possible to print a character to a certain row/column on the console
03:25:12 <cjs> doserj: Oh, I see. thus one can say c -> a -> IO () rather than c a -> a -> IO ().
03:25:25 <doserj> cjs: yes.
03:25:44 <cjs> Hm. I'll have to sit down one day when I have more time and go over functional dependencies more carefully.
03:26:24 <augustss_> Running hugs on the iPhone is cool, but the keyboard is not made for programming.
03:28:22 <edwardk> sjanssen: around?
03:28:47 <edwardk> sjanssen: i rewrote balance plumbing the continuation all the way down into singleR/L, etc. but it didn't help
03:31:20 <bavardage> how do I get a lazy ByteString from Network.HTTP?
03:31:34 <monadzilla> do any of the curses bindings work on windows?
03:31:45 <NameAlreadyInUse> is there a way for me to tell whether the type of a value is an instance of a type class?
03:32:14 <NameAlreadyInUse> like "instanceOfNum 6" is True, "instanceOfNum "some string" " is False
03:32:24 <yitz> NameAlreadyInUse: the type checker tells you that at compile time
03:32:37 <NameAlreadyInUse> yitz: is there a way to check this at run time?
03:33:09 <yitz> NameAlreadyInUse: why do you want to check it at run time?
03:33:36 <yitz> NameAlreadyInUse: are you using generics?
03:34:02 <NameAlreadyInUse> not for any particular reason, i was just curious
03:34:05 <bremner> NameAlreadyInUse: you get that Haskell is statically typed, right?
03:35:01 <NameAlreadyInUse> bremner: i know, but type information surely must exist at run time for type classes to work, or am i missing something?
03:35:29 <yitz> NameAlreadyInUse: there are many possible implementations.
03:36:05 <yitz> NameAlreadyInUse: typical Haskell programs do not depend on any such information being available at run time.
03:36:29 <bremner> NameAlreadyInUse: Since the actual type is known at compile time, I don't think so, but there are many people more expert than I
03:39:25 <yitz> NameAlreadyInUse: In GHC, a polymorphic function argument that can be any instance of a class causes GHC to add an extra invisible argument to the function that contains a method table for the type of the object that is passed at runtime.
03:40:19 <Feuerbach> any ideas on why proc-bounded variable can fall out of scope? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3406
03:44:00 <kadaver> hmm who made the easyVision library? ie a computer vision lib in haskell.
03:45:48 <int-e> Feuerbach: the variables may not occur between <- and -<. The -<< variant allows that, if I read the docs correctly.
03:48:11 <scriptdevil> kadaver: Well.. Is it not on hackage?
03:49:00 <kadaver> no
03:53:49 <Feuerbach> int-e: thanks!
03:59:07 <ErhardtMundt> ciao
04:03:37 <bavardage> :(
04:03:39 <bavardage> THIS MAKES NO SENSE
04:03:48 <bavardage> the doc keeps talking about functions that don't exist
04:03:52 <bavardage> or I'm being really really stupid
04:03:56 <bavardage> which is probably more likely
04:04:24 <bremner> bavardage: I always like to think both are possible for me
04:05:07 <Saterus> bavardage: i've been doing some networking stuff too the last few days. the documentation available on hackage seems incomplete. your best bet is to start sifting through the source. :(
04:05:35 <bavardage> yeah it's difficult :P
04:05:43 <bavardage> has anyone managed to get ByteStrings ?
04:05:50 <bavardage> all I want is a ByteString :(
04:06:31 <bavardage> hmm it seems I have version 4000.0.4 instead of 4000.0.5
04:07:12 <Saterus> bavardage: not a clue, sorry. it took me pretty much all of yesterday to figure out how to form my request so that i stopped getting "bad request" responses.
04:07:23 <bavardage> :P
04:09:00 <bavardage> I'll at least try to upgrade to the latest version
04:11:36 <kadaver> is it possible to make a patent on something and forbid it to be used for military purposes?
04:12:08 <bremner> kadaver: you are not required to license patents
04:12:19 <kadaver> what does that mean?
04:12:29 <kadaver> that i can forbid the use of them?
04:12:41 <kadaver> but when the patent expire it is free for all?
04:12:53 <bremner> kadaver: yes.  In theory
04:13:07 <kadaver> and patents are expensive and likely China and the USA dont give a shit anyway
04:13:27 <bremner> kadaver: yes. But if #haskell is your best source of legal advice...
04:13:42 <ibid> and you are required to commercially exploit the patent, iirc
04:13:53 <bremner> kadaver: IMNSHO, software patents are lame
04:14:00 <bremner> ibid: I don't think so
04:14:18 <bremner> ibid: maybe it varies by jurisdiction
04:15:52 <hipertracker> I am new to Haskell. Inside REPL I have simple statement: let arr = ["a", "b", "c"]. How to get second element? arr[1] nor arr 1, nor arr(1) do not work.
04:16:23 <kadaver> arr !! 1
04:16:37 <NameAlreadyInUse> ibid: there are companies that patent things just so they can file lawsuits against companies that happen to "infringe" on the patent without knowing
04:16:38 <kadaver> > let arr = ["a", "b", "c"] in arr !! 1
04:16:39 <lambdabot>   "b"
04:16:40 <hipertracker> kadaver: tnx :)
04:16:45 <NameAlreadyInUse> i believe they are called patent trolls
04:16:51 <ibid> bremner: okay, checked the law (for finland): after a couple of years, if the patent holder isn't exploiting the patent, someone else can get a court to grant him a license
04:16:55 <RayNbow> @let cstyle xs = map (xs!!)
04:16:56 <lambdabot>  Defined.
04:17:05 * bremner considers moving to finland
04:17:16 <ibid> of course, that license is not free
04:17:27 <osfameron> do they set a reasonable fee in that case though?
04:17:31 <RayNbow> > let arr = cstyle ["a", "b", "c"]   in   arr[1]
04:17:32 <lambdabot>   ["b"]
04:17:40 <RayNbow> ^ not recommended though :p
04:18:17 <ibid> osfameron: the court sets the fee
04:18:25 <kadaver> let (x:xs) = ["a".."c"] in head xs
04:18:27 <kadaver> > let (x:xs) = ["a".."c"] in head xs
04:18:28 <lambdabot>       No instance for (Enum [Char])
04:18:28 <lambdabot>        arising from the arithmetic sequen...
04:18:37 <kadaver> > let (x:xs) = ['a'..'c'] in head xs
04:18:38 <lambdabot>   'b'
04:18:53 <kadaver> > let (x:y:xs) = ['a'..'c'] in y
04:18:55 <lambdabot>   'b'
04:19:00 <osfameron> ibid: seems reasonable, depending on how the courts apply it
04:19:08 <ibid> NameAlreadyInUse: i'm sure those companies are happy to license their patents to others in exchange for money, satisfying the commercial exploitation requirement
04:19:56 <bremner> afaik, most (many?) patent licenses are trades between large holders
04:20:28 <ibid> this seems to be actually international law, not just finnish
04:20:39 <ibid> and exploited mostly in developing nations
04:21:12 <NameAlreadyInUse> RayNbow: where is that cstyle function from?
04:21:28 <ibid> http://en.wikipedia.org/wiki/Compulsory_license
04:22:34 <hipertracker> RayNbow:  Prelude> let arr = cstyle["a", "b", "c"] in arr[1]  displays Not in scope: `cstyle'
04:23:28 <bremner> ibid: I
04:23:57 <bremner> ibid: I'm pretty sure that article says schemes like finland's ok permitted, not that they are mandatory under treaty
04:24:35 <ibid> bremner: true
04:24:48 <ibid> bremner: not a finnish oddity, either
04:24:49 <bremner> @remember JelloBiafra: The conveniences you demanded are now mandatory.
04:24:49 <lambdabot> I will never forget.
04:27:21 <ibid> bremner: i found some indication that exercising the compulsory license option might have become relevant in a past mobile phone standards fight, in which qualcomm (?) was threatening not to give patent licenses
04:28:10 <ibid> bremner: but they did reach a voluntary agreement eventually
04:36:55 <LeCamarade> join #math
04:37:03 <LeCamarade> Sorry.
04:38:01 <LeCamarade> Does Data.Set.length (tacitly) use the axiom of choice?
04:38:22 <LeCamarade> I feel that the very concept of cardinality (of the set) requires Choice.
04:40:04 <ibid> LeCamarade: you don't need axiom of choice with countable sets, i believe
04:40:05 <RayNbow> NameAlreadyInUse, hipertracker --> <RayNbow> @let cstyle xs = map (xs!!)
04:44:04 <LeCamarade> Well, how would you - if the function is recursive, say - get the "tail" of the set?
04:44:31 <LeCamarade> Are countable sets somehow different? Expliquez, s'il vous plait. :o)
04:44:53 <kadaver> how come both map (1+) [1..10] and map (+1) [1..10] works?
04:45:05 <wjt> because (+) is commutative
04:45:14 <LeCamarade> kadaver, Because the + takes two args, and is associative.
04:45:15 <EvilTerran> (1+) = \x -> 1 + x; (+1) = \x -> x + 1
04:45:19 <LeCamarade> I mean commutative.
04:45:22 <LeCamarade>  :o)
04:45:28 <kadaver> sure but i meant how it applies it
04:45:42 <wjt> kadaver: (1 +) desugars to ((+) 1)
04:45:50 <LeCamarade> kadaver, Whichever arg you don't provide is the one they provide later.
04:45:50 <wjt> kadaver: (+ 1) desugars to (flip (+) 1)
04:46:20 <EvilTerran> LeCamarade, i believe you can prove something like the AoC but restricted to finite or countable sets from ZF
04:47:33 <LeCamarade> EvilTerran, Yeah, so assuming the set is vanilla, and is just an unordered ... collection, there is need for Choice to be able to count the elements?
04:48:13 <EvilTerran> well, if a set doesn't have to be finite, "count the elements" is meaningless anyway
04:48:37 <EvilTerran> Data.Set only deals with finite sets, so the AoC has nothing to do with it
04:48:57 <Alpounet> AoC ?
04:49:17 <opqdonut> Axiom of choice
04:49:30 <LeCamarade> Why would "count the elements" be meaningless for a finite set? Can't, if only as an exercise, one be required to write a (Mathematical) function to find the cardinality?
04:50:09 <LeCamarade> Do you assume that the cardinality of a countable set is always known?
04:50:14 <EvilTerran> LeCamarade, i said "count the elements" is meaningless for the domain of potentially infinite sets
04:51:17 <EvilTerran> you can talk about the cardinality, true
04:51:18 <LeCamarade> Ah. Yes, I misread.
04:51:49 <LeCamarade> But then, how does one get the cardinality of a set sans the AoC?
04:52:00 <LeCamarade> It seems to me that it must be used.
04:52:36 <opqdonut> gah
04:53:08 <opqdonut> proving that (for example) the reals are \ge 2^naturals is easy
04:53:31 <opqdonut> even without the axiom of choice
04:53:50 <opqdonut> in _specific_ situations one can usually _construct_ the function provided by AoC
04:54:15 <EvilTerran> ... including all situations where all sets involved are finite or countable, i believe?
04:54:27 <opqdonut> yeah, countable sets are no problem
04:55:45 <bremner> are uncountable sets representable on a Turing machine?
04:55:55 <opqdonut> representable how?
04:55:59 <EvilTerran> bremner, a countable number of them will be, depending on your encoding :P
04:56:05 <opqdonut> the set of outputs and inputs is countable
04:56:07 <opqdonut> yeah
04:56:07 <bremner> uhh, good point
04:56:26 <EvilTerran> *countable subset
04:56:35 <opqdonut> uncountability doesn't in general matter much in theory of computation
04:56:35 * EvilTerran confuses himself
04:56:35 <LeCamarade> Maybe I am thinking wrong, or I should phrase it differently: what axioms would enable you to cherry-pick members of a set? (And, essentially, make, for example, Data.Set.toList.)
04:57:37 <edwardk> ok, going to head into the office and call it a night. results so far, replacing pattern matching with views in Data.Set costs about 28% performance when you are manipulating the leaves a lot (i.e building), but unboxing then wins most of that back (its only about 11% slower), but gains big when doing membership testing. which is almost 35% faster than normal.
04:58:11 <LeCamarade> I thought that, for 1 to be picked out of {3, 4, 5, 2, 1, 0}, I need the axiom of choice.
04:58:17 <edwardk> so for 11% build time you can win 35% member testing time, and not spray thunks all over main memory
04:58:21 <LeCamarade> And for those who haven't discovered it yet, a citable alternative to Wikipedia (but without a thing on, say, Round the Twist) is at plato.stanford.edu.
04:58:54 <EvilTerran> LeCamarade, if your sets are all finite, you could always resort to explicit enumeration of the possibilities
04:58:59 <edwardk> i think Map could be a bigger win, unboxing both key and value
04:59:00 <opqdonut> LeCamarade: you don't need AC for finite sets
04:59:17 <opqdonut> as finiteness implies an injection from a beginning segment of the naturals to your set
04:59:29 <opqdonut> i.e. a well-ordering
05:00:45 <LeCamarade> opqdonut, You mean any finite set is a well-order? Even a set of {bananas, apples, oranges, tables, haskell}?
05:00:52 <opqdonut> yes
05:01:06 <LeCamarade> Just because 'tis finite? I didn't know that.
05:02:06 <LeCamarade> So should I deem cardinality a "bundled attribute" of a finite set, and not something that can be, say, computed?
05:02:06 <opqdonut> well depending on one's definition of finiteness
05:02:17 <opqdonut> it flows easily or more complicatedly :)
05:04:06 <yitz> edwardk: can building be optimized for, e.g., fromList or fromAscList?
05:05:46 <LeCamarade> opqdonut, I'm not quite satisfied. And, it turns out, #haskell is a better #math than #math. So I'll ask again, in some other form: is it possible to write a function that finds the cardinality of a certain set S?
05:06:05 <edwardk> yitz: i'm curious if fromAscList could be turned into something fast and pivot free
05:06:25 <edwardk> yitz: right now those paths do the same as the Set path
05:06:43 <edwardk> any optimizations there would work equally well on Data.Set and don't exactly highlight the approach
05:06:56 <mstr> oranges > apples > bananas, imo
05:07:25 <yitz> edwardk: ok. if we could do something along those lines, then your views results are an unequivocal bin win.
05:07:50 <yitz> *big
05:08:53 <edwardk> yitz: if nothing else i appear to have picked up a few changes along the way that make membership searches faster than in the normal data.set
05:09:08 <edwardk> er membership searches even for boxed values that is
05:09:31 <edwardk> only about 10-15% so far, but still nice
05:10:29 <yitz> yes very nice
05:11:07 <Ferdirand> is there a sucessor to the pfp library ?
05:11:21 <edwardk> yitz: i'll pick it up after work and see if i can eke out a performance win. I _should_ be able to rebalance faster with the continuations than not, but its so far eluded me
05:13:12 <opqdonut> LeCamarade: 1) of course a _mathematical_ function for that exists 2) of course a turign machine that simply counts the elements of a finit sets is possible
05:13:50 <opqdonut> LeCamarade: however, when considering infinite inputs you need to specify what kind of computational formalism you want the function to be expressable in
05:14:01 <opqdonut> LeCamarade: i for one know of now formalisms for infinite computations
05:14:06 <opqdonut> *no
05:16:16 <yitz> mstr: I think that is a fruitless pursuit.
05:16:33 <bavardage> with HXT how would I go about getting the value of a tag that may exist
05:16:43 <bavardage> but giving Nothing if it doesn't exist and Just xxx if it does
05:17:02 <bavardage> a <channel> MAY have a <sub-title>
05:18:24 <yitz> bavardage: i guess it depends on where in the tree the tag could occur.
05:19:00 <yitz> bavardage: if it is only an immediate child, just filter the list of immediate children of the node.
05:19:19 <yitz> bavardage: you could then use listToMaybe
05:19:36 <yitz> bavardage: if it could be nested, you'll have to flatten the tree first
05:23:34 <LeCamarade> Yes, so what, if you don't mind, would the mathematical function look like? In other words, what axioms would it invoke to get at the elements in as descriptive a manner as head and tail enables with the list?
05:23:51 <bavardage> yitz: thanks, I got it now
05:23:58 <bavardage> I used `orElse`
05:24:08 <bavardage> maybeGetField field = (getField field >>> arr Just) `orElse` (constA Nothing)
05:24:09 <Saizan> bavardage: there's also withDefault
05:24:17 <opqdonut> LeCamarade: i'm sorry, the function doesn't exists as a proper function
05:24:19 <bavardage> ooh kk
05:24:33 <bavardage> Saizan: I'll check that out too
05:24:35 <opqdonut> LeCamarade: becaus it'd have to know its own cardinality too
05:24:36 <Saizan> withDefault (getField field >>> arr Just) Nothing
05:24:38 <LeCamarade> opqdonut, Ah. :o(
05:24:39 <opqdonut> => russels paradox
05:24:44 <Saizan> not much different..
05:24:57 <opqdonut> but of course one could specify a cardinality function for some restricted class of sets
05:25:11 <opqdonut> just by saying f={(x,|x|) | x\in X}
05:25:11 <byorgey> opqdonut, LeCamarade: not only that, its domain would include all sets... hence it could not be a set.
05:25:24 <opqdonut> byorgey: that's what i meant
05:25:59 <opqdonut> LeCamarade: the point is, a mathematical function need not have some sort of constructive definition that gives an algorithm for computing it
05:26:21 <yitz> bavardage: oh, ok, fine.
05:26:24 <LeCamarade> opqdonut, Fine. I think that, if it could be computed recursively, the cardinality, then it should invoke Choice. But I'm probably far out of my depth now. Work!
05:26:47 <bavardage> yitz: :D
05:27:09 <yitz> :)
05:27:27 <mib_i4jys1xi> hi, can anyone tell me how to install wxHaskell please?
05:28:03 <LeCamarade> opqdonut, Yeah, but I'm recently a bit concerned that something like the cardinality of a set could have no _constructive_ way to achieve it. (I mean, apart from non-constructive ones like "it is contradictory for a set with two elements to have a cardinality that is not two.")
05:28:15 <bavardage> right who wants another question :D - how would I convert a date string like 20090407110000 +0100 into something sane
05:29:12 <opqdonut> LeCamarade: well there are constructive proofs for cardinalities, just no general way to produce them :)
05:29:20 <opqdonut> (afaik)
05:29:25 <LeCamarade> opqdonut, In any case, I think that, if such a constructive method to compute the cardinality should exist, then it invokes Choice (which is non-constructive, heh).
05:29:30 <LeCamarade> :o)
05:30:07 <yitz> LeCamarade: in full generality, there is no such thing as "the set of all sets", nor "the set of all cardinalities", so it doesn't make sense to speak of a "function" between them. But if you fix a universe set U, then cardinality is a function from the set of subsets of U to the set of cardinalities not greater than the cardinality of U.
05:30:40 <mib_i4jys1xi> guess not
05:31:17 <yitz> LeCamarade: its constructibility depends on the constructibility properties of U.
05:31:37 <score> bavardage: there seems to be some 'parseTime' stuff
05:32:07 <Ferdirand> with overlapping instances, is it possible to have a "top-level" instance applying to any type ?
05:33:31 <yitz> Ferdirand: yes, and then your class becomes useless
05:33:35 <Saizan> Ferdirand: yes, instance Foo a where
05:33:50 <bavardage> score: thanks
05:34:01 <Saizan> yitz: not really useless, you can still write more specific instances
05:34:14 <LeCamarade> Ah, yes. That's clearer. Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}. Is there some way to define a function that maps from this set to a member of the natural numbers, where the number corresponds to the cardinality of that set - eight?
05:34:24 <yitz> Saizan: those will then be ambiguous and fail to compile
05:34:32 <Ferdirand> yitz: indeed. is there another way to write a polymorphic function that has an unconstrained type parameter, and still behave differently depending on class membership ?
05:34:36 <Saizan> yitz: not if you use OverlappingInstances
05:34:45 <Ferdirand> perhaps i should provide context
05:34:52 <score> bavardage: http://www.haskell.org/hoogle/
05:34:55 <ibid> yitz: functions don't need to be sets. they can be classes (assuming a formalism that supports proper classes)
05:35:15 <opqdonut> LeCamarade: yes, there of course is a mathematical function that does that
05:35:32 <opqdonut> LeCamarade: and, when a representation for those sets has been settled, there is a turing machine that computes the function
05:36:36 <kaol> I just used fmap $ fmap $ fmap in my code, do I win anything?
05:36:54 <opqdonut> kaol: use "fmap . fmap . fmap" and you might
05:36:56 <opqdonut> ;)
05:36:59 <Saizan> kaol: a 4chan badge?
05:37:00 <yitz> Saizan: OI allows you to define such things, but you can only use them on types for which the instance is determined unambiguously.
05:37:11 <LeCamarade> opqdonut, Nice. Now, if it uses the recursive model (which, we all believe in happy unison, is equivalent to the Turing Machine), would it have to invoke the axiom of choice (in, say, how it stores the elements)?
05:37:17 <kaol> opqdonut: surely you mean fmap `fmap` fmap `fmap` fmap
05:37:26 <opqdonut> LeCamarade: no, the AoC is not needed
05:37:38 <opqdonut> as AoC for numerable sets is provable
05:37:43 <Ferdirand> i have a weighted list [(a,Int)], that should behave like (Map a Int) when I have Eq a, and assume every a is unique otherwise
05:37:50 <LeCamarade> Okay. Cool. :o) Lemme go do some reading.
05:38:02 <ibid> LeCamarade: as long as you're talking about countable sets, the axiom of choice is a theorem, thus even if you appeal to it, it's not a problem
05:38:02 <opqdonut> kaol: we really need something like @fmapify for lambdabot >:)
05:38:25 <Ferdirand> i thought i'd write a reduce step that would be id when the underlying type is not Eq, and do something otherwise
05:38:25 <LeCamarade> opqdonut, Wait, numerable sets? How are they enumerable? Isn't it because we have (if only tacitly) constructed said function?
05:38:27 <Saizan> yitz: yeah, the instance can only be picked when the type is sufficiently ground, as usual
05:38:37 <LeCamarade> Or is it just bad that I missed lunch? :o)
05:39:23 <Ferdirand> i haven't figured yet if the proper way to go is trough a class, or a constrained datatype, or both
05:39:27 <ibid> LeCamarade: i assume opqdonut meant countable (since the finnish for countable is "numeroituva" 'numerable')
05:39:28 <yitz> Saizan: so once you have a universal instance, you can't use methods on any type for which another instance has been defined. So effectively, your methods have reverted to being just ordinary polmorphic functions.
05:39:28 <opqdonut> LeCamarade: you restricted yourself to finite sets
05:39:35 <yitz> polymorphic
05:39:43 <opqdonut> and yes, i meant countable
05:39:45 <opqdonut> thanks, ibid
05:40:12 <LeCamarade> Finite, yes.
05:41:24 <LeCamarade> But I thought - and I think this is where I'm wrong - that you can't target a member of a set - regardless of the attributes of the set, finite or infinite - without invoking something akin to the AoC. But lemme read a bit.
05:41:42 <LeCamarade> I may need to read a whole byte, it appears.
05:41:56 <LeCamarade> Anyway, fgetc doesn't get less than a byte. Meh.
05:41:59 <LeCamarade> :o)
05:42:00 <Saizan> yitz: i don't get that, if i have instance Foo a; and instance Foo Int, if i use a method on Int i get the second code, if i use it with any other type i get the first, that's not parametric.
05:42:18 <yitz> ibid: hmm, I am used to the convention where elements of Hom sets in a category are referred to as "maps" or "arrows", and the term "function" is reserved for the classical notion of function as special kind of relation on the cartesian product of two sets.
05:42:54 <Ferdirand> yitz: so, how would you write (nub' :: [a] -> [a]), when (Eq a) => nub' = Data.List.nub, and nub' = id otherwise ?
05:43:00 <ibid> yitz: yeah well, ask a hundred mathematicians for a name for a particular concept, you get two hundred answers :)
05:43:15 <ibid> (depends on the concept, obviously)
05:43:39 <yitz> Saizan: are you sure that using a method on an Int won't get you an ambiguous instance error at compile time? Either one could apply, how is the compiler to know which to use?
05:43:40 <Axman6> "the combining of two numbers" could do that i reckon
05:43:51 * Axman6 shuts up and goes to sleep
05:43:55 <yitz> ibid: he
05:44:03 <ibid> yitz: in any case, category theory conventions aren't necessarily well known outside that speciality. i'm not well read on either category theory or set theory, but i know the latter better
05:44:11 <Saizan> yitz: the compiler picks the most specific instance. that's the whole point of OverlappingInstances
05:44:35 <Saizan> yitz: otherwise there won't be a point in letting you define the instances
05:45:48 <yitz> Saizan: sure there's a point. It allows you to define instances in a way that they overlap. But then you can only use them at types outside the overlap.
05:46:08 <Saizan> Ferdirand: that's complicated, since you can't (easily) discriminate only on the Eq a context, but the Oleg site has a solution iirc
05:46:39 <Saizan> yitz: ok, but it also let's you use them when they overlap and there's a most specific one
05:46:40 <yitz> Saizan: How does the compiler know which is more "specific"? In general there is no simple containment relationship, and even when there is it is not trivial to figure that out in general.
05:46:50 <Saizan> yitz: check the ghc manual for details
05:47:12 <yitz> Saizan: ok. is that new? i'm sure it didn't work in the past.
05:47:16 <ibid> hmm, AoC for countable sets is independent of ZF, claims wikipedia.  it seems i have a bad mempry for maths
05:47:22 <Saizan> yitz: it always worked like this.
05:47:36 <Saizan> yitz: the order is based on unification
05:48:39 <Ferdirand> Saizan: ok, i'll check this out, thanks
05:48:41 <ibid> but finite choice is a ZF theorem
05:51:03 <yitz> ibid: let c :: A -> Integer be a counting function. then just choose the element from each set such that |c x| is minimum.
05:51:08 <Saizan> Ferdirand: Oleg's solution is not something you'd like to use in normal code, though
05:51:53 <ibid> yitz: context?
05:52:04 <ibid> hmm, google found this lovely quote: "go make a transfinite coffee and it'll be easily finished when you get back"
05:52:16 <yitz> ibid: A0C for countable sets
05:52:52 <Ferdirand> Saizan: i'm trying hard not to let my head explode
05:53:12 <Ferdirand> maybe the restricted monad route is easier
05:54:18 <yitz> Saizan: I used a lot of OI in my early days of Haskell, like most people coming from OO. I never was successful in getting anything like that to work.
05:54:34 <yitz> Saizan: good thing, too. it forced me to start thinking functionally.
05:55:14 <ibid> yitz: you're assuming that you already have chosen a counting function
05:55:49 <yitz> ibid: how are you defining countability then?
05:56:59 <ibid> yitz: that a counting function exists (which immediately means that you have a lot of them). there's nothing in that that gives you a privilieged counting function
05:57:12 <ibid> yitz: in fact, you need AoC or AoCC to pick one
05:58:04 <yitz> ibid: so wikipedia is claiming that you don't need AoC as an axiom though for countable sets.
05:58:17 <Saizan> yitz: i'm not saying that you can do them to implement OO, (well not without some milliOlegs), just that their semantics is different from what you stated.
05:58:32 <Saizan> s/do/use/
05:58:37 <yitz> milliOlegs or megaOlegs?
05:58:44 <ibid> yitz: i was actually consulting planetmath when picking holes in your argument :)
05:59:13 <yitz> ibid: do they have a proof there without assuming a canonical counting function?
05:59:33 <yitz> as I was
05:59:39 <ibid> yitz: proof of ...?
05:59:52 <ibid> no proofs there
05:59:52 <yitz> AoC for countable sets, using ZF
06:00:04 <ibid> AoCC is not provable from ZF
06:00:05 <Saizan> yitz: there's a published paper about it, so the required olegs are not that much :)
06:00:37 <vixey> you can prove choice for omega sure
06:00:50 <yitz> vixey: do you know the proof?
06:01:06 <vixey> let me double check I'm not talking nonsense actually
06:01:10 <yitz> Saizan: depends on who is the intended audience of the paper.
06:03:53 <vixey> yitz: well ordering <=> choice,  omega is well ordered (strong induction on natural numbers)
06:05:08 <jatqceer> How do you define a Storable instance for data D p = D Int Double (ForeignPtr p) ?
06:05:56 <EvilTerran> er... there's a semantics problem with serializing pointers
06:06:47 <jatqceer> what is the problem?
06:07:15 <dolio> You can't store ForeignPtrs. They have fancy stuff attached to them.
06:07:25 <dolio> IORefs with finalizers and shiznit like that.
06:07:34 <dolio> Or, at least, they potentially do.
06:07:45 <EvilTerran> jatqceer, that there's no reason for the thing the pointer is pointing at to be in the same place, or even still existant, when you deserialize
06:08:10 <EvilTerran> serialize a pointer, send it across the network, deserialize it - wait, what?
06:08:38 <Saizan> EvilTerran: you usually use Storable to communicate to some C code in the same process, though
06:08:57 <EvilTerran> you do? oh right, never mind me then :P
06:09:17 <dolio> Regular Ptrs are storable, for instance.
06:09:19 <EvilTerran> @remember LeCamarade Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
06:09:19 <lambdabot> Done.
06:09:31 <dolio> But that's because their definition is "data Ptr a = Ptr Addr#" or something.
06:09:32 <EvilTerran> out-of-context quotations are the best kind of quotations! :P
06:09:42 <dolio> And Addr#s are easy to write to a byte array.
06:09:55 <LeCamarade> :o)
06:10:27 <EvilTerran> dolio, i see. so it's not the fact that it's a pointer that gets in the way
06:10:53 <dolio> No, it's "data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents"...
06:11:40 <dolio> "data ForeignPtrContents = PlainForeignPtr !(IORef (Finalizers, [IO ()])) | MallocPtr (MutableByteArray# RealWorld) !(IORef (Finalizers, [IO ()])) | ..."
06:12:43 <jatqceer> i thought pointer is just a pointer with sizeof(void *)
06:12:52 <dolio> I was hoping that maybe ForeignPtrs could be stored in UArrs the other day (which would mean ByteStrings would be), but seeing that dashed my hopes.
06:12:55 <Saizan> however you can get a Ptr out of a ForeignPtr
06:13:16 <Saizan> though only a reference to the latter will keep the memory alive
06:13:28 <boegel> can one generate an infinite list of random values, relying on laziness to only consume the first n entries?
06:13:55 <jatqceer> I'm actually thinking of to put it in storablevector...
06:14:23 <boegel> something like "sequence (repeat randomIO)"
06:14:28 <boegel> I'm sensing trouble here... :)
06:14:37 <Saizan> boegel: yes, using randomRs
06:14:45 <Saizan> or randoms
06:14:47 <Saizan> ?type randoms
06:14:49 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
06:15:10 <EvilTerran> ?type random
06:15:11 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
06:15:35 <Saizan> it doesn't return the new generator, since it can't determine the last one it'd need
06:16:03 <EvilTerran> ?src randoms
06:16:03 <lambdabot> Source not found. Do you think like you type?
06:16:08 <kowey> hi everybody... is there a way to get a package hidden from the hackage package listing (just the homepage, not the actual db)?
06:16:19 <ibid> any particular reason lambdabot is rude?
06:16:25 <kowey> I have some obsolete packages that I would like to seen cleared away
06:16:25 <boegel> Saizan: hmmk, thanks
06:17:56 <jatqceer> ?src lambdabot
06:17:56 <lambdabot> Source not found. Just try something else.
06:18:34 <EvilTerran> ?where lambdabot
06:18:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:19:27 <boegel> hmm, I don't think randoms will help in my case, but thanks anyway :)
06:20:55 <boegel> I suppose "randoms (mkStdGen 0)" is not a good idea either :)
06:21:16 <boegel> you're supposed to get a hold of one StdGen in an application, and pass it around, right?
06:21:30 <leftblank> too continue what jelly was asking; how can I request the n-th digit of an integer?
06:21:38 <leftblank> can't quite find that sadly
06:22:16 <dolio> Which one is the nth?
06:22:36 <boegel> dolio: I think he means getting '3' from '12345' as the 3th integer
06:22:37 <leftblank> with n being between 0 and the length of the integer
06:22:40 <leftblank> exactly
06:23:00 <boegel> > (show 12345) !! 3
06:23:01 <lambdabot>   '4'
06:23:02 <dolio> boegel: Well, since you picked the one right in the middle, that doesn't clear it up for me. :)
06:23:03 <EvilTerran> ?type first randoms . split -- boegel, what about something like this?
06:23:04 <lambdabot> forall a d. (RandomGen d, Random a) => d -> ([a], d)
06:23:09 <leftblank> thanks
06:23:12 <boegel> dolio: :P
06:23:32 <boegel> EvilTerran: hmm
06:23:42 <boegel> EvilTerran: well, not sure if that'll help me either :)
06:23:54 <boegel> EvilTerran: in doing something very peculiar, it seems
06:24:13 <EvilTerran> what exactly *are* you doing?
06:24:20 <boegel> EvilTerran: I'm trying to come up with an elegant module for genetic algorithms (more general than the one currently in Hackage)
06:24:43 <boegel> EvilTerran: I'm defining a GenAlg typeclass, which has a function genRandomEntity
06:25:31 <kowey> to answer my own question, I guess http://hackage.haskell.org/trac/hackage/ticket/261 would need to be implemented first
06:25:44 <boegel> when defining an instance for GenAlg for [Double], I need to fill in the definition of genRandomEntity, and I'm struggling to get it to do what I want, i.e. generate a [Double] of a certain length, depending on the user input
06:26:35 <boegel> seems like randoms (mkStdGen 0) might works after all...
06:27:04 <boegel> although I'm somewhat confused why it's return type isn't "IO"... I assume it's because of the StdGen that's being given to it?
06:27:54 <boegel> I could use
06:28:04 <boegel> genRandomEntity = randoms (mkStdGen 0)
06:28:21 <boegel> but that might get me into trouble, because that's an infinite list
06:28:28 <EvilTerran> it's not random, either
06:28:34 <boegel> EvilTerran: yeah, I know :)
06:28:48 <jatqceer> boegel: i believe it is the deterministic behavior of pseudo-random gen
06:28:58 <boegel> jatqceer: yeah, probably
06:29:05 <boegel> EvilTerran: any idea on how to tackle this?
06:29:27 <EvilTerran> well, you'll need to get a random seed in there somewhere
06:29:40 <EvilTerran> either by genRandomEntity taking a seed as a parameter, or being in IO, or similar
06:29:43 <boegel> EvilTerran: I could if I knew how long the list needs to be
06:29:57 <EvilTerran> and genRandomEntity doesn't know how long the list needs to be?
06:29:58 <Saizan> boegel: why?
06:30:02 <boegel> EvilTerran: then I could change the type of genRandomEntity to IO [Double], and just go
06:30:29 <Saizan> boegel: do seed <- newStdGen; return $ randoms seed
06:30:34 <boegel> genRandomEntity = replicateM n randomIO
06:31:02 <boegel> Saizan: ok, that would give me a truly random list of doubles, ok
06:31:16 <boegel> Saizan: but it still would be infinite, which is not what I want
06:31:36 <boegel> Saizan: it should be of a certain length, depending on the input the user gives on the command line of the tool
06:31:53 <EvilTerran> boegel, well, get the input on the command line, and pass it to genRandomEntity?
06:32:13 <boegel> EvilTerran: genRandomEntity is a member of a type class
06:32:33 <boegel> EvilTerran: so I can't pass arbitrary arguments too it, depending on the definition of the particular entity
06:32:38 <boegel> s/too/to
06:32:51 <EvilTerran> encode the length of the list in the GenAlg type?
06:32:53 <boegel> lemme see if I can hpaste something to make this more clear
06:33:15 <boegel> EvilTerran: the lenght of the list is dependent on what the user definition of the entity
06:33:37 <boegel> urgh, I should reread before hitting enter...
06:33:42 <EvilTerran> i think you're sunk
06:33:49 <boegel> @paste
06:33:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:33:53 <boegel> EvilTerran: sunk?
06:34:04 <EvilTerran> you're trying to get a value into a function without passing it as a parameter or using any kind of implicit state
06:34:23 <EvilTerran> that breaks referential transparency
06:35:55 <pozic> What is the correspondence between the 6.8 Arrow class and the new Arrow class + Category? Is there an Arrow class in 6.10 which is compatible with the 6.8 one?
06:36:11 <boegel> EvilTerran: well, I'm sure I'm into trouble, I'm just trying to figure out an elegant way to deal with it
06:37:29 <yitz> boegel: get the user definition and the random generator in the IO monad, then pass them as parameters to a pure function that generates your list of doubles
06:38:20 <boegel> yitz: but that won't allow me to define the genRandomEntity typeclass function, will it?
06:39:27 <yitz> boegel: why not? wait, don't answer that, let's see your paste.
06:39:51 <boegel> here's the paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3411#a3411
06:39:59 <PHO_> http://image.blog.livedoor.jp/blv42/imgs/b/b/bb242d38.png (not related to Haskell, but funny)
06:40:09 <boegel> I want to be able to define initGen generally, i.e. using genRandomEntity
06:40:49 <boegel> but I also want the genRandomEntity instance to create an entity with a list of doubles of certain length, depending on the input in the user-end tool
06:41:23 <boegel> PHO_: nice wallpaper ;-)
06:41:56 <yitz> boegel: so you need to allow input to the genRandomEntity function to allow that information to be passed in. What do you know about the type of that information?
06:42:16 <boegel> yitz: well, it's going to be Int, in this particular case
06:42:29 <yitz> boegel: in general?
06:42:35 <boegel> yitz: but, for another entity, it could be anything else (or maybe even multiple inputs)
06:43:13 <boegel> yitz: well, the input is going to be in the IO monad, if that's what you're aiming at...
06:43:21 * boegel has the feeling yitz is going somewhere with this
06:43:41 <yitz> boegel: could you define another method that returns that information for a given entity type?
06:43:51 <yitz> no, just fishing for leads
06:43:56 <boegel> yitz: k :)
06:43:58 <boegel> yitz: erm
06:44:13 <boegel> yitz: erm, I suppose I could
06:44:18 <boegel> yitz: in this case, length :)
06:45:00 <boegel> maybe I need to change the type of genRandomEntity to IO a -> e or something
06:45:01 <Saizan> maybe you don't want a typeclass at all for this..
06:45:06 <boegel> that would allow one input
06:45:13 <Saizan> a -> IO e
06:45:15 <yitz> boegel: is this a property that *every* GenAlg type will have?
06:45:19 <boegel> Saizan: err, yeah
06:45:35 <boegel> yitz: hmm
06:45:44 <boegel> yitz: the way I look at it, yes... I guess
06:46:08 <boegel> yitz: maybe I'm thinking too specific
06:46:22 <boegel> yitz: maybe having an infinite list isn't so bad after all
06:46:50 <boegel> yitz: I would just need to be careful what to do with it, keeping in mind that it might be infinite
06:47:23 <boegel> yitz: i.e. make the user functions aware of the input parameter 'n'
06:47:43 <boegel> yitz: and thus making them only use the first 'n' values of the infinite list that is an entity
06:49:12 * boegel 's head is spinning
06:49:18 * edwardk generalizes trie.
06:51:58 <boegel> Saizan: moving everything that is only specific to genetic algorithms in a seperate module, and using typeclasses to let the user define the function specific for his/her problem seems an ideal fit for typeclasses, no?
06:52:33 <Saizan> boegel: only if they are indexed by types and nothing else
06:52:38 <yitz> boegel: I would avoid an infinite list here probably.
06:52:40 <eu-prleu-peupeu> how do i multiply an Int with a Double ?
06:53:14 <yitz> boegel: perhaps you should leave genRandomEntity out of the class. Do the other methods need it?
06:53:21 <eu-prleu-peupeu> (and get a Double as a result)
06:53:23 <mc__> eu-prleu-peupeu: you dont
06:53:26 <wjt> eu-prleu-peupeu: fromIntegral
06:53:33 <eu-prleu-peupeu> thanks wjt
06:53:39 <yitz> @type fromIntegral
06:53:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:53:42 <wjt> > fromIntegral (3::Int) * (4.23::Double)
06:53:43 <lambdabot>   12.690000000000001
06:54:12 <boegel> yitz: no
06:54:42 <yitz> boegel: so just leave generating them as the responsibility of each user of the class.
06:55:03 <boegel> yitz: well, the other methods in the typeclass don't, but initGen, which is in the GA module, does need it
06:55:14 <yitz> boegel: perhaps they don't even need IO - they are using some mathematical simulation or something.
06:55:46 <boegel> yitz: well, traditionally, the first entities in a GA are randomly generates, no matter what you're doing
06:56:53 <boegel> yitz: I think I agree that getting the initialization stuff out of the typeclass is probably best
06:56:58 <boegel> thanks for your input guys :)
06:57:59 <yitz> boegel: how about genRandomEntity :: RandomGen g => g -> e
06:59:01 <yitz> boegel: oops -  genRandomEntity :: RandomGen g => g -> (e, g)
06:59:48 <yitz> boegel: or even class Random e => GenAlg e where ...
06:59:57 <boegel> yitz: hmm
07:00:15 <boegel> yitz: I think letting the user construct the initial generation himself woudl be better
07:00:26 <yitz> ok, makes sense
07:00:30 <boegel> yitz: I'd rather keep (almost) everthing strict in the GA module
07:00:52 <boegel> yitz: maybe the user wants to see what the GA gives with a non-random population to start from
07:00:57 <boegel> yitz: :)
07:01:04 <boegel> yitz: so, that should be possible too
07:01:10 <EvilTerran> separation of concerns; good idea
07:01:36 <boegel> EvilTerran: :)
07:01:56 <yitz> boegel: hope your head has stopped spinning
07:04:25 <boegel> yitz: it has
07:04:42 <boegel> thanks a lot for rewiring my brain
07:23:13 <vixey> :t \(a,mx) -> do x <- mx ; return (a,x)
07:23:14 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t, t1 t2) -> t1 (t, t2)
07:23:20 <vixey> every monad in haskell is strong then?
07:23:34 <Saizan> yup
07:23:55 <vixey> so I guess strength is really what (,) means then?
07:24:07 <vixey> it's about (,)
07:24:31 <Saizan> in other categories that's not true
07:24:46 <Saizan> (i think)
07:37:07 <marcot> Hello.  I have a lot of functions with the signature f :: MonadState Int m => m Bool, where Bool changes in the functions, and Int is constant.
07:38:23 <marcot> I'm trying to do type StateInt =  MonadState Int m => m, which leads me to a kind error.  Then I tried type StateInt value = MonadState Int m => m value.
07:39:07 <jfredett> marcot: I think you're just using the state monad wrong
07:39:19 <jfredett> the state monad is not intended to be invoked like a class
07:39:26 <jfredett> but rather as State s a
07:39:33 <vixey> @hoogle MonadState
07:39:33 <lambdabot> No results found
07:39:35 <jfredett> where s is the variable which is "statful"
07:39:43 <jfredett> in your case.
07:39:54 <jfredett> Int -> State Bool
07:39:59 <vixey> I think MonadState is like .. any monad transformer with state in it.. or something like that
07:40:28 <EvilTerran> any monad built from a transformer stack with a StateT in it (or State at the bottom)
07:40:28 <yitz> jfredett: I do what marcot is doing all the time. it is good technique
07:40:29 <jfredett> that is, int is a constant (given by a function variable, you could also you a ReaderT monad transformer, if it's _always_ the same for any function)
07:41:27 <yitz> jfredett: it allows you to change between State and StateT, or other monads that keep state, without having to rewrite all of your type signatures all the time.
07:41:42 <jfredett> yitz: I suppose if you want to deal with the added hassel of type constraints in the argument of a synonym, and you need all that extra functionality... but -- do you?
07:42:15 <jfredett> oh- I suppose you need type StateInt m = MonadState Int m => m in that sig to fix it though
07:42:28 <pozic> Does Cabal change anything with respect to the scope of symbols? I can load a module in ghci just fine, but with Cabal ghc complains that SomeException is not in scope? I imported Control.Exception, so it should be there.
07:43:17 <yitz> but yes, there's a problem with using type to abbreviate such things.
07:43:40 <doserj> pozic: what does the .cabal say aout build-depends?
07:43:41 <int-e> pozic: it may be using the wrong version of base.
07:44:02 <jfredett> you could probably use newtype + generalized deriving + deriving lots of things, thats what I did on my most recent use of MTs...
07:44:03 <Saizan> pozic: yeah, you need at least base >= 4 in .cabal's build-depends
07:44:04 <marcot> It worked, but when I try to redefine: instance MonadState Int m => MonadState Integer m as instace MonadState Integer StateInt, it says that StateInt should have 1 argument, but 0 was given.
07:44:15 <yitz> there's john meacham's class alias proposal for this, but after several years it still hasn't been implemented.
07:45:27 <marcot> yitz: thanks. =)
07:45:28 <jfredett> marcot: this is a parenthisis error, it should be instance MonadState Integer (StateInt a) -- I think
07:45:40 <EvilTerran> marcot, another possibility would be something contrived like "class State Int m => StateInt m | -> m; instance State Int m => StateInt m"
07:45:57 <jfredett> icky. fundeps.
07:46:08 <yitz> yeah
07:46:11 <EvilTerran> jfredett, fundeps with an empty LHS, at that :P
07:46:21 <marcot> EvilTerran: hum, this seems to be nice...
07:46:25 <jfredett> double icky.
07:46:44 <jfredett> EvilTerran: I just got finished with my first app w/ Assoc Typs
07:46:49 <jfredett> types*
07:46:52 <jfredett> they're awesome
07:46:55 <yitz> What I usually do is keep the MonadState Int m => part and just type alias the rest.
07:46:56 <marcot> EvilTerran: I didn't got the point of the empty LHS and the need of fundeps.
07:47:11 <jfredett> used them to implement an extensible "playing card alike" class. so awesome....
07:47:26 <EvilTerran> that'd be "f :: StateInt m => ... -> m ..."
07:48:26 <EvilTerran> actually, i don't think that fundep should be there. nvm.
07:48:57 <EvilTerran> that approach doesn't really save you anything, anyway. you just end up writing "f :: MonadState Int m => ... -> m ..." as "f :: StateInt m => ... -> m ..."
07:50:29 <marcot> In my case I think I'll stay with the old version and use the long option in classes.  There're much more functions that use it than classes, and in functions it works ok.
07:50:51 <marcot> And with your version I'd need to add a type constraint to the function, which is not so simple as the type alias.
07:50:57 <marcot> EvilTerran: but it was very good to know.  Thanks.
07:51:05 <marcot> Gotta go now. Bye.
08:00:44 <jeltsch> Is the community server down at the moment?
08:01:48 <jeltsch> Ping works, HTTP doesnâ€™t.
08:05:35 <bavardage> what is the proper type for representing a date and a time
08:09:09 <tromp_> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/Time.html
08:16:30 <bremner> so, couldn't guarded be replaced by an if in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2057
08:19:04 <int-e> @src guard
08:19:05 <lambdabot> guard True  =  return ()
08:19:05 <lambdabot> guard False =  mzero
08:19:16 <hcube> hi! I've question about binary usage. Is here anyone who has experiance with it?
08:19:41 <int-e> bremner: if needs an else. if foo then return (x,y) else mzero ... would work.
08:19:42 <bremner> int-e: are you saying there is some monadic tradition I'm missing?
08:19:49 <hcube> I meab binary library
08:19:51 <hcube> *mean
08:20:01 <Saizan> ?type guard
08:20:02 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:20:12 <Baughn> hcube: Just ask.
08:20:19 <Saizan> ?type mzero
08:20:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
08:20:42 <int-e> bremner: 'guarded' doesn't appeal to me, I'd use 'guard' instead.
08:20:55 <int-e> > do x <- [1..10]; guard (odd x); return x
08:20:56 <lambdabot>   [1,3,5,7,9]
08:20:56 <Saizan> ?type \b m -> guard b >> return m
08:20:57 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
08:21:06 <bremner> in the list monad I think it is clearer to write [] than mzero
08:21:17 <int-e> perhaps
08:21:17 <Saizan> ops, without return
08:21:27 <hcube> I'd like to parse a binary file what is consists of chunks and i dont know the number of chunks so i have to test the EOF. how can i do that?
08:21:30 <Saizan> ?type \b m -> guard b >> m
08:21:30 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
08:22:34 <bremner> int-e: It's an example from RWH, I guess they didn't want to introduce more machinery (i.e. use guard)
08:23:36 <bavardage> How do I convert a string to a Pico value
08:23:47 <bavardage> since Pico isn't an instance of read
08:24:34 <yitz> @hoogle Pico
08:24:34 <lambdabot> Data.Fixed type Pico = Fixed E12
08:24:34 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
08:27:09 <Saizan> > read "39.3" :: Rational
08:27:10 <lambdabot>   * Exception: Prelude.read: no parse
08:27:33 <mun> hi
08:27:59 <mun> does anyone know what the \ does in ( \  rEnv -> (libname, rEnv)) mEnv ?
08:28:00 <bavardage> I did it like fromIntegral (read string) :: Pico
08:28:43 <Saizan> uhm, that'd try to read the number as an Integer, i think
08:28:54 <BMeph> mun: It introduces an anonymous function.
08:28:55 <Saizan> so it'd fail if there's a decimal point in the string
08:29:13 <yitz> > 5 :: Pico
08:29:15 <lambdabot>   5.000000000000
08:29:35 <yitz> > 5.3 :: Pico
08:29:36 <lambdabot>   5.300000000000
08:29:40 <vixey> > 0.000000000001 :: Pico
08:29:41 <lambdabot>   0.000000000001
08:29:43 <vixey> > 0.0000000000001 :: Pico
08:29:45 <lambdabot>   0.000000000000
08:29:50 <vixey> @src Pico
08:29:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:30:04 <vixey> @info Pico
08:30:04 <lambdabot> Pico
08:30:08 <mun> BMeph: i see, but what does the function  rEnv -> (libname, rEnv) here do?
08:30:30 <yitz> > read "5" :: Pico
08:30:32 <lambdabot>       No instance for (Read Pico)
08:30:32 <lambdabot>        arising from a use of `read' at <int...
08:30:43 <BMeph> mun: You give it rEnv, it gives you back (libname, rEnv)
08:31:34 <ski> mun : `\rEnv -> (libname,rEnv)' is the function that accepts an argument, (locally) calls it `rEnv' and returns `(libname,rEnv)'
08:31:54 <yitz> > realToFrac(read "5" :: Int) :: Pico
08:31:55 <mun> ok thanks
08:31:56 <lambdabot>   5.000000000000
08:32:03 <ski> > (\rEnv -> (libname,rEnv)) 42  where libname = "foo"
08:32:04 <lambdabot>   ("foo",42)
08:32:16 <yitz> bavardage: so read it as some other numeric type, then convert it to a Pico using realToFrac
08:32:21 <yitz> @type realToFrac
08:32:23 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:33:07 <xenoblitz> hi guys just a question regarding terminology... when you do things like
08:33:07 <xenoblitz> instance (MyTypeClass a, MyTypeClass b) => MyTypeClass (a,b) where... is this called anything in particular? I came up with derived instances but I'm not sure its correct
08:33:41 <LeCamarade> opqdonut, Are you still there?
08:33:41 <yitz> subclass
08:33:52 <ski> (yitz : nope)
08:33:55 <LeCamarade> Oh, Piqued Donut.
08:34:12 <yitz> xenoblitz: the MyTypeClasses are all different, right?
08:34:30 <xenoblitz> In my case they are the same type class
08:35:03 <xenoblitz> yitz: imagine they are all called Composable or something like that
08:35:13 <LeCamarade> opqdonut, So, I've been reading, and I see that I'd only really need to invoke the Axiom of Choice on infinite sets. :o)
08:35:22 <xenoblitz> ï»¿instance (ï»¿Composable a, ï»¿Composable b) => ï»¿Composable (a,b) where...
08:35:27 <ski> i suppose one might call it a bounded polymorphic instance
08:35:39 <ski> i'm not aware of a standard term
08:35:47 <vixey> LeCamarade: is it true that choice is valid for omega, without the axiom?
08:35:55 <Eridius> in the paper Recycle Your Arrays! when it describes stream fusion it has a parameter to Stream called the "size hint", which the original stream fusion paper (Stream fusion: From lists to streams to nothing at all) doesn't have. Does anybody know where that came from?
08:36:07 <bavardage> yitz: ty :D
08:36:09 <xenoblitz> ski: thanks :)
08:36:24 <xenoblitz> yitz: thanks as well
08:37:03 <LeCamarade> vixey, I'll plead ignorance.
08:37:08 <LeCamarade> vixey, Where omega is ... ?
08:37:28 <ski> (omega is the sub-object classifier in a topos ..)
08:37:55 <ski> (.. though that's probably not the meaning vixey had in mind)
08:38:09 <LeCamarade> Gah. I'm animatedly dodging interest in topos, because I think it's just a fancy way to build sets, and therefore not enlightening. Am I wrong?
08:38:18 <Saizan> omega as in the ordinal, i think
08:39:01 <ski> LeCamarade : "build sets" meaning ?
08:39:14 <ski> (ZF-like theories ?)
08:43:00 <yitz> I think vixey meant the ordinal number omega
08:43:23 <yitz> oh Saizan :)
08:45:26 <LeCamarade> ski, I don't know. But choice is possible, without having to invoke the axiom, for all finite sets. (Even though the proof of this seems to be inherently rhetorical and tacitly just as non-constructive as one that would have invoked the axiom of choice.)
08:47:36 <ski> (hm .. i assume you're using classical logic ?)
08:48:33 <LeCamarade> Yes. Nothing higher-order.
08:48:41 <LeCamarade> I fear Godel's ghost.
08:48:49 <halberd> kolmogorov complexity is a basically untyped concept
08:49:26 <halberd> is there some useful way to unify kolmogorov complexity with a typed programming language?
08:49:27 <LeCamarade> halberd, complexity :: Kolmogorovable k => k -> KCompl
08:49:28 * ski was thinking classical as opposed to some constructive logics
08:49:53 * LeCamarade favours constructiveness.
08:50:21 * LeCamarade however will take non-constructiveness of the order of "it is contradictory that [...]".
08:50:58 <halberd> let's be more specific:  suppose that you have the shortest untyped program to generate a given output.  If you then annotate this program with types, what do the types tell you?
08:51:04 <codebliss> Hey guys.  I'm trying to write a mini lib for future reference for doing IRC operations  =)  It's based off of http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot .  I got http://haskell.pastebin.com/d8a764d9 and it won't compile.  I'd paste the errors, but It's probably due to me being a bit of a newbie.  Thanks  =)
08:51:14 <vixey> LeCamarade: not one word of that made sense
08:51:26 <codebliss> I'd love to see what I do/don't understand correctly.
08:52:04 <LeCamarade> vixey, Which sentence in particular? The one of "But choice is possible [...]"?
08:53:29 <tromp_> halberd, how do you annote a program that's just a big pile of combinators S and K ?
08:53:36 <tromp_> annotate
08:54:45 <halberd> you could annotate subexpressions
08:55:21 <ski> @type hPrintf
08:55:21 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
08:55:42 <BMeph> codebliss: A helpful hint: seeing the error messages would help to point out where/how you were being a newbie, assuming that you even were. Trust me - we won't judge you for having newbie errors in your code. Just if you try to pass off your errors as signs that the language itself is defective. :)
08:55:54 <ski> codebliss : the first argument to `sendCommand' possibly ought to have type `Handle', instead of `IO Handle' ?
08:56:20 <codebliss> Isn't IO Handle what you use for the monad?
08:56:25 <BMeph> codebliss: In other words, please include the error messages, it makes us feel warm and fuzzy. :)
08:56:27 <codebliss> I'll try that
08:56:34 <ski> (in any case, the first argument to `hPrintf' should have type `Handle', not `IO Handle')
08:57:19 <ski> codebliss : `IO ...' is "what you use for the *result* type for a monadic function"
08:57:23 <codebliss> Ugh I hate working in the windows console XD  1 sec guys thanks
08:57:25 <BMeph> codebliss: It also gives examples to throw at the GHC guys of where certain error messages should be rewrded to give better info. :)
08:57:45 <codebliss> Mkay.
08:58:28 <ski> codebliss : your current `sendCommand :: IO Handle -> ...' says that `sendCommand' takes as first argument not a `Handle' but an `IO'-action than, when *run*, will give a `Handle'
08:58:42 <vixey> @hoogle (Maybe a, Maybe a) -> Maybe (a,a)
08:58:42 <lambdabot> No results found
08:58:52 <ski> codebliss : if you just wanted to pass a `Handle', you should just do that
08:59:00 <codebliss>  Couldn't match expected type `Handle' against inferred type `IO b'  In a stmt of a 'do' expression:      handle <- connectTo server $ PortNumber $ fromIntegral port
08:59:05 <codebliss> Okay =)
08:59:26 <codebliss> I just wanted a function to wrap up the uglyness of one giant main
08:59:32 <ski> @type uncurry (liftA2 (,))
08:59:32 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
08:59:49 <vixey> @hoogle [a] -> Maybe (a,[a])
08:59:49 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
08:59:49 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
08:59:49 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:00:19 <vixey> @let uncons [] = Nothing ; uncons (x:xs) = Just (x, xs)
09:00:20 <lambdabot>  Defined.
09:01:13 <ski> codebliss : also, btw, iirc, you should not use `PortNumber' there
09:01:22 <codebliss> Okay.
09:02:06 <wli> What do you do if you need to bind to a specific port?
09:02:11 <codebliss> Couldn't match expected type `Handle' against inferred type `IO b' In a stmt of a 'do' expression:handle <- connectTo server $ PortNumber $ fromIntegral port
09:02:16 <ski> (i.e. `fromIntegral' should give a port number already .. istr getting wrong results if using the constructor directly)
09:02:26 <codebliss> kk
09:02:41 <wli> fromIntegral sounds like a good answer.
09:02:41 <ski> wli : either write a numeric literal of type `PortNumber', or use `fromIntegral'
09:03:21 <codebliss> Couldn't match expected type `Handle' against inferred type `IO b' In a stmt of a 'do' expression:     handle <- connectTo server $ fromIntegral port                         same error =(
09:03:31 <codebliss> I don't get what's wrong there is the problem
09:04:21 <ski> possibly that error is referring to another mistake in the code
09:04:37 <codebliss> first line of the function
09:04:44 <codebliss> after do
09:04:58 <ski> @type connectTo
09:04:59 <lambdabot> Not in scope: `connectTo'
09:05:05 <vixey> @djinn (Maybe (x, xxx), Maybe (y, yyy)) -> Maybe ((x,y), (xxx,yyy))
09:05:05 <lambdabot> f (a, b) =
09:05:05 <lambdabot>     case a of
09:05:05 <lambdabot>     Nothing -> Nothing
09:05:05 <lambdabot>     Just (c, d) -> case b of
09:05:06 <lambdabot>                    Nothing -> Nothing
09:05:08 <lambdabot>                    Just (e, f) -> Just ((c, e), (d, f))
09:05:14 <codebliss> import Network
09:05:22 <vixey> :t (,) *** (,)
09:05:23 <lambdabot> forall a b b' b1. (a, b') -> (b -> (a, b), b1 -> (b', b1))
09:05:27 <codebliss> @type Network.connectTo
09:05:28 <lambdabot> Network.Socket.HostName -> Network.PortID -> IO GHC.IOBase.Handle
09:05:35 <vixey> @hoogle (Maybe (x, xxx), Maybe (y, yyy)) -> Maybe ((x,y), (xxx,yyy))
09:05:35 <lambdabot> No results found
09:06:26 <vixey> ?djinn ((u,v),(x,y)) -> ((u,x),(v,y))
09:06:26 <lambdabot> f ((a, b), (c, d)) = ((a, c), (b, d))
09:06:31 <ski> @type (fst *** fst) &&& (snd *** snd)
09:06:32 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> ((a, a1), (b, b1))
09:06:49 <wjt> @type liftM2 (&&&) (fst *** fst) (snd *** snd)
09:06:50 <lambdabot>     No instance for (Arrow (,))
09:06:50 <lambdabot>       arising from a use of `&&&' at <interactive>:1:7-11
09:06:50 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:06:52 <wjt> aww :(
09:07:01 <vixey> :t fmap ((fst *** fst) &&& (snd *** snd)) . uncurry (liftA2 (,)) . uncons *** uncons
09:07:03 <lambdabot>     Couldn't match expected type `(f a, f b)'
09:07:03 <lambdabot>            against inferred type `Maybe (t, [t])'
09:07:03 <lambdabot>       Expected type: [t] -> (f a, f b)
09:08:03 <vixey> > curry (unfoldr (fmap ((fst *** fst) &&& (snd *** snd)) . uncurry (liftA2 (,)) . (uncons *** uncons))) "foooo" "barbaz"
09:08:04 <lambdabot>   [('f','b'),('o','a'),('o','r'),('o','b'),('o','a')]
09:08:29 <ski> codebliss : .. i don't see an error yet
09:08:55 <codebliss> I swore the code made sense, I thought maybe I learned something wrong XD
09:09:29 <codebliss> Maybe I should look at the lambdabot code and see if I understand anything
09:09:45 <ski> (.. except from the `IO Handle -> ...' i mentioned, i.e. .. maybe you introduced another error, or the error is in another part of the code ?)
09:09:53 <doserj> the code type-checks here after fixing the type-signature for sendCommand
09:10:09 <wjt> @djinn f :: a -> b -> c -> Maybe a -> Maybe b -> Maybe c
09:10:10 <lambdabot> Cannot parse command
09:10:16 <wjt> @djinn a -> b -> c -> Maybe a -> Maybe b -> Maybe c
09:10:16 <lambdabot> f _ _ a b c =
09:10:16 <lambdabot>     case b of
09:10:16 <lambdabot>     Nothing -> Nothing
09:10:16 <lambdabot>     Just _ -> case c of
09:10:16 <lambdabot>               Nothing -> Nothing
09:10:18 <lambdabot>               Just _ -> Just a
09:10:28 <wjt> @djinn (a -> b -> c){ -> Maybe a -> Maybe b -> Maybe c
09:10:29 <lambdabot> Cannot parse command
09:10:31 <wjt> @djinn (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
09:10:31 <lambdabot> f a b c =
09:10:32 <lambdabot>     case b of
09:10:32 <lambdabot>     Nothing -> Nothing
09:10:32 <lambdabot>     Just d -> case c of
09:10:32 <lambdabot>               Nothing -> Nothing
09:10:33 <lambdabot>               Just e -> Just (a d e)
09:10:34 <wjt> ah well.
09:10:41 * ski wonders how an `unfold'-based zip for trees would look like
09:10:43 <vixey> :t liftA2
09:10:43 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:11:17 <wjt> okay, you're a step ahead of me here :)
09:11:27 <codebliss> http://haskell.pastebin.com/d628c5b9a
09:12:31 <edwardk> @seen dons
09:12:32 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10h 53m 19s ago.
09:12:56 <ski> codebliss : oh !
09:13:05 <ski> i'm sorry, possibly i confused you
09:13:17 <codebliss> That's easy to do =)
09:13:26 <ski> you should not replace the `IO Handle' with `Handle' in the *result* type of those two functions
09:13:34 * edwardk returns to grinding on performance. time to figure out ghc perf stuff
09:13:39 <LeCamarade> Famished, sleep-deprived, tired, confused. Bye, #haskell.
09:13:48 <codebliss> LeCamarade: Good luck =)
09:14:17 <codebliss> K fixed back IO Handle
09:14:24 <codebliss> So what was the problem?
09:15:14 <ski> codebliss : *usually*, when you want a monadic operation, for a monad `M' (e.g. `IO'), you have argument types `A0',`A1',`A2',..., and you want to return a result of type `B'
09:15:25 <ski> so, the type signature you use then is
09:15:40 <ski>   myMonadicOperation :: A0 -> A1 -> A2 -> ... -> M B
09:16:08 <ski> i.e. only wrap the type of the monadic *results* with your `M' (in your case `IO')
09:16:58 <ski> (you can read `M B' as "the action that returns a value of type `B', and also does some side-effects described by `M')
09:17:09 <ski> codebliss : does that help any ?
09:17:26 <codebliss> Kind of.  I started this project after beginning to dig into monads.
09:17:33 <codebliss> Guess I didn't understand them well enough.
09:18:06 <Duqicnk> there are more people here than in the C or C++ rooms :D
09:18:11 <codebliss> I understand what you say with the type sig, but why is it erroring?
09:18:17 <codebliss> PS:  Screw c's =P
09:18:19 <ski> the specific problem in your code there was that with
09:18:21 <ski>   connectIRC :: String -> Int -> String -> Handle
09:18:31 <codebliss> I changed it back to IO Handle and it errors
09:18:37 <ski> you're saying that you'll return a `Handle' without possibly doing any `IO'
09:18:41 <codebliss> Somebody here told me to drop the IO
09:18:43 <BMeph> Duqicnk: ...and your point is? :)
09:19:06 <Duqicnk> haskell has finally surpassed C/C++ in popularity
09:19:08 <ski> the previous problem was with
09:19:12 <Duqicnk> :)
09:19:13 <ski>   sendCommand :: IO Handle -> String -> String -> IO ()
09:19:16 <yitz> @users
09:19:17 <lambdabot> Maximum users seen in #haskell: 658, currently: 605 (91.9%), active: 15 (2.5%)
09:19:53 <codebliss> sendCommand :: IO Handle -> String -> String -> IO () sendCommand handle command datas = do   hPrintf handle "%s %s\r\n" command datas -- ORIGINAL CODE
09:20:02 <codebliss> Hold on, re pastebinning lol
09:20:04 <ski> yes
09:20:07 <ski> codebliss : now that type signature *might* have been what you wanted .. in case you actually wanted to pass in an action that could be run (possibly many times) to get a `Handle'
09:20:59 <ski> so, what i was trying to say above was that, as a default rule, you only want to hang on an `IO' to the result type, not to the argument types, of a monadic operation
09:21:11 <codebliss> Ya of course.
09:21:56 <codebliss> Okay here's what I'm doing.  I have a main function that is basically a REPL irc bot.  I have a main function, and before I loop, I need to connect to the IRC.  I'm must making a function to make it not look as ugly and make it easier to maintain.
09:22:17 <ski> right
09:22:34 <codebliss> I'm going to need a handle later, which is why I'm having connectIRC return one
09:23:03 <codebliss> To save code space I'm going to remove the one that allows you to supply your name, it's just fluff.
09:23:33 <codebliss> Couldn't match expected type `Handle'         against inferred type `IO Handle'
09:23:37 <ski> why not remove the other one ?
09:23:42 <codebliss> sendCommand handle command datas = do   hPrintf handle "%s %s\r\n" command datas
09:23:59 <codebliss> Did =)
09:24:37 <doserj> why not remove all type signatures and let type-inference figure it out?
09:24:37 <codebliss> I have a do, so why is it not matching with the IO Handle return type?
09:24:38 <codebliss> ughjudgd
09:24:43 <codebliss> Sounds good
09:24:56 <ski> which type signature do you have for `sendCommand' currently ?
09:25:57 <codebliss> compiles after minor fix
09:26:16 <codebliss> -- sendCommand :: IO Handle -> String -> String -> IO ()
09:26:20 <codebliss> brb 1m
09:28:35 <ski> codebliss : i've been claiming (a few times) you probably want
09:28:39 <ski>   sendCommand :: Handle -> String -> String -> IO ()
09:28:43 <ski> instead
09:28:52 <codebliss> kk
09:29:14 <codebliss> Makes sense
09:29:52 <marko> hi all
09:30:13 <codebliss> Ahoy =)
09:30:44 <marko> I have a strange observation when using Takusen with PostgreSQL
09:30:47 <ski> codebliss : i'm not sure yet whether you understand why you want that (instead of, say, removing the other `IO' as well) .. but maybe for the moment you are satisfied with this (probably) being what you intended, as opposed to the *why*
09:32:02 <marko> When I run the GHC-compiled executable against the local PostgreSQL database, one specific operation  takes 30 seconds.
09:32:26 <marko> It contains some 59 selects that each take on average 0.46s
09:32:33 <codebliss> ski:  Getting over frustration helps before learning why =P
09:33:07 <codebliss> ski:  I'm the kind of person who has fun doing things, regardless of the outcome.  Just at the moment I need to get my head around monads first =P
09:33:15 <marko> when I capture all the SQL and run that SQL file against the db, it's very much quicker
09:33:25 <marko> haven't times it exactly
09:34:11 <ski> codebliss : it might help to first tackle just the `IO' monad, then looking at other ones ..
09:34:26 <marko> ok, timed it: 2 s for all the SQL commands/queries in the file
09:35:38 <marko> when I run the GHC-compiled executable postgresql goes up to 92% CPU and pretty much stays up there for the entire 30s
09:35:47 <codebliss> ski:  Will do
09:36:25 <marko> does anyone here have any experience that can help with Takusen, PostgreSQL?
09:39:17 <ski> (codebliss : just note that monads can be quite different, so specific things on how to handle `IO' might not carry over to other monads. monads is a fairly general pattern with diverse instances)
09:40:37 <ski> ( marko : probably. i don't have such experience, though ):
09:41:02 <marko> ski: PostgreSQL or Takusen?
09:41:32 <ski> yes
09:43:12 <marko> ski: I have a bottleneck somewhere: when I run the executable using Takusen, it's about 15 times as slow as when I run all the statements and queries from an SQL file
09:45:18 <Baughn> marko: Hackage documentation is broken, so I can't confirm it even /supports/ it, but.. how are you handling transactions?
09:46:00 <marko> Baughn: I'm not using transactions
09:46:05 <Baughn> marko: In particular, if you aren't, how does /Takusen/ handle transactions? If it's doing an fsync per statement, that would rather do it..
09:46:57 <marko> Baughn: an fsync per statement would rather do what? slow it down so much?
09:47:06 <Baughn> Rather, yes.
09:47:35 <marko> Baughn: can you explain how it would slow it down?
09:47:39 <Baughn> fsyncs are insanely slow. Unfortunately unix doesn't support what databases really /want/, so there's no way to get fast databases on unix
09:47:57 <Baughn> ..well, except do what Oracle does and bypass most of the OS
09:48:01 <cocon> how much space is needed to store a list of doubles?
09:48:12 <bremner> OS = filesystem ?
09:48:21 <Baughn> bremner: OS = API
09:48:47 <Baughn> Who cares about the filesystem, the API is what matters. Some filesystems even do support transactions, but if linux doesn't have a transaction api on the vfs...
09:48:58 <marko> Baughn: and feeding the file of SQL statements to psql circumvents this?
09:49:25 <Baughn> marko: Yes, since chances are it's executing them either as one big transaction or without ACID semantics entirely
09:49:39 <Baughn> marko: I don't know how Takusen handles that, so..
09:50:05 <Baughn> marko: But basically, on rotary disks, you're limited to 15-100 (depending on drive speed) /transactions/ a second
09:50:17 <Baughn> Each can be quite large without reducing that number any
09:50:47 <marko> Baughn: so surrounding my applications SQL interaction (all of it) with one transaction might speed it up, IIUYC?
09:50:51 <Saizan> Baughn: but that shouldn't produce a big CPU load, while marko is seeing 92%
09:51:00 <Baughn> ..and if we had a proper API in the OS, with at least exported write barriers, we'd easily get tens of thousands per seocnd
09:51:34 <Baughn> marko: I'd have to see the takusen documentation (which is down) to tell. Now, what's this about CPU use?
09:51:40 <Baughn> marko: Are you quite sure it's not io-wait?
09:52:21 <marko> Baughn: I can check again, but I remember %CPU...
09:52:42 <Baughn> marko: Run top, see what that says
09:53:16 <Baughn> marko: There should be a line breaking it down into parts - user time, system time, nice, and io-WAit
09:53:48 <marko> Baughn: 2576 pgsql     31    0  3860K 8964K CPU/1      0:04 95.52% 17.33% postgres
09:54:21 <marko> Baughn:   PID USERNAME PRI NICE   SIZE   RES STATE      TIME   WCPU    CPU COMMAND
09:54:24 <Baughn> marko: Well,that's weird
09:54:48 <marko> Baughn: that's why I came here ;-)
09:55:08 <Baughn> marko: It's only using 17.33% of your cpu time, mind you
09:55:21 <Baughn> The 95.52% number is without counting idle cycles
09:56:06 <Baughn> marko: Try "sudo strace -p `pidof postgres` -efsync"
09:56:19 <Baughn> marko: Or, hang on..
09:56:38 <Baughn> marko: "sudo strace -p `pidof postgres` -efsync,fdatasync"
09:56:50 <Baughn> marko: See how many lines you get from the script vs. using takusen
09:57:02 <marko> Baughn: sorry, no strace
09:57:10 <Baughn> ..well, install it
09:57:46 <marko> Baughn: this is NetBSD not Linux
09:57:57 <Baughn> marko: Umh. So dtrace, I suppose..
09:58:17 <Baughn> marko: I'm not really familiar with that, but you get the idea. Check for calls to fsync/fdatasync.
09:58:23 <wli> That could be different. I don't remember the semantics of WCPU.
09:58:26 <Baughn> marko: Though I should probably add msync to that
09:59:06 <marko> Baughn: guess ktrace should allow me to something like that, haven't needed it yet. Will check.
10:00:50 * Beelsebob ponders â€“ we have a FILO in [a], do we have a FIFO that's reasonably efficient though?
10:01:08 <wjt> Data.Sequence?
10:01:29 <Beelsebob> what about infinite ones?
10:02:16 <Baughn> Beelsebob: If it's already infinite, you won't need an append operation
10:02:32 <Baughn> And Data.Sequence, yes, but I suspect a straight functional queue would be faster
10:02:55 <Baughn> Same asymptotic efficiency, of course. ;)
10:02:57 <rabideejit> Hello.  I'm looking through the posix libraries, and can't find the equivalent of the c function "pipe".  Is there one but I am missing it, or is another function used instead to do similar things?
10:03:04 <Beelsebob> Baughn: I don't get your point there
10:03:16 <Beelsebob> oh, yes I do
10:03:26 <Beelsebob> but you do still need append
10:03:39 <Beelsebob> append infinitely many items onto a queue of finitely many
10:04:11 <Beelsebob> same way as it's useful to have a stack with infinitely many items on top of it to begin with, it's useful to have a queue that gets infinitely many items added at the end
10:04:11 <Baughn> Beelsebob: Oh, and keep in mind that (++) is O(1) when used as a thunk
10:04:26 <Beelsebob> Baughn: yeh, but last isn't
10:04:34 <Beelsebob> nor reverse
10:05:41 <poucet> Grr haxr-3000 won't build :|
10:05:44 <rabideejit> Hmm. Still can't find "pipe".  I'll have to write a binding.  You'd think it would be in there.
10:06:44 <yitz> rabideejit: look in System.Process for various portable variations
10:07:01 <yitz> rabideejit: are you looking for a direct binding to Posix pipe?
10:07:51 <Baughn> rabideejit: Bear in mind that GHC is really very bad at closing FDs when you runCommand or whatever, which is bound to cause trouble if you aren't careful
10:08:21 <rabideejit> yitz: yeah, I need a more low level interface than available in System.Process.
10:09:12 <rabideejit> Baughn: That might be a problem; I'm relying a child process inheriting its parent's file descriptors.
10:09:29 <Baughn> rabideejit: That's no problem, then
10:09:34 <Baughn> The problem is in /avoiding/ inheritance
10:10:27 <rabideejit> Should work then.  I'll go write a binding to pipe and experiment.
10:10:51 <marko> Baughn: I checked for fsync/msync/fdatasync: they are not called.
10:12:12 <Baughn> marko: Beats me, then. You might try sending an email to the maintainer.
10:12:20 <yitz> rabideejit: System.Posix.IO.createPipe
10:13:36 <marko> Baughn: I have pasted the frequency of the function calls here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2058#a2058
10:14:10 <Baughn> Nope, nothing obvious there
10:14:10 <marko> Baughn: in the past maintainers have been difficult to get to communicate...
10:15:07 <arjanb> is c.h.o down again?
10:16:01 <marko> Baughn: thanks for your comments, even though the problem isn't solved yet they were very helpful!
10:16:20 <marko> Baughn: I'll continue digging...
10:21:41 <mmorrow> edwardk: re: Data.SetUnboxed: (after very minimal messing around and having looked at IntSet), i wonder what it would take for (USet Int) to be as fast as IntSet, and also (Uset Foo) to be as fast as FooSet (where FooSet:::Foo : IntSet:::Int)
10:22:22 <mmorrow> edwardk: i wonder if that's possible with the class dictionary
10:29:04 <HairyDude> I have a strange type error involving associated type synonyms: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3421#a3421
10:31:52 * BMeph is disappointed that one of his projects needs value-indexed types
10:32:17 <vixey> BMeph, ooh cool what is it ?
10:32:19 * HairyDude wonders if associated newtypes would be better
10:32:36 <HairyDude> ah, no such thing.
10:32:48 <vixey> HairyDude: what's the Fun d => for?
10:33:08 <HairyDude> aaaand the error goes away if I replace "type" with "data"
10:33:23 <HairyDude> vixey: erm, because otherwise it couldn't use abst and appl?
10:34:00 <Saizan> HairyDude: i think the problem is that memo_fmap has no argument of type 'd'
10:34:12 <vixey> you can use abst and appl if Memo is a type,
10:34:19 <vixey> you do need the constraint if Memo is data
10:34:20 <HairyDude> ah
10:34:53 <vixey> actually that's wrong
10:35:14 <Saizan> :t appl will have the Fun d => part
10:35:15 <lambdabot> parse error on input `=>'
10:35:49 <HairyDude> well I get exactly the same errors without the Fun => so I suppose it's not needed
10:36:20 <Saizan> HairyDude: btw, did you see http://hackage.haskell.org/packages/archive/MemoTrie/0.4.3/doc/html/Data-MemoTrie.html ?
10:36:24 <mmorrow> HairyDude: this works: (don't ask me why :))
10:36:28 <mmorrow> memo_fmap :: forall a b d. Fun d => (a -> b) -> Memo d a -> Memo d b
10:36:28 <mmorrow> memo_fmap f x = abst (f . (appl :: Memo d a -> d -> a) x)
10:36:55 <mmorrow> (both the "forall .." and the annotation on `appl' are needed on my 6.10.2
10:36:56 <mmorrow> )
10:37:13 <Saizan> and ScopedTypeVariables
10:37:39 <mmorrow> yeah, i have -fglasgow-exts on in my .ghci
10:38:25 <vixey> I guess BMeph is sworn to secrecy
10:38:25 <mmorrow> also amusingly, without the typesig it does fine with no annotation
10:38:40 <HairyDude> hmm, I get "parse error on input `=>'"
10:38:51 <Saizan> and it infers the correct type?
10:38:57 <mmorrow> Saizan: yeah :/
10:38:58 <Gilly> Suppose I have a socket and read it in a lazy ByteString using getContents. If I request one character from the socket, does the corresponding read() syscall also try to read just that one character? That is, if I continue doing this do I get a good bunch of read()s?
10:39:03 <BMeph> vixey: Those ring types, Z[i] (Gaussians), Z[sqrt(3)/2] (Eisenstein no.), Z[sqrt(n)], and such.
10:39:05 <HairyDude> mmorrow: ah, with the foralls I suspect it's using scoped typevars
10:39:21 <BMeph> vixey: ;p
10:39:35 <mmorrow> HairyDude: yes
10:39:53 <BMeph> vixey: Also, Q[] of those ones as well.
10:40:18 <HairyDude> in fact, it compiles with -XScopedTypeVariables but not without, so that must be the case.
10:40:19 <wli> Z[(-3)^(1/2)/2] you mean? Eisenstein integers are a cyclotomic extension ring of Z.
10:40:27 <vixey> I'd not even heard of Eisenstein Integers
10:41:03 <mmorrow> HairyDude: you mean with the extra annotation or as you originally had it?
10:41:16 <HairyDude> mmorrow: with the extra annotation
10:41:22 <wli> vixey: Instead of a square root of -1 (4th root of unity) it extends Z by a cube root of unity.
10:41:35 <mmorrow> ahh, ok :) i was confused for a second there
10:41:53 <wli> vixey: x^2+1 vs. x^2+x+1 as polynomial ideal generators.
10:42:13 <wli> Or minimal polynomials or whatever.
10:42:24 <HairyDude> now let's see if I can write a Functor instance for that
10:42:32 <mmorrow> HairyDude: i tried :(
10:42:48 <mmorrow> Illegal type synonym family application in instance: Memo d
10:42:48 <mmorrow>     In the instance declaration for `Functor (Memo d)'
10:44:21 <wli> vixey: So ultimately they're extensions of the same degree, albeit with somewhat different structure.
10:45:10 * HairyDude notices his ghc is 6.8
10:45:52 <wli> 5th roots of unity have degree 4 IIRC.
10:48:13 <HairyDude> seems to me ghc ought to be able to infer the type for appl with no trouble
10:48:21 <mmorrow> HairyDude: it works if you wrap Memo in a data though
10:48:58 <mmorrow> HairyDude: yeah me too. it seems to be able to infer it with to sig on memo_fmap, but somehow the sig confuses it
10:49:18 <wli> x^6-1 = (x^3+1)*(x^3-1) = ((x+1)*(x^2-x+1))*((x-1)*(x^2+x+1)) or some such, rendering 6th roots quartic. I don't know of any roots of unity of degree 3 over Q.
10:50:35 <mmorrow> HairyDude: *... with _no_ sig on ...
10:51:20 <wli> I'll bet there's a (real?) quadratic extension over which 7th roots of unity have degree 3.
10:51:21 <HairyDude> it infers appl has type Memo d a -> d -> a for some d, call it d1. then fails to unify d = d1, which it should be able to do because I apply x to it, and x unambiguously has type Memo d a
10:52:10 <HairyDude> apply it to x even
10:54:23 <mmorrow> HairyDude: yeah, this looks like a bug to me
10:54:59 <mmorrow> well, bug might be a strong word for this, but whatever it's called it's that :)
10:56:04 <HairyDude> think I'll ask the cafe
10:56:52 <Saizan> i fear it's more like an infelicity of the type system.. but i'm not that familiar with type families
10:57:50 <mmorrow> Saizan: maybe some weird interaction with some heuristic(s) could also be what's happening
11:00:47 <BMeph> wli: So is that the official name for that Z (or Q)[<insert some square root here>] form, a "cyclotomic extension ring"?
11:01:16 <wli> BMeph: Cyclotomic extensions are extensions by roots of unity.
11:02:25 <mmorrow> BMeph: a ring extension
11:03:12 <mmorrow> +just
11:04:04 <BMeph> Ah, so cyclotomic refers to the extension's unity?
11:06:44 <yitz> wli: yes. 7th root of 1 have degree six, and the galois group is cyclic. so there are intermediate fields of degree both 2 and 3.
11:08:34 <wli> yitz: The question is whether there's a real intermediate field of degree 2.
11:08:55 <yitz> oh, real. hmm.
11:12:26 <wli> There's basically a partition into two sums of 3 seventh roots and find their sum and product.
11:13:09 <wli> I think the sum ends up 0 and the product is a pain.
11:13:35 <wli> Or maybe the sum is -1.
11:14:42 <wli> It doesn't matter how you break it up for the sum but the product needs the right answer in terms of automorphisms or something.
11:18:27 <BMeph> wli: Think it would be "cheating" to "sneak" Gaussians in by using Complex Rational? ;)
11:23:55 <pmurias> is there a way to enable profiling on all installed libraries?
11:25:08 <Nafai> pmurias: You have to re-install them all.  Edit your ~/.cabal/config and uncomment the line that says library-profiling and change it to True
11:25:26 <Nafai> pmurias: And then just do cabal --reinstall install each of the cabal-installed libraries
11:26:41 <pmurias> i don't have such a commented line in .cabal/config
11:27:48 <pmurias> Nafai: why is the option turned off by default?
11:34:40 <Nafai> pmurias: I don't know.  THat's just what I had to do on my system
11:37:52 <DARYOUSH> I tried to install a pacakge via cabal install over the network, it failed.  Then I downloaded the tar file from HackageDB and want to run cabal install on my downloaded version.
11:38:08 <DARYOUSH> Now cabal says ".cabal has been changed, please re-configure."
11:38:18 <DARYOUSH> what does that mean? how do you re-configure?
11:39:16 <BMeph> DARYOUSH: 'cabal configure'. :)
11:40:29 <mmorrow> @unmtl ContT r (State s) a
11:40:29 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
11:40:30 <DARYOUSH> I did cabal clean, cabal configure but when I do cabal install I get the same thing
11:40:40 <mmorrow> @unmtl StateT s (Cont r) a
11:40:40 <lambdabot> s -> (a -> s -> r) -> r
11:41:16 <lpsmith> Sweet.  unmtl is the best command I've ever seen.
11:43:32 <FunctorSalad> is it new?
11:44:02 <BMeph> DARYOUSH: Please try "cabal build" in between the "configure" and the "install".
11:44:19 <BMeph> FunctorSalad: ...and Improved! ;)
11:44:22 * FunctorSalad thought there wasn't anyone left who understands or can build lambabot ;)
11:44:53 <FunctorSalad> @version
11:44:54 <lambdabot> lambdabot 4.2.2
11:44:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:45:28 <amaron> lets say I have StateT wrapped over IO, and inside my StateT action I have some IO action called with liftIO someIO. How can I modify state (with put) inside that 'someIO'?
11:46:11 <lpsmith> FunctorSalad:  I dunno, it's new to me.   Then again,  I don't hang out here much.
11:47:07 <DARYOUSH> I tried cabal configure, then cabal build,  still the same thing   it says I need to reconfigure.   Does cabal keep a state on a packaged that I tried to down load that I can delete>
11:47:17 <lpsmith> amaron:  I don't think you can
11:47:49 <lpsmith> Although there is surely a better way to do things...
11:48:34 <lpsmith> For starters,  I wouldn't use StateT,   I would use IORefs and then maybe implement my own get and put if I really want to use the typeclass interface
11:48:44 <FunctorSalad> DARYOUSH: not sure but you can always unpack a fresh copy to the current dir with "cabal unpack <package>"
11:50:11 <amaron> lpsmith: thanks, I'll try to figure out how to do it...
11:52:36 <lpsmith> amaron:  well, feel free to ask again if you feel a bit stuck.  But you'll probably find the use of IORefs to be a bit faster
11:53:30 <amaron> lpsmith: I've just got all to work with StateT except that part, about 500 lines of code, now I have to modify all
11:53:54 <FunctorSalad> @unmtl StateT s IO a
11:53:54 <lambdabot> s -> IO (a, s)
11:53:59 <lpsmith> amaron:  no you don't
11:54:09 <lpsmith> Implement your own get and put
11:54:20 <lpsmith> The changes should be localized entirely to the Monad :-)
11:54:35 <EvilTerran> amaron, surely you could push the liftIO through the someIO so that you can do get and put between liftIO'd parts?
11:54:40 <lpsmith> I did that for HPDF,  I sped up one of it's monads by quite a bit.
11:54:50 <DARYOUSH> i don't have cabal unpack, I am downloading the tar.gz file and trying to run cabal install in my downloaded directory
11:55:00 <FunctorSalad> amaron: maybe I'm missing something, but I think liftIO lifts a "pure" IO action (that doesn't use the state) into the enclosing StateT
11:55:28 <FunctorSalad> (it's similar to return but from one monad to a transformed monad)
11:55:54 <lpsmith> FunctorSalad: indeed
11:55:57 <FunctorSalad> of course "pure IO action" is a bit of a contradiction in terms, I mean pure with regards with the StateT
11:56:14 <mmorrow> > flip runCont id (flip runStateT 0 (callCC (\k -> put 1 >> k 42 >> return 99)))
11:56:15 <lambdabot>   (42,1)
11:56:16 <mmorrow> , runCont id (runStateT 0 (callCC (\k -> set 1 >> k 42 >> return 99)))
11:56:17 <lunabot>  (42,0)
11:56:32 <mmorrow> (mtl vs. monadLib)
11:56:57 <FunctorSalad> amaron: in other words, the code that needs to "put" must return a StateT s IO a, not an IO a
11:57:49 <mmorrow> hmmm, i think both could be useful (state rollback or not)
11:57:51 <amaron> perhaps I'm doing all wrong, I'm playing with gtk2hs, and I'm trying to keep my treeview state within some events
11:57:58 <stulli> @instances Applicative
11:57:59 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:58:08 <stulli> @instances Functor
11:58:09 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:58:43 <FunctorSalad> amaron: ah, I suppose it is a problem with callbacks that expect to call an "IO a"
11:59:00 <FunctorSalad> in that case I think you do need IORefs
11:59:07 <FunctorSalad> (?)
11:59:19 <amaron> FunctorSalad: yes, in this case its IO ()
11:59:37 <EvilTerran> in that case, yeah, you'll need IORefs
11:59:55 <phercek> when building ghc from source a file rts/HSrts.o is created; what is it created from? ... or how is it created?
12:00:55 <hcube> hi! how can i serialize a Ptr Float with binary library?
12:01:07 <hcube> *Ptr Float's content
12:01:29 <amaron> huh, I dont know why I like this haskell so much, it gives me so much headaches,... I'm going back to fix the code with minimal changes
12:02:03 <amaron> StateT was so logical choice at the start...
12:02:05 <FunctorSalad> amaron: low-level interfaces to UI stuff are a bit of a weak point I guess
12:02:30 <lpsmith> Haskell gives me headaches often.   I love it because of that.
12:02:39 <FunctorSalad> amaron: I ran into related complications with OpenGL functions expecting IO
12:03:05 <EvilTerran> you could probably write a function :: MonadIO m => IORef s -> StateT s m a -> m a
12:03:13 <FunctorSalad> amaron: I used a "ReaderT AppState IO" monad, with AppState containing IORefs instead
12:03:27 <lpsmith> They are good headaches though,  not headaches over some inane tripe.    And you won't get them as often over time,  but they still happen.
12:04:54 <amaron> FunctorSalad: ah, great, ReaderT should do the work, just s/get/asks/ in code, and IORef with part I wanna change
12:05:46 <amaron> but when I think of it, I dont have to remove StateT at all
12:05:58 <FunctorSalad> amaron: of course the callback still needs to be IO, but it can be a closure that knows the IORef
12:06:02 <amaron> when I have it allready...
12:06:53 <lpsmith> amaron:  You can also take FunctorSalad's suggestion and implement your own get and put without using StateT
12:07:10 <lpsmith> so that should mean almost no changes to your client code
12:07:47 <lpsmith> So you are removing it,  but your client code doesn't need to be aware of the change
12:13:46 <trofi> where can i get list of supported arches by ghc?
12:15:00 <kaol> trofi: http://hackage.haskell.org/trac/ghc/wiki/Platforms
12:15:06 <trofi> thanks
12:15:45 <orzo> is -keep-hc-files incompatible with --make?
12:16:16 <pumpkin> no
12:16:19 <Eridius> huh, there's an entire column "Dyn libs" on http://hackage.haskell.org/trac/ghc/wiki/Platforms of which only one entry has a Yes (powerpc-apple-darwin)
12:16:24 <pumpkin> but -fvia-C is needed
12:18:14 <Eridius> interesting that only one platform supports producing dynamic libraries
12:18:24 <amaron> lpsmith: I've done it with IORef, I have no idea how to rewrite get and put in context of all of this. Just to check if it works properly...
12:21:26 <FunctorSalad> @type readIORef
12:21:26 <lambdabot> Not in scope: `readIORef'
12:22:15 <FunctorSalad> amaron: gets foo = do { ref <- asks foo; readIORef ref }
12:22:28 <FunctorSalad> (assuming youre using "gets" already anyway)
12:22:30 <orzo> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3422#a3422
12:22:39 <orzo> pumpkin: what's wrong theree? i can't find any generated hc files
12:23:24 <amaron> FunctorSalad: ah, so simple
12:23:49 <pumpkin> orzo: does everything need rebuilding?
12:23:59 <pumpkin> orzo: if the products are already there, it won't bother rebuilding it
12:24:06 <pumpkin> orzo: -fforce-recomp
12:24:08 <EvilTerran> FunctorSalad, and then, when you need an (IO a) in particular (and not a (ReaderT (IORef Whatever) IO a)), use runReaderT?
12:24:41 <FunctorSalad> EvilTerran: yes, I did it that way. I just hope the "runReaderT" gets eliminated by ghc
12:25:43 <orzo> pumpkin: thanks, that worked
12:25:45 <FunctorSalad> (since I adapted "renderPrimitive" and "preservingMatrix" for ReaderT IO that way ;))
12:32:25 <duckinator> hi
12:34:27 <Eridius> FunctorSalad: ReaderT is a newtype. This means it only exists at the type level. It has no runtime representation
12:34:28 <harovali> hi,  why does this "map (Just ) [1,2,3]"  work and not this "map (\n -> (return n :: Just )) [1,2,3]"
12:34:43 <Eridius> harovali: because Just is a constructor, not a type
12:34:46 <vixey> harovali: because Just isn't a type
12:34:47 <Eridius> (return n :: Just) doesn't make sense
12:34:54 <pumpkin> harovali: return n :: Maybe Int
12:34:55 <harovali> thanks
12:35:28 <EvilTerran> harovali, or, say, map (return :: a -> Maybe a) [1,2,3]
12:35:37 <FunctorSalad> Eridius: good point, though one could still help that the wrapped function call itself is avoided too
12:35:48 <FunctorSalad> s/help/hope :/
12:36:13 <harovali> how can I make something like this to work "map (\n -> (return n :: Maybe Int )) [1,2,3,'a']" ?
12:36:43 <Eridius> harovali: you can't
12:36:45 <vixey> harovali: impossible
12:36:48 <Eridius> [1,2,3,'a'] is invalid
12:36:58 <FunctorSalad> Eridius: (since if the Reader environment never changes, it could just become a sort of global variable)
12:37:08 <EvilTerran> harovali, every item in a list has to be the same type
12:37:11 <harovali> i understand
12:37:32 <pumpkin> unless you define a Num instance for Char
12:37:41 <dmhouse> Which you don't want to do.
12:37:42 <EvilTerran> ?type [Left 1, Left 2, Left 3, Right 'a'] -- harovali, there's a few ways of approximating it, though
12:37:43 <lambdabot> forall t. (Num t) => [Either t Char]
12:38:16 <FunctorSalad> . o O ( or a IsString instance for Either Int String? evil )
12:38:28 <FunctorSalad> but I don't know if that overloads char notation too
12:38:35 <EvilTerran> i don't think it does
12:38:42 <Eridius> IsString? o_O never heard of it
12:38:59 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-String.html
12:39:03 <harovali> EvilTerran: thanks, interesting
12:39:15 <FunctorSalad> Eridius: it lets string literals be interpreted as type IsString a => a :D
12:39:21 <EvilTerran> there's no fromChar, though
12:39:24 <Eridius> EvilTerran: I found that with hoogle, now I'm trying to find docs on -foverloaded-srings
12:39:36 <Eridius> ah hah, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
12:39:40 <FunctorSalad> Eridius: bit me in the behind quickly since it made something compile that ought to have failed ;)
12:39:44 <Eridius> hah
12:49:07 <HairyDude> jaunty will have 6.8 still... sigh
12:50:05 <sannysanoff> HairyDude, use arch :)
12:50:34 <HairyDude> nah, there's a PPA with 6.10, much easier :)
12:51:34 <sannysanoff> HairyDude, while using ubuntu, I always did just plain install (downloaded ghc from haskell.org)
12:52:31 <wolverian> there's at least one PPA with 6.10
12:52:37 <wolverian> and you might be able to use the debian packages
12:54:14 <amaron> FunctorSalad: this all works now with minimal changes :). And now I have a strategy to handle global state in event callbacks. Thank you!
12:54:35 <amaron> and thank you all for your insights in StateT, ReaderT, IORefs... :)
12:55:24 <b_jonas> hi
12:56:11 <vixey> hi!
12:56:56 <pumpkin> nice, we already have spam on the haskell platform list
12:58:23 <HairyDude> oh, the PPA doesn't contain 6.10 versions of a load of packages I use
12:58:32 <HairyDude> living on the bleeding edge is darned inconvenient :)
13:01:43 <orzo> ppa?
13:03:27 <bremner> orzo: ubuntu thing
13:04:19 <bremner> HairyDude: now is the time to install Debian unstable :-)
13:04:34 <bremner> or arch, apparently
13:04:38 <HairyDude> bremner: I have thought that several times :)
13:04:38 <bremner> or gentoo
13:05:09 <HairyDude> I shy away from gentoo, looks like it involves too much hacking, and moreover, waiting for things to build
13:05:18 <bremner> ack
13:05:23 <SubStack> good reasons
13:06:02 <bremner> I run debian unstable,  but it is not for everyone.  Maybe sidux is nice
13:07:55 <HairyDude> erm, so what is arch? do you mean Arch Linux or something else?
13:08:38 <bremner> yeah, some people on this channel are big arch linux promoters
13:09:09 <FunctorSalad> why is it called like that?
13:09:31 * bremner looks significantly at dons
13:09:42 <FunctorSalad> in analogy to archangels etc?
13:09:56 <FunctorSalad> (the most powerful linux)
13:10:15 * EvilTerran was thinking the etymology passed through "architecture" somewhere along the way
13:12:28 <HairyDude> think they were referring to arch-buildpackage actually, i.e. GNU Arch
13:12:54 <bremner> grep '^arch' /usr/share/dict/words | wc -l
13:12:56 <bremner> 73
13:13:42 <bremner> archenemy being my favourite guess
13:16:12 <FunctorSalad> arch (adj.)  1547, "chief, principal," from prefix arch- (from Gk. arkhos "chief;" see archon); used in 12c. archangel, etc., but extended to so many derogatory uses (arch-rogue, arch-knave, etc.) that it acquired a meaning of "roguish, mischievous," since softened to "saucy" (1662). Also found in archwife (c.1386) "A wife of a superior order."
13:16:29 <pumpkin> mmm, an archwife :o
13:16:34 <FunctorSalad> :)
13:17:45 <FunctorSalad> there's a seperate entry for the "arch of a bridge" meaning though, as EvilTerran suggested
13:21:23 <jatqceer> how do I make readline load libncursesw.so instead of libncurses.so?
13:22:04 <jatqceer> because in my system, the file /usr/lib/libncurses.so only contains a line with "INPUT(-lncursesw)"
13:22:13 <iesahin> hi all, is there a quick idiom to get random numbers in a pure function via passing Random.StdGen?
13:22:27 <EvilTerran> ?type randoms
13:22:28 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
13:22:37 <jatqceer> readline doesn't like it "Loading package readline-1.0.1.0 ... can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)"
13:22:37 <EvilTerran> might suit
13:22:41 <iesahin> thanks
13:22:54 <EvilTerran> it varies depending on situation which function from Random is most appropriate
13:23:20 <EvilTerran> ?docs System.Random
13:23:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
13:23:30 <iesahin> i need to call a function with different params, but lazy to get back StdGen each time
13:23:44 <iesahin> this is my first experience with random stuff in haskell
13:23:55 <iesahin> i read the docs
13:23:58 <EvilTerran> *ahem* that should be http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
13:24:23 <FunctorSalad> iesahin: does it really have to be pure? I think randomness is a pretty good fit to monads
13:24:46 <FunctorSalad> iesahin: there are some randomness monads on hackage, e.g. the monte-carlo package
13:25:25 <iesahin> FunctorSalad: sure, but mine is a single function and i want to keep things as simple (and pure) as possible
13:25:58 <iesahin> i use a StdGen created in main and retrieve it back from the function
13:28:45 <vixey> any new .. stuff out about dependent typed programming ?
13:31:06 <mmorrow> just found this in a quicky google search, someone else may find it handay too http://www.wangz.net/cgi-bin/pp/gsqlparser/sqlpp/sqlformat.tpl
13:31:55 <Apocalisp> Does lambdabot have a list-comprehension desugarisation feature?
13:33:24 <Gracenotes> yes, but it completely undoes it, iirc
13:33:37 <Deewiant> @undo [ x | x <- [1..10] ]
13:33:38 <lambdabot> concatMap (\ x -> [x]) [1 .. 10]
13:34:08 <Gracenotes> @undo [ (a, b) | a <- xs, b <- ys, a > b ]
13:34:08 <lambdabot> concatMap (\ a -> concatMap (\ b -> if a > b then [(a, b)] else []) ys) xs
13:34:50 <Gracenotes> @undo [ a | a <- xs, let {a' = a+3}, even a' ]
13:34:50 <lambdabot> concatMap (\ a -> let { a' = a + 3} in if even a' then [a] else []) xs
13:35:15 <Apocalisp> @type concatMap (\ x -> [x]) [1 .. 10]
13:35:16 <lambdabot> forall a. (Enum a, Num a) => [a]
13:35:43 <Gracenotes> hm. I thought it used the list monad directly. Substituting the list monad source, that should be what you get
13:36:05 <vixey> that is what it does
13:36:18 <Apocalisp> @undo selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]
13:36:18 <lambdabot> selections (x : xs) = (x, xs) : concatMap (\ (y, ys) -> [(y, x : ys)]) selections xs
13:36:26 <Apocalisp> @. undo type selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]
13:36:27 <lambdabot>  Parse error at "='
13:36:27 <lambdabot>  
13:36:27 <lambdabot> " (column 23)
13:36:31 <Gracenotes> in the second example, that's also do {  a <- xs; b <- ys; guard (a>b); return (a,b) }
13:36:38 <Apocalisp> @. type undo selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]
13:36:39 <lambdabot> parse error on input `='
13:36:43 <Apocalisp> grr
13:36:56 <Apocalisp> @type selections (x : xs) = (x, xs) : concatMap (\ (y, ys) -> [(y, x : ys)]) selections xs
13:36:57 <lambdabot> parse error on input `='
13:37:04 <Gracenotes> @. type undo let selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs] in selections
13:37:05 <lambdabot>     Couldn't match expected type `[(t1, [t])]'
13:37:05 <lambdabot>            against inferred type `[t] -> t2'
13:37:05 <lambdabot>     In the second argument of `concatMap', namely `selections'
13:37:50 <Apocalisp> something is not quite right
13:38:02 <Deewiant> @type let selections (x : xs) = (x, xs) : concatMap (\ (y, ys) -> [(y, x : ys)]) (selections xs) in selections
13:38:03 <lambdabot> forall t. [t] -> [(t, [t])]
13:38:22 <Apocalisp> @type let selections (x : xs) = (x, xs) : concatMap (\ (y, ys) -> [(y, x : ys)]) selections xs in selections
13:38:23 <lambdabot>     Couldn't match expected type `[(t1, [t])]'
13:38:23 <lambdabot>            against inferred type `[t] -> t2'
13:38:23 <lambdabot>     In the second argument of `concatMap', namely `selections'
13:38:38 <Deewiant> Apocalisp: Needs more brackets
13:38:57 <Gracenotes> interesting, undo doesn't add the parens by default
13:39:14 <Apocalisp> oh, parens!
13:39:31 <Gracenotes> @undo [ x | x <- f ys ]
13:39:31 <lambdabot> concatMap (\ x -> [x]) f ys
13:39:32 <vixey> :t select [] = [] ; select (x:xs) = (x,xs) : map (id *** (x:)) (select xs)
13:39:33 <lambdabot> parse error on input `='
13:39:39 <vixey> :t let select [] = [] ; select (x:xs) = (x,xs) : map (id *** (x:)) (select xs) in select
13:39:40 <lambdabot> forall b. [b] -> [(b, [b])]
13:40:50 <Deewiant> second = (id ***)
13:41:19 <pumpkin> edwardk: oh my, more and more structures creeping into your monoids package :P now we have fields!
13:41:27 <pumpkin> and rings!
13:41:28 <vixey> :t let select (x:xs) = slide ([],x,xs) ; slide (u,o,v:vs) = (o, reverse u ++ (v:vs)) : slide (o:u,v,vs) ; slide (u,o,[]) = (o, reverse v) in select
13:41:29 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
13:41:29 <lambdabot>     In the first argument of `reverse', namely `v'
13:41:29 <lambdabot>     In the expression: reverse v
13:41:40 <Heffalump> pumpkin: do you actually have a use for RTraversable, btw?
13:41:53 <vixey> :t let select (x:xs) = slide ([],x,xs) ; slide (u,o,v:vs) = (o, reverse u ++ (v:vs)) : slide (o:u,v,vs) ; slide (u,o,[]) = (o, reverse u) in select
13:41:54 <lambdabot>     Couldn't match expected type `[(a, [a])]'
13:41:54 <lambdabot>            against inferred type `(a, [a])'
13:41:54 <lambdabot>     In the expression: (o, reverse u)
13:42:09 <pumpkin> Heffalump: I had thought of one, but can't remember it now :/
13:42:17 <pumpkin> I'll let you know if I remember
13:42:34 <pumpkin> it probably wasn't very compelling, either way :P
13:43:08 <Apocalisp> @type (***)
13:43:10 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:44:46 <b_jonas> question. is it possible to write n+k patterns as views?
13:44:48 <Apocalisp> @type (id ***)
13:44:49 <lambdabot> forall a b' c'. (b' -> c') -> (a, b') -> (a, c')
13:44:52 <Gracenotes> mm... I can almost smell the brocolli cheddar soup... must have :X
13:47:58 <vixey> what
13:48:47 <olsner> Gracenotes: vegetable sex goes -> #blah :)
13:52:24 <Gracenotes> soup is good.
13:52:51 <Philippa__> b_jonas: I would've thought so? The function in question being to subtract k
13:53:21 <b_jonas> Philippa__: but you also have to check if the result is positive, doesn't n+k patterns do that too?
13:53:43 <pumpkin> I wonder how many people want to use Henning Thielemann's stuff, but are put off by his type/class naming
13:53:54 <Philippa__> b_jonas: don't think so? And even if you did, that just makes for a slightly different function
13:54:21 <pumpkin> > let f (1+x) = x in f 1
13:54:22 <lambdabot>   <no location info>: Parse error in pattern
13:54:28 <pumpkin> whoops, I suck
13:54:38 <b_jonas> nonnegative actually
13:54:45 <FunctorSalad> pumpkin: calling all classes 'C'? yep
13:54:56 <pumpkin> and types T
13:55:11 <b_jonas> > let f (x+1) = x in f (-5)
13:55:12 <lambdabot>   * Exception: /tmp/5224641184536485049:71:44-54: Non-exhaustive patterns in ...
13:55:14 <b_jonas> > let f (x+1) = x in f 0
13:55:15 <lambdabot>   * Exception: /tmp/3409051338701145203:71:44-54: Non-exhaustive patterns in ...
13:55:17 <b_jonas> > let f (x+1) = x in f 1
13:55:18 <lambdabot>   0
13:55:34 <b_jonas> it says so in the h98
13:55:38 <vixey> FunctorSalad: I thought that was Oleg
13:55:46 <FunctorSalad> I mean, I see the reasoning with the modules, but it seems to be just another layer of unexpectedness making it harder to learn
13:56:36 <b_jonas> so how would you translate that to views? the only thing I can think of is a function that returns Just the difference for nonnegative numbers, so you'd have to match to Just x <- that function
13:56:54 <vixey> b_jonas: yeah
13:57:06 <vixey> would be nice to have the stuff like => views
13:57:21 <b_jonas> vixey: what are those?
13:57:21 <vixey> and ocaml style tuples too
13:57:35 <vixey> v => p is the same as v -> Just p
13:58:32 <b_jonas> oh
13:59:09 <b_jonas> I think that clashes with some existing syntax though becuase => is an infix operator you might want to define
13:59:18 <b_jonas> that's just a minor syntax problem though
13:59:30 <b_jonas> makes sense
14:06:49 <koninkje> > let (=>) = (+) in 1 => 2
14:06:50 <lambdabot>   <no location info>: parse error on input `=>'
14:07:06 <koninkje> It's forbidden by H98 actually
14:07:46 <koninkje> (Presumably due to it's use in types, even though that's a different sector of the AST)
14:10:50 <koninkje> ss2.4: http://www.haskell.org/onlinereport/lexemes.html
14:21:27 <pumpkin> koninkje: what does your nick mean?
14:22:29 <koninkje> pumpkin: it's the second half of "winterkoninkje" which is Dutch for "wren" (literally "little winter king", thus koninkje=="little king")
14:22:49 <pumpkin> aha :)
14:24:15 <BMeph> ...you know, n+k pattern would be moot if we just had Naturals...
14:24:55 <opqdonut> indeed
14:25:00 <ddarius> BMeph: So you could write: Succ (Succ (Succ (Succ (Succ n)))) instead of n+5
14:25:38 <b_jonas> wow
14:25:40 <bremner_> That succs
14:25:44 <b_jonas> I just got "ghc: panic! (the 'impossible' happened)"
14:25:48 <BMeph> Koenichen in German, maybe. (Any Deutschsprechern hier^W here?)
14:26:00 <vixey> @let pred' 0 = Nothing ; pred' (n+1) = Just n
14:26:00 <lambdabot>   Parse error in pattern:
14:26:06 <vixey> @let pred' 0 = Nothing ; pred' (1+n) = Just n
14:26:06 <lambdabot>   Parse error in pattern:
14:26:12 <vixey> @let pred' 0 = Nothing ; pred' n = Just (n-1)
14:26:13 <lambdabot>  Defined.
14:26:31 <koninkje> ddarius: Or you could use a skew or shift implementation to get non-unary numbers
14:26:43 <vixey> > let example (pred' -> Just (pred' -> Just (pred' -> Just n))) = Right n ; example _ = Left "error" in map example [1..10]
14:26:44 <lambdabot>   <no location info>: parse error on input `->'
14:26:54 <BMeph> ddarius: Thank you, for emphasizing that Naturals implemented in the type system are literally "the succ". ;p
14:26:57 <vixey> , let pred' 0 = Nothing ; pred' n = Just (n-1) ; example (pred' -> Just (pred' -> Just (pred' -> Just n))) = Right n ; example _ = Left "error" in map example [1..10]
14:26:58 <lunabot>  [Left "error",Left "error",Right 0,Right 1,Right 2,Right 3,Right 4,Right ...
14:27:03 <koninkje> data Binary = 0 | 1+2* Binary | 2+2* Binary
14:27:17 <ddarius> BMeph: That wasn't naturals implemented in the type system.
14:27:53 <b_jonas> could someone runghc the following short module with ghc-6.10.2 please: http://erxz.com/pb/16864
14:28:23 <b_jonas> I get this error: http://erxz.com/pb/16865
14:28:38 <BMeph> ddarius: Fine,  s/in the type system/by ADT/ -- better?
14:28:52 <paul424> off topic : excuse me, what should I do if the channel like c++ is redirectinig me to overflow ?
14:29:45 <BMeph> b_jonas: Your bug report is full of (monic) win. :)
14:30:19 * edwardk wakes up and looks around
14:30:38 <vixey> hi edwardk
14:34:06 <mattam> edwardk: isnt't it a bit late to wake up?
14:34:20 <jmelesky> depends on your time zone
14:34:27 <BMeph> edwardk: Isn't it a bit early to wake up? ;p
14:34:35 <vixey> lol
14:34:35 <jmelesky> it's always morning somewhere
14:36:42 <mattam> True, but I think I'm in edwardk's time zone. And it's 5.30pm here :)
14:37:17 <mattam> I wouldn't want him to get lost in monoid madness.
14:39:02 <Saizan> "the smell of monoids in the evening.. it's the smell of victory"
14:39:42 <aeolist> he is making apocalypse II, he might include that as a reference to the first movie
14:39:54 <MyCatVerbs> Saizan: smells like, IIRC. :)
14:40:20 <Saizan> MyCatVerbs: probably :)
14:48:24 <HairyDude> is there any difference between -frewrite-rules and -fenable-rewrite-rules?
14:48:48 <b_jonas> okay, I've reported this panic
14:54:26 <gwern> 'If I got to choose CL names to pick on, the list would start with MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, and MAPCON. Did nobody see the problem, the almost-but-not-quite system? Also PROGV for not fitting in with the rest. Talk about twisty passages.'
14:57:28 <mauke> hah
14:57:46 <mauke> and don't forget RPLACD and MULTIPLE-VALUE-BIND
15:00:53 <HairyDude> poo. even changing -fenable-rewrite-rules to -frewrite-rules, MemoTrie won't compile in 6.8.2.
15:07:02 <harovali> @src filterM
15:07:02 <lambdabot> Source not found. Are you on drugs?
15:11:12 <mmorrow> HairyDude: from what i understand, type families were borked in 6.8.*
15:11:21 <HairyDude> mmm
15:16:07 <Cale> Yeah, type families didn't really work.
15:16:11 <jedai> HairyDude: Pretty much yeah, tried to do things with it but soon abandoned :)
15:16:37 <vixey> is there any docs yet that actually say what type families *are*
15:16:50 <Cale> If you wanted code using type families to work in 6.8, you'd have to translate them all into multiparameter typeclasses with functional dependencies.
15:16:55 <solistic> hello
15:16:57 <Cale> vixey: yes
15:17:05 <solistic> I need a function: maybeApplay :: (a -> b) -> Maybe a -> Maybe b
15:17:07 <jedai> vixey: Well you have a page on the wiki that explains some
15:17:13 <vixey> solistic: that's fmap
15:17:14 <solistic> like
15:17:15 <solistic> maybeApplay f x =
15:17:15 <solistic>     case x of
15:17:15 <solistic>          Just a     -> Just (f a)
15:17:15 <solistic>          Nothing    -> Nothing
15:17:18 <Deewiant> ?ty fmap :: (a -> b) -> Maybe a -> Maybe b
15:17:19 <lambdabot> forall a b. (a -> b) -> Maybe a -> Maybe b
15:17:19 <Cale> fmap
15:17:29 <Axman6> solistic: fmap
15:17:30 <jedai> > fmap (+1) (Just 5)
15:17:31 <lambdabot>   Just 6
15:17:33 <Cale> http://www.haskell.org/haskellwiki/GHC/Type_families
15:17:37 <jedai> > fmap (+1) Nothing
15:17:39 <lambdabot>   Nothing
15:17:49 <Axman6> > fmap (+1) [1..10]
15:17:50 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
15:17:51 <solistic> Axman6, I'll check
15:17:56 <HairyDude> http://www.haskell.org/haskellwiki/GHC/Indexed_types
15:18:00 <Cale> and then, there are a bunch of papers, which are linked from there
15:18:01 <mmorrow> > fmap (*2) (1,1)
15:18:02 <lambdabot>   (1,2)
15:18:04 <Axman6> > fmap (+1) (Right 1)
15:18:05 <lambdabot>   Right 2
15:18:12 <HairyDude> oh, that's the same as what Cale linked to
15:18:14 <Axman6> > fmap (+1) (Left "hello")
15:18:15 <lambdabot>   Left "hello"
15:18:19 <Deewiant> > fmap (+1) (+2) 3
15:18:20 <lambdabot>   6
15:18:28 <Axman6> :o
15:18:33 <mmorrow> > fmap show (Node 0 [Node 1 [], Node 2 []])
15:18:34 <lambdabot>   Node {rootLabel = "0", subForest = [Node {rootLabel = "1", subForest = []},...
15:18:59 <edwardk> mattam: i'm hardly lost in monoid madness. i've er. found myself here. hi me!
15:19:05 <Axman6> solistic: fmap == super handy
15:19:13 <mattam> :)
15:19:26 <mak__> hi, what I have to use to profile a code with uvectors?
15:19:31 <edwardk> right now i'm lost in ghc optimizing madness anyways
15:19:46 * edwardk is getting sick of playing with magic INLINE and SPECIALIZE pragmas
15:20:24 <edwardk> :w
15:20:31 <edwardk> hah woops
15:20:45 * edwardk has been revealed to the world as a vim user. the shame
15:21:24 <mmorrow> :!killall -9 emacs
15:21:29 <mattam> Hehe... so much separates us now.
15:21:42 * ddarius uses vim as does dons.
15:22:05 * vixey did vimtutor once.. and is still trying to fit the brain back together
15:22:14 <FliPPeh> Oh god!
15:22:28 * edwardk was broken in my childhood. i've been using it for something like 25 years now.
15:22:28 <mauke> yes?
15:22:48 * ddarius has only been using it for about 10 years.
15:22:50 <edwardk> well earlier vis, etc.
15:23:02 <ddarius> Of course, 25 years ago, I hadn't yet been born.
15:23:59 <pumpkin-> ddarius the young
15:24:51 <ddarius> There are a lot of people here younger than me.
15:25:57 <solistic> Axman6, thx
15:26:12 <pumpkin-> kadaver is young
15:26:16 <edwardk> woot. down to within 7% of the original Set implementation for inserts
15:26:24 <solistic> Axman6, works super handy;-)
15:27:20 <ddarius> pumpkin: Ask sjanssen, I think it was, how old he is.
15:27:37 <pumpkin-> ?
15:28:17 <pumpkin-> sjanssen: I ask you!
15:29:37 <TomMD> @seen dcoutts
15:29:37 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #darcs, #haskell, #ghc and #haskell-overflow 2m 13d 16h 59m 57s ago, and .
15:29:51 <HairyDude> and . ?
15:31:10 <TomMD> @tell dcoutts Oddly, if I comment out the hackage-server call to Distribution.Server.bulkImport the persistance issue goes away.  I'm not clear on what bulkImport is supposed to be doing in the first place seeing as everything seems to work without it.  Could you enlighten me?
15:31:11 <lambdabot> Consider it noted.
15:31:22 * SamB wonders what the county courthouse does if you write "don't have black ink" on your jury questionnaire ...
15:32:34 <ddarius> They write back, "Buy a pen."
15:33:42 <pumpkin-> ddarius: what should I ask sjanssen?
15:35:45 <MyCatVerbs> They beat a pen into you.
15:35:57 <SamB> this whole thing isn't even dated!
15:37:59 <SamB> I'm tempted circle the words "within ten days", write "of when?", and send it back ...
15:48:37 <mmorrow> edwardk: go go!
15:49:16 * HairyDude crosses his fingers and installs 6.10 from the PPA (uninstalling lots of stuff it depends on, like xmonad-dev and xmonad-contrib-dev)
15:50:41 <mmorrow> HairyDude: it might be nice to install the binary tarball from haskell.org/ghc (i like /usr/local/ghc), or build from source. 6.10.2 just came out :)
15:51:03 <mmorrow> building from source is super painless (it just takes a little bit ;)
15:51:50 <mak__> hi, what I have to do, to by able  profile a code with uvectors?
15:52:34 <edwardk> i hit 6% for a little while but it seems to be backsliding a bit
15:53:23 <pumpkin-> mak__: how do you mean?
15:53:42 <Axman6> mak__: i'm not sure, but try asking dons and/or pumpkin
15:53:48 <FliPPeh> > ['a'...'Z']
15:53:48 <lambdabot>   Not in scope: `...'
15:53:53 <FliPPeh> > ['a'..'Z']
15:53:54 <lambdabot>   ""
15:53:57 <Axman6> or, pumpkin- could come along and ... rawr
15:53:58 <FliPPeh> > ['a'..'z']
15:53:59 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
15:54:01 <FliPPeh> :d
15:54:14 <mak__> if I use uvector in my code i can't compile it with -prof
15:54:16 <FliPPeh> > reverse "FliPPeh"
15:54:17 <lambdabot>   "hePPilF"
15:54:30 * vixey might hack up some interactive programming thing
15:54:46 <MyCatVerbs> FliPPeh: chr 'a' is 97, chr 'A' is 65. Hence 'Z' comes before 'a' in the character encoding, hence the empty list.
15:54:56 <MyCatVerbs> > ['A'..'z'] -- is longer. :)
15:54:58 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
15:55:02 <FliPPeh> > ['Z'..'a']
15:55:04 <lambdabot>   "Z[\\]^_`a"
15:55:07 <FliPPeh> :D
15:55:09 <blsecres> I have a pure function that's taking a long time to complete and would like some feedback.  Is there a general pattern for this type of thing?  Continuation monad?
15:55:29 <vixey> blsecres: I'd have thought more like forking
15:55:34 <blsecres> i.e. print out the current argument every so often?
15:55:57 <koninkje> blsecres: Is it a recursive function?
15:56:07 <FliPPeh> > '^' ++ repeat '_' 5 ++ '^'
15:56:08 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
15:56:09 <blsecres> koninkje: yes
15:56:11 <FliPPeh> :(
15:56:11 <Axman6> > [\0..]
15:56:12 <lambdabot>   <no location info>: parse error on input `..'
15:56:16 <Axman6> > ['\0'..]
15:56:17 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:56:20 <pumpkin-> mak__: uh, that's probably because you didn't compile uvector with profiling support?
15:56:20 <koninkje> if so, use open recursion and defin you're own fixed-point function which does whatever
15:56:27 <Axman6> > length ['\0'..]
15:56:28 <lambdabot>   1114112
15:56:29 <FliPPeh> > "^" ++ repeat "_" 5 ++ "^"
15:56:30 <lambdabot>   Couldn't match expected type `t -> [Char]'
15:56:44 <blsecres> koninkje: OK, thanks
15:58:22 <mak__> pumpkin: posible, i just cabal-install them
15:59:06 <FliPPeh> > "^" ++ repeat 5 "_" ++ "^"
15:59:07 <lambdabot>   Couldn't match expected type `[Char] -> [Char]'
15:59:09 <pumpkin-> mak__: you need to ask cabal-install to build profiling versions for you... easiest way is .cabal/config (then you need to --reinstall your libraries)
15:59:15 <FliPPeh> > "^" ++ (repeat 5 "_") ++ "^"
15:59:16 <lambdabot>   Couldn't match expected type `[Char] -> [Char]'
15:59:18 <FliPPeh> :(
15:59:54 <FliPPeh> > "^" ++ (take 5 (repeat "_")) ++ "^"
15:59:55 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
15:59:57 <FliPPeh> :AD:DAd
15:59:59 * koninkje fails at the typos
16:00:01 <FliPPeh> I hate yoouuu
16:00:08 <FliPPeh> > "^" ++ (take 5 (repeat '_')) ++ "^"
16:00:10 <lambdabot>   "^_____^"
16:00:12 <Axman6> > "^" ++ (repeat 5 '_') ++ "^"
16:00:12 <FliPPeh> Yaaay!
16:00:13 <lambdabot>   Couldn't match expected type `Char -> [Char]'
16:00:25 <Axman6> > "^" ++ (replicte 5 '_') ++ "^"
16:00:27 <lambdabot>   Not in scope: `replicte'
16:00:27 <FliPPeh> > "^" ++ (take 15 (repeat '_')) ++ "^"
16:00:28 <lambdabot>   "^_______________^"
16:00:29 <Axman6> > "^" ++ (replicate 5 '_') ++ "^"
16:00:30 <lambdabot>   "^_____^"
16:00:32 <koninkje> > replicate 5 '_'
16:00:34 <lambdabot>   "_____"
16:00:34 <Axman6> > "^" ++ (replicate 50 '_') ++ "^"
16:00:36 <lambdabot>   "^__________________________________________________^"
16:02:18 <FliPPeh> > [(\x -> x*x) | x <- [1..120]]
16:02:19 <lambdabot>       Overlapping instances for Show (a -> a)
16:02:19 <lambdabot>        arising from a use of `s...
16:02:53 <FliPPeh> > [(x*x) | x <- [1..120]]
16:02:54 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:03:18 <FliPPeh> > [(\a -> a*a) | x <- [1..120]]
16:03:19 <lambdabot>       Overlapping instances for Show (a -> a)
16:03:19 <lambdabot>        arising from a use of `s...
16:03:22 <FliPPeh> Hm.
16:03:39 <FliPPeh> Well
16:04:21 <pumpkin-> mak__: do you have it working?
16:04:30 <mak__> pumpkin: I have both flag set  to True
16:04:43 <mak__> and still cant compile it...
16:04:50 <pumpkin-> mak__: now you need to rebuild uvector...
16:04:57 <mak__> it says that cant find package
16:04:59 <pumpkin-> mak__: and also make sure you uncomment the line
16:05:23 <mak__> i reubuild it
16:05:45 <pumpkin-> you uncommented the line with library-profiling and changed it to True?
16:05:52 <pumpkin-> the -- in front of each line is a comment
16:06:42 <mak__> yaa i found it now;]
16:06:56 <pumpkin-> yeah, that isn't terribly clear
16:08:24 <mak__> cool its works now ;]. thx for help
16:08:32 <pumpkin-> no problem
16:08:41 <pumpkin-> :)
16:08:58 <mak__> ;]
16:11:46 <CalJohn> I'm trying to write an abstract datatype for bencode structures, as an exercise to help learn haskell.  I've written a few constructors in the format "BString B.ByteString", but my constructor for Maps doesn't seem to work ("BDict M.Map B.ByteString BEncode").  What type signature should I use?
16:12:31 <bos> looks like you're missing parens.
16:12:33 <CalJohn> the error is "not enough type arguments"
16:12:44 <bos> BDict (M.Map B.ByteString BEncode)
16:13:04 <CalJohn> bos: I am, and I just spent an hour googling that
16:13:08 <CalJohn> how stupid :/
16:15:59 <bos> no worries. just a common mistake.
16:17:07 <mak__> is there better way to store datas for dfs than IOArray Int UArr Int?
16:17:16 <CalJohn> while I'm here, how can I convert a Char8 into a Word8? I'm wanting to cons some characters onto a ByteString
16:18:14 <mauke> fromIntegral . ord
16:18:46 <mauke> but why not just use the Char8 interface?
16:18:59 <insane_> how to implement a function in haskell which given an x first tries to look up whether it has calculated a value for x in some 'cache', and if so return it, whereas if it doesn't exist in cache calculate the result, store in cache and return value
16:19:12 <CalJohn> mauke: what is the Char8 interface?
16:19:23 <CalJohn> wait, found it
16:19:28 <tromp_> @hoogle Char8
16:19:28 <lambdabot> module Data.ByteString.Char8
16:19:28 <lambdabot> module Data.ByteString.Lazy.Char8
16:19:28 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
16:19:39 <insane_> i mean how to implement the cache
16:20:32 <monochrom> insane_: perhaps http://www.haskell.org/haskellwiki/Memoization helps
16:21:29 <insane_> monochrom: thanks this is what i needed
16:24:46 <HairyDude> huh... 6.10 desugars an associated type "data (:->:) a :: * -> *" as "data family (:->:) a a", surely that should be "data family (:->:) a b" or "data family (:->:) a :: * -> *" ?
16:25:49 <EvilTerran> HairyDude, where're you seeing this desugaring?
16:26:12 * HairyDude writes a minimal example
16:28:26 <kerlo> "data family", eh?
16:29:39 <EvilTerran> see http://www.haskell.org/haskellwiki/GHC/Type_families
16:29:50 <sheyll> why is it that making a simple liststore based treeview sortable in gtk2hs takes me two hours and lots of headache?
16:30:24 <sheyll> has anyone managed to make his gtk treeview sortable?
16:31:10 <HairyDude> hrm, I see there's no hpaste bot any more
16:31:55 <HairyDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3427#a3427
16:32:25 <HairyDude> oh, I see the actual desugaring in ghci with :i :->:
16:35:12 <EvilTerran> :i isn't entirely accurate for some things
16:35:28 <HairyDude> it certainly seems to be accurate wrt. that error message
16:36:15 <EvilTerran> weird
16:37:53 <mperillo> hi
16:37:58 <EvilTerran> does it still happen if you don't call the class's parameter "a"?
16:38:21 <HairyDude> erm, this is in a library
16:41:39 <mperillo> I got an assertion error from ghc rts: "tpp.c:63: __pthread_tpp_change_priority: Assertion `new_prio == -1 || (new_prio >= __sched_fifo_min_prio && new_prio <= __sched_fifo_max_prio)' failed"
16:42:01 <mperillo> on linux debian i386
16:42:31 <mperillo> well, the assertion error seems to be from gcc runtime
16:45:23 <HairyDude> curiouser and curiouser... I get the same desugaring if I use a local copy, but no error
16:51:24 <altmattr> hi folks, I can't get some SYB/Data.Generics code past the typechecker
16:51:43 <altmattr> I have put a super-simple version that shows the problem here
16:51:44 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2061#a2061
16:51:45 <sheyll> I just cant get gtk2hs to bring up sortable tables; the last messag before segfaulting is: gtk2hs_store_get_impl: assertion `GTK2HS_IS_STORE(store)' failed
16:51:51 <sheyll> anyone any ideas?
16:51:56 <altmattr> can anyone help?
16:54:50 <EvilTerran> altmattr, i've pasted a fixed version
16:55:17 <EvilTerran> the problem was that the type of (transform)'s parameter was fixed by the pattern-match
16:55:51 <altmattr> legend
16:55:57 <altmattr> EvilTerran++
16:56:00 <EvilTerran> :)
16:56:02 <altmattr> EvilTerran++
16:56:14 <altmattr> is that gratuitous?  I don't care :)
16:56:33 <altmattr> and a pragma too!  you deserve double karma
16:57:05 <EvilTerran> yay
16:57:44 <HairyDude> aww... you can't make :->: an Arrow
16:57:52 <HairyDude> cos of the pesky constraints
16:57:59 <pumpkin-> that's why we need RArrow!
16:58:20 <edwardk> pumpkin wants REverything
16:58:24 <pumpkin-> I do :P
16:58:35 <pumpkin-> all the fun things are restricted
16:58:42 <pumpkin-> Ord, Eq, UA
16:59:04 <altmattr> pumpkin-: that is why is called a _strict_ type system
16:59:30 <pumpkin-> altmattr: a strict mistress indeed
16:59:33 <altmattr> like and old school marm
17:01:11 <HairyDude> The Haskell Type System is a Harsh Mistress... hmm... there ain't no such thing as a free theorem? :)
17:01:25 <edwardk> ok, packaged up the Data.Set.Unboxed stuff so far http://comonad.com/haskell/unboxed-containers/dist/doc/html/unboxed-containers/Data-Set-Unboxed.html
17:01:48 <edwardk> going to throw that over on hackage as a starting point for discussion
17:02:05 <pumpkin-> edwardk: I asked earlier, but are you sure you don't want to rename monoids to mathematicalstructures? :P I see group, ring, and field have crept in now :P
17:02:09 <sbahra> edwardk, cool
17:02:32 <edwardk> pumpkin: hah nah i don't want to be lumped in with the numerical prelude ;)
17:02:48 <pumpkin-> edwardk: competition is the best thing!
17:02:58 <pumpkin-> edwardk: call it mathematical prelude instead of numerical one
17:03:05 <pumpkin-> numerical seems like an odd name anyway
17:03:13 * HairyDude is bemused by the lack of a Natural type in haskell
17:03:19 <pumpkin-> edwardk: and don't use T/C, and I'm sure you'd be loved by all
17:03:24 <edwardk> pumpkin: nah, i figure the "Abstract" comes after the prelude it should just be 'import Abstract' =)
17:03:26 <Baughn> HairyDude: Data.Word?
17:03:39 <edwardk> or Chapter 1
17:03:47 <Baughn> @remember HairyDude The Haskell Type System is a Harsh Mistress.. there ain't no such thing as a free theorem.
17:03:47 <lambdabot> Okay.
17:04:07 <altmattr> how did anyone write a compiler in haskell without SYB?
17:04:18 <altmattr> smart cookies, all of them
17:04:36 <HairyDude> Baughn: I meant Natural which is to Nat as Integer is to Int... hence Word might be Nat. but Word sounds too hardware-ish
17:04:50 <pumpkin-> like, lazy naturals?
17:04:59 <pumpkin-> a lazy number would be neat :P
17:05:02 <altmattr> naturally lazy
17:05:14 <edwardk> HairyDude: Data.Ring.Semi.Natural =)
17:06:07 <edwardk> HairyDude: i needed it so i could make every monoid a semiring module over the naturals, every group a ring module over the integers
17:06:08 <jlouis> AI.Compiler.Optimizer.Magic!
17:06:16 <sbahra> edwardk, when will this be on hackage?
17:06:20 <sbahra> edwardk, unboxed-containers
17:06:32 <edwardk> sbahra: in about 5 minutes as soon as the upload takes ;)
17:06:44 <sbahra> Ok
17:07:21 <HairyDude> pumpkin-: well Num includes negate and (-), which don't really make sense for naturals
17:07:36 <edwardk> Num drives me nuts
17:07:53 <pumpkin-> HairyDude: that's why you need a mathematically sound typeclass hierarchy
17:08:00 <pumpkin-> like numerical prelude, minus T/C
17:08:10 <edwardk> HairyDude: you can safely use the Multiplicative and Monoid instances from the lib i mentioned without risking blowing up on partial operations like (-)
17:08:23 <HairyDude> yes... trouble with that is the prelude contains so much compiler-specific stuff :/
17:08:27 <edwardk> sbahra: its up there
17:09:00 <edwardk> sbahra: its a little bit slower than Data.Set in constructing (about 7%) but almost 40% faster for membership tests.
17:09:26 <HairyDude> can't say I know much about mathematical modules, btw
17:09:33 <pumpkin-> edwardk: how does memory usage compare?
17:09:40 <pumpkin-> edwardk: I'd assume yours is much better?
17:09:54 <edwardk> pumpkin: smaller, it wraps the value right in the Bin constructor, no dangling thunk
17:10:09 <sbahra> edwardk, I'll let you know speed-ups I see
17:10:10 <pumpkin-> nice
17:10:15 <edwardk> http://comonad.com/haskell/graphs/USetChar.gif
17:10:23 <pumpkin-> edwardk: does your int instance already behave like an IntSet?
17:10:29 <edwardk> http://comonad.com/haskell/graphs/USet.gif  vs http://comonad.com/haskell/graphs/Set.gif
17:10:31 <pumpkin-> I love how pervasive vacuum already is
17:10:34 <pumpkin-> it's great
17:10:56 <edwardk> pumpkin: its faster than intset for membership testing but way slower for construction
17:11:36 <edwardk> i have been trying to figure out how to optimize 'balance' so it doesn't flip out and start reboxing everything losing most of the benefits
17:11:41 <pumpkin-> aw
17:12:10 <edwardk> by way slower i mean about 80% slower, but thats mostly overhead from the views not being optimized nicely
17:13:21 <edwardk> is you look at the benchmark the 'BoxedSet' benchmark is a USet (Boxed Int) -- which emulates the old Set behavior just with my new machinery, and you can see i lose about 30% performance to the views at least, but get 20% back or so from unboxing
17:14:01 * wli can't even figure out how to get monad comprehensions back.
17:14:20 <pumpkin-> edwardk: oh my, version 0
17:14:53 <pumpkin-> edwardk: it seems like your package is going in the same direction as dons' one
17:14:59 <edwardk> wli: the sugar is pretty thick
17:15:25 <edwardk> pumpkin: i'll happily let him merge it in if it makes sense, i just want to get some performance out of these things
17:15:32 <pumpkin-> :)
17:16:03 <edwardk> i welcome any insight into how i can make balance faster for the generic case.
17:16:23 <pumpkin-> my knowledge of tree algorithms ends at an undergraduate level :P
17:16:41 <edwardk> its just trying to make ghc happier with it, not change the algorithm
17:16:46 <tromp_> what kind of keys do you have, edwardk?
17:17:29 <edwardk> tromp_: unboxed types, Integer, (Int|Word)(|8|16|32|64), Float, Double, Char, Bool
17:17:44 <tromp_> do you know about Judy arrays?
17:17:49 <edwardk> tromp_: yeah
17:18:07 <edwardk> tromp_: this was just an attempt to see if a nice standard container could be specialized with views and type families
17:18:21 <edwardk> tromp_: if so i plan to try to do the same thing to some others like Data.Map
17:18:28 <tromp_> ic
17:19:05 <edwardk> tromp_: the funny thing is i _found_ the haskell community through HsJudy ;)
17:19:15 <tromp_> haha, funny indeed
17:19:36 <pumpkin-> dons: any opinions on "lazy UArrs" Ã  la lazy bytestring? to be seen sort of as a generalized lazy bytestring with a list of fast strict UArr chunks
17:19:50 <edwardk> woo
17:19:52 <edwardk> i like
17:20:37 <edwardk> pumpkin: hah, that actually drops out in the next version of the monoid lib. i have a Generator instance for UArr and a Stratified Generator, that lets you deal with lists of generators for instance.
17:20:44 <pumpkin-> lol
17:20:55 <pumpkin-> monoid lib = future of haskell
17:20:56 <edwardk> pumpkin: though you can only really do monoidal reductions on the result
17:20:56 <pumpkin-> :P
17:21:46 <pumpkin-> monoid lib = main abstract algebra structures + mapreduce + compression + all sorts of awesomeness
17:22:26 <edwardk> admittedly i should probably do something to adjust scope ;)
17:22:39 <pumpkin-> ;)
17:22:47 <kadaver> i want to write a bootloader in haskell
17:22:51 <zeno> whats monoid lib?
17:22:57 <edwardk> i just needed the abstract algebra stuff to describe the mapreduce stuff
17:23:02 <edwardk> zeno: cabal install monoids
17:23:10 <wli> Thrown in ML-style higher-order recursive modules for good measure.
17:23:14 <pumpkin-> kadaver: write a bootloader for a virtual machine of your design ;)
17:23:28 <edwardk> that reminds me i need to strip the unboxed set stuff from monoids
17:23:39 <kadaver> pumpkin-: good idea
17:23:45 <zeno> edwardk: k  :) ill read the source i guess
17:23:47 <edwardk> zeno: its my project for dealing with monoidal parsing and well. anything else monoidal
17:23:51 <pumpkin-> startupVM bootLoader = bootLoader
17:23:54 <zeno> neat
17:23:55 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/
17:24:02 <edwardk> the docs there cover a lot of stuff
17:24:20 <wli> What kinds of grammars (not languages) can they handle?
17:24:34 <edwardk> wli: the monoidal parsing stuff?
17:24:57 <wli> Yeah.
17:25:05 <pumpkin-> edwardk: you should probably write a blog post along the lines of "so you thought monoids were academic ivory tower crappage? well, check it out! mapreduce, compression, parsing, can all be expressed as magic monoids and not one abstract in sight!"
17:25:07 <edwardk> wli: right now i can handle (using some things that haven't made it into the lib) regular expressions, dyck languages, haskell layout, etc. and then use context-sensitive parsing within those delimited chunks
17:25:55 <wli> Dyck languages are pretty close to context-free.
17:26:04 <edwardk> wli: i don't have a formal language family specification, since its a bit more ad hoc.
17:26:34 <edwardk> wli: yes, but the idea is that if you have a nearly context-free language that can chunk your input you can be context-sensitive within the chunk and not suffer too badly, and still get a lot of parallelism
17:26:42 <wli> What do you mean "context-sensitive parsing?" Are you doing nondeterministic LBA's?
17:26:48 <marko> Baughn: more weird observations.... are you still here?
17:28:03 <edwardk> wli: well, you can embed monadic parsing, its just inefficient because the monoid just queues everything up that it has to do. so you can make a parsec nearsemiring reduction on the whole input or on chunks of it
17:28:57 <wli> edwardk: Yeah, the bracketing synchronizing token affair is part of my plot for working on modules in isolation despite not having fully determined the set of defined infix operators imported from other modules.
17:29:00 <edwardk> wli: the monoids are helpers, they break problems down into compositional chunks. they can offload things like utf8 parsing, source position tracking, tokenizing, lexing, etc.
17:29:57 <edwardk> and then you can use utilities like fingertrees (also a monoid!) and monoid-oriented compressed containers to maximize reuse of the monoidal values you obtain
17:30:33 <wli> I need to have some sort of way to assert "if the module is correct at all then this particular assumption can be made" to handle things like potential nameclashes with symbols defined locally to the module.
17:30:43 <edwardk> i.e. if you prescan a list converting it to LZ78 encoding, i can do the decompression in the monoid directly
17:30:59 <kadaver> a virtual machine of my design? i should fantisize one up?
17:31:44 <pumpkin-> kadaver: sure! it should have one instruction that takes a text description of what the end-user wants done
17:31:45 <pumpkin-> and do it
17:32:09 <monochrom> Like this:
17:32:12 <wli> I guess operator parsing may also proceed with such assumptions if the operators involved are all locally defined.
17:32:18 <monochrom> @faq cook rice
17:32:18 <lambdabot> The answer is: Yes! Haskell can do that.
17:32:27 <FliPPeh> I hate it when I know I understand the language to a big part, but still cannot use it :( How can I think in Haskell? It's all so weird :(
17:33:05 <edwardk> i wonder if i should do the same thing i did with Data.BitSet to Data.Set, extending it to handle set complements while retaining the same API so it can be a boolean semiring as well
17:33:12 <edwardk> er Data.Set.Unboxed
17:33:54 <monochrom> You think in Haskell by first running an empty virtual machine for Haskell, empty = without the burden of previous education.
17:33:56 <edwardk> oh wait that only works for Enumerables
17:34:25 <FliPPeh> previous education is the hard pile of work to get rid off
17:34:33 <edwardk> kadaver: xavier leroy has a nice presentation on the krivine machine and the machines used by ocaml
17:34:35 <pumpkin-> you must be flexible
17:34:42 <FliPPeh> Years of fondling with imperative, object oriented languages
17:34:49 <FliPPeh> Can't think haskell
17:35:09 * edwardk tries not to fondle his languages
17:35:20 <edwardk> well, maybe Kata.
17:35:20 * pumpkin- fondles FliPPeh
17:35:28 <elliottt> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3429#a3429
17:35:30 * FliPPeh hugs pumpkin-
17:35:35 <elliottt> interesting new cast operation using type families ;)
17:35:39 <glguy> data familes considered harmful!
17:36:01 <pumpkin-> :o
17:36:03 <elliottt> :)
17:36:09 <pumpkin-> that looks disturbing
17:36:11 <Gracenotes> FliPPeh: don't worry, Python's turning 18 this year
17:36:30 <FliPPeh> Python's dirty
17:36:32 <FliPPeh> Won't touch it
17:36:47 <edwardk> elliottt: yeah we were talking about that one last night it caused a problem for dons's adaptive-containers or whatever
17:36:51 <FliPPeh> Rather grab Ruby..
17:36:52 <glguy> good thing we have Haskell's type system to keep our language type safe ...
17:36:55 <Gracenotes> heh. I'd agree that Python is very makeshift
17:36:58 <glguy> <_<
17:36:59 <Gracenotes> even the type system
17:36:59 <glguy> >_>
17:37:43 <pumpkin-> elliottt: so what does get give you?
17:37:50 <pumpkin-> a crash of some sort? :o
17:37:51 <dolio> Unless there are never bugs in the compiler, type systems are worthless.
17:37:53 <FliPPeh> Time to go sleep tho
17:38:01 <HairyDude> elliottt: I thought overlapping type family instances weren't allowed
17:38:03 <FliPPeh> Nighty nighty.
17:38:14 <edwardk> HairyDude: somewhere along the way the check started failing
17:38:16 <elliottt> pumpkin-: gives me a ghc panic :)
17:38:21 <pumpkin-> HairyDude: I thought they were allowed but it just barfed
17:38:24 <monochrom> Programming considered harmful.
17:38:50 <lpsmith> Here's a question:   can you distinguish _|_ from (const _|_) somehow?
17:39:00 <lpsmith> Seems doable,  but I'm having a bit of difficulty
17:39:04 <pumpkin-> :o
17:39:07 <edwardk> ipsmith: yeah with seq
17:39:10 <monochrom> I think they have different types.
17:39:21 <dons> ?bug
17:39:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:39:25 <lpsmith> hmm,  point taken
17:39:26 <edwardk> f `seq` () will die for the former
17:39:30 <edwardk> heya dons
17:39:32 <dons> ^ elliottt
17:39:32 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:39:38 * dons disappears
17:39:56 <HairyDude> I get "Couldn't match expected type `b' against inferred type `a'"
17:39:57 <lpsmith> I'm familiar with seq,  not sure why I didn't think of that...
17:40:01 <edwardk> dons: http://comonad.com/haskell/unboxed-containers/dist/doc/html/unboxed-containers/
17:40:44 <HairyDude> in 6.10.1
17:41:09 <glguy> works great in 6.10.1 for me
17:41:24 <elliottt> i'm on the 6.10.2 release candidate
17:41:29 <elliottt> installing 6.10.2 now
17:41:49 <glguy> *Main Data.Int Data.Word> cast (-10 :: Int32) :: Word32
17:41:49 <glguy> -10
17:41:51 <pumpkin-> ChilliX: is there somewhere I can check on the status of DPH?
17:42:05 <HairyDude> isn't Word32 unsigned?
17:42:08 <pumpkin-> whoa, a negative Word32
17:42:22 <glguy> anything is possible when you have an a -> b
17:42:24 <edwardk> nah
17:42:26 <HairyDude> oh, I see
17:42:49 <Zao> > minBound :: Word32
17:42:49 <edwardk> its using the Int32 instance because it doesn't have a Word32 it has a proof that Word32 ~ Int32 because of the data family
17:42:50 <lambdabot>   0
17:43:01 <edwardk> so its using the Int32 show because it knows it can
17:43:08 <pumpkin-> sounds scary
17:43:19 <Gracenotes>                   o nos.
17:43:26 <monochrom> Ah! Dictionary preserved.
17:43:49 <glguy> *Main Data.Int Data.Word> show (cast (-10 :: Int32) :: Maybe Word32)
17:43:49 <glguy> "Nothing"
17:43:58 <pumpkin-> :o
17:44:11 <glguy> dictionary switched
17:44:18 <edwardk> hrmm
17:44:23 <pumpkin-> how about a [Word32] ?
17:44:28 <pumpkin-> would it give you [] ?
17:44:36 <dolio> Yes.
17:44:37 <Saizan> it's just joking with us.
17:44:43 <lpsmith> edwardk:  here's another question?   Is there a comonadic continuation?
17:44:46 <glguy> yeah, it gives []
17:45:00 <dolio> [] is the first constructor for lists, and Int32s only have one constructor.
17:45:03 <edwardk> Ipsmith: if you have coexponentials, sure. otherwise you have the context comonad which is the closest you get
17:45:09 <dolio> So I# --> [].
17:45:14 <glguy> *Main Data.Int Data.Word>  (cast (10 :: Word32) :: (Word16,Word16))
17:45:14 <glguy> (zsh: segmentation fault  ghci cast.hs
17:45:20 <monochrom> The plot thickens.
17:45:22 <glguy> I need to try with a stict pair or something
17:45:25 <dolio> Or, I32#.
17:46:16 <edwardk> ipsmith: that comes from the fact that the continuation passing style monad is an unquantified right kan extension and the context comonad is an unexistentialed left kan extension.
17:46:17 <elliottt> it seems to segfault when you run cast twice :)
17:46:40 <pumpkin-> even if you cast it to and from the same type?
17:46:43 <HairyDude> I can call cast :: String -> Bool as many times as I like and it always seems to say True
17:46:45 <elliottt> yeah
17:46:51 <HairyDude> (it works now, for some reason)
17:46:55 <elliottt> oh, i was casting to IO Char
17:46:58 <dons> glguy: ChilliX is going to come to galois and kick your butt if you don't submit the bug :)
17:47:02 <elliottt> and that caused a segfault on the second attempt
17:47:08 <edwardk> dons: hahaha
17:47:08 <pumpkin-> lol
17:47:10 <lpsmith> edwardk:  my username starts with an L ;-),  and I wish I knew a little bit more category theory :-)
17:47:16 <glguy> dons, I didn't paste it to hpast :-P
17:47:26 <dons> ?bug <--
17:47:27 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:47:27 <dolio> The data families bug?
17:47:40 <dolio> I thought we reported that yesterday.
17:47:47 <glguy> dons, My bug would be titled "someone put data families in my ghc"
17:47:52 <glguy> solution "remove them"
17:47:57 <edwardk> glguy: hahaha
17:47:59 <monochrom> If I don't submit bugs, they will come for me?
17:48:00 <elliottt> yeah, that still happens in 6.10.2
17:48:01 <pumpkin-> dons: did you see my question on lazy UArrs? or have you already disappeared?
17:48:04 <elliottt> i'll submit the bug :)
17:48:10 <dons> glguy: he's definitely gonna wanna kick your butt now :)
17:48:37 <dons> dolio: this doesn't use OverlappingInstances (or did edwardk's yesterday boil down to the same thing?)
17:48:38 <edwardk> glguy: i can see it now, you submit a patch named 'ghc 6.8'
17:48:38 <glguy> you got peanut butter in my chocolate!
17:48:46 <elliottt> heh
17:48:47 <edwardk> dons: its the same example
17:48:49 <monochrom> hahahaha glguy
17:48:51 <dons> ah ok. so we're fine then.
17:48:57 <lpsmith> edwardk:  by exponentials,  you mean a function type,  basically?
17:49:02 <edwardk> he just doesn't use a boxed type
17:49:07 <dolio> dons: It doesn't need OverlappingInstances because OverlappingInstances doesn't do anything to type families.
17:49:11 <HairyDude> http://hackage.haskell.org/trac/ghc/ticket/3150 related?
17:49:11 <dons> yep
17:49:24 <dolio> It's just a bug. :)
17:49:26 <dons> yeah, that's it. http://hackage.haskell.org/trac/ghc/ticket/3150 glguy
17:49:29 <edwardk> lpsmith: yeah. an exponential in a category is analogous to a function.
17:49:35 <dons> the one we hit last night
17:49:39 <monochrom> exponent objects make my head explode
17:50:06 <edwardk> coexponentials are like 'subtraction' in a lot of ways. (thats how they show up in posets anyways)
17:50:12 <glguy> ?remember edwardk glguy: i can see it now, you submit a patch named 'ghc 6.8'
17:50:12 <lambdabot> I will remember.
17:50:26 <monochrom> coexponents make my head implode, I guess.
17:50:50 <wli> monochrom: Categorical logarithms?
17:50:53 <HairyDude> what's a coexponent when it's at home?
17:50:55 <monochrom> hahahahahah bug named "ghc 6.8" :)
17:51:13 <edwardk> the problem with coexponentials is you can't have them and exponentials and have anything interesting left over. the whole category collapses into a poset, meaning that there is only one arrow between any two types.
17:51:26 <edwardk> at least if you have them for every type
17:51:28 <edwardk> er object
17:51:38 <edwardk> er only at most
17:51:58 <HairyDude> are coexponentials just the categorical dual of exponential objects?
17:52:01 <lpsmith> hmm
17:52:06 <edwardk> HairyDude: yeah
17:52:11 <monochrom> Interesting. I'll state and prove it during the next category theory study group in my viccinity.
17:52:13 <olsner> combining coexponentials and exponentials explodes and implodes your mind simultaneously, giving a zero net result?
17:52:22 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Category-Cartesian-Closed.html might make it clearer
17:53:00 <monochrom> I guess if I both explode and implode I become a poset singularity.
17:53:20 <HairyDude> I wasn't aware there was such a thing as a cartesian non-closed category
17:53:35 <edwardk> coapply :: b -> (b - a) + a
17:54:29 <edwardk> cartesian doesn't imply the existence of exponentials, being a closed monoidal category does.
17:55:14 <edwardk> if you're closed and cartesian you've got (almost) everything you need to run a lambda calculus in your category
17:55:45 <HairyDude> well yes, I know about CCCs
17:56:07 <lpsmith> edwardk:   how did you come to know so much about category theory,  and do you have any suggestions for learning it?
17:56:11 <lpsmith> I know something about it all
17:56:26 <wli> It's all about cocones, omega lambda X hyperdoctrines, and the short five lemma.
17:56:27 <edwardk> lpsmith: i er.. sat down on this channel one day and started writing a library ;)
17:56:28 <lpsmith> but I find there are too many definitions before insight comes that I tend to get lost
17:56:33 <lpsmith> hahaha
17:56:33 <lpsmith> sweet
17:56:59 <lpsmith> edwardk: yeah,  I can see how haskell would help :-)
17:57:00 <edwardk> lpsmith: i need to go back through and clean up some of the mis-definitions in category-extras.
17:57:22 <olsner> wli: short five lemma? that sounds like it needs a supplementary high five lemma
17:57:25 * wli hits up edwardk for a hyperdoctrine lib.
17:58:16 <edwardk> wli: well, monoids is just a refinement of category-extras. after all a monoid is just a category with one object. i'm still on my original obsession i just er... 'narrowed' my scope =)
17:59:05 <lpsmith> See,  monoids I never had any trouble with.   I first saw them in Abstract Algebra,  though we didn't cover them in depth there
17:59:26 <lpsmith> Theorems and insight come relatively quickly after definitions ;-)
17:59:30 <dons> edwardk: so have you benchmarked the sets?
17:59:33 <edwardk> lpsmith: monoids themselves are boring, its just that i'm using all the structures i can build over them
17:59:38 <dons> do you want to merge them into the general adaptive-containers package?
17:59:47 <edwardk> dons: yeah. ~7% slower than Data.Set for insertions, ~30-40% faster for membership testing
17:59:50 <lpsmith> edwardk: indeed
17:59:52 * HairyDude wonders if Mortomes wants to be in this channel or not :)
17:59:53 <dons> ah interesting
17:59:54 * BMeph gives olsner a high five axiom
18:00:02 <elliottt> dons: ok, i've submitted the bug
18:00:09 <edwardk> dons: yeah i'd like to get some better performance out of them first, but i'll happily hand them over
18:00:16 <edwardk> dons: you know a lot more about haskell optimization than i do
18:00:20 <dolio> edwardk: How's it compare to IntSet/Map?
18:00:25 <dons> elliottt: http://hackage.haskell.org/trac/ghc/ticket/3150
18:00:46 <edwardk> dolio: intset kicks my ass on inserts by a factor of 2, but i'm about 20-30% faster for membership testing.
18:01:00 <dolio> Huh.
18:01:17 <edwardk> basically it seems that because the view has two constructors it doesn't get handled nicely and winds up boxed.
18:01:20 <pumpkin-> edwardk: just copy their code :P
18:01:58 <edwardk> i tried adding a couple of other methods for extracting from the view. one that takes two continuations and one that just unpacks all but the size from a bin into an unboxed tuple
18:02:05 <edwardk> thats how i got to within 7%
18:02:45 <edwardk> oh and i rewrite the balance routine so i'd only have to view once during rotation
18:03:02 <jklk> http://video.google.com/videoplay?docid=-6909741472889151623
18:03:22 <edwardk> dons: did i miss anything obvious optimization wise?
18:04:05 <edwardk> i went through and sjanssen suggestion and worker/wrapper transformed as much stuff as i could readily do so to
18:04:27 <edwardk> but i blow ~50% of my time in balancing otherwise i'd kick Data.Set's butt =)
18:04:53 <edwardk> i'm tempted to move balance into the US class directly so it can balance on the unboxed type
18:05:27 <edwardk> ok, going to try to benchmark that
18:08:50 <halberd> the unification of two types can be viewed as the intersection of the sets that the types represent, can't it?
18:09:11 <gwern> edwardk: but did the PuertoRican type approve in a referendum being moved directly into the US type?
18:09:41 <edwardk> gwern: i used elliottt's cast operator and never gave him the choice
18:10:02 <gwern> ever did empire operate thus
18:10:57 <elliottt> it's a powerful operator.
18:11:22 <halberd> by the unification of two types, I mean as used in type inference
18:11:43 <gwern> type safety grows out of the barrel of a gun!
18:14:40 <wli> edwardk: switch to an rbtree
18:16:23 <edwardk> wli: no desire to change the underlying representation, its been around for a long time for a reason
18:16:40 <Tsion> What's the best way to get Int 1 from Char '1'?
18:16:52 <dolio> @hoogle digitToInt
18:16:53 <lambdabot> Data.Char digitToInt :: Char -> Int
18:16:53 <Tsion> And so on for the other numbers
18:17:08 <wli> edwardk: what reason?
18:17:21 <Tsion> Thanks dolio
18:17:58 <edwardk> wli: i would presume because people haven't been able to get decent performance out of alternatives.
18:18:05 <Nafai> @t fmap
18:18:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:18:12 <Nafai> @type fmap
18:18:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:18:18 <edwardk> wli: i'm interesting in benchmarking the cost of doing the viewpattern/typefamily transform not in changing algorithms right now
18:18:42 <edwardk> if i can find useful patterns for doing the unboxing transform, then we can do this uniformly to other structures
18:18:53 <dolio> RBTrees are too easy. You have to prove you have chest hair by doing AVL or something.
18:22:09 <edwardk> woot i'm faster than Set now!
18:24:22 <edwardk> moving the balance operation into the dictionary for US and transforming it into a single operation makes me ~10% faster for construction
18:24:30 <halberd> more specifically... the unification of two predicates, F(x) and G(x), is a certain predicate H(x) that describes the conjunction F(x) & G(x)
18:24:53 <halberd> but not every H(x) suffices
18:26:05 <halberd> perhaps it will be true for any H(x)=F(x)&G(x) that has been evaluated into normal form?
18:30:45 <HairyDude> module X imports Y, which imports and exports Z. X hence imports Z. so "module Z" in X's export list should work, right?
18:31:14 <olsner> dolio: AVL trees seem way easier to me than rbtrees.... I just can't see nodes having colors and deriving meaning from those colors
18:31:19 <not-math> Yes should work.
18:31:57 <olsner> iirc, avl trees have something like a bit that says whether left- or right subtree is deeper and then you rotate occasionally
18:32:16 <dolio> olsner: It's been a long time since I looked at AVL trees, but I just remember the operations on them being more confusing.
18:32:24 <loop> olsner: if you think it as a node having a bit set or not
18:32:30 <wli> HB[k] trees are binary trees where left and right subtrees differ in height by at most k.
18:32:36 <kadaver> haskell and compute rlnaguage functions in general are not total right?
18:32:40 <wli> AVL is HB[1].
18:32:41 <loop> olsner: black/red, 0/1 ?
18:32:52 <pumpkin-> I thought deletion from RB trees was a real pain
18:32:55 <pumpkin-> the other ones aren't so bad
18:33:01 <HairyDude> doesn't seem to be working.
18:33:45 <edwardk> oslner: avl is easier, but does so much busiwork
18:34:12 <halberd> how can it be a pain, you just implement some algorithm someone else designed
18:34:29 <olsner> loop: yeah, but the thing is that the color (iirc) represents some complicated magical property instead of something you can readily understand what it's about
18:34:36 <pumpkin-> halberd: it's just a long painful set of things to do
18:35:05 <wli> rbtrees aren't as well-balanced but update less of the tree structure upon insertion.
18:35:12 <dolio> olsner: That is, it might be more difficult to see why red black trees keep things appropriately balanced, but writing the functions that maintain the invariants seems more straight forward.
18:35:16 <halberd> pseudocode for a red black tree is almost the same as actual code
18:35:29 <olsner> dolio: sounds about right
18:35:30 <HairyDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3431#a3431
18:36:43 <pumpkin-> oh no, it's a kadaver
18:37:46 <pumpkin-> is it possible to get cache size at runtime?
18:38:01 <olsner> kadaver: computer functions in general often aren't even functions :)
18:38:03 <ChilliX> pumpkin-: depends a bit on what you mean by status
18:38:06 <pumpkin-> cache sizes, rather
18:38:20 <not-math> HairyDude: Oh I see. X receives dummy but not the name Z.
18:38:39 <ChilliX> pumpkin-: here you find the latest benchmark sresults http://hackage.haskell.org/trac/ghc/wiki/DataParallel/BenchmarkStatus
18:38:48 <pumpkin-> ChilliX: as in, is there an associated blog/mailing list? it looks really exciting and I was just curious whether it's progressed since 6.10.1
18:38:49 <pumpkin-> ah cool
18:38:56 <ChilliX> it also says which benchmarks don't work at the moment and why
18:39:37 <ChilliX> pumpkin-: near the bottom of the page, there are also two links to graphs
18:39:54 <ChilliX> yes, it did progress quite a bit since 6.10.1
18:40:09 <ChilliX> both DPH as well as the multi-threaded GHC RTS
18:40:54 <not-math> module Y (module Z) does not export the name Z, it only exports the names exported by Z (here just dummy).
18:42:35 <pumpkin-> also, is there a relationship between uvector and DPH's parallel vector?
18:42:35 <pumpkin-> I seem to remember reading that uvector was based loosely on the DPH structure
18:45:10 <edwardk> pushing up the unboxed container lib again now that its fast
18:45:31 <pumpkin-> glguy: I remember you commenting on the simultaneous traversal for mean being unnecessary... what's the best way you can think of to write mean that calls length and sum independently?
18:45:41 <pumpkin-> or at least not being proven to be necessary
18:50:45 <ChilliX> pumpkin-: vector is directy based on dph code
18:51:01 <ChilliX> uvector a similar fusion framework as dph
18:51:13 <lpsmith> aight,  I'm trying to upgrade from 6.10.1 to 6.10.2
18:51:15 <edwardk> ok, the unboxed sets are now 25% faster than Data.Set, but still 12% slower than IntSet
18:51:39 <edwardk> but given that i seem to be paying about 20% for view patterns i think thats not bad.
18:52:39 <lpsmith> I'm on ubuntu 8.04,  and tried installing the generic i386 Linux for libedit2
18:52:51 <lpsmith> I try running GHCi
18:52:54 <pumpkin-> does http://twitter.com/sigbjorn_finne/ come on IRC?
18:53:08 <lpsmith> ghc: panic! (the 'impossible' happened)
18:53:24 <lpsmith>   (GHC version 6.10.2 for i386-unknown-linux):
18:53:38 <lpsmith> 	interactiveUI:setBuffering2
18:53:51 <lpsmith> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
18:54:14 <lpsmith> I had some issues trying out the pre-release as we
18:54:17 <lpsmith> well
18:54:31 <lpsmith> anybody have some ideas?
18:55:20 <pumpkin-> so just running GHC panics?
18:55:25 <pumpkin-> (ghci)
18:57:07 <lpsmith> yeah
18:57:44 <lpsmith> lemme try compiling something with ghc-6.10.2 and see what happens
18:58:01 <mak__> hmm, is there better way to store datas for dfs than IOArray Int (UArr Int)?
18:58:14 <pumpkin-> dfs?
18:58:19 <pumpkin-> depth-first search?
18:58:24 <mak__> yep
18:58:28 <lpsmith> mak:__ you could use a STUArray :-)
18:58:38 <pumpkin-> why use UArr there?
18:58:47 <mak__> can't by unboxed for list-like
18:58:50 <pumpkin-> appending/prepending onto them is inefficient
18:59:20 <mak__> hmm in test are a bit faster than lists
18:59:31 <pumpkin-> were you appending onto the list too?
18:59:32 <mak__> and eats less memory ;]
18:59:38 <pumpkin-> did you try Data.Sequence?
18:59:47 <lpsmith> mak__:  are you storing adjacency info or something else in the UArray?
18:59:52 <glguy> pumpkin-, my point is that a 4x speed-up in finding the average of a list of numbers wouldn't make a difference in any of my programs except maybe one project euler program
19:00:05 <pumpkin-> glguy: ah, I see :)
19:00:09 <lpsmith> pumpkin-:  Data.Sequence would probably be a performance disaster ;-)
19:00:26 <mak__> lpsmith: i store a a info about childs in list-like structure
19:00:36 <lpsmith> hmm
19:01:07 <lpsmith> mak__:  list-like?
19:01:24 <pumpkin-> glguy: but do you do much statistical work? most statistical measures are complex folds and are used a fair amount ML contexts (which is why I'm interested in them)
19:01:29 * lpsmith finds that ghc-6.10.2 bombs out too
19:02:00 <lpsmith> GHC gives me the message
19:02:08 <lpsmith>     Failed to load interface for `Prelude'
19:02:09 <glguy> pumpkin-, I don't
19:02:24 <mak__> lpsmith: i try lists and uvectors ;]
19:02:38 <pumpkin-> mak__: so what operations are you doing on the UArrs?
19:02:43 <pumpkin-> snocU?
19:02:55 <mak__> cons, head tail
19:03:13 <mak__> null
19:03:14 <pumpkin-> see, they aren't efficient at all for cons
19:03:23 <pumpkin-> unless you get them to fuse
19:04:11 <lpsmith> pumpkin-:  indeed!
19:04:11 <lpsmith> mak__:  the problem is that you have to copy the entire array to make one little change
19:04:42 <lpsmith> Data.Sequence would be a very reasonable approach,  then.
19:04:53 <pumpkin-> if you're just doing cons, I don't see what's wrong with lists
19:04:58 <lpsmith> Especially compared to UArrays
19:05:00 <pumpkin-> unless you have truly enormous datasets
19:05:30 <mak__> pumpkin-: 10^6 elems or sth like that
19:05:30 <pumpkin-> you can always use dons' latest adaptive list (from yesterday)
19:05:32 <lpsmith> lists would probably perform even better than Data.Sequence,  properly used
19:05:58 <lpsmith> improperly used,  and Data.Sequence would be better
19:06:06 <pumpkin-> mak__: I'd suggest the adaptive list then, or to just roll your own data IntList = Nil | Cons !Int IntList
19:06:40 <lpsmith> pumpkin-:  ehh, you can do pretty well by using seq instead
19:06:44 <pumpkin-> data IntList = Nil | Cons {-# UNPACK #-}!int IntList -- or unpack strict
19:06:54 <pumpkin-> lpsmith: well, with explicit strictness you can ask GHC to unpack it
19:06:58 <pumpkin-> so you don't waste space with a box
19:07:06 <lpsmith> yes :-)
19:07:57 <pumpkin-> but 10^6 really isn't that much
19:09:51 <lpsmith> mak__:  you might want to read the first couple chapters of Chris Okasaki's book,  "purely functional data structures"
19:10:07 <lpsmith> That should give you some intuition about what's going on underneath the hood
19:10:45 <pumpkin-> my computer's being a slug
19:10:48 <pumpkin-> brb, restarting
19:10:54 <mak__> maybe its not so much but i have to get performance similar to c/c++ ;]
19:10:56 <lpsmith> The key is that in order to "change" a data structure,  under normal circumstances you can't change the memory location.  (Without IORefs or something)
19:11:18 <wli> That's where rbtrees help.
19:11:44 <wli> The lesser amount of rebalancing they do translates to less allocation, copying, GC, etc.
19:11:45 <lpsmith> Rather,  you allocate a new memory location to hold the parts that have changed,  and share the parts that have not
19:12:21 <lpsmith> In the case of UArrays,  nothing is shared,  so updating it is very expensive
19:12:58 <lpsmith> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
19:13:19 <mak__> mhm
19:13:51 <not-math> http://www.vex.net/~trebla/weblog/fpbooks.xhtml :)
19:14:17 <wli> There is probably a way to fiddle with rbtrees to minimize the updates done while maintaining the red/black invariant.
19:16:34 <c_wraith> When can haskell optimize for in-place updates?
19:17:15 <mak__> hmm still too much gc time...
19:17:59 <kadaver> pumpkin: i still dont get the bootloader stuff, what kind of instructions would ie be?
19:21:07 <lpsmith> not-math: good selection of books
19:21:09 <lpsmith> !
19:21:16 <not-math> hehe
19:21:47 <lpsmith> however,  I seem to remember a much better introduction in "Purely Functional Data Structures" than is presented in the thesis that's freely available online
19:22:06 <lpsmith> Not sure where my copy of the book went.  :-/
19:24:07 <lpsmith> yes...  the book has a better introduction than the thesis,  unfortunately
19:24:29 <lpsmith> I remember reading what's available on Amazon and Google Books
19:24:49 <SamB> it's only unfortunate when you lose your printed copy ...
19:24:57 <not-math> It hurts my feeling that books are expensive. There are a lot of good books out there, irreplaceable by the internet, and they are too expensive.
19:25:00 <lpsmith> SamB:  indeed!
19:25:17 <SamB> unfortunately, mine has been missing too :-(
19:25:19 <lpsmith> also agreed with not-math!
19:25:55 <SamB> hmm, yeah, many of them are too expensive :-(
19:26:34 <lpsmith> Chapters 2 and 3 of the printed version of "Purely Functional Data Structures" are missing from the thesis
19:26:50 <lpsmith> And those are really useful chapters,  especially for relative newbies
19:28:03 <not-math> The thesis was not for newbies. The book is for newbies as much as it can.
19:28:20 <SamB> he might not have been able to find the time to write those if he wasn't going to sell them
19:28:38 <not-math> A thesis is never for newbies!
19:28:52 <SamB> eh
19:28:54 <not-math> (Unless the whole PhD committee consists of newbies.)
19:29:01 <lpsmith> hahaha
19:29:18 <SamB> you can get away with it if you include enough background material, I think ...
19:29:24 <SamB> in some cases
19:29:30 <wli> Or you're doing stuff so obscure that no Ph.D. committee could be reasonably expected to be familiar with the basics.
19:29:43 <bremner> not-smith: I think structurally, there probably is at least one newbie per committee
19:30:13 <lpsmith> Actually,  I'm curious for feedback from newbies about how easy (or hard) my paper was to follow
19:30:43 <lpsmith> http://blog.melding-monads.com/2009/03/09/lloyd-allisons-corecursive-queues/
19:30:54 <lpsmith> The abstract might be a little intimidating
19:31:07 <lpsmith> but the paper itself I really tried hard to make it as gentle as possible
19:31:19 <lpsmith> At least the first three sections or so
19:31:22 <not-math> I have a colleague in our formal methods group doing formal methods for quantum computing. So now her committee has like one physicist (that's one newbie in formal methods) and three formal methods people (that's three newbies in quantum computing).
19:31:58 <SamB> not-math: excellent!
19:32:44 <edwardk> ok, when we start dealing with boxed tuples the win for the unboxed sets goes up considerably up to about 1.5x faster for construction
19:33:03 <wli> There's this one guy's thesis that consists primarily of a long tutorial on properties of a specific and obscure sort of poset.
19:33:11 <dons> edwardk: woo
19:33:25 <dons> i wonder how many benchmarks it would take to make a paper about  this technique :)
19:33:45 <edwardk> dons: i think we might be able to put something together. =) i'm going to tackle Data.Map next
19:34:01 <edwardk> i managed to clean up the code considerably by moving balance into the class, it doesn't even have to be specialized
19:34:08 <edwardk> it just has to be there so it dispatches to the right version of it
19:34:13 <SamB> wli: what was at the end of it?
19:34:16 <SamB> a proof?
19:34:31 <dons> edwardk: yes, it seems to help some inlining and specialization if we do it right.
19:34:35 <not-math> The end says "we have proved 1000 theorems".
19:34:42 <dons> ok. Map would be good. then I'd like to do IntMap
19:35:02 <edwardk> yeah, so we can compare applies to oranges and see which is fast objectively?
19:35:10 <pumpkin> couldn't IntMap be rolled into Map as a specialized instnace for Ints?
19:35:24 <SamB> edwardk: how about going all-out and comparing applies to call/ccs?
19:35:25 <wli> SamB: A few things. Some proofs of a generalized uniqueness property for inferred types, some code or interaction logs of type inference etc.
19:35:43 <lpsmith> edwardk:  objective benchmarks?!   WTF is that??? ;-)
19:35:43 <edwardk> pumpkin: IntMap has a special set of reasoning for dealing with some kind of big endian tries
19:35:52 <pumpkin> hmm
19:36:16 <pumpkin> so it wouldn't be possible to make Map Int a == IntMap a using associated types?
19:36:46 <edwardk> pumpkin: well, we want to benchmark and see if IntMap is faster because it unboxes or if its faster because it has special Int magic
19:36:53 <pumpkin> ah
19:37:15 <edwardk> pumpkin: if its the latter i might be able to merge the two definitions
19:37:23 <pumpkin> :)
19:37:24 <edwardk> but it'll be trickier to do
19:37:58 <edwardk> bashing out some perl to generate instances
19:38:00 <pumpkin> well, it has different time complexity doesn't it? where it's always at most O(log n)?
19:38:18 <pumpkin> edwardk: syb! :P
19:38:20 <dons> and i just want to make IntMap fast. i want the fastest container types!! bring them to me.
19:38:25 <pumpkin> lol
19:38:34 <edwardk> hah
19:38:45 <pumpkin> dons: on that topic, do you have any opinion on a lazy UArr Ã  la lazy bytestring?
19:38:55 <pumpkin> sort of as a generalized bytestring
19:39:15 <pumpkin> I was thinking of trying it, but not sure if it's a silly idea
19:39:55 <dons> i think it'd be very cool
19:40:02 <dons> then we could do streaming video :)
19:40:19 <pumpkin> mmm
19:40:27 <pumpkin> ok, I'll see if I can get something basic up
19:41:33 <wli> I'd think for high perf. B trees for cache/TLB locality would be imperative.
19:41:35 <mak__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3433#a3433 how uneffective is this code? ;]
19:42:22 <pumpkin> mak__: looks very imperative :P
19:42:41 <lpsmith> indeed.   You can do quite well without the IO monad
19:42:51 <pumpkin> even if you want all that, try it in ST instead of IO
19:42:59 <lpsmith> yes
19:43:01 <pumpkin> surely you don't want everyone calling you to be in IO
19:43:37 <lpsmith> The advantage of ST is that you can use localized state,  and eventually get back a pure value
19:43:49 <lpsmith> Whereas you have to cheat to get a pure value out of an IO computation
19:44:36 <lpsmith> (Although you can treat values in an IO computation as pure,   but then the overall computation isn't)
19:45:03 <mak__> I need na IO i have to read thata almoust for all time..
19:45:14 <pumpkin> mak__: ?
19:45:26 <pumpkin> mak__: the only things that you can't do in ST that you can do in IO are external side effects
19:45:41 <mak__> getLine ? ;]
19:45:50 <pumpkin> ew
19:45:56 <pumpkin> don't put getLine into something like dfs :P
19:46:08 <mak__> not in dfs ;]
19:46:13 <pumpkin> then dfs can be in ST
19:46:19 <lpsmith> mak__: yeah, you want to seperate your I/O function from your DFS functions
19:46:33 <mak__> before in functions that create a IOArrar witch is traversed
19:47:45 <mak__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3433#a3434 something like that ;]
19:48:31 <wli> I'm not entirely sure where the Arr stuff comes from.
19:48:39 <pumpkin> pirates!
19:48:46 <joed> Arrrgh
19:48:51 <pumpkin> Arrr matey
19:49:10 <wli> Data.Array doesn't export it, nor its various sub-modules.
19:49:37 <mak__> my Arr ?
19:49:46 <wli> yeah
19:49:48 <mak__> type Arr  = IOUArray Int Int
19:50:03 <wli> That line didn't make it to your past.
19:50:12 <wli> Try STUArray so you can runST it.
19:52:03 <wli> mak: Where are you getting Tree from?
19:52:34 <mak__> form create function
19:52:47 <mak__> from*
19:58:25 <kerlo> @index Arr
19:58:25 <lambdabot> bzzt
19:59:40 <kadaver> what does RFC normally mean?
19:59:50 <Tsion> request for comments
19:59:50 <dibblego> Request For Comment
20:00:05 <kadaver> remote function call?
20:00:10 <kadaver> ok
20:00:17 <lpsmith> mak__:  I just uploaded my variant of DFS to hpaste
20:00:24 <lpsmith> Unfortunately it contains one small bug
20:00:43 <lpsmith> I need x : loop ... instead of loop ...
20:05:06 <canadaduane> Given a list of pairs of numbers, what is a good way to find the index of the pair that sandwiches another number?  E.g. [(1,2), (2,3), (3,4)] -- sandwich 2.5 ==> 1
20:05:20 <canadaduane> sandwich 3.2 ==> 2
20:05:49 <Gracenotes> @type findIndex
20:05:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
20:06:35 <Gracenotes> given a list and a function that returns True when you've found the index you like
20:06:45 <canadaduane> ah, thank you
20:06:52 <canadaduane> figures it's built in ;)
20:06:58 <Gracenotes> @index findIndex
20:06:58 <lambdabot> Data.List, Data.Map
20:07:12 <Gracenotes> yep... you have to import Data.List though
20:07:18 <canadaduane> great
20:07:25 <Gracenotes> I think...
20:07:38 <canadaduane> yeah, it seems to be so
20:08:24 <Gracenotes> @type on (&&) . (==)
20:08:25 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
20:09:21 <mak__> lpsmith: cool but this dfs only pass thru the tree i need something more, it have to make a label for incoming to node and outgoing from node, after visitng all sons
20:10:44 <mak__> and will by nice if i this labels keep in strucure where i can find it in constnt time ;]
20:10:44 <edwardk> i wonder if specializing for all 2000 instances or so would be a bad idea
20:10:48 <edwardk> =)_
20:11:36 <wli> data VertData = VD { inEdges, outEdges :: IntSet } ; data EdgeData = ED { src, dst :: Int } then keep pass graph :: (IntMap VertData, IntMap EdgeData) ... maybe the VertData/EdgeData tuff gets more garbage attached later.
20:12:06 <dolio> How are you doing pairs and such, by the way? Declaring instances for (A, B) for all A and B?
20:12:19 <edwardk> yeah, pairs and triples that way
20:12:25 <dolio> Sounds lovely. :)
20:12:27 <edwardk> i have a newtype for Boxed so you can leave a box in
20:12:48 <edwardk> USet (Int,Boxed Whatever)
20:14:17 <dolio> Boxed is for the polymorphic instances?
20:14:47 <edwardk> yeah
20:14:51 <dolio> Okay.
20:15:24 * wli tries to think of how IntMap differs from Array Int.
20:15:29 <jfredett_> whereabouts might I go to find docs on how to extend the deriving mechanism? Data.Derive haddocks are confusing, is there a tutorial around?
20:15:52 <edwardk> yay for 13000 lines of automatically generated instances
20:16:14 <wli> ... now watch ghc take half an hour to get through them
20:16:46 <edwardk> heh its chewing =)
20:16:52 <edwardk> i may go back down to just pairs
20:18:28 <dons> no, i bet it doesn't take that long
20:18:38 <dons> 4000 lines of instances takes only a few seconds now
20:18:41 <edwardk> still chewing =)
20:19:01 <edwardk> remember i have specializations involved and stuff but i only have specializations for the singleton maps
20:19:26 <edwardk> even so i'm sitting here at 4 gigs and counting of memory consumption
20:19:33 <dolio> dons must compile on some sort of super computer. Like a PlayStation 2.
20:19:43 <dons> heh
20:19:53 <dons> well, that's just how long the 4k lines in the adaptive containers took
20:20:03 <edwardk> yeah, did you do triples ultimately?
20:20:04 <dons> maybe i don't try the same tricks as edwardk
20:20:08 <dons> nope
20:21:27 <dolio> You could flagrantly ignore warnings about orphan instances and stick the pair/triple/etc. instances in their own modules.
20:21:29 <edwardk> i'm going to comment out the triple instances and try again
20:21:30 <dolio> And re-export.
20:22:00 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3439#a3439 <- take a look at that. if you have a large amiunt of fromSomeData cases, ow do you do?
20:22:28 <dolio> You could use a record type.
20:22:52 <not-math> Oh God, thousands of instances.
20:22:56 <dolio> data Request = GET { v :: whatever} | POST { v :: whatever } | HEAD {v :: whatever }.
20:23:02 <not-math> PS2 is not a supercomputer anymore.
20:23:18 <HairyDude> PS2 was a supercomputer?
20:23:21 <kadaver> uyes recordss but i guess
20:23:30 <dolio> HairyDude: According to their marketing, yes.
20:24:11 <dolio> I guess naming those all fromRequest would be a possibility.
20:24:18 <dolio> That'd get your function for free.
20:25:06 <HairyDude> I wouldn't call the PS3 a supercomputer, but it does give you a lot of bang for you buck.
20:25:14 <edwardk> i don't get it, i never had problems before with this many instances
20:25:18 <HairyDude> s/you/&r/
20:25:43 <edwardk> i'm hanging even doing the pairs
20:25:43 <kadaver> can I invertly get the type of the v to? toapply it tosoemhing.
20:26:41 <edwardk> i'm using -O2 -fdicts-cheap, can you think of any problems?
20:26:46 <HairyDude> oh! I just noticed, if ghci fails to load all modules, then you fix the error and reload, it gives you the proper context now
20:27:11 <HairyDude> in 6.8 it would give you the context you got at the point where compilation failed, which was bloody annoying.
20:27:13 <wli> I'm not succeeding in reading Chakravarty's paper.
20:27:13 <MyCatVerbs> HairyDude: sure, if all you ever want to do is masses of floating-point arithmetic. :)
20:27:15 <dolio> They fixed that at some point in 6.8, didn't they?
20:27:22 <dolio> That did bug the hell out of me, though.
20:27:30 <edwardk> there should only be like 196 instances now
20:27:36 <MyCatVerbs> Agreed. Three cheers for the death of that misfeature.
20:28:34 <HairyDude> it was certainly still there in 6.8.2
20:29:41 * HairyDude twiddles his thumbs waiting for patchtag to retry after being greylisted.
20:30:33 <moss> who in their right mind would use haskell for a commercial application
20:30:54 <sjanssen> moss: several companies do
20:31:07 <moss> who
20:31:22 <HairyDude> ah, there it is
20:31:42 <sjanssen> moss: Galois, Credit Suisse, Linspire use or have used Haskell in their business
20:31:43 <HairyDude> though I have a feeling now I don't actually want to put my stuff in a public repo atm
20:31:45 <kadaver> moss: why not?
20:31:58 <HairyDude> thought Galois used OCaml
20:32:00 <sjanssen> moss: BlueSpec
20:32:09 <dons> HairyDude: you're kidding, right? :)
20:32:22 <wli> XenSource/Citrix use ocaml; Galois is known for using Haskell
20:32:23 <HairyDude> oh wait, that's Jane Street
20:32:48 <kadaver> HairyDude: you confuse with Jane Street?
20:32:48 <kadaver> but Jon Harrop said Haskell sucks...
20:33:01 <sjanssen> @quote jdh30
20:33:01 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
20:33:02 <HairyDude> dunno why
20:33:24 <kadaver> Lisp i s dead, long live Haskell!
20:33:25 <HairyDude> I got recruitment ads for Jane Street in gmail for a while
20:33:27 <sjanssen> kadaver: he says lots of things, lots of those things are not strictly true
20:33:30 <kadaver> me too
20:33:47 <kadaver> really o.O ?
20:33:50 <edwardk> HairyDude: i think anyone who receives email about haskell does
20:34:31 <sjanssen> HairyDude: they bought adwords on "Haskell", which makes sense from a recruiting standpoint for them
20:34:40 <dolio> @quote JonHarrop
20:34:41 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
20:34:47 <HairyDude> I considered applying, but then I realised it would mean working in the USA.
20:35:01 <HairyDude> also working in finance, which doesn't really interest me.
20:35:04 <edwardk> dons: for the live of me i can't get this to compile once i add the instances
20:35:14 <edwardk> er i'll post it with them commented down
20:36:06 <dolio> @quote JonHarrop
20:36:07 <lambdabot> JonHarrop says: As the Lispers always say, it is theoretically possible to do a good job but...
20:43:49 <wli> Chakravarty's paper on modules + typeclasses is defying my attempts to understand it for a while longer.
20:48:21 <edwardk> ok, uploaded version unboxed-containers-0.0.1 to hackage -- now faster than Set
20:48:52 <dons> woo!
20:49:07 <edwardk> i couldn't get it to compile when i added the instances for pairs though
20:49:12 <edwardk> just sat there forever
20:49:12 <dons> had a good talk today with iavor diatchki about how to do this with functional dependencies
20:49:19 <dons> we fairly fully explored the design space
20:49:20 <Nafai> How do I ask lambdabot to give me the src for >>= in the State monad?
20:49:26 <edwardk> yeah
20:49:42 <MyCatVerbs> I think it's...
20:49:46 <edwardk> fundeps are no fun =)
20:49:48 <MyCatVerbs> @src (>>=) State
20:49:48 <lambdabot> Source not found. My mind is going. I can feel it.
20:50:04 <kerlo> @src State (>>=
20:50:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:50:06 <kerlo> @src State (>>=)
20:50:07 <lambdabot> Source not found. Do you think like you type?
20:50:10 <kerlo> @src State >>=
20:50:10 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:50:22 <kerlo> @index State
20:50:23 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
20:50:23 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
20:50:30 <kerlo> @src Control.Monad.State.State (>>=)
20:50:31 <lambdabot> Source not found. Take a stress pill and think things over.
20:50:36 <MyCatVerbs> Nafai: screw using lambdabot, hit this up instead: http://www.haskell.org/all_about_monads/html/statemonad.html
20:50:36 <kerlo> @src Control.Monad.State.State >>=
20:50:37 <lambdabot> Source not found. Do you think like you type?
20:50:42 * kerlo yawns.
20:50:43 <shachaf> I suspect it does not have it.
20:50:51 <shachaf> @source Control.Monad.State
20:50:52 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
20:51:27 <Nafai> Heh, that was helpful :)
20:51:47 <edwardk> this should just be able to be implemented as class like class (c `Set` s) | c -> s, s -> c -- no?
20:52:25 <edwardk> making it bidirectional serving the same prupose as the data family letting t a ~ t b => a ~ b
20:52:31 <wli> How is Set an infix type constructor?
20:52:43 <lpsmith> kerlo:  One thing worth considering here is that (>>=) is a instance,  not an indentifier found in Control.Monad.State
20:52:51 <dolio> It's an infix class.
20:53:10 <wli> Ugh, an infix class?
20:53:30 <lpsmith> @src Control.Monad.State.Class (>>=)::State s b
20:53:30 <lambdabot> Source not found. It can only be attributed to human error.
20:53:34 <lpsmith> heh
20:53:43 <lpsmith> well, I obviously don't understand lambdabot
20:53:48 <lpsmith> @src Control.Monad.State.Class (>>=)
20:53:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:53:50 <edwardk> when dealing with binary typeclasses i tend to read them infix as foo-set p indicates that p is a set of foo's -- Char `Set` CharSet
20:53:59 <lpsmith> @src Control.Monad.State.Class.(>>=)
20:54:00 <lambdabot> Source not found. Wrong!  You cheating scum!
20:54:03 <shachaf> lpsmith: @src just looks it up in a lambdabot file.
20:54:05 <edwardk> Char `Reducer` m, etc.
20:54:25 <edwardk> when dealing with binary MPTCs you otherwise lack a good mnemonic for which arg goes first
20:54:48 <shachaf> http://code.haskell.org/lambdabot/State/source
20:54:54 <kerlo> @src [] (>>=)
20:54:54 <lambdabot> xs >>= f     = concatMap f xs
20:55:14 <lpsmith> shachaf:   It actually annoys me somewhat that that the standard GHC documentation no longer includes source files
20:55:49 <lpsmith> occasionally the documentation isn't good enough,  and I find it much easier to take a quick look at the source of the standard libraries
20:55:51 <dolio> The problem with fundeps (or type families) here, as far as I can tell, is that associated data maps exactly to what you're doing, defining constructors to go with each instance.
20:56:23 <dolio> Doing it the other two ways makes you define superfluous datatypes, just to make aliases for them.
20:56:49 <edwardk> dolio: yeah
20:57:14 <shachaf> lpsmith: I tend(ed) to go straight to the .hs.
20:57:24 <dolio> Plus, using them with fundeps would be weird.
20:57:45 <dolio> You'd get signatures like "USet Int s => s -> ..." instead of "USet Int -> ...".
20:58:18 <lpsmith> shachaf:  I have a webserver running on my computer with a lot of standard documentation running for quick reference.   I found the "source" links very handy
20:59:05 <not-math> <3 source
21:05:52 <not-math> Haskell has syntactic sugar. Other languages have syntactic aspartame. If you get my drift. :)
21:06:05 <wli> Chakravarty is translating typeclasses to ML-like functors but it's totally blowing me away.
21:07:27 <wli> Plus MPTC's, AT's, and constructor classes (as distinguished from what other kinds of classes?) are all omitted.
21:08:29 <moss> haskell has phenylaline, aka phenylketuronics
21:08:53 <wli> phenylketonuria
21:15:27 <edwardk> i wonder if it would be possible to make the unpacker smarter with respect to data families and type families so we could cut down on the # of instances needed.
21:15:52 <edwardk> it seems that the moment the unpacker sees anything polymorphic it gets scared - as it should
21:16:24 <edwardk> but when dealing with a type variable that gets fed to a data family or type family that isn't polymorphic in that value it should be able to specialize
21:18:48 <edwardk> then you could make a type family Unboxed a :: * -- type instance Unboxed Int = Int ... and work up a type of pairs of pairs that could use the fact that the pairs are unboxed, and that you can unpack any type that has a single constructor
21:19:29 <edwardk> with the type family telling you that you're not doing so polymorphically.
21:20:45 <edwardk> er what i mean by isn't polymorphic i mean that it has an instance that isn't the quantified case
21:22:53 <kadaver> this is funny, for the first time in my life i have found myself missing Java , I jsut wished a let'ed variable has a type signature :)
21:23:04 <kadaver> but you can annotye types like that right?
21:23:16 <edwardk> you can put one in
21:23:25 <edwardk> > let f :: Int; f = 1 in f
21:23:27 <lambdabot>   1
21:25:29 <wli> There's also
21:25:39 <wli> > let n :: Int = 1 in n
21:25:40 <lambdabot>   1
21:26:10 <not-math> That requires an extension, something about pattern type sig.
21:26:23 <wli> yeah
21:26:29 <kadaver> arse error on input `='
21:26:36 <jmcarthur> > let foo = 5 :: Int in foo
21:26:37 <lambdabot>   5
21:26:40 <kadaver> ah
21:26:50 <jmcarthur> shouldn't need an extension for that one
21:26:53 <kadaver> XScopedTypeVariables
21:26:53 <kadaver> ah thats the one o had ebfore
21:26:54 <kadaver> thta i forgot why i had
21:27:05 <not-math> Right, 5::Int is haskell98 fine.
21:27:34 <edwardk> i thought ScopedTypevariables no longer covered the signature of the method, just the arguments
21:28:27 <wli> > let f (p :: Int) (q :: Int) = p + q :: Int in f 1 2
21:28:28 <lambdabot>   3
21:28:47 <wli> It's more useful for function args.
21:31:18 <wli> > let f (x :: Double) (n :: Int) = x ^ n in f 2 3
21:31:19 <lambdabot>   8.0
21:32:24 <catface> can i ask, why does the function strange x = strange 5 not have type a -> b?
21:33:23 <wli> The argument type is constrained to Num barring polymorphic recursion, I guess.
21:34:54 <wli> If you give it an explicit signature it works.
21:34:59 <catface> yes
21:35:09 <wli> @type let strange :: t -> t' ; strange _ = strange 5 in strange
21:35:10 <lambdabot> forall t t'. t -> t'
21:35:48 <wli> I'm not sure how inference propagates the Num constraint on 5 to the argument.
21:36:10 <catface> no, neither am i :(
21:38:19 <dolio> @type let strange _ = strange 5 in strange
21:38:20 <lambdabot> forall t t1. (Num t) => t -> t1
21:38:37 <wli> The argument appears nowhere in the RHS so the unconstrained argument type variable should subsume Num n => n
21:39:33 <dolio> Inference without type signatures for polymorphic recursion does weird stuff.
21:39:35 <dolio> More or less.
21:39:46 <dolio> @type let strange _ = strange () in strange
21:39:47 <lambdabot> forall t. () -> t
21:39:47 <dj_ryan> quick q for you, whats a good haskell runtime/etc for OSX... ghc doesnt seem to have a modern OSX package
21:39:59 <shapr> Huh, I thought it did.
21:40:29 <Randroid> I'm running GHC 6.10.1 on my Mac. What's the latest?
21:40:40 <Zao> Randroid: .2
21:40:45 <dolio> It apparently just figures out the type of whatever you pass in the recursive call and uses that, if it can.
21:40:53 <dj_ryan> the ghc page makes reference to powerpc macs runing 10.3.
21:41:06 <wli> Yeah, I just don't see how this particular instance of polymorphic recursion has a type less general than possible inferred for it.
21:41:11 <glguy> :t fix (\ strange _ -> strange 5)
21:41:12 <lambdabot> forall t t1. (Num t1) => t1 -> t
21:41:16 <Zao> dj_ryan: "This is an installer for Mac OS X 10.5 (Leopard)."
21:41:25 <dolio> @type let strange x = strange (x,x) in strange
21:41:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
21:41:26 <lambdabot>       Expected type: (t, t) -> t1
21:41:26 <lambdabot>       Inferred type: t -> t1
21:41:26 <glguy> :t \ strange _ -> strange 5
21:41:27 <lambdabot> forall t t1 t2. (Num t1) => (t1 -> t2) -> t -> t2
21:41:48 <dj_ryan> zao: i am not seeing it then...
21:41:54 <Zao> Oh, PPC.
21:42:09 <dj_ryan> ah ha, older release page
21:42:11 <glguy> :t \ f -> f 5
21:42:12 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
21:42:22 <glguy> I think that this is a simpler case of the same issue
21:42:30 <Zao> The 6.10.1 binary download talks about 10.4 and 10.5
21:42:35 * glguy checks in actual ghci ;0
21:42:40 <Zao> http://haskell.org/ghc/download_ghc_6_10_1.html#macosxppc
21:42:42 <edwardk> @tell dons hrmm, i suppose instances for Ratio Integer (Rational) and Complex Float and Complex Double also fit into the framework.
21:42:42 <lambdabot> Consider it noted.
21:43:03 <dj_ryan> zao: you ahve me mistaken, i am on intel, 10.5. i dont do ancient mac :-)
21:43:04 <edwardk> those should be able to unbox nicely
21:43:12 <wli> dolio: I guess the recursions are handled via equating the types vs. the generation of subsumption constraints.
21:43:29 <Zao> dj_ryan: http://haskell.org/ghc/download_ghc_6_10_2.html#macosxintel
21:43:36 <dj_ryan> zao: yeah i got it thanks! :-0
21:43:37 <Zao> Misread you above then in all the lambdabot spam :)
21:43:38 <dj_ryan> :-0
21:43:49 <dolio> @type \f _ -> f ()
21:43:51 <lambdabot> forall t t1. (() -> t1) -> t -> t1
21:44:04 <Randroid> Checking if "sudo port upgrade installed" will upgrade my GHC to .2
21:45:07 <dj_ryan> i rather dislike ports on osx. compiling is not my idea of fn.
21:45:48 <wli> dolio: There's probably a completeness/decidability/etc. problem with using a subsumption rule for argument types in recursion.
21:45:52 <Randroid> dj_ryan: I just like the fact that its easy. I'm a profoundly lazy person.
21:46:00 <dj_ryan> fair enough
21:46:01 <dj_ryan> but
21:46:04 <dj_ryan> compiling boost isnt easy
21:46:16 <dj_ryan> "oh just go away for a few hours while i compile and install you r50 packages"
21:46:23 <dj_ryan> fink = binary distribution = win
21:46:25 <dolio> I have a paper on polymorphic recursion that I've been meaning to read, but haven't.
21:47:30 <Randroid> Are most Haskellers on Linux? I would suspect so.
21:48:10 <wli> I don't envision that particular inference rule inferring all cases of polymorphic recursion, but it seems like that trivial/degenerate case of polymorphic recursion should be done that way for other reasons.
21:49:40 <wli> Mostly having to do with class constraint management.
22:01:03 <pumpkin> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3443#a3443 getting there
22:01:19 <pumpkin> the naming is still up in the air, but since I'm generating all the instances with a script, it's not a pain to change
22:02:37 <pumpkin> that is, the number of elements in each chunk depends on the type
22:03:01 <pumpkin> I stole the actual chunk size from bytestring
22:04:40 <jfredett> So... my project compiles fine -- registers w/ ghc fine, everything goes smoothly, but when I try to load it via :m in ghci, it says "module Data.HCard is not loaded" what gives?
22:05:06 <pumpkin> using cabal?
22:05:06 <jfredett> ooh, hmm
22:05:13 <pumpkin> did you put the module in the listing in the .cabal file?
22:05:23 <jfredett> thats weird- it only fails to load if i'm in my working directory
22:05:28 <wli> Probably have to :l unless it's installed as a package.
22:05:32 <jfredett> pumpkin: what do you mean? I might have... :/
22:05:37 <pumpkin> oh, I've had that happen inside the working dir
22:05:42 <jfredett> wli: it is, so far as I know
22:05:53 <jfredett> pumpkin: does it just get confused by the directory structure?
22:06:04 <jfredett> seems to work now
22:06:08 <pumpkin> does your module rely on external stuff?
22:06:20 <jfredett> I'm gonna write a blog post about this one, a practical, nonscary use for associated types. :)
22:06:39 <jfredett> pumpkin: yah- random-shuffle and quickcheck, not much otherwise, though
22:09:00 <pumpkin> hmm, weird
22:09:48 <vav> > let foo f g = g >>= return . fmap f in foo (+1) [Just 2, Nothing, Just 5]  -- this foo seems like it should be some common function, but not finding it -- or is this clearest way to say this? ([] and Int are simplifications for example. Maybe is really functor.)
22:09:49 <lambdabot>   [Just 3,Nothing,Just 6]
22:10:23 <pumpkin> what's that, concatFmap?
22:10:29 <pumpkin> :P
22:10:37 <pumpkin> fconcatmap?
22:10:46 <wli> > fmap (fmap (+1)) [Just 2, Nothing, Just 5]
22:10:47 <lambdabot>   [Just 3,Nothing,Just 6]
22:11:04 <vav> pumpkin yeah, I've been having a hard time naming it... hehe 'stuttering fmap'?
22:11:13 <pumpkin> probably not concat actually
22:11:18 <Gracenotes> *fmap* *fmap* *fmap* *fmap*
22:11:19 <pumpkin> more like nestedfmap
22:11:26 <pumpkin> Gracenotes: tmi
22:11:31 <jfredett> Gracenotes: ... Awesome.
22:11:39 <wli> vav: All it is is fmap (fmap (+1))
22:12:27 <vav> wli: ah well, already chose bind over that as more readable in actual use case, was afraid of that. Thanks
22:13:07 <jmcarthur> @pl foo f g = g >>= return . fmap f
22:13:08 <lambdabot> foo = fmap . fmap
22:14:03 <vav> hmm, maybe I should re-read. jmcarthur's fmap . fmap is pretty darn clear
22:15:10 <jmcarthur> vav: I recommend reading http://conal.net/blog/posts/semantic-editor-combinators/
22:15:29 <jmcarthur> might give you some intuition on things that look like that
22:16:20 <vav> jmcarthur: neat! Thanks, will do.
22:16:42 <wli> I've been twittering more about health than math, code, or work.
22:17:13 <kadaver> > fmap (fmap (+1)) [[Just 5,Nothing]]
22:17:14 <lambdabot>       No instance for (Num (Maybe t))
22:17:14 <lambdabot>        arising from the literal `1' at ...
22:17:48 <wli> > fmap (fmap (fmap (+1))) [[Just 5, Nothing]]
22:17:49 <lambdabot>   [[Just 6,Nothing]]
22:18:26 <kadaver> > fmap (fmap (+1)) [Just 1,Just 2,Nothing]
22:18:27 <lambdabot>   [Just 2,Just 3,Nothing]
22:18:33 <jmcarthur> > (fmap.fmap.fmap) (+1) [[Just 5, Nothing]]
22:18:35 <lambdabot>   [[Just 6,Nothing]]
22:18:54 <wli> 2 lists + 1 maybe = 3 fmaps
22:19:22 <wli> Basically add up the number of type constructors that are functor instances.
22:19:55 <BMeph> Is there an idiomatic way to say whether a list is full of the same items? I'm drawing a blank, except for what seems a very clunky form.
22:20:19 <wli> BMeph: Set.size (Set.fromList xs) == 1?
22:20:28 <Gracenotes> do you know if the list is non-empty?
22:21:06 <kadaver> im on windows!
22:21:16 <jmcarthur> :t foldl
22:21:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:21:19 <BMeph> Gracenotes: I'm trying to remember, but I think it's always got something in it.
22:21:28 <Gracenotes> @type liftA2 (all . (==)) head tail
22:21:29 <lambdabot> forall a. (Eq a) => [a] -> Bool
22:21:48 <wli> BMeph: It gets better, I guess, since f [] = False ; f (x : xs) = all (== x) xs
22:21:58 <Gracenotes> one way to do it. I've been thinking with applicatives a lot lately though
22:22:13 <Gracenotes> yeah. wli's version is equivalent to mine, except that it accounts for []
22:22:14 <jmcarthur> :t all
22:22:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:22:23 <Gracenotes> and shouldn't f [] = True? :P
22:22:25 <jmcarthur> ah good one
22:22:34 <kadaver> an fmap is TypeX -> TypeX; never TypeX -> TypeY?
22:22:35 <Gracenotes> since all of its elements are trivially equal to each other
22:22:49 <pumpkin> :t fmap
22:22:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:23:07 <jmcarthur> kadaver: no, still different types, just lifted into functors
22:23:07 <BMeph> GracenotesPlease - "vacuously". ;)
22:23:13 <pumpkin> kadaver: it's FunctorX -> FunctorX, but the contents of the functor can be different
22:23:18 <Gracenotes> yes, a better word, BMeph
22:23:19 <kadaver> @type fmap
22:23:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:23:24 <wli> Gracenotes: I took it as Set.size (Set.fromList xs) == 1 vs. other potential definitions.
22:23:32 <jmcarthur> fmap :: Functor f => (a -> b) -> (f a -> f b) -- I like it with parentheses
22:23:46 <Gracenotes> BMeph: degenerately?
22:24:48 <BMeph> Gracenotes: Possibly. But I think "vacuously" fits better.
22:24:50 <jmcarthur> it's like saying A implies B is "trivially true" if it turns out that A is false
22:25:21 <Gracenotes> hm. and "vacuous" doesn't sound as condescending >_>
22:25:47 <wli> "There is one distinct value in the list."
22:26:22 <jmcarthur> "There is at most one distinct value in the list."
22:26:34 <BMeph> Gracenotes: On the contrary, I'd say that "vacuous" sounds very condescending. "Degenerately" sounds pejorative, though.
22:26:43 <wli> That was unclear at the outset.
22:26:45 * BMeph gives himself "word of the day" points
22:27:12 <Gracenotes> connotation association of the day
22:27:27 <jmcarthur> "connotation association"?
22:27:36 <Gracenotes> yes, flows off the tongue, doesn't it?
22:27:37 <BMeph> Gracenotes: Denotative connotation association of the day! ;)
22:27:39 <jmcarthur> repetitive redundant
22:27:55 <anddy> http://thezeitgeistmovement.com/
22:28:02 <Gracenotes> assonant.
22:28:14 <BMeph> Redundently tautological. ;p
22:28:23 <jmcarthur> i like that one
22:28:38 <Gracenotes> compromised spelling
22:28:39 <BMeph> *Redundantly
22:29:19 <Gracenotes> retroactively rectified
22:29:28 <kadaver> is ^ the same as **?
22:29:32 <kadaver> for all inputs?
22:29:36 <kadaver> @type (^)
22:29:37 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:29:40 <kadaver> @type (**)
22:29:41 <lambdabot> forall a. (Floating a) => a -> a -> a
22:29:43 <jmcarthur> nope
22:29:45 <BMeph> kadaver: Of course not! ;p
22:29:59 <kadaver> why ofc not?
22:30:14 <BMeph> Gracenotes: I like "ex-post-fact-checked". ;p
22:30:15 <jmcarthur> @check \x y -> x ** y == x ^ y
22:30:16 <lambdabot>   Add a type signature
22:30:56 <jmcarthur> @check \(x :: Double) (y :: Integer) -> x ** (y :: fromIntegral) == (x ^ y :: fromIntegral)
22:30:56 <lambdabot>   Parse error in pattern at "(y" (column 16)
22:31:05 <jmcarthur> uh, what was i doing?
22:31:21 <jmcarthur> @check \(x :: Double) (y :: Integer) -> x ** (fromIntegral y) == (fromIntegral $ x ^ y)
22:31:21 <lambdabot>   Parse error in pattern at "(y" (column 16)
22:31:45 * BMeph loks frightened at jmcarthur's lapse in type/value distinction...
22:31:49 <jmcarthur> ugh
22:31:52 <jmcarthur> time for bed
22:32:59 <jmcarthur> @check \x y -> (x :: Double) ** (fromIntegral y) == fromIntegral (x ^ y :: Integer)
22:33:00 <lambdabot>   Couldn't match expected type `Integer'
22:33:14 <jmcarthur> that's it!
22:33:15 <jmcarthur> bed
22:33:28 <Gracenotes> oh nos! :X
22:33:32 <Gracenotes> :(
22:35:53 <kadaver> so the difference is types?
22:36:17 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3445#a3445 <- Im trying to udnerstand the whole monad life circus.
22:36:58 <dolio> (^) computes powers via repeated multiplication, so it requires integers in the exponent.
22:37:19 <dolio> (^^) works on fractional bases, so it can have negative exponents.
22:37:29 <kadaver> aha
22:38:11 <dolio> (**) works on real or complex bases/exponents.
22:38:57 * edwardk had a similar issue in the monoid lib, i needed every monoid to be a module over the naturals, and every group could be a module over the integers. i.e. you could 'repeat' a group value a negative number of times, but not one from a monoid
22:40:22 <kadaver> i see
22:40:22 <kadaver> liftVector :: ([a] -> [b]) -> Vector a -> Vector b
22:40:22 <kadaver> liftVector f v = Vector (f (fromVector v))
22:40:22 <kadaver> i was told that isnt a correc t use of lift(now it isnt lift anyway )
22:40:22 <kadaver> data Vector a = Vector { fromVector :: [a] } deriving(Eq, Show)
22:40:48 <edwardk> ok, my compromise on the unboxed stuff is i allow you to repeat the same type in an unboxed tuple up to 9 times, but not to mix types.
22:41:09 <edwardk> i may allow you to mix them in pairs, and repeat the same type a ton of times beyond that later
22:42:04 <edwardk> that lets you abuse this to save a ton of boxing if you really really want to
22:43:02 <pumpkin> it'd be really cool for lazy ByteStrings to adapt their chunk size to an optimal one for your cache
22:43:39 <edwardk> hard to know, that optimality threshold depends on a lot about what you're using them for
22:44:03 <edwardk> pumpkin: i'm looking at a tunable chunking strategy for my generators though
22:44:07 <pumpkin> it could be a bit like fftw
22:44:11 <pumpkin> timing-based :P
22:44:17 <pumpkin> but that sounds awfully stateful
22:44:44 <edwardk> microbenchmarks can be scarily inaccurate as predictors of how a larger system works
22:45:20 <edwardk> now, tuning it as you run based on profiling information... ;)
22:45:46 <edwardk> after all whats the consequence of having a chunk thats too big? its just a little too slow, so nothing prevents you from mixing chunk sizes
22:45:55 <pumpkin> yeah
22:47:19 <edwardk> my current thought with the generators is to spit out a type level brand of things that obey the same parallelization strategy. i could have that brand hold an IO ref or something terribly evil like that that tracked what it thought was the current optimum. since i only expose monoidal reductions and never any internal structure that remains spiritually functional ;)
22:48:01 <wli> Microbenchmarks are pure unadulterated Grade A Texas Bull ****
22:48:37 <wli> Almost everything runs icache cold unless it's a rather tight loop.
22:48:55 <wli> dcache cold, too.
22:49:21 <wli> And TLB misses to boot (barring superpaged affairs).
22:50:05 <wli> $DEITY help you if you provoke any more kernel/user context switches or IPI's than strictly necessary.
22:50:29 <pumpkin> there's a lot of repetitive crap in writing this lazy UArr thing
22:50:48 <pumpkin> lucky I'm generating it all :P
22:51:30 <edwardk> pumpkin: hah
22:51:44 * pumpkin looks guilty though... the generator script is in ruby :(
22:51:49 <edwardk> let me know when its done so i can bolt a generator instance on it ;)
22:51:56 <pumpkin> aw
22:51:57 <pumpkin> nope
22:52:10 <edwardk> just what i need another install requirement ;)
22:52:26 <pumpkin> I was going to use TH but it apparently can't generate associated types until a couple of days ago
22:52:36 * edwardk renames monoids to 'kitchen-sink'
22:52:42 <pumpkin> sounds about right :P
22:53:08 <edwardk> i'm tempted to make most requirements into flags, but those can interact in funny ways if someone installs the package you need later
22:53:33 <pumpkin> if I wanted to make a mutable list (in ST), would I stick STRefs into my cons constructor?
22:54:31 <pumpkin> my question is whether the mutable version of lazy UArrs should have a mutable spine, or just mutable chunks
22:54:39 <pumpkin> I'm tempted to give it a mutable spine
22:54:41 <edwardk> i'd say that you'd have to have a mutable list be a STRef pointing to a list which links using STRef's
22:54:48 <edwardk> hrmm
22:55:30 <edwardk> i guess there's two granularities of mutable lazy UArr, one with a mutable spine and one where you can mutate both the spine and the uarrs themselves
22:55:36 <pumpkin> yeah
22:55:39 <halberd> in type theory what is the difference between the set of functions A -> B and the implication set A \supset B?
22:55:42 <pumpkin> that's what I meant
22:55:50 <pumpkin> I'm tempted to make both mutable
22:55:53 <halberd> \supset is the proper superset symbol
22:56:06 <halberd> that looks like a horseshoe open to the left
22:56:19 <pumpkin> so something like data MutList s a = Nil | Cons (STRef s a) (STRef s (MutList s a))
22:56:33 <edwardk> halberd: they are basically the same idea. the curry howard correspondence relates them
22:57:08 <pumpkin> in my case, it would actually be something like
22:57:52 <pumpkin> MLUArr s a = Empty | Chunk (MBUArr s a) (STRef s (MLUArr s a))
22:58:09 <pumpkin> does that look reasonable?
22:58:19 <pumpkin> or is it too mutable? :P
22:58:31 <edwardk> not quite
22:58:40 <edwardk> i'd say that you're one indirection off.
22:58:46 <pumpkin> hmm?
22:59:19 <Gracenotes> looks like you have a case of STRef throat
22:59:20 <pumpkin> oh you mean to be able to replace the payload of each chunk?
22:59:28 <pumpkin> in a single go?
22:59:30 <edwardk> data MLUArr s a = STRef (MLUArr' s a); data MLUArr' s a = Nil | Cons (STRef s a) (MLUArr s a)
22:59:37 <edwardk> you miss the first STRef
22:59:43 <edwardk> otherwise i can never mutate a Nil
23:00:06 <edwardk> data MLUArr s a = STRef s (MLUArr' s a)
23:00:13 <pumpkin> ah, I see
23:00:14 <edwardk> -- had typo
23:00:48 <pumpkin> hmm, is that too general?
23:00:54 <pumpkin> oh I see
23:00:58 <pumpkin> you left out the MBUArr bit
23:01:21 <yakov> hey
23:01:25 <edwardk> yeah there is still a prime in the reference
23:02:14 <pumpkin> data MLUArr s a = STRef (MLUArr' s a); data MLUArr' s a = Nil | Cons (MBUArr s a) (MLUArr s a)                vs.           data MLUArr s a = STRef (MLUArr' s a); data MLUArr' s a = Nil | Cons (STRef s (MBUArr s a)) (MLUArr s a)
23:02:18 <pumpkin> :P
23:02:37 <pumpkin> that has got to be one of the least readable types ever
23:03:08 <edwardk> the latter seems gratuitous to me
23:03:12 <pumpkin> (the question is basically whether to stick the payload in an STRef too for O(1) replacement)
23:03:19 <pumpkin> yeah, I kind of agree :P
23:03:27 <halberd> this text on type theory I am reading seems to go into a lot of detail on syntactic sugar
23:03:38 <Gracenotes> which text?
23:03:39 <edwardk> you can emulate it in the absence of a second mutator with the first
23:03:44 <mmorrow> vacuum can handle undefined now, thanks to a suggestion from nominolo
23:03:48 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.91
23:03:52 <edwardk> mmorrow: nice
23:03:52 <halberd> is there a minimalist type theory, with as few primitives as possible?
23:03:57 <edwardk> vacuum is a sexy beast
23:03:57 <pumpkin> edwardk: oh, true
23:04:07 <pumpkin> edwardk: yeah, I'll be using it a lot once this is done :P
23:04:07 <mmorrow> edwardk: weee :)
23:04:13 <edwardk> halberd: i kind of like working form the concept of pure type systems
23:04:24 <halberd> this one Gracenotes : http://www.cs.chalmers.se/Cs/Research/Logic/book/
23:04:25 <Gracenotes> dynamic types are pretty minimalist
23:04:40 <edwardk> vacuum is single handedly responsible for my recent obsession with memory representation ;)
23:04:46 <Gracenotes> if piles of runtime errors turn you on
23:04:59 <edwardk> mmorrow; so do you just getTag and check to see if its an error or something?
23:05:00 <halberd> dynamic types != type theory
23:05:03 <mmorrow> edwardk: haha, me too
23:05:15 <mmorrow> edwardk:
23:05:23 <mmorrow> grab :: IO a -> (SomeException -> IO a) -> IO a; grab = catch; defined :: HValue -> IO HValue; defined a = grab (return $! a) (return . unsafeCoerce#)
23:05:24 <pumpkin> mmorrow: I think it's gotten a lot of people obsessed with representations :P
23:05:31 <Gracenotes> halberd: indeed. dynamic types is basically one big type.
23:05:49 <mmorrow> and then "defined" all the ptrs returned from unpackClosure#
23:06:13 <halberd> well I want a minimalist, yet rich type theory, capable of expressing as much as standard type theory
23:06:14 <mmorrow> ooh, i almost forgot
23:06:21 <mmorrow> this is from "vacuum undefined":
23:06:27 <mmorrow> http://moonpatio.com/vacuum/gallery/undefined.png
23:06:51 <mmorrow> (the String that is "..."'ed just says:
23:06:53 <mmorrow> , undefined
23:06:56 <lunabot>  luna: Prelude.undefined
23:07:02 <edwardk> ... = undefined?
23:07:05 <mmorrow> "Prelude.undefined"
23:07:15 <Gracenotes> halberd: seems a little.. much to ask. hm.
23:07:38 <mmorrow> i "..."ed it manually with vacuumTo, but it'll show the whole thing with vacuum
23:07:56 <mmorrow> hmm, maybe i should truncate that by default, could get annoying
23:07:58 <edwardk> mmorrow: now here is a question, can vacuum suck things up without changing what is evaluated?
23:08:07 <halberd> I don't think it sounds like much to ask, just combinatory logic + types
23:08:24 <halberd> unless there is some fundamental problem in that approach
23:08:26 <mmorrow> edwardk: unfortunately at the moment it systeriously segfaults if everything isn't forced
23:08:42 <edwardk> mmorrow: sad
23:08:57 <mmorrow> but once i figure out why i'm sure that can be fixed
23:09:05 <edwardk> mmorrow: i'd love to see it with the actual thunks out there
23:09:15 <mmorrow> yeah me too, that'd be interesting
23:09:43 <edwardk> the other question is would it be possible to have an option to label the edges with their slot # or record field selector?
23:09:58 <edwardk> the latter probably is too hard but the former might not be
23:10:51 <mmorrow> edwardk: ah yeah, so i think i'm going to use andyjgill's dotgen package in combo with the new "Draw" datatype in vacuum to make the .dot generation much more featureful
23:11:01 <halberd> for example does type theory HAVE to have the whole concept of arity?
23:11:10 <halberd> in addition to types?
23:11:18 <mmorrow> edwardk: that reminds me, did you ever get ubigraph working?
23:11:31 <edwardk> halberd: no, you can curry things down to single argument functions
23:11:42 <edwardk> mmorrow: no, it ate my machine, so i put it away
23:11:44 <dons> mmorrow: could vacuum provide 'sizeOfValueinBytes' /
23:11:44 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
23:11:53 <edwardk> haxr and some stuff seemed to want to install a bunch of contradictory requirements
23:12:12 <mmorrow> edwardk: because i made a really thin wrapper over the C "examples/client.c" in the ubigraph tarball that only depends on a few C libs
23:12:21 <dons> edwardk: cool Map looks nice specialised.
23:12:35 <edwardk> did you jump in and do it?
23:12:45 <halberd> edwardk: really? my book uses arity in a complicated way
23:12:46 <mmorrow> edwardk: i can stick that in a darcs repo if you want to try it
23:12:50 <dons> oh i thought http://comonad.com/haskell/graphs/USetChar.gif was. but now i release it is a Set.
23:12:55 <dons> uses the same Bin/Tip constructors :)
23:12:56 <edwardk> yeah
23:13:12 <edwardk> thats why i'm contemplating whether or not i can recycle some of the machinery for both
23:13:15 <halberd> like an abstraction might have arity 0 --> (0 --> 0)
23:13:17 <mmorrow> dons: hmm, i think it could. JaffaCake made a blog post about something like that iirc, right?
23:13:24 <halberd> if it has 2 unbound variables
23:13:29 <edwardk> and if it makes more sense to have a single monolithic 'Unboxed' class that covers both USet and UMap
23:13:38 <halberd> that's already curried but it still has the arity
23:13:47 <mmorrow> dons: and he (was that him?) used unpackClosure# i think, so yeah that should be doable for usre
23:13:49 <mmorrow> *sure
23:13:58 <dons> mmorrow: yes. there's a version of  the script here: http://code.haskell.org/~dons/code/adaptive-containers/scripts/size.hs
23:14:09 <dons> mmorrow: but i don't think it is accurate in the presence of unboxed fields
23:14:13 <mmorrow> dons: ooh nice
23:14:15 <mmorrow> hmm
23:14:30 <dons> it's not looking at the literals
23:14:39 <dons> so it underestimates specialized things
23:14:58 <dons> edwardk: so providing the primitives for all the container types... ?
23:15:07 <dons> good way to have both fast and general interfaces to things. :)
23:15:30 <edwardk> yeah
23:16:09 <mmorrow> dons: i'm not positive, but i think the ByteArray# of the ptrs might just be a ByteArray# of literally ptrs := machine words, but i'm not positive
23:16:16 <edwardk> operations like balancing are largely independent of how you key the structure
23:18:24 <bos> dons: what's the adaptive-containers package?
23:20:05 <edwardk> ok. after everything today i'm at 36% faster than a normal set. that doesn't suck considering i started at half the speed and only reached 7% slower this afternoon some time
23:20:38 <edwardk> bos: automatic packing and unpacking of unboxable tuples using data families
23:20:55 <edwardk> bos: and lists that use the same trick to bind the elements to the spine
23:21:49 <bos> I see. What's the aim, better performance and memory density?
23:21:54 <edwardk> yeah
23:22:07 <edwardk> i've been doing the same thing to Set. will be tackling Map in a bit
23:22:16 <edwardk> easy to use unboxed containers
23:22:53 <edwardk> http://comonad.com/haskell/graphs/Set.gif vs. http://comonad.com/haskell/graphs/USet.gif
23:24:05 <kadaver> how do you do to make Packages that install under for example Data? I have BST,RBT and making KDTree, i mgiht just amke an AVL-tree and finsih my haldfone huffmnaTree and then put a Tree package on Hackage. it should install under Data I guess? So you have Data.RedBlackTree etc.
23:24:59 <edwardk> kadaver: you make a folder named Data in your package and you put it in there and reference it by Data.Whatever
23:26:32 <edwardk> bos: http://comonad.com/haskell/unboxed-containers/dist/doc/html/unboxed-containers/Data-Set-Unboxed.html
23:28:39 <mmorrow> dons: hmm, now that i think about it, of course they're ptrs. the interesting pieces would be in the literals i guess. yeah, vacuum could definitely attach size-of-closure-in-bytes to each HNode as it walks through the graph.
23:30:42 <mmorrow> data Closure = ..., closLitBytes :: Int, closPtrBytes :: Int, closOtherBytes :: Int, ..
23:30:45 <mmorrow> or something
23:30:59 <mmorrow> err, i mean s/Closure/HNode/
23:31:51 <kadaver> is there no way to do some kind of inheritance where you implement some functions for several Trees? like findMinimum is the same for BST and RBT etc
23:32:53 <mmorrow> oh snap, i think i just realized how to get at the (StgClosure *) of an arbitrary "a" so i can pass it to a C "foo_t *dostuff(StgClosure *o)" and go nuts
23:33:27 <mmorrow> (just peek Addr#'s off the ByteArray# of ptrs (??))
23:33:39 <mmorrow> that might be asking for trouble though..
23:38:23 <mmorrow> err, does ghc put, say in data Foo = Foo {-# UNPACK #-} !Double, does the unboxed 64bit double get put inside the constructor?
23:38:31 <mmorrow> and what about for:
23:38:39 <wli> re
23:38:47 <mmorrow> data Foo = Foo {-# UNPACK #-} !Double {-# UNPACK #-} !Int
23:39:28 <mmorrow> (how would that work with the array of literals (:: Array Int Word) that unpackClosure# gives to you?)
23:40:09 <edwardk> mmorrow: iirc isn't the packing mentioned in the information about the tag? i seem to recall there being two encodings one for bunch of pointers then stuff and another that could be mixed
23:40:10 <pumpkin> I think it is equal to struct Foo { double x; } and the non-unpacked one is struct Foo { DoubleBox *x; }
23:40:24 <pumpkin> or is it more complicated than that?
23:40:36 <pumpkin> equal = roughly equivalent
23:40:40 <mmorrow> edwardk: ahh, you're right. i think there might be a bitmap in that case (maybe)
23:40:52 <edwardk> there was a bitmap version and one with a couple of integers
23:44:38 <mmorrow> nice, for (data Foo = Foo {-# UNPACK #-} !Double {-# UNPACK #-} !Int) and (foo = Foo pi 42) the literals are
23:44:48 <mmorrow> nodeLits = [4614256656552045848, 42, 1079543616],
23:45:25 <mmorrow> i can't remember what that third weird literal that always seems to be there is, i thought it was a ptr to something, but maybe it's a bitmap
23:45:51 * mmorrow tries to track down where he read about that
23:45:56 <edwardk> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary%2FRts%2FHeapObjects
23:46:04 <edwardk> look up bitmap layout: small bitmaps
23:46:20 <mmorrow> edwardk: nice, i think that might be the place
23:47:32 <edwardk> now to figure out if you can reverse engineer from that name you have handy to figure out what typeable/data instance you should use to unpack the slots ;)
23:48:09 <mmorrow> from PrimOps.cmm unpackClosure#
23:48:11 <mmorrow> W_[BYTE_ARR_CTS(nptrs_arr) + WDS(p)] = StgClosure_payload(clos, p+ptrs);
23:48:18 <kadaver> but to make a package should I have Data/RedBlackTree/RedBlackTree.hs or Data/RedBlacktree.hs ?
23:48:29 <edwardk> Data.Tree.RedBlack
23:48:32 <edwardk> would be more idiomatic
23:48:46 <mmorrow> so it guess figuring out what it is is just a matter of finding the macro/function def of StgClosure_payload
23:49:13 <edwardk> should be in Closures.h iirc
23:49:16 <mmorrow> edwardk: ooh, that could be interesting (the typeable key)
23:50:04 <edwardk> hrmm apparently not
23:50:15 <mmorrow> it's in one of those
23:50:36 <mmorrow> (*Closure*.{c,h}, InfoTables.h, ..)
23:50:46 <mmorrow> (or maybe in Cmm.h)
23:50:56 <edwardk> http://darcs.haskell.org/ghc/includes/ClosureTypes.h tells you what the kinds of them are but thats useless
23:51:08 <mmorrow> hmm
23:51:09 <edwardk> although, more useful when you start dealing with unevaluated ones
23:51:11 <edwardk> ;)
23:51:21 <mmorrow> heh
23:51:44 <edwardk> http://darcs.haskell.org/ghc/includes/InfoTables.h has MK_BITMAP
23:53:14 <edwardk> ok, now that the unboxed set stuff proved to be a resounding success i should tackle Map
23:53:50 * mmorrow cheers edwark on
23:53:54 <kadaver> edwardk: ok but should redblack have its own dir? seems nicer than havign all trees int he same dir
23:55:06 <edwardk> kadaver: the usual convention is to break things up into (Data|Control|Numeric).(GeneralIdea).WhateverItIs and then you can make Data.Tree.RedBlack.Internals Data.Tree.AVL, etc.
23:55:39 <edwardk> kadaver: its awfully hard to make a data structure in haskell that takes more than a file to describe ;)
23:57:06 <edwardk> ok, eyeballing containers, and working my way down the list we have Data.Tree, Data.Map, Data.Sequence... woooo Data.Sequence
23:57:14 <edwardk> unboxed Sequences?
23:57:16 <wli> a module system might help
23:58:52 <ski> (unboxing the elements or the structure itself ?)
23:59:04 <edwardk> the elements
