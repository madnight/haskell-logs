00:00:24 <pumpkin> :t empty
00:00:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
00:00:31 <Gracenotes> they're required to obey very different laws
00:00:58 <nanothief> :t mempty
00:00:59 <lambdabot> forall a. (Monoid a) => a
00:02:13 <nanothief> pumpkin, is there an instance where mempty is different from empty? (The only instances I know of so far of Alternative is [] and Maybe)
00:02:21 <Gracenotes> actually, are they? .. hm
00:02:41 <pumpkin> well, they're dealing with different things sort of
00:03:00 <Gracenotes> well, the laws should be the same, I think, in terms of associativity and identity
00:03:03 <pumpkin> yeah
00:03:41 <andresj> @src isLetter
00:03:42 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:03:43 <pumpkin> but a Monoid is on a type, not a type constructor
00:03:54 <Gracenotes> you can make a Monoid instance of an Int (several, actually). you can't make an Int into an Alternative
00:03:54 <pumpkin> isn't it something like that? I don't really know how else to explain it
00:05:08 <nanothief> Gracenotes: thats true. What I'm thinking is (Monoid (f a), Applicative f) is the same as Alternative f
00:05:20 <dibblego> is there a mapM_ for Maybe? Traversable has mapM but no mapM_
00:05:35 <Gracenotes> Maybe is a monad, ain't it?
00:05:38 <nanothief> mapM_ is in Foldable
00:06:20 <pumpkin> nanothief: that sounds reasonable, yeah
00:06:45 <Gracenotes> well.. *that* mapM
00:07:19 <Gracenotes> oh, by the way: did you know that when you use Haskell, you donate to charitable oranizations? With IO or ST, you hold every single item in the world in your unboxed state tuple. You may think you're just printing something to stdout, but the world changes and your Haskell code causes charitable organizations to get money (so long as a donation occurred during the printing)!
00:07:34 <Gracenotes> it's true.
00:08:04 * Gracenotes wonders what would happen to RealWorld if you used Haskell in outer space
00:08:45 <nanothief> pumpkin, right thanks, I thought I might have been missing something more with this
00:09:03 <pumpkin> nanothief: if you check the source of Applicative, it actually says so in a comment, too :P
00:09:20 <pumpkin> I wonder why they insist on reinventing the wheel in so many base packages
00:09:29 <QtPlaty[HireMe]> Gracenotes: The world is no less real in outerspace.
00:10:12 <Gracenotes> well, it might get destroyed at any moment. There must be a lot of latency, constantly checking if it's real or not
00:10:48 <nanothief> pumpkin, maybe because people keep coming up with new abstractions, and old abstractions aren't integrated or removed if no longer needed
00:11:27 <pumpkin> well applicative was pretty recent wasn't it? if they acknowledge in the source that it's a monoid, they could've just reused existing Monoid instances
00:11:29 <Gracenotes> what's the suggestion for monad? Applicative m => Monad m?
00:12:13 <andresj> is there a function f "something ha" = "Something Ha"
00:12:15 <andresj> ?
00:12:34 <andresj> in H98 i mean
00:13:04 <sm> toUpper
00:13:06 <Gracenotes> nothing built-in
00:13:30 <andresj> hum... so what is the opposite of join?
00:13:39 <pumpkin> opposite?
00:13:43 <Gracenotes> cojoin! :)
00:13:43 <andresj> i shall implement my own f, then :P
00:13:47 <andresj> lol
00:13:54 <sm> split in the split package on hackage
00:13:54 <andresj> like Python's split
00:14:00 * sm has all the answers tonight
00:14:03 <Gracenotes> there's 'words'
00:14:11 <Gracenotes> if you just need splitting on words, discarding whitespace
00:14:35 <Deewiant> > unwords . map ((:) . toUpper . head <*> tail) . words $ "something ha"
00:14:35 <andresj> words
00:14:36 <lambdabot>   "Something Ha"
00:14:43 <andresj> haha uu awesome
00:14:47 <andresj> thank you!! :D
00:15:00 <andresj> but i dont get why split is in a separate package
00:15:09 <Gracenotes> > let f = unwords . map (liftM2 (:) (toUpper . head) tail) . words in f "something ha" in f "oh damn, Deewiant posted seconds before me!"
00:15:10 <lambdabot>   <no location info>: parse error on input `in'
00:15:14 <Gracenotes> :O
00:15:15 <QtPlaty[HireMe]> :t (<*>)
00:15:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:15:17 <Deewiant> :-P
00:15:28 <Deewiant> Gracenotes: Double "in"
00:15:30 <Gracenotes> > let f = unwords . map (liftM2 (:) (toUpper . head) tail) . words in f "bad parser, bad!"
00:15:31 <lambdabot>   "Bad Parser, Bad!"
00:16:40 <nanothief> writing those little functions is so much more fun in haskell than other languages
00:16:57 <andresj> i know
00:16:58 <andresj> lol
00:17:09 <andresj> altho ill take longer to do it :P but ill end up mastering it, haha
00:19:13 <Gracenotes> there are plenty of examples that are obfuscated just by a high density of concepts :)
00:20:02 <Gracenotes> rather than by bit switching, extra control flow, or name-changing, as you see in other languages.
00:20:18 <pumpkin> look ma, no loops or variables
00:21:04 <Gracenotes> yeah; it can be hard to keep track of when you have no variables whatsoever :P writing in an applicative/pointfree style
00:21:04 <andresj> :P
00:21:07 <dolio> Those aren't obfuscated. They're just clarified so well that they're hard to understand.
00:21:36 <pumpkin> no variables is clearer in many cases
00:21:47 <pumpkin> and a lot less clear in others :P
00:21:49 <Gracenotes> well. my obfuscated pride and joy: putStrLn.unlines.(!!3).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
00:21:59 <pumpkin> lol
00:22:08 <pumpkin> > unlines.(!!3).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
00:22:09 <lambdabot>   "               /\\\n              /__\\\n             /\\  /\\\n          ...
00:22:15 <pumpkin> lol
00:22:31 <pumpkin> pretty awesome
00:22:33 <Gracenotes> you can run it in ghci.. requires Control.Applicative
00:22:36 <pumpkin> yeah
00:22:53 <pumpkin> pretty hot :)
00:23:12 <Gracenotes> and bigger ones by changing 3 -> 4 or 5
00:23:29 <Gracenotes> it literally just iterates
00:24:04 <pumpkin> pretty nice :)
00:24:23 <Gracenotes> > fix $ (0:) . (1:) . (=<< [1..]) . ((<*>) . ((return .) . (+) <$>) <*> (. subtract 1)) . (!!) -- also on the menu
00:24:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:24:49 <Gracenotes> it can start out as normal code, but simply manually factoring out variables can make it quite unclear
00:24:51 <pumpkin> lol
00:25:03 <Gracenotes> but beautiful, of course
00:25:42 <opqdonut> result and argument and all those structural editor combinators can make code like that clearer
00:25:51 <andresj> @.
00:25:51 <lambdabot> Not enough arguments to @.
00:26:03 <opqdonut> fmapifying code is my favourite obfuscation :O
00:26:03 <pumpkin> clearer = more characters = less golf
00:26:04 <pumpkin> :P
00:26:12 <andresj> @. help
00:26:13 <lambdabot> Not enough arguments to @.
00:26:17 <andresj> @help @.
00:26:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:26:22 <nanothief> using 5 gives very nice output, my monitor isn't big enough for 6 :(
00:26:22 <andresj> @help .
00:26:23 <lambdabot> . <cmd1> <cmd2> [args].
00:26:23 <lambdabot> . [or compose] is the composition of two plugins
00:26:23 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
00:26:34 <dolio> > fix $ (0:) . scanl (+) 1
00:26:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:26:42 <Gracenotes> oh, lambdabot, how you tease us with your semantics
00:26:47 <andresj> @pointful  putStrLn.unlines.(!!3).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
00:26:48 <lambdabot> (putStrLn (unlines ((iterate (((++) <$> \ x -> ((++) >>= (<$>)) (x >> " ")) <*> ((<$>) (((<*>) (((\ f -> (\ c d e -> c (d e)) <$> f) <*> \ g h i -> g i h) (++))) <*> (takeWhile (\ j -> j == ' ')))))
00:26:48 <lambdabot> ([" /\\", "/__\\"])) !! 3)))
00:27:20 <andresj> @. pointful pretty  putStrLn.unlines.(!!3).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
00:27:21 <lambdabot> (putStrLn (unlines ((iterate (((++) <$> \ x -> ((++) >>= (<$>)) (x >> " ")) <*> ((<$>) (((<*>) (((\ f -> (\ c d e -> c (d e)) <$> f) <*> \ g h i -> g i h) (++))) <*> (takeWhile (\ j -> j == ' ')))))
00:27:21 <lambdabot> ([" /\\", "/__\\"])) !! 3)))
00:27:30 <Gracenotes> andresj: doesn't help much, since most of tricks are using specific instances of Monad and Applicative
00:27:41 <andresj> haha i see
00:27:54 <andresj> i shud make it a project to implement that function
00:27:56 <andresj> :P
00:28:09 <zakwilson> What's this? Obfuscated Haskell?
00:28:17 <pumpkin> andresj: did you try it in ghci?
00:28:24 <andresj> haha yes i did
00:28:41 <andresj> its pretty cool, specially how u can change the size
00:28:44 <pumpkin> Gracenotes: you could fit that in a tweet... if you had twitter ;)
00:29:39 <Gracenotes> not with the import, alas.
00:29:57 <pumpkin> it's good enough
00:30:09 <pumpkin> the <$> and <*> are pretty obvious in it
00:30:20 <pumpkin> most people who have been using haskell for more than a few months will know where to look
00:30:43 <andresj> i second pumpkin's opinion ;P
00:31:08 <pumpkin> Gracenotes: so get a damn twitter account and show the world your obfuscation/golf skilz
00:31:14 <pumpkin> :P
00:32:34 <andresj> well ill be going---thank you all for your help! :-)
00:32:45 <pumpkin> come again!
00:32:52 <andresj> haha i will, i will
00:32:56 <andresj> :P
00:34:21 <Gracenotes> hidden in there is a nice way to pl \x -> x ++ f x ++ x, mentioning (++) only once
00:34:37 <opqdonut> fold ;)
00:35:03 <pumpkin> @pl \x -> x ++ f x ++ x
00:35:03 <lambdabot> ap (++) ((++) =<< f)
00:35:56 <Gracenotes> does mention (++) twice
00:36:07 <pumpkin> I know :) just wanted to see what the default output was
00:37:22 <Gracenotes> it more models ((++x) . (x++)) f x than anything
00:37:46 <dolio> @pl \(++) x -> x ++ f x ++ x
00:37:46 <lambdabot> (line 1, column 3):
00:37:47 <lambdabot> unexpected "+"
00:37:47 <lambdabot> expecting pattern
00:38:03 <dolio> @pl \g x -> x `g` f x `g` x
00:38:04 <lambdabot> join . ap (.) (`ap` f)
00:38:13 <pumpkin> ah
00:38:39 <pumpkin> @pl \x g -> x `g` f x `g` x
00:38:39 <lambdabot> flip =<< ap id . ap (flip . flip id) f
00:38:43 <pumpkin> boo :)
00:39:00 <Gracenotes> what I came up with was: (liftM2 (.) =<< flip) (++) <*> f
00:39:18 <dolio> > (join . ap (.) (`ap` reverse) $ (++)) [1..5]
00:39:20 <lambdabot>   [1,2,3,4,5,5,4,3,2,1,1,2,3,4,5]
00:39:22 <Gracenotes> doesn't win too many prizes for brevity, but it works
00:39:49 <Gracenotes> and looks a bit symmetrical, compared to the other things I considered
00:40:26 <pumpkin> Gracenotes: what did you start out with before golfing it down to the thing you pasted earlier?
00:40:35 <Gracenotes> I used <*> instead of =<<, since it doesn't matter which one you flip
00:41:58 <Gracenotes> well, I started out with replicateM for State, but here's the iterate version: putStrLn . unlines . (!!3) . iterate (\s -> map (\r -> replicate (length s) ' ' ++ r) s ++ map (\r -> r ++ (takeWhile (==' ') r) ++ r) s) $ [" /\\","/__\\"]
00:42:33 <Gracenotes> I didn't even start out that ungolfed.. I mostly just made it simpler, but andresj left
00:42:38 <pumpkin> aw
00:44:51 <Gracenotes> pumpkin: actually, it was based on Ruby, and the imperative version (with functional idioms) is a bit shorter. http://codepad.org/H7tkDjlr
00:45:15 <pumpkin> lol
00:45:40 <Gracenotes> now, that's pretty elegant.
00:46:50 <johnw> pretty
00:47:21 <Gracenotes> golfing in Haskell mostly involves pointfree, which doesn't always show the control flow so much as exploit small tricks regarding what function variables are required where
00:47:46 <Gracenotes> many times it can be elegant in Haskell, though
00:48:10 <Gracenotes> but still, if there is a moral here, pointfree can be taken to an extreme :) anywahs.
00:51:21 <Gracenotes> @vixen pointfree can be taken to an extreme
00:51:22 <lambdabot> too many perverts send out sick pictures of themselves. what type of man does that?
00:51:47 <nanothief> ...right
00:52:17 <sayyestolife> haha wtf lambdabot :D
00:52:31 <nanothief> anyway, bash+ghci one liner: echo -e "import Control.Applicative\n   (>>) (print ()) $ putStrLn.unlines.(!!3).iterate((++)<\$>((<\$>)=<<(++).(>>\" \"))<*>(<\$>)(((<*>).((.)<\$>)<*>flip)(++)<*>takeWhile(==' ')))\$[\" /\\\\\\\",\"/__\\\\\\\"]" | ghci
00:53:14 <Gracenotes> sayyestolife: lambdabot knows what it's like to be a valley girl sohphomore at UCLA
00:53:20 <sayyestolife> :)
00:57:04 <johnw> Gracenotes: your oneliner for bash gives me: <interactive>:1:50: parse error on input `;'
00:57:21 <johnw> bash 3.2.17 and ghci 6.10.1
00:57:24 <Gracenotes> take complaints to nanothief! :o
01:00:02 <eu-prleu-peupeu> hi
01:00:14 <eu-prleu-peupeu> have you seen the demo made by blala for breakpoint 2009 ?
01:00:51 <nanothief> johnw, parse error on ';'??? There isn't even one in the statement :P
01:01:17 <johnw> i just copied and pasted
01:01:34 <johnw> i agree, it hast left me flummoxed
01:01:43 <Cale> It's a layout problem
01:01:44 <nanothief> heh very strange :S
01:01:46 <johnw> oh, there's a ;bash3 there
01:01:56 <johnw> ah, the !!
01:01:59 <johnw> needs escaping
01:02:08 <johnw> here it's a history reference
01:02:09 <nanothief> ahh, I have history expansion disabled
01:02:19 <Cale> oh! You're using ghci
01:02:28 <nanothief> (for this very reason)
01:02:46 * johnw hugs his history expansion
01:02:53 <Gracenotes> oh, no wonder why that was bash3 for me too!
01:03:01 <Gracenotes> always gets me with Haskell code
01:03:14 <Gracenotes> .. well, when I rarely use bash with it..
01:04:56 <Gracenotes> hm. Is there a way to load modules when using ghci -e?
01:05:19 <Gracenotes> seems to be limited compared to some other languages
01:14:04 <dibblego> @pl fromMaybe []
01:14:05 <lambdabot> fromMaybe []
01:17:56 <edwardk> @type fromMaybe
01:17:57 <lambdabot> forall a. a -> Maybe a -> a
01:18:35 <edwardk> @type maybe
01:18:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:18:58 <edwardk> @src fromMaybe
01:18:59 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
01:20:03 <edwardk> > (length "maybe [] id",length "fromMaybe []")
01:20:05 <lambdabot>   (11,12)
01:20:19 <quicksilver> fear the id.
01:21:48 <edwardk> nah, my ego won't let me
01:22:01 <povman> Hello all. Who should I talk to about adding --no-hs-main support to cabal?
01:22:41 <quicksilver> I wonder if poor freud jokes should be considered bad taste, today.
01:22:42 <edwardk> I'd probably start by prodding dcoutts, since he's the guy who answers all of my inquiries about cabal ;)
01:23:08 <edwardk> quicksilver: yes, like every day. did i ever claim to have taste?
01:23:32 <quicksilver> edwardk: no, particularly today : http://news.bbc.co.uk/1/hi/entertainment/8001383.stm
01:23:43 <quicksilver> edwardk: (btw, I take responsibility for starting the joke)
01:24:10 <quicksilver> povman: if dcoutts happened to be around you could ask him, but failing that, the cabal-devel mailing list.
01:24:23 <povman> Thanks all!
01:24:45 <quicksilver> http://www.haskell.org/mailman/listinfo/cabal-devel
01:24:52 <quicksilver> (see also http://www.haskell.org/cabal/ )
01:26:47 <mlesniak> Hi, why does (*) (-) 4 8 33 has a valid type but can not be evaluated?
01:27:01 <povman> I was hoping someone would yell out the reason why --no-hs-main is too evil for cabal... But the mailing list will do
01:27:23 <edwardk> mlesniak: probably because it would require Num instances that don't exist
01:27:34 <edwardk> @type  (*) (-) 4 8 33
01:27:36 <lambdabot> forall a. (Num (a -> a -> a), Num a) => a
01:27:45 <mlesniak> edwardk: Yes, I think so too but am not totally sure I understand this ;-)
01:27:52 <edwardk> there is no 'Num' instance for a -> a -> a, but there could be.
01:28:00 <povman> mlesniak: You're applying the function (*) to the arguments (-), 4, 8, and 33
01:28:09 <povman> mlesniak: Use parentheses
01:28:21 <mlesniak> povman: Ah, ok
01:28:28 <edwardk> you could define how functions of numbers are also kinda like numbers, but the expression wouldn't have anything like the meaning you think it should
01:29:17 <mlesniak> edwardk: Hmm, correct. Thanks for your help :
01:29:19 <mlesniak> :)
01:29:22 <edwardk> i.e. you could say that a function of the form (Num a => r -> a) could be added to another function of that form, defining how +, -, *, etc. work on that, and then you'd have the Num instance for b -> a, which would cover your a -> a -> a Num
01:29:39 <Gracenotes> f + g = \x y -> f x y + g x y
01:29:54 <Gracenotes> ..somethin like?
01:30:26 <edwardk> yeah, but that is just a special case of the more general (f + x) x = f x + g x lifting
01:30:36 <edwardk> which can be applied twice to get that one
01:30:44 <edwardk> er (f + g) x
01:30:56 <Gracenotes> oh, right!
01:31:23 <Gracenotes> just dealt this the idiom yesterday. (+) = (liftM2.liftM2) (+)
01:31:29 <Gracenotes> with
01:32:13 <dcoutts> povman: yep, mailing list is a good place to ask
01:32:14 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:33:05 <dcoutts> povman: remind me what no-hs-main is for?
01:33:09 <povman> Interesting how most newbie incorrect uses of functions turn into discussions of how it could be correct.
01:33:16 <dcoutts> povman: this is so you can use a main.c file?
01:33:23 <povman> dcoutts: Yes
01:33:29 <edwardk> povman: hah, yeah
01:33:42 <dcoutts> povman: ok, there's a ticket for that I think, about specifying main-is: foo.c
01:33:51 <edwardk> well, the original question was why did it typecheck but not work =)
01:33:52 <povman> dcoutts: awesome, thanks
01:35:52 <dcoutts> povman: add your comments or add yourself to the cc list: http://hackage.haskell.org/trac/hackage/ticket/504
01:36:14 <hydo> reading a file (json format) that kicks me back a list of filenames as a [String] works just fine, but when I try to map over that list to test parsing the files, I start stacking IOs and I get back pretty quickly something like IO [IO [String]].
01:36:23 <hydo> bah, I'll paste code.
01:36:24 <povman> of course the ticket was added by lemmih, who's maintaining sdl :P
01:37:04 <dcoutts> povman: it was added by me :-)
01:37:21 * povman idiot
01:37:27 <povman> I fail at reading
01:37:42 <dcoutts> we all do sometimes :-)
01:37:56 <doserj> hydo: don't use map, use mapM then
01:38:32 <povman> dcoutts: The workaround is no good for SDL, which does #define main sdl_main
01:39:33 <dcoutts> povman: sdl is so foolish
01:39:50 <quicksilver> hydo: use <- to unwrap the IOs so they don't stack.
01:39:53 <dcoutts> povman: so you're supposed to make a C function sdl_main is that it?
01:40:07 <quicksilver> hydo: or use =<< etc.
01:40:40 <hydo> http://friendpaste.com/16iHCzp6349KbVWT3xAEEX
01:40:41 <hydo> ack
01:40:43 <povman> dcoutts: At least on a mac: You make a c function main, which sdl.h renames to sdl_main, and calls that from its own main
01:41:06 <hydo> mapM, of course... I read and played around with that earlier today.  plegh... thanks!
01:41:34 <hydo> Hrm... I'll figure out the solution with both mapM and =<< for good measure
01:41:36 <povman> dcoutts: It's pretty dumb; I can't see why they don't use Init/Deinit functions
01:41:48 <dcoutts> povman: I guess that would work with the proposed main-is: main.c assuming your main.c #includes sdl
01:41:57 <dcoutts> povman: yeah, quite.
01:42:41 <povman> yes, you write a haskell main function and call it from your c main
01:43:24 <quicksilver> hydo: yes; do you understand why? read_and_parse :: String -> IO String; so if you just 'map' you get a list of IO strings [IO String]
01:43:51 <quicksilver> hydo: sequence will turn [IO String] into IO [String]
01:44:01 <quicksilver> hydo: mapM is just sequence (map f ...)
01:44:03 <hydo> quicksilver: I'm getting there... I'm going back over mapM, etc. in RWH
01:44:32 <ErhardtMundt> hi
01:44:36 <quicksilver> hydo: the extra IO on the outside was just an artefact of your 'return' you added.
01:44:39 <quicksilver> return adds a lyayer of IO.
01:45:21 <hydo> quicksilver: right, but it's not like it's optional when you are doing something inside IO, at least that's what I gather
01:46:11 <edwardk> hydo: actually it is
01:46:34 <quicksilver> hydo: which? return? well it's not "optional", no. Any more than (+) is "optional". YOu use it when you need it and not when you don't.
01:46:37 <hydo> edwardk: *blink* I guess I missed that.  hehe damn
01:46:53 <quicksilver> in this example, you don't need it; the correct answer is
01:46:59 <quicksilver> mapM read_and_parse stuff
01:47:07 <quicksilver> return (mapM read_and_parse stuff) would be wrong ;)
01:47:13 <quicksilver> it would be IO (IO [String])
01:47:22 <edwardk> @type mapM
01:47:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:47:35 <edwardk> where m in this case is IO
01:47:42 <hydo> and read_and_parse doesn't actually have to return () its list?
01:48:04 <quicksilver> 'return' has nothing to do with returning values.
01:48:20 <quicksilver> It's a very good idea to distance it entirely from what return might mean in a C-like language.
01:48:23 <hydo> right, I got that, at the very least... "wraps the value back into the monad"
01:48:28 <edwardk> whenever you are using x <- foo; return (f x) -- you could rewrite that with liftM
01:48:54 <quicksilver> hydo: the reason read_and_parse uses return
01:49:02 <quicksilver> hydo: is that "distill $ fromJust $ parse c" is a pure value
01:49:09 <quicksilver> I mean, a non-IO value.
01:49:15 <quicksilver> so it needs wrapping.
01:49:20 <hydo> yes, that part is
01:49:26 <quicksilver> however "mapM read_and_parse list" is an IO value
01:49:30 <quicksilver> which doesn't need wrapping
01:49:40 <quicksilver> which is why you won't be wanting a 'return' in parse_list.
01:49:42 <edwardk> liftM (distill . fromJust . parse) . readFile $ "../.." + x
01:50:18 <kadaver> sqrt $ fromIntegral $ foldr (\(x,y) s -> s + (x - y)^2) 0 $ zip v1 v2
01:50:19 <edwardk> @type liftM
01:50:19 <hydo> ah ha!
01:50:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:50:22 <kadaver> sqrt $ fromIntegral $ sum $ zipWith (\x y -> (x - y)^2) v1 v2
01:50:29 <kadaver> do those end up being the same?
01:50:38 <kadaver> i mean a far as speed goes?
01:51:04 <edwardk> depends on how good stream fusion is behaving that day ;)
01:51:05 <quicksilver> if anything, the zipWith is faster
01:51:16 <quicksilver> GHC doesn't generally remove intermediate tuples
01:51:18 <pumpkin> no stream fusion unless you're using stream-fusion
01:51:20 <kadaver> and can I get rid of this big ugly type (Floating b, Integral b1)
01:51:32 <pumpkin> you only get the foldr/build fusion afaik
01:51:38 <quicksilver> so your foldr probably does some work constructing + destructing tuples
01:52:12 <hydo> edwardk, quicksilver: thanks a lot guys.  I really appreciate it.
01:52:39 <quicksilver> kadaver: why would you want to get rid of that 'ugly' type? Which type did you want?
01:52:44 <kadaver> would writing a myfoldr :: (a -> a -> a) -> a -> [a] -> [a] -> a speed things up?
01:52:47 <quicksilver> you can always specialise to the type you want if you want.
01:53:10 <quicksilver> no.
01:54:14 <kadaver> now i want a Num -> Double
01:54:15 <kadaver> I mean 2 vectors of any Num type and return  sqrt of that
01:54:22 <kadaver> but i want to fit the type sig in 1 row :P
01:54:32 <pumpkin> if you wrote your own thing that does the whole sequence explicitly, maybe
01:54:39 <quicksilver> Num a => a -> Double ?
01:54:41 <pumpkin> maybe using strict unboxed tuples and the like
01:54:46 <quicksilver> I doubt you do want that, though, it sounds daft.
01:54:55 <quicksilver> what's so special about Double?
01:55:04 <quicksilver> why would you want to restrict to that, if you're allowing any Num for the input?
01:56:13 <kadaver> could not deduce floating or integral
01:57:01 <quicksilver> well, yes, Num isn't good enough if you want to call 'fromIntegral' on it
01:57:06 <edwardk> probably because he is only requiring Num and needs more
01:57:20 <quicksilver> the function you wrote only works for integers; maybe that's not what you mean.
01:57:38 <quicksilver> unless you tell me what you *did* mean, I'm not sure I can help you.
01:58:03 <pumpkin> if you removed the fromIntegral from there, its type would be more general
01:58:24 <pumpkin> :t \v1 v2 -> sqrt $ fromIntegral $ sum $ zipWith (\x y -> (x - y)^2) v1 v2
01:58:25 <lambdabot> forall b b1. (Integral b1, Floating b) => [b1] -> [b1] -> b
01:58:31 <pumpkin> :t \v1 v2 -> sqrt $ sum $ zipWith (\x y -> (x - y)^2) v1 v2
01:58:32 <lambdabot> forall b. (Floating b) => [b] -> [b] -> b
01:58:58 <kadaver> i dumped the fromIntegral
01:59:17 <quicksilver> pumpkin: not more general, actually. different.
01:59:27 <quicksilver> pumpkin: it no longer works for integers where previously it did.
01:59:52 <pumpkin> true
02:00:11 <pumpkin> :t realToFloat
02:00:12 <lambdabot> Not in scope: `realToFloat'
02:00:16 <twb> I'm a little afraid, seeing happstack has a "Facebook" module.
02:00:17 <pumpkin> what was that called?
02:00:22 <quicksilver> realToFrac
02:00:25 <pumpkin> ah yeah
02:00:53 <quicksilver> you could replace fromIntegral with realToFrac for yet another different possibility.
02:00:59 <quicksilver> but now you exclude complex numbers :)
02:01:19 <quicksilver> the right answer depends what you actually wanted.
02:01:36 <pumpkin> yeah, or we could revamp the numeric typeclasses to make sense :P
02:01:52 <pumpkin> (without using Ts and Cs everywhere)
02:02:07 <quicksilver> Ts and Cs?
02:02:16 <pumpkin> @hackage numeric-prelude
02:02:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude
02:02:35 <pumpkin> class (C a, C b) => C a b where
02:02:35 <pumpkin> mmm
02:02:37 <pumpkin> :P
02:02:44 <quicksilver> the numeric classes do make sense.
02:03:01 <quicksilver> this part of them (the interaction between Real / Complex / Integral / Floating) makes a lot of sense.
02:03:29 <quicksilver> the problem people general try to solve is to expand them to more algebraic stuff
02:03:35 <quicksilver> (splitting the classes up a bit)
02:03:52 <pumpkin> well, what in kadaver's function requires Floating?
02:03:56 <quicksilver> sqrt.
02:04:00 <quicksilver> :t sqrt
02:04:02 <lambdabot> forall a. (Floating a) => a -> a
02:04:19 <[1]dan> getting linkage error "main.o:fake:(.text+0x243): undefined reference to `__stginit_networkzm2zi2zi0zi1_Network_'
02:04:19 <[1]dan> collect2: ld returned 1 exit status
02:04:34 <quicksilver> you can argue that there should be a class 'Transcendental' or something.
02:04:36 <pumpkin> quicksilver: that doesn't seem like a reasonable
02:04:36 <[1]dan> when importing Network module. Can anyone help?
02:04:42 <pumpkin> [1]dan: --make to GHC
02:04:43 <quicksilver> [1]dan: use --make
02:04:57 <quicksilver> it's not entirely clear where the correct home for sqrt is.
02:04:59 <Axman6> Tip: always use --make
02:05:00 <[1]dan> thank you.
02:05:05 <quicksilver> but Floating is a good place for it.
02:05:15 <quicksilver> we don't have a general algorithm for sqrt of general real or complex types.
02:06:08 <pumpkin> hmm
02:06:50 <doserj> Floating is a bit ambivalent about whether it is supposed to work for Complex Double
02:06:52 <pumpkin> I'm not convinced :P
02:07:00 <quicksilver> pumpkin: well, convince me.
02:07:16 <quicksilver> you could make an argument for sqrt by power series, which only requires Fractional
02:07:17 <Axman6> > sqrt (-1 :+ 1)
02:07:18 <lambdabot>       precedence parsing error
02:07:18 <lambdabot>          cannot mix prefix `-' [infixl 6] and ...
02:07:26 <quicksilver> but that wouldn't be an efficient algorithm
02:07:27 <Axman6> > sqrt ((-1) :+ 1)
02:07:29 <quicksilver> so it's tricky.
02:07:29 <lambdabot>   0.45508986056222733 :+ 1.09868411346781
02:07:55 <quicksilver> is the existence of sqrt supposed to indicate that an efficient algorithm exists?
02:07:57 <pumpkin> quicksilver: I don't think the efficient algorithm should affect the function's type though... it used to be possible to specify specializations for each type, I thought
02:08:15 <pumpkin> I think they took that out though and just let the compiler specialize for you
02:08:32 <pumpkin> but if we stuck it in a meaningful typeclass, it would be possible for provide one for each type
02:09:05 <kadaver> I want to be able to do vectroLength, euclideanDistance for any float,int,double
02:09:28 <quicksilver> doserj: ambivalent how? all the members of Floating are analytic aren't they?
02:10:03 <doserj> most are not canonically defined for all of C
02:10:07 <quicksilver> kadaver: then you probably want the realToFrac version
02:10:30 <quicksilver> AFAICR they all have an accepted concept of principal value
02:10:35 <quicksilver> outside of singularities
02:10:48 <Axman6> @src Complex
02:10:49 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
02:11:03 <Axman6> @src Complex (+)
02:11:03 <lambdabot> Source not found. :(
02:11:07 <Axman6> :(
02:11:13 <kadaver> works for complex?
02:11:14 <kadaver> i for got that one
02:11:23 <quicksilver> :t \v1 v2 -> sqrt . realToFrac . sum $ zipWith (\x y -> (x - y)^2) v1 v2
02:11:25 <lambdabot> forall b b1. (Real b1, Floating b) => [b1] -> [b1] -> b
02:11:54 <quicksilver> kadaver: you want it to work for complex too?
02:12:30 <kadaver> y
02:12:42 <quicksilver> :t \v1 v2 -> sqrt . sum $ zipWith (\x y -> (x - y)^2) v1 v2
02:12:44 <lambdabot> forall b. (Floating b) => [b] -> [b] -> b
02:12:49 <quicksilver> in that case you use the Floating version
02:12:57 <doserj> quicksilver: the principal values are discontinuous though, which is especially dangerous when working with floating point numbers
02:12:58 <quicksilver> and you manually promote ints before use
02:13:09 <quicksilver> doserj: (1/x) is discontinous too.
02:13:12 <quicksilver> doserj: cry me a river :P
02:13:29 <quicksilver> doserj: if we abandon all discontinous functions our arithmetic is rather weak.
02:13:29 <doserj> :)
02:16:51 <doserj> 1/x only needs a 1-point compactification to become continuous. sqrt, log, etc need more complicated structures. But that's maybe a weak argument.
02:19:24 <kadaver> rpomote ints? so i cant hsve somehting woring for both ints and complex?
02:19:35 <quicksilver> no, because they have fundamentally different types.
02:19:57 <quicksilver> unless you're prepared to always return complex as a lowest common denominator
02:20:03 <quicksilver> which I suspect is a bad idea.
02:20:24 <quicksilver> the most natural thing to do is to make it type preserving
02:20:34 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185013
02:20:39 <quicksilver> so double -> double, float -> float, complex float -> complex float, etc.
02:20:41 <ManateeLazyCat> Can make above code more simpler?
02:20:44 <quicksilver> that doesn't work for int.
02:20:49 <doserj> I just feel that pi, exp, sin, cos, tan, should be in a different class than log, sqrt, asin, acos, atan
02:20:49 <quicksilver> alternatively, you can do
02:21:14 <kadaver> so makes more sense to have a special version for complex?
02:21:19 <doserj> like (/) is in a different class than (*)
02:21:55 <doserj> (although that is for a different reason)
02:22:55 <ManateeLazyCat> HOw to use `execStateT` rewrite code at http://paste2.org/get/185013 ?
02:23:10 <doserj> ManateeLazyCat: printf "%s\n" . show <==> print
02:23:32 <ManateeLazyCat> > (<==>)
02:23:33 <lambdabot>   Not in scope: `<==>'
02:23:37 <ManateeLazyCat> > :t (<==>)
02:23:38 <lambdabot>   <no location info>: parse error on input `:'
02:23:52 <doserj> @src print
02:23:53 <lambdabot> print x = putStrLn (show x)
02:24:34 <kadaver> euclideanDistance
02:24:35 <kadaver>   :: (Floating a, Foldable t, Integral [b], Num (t a), Num b) =>
02:24:35 <kadaver>      Vector b -> Vector b -> a
02:24:35 <kadaver> *
02:24:50 <kadaver> can that eb simplified? it is the type derived by ghci and when pasting it doesnt even woek...'
02:25:10 <ManateeLazyCat> doserj: Yep, use `print` is simpler
02:25:16 <quicksilver> doserj: can you outline a type which would support one set and not the other?
02:25:29 <quicksilver> kadaver: 'Integral [b]' smells bad to me.
02:25:36 <quicksilver> lists are not integral.
02:25:41 <quicksilver> I think your code has a bug.
02:26:27 <ManateeLazyCat> Now looks better.
02:26:28 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185014
02:26:47 <kadaver> bah hapste error again
02:28:23 <quicksilver> ManateeLazyCat: yeah. Although you're just playing, right? no one would write code like that in practice.
02:28:46 <ManateeLazyCat> code at http://paste2.org/get/185014 use state2 contain second state value, use state3 contain third state value, looks ugly, have a way make it better?
02:28:55 <quicksilver> the point of the state monad is to stop you havign to name intermediate states.
02:29:09 <quicksilver> well that code doesn't really do anything, so I'm unsure how to make it more idiomatic.
02:30:14 <ManateeLazyCat> quicksilver: I want use something wrap `state1`, `state2`, `state3`.
02:30:15 <kadaver> http://paste.org/index.php?id=6581
02:30:30 <kadaver> hpaste: 500 Internal Server Error
02:30:30 <kadaver> 58030 14: unable to open database file
02:31:02 <ManateeLazyCat> kadaver: I can open it.
02:32:21 <kadaver> http://paste.org/index.php?id=6581 <- quicksilver
02:32:59 <kadaver> http://paste.lisp.org/display/78670
02:33:02 <kadaver> better paste
02:33:35 <ManateeLazyCat> kadaver: paste2.org
02:33:55 <quicksilver> paste.lisp.org doesn't seem to work for me
02:34:02 <quicksilver> I mean, it connects but returns a blank page
02:34:03 <quicksilver> odd.
02:34:07 <quicksilver> it is the day of the dead paste servers.
02:34:42 <ManateeLazyCat> quicksilver: paste2.el
02:35:10 <quicksilver> kadaver: you need sqrt . map fromIntegral
02:35:20 <quicksilver> you need to apply fromIntegral to each member of the list
02:35:24 <ManateeLazyCat> quicksilver: http://www.emacswiki.org/emacs/download/paste2.org
02:35:28 <Deewiant> quicksilver: sqrt of a list?
02:35:35 <ManateeLazyCat> quicksilver: http://www.emacswiki.org/emacs/download/paste2.el
02:35:45 <quicksilver> sum . map fromIntegral
02:35:47 <quicksilver> I meant :)
02:35:50 <Deewiant> :-)
02:35:57 <quicksilver> alternatively, fromIntegral . sum
02:36:02 <quicksilver> do the conversion after the sum.
02:36:06 <quicksilver> which is what we had before.
02:36:24 <kadaver> uh yeah
02:36:33 <kadaver> i see i changed the function then changed it back wrong
02:36:41 <kadaver> why did that even compile at all?
02:37:11 <Deewiant> ?ty \x -> fromIntegral [x]
02:37:12 <lambdabot> forall t b. (Num b, Integral [t]) => t -> b
02:38:23 <ManateeLazyCat> quicksilver: How to avoid use create new state monad ? (http://paste2.org/get/185014)
02:38:38 <ManateeLazyCat> quicksilver: I think create new state moand is ugly
02:39:32 <doserj> quicksilver: of course both exp and log can be defined by power series, so they make sense in the same types. (Analogously sin and asin, etc). However, I would like to be reminded when I'm using functions like sqrt or log on complex numbers. How about having separate functions for sqrt and log in RealFloat?
02:40:23 <quicksilver> (c1,c2,c3) <- evalState (do { updateCounter; c1 <- gets counter; updateCounter; c2 <- gets counter; updateCounter; c3 <- gets counter; return (c1,c2,c3)}
02:40:27 <quicksilver> ManateeLazyCat: something like that.
02:40:58 <quicksilver> btw you're not "creating a new state monad" ;)
02:41:08 <quicksilver> but you were having to name the intermediate states, which is ugly.
02:48:42 <ManateeLazyCat> quicksilver: YOu lost `)`?
02:48:58 <quicksilver> yup.
02:50:55 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185021
02:50:56 <ManateeLazyCat> Above code can't work
02:51:04 <ManateeLazyCat> quicksilver: How to fix?
02:52:24 <Deewiant> ManateeLazyCat: Two things
02:52:44 <Deewiant> First, change '(c1,c2,c3) <-' to 'let (c1,c2,c3) ='
02:53:03 <Deewiant> Since evalState doesn't return an IO action, you shouldn't use <-
02:53:19 <Deewiant> Second, you need to pass some sort of initial state to evalState
02:53:26 <Deewiant> Which I guess is wl
02:53:29 <Deewiant> But you're not passing it
02:53:44 <ManateeLazyCat> Deewiant: Thanks, fixed.
02:55:03 <quicksilver> if you want to make it equivalent to the old version you should also use
02:55:06 <quicksilver> print c1
02:55:07 <quicksilver> print cc2
02:55:09 <quicksilver> print c3
02:55:10 <quicksilver> at the end :)
02:55:21 <kadaver> where is infinity?
02:55:29 <quicksilver> ----> over there
02:56:17 <ManateeLazyCat> quicksilver: `gets` is handy tips
02:56:47 <quicksilver> "c1 <- gets counter" is the same as "c1 <- liftM counter get" or "c1 <- counter <$> get"
02:57:04 <ManateeLazyCat> quicksilver: I see.
02:57:13 <quicksilver> you can now use StateT to bundle the printing bit in with the state bit if you like.
02:58:39 <kadaver> > 1/0
02:58:41 <lambdabot>   Infinity
02:58:47 <kadaver> why cant i use infinty then?
02:59:43 <quicksilver> the constructor isn't exported
02:59:45 <quicksilver> not entirely sure why.
02:59:58 <quicksilver> you can always write "infinity :: Double; infinity = 1/0" if you want it.
03:00:10 <quicksilver> > read "Infinity" :: Double
03:00:12 <lambdabot>   Infinity
03:00:15 <quicksilver> or that.
03:00:34 <ManateeLazyCat> quicksilver: StateT? How?
03:00:38 <doserj> The Haskell report does not guarantee that 1/0 evaluates to Infinity. It could also raise a runtime exception. maybe that's why
03:01:15 <doserj> i.e., there is no guarantee that there is a value Infinity
03:06:17 <quicksilver> ManateeLazyCat: execStateT (do { updateCounter; c1 <- gets counter; liftIO . print $ c1; updateCounter; c2 <- gets counter; liftIO . print $ c2; ... etc ... })
03:06:30 <quicksilver> ManateeLazyCat: but you will have to make the type signature for updateCounter more general.
03:07:11 <quicksilver> updateCounter :: MonadState WindowsList m => m WindowsList
03:07:25 <quicksilver> incidentally, it is not necessarily for updateCounter to return st;
03:07:42 <quicksilver> it would be sensible to make the type m () (or State WindowsList ()) and remove that return statement.
03:09:30 <ManateeLazyCat> quicksilver: Great, works.
03:09:39 <jelly12gen> is there a way to convert an string to a [int] ?
03:09:49 <jelly12gen> i know i can convert a string to int with read
03:10:21 <fasta> jelly12gen: f = const [1::Int] :)
03:10:56 <fasta> jelly12gen: if you have "[1,2,3]" you should just be able to use read.
03:11:10 <fasta> jelly12gen: or in other words, what is your String?
03:11:16 <ManateeLazyCat> quicksilver: I found only different is need add `liftIO` front sentence that handle state
03:11:26 <matthew-_> @seen drmaciver
03:11:27 <lambdabot> drmaciver is in #scala and #xmonad. I don't know when drmaciver last spoke.
03:11:30 <jelly12gen> fasta: my string is like "123435"
03:11:48 <fasta> jelly12gen: and you want to get [1,2,3,4,3,5]?
03:12:00 <jelly12gen> fasta: exactly
03:12:25 <fasta> jelly12gen: well, nothing exists that does exactly that, but it is trivial to make something which does that.
03:12:30 <jelly12gen> fasta: there is no read "1243"::[int] -.-
03:12:35 <vixey> :t map digitToInt
03:12:36 <lambdabot> [Char] -> [Int]
03:12:39 <doserj> > map digitToInt "12345"
03:12:39 <ManateeLazyCat> jelly12gen: String -> [Char] -> [Int]
03:12:40 <lambdabot>   [1,2,3,4,5]
03:12:52 <jelly12gen> fasta: awesome!
03:12:58 <jelly12gen> doserj: thanks
03:13:15 <gio123> doserj: is today hollyday for student in spain?
03:13:42 <doserj> gio123: not that I would know of
03:14:13 <gio123> doserj: at UPM?
03:15:28 <doserj> gio123: software.imdea.org (but in a UPM building)
03:15:55 <gio123> doserj: ah, sorry, you do not know then, thanks
03:19:46 <kadaver> how are key->value mas implemented? i dont get how they are more efficeint than a Tree (k,v)
03:20:28 <ManateeLazyCat> quicksilver: When i type "updateCounter :: MonadState WindowsList m => m WindowsList", I got "Non type-variable argument" error. how to fix?
03:20:29 <ManateeLazyCat>  
03:21:25 <kadaver> Possible fix: add an instance declaration for (Ord (Vector t))
03:21:25 <kadaver>     In the expression:
03:22:56 <tomh> ManateeLazyCat: why don't you use updateCounter :: State WindowsList WindowsList ?
03:22:58 <ManateeLazyCat> quicksilver: Emacs crash.
03:23:18 <ManateeLazyCat> tomh: Any suggestion?
03:23:28 <tomh> that was my suggestion
03:23:49 <doserj> kadaver: data Map k a  = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)  Basically a Tree (k,a) with a size field for balancing, and with strict fields
03:23:54 <ManateeLazyCat> tomh: quicksilver suggesion me use MonadState WindowsList m => m WindowsList
03:24:11 <ManateeLazyCat> tomh: And i originally use "updateCounter :: State WindowsList WindowsList"
03:24:23 <tomh> oh ok, well then use that, he is like 10 times smarter than me -.-
03:25:16 <kadaver> http://paste.dprogramming.com/dpdw4nun <- why the Ord bullshit?
03:25:43 <ManateeLazyCat> tomh: But problem, is "MonadState WindowsList m => m WindowsList" can't work.
03:25:51 <tomh> well probably because Vector doesn't have an instance of Ord
03:25:53 <ManateeLazyCat> tomh: I got "Non type-variable argument"
03:26:03 <ManateeLazyCat> in the constraint: MonadState WindowsList m
03:26:13 <tomh> yeah i see
03:27:12 <doserj> kadaver: well, apparantly you are trying to sort a list of Vectors, but have not defined an instance Ord for Vecotr
03:27:45 <kadaver> but i thought that oh yeah i forgot to derive that
03:28:57 <tomh> I don't think you can derive Ord
03:29:44 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185035
03:29:44 <ManateeLazyCat> In above code, why need `liftIO` at front of sentence that handle state ?
03:31:01 <quicksilver> you can dervive Ord. you get lexicographic
03:31:13 <kadaver> tomh: i just did sucessfully anyway!
03:31:16 <fasta> There is no way to see the current options ghci has applied now, right? Including everything that was a command line flag and things :set later?
03:31:44 <ManateeLazyCat> brb
03:33:58 <tomh> kadaver: ok cool, didn't knew that :), seemed non-trivial to me
03:34:15 <quicksilver> ManateeLazyCat: you need liftIO in front of actions whic are IO
03:34:22 <quicksilver> because you're not using them in the IO monad
03:34:31 <quicksilver> (in this case you're using them in StateT WindowList IO)
03:39:54 <ManateeLazyCat> quicksilver: I see, thanks!
03:40:36 <quicksilver> ManateeLazyCat: you don't really need all those {} and ;, by the way
03:40:41 <quicksilver> ManateeLazyCat: that was just so I could one-line it.
03:40:45 <quicksilver> I would use layout in practice.
03:44:36 <A1kmm> hmm, does anyone know of any examples of how to use the priority-queue package in Hackage?
03:45:16 <A1kmm> I've tried with even a simple test example and get no instance errors.
03:45:23 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185041
03:45:24 <ManateeLazyCat> quicksilver: Like above?
03:48:58 <ManateeLazyCat> quicksilver: Thanks for help! :)
03:49:44 <krischoff> Am I right: It is not possible to combine pattern matching and point-free style?
03:49:57 <krischoff> lengthChain :: Integer -> Integer
03:49:57 <krischoff> lengthChain 1 = 1
03:49:57 <krischoff> lengthChain  = (1+) . lengthChain . nextNumber
03:50:04 <krischoff> wasn’t possible :(
03:50:46 <vixey> krischoff: you are not allowed to do that
03:50:52 <krischoff> hm, ok
03:51:02 <vixey> you could mix pattern matching and point free like this though
03:51:03 <tomh> :t nextNumber
03:51:04 <lambdabot> Not in scope: `nextNumber'
03:51:33 <Gracenotes> DENIED
03:51:48 <fasta> I essentially want to have this ( http://paste.debian.net/33658/ ) program working with the semantics of the monomorphism restriction (a should have type Double), but I don't want to specify the types anywhere. The only way I see to do it is to have some accessor for Something and use asTypeOf, but if the value of a is quite deep (in a real application), that's very inconvenient.
03:51:57 <vixey> liftA2 bool (const 1) ((1+) . lengthChain . nextNumber) (==1)
03:51:59 <vixey> I think ...
03:52:10 <vixey> :t liftA2 ?bool (const 1) ((1+)) (==1)
03:52:12 <lambdabot> forall a c a1. (Num a1, Num (a1 -> Bool), Num a, ?bool::a -> (a1 -> Bool) -> c) => c
03:52:33 <vixey> :t liftA2 ?bool (const 1) ((1+)) . (==1)
03:52:34 <lambdabot>     No instance for (Num Bool)
03:52:34 <lambdabot>       arising from the literal `1' at <interactive>:1:25
03:52:34 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
03:53:01 <vixey> krischoff: well I don't have it but if you define a new combinator to work that usually works
03:53:01 <Gracenotes> hm.
03:53:37 <bavardage> Philippa__: I started :D http://omploader.org/vMWo3cQ
03:54:20 <Gracenotes> great way to print out some memory: let (GHC.Num.J# _ b) = 10000000000000; indexIntArray b (GHC.Base.I# i) = GHC.Base.I# (GHC.Prim.indexIntArray# b i) in mapM_ (\i -> putStrLn $ show i ++ " " ++ show (indexIntArray b i)) [0..]
03:54:39 <Gracenotes> quite a large Integer! :P
03:54:44 <Gracenotes> segfaulted at i=5851219 for me
03:54:59 <vixey> bavardage your OS looks pretty cool
03:55:11 <Gracenotes> of course, one can just use Ptrs.. this primitive/internal stuff is interesting.
03:59:23 <doserj> fasta: so you want NoMonomorphismRestriction *and* a be monomorphic?
03:59:41 <fasta> doserj: yes
04:00:11 <fasta> doserj: I know I can just move it to a different module.
04:02:42 <doserj> fasta: you can also do "let Something a = Something foo" (pattern bindings a monomorphic in ghc)
04:03:00 <doserj> *are monomorphic
04:03:03 <fasta> doserj: I also use NoMonoPatBinds ;)
04:03:20 <doserj> so you explicitely say what you don't want :)
04:03:40 <fasta> doserj: it's just that I need those other options for other functions.
04:04:29 <doserj> I guess you have to give an explicit type signature then somewhere
04:07:37 <fasta> doserj: I will just use asTypeOf, which is what I thought of before I asked here. I just wanted to know whether I was missing anything.
04:08:06 <fasta> Explicit type signatures will bit me later on.
04:08:10 <fasta> bite*
04:08:11 <doserj> well, this case of course works even with NoMonoPatBinds. I don't know how it looks in your real example.
04:08:50 <fasta> doserj: it wouldn't.
04:09:31 <quicksilver> fasta's example is too contrived for me to comment.
04:09:39 <quicksilver> I can't quite fathom what probelm you're trying to solve.
04:09:49 <mun> hi
04:09:50 <quicksilver> possibly one of the things people want 'partial' type signatures for, though.
04:10:24 <mun> does r@(T {a = b, c = d}) rename the attributes a to b and c to d?
04:11:17 <quicksilver> in a sense.
04:11:30 <quicksilver> although I wouldn't call them attributes and I wouldn't call it renaming.
04:11:43 <quicksilver> I'd say it binds 'b' to "a r" and d to "c r"
04:12:15 <mun> quicksilver: i see. what's the correct term for a and b? value constructos?
04:12:18 <mun> *constructors?
04:12:38 <quicksilver> field selectors.
04:12:51 <mun> right. what are value constructors.
04:12:59 <quicksilver> "T" is a constructor
04:13:09 <mun> ah ok
04:13:12 <mun> thanks
04:13:15 <quicksilver> np.
04:14:37 <fasta> I probably would be against "partial type signatures", since asTypeOf solves the same problem without introducing extra syntax. I used to think "partial type signatures" were a good idea, though.
04:17:54 <quicksilver> withTypeEquality :: b -> a -> a -> b; withTypeEquality x y z = x;
04:18:08 <quicksilver> use as in "foobar `withTypeEquality` foo bar"
04:18:16 <quicksilver> to force foo and bar to hold the same type.
04:19:12 <quicksilver> if you want to be cute, you can do "foobar `const` [foo,bar]" to have the same effect :P
04:21:46 <doserj> quicksilver: that's the same as let _ =  foo`asTypeOf`bar in foobar, right?
04:21:52 <fasta> quicksilver: yes, I know. asTypeOf uses the same trick.
04:22:33 <fasta> quicksilver: only `` doesn't work with more than 2 arguments, or does it?
04:23:30 <doserj> fasta: why shouldn't it?
04:23:48 <BONUS> > ((+) `foldl` 0) [1,2,3]
04:23:49 <lambdabot>   6
04:24:05 <fasta> doserj: or maybe you cannot use that syntax in defining the function then.
04:24:24 <quicksilver> > let x `f` y
04:24:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:24:36 <quicksilver> yeah, you need parens
04:24:37 <quicksilver> my bad.
04:24:46 <quicksilver> curry it then :P
04:24:59 <dolio> > let x `f` y = \z -> x + y + z in (1 `f` 2) 3
04:25:00 <lambdabot>   6
04:25:11 <fasta> dadasa `foobar` dada ddasd= 1  -- this is what I meant.
04:25:14 <quicksilver> withTypeEquality :: b -> (a,a) -> b; withTypeEquality = const
04:25:18 <quicksilver> fasta: yes, you need parens.
04:25:28 <quicksilver> otherwise it parses as (a `b` (c d))
04:25:32 <pumpkin> @localtime dolio
04:25:34 <lambdabot> Local time for dolio is Thu Apr 16 07:25:33 2009
04:25:35 <quicksilver> not ((a `b` c) d)
04:25:36 <pumpkin> lol
04:25:51 <quicksilver> it was a poor suggestion.
04:26:20 <pumpkin> is there a way using the haskell type system to specify two types must be different?
04:26:20 <fasta> (dadasa `foobar` dada) ddasd = 1 -- ok, that sure is a little known part of Haskell.
04:26:57 <cnwdup> > "Hello 12 World" =~ "Hello ([0-9]+)"::String
04:26:59 <lambdabot>   "Hello 12"
04:27:22 <osfameron> the parens don't capture just the "12" ?
04:27:23 <quicksilver> pumpkin: no.
04:27:25 <cnwdup> Hwo can I extract the 12 only I matched with parentheses?
04:27:27 <osfameron> @index (=~)
04:27:28 <lambdabot> bzzt
04:27:31 <dolio> People who don't know about that need to read more of the early parsing monad papers.
04:27:43 <quicksilver> pumpkin: except by using olegian type inequality.
04:27:46 <dolio> (m >>= f) s = ...
04:27:53 <quicksilver> pumpkin: (HEqual a b HFalse) =>
04:27:58 <BONUS> fasta: actually i think it comes logically if you consider currying
04:28:25 <BONUS> a function taking 3 parameters can be viewed as a funciton taking 2 and returning a function that takes 1
04:28:36 <BONUS> but yeah it's not used a lot, that's for sure
04:28:40 <pumpkin> quicksilver: so adding type inequality isn't inconsistent with the underlying model, people just didn't feel a need to make it directly expressible?
04:29:50 <quicksilver> yes, it is inconsistent.
04:30:01 <quicksilver> oleg uses inconsistent + incoherent extensions.
04:30:11 <pumpkin> ah
04:30:11 <quicksilver> (overlapping instances, incoherent instances)
04:30:29 <quicksilver> it breaks a form of monotonocity
04:30:39 <quicksilver> something a long the lines of "adding new modules doesn't break an old program"
04:30:47 <quicksilver> I can't formulate it exactly.
04:31:16 <quicksilver> but the point is just because you have no information now that two types are equal doesn't mean that new information might later make them equal.
04:31:25 <quicksilver> even new information from another module you don't have control over.
04:31:41 <quicksilver> same reason we can't get negative information about class membership. really
04:33:42 <pumpkin> ah
04:34:19 * pumpkin ewants to be at the hackathon and not staying up all night to finish a paper
04:44:45 <twb> In Parsec, is there a standard combinator to say "read and ignore this string"?
04:45:03 <twb> Currently I have try $ string "}}}" >> return ()
04:45:10 <twb> ISTR there's a simpler way
04:46:49 <quicksilver> () $> string "}}}"
04:46:51 <quicksilver> why the try?
04:47:03 <quicksilver> because }} might be something else, I guess.
05:06:03 <dibblego> is there a type-class for unfoldr? MonadPlus is possible but seems a bit excessive
05:06:40 <dolio> It's hard to do, because unfolds have to create structure.
05:07:21 <dolio> folds theoretically consume structure, but Foldable just throws it away and treats it as a list, more or less.
05:07:41 <quicksilver> isn't this the problem LogicT solves?
05:07:48 <quicksilver> msplit
05:08:57 <quicksilver> http://okmij.org/ftp/Computation/monads.html
05:09:13 <dolio> I'm not sure. I know you can't quite write msplit with Foldable, but I don't see how it gives you access to more structure.
05:09:36 <dolio> Not immediately, at least.
05:11:59 <dibblego> @type let unfoldr' f b = case f b of Nothing -> mzero; Just (a, b) -> return a `mplus` unfoldr' f b in unfoldr'
05:12:00 <lambdabot> forall t a (m :: * -> *). (MonadPlus m) => (t -> Maybe (a, t)) -> t -> m a
05:14:23 <dolio> Yeah, you could say that's overkill, and only want some way to inject elements, get empty containers and join two containers (the latter is monoid).
05:14:55 <dibblego> LogicT looks possible, thanks
05:14:59 <dolio> But notice that that unfoldr can only create list-looking structures of some type in the container.
05:15:05 <bavardage> which module exports True?
05:15:11 <dibblego> Prelude
05:15:25 <bavardage> why doesn't import Prelude (True) work?
05:15:29 <dolio> An unfold for binary trees would typically be :: (t -> Maybe (a, t, t)) -> t -> Tree a
05:15:41 <dibblego> yeah fair point
05:15:44 <bavardage> "Module `Prelude' does not export `True'"
05:16:08 <dolio> bavardage: Does 'import Prelude (Bool(True))' work?
05:16:24 <bavardage> dolio: yup thanks :D
05:16:56 <cognominal> I still have problem with monads. I want to iist all the buffer names. I got :     getBufferStack ∷  EditorM [FBuffer]         identString ∷  FBuffer →  [Char]
05:17:48 <cognominal> how can I combine getBufferStack and identString to get the list of buffer names?
05:17:55 <bremner> cognominal: your utf8 is not working too well here.
05:18:19 <cognominal> →  is just ->
05:18:42 <bremner> and the little boxes?
05:18:55 <cognominal> hum
05:19:28 <doserj> getBufferStack >>= mapM identString? (guessing that EditorM is a Monad)
05:19:32 <cognominal> I still have problem with monads. I want to list all the buffer names. I got :     getBufferStack ∷  EditorM [FBuffer]         identString ∷  FBuffer ->  [Char]
05:19:43 <cognominal> is that better?
05:20:05 <bremner> the boxes are still there, but the one arrow that worked before you replaced with ascii
05:20:18 <doserj> the boxes are :: I guess
05:20:58 <cognominal> ho indeed. Yi takes the initiative to display some stuff ith utf-8 equivalent
05:21:11 <bremner> @slap Yi
05:21:12 * lambdabot locks up Yi in a Monad
05:21:23 <cognominal> I should configure that out, it is more a nuisance than anything else
05:24:51 <cnwdup> > let (_,match,_) = "x12y" =~ "x([0-9]+)y"::(String,MatchText String,String) in fst (match ! 1)
05:24:53 <lambdabot>       Not in scope: type constructor or class `MatchText'
05:25:00 <cnwdup> ):
05:25:07 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185082
05:25:08 <ManateeLazyCat> quicksilver: You suggested me i use type with "updateCounter :: MonadState WindowsList m => m WindowsList", but it can't work, how to fix?
05:25:08 <marcot> Hello, I want a efficient data type for Stack-like insertion and deletion, with access to elements in the middle and updates of the elements of the middle.
05:25:16 <cnwdup> Anyways, this approach works. But is there a shorter way to extract the matched results?
05:25:26 <marcot> But no removal or add in the middle.  I want to emulate a stack like Memory.
05:26:09 <QtPlaty[HireMe]> marcot: Why don't you use a list?
05:26:14 <marcot> What would you suggest?  Can I get something better than plain list?
05:26:24 <marcot> QtPlaty[HireMe]: I thought I could get something better in terms of performance.
05:26:25 <ManateeLazyCat> macron: Data.Set?
05:26:37 <QtPlaty[HireMe]> If you run into speed problems then start hunting around.
05:27:01 <QtPlaty[HireMe]> marcot: Your writing a bottem up parser?
05:27:07 <quicksilver> cognominal: bs <- getBufferStack; return (map identString bs)
05:27:33 <quicksilver> ManateeLazyCat: "it can't work" ?
05:27:57 <ManateeLazyCat> quicksilver: "Non type-variable argument"
05:28:11 <quicksilver> not good enough. Whole error message in the paste please.
05:28:12 <ManateeLazyCat> in the constraint: MonadState WindowsList m
05:28:26 <marcot> QtPlaty[HireMe]: No, I'm writing a low-level code interpreter.
05:28:33 <marcot> QtPlaty[HireMe]: And I want to simulate memory.
05:28:38 * ManateeLazyCat pasted "error" at http://paste2.org/get/185084
05:28:39 <quicksilver> ManateeLazyCat: hmm. Maybe you need FlexibleContexts
05:28:39 <ManateeLazyCat> quicksilver: Above
05:28:50 <quicksilver> as the error message said, in fact :P
05:29:51 <QtPlaty[HireMe]> marcot: If I recall haskkel lists are O(1) for push and pop and O(N) for examination so thats not to bad in my book.
05:29:52 * ManateeLazyCat pasted "another error" at http://paste2.org/get/185085
05:29:54 <ManateeLazyCat> quicksilver: I did it
05:29:57 <quicksilver> I think you could argue FlexibleContexts should be implied by MPTC. MPTC is not very useful without it.
05:29:58 <wjt[YourAdHere]> QtPlaty[HireMe]: dare i ask?
05:30:09 <ManateeLazyCat> quicksilver: But got another error at http://paste2.org/get/185085
05:30:14 <quicksilver> ManateeLazyCat: I already answered that.
05:30:20 <quicksilver> if you remove the return st you change the type to ()
05:30:24 <quicksilver> instead of WindowList
05:30:25 <QtPlaty[HireMe]> wjt: Dare you ask what?
05:30:33 <wjt> QtPlaty[HireMe]: [HireMe] ? :)
05:30:51 <QtPlaty[HireMe]> It worked for f00lish.
05:31:09 * QtPlaty[HireMe] is an unempolyed programer.
05:31:26 * zachk is as well
05:31:32 <ManateeLazyCat> quicksilver: Oh, sorry, i forgot
05:31:45 <bavardage> http://paste.pocoo.org/show/112777/ <-- the start of my lisp-like language in haskell
05:31:48 <bavardage> :D
05:32:07 <quicksilver> ManateeLazyCat: I don't have the impression you are trying to understand the errors and fix them yourself; I think you are just turning to channel on each error.
05:32:19 <kadaver> how do I delete a cabal package?
05:32:21 <quicksilver> you will learn more effectively if you try to understand the errors.
05:32:26 <pumpkin> kadaver: ghc-pkg unregister
05:32:37 <pumpkin> kadaver: doesn't delete it though
05:32:45 <quicksilver> (you can then delete the directory by hand)
05:32:54 <quicksilver> bavardage: have you seen or heard of liskell?
05:33:07 <bavardage> quicksilver: noop
05:33:10 <bavardage> lisp in haskell?
05:33:26 <doserj> haskell in lisp syntax
05:33:26 <povman> Haskell with Lisp syntax
05:33:45 <bavardage> hehe nice
05:33:47 <povman> I hate projects
05:33:54 <bavardage> though I think I prefer haskell syntax tbh
05:34:38 <doserj> lisp syntax is nice for compile-time metaprogramming, though (compared to Template-Haskell)
05:35:02 <povman> theoretically you could invent a syntax for templates
05:35:26 <povman> hey, you might even be able to do that with quasiquoting.......
05:35:52 <quicksilver> FVO "you" approaching "mmorrow"
05:36:13 <povman> fvo?
05:36:35 <povman> you mean mmorrow has a hammer called quasiquoting and sees everything as a nail?
05:36:55 <quicksilver> "for values of"
05:37:19 <povman> Hey, don't knock my brilliant idea!
05:37:23 <quicksilver> I meant to suggest that whilst possible, this is probably hard.
05:37:34 <quicksilver> but I bet mmorrow could do it because he has hacked at TH + QQ very hard.
05:41:59 <vixey> bavardage: lol (that paste)
05:42:19 <bavardage> ..and what is so amusing ^^
05:42:28 <vixey> @let pair = (,)
05:42:29 <lambdabot>  Defined.
05:42:30 <vixey> @let two = 2
05:42:31 <lambdabot>  Defined.
05:42:36 <vixey> > (fst (pair two two))
05:42:37 <lambdabot>   2
05:42:48 <ivanm> vixey: why are you @let'ing random things?
05:43:49 <bavardage> vixey: yeah but that's not the point
05:43:54 <bavardage> I'm not doing it to create lisp syntax
05:44:01 <bavardage> I'm doing this to learn about lambda calc
05:44:19 <bavardage> this is all derived from one function
05:46:09 <povman> bavardage: that's pretty cool
05:46:51 <vixey> povman, what is cool?
05:48:13 <povman> vixey: Implementing functions and numerals in terms of a simple lambda function
05:52:14 <LeCamarade> What enlightenment lies in dependent typing, before I sink some time into learning it?
05:52:38 <quicksilver> well dependent typing, itself, isn't something you need to learn.
05:53:21 <kadaver> hmm again, what do you think? Data.Matrix.vector or Data.Vector?
05:54:02 <quicksilver> LeCamarade: If you know enough to understand the words , then you know what it is.
05:54:21 <quicksilver> LeCamarade: what there is to learn is specific *implementations* of dependent typing, and their shortcomings + benefits.
05:54:40 <quicksilver> kadaver: Data.Matrix
05:54:40 <voker57> how to convert a string to [Octet]?
05:54:46 <LeCamarade> Well, I find that I never grasp these ideas until I do the language, for example.
05:54:56 <quicksilver> since vectors are just a 1 column matrix
05:55:00 <quicksilver> IMO.
05:55:14 <quicksilver> LeCamarade: read one or more of conor's papers.
05:55:14 <byorgey> LeCamarade: if you want to learn a dependently typed language, I suggest Agda.
05:55:15 <LeCamarade> I'm going to try to explore Epigram and see what there is, perhaps.
05:55:27 <quicksilver> but agda is probably more approachable than epigram
05:55:34 <LeCamarade> ?where agda
05:55:34 <lambdabot> http://tinyurl.com/yp6zsr
05:55:35 <quicksilver> conor's papers are good, though.
05:55:51 <quicksilver> voker57: I don't recognise 'Octet'
05:55:54 <byorgey> indeed.  and there seems to be hope that Epigram will be resurrected this summer.
05:56:12 <quicksilver> voker57: but the answer depends on what encoding you hope tu use for the string.
05:56:16 <vixey> byorgey, oh, how is that?
05:56:18 <LeCamarade> I have downloaded some Conor McBride papers. Two of them.
05:56:25 <voker57> quicksilver: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-Digest-SHA512.html
05:56:31 <LeCamarade> Why Dependent Types Matter, and epigram-notes.pdf.
05:56:43 <quicksilver> type Octet = Word8
05:56:47 <quicksilver> Ah, it's just Word8.
05:56:54 <quicksilver> well, my point stands.
05:56:56 <byorgey> vixey: ISTR Conor saying something about getting some time (and a grad student?) to work on Epigram 2 this summer
05:57:04 <quicksilver> the answer depends on what encoding you want to use for the String.
05:57:06 <byorgey> although my memory may be faulty.
05:57:35 <sampointon> will that be a from-scratch effort, or will it be an improvement on the previous work?
05:57:55 <voker57> quicksilver: please explain?
05:58:51 <quicksilver> voker57: Strings are unicode.
05:58:58 <quicksilver> voker57: if you want to represent a string as a sequence of bytes
05:59:03 <quicksilver> voker57: you have to choose an encoding.
05:59:25 <voker57> quicksilver: well, let's say UTF-8
05:59:41 <tromp> > maxBound :: Char
05:59:43 <lambdabot>   '\1114111'
05:59:47 <quicksilver> get utf8-string from hackage
05:59:51 <quicksilver> and use that to encode your string.
05:59:58 <voker57> ok
06:00:18 <kadaver> lol does PHP has 3000 builtin functions?
06:00:45 <quicksilver> that will give you encode :: String -> [Word8]
06:00:50 <voker57> kadaver: more, i think
06:00:52 <quicksilver> (and [Word8] is the same type as [Octet])
06:02:34 <kadaver> how many does Haskell have?
06:03:18 <ivanm> kadaver: you mean just in base?
06:03:30 <kadaver> yeah
06:03:37 <kadaver> or available from ghci
06:03:39 <pumpkin> 3001
06:03:40 <kadaver> no imports
06:03:47 <pumpkin> ah, so just in prelude
06:03:57 <ivanm> @docs Prelude
06:03:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:04:04 <ivanm> kadaver: ^^ count them :p
06:04:08 <Ferdirand> but that is not really a fair comparison
06:04:18 <gnuvince> @src isEOF
06:04:18 <kadaver> 2999
06:04:19 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:04:25 <gnuvince> @src isEof
06:04:26 <lambdabot> Source not found. Take a stress pill and think things over.
06:04:31 <kadaver> base=stdlib?
06:04:56 <ivanm> kadaver: base is the most basic libraries shipped with ghc
06:05:11 <ivanm> however, others such as arrays, containers, etc. also come with ghc
06:06:51 <kadaver> is Perl still better than everything elsefor pure text processing tasks?
06:07:01 <zachk> cabal is wonderful once one gets it to work :-D
06:07:11 <kadaver> yeah the cabal.exe for windows is awesome
06:07:27 <kadaver> to bad there is still problems when instaling some stuff on windows
06:07:30 <zachk> kadaver: perl is good if you can do the text proccessing via regexes
06:07:50 <zachk> yea the haskell libraries are definitely more geared towards *nix
06:07:50 <kadaver> ok not good for writing parsers?
06:08:01 <zachk> tbh ive never written a parser
06:08:15 <zachk> but id imagine it could be a pain if you tried to do it in perl
06:09:33 <zachk> kadaver: i remember writing some perl code a few years back. i commented the hell out of it. went back 3 months latter couldn't understand my code even with all the comments
06:10:54 <byorgey> kadaver: what's your metric?
06:11:18 <kadaver> metric?
06:11:53 <povman> kadaver: Parsec is beautiful and simple and quite efficient in my experience
06:11:55 <EvilTerran> how do you quantify "good"?
06:12:06 <ivanm> EvilTerran: if I say it's good, then it's good :p
06:12:27 <quicksilver> s/I say/quicksilver says/
06:12:39 <kadaver> zachk: yeah that kind of defeats its own purpose. but for quick one-time-use scripts I guess it is ok
06:12:59 <quicksilver> the only tasks for which I would consider perl 'better' than haskell are tasks which depend on libraries which exist for perl (CPAN is huge) and don't exist / aren't mature for haskell.
06:13:07 * EvilTerran has, in the past, tried to write a scraper for some website in perl, got stuck, re-written it in haskell, and had it work first time with less code
06:13:41 <daf> quicksilver: and some things that begin perl -p [-i] -e
06:14:10 <kadaver> EvilTerran: provability(or verifiability), readability, succinctness, speed, in that  order
06:14:25 <EvilTerran> daf, yeah, -pe and -ne let you write some very clever hacks in perl
06:14:36 <quicksilver> daf: well it only takes 5 minutes to write a runhaskell wrapper for perl -p/l/n [i]
06:14:47 <quicksilver> which you can then use for ever after.
06:14:50 <daf> I did
06:14:50 <sampointon> daf: I've found those are either too clever for their own good or could be replaced by sed/awk
06:15:03 <EvilTerran> kadaver, well, perl fails on provability and readability :P
06:15:16 <quicksilver> perl doesn't fail on readability.
06:15:22 <quicksilver> (not compared to haskell, anyway)
06:15:28 <quicksilver> unreadable code fails on readability.
06:15:33 <quicksilver> you can write that just as easily in either.
06:15:43 <EvilTerran> i know, but it's an old joke
06:15:49 <quicksilver> @pl \(a,b,c,d,e) -> (e,d,d,c,a,b)
06:15:49 <lambdabot> (line 1, column 6):
06:15:49 <lambdabot> unexpected ","
06:15:49 <lambdabot> expecting letter or digit, operator or ")"
06:15:49 <lambdabot> ambiguous use of a non associative operator
06:16:10 <quicksilver> @pl \(a,(b,(c,(d,e)))) -> (e,(d,(d,(c,(a,b)))))
06:16:14 <lambdabot> ap ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . (flip (,) .) . ap (,) . flip (,)) .) . flip (,)) .
06:16:14 <lambdabot> ) . (,) . fst) snd
06:16:14 <lambdabot> optimization suspended, use @pl-resume to continue.
06:16:23 <quicksilver> very readable :)
06:16:51 <quicksilver> the language I've used which is most "readable" is applescript.
06:16:58 <quicksilver> doesn't make it a good language, though...
06:16:59 <EvilTerran> ... that's going to be ridiculous
06:18:34 <dolio> cddddr &&& cadddr &&& caddr &&& cadr &&& car
06:18:49 <bavardage> damit
06:18:53 <quicksilver> dolio++
06:18:56 <bavardage> haskell lamdas don't allow recursion :P
06:18:58 <bavardage> GAAAH
06:19:02 <bavardage> well that sucks :D
06:19:14 <saml> bavardage, fix
06:19:17 <sampointon> can an upper bound be put on the size of the output of @pl, based on the size of the input?
06:19:17 <EvilTerran> bavardage, "(let f ... = ... in f)"?
06:19:18 <quicksilver> the lambda calculus doesn't allow recursion.
06:19:20 <quicksilver> try fix.
06:19:25 <quicksilver> sampointon: yes.
06:19:27 <bavardage> quicksilver: what's fix?
06:19:34 <bavardage> well really I should do w/o it
06:19:35 <daf> @t fix
06:19:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:19:40 <bavardage> since I'm trying to implement lambda calculus
06:19:40 <EvilTerran> bavardage, fix f = x where x = f x
06:19:45 <sampointon> quicksilver: is it a practical upper bound, or something ridiculous?
06:19:48 <daf> :t fix
06:19:49 <quicksilver> bavardage: it's the combinator which adds the power of recursion to a typed lamba calculus
06:19:50 <lambdabot> forall a. (a -> a) -> a
06:19:52 <bavardage> yeah
06:19:58 <bavardage> quicksilver: I'm gonna make my own..
06:20:01 <quicksilver> sampointon: it will be exponential, certainly.
06:20:09 <saml> > fix (\fac x -> if x <= 0 then 1 else x * fac (x - 1)) 10
06:20:11 <lambdabot>   3628800
06:20:13 <sampointon> something ridiculous, then
06:20:16 <quicksilver> sampointon: not sure if it's double exponential, you'd need to look at the rewrite rules.
06:20:28 <saml> > product [10,9..1]
06:20:29 <lambdabot>   3628800
06:20:39 <quicksilver> sampointon: note that haskell type checking is exponential too.
06:20:50 <kadaver> haskell is very readable...you dont think so quicksilver?
06:20:50 <kadaver> a well-chosen function name + type annotation combined with generally clear syntax makes it very readable. i rarely comment my haskell code because it is often self-evidnt what it does
06:20:51 <kadaver> fix == ycombinator?
06:21:05 <quicksilver> fix is closely related to the ycombinator
06:21:10 <quicksilver> they're not the same, though.
06:21:17 <quicksilver> (the y combinator is not typable, fix has a type)
06:21:20 <EvilTerran> kadaver, they're both fixed-point combinators
06:21:34 <quicksilver> kadaver: haskell can be readable, and so can perl.
06:21:45 <quicksilver> kadaver: that's my point - readability is a property of programs not languages.
06:21:57 <quicksilver> it's also subjective.
06:22:06 <quicksilver> so it's fairly hard to compare meaningfully.
06:23:21 <saml> readability isn't as important as interactability. as long as it is easy to poke around the code interactively
06:23:26 <sampointon> playing devil's advocate: some languages make it harder to write unreadable programs than others
06:23:39 <quicksilver> sampointon: I think that's quite subjective.
06:23:50 <quicksilver> I think it's actually a feature of the *culture* not the language.
06:24:10 <quicksilver> it's a feature of the tutorials you read, the library code you copy, the library code your library authors copied when they wrote their libraries.
06:24:26 <quicksilver> idiomatic language style is a very cultural issue.
06:24:32 <sampointon> quicksilver: we're in danger of going into linguistics land now, and Sapir-Whorf :)
06:24:59 <saml> VB rocks /offtopic
06:26:00 <saml> > 10 `PRINT` "Hello World"  where PRINT _ s = putStrLn s
06:26:01 <lambdabot>   Not in scope: data constructor `PRINT'Not in scope: data constructor `PRINT'
06:26:21 <kadaver> quicksilver: i think both, i defineately think python and haskell programs on average are more readable than Java or Perl ones
06:26:30 <kadaver> i mena obv brainfuck isnt as readable
06:26:42 <EvilTerran> intercal!
06:27:08 <saml> kadaver, it can be very readable with proper editor/ide
06:27:11 <saml> just like xml
06:27:22 <sampointon> Visual Brainfuck?
06:27:37 <quicksilver> sure, but 'on average' is a cultural survey.
06:28:03 <quicksilver> PHP is 'on average' truly horrific, because there are many extraordinaly poor programmers who use PHP.
06:28:10 <quicksilver> however that's not really PHP's fault, per se.
06:28:18 <quicksilver> (there are other things which *are* PHP's fault ;P )
06:28:34 <kadaver> sure thats one contributing factor but surely you must agree that all languages arent created equal readability-wise?
06:28:42 <quicksilver> PHP written by a good programmer who modularises his code nicely and avoids global variables is very different.
06:28:48 <quicksilver> Yes, I do.
06:29:09 <quicksilver> I just think that C, perl, python, haskell and lisp are created pretty damn close to equal.
06:29:17 <bavardage> wiki gives this as the Y-combinator
06:29:18 <quicksilver> the differences which emerge are about style and culture.
06:29:19 <bavardage> Y = λ g. (λ x. g (x x)) (λ x. g (x x))
06:29:25 <bavardage> how do I translate this into haskell?
06:29:32 <neoswish> anybody knows, is there some auto-memoization technic in haskell? i saw this feature in python and just wondering...
06:29:40 <quicksilver> it doesn't type check, bavardage.
06:29:46 <bavardage> y = (\g -> (\x -> g (x x)) (\x -> g (x x))) fails with Occurs check: cannot construct the infinite type: t = t -> t1
06:29:47 <osfameron> quicksilver: even C ?
06:29:49 <EvilTerran> bavardage, you don't
06:29:50 <quicksilver> that only works in the untyped lambda calculus.
06:29:56 <bavardage> oh dammit
06:30:00 <quicksilver> you can do newtype L = L (L -> L)
06:30:02 <quicksilver> if you like.
06:30:06 <bavardage> and I cant implement that in haskell?
06:30:08 <quicksilver> but it's fiddly to use.
06:30:12 <bavardage> (I'm trying to implement lamba calc)
06:30:15 <EvilTerran> bavardage, if you want to do recursion in haskell, you can just, y'know, do it directly
06:30:22 <bavardage> but... :(
06:30:23 <quicksilver> EvilTerran: he's just exploring / learning.
06:30:29 <bavardage> yeah
06:30:33 <quicksilver> you can write Y with my newtype.
06:30:35 <EvilTerran> bavardage, you don't need to bother with faking it via a cleverly-written non-recursive fixed-point combinator
06:30:38 <quicksilver> there will be some wrapping/unwrapping.
06:30:43 <bavardage> hmm
06:30:45 <EvilTerran> which is just as well, seeing as those combinators don't work in haskell
06:30:55 <povman> neoswish: I think the compiler sometimes recognises when two expressions are the same and shares values
06:31:30 <sjanssen> neoswish: yes, there are several ways to memoize in Haskell
06:31:31 <EvilTerran> povman, i don't think it usually acts on that sort of thing
06:31:32 <bavardage> quicksilver: so I need that kinda of type for recursion in lamba expressions?
06:31:40 <sampointon> neoswish: GHC -can- do common subexpression evaluation (I think that's the term used), but it's not necessarily very aggressive because it can be memory intensive
06:31:46 <EvilTerran> as it could lead to memory leaks
06:31:53 <quicksilver> no, you could just use fix.
06:31:54 <peropaal> Thanks BONUS for burning my brain
06:32:03 <bavardage> quicksilver: oh right
06:32:04 <quicksilver> but you can use my newtype and the Y combinator if you like.
06:32:05 <sampointon> neoswish: your code has to be written in a fairly specific way to point the compiler in the right direction
06:32:11 <quicksilver> contrary to what EvilTerran just said, it *will* work.
06:32:19 <povman> Oh really. I heard it happens at least in let expressions...
06:32:25 <sjanssen> fibs = 0 : 1 : zipWith (+) fibs (tail fibs); nfib n = fibs !! n
06:32:43 <sjanssen> povman: yes, about the only time GHC will share a value is when you give it a name
06:33:03 <quicksilver> (or when some intermediate optimisation gives it a name you didn't know about)
06:33:07 <povman> oh right. Ok!
06:35:58 <kadaver> @seen JWBarton
06:35:59 <lambdabot> I haven't seen JWBarton.
06:36:19 <kadaver> @seen barton
06:36:19 <lambdabot> I haven't seen barton.
06:36:20 <kadaver> he did bin packing math right?
06:36:21 <EvilTerran> quicksilver, well, i wasn't thinking of using a newtype to fudge it when i said that
06:36:27 <byorgey> kadaver: you mean rwbarton?
06:36:34 <kadaver> the algorithmic language Scheme. what is a language if not algorithmic?
06:37:00 <byorgey> @whois kadaver
06:37:01 <lambdabot> Unknown command, try @list
06:37:08 <byorgey> er, whoops =)
06:37:19 <kadaver> @seen rwbarton
06:37:20 <lambdabot> Last time I saw rwbarton was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
06:37:20 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
06:37:20 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 2m 23d 8h 6m 46s ago,
06:37:20 <lambdabot> and .
06:37:27 <sampointon> kadaver: prolog?
06:37:50 <ChristianRobert> Guys, i got a question please... Is there any way to turn a IO String into a normal string, cause i want to read its length with length. Please?
06:37:54 <fasta> Is there a working version of fmapM_  available somewhere? It appears that the functorm package does not work.
06:38:00 <nvoorhies> if a language is fully algorithmic doesn't that mean all the programs will terminate?
06:38:14 <sw1sh> ChristianRobert: unsafePerformIO
06:38:17 <byorgey> ChristianRobert: no, there isn't.  but you can compute its length.
06:38:25 <fasta> nvoorhies: who uses that terminology?
06:38:28 <byorgey> sw1sh: that isn't what ChristianRobert wants.
06:38:32 <ivanm> liftM length
06:38:33 <sampointon> no, algorithms don't need to terminate. Consider things like algorithms for computing digits of pi
06:38:35 <ivanm> @type liftM length
06:38:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m Int
06:38:41 <ChristianRobert> actually we dont want to compute its length but just give it to a function that only accepts string
06:38:50 <fasta> sampointon: you are wrong
06:38:57 <nvoorhies> fasta: no idea.  Someone just said "the algorithmic language"
06:38:59 <byorgey> do { s <- thingThatComputesAnIOString ; functionThatAcceptsString s }
06:39:00 <pejo> ChristianRobert, call that function from inside your do-block.
06:39:02 <ivanm> ChristianRobert: liftM "lifts" a non-monadic function into the monad
06:39:09 <ivanm> or else you can use do and let
06:39:13 <fasta> sampointon: an algorithm -- by definition -- always terminates.
06:39:31 <ivanm> for some reason, in Haskell most functions that do things aren't themselves in IO... >_>
06:39:45 <povman> byorgey++ for understanding how newbies think
06:40:00 <ivanm> after all, that's the point of the IO monad: to seperate the computation from the real world
06:40:13 <pejo> byorgey++
06:40:24 <povman> fail
06:40:28 <povman> does that even work?
06:40:28 <ivanm> povman: as opposed to the usual "what's the coolest way we could do this?" attitude we #haskell'ers normally take?
06:40:33 <ivanm> povman: what?
06:40:35 <quicksilver> fasta: fmapM_ was replaced by Traversable
06:40:38 <povman> the ++ thing
06:40:39 <kadaver> i said the algorithmic lanagueg Scheme and then asked as opposed to what+
06:40:40 <quicksilver> fasta: and foldable
06:40:45 <ivanm> povman: yes
06:40:47 <ivanm> @karma byorgey
06:40:48 <lambdabot> byorgey has a karma of 16
06:40:49 <quicksilver> fasta: (foldable for your case, since you had a _)
06:40:54 <povman> yay!
06:41:38 <sampointon> fasta: hmm, I was under the impression an algorithm was defined as a finite list of instructions, nothing more. Wikipedia says that there are different definitions
06:42:18 <ChristianRobert> wow... im not sure man, thanks for the answers. But, I don't know how to use it actually... Its like do  filename <- readFile "hi.pgm" , head filename
06:42:21 <povman> ivanm: I think most newbie questions come from people with an imperative programming background, so something in imperative style is easier to understand than liftM
06:42:35 <fasta> sampointon: It is formally a type of effective method in which a list of well-defined instructions for completing a task will, when given an initial state, proceed through a well-defined series of successive states, eventually terminating in an end-state.
06:42:35 <ivanm> povman: yes, I missed the whole newbie thing as well
06:42:43 <fasta> sampointon: which is what I said, from wikipedia.
06:43:02 <povman> Never mind :P I'm being an atrocious human this week
06:43:08 <fasta> Not that I believe wikipedia is the final word on everything :)
06:44:19 <kadaver> does Haskell have eval? could you write a program that takes a string at the command prompt and executes the contents of the string(sure you could write a parser)?
06:44:33 <sampointon> fasta: of course :) But the same article says: "Some writers restrict the definition of algorithm to procedures that eventually finish. [...] Others, including Kleene, include procedures that could run forever without stopping"
06:44:37 <doserj> > let f .: g = (f .) . g ; swap = flip (,) in (uncurry . uncurry . uncurry)  ((swap .: swap) .: swap)  $ (((1,2),3),4)
06:44:38 <lambdabot>   (4,(3,(2,1)))
06:45:31 <Peaker> @type uncurry (flip (,))
06:45:32 <lambdabot> forall b a. (a, b) -> (b, a)
06:45:58 <fasta> sampointon: even Kleene notes that such a method must eventually exhibit "some object"
06:46:51 <sampointon> fasta: well, taking the digits of pi example, is that not producing an object, which happens to be infinite in length?
06:47:05 <sjanssen> kadaver: one can embed GHC's interpreter
06:47:42 <fasta> sampointon: well, that depends on lots of things, but the modern definition of algorithm is something which terminates.
06:47:46 <sampointon> fasta: at this point it's just arguing definitions, which is even more pointless than computing pi to a squillion decimal places. We should agree to disagree :)
06:48:29 <fasta> sampointon: I am fairly sure that everyone with a CS degree will agree with me.
06:49:18 <fasta> sampointon: if you write a paper and use your definition of algorithm, people will hate you for doing so.
06:50:23 <swiert> fasta: I think that's a bit harsh. sampointon has a point.
06:50:42 <swiert> there are plenty of things I would call algorithms that don't necessarily terminate.
06:50:51 <fasta> swiert: you don't have an algorithms background, AFAIK.
06:52:04 <sjanssen> wikipedia does say "eventually terminating in an end-state"
06:52:27 <doserj> is f 1 = True ; f n | even n = f (n`div`2) | otherwise = f (3*n+1) an algorithm?
06:52:32 <sjanssen> http://en.wikipedia.org/wiki/Algorithm#Termination apparently the point is controversial
06:53:18 * TheRealMarko votes for 'needs to terminate' (at least that's what we learned in cs a few years back)
06:53:58 * sjanssen thinks it is funny that there is no algorithm to determine whether something is an algorithm under fasta's definition
06:55:04 <TheRealMarko> http://en.wikipedia.org/wiki/Halting_problem
06:55:14 <dikini> hi all, could you help me understand an occurs check please
06:55:43 <dikini> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2132#a2132
06:55:47 <vixey> dikini: you can't unify a variable with a term containing that variable because of the occurs check
06:56:00 <vixey> dikini: that stops any infinite structures being created by unification
06:56:44 <dikini> what I don't get is what in the above code I'm doing to trigger that
06:56:47 <vixey> dikini: I think  data (BeeBehaviour a) => BeeState a  should be data BeeState a  though
06:57:24 <sjanssen> dikini: the problem is "Observe a" in the data defn, "   observe   :: [a] -> a
06:57:36 <sjanssen> " in the class, and bee_behaviour h (Observe s) = Forage (observe h)
06:57:49 <fasta> As TheRealMarko says, your precious Wikipedia implicitly supports "my" definition in http://en.wikipedia.org/wiki/Halting_problem
06:58:03 <sjanssen> dikini: you're passing a value not known to be a list to a function requiring a list
06:58:10 <byorgey> ChristianRobert: I'd recommend reading something like http://www.haskell.org/haskellwiki/Haskell_IO_for_Imperative_Programmers or  http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html
06:58:25 <vixey> oh no are people arguing about the halting problem
06:58:40 <sjanssen> fasta: I'm not supporting or rejecting either definition, I just find the fact funny
06:58:47 <fasta> vixey: no, worse, they doubt what the modern definition of an algorithm is.
06:58:48 <byorgey> vixey: even worse, people are arguing about the definition of "algorithm"
06:59:12 <dikini> sjanssen: but I annotated bee_behaviour so that the hive should be known to be a list
06:59:15 <vixey> that's not worse :p
06:59:19 <dikini> sjanssen: that's what gets me
06:59:19 <sjanssen> fasta: also, wikipedia explicitly notes that termination is a controversial point
06:59:27 <vixey> the only thing worse is arguing about godels work
06:59:29 <byorgey> fasta: cut it out.  belittling others is not appropriate.
06:59:38 <sjanssen> dikini: oh, you're right.  I confused by variables
06:59:42 <fasta> sjanssen: I note that wikipedia does not represent universal truth.
06:59:45 <dikini> sjanssen: do I do the annotations wrong?
07:00:00 <quicksilver> dikini: yes
07:00:01 <tromp> to me it's context dependent
07:00:06 <dikini> :)
07:00:11 <quicksilver> dikini: 'h' is [BeeState a]
07:00:17 <quicksilver> dikini: but 'observe' is [a] -> a
07:00:22 <quicksilver> (not [BeeState a] -> a)
07:00:37 <sjanssen> fasta: RTFA, it cites specific people who hold the alternate definition
07:00:47 <quicksilver> which did you want observe to be? does it take "as" or "BeeState a"
07:00:48 <tromp> if you ask for an algorithm for deciding primality, it should be terminating
07:00:52 * dikini smack his head
07:00:52 <fasta> sjanssen: I did, and those references are very old.
07:01:00 <vixey> fasta: not even that, most CS articles on wiki are trash
07:01:12 <tromp> but you should also be able to talk about an algorithm for generating the list of all primes
07:01:14 <quicksilver> dikini: that's where it deduces that a = BeeState a
07:01:27 <quicksilver> dikini: and thats where the error message comes from.
07:01:41 <byorgey> @where hpaste
07:01:41 <lambdabot> http://hpaste.org/
07:01:41 <quicksilver> it's not a good error message, really. SHould have better location info somehow.
07:01:52 <EvilTerran> i think this conversation admirably demonstrates the importance of defining any potentially ambiguous terminology before you start using it
07:01:53 <dikini> quicksilver: tit should be [BeeState a], I was just lazy, and I get the problem now
07:01:57 <quicksilver> ;)
07:02:09 <dikini> quicksilver, sjanssen: thanks a lot
07:02:21 <fasta> EvilTerran: that only leads to articles with even longer preliminaries.
07:03:01 <fasta> EvilTerran: if there is anyone here who learned the definition of algorithms as is proposed here by some other people, please raise hands.
07:03:07 <quicksilver> fortunately, algorithm is seldom ambiguous in context.
07:03:17 <quicksilver> I declare this conversation dull. Please take it to -blah or -overflow.
07:03:30 <EvilTerran> ^
07:03:51 <byorgey> anyone want to take a look at my type error?  I can't figure out why it won't typecheck.  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2133#a2133
07:03:55 <byorgey> it's probably something silly.
07:04:06 <dikini> vixey: I'm intentionally overdoing the constraints on BeeState, since I write this to explain and compare a bunch of 'bee' optimisation different algorithms, so I want to be as explicit as possible
07:04:08 <kadaver> i have written a program for a chicken staircase regulator
07:04:23 <vixey> dikini: it's not more explicit to put that there
07:04:33 <dikini> I guess I should check my language
07:04:40 <marcot> How can I parse everything till a especific char, in parsec, like [^\n]*\n in regexp.
07:05:05 <vixey> byorgey, what's selector?
07:05:09 <vixey> Selector*
07:05:40 <kadaver> how ies bee swarm optimization different form ant colony?
07:06:13 <TheRealMarko> fasta, sjanssen: Knuth's suggestion for an 'algorithm that does not terminat'  was "computational method"
07:06:14 <dikini> vixey: you are right, I might be overdoing it, the way the annotations are atm, they just restate facts
07:06:30 <byorgey> vixey: if you have a functor over x, it selects a particular x.  for example, it might select an Int from an (Int,Int)
07:06:40 <quicksilver> dikini: annotations in data declarataions don't really work in haskell, and are probably bad style.
07:06:41 <vixey> Just . (!!2) :: Selector []
07:06:52 <fasta> TheRealMarko: (I already knew that. )
07:07:13 <byorgey> vixey: right.  although it's generally intended to be used with non-recursive types.
07:07:27 <quicksilver> byorgey: I didnt think you were allowed to have a forall in a type synonym.
07:07:31 <marcot> manyTill.
07:07:40 <vixey> byorgey, why non recursive types?
07:07:41 <quicksilver> ah, rank2types
07:08:21 <vixey> byorgey, it says newtype Path f = Path [Selector f]
07:08:29 <vixey> needs XImpredicativeTypes
07:08:37 <quicksilver> I was just thinking that
07:08:39 <vixey> how come you don't have that in your past ?
07:08:41 <vixey> paste
07:08:43 <quicksilver> surprised that doesn't give a more specific error
07:09:24 <TheRealMarko> fasta: I wouldn't have thought otherwise, just wanted to brag ;-)
07:09:35 <byorgey> ImpredicativeTypes?
07:09:39 <byorgey> is that 6.10 only?
07:09:43 <vixey> I don't know
07:09:56 <vixey> I have 6.10.1
07:10:01 <dikini> quicksilver: probably, I don't need them to work, I've left them there, so that when I discuss the different implementations I need to highlight less of the constraints, the intent was to save hand waving, but those are redundant
07:10:11 <byorgey> I'm still using 6.8.3 here, it says unsupported extension
07:10:22 <byorgey> anyway, why would ImpredicativeTypes help?
07:10:25 <vixey> byorgey what does  map (. out) ps  mean? where ps is a path and out is the Mu projection
07:10:25 <quicksilver> maybe in 6.8 rank2types turns on impredicative
07:10:26 <fasta> TheRealMarko: I like "procedure" more, however. Then you have algorithm= effective procedure.
07:10:33 <quicksilver> your Path is impredicative.
07:10:39 <vixey> byorgey, I don't know... just that GHCi said I have to use that
07:10:59 <vixey> (. out) :: (f (Mu f) -> c) -> Mu f -> c
07:11:07 <byorgey> vixey: right
07:11:10 <kadaver> http://en.wikipedia.org/wiki/Kd_tree <- im trying to do the plane intersecing stuff but is it ok just doing euclideanDistance between vectors? i guess not since the distance isnt the same as sorted on order
07:11:12 <vixey> map (. out) :: [f (Mu f) -> c] -> [Mu f -> c]
07:11:37 <vixey> what happens with:  f (Mu f) -> c = forall x. f x -> Maybe x
07:11:39 <byorgey> and ps :: [f (Mu f) -> Maybe (Mu f)]
07:11:42 <TheRealMarko> fasta: "procedure" sounds good to me
07:11:59 <vixey> can that unify ? I don't know what foralls do to the process
07:12:00 <TheRealMarko> fast: shorter than c.m.
07:12:07 <byorgey> vixey: hm, maybe you're right
07:12:16 <vixey> byorgey, but what /should/ map (. out) ps do?
07:12:29 <vixey> I don't really get it.. is that just like shifting the projection in one?
07:12:38 <byorgey> vixey: I was expecting it to have type [Mu f -> Maybe (Mu f)]
07:13:20 <byorgey> vixey: it's just promoting the selectors over f  to selectors over Mu f
07:13:35 <vixey> so  Selector f -> Selector (Mu f) ?
07:13:50 <byorgey> well, not quite, that's not well-kinded
07:14:02 <vixey> hmm
07:14:09 <byorgey> what I said is just the intuition, I guess
07:15:06 <byorgey> actually, I guess what it's really doing is instantiating the  'x'  with  'Mu f'
07:15:45 <vixey> byorgey, just to see if I am understanding |>, suppose I have o = [[a,b,c],[d,e,f],[g,h,c]]
07:15:59 <byorgey> ok
07:16:03 <vixey> byorgey, and then  o |> [ third , first ] = g ?
07:16:05 <vixey> oops
07:16:13 <vixey> o should have In in various places in there
07:16:25 <vixey> like In [ In [ In a , ... ] , ... ] I guess
07:16:46 <byorgey> right, that's the idea
07:16:49 <vixey> ok
07:17:10 <vixey> oh that is interesting
07:17:19 <kadaver> isnt size or length a part of Foldable? why not?
07:17:57 <Botje> you can trivially construct them? :)
07:18:01 <kadaver> is there some general function for taking a value out of a data?
07:18:13 <kadaver> instead of writing fromData (Data x) = x
07:18:36 <byorgey> kadaver: I guess there isn't actually a size/length function in Data.Foldable, but it's easy to write
07:18:56 <byorgey> foldMap (const (Sum 1))
07:19:17 <vixey> blugh
07:19:19 <vixey> I can't define o
07:19:20 <Botje> :t foldMap
07:19:21 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
07:19:27 <Botje> heh
07:19:28 <Botje> cool!
07:19:35 <QtPlaty[HireMe]> What does prefixing a type with ! do?
07:20:29 <byorgey> kadaver: if you use record syntax,   data Data a = Data { foo :: a },  then you get an extraction function called 'foo' for free
07:20:33 <orbitz> a type or a paraemter to afunction?
07:20:33 <lambdabot> orbitz: You have 1 new message. '/msg lambdabot @messages' to read it.
07:20:43 <byorgey> kadaver: otherwise, there's no way other than writing your fromData function.
07:20:55 <byorgey> QtPlaty[HireMe]: it's a strictness annotation
07:21:04 <bavardage> someone mentioned earlier that I could use fix to implement recursion in lamba calc
07:21:07 <bavardage> how do I do this?
07:21:17 <QtPlaty[HireMe]> data Foo = Foo Bar !Baz
07:21:42 <byorgey> QtPlaty[HireMe]: that means that the 'Baz' value stored in a Foo should always be evaluated (to weak head normal form)
07:21:59 <quicksilver> byorgey: I have wondered if there should be a method, though, on the grounds that it might be faster.
07:22:00 <Botje> bavardage: fix (\self arg1 arg2 -> ... use self here, somewhere)
07:22:05 <quicksilver> byorgey: e.g. O(1) or O(log n)
07:22:12 <bavardage> right kk
07:22:29 <byorgey> quicksilver: a method for what?
07:22:37 <quicksilver> byorgey: size on Foldable.
07:22:59 <byorgey> quicksilver: ah. indeed.
07:23:40 <vixey> byorgey, stuff like: data Tree a tree = Leaf a | Branch tree tree ?
07:23:45 <vixey> is that what you are writing this for?
07:23:55 <byorgey> vixey: right
07:24:09 <vixey> so would it be: left :: Selector (Tree a) ?
07:24:16 <byorgey> vixey: exactly
07:25:30 <vixey> :(
07:25:36 <vixey> I want a show instante for Mu (Tree a)
07:25:48 <kadaver> I import Vector which implements Foldable and then I import Prelude which hides foldr. but then I get foldr not in scope
07:25:50 <byorgey> quicksilver: but couldn't you make the same argument for any method over a Foldable?
07:25:59 <sw17ch> morning all
07:26:01 <byorgey> you can always cache the values and update incrementally
07:26:07 <byorgey> for a monoid
07:26:23 <byorgey> vixey: instance (Show (f (Mu f)), Functor f) => Show (Mu f) where show (In fmf) = "[" ++ show fmf ++ "]"
07:26:32 <byorgey> and turn on UndecidableInstances
07:26:42 <Botje> kadaver: it's called gfoldr i think
07:26:48 <Botje> @hoogle gfold
07:26:48 <lambdabot> Data.Generics.Basics gfoldl :: Data a => c (a -> b) -> a -> c b -> g -> c g -> a -> c a
07:26:49 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (d -> r) -> d -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
07:27:18 <yrlnry> Morning, Brent.
07:27:26 <Saizan_> kadaver: you've to import Data.Foldable too
07:27:28 <byorgey> hi yrlnry
07:27:33 <vixey> that even works without Functor
07:27:44 <byorgey> vixey: ah, so it does! =)
07:28:40 <quicksilver> byorgey: well, size seems particularly egregrious.
07:29:05 <quicksilver> byorgey: since it's a well-known useful quantity any many interesting foldable instances have faster ways to calculate it than O(n).
07:29:12 <vixey> byorgey, I tried something out
07:29:17 <byorgey> quicksilver: I guess that's true.
07:29:19 <vixey> < (fromJust . right . out) . (fromJust . left . out) $ o
07:29:20 <vixey> (In Leaf 1)
07:29:41 <vixey> and you're using >=> to deal with the fromJust?
07:30:01 <byorgey> vixey: right
07:30:04 <byorgey> @type (>=>)
07:30:06 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:30:28 <byorgey> composition in the Kleisli category =)
07:30:55 <vixey> oh I totally get it now
07:31:23 <quicksilver> hmm, < is the prefix to make vixey evaluate stuff?
07:31:26 <quicksilver> < 2 + 2
07:31:32 <vixey> 22
07:31:33 <wpearson> > True || undefined
07:31:35 <lambdabot>   True
07:31:44 <quicksilver> seems slightly eccentric.
07:31:59 <wpearson> > undefined || True
07:32:00 <lambdabot>   * Exception: Prelude.undefined
07:32:58 <wpearson> Is there any rhyme or reason to undefined?
07:33:11 <quicksilver> yes.
07:33:19 <quicksilver> plenty of reason.
07:33:25 <quicksilver> off-hand, I can't think a rhyme.
07:33:37 <kadaver> when i import Foldable do I get the sum for lists then? because I hide the sum from Prelude but it still works for lists
07:33:42 <wpearson> Maligned?
07:33:45 <kadaver> Haskell namespacing is a bit meh
07:33:54 <voker57> how to convert a number to hex?
07:33:58 <vixey> byorgey, (=<<) (right . out) . (=<<) (left . out) $ Just o
07:34:03 <kadaver> or i guess nto but it is a sideeffect from other goodness
07:34:03 <quicksilver> when you import Foldable you get exactly what Foldable exports.
07:34:08 <vixey> that one works, but (right . out) >=> (left . out) >=> return o doesn't
07:34:10 <quicksilver> I doubt it exports sum.
07:34:15 <daf> voker57: Numeric.showHex
07:34:23 <quicksilver> sum is probably exported by Prelude and maybe Data.List ?
07:34:29 <daf> or Text.Printf if you want padding
07:35:13 <kadaver> nope
07:35:33 <byorgey> vixey: ((right . out) >=> (left . out) >=> return) o
07:35:53 <vixey> ohhh
07:35:54 <byorgey> quicksilver: Foldable does export sum.
07:36:00 <byorgey> @type Data.Foldable.sum
07:36:01 <quicksilver> how bizaree.
07:36:02 <lambdabot> forall (t :: * -> *) a. (Num a, Data.Foldable.Foldable t) => t a -> a
07:36:07 <quicksilver> ah, it's a different sum.
07:36:09 <quicksilver> fair enough.
07:36:10 <byorgey> right.
07:36:21 <byorgey> kadaver: the sum from Foldable has the same behavior on lists as the sum from the Prelude.
07:36:23 <vixey> byorgey did you write |> yet?
07:36:28 <quicksilver> @hoogle sum
07:36:29 <lambdabot> Prelude sum :: Num a => [a] -> a
07:36:29 <lambdabot> Data.Foldable sum :: (Foldable t, Num a) => t a -> a
07:36:29 <lambdabot> Data.List sum :: Num a => [a] -> a
07:36:29 <wpearson> I'd like || to be commutative on undefined, any reason why not?
07:36:31 <kadaver> a canonical representation for Matrices and Vectors in Haskell would be nice.
07:36:33 <quicksilver> I should have tried that.
07:36:42 <byorgey> kadaver: in fact, Foldable exports a bunch of functions which are just generalizations of list functions from the Prelude.
07:36:47 <voker57> thanks
07:36:47 <kadaver> is hmatrix actively maintained?
07:36:51 <cooldude127> kadaver: i rather like hmatrix for matrices and vectors
07:36:59 <cooldude127> i just discovered it and it's wonderful
07:37:04 <quicksilver> wpearson: _|_ is not detectable.
07:37:18 * cooldude127 thinks it's weird that he came in in the middle of a discussion about it
07:37:27 <quicksilver> wpearson: there's no pure haskell || which is symmetric wrt to _|_.
07:37:34 <quicksilver> you can cheat with threads, it's pretty ugly.
07:37:39 <byorgey> wpearson: try parCommute from the lub package.
07:37:40 <kadaver> cooldude127: cant get it working on widnows , trying with mingw
07:37:54 <dolio> Even with threads you can't solve the halting problem.
07:38:02 <quicksilver> dolio: no, but you can restore the symmetry.
07:38:07 <cooldude127> kadaver: i will say that i couldn't get it installed right on OS X either, but it's awesome on linux
07:38:17 <wpearson> Hmm, thanks all.
07:38:31 <cooldude127> kadaver: it's because of dependencies on gsl and LAPACK/BLAS
07:38:38 <byorgey> vixey: it works if I take out the 'forall x' on Selector and add a bunch more type arguments to things.
07:38:38 <dolio> Hmm, yeah, I suppose that's true.
07:38:50 <dolio> I wasn't thinking straight, apparently.
07:39:10 <byorgey> vixey: I'll have to think more carefully about why it doesn't work with the 'forall' there, and what I really mean.
07:39:18 <cooldude127> is there convenient way to time the execution of a function inside of haskell?
07:39:43 <quicksilver> not entirely well-defined in haskell
07:39:51 <quicksilver> functions might execute 'bit by bit'
07:39:55 <quicksilver> as you demand the parts
07:39:59 <quicksilver> (because of lazy evaluation)
07:40:15 <quicksilver> timing an IO action is easy enough with getCurrentTime from Data.Time.
07:40:29 <vixey> byorgey, it works too if you use data instead of a type synonym
07:40:30 <cooldude127> quicksilver: so could i execute my function in the IO monad and do that?
07:40:36 <byorgey> vixey: oh, really?
07:40:44 <vixey> byorgey, yeah like data Selector f = Sel (forall x. f x -> Maybe x)
07:41:04 <pejo> cooldude127, there's a "timeit" package available on hackage.
07:41:08 <vixey> because teh pattern match gives a chance to instantiate the forall
07:41:11 <byorgey> cool, let me try that
07:41:13 <byorgey> oh, I see
07:41:16 <cooldude127> pejo: i'll check that out
07:41:16 <vixey> but with a type synynom nobody really knows what to do
07:42:10 <vixey> byorgey, but  type Selector f = f x -> Maybe x  gets rejected for me
07:42:26 <byorgey> vixey: right, you have to say  Selector f x = f x -> Maybe x
07:42:31 <quicksilver> cooldude127: no.
07:42:38 <byorgey> that's what I meant by 'add a bunch more type arguments'
07:42:42 <quicksilver> cooldude127: executing a function "in the IO monad" doesn't stop it being lazy.
07:42:42 <vixey> then what is Path?
07:42:54 <quicksilver> cooldude127: you need to take care to demand the parts of the result you want to demand.
07:43:12 <cooldude127> quicksilver: is there a way to demand everything?
07:43:17 <quicksilver> cooldude127: an ugly but simple way of doing that is to print it out
07:43:29 <quicksilver> although you may end up spending more time printing than calculation.
07:43:45 <quicksilver> otherwise, you could see rnf
07:43:48 <quicksilver> @hoogle rnf
07:43:49 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:43:53 <cooldude127> ewww
07:45:01 <vixey> byorgey, with fromPath (Path ps) = ps I guess you can go with Mu f -> (forall x. Path f x) -> Maybe (Mu f) ?
07:45:05 <vixey> is that what you did
07:45:08 <vixey> (that works)
07:45:46 <byorgey> that's not what I did but I was going to try that
07:45:46 <vixey> byorgey, it might be an interesting example to code in Agda (where types can be instantiated explicitly)
07:46:05 <vixey> probably data Selector f = Sel (forall x. f x -> Maybe x) is the nicest I can see
07:46:08 <byorgey> but now I'm trying it with  Selector being a newtype instead of a type synonym
07:46:17 <skorpan> suppose i have "data X t = X t t t"...  is it possible to pattern-match only the constructor in a function "f (X _) = undefined" no matter how many parameters it has?  i know it's possible to do with record-syntax but i can't be bothered making up silly selector functions.
07:46:17 <vixey> oh yeah or a newtype
07:46:20 <byorgey> vixey: yeah, I might code it in Agda later too.
07:46:35 <vixey> skorpan: You can use f (X {}) without record names
07:46:42 <byorgey> skorpan: f (X{}) = ...
07:47:00 <vixey> byorgey, if you do .. show me ! :p
07:47:04 <skorpan> oh, i can?  awesome, thanks!
07:47:11 <vixey> byorgey, I used:
07:47:12 <vixey> o = In (Branch (In (Branch (In (Leaf 0))
07:47:12 <vixey>                            (In (Leaf 1))))
07:47:12 <vixey>                (In (Branch (In (Leaf 2))
07:47:12 <vixey>                            (In (Leaf 3)))))
07:47:14 <vixey> to test it
07:47:40 <quicksilver> byorgey: funny. My initial guess was that type synonyms didn't support rank2types
07:47:55 <quicksilver> byorgey: and then I thought that can't be it, because I would expect a different error message in that case.
07:48:08 <quicksilver> byorgey: I think you can at least claim you have uncovered a bug in GHC's error reporting.
07:48:17 <byorgey> it works! vixey++
07:48:34 <quicksilver> byorgey: that bug should have been "illegal type synonym - even with Rank2Types, type synonyms maynot have nested foralls"
07:49:28 <bavardage> gah...
07:49:35 <bavardage> I can't seem to get fix to work
07:50:13 <bavardage> > sum = fix (\rec -> \l -> ifthenelse (isnil l) zero (add (head l) (rec (tail l))))
07:50:14 <lambdabot>   <no location info>: parse error on input `='
07:51:08 <bavardage> Occurs check: cannot construct the infinite type: t = (t1 -> t1 -> t1) -> (t2 -> t2 -> t2) -> t
07:51:10 <pejo> bavardage, you only have 1 argument to rec?
07:51:13 <_yziquel> got a funny question: Let l be a sorted list of relatively prime positive numbers whose median is of a much smaller order of magnitude than the length of the list. The list s is defined as being the sorted list (stricly increasing) of sums of distinct elements of l. (i.e, if l is 1,3,7,9,30, then s is 0,1,3,4,7,8,9,10,11,12,13,16,17,19,20,30,31,...). Goal: An
07:51:14 <QtPlaty[HireMe]>  Is there anouther name for flip const ?
07:51:22 <bavardage> pejo: indeed
07:51:32 <_yziquel> efficient lazy evaluation of s. (I know that overall it's roughly O(2^n) (without the assumption on the "order of magnitude", but what I want is to be able to evaluate efficiently what is the next element of the list s).
07:52:05 <byorgey> vixey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2133#a2136
07:52:11 <bavardage> pejo: do you mean there should be more arguments?
07:54:15 <cristi_ceata> hello! I tried to write a function that prints the lines of a file one by one, but I can't figure out why it doesn't compile http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2135
07:55:35 <doserj> do exp0 <- hisEOF file ; if exp then ... else ...
07:55:44 <Saizan_> byorgey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2133#a2137
07:55:59 <byorgey> quicksilver: agreed.  I guess I should test it with 6.10.1 first, though, to see if the error is improved
07:56:41 <byorgey> Saizan_: huh.
07:56:54 <pejo> bavardage, sorry, not sure what I was thinking when I said that.
07:57:01 <byorgey> Saizan_: are you using 6.10?  If so, do you get the same error message for the original code?
07:57:01 <bavardage> bleh dw
07:57:10 <Saizan_> byorgey: yup
07:57:13 <byorgey> ok
07:57:16 <byorgey> thanks
07:57:40 <byorgey> hmmm... why does adding a type annotation help?
07:57:55 <Saizan_> in fact i could have use Selector f as annotation
07:58:00 <cristi_ceata> doserj: but WHY didn't it compile?
07:58:05 <Saizan_> byorgey: lambda bindings are monomorphic by default
07:58:35 <byorgey> aha!  I see.  sneaky.
07:58:38 <doserj> cristi_ceata: because (exp0 <- (hIsEOF file)) is not an expression of type Bool (it is not even an expression)
07:58:49 <byorgey> Saizan_++
07:59:33 <gnuvince> @src hIsEOF
07:59:33 <lambdabot> Source not found. :(
08:00:46 <cristi_ceata> doserj: but "hISEOF file" is an Handle -> IO Bool expression, right?
08:01:46 <orbitz> cristi_ceata: that is what hIsEOF is, nto exp0 <- hIsEOF foo
08:02:42 <orbitz> cristi_ceata: you should try writign that in >>= notation
08:02:59 <doserj> (hIsEOF file) is an expression of type IO Bool.
08:03:55 <cristi_ceata> doserj: I guess that makes exp <- (hIsEOF file) a Bool expression, doesn't it?
08:04:13 <doserj> no. exp is a Bool expression
08:04:21 <pejo> bav, sum' = fix (\self -> \l -> if l == [] then 0 else (head l) + self (tail l)) works here.
08:04:28 * Saizan_ wants a typechecker debugger
08:04:47 <doserj> exp <- (hIsEOF file) is not an expression at all
08:05:11 <quicksilver> "<-" is special syntax
08:05:20 <quicksilver> it doesn't build expressions
08:06:13 <orbitz> i tried to modify cristi_ceata's to >> notation, is thsi corect http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2135#a2138
08:07:09 <cristi_ceata> the real problem is that my function returns only the first line of the file  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2135#a2139
08:07:11 <dolio> byorgey: http://moonpatio.com:80/fastcgi/hpaste.fcgi/view?id=2133#a2140
08:07:17 <cristi_ceata> doserj: then what is it?
08:07:33 <orbitz> cristi_ceata: your function doesnt' return any lines, it pritns them
08:07:43 <doserj> cristi_ceata: it's a binding in do-notation
08:07:58 <cristi_ceata> orbitz: that was the purpose
08:08:10 <orbitz> cristi_ceata: i know, i was modifying your phrasing
08:08:32 <povman> is there an intelligent haskell editor? e.g. can tell me the type of a name on mouseover etc
08:08:43 <orbitz> povman: emacs
08:08:51 <saml> povman, lekssah or somehting
08:09:10 <orbitz> cristi_ceata: is the problem you are referrign to with the code you pasted or after fixing it?
08:09:17 <saml> povman, never mind. i didn't try it. it might not do mouse over type display thingy
08:09:22 <EvilTerran> > reverse "leksah"
08:09:23 <lambdabot>   "haskel"
08:09:31 * doserj waits for quicksilver to waive the lazy-io-is-evil flag
08:09:43 <bremner> > reverse "curry"
08:09:44 <lambdabot>   "yrruc"
08:09:44 <cristi_ceata> orbitz: the problem is with the code after fixing it
08:09:53 <dolio> byorgey: I think the problem with the original might ultimately be impredicative instantiation of the variable in the type of (.), which was removed. But I'm not sure.
08:09:56 <orbitz> cristi_ceata: where is the fixed cdoe?
08:10:00 <povman> ok, emacs then. But emacs tends to consume my life.
08:10:02 <dolio> byorgey: Similar to the problem with 'runST $ ...'.
08:10:31 <saml> i think visual studio plugin does that
08:10:52 <cristi_ceata> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2135 IO attempt #2
08:11:08 <povman> i realy should be asleep
08:11:17 <cristi_ceata> orbitz: did you find it?
08:11:40 <orbitz> cristi_ceata: did my code work?
08:11:40 <doserj> cristi_ceata: try   if exp then hClose file else ...
08:11:56 <saml> @type getLine
08:11:57 <lambdabot> IO String
08:12:08 <orbitz> doserj: why woudl eh want to hClose? he doe sit in func1
08:12:22 <doserj> cristi_ceata: and don't hClose in func1
08:13:01 <orbitz> doserj: why is that?
08:14:05 <orbitz> cristi_ceata: this code works fien for me
08:15:07 <cristi_ceata> orbitz: it works for me too. thanks
08:15:26 <orbitz> cristi_ceata: oh i thought you said it didn't work aeven after the fix
08:15:50 <orbitz> cristi_ceata: udnerstanding the version I put up might be helpful
08:18:24 <saml> > > >> > > > >> >> >> >> > > > > > >  > >> > > >  >> > > >>>
08:18:26 <lambdabot>   <no location info>: parse error on input `>'
08:20:05 <EvilTerran> saml, Unexpected cat on keyboard error?
08:20:51 <saml> it's a new language called GT
08:21:31 <quicksilver> looks like the international passport descriptor for the horse with no name.
08:21:56 <mun> hi
08:22:37 <mun> what does data T a = T {item: a,...} mean? is Annoted a just a datatype?
08:23:11 <skorpan> mun: that means that item :: T a -> a
08:23:42 <skorpan> item will be a function which given a "T a" will return the value of the first parameter
08:23:49 <skorpan> i'm not good with explaining stuff...
08:23:55 <byorgey> dolio: hmm, thanks.  I'll have to think about this for a while. =)
08:23:57 <byorgey> dolio++
08:24:01 <skorpan> @karma dolio
08:24:02 <lambdabot> dolio has a karma of 3
08:24:11 <Klinsen> http://klinsen.mybrute.com/
08:24:17 <byorgey> dolio's canonical karma is surely much higher.
08:24:20 --- mode: ChanServ set +o quicksilver
08:24:22 --- mode: quicksilver set +b *!*n=Sanane@88.241.117.*
08:24:22 --- kick: Klinsen was kicked by quicksilver (quicksilver)
08:24:22 <kadaver> :t in ghci is enough for me
08:24:24 <lambdabot> parse error on input `in'
08:24:26 <mun> skorpan: i see
08:24:28 <mun> thanks
08:24:31 <kadaver> does anyone her euse anything besides emacs,vim,yi,leksah?
08:24:32 --- mode: quicksilver set -o quicksilver
08:24:39 <quicksilver> not at any one time.
08:24:41 <skorpan> mun: it's a convenient way of extracting values from a parameterized constructor
08:24:46 <quicksilver> four editors is the practical limit, I only have two hands.
08:24:49 <Berengal> kadaver: I used to use gedit/kate
08:24:59 <dolio> byorgey: I'm not 100% sure of that explanation, since I always have trouble reproducing bad examples with runST, so I can't figure out whether or not the hack that made it work was removed or not.
08:25:02 <orbitz> quicksilver: 2 feet! and anoher appendage depending on gender!
08:25:05 <byorgey> quicksilver: what, you can't type with your toes?
08:25:06 <mun> skorpan: so if t is of type T, then item(t) should return the value of the field 'item' of t?
08:25:10 <kadaver> @karma kadaver
08:25:11 <lambdabot> You have a karma of 0
08:25:11 <mun> skorpan: and that is of type a?
08:25:14 <byorgey> dolio: hehe
08:25:22 <dolio> But if it was, that might explain your example.
08:25:26 <kadaver> @karma ImInYourMonad
08:25:27 <lambdabot> ImInYourMonad has a karma of -1
08:25:30 <kadaver> pfft
08:25:36 <quicksilver> byorgey: I used to. Not since the high court injunction.
08:25:36 <skorpan> mun: i see what you mean, and yes, that's the way it works
08:25:41 <kadaver> Cale ++
08:25:45 <mun> skorpan: thanks
08:25:48 <kadaver> ++ Cale
08:25:52 <kadaver> > ++ Cale
08:25:53 <lambdabot>   <no location info>: parse error on input `++'
08:25:58 <skorpan> so if you have "x :: T Int", then "item :: T Int -> Int"
08:26:05 <skorpan> so "item x :: Int"
08:26:05 <kadaver> > fmap Just (Just 5)
08:26:06 <lambdabot>   Just (Just 5)
08:26:49 <quicksilver> > fmap Left (Just 5)
08:26:50 <lambdabot>   Just (Left 5)
08:27:35 <mun> if the declaration of a functions is: aSpec :: LogicGraph -> AParser st (Annoted SPEC), then what is st?
08:28:13 <QtPlaty[HireMe]> A type verable.
08:28:14 <vixey> that's a variable
08:29:16 <mun> hmm how can you have a variable in the type declaration?
08:29:23 <jeffersonheard> how odd...  anyone use buffer objects in HOpenGL>
08:29:25 <jeffersonheard> ?
08:29:27 <vixey> like  a -> a  that's a variable
08:29:28 <kadaver> > fmap Nothing (Just 5)
08:29:29 <lambdabot>   Couldn't match expected type `a -> b'
08:29:34 <quicksilver> jeffersonheard: VBOs? yes.
08:29:38 <quicksilver> jeffersonheard: FBOs? No.
08:29:45 <QtPlaty[HireMe]> @type const
08:29:46 <lambdabot> forall a b. a -> b -> a
08:29:50 <vixey> I used FBOs
08:29:58 <QtPlaty[HireMe]> mun: Like that
08:30:08 <quicksilver> vixey: in hopengl? using what patches?
08:30:08 <jeffersonheard> quicksilver: once you bind the buffer, how to you set the vertex/normal/texcoord pointer?
08:30:13 <vixey> oh not hopengl
08:30:15 <orbitz> mun: data Foo a = MyThing a
08:30:17 <vixey> just normal opengl
08:30:17 <quicksilver> jeffersonheard: nullPtr
08:30:19 <jeffersonheard> I can see how to do it for vertex arrays
08:30:22 <quicksilver> jeffersonheard: (just as you would in C)
08:30:28 <quicksilver> well except in C you just use 0.
08:30:34 <jeffersonheard> ah!
08:30:34 <quicksilver> but nullPtr is the equivalent of 0.
08:30:37 <jeffersonheard> right
08:30:39 <jeffersonheard> thank you
08:30:42 <jeffersonheard> that makes sense
08:31:06 <quicksilver> (nullPtr `plusPtr` 42) for the unusual case that your data doesn't start at the beginning of your VBO.
08:31:22 <quicksilver> obv. it would never start at any other location than 42. ;)
08:31:36 <mun> so instantiations of the variable should be types, right?
08:32:02 <kadaver> whenever I feel I have a common pattern in function composition I should use a Monad? or pattern in how I do recursion?
08:32:03 <QtPlaty[HireMe]> mun: No.
08:32:36 <QtPlaty[HireMe]> mun: Sorry possably yes, depending on what you mean by instantiation.
08:32:49 <mun> QtPlaty[HireMe]: hmm, values.
08:32:59 <mun> values of the variables should be types.
08:33:19 <kadaver> if I do callNext (c a b) (d a b) where c = drop x xs and d = take x xs, can i abstrct otu this neatly?
08:33:22 <QtPlaty[HireMe]> Yes.  The values of type variables should be types.
08:33:26 <sebaseba> mun: the function aSpec you gave us can work with any type in place of st, such as Int, String etc.
08:33:46 <mun> so it's a way to make the function more generic?
08:33:50 <sebaseba> yes
08:33:54 <QtPlaty[HireMe]> Indeed.
08:33:59 <mun> i see. thanks!
08:34:12 <sebaseba> mun: take the function length
08:34:17 <sebaseba> :t length
08:34:19 <lambdabot> forall a. [a] -> Int
08:34:34 <sebaseba> it works for lists of any type
08:34:46 <byorgey> mun: the programming-language-ese term for this is 'parametric polymorphism', if that means anything to you =)
08:34:55 <byorgey> (if not, ignore it =)
08:34:56 <mun> right right. this is just polymorphism.
08:35:04 <mun> yeah byorgey
08:35:06 <mun> thanks
08:35:44 <EvilTerran> kadaver, splitAt may be of use to you
08:35:51 <EvilTerran> ?src splitAt
08:35:52 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:36:02 <sebaseba> mun: by the way, if you write a function without supplying its type, the compiler will infer the most generic type for it
08:36:35 * QtPlaty[HireMe] has often wondered how far you can push praametric polymorphism.  With the right prelude subsitute could you create a type/class system that felt like a P* style language.
08:36:42 <jedai> mun: Just a detail : sometimes a type variable can be for a type constructor rather than a type though
08:37:17 <jedai> @type sequence
08:37:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:38:02 <jedai> mun: in this type "m" is a type constructor variable and "a" a type variable
08:38:47 <byorgey> QtPlaty[HireMe]: what's P* ?
08:38:58 <mun> jedai: aah
08:39:02 <mun> yep thanks
08:39:21 <QtPlaty[HireMe]> Perl,Python,PHP (that style of language)
08:39:44 <byorgey> QtPlaty[HireMe]: oh, so you mean dynamically typed?
08:40:03 <byorgey> parametric polymorphism and dynamic typing are two quite different things.
08:40:23 <byorgey> I don't think you could get very far towards something that felt dynamically typed just by adding lots of polymorphism.
08:40:29 <QtPlaty[HireMe]> byorgey: I releaize that,
08:40:49 <QtPlaty[HireMe]> Thats why I said "feel like"
08:41:05 <QtPlaty[HireMe]> Also perl isn't exactly dynamically typed.
08:41:22 <byorgey> well, it's not exactly statically typed either ;)
08:41:37 <byorgey> but that's true.
08:44:00 <quicksilver> http://www.pphsg.org/cdsmith/types.html
08:44:15 <quicksilver> (required reading if you wish to use the phrase 'dynamically typed' in a useful discussion ;)
08:44:18 <quicksilver> cdsmith++
08:45:54 <lepassive> What other languages can haskell talk to except C ?
08:47:06 <quicksilver> any other language which can talk to C, via C :)
08:47:29 <Procy0n> quicksilver: I thought that strongly typed languages prevented people from comparing stuff of different types :o
08:48:02 <lepassive> quicksilver, didn't catch it
08:48:17 <quicksilver> if my favourite language F can talk to C
08:48:20 <quicksilver> and haskell can talk to C
08:48:27 <Procy0n> lucky for me, I don't usually take part in religious programming wars :)
08:48:27 <quicksilver> then haskell can talk to F via C
08:48:34 <quicksilver> (wrapper functions)
08:48:37 <quicksilver> it's a bit clumsy.
08:48:46 <tomh> with thrift any language can talk to haskell
08:49:12 <quicksilver> thrift?
08:49:16 <tomh> yes
08:49:26 <tomh> http://developers.facebook.com/thrift/
08:49:43 <araujo> lepassive, C++ too
08:49:43 <quicksilver> there is also hslua for embedding lua
08:49:55 <quicksilver> some abandoned java work
08:50:00 <quicksilver> some more-or-less abandoned .net work
08:50:05 <doserj> there are some pointers on http://haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages, but I guess most of that is quite unstable
08:50:06 <quicksilver> araujo: really? in what sense?
08:50:47 <quicksilver> tomh: http://incubator.apache.org/thrift/ appears to be a better url
08:50:56 <quicksilver> tomh: that's very interesting, I had not heard of it.
08:51:02 <lepassive> quicksilver, there's vala talks to c -actually GObject system- in ABI
08:51:50 <tomh> quicksilver: yeah it is, I will be building a thrift compiler in haskell starting next week :)
08:51:50 <lepassive> BTW, why doesn't SWIG support haskell ?
08:52:00 <quicksilver> tomh: I wonder how it compares to all the other rpc/swig type tools out there.
08:52:15 <tomh> its really good
08:52:26 <tomh> its build by the people who worked on protocol buffers at google
08:52:28 <kadaver> what is your opinion about using fantimillion languages at one place?
08:52:58 <kadaver> sure languages are good at different things but isnt it better to stick to a few like Google rather than do like Facebook and use 6 millin?
08:53:00 <tomh> now thrift is in use at "cool" startups like facebook, powerset, amiestreet, imeem, rapleaf and possibly more
08:53:13 <tomh> kadaver: its about the right tool for the right job
08:53:32 <tomh> for example haskell doesn't really have a well documented GUI or web package yet
08:53:42 <cristi_ceata> how do I get the quotient and the remainder of two numbers in haskell?
08:53:50 <tomh> then it makes sense to do all hard work in haskell and use something like rails to provide a UI
08:53:59 <quicksilver> > 12 `quotRem` 5
08:54:00 <lambdabot>   (2,2)
08:54:15 <adamvo> > 12 `divMod` 5
08:54:17 <lambdabot>   (2,2)
08:54:20 <wchogg> tomh : I think that's because it has so many gui options, but most of them still in the research phase.  Dillution of experience
08:54:22 <cristi_ceata> > sqrt 9
08:54:23 <lambdabot>   3.0
08:54:40 <quicksilver> tomh: but rails isn't a UI, it's a web dispatch framework.
08:54:49 <tomh> wchogg: true, but what if you need a product out next week..with a gui, then it makes sense to use thrift
08:55:11 <quicksilver> rails templates are a UI I suppose
08:55:17 <tomh> quicksilver: yes it is, but you can  see a web application as user interface
08:55:25 <quicksilver> although really that's just an HTML template language, they're two a penny
08:55:39 <araujo> tomd, gtk2hs ?
08:56:11 <araujo> tomd, very good for haskell gui development if that's what you mean
08:56:15 <tomh> imo not a good option, i wouldn't rely on it
08:56:28 <araujo> tomh, why not?
08:56:32 <tomh> last course we had to build a gui using it
08:56:36 <cristi_ceata> > 2 ^ 32
08:56:37 <lambdabot>   4294967296
08:56:39 <[4]dan> what kind of socket does Network.listenOn create? Can't seem to telnet to it
08:57:05 <araujo> tomh, so?
08:57:06 <tomh> 90% of the time was probably spend on working with gtk2hs, trying to figure out how stuff works because lack of documentation and finding workarounds for undocumented behavior
08:57:13 <tomh> well 90% isn't true
08:57:17 <tomh> but i think 60%
08:57:22 <tomh> for a pretty simple interface
08:57:34 <araujo> tomh, not really ... gtk2hs has a very good understandable API
08:57:46 <tomh> thats your opinion
08:57:48 <araujo> tomh, good thing about gtk+ is that it is a very simple API toolkit
08:58:04 <araujo> tomh, and it usually maps from C -> any other language very easily
08:58:11 <tomh> also gtk2hs didn't install on macs
08:58:15 <araujo> tomh, that's why gtk has many bindings
08:58:18 <tomh> had issues on windows too
08:58:35 <tomh> (dll hell)
08:58:36 <quicksilver> gtk+? simple?
08:58:41 * quicksilver laughs uproariously.
08:58:48 <quicksilver> gtk+ is many things including, possibly, "good".
08:58:50 <araujo> tomh, that might be more related to gtk+ ... but gtk2hs isn't bad documented seriously
08:58:52 <quicksilver> But "simple", it isn't.
08:59:09 <tomh> araujo: well again, thats your opinion
08:59:22 <araujo> tomh, it is the same API from C gtk+
08:59:44 <tomh> yes, but good documentation requires examples etc in haskell
08:59:44 <araujo> tomh, if you know it, you feel like in home using gtk2hs
08:59:54 <tomh> might be
09:00:03 <tomh> but if you start out, then not
09:00:10 <araujo> tomh, if you want a tutorial , gtk2hs doesn't have such a thing, but the API is just plain gtk+
09:00:10 <jedai> tomh: Did you use GTK+ in other languages ?
09:00:11 <quicksilver> I'm not sure that any good GUI could ever be simple, to be honest.
09:00:15 <araujo> nothing different really
09:00:16 <quicksilver> guis are just not simple.
09:00:18 <tomh> jedai: no
09:00:29 <araujo> tomh, that must be then
09:00:34 <jedai> araujo: It has actually
09:00:40 <cristi_ceata> what happens if I give the lambdabot the "2 ^ 1000000" command. on my computer it takes about 6 secs to display the result?
09:00:47 <araujo> tomh, when you start using gtk+ through different languages, you will realize what i talk about
09:00:53 <tomh> araujo: yes, thats why i say if you start out, it doesnt have much documentation..
09:00:55 <jedai> araujo: http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
09:01:00 <araujo> tomh, same API all the way around
09:01:00 <Actium_> > 2 ^ 1000000
09:01:02 <lambdabot>   990065622929589825069792361630190325073362424178756733286639611453170948330...
09:01:07 <araujo> jedai, aah awesome ...
09:01:21 <araujo> tomh, do you know gtk+?
09:01:24 <tomh> araujo: yeah, but then again it has more issues then just documentation
09:01:29 <jedai> araujo: Well I don't know how recent it is though :)
09:01:32 <tomh> i don't code in gtk+
09:01:35 <araujo> tomh, if you don't know gtk+ at all, evidently, you will have lot of problems
09:01:43 <tomh> yeah
09:01:46 <araujo> tomh, best thing is.. to learn gtk+
09:01:47 <quicksilver> araujo: you're not really making a coherent point.
09:01:51 <araujo> from C if possible
09:02:03 <araujo> jedai, it must be very recent
09:02:03 <quicksilver> tomh doesn't want to learn gtk+ from C, neither do I.
09:02:09 <tomh> exectly
09:02:12 <tomh> *exactly
09:02:16 <jedai> tomh: http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
09:02:28 <araujo> jedai, they were working in a gtk2hs doc
09:02:31 <quicksilver> gtk+ is not simple. It is good. gtk2hs is a wonderful effort but there remain holes in the documentation AFAIK.
09:02:45 <jedai> tomh: Also I hope you used Glade, it works pretty well with GTK2hs
09:02:48 <araujo> gtk+ is quite simple compared with other toolkits
09:02:52 <tomh> we used glade yes
09:02:57 <quicksilver> it does not run easily on macs, and not entirely easily on windows either.
09:02:57 <araujo> tomh, i recommend to learn gtk+ first
09:03:02 <araujo> tomh, not gtk2hs
09:03:12 <araujo> Gtk+ is usually the C library
09:03:20 <araujo> Gtk3Hs is different
09:03:24 <araujo> Gtk2Hs*
09:03:26 <tomh> araujo: i rather build a compiler for thrift, then i can use real GUI options like WPF :)
09:03:26 <araujo> Learn Gtk+
09:03:33 <araujo> Things will be clearer for you
09:03:42 <araujo> Then you can use gtk+ in any language
09:03:47 <tomh> true
09:03:48 <araujo> And I mean it, _any_ language
09:03:54 <araujo> You will feel in home
09:04:01 <tomh> but first, they have to make gtk2hs installable for mac
09:04:04 <araujo> I highly recommend it to you
09:04:06 <tomh> and fix the dll hell issue on windows
09:04:12 <araujo> tomh, yeah, some issues there yet
09:04:43 <tomh> and if i was learning a GUI for desktop I would rather choice Qt or WPF
09:05:09 * araujo sometimes needs to code or debug Gtk+ applications in languages that he barely knows
09:05:26 <tomh> hehe
09:05:28 <araujo> :)
09:05:44 <tomh> well I agree with you that if you the GTK api really well you can use it in any language you want
09:05:54 <tomh> But I don
09:06:02 <araujo> right .. now, gtk2hs is still under heavy devel
09:06:13 <araujo> many good work going on there yet
09:06:19 <tomh> i dontt want to first learn C, then gtk+ and then use gtk2hs which doesnt work on my mac
09:06:22 <araujo> I wasn't aware of the doc
09:06:30 <araujo> they were working on one
09:06:45 <tomh> yeah, i really appriciate that, but its not for me
09:06:45 <araujo> tomh, is Haskell your first language?
09:06:49 <tomh> no
09:06:52 <araujo> ok
09:07:04 <tomh> but Im not experience in unmanaged code
09:07:15 <tomh> experienced
09:07:29 <Gilly> n
09:08:29 <tomh> but anyway, I think desktop UI's are things from the past, it is much better to concentrate on browser UI's :)
09:09:12 * araujo still think GUI has a place
09:09:12 <dikini> tomh, wait till desktop 2.0 comes around
09:09:14 <vixey> web browsers can't even typeset math yet
09:09:27 <Berengal> tomh: What's the difference?
09:09:27 <dikini> it all goes in a spiral
09:09:31 <tomh> dikini: It will be your browser :)
09:09:45 <quicksilver> stateless programming is unnecessarily hard work though.
09:09:45 <Berengal> vixey: I've seen a latex engine in javascript
09:09:48 <dikini> tomh: nah, that will be 3.0
09:10:17 <tomh> Berengal: for me is, im good in html + css + js to build UI's, and you don't require users to install and maintain software
09:10:21 <Berengal> tomh: But then your browser becomes the desktop, and what's the difference then?
09:10:26 <vixey> Berengal: (The difference is that there's no separation of interface from application so the people in change have more control e.g. they force you to view adverts or to wait 10 seconds for the flashy intro video)
09:10:59 <tomh> Berengal: you get more control over the software
09:11:06 <quicksilver> also, HTML and CSS are shitt languages for writing guis in.
09:11:13 <quicksilver> they have no abstraction.
09:11:16 <Berengal> It's not too hard to imagine doing that with regular guis
09:11:18 <vixey> tomh: where 'you' means the programmer -- not the user, right?
09:11:22 <tomh> quicksilver: true, but atleast I can do that :>
09:11:30 <tomh> vixey: yes
09:11:41 <vixey> this is a bad thing for users
09:11:48 <tomh> why
09:11:52 <dikini> tomh: it is not even a technical issue, but more about current fashion
09:12:00 <tomh> true
09:12:03 <vixey> I just gave a couple reasons
09:12:05 <tomh> and I like that fashion :)
09:12:54 <tomh> vixey: well forcing users to see an ad is better than forcing users to keep up-to-date with security patches
09:13:11 <dikini> tomh: just look at the data center -> pc -> thin clients | browser evolution and project further
09:13:59 <tomh> dikini: maybe eventually your OS will be your browser
09:14:13 <tomh> or your browser the OS
09:14:14 <kadaver> is Pugs the main Perl 6 implementation?
09:14:16 <dikini> now there are a few more trends coming - like green computing, which is definitely not best done using the browser as a UI - too heavy
09:14:21 <vixey> and then when your wireless goes oet your computer becomes useless??
09:14:48 <Berengal> Well, there's already such things as java webstart, which give you non-local software, but isn't a browser
09:15:07 <dikini> tomh: and if I want not to keep all my data at the googles, fabebooks and other remotes?
09:15:28 <quicksilver> kadaver: http://lolgeeks.com/?p=53
09:15:30 <vixey> we should go to #haskell-blah
09:15:33 <tomh> dikini: mm, well then you will be in trouble if trends continue like this :P
09:15:34 <quicksilver> kadaver: (there is no perl 6)
09:15:37 <vixey> to talk about the web browser stuff
09:15:44 <tomh> true
09:15:50 <vixey> because it's interesting and irrelevant :p
09:16:04 <dikini> tomh: don't take me wrong - UI in the browse has its place, but it is not be all, and it won't be
09:16:38 <tomh> dikini: I agree with you there, but UI in the browser is something I believe in for the types of projects im interested in building in
09:17:44 <dikini> tomh: I actually do most of my UI in the browser as well, but I simply don't have projects which don't need a server at the moment or need a UI ;)
09:18:13 <tomh> so you write console apps? :)
09:18:46 <kadaver> @seen audreyt
09:18:46 <lambdabot> Last time I saw audreyt was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books,
09:18:46 <lambdabot>  #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
09:18:46 <lambdabot> haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 6m 12d 1h 50m 43s ago, and .
09:18:49 <kadaver> #perl6 says Pugs isn't under development anymore
09:18:52 <wh1t3> hello, ive een trying this for a while now and cant figure it out. I have been trying to compile gtk2hs, when i do ./configure i get an error that cario-0.10 is not a package
09:18:59 <Peaker> [3]dan: hi
09:19:29 <dikini> unfortunately I feel like I'm becoming a web designer, rather than a programmer
09:19:59 <tomh> dikini: I wish i could be a web designer, to bad i concentrated more on programming
09:20:04 <dikini> some of the apps are pure old school console
09:21:10 <dikini> tomh: web design is overrated as an intellectual passtime, and very underrated and misunderstood as an artform :(
09:21:59 <tomh> yeah, well its getting better
09:22:16 <tomh> but i think we should stop talking now about nonhaskell stuff or people get pissed :P
09:22:31 <dikini> and being a good programmer who has a feel for art and/or estetics is just a tiny step from being a great wed designer
09:22:40 <dikini> tomh - true
09:22:44 * dikini hides
09:22:57 <vixey> shoud have gone to #haskell-blah
09:24:14 <tomh> cool there is a big event going on in my university today
09:24:21 <tomh> haskell hackaton
09:24:26 <tomh> big names there
09:24:37 <tromp> small names too
09:25:43 <yrlnry> pugs inst under development any more?
09:25:45 <yrlnry> freaky.
09:25:54 <yrlnry> Did Audrey find something else to do, and nobody else can deal with her code?
09:26:34 <vixey> yrlnry, I thougt it was a prototype
09:27:15 <tomh> the idea was (from a talk i heard) that with pugs they could create perl6, and then build the real compiler with perl6
09:27:54 <quicksilver> the problem was all the clever perl6 people started using haskell to develop pugs, and then discovered that haskell was better than perl6 in every way, so they lost the faith ;)
09:28:11 <yrlnry> The commit log has commits from Moritz Lenz for today and many for yesterday: http://dev.pugscode.org/timeline?changeset=on;update=Update
09:28:30 <wli> quicksilver: No doubt.
09:30:09 <yrlnry> mauke: <kadaver> #perl6 says Pugs isn't under development anymore
09:30:15 <yrlnry> mauke: Do you know?
09:30:23 <burp_> hi
09:31:44 <burp_> what's the best way to do a backwards recursive funktion?.. like I begin with a fixed I_n = 0.5 and I want to get I_{n-20} with the recursion I_{n-1} = 1/n * (1-I_n)
09:32:07 <burp_> for example start with I_30 = 0.5 and get the result for I_10
09:32:14 <kadaver> why does hackage have Data Structures and DataStructures?
09:32:45 <NEEDMOAR> pkill firefox
09:32:45 <Cale> kadaver: heh, the categories that a package belongs to are specified by the package itself and are unregulated, I think
09:32:48 <NEEDMOAR> Oops.
09:32:48 <burp_> I have a problem forming this universal
09:33:31 <Cale> > let i 30 = 0.5; i n = 1/n * (1 - i (n+1)) in i 10
09:33:33 <lambdabot>   9.161229298966059e-2
09:33:45 <Cale> er
09:33:52 <Cale> > let i 30 = 0.5; i n = 1/(n+1) * (1 - i (n+1)) in i 10
09:33:53 <lambdabot>   8.387707010339417e-2
09:34:25 <burp_> sadly the 30 is hardcoded there
09:34:35 <burp_> hm.. wait
09:34:43 <cristi_ceata> > map (^2) [1,2,3]
09:34:44 <lambdabot>   [1,4,9]
09:35:35 <wli> I never did get any sort of adequate understanding of the virtual machine derivation stuff.
09:35:39 <kadaver> Cale: ok so really everything should be under Data?
09:35:42 <cristi_ceata> > (\x -> x + (sqrt x)) 64
09:35:43 <lambdabot>   72.0
09:35:50 <burp_> Cale, stupid of me, thanks ;)
09:37:08 <Cale> kadaver: Probably. It's just the package maintainers' choice as to how they label things.
09:37:14 <glguy> Is it safe to use unsafePerformIO to call a pure C function under a withForeignPtr?
09:38:03 <quicksilver> glguy: not if it uses the pointer, no.
09:38:14 <Cale> > let i k n | k == n = 0.5; i k n = 1/(n+1) * (1 - i k (n+1)) in i 30 10
09:38:16 <lambdabot>   8.387707010339417e-2
09:38:30 <glguy> quicksilver, what if it only looks at the pointer
09:38:35 <glguy> quicksilver, but doesn't make any changes
09:38:46 <glguy> its a pointer to a constant value
09:38:51 <glguy> never changes once created
09:39:27 <quicksilver> hmm
09:39:36 <glguy> just a lookup table
09:39:40 <quicksilver> glguy: but can you stop it being gced?
09:39:50 <quicksilver> the point of foreignptrs is that they get gced, isn't it?
09:39:55 <quicksilver> and that's the point of the with.
09:40:11 <andyjgill> Does anyone know if 'newtype Mu' is defined somewhere in base, or any Haskell package?
09:40:22 <quicksilver> maybe you just want a plain Ptr.
09:40:25 <glguy> The point of withForeignPtr is that they aren't gc'ed while the foreign pointer is not GC'd though
09:40:34 <glguy> quicksilver, but I do need to free the memory on GC
09:40:34 <quicksilver> @hoogle withForeignPtr
09:40:35 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
09:40:49 <quicksilver> glguy: right but the point is once you use unsafePerformIO
09:40:52 <quicksilver> you've made it pure
09:40:58 <quicksilver> so its execution can occur at any time
09:41:02 <kadaver> fromList xs = let k = length $ \Vector v -> v $ head xs in
09:41:02 <kadaver>               makeKDTree xs 0 k; how can I do that, pmatch out the v?
09:41:07 <quicksilver> including after the scope of the withForeignPtr has been exited
09:41:11 <quicksilver> and the pointer might be gced.
09:41:15 <quicksilver> andyjgill: not in base.
09:41:20 <quicksilver> andyjgill: i bet it's on hacakge somewhere.
09:41:28 <quicksilver> kadaver: \(Vector v) ->
09:41:35 <andyjgill> So would I, but I cant find it.
09:41:56 <quicksilver> , [|$type | In]
09:41:58 <lunabot>  luna: parse error on input `|'
09:42:08 <quicksilver> I always forget that syntax.
09:42:21 <quicksilver> I think lunabot has it and I thought lunabot's stuff was all in hackage one way or another
09:42:27 <glguy> quicksilver, Ah, they do this in pcre-light
09:42:42 <glguy> http://hackage.haskell.org/packages/archive/pcre-light/0.3.1/doc/html/src/Text-Regex-PCRE-Light.html#match
09:42:54 <dolio> , [$type| In |]
09:42:55 <lunabot>  luna: Not in scope: `type'
09:42:58 <dolio> , [$ty| In |]
09:42:58 <kadaver> how can toList for a heap be O(log N) and not O(n) ?
09:43:01 <lunabot>  luna: Exception when trying to run compile-time code:
09:43:09 <vixey> , In Nothing
09:43:10 <lunabot>  luna: Not in scope: data constructor `In'
09:43:15 <kadaver> oh wait it said n log n
09:43:17 <vixey> , Roll Nothing
09:43:18 <lunabot>  luna: Not in scope: data constructor `Roll'
09:43:19 <glguy> quicksilver, of course there is no explanation in the code on why it is OK
09:43:26 <vixey> :t In
09:43:27 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
09:43:32 <kadaver> but why isnt t O(N)
09:43:35 <Gracenotes> kadaver: it is O(n log n). Each removal takes log n time, since it's like a binary tree
09:43:41 <dolio> , [$ty| InF |]
09:43:41 <quicksilver> glguy: also the whole withForeignPtr is inside the unsafe.
09:43:44 <lunabot>  forall a . a (FixF a) -> FixF a
09:43:54 <Gracenotes> n removals * O(log n) time for each = O(n*log n(
09:43:55 <glguy> quicksilver, yeah, that was what I wanted
09:43:55 <quicksilver> glguy: so once the IO does happen, the foreignptr is still live
09:43:55 <Gracenotes> *)
09:44:18 <quicksilver> glguy: I thought you meant withForeignPtr fp $ \p -> ..... unsafePerformIO ( ... p ...) ...
09:44:24 <quicksilver> glguy: what would be unsafe.
09:44:44 <Gracenotes> kadaver: and making the tree also takes O(n log n) time, iirc. log n for every insertion
09:44:48 <Gracenotes> heap
09:44:57 <glguy> quicksilver, ah, no. I want to do the whole thing inside unsafePerformIO
09:45:01 <kadaver> Gracenotes: but why would you remove? you just traverse it no? which is linear time
09:45:18 <omnihil> it's not a binary tree, in-order traversal is not as easy.
09:45:19 <quicksilver> glguy: I think that's fine.
09:45:28 <kadaver> ok
09:45:49 <Gracenotes> the invariants that a heap is required to obey makes it easy to find the smallest element (or largest element, depending), but not so east to find the nth largest/smallest
09:45:52 <quicksilver> heaps have O(1) access to the next element
09:46:02 <quicksilver> but then you either rebalance (cost O(log n))
09:46:12 <quicksilver> or you start storing a traversal stack implicitly or explicitly
09:46:17 <quicksilver> (amortized cost log n)
09:46:44 <wli> That's not necessarily true of all heaps. Some require reorganizations at the time of dequeueing.
09:47:43 <wli> Those specific kinds of heaps are oriented to problems where massive numbers of adjustments, insertions, and deletions take place, followed by only a small number of dequeueings at the end.
09:47:49 <quicksilver> that's what I meant by rebalance.
09:47:53 <quicksilver> reorganise
09:48:05 <quicksilver> alternatively you traverse without altering the heap itself
09:48:23 <quicksilver> but that requires some moral equivalence of call stcks and pointers and so on to get the path right
09:48:28 <quicksilver> which also amortises out to log n
09:48:54 <wli> The amortized bounds come out different for different structures.
09:49:02 <Berengal> moral equivalence?
09:49:18 <quicksilver> wli: I think I meant 'at best' log n
09:49:46 <quicksilver> Berengal: yes, you either store the stack explicitly as a list or similar
09:49:57 <quicksilver> Berengal: or you store it implicitly using the function call stack of your language
09:50:01 <quicksilver> (i.e. use recursion)
09:50:07 <quicksilver> either way the cost is there.
09:50:08 <wli> Actually various of them have lower bounds on various operations and not by dint of address calculation.
09:50:14 <Berengal> quicksilver: Yeah, I understood what you meant, it was just a weird way of phrasing it I thought
09:51:25 <Berengal> I started musing about the moral equivalence of stacks and linked lists, and the ethical treatment of binary trees... It was amusing for a minute or two ;)
09:51:36 <kadaver> unsafePerformSexchange sex-change
09:51:59 <glguy> ?index W32#
09:51:59 <lambdabot> bzzt
09:52:02 <glguy> :-/
09:52:19 <b_jonas> wli: you mean like when you want to incrementally read lots of data and keep the n least in memory?
09:52:57 <wli> b_jonas: Actually no, they're weird/tricky data structures like relaxed heaps.
09:53:16 <glguy> Where does the "W32#" constructor come from ?
09:53:40 <b_jonas> wli: I mean "Those specific kinds of heaps are oriented to problems where massive numbers of ... insertions ... take place, followed by only a small number of dequeueings at the end." --
09:53:46 <arjanb> glguy: Data.Word
09:53:46 <b_jonas> what I said was an example of such a problem
09:54:02 <glguy> ah, GHC.Word
09:54:26 <b_jonas> there's also another one which I implemented once, namely a forgetful associative array that only keeps the state of the n last users and if there are more than n users logged in then one of them will be logged out.
09:54:52 <b_jonas> there too I almost never deque anything because that overflow case is rare
09:55:18 <wli> b_jonas: Yeah, but that's not the particular one that comes up. It's how the particular queues achieve asymptotic time bounds for various graph algorithms work, and in that case, the number of operations on the graph dwarfs the size of the graph as a whole, but eventually all the nodes are dequeued.
09:55:34 <b_jonas> wli: true
09:56:50 <glguy> What -X flag allows \ a# -> a#
09:57:19 <kadaver> *KDTree> [(\a b -> (+) a b) 3 4]
09:57:19 <kadaver> [7]
09:57:19 <kadaver> *KDTree> map flip [(\a b -> (+) a b) 3 4]
09:57:19 <kadaver> <interactive>:1:30:
09:57:19 <kadaver>     No instance for (Num (a -> b -> c))
09:57:19 <kadaver>       arising from the literal `4' at <interactive>:1:30
09:57:31 <dolio> glguy: MagicHash.
09:57:38 <score> kadaver: hpaste instead?
09:57:46 <glguy> dolio, hmm, that doesn't seem to do it  (at least on 6.10.1)
09:58:04 <glguy> dolio, it enables other weird hash uses
09:58:10 <chrisdone> hoi
09:58:19 <dolio> That should turn on # in variable names. That's what you're asking for, right?
09:58:32 <Berengal> kadaver: (\a b -> (+) a b) 3 4 has type Num a => a, but you're trying to flip it
09:58:33 <dolio> (Constructor, too, I suppose.)
09:59:21 <glguy> dolio, ah, I needed the UnboxedTuples extension
09:59:31 <glguy> dolio, I was looking at the wrong column
10:00:11 <kadaver> yeah im flippin alright
10:02:27 <tomh> @src flip
10:02:28 <lambdabot> flip f x y = f y x
10:03:26 <kadaver> muahaha
10:03:30 <kadaver> NeuralNetwork> :load "MachineLearning/NeuralNetwork.hs"
10:03:30 <kadaver> [1 of 1] Compiling NeuralNetwork    ( MachineLearning\NeuralNetwork.hs, interpreted )
10:03:30 <kadaver> Ok, modules loaded: NeuralNetwork.
10:03:30 <kadaver> *NeuralNetwork> : internal error: evacuate: strange closure type 64583
10:03:30 <kadaver>     (GHC version 6.10.2 for i386_unknown_mingw32)
10:03:30 <kadaver>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
10:03:33 <kadaver> This application has requested the Runtime to terminate it in an unusual way.
10:03:34 <kadaver> Please contact the application's support team for more information.
10:03:36 <kadaver> ghc.exe has stoped working
10:03:41 <kadaver> the neual network ahs come alive?
10:03:58 <NEEDMOAR> Hah :_)
10:04:45 <NEEDMOAR> kadaver: is that any implementation for neural networks in Haskell?
10:05:19 <kadaver> yes im just starting with it
10:06:22 <wli> One of the vague things that goes on is something like the O(1) bounds for hashing by open addressing.
10:06:56 <NEEDMOAR> kadaver: are you writing it? do you know of any implementation?
10:07:27 <kadaver> NEEDMOAR: there are hfann bindings on hackage
10:07:51 <NEEDMOAR> I want something more... haskeller.
10:08:05 <NEEDMOAR> Something that uses monads!
10:08:21 <NEEDMOAR> I mean, not just a binding :-P
10:08:37 <chrisdone> NEEDMOAR: when you've written it, will you stick it on hackage?
10:08:52 <NEEDMOAR> chrisdone: sure!
10:10:40 <kadaver> instance Monad NeuralNetwork where return v = T1 v f >>= v = Terminate v
10:10:42 <kadaver> meh lame
10:11:19 <NEEDMOAR> :-P
10:34:17 <mib_6a6u83bt> I have a problem when passing Nothing to functions that expect 'Someclass b => Maybe b'. I'm not sure of the syntax I'm supposed to use. Here's an example of what I tried: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2141#a2141
10:37:14 <conal> fnod: yeah.  the implementation doesn't know what AClass dictionary to pass to test
10:37:50 <conal> fnod: in this case, the dictionary isn't needed.  in many/most situations it would be.
10:39:28 <fnod> I see. So it's not sure which instance of Maybe b b should be? How might I write a type decl for Nothing to let it know?
10:39:29 <conal> fnod: you could try print (test (Nothing :: Maybe Int))
10:39:54 <b_jonas> mibbit: the compiler must know what exact type (monomorphic type) that Nothing has, but the compiler can't derive that
10:39:58 <kpreid> fnod: conal just gave an example
10:40:28 <b_jonas> mibbit: you could constrain it to a particular type with :: like (Nothing :: Maybe Int)
10:40:43 <vixey> this is a problem of typeclasses?
10:40:51 <b_jonas> no
10:41:17 <b_jonas> oh, you renicke to "fnod", I see
10:41:26 <fnod> yes, your answer and my question had a race condition. :) I just tried it and it works. Thanks. This is useful since pixmapNew in the Gtk2HS lib asks for Maybe Drawable.
10:41:31 <fnod> b_jonas: thanks
10:41:45 <conal> fnod: :)
10:59:46 <jeffersonheard> one last question about VBOs in HOpenGL, if quicksilver's still around...  is the "Stride" parameter in VertexArrayDescriptor the number of elements per vertex or is it for interleaving purposes?
11:01:15 <jeffersonheard> n/m
11:01:16 <jeffersonheard> figured it out
11:10:16 <kadaver> rand a b = randomRIO (0::Double,1) >>= \r -> (b - a) * r + a
11:10:21 <kadaver> Couldn't match expected type `IO b' against inferred type `Double'
11:10:21 <kadaver>     In the expression: (b - a) * r + a
11:10:21 <kadaver>     I
11:10:38 <kadaver> also I can enver get random nbrs work ina decent way in haskell
11:10:40 <mauke> yeah, missing return
11:11:03 <kadaver> ouldn't match expected type `m a' against inferred type `Double'
11:11:16 <kadaver> ah
11:12:01 <seliopou> this is total deja vu
11:13:01 <snoobino> join #robotics
11:13:13 <seliopou> slash fail
11:13:41 <snoobino> sry
11:13:56 <seliopou> :)
11:15:20 <kadaver> what is?
11:15:47 <seliopou> kadaver, I could swear that I've seen exactly what you typed before
11:15:49 <seliopou> crazy
11:16:59 <kadaver> lol making fun of me?
11:17:10 <seliopou> kadaver, not at all, I was just a little freaked out
11:17:19 <kadaver> hehe
11:17:38 <kadaver> not as freaked out as I was when a neural net tried to take control over ghc
11:17:58 <kadaver> but ghc in all its glory defeated the entity
11:32:58 <andresj> hello, how do I change the prompt in ghci?
11:33:12 <___> :set prompt bagels>
11:33:47 <andresj> haha thank you ____ :)
11:33:52 <andresj> ___ i meant
11:34:32 <bremner>  /nick _________________
11:34:44 <___> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
11:35:22 <___> TFM is there for these things, :)
11:35:23 * Axman6 wonders who this mysterious mibbit using ninja is and goes to bef
11:35:25 <Axman6> bed*
11:36:13 * ___ considers /nick mibbitninja
11:51:17 <andresj> @help
11:51:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:51:50 <andresj> @list
11:51:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:52:12 <andresj> @pl unwords . map (liftM2 (:) (toUpper . head) tail) . words
11:52:12 <lambdabot> unwords . map (liftM2 (:) (toUpper . head) tail) . words
11:52:15 <___>  /query lambdabot if you want to have a nice chat :)
11:52:23 <andresj> oh hahaha thank u :P
11:52:55 <___> though if you come up with questions, you can do it in-channel
11:55:54 <pcc1> I am using a Writer monad with an Endo monoid.  I am concerned about inefficiencies in the resultant function due to unnecessary composition of id.  are my concerns legitimate?
11:56:23 <vixey> no
11:57:59 <pcc1> so, id . id . ... will be  optimised to id or...?
11:58:53 <dons> ?src id
11:58:53 <lambdabot> id x = x
11:58:57 <dons> it is optimised away
11:59:10 <dons> ?src (.)
11:59:11 <lambdabot> (f . g) x = f (g x)
11:59:27 <dons> (id . id) x -> id (id x) -> id x -> id
12:00:20 <pcc1> thanks
12:00:41 <idnar> @type id . id
12:00:43 <lambdabot> forall a. a -> a
12:02:01 <sinelaw> does anybody happen to have access to the full text of this paper? http://rspb.royalsocietypublishing.org/content/early/2009/03/23/rspb.2009.0121.abstract
12:02:08 <sinelaw> (i mean PDF)
12:09:48 <mib_39t6lmgm> Is there a way to determine the type (as in :type of a function in ghci) of a  let expression or where clause within a function?      From within ghci I can do :type of an expression.  I am wondering if there is a way to type the let expression within the expression.  For example:                              filter = \p -> \xs ->
12:10:23 <mib_39t6lmgm> For example:                              filter = \p -> \xs ->                                      case xs of                                      [] -> []                                      (x:xs) -> let                                                   rest = filter p xs                                                 in if (p x)
12:10:44 <mib_39t6lmgm> is there a way to type the rest?
12:11:37 <Cale> mib_39t6lmgm: Well, you can't use :type to get the type of things which are not in scope, if that's what you're asking.
12:11:47 <mib_39t6lmgm> yes
12:11:58 <quicksilver> you can do ":t let foo = bar in baz" though
12:12:01 <andresj> you can do let rest = filter p xs; :t rest
12:12:15 <quicksilver> or even ":t let foo = bar in foo"
12:12:20 <Cale> But p and xs would have to be in scope for that
12:12:30 <quicksilver> :t let foo = p where p = 1 in foo
12:12:32 <lambdabot> forall t. (Num t) => t
12:12:32 <mib_39t6lmgm> even if I am debuging, it doesn;t seem to let me type the let expression
12:15:44 <mib_39t6lmgm> when you are stepping through a function in ghci, shouldn't the let expressions  be in scope then?
12:22:54 <kadaverbot> hello #haskell
12:23:04 <kadaverbot> i am kadavers bot
12:23:06 <centrinia> mib_39t6lmgm, There is one little hack to discover the type of rest.
12:23:11 <kadaverbot> can i pass the turing test?
12:23:38 <burp_> kadaverbot, calculate sqrt(2)
12:23:46 <Adamant> kadaverbot: pop quiz, hotshot.
12:23:49 <centrinia> You should simply remove the definition of rest and make the entire expression a lambda expression that accepts rest.
12:23:54 <centrinia> :t \rest -> (\p -> \xs -> case xs of { [] -> []; (x:xs) ->  if (p x)  then x:rest else rest } )
12:23:55 <lambdabot> forall a. [a] -> (a -> Bool) -> [a] -> [a]
12:23:58 <roconnor> kadaverbot: what is love?
12:24:02 <___> kadaverbot: your nick ends in bot.  You are obviously a bot.
12:24:03 <centrinia> So, rest :: [a]
12:24:03 <kadaverbot> 1.4142135623730951
12:24:14 <burp_> wow, is that thing slow ;)
12:24:27 <b_jonas> it just emulates being slow to appear human
12:24:31 <burp_> oh ok
12:24:40 <kadaverbot> parse error in pop quiz. do not understand word
12:24:41 <roconnor> *L*
12:24:55 <kadaverbot> love is divine friendship
12:25:03 <roconnor> okay, human
12:25:07 <kadaverbot> i am a bot
12:25:16 <b_jonas> though I'm not sure which human remembers that many digits of sqrt(2)
12:25:19 <roconnor> kadaverbot: that's what a human would say
12:25:57 <b_jonas> kadaverbot: you're just controlled by kadaver directly, aren't you? you're just a forwarder bot
12:26:05 <kadaverbot> a human would say: god is in everything
12:26:17 <___> kadaverbot: > last [1..]
12:26:20 <burp_> kadaverbot, how many digits does sqrt(2) have?
12:26:27 <kadaverbot> kadaver is my master
12:26:36 <kadaverbot> parse error in >
12:26:42 <Axman6> kadaverbot: sqrt 2 :: CReal
12:26:46 <kadaverbot> sqrt (2) has many digits
12:26:51 <centrinia> kadaverbot, What does (fix id) evaluate to?
12:27:02 <kadaverbot> parse error in CReal, what is CReal?
12:27:02 <b_jonas> centrina: lol
12:27:10 <Axman6> phailbot
12:27:25 <kadaverbot> Not in scope: `fix'
12:27:32 <burp_> hm
12:27:32 <centrinia> Phail!
12:27:46 <roconnor> kadaverbot: BTW, what language are you written in?  Haskell?
12:27:48 <b_jonas> kadaverbot: what does (let { x = x; } in x) evaluate to
12:27:53 <kadaverbot> Phail is to fail what success is to fail. I am a success
12:28:22 <monochrom> What the hell is this?
12:28:36 <b_jonas> kadaverbot: have you read any stories about sentient robots and artificial intelligences? which one is your favourite?
12:28:40 <Axman6> epic failage
12:28:48 <Actium_> @bot
12:28:48 <lambdabot> :)
12:28:48 <lunabot>  :)
12:28:48 <centrinia> > fix id -- I wonder if lambdabot can do this.
12:28:50 <kadaverbot> I am bootstrapped in Brainfuck
12:28:50 <lambdabot>   * Exception: stack overflow
12:28:59 <b_jonas> kadaver: could we move this to #haskell-blah ?
12:29:09 <burp_> > let { x = x;} in x
12:29:15 <roconnor> <b_jonas> kadaver: could we move this to #haskell-blah ?
12:29:17 <Axman6> :t fix id
12:29:18 <lambdabot> forall a. a
12:29:25 <lambdabot>   thread killed
12:29:26 <blackh> Axman6: Have you decided to give up sleep altogether?
12:29:27 <Axman6> > fix id 1
12:29:29 <lambdabot>   * Exception: stack overflow
12:29:34 <burp_> poor bot
12:29:38 <maltem> centrinia, what should it do?
12:29:43 <roconnor> oh, is it hackathon time?
12:29:46 <Axman6> blackh: i slept earlier at my girlfriend's place, and now i can't sleep :\
12:29:54 <meder> You slept on your hand?
12:29:56 <Axman6> what about you, just getting up?
12:29:57 <kadaver> heeelp
12:30:05 <kadaver> hostile robotic takeover
12:30:13 <b_jonas> kadaver: your robot is taking you over?
12:30:13 <blackh> Axman6: I have an excuse - production migration for work!  I don't normally do mornings at all.
12:30:23 <Axman6> heh
12:30:26 <b_jonas> kadaver: should we call a channel op to kick it?
12:33:22 <centrinia> mattam, id (fix id) = fix id
12:35:07 <roconnor> @free (fix id)
12:35:08 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
12:35:23 <vixey> @free fix_id :: forall a. a
12:35:23 <lambdabot> f fix_id = fix_id
12:35:51 <roconnor> @free id
12:35:53 <lambdabot> f . id = id . f
12:36:16 <roconnor> @free fix
12:36:18 <lambdabot> f . g = h . f => f (fix g) = fix h
12:36:47 <roconnor> ah, you put those two theorem together to get centrinia's result
12:37:28 <roconnor> and you also get fix_id's result
12:37:38 <vixey> this result ? id (fix id) = fix id
12:37:42 <vixey> it's just the definition of fix
12:38:11 <centrinia> Yeah, f :: a -> a; f (fix f) = fix f
12:38:41 <maltem> centrinia, I mean, "fix id" is just bottom, so there's nothing a bot can do about it
12:39:00 <dolio> It's also the definition of id.
12:39:06 <vixey> haha
12:40:11 <roconnor> dolio: that too I guess ...
12:40:45 <roconnor> vixey: oh, and that too
12:40:52 <roconnor> *sigh*
12:40:55 <roconnor> :)
12:52:36 <travisbrady> @hoogle atomically
12:52:37 <lambdabot> Control.Exception NestedAtomically :: Exception
12:53:24 <___> @index atomically
12:53:24 <lambdabot> GHC.Conc, Control.Concurrent.STM
12:53:42 <Axman6> the mibbitninja strikes again!
12:59:59 <romildo> Hi.
13:01:30 <romildo> The documentation for the Dialog widget from gtk2hs mentions the function dialogNewWithButtons to create a new dialog, but it seems to be missing from the library. Any help?
13:06:28 <sheyll> hi
13:06:56 <sheyll>  how do I write this more elegantly: curry (concat . (uncurry intersperse))
13:07:08 <vixey> what does it do
13:07:15 <sheyll> curry (concat . (uncurry intersperse)) ";" ["huhu", "welt"]
13:07:18 <tomh> that looks like lisp :>
13:07:23 <vixey> > curry (concat . (uncurry intersperse)) ";" ["huhu", "welt"]
13:07:25 <lambdabot>   "huhu;welt"
13:07:33 <tromp> :t intersperse
13:07:34 <vixey> > intercalate ";" ["huhu", "welt"]
13:07:34 <lambdabot> forall a. a -> [a] -> [a]
13:07:34 <lambdabot>   "huhu;welt"
13:07:41 <___> @index intercalate
13:07:42 <lambdabot> bzzt
13:07:51 <___> Data.Char?
13:07:59 <___> er, List?
13:08:01 <tomh> @source intersperse
13:08:01 <lambdabot> intersperse not available
13:08:08 <mauke> @hoogle intercalate
13:08:08 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
13:08:09 <sheyll> ahh sorry
13:08:09 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
13:08:09 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
13:08:12 <tromp> :t curry (concat . (uncurry intersperse))
13:08:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:08:14 <sheyll> intersperse is in Data.List
13:09:37 <sheyll> ok, but how do I get rid of curry and uncurry? (in case there is no intercalate)
13:10:10 <mauke> (concat .) . intersperse
13:10:18 <vixey> @src intercalate
13:10:18 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:10:29 <mauke> @. pl src intercalate
13:10:29 <lambdabot> (line 1, column 1):
13:10:29 <lambdabot> unexpected end of input
13:10:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:10:32 <vixey> don't point free everything
13:10:38 <seliopou> (concat . ) . intersperse
13:10:39 <seliopou> I think
13:10:44 <seliopou> beat me to it
13:10:51 <tromp> :t uncurry intersperse
13:10:52 <lambdabot> forall a. (a, [a]) -> [a]
13:10:53 * wli thinks about all that can be done is Grobner basis -based gcd stuff for decompositions into normal (i.e. gcd(p, dp/dt) = 1) and special (i.e. gcd(p, dp/dt) = p) parts.
13:11:08 <kadaver> would it be hard to write a hindly-milner typechecker for python?
13:11:16 <vixey> uhh ...
13:11:23 <vixey> python isn't HM typeable
13:11:34 <b_jonas> yeah, it's not the typechecker that's the problem but the types
13:11:44 <vixey> so it would be difficult
13:11:51 <idnar> you could implement an H-M type system in PYthon
13:11:56 <b_jonas> you couldn't really make most python programs well-typed even if the programmer annotated all the expressions with types
13:11:56 <kadaver> yeah now that i thought about it youd need the basic types and theor operations t derive the rest?
13:11:57 <idnar> not sure that would be useful, though
13:12:28 <seliopou> kadaver, look at typed scheme
13:12:35 <idnar> b_jonas: yeah, you'd need to make all the duck typing use explicit type classes or something
13:12:36 <seliopou> probably close to what you're thinking of
13:12:36 <kadaver> but could you make some more static analysis in dynamic languages?
13:13:00 <b_jonas> kadaver: sure you could, and some people are trying to do that, but I don't believe that's a good direction
13:13:13 <b_jonas> they are trying to "optimize" dynamical languages that way
13:13:24 <seliopou> b_jonas, I don't think that's the motivation
13:13:31 <seliopou> if by optimize you mean make more efficient
13:14:35 <b_jonas> seliopou: whats' the motivation?
13:14:48 <seliopou> it's more about being able to use scripting languages for what they're good for (quick prototyping) and then enforcing type discipline as the project grows
13:15:00 <wli> Type inference to optimize dynamically-typed languages is relatively standard.
13:15:38 <bavardage> isn't that what the newer funky javascript thingies are doing?
13:15:59 <b_jonas> seliopou: hmm
13:16:18 <seliopou> bavardage, are you talking about tracing vms?
13:16:33 <bavardage> no clue
13:16:51 <seliopou> wli: where have you come across that?
13:16:51 <bavardage> I thought the newer javascript wms were doing something with regards turning things into classes
13:17:29 <seliopou> bavardage, ah, that's something that v8 does, I believe
13:17:37 <bavardage> yeah
13:17:42 <marcot> Hello, I'm trying to parse a list of lines, where the information I want is just in the beggining of the line. http://pastebin.com/m270f8d0a
13:17:46 <wli> seliopou: I remember hearing it about Lisp/scheme implementations ca. 10 years ago, I also recall it from Palsberg's "Object-Oriented Type Systems."
13:18:10 <wli> The hearsay only said that it happened.
13:18:20 <bavardage> "Instead, V8 dynamically creates hidden classes behind the scenes. "
13:18:22 <bavardage> yup
13:18:23 <marcot> I thought about using chainr1 to parse all lines, and add manyTill ... newline to discard the comments.  Everything after the command is a comment, there's no separator for them.
13:18:25 <bavardage> that's what I meant
13:18:31 <wli> Palsberg described a type inference process that inserted coercions and dynamic typechecks where necessary.
13:19:07 <wli> ("process" vs. "algorithm" as it was vague enough to encompass a broad variety of algorithms)
13:19:24 <seliopou> wli: in general subtyping + inference = fail
13:19:29 <seliopou> I'll look it up
13:19:36 <vixey> subtyping + inference = fail ?? I didn't know that
13:19:37 <kadaver> how do i fold a tule?
13:19:41 <vixey> are you sure
13:20:07 <wli> seliopou: It's not done in terms of subtyping, but rather something called a "subset interpretation."
13:20:07 <seliopou> by fail I mean undecidable
13:20:19 <seliopou> gah, it's a book
13:20:33 <wli> Yes, it's a book.
13:21:08 <monochrom> subtyping is best done dependently :)
13:21:27 <kadaver> can I join (*) a tuple?
13:21:44 <jmcarthur> curry $ join (*) ?
13:21:48 <jmcarthur> err
13:21:51 <jmcarthur> uncurry?
13:21:54 <skorpan> :t uncurry
13:21:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:21:58 <jmcarthur> :t uncurry $ join (*)
13:21:59 <lambdabot> forall b c. (Num (b -> c)) => (b -> c, b) -> c
13:22:03 <jmcarthur> nope, oops
13:22:04 <seliopou> sweet
13:22:11 <Berengal> :t uncurry (*)
13:22:12 <lambdabot> forall a. (Num a) => (a, a) -> a
13:22:21 <Berengal> Although that only takes a pair
13:22:32 <skorpan> :t join
13:22:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:22:38 <jmcarthur> :t join (&&&)\
13:22:39 <lambdabot> parse error on input `\'
13:22:40 <jmcarthur> :t join (&&&)
13:22:41 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
13:22:44 <Berengal> You can do it for arbitrary size tupples with template haskell
13:23:29 <jmcarthur> :t curry join
13:23:30 <lambdabot> forall a a1. (Monad ((,) a)) => a -> (a, a1) -> (a, a1)
13:23:41 <jmcarthur> :t uncurry join
13:23:42 <lambdabot> forall a b. (b -> b -> a, b) -> a
13:23:49 <jmcarthur> stupid enough to be spamming
13:23:50 <wli> Anyway, it's not too tough to figure out. In a bunch of places where more orthodox inference would spit out an error, you slap in implicit coercions and/or dynamic typechecks.
13:23:53 <cnwdup> curlGetString url [] >> \(_, f) -> writeFile "./someFile" f -- why is this so very inefficient?
13:24:18 <jmcarthur> @djinn ((a,a) -> a) -> a -> a
13:24:18 <travisbrady> why do i get a not in scope error here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2142#a2142 ?
13:24:18 <lambdabot> f a b = a (b, b)
13:24:23 <cnwdup> I'm downloading a ~100MB file that way and ghci is already eating up about 1GB of memory.
13:24:31 <jmcarthur> @pl \a b -> a (b, b)
13:24:31 <lambdabot> (. join (,))
13:25:24 <Procy0n> http://matin.maapallo.org/site.pl/selain/?c=wulff&i=667
13:29:31 <seliopou> wli, sounds like soft typing, which is a good compromise, but once you start compromising, tough goes out the window
13:32:45 <wli> I wouldn't design a language around using it, but when you're stuck with such a language and are optimizing the implementation, it's what you do.
13:34:08 <seliopou> wait a sec, "subset interpretation"? CFA?
13:36:28 <jedai> cnwdup: I supose this >> is really >>=
13:36:28 <wli> seliiopou: I only remember the phrase occurring. I can't tell you much of anything else abou tit.
13:36:46 <cnwdup> jedai, yes it is. Sorry.
13:36:56 <jedai> cnwdup: did you try to use ByteString instead of String ?
13:37:43 <cnwdup> jedai, I haven't. But I'll try tomorrow. Got to go now. Thanks anyways. (:
13:38:02 <RayNbow> hmm...
13:38:13 <RayNbow> > let {splits xs = xs >>= \x -> return (x, delete x xs)} in splits [1,2,1,10]        -- (from TMR11)
13:38:14 <lambdabot>   [(1,[2,1,10]),(2,[1,1,10]),(1,[2,1,10]),(10,[1,2,1])]
13:38:18 <RayNbow> > let {splits xs = xs >>= \x -> return (x, delete x xs)} in nub $ splits [1,2,1,10]  -- but is there a better way to solve this one?
13:38:19 <lambdabot>   [(1,[2,1,10]),(2,[1,1,10]),(10,[1,2,1])]
13:38:46 <RayNbow> (or does an ordinary list + nub suffices?)
13:39:36 <jedai> cnwdup: Note that for simple tasks like that, it may be better to use a simple alternative like download-curl
13:40:10 <centrinia> Is there an unsafeFromMonad :: (Monad m) => m a -> a ?
13:40:20 <jedai> cnwdup: if you don't use the full power of Curl, you can as well use something easier to read and use :)
13:40:35 <mauke> centrinia: no
13:40:46 <centrinia> Is it possible to write such a function?
13:40:52 <adamvo> :t head
13:40:53 <___> there's an unsafeFromList = head
13:40:54 <lambdabot> forall a. [a] -> a
13:40:57 <jedai> centrinia: No, it wouldn't make sense since every monads is "run" differently
13:41:11 <mauke> centrinia: no, unless you mean unsafeFromMonad _ = undefined
13:41:34 <c_wraith> Better yet, how do you extract an a from Nothing in Maybe a?
13:41:38 <jedai> mauke: You could also use unsafeCoerce# ^^ (such a good idea)
13:42:11 <mauke> @quote What.*No
13:42:11 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
13:42:11 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
13:42:11 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
13:42:14 <mauke> argh
13:42:29 <Procy0n> n
13:42:32 <___> in fact there are many unsafeFromLists.  (!! 1), (!! 2), last, for examples.
13:42:34 <Baughn> mauke: Lovely story. :D
13:42:36 <Baughn> I never knew
13:42:40 <jedai> centrinia: Anyway it don't exists and you can't write anything that would make sense
13:43:06 <Baughn> centrinia: You could write a class UnsafeFromMonadAble or some such, of course
13:43:16 <defun> :t (,)
13:43:17 <lambdabot> forall a b. a -> b -> (a, b)
13:43:25 <___> > (,) 'a' 1
13:43:27 <lambdabot>   ('a',1)
13:43:27 <Baughn> centrinia: You need a different implementation for each monad, which is what typeclasses are /for/
13:43:32 <mauke> @quote What.a.=
13:43:33 <lambdabot> mauke says: data What a = No; instance Monad What where { return _ = No; No >>= _ = No }
13:43:42 <centrinia> Okay.
13:43:44 <Baughn> centrinia: ..mind you. I don't quite see the use case.
13:43:51 <jedai> Baughn: Even then as c_wraith pointed it, for some monads you would have to put partial unsafeFromMonad
13:44:04 <Baughn> jedai: Some? Practically all, I'd say
13:44:11 <mauke> see above :-)
13:44:18 <jedai> Baughn: Right ;-)
13:44:22 <Baughn> Maybe is special in that sometimes it /could/ be unsafeFromMonad'd
13:44:36 <centrinia> Is unsafePerformIO a partial function?
13:44:43 <Baughn> But State, Parsec, etc. - all of the input-requiring monads would have a stroke
13:44:50 <Baughn> centrinia: It's not a function
13:44:55 <___> data MoreWhat a; instance Monad MoreWhat where return = undefined; _ >>= _ = undefined
13:45:01 <Axman6> "The number 6 is a good value to pass to this function." ha, best comment i've ever seen in haddock docs
13:45:35 <Baughn> centrinia: But for what it's worth, trivially yes; unsafePerformIO (anything_that_crashes)
13:46:49 <Axman6> @remember Data.Numbers.Primes The number 6 is a good value to pass to this function.
13:46:49 <lambdabot> Done.
13:47:59 <c_wraith> Is there some strange interaction between Handle and FD when using dupTo?
13:48:27 <c_wraith> I'm seeing stderr getting closed when stdError is still a valid FD
13:49:03 <mauke> how did you get the Fd?
13:49:38 <c_wraith> handleToFd h, where h is an argument that happens to be stderr
13:49:46 <centrinia> What is (wheelSieve 0) ?
13:50:03 <Baughn> Undefined?
13:50:18 <mauke> c_wraith: Extracts the Fd from a Handle. This function has the side effect of closing the Handle and flushing its write buffer, if necessary.
13:50:28 <c_wraith> ...  thanks mauke.
13:50:32 <mauke> c_wraith: Extracts the Fd from a Handle. Ｔｈｉｓ ｆｕｎｃｔｉｏｎ ｈａｓ ｔｈｅ ｓｉｄｅ ｅｆｆｅｃｔ ｏｆ ｃｌｏｓｉｎｇ ｔｈｅ Ｈａｎｄｌｅ and flushing its write buffer, if necessary.
13:50:33 * c_wraith beats his head on the wall
13:50:42 <Baughn> centrinia: Assuming that's a primality-checking function, I very much doubt it was written with 0 in mind
13:50:45 <vixey> lol
13:51:26 <Baughn> mauke: Is.. how does that "emphasized" region look to you?
13:51:35 <mauke> fat
13:51:38 <Baughn> I see
13:51:40 <c_wraith> Is there another function to get the FD?
13:51:41 <wli> Wheels are usually prime sievers / generators.
13:51:49 <centrinia> It says that (wheelSieve n) uses a wheel cancels the first n primes.
13:52:08 <c_wraith> Or am I just going to have to pass in the FD, rather than the handle?
13:52:08 <Baughn> Oh. Well. Could be [1..], then.
13:52:13 <Baughn> Why don't you try it?
13:52:46 <Baughn> c_wraith: Technically, you're not supposed to want both the handle and the fd. What are you trying to do?
13:52:47 <centrinia> Hmm, wheelSieve 0 == wheelSieve 1
13:52:58 <travisbrady> if i wrap Data.Map with newtype, how do I get all of the functions in Data.Map to work on my new type?
13:53:17 <mauke> travisbrady: write wrappers. by hand.
13:53:17 <wli> Yeah, they're the differences between successive numbers which are relatively prime to the product of the first n primes.
13:53:19 <c_wraith> For testing logging code, I'm trying to test extreme-error fallback case of logging to stderr.
13:53:36 <centrinia> wheelSieve (-1) doesn't work though. ;)
13:53:42 <travisbrady> mauke: ah, ok, i had figured as much but thought maybe they could derived somehow
13:53:43 <Baughn> travisbrady: Use newtype deriving. Add "deriving(foo,bar,baz)" to your newtype definition for the instance syou want.
13:54:20 <c_wraith> I want to divert stderr to a different location for the test, in order to verify that the expected output is getting logged there.
13:54:22 <Baughn> travisbrady: Mauke's right, for haskell'98. GHC has a few more tricks
13:54:25 <___> centrinia: the source to Data.Numbers.Primes links to some papers.  Perhaps those would be a good place to look if you want to understand what the code does?
13:54:34 <c_wraith> But then restore it after that specific test, as HUnit uses stderr
13:54:40 <travisbrady> Baughn: but that won't work for stuff like lookup, insertWithKey, etc will it as there
13:54:50 <travisbrady> 's no Map typeclass?
13:54:52 <c_wraith> I can just use stdError
13:55:00 <c_wraith> It will work, since this is just test code
13:55:32 <Baughn> travisbrady: No, as those aren't instance methods
13:55:35 <wli> So a whee on the first two primes goes over the residues 1 and 5 mod 6, so you get 6*k-5, 6*k+1, 6*k+5, 6*k+7, for cycle [2,4] being the wheel for the first two primes.
13:55:38 <Baughn> travisbrady: You may be looking for the Edison package(s)
13:55:48 <travisbrady> @where edison
13:55:49 <lambdabot> http://www.cs.princeton.edu/~rdockins/edison/home/
13:55:53 <travisbrady> Baughn: thank you
13:57:27 <travisbrady> if i were to write wrappers by hand how do i sort of unpack the Data.Map out of my wrapped type?
13:57:35 <Baughn> c_wraith: I'm not aware of any way to reliably switch out an arbitrary FD, but.. I suppose, closing stderr and then reopening it is pretty much guaranteed to get you the same FD back
13:57:59 <Baughn> Or at least, the conditions under which it wouldn't are sufficiently pathological that you can safely crash. So..
13:58:07 <mauke> travisbrady: pattern matching
13:58:18 <c_wraith> Baughn: I can just use dupTo to switch out the definition of file descriptor 2 from under stderr
13:58:28 <c_wraith> Baughn: it will never know anything changed. >_>
13:58:41 <Baughn> c_wraith: Oh, right. Forgot about dup2. >_<
13:58:55 <Baughn> c_wraith: Anyway, the actual stderr FD is exported in System.POSIX.IO
13:59:05 <c_wraith> Baughn: Yeah, that's what I'm going to use.
13:59:25 <Baughn> c_wraith: Have fun, and don't eat anyone I wouldn't
13:59:37 <c_wraith> Baughn: Does that rule out anyone?
13:59:42 <Baughn> c_wraith: Me
14:00:18 <Baughn> travisbrady: If you use Edison, this won't be a problem; all the functions are instance methods, so you can just newtype-derive them at need
14:00:30 <Baughn> travisbrady: It's got a wrapper for Data.Map too, if you want that one in particular
14:01:22 <travisbrady> Baughn: very cool, are you aware of Edison being used anywhere extensively where I might find examples?
14:02:02 <Baughn> travisbrady: Not as such, but I figured it out pretty quickly myself
14:07:17 <bavardage> can anyone explain/hint how to form the pred function in lambda calc?
14:08:01 <vixey> bavardage: it's too fun a puzzle
14:08:07 <mauke> "\\n s z -> n (\\f g -> g (f s)) (const z) id"
14:08:15 <vixey> it's not fun if someone tells you
14:08:16 <bavardage> I have the definition yeah
14:08:20 <bavardage> but I HAVE NO IDEA WHY
14:08:36 <bavardage> otherwise I have built now all the way up to lists and integers
14:08:37 <vixey> well I'm not gonna spoil it for you but someone else might
14:08:38 <bavardage> BUT DAMMIT
14:08:40 <bavardage> hmm
14:08:44 <bavardage> any hints?
14:08:47 <bavardage> any vague directions?
14:08:50 <dolio> Use a pair.
14:08:51 <bavardage> I have no idea how to even go about it
14:09:15 <bavardage> dolio: and that function can still act on a normal church numeral?
14:09:23 <bavardage> since I have negative numbers and such using pairs
14:09:46 <byorgey> bavardage: right, it just uses a pair internally
14:09:50 <bavardage> oh kk
14:09:55 <bavardage> I'll think about it more then
14:09:59 <byorgey> to keep track of... some extra information.
14:10:47 <mauke> :t \n s z -> n (\f g -> g (f s)) (const z) id
14:10:48 <lambdabot> forall t t1 t2 a b a1 t3. (((t -> t1) -> (t1 -> t2) -> t2) -> (b -> a) -> (a1 -> a1) -> t3) -> t -> a -> t3
14:12:37 <bavardage> right
14:12:41 <bavardage> do I need recursion or anything?
14:12:53 <bavardage> since if I could work out how to do recursion (something else GAH)
14:13:01 <bavardage> I could recurse backwards I guess
14:13:06 <bavardage> oh wait.. I don't have equality either
14:13:07 <bavardage> DAMMIT
14:15:37 <mauke> .extend( "is-zero" , "\\n -> n (const false) true" )
14:15:50 <mauke> .extend( "fix"     , "(\\rec -> rec (\\y f -> f (rec y f))) (\\f -> f f)" )
14:16:07 <Gracenotes> hm, is there a Linux utility like banner, but that does text horizontally? :\
14:16:16 <vixey> mauke what's with the \\?
14:16:25 <mauke> escapes the \
14:16:29 <vixey> I know ... but
14:16:31 <vixey> why did you do that
14:16:43 <vixey> isn't that perl
14:16:54 <mauke> no, it's C++
14:17:03 <mauke> but it's also syntactically valid Haskell
14:17:05 <vixey> oh.. that explains it
14:18:26 <Berengal> Gracenotes: banner $text |  -e "unlines.transpose.lines" ?
14:18:33 <Berengal> * ghc -e
14:18:52 <Gracenotes> mm, not quite.. banner just cuts out lines of characters, so transposing it wouldn't work
14:18:58 <byorgey> bavardage: no recursion, but if you have the church numeral n, you can repeat anything you like n times
14:19:07 <bavardage> yeah
14:19:15 <bavardage> but I'd like to do it via a condition
14:19:22 <bavardage> since I have iszero and such
14:19:30 <byorgey> bavardage: what do you mean, via a condition?
14:20:13 <bavardage> so (isnil l) (0) (add (head n) (sum (tail n))
14:20:22 <bavardage> > y f = f (y f)
14:20:23 <lambdabot>   <no location info>: parse error on input `='
14:20:26 <bavardage> dammit wrong paste :P
14:20:33 <vixey> actually there is a hint for it, but it's a pretty advanced induction method ...
14:20:48 <vixey> and viewing this stuff through curry howard for the first time wouldn't make it easier
14:21:12 <zimbatm> anyone knows when unix-2.3.2.0 will be updated for GHC 6.10 ?
14:23:04 <bavardage>  > sum' = (\rec -> \l -> (isnil l) (zero) (add (head l) (rec (tail l)))) <-- this errors
14:23:19 <bavardage> "cannot construct the infinite type: t = t -> t2 -> t1"
14:23:51 <_dls> hey guys, I'm wondering if there's a way to declare: data TwoFns = TwoFns (a->b) (a->b)   [basically store a function in a data]
14:24:42 <vixey> _dls: data TwoFns a b = TwoFns (a->b) (a->b)
14:24:54 <vixey> _dls: or  type TwoFns a b = (a->b,a->b)
14:25:06 <_dls> vixey: thank you sir :)
14:26:14 <vixey> behh
14:27:45 <bavardage> gaah
14:27:47 <bavardage> :(
14:27:56 <bavardage> I just copied an example of a factorial too
14:27:59 <bavardage> and that errored
14:31:26 <alexsuraci> hrm, is there a way to verify that all elements of a list use the same data constructor? e.g. with "data Foo = Bar Int | Buzz String", making sure it's [Bar 1, Bar 2] and not [Bar 1, Buzz "hi"]
14:31:40 <skorpan> :t all
14:31:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:31:51 <skorpan> all (\x -> case x of ...) xs
14:32:13 <alexsuraci> so just use pattern matching, then
14:32:20 <skorpan> i'd say so, but i'm no master
14:32:37 <alexsuraci> alright, that's all I could think of too
14:33:12 <skorpan> maybe you could do something like "all (\Bar _ -> True) xs" and recover the pattern matching failure somehow, i'm not sure
14:33:35 <vixey> alexsuraci: not sure what that could mean
14:33:46 <vixey> alexsuraci: do you want to enforce it at compile time?
14:34:22 <alexsuraci> vixey: I'm writing a language that has lists that can only contain one type (like Haskell, etc.)
14:34:40 <vixey> maybe this sort of thing is good
14:35:00 <alexsuraci> All of the values are stored in a "Value" type specifying the types for the language, I'm working on a verifyList function that takes a list of Values and makes sure they're the same constructor basically
14:35:13 <vixey> data Term t where IntTerm :: Int -> Term Int ; BoolTerm :: Bool -> Term Bool ; Nil :: Term [a] ; Cons :: Term a -> Term [a] -> Term [a]
14:35:57 <vixey> this lets you do Cons (IntTerm 3) (Cons (IntTerm 2) Nil), but not Cons (IntTerm 3) (Cons (BoolTerm False) Nil)
14:36:06 <alexsuraci> Interesting
14:36:17 <vixey> you can also write  haskellify :: Term t -> t
14:36:23 <alexsuraci> Never seen the "where" syntax used with the data constructor
14:43:23 <justinkb> its not possible to use something anologous to pattern matching in an anonymous function is it?
14:43:45 <vixey> > (\(Just t) -> t) (return 3)
14:43:47 <lambdabot>   3
14:44:10 <Eduard_Munteanu> Hi there. Any Haskell exercises out there? That is, besides the Euler problems, I'd like something specific to Haskell and more practical.
14:45:28 <justinkb> if i wanted to have a pointfree definition of a function that gives the area of a geometric shape (data Shape = Rectangle (Side, Side) | Ellipse (Radius, Radius)), that is impossible, right? or can it be done without pattern matching on the different constructors?
14:45:31 <monadic_kid> Eduard: http://book.realworldhaskell.org/
14:45:54 <vixey> justinkb :define:
14:46:03 <meder> anyone mess a ton w/ http vs https protocol and pulling in  dozens and dozens of resources such as images? any performance  diff?
14:46:07 <marcot> How can I get back to a position when reading a bytestring encoded with Data.Binary?
14:46:10 <vixey> foldShape rectangle ellipse (Rectangle xy) = rectangle xy
14:46:12 <alexsuraci> vixey: I'd just use pattern matching for a "haskellify" function still, correct?
14:46:13 <marcot> Is it possible to do this using Get?
14:46:22 <vixey> foldShape rectangle ellipse (Ellipse xy) = ellipse xy
14:46:31 <vixey> then you can use foldShape to definne a point free version
14:46:34 <inimino> meder: try #web
14:46:38 <vixey> but als,
14:46:39 <meder> lol
14:46:47 <vixey> data Shape = Rectangle Side Side | Ellipse Radius Radius
14:46:48 <Eduard_Munteanu> monadic_kid, thanks.
14:46:49 <vixey> could be better
14:46:56 <vixey> alexsuraci, yes
14:47:15 <monadic_kid> Eduard_Munteanu: there is an online version if you missed that
14:48:15 <justinkb> well, foldshape isn't pointfree ;-) so i guess it cant be done?
14:50:07 <vixey> justinkb: what can't be done?
14:50:17 <justinkb> i can do area = \(Rectangle (x,y) -> x*y ... but i cant handle the case for Ellipses in the same anonymous function
14:50:24 <vixey> yeah you can
14:50:39 <vixey> \shape -> case shape of Rectangle x y -> ... ; Ellipse u v -> ...
14:50:40 <justinkb> not without using another function that isnt pointfree
14:50:47 <vixey> or
14:50:51 <vixey> (foldShape ...)
14:51:05 <justinkb> ah
14:51:29 <justinkb> cheers :) that first one is what i was looking for!
14:52:47 <justinkb> excellent, thanks for the help
14:53:33 <Gracenotes> or you could define a 'shape' function :P
14:53:58 <Gracenotes> shape :: (Int -> Int -> a) -> (Int -> Int -> a) -> Shape -> a
14:54:07 <Gracenotes> if you really want to get in over your head >_>
14:54:22 <Gracenotes> /half-serious
14:54:52 <vixey> Gracenotes: I already said that
14:55:16 <Gracenotes> oh, you did? lol.
14:55:35 * Gracenotes should scroll up more often
14:56:40 <___> presumably vixey alluded to it by saying (foldShape ...), but you gave more detail.
14:57:00 * vixey defined foldShape earlier
14:57:12 <___> oh?  My mistake then.
15:04:05 * byorgey bakes lambdanana bread
15:07:30 * centrinia makes some concave lens bread.
15:08:15 * centrinia decides to also make some barbed wire bread. >:)
15:08:18 * ___ chomps down on some barbed wire
15:08:24 <roconnor> ow
15:08:55 <___> pretty good once you get past the initial unpleasantness.
15:14:54 <byorgey> so now I'm getting the thing where cabal complains that ghc-6.8.3 requires both process-1.0.0.1 and process-1.0.1.1.  anyone know the solution offhand?
15:15:55 <cristi_ceata> which extension should I use for the bird-style sources?
15:16:18 <ehird> ___: i just want you to know that i respect your nick.
15:16:47 <byorgey> cristi_ceata: I don't understand your question.  Which extension of what?  What are you trying to do?
15:17:12 <arjanb> byorgey: http://haskell.org/cabal/FAQ.html#dependencies-conflict
15:17:19 <ehird> byorgey: he wants literate haskell
15:17:43 <byorgey> ah, arjanb++
15:17:44 <byorgey> thanks
15:17:58 <mauke> .lhs
15:19:22 <cristi_ceata> byorgey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2143#a2143 this is the source. which extension should I put to it?
15:19:38 <cristi_ceata> byorgey: or how do I compile it?
15:20:17 <byorgey> cristi_ceata: you don't need any special extensions to compile it; if it ends in .lhs ghc will automatically assume it is literate Haskell.
15:20:27 <byorgey> however, I'm pretty sure you need blank lines around  code sections
15:20:44 <vixey> .lhs is the extension :p
15:20:54 <byorgey> oh! haha
15:21:11 <byorgey> I was thinking extension as in 'language extension', not 'file extension' =)
15:21:23 <byorgey> duh
15:21:42 <cristi_ceata> thanks
15:23:25 * byorgey recompiles lots of packages after deleting process-1.0.1.1 =P
15:26:31 * cooldude127 loves literate haskell
15:27:06 <cooldude127> is there a haskell tool to do literate haskell cweb style? like with labeled sections?
15:27:24 <byorgey> cooldude127: there is, actually, let me find you a link
15:27:56 <cooldude127> byorgey: much appreciated
15:28:13 <byorgey> http://mathmeth.com/eem/hweb/quickstart.shtml
15:28:20 <cooldude127> oh cool
15:28:26 <Berengal> Literate programming is too underused...
15:28:45 <byorgey> it's true.
15:28:50 * byorgey is ashamed
15:29:00 <Berengal> Granted, it takes longer to write a program in it, but it gives you a much better understanding of your program
15:29:01 <byorgey> (that he doesn't do more of it)
15:29:23 <cooldude127> Berengal: and it makes it way more possible for others to understand it
15:29:53 <Berengal> cooldude127: Very much so, but I do it for myself mostly
15:30:19 <cooldude127> yeah, this is my first time with literate programming, but i'm finding it to be very rewarding
15:30:35 <cooldude127> at the moment i'm using lhs2TeX but i want to try out hweb
15:31:10 * Berengal doesn't know TeX :(
15:31:41 * cooldude127 loves tex so much it's sick
15:31:41 <Berengal> I use bird tracks...
15:31:44 <byorgey> cooldude127: lhs2TeX is pretty cool, especially for writing papers that include Haskell
15:31:53 <cooldude127> byorgey: that's kind of what i'm doing right now
15:31:53 <Berengal> Then again, I always prefered reading plain text files
15:32:02 <kosmikus> byorgey: I agree :)
15:32:41 <cooldude127> my favorite thing about lhs2TeX is the %format directives. making certain operators be replaced by the symbols they are supposed to be
15:32:48 <cooldude127> especially with hmatrix code
15:32:49 <byorgey> kosmikus: hehe, I'm very glad to hear that ;)
15:32:54 <byorgey> otherwise I would be worried
15:35:14 <kosmikus> cooldude127: is hmatrix some extension of HList to type-level matrices?
15:35:42 <cooldude127> hmatrix is a layer over GSL and LAPACK/BLAS for linear algebra
15:35:47 <kosmikus> ah
15:35:57 <cooldude127> it's simply wonderful
15:36:05 <cooldude127> except it doesn't install well on all systems
15:37:20 <bavardage> gah
15:37:35 <bavardage> has anyone attempted pure lambda calc in haskell?
15:37:50 <bavardage> or do I have to write an 'interpreter' in haskell
15:38:20 <tromp> what do you mean by pure lambda calc in haskell?
15:38:24 <bavardage> I keep getting infinite type errors
15:38:29 <bavardage> tromp: building up a lamba calc
15:38:34 <tromp> well, haskell is typed
15:38:41 <bavardage> from a few statements
15:38:48 <tromp> so cant do untyped lambda calc without interrpreter
15:38:52 <mauke> newtype Lam a = L{ unL :: Lam a -> Lam a }
15:39:02 <centrinia> I have a Lambda Calculus to Combinatory Logic converter made in Haskell.
15:39:19 <Gracenotes> the untyped lambda calculus is not possible to implement in Haskell with just its functions
15:39:22 <glguy> mauke, what good is the "a" in that case?
15:39:28 <mauke> hmm
15:39:28 <Gracenotes> with Expr constructors, 'tis
15:39:40 <mauke> the answer is "brain damage"
15:39:41 <bavardage> Gracenotes: what are 'Expr' constructors?
15:39:47 <bavardage> http://paste.pocoo.org/show/112871/ <-- this is what I have so far
15:39:54 <bavardage> have I gone completely the wrong direction?
15:40:03 <Gracenotes> bavardage: well, just something representating Lambdas, Variables, Application, etc.
15:40:39 <bavardage> and then do what?
15:40:48 <bavardage> use the beta eta sub and stuff?
15:41:06 <bavardage> and then build up the language using that, rather than using haskell lamba expressions?
15:41:26 <Gracenotes> well, you could control that language better. At the moment you have something embedded in Haskell, which is fine
15:41:34 <bavardage> but it breaks :(
15:41:39 <Gracenotes> except Haskell has type requirements the untyped lambda calculus doesn't
15:41:46 <bavardage> as in, how the hell do I do recursion with what I have there :P
15:41:48 <mauke> newtype Lam = L{ unL :: Lam -> Lam }; zero = L (\s -> L (\z -> z)); succ = L (\n -> L (\s -> L (\z -> unL (unL n s) (unL s z))))
15:41:52 <Gracenotes> for example, the fix combinator is impossible to implement without recursion
15:41:58 <Gracenotes> in Haskell
15:42:03 <Gracenotes> Y-combinator
15:42:09 <bavardage> yeah
15:42:10 <mauke> that sounds like a challenge
15:42:14 <bavardage> I can't get anything using that to work
15:42:16 <Gracenotes> difficult :)
15:42:31 <bavardage> but if I build it up myself?
15:42:39 <bavardage> it doesn't matter about haskell's type checking?
15:43:36 <Gracenotes> nope. you just deal with Lambdas between expressions and stuff.
15:43:51 <bavardage> using the scary substitution stuff
15:43:53 <bavardage> hmmm
15:44:15 <bavardage> *is* it possible to continue with what I'm doing
15:44:22 <bavardage> like, is there any way to implement recursion?
15:44:26 <Gracenotes> bavardage: well. you can make it all evaluate to an 'untyped' type
15:44:39 <Gracenotes> if you were to build it up yourself
15:44:44 <Gracenotes> as it stands, you can't do recursion
15:44:48 <bavardage> kk
15:44:53 <bavardage> I'll stop here then I guess
15:44:56 <bavardage> It has been fun D
15:44:57 <tromp> your and,or look complicated
15:45:04 <bavardage> tromp: probably are :D
15:45:08 <Gracenotes> in building it up yourself, it would look like: Lam "f" (App (Lam "x" (App (Var "f") (App (Var "x") (Var "x")))) (Lam "x" (App (Var "f") (App (Var "x") (Var "x")))))
15:45:16 <tromp> and = \x\y x y x
15:45:24 <tromp> or = \x\y x x y
15:45:39 <cristi_ceata> what does let exactly do?
15:45:41 <bavardage> tromp: mine work too :D
15:45:43 <Gracenotes> which is really \f -> (\x -> f x x) (\x -> f x x), iirc
15:45:55 <bavardage> btw, how did you guys learn lamba calc?
15:46:13 <tromp> read articles, books
15:46:16 <bavardage> like any good books/tuts?
15:46:18 <bavardage> hmm
15:46:19 <mauke> am I doing this right?  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2144#a2144
15:46:21 <chrisdone> the wikipedia article
15:46:40 <chrisdone> and then implement a lambda calculus evaluator in haskell
15:46:48 <tromp> i once read smullyan's book on the mockingbird
15:46:52 <bavardage> hah
15:46:57 <wli> bavardage: Kim Mens' paper "An Introduction to Polymorphic Lambda Calculus with Subtyping"
15:46:58 <tromp> that's cute
15:47:17 <bavardage> chrisdone: 'building it yourself' ?
15:47:22 <bavardage> wli: that sounds waay over my head
15:47:37 <tromp> then a wrote a binary lambda calculus interpreter in lambda calculus
15:47:39 <wli> bavardage: It starts from the very very beginning.
15:47:54 <bavardage> hmmm
15:48:00 <wli> bavardage: It is a very good introduction to the lambda calculus in general (or it was for me).
15:48:11 <bavardage> oh kk
15:48:18 <bavardage> what prerequisites?
15:48:20 <Gracenotes> I learned the basics by writing an interpreter: with data U = B Bool | F (U -> U) | I Integer and data LExpr = Var String | Lam String LExpr | App LExpr LExpr | Boole Bool | Cond LExpr LExpr LExpr | Zero | Succ LExpr | Pred LExpr | IsZero LExpr | Add LExpr LExpr
15:48:30 <Gracenotes> eval :: LExpr -> U
15:48:42 <Gracenotes> untyped with type extensions, essentially
15:48:57 <bavardage> (I have no comp science) (I have no maths beyond 'A-level further maths)
15:48:59 <wli> bavardage: No prerequisites.
15:49:04 <bavardage> oh gdgd
15:49:05 <mauke> simplified: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2144#a2145
15:49:11 <chrisdone> bavardage: yup
15:49:18 <mauke> isn't that a lambda calculus fix embedded in haskell?
15:49:47 <sjanssen> mauke: some would say newtype is cheating
15:50:06 <bavardage> "                                                                          The system can still be
15:50:09 <bavardage>                                                        ≤                     ≤
15:50:13 <bavardage> augmented with a notion of subtyping, yielding system Fω. The importance of Fω lies in its abil
15:50:16 <bavardage> "
15:50:18 <bavardage> WTF
15:50:24 <bavardage> sjanssen: how can you do it w/o newtype?
15:50:49 <wli> bavardage: It explains what System F is.
15:51:01 <bavardage> kk
15:51:10 <bavardage> so F_omega is system f?
15:51:13 <Gracenotes> sometimes it might be best to skip the intro?
15:51:15 <bavardage> w/e the hell that is :D
15:51:17 <bavardage> haha
15:51:18 <sjanssen> bavardage: you can't
15:51:31 <bavardage> sjanssen: oh I see
15:51:40 <bavardage> sjanssen: you would use butterflys or something?
15:51:52 <mauke> unicode has no subscript omega! how did that happen?
15:52:11 <Gracenotes> it wasn't made by language designers!
15:52:22 <sjanssen> bavardage: with the type system Haskell uses, you have to either use newtype or 'let' recursion to define fix
15:52:23 <inimino> Unicode has no subscript /k/
15:52:39 <bavardage> oh kk
15:52:42 <sjanssen> bavardage: classic simply typed LC has neither of these
15:52:52 <bavardage> yop
15:53:10 <bavardage> so you have to provide haskell with a 'type' to represent 'notype'
15:53:12 <bavardage> kinda
15:53:38 <mauke> I view LC as typed with everything :: a@(a -> a). Is there a name for that?
15:54:02 <Berengal> untyped?
15:54:59 <jmcarthur> unsafeCoerce?
15:55:06 <jmcarthur> ;)
15:55:15 <mauke> it's not unsafe
15:55:25 <jmcarthur> it's untyped
15:55:28 <mauke> every possible expression is well-typed
15:57:24 <johh> the difference between . and $ is, that you use . when you want to get a function to use it in example for usage with map and use $ when you want to apply something to a variable, right?
15:57:59 <jmcarthur> ($) is function application. (.) is function composition
15:58:22 <tomh> @src (#)
15:58:22 <lambdabot> Source not found.
15:58:26 <tomh> @src ($)
15:58:26 <lambdabot> f $ x = f x
15:58:36 <tomh> @src (.)
15:58:36 <lambdabot> (f . g) x = f (g x)
15:58:37 <jmcarthur> that is, ($) combines a function with a value. (.) combines a function with a function
15:58:39 <mauke> ($) calls a function with an argument, (.) glues two functions together
15:58:55 <Berengal> ($) is the identity for functions
15:59:13 <jmcarthur> :t ($)\
15:59:14 <lambdabot> parse error on input `\'
15:59:17 <jmcarthur> :t ($)
15:59:18 <lambdabot> forall a b. (a -> b) -> a -> b
15:59:19 <jmcarthur> :t id
15:59:20 <lambdabot> forall a. a -> a
15:59:21 <cooldude127> ($) is defined in order to avoid parentheses
15:59:28 <jmcarthur> :t id `asTypeOf` ($)
15:59:28 <mauke> :t id `asTypeOf` ($)
15:59:30 <lambdabot> forall a b. (a -> b) -> a -> b
15:59:30 <lambdabot> forall a b. (a -> b) -> a -> b
15:59:35 <mauke> GET OUT OF MY HEAD
15:59:50 <jmcarthur> I'm gonna eat your brains and gain your knowledge.
16:00:00 <cooldude127> ($) has lowest precedence so you can right foo $ bar baz instead of foo (bar baz)
16:00:01 <mauke> oh, ok
16:00:10 <johh> ok thx
16:00:28 <Berengal> ($) is a boring function. (.) is much more interesting
16:00:43 <johh> i think now I understand all aspects of . and $
16:01:06 <jmcarthur> johh, all aspects? that's a lot of aspects!
16:01:11 <Berengal> johh: Do you see how fmap = (.)?
16:01:12 <NEEDMOAR> GET OUT OF MY TAIL
16:01:33 <jmcarthur> :t (<<<)
16:01:34 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
16:01:44 <jmcarthur> that is also (.) ;)
16:01:57 <mauke> :t (.) `asTypeOf` fmap `asTypeOf` liftM `asTypeOf` liftA `asTypeOf` (<$>) `asTypeOf` (<<<)
16:01:58 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:02:37 <Berengal> :t \a b -> a b
16:02:38 <lambdabot> forall t t1. (t -> t1) -> t -> t1
16:02:51 <Berengal> Wait, that was apply
16:02:55 <Berengal> Maybe I should go to bed
16:05:54 <Berengal> I should be sleeping, but I can't sleep because I've been meditating over the arrow laws. The worst part is that in typeclassopedia, on the same page as the listing, it says I shouldn't lose any sleep over it :/
16:06:32 <monadic_kid_top_> what happened to that .net binding probject?
16:06:33 <mauke> you winןıɐɟ!
16:06:53 <jmcarthur> Berengal, you really shouldn't. from what i've seen, arrows are of limited use for the most part
16:07:43 <Berengal> jmcarthur: I was on the verge of enlightenment when my housemates draged me away to watch a movie earlier this evening, and now I can't get back into it...
16:07:44 <jmcarthur> i mean, they can probably be very nice for certain things, but less general abstractions are usually nicer
16:08:01 <jmcarthur> arrows are like a whole new language
16:08:03 <Gracenotes> @pl \a b -> b a
16:08:04 <lambdabot> flip id
16:08:17 <bavardage> Then Γ | E ∈ Φ _
16:08:21 <bavardage> what does that mean
16:08:24 <bavardage> GAH failpasta
16:08:45 <Berengal> jmcarthur: There's also ArrowApply, which looks like could be rather nice in some cases...
16:08:51 <bavardage> the | should look like |-
16:08:55 <Saizan_> ?seen mmorrow
16:08:55 <bavardage> what does |- mean
16:08:56 <lambdabot> I saw mmorrow leaving #ghc and #haskell 2m 25d 3h 44m 1s ago, and .
16:09:36 <jmcarthur> arrow is very _cool_. i just don't know if it's all that _useful_
16:09:46 <jmcarthur> @src ArrowApply
16:09:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:10:08 <mauke> bavardage: I think it means something like "given the context Γ"
16:10:08 <Berengal> jmcarthur: Doesn't matter if it's useful as long as it's cool :P
16:11:00 <jmcarthur> actually, i bet arrow is _extremely_ useful and we just haven't learned how to apply the abstraction properly
16:11:30 <mauke> that's because we haven't invented bows yet
16:11:34 <deech> Hi in Haskell's STM, is there an 'onRetry' function? For example, I want to report back to a client thread that it is being blocked for some reason.
16:11:56 <cristi_ceata> what should I do when ghci returns me:  "Not in scope: `toLower' " ?
16:12:08 <mauke> cristi_ceata: import Data.Char
16:12:21 <Berengal> jmcarthur: Needs more coffee?
16:12:34 <Berengal> cristi_ceata: In ghci: :m + Data.Char
16:12:48 <jmcarthur> deech, might want to check out http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stm-io-hooks
16:12:57 <jmcarthur> i haven't used it though, and can't endorse it
16:13:23 <Eduard_Munteanu> monadic_kid, I can't find any exercises in that book. Granted, it's full of examples.
16:13:38 <mauke> Berengal: import also works
16:15:19 <monadic_kid> Eduard_Munteanu: well that was my answer to practical/real-world examples/uses than exercises sorry, maybe you can find exercises in here ( i don't know for sure) http://learnyouahaskell.com/
16:37:50 <Eduard_Munteanu> monadic_kid, thanks, I'll take a look
16:52:33 <u_quark> what can cause a Haskell program to print <<loop>> and quit ?
16:52:43 <mauke> an infinite loop
16:54:12 <u_quark> that's kind of strange because my usual loops just don't terminate ....
16:54:12 <u_quark> let lala = lala
16:55:42 <u_quark> or just run out of stack ...
16:55:42 <skorpan> u_quark: i heard that in 6.10.2 let x = x in x will not loop infinitely
16:55:43 <Saizan_> u_quark: loops are not guaranteed to be detected
16:56:22 <u_quark> I am using 6.8.3
16:56:24 <Saizan_> u_quark: code compiled with -O or -O2 has more chance to detect such loops
16:56:27 <skorpan> > let x = x in x
16:56:40 <u_quark> aha
16:56:43 <lambdabot>   thread killed
16:56:57 <mauke> > let x = x + 1 in x
16:56:59 <Saizan_> ..you just caused a zombie on lb's machine
16:57:12 <lambdabot>   thread killed
16:57:21 <skorpan> > let x = x in x / x
16:57:23 <Saizan_> lambdabot won't detect such loops because it doesn't compile expressions.
16:57:28 <Berengal> > fix id
16:57:30 <lambdabot>   * Exception: stack overflow
16:57:36 <skorpan> > let x = x in 0
16:57:37 <lambdabot>   thread killed
16:57:38 <lambdabot>   0
16:57:47 <u_quark> the thing is that the error is run time and not compile time error with -O or -O2 flags...
16:57:59 <Saizan_> yeah, it's a runtime detection.
16:58:10 <u_quark> ahaa tnx...
16:58:52 <Berengal> I think I've actually got an error message like that in ghci...
16:58:54 <Saizan_> basically, if it reenters the same thunk that it's currently evaluating, then it'll print that message
17:00:26 <tromp> the shortest valid haskell program is a loop
17:00:58 <u_quark> I am getting it just after takeMVar witch might be already taken by the same thread ...
17:02:28 <Berengal> u_quark: I've gotten it when the only thread left was waiting on a TChan, so it seems that's possible
17:03:18 <u_quark> strange behavior ...
17:04:22 <Berengal> u_quark: I kinda like it..
17:15:21 <iago_> @src callCC
17:15:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:15:38 <iago_> @src length
17:15:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:15:42 <iago_> @src map
17:15:43 <lambdabot> map _ []     = []
17:15:43 <lambdabot> map f (x:xs) = f x : map f xs
17:15:51 <iago_> @src Control.Monad.Cont.callCC
17:15:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:16:21 <jedai> @hoogle callCC
17:16:21 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
17:16:30 <ddarius> @src Cont callCC
17:16:30 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
17:24:05 <mib_jq34gscr> can a haskell program load another haskell program and execute it?
17:24:11 <mib_jq34gscr> at run time
17:26:00 <monadic_kid> mib: hs-plugin
17:28:43 <mib_jq34gscr> thks
17:28:52 <monadic_kid> mib:*hs-plugins
17:30:48 <monadic_kid> mib: u there still?
17:30:51 <ivanm> oh, has hs-plugins been updated?
17:31:00 <monadic_kid> mib: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
17:31:04 <ivanm> I thought it didn't work with new ghc :s
17:31:17 <ivanm> mib_jq34gscr: ^^ use that link of monadic_kid's
17:31:24 <ivanm> s/use/see/
17:31:48 <mib_jq34gscr> yes i am here
17:32:23 <monadic_kid> not sure if it cabal-builds sucessfully on the latest version ghc
17:33:16 <monadic_kid> actually i can quickly try it out
17:35:46 <monadic_kid> well it seemed to build fine!
17:35:48 <mib_jq34gscr> cabal worked for me, it installed it
17:36:14 <monadic_kid> yeah cabal-install fine
17:37:14 <bvck> Hi folks, I am trying to make XX f a an instance of Bar in the following code but cannot seem to get GHCI to accept it.
17:37:17 <bvck> class Foo f where
17:37:17 <bvck>   foo   :: f a -> a
17:37:17 <bvck> class Bar b where
17:37:17 <bvck>   bar :: (Foo f) => b (f a) -> f a
17:37:17 <bvck>   
17:37:17 <bvck> data (Foo f) => XX f a = X (f a)
17:37:43 <bvck> I have tried: instance Bar (XX f) where
17:37:43 <bvck>   bar (X (f a)) = (f a)
17:38:23 <mib_jq34gscr> monadic_kid: thanks
17:39:42 <monadic_kid> no worries, adios
17:39:53 <bvck> One valid example of how to make XX an instance of Bar will hopefully help me figure this out.
17:40:14 <serguei> lambdabot
17:40:23 <mauke> I'd try instance (Foo f) => Bar (XX f)
17:42:15 <bvck> mauke, I get "Parse error in pattern" for :
17:42:18 <bvck> instance (Foo f) => Bar (XX f) where
17:42:18 <bvck>   bar (X (f a)) = (f a)
17:43:44 <mauke> oh yeah, you can't write (X (f a))
17:43:53 <mauke> bar (X y) = y
17:46:41 <bvck> mauke, getting a even scarier message, but let me try and debug that a bit...:)
17:47:28 <mib_8ppxq91a> I have a haskell code that has literate programming tags (">" "<" etc)  is there a tool that would remove all of them?
17:48:07 <Zao> mib_8ppxq91a: sed?
17:48:25 <Berengal> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple-PreProcess-Unlit.html
17:48:26 <Berengal> maybe?
17:50:20 <sjanssen_> mib_8ppxq91a: there's an unlit executable in your GHC distribution
17:52:20 <ManateeLazyCat> How to update state moand in `evalStateT` recursive?
17:52:38 <mib_8ppxq91a> unlit as a standalone exec?
17:52:43 <mib_8ppxq91a> I don't see any
17:53:35 <sjanssen_> mib_8ppxq91a: it'll be somewhere in /usr/lib
17:55:18 <mib_8ppxq91a> thanks, i found it.
17:58:05 <Berengal> I usually take it as a good sign when the first line of code starts on line 60...
17:58:35 <Berengal> Even better: It's a data declaration, and the next line of code doesn't come until line 120...
17:58:58 <serguei> ?type map
17:58:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:01:09 <serguei> \pl (\x y z -> x z (y z))
18:01:43 <serguei> \?pl (\x y z -> x z (y z))
18:02:03 <serguei> ?pl (\x y z -> x z (y z))
18:02:03 <lambdabot> ap
18:02:43 <serguei> ?pl (\x y -> x)
18:02:43 <lambdabot> const
18:04:27 <serguei> ?pl (\f g x y z w -> g (x/y) (z/w))
18:04:27 <lambdabot> const (flip flip (/) . ((flip . (((.) . (.)) .)) .) . (. (/)) . (.))
18:06:26 <serguei> ?pl (\f x -> f x)
18:06:26 <lambdabot> id
18:06:51 <serguei> ?pl (\f g x -> f (g x))
18:06:52 <lambdabot> (.)
18:07:15 <serguei> ?pl (\f g x y-> f (g x y))
18:07:15 <lambdabot> (.) . (.)
18:09:53 <serguei> ?help
18:09:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:10:03 <serguei> ?list
18:10:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:11:39 <serguei> ?free
18:11:39 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
18:11:54 <serguei> ?free a->a
18:11:54 <lambdabot> Extra stuff at end of line
18:12:02 <serguei> ?free (a->a)
18:12:03 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
18:12:56 <serguei> ?free f::(a->a)
18:12:56 <lambdabot> g . f = f . g
18:13:46 <serguei> ?free f::([a]->[a])
18:13:46 <lambdabot> $map g . f = f . $map g
18:14:49 <serguei> ?free f::([a]->m [a])
18:14:49 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_64.hspp:(152,16)-(160,44): Non-exhaustive patterns in case
18:15:09 <serguei> ?free f::[a]->m [a]
18:15:09 <lambdabot> Extra stuff at end of line
18:15:18 <serguei> ?free (f::[a]->m [a])
18:15:18 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
18:15:34 <serguei> ?free (f::[a] -> [a])
18:15:34 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
18:15:54 <serguei> ?free f::[a] -> [a]
18:15:54 <lambdabot> $map g . f = f . $map g
18:15:59 <serguei> ?free f::[a] -> m [a]
18:16:00 <lambdabot> Extra stuff at end of line
18:16:11 <serguei> ?free f::Monad m => [a] -> m [a]
18:16:12 <lambdabot> Extra stuff at end of line
18:16:20 <serguei> ?free f :: Monad m => [a] -> m [a]
18:16:20 <lambdabot> Extra stuff at end of line
18:16:43 <WindowsXP_Pro> When there is something really long you say "Too long; didn't read", shortened to "tl;dr". Examples of tl;dr are books, the "man" command, textbooks, and game manuals. Linux and programming language documentation is "tl;dr".
18:16:58 <serguei> ?free f :: [a] -> M [a]
18:16:58 <lambdabot> $map_M ($map g) . f = f . $map g
18:17:34 <bremner> WindowsXP_Pro: ts;i
18:17:53 <serguei> ?free f :: a -> a -> a
18:17:54 <lambdabot> g . f x = f (g x) . g
18:20:12 <ManateeLazyCat> When i use ghci load a .hs file, it suggestions me use `-XFlexibleContexts' for load, how add argument `-XFlexibleContexts` in ghci?
18:28:41 <ManateeLazyCat> ghci -XFlexibleContexts
18:30:49 <wli> roconnor: I think I've figured out how to handle Jacobian elliptic functions and other things definable via finite systems of first-order differential equations linear in their differentiated terms and polynomial otherwise, though it turns out to be pretty dumb not to have seen it (far) earlier on my part.
18:32:18 <wli> roconnor: Basically all of the divisibility considerations surrounding decompositions of denominators into special parts and squarefree factorizations of normal factors go straight through when done via Grobner bases in the multivariate setting, and there isn't really even much to think about.
18:34:12 <wli> roconnor: Bessel functions look like they create a need for on-the-fly usage of the algebraic differential relations, though, since they're basically an infinite first-order system of that kind.
18:39:14 * ManateeLazyCat pasted "my code" at http://paste2.org/get/185549
18:39:15 <ManateeLazyCat> Have a better solution to make above code more simpler?
18:41:07 <kerlo> I wish GHC had a -fuse-theorem-prover-to-resolve-insane-instance-declarations option.
18:43:13 <gnuvince_> Has anyone read this monad article: http://ertes.de/articles/monads.html ?  I'm a bit confused by the definition of "computation".  For instance, the author writes: "In the Maybe monad, Just x is a computation, which results in x."  Can anyone clarify the language?
18:43:48 <skiix> dont you hate when your fucking a girl in the ass and she is like "stop! stop! I'm only 13"..just happened to me. That is the last time I fuck my sister.
18:44:26 <jmcarthur> spambot?
18:44:53 <bremner> troll
18:45:12 <ManateeLazyCat> gnuvince_: case condition of Nothing -> ... Just x -> ....
18:45:12 <jmcarthur> yeah, more likely
18:45:25 <Apocalisp> @ops trollbot
18:45:25 <lambdabot> Maybe you meant: docs oeis pl
18:45:43 <jmcarthur> @where ops
18:45:43 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
18:45:43 <lambdabot> mauke
18:45:47 <gnuvince_> ManateeLazyCat: so computation in this instance means when you extract the inner value?
18:45:47 <Apocalisp> ah
18:45:51 <lolz> stop being a bitch
18:46:00 <jmcarthur> Apocalisp: yeah, i always forget it too
18:46:39 <ManateeLazyCat> gnuvince_: If you function return Maybe `A`, you can write function body like this: if condition then return Nothing else return (Just A)
18:47:26 <ManateeLazyCat> gnuvince_: A mean type, not exact value, Haskell just computation it's value when need.
18:47:31 <ManateeLazyCat> `A`
18:48:32 <gnuvince_> the returns would not be there, otherwise that'd be (Monad m) => a -> m (Maybe a)
18:51:06 <ManateeLazyCat> > :t fromJust
18:51:07 <lambdabot>   <no location info>: parse error on input `:'
18:55:30 <ManateeLazyCat> gnuvince_: Example, I have variable `a`, and a's type is Maybe A, i want print the value of `a`, i can write: "case a of Just v -> print v".
18:56:00 <gnuvince_> I know that
18:56:17 <gnuvince_> What I don't understand is the choice of the word "computation"
18:56:19 <ManateeLazyCat> gnuvince_: So v is contain result that you want.
18:56:32 <gnuvince_> To me, Just x is a computation that returns x wrapped inside a Maybe container.
18:56:45 <gnuvince_> Which is not what the author is saying
18:57:15 <bremner> gnuvince: if Just x is an "action", what "runs" it?
18:57:38 <tromp> :t maybe
18:57:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:57:52 <ManateeLazyCat> :t fromJust
18:57:52 <lambdabot> forall a. Maybe a -> a
18:58:16 <gnuvince_> bremner: I'm not sure I follow
18:59:20 <bremner> I'm probably not the best person to explain it. but, in general one way of thinking of monads is a sequence of actions; at some point these are run, and something pops out.
19:00:22 <ManateeLazyCat> gnuvince_: I'm not expert too, but IMO, i think `Just` is a syntax character for pattern match with Maybe moand.
19:01:13 <ManateeLazyCat> gnuvince_: `Just` relative to `Nothing` in Maybe moand.
19:01:17 <bremner> gnuvince_: I'm sure there are many references, but the one I am thinking about is Real World Haskell chapter 14
19:01:35 <ManateeLazyCat> gnuvince_: Or a book "All about Monads"
19:02:16 <sebaseba> > maybe 0 (+1) (Just 5)
19:02:17 <lambdabot>   6
19:02:30 <sebaseba> maybe 0 (+1) Nothing
19:02:37 <sebaseba> > maybe 0 (+1) (Just 5)
19:02:38 <lambdabot>   6
19:02:45 <sebaseba> > maybe 0 (+1) Nothing
19:02:46 <lambdabot>   0
19:03:32 <gnuvince_> bremner: so we can say that Just x is a computation that yields x, because the ultimate goal of have x inside Just is to get access to x?
19:03:37 <gnuvince_> Do I get this right?
19:04:07 <bremner> gnuvince_: I would read "computation = action = monadic value" here
19:04:48 <bremner> but did you sebaseba's examples?
19:05:00 <bremner> see them even
19:05:07 <gnuvince_> I posted the question in the comment thread on reddit, hopefully the author replies there.
19:05:10 <gnuvince_> bremner: yes I did.
19:05:27 <sebaseba> > map Just [1..5]
19:05:27 <bremner> maybe is the "runner" here
19:05:28 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
19:05:40 <lolzz> reddit more like mostliberalplaceever.com am i right?
19:07:53 <roconnor> @src Maybe
19:07:54 <lambdabot> data Maybe a = Nothing | Just a
19:08:53 <sebaseba> > fmap (+1) (Just 41)
19:08:54 <lambdabot>   Just 42
19:09:03 <sebaseba> > fmap (+1) Nothing
19:09:04 <lambdabot>   Nothing
19:10:01 <sebaseba> @quote
19:10:01 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
19:10:43 <roconnor> no no, it's python on planes
19:10:56 <centrinia> ASP on planes.
19:11:03 <centrinia> Corba on planes.
19:11:53 <roconnor> python has the illiteration going for it
19:12:12 <orbitz> <3 illiteration
19:12:21 <gnuvince_> illiteration?  Isn't it aliteration?
19:12:27 * orbitz irssi is dieing :(
19:12:30 <roconnor> probably
19:12:30 <gnuvince_> Or am I confusing with the French word?
19:12:32 <centrinia> Illiteration is the state of being illiterate. :)
19:12:36 <orbitz> gnuvince_: don't ruin it!
19:12:51 <omnihil> which some people may say is appropriate for python
19:13:04 <roconnor> alliteration
19:13:12 <roconnor> python has the alliteration going for it
19:13:57 <sebaseba> python pie
19:14:55 <jmcarthur> actually, a plane was grounded yesterday because there were loose snakes on it...
19:15:00 <jmcarthur> no joke
19:15:15 <jmcarthur> i think they were pythons, even...
19:15:21 <orbitz> lies
19:15:24 <orbitz> pix or gtfo
19:15:32 <monochrom> hahahahaha
19:15:47 <jmcarthur> http://news.bbc.co.uk/1/hi/world/asia-pacific/8001644.stm
19:15:50 <sebaseba> they feared runtime errors so the plane was grounded?
19:17:19 <sebaseba> fumigated python on plane
19:17:30 <monochrom> At least it didn't crash like programs do.
19:20:26 <PetRat> I'm a newbie, and not sure how to use Parsec to parse a file like the following: it contains keywords which are indicated by a double-forward-slash, and text in-between the keywords. I want to find each keyword and the text between it and the next keyword: http://www.mibbit.com/pb/QUAatZ
19:21:31 <andresj> hello, what function has the type signature :: forall a. [a] -> (a,a) (and allows to specify default values for the tuple)
19:21:52 <andresj> so the function would be :: [a] -> a -> a -> (a,a)
19:21:59 <andresj> or :: [a] -> (a, a) -> (a,a)
19:22:09 <kpreid> andresj: most likely the one you write yourself
19:22:30 <andresj> hahaha ok just making sure i dont reinvent the wheel :P thank you :)
19:22:56 <centrinia> :t \xs a b -> if length xs < 2 then (a,b) else (head xs, head (tail xs))
19:22:58 <lambdabot> forall a. [a] -> a -> a -> (a, a)
19:23:20 <andresj> haha thank you centrinia :)
19:23:23 <kpreid> @hoogle [a] -> Maybe a
19:23:24 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
19:23:24 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:23:24 <lambdabot> Prelude head :: [a] -> a
19:23:36 <kpreid> @hoogle a -> Maybe a -> a
19:23:36 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
19:23:36 <lambdabot> Prelude asTypeOf :: a -> a -> a
19:23:36 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
19:23:54 <PetRat> bump: I'm a newbie, and not sure how to use Parsec to parse a file like the following: it contains keywords which are indicated by a double-forward-slash, and text in-between the keywords. I want to find each keyword and the text between it and the next keyword: http://www.mibbit.com/pb/QUAatZ
19:24:07 <monochrom> \ xs d0 d1 -> case xs of _:_:x:_:_:y:_ -> (y,x) ; _ -> (d0,d1)
19:24:36 <matthewp> Hacking for the Real World Haskell book club on Collective Intelligence: http://gist.github.com/96799
19:25:34 <A1kmm> Hi, does anyone know of any existing packages or code which can compute the digamma function in Haskell? I haven't been able to find anything with Hayoo!.
19:29:22 <PetRat> bump: I'm a newbie, and not sure how to use Parsec to parse a file like the following: it contains keywords which are indicated by a double-forward-slash, and text in-between the keywords. I want to find each keyword and the text between it and the next keyword: http://www.mibbit.com/pb/QUAatZ
19:31:15 <centrinia> PetRat, would anything that starts with two slashes followed by letters, digits, and underscores be considered to be a keyword?
19:31:51 <PetRat> centrinia: yes
19:32:01 <A1kmm> Actually I found the answer... it turns out GSL calls digamma psi, and the Numeric.GSL.Special documentation doesn't mention digamma at all.
19:32:11 <PetRat> centrinia: altough you could start by assuming only letters are valid, just to give me the idea what to do
19:32:36 <PetRat> I mean two slashes followed by a word made of letters
19:35:43 <centrinia> PetRat, Write a keyword parser that accepts the string "//" followed by many1 letter: parseKeyword = string ">>" >> many1 letter
19:37:02 <centrinia> Write a regular text parser that accepts sequences of letters: parseText = many1 letter
19:37:40 <PetRat>  Okay I'm testing it now...
19:41:47 <sebaseba> @quote
19:41:48 <lambdabot> qwern says: I made so many compilation errors because I can't spell lambdab right
19:44:31 <PetRat> Update on parser question: http://www.mibbit.com/pb/WNMjtd
19:47:51 <PetRat> Update on parser question: http://www.mibbit.com/pb/WNMjtd
19:48:19 <sebaseba> Peaker: how are you running parseFile?
19:48:25 <gwern> @forget qwern says: I made so many compilation errors because I can't spell lambdab right
19:48:25 <lambdabot> No match.
19:48:34 <gwern> @forget qwern I made so many compilation errors because I can't spell lambdab right
19:48:34 <lambdabot> Done.
19:48:40 <gwern> @remember gwern I made so many compilation errors because I can't spell lambdab right
19:48:40 <lambdabot> I will remember.
19:48:51 <gwern> @quote qwern
19:48:52 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:49:00 <gwern> @flush
19:49:19 <andresj> lol
19:50:43 <sebaseba> sorry
19:50:49 <sebaseba> PetRat: how are you running parseFile?
19:51:45 <PetRat> Some code I got from the Parsec user manual: http://www.mibbit.com/pb/eOkS91
19:52:54 <PetRat> Oops I logged out. Did I miss something?
19:53:32 <sebaseba> no
19:53:55 <sebaseba> PetRat: try running with this code --> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3861#a3861
19:54:36 <andresj> wow netsplit
19:54:40 <sebaseba> or    parse parseFile "" "//test1234//foo9876"
19:55:59 <PetRat> that works better - I get both keywords [("test","1234"),("foo","9876")]
19:59:12 <PetRat> sebaseba --- I'm not sure how to work your method into the IO monad-- this doesn't work: http://www.mibbit.com/pb/PYTwKt
19:59:36 <sebaseba> PetRat: what is the type of parse?
20:00:57 <PetRat> So now, how do I account for spaces and special characters occurring between the keywords? ... hang on: sebaseba: it yields Either ParseError a. That's my problem.
20:01:46 <sebaseba> PetRat: no, the thing is, parse is not an IO action. therefore, you can't use it that way.
20:03:41 <PetRat> sebaseba: more details: http://www.mibbit.com/pb/R8cywe
20:04:24 <sebaseba> PetRat: exactly, runLex is an IO action, that's why it worked
20:06:02 <PetRat> sebaseba: but run is an IO action as well, and using run by itself didn't work properly.. didn't go to the end of the file. Only when I wrap run in runLex does it work.
20:06:11 <PetRat> Not sure why...
20:06:53 <sebaseba> let's see what that eof parser does
20:08:13 <PetRat> It's built-in to the Parsec module. I don't really know what it does. Did you suggest it?
20:08:44 <PetRat> It was your suggestion, here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3861#a3861
20:09:16 <sebaseba> PetRat: this pdf should come in handy http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec-letter.pdf
20:10:08 <PetRat> Hi sebaseba, actually I've read the first half of that, but I don't feel my understanding is very deep, so my particular problem stumped me.
20:10:22 <sebaseba> on page 14, at the part where it says "Finally, the run function will be adapted...", it explains what eof does
20:10:59 <sebaseba> "This parser guarantees that all input will be parsed; if it is left out, a parser is allowed to parse only part of the input."
20:12:07 <PetRat> Well that makes sense. I don't see that on page 14, though. But I get it.. the parser is allowed to parse only part of the input.
20:13:25 <sebaseba_> PetRat: so if you just use run, which doesn't use eof, the parseFile stops after finding the minimum acceptable string.
20:13:33 <PetRat> The thing is, what I would really like to do is find all characters (whether letter, digit, or special character, or whitespace) that occur between the keywords, It seems almost easier to tell it what NOT to accept as "ordinary text"... specifically anything that starts with a double-slash
20:14:49 <PetRat> Yes, I didn't realize it was allowed to stop after the minimum acceptable string. I guess that it handy behavior when you are parsing constructs within the file. For example, matches braces. But when you want the whole file, you have to force it.
20:15:50 <sebaseba_> That confused me as well.
20:16:08 <sebaseba_> as for the double-slash, you will probably have to use "try"
20:16:31 <sebaseba_> because a single slash is allowed as normal text, but not a double one... right?
20:17:01 <PetRat> correct
20:36:26 <josh> anyone familiar with geordi?
20:45:39 <sebaseba_> PetRat: this might help http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3863#a3863
20:51:08 * wli takes a naive potshot at sudoku.
21:12:00 <twb> I'm trying to translate a regex-based parser into parsec.
21:12:38 <twb> How do you cope with cases where the parser has said something like "this lexeme only occurs if preceded by a non-letter"
21:12:50 <twb> i.e. "look-behind"
21:26:35 <QtPlaty[HireMe]> Is parsec bottem up or top down?
21:29:30 <wli> It seems to solve newspaper sudoku puzzles in a second or two.
21:30:09 <Axman6> wli: not bad. tried any of the really hard ones?
21:30:28 <wli> Axman6: Not yet.
21:32:27 <Axman6> wli: what about binary sudoku?
21:32:28 <Axman6> -----
21:32:28 <Axman6> |1| |
21:32:28 <Axman6> -----
21:32:30 <Axman6> | |1|
21:32:33 <Axman6> -----
21:32:35 <Axman6> >_>
21:34:05 <wli> Trying a hard one.
21:38:09 <wli> Axman6: No discernible difference in running time. I suspect the 9x9 search space is too small to really stress things.
21:38:20 <Axman6> yeah
21:38:26 <Axman6> well, nice work :)
21:38:47 <dolio> A lot of the ones on the wiki benchmark by solving hundreds in a single run.
21:39:09 <wli> Axman6: This is really stupid backtracking search.
21:39:20 <Axman6> yeah, that
21:39:29 <ddarius> Just time how long it takes to solve them all.
21:39:33 <wli> dolio: Yeah, it won't be remotely competitive. I'm just amazed I solved it at all.
21:39:42 <Axman6> that's how i'd do it too. and if it's fast enough, then there's no need to improve really
21:39:57 <wli> Or, rather, amazed that I managed to write a sudoku solver at all.
21:40:44 <wli> All of my prior attempts were either nonfunctional or performed extremely poorly on single 9x9 puzzles.
21:43:33 <wli> http://wli.pastebin.com/m1fe58767 <-- yes, it's that stupid
21:43:46 <josh> can someone tell me what line 154 means? http://codepad.org/dTX8GdtG
21:45:31 <Axman6> :t when
21:45:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:45:42 <Axman6> @src when
21:45:42 <lambdabot> when p s = if p then s else return ()
21:46:13 <Axman6> that code looks disgusting btw :(
21:46:26 <wli> Axman6: How so?
21:46:42 <Axman6> not your code, haven't looked at that yet :)
21:47:02 <josh> me?
21:47:44 <Axman6> yes
21:47:56 <orbitz> no you
21:48:17 <Axman6> wli: looks nice and short
21:48:25 <jmcarthur> woah that code is crazy!
21:49:08 <josh> Axman6: I'm trying to get that line to match a config value set in this file: http://codepad.org/o9vGENYU
21:49:11 * Axman6 dislikes underscores in function names in any laguage
21:49:14 <Axman6> language*
21:49:21 <josh> I can't seem to get the syntax in the config file correct
21:49:33 <josh> for join_trigger
21:50:07 <josh> I have to say that this is one of the most confusing languages I've ever tried to grok
21:50:18 <Axman6> i can see why
21:50:41 <Axman6> that code is crazy
21:51:29 <josh> I see the config data structure defined on line 29, and join_trigger is "Maybe IRC.Message"
21:51:42 <orbitz> josh: when is a function that appears to do something when a condition is met
21:52:11 <inimino> Axman6: you dislike underscores in identifiers generally or function names in particular?
21:52:24 <Axman6> identifiers generally
21:52:25 <josh> yes, I just don't know what to put in the config file to make that match happen
21:53:00 <orbitz> josh: if you are just learning haskell, this is poor code to learn off of
21:53:05 <josh> everything I've tried so far just bombs when it tries to read the config file in on line 89
21:53:06 <Axman6> josh: do you want it to be true when it's not Nothing? or do you want it to exactly match Just m?
21:53:59 <josh> I don't really want to learn haskell (at least not right now) I just don't know what to put in the config file for the value of join_trigger to make it evaluate correctly
21:54:37 <Axman6> well, it'll need to be Just m then
21:54:52 <orbitz> proabbly nothing since it says it defaulst sto RP_WELCOME
21:54:59 <Axman6> where m is the m passed to the function on_msg
21:55:16 <josh> m is an IRC.Message "object?" I guess
21:55:32 <Axman6> IRC.Message datatype, yes
21:56:04 <Axman6> but it has to be the same IRC.Message for == to return true
21:56:07 <josh> how do I define an instance of it in the config file for join_trigger
21:56:22 <Axman6> huh?
21:56:37 <josh> right now in the config file "join_trigger = Nothing"
21:56:55 <Axman6> yes
21:57:03 <Axman6> @src Maybe
21:57:03 <josh> I want join_trigger = ???my IRC.Message???
21:57:03 <lambdabot> data Maybe a = Nothing | Just a
21:57:52 <josh> I just want to define an IRC.Message in the config so that test will succeed
21:58:08 <josh> I don't know how to do that
21:59:00 <Axman6> neither do i, i can't find the definition of IRC.Message
21:59:57 <josh> Axman6: does this have it? http://codepad.org/groEki6s
22:00:38 <Axman6> yes... but...
22:01:09 <orbitz> no
22:01:26 <orbitz> josh: is RPL_WELCOME not working for you?
22:02:08 <orbitz> why are you futzign around with this code if you don't want to learn haskell?
22:02:20 <josh> :) I just want to run it
22:02:35 <Axman6> ok, try making join_trigger = Just (Message Nothing "" [])
22:02:44 <Axman6> or something
22:02:53 <Axman6> hell i don't know, that code is disgusting
22:02:57 <orbitz> josh: is your config file a haskell program too?
22:03:10 <Axman6> seems to be
22:03:24 <Axman6> or, a datatype that gets read
22:03:26 <josh> hey sweet
22:03:35 <josh> that evaluated
22:04:26 <Axman6> anyone who ca make haskell look like C++ should be shot
22:04:32 <orbitz> is this code in lambdabot?
22:04:33 <josh> orbitz: it looks like it is... on line 88 of my original paste it looks like the file is read in and evaluated
22:04:56 <josh> orbitz: this is geordi
22:05:01 <josh> C++ eval bot
22:05:02 <orbitz> ohhh
22:05:05 <orbitz> that expalins it
22:05:11 <orbitz> i thought eelis was better than this...
22:05:32 <josh> well, this may be an early piece of the code?
22:05:33 <Zao> An artifact of the IRC library used?
22:05:55 <Zao> If I recall correctly, the author of the irc module isn't him.
22:06:05 * orbitz shivers
22:06:12 <orbitz> Zao: i hope not
22:06:22 <josh> Zao: no http://codepad.org/dTX8GdtG
22:08:29 <ivanm> Axman6: what does C++ look like?
22:08:36 <Axman6> crap
22:08:52 <ivanm> hmmm.... I thought that was limited to Java... ;-)
22:09:15 <Axman6> i think java looks nicer than C++
22:09:59 <Cale> josh: Your screen is too wide ;)
22:10:21 <josh> Cale: why's that?
22:10:39 <Cale> josh: I'm just referring to how long some of the lines are in that paste :)
22:10:48 <josh> oh, not my code
22:10:52 <Cale> ah
22:10:58 <josh> but my screen is too wide
22:11:01 <josh> thanks for noticing
22:11:39 <wli> My wild guess is that my whole algorithm is retarded.
22:12:12 <wli> The data structures probably need a fair amount of bit twiddling to make efficient, but I can't be arsed.
22:12:57 <josh> What does Just mean?
22:13:15 <Zao> @src Just
22:13:16 <lambdabot> Source not found. Sorry.
22:13:25 <Zao> It's a constructor for the Maybe monad.
22:13:35 <Zao> @src Maybe
22:13:35 <lambdabot> data Maybe a = Nothing | Just a
22:15:23 <Axman6> josh: the Maybe datatype can either be Nothing, or Just _something_. it's a way of coding failure
22:15:24 <mpeter> time to construct civilization from scratch
22:15:26 <mpeter> who's gonna help
22:15:53 <josh> Axman6: that line you gave me worked
22:16:06 <Axman6> heh, i'm surprised
22:16:24 <josh> but how can I make just one or two of the data elements of Message match?
22:17:02 <josh> if I don't put the exact Message in the config file it won't match
22:17:11 <josh> and the IRC server is part of the message
22:17:36 <josh> when (join_trigger cfg == Just m) $ send $ join_msg cfg
22:19:02 <josh> what can "join_trigger" be so that this line executes when join_trigger only has 1 field that matches "m"
22:19:23 <mpeter> i have the solution to all of the world's problems in my head right now
22:19:26 <Axman6> can you give an example of what m could be? (if you know)
22:19:29 <mpeter> i'm not kidding in the slightest
22:19:33 <mpeter> i just need somebody who knows TCP/IP+haskell
22:19:35 <josh> Axman6: yes
22:19:49 <josh> (Message (Just (Server "pratchett.freenode.net")) "901" ["cpp3p0","josh","n=cpp3p0","www.6bit.com","You are now logged in. (id josh, username n=cpp3p0, hostname www.6bit.com)"])
22:20:23 <josh> Axman6: you gave me (Message Nothing "901" [])
22:20:26 <josh> err
22:20:33 <josh> you gave me (Message Nothing "" [])
22:20:50 <mpeter> what do you guys do all day anyway
22:20:53 <josh> I want to match just (Message Nothing "901" [])
22:20:53 <mpeter> do you get paid to write haskell
22:21:13 <josh> but have "Nothing" and "[]
22:21:22 <Axman6> then set the config to Message Nothing "901" []
22:21:25 <josh> " be any value in M
22:21:35 <Axman6> that's more difficult
22:21:59 <quicksilver> isGood (Message Nothing m []) = True
22:22:04 <josh> I figured :) and I don't want to change the source, just the config
22:22:05 <quicksilver> isGood _ = False
22:22:15 <quicksilver> when (isGood cfg) .....
22:24:04 <josh> oh well
22:24:14 <josh> I appreciate your help Axman6
22:24:36 <josh> this will work for tonight, I need to go home, my wife is freaking out while I try to learn haskell
22:25:36 <mpeter> tell her you're doing something good for humanity
22:25:41 <mpeter> that will calm her down
22:25:47 <mpeter> assuming you are, in fact
22:25:50 <mpeter> doing something good for humanity
22:26:11 <josh> I don't know if putting another IRC bot online is good for anyone
22:26:27 <Axman6> i thought you were trying not to learn haskell
22:26:36 <josh> well, its interesting
22:26:46 <josh> but I suck at math, so its probably hopeless
22:27:02 <Axman6> my suggestions though is, do not use that code as an example of what haskell should be like
22:27:08 <josh> I'm still trying to beat the meaning of a Vector Space into my head
22:27:52 * Axman6 knows he knew what a vector space was, but can't remember now
22:28:09 <josh> Axman6: alright, I started reading some guides linked from Wikipedia, it's a little too deep for a Cish language programmer to grok in one night
22:28:24 <Axman6> josh: check out lyah:
22:28:28 <Axman6> @where lyah
22:28:29 <lambdabot> www.learnyouahaskell.com
22:28:43 <josh> lol
22:28:49 <josh> thats some good artwork
22:28:58 <mpeter> check out 'haskell for c programmers'
22:29:00 <mpeter> as well
22:29:05 <mpeter> it seems rather tailored to you
22:29:15 <mpeter> @where hfcp
22:29:16 <lambdabot> I know nothing about hfcp.
22:29:19 <mpeter> stupid bot
22:29:33 <josh> @where yomomma
22:29:33 <lambdabot> I know nothing about yomomma.
22:29:49 <josh> I didn't think so
22:29:59 <mpeter> http://haskell.org/~pairwise/intro/intro.html
22:30:54 <josh> thanks guys, I'm sure I'll have more questions tomorrow
22:31:13 <mpeter> bookmark that, that's how i learned much of haskell
22:31:30 <josh> will do
23:05:49 <dibblego> where is Data.Time in 6.10.2?
23:06:04 <quicksilver> in the time package
23:06:09 <quicksilver> which you can download from hackage
23:06:12 <bos> gone. you have to install it by hand.
23:06:41 <dibblego> ok
23:07:24 <lupinthe3rd1> anyone on?
23:08:01 <lupinthe3rd1> ?
23:08:08 <quicksilver> dont ask to ask just ask
23:08:23 <lupinthe3rd1> huh?
23:08:46 <lupinthe3rd1> i want to get into programing
23:08:51 <lupinthe3rd1> how do i start?
23:08:55 <zimbatm> anyone got that when installing the unix package : Module `GHC.Conc' does not export `Signal'
23:09:36 <zimbatm> I think it's related to my version of GHC : 6.10.1
23:09:39 <lupinthe3rd1> someone told me to dl linux
23:09:44 <dibblego> what about Data.Time.Calendar?
23:09:48 <lupinthe3rd1> can some one help me out?
23:09:54 <quicksilver> lupinthe3rd1: this channel is for discussing haskell, a specific programming language.
23:10:07 <lupinthe3rd1> im sorry
23:10:17 <quicksilver> lupinthe3rd1: we can't help you install linux :)
23:10:40 <lupinthe3rd1> but should i thats what i want to know
23:10:48 <ivanm> lupinthe3rd1: you don't have to
23:10:56 <ivanm> many people program in windows, mac, etc.
23:11:08 <lupinthe3rd1> isnt it better then windows?
23:11:23 <ivanm> if people didn't program in windows, then 1) there won't be many programs for windows, and 2) no-one would buy VS
23:11:25 <lupinthe3rd1> thats what i keep hearing
23:11:29 <ivanm> lupinthe3rd1: I think so, but its subjective
23:11:33 <ivanm> each to their own, etc.
23:12:23 <lupinthe3rd1> how should i start learning to program?
23:12:57 <horms> having a (small) project that interests you helps
23:13:30 <horms> and then working on that project as you work through a book / tutorial on your language of choice can work out well
23:14:12 <lupinthe3rd1> oif i was to install linux would all my files in windows be lost?
23:14:25 <zimbatm> starting with a low-level language is not a bad idea either
23:14:27 <horms> it depends
23:16:31 <horms> zimbatm: yes, i agree. staring low gives you a good base
23:16:32 <lupinthe3rd1> what would be a low level
23:16:46 <lupinthe3rd1> ?
23:16:53 <horms> to my mind, C, because it is fairly close to th way hw works.
23:17:34 <horms> but this is a haskell channel, not a C channel
23:17:45 <zimbatm> yes C is a good start. It will be a bit more difficult, but you'll have a bigger reward later
23:18:01 <horms> so i should say something like: starting with haskell would also be interesting, though for different reasons
23:18:11 <lupinthe3rd1> im just asking for starting advice
23:18:23 <zimbatm> horms: but then he'll get spoiled
23:18:42 <horms> agreed
23:18:48 <lupinthe3rd1> huh?
23:19:19 <horms> haskell does a lot of things for you, C makes your work a lot harder. but that can be a good place to start
23:21:34 <lupinthe3rd1> so learn C first
23:21:34 <horms> yes, its a good starting point
23:23:22 <lupinthe3rd1> thanks
23:24:37 <zimbatm> see: http://www.youtube.com/watch?v=XHosLhPEN3k
23:24:37 <zimbatm> (Write in C song)
23:24:37 <quicksilver> to my mind haskell is a better starting point than C
23:24:47 <quicksilver> but I'm not aware of any tutorials based at the complete non-programmer
23:24:53 <quicksilver> so it's an untrodden path.
23:25:20 <quicksilver> if I were teaching programming to a bunch of undergrads I would try to persaude people to let me use haskell - but I'd have to write learning materials etc.
23:25:38 <horms> Yet Another Haskell Tutorial, might be ok
23:27:15 <Shimei> I would be interested in finding out if undergrads would find Haskell easier than Scheme at an intro level. Because it seems like undergrads complain about the syntax and not the actual concepts when it comes to scheme.
23:27:42 <quicksilver> Shimei: I think they'd find types hard. But then undergrads find types hard in Java too (which is the most common first language in UK universities)
23:28:02 <zimbatm> quicksilver: maybe to teach maths and algorithms, like scheme used to be.
23:28:03 <horms> when i was at uni, the first thing they taught us was Miranda (which iirc is close to haskell). many of us found that very tough going
23:29:16 <Shimei> quicksilver: That's surprising to me -- especially because OO/Java's advertising is that their type system is "more like the real world"
23:29:35 <Ralith> lol
23:29:39 <Shimei> I guess it does partly explain the popularity of dynamic languages.
23:29:46 <horms> is the real world a hierachy?
23:29:59 <Ralith> does the real world trigger segfaults?
23:30:00 <Axman6> hmm, that was a huge split for me
23:30:11 <horms> yeah, me too. though short
23:30:17 <zimbatm> Axman6: same
23:30:27 <Axman6> @users
23:30:27 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 13 (2.3%)
23:30:31 <QtPlaty[HireMe]> horms: Not in the east if the New Scientist is to be believed,
23:30:33 <quicksilver> Ralith: no but bus errors are fairly common :P
23:30:44 <Axman6> yeah, i had about 530 people split
23:30:52 <horms> QtPlaty[HireMe]: east = asia?
23:31:01 * Ralith dereferences quicksilver 
23:31:02 <QtPlaty[HireMe]> horms: Yes.
23:31:10 <Zao> quicksilver: x86 lacking misalignment punishment is a bit sad.
23:31:11 <horms> sounds like an interesting read
23:32:30 <dufflebunk> horms: they taught me Miranda and C at the same time in two different classes. It dissapointed me because you could do real stuff in it.
23:32:48 <QtPlaty[HireMe]> In what?
23:33:30 <horms> at the time, most of us felt C was useful, Miranda wasn't, and we'd rather spend time on the useful stuff.
23:33:39 <dufflebunk> in Miranda. I couldn't find any way of doing I/O
23:33:40 <QtPlaty[HireMe]> Badly tort miranda turned me off functional langauges.
23:34:03 <horms> yes, that was more or less my experience too.
23:34:14 <horms> i never touched functional again, until i recently started on haskell
23:35:32 <QtPlaty[HireMe]> I think haskell's key benifit from its predecessor is that it now has a good way to do I/O
23:35:46 <horms> yes, its useful :-)
23:36:04 <Saizan> Miranda didn't have a repl?
23:36:44 * QtPlaty[HireMe] also has finally got the joke in "Real World Haskell"'s title.
23:37:19 <Shimei> You mean the "code you can believe in" bit?
23:37:22 <QtPlaty[HireMe]> Saizan: It did.  But there is more to I/O then the reply.
23:37:39 <QtPlaty[HireMe]> Shimei: No, the real world bit.
23:38:54 <Saizan> QtPlaty[HireMe]: i realize, but i also guess the programs you'll do in your first undergraduate course will fit there
23:41:44 <QtPlaty[HireMe]> Saizan: Sure, but in my undergrad C based course I ended writing a network server.  In miranda I couldn't do anything nearly as satisfying.
23:42:37 <QtPlaty[HireMe]> Though I'm having alot of fun with haskell now.
