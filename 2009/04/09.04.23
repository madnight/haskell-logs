00:00:18 <bryan1> Elly: :)
00:00:18 <dolio> bryan1: Do they both eat memory?
00:00:24 <bryan1> dolio: yes.
00:00:55 <dolio> Oh, right, of course.
00:03:28 <dolio> bryan1: Well, the problem, I think, is that you're never looking at the things in your IORefs, so you just build up ever larger nested, delayed computations.
00:05:38 <dolio> bryan1: What happens if you change the write version to say "update `seq` writeIORef bloatRef update"?
00:05:52 <bryan1> dolio: I'll give that a shot.
00:06:14 <Ralith> :t seq
00:06:15 <lambdabot> forall a t. a -> t -> t
00:06:47 <bryan1> dolio: nope.. 1 GB in 2 secs.
00:07:23 <bryan1> hummmm..
00:09:29 <dolio> Are you sure? That fixes it here.
00:09:57 <bryan1> I'm checking again.. I didn't realize my typo.. even tho Elly pointed it out.
00:10:03 <dolio> :)
00:10:19 <bryan1> dolio: all better.. ty!
00:13:46 <dmead> hey guys
00:13:54 <dmead> does tail recusion work at all in ghc?
00:18:05 <sjanssen> dmead: yes
00:19:05 <dabblego> dmead, see foldl' for example
00:19:10 <dmead> ah
00:19:11 <dmead> tks
00:19:27 <dmead> what if i don't want an accumulator?
00:19:42 <dmead> do people use that to just do the tail elimation
00:19:49 <dmead> and put a dummy as the acc?
00:20:39 <QtPlaty[HireMe]> dmead: what do you mean.?
00:21:17 <dmead> i'm asking if theres a general construct for iteration, not just tail elimination
00:21:49 <Berengal> dmead: Recursion is the only way to loop in Haskell, but there are lots of functions that'll do the recursion for you
00:22:04 <dmead> such as?
00:22:14 <QtPlaty[HireMe]> dmead: You only need to worry about accumulators for recursion that accumulates.
00:22:27 <Berengal> map, foldr, filter, unfoldr, zipWith...
00:22:38 <dmead> map is tail elimated?
00:22:42 <dmead> ?src map
00:22:42 <lambdabot> map _ []     = []
00:22:42 <lambdabot> map f (x:xs) = f x : map f xs
00:22:45 <dmead> you sure about that?
00:22:55 <dmead> wait nm
00:22:56 <dmead> :P
00:23:13 <Berengal> Well, not really, but since Haskell is lazy it might as well have been
00:23:26 <QtPlaty[HireMe]> If it doesn't accumulate anything, then tail recursion isn't needed.
00:24:04 <Berengal> Tail recursion isn't quite the same in haskell as it is in strict languages
00:25:19 <Berengal> For example, foldl is tail recursive, but may still blow up the stack. map isn't tail recursive, but doesn't
00:26:09 <RayNbow> > foldl (+) 0 [1..10000000] -- this should do it... :p
00:26:17 <lambdabot>   mueval: Prelude.read: no parse
00:26:27 <Berengal> O_o
00:26:40 <RayNbow> oh silly lambdabot and your error messages... :p
00:26:46 <Badger> heh
00:26:55 <QtPlaty[HireMe]> > foldl (+) [1..100000]
00:26:58 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
00:26:59 <lambdabot>        arising from a use...
00:27:01 <Berengal> > maximum [1..10^6]
00:27:04 <lambdabot>   * Exception: stack overflow
00:27:10 <Berengal> ?src maximum
00:27:10 <lambdabot> maximum [] = undefined
00:27:10 <lambdabot> maximum xs = foldl1 max xs
00:27:27 <Berengal> There we go, foldl blowing up the stack...
00:27:48 <Berengal> last . map (*2) $ [1..10^6]
00:28:14 <Berengal> > last . map (*2) $ [1..10^6]
00:28:15 <lambdabot>   2000000
00:28:28 <RayNbow> > let maxi xs = foldl1' max xs in maxi [1..10^6]
00:28:30 <lambdabot>   1000000
00:28:38 <RayNbow> strict folds <3
00:28:39 <Gracenotes> Berengal: actually, that wouldn't happen in a compiled file
00:28:57 <Gracenotes> two rules are provided, "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int); and "maximumInteger" maximum = (strictMaximum :: [Integer] -> Integer)
00:29:09 <Berengal> Gracenotes: You're talking about the specialization on ints?
00:29:11 <Berengal> right
00:29:33 <Gracenotes> yeah. Sort of a hack (not to rely on it or anything), but unstrictness is a problem still
00:29:40 <Gracenotes> for large stuffs.
00:30:14 <Berengal> Strictness can be a problem, as demonstrated by exactly foldl and map
00:30:28 <Berengal> lazyness makes foldl, a tail-recursive function, blow up the stack
00:30:40 <Berengal> It also makes map, a non-tail-recursive function, work just fine
00:30:59 <Gracenotes> mm
00:31:10 <Gracenotes> which has a partial result
00:31:32 <Berengal> hm?
00:32:01 <RayNbow> recursion in map is guarded by a constructor
00:32:12 <Gracenotes> well, just noting, map can be lazily retrieved due to the :
00:32:21 <Gracenotes> but that's a different story too
00:32:48 <Gracenotes> you could get a partial result from a folding sum if you used Zero | Succ Nat :P but only foldr, probably
00:33:15 <Berengal> Well, that's part of the point. If we were in a strict language, we'd have to evaluate the entire recursion chain before we got to calling the first constructor.
00:34:17 <Berengal> But because we're in a lazy language, we get the first constructor first, and can evaluate the rest of the call at our leisure, without blowing up the stack
00:36:22 <twb> How do I get /dev/null as a Handle?
00:37:08 <glguy> openBinaryFile
00:37:37 <twb> glguy: I can't assume /dev/null exists, though, surely?
00:37:44 <twb> On account of Windows
00:38:34 <sjanssen> does Windows have such a thing?
00:38:35 <glguy> Oh, I don't use Windows for anything but games
00:39:19 <koala_man> if it doesn't exist, how are you going to have a handle to it?
00:39:20 <twb> What I'm actually trying to do is run "dist/build/darcs/darcs help manpage >dist/build/doc/darcs.1" without resorting to `system`.
00:40:41 <sjanssen> twb: use runProcess?
00:40:47 <twb> sjanssen: that's what I'm doing.
00:41:02 <twb> sjanssen: but stdin should not be used for the child process.  The child's stdin should be EOF
00:41:13 <sjanssen> twb: is that strictly necessary?
00:41:20 <twb> Ideologically, yes.
00:41:39 <twb> If something goes wrong, the child Darcs process should not be consuming input intended for ./Setup.
00:41:43 <sjanssen> I'm not sure how to do it platform-independently
00:41:52 <twb> I'll use /dev/null for now
00:42:08 <glguy> which ideology is that?
00:42:22 <twb> glguy: the church of DTRT
00:42:28 <sjanssen> twb: you could open an empty file
00:43:10 <twb> runProcess says it immediately closes any handle you pass it, too
00:43:15 <RayNbow> Windows has the special NUL file
00:43:20 <RayNbow> in every directory
00:43:22 <twb> Which makes me kinda scared about leaving stderr unchanged.
00:43:32 <twb> RayNbow: wow, that's painful.
00:43:35 <sjanssen> twb: can you use the new createProcess function?
00:43:42 <twb> sjanssen: dunno.
00:43:44 <RayNbow> twb: it's a DOS relic :p
00:43:47 <sjanssen> it will create a pipe for you, which you could subsequently close
00:43:56 <RayNbow> Windows also has a PRN, CON, AUX, etc. file in every directory :p
00:43:58 <sjanssen> twb: well, what versions of GHC do you need to be compatible with?
00:44:15 <twb> sjanssen: I don't know :-)  >= 6.6, I think.
00:44:30 <sjanssen> twb: createProcess is not an option in that case
00:44:35 <sjanssen> it's new in 6.10
00:44:58 <p_l> RayNbow: that's a NUL device file in the root namespace, rather ;-)
00:45:21 <RayNbow> p_l: oh, okay :)
00:46:23 <p_l> it probably maps into something like \\.\NUL or similar on NT...
00:47:34 <RayNbow> \\.\NUL seems to work
00:48:16 <RayNbow> heh...
00:48:18 <RayNbow> C:\>echo foo > c:\nonexisting\CON
00:48:18 <RayNbow> foo
00:48:22 <RayNbow> :p
00:49:11 <p_l> RayNbow: this being CMD.EXE, I'm not sure how exactly it would translate the paths :)
00:49:20 <RayNbow> oh right
00:49:32 <RayNbow> but I'm too lazy to try something else now :p
00:49:44 <RayNbow> (and I got a train to catch)
00:50:09 <p_l> and I think 'CON' was on list of restricted filenames, cause opening the file in working directory with that name would give you the root CON file..
00:50:39 * RayNbow nods
00:50:45 <RayNbow> anyway, gtg :)
00:51:05 <p_l> cya
00:51:09 <RayNbow> laters :)
01:06:24 <poucet> Heh, this blows your mind: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
01:16:55 <Berengal> poucet: Wow...
01:46:11 <eu-prleu-peupeu> hello haskell ppl
01:46:51 <eu-prleu-peupeu> anyone here can give me a hand in reactive ?
01:47:41 <Lemmih> Yes, but you need to send me a signal first.
01:47:52 <Berengal> You got signal?
01:48:29 <eu-prleu-peupeu> signal ?
01:48:37 <Berengal> Someone set up you the bomb?
01:48:56 <Lemmih> eu-prleu-peupeu: I was joking. I don't really know anything about reactive.
01:49:05 <eu-prleu-peupeu> ahah
01:49:09 <eu-prleu-peupeu> its an event :)
01:52:45 <quicksilver> eu-prleu-peupeu: somewhat, perhaps.
01:52:57 <quicksilver> eu-prleu-peupeu: I can help you with concepts at least
01:53:04 <quicksilver> not the implementation details of conal's implementation, which I haven't used.
01:53:22 <eu-prleu-peupeu> hmm
01:54:17 <eu-prleu-peupeu> im having some running problems with reactive glut, ill look at the source code of it
02:00:08 <SubStack> wow, there's a reactive glut
02:05:22 <cjs> How can I tell, given two values of a type that has multiple value constructors, if they were constructed with the same constructor, when I don't otherwise care what the constructor is?
02:06:32 <dabblego> cjs, pattern matching
02:06:49 <cjs> Oof. So basically, I need to list all the constructors.
02:09:00 <cjs> I had hoped that there was some more clever way to do it.
02:09:53 <dmead> cjs that IS pattern matching
02:10:09 <dmead> you could just list the constructors you're interested in
02:10:15 <dmead> and throw away the others with _
02:11:13 <cjs> I'm interested in all of them. Basically, values of, say, A_Int32 17 and A_Int32 19 have the same type, but values of A_Int32 17 and anything not constructed with A_Int32 don't match.
02:11:29 <doserj> cjs, if you can derive Data, you can do toConstr x == toConstr y
02:13:28 <cjs> Mmm. Or I could just cons up a silly little equation that does a single pattern match to map types to Ints, which is probably easier and faster.
02:14:32 <xrfang> @src map
02:14:32 <lambdabot> map _ []     = []
02:14:33 <lambdabot> map f (x:xs) = f x : map f xs
02:17:19 <xrfang> hi, how can I "read" the type of a function? I get confused. for example, if I write :t foldl, it says:
02:17:20 <xrfang> foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
02:17:27 <xrfang> too many "->"s
02:17:48 <BONUS> well
02:17:58 <BONUS> if you have a -> b -> c
02:18:11 <BONUS> you can for starters think of it as: it takes an a and a b, and returns a c
02:18:23 <BONUS> the last -> is before the return value
02:18:25 <Axman6> it takes a function, which takes argument of type a and b, and returns an a, an initial a, a list of b's and returns an a
02:18:33 <xrfang> ok
02:18:42 <xrfang> for foldl,
02:18:56 <xrfang> forall a b,
02:19:03 <xrfang> (a -> b -> a) is a function
02:19:28 <xrfang> it says it takes an "a" and a "b", return an "a".
02:19:55 <xrfang> then the foldl takes such a function, and an "a" and a "[b]", then return an "a", right?
02:20:00 <Axman6> somthing sort of like: A func(A f(A x,B y), A init, B * bs) in C (though that's not really C syntax)
02:20:36 <Axman6> > foldl (flip const) 0 [1..10]
02:20:37 <lambdabot>   10
02:20:42 <Axman6> > foldl (const) 0 [1..10]
02:20:43 <lambdabot>   0
02:20:58 <Axman6> semi safe last...
02:20:59 <Axman6> anyway
02:21:10 <xrfang> quite interesting, how does lambdabot knwo it should respond?
02:21:20 <Zao> xrfang: > and @
02:21:35 <Axman6> > text "the > makes me do my magic"
02:21:36 <lambdabot>   the > makes me do my magic
02:21:49 <xrfang> ok... :) generally speaking in a type response, a -> b -> c -> d....
02:22:05 <xrfang> only the last type is the result type, all previous types are considered params of the function, right?
02:22:14 <Axman6> yep
02:22:20 <xrfang> thanks Axman6
02:22:32 <Axman6> xrfang: want to get slightly more technical?
02:22:50 <xrfang> no, I want it slightly DE-MISTIFIED :)
02:22:52 <xrfang> for this
02:22:54 <Axman6> what i mean by that is, that all functions only accept a single parameter
02:22:56 <xrfang> for example forall
02:22:59 <xrfang> forall a b
02:23:02 <xrfang> what is that?
02:23:16 <xrfang> oh yes I read about this is called the lambda calculus
02:23:20 <Axman6> just means that for any a and b tyles
02:23:22 <Axman6> types*
02:23:42 <Axman6> you can ignore the forall stuff though
02:23:53 <xrfang> in Haskell like I have learned erlang before (only about 2 months), the things that most confuse me is really strange use of symbols
02:24:11 <Axman6> you'll get used to them
02:24:24 <xrfang> if it is keywords, function names, then no problem, but if it is <-, ->, =>, | etc, this is cryptic and terrifying :)
02:25:14 <Axman6> like i said, you'll get used to them ;)
02:25:41 <xrfang> for foldl, if I am writing the return of :t I would suggest  something like ((a, b => a), a, b) => a, i.e. use , to separate params and => to indicate return value...
02:25:55 <Axman6> > (,) <$> [1..5] <*> [11..15]
02:25:56 <lambdabot>   [(1,11),(1,12),(1,13),(1,14),(1,15),(2,11),(2,12),(2,13),(2,14),(2,15),(3,1...
02:26:11 <xrfang> thanks godness
02:26:16 <xrfang> what is <$> above?
02:26:21 <xrfang> and <*>
02:26:24 <Axman6> it's fmap
02:26:29 <xrfang> I presume (,) is a function
02:26:29 <Axman6> and <*> is ap
02:26:33 <Axman6> yep
02:26:35 <xrfang> but I don't know what is the rest
02:26:37 <Axman6> :t (,)
02:26:39 <lambdabot> forall a b. a -> b -> (a, b)
02:27:01 <Axman6> yeah, i was just domonstrating how cryptic haskell can be if you're not used to it
02:27:16 <gueux> hi
02:27:27 <gueux> how can I get "Control.Exception.Extensible"?
02:27:39 <xrfang> thanks Axman6, continue reading...
02:27:51 <Axman6> xrfang: the thing is, that you can't really use something like (a,b => c) because the function is actually a -> (b -> c)
02:28:00 <gueux> I wanted to use Control.OldException, but someone told me to use this unstead
02:28:08 <gueux> -u+i
02:28:09 <Axman6> so, it takes an a, and returns a function that takes a b and returns a c
02:28:14 <ivanm> gueux: which version of ghc do you have?
02:28:20 <xrfang> why
02:28:24 <xrfang> oh!
02:28:25 <xrfang> yes
02:28:36 <gueux> ivanm: 6.8.2
02:28:46 <Axman6> a -> b -> c -> d --> a -> (b -> (c -> d))
02:28:49 <doserj> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
02:28:52 <ivanm> gueux: in that case, get the extensible-exceptions package
02:28:56 <ivanm> which doserj just linked to ;-)
02:29:03 <xrfang> :S...
02:29:29 <Axman6> a -> b -> c -> d is actually a -> (b -> (c -> d)) (to reduce the line noise :P)
02:29:43 <gueux> is there a debian package?
02:29:46 <BONUS> > (max 3) 4
02:29:48 <lambdabot>   4
02:29:55 <ivanm> gueux: no idea, have a look
02:29:58 <Axman6> :t (max 3)
02:29:59 <lambdabot> forall t. (Ord t, Num t) => t -> t
02:30:04 <gueux> ok
02:30:05 <ivanm> otherwise, use cabal-install
02:30:05 <BONUS> basically a -> b -> c says that it's a function that takes an a and returns a b -> c
02:30:12 <BONUS> that's currying
02:30:23 <BONUS> and that's why you can partially apply functions just by giving them too few parameters
02:30:30 <BONUS> > map (max 3) [1,2,3,4,5,6]
02:30:31 <lambdabot>   [3,3,3,4,5,6]
02:30:55 <BONUS> the expression max 3 is a function that takes one number and returns either 3 or that number, depending on which is bigger
02:31:52 <xrfang> can I get a detailed explanation of a function (not just its src) from lambdabot?
02:32:07 <dabblego> you can get its type with @type
02:32:10 <dabblego> @type max 3
02:32:11 <lambdabot> forall t. (Ord t, Num t) => t -> t
02:32:51 <BONUS> src is the most detailed explanation, really. you mean like more general, like what it does?
02:33:14 <xrfang> right
02:33:19 <BONUS> look at the GHC docs
02:33:27 <xrfang> sure :)
02:33:31 <BONUS> http://www.haskell.org/ghc/docs/latest/html/libraries/
02:33:44 <BONUS> this is a very good source, you can spend hours there just browsing and learning
02:34:27 * Axman6 uses his local copy
02:34:44 <BONUS> me too
02:34:51 <gueux> mmh I installed extensible-exception but my file does not compile... is it possible to install Control.OldException?
02:35:04 <gueux> I can't find it on cabal
02:35:31 <ivanm> gueux: with ghc 6.8.2, there's no need to
02:35:48 <ivanm> except it's not called OldException
02:35:55 <xrfang> > :t \x y z -> (x, y:z:[])
02:35:56 <lambdabot>   <no location info>: parse error on input `:'
02:36:00 <ivanm> ghc 6.10 calls it that, because it was replaced with extensible-exceptions
02:36:06 <ivanm> xrfang: no ">" if you want the type
02:36:14 <ivanm> :t \ x y z -> (x, y:z:[])
02:36:16 <lambdabot> forall t a. t -> a -> a -> (t, [a])
02:36:16 <gueux> mmh, ok
02:36:17 <xrfang> :t \x y z -> (x, y:z:[])
02:36:18 <lambdabot> forall t a. t -> a -> a -> (t, [a])
02:36:25 <gueux> so, I just have to comment it
02:36:26 <ivanm> @type \ x y z -> (x, y:z:[]) -- alternative
02:36:27 <lambdabot> forall t a. t -> a -> a -> (t, [a])
02:36:34 <xrfang> alright ivanm, that's confusion for me too
02:36:45 <xrfang> why it says forall t a. t?
02:36:48 <xrfang> specifically
02:36:59 <xrfang> why there are 2 t, and why there is a . after "a"?
02:37:09 <xrfang> I presume it should give forall a b c...
02:37:29 <ivanm> xrfang: ignore the forall
02:37:41 <Axman6> well no, the second and third arguments need to be the same type
02:37:42 <ivanm> "forall t a." means that it works for any types t and a
02:37:51 <ivanm> the actual type is "t -> a -> a -> (t, [a])
02:37:52 <ivanm> "
02:38:36 <xrfang> ok, got it, it is not "forall t a. t", but "forall t a" the . is a fullstop ? :)
02:38:54 <ivanm> yes
02:39:06 <xrfang> tks ivanm
02:39:13 <gueux> ok, thanks
02:39:14 <ivanm> no worries
02:41:26 <xrfang> :t \x -> x + 5
02:41:27 <lambdabot> forall a. (Num a) => a -> a
02:41:41 <xrfang> alright, what is the (Num a) => here?
02:41:50 <xrfang> meaning of "=>" please
02:41:56 <Axman6> it means that the a has to be an instance of the Num class
02:42:16 <Berengal> You can read => as "constraints stop here. Type signature follows"
02:42:24 <Axman6> so, that function is the function which can take any Num instance and add 5 to it
02:42:29 <xrfang> thanks, so => is only used in return of :t command, or it is a language symbol?
02:42:30 <ivanm> xrfang: basically, it works for numeric type
02:42:35 <ivanm> xrfang: only for types
02:42:36 <McManiaC> hey, is there a way to avoid "exceptions" and force them to be Either or sth? so my program wont die once I hit an exception in IO
02:42:45 <ivanm> to seperate the classes from the actual types themselves
02:42:47 <xrfang> I understand these, but I don't understand the symbols used here.
02:42:48 <Axman6> xrfang: it's a lanfuage symbol
02:42:56 <ivanm> McManiaC: you'd need to wrap it...
02:43:00 <ivanm> so no, not by default AFAIK
02:43:06 <xrfang> ok, so => can actually be used in haskell program? what is its meaning?
02:43:17 <Axman6> yes
02:43:21 <xrfang> if I want a number shouldn't I write x::Num?
02:43:33 <Axman6> it means that a has to be an instance of the class Num
02:43:33 <opqdonut> xrfang: no, x :: Num a => a
02:43:34 <daf> Num is not a type
02:43:54 <Berengal> You can't have => as a name, I think...
02:44:05 <xrfang> x ::  Num a => a, what is the meaning ?
02:44:08 <Berengal> > let (=>) = (+) in 5 => 5
02:44:09 <scook0> "x can have any type, as long as that type is a member of typeclass Num"
02:44:09 <lambdabot>   <no location info>: parse error on input `=>'
02:44:13 <Axman6> you can have (Ord a, Num a) => a -> a, which would mean that whatever a is, it has to be an instance of the Ord class and the Num class
02:44:27 <McManiaC> ok
02:44:41 <xrfang> Axman6, where can I use it?
02:44:44 <xrfang> say
02:44:46 <xrfang> I define:
02:44:53 <xrfang> let f = f + 5
02:44:53 <Berengal> @type let maximum = foldl max minBound in maximum
02:44:55 <lambdabot> forall a. (Bounded a, Ord a) => [a] -> a
02:45:04 <xrfang> I want this function to be applied to only Integer
02:45:12 <Berengal> @type let f = f + 5 in f
02:45:13 <lambdabot> forall a. (Num a) => a
02:45:14 <thoughtpolice> xrfang: give it an explicit type
02:45:15 <xrfang> sorry made a mistake
02:45:25 <xrfang> let f x = x + 5
02:45:42 <Axman6> >t let f x = x + 5 in f
02:45:43 <xrfang> now to specify x is Int only:  let f x :: Int = x + 5?
02:45:49 <Axman6> :t let f x = x + 5 in f
02:45:50 <lambdabot> forall a. (Num a) => a -> a
02:45:56 <scook0> let f :: Integer -> Integer
02:46:02 <thoughtpolice> xrfang: basically, when you see the syntax 'f :: (Class a) => a', you *constrain* the types which the type variable 'a' can be, to only those types which are instances of 'Class'
02:46:02 <scook0>     f x = x + 5
02:46:23 <Berengal> @type let {f :: Integer -> Integer; f x = x + 5} in f
02:46:24 <lambdabot> Integer -> Integer
02:46:31 <thoughtpolice> so,
02:46:34 <thoughtpolice> @instances Num
02:46:35 <lambdabot> Double, Float, Int, Integer
02:46:40 <Axman6> xrfang: though this isn't really related to =>
02:46:40 <xrfang> thoughtpolice: I can guess the meaning, but I want correct syntax used in a program, and where to use what :|
02:46:55 <thoughtpolice> xrfang: => is a reserved operator for class constraints
02:47:02 <xrfang> the use of "let" is not relevant to this question
02:47:02 <thoughtpolice> you can't use it for anything else
02:47:08 <Axman6> :t let f :: Integral a => a -> a; f x = x + 5 in f
02:47:10 <lambdabot> forall a. (Integral a) => a -> a
02:47:11 <Berengal> xrfang: Basically, you use it in type signatures
02:47:18 <Axman6> @instances Integral
02:47:19 <lambdabot> Int, Integer
02:47:19 <thoughtpolice> xrfang: you just use it in type signatures
02:47:34 <thoughtpolice> xrfang: if you do not give a type signature, the type checker finds the most 'general' type for the expression
02:47:39 <thoughtpolice> which will include class constraints
02:47:46 <xrfang> ok, this stuff => is used in type signatures, how about ::?
02:47:51 <xrfang> where to use double colon?
02:48:02 <thoughtpolice> xrfang: the double colon starts a type signature
02:48:06 <Axman6> that says that the thing on the left of the :: has the type on the right
02:48:08 <Berengal> xrfang: Type signatures are (approximately): [optional: class constraints + =>] type
02:48:10 <thoughtpolice> i.e. 'f :: x' says 'f' has type 'x'
02:48:32 <xrfang> plus x y = x + y
02:48:44 <xrfang> now, I want x y to be both Integer, how do I write that?
02:48:52 <opqdonut> plus :: Integer -> Integer -> Integer
02:48:54 <thoughtpolice> plus :: Integer -> Integer -> Integer
02:48:57 <thoughtpolice> plus x y = x + y
02:49:13 <opqdonut> :t let plus x y = x + y in plus
02:49:14 <lambdabot> forall a. (Num a) => a -> a -> a
02:49:16 <thoughtpolice> you simply give the expression an implicit type signature
02:49:18 <opqdonut> that's the type that ghc infers
02:49:18 <xrfang> in another word, I don't want the "meaning" of "::", I want to know the correct syntax of using that symbol :)
02:49:42 <opqdonut> ah
02:49:49 <Berengal> xrfang: It just means "here starts the type signature for the previous expression"
02:49:56 <opqdonut> when you have a series of declarations foo = bar, you can intersperse foo :: type there
02:49:59 <xrfang> ok, the :: is used in "plus :: Integer..." not in the definition of the function itself
02:50:05 <thoughtpolice> it is simply used to give an expression (*any* expression) an explicit type
02:50:28 <opqdonut> or if you have enabled some extensions, you can say "plus x y = (x :: Integer) + (y :: Integer)"
02:50:33 <opqdonut> or something like that
02:50:36 <xrfang> but then when to use => -- it is also used in type signature, but "plus :: Integer -> Integer -> Integer" is already a signature...?
02:50:43 <ezero> any ideas how I check for a case when key not found in my ADT map http://pastie.org/private/6xbr5niatcpd1xtkxgpn7w
02:50:44 <Berengal> opqdonut: I think you can do that without extensions
02:50:55 <xrfang> opqdonut: yes I have saw that in my first tutorial
02:50:56 <opqdonut> xrfang: => is part of the type
02:51:00 <thoughtpolice> opqdonut: you don't need any extensions
02:51:00 <Axman6> xrfang: take a look at this:
02:51:01 <opqdonut> xrfang: an optional part
02:51:04 <Axman6> :t let f :: Integral a => a -> a; f x = x + 5 in f
02:51:05 <lambdabot> forall a. (Integral a) => a -> a
02:51:15 <thoughtpolice> opqdonut: you can (afaik) give a type signature to any expression anywhere
02:51:25 <Berengal> xrfang: => is used only when you want to be able to use polymorphic types, but have them restricted to certain classes
02:51:30 <thoughtpolice> opqdonut: but there are extensions so you can have type signatures e.g. on the rhs of a definition
02:51:31 <Axman6> :t let f :: Integral a => a -> a; f x = if x < 5 then x + 5 else x in f
02:51:32 <lambdabot> forall a. (Integral a) => a -> a
02:51:43 <thoughtpolice> er
02:51:43 <thoughtpolice> lhs
02:51:46 <opqdonut> ah yes sorry, scoped type variables were an extension
02:51:49 <thoughtpolice> so you can do let (x::Int) = y
02:51:51 <opqdonut> and lhs types
02:51:52 <opqdonut> yeah
02:52:05 <xrfang> ok, Say, in the above example, "Integral a => a" is a type
02:52:07 <jedai> opqdonut: That's something else
02:52:19 <xrfang> Integral is language-defined class?
02:52:29 <ErhardtMundt> hallo
02:52:33 <Berengal> ?index Integral
02:52:33 <lambdabot> Prelude
02:52:40 <Berengal> Integral is in the prelude
02:52:44 <Berengal> :P
02:52:48 <jedai> opqdonut: scoped type variables just create scope for foralled type variables
02:53:04 <xrfang> ok, so I can also write "Integral b => b"? i.e. a used in the type is arbitrary?
02:53:23 <Berengal> xrfang: Type variables can have any name you want
02:53:24 <xrfang> this means b is a type in the "integral" class, right?
02:53:29 <thoughtpolice> xrfang: yes, it is just a variable for your type
02:53:30 <thoughtpolice> xrfang: yes
02:53:34 <xrfang> thanks
02:53:40 <opqdonut> jedai: yes, I know
02:53:44 <Berengal> It's just common to give type variables a single letter name
02:54:00 <Berengal> @type quickCheck
02:54:02 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
02:54:03 <jedai> opqdonut: It doesn't extend where you can put type annotation
02:54:06 <thoughtpolice> but but but... what if you need to explicitly bring into scope more than 26 type variables?!?!?!
02:54:21 <opqdonut> jedai: yes, I know. as I said i misremembered what exactly needed extending
02:54:24 <ivanm> thoughtpolice: a1, etc.?
02:54:41 <xrfang> the more I ask here, the more questions I have -- sorry :)
02:54:51 <xrfang> in this: let f :: Integral a => a -> a; f x = if x < 5 then x + 5 else x in f
02:55:10 <xrfang> the "in f" clause applies to the let in the beginning, right?
02:55:20 <Berengal> @type let {myId :: anyTypeYouLike -> anyTypeYouLike; myId x = x} in myId
02:55:21 <lambdabot> forall anyTypeYouLike. anyTypeYouLike -> anyTypeYouLike
02:55:22 <Axman6> yeah
02:55:22 <jedai> xrfang: yes
02:55:26 <thoughtpolice> xrfang: yes, it applies to the 'innermost' let
02:55:32 <xrfang> ok thanks
02:55:36 <thoughtpolice> as they have scope when you use 'in'
02:55:37 <xrfang> but
02:55:49 <xrfang> "in f", means it is related to f
02:55:53 <xrfang> how about this
02:56:13 <Berengal> xrfang: The "in" means "in the following expression"
02:56:15 <xrfang> let f1 :: Integral a => a -> a; f2 x = if x < 5 then x + 5 else x in (f1 or f2 here?)
02:56:35 <xrfang> I mean if the let block defines more than one function? is that correct syntax?
02:56:44 <thoughtpolice> xrfang: ah, you're confused. type signatures for named expressions can be 'detached' from the actual definition
02:56:46 <jedai> xrfang: whatever you want (except that didn't define f1
02:56:46 <opqdonut> xrfang: yes, it can define more than one function
02:56:48 <Berengal> So "let the variables [variables] be defined in the following expression: [expression]"
02:57:17 <xrfang> ok, detach the type signature...
02:57:18 <jedai> xrfang: let { declarations } in expression
02:57:19 <thoughtpolice> xrfang: you can have 'f :: Integral a => a -> a -> a' appear somewhere, but the actual definition of 'f' can appear much later at a different location.
02:57:30 <thoughtpolice> xrfang: so in "let f :: Integral a => a -> a; f x = if x < 5 then x + 5 else x in f
02:57:33 <thoughtpolice> "
02:57:34 <ski> > let x = 0 : y; y = 1 : map (2 *) y in x !! 28
02:57:35 <lambdabot>   134217728
02:57:40 <thoughtpolice> you are simply stating the type of 'f' upfront
02:57:58 <thoughtpolice> xrfang: you would also do that if you explicitly wanted Integer instead of 'Integral a' etc
02:58:06 <xrfang> help! :p  what is !!? please do not introduce scarying symobols to a newbie
02:58:18 <ski> > [0,1,2,3,4,5,6,7] !! 5
02:58:20 <lambdabot>   5
02:58:25 <ski> > "help" !! 2
02:58:26 <lambdabot>   'l'
02:58:28 <gueux> I have implemented a small game with a game server and an irc-game server client. I would like to code something to access to it on the web. do you think I could do that easily in haskell too? Or may I code directely a client in another language such as php? (I almost don't know php at all)
02:58:30 <Berengal> xrfang: (!!) is the index function, same as array indexing
02:58:45 <Berengal> Well, about
02:58:48 <xrfang> tks. let me think of the f.
02:59:30 <xrfang> lets ignore the type signature...
02:59:32 <xrfang> say
02:59:37 <jedai> gueux: You can do it pretty easily in Haskell
02:59:44 <xrfang> let f x = if x < 5 then x + 5 else x in f
02:59:51 <xrfang> is the above correct expressing?
02:59:55 <Berengal> xrfang: Yes
03:00:03 <Berengal> @type let f x = if x < 5 then x + 5 else x in f
03:00:04 <lambdabot> forall a. (Ord a, Num a) => a -> a
03:00:24 <xrfang> here the confusion comes from the "in" clause
03:00:35 <jedai> gueux: You can access the network to discuss with your server and there are several good solutions to create web UI with Haskell
03:00:39 <xrfang> in a program I see the "in" cluase, it reads quite natural like English
03:00:43 <xrfang> but in the above
03:00:48 <xrfang> what is the difference between:
03:00:56 <xrfang> let f x = if x < 5 then x + 5 else x in f
03:00:57 <xrfang> and
03:01:01 <xrfang> et f x = if x < 5 then x + 5 else x
03:01:04 <xrfang> let
03:01:11 <xrfang> i.e with or without "in f"
03:01:14 <Berengal> xrfang: The last one isn't valid
03:01:15 <ski> the latter isn't a proper expression
03:01:19 <xrfang> I don't think the "in f" is necessary?
03:01:26 <Berengal> xrfang: Yes it is
03:01:30 <ski> yes it is (except in `do'-notation)
03:01:32 <jedai> xrfang: the first is an expression, the second is invalid
03:01:35 <gueux> jedai: ok, great
03:01:47 <Berengal> Let introduces new names. These names are only defined in the let expression
03:01:50 <xrfang> oh yes it is in a do in the sample program
03:02:00 <gueux> I would probably need something to use the mouse to click on the board,...
03:02:05 <Berengal> xrfang: "do" is special :)
03:02:07 <gueux> things like that
03:02:21 <xrfang> so the let ... in f statement actually just DEFINE a function but did not "execute" it some how, right?
03:02:24 <ski> `do' is "special", but we all love it anyways
03:02:33 <ski> (except for those who don't)
03:02:37 <gueux> have you a good solution to give me? :-)
03:02:39 <jedai> xrfang: sure, but do-notation is just syntax sugar, in reality the "let ..." in a do-block is translated into a let ... in ...
03:03:04 <gueux> (the simplest would be the best)
03:03:16 <xrfang> tks
03:03:17 <Berengal> xrfang: Exactly. "let" alone just defines name, but it doesn't return a value. The value of a let expression is the part in the "in" part
03:03:31 <ski> xrfang : yes, `let' defines stuff in a local scope, but doesn't execute it
03:03:35 <Berengal> And all expressions need to return a value
03:03:37 <jedai> gueux: I'm not certain what you mean, do you want a GUI or a web UI (in XHTML, CSS and Javascript) ?
03:03:52 <xrfang> let is "optional", so even in the place, e.g. top level function where let is not necessary, I can still use it?
03:04:26 <gueux> jedai: a web ui
03:04:30 <Berengal> xrfang: No, let isn't optional when you want to define new names (except at the top-level where lets aren't allowed)
03:04:31 <ski> you can't use `let' on the "top level" of a module, simply because expressions is not allowed there
03:04:48 <ray> where
03:05:03 <Berengal> xrfang: Well, you could use "where" to bind new names, but they're similar enough to lets
03:05:09 <gueux> concerning XHTML, CSS and Javascript, I don't know what I need
03:05:47 <xrfang> well I see: "module Main\n where..." in all the sample programs.
03:05:54 <xrfang> is this mandatory or optional?
03:06:04 <Berengal> xrfang: Optional
03:06:10 <xrfang> tks
03:06:32 <jedai> gueux: You need to know at least the first two to do a web UI (whatever language you use server-side to generate your dynamic pages) and Javascript is handy to do cuter and more user-friendly interfaces
03:07:48 <McManiaC> i have this line of code:
03:07:51 <McManiaC> x <- runErrorT . join . liftIO $ readfile emptyCP filepath
03:07:57 <McManiaC> with readfile :: MonadError CPError m => ConfigParser -> FilePath -> IO (m ConfigParser)
03:08:00 <xrfang> what is the difference between:
03:08:09 <xrfang> (Num a) => a
03:08:13 <xrfang> and Num a => a
03:08:17 <xrfang> without ()
03:08:20 <McManiaC> how can i make sure the programm doesnt crash if the file at filepath does not exist?
03:08:28 <opqdonut> xrfang: no difference
03:08:29 <McManiaC> i thought thats what runErrorT was for?
03:08:45 <opqdonut> xrfang: you need the parenthesis if you have multiple constraints: (Num a, Ord a)
03:09:07 <xrfang> (Num a, Ord a) means either Num or Ord?
03:09:08 <jedai> xrfang: No difference, because there's only one constraint, if there's more, you'll need the parens
03:09:27 <McManiaC> xrfang: and
03:09:30 <opqdonut> xrfang: means both
03:09:31 <jedai> xrfang: no, it means a is an instance of Num and Ord
03:09:40 <xrfang> ok, tks!
03:09:55 <gueux> jedai: ok, javascript may make the problem harder... If I can have just a form to enter the player's name, a picture with clicable areas, and an interface with the game server, it would be perfect :)
03:13:42 <jedai> gueux: Then you only need to know XHTML and Haskell (and CSS if you care for the appearance of your site)
03:14:19 <xrfang> :t \x -> "hello world"
03:14:21 <lambdabot> forall t. t -> [Char]
03:15:06 <gueux> jedai: ok. What library do I need, in your opinion?
03:15:15 <ivanm> @pl \ x -> "hello world"
03:15:16 <lambdabot> const "hello world"
03:15:24 <ivanm> ;-)
03:15:29 <xrfang> what is pl?
03:15:36 <Axman6> pointless
03:15:43 <Berengal> aka. point-free
03:15:50 <xrfang> I tried in ghci the above, but it says: IInterInterrupted.
03:15:51 <jedai> gueux: What's your webserver ?
03:15:56 <xrfang> point free?
03:16:07 <Berengal> xrfang: points are variable names
03:16:07 <Axman6> xrfang: did you hit ^C?
03:16:18 <xrfang> oh. probably
03:16:26 <Berengal> xrfang: point free means no variables
03:16:29 <xrfang> I thought that is an invalid expression
03:16:34 <jedai> xrfang: ghci doesn't know those commands, it's a lambdabot plugin
03:16:34 <SubStack> @pl (\a b c d -> a : b : c : d : [])
03:16:35 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
03:16:38 <SubStack> blech
03:16:47 <opqdonut> :)
03:16:50 <xrfang> forget about @pl now ;)
03:16:52 <Berengal> sometimes pl really is pointless
03:17:03 <xrfang> :t \x -> x 'a'
03:17:04 <lambdabot> forall t. (Char -> t) -> t
03:17:13 <xrfang> this stuff is weird
03:17:19 <opqdonut> not really
03:17:32 <Berengal> Exactly what is weird about it?
03:17:34 <xrfang> >let f = \x -> x 'a'; f 'a'
03:17:42 <Axman6> @pl \q w e r t y u i o p ->  t y p e w r i t e r
03:17:45 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
03:17:45 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
03:17:45 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
03:17:45 <lambdabot> optimization suspended, use @pl-resume to continue.
03:17:53 <opqdonut> :)
03:17:59 <xrfang> it says (Char -> t) -> t
03:18:00 <Axman6> @more
03:18:03 <xrfang> what does that mean
03:18:06 * Axman6 ducks 
03:18:12 <Axman6> @pl-resume
03:18:14 <Berengal> xrfang: That means it takes one argument of type Char -> t
03:18:17 * Axman6 chickens
03:18:19 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .
03:18:19 <lambdabot> ) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (
03:18:19 <lambdabot> flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
03:18:19 <lambdabot> optimization suspended, use @pl-resume to continue.
03:18:20 <opqdonut> xrfang: "when given a function from Char to t, this function returns a value of type t"
03:18:21 <Berengal> And returns one of type t
03:18:38 <jedai> xrfang: Well it's just a function that takes a function from Char to t in argument and returns a t
03:18:42 <xrfang> I defined that function f, and "run"
03:18:58 <xrfang> it does not reply correctly... sorry I will leave for now, study continues after dinner, thanks all!
03:19:04 <jedai> > let f x = x 'a' in f ord
03:19:05 <lambdabot>   97
03:19:07 <gueux> jedai: ? my server is not yet a web server.
03:19:15 <ski> McManiaC : how is `liftIO' supposed to know about how to convert file-not-found errors into `CPError' ?
03:19:21 <Berengal> > let f x = x 'a' in f (:[])
03:19:22 <lambdabot>   "a"
03:19:30 <jedai> gueux: ok, but it's your personal server, your access isn't restricted ?
03:19:30 <gueux> jedai: apache
03:19:45 <gueux> jedai: yes
03:20:00 <gueux> I can do what I want :)
03:20:25 <jedai> gueux: In this case you can try Happstack, it integrate most part of a web application in Haskell
03:20:38 <pao> can anyone enlight me about backward incompatible changes in ghc 6.10.2 WRT foreign pointers?
03:20:51 <pao> the release notes do not say much
03:20:56 <McManiaC> ski: ?
03:20:56 <jedai> gueux: Check the recent tutorials on Happstack on Planet Haskell
03:21:49 <Axman6> pao: #ghc would be a better place to ask
03:21:55 <quicksilver> pao: haskell finalisers, which were never permitted, are now actually broken.
03:21:58 <quicksilver> pao: something like that.
03:22:13 <gueux> jedai: ok, thanks! do you know if there is a kind of game which use this happstack?
03:22:14 <pao> quicksilver: thanks
03:22:25 <ski> McManiaC : presumably your `readfile' calls `readFile' or a friend on the filepath, and presumably this can generate a file-not-found error in the `IO' part of the computation
03:22:31 <gueux> jones-: (it could help me in the beginning)
03:22:48 <jones-> gueux: you mean someone else?
03:22:52 <McManiaC> ski: ok
03:22:53 <pao> Axman6: thanks
03:23:16 <ski> McManiaC : when you pass that to `liftIO' you convert the outer `IO' layer into an `m' layer, for your monad satisfying `MonadError CPError m', and then the join smashes that layer and the inner `m' layer together
03:23:35 <gueux> jones-: sorry, I meant jedai
03:23:38 <gueux> :)
03:23:42 <jones-> gueux: np.
03:23:54 <ski> McManiaC : both `liftIO' and `join' and library functions, and can't be expected to know about your `CPError' type
03:24:40 <ski> McManiaC : possibly you want to somewhere actually catch file-not-found errors in the `IO' part, and convert them into `CPError's
03:26:43 <ski> (or maybe change `readfile' into not generating any `IO' at all, as separate from an `m' with `MonadIO m' constraint)
03:29:41 <McManiaC> hmmm
03:31:26 <Axman6> @hoogle Text.XML.Light
03:31:26 <lambdabot> package lighttpd-conf
03:31:27 <lambdabot> package lighttpd-conf-qq
03:31:27 <lambdabot> package highlighting-kate
03:31:35 <Axman6> hmm
03:31:45 <ski> hm
03:32:01 <ray> h
03:35:12 <Axman6> anyone played with haskalebelle? i'm tryig to emulate the post here http://www.jedi-ninja.net/2009/04/20/A-little-fun.html but i'm getting some very strange errors
03:36:35 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4117#a4117
03:41:35 <doserj> Axman6: wrong version of haskell-src-exts?
03:41:53 <Axman6> no idea
03:42:08 <Axman6> see if i can upgrade it...
03:56:23 <vixey> "Delimited Continuations .... have been used to implement A-normalization in direct style"
03:56:25 <vixey> hah!
03:56:51 <BONUS> haha what
04:01:50 <Acteum> hahaha!
04:17:28 <mc__> is there an easy way to check if one list contains another?
04:17:44 <therp> elem?
04:17:54 <ivanm> mc__: as in a complete list?
04:17:59 <ivanm> @type (\\)
04:18:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:18:08 <mc__> ivanm: yes
04:18:17 <quicksilver> > "foo" `isInfixOf` "this string contains foo, I believe"
04:18:18 <lambdabot>   True
04:18:26 <ivanm> mc__: smallerList \\ biggerList == []
04:18:43 <quicksilver> that only checks it contains the characters
04:18:46 <quicksilver> not the order
04:19:00 <ordwidr> hi
04:19:05 <quicksilver> > "abcdefghijklmnopqrstuvwxyz" \\ "the quick brown fox jumped over the lazy dog"
04:19:07 <lambdabot>   "s"
04:19:15 <ivanm> quicksilver: ahhhh
04:19:21 <ivanm> he didn't specify order though...
04:19:22 <ordwidr> quicksilver: "jumps"
04:19:36 <quicksilver> ordwidr: deliberate mistake to make the example more interesting :P
04:20:02 * ordwidr missed the beggining of the discussion :-p
04:20:03 <int-e> mc__: so the real answer is that we need a better specification of what behaviour you want.
04:20:04 <opqdonut> the strict brown fox jumped over the lazy dog
04:20:15 <mc__> ivanm: in what module is \\ ?
04:20:20 <quicksilver> but the lazy dog was more flexible.
04:20:20 <int-e> Data.List
04:20:25 <int-e> @where (\\)
04:20:26 <lambdabot> I know nothing about (\\).
04:20:30 <int-e> @index (\\)
04:20:30 <lambdabot> bzzt
04:20:34 <int-e> @hoogle (\\)
04:20:35 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
04:20:35 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
04:20:35 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
04:20:45 <ordwidr> opqdonut: the pure lazy fox jumped over the strict dog
04:20:47 <int-e> (meh. index should've worked :) )
04:20:56 <mc__> int-e: I think \\ is exactly what I want
04:21:13 <quicksilver> @index (\\\\)
04:21:14 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
04:21:18 <quicksilver> int-e: escaping bug :P
04:21:20 * ordwidr fights fundeps
04:21:24 <int-e> quicksilver: oh
04:22:04 <int-e> :t Data.Set.fromList ?a `Data.Set.isSubsetOf` Data.Set.fromList b
04:22:05 <int-e> :t Data.Set.fromList ?a `Data.Set.isSubsetOf` Data.Set.fromList ?b
04:22:05 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
04:22:06 <lambdabot>     In the first argument of `S.fromList', namely `b'
04:22:06 <lambdabot>     In the second argument of `S.isSubsetOf', namely `S.fromList b'
04:22:07 <lambdabot> forall a. (?b::[a], Ord a, ?a::[a]) => Bool
04:22:54 <ordwidr> if I have a function  f :: a -> b -> c  where certain types for "b" shall only be a arguments for type "a" will I need typeclasses and fundeps?
04:23:01 <ordwidr> or ist there a simpler way?
04:23:29 <BONUS> what do you mean arguments for type "a"?
04:23:31 <ivanm> ordwidr: care to give an example so we're sure of what you want?
04:23:45 <ivanm> do you mean something like: Maybe a -> a -> b ?
04:24:37 <QtPlaty[HireMe]> Or do mean that there is a relationship bettween a and b?
04:24:45 <ordwidr> say I have a function createDocument document format formatOptions, e.g. createDocument doc PDF PDFOps { ... }
04:25:02 <ordwidr> and createDocument doc HTML HTMLOoptions { ... }
04:25:24 <ordwidr> and doc type HTML implies HTMLOptions wheras PDF implies PDFOptions
04:25:27 <ivanm> oh, so PDF implies PDFOps, etc.?
04:25:33 <ivanm> sounds like fundeps
04:25:37 <ordwidr> ivanm: ok
04:25:53 <rabideejit> @hoogle chroot
04:25:53 <lambdabot> No results found
04:26:05 <ivanm> rabideejit: do I dare ask why?
04:26:15 <ivanm> @hoogle hoogle
04:26:16 <lambdabot> Can't think of anything more interesting to search for?
04:26:16 <lambdabot> package hoogle
04:26:16 <lambdabot> Distribution.Simple.Setup haddockHoogle :: HaddockFlags -> Flag Bool
04:26:18 <ivanm> ^^ heh
04:26:32 <ordwidr> in java I would have:
04:26:32 <ordwidr> interface Doctype<T extends Doctype<T,O>,O extends Docoptions<T,O>
04:26:32 <ordwidr> interface Docoptions<T extends Doctype<T,O>,O extends Docoptions<T,O>
04:27:13 <int-e> this is a possibility: class CreateDocument format options | format -> options where createDocument :: Document -> format -> options -> whatever, with data HTML = HTML, data PDF = PDF and so on.
04:27:20 <rabideejit> ivanm: yeah, I'd better set hoogle up properly on this machine.  I have an irc bot which executes a few esoteric languages, I'd rather not let it see /dev and /proc.
04:27:34 <ivanm> hmmm...
04:27:40 <int-e> and instances CreateDocument HTML HTMLOptions and CreateDocument PDF PDFOptions
04:27:43 <ordwidr> ivanm: the internet told me that fundeps are between evil and dilemma
04:27:53 <ivanm> both!
04:27:54 <ordwidr> int-e: that's how I did it.
04:27:59 <ivanm> it's a quantum extension!
04:29:21 <ordwidr> ivanm: so my usage of fundeps be a  measurement of the state so that the superposition of evil and dilemma is useful?
04:29:40 <ivanm> ..... maybe...
04:29:53 <ivanm> or, to be more haskellian, answer :: Maybe Bool
04:29:54 <ivanm> ;-)
04:29:57 <ordwidr> or either?
04:30:09 <ordwidr> Either Dilemma Evil
04:30:44 <quicksilver> newtype Dilemma = Dilemma (Either Dilemma Evil)
04:30:47 <int-e> Why can't fundeps be both useful and evil? We're not google ;)
04:31:10 <ivanm> quicksilver: a recursive dilemma! ;-)
04:31:20 <ivanm> int-e: a useful evil?
04:31:32 <int-e> type Dilemma = Either Lemma Lemma
04:31:32 <ordwidr> int-e: i was worried because after my first 10 lines of haskell I stumbleon fundeps.
04:31:49 <ivanm> int-e: now define Lemma
04:32:00 <ivanm> oh, wait, I get it *groan*
04:32:04 <ordwidr> int-e: resolve :: Dielemma -> Lemma
04:32:14 <ivanm> though isn't (Lemma, Lemma) more strictly accurate?
04:32:26 <opqdonut> quicksilver: :D
04:32:27 <ordwidr> ivanm: does the order matter?
04:32:43 <int-e> ivanm: maybe, but it makes less sense semantically ;)
04:32:54 <rabideejit> why not type families: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4118#a4118
04:33:11 <ivanm> int-e: well, you're only offering one of two possible Lemmas...
04:33:19 <ivanm> to be a DIlemma, there _has_ to be two
04:34:06 <ordwidr> rabideejit: interesting. how is a concrete instance defined for such a class?
04:34:36 <int-e> ordwidr: You /can/ do this: class CreateDocument options where createDocument :: Document -> options -> whatever. This will be Haskell 98 even; the format will be implied by the type of options you use.
04:34:41 <ordwidr> rabideejit: instance CreateDocument Doc HTMLDoc HTMLOpts ?
04:35:03 <rabideejit> you have to bind the type families to a given type in the instance declaration
04:35:15 <int-e> ordwidr: but if you choose a multi parameter type class, functional dependencies will almost inevitably creep in as well.
04:35:46 <ordwidr> int-e: I feel them in my left trowser leg
04:38:06 <rabideejit> actually wait, I wrote that type family thing pretty weird... it's better if you use the type families to deal with one type, instead of three
04:39:21 <ordwidr> rabideejit: my actual use case is validation, so there is a type specification a type value  and validate :: spec -> value -> Bool
04:39:46 <rabideejit> This is better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4119#a4119
04:39:52 <mlesniak> Hi, I have a preliminary function to measure the duration of an IO action but, e.g. in measure (threadDelay 1000000) I get quite different results. Is there a better / standard way to measure duration with a precision better than 1 second? (Code: see http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2206#a2206 )
04:40:24 <ordwidr> rabideejit: ah, I'll look
04:40:26 <rabideejit> ahh, well then you use each Value type in the place of the thing like HTMLT in the source there
04:40:36 <rabideejit> If I'm understanding you correctly
04:42:23 <rabideejit> mlesniak: the time library proviedes getCurrentTime, which has a fractional representation
04:43:08 <mlesniak> rabideejit: Ah thanks. I was quite sure there has to be some library. My fault for not looking deep enough on hackage. Thanks again
04:43:42 <rabideejit> It's alright, hope it works for you
04:47:32 <ordwidr> rabideejit: nope, it doesn't
04:47:48 <ordwidr> rabideejit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4119#a4121
04:50:57 <rabideejit> hmmm
04:52:58 <rabideejit> ordwidr: actually that compiles for me
04:53:38 <ordwidr> rabideejit: it compiles, yet. but verify (StringS 1 2) (StringV "ab") fails
04:53:53 <rabideejit> ah yes
04:58:06 <haskellnoob> How can I figure out the upper and lower bounds for the various Numeric classes, such as Int32, Word32 etc?
04:58:21 <BONUS> > maxBount :: Int
04:58:23 <lambdabot>   Not in scope: `maxBount'
04:58:29 <BONUS> > maxBound :: Int
04:58:31 <lambdabot>   9223372036854775807
04:58:37 <BONUS> > minBound :: Int
04:58:39 <lambdabot>   -9223372036854775808
04:58:42 <haskellnoob> BONUS:thanks
04:58:47 <BONUS> np :]
04:59:40 <burp_> are there also functions for the precision?
05:00:53 <burp_> of floats?
05:01:22 <ordwidr> rabideejit: any idea? or doesn't it work with type families?
05:01:33 <Acteum> could someone say something in unicode please
05:01:43 <therp> äüé
05:01:44 <ivanm> защо?
05:01:47 <Berengal> ł→ĸ€ łħªþ
05:01:54 <Acteum> thanks
05:01:54 <rabideejit> ordwidr: I got it working
05:02:05 <ivanm> Berengal: was that actually meant to be anything?
05:02:15 <ordwidr> ʎ or λ
05:02:21 <Berengal> ivanm: map altGr "like what"
05:02:38 <ordwidr> Berengal: *lol*
05:02:44 <Acteum> lol
05:02:48 <rabideejit> ordwidr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4119#a4122
05:02:49 <ivanm> Berengal: ahhh
05:02:56 <haskellnoob> How do I read in a line of input as, say, Word32? Right now my code reads as follows:
05:02:58 <haskellnoob>   do
05:02:59 <haskellnoob>         inputLine <- getLine
05:03:00 <ordwidr> what is the revereds lambda λ good for?
05:03:01 <haskellnoob>         let inputNum  = read inputLine
05:03:02 <haskellnoob>         -- do stuff with inputNum
05:03:04 <haskellnoob> The problems with this are:
05:03:05 <haskellnoob> 1. I know that the input will always be a positive integer between 1 and 1000 (say), but the above code doesn't know this, so it may not be the fastest.
05:03:07 <haskellnoob> 2. I want the various operations with inputNum to be in the integer domain, but since I haven't told that inputNum is an integer, division results in values that are not integers.
05:03:08 <haskellnoob> So, how do I tell to read inputLine and store it as a Word32 value, for instance?
05:03:31 <ivanm> haskellnoob: let inputNum = read inputLine :: Word32 ?
05:03:36 <ordwidr> brb
05:04:14 <rabideejit> @t (/)
05:04:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:04:17 <rabideejit> eh
05:04:20 <rabideejit> I forgot the thing
05:04:20 <haskellnoob> ivanm: thanks. I checked the Prelude where they describe read and reads and so on, but couldn't figure this out. Let me check again.
05:04:29 <Acteum> @thanks
05:04:30 <lambdabot> you are welcome
05:05:05 <rabideejit> haskellnoob: Integer's can't be divided, they're not fractional
05:05:23 <Berengal> @ticker JAVA
05:05:24 <lambdabot> JAVA: 9.15 0.00 (0.00%) @ 4/22/2009 4:00pm
05:05:25 <rabideejit> with an extra apostrophe for the integer there.
05:05:27 <ivanm> rabideejit: well, there's `div`
05:05:28 <Berengal> O_o
05:05:30 <rabideejit> ah
05:05:32 <rabideejit> yeah
05:05:46 <Acteum> 4/2=2
05:05:59 <haskellnoob> ivanm: or do I read the above line as: "read inputLine as type Word32"? Does the :: apply to inputLine, or to (read inputLine) ?
05:06:12 <ivanm> haskellnoob: to read inputLine
05:06:28 <rabideejit> Acteum: What I meant was that
05:06:35 <Berengal> The precedence of :: always confuses me...
05:06:35 <rabideejit> > ( 4 :: Int ) / ( 2 :: Int )
05:06:37 <lambdabot>       No instance for (Fractional Int)
05:06:37 <lambdabot>        arising from a use of `/' at <i...
05:06:44 <PeakerWork> The precedence of :: is very low, even lower than $
05:06:46 <Acteum> indeed
05:06:47 <ivanm> rabideejit: ummm... no, Int's can't be divided
05:06:52 <ivanm> @type (/)
05:06:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:07:02 <ivanm> @instances Fractional
05:07:03 <lambdabot> Double, Float
05:07:06 <PeakerWork> > ((+) $ 3 :: Int) 5
05:07:07 <lambdabot>   Couldn't match expected type `Int' against inferred type `a -> a'
05:07:09 <PeakerWork> > ((+) $ 3 :: Int -> Int) 5
05:07:11 <lambdabot>   8
05:07:14 <ivanm> @instances-importing Data.Complex Fractional
05:07:15 <lambdabot> Complex a, Double, Float
05:07:15 <Acteum> > 5 `div` 6
05:07:17 <lambdabot>   0
05:07:25 <PeakerWork> that shows the precedence of :: is lower than $ and thus the lowest possible
05:07:38 <PeakerWork> > 5 `divMod` 6
05:07:39 <lambdabot>   (0,5)
05:07:41 <rabideejit> ivanm: I was trying to clear up haskellnoob's comment: 'since I haven't told that inputNum is an integer, division results in values that are not integers'.  Yes, use `div`.
05:07:45 <ivanm> PeakerWork: how does it show it's the lowest possible?
05:07:49 <Berengal> PeakerWork: = seems to stop it though, but I'm guessing that's because = is special?
05:08:05 <PeakerWork> ivanm: it shows its lower than $, the "thus" is not shown, its my deduction which may be wrong :)
05:08:05 <ivanm> Berengal: = is assignment
05:08:12 <ivanm> PeakerWork: heh
05:08:12 <Acteum> not quite assignment
05:08:24 <PeakerWork> Berengal: I guess = is even lower than the lowest possible, my bad :-)
05:08:40 <Berengal> ivanm: That makes it special, no?
05:09:16 <ivanm> Berengal: well, it's not a function...
05:09:28 <Berengal> ivanm: Neither is ::
05:09:29 <ivanm> @type (::)
05:09:31 <lambdabot> parse error on input `::'
05:09:40 <ivanm> Berengal: it has a kind value IIRC...
05:09:54 <Berengal> If (::) is a function, what type does it have?
05:10:16 <doserj> = form definitions, not expressions. :: forms an expression
05:10:34 <Acteum> i thought (::) was just a hint
05:10:52 <Acteum> or restriction
05:10:53 <doserj> :: is part of expression syntax
05:10:55 <Berengal> If :: forms an expression, what's the value of "foo :: Int -> Int -> Bool"?
05:11:29 <QtPlaty[HireMe]> I thought it was just part of syntax.
05:11:34 <Acteum> it is
05:11:46 <Berengal> Everything is part of the syntax...
05:11:50 <Berengal> Well, all text is
05:11:51 <Acteum> it's not an expression because it doesnt evaluate to anything
05:11:59 <ordwidr> re
05:12:06 * ivanm leans towards doserj's explanation
05:12:08 <QtPlaty[HireMe]> Isn't it a declaration?
05:12:21 <QtPlaty[HireMe]> Well part of a declaration.
05:12:43 <Berengal> It's a signature, an optional part of a binding, it appears
05:12:46 <doserj> http://www.haskell.org/onlinereport/exps.html, first production
05:13:18 <doserj> of course, :: is also used for type-signatures in other places.
05:13:49 <rabideejit> cheerio!
05:13:52 <int-e> Berengal: the value is that of 'foo', assuming the type is correct.
05:14:17 <Berengal> doserj: So it's a syntactic expression, but not a semantic one
05:14:35 <int-e> > (1 :: Int, 1 :: Double, 1 :: Rational)
05:14:36 <lambdabot>   (1,1.0,1%1)
05:14:38 <Berengal> Unless it appears in an expression, of course (like 1::Int), in which case it is an expression
05:14:46 <vixey> Berengal; the value of foo :: Int -> Int -> Bool is the value of foo
05:14:47 <xrfang> >let f x = x 'a' in f (:[])
05:14:53 <vixey> (of course typeclass dispatch throws a spanner in the works here)
05:15:42 <ray> if only you could do map (1 ::) (Int, Double, Rational)
05:15:57 <Berengal> At the top level, there are no expressions, only bindings
05:16:34 <ivanm> ray: the types are wrong
05:16:35 <Berengal> So I must assume top-level type signatures are different from expression-level ones
05:16:47 <ivanm> map requires a list ;-)
05:16:58 <ray> dammit
05:17:10 * ray curses
05:17:16 <quicksilver> Berengal: technically there is a difference between giving a signature to a new name (a fresh definition) and to an expression
05:17:18 <xrfang> >let f x = x 'a' in f (:[])
05:17:23 <ray> still, where's my first-class ::
05:17:27 <quicksilver> Berengal: however there are obviously very simlar.
05:17:38 <Berengal> > let f x = x 'a' in f (:[])
05:17:39 <lambdabot>   "a"
05:17:43 <xrfang> the bot fell a sleep?
05:17:49 <quicksilver> which is why they use the same syntax.
05:17:50 <xrfang> oops
05:17:52 <Berengal> xrfang: You need a space after the >
05:17:54 <wjt> ray: i think it's called asTypeOf :P
05:18:04 <quicksilver> it's only confusing when you try to analyse the syntax very carefuly.
05:18:16 <xrfang> I am confused by this stuff, 2 questions here first, (:[]) is a function?
05:18:17 <vixey> ray first-class ::
05:18:27 <Berengal> quicksilver: The difference was the crux though
05:18:30 <vixey> ray asTypeOf = const :: a -> a -> a
05:18:33 <BONUS> xrfang: yeah. much like (+3) is a function
05:18:40 <BONUS> > 3:[]
05:18:42 <lambdabot>   [3]
05:18:54 <haskellnoob> What is this "casting" of a Numeric value to, say, Word32 by saying numVal :: Word32 called? How does this happen? Is :: a function defined somewhere?
05:18:54 <Berengal> quicksilver: Because I was considering "let f x = x :: Int" type expressions
05:19:04 <xrfang> I don't know how to use this, specifically I am confused about prefix, infix (and maybe suffix?) style
05:19:17 <vixey> xrfang: it's the same as \x -> x:[]
05:19:17 <vixey> xrfang: which is \x -> [x]
05:19:17 <vixey> > (:[]) 3
05:19:18 <lambdabot>   [3]
05:19:30 <Berengal> And the precedence of ::
05:19:30 <ray> it's not casting, there's typeclass stuff that does conversions
05:19:33 <quicksilver> Berengal: that's not an expression.
05:19:35 <xrfang> this means :[] is a "suffix function"?
05:19:42 <quicksilver> Berengal: (if we're being precise here)
05:19:49 <ivanm> haskellnoob: until you specify, 1 can be any number you like
05:19:50 <Berengal> quicksilver: Some of it is
05:19:54 <quicksilver> Berengal: yeah ;)
05:19:58 <BONUS> basically if you have functions that act like operators, you can surround them with parens and leave out one side
05:19:59 <ivanm> (though it defaults to Integer if you don't specify anything IIRC)
05:20:04 <ray> :t 1
05:20:05 <lambdabot> forall t. (Num t) => t
05:20:08 <ivanm> by using ::, you force which numeric type it is
05:20:12 <BONUS> like (+3) or (5*)
05:20:17 <BONUS> and it's a function that takes the other side
05:20:17 <ivanm> @type 1 :: (Floating a) => a
05:20:18 <lambdabot> forall a. (Floating a) => a
05:20:19 <Berengal> quicksilver: And that was sort of the point, lacking in point itself as it might be :)
05:20:28 <quicksilver> ;)
05:20:30 <xrfang> ok, BONUS, how do I know?
05:20:32 <quicksilver> pointless points = win.
05:20:49 <ivanm> EvilTerran: awww, don't you want to rant anymore?
05:20:50 <ivanm> ;-)
05:20:53 <Berengal> pointless points are the only really interesting ones
05:20:53 <quicksilver> xrfang: anything that is symbols is an operator. + - * / // ++ that sort of thing.
05:21:09 <quicksilver> xrfang: they can all be sectioned, which is what Berengal is talking about.
05:21:16 <BONUS> yeah. if a function is made only out of symbols, you use it like an operator
05:21:17 <quicksilver> BONUS that should have been
05:21:18 <ivanm> quicksilver: doesn't it have to be composed solely with symbols, or just start with a symbol?
05:21:27 <quicksilver> composed solely of.
05:21:31 <doserj> ->, --, =>, <-, etc :)
05:21:34 <BONUS> yes, sorry :)
05:21:37 <ivanm> actually, if you allowed non-symbols then it would be hard to parse stuff like (+x) I suppose...
05:21:40 <xrfang> quicksilver: you mean "pointless pointers"?
05:21:43 <ray> those are all disallowed operators :(
05:21:52 <xrfang> sorry I was away for an hour... didn't know what you are talking :)
05:21:52 <Berengal> doserj: => isn't allowed, as far as I can tell
05:21:56 <ivanm> xrfang: pointless pointers pointlessly pointing
05:22:01 <ivanm> :p
05:22:03 <ray> %^% or something
05:22:14 <ray> haskell is all about creative line noise names for operators
05:22:29 <ivanm> ray: I thought that was perl's speciality...
05:22:35 <doserj> Berengal: non of that is allowed
05:22:38 <ivanm> we just emulate them sometimes ;-)
05:22:41 <ray> perl is about line noise for everything but operators
05:22:49 <Berengal> <*> <$ &&& , ||| >>= <=< *** *>
05:22:54 <ivanm> doserj: hence the ":)" I'm guessing?
05:23:00 <doserj> yep
05:23:10 <ray> > let a %^% b = if a then a else b
05:23:11 <lambdabot>   <no location info>: parse error on input `;'
05:23:14 <ivanm> /^\ ? ;-)
05:23:16 <Berengal> doserj: Right, lost the context (and etc is allowed ;))
05:23:20 <ivanm> the mountain operator! :p
05:23:21 <ray> > let a %^% b = if a then a else b in True %^% False
05:23:23 <lambdabot>   True
05:23:37 <ray> :t let a %^% b = if a then a else b in (True %^%)
05:23:39 <lambdabot> Bool -> Bool
05:23:46 <vixey> @quote synergy
05:23:46 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
05:23:50 <ivanm> ray: isn't that just or?
05:24:06 <ray> probably
05:24:11 <ray> i just typed what came to my head
05:24:14 <ivanm> @src (||)
05:24:15 <lambdabot> True  || _ =  True
05:24:15 <lambdabot> False || x =  x
05:24:28 <ray> yep, it's or
05:24:37 * ivanm thinks it's cool how the ||'s in the src line up with the || in the command...
05:24:48 * ivanm doesn't get out much...
05:25:07 * Berengal obviously uses a different client than ivanm
05:25:18 <ivanm> or else non-monospace fonts?
05:25:30 <Berengal> That too
05:25:51 <quicksilver> ivanm's client is presunably lining up comments from users even if their nick length varies
05:25:54 <quicksilver> mine doesn't
05:25:59 <quicksilver> does that mean I get out more?
05:26:05 <ivanm> yeah, xchat seperates the nicks from what they say
05:26:22 <ivanm> quicksilver: no, that "doesn't get out much" referred to me thinking the fact that some characters line up was cool
05:26:35 <Berengal> It is though
05:26:50 <ivanm> Berengal obviously doesn't get out much either :p
05:26:56 <Berengal> It just doesn't happen that often for me...
05:27:13 * Berengal can't remember what color "outside" is even
05:27:33 * Berengal vaguely remembers red
05:27:44 <xrfang> :t \x -> x x
05:27:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
05:27:45 <lambdabot>     Probable cause: `x' is applied to too many arguments
05:27:45 <lambdabot>     In the expression: x x
05:28:03 <bremner> Berengal: no, that was Mom. outside is different.
05:28:16 <xrfang> :t \x -> x + x
05:28:17 <lambdabot> forall a. (Num a) => a -> a
05:29:03 <Berengal> bremner: How so? I'm keen on learning more about this "real world". Haskell was supposedly great at it, even having a book about it written
05:29:24 * Berengal wonders if Haskell IS the real world maybe
05:29:29 <Raevel> MAYBE
05:29:49 <Berengal> data RealWorld = Just Haskell | Nothing
05:30:12 <quicksilver> @type (\(x :: forall a . a -> a) -> x x)
05:30:14 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
05:30:43 <Raevel> how nihilistic
05:30:45 <Berengal> Does that function even make sense?
05:30:50 <quicksilver> sure
05:30:55 <quicksilver> it's not very useful though.
05:31:15 <quicksilver> the only (bottoms neglected) parameter it can accept is 'id', and then it returns 'id'
05:31:57 <Berengal> Ah, I see it now
05:32:31 <ordwidr> must all elements of a list be of the same type? what if they all are instances of the same class, can I have a collection of types of the sam eclass?
05:32:38 <Berengal> Usually when I get something I feel a tinge of happiness. This time I just felt a bit sad, however...
05:32:42 <Berengal> Just like the function itself
05:32:58 <quicksilver> ordwidr: yes; you can make a type which represents 'unknown element of this class'
05:33:14 <Raevel> oh i didn't know that
05:33:15 <Berengal> quicksilver: Can't you use existentials?
05:33:29 <quicksilver> Berengal: that is what they are called, yes.
05:33:48 <Berengal> > ["hello", 'a', 52] :: forall a. Show a => [a]
05:33:48 <doserj> http://haskell.org/haskellwiki/Heterogenous_collections
05:33:49 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
05:33:53 <Berengal> :/
05:33:54 <quicksilver> data AnyFoo = forall a . Foo a => MkAnyFoo a
05:34:09 <quicksilver> you can't do implicit conversions to existentials
05:34:16 <quicksilver> you have to explicitly wrap and unwrap.
05:34:21 <Berengal> :(
05:34:32 <Berengal> Hmmm... couldn't UHC do this?
05:34:33 <Deewiant> Or use UHC!
05:34:50 <Berengal> I've been meaning to try it out, but I haven't gotten around to it yet
05:35:46 <quicksilver> UHC has 'first-class' existentials but I don't know if it would do the implicit promotion your list example suggests
05:35:49 <quicksilver> not played with it yet
05:36:29 <Berengal> I've barely touched upon existentials... not really gotten into types except for the basic stuff
05:36:41 <vixey> ["hello", 'a', 52] :: forall a. Show a => [a]  is silly
05:36:45 <vixey> you should just have
05:36:47 <Berengal> Although just the other day ghc told me to enable RankNTypes, so I might be learning...
05:36:52 <vixey> [show "hello", show 'a', show 52]
05:37:05 <quicksilver> it's not silly to not want to type 'show' N times.
05:37:23 <Berengal> vixey: That would just be a list of strings, not a list of arbitrary types that are members of a class
05:37:24 <doserj> and Show contains more than just the function show
05:37:41 <vixey> Berengal: I'm saying 'arbitrary types that are members of a class' is  silly
05:38:14 <quicksilver> no it's not.
05:38:21 <quicksilver> it is sometimes a useful thing to do
05:38:29 <quicksilver> although, it does smell slightly of typeclass abuse.
05:38:33 <quicksilver> (they're not interfaces)
05:38:35 <vixey> in ocaml you make it  () -> string  but in haskell you can just use  String
05:39:39 <Berengal> Hmm.... if you had some class with a method foo :: a -> IO (), that could be useful...
05:39:46 <Berengal> And of course, it's easy to extend that idea
05:40:00 <ordwidr> quicksilver: let's have an example. I have tabespec consisting of column specs and a table that has a tablespec and rows. Each row must be verified against the coloumn specs. How would you model this?
05:43:32 <quicksilver> ordwidr: bunch of functions [a] -> Bool and stuff like that/
05:43:36 <quicksilver> perhaps?
05:43:46 <quicksilver> I probably don't quite have the required context
05:43:47 <vixey> @w80 tentatively
05:43:50 <lambdabot> *** "tentatively" wn "WordNet (r) 2.0"
05:43:50 <lambdabot> tentatively
05:43:50 <lambdabot>      adv : in a tentative manner; "we agreed tentatively on a dinner
05:43:50 <lambdabot>            date"
05:44:05 <ordwidr> quicksilver: think of sql / rdb table definition and rows
05:44:57 <quicksilver> sure, functions [a] -> Bool and Row -> Bool and [Row] -> Bool and so on sounds good to me.
05:45:18 <quicksilver> typeclasses are where you want something to be type-directed - correct instance chosen by the compiler at compile time
05:45:25 <quicksilver> what you're talking about doesn't sound type-directed to me
05:45:28 <quicksilver> ICBW.
05:45:40 <doserj> quicksilver: I guess he is asking for the type for Row
05:45:47 <ordwidr> quicksilver: ok. I come from a java generics background so I might be mislead.
05:46:55 <ordwidr> quicksilver: I can to a data TableDef | StringCol Int Int | IntCol Int | ... and define functions on it. But I want the TabelDef type to be open. So I can add Column Types later on
05:47:20 <quicksilver> it's true that typeclasses do give a way to model "open data"
05:47:33 <quicksilver> but you can also do a lot just using higher order functions
05:47:35 <ordwidr> quicksilver: is there another way?
05:48:07 <quicksilver> a typeclass is just a tuple of functions which you ask the compiler to select for you at compile time
05:48:11 <quicksilver> (based on type inference)
05:48:12 <doserj> manual dictionary passing
05:48:25 <quicksilver> you can also always just use a tuple of functions int eh first place
05:48:33 <quicksilver> which is more flexible - it's not tied into the type inference process.
05:48:44 <ordwidr> quicksilver: do you have an example at hand?
05:48:50 * ordwidr likes higher order functions
05:48:57 <quicksilver> let's pretend that Show is just "show :: a -> String" as its only method
05:49:02 <quicksilver> (not true, but as a simplification)
05:49:09 <ordwidr> ok
05:49:28 <quicksilver> what's the difference between a Show instance for the type T, and a function (T -> String)
05:49:37 <quicksilver> well, the difference is that you are only allowed to have one of the former
05:49:44 <quicksilver> and the compiler selects it automatically
05:49:48 <ordwidr> quicksilver: I see
05:49:48 <quicksilver> when it calculates the type of T.
05:49:57 <quicksilver> the second, (T -> String) you can have as many of as you want.
05:50:02 <quicksilver> and pass them around however you want.
05:50:34 <ordwidr> quicksilver: so in my case  a table def is just a collection of verify functions
05:50:40 <quicksilver> yes
05:50:46 <quicksilver> and it might be more convenient to admit that explicitly
05:50:52 <quicksilver> and just pass around the verify functions
05:51:15 <quicksilver> it comes down to - do you want your tables to have compile-time types, such that the correct verify functions are automatical picked?
05:51:38 <quicksilver> or do you just want to bundle the verify functions together yourself using appropriate combinators, possibly without specific restirctions on the compile-time type?
05:51:56 <quicksilver> it's really about how much you're trying to get teh compiler to do for you.
05:52:13 <quicksilver> You *can* do very clever compiler time tricks, (ab)using GHC's type inference engine to perform calculation / make selection for you.
05:52:17 <ordwidr> quicksilver: actually I want the tabledefinition to be extensible at runtime.
05:52:23 <quicksilver> but it's not always simplest or best for a particular problem.
05:52:32 <quicksilver> ordwidr: sounds like you don't want to be using classes, then.
05:52:39 <quicksilver> functions can always be replaced at runtime.
05:52:41 <ordwidr> quicksilver: but on a compile time set of column types.
05:52:53 <quicksilver> there are hybrid approaches too.
05:53:39 <ordwidr> how would the definition of a tabledef which is a collecion of verify :: a -> Bool look like?
05:54:01 <ordwidr> data TableDef = TableDef [(a -> Bool)] has a "open" type variable, of course
05:54:01 <Berengal> [a -> Bool] ?
05:54:02 <mc__> I'd like to generate a list of triples containing all the possible combinations of the numbers 255, is there an easy way to that? I'm looking for something that can combine lists or so...
05:54:59 <ordwidr> mc__: sequence $ replicate 3 [0..255]
05:55:41 <mc__> ordwidr: that does the trick, thank you!
05:56:17 <Berengal> sequence is magic...
05:56:41 <quicksilver> replicateM 3 [0..255]
05:57:06 <quicksilver> ordwidr: something somewhere has to be parametric over the column types.
05:57:21 <quicksilver> ordwidr: and you may need an existential to make it work over all colmns.
05:57:33 <ordwidr> quicksilver: ah
05:58:40 <ordwidr> quicksilver: existentials are "forall ..."
06:01:38 <quicksilver> ordwidr: well, they're not really :)
06:01:46 <quicksilver> ordwidr: but because of a duality, we use foralls to define them
06:02:00 <quicksilver> it would be more accurate to say that 'the constructors of existentials are forall... "
06:02:29 <ordwidr> quicksilver: I'll look if I can get it working
06:08:38 * EvilTerran has sth like "data Expr = VarE Var | ConE Con | AppE Expr Expr", and is trying to work out the sanest way of adding lambdas
06:08:59 <xrfang> @src forall
06:09:00 <lambdabot> Source not found. stty: unknown mode: doofus
06:09:19 <EvilTerran> "| LamE String Expr" would work, given some kinda deBrujin-index-esque way of associating the Vars with the appropriate LamEs, i guess
06:09:21 <xrfang> quicksilver: is "forall" a function or not?
06:09:38 <quicksilver> xrfang: it is not.
06:09:39 <EvilTerran> forall is special syntax
06:09:43 <quicksilver> it is a keyword.
06:09:59 <quicksilver> EvilTerran: surely LamE Var Expr?
06:10:04 <quicksilver> EvilTerran: if you already have Var.
06:10:13 <vixey> newtype Scope a = Scope a
06:10:19 <xrfang> ok, I thought it is only a non-language word used in output of :t :)
06:10:23 <vixey> | Lam (Scope Term)
06:10:24 <vixey> or
06:10:28 <vixey> | Lam Suggestion (Scope Term)
06:10:35 <vixey> with Suggestion = Maybe Name
06:10:38 <quicksilver> there are cleverer tricks you can do certainly.
06:11:12 <vixey> @go epigram i am a name not a number
06:11:14 <lambdabot> http://www.e-pig.org/downloads/notanum.pdf
06:11:15 <lambdabot> Title: I am not a number: I am a free variable
06:11:27 <vixey> @go epigram i am not a number I am a free variable
06:11:28 <lambdabot> http://www.e-pig.org/downloads/notanum.pdf
06:11:28 <lambdabot> Title: I am not a number: I am a free variable
06:11:41 <EvilTerran> quicksilver, yeah, LamE Var Expr would be the obvious one; whatever i do, i guess i'm going to have to deal with renaming
06:12:09 <vixey> EvilTerran no you don't have to
06:12:09 <quicksilver> EvilTerran: there are very clever tricks with variable binding
06:12:18 <vixey> and you shouldn't
06:12:23 <quicksilver> EvilTerran: which vary from the very clever to the mind boggling clever.
06:12:25 <vixey> it is the #1 place for bugs
06:12:32 <quicksilver> EvilTerran: vixey is trying to point you at them :)
06:12:38 <quicksilver> I was just pointing at the most direct way.
06:12:42 <EvilTerran> it's downloading
06:12:44 <dddddd> what does iot mean to use (!) on data fields? that the data will be created directly when constructed rather than lazily when needed? example: data Tree = !Leaf | Node !a !Tree !Tree
06:12:53 <EvilTerran> durn wireless internet
06:12:59 <quicksilver> dddddd: somehting like that.
06:13:09 <quicksilver> dddddd: !Leaf is meaningless there.
06:13:18 <quicksilver> dddddd: ! goes before fields, not alternatively.
06:13:20 <EvilTerran> vixey, that paper looks pretty useful, thanks :)
06:13:23 <quicksilver> alternatives.
06:14:26 <kadaver> ok
06:14:38 * EvilTerran , when he said "renaming", included such things as the "lifting" of variable numbers necessary for deBrujin notation, incidentally. that wasn't very well-phrased. :P
06:16:22 <xrfang> > data Pair a b = Pair a b
06:16:23 <lambdabot>   <no location info>: parse error on input `data'
06:16:49 <xrfang> how to use "data" in ghci? :S
06:17:01 <EvilTerran> you can't, unfortunately
06:17:07 <vixey> Lam = Lam (Lam -> Lam) works for evalutaion but it sucks for anything else
06:17:18 <doserj> xrfang: put it in a file and load it
06:17:23 <EvilTerran> without making a .hs file with the definitions in it
06:17:40 <EvilTerran> vixey, yeah, Mu Endo's really kinda limited for actually doing anything with
06:18:52 <xrfang> ok, tks doserj, EvilTerran
06:20:16 <xrfang> :l t.hs
06:20:21 <xrfang> oops.
06:34:36 <ordwidr> quicksilver: how can I define a List of functions verify :: a -> Bool ?
06:35:00 <ordwidr> quicksilver: I read about existintially quantified types but I don't get how to apply them on a function
06:35:35 <ivanm> ordwidr: [(a -> Bool)] is a list of functions
06:35:53 <ordwidr> ivanm: yes, I want a list of such functions for different types a
06:35:56 <EvilTerran> ?type [(==0), (/=1), \x -> x `mod` 3 > 0]
06:35:57 <lambdabot> forall a. (Integral a) => [a -> Bool]
06:36:07 <PeakerWork> ordwidr: why?
06:36:24 <PeakerWork> ordwidr: once you lose the type of the arg you won't be able to call it with any arg
06:36:44 <PeakerWork> ordwidr: unless you store (a, a->Bool) in which case you might as well just store the Bool itself
06:37:01 <quicksilver> PeakerWork: it's more like ([a], a -> Bool)
06:37:25 <ordwidr> PeakerWork: I want to model the following: a tablespec consists of column specs and a row shall be verifieable against a table spec.
06:37:28 <PeakerWork> quicksilver: I meant: [(a, a->Bool)]
06:37:34 <quicksilver> PeakerWork: it's a model of a table with columns of unknown type, but verifiable conditions
06:37:46 <quicksilver> PeakerWork: I was just pointing out there is more than one 'a' per condition 'a -> Bool'
06:37:48 <idnar> PeakerWork: [([a], a -> Bool)]
06:37:50 <ivanm> PeakerWork: well, maybe you don't _want_ to evaluate the functions yet...
06:37:54 <PeakerWork> quicksilver: oh
06:37:58 <ivanm> especially if they're unsafe... >_>
06:38:14 <ordwidr> ivanm: I hope they are :-)
06:38:28 <ivanm> ordwidr: you _want_ unsafe functions?
06:38:29 <idnar> @type [(==0), (/=1), \x -> x `mod` 3 > 0, (=="foo")]
06:38:30 <lambdabot>     No instance for (Integral [Char])
06:38:31 <lambdabot>       arising from a use of `mod' at <interactive>:1:21-29
06:38:31 <lambdabot>     Possible fix: add an instance declaration for (Integral [Char])
06:38:32 <PeakerWork> ivanm: The Bool is a lazy thunk anyway..
06:38:37 <idnar> @type [(==0), (/=1), \x -> x `mod` 3 > 0, (=="foo")] :: [forall a. a -> Bool]
06:38:37 <ivanm> do I dare ask why? :s
06:38:38 <lambdabot>     Could not deduce (Num a) from the context ()
06:38:38 <lambdabot>       arising from the literal `0' at <interactive>:1:4
06:38:38 <lambdabot>     Possible fix:
06:38:39 <ivanm> PeakerWork: yeah
06:38:49 <idnar> hmm
06:38:57 * ivanm loves lambdabot's possible fix
06:39:02 <EvilTerran> idnar, you can't have a forall as a type parameter
06:39:08 <EvilTerran> except if the type is ->
06:39:10 <EvilTerran> iirc
06:39:12 <ordwidr> ivanm: no the are safe
06:39:28 <ordwidr> EvilTerran: what is -> for a type?
06:39:28 <ivanm> ordwidr: then why do you want a list of functions taking in different input values?
06:39:37 <ordwidr> ivanm: yes. basically
06:39:45 <ivanm> ordwidr: I asked _why_ ;-)
06:39:58 <idnar> EvilTerran: why is it a parameter?
06:40:03 <PeakerWork> > [] :: [forall a. a -> Bool]
06:40:05 <ivanm> the only possible thing I can think of is if you then have a list of different types using forall and then you want to zip them...
06:40:05 <lambdabot>       No instance for (Show (forall a. a -> Bool))
06:40:06 <lambdabot>        arising from a use ...
06:40:15 <ordwidr> ordnungswidrig: because a table spec consists of a list of _different_ column specs
06:40:18 <ivanm> PeakerWork: :/
06:40:19 <EvilTerran> ordwidr, idnar, i mean, you can have "(forall (...). ...) -> (forall (...). ...)", but not sth like Maybe (forall (...). ...)
06:40:23 <EvilTerran> (again, iirc)
06:40:28 <idnar> hmm
06:40:31 <quicksilver> you can
06:40:37 <quicksilver> you just need -XImpredicativeTypes
06:40:41 <idnar> well, Peaker's counterexample demonstrates otherwise
06:40:42 <quicksilver> or whatever the extension is called.
06:40:45 <ivanm> ordwidr: ummmm..... what?
06:40:48 <idnar> (I guess?)
06:41:03 <EvilTerran> ah, there would be an extension for it :P
06:41:07 <idnar> @type [(==0) :: forall a. a -> Bool]
06:41:08 <lambdabot>     Could not deduce (Num a) from the context ()
06:41:08 <lambdabot>       arising from the literal `0' at <interactive>:1:4
06:41:08 <lambdabot>     Possible fix:
06:41:14 <idnar> hrm, no
06:41:39 <idnar> I don't want "forall", I want "exists"
06:41:41 <ordwidr> ivanm: a row is a collection of different field values and the rows fields shall be verifiable against the table's columns specs.
06:42:06 <ivanm> wrt what?
06:42:24 <ivanm> and as PeakerWork pointed out, how do you hope to use the functions afterwards?
06:42:56 <Berengal> ordwidr: Perhaps a concrete example would help?
06:43:18 <ordwidr> Berengal: I find tables columns and rows rather concrete
06:43:44 <Berengal> ordwidr: But how would an example table look like?
06:43:44 <ivanm> ordwidr: table columns in _what_?
06:43:47 <cooldude127> hey guys why is this code giving me an "Illegal instance declaration" error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4128#a4128
06:44:06 <quicksilver> cooldude127: haskell98 has some very simplistic restrictions on instance shape
06:44:13 <quicksilver> cooldude127: "Vector Double" is not permitted.
06:44:23 <quicksilver> cooldude127: turn on FlexibleInstances
06:44:30 <quicksilver> I think the error message should have suggested it.
06:44:30 <cooldude127> how do i do that?
06:44:38 <cooldude127> oh ok
06:44:48 <cooldude127> just use an argument to GHCi?
06:44:56 <quicksilver> {-# LANGUAGE FlexibleInstances #-}
06:44:59 <quicksilver> as the first line of the file
06:45:01 <cooldude127> oh even better
06:45:05 <ordwidr> Berengal: a person table spec will sth. like a [("name", StringField 10),("birthday", DateField)]
06:45:41 <ordwidr> Berengal: a table will consist of a table spect and a list of rows
06:45:48 <ivanm> ordwidr: records? algebraic datatypes?
06:46:27 <ivanm> note that you'd already have to use algebraic datatypes for StringField Int and DateField
06:46:59 <ordwidr> ivanm: that was just an example. Whatever will fit my needs better I'll use. A want to be able to define ant alter table specs at runtime. I want to have a open set of column types.
06:47:17 <ivanm> what are you hoping to achieve here?
06:47:33 <ordwidr> ivanm: world domination?
06:47:40 <Berengal> Good answer...
06:47:48 <ordwidr> ivanm: think of a relational database
06:48:55 <Berengal> Hmm.... HLists?
06:49:06 <ordwidr> Berengal: I thought of that
06:49:26 <vixey> no
06:49:28 <vixey> GADT
06:49:33 <vixey> data Base where
06:49:37 <vixey>  Birthday :: Date -> Base
06:49:43 <vixey> or
06:49:51 <ordwidr> "data Base"
06:49:53 <vixey> data Base t where Birthday :: Base Date
06:49:54 <ordwidr> *g*
06:50:02 <vixey> 'Birthday' is a label then
06:50:11 <edwardk> ordwidr: yeah i started trying to figure out where she was going with the pun myself =)
06:50:15 <ordwidr> vixey: but this isn't extensible at runtime
06:50:23 <vixey> nothing is extesible at runtime
06:50:57 <quicksilver> if you do it in the type system it won't be extensible at runtime
06:50:59 <quicksilver> essentially.
06:51:03 <Berengal> If you want runtime types, you better start implementing a runtime type system...
06:51:03 <vixey> so pairs are  Pair where Both :: Base t -> t -> Pair
06:51:13 <edwardk> quicksilver: unless you make a big dictionary like abstraction
06:51:21 * ordwidr is confused
06:51:30 <vixey> then you have  [(Name, 10),(Birthday, 22/10/05)]
06:51:37 <vixey> or whatever..
06:51:50 <edwardk> quicksilver: i mean there is always the ICanTasteTheAmazing design pattern: http://www.lostechies.com/blogs/jimmy_bogard/archive/2009/04/21/the-infinite-extensibility-engine.aspx
06:52:53 <ordwidr> I java I'd have interfaces coldef and colvalue, implement StringColDef StringValue and IntColDef and IntColValue and a table is basically list of ColDefs and a List of List of ColValues
06:53:25 * edwardk goes and mines the logs to see what the heck folks are talking about
06:53:28 <quicksilver> java doesn't let you invent new types at runtime either.
06:53:35 <ivanm> edwardk: we don't know either ;-)
06:53:44 <vixey> lol
06:53:47 <vixey> edwardk great link
06:53:57 <ordwidr> quicksilver: yes. You got me wrong. The type are fixed at compile time. But the table definitions shall not
06:53:57 <ivanm> edwardk: ordwidr is wanting to have a list of [forall a. a -> Bool]
06:54:05 <ordwidr> ivanm: ah
06:54:19 <quicksilver> oh, OK.
06:54:23 <quicksilver> That helps a bit, yes :)
06:54:28 <edwardk> ivanm: erm, wouldn't that be um, isomorphic to [Bool] ? =)
06:54:33 <vixey> ordwidr is there a full desc. of what you're trying to code?
06:54:38 <ivanm> edwardk: *shrug*
06:54:42 <ordwidr> vixey: no
06:54:45 <ivanm> PeakerWork already brought that up
06:55:29 <edwardk> since the functions can consume any a they can't do anything with any of them other that force them with seq
06:55:41 <edwardk> so not quite isomorphic to Bool
06:56:00 <edwardk> but pretty darn close in the absence of silly efficiency tricks ;)
06:56:21 <ivanm> edwardk: I _think_ what he wants is a whole bunch of functions that take in some parameter and return a Bool
06:56:40 <edwardk> ordwidr: what are you trying to accomplish?
06:56:43 <vixey> ordwidr :(
06:56:44 <ivanm> e.g. [Int -> Bool, Bool -> Bool]
06:56:47 <ordwidr> ivanm: this was a suggestion by quicksilver as an alternative to using fundeps
06:56:48 <ivanm> edwardk: good question ;-)
06:56:54 <ivanm> something about implementing a table or something
06:57:04 <quicksilver> a table in the RDBMS sense.
06:57:09 <quicksilver> that is, rows are tuples
06:57:15 <ordwidr> ivanm: I'll should post the problem definition in hpaste
06:57:17 <quicksilver> a table has a "type" - that is, the types of its rows.
06:57:23 <edwardk> ah fair enough
06:57:34 <quicksilver> and additionally some constraints
06:57:42 <quicksilver> which much satistfied by all tuples (rows)
06:57:52 <ivanm> so how do the various Haskell -> RDBMS libs do this?
06:57:53 <quicksilver> which are the -> Bool functions under discussion.
06:58:06 <ordwidr> I tried data Tabledef = TableDef [forall a . a -> Bool]
06:58:11 <quicksilver> ivanm: the clever oness do it in the type system, assuming the scheme is known at compile time
06:58:14 <edwardk> my approach for that is to use a sequence of some row type.
06:58:18 <ivanm> quicksilver: *nod*
06:58:24 <vixey> yes problem def!!
06:58:25 <quicksilver> ivanm: however, ordwidr doesn't want the schema to be fixed at compile time
06:58:27 <edwardk> ordwidr: don't go there, its not the direct direction
06:58:43 <quicksilver> so therefore you can't encode that part of the problem in the type system, it's not static enough.
06:59:02 <Berengal> edwardk: direct direction?
06:59:06 <ordwidr> quicksilver: But haskell forces me to follow to the types.
06:59:23 <edwardk> then you're stuck with something silly like: Seq (Col -> Value)
06:59:23 <gcollins> does anyone know if there's a way to detect whether you're in GHCI using the C preprocessor? I tried "{-# LANGUAGE CPP #-}" and "#ifdef GHCI" but it doesn't work. Do I have the right magic incantation?
06:59:27 <Berengal> ordwidr: You could always use values...
06:59:40 <edwardk> er not the right direction
06:59:52 <|xrfang|> test
07:00:06 <ordwidr> |xrfang|: failed
07:00:41 <quicksilver> |xrfang|: I can't hear you, can you speak up?
07:00:59 <ivanm> ordwidr, quicksilver: who are you talking to?
07:01:00 <ivanm> ;-)
07:01:17 <edwardk> ordwidr: ok, rewinding, why do you need these dynamic table things?
07:01:48 <ordwidr> edwardk: the simple answer. Assume I shall implement a relational database.
07:02:18 <edwardk> ordwidr: ok, then you want some representation that can be efficiently represented on disk
07:02:37 <edwardk> ordwidr: the reason i asked was because i was looking for how memory vs. disk oriented you had to be
07:03:16 <ordwidr> edwardk: if you consider this part of the problem
07:04:49 <ordwidr> edwardk: I looked at HDBC to get a feeling for a possilbe API. You'll find fetchRow :: Statement -> IO (Maybe [SqlValue])
07:05:09 <mib_983bj51u> o hai der
07:05:14 <mib_983bj51u> i like cake
07:05:43 <ordwidr> ordnungswidrig: for HDBC SqlValue is a ADT, i.e. a closed type. I wan't to work with open types. In a sense that a user of the API can define it's own types (at compile time)
07:05:51 <vixey> is there a problem desc. yet??
07:06:26 <ordwidr> vixey: no.
07:06:29 <vixey> :(((
07:06:31 <vixey> you said!
07:06:33 <edwardk> ordwidr: i did this for a column store a while back, i don't have the api handy, but rederiving parts of it. what i defined was a small set of column types that i could marshal back and forth, ala Binary. and you needed an explicit enumeration of them
07:07:18 <edwardk> ordwidr: otherwise you have no way to figure out how to read the column off of disk, somewhere somehow your database needs to know all of the possible kinds of columns.
07:07:50 <edwardk> not their names, but at least the types that they can contain
07:08:02 <edwardk> i.e. Int, Bool, String, whatever
07:11:24 <ordwidr> vixey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4131#a4131
07:11:26 <edwardk> too bad TypeReps can't be made into instances of Binary or this could be interesting
07:12:03 <ordwidr> edwardk: yes, this set of column types is fixed at compile time.
07:12:12 <ordwidr> edwardk: but it should be extensible at runtime
07:12:27 <edwardk> ordwidr: erm, which is it? =)
07:12:29 <ordwidr> edwardk: sorry. It should be extensible at *COMPILE* time
07:12:33 <edwardk> hahaha
07:12:34 <edwardk> ok
07:12:38 <vixey> o_o
07:12:51 <Berengal> So... you should be able to add new ones in the source?
07:12:59 <ordwidr> having a ADT for columns is not open.
07:13:01 <ordwidr> Berengal: yes.
07:13:02 <edwardk> then i would say your answer is to use something like the 'ala carte' approach to specify your column type
07:13:14 <ordwidr> edwardk: à la carte?
07:13:17 <edwardk> ordwidr: or you can use an existential
07:14:23 <ordwidr> edwardk: I have a solution for the colspec => colvalue "problem" using fundeps. Can I add existentials to make a list of colspecs?
07:14:29 <pozic> Is there a non-portable way to make non-H98 names, like a^-1, instead of aInverse?
07:14:57 <ordwidr> edwardk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4119#a4124
07:15:19 <ordwidr> edwardk: I meant type families. The solution with fundeps works as well.
07:15:40 <edwardk> data Column = forall a. (Typeable a, Binary a) => Column [a] -- would give you a column store oriented representation, but it vioilates your spec, because you'd join columns together rather than store ISAM style in the row
07:16:15 <ordwidr> edwardk: ignore storage for now.
07:16:35 <vixey> ordwidr: ADT can be 'open' from one point of view and closed from another
07:16:57 <ordwidr> edwardk: ISAM means "rows go together"?
07:17:08 <edwardk> ordwidr: the other option is to define your 'ADT' using the data types ala carte approach, which may be better for your use, but is still an ADT
07:17:34 <ordwidr> edwardk: what's the ala carte? do you have a link?
07:17:46 <edwardk> ordwidr: yeah. a column store stores columns separately and 'zips' them together, an ISAM store stores a row as a monolithic entity and stores b-trees that index int it
07:17:50 <ordwidr> vixey: how can they be open?
07:17:57 <vixey> ordwidr:  String column a min and max lenght shall be specified  --  you cannot do this in the type system
07:18:00 <edwardk> http://lambda-the-ultimate.org/node/2700
07:18:05 <pozic> ordwidr: google data types ala carte
07:18:07 <EvilTerran> ?go data types a la carte
07:18:08 <lambdabot> http://lambda-the-ultimate.org/node/2700
07:18:08 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
07:18:09 <vixey> ordwidr: the length of the string I mean.. but you can check that at runtime
07:18:23 <ordwidr> vixey: that's sufficient
07:18:23 <vixey> ordwidr: just pointing out that is one thing which /must/ be dynamically checked
07:18:39 <ordwidr> vixey: yes. of course.
07:19:12 <ordwidr> edwardk: I remember having read (and forgot) this pape
07:20:32 <edwardk> he idea there is you encode your 'type of valid columns' as a big data ADT in its own right using a combinator. so you'd have (using a modified version of the approach) something like type ValidColumn = (Int :*: String :*: Char :*: ..) somewhere, then use that and some HList magic
07:20:49 <vixey> ordwidr: it is a "table api"
07:20:56 <ordwidr> vixey: yes.
07:20:59 <xrfang> what does this mean:
07:21:01 <vixey> ordwidr: so once you have got tables -- what operations on them?
07:21:08 <xrfang> firstElement :: [a] -> Maybe a
07:21:10 <xrfang> firstElement [] = Nothing
07:21:11 <vixey> I guess stuff like sorting by column.. printing reading from a file...
07:21:12 <xrfang> firstElement (x:xs) = Just x
07:21:25 <vixey> but the thing is, which operations you have could influence the desing
07:21:35 <edwardk> the reason I mentioned the 'Typeable/Binary' version is that it is more flexible in a lot of ways
07:21:50 <Berengal> xrfang: What exactly don't you understand?
07:21:55 <xrfang> specifically, what is Maybe Nothing and Just?
07:22:02 <xrfang> I keyin the above in a file
07:22:04 <xrfang> run it
07:22:16 <xrfang> firstElement [1,2,3]
07:22:17 <ordwidr> vixey: insert, delete, query on rows. add columns, remove columns.
07:22:23 <vixey> query ?
07:22:25 <xrfang> it says "Just 1" which is quite mysterious
07:22:26 <vixey> like SQL
07:22:41 <Berengal> "Maybe a" is a type with two constructors: Nothing and Just a
07:22:41 <vixey> or like sort of pattern matching on them
07:22:45 <edwardk> by storing columns separately and zipping columns, and just relying on the ability to serialize due to being Binary or Storable and that you can cast back out using Typeable (and the fact that you can compare with, say, Ord) you should be good to go, and won't suffer the ala carte overhead
07:22:48 <ordwidr> vixey: like sql
07:22:58 <vixey> that's a LOT of work
07:22:59 <xrfang> yes berengal, I understand this "literally".
07:22:59 <daf> I think CRUD is the term you're looking for
07:23:15 <ordwidr> daf: :-)
07:23:17 <Berengal> xrfang: So if you have for example a value of type Maybe Int it is either Nothing or Just someInt
07:23:22 <xrfang> in the above, I can "uderstand" the type declaration
07:23:34 <xrfang> but I don't understand why we need "Just"
07:23:41 <xrfang> Maybe and Nothing seems ok.
07:23:47 <Berengal> xrfang: To separate it from Nothing
07:23:51 <ordwidr> vixey: actually it's my challenge to learn haskell
07:23:51 <EvilTerran> xrfang, you need Just to distinguish between an "a" and a "Maybe a"
07:23:54 <gueux> I am on linux, how can I compile my program to windows?
07:23:54 <EvilTerran> ?type Just
07:23:54 <mofmog> whats the sop for making a literate haskell file?
07:23:55 <lambdabot> forall a. a -> Maybe a
07:23:55 <Berengal> xrfang: Both are of the same type
07:24:13 <mofmog> as in, what tools do people normally use?
07:24:20 <xrfang> Maybe a is a *type* not a *value* right?
07:24:29 <EvilTerran> yes
07:24:35 <Berengal> xrfang: Actually, Maybe is a type constructor...
07:24:37 <vixey> ordwidr: Do you know 'data' yet?
07:24:40 <vixey> for example
07:24:43 <vixey> data Maybe a where
07:24:45 <vixey>  Nothing :: Maybe a
07:24:47 <vixey>  Just :: a -> Maybe a
07:24:58 <xrfang> I am reading data, but don't understand it at all!
07:25:05 <vixey> xrfang: (on the left of :: is a value, on the rigth of :: is a type)
07:25:15 <xrfang> for example, data Pair a b = Pair a b
07:25:22 <xrfang> this is the first example I see
07:25:26 <EvilTerran> xrfang, Nothing and, say, 42 have different types, so you need to wrap the 42 in a Just if you want to use it somewhere where a Nothing might be valid
07:25:33 <EvilTerran> ?type Just 42
07:25:34 <lambdabot> forall t. (Num t) => Maybe t
07:25:37 <EvilTerran> ?type Nothing
07:25:38 <lambdabot> forall a. Maybe a
07:26:02 <xrfang> EvilTerran:  is there a "null" in haskell?
07:26:07 <EvilTerran> no
07:26:12 <edwardk> @type Maybe
07:26:13 <lambdabot> Not in scope: data constructor `Maybe'
07:26:14 <Berengal> xrfang: Nothing is the closest you get
07:26:16 <edwardk> er
07:26:18 <Berengal> @src Maybe
07:26:18 <edwardk> @src Maybe
07:26:18 <lambdabot> data Maybe a = Nothing | Just a
07:26:19 <lambdabot> data Maybe a = Nothing | Just a
07:26:31 <EvilTerran> xrfang, given a type "t", the type "Maybe t" is analogous to t-but-with-nulls
07:26:32 <xrfang> if I do head [], I get an error
07:26:46 <edwardk> xrfang: you use the 'Maybe' type to wrap your value when you want it to have the possibility of having Nothing
07:26:48 <xrfang> I think if I can write my_head,
07:26:51 <EvilTerran> xrfang, well, there's bottom, but it's not like null
07:26:56 <xrfang> e.g. my_head [] = Nothing
07:26:59 <vixey> xrfang: myHead
07:27:00 <edwardk> > listToMaybe []
07:27:01 <EvilTerran> > undefined
07:27:02 <lambdabot>   Nothing
07:27:03 <lambdabot>   * Exception: Prelude.undefined
07:27:05 <xrfang> my_head (x:xs) = x
07:27:12 <edwardk> > listToMaybe "Hello"
07:27:13 <lambdabot>   Just 'H'
07:27:22 <edwardk> @type listToMaybe
07:27:22 <EvilTerran> xrfang, that'd have to be "my_head (x:xs) = Just x"
07:27:23 <xrfang> oh my...
07:27:23 <lambdabot> forall a. [a] -> Maybe a
07:27:28 <Berengal> @type Nothing
07:27:28 <edwardk> @src listToMaybe
07:27:29 <lambdabot> forall a. Maybe a
07:27:29 <lambdabot> listToMaybe []        =  Nothing
07:27:29 <lambdabot> listToMaybe (a:_)     =  Just a
07:27:31 <Berengal> @type 5
07:27:33 <lambdabot> forall t. (Num t) => t
07:27:42 <edwardk> listToMaybe is 'safe head'
07:27:53 <EvilTerran> xrfang, the thing is, each branch of a function definition has to have the same type
07:27:58 <vixey> you should call it    myHead    in Haskell
07:27:59 <xrfang> EvilTerran: you mean, Nothing and a are not same type, you want to make it Just a to be same type?
07:28:10 <EvilTerran> ?type let myHead [] = Nothing in myHead
07:28:11 <lambdabot> forall t a. [t] -> Maybe a
07:28:16 <EvilTerran> ?type let myHead (x:xs) = x in myHead
07:28:17 <lambdabot> forall t. [t] -> t
07:28:26 <Berengal> xrfang: You can view Maybe as a car...
07:28:29 <vixey> (why? because that's what everyone does)
07:28:33 <Berengal> Now, a car has a trunk
07:28:38 <Berengal> The trunk may or may not be empty
07:28:44 <Berengal> But the trunk itself will always be there
07:29:05 <Berengal> For you to be able to pass around Maybe values you need something to pass around
07:29:09 <wjt> @let popTheTrunk = fromJust
07:29:11 <lambdabot>  Defined.
07:29:18 <daf> :D
07:29:20 <Berengal> Which is why you need the Maybe in the first place
07:29:25 <wjt> > popTheTrunk (Just "sup dawg")
07:29:27 <lambdabot>   "sup dawg"
07:29:33 <Berengal> Now, you're passing around trunks
07:29:34 <EvilTerran> xrfang, and, in order for branches of a function to have the same type, they have to return things of the same type
07:29:39 <edwardk> > popTheTrunk Nothing
07:29:41 <lambdabot>   * Exception: Maybe.fromJust: Nothing
07:29:44 <Berengal> Well, actually, a car with a trunk
07:29:48 <Berengal> Anyway
07:30:08 <EvilTerran> xrfang, Nothing :: Maybe a, so, if you want to be able to return Nothing, you have to use Just (:: a -> Maybe a) to wrap any non-Nothing values you're returning
07:30:10 <yakov> hey
07:30:11 <Berengal> Since you're passing around a car with something inside, it's obviously of a different type than a pure value
07:30:23 <Berengal> Which is why you have to wrap it around something
07:30:32 <edwardk> > popTheTrunk $ popTheTrunk  $Just  $ Just "yo dawg..."
07:30:33 <lambdabot>   "yo dawg..."
07:30:40 <Berengal> So you have data Car a = EmptyTrunk | TrunkWithValue a
07:30:44 <wjt> > iterate popTheTrunk
07:30:46 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
07:30:46 <lambdabot>        Ex...
07:31:00 <daf> edwardk: I can put a car in my car? :O
07:31:34 <edwardk> daf: yeah, thats the benefits of Maybe over null ;)
07:31:36 <Berengal> I hope everyone's sufficiently confused now
07:31:43 <vixey> Mu Maybe
07:32:04 <Berengal> @type undefined :: Mu Maybe
07:32:06 <lambdabot> Mu Maybe
07:32:08 <edwardk> vixey: ala 'Nat' =)
07:32:11 <wjt> Berengal: i think the trunk analogy may have been doomed from the start :)
07:32:13 <edwardk> er aka
07:32:21 <Berengal> Analogies are like cars...
07:32:36 <leimy_> Berengal: they run out of gas?
07:32:40 <Berengal> Although the trunk is a nice analogy to the box, which seems to be the default Maybe analogy...
07:32:43 <edwardk> berengal: hrmm, you can put an analogy in your analogy?
07:32:45 <EvilTerran> ?type iterate (popTheTrunk . out)
07:32:46 <lambdabot> Mu Maybe -> [Mu Maybe]
07:33:01 <leimy_> On a scale of 1 to 10 how would you rate scales of 1 to 10
07:33:04 <Berengal> edwardk: I just did. I put the trunk in the car
07:33:12 <vixey> 0
07:33:15 <Taejo> leimy: -pi
07:33:25 <EvilTerran> sqrt (-2)
07:33:40 <quicksilver> yo dawg i heard you like confusing people so I put an analogy in your analogy so you can confuse us while you confuse us.
07:33:57 <Berengal> > fix error
07:33:59 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:34:05 <Taejo> leimy: aka, what is #haskell's favourite number outside of [1..10]
07:34:09 <edwardk> quicksilver: sounds like every monad tutorial ever
07:34:25 <edwardk> berengal: i'd challenge that that error is not fixed ;)
07:34:31 <burp_> lol
07:34:45 <wjt> ?type fix (popTheTrunk . out)
07:34:46 <lambdabot> Mu Maybe
07:35:09 <Berengal> edwardk: So just what is the least fixed point of error?
07:35:46 <Taejo> Berengal: error x = _|_ for all x, so _|_ is a fixed point of error
07:36:17 <Berengal> Taejo: And fix error = _|_, right?
07:36:26 <edwardk> clearly fix should get rid of the error ;)
07:36:35 <Berengal> @type fix
07:36:36 <lambdabot> forall a. (a -> a) -> a
07:36:37 <Berengal> @type error
07:36:38 <lambdabot> forall a. [Char] -> a
07:36:39 <Berengal> @type fix error
07:36:41 <lambdabot> [Char]
07:37:26 <vixey> _|_ is the fixed point of most thing.s..
07:37:34 <Taejo> Berengal: fix f is the least fixed point of f; _|_ is *a* fixed point of error, but it is also the least of all values, so it must be the least fixed point. thus fix error = _|_
07:37:39 <Taejo> vixey: *most*?
07:37:41 <doserj> > fix error
07:37:43 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:37:53 <vixey> I think b_jonas proved to be a non _|_ fixed point the function must look like  f <something> = <Constructor> <something>
07:38:14 <xrfang> sorry I was away, my further question is, say I write this:
07:38:22 <xrfang> myHead [] = Nothing
07:38:36 <xrfang> myHead x:xs = Just x
07:38:53 <xrfang> now I say a = myHead [1, 2, 3, 4, 5]
07:39:07 <xrfang> a will be "Just 1", right? then can I compare a with a number??
07:39:24 <Berengal> xrfang: You need to unwrap it using a case statement
07:39:26 <vixey> that's wrong xrfang
07:39:34 <Berengal> There are functions that do this for you
07:39:35 <edwardk> xrfang: its Just 1. you cna compare wiht a number by wrapping that number in a Just, or you can map the comparison into the maybe monad.
07:39:37 <Berengal> @type maybe
07:39:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:40:07 <edwardk> > Just 1 <= Just 3
07:40:08 <lambdabot>   True
07:40:22 <iago_> > Nothing <= Just 1
07:40:23 <lambdabot>   True
07:40:24 <Berengal> > maybe "No matches found" id $ lookup 2 [(1, "hello"), (2, "hi")]
07:40:24 <edwardk> > fmap (<= 3) (Just 2)
07:40:26 <lambdabot>   Just True
07:40:26 <lambdabot>   "hi"
07:40:34 <Berengal> > maybe "No matches found" id $ lookup 3 [(1, "hello"), (2, "hi")]
07:40:35 <edwardk> > fmap (<= 3) Nothing
07:40:35 <lambdabot>   "No matches found"
07:40:36 <iago_> > Just 1 <= Nothing
07:40:37 <lambdabot>   Nothing
07:40:38 <lambdabot>   False
07:40:50 <iago_> > Just (-1= <= Nothing
07:40:51 <lambdabot>   <no location info>: parse error on input `='
07:40:54 <iago_> > Just (-1) <= Nothing
07:40:55 <lambdabot>   False
07:41:10 <iago_> all is greater than Nothing
07:41:13 <edwardk> fmapping the comparison gives you the 'semantics' of having null cascade upwards through comparisons like 'NaN'
07:41:27 <yitz> > unsafeInterleaveIO Berengal edwardk
07:41:28 <lambdabot>   Not in scope: `unsafeInterleaveIO'Not in scope: data constructor `Berengal'...
07:41:36 <xrfang> maybe monad :( ok, I give up for now.
07:41:47 <edwardk> yitz: =)
07:41:49 <xrfang> next question still about data
07:41:53 <Berengal> xrfang: Nevermind the Maybe monad
07:41:53 <edwardk> xrfang: no no you're doing well
07:42:02 <Berengal> Just use case expressions at first
07:42:05 <edwardk> @type fmap
07:42:05 <Berengal> Monads are for later :)
07:42:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:42:09 <xrfang> I understand I should go step by step ;)
07:42:12 <Berengal> (Functors come first)
07:42:16 <xrfang> data Pair a b = Pair a b
07:42:23 <Berengal> Well, before monads
07:42:51 <xrfang> this example, the tutorial says that the Pair at the RHS is a constructor, it could be any name not necessarily same as the LHS type name, right?
07:43:08 <Berengal> xrfang: Right. Just look at Maybe once more:
07:43:11 <Berengal> ?src Maybe
07:43:12 <lambdabot> data Maybe a = Nothing | Just a
07:43:33 <edwardk> @src Maybe fmap
07:43:33 <lambdabot> fmap _ Nothing       = Nothing
07:43:34 <lambdabot> fmap f (Just a)      = Just (f a)
07:43:35 <xrfang> but if I read this I have MORE question :p. e.g. what is "|"?
07:43:58 <Berengal> xrfang: The "|" means you can have more than one constructor
07:43:59 <edwardk> xrfang: | means that you can define a Maybe using either the 'Just' tag or the Nothing tag.
07:44:38 <Berengal> For example: data Car = Truck Driver Load | NormalCar Driver Passenger | TinyCar Driver
07:45:05 <kadaver> wow
07:45:13 <Berengal> ADTs are like cars :)
07:46:00 <xrfang> ok | is like | in C.
07:46:19 <wjt> well not really
07:46:23 <Berengal> xrfang: Not exactly, no. C doesn't have ADTs
07:46:29 <wjt> it's more like union {} in C :))
07:46:30 <xrfang> ADT is?
07:46:45 <xrfang> Abstract Data Type?
07:46:56 <Berengal> xrfang: Algebraic Data Type
07:47:04 <xrfang> ok,
07:47:08 <Berengal> To get somewhat technical, do you know what a product type is?
07:47:18 <xrfang> you used ?src and @src to talk to bot, what's the difference?
07:47:23 <wjt> no difference
07:47:39 <xrfang> Berengal, I don't know what do you mean "product type"?
07:47:54 <Berengal> A product type is a type that is a "product" of other types
07:48:13 <Berengal> For example, the type (Integer, Char) is the product of Integer and Char, and in that order
07:48:28 <Berengal> It is different from (Char, Integer), because the types are in different order...
07:48:50 <Berengal> You can chain as many of these types together as you want, so (Int, Int, Int, Int, Int) is a valid type
07:49:06 <Berengal> (Usually, outside of Haskell, this'll be written Int*Int*Int*Int etc)
07:49:25 <xrfang> hehe, I thought product type is type of a product, like a TV set :p
07:49:42 <Berengal> xrfang: Discard that notion :)
07:49:53 <ordwidr> interesting: http://homepages.cwi.nl/~ralf/HList/paper.pdf uses a table API as an example.
07:50:09 <Berengal> Anyway, did you get it?
07:50:17 <Berengal> You construct new types by combining old types
07:50:18 <xrfang> what is the purpose of "product type" is my future question, but I want to stop for now, otherwise it is like random walk :)
07:50:25 <xrfang> the maze of haskell
07:50:38 <xrfang> I know what is product type now, but I don't know WHY we need that
07:50:41 <Berengal> The purpose is simple: To store more than one value in one value
07:50:53 <Berengal> For example pairs
07:50:54 <xrfang> a bit abstract...
07:51:01 <xrfang> yes in Pair
07:51:08 <xrfang> we have a so called "constructor"
07:51:23 <Berengal> The constructor simply tells us which product type we're creating
07:51:26 <xrfang> but I don't know what is that constructor, because I am thinking of constructor in C++ Java
07:51:32 <Berengal> It's the "wrapper", or the box the values are put in
07:51:44 <Berengal> Other than that, it doesn't do anything at all
07:51:48 <Berengal> It's simply a label
07:52:07 <xrfang> again, theoretically, I know, but I don't know the syntax, quite alien...
07:52:25 <xrfang> now, data Pair a b = Constructor a b
07:52:27 <xrfang> ok?
07:52:40 <Berengal> The syntax will come...
07:52:43 <Berengal> Yes, that's fine
07:52:53 <Berengal> Anyway, on to sum types
07:52:54 <xrfang> this is a type definition
07:53:04 <xrfang> how to use that type then?
07:53:16 <Berengal> I'll get to that, just as soon as I explain sum types :P
07:53:20 <xrfang> in c, we say typedef blah = blahblah...
07:53:22 <xrfang> ok, thanks!
07:54:08 <Berengal> Sum types are sort of like product types in that they build new types out of old types
07:54:29 <Berengal> However, this time the final value is an "either", not an "and"
07:55:10 <Berengal> So (Int, Int) is "Int and Int", but if you had a "data Foo = Bar | Bar" the values are "either Bar, or Baz"
07:55:42 <Berengal> Get it?
07:56:10 <wjt> xrfang: i think your best bet is to read a book on Haskell
07:56:25 <wjt> xrfang: you could do a lot worse than Real World Haskell, which you can read online :)
07:56:31 <dddddd> ADT are like electric cars driven by solar power
07:56:38 <ordwidr> xrfang: *g*
07:56:38 <dddddd> how can i rep infinty as an Int?
07:57:04 <Berengal> dddddd: You can't. All values of type Int are finite
07:57:05 <yitz> dddddd: Nothing :: Maybe Int
07:57:06 <dddddd> 1/0 doesnt work
07:57:20 <dddddd> but Nothing isnt good as infinty
07:57:21 <xrfang> Berengal: sorry, busy with my daughter, can we open a separate window so that your answer will not get scroll out too soon? -- haskell is the hotest channel :)
07:57:35 <Berengal> xrfang: sure :)
07:57:39 <dddddd> i want to store graph weights as Ints,Double is unncessary memory
07:57:56 <xrfang> wjt: I am reading my first tutorial, I plan to read a lot more, but I just feel uncomfortable about strange symbols.
07:58:12 <xrfang> talk later gentlemen (ladies)
07:58:13 <ordwidr> dddddd: Maybe Int ?
07:58:26 <ordwidr> dddddd: where Nothing reperents infirnity?
07:58:56 <yitz> dddddd: data PossiblyInfiniteInt = Finite Int | Infinity
07:59:10 <yitz> dddddd: then make it an instance of Num, Integral, etc.
07:59:35 <yitz> dddddd: you get to decide what rules of arithmetic it should follow
08:03:18 <yitz> xrfang: avoid APL
08:07:15 <xrfang> yitz: what is apl?
08:07:42 <yitz> xrfang: a language that consists almost entirely of very strange symbols
08:08:18 * byorgey <3 APL
08:08:25 <xrfang> oh ... I already feel haskell is much more cryptic than erlang, but I realize that it might be caused by strict and polymorphic typing of haskell?
08:08:57 <byorgey> crypticness is in the eye of the beholder.
08:09:05 <byorgey> cryptosity?
08:09:18 <edwardk> xrfang: polymorphism starts out feeling cryptic, but once you get it it helps you avoid the combinatorial explosion of different names for the same thing
08:09:32 <yitz> crypticality
08:10:09 <edwardk> I wonder what happens when a project reaches "cryptical mass".
08:10:22 <yitz> hehe
08:10:41 <yitz> i've seen too many projects like that
08:11:12 <xrfang> edwardk: I don't see polymorphism cryptic
08:11:21 <xrfang> I see the *symbols* cryptic :)
08:11:33 <ordwidr> cu
08:11:51 <edwardk> xrfang: well, the penchant we have for letting you make up operators is a bit confusing to folks at first
08:13:40 <xrfang> I see the style of (+) 3 5 a little like lisp, but I don't know that at all :)
08:14:01 <quicksilver> erlang is very cryptic. Without a type system, how do they know what things *are*? Now that's a puzzle.
08:14:58 <xrfang> quicksilver: erlang seems not cryptic. I learned that in merely 1-2 month and wrote a quite good smtp server with it :)
08:15:16 <quicksilver> I was making a joke, not a very good one.
08:16:07 * quicksilver laughs at the wikipedia erlang page
08:16:09 <quicksilver> "Use the anonymous fun (here named 'Smaller')"
08:16:18 <quicksilver> anonymous functions with names? whatever next...
08:17:55 <xrfang> hehe, I want to study haskell to compare also I like haskell's ability to make native executables
08:18:01 <xrfang> now I like #haskell :)
08:18:26 <CirceOfAaea> @type map
08:18:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:18:49 <CirceOfAaea> @pl add a b = a + b
08:18:50 <lambdabot> add = (+)
08:19:04 <CirceOfAaea> @pl add a b = 2*a
08:19:04 <lambdabot> add = const . (2 *)
08:19:19 <burp_> @faq ghc for opensolaris?
08:19:20 <lambdabot> The answer is: Yes! Haskell can do that.
08:19:34 <CirceOfAaea> @pl add a b = 2 * a + (b-1)
08:19:34 <lambdabot> add = (. subtract 1) . (+) . (2 *)
08:24:27 <edwardk> @seen vincenz
08:24:27 <lambdabot> Last time I saw vincenz was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
08:24:27 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
08:24:27 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 3m 2d 9h 53m 49s ago,
08:24:27 <lambdabot> and .
08:24:42 <edwardk> yeow.
08:24:52 <edwardk> lambdabot is a busy girl
08:25:04 <cooldude127> lambdabot's a girl?
08:25:11 <edwardk> @vixen asl
08:25:11 <lambdabot> 19/f/California
08:25:15 <edwardk> see?
08:25:19 <cooldude127> lol
08:33:36 <CirceOfAaea> @pl add f g a = (f a).g
08:33:36 <lambdabot> add = flip . ((.) .)
08:34:26 <cooldude127> how does it do that?
08:35:01 <copumpkin> a series of smart transformations that don't (usually) affect the behavior
08:35:07 <cooldude127> awesome
08:35:14 <copumpkin> you can confuse it though
08:35:18 <cooldude127> i'm sure
08:35:30 <copumpkin> @pl (\x -> x x) (\x -> x x)
08:35:30 <Deewiant> ?pl \x -> x == 1
08:35:31 <lambdabot> (1 ==)
08:35:34 <lambdabot> ap id id (ap id id)
08:35:34 <lambdabot> optimization suspended, use @pl-resume to continue.
08:35:45 <copumpkin> @pl-resume
08:35:51 <Deewiant> Well, that's cheating, you're giving it bad input.
08:35:52 <lambdabot> ap id id (ap id id)
08:35:52 <lambdabot> optimization suspended, use @pl-resume to continue.
08:35:58 <copumpkin> :P
08:36:04 <EvilTerran> ?djinn Either a b -> (a -> b) -> b
08:36:05 <lambdabot> f a b =
08:36:05 <lambdabot>     case a of
08:36:05 <lambdabot>     Left c -> b c
08:36:05 <lambdabot>     Right d -> d
08:38:59 <mofmog> what's a function to tell if a list is full of equal values
08:39:17 <cooldude127> foldl1 (==) xs
08:39:19 <cooldude127> i think
08:39:32 <mofmog> no that can't be right
08:39:37 <mofmog> would nub work?
08:39:41 <copumpkin> I'd use group
08:39:41 <EvilTerran> allEq [] = True; allEq (x:xs) = all (==x) xs
08:39:57 <EvilTerran> allEq = null . drop 1 . group
08:40:02 <copumpkin> yeah
08:40:21 <cooldude127> that works, i see why foldl1 wouldn't work
08:40:30 <EvilTerran> @check let allEq [] = True; allEq (x:xs) = all (==x) xs in \xs -> allEq xs == (null . drop 1 . group) (xs :: Int)
08:40:40 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
08:40:47 <quicksilver> and $ zipWith (==) xs (tail xs)
08:40:49 <EvilTerran> @check let allEq [] = True; allEq (x:xs) = all (==x) xs in \xs -> allEq xs == (null . drop 1 . group) (xs :: [Int]) -- whups
08:40:52 <lambdabot>   "OK, passed 500 tests."
08:41:02 <quicksilver> or and . (zipWith(==)`ap`tail)
08:41:14 <cooldude127> lambdabot can quickcheck? wow
08:41:23 <dev31212> ?type [1]
08:41:25 <lambdabot> forall t. (Num t) => [t]
08:41:40 <dev31212> ?type (\x->x+5)
08:41:41 <lambdabot> forall a. (Num a) => a -> a
08:41:47 <EvilTerran> @check \x y -> x == y -- cooldude127, yes, but be wary of types defaulting to ()
08:41:48 <lambdabot>   "OK, passed 500 tests."
08:42:07 <cooldude127> yeah, quickcheck needs type decls
08:42:12 <CirceOfAaea> @pl add f g a = (f a).g
08:42:13 <lambdabot> add = flip . ((.) .)
08:42:32 <cooldude127> i'm working on using quickcheck for the first time right now. it's pretty awesome so far, especially for mathematical stuff
08:42:52 <copumpkin> for mathematical stuff, you'd be better off just proving it :P
08:43:11 <copumpkin> depending on the mathematical stuff, I guess :P
08:43:17 <cooldude127> it's linear algebra, stuff i wouldn't want to do by hand
08:43:30 <quicksilver> well normally it's when the implementation differs from the specification
08:43:41 <cooldude127> making quickcheck generate random matrices to test is quite cool
08:43:41 <quicksilver> you don't prove the spec - that's the mathematical bit, you hope you got that right.
08:43:42 <CirceOfAaea> @pl \a -> (f a).g
08:43:42 <lambdabot> (. g) . f
08:43:57 <quicksilver> you "prove" (check) the implementation matches the spec.
08:44:07 <quicksilver> for simple programs where the implementation *is* the spec, in haskell, it's pointless.
08:44:34 <xrfang> @pl double xs = map (*2) xs
08:44:35 <lambdabot> double = map (2 *)
08:44:55 <cooldude127> lambdabot knows * is commutative?
08:45:10 <quicksilver> @pl does
08:45:10 <lambdabot> does
08:45:14 <cooldude127> lol
08:45:17 <loop> :)
08:45:24 <quicksilver> @pl is just a set of rewrite rules
08:45:25 <lambdabot> is just a set of rewrite rules
08:45:42 <quicksilver> @check (\(x::Double) y -> x*y == y*x)
08:45:42 <lambdabot>   Parse error in pattern at "y" (column 15)
08:45:56 <quicksilver> @check (\x y -> x*y == (y*x :: Double))
08:45:57 <lambdabot>   "OK, passed 500 tests."
08:46:03 <quicksilver> I'm surprised.
08:46:13 <quicksilver> I thought it would find a counterexample in 500. obviously didn't try hard enough.
08:46:29 <dev31212> btw, who wrote lambdabot?
08:46:32 <quicksilver> or do FPUs actually implement commutative multiplication?
08:46:35 <quicksilver> dev31212: lots of people
08:46:39 <dev31212> ohok
08:47:42 <cooldude127> quicksilver: idk, but i've got an approximately equal function that's used all over my code cuz floating points suck
08:49:40 <Arien> Hiya all, is there bychance anyone around who uses Arch and would know where the fault of the xmonad breakage (after the ghc update) lies?
08:52:00 <xrfang> data List a = Nil | Cons a (List a)
08:52:06 <xrfang> this is a data type definition
08:52:22 <cooldude127> agreed
08:52:33 <xrfang> my question is: Nil, Cons, List, they are labels but *not* keyword/reserved word, right?
08:52:52 <ksf> I want to construct a tree-structure on top of a bytestream (fd, socket, mmap, you name it), lazily so I don't force dfs or bfs, and iteratees don't work because they don't properly support relative forward-seeks. any ideas?
08:52:58 <cooldude127> not reserved, List is a type, and Cons and Nil are essentially function
08:53:00 <cooldude127> s
08:53:20 <gueux> I am trying to use GetOpt to take a optional PortNumber. But "read x" where x is a PortNumber does not seem to work...
08:53:26 <quicksilver> xrfang: keywords are a fixed list. You can't define your own.
08:53:36 <xrfang> i.e. they are defined by this statement, or they actually already exists in haskell (e.g. defined in Prelude)?
08:53:46 <yowgi> gueux, try using fromIntegral
08:53:53 <xrfang> quicksilver: I know this, but I didn't write anything, just this line, it seems loaded ok
08:54:05 <quicksilver> xrfang: yes. it's fine.
08:54:07 <quicksilver> they're not keywords.
08:54:07 <cooldude127> xrfang: there's nothing wrong with this line
08:54:10 <quicksilver> "let" is a keyword.
08:54:19 <cooldude127> if, then, else, where
08:54:27 <xrfang> so I presume Cons is a keyword, or it is a label (which is created by this statement, but does not exist before this datatype is created), right?
08:54:32 <quicksilver> xrfang: no. it's not a keyword.
08:54:35 <cooldude127> it's not a keyword
08:54:37 <cooldude127> it's a function
08:54:39 <quicksilver> let's get terminology straight.
08:54:42 <cooldude127> a data constructor
08:54:47 <yowgi> gueux, I have a fromIntegral (read p :: Int) :: PortNumber here. Don't know how to make it better, sorry...
08:54:49 <quicksilver> a keyword is one of a small list of words reserved by the language.
08:54:51 <xrfang> the reason I ask is I just learned about Maybe Nothing Just
08:54:58 <cooldude127> also not keywords
08:55:03 <xrfang> these seems already defined by Haskell? so I think Cons also?
08:55:05 <gueux> yowgi: mmh ok
08:55:07 <Axman6> Maybe is just a datatype
08:55:11 <Axman6> @src Maybe
08:55:12 <lambdabot> data Maybe a = Nothing | Just a
08:55:20 <xrfang> @src Just
08:55:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:55:23 <ksf> xrfang, yes, but they're just ordinary datatypes like any else.
08:55:26 <quicksilver> Axman6: xrfang is try to learn about datatypes, yes.
08:55:40 <CirceOfAaea> @pl add f a = f a
08:55:40 <lambdabot> add = id
08:55:41 <Axman6> ah, ok
08:55:45 <cooldude127> data types are not special
08:55:46 <xrfang> see, @src Maybe can return a definition, but @src Just ...?
08:55:48 <cooldude127> unlike keywords
08:55:52 <yowgi> gueux, although you don't even need the second "cast"
08:55:57 <quicksilver> xrfang: @src is not comprehensive.
08:56:05 <cooldude127> xrfang: Just is part of the Maybe definition
08:56:10 <quicksilver> xrfang: it's just a random list of things people felt light programming into lambdabot.
08:56:16 <ksf> Just doesn't have a source on its own, anyway.
08:56:25 <CirceOfAaea> add f g = g . f
08:56:28 <yowgi> or the first :)
08:56:30 <quicksilver> it's neither canonical, nor comprehensive. It's not even correct.
08:56:30 <xrfang> cooldude127, Maybe is defined by Just Nothing, but how is Just be defined?
08:56:37 <xrfang> I guess Maybe is defined by Prelude?
08:56:38 <CirceOfAaea> @pl add f g = g . f
08:56:38 <lambdabot> add = flip (.)
08:56:46 <cooldude127> xrfang: Just creates a Maybe
08:56:51 <ksf> @src Maybe
08:56:52 <lambdabot> data Maybe a = Nothing | Just a
08:56:55 <quicksilver> xrfang: the statement "data Maybe a = Just a | Nothing" defines all three
08:56:58 <ksf> that's how just is defined...
08:56:59 <zachk> hey i am having trouble overloading Eq and Show the code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4133#a4133 if anyone could take a look it would be much appreciated
08:57:01 <quicksilver> xrfang: it defines Maybe, Just and Nothing.
08:57:17 <cooldude127> Nothing creates a maybe with no other data, and Just creates a maybe that has some data
08:57:36 <cooldude127> a maybe is something creating using either the Just or Nothing functions
08:57:38 <quicksilver> zachk: what's the problem?
08:57:52 <xrfang> oh great, so I can define my own, eg. data Perhaps a = Empty | Only a right?
08:57:58 <quicksilver> xrfang: yes.
08:57:59 <cooldude127> yes
08:58:01 <xrfang> and use them *exactly* same as Maybe
08:58:07 <quicksilver> exactly.
08:58:13 <xrfang> Maybe is just predefined, but not special in anyway :)
08:58:17 <quicksilver> yes.
08:58:22 <xrfang> cool thanks
08:59:09 <quicksilver> zachk: oh, the problem is you have "deriving" *and* you write your own instance
08:59:13 <quicksilver> zachk: do one or the other.
08:59:17 <zachk> quicksilver: the compiler is saying it cant do Show or Eq for N->N->N. but in my special declations for show and eq i am using a wildcard
08:59:19 <Axman6> zachk: don't derive Show and then also try and make an instance of Show
08:59:22 <zachk> oh ok thank you
08:59:27 <zachk> didnt know that
08:59:36 <Axman6> zachk: so, get rid of the deriving
08:59:43 <Axman6> (Eq,Show)*
09:00:14 <dbueno> Does anyone have any general advice for eliminating the SYSTEM retainer, i.e. data retained by the stack?
09:00:34 <quicksilver> zachk: your instance for Show is bad, by the way. but I assume you're just trying out instances for now.
09:00:51 <Axman6> zachk: deriving means that the instances are derived, you don't have to write any code for them, the compiler will make it for you
09:00:58 <gueux> mmh, my program compiles well with ghci, but with ghc it does not load the dependences. Have I to do a makefile?
09:01:01 <xrfang> problem:
09:01:06 <xrfang> listLength Nil = 0
09:01:08 <xrfang> listLength (Cons x xs) = 1 + listLength xs
09:01:15 <xrfang> I wrote the above 2 lines in a hs file
09:01:19 <xrfang> then load it in ghci
09:01:22 <Axman6> gueux: ghc --make
09:01:33 <xrfang> it says Nil and Cons not defined...
09:01:43 <EvilTerran> xrfang, have you defined them?
09:01:47 <cooldude127> xrfang: did you write the datatype definition?
09:01:50 <Axman6> xrfang: well, you've got to define them first ;)
09:01:51 <cooldude127> the line you were asking about?
09:02:04 <xrfang> yes, I am try to figure out...
09:02:17 <dddddd> what is a good name for a weighted graph?
09:02:21 <EvilTerran> xrfang, what do you have so far?
09:02:23 <dddddd> WeightedGraph?
09:02:25 <cooldude127> lol
09:02:35 <dddddd> or does it have some special name
09:02:42 <Axman6> xrfang: Nil and Cons/List are nor defined by default. however [], (:) and [a] are
09:02:43 <dddddd> like directed acyclic grpah=DAG
09:02:44 <cooldude127> dddddd: i think that's as good as any
09:02:44 <xrfang> like a dream to me,
09:02:57 <gueux> Axman6: ok
09:02:58 <gueux> thanks
09:03:01 <xrfang> data List a = Nil | Cons a (List a) this defines Nil and Cons
09:03:08 <Axman6> yep
09:03:15 <xrfang> but the meaning of Cons ...
09:03:28 <xrfang> how does haskell knows that Cons is similar / same to ":"?
09:03:38 <Axman6> it doesn't
09:03:42 <cooldude127> no relation
09:03:46 <xrfang> ok
09:03:47 <Axman6> it just happens to be similar
09:04:05 <xrfang> for me looks like same, now I have the listLength defined, let me work on it
09:04:49 <EvilTerran> xrfang, your (List a) is exactly equivalent to [a], but the compiler doesn't know that; it has no need to
09:04:54 <Axman6> lists could have been defined data [a] = a :$##@^^!#$^ [a] | End, and then you'd have to write x :$##@^^!#$^ xs
09:05:01 <xrfang> I tried listLength [1, 2, 3] but it says [a] and List a is not same
09:05:12 <quicksilver> xrfang: which is true, because they are not the same.
09:05:12 <xrfang> if I define a listLength like above, how to use it??
09:05:18 <cooldude127> xrfang: they're not, you can't use lists in place of your type
09:05:27 <quicksilver> listLength (Cons 1 (Cons 2 (Cons 3 Nil)))
09:05:30 <Axman6> xrfang: but [1,2,3] isn't a List, it's a []
09:05:31 <cooldude127> xrfang: Cons 1 (Cons 2 (Cons 3 Nil))
09:06:14 <xrfang> so I'd say it is a coined data type without any practical usage... but I do learned more about type define :)
09:06:28 <Axman6> yup
09:06:43 <xrfang> constructors are actually functions, right?
09:06:46 <gueux> and with ghc --make, I need a Main module, but how can I do if I have another program which I want to compile and which use that module?
09:06:47 <cooldude127> yes
09:06:49 <quicksilver> constructors are also functions.
09:06:58 <quicksilver> however, functions are not constructors.
09:07:03 <cooldude127> except you can do pattern matching on constructors
09:07:06 <Axman6> :t Just
09:07:07 <lambdabot> forall a. a -> Maybe a
09:07:16 <Axman6> :t (:)
09:07:17 <lambdabot> forall a. a -> [a] -> [a]
09:07:18 <quicksilver> constructors are functions but they are not *merely* functions
09:07:19 <xrfang> ?
09:07:24 <quicksilver> they are something special.
09:07:32 <cooldude127> but they behave like functions
09:07:38 <Axman6> quicksilver: in general they're not, but they can be
09:07:38 <cooldude127> they just do more
09:07:41 <Axman6> right?
09:07:49 <xrfang> Just is a fuction, given a output Maybe a?
09:07:50 <Axman6> like toJust x = Just x
09:07:59 <cooldude127> xrfang: yes
09:08:13 <xrfang> but Just a does not include Nothing while Maybe a include Nothing?
09:08:14 <cooldude127> but it is a constructor so you can say "let (Just x) = ..."
09:08:31 <EvilTerran> xrfang, Just is a constructor, a function; Maybe is a type
09:08:40 <xrfang> :t Maybe
09:08:41 <lambdabot> Not in scope: data constructor `Maybe'
09:08:45 <xrfang> :t Just
09:08:46 <lambdabot> forall a. a -> Maybe a
09:08:46 <EvilTerran> types don't have types
09:08:57 <EvilTerran> :k Maybe -- but types do have kinds!
09:08:58 <lambdabot> * -> *
09:08:59 <xrfang> @src Maybe
09:09:00 <lambdabot> data Maybe a = Nothing | Just a
09:09:06 <Axman6> :t (:[1,2,3])
09:09:07 <lambdabot> forall a. (Num a) => a -> [a]
09:09:11 <xrfang> :t Nothing
09:09:12 <lambdabot> forall a. Maybe a
09:09:23 <xrfang> @src Nothing
09:09:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:09:25 <EvilTerran> "* -> *" meaning "takes a fully-applied type and gives back a fully-applied type"
09:09:32 <lpsmith> True is a constructor... is it also a function?  ;-)
09:09:36 <quicksilver> EvilTerran: I think you risk confusing issue by introducing kinds ust now.
09:09:47 <EvilTerran> point
09:09:51 <Axman6> :k True
09:09:52 <cooldude127> the line between constants and no-arg functions is so blurred in haskell
09:09:52 <lambdabot> Not in scope: type constructor or class `True'
09:10:09 <Axman6> :t Bool
09:10:10 <lambdabot> Not in scope: data constructor `Bool'
09:10:13 <Axman6> :t True
09:10:14 <lambdabot> Bool
09:10:14 <cooldude127> :t True
09:10:15 <EvilTerran> cooldude127, there's a line there?
09:10:16 <lambdabot> Bool
09:10:21 <xrfang> :t False
09:10:22 <lambdabot> Bool
09:10:24 <Axman6> man, lambdabot hates me
09:10:30 <cooldude127> EvilTerran: i guess when you come from impure languages, yes
09:10:32 <Axman6> @src Bool
09:10:32 <lambdabot> data Bool = False | True deriving (Eq, Ord)
09:10:36 <lpsmith> cooldude127:  indeed.
09:10:37 <xrfang> :t (Just x)
09:10:39 <lambdabot> Maybe Expr
09:10:43 <cooldude127> EvilTerran: in haskell, it doesn't matter, cuz it's the same
09:10:47 <xrfang> what is Maybe Expr?
09:10:55 <EvilTerran> cooldude127, in fact, there is when you come from strict languages; it's the laziness that effectively removes the distinction
09:10:58 <quicksilver> Expr is a type.
09:10:59 <xrfang> let (Just x) = ...
09:11:02 <lpsmith> In fact,  many formalizations of logic treat constants as simply functions of no arguments
09:11:06 <xrfang> what does that mean?
09:11:10 <quicksilver> it's built into lambdabot, let's you do clever things with xs
09:11:12 <EvilTerran> > let Just x = Just 1 in x
09:11:13 <lambdabot>   1
09:11:14 <quicksilver> I suggest you ifnore it.
09:11:17 <EvilTerran> > let Just x = Nothing in x
09:11:19 <lambdabot>   * Exception: /tmp/129028272347536330:71:36-51: Irrefutable pattern failed f...
09:11:31 <quicksilver> if you had said ":t Just x" to ghci it would have complained that x was undefined.
09:11:34 <cooldude127> EvilTerran: i wouldn't consider it the laziness, but the fact that a function's output only depends on the input
09:11:44 <cooldude127> EvilTerran: if there is no input, it always returns the same thing
09:11:46 <cooldude127> hence a constant
09:11:51 <xrfang> quicksilver: so Maybe Expr is a new type,
09:11:58 <cooldude127> laziness does change when it computes the value tho
09:12:03 <xrfang> is it a Maybe and a Expr or "or" or neither?
09:12:08 <EvilTerran> cooldude127, i was thinking of the distinction between, say, "let foo = ..." and "let foo () = ...", in ML-like languages
09:12:28 <cooldude127> oh yeah, i haven't much experience with ML
09:12:55 <EvilTerran> the latter being, in intent, a function of no arguments, and the former being a constant
09:13:19 <cooldude127> yeah
09:13:26 <EvilTerran> in strict settings, like ML, the constant would be evaluated immediately (and only once), and the function would be evaluated only when it's called
09:13:28 <lpsmith> It's a bit of a silly argument in the end of what a given term means,   but yes,  all constructors are functions,   but some functions are not constructors.   Ignoring nullary constructors, that is.
09:13:37 <EvilTerran> *that* difference is annihilated by laziness
09:14:00 <marcot> Good evening.
09:14:14 <marcot> @hoogle Monad m => (a -> a) -> f a -> m ()
09:14:14 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
09:14:14 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:14:14 <lambdabot> Data.IntMap updateMax :: (a -> a) -> IntMap a -> IntMap a
09:14:36 <cooldude127> EvilTerran: correct. both factors affect it. the combination of purity and laziness is why no-arg functions are constants in haskell
09:14:54 <marcot> It would be good to have a type class that generalizes this function of IORef.
09:14:54 <EvilTerran> cooldude127, yeah, that about covers it
09:15:15 <cooldude127> can lambdabot track quotes?
09:15:23 <roconnor> laziness has nothing to do with it.
09:15:43 <cooldude127> roconnor: how so?
09:15:44 <marcot> To work with gtk2hs ListStore, for instance.
09:16:08 <EvilTerran> roconnor, see what i said above about "foo =" vs "foo () =" in strict ML-likes
09:16:22 <cooldude127> laziness is indeed a factor
09:16:42 <dddddd> repping infinity as Nothing is totally useless
09:16:51 <lpsmith> I tend to agree with roconner.   I think you are conflating the fact can emulate laziness in strict languages via thunks with nullary functions.
09:16:54 <gueux> is there a "clean" with ghc (ghc --make-clean)?
09:17:08 <gueux> I haven't found it into the manpage
09:17:09 <Axman6> no
09:17:11 <dddddd> i need something like Specialint = Int | Infinity
09:17:11 <pejo> gueux, --force-recomp or something similar.
09:17:33 <Axman6> rm *.o  *.hi maybeh
09:17:34 <roconnor> EvilTerran: I don't get it.  So a and () -> a are isomorphic types.
09:17:36 <Lemmih> gueux: cabal clean or ghc -fforce-recomp
09:18:11 <EvilTerran> roconnor, my point was that they behave distinctly in a strict setting, and equivalently in a lazy setting
09:18:14 <gueux> ok
09:18:35 <roconnor> EvilTerran: are you talking about operational behavior?
09:18:48 <EvilTerran> with regard to _|_s and whatnot
09:18:56 <Axman6> dddddd: data Specialint = SI Int | Infinity
09:19:06 <cooldude127> laziness eliminates the last distinction between constants and nullary function. with strict languages, it affects when execution happens, but in a lazy language, you can't control when either executes
09:19:47 <EvilTerran> actually, i'm pretty much just thinking of _|_ semantics
09:19:55 <lpsmith> cooldude:  you can control when stuff executes in Haskell
09:20:03 <Cale> Actually, there is a difference with respect to allocation as well
09:20:22 <roconnor> > let  foo () = "bar" in foo undefined
09:20:23 <lambdabot>   "* Exception: Prelude.undefined
09:20:26 <Cale> Constants are allocated, and cached as long as they remain in scope.
09:20:42 <Cale> Results of functions are never cached automatically.
09:20:51 <roconnor> EvilTerran: doesn't that distiguish between () -> a and a in Haskell?
09:21:06 <CirceOfAaea> @pl add f g a =  (f a).g
09:21:06 <lambdabot> add = flip . ((.) .)
09:21:14 <Cale> So there can be memory usage differences between using a constant and a constant function.
09:21:16 <cooldude127> there is no point in having a function take () as an input
09:21:18 <EvilTerran> roconnor, there's nothing analogous to that in the :: a case, thought
09:21:26 <Cale> cooldude127: I just told you a possible purpose.
09:21:27 <EvilTerran> s/t$//
09:21:32 <roconnor> sure there is: "bar"
09:21:36 <edwardk> cooldude127: in the absence of seq
09:21:36 <lpsmith> cale:  the results of functions are sometimes cached
09:21:41 <lpsmith> for example
09:21:48 <roconnor> > let  foo () = "bar" in foo ()
09:21:49 <lambdabot>   "bar"
09:21:55 <lpsmith> if you write    f () = bar   where bar = ...
09:21:56 <EvilTerran> er, non-sequiteur
09:21:57 <cooldude127> hmm, idk i think i'm talking slightly out of my ass. i don't believe i fully understand how everything works
09:22:08 <lpsmith> f () is sometimes cached,   with bar as a CAF
09:22:27 <Cale> lpsmith: Well, okay, sure.
09:22:28 <CirceOfAaea> ﻿@﻿pl add f g a = (f a).g
09:22:29 <EvilTerran> roconnor, fine, use "foo ~() =", if you prefer
09:22:30 <cooldude127> i don't imagine myself wanting to have something not be cached if it isn't affected by the outside world
09:22:33 <Cale> lpsmith: But bar is a constant.
09:22:51 <CirceOfAaea> ﻿@﻿pl add f g a = (f a).g
09:22:55 * roconnor isn't sure what we are arguing anymore
09:22:55 <Cale> cooldude127: Your memory would fill up with garbage.
09:22:56 <pejo> cooldude127, space behaviour.
09:23:01 <cooldude127> oh
09:23:04 <lpsmith> cale:  no argument here on that count :-)
09:23:10 <cooldude127> alright i think i see
09:23:22 <Cale> lpsmith: Actually, that's probably a bug.
09:23:23 <CirceOfAaea> @pl hello
09:23:24 <lambdabot> hello
09:23:25 <Lemmih> @seen dcoutts
09:23:25 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
09:23:32 <cooldude127> usually my consider is more often time complexity than space
09:23:34 <Cale> lpsmith: I would expect bar to be discarded when it goes out of scope
09:23:54 <lpsmith> Well,  CAFs are garbage collected
09:23:57 <CirceOfAaea> @pl add f g = f.g
09:23:57 <lambdabot> add = (.)
09:24:06 <roconnor> Haskell doesn't have operational semenatics!  GHC does.
09:24:11 <CirceOfAaea> ﻿﻿@﻿pl add f g a = (f a).g
09:24:17 <Cale> roconnor: true :)
09:24:23 <FalconNL> Does a 500 Internal Server Error when uploading a package to Hackage indicate an actual server error or does it mean there's some kind of error in the package?
09:24:33 <lpsmith> And you can control CAF-ing with {-# CAF #-} and {-# UNCAF #-}
09:24:35 <CirceOfAaea> Is lambdabot down
09:24:36 <CirceOfAaea> ?
09:24:42 <EvilTerran> ?bot
09:24:42 <lambdabot> :)
09:24:46 <Cale> lpsmith: I didn't know about that :)
09:24:46 <EvilTerran> no
09:24:48 <centrinia> Law of Minimum Complexity: {time complexity} * {space complexity} >= {some constant} > 0
09:25:01 <CirceOfAaea> ﻿@﻿pl let add f g a = (f a).g
09:25:07 <lpsmith> Yeah, I learned about it recently.  I forget where or why.
09:25:08 <CirceOfAaea> Oh the fool that I am
09:25:20 <roconnor> centrinia: you can also add an energy tradeoff to that
09:25:29 <CirceOfAaea> wait
09:25:33 <CirceOfAaea> ?bot
09:25:33 <lambdabot> :)
09:25:37 <roconnor> {time complexity} * {space complexity} * {energy complexity} >= {some constant} > 0
09:25:38 <CirceOfAaea> @pl
09:25:38 <lambdabot> (line 1, column 1):
09:25:38 <centrinia> Energy tradeoff is a function of space complexity.
09:25:38 <lambdabot> unexpected end of input
09:25:38 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:25:45 <lpsmith> and roconner is absolutely right... it's difficult to speak about such things in Haskell,  as it doesn't have an operational semantics
09:25:51 <CirceOfAaea> @pl add f = f
09:25:51 <lambdabot> add = id
09:26:01 <CirceOfAaea> @pl add f g a = (f a).g
09:26:02 <lambdabot> add = flip . ((.) .)
09:26:14 <roconnor> centrinia: that isn't my understanding.  Energy use is distinct.
09:26:20 <lpsmith> So we are usually in fact talking about de-facto standards across most compilers,  or what GHC does,  as GHC itself is kind of a de-facto standard
09:26:28 <Cale> Right, I'm considering what I'd expect GHC to do, or else what I'd expect a simple lazy implementation of Haskell to do.
09:26:34 <kadaver> why isnt there some built-in way to handle infinity?
09:26:38 <roconnor> by energy I mean the number of bits that need to be set (but not flipped) during the run.
09:26:43 <Cale> kadaver: Infinity?
09:26:48 <centrinia> Nullity?
09:26:57 <lpsmith> >  1.0 / 0.0
09:26:58 <Cale> > 1/0
09:26:59 <lambdabot>   Infinity
09:26:59 <lambdabot>   Infinity
09:27:08 <lpsmith> :t 1 / 0
09:27:09 <cooldude127> it appears there is
09:27:10 <lambdabot> forall t. (Fractional t) => t
09:27:12 <roconnor> > length (repeat ())
09:27:20 <lpsmith> ahh,  defaults to a double
09:27:28 <lambdabot>   thread killed
09:27:28 <cooldude127> roconnor: i think you just broke lambdabot
09:27:30 <Acteum> > (1/0)/0
09:27:31 <cooldude127> lol
09:27:31 <lambdabot>   Infinity
09:27:32 <lpsmith> Not all fractionals handle infinity
09:27:43 <centrinia> > 1 / (1/0)
09:27:44 <lambdabot>   0.0
09:27:47 <Acteum> ah lol
09:28:13 <centrinia> @quickcheck x == 1 / (1/x)
09:28:13 <lpsmith> Infinity is included in the IEEE 754 standard
09:28:14 <lambdabot> Unknown command, try @list
09:28:21 <centrinia> @check x == 1 / (1/x)
09:28:22 <Cale> :t isInfinite
09:28:24 <lambdabot> forall a. (RealFloat a) => a -> Bool
09:28:24 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:28:28 <Cale> :t isIEEE
09:28:30 <lambdabot> forall a. (RealFloat a) => a -> Bool
09:28:40 <Cale> :t isDenormalised
09:28:41 <lambdabot> Not in scope: `isDenormalised'
09:28:43 <quicksilver> I don't think IEEE 754 is a very useful infinity
09:28:43 <Cale> :t isDenormalized
09:28:45 <lambdabot> forall a. (RealFloat a) => a -> Bool
09:28:47 <lpsmith> So most sane languages that support floating point have some at least one kind of infinity.
09:28:49 <quicksilver> although I've not tried to use it very hard.
09:28:57 <lpsmith> >  -1 / Infinity
09:28:58 <centrinia> @check abs (x - (1 / (1/x))) < 0.01
09:28:59 <lambdabot>   Not in scope: data constructor `Infinity'
09:29:00 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:29:13 <quicksilver> I think it you really want a sane infinity, you need to specify your precise semantics carefully.
09:29:19 <roconnor> > read "Infinity" :: Double
09:29:21 <lambdabot>   Infinity
09:29:45 <lpsmith> @let inf = read "Infinity" :: Double
09:29:47 <lambdabot>  Defined.
09:29:53 <lpsmith> > - 1 / inf
09:29:55 <lambdabot>   -0.0
09:30:03 <lpsmith> > -0.0 == 0.0
09:30:05 <lambdabot>   True
09:30:07 <centrinia> > (inf - 1)+1
09:30:08 <lambdabot>   Infinity
09:30:56 <lpsmith> > inf - 1
09:30:57 <lambdabot>   Infinity
09:31:00 <lpsmith> > inf - inf
09:31:01 <lambdabot>   NaN
09:31:03 <bwr> > (inf + 1) - (inf - 1)
09:31:04 <lambdabot>   NaN
09:31:42 <roconnor> > read "NaN" :: Double
09:31:43 <lambdabot>   NaN
09:31:48 <roconnor> oh
09:32:09 <roconnor> I'm a little surprised by that
09:32:17 <cooldude127> what did you expect?
09:32:19 <roconnor> I probably shouldn't be
09:32:35 <roconnor> > let x = read "NaN" :: Double in x == x
09:32:36 <lambdabot>   False
09:32:42 <roconnor> > let x = read "NaN" :: Double in compare x x
09:32:44 <lambdabot>   GT
09:32:46 <centrinia> That's funny. :)
09:32:54 <roconnor> > let x = read "NaN" :: Double in x > x
09:32:55 <lambdabot>   False
09:33:01 <centrinia> Heh.
09:33:31 <lpsmith> There is a way to distinguish positive and negative zero
09:33:37 <lpsmith> I forget all the ins and outs
09:33:40 <centrinia> > -0.0 > 0.0
09:33:41 <lambdabot>   False
09:33:50 <centrinia> > compare (-0.0) 0.0
09:33:52 <lambdabot>   EQ
09:34:06 <lpsmith> ahh
09:34:10 <lpsmith> I remember
09:34:13 <centrinia> > -0.0 < 0.0
09:34:14 <lambdabot>   False
09:34:15 <lpsmith> >   1 / -0.0
09:34:17 <lambdabot>       precedence parsing error
09:34:17 <lambdabot>          cannot mix `(/)' [infixl 7] and prefi...
09:34:19 <centrinia> Strange.
09:34:19 <quicksilver> > -0.0
09:34:21 <lambdabot>   -0.0
09:34:21 <lpsmith> >   1 / (-0.0)
09:34:23 <lambdabot>   -Infinity
09:34:27 <lpsmith> >   1 / (0.0)
09:34:29 <lambdabot>   Infinity
09:34:37 <lpsmith> > -inf == inf
09:34:38 <lambdabot>   False
09:34:49 <kadaver> if ghci fails to deduce a type bcause no isntance for num, couldnt it say still what it thinks the correc ttype is as a hint to me?
09:34:49 <cooldude127> > -inf
09:34:50 <lambdabot>   -Infinity
09:34:56 <quicksilver> haskell doesn't give access to some of the obscure bits of ieee 754 IIRC.
09:35:14 <roconnor> > isNegativeZero (-0.0)
09:35:15 <lambdabot>   True
09:35:22 <roconnor> > isNegativeZero (0.0)
09:35:24 <lambdabot>   False
09:35:30 <centrinia> > isNegativeZero (0.0/0.0)
09:35:31 <lambdabot>   False
09:35:47 <lpsmith> > 0.0 / 0.0
09:35:49 <lambdabot>   NaN
09:36:27 * centrinia is still perplexed by the fact that compare x y == GT doesn't necessarily imply that x>y
09:37:09 <kadaver> wtf this is ugly, no i have to do a wholetypelcass shizmit just to have SpecialInt
09:37:45 <roconnor> centrinia: it's because NaN isn't equal to NaN
09:37:59 <roconnor> so all bets are off when you use NaN in any function.
09:38:08 <Axman6> kowey: what's wrong with using maxBound for infinity?
09:38:09 <roconnor> At least, that is my interpretation
09:38:16 <lpsmith> @let isFunction f x y =  if x == y then f x == f y else True
09:38:18 <lambdabot>  Defined.
09:38:29 <kowey> Axman6: I beg your pardon?
09:38:42 <lpsmith> > isFunction (1 /)   (-0.0) (0.0)
09:38:44 <lambdabot>   False
09:38:45 <roconnor> > maxBound :: Integer
09:38:46 <lambdabot>       No instance for (Bounded Integer)
09:38:46 <lambdabot>        arising from a use of `maxBoun...
09:38:50 <Axman6> uh, meant kadaver
09:39:09 <kowey> phew! :-)
09:39:10 <quicksilver> conal had some code for adding bounds to a type
09:39:19 <quicksilver> such as adding +- Infinity to the integers
09:39:26 <lpsmith> >  maxBound :: Double
09:39:28 <lambdabot>       No instance for (Bounded Double)
09:39:28 <lambdabot>        arising from a use of `maxBound...
09:39:32 <quicksilver> btu the thing is, there are lots of possble semantics you might imagine.
09:39:36 <quicksilver> so you need to make some decisions.
09:39:39 <quicksilver> on what behaviour you want.
09:39:44 <quicksilver> kadaver's gone anyway :P
09:40:07 <FalconNL> Can anyone tell me if a 500 Internal Server Error when uploading a package to Hackage indicates an actual server error or does it mean there's some kind of error in the package?
09:40:08 <kowey> remember ohloh? they're open-source now... in case anybody here had the Ruby-fu to add darcs support
09:40:20 <MyCatVerbs> quicksilver: If you want, I could masquerade as a cadaver - I am roughly human-shaped, and have no life.
09:40:24 <quicksilver> ;)
09:40:45 <Lemmih> @tell dcoutts Please tell me it's possible to test new versions of Cabal with cabal-install.
09:40:45 <lambdabot> Consider it noted.
09:40:46 <kowey> git clone git://github.com/robinluckey/ohloh_scm.git <-- adding darcs support would be a boon to the Haskell community
09:42:07 <centrinia> Can we construct a real number type where a value consists of a Cauchy sequence of rational numbers?
09:42:23 <vixey> centrinia: no..
09:42:32 <centrinia> Why not?
09:42:33 <vixey> centrinia: you can do [Rational] and hope it's cauchy convergent
09:42:36 <edwardk> centrinia: check out CReal
09:42:52 <Axman6> > showCReal 100 pi
09:42:53 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
09:42:57 <eu-prleu-peupeu> can someone help me out with reactive ?
09:42:57 <vixey> all we have without dependent types is hope
09:44:36 * QtPlaty[HireMe] has met a few dependent types .
09:44:44 <BONUS> ah, ubuntu 9.04 is pretty awesome. i suck at installing haskell stuff. if i just do apt-get install ghc6, i'll get 6.8.2, right?
09:44:47 <dddddd> axman6: that it doesnt work correctly?
09:44:53 <dddddd> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4135#a4135
09:45:28 <roconnor> centrinia: you could have smart constructors to ensure that all sequences are Cauchy, but then you couldn't have enough smart constructors to cover all cauchy sequences.
09:45:31 <vixey> BONUS: do you want a more recent GHC/
09:45:45 <roconnor> centrinia: you'd either have to leave some out, or allow "unsafeConstructoCauchySequence"
09:45:51 <vixey> BONUS : I just got 9.04 too and don't have GHC yet ..
09:45:52 <BONUS> yeah i want 6.10.2
09:46:19 <BONUS> 6.8.2 has bad support for associated types, right?
09:46:21 <centrinia> How do I use smart constructors to ensure that all sequences are Cauchy?
09:46:24 <eu-prleu-peupeu> BONUS: install it from binary
09:46:29 <vixey> I don't think it has ANY support
09:46:34 <eu-prleu-peupeu> thats what i did, and it works fine :)
09:46:49 <centrinia> You can also compile ghc-6.10.2 :)
09:46:56 <BONUS> eu-prleu-peupeu: the tar.bz2 from the site? which one, the libedit.so.0 or libedit.so.2
09:47:02 <marcot> I'm trying to define a class using type families, like the examples with Collects at http://haskell.org/haskellwiki/GHC/Indexed_types.
09:47:07 <roconnor> centrinia: just define, pi, and fromRational, and then write functions such as sin and cos.
09:47:11 <dddddd> how often does apt-get updated? i mean 6.8,.2 is old now
09:47:13 <roconnor> centrinia: the way CReal works
09:47:17 <lpsmith> BONUS:   IIRC,  you really want GHC 6.8.3,   ghci has a rather nasty variable scoping bug from the command line in 6.8.2
09:47:27 <marcot> My problem is that one of the defined types has the kind * -> *, and not *.
09:47:37 <BONUS> i think i really want 6.10.x
09:47:38 <eu-prleu-peupeu> BONUS: the one that says debian, i think its 2
09:47:38 <lpsmith> BONUS:  or 6.10.*  ;-)
09:47:43 <eu-prleu-peupeu> libedit.so.2
09:47:44 <BONUS> ah
09:47:47 <marcot> So I get a kind error in the function signature where it's used.
09:47:53 * Cale tries switching to the libedit0 version of ghc to escape the segfaults.
09:48:02 <roconnor> > exp (0 :+ pi) :: Complex CReal
09:48:03 <lambdabot>   (-1.0) :+ 0.0
09:48:05 <BONUS> says i need a libffi5 package, apt-get doesnt find that, hmm
09:48:45 <vixey> Cale is libedit2 dodgy? :(
09:48:46 <centrinia> > exp (0 :+ pi) + (1 :+ 0)
09:48:47 <lambdabot>   0.0 :+ 1.2246467991473532e-16
09:49:01 <roconnor> > exp (0 :+ pi) + (1 :+ 0) :: Complex CReal
09:49:01 <lpsmith> Cale:  segfaults?   I ended up compiling my own 6.10.2,  and it segfaults every time I do a ^C
09:49:03 <Cale> vixey: It segfaults whenever I hit Ctrl-C to kill a computation
09:49:04 <lambdabot>   0.0 :+ 0.0
09:49:10 <vixey> yuc
09:49:10 <marcot> Is there a way to use * -> * types in type families?
09:49:14 <vixey> that sucsks
09:49:14 <Cale> vixey: I think it's a libedit2 bug
09:49:29 <BONUS> haha did you know there's a haskell98-report package in the repositories
09:49:39 <lpsmith> What's the difference between libedit2 and libedit0 ?
09:49:47 <Cale> I can't wait for ghc to get away from using libedit. It's such garbage.
09:50:02 <Cale> lpsmith: An annoying bug?
09:50:08 <lpsmith> supremely
09:50:10 <centrinia> What would it use instead of libedit?
09:50:11 <Craig`> hey
09:50:30 <lpsmith> centrina:  a native command line editing solution written in Haskell ;-)
09:51:12 <lpsmith> cale:  however it does have the advantage of being able to break out of certain computations that GHCi can't break out of :-P
09:51:22 <Cale> heh
09:51:29 <vixey> Cale, what would it use instead?
09:51:34 <vixey> oh right...
09:51:37 <Cale> vixey: Maybe haskeline?
09:52:09 <lpsmith> and these particular computations seem to be biting me quite a lot lately.
09:52:54 <eu-prleu-peupeu> can someone help me out with reactive ?
09:53:08 <QtPlaty[HireMe]> eu-prleu-peupeu: What is the problem your haiving with it?
09:53:14 <Cale> lpsmith: You can always Ctrl-Z and then kill %1
09:53:26 <lilac> or Ctrl-\
09:53:35 <lpsmith> lol,  of course,  but that's not quite the solution I'm looking for
09:53:50 <eu-prleu-peupeu> QtPlaty[HireMe]: i can't change a behaviour whenever an event occurs :/
09:53:50 <lpsmith> I think "last [0..]" does the trick
09:54:00 <vixey> maybe I should use UHC
09:54:09 <vixey> instead of GHC
09:54:18 <mofmog> what's a good way to do something like [[2,3],[2,4]] -> [[(0,0,2), (1,0,3)], [(0,1,2), (1,1,4)]]
09:54:26 <mofmog> i have some ungodly hack involving multiple maps and zip
09:54:48 <mofmog> basically, assign coordinates to a nested list
09:54:49 <lpsmith> No,  you need "let ones = 1 : ones in last ones"
09:54:51 <eu-prleu-peupeu> QtPlaty[HireMe]: i've been using reactive-glut, and changing the test file from the darcs repository, here is my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4136#a4136
09:55:02 <vixey> mofmog: how about [[2,3],[2,4]] & [[(0,0),(1,0)],[(0,1),(1,1)]] --> <what you wrote>
09:55:14 <lpsmith> Many broken examples of self-referential corecursion also do the trick
09:55:14 <yakov> I can't build DLL on windows from entire program, is it b0rken (again)?
09:55:14 <vixey> because that one is really easy
09:55:19 * QtPlaty[HireMe] doesn't know the answer unforutnitly.
09:55:23 <mofmog> ahh
09:55:28 <mofmog> durr, i could just zip that hur
09:55:30 <yakov> i'm on 6.10.1..
09:55:48 <zsol> any pointers on .cabal/config documentation anyone? :)
09:55:49 <Cale> grr, that didn't help.
09:55:50 <vixey> mofmog: yeah if you ever get stuck see if it's possible to generalize the problem into something easier
09:56:01 <Cale> Well... to be fair, this isn't really libedit0 I'm using.
09:56:10 <Cale> Maybe I should see about getting a proper libedit0
09:56:12 <mofmog>         genCoords = [(x,y) | x <- [0..maxX], y <- [0..maxX]]
09:56:17 <mofmog> durr
09:57:46 <Craig``> sorry about that - did anyone reply?
09:58:38 <lpsmith> Craig``:  http://tunes.org/~nef/logs/haskell/09.04.23
09:59:50 <yakov> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4137#a4137        - here's ghc output on windows
10:00:10 <yakov> strange.. as I read in docs building entire app as DLL is possible :-/
10:00:42 * vixey wonders how to compile UHC without a haskell compiler
10:01:12 <Zao> Can't you bootstrap yourself up from an early EHC?
10:03:00 <Craig``> strange according to that website i didnt say something
10:03:09 <Craig``> <Craig`> I want to be web dev yet I want to learn haskell, so I thought I could do both and make kinda web stuff with Haskell: would Haskell be an okay/good choice of language for an instant messeneger?
10:04:22 <lament> a web instant messenger?
10:04:40 <mornfall> Craig``: www.happstack.com I guess :)
10:05:06 <Cale> Craig``: It's not a bad choice, but how much do you already know about Haskell?
10:05:45 <Craig``> No like an app one, (and I'm 15 atm, just learning Haskell, this is like when I'm 18) :)
10:05:48 <lpsmith> gmail needs something more than just a "report spam" button.   They should have a "report fraud/ report phishing" button as wee
10:06:12 <wjt> Craig``: i think you may underestimate how much work is involved to implement an IM client :)
10:06:32 <Craig``> I guess it's a _lot_?
10:06:39 <dddddd> hmm flodyMarshall doesnt work for string keys in a Graph, I need to convert to nbrs? or hash tem
10:06:42 <kowey> lpsmith: they do have such a feature, but it's buried away in the UI
10:06:47 <dddddd> hash could be dangerous though
10:06:59 <Cale> Craig``: Well, it could also be very simple. :)
10:07:12 <dddddd> a
10:07:28 <Craig``> oh cool
10:07:37 <Cale> But if you want it to interact with the traditional IM networks, implementing those protocols tends to be a pain :)
10:07:48 <Craig``> I tried googling but it came up with people with the surname "haskell" having msn.. lol
10:08:09 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4135#a4135 <- so why doesn't maxBound work there? it seems to wrap around or something
10:08:18 <kadaver> bah
10:08:30 <kadaver> maxBound is useless as infinity:
10:08:33 <Cale> Craig``: A lot of those networks seem to go out of their way to make it hard for people to write nonstandard clients.
10:08:35 <kadaver> > maxBound :: Int)
10:08:36 <lambdabot>   <no location info>: parse error on input `)'
10:08:41 <kadaver> > (maxBound :: Int) + 1
10:08:42 <lambdabot>   -9223372036854775808
10:09:10 <vixey> behh I have to download 60 MB of haskell compiler to compile haskell compiler
10:09:21 * Cale grumbles. ghci-haskeline seems incapable of responding to Ctrl-C at all.
10:09:22 <mofmog> why does length have to return an int >_<
10:09:43 <QtPlaty[HireMe]> mofmog: What should it return?
10:09:46 <Cale> mofmog: I know, I think it's stupid too.
10:09:46 <mofmog> Integer
10:09:51 <mofmog> or at least
10:09:55 <mofmog> there should be an easy alternative
10:09:55 <Cale> Or polymorphic.
10:09:57 <Craig``> what do you want it to return? it cant be a double, and strings could only be like "one"
10:09:58 <Lemmih> mofmog: see genericLength.
10:10:43 <Cale> genericLength has a long enough name that you might as well just use fromIntegral :)
10:10:56 <Cale> Craig``: It can be a Double.
10:11:09 <Cale> It should be  length :: (Num b) => [a] -> b
10:11:09 * QtPlaty[HireMe] thinks that it should return Natural, he also thinks that Haskell should have Natural type.
10:11:34 <vixey> what's the point in turning a list into a natural?
10:11:37 <vixey> just use the list directl
10:11:54 <Craig``> what I mean is: you cant have 5 and "a bit" characters so they could not use double in that sense
10:11:54 <Cale> vixey: He presumably means an *efficient* lazy natural type :)
10:12:06 <vixey> efficient lazy natural I would love to see
10:12:22 <Cale> vixey: I believe you can find one on Hackage
10:12:31 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat
10:16:57 <Cale> Craig``: Well, it would definitely be silly for it to be monomorphically a Double.
10:17:10 <Cale> But allowing a Double result would be good.
10:17:41 <Craig``> you mean for the higher values (capacity) the double has compared to an Int?
10:18:39 <idnar> uhm
10:18:52 <idnar> what happens if you try to take the length of a list that's longer than maxBound :: Int?
10:19:08 <vixey> idnar: I think it wraps around
10:19:15 <iago_> perhaps is a stupid question but.. why FP languages that has a System F type system don't allow you to apply a function to a type?
10:19:18 <vixey> (in practice it would take so long you would not wait)
10:19:19 <idnar> or, hmm, maybe that's impossible
10:19:39 <idnar> you wouldn't be able to allocate enough memory to store it
10:20:01 <idnar> I suppose you could do some trickery with unsafePerformIO to fake it
10:20:01 <Zao> idnar: 64-bit?
10:20:03 <QtPlaty[HireMe]> I wonder if you have a list that is around about maxBound :: Int long should you be using some other type of Data structure more suited for what your doing?
10:20:15 <vixey> idnar: I would expect a GC to kill the list as it's consumed -- maybe I am too optimistic about it
10:20:17 <MyCatVerbs> idnar: naw, if all you're doing with that list is passing it to length and nothing else, then the cells you're allocating would become dead immediately, so the GC could reclaim them.
10:20:17 <idnar> Zao: maxBound :: Int is huge on 64-bit, though
10:20:24 <maltem> > length (() : replicate maxBound ())
10:20:25 <idnar> MyCatVerbs: oh, true
10:20:35 * MyCatVerbs waves at vixey.
10:20:39 <lambdabot>   thread killed
10:20:40 <idnar> hooray laziness
10:20:41 <vixey> heya
10:20:46 <doserj> > (maxBound::Int)+1
10:20:48 <lambdabot>   -9223372036854775808
10:20:48 <idnar> anyhow, that's a pretty awful failure mode (wrapping around) :/
10:21:50 <vixey> idnar: b..but Int is FAST
10:22:03 <MyCatVerbs> idnar: eh, that's how two's complement arithmetic works.
10:22:05 <maltem> idnar, it's perfectly well-defined arithmetics in the ring of Int :P
10:22:07 <vixey> haven't you noticed how much faster  length [1,2,3]  is with Int compared to Integer
10:22:29 <idnar> maltem: yes, but that's a useless semantics for a function that gets the length of a list :P
10:22:41 <MyCatVerbs> It has a few handy properties, like the fact that with wraparound behavoir it forms a ring.
10:22:46 <idnar> vixey: *giggle*
10:22:55 <MyCatVerbs> Plus it's really, really useful for bit-twiddling maniacs.
10:23:05 <idnar> MyCatVerbs: the semantics of Int aren't the problem
10:23:09 <idnar> MyCatVerbs: the semantics of length are the problem
10:23:26 <MyCatVerbs> Oh! Yes, of course.
10:23:45 <bogner> the haskellwiki page on arrows references an article called ArrowsIntroduction in issue 4 of the monad reader, but it doesn't seem to be on the monad reader issue 4 wiki page, anyone know what's going on there?
10:24:05 <Zao> length wraps around just using a meg or so of memory with -O2
10:24:14 <vixey> why does uuagc use GMP?
10:24:35 <vixey> I was hoping Integer would be good enough
10:25:34 <MyCatVerbs> Zao: for reference, doing it in ghci shows ghci taking about 20MB resident memory, according to top.
10:26:03 <MyCatVerbs> So yeah, it's still constant space even with no optimizations at all.
10:28:13 <vixey> Configuring EH-Util-1.0...
10:28:13 <vixey> setup: At least the following dependencies are missing:
10:28:16 <vixey> fgl -any
10:28:18 <vixey> :/
10:28:21 <vixey> not listen on the wiki
10:28:24 <vixey> listed*
10:31:00 <Craig``> anyone here swedish?
10:31:54 <tomh> vixey: GMP ?
10:33:17 * mofmog spent an hour hacking a list when an array would've been 100x more elegant
10:34:24 <byorgey> heh, I think we've all been there at some point, with suitable substitutions for 'list' and 'array'
10:34:49 <mofmog> im trying to make a convenient representation for a maze
10:35:00 <jinjing> is there a way to get a backtrace for an IO exception ?
10:35:01 <mofmog> obviously a list is idiotic -_-
10:35:09 <byorgey> mofmog: yeah, that's tricky
10:35:36 <mofmog> this is like when i realized that making an array comonadic is easier than making a list comonadic
10:39:41 <vixey> tomh what?
10:39:57 <tomh> whats GMP?
10:40:27 <BONUS> mofmog: don't forget to use a zipper
10:40:28 <vixey> GNU Multi Precision
10:40:32 <vixey> it's a library for large numbers
10:40:51 <vixey> mofmog what is a maze?
10:41:23 <vixey> @hackage fgl
10:41:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
10:41:26 <mofmog> you know, the things rats go through
10:41:38 <vixey> mofmog as far as your program is concerned
10:41:47 <seliopou> graph ftw
10:41:51 <mofmog> oh, a 2d array with a start position and and end position
10:42:03 <vixey> then use an array :p
10:42:03 <mofmog> with blocks in between
10:42:05 <mofmog> i am
10:42:13 <mofmog> hence my whining earlier ^_^
10:42:37 <tomh> ah ok
10:42:56 <mofmog> now how best to turn an [[foo]] into a 2d array
10:43:17 <vixey> that's easy..
10:44:10 <mofmog> can i just use fromlist ?!
10:44:13 <da-x> I am confused.
10:44:16 <byorgey> @type listArray
10:44:18 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
10:44:24 <mofmog> er wrong func
10:44:39 <mofmog> > listArray [[3,2,3],[5,3,2]]
10:44:40 <lambdabot>   Couldn't match expected type `(i, i)' against inferred type `[a]'
10:44:45 <da-x> ((++)"a") "b"  == "ab"   and   (++"a") "b" == "ba"
10:44:56 <mofmog> > listArray ((0,3),(3,3)) [[3,2,3],[5,3,2]]
10:44:57 <lambdabot>   array ((0,3),(3,3)) [((0,3),[3,2,3]),((1,3),[5,3,2]),((2,3),* Exception: (A...
10:45:01 <mofmog> durr
10:45:30 <byorgey> > listArray ((0,0),(1,2)) (concat [[3,2,3],[5,3,2]])
10:45:32 <lambdabot>   array ((0,0),(1,2)) [((0,0),3),((0,1),2),((0,2),3),((1,0),5),((1,1),3),((1,...
10:45:38 <da-x> Someone should really stress out the difference.
10:46:00 <mofmog> da-x: the first one applies it as the first argument, the second one as the second
10:46:21 <da-x> mofmog: it's very subtle.
10:46:31 <mofmog> not really, the parens mean prefix
10:46:52 <mofmog> but why would you ever do (++)
10:46:55 <byorgey> da-x: (++) is the prefix version of ++,  so ((++)"a") is just  (++) "a", i.e. (++) with "a" as its first argument
10:46:55 <mofmog> in that case
10:47:00 <Craig``> I know there's already a power operator^ but say I wanted to make a function for it how would i? power x y = .. in other languages I would make a type of loop and then make the var += the value until y
10:47:04 <byorgey> da-x: whereas (++"a") is special operator section syntax
10:47:15 <byorgey> which corresponds to  \b -> b ++ "a"
10:47:15 <mofmog> Craig: sicp version of fast exp?
10:47:45 <byorgey> da-x: does that help?  It is a bit subtle, I suppose, but not too bad once you get used to it.
10:47:47 <Craig``> o_O
10:47:55 <vixey> Craig``: what is the mathematical definition of power?
10:47:58 <byorgey> da-x: the important point is that putting an operator in parens makes it into a prefix function.
10:48:13 <mofmog> power x 0 = 1
10:48:24 <Craig``> yeah i knew that
10:48:25 <mofmog> power x y = x * (power x (y-1))
10:48:29 <Craig``> anything to the ^0 is 1
10:48:46 <da-x> byorgey: Yes, I understand, however I don't like the (++"a') variant, I think it just adds confusion.
10:48:47 <mofmog> x^y = x*x^(y-1) unless i've gottenr etarded
10:49:09 <malosh> Hi. I understand there is no type-safe polymorphic way of dynamicaly linking a function defined in an external file. Someone can correct me ? :-)
10:49:11 <mofmog> of course, this only works for y >= 0
10:49:11 <Craig``> I dont get how calling a function inside a (what i see to be an unfinished function) works
10:49:22 <mofmog> that's how recursion works
10:49:29 <cypher-> mofmog: do it in log time
10:49:31 <byorgey> Craig``: recursion is the bread and butter of Haskell =)
10:49:37 <vixey> Craig``: it doesn't always work
10:49:39 <mofmog> cypher: im not writing that out on irc
10:49:43 <edwardk> craig: there is a 'Data.Monoid.Combinators.replicate' that will repeat an arbitrary monoid.. Endo is a monoid, so it can be used to iterate a function n times
10:49:51 <edwardk> Craig``: and it'll do so efficiently
10:49:52 <mofmog> cypher: i remember doing it in scheme
10:50:06 <vixey> Craig``: do you know induction?
10:50:06 <byorgey> da-x: well, it's convenient sometimes.  But I guess you're not required to like it =)
10:50:10 <QtPlaty[HireMe]> Craig``: It works as long as you have a base for your recursion.
10:50:16 <_dolio> @type let (+) + 1 + 1 = (+) in (+)
10:50:16 <Craig``> Prelude> 3 `power` 2
10:50:17 <lambdabot> forall t t1. (Num t1, Integral t) => t -> t1 -> t
10:50:18 <Craig``> *** Exception: stack overflow
10:50:30 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Combinators.html
10:50:33 <mofmog> edwardk: ?? he obviously doesn't understand recursion whats with teh cat theory
10:50:34 <vixey> checking for suitable m4... configure: error: No usable m4 in $PATH or /usr/5bin (see config.log for reasons)
10:50:37 <vixey> argh!!
10:51:45 <da-x> byorgey: you'd usually don't expect parenthesis to change the functionality of an expression if they surround the first token of an expression composed of only two tokens. I was working with that assumption. I guess I still understand Just Nothing in haskell...
10:51:54 <edwardk> mofmog: sorry, i just looked up and saw a bit of discussion about a generic power function. I didn't dig into the log.
10:52:12 <mofmog> craig: you can't insert what i wrote into ghci sadly
10:52:28 <byorgey> da-x: that's true, operator section notation throws a little corner case into that expectation
10:52:49 <leimy_> > intercalate "," ["one","two","three"]
10:52:49 <byorgey> well, and the fact that parens are special when surrounding an operator
10:52:49 <lambdabot>   "one,two,three"
10:52:53 <leimy_> nice...
10:53:06 <leimy_> @src intercalate
10:53:06 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:53:28 <leimy_> intersperse "," ["one", "two", "three"]
10:53:31 <byorgey> in Haskell, (t) is always the same as  t  for arbitrary *terms* t
10:53:37 <vixey> da-x: um.. I do expect adding parens to change things.. kinda what they are for
10:53:39 <byorgey> but  operators on their own are not terms.
10:53:47 <mofmog>  let power x y = if y == 0 then 1 else x * (power x (y-1))
10:53:56 <leimy_> > intersperse "," ["one", "two", "three"]
10:53:56 <vixey> da-x: e.g.  1 + 2 * 3 vs (1 + 2) * 3
10:53:57 <lambdabot>   ["one",",","two",",","three"]
10:54:00 <mofmog> craig: do you understand how fibonacci works?
10:54:15 <Craig``> i won't lie - no
10:54:21 <mofmog> ok, here's what i suggest
10:54:32 <mofmog> go look up structure and interpretation of computer programs
10:54:36 <mofmog> go through the first chapter, come back to haskell
10:54:47 <mofmog> it's free and you'll become 10x smarter after it
10:55:10 * mofmog thinks scip needs a haskell version
10:55:21 <skorpan> sicp too
10:55:48 <mofmog> it's like emacs, all the cool kids use it
10:57:03 <mofmog> basically the reason is because you shoudlnt want to grapple with haskell's complicated syntax before knowing how recursion etc works
10:57:31 <skorpan> i don't really think haskell's syntax is that complicated
10:57:39 <skorpan> well... okay, it is
10:57:39 <mauke> meh, you can just start with haskell's simple syntax
10:57:47 <skorpan> yeah, you can start with simple stuff
10:57:50 <mauke> you don't have to learn it all at once
10:57:58 <skorpan> you don't *have* to use much at all
10:58:06 <mofmog> yeah but it's like
10:58:21 <mofmog> you can drive a glitzed out lexus without using all the features
10:58:32 <mofmog> but you might accidentally push the wrong button
10:58:53 <mauke> that doesn't seem to stop people in reality
10:58:59 <mofmog> reality is dangerous
10:59:17 <Craig``> that book is lisp?
10:59:20 <mofmog> Scheme
10:59:21 <mauke> scheme
10:59:33 <mauke> (another problem is finding a good scheme implementation)
10:59:39 <mofmog> DrScheme
10:59:44 <mauke> no.
10:59:51 <mofmog> iono, i used UCBScheme
10:59:56 <mauke> DrScheme is horrible because I couldn't figure out how to use it
11:00:03 <Craig``> im learning haskell though?
11:00:24 <mofmog> haskell and scheme are both functional programming languages that share many ideas
11:00:43 <psnively> mauke: You mean the problem is choosing which of N good Scheme implementations to use, surely.
11:00:45 <mofmog> if you know scheme, the concepts of haskell are easier to learn
11:00:53 <edwardk> mauke: hah. actually i applaud the ambitions of the plt scheme stuff.
11:01:04 <mauke> if you know perl, the concepts of haskell are also easier to learn
11:01:10 <vixey> haha
11:01:16 <mofmog> but scheme moreso!
11:01:25 <mauke> meh
11:01:30 <edwardk> mauke: maybe that was why i picked it up so fast =)
11:01:48 <mofmog> perl is good because it teaches you how to make sense of line noise
11:02:01 <mauke> mofmog: syntax is not line noise
11:02:10 <TomMD> If you hate pointer and errors, the concepts of Haskell are also easier to learn.
11:02:33 <edwardk> though i find having a richer type system for functions than 'sub foo ($$) { ... }' completely daunting ;)
11:02:42 <deech> Hi all, can I use unsafePerformIO like a System.Out.Println in Java?
11:02:43 <mauke> edwardk: ($$) is not about types
11:02:46 <edwardk> mofmog: bah, thats what sendmail is for
11:02:53 <vixey> deech no
11:02:55 <mauke> deech: no
11:03:02 <Botje> deech: if you want debugging output, look at Debug.Trace
11:03:16 <deech> Botje : Will do, thanks !
11:03:28 <TomMD> Or use the debugger...
11:03:54 <Botje> edwardk: perl6 will have a Proper Argument System(tm)
11:04:36 <vixey> UHC has LOADS of cool features!!
11:04:48 <vixey> check this out
11:04:53 <vixey> http://www.cs.uu.nl/wiki/bin/view/Ehc/Examples
11:05:08 <lpsmith> TomMD:  an understanding of pointers helps a Haskell programmer a lot,  especially using the language effectively
11:05:23 <lpsmith> Haskell does,  however,  free you from a lot of low-level pointer manipulation
11:05:40 <mauke> hey, I can write C in Haskell
11:05:47 <edwardk> ooh ...
11:06:05 <mofmog> haskell is a silly language
11:06:05 <TomMD> lpsmith: Yep, I was implying that hating errors that Haskell helps mitigate is a motivation of sorts.
11:06:10 <vixey> ids1 = single  id          -- :: forall a . [a->a]
11:06:10 <vixey> ids2 = single ~id          -- :: [forall a . a->a]
11:07:05 <edwardk> the kind polymorphism makes me drool. as do 'existentials anywhere'
11:08:37 <vixey> edwardk: yes! :p
11:08:49 <vixey> I think UHC looks great
11:09:20 <vixey> this is awesome to
11:09:21 <edwardk> instance (Binary a, (Binary b => Binary (f b))) => Binary (GRose f a) -- also looks interesting
11:09:25 <vixey> you can use  ...   in type annotations
11:09:29 <deech> Botje
11:09:44 <edwardk> yeah that was the 'oooh ...' above =)
11:09:52 <edwardk> maybe i should have been clearer ;)
11:09:54 <Botje> deech: sorry, you got cut off after "Botje" :)
11:09:58 <deech> Botje : I am looking at putTraceMsg, how do I use this outside of the IO Monad
11:10:01 <pumpkin> mofmog: :o
11:10:08 <Botje> deech: uh, look at "trace" instead
11:10:16 <Botje> :t trace
11:10:17 <lambdabot> Not in scope: `trace'
11:10:19 <centrinia> pumpkin: :O
11:10:21 <Botje> argh
11:10:27 <pumpkin> centrinia: :0
11:10:27 <Botje> @hoogle trace
11:10:28 <lambdabot> Debug.Trace trace :: String -> a -> a
11:10:28 <lambdabot> module Debug.Trace
11:10:28 <lambdabot> package traced
11:10:30 <Botje> deech: ^^
11:10:33 <vixey> looks like you can put anything in a  let  as well
11:10:34 <Botje> no pesky IO there
11:10:37 <vixey> data, instances, ..
11:11:01 <vixey> UHC does not feature the monomorphism restriction <333
11:11:06 <edwardk> vixey: instances make sense in their case because they allow explicit dictionary passing
11:12:26 <vixey> Feature: n+k patterns  implementation status:  Never
11:12:41 <dolio> It doesn't seem to do much defaulting.
11:12:41 <deech> Botje : I don't get what the second argument is for. I just want to be able to 'trace ( show myVariable ) ', what else is trace looking for?
11:13:01 <Zao> > trace "printthis" 42
11:13:02 <lambdabot>   Not in scope: `trace'
11:13:09 <dolio> If you do "let v = 3 in print v", it seems to complain about ambiguity.
11:13:25 <Botje> deech: trace prints something (first argument) and evaluates to its second
11:13:52 <Zao> trace is much like id, but it prints something as a sneaky side effect.
11:13:53 <mofmog> so i have a record, and an i pass it into the fuction, but i dont wanna have to keep calling accessors on it
11:13:57 <deech> Botje : So I can just go 'trace ( show myVariable ) ()' ?
11:14:14 <Zao> deech: If you want the expression to have the value (), yes.
11:14:14 <Botje> deech: maybe.
11:14:18 <Botje> depends where you stick it
11:14:34 <Botje> I usually just do spy x = trace (show x) x
11:14:36 <Zao> let sum = 4 + (trace "omg" 2)
11:16:08 <deech> Botje : How about 'trace ( show myVariable ) return ' ?
11:17:23 <pumpkin> there's traceShow
11:17:23 <Botje> deech: you probably don't want that either.
11:17:23 <Zao> Debug.Trace.trace (show 42) return :: (Monad m) => a -> m a
11:17:23 <deech> Botje : Ok, I was in an Maybe monad and I got the compiler to accept 'trace ( show myVariable ) Nothing'
11:17:23 <Botje> deech: another thing to do is fun x | trace x False = undefined
11:17:23 <PetRat> I'm trying to install the Sqlite3 driver for Database.HDBC on Windows XP... I was able to install HDBC via Cabal, then downloaded a zip file related to the Sqlite3 driver... problem is I don't know what to do with the contents of that zip file.. It has some haskell source like Sqlite3.hs, also Setup.hs, Makefile, a .c and .h file
11:17:40 <TomMD> PetRat: runhaskell Setup.hs [configure,build,install]
11:17:53 <TomMD> PetRat: Or just goto that directory and 'cabal install'
11:18:15 <deech> Botje: Thanks !
11:18:38 <PetRat> TomMD: got errror "missing C library sqlite3" (on running cabal install)
11:18:39 * vixey found out UHC doesn't have GADTs though :(
11:18:40 <TomMD> PetRat: Setup.hs is the standard install script that uses the Cabal library, but the cabal-install program (cabal.exe) will do fine.
11:18:54 <TomMD> PetRat: Have you installed sqlite3-dev library?
11:19:06 <TomMD> PetRat: You need to install any C deps manually.
11:19:19 <PetRat> TomMD: what I have done so far is use Cabal to install Database.HDBC
11:19:25 <cads> if I've got a build of cabal already up, is there any way I can update it from inside itself? or shall I have to build it manually again?
11:19:38 <TomMD> PetRat: So install sqlite3
11:20:01 <PetRat> You mean download sqlite3.dll and put it somewhere?
11:20:33 <TomMD> PetRat: http://www.sqlite.org/download.html
11:20:52 <TomMD> They have installers for those platforms that don't have package managers.
11:21:19 <PetRat> TomMD: This is WindowsXP... the Sqlite3 web page does not give instructions "per se" for installation. You can download sqlite3.dll but it doesn't say what to do wtih it.
11:21:59 <TomMD> PetRat: Just put it in your libraries directory.
11:22:14 <TomMD> PetRet: In XP I think thats C:\Windows\System or C:\Windows\System32
11:22:37 <Zao> Deploying such libraries system-wide is generally frowned upon.
11:22:46 <TomMD> PetRat: See above.  Also, you could put the DLL in the directory with your source/executable and it should build/link ok.
11:22:50 <Zao> Do a private deployment into your application dir or somewhere in the user PATH.
11:23:00 <Zao> One never links against a DLL.
11:23:04 <TomMD> Zao: Well I'm not a windows user, if you have better advice then yay.
11:23:10 <Zao> You either load it at runtime or link an import lib.
11:24:08 <mofmog> ok, i got a 2d array and now i wanna turn it into a string... hrm
11:24:10 <PetRat> Zao: to repeat the original question: trying to install the Sqlite3 driver for Database.HDBC on Windows XP... able to install HDBC via Cabal, then downloaded a zip file related to the Sqlite3 driver... problem is I don't know what to do with the contents of that zip file.. It has some haskell source like Sqlite3.hs, also Setup.hs, Makefile, a .c and .h file
11:24:19 <TomMD> mofmog: 'show'
11:24:44 <mofmog> tommd: obviously
11:24:48 <TomMD> :-)
11:24:51 <mofmog> defining show is the hard part -_-
11:25:06 <Zao> PetRat: I can't offer any insight to how to build the Haskell driver for it.
11:25:12 <PetRat> Zao: tried to run cabal install on the contents of that zip file (after unzipping) and got an error: missing C library : sqlite3
11:25:42 <holzensp> since we are on linking issues ;) Does anybody know whether it is possible to build modules into a static library and to have ghc link to that library later on?
11:25:47 <TomMD> PetRat: You might want to run cabal with -v3 to get more info, but its still just a header missing I think.
11:26:34 <p_l> PetRat: Download sqlite amalgamation source from sqlite.org, grab the gcc stashed in GHC's directory, compile it, link it into static library, leave it in the same directory as sources for SQLite driver... :D
11:26:51 <p_l> that combination *should* work
11:29:03 <PetRat> p_l: thanks I'll try
11:29:07 <mofmog> is there a fold for arrays
11:29:16 <mofmog> or a way to go from arrays -> lists
11:29:45 <holzensp> mofmog: elems
11:29:48 <p_l> PetRat: At least you weren't asking for SQLite3 as shared lib on linux/mips-le :>
11:30:02 <centrinia> > elems $ listArray [1..10]
11:30:03 <lambdabot>   Couldn't match expected type `(i, i)' against inferred type `[a]'
11:30:12 <centrinia> > elems $ listArray (1,10) [1..10]
11:30:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:30:13 <mofmog> ahh ok
11:31:03 <centrinia> > let elems' arr = [ arr ! i | i <- range arr] in elems' $ listArray (1,10) [1..10]
11:31:04 <lambdabot>   Couldn't match expected type `Array i e'
11:31:04 <holzensp> mofmog: if you want to do something with the indices as well: assocs
11:31:06 <holzensp> :t assocs
11:31:07 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
11:31:10 <holzensp> @t assocs
11:31:10 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:31:26 <centrinia> > let elems' arr = [ arr ! i | i <- indexes arr] in elems' $ listArray (1,10) [1..10]
11:31:27 <lambdabot>   Not in scope: `indexes'
11:31:38 <holzensp> centrinia: indices
11:31:45 <centrinia> > let elems' arr = [ arr ! i | i <- indices arr] in elems' $ listArray (1,10) [1..10]
11:31:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:31:50 <centrinia> Thanks. :)
11:31:54 <holzensp> np
11:32:01 <mofmog> im basically trying to take a 2d array and print out a nice formatted string with it
11:32:03 <kadaver> hey bitchasses, do you like Data.Graph?
11:32:35 <skorpan> kadaver--
11:32:38 <skorpan> @karma kadaver
11:32:38 <lambdabot> kadaver has a karma of -1
11:32:41 <roconnor> kadaver--
11:32:49 <holzensp> kadaver: a putrid smell of decay
11:34:05 <PetRat> p_l: I can't find gcc in the ghc directory (not in bin or anywhere else)
11:34:23 <PetRat> p_l: maybe I forgot to download something originally?
11:34:31 <holzensp> mmm... the -- notation seems a little unhaskell... shouldn't it be "(\x -> x-1) kadaver" ? :p
11:34:43 <p_l> PetRat: look for 'cc'
11:34:49 <p_l> or similar
11:34:54 <bremner> holzensp: karma monad
11:35:01 <holzensp> good point
11:35:03 <Zao> PetRat: Grabbing the amalgated source, gcc -c sqlite3.c && ar r libsqlite3.a sqlite3.o  seems to satisfy the configure step.
11:35:08 <kadaver> graphFromEdges' :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
11:35:11 <vixey> -- is a comment
11:35:14 <Zao> PetRat: Well, extra-lib-dirs: .  too
11:35:21 <kadaver> lets say i want a graph with distances between cities. how?
11:35:25 <Zao> Provided that you have the .h and the .a in the HDBC-sqlite3 dir.
11:35:55 <PetRat> Zao, p_l: no cc. nothing but variants on ghc
11:36:20 <p_l> PetRat: weird, I thought there was a copy of gcc in GHC windows package...
11:36:25 * holzensp is pulling up last Graph project
11:36:39 <PetRat> Maybe I should download mingw
11:36:56 <Zao> I've got the recommended mingw+msys setup.
11:37:22 <PetRat> Zao: what is that?
11:37:58 <Zao> http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Windows
11:38:22 <holzensp> Kadaver: I've always used buildG
11:38:29 <holzensp> @t buildG
11:38:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:38:31 <Zao> You probably don't need python or happy/alex/haddock
11:38:39 <mofmog> is there an intersperse that only interseperses every x elements?
11:39:16 <kadaver> Graphs are not showable, there doesnt seem to be a way to have weights. is this lib used at all?
11:39:17 <centrinia> Write your own. :)
11:39:39 <holzensp> kadaver: I use it all the time
11:39:58 <PetRat> Zao: I'll give it a try, thanks.
11:40:01 <PetRat> Zao++
11:40:28 <holzensp> mathematically, the idea of a "weighed graph" is muddy (or so my math-friends have been telling me); when I want to weigh my graph, I use a labelling function for the edges
11:40:40 <vixey> I don't agree that is muddy
11:41:27 <holzensp> neither do I, but I'm a lowly computer scientist ;)
11:42:10 <kadaver> centrinia: I just did. but it takes time and there is a diff between a small and big efficient lib.
11:42:59 <centrinia> If you want weighed graphs then you need to define the edge set as a set of triples with the first component being the source vertex, the second component being the destination vertex, and the third component being the weight.
11:43:07 <Zao> PetRat: Seems to have built and installed for me.
11:45:41 <holzensp> kadaver: what centrinia said, although, you might actually go another way altogether and implement the graph not as a Table [Vertex], but rather as Table [Table Weight]
11:45:47 <holzensp> or directly as a 2D array
11:46:00 <holzensp> you were thinking of doing Dijkstra stuff, right?
11:46:47 <kadaver> i dont get the Bounds /Table thing that buldG takes
11:47:44 <holzensp> The Graph is implemented as an Array... Array is defined with bounds
11:47:47 <Cale> haha, this just popped up while I was testing a simple HGL program... thtttttttttttrhhhhhhhhhhherrrrrrrrrrraeeeeeeeeeeedaaaaaaaaaaa dddddddddddb           lbbbbbbbbbbbolllllllllllcoooooooooookcccccccccccekkkkkkkkkkkdeeeeeeeeeee dddddddddddi           niiiiiiiiiiidnnnnnnnnnnnedddddddddddfeeeeeeeeeeeifffffffffffniiiiiiiiiiiinnnnnnnnnntniiiiiiiiiieittttttttttlteeeeeeeeeeyelllllllllllyyyyyyyyyyy
11:48:12 <Cale> It's a whole bunch of "thread blocked indefinitely"
11:48:17 <pumpkin> nice
11:48:25 <holzensp> yep, nice indeed
11:48:27 <holzensp> well done ;)
11:48:34 <centrinia> That can be run length encoded.
11:48:57 <holzensp> oh yes... will get nice results... not on the blocked threads, though ;)
11:50:56 <Cale> Another strange thing is that after drawing a filled region, I can't seem to draw anything else.
11:51:49 <kadaver> doesnt seem possible to rep a weighted graph with a 3-tuple
11:52:00 <holzensp> kadaver: why?
11:52:22 <holzensp> kadaver: (from :: Vertex, weight :: Int, to :: Vertex)
11:53:24 <holzensp> but the question is whether this is the representation most suited for your needs
11:53:42 <dddddd> holzensp: yes i was thinking of doing dijkstra yes
11:53:45 <dddddd> why?
11:54:15 <holzensp> dddddd == kadaver?
11:54:47 <dddddd> I did do dijkstra in my own but it is ugly and uses IORef, i implemented floyd-Warshall too, more functional
11:54:55 <dddddd> yes i am ddd when mirc fux up
11:55:13 <edwardk> dddddd: using ST it isn't so bad
11:55:14 <dddddd> but im writing my own graph lib just to learn graph theory
11:55:26 <pumpkin> dddddd: the convention is usually to append an underscore to your regular nick
11:55:29 <dddddd> ST=StateMonad?
11:55:30 <holzensp> erm... well, because depending on what algorithm you want to implement and where the trade-off is between readability and computational efficiency... you may chose different representations
11:55:47 <holzensp> I don't see why Floyd-Warshall is more functional, btw
11:56:01 <dddddd> but i dont want to write a complete professional graph lbi since thta is to much work
11:56:23 <edwardk> dddddd: ST = ST. its a different monad than State
11:56:48 <edwardk> it lets you work with references, like IO, but you can only do things that are safe to wrap up with a functional bow in the end.
11:57:04 <dddddd> holzensp: well it is easier to implemetn functionally than dijkstra
11:57:10 <holzensp> I don't really know what constitutes a "professional" lib ;) However... if you just want Dijkstra in a cleanly readable way... use Data.Graph and a weighting function
11:57:39 <holzensp> dddddd: I don't see that either; I did a Dijkstra a while back and it looks very functional
11:57:41 <edwardk> dddddd http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
11:58:57 <edwardk> basically you can newSTRef, and read and write them, but in the end you runST :: (forall s. ST s a) -> a and you can't access those references outside of that context.
11:58:59 <holzensp> (in my mind, FW is just doing Dijkstra n times)
11:59:21 <edwardk> dddddd: the quantifier there keeps you from doing anything 'non-functional' with ST
11:59:38 <edwardk> its a little bit of awesome
11:59:50 <holzensp> aw... edwardk is in love ;)
12:00:05 <edwardk> yeah
12:00:12 <edwardk> just don't tell my wife
12:00:26 <holzensp> isn't she in this channel?
12:00:50 <edwardk> she might be. i handed her 'learn you a haskell' a little while back ;)
12:02:22 <edwardk> and we did meet via irc like 16 years ago, but a functional love triangle would put undue stress on things ;)
12:02:41 <holzensp> :D
12:03:13 <holzensp> (let's leave it here before we run into jokes about how to wrap your wife in a WriterT and ST in a ReaderT and stuff gets nasty and nerdy)
12:04:33 <edwardk> well, i thought about passing her around in a State, but then realized that as long as I used the MTL and used ContT r (State Wife), I was in a better place, because if I ever did anything wrong, I could just call the continuation and she'd forget.
12:05:02 <edwardk> monadLib screwed up my plans though
12:05:18 <mauke> @quote fix.*rel
12:05:18 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
12:05:38 <edwardk> mauke: lol
12:06:14 <holzensp> edwardk/mauke: omg... this means it came up before
12:06:18 <holzensp> that's Just Wrong
12:06:45 <edwardk> bah, thats Nothing ;)
12:08:05 <skorpan> :t length
12:08:06 <lambdabot> forall a. [a] -> Int
12:12:07 <dddddd> FW?
12:12:15 <holzensp> Floyd-Warshall
12:12:42 <dddddd> oh ofc
12:13:18 <holzensp> a functional perspective on Dijkstra is to recursively remove visited nodes from the graph
12:13:33 <holzensp> and to keep a "head" or "gray" set of nodes that you've seen, but not visited
12:14:08 <dddddd> but how do I add a weightening function to Data.Graph?
12:14:25 <edwardk> > fix error
12:14:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:14:46 <holzensp> you can just define any function "myWeights :: Vertex -> Int" anywhere
12:17:08 <dddddd> and can anyoen show how to do weights directly? eventually i want to implement some optimization technique for stochastic search, like ant colony or simulated annealing
12:17:28 <holzensp> what is "directly" exactly?
12:18:19 <dddddd> but I dont see hwo that works, it needs to be integrated into the graph somehow
12:18:40 <holzensp> I can't shake the idea you're thinking of objects
12:18:42 <edwardk> type Table = Vertex -> [(Weight,Vertex)] -- or Array Vertex [(Weight,Vertex)]
12:18:59 <holzensp> or
12:19:06 <holzensp> Array (Vertex,Vertex) Weight
12:19:50 <cooldude127> Vertex needs have an instance for Ix doesn't it?
12:19:56 <cooldude127> if you use an array
12:20:06 <holzensp> yep, but it's default def is Int
12:20:24 <edwardk> holzensp: Array (Vertex,Vertex) (Maybe Weight) -- might be better than that for the adjacency matrix
12:20:41 <edwardk> cooldude127: yeah, Data.Graph assumes Vertex = Int
12:20:43 <holzensp> fair enough
12:20:48 <cooldude127> oh
12:21:47 <edwardk> Map Vertex [(Weight,Vertex)] -- might be better if Vertex is particularly sparse
12:24:26 <zachk> to use hgl (the hugs graphic library) in ghc what do i import?
12:24:27 <Pistos> Hi guys.  I was typing up the Haskell definition for my editor.  Any recommended URLs I can look at for a quick syntax overview, and/or common/standard style conventions?  Esp. re: indentation.
12:26:41 <mauke> .oO( rule 1: never mix spaces and tabs. rule 2: using tabs may get you hurt unless you follow some extra rules )
12:27:00 <byorgey> Pistos: http://haskell.org/onlinereport/ is the standard reference.
12:27:18 <Pistos> byorgey: Thank you.
12:29:09 <Pistos> What's the comment indent size?  I'm seeing both 2 and 4 in example code.
12:29:19 <Pistos> And, in fact, "line up" style indentation.
12:29:27 <pumpkin> yeah, the language follows that
12:29:34 <pumpkin> it's not a fixed offset
12:30:04 <mauke> Pistos: I use a fixed indentation of 4 (which would actually let me use tabs instead), but it seems most people don't
12:30:23 <Pistos> Welp, I want to put and use what is the most common.  :)
12:30:29 <Pistos> Or is there really no standard in that regard?
12:30:46 <edwardk> an argument against 2 is the fact that if you use haddock you need the -- | ... to start the coment, which also argues against 4 ;)
12:30:53 <Pistos> But "line up" indentation is going to be new and probably difficult to code...
12:30:56 <holzensp> you're talking about Haskell programmers... it's like herding cats
12:31:32 <edwardk> so "-- | This is a haddock comment." would put you at 5+ spaces for comments
12:31:41 <Pistos> I'm reading this.  Good idea / bad idea?  http://en.wikibooks.org/wiki/Haskell/Indentation
12:32:47 <tromp> 2 is enough for me
12:32:57 <malosh> Someone knows how I can use the GHC Api to load a function of type (Bounded a, Enum a)->[a]->a from an external haskell file ?
12:33:09 <Pistos> I see that the Real World Haskell book uses 4?
12:33:25 <edwardk> pistos: everything in there is factually correct, but they tend to use layout in a 'brittle' fashion throughout.
12:34:02 <edwardk> pistos: for instance i rarely use foo = do bar\n               baz -- because if i ever rename foo i have to reindent everything below it
12:34:37 <edwardk> pistos: so as style guidelines go, my rule of thumb is to never start a layout rule and put the first entry on the same line unless i glom it all onto that line.
12:34:54 <Pistos> That confuses me.  :)
12:35:19 <Pistos> But, clicking into later chapters, I do see that the RWH book does the line-up indentation.
12:35:20 <pumpkin_> grr
12:35:30 <edwardk> pistos: have you gotten to 'layout' in haskell?
12:36:05 <Pistos> Nnn... ot really?  Sort of just starting Chapter 2 of RWH.
12:36:10 <tromp> Apple App store will hit a billion downloads in a few hours
12:36:22 <edwardk> then don't worry about what i said just yet ;)
12:36:33 <Pistos> Okay.  :)
12:37:10 <mauke> what he means is: always start a new line after "do", "where", "let" and "of", unless it's followed by a single line thingy
12:37:43 <dddddd> so i should override the Table definition somehow?
12:37:56 <Pistos> mauke: Okay, I can live with that.
12:39:01 <edwardk> mauke: i actually don't allow you to violate that rule of thumb in my toy compiler. mainly because with that constraint changed in the way layout works it doesn't matter if you use a proportional font or if unicode characters render double-wide, etc. ;)
12:39:18 <holzensp> dddddd: type MyGraph = Map Vertex [(Weight,Vertex)]
12:39:22 <mauke> edwardk: or how wide your tabs are!
12:39:32 <pumpkin> GHC needs first-class thunks!
12:39:34 <holzensp> dddddd: dijkstra :: MyGraph -> Vertex -> Vertex -> [Vertex]
12:40:03 <edwardk> mauke: well, tabs still byte you if you want them to expand out to a given column # and they have mixed tabs and spaces
12:40:19 <mauke> well, see rule 1
12:40:22 <Deewiant> If you're doing that you're doing it wrong.
12:40:29 <edwardk> mauke: yeah =)
12:41:07 <edwardk> mauke: hrmm i suppose i could make it a parse error to have spaces lead into tabs and then i don't need to care
12:41:56 <edwardk> mauke: done =)
12:42:22 <edwardk> and thus ends the great tabs vs. spaces war.
12:43:08 <zsol> anyone care to help me with this: (fromMaybe length) . (findIndex (=='x'))
12:43:28 <zsol> I want to find the index of 'x' or return the full length
12:43:50 <edwardk> > (fromMaybe length) . (findIndex (=='x')) $ "Hello x World"
12:43:51 <lambdabot>   Couldn't match expected type `[a] -> Int'
12:44:00 <roconnor> @type (fromMaybe length) `ap` (findIndex (=='x'))
12:44:01 <lambdabot>     Couldn't match expected type `Maybe ([a] -> Int)'
12:44:01 <lambdabot>            against inferred type `[Char]'
12:44:01 <lambdabot>       Expected type: Maybe ([a] -> Int) -> [a]
12:44:11 <mauke> @pl \s -> fromMaybe (length s) (findIndex (=='x') s)
12:44:11 <lambdabot> liftM2 fromMaybe length (findIndex ('x' ==))
12:44:33 <roconnor> @type (fromMaybe length) >>= (findIndex (=='x'))
12:44:34 <lambdabot>     Couldn't match expected type `[a] -> Int'
12:44:34 <lambdabot>            against inferred type `[Char]'
12:44:34 <lambdabot>     Probable cause: `findIndex' is applied to too many arguments
12:44:56 <edwardk> > let findX y = fromMaybe (length y) $ findIndex (=='x') y in findX "Hello x World"
12:44:57 <lambdabot>   6
12:44:59 <roconnor> @pl \a -> f a (g a)
12:45:00 <lambdabot> ap f g
12:45:17 <edwardk> @pl \y -> fromMaybe (length y) $ findIndex (=='x') y
12:45:17 <lambdabot> liftM2 fromMaybe length (findIndex ('x' ==))
12:45:36 <roconnor> oh fromMaybe needs to be composed with length, not applied
12:45:38 <edwardk> that will work if you import Control.Monad.Instances
12:45:44 <pumpkin> @type (fromMaybe . length) `ap` (findIndex (=='x'))
12:45:45 <lambdabot> [Char] -> Int
12:45:45 <roconnor> @type (fromMaybe . length) `ap` (findIndex (=='x'))
12:45:46 <lambdabot> [Char] -> Int
12:45:59 <zsol> cool.
12:46:08 <zsol> I wonder how @pl works :)
12:46:13 <roconnor> zsol: it's better just to write out the pointful function
12:46:15 <zsol> seems to be smarter than me
12:46:17 <edwardk> deep magic
12:46:17 <roconnor> IMHO
12:46:29 <vixey> @pl does some rewrite rules in a loop
12:46:29 <lambdabot> (line 1, column 25):
12:46:29 <lambdabot> unexpected reserved word "in" or "i"
12:46:29 <lambdabot> expecting variable, "(", operator or end of input
12:46:35 <zsol> roconnor: I agree, though I like challenges
12:46:57 <zsol> vixey: you mean graph rewriting?
12:46:59 <roconnor> zsol: okay.  Well, your first mistake was that you needed fromMaybe . length
12:47:37 <zsol> yeah I see that now
12:47:43 <vixey> term rewriting
12:47:44 <roconnor> and the `ap` solution requires you to import the ((->) r) monad instance.
12:47:49 <vixey> not graph rewriting
12:48:05 <thoughtpolice> preflex: seen dons
12:48:06 <preflex>  dons was last seen on #xmonad 22 hours, 20 minutes and 14 seconds ago, saying: well, that's the text prior to being shipped, it's 95% of what is in the published version
12:48:09 <iListenU> Please help, i get problem in: http://parduoduv.puslapiai.lt at header error. (top). What can it be?
12:48:24 <Botje> oh fucks sake
12:48:31 <Botje> die, spammer
12:48:33 <pumpkin> lol
12:48:35 <roconnor> arguably we ought to have a concrete name for `ap` in the ((->) r) monad for cases like this
12:48:37 <pumpkin> that was a smart one though
12:48:44 <pumpkin> people are going to start asking fake haskell questions
12:48:49 <zsol> roconnor: how about <*> from Control.Applicative
12:49:16 <roconnor> you would still need to import an applicative instance for ((->)r) from somewhere
12:49:18 <zsol> seems to work as well
12:49:20 <zsol> yeah
12:49:40 <roconnor> <*> is nice(ish) if you want to import Control.Applicative
12:50:28 * pumpkin thinks it should be in the prelude :P
12:50:32 <pumpkin> along with <$>
12:50:36 --- mode: ChanServ set +o mauke
12:50:36 --- mode: mauke set +b *!*@78-57-141-87.static.zebra.lt
12:50:52 <roconnor> pumpkin: should ((->)r) monad/applicative be in the prelude?
12:50:59 <pumpkin> definitely
12:51:03 <pumpkin> I use it all the time
12:51:07 <roconnor> hmm
12:51:11 <roconnor> probably
12:51:21 <roconnor> It makes confusing errors
12:51:25 <roconnor> but what the hell
12:51:34 <pumpkin> maybe those could be improved a bit
12:51:34 <roconnor> in for a penny, in for a pound
12:51:40 <pumpkin> but I definitely like it
12:52:05 <pumpkin> of course, my approval is not sufficient to warrant adding it to the prelude :P
12:52:21 <roconnor> do you have a PumpkinPrelude module that exports everything you want?
12:52:23 <sjanssen> roconnor: it should be in the Prelude because of the orphan instance rule
12:52:36 --- mode: mauke set -o mauke
12:52:53 <pumpkin> roconnor: not really, it feels dirty to make my own personal lib of stuff, somehow
12:53:06 <sjanssen> pumpkin: I agree
12:53:19 <pumpkin> there's a package on hackage which is full of useful stuff
12:53:29 <pumpkin> but it's all someone's initials
12:53:44 <pumpkin> and that bothers me, for some irrational reason :P
12:53:48 <roconnor> ya
12:53:51 <sjanssen> pumpkin: which package?
12:53:51 <roconnor> sounds irrational
12:54:05 <dolio> There's also liboleg.
12:54:06 <pumpkin> sjanssen: all the modules end in .HT
12:54:11 <pumpkin> iirc
12:54:19 <sjanssen> Henning Thieleman?
12:54:44 <pumpkin> yeah :)
12:54:49 <dolio> Although only the package name involves someone's name there.
12:54:56 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utility-ht
12:55:06 <dolio> Hahaha.
12:55:06 <pumpkin> importing Data.Maybe.HT feels weird
12:55:18 <sjanssen> yes, I don't like this style of package
12:55:24 <sjanssen> missingh is another example
12:55:46 <pumpkin> yeah, it's a bag of random stuff
12:55:50 <pumpkin> a lot of which is useful
12:56:00 <roconnor> well, bags of random stuff are problematic
12:56:19 <roconnor> because you end up depending on a lot of stuff that you don't depend on.
12:56:25 <pumpkin> yeah
12:56:32 <roconnor> so that I can understand
12:57:02 <roconnor> if missingh was a big bag of random pure functionality, I wouldn't have a problem
12:57:21 <roconnor> pure isn't quite the right word
12:57:30 <pumpkin> but even if utility-ht weren't a bag of random stuff, I still feel uncomfortable importing a bunch of .HT stuff, dunno why
12:57:39 <dolio> So here's a quiz: if you're discussing recursion vs. iteration, and which is "more generic", and someone says "conditional branch", what does that mean?
12:58:05 <roconnor> conditional branch is an if branch?
12:58:06 <seliopou> is that IO vs FFI thread still going?
12:58:08 <pumpkin> sounds to me like it's talking on a different level where the two are the same
12:58:10 <pumpkin> :P
12:58:23 <dolio> roconnor: No idea.
12:58:33 <vixey> conditional branch is probably pattern matching
12:58:38 <mauke> dolio: do you know any asm?
12:58:38 <roconnor> I have no idea what generic means WRT recursion vs iteration
12:58:39 <vixey> idk
12:58:41 <dddddd> is there a better way to invert a Map than : M.fromList $ map (\(a,b) -> (b,a)) $ M.toList m ?
12:58:43 <pumpkin> when we compile iteration and recursion, both lead to branching  on the machine level :P
12:58:53 <pumpkin> that's what it sounds like to me
12:58:57 <dolio> mauke: Yeah, I figured that's what he meant. But he's still an ass.
12:59:10 <mauke> conditional branch = the goto-if instruction
12:59:11 <roconnor> I thought we get the same machine code from iteration and recursion
12:59:33 <dolio> Well, you don't in python.
12:59:46 <pumpkin> dolio: who's an ass?
12:59:55 <pumpkin> oh, you talking about the guido post?
13:00:21 <seliopou> ohhh
13:00:26 <dolio> pumpkin: The "my assembly instruction is the most general control flow abstraction" guy.
13:00:37 <pumpkin> :o
13:00:42 <roconnor> ya, in assembly a conditional branch is anyone of those jmp-on-some-condition instructions
13:01:10 <pumpkin> I haven't had the pleasure of meeting that guy
13:01:17 <dolio> You're lucky.
13:01:28 <seliopou> dolio, it's not an abstraction :(
13:01:32 <pumpkin> I'm not even sure how it's meaningful to be talking about recursion vs. iteration at that level
13:01:59 <seliopou> at least to people that write software...
13:02:11 <dolio> At that level, recursion and iteration are like design patterns.
13:02:19 <pumpkin> yeah
13:02:29 <pumpkin> they're not a feature of the language though
13:02:33 <roconnor> what guido post?
13:02:57 <seliopou> The Guido Post in which He Confuses His Opinions for Arguments
13:02:58 <pumpkin> roconnor: the one I was talking about was guido's justification for not including TCO
13:03:08 <dddddd> does asm have loop? or just goto?
13:03:15 <vixey> lol
13:03:17 <jmcarthur> heh
13:03:19 <dolio> seliopou: That might be ambiguous.
13:03:20 <pumpkin> well, I would've answered...
13:03:28 <roconnor> Total Cost of Operation?
13:03:35 <pumpkin> tail-call optimization
13:03:36 <seliopou> dolio, right
13:03:36 <dolio> Tall call optimization.
13:03:43 <roconnor> oh
13:03:52 <roconnor> pfft
13:03:53 <seliopou> he wasn't event talking about TCO, he was talking about TRO
13:04:04 <seliopou> which... I just don't get
13:04:05 <pumpkin> roconnor: zomg, python is too dynamic for things like that, no TCO for you... 1000 stack frames should be enough for everyone
13:04:08 <dddddd> anyone here ever write anything significant in asm?
13:04:15 <pumpkin> seliopou: he sounded confused
13:04:23 <pumpkin> dddddd: a few things
13:04:23 <vixey> I wrote factorial in asm
13:04:24 <roconnor> just to a CPS pass on your python.
13:04:28 <roconnor> that's what I do!
13:04:36 <vixey> oh and I wrote aa program that prints out a pyramid
13:05:22 <pumpkin> dddddd: there are many different asms, btw :)
13:05:26 <roconnor> dddddd: I wrote a very mini DOS shell called UM-DOS
13:05:34 <vixey> can you do monadic reflection multiple times instead of using monad transformers?
13:06:20 <pumpkin> wow, dddddd's connection is wonderful
13:06:22 <seliopou> peer's cleaning house on d
13:06:32 <vixey> ??
13:06:38 <pumpkin> dddddd: you on a IP over pigeon carrier link?
13:06:47 <jmcarthur> vixey: "Connection reset by peer"
13:06:53 <vixey> what
13:06:58 <pumpkin> his quit message
13:06:59 <roconnor> icfp2006$ ./vm COMMAND.UM
13:07:00 <roconnor> C:\>ver
13:07:02 <roconnor> UM-DOS version 1.00
13:07:03 <pumpkin> well the error
13:07:03 <roconnor> C:\>exit
13:07:19 <sjanssen> roconnor: nice
13:07:23 <pumpkin> roconnor: and submitted it tto icfp2006?
13:07:29 <roconnor> C:\>dir
13:07:31 <roconnor>   Volume in drive C is CLV
13:07:32 <roconnor>   Volume Serial Number is 0BAD-WOLF
13:07:34 <roconnor>   Directory of C:\
13:07:35 <roconnor> README   TXT            659 07-26-:6  12:00p
13:07:37 <roconnor> SOLUTION TAR        3778560 07-26-:6  12:00p
13:07:38 <roconnor>           2 file(s)        3779219 bytes
13:07:40 <roconnor>                                  0 bytes free
13:07:42 <roconnor> pumpkin: ya
13:07:47 <sjanssen> icfp2006 was so fun
13:07:53 <vixey> wha's that roconnor?
13:08:07 <DrSyzygyFR> How does do let work again?
13:08:07 <edwardk> i loved icfp06!
13:08:15 <roconnor> vixey: that is what my UM assembly program did
13:08:15 <DrSyzygyFR> And how do I ... define stuff in a do clause?
13:08:20 <edwardk> that was the best icfp programming contest ever
13:08:29 <dolio> vixey: Have you read this: http://www.cs.ioc.ee/mpc-amast06/msfp/filinski-slides.pdf
13:08:38 <roconnor> C:\>help
13:08:40 <roconnor> Bad command or file name
13:08:41 <roconnor> Available Commands: DIR, EXIT, TYPE, VER
13:09:27 <roconnor> My favourite is the dates for the files
13:09:30 <vixey> You implemented a command line?
13:09:34 <roconnor> 07-26-:6  12:00p
13:09:38 <roconnor> vixey: ya
13:09:47 <roconnor> they said they accepted UMZ submissions
13:10:16 <roconnor> another team member was able to compile a decompressor to UM assembly
13:10:40 <roconnor> so our TAR file was stored compressed, and decompressed with TYPEd
13:11:01 <roconnor> I'm not sure if UM assembly is what dddddd had in mind
13:11:13 <DrSyzygyFR> There has GOT to be a nicer way to do: do f <- return $ someFunc
13:11:18 <DrSyzygyFR> Anyone?
13:11:29 <roconnor> let f = someFunc
13:11:45 <glguy> there wouldn't happen to be some shortcut when using cabal and installing a new version of GHC to have cabal reinstall everything I used to have, is there?
13:11:46 <edwardk> DrSyzygyFR: let is available inside 'do'
13:12:17 <DrSyzygyFR> edwardk: The same way as in ghci or the same way as everywhere else?
13:12:31 <sjanssen> glguy: you could massage the output of ghc-pkg list into some 'cabal install' commands
13:13:17 <roconnor> vixey: the command line is pretty simple since all the results are hard coded. :P
13:15:00 <glguy> network-bytestring doesn't work with ghc 6.10.2?
13:15:01 <glguy> bah
13:16:06 <mauke> it doesn't?
13:16:13 <roconnor> then I wrote an article on how to write an assembler in Haskell using recursive do for the "Monad.Reader"
13:16:22 <glguy> mauke, well, the released version doesn't build
13:16:33 <glguy> I don't know that there aren't patches to fix it already
13:16:43 <edwardk> DrSyzygyFR: same way
13:17:47 <edwardk> roconnor: i had a small set of llvm bindings using that trick which i dumped when bos and lennart put out a more robust set of bindings
13:17:56 <mauke> glguy: I have 0.1.2
13:17:58 <roconnor> > succ '9'
13:17:59 <lambdabot>   ':'
13:18:28 <roconnor> edwardk: all thanks to the ICFP '06 contest
13:19:01 <edwardk> roconnor: i used gnu lightning to jit for icfp 06
13:19:23 <roconnor> :P
13:19:37 <roconnor> I was scared of dynamically changing code
13:20:10 <roconnor> I also tried "compiling" every instruction into a closure. ... that didn't work out so good.
13:20:11 <vixey> thanks dolio that's really cool stuf
13:20:21 <roconnor> @quote closure
13:20:21 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
13:20:33 <roconnor> @quote closure
13:20:33 <lambdabot> roconnor says: life lesson from today: 1 closure is nice, 500 000 closures sucks
13:20:39 <edwardk> well, i kept the simple one thats sitting at the top of dons old um benchmarks, but the jitted version worked for everything that came out of the machine, didnt appear to have any self-modifying code issues
13:20:53 <roconnor> indeed, I understand it didn't
13:22:24 <bos> mmmm, llvm.
13:22:33 <dolio> vixey: I think the answer is that he still uses transformers, but you probably need to to explain how the embedded effects interact.
13:22:43 <dolio> At least, you need some way of specifying that.
13:22:45 <DrSyzygyFR> Whut???
13:22:46 <DrSyzygyFR> *** Exception: No match in record selector OperadGB.subTrees
13:24:29 <edwardk> roconnor: i also wrote an incredibly bad jit using hsplugins that shall not be spoken of again
13:24:36 <vips> hello ??
13:24:40 <edwardk> roconnor: it was awesome on the second day or so of use.
13:24:41 <roconnor> :)
13:25:04 <vips> Well i have some questions regarding c++ programming ? Which are making me mad...
13:25:36 <dolio> C++ can have that effect.
13:25:59 <edwardk> vips: well, there is a lovely channel that might be more appropriate called #c++ ;) but we're generally helpful
13:26:18 <Zao> edwardk: Well, ##c++
13:26:38 <glguy> mauke, what version of network do you have?
13:26:44 <vips> well , seriously due to non-standardised paradigms now c++ has become a pain in my ass..
13:26:56 <mauke> glguy: network-2.2.1
13:27:08 <glguy> mauke, what did you have to tell cabal for it to be able to build?
13:27:28 <mauke> uh, I don't know
13:27:35 <vips> edwardk , i opted for the room , since there are 628 people around ,and many must be knowing c++ too ??
13:27:51 <edwardk> vips: a good reason to switch to haskell ;)
13:27:56 <glguy> maybe there are a few different "0.1.2" releases floating around
13:27:58 <mauke> vips: why don't you ask in #gentoo then?
13:28:04 <DrSyzygyFR> Would a return early in a do notation break me out of it?
13:28:13 <mauke> vips: or ##php, actually
13:28:20 <Botje> DrSyzygyFR: nope
13:28:23 <DrSyzygyFR> I want to do something like do guard a; guard b; guard c; if d then return e; guard f; guard g; return h
13:28:25 <mauke> DrSyzygyFR: no, 'return' is a function like any other
13:28:27 <vips> hey , actually i have few questions if you could help me out ?
13:28:35 <DrSyzygyFR> Anyway to break out early from a do sequence?
13:28:35 <vixey> do guard a; guard b; guard c; if d then return e else do guard f; guard g; return h
13:28:41 <DrSyzygyFR> Ah.
13:30:29 <DrSyzygyFR> >.< I'm getting a parse error/incorrect indentation on my else
13:31:03 <DrSyzygyFR> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4140#a4140
13:32:02 <vixey> do this
13:32:04 <vixey> if ...
13:32:07 <vixey>    then ...
13:32:09 <vixey>    else ...
13:32:34 <Botje> DrSyzygyFR: the let at line 8 must be at the same level of indentation as lines 9-12
13:33:02 <glguy> ah, the version of network-2.2.1 that came with ghc-6.10.2 for me was broken
13:33:04 <glguy> I had to reinstall
13:33:20 <DrSyzygyFR> Found a different way to do it.
13:33:23 <DrSyzygyFR> But thanks, Botje !!
13:33:31 <glguy> then network-bytestring could find the export it needed
13:33:31 <DrSyzygyFR> vixey: Oooooh.
13:36:28 <burp_> what could be the issue when my local lambdabot just prints "Terminated" on haskell evaluations?
13:36:36 <burp_> have a guess please ;-)
13:57:11 <burp_> @let (+) = (-)
13:57:12 <lambdabot>  Defined.
13:57:15 <burp_> > 1+1
13:57:16 <lambdabot>       Ambiguous occurrence `+'
13:57:16 <lambdabot>      It could refer to either `Prelude.+', imp...
13:57:21 <burp_> damn :>
13:57:45 <mauke> @define
13:57:52 <burp_> @undefine (+)
13:58:10 <burp_> > 1+1
13:58:11 <lambdabot>   2
14:00:40 <bvck> Hopefully quick question. When I ask ":kind Monad" in ghci, I get the following response '<interactive>:1:0: Class `Monad' used as a type'. Can someone please explain this?
14:00:58 <bvck> Is there some equivalence between class and type in terms of implementation?
14:01:33 <vixey> Monad is a class
14:01:42 <vixey> Maybe is a Monad ..
14:02:06 <bvck> vixey: what does it mean 'used as a type' there?
14:02:13 <mauke> bvck: only types have kinds
14:02:21 <mauke> you can't ask for the kind of a class
14:02:27 <Heffalump> which is a shame
14:03:13 <vixey> kind is sorf of the wrong name for it ?
14:03:33 <vixey> we have Monad m, m :: * -> *, it's not Monad :: (* -> *) -> *
14:03:42 <bvck> mauke: I got that (thanks to Saizan). I am more curious about the statement being printed by GHCI here.
14:04:00 <bvck> 'used as a type' that is.
14:04:02 <mauke> what
14:04:25 <burp_> @check 1 > 0 <lambdabot>  Terminated
14:04:26 <burp_> :(
14:04:26 <lambdabot>       precedence parsing error
14:04:26 <lambdabot>          cannot mix `(>)' [infix 4] and `(<)' ...
14:05:29 <twanvl> "Class"/"Predicate" is like a kind, so Monad :: (* -> *) -> Predicate
14:05:44 <bvck> mauke: Saizan (in another chat) had explained only types having kinds to me.
14:06:10 <mauke> bvck: then what is your question?
14:07:04 <bvck> Let me try again...:)  Am I reading too much into 'Class 'xxx' used as a type'. Is there some 'internal' match or implementation between class and types?
14:07:26 <mauke> WHAT
14:17:07 <PetRat> Anyone here with experience installing the Sqlite3 drivers for HDBC for Windows?
14:17:24 <Zao> PetRat: No luck yet?
14:17:58 <PetRat> Zao: good you're here. I followed the instructions on that page to install MinGW, MSYS, etc., but don't know what to do now.
14:18:34 <PetRat> I think I need to put MinGW on the path, perhaps?
14:18:51 <Zao> Did you set up msys's fstab to point at your mingw setup?
14:19:02 <PetRat> Not that I'm aware of.
14:19:32 <PetRat> When MSYS installed, it did run some kind of postprocessor telling me it was "syncing" with MinGW
14:19:46 <Zao> Start msys, see if running gcc there find gcc.
14:20:24 <PetRat> Zao: okay, yes MSYS does find gcc
14:20:44 <Zao> If so, unpack the sqlite3-amalgated zip somewhere and gcc -c sqlite3.c && ar r libsqlite3.a sqlite3.o
14:21:29 <Zao> Then edit HDBC-sqlite3.cabal and add extra-lib-dirs: and extra-include-dirs to wherever you put the files.
14:21:48 <Zao> _then_ finally you should be able to cabal configure/build/install from that dir.
14:22:22 <PetRat> Okay running gcc went fine.
14:23:48 <PetRat> Zao: do you know, in .cabal files on windows, do they need forward slash or backslash?
14:24:02 <PetRat> ..for path names. Also can it accept a relative path?
14:24:11 <Zao> No idea, I put the files in the HDBC-sqlite3 dir so I just used   .
14:24:15 <Zao> So yes, relative should be fine.
14:25:09 <Zao> If this was a linux/osx/whatnot system these files would be available in the system search paths, most probably.
14:26:33 <kadaver> hmm, if i create a a Map of Maps of a file with words. ie the map is: WordX [(wordAfterWordX, count),(anotherWordAfterWordX,anotherCount)]. that is a markov chain right. and it is a directed graph where the edges(weights) are probabilities(once counted the counts are transformed toprobabilities)
14:27:04 <PetRat> Zao: so I type extra lines that start extra-lib-dirs and extra-include-dirs?
14:27:20 <Zao> PetRat: Awy.
14:27:31 <Zao> Much similiar to the include-dirs: one that already exist.
14:27:57 <Zao> If you put the files in the same dir as the .cabal, you only need the extra-lib-dirs: one.
14:28:19 <PetRat> Do they go in the Libary section, the Executable runtests section, or both?
14:29:13 <Zao> You could probably put them before both and it'd propagate properly.
14:29:17 <Zao> I'm not too familiar with .cabal
14:29:26 <Zao> Try it and see :)
14:31:09 <PetRat> Cabal is not happy with extra-include-dirs. Says it'sn ot a valid field.
14:31:46 <Zao> Skip that then.
14:32:13 <PetRat> Doesn't like extra-lib-dirs either.
14:32:49 <PetRat> Some existing fields are include-dirs, Extra-Libraries, extra-source-files
14:33:00 <Zao> Put it inside Library and Executable then.
14:33:20 <enolan> How can I get cabal install to build HsColour-ised source by default?
14:33:32 <vixey> @free id
14:33:34 <lambdabot> f . id = id . f
14:33:34 <vixey> @free const
14:33:35 <lambdabot> f . const x = const (f x) . g
14:33:36 <vixey> @free flip
14:33:37 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
14:34:08 <PetRat> Zao: it's complaining about a path outside the source tree.. I'll just move everything into the HDBC-sqlite3 diretory and try again.
14:35:51 <PetRat> Zao: Worked! Turns out it wanted --extra-lib-dirs as a command-line option. At least that's how I got it to work.
14:36:10 <dcoutts> PetRat: in the .cabal files it's "extra-lib-dirs"
14:36:11 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
14:36:25 <dcoutts> PetRat: and yes, same on the command line
14:36:42 <dcoutts> @seen Lemmih
14:36:43 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 4h 26m 44s ago.
14:37:07 <Zao> It's probably possible to throw those at cabal to avoid the whole unpacking business if you have suitable magic.
14:37:57 <PetRat> Okay, now I can't load Database.HDBC.Sqlite3. I can load Database.HDBC
14:38:08 <PetRat> I'm looking at chapter 21 in RWH.
14:38:17 <Zao> Did you remember to install it? :)
14:38:33 <Zao> Is it shown in ghc-pkg list?
14:39:01 <PetRat> I did install it... that's what I was trying to get to work... however, typing cabal install again, now I get an error.
14:39:38 <PetRat> Okay, yes cabal install runs without error.
14:39:53 <PetRat> How do I check the ghc-pkg list?
14:40:15 <Saizan_> run "ghc-pkg list"
14:40:17 <PetRat> Okay, yes it's shown in ghc-pkg list.
14:40:54 <PetRat> Shown as HDBC-sqlite3-2.1.0.0
14:41:26 <glguy> Anyone have a good URL about how thread context switching to the main thread is expensive and so you are supposed to forkIO your logic out of that thread?
14:41:31 <glguy> (in GHC)
14:43:26 <lunatic> Whats going on with code.haskell.org? It's timing out for me.
14:43:50 <PetRat> Typing :module Database.HDBC works. However :module Database.HDBC.Sqlite3 gives an error (module not loaded)
14:44:18 * mofmog is hesitant about doing a clean install for jaunty
14:45:06 <PetRat> Never mind, I guess it wasn't working because I ran ghci in the same directory as cabal install. Now it seems to work. Thanks everyone.
14:46:03 <Zao> PetRat: Awesome.
14:46:30 <burp_> @hoogle popen
14:46:30 <lambdabot> package popenhs
14:46:52 <mauke> http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html
14:47:13 <bindreturn> Hi all, I am trying to install bytestring-lexing-0.2 from cabal and it is indicating it cannot find alex although I have just manually installed also via cabal. Anyone have an idea ?
14:47:18 <burp_> which popen does lambdabot use?
14:47:57 <dcoutts> bindreturn: it's probably not on the $PATH
14:48:37 <burp_> lambdabot, your documentation is crappy
14:48:38 <bindreturn> dcoutts, I need to add the alex directory in .cabal to $PATH ?
14:48:40 <dcoutts> bindreturn: you should either put ~/.cabal/bin on the $PATH, or change your ~/.cabal/config to symlink-bindir: to your $HOME/bin
14:49:14 <bindreturn> I havent had any other issues with cabal installing packages
14:49:22 <burp_> (out,err,_) <- popen binary ["-E", "--timelimit=", "10", "-l", load, "--expression=" ++ src] Nothing
14:50:03 <dcoutts> bindreturn: sure, it's just that you've not been installing any programs I presume
14:50:13 <cinema> kosmikus, Do you know if there will be several advanced haskellers at the Utrecht's summer school ?
14:50:36 <jfredett> is there any specific reason `cabal install haxml` installs version 1.13 and not the latest version?
14:50:52 <dcoutts> bindreturn: so alex installed fine, but the ~/.cabal/bin dir is not on the $PATH. The symlink-bindir setting in the ~/.cabal/config allows you to install to ~/.cabal/bin but to add symlinks into ~/bin
14:51:06 <burp_> well, no wonder.. lambdabot had missing dependencies..
14:53:38 <bindreturn> dcoutts ok i think this makes sense, I installed cabal installed hoogle and remember i had to do something funny
14:53:45 <jfredett> ahh- methinks it's because these versions are not marked stable, okay -- solved my own problem.
15:00:41 <mm_freak> :i Category
15:00:44 <mm_freak> @info Category
15:00:45 <lambdabot> Category
15:00:51 <mm_freak> @i Category
15:00:51 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
15:02:02 <vixey> oh everyone is leaving, I guess they got sick of haskell!
15:05:23 <Botje> perhaps they have a lazy irc client which only keeps #haskell around for as long as they need it :
15:05:50 <bindreturn> dcoutts,   An alex binary is installed ok in  ~/.cabal/bin/. I did export PATH="$PATH:~/.cabal/bin" which works to make binaries available in shell. However cabal install bytestring still reports that it cannot find alex.
15:06:34 <bindreturn> Is it possible that bytestring has its dependency hardcoded not to .cabal ?
15:07:22 <suchsuch> How do you pick between two design choices like:
15:07:24 <suchsuch> class Special a
15:07:26 <suchsuch>     run :: a -> IO ()
15:07:27 <suchsuch> versus   data Special a = Special {run :: a -> IO()}
15:07:30 <alexp> whats going on with the darcs repo on code.haskell.org?
15:07:36 <alexp> I haven't been able to access it for a few hours now
15:07:54 <vixey> suchsuch: I choose data
15:08:15 <dcoutts> bindreturn: hmm, bytestring does not need alex.
15:08:36 <suchsuch> is the data version more flexible or are the same?
15:08:37 <dcoutts> bindreturn: perhaps you could use hpaste to show the command you're running and the output.
15:08:41 <alexp> anyone?
15:09:38 <bindreturn> dcoutts I am trying to install attoparsec which has a dep on bytestring-lexing which has dep on alex,
15:09:46 <bindreturn> I do    cabal install bytestring-lexing
15:10:04 <dcoutts> bindreturn: ah bytestring-lexing not bytestring, ok.
15:10:05 <pumpkin> do cabal install alex
15:10:06 <bindreturn> after exporting new $PATH with bin
15:10:24 <pumpkin> it can't install alex as a dependency directly, afaik
15:10:36 <bindreturn> pumpkin alex installed ok
15:10:42 <dcoutts> bindreturn: and alex --version works ok?
15:10:44 <pumpkin> oh ok :)
15:11:01 <solistic> Say we have:
15:11:03 <solistic> data Type = Foo | Bar | Baz
15:11:03 <solistic> f x = case x of Foo -> 1 Bar -> 2
15:11:16 <bindreturn> yes i first tried just cabal install attoparsec and then narrowed back down to try and install deps specifically
15:11:44 <bindreturn> dcoutts, Well you have me there, I dont know what alex is supposed to do except lex something ;-)
15:11:46 <solistic> then we have a none-exhaustive pattern
15:12:01 <defu1> can infix operators have more than two arguments?
15:12:02 <solistic> so is it possible to make ghc warn about it (or even forbid)?
15:12:07 <mauke> defu1: yes
15:12:09 <bindreturn> typing alex at cli   appears to run however
15:12:11 <defu1> thanks.
15:12:11 <pumpkin> solistic: -Wall
15:12:29 <suchsuch> it's always arg 1 + arg2 arg3  etc though
15:12:36 <dcoutts> bindreturn: ok, can you use hpaste to show the command you're running and the output.
15:12:37 <bindreturn> eg i get the prompt --> Usage: alex [OPTION...] file
15:12:38 <dcoutts> @hpaste
15:12:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:12:57 <glguy> (arg1 ? arg2) arg3 arg4
15:13:00 <bindreturn> yep
15:13:01 <bindreturn> thanks
15:13:26 <solistic> pumpkin, thx:)
15:19:05 <bindreturn> dcoutts, pumpkin   --> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4148#a4148
15:28:40 <dcoutts> bindreturn: could you annotate that paste by re-running the last command again but with -v3 so we can see how it's finding alex.
15:35:28 <bindreturn> dcoutts, annotated with -v3
15:38:27 <gbacon> in http://neilmitchell.blogspot.com/2008/05/interactive-tagsoup-parsing.html there's odd syntax in the list comprehension. Is it a form of view pattern?
15:38:42 <gbacon> let packages = sort [x | a:TagText x:_ <- tails parsed, a ~== "<a href>"]
15:39:24 <vixey> gbacon, no
15:39:31 <Botje> (a:TagText x:_) <- tails parsed
15:39:45 <Botje> that's just list deconstruction at work
15:39:49 <vixey> > [ x | x <- [1 .. 10] ]
15:39:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:39:51 <vixey> > [ x | x <- [1 .. 10], [] ]
15:39:52 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
15:39:56 <vixey> :/
15:39:58 <vixey> > [ x | x <- [1 .. 10], False ]
15:39:59 <lambdabot>   []
15:40:06 <Botje> gbacon: or do you mean the ~== part?
15:40:07 <vixey> > [ x | x <- [1 .. 10], odd x ]
15:40:08 <lambdabot>   [1,3,5,7,9]
15:40:10 <Zao> vixey: No comma.
15:40:40 <gbacon> Botje: no, I mean the single colons.. oh, is that just cons?
15:41:13 <Zao> That comprehension hurts to look at.
15:41:26 <Botje> yes
15:41:29 <gbacon> > tails [1..5]
15:41:30 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
15:41:47 <gbacon> [(a,b) | a : b : _ <- tails [1..5]]
15:41:51 <gbacon> > [(a,b) | a : b : _ <- tails [1..5]]
15:41:52 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
15:42:22 <gbacon> ok ok.. weird visual parse
15:42:31 <gbacon> thanks Botje and vixey
15:43:48 <mholub_> why [String] return value for regex match was removed from haskell?
15:44:07 <mholub_> and what should I use instead? [[String]]?
15:46:30 <mholub_> > "foo" =~ "foo"
15:46:31 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
15:46:31 <lambdabot>                ...
15:46:52 <mholub_> "foo" =~ "foo" :: Bool
15:47:06 <mholub_> > "foo" =~ "foo" :: Bool
15:47:08 <lambdabot>   True
15:47:31 <mholub_> >  "foo" =~ "foo" :: [String]
15:47:32 <lambdabot>   ["foo"]
15:57:16 <dev31212> ?let x = 5
15:57:17 <lambdabot>  Defined.
15:57:32 <dev31212> ?let foo x y = map x y
15:57:33 <lambdabot>  Defined.
15:57:44 <dev31212> ?let h = foo (+5) 20
15:57:45 <lambdabot>  <local>:5:9:
15:57:45 <lambdabot>      Ambiguous occurrence `+'
15:57:45 <lambdabot>      It could refer to either `L....
15:57:59 <dev31212> ?let h = foo (5+) 20
15:57:59 <lambdabot>  <local>:5:10:
15:57:59 <lambdabot>      Ambiguous occurrence `+'
15:57:59 <lambdabot>      It could refer to either `L...
15:58:02 <Baughn> ?undefine
15:58:08 <dev31212> ok
15:58:16 <Baughn> @undefine
15:58:20 <dev31212> ahhh what am I thinking...
15:58:23 <dev31212> I must be too tired
15:58:25 <Baughn> @bot
15:58:25 <lambdabot> :)
15:58:26 <lunabot>  :)
15:58:43 <lament> @boot
15:58:44 <lambdabot> Unknown command, try @list
15:58:47 <lament> @bat
15:58:47 <lambdabot> Maybe you meant: bf bid bug fact faq ft let map part what
15:59:04 <lament> has command guessing been turned off?
15:59:18 <Baughn> @botd
15:59:18 <lambdabot> Maybe you meant: bid vote
15:59:18 <lunabot>  :)
15:59:27 <Baughn> Yes
15:59:32 <pchiusano> question about strictness analysis
15:59:34 <lament> @slip Freud
15:59:34 * lambdabot smacks Freud about with a large trout
16:00:11 <pchiusano> foldl f z list
16:00:45 <pchiusano> is strict in its second argument if f is strict in both its arguments
16:01:23 <pchiusano> so why does foldl (+) 0 not just evaluate as it goes
16:02:27 <pchiusano> or is it the case that the compiler cannot have strictness which depends on the strictness of its arguments
16:04:05 <pchiusano> ideally you would not need foldl' and the compiler could infer that foldl was strict when the operator was strict
16:04:30 <pchiusano> having to explicitly add strictness in this case seems ugly to me
16:05:04 <pchiusano> ok i will stop talking to myself now :)
16:06:39 <bindreturn> dcoutts, I solved it
16:07:30 <Baughn> pchiusano: Sometimes the compiler doesn't know whether the function is strict or not
16:07:45 <Baughn> pchiusano: It often varies depending on parameter values
16:07:46 <bindreturn> dcoutts, My path annotation PATH="$PATH:~/.cabal/bin" worked in the shell
16:08:05 <bindreturn> but it needed to be fully explicit
16:08:21 <bindreturn> eg PATH="$PATH:/home/purple/.cabal/bin"
16:08:36 <Baughn> bindreturn: You can use $HOME instead of ~
16:08:42 <bindreturn> seems something got confused somewhere
16:09:03 <bindreturn> Yes it didn't expand where where I thought it might
16:09:53 <pchiusano> Baughn: is it the case that strictness analysis is just done up front, and can't depend on the value of a parameter
16:10:14 <Baughn> pchiusano: Strictness analysis is done at compile-time. Values exist at runtime
16:10:20 <bindreturn> Sorry !!
16:11:23 <pchiusano> Baughn: it seems like in order to do what I am thinking of, you would actually need to compile different versions of foldl
16:11:40 <bindreturn> And attoparsec installs fine - I will edit the hpaste to indicate it is ok
16:11:59 <Baughn> pchiusano: Oh, it doesthat. foldl is so small, it's completely inlined most of the time.
16:12:41 <pchiusano> Baughn: how can it be inlined if it is a recursive function?
16:13:21 <vixey> > 1=1
16:13:22 <Baughn> pchiusano: By inlining just one level
16:13:22 <lambdabot>   <no location info>: parse error on input `='
16:13:23 <vixey> > 1+1
16:13:24 <lambdabot>   2
16:13:39 <Baughn> @let foo=2
16:13:40 <lambdabot>  Defined.
16:13:44 <Baughn> @undefined
16:13:45 <vixey> > foo+foo
16:13:45 <Baughn> @undefine
16:13:46 <lambdabot>   Not in scope: `foo'Not in scope: `foo'
16:14:40 <Baughn> pchiusano: Really, it's more so it can also inline the function passed to foldl - (+), say
16:15:02 <Baughn> pchiusano: Also, foldl is /tail-recursive/
16:19:47 <pchiusano> Baughn: i have to run, more later
16:20:15 <pchiusano> if foldl is always inlined, I don't see why it couldn't be made strict in its second argument when applicable
16:20:39 <Baughn> pchiusano: As I said, the problem is deciding whether it's applicable.
16:23:54 <bmh> As always, I'm attempting to upgrade to cabal-install 6.10.1. I just installed zlib systemwide and ghc can't find it -- so I can't install 6.10.1
16:24:35 <bmh> [I hate Debian]
16:25:39 <tomh> do you got the zlib dev headers?
16:26:14 <bmh> tomh: I just pulled the source package linked to from hackage and installed it. If that got me the dev headers, then, yes I have them. If not, no.
16:27:00 <c_wraith> bmh: apt-get install zlib1g-dev
16:27:07 <tomh> yeah
16:27:14 <c_wraith> assuming debian or ubuntu
16:27:25 <tomh> then after that you can install zlib from hackage
16:27:32 <tomh> and after that you need to install http
16:27:35 <bmh> c_wraith: That's fair to assume based on my denigration of debian above. I just fixed aptitude. The damned thing was seg'ing
16:27:40 <tomh> and faster that you can do cabal :>
16:28:23 <bmh> c_wraith: it persists in its objection that it can't locate `Codec.Compression.GZip`
16:28:55 <c_wraith> I'm not too experienced with haskell..  I haven't fought with issues installing zlib, so I'm probably not much help with that.
16:32:00 <bindreturn> bmd do you have zlib.h in /usr/include ?  Me I installed devel version of zlib and then used cabal to install (its just a wrapper around the c-api)
16:32:34 <bmh> bindreturn: Yes, I do have it.
16:45:31 <mofmog> someone tell me that http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4151#a4151 can be done better
16:46:11 <mofmog> intersperseX 4 '\n' "iosejfosiejfoejf" for example inserts a newline every fourth element
16:46:16 <mofmog> including at the beginning
16:46:29 <Cale> Hmm, I have an HGL program here which works correctly on my machine, but on my friend's machine, it seems that maybeGetWindowEvent never gives Nothing and always waits stupidly for the next event. Has anyone else here seen that behaviour?
16:47:19 <mofmog> i feel like i wrote something someone already did, but better
16:48:13 <Cale> let intersperseX every elem = concat . intersperse [elem] . map (take every) . takeWhile (not . null) . iterate (drop every) in intersperseX 4 'b' "aaaaaaaa"
16:48:16 <Cale> > let intersperseX every elem = concat . intersperse [elem] . map (take every) . takeWhile (not . null) . iterate (drop every) in intersperseX 4 'b' "aaaaaaaa"
16:48:18 <lambdabot>   "aaaabaaaa"
16:48:21 <Cale> > let intersperseX every elem = concat . intersperse [elem] . map (take every) . takeWhile (not . null) . iterate (drop every) in intersperseX 4 'b' "aaaaaaaaaaaaaaaaaaaaaa"
16:48:23 <lambdabot>   "aaaabaaaabaaaabaaaabaaaabaa"
16:49:16 <mofmog> oh lord
16:50:36 <Cale> actually...
16:50:44 <Cale> > let intersperseX every elem = intercalate [elem] . map (take every) . takeWhile (not . null) . iterate (drop every) in intersperseX 4 'b' "aaaaaaaaaaaaaaaaaaaaaa"
16:50:46 <lambdabot>   "aaaabaaaabaaaabaaaabaaaabaa"
16:54:40 <mofmog> cale: still sorta ugly
16:54:50 <bindreturn> bmh, oops it just occured to me that i might have downloaded the haskell zlib-0.5.0.0/  and installed by hand (not cabal) because cabal has requires zlib along with http. sorry for wrong information.
16:54:58 <gbacon> ?pl \(a,b) f -> (f a, f b)
16:54:58 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
16:55:06 <Cale> mofmog: Well, you can turn the map/takeWhile/iterate into an unfoldr
17:01:41 <Cale> > let intersperseX every elem = intercalate [elem] . unfoldr (\xs -> guard (not (null xs)) >> return (splitAt every xs)) in intersperseX 4 'b' "aaaaaaaaaaaaaaaaaaaaaa"
17:01:43 <lambdabot>   "aaaabaaaabaaaabaaaabaaaabaa"
17:01:49 <Cale> Not sure that's actually nicer.
17:02:21 <mofmog> urgh why can't drop take Integer
17:02:23 <Cale> > let intersperseX every elem = intercalate [elem] . unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt every)) in intersperseX 4 'b' "aaaaaaaaaaaaaaaaaaaaaa"
17:02:24 <lambdabot>   "aaaabaaaabaaaabaaaabaaaabaa"
17:02:53 <mofmog> this is a function that honestly shouldnt take this much wrangling
17:03:00 <Cale> wrangling?
17:03:10 <mofmog> well you got multiple function compositions
17:03:56 <mofmog> it should be an intercalation of a list that's split up into equal sized sublists
17:04:08 <mofmog> making the sublists shouldn't be this painful
17:05:06 <Cale> ?
17:05:23 <Cale> I don't understand how this is painful...
17:05:25 <mofmog> you have to admit, for something so simple it's a bit complicated
17:05:38 <Cale> I don't see it as being very complicated at all.
17:05:45 <mofmog> seriously? you dont feel any sort of aesthetic pain just looking at it?
17:05:52 <Cale> intercalate [elem] . map (take every) . takeWhile (not . null) . iterate (drop every)
17:05:55 <Cale> seems nice to me
17:06:13 <Cale> You could also get the split library
17:06:22 <dev31212> ?let x = map (+5) [1,2,3]
17:06:22 <lambdabot>  Defined.
17:06:24 <Cale> and it probably already has this thing
17:06:27 <dev31212> ?putStrLn x
17:06:27 <lambdabot> Unknown command, try @list
17:06:50 <Cale> then it's just  intercalate [elem] . splitEvery every
17:07:17 <Cale> (or 'chunk every', which is the same)
17:07:54 <Cale> You can install Data.List.Split by  cabal install split
17:08:24 * kadaver_ is hacking asm and feeling great, as satisfying as coding haskell!
17:12:48 <DrSyzygyFR> Is there a good data type in Haskell for doing basically what Data.Map does, but with decent handling of sorted keys?
17:13:01 <Cale> DrSyzygyFR: Data.Map needs sorted keys
17:13:33 <Cale> Or do you mean maintain some arbitrary permutation of the keys at the same time?
17:13:35 <DrSyzygyFR> No way to hand it a specific sorting separately? And still have easy access to "key and value for the smallest key"?
17:13:44 <DrSyzygyFR> Thing is, I'm implementing a Gröbner basis algorithm.
17:13:44 <Cale> oh
17:13:55 <DrSyzygyFR> So you'd like to be able to plug-and-play with your monomial ordering algorithms.
17:14:23 <DrSyzygyFR> And getting hold of thesmallest (or largest, but reversing order is easy) key happens all the time.
17:14:24 <Cale> hmm
17:14:56 <glguy> you could always make a data type for a thing that carries its compare with it
17:15:21 <Cale> yeah...
17:15:32 <DrSyzygyFR> glguy: And have it implement Ord with that? Hmmm...
17:15:53 <c_wraith> DrSyzygyFR: Yeah, I've done that in the past.  Feels kind of hacky, but it works.
17:16:01 <Cale> data Reordered a = RO (a -> a -> Ordering) a
17:16:33 <Cale> instance Ord (Reordered a) where compare (RO c x) (RO c' y) = c x y
17:17:00 <Cale> But obviously you can end up with some nonsense like that :)
17:17:03 <DrSyzygyFR> Hmmmmmm....
17:17:21 <Cale> (if you start comparing things with different comparators)
17:17:34 <DrSyzygyFR> On the other hand, since I have my orderings implemented as empty data types instantiating a my monomial order thingie, I end up with keys being forced to have the same order.
17:17:44 <Cale> and you'd want to be certain that it really is a total order
17:17:53 <DrSyzygyFR> Oh, THAT is needed anyway.
17:17:57 <Cale> yeah
17:18:02 <DrSyzygyFR> Total and well ordering that respects other stuff.
17:18:38 <DrSyzygyFR> So .. ehm .. yeah .. this looks workable.
17:18:55 <DrSyzygyFR> Gotta transplant all sorts of variables all over, but that's doable I guess.
17:19:07 <DrSyzygyFR> And getting the first key and its value from a Map?
17:21:06 * Cale is very annoyed by HGL having broken behaviour on his friend's machine while working perfectly here.
17:22:32 <johnw> reminds of how often people at work say "works for me!"
17:22:45 <johnw> sung to tune of "sucks to be you man"
17:23:14 <DrSyzygyFR> Btw, is there some way to encapsulate the proliferation of (Class1 a, Class2 b, Class3 c, Class4 d) => Blah in all my type declarations?
17:24:21 <Cale> DrSyzygyFR: You can create a subclass of all of them which is empty.
17:24:22 <johnw> make a type to represent that tuple?
17:24:27 <Cale> DrSyzygyFR: and write empty instances for it
17:24:39 <Cale> Oh, different types?
17:24:40 <Cale> hmm
17:24:43 <mib_2utcejar> I am trying to install happs-tutorial.  It needs hsp 0.4.5.  But hsp fails in compilations:   trhsx: Error at SrcLoc {srcFilename = "src/HSP/XMLGenerator.hs", srcLine = 63, srcColumn = 2}:
17:24:43 <mib_2utcejar> any idas?
17:24:43 <mib_2utcejar> any ideas?
17:24:47 <Cale> Not really, in that case.
17:25:33 <Cale> It might help to use fewer typeclasses in general... sometimes it's tempting to go for maximum generality, and end up with all these typeclasses with almost no instances.
17:27:01 <Cale> mib_2utcejar: I'd help, but I've never really tried anything involving happs myself.
17:27:43 <DrSyzygyFR> Cale: I need to require Ord from my label type, and thus an Ord instance shows up in Every Single Function I declare in the whole project.
17:27:48 <DrSyzygyFR> Similarly with Eq.
17:30:35 <adamvo> DrSyzygyFR: you don't need (Ord a, Eq a) => ....  since (Ord a) => ....  works because ord is a subclass of eq (or however people describe it)
17:37:23 <kadaver_> anyoen good with masm32?
17:37:24 <kadaver_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4152#a4152
17:37:39 <kadaver_> the tutorial says clean up but doesnt that program clean up after itself?
17:44:18 <DrSyzygyFR> adamvo: Thanks!!
17:44:36 <suchsuch> there is a way to do it with existenstials
17:44:47 <suchsuch> (how do you do the reply directly thing?)
17:45:25 <adamvo> suchsuch: to do what for whom?
17:46:08 <Cale> Eq and Ord are not very useful with existentials.
17:46:11 <suchsuch> Data Foo t = (Ord t) => Foo T     will hide the Ord context in a function :   Foo -> Foo
17:46:13 <suchsuch> true
17:46:27 <suchsuch> but it was the only thing I could think of
17:46:34 <Cale> You could never do a comparison other than comparing that one thing with itself :)
17:47:03 <Cale> (because you'll never be able to prove that it's the same type t as in some other case)
17:47:15 <suchsuch> er
17:47:31 <suchsuch> I meant   Foo t -> Foo t
17:49:27 <pumpkin_> does anyone know of a nice graph showing all the common algebraic structures, starting from magma, with requirements on the edges?
17:49:34 <pumpkin_> or some other good illustration of all of them
17:49:59 <suchsuch> http://en.wikipedia.org/wiki/Magma_(algebra)
17:50:18 <pumpkin_> yeah, I've seen that one
17:50:22 <pumpkin_> but that's not very big
17:50:27 <suchsuch> oh
17:50:41 <ivanm> pumpkin_: surely you can enlargen it... ;-)
17:50:47 <pumpkin_> hrrmpf
17:50:49 <suchsuch> you want more pixels or more algebraic objects?
17:50:55 <pumpkin_> I want more algebraic objects
17:51:01 <pumpkin_> just a good visualization of how they all relate
17:51:02 <ivanm> picky, picky...
17:51:16 <pumpkin_> it seems like something someone would've done
17:51:19 <ivanm> pumpkin_: you want the algebraic family tree or something?
17:51:43 <pumpkin_> yeah :P byorgey has something a bit like that in the haskell context in his typeclassopedia
17:51:56 * ivanm points out graphviz to pumpkin_ 
17:51:57 <suchsuch> groups and rings would probably have the most subclasses
17:53:35 <suchsuch> or if you had a graph of category theory notions, everything would be an instance of everything else
17:53:36 <pumpkin_> ivanm: I know how to use graphviz, I just didn't feel like setting it all up, and some things might be hard to show
17:54:23 <pumpkin_> what'd be a good way of tying structures with two operations to structures with one operation, for example
17:54:32 <ivanm> pumpkin_: best bet is probably looking up websites for courses dealing with group theory, etc.
17:54:37 <pumpkin_> all I want is a good visualization
17:54:53 <pumpkin_> alright
17:54:59 <pumpkin_> I googled and couldn't find anything obvious, but I'll keep looking
18:00:05 <kadaver> im writing monads in asm!
18:00:19 <pumpkin_> how does that work?
18:00:33 <kadaver> data Maybe = Nothing | Just ComputerCrash
18:00:57 <pumpkin_> :o
18:01:06 <pumpkin_> :)
18:01:32 <ezyang> asm is uaseful if you want to write a kernl exploit...
18:01:46 <gnuvince_> jeffk?
18:02:58 <kadaver> or  a robot using a microcontroller
18:03:22 <pumpkin_> you can program many of them in c-like languages
18:03:30 <ezyang> bah, that's just nornal
18:03:52 <ezyang> re microcontrller
18:03:59 <ivanm> that was a pretty pathetic netsplit...
18:04:09 * pumpkin_ writes kernel exploits in his sleep
18:04:40 <suchsuch> that's why you should use hibernate
18:14:34 <zoheb> I wrote a function to generate permutations
18:14:46 <zoheb> > foldr (\x -> concat.map (\xs -> map (\(a,b) -> a ++ (x:b)) $ zipWith ($) (map splitAt [0..length xs]) $ repeat xs)) [[]] "123"
18:14:47 <lambdabot>   ["123","213","231","132","312","321"]
18:15:10 <zoheb> But the map splitAt is too expensive
18:15:25 <pumpkin_> , permutations [1..5]
18:15:28 <lunabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],...
18:15:29 <ivanm> @go haskell permutations
18:15:30 <lambdabot> No Result Found.
18:15:58 <ivanm> lambdabot is lying!
18:16:04 <zoheb> didnt know about that
18:16:26 <ivanm> zoheb: http://www.polyomino.f2s.com/david/haskell/hs/CombinatoricsGeneration.hs.txt
18:16:33 <zoheb> However, I was wondering if there is a way to improve the splitAt
18:16:41 <adamvo> > zip (tails "123") (reverse $ inits "tails")
18:16:42 <lambdabot>   [("123","tails"),("23","tail"),("3","tai"),("","ta")]
18:16:49 <adamvo> > zip (tails "123") (reverse $ inits "123")
18:16:51 <lambdabot>   [("123","123"),("23","12"),("3","1"),("","")]
18:17:03 <adamvo> > zip (tails "123") (inits "123")
18:17:04 <lambdabot>   [("123",""),("23","1"),("3","12"),("","123")]
18:17:15 <adamvo> > flip zip (tails "123") (inits "123")
18:17:16 <lambdabot>   [("","123"),("1","23"),("12","3"),("123","")]
18:17:23 <zoheb> I am taking a smaller permutation and splitting it in various places to insert an extra element to generate larger permutations
18:17:33 <adamvo> I wonder if that results in more sharing?
18:17:52 <zoheb> In an imperative language this should be easy to do with a doubly linked list
18:17:57 <zoheb> linked list
18:18:11 <zoheb> inserting into the middle of an existing list
18:18:22 <adamvo> @go zipper
18:18:23 <lambdabot> http://en.wikipedia.org/wiki/Zipper
18:18:23 <lambdabot> Title: Zipper - Wikipedia, the free encyclopedia
18:18:28 <ivanm> zoheb: see the code in that link
18:18:36 <ivanm> that's basically what it does
18:18:54 <zoheb> It isnt opening
18:19:19 <ivanm> opens here just fine...
18:19:40 <zoheb> not opening
18:19:43 <zoheb> will try later
18:20:04 <zoheb> does it use a zipper?
18:20:11 <ivanm> no
18:20:27 <zoheb> I know we can use a DList to append or prepend
18:20:55 <zoheb> but does anyone know about insertions into the middle
18:21:00 <zoheb> in the std library
18:22:03 * pumpkin_ doesn't want anything to do with std
18:22:13 <zoheb> he he
18:22:17 <MyCatVerbs> adamvo: I think you're stuffed for sharing either way; inits has no way to share the spines of ths lists that it returns.
18:22:28 <ivanm> zoheb: it's usually better not to do that
18:22:47 <ivanm> the code I linked to takes each element from the list and puts it up the front in turn
18:23:10 <pumpkin_> a Seq can take efficient insertions into the middle, right?
18:23:13 <zoheb> that has to be the best
18:23:24 <pumpkin_> not as efficient as cons or snoc, but more efficient than inefficient :P
18:23:39 <zoheb> :t Seq
18:23:40 <lambdabot> Not in scope: data constructor `Seq'
18:23:48 <pumpkin_> Data.Sequence
18:26:11 <kadaver> anyone here know masm32? i cant figure out how to loop :P
18:26:31 <pumpkin_> use jmp or the conditional variants
18:26:50 <pumpkin_> (you'll need a label)
18:26:59 <pumpkin_> unless you want to calculate the offset yourself
18:29:53 <zoheb> Ok, The Data.Sequence is basically a tree
18:30:03 <zoheb> So most ops are log n
18:30:12 <kadaver> yeah im trying that but it aint branching
18:30:25 <pumpkin_> kadaver: then you're doing something wrong :P
18:30:29 <pumpkin_> zoheb: yeah
18:30:38 <pumpkin_> it's a finger tree!
18:33:44 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4153#a4153 <- theres the program
18:33:55 <kadaver> it pops up the window but only garbage is displayed
18:34:16 <pumpkin_> how are two jzs in a row supposed to do anything?
18:34:32 <kadaver> if cmp then first else snd?
18:34:39 <pumpkin_> no
18:34:40 <kadaver> i found an eeror btw
18:37:32 <kadaver> ok so how do I do it then?
18:39:32 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4153#a4154
18:39:48 <kadaver> i think that should work if the condition is changed to soemthing correct
18:40:13 <kadaver> and ait it is factorial not fib :P
18:42:03 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4153#a4155
18:43:52 <Berengal> kadaver: Why two jump instruction at the end of fac?
18:44:17 <kadaver> because i thought thats like if-then-else
18:44:22 <Berengal> Why not just jne (or whatever not-equal is)?
18:44:25 <kadaver> i dont get how to branch
18:44:37 <kadaver> i cant find a reference
18:44:40 <Berengal> jne _fac, else fallthrough
18:44:46 <kadaver> so i dont know exactly whay jz jne is
18:45:55 <kadaver> ?
18:46:08 <Berengal> jz seems like jump-if-zero to me
18:46:25 <Berengal> Although I don't have a reference either :P
18:46:40 <kadaver> but if that isnt true doesnt it just do the next oeration then?
18:46:55 <kadaver> wait
18:47:02 <kadaver> jz _end
18:47:06 <kadaver> jne _fac?
18:47:17 <kadaver> nwo it printed an x
18:47:34 <Berengal> Should it print an x?
18:47:39 <kadaver> no, 120
18:47:59 <pumpkin_> that's right
18:48:00 <Berengal> > ord 'x'
18:48:02 <lambdabot>   120
18:48:02 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4156#a4156
18:48:06 <kadaver> wehoo!
18:48:09 <kadaver> haha
18:48:17 <kadaver> so how do I do that in asm?
18:48:32 <pumpkin_> you want some sort of itoa
18:48:40 <pumpkin_> or an sprintf
18:48:47 <pumpkin_> you probably don't want to write that yourself
18:48:54 <pumpkin_> but given that you're writing asm in the first place, maybe you do
18:49:02 <Berengal> Anyway, look at the jumps for a second. You could change the order of those two jumps without changing the meaning of the program, no?
18:49:21 <kadaver> itoa:iota?
18:49:48 <kadaver> yes i just dleeted jz
18:50:06 <Berengal> itoa is characters-are-expensive-in-this-day-and-age 70's C speak for integer-to-ascii
18:50:26 <kadaver> means intoilet in swedish
18:53:32 <kadaver> ok, any idea what i need to do?
18:53:53 <Berengal> No, none whatsoever
18:53:58 <Berengal> I've never done assembly :P
18:54:28 <kadaver> how did you know how to fix it then?
18:56:17 <Berengal> Educated guesses? It seemed like the logical thing to do...
18:57:43 <kadaver> and you knew JNE
18:58:50 <Berengal> It was either that or JNZ. Since any one of them could be right, or even both of them, there was an over 50% chance I was right no matter which one I chose
19:05:27 <sm> has anyone managed to build leksah on a mac ?
19:06:31 <sm> I succeeded in building macports gtk2hs, but not gtksourceview, and the packaged mac-ish gtk2hs doesn't seem to include gtksourceview
19:13:35 * sm gets a bit further
19:14:37 <thoughtpolice> @seen dons
19:14:38 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 38m 39s ago.
19:16:23 <sm> gah!
19:17:00 * sm finds leksah is not so important after all
19:17:16 <trez> its gay after all
19:19:18 <Elly> a gay editor?
19:20:31 <trez> vi vi vi, 6 6 6, gay editor, leksah
19:20:53 <trez> or to many berrhs
19:20:59 <Elly> I do not understand
19:22:25 <Nafai> trez: Please be nice.
19:58:33 <pumpkin_> mmorrow: did you ever figure out a function isThunk :: a -> IO Bool ?
20:01:36 <gwern> @hoogle isMaybe
20:01:37 <lambdabot> No results found
20:02:30 <gwern> @hoogle is
20:02:30 <lambdabot> System.FilePath.Posix isAbsolute :: FilePath -> Bool
20:02:30 <lambdabot> System.FilePath.Windows isAbsolute :: FilePath -> Bool
20:02:30 <lambdabot> Data.Generics.Basics isAlgType :: DataType -> Bool
20:07:30 <pumpkin_> is there a function anywhere that takes a bytestring and gives a nice hexdump-style dump of it?
20:08:33 <MyCatVerbs> Good question.
20:08:54 <pumpkin_> and what's the quickest way to get from an Addr# to a strict ByteString? :P
20:09:41 <segher> pumpkin_: damn man, what are you doing _now_ :-)
20:09:44 <pumpkin_> lol
20:09:54 <pumpkin_> poking around where I don't belong
20:10:54 <pumpkin_> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
20:11:16 <pumpkin_> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) -- payload
20:11:21 <pumpkin_> I guess that's one way :P
20:11:31 <pumpkin_> not sure why ForeignPtr keeps ForeignPtrContents around though, hmm
20:12:38 <sjanssen> pumpkin_: ForeignPtrContents is for the garbage collector, finalizers and such
20:12:59 <pumpkin_> hmm, I don't want that though
20:13:03 <sjanssen> pumpkin_: probably the correct path is Addr# -> Ptr, Ptr -> ForeignPtr
20:13:12 <pumpkin_> ok
20:13:25 <sjanssen> pumpkin_: when/how will the memory be freed?
20:13:31 <pumpkin_> it's not mine to free
20:13:34 <pumpkin_> :P
20:13:59 <pumpkin_> I just want to poke around GHC's heap
20:19:12 <dev31212> hi
20:23:17 <thoughtpolice> has anybody read or seen anything about this book? http://www.cambridge.org/catalogue/catalogue.asp?isbn=9780521899574&ss=toc <- it looks good, I'm just not sure if I want to spend $120 on it though...
20:23:59 <pumpkin_> does anyone know of a ByteString -> String that formats the bytestring like hexdump?
20:24:28 <johnw> yeah, i wrote one of those
20:24:35 <thoughtpolice> pumpkin_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hexdump ?
20:24:35 <johnw> one sec
20:24:42 <gwern> thoughtpolice: never heard of it before, but for 120 bucks I would sure as hell ILL it first
20:24:42 <johnw> hexString = concat . map (printf "%02x") . BS.unpack
20:26:22 <Tsion> johnw: could you use concatMap?
20:28:38 <johnw> probably
20:29:03 <thoughtpolice> gwern: ILL?
20:29:15 <gwern> interlibrary loan
20:29:51 <thoughtpolice> gwern: thing is it just came out this month; so i doubt any around here might have it
20:41:41 * Cale reverts to 6.10.1 :P
20:41:53 <pumpkin_> :o
20:42:23 <Cale> The segfaults in ghci were just too annoying.
20:47:39 <scutigera> any ML'ers in the audience ? I'm looking for the haskell equivalent of the vector structure in ML
20:48:55 <Cale> scutigera: Array?
20:49:06 <jmcarthur> scutigera: what is the vector structure in ML?
20:49:49 <scutigera> the array gets part way there, but in particular it's missing fold over arrays, concat, find the ability to map over index AND values.
20:50:04 <scutigera> vector is an immutable array type (0 based always) in ML
20:50:11 <jmcarthur> scutigera: you want something like the uvector package?
20:50:22 <pumpkin_> uvector does all that, yeah
20:50:45 <Cale> I think the assumption is that if you wanted to fold over it, you'd just apply elems first
20:50:52 <Cale> (to turn it into a list)
20:51:08 <pumpkin_> as long as the list fuses away, that seems reasonable
20:51:15 <pumpkin_> but I don't think it would?
20:51:18 <scutigera> fuses ?
20:51:20 <Cale> Maybe not.
20:51:30 <Cale> But I still think it's *somewhat* reasonable
20:51:43 <Cale> Since at the very least, the list elements are immediate garbage.
20:51:49 <pumpkin_> scutigera: doesn't bother creating a list
20:52:31 <jmcarthur> scutigera: you can consider stream fusion to be something like "loop fusion" in an imperative language, i think
20:53:35 <jmcarthur> multiple loops over the same collection fusing into one loop, eliminating intermediate states
20:53:39 <scutigera> certainly I figured out that I could go back and forth to a list, but that seemed quite inefficient.  maybe the fusion thing takes care of that- more reading to do !
20:54:27 <scutigera> meanwhile uvector looks very good.  let me guess, suffix U stands for unboxed ? :-)
20:54:34 <jmcarthur> yup :)
20:54:35 <Cale> scutigera: Well, laziness means that as long as GC does its job, it should only use constant space.
20:54:48 <Cale> scutigera: (the extra list)
20:55:14 <jmcarthur> well, i always _assumed_ it stands for unboxed, anyway
20:55:16 <Cale> But you will get hit with the time for allocation.
20:55:40 <Cale> unless the potential fusion actually does occur.
20:56:04 <Cale> It's a potential solution to the problem of the intermediate list, but whether it's actually implemented is another thing.
20:56:12 <scutigera> right now,  I am using small vectors, but I have some code that processes multi-million element vectors.  Then it will be important...
20:56:37 <scutigera> cale: are you referring to fold specifically ?
20:56:37 <Cale> You needn't worry about the additional list existing all in memory at any one time.
20:56:57 <Cale> scutigera: Yeah, fold particularly, but other processes which iterate linearly over the structure would be okay too.
20:57:18 <Cale> Oh... also...
20:57:46 <Cale> Array i is an instance of Foldable
20:57:50 <Cale> So you could also just use that.
20:57:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
20:58:49 <Cale> But, haha, the implementation just does what I suggested: it applies elems and then uses the list foldr :)
20:59:35 <Cale> If you need to fold or map or do anything else where you also need access to the indices, the appropriate idiom is to apply zip [0..] first
20:59:38 <Cale> like...
21:00:31 <Cale> > concat [replicate n x | (n,x) <- zip [1..] "stutter"]
21:00:32 <lambdabot>   "sttuuuttttttttteeeeeerrrrrrr"
21:01:09 <orbitz> are you making fun of people with a disability?
21:01:57 <Cale> > map snd . filter (\(n,x) -> even n) . zip [0..] $ "take only even elements"
21:01:58 <lambdabot>   "tk nyee lmns"
21:02:13 <Cale> orbitz: It's just an example :)
21:02:25 <scutigera> nice examples, thanks !
21:03:34 <Cale> But concatenation of arrays is something which is not as easily provided for.
21:03:36 <orbitz> Cale: <insert overly PC statement>
21:03:50 <Cale> Another interesting structure to check out is Data.Sequence
21:04:15 <jmcarthur> or more generally, fingertree
21:04:17 <Cale> It has log time lookup, splitting, and concatenation, and constant time access to both ends
21:05:01 <jmcarthur> sequence is just fingertree specialized to indexed access
21:05:09 <Cale> right
21:05:24 <Cale> It's really too bad that it needs to be hand-specialised that way.
21:05:42 <orbitz> Cale: i was talking to someone who was arguign that you can't do most data structures with decently fast implementations without mutability
21:05:46 <Cale> I think it should be a goal for the GHC guys to be able to do enough transformations to render that unnecessary. :)
21:05:46 <jmcarthur> needs to be? you mean for performance?
21:05:49 <Cale> right
21:06:23 <jmcarthur> orbitz: well, there are definitely _some_ that benefit a lot from mutability, but _most_ is a stretch, i think
21:06:33 <Cale> orbitz: If you're willing to ignore a log factor (which you're already ignoring at the hardware level), then you can.
21:07:06 <orbitz> Cale: one of his argumetns is somethign calel da zorbist hash
21:07:07 <Cale> You can do everything immutably that you can do with mutation with only a log time hit.
21:07:12 <Cale> (and log space hit)
21:07:14 <orbitz> claims you cannot implement it efficiently withotu mutability
21:09:44 <Cale> I don't see how the idea of Zobrist hashing wouldn't transfer to using a Data.IntMap or some such.
21:10:14 <mmorrow> pumpkin: yes, it's easy to determine if a closure's evaluated, but the thing is that something causes a segfault while walking the graph if everything isn't forced. i haven't found out what that is yet (although i haven't looked in to it since i last tried a week or two ago)
21:10:35 <Cale> Sure, you're likely to pay a bit, but not more than a log factor.
21:10:35 <pumpkin_> how can you determine if it's evaluated?
21:10:51 <mmorrow> pumpkin_: by looking at its closure type
21:11:17 <orbitz> Cale: can a log factor be a bad hit?
21:12:02 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType]
21:12:02 <lunabot>  luna: Couldn't match expected type `RtClosureInspect.ClosureType'
21:12:02 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
21:12:02 <lunabot>  [AP,Constr]
21:12:02 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x, closureType id]
21:12:02 <lunabot>  [AP,Constr,Fun]
21:12:02 <Cale> orbitz: It can make a difference if you're really pushing the limits of what your hardware can do.
21:12:09 <orbitz> Cale: he claims:
21:12:12 <Cale> orbitz: But if you're doing something which is fairly comfortable anyway, it's not usually so bad.
21:12:44 <orbitz> "the vast bulk of actually searching a ply tree is the board hashing, and you're looking at  a 30:1 performance loss for a chess engine"
21:12:54 <Cale> 30:1 seems extreme
21:13:08 <Cale> I could imagine 10:1
21:13:16 <Cale> maybe
21:13:25 <Cale> Depends on how much work you're willing to put in.
21:13:58 <Cale> The log factor can be treated as just another constant -- reducing other constants can help too.
21:15:18 <Cale> Chess engines are usually designed to push the limits of what the hardware they run on can do though.
21:15:27 <orbitz> okay
21:15:51 <StoneCypher> it's 30:1 if you're very careful and using a non-iterative deepening search framework
21:16:03 <orbitz> i present the hroses mouth
21:16:08 <StoneCypher> if you pretend to yourself that you can arbitrarily apply a log factor expansion magically through estimation, you're kidding yourself
21:16:22 <StoneCypher> many algorithms and datastructures are fundamentally unreasonable without mutability
21:16:32 <StoneCypher> a classic example that any well educated college freshman knows is the splay tree
21:16:42 <mmorrow> pumpkin: i think i know how to get around the unpointed-closure-being-incorrectly-coerced-to-HValues-by-ghc-which-causes-a-crash-when-they're-entered thing though, thanks to JaffaCake
21:16:45 <StoneCypher> if you believe you can make that happen without mutability in log factor expansion, prepare to be rich as hell
21:17:16 <pumpkin_> StoneCypher: we can use mutability if we want to :)
21:17:18 <StoneCypher> and be ready to put your money where your mouth is, because otherwise ain't nobody who knows what they're talking about gonna take you seriously when you just announce "max of log" without even considering what the actual circumstance might be
21:17:22 <StoneCypher> yay for you
21:17:26 <mmorrow> pumpkin_: i'm gonna see if i can't get that fixed, then try to track down the segfault
21:17:32 <Cale> Well, you can design an immutable datastructure which has log time access and update, which means that if you fix a bound on the size that structure needs to be, you can work out roughly what the constant you're going to pay is.
21:17:36 <pumpkin_> StoneCypher: you're well known as an arrogant prick by the way :)
21:17:37 <StoneCypher> i just showed up to laugh at the guy who thinks tacking a log onto things is somehow realistic
21:17:48 <pumpkin_> your reputation precedes you
21:17:49 <Cale> StoneCypher: It quite often is.
21:17:51 <StoneCypher> pumpkin_: uh huh.  ignored.
21:18:27 <sjanssen> StoneCypher: are you here to learn about Haskell, or troll?
21:18:33 <StoneCypher> sjanssen: neither
21:18:41 <jmcarthur> if you assume that you are indexing my machine native unsigned integers then the log is effectively a constant
21:18:45 <StoneCypher> sjanssen: unfortunately you seem very easily tricked by simple people like pumpkin
21:18:48 <StoneCypher> sjanssen: have a nice day
21:19:00 <jmcarthur> oh i think you said that anyway, nevermind
21:19:08 <pumpkin_> :)
21:19:20 <StoneCypher> Cale: "log expansion quite often" is very different than < Cale> 30:1 seems extreme < Cale> I could imagine 10:1
21:19:27 <StoneCypher> Cale: you were really just making numbers up
21:19:41 <StoneCypher> Cale: have you ever written a ply search of any kind?
21:19:48 <orbitz> StoneCypher: wasn't your 30:1 made up?
21:19:49 <Cale> StoneCypher: I'm just saying from my personal experience, it's unusual to take quite that bad of a hit.
21:19:51 <StoneCypher> orbitz: no
21:19:57 * jmcarthur isn't so sure that StoneCypher isn't a troll
21:19:59 <StoneCypher> orbitz: have you ever seen me give a made up number?  ever?
21:20:03 <StoneCypher> jesus
21:20:12 <StoneCypher> you people are really desperate to find a way to look down on others, aren't you
21:20:12 <pumpkin_> StoneCypher: most disk-based search structures are tree-based, with log factors, despite the presence of disk-based hashtables
21:20:13 <mmorrow> StoneCypher: the only thing splay trees are remotely good at is insertion
21:20:16 <pumpkin_> even on enormous datasets
21:20:19 <orbitz> 00:14 <StoneCypher> that isn't an exact number.  the exact number depends on a huge number of things ...
21:20:21 <Cale> I haven't written chess search algorithms, but I have done other combinatorial optimisation problems using immutable structures.
21:20:22 <mmorrow> StoneCypher: they're pretty useless anywhere else
21:20:23 <StoneCypher> mmorrow: they're great for caching
21:20:38 <StoneCypher> mmorrow: especially when the cache is variably size bounded
21:20:44 <pumpkin_> oh I forgot, I'm probably /ignored
21:20:47 <StoneCypher> mmorrow: there are other uses for them too, but that's the canonical one
21:20:47 <Cale> (with little performance problem)
21:21:04 <Cale> Mind you, my programs were not the sort of thing which were highly time-limited.
21:21:07 <pumpkin_> anyway, guys, it's useless trying to talk to him
21:21:07 <StoneCypher> Cale: ply trees aren't immutable structures
21:21:15 <StoneCypher> well i guess to a haskell person they are
21:21:18 <orbitz> pumpkin_: hah
21:21:22 <StoneCypher> the lazy generation mindset
21:21:25 <pumpkin_> I'm serious :)
21:21:36 <Cale> StoneCypher: Immutable structures are nice. We can do immutable structures too.
21:21:46 <pumpkin_> I won't say he's a troll, I'm just saying you'll get pissed off trying to talk to him
21:21:49 <Cale> StoneCypher: But usually prefer immutable ones since they're easier to think about.
21:21:51 <orbitz> Cale: do yo mean mutable in the second sentence?
21:21:56 <Cale> er, yes
21:22:02 <StoneCypher> Cale: well, i guess you're smarter than everyone in the highly profitable chess industry.
21:22:03 <Cale> We can do mutable structures too.
21:22:28 <StoneCypher> Cale: sounds like you have a career move.  people who could do the things you claim would quickly make eight digits a year.
21:22:29 <jmcarthur> and Cale is _not_ just talking about the log-as-constant assumption, either
21:22:33 <Cale> StoneCypher: I don't write chess software.
21:22:43 * bremner wanders what alternate reality he has arrived in
21:22:49 <StoneCypher> cale: Indeed.
21:22:59 <mmorrow> StoneCypher: also, "Another drawback to splay trees is that they're guaranteed to be efficient only when used in a single-threaded manner." (from this paper i happen to have opened)
21:23:18 <StoneCypher> mmorrow: That paper is outdated.
21:23:24 <mmorrow> heh
21:23:31 <jmcarthur> what good _is_ a splay tree, really?
21:23:38 <jmcarthur> insertion, weee
21:23:39 <pumpkin_> it moves commonly used stuff to the top
21:23:40 <pumpkin_> that's about it
21:23:46 <mmorrow> StoneCypher: my point is that nothing is "the best"
21:24:02 <mmorrow> StoneCypher: there are only shades of grey
21:24:12 <jberryman> lists.
21:24:15 <StoneCypher> Cale: So, your arguing with well known numbers regarding a process you've never engaged in is based solely on having worked with vaguely handwaved immutable datastructures?
21:24:16 <jberryman> lists are the best.
21:24:17 <sjanssen> StoneCypher, Cale, everybody else involved in this conversation: let's take this to #haskell-overflow, it is off topic and is distracting
21:24:31 <jberryman> end of discussiion
21:24:51 <jmcarthur> StoneCypher: Cale has said repeatedly that we can do mutable structures anyway, and I don't think he has claimed that doing so is a bad idea...
21:24:55 <scutigera> deschutes black butte porter is the best
21:24:57 <mmorrow> StoneCypher: are you threatened by immutability?
21:25:09 <Cale> Yeah, I don't really understand your tone here.
21:25:10 <StoneCypher> mmorrow: No.  Does making up fears in others make you feel smart?
21:25:17 <mmorrow> StoneCypher: yes.
21:25:22 <StoneCypher> mmorrow: Kay.
21:25:25 <StoneCypher> cale: It's a simple enough question
21:25:45 * pumpkin_ shrugs, I warned y'all :)
21:25:47 <orbitz> the question i brought up really has nothign to do wit if haskell can do mutable datastrucutrs or if splay trees are any good
21:25:51 <mmorrow> StoneCypher: so then i suppose it's simply fear then.
21:25:58 <StoneCypher> mmorrow: You suppose a lot of things.
21:26:06 <mmorrow> StoneCypher: just two so far.
21:26:10 --- mode: ChanServ set +o sjanssen
21:26:11 <Cale> StoneCypher: I've worked on many similar combinatorial optimisation problems with little trouble, and I know the benchmarks that I've seen regarding such things.
21:26:12 <bremner> look, I can ignore the splay tree guy if the rest of you would too
21:26:22 <StoneCypher> aha, and now the meaningless display of power <3
21:26:36 <sjanssen> really guys, off topic, #haskell-overflow is that-a-way
21:26:37 <Cale> StoneCypher: Well, you are being quite disruptive here :P
21:26:39 <StoneCypher> mmorrow: Amusingly, two of my favorite three languages are pure immutable
21:26:42 <StoneCypher> cale: Right.
21:26:55 <mmorrow> StoneCypher: oh cool, which?
21:26:58 <StoneCypher> I gather haskell people don't like dissenting voices.
21:27:02 <orbitz> although you think immutbailty in erlang was a huge mistake...
21:27:10 <bos> StoneCypher: we try to maintain a polite atmosphere around here, and you are not being noticeably polite.
21:27:11 <StoneCypher> I'll see my way out before sjanssen establishes his alpha male dominance.
21:27:16 <Cale> StoneCypher: It's not that, it's that the discussion is loud and offtopic :P
21:27:16 <pumpkin_> http://www.urbandictionary.com/define.php?term=stonecypher
21:27:16 <jmcarthur> I don't see any dissent. Nobody is arguing with you. You're imagining it.
21:27:30 <Cale> He already left
21:27:34 --- mode: ChanServ set -o sjanssen
21:27:34 <jmcarthur> :\
21:27:45 * sjanssen 's bloodlust will remain unfilled :(
21:27:57 <pumpkin_> he's on par with DanFrederiksen
21:28:04 <pumpkin_> in the most annoying people I've met on IRC
21:28:08 <sjanssen> pumpkin_: you know him from somewhere?
21:28:24 * jberryman looks out from under his desk to see if it's safe...
21:28:26 <pumpkin_> I heard of him from someone pissed off at him
21:28:27 <sjanssen> I'm quite curious how this started, he jumped into the conversation from nowhere
21:28:38 <pumpkin_> so I went and observed in a channel he was "discussing" in
21:28:52 <pumpkin_> it was ridiculous and I had to leave I got so frustrated
21:28:54 <QtPlaty[HireMe]> Who is DanFrederiksen?
21:28:56 <orbitz> pumpkin_: what abotu Smerdy?
21:29:06 <Cale> On more on-topic matters, can anyone think of a reason why in HGL, the function maybeGetWindowEvent would block on some systems?
21:29:08 <pumpkin_> orbitz: I've heard great things about him too, but have never "met" him
21:29:26 <pumpkin_> QtPlaty[HireMe]: he hangs out in #ai among other places on freenode, feel free to try to talk to him
21:29:28 <scutigera> abou those million element arrays... let's say I only need access to the last three or four values at any one time.  Will laziness cause the accesses to "stream" such that the entire array is not created all at once /
21:29:31 <sjanssen> Cale: does it make a blocking FFI call?
21:29:34 <scutigera> at once ?
21:29:45 <Cale> It seems to block until an event actually occurs on my friend's system, always returning Just x rather than ever producing Nothing
21:29:53 <jmcarthur> scutigera: arrays are usually strict
21:30:08 <sjanssen> scutigera: with arrays, the entire spine will be allocated.  A list might exhibit the behavior you need, however
21:30:17 <jmcarthur> scutigera: if you only need access to a few values at a time, an array is probably not the right data structure to use
21:31:04 <Lemmih> orbitz: Smerdyakov isn't a bad guy. He just tends to be rather pedantic.
21:31:17 <Cale> It's internally implemented by doing an isChanEmpty followed by readChan if that returns False
21:31:29 <Cale> er, isEmptyChan
21:31:36 <orbitz> Lemmih: i don't mind him myself, but i can see the problem people have with him
21:31:40 <scutigera> it's for a dsp application, so it's a time sequence where, for purposes of calculation you generally only need the last 20-30 values.
21:31:59 <glguy> isEmptyChan blocks if someone else is listening on the chan already
21:32:00 <Cale> I can imagine if the channel was somehow getting emptied from elsewhere how that might block occasionally
21:32:10 <Cale> oh?
21:32:17 <mmorrow> glguy: really?
21:32:20 <sjanssen> glguy: huh.  I've never heard of that one before
21:32:20 <Cale> isEmptyChan can block?
21:32:28 <jmcarthur> yuck!
21:32:29 <sjanssen> Chan is broken, it really ought to be replaced with TChan
21:32:57 <Cale> hmm... I wonder if I should go to the trouble of reworking HGL to use STM.
21:33:19 <Cale> I really just want a very simple graphics library for teaching purposes.
21:33:57 <jmcarthur> scutigera: it sounds like a list is more appropriate than an array, to me
21:34:45 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4162#a4162
21:34:51 <scutigera> jmcarthur: how to efficiently retrieve nth previous value ?
21:35:07 <jmcarthur> scutigera: do you *need* indexed access?
21:36:10 <mmorrow> glguy: that's distressing
21:36:17 <scutigera> jmcarthur: good point .  I've never thought of trying to solve the probelm using lists, as all the math is written as sums and double sums, so it's written more naturally as array access.
21:36:30 <glguy> mmorrow, what is distressing is that it isn't documented as blocking
21:36:36 <glguy> as everyoen seems to assume that it isn't
21:36:40 <mmorrow> glguy: exactly
21:36:53 <scutigera> however ALL of the values are consumed in-order, so using list would probably work.
21:36:57 <mmorrow> glguy: so i guess that's a property of MVars then?
21:37:05 * mmorrow tries
21:37:13 <glguy> mmorrow, will, it is a property of how Chans are implemented
21:37:15 <glguy> well*
21:37:28 <pumpkin_> mmorrow: edwardk and I were talking about something awesome earlier... maybe you have some idea whether it's implementable in current GHC
21:38:05 <sjanssen> glguy, mmorrow: I think it's essentially a property of MVars
21:38:26 <mmorrow> glguy: phew: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4162#a4163
21:38:34 <mmorrow> sjanssen: i just checked
21:38:46 <jmcarthur> scutigera: i haven't much opportunity to practice with them, but i've always imagined that a comonad would be a nice abstraction for causal signal processing
21:39:04 <mmorrow> pumpkin_: oh?
21:39:26 <pumpkin_> mmorrow: pure weak references would be really cool... current weak references live in IO and if you dereference them you might get a Nothing if they've been GCed... much nicer would be if it didn't hold on to the value GC-wise, but would recompute it on demand
21:39:41 <pumpkin_> that would also allow it to be pure
21:40:13 <scutigera> jmcarthur: comonad ?  you're making that up ;-)
21:40:26 <jmcarthur> scutigera: no i'm not :P
21:40:26 <pumpkin_> I have a feeling it can still be grown on top of Weak# but it would be quite a hack
21:40:33 <mmorrow> pumpkin_: hmm, but wouldn't that be essentially the same as holding onto the value? (ignoring that the value might be huge and the code small)
21:40:42 <mmorrow> or am i missing the point
21:40:42 <davidL> are there any pure haskell libraries for writing gifs or jpegs or pngs?
21:40:53 <jmcarthur> scutigera: one interesting application of comonads: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
21:41:14 <sjanssen> pumpkin_: I think what you really want is a primitive to un-share a thunk or value
21:41:49 <pumpkin_> mmorrow: the idea is that CAFs can be GCed, but it's really easy to hold on to them so the GC can't collect them. Typical primes CAFs suffer from this... people will get around it by making primes take a useless unit parameter, but having it be GC'able but recomputable would be nicer
21:41:51 <Cale> Well, that's pretty convincing that Chan should be implemented in terms of TChan by wrapping atomically around everything.
21:42:16 <Cale> It would fix the annoying bug anyway.
21:42:23 <sjanssen> Cale: TChan does lose some guarantees about fairness, of course
21:42:38 <glguy> implementing it in terms of stm would be a good way to kill performance
21:42:47 <mmorrow> Cale: the only unfortunate thing though is that STM is much slower (although more convenient/whatever) than MVars
21:42:48 <jmcarthur> Chan has guarantees about fairness?
21:42:53 <mmorrow> pumpkin_: hmm
21:43:03 <pumpkin_> does that make sense?
21:44:02 <scutigera> jmcarthur: woh !  emacs quit unexpectedly - don't see that often.  thanks for the link: large datastructures pieced together from lots of small but similar computations- very interesting.
21:44:33 <mmorrow> pumpkin_: so the point is that you would rather GC data and recompute it (possibly many times) on-demand, rather than just compute it once and have it sitting in memory?
21:45:11 <mmorrow> pumpkin_: that could be nice if recomputation is cheap and the data is huge
21:45:13 <pumpkin_> mmorrow: yeah, for an infinite list of primes as a CAF, you might just want to lazily fold over that list in two different places in your code... but because it's referenced in two places, it can't be GCed
21:45:32 <mmorrow> pumpkin_: ah, hmm
21:45:37 <pumpkin_> mmorrow: so primes :: [Integer] is ideal
21:45:41 <glguy> if you want it regenerated
21:45:44 <pumpkin_> but people tend to do primes :: () -> [Integer]
21:45:45 <glguy> make it a function taking a ()?
21:45:50 <jmcarthur> scutigera: i only recommend a lazier data structure because the laziness seems important to you, but if you really are after performance and you expect that all that data will eventually be stored in memory at once anyway, you might as well go with an array
21:45:55 <pumpkin_> yeah, that's what we're trying to avoid :P
21:46:10 <pumpkin_> it's ugly and having a "recomputable weak reference" would be a nicer way of doing it, I think
21:46:31 <mmorrow> pumpkin_: it seems like adding a () param though might be a lighter-weight solution (but maybe not)
21:46:47 <pumpkin_> oh, it would be, but a "recomputable weak reference" would be cooler :P
21:46:55 <mmorrow> heh, agreed
21:47:10 <pumpkin_> it's really easy to add the () parameter
21:47:18 <pumpkin_> but there's no fundamental reason that should be necessary
21:48:14 <Cale> Well, I replaced the Chans in HGL with TChans, and my program seems fast enough still, I'll have to send the package to my friend and see if she has any better luck with the TChan version.
21:49:34 <mmorrow> Cale: i think performance if heavily impacted by how much contention there happens to be in a particular situation
21:49:54 <mmorrow> when contention is high, STM starts to slow-mo
21:50:09 <mmorrow> s/if/is/
21:50:28 <Cale> The Chan in this case is just being used as the event queue for a graphics app.
21:50:45 <mmorrow> like, say the Chan has 1000 readers
21:50:48 <Cale> Really, I don't see where it's being read apart from my main event-handling loop.
21:50:51 <mmorrow> (concurrent readers)
21:51:12 <Cale> But I suppose it's possible, since I don't know everything about how HGL works, that there's another reader somewhere.
21:51:15 <scutigera> jmcarthur: code runs fast (in ML), but allocates A LOT of memory, since I keep mapping vectors (immutable).  The comonad idea looks really neat, and I think it might work.
21:52:02 <jmcarthur> scutigera: excellent, glad i could help
21:52:18 <jmcarthur> scutigera: if it turns out that the comonad abstraction isn't a perfect fit, you can still try something like a zipper
21:52:49 <jmcarthur> scutigera: but i think a list would be sufficient, honestly
21:52:49 <Cale> Another thing, does anyone know if it's possible for X clients to do a client-local equivalent of xset r off (turn off keyboard repeat)?
21:52:59 <jmcarthur> the comonad abstraction would just be bonus cool points
21:53:25 <jberryman> how would i go about dealing with the ".." and "." directoried in a portable way (I'm assuming those don't get returned in windows?). I want them to go away.
21:53:46 <scutigera> jmcarthur: lol  - yes it would.  More importantly it will make me think about the problem differently.
21:54:21 <scutigera> jmcarthur: thanks again !
21:55:21 <jberryman> ... I guess if I use filter (/= "..") that would work on windows too. duh.
21:59:01 <johnw> jberryman: you can use // [".", ".."]
22:07:50 <jberryman> will System.Directory.getDirectoryContents do anything weird ala ".." under windows?
22:11:38 <pumpkin_> lol, just as I was complaining today about utility-ht, someone submits it to the haskell subreddit :P
22:13:13 <ray> social media are a drag, i submit my links to irc
22:13:57 * pumpkin_ ponders registering http://2naturaltransformations1functor.com/
22:14:35 <ray> "ponders"? you should have registered it five minutes before you thought of it
22:17:29 <pumpkin_> there, bought it
22:17:39 <pumpkin_> I'll never use it, but it gives me a warm fuzzy feeling
22:23:30 <Gracenotes> hmmm... whenever I make a little change and a big change to some code, and upon recompiling there's an error produced, I just assume that the big change caused it
22:23:46 <Gracenotes> (except on further examination, usually)
22:24:07 <hamishmack> sm: To get gtksourceview2 support in gtk2hs it needs to be installed before gtk2hs is configured.
22:24:39 <ray> solution: don't make them both before recompiling
22:24:50 <hamishmack> sm: Leksah user manual has detailed instructions on installing on OSX (section 2.2)
22:24:58 <sm> thanks hamishmack
22:25:27 <sm> I did find those, currently blocked on a problem installing py25-libxml , I just commented on the reddit thread
22:25:32 <Gracenotes> ray: indeed... you can only get so incremental though
22:26:22 <Gracenotes> in this case the little change was moving code from one location to another, and the big change was adapting the code for new location. both needed for compilation... except that moving away from the old location too much was cut
22:26:46 <Gracenotes> and Haskell cried :(
22:26:58 <sm> hamishmack: http://www.reddit.com/r/haskell/comments/890mi/leksah_044_underlines_errors_as_you_type/ . I'll understand if you have better things to do than dig into this
22:28:28 <Gracenotes> parsing a regular expression is harder than I thought :o
22:28:58 <Gracenotes> I mean, the regular expression string. like "(a|b|c+)?"
22:29:12 <inimino> and you can't use a regex to do it :)
22:30:34 * BMeph pushes down the urge to "SUP DAWG" on inimino's comment...
22:31:06 <Gracenotes> inimino: quite
22:31:07 <Gracenotes> :o
22:34:50 <hamishmack> sm: I don't see that comment yet (is there a delay on reddit comments?).  What error do you get when installing py25-libxml?
22:35:55 <sm> perhaps.. here it is: http://gist.github.com/100974
22:37:53 <Gracenotes> heh. there has to be a better way to do this.. http://67.223.225.106/fsm/heug.svg
22:38:21 <Gracenotes> I think defining 'plus n = n +-+ kleeneNFA n' probably wasn't as elegant as it could be
22:38:55 <hamishmack> sm: I think this might be it... http://trac.macports.org/ticket/18196
22:39:05 <Gracenotes> just need to make accept go to start, but with no initial accepts
22:40:12 <hamishmack> sm: sudo port upgrade python25  (I think)
22:40:38 <sm> hamishmack: this is much appreciated! that has been annoying for a while
22:41:01 <sm> alternately I might uninstall it since I have python26 now
22:41:53 <Gracenotes> lol. went from 25 nodes to 9
22:42:06 * sm decides not to anger port by uninstalling python25
22:43:58 <Gracenotes> mai primitive regex engine is so kawaii ^_^
22:54:19 <cjs> What the heck were the functions to convert between strict and lazy ByteStrings?
22:55:15 <mmorrow> {to,from}Chunks
22:55:40 <sm> hamishmack: oh boy. "Error: You have Xcode 3.0. Please update to at least Xcode 3.1." :) is this expected ?
22:56:11 <mmorrow> cjs: you probably don't want to concat the [ByteString] you get back though, because they'll all have to be copied into a single buffer
22:56:31 <cjs> That's just what I'm looking for. This is just to make things more readable when testing.
22:56:32 <mmorrow> (that's [Data.ByteString.ByteString])
22:56:42 <mmorrow> nice
22:56:58 <cjs> You'd think that copy would actually convert from many chunks to just one chunk....
22:57:49 <hamishmack> sm: I have not seen it, but I have XCode 3.1.2 installed
22:58:04 <hamishmack> sm: What port was it working on?
22:58:21 <sm> gtk2
22:58:44 <sm> I guess this is the first time I tried to install the quartz variant
23:00:21 <sm> hamishmack: so is your mac new, or did you upgrade xcode ? (and if the latter, are you an ADC member ?)
23:00:36 <sm> apple seems to want me to be one
23:00:46 <mle> It doesn't cost money
23:00:46 <hamishmack> sm: Yes but it is free
23:00:49 <mle> just patience.
23:01:38 <cjs> Ha. A comment on 'copy':  "--TODO, we could coalese small blocks here"
23:02:30 <hamishmack> sm: payed members get stuff like OSX betas.  But the upgrades for XCode are available in the free ADC
23:02:45 <sm> thanks.. yay, I joined before. Now to download 1G of xcode. On my dsl link, this means leksah will wait for another day
23:03:18 <sm> hmm, maybe one more attempt to build with non-quartz gtk ?
23:03:42 <sm> no, that will mean redoing a bunch of compiles.. I'll wait
23:04:52 <sm> thanks again for the support! good night
23:08:03 <cjs> Is there Data.Binary support somewhere for reading and writing 32-bit signed integers?
23:08:24 <pumpkin_> the Get and Put instance for Int32?
23:08:34 <cjs> Oh, doh.
23:08:39 <glguy> Get and Put are (unfortunately) not separate
23:08:52 * glguy petitions for a divorce of the two
23:08:57 <pumpkin_> hm?
23:09:26 <cjs> Hm?
23:09:30 <glguy> Get and Put aren't typeclasses, Binary is
23:09:36 <cjs> Get and Put are monads.
23:09:43 <glguy> right
23:09:48 <glguy> he was talking about instances
23:09:50 <pumpkin_> oh, right
23:09:54 <pumpkin_> yeah, I see what you mean
23:10:03 <cjs> Hm. What advantage would the separation bring?
23:10:43 <glguy> so you could implement one and not the other
23:10:50 <glguy> and not have to have a wart/undefined
23:11:15 <cjs> Hm. I'm not entirely clear on where that would be so terribly useful....
23:11:40 <glguy> when you are writing your own instances, you don't necessarily need to implement both
23:11:45 <glguy> depending on the application
23:11:51 <glguy> they don't depend on each other
23:12:03 <glguy> so it would be nice if they didn't belong to the same class
23:12:08 <glguy> there isn't anything more to it
23:15:15 <davidL> @seen marko
23:15:15 <lambdabot> I saw marko leaving #haskell 6h 3m 38s ago, and .
23:17:43 <jberryman> what's the right way to do this?:
23:17:52 <jberryman> @type (\x y-> liftM (,) x `ap` y)
23:17:53 <lambdabot> forall a1 a (m :: * -> *). (Monad m) => m a1 -> m a -> m (a1, a)
23:18:38 <glguy> :t liftM2 (,)
23:18:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
23:20:04 <jberryman> glguy: awesome, thank you
23:28:08 <SubStack> @pl (\line -> hPutStrLn handle =<< parseCommand world line)
23:28:09 <lambdabot> (hPutStrLn handle =<<) . parseCommand world
23:28:38 <glguy> :t (<=<)
23:28:40 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:28:45 <glguy> SubStack, ^
23:29:39 <SubStack>  :o
23:29:41 <SubStack> laaaaag
23:30:28 <SubStack> neat
23:30:34 <SubStack> glguy++
23:31:30 <Axman6> @check \a b -> let mod' x y = let ac1 = x `div` y; ac2 = ac1 * y; ac3 = ac2 - x; -ac3 in b == 0 ||  mod' a b == mod a b
23:31:30 <lambdabot>   Parse error at "in" (column 80)
23:32:58 <Axman6> @check \a b -> let mod' x y = -(((x `div` y) * y) - x) in b == 0 ||  mod' a b == mod a b
23:32:59 <lambdabot>   "OK, passed 500 tests."
23:33:02 <Axman6> whoot
23:34:40 <dolio> > let x + 1 + 1 = x in 2 + 1
23:34:42 <lambdabot>   1
23:34:51 <dolio> > let x + 1 + 1 + 1 = x in 2 + 2
23:34:52 <lambdabot>   <no location info>: Parse error in pattern
23:42:02 * pumpkin_ is trying to make a simple algebraic structure typeclass hierarchy
23:43:13 <pumpkin_> but I got stuck
23:43:59 <adrian___> good morning
23:44:44 <adrian___> say I have two data constructors, data A = A B and data B = B Int
23:45:14 <adrian___> this way I can have A _|_ and A (B _|_)
23:45:30 <adrian___> if I say data A = A B!
23:45:47 <adrian___> I can still have A (B _|_), but not A _|_, right?
23:47:03 <glguy> yeah, (but it is  A !B
23:47:06 <glguy> )
23:47:19 <adrian___> thanks
23:47:41 <adrian___> do I need some pragma?
23:47:48 <glguy> no
23:47:52 <adrian___> great
23:47:55 <glguy> not for data type definitions
23:49:36 <adrian___> ah, but it doesn't work with record syntax?
23:50:10 <glguy> it should
23:50:49 <glguy> data A = B {c :: !Int}
23:51:52 <adrian___> it does, thanks again
